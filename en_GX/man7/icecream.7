.\" -*- coding: us-ascii -*-
.if \n(.g .ds T< \\FC
.if \n(.g .ds T> \\F[\n[.fam]]
.de URL
\\$2 \(la\\$1\(ra\\$3
..
.if \n(.g .mso www.tmac
.TH icecream 7 "April 21th, 2005" "" ""
.SH NAME
icecream \- A distributed compile system
.SH DESCRIPTION
Icecream be a gangbangin' finger-lickin' distributed compile system fo' C n' C++.
.PP
Icecream is pimped by SUSE n' is based on scams n' code by distcc. Like
distcc it takes compile thangs from yo' build n' distributes it ta remote
machines allowin a parallel build on nuff muthafuckin machines you have got. But unlike
distcc Icecream uses a cold-ass lil central server dat schedulez tha compile thangs ta the
fastest free server n' be as dis dynamic. This advantage pays off mostly for
shared computers, if yo ass is tha only user on X machines, you have full control
over dem anyway.
.SH "HOW TO USE ICECREAM"
Yo ass need:
.TP 0.2i
\(bu
One machine dat runs tha scheduler
(\fBicecc-schedula \*(T<\fB\-d\fR\*(T>\fR)
.TP 0.2i
\(bu
Many machines dat run tha daemon
(\fBiceccd \*(T<\fB\-d\fR\*(T>\fR)
.PP
If you wanna compile rockin icecream, make sure
\*(T<\fI$prefix/lib/icecc/bin\fR\*(T>
is tha straight-up original gangsta entry up in yo' path, e.g. type
\fBexport PATH=/usr/lib/icecc/bin:$PATH\fR
(Hint: put dis up in \*(T<\fI~/.bashrc\fR\*(T> or \*(T<\fI/etc/profile\fR\*(T>
to not gotta type it up in everytime)
.PP
Then you just compile with
\fBmake \*(T<\fB\-j \fR\*(T>\fInum\fB\fR,
where \*(T<num\*(T> is tha amount of thangs you wanna compile up in parallel.
Do not exaggerate. Too big-ass numbers can overload yo' machine or tha compile cluster
and make tha build up in fact slower.
.PP
.RS 
\fBWarning\fR

Never use icecream up in untrusted environments, n' you can put dat on yo' toast. Run tha daemons and
the schedula as unpriviliged user up in such networks if you have to! But you will
have ta rely on homogeneous networks then (see below).
.RE
.PP
If you want a overview of yo' icecream compile cluster, or if you just want funky stats,
you might wanna run icemon.
.SH "USING ICECREAM IN HETEROGENEOUS ENVIRONMENTS"
If yo ass is hustlin icecream daemons up in tha same icecream
network but on machines wit incompatible compila versions, icecream need ta send
your build environment ta remote machines (note: they \fIall\fR must be hustlin as
root if compiled without libcap-ng support. In tha future icecream might bust tha mobilitizzle ta know when machines cannot
accept a gangbangin' finger-lickin' different environment yo, but fo' now it be all or nothing).
.PP
Under aiiight circumstances dis is handled transparently by tha icecream
daemon, which will prepare a tarbizzle wit tha environment when needed.
This is tha recommended way, as tha daemon will also automatically update
the tarbizzle whenever yo' compila chizzles.
.PP
If you wanna handle dis manually fo' some reason, you gotta tell
icecream which environment yo ass is using. Use \fBicecc \*(T<\fB\-\-build\-native\fR\*(T>\fR to
create a archive file containin all tha filez necessary ta setup tha compiler
environment. Da file gonna git a random unique name like
\*(T<\fIddaea39ca1a7c88522b185eca04da2d8.tar.bz2\fR\*(T> per default. Rename it ta something
more expressive fo' yo' convenience, e.g. \*(T<\fIi386\-3.3.1.tar.bz2\fR\*(T>. Right back up in yo muthafuckin ass. Set
\fBICECC_VERSION=\fIfilename_of_archive_containing_your_environment\fB\fR
in tha shell environment where you start tha compile thangs n' tha file will be
transfered ta tha daemons where yo' compile thangs run n' installed ta a cold-ass lil chroot
environment fo' executin tha compile thangs up in tha environment fittin ta the
environment of tha client. This requires dat tha icecream daemon runs as root.
.SH "CROSS-COMPILING USING ICECREAM"
SUSE gots like some phat machines not havin a processor from Intel or
AMD, so icecream is pretty phat up in rockin cross-compila environments similar
to tha above way of spreadin compilers. There tha ICECC_VERSION variable looks
like
\*(T<<native_filename>(,<platform>:<cross_compiler_filename>)*\*(T>,
for example like this:
\*(T</work/9.1\-i386.tar.bz2,ia64:/work/9.1\-cross\-ia64.tar.bz2\*(T>
.PP
How tha fuck ta package such a cold-ass lil cross compila is pretty straightforward if you look
what is inside tha tarballs generated by
\fBicecc \*(T<\fB\-\-build\-native\fR\*(T>\fR.
.SH "CROSS-COMPILING FOR EMBEDDED TARGETS USING ICECREAM"
When buildin fo' embedded targets like ARM often you gonna git a toolchain
that runs on yo' host n' produces code fo' tha target. In these thangs you
can exploit tha juice of icecream as well.
.PP
Smoke symlinks from where icecc is ta tha name of yo' cross compilers
(e.g. \*(T<\fIarm\-linux\-g++\fR\*(T> and
\*(T<\fIarm\-linux\-gcc\fR\*(T>), make shizzle dat these symlinks is up in the
path n' before tha path of yo' toolchain, wit \*(T<$ICECC_CC\*(T>
and \*(T<$ICECC_CXX\*(T> you need ta tell icecream which compilaz to
use fo' preprocessin n' local compiling. e.g. set it to
\fBICECC_CC=arm-linux-gcc\fR and
\fBICECC_CXX=arm-linux-g++\fR.
.PP
As tha next step you need ta create a \*(T<.tar.bz2\*(T>
of yo' cross compiler,
check tha result of build-natizzle ta peep what tha fuck need ta be present.
.PP
Finally one need ta set \*(T<ICECC_VERSION\*(T> n' point it to
the \*(T<.tar.bz2\*(T> you have pimped.
When you start compilin yo' toolchain is ghon be used.
.PP
.RS 
\fBNote\fR

With \*(T<ICECC_VERSION\*(T> you point up on which
platforms yo' toolchain runs, you do not indicate fo' which target code will be
generated.
.RE
.SH "CROSS-COMPILING FOR MULTIPLE TARGETS IN THE SAME ENVIRONMENT USING ICECREAM"
When hustlin wit toolchains fo' multiple targets, icecream can be
configured ta support multiple toolchains up in tha same environment.
.PP
Multiple toolchains can be configured by appendin =<target> ta the
tarbizzle filename up in tha \*(T<ICECC_VERSION\*(T> variable. Where tha <target> is
the cross compila prefix. There tha \*(T<ICECC_VERSION\*(T> variable will look
like <native_filename>(,<platform>:<cross_compiler_filename>=<target>)*.
.PP
Below a example of how tha fuck ta configure icecream ta use two toolchains,
/work/toolchain1/bin/arm-eabi-[gcc,g++] n' /work/toolchain2/bin/arm-linux-androideabi-[gcc,g++],
for tha same host architecture:
.TP 0.2i
\(bu
Smoke symbolic links wit tha cross compilaz names
(e.g. arm-eabi-[gcc,g++] n' arm-linux-androideabi-[gcc,g++])
pointin ta where tha icecc binary is. Make shizzle these symbolic links are
in tha $PATH n' before tha path of tha toolchains.
.TP 0.2i
\(bu
Smoke a tarbizzle file fo' each toolchain dat you wanna use with
icecream. Da \*(T<\fI/usr/lib/icecc/icecc\-create\-env\fR\*(T> script can be used to
create tha tarbizzle file fo' each toolchain, fo' example:
\fB/usr/lib/icecc/icecc-create-env --gcc /work/toolchain1/bin/arm-eabi-gcc
/work/toolchain1/bin/arm-eabi-g++\fR
\fB/usr/lib/icecc/icecc-create-env --gcc /work/toolchain2/bin/arm-linux-androideabi-gcc
/work/toolchain2/bin/arm-linux-androideabi-gcc\fR.
.TP 0.2i
\(bu
Set \*(T<ICECC_VERSION\*(T> ta point ta tha natizzle tarbizzle file n' fo' each
tarbizzle file pimped ta tha toolchains (e.g \*(T<ICECC_VERSION\*(T>=/work/i386-native.tar.gz,/work/arm-eabi-toolchain1.tar.gz=arm-eabi,/work/arm-linux-androideabi-toolchain2.tar.gz=arm-linux-androideabi).
.PP
With these steps tha icecrem will use \*(T<\fI/work/arm\-eabi\-toolchain1.tar.gz\fR\*(T>
file ta cross compilaz wit tha prefix \*(T<arm\-eabi\*(T>
(e.g. \fBarm-eabi-gcc\fR n' \fBarm-eabi-g++\fR), use
\*(T<\fI/work/arm\-linux\-androideabi\-toolchain2.tar.gz\fR\*(T>
file ta cross compilaz wit tha prefix \*(T<arm\-linux\-androideabi\*(T>
(e.g. \fBarm-linux-androideabi-gcc\fR n' \fBarm-linux-androideabi-g++\fR)
and use \*(T<\fI/work/i386\-native.tar.gz\fR\*(T> file ta compilaz without prefix,
the natizzle compilers.
.SH "HOW TO COMBINE ICECREAM WITH ccache"
Da easiest way ta use ccache wit icecream is ta set \*(T<CCACHE_PREFIX\*(T>
to icecc (the actual icecream client wrapper)

.nf
\*(T<\fBexport CCACHE_PREFIX=icecc\fR\*(T>
.fi
.PP
This will make ccache prefix any compilation command it need ta do wit icecc,
makin it use icecream fo' tha compilation (but not fo' preprocessin alone).
.PP
To straight-up use ccache, tha mechanizzle is tha same ol' dirty like wit rockin icecream ridin' solo.
Since ccache do not provide any symlinks in
\*(T<\fI/opt/ccache/bin\fR\*(T>,
you can create dem manually:

.nf
\*(T<mkdir /opt/ccache/bin
ln \-s /usr/bin/ccache /opt/ccache/bin/gcc
ln \-s /usr/bin/ccache /opt/ccache/bin/g++\*(T>
.fi
.PP
And then compile with

.nf
\*(T<export PATH=/opt/ccache/bin:$PATH\*(T>
.fi
.PP
Note however dat ccache aint straight-up worth tha shiznit if yo ass is not
recompilin yo' project three times a thugged-out dizzle from scratch (it addz like some overhead
in comparin tha preprocessor output n' uses like some disc space n' I found
a cache hit of 18% a lil' bit too few, so I disabled it again).
.SH "DEBUG OUTPUT"
Yo ass can use tha environment variable \*(T<ICECC_DEBUG\*(T> to
control if icecream gives debug output or not. Right back up in yo muthafuckin ass. Set it to
\*(T<debug\*(T> ta git debug output. Da other possible joints are
\*(T<error\*(T>, \*(T<warning\*(T> n' \*(T<info\*(T>
(the \*(T<\fB\-v\fR\*(T> option fo' daemon n' schedula raise tha level per
\*(T<\fB\-v\fR\*(T> on tha command line - so use \*(T<\fB\-vvv\fR\*(T>
for full debug).
.SH "AVOIDING OLD HOSTS"
It be possible dat compilation on some hosts fails cuz they is too old
(typically tha kernel on tha remote host is too oldschool fo' tha glibc from tha local host).
Recent icecream versions should automatically detect dis n' avoid such hosts
when compilation would fail. If some hosts is hustlin oldschool icecream versions and
it aint possible ta upgrade dem fo' some reason, use

.nf
\*(T<export ICECC_IGNORE_UNVERIFIED=1\*(T>
.fi
.SH "SOME NUMBERS"
Numberz of mah test case (some STL C++ genetic algorithm)
.TP 0.2i
\(bu
\fBg++\fR on mah machine: 1.6s
.TP 0.2i
\(bu
\fBg++\fR on fast machine: 1.1s
.TP 0.2i
\(bu
icecream rockin mah machine as remote machine: 1.9s
.TP 0.2i
\(bu
icecream rockin fast machine: 1.8s
.PP
Da icecream overhead is like big-ass as you might notice yo, but tha compiler
cannot interleave preprocessin wit compilation n' tha file need ta be
read/written once mo' n' up in between tha file is transfered.
.PP
But even if tha other computa is faster, rockin \fBg++\fR on mah local machine
is fasta n' shit. If yo ass is (for whatever reason) ridin' solo up in yo' network at some point,
you lose all advantagez of distributed compilin n' only add tha overhead. Y'all KNOW dat shit, muthafucka! So
icecream gots a special case fo' local compilations (the same special meaning
that localhost gots within $DISTCC_HOSTS). This make compilin on mah machine
usin icecream down ta 1.7s (the overhead is straight-up less than 0.1s in
average).
.PP
As tha schedula be aware of dat meaning, it will prefer yo' own
computa if it is free n' gots not less than 70% of tha fastest available
computer.
.PP
Keep it realz in mind, dat dis affects only tha straight-up original gangsta compile thang, tha second one
is distributed anyway. Right back up in yo muthafuckin ass. So if I had ta compile two of mah files, I would get
.TP 0.2i
\(bu
\fBg++ \*(T<\fB\-j1\fR\*(T>\fR on mah machine: 3.2s
.TP 0.2i
\(bu
\fBg++ \*(T<\fB\-j1\fR\*(T>\fR on tha fast machine: 2.2s
.TP 0.2i
\(bu
usin icecream \*(T<\fB\-j2\fR\*(T> on mah machine: max(1.7,1.8)=1.8s
.TP 0.2i
\(bu
(usin icecream \*(T<\fB\-j2\fR\*(T> on tha other machine: max(1.1,1.8)=1.8s)
.PP
Da math be a lil' bit tricky n' dependz a shitload on tha current state of the
compilation network yo, but make shizzle yo ass is not blindly assuming
\fBmake \*(T<\fB\-j2\fR\*(T>\fR halves yo' compilation time.
.SH "WHAT IS THE BEST ENVIRONMENT FOR ICECREAM"
In most requirements icecream aint special, e.g. it do not matta what
distributed compile system you use, yo big-ass booty is ghon not have funk if yo' nodes are
connected all up in than less or equal ta 10MBit. Note dat icecream compresses
input n' output filez (usin \*(T<lzo\*(T>), so you can calc wit ~1MBit per compile thang
- i.e. mo' than \fBmake \*(T<\fB\-j10\fR\*(T>\fR will not
be possible without delays.
.PP
Remember dat mo' machines is only phat if you can use massive
parallelization yo, but yo big-ass booty is ghon fo' shizzle git tha dopest result if yo' submitting
machine (the one you called \fBg++\fR on) is ghon be fast enough ta feed tha others.
Especially if yo' project consistz of nuff easy as fuck  ta compile files, the
preprocessin n' file I/O is ghon be thang enough ta need a quick machine.
.PP
Da schedula will try ta hit you wit tha fastest machines available, so even
if you add oldschool machines, they is ghon be used only up in exceptionizzle thangs yo, but
still you can have wack luck - tha schedula do not know how tha fuck long a thang will
take before it started. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Right back up in yo muthafuckin ass. So if you have 3 machines n' two quick ta compile and
one long ta compile source file, yo ass is not safe from a cold-ass lil chizzle where everyone
has ta wait on tha slow machine. Keep dat up in mind.
.SH "NETWORK SETUP FOR ICECREAM (FIREWALLS)"
A short overview of tha ports icecream requires:
.TP 0.2i
\(bu
TCP/10245 on tha daemon computas (required)
.TP 0.2i
\(bu
TCP/8765 fo' tha the schedula computa (required)
.TP 0.2i
\(bu
TCP/8766 fo' tha telnet intercourse ta tha schedula (optional)
.TP 0.2i
\(bu
UDP/8765 fo' broadcast ta find tha schedula (optional)
.PP
If tha monitor cannot find tha scheduler, use
\fBUSE_SCHEDULER=\fIhost\fB icemon\fR.
.SH "SEE ALSO"
icecc-scheduler(1), iceccd(1), icemon(1)
.SH "ICECREAM AUTHORS"
Stephan Kulow <coolo@suse.de>
.PP
Mike Matz <matz@suse.de>
.PP
Cornelius Schumacher <cschum@suse.de>
.PP
\&...and various other contributors.
