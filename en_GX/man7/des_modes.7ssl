.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DES_MODES 7"
.TH DES_MODES 7 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
des_modes \- tha variantz of DES n' other crypto algorithmz of OpenSSL
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Several crypto algorithms fo' OpenSSL can be used up in a fuckin shitload of modes.  Those
are used fo' rockin block ciphers up in a way similar ta stream ciphers, among
other thangs.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
.SS "Electronic Codebook Mode (\s-1ECB\s0)"
.IX Subsection "Electronic Codebook Mode (ECB)"
Normally, dis is found as tha function \fIalgorithm\fR\fI_ecb_encrypt()\fR.
.IP "\(bu" 2
64 bits is enciphered at a time.
.IP "\(bu" 2
Da order of tha blocks can be rearranged without detection.
.IP "\(bu" 2
Da same plaintext block always produces tha same ol' dirty ciphertext block
(for tha same key) makin it vulnerable ta a 'doggtionary attack'.
.IP "\(bu" 2
An error will only affect one ciphertext block.
.SS "Cipher Block Chainin Mode (\s-1CBC\s0)"
.IX Subsection "Cipher Block Chainin Mode (CBC)"
Normally, dis is found as tha function \fIalgorithm\fR\fI_cbc_encrypt()\fR.
Be aware dat \fIdes_cbc_encrypt()\fR aint straight-up \s-1DES STD \s0(it do
not update tha \s-1IV\s0); use \fIdes_ncbc_encrypt()\fR instead.
.IP "\(bu" 2
a multiple of 64 bits is enciphered at a time.
.IP "\(bu" 2
Da \s-1CBC\s0 mode produces tha same ol' dirty ciphertext whenever tha same
plaintext is encrypted rockin tha same key n' startin variable.
.IP "\(bu" 2
Da chainin operation make tha ciphertext blocks dependent on the
current n' all precedin plaintext blocks n' therefore blocks can not
be rearranged.
.IP "\(bu" 2
Da use of different startin variablez prevents tha same ol' dirty plaintext
encipherin ta tha same ciphertext.
.IP "\(bu" 2
An error will affect tha current n' tha followin ciphertext blocks.
.SS "Cipher Feedback Mode (\s-1CFB\s0)"
.IX Subsection "Cipher Feedback Mode (CFB)"
Normally, dis is found as tha function \fIalgorithm\fR\fI_cfb_encrypt()\fR.
.IP "\(bu" 2
a number of bits (j) <= 64 is enciphered at a time.
.IP "\(bu" 2
Da \s-1CFB\s0 mode produces tha same ol' dirty ciphertext whenever tha same
plaintext is encrypted rockin tha same key n' startin variable.
.IP "\(bu" 2
Da chainin operation make tha ciphertext variablez dependent on the
current n' all precedin variablez n' therefore j\-bit variablez are
chained together n' can not be rearranged.
.IP "\(bu" 2
Da use of different startin variablez prevents tha same ol' dirty plaintext
encipherin ta tha same ciphertext.
.IP "\(bu" 2
Da strength of tha \s-1CFB\s0 mode dependz on tha size of k (maximal if
j == k).  In mah implementation dis be always tha case.
.IP "\(bu" 2
Selection of a lil' small-ass value fo' j will require mo' cyclez through
the encipherment algorithm per unit of plaintext n' thus cause
greata processin overheads.
.IP "\(bu" 2
Only multiplez of j bits can be enciphered.
.IP "\(bu" 2
An error will affect tha current n' tha followin ciphertext variables.
.SS "Output Feedback Mode (\s-1OFB\s0)"
.IX Subsection "Output Feedback Mode (OFB)"
Normally, dis is found as tha function \fIalgorithm\fR\fI_ofb_encrypt()\fR.
.IP "\(bu" 2
a number of bits (j) <= 64 is enciphered at a time.
.IP "\(bu" 2
Da \s-1OFB\s0 mode produces tha same ol' dirty ciphertext whenever tha same
plaintext enciphered rockin tha same key n' startin variable.  Mo'
over, up in tha \s-1OFB\s0 mode tha same key stream is produced when tha same
key n' start variable is used. Y'all KNOW dat shit, muthafucka!  Consequently, fo' securitizzle reasons
a specific start variable should be used only once fo' a given key.
.IP "\(bu" 2
Da absence of chainin make tha \s-1OFB\s0 mo' vulnerable ta specific attacks.
.IP "\(bu" 2
Da use of different start variablez joints prevents tha same
plaintext encipherin ta tha same ciphertext, by producin different
key streams.
.IP "\(bu" 2
Selection of a lil' small-ass value fo' j will require mo' cyclez through
the encipherment algorithm per unit of plaintext n' thus cause
greata processin overheads.
.IP "\(bu" 2
Only multiplez of j bits can be enciphered.
.IP "\(bu" 2
\&\s-1OFB\s0 mode of operation do not extend ciphertext errors up in the
resultant plaintext output.  Every bit error up in tha ciphertext causes
only one bit ta be up in error up in tha deciphered plaintext.
.IP "\(bu" 2
\&\s-1OFB\s0 mode aint self-synchronizing.  If tha two operation of
encipherment n' decipherment git outta synchronism, tha system needs
to be re-initialized.
.IP "\(bu" 2
Each re-initialization should bust a value of tha start variable
different from tha start variable joints used before wit tha same
key.  Da reason fo' dis is dat a identical bit stream would be
produced each time from tha same parameters.  This would be
susceptible ta a 'known plaintext' attack.
.SS "Triple \s-1ECB\s0 Mode"
.IX Subsection "Triple ECB Mode"
Normally, dis is found as tha function \fIalgorithm\fR\fI_ecb3_encrypt()\fR.
.IP "\(bu" 2
Encrypt wit key1, decrypt wit key2 n' encrypt wit key3 again.
.IP "\(bu" 2
As fo' \s-1ECB\s0 encryption but increases tha key length ta 168 bits.
There is theoretic attacks dat can be used dat make tha effective
key length 112 bits yo, but dis battle also requires 2^56 blocks of
memory, not straight-up likely, even fo' tha \s-1NSA.\s0
.IP "\(bu" 2
If both keys is tha same it is equivalent ta encryptin once with
just one key.
.IP "\(bu" 2
If tha straight-up original gangsta n' last key is tha same, tha key length is 112 bits.
There is attacks dat could reduce tha effectizzle key strength
to only slightly mo' than 56 bits yo, but these require a shitload of memory.
.IP "\(bu" 2
If all 3 keys is tha same, dis is effectively tha same as normal
ecb mode.
.SS "Triple \s-1CBC\s0 Mode"
.IX Subsection "Triple STD Mode"
Normally, dis is found as tha function \fIalgorithm\fR\fI_ede3_cbc_encrypt()\fR.
.IP "\(bu" 2
Encrypt wit key1, decrypt wit key2 n' then encrypt wit key3.
.IP "\(bu" 2
As fo' \s-1CBC\s0 encryption but increases tha key length ta 168 bits with
the same restrictions as fo' triple ecb mode.
.SH "NOTES"
.IX Header "NOTES"
This text was been freestyled up in big-ass parts by Eric Young up in his original
documentation fo' SSLeay, tha predecessor of OpenSSL.  In turn, he attributed
it to:
.PP
.Vb 5
\&        AS 2805.5.2
\&        Australian Standard
\&        Electronic fundz transfer \- Requirements fo' intercourses,
\&        Part 5.2: Modez of operation fo' a n\-bit block cipher algorithm
\&        Appendix A
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIblowfish\fR\|(3), \fIdes\fR\|(3), \fIidea\fR\|(3),
\&\fIrc2\fR\|(3)
