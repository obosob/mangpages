'\" t
.\"     Title: drm
.\"    Author: Dizzy Herrmann <dh.herrmann@googlemail.com>
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: September 2012
.\"    Manual: Direct Renderin Manager
.\"    Source: libdrm
.\"  Language: Gangsta
.\"
.TH "DRM" "7" "September 2012" "libdrm" "Direct Renderin Manager"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
drm \- Direct Renderin Manager
.SH "SYNOPSIS"
.sp
.ft B
.nf
#include <xf86drm\&.h>
.fi
.ft
.SH "DESCRIPTION"
.PP
The
\fIDirect Renderin Manager\fR
(DRM) be a gangbangin' framework ta manage
\fIGraphics Processin Units\fR
(GPUs)\&. Well shiiiit, it is designed ta support tha needz of complex graphics devices, probably containin programmable pipelines well suited ta 3D graphics acceleration\&. Furthermore, it is responsible fo' memory pimpment, interrupt handlin n' DMA ta provide a uniform intercourse ta applications\&.
.PP
In earlier days, tha kernel framework was solely used ta provide raw hardware access ta priviledged user\-space processes which implement all tha hardware abstraction layers\&. But mo' n' mo' tasks where moved tha fuck into tha kernel\& fo' realz. All these intercourses is based on
\fBioctl\fR(2)
commandz on tha DRM characta device\&. The
\fIlibdrm\fR
library serves up wrappers fo' these system\-calls n' nuff helpers ta simplify tha API\&.
.PP
When a GPU is detected, tha DRM system loadz a thugged-out driver fo' tha detected hardware type\&. Each connected GPU is then presented ta user\-space via a cold-ass lil character\-device dat is probably available as
/dev/dri/card0
and can be accessed with
\fBopen\fR(2)
and
\fBclose\fR(2)\&. But fuck dat shiznit yo, tha word on tha street is dat it still dependz on tha grapics driver which intercourses is available on these devices\&. If a intercourse aint available, tha syscalls will fail with
EINVAL\&.
.SS "Authentication"
.PP
All DRM devices provide authentication mechanisms\&. Only a DRM\-Masta be allowed ta big-ass up mode\-settin or modify core state n' only one user can be DRM\-Masta at a time\&. Right back up in yo muthafuckin ass. See
\fBdrmSetMaster\fR(3)
for shiznit on how tha fuck ta become DRM\-Masta n' what tha fuck tha limitations are\&. Other DRM playas can be authenticated ta tha DRM\-Masta via
\fBdrmAuthMagic\fR(3)
so they can big-ass up buffer allocations n' rendering\&.
.SS "Mode\-Setting"
.PP
Managin connected monitors n' displays n' changin tha current modes is called
\fIMode\-Setting\fR\&. This is restricted ta tha current DRM\-Master\& yo. Historically, dis was implemented up in user\-space yo, but freshly smoked up DRM drivers implement a kernel intercourse ta big-ass up mode\-settin called
\fIKernel Mode Setting\fR
(KMS)\&. If yo' hardware\-driver supports it, you can use tha KMS API provided by DRM\&. This includes allocatin framebuffers, selectin modes n' managin CRTCs n' encoders\&. Right back up in yo muthafuckin ass. See
\fBdrm-kms\fR(7)
for more\&.
.SS "Memory Management"
.PP
Da most sophisticated tasks fo' GPUs todizzle is managin memory objects\&. Textures, framebuffers, command\-buffers n' all other kindz of commandz fo' tha GPU gotta be stored up in memory\&. Da DRM driver takes care of managin all memory objects, flushin caches, synchronizin access n' providin CPU access ta GPU memory\& fo' realz. All memory pimpment is hardware driver dependent\&. But fuck dat shiznit yo, tha word on tha street is dat two generic frameworks is available dat is used by most DRM drivers\&. These is the
\fITranslation Table Manager\fR
(TTM) n' the
\fIGraphics Execution Manager\fR
(GEM)\&. They provide generic APIs ta create, destroy n' access buffers from user\-space\&. But fuck dat shiznit yo, tha word on tha street is dat there be still nuff differences between tha drivers so driver\-depedent code is still needed\&. Many helpers is provided in
\fIlibgbm\fR
(Graphics Buffer Manager) from the
\fImesa\-project\fR\&. For mo' shiznit on DRM memory\-management, see
\fBdrm-memory\fR(7)\&.
.SH "REPORTING BUGS"
.PP
Bugs up in dis manual should be reported ta http://bugs\&.freedesktop\&.org under tha "Mesa" product, wit "Other" or "libdrm" as tha component\&.
.SH "SEE ALSO"
.PP
\fBdrm-kms\fR(7),
\fBdrm-memory\fR(7),
\fBdrmSetMaster\fR(3),
\fBdrmAuthMagic\fR(3),
\fBdrmAvailable\fR(3),
\fBdrmOpen\fR(3)
