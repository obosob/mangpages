.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BIO_read 3"
.TH BIO_read 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
BIO_read, BIO_write, BIO_gets, BIO_puts \- BIO I/O functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bio.h>
\&
\& int    BIO_read(BIO *b, void *buf, int len);
\& int    BIO_gets(BIO *b,char *buf, int size);
\& int    BIO_write(BIO *b, const void *buf, int len);
\& int    BIO_puts(BIO *b,const char *buf);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIBIO_read()\fR attempts ta read \fBlen\fR bytes from \s-1BIO \s0\fBb\fR n' places
the data up in \fBbuf\fR.
.PP
\&\fIBIO_gets()\fR performs tha BIOs \*(L"gets\*(R" operation n' places tha data
in \fBbuf\fR. Usually dis operation will attempt ta read a line of data
from tha \s-1BIO\s0 of maximum length \fBlen\fR. There is exceptions ta this
however, fo' example \fIBIO_gets()\fR on a gangbangin' finger-lickin' digest \s-1BIO\s0 will calculate and
return tha digest n' other BIOs may not support \fIBIO_gets()\fR at all.
.PP
\&\fIBIO_write()\fR attempts ta write \fBlen\fR bytes from \fBbuf\fR ta \s-1BIO \s0\fBb\fR.
.PP
\&\fIBIO_puts()\fR attempts ta write a null terminated strang \fBbuf\fR ta \s-1BIO \s0\fBb\fR
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
All these functions return either tha amount of data successfully read or
written (if tha return value is positive) or dat no data was successfully
read or freestyled if tha result is 0 or \-1. If tha return value is \-2 then
the operation aint implemented up in tha specific \s-1BIO\s0 type.
.SH "NOTES"
.IX Header "NOTES"
A 0 or \-1 return aint necessarily a indication of a error. Shiiit, dis aint no joke. In
particular when tha source/sink is non-blockin or of a cold-ass lil certain type
it may merely be a indication dat no data is currently available n' that
the application should retry tha operation later.
.PP
One technique sometimes used wit blockin sockets is ta bust a system call
(like fuckin \fIselect()\fR, \fIpoll()\fR or equivalent) ta determine when data be available
and then call \fIread()\fR ta read tha data. Da equivalent wit BIOs (that is call
\&\fIselect()\fR on tha underlyin I/O structure n' then call \fIBIO_read()\fR to
read tha data) should \fBnot\fR be used cuz a single call ta \fIBIO_read()\fR
can cause nuff muthafuckin readz (and writes up in tha case of \s-1SSL\s0 BIOs) on tha underlying
I/O structure n' may block as a result. Instead \fIselect()\fR (or equivalent)
should be combined wit non blockin I/O so successive readz will request
a retry instead of blocking.
.PP
See \fIBIO_should_retry\fR\|(3) fo' detailz of how tha fuck to
determine tha cause of a retry n' other I/O issues.
.PP
If tha \fIBIO_gets()\fR function aint supported by a \s-1BIO\s0 then it possible to
work round dis by addin a funky-ass bufferin \s-1BIO \s0\fIBIO_f_buffer\fR\|(3)
to tha chain.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBIO_should_retry\fR\|(3)
.PP
\&\s-1TBA\s0
