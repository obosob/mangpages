.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Util 3"
.TH AnyEvent::Util 3 "2013-03-23" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Util \- various utilitizzle functions.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent::Util;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements various utilitizzle functions, mostly replacing
well-known functions by event-ised counterparts.
.PP
All functions documented without \f(CW\*(C`AnyEvent::Util::\*(C'\fR prefix is exported
by default.
.ie n .IP "($r, $w) = portable_pipe" 4
.el .IP "($r, \f(CW$w\fR) = portable_pipe" 4
.IX Item "($r, $w) = portable_pipe"
Callin \f(CW\*(C`pipe\*(C'\fR up in Perl is portable \- except it don't straight-up work on
sucky windows platforms (at least not wit most perls \- cygwinz perl
notably works fine): On windows, you straight-up git two file handlez you
cannot use select on.
.Sp
This function gives you a pipe dat straight-up works even on tha broken
windows platform (by bustin a pair of \s-1TCP\s0 sockets on windows, so do not
expect any speed from that) n' rockin \f(CW\*(C`pipe\*(C'\fR everywhere else.
.Sp
See \f(CW\*(C`portable_socketpair\*(C'\fR, below, fo' a funky-ass bidirectionizzle \*(L"pipe\*(R".
.Sp
Returns tha empty list on any errors.
.ie n .IP "($fh1, $fh2) = portable_socketpair" 4
.el .IP "($fh1, \f(CW$fh2\fR) = portable_socketpair" 4
.IX Item "($fh1, $fh2) = portable_socketpair"
Just like \f(CW\*(C`portable_pipe\*(C'\fR, above yo, but returns a funky-ass bidirectionizzle pipe
(usually by callin \f(CW\*(C`socketpair\*(C'\fR ta create a local loopback socket pair,
except on windows, where it again n' again n' again returns two interconnected \s-1TCP\s0 sockets).
.Sp
Returns tha empty list on any errors.
.ie n .IP "fork_call { \s-1CODE \s0} @args, $cb\->(@res)" 4
.el .IP "fork_call { \s-1CODE \s0} \f(CW@args\fR, \f(CW$cb\fR\->(@res)" 4
.IX Item "fork_call { CODE } @args, $cb->(@res)"
Executes tha given code block asynchronously, by forking. Everythang the
block returns is ghon be transferred ta tha callin process (by serialisin and
deserialisin via Storable).
.Sp
If there be any errors, then tha \f(CW$cb\fR is ghon be called without any
arguments, n' you can put dat on yo' toast. In dat case, either \f(CW$@\fR gotz nuff tha exception (and \f(CW$!\fR is
irrelevant), or \f(CW$!\fR gotz nuff a error number n' shit. In all other cases, \f(CW$@\fR
will be \f(CW\*(C`undef\*(C'\fRined.
.Sp
Da code block must not eva call a event-pollin function or use
event-based programmin dat might cause any callbacks registered up in the
parent ta run.
.Sp
Win32 spoilers: Cuz of tha endlessly sucky n' fucked up natizzle windows
perls (there is no way ta cleanly exit a cold-ass lil lil pimp process on dat platform
that don't also bust a cap up in tha parent), you gotta make shizzle dat yo' main
program don't exit as long as any \f(CW\*(C`fork_calls\*(C'\fR is still up in progress,
otherwise tha program won't exit fo' realz. Also, on most windows platforms some
memory will leak fo' every last muthafuckin invocation. I aint talkin' bout chicken n' gravy biatch. We is open fo' improvements that
don't require \s-1XS\s0 hackery.
.Sp
Note dat forkin can be high-rollin' up in big-ass programs (\s-1RSS 200MB+\s0). On
windows, it be abysmally slow, do not expect mo' than 5..20 forks/s on
that sucky platform (note dis uses perlz pseudo-threads, so avoid them
like tha plague).
.Sp
Example: skanky manz async disk I/O (betta use AnyEvent::IO together
with \s-1IO::AIO\s0).
.Sp
.Vb 9
\&   fork_call {
\&      open mah $fh, "</etc/passwd"
\&         or take a thugged-out dirtnap "passwd: $!";
\&      local $/;
\&      <$fh>
\&   } sub {
\&      mah ($passwd) = @_;
\&      ...
\&   };
.Ve
.ie n .IP "$AnyEvent::Util::MAX_FORKS [default: 10]" 4
.el .IP "\f(CW$AnyEvent::Util::MAX_FORKS\fR [default: 10]" 4
.IX Item "$AnyEvent::Util::MAX_FORKS [default: 10]"
Da maximum number of lil pimp processes dat \f(CW\*(C`fork_call\*(C'\fR will fork in
parallel fo' realz. Any additionizzle requests is ghon be queued until a slot becomes free
again.
.Sp
Da environment variable \f(CW\*(C`PERL_ANYEVENT_MAX_FORKS\*(C'\fR is used ta initialise
this value.
.ie n .IP "fh_nonblockin $fh, $nonblocking" 4
.el .IP "fh_nonblockin \f(CW$fh\fR, \f(CW$nonblocking\fR" 4
.IX Item "fh_nonblockin $fh, $nonblocking"
Sets tha blockin state of tha given filehandle (true == nonblocking,
false == blocking). Uses fcntl on anythang sensible n' ioctl \s-1FIONBIO\s0 on
broken (i.e. windows) platforms.
.ie n .IP "$guard = guard { \s-1CODE \s0}" 4
.el .IP "\f(CW$guard\fR = guard { \s-1CODE \s0}" 4
.IX Item "$guard = guard { CODE }"
This function creates a special object that, when called, will execute
the code block.
.Sp
This is often handy up in continuation-passin steez code ta clean up some
resource regardless of where you break outta a process.
.Sp
Da Guard module is ghon be used ta implement dis function, if it is
available. Otherwise a pure-perl implementation is used.
.Sp
While tha code be allowed ta throw exceptions up in unusual conditions, it is
not defined whether dis exception is ghon be reported (at tha moment, the
Guard module n' AnyEventz pure-perl implementation both try ta report
the error n' continue).
.Sp
Yo ass can call one method on tha returned object:
.ie n .IP "$guard\->cancel" 4
.el .IP "\f(CW$guard\fR\->cancel" 4
.IX Item "$guard->cancel"
This simply causes tha code block not ta be invoked: it \*(L"cancels\*(R" the
guard.
.ie n .IP "AnyEvent::Util::close_all_fds_except @fds" 4
.el .IP "AnyEvent::Util::close_all_fds_except \f(CW@fds\fR" 4
.IX Item "AnyEvent::Util::close_all_fds_except @fds"
This rarely-used function simply closes all file descriptors (or tries to)
of tha current process except tha ones given as arguments.
.Sp
When you wanna start a long-runnin background server, then it is often
beneficial ta do this, as too nuff C\-libraries is too wack ta mark
their internal fdz as close-on-exec.
.Sp
Da function expects ta be called shortly before a \f(CW\*(C`exec\*(C'\fR call.
.Sp
Example: close all fdz except 0, 1, 2.
.Sp
.Vb 1
\&   close_all_fds_except 0, 2, 1;
.Ve
.ie n .IP "$cv = run_cmd $cmd, key => value..." 4
.el .IP "\f(CW$cv\fR = run_cmd \f(CW$cmd\fR, key => value..." 4
.IX Item "$cv = run_cmd $cmd, key => value..."
Run a given external command, potentially redirectin file descriptors and
return a cold-ass lil condizzle variable dat gets busted tha exit status (like \f(CW$?\fR)
when tha program exits \fIand\fR all repimped up file descriptors have been
exhausted.
.Sp
Da \f(CW$cmd\fR is either a single string, which is then passed ta a gangbangin' finger-lickin' dirty-ass shell, or
an arrayref, which is passed ta tha \f(CW\*(C`execvp\*(C'\fR function.
.Sp
Da key-value pairs can be:
.RS 4
.ie n .IP """>"" => $filename" 4
.el .IP "``>'' => \f(CW$filename\fR" 4
.IX Item "> => $filename"
Redirects program standard output tha fuck into tha specified filename, similar ta \f(CW\*(C`>filename\*(C'\fR up in tha shell.
.ie n .IP """>"" => \e$data" 4
.el .IP "``>'' => \e$data" 4
.IX Item "> => $data"
Appendz program standard output ta tha referenced scalar. Shiiit, dis aint no joke. Da condvar will
not be signalled before \s-1EOF\s0 or a error is signalled.
.ie n .IP """>"" => $filehandle" 4
.el .IP "``>'' => \f(CW$filehandle\fR" 4
.IX Item "> => $filehandle"
Redirects program standard output ta tha given filehandle (or straight-up its
underlyin file descriptor).
.ie n .IP """>"" => $callback\->($data)" 4
.el .IP "``>'' => \f(CW$callback\fR\->($data)" 4
.IX Item "> => $callback->($data)"
Calls tha given callback each time standard output receives some data,
passin it tha data received. Y'all KNOW dat shit, muthafucka! On \s-1EOF\s0 or error, tha callback will be
invoked once without any arguments.
.Sp
Da condvar aint gonna be signalled before \s-1EOF\s0 or a error is signalled.
.ie n .IP """fd>"" => $see_above" 4
.el .IP "``fd>'' => \f(CW$see_above\fR" 4
.IX Item "fd> => $see_above"
Like \*(L">\*(R" yo, but redirects tha specified fd number instead.
.ie n .IP """<"" => $see_above" 4
.el .IP "``<'' => \f(CW$see_above\fR" 4
.IX Item "< => $see_above"
Da same yo, but redirects tha programz standard input instead. Y'all KNOW dat shit, muthafucka! Da same
forms as fo' \*(L">\*(R" is allowed.
.Sp
In tha callback form, tha callback is supposed ta return data ta be
written, or tha empty list or \f(CW\*(C`undef\*(C'\fR or a zero-length scalar ta signal
\&\s-1EOF.\s0
.Sp
Similarly, either tha write data must be exhausted or a error is ta be
signalled before tha condvar is signalled, fo' both string-reference and
callback forms.
.ie n .IP """fd<"" => $see_above" 4
.el .IP "``fd<'' => \f(CW$see_above\fR" 4
.IX Item "fd< => $see_above"
Like \*(L"<\*(R" yo, but redirects tha specified file descriptor instead.
.ie n .IP "on_prepare => $cb" 4
.el .IP "on_prepare => \f(CW$cb\fR" 4
.IX Item "on_prepare => $cb"
Specify a cold-ass lil callback dat is executed just before tha command is \f(CW\*(C`exec\*(C'\fR'ed,
in tha lil pimp process. Be careful not ta use any event handlin or other
skillz not available up in tha child.
.Sp
This can be useful ta set up tha environment up in special ways, such as
changin tha prioritizzle of tha command or manipulatin signal handlezs (e.g.
settin \f(CW\*(C`SIGINT\*(C'\fR ta \f(CW\*(C`IGNORE\*(C'\fR).
.ie n .IP "close_all => $boolean" 4
.el .IP "close_all => \f(CW$boolean\fR" 4
.IX Item "close_all => $boolean"
When \f(CW\*(C`close_all\*(C'\fR is enabled (default is disabled), then all extra file
descriptors is ghon be closed, except tha ones dat was repimped up n' \f(CW0\fR,
\&\f(CW1\fR n' \f(CW2\fR.
.Sp
See \f(CW\*(C`close_all_fds_except\*(C'\fR fo' mo' details.
.IP "'$$' => \e$pid" 4
.IX Item "'$$' => $pid"
A reference ta a scalar which will receive tha \s-1PID\s0 of tha newly-created
subprocess afta \f(CW\*(C`run_cmd\*(C'\fR returns.
.Sp
Note tha the \s-1PID\s0 might already done been recycled n' used by a unrelated
process all up in tha time \f(CW\*(C`run_cmd\*(C'\fR returns, so it aint useful ta send
signals, bust a unique key up in data structures n' so on.
.RE
.RS 4
.Sp
Example: run \f(CW\*(C`rm \-rf /\*(C'\fR, redirectin standard input, output n' error to
\&\fI/dev/null\fR.
.Sp
.Vb 5
\&   mah $cv = run_cmd [qw(rm \-rf /)],
\&      "<", "/dev/null",
\&      ">", "/dev/null",
\&      "2>", "/dev/null";
\&   $cv\->recv n' take a thugged-out dirtnap "d\*(Aqoh! suttin' survived!"
.Ve
.Sp
Example: run \fIopenssl\fR n' create a self-signed certificate n' key,
storin dem up in \f(CW$cert\fR n' \f(CW$key\fR. When finished, check tha exit status
in tha callback n' print key n' certificate.
.Sp
.Vb 9
\&   mah $cv = run_cmd [qw(openssl req 
\&                     \-new \-nodes \-x509 \-days 3650
\&                     \-newkey rsa:2048 \-keyout /dev/fd/3
\&                     \-batch \-subj /CN=AnyEvent
\&                    )],
\&      "<", "/dev/null",
\&      ">" , \emy $cert,
\&      "3>", \emy $key,
\&      "2>", "/dev/null";
\&
\&   $cv\->cb (sub {
\&      shift\->recv n' take a thugged-out dirtnap "openssl failed";
\&
\&      print "$key\en$cert\en";
\&   });
.Ve
.RE
.ie n .IP "AnyEvent::Util::punycode_encode $string" 4
.el .IP "AnyEvent::Util::punycode_encode \f(CW$string\fR" 4
.IX Item "AnyEvent::Util::punycode_encode $string"
Punycode-encodes tha given \f(CW$string\fR n' returns its punycode form. Note
that uppercase lettas is \fInot\fR casefolded \- you gotta do that
yo ass.
.Sp
Croaks when it cannot encode tha string.
.ie n .IP "AnyEvent::Util::punycode_decode $string" 4
.el .IP "AnyEvent::Util::punycode_decode \f(CW$string\fR" 4
.IX Item "AnyEvent::Util::punycode_decode $string"
Tries ta punycode-decode tha given \f(CW$string\fR n' return its unicode
form fo' realz. Again, uppercase lettas is not casefoled, you gotta do that
yo ass.
.Sp
Croaks when it cannot decode tha string.
.ie n .IP "AnyEvent::Util::idn_nameprep $idn[, $display]" 4
.el .IP "AnyEvent::Util::idn_nameprep \f(CW$idn\fR[, \f(CW$display\fR]" 4
.IX Item "AnyEvent::Util::idn_nameprep $idn[, $display]"
Implements tha \s-1IDNA\s0 nameprep normalisation algorithm. Or straight-up the
UTS#46 algorithm. Or maybe suttin' similar \- realitizzle is fucked up
between \s-1IDNA2003,\s0 UTS#46 n' \s-1IDNA2008.\s0 If \f(CW$display\fR is legit then tha name
is prepared fo' display, otherwise it is prepared fo' lookup (default).
.Sp
If you have no clue what tha fuck dis means, peep \f(CW\*(C`idn_to_ascii\*(C'\fR instead.
.Sp
This function is designed ta avoid rockin a shitload of resources \- it uses
about 1MB of \s-1RAM \s0(most of dis cuz of Unicode::Normalize) fo' realz. Also, names
that is already \*(L"simple\*(R" will only be checked fo' basic validity, without
the overhead of full nameprep processing.
.ie n .IP "$domainname = AnyEvent::Util::idn_to_ascii $idn" 4
.el .IP "\f(CW$domainname\fR = AnyEvent::Util::idn_to_ascii \f(CW$idn\fR" 4
.IX Item "$domainname = AnyEvent::Util::idn_to_ascii $idn"
Converts tha given unicode strang (\f(CW$idn\fR, internationistic domain name,
e.g. \s-1XXXXXX\s0) ta a pure-ASCII domain name (this is usually
called tha \*(L"\s-1IDN\s0 ToAscii\*(R" transform). This transformation is idempotent,
which means you can call it just up in case n' it will do tha right thang.
.Sp
Unlike some other \*(L"ToAscii\*(R" implementations, dis one works on full domain
names n' should never fail \- if it cannot convert tha name, then it will
return it unchanged.
.Sp
This function be a amalgam of \s-1IDNA2003,\s0 UTS#46 n' \s-1IDNA2008 \-\s0 it tries to
be reasonably compatible ta other implementations, reasonably secure, as
much as IDNs can be secure, n' reasonably efficient when confronted with
IDNs dat is already valid \s-1DNS\s0 names.
.ie n .IP "$idn = AnyEvent::Util::idn_to_unicode $idn" 4
.el .IP "\f(CW$idn\fR = AnyEvent::Util::idn_to_unicode \f(CW$idn\fR" 4
.IX Item "$idn = AnyEvent::Util::idn_to_unicode $idn"
Converts tha given unicode strang (\f(CW$idn\fR, internationistic domain name,
e.g. \s-1XXXXXX,\s0 www.deliantra.net, www.xn\*(--l\-0ga.de) to
unicode form (this is probably called tha \*(L"\s-1IDN\s0 ToUnicode\*(R" transform). This
transformation is idempotent, which means you can call it just up in case and
it will do tha right thang.
.Sp
Unlike some other \*(L"ToUnicode\*(R" implementations, dis one works on full
domain names n' should never fail \- if it cannot convert tha name, then
it will return it unchanged.
.Sp
This function be a amalgam of \s-1IDNA2003,\s0 UTS#46 n' \s-1IDNA2008 \-\s0 it tries to
be reasonably compatible ta other implementations, reasonably secure, as
much as IDNs can be secure, n' reasonably efficient when confronted with
IDNs dat is already valid \s-1DNS\s0 names.
.Sp
At tha moment, dis function simply calls \f(CW\*(C`idn_nameprep $idn, 1\*(C'\fR,
returnin its argument when dat function fails.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://anyevent.schmorp.de
.Ve
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 887:" 4
.IX Item "Around line 887:"
Non-ASCII characta peeped before =encodin up in '\s-1XXXXXX\s0)' fo' realz. Assumin \s-1UTF\-8\s0
