.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::Element 3"
.TH HTML::Element 3 "2013-08-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::Element \- Class fo' objects dat represent HTML elements
.SH "VERSION"
.IX Header "VERSION"
This document raps bout version 5.03 of
HTML::Element, busted out September 22, 2012
as part of HTML-Tree.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use HTML::Element;
\&    $a = HTML::Element\->new(\*(Aqa\*(Aq, href => \*(Aqhttp://www.perl.com/\*(Aq);
\&    $a\->push_content("Da Perl Homepage");
\&
\&    $tag = $a\->tag;
\&    print "$tag starts up as:",  $a\->starttag, "\en";
\&    print "$tag endz as:",  $a\->endtag, "\en";
\&    print "$tag\e\*(Aqs href attribute is: ", $a\->attr(\*(Aqhref\*(Aq), "\en";
\&
\&    $links_r = $a\->extract_links();
\&    print "Yo, I found ", scalar(@$links_r), " links.\en";
\&
\&    print "And that, as HTML, is: ", $a\->as_HTML, "\en";
\&    $a = $a\->delete;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
(This class is part of tha HTML::Tree dist.)
.PP
Objectz of tha HTML::Element class can be used ta represent elements
of \s-1HTML\s0 document trees.  These objects have attributes, notably attributes that
designates each elementz parent n' content.  Da content be a array
of text segments n' other HTML::Element objects, n' you can put dat on yo' toast.  A tree wit HTML::Element
objects as nodes can represent tha syntax tree fo' a \s-1HTML\s0 document.
.SH "HOW WE REPRESENT TREES"
.IX Header "HOW WE REPRESENT TREES"
Consider dis \s-1HTML\s0 document:
.PP
.Vb 9
\&  <html lang=\*(Aqen\-US\*(Aq>
\&    <head>
\&      <title>Stuff</title>
\&      <meta name=\*(Aqauthor\*(Aq content=\*(AqJojo\*(Aq>
\&    </head>
\&    <body>
\&     <h1>I wanna bust a nut on potatoes!</h1>
\&    </body>
\&  </html>
.Ve
.PP
Buildin a syntax tree outta it cook up a tree-structure up in memory
that could be diagrammed as:
.PP
.Vb 11
\&                     html (lang=\*(Aqen\-US\*(Aq)
\&                      / \e
\&                    /     \e
\&                  /         \e
\&                head        body
\&               /\e               \e
\&             /    \e               \e
\&           /        \e               \e
\&         title     meta              h1
\&          |       (name=\*(Aqauthor\*(Aq,     |
\&       "Stuff"    content=\*(AqJojo\*(Aq)    "I wanna bust a nut on potatoes"
.Ve
.PP
This is tha traditionizzle way ta diagram a tree, wit tha \*(L"root\*(R" at the
top, n' itz dis kind of diagram dat playas have up in mind when they
say, fo' example, dat \*(L"the meta element is under tha head element
instead of under tha body element\*(R".  (Da same be also holla'd with
\&\*(L"inside\*(R" instead of \*(L"under\*(R" \*(-- tha use of \*(L"inside\*(R" make mo' sense
when you lookin all up in tha \s-1HTML\s0 source.)
.PP
Another way ta represent tha above tree is wit indenting:
.PP
.Vb 8
\&  html (attributes: lang=\*(Aqen\-US\*(Aq)
\&    head
\&      title
\&        "Stuff"
\&      meta (attributes: name=\*(Aqauthor\*(Aq content=\*(AqJojo\*(Aq)
\&    body
\&      h1
\&        "I wanna bust a nut on potatoes"
.Ve
.PP
Incidentally, diagrammin wit indentin works much betta fo' hella
pimpin' trees, n' is easier fo' a program ta generate.  Da \f(CW\*(C`$tree\->dump\*(C'\fR
method uses indentation just dat way.
.PP
However you diagram tha tree, itz stored tha same up in memory \*(-- itz a
network of objects, each of which has attributes like so:
.PP
.Vb 4
\&  element #1:  _tag: \*(Aqhtml\*(Aq
\&               _parent: none
\&               _content: [element #2, element #5]
\&               lang: \*(Aqen\-US\*(Aq
\&
\&  element #2:  _tag: \*(Aqhead\*(Aq
\&               _parent: element #1
\&               _content: [element #3, element #4]
\&
\&  element #3:  _tag: \*(Aqtitle\*(Aq
\&               _parent: element #2
\&               _content: [text segment "Stuff"]
\&
\&  element #4   _tag: \*(Aqmeta\*(Aq
\&               _parent: element #2
\&               _content: none
\&               name: author
\&               content: Jojo
\&
\&  element #5   _tag: \*(Aqbody\*(Aq
\&               _parent: element #1
\&               _content: [element #6]
\&
\&  element #6   _tag: \*(Aqh1\*(Aq
\&               _parent: element #5
\&               _content: [text segment "I wanna bust a nut on potatoes"]
.Ve
.PP
Da \*(L"treeness\*(R" of tha tree-structure dat these elements comprise is
not a aspect of any particular object yo, but is emergent from the
relatednizz attributes (_parent n' _content) of these element-objects
and from how tha fuck you use dem ta git from element ta element.
.PP
While you could access tha content of a tree by freestylin code dat says
"access tha 'src' attribute of tha rootz \fIfirst\fR childz \fIseventh\fR
childz \fIthird\fR child\*(L", you mo' likely ta gotta scan tha contents
of a tree, lookin fo' whatever nodes, or kindz of nodes, you want to
do suttin' with.  Da most straightforward way ta look over a tree
is ta \*(R"traverse" it; a HTML::Element method (\f(CW\*(C`$h\->traverse\*(C'\fR) is
provided fo' dis purpose; n' nuff muthafuckin other HTML::Element methodz are
based on dat shit.
.PP
(For every last muthafuckin thang you eva wanted ta know bout trees, n' then some,
see Niklaus Wirthz \fIAlgorithms + Data Structures = Programs\fR or
Dizzle Knuthz \fIDa Art of Computa Programming, Volume 1\fR.)
.SS "Weak References"
.IX Subsection "Weak References"
\&\s-1TL\s0;DR summary: \f(CW\*(C`use\ HTML::TreeBuilder\ 5\ \-weak;\*(C'\fR n' forget about
the \f(CW\*(C`delete\*(C'\fR method (except fo' prunin a node from a tree).
.PP
Because HTML::Element stores a reference ta tha parent element, Perl's
reference-count garbage collection don't work properly with
HTML::Element trees.  Startin wit version 5.00, HTML::Element uses
weak references (if available) ta prevent dat problem.  Weak
references was introduced up in Perl 5.6.0 yo, but you also need a version
of Scalar::Util dat serves up tha \f(CW\*(C`weaken\*(C'\fR function.
.PP
Weak references is enabled by default.  If you wanna be certain
they up in use, you can say \f(CW\*(C`use\ HTML::Element\ 5\ \-weak;\*(C'\fR.  You
must include tha version number; previous versionz of HTML::Element
ignored tha import list entirely.
.PP
To disable weak references, you can say \f(CW\*(C`use\ HTML::Element\ \-noweak;\*(C'\fR.
This be a global setting.  \fBThis feature is deprecated\fR n' is
provided only as a quick fix fo' fucked up code.  If yo' code do not
work properly wit weak references, you should fix it immediately, as
weak references may become mandatory up in a gangbangin' future version. I aint talkin' bout chicken n' gravy biatch.  Generally,
all you need ta do is keep a reference ta tha root of tha tree until
yo ass is done hustlin wit dat shit.
.PP
Because HTML::TreeBuilder be a subclass of HTML::Element, you can also
import \f(CW\*(C`\-weak\*(C'\fR or \f(CW\*(C`\-noweak\*(C'\fR from HTML::TreeBuilder: e.g.
\&\f(CW\*(C`use\ HTML::TreeBuilder:\ 5\ \-weak;\*(C'\fR.
.SH "BASIC METHODS"
.IX Header "BASIC METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  $h = HTML::Element\->new(\*(Aqtag\*(Aq, \*(Aqattrname\*(Aq => \*(Aqvalue\*(Aq, ... );
.Ve
.PP
This constructor method returns a freshly smoked up HTML::Element object.  Da tag
name be a required argument; it is ghon be forced ta lowercase.
Optionally, you can specify other initial attributes at object
creation time.
.SS "attr"
.IX Subsection "attr"
.Vb 2
\&  $value = $h\->attr(\*(Aqattr\*(Aq);
\&  $old_value = $h\->attr(\*(Aqattr\*(Aq, $new_value);
.Ve
.PP
Returns (optionally sets) tha value of tha given attribute of \f(CW$h\fR.  The
attribute name (but not tha value, if provided) is forced to
lowercase.  If tryin ta read tha value of a attribute not present
for dis element, tha return value is undef.
If settin a freshly smoked up value, tha oldschool value of dat attribute is
returned.
.PP
If methodz is provided fo' accessin a attribute (like \f(CW\*(C`$h\->tag\*(C'\fR for
\&\*(L"_tag\*(R", \f(CW\*(C`$h\->content_list\*(C'\fR, etc. below), use dem instead of calling
attr \f(CW\*(C`$h\->attr\*(C'\fR, whether fo' readin or setting.
.PP
Note dat settin a attribute ta \f(CW\*(C`undef\*(C'\fR (as opposed ta "", tha empty
string) straight-up deletes tha attribute.
.SS "tag"
.IX Subsection "tag"
.Vb 2
\&  $tagname = $h\->tag();
\&  $h\->tag(\*(Aqtagname\*(Aq);
.Ve
.PP
Returns (optionally sets) tha tag name (also known as tha generic
identifier) fo' tha element \f(CW$h\fR.  In setting, tha tag name be always
converted ta lower case.
.PP
There is four kindz of \*(L"pseudo-elements\*(R" dat show up as
HTML::Element objects:
.IP "Comment pseudo-elements" 4
.IX Item "Comment pseudo-elements"
These is element objects wit a \f(CW\*(C`$h\->tag\*(C'\fR value of \*(L"~comment\*(R",
and tha content of tha comment is stored up in tha \*(L"text\*(R" attribute
(\f(CW\*(C`$h\->attr("text")\*(C'\fR).  For example, parsin dis code with
HTML::TreeBuilder...
.Sp
.Vb 3
\&  <!\-\- I wanna bust a nut on Pie.
\&     Pie is good
\&  \-\->
.Ve
.Sp
produces a HTML::Element object wit these attributes:
.Sp
.Vb 4
\&  "_tag",
\&  "~comment",
\&  "text",
\&  " I wanna bust a nut on Pie.\en     Pie is good\en  "
.Ve
.IP "Declaration pseudo-elements" 4
.IX Item "Declaration pseudo-elements"
Declarations (rarely encountered) is represented as HTML::Element
objects wit a tag name of \*(L"~declaration\*(R", n' content up in tha \*(L"text\*(R"
attribute.  For example, this:
.Sp
.Vb 1
\&  <!DOCTYPE foo>
.Ve
.Sp
produces a element whose attributes include:
.Sp
.Vb 1
\&  "_tag", "~declaration", "text", "DOCTYPE foo"
.Ve
.IP "Processin instruction pseudo-elements" 4
.IX Item "Processin instruction pseudo-elements"
PIs (rarely encountered) is represented as HTML::Element objects with
a tag name of \*(L"~pi\*(R", n' content up in tha \*(L"text\*(R" attribute.  For
example, this:
.Sp
.Vb 1
\&  <?shiznit foo?>
.Ve
.Sp
produces a element whose attributes include:
.Sp
.Vb 1
\&  "_tag", "~pi", "text", "shiznit foo?"
.Ve
.Sp
(assumin a recent version of HTML::Parser)
.IP "~literal pseudo-elements" 4
.IX Item "~literal pseudo-elements"
These objects is not currently produced by HTML::TreeBuilder yo, but can
be used ta represent a \*(L"super-literal\*(R" \*(-- i.e., a literal you want to
be immune from escaping.  (Yes, I just made dat term up.)
.Sp
That is, dis is useful if you wanna bang code tha fuck into a tree that
you plan ta dump up wit \f(CW\*(C`as_HTML\*(C'\fR, where you want, fo' some reason,
to suppress \f(CW\*(C`as_HTML\*(C'\fRz aiiight behavior of amp-quotin text segments.
.Sp
For example, this:
.Sp
.Vb 6
\&  mah $literal = HTML::Element\->new(\*(Aq~literal\*(Aq,
\&    \*(Aqtext\*(Aq => \*(Aqx < 4 & y > 7\*(Aq
\&  );
\&  mah $span = HTML::Element\->new(\*(Aqspan\*(Aq);
\&  $span\->push_content($literal);
\&  print $span\->as_HTML;
.Ve
.Sp
prints this:
.Sp
.Vb 1
\&  <span>x < 4 & y > 7</span>
.Ve
.Sp
Whereas this:
.Sp
.Vb 4
\&  mah $span = HTML::Element\->new(\*(Aqspan\*(Aq);
\&  $span\->push_content(\*(Aqx < 4 & y > 7\*(Aq);
\&    # aiiight text segment
\&  print $span\->as_HTML;
.Ve
.Sp
prints this:
.Sp
.Vb 1
\&  <span>x &lt; 4 &amp; y &gt; 7</span>
.Ve
.Sp
Unless you insertin fuckin shitloadz of pre-cooked code tha fuck into existin trees,
and dumpin dem up again, it aint likely dat you gonna find
\&\f(CW\*(C`~literal\*(C'\fR pseudo-elements useful.
.SS "parent"
.IX Subsection "parent"
.Vb 2
\&  $parent = $h\->parent();
\&  $h\->parent($new_parent);
.Ve
.PP
Returns (optionally sets) tha parent (aka \*(L"container\*(R") fo' dis element.
Da parent should either be undef, or should be another element.
.PP
Yo ass \fBshould not\fR use dis ta directly set tha parent of a element.
Instead use any of tha other methodz under \*(L"Structure-Modifying
Methods\*(R", below.
.PP
Note dat \f(CW\*(C`not($h\->parent)\*(C'\fR be a simple test fo' whether \f(CW$h\fR is the
root of its subtree.
.SS "content_list"
.IX Subsection "content_list"
.Vb 2
\&  @content = $h\->content_list();
\&  $num_lil pimps = $h\->content_list();
.Ve
.PP
Returns a list of tha lil pimp nodez of dis element \*(-- i.e., what
nodes (elements or text segments) is inside/under dis element. (Note
that dis may be a empty list.)
.PP
In a scalar context, dis returns tha count of tha items,
as you may expect.
.SS "content"
.IX Subsection "content"
.Vb 1
\&  $content_array_ref = $h\->content(); # may return undef
.Ve
.PP
This somewhat deprecated method returns tha content of dis element;
but unlike content_list, dis returns either undef (which you should
understand ta mean no content), or a \fIreference ta tha array\fR of
content items, each of which is either a text segment (a string, i.e.,
a defined non-reference scalar value), or a HTML::Element object.
Note dat even if a arrayref is returned, it may be a reference ta an
empty array.
.PP
While olda code should feel free ta continue ta use \f(CW\*(C`$h\->content\*(C'\fR,
new code should use \f(CW\*(C`$h\->content_list\*(C'\fR up in almost all conceivable
cases.  It be mah experience dat up in most cases dis leadz ta simpler
code anyway, since it means one can say:
.PP
.Vb 1
\&    @lil pimps = $h\->content_list;
.Ve
.PP
instead of tha inelegant:
.PP
.Vb 1
\&    @lil pimps = @{$h\->content || []};
.Ve
.PP
If you do use \f(CW\*(C`$h\->content\*(C'\fR (or \f(CW\*(C`$h\->content_array_ref\*(C'\fR), you should not
use tha reference returned by it (assumin it returned a reference,
and not undef) ta directly set or chizzle tha content of a element or
text segment son!  Instead use content_refs_list or any of tha other
methodz under \*(L"Structure-Modifyin Methods\*(R", below.
.SS "content_array_ref"
.IX Subsection "content_array_ref"
.Vb 1
\&  $content_array_ref = $h\->content_array_ref(); # never undef
.Ve
.PP
This is like \f(CW\*(C`content\*(C'\fR (with all its caveats n' deprecations) except
that it is guaranteed ta return a array reference.  That is, if the
given node has no \f(CW\*(C`_content\*(C'\fR attribute, tha \f(CW\*(C`content\*(C'\fR method would
return dat undef yo, but \f(CW\*(C`content_array_ref\*(C'\fR would set tha given node's
\&\f(CW\*(C`_content\*(C'\fR value ta \f(CW\*(C`[]\*(C'\fR (a reference ta a new, empty array), and
return dis shit.
.SS "content_refs_list"
.IX Subsection "content_refs_list"
.Vb 1
\&  @content_refs = $h\->content_refs_list;
.Ve
.PP
This returns a list of scalar references ta each element of \f(CW$h\fR's
content list.  This is useful up in case you wanna in-place edit any
pimpin' text segments without havin ta git a cold-ass lil copy of tha current value
of dat segment value, modify dat copy, then use the
\&\f(CW\*(C`splice_content\*(C'\fR ta replace tha oldschool wit tha new.  Instead, here you
can in-place edit:
.PP
.Vb 4
\&    foreach mah $item_r ($h\->content_refs_list) {
\&        next if ref $$item_r;
\&        $$item_r =~ s/honour/honor/g;
\&    }
.Ve
.PP
Yo ass \fIcould\fR currently big up tha same affect with:
.PP
.Vb 5
\&    foreach mah $item (@{ $h\->content_array_ref }) {
\&        # deprecated!
\&        next if ref $item;
\&        $item =~ s/honour/honor/g;
\&    }
.Ve
.PP
\&...except dat rockin tha return value of \f(CW\*(C`$h\->content\*(C'\fR or
\&\f(CW\*(C`$h\->content_array_ref\*(C'\fR ta do dat is deprecated, n' just might stop
workin up in tha future.
.SS "implicit"
.IX Subsection "implicit"
.Vb 2
\&  $is_implicit = $h\->implicit();
\&  $h\->implicit($make_implicit);
.Ve
.PP
Returns (optionally sets) tha \*(L"_implicit\*(R" attribute.  This attribute is
a flag thatz used fo' indicatin dat tha element was not originally
present up in tha source yo, but was added ta tha parse tree (by
HTML::TreeBuilder, fo' example) up in order ta conform ta tha rulez of
\&\s-1HTML\s0 structure.
.SS "pos"
.IX Subsection "pos"
.Vb 2
\&  $pos = $h\->pos();
\&  $h\->pos($element);
.Ve
.PP
Returns (and optionally sets) tha \*(L"_pos\*(R" (for "current \fIpos\fRition")
pointa of \f(CW$h\fR.  This attribute be a pointa used durin some
parsin operations, whose value is whatever HTML::Element element
at or under \f(CW$h\fR is currently \*(L"open\*(R", where \f(CW\*(C`$h\->insert_element(NEW)\*(C'\fR
will straight-up bang a freshly smoked up element.
.PP
(This has not a god damn thang ta do wit tha Perl function called \f(CW\*(C`pos\*(C'\fR, for
controllin where regular expression matchin starts.)
.PP
If you set \f(CW\*(C`$h\->pos($element)\*(C'\fR, be shizzle dat \f(CW$element\fR is
either \f(CW$h\fR, or a element under \f(CW$h\fR.
.PP
If you've been modifyin tha tree under \f(CW$h\fR n' is no longer
sure \f(CW\*(C`$h\->pos\*(C'\fR is valid, you can enforce validitizzle with:
.PP
.Vb 1
\&    $h\->pos(undef) unless $h\->pos\->is_inside($h);
.Ve
.SS "all_attr"
.IX Subsection "all_attr"
.Vb 1
\&  %attr = $h\->all_attr();
.Ve
.PP
Returns all dis elementz attributes n' joints, as key-value pairs.
This will include any \*(L"internal\*(R" attributes (i.e., ones not present
in tha original gangsta element, n' which aint gonna be represented if/when you
call \f(CW\*(C`$h\->as_HTML\*(C'\fR).  Internal attributes is distinguished by tha fact
that tha straight-up original gangsta characta of they key (not value biaaatch! key!) be an
underscore (\*(L"_\*(R").
.PP
Example output of \f(CW\*(C`$h\->all_attr()\*(C'\fR :
\&\f(CW\*(C`\*(Aq_parent\*(Aq, \*(C'\fR\fI[object_value]\fR\f(CW\*(C` , \*(Aq_tag\*(Aq, \*(Aqem\*(Aq, \*(Aqlang\*(Aq, \*(Aqen\-US\*(Aq,
\&\*(Aq_content\*(Aq, \*(C'\fR\fI[array\-ref value]\fR.
.SS "all_attr_names"
.IX Subsection "all_attr_names"
.Vb 2
\&  @names = $h\->all_attr_names();
\&  $num_attrs = $h\->all_attr_names();
.Ve
.PP
Like \f(CW\*(C`all_attr\*(C'\fR yo, but only returns tha namez of tha attributes.
In scalar context, returns tha number of attributes.
.PP
Example output of \f(CW\*(C`$h\->all_attr_names()\*(C'\fR :
\&\f(CW\*(C`\*(Aq_parent\*(Aq, \*(Aq_tag\*(Aq, \*(Aqlang\*(Aq, \*(Aq_content\*(Aq, \*(C'\fR.
.SS "all_external_attr"
.IX Subsection "all_external_attr"
.Vb 1
\&  %attr = $h\->all_external_attr();
.Ve
.PP
Like \f(CW\*(C`all_attr\*(C'\fR, except dat internal attributes is not present.
.SS "all_external_attr_names"
.IX Subsection "all_external_attr_names"
.Vb 2
\&  @names = $h\->all_external_attr_names();
\&  $num_attrs = $h\->all_external_attr_names();
.Ve
.PP
Like \f(CW\*(C`all_attr_names\*(C'\fR, except dat internal attributes' names
are not present (or counted).
.SS "id"
.IX Subsection "id"
.Vb 2
\&  $id = $h\->id();
\&  $h\->id($string);
.Ve
.PP
Returns (optionally sets ta \f(CW$string\fR) tha \*(L"id\*(R" attribute.
\&\f(CW\*(C`$h\->id(undef)\*(C'\fR deletes tha \*(L"id\*(R" attribute.
.PP
\&\f(CW\*(C`$h\->id(...)\*(C'\fR is basically equivalent ta \f(CW\*(C`$h\->attr(\*(Aqid\*(Aq, ...)\*(C'\fR,
except dat when settin tha attribute, dis method returns tha freshly smoked up value,
not tha oldschool value.
.SS "idf"
.IX Subsection "idf"
.Vb 2
\&  $id = $h\->idf();
\&  $h\->idf($string);
.Ve
.PP
Just like tha \f(CW\*(C`id\*(C'\fR method, except dat if you call \f(CW\*(C`$h\->idf()\*(C'\fR and
no \*(L"id\*(R" attribute is defined fo' dis element, then itz set ta a
likely-to-be-unique value, n' returned. Y'all KNOW dat shit, muthafucka!  (Da \*(L"f\*(R" is fo' \*(L"force\*(R".)
.SH "STRUCTURE-MODIFYING METHODS"
.IX Header "STRUCTURE-MODIFYING METHODS"
These methodz is provided fo' modifyin tha content of trees
by addin or changin nodes as muthafathas or lil pimpz of other nodes.
.SS "push_content"
.IX Subsection "push_content"
.Vb 1
\&  $h\->push_content($element_or_text, ...);
.Ve
.PP
Addz tha specified shit ta tha \fIend\fR of tha content list of the
element \f(CW$h\fR.  Da shit of content ta be added should each be either a
text segment (a string), a HTML::Element object, or a arrayref.
Arrayrefs is fed thru \f(CW\*(C`$h\->new_from_lol(that_arrayref)\*(C'\fR to
convert dem tha fuck into elements, before bein added ta tha content
list of \f(CW$h\fR.  This means you can say thangs concise thangs like:
.PP
.Vb 6
\&  $body\->push_content(
\&    [\*(Aqbr\*(Aq],
\&    [\*(Aqul\*(Aq,
\&      map [\*(Aqli\*(Aq, $_], qw(Peaches Applez Pears Mangos)
\&    ]
\&  );
.Ve
.PP
See tha \*(L"new_from_lol\*(R" methodz documentation, far below, fo' more
explanation.
.PP
Returns \f(CW$h\fR (the element itself).
.PP
Da push_content method will try ta consolidate adjacent text segments
while addin ta tha content list.  Thatz ta say, if \f(CW$h\fRz \f(CW\*(C`content_list\*(C'\fR is
.PP
.Vb 1
\&  (\*(Aqfoo bar \*(Aq, $some_node, \*(Aqbaz!\*(Aq)
.Ve
.PP
and you call
.PP
.Vb 1
\&   $h\->push_content(\*(Aqquack?\*(Aq);
.Ve
.PP
then tha resultin content list is ghon be this:
.PP
.Vb 1
\&  (\*(Aqfoo bar \*(Aq, $some_node, \*(Aqbaz!quack?\*(Aq)
.Ve
.PP
and not this:
.PP
.Vb 1
\&  (\*(Aqfoo bar \*(Aq, $some_node, \*(Aqbaz!\*(Aq, \*(Aqquack?\*(Aq)
.Ve
.PP
If dat latta is what tha fuck you want, you gonna gotta override the
feature of consolipimpin text by rockin splice_content,
as in:
.PP
.Vb 1
\&  $h\->splice_content(scalar($h\->content_list),0,\*(Aqquack?\*(Aq);
.Ve
.PP
Similarly, if you wanted ta add 'Skronk' ta tha beginnin of
the content list, callin this:
.PP
.Vb 1
\&   $h\->unshift_content(\*(AqSkronk\*(Aq);
.Ve
.PP
then tha resultin content list is ghon be this:
.PP
.Vb 1
\&  (\*(AqSkronkfoo bar \*(Aq, $some_node, \*(Aqbaz!\*(Aq)
.Ve
.PP
and not this:
.PP
.Vb 1
\&  (\*(AqSkronk\*(Aq, \*(Aqfoo bar \*(Aq, $some_node, \*(Aqbaz!\*(Aq)
.Ve
.PP
What you'd ta do git tha latta is:
.PP
.Vb 1
\&  $h\->splice_content(0,0,\*(AqSkronk\*(Aq);
.Ve
.SS "unshift_content"
.IX Subsection "unshift_content"
.Vb 1
\&  $h\->unshift_content($element_or_text, ...)
.Ve
.PP
Just like \f(CW\*(C`push_content\*(C'\fR yo, but addz ta tha \fIbeginning\fR of tha \f(CW$h\fR
elementz content list.
.PP
Da shit of content ta be added should each be
either a text segment (a string), a HTML::Element object, or
an arrayref (which is fed thru \f(CW\*(C`new_from_lol\*(C'\fR).
.PP
Da unshift_content method will try ta consolidate adjacent text segments
while addin ta tha content list.  See above fo' a gangbangin' finger-lickin' rap of all dis bullshit.
.PP
Returns \f(CW$h\fR (the element itself).
.SS "splice_content"
.IX Subsection "splice_content"
.Vb 2
\&  @removed = $h\->splice_content($offset, $length,
\&                                $element_or_text, ...);
.Ve
.PP
Detaches tha elements from \f(CW$h\fRz list of content-nodes, startin at
\&\f(CW$offset\fR n' continuin fo' \f(CW$length\fR items, replacin dem wit the
elementz of tha followin list, if any.  Returns tha elements (if any)
removed from tha content-list.  If \f(CW$offset\fR is negative, then it starts
that far from tha end of tha array, just like Perlz aiiight \f(CW\*(C`splice\*(C'\fR
function. I aint talkin' bout chicken n' gravy biatch.  If \f(CW$length\fR n' tha followin list is omitted, removes
everythang from \f(CW$offset\fR onward.
.PP
Da shit of content ta be added (if any) should each be either a text
segment (a string), a arrayref (which is fed thru \*(L"new_from_lol\*(R"),
or a HTML::Element object thatz not already
a lil pimp of \f(CW$h\fR.
.SS "detach"
.IX Subsection "detach"
.Vb 1
\&  $old_parent = $h\->detach();
.Ve
.PP
This unlinks \f(CW$h\fR from its parent, by settin its 'parent' attribute to
undef, n' by removin it from tha content list of its parent (if it
had one).  Da return value is tha parent dat was detached from (or
undef, if \f(CW$h\fR had no parent ta start with).  Note dat neither \f(CW$h\fR nor
its parent is explicitly destroyed.
.SS "detach_content"
.IX Subsection "detach_content"
.Vb 1
\&  @old_content = $h\->detach_content();
.Ve
.PP
This unlinks all of \f(CW$h\fRz lil pimps from \f(CW$h\fR, n' returns em.
Note dat these is not explicitly destroyed; fo' that, you
can just use \f(CW\*(C`$h\->delete_content\*(C'\fR.
.SS "replace_with"
.IX Subsection "replace_with"
.Vb 1
\&  $h\->replace_with( $element_or_text, ... )
.Ve
.PP
This replaces \f(CW$h\fR up in its parentz content list wit tha nodes
specified. Y'all KNOW dat shit, muthafucka!  Da element \f(CW$h\fR (which by then may have no parent)
is returned. Y'all KNOW dat shit, muthafucka!  This causes a gangbangin' fatal error if \f(CW$h\fR has no parent.
Da list of nodes ta bang may contain \f(CW$h\fR yo, but at most once.
Aside from dat possible exception, tha nodes ta bang should not
already be lil pimpz of \f(CW$h\fRz parent.
.PP
Also, note dat dis method do not destroy \f(CW$h\fR if weak references are
turned off \*(-- use \f(CW\*(C`$h\->replace_with(...)\->delete\*(C'\fR if you need dis shit.
.SS "preinsert"
.IX Subsection "preinsert"
.Vb 1
\&  $h\->preinsert($element_or_text...);
.Ve
.PP
Inserts tha given nodes right \s-1BEFORE \s0\f(CW$h\fR up in \f(CW$h\fRz parent's
content list.  This causes a gangbangin' fatal error if \f(CW$h\fR has no parent.
None of tha given nodes should be \f(CW$h\fR or other lil pimpz of \f(CW$h\fR.
Returns \f(CW$h\fR.
.SS "postinsert"
.IX Subsection "postinsert"
.Vb 1
\&  $h\->postinsert($element_or_text...)
.Ve
.PP
Inserts tha given nodes right \s-1AFTER \s0\f(CW$h\fR up in \f(CW$h\fRz parentz content
list.  This causes a gangbangin' fatal error if \f(CW$h\fR has no parent.  None of
the given nodes should be \f(CW$h\fR or other lil pimpz of \f(CW$h\fR.  Returns
\&\f(CW$h\fR.
.SS "replace_with_content"
.IX Subsection "replace_with_content"
.Vb 1
\&  $h\->replace_with_content();
.Ve
.PP
This replaces \f(CW$h\fR up in its parentz content list wit its own content.
Da element \f(CW$h\fR (which by then has no parent or content of its own) is
returned. Y'all KNOW dat shit, muthafucka!  This causes a gangbangin' fatal error if \f(CW$h\fR has no parent.  Also, note
that dis do not destroy \f(CW$h\fR if weak references is turned off \*(-- use
\&\f(CW\*(C`$h\->replace_with_content\->delete\*(C'\fR if you need dis shit.
.SS "delete_content"
.IX Subsection "delete_content"
.Vb 2
\&  $h\->delete_content();
\&  $h\->destroy_content(); # alias
.Ve
.PP
Clears tha content of \f(CW$h\fR, callin \f(CW\*(C`$h\->delete\*(C'\fR fo' each content
element.  Compare wit \f(CW\*(C`$h\->detach_content\*(C'\fR.
.PP
Returns \f(CW$h\fR.
.PP
\&\f(CW\*(C`destroy_content\*(C'\fR be a alias fo' dis method.
.SS "delete"
.IX Subsection "delete"
.Vb 2
\&  $h\->delete();
\&  $h\->destroy(); # alias
.Ve
.PP
Detaches dis element from its parent (if it has one) n' explicitly
destroys tha element n' all its descendants, n' you can put dat on yo' toast.  Da return value is
the empty list (or \f(CW\*(C`undef\*(C'\fR up in scalar context).
.PP
Before version 5.00 of HTML::Element, you had ta booty-call \f(CW\*(C`delete\*(C'\fR when
you was finished wit tha tree, or yo' program would leak memory.
This is no longer necessary if weak references is enabled, see
\&\*(L"Weak References\*(R".
.SS "destroy"
.IX Subsection "destroy"
An alias fo' \*(L"delete\*(R".
.SS "destroy_content"
.IX Subsection "destroy_content"
An alias fo' \*(L"delete_content\*(R".
.SS "clone"
.IX Subsection "clone"
.Vb 1
\&  $copy = $h\->clone();
.Ve
.PP
Returns a cold-ass lil copy of tha element (whose lil pimps is clones (recursively)
of tha originalz children, if any).
.PP
Da returned element is parentless.  Any '_pos' attributes present up in the
source element/tree is ghon be absent up in tha copy.  For dat n' other reasons,
the clone of a HTML::TreeBuilder object thatz up in mid-parse (i.e, tha head
of a tree dat HTML::TreeBuilder is elaborating) cannot (currently) be used
to continue tha parse.
.PP
Yo ass is free ta clone HTML::TreeBuilder trees, just as long as:
1) they done bein parsed, or 2) you don't expect ta resume parsing
into tha clone.  (Yo ass can continue parsin tha fuck into tha original; it is
never affected.)
.SS "clone_list"
.IX Subsection "clone_list"
.Vb 1
\&  @copies = HTML::Element\->clone_list(...nodes...);
.Ve
.PP
Returns a list consistin of a cold-ass lil copy of each node given.
Text segments is simply copied; elements is cloned by
callin \f(CW\*(C`$it\->clone\*(C'\fR on each of em.
.PP
Note dat dis must be called as a cold-ass lil class method, not as a instance
method. Y'all KNOW dat shit, muthafucka!  \f(CW\*(C`clone_list\*(C'\fR will croak if called as a instizzle method.
Yo ass can also call it like so:
.PP
.Vb 1
\&    ref($h)\->clone_list(...nodes...)
.Ve
.SS "normalize_content"
.IX Subsection "normalize_content"
.Vb 1
\&  $h\->normalize_content
.Ve
.PP
Normalizes tha content of \f(CW$h\fR \*(-- i.e., concatenates any adjacent
text nodes.  (Any undefined text segments is turned tha fuck into empty-strings.)
Note dat dis do not recurse tha fuck into \f(CW$h\fRz descendants.
.SS "delete_ignorable_whitespace"
.IX Subsection "delete_ignorable_whitespace"
.Vb 1
\&  $h\->delete_ignorable_whitespace()
.Ve
.PP
This traverses under \f(CW$h\fR n' deletes any text segments dat is ignorable
whitespace.  Yo ass should not use dis if \f(CW$h\fR is under a \f(CW\*(C`<pre>\*(C'\fR element.
.SS "insert_element"
.IX Subsection "insert_element"
.Vb 1
\&  $h\->insert_element($element, $implicit);
.Ve
.PP
Inserts (via push_content) a freshly smoked up element under tha element at
\&\f(CW\*(C`$h\->pos()\*(C'\fR.  Then thugged-out shiznit \f(CW\*(C`$h\->pos()\*(C'\fR ta point ta tha inserted
element, unless \f(CW$element\fR be a prototypically empty element like
\&\f(CW\*(C`<br>\*(C'\fR, \f(CW\*(C`<hr>\*(C'\fR, \f(CW\*(C`<img>\*(C'\fR, etc.
Da freshly smoked up \f(CW\*(C`$h\->pos()\*(C'\fR is returned. Y'all KNOW dat shit, muthafucka!  This
method is useful only if yo' particular tree task involves setting
\&\f(CW\*(C`$h\->pos()\*(C'\fR.
.SH "DUMPING METHODS"
.IX Header "DUMPING METHODS"
.SS "dump"
.IX Subsection "dump"
.Vb 2
\&  $h\->dump()
\&  $h\->dump(*FH)  ; # or *FH{IO} or $fh_obj
.Ve
.PP
Prints tha element n' all its lil pimps ta \s-1STDOUT \s0(or ta a specified
filehandle), up in a gangbangin' format useful
only fo' debugging.  Da structure of tha document is shown by
indentation (no end tags).
.SS "as_HTML"
.IX Subsection "as_HTML"
.Vb 4
\&  $s = $h\->as_HTML();
\&  $s = $h\->as_HTML($entities);
\&  $s = $h\->as_HTML($entities, $indent_char);
\&  $s = $h\->as_HTML($entities, $indent_char, \e%optional_end_tags);
.Ve
.PP
Returns a strang representin up in \s-1HTML\s0 tha element n' its
descendants, n' you can put dat on yo' toast.  Da optionizzle argument \f(CW$entities\fR specifies a strang of
the entitizzles ta encode.  For compatibilitizzle wit previous versions,
specify \f(CW\*(Aq<>&\*(Aq\fR here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  If omitted or undef, \fIall\fR unsafe
charactas is encoded as \s-1HTML\s0 entities. Put ya muthafuckin choppers up if ya feel dis!  See HTML::Entitizzles for
details.  If passed a empty string, no entitizzles is encoded.
.PP
If \f(CW$indent_char\fR is specified n' defined, tha \s-1HTML\s0 ta be output is
intented, rockin tha strang you specify (which you probably should
set ta \*(L"\et\*(R", or some number of spaces, if you specify it).
.PP
If \f(CW\*(C`\e%optional_end_tags\*(C'\fR is specified n' defined, it should be
a reference ta a hash dat holdz a legit value fo' every last muthafuckin tag name
whose end tag is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Defaults to
\&\f(CW\*(C`\e%HTML::Element::optionalEndTag\*(C'\fR, which be a alias to
\&\f(CW%HTML::Tagset::optionalEndTag\fR, which, at time of writing, gotz nuff
true joints fo' \f(CW\*(C`p, li, dt, dd\*(C'\fR.  A useful value ta pass be a empty
hashref, \f(CW\*(C`{}\*(C'\fR, which means dat no end-tags is optionizzle fo' dis dump.
Otherwise, possibly consider copyin \f(CW%HTML::Tagset::optionalEndTag\fR ta a
hash of yo' own, addin or deletin joints as you like, n' passing
a reference ta dat hash.
.SS "as_text"
.IX Subsection "as_text"
.Vb 2
\&  $s = $h\->as_text();
\&  $s = $h\->as_text(skip_dels => 1);
.Ve
.PP
Returns a strang consistin of only tha text partz of tha element's
descendants, n' you can put dat on yo' toast.  Any whitespace inside tha element is included unchanged,
but whitespace not up in tha tree is never added. Y'all KNOW dat shit, muthafucka!  But remember that
whitespace may be ignored or compacted by HTML::TreeBuilder during
parsin (dependin on tha value of tha \f(CW\*(C`ignore_ignorable_whitespace\*(C'\fR
and \f(CW\*(C`no_space_compacting\*(C'\fR attributes).  Also, since whitespace is
never added durin parsing,
.PP
.Vb 2
\&  HTML::TreeBuilder\->new_from_content("<p>a</p><p>b</p>")
\&                   \->as_text;
.Ve
.PP
returns \f(CW"ab"\fR, not \f(CW"a b"\fR or \f(CW"a\enb"\fR.
.PP
Text under \f(CW\*(C`<script>\*(C'\fR or \f(CW\*(C`<style>\*(C'\fR elements is never
included up in whatz returned. Y'all KNOW dat shit, muthafucka!  If \f(CW\*(C`skip_dels\*(C'\fR is true, then text
content under \f(CW\*(C`<del>\*(C'\fR nodes aint included up in whatz returned.
.SS "as_trimmed_text"
.IX Subsection "as_trimmed_text"
.Vb 3
\&  $s = $h\->as_trimmed_text(...);
\&  $s = $h\->as_trimmed_text(extra_chars => \*(Aq\exA0\*(Aq); # remove &nbsp;
\&  $s = $h\->as_text_trimmed(...); # alias
.Ve
.PP
This is just like \f(CW\*(C`as_text(...)\*(C'\fR except dat leadin n' trailing
whitespace is deleted, n' any internal whitespace is collapsed.
.PP
This aint gonna remove non-breakin spaces, Unicode spaces, or any other
non-ASCII whitespace unless you supply tha extra charactas as
a strang argument (e.g. \f(CW\*(C`$h\->as_trimmed_text(extra_chars => \*(Aq\exA0\*(Aq)\*(C'\fR).
\&\f(CW\*(C`extra_chars\*(C'\fR may be any strang dat can step tha fuck up inside a cold-ass lil character
class, includin ranges like \f(CW\*(C`a\-z\*(C'\fR, \s-1POSIX\s0 characta classes like
\&\f(CW\*(C`[:alpha:]\*(C'\fR, n' characta class escapes like \f(CW\*(C`\ep{Zs}\*(C'\fR.
.SS "as_XML"
.IX Subsection "as_XML"
.Vb 1
\&  $s = $h\->as_XML()
.Ve
.PP
Returns a strang representin up in \s-1XML\s0 tha element n' its descendants.
.PP
Da \s-1XML\s0 aint indented.
.SS "as_Lisp_form"
.IX Subsection "as_Lisp_form"
.Vb 1
\&  $s = $h\->as_Lisp_form();
.Ve
.PP
Returns a strang representin tha element n' its descendants as a
Lisp form.  Unsafe charactas is encoded as octal escapes.
.PP
Da Lisp form is indented, n' gotz nuff external (\*(L"href\*(R", etc.)  as
well as internal attributes (\*(L"_tag\*(R", \*(L"_content\*(R", \*(L"_implicit\*(R", etc.),
except fo' \*(L"_parent\*(R", which is omitted.
.PP
Current example output fo' a given element:
.PP
.Vb 1
\&  ("_tag" "img" "border" "0" "src" "pie.png" "usemap" "#main.map")
.Ve
.SS "format"
.IX Subsection "format"
.Vb 2
\&  $s = $h\->format; # use HTML::FormatText
\&  $s = $h\->format($formatter);
.Ve
.PP
Formats text output. Defaults ta HTML::FormatText.
.PP
Takes a second argument dat be a reference ta a gangbangin' formatter.
.SS "starttag"
.IX Subsection "starttag"
.Vb 2
\&  $start = $h\->starttag();
\&  $start = $h\->starttag($entities);
.Ve
.PP
Returns a strang representin tha complete start tag fo' tha element.
I.e., leadin \*(L"<\*(R", tag name, attributes, n' trailin \*(L">\*(R".
All joints is surrounded with
double-quotes, n' appropriate charactas is encoded. Y'all KNOW dat shit, muthafucka!  If \f(CW$entities\fR
is omitted or undef, \fIall\fR unsafe charactas is encoded as \s-1HTML\s0
entities. Put ya muthafuckin choppers up if ya feel dis!  See HTML::Entitizzles fo' details.  If you specify some
value fo' \f(CW$entities\fR, remember ta include tha double-quote characta in
it.  (Previous versionz of dis module would basically behave as if
\&\f(CW\*(Aq&">\*(Aq\fR was specified fo' \f(CW$entities\fR.)  If \f(CW$entities\fR is
an empty string, no entitizzle is escaped.
.SS "starttag_XML"
.IX Subsection "starttag_XML"
.Vb 1
\&  $start = $h\->starttag_XML();
.Ve
.PP
Returns a strang representin tha complete start tag fo' tha element.
.SS "endtag"
.IX Subsection "endtag"
.Vb 1
\&  $end = $h\->endtag();
.Ve
.PP
Returns a strang representin tha complete end tag fo' dis element.
I.e., \*(L"</\*(R", tag name, n' \*(L">\*(R".
.SS "endtag_XML"
.IX Subsection "endtag_XML"
.Vb 1
\&  $end = $h\->endtag_XML();
.Ve
.PP
Returns a strang representin tha complete end tag fo' dis element.
I.e., \*(L"</\*(R", tag name, n' \*(L">\*(R".
.SH "SECONDARY STRUCTURAL METHODS"
.IX Header "SECONDARY STRUCTURAL METHODS"
These methodz all involve some structural aspect of tha tree;
either they report some aspect of tha treez structure, or they involve
traversal down tha tree, or struttin up tha tree.
.SS "is_inside"
.IX Subsection "is_inside"
.Vb 1
\&  $inside = $h\->is_inside(\*(Aqtag\*(Aq, $element, ...);
.Ve
.PP
Returns legit if tha \f(CW$h\fR element is, or is contained anywhere inside an
element dat be any of tha ones listed, or whose tag name be any of
the tag names listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Yo ass can use any mix of elements n' tag names.
.SS "is_empty"
.IX Subsection "is_empty"
.Vb 1
\&  $empty = $h\->is_empty();
.Ve
.PP
Returns legit if \f(CW$h\fR has no content, i.e., has no elements or text
segments under dat shit.  In other lyrics, dis returns legit if \f(CW$h\fR be a leaf
node, \s-1AKA\s0 a terminal node.  Do not confuse dis sense of \*(L"empty\*(R" with
another sense dat it can have up in \s-1SGML/HTML/XML\s0 terminology, which
means dat tha element up in question iz of tha type (like \s-1HTML\s0z \f(CW\*(C`<hr>\*(C'\fR,
\&\f(CW\*(C`<br>\*(C'\fR, \f(CW\*(C`<img>\*(C'\fR, etc.) dat \fIcan't\fR have any content.
.PP
That is, a particular \f(CW\*(C`<p>\*(C'\fR element may happen ta have no content, so
\&\f(CW$that_p_element\fR\->is_empty is ghon be legit \*(-- even though tha prototypical
\&\f(CW\*(C`<p>\*(C'\fR element aint \*(L"empty\*(R" (not up in tha way dat tha prototypical
\&\f(CW\*(C`<hr>\*(C'\fR element is).
.PP
If you be thinkin dis might make fo' potentially confusin code, consider
simply rockin tha clearer exact equivalent:  \f(CW\*(C`not($h\->content_list)\*(C'\fR.
.SS "pindex"
.IX Subsection "pindex"
.Vb 1
\&  $index = $h\->pindex();
.Ve
.PP
Return tha index of tha element up in its parentz contents array, such
that \f(CW$h\fR would equal
.PP
.Vb 3
\&  $h\->parent\->content\->[$h\->pindex]
\&  # or
\&  ($h\->parent\->content_list)[$h\->pindex]
.Ve
.PP
assumin \f(CW$h\fR aint root.  If tha element \f(CW$h\fR is root, then
\&\f(CW\*(C`$h\->pindex\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR.
.SS "left"
.IX Subsection "left"
.Vb 2
\&  $element = $h\->left();
\&  @elements = $h\->left();
.Ve
.PP
In scalar context: returns tha node thatz tha immediate left sibling
of \f(CW$h\fR.  If \f(CW$h\fR is tha leftmost (or only) lil pimp of its parent (or has no
parent), then dis returns undef.
.PP
In list context: returns all tha nodes that're tha left siblingz of \f(CW$h\fR
(startin wit tha leftmost).  If \f(CW$h\fR is tha leftmost (or only) child
of its parent (or has no parent), then dis returns a empty list.
.PP
(See also \f(CW\*(C`$h\->preinsert(LIST)\*(C'\fR.)
.SS "right"
.IX Subsection "right"
.Vb 2
\&  $element = $h\->right();
\&  @elements = $h\->right();
.Ve
.PP
In scalar context: returns tha node thatz tha immediate right sibling
of \f(CW$h\fR.  If \f(CW$h\fR is tha rightmost (or only) lil pimp of its parent (or has
no parent), then dis returns \f(CW\*(C`undef\*(C'\fR.
.PP
In list context: returns all tha nodes that're tha right siblings of
\&\f(CW$h\fR, startin wit tha leftmost.  If \f(CW$h\fR is tha rightmost (or only) child
of its parent (or has no parent), then dis returns a empty list.
.PP
(See also \f(CW\*(C`$h\->postinsert(LIST)\*(C'\fR.)
.SS "address"
.IX Subsection "address"
.Vb 2
\&  $address = $h\->address();
\&  $element_or_text = $h\->address($address);
.Ve
.PP
Da first form (with no parameter) returns a strang representin the
location of \f(CW$h\fR up in tha tree it aint nuthin but a gangmember of.
Da address consistz of numbers joined by a '.', startin wit '0',
and followed by tha pindexez of tha nodes up in tha tree dat are
ancestorz of \f(CW$h\fR, startin from tha top.
.PP
So if tha way ta git ta a node startin all up in tha root is ta git all up in child
2 of tha root, then lil pimp 10 of that, n' then lil pimp 0 of that, and
then you there \*(-- then dat nodez address is \*(L"0.2.10.0\*(R".
.PP
As a lil' bit of a special case, tha address of tha root is simply \*(L"0\*(R".
.PP
I forsee dis bein used mainly fo' debuggin yo, but you may
find yo' own uses fo' dat shit.
.PP
.Vb 1
\&  $element_or_text = $h\->address($address);
.Ve
.PP
This form returns tha node (whether element or text-segment) at
the given address up in tha tree dat \f(CW$h\fR be a part of.  (That is,
the address is resolved startin from \f(CW\*(C`$h\->root\*(C'\fR.)
.PP
If there is no node all up in tha given address, dis returns \f(CW\*(C`undef\*(C'\fR.
.PP
Yo ass can specify \*(L"relatizzle addressing\*(R" (i.e., dat indexin is supposed
to start from \f(CW$h\fR n' not from \f(CW\*(C`$h\->root\*(C'\fR) by havin tha address start
with a period \*(-- e.g., \f(CW\*(C`$h\->address(".3.2")\*(C'\fR will peep lil pimp 3 of \f(CW$h\fR,
and lil pimp 2 of dis shit.
.SS "depth"
.IX Subsection "depth"
.Vb 1
\&  $depth = $h\->depth();
.Ve
.PP
Returns a number expressin \f(CW$h\fRz depth within its tree, i.e., how tha fuck many
steps away it is from tha root.  If \f(CW$h\fR has no parent (i.e., is root),
its depth is 0.
.SS "root"
.IX Subsection "root"
.Vb 1
\&  $root = $h\->root();
.Ve
.PP
Returns tha element thatz tha top of \f(CW$h\fRz tree.  If \f(CW$h\fR is
root, dis just returns \f(CW$h\fR.  (If you wanna test whether \f(CW$h\fR
\&\fIis\fR tha root, instead of askin what tha fuck its root is, just test
\&\f(CW\*(C`not($h\->parent)\*(C'\fR.)
.SS "lineage"
.IX Subsection "lineage"
.Vb 1
\&  @lineage = $h\->lineage();
.Ve
.PP
Returns tha list of \f(CW$h\fRz ancestors, startin wit its parent,
and then dat parentz parent, n' so on, up ta tha root.  If \f(CW$h\fR
is root, dis returns a empty list.
.PP
If you simply want a cold-ass lil count of tha number of elements up in \f(CW$h\fRz lineage,
use \f(CW\*(C`$h\->depth\*(C'\fR.
.SS "lineage_tag_names"
.IX Subsection "lineage_tag_names"
.Vb 1
\&  @names = $h\->lineage_tag_names();
.Ve
.PP
Returns tha list of tha tag namez of \f(CW$h\fRz ancestors, starting
with its parent, n' dat parentz parent, n' so on, up ta the
root.  If \f(CW$h\fR is root, dis returns a empty list.
Example output: \f(CW\*(C`(\*(Aqem\*(Aq, \*(Aqtd\*(Aq, \*(Aqtr\*(Aq, \*(Aqtable\*(Aq, \*(Aqbody\*(Aq, \*(Aqhtml\*(Aq)\*(C'\fR
.PP
Equivalent to:
.PP
.Vb 1
\&  map { $_\->tag } $h\->lineage;
.Ve
.SS "descendants"
.IX Subsection "descendants"
.Vb 1
\&  @descendants = $h\->descendants();
.Ve
.PP
In list context, returns tha list of all \f(CW$h\fRz descendant elements,
listed up in pre-order (i.e., a element appears before its
content-elements).  Text segments \s-1DO NOT\s0 step tha fuck up in tha list.
In scalar context, returns a cold-ass lil count of all such elements.
.SS "descendents"
.IX Subsection "descendents"
This is just a alias ta tha \f(CW\*(C`descendants\*(C'\fR method, fo' playas who
can't spell.
.SS "find_by_tag_name"
.IX Subsection "find_by_tag_name"
.Vb 2
\&  @elements = $h\->find_by_tag_name(\*(Aqtag\*(Aq, ...);
\&  $first_match = $h\->find_by_tag_name(\*(Aqtag\*(Aq, ...);
.Ve
.PP
In list context, returns a list of elements at or under \f(CW$h\fR dat have
any of tha specified tag names.  In scalar context, returns tha first
(in pre-order traversal of tha tree) such element found, or undef if
none.
.SS "find"
.IX Subsection "find"
This is just a alias ta \f(CW\*(C`find_by_tag_name\*(C'\fR.  (There was once
goin ta be a whole find_* crew of methodz yo, but then \f(CW\*(C`look_down\*(C'\fR
filled dat niche, so there turned up not ta be much reason fo' the
verbosenizz of tha name \*(L"find_by_tag_name\*(R".)
.SS "find_by_attribute"
.IX Subsection "find_by_attribute"
.Vb 2
\&  @elements = $h\->find_by_attribute(\*(Aqattribute\*(Aq, \*(Aqvalue\*(Aq);
\&  $first_match = $h\->find_by_attribute(\*(Aqattribute\*(Aq, \*(Aqvalue\*(Aq);
.Ve
.PP
In a list context, returns a list of elements at or under \f(CW$h\fR dat have
the specified attribute, n' have tha given value fo' dat attribute.
In a scalar context, returns tha straight-up original gangsta (in pre-order traversal of the
tree) such element found, or undef if none.
.PP
This method is \fBdeprecated\fR up in favor of tha mo' expressive
\&\f(CW\*(C`look_down\*(C'\fR method, which freshly smoked up code should use instead.
.SS "look_down"
.IX Subsection "look_down"
.Vb 2
\&  @elements = $h\->look_down( ...criteria... );
\&  $first_match = $h\->look_down( ...criteria... );
.Ve
.PP
This starts at \f(CW$h\fR n' looks thru its element descendants (in
pre-order), lookin fo' elements matchin tha criteria you specify.
In list context, returns all elements dat match all tha given
criteria; up in scalar context, returns tha straight-up original gangsta such element (or undef,
if not a god damn thang matched).
.PP
There is three kindz of criteria you can specify:
.IP "(attr_name, attr_value)" 4
.IX Item "(attr_name, attr_value)"
This means you lookin fo' a element wit dat value fo' that
attribute.  Example: \f(CW"alt", "pix!"\fR.  Consider dat you can search
on internal attribute joints too: \f(CW"_tag", "p"\fR.
.IP "(attr_name, qr/.../)" 4
.IX Item "(attr_name, qr/.../)"
This means you lookin fo' a element whose value fo' that
attribute matches tha specified Regexp object.
.IP "a coderef" 4
.IX Item "a coderef"
This means you lookin fo' elements where coderef\->(each_element)
returns true.  Example:
.Sp
.Vb 5
\&  mah @wide_pix_images = $h\->look_down(
\&    _tag => "img",
\&    alt  => "pix!",
\&    sub { $_[0]\->attr(\*(Aqwidth\*(Aq) > 350 }
\&  );
.Ve
.PP
Note dat \f(CW\*(C`(attr_name, attr_value)\*(C'\fR n' \f(CW\*(C`(attr_name, qr/.../)\*(C'\fR
criteria is almost always fasta than coderef
criteria, so should presumably be put before dem up in yo' list of
criteria.  That is, up in tha example above, tha sub ref is called only
for elements dat have already passed tha criteria of havin a \*(L"_tag\*(R"
attribute wit value \*(L"img\*(R", n' a \*(L"alt\*(R" attribute wit value \*(L"pix!\*(R".
If tha coderef was first, it would be called on every last muthafuckin element, and
\&\fIthen\fR what tha fuck elements pass dat criterion (i.e., elements fo' which
the coderef returned true) would be checked fo' they \*(L"_tag\*(R" n' \*(L"alt\*(R"
attributes.
.PP
Note dat comparison of strang attribute-values against tha string
value up in \f(CW\*(C`(attr_name, attr_value)\*(C'\fR is case-INsensitizzle biaaatch!  A criterion
of \f(CW\*(C`(\*(Aqalign\*(Aq, \*(Aqright\*(Aq)\*(C'\fR \fIwill\fR match a element whose \*(L"align\*(R" value
is \*(L"\s-1RIGHT\*(R",\s0 or \*(L"right\*(R" or \*(L"rIGhT\*(R", etc.
.PP
Note also dat \f(CW\*(C`look_down\*(C'\fR considaz "" (empty-string) n' undef to
be different thangs, up in attribute joints, n' you can put dat on yo' toast.  So this:
.PP
.Vb 1
\&  $h\->look_down("alt", "")
.Ve
.PP
will find elements \fIwith\fR a \*(L"alt\*(R" attribute yo, but where tha value for
the \*(L"alt\*(R" attribute is "".  But this:
.PP
.Vb 1
\&  $h\->look_down("alt", undef)
.Ve
.PP
is tha same ol' dirty as:
.PP
.Vb 1
\&  $h\->look_down(sub { !defined($_[0]\->attr(\*(Aqalt\*(Aq)) } )
.Ve
.PP
That is, it findz elements dat aint gots a \*(L"alt\*(R" attribute at all
(or dat do have a \*(L"alt\*(R" attribute yo, but wit a value of undef \*(--
which aint normally possible).
.PP
Note dat when you give nuff muthafuckin criteria, dis is taken ta mean you is
lookin fo' elements dat match \fIall\fR yo' criterion, not just \fIany\fR
of em.  In other lyrics, there be a implicit \*(L"and\*(R", not a \*(L"or\*(R".  So
if you wanted ta express dat you wanted ta find elements wit a
\&\*(L"name\*(R" attribute wit tha value \*(L"foo\*(R" \fIor\fR wit a \*(L"id\*(R" attribute
with tha value \*(L"baz\*(R", you'd gotta do it like:
.PP
.Vb 7
\&  @them = $h\->look_down(
\&    sub {
\&      # tha lcs is ta fold case
\&      lc($_[0]\->attr(\*(Aqname\*(Aq)) eq \*(Aqfoo\*(Aq
\&      or lc($_[0]\->attr(\*(Aqid\*(Aq)) eq \*(Aqbaz\*(Aq
\&    }
\&  );
.Ve
.PP
Coderef criteria is mo' expressive than \f(CW\*(C`(attr_name, attr_value)\*(C'\fR
and \f(CW\*(C`(attr_name, qr/.../)\*(C'\fR
criteria, n' all \f(CW\*(C`(attr_name, attr_value)\*(C'\fR
and \f(CW\*(C`(attr_name, qr/.../)\*(C'\fR
criteria could be
expressed up in termz of coderefs.  But fuck dat shiznit yo, tha word on tha street is dat \f(CW\*(C`(attr_name, attr_value)\*(C'\fR
and \f(CW\*(C`(attr_name, qr/.../)\*(C'\fR
criteria is a cold-ass lil convenient shorthand. Y'all KNOW dat shit, muthafucka!  (In fact, \f(CW\*(C`look_down\*(C'\fR itself is
basically \*(L"shorthand\*(R" too, since anythang you can do wit \f(CW\*(C`look_down\*(C'\fR
you could do by traversin tha tree, either wit tha \f(CW\*(C`traverse\*(C'\fR
method or wit a routine of yo' own. I aint talkin' bout chicken n' gravy biatch.  But fuck dat shiznit yo, tha word on tha street is dat \f(CW\*(C`look_down\*(C'\fR often
makes fo' straight-up concise n' clear code.)
.SS "look_up"
.IX Subsection "look_up"
.Vb 2
\&  @elements = $h\->look_up( ...criteria... );
\&  $first_match = $h\->look_up( ...criteria... );
.Ve
.PP
This is identical ta \f(CW\*(C`$h\->look_down\*(C'\fR, except dat whereas
\&\f(CW\*(C`$h\->look_down\*(C'\fR
basically scans over tha list:
.PP
.Vb 1
\&   ($h, $h\->descendants)
.Ve
.PP
\&\f(CW\*(C`$h\->look_up\*(C'\fR instead scans over tha list
.PP
.Vb 1
\&   ($h, $h\->lineage)
.Ve
.PP
So, fo' example, dis returns all ancestorz of \f(CW$h\fR (possibly including
\&\f(CW$h\fR itself) dat is \f(CW\*(C`<td>\*(C'\fR elements wit a \*(L"align\*(R" attribute wit a
value of \*(L"right\*(R" (or \*(L"\s-1RIGHT\*(R",\s0 etc.):
.PP
.Vb 1
\&   $h\->look_up("_tag", "td", "align", "right");
.Ve
.SS "traverse"
.IX Subsection "traverse"
.Vb 1
\&  $h\->traverse(...options...)
.Ve
.PP
Lengthy rap of HTML::Elementz unnecessary n' confusing
\&\f(CW\*(C`traverse\*(C'\fR method has been moved ta a separate file:
HTML::Element::traverse
.SS "attr_get_i"
.IX Subsection "attr_get_i"
.Vb 2
\&  @values = $h\->attr_get_i(\*(Aqattribute\*(Aq);
\&  $first_value = $h\->attr_get_i(\*(Aqattribute\*(Aq);
.Ve
.PP
In list context, returns a list consistin of tha jointz of tha given
attribute fo' \f(CW$h\fR n' fo' all its ancestors startin from \f(CW$h\fR and
workin its way up.  Nodes wit no such attribute is skipped.
(\*(L"attr_get_i\*(R" standz fo' \*(L"attribute get, wit inheritance\*(R".)
In scalar context, returns tha straight-up original gangsta such value, or undef if none.
.PP
Consider a thugged-out document consistin of:
.PP
.Vb 10
\&   <html lang=\*(Aqi\-klingon\*(Aq>
\&     <head><title>Pati Pata</title></head>
\&     <body>
\&       <h1 lang=\*(Aqla\*(Aq>Stuff</h1>
\&       <p lang=\*(Aqes\-MX\*(Aq align=\*(Aqcenter\*(Aq>
\&         Foo bar baz <cite>Quux</cite>.
\&       </p>
\&       <p>Hooboy.</p>
\&     </body>
\&   </html>
.Ve
.PP
If \f(CW$h\fR is tha \f(CW\*(C`<cite>\*(C'\fR element, \f(CW\*(C`$h\->attr_get_i("lang")\*(C'\fR
in list context will return tha list \f(CW\*(C`(\*(Aqes\-MX\*(Aq, \*(Aqi\-klingon\*(Aq)\*(C'\fR.
In scalar context, it will return tha value \f(CW\*(Aqes\-MX\*(Aq\fR.
.PP
If you call wit multiple attribute names...
.PP
.Vb 2
\&  @values = $h\->attr_get_i(\*(Aqa1\*(Aq, \*(Aqa2\*(Aq, \*(Aqa3\*(Aq);
\&  $first_value = $h\->attr_get_i(\*(Aqa1\*(Aq, \*(Aqa2\*(Aq, \*(Aqa3\*(Aq);
.Ve
.PP
\&...in list context, dis will return a list consistin of
the jointz of these attributes which exist up in \f(CW$h\fR n' its ancestors.
In scalar context, dis returns tha straight-up original gangsta value (i.e., tha value of
the first existin attribute from tha straight-up original gangsta element dat has
any of tha attributes listed).  So, up in tha above example,
.PP
.Vb 1
\&  $h\->attr_get_i(\*(Aqlang\*(Aq, \*(Aqalign\*(Aq);
.Ve
.PP
will return:
.PP
.Vb 3
\&   (\*(Aqes\-MX\*(Aq, \*(Aqcenter\*(Aq, \*(Aqi\-klingon\*(Aq) # up in list context
\&  or
\&   \*(Aqes\-MX\*(Aq # up in scalar context.
.Ve
.PP
But note dat this:
.PP
.Vb 1
\& $h\->attr_get_i(\*(Aqalign\*(Aq, \*(Aqlang\*(Aq);
.Ve
.PP
will return:
.PP
.Vb 3
\&   (\*(Aqcenter\*(Aq, \*(Aqes\-MX\*(Aq, \*(Aqi\-klingon\*(Aq) # up in list context
\&  or
\&   \*(Aqcenter\*(Aq # up in scalar context.
.Ve
.SS "tagname_map"
.IX Subsection "tagname_map"
.Vb 1
\&  $hash_ref = $h\->tagname_map();
.Ve
.PP
Scans across \f(CW$h\fR n' all its descendants, n' cook up a hash (a
reference ta which is returned) where each entry consistz of a key
thatz a tag name, n' a value thatz a reference ta a list ta all
elements dat have dat tag name.  I.e., dis method returns:
.PP
.Vb 6
\&   {
\&     # Across $h n' all descendants...
\&     \*(Aqa\*(Aq   => [ ...list of all <a>   elements... ],
\&     \*(Aqem\*(Aq  => [ ...list of all <em>  elements... ],
\&     \*(Aqimg\*(Aq => [ ...list of all <img> elements... ],
\&   }
.Ve
.PP
(There is entries up in tha hash fo' only dem tagnames dat occur
at/under \f(CW$h\fR \*(-- so if there be a no \f(CW\*(C`<img>\*(C'\fR elements, there'll be no
\&\*(L"img\*(R" entry up in tha returned hashref.)
.PP
Example usage:
.PP
.Vb 7
\&    mah $map_r = $h\->tagname_map();
\&    mah @heading_tags = sort grep m/^h\ed$/s, keys %$map_r;
\&    if(@heading_tags) {
\&      print "Headin levels used: @heading_tags\en";
\&    } else {
\&      print "No headings.\en"
\&    }
.Ve
.SS "extract_links"
.IX Subsection "extract_links"
.Vb 2
\&  $links_array_ref = $h\->extract_links();
\&  $links_array_ref = $h\->extract_links(@wantedTypes);
.Ve
.PP
Returns links found by traversin tha element n' all of its children
and lookin fo' attributes (like \*(L"href\*(R" up in a \f(CW\*(C`<a>\*(C'\fR element, or \*(L"src\*(R" in
an \f(CW\*(C`<img>\*(C'\fR element) whose joints represent links.  Da return value be a
\&\fIreference\fR ta a array.  Each element of tha array is reference to
an array wit \fIfour\fR items: tha link-value, tha element dat has the
attribute wit dat link-value, n' tha name of dat attribute, and
the tagname of dat element.
(Example: \f(CW\*(C`[\*(Aqhttp://www.suck.com/\*(Aq,\*(C'\fR \fI\f(CI$elem_obj\fI\fR \f(CW\*(C`, \*(Aqhref\*(Aq, \*(Aqa\*(Aq]\*(C'\fR.)
Yo ass may or may not end up rockin the
element itself \*(-- fo' some purposes, you may use only tha link value.
.PP
Yo ass might specify dat you wanna extract links from just some kinds
of elements (instead of tha default, which is ta extract links from
\&\fIall\fR tha kindz of elements known ta have attributes whose joints
represent links).  For instance, if you wanna extract links from
only \f(CW\*(C`<a>\*(C'\fR n' \f(CW\*(C`<img>\*(C'\fR elements, you could code it like this:
.PP
.Vb 7
\&  fo' (@{  $e\->extract_links(\*(Aqa\*(Aq, \*(Aqimg\*(Aq)  }) {
\&      my($link, $element, $attr, $tag) = @$_;
\&      print
\&        "Yo, there\*(Aqs a $tag dat links ta ",
\&        $link, ", up in its $attr attribute, at ",
\&        $element\->address(), ".\en";
\&  }
.Ve
.SS "simplify_pres"
.IX Subsection "simplify_pres"
.Vb 1
\&  $h\->simplify_pres();
.Ve
.PP
In text bits under \s-1PRE\s0 elements dat is at/under \f(CW$h\fR, dis routine
nativizes all newlines, n' expandz all tabs.
.PP
That is, if you read a gangbangin' file wit lines delimited by \f(CW\*(C`\ecm\ecj\*(C'\fR's, the
text under \s-1PRE\s0 areas gonna git \f(CW\*(C`\ecm\ecj\*(C'\fRz instead of \f(CW\*(C`\en\*(C'\fR's. Calling
\&\f(CW\*(C`$h\->simplify_pres\*(C'\fR on such a tree will turn \f(CW\*(C`\ecm\ecj\*(C'\fRz into
\&\f(CW\*(C`\en\*(C'\fR's.
.PP
Tabs is expanded ta however nuff spaces it takes ta get
to tha next 8th column \*(-- tha usual way of expandin em.
.SS "same_as"
.IX Subsection "same_as"
.Vb 1
\&  $equal = $h\->same_as($i)
.Ve
.PP
Returns legit if \f(CW$h\fR n' \f(CW$i\fR is both elements representin tha same tree
of elements, each wit tha same tag name, wit tha same explicit
attributes (i.e., not countin attributes whose names start wit \*(L"_\*(R"),
and wit tha same content (textual, comments, etc.).
.PP
Samenizz of descendant elements is tested, recursively, with
\&\f(CW\*(C`$child1\->same_as($child_2)\*(C'\fR, n' samenizz of text segments is tested
with \f(CW\*(C`$segment1 eq $segment2\*(C'\fR.
.SS "new_from_lol"
.IX Subsection "new_from_lol"
.Vb 2
\&  $h = HTML::Element\->new_from_lol($array_ref);
\&  @elements = HTML::Element\->new_from_lol($array_ref, ...);
.Ve
.PP
Resursively constructs a tree of nodes, based on tha (non-cyclic)
data structure represented by each \f(CW$array_ref\fR, where dat be a reference
to a array of arrays (of arrays (of arrays (etc.))).
.PP
In each arrayref up in dat structure, different kindz of joints are
treated as bigs up:
.IP "\(bu" 4
Arrayrefs
.Sp
Arrayrefs is considered to
designate a sub-tree representin lil pimps fo' tha node constructed
from tha current arrayref.
.IP "\(bu" 4
Hashrefs
.Sp
Hashrefs is considered ta contain
attribute-value pairs ta add ta tha element ta be constructed from
the current arrayref
.IP "\(bu" 4
Text segments
.Sp
Text segments all up in tha start of any arrayref
will be considered ta specify tha name of tha element ta be
constructed from tha current arrayref; all other text segments will
be considered ta specify text segments as lil pimps fo' tha current
arrayref.
.IP "\(bu" 4
Elements
.Sp
Existin element objects is either banged tha fuck into tha treelet
constructed, or clonez of dem are.  That is, when tha lol-tree is
bein traversed n' elements constructed based whatz up in it, if
an existin element object is found, if it has no parent, then it is
added directly ta tha treelet constructed; but if it has a parent,
then \f(CW\*(C`$that_node\->clone\*(C'\fR be added ta tha treelet at the
appropriate place.
.PP
An example will hopefully make dis mo' obvious:
.PP
.Vb 10
\&  mah $h = HTML::Element\->new_from_lol(
\&    [\*(Aqhtml\*(Aq,
\&      [\*(Aqhead\*(Aq,
\&        [ \*(Aqtitle\*(Aq, \*(AqI wanna bust a nut on stuff!\*(Aq ],
\&      ],
\&      [\*(Aqbody\*(Aq,
\&        {\*(Aqlang\*(Aq, \*(Aqen\-JP\*(Aq, _implicit => 1},
\&        \*(Aqstuff\*(Aq,
\&        [\*(Aqp\*(Aq, \*(Aqum, p < 4!\*(Aq, {\*(Aqclass\*(Aq => \*(Aqpar123\*(Aq}],
\&        [\*(Aqdiv\*(Aq, {foo => \*(Aqbar\*(Aq}, \*(Aq123\*(Aq],
\&      ]
\&    ]
\&  );
\&  $h\->dump;
.Ve
.PP
Will print this:
.PP
.Vb 10
\&  <html> @0
\&    <head> @0.0
\&      <title> @0.0.0
\&        "I wanna bust a nut on stuff!"
\&    <body lang="en\-JP"> @0.1 (IMPLICIT)
\&      "stuff"
\&      <p class="par123"> @0.1.1
\&        "um, p < 4!"
\&      <div foo="bar"> @0.1.2
\&        "123"
.Ve
.PP
And printin \f(CW$h\fR\->as_HTML will give suttin' like:
.PP
.Vb 3
\&  <html><head><title>I wanna bust a nut on stuff!</title></head>
\&  <body lang="en\-JP">stuff<p class="par123">um, p &lt; 4!
\&  <div foo="bar">123</div></body></html>
.Ve
.PP
Yo ass can even do fancy thangs wit \f(CW\*(C`map\*(C'\fR:
.PP
.Vb 10
\&  $body\->push_content(
\&    # push_content implicitly calls new_from_lol on arrayrefs...
\&    [\*(Aqbr\*(Aq],
\&    [\*(Aqblockquote\*(Aq,
\&      [\*(Aqh2\*(Aq, \*(AqPictures!\*(Aq],
\&      map [\*(Aqp\*(Aq, $_],
\&      $body2\->look_down("_tag", "img"),
\&        # images, ta be copied from dat other tree.
\&    ],
\&    # n' mo' stuff:
\&    [\*(Aqul\*(Aq,
\&      map [\*(Aqli\*(Aq, [\*(Aqa\*(Aq, {\*(Aqhref\*(Aq=>"$_.png"}, $_ ] ],
\&      qw(Peaches Applez Pears Mangos)
\&    ],
\&  );
.Ve
.PP
In scalar context, you must supply exactly one arrayref.  In list
context, you can pass a list of arrayrefs, n' new_from_lol will
return a list of elements, one fo' each arrayref.
.PP
.Vb 5
\&  @elements = HTML::Element\->new_from_lol(
\&    [\*(Aqhr\*(Aq],
\&    [\*(Aqp\*(Aq, \*(AqAnd there, on tha door, was a hook!\*(Aq],
\&  );
\&   # constructs two elements.
.Ve
.SS "objectify_text"
.IX Subsection "objectify_text"
.Vb 1
\&  $h\->objectify_text();
.Ve
.PP
This turns any text nodes under \f(CW$h\fR from mere text segments (strings)
into real objects, pseudo-elements wit a tag-name of \*(L"~text\*(R", n' the
actual text content up in a attribute called \*(L"text\*(R".  (For a gangbangin' finger-lickin' rap
of pseudo-elements, peep tha \*(L"tag\*(R" method, far above.)  This method is
provided cuz, fo' some purposes, it is convenient or necessary to
be able, fo' a given text node, ta ask what tha fuck element is its parent; and
clearly dis aint possible if a node is just a text string.
.PP
Note dat these \*(L"~text\*(R" objects is not recognized as text nodes by
methodz like \*(L"as_text\*(R".  Presumably yo big-ass booty is ghon wanna call
\&\f(CW\*(C`$h\->objectify_text\*(C'\fR, big-ass up whatever task dat you needed dat for,
and then call \f(CW\*(C`$h\->deobjectify_text\*(C'\fR before callin anythang like
\&\f(CW\*(C`$h\->as_text\*(C'\fR.
.SS "deobjectify_text"
.IX Subsection "deobjectify_text"
.Vb 1
\&  $h\->deobjectify_text();
.Ve
.PP
This undoes tha effect of \f(CW\*(C`$h\->objectify_text\*(C'\fR.  That is, it takes any
\&\*(L"~text\*(R" pseudo-elements up in tha tree at/under \f(CW$h\fR, n' deletes each one,
replacin each wit tha content of its \*(L"text\*(R" attribute.
.PP
Note dat if \f(CW$h\fR itself be a \*(L"~text\*(R" pseudo-element, it will be
destroyed \*(-- a cold-ass lil condizzle you may need ta treat specially up in your
callin code (since it means you can't straight-up well do anythang wit \f(CW$h\fR
afta that).  So dat you can detect dat condition, if \f(CW$h\fR is itself a
\&\*(L"~text\*(R" pseudo-element, then dis method returns tha value of the
\&\*(L"text\*(R" attribute, which should be a thugged-out defined value; up in all other cases,
it returns undef.
.PP
(This method assumes dat no \*(L"~text\*(R" pseudo-element has any lil' thugs.)
.SS "number_lists"
.IX Subsection "number_lists"
.Vb 1
\&  $h\->number_lists();
.Ve
.PP
For every last muthafuckin \s-1UL, OL, DIR,\s0 n' \s-1MENU\s0 element at/under \f(CW$h\fR, dis sets a
\&\*(L"_bullet\*(R" attribute fo' every last muthafuckin lil pimp \s-1LI\s0 element.  For \s-1LI\s0 lil pimpz of an
\&\s-1OL,\s0 tha \*(L"_bullet\*(R" attributez value is ghon be suttin' like \*(L"4.\*(R", \*(L"d.\*(R",
\&\*(L"D.\*(R", \*(L"\s-1IV.\*(R",\s0 or \*(L"iv.\*(R", dependin on tha \s-1OL\s0 elementz \*(L"type\*(R" attribute.
\&\s-1LI\s0 lil pimpz of a \s-1UL, DIR,\s0 or \s-1MENU\s0 git they \*(L"_bullet\*(R" attribute set
to \*(L"*\*(R".
There should be no other LIs (i.e., except as lil pimpz of \s-1OL, UL, DIR,\s0
or \s-1MENU\s0 elements), n' if there are, they is unaffected.
.SS "has_insane_linkage"
.IX Subsection "has_insane_linkage"
.Vb 1
\&  $h\->has_insane_linkage
.Ve
.PP
This method is fo' testin whether dis element or tha elements
under it have linkage attributes (_parent n' _content) whose joints
are deeply aberrant: if there be undefs up in a cold-ass lil content list; if an
element appears up in tha content listz of mo' than one element;
if tha _parent attribute of a element don't match its actual
parent; or if a element appears as its own descendant (i.e.,
if there be a cold-ass lil cyclicitizzle up in tha tree).
.PP
This returns empty list (or false, up in scalar context) if tha subtree's
linkage methodz is sane; otherwise it returns two shit (or true, in
scalar context): tha element where tha error occurred, n' a string
describin tha error.
.PP
This method is provided is mainly fo' debuggin n' shitshootin \*(--
it should be \fIquite impossible\fR fo' any document constructed via
HTML::TreeBuilder ta parse tha fuck into a non-sane tree (since itz not
the content of tha tree per se thatz up in question yo, but whether
the tree up in memory was properly constructed); n' it \fIshould\fR be
impossible fo' you ta produce a crazy tree just thru reasonable
use of aiiight documented structure-modifyin methods.  But if you is
constructin yo' own trees, n' yo' program is goin tha fuck into infinite
loops as durin calls ta \fItraverse()\fR or any of tha secondary
structural methods, as part of debugging, consider calling
\&\f(CW\*(C`has_insane_linkage\*(C'\fR on tha tree.
.SS "element_class"
.IX Subsection "element_class"
.Vb 1
\&  $classname = $h\->element_class();
.Ve
.PP
This method returns tha class which is ghon be used fo' freshly smoked up elements, n' you can put dat on yo' toast.  It
defaults ta HTML::Element yo, but can be overridden by subclassin or esoteric
means dopest left ta dem will will read tha source n' then not diss when
those esoteric means chizzle.  (Just subclass.)
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.SS "Use_Weak_Refs"
.IX Subsection "Use_Weak_Refs"
.Vb 2
\&  $enabled = HTML::Element\->Use_Weak_Refs;
\&  HTML::Element\->Use_Weak_Refs( $enabled );
.Ve
.PP
This method allows you ta check whether weak reference support is
enabled, n' ta enable or disable dat shit. For details, peep \*(L"Weak References\*(R".
\&\f(CW$enabled\fR is legit if weak references is enabled.
.PP
Yo ass should not switch dis up in tha middle of yo' program, n' you
probably shouldn't use it at all.  Existin trees is not affected by
this method (until you start modifyin nodes up in them).
.PP
Throws a exception if you attempt ta enable weak references n' your
Perl or Scalar::Util do not support em.
.PP
Disablin weak reference support is deprecated.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.SS "Version"
.IX Subsection "Version"
This subroutine is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Please use tha standard \s-1VERSION\s0 method
(e.g. \f(CW\*(C`HTML::Element\->VERSION\*(C'\fR) instead.
.SS "\s-1ABORT OK PRUNE PRUNE_SOFTLY PRUNE_UP\s0"
.IX Subsection "ABORT OK PRUNE PRUNE_SOFTLY PRUNE_UP"
Constants fo' signallin back ta tha traverser
.SH "BUGS"
.IX Header "BUGS"
* If you wanna free tha memory associated wit a tree built of
HTML::Element nodes, n' you have disabled weak references, then you
will gotta delete it explicitly rockin tha \*(L"delete\*(R" method.
See \*(L"Weak References\*(R".
.PP
* Therez almost not a god damn thang ta stop you from bustin a \*(L"tree\*(R" with
cyclicitizzles (loops) up in it, which could, fo' example, make the
traverse method go tha fuck into a infinite loop.  So don't make
cyclicities muthafucka!  (If all you bustin is parsin \s-1HTML\s0 files,
and lookin all up in tha resultin trees, dis aint NEVER gonna be a problem
for yo thugged-out ass.)
.PP
* Therez no way ta represent comments or processin directives
in a tree wit HTML::Elements, n' you can put dat on yo' toast.  Not yet, at least.
.PP
* Therez (currently) not a god damn thang ta stop you from rockin a undefined
value as a text segment.  If you hustlin under \f(CW\*(C`perl \-w\*(C'\fR, however,
this may make HTML::Elementz code produce a slew of warnings.
.SH "NOTES ON SUBCLASSING"
.IX Header "NOTES ON SUBCLASSING"
Yo ass is welcome ta derive subclasses from HTML::Element yo, but you
should be aware dat tha code up in HTML::Element make certain
assumptions bout elements (and I be rockin \*(L"element\*(R" ta mean \s-1ONLY\s0 an
object of class HTML::Element, or of a subclass of HTML::Element):
.PP
* Da value of a elementz _parent attribute must either be undef or
otherwise false, or must be a element.
.PP
* Da value of a elementz _content attribute must either be undef or
otherwise false, or a reference ta a (unblessed) array.  Da array
may be empty; but if it has items, they must \s-1ALL\s0 be either mere
strings (text segments), or elements.
.PP
* Da value of a elementz _tag attribute should, at least, be a
strin of printable characters.
.PP
Mo'over, bear these rulez up in mind:
.PP
* Do not break encapsulation on objects, n' you can put dat on yo' toast.  That is, access their
contents only thru \f(CW$obj\fR\->attr or mo' specific methods.
.PP
* Yo ass should be thinkin twice before straight-up overridin any of the
methodz dat HTML::Element provides.  (Overridin wit a method that
calls tha superclass method aint so bad, though.)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTML::Tree; HTML::TreeBuilder; HTML::AsSubs; HTML::Tagset;
and, fo' tha morbidly curious, HTML::Element::traverse.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks ta Mark-Jizzo Dominus fo' a \s-1POD\s0 suggestion.
.SH "AUTHOR"
.IX Header "AUTHOR"
Current maintainers:
.IP "\(bu" 4
Christopher J. Madsen \f(CW\*(C`<perl\ AT\ cjmweb.net>\*(C'\fR
.IP "\(bu" 4
Jeff Fearn \f(CW\*(C`<jfearn\ AT\ cpan.org>\*(C'\fR
.PP
Original Gangsta HTML-Tree author:
.IP "\(bu" 4
Gisle Aas
.PP
Forma maintainers:
.IP "\(bu" 4
Shizzle M. Burke
.IP "\(bu" 4
Andy Lester
.IP "\(bu" 4
Pete Krawczyk \f(CW\*(C`<petek\ AT\ cpan.org>\*(C'\fR
.PP
Yo ass can follow or contribute ta HTML-Treez pimpment at
<http://github.com/madsen/HTML\-Tree>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1995\-1998 Gisle Aas, 1999\-2004 Shizzle M. Burke,
2005 Andy Lester, 2006 Pete Krawczyk, 2010 Jeff Fearn,
2012 Christopher J. Madsen.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.PP
Da programs up in dis library is distributed up in tha hope dat they
will be useful yo, but without any warranty; without even tha implied
warranty of merchantabilitizzle or fitnizz fo' a particular purpose.
