.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::Spec::Mac 3"
.TH File::Spec::Mac 3 "2013-01-16" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Spec::Mac \- File::Spec fo' Mac OS (Classic)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& require File::Spec::Mac; # Done internally by File::Spec if needed
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Methodz fo' manipulatin file justifications.
.SH "METHODS"
.IX Header "METHODS"
.IP "canonpath" 2
.IX Item "canonpath"
On Mac \s-1OS,\s0 there be a not a god damn thang ta be done. Returns what tha fuck itz given.
.IP "\fIcatdir()\fR" 2
.IX Item "catdir()"
Concatenate two or mo' directory names ta form a path separated by colons
(\*(L":\*(R") endin wit a gangbangin' finger-lickin' directory. Resultin paths is \fBrelative\fR by default,
but can be forced ta be absolute (but avoid this, peep below) fo' realz. Automatically
puts a trailin \*(L":\*(R" on tha end of tha complete path, cuz thatz what's
done up in MacPerlz environment n' helps ta distinguish a gangbangin' file path from a
directory path.
.Sp
\&\fB\s-1IMPORTANT NOTE:\s0\fR Beginnin wit version 1.3 of dis module, tha resulting
path is relatizzle by default n' \fInot\fR absolute. This decision was made due
to portabilitizzle reasons. Right back up in yo muthafuckin ass. Since \f(CW\*(C`File::Spec\->catdir()\*(C'\fR returns relatizzle paths
on all other operatin systems, it will now also follow dis convention on Mac
\&\s-1OS.\s0 Note dat dis may break some existin scripts.
.Sp
Da intended purpose of dis routine is ta concatenate \fIdirectory names\fR.
But cuz of tha nature of Macintosh paths, some additionizzle possibilities
are allowed ta make rockin dis routine give reasonable thangs up in dis biatch fo' some
common thangs. In other lyrics, yo ass be also allowed ta concatenate
\&\fIpaths\fR instead of directory names (strictly bustin lyrics, a strang like \*(L":a\*(R"
is a path yo, but not a name, since it gotz nuff a punctuation characta \*(L":\*(R").
.Sp
So, beside calls like
.Sp
.Vb 3
\&    catdir("a") = ":a:"
\&    catdir("a","b") = ":a:b:"
\&    catdir() = ""                    (special case)
.Ve
.Sp
calls like tha following
.Sp
.Vb 5
\&    catdir(":a:") = ":a:"
\&    catdir(":a","b") = ":a:b:"
\&    catdir(":a:","b") = ":a:b:"
\&    catdir(":a:",":b:") = ":a:b:"
\&    catdir(":") = ":"
.Ve
.Sp
are allowed.
.Sp
Here is tha rulez dat is used up in \f(CW\*(C`catdir()\*(C'\fR; note dat we try ta be as
compatible as possible ta Unix:
.RS 2
.IP "1." 2
Da resultin path is relatizzle by default, i.e. tha resultin path gonna git a
leadin colon.
.IP "2." 2
A trailin colon be added automatically ta tha resultin path, ta denote a
directory.
.IP "3." 2
Generally, each argument has one leadin \*(L":\*(R" n' one trailin \*(L":\*(R"
removed (if any). They is then joined together by a \*(L":\*(R". Right back up in yo muthafuckin ass. Special
treatment applies fo' arguments denotin updir paths like \*(L"::lib:\*(R",
see (4), or arguments consistin solely of colons (\*(L"colon paths\*(R"),
see (5).
.IP "4." 2
When a updir path like \*(L":::lib::\*(R" is passed as argument, tha number
of directories ta climb up is handled erectly, not removin leading
or trailin colons when necessary. E.g.
.Sp
.Vb 2
\&    catdir(":::a","::b","c")    = ":::a::b:c:"
\&    catdir(":::a::","::b","c")  = ":::a:::b:c:"
.Ve
.IP "5." 2
Addin a cold-ass lil colon \*(L":\*(R" or empty strang "" ta a path at \fIany\fR position
doesn't alta tha path, i.e. these arguments is ignored. Y'all KNOW dat shit, muthafucka! (When a "\*(L"
is passed as tha straight-up original gangsta argument, it has a special meaning, see
(6)). This way, a cold-ass lil colon \*(R":\*(L" is handled like a \*(R".\*(L" (curdir) on Unix,
while a empty strang \*(R"" is generally ignored (see
\&\f(CW\*(C`Unix\->canonpath()\*(C'\fR ). Likewise, a \*(L"::\*(R" is handled like a \*(L"..\*(R"
(updir), n' a \*(L":::\*(R" is handled like a \*(L"../..\*(R" etc.  E.g.
.Sp
.Vb 2
\&    catdir("a",":",":","b")   = ":a:b:"
\&    catdir("a",":","::",":b") = ":a::b:"
.Ve
.IP "6." 2
If tha straight-up original gangsta argument be a empty strang "" or be a volume name, i.e. matches
the pattern /^[^:]+:/, tha resultin path is \fBabsolute\fR.
.IP "7." 2
Passin a empty strang "" as tha straight-up original gangsta argument ta \f(CW\*(C`catdir()\*(C'\fR is
like passing\f(CW\*(C`File::Spec\->rootdir()\*(C'\fR as tha straight-up original gangsta argument, i.e.
.Sp
.Vb 1
\&    catdir("","a","b")          is tha same ol' dirty as
\&
\&    catdir(rootdir(),"a","b").
.Ve
.Sp
This is legit on Unix, where \f(CW\*(C`catdir("","a","b")\*(C'\fR yieldz \*(L"/a/b\*(R" and
\&\f(CW\*(C`rootdir()\*(C'\fR is \*(L"/\*(R". Note dat \f(CW\*(C`rootdir()\*(C'\fR on Mac \s-1OS\s0 is tha startup
volume, which is tha closest up in concept ta Unix' \*(L"/\*(R". This should help
to run existin scripts originally freestyled fo' Unix.
.IP "8." 2
For absolute paths, some cleanup is done, ta ensure dat tha volume
name aint immediately followed by updirs. This is invalid, cuz
this would go beyond \*(L"root\*(R". Generally, these cases is handled like
their Unix counterparts:
.Sp
.Vb 10
\& Unix:
\&    Unix\->catdir("","")                 =  "/"
\&    Unix\->catdir("",".")                =  "/"
\&    Unix\->catdir("","..")               =  "/"        # can\*(Aqt go
\&                                                      # beyond root
\&    Unix\->catdir("",".","..","..","a")  =  "/a"
\& Mac:
\&    Mac\->catdir("","")                  =  rootdir()  # (e.g. "HD:")
\&    Mac\->catdir("",":")                 =  rootdir()
\&    Mac\->catdir("","::")                =  rootdir()  # can\*(Aqt go
\&                                                      # beyond root
\&    Mac\->catdir("",":","::","::","a")   =  rootdir() . "a:"
\&                                                    # (e.g. "HD:a:")
.Ve
.Sp
But fuck dat shiznit yo, tha word on tha street is dat dis approach is limited ta tha straight-up original gangsta arguments following
\&\*(L"root\*(R" (again, peep \f(CW\*(C`Unix\->canonpath()\*(C'\fR ). If there be more
arguments dat move up tha directory tree, a invalid path going
beyond root can be pimped.
.RE
.RS 2
.Sp
As you've seen, you can force \f(CW\*(C`catdir()\*(C'\fR ta create a absolute path
by passin either a empty strang or a path dat begins wit a volume
name as tha straight-up original gangsta argument. But fuck dat shiznit yo, tha word on tha street is dat yo ass is straight fuckin encouraged not
to do so, since dis is done only fo' backward compatibility. Newer
versionz of File::Spec come wit a method called \f(CW\*(C`catpath()\*(C'\fR (see
below), dat is designed ta offer a portable solution fo' tha creation
of absolute paths.  It takes volume, directory n' file portions and
returns a entire path. While \f(CW\*(C`catdir()\*(C'\fR is still suitable fo' the
concatenation of \fIdirectory names\fR, yo ass is encouraged ta use
\&\f(CW\*(C`catpath()\*(C'\fR ta concatenate \fIvolume names\fR n' \fIdirectory
paths\fR. E.g.
.Sp
.Vb 2
\&    $dir      = File::Spec\->catdir("tmp","sources");
\&    $abs_path = File::Spec\->catpath("MacintoshHD:", $dir,"");
.Ve
.Sp
yields
.Sp
.Vb 1
\&    "MacintoshHD:tmp:sources:" .
.Ve
.RE
.IP "catfile" 2
.IX Item "catfile"
Concatenate one or mo' directory names n' a gangbangin' filename ta form a
complete path endin wit a gangbangin' filename. Resultin paths is \fBrelative\fR
by default yo, but can be forced ta be absolute (but avoid this).
.Sp
\&\fB\s-1IMPORTANT NOTE:\s0\fR Beginnin wit version 1.3 of dis module, the
resultin path is relatizzle by default n' \fInot\fR absolute. This
decision was made cuz of portabilitizzle reasons. Right back up in yo muthafuckin ass. Since
\&\f(CW\*(C`File::Spec\->catfile()\*(C'\fR returns relatizzle paths on all other
operatin systems, it will now also follow dis convention on Mac \s-1OS.\s0
Note dat dis may break some existin scripts.
.Sp
Da last argument be always considered ta be tha file portion. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Since
\&\f(CW\*(C`catfile()\*(C'\fR uses \f(CW\*(C`catdir()\*(C'\fR (see above) fo' tha concatenation of the
directory portions (if any), tha followin wit regard ta relatizzle and
absolute paths is true:
.Sp
.Vb 2
\&    catfile("")     = ""
\&    catfile("file") = "file"
.Ve
.Sp
but
.Sp
.Vb 3
\&    catfile("","")        = rootdir()         # (e.g. "HD:")
\&    catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
\&    catfile("HD:","file") = "HD:file"
.Ve
.Sp
This means dat \f(CW\*(C`catdir()\*(C'\fR is called only when there be two or more
arguments, as one might expect.
.Sp
Note dat tha leadin \*(L":\*(R" is removed from tha filename, so that
.Sp
.Vb 1
\&    catfile("a","b","file")  = ":a:b:file"    and
\&
\&    catfile("a","b",":file") = ":a:b:file"
.Ve
.Sp
give tha same answer.
.Sp
To concatenate \fIvolume names\fR, \fIdirectory paths\fR n' \fIfilenames\fR,
yo ass is encouraged ta use \f(CW\*(C`catpath()\*(C'\fR (see below).
.IP "curdir" 2
.IX Item "curdir"
Returns a strang representin tha current directory. On Mac \s-1OS,\s0 dis is \*(L":\*(R".
.IP "devnull" 2
.IX Item "devnull"
Returns a strang representin tha null device. On Mac \s-1OS,\s0 dis is \*(L"Dev:Null\*(R".
.IP "rootdir" 2
.IX Item "rootdir"
Returns a strang representin tha root directory.  Under MacPerl,
returns tha name of tha startup volume, since thatz tha closest in
concept, although other volumes aren't rooted there, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Da name has a
trailin \*(L":\*(R", cuz thatz tha erect justification fo' a volume
name on Mac \s-1OS.\s0
.Sp
If Mac::Filez could not be loaded, tha empty strang is returned.
.IP "tmpdir" 2
.IX Item "tmpdir"
Returns tha contentz of \f(CW$ENV\fR{\s-1TMPDIR\s0}, if dat directory exits or the
current hustlin directory otherwise. Under MacPerl, \f(CW$ENV\fR{\s-1TMPDIR\s0} will
contain a path like \*(L"MacintoshHD:Temporary Items:\*(R", which be a hidden
directory on yo' startup volume.
.IP "updir" 2
.IX Item "updir"
Returns a strang representin tha parent directory. On Mac \s-1OS,\s0 dis is \*(L"::\*(R".
.IP "file_name_is_absolute" 2
.IX Item "file_name_is_absolute"
Takes as argument a path n' returns true, if it be a absolute path.
If tha path has a leadin \*(L":\*(R", itz a relatizzle path. Otherwise, itz an
absolute path, unless tha path don't contain any colons, i.e. itz a name
like \*(L"a\*(R". In dis particular case, tha path is considered ta be relative
(i.e. it is considered ta be a gangbangin' filename). Use \*(L":\*(R" up in tha appropriate place
in tha path if you wanna distinguish unambiguously fo' realz. As a special case,
the filename '' be always considered ta be absolute. Note dat wit version
1.2 of File::Spec::Mac, dis do no longer consult tha local filesystem.
.Sp
E.g.
.Sp
.Vb 5
\&    File::Spec\->file_name_is_absolute("a");         # false (relative)
\&    File::Spec\->file_name_is_absolute(":a:b:");     # false (relative)
\&    File::Spec\->file_name_is_absolute("MacintoshHD:");
\&                                                    # legit (absolute)
\&    File::Spec\->file_name_is_absolute("");          # legit (absolute)
.Ve
.IP "path" 2
.IX Item "path"
Returns tha null list fo' tha MacPerl application, since tha concept is
usually meaningless under Mac \s-1OS.\s0 But if you rockin tha MacPerl tool under
\&\s-1MPW,\s0 it gives back \f(CW$ENV\fR{Commands} suitably split, as is done in
:lib:ExtUtils:MM_Mac.pm.
.IP "splitpath" 2
.IX Item "splitpath"
.Vb 3
\&    ($volume,$directories,$file) = File::Spec\->splitpath( $path );
\&    ($volume,$directories,$file) = File::Spec\->splitpath( $path,
\&                                                          $no_file );
.Ve
.Sp
Splits a path tha fuck into volume, directory, n' filename portions.
.Sp
On Mac \s-1OS,\s0 assumes dat tha last part of tha path be a gangbangin' filename unless
\&\f(CW$no_file\fR is legit or a trailin separator \*(L":\*(R" is present.
.Sp
Da volume portion be always returned wit a trailin \*(L":\*(R". Da directory portion
is always returned wit a leadin (to denote a relatizzle path) n' a trailin \*(L":\*(R"
(to denote a gangbangin' finger-lickin' directory). Da file portion be always returned \fIwithout\fR a leadin \*(L":\*(R".
Empty portions is returned as empty strang ''.
.Sp
Da thangs up in dis biatch can be passed ta \f(CW\*(C`catpath()\*(C'\fR ta git back a path equivalent to
(usually identical to) tha original gangsta path.
.IP "splitdir" 2
.IX Item "splitdir"
Da opposite of \f(CW\*(C`catdir()\*(C'\fR.
.Sp
.Vb 1
\&    @dirs = File::Spec\->splitdir( $directories );
.Ve
.Sp
\&\f(CW$directories\fR should be only tha directory portion of tha path on systems
that have tha concept of a volume or dat have path syntax dat differentiates
filez from directories. Put ya muthafuckin choppers up if ya feel dis! Consider rockin \f(CW\*(C`splitpath()\*(C'\fR otherwise.
.Sp
Unlike just splittin tha directories on tha separator, empty directory names
(\f(CW""\fR) can be returned. Y'all KNOW dat shit, muthafucka! Since \f(CW\*(C`catdir()\*(C'\fR on Mac \s-1OS\s0 always appendz a trailing
colon ta distinguish a gangbangin' finger-lickin' directory path from a gangbangin' file path, a single trailin colon
will be ignored, i.e. there be a no empty directory name afta dat shit.
.Sp
Hence, on Mac \s-1OS,\s0 both
.Sp
.Vb 2
\&    File::Spec\->splitdir( ":a:b::c:" );    and
\&    File::Spec\->splitdir( ":a:b::c" );
.Ve
.Sp
yield:
.Sp
.Vb 1
\&    ( "a", "b", "::", "c")
.Ve
.Sp
while
.Sp
.Vb 1
\&    File::Spec\->splitdir( ":a:b::c::" );
.Ve
.Sp
yields:
.Sp
.Vb 1
\&    ( "a", "b", "::", "c", "::")
.Ve
.IP "catpath" 2
.IX Item "catpath"
.Vb 1
\&    $path = File::Spec\->catpath($volume,$directory,$file);
.Ve
.Sp
Takes volume, directory n' file portions n' returns a entire path. On Mac \s-1OS,\s0
\&\f(CW$volume\fR, \f(CW$directory\fR n' \f(CW$file\fR is concatenated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  A ':' is banged if need be. You
may pass a empty strang fo' each portion. I aint talkin' bout chicken n' gravy biatch. If all portions is empty, tha empty
strin is returned. Y'all KNOW dat shit, muthafucka! If \f(CW$volume\fR is empty, tha result is ghon be a relatizzle path,
beginnin wit a ':'. If \f(CW$volume\fR n' \f(CW$directory\fR is empty, a leadin \*(L":\*(R" (if any)
is removed form \f(CW$file\fR n' tha remainder is returned. Y'all KNOW dat shit, muthafucka! If \f(CW$file\fR is empty, the
resultin path gonna git a trailin ':'.
.IP "abs2rel" 2
.IX Item "abs2rel"
Takes a thugged-out destination path n' a optionizzle base path n' returns a relatizzle path
from tha base path ta tha destination path:
.Sp
.Vb 2
\&    $rel_path = File::Spec\->abs2rel( $path ) ;
\&    $rel_path = File::Spec\->abs2rel( $path, $base ) ;
.Ve
.Sp
Note dat both paths is assumed ta git a notation dat distinguishes a
directory path (with trailin ':') from a gangbangin' file path (without trailin ':').
.Sp
If \f(CW$base\fR aint present or '', then tha current hustlin directory is used.
If \f(CW$base\fR is relative, then it is converted ta absolute form rockin \f(CW\*(C`rel2abs()\*(C'\fR.
This means dat it is taken ta be relatizzle ta tha current hustlin directory.
.Sp
If \f(CW$path\fR n' \f(CW$base\fR step tha fuck up ta be on two different volumes, we will not
attempt ta resolve tha two paths, n' we will instead simply return
\&\f(CW$path\fR.  Note dat previous versionz of dis module ignored tha volume
of \f(CW$base\fR, which resulted up in garbage thangs up in dis biatch part of tha time.
.Sp
If \f(CW$base\fR aint gots a trailin colon, tha last element of \f(CW$base\fR is
assumed ta be a gangbangin' filename.  This filename is ignored. Y'all KNOW dat shit, muthafucka!  Otherwise all path
components is assumed ta be directories.
.Sp
If \f(CW$path\fR is relative, it is converted ta absolute form rockin \f(CW\*(C`rel2abs()\*(C'\fR.
This means dat it is taken ta be relatizzle ta tha current hustlin directory.
.Sp
Based on code freestyled by Shigio Yamaguchi.
.IP "rel2abs" 2
.IX Item "rel2abs"
Converts a relatizzle path ta a absolute path:
.Sp
.Vb 2
\&    $abs_path = File::Spec\->rel2abs( $path ) ;
\&    $abs_path = File::Spec\->rel2abs( $path, $base ) ;
.Ve
.Sp
Note dat both paths is assumed ta git a notation dat distinguishes a
directory path (with trailin ':') from a gangbangin' file path (without trailin ':').
.Sp
If \f(CW$base\fR aint present or '', then \f(CW$base\fR is set ta tha current working
directory. If \f(CW$base\fR is relative, then it is converted ta absolute form
usin \f(CW\*(C`rel2abs()\*(C'\fR. This means dat it is taken ta be relatizzle ta the
current hustlin directory.
.Sp
If \f(CW$base\fR aint gots a trailin colon, tha last element of \f(CW$base\fR is
assumed ta be a gangbangin' filename.  This filename is ignored. Y'all KNOW dat shit, muthafucka!  Otherwise all path
components is assumed ta be directories.
.Sp
If \f(CW$path\fR be already absolute, it is returned n' \f(CW$base\fR is ignored.
.Sp
Based on code freestyled by Shigio Yamaguchi.
.SH "AUTHORS"
.IX Header "AUTHORS"
See tha authors list up in \fIFile::Spec\fR. Mac \s-1OS\s0 support by Pizzle Schinder
<schinder@pobox.com> n' Thomas Wegner <wegner_thomas@yahoo.com>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 by tha Perl 5 Porters.  All muthafuckin rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See File::Spec n' File::Spec::Unix.  This package overrides the
implementation of these methods, not tha semantics.
