" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_debug::_Safe_iterator< _Iterator, _Sequence > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fB__gnu_debug::_Safe_iterator_base\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Traits::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef _Traits::iterator_category \fBiterator_category\fP"
.br
.ti -1c
.RI "typedef _Iterator \fBiterator_type\fP"
.br
.ti -1c
.RI "typedef _Traits::pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Traits::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef _Traits::value_type \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator\fP ()"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP (const _Iterator &__i, const _Sequence *__seq)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP (const \fB_Safe_iterator\fP &__x)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP (\fB_Safe_iterator\fP &&__x)"
.br
.ti -1c
.RI "template<typename _MutableIterator > \fB_Safe_iterator\fP (const \fB_Safe_iterator\fP< _MutableIterator, typename __gnu_cxx::__enable_if<(std::__are_same< _MutableIterator, typename _Sequence::iterator::iterator_type >::__value), _Sequence >::__type > &__x)"
.br
.ti -1c
.RI "void \fB_M_attach\fP (\fB_Safe_sequence_base\fP *__seq, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach\fP (\fB_Safe_sequence_base\fP *__seq)"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (\fB_Safe_sequence_base\fP *__seq, bool __constant)  throw ()"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (\fB_Safe_sequence_base\fP *__seq)"
.br
.ti -1c
.RI "bool \fB_M_attached_to\fP (const \fB_Safe_sequence_base\fP *__seq) const "
.br
.ti -1c
.RI "bool \fB_M_before_dereferenceable\fP () const "
.br
.ti -1c
.RI "bool \fB_M_can_advance\fP (const difference_type &__n) const "
.br
.ti -1c
.RI "bool \fB_M_can_compare\fP (const \fB_Safe_iterator_base\fP &__x) const   throw ()"
.br
.ti -1c
.RI "bool \fB_M_decrementable\fP () const "
.br
.ti -1c
.RI "bool \fB_M_dereferenceable\fP () const "
.br
.ti -1c
.RI "void \fB_M_detach\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_single\fP ()  throw ()"
.br
.ti -1c
.RI "const _Sequence * \fB_M_get_sequence\fP () const "
.br
.ti -1c
.RI "bool \fB_M_incrementable\fP () const "
.br
.ti -1c
.RI "void \fB_M_invalidate\fP ()"
.br
.ti -1c
.RI "bool \fB_M_is_before_begin\fP () const "
.br
.ti -1c
.RI "bool \fB_M_is_begin\fP () const "
.br
.ti -1c
.RI "bool \fB_M_is_beginnest\fP () const "
.br
.ti -1c
.RI "bool \fB_M_is_end\fP () const "
.br
.ti -1c
.RI "void \fB_M_reset\fP ()  throw ()"
.br
.ti -1c
.RI "bool \fB_M_singular\fP () const   throw ()"
.br
.ti -1c
.RI "void \fB_M_unlink\fP ()  throw ()"
.br
.ti -1c
.RI "template<typename _Other > bool \fB_M_valid_range\fP (const \fB_Safe_iterator\fP< _Other, _Sequence > &__rhs) const "
.br
.ti -1c
.RI "_Iterator \fBbase\fP () const "
.br
.ti -1c
.RI "\fBoperator _Iterator\fP () const "
.br
.ti -1c
.RI "reference \fBoperator*\fP () const "
.br
.ti -1c
.RI "\fB_Safe_iterator\fP \fBoperator+\fP (const difference_type &__n) const "
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator++\fP ()"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP \fBoperator++\fP (int)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator+=\fP (const difference_type &__n)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP \fBoperator-\fP (const difference_type &__n) const "
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator--\fP ()"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP \fBoperator--\fP (int)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator-=\fP (const difference_type &__n)"
.br
.ti -1c
.RI "pointa \fBoperator->\fP () const "
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator=\fP (const \fB_Safe_iterator\fP &__x)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator=\fP (\fB_Safe_iterator\fP &&__x)"
.br
.ti -1c
.RI "reference \fBoperator[]\fP (const difference_type &__n) const "
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_next\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_prior\fP"
.br
.ti -1c
.RI "\fB_Safe_sequence_base\fP * \fB_M_sequence\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()  throw ()"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Iterator, typename _Sequence>class __gnu_debug::_Safe_iterator< _Iterator, _Sequence >"
Safe iterator wrapper\&. 

Da class template _Safe_iterator be a wrapper round a iterator dat tracks tha iteratorz movement among sequences n' checks dat operations performed on tha 'safe' iterator is legal\&. In additionizzle ta tha basic iterator operations (which is validated, n' then passed ta tha underlyin iterator), _Safe_iterator has member functions fo' iterator invalidation, attaching/detachin tha iterator from sequences, n' queryin tha iteratorz state\&. 
.PP
Definizzle at line 46 of file formatter\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Iterator, typename _Sequence> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::\fB_Safe_iterator\fP ()\fC [inline]\fP"

.PP
\fBPostcondition:\fP
.RS 4
the iterator is singular n' unattached 
.RE
.PP

.PP
Definizzle at line 142 of file safe_iterator\&.h\&.
.SS "template<typename _Iterator, typename _Sequence> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::\fB_Safe_iterator\fP (const _Iterator &__i, const _Sequence *__seq)\fC [inline]\fP"

.PP
Safe iterator construction from a unsafe iterator n' its sequence\&. 
.PP
\fBPrecondition:\fP
.RS 4
\fCseq\fP aint NULL 
.RE
.PP
\fBPostcondition:\fP
.RS 4
this aint singular 
.RE
.PP

.PP
Definizzle at line 151 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator_base::_M_singular()\&.
.SS "template<typename _Iterator, typename _Sequence> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::\fB_Safe_iterator\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__x)\fC [inline]\fP"

.PP
Copy construction\&. 
.PP
Definizzle at line 162 of file safe_iterator\&.h\&.
.SS "template<typename _Iterator, typename _Sequence> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::\fB_Safe_iterator\fP (\fB_Safe_iterator\fP< _Iterator, _Sequence > &&__x)\fC [inline]\fP"

.PP
Move construction\&. 
.PP
\fBPostcondition:\fP
.RS 4
__x is singular n' unattached 
.RE
.PP

.PP
Definizzle at line 179 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_attach()\&.
.SS "template<typename _Iterator, typename _Sequence> template<typename _MutableIterator > \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::\fB_Safe_iterator\fP (const \fB_Safe_iterator\fP< _MutableIterator, typename __gnu_cxx::__enable_if<(std::__are_same< _MutableIterator, typename _Sequence::iterator::iterator_type >::__value), _Sequence >::__type > &__x)\fC [inline]\fP"

.PP
Convertin constructor from a mutable iterator ta a cold-ass lil constant iterator\&. 
.PP
Definizzle at line 197 of file safe_iterator\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_iterator_base::_M_attach (\fB_Safe_sequence_base\fP *__seq, bool__constant)\fC [inherited]\fP"
Attaches dis iterator ta tha given sequence, detachin it from whatever sequence dat shiznit was attached ta originally\&. If tha freshly smoked up sequence is tha NULL pointer, tha iterator is left unattached\&. 
.PP
Referenced by __gnu_debug::_Safe_local_iterator< _Iterator, _Sequence >::_M_attach(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_attach(), n' __gnu_debug::_Safe_iterator_base::_Safe_iterator_base()\&.
.SS "template<typename _Iterator, typename _Sequence> void \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_attach (\fB_Safe_sequence_base\fP *__seq)\fC [inline]\fP"
Attach iterator ta tha given sequence\&. 
.PP
Definizzle at line 406 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator_base::_M_attach()\&.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_Safe_iterator(), n' __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator=()\&.
.SS "void __gnu_debug::_Safe_iterator_base::_M_attach_single (\fB_Safe_sequence_base\fP *__seq, bool__constant)\fC [inherited]\fP"
Likewise yo, but not thread-safe\&. 
.PP
Referenced by __gnu_debug::_Safe_local_iterator< _Iterator, _Sequence >::_M_attach_single(), n' __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_attach_single()\&.
.SS "template<typename _Iterator, typename _Sequence> void \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_attach_single (\fB_Safe_sequence_base\fP *__seq)\fC [inline]\fP"
Likewise yo, but not thread-safe\&. 
.PP
Definizzle at line 413 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator_base::_M_attach_single()\&.
.SS "bool __gnu_debug::_Safe_iterator_base::_M_attached_to (const \fB_Safe_sequence_base\fP *__seq) const\fC [inline]\fP, \fC [inherited]\fP"
Determines if we is attached ta tha given sequence\&. 
.PP
Definizzle at line 129 of file safe_base\&.h\&.
.PP
References __gnu_debug::_Safe_iterator_base::_M_sequence\&.
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_before_dereferenceable () const\fC [inline]\fP"

.PP
Is tha iterator before a thugged-out dereferenceable one, biatch? 
.PP
Definizzle at line 425 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::__base(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_incrementable(), n' __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::base()\&.
.SS "bool __gnu_debug::_Safe_iterator_base::_M_can_compare (const \fB_Safe_iterator_base\fP &__x) const\fC [inherited]\fP"
Can we compare dis iterator ta tha given iterator \fC__x\fP, biatch? Returns legit if both iterators is nonsingular n' reference tha same sequence\&. 
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_dereferenceable () const\fC [inline]\fP"

.PP
Is tha iterator dereferenceable, biatch? 
.PP
Definizzle at line 420 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_before_begin(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_end(), n' __gnu_debug::_Safe_iterator_base::_M_singular()\&.
.PP
Referenced by __gnu_debug::__check_dereferenceable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator*(), n' __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator->()\&.
.SS "void __gnu_debug::_Safe_iterator_base::_M_detach ()\fC [inherited]\fP"
Detach tha iterator fo' whatever sequence it be attached to, if any\&. 
.SS "void __gnu_debug::_Safe_iterator_base::_M_detach_single ()\fC [inherited]\fP"
Likewise yo, but not thread-safe\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_iterator_base::_M_get_mutex ()\fC [protected]\fP, \fC [inherited]\fP"
For use up in _Safe_iterator\&. 
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_incrementable () const\fC [inline]\fP"

.PP
Is tha iterator incrementable, biatch? 
.PP
Definizzle at line 437 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_end(), n' __gnu_debug::_Safe_iterator_base::_M_singular()\&.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_before_dereferenceable(), n' __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator++()\&.
.SS "void __gnu_debug::_Safe_iterator_base::_M_invalidate ()\fC [inline]\fP, \fC [inherited]\fP"
Invalidate tha iterator, makin it singular\&. 
.PP
Definizzle at line 142 of file safe_base\&.h\&.
.PP
References __gnu_debug::_Safe_iterator_base::_M_version\&.
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_is_before_begin () const\fC [inline]\fP"

.PP
Is dis iterator equal ta tha sequencez before_begin() iterator if any, biatch? 
.PP
Definizzle at line 468 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::base()\&.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable()\&.
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_is_begin () const\fC [inline]\fP"

.PP
Is dis iterator equal ta tha sequencez begin() iterator, biatch? 
.PP
Definizzle at line 459 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::base()\&.
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_is_beginnest () const\fC [inline]\fP"

.PP
Is dis iterator equal ta tha sequencez before_begin() iterator if any or begin() otherwise, biatch? 
.PP
Definizzle at line 475 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::base()\&.
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_is_end () const\fC [inline]\fP"

.PP
Is dis iterator equal ta tha sequencez end() iterator, biatch? 
.PP
Definizzle at line 463 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::base()\&.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable(), n' __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_incrementable()\&.
.SS "void __gnu_debug::_Safe_iterator_base::_M_reset ()\fC [inherited]\fP"
Reset all member variablez 
.SS "bool __gnu_debug::_Safe_iterator_base::_M_singular () const\fC [inherited]\fP"
Is dis iterator singular, biatch? 
.PP
Referenced by __gnu_debug::__check_singular(), __gnu_debug::__check_singular_aux(), __gnu_debug::_Safe_local_iterator< _Iterator, _Sequence >::_M_dereferenceable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable(), __gnu_debug::_Safe_local_iterator< _Iterator, _Sequence >::_M_incrementable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_incrementable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_Safe_iterator(), n' __gnu_debug::_Safe_local_iterator< _Iterator, _Sequence >::_Safe_local_iterator()\&.
.SS "void __gnu_debug::_Safe_iterator_base::_M_unlink ()\fC [inline]\fP, \fC [inherited]\fP"
Unlink itself 
.PP
Definizzle at line 151 of file safe_base\&.h\&.
.PP
References __gnu_debug::_Safe_iterator_base::_M_next, n' __gnu_debug::_Safe_iterator_base::_M_prior\&.
.SS "template<typename _Iterator, typename _Sequence> _Iterator \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::base () const\fC [inline]\fP"

.PP
Return tha underlyin iterator\&. 
.PP
Definizzle at line 396 of file safe_iterator\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_before_dereferenceable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_before_begin(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_begin(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_beginnest(), n' __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_end()\&.
.SS "template<typename _Iterator, typename _Sequence> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator _Iterator () const\fC [inline]\fP"

.PP
Conversion ta underlyin non-debug iterator ta allow betta interaction wit non-debug containers\&. 
.PP
Definizzle at line 402 of file safe_iterator\&.h\&.
.SS "template<typename _Iterator, typename _Sequence> reference \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator* () const\fC [inline]\fP"

.PP
Iterator dereference\&. 
.PP
\fBPrecondition:\fP
.RS 4
iterator is dereferenceable 
.RE
.PP

.PP
Definizzle at line 260 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable()\&.
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP& \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator++ ()\fC [inline]\fP"

.PP
Iterator preincrement\&. 
.PP
\fBPrecondition:\fP
.RS 4
iterator is incrementable 
.RE
.PP

.PP
Definizzle at line 289 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_incrementable()\&.
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator++ (int)\fC [inline]\fP"

.PP
Iterator postincrement\&. 
.PP
\fBPrecondition:\fP
.RS 4
iterator is incrementable 
.RE
.PP

.PP
Definizzle at line 303 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_incrementable()\&.
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP& \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator-- ()\fC [inline]\fP"

.PP
Iterator predecrement\&. 
.PP
\fBPrecondition:\fP
.RS 4
iterator is decrementable 
.RE
.PP

.PP
Definizzle at line 319 of file safe_iterator\&.h\&.
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator-- (int)\fC [inline]\fP"

.PP
Iterator postdecrement\&. 
.PP
\fBPrecondition:\fP
.RS 4
iterator is decrementable 
.RE
.PP

.PP
Definizzle at line 333 of file safe_iterator\&.h\&.
.SS "template<typename _Iterator, typename _Sequence> pointa \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator-> () const\fC [inline]\fP"

.PP
Iterator dereference\&. 
.PP
\fBPrecondition:\fP
.RS 4
iterator is dereferenceable 
.RE
.PP
\fBTodo\fP
.RS 4
Make dis erect w\&.r\&.t\&. iterators dat return proxies 
.PP
Use addressof() instead of & operator 
.RE
.PP

.PP
Definizzle at line 275 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable()\&.
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP& \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator= (const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__x)\fC [inline]\fP"

.PP
Copy assignment\&. 
.PP
Definizzle at line 217 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_attach()\&.
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP& \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator= (\fB_Safe_iterator\fP< _Iterator, _Sequence > &&__x)\fC [inline]\fP"

.PP
Move assignment\&. 
.PP
\fBPostcondition:\fP
.RS 4
__x is singular n' unattached 
.RE
.PP

.PP
Definizzle at line 237 of file safe_iterator\&.h\&.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_attach()\&.
.SH "Member Data Documentation"
.PP 
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_iterator_base::_M_next\fC [inherited]\fP"
Pointa ta tha next iterator up in tha sequencez list of iterators\&. Only valid when _M_sequence != NULL\&. 
.PP
Definizzle at line 72 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if(), n' __gnu_debug::_Safe_iterator_base::_M_unlink()\&.
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_iterator_base::_M_prior\fC [inherited]\fP"
Pointa ta tha previous iterator up in tha sequencez list of iterators\&. Only valid when _M_sequence != NULL\&. 
.PP
Definizzle at line 68 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if(), n' __gnu_debug::_Safe_iterator_base::_M_unlink()\&.
.SS "\fB_Safe_sequence_base\fP* __gnu_debug::_Safe_iterator_base::_M_sequence\fC [inherited]\fP"
Da sequence dis iterator references; may be NULL ta indicate a singular iterator\&. 
.PP
Definizzle at line 55 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_iterator_base::_M_attached_to(), __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if(), __gnu_debug::_Safe_iterator_base::_Safe_iterator_base(), n' __gnu_debug::_Safe_local_iterator_base::_Safe_local_iterator_base()\&.
.SS "unsigned int __gnu_debug::_Safe_iterator_base::_M_version\fC [inherited]\fP"
Da version number of dis iterator\&. Da sentinel value 0 is used ta indicate a invalidated iterator (i\&.e\&., one dat is singular cuz of a operation on tha container)\&. This version number must equal tha version number up in tha sequence referenced by _M_sequence fo' tha iterator ta be non-singular\&. 
.PP
Definizzle at line 64 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_iterator_base::_M_invalidate()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
