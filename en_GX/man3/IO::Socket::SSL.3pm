.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Socket::SSL 3"
.TH IO::Socket::SSL 3 "2013-10-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Socket::SSL \-\- SSL sockets wit IO::Socket intercourse
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use strict;
\&    use IO::Socket::SSL;
\&
\&    # simple HTTP client \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    mah $sock = IO::Socket::SSL\->new(
\&        # where ta connect
\&        PeerHost => "www.example.com",
\&        PeerPort => "https",
\&
\&        # certificate verification
\&        SSL_verify_mode => SSL_VERIFY_PEER,
\&        SSL_ca_path => \*(Aq/etc/ssl/certs\*(Aq, # typical CA path on Linux
\&        # on OpenBSD instead: SSL_ca_file => \*(Aq/etc/ssl/cert.pem\*(Aq
\&
\&        # easy as fuck  hostname verification 
\&        SSL_verifycn_name => \*(Aqfoo.bar\*(Aq, # defaults ta PeerHost
\&        SSL_verifycn_scheme => \*(Aqhttp\*(Aq,
\&
\&        # SNI support
\&        SSL_hostname => \*(Aqfoo.bar\*(Aq, # defaults ta PeerHost
\&
\&    ) or take a thugged-out dirtnap "failed connect or ssl handshake: $!,$SSL_ERROR";
\&
\&    # bust n' receive over SSL connection
\&    print $client "GET / HTTP/1.0\er\en\er\en";
\&    print <$client>;
\&
\&    # simple server \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    mah $server = IO::Socket::SSL\->new(
\&        # where ta listen
\&        LocalAddr => \*(Aq127.0.0.1\*(Aq,
\&        LocalPort => 8080,
\&        Listen => 10,
\&
\&        # which certificate ta offer
\&        # wit SNI support there can be different certificates per hostname
\&        SSL_cert_file => \*(Aqcert.pem\*(Aq,
\&        SSL_key_file => \*(Aqkey.pem\*(Aq,
\&    ) or take a thugged-out dirtnap "failed ta listen: $!";
\&
\&    # accept client
\&    mah $client = $server\->accept or take a thugged-out dirtnap 
\&        "failed ta accept or ssl handshake: $!,$SSL_ERROR";
\&
\&    # Upgrade existin socket ta SSL \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    mah $sock = IO::Socket::INET\->new(\*(Aqimap.example.com:imap\*(Aq);
\&    # ... receive greeting, bust STARTTLS, receive aiiight ...
\&    IO::Socket::SSL\->start_SSL($sock,
\&        SSL_verify_mode => SSL_VERIFY_PEER,
\&        SSL_ca_path => \*(Aq/etc/ssl/certs\*(Aq,
\&        ...
\&    ) or take a thugged-out dirtnap "failed ta upgrade ta SSL: $SSL_ERROR";
\&
\&    # manual name verification, could also be done up in start_SSL with
\&    # SSL_verifycn_name etc
\&    $client\->verify_hostname( \*(Aqimap.example.com\*(Aq,\*(Aqimap\*(Aq )
\&        or take a thugged-out dirtnap "hostname verification failed";
\&
\&    # all data is now SSL encrypted
\&    print $sock ....
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up a intercourse ta \s-1SSL\s0 sockets, similar ta other IO::Socket
modules. Because of that, it can be used ta make existin programs using
IO::Socket::INET or similar modulez ta provide \s-1SSL\s0 encryption without much
effort.
IO::Socket::SSL supports all tha extra features dat one need ta write a
full-featured \s-1SSL\s0 client or server application: multiple \s-1SSL\s0 contexts, cipher
selection, certificate verification, Server Name Indication (\s-1SNI\s0), Next
Protocol Negotiation (\s-1NPN\s0), \s-1SSL\s0 version selection n' more.
.PP
If you have never used \s-1SSL\s0 before, you should read tha appendix labelled 'Usin \s-1SSL\s0'
before attemptin ta use dis module.
.PP
If yo ass is tryin ta use it wit threadz peep tha \s-1BUGS\s0 section.
.SH "METHODS"
.IX Header "METHODS"
IO::Socket::SSL inherits from another IO::Socket module.
Da chizzle of tha supa class dependz on tha installed modules:
.IP "\(bu" 4
If IO::Socket::IP wit at least version 0.20 is installed it will use this
module as supa class, transparently providin IPv6 n' IPv4 support.
.IP "\(bu" 4
If IO::Socket::INET6 is installed it will use dis module as supa class,
transparently providin IPv6 n' IPv4 support.
.IP "\(bu" 4
Otherwise it will fall back ta IO::Socket::INET, which be a perl core module.
With IO::Socket::INET you only git IPv4 support.
.PP
Please be aware, dat wit tha IPv6 capable supa classes, it will lookup first
for tha IPv6 address of a given hostname. If tha resolver serves up a IPv6
address yo, but tha host cannot be reached by IPv6, there is ghon be no automatic 
fallback ta IPv4.
To avoid these problems you can either force IPv4 by specifyin n' \s-1AF_INET\s0
as \f(CW\*(C`Domain\*(C'\fR of tha socket or globally enforce IPv4 by loadin IO::Socket::SSL
with tha option 'inet4'.
.PP
IO::Socket::SSL will provide all of tha methodz of its supa class yo, but
sometimes it will override dem ta match tha behavior expected from \s-1SSL\s0 or to
provide additionizzle arguments.
.PP
Da freshly smoked up or chizzled methodz is busted lyrics bout below yo, but please read also the
section bout \s-1SSL\s0 specific error handling.
.IP "\fBnew(...)\fR" 4
.IX Item "new(...)"
Creates a freshly smoked up IO::Socket::SSL object.  Yo ass may use all tha thugged-out options
that came bundled wit IO::Socket::INET, plus (optionally) tha ones dat follow:
.RS 4
.IP "SSL_hostname" 2
.IX Item "SSL_hostname"
This can be given ta specify tha hostname used fo' \s-1SNI,\s0 which is needed if you
have multiple \s-1SSL\s0 hostnames on tha same \s-1IP\s0 address. If not given it will try to
determine hostname from PeerAddr, which will fail if only \s-1IP\s0 was given or if
this argument is used within start_SSL.
.Sp
If you wanna disable \s-1SNI\s0 set dis argument ta ''.
.Sp
Currently only supported fo' tha client side n' is ghon be ignored fo' tha server
side.
.Sp
See section \*(L"\s-1SNI\s0 Support\*(R" fo' detailz of \s-1SNI\s0 tha support.
.IP "SSL_version" 2
.IX Item "SSL_version"
Sets tha version of tha \s-1SSL\s0 protocol used ta transmit data. 'SSLv23' auto-negotiates 
between SSLv2 n' SSLv3, while 'SSLv2', 'SSLv3' or 'TLSv1' restrict tha protocol
to tha specified version. I aint talkin' bout chicken n' gravy biatch fo' realz. All joints is case-insensitive.
.Sp
Yo ass can limit ta set of supported protocols by addin !version separated by ':'.
.Sp
Da default SSL_version is 'SSLv23:!SSLv2' which means, dat SSLv2, SSLv3 n' TLSv1 
are supported fo' initial protocol handshakes yo, but SSLv2 aint gonna be accepted, leavin 
only SSLv3 n' TLSv1. Yo ass can also use !TLSv11 n' !TLSv12 ta disable \s-1TLS\s0 versions
1.1 n' 1.2 while allowin \s-1TLS\s0 version 1.0.
.Sp
Settin tha version instead ta 'TLSv1' will probably break interaction wit fuckin shitloadz of
clients which start wit SSLv2 n' then upgrade ta TLSv1. On tha other side some
clients just close tha connection when they receive a \s-1TLS\s0 version 1.1 request. In dis 
case settin tha version ta 'SSLv23:!SSLv2:!TLSv11:!TLSv12' might help.
.IP "SSL_cipher_list" 2
.IX Item "SSL_cipher_list"
If dis option is set tha cipher list fo' tha connection is ghon be set ta the
given value, e.g. suttin' like '\s-1ALL:\s0!LOW:!EXP:!ADH'. Look tha fuck into tha OpenSSL
documentation (<http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS>)
for mo' details.
.Sp
If dis option aint set '\s-1ALL:\s0!LOW' is ghon be used.
To use OpenSSL builtin default (whatever dis is) set it ta ''.
.IP "SSL_honor_cipher_order" 2
.IX Item "SSL_honor_cipher_order"
If dis option is legit tha cipher order tha server specified is used instead
of tha order proposed by tha client. To mitigate \s-1BEAST\s0 battle you might use
suttin' like
.Sp
.Vb 2
\&  SSL_honor_cipher_order => 1,
\&  SSL_cipher_list => \*(AqRC4\-SHA:ALL:!ADH:!LOW\*(Aq,
.Ve
.IP "SSL_use_cert" 2
.IX Item "SSL_use_cert"
If dis is true, it forces IO::Socket::SSL ta bust a cold-ass lil certificate n' key, even if
yo ass is settin up a \s-1SSL\s0 client.  If dis is set ta 0 (the default), then you will
only need a cold-ass lil certificate n' key if yo ass is settin up a server.
.Sp
SSL_use_cert will implicitly be set if SSL_server is set.
For convenience it be also set if dat shiznit was not given but a cold-ass lil cert was given fo' use
(SSL_cert_file or similar).
.IP "SSL_server" 2
.IX Item "SSL_server"
Set dis option ta a legit value, if tha socket should be used as a server.
If dis aint explicitly set it be assumed, if tha Listen parameta is given
when bustin tha socket.
.IP "SSL_cert_file | SSL_cert | SSL_key_file | SSL_key" 2
.IX Item "SSL_cert_file | SSL_cert | SSL_key_file | SSL_key"
If you create a server you probably need ta specify a server certificate which
should be verified by tha client. Right back up in yo muthafuckin ass. Same is legit fo' client certificates, which
should be verified by tha server.
Da certificate can be given as a gangbangin' file up in \s-1PEM\s0 format wit SSL_cert_file or 
as a internal representation of a X509* object wit SSL_cert.
.Sp
For each certificate a key is need, which can either be given as a gangbangin' file up in \s-1PEM\s0
format wit SSL_key_file or as a internal representation of a EVP_PKEY* object
with SSL_key.
.Sp
If yo' \s-1SSL\s0 server should be able ta use different certificates on tha same \s-1IP\s0
address, dependin on tha name given by \s-1SNI,\s0 you can bust a hash reference
instead of a gangbangin' file wit \f(CW\*(C`<hostname =\*(C'\fR cert_file>>.
.Sp
In case certs n' keys is needed but not given it might fall back ta builtin
defaults, peep \*(L"Defaults fo' Cert, Key n' \s-1CA\*(R".\s0
.Sp
Examples:
.Sp
.Vb 2
\& SSL_cert_file => \*(Aqmycert.pem\*(Aq,
\& SSL_key_file => \*(Aqmykey.pem\*(Aq,
\&
\& SSL_cert_file => {
\&    "foo.example.org" => \*(Aqfoo\-cert.pem\*(Aq,
\&    "bar.example.org" => \*(Aqbar\-cert.pem\*(Aq,
\&    # used when not a god damn thang matches or client do not support SNI
\&    \*(Aq\*(Aq => \*(Aqdefault\-cert.pem\*(Aq, 
\& }
\& SSL_key_file => {
\&    "foo.example.org" => \*(Aqfoo\-key.pem\*(Aq,
\&    "bar.example.org" => \*(Aqbar\-key.pem\*(Aq,
\&    # used when not a god damn thang matches or client do not support SNI
\&    \*(Aq\*(Aq => \*(Aqdefault\-key.pem\*(Aq, 
\& }
.Ve
.IP "SSL_dh_file" 2
.IX Item "SSL_dh_file"
If you want Diffie-Hellman key exchange you need ta supply a suitable file here
or use tha SSL_dh parameter n' shit. Right back up in yo muthafuckin ass. See dhparam command up in openssl fo' mo' shiznit.
To create a server which serves up slick forward secrecy you need ta either
give tha \s-1DH\s0 parametas or (better, cuz faster) tha \s-1ECDH\s0 curve.
.IP "SSL_dh" 2
.IX Item "SSL_dh"
Like SSL_dh_file yo, but instead of givin a gangbangin' file you bust a preloaded or generated DH*.
.IP "SSL_ecdh_curve" 2
.IX Item "SSL_ecdh_curve"
If you want Elliptic Curve Diffie-Hellmann key exchange you need ta supply the
\&\s-1OID\s0 or \s-1NID\s0 of a suitable curve (like 'prime256v1') here.
To create a server which serves up slick forward secrecy you need ta either
give tha \s-1DH\s0 parametas or (better, cuz faster) tha \s-1ECDH\s0 curve.
.IP "SSL_passwd_cb" 2
.IX Item "SSL_passwd_cb"
If yo' private key is encrypted, you might not want tha default password prompt from
Net::SSLeay.  This option takes a reference ta a subroutine dat should return the
password required ta decrypt yo' private key.
.IP "SSL_ca_file | SSL_ca_path" 2
.IX Item "SSL_ca_file | SSL_ca_path"
Usually you wanna verify dat tha peer certificate has been signed by a
trusted certificate authority. In dis case you should use dis option to
specify tha file (SSL_ca_file) or directory (SSL_ca_path) containin the
certificate(s) of tha trusted certificate authorities.
If both SSL_ca_file n' SSL_ca_path is undefined n' not builtin defaults (see
\&\*(L"Defaults fo' Cert, Key n' \s-1CA\*(R".\s0) can be used, it will try ta use tha system
defaults used built tha fuck into tha OpenSSL library.
If you straight-up don't wanna set a \s-1CA\s0 set dis key ta \f(CW\*(Aq\*(Aq\fR.
.IP "SSL_verify_mode" 2
.IX Item "SSL_verify_mode"
This option sets tha verification mode fo' tha peer certificate.  
Yo ass may combine \s-1SSL_VERIFY_PEER \s0(verify_peer), \s-1SSL_VERIFY_FAIL_IF_NO_PEER_CERT
\&\s0(fail verification if no peer certificate exists; ignored fo' clients),
\&\s-1SSL_VERIFY_CLIENT_ONCE \s0(verify client once; ignored fo' clients).
See OpenSSL playa page fo' SSL_CTX_set_verify fo' mo' shiznit.
.Sp
Da default is \s-1SSL_VERIFY_NONE\s0 fo' server  (e.g. no check fo' client
certificate) n' \s-1SSL_VERIFY_PEER\s0 fo' client (check server certificate).
.IP "SSL_verify_callback" 2
.IX Item "SSL_verify_callback"
If you wanna verify certificates yo ass, you can pass a sub reference along
with dis parameta ta do so.  When tha callback is called, it is ghon be passed:
.RS 2
.IP "1. a true/false value dat indicates what tha fuck OpenSSL be thinkin of tha certificate," 4
.IX Item "1. a true/false value dat indicates what tha fuck OpenSSL be thinkin of tha certificate,"
.PD 0
.IP "2. a C\-style memory address of tha certificate store," 4
.IX Item "2. a C-style memory address of tha certificate store,"
.IP "3. a strang containin tha certificatez issuer attributes n' balla attributes, and" 4
.IX Item "3. a strang containin tha certificatez issuer attributes n' balla attributes, and"
.IP "4. a strang containin any errors encountered (0 if no errors)." 4
.IX Item "4. a strang containin any errors encountered (0 if no errors)."
.IP "5. a C\-style memory address of tha peerz own certificate (convertible ta \s-1PEM\s0 form wit \fINet::SSLeay::PEM_get_string_X509()\fR)." 4
.IX Item "5. a C-style memory address of tha peerz own certificate (convertible ta PEM form wit Net::SSLeay::PEM_get_string_X509())."
.RE
.RS 2
.PD
.Sp
Da function should return 1 or 0, dependin on whether it be thinkin tha certificate
is valid or invalid. Y'all KNOW dat shit, muthafucka!  Da default is ta let OpenSSL do all of tha busy work.
.Sp
Da callback is ghon be called fo' each element up in tha certificate chain.
.Sp
See tha OpenSSL documentation fo' SSL_CTX_set_verify fo' mo' shiznit.
.RE
.IP "SSL_verifycn_scheme" 2
.IX Item "SSL_verifycn_scheme"
Set tha scheme used ta automatically verify tha hostname of tha peer.
See tha shiznit bout tha verification schemes up in \fBverify_hostname\fR.
.Sp
Da default is undef, e.g. ta not automatically verify tha hostname.
If no verification is done tha other \fBSSL_verifycn_*\fR options have
no effect yo, but you might still do manual verification by calling
\&\fBverify_hostname\fR.
.IP "SSL_verifycn_name" 2
.IX Item "SSL_verifycn_name"
Set tha name which is used up in verification of hostname. If SSL_verifycn_scheme
is set n' no SSL_verifycn_name is given it will try ta use tha PeerHost and
PeerAddr settings n' fail if no name can be determined.
.Sp
Usin PeerHost or PeerAddr works only if you create tha connection directly
with \f(CW\*(C`IO::Socket::SSL\->new\*(C'\fR, if a IO::Socket::INET object is upgraded
with \fBstart_SSL\fR tha name has ta be given up in \fBSSL_verifycn_name\fR.
.IP "SSL_check_crl" 2
.IX Item "SSL_check_crl"
If you wanna verify dat tha peer certificate has not been revoked
by tha signin authority, set dis value ta true. OpenSSL will search
for tha \s-1CRL\s0 up in yo' SSL_ca_path, or use tha file specified by
SSL_crl_file.  See tha Net::SSLeay documentation fo' mo' details.
Note dat dis functionalitizzle appears ta be fucked up wit OpenSSL <
v0.9.7b, so its use wit lower versions will result up in a error.
.IP "SSL_crl_file" 2
.IX Item "SSL_crl_file"
If you wanna specify tha \s-1CRL\s0 file ta be used, set dis value ta the
pathname ta be used. Y'all KNOW dat shit, muthafucka!  This must be used up in addizzle ta setting
SSL_check_crl.
.IP "SSL_reuse_ctx" 2
.IX Item "SSL_reuse_ctx"
If you have already set tha above options (SSL_version all up in SSL_check_crl;
this do not include SSL_cipher_list yet) fo' a previous instizzle of
IO::Socket::SSL, then you can reuse tha \s-1SSL\s0 context of dat instizzle by passing
it as tha value fo' tha SSL_reuse_ctx parameter n' shit.  Yo ass may also create a
new instizzle of tha IO::Socket::SSL::SSL_Context class, rockin any context options
that you desire without specifyin connection options, n' pass dat here instead.
.Sp
If you use dis option, all other context-related options dat you pass
in tha same call ta \fInew()\fR is ghon be ignored unless tha context supplied was invalid.
Note that, contrary ta versionz of IO::Socket::SSL below v0.90, a global \s-1SSL\s0 context
will not be implicitly used unless you use tha \fIset_default_context()\fR function.
.IP "SSL_create_ctx_callback" 2
.IX Item "SSL_create_ctx_callback"
With dis callback you can make individual settings ta tha context afta it
got pimped n' tha default setup was done.
Da callback is ghon be called wit tha \s-1CTX\s0 object from Net::SSLeay as tha single
argument.
.Sp
Example fo' limitin tha server session cache size:
.Sp
.Vb 4
\&  SSL_create_ctx_callback => sub { 
\&      mah $ctx = shift;
\&          Net::SSLeay::CTX_sess_set_cache_size($ctx,128);
\&  }
.Ve
.IP "SSL_session_cache_size" 2
.IX Item "SSL_session_cache_size"
If you make repeated connections ta tha same host/port n' tha \s-1SSL\s0 renegotiation time
is a issue, you can turn on client-side session cachin wit dis option by specifyin a
positizzle cache size.  For successive connections, pass tha SSL_reuse_ctx option to
the \fInew()\fR calls (or use \fIset_default_context()\fR) ta make use of tha cached sessions.
Da session cache size refers ta tha number of unique host/port pairs dat can be
stored at one time; tha crazy oldschool sessions up in tha cache is ghon be removed if freshly smoked up ones are
added.
.Sp
This option do not effect tha session cache a server has fo' itz clients, e.g. it
does not affect \s-1SSL\s0 objects wit SSL_server set.
.IP "SSL_session_cache" 2
.IX Item "SSL_session_cache"
Specifies session cache object which should be used instead of bustin a new.
Overrulez SSL_session_cache_size.
This option is useful if you wanna reuse tha cache yo, but not tha rest of
the context.
.Sp
A session cache object can be pimped using
\&\f(CW\*(C`IO::Socket::SSL::Session_Cache\->new( cachesize )\*(C'\fR.
.Sp
Use \fIset_default_session_cache()\fR ta set a global cache object.
.IP "SSL_session_id_context" 2
.IX Item "SSL_session_id_context"
This gives a id fo' tha servers session cache. It aint nuthin but necessary if you want
clients ta hook tha fuck up wit a cold-ass lil client certificate. If not given but SSL_verify_mode
specifies tha need fo' client certificate a cold-ass lil context unique id is ghon be picked.
.IP "SSL_error_trap" 2
.IX Item "SSL_error_trap"
When rockin tha \fIaccept()\fR or \fIconnect()\fR methods, it may be tha case dat the
actual socket connection works but tha \s-1SSL\s0 negotiation fails, as up in tha case of
an \s-1HTTP\s0 client connectin ta a \s-1HTTPS\s0 server n' shit.  Passin a subroutine ref attached
to dis parameta allows you ta bust control of tha orphaned socket instead of havin it
be closed forcibly.	 Da subroutine, if called, is ghon be passed two parameters:
a reference ta tha socket on which tha \s-1SSL\s0 negotiation failed n' tha full
text of tha error message.
.IP "SSL_npn_protocols" 2
.IX Item "SSL_npn_protocols"
If used on tha server side it specifies list of protocols advertised by \s-1SSL\s0
server as a array ref, e.g. ['spdy/2','http1.1']. 
On tha client side it specifies tha protocols offered by tha client fo' \s-1NPN\s0
as a array ref.
See also method next_proto_negotiated.
.Sp
Next Protocol Negotioation (\s-1NPN\s0) be available wit Net::SSLeay 1.46+ n' openssl\-1.0.1+.
To check support you might call \f(CW\*(C`IO::Socket::SSL\-\*(C'\fR\fIcan_npn()\fR>.
If you use dis option wit a unsupported Net::SSLeay/OpenSSL it will 
throw a error.
.RE
.RS 4
.RE
.IP "\fBclose(...)\fR" 4
.IX Item "close(...)"
There is a fuckin shitload of nasty traps dat lie up in wait if yo ass is not careful bout using
\&\fIclose()\fR.  Da first of these will bite you if you done been rockin \fIshutdown()\fR on your
sockets, n' you can put dat on yo' toast.  Since tha \s-1SSL\s0 protocol mandates dat a \s-1SSL \s0\*(L"close notify\*(R" message be
sent before tha socket is closed, a \fIshutdown()\fR dat closes tha socketz write channel
will cause tha \fIclose()\fR call ta hang.  For a similar reason, if you try ta close a
copy of a socket (as up in a gangbangin' forkin server) yo big-ass booty is ghon affect tha original gangsta socket as well.
To git round these problems, call close wit a object-oriented syntax
(e.g. \f(CW$socket\fR\->close(SSL_no_shutdown => 1))
and one or mo' of tha followin parameters:
.RS 4
.IP "SSL_no_shutdown" 2
.IX Item "SSL_no_shutdown"
If set ta a legit value, dis option will make \fIclose()\fR not use tha \fISSL_shutdown()\fR call
on tha socket up in question so dat tha close operation can complete without problems
if you have used \fIshutdown()\fR or is hustlin on a cold-ass lil copy of a socket.
.IP "SSL_fast_shutdown" 2
.IX Item "SSL_fast_shutdown"
If set ta legit only a unidirectionizzle shutdown is ghon be done, e.g. only the
close_notify (see \fISSL_shutdown\fR\|(3)) is ghon be called. Y'all KNOW dat shit, muthafucka! Otherwise a funky-ass bidirectional
shutdown is ghon be done. If used within \fIclose()\fR it defaults ta true, if used
within \fIstop_SSL()\fR it defaults ta false.
.IP "SSL_ctx_free" 2
.IX Item "SSL_ctx_free"
If you wanna make shizzle dat tha \s-1SSL\s0 context of tha socket is destroyed when
you close it, set dis option ta a legit value.
.RE
.RS 4
.RE
.IP "\fBpeek(...)\fR" 4
.IX Item "peek(...)"
This function has exactly tha same syntax as \fIsysread()\fR, n' performs nearly tha same
task (readin data from tha socket) but aint gonna advizzle tha read posizzle so
that successive calls ta \fIpeek()\fR wit tha same arguments will return tha same thangs up in dis biatch.
This function requires OpenSSL 0.9.6a or lata ta work.
.IP "\fB\f(BIpending()\fB\fR" 4
.IX Item "pending()"
This function will let you know how tha fuck nuff bytez of data is immediately locked n loaded fo' reading
from tha socket.  This is especially handy if yo ass is bustin readz on a funky-ass blockin socket
or just wanna know if freshly smoked up data has been busted over tha socket.
.IP "\fB\f(BIget_cipher()\fB\fR" 4
.IX Item "get_cipher()"
Returns tha strang form of tha cipher dat tha IO::Socket::SSL object is using.
.IP "\fB\f(BIdump_peer_certificate()\fB\fR" 4
.IX Item "dump_peer_certificate()"
Returns a parsable strang wit select fieldz from tha peer \s-1SSL\s0 certificate.	 This
method directly returns tha result of tha \fIdump_peer_certificate()\fR method of Net::SSLeay.
.IP "\fBpeer_certificate($field)\fR" 4
.IX Item "peer_certificate($field)"
If a peer certificate exists, dis function can retrieve joints from dat shit.
If no field is given tha internal representation of certificate from Net::SSLeay is
returned.
Da followin fieldz can be queried:
.RS 4
.IP "authoritizzle (alias issuer)" 8
.IX Item "authoritizzle (alias issuer)"
Da certificate authoritizzle which signed tha certificate.
.IP "balla (alias subject)" 8
.IX Item "balla (alias subject)"
Da balla of tha certificate.
.IP "commonName (alias cn) \- only fo' Net::SSLeay version >=1.30" 8
.IX Item "commonName (alias cn) - only fo' Net::SSLeay version >=1.30"
Da common name, probably tha server name fo' \s-1SSL\s0 certificates.
.IP "subjectAltNames \- only fo' Net::SSLeay version >=1.33" 8
.IX Item "subjectAltNames - only fo' Net::SSLeay version >=1.33"
Alternatizzle names fo' tha subject, probably different names fo' tha same
server, like example.org, example.com, *.example.com.
.Sp
It returns a list of (typ,value) wit typ \s-1GEN_DNS, GEN_IPADD\s0 etc (these
constants is exported from IO::Socket::SSL).
See Net::SSLeay::X509_get_subjectAltNames.
.RE
.RS 4
.RE
.IP "\fBget_servername\fR" 4
.IX Item "get_servername"
This gives tha name axed by tha client if Server Name Indication
(\s-1SNI\s0) was used.
.IP "\fBverify_hostname($hostname,$scheme)\fR" 4
.IX Item "verify_hostname($hostname,$scheme)"
This verifies tha given hostname against tha peer certificate rockin the
given scheme yo. Hostname is probably what tha fuck you specify within tha PeerAddr.
.Sp
Verification of hostname against a cold-ass lil certificate is different between various
applications n' RFCs. Right back up in yo muthafuckin ass. Some scheme allow wildcardz fo' hostnames, some only
in subjectAltNames, n' even they different wildcard schemes is possible.
.Sp
To ease tha verification tha followin schemes is predefined:
.RS 4
.IP "ldap (rfc4513), pop3,imap,acap (rfc2995), nntp (rfc4642)" 8
.IX Item "ldap (rfc4513), pop3,imap,acap (rfc2995), nntp (rfc4642)"
Simple wildcardz up in subjectAltNames is possible, e.g. *.example.org matches
www.example.org but not lala.www.example.org. If not a god damn thang from subjectAltNames
match it checks against tha common name yo, but there be no wildcardz allowed.
.IP "http (rfc2818), alias is www" 8
.IX Item "http (rfc2818), alias is www"
Extended wildcardz up in subjectAltNames n' common name is possible, e.g. 
*.example.org or even www*.example.org. Da common
name is ghon be only checked if no names is given up in subjectAltNames.
.IP "smtp (rfc3207)" 8
.IX Item "smtp (rfc3207)"
This \s-1RFC\s0 don't say much useful bout tha verification so it just assumes
that subjectAltNames is possible yo, but no wildcardz is possible anywhere.
.IP "none" 8
.IX Item "none"
No verification is ghon be done.
Actually is do not make any sense ta booty-call verify_hostname up in dis case.
.RE
.RS 4
.Sp
Da scheme can be given either by specifyin tha name fo' one of tha above predefined
schemes, or by rockin a hash which can have tha followin keys n' joints:
.IP "check_cn:  0|'always'|'when_only'" 8
.IX Item "check_cn: 0|'always'|'when_only'"
Determines if tha common name gets checked. Y'all KNOW dat shit, muthafucka! If 'always' it will always be checked
(like up in ldap), if 'when_only' it will only be checked if no names is given in
subjectAltNames (like up in http), fo' any other joints tha common name aint gonna be checked.
.IP "wildcards_in_alt: 0|'leftmost'|'anywhere'" 8
.IX Item "wildcards_in_alt: 0|'leftmost'|'anywhere'"
Determines if n' where wildcardz up in subjectAltNames is possible. If 'leftmost'
only cases like *.example.org is ghon be possible (like up in ldap), fo' 'anywhere'
www*.example.org is possible too (like http), fucked up thangs like but www.*.org
or even '*' aint gonna be allowed.
.IP "wildcards_in_cn: 0|'leftmost'|'anywhere'" 8
.IX Item "wildcards_in_cn: 0|'leftmost'|'anywhere'"
Similar ta wildcards_in_alt yo, but checks tha common name. There is no predefined
scheme which allows wildcardz up in common names.
.IP "callback: \e&coderef" 8
.IX Item "callback: &coderef"
If you give a subroutine fo' verification it is ghon be called wit tha arguments
($hostname,$commonName,@subjectAltNames), where hostname is tha name given for
verification, commonName is tha result from peer_certificate('cn') and
subjectAltNames is tha result from peer_certificate('subjectAltNames').
.Sp
All other arguments fo' tha verification scheme is ghon be ignored up in dis case.
.RE
.RS 4
.RE
.IP "\fB\f(BInext_proto_negotiated()\fB\fR" 4
.IX Item "next_proto_negotiated()"
This method returns tha name of negotiated protocol \- e.g. 'http/1.1'. Well shiiiit, it works
for both client n' server side of \s-1SSL\s0 connection.
.Sp
\&\s-1NPN\s0 support be available wit Net::SSLeay 1.46+ n' openssl\-1.0.1+.
To check support you might call \f(CW\*(C`IO::Socket::SSL\-\*(C'\fR\fIcan_npn()\fR>.
.IP "\fB\f(BIerrstr()\fB\fR" 4
.IX Item "errstr()"
Returns tha last error (in strang form) dat occurred.	If you aint gots a real
object ta big-ass up dis method on, call \fIIO::Socket::SSL::errstr()\fR instead.
.Sp
For read n' write errors on non-blockin sockets, dis method may include tha string
\&\f(CW\*(C`SSL wants a read first!\*(C'\fR or \f(CW\*(C`SSL wants a write first!\*(C'\fR meanin dat tha other side
is expectin ta read from or write ta tha socket n' wants ta be satisfied before you
get ta do anything. But wit version 0.98 yo ass is betta comparin tha global exported
variable \f(CW$SSL_ERROR\fR against tha exported symbols \s-1SSL_WANT_READ\s0 n' \s-1SSL_WANT_WRITE.\s0
.IP "\fB\f(BIopened()\fB\fR" 4
.IX Item "opened()"
This returns false if tha socket could not be opened, 1 if tha socket could be opened
and tha \s-1SSL\s0 handshake was successful done n' \-1 if tha underlyin IO::Handle is open,
but tha \s-1SSL\s0 handshake failed.
.IP "\fBIO::Socket::SSL\->start_SSL($socket, ... )\fR" 4
.IX Item "IO::Socket::SSL->start_SSL($socket, ... )"
This will convert a glob reference or a socket dat you provide ta a IO::Socket::SSL
object.	 Yo ass may also pass parametas ta specify context or connection options as with
a call ta \fInew()\fR.  If yo ass is rockin dis function on a \fIaccept()\fRed socket, you must
set tha parameta \*(L"SSL_server\*(R" ta 1, i.e. IO::Socket::SSL\->start_SSL($socket, SSL_server => 1).
If you gotz a cold-ass lil class dat inherits from IO::Socket::SSL n' you want tha \f(CW$socket\fR ta be pimped
into yo' own class instead, use MyClass\->start_SSL($socket) ta big up tha desired effect.
.Sp
Note dat if \fIstart_SSL()\fR fails up in \s-1SSL\s0 negotiation, \f(CW$socket\fR will remain pimped up in its
original gangsta class.	 For non-blockin sockets you betta just upgrade tha socket to
IO::Socket::SSL n' call accept_SSL or connect_SSL n' tha upgraded object. To
just upgrade tha socket set \fBSSL_startHandshake\fR explicitly ta 0. If you call start_SSL
w/o dis parameta it will revert ta blockin behavior fo' accept_SSL n' connect_SSL.
.Sp
If given tha parameta \*(L"Timeout\*(R" it will stop if afta tha timeout no \s-1SSL\s0 connection
was established. Y'all KNOW dat shit, muthafucka! This parameta is only used fo' blockin sockets, if it aint given the
default Timeout from tha underlyin IO::Socket is ghon be used.
.IP "\fBstop_SSL(...)\fR" 4
.IX Item "stop_SSL(...)"
This is tha opposite of \fIstart_SSL()\fR, e.g. it will shutdown tha \s-1SSL\s0 connection
and return ta tha class before \fIstart_SSL()\fR. Well shiiiit, it gets tha same ol' dirty arguments as \fIclose()\fR,
in fact \fIclose()\fR calls \fIstop_SSL()\fR (but without downgradin tha class).
.Sp
Will return legit if it succeeded n' undef if failed. Y'all KNOW dat shit, muthafucka! This might be tha case for
non-blockin sockets, n' you can put dat on yo' toast. In dis case $! is set ta \s-1EAGAIN\s0 n' tha ssl error to
\&\s-1SSL_WANT_READ\s0 or \s-1SSL_WANT_WRITE.\s0 In dis case tha call should be retried again n' again n' again with
the same arguments once tha socket is locked n loaded is until it succeeds.
.IP "\fBIO::Socket::SSL\->new_from_fd($fd, ...)\fR" 4
.IX Item "IO::Socket::SSL->new_from_fd($fd, ...)"
This will convert a socket identified via a gangbangin' file descriptor tha fuck into a \s-1SSL\s0 socket.
Note dat tha argument list do not include a \*(L"\s-1MODE\*(R"\s0 argument; if you supply one,
it is ghon be thoughtfully ignored (for compatibilitizzle wit IO::Socket::INET).	Instead,
a mode of '+<' be assumed, n' tha file descriptor passed must be able ta handle such
I/O cuz tha initial \s-1SSL\s0 handshake requires bidirectionizzle communication.
.IP "\fBIO::Socket::SSL::set_default_context(...)\fR" 4
.IX Item "IO::Socket::SSL::set_default_context(...)"
Yo ass may use dis ta make IO::Socket::SSL automatically re-use a given context (unless
specifically overridden up in a cold-ass lil call ta \fInew()\fR).  It accepts one argument, which should
be either a IO::Socket::SSL object or a IO::Socket::SSL::SSL_Context object.	See
the SSL_reuse_ctx option of \fInew()\fR fo' mo' details.	 Note dat dis sets tha default
context globally, so use wit caution (esp. up in mod_perl scripts).
.IP "\fBIO::Socket::SSL::set_default_session_cache(...)\fR" 4
.IX Item "IO::Socket::SSL::set_default_session_cache(...)"
Yo ass may use dis ta make IO::Socket::SSL automatically re-use a given session cache
(unless specifically overridden up in a cold-ass lil call ta \fInew()\fR).  It accepts one argument, which should
be a IO::Socket::SSL::Session_Cache object or similar (e.g suttin' which implements
get_session n' add_session like IO::Socket::SSL::Session_Cache do).
See tha SSL_session_cache option of \fInew()\fR fo' mo' details.	 Note dat dis sets tha default
cache globally, so use wit caution.
.IP "\fBIO::Socket::SSL::set_defaults(%args)\fR" 4
.IX Item "IO::Socket::SSL::set_defaults(%args)"
With dis function one can set defaults fo' all SSL_* parameta used fo' creation of
the context, like tha SSL_verify* parameter.
.RS 4
.IP "mode \- set default SSL_verify_mode" 8
.IX Item "mode - set default SSL_verify_mode"
.PD 0
.IP "callback \- set default SSL_verify_callback" 8
.IX Item "callback - set default SSL_verify_callback"
.IP "scheme \- set default SSL_verifycn_scheme" 8
.IX Item "scheme - set default SSL_verifycn_scheme"
.IP "name \- set default SSL_verifycn_name" 8
.IX Item "name - set default SSL_verifycn_name"
.PD
If not given n' scheme is hash reference wit key callback it is ghon be set ta 'unknown'
.RE
.RS 4
.RE
.IP "\fBIO::Socket::SSL::set_client_defaults(%args)\fR" 4
.IX Item "IO::Socket::SSL::set_client_defaults(%args)"
Similar ta \f(CW\*(C`set_defaults\*(C'\fR yo, but only sets tha defaults fo' client mode.
.IP "\fBIO::Socket::SSL::set_server_defaults(%args)\fR" 4
.IX Item "IO::Socket::SSL::set_server_defaults(%args)"
Similar ta \f(CW\*(C`set_defaults\*(C'\fR yo, but only sets tha defaults fo' server mode.
.PP
Da followin methodz is unsupported (not ta mention futile!) n' IO::Socket::SSL
will emit a big-ass \s-1\fICROAK\s0()\fR if yo ass is wack-ass enough ta use them:
.IP "truncate" 4
.IX Item "truncate"
.PD 0
.IP "stat" 4
.IX Item "stat"
.IP "ungetc" 4
.IX Item "ungetc"
.IP "setbuf" 4
.IX Item "setbuf"
.IP "setvbuf" 4
.IX Item "setvbuf"
.IP "fdopen" 4
.IX Item "fdopen"
.IP "send/recv" 4
.IX Item "send/recv"
.PD
Note dat \fIsend()\fR n' \fIrecv()\fR cannot be reliably trapped by a tied filehandle (such as
that used by IO::Socket::SSL) n' so may bust unencrypted data over tha socket.	 Object-oriented
calls ta these functions will fail, spittin some lyrics ta you ta use tha print/printf/syswrite
and read/sysread crews instead.
.SS "Defaults fo' Cert, Key n' \s-1CA\s0"
.IX Subsection "Defaults fo' Cert, Key n' CA"
Only if no SSL_key*, no SSL_cert* n' no SSL_ca* options is given it will fall
back ta tha followin builtin defaults:
.IP "SSL_cert_file" 4
.IX Item "SSL_cert_file"
Dependin on tha SSL_server settin it is ghon be either \f(CW\*(C`certs/server\-cert.pem\*(C'\fR
or \f(CW\*(C`certs/client\-cert.pem\*(C'\fR.
.IP "SSL_key_file" 4
.IX Item "SSL_key_file"
Dependin on tha SSL_server settin it is ghon be either \f(CW\*(C`certs/server\-key.pem\*(C'\fR
or \f(CW\*(C`certs/client\-key.pem\*(C'\fR.
.IP "SSL_ca_file | SSL_ca_path" 4
.IX Item "SSL_ca_file | SSL_ca_path"
It will set SSL_ca_file ta \f(CW\*(C`certs/my\-ca.pem\*(C'\fR if it exist.
Otherwise it will set SSL_ca_path ta \f(CW\*(C`ca/\*(C'\fR if it exist.
.PP
\&\fBPlease note, dat these defaults is depreciated n' is ghon be removed up in the
near future\fR, e.g. you should specify all tha certificates n' keys you use.
If you don't specify a \s-1CA\s0 file or path it will fall back ta tha system default
built tha fuck into OpenSSL.
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
If a \s-1SSL\s0 specific error occurs tha global variable \f(CW$SSL_ERROR\fR is ghon be set.
If tha error occurred on a existin \s-1SSL\s0 socket tha method \f(CW\*(C`errstr\*(C'\fR will
give access ta tha sickest fuckin socket specific error.
Both \f(CW$SSL_ERROR\fR n' \f(CW\*(C`errstr\*(C'\fR method give a thugged-out dualvar similar ta \f(CW$!\fR, e.g.
providin a error number up in numeric context or a error description up in string
context.
.SH "NON-BLOCKING I/O"
.IX Header "NON-BLOCKING I/O"
If you gotz a non-blockin socket, tha expected behavior on read, write, accept
or connect is ta set \f(CW$!\fR ta \s-1EAGAIN\s0 if tha operation can not be completed
immediately.
.PP
With \s-1SSL\s0 there be cases, like wit \s-1SSL\s0 handshakes, where tha write operation
can not be completed until it can read from tha socket or vice versa. 
In these cases \f(CW$!\fR is set ta \s-1EGAIN\s0 like expected, n' additionally
\&\f(CW$SSL_ERROR\fR is set ta either \s-1SSL_WANT_READ\s0 or \s-1SSL_WANT_WRITE.\s0
Thus if you git \s-1EAGAIN\s0 on a \s-1SSL\s0 socket you must check \f(CW$SSL_ERROR\fR for
SSL_WANT_* n' adapt yo' event mask accordingly.
.PP
Usin readline on non-blockin sockets do not make much sense n' I would
advise against rockin dat shit.
And, while tha behavior aint documented fo' other IO::Socket classes, it
will try ta emulate tha behavior peeped there, e.g. ta return tha received data
instead of blocking, even if tha line aint complete. If a unrecoverable error
occurs it will return nothing, even if it already received some data.
.SH "SNI Support"
.IX Header "SNI Support"
Newer extensions ta \s-1SSL\s0 can distinguish between multiple hostnames on tha same
\&\s-1IP\s0 address rockin Server Name Indication (\s-1SNI\s0).
.PP
Support fo' \s-1SNI\s0 on tha client side was added somewhere up in tha OpenSSL 0.9.8
series yo, but only wit 1.0 a funky-ass bug was fixed when tha server could not decizzle about
its hostname. Therefore client side \s-1SNI\s0 is only supported wit OpenSSL 1.0 or
higher up in IO::Socket::SSL.
With a supported version, \s-1SNI\s0 is used automatically on tha client side, if it can
determine tha hostname from \f(CW\*(C`PeerAddr\*(C'\fR or \f(CW\*(C`PeerHost\*(C'\fR. On unsupported OpenSSL
versions it will silently not use \s-1SNI.\s0
Da hostname can also be given explicitly given wit \f(CW\*(C`SSL_hostname\*(C'\fR yo, but in
this case it will throw up in error, if \s-1SNI\s0 aint supported.
To check fo' support you might call \f(CW\*(C`IO::Socket::SSL\-\*(C'\fR\fIcan_client_sni()\fR>.
.PP
On tha server side earlier versionz of OpenSSL is supported yo, but only together
with Net::SSLeay version >= 1.50.
To check fo' support you might call \f(CW\*(C`IO::Socket::SSL\-\*(C'\fR\fIcan_server_sni()\fR>.
If server side \s-1SNI\s0 is supported, you might specify different certificates per
host wit \f(CW\*(C`SSL_cert*\*(C'\fR n' \f(CW\*(C`SSL_key*\*(C'\fR, n' check tha axed name using
\&\f(CW\*(C`get_servername\*(C'\fR.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
A few chizzlez have gone tha fuck into IO::Socket::SSL v0.93 n' lata wit respect to
return joints.	Da behavior on success remains unchanged yo, but fo' \fIall\fR functions,
the return value on error is now a empty list.	 Therefore, tha return value will be
false up in all contexts yo, but dem playas whoz ass done been rockin tha return joints as arguments
to subroutines (like \f(CW\*(C`mysub(IO::Socket::SSL(...)\-\*(C'\fRnew, ...)>) may run tha fuck into problems.
Da moral of tha story: \fIalways\fR check tha return jointz of these functions before
usin dem up in any way dat you consider meaningful.
.SH "DEBUGGING"
.IX Header "DEBUGGING"
If yo ass is havin problems rockin IO::Socket::SSL despite tha fact dat can recite backwards
the section of dis documentation labelled 'Usin \s-1SSL\s0', you should try enablin debugging.	To
specify tha debug level, pass 'debug#' (where # be a number from 0 ta 3) ta IO::Socket::SSL
when callin dat shit.
Da debug level will also be propagated ta Net::SSLeay::trace, peep also Net::SSLeay:
.IP "use IO::Socket::SSL qw(debug0);" 4
.IX Item "use IO::Socket::SSL qw(debug0);"
No debuggin (default).
.IP "use IO::Socket::SSL qw(debug1);" 4
.IX Item "use IO::Socket::SSL qw(debug1);"
Print up errors from IO::Socket::SSL n' ciphers from Net::SSLeay.
.IP "use IO::Socket::SSL qw(debug2);" 4
.IX Item "use IO::Socket::SSL qw(debug2);"
Print also shiznit bout call flow from IO::Socket::SSL n' progress
information from Net::SSLeay.
.IP "use IO::Socket::SSL qw(debug3);" 4
.IX Item "use IO::Socket::SSL qw(debug3);"
Print also some data dumps from IO::Socket::SSL n' from Net::SSLeay.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See tha 'example' directory.
.SH "BUGS"
.IX Header "BUGS"
IO::Socket::SSL dependz on Net::SSLeay.  Up ta version 1.43 of Net::SSLeay
it was not thread safe, although it did probably work if you did not use 
SSL_verify_callback n' SSL_password_cb.
.PP
If you use IO::Socket::SSL together wit threadz you should load it (e.g. use or
require) inside tha main thread before bustin any other threadz which use dat shit.
This way it is much fasta cuz it is ghon be initialized only once fo' realz. Also there
are reports dat it might crash tha other way.
.PP
Creatin a IO::Socket::SSL object up in one thread n' closin it up in another
thread aint gonna work.
.PP
IO::Socket::SSL do not work together wit Storable::fd_retrieve/fd_store.
See \s-1BUGS\s0 file fo' mo' shiznit n' how tha fuck ta work round tha problem.
.PP
Non-blockin n' timeouts (which is based on non-blocking) is not
supported on Win32, cuz tha underlyin IO::Socket::INET do not support
non-blockin on dis platform.
.PP
If you gotz a server n' it be lookin like you gotz a memory leak you might 
check tha size of yo' session cache. Default fo' Net::SSLeay seems ta be 
20480, peep tha example fo' SSL_create_ctx_callback fo' how tha fuck ta limit dat shit.
.PP
Da default fo' SSL_verify_mode on tha client is currently \s-1SSL_VERIFY_NONE,\s0
which be a straight-up wack idea, thus tha default will chizzle up in tha near future.
See documentation fo' SSL_verify_mode fo' mo' shiznit.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
IO::Socket::SSL uses Net::SSLeay as tha shiny intercourse ta OpenSSL, which is
the shiny intercourse ta tha uglinizz of \s-1SSL.	\s0 As a result, yo big-ass booty is ghon need both Net::SSLeay
and OpenSSL on yo' computa before rockin dis module.
.PP
If you have Scalar::Util (standard wit Perl 5.8.0 n' above) or WeakRef, IO::Socket::SSL
sockets will auto-close when they go outta scope, just like IO::Socket::INET sockets.	If
you aint gots one of these modules, then IO::Socket::SSL sockets will stay open until the
program endz or you explicitly close em.	This is cuz of tha fact dat a cold-ass lil circular reference
is required ta make IO::Socket::SSL sockets act simultaneously like objects n' glob references.
.SH "DEPRECATIONS"
.IX Header "DEPRECATIONS"
Da followin functions is deprecated n' is only retained fo' compatibility:
.IP "\fIcontext_init()\fR" 2
.IX Item "context_init()"
use tha SSL_reuse_ctx option if you wanna re-use a cold-ass lil context
.IP "\fIsocketToSSL()\fR n' \fIsocket_to_SSL()\fR" 2
.IX Item "socketToSSL() n' socket_to_SSL()"
use IO::Socket::SSL\->\fIstart_SSL()\fR instead
.IP "\fIkill_socket()\fR" 2
.IX Item "kill_socket()"
use \fIclose()\fR instead
.IP "\fIget_peer_certificate()\fR" 2
.IX Item "get_peer_certificate()"
use tha \fIpeer_certificate()\fR function instead.
Used ta return X509_Certificate wit methodz subject_name n' issuer_name.
Now simply returns \f(CW$self\fR which has these methodz (although deprecated).
.IP "\fIissuer_name()\fR" 2
.IX Item "issuer_name()"
use peer_certificate( 'issuer' ) instead
.IP "\fIsubject_name()\fR" 2
.IX Item "subject_name()"
use peer_certificate( 'subject' ) instead
.SH "SEE ALSO"
.IX Header "SEE ALSO"
IO::Socket::INET, IO::Socket::INET6, IO::Socket::IP, Net::SSLeay.
.SH "AUTHORS"
.IX Header "AUTHORS"
Steffen Ullrich, <steffen at genua.de> is tha current maintainer.
.PP
Peta Behroozi, <behrooz at fas.harvard.edu> (Note tha lack of a \*(L"i\*(R" all up in tha end of \*(L"behrooz\*(R")
.PP
Marko Asplund, <marko.asplund at kronodoc.fi>, was tha original gangsta lyricist of IO::Socket::SSL.
.PP
Patches incorporated from various people, peep file Chizzles.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Da original gangsta versionz of dis module is Copyright (C) 1999\-2002 Marko Asplund.
.PP
Da rewrite of dis module is Copyright (C) 2002\-2005 Peta Behroozi.
.PP
Versions 0.98 n' newer is Copyright (C) 2006\-2013 Steffen Ullrich.
.PP
This module is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.SH "Appendix: Usin SSL"
.IX Header "Appendix: Usin SSL"
If yo ass is unfamiliar wit tha way OpenSSL works, phat references may be found in
both tha book \*(L"Network Securitizzle wit OpenSSL\*(R" (Oreilly & Assoc.) n' tha wizzy crib
<http://www.tldp.org/HOWTO/SSL\-Certificates\-HOWTO/>.  Read on fo' a quick overview.
.SS "Da Long of It (Detail)"
.IX Subsection "Da Long of It (Detail)"
Da usual reason fo' rockin \s-1SSL\s0 is ta keep yo' data safe.  This means dat not only
do you gotta encrypt tha data while it is bein transported over a network yo, but
you also gotta make shizzle dat tha right thug gets tha data.	 To accomplish this
with \s-1SSL,\s0 you gotta use certificates.	 A certificate closely resemblez a
Government-issued \s-1ID \s0(at least up in places where you can trust them).	 Da \s-1ID\s0 gotz nuff some sort of
identifyin shiznit like fuckin a name n' address, n' is probably stamped wit a seal
of Posse Approval.	 Theoretically, dis means dat you may trust tha shiznit on
the card n' do bidnizz wit tha balla of tha card. Y'all KNOW dat shit, muthafucka!  Da same scams apply ta \s-1SSL\s0 certificates,
which have some identifyin shiznit n' is \*(L"stamped\*(R" [most playas refer ta dis as
\&\fIsigning\fR instead] by one of mah thugs (a Certificate Authority) whoz ass you trust will adequately
verify tha identifyin shiznit.	 In dis case, cuz of some smart-ass number theory,
it is mad hard as fuck ta falsify tha stampin process.	Another useful consequence
of number theory is dat tha certificate is linked ta tha encryption process, so you may
encrypt data (usin shiznit on tha certificate) dat only tha certificate balla can
decrypt.
.PP
What do dis mean fo' yo slick ass, biatch?  It means dat at least one thug up in tha jam has to
have a \s-1ID\s0 ta git dranks :\-).  Seriously, it means dat one of tha playas communicating
has ta git a cold-ass lil certificate ta ensure dat yo' data is safe.	 For client/server
interactions, tha server must \fBalways\fR gotz a cold-ass lil certificate.	 If tha server wants to
verify dat tha client is safe, then tha client must also gotz a underground certificate.
To verify dat a cold-ass lil certificate is safe, one compares tha stamped \*(L"seal\*(R" [commonly called
an \fIencrypted digest/hash/signature\fR] on tha certificate wit tha straight-up legit \*(L"seal\*(R" of
the Certificate Authoritizzle ta make shizzle dat they is tha same.	To do this, you will
need tha [unfortunately named] certificate of tha Certificate Authority.  With all these
in hand, you can set up a \s-1SSL\s0 connection n' be reasonably Kool & Tha Gang dat no-one is
readin yo' data.
.SS "Da Short of It (Summary)"
.IX Subsection "Da Short of It (Summary)"
For servers, yo big-ass booty is ghon need ta generate a cold-ass lil cryptographic private key n' a cold-ass lil certificate
request.  Yo ass will need ta bust tha certificate request ta a Certificate Authoritizzle to
get a real certificate back, afta which you can start servin people.	For clients,
you aint gonna need anythang unless tha server wants validation, up in which case you will
also need a private key n' a real certificate.	 For mo' shiznit bout how tha fuck to
get these, peep <http://www.modssl.org/docs/2.8/ssl_faq.html#ToC24>.
