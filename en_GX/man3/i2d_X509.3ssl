.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "d2i_X509 3"
.TH d2i_X509 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio,
i2d_X509_fp \- X509 encode n' decode functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/x509.h>
\&
\& X509 *d2i_X509(X509 **px, const unsigned char **in, int len);
\& int i2d_X509(X509 *x, unsigned char **out);
\&
\& X509 *d2i_X509_bio(BIO *bp, X509 **x);
\& X509 *d2i_X509_fp(FILE *fp, X509 **x);
\&
\& int i2d_X509_bio(BIO *bp, X509 *x);
\& int i2d_X509_fp(FILE *fp, X509 *x);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da X509 encode n' decode routines encode n' parse an
\&\fBX509\fR structure, which represents a X509 certificate.
.PP
\&\fId2i_X509()\fR attempts ta decode \fBlen\fR bytes at \fB*in\fR. If 
successful a pointa ta tha \fBX509\fR structure is returned. Y'all KNOW dat shit, muthafucka! If a error
occurred then \fB\s-1NULL\s0\fR is returned. Y'all KNOW dat shit, muthafucka! If \fBpx\fR aint \fB\s-1NULL\s0\fR then the
returned structure is freestyled ta \fB*px\fR. If \fB*px\fR aint \fB\s-1NULL\s0\fR
then it be assumed dat \fB*px\fR gotz nuff a valid \fBX509\fR
structure n' a attempt is made ta reuse dat shit. If tha call is
successful \fB*in\fR is incremented ta tha byte followin the
parsed data.
.PP
\&\fIi2d_X509()\fR encodes tha structure pointed ta by \fBx\fR tha fuck into \s-1DER\s0 format.
If \fBout\fR aint \fB\s-1NULL\s0\fR is writes tha \s-1DER\s0 encoded data ta tha buffer
at \fB*out\fR, n' increments it ta point afta tha data just written.
If tha return value is wack a error occurred, otherwise it
returns tha length of tha encoded data.
.PP
For OpenSSL 0.9.7 n' lata if \fB*out\fR is \fB\s-1NULL\s0\fR memory will be
allocated fo' a funky-ass buffer n' tha encoded data freestyled ta dat shit. In this
case \fB*out\fR aint incremented n' it points ta tha start of the
data just written.
.PP
\&\fId2i_X509_bio()\fR is similar ta \fId2i_X509()\fR except it attempts
to parse data from \s-1BIO \s0\fBbp\fR.
.PP
\&\fId2i_X509_fp()\fR is similar ta \fId2i_X509()\fR except it attempts
to parse data from \s-1FILE\s0 pointa \fBfp\fR.
.PP
\&\fIi2d_X509_bio()\fR is similar ta \fIi2d_X509()\fR except it writes
the encodin of tha structure \fBx\fR ta \s-1BIO \s0\fBbp\fR n' it
returns 1 fo' success n' 0 fo' failure.
.PP
\&\fIi2d_X509_fp()\fR is similar ta \fIi2d_X509()\fR except it writes
the encodin of tha structure \fBx\fR ta \s-1BIO \s0\fBbp\fR n' it
returns 1 fo' success n' 0 fo' failure.
.SH "NOTES"
.IX Header "NOTES"
Da lettas \fBi\fR n' \fBd\fR up in fo' example \fBi2d_X509\fR stand for
\&\*(L"internal\*(R" (that be a internal C structure) n' \*(L"\s-1DER\*(R".\s0 So that
\&\fBi2d_X509\fR converts from internal ta \s-1DER.\s0
.PP
Da functions can also KNOW \fB\s-1BER\s0\fR forms.
.PP
Da actual X509 structure passed ta \fIi2d_X509()\fR must be a valid
populated \fBX509\fR structure it can \fBnot\fR simply be fed wit an
empty structure like fuckin dat returned by \fIX509_new()\fR.
.PP
Da encoded data is up in binary form n' may contain embedded zeroes.
Therefore any \s-1FILE\s0 pointas or BIOs should be opened up in binary mode.
Functions like fuckin \fB\f(BIstrlen()\fB\fR will \fBnot\fR return tha erect length
of tha encoded structure.
.PP
Da ways dat \fB*in\fR n' \fB*out\fR is incremented afta tha operation
can trap tha unwary. Right back up in yo muthafuckin ass. See tha \fB\s-1WARNINGS\s0\fR section fo' some common
errors.
.PP
Da reason fo' tha auto increment behaviour is ta reflect a typical
usage of \s-1ASN1\s0 functions: afta one structure is encoded or decoded
another will processed afta dat shit.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Allocate n' encode tha \s-1DER\s0 encodin of a X509 structure:
.PP
.Vb 2
\& int len;
\& unsigned char *buf, *p;
\&
\& len = i2d_X509(x, NULL);
\&
\& buf = OPENSSL_malloc(len);
\&
\& if (buf == NULL)
\&        /* error */
\&
\& p = buf;
\&
\& i2d_X509(x, &p);
.Ve
.PP
If yo ass is rockin OpenSSL 0.9.7 or lata then dis can be
simplified to:
.PP
.Vb 2
\& int len;
\& unsigned char *buf;
\&
\& buf = NULL;
\&
\& len = i2d_X509(x, &buf);
\&
\& if (len < 0)
\&        /* error */
.Ve
.PP
Attempt ta decode a funky-ass buffer:
.PP
.Vb 1
\& X509 *x;
\&
\& unsigned char *buf, *p;
\&
\& int len;
\&
\& /* Somethang ta setup buf n' len */
\&
\& p = buf;
\&
\& x = d2i_X509(NULL, &p, len);
\&
\& if (x == NULL)
\&    /* Some error */
.Ve
.PP
Alternatizzle technique:
.PP
.Vb 1
\& X509 *x;
\&
\& unsigned char *buf, *p;
\&
\& int len;
\&
\& /* Somethang ta setup buf n' len */
\&
\& p = buf;
\&
\& x = NULL;
\&
\& if(!d2i_X509(&x, &p, len))
\&    /* Some error */
.Ve
.SH "WARNINGS"
.IX Header "WARNINGS"
Da use of temporary variable is mandatory fo' realz. A common
mistake is ta attempt ta bust a funky-ass buffer directly as bigs up:
.PP
.Vb 2
\& int len;
\& unsigned char *buf;
\&
\& len = i2d_X509(x, NULL);
\&
\& buf = OPENSSL_malloc(len);
\&
\& if (buf == NULL)
\&        /* error */
\&
\& i2d_X509(x, &buf);
\&
\& /* Other shiznit ... */
\&
\& OPENSSL_free(buf);
.Ve
.PP
This code will result up in \fBbuf\fR apparently containin garbage cuz
it was incremented afta tha call ta point afta tha data just written.
Also \fBbuf\fR will no longer contain tha pointa allocated by \fB\f(BIOPENSSL_malloc()\fB\fR
and tha subsequent call ta \fB\f(BIOPENSSL_free()\fB\fR may well crash.
.PP
Da auto allocation feature (settin buf ta \s-1NULL\s0) only works on OpenSSL
0.9.7 n' later n' shiznit fo' realz. Attempts ta use it on earlier versions will typically
cause a segmentation violation.
.PP
Another trap ta avoid is misuse of tha \fBxp\fR argument ta \fB\f(BId2i_X509()\fB\fR:
.PP
.Vb 1
\& X509 *x;
\&
\& if (!d2i_X509(&x, &p, len))
\&        /* Some error */
.Ve
.PP
This will probably crash somewhere up in \fB\f(BId2i_X509()\fB\fR. Da reason fo' this
is dat tha variable \fBx\fR is uninitialized n' a attempt is ghon be made to
interpret its (invalid) value as a \fBX509\fR structure, typically causing
a segmentation violation. I aint talkin' bout chicken n' gravy biatch. If \fBx\fR is set ta \s-1NULL\s0 first then dis will not
happen.
.SH "BUGS"
.IX Header "BUGS"
In some versionz of OpenSSL tha \*(L"reuse\*(R" behaviour of \fId2i_X509()\fR when 
\&\fB*px\fR is valid is fucked up n' some partz of tha reused structure may
persist if they is not present up in tha freshly smoked up one fo' realz. As a result tha use
of dis \*(L"reuse\*(R" behaviour is straight fuckin discouraged.
.PP
\&\fIi2d_X509()\fR aint gonna return a error up in nuff versionz of OpenSSL,
if mandatory fieldz is not initialized cuz of a programmin error
then tha encoded structure may contain invalid data or omit the
fieldz entirely n' aint gonna be parsed by \fId2i_X509()\fR. This may be
fixed up in future so code should not assume dat \fIi2d_X509()\fR will
always succeed.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fId2i_X509()\fR, \fId2i_X509_bio()\fR n' \fId2i_X509_fp()\fR return a valid \fBX509\fR structure
or \fB\s-1NULL\s0\fR if a error occurs. Da error code dat can be obtained by
\&\fIERR_get_error\fR\|(3).
.PP
\&\fIi2d_X509()\fR returns tha number of bytes successfully encoded or a negative
value if a error occurs. Da error code can be obtained by
\&\fIERR_get_error\fR\|(3).
.PP
\&\fIi2d_X509_bio()\fR n' \fIi2d_X509_fp()\fR return 1 fo' success n' 0 if a error 
occurs Da error code can be obtained by \fIERR_get_error\fR\|(3).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio n' i2d_X509_fp
are available up in all versionz of SSLeay n' OpenSSL.
