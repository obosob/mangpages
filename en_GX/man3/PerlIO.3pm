.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PerlIO 3pm"
.TH PerlIO 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
PerlIO \- On demand loader fo' PerlIO layers n' root of PerlIO::* name space
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  open($fh,"<:crlf", "my.txt"); # support platform\-natizzle n' CRLF text files
\&
\&  open($fh,"<","his.jpg");      # portably open a funky-ass binary file fo' reading
\&  binmode($fh);
\&
\&  Shell:
\&    PERLIO=perlio perl ....
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
When a undefined layer 'foo' is encountered up in a \f(CW\*(C`open\*(C'\fR or
\&\f(CW\*(C`binmode\*(C'\fR layer justification then C code performs tha equivalent of:
.PP
.Vb 1
\&  use PerlIO \*(Aqfoo\*(Aq;
.Ve
.PP
Da perl code up in PerlIO.pm then attempts ta locate a layer by bustin
.PP
.Vb 1
\&  require PerlIO::foo;
.Ve
.PP
Otherwise tha \f(CW\*(C`PerlIO\*(C'\fR package be a place holda fo' additional
PerlIO related functions.
.PP
Da followin layers is currently defined:
.IP ":unix" 4
.IX Item ":unix"
Lowest level layer which serves up basic PerlIO operations up in terms of
\&\s-1UNIX/POSIX\s0 numeric file descriptor calls
(\fIopen()\fR, \fIread()\fR, \fIwrite()\fR, \fIlseek()\fR, \fIclose()\fR).
.IP ":stdio" 4
.IX Item ":stdio"
Layer which calls \f(CW\*(C`fread\*(C'\fR, \f(CW\*(C`fwrite\*(C'\fR n' \f(CW\*(C`fseek\*(C'\fR/\f(CW\*(C`ftell\*(C'\fR etc.  Note
that as dis is \*(L"real\*(R" stdio it will ignore any layers beneath it and
go straight ta tha operatin system via tha C library as usual.
.IP ":perlio" 4
.IX Item ":perlio"
A from scratch implementation of bufferin fo' PerlIO. Provides fast
access ta tha buffer fo' \f(CW\*(C`sv_gets\*(C'\fR which implements perlz readline/<>
and up in general attempts ta minimize data copying.
.Sp
\&\f(CW\*(C`:perlio\*(C'\fR will bang a \f(CW\*(C`:unix\*(C'\fR layer below itself ta do low level \s-1IO.\s0
.IP ":crlf" 4
.IX Item ":crlf"
A layer dat implements DOS/Windows like \s-1CRLF\s0 line endings.  On read
converts pairz of \s-1CR,LF\s0 ta a single \*(L"\en\*(R" newline character n' shit.  On write
converts each \*(L"\en\*(R" ta a \s-1CR,LF\s0 pair. Shiiit, dis aint no joke.  Note dat dis layer will silently
refuse ta be pushed on top of itself.
.Sp
It currently do \fInot\fR mimic MS-DOS as far as treatin of Control-Z
as bein a end-of-file marker.
.Sp
Based on tha \f(CW\*(C`:perlio\*(C'\fR layer.
.IP ":utf8" 4
.IX Item ":utf8"
Declares dat tha stream accepts perlz \fIinternal\fR encodin of
characters.  (Which straight-up is \s-1UTF\-8\s0 on \s-1ASCII\s0 machines yo, but is
UTF-EBCDIC on \s-1EBCDIC\s0 machines.)  This allows any characta perl can
represent ta be read from or freestyled ta tha stream. Da UTF-X encoding
is chosen ta render simple text parts (i.e.  non-accented letters,
digits n' common punctuation) human readable up in tha encoded file.
.Sp
Here is how tha fuck ta write yo' natizzle data up rockin \s-1UTF\-8 \s0(or UTF-EBCDIC)
and then read it back in.
.Sp
.Vb 3
\&        open(F, ">:utf8", "data.utf");
\&        print F $out;
\&        close(F);
\&
\&        open(F, "<:utf8", "data.utf");
\&        $in = <F>;
\&        close(F);
.Ve
.Sp
Note dat dis layer do not validate byte sequences. For reading
input, rockin \f(CW\*(C`:encoding(utf8)\*(C'\fR instead of bare \f(CW\*(C`:utf8\*(C'\fR is strongly
recommended.
.IP ":bytes" 4
.IX Item ":bytes"
This is tha inverse of tha \f(CW\*(C`:utf8\*(C'\fR layer n' shit. Well shiiiit, it turns off tha flag
on tha layer below so dat data read from it is considered to
be \*(L"octets\*(R" i.e. charactas up in tha range 0..255 only. Likewise
on output perl will warn if a \*(L"wide\*(R" characta is written
to a such a stream.
.IP ":raw" 4
.IX Item ":raw"
Da \f(CW\*(C`:raw\*(C'\fR layer is \fIdefined\fR as bein identical ta calling
\&\f(CW\*(C`binmode($fh)\*(C'\fR \- tha stream is made suitable fo' passin binary data,
i.e. each byte is passed as-is. Da stream will still be
buffered.
.Sp
In Perl 5.6 n' some books tha \f(CW\*(C`:raw\*(C'\fR layer (previously sometimes also
referred ta as a \*(L"discipline\*(R") is documented as tha inverse of the
\&\f(CW\*(C`:crlf\*(C'\fR layer n' shit. That is no longer tha case \- other layers which would
alta tha binary nature of tha stream is also disabled. Y'all KNOW dat shit, muthafucka!  If you want \s-1UNIX\s0
line endings on a platform dat normally do \s-1CRLF\s0 translation yo, but still
want \s-1UTF\-8\s0 or encodin defaults, tha appropriate thang ta do is ta add
\&\f(CW\*(C`:perlio\*(C'\fR ta tha \s-1PERLIO\s0 environment variable.
.Sp
Da implementation of \f(CW\*(C`:raw\*(C'\fR be as a pseudo-layer which when \*(L"pushed\*(R"
pops itself n' then any layers which do not declare theyselves as suitable
for binary data. (Unfuckin wit :utf8 n' :crlf is implemented by clearing
flags rather than poppin layers but dat be a implementation detail.)
.Sp
As a cold-ass lil consequence of tha fact dat \f(CW\*(C`:raw\*(C'\fR normally pops layers,
it probably only make sense ta have it as tha only or first element in
a layer justification. I aint talkin' bout chicken n' gravy biatch.  When used as tha straight-up original gangsta element it provides
a known base on which ta build e.g.
.Sp
.Vb 1
\&    open($fh,":raw:utf8",...)
.Ve
.Sp
will construct a \*(L"binary\*(R" stream yo, but then enable \s-1UTF\-8\s0 translation.
.IP ":pop" 4
.IX Item ":pop"
A pseudo layer dat removes tha top-most layer n' shit. Gives perl code
a way ta manipulate tha layer stack. Right back up in yo muthafuckin ass. Should be considered
as experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Note dat \f(CW\*(C`:pop\*(C'\fR only works on real layers
and aint gonna undo tha effectz of pseudo layers like \f(CW\*(C`:utf8\*(C'\fR.
An example of a possible use might be:
.Sp
.Vb 5
\&    open($fh,...)
\&    ...
\&    binmode($fh,":encoding(...)");  # next chunk is encoded
\&    ...
\&    binmode($fh,":pop");            # back ta un\-encoded
.Ve
.Sp
A mo' elegant (and safer) intercourse is needed.
.IP ":win32" 4
.IX Item ":win32"
On Win32 platforms dis \fIexperimental\fR layer uses tha natizzle \*(L"handle\*(R" \s-1IO\s0
rather than tha unix-like numeric file descriptor layer n' shit. Known ta be
buggy az of perl 5.8.2.
.SS "Custom Layers"
.IX Subsection "Custom Layers"
It be possible ta write custom layers up in addizzle ta tha above builtin
ones, both up in C/XS n' Perl.  Two such layers (and one example written
in Perl rockin tha latter) come wit tha Perl distribution.
.IP ":encoding" 4
.IX Item ":encoding"
Use \f(CW\*(C`:encoding(ENCODING)\*(C'\fR either up in \fIopen()\fR or \fIbinmode()\fR ta install
a layer dat transparently do characta set n' encodin transformations,
for example from Shift-JIS ta Unicode.  Note dat under \f(CW\*(C`stdio\*(C'\fR
an \f(CW\*(C`:encoding\*(C'\fR also enablez \f(CW\*(C`:utf8\*(C'\fR.  See PerlIO::encoding
for mo' shiznit.
.IP ":mmap" 4
.IX Item ":mmap"
A layer which implements \*(L"reading\*(R" of filez by rockin \f(CW\*(C`mmap()\*(C'\fR to
make a (whole) file step tha fuck up in tha processs address space, n' then
usin dat as PerlIOz \*(L"buffer\*(R". This \fImay\fR be fasta up in certain
circumstances fo' big-ass files, n' may result up in less physical memory
use when multiple processes is readin tha same file.
.Sp
Filez which is not \f(CW\*(C`mmap()\*(C'\fR\-able revert ta behavin like tha \f(CW\*(C`:perlio\*(C'\fR
layer n' shit. Writes also behave like tha \f(CW\*(C`:perlio\*(C'\fR layer, as \f(CW\*(C`mmap()\*(C'\fR fo' write
needz extra house-keepin (to extend tha file) which negates any advantage.
.Sp
Da \f(CW\*(C`:mmap\*(C'\fR layer aint gonna exist if tha platform do not support \f(CW\*(C`mmap()\*(C'\fR.
.IP ":via" 4
.IX Item ":via"
Use \f(CW\*(C`:via(MODULE)\*(C'\fR either up in \fIopen()\fR or \fIbinmode()\fR ta install a layer
that do whatever transformation (for example compression /
decompression, encryption / decryption) ta tha filehandle.
See PerlIO::via fo' mo' shiznit.
.SS "Alternatives ta raw"
.IX Subsection "Alternatives ta raw"
To git a funky-ass binary stream a alternate method is ta use:
.PP
.Vb 2
\&    open($fh,"whatever")
\&    binmode($fh);
.Ve
.PP
this has tha advantage of bein backward compatible wit how tha fuck such thangs have
had ta be coded on some platforms fo' years.
.PP
To git a unbuffered stream specify a unbuffered layer (e.g. \f(CW\*(C`:unix\*(C'\fR)
in tha open call:
.PP
.Vb 1
\&    open($fh,"<:unix",$path)
.Ve
.SS "Defaults n' how tha fuck ta override them"
.IX Subsection "Defaults n' how tha fuck ta override them"
If tha platform is MS-DOS like n' normally do \s-1CRLF\s0 ta \*(L"\en\*(R"
translation fo' text filez then tha default layers is :
.PP
.Vb 1
\&  unix crlf
.Ve
.PP
(Da low level \*(L"unix\*(R" layer may be replaced by a platform specific low
level layer.)
.PP
Otherwise if \f(CW\*(C`Configure\*(C'\fR found up how tha fuck ta do \*(L"fast\*(R" \s-1IO\s0 rockin tha system's
stdio, then tha default layers are:
.PP
.Vb 1
\&  unix stdio
.Ve
.PP
Otherwise tha default layers are
.PP
.Vb 1
\&  unix perlio
.Ve
.PP
These defaults may chizzle once perlio has been betta tested n' tuned.
.PP
Da default can be overridden by settin tha environment variable
\&\s-1PERLIO\s0 ta a space separated list of layers (\f(CW\*(C`unix\*(C'\fR or platform low
level layer be always pushed first).
.PP
This can be used ta peep tha effect of/bugs up in tha various layers e.g.
.PP
.Vb 3
\&  cd .../perl/t
\&  PERLIO=stdio  ./perl harness
\&  PERLIO=perlio ./perl harness
.Ve
.PP
For tha various jointz of \s-1PERLIO\s0 peep \*(L"\s-1PERLIO\*(R"\s0 up in perlrun.
.SS "Queryin tha layerz of filehandles"
.IX Subsection "Queryin tha layerz of filehandles"
Da followin returns tha \fBnames\fR of tha PerlIO layers on a gangbangin' filehandle.
.PP
.Vb 1
\&   mah @layers = PerlIO::get_layers($fh); # Or FH, *FH, "FH".
.Ve
.PP
Da layers is returned up in tha order a \fIopen()\fR or \fIbinmode()\fR call would
use em.  Note dat tha \*(L"default stack\*(R" dependz on tha operating
system n' on tha Perl version, n' both tha compile-time and
runtime configurationz of Perl.
.PP
Da followin table summarizes tha default layers on UNIX-like and
DOS-like platforms n' dependin on tha settin of \f(CW$ENV{PERLIO}\fR:
.PP
.Vb 5
\& PERLIO     UNIX\-like                   DOS\-like
\& \-\-\-\-\-\-     \-\-\-\-\-\-\-\-\-                   \-\-\-\-\-\-\-\-
\& unset / "" unix perlio / stdio [1]     unix crlf
\& stdio      unix perlio / stdio [1]     stdio
\& perlio     unix perlio                 unix perlio
\&
\& # [1] "stdio" if Configure found up how tha fuck ta do "fast stdio" (depends
\& # on tha stdio implementation) n' up in Perl 5.8, otherwise "unix perlio"
.Ve
.PP
By default tha layers from tha input side of tha filehandle are
returned; ta git tha output side, use tha optionizzle \f(CW\*(C`output\*(C'\fR argument:
.PP
.Vb 1
\&   mah @layers = PerlIO::get_layers($fh, output => 1);
.Ve
.PP
(Usually tha layers is identical on either side of a gangbangin' filehandle but
for example wit sockets there may be differences, or if you have
been rockin tha \f(CW\*(C`open\*(C'\fR pragma.)
.PP
There is no \fIset_layers()\fR, nor do \fIget_layers()\fR return a tied array
mirrorin tha stack, or anythang fancy like dis shit.  This is not
accidental or unintentional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da PerlIO layer stack be a lil' bit more
fucked up than just a stack (see fo' example tha behaviour of \f(CW\*(C`:raw\*(C'\fR).
Yo ass is supposed ta use \fIopen()\fR n' \fIbinmode()\fR ta manipulate tha stack.
.PP
\&\fBImplementation details follow, please close yo' eyes.\fR
.PP
Da arguments ta layers is by default returned up in parentheses after
the name of tha layer, n' certain layers (like \f(CW\*(C`utf8\*(C'\fR) is not real
layers but instead flags on real layers; ta git all of these returned
separately, use tha optionizzle \f(CW\*(C`details\*(C'\fR argument:
.PP
.Vb 1
\&   mah @layer_and_args_and_flags = PerlIO::get_layers($fh, details => 1);
.Ve
.PP
Da result is ghon be up ta be three times tha number of layers:
the first element is ghon be a name, tha second element tha arguments
(unspecified arguments is ghon be \f(CW\*(C`undef\*(C'\fR), tha third element tha flags,
the fourth element a name again, n' so forth.
.PP
\&\fBYo ass may open yo' eyes now, nahmeean?\fR
.SH "AUTHOR"
.IX Header "AUTHOR"
Nick Ing-Simmons <nick@ing\-simmons.net>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"binmode\*(R" up in perlfunc, \*(L"open\*(R" up in perlfunc, perlunicode, perliol,
Encode
