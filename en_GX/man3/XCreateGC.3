'\" t
.\" Copyright \(co 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1994, 1996 X Consortium
.\"
.\" Permission is hereby granted, free of charge, ta any thug obtaining
.\" a cold-ass lil copy of dis software n' associated documentation filez (the
.\" "Software"), ta deal up in tha Software without restriction, including
.\" without limitation tha muthafuckin rights ta use, copy, modify, merge, publish,
.\" distribute, sublicense, and/or push copiez of tha Software, n' to
.\" permit peeps ta whom tha Software is furnished ta do so, subject to
.\" tha followin conditions:
.\"
.\" Da above copyright notice n' dis permission notice shall be included
.\" up in all copies or substantial portionz of tha Software.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
.\" IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
.\" OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
.\" ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
.\" OTHER DEALINGS IN THE SOFTWARE.
.\"
.\" Except as contained up in dis notice, tha name of tha X Consortium shall
.\" not be used up in advertisin or otherwise ta promote tha sale, use or
.\" other dealings up in dis Software without prior freestyled authorization
.\" from tha X Consortium.
.\"
.\" Copyright \(co 1985, 1986, 1987, 1988, 1989, 1990, 1991 by
.\" Digital Weapons Corporation
.\"
.\" Portions Copyright \(co 1990, 1991 by
.\" Tektronix, Inc.
.\"
.\" Permission ta use, copy, modify n' distribute dis documentation for
.\" any purpose n' without fee is hereby granted, provided dat tha above
.\" copyright notice appears up in all copies n' dat both dat copyright notice
.\" n' dis permission notice step tha fuck up in all copies, n' dat tha names of
.\" Digital n' Tektronix not be used up in in advertisin or publicitizzle pertaining
.\" ta dis documentation without specific, freestyled prior permission.
.\" Digital n' Tektronix make no representations bout tha suitability
.\" of dis documentation fo' any purpose.
.\" It be provided ``as is'' without express or implied warranty.
.\" 
.\"
.ds xT X Toolkit Intrinsics \- C Language Interface
.ds xW Athena X Widgets \- C Language X Toolkit Interface
.ds xL Xlib \- C Language X Interface
.ds xC Inter-Client Communication Conventions Manual
.na
.de Ds
.nf
.\\$1D \\$2 \\$1
.ft CW
.\".ps \\n(PS
.\".if \\n(VS>=40 .vs \\n(VSu
.\".if \\n(VS<=39 .vs \\n(VSp
..
.de De
.ce 0
.if \\n(BD .DF
.nr BD 0
.in \\n(OIu
.if \\n(TM .ls 2
.sp \\n(DDu
.fi
..
.de IN		\" bust a index entry ta tha stderr
..
.de Pn
.ie t \\$1\fB\^\\$2\^\fR\\$3
.el \\$1\fI\^\\$2\^\fP\\$3
..
.de ZN
.ie t \fB\^\\$1\^\fR\\$2
.el \fI\^\\$1\^\fP\\$2
..
.de hN
.ie t <\fB\\$1\fR>\\$2
.el <\fI\\$1\fP>\\$2
..
.ny0
'\" t
.TH XCreateGC 3 "libX11 1.6.1" "X Version 11" "XLIB FUNCTIONS"
.SH NAME
XCreateGC, XCopyGC, XChangeGC, XGetGCValues, XFreeGC, XGContextFromGC, XGCValues \- create or free graphics contexts n' graphics context structure
.SH SYNTAX
.HP
GC XCreateGC\^(\^Display *\fIdisplay\fP\^, Drawable \fId\fP\^, unsigned long
\fIvaluemask\fP\^, XGCValues *\^\fIvalues\fP\^); 
.HP
int XCopyGC\^(\^Display *\fIdisplay\fP\^, GC \fIsrc\fP\^,
unsigned long \fIvaluemask\fP\^, GC \fIdest\fP\^); 
.HP
int XChangeGC\^(\^Display *\fIdisplay\fP\^, GC \fIgc\fP\^, unsigned long
\fIvaluemask\fP\^, XGCValues *\^\fIvalues\fP\^); 
.HP
Status XGetGCValues\^(\^Display *\fIdisplay\fP\^, GC \fIgc\fP\^, unsigned long
\fIvaluemask\fP\^, XGCValues *\fIvalues_return\fP\^); 
.HP
int XFreeGC\^(\^Display *\fIdisplay\fP\^, GC \fIgc\fP\^); 
.HP
GContext XGContextFromGC\^(\^GC \fIgc\fP\^); 
.SH ARGUMENTS
.IP \fId\fP 1i
Specifies tha drawable. 
.IP \fIdest\fP 1i
Specifies tha destination GC.
.IP \fIdisplay\fP 1i
Specifies tha connection ta tha X server.
.IP \fIgc\fP 1i
Specifies tha GC.
.IP \fIsrc\fP 1i
Specifies tha componentz of tha source GC.
.ds Vm set, copied, chizzled, or returned 
.IP \fIvaluemask\fP 1i
Specifies which components up in tha GC is ta be \*(Vm. 
This argument is tha bitwise inclusive OR of zero or mo' of tha valid
GC component mask bits.
.IP \fIvalues\fP 1i
Specifies any joints as specified by tha valuemask.
.IP \fIvalues_return\fP 1i
Returns tha GC joints up in tha specified
.ZN XGCValues 
structure.
.SH DESCRIPTION
The
.ZN XCreateGC
function creates a graphics context n' returns a GC.
Da GC can be used wit any destination drawable havin tha same root
and depth as tha specified drawable.
Use wit other drawablez thangs up in dis biatch up in a
.ZN BadMatch
error.
.LP
.ZN XCreateGC
can generate
.ZN BadAlloc ,
.ZN BadDrawable ,
.ZN BadFont ,
.ZN BadMatch ,
.ZN BadPixmap ,
and
.ZN BadValue 
errors.
.LP
The
.ZN XCopyGC
function copies tha specified components from tha source GC
to tha destination GC.
Da source n' destination GCs must have tha same root n' depth,
or a
.ZN BadMatch
error thangs up in dis biatch.
Da valuemask specifies which component ta copy, as for
.ZN XCreateGC .
.LP
.ZN XCopyGC
can generate
.ZN BadAlloc ,
.ZN BadGC ,
and
.ZN BadMatch
errors.
.LP
The
.ZN XChangeGC
function chizzlez tha components specified by valuemask for
the specified GC.
Da joints argument gotz nuff tha joints ta be set.
Da joints n' restrictions is tha same as fo' 
.ZN XCreateGC .
Changin tha clip-mask overrides any previous 
.ZN XSetClipRectangles
request on tha context. 
Changin tha dash-offset or dash-list
overrides any previous 
.ZN XSetDashes
request on tha context.
Da order up in which components is verified n' altered is server dependent.
If a error is generated, a subset of tha components may done been altered.
.LP
.ZN XChangeGC
can generate
.ZN BadAlloc ,
.ZN BadFont ,
.ZN BadGC ,
.ZN BadMatch ,
.ZN BadPixmap ,
and
.ZN BadValue 
errors.
.LP
The
.ZN XGetGCValues
function returns tha components specified by valuemask fo' tha specified GC.
If tha valuemask gotz nuff a valid set of GC mask bits
.Pn ( GCFunction ,
.ZN GCPlaneMask ,
.ZN GCForeground ,
.ZN GCBackground ,
.ZN GCLineWidth ,
.ZN GCLineStyle ,
.ZN GCCapStyle ,
.ZN GCJoinStyle ,
.ZN GCFillStyle ,
.ZN GCFillRule ,
.ZN GCTile ,
.ZN GCStipple ,
.ZN GCTileStipXOrigin ,
.ZN GCTileStipYOrigin ,
.ZN GCFont ,
.ZN GCSubwindowMode ,
.ZN GCGraphicsExposures ,
.ZN GCClipXOrigin ,
.ZN GCCLipYOrigin ,
.ZN GCDashOffset ,
or
.ZN GCArcMode )
and no error occurs,
.ZN XGetGCValues
sets tha axed components up in joints_return n' returns a nonzero status.
Otherwise, it returns a zero status.
Note dat tha clip-mask n' dash-list (represented by the
.ZN GCClipMask
and 
.ZN GCDashList
bits, respectively, up in tha valuemask)
cannot be requested.
Also note dat a invalid resource ID (with one or mo' of tha three
most dope bits set ta 1) is ghon be returned for
.ZN GCFont ,
.ZN GCTile ,
and
.ZN GCStipple
if tha component has never been explicitly set by tha client.
.LP
The
.ZN XFreeGC
function destroys tha specified GC as well as all tha associated storage.
.LP
.ZN XFreeGC
can generate a
.ZN BadGC 
error.
.SH STRUCTURES
The
.ZN XGCValues
structure gotz nuff:
.LP
.LP
/\&* GC attribute value mask bits */
.TS
lw(.5i) lw(2.5i) lw(.75i).
T{
\&#define
T}	T{
.ZN GCFunction
T}	T{
(1L<<0)
T}
T{
\&#define
T}	T{
.ZN GCPlaneMask
T}	T{
(1L<<1)
T}
T{
\&#define
T}	T{
.ZN GCForeground
T}	T{
(1L<<2)
T}
T{
\&#define
T}	T{
.ZN GCBackground
T}	T{
(1L<<3)
T}
T{
\&#define
T}	T{
.ZN GCLineWidth
T}	T{
(1L<<4)
T}
T{
\&#define
T}	T{
.ZN GCLineStyle
T}	T{
(1L<<5)
T}
T{
\&#define
T}	T{
.ZN GCCapStyle
T}	T{
(1L<<6)
T}
T{
\&#define
T}	T{
.ZN GCJoinStyle
T}	T{
(1L<<7)
T}
T{
\&#define
T}	T{
.ZN GCFillStyle
T}	T{
(1L<<8)
T}
T{
\&#define
T}	T{
.ZN GCFillRule
T}	T{
(1L<<9)
T}
T{
\&#define
T}	T{
.ZN GCTile
T}	T{
(1L<<10)
T}
T{
\&#define
T}	T{
.ZN GCStipple
T}	T{
(1L<<11)
T}
T{
\&#define
T}	T{
.ZN GCTileStipXOrigin
T}	T{
(1L<<12)
T}
T{
\&#define
T}	T{
.ZN GCTileStipYOrigin
T}	T{
(1L<<13)
T}
T{
\&#define
T}	T{
.ZN GCFont
T}	T{
(1L<<14)
T}
T{
\&#define
T}	T{
.ZN GCSubwindowMode
T}	T{
(1L<<15)
T}
T{
\&#define
T}	T{
.ZN GCGraphicsExposures
T}	T{
(1L<<16)
T}
T{
\&#define
T}	T{
.ZN GCClipXOrigin
T}	T{
(1L<<17)
T}
T{
\&#define
T}	T{
.ZN GCClipYOrigin
T}	T{
(1L<<18)
T}
T{
\&#define
T}	T{
.ZN GCClipMask
T}	T{
(1L<<19)
T}
T{
\&#define
T}	T{
.ZN GCDashOffset
T}	T{
(1L<<20)
T}
T{
\&#define
T}	T{
.ZN GCDashList
T}	T{
(1L<<21)
T}
T{
\&#define
T}	T{
.ZN GCArcMode
T}	T{
(1L<<22)
T}
.TE
.IN "XGCValues" "" "@DEF@"
.Ds 0
/\&* Values */

typedef struct {
        int function;   /\&* logical operation */
        unsigned long plane_mask;       /\&* plane mask */
        unsigned long foreground;       /\&* foreground pixel */
        unsigned long background;       /\&* background pixel */
        int line_width; /\&* line width (in pixels) */
        int line_style; /\&* LineSolid, LineOnOffDash, LineDoubleDash */
        int cap_style;  /\&* CapNotLast, CapButt, CapRound, CapProjectin */
        int join_style; /\&* JoinMiter, JoinRound, JoinBevel */
        int fill_style; /\&* FillSolid, FillTiled, FillStippled FillOpaqueStippled*/
        int fill_rule;  /\&* EvenOddRule, WindingRule */
        int arc_mode;   /\&* ArcChord, ArcPieSlice */
        Pixmap tile;    /\&* tile pixmap fo' tilin operations */
        Pixmap stipple; /\&* stipple 1 plane pixmap fo' stipplin */
        int ts_x_origin;        /\&* offset fo' tile or stipple operations */
        int ts_y_origin;
        Font font;      /\&* default text font fo' text operations */
        int subwindow_mode;     /\&* ClipByChildren, IncludeInferiors */
        Bool graphics_exposures;        /\&* boolean, should exposures be generated */
        int clip_x_origin;      /\&* origin fo' clippin */
        int clip_y_origin;
        Pixmap clip_mask;       /\&* bitmap clipping; other calls fo' rects */
        int dash_offset;        /\&* patterned/dashed line shiznit */
        char dashes;
} XGCValues;
.De
.LP
Da function attributez of a GC is used when you update a section of
a drawable (the destination) wit bits from somewhere else (the source).  
Da function up in a GC defines how tha fuck tha freshly smoked up destination bits is ta be
computed from tha source bits n' tha oldschool destination bits.
.ZN GXcopy
is typically da most thugged-out useful cuz it will work on a cold-ass lil color display,
but special applications may use other functions,
particularly up in gangbang wit particular planez of a cold-ass lil color display.
Da 16 GC functions, defined up in 
.hN X11/X.h ,
are:
.\" is listed up in Table 5-1 along wit tha 
.\"the associated hexadecimal code
.\" n' operation.
.\".CP T 1
.\"Display Functions
.TS
lw(1.5i) cw(.5i) lw(2i).
_
.sp 6p
.B
Function Name	Value	Operation
.sp 6p
_
.sp 6p
T{
.ZN GXclear
T}	T{
0x0
T}	T{
0
T}
T{
.ZN GXand
T}	T{
0x1
T}	T{
src AND dst
T}
T{
.ZN GXandReverse
T}	T{
0x2
T}	T{
src AND NOT dst
T}
T{
.ZN GXcopy
T}	T{
0x3
T}	T{
src
T}
T{
.ZN GXandInverted
T}	T{
0x4
T}	T{
(NOT src) AND dst
T}
T{
.ZN GXnoop
T}	T{
0x5
T}	T{
dst
T}
T{
.ZN GXxor
T}	T{
0x6
T}	T{
src XOR dst
T}
T{
.ZN GXor
T}	T{
0x7
T}	T{
src OR dst
T}
T{
.ZN GXnor
T}	T{
0x8
T}	T{
(NOT src) AND (NOT dst)
T}
T{
.ZN GXequiv
T}	T{
0x9
T}	T{
(NOT src) XOR dst
T}
T{
.ZN GXinvert
T}	T{
0xa
T}	T{
NOT dst
T}
T{
.ZN GXorReverse
T}	T{
0xb
T}	T{
src OR (NOT dst)
T}
T{
.ZN GXcopyInverted
T}	T{
0xc
T}	T{
NOT src
T}
T{
.ZN GXorInverted
T}	T{
0xd
T}	T{
(NOT src) OR dst
T}
T{
.ZN GXnand
T}	T{
0xe
T}	T{
(NOT src) OR (NOT dst)
T}
T{
.ZN GXset
T}	T{
0xf
T}	T{
1
T}
.sp 6p
_
.TE
.LP
Many graphics operations depend on either pixel joints or planes up in a GC.
.IN "Pixel value"
Da planes attribute iz of type long, n' it specifies which planez of the
destination is ta be modified, one bit per plane.
.IN "Plane" "mask"
A monochrome display has only one plane and
will be tha least dope bit of tha word.
As planes is added ta tha display hardware, they will occupy more
significant bits up in tha plane mask.
.LP
In graphics operations, given a source n' destination pixel, 
the result is computed bitwise on correspondin bitz of tha pixels.
That is, a Boolean operation is performed up in each bit plane.  
Da plane_mask restricts tha operation ta a subset of planes.
A macro constant
.ZN AllPlanes
can be used ta refer ta all planez of tha screen simultaneously.
Da result is computed by tha following:
.LP
.Ds 
((src FUNC dst) AND plane-mask) OR (dst AND (NOT plane-mask))
.De
.LP
Range checkin aint performed on tha joints fo' foreground,
background, or plane_mask.
They is simply truncated ta tha appropriate
number of bits.
Da line-width is measured up in pixels n' either can be pimped outa than or equal to
one (wide line) or can be tha special value zero (thin line).
.LP
Wide lines is drawn centered on tha path busted lyrics bout by tha graphics request.
Unless otherwise specified by tha join-style or cap-style,
the boundin box of a wide line wit endpoints [x1, y1], [x2, y2] and
width w be a rectangle wit vertices all up in tha followin real coordinates:
.LP
.Ds
[x1-(w*sn/2), y1+(w*cs/2)], [x1+(w*sn/2), y1-(w*cs/2)],
[x2-(w*sn/2), y2+(w*cs/2)], [x2+(w*sn/2), y2-(w*cs/2)]
.De
.LP
Here sn is tha sine of tha angle of tha line,
and cs is tha cosine of tha angle of tha line.
A pixel is part of tha line n' so is drawn
if tha centa of tha pixel is straight-up inside tha boundin box
(which is viewed as havin infinitely thin edges).
If tha centa of tha pixel is exactly on tha boundin box,
it is part of tha line if n' only if tha interior is immediately ta its right
(x increasin direction).
Pixels wit centas on a horizontal edge is a special case n' is part of
the line if n' only if tha interior or tha boundary is immediately below 
(y increasin direction) n' tha interior or tha boundary is immediately
to tha right (x increasin direction).
.LP
Thin lines (zero line-width) is one-pixel-wide lines drawn rockin an
unspecified, device-dependent algorithm.
There is only two constraints on dis algorithm. 
.IP 1. 5
If a line is drawn unclipped from [x1,y1] ta [x2,y2] and
if another line is drawn unclipped from [x1+dx,y1+dy] ta [x2+dx,y2+dy],
a point [x,y] is touched by drawin tha straight-up original gangsta line 
if n' only if tha point [x+dx,y+dy] is touched by drawin tha second line.
.IP 2. 5
Da effectizzle set of points comprisin a line cannot be affected by clipping.
That is, a point is touched up in a cold-ass lil clipped line if n' only if tha point 
lies inside tha clippin region n' tha point would be touched
by tha line when drawn unclipped.
.LP
A wide line drawn from [x1,y1] ta [x2,y2] always draws tha same ol' dirty pixels 
as a wide line drawn from [x2,y2] ta [x1,y1], not countin cap-style 
and join-style.
It be recommended dat dis property be legit fo' thin lines, 
but dis aint required.
A line-width of zero may differ from a line-width of one up in which pixels are
drawn.
This permits tha use of nuff manufacturers' line drawin hardware,
which may run nuff times fasta than tha mo' precisely specified
wide lines.
.LP
In general, 
drawin a thin line is ghon be fasta than drawin a wide line of width one.
But fuck dat shiznit yo, tha word on tha street is dat cuz of they different drawin algorithms,
thin lines may not mix well aesthetically wit wide lines.
If it is desirable ta obtain precise n' uniform thangs up in dis biatch across all displays,
a client should always bust a line-width of one rather than a line-width of zero.
.LP
Da line-style defines which sectionz of a line is drawn:
.TS
lw(1.3i) lw(4.5i).
T{
.ZN LineSolid
T}	T{
Da full path of tha line is drawn.
T}
.sp 6p
T{
.ZN LineDoubleDash
T}	T{
Da full path of tha line is drawn, 
but tha even dashes is filled differently 
from tha odd dashes (see fill-style) with
.ZN CapButt 
style used where even n' odd dashes meet.
T}
.sp 6p
T{
.ZN LineOnOffDash
T}	T{
Only tha even dashes is drawn,
and cap-style applies ta 
all internal endz of tha individual dashes,
except 
.ZN CapNotLast
is treated as 
.ZN CapButt . 
T}
.TE
.LP
Da cap-style defines how tha fuck tha endpointz of a path is drawn:
.IN "Graphics context" "path"
.TS
lw(1.3i) lw(4.5i).
T{
.ZN CapNotLast
T}	T{
This is equivalent ta 
.ZN CapButt  
except dat fo' a line-width of zero tha final endpoint aint drawn.
T}
.sp 6p
T{
.ZN CapButt
T}	T{
Da line is square all up in tha endpoint (perpendicular ta tha slope of tha line)
with no projection beyond.
T}
.sp 6p
T{
.ZN CapRound
T}	T{
Da line has a cold-ass lil circular arc wit tha diameta equal ta tha line-width,
centered on tha endpoint.
(This is equivalent ta 
.ZN CapButt 
for line-width of zero).
T}
.sp 6p
T{
.ZN CapProjecting
T}	T{
Da line is square all up in tha end yo, but tha path continues beyond tha endpoint 
for a gangbangin' finger-lickin' distizzle equal ta half tha line-width.
(This is equivalent ta 
.ZN CapButt 
for line-width of zero).
T}
.TE
.LP
Da join-style defines how tha fuck corners is drawn fo' wide lines:
.TS
lw(1.3i) lw(4.5i).
T{
.ZN JoinMiter
T}	T{
Da outa edgez of two lines extend ta hook up at a angle.
But fuck dat shiznit yo, tha word on tha street is dat if tha angle is less than 11 degrees,
then a
.ZN JoinBevel
join-style is used instead.
T}
.sp 6p
T{
.ZN JoinRound
T}	T{
Da corner be a cold-ass lil circular arc wit tha diameta equal ta tha line-width, 
centered on tha joinpoint.
T}
.sp 6p
T{
.ZN JoinBevel
T}	T{
Da corner has
.ZN CapButt 
endpoint stylez wit tha triangular notch filled.
T}
.TE
.LP
For a line wit coincident endpoints (x1=x2, y1=y2), 
when tha cap-style be applied ta both endpoints, 
the semantics dependz on tha line-width n' tha cap-style:
.TS
lw(1.3i) lw(.5i) lw(4i).
T{
.ZN CapNotLast
T}	T{
thin
T}	T{
Da thangs up in dis biatch is thang dependent, 
but tha desired effect is dat not a god damn thang is drawn.
T}
.sp 6p
T{
.ZN CapButt
T}	T{
thin
T}	T{
Da thangs up in dis biatch is thang dependent, 
but tha desired effect is dat a single pixel is drawn.
T}
.sp 6p
T{
.ZN CapRound
T}	T{
thin
T}	T{
Da thangs up in dis biatch is tha same as for
.ZN CapButt /thin.
T}
.sp 6p
T{
.ZN CapProjecting
T}	T{
thin
T}	T{
Da thangs up in dis biatch is tha same as for
.ZN CapButt /thin.
T}
.sp 6p
T{
.ZN CapButt
T}	T{
wide
T}	T{
Nothang is drawn.
T}
.sp 6p
T{
.ZN CapRound
T}	T{
wide
T}	T{
Da closed path be a cold-ass lil circle, centered all up in tha endpoint, and
with tha diameta equal ta tha line-width.
T}
.sp 6p
T{
.ZN CapProjecting
T}	T{
wide
T}	T{
Da closed path be a square, aligned wit tha coordinizzle axes, centered at the
endpoint, n' wit tha sides equal ta tha line-width.
T}
.TE
.LP
For a line wit coincident endpoints (x1=x2, y1=y2), 
when tha join-style be applied at one or both endpoints, 
the effect be as if tha line was removed from tha overall path.
But fuck dat shiznit yo, tha word on tha street is dat if tha total path consistz of or is reduced ta a single point joined
with itself, tha effect is tha same ol' dirty as when tha cap-style be applied at both
endpoints.
.LP
Da tile/stipple represents a infinite two-dimensionizzle plane,
with tha tile/stipple replicated up in all dimensions.
When dat plane is superimposed on tha drawable
for use up in a graphics operation, tha upper-left corner
of some instizzle of tha tile/stipple be all up in tha coordinates within
the drawable specified by tha tile/stipple origin.
Da tile/stipple n' clip origins is interpreted relatizzle ta the
origin of whatever destination drawable is specified up in a graphics
request.
Da tile pixmap must have tha same root n' depth as tha GC,
or a
.ZN BadMatch 
error thangs up in dis biatch.
Da stipple pixmap must have depth one n' must have tha same root as the
GC, or a 
.ZN BadMatch 
error thangs up in dis biatch.  
For stipple operations where tha fill-style is
.ZN FillStippled
but not 
.ZN FillOpaqueStippled ,
the stipple pattern is tiled up in a
single plane n' acts as a additionizzle clip mask ta be ANDed wit tha clip-mask.
Although some sizes may be fasta ta use than others,
any size pixmap can be used fo' tilin or stippling.
.LP
Da fill-style defines tha contentz of tha source fo' line, text, and
fill requests, n' you can put dat on yo' toast.  
For all text n' fill requests (for example,
.ZN XDrawText , 
.ZN XDrawText16 ,
.ZN XFillRectangle , 
.ZN XFillPolygon , 
and
.ZN XFillArc );
for line requests 
with line-style 
.ZN LineSolid 
(for example,
.ZN XDrawLine ,
.ZN XDrawSegments , 
.ZN XDrawRectangle ,
.ZN XDrawArc );
and fo' tha even dashes fo' line requests wit line-style 
.ZN LineOnOffDash 
or 
.ZN LineDoubleDash ,
the followin apply:
.TS
lw(1.8i) lw(4i).
T{
.ZN FillSolid
T}	T{
Foreground
T}
.sp 6p
T{
.ZN FillTiled
T}	T{
Tile
T}
.sp 6p
T{
.ZN FillOpaqueStippled
T}	T{
A tile wit tha same width n' height as stipple,
but wit background everywhere stipple has a zero
and wit foreground everywhere stipple has a one
T}
.sp 6p
T{
.ZN FillStippled
T}	T{
Foreground maxed by stipple
T}
.TE
.LP
When drawin lines wit line-style
.ZN LineDoubleDash ,
the odd dashes is controlled by tha fill-style up in tha followin manner:
.TS
lw(1.8i) lw(4i).
T{
.ZN FillSolid
T}	T{
Background
T}
.sp 6p
T{
.ZN FillTiled
T}	T{
Same as fo' even dashes
T}
.sp 6p
T{
.ZN FillOpaqueStippled
T}	T{
Same as fo' even dashes
T}
.sp 6p
T{
.ZN FillStippled
T}	T{
Background maxed by stipple
T}
.TE
.LP
Storin a pixmap up in a GC might or might not result up in a cold-ass lil copy
bein made.
If tha pixmap is lata used as tha destination fo' a graphics request,
the chizzle might or might not be reflected up in tha GC.
If tha pixmap is used simultaneously up in a graphics request both as
a destination n' as a tile or stipple,
the thangs up in dis biatch is undefined.
.LP
For optimum performance,
you should draw as much as possible wit tha same GC 
(without changin its components).
Da costz of changin GC components relatizzle ta rockin different GCs
depend on tha display hardware n' tha server implementation.
It be like likely dat some amount of GC shiznit will be
cached up in display hardware n' dat such hardware can only cache a lil' small-ass number
of GCs.
.LP
Da dashes value is straight-up a simplified form of the
more general patterns dat can be set wit 
.ZN XSetDashes .  
Specifyin a
value of N is equivalent ta specifyin tha two-element list [N, N] up in 
.ZN XSetDashes . 
Da value must be nonzero,
or a
.ZN BadValue
error thangs up in dis biatch.
.LP
Da clip-mask restricts writes ta tha destination drawable.  
If tha clip-mask is set ta a pixmap,
it must have depth one n' have tha same root as tha GC,
or a
.ZN BadMatch 
error thangs up in dis biatch.
If clip-mask is set to
.ZN None ,
the pixels is always drawn regardless of tha clip origin.
Da clip-mask also can be set by callin the
.ZN XSetClipRectangles
or
.ZN XSetRegion
functions.
Only pixels where tha clip-mask has a lil' bit set ta 1 is drawn. I aint talkin' bout chicken n' gravy biatch.  
Pixels is not drawn outside tha area covered by tha clip-mask 
or where tha clip-mask has a lil' bit set ta 0.
Da clip-mask affects all graphics requests.
Da clip-mask do not clip sources.
Da clip-mask origin is interpreted relatizzle ta tha origin of whatever
destination drawable is specified up in a graphics request.
.LP
Yo ass can set tha subwindow-mode to
.ZN ClipByChildren
or
.ZN IncludeInferiors .
For 
.ZN ClipByLil Pimps , 
both source n' destination windows are
additionally clipped by all viewable 
.ZN InputOutput
children. I aint talkin' bout chicken n' gravy biatch.  
For 
.ZN IncludeInferiors ,
neither source nor destination window is clipped by inferiors. 
This will result up in includin subwindow contents up in tha source
and drawin all up in subwindow boundariez of tha destination.
Da use of 
.ZN IncludeInferiors 
on a window of one depth wit mapped
inferiorz of differin depth aint illegal yo, but tha semantics are
undefined by tha core protocol.
.LP
Da fill-rule defines what tha fuck pixels is inside (drawn) for
paths given up in 
.ZN XFillPolygon 
requests n' can be set ta 
.ZN EvenOddRule 
or
.ZN WindingRule .
For
.ZN EvenOddRule ,
a point is inside if
an infinite ray wit tha point as origin crosses tha path a odd number
of times.  
For 
.ZN WindingRule , 
a point is inside if a infinite ray wit the
point as origin crosses a unequal number of clockwise and
counterclockwise pimped up path segments.
A clockwise pimped up path segment is one dat crosses tha ray from left to
right as observed from tha point.
A counterclockwise segment is one dat crosses tha ray from right ta left
as observed from tha point.
Da case where a gangbangin' finger-lickin' pimped up line segment is coincident wit tha ray is
uninterestin cuz you can simply chizzle a gangbangin' finger-lickin' different ray dat is not
coincident wit a segment.
.LP
For both 
.ZN EvenOddRule
and
.ZN WindingRule ,
a point is infinitely small, 
and tha path be a infinitely thin line.  
A pixel is inside if tha centa point of tha pixel is inside
and tha centa point aint on tha boundary.  
If tha centa point is on tha boundary,
the pixel is inside if n' only if tha polygon interior is immediately to
its right (x increasin direction).  
Pixels wit centas on a horizontal edge is a special case 
and is inside if n' only if tha polygon interior is immediately below 
(y increasin direction).
.LP
Da arc-mode controls fillin up in tha 
.ZN XFillArcs
function n' can be set to
.ZN ArcPieSlice
or
.ZN ArcChord .
For
.ZN ArcPieSlice ,
the arcs is pie-slice filled.
For
.ZN ArcChord ,
the arcs is chord filled.
.LP
Da graphics-exposure flag controls 
.ZN GraphicsExpose 
event generation
for 
.ZN XCopyArea 
and 
.ZN XCopyPlane
requests (and any similar requests defined by extensions).
.SH DIAGNOSTICS
.TP 1i
.ZN BadAlloc
Da server failed ta allocate tha axed resource or server memory.
.TP 1i
.ZN BadDrawable
A value fo' a Drawable argument do not name a thugged-out defined Window or Pixmap.
.TP 1i
.ZN BadFont
A value fo' a Font or GContext argument do not name a thugged-out defined Font.
.TP 1i
.ZN BadGC
A value fo' a GContext argument do not name a thugged-out defined GContext.
.TP 1i
.ZN BadMatch
An
.ZN InputOnly
window is used as a Drawable.
.TP 1i
.ZN BadMatch
Some argument or pair of arguments has tha erect type n' range but fails
to match up in some other way required by tha request.
.TP 1i
.ZN BadPixmap
A value fo' a Pixmap argument do not name a thugged-out defined Pixmap.
.TP 1i
.ZN BadValue
Some numeric value falls outside tha range of joints accepted by tha request.
Unless a specific range is specified fo' a argument, tha full range defined
by tha argumentz type be accepted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Any argument defined as a set of
alternatives can generate dis error.
.SH "SEE ALSO"
AllPlanes(3),
XCopyArea(3),
XCreateRegion(3),
XDrawArc(3),
XDrawLine(3),
XDrawRectangle(3),
XDrawText(3),
XFillRectangle(3),
XQueryBestSize(3),
XSetArcMode(3),
XSetClipOrigin(3),
XSetFillStyle(3),
XSetFont(3),
XSetLineAttributes(3),
XSetState(3),
XSetTile(3)
.br
\fI\*(xL\fP
