.TH "__gnu_debug::_Safe_iterator_base" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_debug::_Safe_iterator_base \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherited by \fB__gnu_debug::_Safe_iterator< _Iterator, _Sequence >\fP, n' \fB__gnu_debug::_Safe_local_iterator_base\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_attach\fP (\fB_Safe_sequence_base\fP *__seq, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (\fB_Safe_sequence_base\fP *__seq, bool __constant)  throw ()"
.br
.ti -1c
.RI "bool \fB_M_attached_to\fP (const \fB_Safe_sequence_base\fP *__seq) const "
.br
.ti -1c
.RI "bool \fB_M_can_compare\fP (const \fB_Safe_iterator_base\fP &__x) const   throw ()"
.br
.ti -1c
.RI "void \fB_M_detach\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_single\fP ()  throw ()"
.br
.ti -1c
.RI "void \fB_M_invalidate\fP ()"
.br
.ti -1c
.RI "void \fB_M_reset\fP ()  throw ()"
.br
.ti -1c
.RI "bool \fB_M_singular\fP () const   throw ()"
.br
.ti -1c
.RI "void \fB_M_unlink\fP ()  throw ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_next\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_prior\fP"
.br
.ti -1c
.RI "\fB_Safe_sequence_base\fP * \fB_M_sequence\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator_base\fP ()"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP (const \fB_Safe_sequence_base\fP *__seq, bool __constant)"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP (const \fB_Safe_iterator_base\fP &__x, bool __constant)"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP (const \fB_Safe_iterator_base\fP &)"
.br
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()  throw ()"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP & \fBoperator=\fP (const \fB_Safe_iterator_base\fP &)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Basic functionalitizzle fo' a \fIsafe\fP iterator\&. 

Da _Safe_iterator_base base class implements tha functionalitizzle of a safe iterator dat aint specific ta a particular iterator type\&. Well shiiiit, it gotz nuff a pointa back ta tha sequence it references along wit iterator version shiznit n' pointas ta form a thugged-out doubly-linked list of iterators referenced by tha container\&.
.PP
This class must not big-ass up any operations dat can throw a exception, or tha exception guaranteez of derived iterators is ghon be broken\&. 
.PP
Definizzle at line 50 of file safe_base\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "__gnu_debug::_Safe_iterator_base::_Safe_iterator_base ()\fC [inline]\fP, \fC [protected]\fP"
Initializes tha iterator n' make it singular\&. 
.PP
Definizzle at line 76 of file safe_base\&.h\&.
.SS "__gnu_debug::_Safe_iterator_base::_Safe_iterator_base (const \fB_Safe_sequence_base\fP *__seq, bool__constant)\fC [inline]\fP, \fC [protected]\fP"
Initialize tha iterator ta reference tha sequence pointed ta by \fC__seq\fP\&. \fC__constant\fP is legit when we is initializin a cold-ass lil constant iterator, n' false if it aint nuthin but a mutable iterator\&. Note dat \fC__seq\fP may be NULL, up in which case tha iterator is ghon be singular\&. Otherwise, tha iterator will reference \fC__seq\fP n' be nonsingular\&. 
.PP
Definizzle at line 87 of file safe_base\&.h\&.
.PP
References _M_attach()\&.
.SS "__gnu_debug::_Safe_iterator_base::_Safe_iterator_base (const \fB_Safe_iterator_base\fP &__x, bool__constant)\fC [inline]\fP, \fC [protected]\fP"
Initializes tha iterator ta reference tha same sequence dat \fC__x\fP do\&. \fC__constant\fP is legit if dis be a cold-ass lil constant iterator, n' false if it is mutable\&. 
.PP
Definizzle at line 94 of file safe_base\&.h\&.
.PP
References _M_attach(), n' _M_sequence\&.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_iterator_base::_M_attach (\fB_Safe_sequence_base\fP *__seq, bool__constant)"
Attaches dis iterator ta tha given sequence, detachin it from whatever sequence dat shiznit was attached ta originally\&. If tha freshly smoked up sequence is tha NULL pointer, tha iterator is left unattached\&. 
.PP
Referenced by __gnu_debug::_Safe_local_iterator< _Iterator, _Sequence >::_M_attach(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_attach(), n' _Safe_iterator_base()\&.
.SS "void __gnu_debug::_Safe_iterator_base::_M_attach_single (\fB_Safe_sequence_base\fP *__seq, bool__constant)"
Likewise yo, but not thread-safe\&. 
.PP
Referenced by __gnu_debug::_Safe_local_iterator< _Iterator, _Sequence >::_M_attach_single(), n' __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_attach_single()\&.
.SS "bool __gnu_debug::_Safe_iterator_base::_M_attached_to (const \fB_Safe_sequence_base\fP *__seq) const\fC [inline]\fP"
Determines if we is attached ta tha given sequence\&. 
.PP
Definizzle at line 129 of file safe_base\&.h\&.
.PP
References _M_sequence\&.
.SS "bool __gnu_debug::_Safe_iterator_base::_M_can_compare (const \fB_Safe_iterator_base\fP &__x) const"
Can we compare dis iterator ta tha given iterator \fC__x\fP? Returns legit if both iterators is nonsingular n' reference tha same sequence\&. 
.SS "void __gnu_debug::_Safe_iterator_base::_M_detach ()"
Detach tha iterator fo' whatever sequence it be attached to, if any\&. 
.SS "void __gnu_debug::_Safe_iterator_base::_M_detach_single ()"
Likewise yo, but not thread-safe\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_iterator_base::_M_get_mutex ()\fC [protected]\fP"
For use up in _Safe_iterator\&. 
.SS "void __gnu_debug::_Safe_iterator_base::_M_invalidate ()\fC [inline]\fP"
Invalidate tha iterator, makin it singular\&. 
.PP
Definizzle at line 142 of file safe_base\&.h\&.
.PP
References _M_version\&.
.SS "void __gnu_debug::_Safe_iterator_base::_M_reset ()"
Reset all member variablez 
.SS "bool __gnu_debug::_Safe_iterator_base::_M_singular () const"
Is dis iterator singular? 
.PP
Referenced by __gnu_debug::__check_singular(), __gnu_debug::__check_singular_aux(), __gnu_debug::_Safe_local_iterator< _Iterator, _Sequence >::_M_dereferenceable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable(), __gnu_debug::_Safe_local_iterator< _Iterator, _Sequence >::_M_incrementable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_incrementable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_Safe_iterator(), n' __gnu_debug::_Safe_local_iterator< _Iterator, _Sequence >::_Safe_local_iterator()\&.
.SS "void __gnu_debug::_Safe_iterator_base::_M_unlink ()\fC [inline]\fP"
Unlink itself 
.PP
Definizzle at line 151 of file safe_base\&.h\&.
.PP
References _M_next, n' _M_prior\&.
.SH "Member Data Documentation"
.PP 
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_iterator_base::_M_next"
Pointa ta tha next iterator up in tha sequencez list of iterators\&. Only valid when _M_sequence != NULL\&. 
.PP
Definizzle at line 72 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if(), n' _M_unlink()\&.
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_iterator_base::_M_prior"
Pointa ta tha previous iterator up in tha sequencez list of iterators\&. Only valid when _M_sequence != NULL\&. 
.PP
Definizzle at line 68 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if(), n' _M_unlink()\&.
.SS "\fB_Safe_sequence_base\fP* __gnu_debug::_Safe_iterator_base::_M_sequence"
Da sequence dis iterator references; may be NULL ta indicate a singular iterator\&. 
.PP
Definizzle at line 55 of file safe_base\&.h\&.
.PP
Referenced by _M_attached_to(), __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if(), _Safe_iterator_base(), n' __gnu_debug::_Safe_local_iterator_base::_Safe_local_iterator_base()\&.
.SS "unsigned int __gnu_debug::_Safe_iterator_base::_M_version"
Da version number of dis iterator\&. Da sentinel value 0 is used ta indicate a invalidated iterator (i\&.e\&., one dat is singular cuz of a operation on tha container)\&. This version number must equal tha version number up in tha sequence referenced by _M_sequence fo' tha iterator ta be non-singular\&. 
.PP
Definizzle at line 64 of file safe_base\&.h\&.
.PP
Referenced by _M_invalidate()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
