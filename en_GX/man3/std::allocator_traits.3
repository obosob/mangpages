" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::allocator_traits< _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherited by \fB__gnu_cxx::__alloc_traits< _Alloc >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef __const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef __const_void_pointa \fBconst_void_pointer\fP"
.br
.ti -1c
.RI "typedef __difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef __pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef 
.br
__propagate_on_container_copy_assignment \fBpropagate_on_container_copy_assignment\fP"
.br
.ti -1c
.RI "typedef 
.br
__propagate_on_container_move_assignment \fBpropagate_on_container_move_assignment\fP"
.br
.ti -1c
.RI "typedef 
.br
__propagate_on_container_swap \fBpropagate_on_container_swap\fP"
.br
.ti -1c
.RI "template<typename _Tp > rockin \fBrebind_alloc\fP = typename __alloctr_rebind< _Alloc, _Tp >::__type"
.br
.ti -1c
.RI "template<typename _Tp > rockin \fBrebind_traits\fP = \fBallocator_traits\fP< rebind_alloc< _Tp >>"
.br
.ti -1c
.RI "typedef __size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Alloc::value_type \fBvalue_type\fP"
.br
.ti -1c
.RI "typedef __void_pointa \fBvoid_pointer\fP"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBpointer\fP \fBallocate\fP (_Alloc &__a, \fBsize_type\fP __n)"
.br
.ti -1c
.RI "static \fBpointer\fP \fBallocate\fP (_Alloc &__a, \fBsize_type\fP __n, \fBconst_void_pointer\fP __hint)"
.br
.ti -1c
.RI "template<typename _Tp , typename\&.\&.\&. _Args> static auto \fBconstruct\fP (_Alloc &__a, _Tp *__p, _Args &&\&.\&.\&.__args) -> decltype(_S_construct(__a, __p, \fBstd::forward\fP< _Args >(__args)\&.\&.\&.))"
.br
.ti -1c
.RI "static void \fBdeallocate\fP (_Alloc &__a, \fBpointer\fP __p, \fBsize_type\fP __n)"
.br
.ti -1c
.RI "template<class _Tp > static void \fBdestroy\fP (_Alloc &__a, _Tp *__p)"
.br
.ti -1c
.RI "static \fBsize_type\fP \fBmax_size\fP (const _Alloc &__a)"
.br
.ti -1c
.RI "static _Alloc \fBselect_on_container_copy_construction\fP (const _Alloc &__rhs)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Alloc>struct std::allocator_traits< _Alloc >"
Uniform intercourse ta all allocator types\&. 
.PP
Definizzle at line 85 of file bits/alloc_traits\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename _Alloc> typedef _Alloc \fBstd::allocator_traits\fP< _Alloc >::\fBallocator_type\fP"

.PP
Da allocator type\&. 
.PP
Definizzle at line 88 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef __const_pointa \fBstd::allocator_traits\fP< _Alloc >::\fBconst_pointer\fP"

.PP
Da allocatorz const pointa type\&. \fCAlloc::const_pointer\fP if dat type exists, otherwise \fC pointer_traits<pointer>::rebind<const value_type> \fP 
.PP
Definizzle at line 118 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef __const_void_pointa \fBstd::allocator_traits\fP< _Alloc >::\fBconst_void_pointer\fP"

.PP
Da allocatorz const void pointa type\&. \fCAlloc::const_void_pointer\fP if dat type exists, otherwise \fC pointer_traits<pointer>::rebind<const void> \fP 
.PP
Definizzle at line 140 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef __difference_type \fBstd::allocator_traits\fP< _Alloc >::\fBdifference_type\fP"

.PP
Da allocatorz difference type\&. \fCAlloc::difference_type\fP if dat type exists, otherwise \fC pointer_traits<pointer>::difference_type \fP 
.PP
Definizzle at line 151 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef __pointa \fBstd::allocator_traits\fP< _Alloc >::\fBpointer\fP"

.PP
Da allocatorz pointa type\&. \fCAlloc::pointer\fP if dat type exists, otherwise \fCvalue_type*\fP 
.PP
Definizzle at line 107 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef __propagate_on_container_copy_assignment \fBstd::allocator_traits\fP< _Alloc >::\fBpropagate_on_container_copy_assignment\fP"

.PP
How tha fuck tha allocator is propagated on copy assignment\&. \fCAlloc::propagate_on_container_copy_assignment\fP if dat type exists, otherwise \fCfalse_type\fP 
.PP
Definizzle at line 174 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef __propagate_on_container_move_assignment \fBstd::allocator_traits\fP< _Alloc >::\fBpropagate_on_container_move_assignment\fP"

.PP
How tha fuck tha allocator is propagated on move assignment\&. \fCAlloc::propagate_on_container_move_assignment\fP if dat type exists, otherwise \fCfalse_type\fP 
.PP
Definizzle at line 186 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef __propagate_on_container_swap \fBstd::allocator_traits\fP< _Alloc >::\fBpropagate_on_container_swap\fP"

.PP
How tha fuck tha allocator is propagated on swap\&. \fCAlloc::propagate_on_container_swap\fP if dat type exists, otherwise \fCfalse_type\fP 
.PP
Definizzle at line 197 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef __size_type \fBstd::allocator_traits\fP< _Alloc >::\fBsize_type\fP"

.PP
Da allocatorz size type\&. \fCAlloc::size_type\fP if dat type exists, otherwise \fC make_unsigned<difference_type>::type \fP 
.PP
Definizzle at line 162 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef _Alloc::value_type \fBstd::allocator_traits\fP< _Alloc >::\fBvalue_type\fP"

.PP
Da allocated type\&. 
.PP
Definizzle at line 90 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef __void_pointa \fBstd::allocator_traits\fP< _Alloc >::\fBvoid_pointer\fP"

.PP
Da allocatorz void pointa type\&. \fCAlloc::void_pointer\fP if dat type exists, otherwise \fC pointer_traits<pointer>::rebind<void> \fP 
.PP
Definizzle at line 129 of file bits/alloc_traits\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Alloc> static \fBpointer\fP \fBstd::allocator_traits\fP< _Alloc >::allocate (_Alloc &__a, \fBsize_type\fP__n)\fC [inline]\fP, \fC [static]\fP"

.PP
Allocate memory\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator\&. 
.br
\fI__n\fP Da number of objects ta allocate space for\&.
.RE
.PP
Calls \fCa\&.allocate(n)\fP 
.PP
Definizzle at line 350 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> static \fBpointer\fP \fBstd::allocator_traits\fP< _Alloc >::allocate (_Alloc &__a, \fBsize_type\fP__n, \fBconst_void_pointer\fP__hint)\fC [inline]\fP, \fC [static]\fP"

.PP
Allocate memory\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator\&. 
.br
\fI__n\fP Da number of objects ta allocate space for\&. 
.br
\fI__hint\fP Aid ta locality\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Memory of suitable size n' alignment fo' \fIn\fP objectz of type \fCvalue_type\fP 
.RE
.PP
Returns \fC a\&.allocate(n, hint) \fP if dat expression is well-formed, otherwise returns \fCa\&.allocate(n)\fP 
.PP
Definizzle at line 365 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> template<typename _Tp , typename\&.\&.\&. _Args> static auto \fBstd::allocator_traits\fP< _Alloc >::construct (_Alloc &__a, _Tp *__p, _Args &&\&.\&.\&.__args) -> decltype(_S_construct(__a, __p, \fBstd::forward\fP<_Args>(__args)\&.\&.\&.))
	\fC [inline]\fP, \fC [static]\fP"

.PP
Construct a object of type \fI_Tp\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator\&. 
.br
\fI__p\fP Pointa ta memory of suitable size n' alignment fo' Tp 
.br
\fI__args\fP Constructor arguments\&.
.RE
.PP
Calls \fC __a\&.construct(__p, std::forward<Args>(__args)\&.\&.\&.) \fP if dat expression is well-formed, otherwise uses placement-new ta construct a object of type \fI_Tp\fP at location \fI__p\fP from tha arguments \fI__args\fP\&.\&.\&. 
.PP
Definizzle at line 391 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> static void \fBstd::allocator_traits\fP< _Alloc >::deallocate (_Alloc &__a, \fBpointer\fP__p, \fBsize_type\fP__n)\fC [inline]\fP, \fC [static]\fP"

.PP
Deallocate memory\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator\&. 
.br
\fI__p\fP Pointa ta tha memory ta deallocate\&. 
.br
\fI__n\fP Da number of objects space was allocated for\&.
.RE
.PP
Calls \fC a\&.deallocate(p, n) \fP 
.PP
Definizzle at line 376 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> template<class _Tp > static void \fBstd::allocator_traits\fP< _Alloc >::destroy (_Alloc &__a, _Tp *__p)\fC [inline]\fP, \fC [static]\fP"

.PP
Destroy a object of type \fI_Tp\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator\&. 
.br
\fI__p\fP Pointa ta tha object ta destroy
.RE
.PP
Calls \fC__a\&.destroy(__p)\fP if dat expression is well-formed, otherwise calls \fC__p->~_Tp()\fP 
.PP
Definizzle at line 404 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> static \fBsize_type\fP \fBstd::allocator_traits\fP< _Alloc >::max_size (const _Alloc &__a)\fC [inline]\fP, \fC [static]\fP"

.PP
Da maximum supported allocation size\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fC__a\&.max_size()\fP or \fCnumeric_limits<size_type>::max()\fP 
.RE
.PP
Returns \fC__a\&.max_size()\fP if dat expression is well-formed, otherwise returns \fCnumeric_limits<size_type>::max()\fP 
.PP
Definizzle at line 415 of file bits/alloc_traits\&.h\&.
.PP
Referenced by std::forward_list< _Tp, _Alloc >::max_size()\&.
.SS "template<typename _Alloc> static _Alloc \fBstd::allocator_traits\fP< _Alloc >::select_on_container_copy_construction (const _Alloc &__rhs)\fC [inline]\fP, \fC [static]\fP"

.PP
Obtain a allocator ta use when copyin a cold-ass lil container\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__rhs\fP An allocator\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fC__rhs\&.select_on_container_copy_construction()\fP or \fI__rhs\fP 
.RE
.PP
Returns \fC__rhs\&.select_on_container_copy_construction()\fP if dat expression is well-formed, otherwise returns \fI__rhs\fP 
.PP
Definizzle at line 427 of file bits/alloc_traits\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
