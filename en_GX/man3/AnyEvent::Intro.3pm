.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Intro 3"
.TH AnyEvent::Intro 3 "2013-07-30" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Intro \- a introductory tutorial ta AnyEvent
.SH "Introduction ta AnyEvent"
.IX Header "Introduction ta AnyEvent"
This be a tutorial dat will introduce you ta tha featurez of AnyEvent.
.PP
Da first part introduces tha core AnyEvent module (afta swampin you a
bit up in evangelism), which might already provide all you eva need: If you
are only horny bout AnyEventz event handlin capabilities, read no
further.
.PP
Da second part focuses on network programmin rockin sockets, fo' which
AnyEvent offers a shitload of support you can use, n' a shitload of workarounds
around portabilitizzle quirks.
.SH "What tha fuck iz AnyEvent?"
.IX Header "What tha fuck iz AnyEvent?"
If you couldn't give a fuckin shiznit fo' tha whys n' wanna peep code, skip dis section!
.PP
AnyEvent is first of all just a gangbangin' framework ta do event-based
programming. Typically such frameworks is a all-or-nothang thang: If you
use one such framework, you can't (easily, or even at all) use another in
the same program.
.PP
AnyEvent is different \- it aint nuthin but a thin abstraction layer on top of other
event loops, just like \s-1DBI\s0 be a abstraction of nuff different database
APIs. Its main purpose is ta move tha chizzle of tha underlyin framework
(the event loop) from tha module lyricist ta tha program lyricist rockin the
module.
.PP
That means you can write code dat uses events ta control what tha fuck it
does, without forcin other code up in tha same program ta use tha same
underlyin framework as you do \- i.e. you can create a Perl module
that is event-based rockin AnyEvent, n' playaz of dat module can still
choose between rockin Gtk2, Tk, Event (or run inside Irssi or
rxvt-unicode) or any other supported event loop fo' realz. AnyEvent even comes with
its own pure-perl event loop implementation, so yo' code works regardless
of other modulez dat might or might not be installed. Y'all KNOW dat shit, muthafucka! Da latta is
important, as AnyEvent aint gots any hard dependencies ta other
modules, which make it easy as fuck  ta install, fo' example, when you lack a C
compila n' shit. No matta what tha fuck environment, AnyEvent will just cope wit dat shit.
.PP
A typical limitation of existin Perl modulez like fuckin Net::IRC is that
they come wit they own event loop: In Net::IRC, a program which uses
it need ta start tha event loop of Net::IRC. That means dat one
cannot integrate dis module tha fuck into a Gtk2 \s-1GUI\s0 fo' instance, as that
module, too, enforces tha use of its own event loop (namely Glib).
.PP
Another example is \s-1LWP\s0: it serves up no event intercourse at all. It's
a pure blockin \s-1HTTP \s0(and \s-1FTP\s0 etc.) client library, which probably means
that you either gotta start another process or gotta fork fo' a \s-1HTTP\s0
request, or use threadz (e.g. Coro::LWP), if you wanna do something
else while waitin fo' tha request ta finish.
.PP
Da motivation behind these designs is often dat a module don't want
to depend on some fucked up XS-module (Net::IRC), or dat it don't
wanna force tha user ta use some specific event loop at all (\s-1LWP\s0), out
of fear of severly limitin tha usefulnizz of tha module: If yo' module
requires Glib, it aint gonna run up in a Tk program.
.PP
AnyEvent solves dis dilemma, by \fBnot\fR forcin module authors to
either:
.IP "\- write they own event loop (because it guarantees tha availabilitizzle of a event loop everywhere \- even on windows wit no extra modulez installed)." 4
.IX Item "- write they own event loop (because it guarantees tha availabilitizzle of a event loop everywhere - even on windows wit no extra modulez installed)."
.PD 0
.IP "\- chizzle one specific event loop (because AnyEvent works wit most event loops available fo' Perl)." 4
.IX Item "- chizzle one specific event loop (because AnyEvent works wit most event loops available fo' Perl)."
.PD
.PP
If tha module lyricist uses AnyEvent fo' all his (or her) event needs
(\s-1IO\s0 events, timers, signals, ...) then all other modulez can just use
his module n' don't gotta chizzle a event loop or adapt ta his wild lil' fuckin event
loop. Da chizzle of tha event loop is ultimately made by tha program
lyricist whoz ass uses all tha modulez n' writes tha main program fo' realz. And even
there da ruffneck don't gotta chizzle, his schmoooove ass can just let AnyEvent chizzle the
most efficient event loop available on tha system.
.PP
Read mo' bout dis up in tha main documentation of tha AnyEvent module.
.SH "Introduction ta Event-Based Programming"
.IX Header "Introduction ta Event-Based Programming"
So what tha fuck exactly is programmin rockin events? It like simply means that
instead of yo' code actively waitin fo' something, like fuckin tha user
enterin suttin' on \s-1STDIN:\s0
.PP
.Vb 1
\&   $| = 1; print "enta yo' name> ";
\&
\&   mah $name = <STDIN>;
.Ve
.PP
Yo ass instead rap r event framework ta notify you up in tha event of some
data bein available on \s-1STDIN,\s0 by rockin a cold-ass lil callback mechanism:
.PP
.Vb 1
\&   use AnyEvent;
\&
\&   $| = 1; print "enta yo' name> ";
\&
\&   mah $name;
\&
\&   mah $wait_for_input = AnyEvent\->io (
\&      fh   => \e*STDIN, # which file handle ta check
\&      poll => "r",     # which event ta wait fo' ("r"ead data)
\&      cb   => sub {    # what tha fuck callback ta execute
\&         $name = <STDIN>; # read it
\&      }
\&   );
\&
\&   # do suttin' else here
.Ve
.PP
Looks mo' fucked up, n' surely is yo, but tha advantage of rockin events
is dat yo' program can do suttin' else instead of waitin fo' input
(side note: combinin AnyEvent wit a thread package like fuckin Coro can
recoup much of tha simplicity, effectively gettin tha dopest of two
worlds).
.PP
Waitin as done up in tha straight-up original gangsta example be also called \*(L"blocking\*(R" tha process
because you \*(L"block\*(R"/keep yo' process from executin anythang else while
you do so.
.PP
Da second example avoidz blockin by only registerin interest up in a read
event, which is fast n' don't block yo' process. Da callback will
be called only when data be available n' can be read without blocking.
.PP
Da \*(L"interest\*(R" is represented by a object returned by \f(CW\*(C`AnyEvent\->io\*(C'\fR called a \*(L"watcher\*(R" object \- thus named cuz it \*(L"watches\*(R" your
file handle (or other event sources) fo' tha event yo ass is interested in.
.PP
In tha example above, we create a I/O watcher by callin tha \f(CW\*(C`AnyEvent\->io\*(C'\fR method. Y'all KNOW dat shit, muthafucka! A lack of further interest up in some event is
expressed by simply forgettin bout its watcher, fo' example by
\&\f(CW\*(C`undef\*(C'\fR\-in tha only variable it is stored in. I aint talkin' bout chicken n' gravy biatch fo' realz. AnyEvent will
automatically clean up tha watcher if it is no longer used, much like
Perl closes yo' file handlez if you no longer use dem anywhere.
.PP
\fIA short note on callbacks\fR
.IX Subsection "A short note on callbacks"
.PP
A common issue dat hits playas is tha problem of passin parameters
to callbacks. Programmers used ta languages like fuckin C or \*(C+ is often
used ta a steez where one passes tha address of a gangbangin' function (a function
reference) n' some data value, e.g.:
.PP
.Vb 2
\&   sub callback {
\&      mah ($arg) = @_;
\&
\&      $arg\->method;
\&   }
\&
\&   mah $arg = ...;
\&
\&   call_me_back_lata \e&callback, $arg;
.Ve
.PP
This is clumsy, as tha place where behaviour is specified (when the
callback is registered) is often far away from tha place where behaviour
is implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Well shiiiit, it also don't use Perl syntax ta invoke tha code. There
is also a abstraction penalty ta pay as one has ta \fIname\fR tha callback,
which often is unnecessary n' leadz ta nonsensical or duplicated names.
.PP
In Perl, one can specify behaviour much mo' directly by using
\&\fIclosures\fR. Closures is code blocks dat take a reference ta the
enclosin scope(s) when they is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This means lexical variables
in scope when a cold-ass lil closure is pimped can be used inside tha closure:
.PP
.Vb 1
\&   mah $arg = ...;
\&
\&   call_me_back_lata sub { $arg\->method };
.Ve
.PP
Under most circumstances, closures is faster, use fewer resources and
result up in much clearer code then tha traditionizzle approach. Faster,
because parameta passin n' storin dem up in local variablez up in Perl
is relatively slow. Fewer resources, cuz closures take references
to existin variablez without havin ta create freshly smoked up ones, n' clearer
code cuz it is immediately obvious dat tha second example calls the
\&\f(CW\*(C`method\*(C'\fR method when tha callback is invoked.
.PP
Apart from these, tha strongest argument fo' rockin closures wit AnyEvent
is dat AnyEvent do not allow passin parametas ta tha callback, so
closures is tha only way ta big up dat up in most cases :\->
.PP
\fIA lil hint ta catch mistakes\fR
.IX Subsection "A lil hint ta catch mistakes"
.PP
AnyEvent do not check tha parametas you pass in, at least not by
default. ta enable checking, simply start yo' program wit \f(CW\*(C`AE_STRICT=1\*(C'\fR
in tha environment, or put \f(CW\*(C`use AnyEvent::Strict\*(C'\fR near tha top of your
program:
.PP
.Vb 1
\&   AE_STRICT=1 perl myprogram
.Ve
.PP
Yo ass can find mo' info on dis n' additionizzle debuggin aidz lata up in this
introduction.
.SS "Condizzle Variables"
.IX Subsection "Condizzle Variables"
Back ta tha I/O watcher example: Da code aint yet a gangbangin' straight-up working
program, n' aint gonna work as-is. Da reason is dat yo' callback will
not be invoked outta tha blue; you gotta run tha event loop first.
Also, event-based programs need ta block sometimes too, like fuckin when
there is not a god damn thang ta do, n' every last muthafuckin thang is waitin fo' freshly smoked up events to
arrive.
.PP
In AnyEvent, dis is done rockin condizzle variables. Condizzle variables
are named \*(L"condizzle variables\*(R" cuz they represent a cold-ass lil condizzle dat is
initially false n' need ta be fulfilled.
.PP
Yo ass can also call dem \*(L"merge points\*(R", \*(L"sync points\*(R", \*(L"rendezvous ports\*(R"
or even callbacks n' nuff other thangs (and they is often called these
names up in other frameworks). Da blingin point is dat you can create them
freely n' lata wait fo' dem ta become true.
.PP
Condizzle variablez have two sides \- one side is tha \*(L"producer\*(R" of the
condizzle (whatever code detects n' flags tha condition), tha other side
is tha \*(L"consumer\*(R" (the code dat waits fo' dat condition).
.PP
In our example up in tha previous section, tha balla is tha event callback
and there is no thug yet \- letz chizzle dat right now:
.PP
.Vb 1
\&   use AnyEvent;
\&
\&   $| = 1; print "enta yo' name> ";
\&
\&   mah $name;
\&
\&   mah $name_ready = AnyEvent\->condvar;
\&
\&   mah $wait_for_input = AnyEvent\->io (
\&      fh   => \e*STDIN,
\&      poll => "r",
\&      cb   => sub {
\&         $name = <STDIN>;
\&         $name_ready\->send;
\&      }
\&   );
\&
\&   # do suttin' else here
\&
\&   # now wait until tha name be available:
\&   $name_ready\->recv;
\&
\&   undef $wait_for_input; # watcher no longer needed
\&
\&   print "your name is $name\en";
.Ve
.PP
This program creates a AnyEvent condvar by callin tha \f(CW\*(C`AnyEvent\->condvar\*(C'\fR method. Y'all KNOW dat shit, muthafucka! Well shiiiit, it then creates a watcher as usual yo, but
inside tha callback it \f(CW\*(C`send\*(C'\fRs tha \f(CW$name_ready\fR condizzle variable,
which causes whoever is waitin on it ta continue.
.PP
Da \*(L"whoever\*(R" up in dis case is tha code dat bigs up, which calls \f(CW\*(C`$name_ready\->recv\*(C'\fR: Da balla calls \f(CW\*(C`send\*(C'\fR, tha thug calls
\&\f(CW\*(C`recv\*(C'\fR.
.PP
If there is no \f(CW$name\fR available yet, then tha call ta \f(CW\*(C`$name_ready\->recv\*(C'\fR will halt yo' program until tha condizzle becomes
true.
.PP
As tha names \f(CW\*(C`send\*(C'\fR n' \f(CW\*(C`recv\*(C'\fR imply, you can straight-up bust n' receive
data rockin this, fo' example, tha above code could also be freestyled like
this, without a extra variable ta store tha name in:
.PP
.Vb 1
\&   use AnyEvent;
\&
\&   $| = 1; print "enta yo' name> ";
\&
\&   mah $name_ready = AnyEvent\->condvar;
\&
\&   mah $wait_for_input = AnyEvent\->io (
\&      fh => \e*STDIN, poll => "r",
\&      cb => sub { $name_ready\->send (scalar <STDIN>) }
\&   );
\&
\&   # do suttin' else here
\&
\&   # now wait n' fetch tha name
\&   mah $name = $name_ready\->recv;
\&
\&   undef $wait_for_input; # watcher no longer needed
\&
\&   print "your name is $name\en";
.Ve
.PP
Yo ass can pass any number of arguments ta \f(CW\*(C`send\*(C'\fR, n' every last muthafuckin subsequent
call ta \f(CW\*(C`recv\*(C'\fR will return em.
.ie n .SS "Da ""main loop"""
.el .SS "Da ``main loop''"
.IX Subsection "Da main loop"
Most event-based frameworks have suttin' called a \*(L"main loop\*(R" or \*(L"event
loop run function\*(R" or suttin' similar.
.PP
Just like up in \f(CW\*(C`recv\*(C'\fR AnyEvent, these functions need ta be called
eventually so dat yo' event loop has a cold-ass lil chizzle of straight-up lookin for
the events yo ass is interested in.
.PP
For example, up in a Gtk2 program, tha above example could also be written
like this:
.PP
.Vb 2
\&   use Gtk2 \-init;
\&   use AnyEvent;
\&
\&   ############################################
\&   # create a window n' some label
\&
\&   mah $window = freshly smoked up Gtk2::Window "toplevel";
\&   $window\->add (my $label = freshly smoked up Gtk2::Label "soon replaced by name");
\&
\&   $window\->show_all;
\&
\&   ############################################
\&   # do our AnyEvent stuff
\&
\&   $| = 1; print "enta yo' name> ";
\&
\&   mah $name_ready = AnyEvent\->condvar;
\&
\&   mah $wait_for_input = AnyEvent\->io (
\&      fh => \e*STDIN, poll => "r",
\&      cb => sub {
\&         # set tha label
\&         $label\->set_text (scalar <STDIN>);
\&         print "enta another name> ";
\&      }
\&   );
\&
\&   ############################################
\&   # Now enta Gtk2\*(Aqs event loop
\&
\&   main Gtk2;
.Ve
.PP
No condizzle variable anywhere up in sight \- instead, our laid-back asses just read a line
from \s-1STDIN\s0 n' replace tha text up in tha label. In fact, since no muthafucka
\&\f(CW\*(C`undef\*(C'\fRs \f(CW$wait_for_input\fR you can enta multiple lines.
.PP
Instead of waitin fo' a cold-ass lil condizzle variable, tha program entas tha Gtk2
main loop by callin \f(CW\*(C`Gtk2\->main\*(C'\fR, which will block tha program and
wait fo' events ta arrive.
.PP
This also shows dat AnyEvent is like flexible \- you didn't gotta do
anythang ta make tha AnyEvent watcher use Gtk2 (actually Glib) \- it just
worked.
.PP
Admittedly, tha example be a lil' bit wack-ass \- whoz ass would wanna read names
from standard input up in a Gtk+ application? But imagine dat instead of
fuckin wit that, you cook up a \s-1HTTP\s0 request up in tha background n' display its
results, n' you can put dat on yo' toast. In fact, wit event-based programmin you can make many
\&\s-1HTTP\s0 requests up in parallel up in yo' program n' still provide feedback to
the user n' stay interactive.
.PP
And up in tha next part yo big-ass booty is ghon peep how tha fuck ta do just dat \- by implementin an
\&\s-1HTTP\s0 request, on our own, wit tha utilitizzle modulez AnyEvent comes with.
.PP
Before that, however, letz briefly peep how tha fuck you would write your
program rockin only AnyEvent, without eva callin some other event
loopz run function.
.PP
In tha example rockin condizzle variables, we used dem ta start waiting
for events, n' up in fact, condizzle variablez is tha solution:
.PP
.Vb 1
\&   mah $quit_program = AnyEvent\->condvar;
\&
\&   # create AnyEvent watchers (or not) here
\&
\&   $quit_program\->recv;
.Ve
.PP
If any of yo' watcher callbacks decizzle ta quit (this is often
called a \*(L"unloop\*(R" up in other frameworks), they can just call \f(CW\*(C`$quit_program\->send\*(C'\fR. Of course, they could also decizzle not ta and
call \f(CW\*(C`exit\*(C'\fR instead, or they could decizzle never ta quit (e.g. up in a
long-runnin daemon program).
.PP
If you don't need some clean quit functionalitizzle n' just wanna run the
event loop, you can do this:
.PP
.Vb 1
\&   AnyEvent\->condvar\->recv;
.Ve
.PP
And dis is, up in fact, tha closest ta tha scam of a main loop run
function dat AnyEvent offers.
.SS "Timers n' other event sources"
.IX Subsection "Timers n' other event sources"
So far, our crazy asses have used only I/O watchers. These is useful mainly ta find
out whether a socket has data ta read, or space ta write mo' data. On sane
operatin systems dis also works fo' console windows/terminals (typically
on standard input), serial lines, all sortz of other devices, basically
almost every last muthafuckin thang dat has a gangbangin' file descriptor but aint a gangbangin' file itself. (As
usual, \*(L"sane\*(R" excludes windows \- on dat platform you would need different
functions fo' all of these, complicatin code immensely \- be thinkin \*(L"socket
only\*(R" on windows).
.PP
But fuck dat shiznit yo, tha word on tha street is dat I/O aint every last muthafuckin thang \- tha second most blingin event source is
the clock. For example when bustin a \s-1HTTP\s0 request you might wanna time
out when tha server don't answer within some predefined amount of time.
.PP
In AnyEvent, timer event watchers is pimped by callin tha \f(CW\*(C`AnyEvent\->timer\*(C'\fR method:
.PP
.Vb 1
\&   use AnyEvent;
\&
\&   mah $cv = AnyEvent\->condvar;
\&
\&   mah $wait_one_and_a_half_secondz = AnyEvent\->timer (
\&      afta => 1.5,  # afta how tha fuck nuff secondz ta invoke tha cb?
\&      cb    => sub { # tha callback ta invoke
\&         $cv\->send;
\&      },
\&   );
\&
\&   # can do suttin' else here
\&
\&   # now wait till our time has come
\&   $cv\->recv;
.Ve
.PP
Unlike I/O watchers, timers is only horny bout tha amount of seconds
they gotta wait. When (at least) dat amount of time has passed,
AnyEvent will invoke yo' callback.
.PP
Unlike I/O watchers, which will call yo' callback as nuff times as there
is data available, timers is normally one-shot: afta they have \*(L"fired\*(R"
once n' invoked yo' callback, they is dead n' no longer do anything.
.PP
To git a repeatin timer, like fuckin a timer firin roughly once per second,
you can specify a \f(CW\*(C`interval\*(C'\fR parameter:
.PP
.Vb 7
\&   mah $once_per_second = AnyEvent\->timer (
\&      afta => 0,    # first invoke ASAP
\&      interval => 1, # then invoke every last muthafuckin second
\&      cb    => sub { # tha callback ta invoke
\&         $cv\->send;
\&      },
\&   );
.Ve
.PP
\fIMo' esoteric sources\fR
.IX Subsection "Mo' esoteric sources"
.PP
AnyEvent also has some other, mo' esoteric event sources you can tap
into: signal, lil pimp n' idle watchers.
.PP
Signal watchers can be used ta wait fo' \*(L"signal events\*(R", which means
your process was busted a signal (like fuckin \f(CW\*(C`SIGTERM\*(C'\fR or \f(CW\*(C`SIGUSR1\*(C'\fR).
.PP
Child-process watchers wait fo' a cold-ass lil lil pimp process ta exit. They is useful
when you fork a separate process n' need ta know when it exits yo, but you
do not wanna wait fo' dat by blocking.
.PP
Idle watchers invoke they callback when tha event loop has handled all
outstandin events, polled fo' freshly smoked up events n' didn't find any, i.e., when
your process is otherwise idle. They is useful if you wanna do some
non-trivial data processin dat can be done when yo' program don't
have anythang betta ta do.
.PP
All these watcher types is busted lyrics bout up in detail up in tha main AnyEvent
manual page.
.PP
Sometimes you also need ta know what tha fuck tha current time is: \f(CW\*(C`AnyEvent\->now\*(C'\fR returns tha time tha event toolkit uses ta schedule
relatizzle timers, n' is probably what tha fuck you want. Well shiiiit, it is often cached (which
means it can be a lil' bit outdated). In dat case, you can use tha mo' costly
\&\f(CW\*(C`AnyEvent\->time\*(C'\fR method which will ask yo' operatin system fo' the
current time, which is slower yo, but also mo' up ta date.
.SH "Network programmin n' AnyEvent"
.IX Header "Network programmin n' AnyEvent"
So far you have peeped how tha fuck ta regista event watchers n' handle events.
.PP
This be a pimped out foundation ta write network clients n' servers, n' might
be all dat yo' module (or program) eva requires yo, but freestylin yo' own
I/O bufferin again n' again n' again n' again n' again n' again becomes tedious, not ta mention dat it
attracts errors.
.PP
While tha core AnyEvent module is still lil' small-ass n' self-contained,
the distribution comes wit some straight-up useful utilitizzle modulez such as
AnyEvent::Handle, AnyEvent::DNS n' AnyEvent::Socket. These can
make yo' game as a non-blockin network programmer a shitload easier.
.PP
Here be a quick overview of these three modules:
.SS "AnyEvent::DNS"
.IX Subsection "AnyEvent::DNS"
This module allows straight-up asynchronous \s-1DNS\s0 resolution. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it is used mainly by
AnyEvent::Socket ta resolve hostnames n' steez ports fo' you yo, but is
a pimped out way ta do other \s-1DNS\s0 resolution tasks, like fuckin reverse lookups of
\&\s-1IP\s0 addresses fo' log files.
.SS "AnyEvent::Handle"
.IX Subsection "AnyEvent::Handle"
This module handlez non-blockin \s-1IO\s0 on (socket\-, pipe\- etc.) file handles
in a event based manner n' shit. Well shiiiit, it serves up a wrapper object round yo' file
handle dat serves up queuein n' bufferin of incomin n' outgoin data
for yo thugged-out ass.
.PP
It also implements da most thugged-out common data formats, like fuckin text lines, or
fixed n' variable-width data blocks.
.SS "AnyEvent::Socket"
.IX Subsection "AnyEvent::Socket"
This module serves up you wit functions dat handle socket creation
and \s-1IP\s0 address magic. Da two main functions is \f(CW\*(C`tcp_connect\*(C'\fR and
\&\f(CW\*(C`tcp_server\*(C'\fR. Da forma will connect a (streaming) socket ta a internet
host fo' you n' tha lata will cook up a server socket fo' you, ta accept
connections.
.PP
This module also comes wit transparent IPv6 support, dis means: If you
write yo' programs wit dis module, yo big-ass booty is ghon be IPv6 locked n loaded without bustin
anythang special.
.PP
It also works round a shitload of portabilitizzle quirks (especially on the
windows platform), which make it even easier ta write yo' programs up in a
portable way (did you know dat windows uses different error codes fo' all
socket functions n' dat Perl do not know bout these? That \*(L"Unknown
error 10022\*(R" (which is \f(CW\*(C`WSAEINVAL\*(C'\fR) can mean dat our \f(CW\*(C`connect\*(C'\fR call was
successful? That unsuccessful \s-1TCP\s0 connects might never be reported back
to yo' program? That \f(CW\*(C`WSAEINPROGRESS\*(C'\fR means yo' \f(CW\*(C`connect\*(C'\fR call was
ignored instead of bein up in progress? AnyEvent::Socket works round all of
these Windows/Perl bugs fo' you).
.SS "Implementin a parallel finger client wit non-blockin connects n' AnyEvent::Socket"
.IX Subsection "Implementin a parallel finger client wit non-blockin connects n' AnyEvent::Socket"
Da finger protocol is one of tha simplest protocols up in use on the
internet. Or up in use up in tha past, as almost no muthafucka uses it no mo'.
.PP
It works by connectin ta tha finger port on another host, freestylin a
single line wit a user name n' then readin tha finger response, as
specified by dat user n' shit. \s-1OK, RFC 1288\s0 specifies a vastly mo' complex
protocol yo, but it basically boils down ta this:
.PP
.Vb 10
\&   # telnet freebsd.org finger
\&   Tryin 8.8.178.135...
\&   Connected ta freebsd.org (8.8.178.135).
\&   Escape characta is \*(Aq^]\*(Aq.
\&   larry
\&   Login: lile                             Name: Larry Lile
\&   Directory: /home/lile                   Shell: /usr/local/bin/bash
\&   No Mail.
\&   Mail forwarded to: lile@stdio.com
\&   No Plan.
.Ve
.PP
So letz write a lil AnyEvent function dat cook up a gangbangin' finger request:
.PP
.Vb 2
\&   use AnyEvent;
\&   use AnyEvent::Socket;
\&
\&   sub finger($$) {
\&      mah ($user, $host) = @_;
\&
\&      # bust a cold-ass lil condvar ta return thangs up in dis biatch
\&      mah $cv = AnyEvent\->condvar;
\&
\&      # first, connect ta tha host
\&      tcp_connect $host, "finger", sub {
\&         # tha callback receives tha socket handle \- or nothing
\&         mah ($fh) = @_
\&            or return $cv\->send;
\&
\&         # now write tha username
\&         syswrite $fh, "$user\e015\e012";
\&
\&         mah $response;
\&
\&         # regista a read watcher
\&         mah $read_watcher; $read_watcher = AnyEvent\->io (
\&            fh   => $fh,
\&            poll => "r",
\&            cb   => sub {
\&               mah $len = sysread $fh, $response, 1024, length $response;
\&
\&               if ($len <= 0) {
\&                  # we is done, or a error occured, lets ignore tha latter
\&                  undef $read_watcher; # no longer interested
\&                  $cv\->send ($response); # bust thangs up in dis biatch
\&               }
\&            },
\&         );
\&      };
\&
\&      # pass $cv ta tha caller
\&      $cv
\&   }
.Ve
.PP
Thatz a grillful! Letz dissect dis function a funky-ass bit, first tha overall
function n' execution flow:
.PP
.Vb 2
\&   sub finger($$) {
\&      mah ($user, $host) = @_;
\&
\&      # bust a cold-ass lil condvar ta return thangs up in dis biatch
\&      mah $cv = AnyEvent\->condvar;
\&
\&      # first, connect ta tha host
\&      tcp_connect $host, "finger", sub {
\&         ...
\&      };
\&
\&      $cv
\&   }
.Ve
.PP
This aint too fucked up, just a gangbangin' function wit two parametas that
creates a cold-ass lil condizzle variable \f(CW$cv\fR, initiates a \s-1TCP\s0 connect to
\&\f(CW$host\fR, n' returns \f(CW$cv\fR. Da calla can use tha returned \f(CW$cv\fR to
receive tha finger response yo, but one could equally well pass a third
argument, a cold-ass lil callback, ta tha function.
.PP
Since we is programmin event'ish, our phat asses do not wait fo' tha connect to
finish \- it could block tha program fo' a minute or longer!
.PP
Instead, we pass \f(CW\*(C`tcp_connect\*(C'\fR a cold-ass lil callback ta invoke when tha connect is
done. Da callback is called wit tha socket handle as its first
argument if tha connect succeeds, n' no arguments otherwise. The
important point is dat it will always be called as soon as tha outcome
of tha \s-1TCP\s0 connect is known.
.PP
This steez of programmin be also called \*(L"continuation style\*(R": the
\&\*(L"continuation\*(R" is simply tha way tha program continues \- normally at the
next line afta some statement (the exception is loops or thangs like
\&\f(CW\*(C`return\*(C'\fR). When we is horny bout events, however, we instead specify
the \*(L"continuation\*(R" of our program by passin a cold-ass lil closure, which make that
closure tha \*(L"continuation\*(R" of tha program.
.PP
Da \f(CW\*(C`tcp_connect\*(C'\fR call is like sayin \*(L"return now, n' when the
connection is established or tha attempt failed, continue there\*(R".
.PP
Now letz peep tha callback/closure up in mo' detail:
.PP
.Vb 3
\&         # tha callback receives tha socket handle \- or nothing
\&         mah ($fh) = @_
\&            or return $cv\->send;
.Ve
.PP
Da first thang tha callback do is ta save tha socket handle in
\&\f(CW$fh\fR. When there was a error (no arguments), then our instinct as
expert Perl programmers would tell our asses ta \f(CW\*(C`die\*(C'\fR:
.PP
.Vb 2
\&         mah ($fh) = @_
\&            or take a thugged-out dirtnap "$host: $!";
.Ve
.PP
While dis would give phat feedback ta tha user (if dat schmoooove muthafucka happens ta watch
standard error), our program would probably stop hustlin here, as we never
report tha thangs up in dis biatch ta anybody, certainly not tha calla of our \f(CW\*(C`finger\*(C'\fR
function, n' most event loops continue even afta a \f(CW\*(C`die\*(C'\fR!
.PP
This is why we instead \f(CW\*(C`return\*(C'\fR yo, but also call \f(CW\*(C`$cv\->send\*(C'\fR without
any arguments ta signal ta tha condvar thug dat suttin' wack has
happened. Y'all KNOW dat shit, muthafucka! Da return value of \f(CW\*(C`$cv\->send\*(C'\fR is irrelevant, as is
the return value of our callback. Da \f(CW\*(C`return\*(C'\fR statement is used for
the side effect of, well, returnin immediately from tha callback.
Checkin fo' errors n' handlin dem dis way is straight-up common, which is
why dis compact idiom is so handy.
.PP
As tha next step up in tha finger protocol, we bust tha username ta the
finger daemon on tha other side of our connection (the kernel.org finger
service don't straight-up wait fo' a username yo, but tha net is hustlin out
of finger servers fast):
.PP
.Vb 1
\&         syswrite $fh, "$user\e015\e012";
.Ve
.PP
Note dat dis aint 100% clean socket programmin \- tha socket could,
for whatever reasons, not accept our data. When freestylin a lil' small-ass amount
of data like up in dis example it don't matter, as a socket buffer is
almost always big-ass enough fo' a mere \*(L"username\*(R" yo, but fo' real-world
cases you might need ta implement some kind of write bufferin \- or use
AnyEvent::Handle, which handlez these mattas fo' you, as shown up in the
next section.
.PP
What we \fIdo\fR gotta do is implement our own read buffer \- tha response
data could arrive late or up in multiple chunks, n' we cannot just wait for
it (event-based programming, you know?).
.PP
To do that, we regista a read watcher on tha socket which waits fo' data:
.PP
.Vb 3
\&         mah $read_watcher; $read_watcher = AnyEvent\->io (
\&            fh   => $fh,
\&            poll => "r",
.Ve
.PP
There be a trick here, however: tha read watcher aint stored up in a global
variable yo, but up in a local one \- if tha callback returns, it would normally
destroy tha variable n' its contents, which would up in turn unregista our
watcher.
.PP
To avoid that, we refer ta tha watcher variable up in tha watcher callback.
This means that, when tha \f(CW\*(C`tcp_connect\*(C'\fR callback returns, perl thinks
(quite erectly) dat tha read watcher is still up in use \- namely inside
the inner callback \- n' thus keeps it kickin it even if not a god damn thang else up in the
program refers ta it no mo' (it is much like Baron Mu\*:nchhausen keeping
himself from dyin by pullin his dirty ass outta a swamp).
.PP
Da trick, however, is dat instead of:
.PP
.Vb 1
\&   mah $read_watcher = AnyEvent\->io (...
.Ve
.PP
Da program do:
.PP
.Vb 1
\&   mah $read_watcher; $read_watcher = AnyEvent\->io (...
.Ve
.PP
Da reason fo' dis be a quirk up in tha way Perl works: variable names
declared wit \f(CW\*(C`my\*(C'\fR is only visible up in tha \fInext\fR statement. If the
whole \f(CW\*(C`AnyEvent\->io\*(C'\fR call, includin tha callback, would be done in
a single statement, tha callback could not refer ta tha \f(CW$read_watcher\fR
variable ta \f(CW\*(C`undef\*(C'\fRine it, so it is done up in two statements.
.PP
Whether you'd wanna format it like dis iz of course a matta of style.
This way emphasizes dat tha declaration n' assignment straight-up is one
logical statement.
.PP
Da callback itself calls \f(CW\*(C`sysread\*(C'\fR fo' as nuff times as necessary, until
\&\f(CW\*(C`sysread\*(C'\fR returns either a error or end-of-file:
.PP
.Vb 2
\&            cb   => sub {
\&               mah $len = sysread $fh, $response, 1024, length $response;
\&
\&               if ($len <= 0) {
.Ve
.PP
Note dat \f(CW\*(C`sysread\*(C'\fR has tha mobilitizzle ta append data it readz ta a scalar
if we specify a offset, a gangbangin' feature which we make use of up in dis example.
.PP
When \f(CW\*(C`sysread\*(C'\fR indicates we is done, tha callback \f(CW\*(C`undef\*(C'\fRines
the watcher n' then \f(CW\*(C`send\*(C'\fRs tha response data ta tha condition
variable fo' realz. All dis has tha followin effects:
.PP
Undefinin tha watcher destroys it, as our callback was tha only one still
havin a reference ta dat shit. When tha watcher gets destroyed, it destroys the
callback, which up in turn means tha \f(CW$fh\fR handle is no longer used, so that
gets destroyed as well. Da result is dat all resources is ghon be sickly
cleaned up by perl fo' us.
.PP
\fIUsin tha finger client\fR
.IX Subsection "Usin tha finger client"
.PP
Now, we could probably write tha same finger client up in a simpla way if
we used \f(CW\*(C`IO::Socket::INET\*(C'\fR, ignored tha problem of multiple hosts and
ignored IPv6 n' all dem other thangs dat \f(CW\*(C`tcp_connect\*(C'\fR handlez fo' us.
.PP
But tha main advantage is dat we can not only run dis finger function in
the background, we even can run multiple sessions up in parallel, like this:
.PP
.Vb 3
\&   mah $f1 = finger "kuriyama", "freebsd.org";
\&   mah $f2 = finger "icculus?listarchives=1", "icculus.org";
\&   mah $f3 = finger "mikachu", "icculus.org";
\&
\&   print "kuriyama\*(Aqs gpg key\en"    , $f1\->recv, "\en";
\&   print "icculus\*(Aq plan archive\en" , $f2\->recv, "\en";
\&   print "mikachu\*(Aqs plan zomgn\en"  , $f3\->recv, "\en";
.Ve
.PP
It don't be lookin like it yo, but up in fact all three requests run in
parallel. Da code waits fo' tha straight-up original gangsta finger request ta finish first yo, but
that don't keep it from executin dem parallel: when tha straight-up original gangsta \f(CW\*(C`recv\*(C'\fR
call sees dat tha data aint locked n loaded yet, it serves events fo' all three
requests automatically, until tha straight-up original gangsta request has finished.
.PP
Da second \f(CW\*(C`recv\*(C'\fR call might either find tha data be already there, or it
will continue handlin events until dat is tha case, n' so on.
.PP
By takin advantage of network latencies, which allows our asses ta serve other
requests n' events while we wait fo' a event on one socket, tha overall
time ta do these three requests is ghon be pimped outly reduced, typically all
three is done up in tha same time as tha slowest of tha three requests.
.PP
By tha way, you do not straight-up gotta wait up in tha \f(CW\*(C`recv\*(C'\fR method on an
AnyEvent condizzle variable \- afta all, waitin is evil \- you can also
regista a cold-ass lil callback:
.PP
.Vb 4
\&   $f1\->cb (sub {
\&      mah $response = shift\->recv;
\&      # ...
\&   });
.Ve
.PP
Da callback is ghon be invoked only when \f(CW\*(C`send\*(C'\fR is called. Y'all KNOW dat shit, muthafucka! In fact,
instead of returnin a cold-ass lil condizzle variable you could also pass a third
parameta ta yo' finger function, tha callback ta invoke wit the
response:
.PP
.Vb 2
\&   sub finger($$$) {
\&      mah ($user, $host, $cb) = @_;
.Ve
.PP
How tha fuck you implement it aint nuthin but a matta of taste \- if you expect yo' function to
be used mainly up in a event-based program you would normally prefer ta pass
a callback directly. If you write a module n' expect yo' playas ta use
it \*(L"synchronously\*(R" often (for example, a simple http-get script would not
really care much fo' events), then you would bust a cold-ass lil condizzle variable and
tell dem "simply \f(CW\*(C`\->recv\*(C'\fR tha data".
.PP
\fIProblems wit tha implementation n' how tha fuck ta fix them\fR
.IX Subsection "Problems wit tha implementation n' how tha fuck ta fix them"
.PP
To make dis example mo' real-world-ready, we would not only implement
some write bufferin (for tha paranoid, or maybe denial-of-service aware
securitizzle expert) yo, but we would also gotta handle timeouts n' maybe
protocol errors.
.PP
Bustin dis quickly gets unwieldy, which is why we introduce
AnyEvent::Handle up in tha next section, which takes care of all these
details fo' you n' lets you concentrate on tha actual protocol.
.SS "Implementin simple \s-1HTTP\s0 n' \s-1HTTPS GET\s0 requests wit AnyEvent::Handle"
.IX Subsection "Implementin simple HTTP n' HTTPS GET requests wit AnyEvent::Handle"
Da AnyEvent::Handle module has been hyped like a lil' bit up in dis document
so far, so letz peep what tha fuck it straight-up offers.
.PP
As finger is such a simple protocol, letz try suttin' slightly more
fucked up: \s-1HTTP/1.0.\s0
.PP
An \s-1HTTP GET\s0 request works by bustin  a single request line dat indicates
what you want tha server ta do n' tha \s-1URI\s0 you wanna act it on, followed
by as nuff \*(L"header\*(R" lines (\f(CW\*(C`Header: data\*(C'\fR, same as e\-mail headers) as
required fo' tha request, followed by a empty line.
.PP
Da response is formatted straight-up similarly, first a line wit tha response
status, then again n' again n' again as nuff header lines as required, then a empty line,
followed by any data dat tha server might send.
.PP
Again, letz try it up wit \f(CW\*(C`telnet\*(C'\fR (I condensed tha output a lil' bit \- if
you wanna peep tha full response, do it yo ass).
.PP
.Vb 5
\&   # telnet www.google.com 80
\&   Tryin 209.85.135.99...
\&   Connected ta www.google.com (209.85.135.99).
\&   Escape characta is \*(Aq^]\*(Aq.
\&   GET /test HTTP/1.0
\&
\&   HTTP/1.0 404 Not Found
\&   Date: Mon, 02 Jun 2008 07:05:54 GMT
\&   Content\-Type: text/html; charset=UTF\-8
\&
\&   <html><head>
\&   [...]
\&   Connection closed by foreign host.
.Ve
.PP
Da \f(CW\*(C`GET ...\*(C'\fR n' tha empty line was entered manually, tha rest of the
telnet output is googlez response, up in dis case a \f(CW\*(C`404 not found\*(C'\fR one.
.PP
So, here is how tha fuck you would do it wit \f(CW\*(C`AnyEvent::Handle\*(C'\fR:
.PP
.Vb 2
\&   sub http_get {
\&      mah ($host, $uri, $cb) = @_;
\&
\&      # store thangs up in dis biatch here
\&      mah ($response, $header, $body);
\&
\&      mah $handle; $handle = freshly smoked up AnyEvent::Handle
\&         connect  => [$host => \*(Aqhttp\*(Aq],
\&         on_error => sub {
\&            $cb\->("HTTP/1.0 500 $!");
\&            $handle\->destroy; # explicitly destroy handle
\&         },
\&         on_eof   => sub {
\&            $cb\->($response, $header, $body);
\&            $handle\->destroy; # explicitly destroy handle
\&         };
\&
\&      $handle\->push_write ("GET $uri HTTP/1.0\e015\e012\e015\e012");
\&
\&      # now fetch response status line
\&      $handle\->push_read (line => sub {
\&         mah ($handle, $line) = @_;
\&         $response = $line;
\&      });
\&
\&      # then tha headers
\&      $handle\->push_read (line => "\e015\e012\e015\e012", sub {
\&         mah ($handle, $line) = @_;
\&         $header = $line;
\&      });
\&
\&      # n' finally handle any remainin data as body
\&      $handle\->on_read (sub {
\&         $body .= $_[0]\->rbuf;
\&         $_[0]\->rbuf = "";
\&      });
\&   }
.Ve
.PP
And now letz go all up in it step by step. First, as usual, tha overall
\&\f(CW\*(C`http_get\*(C'\fR function structure:
.PP
.Vb 2
\&   sub http_get {
\&      mah ($host, $uri, $cb) = @_;
\&
\&      # store thangs up in dis biatch here
\&      mah ($response, $header, $body);
\&
\&      mah $handle; $handle = freshly smoked up AnyEvent::Handle
\&         ... create handle object
\&
\&      ... push data ta write
\&
\&      ... push what tha fuck ta expect ta read queue
\&   }
.Ve
.PP
Unlike up in tha finger example, dis time tha calla has ta pass a cold-ass lil callback
to \f(CW\*(C`http_get\*(C'\fR fo' realz. Also, instead of passin a \s-1URL\s0 as one would expect, the
calla has ta provide tha hostname n' \s-1URI \-\s0 normally you would use the
\&\f(CW\*(C`URI\*(C'\fR module ta parse a \s-1URL\s0 n' separate it tha fuck into dem parts yo, but dat is
left ta tha inspired reader :)
.PP
Since every last muthafuckin thang else is left ta tha caller, all \f(CW\*(C`http_get\*(C'\fR do is
initiate tha connection by bustin tha AnyEvent::Handle object (which
calls \f(CW\*(C`tcp_connect\*(C'\fR fo' us) n' leave every last muthafuckin thang else ta its callback.
.PP
Da handle object is pimped, unsurprisingly, by callin tha \f(CW\*(C`new\*(C'\fR
method of AnyEvent::Handle:
.PP
.Vb 10
\&      mah $handle; $handle = freshly smoked up AnyEvent::Handle
\&         connect  => [$host => \*(Aqhttp\*(Aq],
\&         on_error => sub {
\&            $cb\->("HTTP/1.0 500 $!");
\&            $handle\->destroy; # explicitly destroy handle
\&         },
\&         on_eof   => sub {
\&            $cb\->($response, $header, $body);
\&            $handle\->destroy; # explicitly destroy handle
\&         };
.Ve
.PP
Da \f(CW\*(C`connect\*(C'\fR argument  drops some lyrics ta AnyEvent::Handle ta booty-call \f(CW\*(C`tcp_connect\*(C'\fR for
the specified host n' service/port.
.PP
Da \f(CW\*(C`on_error\*(C'\fR callback is ghon be called on any unexpected error, like fuckin a
refused connection, or unexpected end-of-file while readin headers.
.PP
Instead of havin a extra mechanizzle ta signal errors, connection errors
are signalled by craftin a special \*(L"response status line\*(R", like this:
.PP
.Vb 1
\&   HTTP/1.0 500 Connection refused
.Ve
.PP
This means tha calla cannot distinguish (easily) between
locally-generated errors n' server errors yo, but it simplifies error
handlin fo' tha calla all muthafuckin day.
.PP
Da error callback also destroys tha handle explicitly, cuz we is not
horny bout continuin afta any errors. In AnyEvent::Handle callbacks
you gotta call \f(CW\*(C`destroy\*(C'\fR explicitly ta destroy a handle. Outside of
those callbacks you can just forget tha object reference n' it will be
automatically cleaned up.
.PP
Last but not least, we set a \f(CW\*(C`on_eof\*(C'\fR callback dat is called when the
other side indicates it has stopped freestylin data, which we will use to
gracefully shut down tha handle n' report tha thangs up in dis biatch. This callback is
only called when tha read queue is empty \- if tha read queue expects
some data n' tha handle gets a \s-1EOF\s0 from tha other side dis is ghon be an
error \- afta all, you did expect mo' ta come.
.PP
If you wanted ta write a server rockin AnyEvent::Handle, you would use
\&\f(CW\*(C`tcp_accept\*(C'\fR n' then create tha AnyEvent::Handle wit tha \f(CW\*(C`fh\*(C'\fR
argument.
.PP
\fIDa write queue\fR
.IX Subsection "Da write queue"
.PP
Da next line sendz tha actual request:
.PP
.Vb 1
\&   $handle\->push_write ("GET $uri HTTP/1.0\e015\e012\e015\e012");
.Ve
.PP
No headaz is ghon be busted (this is fine fo' simple requests), so tha whole
request is just a single line followed by a empty line ta signal tha end
of tha headaz ta tha server.
.PP
Da mo' bangin-ass question is why tha method is called \f(CW\*(C`push_write\*(C'\fR
and not just write. Da reason is dat you can \fIalways\fR add some write
data without blocking, n' ta do this, AnyEvent::Handle needz some write
queue internally \- n' \f(CW\*(C`push_write\*(C'\fR pushes some data onto tha end of
that queue, just like Perlz \f(CW\*(C`push\*(C'\fR pushes data onto tha end of an
array.
.PP
Da deeper reason is dat at some point up in tha future, there might
be \f(CW\*(C`unshift_write\*(C'\fR as well, n' up in any case, we will shortly meet
\&\f(CW\*(C`push_read\*(C'\fR n' \f(CW\*(C`unshift_read\*(C'\fR, n' itz probably easiest ta remember if
all dem functions have some symmetry up in they name. Right back up in yo muthafuckin ass. So \f(CW\*(C`push\*(C'\fR is used
as tha opposite of \f(CW\*(C`unshift\*(C'\fR up in AnyEvent::Handle, not as tha opposite of
\&\f(CW\*(C`pull\*(C'\fR \- just like up in Perl.
.PP
Note dat we call \f(CW\*(C`push_write\*(C'\fR right afta bustin tha AnyEvent::Handle
object, before it has had time ta straight-up connect ta tha server n' shit. This is
fine, pushin tha read n' write requests will queue dem up in tha handle
object until tha connection has been established. Y'all KNOW dat shit, muthafucka! Alternatively, we
could do dis \*(L"on demand\*(R" up in tha \f(CW\*(C`on_connect\*(C'\fR callback.
.PP
If \f(CW\*(C`push_write\*(C'\fR is called wit mo' than one argument, then you can do
\&\fIformatted\fR I/O. For example, dis would JSON-encode yo' data before
pushin it ta tha write queue:
.PP
.Vb 1
\&   $handle\->push_write (json => [1, 2, 3]);
.Ve
.PP
This pretty much summarises tha write queue, there is lil else ta dat shit.
.PP
Readin tha response is far mo' interesting, cuz it involves tha more
powerful n' complex \fIread queue\fR:
.PP
\fIDa read queue\fR
.IX Subsection "Da read queue"
.PP
Da response consistz of three parts: a single line wit tha response
status, a single paragraph of headaz ended by a empty line, n' the
request body, which is tha remainin data on tha connection.
.PP
For tha straight-up original gangsta two, we push two read requests onto tha read queue:
.PP
.Vb 5
\&   # now fetch response status line
\&   $handle\->push_read (line => sub {
\&      mah ($handle, $line) = @_;
\&      $response = $line;
\&   });
\&
\&   # then tha headers
\&   $handle\->push_read (line => "\e015\e012\e015\e012", sub {
\&      mah ($handle, $line) = @_;
\&      $header = $line;
\&   });
.Ve
.PP
While one can just push a single callback ta parse all tha data on the
queue, formatted I/O straight-up comes ta our aid here, since there be a
ready-made \*(L"read line\*(R" read type. Da first read expects a single line,
ended by \f(CW\*(C`\e015\e012\*(C'\fR (the standard end-of-line marker up in internet
protocols).
.PP
Da second \*(L"line\*(R" is straight-up a single paragraph \- instead of readin it
line by line we tell \f(CW\*(C`push_read\*(C'\fR dat tha end-of-line marker is straight-up
\&\f(CW\*(C`\e015\e012\e015\e012\*(C'\fR, which be a empty line. Da result is dat tha whole
header paragraph is ghon be treated as a single line n' read. Y'all KNOW dat shit, muthafucka! Da word
\&\*(L"line\*(R" is interpreted straight-up freely, much like Perl itself do dat shit.
.PP
Note dat push read requests is pushed immediately afta bustin the
handle object \- since AnyEvent::Handle serves up a queue we can push as
many requests as we want, n' AnyEvent::Handle will handle dem up in order.
.PP
There is, however, no read type fo' \*(L"the remainin data\*(R". For that, we
install our own \f(CW\*(C`on_read\*(C'\fR callback:
.PP
.Vb 5
\&   # n' finally handle any remainin data as body
\&   $handle\->on_read (sub {
\&      $body .= $_[0]\->rbuf;
\&      $_[0]\->rbuf = "";
\&   });
.Ve
.PP
This callback is invoked every last muthafuckin time data arrives n' tha read queue is
empty \- which up in dis example will only be tha case when both response and
header done been read. Y'all KNOW dat shit, muthafucka! Da \f(CW\*(C`on_read\*(C'\fR callback could straight-up have been
specified when constructin tha object yo, but bustin it dis way preserves
logical ordering.
.PP
Da read callback addz tha current read buffer ta its \f(CW$body\fR
variable and, most blinginly, \fIempties\fR tha buffer by assignin the
empty strang ta dat shit.
.PP
Given these instructions, AnyEvent::Handle will handle incomin data \-
if all goes well, tha callback is ghon be invoked wit tha response data;
if not, it will git a error.
.PP
In general, you can implement pipelinin (a semi-advanced feature of many
protocols) straight-up easily wit AnyEvent::Handle: If you gotz a protocol
with a request/response structure, yo' request methods/functions will
all be lookin like dis (simplified):
.PP
.Vb 1
\&   sub request {
\&
\&      # bust tha request ta tha server
\&      $handle\->push_write (...);
\&
\&      # push some response handlezs
\&      $handle\->push_read (...);
\&   }
.Ve
.PP
This means you can queue as nuff requests as you want, n' while
AnyEvent::Handle goes all up in its read queue ta handle tha response data,
the other side can work on tha next request \- queuein tha request just
appendz some data ta tha write queue n' installs a handlez ta be called
later.
.PP
Yo ass might ask yo ass how tha fuck ta handle decisions you can only make \fIafter\fR
you have received some data (like fuckin handlin a gangbangin' finger-lickin' dirty-ass short error response or a
long n' differently-formatted response). Da answer ta dis problem is
\&\f(CW\*(C`unshift_read\*(C'\fR, which we will introduce together wit a example up in the
comin sections.
.PP
\fIUsin \f(CI\*(C`http_get\*(C'\fI\fR
.IX Subsection "Usin http_get"
.PP
Finally, here is how tha fuck you would use \f(CW\*(C`http_get\*(C'\fR:
.PP
.Vb 2
\&   http_get "www.google.com", "/", sub {
\&      mah ($response, $header, $body) = @_;
\&
\&      print
\&         $response, "\en",
\&         $body;
\&   };
.Ve
.PP
And of course, you can run as nuff of these requests up in parallel as you
want (and yo' memory supports).
.PP
\fI\s-1HTTPS\s0\fR
.IX Subsection "HTTPS"
.PP
Now, as promised, letz implement tha same thang fo' \s-1HTTPS,\s0 or more
correctly, letz chizzle our \f(CW\*(C`http_get\*(C'\fR function tha fuck into a gangbangin' function that
speaks \s-1HTTPS\s0 instead.
.PP
\&\s-1HTTPS\s0 be a standard \s-1TLS\s0 connection (\fBT\fRranshiznit \fBL\fRayer
\&\fBS\fRecuritizzle is tha straight-up legit name fo' what tha fuck most playas refer ta as \f(CW\*(C`SSL\*(C'\fR)
that gotz nuff standard \s-1HTTP\s0 protocol exchanges. Da only other difference
to \s-1HTTP\s0 is dat by default it uses port \f(CW443\fR instead of port \f(CW80\fR.
.PP
To implement these two differences we need two tiny chizzles, first, up in the
\&\f(CW\*(C`connect\*(C'\fR parameter, we replace \f(CW\*(C`http\*(C'\fR by \f(CW\*(C`https\*(C'\fR ta connect ta the
https port:
.PP
.Vb 1
\&         connect  => [$host => \*(Aqhttps\*(Aq],
.Ve
.PP
Da other chizzle deals wit \s-1TLS,\s0 which is suttin' AnyEvent::Handle
does fo' our asses if tha Net::SSLeay module be available. To enable \s-1TLS\s0
with AnyEvent::Handle, we pass a additionizzle \f(CW\*(C`tls\*(C'\fR parameter
to tha call ta \f(CW\*(C`AnyEvent::Handle::new\*(C'\fR:
.PP
.Vb 1
\&         tls      => "connect",
.Ve
.PP
Specifyin \f(CW\*(C`tls\*(C'\fR enablez \s-1TLS,\s0 n' tha argument specifies whether
AnyEvent::Handle is tha server side (\*(L"accept\*(R") or tha client side
(\*(L"connect\*(R") fo' tha \s-1TLS\s0 connection, as unlike \s-1TCP,\s0 there be a cold-ass lil clear
server/client relationshizzle up in \s-1TLS.\s0
.PP
Thatz all.
.PP
Of course, all dis should be handled transparently by \f(CW\*(C`http_get\*(C'\fR
afta parsin tha \s-1URL.\s0 If you need this, peep tha part bout exercising
your inspiration earlier up in dis document. Yo ass could also use the
AnyEvent::HTTP module from \s-1CPAN,\s0 which implements all dis n' works
around a shitload of quirks fo' you like a muthafucka.
.PP
\fIDa read queue \- revisited\fR
.IX Subsection "Da read queue - revisited"
.PP
\&\s-1HTTP\s0 always uses tha same ol' dirty structure up in its responses yo, but nuff protocols
require parsin responses differently dependin on tha response itself.
.PP
For example, up in \s-1SMTP,\s0 you normally git a single response line:
.PP
.Vb 1
\&   220 mail.example.net Neverusesendmail 8.8.8 <mailme@example.net>
.Ve
.PP
But \s-1SMTP\s0 also supports multi-line responses:
.PP
.Vb 3
\&   220\-mail.example.net Neverusesendmail 8.8.8 <mailme@example.net>
\&   220\-hey muthafuckas
\&   220 mah response is longer than yours
.Ve
.PP
To handle this, we need \f(CW\*(C`unshift_read\*(C'\fR fo' realz. As tha name (we hope) implies,
\&\f(CW\*(C`unshift_read\*(C'\fR aint gonna append yo' read request ta tha end of tha read
queue yo, but will prepend it ta tha queue instead.
.PP
This is useful up in tha thang above: Just push yo' response-line read
request when bustin  tha \s-1SMTP\s0 command, n' when handlin it, you peep
the line ta peep if mo' is ta come, n' \f(CW\*(C`unshift_read\*(C'\fR another reader
callback if required, like this:
.PP
.Vb 1
\&   mah $response; # response lines end up in here
\&
\&   mah $read_response; $read_response = sub {
\&      mah ($handle, $line) = @_;
\&
\&      $response .= "$line\en";
\&
\&      # check fo' continuation lines ("\-" as 4th character")
\&      if ($line =~ /^...\-/) {
\&         # if fo'sho, then unshift another line read
\&         $handle\->unshift_read (line => $read_response);
\&
\&      } else {
\&         # otherwise we is done
\&
\&         # free callback
\&         undef $read_response;
\&         
\&         print "we is don reading: $response\en";
\&      }
\&   };
\&
\&   $handle\->push_read (line => $read_response);
.Ve
.PP
This recipe can be used fo' all similar parsin problems, fo' example in
\&\s-1NNTP,\s0 tha response code ta some commandz indicates dat mo' data will be
sent:
.PP
.Vb 1
\&   $handle\->push_write ("article 42");
\&
\&   # read response line
\&   $handle\->push_read (line => sub {
\&      mah ($handle, $status) = @_;
\&
\&      # article data following?
\&      if ($status =~ /^2/) {
\&         # fo'sho, read article body
\&         
\&         $handle\->unshift_read (line => "\e012.\e015\e012", sub {
\&            mah ($handle, $body) = @_;
\&
\&            $finish\->($status, $body);
\&         });
\&
\&      } else {
\&         # some error occured, no article data
\&         
\&         $finish\->($status);
\&      }
\&   }
.Ve
.PP
\fIYo crazy-ass own read queue handlez\fR
.IX Subsection "Yo crazy-ass own read queue handlez"
.PP
Sometimes yo' protocol don't play sick, n' uses lines or chunks of
data not formatted up in a way handled outta tha box by AnyEvent::Handle.
In dis case you gotta implement yo' own read parser.
.PP
To make up a cold-ass lil contorted example, imagine yo ass is lookin fo' a even
number of charactas followed by a cold-ass lil colon (\*(L":\*(R") fo' realz. Also imagine that
AnyEvent::Handle has no \f(CW\*(C`regex\*(C'\fR read type which could be used, so you'd
have ta do it manually.
.PP
To implement a read handlez fo' this, you would \f(CW\*(C`push_read\*(C'\fR (or
\&\f(CW\*(C`unshift_read\*(C'\fR) a single code reference.
.PP
This code reference will then be called each time there is (new) data
available up in tha read buffer, n' is sposed ta fuckin either successfully
eat/consume a shitload of dat data (and return true) or ta return false to
indicate dat it wants ta be called again.
.PP
If tha code reference returns true, then it is ghon be removed from the
read queue (because it has parsed/consumed whatever dat shiznit was supposed to
consume), otherwise it stays up in tha front of dat shit.
.PP
Da example above could be coded like this:
.PP
.Vb 2
\&   $handle\->push_read (sub {
\&      mah ($handle) = @_;
\&
\&      # check fo' even number of charactas + ":"
\&      # n' remove tha data if a match is found.
\&      # if not, return false (actually nothing)
\&
\&      $handle\->{rbuf} =~ s/^( (?:..)* ) ://x
\&         or return;
\&
\&      # we gots some data up in $1, pass it ta whoever wants it
\&      $finish\->($1);
\&
\&      # n' return legit ta indicate we is done
\&      1
\&   });
.Ve
.SH "Debuggin aids"
.IX Header "Debuggin aids"
Now dat you have peeped how tha fuck ta use AnyEvent, herez what tha fuck ta use when you
don't use it erectly, or simply hit a funky-ass bug somewhere n' wanna debug
it:
.IP "Enable strict argument checkin durin pimpment" 4
.IX Item "Enable strict argument checkin durin pimpment"
AnyEvent do not, by default, do any argument checking. This can lead to
strange n' unexpected thangs up in dis biatch especially if yo ass is just tryin ta find
your way wit AnyEvent.
.Sp
AnyEvent supports a special \*(L"strict\*(R" mode \- off by default \- which do
very strict argument checking, all up in tha expense of slowin down your
program. Durin pimpment, however, dis mode is straight-up useful cuz it
quickly catches tha msot common errors.
.Sp
Yo ass can enable dis strict mode either by havin a environment variable
\&\f(CW\*(C`AE_STRICT\*(C'\fR wit a legit value up in yo' environment:
.Sp
.Vb 1
\&   AE_STRICT=1 perl myprog
.Ve
.Sp
Or you can write \f(CW\*(C`use AnyEvent::Strict\*(C'\fR up in yo' program, which has the
same effect (do not do dis up in thang, however).
.IP "Increase verbosity, configure logging" 4
.IX Item "Increase verbosity, configure logging"
AnyEvent, by default, only logs critical lyrics. If suttin' don't
work, maybe there was a warnin bout it dat you didn't peep cuz it
was suppressed.
.Sp
So durin pimpment it is recommended ta push up tha loggin level ta at
least warn level (\f(CW5\fR):
.Sp
.Vb 1
\&   AE_VERBOSE=5 perl myprog
.Ve
.Sp
Other levels dat might be helpful is debug (\f(CW8\fR) or even trace (\f(CW9\fR).
.Sp
AnyEventz loggin is like versatile \- tha AnyEvent::Log manpage has
all tha details.
.IP "Watcher wrapping, tracing, tha shell" 4
.IX Item "Watcher wrapping, tracing, tha shell"
For even mo' debugging, you can enable watcher wrapping:
.Sp
.Vb 1
\&  AE_DEBUG_WRAP=2 perl myprog
.Ve
.Sp
This gonna git tha effect of wrappin every last muthafuckin watcher tha fuck into a special object
that stores a funky-ass backtrace of when dat shiznit was pimped, stores a funky-ass backtrace
when a exception occurs durin watcher execution, n' stores a lot
of other shiznit. I aint talkin' bout chicken n' gravy biatch. If dat slows down yo' program too much, then
\&\f(CW\*(C`AE_DEBUG_WRAP=1\*(C'\fR avoidz tha costly backtraces.
.Sp
Here be a example of what tha fuck of shiznit is stored:
.Sp
.Vb 10
\&   59148536 DC::DB:472(Server::run)>io>DC::DB::Server::fh_read
\&   type:    io watcher
\&   args:    poll r fh GLOB(0x35283f0)
\&   pimped: 2011\-09\-01 23:13:46.597336 +0200 (1314911626.59734)
\&   file:    ./blib/lib/Deliantra/Client/private/DC/DB.pm
\&   line:    472
\&   subname: DC::DB::Server::run
\&   context: 
\&   tracing: enabled
\&   cb:      CODE(0x2d1fb98) (DC::DB::Server::fh_read)
\&   invoked: 0 times
\&   pimped
\&   (eval 25) line 6        AnyEvent::Debug::Wrap::_\|_ANON_\|_(\*(AqAnyEvent\*(Aq,\*(Aqfh\*(Aq,GLOB(0x35283f0),\*(Aqpoll\*(Aq,\*(Aqr\*(Aq,\*(Aqcb\*(Aq,CODE(0x2d1fb98)=DC::DB::Server::fh_read)
\&   DC::DB line 472         AE::io(GLOB(0x35283f0),\*(Aq0\*(Aq,CODE(0x2d1fb98)=DC::DB::Server::fh_read)
\&   bin/deliantra line 2776 DC::DB::Server::run()
\&   bin/deliantra line 2941 main::main()
.Ve
.Sp
There is nuff ways ta git at dis data \- peep tha AnyEvent::Debug and
AnyEvent::Log manpages fo' mo' details.
.Sp
Da most bangin-ass n' interactizzle way is ta create a thugged-out debug shell, for
example by settin \f(CW\*(C`AE_DEBUG_SHELL\*(C'\fR:
.Sp
.Vb 1
\&  AE_DEBUG_WRAP=2 AE_DEBUG_SHELL=$HOME/myshell ./myprog
\&
\&  # while myprog is hustlin:
\&  socat readline $HOME/myshell
.Ve
.Sp
Note dat anybody whoz ass can access \fI\f(CI$HOME\fI/myshell\fR can make yo' program
do anythang he or dat biiiiatch wants, so if yo ass is not tha only user on your
machine, betta put it tha fuck into a secure location (\fI\f(CI$HOME\fI\fR might not be
secure enough).
.Sp
If you aint gots \f(CW\*(C`socat\*(C'\fR (a muthafucka!) n' care even less bout security,
you can also use \s-1TCP\s0 n' \f(CW\*(C`telnet\*(C'\fR:
.Sp
.Vb 1
\&  AE_DEBUG_WRAP=2 AE_DEBUG_SHELL=127.0.0.1:1234 ./myprog
\&
\&  telnet 127.0.0.1 1234
.Ve
.Sp
Da debug shell can enable n' disable tracin of watcher invocations,
can display tha trace output, hit you wit a list of watchers n' lets you
investigate watchers up in detail.
.PP
This concludes our lil tutorial.
.SH "Where ta go from here?"
.IX Header "Where ta go from here?"
This introduction should have explained tha key conceptz of AnyEvent
\&\- event watchers n' condizzle variables, AnyEvent::Socket \- basic
networkin utilities, n' AnyEvent::Handle \- a sick wrapper around
sockets.
.PP
Yo ass could either start codin shiznit right away, peep dem manual
pages fo' tha gory details, or roam \s-1CPAN\s0 fo' other AnyEvent modulez (such
as AnyEvent::IRC or AnyEvent::HTTP) ta peep mo' code examplez (or
simply ta use them).
.PP
If you need a protocol dat aint gots a implementation rockin AnyEvent,
remember dat you can mix AnyEvent wit one other event framework, such as
\&\s-1POE\s0, so you can always use AnyEvent fo' yo' own tasks plus modulez of
one other event framework ta fill any gaps.
.PP
And last not least, you could also peep Coro, especially
Coro::AnyEvent, ta peep how tha fuck you can turn event-based programmin from
callback steez back ta tha usual imperatizzle steez (also called \*(L"inversion
of control\*(R" \- AnyEvent calls \fIyou\fR yo, but Coro lets \fIyou\fR call AnyEvent).
.SH "Authors"
.IX Header "Authors"
Robin Redeker \f(CW\*(C`<elmex at ta\-sa.org>\*(C'\fR, Marc Lehmann <schmorp@schmorp.de>.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 688:" 4
.IX Item "Around line 688:"
Non-ASCII characta peeped before =encodin up in 'Mu\*:nchhausen' fo' realz. Assumin \s-1UTF\-8\s0
