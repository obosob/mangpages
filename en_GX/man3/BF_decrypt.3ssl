.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "blowfish 3"
.TH blowfish 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
blowfish, BF_set_key, BF_encrypt, BF_decrypt, BF_ecb_encrypt, BF_cbc_encrypt,
BF_cfb64_encrypt, BF_ofb64_encrypt, BF_options \- Blowfish encryption
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/blowfish.h>
\&
\& void BF_set_key(BF_KEY *key, int len, const unsigned char *data);
\&
\& void BF_ecb_encrypt(const unsigned char *in, unsigned char *out,
\&         BF_KEY *key, int enc);
\& void BF_cbc_encrypt(const unsigned char *in, unsigned char *out,
\&         long length, BF_KEY *schedule, unsigned char *ivec, int enc);
\& void BF_cfb64_encrypt(const unsigned char *in, unsigned char *out,
\&         long length, BF_KEY *schedule, unsigned char *ivec, int *num,
\&         int enc);
\& void BF_ofb64_encrypt(const unsigned char *in, unsigned char *out,
\&         long length, BF_KEY *schedule, unsigned char *ivec, int *num);
\& const char *BF_options(void);
\&
\& void BF_encrypt(BF_LONG *data,const BF_KEY *key);
\& void BF_decrypt(BF_LONG *data,const BF_KEY *key);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This library implements tha Blowfish cipher, which was invented n' busted lyrics about
by Counterpane (see http://www.counterpane.com/blowfish.html ).
.PP
Blowfish be a funky-ass block cipher dat operates on 64 bit (8 byte) blockz of data.
It uses a variable size key yo, but typically, 128 bit (16 byte) keys are
considered phat fo' phat encryption. I aint talkin' bout chicken n' gravy biatch.  Blowfish can be used up in tha same
modes as \s-1DES \s0(see \fIdes_modes\fR\|(7)).  Blowfish is currently one
of tha fasta block ciphers.  It be like a lil' bit fasta than \s-1DES,\s0 n' much
fasta than \s-1IDEA\s0 or \s-1RC2.\s0
.PP
Blowfish consistz of a key setup phase n' tha actual encryption or decryption
phase.
.PP
\&\fIBF_set_key()\fR sets up tha \fB\s-1BF_KEY\s0\fR \fBkey\fR rockin tha \fBlen\fR bytes long key
at \fBdata\fR.
.PP
\&\fIBF_ecb_encrypt()\fR is tha basic Blowfish encryption n' decryption function.
It encrypts or decrypts tha straight-up original gangsta 64 bitz of \fBin\fR rockin tha key \fBkey\fR,
puttin tha result up in \fBout\fR.  \fBenc\fR decides if encryption (\fB\s-1BF_ENCRYPT\s0\fR)
or decryption (\fB\s-1BF_DECRYPT\s0\fR) shall be performed. Y'all KNOW dat shit, muthafucka!  Da vector pointed at by
\&\fBin\fR n' \fBout\fR must be 64 bits up in length, no less.  If they is larger,
everythang afta tha straight-up original gangsta 64 bits is ignored.
.PP
Da mode functions \fIBF_cbc_encrypt()\fR, \fIBF_cfb64_encrypt()\fR n' \fIBF_ofb64_encrypt()\fR
all operate on variable length data.  They all take a initialization vector
\&\fBivec\fR which need ta be passed along tha fuck into tha next call of tha same function 
for tha same message.  \fBivec\fR may be initialized wit anythang yo, but the
recipient need ta know what tha fuck dat shiznit was initialized with, or it won't be able
to decrypt.  Some programs n' protocols simplify this, like \s-1SSH,\s0 where
\&\fBivec\fR is simply initialized ta zero.
\&\fIBF_cbc_encrypt()\fR operates on data dat be a multiple of 8 bytes long, while
\&\fIBF_cfb64_encrypt()\fR n' \fIBF_ofb64_encrypt()\fR is used ta encrypt a variable
number of bytes (the amount do not gotta be a exact multiple of 8).  The
purpose of tha latta two is ta simulate stream ciphers, n' therefore, they
need tha parameta \fBnum\fR, which be a pointa ta a integer where tha current
offset up in \fBivec\fR is stored between calls.  This integer must be initialized
to zero when \fBivec\fR is initialized.
.PP
\&\fIBF_cbc_encrypt()\fR is tha Cipher Block Chainin function fo' Blowfish.  It
encrypts or decrypts tha 64 bits chunkz of \fBin\fR rockin tha key \fBschedule\fR,
puttin tha result up in \fBout\fR.  \fBenc\fR decides if encryption (\s-1BF_ENCRYPT\s0) or
decryption (\s-1BF_DECRYPT\s0) shall be performed. Y'all KNOW dat shit, muthafucka!  \fBivec\fR must point at a 8 byte
long initialization vector.
.PP
\&\fIBF_cfb64_encrypt()\fR is tha \s-1CFB\s0 mode fo' Blowfish wit 64 bit feedback.
It encrypts or decrypts tha bytes up in \fBin\fR rockin tha key \fBschedule\fR,
puttin tha result up in \fBout\fR.  \fBenc\fR decides if encryption (\fB\s-1BF_ENCRYPT\s0\fR)
or decryption (\fB\s-1BF_DECRYPT\s0\fR) shall be performed. Y'all KNOW dat shit, muthafucka!  \fBivec\fR must point at an
8 byte long initialization vector. Shiiit, dis aint no joke. \fBnum\fR must point at a integer which must
be initially zero.
.PP
\&\fIBF_ofb64_encrypt()\fR is tha \s-1OFB\s0 mode fo' Blowfish wit 64 bit feedback.
It uses tha same ol' dirty parametas as \fIBF_cfb64_encrypt()\fR, which must be initialized
the same way.
.PP
\&\fIBF_encrypt()\fR n' \fIBF_decrypt()\fR is tha lowest level functions fo' Blowfish
encryption. I aint talkin' bout chicken n' gravy biatch.  They encrypt/decrypt tha straight-up original gangsta 64 bitz of tha vector pointed by
\&\fBdata\fR, rockin tha key \fBkey\fR.  These functions should not be used unless you
implement 'modes' of Blowfish.  Da alternatizzle is ta use \fIBF_ecb_encrypt()\fR.
If you still wanna use these functions, you should be aware dat they take
each 32\-bit chunk up in host-byte order, which is lil-endian on lil-endian
platforms n' big-endian on big-endian ones.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
None of tha functions presented here return any value.
.SH "NOTE"
.IX Header "NOTE"
Applications should use tha higher level functions
\&\fIEVP_EncryptInit\fR\|(3) etc. instead of callin the
blowfish functions directly.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIdes_modes\fR\|(7)
.SH "HISTORY"
.IX Header "HISTORY"
Da Blowfish functions is available up in all versionz of SSLeay n' OpenSSL.
