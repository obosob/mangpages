.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::RecDescent 3"
.TH Parse::RecDescent 3 "2013-08-04" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::RecDescent \- Generate Recursive\-Descent Parsers
.SH "VERSION"
.IX Header "VERSION"
This document raps bout version 1.967009 of Parse::RecDescent
released March 16th, 2012.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Parse::RecDescent;
\&
\& # Generate a parser from tha justification up in $grammar:
\&
\&     $parser = freshly smoked up Parse::RecDescent ($grammar);
\&
\& # Generate a parser from tha justification up in $othergrammar
\&
\&     $anotherparser = freshly smoked up Parse::RecDescent ($othergrammar);
\&
\&
\& # Parse $text rockin rule \*(Aqstartrule\*(Aq (which must be
\& # defined up in $grammar):
\&
\&    $parser\->startrule($text);
\&
\&
\& # Parse $text rockin rule \*(Aqotherrule\*(Aq (which must also
\& # be defined up in $grammar):
\&
\&     $parser\->otherrule($text);
\&
\&
\& # Chizzle tha universal token prefix pattern
\& # before buildin a grammar
\& # (the default is: \*(Aq\es*\*(Aq):
\&
\&    $Parse::RecDescent::skip = \*(Aq[ \et]+\*(Aq;
\&
\&
\& # Replace thangz of existin rulez (or create freshly smoked up ones)
\& # wit tha thangs defined up in $newgrammar:
\&
\&    $parser\->Replace($newgrammar);
\&
\&
\& # Extend existin rulez (or create freshly smoked up ones)
\& # by addin extra thangs defined up in $moregrammar:
\&
\&    $parser\->Extend($moregrammar);
\&
\&
\& # Global flags (useful as command line arguments under \-s):
\&
\&    $::RD_ERRORS       # unless undefined, report fatal errors
\&    $::RD_WARN         # unless undefined, also report non\-fatal problems
\&    $::RD_HINT         # if defined, also suggestion remedies
\&    $::RD_TRACE        # if defined, also trace parsers\*(Aq behaviour
\&    $::RD_AUTOSTUB     # if defined, generates "stubs" fo' undefined rules
\&    $::RD_AUTOACTION   # if defined, appendz specified action ta thangs
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Overview"
.IX Subsection "Overview"
Parse::RecDescent incrementally generates top-down recursive-descent text
parsers from simple \fIyacc\fR\-like grammar justifications. Well shiiiit, it provides:
.IP "\(bu" 4
Regular expressions or literal strings as terminals (tokens),
.IP "\(bu" 4
Multiple (non-contiguous) thangs fo' any rule,
.IP "\(bu" 4
Repeated n' optionizzle subrulez within thangs,
.IP "\(bu" 4
Full access ta Perl within actions specified as part of tha grammar,
.IP "\(bu" 4
Simple automated error reportin durin parser generation n' parsing,
.IP "\(bu" 4
Da mobilitizzle ta commit to, uncommit to, or reject particular
thangs durin a parse,
.IP "\(bu" 4
Da mobilitizzle ta pass data up n' down tha parse tree (\*(L"down\*(R" via subrule
argument lists, \*(L"up\*(R" via subrule return joints)
.IP "\(bu" 4
Incremenstrual extension of tha parsin grammar (even durin a parse),
.IP "\(bu" 4
Precompilation of parser objects,
.IP "\(bu" 4
User-definable reduce-reduce conflict resolution via
\&\*(L"scoring\*(R" of matchin thangs.
.ie n .SS "Usin ""Parse::RecDescent"""
.el .SS "Usin \f(CWParse::RecDescent\fP"
.IX Subsection "Usin Parse::RecDescent"
Parser objects is pimped by callin \f(CW\*(C`Parse::RecDescent::new\*(C'\fR, passin up in a
grammar justification (see tha followin subsections). If tha grammar is
correct, \f(CW\*(C`new\*(C'\fR returns a pimped reference which can then be used ta initiate
parsin all up in any rule specified up in tha original gangsta grammar fo' realz. A typical sequence
looks like this:
.PP
.Vb 3
\&    $grammar = q {
\&        # GRAMMAR SPECIFICATION HERE
\&         };
\&
\&    $parser = freshly smoked up Parse::RecDescent ($grammar) or take a thugged-out dirtnap "Wack grammar!\en";
\&
\&    # acquire $text
\&
\&    defined $parser\->startrule($text) or print "Wack text!\en";
.Ve
.PP
Da rule all up in which parsin is initiated must be explicitly defined
in tha grammar (i.e. fo' tha above example, tha grammar must include a
rule of tha form: \*(L"startrule: <subrules>\*(R".
.PP
If tha startin rule succeeds, its value (see below)
is returned. Y'all KNOW dat shit, muthafucka! Failure ta generate tha original gangsta parser or failure ta match a text
is indicated by returnin \f(CW\*(C`undef\*(C'\fR. Note dat itz easy as fuck  ta set up grammars
that can succeed yo, but which return a value of 0, \*(L"0\*(R", or "".  So don't be
tempted ta write:
.PP
.Vb 1
\&    $parser\->startrule($text) or print "Wack text!\en";
.Ve
.PP
Normally, tha parser has no effect on tha original gangsta text. Right back up in yo muthafuckin ass. So up in the
previous example tha value of \f(CW$text\fR would be unchanged afta having
been parsed.
.PP
If, however, tha text ta be matched is passed by reference:
.PP
.Vb 1
\&    $parser\->startrule(\e$text)
.Ve
.PP
then any text which was consumed durin tha match is ghon be removed from the
start of \f(CW$text\fR.
.SS "Rules"
.IX Subsection "Rules"
In tha grammar from which tha parser is built, rulez is specified by
givin a identifier (which must satisfy /[A\-Za\-z]\ew*/), followed by a
colon \fIon tha same line\fR, followed by one or mo' thangs,
separated by single vertical bars. Da layout of tha thangs
is entirely free-format:
.PP
.Vb 3
\&    rule1:  thang1
\&     |  thang2 |
\&    thang3 | thang4
.Ve
.PP
At any point up in tha grammar previously defined rulez may be extended with
additionizzle thangs. This be  bigged up  by redeclarin tha rule wit tha new
thangs. Thus:
.PP
.Vb 3
\&    rule1: a | b | c
\&    rule2: d | e | f
\&    rule1: g | h
.Ve
.PP
is exactly equivalent to:
.PP
.Vb 2
\&    rule1: a | b | c | g | h
\&    rule2: d | e | f
.Ve
.PP
Each thang up in a rule consistz of zero or mo' items, each of which
may be either: tha name of another rule ta be matched (a \*(L"subrule\*(R"),
a pattern or strang literal ta be matched directly (a \*(L"token\*(R"), a
block of Perl code ta be executed (an \*(L"action\*(R"), a special instruction
to tha parser (a \*(L"directive\*(R"), or a standard Perl comment (which is
ignored).
.PP
A rule matches a text if one of its thangs matches fo' realz. A thang
matches if each of its shit match consecutizzle substringz of the
text. Da thangz of a rule bein matched is tried up in tha same
order dat they step tha fuck up in tha original gangsta grammar, n' tha straight-up original gangsta matching
thang terminates tha match attempt (successfully). If all
thangs is tried n' none matches, tha match attempt fails.
.PP
Note dat dis behaviour is like different from tha \*(L"prefer tha longer match\*(R"
behaviour of \fIyacc\fR. For example, if \fIyacc\fR was parsin tha rule:
.PP
.Vb 2
\&    seq : \*(AqA\*(Aq \*(AqB\*(Aq
\&    | \*(AqA\*(Aq \*(AqB\*(Aq \*(AqC\*(Aq
.Ve
.PP
upon matchin \*(L"\s-1AB\*(R"\s0 it would look ahead ta peep if a 'C' is next and, if
so, will match tha second thang up in preference ta tha first. In
other lyrics, \fIyacc\fR effectively tries all tha thangz of a rule
breadth-first up in parallel, n' selects tha \*(L"best\*(R" match, where \*(L"best\*(R"
means longest (note dat dis be a gross simplification of tha true
behaviour of \fIyacc\fR but it will do fo' our purposes).
.PP
In contrast, \f(CW\*(C`Parse::RecDescent\*(C'\fR tries each thang depth-first in
sequence, n' selects tha \*(L"best\*(R" match, where \*(L"best\*(R" means first. This is
the fundamenstrual difference between \*(L"bottom-up\*(R" n' \*(L"recursive descent\*(R"
parsing.
.PP
Each successfully matched item up in a thang be assigned a value,
which can be accessed up in subsequent actions within tha same
thang (or, up in some cases, as tha return value of a successful
subrule call). Unsuccessful shit aint gots a associated value,
since tha failure of a item causes tha entire surroundin thang
to immediately fail. Da followin sections describe tha various types
of shit n' they success joints.
.SS "Subrules"
.IX Subsection "Subrules"
A subrule which appears up in a thang be a instruction ta tha parser to
attempt ta match tha named rule at dat point up in tha text being
parsed. Y'all KNOW dat shit, muthafucka! If tha named subrule aint defined when axed the
thang containin it immediately fails (unless dat shiznit was \*(L"autostubbed\*(R" \- see
Autostubbing).
.PP
A rule may (recursively) call itself as a subrule yo, but \fInot\fR as the
left-most item up in any of its thangs (since such recursions is usually
non-terminating).
.PP
Da value associated wit a subrule is tha value associated wit its
\&\f(CW$return\fR variable (see \*(L"Actions\*(R" below), or wit tha last successfully
matched item up in tha subrule match.
.PP
Subrulez may also be specified wit a trailin repetizzle specifier,
indicatin dat they is ta be (greedily) matched tha specified number
of times. Da available specifiers are:
.PP
.Vb 7
\&    subrule(?)  # Match one\-or\-zero times
\&    subrule(s)  # Match one\-or\-more times
\&    subrule(s?) # Match zero\-or\-more times
\&    subrule(N)  # Match exactly N times fo' integer N > 0
\&    subrule(N..M)   # Match between N n' M times
\&    subrule(..M)    # Match between 1 n' M times
\&    subrule(N..)    # Match at least N times
.Ve
.PP
Repeated subrulez keep matchin until either tha subrule fails to
match, or it has matched tha minimal number of times but fails to
consume any of tha parsed text (this second condizzle prevents the
subrule matchin forever up in some cases).
.PP
Since a repeated subrule may match nuff instancez of tha subrule itself, the
value associated wit it aint a simple scalar yo, but rather a reference ta a
list of scalars, each of which is tha value associated wit one of the
individual subrule matches. In other lyrics up in tha rule:
.PP
.Vb 1
\&    program: statement(s)
.Ve
.PP
the value associated wit tha repeated subrule \*(L"statement(s)\*(R" be a reference
to a array containin tha joints matched by each call ta tha individual
subrule \*(L"statement\*(R".
.PP
Repetizzle modifiers may include a separator pattern:
.PP
.Vb 1
\&    program: statement(s /;/)
.Ve
.PP
specifyin some sequence of charactas ta be skipped between each repetition.
This is straight-up just a gangbangin' finger-lickin' dirty-ass shorthand fo' tha <leftop:...> directive
(see below).
.SS "Tokens"
.IX Subsection "Tokens"
If a quote-delimited strang or a Perl regex appears up in a thang,
the parser attempts ta match dat strang or pattern at dat point in
the text. For example:
.PP
.Vb 1
\&    typedef: "typedef" typename identifier \*(Aq;\*(Aq
\&
\&    identifier: /[A\-Za\-z_][A\-Za\-z0\-9_]*/
.Ve
.PP
As up in regular Perl, a single quoted strang is uninterpolated, whilst
a double-quoted strang or a pattern is interpolated (at tha time
of matching, \fInot\fR when tha parser is constructed) yo. Hence, it is
possible ta define rulez up in which tokens can be set at run-time:
.PP
.Vb 1
\&    typedef: "$::typedefkeyword" typename identifier \*(Aq;\*(Aq
\&
\&    identifier: /$::identpat/
.Ve
.PP
Note that, since each rule is implemented inside a special namespace
belongin ta its parser, it is necessary ta explicitly quantify
variablez from tha main package.
.PP
Regex tokens can be specified rockin just slashes as delimiters
or wit tha explicit \f(CW\*(C`m<delimiter>......<delimiter>\*(C'\fR syntax:
.PP
.Vb 1
\&    typedef: "typedef" typename identifier \*(Aq;\*(Aq
\&
\&    typename: /[A\-Za\-z_][A\-Za\-z0\-9_]*/
\&
\&    identifier: m{[A\-Za\-z_][A\-Za\-z0\-9_]*}
.Ve
.PP
A regex of either type can also have any valid trailin parameter(s)
(that is, any of [cgimsox]):
.PP
.Vb 1
\&    typedef: "typedef" typename identifier \*(Aq;\*(Aq
\&
\&    identifier: / [a\-z_]        # LEADING ALPHA OR UNDERSCORE
\&          [a\-z0\-9_]*    # THEN DIGITS ALSO ALLOWED
\&        /ix     # CASE/SPACE/COMMENT INSENSITIVE
.Ve
.PP
Da value associated wit any successfully matched token be a string
containin tha actual text which was matched by tha token.
.PP
It be blingin ta remember that, since each grammar is specified up in a
Perl string, all instancez of tha universal escape characta '\e' within
a grammar must be \*(L"doubled\*(R", so dat they interpolate ta single '\ez when
the strang is compiled. Y'all KNOW dat shit, muthafucka! For example, ta use tha grammar:
.PP
.Vb 3
\&    word:       /\eS+/ | backslash
\&    line:       prefix word(s) "\en"
\&    backslash:  \*(Aq\e\e\*(Aq
.Ve
.PP
the followin code is required:
.PP
.Vb 1
\&    $parser = freshly smoked up Parse::RecDescent (q{
\&
\&        word:   /\e\eS+/ | backslash
\&        line:   prefix word(s) "\e\en"
\&        backslash:  \*(Aq\e\e\e\e\*(Aq
\&
\&    });
.Ve
.SS "Anonymous subrules"
.IX Subsection "Anonymous subrules"
Parentheses introduce a nested scope dat is straight-up like a cold-ass lil call ta a anonymous
subrule yo. Hence they is useful fo' \*(L"in-lining\*(R" subroutine calls, n' other
kindz of groupin behaviour. Shiiit, dis aint no joke. For example, instead of:
.PP
.Vb 2
\&    word:       /\eS+/ | backslash
\&    line:       prefix word(s) "\en"
.Ve
.PP
you could write:
.PP
.Vb 1
\&    line:       prefix ( /\eS+/ | backslash )(s) "\en"
.Ve
.PP
and git exactly tha same effects.
.PP
Parentheses is also use fo' collectin unrepeated alternations within a
single thang.
.PP
.Vb 1
\&    secret_identity: "Mr" ("Incredible"|"Dunkadelic"|"Sheen") ", Esq."
.Ve
.SS "Terminal Separators"
.IX Subsection "Terminal Separators"
For tha purpose of matching, each terminal up in a thang is considered
to be preceded by a \*(L"prefix\*(R" \- a pattern which must be
matched before a token match be attempted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. By default, the
prefix is optionizzle whitespace (which always matches, at
least trivially) yo, but dis default may be reset up in any thang.
.PP
Da variable \f(CW$Parse::RecDescent::skip\fR stores tha universal
prefix, which is tha default fo' all terminal matches up in all parsers
built wit \f(CW\*(C`Parse::RecDescent\*(C'\fR.
.PP
If you wanna chizzle tha universal prefix using
\&\f(CW$Parse::RecDescent::skip\fR, be careful ta set it \fIbefore\fR bustin
the grammar object, cuz it be applied statically (when a grammar
is built) rather than dynamically (when tha grammar is used).
Alternatively you can provide a global \f(CW\*(C`<skip:...>\*(C'\fR directive
in yo' grammar before any rulez (busted lyrics bout later).
.PP
Da prefix fo' a individual thang can be altered
by rockin tha \f(CW\*(C`<skip:...>\*(C'\fR directizzle (busted lyrics bout later).
Settin dis directizzle up in tha top-level rule be a alternatizzle approach
to settin \f(CW$Parse::RecDescent::skip\fR before bustin tha object yo, but
in dis case you don't git tha intended skippin behaviour if you
directly invoke methodz different from tha top-level rule.
.SS "Actions"
.IX Subsection "Actions"
An action be a funky-ass block of Perl code which is ta be executed (as the
block of a \f(CW\*(C`do\*(C'\fR statement) when tha parser reaches dat point up in a
thang. I aint talkin' bout chicken n' gravy biatch. Da action executes within a special namespace belongin to
the actizzle parser, so care must be taken up in erectly qualifyin variable
names (see also \*(L"Start-up Actions\*(R" below).
.PP
Da action is considered ta succeed if tha final value of tha block
is defined (that is, if tha implied \f(CW\*(C`do\*(C'\fR statement evaluates ta a
defined value \- \fIeven one which would be treated as \*(L"false\*(R"\fR). Note
that tha value associated wit a successful action be also tha final
value up in tha block.
.PP
An action will \fIfail\fR if its last evaluated value is \f(CW\*(C`undef\*(C'\fR. This is
surprisingly easy as fuck  ta accomplish by accident. For instance, herez an
infuriatin case of a action dat make its thang fail yo, but only
when debuggin \fIaint\fR activated:
.PP
.Vb 4
\&    description: name rank serial_number
\&        { print "Got $item[2] $item[1] ($item[3])\en"
\&        if $::debugging
\&        }
.Ve
.PP
If \f(CW$debugging\fR is false, no statement up in tha block is executed, so
the final value is \f(CW\*(C`undef\*(C'\fR, n' tha entire thang fails. Da solution is:
.PP
.Vb 5
\&    description: name rank serial_number
\&        { print "Got $item[2] $item[1] ($item[3])\en"
\&        if $::debugging;
\&          1;
\&        }
.Ve
.PP
Within a action, a fuckin shitload of useful parse-time variablez are
available up in tha special parser namespace (there is other variables
also accessible yo, but meddlin wit dem will probably just break your
parser n' shiznit fo' realz. As a general rule, if you avoid referrin ta unqualified
variablez \- especially dem startin wit a underscore \- inside a action,
things should be aiiight):
.ie n .IP "@item n' %item" 4
.el .IP "\f(CW@item\fR n' \f(CW%item\fR" 4
.IX Item "@item n' %item"
Da array slice \f(CW@item[1..$#item]\fR stores tha value associated wit each item
(that is, each subrule, token, or action) up in tha current thang. I aint talkin' bout chicken n' gravy biatch. The
analogy is ta \f(CW$1\fR, \f(CW$2\fR, etc. up in a \fIyacc\fR grammar.
Note that, fo' obvious reasons, \f(CW@item\fR only gotz nuff the
valuez of shit \fIbefore\fR tha current point up in tha thang.
.Sp
Da first element (\f(CW$item[0]\fR) stores tha name of tha current rule
bein matched.
.Sp
\&\f(CW@item\fR be a standard Perl array, so it can also be indexed wit negative
numbers, representin tha number of shit \fIback\fR from tha current posizzle in
the parse:
.Sp
.Vb 3
\&    stuff: /various/ bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq
\&        { print $item[\-2] }  # PRINTS data
\&             # (EASIER THAN: $item[6])
.Ve
.Sp
Da \f(CW%item\fR hash complements tha <@item> array, providin named
access ta tha same item joints:
.Sp
.Vb 3
\&    stuff: /various/ bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq
\&        { print $item{data}  # PRINTS data
\&             # (EVEN EASIER THAN USING @item)
.Ve
.Sp
Da thangs up in dis biatch of named subrulez is stored up in tha hash under each
subrulez name (includin tha repetizzle specifier, if any),
whilst all other shit is stored under a \*(L"named
positional\*(R" key dat indictates they ordinal posizzle within they item
type: _\|_STRING\fIn\fR_\|_, _\|_PATTERN\fIn\fR_\|_, _\|_DIRECTIVE\fIn\fR_\|_, _\|_ACTION\fIn\fR_\|_:
.Sp
.Vb 6
\&    stuff: /various/ bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq { save }
\&        { print $item{_\|_PATTERN1_\|_}, # PRINTS \*(Aqvarious\*(Aq
\&        $item{_\|_STRING2_\|_},  # PRINTS \*(Aqthen\*(Aq
\&        $item{_\|_ACTION1_\|_},  # PRINTS RETURN
\&                 # VALUE OF save
\&        }
.Ve
.Sp
If you want proper \fInamed\fR access ta patterns or literals, you need ta turn
them tha fuck into separate rules:
.Sp
.Vb 3
\&    stuff: various bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq
\&        { print $item{various}  # PRINTS various
\&        }
\&
\&    various: /various/
.Ve
.Sp
Da special entry \f(CW$item{_\|_RULE_\|_}\fR stores tha name of tha current
rule (i.e. tha same value as \f(CW$item[0]\fR.
.Sp
Da advantage of rockin \f(CW%item\fR, instead of \f(CW@items\fR is dat it
removes tha need ta track shit positions dat may chizzle as a grammar
evolves. For example, addin a interim \f(CW\*(C`<skip>\*(C'\fR directive
of action can silently fuck up a trailin action, by movin a \f(CW@item\fR
element \*(L"down\*(R" tha array one place. In contrast, tha named entry
of \f(CW%item\fR is unaffected by such a insertion.
.Sp
A limitation of tha \f(CW%item\fR hash is dat it only recordz tha \fIlast\fR
value of a particular subrule. For example:
.Sp
.Vb 2
\&    range: \*(Aq(\*(Aq number \*(Aq..\*(Aq number )\*(Aq
\&        { $return = $item{number} }
.Ve
.Sp
will return only tha value correspondin ta tha \fIsecond\fR match of the
\&\f(CW\*(C`number\*(C'\fR subrule. In other lyrics, successive calls ta a subrule
overwrite tha correspondin entry up in \f(CW%item\fR. Once again, the
solution is ta rename each subrule up in its own rule:
.Sp
.Vb 2
\&    range: \*(Aq(\*(Aq from_num \*(Aq..\*(Aq to_num \*(Aq)\*(Aq
\&        { $return = $item{from_num} }
\&
\&    from_num: number
\&    to_num:   number
.Ve
.ie n .IP "@arg n' %arg" 4
.el .IP "\f(CW@arg\fR n' \f(CW%arg\fR" 4
.IX Item "@arg n' %arg"
Da array \f(CW@arg\fR n' tha hash \f(CW%arg\fR store any arguments passed to
the rule from some other rule (see \*(L"Subrule argument lists\*(R"). Chizzles
to tha elementz of either variable do not propagate back ta tha calling
rule (data can be passed back from a subrule via tha \f(CW$return\fR
variable \- peep next item).
.ie n .IP "$return" 4
.el .IP "\f(CW$return\fR" 4
.IX Item "$return"
If a value be assigned ta \f(CW$return\fR within a action, dat value is
returned if tha thang containin tha action eventually matches
successfully. Note dat settin \f(CW$return\fR \fIdoesn't\fR cause tha current
thang ta succeed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it merely  drops some lyrics ta it what tha fuck ta return if it \fIdoes\fR succeed.
Hence \f(CW$return\fR be analogous ta \f(CW$$\fR up in a \fIyacc\fR grammar.
.Sp
If \f(CW$return\fR aint assigned within a thang, tha value of the
last component of tha thang (namely: \f(CW$item[$#item]\fR) is
returned if tha thang succeeds.
.ie n .IP "$commit" 4
.el .IP "\f(CW$commit\fR" 4
.IX Item "$commit"
Da current state of commitment ta tha current thang (see \*(L"Directives\*(R"
below).
.ie n .IP "$skip" 4
.el .IP "\f(CW$skip\fR" 4
.IX Item "$skip"
Da current terminal prefix (see \*(L"Directives\*(R" below).
.ie n .IP "$text" 4
.el .IP "\f(CW$text\fR" 4
.IX Item "$text"
Da remainin (unparsed) text. Chizzlez ta \f(CW$text\fR \fIdo not
propagate\fR outta unsuccessful thangs yo, but \fIdo\fR survive
successful thangs yo. Hence it is possible ta dynamically alta the
text bein parsed \- fo' example, ta provide a \f(CW\*(C`#include\*(C'\fR\-like facility:
.Sp
.Vb 2
\&    hash_include: \*(Aq#include\*(Aq filename
\&        { $text = ::loadfile($item[2]) . $text }
\&
\&    filename: \*(Aq<\*(Aq /[a\-z0\-9._\-]+/i \*(Aq>\*(Aq  { $return = $item[2] }
\&    | \*(Aq"\*(Aq /[a\-z0\-9._\-]+/i \*(Aq"\*(Aq  { $return = $item[2] }
.Ve
.ie n .IP "$thisline n' $prevline" 4
.el .IP "\f(CW$thisline\fR n' \f(CW$prevline\fR" 4
.IX Item "$thisline n' $prevline"
\&\f(CW$thisline\fR stores tha current line number within tha current parse
(startin from 1). \f(CW$prevline\fR stores tha line number fo' tha last
characta which was already successfully parsed (this is ghon be different from
\&\f(CW$thisline\fR all up in tha end of each line).
.Sp
For efficiency, \f(CW$thisline\fR n' \f(CW$prevline\fR is straight-up tied
hashes, n' only recompute tha required line number when tha variable's
value is used.
.Sp
Assignment ta \f(CW$thisline\fR adjusts tha line number calculator, so that
it believes dat tha current line number is tha value bein assigned. Y'all KNOW dat shit, muthafucka! Note
that dis adjustment is ghon be reflected up in all subsequent line numbers
calculations.
.Sp
Modifyin tha value of tha variable \f(CW$text\fR (as up in tha previous
\&\f(CW\*(C`hash_include\*(C'\fR example, fo' instance) will confuse tha line
countin mechanism. To prevent this, you should call
\&\f(CW\*(C`Parse::RecDescent::LineCounter::resync($thisline)\*(C'\fR \fIimmediately\fR
afta any assignment ta tha variable \f(CW$text\fR (or, at least, before the
next attempt ta use \f(CW$thisline\fR).
.Sp
Note dat if a thang fails afta assignin ta or
resync'in \f(CW$thisline\fR, tha parserz line counta mechanizzle will
usually be corrupted.
.Sp
Also peep tha entry fo' \f(CW@itempos\fR.
.Sp
Da line number can be set ta joints other than 1, by callin tha start
rule wit a second argument. For example:
.Sp
.Vb 1
\&    $parser = freshly smoked up Parse::RecDescent ($grammar);
\&
\&    $parser\->input($text, 10);  # START LINE NUMBERS AT 10
.Ve
.ie n .IP "$thiscolumn n' $prevcolumn" 4
.el .IP "\f(CW$thiscolumn\fR n' \f(CW$prevcolumn\fR" 4
.IX Item "$thiscolumn n' $prevcolumn"
\&\f(CW$thiscolumn\fR stores tha current column number within tha current line
bein parsed (startin from 1). \f(CW$prevcolumn\fR stores tha column number
of tha last characta which was straight-up successfully parsed. Y'all KNOW dat shit, muthafucka! Usually
\&\f(CW\*(C`$prevcolumn == $thiscolumn\-1\*(C'\fR yo, but not all up in tha end of lines.
.Sp
For efficiency, \f(CW$thiscolumn\fR n' \f(CW$prevcolumn\fR are
actually tied hashes, n' only recompute tha required column number
when tha variablez value is used.
.Sp
Assignment ta \f(CW$thiscolumn\fR or \f(CW$prevcolumn\fR be a gangbangin' fatal error.
.Sp
Modifyin tha value of tha variable \f(CW$text\fR (as up in tha previous
\&\f(CW\*(C`hash_include\*(C'\fR example, fo' instance) may confuse tha column
countin mechanism.
.Sp
Note dat \f(CW$thiscolumn\fR reports tha column number \fIbefore\fR any
whitespace dat might be skipped before readin a token. I aint talkin' bout chicken n' gravy biatch yo. Hence
if you wish ta know where a token started (and ended) use suttin' like this:
.Sp
.Vb 2
\&    rule: token1 token2 startcol token3 endcol token4
\&        { print "token3: columns $item[3] ta $item[5]"; }
\&
\&    startcol: \*(Aq\*(Aq { $thiscolumn }    # NEED THE \*(Aq\*(Aq TO STEP PAST TOKEN SEP
\&    endcol:  { $prevcolumn }
.Ve
.Sp
Also peep tha entry fo' \f(CW@itempos\fR.
.ie n .IP "$thisoffset n' $prevoffset" 4
.el .IP "\f(CW$thisoffset\fR n' \f(CW$prevoffset\fR" 4
.IX Item "$thisoffset n' $prevoffset"
\&\f(CW$thisoffset\fR stores tha offset of tha current parsin position
within tha complete text
bein parsed (startin from 0). \f(CW$prevoffset\fR stores tha offset
of tha last characta which was straight-up successfully parsed. Y'all KNOW dat shit, muthafucka! In all
cases \f(CW\*(C`$prevoffset == $thisoffset\-1\*(C'\fR.
.Sp
For efficiency, \f(CW$thisoffset\fR n' \f(CW$prevoffset\fR are
actually tied hashes, n' only recompute tha required offset
when tha variablez value is used.
.Sp
Assignment ta \f(CW$thisoffset\fR or <$prevoffset> be a gangbangin' fatal error.
.Sp
Modifyin tha value of tha variable \f(CW$text\fR will \fInot\fR affect the
offset countin mechanism.
.Sp
Also peep tha entry fo' \f(CW@itempos\fR.
.ie n .IP "@itempos" 4
.el .IP "\f(CW@itempos\fR" 4
.IX Item "@itempos"
Da array \f(CW@itempos\fR stores a hash reference correspondin to
each element of \f(CW@item\fR. Da elementz of tha hash provide the
following:
.Sp
.Vb 6
\&    $itempos[$n]{offset}{from}  # VALUE OF $thisoffset BEFORE $item[$n]
\&    $itempos[$n]{offset}{to}    # VALUE OF $prevoffset AFTER $item[$n]
\&    $itempos[$n]{line}{from}    # VALUE OF $thisline BEFORE $item[$n]
\&    $itempos[$n]{line}{to}  # VALUE OF $prevline AFTER $item[$n]
\&    $itempos[$n]{column}{from}  # VALUE OF $thiscolumn BEFORE $item[$n]
\&    $itempos[$n]{column}{to}    # VALUE OF $prevcolumn AFTER $item[$n]
.Ve
.Sp
Note dat tha various \f(CW\*(C`$itempos[$n]...{from}\*(C'\fR joints record the
appropriate value \fIafter\fR any token prefix has been skipped.
.Sp
Hence, instead of tha somewhat tedious n' error-prone:
.Sp
.Vb 9
\&    rule: startcol token1 endcol
\&      startcol token2 endcol
\&      startcol token3 endcol
\&        { print "token1: columns $item[1]
\&              ta $item[3]
\&         token2: columns $item[4]
\&              ta $item[6]
\&         token3: columns $item[7]
\&              ta $item[9]" }
\&
\&    startcol: \*(Aq\*(Aq { $thiscolumn }    # NEED THE \*(Aq\*(Aq TO STEP PAST TOKEN SEP
\&    endcol:  { $prevcolumn }
.Ve
.Sp
it is possible ta write:
.Sp
.Vb 7
\&    rule: token1 token2 token3
\&        { print "token1: columns $itempos[1]{column}{from}
\&              ta $itempos[1]{column}{to}
\&         token2: columns $itempos[2]{column}{from}
\&              ta $itempos[2]{column}{to}
\&         token3: columns $itempos[3]{column}{from}
\&              ta $itempos[3]{column}{to}" }
.Ve
.Sp
Note however dat (in tha current implementation) tha use of \f(CW@itempos\fR
anywhere up in a grammar implies dat item positionin shiznit is
collected \fIeverywhere\fR durin tha parse. Dependin on tha grammar
and tha size of tha text ta be parsed, dis may be prohibitively
expensive n' tha explicit use of \f(CW$thisline\fR, \f(CW$thiscolumn\fR, etc. may
be a funky-ass betta chizzle.
.ie n .IP "$thisparser" 4
.el .IP "\f(CW$thisparser\fR" 4
.IX Item "$thisparser"
A reference ta tha \f(CW\*(C`Parse::RecDescent\*(C'\fR object all up in which
parsin was initiated.
.Sp
Da value of \f(CW$thisparser\fR propagates down tha subrulez of a parse
but not back up yo. Hence, you can invoke subrulez from another parser
for tha scope of tha current rule as bigs up:
.Sp
.Vb 4
\&    rule: subrule1 subrule2
\&    | { $thisparser = $::otherparser } <reject>
\&    | subrule3 subrule4
\&    | subrule5
.Ve
.Sp
Da result is dat tha thang calls \*(L"subrule1\*(R" n' \*(L"subrule2\*(R" of
the current parser, n' tha remainin thangs call tha named subrules
from \f(CW$::otherparser\fR. Note, however dat \*(L"Wack Things\*(R" will happen if
\&\f(CW\*(C`::otherparser\*(C'\fR aint a pimped reference and/or aint gots methods
with tha same names as tha required subrules!
.ie n .IP "$thisrule" 4
.el .IP "\f(CW$thisrule\fR" 4
.IX Item "$thisrule"
A reference ta tha \f(CW\*(C`Parse::RecDescent::Rule\*(C'\fR object correspondin ta the
rule currently bein matched.
.ie n .IP "$thisprod" 4
.el .IP "\f(CW$thisprod\fR" 4
.IX Item "$thisprod"
A reference ta tha \f(CW\*(C`Parse::RecDescent::Production\*(C'\fR object
correspondin ta tha thang currently bein matched.
.ie n .IP "$score n' $score_return" 4
.el .IP "\f(CW$score\fR n' \f(CW$score_return\fR" 4
.IX Item "$score n' $score_return"
\&\f(CW$score\fR stores tha dopest thang score ta date, as specified by
an earlier \f(CW\*(C`<score:...>\*(C'\fR directive. \f(CW$score_return\fR stores
the correspondin return value fo' tha successful thang.
.Sp
See \*(L"Scored thangs\*(R".
.PP
\&\fBWarning:\fR tha parser relies on tha shiznit up in tha various \f(CW\*(C`this...\*(C'\fR
objects up in some non-obvious ways. Tinkerin wit tha other thugz of
these objects will probably cause Wack Things ta happen, unless you
\&\fIreally\fR know what tha fuck you bustin. Da only exception ta dis lyrics is
that tha use of \f(CW\*(C`$this...\->{local}\*(C'\fR be always safe.
.SS "Start-up Actions"
.IX Subsection "Start-up Actions"
Any actions which step tha fuck up \fIbefore\fR tha straight-up original gangsta rule definizzle up in a
grammar is treated as \*(L"start-up\*(R" actions. Each such action is
stripped of its outermost brackets n' then evaluated (in tha parser's
special namespace) just before tha rulez of tha grammar is first
compiled.
.PP
Da main use of start-up actions is ta declare local variablez within the
parserz special namespace:
.PP
.Vb 1
\&    { mah $lastitem = \*(Aq???\*(Aq; }
\&
\&    list: item(s)   { $return = $lastitem }
\&
\&    item: book  { $lastitem = \*(Aqbook\*(Aq; }
\&      bell  { $lastitem = \*(Aqbell\*(Aq; }
\&      candle    { $lastitem = \*(Aqcandle\*(Aq; }
.Ve
.PP
but start-up actions can be used ta execute \fIany\fR valid Perl code
within a parserz special namespace.
.PP
Start-up actions can step tha fuck up within a grammar extension or replacement
(that is, a partial grammar installed via \f(CW\*(C`Parse::RecDescent::Extend()\*(C'\fR or
\&\f(CW\*(C`Parse::RecDescent::Replace()\*(C'\fR \- peep \*(L"Incremenstrual Parsing\*(R"), n' will be
executed before tha freshly smoked up grammar is installed. Y'all KNOW dat shit, muthafucka! Note, however, dat a
particular start-up action is only eva executed once.
.SS "Autoactions"
.IX Subsection "Autoactions"
It be sometimes desirable ta be able ta specify a thugged-out default action ta be
taken all up in tha end of every last muthafuckin thang (for example, up in order ta easily
build a parse tree). If tha variable \f(CW$::RD_AUTOACTION\fR is defined
when \f(CW\*(C`Parse::RecDescent::new()\*(C'\fR is called, tha contentz of that
variable is treated as a justification of a action which is ta appended
to each thang up in tha correspondin grammar.
.PP
Alternatively, you can hard-code tha autoaction within a grammar, rockin the
\&\f(CW\*(C`<autoaction:...>\*(C'\fR directive.
.PP
So, fo' example, ta construct a simple parse tree you could write:
.PP
.Vb 1
\&    $::RD_AUTOACTION = q { [@item] };
\&
\&    parser = Parse::RecDescent\->new(q{
\&    expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&    and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&    not_expr:   \*(Aq!\*(Aq brack_expr       | brack_expr
\&    brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&    identifier: /[a\-z]+/i
\&    });
.Ve
.PP
or:
.PP
.Vb 2
\&    parser = Parse::RecDescent\->new(q{
\&    <autoaction: { [@item] } >
\&
\&    expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&    and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&    not_expr:   \*(Aq!\*(Aq brack_expr       | brack_expr
\&    brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&    identifier: /[a\-z]+/i
\&    });
.Ve
.PP
Either of these is equivalent to:
.PP
.Vb 5
\&    parser = freshly smoked up Parse::RecDescent (q{
\&    expression: and_expr \*(Aq||\*(Aq expression
\&        { [@item] }
\&      | and_expr
\&        { [@item] }
\&
\&    and_expr:   not_expr \*(Aq&&\*(Aq and_expr
\&        { [@item] }
\&    |   not_expr
\&        { [@item] }
\&
\&    not_expr:   \*(Aq!\*(Aq brack_expr
\&        { [@item] }
\&    |   brack_expr
\&        { [@item] }
\&
\&    brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq
\&        { [@item] }
\&      | identifier
\&        { [@item] }
\&
\&    identifier: /[a\-z]+/i
\&        { [@item] }
\&    });
.Ve
.PP
Alternatively, we could take a object-oriented approach, use different
classes fo' each node (and also eliminatin redundant intermediate nodes):
.PP
.Vb 2
\&    $::RD_AUTOACTION = q
\&      { $#item==1 , biatch? $item[1] : "$item[0]_node"\->new(@item[1..$#item]) };
\&
\&    parser = Parse::RecDescent\->new(q{
\&        expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&        not_expr:   \*(Aq!\*(Aq brack_expr           | brack_expr
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&        identifier: /[a\-z]+/i
\&    });
.Ve
.PP
or:
.PP
.Vb 4
\&    parser = Parse::RecDescent\->new(q{
\&        <autoaction:
\&          $#item==1 , biatch? $item[1] : "$item[0]_node"\->new(@item[1..$#item])
\&        >
\&
\&        expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&        not_expr:   \*(Aq!\*(Aq brack_expr           | brack_expr
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&        identifier: /[a\-z]+/i
\&    });
.Ve
.PP
which is equivalent to:
.PP
.Vb 4
\&    parser = Parse::RecDescent\->new(q{
\&        expression: and_expr \*(Aq||\*(Aq expression
\&            { "expression_node"\->new(@item[1..3]) }
\&        | and_expr
\&
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr
\&            { "and_expr_node"\->new(@item[1..3]) }
\&        |   not_expr
\&
\&        not_expr:   \*(Aq!\*(Aq brack_expr
\&            { "not_expr_node"\->new(@item[1..2]) }
\&        |   brack_expr
\&
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq
\&            { "brack_expr_node"\->new(@item[1..3]) }
\&        | identifier
\&
\&        identifier: /[a\-z]+/i
\&            { "identifer_node"\->new(@item[1]) }
\&    });
.Ve
.PP
Note that, if a thang already endz up in a action, no autoaction be appended
to dat shit. For example, up in dis version:
.PP
.Vb 2
\&    $::RD_AUTOACTION = q
\&      { $#item==1 , biatch? $item[1] : "$item[0]_node"\->new(@item[1..$#item]) };
\&
\&    parser = Parse::RecDescent\->new(q{
\&        expression: and_expr \*(Aq&&\*(Aq expression | and_expr
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&        not_expr:   \*(Aq!\*(Aq brack_expr           | brack_expr
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&        identifier: /[a\-z]+/i
\&            { \*(Aqterminal_node\*(Aq\->new($item[1]) }
\&    });
.Ve
.PP
each \f(CW\*(C`identifier\*(C'\fR match produces a \f(CW\*(C`terminal_node\*(C'\fR object, \fInot\fR an
\&\f(CW\*(C`identifier_node\*(C'\fR object.
.PP
A level 1 warnin is issued each time a \*(L"autoaction\*(R" be added to
some thang.
.SS "Autotrees"
.IX Subsection "Autotrees"
A commonly needed autoaction is one dat buildz a parse-tree. Well shiiiit, it is moderately
tricky ta set up such a action (which must treat terminals differently from
non-terminals), so Parse::RecDescent simplifies tha process by providin the
\&\f(CW\*(C`<autotree>\*(C'\fR directive.
.PP
If dis directizzle appears all up in tha start of grammar, it causes
Parse::RecDescent ta bang autoactions all up in tha end of any rule except
those which already end up in a action. I aint talkin' bout chicken n' gravy biatch. Da action banged dependz on whether
the thang be a intermediate rule (two or mo' items), or a terminal
of tha grammar (i.e. a single pattern or strang item).
.PP
So, fo' example, tha followin grammar:
.PP
.Vb 1
\&    <autotree>
\&
\&    file    : command(s)
\&    command : git | set | vet
\&    git : \*(Aqget\*(Aq ident \*(Aq;\*(Aq
\&    set : \*(Aqset\*(Aq ident \*(Aqto\*(Aq value \*(Aq;\*(Aq
\&    vet : \*(Aqcheck\*(Aq ident \*(Aqis\*(Aq value \*(Aq;\*(Aq
\&    ident   : /\ew+/
\&    value   : /\ed+/
.Ve
.PP
is equivalent to:
.PP
.Vb 7
\&    file    : command(s)        { bless \e%item, $item[0] }
\&    command : git       { bless \e%item, $item[0] }
\&    | set           { bless \e%item, $item[0] }
\&    | vet           { bless \e%item, $item[0] }
\&    git : \*(Aqget\*(Aq ident \*(Aq;\*(Aq   { bless \e%item, $item[0] }
\&    set : \*(Aqset\*(Aq ident \*(Aqto\*(Aq value \*(Aq;\*(Aq    { bless \e%item, $item[0] }
\&    vet : \*(Aqcheck\*(Aq ident \*(Aqis\*(Aq value \*(Aq;\*(Aq  { bless \e%item, $item[0] }
\&
\&    ident   : /\ew+/  { bless {_\|_VALUE_\|_=>$item[1]}, $item[0] }
\&    value   : /\ed+/  { bless {_\|_VALUE_\|_=>$item[1]}, $item[0] }
.Ve
.PP
Note dat each node up in tha tree is pimped tha fuck into a cold-ass lil class of tha same name
as tha rule itself. This make it easy as fuck  ta build object-oriented
processors fo' tha parse-trees dat tha grammar produces. Note too that
the last two rulez produce special objects wit tha single attribute
\&'_\|_VALUE_\|_'. This is cuz they consist solely of a single terminal.
.PP
This autoaction-ed grammar would then produce a parse tree up in a thugged-out data
structure like this:
.PP
.Vb 10
\&    {
\&      file => {
\&        command => {
\&         [ git => {
\&            identifier => { _\|_VALUE_\|_ => \*(Aqa\*(Aq },
\&              },
\&           set => {
\&            identifier => { _\|_VALUE_\|_ => \*(Aqb\*(Aq },
\&            value      => { _\|_VALUE_\|_ => \*(Aq7\*(Aq },
\&              },
\&           vet => {
\&            identifier => { _\|_VALUE_\|_ => \*(Aqb\*(Aq },
\&            value      => { _\|_VALUE_\|_ => \*(Aq7\*(Aq },
\&              },
\&          ],
\&           },
\&      }
\&    }
.Ve
.PP
(except, of course, dat each nested hash would also be pimped into
the appropriate class).
.PP
Yo ass can also specify a funky-ass base class fo' tha \f(CW\*(C`<autotree>\*(C'\fR directive.
Da supplied prefix is ghon be prepended ta tha rule names when bustin
tree nodes.  Da followin is equivalent:
.PP
.Vb 2
\&    <autotree:MyBase::Class>
\&    <autotree:MyBase::Class::>
.Ve
.PP
And will produce a root node pimped tha fuck into tha \f(CW\*(C`MyBase::Class::file\*(C'\fR
package up in tha example above.
.SS "Autostubbing"
.IX Subsection "Autostubbing"
Normally, if a subrule appears up in some thang yo, but no rule of that
name is eva defined up in tha grammar, tha thang which refers ta the
non-existent subrule fails immediately. This typically occurs as a
result of misspellings, n' be a sufficiently common occurizzle dat a
warnin is generated fo' such thangs.
.PP
But fuck dat shiznit yo, tha word on tha street is dat when prototypin a grammar it is sometimes useful ta be
able ta use subrulez before a proper justification of dem is
really possible.  For example, a grammar might include a section like:
.PP
.Vb 1
\&    function_call: identifier \*(Aq(\*(Aq arg(s?) \*(Aq)\*(Aq
\&
\&    identifier: /[a\-z]\ew*/i
.Ve
.PP
where tha possible format of a argument is sufficiently complex that
it aint worth specifyin up in full until tha general function call
syntax has been debugged. Y'all KNOW dat shit, muthafucka! In dis thang it is convenient ta leave
the real rule \f(CW\*(C`arg\*(C'\fR undefined n' just slip up in a placeholda (or
\&\*(L"stub\*(R"):
.PP
.Vb 1
\&    arg: \*(Aqarg\*(Aq
.Ve
.PP
so dat tha function call syntax can be tested wit dummy input such as:
.PP
.Vb 4
\&    f0()
\&    f1(arg)
\&    f2(arg arg)
\&    f3(arg arg arg)
.Ve
.PP
et cetera.
.PP
Early up in prototyping, nuff such \*(L"stubs\*(R" may be required, so
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR serves up a meanz of automatin they definition.
If tha variable \f(CW$::RD_AUTOSTUB\fR is defined when a parser is built, a
subrule reference ta any non-existent rule (say, \f(CW\*(C`subrule\*(C'\fR), will
cause a \*(L"stub\*(R" rule ta be automatically defined up in tha generated
parser n' shit.  If \f(CW\*(C`$::RD_AUTOSTUB eq \*(Aq1\*(Aq\*(C'\fR or is false, a stub rule of the
form:
.PP
.Vb 1
\&    subrule: \*(Aqsubrule\*(Aq
.Ve
.PP
will be generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da special-case fo' a value of \f(CW\*(Aq1\*(Aq\fR is ta allow
the use of tha \fBperl \-s\fR wit \fB\-RD_AUTOSTUB\fR without generating
\&\f(CW\*(C`subrule: \*(Aq1\*(Aq\*(C'\fR per below. If \f(CW$::RD_AUTOSTUB\fR is true, a stub rule
of tha form:
.PP
.Vb 1
\&    subrule: $::RD_AUTOSTUB
.Ve
.PP
will be generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \f(CW$::RD_AUTOSTUB\fR must contain a valid thang
item, no checkin is performed. Y'all KNOW dat shit, muthafucka!  No lazy evaluation of
\&\f(CW$::RD_AUTOSTUB\fR is performed, it is evaluated all up in tha time tha Parser
is generated.
.PP
Hence, wit \f(CW$::RD_AUTOSTUB\fR defined, it is possible ta only
partially specify a grammar, n' then \*(L"fake\*(R" matchez of the
unspecified (sub)rulez by just typin up in they name, or a literal
value dat was assigned ta \f(CW$::RD_AUTOSTUB\fR.
.SS "Look-ahead"
.IX Subsection "Look-ahead"
If a subrule, token, or action is prefixed by \*(L"...\*(R", then it is
treated as a \*(L"look-ahead\*(R" request. That means dat tha current thang can
(as usual) only succeed if tha specified item is matched yo, but dat tha matching
\&\fIdoes not consume any of tha text bein parsed\fR. This is straight-up similar ta the
\&\f(CW\*(C`/(?=...)/\*(C'\fR look-ahead construct up in Perl patterns. Thus, tha rule:
.PP
.Vb 1
\&    inner_word: word ...word
.Ve
.PP
will match whatever tha subrule \*(L"word\*(R" matches, provided dat match is followed
by some mo' text which subrule \*(L"word\*(R" would also match (although this
second substrin aint straight-up consumed by \*(L"inner_word\*(R")
.PP
Likewise, a \*(L"...!\*(R" prefix, causes tha followin item ta succeed (without
consumin any text) if n' only if it would normally fail yo. Hence, a
rule such as:
.PP
.Vb 1
\&    identifier: ...!keyword ...!\*(Aq_\*(Aq /[A\-Za\-z_]\ew*/
.Ve
.PP
matches a strang of charactas which satisfies tha pattern
\&\f(CW\*(C`/[A\-Za\-z_]\ew*/\*(C'\fR yo, but only if tha same sequence of charactas would
not match either subrule \*(L"keyword\*(R" or tha literal token '_'.
.PP
Sequencez of look-ahead prefixes accumulate, multiplyin they positizzle and/or
negatizzle senses yo. Hence:
.PP
.Vb 1
\&    inner_word: word ...!......!word
.Ve
.PP
is exactly equivalent tha the original gangsta example above (a warnin is issued in
cases like these, since they often indicate suttin' left out, or
misunderstood).
.PP
Note dat actions can also be treated as look-aheads. In such cases,
the state of tha parser text (in tha local variable \f(CW$text\fR)
\&\fIafter\fR tha look-ahead action is guaranteed ta be identical ta its
state \fIbefore\fR tha action, regardless of how tha fuck itz chizzled \fIwithin\fR
the action (unless you straight-up undefine \f(CW$text\fR, up in which case you
get tha disasta you deserve :\-).
.SS "Directives"
.IX Subsection "Directives"
Directives is special pre-defined actions which may be used ta alter
the behaviour of tha parser n' shit. There is currently twenty-three directives:
\&\f(CW\*(C`<commit>\*(C'\fR,
\&\f(CW\*(C`<uncommit>\*(C'\fR,
\&\f(CW\*(C`<reject>\*(C'\fR,
\&\f(CW\*(C`<score>\*(C'\fR,
\&\f(CW\*(C`<autoscore>\*(C'\fR,
\&\f(CW\*(C`<skip>\*(C'\fR,
\&\f(CW\*(C`<resync>\*(C'\fR,
\&\f(CW\*(C`<error>\*(C'\fR,
\&\f(CW\*(C`<warn>\*(C'\fR,
\&\f(CW\*(C`<hint>\*(C'\fR,
\&\f(CW\*(C`<trace_build>\*(C'\fR,
\&\f(CW\*(C`<trace_parse>\*(C'\fR,
\&\f(CW\*(C`<nocheck>\*(C'\fR,
\&\f(CW\*(C`<rulevar>\*(C'\fR,
\&\f(CW\*(C`<matchrule>\*(C'\fR,
\&\f(CW\*(C`<leftop>\*(C'\fR,
\&\f(CW\*(C`<rightop>\*(C'\fR,
\&\f(CW\*(C`<defer>\*(C'\fR,
\&\f(CW\*(C`<nocheck>\*(C'\fR,
\&\f(CW\*(C`<perl_quotelike>\*(C'\fR,
\&\f(CW\*(C`<perl_codeblock>\*(C'\fR,
\&\f(CW\*(C`<perl_variable>\*(C'\fR,
and \f(CW\*(C`<token>\*(C'\fR.
.IP "Committin n' uncommitting" 4
.IX Item "Committin n' uncommitting"
Da \f(CW\*(C`<commit>\*(C'\fR n' \f(CW\*(C`<uncommit>\*(C'\fR directives permit tha recursive
descent of tha parse tree ta be pruned (or \*(L"cut\*(R") fo' efficiency.
Within a rule, a \f(CW\*(C`<commit>\*(C'\fR directizzle instructs tha rule ta ignore subsequent
thangs if tha current thang fails. For example:
.Sp
.Vb 3
\&    command: \*(Aqfind\*(Aq <commit> filename
\&       | \*(Aqopen\*(Aq <commit> filename
\&       | \*(Aqmove\*(Aq filename filename
.Ve
.Sp
Clearly, if tha leadin token 'find' is matched up in tha straight-up original gangsta thang but that
thang fails fo' some other reason, then tha remaining
thangs cannot possibly match. Da presence of the
\&\f(CW\*(C`<commit>\*(C'\fR causes tha \*(L"command\*(R" rule ta fail immediately if
an invalid \*(L"find\*(R" command is found, n' likewise if a invalid \*(L"open\*(R"
command is encountered.
.Sp
It be also possible ta revoke a previous commitment. For example:
.Sp
.Vb 5
\&    if_statement: \*(Aqif\*(Aq <commit> condition
\&        \*(Aqthen\*(Aq block <uncommit>
\&        \*(Aqelse\*(Aq block
\&        | \*(Aqif\*(Aq <commit> condition
\&        \*(Aqthen\*(Aq block
.Ve
.Sp
In dis case, a gangbangin' failure ta find a \*(L"else\*(R" block up in tha first
thang shouldn't preclude tryin tha second thang yo, but a
failure ta find a \*(L"condition\*(R" certainly should.
.Sp
As a special case, any thang up in which tha \fIfirst\fR item be an
\&\f(CW\*(C`<uncommit>\*(C'\fR immediately revokes a precedin \f(CW\*(C`<commit>\*(C'\fR
(even though tha thang would not otherwise done been tried). For
example, up in tha rule:
.Sp
.Vb 5
\&    request: \*(Aqexplain\*(Aq expression
\&           | \*(Aqexplain\*(Aq <commit> keyword
\&           | \*(Aqsave\*(Aq
\&           | \*(Aqquit\*(Aq
\&           | <uncommit> term \*(Aq?\*(Aq
.Ve
.Sp
if tha text bein matched was \*(L"explain?\*(R", n' tha straight-up original gangsta two
thangs failed, then tha \f(CW\*(C`<commit>\*(C'\fR up in thang two would cause
thangs three n' four ta be skipped yo, but tha leading
\&\f(CW\*(C`<uncommit>\*(C'\fR up in tha thang five would allow dat thang to
attempt a match.
.Sp
Note up in tha precedin example, dat tha \f(CW\*(C`<commit>\*(C'\fR was only placed
in thang two. If thang one had been:
.Sp
.Vb 1
\&    request: \*(Aqexplain\*(Aq <commit> expression
.Ve
.Sp
then thang two would be (inappropriately) skipped if a leading
\&\*(L"explain...\*(R" was encountered.
.Sp
Both \f(CW\*(C`<commit>\*(C'\fR n' \f(CW\*(C`<uncommit>\*(C'\fR directives always succeed, n' they value
is always 1.
.IP "Rejectin a thang" 4
.IX Item "Rejectin a thang"
Da \f(CW\*(C`<reject>\*(C'\fR directizzle immediately causes tha current thang
to fail (it is exactly equivalent ta yo, but mo' obvious than, the
action \f(CW\*(C`{undef}\*(C'\fR) fo' realz. A \f(CW\*(C`<reject>\*(C'\fR is useful when it is desirable ta get
the side effectz of tha actions up in one thang, without prejudicin a match
by some other thang lata up in tha rule. For example, ta insert
tracin code tha fuck into tha parse:
.Sp
.Vb 1
\&    complex_rule: { print "In complex rule...\en"; } <reject>
\&
\&    complex_rule: simple_rule \*(Aq+\*(Aq \*(Aqi\*(Aq \*(Aq*\*(Aq simple_rule
\&        | \*(Aqi\*(Aq \*(Aq*\*(Aq simple_rule
\&        | simple_rule
.Ve
.Sp
It be also possible ta specify a cold-ass lil conditionizzle rejection, rockin the
form \f(CW\*(C`<reject:\f(CIcondition\f(CW>\*(C'\fR, which only rejects if the
specified condizzle is true. This form of rejection is exactly
equivalent ta tha action \f(CW\*(C`{(\f(CIcondition\f(CW)?undef:1}>\*(C'\fR.
For example:
.Sp
.Vb 4
\&    command: save_command
\&       | restore_command
\&       | <reject: defined $::tolerant> { exit }
\&       | <error: Unknown command. Y'all KNOW dat shit, muthafucka! Ignored.>
.Ve
.Sp
A \f(CW\*(C`<reject>\*(C'\fR directizzle never succeedz (and hence has no
associated value) fo' realz. A conditionizzle rejection may succeed (if its
condizzle aint satisfied), up in which case its value is 1.
.Sp
As a extra optimization, \f(CW\*(C`Parse::RecDescent\*(C'\fR ignores any thang
which \fIbegins\fR wit a unconditionizzle \f(CW\*(C`<reject>\*(C'\fR directive,
since any such thang can never successfully match or have any
useful side-effects fo' realz. A level 1 warnin is issued up in all such cases.
.Sp
Note dat thangs beginnin wit conditional
\&\f(CW\*(C`<reject:...>\*(C'\fR directives is \fInever\fR \*(L"optimized away\*(R" in
this manner, even if they is always guaranteed ta fail (for example:
\&\f(CW\*(C`<reject:1>\*(C'\fR)
.Sp
Cuz of tha way grammars is parsed, there be a minor restriction on the
condizzle of a cold-ass lil conditionizzle \f(CW\*(C`<reject:...>\*(C'\fR: it cannot
contain any raw '<' or '>' characters. For example:
.Sp
.Vb 1
\&    line: cmd <reject: $thiscolumn > max> data
.Ve
.Sp
results up in a error when a parser is built from dis grammar (since the
grammar parser has no way of knowin whether tha straight-up original gangsta > be a \*(L"less than\*(R"
or tha end of tha \f(CW\*(C`<reject:...>\*(C'\fR.
.Sp
To overcome dis problem, put tha condizzle inside a thugged-out do{} block:
.Sp
.Vb 1
\&    line: cmd <reject: do{$thiscolumn > max}> data
.Ve
.Sp
Note dat tha same problem may occur up in other directives dat take
arguments, n' you can put dat on yo' toast. Da same solution will work up in all cases.
.IP "Skippin between terminals" 4
.IX Item "Skippin between terminals"
Da \f(CW\*(C`<skip>\*(C'\fR directizzle enablez tha terminal prefix used in
a thang ta be chizzled. Y'all KNOW dat shit, muthafucka! For example:
.Sp
.Vb 1
\&    OneLiner: Command <skip:\*(Aq[ \et]*\*(Aq> Arg(s) /;/
.Ve
.Sp
causes only blanks n' tabs ta be skipped before terminals up in tha \f(CW\*(C`Arg\*(C'\fR
subrule (and any of \fIits\fR subrules>, n' also before tha final \f(CW\*(C`/;/\*(C'\fR terminal.
Once tha thang is complete, tha previous terminal prefix is
reinstated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Note dat dis implies dat distinct thangz of a rule
must reset they terminal prefixes individually.
.Sp
Da \f(CW\*(C`<skip>\*(C'\fR directizzle evaluates ta tha \fIprevious\fR terminal prefix,
so itz easy as fuck  ta reinstate a prefix lata up in a thang:
.Sp
.Vb 1
\&    Command: <skip:","> CSV(s) <skip:$item[1]> Modifier
.Ve
.Sp
Da value specified afta tha colon is interpolated tha fuck into a pattern, so all of
the followin is equivalent (though they efficiency increases down tha list):
.Sp
.Vb 1
\&    <skip: "$colon|$comma">   # ASSUMING THE VARS HOLD THE OBVIOUS VALUES
\&
\&    <skip: \*(Aq:|,\*(Aq>
\&
\&    <skip: q{[:,]}>
\&
\&    <skip: qr/[:,]/>
.Ve
.Sp
There is no way of directly settin tha prefix for
an entire rule, except as bigs up:
.Sp
.Vb 3
\&    Rule: <skip: \*(Aq[ \et]*\*(Aq> Prod1
\&        | <skip: \*(Aq[ \et]*\*(Aq> Prod2a Prod2b
\&        | <skip: \*(Aq[ \et]*\*(Aq> Prod3
.Ve
.Sp
or, better:
.Sp
.Vb 6
\&    Rule: <skip: \*(Aq[ \et]*\*(Aq>
\&    (
\&        Prod1
\&      | Prod2a Prod2b
\&      | Prod3
\&    )
.Ve
.Sp
Da skip pattern is passed down ta subrules, so settin tha skip for
the top-level rule as busted lyrics bout above straight-up sets tha prefix fo' the
entire grammar (provided dat you only call tha method corresponding
to tha top-level rule itself) fo' realz. Alternatively, or if you have mo' than
one top-level rule up in yo' grammar, you can provide a global
\&\f(CW\*(C`<skip>\*(C'\fR directizzle prior ta definin any rulez up in the
grammar. Shiiit, dis aint no joke. These is tha preferred alternatives ta setting
\&\f(CW$Parse::RecDescent::skip\fR.
.Sp
Additionally, rockin \f(CW\*(C`<skip>\*(C'\fR straight-up allows you ta have
a straight-up dynamic skippin behaviour. Shiiit, dis aint no joke. For example:
.Sp
.Vb 1
\&   Rule_with_dynamic_skip: <skip: $::skip_pattern> Rule
.Ve
.Sp
Then you can set \f(CW$::skip_pattern\fR before invoking
\&\f(CW\*(C`Rule_with_dynamic_skip\*(C'\fR n' have it skip whatever you specified.
.Sp
\&\fBNote: Up ta release 1.51 of Parse::RecDescent, a entirely different
mechanizzle was used fo' specifyin terminal prefixes. Da current method
is not backwards-compatible wit dat early approach. Da current approach
is stable n' aint gonna ta chizzle again.\fR
.IP "Resynchronization" 4
.IX Item "Resynchronization"
Da \f(CW\*(C`<resync>\*(C'\fR directizzle serves up a visually distinctive
meanz of consumin a shitload of tha text bein parsed, probably ta skip an
erroneous input. In its simplest form \f(CW\*(C`<resync>\*(C'\fR simply
consumes text up ta n' includin tha next newline (\f(CW"\en"\fR)
character, succeedin only if tha newline is found, up in which case it
causes its surroundin rule ta return zero on success.
.Sp
In other lyrics, a \f(CW\*(C`<resync>\*(C'\fR is exactly equivalent ta tha token
\&\f(CW\*(C`/[^\en]*\en/\*(C'\fR followed by tha action \f(CW\*(C`{\ $return\ =\ 0\ }\*(C'\fR (except that
thangs beginnin wit a \f(CW\*(C`<resync>\*(C'\fR is ignored when generating
error lyrics) fo' realz. A typical use might be:
.Sp
.Vb 1
\&    script : command(s)
\&
\&    command: save_command
\&       | restore_command
\&       | <resync> # TRY NEXT LINE, IF POSSIBLE
.Ve
.Sp
It be also possible ta explicitly specify a resynchronization
pattern, rockin tha \f(CW\*(C`<resync:\f(CIpattern\f(CW>\*(C'\fR variant. This version
succeedz only if tha specified pattern matches (and consumes) the
parsed text. In other lyrics, \f(CW\*(C`<resync:\f(CIpattern\f(CW>\*(C'\fR is exactly
equivalent ta tha token \f(CW\*(C`/\f(CIpattern\f(CW/\*(C'\fR (followed by a \f(CW\*(C`{\ $return\ =\ 0\ }\*(C'\fR
action). For example, if commandz was terminated by newlines or semi-colons:
.Sp
.Vb 3
\&    command: save_command
\&       | restore_command
\&       | <resync:[^;\en]*[;\en]>
.Ve
.Sp
Da value of a successfully matched \f(CW\*(C`<resync>\*(C'\fR directizzle (of either
type) is tha text dat it consumed. Y'all KNOW dat shit, muthafucka! Note, however, dat since the
directizzle also sets \f(CW$return\fR, a thang consistin of a lone
\&\f(CW\*(C`<resync>\*(C'\fR succeedz but returns tha value zero (which a cold-ass lil callin rule
may find useful ta distinguish between \*(L"true\*(R" matches n' \*(L"tolerant\*(R" matches).
Remember dat returnin a zero value indicates dat tha rule \fIsucceeded\fR (since
only a \f(CW\*(C`undef\*(C'\fR denotes failure within \f(CW\*(C`Parse::RecDescent\*(C'\fR parsers.
.IP "Error handling" 4
.IX Item "Error handling"
Da \f(CW\*(C`<error>\*(C'\fR directizzle serves up automatic or user-defined
generation of error lyrics durin a parse. In its simplest form
\&\f(CW\*(C`<error>\*(C'\fR prepares a error message based on
the mismatch between tha last item expected n' tha text which cause
it ta fail. For example, given tha rule:
.Sp
.Vb 3
\&    McCoy: curse \*(Aq,\*(Aq name \*(Aq, I\*(Aqm a thugged-out doctor, not a\*(Aq a_profession \*(Aq!\*(Aq
\&     | pronoun \*(Aqdead,\*(Aq name \*(Aq!\*(Aq
\&     | <error>
.Ve
.Sp
the followin strings would produce tha followin lyrics:
.RS 4
.ie n .IP """Amen, Jim!""" 4
.el .IP "``Amen, Jim!''" 4
.IX Item "Amen, Jim!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected curse or pronoun
\&           not found
.Ve
.ie n .IP """Dammit, Jim, I be a thugged-out doctor!""" 4
.el .IP "``Dammit, Jim, I be a thugged-out doctor!''" 4
.IX Item "Dammit, Jim, I be a thugged-out doctor!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected ", I\*(Aqm a thugged-out doctor, not a"
\&           but found ", I\*(Aqm a thugged-out doctor!" instead
.Ve
.ie n .IP """Dat punk dead,\en""" 4
.el .IP "``Dat punk dead,\en''" 4
.IX Item "Dat punk dead,n"
.Vb 1
\&       ERROR (line 2): Invalid McCoy: Expected name not found
.Ve
.ie n .IP """Dat punk kickin it!""" 4
.el .IP "``Dat punk kickin it!''" 4
.IX Item "Dat punk kickin it!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected \*(Aqdead,\*(Aq but found
\&           "kickin it!" instead
.Ve
.ie n .IP """Dammit, Jim, I be a thugged-out doctor, not a pointy-eared Vulcan!""" 4
.el .IP "``Dammit, Jim, I be a thugged-out doctor, not a pointy-eared Vulcan!''" 4
.IX Item "Dammit, Jim, I be a thugged-out doctor, not a pointy-eared Vulcan!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected a profession but found
\&           "pointy\-eared Vulcan!" instead
.Ve
.RE
.RS 4
.Sp
Note that, when autogeneratin error lyrics, all underscores up in any
rule name used up in a message is replaced by single spaces (for example
\&\*(L"a_thang\*(R" becomes \*(L"a thang\*(R"). Judicious chizzle of rule
names can therefore considerably improve tha readabilitizzle of automatic
error lyrics (as well as tha maintainabilitizzle of tha original
grammar).
.Sp
If tha automatically generated error aint sufficient, it is possible to
provide a explicit message as part of tha error directive. For example:
.Sp
.Vb 3
\&    Spock: "Fascinatin \*(Aq,\*(Aq (name | \*(AqCaptain\*(Aq) \*(Aq.\*(Aq
\&     | "Highly illogical, doctor."
\&     | <error: Dude never holla'd that!>
.Ve
.Sp
which would result up in \fIall\fR failures ta parse a \*(L"Spock\*(R" subrule printin the
followin message:
.Sp
.Vb 1
\&       ERROR (line <N>): Invalid Spock:  Dude never holla'd that!
.Ve
.Sp
Da error message is treated as a \*(L"qq{...}\*(R" strang n' interpolated
when tha error is generated (\fInot\fR when tha directizzle is specified!).
Hence:
.Sp
.Vb 1
\&    <error: Mystical error near "$text">
.Ve
.Sp
would erectly bang tha ambient text strang which caused tha error.
.Sp
There is two other formz of error directive: \f(CW\*(C`<error?>\*(C'\fR and
\&\f(CW\*(C`<error?:\ msg>\*(C'\fR. These behave just like \f(CW\*(C`<error>\*(C'\fR
and \f(CW\*(C`<error:\ msg>\*(C'\fR respectively, except dat they are
only triggered if tha rule is \*(L"committed\*(R" all up in tha time they are
encountered. Y'all KNOW dat shit, muthafucka! For example:
.Sp
.Vb 3
\&    Scotty: "Ya kenna chizzle tha Lawz of Phusics," <commit> name
\&      | name <commit> \*(Aq,\*(Aq \*(Aqshe\*(Aqs goanta blaw!\*(Aq
\&      | <error?>
.Ve
.Sp
will only generate a error fo' a strang beginnin wit \*(L"Ya kenna
change tha Laws o' Phusics,\*(R" or a valid name yo, but which still fails ta match the
correspondin thang. I aint talkin' bout chicken n' gravy biatch. That is, \f(CW\*(C`$parser\->Scotty("Aye, Cap\*(Aqain")\*(C'\fR will
fail silently (since neither thang will \*(L"commit\*(R" tha rule on that
input), whereas \f(CW\*(C`$parser\->Scotty("Mr\ Spock,\ ah\ jest\ kenna\ do\*(Aqut!")\*(C'\fR
will fail wit tha error message:
.Sp
.Vb 2
\&       ERROR (line 1): Invalid Scotty: expected \*(Aqshe\*(Aqs goanta blaw!\*(Aq
\&           but found \*(AqI jest kenna do\*(Aqut!\*(Aq instead.
.Ve
.Sp
since up in dat case tha second thang would commit afta matching
the leadin name.
.Sp
Note dat ta allow dis behaviour, all \f(CW\*(C`<error>\*(C'\fR directives which are
the first item up in a thang automatically uncommit tha rule just
long enough ta allow they thang ta be attempted (that is, when
their thang fails, tha commitment is reinstated so that
subsequent thangs is skipped).
.Sp
In order ta \fIpermanently\fR uncommit tha rule before a error message,
it is necessary ta put a explicit \f(CW\*(C`<uncommit>\*(C'\fR before the
\&\f(CW\*(C`<error>\*(C'\fR. For example:
.Sp
.Vb 5
\&    line: \*(AqKirk:\*(Aq  <commit> Kirk
\&    | \*(AqSpock:\*(Aq <commit> Spock
\&    | \*(AqMcCoy:\*(Aq <commit> McCoy
\&    | <uncommit> <error?> <reject>
\&    | <resync>
.Ve
.Sp
Error lyrics generated by tha various \f(CW\*(C`<error...>\*(C'\fR directives
are not displayed immediately. Instead, they is \*(L"queued\*(R" up in a funky-ass buffer and
are only displayed once parsin ultimately fails. Mo'over,
\&\f(CW\*(C`<error...>\*(C'\fR directives dat cause one thang of a rule
to fail is automatically removed from tha message queue
if another thang subsequently causes tha entire rule ta succeed.
This means dat you can put
\&\f(CW\*(C`<error...>\*(C'\fR directives wherever useful diagnosis can be done,
and only dem associated wit actual parser failure will eva be
displayed. Y'all KNOW dat shit, muthafucka! Also peep \*(L"\s-1GOTCHAS\*(R"\s0.
.Sp
As a general rule, da most thugged-out useful diagnostics is probably generated
either all up in tha straight-up lowest level within tha grammar, or all up in tha hella
highest fo' realz. A phat rule of thumb is ta identify dem subrulez which
consist mainly (or entirely) of terminals, n' then put an
\&\f(CW\*(C`<error...>\*(C'\fR directizzle all up in tha end of any other rule which calls
one or mo' of dem subrules.
.Sp
There is one other thang up in which tha output of tha various types of
error directizzle is suppressed; namely, when tha rule containin them
is bein parsed as part of a \*(L"look-ahead\*(R" (see \*(L"Look-ahead\*(R"). In this
case, tha error directizzle will still cause tha rule ta fail yo, but will do
so silently.
.Sp
An unconditionizzle \f(CW\*(C`<error>\*(C'\fR directizzle always fails (and hence has no
associated value). This means dat encounterin such a gangbangin' finger-lickin' directive
always causes tha thang containin it ta fail yo. Hence an
\&\f(CW\*(C`<error>\*(C'\fR directizzle will inevitably be tha last (useful) item of a
rule (a level 3 warnin is issued if a thang gotz nuff shit afta a unconditional
\&\f(CW\*(C`<error>\*(C'\fR directive).
.Sp
An \f(CW\*(C`<error?>\*(C'\fR directizzle will \fIsucceed\fR (that is: fail ta fail :\-), if
the current rule is uncommitted when tha directizzle is encountered. Y'all KNOW dat shit, muthafucka! In
that case tha directivez associated value is zero yo. Hence, dis type
of error directizzle \fIcan\fR be used before tha end of a
thang. I aint talkin' bout chicken n' gravy biatch. For example:
.Sp
.Vb 3
\&    command: \*(Aqdo\*(Aq <commit> something
\&       | \*(Aqreport\*(Aq <commit> something
\&       | <error?: Syntax error> <error: Unknown command>
.Ve
.Sp
\&\fBWarning:\fR Da \f(CW\*(C`<error?>\*(C'\fR directizzle do \fInot\fR mean \*(L"always fail (but
do so silently unless committed)\*(R". Well shiiiit, it straight-up means "only fail (and report) if
committed, otherwise \fIsucceed\fR\*(L". To big up tha \*(R"fail silently if uncommitted"
semantics, it is necessary ta use:
.Sp
.Vb 2
\&    rule: item <commit> item(s)
\&    | <error?> <reject>  # FAIL SILENTLY UNLESS COMMITTED
.Ve
.Sp
But fuck dat shiznit yo, tha word on tha street is dat cuz playas seem ta expect a lone \f(CW\*(C`<error?>\*(C'\fR directive
to work like this:
.Sp
.Vb 3
\&    rule: item <commit> item(s)
\&    | <error?: Error message if committed>
\&    | <error:  Error message if uncommitted>
.Ve
.Sp
Parse::RecDescent automatically appendz a
\&\f(CW\*(C`<reject>\*(C'\fR directizzle if tha \f(CW\*(C`<error?>\*(C'\fR directive
is tha only item up in a thang. I aint talkin' bout chicken n' gravy biatch fo' realz. A level 2 warnin (see below)
is issued when dis happens.
.Sp
Da level of error reportin durin both parser construction and
parsin is controlled by tha presence or absence of four global
variables: \f(CW$::RD_ERRORS\fR, \f(CW$::RD_WARN\fR, \f(CW$::RD_HINT\fR, and
<$::RD_TRACE>. If \f(CW$::RD_ERRORS\fR is defined (and, by default, it is)
then fatal errors is reported.
.Sp
Whenever \f(CW$::RD_WARN\fR is defined, certain non-fatal problems is also reported.
.Sp
Warnings have a associated \*(L"level\*(R": 1, 2, or 3. Da higher tha level,
the mo' straight-up tha warning. Da value of tha correspondin global
variable (\f(CW$::RD_WARN\fR) determines tha \fIlowest\fR level of warnin to
be displayed. Y'all KNOW dat shit, muthafucka! Hence, ta peep \fIall\fR warnings, set \f(CW$::RD_WARN\fR ta 1.
To peep only da most thugged-out straight-up warnings set \f(CW$::RD_WARN\fR ta 3.
By default \f(CW$::RD_WARN\fR is initialized ta 3, ensurin dat straight-up but
non-fatal errors is automatically reported.
.Sp
There be also a grammar directizzle ta turn on warnings from within the
grammar: \f(CW\*(C`<warn>\*(C'\fR. Well shiiiit, it takes a optionizzle argument, which specifies
the warnin level: \f(CW\*(C`<warn: 2>\*(C'\fR.
.Sp
See \fI\*(L"\s-1DIAGNOSTICS\*(R"\s0\fR fo' a list of tha varous error n' warnin lyrics
that Parse::RecDescent generates when these two variablez is defined.
.Sp
Definin any of tha remainin variablez (which is not defined by
default) further increases tha amount of shiznit reported.
Definin \f(CW$::RD_HINT\fR causes tha parser generator ta offer
more detailed analyses n' hints on both errors n' warnings.
Note dat settin \f(CW$::RD_HINT\fR at any point automagically
sets \f(CW$::RD_WARN\fR ta 1. There be also a \f(CW\*(C`<hint>\*(C'\fR directive, which can
be hard-coded tha fuck into a grammar.
.Sp
Definin \f(CW$::RD_TRACE\fR causes tha parser generator n' tha parser to
report they progress ta \s-1STDERR\s0 up in excruciatin detail (although, without hints
unless \f(CW$::RD_HINT\fR is separately defined). This detail
can be moderated up in only one respect: if \f(CW$::RD_TRACE\fR has an
integer value (\fIN\fR) pimped outa than 1, only tha \fIN\fR charactas of
the \*(L"current parsin context\*(R" (that is, where up in tha input strang we
are at any point up in tha parse) is reported at any time.
.Sp
\&\f(CW$::RD_TRACE\fR is mainly useful fo' debuggin a grammar dat aint
behavin as you expected it to. To dis end, if \f(CW$::RD_TRACE\fR is
defined when a parser is built, any actual parser code which is
generated be also freestyled ta a gangbangin' file named \*(L"\s-1RD_TRACE\*(R"\s0 up in tha local
directory.
.Sp
There is two directives associated wit tha \f(CW$::RD_TRACE\fR variable.
If a grammar gotz nuff a \f(CW\*(C`<trace_build>\*(C'\fR directizzle anywhere up in its
specification, \f(CW$::RD_TRACE\fR is turned on durin tha parser construction
phase.  If a grammar gotz nuff a \f(CW\*(C`<trace_parse>\*(C'\fR directizzle anywhere up in its
specification, \f(CW$::RD_TRACE\fR is turned on durin any parse tha parser
performs.
.Sp
Note dat tha four variablez belong ta tha \*(L"main\*(R" package, which
makes dem easier ta refer ta up in tha code controllin tha parser, and
also make it easy as fuck  ta turn dem tha fuck into command line flags (\*(L"\-RD_ERRORS\*(R",
\&\*(L"\-RD_WARN\*(R", \*(L"\-RD_HINT\*(R", \*(L"\-RD_TRACE\*(R") under \fBperl \-s\fR.
.Sp
Da correspondin directives is useful ta \*(L"hardwire\*(R" tha various
debuggin features tha fuck into a particular grammar (rather than havin ta set
and reset external variables).
.RE
.IP "Redirectin diagnostics" 4
.IX Item "Redirectin diagnostics"
Da diagnostics provided by tha tracin mechanizzle always git all up in \s-1STDERR.\s0
If you need dem ta go elsewhere, localize n' reopen \s-1STDERR\s0 prior ta the
parse.
.Sp
For example:
.Sp
.Vb 2
\&    {
\&        local *STDERR = IO::File\->new(">$filename") or take a thugged-out dirtnap $!;
\&
\&        mah $result = $parser\->startrule($text);
\&    }
.Ve
.IP "Consistency checks" 4
.IX Item "Consistency checks"
Whenever a parser is build, Parse::RecDescent carries up a number of
(potentially expensive) consistency checks. These include: verifyin dat the
grammar aint left-recursive n' dat no rulez done been left undefined.
.Sp
These checks is blingin safeguardz durin pimpment yo, but unnecessary
overheadz when tha grammar is stable n' locked n loaded ta be deployed. Y'all KNOW dat shit, muthafucka! So
Parse::RecDescent serves up a gangbangin' finger-lickin' directizzle ta disable them: \f(CW\*(C`<nocheck>\*(C'\fR.
.Sp
If a grammar gotz nuff a \f(CW\*(C`<nocheck>\*(C'\fR directizzle anywhere up in its
specification, tha extra compile-time checks is by-passed.
.IP "Specifyin local variables" 4
.IX Item "Specifyin local variables"
It be occasionally convenient ta specify variablez which is local
to a single rule. This may be  bigged up  by includin a
\&\f(CW\*(C`<rulevar:...>\*(C'\fR directizzle anywhere up in tha rule. For example:
.Sp
.Vb 1
\&    markup: <rulevar: $tag>
\&
\&    markup: tag {($tag=$item[1]) =~ s/^<|>$//g} body[$tag]
.Ve
.Sp
Da example \f(CW\*(C`<rulevar: $tag>\*(C'\fR directizzle causes a \*(L"my\*(R" variable named
\&\f(CW$tag\fR ta be declared all up in tha start of tha subroutine implementin the
\&\f(CW\*(C`markup\*(C'\fR rule (that is, \fIbefore\fR tha straight-up original gangsta thang, regardless of
where up in tha rule it is specified).
.Sp
Specifically, any directizzle of tha form:
\&\f(CW\*(C`<rulevar:\f(CItext\f(CW>\*(C'\fR causes a line of tha form \f(CW\*(C`my \f(CItext\f(CW;\*(C'\fR
to be added all up in tha beginnin of tha rule subroutine, immediately after
the definitionz of tha followin local variables:
.Sp
.Vb 4
\&    $thisparser $commit
\&    $thisrule   @item
\&    $thisline   @arg
\&    $text   %arg
.Ve
.Sp
This means dat tha followin \f(CW\*(C`<rulevar>\*(C'\fR directives work
as expected:
.Sp
.Vb 1
\&    <rulevar: $count = 0 >
\&
\&    <rulevar: $firstarg = $arg[0] || \*(Aq\*(Aq >
\&
\&    <rulevar: $myItems = \e@item >
\&
\&    <rulevar: @context = ( $thisline, $text, @arg ) >
\&
\&    <rulevar: ($name,$age) = $arg{"name","age"} >
.Ve
.Sp
If a variable dat be also visible ta subrulez is required, it needs
to be \f(CW\*(C`local\*(C'\fR'd, not \f(CW\*(C`my\*(C'\fR'd. Y'all KNOW dat shit, muthafucka! \f(CW\*(C`rulevar\*(C'\fR defaults ta \f(CW\*(C`my\*(C'\fR yo, but if \f(CW\*(C`local\*(C'\fR
is explicitly specified:
.Sp
.Vb 1
\&    <rulevar: local $count = 0 >
.Ve
.Sp
then a \f(CW\*(C`local\*(C'\fR\-ized variable is declared instead, n' is ghon be available
within subrules.
.Sp
Note however that, cuz all such variablez is \*(L"my\*(R" variables, their
values \fIdo not persist\fR between match attempts on a given rule. To
preserve joints between match attempts, joints can be stored within the
\&\*(L"local\*(R" gangmember of tha \f(CW$thisrule\fR object:
.Sp
.Vb 6
\&    countedrule: { $thisrule\->{"local"}{"count"}++ }
\&         <reject>
\&       | subrule1
\&       | subrule2
\&       | <reject: $thisrule\->{"local"}{"count"} == 1>
\&         subrule3
.Ve
.Sp
When matchin a rule, each \f(CW\*(C`<rulevar>\*(C'\fR directizzle is matched as
if it was a unconditionizzle \f(CW\*(C`<reject>\*(C'\fR directizzle (that is, it
causes any thang up in which it appears ta immediately fail ta match).
For dis reason (and ta improve readability) it is usual ta specify any
\&\f(CW\*(C`<rulevar>\*(C'\fR directizzle up in a separate thang all up in tha start of
the rule (this has tha added advantage dat it enables
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR ta optimize away such thangs, just as it do
for tha \f(CW\*(C`<reject>\*(C'\fR directive).
.IP "Dynamically matched rules" 4
.IX Item "Dynamically matched rules"
Because regexes n' double-quoted strings is interpolated, it is relatively
easy ta specify thangs wit \*(L"context sensitive\*(R" tokens. For example:
.Sp
.Vb 1
\&    command:  keyword  body  "end $item[1]"
.Ve
.Sp
which ensures dat a cold-ass lil command block is bounded by a
"\fI<keyword>\fR...end \fI<same keyword>\fR" pair.
.Sp
Buildin thangs up in which subrulez is context sensitizzle be also possible,
via tha \f(CW\*(C`<matchrule:...>\*(C'\fR directive. This directizzle behaves
identically ta a subrule item, except dat tha rule which is invoked ta match
it is determined by tha strang specified afta tha colon. I aint talkin' bout chicken n' gravy biatch. For example, we could
rewrite tha \f(CW\*(C`command\*(C'\fR rule like this:
.Sp
.Vb 1
\&    command:  keyword  <matchrule:body>  "end $item[1]"
.Ve
.Sp
Whatever appears afta tha colon up in tha directizzle is treated as a interpolated
strin (that is, as if it rocked up in \f(CW\*(C`qq{...}\*(C'\fR operator) n' tha value of
that interpolated strang is tha name of tha subrule ta be matched.
.Sp
Of course, just puttin a cold-ass lil constant strang like \f(CW\*(C`body\*(C'\fR up in a
\&\f(CW\*(C`<matchrule:...>\*(C'\fR directizzle iz of lil interest or benefit.
Da juice of directizzle is peeped when we bust a strang dat interpolates
to suttin' interesting. For example:
.Sp
.Vb 1
\&    command:    keyword <matchrule:$item[1]_body> "end $item[1]"
\&
\&    keyword:    \*(Aqwhile\*(Aq | \*(Aqif\*(Aq | \*(Aqfunction\*(Aq
\&
\&    while_body: condizzle block
\&
\&    if_body:    condizzle block (\*(Aqelse\*(Aq block)(?)
\&
\&    function_body:  arglist block
.Ve
.Sp
Now tha \f(CW\*(C`command\*(C'\fR rule selects how tha fuck ta proceed on tha basiz of tha keyword
that is found. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be as if \f(CW\*(C`command\*(C'\fR was declared:
.Sp
.Vb 3
\&    command:    \*(Aqwhile\*(Aq    while_body    "end while"
\&       |    \*(Aqif\*(Aq       if_body   "end if"
\&       |    \*(Aqfunction\*(Aq function_body "end function"
.Ve
.Sp
When a \f(CW\*(C`<matchrule:...>\*(C'\fR directizzle is used as a repeated
subrule, tha rule name expression is \*(L"late-bound\*(R". That is, tha name of
the rule ta be called is re-evaluated \fIeach time\fR a match attempt is
made yo. Hence, tha followin grammar:
.Sp
.Vb 1
\&    { $::species = \*(Aqdawgs\*(Aq }
\&
\&    pair:   \*(Aqtwo\*(Aq <matchrule:$::species>(s)
\&
\&    dawgs:   /dawgs/ { $::species = \*(Aqcats\*(Aq }
\&
\&    cats:   /cats/
.Ve
.Sp
will match tha strang \*(L"two dawgs pussies cats\*(R" straight-up, whereas it will
only match tha strang \*(L"two dawgs dawgs dawgs\*(R" up ta tha eighth letter n' shit. If
the rule name was \*(L"early bound\*(R" (that is, evaluated only tha first
time tha directizzle is encountered up in a thang), tha reverse
behaviour would be expected.
.Sp
Note dat tha \f(CW\*(C`matchrule\*(C'\fR directizzle takes a strang dat is ta be treated
as a rule name, \fInot\fR as a rule invocation. I aint talkin' bout chicken n' gravy biatch. That is,
itz like a Perl symbolic reference, not a \f(CW\*(C`eval\*(C'\fR. Just as you can say:
.Sp
.Vb 1
\&    $subname = \*(Aqfoo\*(Aq;
\&
\&    # n' later...
\&
\&    &{$foo}(@args);
.Ve
.Sp
but not:
.Sp
.Vb 1
\&    $subname = \*(Aqfoo(@args)\*(Aq;
\&
\&    # n' later...
\&
\&    &{$foo};
.Ve
.Sp
likewise you can say:
.Sp
.Vb 1
\&    $rulename = \*(Aqfoo\*(Aq;
\&
\&    # n' up in tha grammar...
\&
\&    <matchrule:$rulename>[@args]
.Ve
.Sp
but not:
.Sp
.Vb 1
\&    $rulename = \*(Aqfoo[@args]\*(Aq;
\&
\&    # n' up in tha grammar...
\&
\&    <matchrule:$rulename>
.Ve
.IP "Deferred actions" 4
.IX Item "Deferred actions"
Da \f(CW\*(C`<defer:...>\*(C'\fR directizzle is used ta specify a action ta be
performed when (and only if!) tha current thang ultimately succeeds.
.Sp
Whenever a \f(CW\*(C`<defer:...>\*(C'\fR directizzle appears, tha code it specifies
is converted ta a cold-ass lil closure (an anonymous subroutine reference) which is
queued within tha actizzle parser object. Note that,
because tha deferred code is converted ta a cold-ass lil closure, tha jointz of any
\&\*(L"local\*(R" variable (like fuckin \f(CW$text\fR, <@item>, etc.) is preserved
until tha deferred code is straight-up executed.
.Sp
If tha parse ultimately succeeds
\&\fIand\fR tha thang up in which tha \f(CW\*(C`<defer:...>\*(C'\fR directizzle was
evaluated formed part of tha successful parse, then tha deferred code is
executed immediately before tha parse returns. If however tha thang
which queued a thugged-out deferred action fails, or one of tha higher-level
rulez which called dat thang fails, then tha deferred action is
removed from tha queue, n' hence is never executed.
.Sp
For example, given tha grammar:
.Sp
.Vb 2
\&    sentence: noun trans noun
\&    | noun intrans
\&
\&    noun:     \*(Aqthe dog\*(Aq
\&        { print "$item[1]\et(noun)\en" }
\&    |     \*(Aqthe meat\*(Aq
\&        { print "$item[1]\et(noun)\en" }
\&
\&    trans:    \*(Aqate\*(Aq
\&        { print "$item[1]\et(transitive)\en" }
\&
\&    intrans:  \*(Aqate\*(Aq
\&        { print "$item[1]\et(intransitive)\en" }
\&       |  \*(Aqbarked\*(Aq
\&        { print "$item[1]\et(intransitive)\en" }
.Ve
.Sp
then parsin tha sentence \f(CW"the dawg ate"\fR would produce tha output:
.Sp
.Vb 4
\&    tha dawg  (noun)
\&    ate  (transitive)
\&    tha dawg  (noun)
\&    ate  (intransitive)
.Ve
.Sp
This is cuz, even though tha straight-up original gangsta thang of \f(CW\*(C`sentence\*(C'\fR
ultimately fails, its initial subrulez \f(CW\*(C`noun\*(C'\fR n' \f(CW\*(C`trans\*(C'\fR do match,
and hence they execute they associated actions.
Then tha second thang of \f(CW\*(C`sentence\*(C'\fR succeeds, causin the
actionz of tha subrulez \f(CW\*(C`noun\*(C'\fR n' \f(CW\*(C`intrans\*(C'\fR ta be executed as well.
.Sp
On tha other hand, if tha actions was replaced by \f(CW\*(C`<defer:...>\*(C'\fR
directives:
.Sp
.Vb 2
\&    sentence: noun trans noun
\&    | noun intrans
\&
\&    noun:     \*(Aqthe dog\*(Aq
\&        <defer: print "$item[1]\et(noun)\en" >
\&    |     \*(Aqthe meat\*(Aq
\&        <defer: print "$item[1]\et(noun)\en" >
\&
\&    trans:    \*(Aqate\*(Aq
\&        <defer: print "$item[1]\et(transitive)\en" >
\&
\&    intrans:  \*(Aqate\*(Aq
\&        <defer: print "$item[1]\et(intransitive)\en" >
\&       |  \*(Aqbarked\*(Aq
\&        <defer: print "$item[1]\et(intransitive)\en" >
.Ve
.Sp
the output would be:
.Sp
.Vb 2
\&    tha dawg  (noun)
\&    ate  (intransitive)
.Ve
.Sp
since deferred actions is only executed if they was evaluated in
a thang which ultimately contributes ta tha successful parse.
.Sp
In dis case, even though tha straight-up original gangsta thang of \f(CW\*(C`sentence\*(C'\fR caused
the subrulez \f(CW\*(C`noun\*(C'\fR n' \f(CW\*(C`trans\*(C'\fR ta match, dat thang ultimately
failed n' so tha deferred actions queued by dem subrulez was subsequently
disgarded. Y'all KNOW dat shit, muthafucka! Da second thang then succeeded, causin tha entire
parse ta succeed, n' so tha deferred actions queued by tha (second) match of
the \f(CW\*(C`noun\*(C'\fR subrule n' tha subsequent match of \f(CW\*(C`intrans\*(C'\fR \fIare\fR preserved and
eventually executed.
.Sp
Deferred actions provide a meanz of pimpin-out tha performizzle of a parser,
by only executin dem actions which is part of tha final parse-tree
for tha input data.
.Sp
Alternatively, deferred actions can be viewed as a mechanizzle fo' building
(and executing) a
customized subroutine correspondin ta tha given input data, much up in the
same way dat autoactions (see \*(L"Autoactions\*(R") can be used ta build a
customized data structure fo' specific input.
.Sp
Whether or not tha action it specifies is eva executed,
a \f(CW\*(C`<defer:...>\*(C'\fR directizzle always succeeds, returnin the
number of deferred actions currently queued at dat point.
.IP "Parsin Perl" 4
.IX Item "Parsin Perl"
Parse::RecDescent serves up limited support fo' parsin subsetz of Perl,
namely: quote-like operators, Perl variables, n' complete code blocks.
.Sp
Da \f(CW\*(C`<perl_quotelike>\*(C'\fR directizzle can be used ta parse any Perl
quote-like operator: \f(CW\*(Aqa string\*(Aq\fR, \f(CW\*(C`m/a pattern/\*(C'\fR, \f(CW\*(C`tr{ans}{lation}\*(C'\fR,
etc.  It do dis by callin \fIText::Balanced::quotelike()\fR.
.Sp
If a quote-like operator is found, a reference ta a array of eight elements
is returned. Y'all KNOW dat shit, muthafucka! Those elements is identical ta tha last eight elements returned
by \fIText::Balanced::extract_quotelike()\fR up in a array context, namely:
.RS 4
.IP "[0]" 4
.IX Item "[0]"
the name of tha quotelike operator \*(-- 'q', 'qq', 'm', 's', 'tr' \*(-- if the
operator was named; otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[1]" 4
.IX Item "[1]"
the left delimita of tha straight-up original gangsta block of tha operation,
.IP "[2]" 4
.IX Item "[2]"
the text of tha straight-up original gangsta block of tha operation
(that is, tha contents of
a quote, tha regex of a match, or substitution or tha target list of a
translation),
.IP "[3]" 4
.IX Item "[3]"
the right delimita of tha straight-up original gangsta block of tha operation,
.IP "[4]" 4
.IX Item "[4]"
the left delimita of tha second block of tha operation if there is one
(that is, if it aint nuthin but a \f(CW\*(C`s\*(C'\fR, \f(CW\*(C`tr\*(C'\fR, or \f(CW\*(C`y\*(C'\fR); otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[5]" 4
.IX Item "[5]"
the text of tha second block of tha operation if there is one
(that is, tha replacement of a substitution or tha translation list
of a translation); otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[6]" 4
.IX Item "[6]"
the right delimita of tha second block of tha operation (if any);
otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[7]" 4
.IX Item "[7]"
the trailin modifiers on tha operation (if any); otherwise \f(CW\*(C`undef\*(C'\fR.
.RE
.RS 4
.Sp
If a quote-like expression aint found, tha directizzle fails wit tha usual
\&\f(CW\*(C`undef\*(C'\fR value.
.Sp
Da \f(CW\*(C`<perl_variable>\*(C'\fR directizzle can be used ta parse any Perl
variable: \f(CW$scalar\fR, \f(CW@array\fR, \f(CW%hash\fR, \f(CW$ref\fR\->{field}[$index], etc.
It do dis by callin \fIText::Balanced::extract_variable()\fR.
.Sp
If tha directizzle matches text representin a valid Perl variable
specification, it returns dat text. Otherwise it fails wit tha usual
\&\f(CW\*(C`undef\*(C'\fR value.
.Sp
Da \f(CW\*(C`<perl_codeblock>\*(C'\fR directizzle can be used ta parse curly-brace-delimited block of Perl code, such as: { \f(CW$a\fR = 1; f() =~ m/pat/; }.
It do dis by callin \fIText::Balanced::extract_codeblock()\fR.
.Sp
If tha directizzle matches text representin a valid Perl code block,
it returns dat text. Otherwise it fails wit tha usual \f(CW\*(C`undef\*(C'\fR value.
.Sp
Yo ass can also tell it what tha fuck kind of brackets ta use as tha outermost
delimiters. For example:
.Sp
.Vb 1
\&    arglist: <perl_codeblock ()>
.Ve
.Sp
causes a arglist ta match a perl code block whose outermost delimiters
are \f(CW\*(C`(...)\*(C'\fR (rather than tha default \f(CW\*(C`{...}\*(C'\fR).
.RE
.IP "Constructin tokens" 4
.IX Item "Constructin tokens"
Eventually, Parse::RecDescent is ghon be able ta parse tokenized input, as
well as ordinary strings. In preparation fo' dis joyous day, the
\&\f(CW\*(C`<token:...>\*(C'\fR directizzle has been provided.
This directizzle creates a token which is ghon be suitable for
input ta a Parse::RecDescent parser (when it eventually supports
tokenized input).
.Sp
Da text of tha token is tha value of the
immediately precedin item up in tha thang. I aint talkin' bout chicken n' gravy biatch fo' realz. A
\&\f(CW\*(C`<token:...>\*(C'\fR directizzle always succeedz wit a return
value which is tha hash reference dat is tha freshly smoked up token. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it also
sets tha return value fo' tha thang ta dat hash ref.
.Sp
Da \f(CW\*(C`<token:...>\*(C'\fR directizzle make it easy as fuck  ta build
a Parse::RecDescent\-compatible lexer up in Parse::RecDescent:
.Sp
.Vb 3
\&    mah $lexer = freshly smoked up Parse::RecDescent q
\&    {
\&    lex:    token(s)
\&
\&    token:  /a\eb/          <token:INDEF>
\&         |  /the\eb/        <token:DEF>
\&         |  /fly\eb/        <token:NOUN,VERB>
\&         |  /[a\-z]+/i { lc $item[1] }  <token:ALPHA>
\&         |  <error: Unknown token>
\&
\&    };
.Ve
.Sp
which will eventually be able ta be used wit a regular Parse::RecDescent
grammar:
.Sp
.Vb 3
\&    mah $parser = freshly smoked up Parse::RecDescent q
\&    {
\&    startrule: subrule1 subrule 2
\&
\&    # ETC...
\&    };
.Ve
.Sp
either wit a pre-lexin phase:
.Sp
.Vb 1
\&    $parser\->startrule( $lexer\->lex($data) );
.Ve
.Sp
or wit a lex-on-demand approach:
.Sp
.Vb 1
\&    $parser\->startrule( sub{$lexer\->token(\e$data)} );
.Ve
.Sp
But at present, only tha \f(CW\*(C`<token:...>\*(C'\fR directizzle is
actually implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da rest is vapourware.
.IP "Specifyin operations" 4
.IX Item "Specifyin operations"
One of tha commonest requirements when buildin a parser is ta specify
binary operators. Unfortunately, up in a aiiight grammar, tha rulez for
such thangs is awkward:
.Sp
.Vb 2
\&    disjunction:    conjunction (\*(Aqor\*(Aq conjunction)(s?)
\&        { $return = [ $item[1], @{$item[2]} ] }
\&
\&    conjunction:    atom (\*(Aqand\*(Aq atom)(s?)
\&        { $return = [ $item[1], @{$item[2]} ] }
.Ve
.Sp
or inefficient:
.Sp
.Vb 4
\&    disjunction:    conjunction \*(Aqor\*(Aq disjunction
\&        { $return = [ $item[1], @{$item[2]} ] }
\&       |    conjunction
\&        { $return = [ $item[1] ] }
\&
\&    conjunction:    atom \*(Aqand\*(Aq conjunction
\&        { $return = [ $item[1], @{$item[2]} ] }
\&       |    atom
\&        { $return = [ $item[1] ] }
.Ve
.Sp
and either way is skanky n' hard ta git right.
.Sp
Da \f(CW\*(C`<leftop:...>\*(C'\fR n' \f(CW\*(C`<rightop:...>\*(C'\fR directives provide an
easier way of specifyin such operations. Usin \f(CW\*(C`<leftop:...>\*(C'\fR the
above examplez become:
.Sp
.Vb 2
\&    disjunction:    <leftop: conjunction \*(Aqor\*(Aq conjunction>
\&    conjunction:    <leftop: atom \*(Aqand\*(Aq atom>
.Ve
.Sp
Da \f(CW\*(C`<leftop:...>\*(C'\fR directizzle specifies a left-associatizzle binary operator.
It be specified round three other grammar elements
(typically subrulez or terminals), which match tha left operand,
the operator itself, n' tha right operand respectively.
.Sp
A \f(CW\*(C`<leftop:...>\*(C'\fR directizzle such as:
.Sp
.Vb 1
\&    disjunction:    <leftop: conjunction \*(Aqor\*(Aq conjunction>
.Ve
.Sp
is converted ta tha following:
.Sp
.Vb 2
\&    disjunction:    ( conjunction (\*(Aqor\*(Aq conjunction)(s?)
\&        { $return = [ $item[1], @{$item[2]} ] } )
.Ve
.Sp
In other lyrics, a \f(CW\*(C`<leftop:...>\*(C'\fR directizzle matches tha left operand followed by zero
or mo' repetitionz of both tha operator n' tha right operand. Y'all KNOW dat shit, muthafucka! Well shiiiit, it then
flattens tha matched shit tha fuck into a anonymous array which becomes the
(single) value of tha entire \f(CW\*(C`<leftop:...>\*(C'\fR directive.
.Sp
For example, a \f(CW\*(C`<leftop:...>\*(C'\fR directizzle such as:
.Sp
.Vb 1
\&    output:  <leftop: ident \*(Aq<<\*(Aq expr >
.Ve
.Sp
when given a strang such as:
.Sp
.Vb 1
\&    cout << var << "str" << 3
.Ve
.Sp
would match, n' \f(CW$item[1]\fR would be set to:
.Sp
.Vb 1
\&    [ \*(Aqcout\*(Aq, \*(Aqvar\*(Aq, \*(Aq"str"\*(Aq, \*(Aq3\*(Aq ]
.Ve
.Sp
In other lyrics:
.Sp
.Vb 1
\&    output:  <leftop: ident \*(Aq<<\*(Aq expr >
.Ve
.Sp
is equivalent ta a left-associatizzle operator:
.Sp
.Vb 5
\&    output:  ident          { $return = [$item[1]]   }
\&          |  ident \*(Aq<<\*(Aq expr        { $return = [@item[1,3]]     }
\&          |  ident \*(Aq<<\*(Aq expr \*(Aq<<\*(Aq expr      { $return = [@item[1,3,5]]   }
\&          |  ident \*(Aq<<\*(Aq expr \*(Aq<<\*(Aq expr \*(Aq<<\*(Aq expr    { $return = [@item[1,3,5,7]] }
\&          #  ...etc...
.Ve
.Sp
Similarly, tha \f(CW\*(C`<rightop:...>\*(C'\fR directizzle takes a left operand, a operator, n' a right operand:
.Sp
.Vb 1
\&    assign:  <rightop: var \*(Aq=\*(Aq expr >
.Ve
.Sp
and converts dem to:
.Sp
.Vb 2
\&    assign:  ( (var \*(Aq=\*(Aq {$return=$item[1]})(s?) expr
\&        { $return = [ @{$item[1]}, $item[2] ] } )
.Ve
.Sp
which is equivalent ta a right-associatizzle operator:
.Sp
.Vb 5
\&    assign:  expr       { $return = [$item[1]]       }
\&          |  var \*(Aq=\*(Aq expr       { $return = [@item[1,3]]     }
\&          |  var \*(Aq=\*(Aq var \*(Aq=\*(Aq expr   { $return = [@item[1,3,5]]   }
\&          |  var \*(Aq=\*(Aq var \*(Aq=\*(Aq var \*(Aq=\*(Aq expr   { $return = [@item[1,3,5,7]] }
\&          #  ...etc...
.Ve
.Sp
Note dat fo' both tha \f(CW\*(C`<leftop:...>\*(C'\fR n' \f(CW\*(C`<rightop:...>\*(C'\fR directives, tha directizzle do not normally
return tha operator itself, just a list of tha operandz involved. Y'all KNOW dat shit, muthafucka! This is
particularly handy fo' specifyin lists:
.Sp
.Vb 2
\&    list: \*(Aq(\*(Aq <leftop: list_item \*(Aq,\*(Aq list_item> \*(Aq)\*(Aq
\&        { $return = $item[2] }
.Ve
.Sp
There is, however, a problem: sometimes tha operator is itself significant.
For example, up in a Perl list a cold-ass lil comma n' a \f(CW\*(C`=>\*(C'\fR is both
valid separators yo, but tha \f(CW\*(C`=>\*(C'\fR has additionizzle stringification semantics.
Hence itz blingin ta know which was used up in each case.
.Sp
To solve dis problem the
\&\f(CW\*(C`<leftop:...>\*(C'\fR n' \f(CW\*(C`<rightop:...>\*(C'\fR directives
\&\fIdo\fR return tha operator(s) as well, under two circumstances.
Da first case is where tha operator is specified as a subrule. In dat instance,
whatever tha operator matches is returned (on tha assumption dat if tha operator
is blingin enough ta have its own subrule, then itz blingin enough ta return).
.Sp
Da second case is where tha operator is specified as a regular
expression. I aint talkin' bout chicken n' gravy biatch. In dat case, if tha straight-up original gangsta bracketed subpattern of the
regular expression matches, dat matchin value is returned (this be analogous to
the behaviour of tha Perl \f(CW\*(C`split\*(C'\fR function, except dat only tha straight-up original gangsta subpattern
is returned).
.Sp
In other lyrics, given tha input:
.Sp
.Vb 1
\&    ( a=>1, b=>2 )
.Ve
.Sp
the justifications:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item separator list_item>  \*(Aq)\*(Aq
\&
\&    separator: \*(Aq,\*(Aq | \*(Aq=>\*(Aq
.Ve
.Sp
or:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item /(,|=>)/ list_item>  \*(Aq)\*(Aq
.Ve
.Sp
cause tha list separators ta be interleaved wit tha operandz up in the
anonymous array up in \f(CW$item[2]\fR:
.Sp
.Vb 1
\&    [ \*(Aqa\*(Aq, \*(Aq=>\*(Aq, \*(Aq1\*(Aq, \*(Aq,\*(Aq, \*(Aqb\*(Aq, \*(Aq=>\*(Aq, \*(Aq2\*(Aq ]
.Ve
.Sp
But tha followin version:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item /,|=>/ list_item>  \*(Aq)\*(Aq
.Ve
.Sp
returns only tha operators:
.Sp
.Vb 1
\&    [ \*(Aqa\*(Aq, \*(Aq1\*(Aq, \*(Aqb\*(Aq, \*(Aq2\*(Aq ]
.Ve
.Sp
Of course, none of tha above justifications handle tha case of a empty
list, since tha \f(CW\*(C`<leftop:...>\*(C'\fR n' \f(CW\*(C`<rightop:...>\*(C'\fR directives
require at least a single right or left operand ta match. To specify
that tha operator can match \*(L"trivially\*(R",
itz necessary ta add a \f(CW\*(C`(s?)\*(C'\fR qualifier ta tha directive:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item /(,|=>)/ list_item>(s?)  \*(Aq)\*(Aq
.Ve
.Sp
Note dat up in almost all tha above examples, tha straight-up original gangsta n' third arguments
of tha \f(CW\*(C`<leftop:...>\*(C'\fR directizzle was tha same subrule. That is cuz
\&\f(CW\*(C`<leftop:...>\*(C'\fRz is frequently used ta specify \*(L"separated\*(R" listz of the
same type of item. To make such lists easier ta specify, tha following
syntax:
.Sp
.Vb 1
\&    list:   element(s /,/)
.Ve
.Sp
is exactly equivalent to:
.Sp
.Vb 1
\&    list:   <leftop: element /,/ element>
.Ve
.Sp
Note dat tha separator must be specified as a raw pattern (i.e.
not a strang or subrule).
.IP "Scored thangs" 4
.IX Item "Scored thangs"
By default, Parse::RecDescent grammar rulez always accept tha first
thang dat matches tha input. But if two or mo' thangs may
potentially match tha same input, choosin tha straight-up original gangsta dat do so may
not be optimal.
.Sp
For example, if you was parsin tha sentence \*(L"time flies like a arrow\*(R",
you might bust a rule like this:
.Sp
.Vb 3
\&    sentence: verb noun preposizzle article noun { [@item] }
\&    | adjectizzle noun verb article noun   { [@item] }
\&    | noun verb preposizzle article noun { [@item] }
.Ve
.Sp
Each of these thangs matches tha sentence yo, but tha third one
is da most thugged-out likely interpretation. I aint talkin' bout chicken n' gravy biatch. But fuck dat shiznit yo, tha word on tha street is dat if tha sentence had been
\&\*(L"fruit flies like a funky-ass banana\*(R", then tha second thang is probably
the right match.
.Sp
To cata fo' such situtations, tha \f(CW\*(C`<score:...>\*(C'\fR can be used.
Da directizzle is equivalent ta a unconditionizzle \f(CW\*(C`<reject>\*(C'\fR,
except dat it allows you ta specify a \*(L"score\*(R" fo' tha current
thang. I aint talkin' bout chicken n' gravy biatch. If dat score is numerically pimped outa than tha best
score of any precedin thang, tha current thang is cached fo' later
consideration. I aint talkin' bout chicken n' gravy biatch. If no lata thang matches, then tha cached
thang is treated as havin matched, n' tha value of the
item immediately before its \f(CW\*(C`<score:...>\*(C'\fR directizzle is returned as the
result.
.Sp
In other lyrics, by puttin a \f(CW\*(C`<score:...>\*(C'\fR directizzle all up in tha end of
each thang, you can select which thang matches using
criteria other than justification order n' shit. For example:
.Sp
.Vb 3
\&    sentence: verb noun preposizzle article noun { [@item] } <score: sensible(@item)>
\&    | adjectizzle noun verb article noun   { [@item] } <score: sensible(@item)>
\&    | noun verb preposizzle article noun { [@item] } <score: sensible(@item)>
.Ve
.Sp
Now, when each thang reaches its respectizzle \f(CW\*(C`<score:...>\*(C'\fR
directive, tha subroutine \f(CW\*(C`sensible\*(C'\fR is ghon be called ta evaluate the
matched shit (somehow). Once all thangs done been tried, the
one which \f(CW\*(C`sensible\*(C'\fR banged up most highly is ghon be tha one dat is
accepted as a match fo' tha rule.
.Sp
Da variable \f(CW$score\fR always holdz tha current dopest score of any thang,
and tha variable \f(CW$score_return\fR holdz tha correspondin return value.
.Sp
As another example, tha followin grammar matches lines dat may be
separated by commas, colons, or semi-colons. This can be tricky if
a colon-separated line also gotz nuff commas, or vice versa. Da grammar
resolves tha ambiguitizzle by selectin tha rule dat thangs up in dis biatch up in the
fewest fields:
.Sp
.Vb 3
\&    line: seplist[sep=>\*(Aq,\*(Aq]  <score: \-@{$item[1]}>
\&    | seplist[sep=>\*(Aq:\*(Aq]  <score: \-@{$item[1]}>
\&    | seplist[sep=>" "]  <score: \-@{$item[1]}>
\&
\&    seplist: <skip:""> <leftop: /[^$arg{sep}]*/ "$arg{sep}" /[^$arg{sep}]*/>
.Ve
.Sp
Note tha use of negation within tha \f(CW\*(C`<score:...>\*(C'\fR directive
to ensure dat tha seplist wit da most thugged-out shit gets tha lowest score.
.Sp
As tha above examplez indicate, it is often tha case dat all thangs
in a rule use exactly tha same \f(CW\*(C`<score:...>\*(C'\fR directive. Well shiiiit, it is
tedious ta gotta repeat dis identical directizzle up in every last muthafuckin thang, so
Parse::RecDescent also serves up tha \f(CW\*(C`<autoscore:...>\*(C'\fR directive.
.Sp
If a \f(CW\*(C`<autoscore:...>\*(C'\fR directizzle appears up in any
thang of a rule, tha code it specifies is used as tha scoring
code fo' every last muthafuckin thang of dat rule, except thangs dat already
end wit a explicit \f(CW\*(C`<score:...>\*(C'\fR directive. Thus tha rulez above could
be rewritten:
.Sp
.Vb 4
\&    line: <autoscore: \-@{$item[1]}>
\&    line: seplist[sep=>\*(Aq,\*(Aq]
\&    | seplist[sep=>\*(Aq:\*(Aq]
\&    | seplist[sep=>" "]
\&
\&
\&    sentence: <autoscore: sensible(@item)>
\&    | verb noun preposizzle article noun { [@item] }
\&    | adjectizzle noun verb article noun   { [@item] }
\&    | noun verb preposizzle article noun { [@item] }
.Ve
.Sp
Note dat tha \f(CW\*(C`<autoscore:...>\*(C'\fR directizzle itself acts as an
unconditionizzle \f(CW\*(C`<reject>\*(C'\fR, n' (like tha \f(CW\*(C`<rulevar:...>\*(C'\fR
directive) is pruned at compile-time wherever possible.
.IP "Dispensin wit grammar checks" 4
.IX Item "Dispensin wit grammar checks"
Durin tha compilation phase of parser construction, Parse::RecDescent performs
a lil' small-ass number of checks on tha grammar itz given. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Specifically it checks that
the grammar aint left-recursive, dat there be no \*(L"insatiable\*(R" constructs of
the form:
.Sp
.Vb 1
\&    rule: subrule(s) subrule
.Ve
.Sp
and dat there be no rulez missin (i.e. referred ta yo, but never defined).
.Sp
These checks is blingin durin pimpment yo, but can slow down parser
construction up in stable code. Right back up in yo muthafuckin ass. So Parse::RecDescent serves up the
<nocheck> directizzle ta turn dem off. Da directizzle can only appear
before tha straight-up original gangsta rule definition, n' switches off checkin all up in tha rest
of tha current grammar.
.Sp
Typically, dis directizzle would be added when a parser has been thoroughly
tested n' is locked n loaded fo' release.
.SS "Subrule argument lists"
.IX Subsection "Subrule argument lists"
It be occasionally useful ta pass data ta a subrule which is bein invoked. Y'all KNOW dat shit, muthafucka! For
example, consider tha followin grammar fragment:
.PP
.Vb 1
\&    classdecl: keyword decl
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      # WHATEVER
.Ve
.PP
Da \f(CW\*(C`decl\*(C'\fR rule might wish ta know which of tha two keywordz was used
(since it may affect some aspect of tha way tha subsequent declaration
is interpreted). \f(CW\*(C`Parse::RecDescent\*(C'\fR allows tha grammar designer to
pass data tha fuck into a rule, by placin dat data up in a \fIargument list\fR
(that is, up in square brackets) immediately afta any subrule item up in a
thang. I aint talkin' bout chicken n' gravy biatch yo. Hence, we could pass tha keyword ta \f(CW\*(C`decl\*(C'\fR as bigs up:
.PP
.Vb 1
\&    classdecl: keyword decl[ $item[1] ]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      # WHATEVER
.Ve
.PP
Da argument list can consist of any number (includin zero!) of comma-separated
Perl expressions. In other lyrics, it looks exactly like a Perl anonymous
array reference. For example, we could pass tha keyword, tha name of the
surroundin rule, n' tha literal 'keyword' ta \f(CW\*(C`decl\*(C'\fR like so:
.PP
.Vb 1
\&    classdecl: keyword decl[$item[1],$item[0],\*(Aqkeyword\*(Aq]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      # WHATEVER
.Ve
.PP
Within tha rule ta which tha data is passed (\f(CW\*(C`decl\*(C'\fR up in tha above examples)
that data be available as tha elementz of a local variable \f(CW@arg\fR yo. Hence
\&\f(CW\*(C`decl\*(C'\fR might report its intentions as bigs up:
.PP
.Vb 1
\&    classdecl: keyword decl[$item[1],$item[0],\*(Aqkeyword\*(Aq]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      { print "Declarin $arg[0] (a $arg[2])\en";
\&         print "(this rule called by $arg[1])" }
.Ve
.PP
Subrule argument lists can also be interpreted as hashes, simply by using
the local variable \f(CW%arg\fR instead of \f(CW@arg\fR yo. Hence we could rewrite the
previous example:
.PP
.Vb 3
\&    classdecl: keyword decl[keyword => $item[1],
\&        calla  => $item[0],
\&        type    => \*(Aqkeyword\*(Aq]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      { print "Declarin $arg{keyword} (a $arg{type})\en";
\&         print "(this rule called by $arg{caller})" }
.Ve
.PP
Both \f(CW@arg\fR n' \f(CW%arg\fR is always available, so tha grammar designer may
choose whichever convention (or combination of conventions) suits best.
.PP
Subrule argument lists is also useful fo' bustin \*(L"rule templates\*(R"
(especially when used up in conjunction wit tha \f(CW\*(C`<matchrule:...>\*(C'\fR
directive). For example, tha subrule:
.PP
.Vb 4
\&    list:     <matchrule:$arg{rule}> /$arg{sep}/ list[%arg]
\&        { $return = [ $item[1], @{$item[3]} ] }
\&    |     <matchrule:$arg{rule}>
\&        { $return = [ $item[1]] }
.Ve
.PP
is a handy template fo' tha common problem of matchin a separated list.
For example:
.PP
.Vb 1
\&    function: \*(Aqfunc\*(Aq name \*(Aq(\*(Aq list[rule=>\*(Aqparam\*(Aq,sep=>\*(Aq;\*(Aq] \*(Aq)\*(Aq
\&
\&    param:    list[rule=>\*(Aqname\*(Aq,sep=>\*(Aq,\*(Aq] \*(Aq:\*(Aq typename
\&
\&    name:     /\ew+/
\&
\&    typename: name
.Ve
.PP
When a subrule argument list is used wit a repeated subrule, tha argument list
goes \fIbefore\fR tha repetizzle specifier:
.PP
.Vb 1
\&    list:   /some|many/ thang[ $item[1] ](s)
.Ve
.PP
Da argument list is \*(L"late bound\*(R". That is, it is re-evaluated fo' every
repetizzle of tha repeated subrule.
This means dat each repeated attempt ta match tha subrule may be
passed a cold-ass lil straight-up different set of arguments if tha value of the
expression up in tha argument list chizzlez between attempts, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. So, for
example, tha grammar:
.PP
.Vb 1
\&    { $::species = \*(Aqdawgs\*(Aq }
\&
\&    pair:   \*(Aqtwo\*(Aq animal[$::species](s)
\&
\&    animal: /$arg[0]/ { $::species = \*(Aqcats\*(Aq }
.Ve
.PP
will match tha strang \*(L"two dawgs pussies cats\*(R" straight-up, whereas
it will only match tha strang \*(L"two dawgs dawgs dawgs\*(R" up ta the
eighth letter n' shit. If tha value of tha argument list was \*(L"early bound\*(R"
(that is, evaluated only tha last time a repeated subrule match is
attempted), one would expect tha matchin behaviours ta be reversed.
.PP
Of course, it is possible ta effectively \*(L"early bind\*(R" such argument lists
by passin dem a value which do not chizzle on each repetition. I aint talkin' bout chicken n' gravy biatch. For example:
.PP
.Vb 1
\&    { $::species = \*(Aqdawgs\*(Aq }
\&
\&    pair:   \*(Aqtwo\*(Aq { $::species } animal[$item[2]](s)
\&
\&    animal: /$arg[0]/ { $::species = \*(Aqcats\*(Aq }
.Ve
.PP
Arguments can also be passed ta tha start rule, simply by appendin them
to tha argument list wit which tha start rule is called (\fIafter\fR the
\&\*(L"line number\*(R" parameter). For example, given:
.PP
.Vb 1
\&    $parser = freshly smoked up Parse::RecDescent ( $grammar );
\&
\&    $parser\->data($text, 1, "str", 2, \e@arr);
\&
\&    #         ^^^^^  ^  ^^^^^^^^^^^^^^^
\&    #       |    |     |
\&    # TEXT TO BE PARSED  |     |
\&    # STARTING LINE NUMBER     |
\&    # ELEMENTS OF @arg WHICH IS PASSED TO RULE data
.Ve
.PP
then within tha thangz of tha rule \f(CW\*(C`data\*(C'\fR, tha array \f(CW@arg\fR will contain
\&\f(CW\*(C`("str", 2, \e@arr)\*(C'\fR.
.SS "Alternations"
.IX Subsection "Alternations"
Alternations is implicit (unnamed) rulez defined as part of a thang. I aint talkin' bout chicken n' gravy biatch fo' realz. An
alternation is defined as a seriez of '|'\-separated thangs inside a
pair of round brackets, n' you can put dat on yo' toast. For example:
.PP
.Vb 1
\&    character: \*(Aqthe\*(Aq ( phat | wack | skanky ) /dude/
.Ve
.PP
Every alternation implicitly defines a freshly smoked up subrule, whose
automatically-generated name indicates its origin:
\&\*(L"_alternation_<I>_of_thang_<P>_of_rule<R>\*(R" fo' tha appropriate
valuez of <I>, <P>, n' <R> fo' realz. A call ta dis implicit subrule is then
inserted up in place of tha brackets yo. Hence tha above example is merely a
convenient short-hand for:
.PP
.Vb 3
\&    character: \*(Aqthe\*(Aq
\&       _alternation_1_of_thang_1_of_rule_character
\&       /dude/
\&
\&    _alternation_1_of_thang_1_of_rule_character:
\&       phat | wack | skanky
.Ve
.PP
Since alternations is parsed by recursively callin tha parser generator,
any type(s) of item can step tha fuck up in a alternation. I aint talkin' bout chicken n' gravy biatch. For example:
.PP
.Vb 5
\&    character: \*(Aqthe\*(Aq ( \*(Aqhigh\*(Aq "plains"  # Silent, wit poncho
\&         | /no[\- ]name/ # Silent, no poncho
\&         | vengeance_seekin    # Poncho\-optional
\&         | <error>
\&         ) drifter
.Ve
.PP
In dis case, if a error occurred, tha automatically generated
message would be:
.PP
.Vb 3
\&    ERROR (line <N>): Invalid implicit subrule: Expected
\&          \*(Aqhigh\*(Aq or /no[\- ]name/ or generic,
\&          but found "pacifist" instead
.Ve
.PP
Since every last muthafuckin alternation straight-up has a name, itz even possible
to extend or replace them:
.PP
.Vb 4
\&    parser\->Replace(
\&    "_alternation_1_of_thang_1_of_rule_character:
\&        \*(Aqgeneric Eastwood\*(Aq"
\&        );
.Ve
.PP
Mo' blinginly, since alternations is a gangbangin' form of subrule, they can be given
repetizzle specifiers:
.PP
.Vb 1
\&    character: \*(Aqthe\*(Aq ( phat | wack | skanky )(?) /dude/
.Ve
.SS "Incremenstrual Parsing"
.IX Subsection "Incremenstrual Parsing"
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR serves up two methodz \- \f(CW\*(C`Extend\*(C'\fR n' \f(CW\*(C`Replace\*(C'\fR \- which
can be used ta alta tha grammar matched by a parser n' shit. Both methods
take tha same argument as \f(CW\*(C`Parse::RecDescent::new\*(C'\fR, namely a
grammar justification string
.PP
\&\f(CW\*(C`Parse::RecDescent::Extend\*(C'\fR interprets tha grammar justification n' addz any
thangs it findz ta tha end of tha rulez fo' which they is specified. Y'all KNOW dat shit, muthafucka! For
example:
.PP
.Vb 2
\&    $add = "name: \*(AqJimmy\-Bob\*(Aq | \*(AqBobby\-Jim\*(Aq\endesc: colour /necks?/";
\&    parser\->Extend($add);
.Ve
.PP
addz two thangs ta tha rule \*(L"name\*(R" (bustin it if necessary) n' one
thang ta tha rule \*(L"desc\*(R".
.PP
\&\f(CW\*(C`Parse::RecDescent::Replace\*(C'\fR is identical, except dat it first resets are
rule specified up in tha additionizzle grammar, removin any existin thangs.
Hence after:
.PP
.Vb 2
\&    $add = "name: \*(AqJimmy\-Bob\*(Aq | \*(AqBobby\-Jim\*(Aq\endesc: colour /necks?/";
\&    parser\->Replace($add);
.Ve
.PP
are is \fIonly\fR valid \*(L"name\*(R"s n' tha one possible description.
.PP
A mo' bangin-ass use of tha \f(CW\*(C`Extend\*(C'\fR n' \f(CW\*(C`Replace\*(C'\fR methodz is ta booty-call them
inside tha action of a executin parser n' shit. For example:
.PP
.Vb 3
\&    typedef: \*(Aqtypedef\*(Aq type_name identifier \*(Aq;\*(Aq
\&           { $thisparser\->Extend("type_name: \*(Aq$item[3]\*(Aq") }
\&       | <error>
\&
\&    identifier: ...!type_name /[A\-Za\-z_]w*/
.Ve
.PP
which automatically prevents type names from bein typedef'd, or:
.PP
.Vb 6
\&    command: \*(Aqmap\*(Aq key_name \*(Aqto\*(Aq abort_key
\&           { $thisparser\->Replace("abort_key: \*(Aq$item[2]\*(Aq") }
\&       | \*(Aqmap\*(Aq key_name \*(Aqto\*(Aq key_name
\&           { map_key($item[2],$item[4]) }
\&       | abort_key
\&           { exit if confirm("abort?") }
\&
\&    abort_key: \*(Aqq\*(Aq
\&
\&    key_name: ...!abort_key /[A\-Za\-z]/
.Ve
.PP
which allows tha user ta chizzle tha abort key bindin yo, but not ta unbind dat shit.
.PP
Da careful use of such constructs make it possible ta reconfigure a
a hustlin parser, eliminatin tha need fo' semantic feedback by
providin syntactic feedback instead. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat as currently implemented,
\&\f(CW\*(C`Replace()\*(C'\fR n' \f(CW\*(C`Extend()\*(C'\fR gotta regenerate n' re\-\f(CW\*(C`eval\*(C'\fR the
entire parser whenever they is called. Y'all KNOW dat shit, muthafucka! This make dem like slow for
pimpin' grammars.
.PP
In such cases, tha judicious use of a interpolated regex is likely to
be far mo' efficient:
.PP
.Vb 3
\&    typedef: \*(Aqtypedef\*(Aq type_name/ identifier \*(Aq;\*(Aq
\&           { $thisparser\->{local}{type_name} .= "|$item[3]" }
\&       | <error>
\&
\&    identifier: ...!type_name /[A\-Za\-z_]w*/
\&
\&    type_name: /$thisparser\->{local}{type_name}/
.Ve
.SS "Precompilin parsers"
.IX Subsection "Precompilin parsers"
Normally Parse::RecDescent buildz a parser from a grammar at run-time.
That approach simplifies tha design n' implementation of parsin code,
but has tha disadvantage dat it slows tha parsin process down \- you
have ta wait fo' Parse::RecDescent ta build tha parser every last muthafuckin time the
program runs. Long or complex grammars can be particularly slow to
build, leadin ta unacceptable delays at start-up.
.PP
To overcome this, tha module serves up a way of \*(L"pre-building\*(R" a parser
object n' savin it up in a separate module. That module can then be used
to create clonez of tha original gangsta parser.
.PP
A grammar may be precompiled rockin tha \f(CW\*(C`Precompile\*(C'\fR class method.
For example, ta precompile a grammar stored up in tha scalar \f(CW$grammar\fR,
and produce a cold-ass lil class named PreGrammar up in a module file named PreGrammar.pm,
you could use:
.PP
.Vb 1
\&    use Parse::RecDescent;
\&
\&    Parse::RecDescent\->Precompile([$options_hashref], $grammar, "PreGrammar");
.Ve
.PP
Da first required argument is tha grammar string, tha second is the
name of tha class ta be built. Da name of tha module file is
generated automatically by appendin \*(L".pm\*(R" ta tha last element of the
class name. Thus
.PP
.Vb 1
\&    Parse::RecDescent\->Precompile($grammar, "My::New::Parser");
.Ve
.PP
would produce a module file named Parser.pm.
.PP
An optionizzle hash reference may be supplied as tha straight-up original gangsta argument to
\&\f(CW\*(C`Precompile\*(C'\fR.  This argument is currently \s-1EXPERIMENTAL,\s0 n' may chizzle
in a gangbangin' future release of Parse::RecDescent.  Da only supported option
is currently \f(CW\*(C`\-standalone\*(C'\fR, peep \*(L"Standalone Precompiled Parsers\*(R".
.PP
It be somewhat tedious ta gotta write a lil' small-ass Perl program just to
generate a precompiled grammar class, so Parse::RecDescent has some special
magic dat allows you ta do tha thang directly from tha command-line.
.PP
If yo' grammar is specified up in a gangbangin' file named \fIgrammar\fR, you can generate
a class named Yet::Another::Grammar like so:
.PP
.Vb 1
\&    > perl \-MParse::RecDescent \- grammar Yet::Another::Grammar
.Ve
.PP
This would produce a gangbangin' file named \fIGrammar.pm\fR containin tha full
definizzle of a cold-ass lil class called Yet::Another::Grammar. Shiiit, dis aint no joke. Of course, ta use
that class, you would need ta put tha \fIGrammar.pm\fR file up in a
directory named \fIYet/Another\fR, somewhere up in yo' Perl include path.
.PP
Havin pimped tha freshly smoked up class, itz straight-up easy as fuck  ta use it ta build
a parser n' shit. Yo ass simply \f(CW\*(C`use\*(C'\fR tha freshly smoked up module, n' then call its
\&\f(CW\*(C`new\*(C'\fR method ta create a parser object. For example:
.PP
.Vb 2
\&    use Yet::Another::Grammar;
\&    mah $parser = Yet::Another::Grammar\->new();
.Ve
.PP
Da effect of these two lines is exactly tha same as:
.PP
.Vb 1
\&    use Parse::RecDescent;
\&
\&    open GRAMMAR_FILE, "grammar" or die;
\&    local $/;
\&    mah $grammar = <GRAMMAR_FILE>;
\&
\&    mah $parser = Parse::RecDescent\->new($grammar);
.Ve
.PP
only considerably faster.
.PP
Note however dat tha parsers produced by either approach is exactly
the same, so whilst precompilation has a effect on \fIset-up\fR speed,
it has no effect on \fIparsing\fR speed. Y'all KNOW dat shit, muthafucka! RecDescent 2.0 will address that
problem.
.PP
\fIStandalone Precompiled Parsers\fR
.IX Subsection "Standalone Precompiled Parsers"
.PP
Until version 1.967003 of Parse::RecDescent, parser modulez built with
\&\f(CW\*(C`Precompile\*(C'\fR was dependent on Parse::RecDescent.  Future
Parse::RecDescent releases wit different internal implementations
would break pre-existin precompiled parsers.
.PP
Version 1.967_005 added tha mobilitizzle fo' Parse::RecDescent ta include
itself up in tha resultin .pm file if you pass tha boolean option
\&\f(CW\*(C`\-standalone\*(C'\fR ta \f(CW\*(C`Precompile\*(C'\fR:
.PP
.Vb 2
\&    Parse::RecDescent\->Precompile({ \-standalone = 1, },
\&        $grammar, "My::New::Parser");
.Ve
.PP
Parse::RecDescent is included as Parse::RecDescent::_Runtime up in order
to avoid conflicts between a installed version of Parse::RecDescent
and a precompiled, standalone parser made wit another version of
Parse::RecDescent.  This renamin is experimental, n' is subject to
change up in future versions.
.PP
Precompiled parsers remain dependent on Parse::RecDescent by default,
as dis feature is still considered experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  In tha future,
standalone parsers will become tha default.
.SH "GOTCHAS"
.IX Header "GOTCHAS"
This section raps bout common mistakes dat grammar writas seem to
make on a regular basis.
.SS "1. Expectin a error ta always invalidate a parse"
.IX Subsection "1. Expectin a error ta always invalidate a parse"
A common fuck up when rockin error lyrics is ta write tha grammar like this:
.PP
.Vb 1
\&    file: line(s)
\&
\&    line: line_type_1
\&    | line_type_2
\&    | line_type_3
\&    | <error>
.Ve
.PP
Da expectation seems ta be dat any line dat aint of type 1, 2 or 3 will
invoke tha \f(CW\*(C`<error>\*(C'\fR directizzle n' thereby cause tha parse ta fail.
.PP
Unfortunately, dat only happens if tha error occurs up in tha straight-up first line.
Da first rule states dat a \f(CW\*(C`file\*(C'\fR is matched by one or mo' lines, so if
even a single line succeeds, tha straight-up original gangsta rule is straight-up satisfied n' the
parse as a whole succeeds. That means dat any error lyrics generated by
subsequent failures up in tha \f(CW\*(C`line\*(C'\fR rule is on tha fuckin' down-lowly ignored.
.PP
Typically whatz straight-up needed is this:
.PP
.Vb 1
\&    file: line(s) eofile    { $return = $item[1] }
\&
\&    line: line_type_1
\&    | line_type_2
\&    | line_type_3
\&    | <error>
\&
\&    eofile: /^\eZ/
.Ve
.PP
Da addizzle of tha \f(CW\*(C`eofile\*(C'\fR subrule  ta tha straight-up original gangsta thang means that
a file only matches a seriez of successful \f(CW\*(C`line\*(C'\fR matches \fIthat consume the
complete input text\fR. If any input text remains afta tha lines is matched,
there must done been a error up in tha last \f(CW\*(C`line\*(C'\fR. In dat case tha \f(CW\*(C`eofile\*(C'\fR
rule will fail, causin tha entire \f(CW\*(C`file\*(C'\fR rule ta fail like a muthafucka.
.PP
Note too dat \f(CW\*(C`eofile\*(C'\fR must match \f(CW\*(C`/^\eZ/\*(C'\fR (end-of-text), \fInot\fR
\&\f(CW\*(C`/^\ecZ/\*(C'\fR or \f(CW\*(C`/^\ecD/\*(C'\fR (end-of-file).
.PP
And don't forget tha action all up in tha end of tha thang. I aint talkin' bout chicken n' gravy biatch. If you just
write:
.PP
.Vb 1
\&    file: line(s) eofile
.Ve
.PP
then tha value returned by tha \f(CW\*(C`file\*(C'\fR rule is ghon be tha value of its
last item: \f(CW\*(C`eofile\*(C'\fR. Right back up in yo muthafuckin ass. Since \f(CW\*(C`eofile\*(C'\fR always returns a empty string
on success, dat will cause tha \f(CW\*(C`file\*(C'\fR rule ta return dat empty
strin fo' realz. Apart from returnin tha wack value, returnin a empty string
will trip up code such as:
.PP
.Vb 1
\&    $parser\->file($filetext) || die;
.Ve
.PP
(since "" is false).
.PP
Remember dat Parse::RecDescent returns undef on failure,
so tha only safe test fo' failure is:
.PP
.Vb 1
\&    defined($parser\->file($filetext)) || die;
.Ve
.ie n .SS "2. Usin a ""return"" up in a action"
.el .SS "2. Usin a \f(CWreturn\fP up in a action"
.IX Subsection "2. Usin a return up in a action"
An action is like a \f(CW\*(C`do\*(C'\fR block inside tha subroutine implementin the
surroundin rule. Right back up in yo muthafuckin ass. So if you put a \f(CW\*(C`return\*(C'\fR statement up in a action:
.PP
.Vb 3
\&    range: \*(Aq(\*(Aq start \*(Aq..\*(Aq end )\*(Aq
\&        { return $item{end} }
\&       /\es+/
.Ve
.PP
that subroutine will immediately return, without checkin tha rest of
the shit up in tha current thang (e.g. tha \f(CW\*(C`/\es+/\*(C'\fR) n' without
settin up tha necessary data structures ta tell tha parser dat the
rule has succeeded.
.PP
Da erect way ta set a return value up in a action is ta set tha \f(CW$return\fR
variable:
.PP
.Vb 3
\&    range: \*(Aq(\*(Aq start \*(Aq..\*(Aq end )\*(Aq
\&                { $return = $item{end} }
\&           /\es+/
.Ve
.ie n .SS "2. Right back up in yo muthafuckin ass. Settin $Parse::RecDescent::skip at parse time"
.el .SS "2. Right back up in yo muthafuckin ass. Settin \f(CW$Parse::RecDescent::skip\fP at parse time"
.IX Subsection "2. Right back up in yo muthafuckin ass. Settin $Parse::RecDescent::skip at parse time"
If you wanna chizzle tha default skippin behaviour (see
\&\*(L"Terminal Separators\*(R" n' tha \f(CW\*(C`<skip:...>\*(C'\fR directive) by setting
\&\f(CW$Parse::RecDescent::skip\fR you gotta remember ta set dis variable
\&\fIbefore\fR bustin tha grammar object.
.PP
For example, you might wanna skip all Perl-like comments wit this
regular expression:
.PP
.Vb 6
\&   mah $skip_spaces_and_comments = qr/
\&         (?mxs:
\&            \es+         # either spaces
\&            | \e# .*?$   # or a thugged-out dash n' whatever up ta tha end of line
\&         )*             # repeated at will (in whatever order)
\&      /;
.Ve
.PP
And then:
.PP
.Vb 1
\&   mah $parser1 = Parse::RecDescent\->new($grammar);
\&
\&   $Parse::RecDescent::skip = $skip_spaces_and_comments;
\&
\&   mah $parser2 = Parse::RecDescent\->new($grammar);
\&
\&   $parser1\->parse($text); # dis do not cope wit comments
\&   $parser2\->parse($text); # dis skips comments erectly
.Ve
.PP
Da two parsers behave differently, cuz any skippin behaviour
specified via \f(CW$Parse::RecDescent::skip\fR is hard-coded when the
grammar object is built, not at parse time.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Diagnostics is intended ta be self-explanatory (particularly if you
use \fB\-RD_HINT\fR (under \fBperl \-s\fR) or define \f(CW$::RD_HINT\fR inside tha program).
.PP
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR currently diagnoses tha following:
.IP "\(bu" 4
Invalid regular expressions used as pattern terminals (fatal error).
.IP "\(bu" 4
Invalid Perl code up in code blocks (fatal error).
.IP "\(bu" 4
Lookahead used up in tha wack place or up in a nonsensical way (fatal error).
.IP "\(bu" 4
\&\*(L"Obvious\*(R" casez of left-recursion (fatal error).
.IP "\(bu" 4
Missin or extra components up in a \f(CW\*(C`<leftop>\*(C'\fR or \f(CW\*(C`<rightop>\*(C'\fR
directive.
.IP "\(bu" 4
Unrecognisable components up in tha grammar justification (fatal error).
.IP "\(bu" 4
\&\*(L"Orphaned\*(R" rule components specified before tha straight-up original gangsta rule (fatal error)
or afta a \f(CW\*(C`<error>\*(C'\fR directizzle (level 3 warning).
.IP "\(bu" 4
Missin rule definitions (this only generates a level 3 warning, since you
may be providin dem lata via \f(CW\*(C`Parse::RecDescent::Extend()\*(C'\fR).
.IP "\(bu" 4
Instances where greedy repetizzle behaviour will almost certainly
cause tha failure of a thang (a level 3 warnin \- see
\&\*(L"ON-GOING \s-1ISSUES AND FUTURE DIRECTIONS\*(R"\s0 below).
.IP "\(bu" 4
Attempts ta define rulez named 'Replace' or 'Extend', which cannot be
called directly all up in tha parser object cuz of tha predefined
meanin of \f(CW\*(C`Parse::RecDescent::Replace\*(C'\fR and
\&\f(CW\*(C`Parse::RecDescent::Extend\*(C'\fR. (Only a level 2 warnin is generated, since
such rulez \fIcan\fR still be used as subrules).
.IP "\(bu" 4
Productions which consist of a single \f(CW\*(C`<error?>\*(C'\fR
directive, n' which therefore may succeed unexpectedly
(a level 2 warning, since dis might conceivably be tha desired effect).
.IP "\(bu" 4
Multiple consecutizzle lookahead specifiers (a level 1 warnin only, since their
effects simply accumulate).
.IP "\(bu" 4
Productions which start wit a \f(CW\*(C`<reject>\*(C'\fR or \f(CW\*(C`<rulevar:...>\*(C'\fR
directive. Right back up in yo muthafuckin ass. Such thangs is optimized away (a level 1 warning).
.IP "\(bu" 4
Rulez which is autogenerated under \f(CW$::AUTOSTUB\fR (a level 1 warning).
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
Jeremy T. Braun (JTBRAUN@CPAN.org) [current maintainer]
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
There is undoubtedly straight-up bugs lurkin somewhere up in dis much code :\-)
Bug reports, test cases n' other feedback is most welcome.
.PP
Ongoin annoyances include:
.IP "\(bu" 4
Therez no support fo' parsin directly from a input stream.
If n' when tha Perl Godz give our asses regular expressions on streams,
this should be trivial (ahem!) ta implement.
.IP "\(bu" 4
Da parser generator can git trippin if actions aren't properly
closed or if they contain particularly nasty Perl syntax errors
(especially unmatched curly brackets).
.IP "\(bu" 4
Da generator only detects da most thugged-out obvious form of left recursion
(potential recursion on tha straight-up original gangsta subrule up in a rule). Mo' subtle
formz of left recursion (for example, all up in tha second item up in a
rule afta a \*(L"zero\*(R" match of a precedin \*(L"zero-or-more\*(R" repetition,
or afta a match of a subrule wit a empty thang) is not found.
.IP "\(bu" 4
Instead of complainin bout left-recursion, tha generator should
silently transform tha grammar ta remove dat shit. Don't expect this
feature any time soon as it would require a mo' sophisticated
approach ta parser generation than is currently used.
.IP "\(bu" 4
Da generated parsers don't always run as fast as might be wished.
.IP "\(bu" 4
Da meta-parser should be bootstrapped rockin \f(CW\*(C`Parse::RecDescent\*(C'\fR :\-)
.SH "ON-GOING ISSUES AND FUTURE DIRECTIONS"
.IX Header "ON-GOING ISSUES AND FUTURE DIRECTIONS"
.IP "1." 4
Repetitions is \*(L"incorrigibly greedy\*(R" up in dat they will smoke every last muthafuckin thang they can
and won't backtrack if dat behaviour causes a thang ta fail needlessly.
So, fo' example:
.Sp
.Vb 1
\&    rule: subrule(s) subrule
.Ve
.Sp
will \fInever\fR succeed, cuz tha repetizzle will smoke all the
subrulez it finds, leavin none ta match tha second item. Right back up in yo muthafuckin ass. Such
constructions is relatively rare (and \f(CW\*(C`Parse::RecDescent::new\*(C'\fR generates a
warnin whenever they occur) so dis may not be a problem, especially
since tha insatiable behaviour can be overcome \*(L"manually\*(R" by writing:
.Sp
.Vb 1
\&    rule: penultimate_subrule(s) subrule
\&
\&    penultimate_subrule: subrule ...subrule
.Ve
.Sp
Da issue is dat dis construction is exactly twice as high-rollin' as the
original, whereas backtrackin would add only 1/\fIN\fR ta tha cost (for
matchin \fIN\fR repetitionz of \f(CW\*(C`subrule\*(C'\fR). I would welcome feedback on
the need fo' backtracking; particularly on cases where tha lack of it
makes parsin performizzle problematical.
.IP "2." 4
Havin opened dat can of worms, itz also necessary ta consider whether there
is a need fo' non-greedy repetizzle specifiers fo' realz. Again, itz possible (at some
cost) ta manually provide tha required functionality:
.Sp
.Vb 1
\&    rule: nongreedy_subrule(s) othersubrule
\&
\&    nongreedy_subrule: subrule ...!othersubrule
.Ve
.Sp
Overall, tha issue is whether tha benefit of dis extra functionality
outweighs tha drawbackz of further complicatin tha (currently
minimalist) grammar justification syntax, n' (worse) introducin mo' overhead
into tha generated parsers.
.IP "3." 4
An \f(CW\*(C`<autocommit>\*(C'\fR directizzle would be sick. That is, it would be useful ta be
able ta say:
.Sp
.Vb 7
\&    command: <autocommit>
\&    command: \*(Aqfind\*(Aq name
\&       | \*(Aqfind\*(Aq address
\&       | \*(Aqdo\*(Aq command \*(Aqat\*(Aq time \*(Aqif\*(Aq condition
\&       | \*(Aqdo\*(Aq command \*(Aqat\*(Aq time
\&       | \*(Aqdo\*(Aq command
\&       | unusual_command
.Ve
.Sp
and have tha generator work up dat dis should be \*(L"pruned\*(R" thus:
.Sp
.Vb 9
\&    command: \*(Aqfind\*(Aq name
\&       | \*(Aqfind\*(Aq <commit> address
\&       | \*(Aqdo\*(Aq <commit> command <uncommit>
\&        \*(Aqat\*(Aq time
\&        \*(Aqif\*(Aq <commit> condition
\&       | \*(Aqdo\*(Aq <commit> command <uncommit>
\&        \*(Aqat\*(Aq <commit> time
\&       | \*(Aqdo\*(Aq <commit> command
\&       | unusual_command
.Ve
.Sp
There is nuff muthafuckin thangs here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Firstly, should the
\&\f(CW\*(C`<autocommit>\*(C'\fR automatically install a \f(CW\*(C`<uncommit>\*(C'\fR
at tha start of tha last thang (on tha groundz dat tha \*(L"command\*(R"
rule don't give a fuck whether a \*(L"unusual_command\*(R" might start wit \*(L"find\*(R"
or \*(L"do\*(R") or should tha \*(L"unusual_command\*(R" subgraph be analysed (to see
if it \fImight\fR be viable afta a \*(L"find\*(R" or \*(L"do\*(R")?
.Sp
Da second issue is how tha fuck regular expressions should be treated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da simplest
approach would be simply ta uncommit before dem (on tha groundz dat they
\&\fImight\fR match). Betta efficiency would be obtained by analyzin all preceding
literal tokens ta determine whether tha pattern would match em.
.Sp
Overall, tha thangs are: can such automated \*(L"pruning\*(R" approach a hand-tuned
version sufficiently closely ta warrant tha extra set-up expense, n' (more
importantly) is tha problem blingin enough ta even warrant tha non-trivial
effort of buildin a automated solution?
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Source Code Repository"
.IX Subsection "Source Code Repository"
<http://github.com/jtbraun/Parse\-RecDescent>
.SS "Mailin List"
.IX Subsection "Mailin List"
Smoke up <http://www.perlfoundation.org/perl5/index.cgi?parse_recdescent> ta sign up fo' tha mailin list.
.PP
<http://www.PerlMonks.org> be also a phat place ta ask
questions. Previous posts bout Parse::RecDescent can typically be
found wit dis search:
<http://perlmonks.org/index.pl?node=recdescent>.
.SS "\s-1FAQ\s0"
.IX Subsection "FAQ"
Smoke up Parse::RecDescent::FAQ fo' lyrics ta frequently (and not so
frequently) axed thangs bout Parse::RecDescent.
.SS "View/Report Bugs"
.IX Subsection "View/Report Bugs"
To view tha current bug list or report a freshly smoked up issue visit
<https://rt.cpan.org/Public/Dist/Display.html?Name=Parse\-RecDescent>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Grammars serves up Parse::RecDescent steez parsin rockin native
Perl 5.10 regular expressions.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 1997\-2007, Damian Conway \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR fo' realz. All rights
reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself. Right back up in yo muthafuckin ass. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE \*(L"AS IS\*(R" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. Right back up in yo muthafuckin ass. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.\s0
.PP
\&\s-1IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE \s0(\s-1INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE\s0), \s-1EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.\s0
