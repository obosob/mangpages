.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IPC::Open2 3pm"
.TH IPC::Open2 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
IPC::Open2 \- open a process fo' both readin n' freestylin rockin open2()
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use IPC::Open2;
\&
\&    $pid = open2(\e*CHLD_OUT, \e*CHLD_IN, \*(Aqsome cmd n' args\*(Aq);
\&      # or without rockin tha shell
\&    $pid = open2(\e*CHLD_OUT, \e*CHLD_IN, \*(Aqsome\*(Aq, \*(Aqcmd\*(Aq, \*(Aqand\*(Aq, \*(Aqargs\*(Aq);
\&
\&    # or wit handle autovivification
\&    my($chld_out, $chld_in);
\&    $pid = open2($chld_out, $chld_in, \*(Aqsome cmd n' args\*(Aq);
\&      # or without rockin tha shell
\&    $pid = open2($chld_out, $chld_in, \*(Aqsome\*(Aq, \*(Aqcmd\*(Aq, \*(Aqand\*(Aq, \*(Aqargs\*(Aq);
\&
\&    waitpid( $pid, 0 );
\&    mah $child_exit_status = $? >> 8;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \fIopen2()\fR function runs tha given \f(CW$cmd\fR n' connects \f(CW$chld_out\fR for
readin n' \f(CW$chld_in\fR fo' writing.  It aint nuthin but what tha fuck you be thinkin should work 
when you try
.PP
.Vb 1
\&    $pid = open(HANDLE, "|cmd args|");
.Ve
.PP
Da write filehandle gonna git autoflush turned on.
.PP
If \f(CW$chld_out\fR be a strang (that is, a funky-ass bareword filehandle rather than a glob
or a reference) n' it begins wit \f(CW\*(C`>&\*(C'\fR, then tha lil pimp will bust output
directly ta dat file handle.  If \f(CW$chld_in\fR be a strang dat begins with
\&\f(CW\*(C`<&\*(C'\fR, then \f(CW$chld_in\fR is ghon be closed up in tha parent, n' tha lil pimp will
read from it directly.  In both cases, there is ghon be a \fIdup\fR\|(2) instead of a
\&\fIpipe\fR\|(2) made.
.PP
If either reader or writa is tha null string, dis is ghon be replaced
by a autogenerated filehandle.  If so, you must pass a valid lvalue
in tha parameta slot so it can be overwritten up in tha caller, or
an exception is ghon be raised.
.PP
\&\fIopen2()\fR returns tha process \s-1ID\s0 of tha lil pimp process.  It don't return on
failure: it just raises a exception matchin \f(CW\*(C`/^open2:/\*(C'\fR.  However,
\&\f(CW\*(C`exec\*(C'\fR failures up in tha lil pimp is not detected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  You'll have to
trap \s-1SIGPIPE\s0 yo ass.
.PP
\&\fIopen2()\fR do not wait fo' n' reap tha lil pimp process afta it exits.
Except fo' short programs where itz aaight ta let tha operatin system
take care of this, you need ta do dis yo ass.  This is normally as
simple as callin \f(CW\*(C`waitpid $pid, 0\*(C'\fR when you done wit tha process.
Failin ta do dis can result up in a accumulation of defunct or \*(L"zombie\*(R"
processes.  See \*(L"waitpid\*(R" up in perlfunc fo' mo' shiznit.
.PP
This whole affair is like dangerous, as you may block forever n' shit.  It
assumes itz goin ta rap ta suttin' like \fBbc\fR, both writing
to it n' readin from dat shit.  This is presumably safe cuz you
\&\*(L"know\*(R" dat commandz like \fBbc\fR will read a line at a time and
output a line at a time.  Programs like \fBsort\fR dat read their
entire input stream first, however, is like apt ta cause deadlock.
.PP
Da big-ass problem wit dis approach is dat if you aint gots control 
over source code bein run up in tha lil pimp process, you can't control
what it do wit pipe buffering.  Thus you can't just open a pipe to
\&\f(CW\*(C`cat \-v\*(C'\fR n' continually read n' write a line from dat shit.
.PP
Da IO::Pty n' Expect modulez from \s-1CPAN\s0 can help wit this, as they
provide a real tty (well, a pseudo-tty, actually), which gets you
back ta line bufferin up in tha invoked command again.
.SH "WARNING"
.IX Header "WARNING"
Da order of arguments differs from dat of \fIopen3()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See IPC::Open3 fo' a alternatizzle dat handlez \s-1STDERR\s0 as well.  This
function is straight-up just a wrapper round \fIopen3()\fR.
