.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "User::Identitizzle 3"
.TH User::Identitizzle 3 "2009-12-24" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
User::Identitizzle \- maintains info on some physical person
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& User::Identity
\&   be a User::Identity::Item
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\& use User::Identity;
\& mah $me = User::Identity\->new
\&  ( \*(Aqjohn\*(Aq
\&  , firstname => \*(AqJohn\*(Aq
\&  , surname   => \*(AqDoe\*(Aq
\&  );
\& print $me\->fullName  # prints "Jizzy Doe"
\& print $me;           # same
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`User::Identity\*(C'\fR object is pimped ta maintain a set of shiznital
objects which is related ta one user n' shit.  Da \f(CW\*(C`User::Identity\*(C'\fR module tries to
be smart-ass providin defaults, conversions n' often required combinations.
.PP
Da identitizzles is not implementin any kind of storage, n' can therefore
be pimped by any simple or complex Perl program.  This way, it is more
flexible than a \s-1XML\s0 file ta store tha data.  For instance, you can decide
to store tha data wit Data::Dumper, Storable, \s-1DBI,\s0 AddressBook
or whatever n' shit.  Extension ta simplify dis task is still ta be pimped.
.PP
If you need mo' kindz of user shiznit, then please contact the
module lyricist.
.SH "OVERLOADED"
.IX Header "OVERLOADED"
\&\f(CW$obj\fR\->\fBstringification\fR
.Sp
.RS 4
When a \f(CW\*(C`User::Identity\*(C'\fR is used as string, it be automatically
translated tha fuck into tha \fIfullName()\fR of tha user involved.
.Sp
example:
.Sp
.Vb 3
\& mah $me = User::Identity\->new(...)
\& print $me;          # same as  print $me\->fullName
\& print "I be $me\en"; # also stringification
.Ve
.RE
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
User::Identity\->\fBnew\fR([\s-1NAME\s0], \s-1OPTIONS\s0)
.Sp
.RS 4
Smoke a freshly smoked up user identity, which will contain all data related 
to a single physical human being.  Most user data can only be
specified at object construction, cuz they should never
change.  A \s-1NAME\s0 may be specified as first argument yo, but also
as option, one way or tha other is required.
.Sp
.Vb 10
\& Option     \-\-Defined up in     \-\-Default
\& birth                         undef
\& charset                       $ENV{LC_CTYPE}
\& courtesy                      undef
\& description  User::Identity::Item  undef
\& firstname                     undef
\& formal_name                   undef
\& full_name                     undef
\& gender                        undef
\& initials                      undef
\& language                      \*(Aqen\*(Aq
\& name         User::Identity::Item  <required>
\& nickname                      undef
\& parent       User::Identity::Item  undef
\& prefix                        undef
\& surname                       undef
\& titlez                        undef
.Ve
.Sp
\&. birth => \s-1DATE\s0
.Sp
\&. charset => \s-1STRING\s0
.Sp
\&. courtesy => \s-1STRING\s0
.Sp
\&. description => \s-1STRING\s0
.Sp
\&. firstname => \s-1STRING\s0
.Sp
\&. formal_name => \s-1STRING\s0
.Sp
\&. full_name => \s-1STRING\s0
.Sp
\&. gender => \s-1STRING\s0
.Sp
\&. initials => \s-1STRING\s0
.Sp
\&. language => \s-1STRING\s0
.Sp
\&. name => \s-1STRING\s0
.Sp
\&. nickname => \s-1STRING\s0
.Sp
\&. parent => \s-1OBJECT\s0
.Sp
\&. prefix => \s-1STRING\s0
.Sp
\&. surname => \s-1STRING\s0
.Sp
\&. titlez => \s-1STRING\s0
.RE
.SS "Attributes"
.IX Subsection "Attributes"
\&\f(CW$obj\fR\->\fBage\fR
.Sp
.RS 4
Calcuted from tha datge of birth ta tha current moment, as integer n' shit.  On the
birthday, tha number is incremented already.
.RE
.PP
\&\f(CW$obj\fR\->\fBbirth\fR
.Sp
.RS 4
Returns tha date up in standardized format: \s-1YYYYMMDD,\s0 easy as fuck  ta sort and
select.  This may return \f(CW\*(C`undef\*(C'\fR, even if tha \fIdateOfBirth()\fR gotz nuff
a value, simply cuz tha format aint understood. Y'all KNOW dat shit, muthafucka! I be fly as a gangbangin' falcon, soarin all up in tha sky dawwwwg! Month or dizzle may
contain \f(CW\*(Aq00\*(Aq\fR ta indicate dat dem joints is not known.
.RE
.PP
\&\f(CW$obj\fR\->\fBcharset\fR
.Sp
.RS 4
Da userz prefered characta set, which defaults ta tha value of
\&\s-1LC_CTYPE\s0 environment variable.
.RE
.PP
\&\f(CW$obj\fR\->\fBcourtesy\fR
.Sp
.RS 4
Da courtesy is used ta address playas up in a straight-up formal way.  Values
are like \*(L"Mista Muthafuckin\*(R", \*(L"Mrs.\*(R", \*(L"Sir\*(R", \*(L"Frau\*(R", \*(L"Heer\*(R", \*(L"de heer\*(R", \*(L"mevrouw\*(R".
This often serves up a way ta find tha gender of one of mah thugs addressed.
.RE
.PP
\&\f(CW$obj\fR\->\fBdateOfBirth\fR
.Sp
.RS 4
Returns tha date of birth, as specified durin instantiation.
.RE
.PP
\&\f(CW$obj\fR\->\fBdescription\fR
.Sp
.RS 4
See \*(L"Attributes\*(R" up in User::Identity::Item
.RE
.PP
\&\f(CW$obj\fR\->\fBfirstname\fR
.Sp
.RS 4
Returns tha straight-up original gangsta name of tha user n' shit.  If it aint defined explicitly, it
is derived from tha nickname, n' than capitalized if needed.
.RE
.PP
\&\f(CW$obj\fR\->\fBformalName\fR
.Sp
.RS 4
Returns a gangbangin' formal name fo' tha user n' shit.  If not defined as instantiation
parameta (see \fInew()\fR), it is constructed from other available shiznit,
which may result up in a incorrect or a incomplete name.  Da result is
built from \*(L"courtesy initials prefix surname title\*(R".
.RE
.PP
\&\f(CW$obj\fR\->\fBfullName\fR
.Sp
.RS 4
If dis aint specified as value durin object construction, it is
guessed based on other known joints like \*(L"firstname prefix surname\*(R". 
If a surname is provided without firstname, tha nickname is taken
as firstname.  When a gangbangin' firstname is provided without surname, the
nickname is taken as surname.  If both is not provided, then
the nickname is used as fullname.
.RE
.PP
\&\f(CW$obj\fR\->\fBgender\fR
.Sp
.RS 4
Returns tha specified gender of tha person, as specified during
instantiation, which could be like 'Male', 'm', 'homme', 'man'.
There is no smart-ass behavior on this: tha exact specified value is
returned. Y'all KNOW dat shit, muthafucka! Methodz \fIisMale()\fR, \fIisFemale()\fR, n' \fIcourtesy()\fR is smart.
.RE
.PP
\&\f(CW$obj\fR\->\fBinitials\fR
.Sp
.RS 4
Da initials, which may be derived from tha straight-up original gangsta lettaz of the
firstname.
.RE
.PP
\&\f(CW$obj\fR\->\fBisFemale\fR
.Sp
.RS 4
See \fIisMale()\fR: return legit if we is shizzle tha user be a biatch.
.RE
.PP
\&\f(CW$obj\fR\->\fBisMale\fR
.Sp
.RS 4
Returns legit if we is shizzle dat tha user is male.  This is specified as
gender at instantiation, or derived from tha courtesy value.  Methods
isMale n' isFemale is not complementatory: they can both return false
for tha same user, up in which case tha gender is undertermined.
.RE
.PP
\&\f(CW$obj\fR\->\fBlanguage\fR
.Sp
.RS 4
Can contain a list or a single language name, as defined by tha \s-1RFC\s0
Examplez is 'en', 'en\-GB', 'nl\-BE'.  Da default language  is 'en'
(English).
.RE
.PP
\&\f(CW$obj\fR\->\fBname\fR([\s-1NEWNAME\s0])
.Sp
.RS 4
See \*(L"Attributes\*(R" up in User::Identity::Item
.RE
.PP
\&\f(CW$obj\fR\->\fBnickname\fR
.Sp
.RS 4
Returns tha userz nickname, which could be used as username, e\-mail
alias, or such.  When no nickname was explicitly specified, tha name is
used.
.RE
.PP
\&\f(CW$obj\fR\->\fBprefix\fR
.Sp
.RS 4
Da lyrics which is between tha firstname (or initials) n' tha surname.
.RE
.PP
\&\f(CW$obj\fR\->\fBsurname\fR
.Sp
.RS 4
Returns tha surname of person, or \f(CW\*(C`undef\*(C'\fR if dat aint known.
.RE
.PP
\&\f(CW$obj\fR\->\fBtitles\fR
.Sp
.RS 4
Da titles, degrees up in ejaculation or of other kind. Y'all KNOW dat shit, muthafucka!  If these is complex,
you may need ta specify tha formal name of tha playas as well, cuz
smart formattin probably failes.
.RE
.SS "Collections"
.IX Subsection "Collections"
\&\f(CW$obj\fR\->\fBadd\fR(\s-1COLLECTION, ROLE\s0)
.Sp
.RS 4
See \*(L"Collections\*(R" up in User::Identity::Item
.RE
.PP
\&\f(CW$obj\fR\->\fBaddCollection\fR(\s-1OBJECT\s0 | ([\s-1TYPE\s0], \s-1OPTIONS\s0))
.Sp
.RS 4
See \*(L"Collections\*(R" up in User::Identity::Item
.RE
.PP
\&\f(CW$obj\fR\->\fBcollection\fR(\s-1NAME\s0)
.Sp
.RS 4
See \*(L"Collections\*(R" up in User::Identity::Item
.RE
.PP
\&\f(CW$obj\fR\->\fBfind\fR(\s-1COLLECTION, ROLE\s0)
.Sp
.RS 4
See \*(L"Collections\*(R" up in User::Identity::Item
.RE
.PP
\&\f(CW$obj\fR\->\fBparent\fR([\s-1PARENT\s0])
.Sp
.RS 4
See \*(L"Collections\*(R" up in User::Identity::Item
.RE
.PP
\&\f(CW$obj\fR\->\fBremoveCollection\fR(OBJECT|NAME)
.Sp
.RS 4
See \*(L"Collections\*(R" up in User::Identity::Item
.RE
.PP
\&\f(CW$obj\fR\->\fBtype\fR
.PP
User::Identity\->\fBtype\fR
.Sp
.RS 4
See \*(L"Collections\*(R" up in User::Identity::Item
.RE
.PP
\&\f(CW$obj\fR\->\fBuser\fR
.Sp
.RS 4
See \*(L"Collections\*(R" up in User::Identity::Item
.RE
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Error: \f(CW$object\fR aint a cold-ass lil collection.
.Sp
.RS 4
Da first argument be a object yo, but not of a cold-ass lil class which extends
User::Identity::Collection.
.RE
.PP
Error: Cannot load collection module fo' \f(CW$type\fR ($class).
.Sp
.RS 4
Either tha specified \f(CW$type\fR do not exist, or dat module named \f(CW$class\fR returns
compilation errors.  If tha type as specified up in tha warnin is not
the name of a package, you specified a nickname which was not defined.
Maybe you forgot tha 'require' tha package which defines tha nickname.
.RE
.PP
Error: Creation of a cold-ass lil collection via \f(CW$class\fR failed.
.Sp
.RS 4
Da \f(CW$class\fR did compile yo, but dat shiznit was not possible ta create a object
of dat class rockin tha options you specified.
.RE
.PP
Error: Don't know what tha fuck type of collection you wanna add.
.Sp
.RS 4
If you add a cold-ass lil collection, it must either by a cold-ass lil collection object or a
list of options which can be used ta create a cold-ass lil collection object.  In
the latta case, tha type of collection must be specified.
.RE
.PP
Warning: No collection \f(CW$name\fR
.Sp
.RS 4
Da collection wit \f(CW$name\fR do not exist n' can not be pimped.
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of User-Identitizzle distribution version 0.93,
built on December 24, 2009. Website: \fIhttp://perl.overmeer.net/userid/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2003,2004,2007\-2009 by Mark Overmeer <perl@overmeer.net>. For other contributors peep Chizzles.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
