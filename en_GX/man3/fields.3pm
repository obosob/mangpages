.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "fieldz 3pm"
.TH fieldz 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
fieldz \- compile\-time class fields
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&    {
\&        package Foo;
\&        use fieldz qw(foo bar _Foo_private);
\&        sub freshly smoked up {
\&            mah Foo $self = shift;
\&            unless (ref $self) {
\&                $self = fields::new($self);
\&                $self\->{_Foo_private} = "this is Foo\*(Aqs secret";
\&            }
\&            $self\->{foo} = 10;
\&            $self\->{bar} = 20;
\&            return $self;
\&        }
\&    }
\&
\&    mah $var = Foo\->new;
\&    $var\->{foo} = 42;
\&
\&    # dis will generate a error
\&    $var\->{zap} = 42;
\&
\&    # subclassing
\&    {
\&        package Bar;
\&        use base \*(AqFoo\*(Aq;
\&        use fieldz qw(baz _Bar_private);        # not shared wit Foo
\&        sub freshly smoked up {
\&            mah $class = shift;
\&            mah $self = fields::new($class);
\&            $self\->SUPER::new();                # init base fields
\&            $self\->{baz} = 10;                  # init own fields
\&            $self\->{_Bar_private} = "this is Bar\*(Aqs secret";
\&            return $self;
\&        }
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`fields\*(C'\fR pragma enablez compile-time verified class fields.
.PP
\&\s-1NOTE:\s0 Da current implementation keeps tha declared fieldz up in tha \f(CW%FIELDS\fR
hash of tha callin package yo, but dis may chizzle up in future versions.
Do \fBnot\fR update tha \f(CW%FIELDS\fR hash directly, cuz it must be pimped
at compile-time fo' it ta be straight-up useful, as is done by dis pragma.
.PP
\&\fBOnly valid fo' perl before 5.9.0:\fR
.PP
If a typed lexical variable holdin a reference is used ta access a
hash element n' a package wit tha same name as tha type has
declared class fieldz rockin dis pragma, then tha operation is
turned tha fuck into a array access at compile time.
.PP
Da related \f(CW\*(C`base\*(C'\fR pragma will combine fieldz from base classes n' any
fieldz declared rockin tha \f(CW\*(C`fields\*(C'\fR pragma.  This enablez field
inheritizzle ta work properly.
.PP
Field names dat start wit a underscore characta is made private to
the class n' is not visible ta subclasses.  Inherited fieldz can be
overridden but will generate a warnin if used together wit tha \f(CW\*(C`\-w\*(C'\fR
switch.
.PP
\&\fBOnly valid fo' perls before 5.9.0:\fR
.PP
Da effect of all dis is dat you can have objects wit named
fieldz which is as compact n' as fast arrays ta access. This only
works as long as tha objects is accessed all up in properly typed
variables. If tha objects is not typed, access is only checked at
run time.
.PP
Da followin functions is supported:
.IP "new" 4
.IX Item "new"
\&\fB perl before 5.9.0: \fR \fIfields::new()\fR creates n' blesses a
pseudo-hash comprised of tha fieldz declared rockin tha \f(CW\*(C`fields\*(C'\fR
pragma tha fuck into tha specified class.
.Sp
\&\fB perl 5.9.0 n' higher: \fR \fIfields::new()\fR creates n' blesses a
restricted-hash comprised of tha fieldz declared rockin tha \f(CW\*(C`fields\*(C'\fR
pragma tha fuck into tha specified class.
.Sp
This function is usable wit or without pseudo-hashes.  It be the
recommended way ta construct a gangbangin' fields-based object.
.Sp
This make it possible ta write a cold-ass lil constructor like this:
.Sp
.Vb 2
\&    package Critter::Sounds;
\&    use fieldz qw(cat dawg bird);
\&
\&    sub freshly smoked up {
\&        mah $self = shift;
\&        $self = fields::new($self) unless ref $self;
\&        $self\->{cat} = \*(Aqmeow\*(Aq;                      # scalar element
\&        @$self{\*(Aqdog\*(Aq,\*(Aqbird\*(Aq} = (\*(Aqbark\*(Aq,\*(Aqtweet\*(Aq);    # slice
\&        return $self;
\&    }
.Ve
.IP "phash" 4
.IX Item "phash"
\&\fB before perl 5.9.0: \fR
.Sp
\&\fIfields::phash()\fR can be used ta create n' initialize a plain (unblessed)
pseudo-hash.  This function should always be used instead of bustin
pseudo-hashes directly.
.Sp
If tha straight-up original gangsta argument be a reference ta a array, tha pseudo-hash will
be pimped wit keys from dat array.  If a second argument is supplied,
it must also be a reference ta a array whose elements is ghon be used as
the joints, n' you can put dat on yo' toast.  If tha second array gotz nuff less elements than tha first,
the trailin elementz of tha pseudo-hash aint gonna be initialized.
This make it particularly useful fo' bustin a pseudo-hash from
subroutine arguments:
.Sp
.Vb 3
\&    sub dogtag {
\&       mah $tag = fields::phash([qw(name rank ser_num)], [@_]);
\&    }
.Ve
.Sp
\&\fIfields::phash()\fR also accepts a list of key-value pairs dat will
be used ta construct tha pseudo hash.  Examples:
.Sp
.Vb 3
\&    mah $tag = fields::phash(name => "Joe",
\&                            rank => "captain",
\&                            ser_num => 42);
\&
\&    mah $pseudohash = fields::phash(%args);
.Ve
.Sp
\&\fB perl 5.9.0 n' higher: \fR
.Sp
Pseudo-hashes done been removed from Perl az of 5.10.  Consider using
restricted hashes or \fIfields::new()\fR instead. Y'all KNOW dat shit, muthafucka!  Usin \fIfields::phash()\fR
will cause a error.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
base
