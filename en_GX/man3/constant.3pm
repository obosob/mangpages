.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "constant 3"
.TH constant 3 "2013-03-21" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
constant \- Perl pragma ta declare constants
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use constant PI    => 4 * atan2(1, 1);
\&    use constant DEBUG => 0;
\&
\&    print "Pi equals ", PI, "...\en" if DEBUG;
\&
\&    use constant {
\&        SEC   => 0,
\&        MIN   => 1,
\&        HOUR  => 2,
\&        MDAY  => 3,
\&        MON   => 4,
\&        YEAR  => 5,
\&        WDAY  => 6,
\&        YDAY  => 7,
\&        ISDST => 8,
\&    };
\&
\&    use constant WEEKDAYS => qw(
\&        Sundizzle Mondizzle Tuesdizzle Wednesdizzle Thursdizzle Fridizzle Saturday
\&    );
\&
\&    print "Todizzle is ", (WEEKDAYS)[ (localtime)[WDAY] ], ".\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This pragma allows you ta declare constants at compile-time.
.PP
When you declare a cold-ass lil constant like fuckin \f(CW\*(C`PI\*(C'\fR rockin tha method shown
above, each machine yo' script runs upon can have as nuff digits
of accuracy as it can use fo' realz. Also, yo' program is ghon be easier to
read, mo' likely ta be maintained (and maintained erectly), and
far less likely ta bust a space probe ta tha wack hood cuz
nobody noticed tha one equation up in which you freestyled \f(CW3.14195\fR.
.PP
When a cold-ass lil constant is used up in a expression, Perl replaces it wit its
value at compile time, n' may then optimize tha expression further.
In particular, any code up in a \f(CW\*(C`if (CONSTANT)\*(C'\fR block is ghon be optimized
away if tha constant is false.
.SH "NOTES"
.IX Header "NOTES"
As wit all \f(CW\*(C`use\*(C'\fR directives, definin a cold-ass lil constant happens at
compile time. Thus, itz probably not erect ta put a cold-ass lil constant
declaration inside of a cold-ass lil conditionizzle statement (like \f(CW\*(C`if ($foo)
{ use constant ... }\*(C'\fR).
.PP
Constants defined rockin dis module cannot be interpolated into
strings like variables.  But fuck dat shiznit yo, tha word on tha street is dat concatenation works just fine:
.PP
.Vb 2
\&    print "Pi equals PI...\en";        # WRONG: do not expand "PI"
\&    print "Pi equals ".PI."...\en";    # right
.Ve
.PP
Even though a reference may be declared as a cold-ass lil constant, tha reference may
point ta data which may be chizzled, as dis code shows.
.PP
.Vb 4
\&    use constant ARRAY => [ 1,2,3,4 ];
\&    print ARRAY\->[1];
\&    ARRAY\->[1] = " be chizzled";
\&    print ARRAY\->[1];
.Ve
.PP
Dereferencin constant references incorrectly (like fuckin rockin a array
subscript on a cold-ass lil constant hash reference, or vice versa) is ghon be trapped at
compile time.
.PP
Constants belong ta tha package they is defined in. I aint talkin' bout chicken n' gravy biatch.  To refer ta a
constant defined up in another package, specify tha full package name, as
in \f(CW\*(C`Some::Package::CONSTANT\*(C'\fR.  Constants may be exported by modules,
and may also be called as either class or instizzle methods, dat is,
as \f(CW\*(C`Some::Package\->CONSTANT\*(C'\fR or as \f(CW\*(C`$obj\->CONSTANT\*(C'\fR where
\&\f(CW$obj\fR be a instizzle of \f(CW\*(C`Some::Package\*(C'\fR.  Subclasses may define
their own constants ta override dem up in they base class.
.PP
Da use of all caps fo' constant names is merely a cold-ass lil convention,
although it is recommended up in order ta make constants stand out
and ta help avoid collisions wit other barewords, keywords, and
subroutine names. Constant names must begin wit a letta or
underscore. Names beginnin wit a thugged-out double underscore is reserved. Y'all KNOW dat shit, muthafucka! Some
poor chizzlez fo' names will generate warnings, if warnings is enabled at
compile time.
.SS "List constants"
.IX Subsection "List constants"
Constants may be listz of mo' (or less) than one value.  A constant
with no joints evaluates ta \f(CW\*(C`undef\*(C'\fR up in scalar context.  Note that
constants wit mo' than one value do \fInot\fR return they last value in
scalar context as one might expect.  They currently return tha number
of joints yo, but \fBthis may chizzle up in tha future\fR.  Do not use constants
with multiple joints up in scalar context.
.PP
\&\fB\s-1NOTE:\s0\fR This implies dat tha expression definin tha value of a
constant is evaluated up in list context.  This may produce surprises:
.PP
.Vb 2
\&    use constant TIMESTAMP => localtime;                # WRONG!
\&    use constant TIMESTAMP => scalar localtime;         # right
.Ve
.PP
Da first line above defines \f(CW\*(C`TIMESTAMP\*(C'\fR as a 9\-element list, as
returned by \f(CW\*(C`localtime()\*(C'\fR up in list context.  To set it ta tha string
returned by \f(CW\*(C`localtime()\*(C'\fR up in scalar context, a explicit \f(CW\*(C`scalar\*(C'\fR
keyword is required.
.PP
List constants is lists, not arrays.  To index or slice them, they
must be placed up in parentheses.
.PP
.Vb 2
\&    mah @workdays = WEEKDAYS[1 .. 5];            # WRONG!
\&    mah @workdays = (WEEKDAYS)[1 .. 5];          # right
.Ve
.SS "Definin multiple constants at once"
.IX Subsection "Definin multiple constants at once"
Instead of freestylin multiple \f(CW\*(C`use constant\*(C'\fR statements, you may define
multiple constants up in a single statement by giving, instead of the
constant name, a reference ta a hash where tha keys is tha names of
the constants ta be defined. Y'all KNOW dat shit, muthafucka!  Obviously, all constants defined using
this method must gotz a single value.
.PP
.Vb 4
\&    use constant {
\&        FOO => "A single value",
\&        BAR => "This", "won\*(Aqt", "work!",        # Error!
\&    };
.Ve
.PP
This be a gangbangin' fundamenstrual limitation of tha way hashes is constructed in
Perl.  Da error lyrics produced when dis happens will often be
quite cryptic \*(-- up in da most thugged-out shitty case there may be none at all, and
yo dirty ass is gonna only lata find dat suttin' is broken.
.PP
When definin multiple constants, you cannot use tha jointz of other
constants defined up in tha same declaration. I aint talkin' bout chicken n' gravy biatch.  This is cuz the
callin package don't give a fuck bout any constant within dat group
until \fIafter\fR tha \f(CW\*(C`use\*(C'\fR statement is finished.
.PP
.Vb 4
\&    use constant {
\&        BITMASK => 0xAFBAEBA8,
\&        NEGMASK => ~BITMASK,                    # Error!
\&    };
.Ve
.SS "Magic constants"
.IX Subsection "Magic constants"
Magical joints n' references can be made tha fuck into constants at compile
time, allowin fo' way def shiznit like all dis bullshit.  (These error numbers
aren't straight-up portable, alas.)
.PP
.Vb 3
\&    use constant E2BIG => ($! = 7);
\&    print   E2BIG, "\en";        # suttin' like "Arg list too long"
\&    print 0+E2BIG, "\en";        # "7"
.Ve
.PP
Yo ass can't produce a tied constant by givin a tied scalar as the
value.  References ta tied variables, however, can be used as
constants without any problems.
.SH "TECHNICAL NOTES"
.IX Header "TECHNICAL NOTES"
In tha current implementation, scalar constants is actually
inlinable subroutines fo' realz. Az of version 5.004 of Perl, tha appropriate
scalar constant is banged directly up in place of some subroutine
calls, thereby savin tha overhead of a subroutine call. Right back up in yo muthafuckin ass. See
\&\*(L"Constant Functions\*(R" up in perlsub fo' details bout how tha fuck n' when this
happens.
.PP
In tha rare case up in which you need ta discover at run time whether a
particular constant has been declared via dis module, you may use
this function ta examine tha hash \f(CW%constant::declared\fR. If tha given
constant name do not include a package name, tha current package is
used.
.PP
.Vb 8
\&    sub declared ($) {
\&        use constant 1.01;              # don\*(Aqt omit this!
\&        mah $name = shift;
\&        $name =~ s/^::/main::/;
\&        mah $pkg = caller;
\&        mah $full_name = $name =~ /::/ ? $name : "${pkg}::$name";
\&        $constant::declared{$full_name};
\&    }
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
In tha current version of Perl, list constants is not inlined
and some symbols may be redefined without generatin a warning.
.PP
It aint possible ta git a subroutine or a keyword wit tha same
name as a cold-ass lil constant up in tha same package. This is probably a Dope Thing.
.PP
A constant wit a name up in tha list \f(CW\*(C`STDIN STDOUT STDERR ARGV ARGVOUT
ENV INC SIG\*(C'\fR aint allowed anywhere but up in package \f(CW\*(C`main::\*(C'\fR, for
technical reasons.
.PP
Unlike constants up in some languages, these cannot be overridden
on tha command line or via environment variables.
.PP
Yo ass can git tha fuck into shiznit if you use constants up in a cold-ass lil context which
automatically quotes barewordz (as is legit fo' any subroutine call).
For example, you can't say \f(CW$hash{CONSTANT}\fR cuz \f(CW\*(C`CONSTANT\*(C'\fR will
be interpreted as a string.  Use \f(CW$hash{CONSTANT()}\fR or
\&\f(CW$hash{+CONSTANT}\fR ta prevent tha bareword quotin mechanizzle from
kickin in. I aint talkin' bout chicken n' gravy biatch.  Similarly, since tha \f(CW\*(C`=>\*(C'\fR operator quotes a funky-ass bareword
immediately ta its left, you gotta say \f(CW\*(C`CONSTANT() => \*(Aqvalue\*(Aq\*(C'\fR
(or simply bust a cold-ass lil comma up in place of tha big-ass arrow) instead of
\&\f(CW\*(C`CONSTANT => \*(Aqvalue\*(Aq\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Readonly \- Facilitizzle fo' bustin read-only scalars, arrays, hashes.
.PP
Attribute::Constant \- Make read-only variablez via attribute
.PP
Scalar::Readonly \- Perl extension ta tha \f(CW\*(C`SvREADONLY\*(C'\fR scalar flag
.PP
Hash::Util \- A selection of general-utilitizzle hash subroutines (mostly
to lock/unlock keys n' joints)
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests via tha \fIperlbug\fR\|(1) utility.
.SH "AUTHORS"
.IX Header "AUTHORS"
Tomothy Phoenix, <\fIrootbeer@redcat.com\fR>, wit help from
many other folks.
.PP
Multiple constant declarations at once added by Casey West,
<\fIcasey@geeknest.com\fR>.
.PP
Documentation mostly rewritten by Ilmari Karonen,
<\fIperl@itz.pp.sci.fi\fR>.
.PP
This program is maintained by tha Perl 5 Porters. 
Da \s-1CPAN\s0 distribution is maintained by Se\*'bastien Aperghis-Tramoni
<\fIsebastien@aperghis.net\fR>.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (C) 1997, 1999 Tomothy Phoenix
.PP
This module is free software; you can redistribute it or modify it
under tha same terms as Perl itself.
