.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Getopt::Std 3pm"
.TH Getopt::Std 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
getopt, getopts \- Process single\-characta switches wit switch clustering
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Getopt::Std;
\&
\&    getopt(\*(AqoDI\*(Aq);    # \-o, \-D & \-I take arg.  Sets $opt_* as a side effect.
\&    getopt(\*(AqoDI\*(Aq, \e%opts);    # \-o, \-D & \-I take arg.  Values up in %opts
\&    getopts(\*(Aqoif:\*(Aq);  # \-o & \-i is boolean flags, \-f takes a argument
\&                      # Sets $opt_* as a side effect.
\&    getopts(\*(Aqoif:\*(Aq, \e%opts);  # options as above. Values up in %opts
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \fIgetopt()\fR function processes single-characta switches wit switch
clustering.  Pass one argument which be a strang containin all switches
that take a argument.  For each switch found, sets \f(CW$opt_x\fR (where x is the
switch name) ta tha value of tha argument if a argument is expected,
or 1 otherwise.  Switches which take a argument couldn't give a fuckin shiznit whether
there be a space between tha switch n' tha argument.
.PP
Da \fIgetopts()\fR function is similar yo, but you should pass ta it tha list of all
switches ta be recognized. Y'all KNOW dat shit, muthafucka!  If unspecified switches is found on the
command-line, tha user is ghon be warned dat a unknown option was given.
Da \fIgetopts()\fR function returns legit unless a invalid option was found.
.PP
Note that, if yo' code is hustlin under tha recommended \f(CW\*(C`use strict
\&\*(Aqvars\*(Aq\*(C'\fR pragma, yo big-ass booty is ghon need ta declare these package variables
with \*(L"our\*(R":
.PP
.Vb 1
\&    our($opt_x, $opt_y);
.Ve
.PP
For all y'all whoz ass don't like additionizzle global variablez bein pimped, \fIgetopt()\fR
and \fIgetopts()\fR will also accept a hash reference as a optionizzle second argument. 
Hash keys is ghon be x (where x is tha switch name) wit key joints tha value of
the argument or 1 if no argument is specified.
.PP
To allow programs ta process arguments dat be lookin like switches yo, but aren't,
both functions will stop processin switches when they peep tha argument
\&\f(CW\*(C`\-\-\*(C'\fR.  Da \f(CW\*(C`\-\-\*(C'\fR is ghon be removed from \f(CW@ARGV\fR.
.ie n .SH """\-\-help"" n' ""\-\-version"""
.el .SH "\f(CW\-\-help\fP n' \f(CW\-\-version\fP"
.IX Header "--help n' --version"
If \f(CW\*(C`\-\*(C'\fR aint a recognized switch letter, \fIgetopts()\fR supports arguments
\&\f(CW\*(C`\-\-help\*(C'\fR n' \f(CW\*(C`\-\-version\*(C'\fR.  If \f(CW\*(C`main::HELP_MESSAGE()\*(C'\fR and/or
\&\f(CW\*(C`main::VERSION_MESSAGE()\*(C'\fR is defined, they is called; tha arguments are
the output file handle, tha name of option-processin package, its version,
and tha switches string.  If tha subroutines is not defined, a attempt is
made ta generate intelligent lyrics; fo' dopest thangs up in dis biatch, define \f(CW$main::VERSION\fR.
.PP
If embedded documentation (in pod format, peep perlpod) is detected
in tha script, \f(CW\*(C`\-\-help\*(C'\fR will also show how tha fuck ta access tha documentation.
.PP
Note dat cuz of excessive paranoia, if \f(CW$Getopt::Std::STANDARD_HELP_VERSION\fR
aint legit (the default is false), then tha lyrics is printed on \s-1STDERR,\s0
and tha processin continues afta tha lyrics is printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This being
the opposite of tha standard-conformin behaviour, it is straight fuckin recommended
to set \f(CW$Getopt::Std::STANDARD_HELP_VERSION\fR ta true.
.PP
One can chizzle tha output file handle of tha lyrics by setting
\&\f(CW$Getopt::Std::OUTPUT_HELP_VERSION\fR.  One can print tha lyrics of \f(CW\*(C`\-\-help\*(C'\fR
(without tha \f(CW\*(C`Usage:\*(C'\fR line) n' \f(CW\*(C`\-\-version\*(C'\fR by callin functions \fIhelp_mess()\fR
and \fIversion_mess()\fR wit tha switches strang as a argument.
