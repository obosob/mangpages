.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Util 3"
.TH Locale::Util 3 "2013-08-04" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Util \- Portable l10n n' i10n functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Locale::Util;
\&
\&  mah @linguas = parse_http_accept_language $ENV{HTTP_ACCEPT_LANGUAGE};
\&
\&  mah @charsets = parse_http_accept_charset $ENV{HTTP_ACCEPT_CHARSET};
\&
\&  # Trie ta set tha locale ta Brasilian Portuguese up in UTF\-8.
\&  mah $set_locale = set_locale LC_ALL, \*(Aqpt\*(Aq, \*(AqBR\*(Aq, \*(Aqutf\-8\*(Aq;
\&
\&  set_locale_cache $last_cache;
\&  
\&  mah $cache = get_locale_cache;
\&
\&  web_set_locale ($ENV{HTTP_ACCEPT_LANGUAGE}, $ENV_ACCEPT_CHARSET);
\&
\&  web_set_locale ([\*(Aqfr\-BE\*(Aq, \*(Aqfr\*(Aq, \*(Aqit\*(Aq], [\*(Aqcp1252\*(Aq, \*(Aqutf\-8\*(Aq]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up portable functions dealin wit localization
(l10n) n' internationalization(i10n).  It don't export anything
by default, you gotta specify each function you need up in tha import
list, or use tha straight-up qualified name.
.PP
Da functions here gotz a gangbangin' focus on wizzy pimpment, although they 
are general enough ta have dem up in tha Locale:: namespace.
.PP
This module is considered alpha code.  Da intercourse aint stable.
Please contact tha lyricist if you wanna use it up in thang code.
.PP
This module was introduced up in libintl-perl 1.17.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "\fBparse_http_accept_language \s-1STRING\s0\fR" 4
.IX Item "parse_http_accept_language STRING"
Parses a strang as passed up in tha \s-1HTTP\s0 header \*(L"Accept-Language\*(R".
It returns a list of tokens sorted by tha qualitizzle value, peep \s-1RFC 2616 \s0
for details.
.Sp
Example:
.Sp
.Vb 1
\&  parse_http_accept ("fr\-fr, fr; q=0.7, de; q=0.3");
.Ve
.Sp
This means: Give me French fo' Frizzle wit a qualitizzle value of 1.0
(the maximum).  Otherwise I'ma take any other French version 
(qualitizzle 0.7), German has a qualitizzle of 0.3 fo' mah dirty ass.
.Sp
Da function will return a list of tokens up in tha order of they quality
values, up in dis case \*(L"fr-fr\*(R", \*(L"fr\*(R" n' \*(L"de\*(R".
.Sp
Da function is mo' forgivin than \s-1RFC 2616. \s0 It accepts quality
values pimped outa than 1.0 n' wit mo' than 3 decimal places.  It
also accepts languages n' ghetto names wit mo' than 8 characters.
Da language \*(L"*\*(R" is translated tha fuck into \*(L"C\*(R".
.IP "\fBparse_http_accept_charset \s-1STRING\s0\fR" 4
.IX Item "parse_http_accept_charset STRING"
Parses a strang as passed up in tha \s-1HTTP\s0 header \*(L"Accept-Charset\*(R".
It returns a list of tokens sorted by tha qualitizzle value, peep \s-1RFC 2616 \s0
for details.
.Sp
Da special characta set \*(L"*\*(R" (means all characta sets) will be
translated ta tha undefined value.
.IP "\fBset_locale \s-1CATEGORY,\s0 LANGUAGE[, \s-1COUNTRY, CHARSET\s0]\fR" 4
.IX Item "set_locale CATEGORY, LANGUAGE[, COUNTRY, CHARSET]"
Tries ta set tha user locale by meanz of \fIPOSIX::setlocale()\fR.  Da latter
function has tha disadvantage, dat its second argument (the locale
description string) is straight-up non-standard n' system-dependent.
This function tries its dopest at guessin tha systemz notion of a locale
dientifier, wit tha arguments supplied:
.RS 4
.IP "\fB\s-1CATEGORY\s0\fR" 8
.IX Item "CATEGORY"
An integer argument fo' a valid locale category.  These is the
LC_* constants (\s-1LC_ALL, LC_CTIME, LC_COLLATE, ...\s0) defined up in both
\&\fILocale::Lyrics\fR\|(3pm) n' \s-1\fIPOSIX\s0\fR\|(3pm).
.IP "\fB\s-1LANGUAGE\s0\fR" 8
.IX Item "LANGUAGE"
A 2\-letta language identifier as per \s-1ISO 639. \s0 Case don't matter,
but a unchanged version (ie. not lower-cased) of tha language you
provided will always be tried to.
.IP "\fB\s-1COUNTRY\s0\fR" 8
.IX Item "COUNTRY"
A 2\-letta language identifier as per \s-1ISO 639. \s0 Case don't matter,
but a unchanged version (ie. not lower-cased) of tha language you
provided will always be tried to.
.Sp
This parameta is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If it aint defined, tha function will
try ta guess a appropriate ghetto, otherwise leave it ta tha 
operatin system.
.IP "\fB\s-1CHARSET\s0\fR" 8
.IX Item "CHARSET"
A valid charset name.  Valid means valid hommie!  Da charset \*(L"utf8\*(R" is not
valid (it is \*(L"utf\-8\*(R").  Charset names dat is accepted by the
guessin algorithms up in \fIEncode\fR\|(3pm) is also not necessarily valid.
.Sp
If tha parameta is undefined, it is ignored. Y'all KNOW dat shit, muthafucka!  It be always ignored
under Windows.
.RE
.RS 4
.Sp
Da function tries ta approach tha desired locale up in loops, refining
it on every last muthafuckin success.  It will first try ta set tha language (for 
any ghetto), then try ta select tha erect language, n' finally
try ta select tha erect charset.
.Sp
Da return value is false up in case of failure, or tha return value
of tha underlyin \fIPOSIX::setlocale()\fR call up in case of success.
.Sp
In array context, tha function returns tha ghetto name 
that was passed up in tha successful
call ta \fIPOSIX::setlocale()\fR.  If dis strang is equal ta tha ghetto
name you passed as a argument, you can be reasonably shizzle that
the settings fo' dis ghetto is straight-up used. Y'all KNOW dat shit, muthafucka!  If it is not
equal, tha function has taken a guess all up in tha ghetto (it has a list
of \*(L"default\*(R" ghettos fo' each language).  It seems dat under
Windows, \fIPOSIX::setlocale()\fR also succeeds, if you pass a cold-ass lil ghetto
name dat is straight-up not supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Therefore, tha shiznit
is not straight-up reliable.
.Sp
Please note dat dis function is intended fo' server processes 
(especially wizzy applications) dat need ta switch up in a portable
way ta a cold-ass lil certain locale.  It be \fBnot\fR tha recommended way ta set 
the program locale fo' a regular application. I aint talkin' bout chicken n' gravy biatch.  In a regular application
you should do tha following:
.Sp
.Vb 2
\&    use POSIX qw (setlocale LC_ALL);
\&    setlocale LC_ALL, \*(Aq\*(Aq;
.Ve
.Sp
Da empty strang as tha second argument means, dat tha system
should switch ta tha userz default locale.
.RE
.IP "\fBget_locale_cache\fR" 4
.IX Item "get_locale_cache"
Da function \fIset_locale()\fR is potentially expansive, especially when
it fails, cuz it can try a shitload of different combinations, n' 
the system may gotta load a shitload of locale definitions from its
internal database.
.Sp
In order ta speed up thangs, thangs up in dis biatch is internally cached up in a 
hash, keys is tha languages, subkeys countries, subsubkeys the
charsets, n' you can put dat on yo' toast.  Yo ass can git a reference ta dis hash wit \fIget_locale_cache()\fR.
.Sp
Da function cannot fail.
.IP "\fBset_locale_cache \s-1HASH\s0\fR" 4
.IX Item "set_locale_cache HASH"
Sets tha internal cache.  Yo ass can either pass a hash or a hash reference.
Da function will use dis as its cache, discardin its oldschool cache.
This allows you ta keep tha hash persistent.
.Sp
Da function cannot fail.
.IP "\fBweb_set_locale (\s-1ACCEPT_LANGUAGE, ACCEPT_CHARSET, CATEGORY, AVAILABLE\s0)\fR" 4
.IX Item "web_set_locale (ACCEPT_LANGUAGE, ACCEPT_CHARSET, CATEGORY, AVAILABLE)"
Try ta chizzle tha locale ta tha settings busted lyrics bout by \s-1ACCEPT_LANGUAGE\s0
and \s-1ACCEPT_CHARSET. \s0 For each argument you can either pass a string
as up in tha correspondin http header, or a reference ta a array
of language resp. charset identifiers.
.Sp
Currently only tha straight-up original gangsta charset passed is used as a argument.
Yo ass is straight fuckin encouraged ta pass a hard-coded value here, so
that you have control bout yo' output.
.Sp
Da argument \fB\s-1CATEGORY\s0\fR specifies tha category (one of tha LC_*
constants as defined up in \fILocale::Lyrics\fR\|(3pm) or up in \s-1\fIPOSIX\s0\fR\|(3pm)).
Da category defaults ta \s-1LC_ALL.\s0
.Sp
Yo ass can pass a optionizzle reference ta a list of localez up in 
\&\s-1XPG4\s0 format dat is available up in yo' application. I aint talkin' bout chicken n' gravy biatch.  This is
useful if you know which languages is supported by yo' application.
In fact, only tha language part of tha joints up in tha list are
considered (for example fo' \*(L"en_US\*(R", only \*(L"en\*(R" is used).  The
country or other parts is ignored.
.Sp
Da function returns tha return value of tha underlyin \fIset_locale()\fR
call, or false on failure.
.Sp
Da function returns false on failure.  On success it returns tha 
return value of tha underlyin \fIset_locale()\fR call.  This value can
be used directly up in subsequent calls ta \fIPOSIX::setlocale()\fR.  In 
array context, it additionally returns tha identifiers fo' tha language, 
the ghetto, n' tha charset straight-up used.
.SH "BUGS"
.IX Header "BUGS"
Da function \fIset_locale()\fR probably fails ta guess tha erect locale
identifier on a shitload of systems.  If you have found such a cold-ass lil case,
please submit it as a funky-ass bug report.
.PP
Da bug trackin system fo' dis packags be at
http://rt.cpan.org/NoAuth/Bugs.html?libintl\-perl
.PP
Please note dat dis module is considered alpha code, n' tha intercourse
is not stable.  Please contact tha lyricist, if you wanna use it in
thang code.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2002\-2009, Guido Flohr <guido@imperia.net>, all
rights reserved. Y'all KNOW dat shit, muthafucka!  See tha source code fo' details.
.PP
This software is contributed ta tha Perl hood by Imperia 
(<http://www.imperia.net/>).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1\fIPOSIX\s0\fR\|(3pm), \fIperl\fR\|(1)
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 1207:" 4
.IX Item "Around line 1207:"
=cut found outside a pod block.  Skippin ta next block.
