.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Symbol 3pm"
.TH Symbol 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Symbol \- manipulate Perl symbols n' they names
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Symbol;
\&
\&    $sym = gensym;
\&    open($sym, "filename");
\&    $_ = <$sym>;
\&    # etc.
\&
\&    ungensym $sym;      # no effect
\&
\&    # replace *FOO{IO} handle but not $FOO, %FOO, etc.
\&    *FOO = geniosym;
\&
\&    print qualify("x"), "\en";              # "main::x"
\&    print qualify("x", "FOO"), "\en";       # "FOO::x"
\&    print qualify("BAR::x"), "\en";         # "BAR::x"
\&    print qualify("BAR::x", "FOO"), "\en";  # "BAR::x"
\&    print qualify("STDOUT", "FOO"), "\en";  # "main::STDOUT" (global)
\&    print qualify(\e*x), "\en";              # returns \e*x
\&    print qualify(\e*x, "FOO"), "\en";       # returns \e*x
\&
\&    use strict refs;
\&    print { qualify_to_ref $fh } "foo!\en";
\&    $ref = qualify_to_ref $name, $pkg;
\&
\&    use Symbol qw(delete_package);
\&    delete_package(\*(AqFoo::Bar\*(Aq);
\&    print "deleted\en" unless exists $Foo::{\*(AqBar::\*(Aq};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Symbol::gensym\*(C'\fR creates a anonymous glob n' returns a reference
to dat shit.  Such a glob reference can be used as a gangbangin' file or directory
handle.
.PP
For backward compatibilitizzle wit olda implementations dat didn't
support anonymous globs, \f(CW\*(C`Symbol::ungensym\*(C'\fR be also provided.
But it don't do anything.
.PP
\&\f(CW\*(C`Symbol::geniosym\*(C'\fR creates a anonymous \s-1IO\s0 handle.  This can be
assigned tha fuck into a existin glob without affectin tha non-IO portions
of tha glob.
.PP
\&\f(CW\*(C`Symbol::qualify\*(C'\fR turns unqualified symbol names tha fuck into qualified
variable names (e.g. \*(L"myvar\*(R" \-> \*(L"MyPackage::myvar\*(R").  If it is given a
second parameter, \f(CW\*(C`qualify\*(C'\fR uses it as tha default package;
otherwise, it uses tha package of its calla n' shit.  Regardless, global
variable names (e.g. \*(L"\s-1STDOUT\*(R", \*(L"ENV\*(R", \*(L"SIG\*(R"\s0) is always qualified with
\&\*(L"main::\*(R".
.PP
Qualification applies only ta symbol names (strings).  References are
left unchanged under tha assumption dat they is glob references,
which is qualified by they nature.
.PP
\&\f(CW\*(C`Symbol::qualify_to_ref\*(C'\fR is just like \f(CW\*(C`Symbol::qualify\*(C'\fR except dat it
returns a glob ref rather than a symbol name, so you can use tha result
even if \f(CW\*(C`use strict \*(Aqrefs\*(Aq\*(C'\fR is up in effect.
.PP
\&\f(CW\*(C`Symbol::delete_package\*(C'\fR wipes up a whole package namespace.  Note
this routine aint exported by default\*(--you may wanna import it
explicitly.
.SH "BUGS"
.IX Header "BUGS"
\&\f(CW\*(C`Symbol::delete_package\*(C'\fR be a lil' bit too bangin naaahhmean, biatch? It undefines every last muthafuckin symbol that
lives up in tha specified package. Right back up in yo muthafuckin ass. Since perl, fo' performizzle reasons, do not
perform a symbol table lookup each time a gangbangin' function is called or a global
variable be accessed, some code dat has already been loaded n' dat make use
of symbols up in package \f(CW\*(C`Foo\*(C'\fR may stop hustlin afta you delete \f(CW\*(C`Foo\*(C'\fR, even if
you reload tha \f(CW\*(C`Foo\*(C'\fR module afterwards.
