.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "version 3"
.TH version 3 "2013-08-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
version \- Perl extension fo' Version Objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # Parsin version strings (decimal or dotted\-decimal)
\&
\&  use version 0.77; # git sickest fuckin bug\-fixes n' API
\&  $ver = version\->parse($string)
\&
\&  # Declarin a thugged-out dotted\-decimal $VERSION (keep on one line!)
\&
\&  use version; our $VERSION = version\->declare("v1.2.3"); # formal
\&  use version; our $VERSION = qv("v1.2.3");               # shorthand
\&  use version; our $VERSION = qv("v1.2_3");               # alpha
\&
\&  # Declarin a old\-style decimal $VERSION (use quotes!)
\&
\&  our $VERSION = "1.0203";                                # recommended
\&  use version; our $VERSION = version\->parse("1.0203");   # formal
\&  use version; our $VERSION = version\->parse("1.02_03");  # alpha
\&
\&  # Comparin mixed version stylez (decimals, dotted\-decimals, objects)
\&
\&  if ( version\->parse($v1) == version\->parse($v2) ) {
\&    # do stuff
\&  }
\&
\&  # Sortin mixed version styles
\&
\&  @ordered = sort { version\->parse($a) <=> version\->parse($b) } @list;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Version objects was added ta Perl up in 5.10.  This module implements version
objects fo' olda version of Perl n' serves up tha version object \s-1API\s0 fo' all
versionz of Perl.  All previous releases before 0.74 is deprecated n' should
not be used cuz of incompatible \s-1API\s0 chizzles.  Version 0.77 introduces tha new
\&'parse' n' 'declare' methodz ta standardize usage.  Yo ass is straight fuckin urged to
set 0.77 as a minimum up in yo' code, e.g.
.PP
.Vb 1
\&  use version 0.77; # even fo' Perl v.5.10.0
.Ve
.SH "TYPES OF VERSION OBJECTS"
.IX Header "TYPES OF VERSION OBJECTS"
There is two different typez of version objects, correspondin ta tha two
different stylez of versions up in use:
.IP "Decimal Versions" 2
.IX Item "Decimal Versions"
Da funky-ass floating-point number \f(CW$VERSION\fR.  Da advantage ta dis steez is
that you don't need ta do anythang special, just type a number tha fuck into your
source file.  Quotin is recommended, as it ensures dat trailin zeroes
(\*(L"1.50\*(R") is preserved up in any warnings or other output.
.IP "Dotted Decimal Versions" 2
.IX Item "Dotted Decimal Versions"
Da mo' modern form of version assignment, wit 3 (or potentially more)
integers separated by decimal points (e.g. v1.2.3).  This is tha form that
Perl itself has used since 5.6.0 was busted out. Y'all KNOW dat shit, muthafucka!  Da leadin 'v' is now
strongly recommended fo' clarity, n' will throw a warnin up in a gangbangin' future
release if omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  A leadin 'v' characta is required ta pass the
\&\*(L"\fIis_strict()\fR\*(R" test.
.SH "DECLARING VERSIONS"
.IX Header "DECLARING VERSIONS"
If you gotz a module dat uses a thugged-out decimal \f(CW$VERSION\fR (floatin point), n' you
do not intend ta eva chizzle that, dis module aint fo' yo thugged-out ass.  There is
nothang dat version.pm gains you over a simple \f(CW$VERSION\fR assignment:
.PP
.Vb 1
\&  our $VERSION = "1.02";
.Ve
.PP
Since Perl v5.10.0 includes tha version.pm comparison logic anyways,
you don't need ta do anythang at all.
.SS "How tha fuck ta convert a module from decimal ta dotted-decimal"
.IX Subsection "How tha fuck ta convert a module from decimal ta dotted-decimal"
If you have used a thugged-out decimal \f(CW$VERSION\fR up in tha past n' wish ta switch ta a
dotted-decimal \f(CW$VERSION\fR, then you need ta cook up a one-time conversion to
the freshly smoked up format.
.PP
\&\fBImportant Note\fR: you must ensure dat yo' freshly smoked up \f(CW$VERSION\fR is numerically
greata than yo' current decimal \f(CW$VERSION\fR; dis aint always obvious. First,
convert yo' oldschool decimal version (e.g. 1.02) ta a normalized dotted-decimal
form:
.PP
.Vb 2
\&  $ perl \-Mversion \-e \*(Aqprint version\->parse("1.02")\->normal\*(Aq
\&  v1.20.0
.Ve
.PP
Then increment any of tha dotted-decimal components (v1.20.1 or v1.21.0).
.ie n .SS "How tha fuck ta ""declare()"" a thugged-out dotted-decimal version"
.el .SS "How tha fuck ta \f(CWdeclare()\fP a thugged-out dotted-decimal version"
.IX Subsection "How tha fuck ta declare() a thugged-out dotted-decimal version"
.Vb 1
\&  use version; our $VERSION = version\->declare("v1.2.3");
.Ve
.PP
Da \f(CW\*(C`declare()\*(C'\fR method always creates dotted-decimal version objects, n' you can put dat on yo' toast.  When
used up in a module, you \fBmust\fR put it on tha same line as \*(L"use version\*(R" to
ensure dat \f(CW$VERSION\fR is read erectly by \s-1PAUSE\s0 n' installa tools.  You
should also add 'version' ta tha 'configure_requires' section of your
module metadata file.  See instructions up in ExtUtils::MakeMaker or
Module::Build fo' details.
.PP
\&\fBImportant Note\fR: Even if you pass up in what tha fuck be lookin like a thugged-out decimal number
(\*(L"1.2\*(R"), a thugged-out dotted-decimal is ghon be pimped (\*(L"v1.200.0\*(R"). To avoid mad drama
or unintentionizzle errors on olda Perls, follow these guidelines:
.IP "\(bu" 2
Always bust a thugged-out dotted-decimal wit (at least) three components
.IP "\(bu" 2
Always bust a leading-v
.IP "\(bu" 2
Always quote tha version
.PP
If you straight-up insist on rockin version.pm wit a ordinary decimal version,
use \f(CW\*(C`parse()\*(C'\fR instead of declare.  See tha \*(L"\s-1PARSING AND COMPARING VERSIONS\*(R"\s0
for details.
.PP
See also version::Internals fo' mo' on version number conversion,
quoting, calculated version numbers n' declarin pimper or \*(L"alpha\*(R" version
numbers.
.SH "PARSING AND COMPARING VERSIONS"
.IX Header "PARSING AND COMPARING VERSIONS"
If you need ta compare version numbers yo, but can't be shizzle whether they are
expressed as numbers, strings, v\-strings or version objects,  then you should
use version.pm ta parse dem all tha fuck into objects fo' comparison.
.ie n .SS "How tha fuck ta ""parse()"" a version"
.el .SS "How tha fuck ta \f(CWparse()\fP a version"
.IX Subsection "How tha fuck ta parse() a version"
Da \f(CW\*(C`parse()\*(C'\fR method takes up in anythang dat might be a version n' returns
a correspondin version object, bustin any necessary conversion along tha way.
.IP "\(bu" 2
Dotted-decimal: bare v\-strings (v1.2.3) n' strings wit mo' than one
decimal point n' a leadin 'v' (\*(L"v1.2.3\*(R"); \s-1NOTE\s0 you can technologically use a
v\-strin or strings wit a leading-v n' only one decimal point (v1.2 or
\&\*(L"v1.2\*(R") yo, but yo big-ass booty is ghon confuse both yo ass n' others.
.IP "\(bu" 2
Decimal: regular decimal numbers (literal or up in a string)
.PP
Some examples:
.PP
.Vb 8
\&  $variable   version\->parse($variable)
\&  \-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  1.23        v1.230.0
\&  "1.23"      v1.230.0
\&  v1.23       v1.23.0
\&  "v1.23"     v1.23.0
\&  "1.2.3"     v1.2.3
\&  "v1.2.3"    v1.2.3
.Ve
.PP
See version::Internals fo' mo' on version number conversion.
.SS "How tha fuck ta check fo' a legal version string"
.IX Subsection "How tha fuck ta check fo' a legal version string"
If you do not wanna straight-up create a gangbangin' full blown version object yo, but
would still like ta verify dat a given strang meets tha criteria to
be parsed as a version, there be two helper functions dat can be
employed directly:
.ie n .IP """is_lax()""" 4
.el .IP "\f(CWis_lax()\fR" 4
.IX Item "is_lax()"
Da lax criteria correspondz ta what tha fuck is currently allowed by the
version parser n' shit.  All of tha followin formats is acceptable
for dotted-decimal formats strings:
.Sp
.Vb 5
\&    v1.2
\&    1.2345.6
\&    v1.23_4
\&    1.2345
\&    1.2345_01
.Ve
.ie n .IP """is_strict()""" 4
.el .IP "\f(CWis_strict()\fR" 4
.IX Item "is_strict()"
If you wanna limit yo ass ta a much mo' narrow definizzle of what
a version strang constitutes, \f(CW\*(C`is_strict()\*(C'\fR is limited ta version
strings like tha followin list:
.Sp
.Vb 2
\&    v1.234.5
\&    2.3456
.Ve
.PP
See version::Internals fo' detailz of tha regular expressions
that define tha legal version strang forms, as well as how tha fuck ta use
those regular expressions up in yo' own code if \f(CW\*(C`is_lax()\*(C'\fR and
\&\f(CW\*(C`is_strict()\*(C'\fR is not sufficient fo' yo' needs.
.SS "How tha fuck ta compare version objects"
.IX Subsection "How tha fuck ta compare version objects"
Version objects overload tha \f(CW\*(C`cmp\*(C'\fR n' \f(CW\*(C`<=>\*(C'\fR operators.  Perl
automatically generates all of tha other comparison operators based on them
two so all tha aiiight logical comparisons will work.
.PP
.Vb 3
\&  if ( version\->parse($v1) == version\->parse($v2) ) {
\&    # do stuff
\&  }
.Ve
.PP
If a version object is compared against a non-version object, tha non-object
term is ghon be converted ta a version object rockin \f(CW\*(C`parse()\*(C'\fR.  This may give
surprisin thangs up in dis biatch:
.PP
.Vb 2
\&  $v1 = version\->parse("v0.95.0");
\&  $bool = $v1 < 0.96; # FALSE since 0.96 is v0.960.0
.Ve
.PP
Always comparin ta a version object will help avoid surprises:
.PP
.Vb 1
\&  $bool = $v1 < version\->parse("v0.96.0"); # TRUE
.Ve
.PP
Note dat \*(L"alpha\*(R" version objects (where tha version strang gotz nuff
a trailin underscore segment) compare as less than tha equivalent
version without a underscore:
.PP
.Vb 1
\&  $bool = version\->parse("1.23_45") < version\->parse("1.2345"); # TRUE
.Ve
.PP
See version::Internals fo' mo' details on \*(L"alpha\*(R" versions.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.SS "\fIis_alpha()\fP"
.IX Subsection "is_alpha()"
True if n' only if tha version object was pimped wit a underscore, e.g.
.PP
.Vb 2
\&  version\->parse(\*(Aq1.002_03\*(Aq)\->is_alpha;  # TRUE
\&  version\->declare(\*(Aq1.2.3_4\*(Aq)\->is_alpha; # TRUE
.Ve
.SS "\fIis_qv()\fP"
.IX Subsection "is_qv()"
True only if tha version object be a thugged-out dotted-decimal version, e.g.
.PP
.Vb 4
\&  version\->parse(\*(Aqv1.2.0\*(Aq)\->is_qv;       # TRUE
\&  version\->declare(\*(Aqv1.2\*(Aq)\->is_qv;       # TRUE
\&  qv(\*(Aq1.2\*(Aq)\->is_qv;                      # TRUE
\&  version\->parse(\*(Aq1.2\*(Aq)\->is_qv;          # FALSE
.Ve
.SS "\fInormal()\fP"
.IX Subsection "normal()"
Returns a strang wit a standard 'normalized' dotted-decimal form wit a
leading-v n' at least 3 components.
.PP
.Vb 2
\& version\->declare(\*(Aqv1.2\*(Aq)\->normal;  # v1.2.0
\& version\->parse(\*(Aq1.2\*(Aq)\->normal;     # v1.200.0
.Ve
.SS "\fInumify()\fP"
.IX Subsection "numify()"
Returns a value representin tha object up in a pure decimal form without
trailin zeroes.
.PP
.Vb 2
\& version\->declare(\*(Aqv1.2\*(Aq)\->numify;  # 1.002
\& version\->parse(\*(Aq1.2\*(Aq)\->numify;     # 1.2
.Ve
.SS "\fIstringify()\fP"
.IX Subsection "stringify()"
Returns a strang dat be as close ta tha original gangsta representation as possible.
If tha original gangsta representation was a numeric literal, it is ghon be returned the
way perl would normally represent it up in a string.  This method is used whenever
a version object is interpolated tha fuck into a string.
.PP
.Vb 3
\& version\->declare(\*(Aqv1.2\*(Aq)\->stringify;    # v1.2
\& version\->parse(\*(Aq1.200\*(Aq)\->stringify;     # 1.200
\& version\->parse(1.02_30)\->stringify;     # 1.023
.Ve
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
.SS "\fIqv()\fP"
.IX Subsection "qv()"
This function is no longer recommended fo' use yo, but is maintained for
compatibilitizzle wit existin code.  If you do not wanna have it exported
to yo' namespace, use dis form:
.PP
.Vb 1
\&  use version 0.77 ();
.Ve
.SS "\fIis_lax()\fP"
.IX Subsection "is_lax()"
(Not exported by default)
.PP
This function takes a scalar argument n' returns a funky-ass boolean value indicating
whether tha argument meets tha \*(L"lax\*(R" rulez fo' a version number n' shit.  Leadin and
trailin spaces is not allowed.
.SS "\fIis_strict()\fP"
.IX Subsection "is_strict()"
(Not exported by default)
.PP
This function takes a scalar argument n' returns a funky-ass boolean value indicating
whether tha argument meets tha \*(L"strict\*(R" rulez fo' a version number n' shit.  Leading
and trailin spaces is not allowed.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jizzy Peading-a-ling <jpeacock@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
version::Internals.
.PP
perl.
