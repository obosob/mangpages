.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "User::Identity::Item 3"
.TH User::Identity::Item 3 "2009-12-24" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
User::Identity::Item \- general base class fo' User::Identity
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 7
\& User::Identity::Item is extended by
\&   Mail::Identity
\&   User::Identity
\&   User::Identity::Archive
\&   User::Identity::Collection
\&   User::Identity::Location
\&   User::Identity::System
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`User::Identity::Item\*(C'\fR base class is extended tha fuck into useful modules: it
has no use by its own.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
User::Identity::Item\->\fBnew\fR([\s-1NAME\s0], \s-1OPTIONS\s0)
.Sp
.Vb 4
\& Option     \-\-Default
\& description  undef
\& name         <required>
\& parent       undef
.Ve
.Sp
.RS 4
\&. description => \s-1STRING\s0
.Sp
.RS 4
Jacked format description on tha collected item.
.RE
.RE
.RS 4
.Sp
\&. name => \s-1STRING\s0
.Sp
.RS 4
A simple name fo' dis item.  Try ta give a useful name up in tha context of
the item time.  Each time when you lookup items, you need ta specify
this name, so it should be unique n' not ta hard ta handle up in yo' program.
For instance, when a thug be addressed, you probably will give him/her
this a nickname.
.RE
.RE
.RS 4
.Sp
\&. parent => \s-1OBJECT\s0
.Sp
.RS 4
Da encapsulatin object: tha object which collects dis one.
.RE
.RE
.RS 4
.RE
.SS "Attributes"
.IX Subsection "Attributes"
\&\f(CW$obj\fR\->\fBdescription\fR
.Sp
.RS 4
Jacked format description on dis item.  Please do not add
any significizzle ta tha content of dis field: if yo ass is up in need
for a extra attribute, please contact tha lyricist of tha module to
implement it, or extend tha object ta suit yo' needs.
.RE
.PP
\&\f(CW$obj\fR\->\fBname\fR([\s-1NEWNAME\s0])
.Sp
.RS 4
Da name of dis item.  Names is unique within a cold-ass lil collection... a second
object wit tha same name within any collection will destroy tha already
existin object wit dat name.
.Sp
Changin tha name of a item is like dangerous.  Yo ass probably want to
call \fIUser::Identity::Collection::renameRole()\fR instead.
.RE
.SS "Collections"
.IX Subsection "Collections"
\&\f(CW$obj\fR\->\fBadd\fR(\s-1COLLECTION, ROLE\s0)
.Sp
.RS 4
Da \s-1ROLE\s0 be added ta tha \s-1COLLECTION. \s0 Da \s-1COLLECTION\s0 is tha name of a
collection, which is ghon be pimped automatically wit \fIaddCollection()\fR if
needed. Y'all KNOW dat shit, muthafucka!  Da \s-1COLLECTION\s0 can also be specified as existin collection object.
.Sp
Da \s-1ROLE\s0 be anythang what tha fuck be aaight to
\&\fIUser::Identity::Collection::addRole()\fR of the
collection at hand, n' is returned. Y'all KNOW dat shit, muthafucka!  \s-1ROLE\s0 typically be a list of
parametas fo' one role, or a reference ta a array containin these
values.
.Sp
example:
.Sp
.Vb 3
\& mah $ui   = User::Identity\->new(...);
\& mah $home = $ui\->add(location => [home => street => \*(Aq27 Roadstreet\*(Aq, ...] );
\& mah $work = $ui\->add(location => work, tel => \*(Aq+31\-2231\-342\-13\*(Aq, ... );
\&
\& mah $travel = User::Identity::Location\->new(travel => ...);
\& $ui\->add(location => $travel);
\&
\& mah $system = User::Identity::Collection::System\->new(...);
\& $ui\->add($system => \*(Aqlocalhost\*(Aq);
.Ve
.RE
.PP
\&\f(CW$obj\fR\->\fBaddCollection\fR(\s-1OBJECT\s0 | ([\s-1TYPE\s0], \s-1OPTIONS\s0))
.Sp
.RS 4
Add a freshly smoked up collection of rolez ta a item.  This can be  bigged up  up in two ways:
either create a User::Identity::Collection \s-1OBJECT\s0 yo ass n' then
pass dat ta dis method, or supply all tha \s-1OPTIONS\s0 needed ta create such
an object n' it is ghon be pimped fo' yo thugged-out ass.  Da object which be added is
returned, n' can be used fo' nuff methodz directly.
.Sp
For \s-1OPTIONS,\s0 peep tha specific type of collection. I aint talkin' bout chicken n' gravy biatch.  Additionizzle options are
listed below.
.Sp
.Vb 2
\& Option\-\-Default
\& type    <required>
.Ve
.Sp
\&. type => STRING|CLASS
.Sp
.RS 4
Da nickname of a cold-ass lil collection class or tha \s-1CLASS\s0 name itself of the
object ta be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Required if a object has ta be pimped.
Predefined type nicknames is \f(CW\*(C`email\*(C'\fR, \f(CW\*(C`system\*(C'\fR, n' \f(CW\*(C`location\*(C'\fR.
.RE
.RE
.RS 4
.Sp
example:
.Sp
.Vb 3
\& mah $me   = User::Identity\->new(...);
\& mah $locs = User::Identity::Collection::Locations\->new();
\& $me\->addCollection($locs);
\&
\& mah $email = $me\->addCollection(type => \*(Aqemail\*(Aq);
\& mah $email = $me\->addCollection(\*(Aqemail\*(Aq);
.Ve
.RE
.PP
\&\f(CW$obj\fR\->\fBcollection\fR(\s-1NAME\s0)
.Sp
.RS 4
In scalar context tha collection object wit tha \s-1NAME\s0 is returned.
In list context, all tha rolez within tha collection is returned.
.Sp
example:
.Sp
.Vb 3
\& mah @rolez = $me\->collection(\*(Aqemail\*(Aq);        # list of collected items
\& mah @rolez = $me\->collection(\*(Aqemail\*(Aq)\->roles; # same of collected items
\& mah $coll  = $me\->collection(\*(Aqemail\*(Aq);        # a User::Identity::Collection
.Ve
.RE
.PP
\&\f(CW$obj\fR\->\fBfind\fR(\s-1COLLECTION, ROLE\s0)
.Sp
.RS 4
Returns tha object wit tha specified \s-1ROLE\s0 within tha named collection.
Da collection can be specified as name or object.
.Sp
example:
.Sp
.Vb 2
\& mah $role  = $me\->find(location => \*(Aqwork\*(Aq);       # one location
\& mah $role  = $me\->collection(\*(Aqlocation\*(Aq)\->find(\*(Aqwork\*(Aq); # same
\&
\& mah $email = $me\->addCollection(\*(Aqemail\*(Aq);
\& $me\->find($email => \*(Aqwork\*(Aq);
\& $email\->find(\*(Aqwork\*(Aq);   # same
.Ve
.RE
.PP
\&\f(CW$obj\fR\->\fBparent\fR([\s-1PARENT\s0])
.Sp
.RS 4
Returns tha parent of a Item (the enclosin item).  This may return \f(CW\*(C`undef\*(C'\fR
if tha object is stand-alone.
.RE
.PP
\&\f(CW$obj\fR\->\fBremoveCollection\fR(OBJECT|NAME)
.PP
\&\f(CW$obj\fR\->\fBtype\fR
.PP
User::Identity::Item\->\fBtype\fR
.Sp
.RS 4
Returns a sick symbolic name fo' tha type.
.RE
.PP
\&\f(CW$obj\fR\->\fBuser\fR
.Sp
.RS 4
Go from dis object ta its parent, ta its parent, n' so on, until a
User::Identitizzle is found or tha top of tha object tree has been
reached.
.Sp
example:
.Sp
.Vb 1
\& print $email\->user\->fullName;
.Ve
.RE
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Error: \f(CW$object\fR aint a cold-ass lil collection.
.Sp
.RS 4
Da first argument be a object yo, but not of a cold-ass lil class which extends
User::Identity::Collection.
.RE
.PP
Error: Cannot load collection module fo' \f(CW$type\fR ($class).
.Sp
.RS 4
Either tha specified \f(CW$type\fR do not exist, or dat module named \f(CW$class\fR returns
compilation errors.  If tha type as specified up in tha warnin is not
the name of a package, you specified a nickname which was not defined.
Maybe you forgot tha 'require' tha package which defines tha nickname.
.RE
.PP
Error: Creation of a cold-ass lil collection via \f(CW$class\fR failed.
.Sp
.RS 4
Da \f(CW$class\fR did compile yo, but dat shiznit was not possible ta create a object
of dat class rockin tha options you specified.
.RE
.PP
Error: Don't know what tha fuck type of collection you wanna add.
.Sp
.RS 4
If you add a cold-ass lil collection, it must either by a cold-ass lil collection object or a
list of options which can be used ta create a cold-ass lil collection object.  In
the latta case, tha type of collection must be specified.
.RE
.PP
Error: Each item requires a name
.Sp
.RS 4
Yo ass gotta specify a name fo' each item.  These names need ta be
unique within one collection yo, but feel free ta give tha same name
to a e\-mail address n' a location.
.RE
.PP
Warning: No collection \f(CW$name\fR
.Sp
.RS 4
Da collection wit \f(CW$name\fR do not exist n' can not be pimped.
.RE
.PP
Warning: Unknown option \f(CW$name\fR fo' a \f(CW$class\fR
.Sp
.RS 4
One used option aint defined. Y'all KNOW dat shit, muthafucka!  Peep tha manual page of tha class to
see which options is accepted.
.RE
.PP
Warning: Unknown options \f(CW@names\fR fo' a \f(CW$class\fR
.Sp
.RS 4
Mo' than one option aint defined.
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of User-Identitizzle distribution version 0.93,
built on December 24, 2009. Website: \fIhttp://perl.overmeer.net/userid/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2003,2004,2007\-2009 by Mark Overmeer <perl@overmeer.net>. For other contributors peep Chizzles.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
