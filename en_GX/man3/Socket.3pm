.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Socket 3"
.TH Socket 3 "2014-10-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
"Socket" \- networkin constants n' support functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\f(CW\*(C`Socket\*(C'\fR a low-level module used by, among other thangs, tha IO::Socket
family of modules. Da followin examplez demonstrate some low-level uses but
a practical program wannaly use tha higher-level \s-1API\s0 provided by
\&\f(CW\*(C`IO::Socket\*(C'\fR or similar instead.
.PP
.Vb 1
\& use Socket qw(PF_INET SOCK_STREAM pack_sockaddr_in inet_aton);
\&
\& socket(my $socket, PF_INET, SOCK_STREAM, 0)
\&     or take a thugged-out dirtnap "socket: $!";
\&
\& mah $port = getservbyname "echo", "tcp";
\& connect($socket, pack_sockaddr_in($port, inet_aton("localhost")))
\&     or take a thugged-out dirtnap "connect: $!";
\&
\& print $socket "Yo muthafucka, ghetto!\en";
\& print <$socket>;
.Ve
.PP
See also tha \*(L"\s-1EXAMPLES\*(R"\s0 section.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up a variety of constants, structure manipulators n' other
functions related ta socket-based networking. Da joints n' functions
provided is useful when used up in conjunction wit Perl core functions such as
\&\fIsocket()\fR, \fIsetsockopt()\fR n' \fIbind()\fR. Well shiiiit, it also serves up nuff muthafuckin other support
functions, mostly fo' dealin wit conversionz of network addresses between
human-readable n' natizzle binary forms, n' fo' hostname resolver operations.
.PP
Some constants n' functions is exported by default by dis module; but for
backward-compatibilitizzle any recently-added symbols is not exported by default
and must be axed explicitly. When a import list is provided ta the
\&\f(CW\*(C`use Socket\*(C'\fR line, tha default exports is not automatically imported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Well shiiiit, it is
therefore dopest practice ta always ta explicitly list all tha symbols required.
.PP
Also, some common socket \*(L"newline\*(R" constants is provided: tha constants
\&\f(CW\*(C`CR\*(C'\fR, \f(CW\*(C`LF\*(C'\fR, n' \f(CW\*(C`CRLF\*(C'\fR, as well as \f(CW$CR\fR, \f(CW$LF\fR, n' \f(CW$CRLF\fR, which map
to \f(CW\*(C`\e015\*(C'\fR, \f(CW\*(C`\e012\*(C'\fR, n' \f(CW\*(C`\e015\e012\*(C'\fR. If you do not wanna use tha literal
charactas up in yo' programs, then use tha constants provided here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. They are
not exported by default yo, but can be imported individually, n' wit the
\&\f(CW\*(C`:crlf\*(C'\fR export tag:
.PP
.Vb 1
\& use Socket qw(:DEFAULT :crlf);
\&
\& $sock\->print("GET / HTTP/1.0$CRLF");
.Ve
.PP
Da entire \fIgetaddrinfo()\fR subsystem can be exported rockin tha tag \f(CW\*(C`:addrinfo\*(C'\fR;
this exports tha \fIgetaddrinfo()\fR n' \fIgetnameinfo()\fR functions, n' all the
\&\f(CW\*(C`AI_*\*(C'\fR, \f(CW\*(C`NI_*\*(C'\fR, \f(CW\*(C`NIx_*\*(C'\fR n' \f(CW\*(C`EAI_*\*(C'\fR constants.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
In each of tha followin groups, there may be nuff mo' constants provided
than just tha ones given as examplez up in tha section heading. If tha heading
endz \f(CW\*(C`...\*(C'\fR then dis means there be likely more; tha exact constants
provided will depend on tha \s-1OS\s0 n' headaz found at compile-time.
.SS "\s-1PF_INET, PF_INET6, PF_UNIX, ...\s0"
.IX Subsection "PF_INET, PF_INET6, PF_UNIX, ..."
Protocol crew constants ta use as tha straight-up original gangsta argument ta \fIsocket()\fR or the
value of tha \f(CW\*(C`SO_DOMAIN\*(C'\fR or \f(CW\*(C`SO_FAMILY\*(C'\fR socket option.
.SS "\s-1AF_INET, AF_INET6, AF_UNIX, ...\s0"
.IX Subsection "AF_INET, AF_INET6, AF_UNIX, ..."
Address crew constants used by tha socket address structures, ta pass to
such functions as \fIinet_pton()\fR or \fIgetaddrinfo()\fR, or is returned by such
functions as \fIsockaddr_family()\fR.
.SS "\s-1SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, ...\s0"
.IX Subsection "SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, ..."
Socket type constants ta use as tha second argument ta \fIsocket()\fR, or tha value
of tha \f(CW\*(C`SO_TYPE\*(C'\fR socket option.
.SS "\s-1SOCK_NONBLOCK. Right back up in yo muthafuckin ass. SOCK_CLOEXEC\s0"
.IX Subsection "SOCK_NONBLOCK. Right back up in yo muthafuckin ass. SOCK_CLOEXEC"
Linux-specific shortcuts ta specify tha \f(CW\*(C`O_NONBLOCK\*(C'\fR n' \f(CW\*(C`FD_CLOEXEC\*(C'\fR flags
durin a \f(CWsocket(2)\fR call.
.PP
.Vb 1
\& socket( mah $sockh, PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, 0 )
.Ve
.SS "\s-1SOL_SOCKET\s0"
.IX Subsection "SOL_SOCKET"
Socket option level constant fo' \fIsetsockopt()\fR n' \fIgetsockopt()\fR.
.SS "\s-1SO_ACCEPTCONN, SO_BROADCAST, SO_ERROR, ...\s0"
.IX Subsection "SO_ACCEPTCONN, SO_BROADCAST, SO_ERROR, ..."
Socket option name constants fo' \fIsetsockopt()\fR n' \fIgetsockopt()\fR at the
\&\f(CW\*(C`SOL_SOCKET\*(C'\fR level.
.SS "\s-1IP_OPTIONS, IP_TOS, IP_TTL, ...\s0"
.IX Subsection "IP_OPTIONS, IP_TOS, IP_TTL, ..."
Socket option name constants fo' IPv4 socket options all up in tha \f(CW\*(C`IPPROTO_IP\*(C'\fR
level.
.SS "\s-1IPTOS_LOWDELAY, IPTOS_THROUGHPUT, IPTOS_RELIABILITY, ...\s0"
.IX Subsection "IPTOS_LOWDELAY, IPTOS_THROUGHPUT, IPTOS_RELIABILITY, ..."
Socket option value constants fo' \f(CW\*(C`IP_TOS\*(C'\fR socket option.
.SS "\s-1MSG_BCAST, MSG_OOB, MSG_TRUNC, ...\s0"
.IX Subsection "MSG_BCAST, MSG_OOB, MSG_TRUNC, ..."
Message flag constants fo' \fIsend()\fR n' \fIrecv()\fR.
.SS "\s-1SHUT_RD, SHUT_RDWR, SHUT_WR\s0"
.IX Subsection "SHUT_RD, SHUT_RDWR, SHUT_WR"
Direction constants fo' \fIshutdown()\fR.
.SS "\s-1INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE\s0"
.IX Subsection "INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE"
Constants givin tha special \f(CW\*(C`AF_INET\*(C'\fR addresses fo' wildcard, broadcast,
local loopback, n' invalid addresses.
.PP
Normally equivalent ta inet_aton('0.0.0.0'), inet_aton('255.255.255.255'),
inet_aton('localhost') n' inet_aton('255.255.255.255') respectively.
.SS "\s-1IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...\s0"
.IX Subsection "IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ..."
\&\s-1IP\s0 protocol constants ta use as tha third argument ta \fIsocket()\fR, tha level
argument ta \fIgetsockopt()\fR or \fIsetsockopt()\fR, or tha value of tha \f(CW\*(C`SO_PROTOCOL\*(C'\fR
socket option.
.SS "\s-1TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...\s0"
.IX Subsection "TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ..."
Socket option name constants fo' \s-1TCP\s0 socket options all up in tha \f(CW\*(C`IPPROTO_TCP\*(C'\fR
level.
.SS "\s-1IN6ADDR_ANY, IN6ADDR_LOOPBACK\s0"
.IX Subsection "IN6ADDR_ANY, IN6ADDR_LOOPBACK"
Constants givin tha special \f(CW\*(C`AF_INET6\*(C'\fR addresses fo' wildcard n' local
loopback.
.PP
Normally equivalent ta inet_pton(\s-1AF_INET6, \*(L"::\*(R"\s0) and
inet_pton(\s-1AF_INET6, \*(L"::1\*(R"\s0) respectively.
.SS "\s-1IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...\s0"
.IX Subsection "IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ..."
Socket option name constants fo' IPv6 socket options all up in tha \f(CW\*(C`IPPROTO_IPV6\*(C'\fR
level.
.SH "STRUCTURE MANIPULATORS"
.IX Header "STRUCTURE MANIPULATORS"
Da followin functions convert between listz of Perl joints n' packed binary
strings representin structures.
.ie n .SS "$family = sockaddr_family $sockaddr"
.el .SS "\f(CW$family\fP = sockaddr_family \f(CW$sockaddr\fP"
.IX Subsection "$family = sockaddr_family $sockaddr"
Takes a packed socket address (as returned by \fIpack_sockaddr_in()\fR,
\&\fIpack_sockaddr_un()\fR or tha perl builtin functions \fIgetsockname()\fR and
\&\fIgetpeername()\fR). Returns tha address crew tag. This is ghon be one of the
\&\f(CW\*(C`AF_*\*(C'\fR constants, like fuckin \f(CW\*(C`AF_INET\*(C'\fR fo' a \f(CW\*(C`sockaddr_in\*(C'\fR addresses or
\&\f(CW\*(C`AF_UNIX\*(C'\fR fo' a \f(CW\*(C`sockaddr_un\*(C'\fR. Well shiiiit, it can be used ta figure up what tha fuck unpack to
use fo' a sockaddr of unknown type.
.ie n .SS "$sockaddr = pack_sockaddr_in $port, $ip_address"
.el .SS "\f(CW$sockaddr\fP = pack_sockaddr_in \f(CW$port\fP, \f(CW$ip_address\fP"
.IX Subsection "$sockaddr = pack_sockaddr_in $port, $ip_address"
Takes two arguments, a port number n' a opaque strang (as returned by
\&\fIinet_aton()\fR, or a v\-string). Returns tha \f(CW\*(C`sockaddr_in\*(C'\fR structure wit them
arguments packed up in n' \f(CW\*(C`AF_INET\*(C'\fR filled in. I aint talkin' bout chicken n' gravy biatch. For Internizzle domain sockets,
this structure is normally what tha fuck you need fo' tha arguments up in \fIbind()\fR,
\&\fIconnect()\fR, n' \fIsend()\fR.
.ie n .SS "($port, $ip_address) = unpack_sockaddr_in $sockaddr"
.el .SS "($port, \f(CW$ip_address\fP) = unpack_sockaddr_in \f(CW$sockaddr\fP"
.IX Subsection "($port, $ip_address) = unpack_sockaddr_in $sockaddr"
Takes a \f(CW\*(C`sockaddr_in\*(C'\fR structure (as returned by \fIpack_sockaddr_in()\fR,
\&\fIgetpeername()\fR or \fIrecv()\fR). Returns a list of two elements: tha port n' an
opaque strang representin tha \s-1IP\s0 address (you can use \fIinet_ntoa()\fR ta convert
the address ta tha four-dotted numeric format). Will croak if tha structure
does not represent a \f(CW\*(C`AF_INET\*(C'\fR address.
.PP
In scalar context will return just tha \s-1IP\s0 address.
.ie n .SS "$sockaddr = sockaddr_in $port, $ip_address"
.el .SS "\f(CW$sockaddr\fP = sockaddr_in \f(CW$port\fP, \f(CW$ip_address\fP"
.IX Subsection "$sockaddr = sockaddr_in $port, $ip_address"
.ie n .SS "($port, $ip_address) = sockaddr_in $sockaddr"
.el .SS "($port, \f(CW$ip_address\fP) = sockaddr_in \f(CW$sockaddr\fP"
.IX Subsection "($port, $ip_address) = sockaddr_in $sockaddr"
A wrapper of \fIpack_sockaddr_in()\fR or \fIunpack_sockaddr_in()\fR. In list context,
unpacks its argument n' returns a list consistin of tha port n' \s-1IP\s0 address.
In scalar context, packs its port n' \s-1IP\s0 address arguments as a \f(CW\*(C`sockaddr_in\*(C'\fR
and returns dat shit.
.PP
Provided largely fo' legacy compatibility; it is betta ta use
\&\fIpack_sockaddr_in()\fR or \fIunpack_sockaddr_in()\fR explicitly.
.ie n .SS "$sockaddr = pack_sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]"
.el .SS "\f(CW$sockaddr\fP = pack_sockaddr_in6 \f(CW$port\fP, \f(CW$ip6_address\fP, [$scope_id, [$flowinfo]]"
.IX Subsection "$sockaddr = pack_sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]"
Takes two ta four arguments, a port number, a opaque strang (as returned by
\&\fIinet_pton()\fR), optionally a scope \s-1ID\s0 number, n' optionally a gangbangin' flow label
number n' shit. Returns tha \f(CW\*(C`sockaddr_in6\*(C'\fR structure wit dem arguments packed in
and \f(CW\*(C`AF_INET6\*(C'\fR filled in. I aint talkin' bout chicken n' gravy biatch. IPv6 equivalent of \fIpack_sockaddr_in()\fR.
.ie n .SS "($port, $ip6_address, $scope_id, $flowinfo) = unpack_sockaddr_in6 $sockaddr"
.el .SS "($port, \f(CW$ip6_address\fP, \f(CW$scope_id\fP, \f(CW$flowinfo\fP) = unpack_sockaddr_in6 \f(CW$sockaddr\fP"
.IX Subsection "($port, $ip6_address, $scope_id, $flowinfo) = unpack_sockaddr_in6 $sockaddr"
Takes a \f(CW\*(C`sockaddr_in6\*(C'\fR structure. Returns a list of four elements: tha port
number, a opaque strang representin tha IPv6 address, tha scope \s-1ID,\s0 n' the
flow label. (Yo ass can use \fIinet_ntop()\fR ta convert tha address ta tha usual
strin format). Will croak if tha structure do not represent a \f(CW\*(C`AF_INET6\*(C'\fR
address.
.PP
In scalar context will return just tha \s-1IP\s0 address.
.ie n .SS "$sockaddr = sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]"
.el .SS "\f(CW$sockaddr\fP = sockaddr_in6 \f(CW$port\fP, \f(CW$ip6_address\fP, [$scope_id, [$flowinfo]]"
.IX Subsection "$sockaddr = sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]"
.ie n .SS "($port, $ip6_address, $scope_id, $flowinfo) = sockaddr_in6 $sockaddr"
.el .SS "($port, \f(CW$ip6_address\fP, \f(CW$scope_id\fP, \f(CW$flowinfo\fP) = sockaddr_in6 \f(CW$sockaddr\fP"
.IX Subsection "($port, $ip6_address, $scope_id, $flowinfo) = sockaddr_in6 $sockaddr"
A wrapper of \fIpack_sockaddr_in6()\fR or \fIunpack_sockaddr_in6()\fR. In list context,
unpacks its argument accordin ta \fIunpack_sockaddr_in6()\fR. In scalar context,
packs its arguments accordin ta \fIpack_sockaddr_in6()\fR.
.PP
Provided largely fo' legacy compatibility; it is betta ta use
\&\fIpack_sockaddr_in6()\fR or \fIunpack_sockaddr_in6()\fR explicitly.
.ie n .SS "$sockaddr = pack_sockaddr_un $path"
.el .SS "\f(CW$sockaddr\fP = pack_sockaddr_un \f(CW$path\fP"
.IX Subsection "$sockaddr = pack_sockaddr_un $path"
Takes one argument, a pathname. Returns tha \f(CW\*(C`sockaddr_un\*(C'\fR structure wit that
path packed up in wit \f(CW\*(C`AF_UNIX\*(C'\fR filled in. I aint talkin' bout chicken n' gravy biatch. For \f(CW\*(C`PF_UNIX\*(C'\fR sockets, this
structure is normally what tha fuck you need fo' tha arguments up in \fIbind()\fR, \fIconnect()\fR,
and \fIsend()\fR.
.ie n .SS "($path) = unpack_sockaddr_un $sockaddr"
.el .SS "($path) = unpack_sockaddr_un \f(CW$sockaddr\fP"
.IX Subsection "($path) = unpack_sockaddr_un $sockaddr"
Takes a \f(CW\*(C`sockaddr_un\*(C'\fR structure (as returned by \fIpack_sockaddr_un()\fR,
\&\fIgetpeername()\fR or \fIrecv()\fR). Returns a list of one element: tha pathname. Will
croak if tha structure do not represent a \f(CW\*(C`AF_UNIX\*(C'\fR address.
.ie n .SS "$sockaddr = sockaddr_un $path"
.el .SS "\f(CW$sockaddr\fP = sockaddr_un \f(CW$path\fP"
.IX Subsection "$sockaddr = sockaddr_un $path"
.ie n .SS "($path) = sockaddr_un $sockaddr"
.el .SS "($path) = sockaddr_un \f(CW$sockaddr\fP"
.IX Subsection "($path) = sockaddr_un $sockaddr"
A wrapper of \fIpack_sockaddr_un()\fR or \fIunpack_sockaddr_un()\fR. In a list context,
unpacks its argument n' returns a list consistin of tha pathname. In a
scalar context, packs its pathname as a \f(CW\*(C`sockaddr_un\*(C'\fR n' returns dat shit.
.PP
Provided largely fo' legacy compatibility; it is betta ta use
\&\fIpack_sockaddr_un()\fR or \fIunpack_sockaddr_un()\fR explicitly.
.PP
These is only supported if yo' system has <\fIsys/un.h\fR>.
.ie n .SS "$ip_mreq = pack_ip_mreq $multiaddr, $interface"
.el .SS "\f(CW$ip_mreq\fP = pack_ip_mreq \f(CW$multiaddr\fP, \f(CW$interface\fP"
.IX Subsection "$ip_mreq = pack_ip_mreq $multiaddr, $interface"
Takes a IPv4 multicast address n' optionally a intercourse address (or
\&\f(CW\*(C`INADDR_ANY\*(C'\fR). Returns tha \f(CW\*(C`ip_mreq\*(C'\fR structure wit dem arguments packed
in. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Suitable fo' use wit tha \f(CW\*(C`IP_ADD_MEMBERSHIP\*(C'\fR n' \f(CW\*(C`IP_DROP_MEMBERSHIP\*(C'\fR
sockopts.
.ie n .SS "($multiaddr, $interface) = unpack_ip_mreq $ip_mreq"
.el .SS "($multiaddr, \f(CW$interface\fP) = unpack_ip_mreq \f(CW$ip_mreq\fP"
.IX Subsection "($multiaddr, $interface) = unpack_ip_mreq $ip_mreq"
Takes a \f(CW\*(C`ip_mreq\*(C'\fR structure. Returns a list of two elements; tha IPv4
multicast address n' intercourse address.
.ie n .SS "$ip_mreq_source = pack_ip_mreq_source $multiaddr, $source, $interface"
.el .SS "\f(CW$ip_mreq_source\fP = pack_ip_mreq_source \f(CW$multiaddr\fP, \f(CW$source\fP, \f(CW$interface\fP"
.IX Subsection "$ip_mreq_source = pack_ip_mreq_source $multiaddr, $source, $interface"
Takes a IPv4 multicast address, source address, n' optionally a intercourse
address (or \f(CW\*(C`INADDR_ANY\*(C'\fR). Returns tha \f(CW\*(C`ip_mreq_source\*(C'\fR structure wit them
arguments packed in. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Suitable fo' use wit tha \f(CW\*(C`IP_ADD_SOURCE_MEMBERSHIP\*(C'\fR
and \f(CW\*(C`IP_DROP_SOURCE_MEMBERSHIP\*(C'\fR sockopts.
.ie n .SS "($multiaddr, $source, $interface) = unpack_ip_mreq_source $ip_mreq"
.el .SS "($multiaddr, \f(CW$source\fP, \f(CW$interface\fP) = unpack_ip_mreq_source \f(CW$ip_mreq\fP"
.IX Subsection "($multiaddr, $source, $interface) = unpack_ip_mreq_source $ip_mreq"
Takes a \f(CW\*(C`ip_mreq_source\*(C'\fR structure. Returns a list of three elements; the
IPv4 multicast address, source address n' intercourse address.
.ie n .SS "$ipv6_mreq = pack_ipv6_mreq $multiaddr6, $ifindex"
.el .SS "\f(CW$ipv6_mreq\fP = pack_ipv6_mreq \f(CW$multiaddr6\fP, \f(CW$ifindex\fP"
.IX Subsection "$ipv6_mreq = pack_ipv6_mreq $multiaddr6, $ifindex"
Takes a IPv6 multicast address n' a intercourse number n' shit. Returns the
\&\f(CW\*(C`ipv6_mreq\*(C'\fR structure wit dem arguments packed in. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Suitable fo' use with
the \f(CW\*(C`IPV6_ADD_MEMBERSHIP\*(C'\fR n' \f(CW\*(C`IPV6_DROP_MEMBERSHIP\*(C'\fR sockopts.
.ie n .SS "($multiaddr6, $ifindex) = unpack_ipv6_mreq $ipv6_mreq"
.el .SS "($multiaddr6, \f(CW$ifindex\fP) = unpack_ipv6_mreq \f(CW$ipv6_mreq\fP"
.IX Subsection "($multiaddr6, $ifindex) = unpack_ipv6_mreq $ipv6_mreq"
Takes a \f(CW\*(C`ipv6_mreq\*(C'\fR structure. Returns a list of two elements; tha IPv6
address n' a intercourse number.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .SS "$ip_address = inet_aton $string"
.el .SS "\f(CW$ip_address\fP = inet_aton \f(CW$string\fP"
.IX Subsection "$ip_address = inet_aton $string"
Takes a strang givin tha name of a host, or a textual representation of a \s-1IP\s0
address n' translates dat ta a packed binary address structure suitable to
pass ta \fIpack_sockaddr_in()\fR. If passed a hostname dat cannot be resolved,
returns \f(CW\*(C`undef\*(C'\fR. For multi-homed hosts (hosts wit mo' than one address),
the first address found is returned.
.PP
For portabilitizzle do not assume dat tha result of \fIinet_aton()\fR is 32 bits wide,
in other lyrics, dat it would contain only tha IPv4 address up in network order.
.PP
This IPv4\-only function is provided largely fo' legacy reasons. Newly-written
code should use \fIgetaddrinfo()\fR or \fIinet_pton()\fR instead fo' IPv6 support.
.ie n .SS "$strin = inet_ntoa $ip_address"
.el .SS "\f(CW$string\fP = inet_ntoa \f(CW$ip_address\fP"
.IX Subsection "$strin = inet_ntoa $ip_address"
Takes a packed binary address structure like fuckin returned by
\&\fIunpack_sockaddr_in()\fR (or a v\-strin representin tha four octetz of tha IPv4
address up in network order) n' translates it tha fuck into a strang of tha form
\&\f(CW\*(C`d.d.d.d\*(C'\fR where tha \f(CW\*(C`d\*(C'\fRs is numbers less than 256 (the normal
human-readable four dotted number notation fo' Internizzle addresses).
.PP
This IPv4\-only function is provided largely fo' legacy reasons. Newly-written
code should use \fIgetnameinfo()\fR or \fIinet_ntop()\fR instead fo' IPv6 support.
.ie n .SS "$address = inet_pton $family, $string"
.el .SS "\f(CW$address\fP = inet_pton \f(CW$family\fP, \f(CW$string\fP"
.IX Subsection "$address = inet_pton $family, $string"
Takes a address crew (like fuckin \f(CW\*(C`AF_INET\*(C'\fR or \f(CW\*(C`AF_INET6\*(C'\fR) n' a string
containin a textual representation of a address up in dat crew and
translates dat ta a packed binary address structure.
.PP
See also \fIgetaddrinfo()\fR fo' a mo' bangin n' flexible function ta look up
socket addresses given hostnames or textual addresses.
.ie n .SS "$strin = inet_ntop $family, $address"
.el .SS "\f(CW$string\fP = inet_ntop \f(CW$family\fP, \f(CW$address\fP"
.IX Subsection "$strin = inet_ntop $family, $address"
Takes a address crew n' a packed binary address structure n' translates
it tha fuck into a human-readable textual representation of tha address; typically in
\&\f(CW\*(C`d.d.d.d\*(C'\fR form fo' \f(CW\*(C`AF_INET\*(C'\fR or \f(CW\*(C`hhhh:hhhh::hhhh\*(C'\fR form fo' \f(CW\*(C`AF_INET6\*(C'\fR.
.PP
See also \fIgetnameinfo()\fR fo' a mo' bangin n' flexible function ta turn
socket addresses tha fuck into human-readable textual representations.
.ie n .SS "($err, @result) = getaddrinfo $host, $service, [$hints]"
.el .SS "($err, \f(CW@result\fP) = getaddrinfo \f(CW$host\fP, \f(CW$service\fP, [$hints]"
.IX Subsection "($err, @result) = getaddrinfo $host, $service, [$hints]"
Given both a hostname n' steez name, dis function attempts ta resolve the
host name tha fuck into a list of network addresses, n' tha steez name tha fuck into a
protocol n' port number, n' then returns a list of address structures
suitable ta \fIconnect()\fR ta dat shit.
.PP
Given just a host name, dis function attempts ta resolve it ta a list of
network addresses, n' then returns a list of address structures givin these
addresses.
.PP
Given just a steez name, dis function attempts ta resolve it ta a protocol
and port number, n' then returns a list of address structures dat represent
it suitable ta \fIbind()\fR to. This use should be combined wit tha \f(CW\*(C`AI_PASSIVE\*(C'\fR
flag; peep below.
.PP
Given neither name, it generates a error.
.PP
If present, \f(CW$hints\fR should be a reference ta a hash, where tha followin keys
are recognised:
.IP "flags => \s-1INT\s0" 4
.IX Item "flags => INT"
A bitfield containin \f(CW\*(C`AI_*\*(C'\fR constants; peep below.
.IP "family => \s-1INT\s0" 4
.IX Item "family => INT"
Restrict ta only generatin addresses up in dis address crew
.IP "socktype => \s-1INT\s0" 4
.IX Item "socktype => INT"
Restrict ta only generatin addressez of dis socket type
.IP "protocol => \s-1INT\s0" 4
.IX Item "protocol => INT"
Restrict ta only generatin addresses fo' dis protocol
.PP
Da return value is ghon be a list; tha straight-up original gangsta value bein a error indication,
followed by a list of address structures (if no error occurred).
.PP
Da error value is ghon be a thugged-out dualvar; comparable ta tha \f(CW\*(C`EI_*\*(C'\fR error constants,
or printable as a human-readable error message string. If no error occurred it
will be zero numerically n' a empty string.
.PP
Each value up in tha thangs up in dis biatch list is ghon be a hash reference containin tha following
fields:
.IP "family => \s-1INT\s0" 4
.IX Item "family => INT"
Da address crew (e.g. \f(CW\*(C`AF_INET\*(C'\fR)
.IP "socktype => \s-1INT\s0" 4
.IX Item "socktype => INT"
Da socket type (e.g. \f(CW\*(C`SOCK_STREAM\*(C'\fR)
.IP "protocol => \s-1INT\s0" 4
.IX Item "protocol => INT"
Da protocol (e.g. \f(CW\*(C`IPPROTO_TCP\*(C'\fR)
.IP "addr => \s-1STRING\s0" 4
.IX Item "addr => STRING"
Da address up in a packed strang (like fuckin would be returned by
\&\fIpack_sockaddr_in()\fR)
.IP "canonname => \s-1STRING\s0" 4
.IX Item "canonname => STRING"
Da canonical name fo' tha host if tha \f(CW\*(C`AI_CANONNAME\*(C'\fR flag was provided, or
\&\f(CW\*(C`undef\*(C'\fR otherwise. This field will only be present on tha straight-up original gangsta returned
address.
.PP
Da followin flag constants is recognised up in tha \f(CW$hints\fR hash. Other flag
constants may exist as provided by tha \s-1OS.\s0
.IP "\s-1AI_PASSIVE\s0" 4
.IX Item "AI_PASSIVE"
Indicates dat dis resolution is fo' a local \fIbind()\fR fo' a passive (i.e.
listening) socket, rather than a actizzle (i.e. connecting) socket.
.IP "\s-1AI_CANONNAME\s0" 4
.IX Item "AI_CANONNAME"
Indicates dat tha calla wishes tha canonical hostname (\f(CW\*(C`canonname\*(C'\fR) field
of tha result ta be filled in.
.IP "\s-1AI_NUMERICHOST\s0" 4
.IX Item "AI_NUMERICHOST"
Indicates dat tha calla will pass a numeric address, rather than a hostname,
and dat \fIgetaddrinfo()\fR must not big-ass up a resolve operation on dis name. This
flag will prevent a possibly-slow network lookup operation, n' instead return
an error if a hostname is passed.
.ie n .SS "($err, $hostname, $servicename) = getnameinfo $sockaddr, [$flags, [$xflags]]"
.el .SS "($err, \f(CW$hostname\fP, \f(CW$servicename\fP) = getnameinfo \f(CW$sockaddr\fP, [$flags, [$xflags]]"
.IX Subsection "($err, $hostname, $servicename) = getnameinfo $sockaddr, [$flags, [$xflags]]"
Given a packed socket address (like fuckin from \fIgetsockname()\fR, \fIgetpeername()\fR, or
returned by \fIgetaddrinfo()\fR up in a \f(CW\*(C`addr\*(C'\fR field), returns tha hostname and
symbolic steez name it represents, n' you can put dat on yo' toast. \f(CW$flags\fR may be a funky-ass bitmask of \f(CW\*(C`NI_*\*(C'\fR
constants, or defaults ta 0 if unspecified.
.PP
Da return value is ghon be a list; tha straight-up original gangsta value bein a error condition,
followed by tha hostname n' steez name.
.PP
Da error value is ghon be a thugged-out dualvar; comparable ta tha \f(CW\*(C`EI_*\*(C'\fR error constants,
or printable as a human-readable error message string. Da host n' service
names is ghon be plain strings.
.PP
Da followin flag constants is recognised as \f(CW$flags\fR. Other flag constants may
exist as provided by tha \s-1OS.\s0
.IP "\s-1NI_NUMERICHOST\s0" 4
.IX Item "NI_NUMERICHOST"
Requests dat a human-readable strang representation of tha numeric address be
returned directly, rather than struttin a name resolve operation dat may
convert it tha fuck into a hostname. This will also avoid potentially-blockin network
\&\s-1IO.\s0
.IP "\s-1NI_NUMERICSERV\s0" 4
.IX Item "NI_NUMERICSERV"
Requests dat tha port number be returned directly as a number representation
rather than struttin a name resolve operation dat may convert it tha fuck into a
service name.
.IP "\s-1NI_NAMEREQD\s0" 4
.IX Item "NI_NAMEREQD"
If a name resolve operation fails ta provide a name, then dis flag will cause
\&\fIgetnameinfo()\fR ta indicate a error, rather than returnin tha numeric
representation as a human-readable string.
.IP "\s-1NI_DGRAM\s0" 4
.IX Item "NI_DGRAM"
Indicates dat tha socket address relates ta a \f(CW\*(C`SOCK_DGRAM\*(C'\fR socket, fo' the
skillz whose name differs between \s-1TCP\s0 n' \s-1UDP\s0 protocols.
.PP
Da followin constants may be supplied as \f(CW$xflags\fR.
.IP "NIx_NOHOST" 4
.IX Item "NIx_NOHOST"
Indicates dat tha calla aint horny bout tha hostname of tha result, so
it do not gotta be converted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. \f(CW\*(C`undef\*(C'\fR is ghon be returned as tha hostname.
.IP "NIx_NOSERV" 4
.IX Item "NIx_NOSERV"
Indicates dat tha calla aint horny bout tha steez name of tha result,
so it do not gotta be converted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. \f(CW\*(C`undef\*(C'\fR is ghon be returned as tha service
name.
.SH "\fIgetaddrinfo()\fP / \fIgetnameinfo()\fP ERROR CONSTANTS"
.IX Header "getaddrinfo() / getnameinfo() ERROR CONSTANTS"
Da followin constants may be returned by \fIgetaddrinfo()\fR or \fIgetnameinfo()\fR.
Others may be provided by tha \s-1OS.\s0
.IP "\s-1EAI_AGAIN\s0" 4
.IX Item "EAI_AGAIN"
A temporary failure occurred durin name resolution. I aint talkin' bout chicken n' gravy biatch. Da operation may be
successful if it is retried later.
.IP "\s-1EAI_BADFLAGS\s0" 4
.IX Item "EAI_BADFLAGS"
Da value of tha \f(CW\*(C`flags\*(C'\fR hint ta \fIgetaddrinfo()\fR, or tha \f(CW$flags\fR parameta to
\&\fIgetnameinfo()\fR gotz nuff unrecognised flags.
.IP "\s-1EAI_FAMILY\s0" 4
.IX Item "EAI_FAMILY"
Da \f(CW\*(C`family\*(C'\fR hint ta \fIgetaddrinfo()\fR, or tha crew of tha socket address
passed ta \fIgetnameinfo()\fR aint supported.
.IP "\s-1EAI_NODATA\s0" 4
.IX Item "EAI_NODATA"
Da host name supplied ta \fIgetaddrinfo()\fR did not provide any usable address
data.
.IP "\s-1EAI_NONAME\s0" 4
.IX Item "EAI_NONAME"
Da host name supplied ta \fIgetaddrinfo()\fR do not exist, or tha address
supplied ta \fIgetnameinfo()\fR aint associated wit a host name n' the
\&\f(CW\*(C`NI_NAMEREQD\*(C'\fR flag was supplied.
.IP "\s-1EAI_SERVICE\s0" 4
.IX Item "EAI_SERVICE"
Da steez name supplied ta \fIgetaddrinfo()\fR aint available fo' tha socket
type given up in tha \f(CW$hints\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Lookup fo' \fIconnect()\fP"
.IX Subsection "Lookup fo' connect()"
Da \fIgetaddrinfo()\fR function converts a hostname n' a steez name tha fuck into a list
of structures, each containin a potential way ta \fIconnect()\fR ta tha named
service on tha named host.
.PP
.Vb 2
\& use IO::Socket;
\& use Socket qw(SOCK_STREAM getaddrinfo);
\&
\& mah %hints = (socktype => SOCK_STREAM);
\& mah ($err, @res) = getaddrinfo("localhost", "echo", \e%hints);
\& take a thugged-out dirtnap "Cannot getaddrinfo \- $err" if $err;
\&
\& mah $sock;
\&
\& foreach mah $ai (@res) {
\&     mah $candidate = IO::Socket\->new();
\&
\&     $candidate\->socket($ai\->{family}, $ai\->{socktype}, $ai\->{protocol})
\&         or next;
\&
\&     $candidate\->connect($ai\->{addr})
\&         or next;
\&
\&     $sock = $candidate;
\&     last;
\& }
\&
\& take a thugged-out dirtnap "Cannot connect ta localhost:echo" unless $sock;
\&
\& $sock\->print("Yo muthafucka, ghetto!\en");
\& print <$sock>;
.Ve
.PP
Because a list of potential muthafuckas is returned, tha \f(CW\*(C`while\*(C'\fR loop tries
each up in turn until it findz one dat succeedz both tha \fIsocket()\fR n' \fIconnect()\fR
calls.
.PP
This function performs tha work of tha legacy functions \fIgethostbyname()\fR,
\&\fIgetservbyname()\fR, \fIinet_aton()\fR n' \fIpack_sockaddr_in()\fR.
.PP
In practice dis logic is betta performed by IO::Socket::IP.
.SS "Makin a human-readable strang outta a address"
.IX Subsection "Makin a human-readable strang outta a address"
Da \fIgetnameinfo()\fR function converts a socket address, like fuckin returned by
\&\fIgetsockname()\fR or \fIgetpeername()\fR, tha fuck into a pair of human-readable strings
representin tha address n' steez name.
.PP
.Vb 2
\& use IO::Socket::IP;
\& use Socket qw(getnameinfo);
\&
\& mah $server = IO::Socket::IP\->new(LocalPort => 12345, Listen => 1) or
\&     take a thugged-out dirtnap "Cannot listen \- $@";
\&
\& mah $socket = $server\->accept or take a thugged-out dirtnap "accept: $!";
\&
\& mah ($err, $hostname, $servicename) = getnameinfo($socket\->peername);
\& take a thugged-out dirtnap "Cannot getnameinfo \- $err" if $err;
\&
\& print "Da peer is connected from $hostname\en";
.Ve
.PP
Since up in dis example only tha hostname was used, tha redundant conversion of
the port number tha fuck into a steez name may be omitted by passin the
\&\f(CW\*(C`NIx_NOSERV\*(C'\fR flag.
.PP
.Vb 1
\& use Socket qw(getnameinfo NIx_NOSERV);
\&
\& mah ($err, $hostname) = getnameinfo($socket\->peername, 0, NIx_NOSERV);
.Ve
.PP
This function performs tha work of tha legacy functions \fIunpack_sockaddr_in()\fR,
\&\fIinet_ntoa()\fR, \fIgethostbyaddr()\fR n' \fIgetservbyport()\fR.
.PP
In practice dis logic is betta performed by IO::Socket::IP.
.SS "Resolvin hostnames tha fuck into \s-1IP\s0 addresses"
.IX Subsection "Resolvin hostnames tha fuck into IP addresses"
To turn a hostname tha fuck into a human-readable plain \s-1IP\s0 address use \fIgetaddrinfo()\fR
to turn tha hostname tha fuck into a list of socket structures, then \fIgetnameinfo()\fR on
each one ta make it a readable \s-1IP\s0 address again.
.PP
.Vb 1
\& use Socket qw(:addrinfo SOCK_RAW);
\&
\& mah ($err, @res) = getaddrinfo($hostname, "", {socktype => SOCK_RAW});
\& take a thugged-out dirtnap "Cannot getaddrinfo \- $err" if $err;
\&
\& while( mah $ai = shift @res ) {
\&     mah ($err, $ipaddr) = getnameinfo($ai\->{addr}, NI_NUMERICHOST, NIx_NOSERV);
\&     take a thugged-out dirtnap "Cannot getnameinfo \- $err" if $err;
\&
\&     print "$ipaddr\en";
\& }
.Ve
.PP
Da \f(CW\*(C`socktype\*(C'\fR hint ta \fIgetaddrinfo()\fR filtas tha thangs up in dis biatch ta only include one
socket type n' protocol. Without dis most OSes return three combinations,
for \f(CW\*(C`SOCK_STREAM\*(C'\fR, \f(CW\*(C`SOCK_DGRAM\*(C'\fR n' \f(CW\*(C`SOCK_RAW\*(C'\fR, resultin up in triplicate
output of addresses. Da \f(CW\*(C`NI_NUMERICHOST\*(C'\fR flag ta \fIgetnameinfo()\fR causes it to
return a string-formatted plain \s-1IP\s0 address, rather than reverse resolvin it
back tha fuck into a hostname.
.PP
This combination performs tha work of tha legacy functions \fIgethostbyname()\fR
and \fIinet_ntoa()\fR.
.SS "Accessin socket options"
.IX Subsection "Accessin socket options"
Da nuff \f(CW\*(C`SO_*\*(C'\fR n' other constants provide tha socket option names for
\&\fIgetsockopt()\fR n' \fIsetsockopt()\fR.
.PP
.Vb 2
\& use IO::Socket::INET;
\& use Socket qw(SOL_SOCKET SO_RCVBUF IPPROTO_IP IP_TTL);
\&
\& mah $socket = IO::Socket::INET\->new(LocalPort => 0, Proto => \*(Aqudp\*(Aq)
\&     or take a thugged-out dirtnap "Cannot create socket: $@";
\&
\& $socket\->setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024) or
\&     take a thugged-out dirtnap "setsockopt: $!";
\&
\& print "Receive buffer is ", $socket\->getsockopt(SOL_SOCKET, SO_RCVBUF),
\&     " bytes\en";
\&
\& print "IP TTL is ", $socket\->getsockopt(IPPROTO_IP, IP_TTL), "\en";
.Ve
.PP
As a cold-ass lil convenience, IO::Socketz \fIsetsockopt()\fR method will convert a number
into a packed byte buffer, n' \fIgetsockopt()\fR will unpack a funky-ass byte buffer of the
correct size back tha fuck into a number.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module was originally maintained up in Perl core by tha Perl 5 Porters.
.PP
Dat shiznit was extracted ta dual-life on \s-1CPAN\s0 at version 1.95 by
Pizzle Evans <leonerd@leonerd.org.uk>
