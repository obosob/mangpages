.TH PCRE 3 "12 May 2013" "PCRE 8.33"
.SH NAME
PCRE - Perl-compatible regular expressions
.sp
.B #include <pcre.h>
.
.
.SH "PCRE 16-BIT API BASIC FUNCTIONS"
.rs
.sp
.SM
.B pcre16 *pcre16_compile(PCRE_SPTR16 \fIpattern\fP, int \fIoptions\fP,
.ti +5n
.B const char **\fIerrptr\fP, int *\fIerroffset\fP,
.ti +5n
.B const unsigned char *\fItableptr\fP);
.PP
.B pcre16 *pcre16_compile2(PCRE_SPTR16 \fIpattern\fP, int \fIoptions\fP,
.ti +5n
.B int *\fIerrorcodeptr\fP,
.ti +5n
.B const char **\fIerrptr\fP, int *\fIerroffset\fP,
.ti +5n
.B const unsigned char *\fItableptr\fP);
.PP
.B pcre16_extra *pcre16_study(const pcre16 *\fIcode\fP, int \fIoptions\fP,
.ti +5n
.B const char **\fIerrptr\fP);
.PP
.B void pcre16_free_study(pcre16_extra *\fIextra\fP);
.PP
.B int pcre16_exec(const pcre16 *\fIcode\fP, "const pcre16_extra *\fIextra\fP,"
.ti +5n
.B "PCRE_SPTR16 \fIsubject\fP," int \fIlength\fP, int \fIstartoffset\fP,
.ti +5n
.B int \fIoptions\fP, int *\fIovector\fP, int \fIovecsize\fP);
.PP
.B int pcre16_dfa_exec(const pcre16 *\fIcode\fP, "const pcre16_extra *\fIextra\fP,"
.ti +5n
.B "PCRE_SPTR16 \fIsubject\fP," int \fIlength\fP, int \fIstartoffset\fP,
.ti +5n
.B int \fIoptions\fP, int *\fIovector\fP, int \fIovecsize\fP,
.ti +5n
.B int *\fIworkspace\fP, int \fIwscount\fP);
.
.
.SH "PCRE 16-BIT API STRING EXTRACTION FUNCTIONS"
.rs
.sp
.B int pcre16_copy_named_substring(const pcre16 *\fIcode\fP,
.ti +5n
.B PCRE_SPTR16 \fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, PCRE_SPTR16 \fIstringname\fP,
.ti +5n
.B PCRE_UCHAR16 *\fIbuffer\fP, int \fIbuffersize\fP);
.PP
.B int pcre16_copy_substring(PCRE_SPTR16 \fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, int \fIstringnumber\fP, PCRE_UCHAR16 *\fIbuffer\fP,
.ti +5n
.B int \fIbuffersize\fP);
.PP
.B int pcre16_get_named_substring(const pcre16 *\fIcode\fP,
.ti +5n
.B PCRE_SPTR16 \fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, PCRE_SPTR16 \fIstringname\fP,
.ti +5n
.B PCRE_SPTR16 *\fIstringptr\fP);
.PP
.B int pcre16_get_stringnumber(const pcre16 *\fIcode\fP,
.ti +5n
.B PCRE_SPTR16 \fIname\fP);
.PP
.B int pcre16_get_stringtable_entries(const pcre16 *\fIcode\fP,
.ti +5n
.B PCRE_SPTR16 \fIname\fP, PCRE_UCHAR16 **\fIfirst\fP, PCRE_UCHAR16 **\fIlast\fP);
.PP
.B int pcre16_get_substring(PCRE_SPTR16 \fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, int \fIstringnumber\fP,
.ti +5n
.B PCRE_SPTR16 *\fIstringptr\fP);
.PP
.B int pcre16_get_substring_list(PCRE_SPTR16 \fIsubject\fP,
.ti +5n
.B int *\fIovector\fP, int \fIstringcount\fP, "PCRE_SPTR16 **\fIlistptr\fP);"
.PP
.B void pcre16_free_substring(PCRE_SPTR16 \fIstringptr\fP);
.PP
.B void pcre16_free_substring_list(PCRE_SPTR16 *\fIstringptr\fP);
.
.
.SH "PCRE 16-BIT API AUXILIARY FUNCTIONS"
.rs
.sp
.B pcre16_jit_stack *pcre16_jit_stack_alloc(int \fIstartsize\fP, int \fImaxsize\fP);
.PP
.B void pcre16_jit_stack_free(pcre16_jit_stack *\fIstack\fP);
.PP
.B void pcre16_assign_jit_stack(pcre16_extra *\fIextra\fP,
.ti +5n
.B pcre16_jit_callback \fIcallback\fP, void *\fIdata\fP);
.PP
.B const unsigned char *pcre16_maketables(void);
.PP
.B int pcre16_fullinfo(const pcre16 *\fIcode\fP, "const pcre16_extra *\fIextra\fP,"
.ti +5n
.B int \fIwhat\fP, void *\fIwhere\fP);
.PP
.B int pcre16_refcount(pcre16 *\fIcode\fP, int \fIadjust\fP);
.PP
.B int pcre16_config(int \fIwhat\fP, void *\fIwhere\fP);
.PP
.B const char *pcre16_version(void);
.PP
.B int pcre16_pattern_to_host_byte_order(pcre16 *\fIcode\fP,
.ti +5n
.B pcre16_extra *\fIextra\fP, const unsigned char *\fItables\fP);
.
.
.SH "PCRE 16-BIT API INDIRECTED FUNCTIONS"
.rs
.sp
.B void *(*pcre16_malloc)(size_t);
.PP
.B void (*pcre16_free)(void *);
.PP
.B void *(*pcre16_stack_malloc)(size_t);
.PP
.B void (*pcre16_stack_free)(void *);
.PP
.B int (*pcre16_callout)(pcre16_callout_block *);
.
.
.SH "PCRE 16-BIT API 16-BIT-ONLY FUNCTION"
.rs
.sp
.B int pcre16_utf16_to_host_byte_order(PCRE_UCHAR16 *\fIoutput\fP,
.ti +5n
.B PCRE_SPTR16 \fIinput\fP, int \fIlength\fP, int *\fIbyte_order\fP,
.ti +5n
.B int \fIkeep_boms\fP);
.
.
.SH "THE PCRE 16-BIT LIBRARY"
.rs
.sp
Startin wit release 8.30, it is possible ta compile a PCRE library that
supports 16-bit characta strings, includin UTF-16 strings, as well as or
instead of tha original gangsta 8-bit library. Da majoritizzle of tha work ta make this
possible was done by Zoltan Herczeg. Da two libraries contain identical sets
of functions, used up in exactly tha same way. Only tha namez of tha functions and
the data typez of they arguments n' thangs up in dis biatch is different. To avoid
over-complication n' reduce tha documentation maintenizzle load, most of the
PCRE documentation raps bout tha 8-bit library, wit only occasionizzle references
to tha 16-bit library. This page raps bout what tha fuck is different when you use the
16-bit library.
.P
WARNING: A single application can be linked wit both libraries yo, but you must
take care when processin any particular pattern ta use functions from just one
library. For example, if you wanna study a pattern dat was compiled with
\fBpcre16_compile()\fP, you must do so wit \fBpcre16_study()\fP, not
\fBpcre_study()\fP, n' you must free tha study data with
\fBpcre16_free_study()\fP.
.
.
.SH "THE HEADER FILE"
.rs
.sp
There is only one header file, \fBpcre.h\fP. Well shiiiit, it gotz nuff prototypes fo' all the
functions up in all libraries, as well as definitionz of flags, structures, error
codes, etc.
.
.
.SH "THE LIBRARY NAME"
.rs
.sp
In Unix-like systems, tha 16-bit library is called \fBlibpcre16\fP, n' can
normally be accesss by addin \fB-lpcre16\fP ta tha command fo' linkin an
application dat uses PCRE.
.
.
.SH "STRING TYPES"
.rs
.sp
In tha 8-bit library, strings is passed ta PCRE library functions as vectors
of bytes wit tha C type "char *". In tha 16-bit library, strings is passed as
vectorz of unsigned 16-bit quantities. Put ya muthafuckin choppers up if ya feel dis! Da macro PCRE_UCHAR16 specifies an
appropriate data type, n' PCRE_SPTR16 is defined as "const PCRE_UCHAR16 *". In
very nuff environments, "short int" be a 16-bit data type. When PCRE is built,
it defines PCRE_UCHAR16 as "unsigned short int" yo, but checks dat it straight-up be a
16-bit data type. If it is not, tha build fails wit a error message telling
the maintainer ta modify tha definizzle appropriately.
.
.
.SH "STRUCTURE TYPES"
.rs
.sp
Da typez of tha opaque structures dat is used fo' compiled 16-bit patterns
and JIT stacks is \fBpcre16\fP n' \fBpcre16_jit_stack\fP respectively. The
type of tha user-accessible structure dat is returned by \fBpcre16_study()\fP
is \fBpcre16_extra\fP, n' tha type of tha structure dat is used fo' passing
data ta a cold-ass lil callout function is \fBpcre16_callout_block\fP. These structures
contain tha same fields, wit tha same names, as they 8-bit counterparts, n' you can put dat on yo' toast. The
only difference is dat pointas ta characta strings is 16-bit instead of
8-bit types.
.
.
.SH "16-BIT FUNCTIONS"
.rs
.sp
For every last muthafuckin function up in tha 8-bit library there be a cold-ass lil correspondin function in
the 16-bit library wit a name dat starts wit \fBpcre16_\fP instead of
\fBpcre_\fP. Da prototypes is listed above. In addition, there is one extra
function, \fBpcre16_utf16_to_host_byte_order()\fP. This be a utilitizzle function
that converts a UTF-16 characta strang ta host byte order if necessary. The
other 16-bit functions expect tha strings they is passed ta be up in host byte
order.
.P
Da \fIinput\fP n' \fIoutput\fP arguments of
\fBpcre16_utf16_to_host_byte_order()\fP may point ta tha same address, dat is,
conversion up in place is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da output buffer must be at least as long as
the input.
.P
Da \fIlength\fP argument specifies tha number of 16-bit data units up in the
input string; a wack value specifies a zero-terminated string.
.P
If \fIbyte_order\fP is NULL, it be assumed dat tha strang starts off up in host
byte order n' shit. This may be chizzled by byte-order marks (BOMs) anywhere up in the
strin (commonly as tha straight-up original gangsta character).
.P
If \fIbyte_order\fP aint NULL, a non-zero value of tha integer ta which it
points means dat tha input starts off up in host byte order, otherwise the
opposite order be assumed. Y'all KNOW dat shit, muthafucka! Again, BOMs up in tha strang can chizzle all dis bullshit. Da final
byte order is passed back all up in tha end of processing.
.P
If \fIkeep_boms\fP aint zero, byte-order mark charactas (0xfeff) is copied
into tha output string. Otherwise they is discarded.
.P
Da result of tha function is tha number of 16-bit units placed tha fuck into tha output
buffer, includin tha zero terminator if tha strang was zero-terminated.
.
.
.SH "SUBJECT STRING OFFSETS"
.rs
.sp
Da lengths n' startin offsetz of subject strings must be specified up in 16-bit
data units, n' tha offsets within subject strings dat is returned by the
matchin functions is up in also 16-bit units rather than bytes.
.
.
.SH "NAMED SUBPATTERNS"
.rs
.sp
Da name-to-number translation table dat is maintained fo' named subpatterns
uses 16-bit characters. Da \fBpcre16_get_stringtable_entries()\fP function
returns tha length of each entry up in tha table as tha number of 16-bit data
units.
.
.
.SH "OPTION NAMES"
.rs
.sp
There is two freshly smoked up general option names, PCRE_UTF16 n' PCRE_NO_UTF16_CHECK,
which correspond ta PCRE_UTF8 n' PCRE_NO_UTF8_CHECK up in tha 8-bit library. In
fact, these freshly smoked up options define tha same bits up in tha options word. Y'all KNOW dat shit, muthafucka! There be a
rap bout the
.\" HTML <a href="pcreunicode.html#utf16strings">
.\" </a>
validitizzle of UTF-16 strings
.\"
in the
.\" HREF
\fBpcreunicode\fP
.\"
page.
.P
For tha \fBpcre16_config()\fP function there be a option PCRE_CONFIG_UTF16
that returns 1 if UTF-16 support is configured, otherwise 0. If dis option is
given ta \fBpcre_config()\fP or \fBpcre32_config()\fP, or if the
PCRE_CONFIG_UTF8 or PCRE_CONFIG_UTF32 option is given ta \fBpcre16_config()\fP,
the result is tha PCRE_ERROR_BADOPTION error.
.
.
.SH "CHARACTER CODES"
.rs
.sp
In 16-bit mode, when PCRE_UTF16 aint set, characta joints is treated up in the
same way as up in 8-bit, non UTF-8 mode, except, of course, dat they can range
from 0 ta 0xffff instead of 0 ta 0xff. Characta types fo' charactas less than
0xff can therefore be hyped up by tha locale up in tha same way as before.
Charactas pimped outa than 0xff have only one case, n' no "type" (like fuckin letter
or digit).
.P
In UTF-16 mode, tha characta code is Unicode, up in tha range 0 ta 0x10ffff, with
the exception of joints up in tha range 0xd800 ta 0xdfff cuz dem are
"surrogate" joints dat is used up in pairs ta encode joints pimped outa than 0xffff.
.P
A UTF-16 strang can indicate its endiannizz by special code knows as a
byte-order mark (BOM). Da PCRE functions do not handle this, expectin strings
to be up in host byte order n' shiznit fo' realz. A utilitizzle function called
\fBpcre16_utf16_to_host_byte_order()\fP is provided ta help wit dis (see
above).
.
.
.SH "ERROR NAMES"
.rs
.sp
Da errors PCRE_ERROR_BADUTF16_OFFSET n' PCRE_ERROR_SHORTUTF16 correspond to
their 8-bit counterparts, n' you can put dat on yo' toast. Da error PCRE_ERROR_BADMODE is given when a cold-ass lil compiled
pattern is passed ta a gangbangin' function dat processes patterns up in tha other
mode, fo' example, if a pattern compiled wit \fBpcre_compile()\fP is passed to
\fBpcre16_exec()\fP.
.P
There is freshly smoked up error codes whose names begin wit PCRE_UTF16_ERR fo' invalid
UTF-16 strings, correspondin ta tha PCRE_UTF8_ERR codes fo' UTF-8 strings that
are busted lyrics bout up in tha section entitled
.\" HTML <a href="pcreapi.html#badutf8reasons">
.\" </a>
"Reason codes fo' invalid UTF-8 strings"
.\"
in tha main
.\" HREF
\fBpcreapi\fP
.\"
page. Da UTF-16 errors are:
.sp
  PCRE_UTF16_ERR1  Missin low surrogate at end of string
  PCRE_UTF16_ERR2  Invalid low surrogate bigs up high surrogate
  PCRE_UTF16_ERR3  Isolated low surrogate
  PCRE_UTF16_ERR4  Non-character
.
.
.SH "ERROR TEXTS"
.rs
.sp
If there be a error while compilin a pattern, tha error text dat is passed
back by \fBpcre16_compile()\fP or \fBpcre16_compile2()\fP is still a 8-bit
characta string, zero-terminated.
.
.
.SH "CALLOUTS"
.rs
.sp
Da \fIsubject\fP n' \fImark\fP fieldz up in tha callout block dat is passed to
a callout function point ta 16-bit vectors.
.
.
.SH "TESTING"
.rs
.sp
Da \fBpcretest\fP program continues ta operate wit 8-bit input n' output
filez yo, but it can be used fo' testin tha 16-bit library. If it is run wit the
command line option \fB-16\fP, patterns n' subject strings is converted from
8-bit ta 16-bit before bein passed ta PCRE, n' tha 16-bit library functions
are used instead of tha 8-bit ones. Returned 16-bit strings is converted to
8-bit fo' output. If both tha 8-bit n' tha 32-bit libraries was not compiled,
\fBpcretest\fP defaults ta 16-bit n' tha \fB-16\fP option is ignored.
.P
When PCRE is bein built, tha \fBRunTest\fP script dat is called by "make
check" uses tha \fBpcretest\fP \fB-C\fP option ta discover which of tha 8-bit,
16-bit n' 32-bit libraries has been built, n' runs tha tests appropriately.
.
.
.SH "NOT SUPPORTED IN 16-BIT MODE"
.rs
.sp
Not all tha featurez of tha 8-bit library is available wit tha 16-bit
library. Da C++ n' POSIX wrapper functions support only tha 8-bit library,
and tha \fBpcregrep\fP program be at present 8-bit only.
.
.
.SH AUTHOR
.rs
.sp
.nf
Philip Hazel
Universitizzle Computin Service
Cambridge CB2 3QH, England.
.fi
.
.
.SH REVISION
.rs
.sp
.nf
Last updated: 12 May 2013
Copyright (c) 1997-2013 Universitizzle of Cambridge.
.fi
