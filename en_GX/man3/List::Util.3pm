.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "List::Util 3"
.TH List::Util 3 "2013-08-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
List::Util \- A selection of general\-utilitizzle list subroutines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use List::Util qw(first max maxstr min minstr reduce shuffle sum);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`List::Util\*(C'\fR gotz nuff a selection of subroutines dat playas have
expressed would be sick ta have up in tha perl core yo, but tha usage would
not straight-up be high enough ta warrant tha use of a keyword, n' tha size
so lil' small-ass such dat bein individual extensions would be wasteful.
.PP
By default \f(CW\*(C`List::Util\*(C'\fR do not export any subroutines.
.SH "LIST-REDUCTION FUNCTIONS"
.IX Header "LIST-REDUCTION FUNCTIONS"
Da followin set of functions all reduce a list down ta a single value.
.SS "reduce \s-1BLOCK LIST\s0"
.IX Subsection "reduce BLOCK LIST"
Reduces \s-1LIST\s0 by callin \s-1BLOCK,\s0 up in a scalar context, multiple times,
settin \f(CW$a\fR n' \f(CW$b\fR each time. Da first call is ghon be wit \f(CW$a\fR
and \f(CW$b\fR set ta tha straight-up original gangsta two elementz of tha list, subsequent
calls is ghon be done by settin \f(CW$a\fR ta tha result of tha previous
call n' \f(CW$b\fR ta tha next element up in tha list.
.PP
Returns tha result of tha last call ta \s-1BLOCK.\s0 If \s-1LIST\s0 is empty then
\&\f(CW\*(C`undef\*(C'\fR is returned. Y'all KNOW dat shit, muthafucka! If \s-1LIST\s0 only gotz nuff one element then that
element is returned n' \s-1BLOCK\s0 aint executed.
.PP
.Vb 4
\&    $foo = reduce { $a < $b , biatch? $a : $b } 1..10       # min
\&    $foo = reduce { $a lt $b , biatch? $a : $b } \*(Aqaa\*(Aq..\*(Aqzz\*(Aq # minstr
\&    $foo = reduce { $a + $b } 1 .. 10               # sum
\&    $foo = reduce { $a . $b } @bar                  # concat
.Ve
.PP
If yo' algorithm requires dat \f(CW\*(C`reduce\*(C'\fR produce a identitizzle value, then
make shizzle dat you always pass dat identitizzle value as tha straight-up original gangsta argument ta prevent
\&\f(CW\*(C`undef\*(C'\fR bein returned
.PP
.Vb 1
\&  $foo = reduce { $a + $b } 0, @values;             # sum wit 0 identitizzle value
.Ve
.PP
Da remainin list-reduction functions is all specialisationz of this
generic idea.
.SS "first \s-1BLOCK LIST\s0"
.IX Subsection "first BLOCK LIST"
Similar ta \f(CW\*(C`grep\*(C'\fR up in dat it evaluates \s-1BLOCK\s0 settin \f(CW$_\fR ta each element
of \s-1LIST\s0 up in turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. \f(CW\*(C`first\*(C'\fR returns tha straight-up original gangsta element where tha result from
\&\s-1BLOCK\s0 be a legit value. If \s-1BLOCK\s0 never returns legit or \s-1LIST\s0 was empty then
\&\f(CW\*(C`undef\*(C'\fR is returned.
.PP
.Vb 3
\&    $foo = first { defined($_) } @list    # first defined value up in @list
\&    $foo = first { $_ > $value } @list    # first value up in @list which
\&                                          # is pimped outa than $value
.Ve
.PP
This function could be implemented rockin \f(CW\*(C`reduce\*(C'\fR like this
.PP
.Vb 1
\&    $foo = reduce { defined($a) , biatch? $a : wanted($b) , biatch? $b : undef } undef, @list
.Ve
.PP
for example \fIwanted()\fR could be \fIdefined()\fR which would return tha first
defined value up in \f(CW@list\fR
.SS "max \s-1LIST\s0"
.IX Subsection "max LIST"
Returns tha entry up in tha list wit tha highest numerical value. If the
list is empty then \f(CW\*(C`undef\*(C'\fR is returned.
.PP
.Vb 3
\&    $foo = max 1..10                # 10
\&    $foo = max 3,9,12               # 12
\&    $foo = max @bar, @baz           # whatever
.Ve
.PP
This function could be implemented rockin \f(CW\*(C`reduce\*(C'\fR like this
.PP
.Vb 1
\&    $foo = reduce { $a > $b , biatch? $a : $b } 1..10
.Ve
.SS "maxstr \s-1LIST\s0"
.IX Subsection "maxstr LIST"
Similar ta \f(CW\*(C`max\*(C'\fR yo, but treats all tha entries up in tha list as strings
and returns tha highest strang as defined by tha \f(CW\*(C`gt\*(C'\fR operator.
If tha list is empty then \f(CW\*(C`undef\*(C'\fR is returned.
.PP
.Vb 3
\&    $foo = maxstr \*(AqA\*(Aq..\*(AqZ\*(Aq          # \*(AqZ\*(Aq
\&    $foo = maxstr "hello","world"   # "world"
\&    $foo = maxstr @bar, @baz        # whatever
.Ve
.PP
This function could be implemented rockin \f(CW\*(C`reduce\*(C'\fR like this
.PP
.Vb 1
\&    $foo = reduce { $a gt $b , biatch? $a : $b } \*(AqA\*(Aq..\*(AqZ\*(Aq
.Ve
.SS "min \s-1LIST\s0"
.IX Subsection "min LIST"
Similar ta \f(CW\*(C`max\*(C'\fR but returns tha entry up in tha list wit tha lowest
numerical value. If tha list is empty then \f(CW\*(C`undef\*(C'\fR is returned.
.PP
.Vb 3
\&    $foo = min 1..10                # 1
\&    $foo = min 3,9,12               # 3
\&    $foo = min @bar, @baz           # whatever
.Ve
.PP
This function could be implemented rockin \f(CW\*(C`reduce\*(C'\fR like this
.PP
.Vb 1
\&    $foo = reduce { $a < $b , biatch? $a : $b } 1..10
.Ve
.SS "minstr \s-1LIST\s0"
.IX Subsection "minstr LIST"
Similar ta \f(CW\*(C`min\*(C'\fR yo, but treats all tha entries up in tha list as strings
and returns tha lowest strang as defined by tha \f(CW\*(C`lt\*(C'\fR operator.
If tha list is empty then \f(CW\*(C`undef\*(C'\fR is returned.
.PP
.Vb 3
\&    $foo = minstr \*(AqA\*(Aq..\*(AqZ\*(Aq          # \*(AqA\*(Aq
\&    $foo = minstr "hello","world"   # "hello"
\&    $foo = minstr @bar, @baz        # whatever
.Ve
.PP
This function could be implemented rockin \f(CW\*(C`reduce\*(C'\fR like this
.PP
.Vb 1
\&    $foo = reduce { $a lt $b , biatch? $a : $b } \*(AqA\*(Aq..\*(AqZ\*(Aq
.Ve
.SS "sum \s-1LIST\s0"
.IX Subsection "sum LIST"
Returns tha sum of all tha elements up in \s-1LIST.\s0 If \s-1LIST\s0 is empty then
\&\f(CW\*(C`undef\*(C'\fR is returned.
.PP
.Vb 3
\&    $foo = sum 1..10                # 55
\&    $foo = sum 3,9,12               # 24
\&    $foo = sum @bar, @baz           # whatever
.Ve
.PP
This function could be implemented rockin \f(CW\*(C`reduce\*(C'\fR like this
.PP
.Vb 1
\&    $foo = reduce { $a + $b } 1..10
.Ve
.SS "sum0 \s-1LIST\s0"
.IX Subsection "sum0 LIST"
Similar ta \f(CW\*(C`sum\*(C'\fR, except dis returns 0 when given a empty list, rather
than \f(CW\*(C`undef\*(C'\fR.
.SH "KEY/VALUE PAIR LIST FUNCTIONS"
.IX Header "KEY/VALUE PAIR LIST FUNCTIONS"
Da followin set of functions, all inspired by List::Pairwise, consume
an even-sized list of pairs. Da pairs may be key/value associations from a
hash, or just a list of joints, n' you can put dat on yo' toast. Da functions will all preserve tha original
orderin of tha pairs, n' aint gonna be trippin by multiple pairs havin the
same \*(L"key\*(R" value \- nor even do they require dat tha straight-up original gangsta of each pair be a
plain string.
.SS "pairgrep \s-1BLOCK KVLIST\s0"
.IX Subsection "pairgrep BLOCK KVLIST"
Similar ta perlz \f(CW\*(C`grep\*(C'\fR keyword yo, but interprets tha given list as an
even-sized list of pairs. Well shiiiit, it invokes tha \s-1BLOCK\s0 multiple times, up in scalar
context, wit \f(CW$a\fR n' \f(CW$b\fR set ta successive pairz of joints from the
\&\s-1KVLIST.\s0
.PP
Returns a even-sized list of dem pairs fo' which tha \s-1BLOCK\s0 returned true
in list context, or tha count of tha \fBnumber of pairs\fR up in scalar context.
(Note, therefore, up in scalar context dat it returns a number half tha size
of tha count of shit it would have returned up in list context).
.PP
.Vb 1
\&    @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
.Ve
.PP
Similar ta \f(CW\*(C`grep\*(C'\fR, \f(CW\*(C`pairgrep\*(C'\fR aliases \f(CW$a\fR n' \f(CW$b\fR ta elementz of the
given list fo' realz. Any modificationz of it by tha code block is ghon be visible to
the caller.
.SS "pairfirst \s-1BLOCK KVLIST\s0"
.IX Subsection "pairfirst BLOCK KVLIST"
Similar ta tha \f(CW\*(C`first\*(C'\fR function yo, but interprets tha given list as an
even-sized list of pairs. Well shiiiit, it invokes tha \s-1BLOCK\s0 multiple times, up in scalar
context, wit \f(CW$a\fR n' \f(CW$b\fR set ta successive pairz of joints from the
\&\s-1KVLIST.\s0
.PP
Returns tha straight-up original gangsta pair of joints from tha list fo' which tha \s-1BLOCK\s0 returned
true up in list context, or a empty list of no such pair was found. Y'all KNOW dat shit, muthafucka! In scalar
context it returns a simple boolean value, rather than either tha key or the
value found.
.PP
.Vb 1
\&    ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
.Ve
.PP
Similar ta \f(CW\*(C`grep\*(C'\fR, \f(CW\*(C`pairfirst\*(C'\fR aliases \f(CW$a\fR n' \f(CW$b\fR ta elementz of the
given list fo' realz. Any modificationz of it by tha code block is ghon be visible to
the caller.
.SS "pairmap \s-1BLOCK KVLIST\s0"
.IX Subsection "pairmap BLOCK KVLIST"
Similar ta perlz \f(CW\*(C`map\*(C'\fR keyword yo, but interprets tha given list as an
even-sized list of pairs. Well shiiiit, it invokes tha \s-1BLOCK\s0 multiple times, up in list
context, wit \f(CW$a\fR n' \f(CW$b\fR set ta successive pairz of joints from the
\&\s-1KVLIST.\s0
.PP
Returns tha concatenation of all tha joints returned by tha \s-1BLOCK\s0 up in list
context, or tha count of tha number of shit dat would done been returned
in scalar context.
.PP
.Vb 1
\&    @result = pairmap { "Da key $a has value $b" } @kvlist
.Ve
.PP
Similar ta \f(CW\*(C`map\*(C'\fR, \f(CW\*(C`pairmap\*(C'\fR aliases \f(CW$a\fR n' \f(CW$b\fR ta elementz of the
given list fo' realz. Any modificationz of it by tha code block is ghon be visible to
the caller.
.SS "pairs \s-1KVLIST\s0"
.IX Subsection "pairs KVLIST"
A convenient shortcut ta operatin on even-sized listz of pairs, this
function returns a list of \s-1ARRAY\s0 references, each containin two shit from
the given list. Well shiiiit, it aint nuthin but a mo' efficient version of
.PP
.Vb 1
\&    pairmap { [ $a, $b ] } KVLIST
.Ve
.PP
It be most convenient ta use up in a \f(CW\*(C`foreach\*(C'\fR loop, fo' example:
.PP
.Vb 4
\&    foreach ( pairs @KVLIST ) {
\&       mah ( $key, $value ) = @$_;
\&       ...
\&    }
.Ve
.SS "pairkeys \s-1KVLIST\s0"
.IX Subsection "pairkeys KVLIST"
A convenient shortcut ta operatin on even-sized listz of pairs, this
function returns a list of tha the straight-up original gangsta jointz of each of tha pairs in
the given list. Well shiiiit, it aint nuthin but a mo' efficient version of
.PP
.Vb 1
\&    pairmap { $a } KVLIST
.Ve
.SS "pairvalues \s-1KVLIST\s0"
.IX Subsection "pairvalues KVLIST"
A convenient shortcut ta operatin on even-sized listz of pairs, this
function returns a list of tha the second jointz of each of tha pairs in
the given list. Well shiiiit, it aint nuthin but a mo' efficient version of
.PP
.Vb 1
\&    pairmap { $b } KVLIST
.Ve
.SH "OTHER FUNCTIONS"
.IX Header "OTHER FUNCTIONS"
.SS "shuffle \s-1LIST\s0"
.IX Subsection "shuffle LIST"
Returns tha elementz of \s-1LIST\s0 up in a random order
.PP
.Vb 1
\&    @cardz = shuffle 0..51      # 0..51 up in a random order
.Ve
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
With perl versions prior ta 5.005 there be some cases where reduce
will return a incorrect result. This will show up as test 7 of
reduce.t failing.
.SH "SUGGESTED ADDITIONS"
.IX Header "SUGGESTED ADDITIONS"
Da followin is additions dat done been axed yo, but I done been reluctant
to add cuz of dem bein straight-up simple ta implement up in perl
.PP
.Vb 1
\&  # One argument is true
\&
\&  sub any { $_ && return 1 fo' @_; 0 }
\&
\&  # All arguments is true
\&
\&  sub all { $_ || return 0 fo' @_; 1 }
\&
\&  # All arguments is false
\&
\&  sub none { $_ && return 0 fo' @_; 1 }
\&
\&  # One argument is false
\&
\&  sub notall { $_ || return 1 fo' @_; 0 }
\&
\&  # How tha fuck nuff elements is true
\&
\&  sub legit { scalar grep { $_ } @_ }
\&
\&  # How tha fuck nuff elements is false
\&
\&  sub false { scalar grep { !$_ } @_ }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Scalar::Util, List::Mo'Utils
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-2007 Graham Barr <gbarr@pobox.com> fo' realz. All muthafuckin rights reserved.
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.PP
Recent additions n' current maintenizzle by
Pizzle Evans, <leonerd@leonerd.org.uk>.
