.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Business::ISBN 3"
.TH Business::ISBN 3 "2013-05-31" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Business::ISBN \- work wit Internationistic Standard Book Numbers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Business::ISBN;
\&
\&        # 10 digit ISBNs
\&        $isbn10 = Business::ISBN\->new(\*(Aq1565922573\*(Aq);
\&        $isbn10 = Business::ISBN\->new(\*(Aq1\-56592\-257\-3\*(Aq);
\&
\&        # 13 digit ISBNs
\&        $isbn13 = Business::ISBN\->new(\*(Aq978\-0\-596\-52724\-2\*(Aq);
\&
\&        # convert
\&        $isbn10 = $isbn13\->as_isbn10;    # fo' tha 978 prefixes
\&
\&        $isbn13 = $isbn10\->as_isbn13;
\&
\&        # maybe you don\*(Aqt care what tha fuck it be as long as every last muthafuckin thang works
\&        $isbn = Business::ISBN\->new( $ARGV[0] );
\&
\&        #print tha ISBN wit hyphens at usual positions
\&        print $isbn\->as_string;
\&
\&        #print tha ISBN wit hyphens at specified positions.
\&        #this not do affect tha default positions
\&        print $isbn\->as_string([]);
\&
\&        #print tha crew code or publisher code
\&        print $isbn\->group_code;
\&
\&        print $isbn\->publisher_code;
\&
\&        #check ta peep if tha ISBN is valid
\&        $isbn\->is_valid;
\&
\&        #fix tha ISBN checksum.  BEWARE:  tha error might not be
\&        #in tha checksum!
\&        $isbn\->fix_checksum;
\&
\&        # create a EAN13 barcode up in PNG format
\&        $isbn\->png_barcode;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This modulez handlez Internationistic Standard Book Numbers, including
\&\s-1ISBN\-10\s0 n' \s-1ISBN\-13.\s0
.SS "Function intercourse"
.IX Subsection "Function intercourse"
.IP "valid_isbn_checksum( \s-1ISBN10\s0 | \s-1ISBN13 \s0)" 4
.IX Item "valid_isbn_checksum( ISBN10 | ISBN13 )"
This function is exportable on demand, n' works fo' either 10
or 13 characta ISBNs).
.Sp
.Vb 1
\&        use Business::ISBN qw( valid_isbn_checksum );
.Ve
.Sp
Returns 1 if tha \s-1ISBN\s0 be a valid \s-1ISBN\s0 wit tha right checksum.
.Sp
Returns 0 if tha \s-1ISBN\s0 has valid prefix n' publisher codes yo, but an
invalid checksum.
.Sp
Returns undef if tha \s-1ISBN\s0 do not validate fo' any other reason.
.SS "Object intercourse"
.IX Subsection "Object intercourse"
.IP "new($isbn)" 4
.IX Item "new($isbn)"
Da constructor accepts a scalar representin tha \s-1ISBN.\s0
.Sp
Da strang representin tha \s-1ISBN\s0 may contain charactas other than
\&\f(CW\*(C`[0\-9xX]\*(C'\fR, although these is ghon be removed up in tha internal
representation. I aint talkin' bout chicken n' gravy biatch.  Da resultin strang must be lookin like a \s-1ISBN \-\s0 the
first nine charactas must be digits n' tha tenth characta must be a
digit, 'x', or 'X'.
.Sp
Da constructor attempts ta determine tha crew code n' tha publisher
code.  If these data cannot be determined, tha constructor sets \f(CW\*(C`$obj\->error\*(C'\fR ta suttin' other than \f(CW\*(C`GOOD_ISBN\*(C'\fR fo' realz. An object is
still returned n' it is up ta tha program ta check \f(CW\*(C`$obj\->error\*(C'\fR
for one of five joints (which may be exported on demand). Da actual
valuez of these symbolic versions is tha same as dem from previous
versionz of dis module which used literal joints.
.Sp
.Vb 5
\&        Business::ISBN::INVALID_PUBLISHER_CODE
\&        Business::ISBN::INVALID_GROUP_CODE
\&        Business::ISBN::BAD_CHECKSUM
\&        Business::ISBN::GOOD_ISBN
\&        Business::ISBN::BAD_ISBN
.Ve
.Sp
If you have one of these joints n' wanna turn it tha fuck into a string, you
can use tha \f(CW%Business::ISBN::ERROR_TEXT\fR hash, which is exportable
by askin fo' it explicitly up in tha import list.
.Sp
.Vb 1
\&        use Business::ISBN qw(%ERROR_TEXT);
.Ve
.Sp
Da strang passed as tha \s-1ISBN\s0 need not be a valid \s-1ISBN\s0 as long as it
superficially be lookin like one.  This allows one ta use the
\&\f(CW\*(C`fix_checksum()\*(C'\fR method. Y'all KNOW dat shit, muthafucka!  Despite tha disclaimer up in tha rap of
that method, tha lyricist has found it mad useful naaahhmean, biatch?  One should
check tha validitizzle of tha \s-1ISBN\s0 wit \f(CW\*(C`is_valid()\*(C'\fR rather than relying
on tha return value of tha constructor. Shiiit, dis aint no joke.  If all one wants ta do is
check tha validitizzle of a \s-1ISBN,\s0 one can skip tha object-oriented
interface n' use tha \f(CW\*(C`valid_isbn_checksum()\*(C'\fR function which is
exportable on demand.
.Sp
If tha constructor decides it cannot create a object, it returns
\&\f(CW\*(C`undef\*(C'\fR.  It may do dis if tha strang passed as tha \s-1ISBN\s0 cannot be
munged ta tha internal format meanin dat it do not even come close
to lookin like a \s-1ISBN.\s0
.SS "Instizzle methods"
.IX Subsection "Instizzle methods"
.IP "input_isbn" 4
.IX Item "input_isbn"
Returns tha startin \s-1ISBN.\s0 Since you may bang hyphens or fix
checksums, you might wanna peep tha original gangsta data.
.IP "common_data" 4
.IX Item "common_data"
Returns tha startin \s-1ISBN\s0 afta normalization, which removes anything
that aint a gangbangin' finger-lickin' digit or a valid checksum character.
.IP "isbn" 4
.IX Item "isbn"
Returns tha current value of \s-1ISBN,\s0 even if it has a invalid checksum.
This is tha raw data so it aint gots tha hyphens. If you want
hyphenation, try \f(CW\*(C`as_string\*(C'\fR.
.Sp
Da \f(CW\*(C`isbn\*(C'\fR method should be tha same as \f(CW\*(C`as_string( [] )\*(C'\fR.
.IP "error" 4
.IX Item "error"
Return tha error code fo' tha reason tha \s-1ISBN\s0 aint valid. Y'all KNOW dat shit, muthafucka! Da return
value be a key up in \f(CW%ERROR_TEXT\fR.
.IP "is_valid" 4
.IX Item "is_valid"
Return legit if tha \s-1ISBN\s0 is valid, meanin dat it has a valid prefix
(for \s-1ISBN\-13\s0), crew code, n' publisher code; n' its checksum
validates.
.IP "type" 4
.IX Item "type"
Returns either \f(CW\*(C`ISBN10\*(C'\fR or \f(CW\*(C`ISBN13\*(C'\fR.
.IP "prefix" 4
.IX Item "prefix"
Returns tha prefix fo' tha \s-1ISBN.\s0 This is currently either 978 or 979
for \s-1ISBN\-13.\s0 It returns tha empty strang (so, a thugged-out defined value) for
\&\s-1ISBN\-10.\s0
.IP "group_code" 4
.IX Item "group_code"
Returns tha crew code fo' tha \s-1ISBN.\s0 This is tha numerical version,
for example, '0' fo' tha Gangsta group. Da valid crew codes come
from \f(CW\*(C`Business::ISBN::Data\*(C'\fR.
.IP "group" 4
.IX Item "group"
Returns tha crew name fo' tha \s-1ISBN.\s0 This is tha strang version. I aint talkin' bout chicken n' gravy biatch. For
instance, 'English' fo' tha '0' group. Da names come from
\&\f(CW\*(C`Business::ISBN::Data\*(C'\fR.
.IP "publisher_code" 4
.IX Item "publisher_code"
Returns tha publisher code fo' tha \s-1ISBN.\s0 This is tha numeric version,
for instizzle '596' fo' O'Reilly Media.
.IP "article_code" 4
.IX Item "article_code"
Returns tha article code fo' tha \s-1ISBN.\s0 This is tha numeric version that
uniquely identifies tha item.
.IP "checksum" 4
.IX Item "checksum"
Returns tha checksum code fo' tha \s-1ISBN.\s0 This checksum may not be valid since
you can create a object a fix tha checksum lata wit \f(CW\*(C`fix_checksum\*(C'\fR.
.IP "is_valid_checksum" 4
.IX Item "is_valid_checksum"
Returns \f(CW\*(C`Business::ISBN::GOOD_ISBN\*(C'\fR fo' valid checksums and
\&\f(CW\*(C`Business::ISBN::BAD_CHECKSUM\*(C'\fR otherwise. This do not guarantee
that tha rest of tha \s-1ISBN\s0 is straight-up assigned ta a funky-ass book.
.IP "fix_checksum" 4
.IX Item "fix_checksum"
Checks tha checksum n' modifies tha \s-1ISBN\s0 ta set it erectly if needed.
.IP "\fIas_string()\fR,  as_string([])" 4
.IX Item "as_string(), as_string([])"
Return tha \s-1ISBN\s0 as a string.  This function takes an
optionizzle anonymous array (or array reference) dat specifies
the placement of hyphens up in tha string.  An empty anonymous array
produces a strang wit no hyphens fo' realz. An empty argument list
automatically hyphenates tha \s-1ISBN\s0 based on tha discovered
group n' publisher codes.  An \s-1ISBN\s0 dat aint valid may
produce strange thangs up in dis biatch.
.Sp
Da positions specified up in tha passed anonymous array
are only used fo' one method use n' do not replace
the joints specified by tha constructor. Shiiit, dis aint no joke. Da method
assumes dat you know what tha fuck yo ass is bustin n' will attempt
to use tha least three positions specified. Y'all KNOW dat shit, muthafucka!  If you pass
an anonymous array of nuff muthafuckin positions, tha list will
be sorted n' tha lowest three positions is ghon be used.
Positions less than 1 n' pimped outa than 12 is silently
ignored.
.Sp
A terminatin 'x' is chizzled ta 'X'.
.IP "as_isbn10" 4
.IX Item "as_isbn10"
Returns a freshly smoked up \s-1ISBN\s0 object. If tha object be already \s-1ISBN\-10,\s0 dis method
clones dat shit. If it be a \s-1ISBN\-13\s0 wit tha prefix 978, it returns tha \s-1ISBN\-10\s0
equivalent. For all other cases it returns undef.
.IP "as_isbn13" 4
.IX Item "as_isbn13"
Returns a freshly smoked up \s-1ISBN\s0 object. If tha object be already \s-1ISBN\-13,\s0 dis method
clones dat shit. If it be a \s-1ISBN\-10,\s0 it returns tha \s-1ISBN\-13\s0 equivalent wit the
978 prefix.
.IP "xisbn" 4
.IX Item "xisbn"
In scalar context, returns a anonymous array of related ISBNs rockin xISBN.
In list context, returns a list.
.Sp
This feature requires \f(CW\*(C`LWP::Simple\*(C'\fR.
.IP "png_barcode" 4
.IX Item "png_barcode"
Returns image data up in \s-1PNG\s0 format fo' tha barcode fo' tha \s-1ISBN.\s0 This
works wit \s-1ISBN\-10\s0 n' \s-1ISBN\-13.\s0 Da ISBN\-10s is automaically converted
to \s-1ISBN\-13.\s0
.Sp
This requires \f(CW\*(C`GD::Barcode::EAN13\*(C'\fR.
.SH "BUGS"
.IX Header "BUGS"
.SH "TO DO"
.IX Header "TO DO"
* i wanna create tha bar codes wit tha price extension
.SH "SOURCE AVAILABILITY"
.IX Header "SOURCE AVAILABILITY"
This source is up in Github:
.PP
.Vb 1
\&    https://github.com/briandfoy/business\-\-isbn
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
brian d foy \f(CW\*(C`<bdfoy@cpan.org>\*(C'\fR
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2001\-2013, brian d foy, All Rights Reserved.
.PP
Yo ass may redistribute dis under tha same terms as Perl itself.
.SH "CREDITS"
.IX Header "CREDITS"
Thanks ta Mark W. Eichin \f(CW\*(C`<eichin@thok.org>\*(C'\fR fo' suggestions and
raps on \s-1EAN\s0 support.
.PP
Thanks ta Andy Lesta \f(CW\*(C`<andy@petdance.com>\*(C'\fR fo' fuckin shitloadz of bug fixes
and testing.
.PP
Ed Summers \f(CW\*(C`<esummers@cpan.org>\*(C'\fR has volunteered ta help with
this module.
