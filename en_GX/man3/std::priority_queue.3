" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::priority_queue< _Tp, _Sequence, _Compare > \- 
.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Sequence::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef _Sequence \fBcontainer_type\fP"
.br
.ti -1c
.RI "typedef _Sequence::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef _Sequence::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Sequence::value_type \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBpriority_queue\fP (const _Compare &__x, const _Sequence &__s)"
.br
.ti -1c
.RI "\fBpriority_queue\fP (const _Compare &__x=_Compare(), _Sequence &&__s=_Sequence())"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBpriority_queue\fP (_InputIterator __first, _InputIterator __last, const _Compare &__x, const _Sequence &__s)"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBpriority_queue\fP (_InputIterator __first, _InputIterator __last, const _Compare &__x=_Compare(), _Sequence &&__s=_Sequence())"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> void \fBemplace\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.ti -1c
.RI "void \fBpop\fP ()"
.br
.ti -1c
.RI "void \fBpush\fP (const value_type &__x)"
.br
.ti -1c
.RI "void \fBpush\fP (value_type &&__x)"
.br
.ti -1c
.RI "size_type \fBsize\fP () const "
.br
.ti -1c
.RI "void \fBswap\fP (\fBpriority_queue\fP &__pq) noexcept(noexcept(swap(c, __pq\&.c))&&noexcept(swap(comp, __pq\&.comp)))"
.br
.ti -1c
.RI "const_reference \fBtop\fP () const "
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_Sequence \fBc\fP"
.br
.ti -1c
.RI "_Compare \fBcomp\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp, typename _Sequence = vector<_Tp>, typename _Compare = less<typename _Sequence::value_type>>class std::priority_queue< _Tp, _Sequence, _Compare >"
A standard container automatically sortin its contents\&. 


.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Tp\fP Type of element\&. 
.br
\fI_Sequence\fP Type of underlyin sequence, defaults ta vector<_Tp>\&. 
.br
\fI_Compare\fP Comparison function object type, defaults ta less<_Sequence::value_type>\&.
.RE
.PP
This aint a legit container yo, but a \fIadaptor\fP\&. Well shiiiit, it holdz another container, n' serves up a wrapper intercourse ta dat container\&. Da wrapper is what tha fuck enforces priority-based sortin n' queue behavior\&. Straight-up few of tha standard container/sequence intercourse requirements is kicked it wit (e\&.g\&., iterators)\&.
.PP
Da second template parameta defines tha type of tha underlyin sequence/container\&. Well shiiiit, it defaults ta std::vector yo, but it can be any type dat supports \fCfront()\fP, \fCpush_back\fP, \fCpop_back\fP, n' random-access iterators, like fuckin std::deque or a appropriate user-defined type\&.
.PP
Da third template parameta supplies tha meanz of makin prioritizzle comparisons\&. Well shiiiit, it defaults ta \fCless<value_type>\fP but can be anythang definin a strict weak ordering\&.
.PP
Members not found up in \fInormal\fP containers is \fCcontainer_type\fP, which be a typedef fo' tha second Sequence parameter, n' \fCpush\fP, \fCpop\fP, n' \fCtop\fP, which is standard queue operations\&.
.PP
\fBNote:\fP
.RS 4
No equality/comparison operators is provided fo' priority_queue\&.
.PP
Sortin of tha elements takes place as they is added to, n' removed from, tha priority_queue rockin tha priority_queuez member functions\&. If you access tha elements by other means, n' chizzle they data such dat tha sortin order would be different, tha priority_queue aint gonna re-sort tha elements fo' you\&. (How tha fuck could it know ta do so?) 
.RE
.PP

.PP
Definizzle at line 367 of file stl_queue\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Tp, typename _Sequence = vector<_Tp>, typename _Compare = less<typename _Sequence::value_type>> \fBstd::priority_queue\fP< _Tp, _Sequence, _Compare >::\fBpriority_queue\fP (const _Compare &__x, const _Sequence &__s)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Default constructor creates no elements\&. 
.PP
Definizzle at line 402 of file stl_queue\&.h\&.
.PP
References std::make_heap()\&.
.SS "template<typename _Tp, typename _Sequence = vector<_Tp>, typename _Compare = less<typename _Sequence::value_type>> template<typename _InputIterator > \fBstd::priority_queue\fP< _Tp, _Sequence, _Compare >::\fBpriority_queue\fP (_InputIterator__first, _InputIterator__last, const _Compare &__x, const _Sequence &__s)\fC [inline]\fP"

.PP
Buildz a queue from a range\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&. 
.br
\fI__x\fP A comparison functor describin a strict weak ordering\&. 
.br
\fI__s\fP An initial sequence wit which ta start\&.
.RE
.PP
Begins by copyin \fI__s\fP, insertin a cold-ass lil copy of tha elements from \fI\fP[first,last) tha fuck into tha copy of \fI__s\fP, then orderin tha copy accordin ta \fI__x\fP\&.
.PP
For mo' shiznit on function objects, peep tha documentation on \fBfunctor base classes\fP\&. 
.PP
Definizzle at line 442 of file stl_queue\&.h\&.
.PP
References std::make_heap()\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp, typename _Sequence = vector<_Tp>, typename _Compare = less<typename _Sequence::value_type>> bool \fBstd::priority_queue\fP< _Tp, _Sequence, _Compare >::empty () const\fC [inline]\fP"
Returns legit if tha queue is empty\&. 
.PP
Definizzle at line 468 of file stl_queue\&.h\&.
.PP
Referenced by __gnu_parallel::multiseq_partition(), n' __gnu_parallel::multiseq_selection()\&.
.SS "template<typename _Tp, typename _Sequence = vector<_Tp>, typename _Compare = less<typename _Sequence::value_type>> void \fBstd::priority_queue\fP< _Tp, _Sequence, _Compare >::pop ()\fC [inline]\fP"

.PP
Removes first element\&. This be a typical queue operation\&. Well shiiiit, it shrinks tha queue by one\&. Da time complexitizzle of tha operation dependz on tha underlyin sequence\&.
.PP
Note dat no data is returned, n' if tha straight-up original gangsta elementz data is needed, it should be retrieved before pop() is called\&. 
.PP
Definizzle at line 531 of file stl_queue\&.h\&.
.PP
References std::pop_heap()\&.
.PP
Referenced by __gnu_parallel::multiseq_partition(), n' __gnu_parallel::multiseq_selection()\&.
.SS "template<typename _Tp, typename _Sequence = vector<_Tp>, typename _Compare = less<typename _Sequence::value_type>> void \fBstd::priority_queue\fP< _Tp, _Sequence, _Compare >::push (const value_type &__x)\fC [inline]\fP"

.PP
Add data ta tha queue\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Data ta be added\&.
.RE
.PP
This be a typical queue operation\&. Da time complexitizzle of tha operation dependz on tha underlyin sequence\&. 
.PP
Definizzle at line 496 of file stl_queue\&.h\&.
.PP
References std::push_heap()\&.
.PP
Referenced by __gnu_parallel::multiseq_partition(), n' __gnu_parallel::multiseq_selection()\&.
.SS "template<typename _Tp, typename _Sequence = vector<_Tp>, typename _Compare = less<typename _Sequence::value_type>> size_type \fBstd::priority_queue\fP< _Tp, _Sequence, _Compare >::size () const\fC [inline]\fP"
Returns tha number of elements up in tha queue\&. 
.PP
Definizzle at line 473 of file stl_queue\&.h\&.
.SS "template<typename _Tp, typename _Sequence = vector<_Tp>, typename _Compare = less<typename _Sequence::value_type>> const_reference \fBstd::priority_queue\fP< _Tp, _Sequence, _Compare >::top () const\fC [inline]\fP"
Returns a read-only (constant) reference ta tha data all up in tha straight-up original gangsta element of tha queue\&. 
.PP
Definizzle at line 481 of file stl_queue\&.h\&.
.PP
Referenced by __gnu_parallel::multiseq_partition(), n' __gnu_parallel::multiseq_selection()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
