.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::Cap 3pm"
.TH Term::Cap 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::Cap \- Perl termcap intercourse
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    require Term::Cap;
\&    $terminal = Tgetent Term::Cap { TERM => undef, OSPEED => $ospeed };
\&    $terminal\->Trequire(qw/ce ku kd/);
\&    $terminal\->Tgoto(\*(Aqcm\*(Aq, $col, $row, $FH);
\&    $terminal\->Tputs(\*(Aqdl\*(Aq, $count, $FH);
\&    $terminal\->Tpad($string, $count, $FH);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These is low-level functions ta extract n' use capabilitizzles from
a terminal capabilitizzle (termcap) database.
.PP
Mo' shiznit on tha terminal capabilitizzles is ghon be found up in the
termcap manpage on most Unix-like systems.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
Da output strings fo' \fBTputs\fR is cached fo' countz of 1 fo' performance.
\&\fBTgoto\fR n' \fBTpad\fR do not cache.  \f(CW\*(C`$self\->{_xx}\*(C'\fR is tha raw termcap
data n' \f(CW\*(C`$self\->{xx}\*(C'\fR is tha cached version.
.PP
.Vb 1
\&    print $terminal\->Tpad($self\->{_xx}, 1);
.Ve
.PP
\&\fBTgoto\fR, \fBTputs\fR, n' \fBTpad\fR return tha strang n' will also
output tha strang ta \f(CW$FH\fR if specified.
.IP "\fBTgetent\fR" 4
.IX Item "Tgetent"
Returns a pimped object reference which tha user can
then use ta bust tha control strings ta tha terminal rockin \fBTputs\fR
and \fBTgoto\fR.
.Sp
Da function extracts tha entry of tha specified terminal
type \fI\s-1TERM\s0\fR (defaults ta tha environment variable \fI\s-1TERM\s0\fR) from the
database.
.Sp
It will look up in tha environment fo' a \fI\s-1TERMCAP\s0\fR variable.  If
found, n' tha value do not begin wit a slash, n' tha terminal
type name is tha same ol' dirty as tha environment strang \fI\s-1TERM\s0\fR, the
\&\fI\s-1TERMCAP\s0\fR strang is used instead of readin a termcap file.  If
it do begin wit a slash, tha strang is used as a path name of
the termcap file ta search.  If \fI\s-1TERMCAP\s0\fR do not begin wit a
slash n' name is different from \fI\s-1TERM\s0\fR, \fBTgetent\fR searches the
filez \fI\f(CI$HOME\fI/.termcap\fR, \fI/etc/termcap\fR, n' \fI/usr/share/misc/termcap\fR,
in dat order, unless tha environment variable \fI\s-1TERMPATH\s0\fR exists,
in which case it specifies a list of file pathnames (separated by
spaces or colons) ta be searched \fBinstead\fR.  Whenever multiple
filez is searched n' a tc field occurs up in tha axed entry,
the entry it names must be found up in tha same file or one of the
succeedin files.  If there be a \f(CW\*(C`:tc=...:\*(C'\fR up in tha \fI\s-1TERMCAP\s0\fR
environment variable strang it will continue tha search up in the
filez as above.
.Sp
Da extracted termcap entry be available up in tha object
as \f(CW\*(C`$self\->{TERMCAP}\*(C'\fR.
.Sp
It takes a hash reference as a argument wit two optionizzle keys:
.RS 4
.IP "\s-1OSPEED\s0" 2
.IX Item "OSPEED"
Da terminal output bit rate (often mistakenly called tha baud rate)
for dis terminal \- if not set a warnin is ghon be generated
and it is ghon be defaulted ta 9600.  \fI\s-1OSPEED\s0\fR can be be specified as
either a \s-1POSIX\s0 termios/SYSV termio speedz (where 9600 equals 9600) or
an oldschool DSD-style speed ( where 13 equals 9600).
.IP "\s-1TERM\s0" 2
.IX Item "TERM"
Da terminal type whose termcap entry is ghon be used \- if not supplied it will
default ta \f(CW$ENV\fR{\s-1TERM\s0}: if dat aint set then \fBTgetent\fR will croak.
.RE
.RS 4
.Sp
It calls \f(CW\*(C`croak\*(C'\fR on failure.
.RE
.IP "\fBTpad\fR" 4
.IX Item "Tpad"
Outputs a literal strang wit appropriate paddin fo' tha current terminal.
.Sp
It takes three arguments:
.RS 4
.ie n .IP "\fB\fB$string\fB\fR" 2
.el .IP "\fB\f(CB$string\fB\fR" 2
.IX Item "$string"
Da literal strang ta be output.  If it starts wit a number n' a optional
\&'*' then tha paddin is ghon be increased by a amount relatizzle ta dis number,
if tha '*' is present then dis amount will me multiplied by \f(CW$cnt\fR.  This part
of \f(CW$string\fR is removed before output/
.ie n .IP "\fB\fB$cnt\fB\fR" 2
.el .IP "\fB\f(CB$cnt\fB\fR" 2
.IX Item "$cnt"
Will be used ta modify tha paddin applied ta strang as busted lyrics bout above.
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optionizzle filehandle (or IO::Handle ) dat output is ghon be printed to.
.RE
.RS 4
.Sp
Da padded \f(CW$string\fR is returned.
.RE
.IP "\fBTputs\fR" 4
.IX Item "Tputs"
Output tha strang fo' tha given capabilitizzle padded as appropriate without
any parameta substitution.
.Sp
It takes three arguments:
.RS 4
.ie n .IP "\fB\fB$cap\fB\fR" 2
.el .IP "\fB\f(CB$cap\fB\fR" 2
.IX Item "$cap"
Da capabilitizzle whose strang is ta be output.
.ie n .IP "\fB\fB$cnt\fB\fR" 2
.el .IP "\fB\f(CB$cnt\fB\fR" 2
.IX Item "$cnt"
A count passed ta Tpad ta modify tha paddin applied ta tha output string.
If \f(CW$cnt\fR is zero or one then tha resultin strang is ghon be cached.
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optionizzle filehandle (or IO::Handle ) dat output is ghon be printed to.
.RE
.RS 4
.Sp
Da appropriate strang fo' tha capabilitizzle is ghon be returned.
.RE
.IP "\fBTgoto\fR" 4
.IX Item "Tgoto"
\&\fBTgoto\fR decodes a cold-ass lil cursor addressin strang wit tha given parameters.
.Sp
There is four arguments:
.RS 4
.ie n .IP "\fB\fB$cap\fB\fR" 2
.el .IP "\fB\f(CB$cap\fB\fR" 2
.IX Item "$cap"
Da name of tha capabilitizzle ta be output.
.ie n .IP "\fB\fB$col\fB\fR" 2
.el .IP "\fB\f(CB$col\fB\fR" 2
.IX Item "$col"
Da first value ta be substituted up in tha output strang ( probably tha column
in a cold-ass lil cursor addressin capabilitizzle )
.ie n .IP "\fB\fB$row\fB\fR" 2
.el .IP "\fB\f(CB$row\fB\fR" 2
.IX Item "$row"
Da second value ta be substituted up in tha output strang (usually tha row
in cursor addressin capabilities)
.ie n .IP "\fB\fB$FH\fB\fR" 2
.el .IP "\fB\f(CB$FH\fB\fR" 2
.IX Item "$FH"
An optionizzle filehandle (or IO::Handle ) ta which tha output strang will be
printed.
.RE
.RS 4
.Sp
Substitutions is made wit \f(CW$col\fR n' \f(CW$row\fR up in tha output strang wit the
followin \fIsprintf()\fR line formats:
.Sp
.Vb 6
\& %%   output \`%\*(Aq
\& %d   output value as up in printf %d
\& %2   output value as up in printf %2d
\& %3   output value as up in printf %3d
\& %.   output value as up in printf %c
\& %+x  add x ta value, then do %.
\&
\& %>xy if value > x then add y, no output
\& %r   reverse order of two parameters, no output
\& %i   increment by one, no output
\& %B   BCD (16*(value/10)) + (value%10), no output
\&
\& %n   exclusive\-or all parametas wit 0140 (Datamedia 2500)
\& %D   Reverse codin (value \- 2*(value%16)), no output (Delta Data)
.Ve
.Sp
Da output strang is ghon be returned.
.RE
.IP "\fBTrequire\fR" 4
.IX Item "Trequire"
Takes a list of capabilitizzles as a argument n' will croak if one is not
found.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&    use Term::Cap;
\&
\&    # Git terminal output speed
\&    require POSIX;
\&    mah $termios = freshly smoked up POSIX::Termios;
\&    $termios\->getattr;
\&    mah $ospeed = $termios\->getospeed;
\&
\&    # Old\-style ioctl code ta git ospeed:
\&    #     require \*(Aqioctl.pl\*(Aq;
\&    #     ioctl(TTY,$TIOCGETP,$sgtty);
\&    #     ($ispeed,$ospeed) = unpack(\*(Aqcc\*(Aq,$sgtty);
\&
\&    # allocate n' initialize a terminal structure
\&    $terminal = Tgetent Term::Cap { TERM => undef, OSPEED => $ospeed };
\&
\&    # require certain capabilitizzles ta be available
\&    $terminal\->Trequire(qw/ce ku kd/);
\&
\&    # Output Routines, if $FH is undefined these just return tha string
\&
\&    # Tgoto do tha % expansion shiznit wit tha given args
\&    $terminal\->Tgoto(\*(Aqcm\*(Aq, $col, $row, $FH);
\&
\&    # Tputs don\*(Aqt do any % expansion.
\&    $terminal\->Tputs(\*(Aqdl\*(Aq, $count = 1, $FH);
.Ve
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Please peep tha \s-1README\s0 file up in distribution.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module is part of tha core Perl distribution n' be also maintained
for \s-1CPAN\s0 by Jonathan Stowe <jns@gellyfish.com>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fItermcap\fR\|(5)
