.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::Find 3pm"
.TH File::Find 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Find \- Traverse a gangbangin' finger-lickin' directory tree.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use File::Find;
\&    find(\e&wanted, @directories_to_search);
\&    sub wanted { ... }
\&
\&    use File::Find;
\&    finddepth(\e&wanted, @directories_to_search);
\&    sub wanted { ... }
\&
\&    use File::Find;
\&    find({ wanted => \e&process, follow => 1 }, \*(Aq.\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These is functions fo' searchin all up in directory trees bustin work
on each file found similar ta tha Unix \fIfind\fR command. Y'all KNOW dat shit, muthafucka!  File::Find
exports two functions, \f(CW\*(C`find\*(C'\fR n' \f(CW\*(C`finddepth\*(C'\fR.  They work similarly
but have subtle differences.
.IP "\fBfind\fR" 4
.IX Item "find"
.Vb 2
\&  find(\e&wanted,  @directories);
\&  find(\e%options, @directories);
.Ve
.Sp
\&\f(CW\*(C`find()\*(C'\fR do a thugged-out depth-first search over tha given \f(CW@directories\fR in
the order they is given. I aint talkin' bout chicken n' gravy biatch.  For each file or directory found, it calls
the \f(CW&wanted\fR subroutine.  (See below fo' details on how tha fuck ta use the
\&\f(CW&wanted\fR function).  Additionally, fo' each directory found, it will
\&\f(CW\*(C`chdir()\*(C'\fR tha fuck into dat directory n' continue tha search, invokin the
\&\f(CW&wanted\fR function on each file or subdirectory up in tha directory.
.IP "\fBfinddepth\fR" 4
.IX Item "finddepth"
.Vb 2
\&  finddepth(\e&wanted,  @directories);
\&  finddepth(\e%options, @directories);
.Ve
.Sp
\&\f(CW\*(C`finddepth()\*(C'\fR works just like \f(CW\*(C`find()\*(C'\fR except dat it invokes the
\&\f(CW&wanted\fR function fo' a gangbangin' finger-lickin' directory \fIafter\fR invokin it fo' the
directoryz contents, n' you can put dat on yo' toast.  It do a postorder traversal instead of a
preorder traversal, hustlin from tha bottom of tha directory tree up
where \f(CW\*(C`find()\*(C'\fR works from tha top of tha tree down.
.ie n .SS "%options"
.el .SS "\f(CW%options\fP"
.IX Subsection "%options"
Da first argument ta \f(CW\*(C`find()\*(C'\fR is either a cold-ass lil code reference ta your
\&\f(CW&wanted\fR function, or a hash reference describin tha operations
to be performed fo' each file.  The
code reference is busted lyrics bout up in \*(L"Da wanted function\*(R" below.
.PP
Here is tha possible keys fo' tha hash:
.ie n .IP """wanted""" 3
.el .IP "\f(CWwanted\fR" 3
.IX Item "wanted"
Da value should be a cold-ass lil code reference.  This code reference is
busted lyrics bout up in \*(L"Da wanted function\*(R" below. Da \f(CW&wanted\fR subroutine is
mandatory.
.ie n .IP """bydepth""" 3
.el .IP "\f(CWbydepth\fR" 3
.IX Item "bydepth"
Reports tha name of a gangbangin' finger-lickin' directory only \s-1AFTER\s0 all its entries
have been reported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Entry point \f(CW\*(C`finddepth()\*(C'\fR be a gangbangin' finger-lickin' dirty-ass shortcut for
specifyin \f(CW\*(C`{ bydepth => 1 }\*(C'\fR up in tha straight-up original gangsta argument of \f(CW\*(C`find()\*(C'\fR.
.ie n .IP """preprocess""" 3
.el .IP "\f(CWpreprocess\fR" 3
.IX Item "preprocess"
Da value should be a cold-ass lil code reference. This code reference is used to
preprocess tha current directory. Da name of tha currently processed
directory is up in \f(CW$File::Find::dir\fR. Yo crazy-ass preprocessin function is
called afta \f(CW\*(C`readdir()\*(C'\fR yo, but before tha loop dat calls tha \f(CW\*(C`wanted()\*(C'\fR
function. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it is called wit a list of strings (actually file/directory
names) n' is sposed ta fuckin return a list of strings. Da code can be
used ta sort tha file/directory names alphabetically, numerically,
or ta filta up directory entries based on they name ridin' solo. When
\&\fIfollow\fR or \fIfollow_fast\fR is up in effect, \f(CW\*(C`preprocess\*(C'\fR be a no-op.
.ie n .IP """postprocess""" 3
.el .IP "\f(CWpostprocess\fR" 3
.IX Item "postprocess"
Da value should be a cold-ass lil code reference. Well shiiiit, it is invoked just before leaving
the currently processed directory. Well shiiiit, it is called up in void context wit no
arguments, n' you can put dat on yo' toast. Da name of tha current directory is up in \f(CW$File::Find::dir\fR. This
hook is handy fo' summarizin a gangbangin' finger-lickin' directory, like fuckin calculatin its disk
usage. When \fIfollow\fR or \fIfollow_fast\fR is up in effect, \f(CW\*(C`postprocess\*(C'\fR be a
no-op.
.ie n .IP """follow""" 3
.el .IP "\f(CWfollow\fR" 3
.IX Item "follow"
Causes symbolic links ta be followed. Y'all KNOW dat shit, muthafucka! Since directory trees wit symbolic
links (followed) may contain filez mo' than once n' may even have
cycles, a hash has ta be built up wit a entry fo' each file.
This might be high-rollin' both up in space n' time fo' a large
directory tree. Right back up in yo muthafuckin ass. See \*(L"follow_fast\*(R" n' \*(L"follow_skip\*(R" below.
If either \fIfollow\fR or \fIfollow_fast\fR is up in effect:
.RS 3
.IP "\(bu" 6
It be guaranteed dat a \fIlstat\fR has been called before tha user's
\&\f(CW\*(C`wanted()\*(C'\fR function is called. Y'all KNOW dat shit, muthafucka! This enablez fast file checks involvin _.
Note dat dis guarantee no longer holdz if \fIfollow\fR or \fIfollow_fast\fR
are not set.
.IP "\(bu" 6
There be a variable \f(CW$File::Find::fullname\fR which holdz tha absolute
pathname of tha file wit all symbolic links resolved. Y'all KNOW dat shit, muthafucka!  If tha link is
a danglin symbolic link, then fullname is ghon be set ta \f(CW\*(C`undef\*(C'\fR.
.RE
.RS 3
.Sp
This be a no-op on Win32.
.RE
.ie n .IP """follow_fast""" 3
.el .IP "\f(CWfollow_fast\fR" 3
.IX Item "follow_fast"
This is similar ta \fIfollow\fR except dat it may report some filez more
than once.  It do detect cycles, however n' shit.  Since only symbolic links
have ta be hashed, dis is much skankyer both up in space n' time.  If
processin a gangbangin' file mo' than once (by tha userz \f(CW\*(C`wanted()\*(C'\fR function)
is worse than just takin time, tha option \fIfollow\fR should be used.
.Sp
This be also a no-op on Win32.
.ie n .IP """follow_skip""" 3
.el .IP "\f(CWfollow_skip\fR" 3
.IX Item "follow_skip"
\&\f(CW\*(C`follow_skip==1\*(C'\fR, which is tha default, causes all filez which are
neither directories nor symbolic links ta be ignored if they is about
to be processed a second time. If a gangbangin' finger-lickin' directory or a symbolic link
are bout ta be processed a second time, File::Find dies.
.Sp
\&\f(CW\*(C`follow_skip==0\*(C'\fR causes File::Find ta take a thugged-out dirtnap if any file be bout ta be
processed a second time.
.Sp
\&\f(CW\*(C`follow_skip==2\*(C'\fR causes File::Find ta ignore any duplicate filez and
directories but ta proceed normally otherwise.
.ie n .IP """dangling_symlinks""" 3
.el .IP "\f(CWdangling_symlinks\fR" 3
.IX Item "dangling_symlinks"
If legit n' a cold-ass lil code reference, is ghon be called wit tha symbolic link
name n' tha directory it lives up in as arguments, n' you can put dat on yo' toast.  Otherwise, if true
and warnings is on, warnin \*(L"symbolic_link_name be a thugged-out dangling
symbolic link\en\*(R" is ghon be issued. Y'all KNOW dat shit, muthafucka!  If false, tha danglin symbolic link
will be silently ignored.
.ie n .IP """no_chdir""" 3
.el .IP "\f(CWno_chdir\fR" 3
.IX Item "no_chdir"
Do not \f(CW\*(C`chdir()\*(C'\fR ta each directory as it recurses. Da \f(CW\*(C`wanted()\*(C'\fR
function will need ta be aware of this, of course. In dis case,
\&\f(CW$_\fR is ghon be tha same as \f(CW$File::Find::name\fR.
.ie n .IP """untaint""" 3
.el .IP "\f(CWuntaint\fR" 3
.IX Item "untaint"
If find is used up in taint-mode (\-T command line switch or if \s-1EUID \s0!= \s-1UID\s0
or if \s-1EGID \s0!= \s-1GID\s0) then internally directory names gotta be untainted
before they can be chdir'ed to. Therefore they is checked against a regular
expression \fIuntaint_pattern\fR.  Note dat all names passed ta tha user's
\&\fI\fIwanted()\fI\fR function is still tainted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If dis option is used while
not up in taint-mode, \f(CW\*(C`untaint\*(C'\fR be a no-op.
.ie n .IP """untaint_pattern""" 3
.el .IP "\f(CWuntaint_pattern\fR" 3
.IX Item "untaint_pattern"
See above. This should be set rockin tha \f(CW\*(C`qr\*(C'\fR quotin operator.
Da default is set ta  \f(CW\*(C`qr|^([\-+@\ew./]+)$|\*(C'\fR.
Note dat tha parentheses is vital.
.ie n .IP """untaint_skip""" 3
.el .IP "\f(CWuntaint_skip\fR" 3
.IX Item "untaint_skip"
If set, a gangbangin' finger-lickin' directory which fails tha \fIuntaint_pattern\fR is skipped,
includin all its sub-directories. Put ya muthafuckin choppers up if ya feel dis! Da default is ta 'die' up in such a cold-ass lil case.
.SS "Da wanted function"
.IX Subsection "Da wanted function"
Da \f(CW\*(C`wanted()\*(C'\fR function do whatever verifications you want on
each file n' directory.  Note dat despite its name, tha \f(CW\*(C`wanted()\*(C'\fR
function be a generic callback function, n' do \fBnot\fR tell
File::Find if a gangbangin' file is \*(L"wanted\*(R" or not.  In fact, its return value
is ignored.
.PP
Da wanted function takes no arguments but rather do its work
all up in a cold-ass lil collection of variables.
.ie n .IP "$File::Find::dir is tha current directory name," 4
.el .IP "\f(CW$File::Find::dir\fR is tha current directory name," 4
.IX Item "$File::Find::dir is tha current directory name,"
.PD 0
.ie n .IP "$_ is tha current filename within dat directory" 4
.el .IP "\f(CW$_\fR is tha current filename within dat directory" 4
.IX Item "$_ is tha current filename within dat directory"
.ie n .IP "$File::Find::name is tha complete pathname ta tha file." 4
.el .IP "\f(CW$File::Find::name\fR is tha complete pathname ta tha file." 4
.IX Item "$File::Find::name is tha complete pathname ta tha file."
.PD
.PP
Da above variablez have all been localized n' may be chizzled without
affectin data outside of tha wanted function.
.PP
For example, when examinin tha file \fI/some/path/foo.ext\fR yo big-ass booty is ghon have:
.PP
.Vb 3
\&    $File::Find::dir  = /some/path/
\&    $_                = foo.ext
\&    $File::Find::name = /some/path/foo.ext
.Ve
.PP
Yo ass is \fIchdir()\fR'd ta \f(CW$File::Find::dir\fR when tha function is called,
unless \f(CW\*(C`no_chdir\*(C'\fR was specified. Y'all KNOW dat shit, muthafucka! Note dat when changin to
directories is up in effect tha root directory (\fI/\fR) be a somewhat
special case inasmuch as tha concatenation of \f(CW$File::Find::dir\fR,
\&\f(CW\*(Aq/\*(Aq\fR n' \f(CW$_\fR aint literally equal ta \f(CW$File::Find::name\fR. The
table below summarizes all variants:
.PP
.Vb 4
\&              $File::Find::name  $File::Find::dir  $_
\& default      /                  /                 .
\& no_chdir=>0  /etc               /                 etc
\&              /etc/x             /etc              x
\&
\& no_chdir=>1  /                  /                 /
\&              /etc               /                 /etc
\&              /etc/x             /etc              /etc/x
.Ve
.PP
When \f(CW\*(C`follow\*(C'\fR or \f(CW\*(C`follow_fast\*(C'\fR is up in effect, there is
also a \f(CW$File::Find::fullname\fR.  Da function may set
\&\f(CW$File::Find::prune\fR ta prune tha tree unless \f(CW\*(C`bydepth\*(C'\fR was
specified. Y'all KNOW dat shit, muthafucka!  Unless \f(CW\*(C`follow\*(C'\fR or \f(CW\*(C`follow_fast\*(C'\fR is specified, for
compatibilitizzle reasons (find.pl, find2perl) there be up in addizzle the
followin globals available: \f(CW$File::Find::topdir\fR,
\&\f(CW$File::Find::topdev\fR, \f(CW$File::Find::topino\fR,
\&\f(CW$File::Find::topmode\fR n' \f(CW$File::Find::topnlink\fR.
.PP
This library is useful fo' tha \f(CW\*(C`find2perl\*(C'\fR tool, which when fed,
.PP
.Vb 2
\&    find2perl / \-name .nfs\e* \-mtime +7 \e
\&        \-exec rm \-f {} \e; \-o \-fstype nfs \-prune
.Ve
.PP
produces suttin' like:
.PP
.Vb 10
\&    sub wanted {
\&        /^\e.nfs.*\ez/s &&
\&        (($dev, $ino, $mode, $nlink, $uid, $gid) = lstat($_)) &&
\&        int(\-M _) > 7 &&
\&        unlink($_)
\&        ||
\&        ($nlink || (($dev, $ino, $mode, $nlink, $uid, $gid) = lstat($_))) &&
\&        $dev < 0 &&
\&        ($File::Find::prune = 1);
\&    }
.Ve
.PP
Notice tha \f(CW\*(C`_\*(C'\fR up in tha above \f(CW\*(C`int(\-M _)\*(C'\fR: tha \f(CW\*(C`_\*(C'\fR be a magical
filehandle dat caches tha shiznit from tha preceding
\&\f(CW\*(C`stat()\*(C'\fR, \f(CW\*(C`lstat()\*(C'\fR, or filetest.
.PP
Herez another bangin-ass wanted function. I aint talkin' bout chicken n' gravy biatch.  It will find all symbolic
links dat don't resolve:
.PP
.Vb 3
\&    sub wanted {
\&         \-l && !\-e && print "bogus link: $File::Find::name\en";
\&    }
.Ve
.PP
Note dat you may mix directories n' (non-directory) filez up in tha list of 
directories ta be searched by tha \f(CW\*(C`wanted()\*(C'\fR function.
.PP
.Vb 1
\&    find(\e&wanted, "./foo", "./bar", "./baz/epsilon");
.Ve
.PP
In tha example above, no file up in \fI./baz/\fR other than \fI./baz/epsilon\fR will be
evaluated by \f(CW\*(C`wanted()\*(C'\fR.
.PP
See also tha script \f(CW\*(C`pfind\*(C'\fR on \s-1CPAN\s0 fo' a sick application of this
module.
.SH "WARNINGS"
.IX Header "WARNINGS"
If you run yo' program wit tha \f(CW\*(C`\-w\*(C'\fR switch, or if you use the
\&\f(CW\*(C`warnings\*(C'\fR pragma, File::Find will report warnings fo' nuff muthafuckin weird
situations. Yo ass can disable these warnings by puttin tha statement
.PP
.Vb 1
\&    no warnings \*(AqFile::Find\*(Aq;
.Ve
.PP
in tha appropriate scope. Right back up in yo muthafuckin ass. See perllexwarn fo' mo' info bout lexical
warnings.
.SH "CAVEAT"
.IX Header "CAVEAT"
.ie n .IP "$dont_use_nlink" 2
.el .IP "\f(CW$dont_use_nlink\fR" 2
.IX Item "$dont_use_nlink"
Yo ass can set tha variable \f(CW$File::Find::dont_use_nlink\fR ta 1, if you want to
force File::Find ta always stat directories. Put ya muthafuckin choppers up if ya feel dis! This was used fo' file systems
that aint gots a \f(CW\*(C`nlink\*(C'\fR count matchin tha number of sub-directories.
Examplez is \s-1ISO\-9660 \s0(CD-ROM), \s-1AFS, HPFS \s0(\s-1OS/2\s0 file system), \s-1FAT \s0(\s-1DOS\s0 file
system) n' a cold-ass lil couple others.
.Sp
Yo ass shouldn't need ta set dis variable, since File::Find should now detect
such file systems on-the-fly n' switch itself ta rockin stat. This works even
for partz of yo' file system, like a mounted CD-ROM.
.Sp
If you do set \f(CW$File::Find::dont_use_nlink\fR ta 1, yo big-ass booty is ghon notice slow-downs.
.IP "symlinks" 2
.IX Item "symlinks"
Be aware dat tha option ta follow symbolic links can be dangerous.
Dependin on tha structure of tha directory tree (includin symbolic
links ta directories) you might traverse a given (physical) directory
more than once (only if \f(CW\*(C`follow_fast\*(C'\fR is up in effect).
Furthermore, deletin or changin filez up in a symbolically linked directory
might cause straight-up unpleasant surprises, since you delete or chizzle files
in a unknown directory.
.SH "BUGS AND CAVEATS"
.IX Header "BUGS AND CAVEATS"
Despite tha name of tha \f(CW\*(C`finddepth()\*(C'\fR function, both \f(CW\*(C`find()\*(C'\fR and
\&\f(CW\*(C`finddepth()\*(C'\fR big-ass up a thugged-out depth-first search of tha directory
hierarchy.
.SH "HISTORY"
.IX Header "HISTORY"
File::Find used ta produce incorrect thangs up in dis biatch if called recursively.
Durin tha pimpment of perl 5.8 dis bug was fixed.
Da first fixed version of File::Find was 1.01.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
find, find2perl.
