'\" t
.\"     Title: glUniform
.\"    Author: opengl.org
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 08/03/2013
.\"    Manual: OpenGL Manual
.\"    Source: opengl.org
.\"  Language: Gangsta
.\"
.TH "GLUNIFORM" "3G" "08/03/2013" "opengl.org" "OpenGL Manual"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
glUniform1f, glUniform2f, glUniform3f, glUniform4f, glUniform1i, glUniform2i, glUniform3i, glUniform4i, glUniform1ui, glUniform2ui, glUniform3ui, glUniform4ui, glUniform1fv, glUniform2fv, glUniform3fv, glUniform4fv, glUniform1iv, glUniform2iv, glUniform3iv, glUniform4iv, glUniform1uiv, glUniform2uiv, glUniform3uiv, glUniform4uiv, glUniformMatrix2fv, glUniformMatrix3fv, glUniformMatrix4fv, glUniformMatrix2x3fv, glUniformMatrix3x2fv, glUniformMatrix2x4fv, glUniformMatrix4x2fv, glUniformMatrix3x4fv, glUniformMatrix4x3fv \- Specify tha value of a uniform variable fo' tha current program object
.SH "C SPECIFICATION"
.HP \w'void\ glUniform1f('u
.BI "void glUniform1f(GLint\ " "location" ", GLfloat\ " "v0" ");"
.HP \w'void\ glUniform2f('u
.BI "void glUniform2f(GLint\ " "location" ", GLfloat\ " "v0" ", GLfloat\ " "v1" ");"
.HP \w'void\ glUniform3f('u
.BI "void glUniform3f(GLint\ " "location" ", GLfloat\ " "v0" ", GLfloat\ " "v1" ", GLfloat\ " "v2" ");"
.HP \w'void\ glUniform4f('u
.BI "void glUniform4f(GLint\ " "location" ", GLfloat\ " "v0" ", GLfloat\ " "v1" ", GLfloat\ " "v2" ", GLfloat\ " "v3" ");"
.HP \w'void\ glUniform1i('u
.BI "void glUniform1i(GLint\ " "location" ", GLint\ " "v0" ");"
.HP \w'void\ glUniform2i('u
.BI "void glUniform2i(GLint\ " "location" ", GLint\ " "v0" ", GLint\ " "v1" ");"
.HP \w'void\ glUniform3i('u
.BI "void glUniform3i(GLint\ " "location" ", GLint\ " "v0" ", GLint\ " "v1" ", GLint\ " "v2" ");"
.HP \w'void\ glUniform4i('u
.BI "void glUniform4i(GLint\ " "location" ", GLint\ " "v0" ", GLint\ " "v1" ", GLint\ " "v2" ", GLint\ " "v3" ");"
.HP \w'void\ glUniform1ui('u
.BI "void glUniform1ui(GLint\ " "location" ", GLuint\ " "v0" ");"
.HP \w'void\ glUniform2ui('u
.BI "void glUniform2ui(GLint\ " "location" ", GLuint\ " "v0" ", GLuint\ " "v1" ");"
.HP \w'void\ glUniform3ui('u
.BI "void glUniform3ui(GLint\ " "location" ", GLuint\ " "v0" ", GLuint\ " "v1" ", GLuint\ " "v2" ");"
.HP \w'void\ glUniform4ui('u
.BI "void glUniform4ui(GLint\ " "location" ", GLuint\ " "v0" ", GLuint\ " "v1" ", GLuint\ " "v2" ", GLuint\ " "v3" ");"
.SH "PARAMETERS"
.PP
\fIlocation\fR
.RS 4
Specifies tha location of tha uniform variable ta be modified\&.
.RE
.PP
\fIv0\fR, \fIv1\fR, \fIv2\fR, \fIv3\fR
.RS 4
Specifies tha freshly smoked up joints ta be used fo' tha specified uniform variable\&.
.RE
.SH "C SPECIFICATION"
.HP \w'void\ glUniform1fv('u
.BI "void glUniform1fv(GLint\ " "location" ", GLsizei\ " "count" ", const\ GLfloat\ *" "value" ");"
.HP \w'void\ glUniform2fv('u
.BI "void glUniform2fv(GLint\ " "location" ", GLsizei\ " "count" ", const\ GLfloat\ *" "value" ");"
.HP \w'void\ glUniform3fv('u
.BI "void glUniform3fv(GLint\ " "location" ", GLsizei\ " "count" ", const\ GLfloat\ *" "value" ");"
.HP \w'void\ glUniform4fv('u
.BI "void glUniform4fv(GLint\ " "location" ", GLsizei\ " "count" ", const\ GLfloat\ *" "value" ");"
.HP \w'void\ glUniform1iv('u
.BI "void glUniform1iv(GLint\ " "location" ", GLsizei\ " "count" ", const\ GLint\ *" "value" ");"
.HP \w'void\ glUniform2iv('u
.BI "void glUniform2iv(GLint\ " "location" ", GLsizei\ " "count" ", const\ GLint\ *" "value" ");"
.HP \w'void\ glUniform3iv('u
.BI "void glUniform3iv(GLint\ " "location" ", GLsizei\ " "count" ", const\ GLint\ *" "value" ");"
.HP \w'void\ glUniform4iv('u
.BI "void glUniform4iv(GLint\ " "location" ", GLsizei\ " "count" ", const\ GLint\ *" "value" ");"
.HP \w'void\ glUniform1uiv('u
.BI "void glUniform1uiv(GLint\ " "location" ", GLsizei\ " "count" ", const\ GLuint\ *" "value" ");"
.HP \w'void\ glUniform2uiv('u
.BI "void glUniform2uiv(GLint\ " "location" ", GLsizei\ " "count" ", const\ GLuint\ *" "value" ");"
.HP \w'void\ glUniform3uiv('u
.BI "void glUniform3uiv(GLint\ " "location" ", GLsizei\ " "count" ", const\ GLuint\ *" "value" ");"
.HP \w'void\ glUniform4uiv('u
.BI "void glUniform4uiv(GLint\ " "location" ", GLsizei\ " "count" ", const\ GLuint\ *" "value" ");"
.SH "PARAMETERS"
.PP
\fIlocation\fR
.RS 4
Specifies tha location of tha uniform value ta be modified\&.
.RE
.PP
\fIcount\fR
.RS 4
Specifies tha number of elements dat is ta be modified\&. This should be 1 if tha targeted uniform variable aint a array, n' 1 or mo' if it be a array\&.
.RE
.PP
\fIvalue\fR
.RS 4
Specifies a pointa ta a array of
\fIcount\fR
values dat is ghon be used ta update tha specified uniform variable\&.
.RE
.SH "C SPECIFICATION"
.HP \w'void\ glUniformMatrix2fv('u
.BI "void glUniformMatrix2fv(GLint\ " "location" ", GLsizei\ " "count" ", GLboolean\ " "transpose" ", const\ GLfloat\ *" "value" ");"
.HP \w'void\ glUniformMatrix3fv('u
.BI "void glUniformMatrix3fv(GLint\ " "location" ", GLsizei\ " "count" ", GLboolean\ " "transpose" ", const\ GLfloat\ *" "value" ");"
.HP \w'void\ glUniformMatrix4fv('u
.BI "void glUniformMatrix4fv(GLint\ " "location" ", GLsizei\ " "count" ", GLboolean\ " "transpose" ", const\ GLfloat\ *" "value" ");"
.HP \w'void\ glUniformMatrix2x3fv('u
.BI "void glUniformMatrix2x3fv(GLint\ " "location" ", GLsizei\ " "count" ", GLboolean\ " "transpose" ", const\ GLfloat\ *" "value" ");"
.HP \w'void\ glUniformMatrix3x2fv('u
.BI "void glUniformMatrix3x2fv(GLint\ " "location" ", GLsizei\ " "count" ", GLboolean\ " "transpose" ", const\ GLfloat\ *" "value" ");"
.HP \w'void\ glUniformMatrix2x4fv('u
.BI "void glUniformMatrix2x4fv(GLint\ " "location" ", GLsizei\ " "count" ", GLboolean\ " "transpose" ", const\ GLfloat\ *" "value" ");"
.HP \w'void\ glUniformMatrix4x2fv('u
.BI "void glUniformMatrix4x2fv(GLint\ " "location" ", GLsizei\ " "count" ", GLboolean\ " "transpose" ", const\ GLfloat\ *" "value" ");"
.HP \w'void\ glUniformMatrix3x4fv('u
.BI "void glUniformMatrix3x4fv(GLint\ " "location" ", GLsizei\ " "count" ", GLboolean\ " "transpose" ", const\ GLfloat\ *" "value" ");"
.HP \w'void\ glUniformMatrix4x3fv('u
.BI "void glUniformMatrix4x3fv(GLint\ " "location" ", GLsizei\ " "count" ", GLboolean\ " "transpose" ", const\ GLfloat\ *" "value" ");"
.SH "PARAMETERS"
.PP
\fIlocation\fR
.RS 4
Specifies tha location of tha uniform value ta be modified\&.
.RE
.PP
\fIcount\fR
.RS 4
Specifies tha number of matrices dat is ta be modified\&. This should be 1 if tha targeted uniform variable aint a array of matrices, n' 1 or mo' if it be a array of matrices\&.
.RE
.PP
\fItranspose\fR
.RS 4
Specifies whether ta transpose tha matrix as tha joints is loaded tha fuck into tha uniform variable\&.
.RE
.PP
\fIvalue\fR
.RS 4
Specifies a pointa ta a array of
\fIcount\fR
values dat is ghon be used ta update tha specified uniform variable\&.
.RE
.SH "DESCRIPTION"
.PP
\fBglUniform\fR
modifies tha value of a uniform variable or a uniform variable array\&. Da location of tha uniform variable ta be modified is specified by
\fIlocation\fR, which should be a value returned by
\fBglGetUniformLocation\fR()\&.
\fBglUniform\fR
operates on tha program object dat was made part of current state by calling
\fBglUseProgram\fR()\&.
.PP
Da commands
\fBglUniform{1|2|3|4}{f|i|ui}\fR
are used ta chizzle tha value of tha uniform variable specified by
\fIlocation\fR
usin tha joints passed as arguments\&. Da number specified up in tha command should match tha number of components up in tha data type of tha specified uniform variable (e\&.g\&.,
\fB1\fR
for
float,
int,
unsigned int,
bool;
\fB2\fR
for
vec2,
ivec2,
uvec2,
bvec2, etc\&.)\&. Da suffix
\fBf\fR
indicates dat floating\-point joints is bein passed; tha suffix
\fBi\fR
indicates dat integer joints is bein passed; tha suffix
\fBui\fR
indicates dat unsigned integer joints is bein passed, n' dis type should also match tha data type of tha specified uniform variable\&. The
\fBi\fR
variantz of dis function should be used ta provide joints fo' uniform variablez defined as
int,
ivec2,
ivec3,
ivec4, or arrayz of these\&. The
\fBui\fR
variantz of dis function should be used ta provide joints fo' uniform variablez defined as
unsigned int,
uvec2,
uvec3,
uvec4, or arrayz of these\&. The
\fBf\fR
variants should be used ta provide joints fo' uniform variablez of type
float,
vec2,
vec3,
vec4, or arrayz of these\&. Either the
\fBi\fR,
\fBui\fR
or
\fBf\fR
variants may be used ta provide joints fo' uniform variablez of type
bool,
bvec2,
bvec3,
bvec4, or arrayz of these\&. Da uniform variable is ghon be set to
false
if tha input value is 0 or 0\&.0f, n' it is ghon be set to
true
otherwise\&.
.PP
All actizzle uniform variablez defined up in a program object is initialized ta 0 when tha program object is linked successfully\&. They retain tha joints assigned ta dem by a cold-ass lil call to
\fBglUniform \fR
until tha next successful link operation occurs on tha program object, when they is once again n' again n' again initialized ta 0\&.
.PP
Da commands
\fBglUniform{1|2|3|4}{f|i|ui}v\fR
can be used ta modify a single uniform variable or a uniform variable array\&. These commandz pass a cold-ass lil count n' a pointa ta tha joints ta be loaded tha fuck into a uniform variable or a uniform variable array\& fo' realz. A count of 1 should be used if modifyin tha value of a single uniform variable, n' a cold-ass lil count of 1 or pimped outa can be used ta modify a entire array or part of a array\&. When loading
\fIn\fR
elements startin at a arbitrary position
\fIm\fR
in a uniform variable array, elements
\fIm\fR
+
\fIn\fR
\- 1 up in tha array is ghon be replaced wit tha freshly smoked up joints\&. If
\fIm\fR
+
\fIn\fR
\- 1 is larger than tha size of tha uniform variable array, joints fo' all array elements beyond tha end of tha array is ghon be ignored\&. Da number specified up in tha name of tha command indicates tha number of components fo' each element in
\fIvalue\fR, n' it should match tha number of components up in tha data type of tha specified uniform variable (e\&.g\&.,
\fB1\fR
for float, int, bool;
\fB2\fR
for vec2, ivec2, bvec2, etc\&.)\&. Da data type specified up in tha name of tha command must match tha data type fo' tha specified uniform variable as busted lyrics bout previously for
\fBglUniform{1|2|3|4}{f|i|ui}\fR\&.
.PP
For uniform variable arrays, each element of tha array is considered ta be of tha type indicated up in tha name of tha command (e\&.g\&.,
\fBglUniform3f\fR
or
\fBglUniform3fv\fR
can be used ta load a uniform variable array of type vec3)\&. Da number of elementz of tha uniform variable array ta be modified is specified by
\fIcount\fR
.PP
Da commands
\fBglUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv\fR
are used ta modify a matrix or a array of matrices\&. Da numbers up in tha command name is interpreted as tha dimensionalitizzle of tha matrix\&. Da number
\fB2\fR
indicates a 2 \(mu 2 matrix (i\&.e\&., 4 joints), tha number
\fB3\fR
indicates a 3 \(mu 3 matrix (i\&.e\&., 9 joints), n' tha number
\fB4\fR
indicates a 4 \(mu 4 matrix (i\&.e\&., 16 joints)\&. Non\-square matrix dimensionalitizzle is explicit, wit tha straight-up original gangsta number representin tha number of columns n' tha second number representin tha number of rows\&. For example,
\fB2x4\fR
indicates a 2 \(mu 4 matrix wit 2 columns n' 4 rows (i\&.e\&., 8 joints)\&. If
\fItranspose\fR
is
\fBGL_FALSE\fR, each matrix be assumed ta be supplied up in column major order\&. If
\fItranspose\fR
is
\fBGL_TRUE\fR, each matrix be assumed ta be supplied up in row major order\&. The
\fIcount\fR
argument indicates tha number of matrices ta be passed\& fo' realz. A count of 1 should be used if modifyin tha value of a single matrix, n' a cold-ass lil count pimped outa than 1 can be used ta modify a array of matrices\&.
.SH "NOTES"
.PP
\fBglUniform1i\fR
and
\fBglUniform1iv\fR
are tha only two functions dat may be used ta load uniform variablez defined as sampla types\&. Loadin samplaz wit any other function will result up in a
\fBGL_INVALID_OPERATION\fR
error\&.
.PP
If
\fIcount\fR
is pimped outa than 1 n' tha indicated uniform variable aint a array, a
\fBGL_INVALID_OPERATION\fR
error is generated n' tha specified uniform variable will remain unchanged\&.
.PP
Other than tha precedin exceptions, if tha type n' size of tha uniform variable as defined up in tha shader do not match tha type n' size specified up in tha name of tha command used ta load its value, a
\fBGL_INVALID_OPERATION\fR
error is ghon be generated n' tha specified uniform variable will remain unchanged\&.
.PP
If
\fIlocation\fR
is a value other than \-1 n' it do not represent a valid uniform variable location up in tha current program object, a error is ghon be generated, n' no chizzlez is ghon be made ta tha uniform variable storage of tha current program object\&. If
\fIlocation\fR
is equal ta \-1, tha data passed up in is ghon be silently ignored n' tha specified uniform variable aint gonna be chizzled\&.
.SH "ERRORS"
.PP
\fBGL_INVALID_OPERATION\fR
is generated if there is no current program object\&.
.PP
\fBGL_INVALID_OPERATION\fR
is generated if tha size of tha uniform variable declared up in tha shader do not match tha size indicated by the
\fBglUniform\fR
command\&.
.PP
\fBGL_INVALID_OPERATION\fR
is generated if one of tha signed or unsigned integer variantz of dis function is used ta load a uniform variable of type
float,
vec2,
vec3,
vec4, or a array of these, or if one of tha floating\-point variantz of dis function is used ta load a uniform variable of type
int,
ivec2,
ivec3,
ivec4,
unsigned int,
uvec2,
uvec3,
uvec4, or a array of these\&.
.PP
\fBGL_INVALID_OPERATION\fR
is generated if one of tha signed integer variantz of dis function is used ta load a uniform variable of type
unsigned int,
uvec2,
uvec3,
uvec4, or a array of these\&.
.PP
\fBGL_INVALID_OPERATION\fR
is generated if one of tha unsigned integer variantz of dis function is used ta load a uniform variable of type
int,
ivec2,
ivec3,
ivec4, or a array of these\&.
.PP
\fBGL_INVALID_OPERATION\fR
is generated if
\fIlocation\fR
is a invalid uniform location fo' tha current program object and
\fIlocation\fR
is not equal ta \-1\&.
.PP
\fBGL_INVALID_VALUE\fR
is generated if
\fIcount\fR
is less than 0\&.
.PP
\fBGL_INVALID_OPERATION\fR
is generated if
\fIcount\fR
is pimped outa than 1 n' tha indicated uniform variable aint a array variable\&.
.PP
\fBGL_INVALID_OPERATION\fR
is generated if a sampla is loaded rockin a cold-ass lil command other than
\fBglUniform1i\fR
and
\fBglUniform1iv\fR\&.
.SH "ASSOCIATED GETS"
.PP
\fBglGet\fR()
with tha argument
\fBGL_CURRENT_PROGRAM\fR
.PP
\fBglGetActiveUniform\fR()
with tha handle of a program object n' tha index of a actizzle uniform variable
.PP
\fBglGetUniform\fR()
with tha handle of a program object n' tha location of a uniform variable
.PP
\fBglGetUniformLocation\fR()
with tha handle of a program object n' tha name of a uniform variable
.SH "SEE ALSO"
.PP
\fBglLinkProgram\fR(),
\fBglUseProgram\fR()
.SH "COPYRIGHT"
.PP
Copyright
\(co
2003\-2005 3Dlabs Inc\&. Ltd\&. Copyright
\(co
2010 Khronos Group\&. This material may be distributed subject ta tha terms n' conditions set forth up in tha Open Publication License, v 1\&.0, 8 June 1999\&.
\m[blue]\fBhttp://opencontent\&.org/openpub/\fR\m[]\&.
.SH "AUTHORS"
.PP
\fBopengl\&.org\fR
