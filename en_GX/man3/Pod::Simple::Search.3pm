.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Simple::Search 3"
.TH Pod::Simple::Search 3 "2013-05-03" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Simple::Search \- find POD documents up in directory trees
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use Pod::Simple::Search;
\&  mah $name2path = Pod::Simple::Search\->new\->limit_glob(\*(AqLWP::*\*(Aq)\->survey;
\&  print "Looky peep what tha fuck I found: ",
\&    join(\*(Aq \*(Aq, sort keys %$name2path), "\en";
\&
\&  print "LWPUA docs = ",
\&    Pod::Simple::Search\->new\->find(\*(AqLWP::UserAgent\*(Aq) || "?",
\&    "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBPod::Simple::Search\fR be a cold-ass lil class dat you use fo' hustlin searches
for Pod files.  An object of dis class has nuff muthafuckin attributes
(mostly options fo' controllin search options), n' some methods
for searchin based on dem attributes.
.PP
Da way ta use dis class is ta cook up a freshly smoked up object of dis class,
set any options, n' then call one of tha search options
(probably \f(CW\*(C`survey\*(C'\fR or \f(CW\*(C`find\*(C'\fR).  Da sections below say shit bout the
syntaxes fo' bustin all dis shit.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
This class serves up tha one constructor, called \f(CW\*(C`new\*(C'\fR.
It takes no parameters:
.PP
.Vb 2
\&  use Pod::Simple::Search;
\&  mah $search = Pod::Simple::Search\->new;
.Ve
.SH "ACCESSORS"
.IX Header "ACCESSORS"
This class defines nuff muthafuckin methodz fo' settin (and, occasionally,
reading) tha contentz of a object. With two exceptions (discussed at
the end of dis section), these attributes is just fo' controllin the
way searches is carried out.
.PP
Note dat each of these return \f(CW$self\fR when you call dem as
\&\f(CW\*(C`$self\->\f(CIwhatever(value)\f(CW\*(C'\fR.  Thatz so dat you can chain
together set-attribute calls like this:
.PP
.Vb 4
\&  mah $name2path =
\&    Pod::Simple::Search\->new
\&    \-> inc(0) \-> verbose(1) \-> callback(\e&blab)
\&    \->survey(@there);
.Ve
.PP
\&...which works exactly as if you'd done this:
.PP
.Vb 5
\&  mah $search = Pod::Simple::Search\->new;
\&  $search\->inc(0);
\&  $search\->verbose(1);
\&  $search\->callback(\e&blab);
\&  mah $name2path = $search\->survey(@there);
.Ve
.ie n .IP "$search\->inc( \fItrue-or-false\fR );" 4
.el .IP "\f(CW$search\fR\->inc( \fItrue-or-false\fR );" 4
.IX Item "$search->inc( true-or-false );"
This attribute, if set ta a legit value, means dat searches should
implicitly add perlz \fI\f(CI@INC\fI\fR paths. This
automatically considaz paths specified up in tha \f(CW\*(C`PERL5LIB\*(C'\fR environment
as dis is prepended ta \fI\f(CI@INC\fI\fR by tha Perl interpreta itself.
This attributez default value is \fB\s-1TRUE\s0\fR.  If you wanna search
only specific directories, set \f(CW$self\fR\->\fIinc\fR\|(0) before calling
\&\f(CW$inc\fR\->survey or \f(CW$inc\fR\->find.
.ie n .IP "$search\->verbose( \fInonnegative-number\fR );" 4
.el .IP "\f(CW$search\fR\->verbose( \fInonnegative-number\fR );" 4
.IX Item "$search->verbose( nonnegative-number );"
This attribute, if set ta a nonzero positizzle value, will make searches output
(via \f(CW\*(C`warn\*(C'\fR) notes bout what tha fuck they bustin as they do dat shit.
This option may be useful fo' debuggin a pod-related module.
This attributez default value is zero, meanin dat no \f(CW\*(C`warn\*(C'\fR lyrics
are produced. Y'all KNOW dat shit, muthafucka!  (Settin verbose ta 1 turns on some lyrics, n' setting
it ta 2 turns on even mo' lyrics, i.e., make tha followin search(es)
even mo' verbose than 1 would make em.)
.ie n .IP "$search\->limit_glob( \fIsome-glob-string\fR );" 4
.el .IP "\f(CW$search\fR\->limit_glob( \fIsome-glob-string\fR );" 4
.IX Item "$search->limit_glob( some-glob-strin );"
This option means dat you wanna limit tha thangs up in dis biatch just ta shit whose
podnames match tha given glob/wildcard expression. I aint talkin' bout chicken n' gravy biatch. For example, you
might limit yo' search ta just \*(L"LWP::*\*(R", ta search only fo' modules
startin wit \*(L"LWP::*\*(R" (but not includin tha module \*(L"\s-1LWP\*(R"\s0 itself); or
you might limit yo' search ta \*(L"LW*\*(R" ta peep only modulez whose (full)
names begin wit \*(L"\s-1LW\*(R"\s0; or you might search fo' \*(L"*Find*\*(R" ta search for
all modulez wit \*(L"Find\*(R" somewhere up in they full name. (Yo ass can also use
\&\*(L"?\*(R" up in a glob expression; so \*(L"\s-1DB\s0?\*(R" will match \*(L"\s-1DBI\*(R"\s0 n' \*(L"\s-1DBD\*(R".\s0)
.ie n .IP "$search\->callback( \fI\e&some_routine\fR );" 4
.el .IP "\f(CW$search\fR\->callback( \fI\e&some_routine\fR );" 4
.IX Item "$search->callback( &some_routine );"
This attribute means dat every last muthafuckin time dis search sees a matching
Pod file, it should call dis callback routine.  Da routine is called
with two parameters: tha current filez filespec, n' its pod name.
(For example: \f(CW\*(C`("/etc/perljunk/File/Crunk.pm", "File::Crunk")\*(C'\fR would
be up in \f(CW@_\fR.)
.Sp
Da callback routinez return value aint used fo' anything.
.Sp
This attributez default value is false, meanin dat no callback
is called.
.ie n .IP "$search\->laborious( \fItrue-or-false\fR );" 4
.el .IP "\f(CW$search\fR\->laborious( \fItrue-or-false\fR );" 4
.IX Item "$search->laborious( true-or-false );"
Unless you set dis attribute ta a legit value, Pod::Search will 
apply Perl-specific heuristics ta find tha erect module PODs doggystyle.
This attributez default value is false.  Yo ass won't normally need
to set dis ta true.
.Sp
Specifically: Turnin on dis option will disable tha heuristics for
seein only filez wit Perl-like extensions, omittin subdirectories
that is numeric but do \fInot\fR match tha current Perl interpreter's
version \s-1ID,\s0 suppressin \fIsite_perl\fR as a module hierarchy name, etc.
.ie n .IP "$search\->shadows( \fItrue-or-false\fR );" 4
.el .IP "\f(CW$search\fR\->shadows( \fItrue-or-false\fR );" 4
.IX Item "$search->shadows( true-or-false );"
Unless you set dis attribute ta a legit value, Pod::Simple::Search will
consider only tha straight-up original gangsta file of a given modulename as it looks thru the
specified directories; dat is, wit dis option off, if
Pod::Simple::Search has peeped a \f(CW\*(C`somepathdir/Foo/Bar.pm\*(C'\fR already up in this
search, then it won't bother lookin at a \f(CW\*(C`somelaterpathdir/Foo/Bar.pm\*(C'\fR
lata on up in dat search, cuz dat file is merely a \*(L"shadow\*(R". But if
you turn on \f(CW\*(C`$self\->shadows(1)\*(C'\fR, then these \*(L"shadow\*(R" filez are
inspected too, n' is noted up in tha pathname2podname return hash.
.Sp
This attributez default value is false; n' normally you won't
need ta turn it on.
.ie n .IP "$search\->limit_re( \fIsome-regxp\fR );" 4
.el .IP "\f(CW$search\fR\->limit_re( \fIsome-regxp\fR );" 4
.IX Item "$search->limit_re( some-regxp );"
Settin dis attribute (to a value thatz a regexp) means dat you want
to limit tha thangs up in dis biatch just ta shit whose podnames match tha given
regexp. Normally dis option aint needed, n' tha mo' efficient
\&\f(CW\*(C`limit_glob\*(C'\fR attribute is used instead.
.ie n .IP "$search\->dir_prefix( \fIsome-string-value\fR );" 4
.el .IP "\f(CW$search\fR\->dir_prefix( \fIsome-string-value\fR );" 4
.IX Item "$search->dir_prefix( some-string-value );"
Settin dis attribute ta a strang value means dat tha searches should
begin up in tha specified subdirectory name (like \*(L"Pod\*(R" or \*(L"File::Find\*(R",
also expressable as \*(L"File/Find\*(R"). For example, tha search option
\&\f(CW\*(C`$search\->limit_glob("File::Find::R*")\*(C'\fR
is tha same ol' dirty as tha combination of tha search options
\&\f(CW\*(C`$search\->limit_re("^File::Find::R") \-> dir_prefix("File::Find")\*(C'\fR.
.Sp
Normally you don't need ta know bout tha \f(CW\*(C`dir_prefix\*(C'\fR option yo, but I
include it up in case it might prove useful fo' one of mah thugs somewhere.
.Sp
(Implementationally, searchin wit limit_glob endz up settin limit_re
and probably dir_prefix.)
.ie n .IP "$search\->progress( \fIsome-progress-object\fR );" 4
.el .IP "\f(CW$search\fR\->progress( \fIsome-progress-object\fR );" 4
.IX Item "$search->progress( some-progress-object );"
If you set a value fo' dis attribute, tha value is expected
to be a object (probably of a cold-ass lil class dat you define) dat has a 
\&\f(CW\*(C`reach\*(C'\fR method n' a \f(CW\*(C`done\*(C'\fR method. Y'all KNOW dat shit, muthafucka!  This is meant fo' reporting
progress durin tha search, if you don't wanna bust a simple
callback.
.Sp
Normally you don't need ta know bout tha \f(CW\*(C`progress\*(C'\fR option yo, but I
include it up in case it might prove useful fo' one of mah thugs somewhere.
.Sp
While a search is up in progress, tha progress objectz \f(CW\*(C`reach\*(C'\fR and
\&\f(CW\*(C`done\*(C'\fR methodz is called like this:
.Sp
.Vb 2
\&  # Every time a gangbangin' file is bein scanned fo' pod:
\&  $progress\->reach($count, "Scannin $file");   ++$count;
\&
\&  # And then all up in tha end of tha search:
\&  $progress\->done("Noted $count Pod filez total");
.Ve
.Sp
Internally, we often set dis ta a object of class
Pod::Simple::Progress.  That class is probably undocumented,
but you may wish ta peep its source.
.ie n .IP "$name2path = $self\->name2path;" 4
.el .IP "\f(CW$name2path\fR = \f(CW$self\fR\->name2path;" 4
.IX Item "$name2path = $self->name2path;"
This attribute aint a search parameter yo, but is used ta report the
result of \f(CW\*(C`survey\*(C'\fR method, as discussed up in tha next section.
.ie n .IP "$path2name = $self\->path2name;" 4
.el .IP "\f(CW$path2name\fR = \f(CW$self\fR\->path2name;" 4
.IX Item "$path2name = $self->path2name;"
This attribute aint a search parameter yo, but is used ta report the
result of \f(CW\*(C`survey\*(C'\fR method, as discussed up in tha next section.
.SH "MAIN SEARCH METHODS"
.IX Header "MAIN SEARCH METHODS"
Once you've straight-up set any options you want (if any), you can go
ahead n' use tha followin methodz ta search fo' Pod files
in particular ways.
.ie n .SS """$search\->survey( @directories )"""
.el .SS "\f(CW$search\->survey( @directories )\fP"
.IX Subsection "$search->survey( @directories )"
Da method \f(CW\*(C`survey\*(C'\fR searches fo' \s-1POD\s0 documents up in a given set of
filez and/or directories. Put ya muthafuckin choppers up if ya feel dis!  This runs tha search accordin ta tha various
options set by tha accessors above.  (For example, if tha \f(CW\*(C`inc\*(C'\fR attribute
is on, as it is by default, then tha perl \f(CW@INC\fR directories is implicitly
added ta tha list of directories (if any) dat you specify.)
.PP
Da return value of \f(CW\*(C`survey\*(C'\fR is two hashes:
.ie n .IP """name2path""" 4
.el .IP "\f(CWname2path\fR" 4
.IX Item "name2path"
A hash dat maps from each pod-name ta tha filespec (like
\&\*(L"Stuff::Thing\*(R" => \*(L"/whatever/plib/Stuff/Thing.pm\*(R")
.ie n .IP """path2name""" 4
.el .IP "\f(CWpath2name\fR" 4
.IX Item "path2name"
A hash dat maps from each Pod filespec ta its pod-name (like
\&\*(L"/whatever/plib/Stuff/Thing.pm\*(R" => \*(L"Stuff::Thing\*(R")
.PP
Besides savin these hashes as tha hashref attributes
\&\f(CW\*(C`name2path\*(C'\fR n' \f(CW\*(C`path2name\*(C'\fR, callin dis function also returns
these hashrefs.  In list context, tha return value of
\&\f(CW\*(C`$search\->survey\*(C'\fR is tha list \f(CW\*(C`(\e%name2path, \e%path2name)\*(C'\fR.
In scalar context, tha return value is \f(CW\*(C`\e%name2path\*(C'\fR.
Or you can just call dis up in void context.
.PP
Regardless of callin context, callin \f(CW\*(C`survey\*(C'\fR saves
its thangs up in dis biatch up in its \f(CW\*(C`name2path\*(C'\fR n' \f(CW\*(C`path2name\*(C'\fR attributes.
.PP
E.g., when searchin up in \fI\f(CI$HOME\fI/perl5lib\fR, tha file
\&\fI\f(CI$HOME\fI/perl5lib/MyModule.pm\fR would git tha \s-1POD\s0 name \fIMyModule\fR,
whereas \fI\f(CI$HOME\fI/perl5lib/Myclass/Subclass.pm\fR would be
\&\fIMyclass::Subclass\fR. Da name shiznit can be used fo' \s-1POD\s0
translators.
.PP
Only text filez containin at least one valid \s-1POD\s0 command is found.
.PP
In verbose mode, a warnin is printed if shadows is found (i.e., more
than one \s-1POD\s0 file wit tha same \s-1POD\s0 name is found, e.g. \fI\s-1CPAN\s0.pm\fR in
different directories).  This probably indicates duplicate occurrences of
modulez up in tha \fI\f(CI@INC\fI\fR search path, which is occasionally inadvertent
(but is often simply a cold-ass lil case of a userz path dir havin a mo' recent
version than tha systemz general path dirs up in general.)
.PP
Da options ta dis argument be a list of either directories dat are
searched recursively, or files.  (Usually you wouldn't specify files,
but just dirs.)  Or you can just specify a empty-list, as in
\&\f(CW$name2path\fR; wit the
\&\f(CW\*(C`inc\*(C'\fR option on, as it is by default, teh
.PP
Da \s-1POD\s0 namez of filez is tha plain basenames wit any Perl-like
extension (.pm, .pl, .pod) stripped, n' path separators replaced by
\&\f(CW\*(C`::\*(C'\fR's.
.PP
Callin Pod::Simple::Search\->search(...) is short for
Pod::Simple::Search\->new\->search(...).  That is, a throwaway object
with default attribute joints is used.
.ie n .SS """$search\->simplify_name( $str )"""
.el .SS "\f(CW$search\->simplify_name( $str )\fP"
.IX Subsection "$search->simplify_name( $str )"
Da method \fBsimplify_name\fR is equivalent ta \fBbasename\fR yo, but also
strips Perl-like extensions (.pm, .pl, .pod) n' extensions like
\&\fI.bat\fR, \fI.cmd\fR on Win32 n' \s-1OS/2,\s0 or \fI.com\fR on \s-1VMS,\s0 respectively.
.ie n .SS """$search\->find( $pod )"""
.el .SS "\f(CW$search\->find( $pod )\fP"
.IX Subsection "$search->find( $pod )"
.ie n .SS """$search\->find( $pod, @search_dirs )"""
.el .SS "\f(CW$search\->find( $pod, @search_dirs )\fP"
.IX Subsection "$search->find( $pod, @search_dirs )"
Returns tha location of a Pod file, given a Pod/module/script name
(like \*(L"Foo::Bar\*(R" or \*(L"perlvar\*(R" or \*(L"perldoc\*(R"), n' a scam of
what files/directories ta look in.
It searches accordin ta tha various options set by tha accessors above.
(For example, if tha \f(CW\*(C`inc\*(C'\fR attribute is on, as it is by default, then
the perl \f(CW@INC\fR directories is implicitly added ta tha list of
directories (if any) dat you specify.)
.PP
This returns tha full path of tha straight-up original gangsta occurrence ta tha file.
Package names (eg 'A::B') is automatically converted ta directory
names up in tha selected directory.  Additionally, '.pm', '.pl' n' '.pod'
are automatically appended ta tha search as required.
(So, fo' example, under Unix, \*(L"A::B\*(R" is converted ta \*(L"somedir/A/B.pm\*(R",
\&\*(L"somedir/A/B.pod\*(R", or \*(L"somedir/A/B.pl\*(R", as appropriate.)
.PP
If no such Pod file is found, dis method returns undef.
.PP
If any of tha given search directories gotz nuff a \fIpod/\fR subdirectory,
then it is searched. Y'all KNOW dat shit, muthafucka!  (Thatz how tha fuck we manage ta find \fIperlfunc\fR,
for example, which is probably up in \fIpod/perlfunc\fR up in most Perl dists.)
.PP
Da \f(CW\*(C`verbose\*(C'\fR n' \f(CW\*(C`inc\*(C'\fR attributes influence tha behavior of this
search; notably, \f(CW\*(C`inc\*(C'\fR, if true, addz \f(CW@INC\fR \fIand also
\&\f(CI$Config::Config\fI{'scriptdir'}\fR ta tha list of directories ta search.
.PP
It be common ta simply say \f(CW\*(C`$filename = Pod::Simple::Search\-> freshly smoked up 
\&\->find("perlvar")\*(C'\fR so dat just tha \f(CW@INC\fR (well, n' scriptdir)
directories is searched. Y'all KNOW dat shit, muthafucka!  (This happens cuz tha \f(CW\*(C`inc\*(C'\fR
attribute is legit by default.)
.PP
Callin Pod::Simple::Search\->find(...) is short for
Pod::Simple::Search\->new\->find(...).  That is, a throwaway object
with default attribute joints is used.
.ie n .SS """$self\->gotz nuff_pod( $file )"""
.el .SS "\f(CW$self\->gotz nuff_pod( $file )\fP"
.IX Subsection "$self->gotz nuff_pod( $file )"
Returns legit if tha supplied filename (not \s-1POD\s0 module) gotz nuff some Pod
documentation.
=head1 \s-1SUPPORT\s0
.PP
Thangs or rap bout \s-1POD\s0 n' Pod::Simple should be busted ta the
pod\-people@perl.org mail list. Right back up in yo muthafuckin ass. Send a empty email to
pod\-people\-subscribe@perl.org ta subscribe.
.PP
This module is managed up in a open GitHub repository,
<https://github.com/theory/pod\-simple/>. Feel free ta fork n' contribute, or
to clone <git://github.com/theory/pod\-simple.git> n' bust patches!
.PP
Patches against Pod::Simple is welcome. Please bust bug reports to
<bug\-pod\-simple@rt.cpan.org>.
.SH "COPYRIGHT AND DISCLAIMERS"
.IX Header "COPYRIGHT AND DISCLAIMERS"
Copyright (c) 2002 Shizzle M. Burke.
.PP
This library is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
This program is distributed up in tha hope dat it is ghon be useful yo, but
without any warranty; without even tha implied warranty of
merchantabilitizzle or fitnizz fo' a particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pod::Simple was pimped by Shizzle M. Burke <sburke@cpan.org> wit code borrowed
from Marek Rouchalz Pod::Find, which up in turn heavily borrowed code from
Nick Ing\-Simmons' \f(CW\*(C`PodToHtml\*(C'\fR.
.PP
But don't bother him, he retired.
.PP
Pod::Simple is maintained by:
.IP "\(bu" 4
Allison Randal \f(CW\*(C`allison@perl.org\*(C'\fR
.IP "\(bu" 4
Hans Dieta Pearcey \f(CW\*(C`hdp@cpan.org\*(C'\fR
.IP "\(bu" 4
Dizzy E. Wheela \f(CW\*(C`dwheeler@cpan.org\*(C'\fR
