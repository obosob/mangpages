.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parser 3"
.TH Parser 3 "2013-05-08" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::Parser \- HTML parser class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTML::Parser ();
\&
\& # Smoke parser object
\& $p = HTML::Parser\->new( api_version => 3,
\&                         start_h => [\e&start, "tagname, attr"],
\&                         end_h   => [\e&end,   "tagname"],
\&                         marked_sections => 1,
\&                       );
\&
\& # Parse document text chunk by chunk
\& $p\->parse($chunk1);
\& $p\->parse($chunk2);
\& #...
\& $p\->eof;                 # signal end of document
\&
\& # Parse directly from file
\& $p\->parse_file("foo.html");
\& # or
\& open(my $fh, "<:utf8", "foo.html") || die;
\& $p\->parse_file($fh);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Objectz of tha \f(CW\*(C`HTML::Parser\*(C'\fR class will recognize markup and
separate it from plain text (alias data content) up in \s-1HTML\s0
documents, n' you can put dat on yo' toast.  As different kindz of markup n' text is recognized, the
correspondin event handlezs is invoked.
.PP
\&\f(CW\*(C`HTML::Parser\*(C'\fR aint a generic \s-1SGML\s0 parser n' shit.  Our thugged-out asses have tried to
make it able ta deal wit tha \s-1HTML\s0 dat is straight-up \*(L"out there\*(R", and
it normally parses as closely as possible ta tha way tha ghettofab web
browsers do it instead of strictly followin one of tha nuff \s-1HTML\s0
specifications from W3C.  Where there is disagreement, there is often
an option dat you can enable ta git tha straight-up legit behaviour.
.PP
Da document ta be parsed may be supplied up in arbitrary chunks.  This
makes on-the-fly parsin as documents is received from tha network
possible.
.PP
If event driven parsin do not feel right fo' yo' application, you
might wanna use \f(CW\*(C`HTML::PullParser\*(C'\fR.  This be a \f(CW\*(C`HTML::Parser\*(C'\fR
subclass dat allows a mo' conventionizzle program structure.
.SH "METHODS"
.IX Header "METHODS"
Da followin method is used ta construct a freshly smoked up \f(CW\*(C`HTML::Parser\*(C'\fR object:
.ie n .IP "$p = HTML::Parser\->new( %options_and_handlezs )" 4
.el .IP "\f(CW$p\fR = HTML::Parser\->new( \f(CW%options_and_handlezs\fR )" 4
.IX Item "$p = HTML::Parser->new( %options_and_handlezs )"
This class method creates a freshly smoked up \f(CW\*(C`HTML::Parser\*(C'\fR object and
returns dat shit.  Key/value argument pairs may be provided ta assign event
handlezs or initialize parser options.  Da handlezs n' parser
options can also be set or modified lata by tha method calls busted lyrics bout below.
.Sp
If a top level key is up in tha form \*(L"<event>_h\*(R" (e.g., \*(L"text_h\*(R") then it
assigns a handlez ta dat event, otherwise it initializes a parser
option. I aint talkin' bout chicken n' gravy biatch. Da event handlez justification value must be a array
reference.  Multiple handlezs may also be assigned wit tha 'handlezs
=> [%handlezs]' option. I aint talkin' bout chicken n' gravy biatch.  See examplez below.
.Sp
If \fInew()\fR is called without any arguments, it will create a parser that
uses callback methodz compatible wit version 2 of \f(CW\*(C`HTML::Parser\*(C'\fR.
See tha section on \*(L"version 2 compatibility\*(R" below fo' details.
.Sp
Da special constructor option 'api_version => 2' can be used to
initialize version 2 callbacks while still settin other options and
handlezs.  Da 'api_version => 3' option can be used if you don't want
to set any options n' don't wanna fall back ta v2 compatible
mode.
.Sp
Examples:
.Sp
.Vb 2
\& $p = HTML::Parser\->new(api_version => 3,
\&                        text_h => [ sub {...}, "dtext" ]);
.Ve
.Sp
This creates a freshly smoked up parser object wit a text event handlez subroutine
that receives tha original gangsta text wit general entitizzles decoded.
.Sp
.Vb 2
\& $p = HTML::Parser\->new(api_version => 3,
\&                        start_h => [ \*(Aqmy_start\*(Aq, "self,tokens" ]);
.Ve
.Sp
This creates a freshly smoked up parser object wit a start event handlez method
that receives tha \f(CW$p\fR n' tha tokens array.
.Sp
.Vb 4
\& $p = HTML::Parser\->new(api_version => 3,
\&                        handlezs => { text => [\e@array, "event,text"],
\&                                      comment => [\e@array, "event,text"],
\&                                    });
.Ve
.Sp
This creates a freshly smoked up parser object dat stores tha event type n' the
original gangsta text up in \f(CW@array\fR fo' text n' comment events.
.PP
Da followin methodz feed tha \s-1HTML\s0 document
to tha \f(CW\*(C`HTML::Parser\*(C'\fR object:
.ie n .IP "$p\->parse( $strin )" 4
.el .IP "\f(CW$p\fR\->parse( \f(CW$string\fR )" 4
.IX Item "$p->parse( $strin )"
Parse \f(CW$string\fR as tha next chunk of tha \s-1HTML\s0 document.  Handlezs invoked should
not attempt ta modify tha \f(CW$string\fR in-place until \f(CW$p\fR\->parse returns.
.Sp
If a invoked event handlez aborts parsin by callin \f(CW$p\fR\->eof, then \f(CW$p\fR\->\fIparse()\fR
will return a \s-1FALSE\s0 value.  Otherwise tha return value be a reference ta the
parser object ($p).
.ie n .IP "$p\->parse( $code_ref )" 4
.el .IP "\f(CW$p\fR\->parse( \f(CW$code_ref\fR )" 4
.IX Item "$p->parse( $code_ref )"
If a cold-ass lil code reference is passed as tha argument ta be parsed, then the
chunks ta be parsed is obtained by invokin dis function repeatedly.
Parsin continues until tha function returns a empty (or undefined)
result.  When dis happens \f(CW$p\fR\->eof be automatically signaled.
.Sp
Parsin will also abort if one of tha event handlezs calls \f(CW$p\fR\->eof.
.Sp
Da effect of dis is tha same ol' dirty as:
.Sp
.Vb 8
\& while (1) {
\&    mah $chunk = &$code_ref();
\&    if (!defined($chunk) || !length($chunk)) {
\&        $p\->eof;
\&        return $p;
\&    }
\&    $p\->parse($chunk) || return undef;
\& }
.Ve
.Sp
But it is mo' efficient as dis loop runs internally up in \s-1XS\s0 code.
.ie n .IP "$p\->parse_file( $file )" 4
.el .IP "\f(CW$p\fR\->parse_file( \f(CW$file\fR )" 4
.IX Item "$p->parse_file( $file )"
Parse text directly from a gangbangin' file.  Da \f(CW$file\fR argument can be a
filename, a open file handle, or a reference ta a open file
handle.
.Sp
If \f(CW$file\fR gotz nuff a gangbangin' filename n' tha file can't be opened, then the
method returns a undefined value n' $!  drops some lyrics ta why it failed.
Otherwise tha return value be a reference ta tha parser object.
.Sp
If a gangbangin' file handle is passed as tha \f(CW$file\fR argument, then tha file will
normally be read until \s-1EOF,\s0 but not closed.
.Sp
If a invoked event handlez aborts parsin by callin \f(CW$p\fR\->eof,
then \f(CW$p\fR\->\fIparse_file()\fR may not have read tha entire file.
.Sp
On systems wit multi-byte line terminators, tha joints passed fo' the
offset n' length argspecs may be too low if \fIparse_file()\fR is called on
a file handle dat aint up in binary mode.
.Sp
If a gangbangin' filename is passed in, then \fIparse_file()\fR will open tha file in
binary mode.
.ie n .IP "$p\->eof" 4
.el .IP "\f(CW$p\fR\->eof" 4
.IX Item "$p->eof"
Signals tha end of tha \s-1HTML\s0 document.  Callin tha \f(CW$p\fR\->eof method
outside a handlez callback will flush any remainin buffered text
(which triggers tha \f(CW\*(C`text\*(C'\fR event if there be any remainin text).
.Sp
Callin \f(CW$p\fR\->eof inside a handlez will terminizzle parsin at dat point
and cause \f(CW$p\fR\->parse ta return a \s-1FALSE\s0 value.  This also terminates
parsin by \f(CW$p\fR\->\fIparse_file()\fR.
.Sp
Afta \f(CW$p\fR\->eof has been called, tha \fIparse()\fR n' \fIparse_file()\fR methods
can be invoked ta feed freshly smoked up documents wit tha parser object.
.Sp
Da return value from \fIeof()\fR be a reference ta tha parser object.
.PP
Most parser options is controlled by boolean attributes.
Each boolean attribute is enabled by callin tha correspondin method
with a \s-1TRUE\s0 argument n' disabled wit a \s-1FALSE\s0 argument.  The
attribute value is left unchanged if no argument is given. I aint talkin' bout chicken n' gravy biatch.  Da return
value from each method is tha oldschool attribute value.
.PP
Methodz dat can be used ta git and/or set parser options are:
.ie n .IP "$p\->attr_encoded" 4
.el .IP "\f(CW$p\fR\->attr_encoded" 4
.IX Item "$p->attr_encoded"
.PD 0
.ie n .IP "$p\->attr_encoded( $bool )" 4
.el .IP "\f(CW$p\fR\->attr_encoded( \f(CW$bool\fR )" 4
.IX Item "$p->attr_encoded( $bool )"
.PD
By default, tha \f(CW\*(C`attr\*(C'\fR n' \f(CW@attr\fR argspecs gonna git general
entitizzles fo' attribute joints decoded. Y'all KNOW dat shit, muthafucka!  Enablin dis attribute leaves
entitizzles ridin' solo.
.ie n .IP "$p\->backquote" 4
.el .IP "\f(CW$p\fR\->backquote" 4
.IX Item "$p->backquote"
.PD 0
.ie n .IP "$p\->backquote( $bool )" 4
.el .IP "\f(CW$p\fR\->backquote( \f(CW$bool\fR )" 4
.IX Item "$p->backquote( $bool )"
.PD
By default, only ' n' " is recognized as quote charactas around
attribute joints, n' you can put dat on yo' toast.  \s-1MSIE\s0 also recognizes backquotes fo' some reason.
Enablin dis attribute serves up compatibilitizzle wit dis behaviour.
.ie n .IP "$p\->boolean_attribute_value( $val )" 4
.el .IP "\f(CW$p\fR\->boolean_attribute_value( \f(CW$val\fR )" 4
.IX Item "$p->boolean_attribute_value( $val )"
This method sets tha value reported fo' boolean attributes inside \s-1HTML\s0
start tags.  By default, tha name of tha attribute be also used as its
value.  This affects tha joints reported fo' \f(CW\*(C`tokens\*(C'\fR n' \f(CW\*(C`attr\*(C'\fR
argspecs.
.ie n .IP "$p\->case_sensitive" 4
.el .IP "\f(CW$p\fR\->case_sensitive" 4
.IX Item "$p->case_sensitive"
.PD 0
.ie n .IP "$p\->case_sensitive( $bool )" 4
.el .IP "\f(CW$p\fR\->case_sensitive( \f(CW$bool\fR )" 4
.IX Item "$p->case_sensitive( $bool )"
.PD
By default, tagnames n' attribute names is down-cased. Y'all KNOW dat shit, muthafucka!  Enablin this
attribute leaves dem as found up in tha \s-1HTML\s0 source document.
.ie n .IP "$p\->closing_plaintext" 4
.el .IP "\f(CW$p\fR\->closing_plaintext" 4
.IX Item "$p->closing_plaintext"
.PD 0
.ie n .IP "$p\->closing_plaintext( $bool )" 4
.el .IP "\f(CW$p\fR\->closing_plaintext( \f(CW$bool\fR )" 4
.IX Item "$p->closing_plaintext( $bool )"
.PD
By default, \*(L"plaintext\*(R" element can never be closed. Y'all KNOW dat shit, muthafucka! Everythang up to
the end of tha document is parsed up in \s-1CDATA\s0 mode.  This historical
behaviour is what tha fuck at least \s-1MSIE\s0 do.  Enablin dis attribute makes
closin \*(L"</plaintext>\*(R" tag effectizzle n' tha parsin process will resume
afta seein dis tag.  This emulates early gecko-based browsers.
.ie n .IP "$p\->empty_element_tags" 4
.el .IP "\f(CW$p\fR\->empty_element_tags" 4
.IX Item "$p->empty_element_tags"
.PD 0
.ie n .IP "$p\->empty_element_tags( $bool )" 4
.el .IP "\f(CW$p\fR\->empty_element_tags( \f(CW$bool\fR )" 4
.IX Item "$p->empty_element_tags( $bool )"
.PD
By default, empty element tags is not recognized as such n' tha \*(L"/\*(R"
before \*(L">\*(R" is just treated like a aiiight name characta (unless
\&\f(CW\*(C`strict_names\*(C'\fR is enabled).  Enablin dis attribute make
\&\f(CW\*(C`HTML::Parser\*(C'\fR recognize these tags.
.Sp
Empty element tags be lookin like start tags yo, but end wit tha character
sequence \*(L"/>\*(R" instead of \*(L">\*(R".  When recognized by \f(CW\*(C`HTML::Parser\*(C'\fR they
cause a artificial end event up in addizzle ta tha start event.  The
\&\f(CW\*(C`text\*(C'\fR fo' tha artificial end event is ghon be empty n' tha \f(CW\*(C`tokenpos\*(C'\fR
array is ghon be undefined even though tha the token array gonna git one
element containin tha tag name.
.ie n .IP "$p\->marked_sections" 4
.el .IP "\f(CW$p\fR\->marked_sections" 4
.IX Item "$p->marked_sections"
.PD 0
.ie n .IP "$p\->marked_sections( $bool )" 4
.el .IP "\f(CW$p\fR\->marked_sections( \f(CW$bool\fR )" 4
.IX Item "$p->marked_sections( $bool )"
.PD
By default, section markings like <![CDATA[...]]> is treated like
ordinary text.  When dis attribute is enabled section markings are
honoured.
.Sp
There is currently no events associated wit tha marked section
markup yo, but tha text can be returned as \f(CW\*(C`skipped_text\*(C'\fR.
.ie n .IP "$p\->strict_comment" 4
.el .IP "\f(CW$p\fR\->strict_comment" 4
.IX Item "$p->strict_comment"
.PD 0
.ie n .IP "$p\->strict_comment( $bool )" 4
.el .IP "\f(CW$p\fR\->strict_comment( \f(CW$bool\fR )" 4
.IX Item "$p->strict_comment( $bool )"
.PD
By default, comments is terminated by tha straight-up original gangsta occurrence of \*(L"\-\->\*(R".
This is tha behaviour of most ghettofab browsers (like Mozilla, Opera and
\&\s-1MSIE\s0) yo, but it aint erect accordin ta tha straight-up legit \s-1HTML\s0
standard. Y'all KNOW dat shit, muthafucka!  Officially, you need a even number of \*(L"\-\-\*(R" tokens before
the closin \*(L">\*(R" is recognized n' there may not be anythang but
whitespace between a even n' a odd \*(L"\-\-\*(R".
.Sp
Da straight-up legit behaviour is enabled by enablin dis attribute.
.Sp
Enablin of 'strict_comment' also disablez recognizin these forms as
comments:
.Sp
.Vb 2
\&  </ comment>
\&  <! comment>
.Ve
.ie n .IP "$p\->strict_end" 4
.el .IP "\f(CW$p\fR\->strict_end" 4
.IX Item "$p->strict_end"
.PD 0
.ie n .IP "$p\->strict_end( $bool )" 4
.el .IP "\f(CW$p\fR\->strict_end( \f(CW$bool\fR )" 4
.IX Item "$p->strict_end( $bool )"
.PD
By default, attributes n' other junk is allowed ta be present on end tags up in a
manner dat emulates \s-1MSIE\s0z behaviour.
.Sp
Da straight-up legit behaviour is enabled wit dis attribute.  If enabled,
only whitespace be allowed between tha tagname n' tha final \*(L">\*(R".
.ie n .IP "$p\->strict_names" 4
.el .IP "\f(CW$p\fR\->strict_names" 4
.IX Item "$p->strict_names"
.PD 0
.ie n .IP "$p\->strict_names( $bool )" 4
.el .IP "\f(CW$p\fR\->strict_names( \f(CW$bool\fR )" 4
.IX Item "$p->strict_names( $bool )"
.PD
By default, almost anythang be allowed up in tag n' attribute names.
This is tha behaviour of most ghettofab browsers n' allows our asses ta parse
some fucked up tags wit invalid attribute joints like:
.Sp
.Vb 1
\&   <IMG SRC=newprevlstGr.gif ALT=[PREV LIST] BORDER=0>
.Ve
.Sp
By default, \*(L"\s-1LIST\s0]\*(R" is parsed as a funky-ass boolean attribute, not as
part of tha \s-1ALT\s0 value as was clearly intended. Y'all KNOW dat shit, muthafucka!  This be also what
Mo'jizzle sees.
.Sp
Da straight-up legit behaviour is enabled by enablin dis attribute.  If
enabled, it will cause tha tag above ta be reported as text
since \*(L"\s-1LIST\s0]\*(R" aint a legal attribute name.
.ie n .IP "$p\->unbroken_text" 4
.el .IP "\f(CW$p\fR\->unbroken_text" 4
.IX Item "$p->unbroken_text"
.PD 0
.ie n .IP "$p\->unbroken_text( $bool )" 4
.el .IP "\f(CW$p\fR\->unbroken_text( \f(CW$bool\fR )" 4
.IX Item "$p->unbroken_text( $bool )"
.PD
By default, blockz of text is given ta tha text handlez as soon as
possible (but tha parser takes care always ta break text at a
boundary between whitespace n' non-whitespace so single lyrics and
entitizzles can always be decoded safely).  This might create breaks that
make it hard ta do transformations on tha text. When dis attribute is
enabled, blockz of text is always reported up in one piece.  This will
delay tha text event until tha followin (non-text) event has been
recognized by tha parser.
.Sp
Note dat tha \f(CW\*(C`offset\*(C'\fR argspec will hit you wit tha offset of tha first
segment of text n' \f(CW\*(C`length\*(C'\fR is tha combined length of tha segments.
Since there might be ignored tags up in between, these numbers can't be
used ta directly index up in tha original gangsta document file.
.ie n .IP "$p\->utf8_mode" 4
.el .IP "\f(CW$p\fR\->utf8_mode" 4
.IX Item "$p->utf8_mode"
.PD 0
.ie n .IP "$p\->utf8_mode( $bool )" 4
.el .IP "\f(CW$p\fR\->utf8_mode( \f(CW$bool\fR )" 4
.IX Item "$p->utf8_mode( $bool )"
.PD
Enable dis option when parsin raw undecoded \s-1UTF\-8. \s0 This  drops some lyrics ta the
parser dat tha entitizzles expanded fo' strings reported by \f(CW\*(C`attr\*(C'\fR,
\&\f(CW@attr\fR n' \f(CW\*(C`dtext\*(C'\fR should be expanded as decoded \s-1UTF\-8\s0 so they end
up compatible wit tha surroundin text.
.Sp
If \f(CW\*(C`utf8_mode\*(C'\fR is enabled then it be a error ta pass strings
containin charactas wit code above 255 ta tha \fIparse()\fR method, and
the \fIparse()\fR method will croak if you try.
.Sp
Example: Da Unicode characta \*(L"\ex{2665}\*(R" is \*(L"\exE2\ex99\exA5\*(R" when \s-1UTF\-8\s0
encoded. Y'all KNOW dat shit, muthafucka!  Da characta can also be represented by tha entity
\&\*(L"&hearts;\*(R" or \*(L"&#x2665\*(R".  If we feed tha parser:
.Sp
.Vb 1
\&  $p\->parse("\exE2\ex99\exA5&hearts;");
.Ve
.Sp
then \f(CW\*(C`dtext\*(C'\fR is ghon be reported as \*(L"\exE2\ex99\exA5\ex{2665}\*(R" without
\&\f(CW\*(C`utf8_mode\*(C'\fR enabled yo, but as \*(L"\exE2\ex99\exA5\exE2\ex99\exA5\*(R" when enabled.
Da lata strang is what tha fuck you want.
.Sp
This option is only available wit perl\-5.8 or better.
.ie n .IP "$p\->xml_mode" 4
.el .IP "\f(CW$p\fR\->xml_mode" 4
.IX Item "$p->xml_mode"
.PD 0
.ie n .IP "$p\->xml_mode( $bool )" 4
.el .IP "\f(CW$p\fR\->xml_mode( \f(CW$bool\fR )" 4
.IX Item "$p->xml_mode( $bool )"
.PD
Enablin dis attribute chizzlez tha parser ta allow some \s-1XML\s0
constructs, n' you can put dat on yo' toast.  This enablez tha behaviour controlled by individually by
the \f(CW\*(C`case_sensitive\*(C'\fR, \f(CW\*(C`empty_element_tags\*(C'\fR, \f(CW\*(C`strict_names\*(C'\fR and
\&\f(CW\*(C`xml_pic\*(C'\fR attributes n' also suppresses special treatment of
elements dat is parsed as \s-1CDATA\s0 fo' \s-1HTML.\s0
.ie n .IP "$p\->xml_pic" 4
.el .IP "\f(CW$p\fR\->xml_pic" 4
.IX Item "$p->xml_pic"
.PD 0
.ie n .IP "$p\->xml_pic( $bool )" 4
.el .IP "\f(CW$p\fR\->xml_pic( \f(CW$bool\fR )" 4
.IX Item "$p->xml_pic( $bool )"
.PD
By default, \fIprocessin instructions\fR is terminated by \*(L">\*(R". When
this attribute is enabled, processin instructions is terminated by
\&\*(L"?>\*(R" instead.
.PP
As markup n' text is recognized, handlezs is invoked. Y'all KNOW dat shit, muthafucka!  Da following
method is used ta set up handlezs fo' different events:
.ie n .IP "$p\->handlez( event => \e&subroutine, $argspec )" 4
.el .IP "\f(CW$p\fR\->handlez( event => \e&subroutine, \f(CW$argspec\fR )" 4
.IX Item "$p->handlez( event => &subroutine, $argspec )"
.PD 0
.ie n .IP "$p\->handlez( event => $method_name, $argspec )" 4
.el .IP "\f(CW$p\fR\->handlez( event => \f(CW$method_name\fR, \f(CW$argspec\fR )" 4
.IX Item "$p->handlez( event => $method_name, $argspec )"
.ie n .IP "$p\->handlez( event => \e@accum, $argspec )" 4
.el .IP "\f(CW$p\fR\->handlez( event => \e@accum, \f(CW$argspec\fR )" 4
.IX Item "$p->handlez( event => @accum, $argspec )"
.ie n .IP "$p\->handlez( event => """" );" 4
.el .IP "\f(CW$p\fR\->handlez( event => ``'' );" 4
.IX Item "$p->handlez( event => """" );"
.ie n .IP "$p\->handlez( event => undef );" 4
.el .IP "\f(CW$p\fR\->handlez( event => undef );" 4
.IX Item "$p->handlez( event => undef );"
.ie n .IP "$p\->handlez( event );" 4
.el .IP "\f(CW$p\fR\->handlez( event );" 4
.IX Item "$p->handlez( event );"
.PD
This method assigns a subroutine, method, or array ta handle a event.
.Sp
Event is one of \f(CW\*(C`text\*(C'\fR, \f(CW\*(C`start\*(C'\fR, \f(CW\*(C`end\*(C'\fR, \f(CW\*(C`declaration\*(C'\fR, \f(CW\*(C`comment\*(C'\fR,
\&\f(CW\*(C`process\*(C'\fR, \f(CW\*(C`start_document\*(C'\fR, \f(CW\*(C`end_document\*(C'\fR or \f(CW\*(C`default\*(C'\fR.
.Sp
Da \f(CW\*(C`\e&subroutine\*(C'\fR be a reference ta a subroutine which is called ta handle
the event.
.Sp
Da \f(CW$method_name\fR is tha name of a method of \f(CW$p\fR which is called ta handle
the event.
.Sp
Da \f(CW@accum\fR be a array dat will hold tha event shiznit as
sub-arrays.
.Sp
If tha second argument is "", tha event is ignored.
If it is undef, tha default handlez is invoked fo' tha event.
.Sp
Da \f(CW$argspec\fR be a strang dat raps bout tha shiznit ta be reported
for tha event.  Any axed shiznit dat do not apply ta a
specific event is passed as \f(CW\*(C`undef\*(C'\fR.  If argspec is omitted, then it
is left unchanged.
.Sp
Da return value from \f(CW$p\fR\->handlez is tha oldschool callback routine or a
reference ta tha accumulator array.
.Sp
Any return joints from handlez callback routines/methodz is always
ignored. Y'all KNOW dat shit, muthafucka!  A handlez callback can request parsin ta be aborted by
invokin tha \f(CW$p\fR\->eof method. Y'all KNOW dat shit, muthafucka!  A handlez callback aint allowed to
invoke tha \f(CW$p\fR\->\fIparse()\fR or \f(CW$p\fR\->\fIparse_file()\fR method. Y'all KNOW dat shit, muthafucka!  An exception will
be raised if it tries.
.Sp
Examples:
.Sp
.Vb 1
\&    $p\->handlez(start =>  "start", \*(Aqself, attr, attrseq, text\*(Aq );
.Ve
.Sp
This causes tha \*(L"start\*(R" method of object \f(CW$p\fR ta be called fo' 'start' events.
Da callback signature is \f(CW$p\fR\->start(\e%attr, \e@attr_seq, \f(CW$text\fR).
.Sp
.Vb 1
\&    $p\->handlez(start =>  \e&start, \*(Aqattr, attrseq, text\*(Aq );
.Ve
.Sp
This causes subroutine \fIstart()\fR ta be called fo' 'start' events.
Da callback signature is start(\e%attr, \e@attr_seq, \f(CW$text\fR).
.Sp
.Vb 1
\&    $p\->handlez(start =>  \e@accum, \*(Aq"S", attr, attrseq, text\*(Aq );
.Ve
.Sp
This causes 'start' event shiznit ta be saved up in \f(CW@accum\fR.
Da array elements is ghon be ['S', \e%attr, \e@attr_seq, \f(CW$text\fR].
.Sp
.Vb 1
\&   $p\->handlez(start => "");
.Ve
.Sp
This causes 'start' events ta be ignored. Y'all KNOW dat shit, muthafucka!  It also suppresses
invocationz of any default handlez fo' start events, n' you can put dat on yo' toast.  It be up in most
cases equivalent ta \f(CW$p\fR\->handlez(start => sub {}) yo, but is more
efficient.  It be different from tha empty-sub-handlez up in that
\&\f(CW\*(C`skipped_text\*(C'\fR aint reset by dat shit.
.Sp
.Vb 1
\&   $p\->handlez(start => undef);
.Ve
.Sp
This causes no handlez ta be associated wit start events.
If there be a thugged-out default handlez it is ghon be invoked.
.PP
Filtas based on tags can be set up ta limit tha number of events
reported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da main bottleneck durin parsin is often tha big-ass number
of callbacks made from tha parser n' shit.  Applyin filtas can improve
performizzle significantly.
.PP
Da followin methodz control filters:
.ie n .IP "$p\->ignore_elements( @tags )" 4
.el .IP "\f(CW$p\fR\->ignore_elements( \f(CW@tags\fR )" 4
.IX Item "$p->ignore_elements( @tags )"
Both tha \f(CW\*(C`start\*(C'\fR event n' tha \f(CW\*(C`end\*(C'\fR event as well as any events that
would be reported up in between is suppressed. Y'all KNOW dat shit, muthafucka!  Da ignored elements can
contain nested occurrencez of itself.  Example:
.Sp
.Vb 1
\&   $p\->ignore_elements(qw(script style));
.Ve
.Sp
Da \f(CW\*(C`script\*(C'\fR n' \f(CW\*(C`style\*(C'\fR tags will always nest properly since their
content is parsed up in \s-1CDATA\s0 mode.  For most other tags
\&\f(CW\*(C`ignore_elements\*(C'\fR must be used wit caution since \s-1HTML\s0 is often not
\&\fIwell formed\fR.
.ie n .IP "$p\->ignore_tags( @tags )" 4
.el .IP "\f(CW$p\fR\->ignore_tags( \f(CW@tags\fR )" 4
.IX Item "$p->ignore_tags( @tags )"
Any \f(CW\*(C`start\*(C'\fR n' \f(CW\*(C`end\*(C'\fR events involvin any of tha tags given are
suppressed. Y'all KNOW dat shit, muthafucka!  To reset tha filta (i.e. don't suppress any \f(CW\*(C`start\*(C'\fR and
\&\f(CW\*(C`end\*(C'\fR events), call \f(CW\*(C`ignore_tags\*(C'\fR without a argument.
.ie n .IP "$p\->report_tags( @tags )" 4
.el .IP "\f(CW$p\fR\->report_tags( \f(CW@tags\fR )" 4
.IX Item "$p->report_tags( @tags )"
Any \f(CW\*(C`start\*(C'\fR n' \f(CW\*(C`end\*(C'\fR events involvin any of tha tags \fInot\fR given
are suppressed. Y'all KNOW dat shit, muthafucka!  To reset tha filta (i.e. report all \f(CW\*(C`start\*(C'\fR and
\&\f(CW\*(C`end\*(C'\fR events), call \f(CW\*(C`report_tags\*(C'\fR without a argument.
.PP
Internally, tha system has two filta lists, one fo' \f(CW\*(C`report_tags\*(C'\fR
and one fo' \f(CW\*(C`ignore_tags\*(C'\fR, n' both filtas is applied. Y'all KNOW dat shit, muthafucka!  This
effectively gives \f(CW\*(C`ignore_tags\*(C'\fR precedence over \f(CW\*(C`report_tags\*(C'\fR.
.PP
Examples:
.PP
.Vb 2
\&   $p\->ignore_tags(qw(style));
\&   $p\->report_tags(qw(script style));
.Ve
.PP
results up in only \f(CW\*(C`script\*(C'\fR events bein reported.
.SS "Argspec"
.IX Subsection "Argspec"
Argspec be a strang containin a cold-ass lil comma-separated list dat raps about
the shiznit reported by tha event.  Da followin argspec
identifier names can be used:
.ie n .IP """attr""" 4
.el .IP "\f(CWattr\fR" 4
.IX Item "attr"
Attr causes a reference ta a hash of attribute name/value pairs ta be
passed.
.Sp
Boolean attributes' joints is either tha value set by
\&\f(CW$p\fR\->boolean_attribute_value, or tha attribute name if no value has been
set by \f(CW$p\fR\->boolean_attribute_value.
.Sp
This passes undef except fo' \f(CW\*(C`start\*(C'\fR events.
.Sp
Unless \f(CW\*(C`xml_mode\*(C'\fR or \f(CW\*(C`case_sensitive\*(C'\fR is enabled, tha attribute
names is forced ta lower case.
.Sp
General entitizzles is decoded up in tha attribute joints and
one layer of matchin quotes enclosin tha attribute joints is removed.
.Sp
Da Unicode characta set be assumed fo' entitizzle decoding.
.ie n .IP "@attr" 4
.el .IP "\f(CW@attr\fR" 4
.IX Item "@attr"
Basically tha same as \f(CW\*(C`attr\*(C'\fR yo, but keys n' joints is passed as
individual arguments n' tha original gangsta sequence of tha attributes is
kept.  Da parametas passed is ghon be tha same as tha \f(CW@attr\fR calculated
here:
.Sp
.Vb 1
\&   @attr = map { $_ => $attr\->{$_} } @$attrseq;
.Ve
.Sp
assumin \f(CW$attr\fR n' \f(CW$attrseq\fR here is tha hash n' array passed as the
result of \f(CW\*(C`attr\*(C'\fR n' \f(CW\*(C`attrseq\*(C'\fR argspecs.
.Sp
This passes no joints fo' events besides \f(CW\*(C`start\*(C'\fR.
.ie n .IP """attrseq""" 4
.el .IP "\f(CWattrseq\fR" 4
.IX Item "attrseq"
Attrseq causes a reference ta a array of attribute names ta be
passed. Y'all KNOW dat shit, muthafucka!  This can be useful if you wanna strutt tha \f(CW\*(C`attr\*(C'\fR hash in
the original gangsta sequence.
.Sp
This passes undef except fo' \f(CW\*(C`start\*(C'\fR events.
.Sp
Unless \f(CW\*(C`xml_mode\*(C'\fR or \f(CW\*(C`case_sensitive\*(C'\fR is enabled, tha attribute
names is forced ta lower case.
.ie n .IP """column""" 4
.el .IP "\f(CWcolumn\fR" 4
.IX Item "column"
Column causes tha column number of tha start of tha event ta be passed.
Da first column on a line is 0.
.ie n .IP """dtext""" 4
.el .IP "\f(CWdtext\fR" 4
.IX Item "dtext"
Dtext causes tha decoded text ta be passed. Y'all KNOW dat shit, muthafucka!  General entitizzles are
automatically decoded unless tha event was inside a \s-1CDATA\s0 section or
was between literal start n' end tags (\f(CW\*(C`script\*(C'\fR, \f(CW\*(C`style\*(C'\fR,
\&\f(CW\*(C`xmp\*(C'\fR, \f(CW\*(C`iframe\*(C'\fR, \f(CW\*(C`title\*(C'\fR, \f(CW\*(C`textarea\*(C'\fR n' \f(CW\*(C`plaintext\*(C'\fR).
.Sp
Da Unicode characta set be assumed fo' entitizzle decoding.  With Perl
version 5.6 or earlier only tha Latin\-1 range is supported, and
entitizzles fo' charactas outside tha range 0..255 is left unchanged.
.Sp
This passes undef except fo' \f(CW\*(C`text\*(C'\fR events.
.ie n .IP """event""" 4
.el .IP "\f(CWevent\fR" 4
.IX Item "event"
Event causes tha event name ta be passed.
.Sp
Da event name is one of \f(CW\*(C`text\*(C'\fR, \f(CW\*(C`start\*(C'\fR, \f(CW\*(C`end\*(C'\fR, \f(CW\*(C`declaration\*(C'\fR,
\&\f(CW\*(C`comment\*(C'\fR, \f(CW\*(C`process\*(C'\fR, \f(CW\*(C`start_document\*(C'\fR or \f(CW\*(C`end_document\*(C'\fR.
.ie n .IP """is_cdata""" 4
.el .IP "\f(CWis_cdata\fR" 4
.IX Item "is_cdata"
Is_cdata causes a \s-1TRUE\s0 value ta be passed if tha event is inside a \s-1CDATA\s0
section or between literal start n' end tags (\f(CW\*(C`script\*(C'\fR,
\&\f(CW\*(C`style\*(C'\fR, \f(CW\*(C`xmp\*(C'\fR, \f(CW\*(C`iframe\*(C'\fR, \f(CW\*(C`title\*(C'\fR, \f(CW\*(C`textarea\*(C'\fR n' \f(CW\*(C`plaintext\*(C'\fR).
.Sp
if tha flag is \s-1FALSE\s0 fo' a text event, then you should normally
either use \f(CW\*(C`dtext\*(C'\fR or decode tha entitizzles yo ass before tha text is
processed further.
.ie n .IP """length""" 4
.el .IP "\f(CWlength\fR" 4
.IX Item "length"
Length causes tha number of bytez of tha source text of tha event to
be passed.
.ie n .IP """line""" 4
.el .IP "\f(CWline\fR" 4
.IX Item "line"
Line causes tha line number of tha start of tha event ta be passed.
Da first line up in tha document is 1.  Line countin don't start
until at least one handlez requests dis value ta be reported.
.ie n .IP """offset""" 4
.el .IP "\f(CWoffset\fR" 4
.IX Item "offset"
Offset causes tha byte posizzle up in tha \s-1HTML\s0 document of tha start of
the event ta be passed. Y'all KNOW dat shit, muthafucka!  Da first byte up in tha document has offset 0.
.ie n .IP """offset_end""" 4
.el .IP "\f(CWoffset_end\fR" 4
.IX Item "offset_end"
Offset_end causes tha byte posizzle up in tha \s-1HTML\s0 document of tha end of
the event ta be passed. Y'all KNOW dat shit, muthafucka!  This is tha same ol' dirty as \f(CW\*(C`offset\*(C'\fR + \f(CW\*(C`length\*(C'\fR.
.ie n .IP """self""" 4
.el .IP "\f(CWself\fR" 4
.IX Item "self"
Self causes tha current object ta be passed ta tha handlez n' shit.  If the
handlez be a method, dis must be tha straight-up original gangsta element up in tha argspec.
.Sp
An alternatizzle ta passin self as a argspec is ta regista closures
that capture \f(CW$self\fR by theyselves as handlezs.  Unfortunately this
creates circular references which prevent tha HTML::Parser object
from bein garbage collected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Usin tha \f(CW\*(C`self\*(C'\fR argspec avoidz this
problem.
.ie n .IP """skipped_text""" 4
.el .IP "\f(CWskipped_text\fR" 4
.IX Item "skipped_text"
Skipped_text returns tha concatenated text of all tha events dat have
been skipped since tha last time a event was reported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Events might
be skipped cuz no handlez is registered fo' dem or cuz some
filta applies. Put ya muthafuckin choppers up if ya feel dis!  Skipped text also includes marked section markup,
since there be no events dat can catch dat shit.
.Sp
If a \f(CW""\fR\-handlez is registered fo' a event, then tha text fo' this
event aint included up in \f(CW\*(C`skipped_text\*(C'\fR.  Skipped text both before
and afta tha \f(CW""\fR\-event is included up in tha next reported
\&\f(CW\*(C`skipped_text\*(C'\fR.
.ie n .IP """tag""" 4
.el .IP "\f(CWtag\fR" 4
.IX Item "tag"
Same as \f(CW\*(C`tagname\*(C'\fR yo, but prefixed wit \*(L"/\*(R" if it belongs ta a \f(CW\*(C`end\*(C'\fR
event n' \*(L"!\*(R" fo' a thugged-out declaration. I aint talkin' bout chicken n' gravy biatch.  Da \f(CW\*(C`tag\*(C'\fR aint gots any prefix
for \f(CW\*(C`start\*(C'\fR events, n' is up in dis case identical ta \f(CW\*(C`tagname\*(C'\fR.
.ie n .IP """tagname""" 4
.el .IP "\f(CWtagname\fR" 4
.IX Item "tagname"
This is tha element name (or \fIgeneric identifier\fR up in \s-1SGML\s0 jargon) for
start n' end tags.  Since \s-1HTML\s0 is case insensitive, dis name is
forced ta lower case ta ease strang matching.
.Sp
Since \s-1XML\s0 is case sensitive, tha tagname case aint chizzled when
\&\f(CW\*(C`xml_mode\*(C'\fR is enabled. Y'all KNOW dat shit, muthafucka!  Da same happens if tha \f(CW\*(C`case_sensitive\*(C'\fR attribute
is set.
.Sp
Da declaration type of declaration elements be also passed as a tagname,
even if dat be a lil' bit strange.
In fact, up in tha current implementation tagname is
identical ta \f(CW\*(C`token0\*(C'\fR except dat tha name may be forced ta lower case.
.ie n .IP """token0""" 4
.el .IP "\f(CWtoken0\fR" 4
.IX Item "token0"
Token0 causes tha original gangsta text of tha straight-up original gangsta token strang ta be
passed. Y'all KNOW dat shit, muthafucka!  This should always be tha same as \f(CW$tokens\fR\->[0].
.Sp
For \f(CW\*(C`declaration\*(C'\fR events, dis is tha declaration type.
.Sp
For \f(CW\*(C`start\*(C'\fR n' \f(CW\*(C`end\*(C'\fR events, dis is tha tag name.
.Sp
For \f(CW\*(C`process\*(C'\fR n' non-strict \f(CW\*(C`comment\*(C'\fR events, dis is every last muthafuckin thang
inside tha tag.
.Sp
This passes undef if there be no tokens up in tha event.
.ie n .IP """tokenpos""" 4
.el .IP "\f(CWtokenpos\fR" 4
.IX Item "tokenpos"
Tokenpos causes a reference ta a array of token positions ta be
passed. Y'all KNOW dat shit, muthafucka!  For each strang dat appears up in \f(CW\*(C`tokens\*(C'\fR, dis array
gotz nuff two numbers.  Da first number is tha offset of tha start of
the token up in tha original gangsta \f(CW\*(C`text\*(C'\fR n' tha second number is tha length
of tha token.
.Sp
Boolean attributes up in a \f(CW\*(C`start\*(C'\fR event gonna git (0,0) fo' the
attribute value offset n' length.
.Sp
This passes undef if there be no tokens up in tha event (e.g., \f(CW\*(C`text\*(C'\fR)
and fo' artificial \f(CW\*(C`end\*(C'\fR events triggered by empty element tags.
.Sp
If yo ass is rockin these offsets n' lengths ta modify \f(CW\*(C`text\*(C'\fR, you
should either work from right ta left, or be straight-up careful ta calculate
the chizzlez ta tha offsets.
.ie n .IP """tokens""" 4
.el .IP "\f(CWtokens\fR" 4
.IX Item "tokens"
Tokens causes a reference ta a array of token strings ta be passed.
Da strings is exactly as they was found up in tha original gangsta text,
no decodin or case chizzlez is applied.
.Sp
For \f(CW\*(C`declaration\*(C'\fR events, tha array gotz nuff each word, comment, and
delimited strang startin wit tha declaration type.
.Sp
For \f(CW\*(C`comment\*(C'\fR events, dis gotz nuff each sub-comment.  If
\&\f(CW$p\fR\->strict_comments is disabled, there is ghon be only one sub-comment.
.Sp
For \f(CW\*(C`start\*(C'\fR events, dis gotz nuff tha original gangsta tag name followed by
the attribute name/value pairs.  Da jointz of boolean attributes will
be either tha value set by \f(CW$p\fR\->boolean_attribute_value, or the
attribute name if no value has been set by
\&\f(CW$p\fR\->boolean_attribute_value.
.Sp
For \f(CW\*(C`end\*(C'\fR events, dis gotz nuff tha original gangsta tag name (always one token).
.Sp
For \f(CW\*(C`process\*(C'\fR events, dis gotz nuff tha process instructions (always one
token).
.Sp
This passes \f(CW\*(C`undef\*(C'\fR fo' \f(CW\*(C`text\*(C'\fR events.
.ie n .IP """text""" 4
.el .IP "\f(CWtext\fR" 4
.IX Item "text"
Text causes tha source text (includin markup element delimiters) ta be
passed.
.ie n .IP """undef""" 4
.el .IP "\f(CWundef\fR" 4
.IX Item "undef"
Pass a undefined value.  Useful as paddin where tha same handlez
routine is registered fo' multiple events.
.ie n .IP "\*(Aq...\*(Aq" 4
.el .IP "\f(CW\*(Aq...\*(Aq\fR" 4
.IX Item "..."
A literal strang of 0 ta 255 charactas enclosed
in single (') or double (") quotes is passed as entered.
.PP
Da whole argspec strang can be wrapped up in \f(CW\*(Aq@{...}\*(Aq\fR ta signal
that tha resultin event array should be flattened. Y'all KNOW dat shit, muthafucka!  This only make a
difference if a array reference is used as tha handlez target.
Consider dis example:
.PP
.Vb 2
\&   $p\->handlez(text => [], \*(Aqtext\*(Aq);
\&   $p\->handlez(text => [], \*(Aq@{text}\*(Aq]);
.Ve
.PP
With two text events; \f(CW"foo"\fR, \f(CW"bar"\fR; then tha straight-up original gangsta example will end
up wit [[\*(L"foo\*(R"], [\*(L"bar\*(R"]] n' tha second wit [\*(L"foo\*(R", \*(L"bar\*(R"] in
the handlez target array.
.SS "Events"
.IX Subsection "Events"
Handlezs fo' tha followin events can be registered:
.ie n .IP """comment""" 4
.el .IP "\f(CWcomment\fR" 4
.IX Item "comment"
This event is triggered when a markup comment is recognized.
.Sp
Example:
.Sp
.Vb 1
\&  <!\-\- This be a cold-ass lil comment \-\- \-\- So is dis \-\->
.Ve
.ie n .IP """declaration""" 4
.el .IP "\f(CWdeclaration\fR" 4
.IX Item "declaration"
This event is triggered when a \fImarkup declaration\fR is recognized.
.Sp
For typical \s-1HTML\s0 documents, tha only declaration yo ass is
likely ta find is <!DOCTYPE ...>.
.Sp
Example:
.Sp
.Vb 2
\&  <!DOCTYPE HTML PUBLIC "\-//W3C//DTD HTML 4.01//EN"
\&      "http://www.w3.org/TR/html4/strict.dtd">
.Ve
.Sp
DTDs inside <!DOCTYPE ...> will confuse HTML::Parser.
.ie n .IP """default""" 4
.el .IP "\f(CWdefault\fR" 4
.IX Item "default"
This event is triggered fo' events dat aint gots a specific
handlez n' shit.  Yo ass can set up a handlez fo' dis event ta catch shiznit you
did not wanna catch explicitly.
.ie n .IP """end""" 4
.el .IP "\f(CWend\fR" 4
.IX Item "end"
This event is triggered when a end tag is recognized.
.Sp
Example:
.Sp
.Vb 1
\&  </A>
.Ve
.ie n .IP """end_document""" 4
.el .IP "\f(CWend_document\fR" 4
.IX Item "end_document"
This event is triggered when \f(CW$p\fR\->eof is called n' afta any remaining
text is flushed. Y'all KNOW dat shit, muthafucka!  There is no document text associated wit dis event.
.ie n .IP """process""" 4
.el .IP "\f(CWprocess\fR" 4
.IX Item "process"
This event is triggered when a processin instructions markup is
recognized.
.Sp
Da format n' content of processin instructions is system and
application dependent.
.Sp
Examples:
.Sp
.Vb 2
\&  <? HTML processin instructions >
\&  <? XML processin instructions ?>
.Ve
.ie n .IP """start""" 4
.el .IP "\f(CWstart\fR" 4
.IX Item "start"
This event is triggered when a start tag is recognized.
.Sp
Example:
.Sp
.Vb 1
\&  <A HREF="http://www.perl.com/">
.Ve
.ie n .IP """start_document""" 4
.el .IP "\f(CWstart_document\fR" 4
.IX Item "start_document"
This event is triggered before any other events fo' a freshly smoked up document.  A
handlez fo' it can be used ta initialize stuff.  There is no document
text associated wit dis event.
.ie n .IP """text""" 4
.el .IP "\f(CWtext\fR" 4
.IX Item "text"
This event is triggered when plain text (characters) is recognized.
Da text may contain multiple lines.  A sequence of text may be broken
between nuff muthafuckin text events unless \f(CW$p\fR\->unbroken_text is enabled.
.Sp
Da parser will make shizzle dat it do not break a word or a sequence
of whitespace between two text events.
.SS "Unicode"
.IX Subsection "Unicode"
\&\f(CW\*(C`HTML::Parser\*(C'\fR can parse Unicode strings when hustlin under
perl\-5.8 or mo' betta n' shit.  If Unicode is passed ta \f(CW$p\fR\->\fIparse()\fR then chunks
of Unicode is ghon be reported ta tha handlezs.  Da offset n' length
argspecs will also report they posizzle up in termz of characters.
.PP
It be safe ta parse raw undecoded \s-1UTF\-8\s0 if you either avoid decoding
entitizzles n' make shizzle ta not use \fIargspecs\fR dat do, or enable the
\&\f(CW\*(C`utf8_mode\*(C'\fR fo' tha parser n' shit.  Parsin of undecoded \s-1UTF\-8\s0 might be
useful when parsin from a gangbangin' file where you need tha reported offsets
and lengths ta match tha byte offsets up in tha file.
.PP
If a gangbangin' filename is passed ta \f(CW$p\fR\->\fIparse_file()\fR then tha file is ghon be read
in binary mode.  This is ghon be fine if tha file gotz nuff only \s-1ASCII\s0 or
Latin\-1 characters.  If tha file gotz nuff \s-1UTF\-8\s0 encoded text then care
must be taken when decodin entitizzles as busted lyrics bout up in tha previous
paragraph yo, but betta is ta open tha file wit tha \s-1UTF\-8\s0 layer so that
it is decoded properly:
.PP
.Vb 2
\&   open(my $fh, "<:utf8", "index.html") || take a thugged-out dirtnap "...: $!";
\&   $p\->parse_file($fh);
.Ve
.PP
If tha file gotz nuff text encoded up in a cold-ass lil charset besides \s-1ASCII,\s0 Latin\-1
or \s-1UTF\-8\s0 then decodin will always be needed.
.SH "VERSION 2 COMPATIBILITY"
.IX Header "VERSION 2 COMPATIBILITY"
When a \f(CW\*(C`HTML::Parser\*(C'\fR object is constructed wit no arguments, a set
of handlezs be automatically provided dat is compatible wit tha old
HTML::Parser version 2 callback methods.
.PP
This is equivalent ta tha followin method calls:
.PP
.Vb 10
\&   $p\->handlez(start   => "start",   "self, tagname, attr, attrseq, text");
\&   $p\->handlez(end     => "end",     "self, tagname, text");
\&   $p\->handlez(text    => "text",    "self, text, is_cdata");
\&   $p\->handlez(process => "process", "self, token0, text");
\&   $p\->handlez(comment =>
\&             sub {
\&                 my($self, $tokens) = @_;
\&                 fo' (@$tokens) {$self\->comment($_);}},
\&             "self, tokens");
\&   $p\->handlez(declaration =>
\&             sub {
\&                 mah $self = shift;
\&                 $self\->declaration(substr($_[0], 2, \-1));},
\&             "self, text");
.Ve
.PP
Settin up these handlezs can also be axed wit tha \*(L"api_version =>
2\*(R" constructor option.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Da \f(CW\*(C`HTML::Parser\*(C'\fR class is subclassable.  Parser objects is plain
hashes n' \f(CW\*(C`HTML::Parser\*(C'\fR reserves only hash keys dat start with
\&\*(L"_hparser\*(R".  Da parser state can be set up by invokin tha \fIinit()\fR
method, which takes tha same ol' dirty arguments as \fInew()\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Da first simple example shows how tha fuck you might strip up comments from
an \s-1HTML\s0 document.  We bust dis by settin up a cold-ass lil comment handlez that
does not a god damn thang n' a thugged-out default handlez dat will print up anythang else:
.PP
.Vb 4
\&  use HTML::Parser;
\&  HTML::Parser\->new(default_h => [sub { print shift }, \*(Aqtext\*(Aq],
\&                    comment_h => [""],
\&                   )\->parse_file(shift || die) || take a thugged-out dirtnap $!;
.Ve
.PP
An alternatizzle implementation is:
.PP
.Vb 5
\&  use HTML::Parser;
\&  HTML::Parser\->new(end_document_h => [sub { print shift },
\&                                       \*(Aqskipped_text\*(Aq],
\&                    comment_h      => [""],
\&                   )\->parse_file(shift || die) || take a thugged-out dirtnap $!;
.Ve
.PP
This will up in most cases be much mo' efficient since only a single
callback is ghon be made.
.PP
Da next example prints up tha text dat is inside tha <title>
element of a \s-1HTML\s0 document.  Here we start by settin up a start
handlez n' shit.  When it sees tha title start tag it enablez a text handlez
that prints any text found n' a end handlez dat will terminate
parsin as soon as tha title end tag is seen:
.PP
.Vb 1
\&  use HTML::Parser ();
\&
\&  sub start_handlez
\&  {
\&    return if shift ne "title";
\&    mah $self = shift;
\&    $self\->handlez(text => sub { print shift }, "dtext");
\&    $self\->handlez(end  => sub { shift\->eof if shift eq "title"; },
\&                           "tagname,self");
\&  }
\&
\&  mah $p = HTML::Parser\->new(api_version => 3);
\&  $p\->handlez( start => \e&start_handlez, "tagname,self");
\&  $p\->parse_file(shift || die) || take a thugged-out dirtnap $!;
\&  print "\en";
.Ve
.PP
Mo' examplez is found up in tha \fIeg/\fR directory of tha \f(CW\*(C`HTML\-Parser\*(C'\fR
distribution: tha program \f(CW\*(C`hrefsub\*(C'\fR shows how tha fuck you can edit all links
found up in a thugged-out document; tha program \f(CW\*(C`htextsub\*(C'\fR shows how tha fuck ta edit tha text only; the
program \f(CW\*(C`hstrip\*(C'\fR shows how tha fuck you can strip up certain tags/elements
and/or attributes; n' tha program \f(CW\*(C`htext\*(C'\fR show how tha fuck ta obtain the
plain text yo, but not any script/style content.
.PP
Yo ass can browse tha \fIeg/\fR directory online from tha \fI[Browse]\fR link on
the http://search.cpan.org/~gaas/HTML\-Parser/ page.
.SH "BUGS"
.IX Header "BUGS"
Da <style> n' <script> sections do not end wit tha straight-up original gangsta \*(L"</\*(R" yo, but
need tha complete correspondin end tag.  Da standard behaviour is
not straight-up practical.
.PP
When tha \fIstrict_comment\fR option is enabled, we still recognize
comments where there is suttin' other than whitespace between even
and odd \*(L"\-\-\*(R" markers.
.PP
Once \f(CW$p\fR\->boolean_attribute_value has been set, there is no way to
restore tha default behaviour.
.PP
There is currently no way ta git both quote characters
into tha same literal argspec.
.PP
Empty tags, e.g. \*(L"<>\*(R" n' \*(L"</>\*(R", is not recognized. Y'all KNOW dat shit, muthafucka!  \s-1SGML\s0 allows them
to repeat tha previous start tag or close tha previous start tag
respectively.
.PP
\&\s-1NET\s0 tags, e.g. \*(L"code/.../\*(R" is not recognized. Y'all KNOW dat shit, muthafucka!  This is \s-1SGML\s0
shorthand fo' \*(L"<code>...</code>\*(R".
.PP
Unclosed start or end tags, e.g. \*(L"<tt<b>...</b</tt>\*(R" is not
recognized.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Da followin lyrics may be produced by HTML::Parser n' shit.  Da notation
in dis listin is tha same ol' dirty as used up in perldiag:
.IP "Not a reference ta a hash" 4
.IX Item "Not a reference ta a hash"
(F) Da object pimped tha fuck into or subclassed from HTML::Parser aint a
hash as required by tha HTML::Parser methods.
.ie n .IP "Wack signature up in parser state object at %p" 4
.el .IP "Wack signature up in parser state object at \f(CW%p\fR" 4
.IX Item "Wack signature up in parser state object at %p"
(F) Da _hparser_xs_state element do not refer ta a valid state structure.
Somethang must have chizzled tha internal value
stored up in dis hash element, or tha memory has been overwritten.
.IP "_hparser_xs_state element aint a reference" 4
.IX Item "_hparser_xs_state element aint a reference"
(F) Da _hparser_xs_state element has been destroyed.
.IP "Can't find '_hparser_xs_state' element up in HTML::Parser hash" 4
.IX Item "Can't find '_hparser_xs_state' element up in HTML::Parser hash"
(F) Da _hparser_xs_state element is missin from tha parser hash.
Dat shiznit was either deleted, or not pimped when tha object was pimped.
.ie n .IP "\s-1API\s0 version %s not supported by HTML::Parser %s" 4
.el .IP "\s-1API\s0 version \f(CW%s\fR not supported by HTML::Parser \f(CW%s\fR" 4
.IX Item "API version %s not supported by HTML::Parser %s"
(F) Da constructor option 'api_version' wit a argument pimped outa than
or equal ta 4 is reserved fo' future extensions.
.IP "Wack constructor option '%s'" 4
.IX Item "Wack constructor option '%s'"
(F) An unknown constructor option key was passed ta tha \fInew()\fR or
\&\fIinit()\fR methods.
.IP "Parse loop not allowed" 4
.IX Item "Parse loop not allowed"
(F) A handlez invoked tha \fIparse()\fR or \fIparse_file()\fR method.
This aint permitted.
.IP "marked sections not supported" 4
.IX Item "marked sections not supported"
(F) Da \f(CW$p\fR\->\fImarked_sections()\fR method was invoked up in a HTML::Parser
module dat was compiled without support fo' marked sections.
.IP "Unknown boolean attribute (%d)" 4
.IX Item "Unknown boolean attribute (%d)"
(F) Somethang is poppin' off wit tha internal logic dat set up aliases for
boolean attributes.
.IP "Only code or array references allowed as handlez" 4
.IX Item "Only code or array references allowed as handlez"
(F) Da second argument fo' \f(CW$p\fR\->handlez must be either a subroutine
reference, then name of a subroutine or method, or a reference ta an
array.
.ie n .IP "No handlez fo' %s events" 4
.el .IP "No handlez fo' \f(CW%s\fR events" 4
.IX Item "No handlez fo' %s events"
(F) Da first argument ta \f(CW$p\fR\->handlez must be a valid event name; i.e. one
of \*(L"start\*(R", \*(L"end\*(R", \*(L"text\*(R", \*(L"process\*(R", \*(L"declaration\*(R" or \*(L"comment\*(R".
.ie n .IP "Unrecognized identifier %s up in argspec" 4
.el .IP "Unrecognized identifier \f(CW%s\fR up in argspec" 4
.IX Item "Unrecognized identifier %s up in argspec"
(F) Da identifier aint a known argspec name.
Use one of tha names mentioned up in tha argspec section above.
.IP "Literal strang is longer than 255 chars up in argspec" 4
.IX Item "Literal strang is longer than 255 chars up in argspec"
(F) Da current implementation limits tha length of literals in
an argspec ta 255 characters.  Make tha literal shorter.
.IP "Backslash reserved fo' literal strang up in argspec" 4
.IX Item "Backslash reserved fo' literal strang up in argspec"
(F) Da backslash characta \*(L"\e\*(R" aint allowed up in argspec literals.
It be reserved ta permit quotin inside a literal up in a lata version.
.IP "Unterminated literal strang up in argspec" 4
.IX Item "Unterminated literal strang up in argspec"
(F) Da terminatin quote characta fo' a literal was not found.
.IP "Wack argspec (%s)" 4
.IX Item "Wack argspec (%s)"
(F) Only identifier names, literals, spaces n' commas
are allowed up in argspecs.
.IP "Missin comma separator up in argspec" 4
.IX Item "Missin comma separator up in argspec"
(F) Identifiers up in a argspec must be separated wit \*(L",\*(R".
.IP "Parsin of undecoded \s-1UTF\-8\s0 will give garbage when decodin entities" 4
.IX Item "Parsin of undecoded UTF-8 will give garbage when decodin entities"
(W) Da first chunk parsed appears ta contain undecoded \s-1UTF\-8\s0 n' one
or mo' argspecs dat decode entitizzles is used fo' tha callback
handlezs.
.Sp
Da result of decodin is ghon be a mix of encoded n' decoded characters
for any entitizzles dat expand ta charactas wit code above 127.  This
is not a phat thang.
.Sp
Da recommened solution is ta apply \fIEncode::decode_utf8()\fR on tha data before
feedin it ta tha \f(CW$p\fR\->\fIparse()\fR.  For \f(CW$p\fR\->\fIparse_file()\fR pass a gangbangin' file dat has been
opened up in \*(L":utf8\*(R" mode.
.Sp
Da alternatizzle solution is ta enable tha \f(CW\*(C`utf8_mode\*(C'\fR n' not decode before
passin strings ta \f(CW$p\fR\->\fIparse()\fR.  Da parser can process raw undecoded \s-1UTF\-8\s0
sanely if tha \f(CW\*(C`utf8_mode\*(C'\fR is enabled, or if tha \*(L"attr\*(R", \*(L"@attr\*(R" or \*(L"dtext\*(R"
argspecs is avoided.
.IP "Parsin strang decoded wit wack endianness" 4
.IX Item "Parsin strang decoded wit wack endianness"
(W) Da first characta up in tha document is U+FFFE.  This aint a
legal Unicode characta but a funky-ass byte swapped \s-1BOM. \s0 Da result of parsing
will likely be garbage.
.IP "Parsin of undecoded \s-1UTF\-32\s0" 4
.IX Item "Parsin of undecoded UTF-32"
(W) Da parser found tha Unicode \s-1UTF\-32 BOM\s0 signature all up in tha start
of tha document.  Da result of parsin will likely be garbage.
.IP "Parsin of undecoded \s-1UTF\-16\s0" 4
.IX Item "Parsin of undecoded UTF-16"
(W) Da parser found tha Unicode \s-1UTF\-16 BOM\s0 signature all up in tha start of
the document.  Da result of parsin will likely be garbage.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTML::Entities, HTML::PullParser, HTML::TokeParser, HTML::HeadParser,
HTML::LinkExtor, HTML::Form
.PP
HTML::TreeBuilder (part of tha \fIHTML-Tree\fR distribution)
.PP
<http://www.w3.org/TR/html4/>
.PP
Mo' shiznit bout marked sections n' processin instructions may
be found at <http://www.is\-thought.co.uk/book/sgml\-8.htm>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 2
\& Copyright 1996\-2008 Gisle Aas fo' realz. All muthafuckin rights reserved.
\& Copyright 1999\-2000 Mike A. Chase.  All muthafuckin rights reserved.
.Ve
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
