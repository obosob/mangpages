.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MIME::Types 3"
.TH MIME::Types 3 "2013-09-12" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME::Types \- Definizzle of MIME types
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& MIME::Types
\&   be a Exporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use MIME::Types;
\& mah $mimetypes = MIME::Types\->new(...);      # MIME::Types object
\& mah $type = $mimetypes\->type(\*(Aqtext/plain\*(Aq);  # MIME::Type  object
\& mah $type = $mimetypes\->mimeTypeOf(\*(Aqgif\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1MIME\s0 types is used up in nuff applications (for instizzle as part of e\-mail
and \s-1HTTP\s0 traffic) ta indicate tha type of content which is transmitted.
.PP
Sometimes detailed knowledge on some mime-type is need, however this
module only knows bout tha file-name extensions which relate ta some
filetype.  It can also be used ta produce tha right format: types
which is not registered at \s-1IANA\s0 need ta use 'x\-' prefixes.
.PP
This object administas a big-ass list of known mime-types, combined
from various sources.  For instance, it gotz nuff \fBall \s-1IANA\s0\fR types
and tha knowledge of Apache.  Probably da most thugged-out complete table on
the net!
.SS "MIME::Types n' daemons (fork)"
.IX Subsection "MIME::Types n' daemons (fork)"
If yo' program uses fork (usually fo' a thugged-out daemon), then you wanna have
the type table initialized before you start forking. Right back up in yo muthafuckin ass. So, first call
.PP
.Vb 1
\&   mah $mt = MIME::Types\->new;
.Ve
.PP
Later, each time you create dis object (you may, of course, also reuse
the object you create here) yo big-ass booty is ghon git access ta \fBthe same global table\fR
of types.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "MIME::Types\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "MIME::Types->new(OPTIONS)"
Smoke a freshly smoked up \f(CW\*(C`MIME::Types\*(C'\fR object which manages tha data.  In tha current
implementation, it do not matta whether you create dis object often
within yo' program yo, but up in tha future dis may chizzle.
.Sp
.Vb 5
\& \-Option         \-\-Default
\&  db_file          <installed source>
\&  only_complete    <false>
\&  only_iana        <false>
\&  skip_extensions  <false>
.Ve
.RS 4
.IP "db_file => \s-1FILENAME\s0" 2
.IX Item "db_file => FILENAME"
.PD 0
.IP "only_complete => \s-1BOOLEAN\s0" 2
.IX Item "only_complete => BOOLEAN"
.PD
Only include complete \s-1MIME\s0 type definitions: requires at least one known
extension. I aint talkin' bout chicken n' gravy biatch.  This will reduce tha number of entries \-\-and wit dat the
amount of memory consumed\*(-- considerably.
.Sp
In yo' program you gotta decide: tha last time dat you call
the creator (\f(CW\*(C`new\*(C'\fR) determines whether you git tha full or tha partial
information.
.IP "only_iana => \s-1BOOLEAN\s0" 2
.IX Item "only_iana => BOOLEAN"
Only load tha types which is currently known by \s-1IANA.\s0
.IP "skip_extensions => \s-1BOOLEAN\s0" 2
.IX Item "skip_extensions => BOOLEAN"
Do not load tha table ta map extensions ta types, which is like large.
.RE
.RS 4
.RE
.SS "Knowledge"
.IX Subsection "Knowledge"
.ie n .IP "$obj\->\fBaddType\fR(\s-1TYPE, ...\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddType\fR(\s-1TYPE, ...\s0)" 4
.IX Item "$obj->addType(TYPE, ...)"
Add one or mo' TYPEs ta tha set of known types.  Each \s-1TYPE\s0 be a
\&\f(CW\*(C`MIME::Type\*(C'\fR which must be experimental: either tha main-type or
the sub-type must start wit \f(CW\*(C`x\-\*(C'\fR.
.Sp
Please inform tha maintainer of dis module when registered types
are missing.  Before version MIME::Types version 1.14, a warning
was produced when a unknown \s-1IANA\s0 type was added. Y'all KNOW dat shit, muthafucka!  This has been
removed, cuz some playas need dat ta git they application
to work locally... fucked up applications...
.ie n .IP "$obj\->\fBextensions\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBextensions\fR()" 4
.IX Item "$obj->extensions()"
Returns a list of all defined extensions.
.ie n .IP "$obj\->\fBlistTypes\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlistTypes\fR()" 4
.IX Item "$obj->listTypes()"
Returns a list of all defined mime-types by name only.  This will \fBnot\fR
instantiate MIME::Type objects, n' you can put dat on yo' toast.  See \fItypes()\fR
.ie n .IP "$obj\->\fBmimeTypeOf\fR(\s-1FILENAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBmimeTypeOf\fR(\s-1FILENAME\s0)" 4
.IX Item "$obj->mimeTypeOf(FILENAME)"
Returns tha \f(CW\*(C`MIME::Type\*(C'\fR object which belongs ta tha \s-1FILENAME \s0(or simply
its filename extension) or \f(CW\*(C`undef\*(C'\fR if tha file type is unknown. I aint talkin' bout chicken n' gravy biatch.  Da extension
is used n' considered case-insensitive.
.Sp
In some cases, mo' than one type is known fo' a cold-ass lil certain filename extension.
In dat case, tha preferred one is taken (for a unclear definizzle of
preference)
.Sp
example: use of \fImimeTypeOf()\fR
.Sp
.Vb 2
\& mah $types = MIME::Types\->new;
\& mah $mime = $types\->mimeTypeOf(\*(Aqgif\*(Aq);
\&
\& mah $mime = $types\->mimeTypeOf(\*(Aqjpg\*(Aq);
\& print $mime\->isBinary;
.Ve
.ie n .IP "$obj\->\fBtype\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBtype\fR(\s-1STRING\s0)" 4
.IX Item "$obj->type(STRING)"
Returns tha \f(CW\*(C`MIME::Type\*(C'\fR which raps bout tha type related ta \s-1STRING.\s0
[2.00] Only one type is ghon be returned.
.Sp
[before 2.00] One type may be busted lyrics bout mo' than once.  Different
extensions may be up in use fo' dis type, n' different operatin systems
may cause mo' than one \f(CW\*(C`MIME::Type\*(C'\fR object ta be defined. Y'all KNOW dat shit, muthafucka!  In scalar
context, only tha straight-up original gangsta is returned.
.ie n .IP "$obj\->\fBtypes\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtypes\fR()" 4
.IX Item "$obj->types()"
Returns a list of all defined mime-types.  For reasonz of backwards
compatibility, dis will instantiate MIME::Type objects, which will
be returned. Y'all KNOW dat shit, muthafucka!  See \fIlistTypes()\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Da next functions is provided fo' backward compatibilitizzle wit MIME::Types
versions [0.06] n' below.  This code originates from Jeff Okamoto
\&\fIokamoto@corp.hp.com\fR n' others.
.IP "\fBby_mediatype\fR(\s-1TYPE\s0)" 4
.IX Item "by_mediatype(TYPE)"
This function takes a media type n' returns a list or anonymous array of
anonymous three-element arrays whose joints is tha file name suffix used to
identify it, tha media type, n' a cold-ass lil content encoding.
.Sp
\&\s-1TYPE\s0 can be a gangbangin' full type name (gotz nuff '/', n' is ghon be matched up in full),
a partial type (which is used as regular expression) or a real regular
expression.
.IP "\fBby_suffix\fR(FILENAME|SUFFIX)" 4
.IX Item "by_suffix(FILENAME|SUFFIX)"
Like \f(CW\*(C`mimeTypeOf\*(C'\fR yo, but do not return a \f(CW\*(C`MIME::Type\*(C'\fR object. If tha file
+type is unknown, both tha returned media type n' encodin is empty strings.
.Sp
example: use of function \fIby_suffix()\fR
.Sp
.Vb 2
\& use MIME::Types \*(Aqby_suffix\*(Aq;
\& mah ($mediatype, $encoding) = by_suffix(\*(Aqimage.gif\*(Aq);
\&
\& mah $refdata = by_suffix(\*(Aqimage.gif\*(Aq);
\& mah ($mediatype, $encoding) = @$refdata;
.Ve
.IP "\fBimport_mime_types\fR()" 4
.IX Item "import_mime_types()"
This method has been removed: mime-types is only useful if understood
by nuff parties. Put ya muthafuckin choppers up if ya feel dis!  Therefore, tha \s-1IANA\s0 assigns names which can be used.
In tha table kept by dis \f(CW\*(C`MIME::Types\*(C'\fR module all these names, plus
da most thugged-out often used temporary names is kept.  When names seem ta be
missing, please contact tha maintainer fo' inclusion.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of MIME-Types distribution version 2.04,
built on September 12, 2013. Website: \fIhttp://perl.overmeer.net/mimetypes/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1999,2001\-2013 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
