" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::vector< _Tp, _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBstd::_Vector_base< _Tp, _Alloc >\fP\&.
.PP
Inherited by \fBstd::match_results< _Bi_ita >\fP\fC [private]\fP, n' \fBstd::match_results< _FwdIterT, _Alloc >\fP\fC [private]\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef 
.br
__gnu_cxx::__normal_iterator
.br
< const_pointer, \fBvector\fP > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef 
.br
_Alloc_traits::const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef 
.br
_Alloc_traits::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< const_iterator > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef 
.br
__gnu_cxx::__normal_iterator
.br
< pointer, \fBvector\fP > \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Base::pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Alloc_traits::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< iterator > \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Tp \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBvector\fP ()"
.br
.ti -1c
.RI "\fBvector\fP (const allocator_type &__a)"
.br
.ti -1c
.RI "\fBvector\fP (size_type __n, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBvector\fP (size_type __n, const value_type &__value, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBvector\fP (const \fBvector\fP &__x)"
.br
.ti -1c
.RI "\fBvector\fP (\fBvector\fP &&__x) noexcept"
.br
.ti -1c
.RI "\fBvector\fP (const \fBvector\fP &__x, const allocator_type &__a)"
.br
.ti -1c
.RI "\fBvector\fP (\fBvector\fP &&__rv, const allocator_type &__m)"
.br
.ti -1c
.RI "\fBvector\fP (\fBinitializer_list\fP< value_type > __l, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> \fBvector\fP (_InputIterator __first, _InputIterator __last, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fB~vector\fP () noexcept"
.br
.ti -1c
.RI "void \fBassign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> void \fBassign\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBassign\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "reference \fBat\fP (size_type __n)"
.br
.ti -1c
.RI "const_reference \fBat\fP (size_type __n) const "
.br
.ti -1c
.RI "reference \fBback\fP ()"
.br
.ti -1c
.RI "const_reference \fBback\fP () const "
.br
.ti -1c
.RI "iterator \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "const_iterator \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "size_type \fBcapacity\fP () const noexcept"
.br
.ti -1c
.RI "const_iterator \fBcbegin\fP () const noexcept"
.br
.ti -1c
.RI "const_iterator \fBcend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const noexcept"
.br
.ti -1c
.RI "_Tp * \fBdata\fP () noexcept"
.br
.ti -1c
.RI "const _Tp * \fBdata\fP () const noexcept"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBvector\fP< _Tp, _Alloc >::iterator \fBemplace\fP (iterator __position, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> iterator \fBemplace\fP (iterator __position, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> void \fBemplace_back\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "iterator \fBend\fP () noexcept"
.br
.ti -1c
.RI "const_iterator \fBend\fP () const noexcept"
.br
.ti -1c
.RI "iterator \fBerase\fP (iterator __position)"
.br
.ti -1c
.RI "iterator \fBerase\fP (iterator __first, iterator __last)"
.br
.ti -1c
.RI "reference \fBfront\fP ()"
.br
.ti -1c
.RI "const_reference \fBfront\fP () const "
.br
.ti -1c
.RI "iterator \fBinsert\fP (iterator __position, const value_type &__x)"
.br
.ti -1c
.RI "iterator \fBinsert\fP (iterator __position, value_type &&__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (iterator __position, \fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "void \fBinsert\fP (iterator __position, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> void \fBinsert\fP (iterator __position, _InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const noexcept"
.br
.ti -1c
.RI "\fBvector\fP & \fBoperator=\fP (const \fBvector\fP &__x)"
.br
.ti -1c
.RI "\fBvector\fP & \fBoperator=\fP (\fBvector\fP &&__x) noexcept(_Alloc_traits::_S_nothrow_move())"
.br
.ti -1c
.RI "\fBvector\fP & \fBoperator=\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "reference \fBoperator[]\fP (size_type __n)"
.br
.ti -1c
.RI "const_reference \fBoperator[]\fP (size_type __n) const "
.br
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.ti -1c
.RI "void \fBpush_back\fP (const value_type &__x)"
.br
.ti -1c
.RI "void \fBpush_back\fP (value_type &&__x)"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBreserve\fP (size_type __n)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size, const value_type &__x)"
.br
.ti -1c
.RI "void \fBshrink_to_fit\fP ()"
.br
.ti -1c
.RI "size_type \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "void \fBswap\fP (\fBvector\fP &__x) noexcept(_Alloc_traits::_S_nothrow_swap())"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "pointa \fB_M_allocate\fP (size_t __n)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > pointa \fB_M_allocate_and_copy\fP (size_type __n, _ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_assign_aux\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_assign_aux\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_assign_dispatch\fP (_Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_assign_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "size_type \fB_M_check_len\fP (size_type __n, const char *__s) const "
.br
.ti -1c
.RI "void \fB_M_deallocate\fP (pointa __p, size_t __n)"
.br
.ti -1c
.RI "void \fB_M_default_append\fP (size_type __n)"
.br
.ti -1c
.RI "void \fB_M_default_initialize\fP (size_type __n)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> void \fB_M_emplace_back_aux\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "void \fB_M_erase_at_end\fP (pointa __pos)"
.br
.ti -1c
.RI "void \fB_M_fill_assign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "void \fB_M_fill_initialize\fP (size_type __n, const value_type &__value)"
.br
.ti -1c
.RI "void \fB_M_fill_insert\fP (iterator __pos, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "_Tp_alloc_type & \fB_M_get_Tp_allocator\fP () noexcept"
.br
.ti -1c
.RI "const _Tp_alloc_type & \fB_M_get_Tp_allocator\fP () const noexcept"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_initialize_dispatch\fP (_Integer __n, _Integer __value, __true_type)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_initialize_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> void \fB_M_insert_aux\fP (iterator __position, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_insert_dispatch\fP (iterator __pos, _Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_insert_dispatch\fP (iterator __pos, _InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "void \fB_M_range_check\fP (size_type __n) const "
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_range_initialize\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_range_initialize\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_range_insert\fP (iterator __pos, _InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_range_insert\fP (iterator __pos, _ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "bool \fB_M_shrink_to_fit\fP ()"
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const noexcept"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_Vector_impl \fB_M_impl\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>>class std::vector< _Tp, _Alloc >"
A standard container which offers fixed time access ta individual elements up in any order\&. 


.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Tp\fP Type of element\&. 
.br
\fI_Alloc\fP Allocator type, defaults ta allocator<_Tp>\&.
.RE
.PP
Meets tha requirementz of a \fCcontainer\fP, a \fCreversible container\fP, n' a \fCsequence\fP, includin tha \fCoptionizzle sequence requirements\fP wit tha exception of \fCpush_front\fP n' \fCpop_front\fP\&.
.PP
In some terminologizzle a vector can be busted lyrics bout as a thugged-out dynamic C-style array, it offers fast n' efficient access ta individual elements up in any order n' saves tha user from worryin bout memory n' size allocation\&. Right back up in yo muthafuckin ass. Subscriptin ( \fC\fP[] ) access be also provided as wit C-style arrays\&. 
.PP
Definizzle at line 210 of file stl_vector\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP ()\fC [inline]\fP"

.PP
Default constructor creates no elements\&. 
.PP
Definizzle at line 248 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (const allocator_type &__a)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Creates a vector wit no elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator object\&. 
.RE
.PP

.PP
Definizzle at line 256 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (size_type__n, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Creates a vector wit default constructed elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da number of elements ta initially create\&. 
.br
\fI__a\fP An allocator\&.
.RE
.PP
This constructor fills tha vector wit \fI__n\fP default constructed elements\&. 
.PP
Definizzle at line 269 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (size_type__n, const value_type &__value, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP"

.PP
Creates a vector wit copiez of a exemplar element\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da number of elements ta initially create\&. 
.br
\fI__value\fP An element ta copy\&. 
.br
\fI__a\fP An allocator\&.
.RE
.PP
This constructor fills tha vector wit \fI__n\fP copiez of \fI__value\fP\&. 
.PP
Definizzle at line 281 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (const \fBvector\fP< _Tp, _Alloc > &__x)\fC [inline]\fP"

.PP
Vector copy constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A vector of identical element n' allocator types\&.
.RE
.PP
Da newly-created vector uses a cold-ass lil copy of tha allocation object used by \fI__x\fP\& fo' realz. All tha elementz of \fI__x\fP is copied yo, but any extra memory up in \fI__x\fP (for fast expansion) aint gonna be copied\&. 
.PP
Definizzle at line 310 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (\fBvector\fP< _Tp, _Alloc > &&__x)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Vector move constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A vector of identical element n' allocator types\&.
.RE
.PP
Da newly-created vector gotz nuff tha exact contentz of \fI__x\fP\&. Da contentz of \fI__x\fP is a valid yo, but unspecified vector\&. 
.PP
Definizzle at line 327 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (const \fBvector\fP< _Tp, _Alloc > &__x, const allocator_type &__a)\fC [inline]\fP"

.PP
Copy constructor wit alternatizzle allocator\&. 
.PP
Definizzle at line 331 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (\fBvector\fP< _Tp, _Alloc > &&__rv, const allocator_type &__m)\fC [inline]\fP"

.PP
Move constructor wit alternatizzle allocator\&. 
.PP
Definizzle at line 340 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (\fBinitializer_list\fP< value_type >__l, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP"

.PP
Buildz a vector from a initializer list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list\&. 
.br
\fI__a\fP An allocator\&.
.RE
.PP
Smoke a vector consistin of copiez of tha elements up in tha initializer_list \fI__l\fP\&.
.PP
This will call tha element typez copy constructor N times (where N is \fI__l\&.size()\fP) n' do no memory reallocation\&. 
.PP
Definizzle at line 364 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (_InputIterator__first, _InputIterator__last, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP"

.PP
Buildz a vector from a range\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&. 
.br
\fI__a\fP An allocator\&.
.RE
.PP
Smoke a vector consistin of copiez of tha elements from [first,last)\&.
.PP
If tha iterators is forward, bidirectional, or random-access, then dis will call tha elements' copy constructor N times (where N is distance(first,last)) n' do no memory reallocation\&. But if only input iterators is used, then dis will do at most 2N calls ta tha copy constructor, n' logN memory reallocations\&. 
.PP
Definizzle at line 392 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::~\fBvector\fP ()\fC [inline]\fP, \fC [noexcept]\fP"
Da dtor only erases tha elements, n' note dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 414 of file stl_vector\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _ForwardIterator > pointa \fBstd::vector\fP< _Tp, _Alloc >::_M_allocate_and_copy (size_type__n, _ForwardIterator__first, _ForwardIterator__last)\fC [inline]\fP, \fC [protected]\fP"
Memory expansion handlez\&. Uses tha member allocation function ta obtain \fIn\fP bytez of memory, n' then copies [first,last) tha fuck into it\&. 
.PP
Definizzle at line 1135 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::_M_range_check (size_type__n) const\fC [inline]\fP, \fC [protected]\fP"

.PP
Safety check used only from at()\&. 
.PP
Definizzle at line 791 of file stl_vector\&.h\&.
.PP
Referenced by std::vector< _State >::at()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::assign (size_type__n, const value_type &__val)\fC [inline]\fP"

.PP
Assigns a given value ta a vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Number of elements ta be assigned\&. 
.br
\fI__val\fP Value ta be assigned\&.
.RE
.PP
This function fills a vector wit \fI__n\fP copiez of tha given value\&. Note dat tha assignment straight-up chizzlez tha vector n' dat tha resultin vectorz size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 479 of file stl_vector\&.h\&.
.PP
Referenced by std::vector< _State >::assign(), n' std::vector< _State >::operator=()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> void \fBstd::vector\fP< _Tp, _Alloc >::assign (_InputIterator__first, _InputIterator__last)\fC [inline]\fP"

.PP
Assigns a range ta a vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&.
.RE
.PP
This function fills a vector wit copiez of tha elements up in tha range [__first,__last)\&.
.PP
Note dat tha assignment straight-up chizzlez tha vector n' dat tha resultin vectorz size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 498 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::assign (\fBinitializer_list\fP< value_type >__l)\fC [inline]\fP"

.PP
Assigns a initializer list ta a vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list\&.
.RE
.PP
This function fills a vector wit copiez of tha elements up in tha initializer list \fI__l\fP\&.
.PP
Note dat tha assignment straight-up chizzlez tha vector n' dat tha resultin vectorz size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 524 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::vector\fP< _Tp, _Alloc >::at (size_type__n)\fC [inline]\fP"

.PP
Provides access ta tha data contained up in tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha element fo' which data should be accessed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read/write reference ta data\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fI__n\fP be a invalid index\&.
.RE
.PP
This function serves up fo' less thuggy data access\&. Da parameta is first checked dat it is up in tha range of tha vector\&. Da function throws out_of_range if tha check fails\&. 
.PP
Definizzle at line 810 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::vector\fP< _Tp, _Alloc >::at (size_type__n) const\fC [inline]\fP"

.PP
Provides access ta tha data contained up in tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha element fo' which data should be accessed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) reference ta data\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fI__n\fP be a invalid index\&.
.RE
.PP
This function serves up fo' less thuggy data access\&. Da parameta is first checked dat it is up in tha range of tha vector\&. Da function throws out_of_range if tha check fails\&. 
.PP
Definizzle at line 828 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::vector\fP< _Tp, _Alloc >::back ()\fC [inline]\fP"
Returns a read/write reference ta tha data all up in tha last element of tha vector\&. 
.PP
Definizzle at line 855 of file stl_vector\&.h\&.
.PP
Referenced by std::piecewise_constant_distribution< _RealType >::max(), n' std::piecewise_linear_distribution< _RealType >::max()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::vector\fP< _Tp, _Alloc >::back () const\fC [inline]\fP"
Returns a read-only (constant) reference ta tha data all up in tha last element of tha vector\&. 
.PP
Definizzle at line 863 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> iterator \fBstd::vector\fP< _Tp, _Alloc >::begin ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write iterator dat points ta tha straight-up original gangsta element up in tha vector\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 538 of file stl_vector\&.h\&.
.PP
Referenced by std::vector< _State >::crend(), std::vector< _State >::empty(), std::vector< _State >::front(), __gnu_parallel::multiseq_partition(), __gnu_parallel::multiseq_selection(), __gnu_parallel::multiway_merge_exact_splitting(), std::operator<(), std::vector< _Tp, _Alloc >::operator=(), std::operator==(), std::vector< _State >::rend(), n' std::vector< _State >::vector()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_iterator \fBstd::vector\fP< _Tp, _Alloc >::begin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points ta tha straight-up original gangsta element up in tha vector\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 547 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::vector\fP< _Tp, _Alloc >::capacitizzle () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns tha total number of elements dat tha vector can hold before needin ta allocate mo' memory\&. 
.PP
Definizzle at line 725 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_iterator \fBstd::vector\fP< _Tp, _Alloc >::cbegin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points ta tha straight-up original gangsta element up in tha vector\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 611 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_iterator \fBstd::vector\fP< _Tp, _Alloc >::cend () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points one past tha last element up in tha vector\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 620 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::clear ()\fC [inline]\fP, \fC [noexcept]\fP"
Erases all tha elements\&. Note dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 1125 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::vector\fP< _Tp, _Alloc >::crbegin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta tha last element up in tha vector\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 629 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::vector\fP< _Tp, _Alloc >::crend () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta one before tha straight-up original gangsta element up in tha vector\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 638 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> _Tp* \fBstd::vector\fP< _Tp, _Alloc >::data ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a pointa such dat [data(), data() + size()) be a valid range\&. For a non-empty vector, data() == &front()\&. 
.PP
Definizzle at line 878 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename\&.\&.\&. _Args> iterator \fBstd::vector\fP< _Tp, _Alloc >::emplace (iterator__position, _Args &&\&.\&.\&.__args)"

.PP
Inserts a object up in vector before specified iterator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha vector\&. 
.br
\fI__args\fP Arguments\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha banged data\&.
.RE
.PP
This function will bang a object of type T constructed wit T(std::forward<Args>(args)\&.\&.\&.) before tha specified location\&. Note dat dis kind of operation could be high-rollin' fo' a vector n' if it is frequently used tha user should consider rockin std::list\&. 
.PP
Referenced by std::vector< _State >::insert()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> bool \fBstd::vector\fP< _Tp, _Alloc >::empty () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns legit if tha vector is empty\&. (Thus begin() would equal end()\&.) 
.PP
Definizzle at line 734 of file stl_vector\&.h\&.
.PP
Referenced by std::piecewise_constant_distribution< _RealType >::densities(), std::piecewise_linear_distribution< _RealType >::densities(), std::piecewise_constant_distribution< _RealType >::intervals(), std::piecewise_linear_distribution< _RealType >::intervals(), std::discrete_distribution< _IntType >::max(), std::piecewise_constant_distribution< _RealType >::max(), std::piecewise_linear_distribution< _RealType >::max(), std::piecewise_constant_distribution< _RealType >::min(), std::piecewise_linear_distribution< _RealType >::min(), n' std::discrete_distribution< _IntType >::probabilities()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> iterator \fBstd::vector\fP< _Tp, _Alloc >::end ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write iterator dat points one past tha last element up in tha vector\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 556 of file stl_vector\&.h\&.
.PP
Referenced by std::vector< _State >::back(), std::vector< _State >::crbegin(), std::vector< _State >::empty(), __gnu_parallel::multiseq_partition(), __gnu_parallel::multiseq_selection(), __gnu_parallel::multiway_merge_exact_splitting(), std::operator<(), std::vector< _Tp, _Alloc >::operator=(), std::operator==(), std::vector< _State >::push_back(), std::vector< _State >::rbegin(), std::vector< _State >::resize(), n' std::vector< _State >::vector()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_iterator \fBstd::vector\fP< _Tp, _Alloc >::end () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points one past tha last element up in tha vector\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 565 of file stl_vector\&.h\&.
.SS "template<typename _Tp , typename _Alloc > \fBvector\fP< _Tp, _Alloc >::iterator vector::erase (iterator__position)"

.PP
Remove element at given position\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP Iterator pointin ta element ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator pointin ta tha next element (or end())\&.
.RE
.PP
This function will erase tha element all up in tha given posizzle n' thus shorten tha vector by one\&.
.PP
Note This operation could be high-rollin' n' if it is frequently used tha user should consider rockin std::list\&. Da user be also cautioned dat dis function only erases tha element, n' dat if tha element is itself a pointer, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 135 of file vector\&.tcc\&.
.PP
References std::end()\&.
.SS "template<typename _Tp , typename _Alloc > \fBvector\fP< _Tp, _Alloc >::iterator vector::erase (iterator__first, iterator__last)"

.PP
Remove a range of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP Iterator pointin ta tha straight-up original gangsta element ta be erased\&. 
.br
\fI__last\fP Iterator pointin ta one past tha last element ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator pointin ta tha element pointed ta by \fI__last\fP prior ta erasin (or end())\&.
.RE
.PP
This function will erase tha elements up in tha range [__first,__last) n' shorten tha vector accordingly\&.
.PP
Note This operation could be high-rollin' n' if it is frequently used tha user should consider rockin std::list\&. Da user be also cautioned dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 147 of file vector\&.tcc\&.
.PP
References std::end()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::vector\fP< _Tp, _Alloc >::front ()\fC [inline]\fP"
Returns a read/write reference ta tha data all up in tha straight-up original gangsta element of tha vector\&. 
.PP
Definizzle at line 839 of file stl_vector\&.h\&.
.PP
Referenced by std::vector< _State >::data(), std::piecewise_constant_distribution< _RealType >::min(), n' std::piecewise_linear_distribution< _RealType >::min()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::vector\fP< _Tp, _Alloc >::front () const\fC [inline]\fP"
Returns a read-only (constant) reference ta tha data all up in tha straight-up original gangsta element of tha vector\&. 
.PP
Definizzle at line 847 of file stl_vector\&.h\&.
.SS "template<typename _Tp , typename _Alloc > \fBvector\fP< _Tp, _Alloc >::iterator vector::insert (iterator__position, const value_type &__x)"

.PP
Inserts given value tha fuck into vector before specified iterator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha vector\&. 
.br
\fI__x\fP Data ta be inserted\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha banged data\&.
.RE
.PP
This function will bang a cold-ass lil copy of tha given value before tha specified location\&. Note dat dis kind of operation could be high-rollin' fo' a vector n' if it is frequently used tha user should consider rockin std::list\&. 
.PP
Definizzle at line 108 of file vector\&.tcc\&.
.PP
References std::begin(), n' std::end()\&.
.PP
Referenced by std::vector< _State >::insert(), n' std::vector< _State >::resize()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> iterator \fBstd::vector\fP< _Tp, _Alloc >::insert (iterator__position, value_type &&__x)\fC [inline]\fP"

.PP
Inserts given rvalue tha fuck into vector before specified iterator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha vector\&. 
.br
\fI__x\fP Data ta be inserted\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha banged data\&.
.RE
.PP
This function will bang a cold-ass lil copy of tha given rvalue before tha specified location\&. Note dat dis kind of operation could be high-rollin' fo' a vector n' if it is frequently used tha user should consider rockin std::list\&. 
.PP
Definizzle at line 988 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::insert (iterator__position, \fBinitializer_list\fP< value_type >__l)\fC [inline]\fP"

.PP
Inserts a initializer_list tha fuck into tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha vector\&. 
.br
\fI__l\fP An initializer_list\&.
.RE
.PP
This function will bang copiez of tha data up in tha initializer_list \fIl\fP tha fuck into tha vector before tha location specified by \fIposition\fP\&.
.PP
Note dat dis kind of operation could be high-rollin' fo' a vector n' if it is frequently used tha user should consider rockin std::list\&. 
.PP
Definizzle at line 1005 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::insert (iterator__position, size_type__n, const value_type &__x)\fC [inline]\fP"

.PP
Inserts a fuckin shitload of copiez of given data tha fuck into tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha vector\&. 
.br
\fI__n\fP Number of elements ta be inserted\&. 
.br
\fI__x\fP Data ta be inserted\&.
.RE
.PP
This function will bang a specified number of copiez of tha given data before tha location specified by \fIposition\fP\&.
.PP
Note dat dis kind of operation could be high-rollin' fo' a vector n' if it is frequently used tha user should consider rockin std::list\&. 
.PP
Definizzle at line 1023 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> void \fBstd::vector\fP< _Tp, _Alloc >::insert (iterator__position, _InputIterator__first, _InputIterator__last)\fC [inline]\fP"

.PP
Inserts a range tha fuck into tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha vector\&. 
.br
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&.
.RE
.PP
This function will bang copiez of tha data up in tha range [__first,__last) tha fuck into tha vector before tha location specified by \fIpos\fP\&.
.PP
Note dat dis kind of operation could be high-rollin' fo' a vector n' if it is frequently used tha user should consider rockin std::list\&. 
.PP
Definizzle at line 1044 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::vector\fP< _Tp, _Alloc >::max_size () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns tha size() of tha phattest possible vector\&. 
.PP
Definizzle at line 650 of file stl_vector\&.h\&.
.SS "template<typename _Tp , typename _Alloc > \fBvector\fP< _Tp, _Alloc > & vector::operator= (const \fBvector\fP< _Tp, _Alloc > &__x)"

.PP
Vector assignment operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A vector of identical element n' allocator types\&.
.RE
.PP
All tha elementz of \fI__x\fP is copied yo, but any extra memory up in \fI__x\fP (for fast expansion) aint gonna be copied\&. Unlike tha copy constructor, tha allocator object aint copied\&. 
.PP
Definizzle at line 161 of file vector\&.tcc\&.
.PP
References std::_Destroy(), std::begin(), std::vector< _Tp, _Alloc >::begin(), std::end(), std::vector< _Tp, _Alloc >::end(), std::vector< _Tp, _Alloc >::size(), n' std::size()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBvector\fP& \fBstd::vector\fP< _Tp, _Alloc >::operator= (\fBvector\fP< _Tp, _Alloc > &&__x)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Vector move assignment operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A vector of identical element n' allocator types\&.
.RE
.PP
Da contentz of \fI__x\fP is moved tha fuck into dis vector (without copying, if tha allocators permit it)\&. \fI__x\fP be a valid yo, but unspecified vector\&. 
.PP
Definizzle at line 439 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBvector\fP& \fBstd::vector\fP< _Tp, _Alloc >::operator= (\fBinitializer_list\fP< value_type >__l)\fC [inline]\fP"

.PP
Vector list assignment operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list\&.
.RE
.PP
This function fills a vector wit copiez of tha elements up in tha initializer list \fI__l\fP\&.
.PP
Note dat tha assignment straight-up chizzlez tha vector n' dat tha resultin vectorz size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 461 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::vector\fP< _Tp, _Alloc >::operator[] (size_type__n)\fC [inline]\fP"

.PP
Subscript access ta tha data contained up in tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha element fo' which data should be accessed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read/write reference ta data\&.
.RE
.PP
This operator allows fo' easy as fuck , array-style, data access\&. Note dat data access wit dis operator is unchecked n' out_of_range lookups is not defined\&. (For checked lookups peep at()\&.) 
.PP
Definizzle at line 770 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::vector\fP< _Tp, _Alloc >::operator[] (size_type__n) const\fC [inline]\fP"

.PP
Subscript access ta tha data contained up in tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha element fo' which data should be accessed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) reference ta data\&.
.RE
.PP
This operator allows fo' easy as fuck , array-style, data access\&. Note dat data access wit dis operator is unchecked n' out_of_range lookups is not defined\&. (For checked lookups peep at()\&.) 
.PP
Definizzle at line 785 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::pop_back ()\fC [inline]\fP"

.PP
Removes last element\&. This be a typical stack operation\&. Well shiiiit, it shrinks tha vector by one\&.
.PP
Note dat no data is returned, n' if tha last elementz data is needed, it should be retrieved before pop_back() is called\&. 
.PP
Definizzle at line 937 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::push_back (const value_type &__x)\fC [inline]\fP"

.PP
Add data ta tha end of tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Data ta be added\&.
.RE
.PP
This be a typical stack operation\&. Da function creates a element all up in tha end of tha vector n' assigns tha given data ta it\&. Cuz of tha nature of a vector dis operation can be done up in constant time if tha vector has preallocated space available\&. 
.PP
Definizzle at line 901 of file stl_vector\&.h\&.
.PP
Referenced by __gnu_parallel::multiseq_partition(), n' __gnu_parallel::multiseq_selection()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBreverse_iterator\fP \fBstd::vector\fP< _Tp, _Alloc >::rbegin ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write reverse iterator dat points ta tha last element up in tha vector\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 574 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::vector\fP< _Tp, _Alloc >::rbegin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta tha last element up in tha vector\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 583 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBreverse_iterator\fP \fBstd::vector\fP< _Tp, _Alloc >::rend ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write reverse iterator dat points ta one before tha straight-up original gangsta element up in tha vector\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 592 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::vector\fP< _Tp, _Alloc >::rend () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta one before tha straight-up original gangsta element up in tha vector\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 601 of file stl_vector\&.h\&.
.SS "template<typename _Tp , typename _Alloc > void vector::reserve (size_type__n)"

.PP
Attempt ta preallocate enough memory fo' specified number of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Number of elements required\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If \fIn\fP exceedz \fCmax_size()\fP\&.
.RE
.PP
This function attempts ta reserve enough memory fo' tha vector ta hold tha specified number of elements\&. If tha number axed is mo' than max_size(), length_error is thrown\&.
.PP
Da advantage of dis function is dat if optimal code be a necessitizzle n' tha user can determine tha number of elements dat is ghon be required, tha user can reserve tha memory up in advance, n' thus prevent a possible reallocation of memory n' copyin of vector data\&. 
.PP
Definizzle at line 66 of file vector\&.tcc\&.
.PP
References std::_Destroy(), n' std::size()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::resize (size_type__new_size)\fC [inline]\fP"

.PP
Resizes tha vector ta tha specified number of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__new_size\fP Number of elements tha vector should contain\&.
.RE
.PP
This function will resize tha vector ta tha specified number of elements\&. If tha number is smalla than tha vectorz current size tha vector is truncated, otherwise default constructed elements is appended\&. 
.PP
Definizzle at line 664 of file stl_vector\&.h\&.
.PP
Referenced by __gnu_parallel::__shrink_and_double(), n' __gnu_parallel::multiway_merge_exact_splitting()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::resize (size_type__new_size, const value_type &__x)\fC [inline]\fP"

.PP
Resizes tha vector ta tha specified number of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__new_size\fP Number of elements tha vector should contain\&. 
.br
\fI__x\fP Data wit which freshly smoked up elements should be populated\&.
.RE
.PP
This function will resize tha vector ta tha specified number of elements\&. If tha number is smalla than tha vectorz current size tha vector is truncated, otherwise tha vector is extended n' freshly smoked up elements is populated wit given data\&. 
.PP
Definizzle at line 684 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::shrink_to_fit ()\fC [inline]\fP"
A non-bindin request ta reduce capacity() ta size()\&. 
.PP
Definizzle at line 716 of file stl_vector\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::vector\fP< _Tp, _Alloc >::size () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns tha number of elements up in tha vector\&. 
.PP
Definizzle at line 645 of file stl_vector\&.h\&.
.PP
Referenced by __gnu_parallel::__shrink(), __gnu_parallel::__shrink_and_double(), std::vector< _State >::_M_range_check(), __gnu_parallel::list_partition(), std::discrete_distribution< _IntType >::max(), std::vector< _Tp, _Alloc >::operator=(), std::operator==(), n' std::vector< _State >::resize()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::swap (\fBvector\fP< _Tp, _Alloc > &__x)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Swaps data wit another vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A vector of tha same element n' allocator types\&.
.RE
.PP
This exchanges tha elements between two vectors up in constant time\&. (Three pointers, so it should be like fast\&.) Note dat tha global std::swap() function is specialized such dat std::swap(v1,v2) will feed ta dis function\&. 
.PP
Definizzle at line 1108 of file stl_vector\&.h\&.
.PP
Referenced by std::swap()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
