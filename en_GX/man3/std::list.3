" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::list< _Tp, _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBstd::_List_base< _Tp, _Alloc >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef \fB_List_const_iterator\fP< _Tp > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef 
.br
_Tp_alloc_type::const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef 
.br
_Tp_alloc_type::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< \fBconst_iterator\fP > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef \fB_List_iterator\fP< _Tp > \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< \fBiterator\fP > \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Tp \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBlist\fP ()"
.br
.ti -1c
.RI "\fBlist\fP (const allocator_type &__a)"
.br
.ti -1c
.RI "\fBlist\fP (size_type __n)"
.br
.ti -1c
.RI "\fBlist\fP (size_type __n, const value_type &__value, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBlist\fP (const \fBlist\fP &__x)"
.br
.ti -1c
.RI "\fBlist\fP (\fBlist\fP &&__x) noexcept"
.br
.ti -1c
.RI "\fBlist\fP (\fBinitializer_list\fP< value_type > __l, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> \fBlist\fP (_InputIterator __first, _InputIterator __last, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "void \fBassign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> void \fBassign\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBassign\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "reference \fBback\fP ()"
.br
.ti -1c
.RI "const_reference \fBback\fP () const "
.br
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const noexcept"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBlist\fP< _Tp, _Alloc >::\fBiterator\fP \fBemplace\fP (\fBiterator\fP __position, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBiterator\fP \fBemplace\fP (\fBiterator\fP __position, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> void \fBemplace_back\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> void \fBemplace_front\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const noexcept"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __position)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __first, \fBiterator\fP __last)"
.br
.ti -1c
.RI "reference \fBfront\fP ()"
.br
.ti -1c
.RI "const_reference \fBfront\fP () const "
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const noexcept"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBiterator\fP __position, const value_type &__x)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBiterator\fP __position, value_type &&__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __p, \fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __position, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> void \fBinsert\fP (\fBiterator\fP __position, _InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const noexcept"
.br
.ti -1c
.RI "void \fBmerge\fP (\fBlist\fP &&__x)"
.br
.ti -1c
.RI "void \fBmerge\fP (\fBlist\fP &__x)"
.br
.ti -1c
.RI "template<typename _StrictWeakOrderin > void \fBmerge\fP (\fBlist\fP &&__x, _StrictWeakOrderin __comp)"
.br
.ti -1c
.RI "template<typename _StrictWeakOrderin > void \fBmerge\fP (\fBlist\fP &__x, _StrictWeakOrderin __comp)"
.br
.ti -1c
.RI "\fBlist\fP & \fBoperator=\fP (const \fBlist\fP &__x)"
.br
.ti -1c
.RI "\fBlist\fP & \fBoperator=\fP (\fBlist\fP &&__x)"
.br
.ti -1c
.RI "\fBlist\fP & \fBoperator=\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.ti -1c
.RI "void \fBpop_front\fP ()"
.br
.ti -1c
.RI "void \fBpush_back\fP (const value_type &__x)"
.br
.ti -1c
.RI "void \fBpush_back\fP (value_type &&__x)"
.br
.ti -1c
.RI "void \fBpush_front\fP (const value_type &__x)"
.br
.ti -1c
.RI "void \fBpush_front\fP (value_type &&__x)"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const noexcept"
.br
.ti -1c
.RI "void \fBremove\fP (const _Tp &__value)"
.br
.ti -1c
.RI "template<typename _Predicate > void \fBremove_if\fP (_Predicate)"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size, const value_type &__x)"
.br
.ti -1c
.RI "void \fBreverse\fP () noexcept"
.br
.ti -1c
.RI "size_type \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "void \fBsort\fP ()"
.br
.ti -1c
.RI "template<typename _StrictWeakOrderin > void \fBsort\fP (_StrictWeakOrdering)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &&__x)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &__x)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &&__x, \fBiterator\fP __i)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &__x, \fBiterator\fP __i)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &&__x, \fBiterator\fP __first, \fBiterator\fP __last)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &__x, \fBiterator\fP __first, \fBiterator\fP __last)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBlist\fP &__x)"
.br
.ti -1c
.RI "void \fBunique\fP ()"
.br
.ti -1c
.RI "template<typename _BinaryPredicate > void \fBunique\fP (_BinaryPredicate)"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef \fB_List_node\fP< _Tp > \fB_Node\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "template<typename _Integer > void \fB_M_assign_dispatch\fP (_Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_assign_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "void \fB_M_check_equal_allocators\fP (\fBlist\fP &__x)"
.br
.ti -1c
.RI "void \fB_M_clear\fP ()"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fB_Node\fP * \fB_M_create_node\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "void \fB_M_default_append\fP (size_type __n)"
.br
.ti -1c
.RI "void \fB_M_default_initialize\fP (size_type __n)"
.br
.ti -1c
.RI "void \fB_M_erase\fP (\fBiterator\fP __position)"
.br
.ti -1c
.RI "void \fB_M_fill_assign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "void \fB_M_fill_initialize\fP (size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "\fB_List_node\fP< _Tp > * \fB_M_get_node\fP ()"
.br
.ti -1c
.RI "_Node_alloc_type & \fB_M_get_Node_allocator\fP () noexcept"
.br
.ti -1c
.RI "const _Node_alloc_type & \fB_M_get_Node_allocator\fP () const noexcept"
.br
.ti -1c
.RI "_Tp_alloc_type \fB_M_get_Tp_allocator\fP () const noexcept"
.br
.ti -1c
.RI "void \fB_M_init\fP ()"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_initialize_dispatch\fP (_Integer __n, _Integer __x, __true_type)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_initialize_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> void \fB_M_insert\fP (\fBiterator\fP __position, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "void \fB_M_put_node\fP (\fB_List_node\fP< _Tp > *__p)"
.br
.ti -1c
.RI "void \fB_M_transfer\fP (\fBiterator\fP __position, \fBiterator\fP __first, \fBiterator\fP __last)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_List_impl \fB_M_impl\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>>class std::list< _Tp, _Alloc >"
A standard container wit linear time access ta elements, n' fixed time insertion/deletion at any point up in tha sequence\&. 


.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Tp\fP Type of element\&. 
.br
\fI_Alloc\fP Allocator type, defaults ta allocator<_Tp>\&.
.RE
.PP
Meets tha requirementz of a \fCcontainer\fP, a \fCreversible container\fP, n' a \fCsequence\fP, includin tha \fCoptionizzle sequence requirements\fP wit tha exception of \fCat\fP n' \fCoperator\fP[]\&.
.PP
This be a \fIdoubly\fP \fIlinked\fP list\&. Traversal up n' down tha list requires linear time yo, but addin n' removin elements (or \fInodes\fP) is done up in constant time, regardless of where tha chizzle takes place\&. Unlike std::vector n' std::deque, random-access iterators is not provided, so subscriptin ( \fC\fP[] ) access aint allowed\&. For algorithms which only need sequential access, dis lack make no difference\&.
.PP
Also unlike tha other standard containers, std::list serves up specialized algorithms unique ta linked lists, like fuckin splicing, sorting, n' in-place reversal\&.
.PP
A couple points on memory allocation fo' list<Tp>:
.PP
First, we never straight-up allocate a Tp, we allocate List_node<Tp>z n' trust [20\&.1\&.5]/4 ta DTRT\&. This is ta ensure dat afta elements from list<X,Alloc1> is spliced tha fuck into list<X,Alloc2>, beatin tha livin shiznit outta tha memory of tha second list be a valid operation, i\&.e\&., Alloc1 giveth n' Alloc2 taketh away\&.
.PP
Second, a list conceptually represented as 
.PP
.nf
A <---> B <---> C <---> D

.fi
.PP
 is straight-up circular; a link exists between A n' D\&. Da list class holdz (as its only data member) a private list::iterator pointin ta \fID\fP, not ta \fIA!\fP To git ta tha head of tha list, we start all up in tha tail n' move forward by one\&. When dis member iteratorz next/previous pointas refer ta itself, tha list is empty\&. 
.PP
Definizzle at line 438 of file stl_list\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP ()\fC [inline]\fP"

.PP
Default constructor creates no elements\&. 
.PP
Definizzle at line 523 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP (const allocator_type &__a)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Creates a list wit no elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator object\&. 
.RE
.PP

.PP
Definizzle at line 531 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP (size_type__n)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Creates a list wit default constructed elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da number of elements ta initially create\&.
.RE
.PP
This constructor fills tha list wit \fI__n\fP default constructed elements\&. 
.PP
Definizzle at line 543 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP (size_type__n, const value_type &__value, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP"

.PP
Creates a list wit copiez of a exemplar element\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da number of elements ta initially create\&. 
.br
\fI__value\fP An element ta copy\&. 
.br
\fI__a\fP An allocator object\&.
.RE
.PP
This constructor fills tha list wit \fI__n\fP copiez of \fI__value\fP\&. 
.PP
Definizzle at line 555 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP (const \fBlist\fP< _Tp, _Alloc > &__x)\fC [inline]\fP"

.PP
List copy constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A list of identical element n' allocator types\&.
.RE
.PP
Da newly-created list uses a cold-ass lil copy of tha allocation object used by \fI__x\fP\&. 
.PP
Definizzle at line 582 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP (\fBlist\fP< _Tp, _Alloc > &&__x)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
List move constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A list of identical element n' allocator types\&.
.RE
.PP
Da newly-created list gotz nuff tha exact contentz of \fI__x\fP\&. Da contentz of \fI__x\fP is a valid yo, but unspecified list\&. 
.PP
Definizzle at line 594 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP (\fBinitializer_list\fP< value_type >__l, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP"

.PP
Buildz a list from a initializer_list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list of value_type\&. 
.br
\fI__a\fP An allocator object\&.
.RE
.PP
Smoke a list consistin of copiez of tha elements up in tha initializer_list \fI__l\fP\&. This is linear up in __l\&.size()\&. 
.PP
Definizzle at line 605 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP (_InputIterator__first, _InputIterator__last, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP"

.PP
Buildz a list from a range\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&. 
.br
\fI__a\fP An allocator object\&.
.RE
.PP
Smoke a list consistin of copiez of tha elements from [\fI__first\fP,\fI__last\fP)\&. This is linear up in N (where N is distance(\fI__first\fP,\fI__last\fP))\&. 
.PP
Definizzle at line 624 of file stl_list\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename\&.\&.\&. _Args> \fB_Node\fP* \fBstd::list\fP< _Tp, _Alloc >::_M_create_node (_Args &&\&.\&.\&.__args)\fC [inline]\fP, \fC [protected]\fP"

.PP
\fBParameters:\fP
.RS 4
\fI__args\fP An instizzle of user data\&.
.RE
.PP
Allocates space fo' a freshly smoked up node n' constructs a cold-ass lil copy of \fI__args\fP up in it\&. 
.PP
Definizzle at line 500 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::assign (size_type__n, const value_type &__val)\fC [inline]\fP"

.PP
Assigns a given value ta a list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Number of elements ta be assigned\&. 
.br
\fI__val\fP Value ta be assigned\&.
.RE
.PP
This function fills a list wit \fI__n\fP copiez of tha given value\&. Note dat tha assignment straight-up chizzlez tha list n' dat tha resultin listz size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 702 of file stl_list\&.h\&.
.PP
Referenced by std::list< __inp, __rebind_inp >::assign(), n' std::list< __inp, __rebind_inp >::operator=()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> void \fBstd::list\fP< _Tp, _Alloc >::assign (_InputIterator__first, _InputIterator__last)\fC [inline]\fP"

.PP
Assigns a range ta a list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&.
.RE
.PP
This function fills a list wit copiez of tha elements up in tha range [\fI__first\fP,\fI__last\fP)\&.
.PP
Note dat tha assignment straight-up chizzlez tha list n' dat tha resultin listz size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 721 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::assign (\fBinitializer_list\fP< value_type >__l)\fC [inline]\fP"

.PP
Assigns a initializer_list ta a list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list of value_type\&.
.RE
.PP
Replace tha contentz of tha list wit copiez of tha elements up in tha initializer_list \fI__l\fP\&. This is linear up in __l\&.size()\&. 
.PP
Definizzle at line 743 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::list\fP< _Tp, _Alloc >::back ()\fC [inline]\fP"
Returns a read/write reference ta tha data all up in tha last element of tha list\&. 
.PP
Definizzle at line 943 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::list\fP< _Tp, _Alloc >::back () const\fC [inline]\fP"
Returns a read-only (constant) reference ta tha data all up in tha last element of tha list\&. 
.PP
Definizzle at line 955 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::list\fP< _Tp, _Alloc >::begin ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write iterator dat points ta tha straight-up original gangsta element up in tha list\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 758 of file stl_list\&.h\&.
.PP
Referenced by std::list< __inp, __rebind_inp >::crend(), std::list< __inp, __rebind_inp >::front(), std::list< __inp, __rebind_inp >::list(), std::list< _Tp, _Alloc >::merge(), std::list< _Tp, _Alloc >::operator=(), std::operator==(), std::list< __inp, __rebind_inp >::pop_front(), std::list< __inp, __rebind_inp >::push_front(), std::list< __inp, __rebind_inp >::rend(), std::list< __inp, __rebind_inp >::size(), std::list< _Tp, _Alloc >::sort(), n' std::list< __inp, __rebind_inp >::splice()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::begin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points ta tha straight-up original gangsta element up in tha list\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 767 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::cbegin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points ta tha straight-up original gangsta element up in tha list\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 831 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::cend () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points one past tha last element up in tha list\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 840 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::clear ()\fC [inline]\fP, \fC [noexcept]\fP"
Erases all tha elements\&. Note dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 1228 of file stl_list\&.h\&.
.PP
Referenced by std::list< __inp, __rebind_inp >::operator=()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::crbegin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta tha last element up in tha list\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 849 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::crend () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta one before tha straight-up original gangsta element up in tha list\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 858 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename\&.\&.\&. _Args> \fBiterator\fP \fBstd::list\fP< _Tp, _Alloc >::emplace (\fBiterator\fP__position, _Args &&\&.\&.\&.__args)"

.PP
Constructs object up in list before specified iterator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP A const_iterator tha fuck into tha list\&. 
.br
\fI__args\fP Arguments\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha banged data\&.
.RE
.PP
This function will bang a object of type T constructed wit T(std::forward<Args>(args)\&.\&.\&.) before tha specified location\&. Cuz of tha nature of a list dis operation can be done up in constant time, n' do not invalidate iterators n' references\&. 
.PP
Referenced by std::list< __inp, __rebind_inp >::insert()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> bool \fBstd::list\fP< _Tp, _Alloc >::empty () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns legit if tha list is empty\&. (Thus begin() would equal end()\&.) 
.PP
Definizzle at line 868 of file stl_list\&.h\&.
.PP
Referenced by std::list< _Tp, _Alloc >::sort(), n' std::list< __inp, __rebind_inp >::splice()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::list\fP< _Tp, _Alloc >::end ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write iterator dat points one past tha last element up in tha list\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 776 of file stl_list\&.h\&.
.PP
Referenced by std::list< __inp, __rebind_inp >::back(), std::list< __inp, __rebind_inp >::crbegin(), std::list< __inp, __rebind_inp >::list(), std::list< _Tp, _Alloc >::merge(), std::list< _Tp, _Alloc >::operator=(), std::operator==(), std::list< __inp, __rebind_inp >::push_back(), std::list< __inp, __rebind_inp >::rbegin(), std::list< __inp, __rebind_inp >::size(), n' std::list< __inp, __rebind_inp >::splice()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::end () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points one past tha last element up in tha list\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 785 of file stl_list\&.h\&.
.SS "template<typename _Tp , typename _Alloc > \fBlist\fP< _Tp, _Alloc >::\fBiterator\fP list::erase (\fBiterator\fP__position)"

.PP
Remove element at given position\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP Iterator pointin ta element ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator pointin ta tha next element (or end())\&.
.RE
.PP
This function will erase tha element all up in tha given posizzle n' thus shorten tha list by one\&.
.PP
Cuz of tha nature of a list dis operation can be done up in constant time, n' only invalidates iterators/references ta tha element bein removed\&. Da user be also cautioned dat dis function only erases tha element, n' dat if tha element is itself a pointer, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 109 of file list\&.tcc\&.
.PP
Referenced by std::list< __inp, __rebind_inp >::erase()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::list\fP< _Tp, _Alloc >::erase (\fBiterator\fP__first, \fBiterator\fP__last)\fC [inline]\fP"

.PP
Remove a range of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP Iterator pointin ta tha straight-up original gangsta element ta be erased\&. 
.br
\fI__last\fP Iterator pointin ta one past tha last element ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator pointin ta tha element pointed ta by \fIlast\fP prior ta erasin (or end())\&.
.RE
.PP
This function will erase tha elements up in tha range \fI\fP[first,last) n' shorten tha list accordingly\&.
.PP
This operation is linear time up in tha size of tha range n' only invalidates iterators/references ta tha element bein removed\&. Da user be also cautioned dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 1193 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::list\fP< _Tp, _Alloc >::front ()\fC [inline]\fP"
Returns a read/write reference ta tha data all up in tha straight-up original gangsta element of tha list\&. 
.PP
Definizzle at line 927 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::list\fP< _Tp, _Alloc >::front () const\fC [inline]\fP"
Returns a read-only (constant) reference ta tha data all up in tha straight-up original gangsta element of tha list\&. 
.PP
Definizzle at line 935 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> allocator_type \fBstd::list\fP< _Tp, _Alloc >::get_allocator () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Git a cold-ass lil copy of tha memory allocation object\&. 
.PP
Definizzle at line 749 of file stl_list\&.h\&.
.PP
Referenced by std::list< __inp, __rebind_inp >::insert()\&.
.SS "template<typename _Tp , typename _Alloc > \fBlist\fP< _Tp, _Alloc >::\fBiterator\fP list::insert (\fBiterator\fP__position, const value_type &__x)"

.PP
Inserts given value tha fuck into list before specified iterator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha list\&. 
.br
\fI__x\fP Data ta be inserted\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha banged data\&.
.RE
.PP
This function will bang a cold-ass lil copy of tha given value before tha specified location\&. Cuz of tha nature of a list dis operation can be done up in constant time, n' do not invalidate iterators n' references\&. 
.PP
Definizzle at line 99 of file list\&.tcc\&.
.PP
Referenced by std::list< __inp, __rebind_inp >::insert()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::list\fP< _Tp, _Alloc >::insert (\fBiterator\fP__position, value_type &&__x)\fC [inline]\fP"

.PP
Inserts given rvalue tha fuck into list before specified iterator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha list\&. 
.br
\fI__x\fP Data ta be inserted\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha banged data\&.
.RE
.PP
This function will bang a cold-ass lil copy of tha given rvalue before tha specified location\&. Cuz of tha nature of a list dis operation can be done up in constant time, n' do not invalidate iterators n' references\&. 
.PP
Definizzle at line 1089 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::insert (\fBiterator\fP__p, \fBinitializer_list\fP< value_type >__l)\fC [inline]\fP"

.PP
Inserts tha contentz of a initializer_list tha fuck into list before specified iterator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP An iterator tha fuck into tha list\&. 
.br
\fI__l\fP An initializer_list of value_type\&.
.RE
.PP
This function will bang copiez of tha data up in tha initializer_list \fIl\fP tha fuck into tha list before tha location specified by \fIp\fP\&.
.PP
This operation is linear up in tha number of elements banged n' do not invalidate iterators n' references\&. 
.PP
Definizzle at line 1106 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::insert (\fBiterator\fP__position, size_type__n, const value_type &__x)\fC [inline]\fP"

.PP
Inserts a fuckin shitload of copiez of given data tha fuck into tha list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha list\&. 
.br
\fI__n\fP Number of elements ta be inserted\&. 
.br
\fI__x\fP Data ta be inserted\&.
.RE
.PP
This function will bang a specified number of copiez of tha given data before tha location specified by \fIposition\fP\&.
.PP
This operation is linear up in tha number of elements banged n' do not invalidate iterators n' references\&. 
.PP
Definizzle at line 1123 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> void \fBstd::list\fP< _Tp, _Alloc >::insert (\fBiterator\fP__position, _InputIterator__first, _InputIterator__last)\fC [inline]\fP"

.PP
Inserts a range tha fuck into tha list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha list\&. 
.br
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&.
.RE
.PP
This function will bang copiez of tha data up in tha range [\fIfirst\fP,\fIlast\fP) tha fuck into tha list before tha location specified by \fIposition\fP\&.
.PP
This operation is linear up in tha number of elements banged n' do not invalidate iterators n' references\&. 
.PP
Definizzle at line 1149 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::list\fP< _Tp, _Alloc >::max_size () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns tha size() of tha phattest possible list\&. 
.PP
Definizzle at line 878 of file stl_list\&.h\&.
.SS "template<typename _Tp , typename _Alloc > void list::merge (\fBlist\fP< _Tp, _Alloc > &&__x)"

.PP
Merge sorted lists\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Sorted list ta merge\&.
.RE
.PP
Assumes dat both \fI__x\fP n' dis list is sorted accordin ta operator<()\&. Merges elementz of \fI__x\fP tha fuck into dis list up in sorted order, leavin \fI__x\fP empty when complete\&. Elements up in dis list precede elements up in \fI__x\fP dat is equal\&. 
.PP
Definizzle at line 288 of file list\&.tcc\&.
.PP
References std::begin(), std::list< _Tp, _Alloc >::begin(), std::end(), n' std::list< _Tp, _Alloc >::end()\&.
.PP
Referenced by std::list< _Tp, _Alloc >::sort()\&.
.SS "template<typename _Tp , typename _Alloc > template<typename _StrictWeakOrderin > void list::merge (\fBlist\fP< _Tp, _Alloc > &&__x, _StrictWeakOrdering__comp)"

.PP
Merge sorted lists accordin ta comparison function\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_StrictWeakOrdering\fP Comparison function definin sort order\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Sorted list ta merge\&. 
.br
\fI__comp\fP Comparison functor\&.
.RE
.PP
Assumes dat both \fI__x\fP n' dis list is sorted accordin ta StrictWeakOrdering\&. Merges elementz of \fI__x\fP tha fuck into dis list up in sorted order, leavin \fI__x\fP empty when complete\&. Elements up in dis list precede elements up in \fI__x\fP dat is equivalent accordin ta StrictWeakOrdering()\&. 
.PP
Definizzle at line 322 of file list\&.tcc\&.
.PP
References std::begin(), std::list< _Tp, _Alloc >::begin(), std::end(), n' std::list< _Tp, _Alloc >::end()\&.
.SS "template<typename _Tp , typename _Alloc > \fBlist\fP< _Tp, _Alloc > & list::operator= (const \fBlist\fP< _Tp, _Alloc > &__x)"

.PP
List assignment operator\&. No explicit dtor needed as tha _Base dtor takes care of thangs\&. Da _Base dtor only erases tha elements, n' note dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A list of identical element n' allocator types\&.
.RE
.PP
All tha elementz of \fI__x\fP is copied yo, but unlike tha copy constructor, tha allocator object aint copied\&. 
.PP
Definizzle at line 185 of file list\&.tcc\&.
.PP
References std::begin(), std::list< _Tp, _Alloc >::begin(), std::end(), n' std::list< _Tp, _Alloc >::end()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBlist\fP& \fBstd::list\fP< _Tp, _Alloc >::operator= (\fBlist\fP< _Tp, _Alloc > &&__x)\fC [inline]\fP"

.PP
List move assignment operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A list of identical element n' allocator types\&.
.RE
.PP
Da contentz of \fI__x\fP is moved tha fuck into dis list (without copying)\&. \fI__x\fP be a valid yo, but unspecified list 
.PP
Definizzle at line 667 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBlist\fP& \fBstd::list\fP< _Tp, _Alloc >::operator= (\fBinitializer_list\fP< value_type >__l)\fC [inline]\fP"

.PP
List initializer list assignment operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list of value_type\&.
.RE
.PP
Replace tha contentz of tha list wit copiez of tha elements up in tha initializer_list \fI__l\fP\&. This is linear up in l\&.size()\&. 
.PP
Definizzle at line 684 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::pop_back ()\fC [inline]\fP"

.PP
Removes last element\&. This be a typical stack operation\&. Well shiiiit, it shrinks tha list by one\&. Cuz of tha nature of a list dis operation can be done up in constant time, n' only invalidates iterators/references ta tha element bein removed\&.
.PP
Note dat no data is returned, n' if tha last elementz data is needed, it should be retrieved before pop_back() is called\&. 
.PP
Definizzle at line 1041 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::pop_front ()\fC [inline]\fP"

.PP
Removes first element\&. This be a typical stack operation\&. Well shiiiit, it shrinks tha list by one\&. Cuz of tha nature of a list dis operation can be done up in constant time, n' only invalidates iterators/references ta tha element bein removed\&.
.PP
Note dat no data is returned, n' if tha straight-up original gangsta elementz data is needed, it should be retrieved before pop_front() is called\&. 
.PP
Definizzle at line 1001 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::push_back (const value_type &__x)\fC [inline]\fP"

.PP
Add data ta tha end of tha list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Data ta be added\&.
.RE
.PP
This be a typical stack operation\&. Da function creates a element all up in tha end of tha list n' assigns tha given data ta it\&. Cuz of tha nature of a list dis operation can be done up in constant time, n' do not invalidate iterators n' references\&. 
.PP
Definizzle at line 1015 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::push_front (const value_type &__x)\fC [inline]\fP"

.PP
Add data ta tha front of tha list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Data ta be added\&.
.RE
.PP
This be a typical stack operation\&. Da function creates a element all up in tha front of tha list n' assigns tha given data ta it\&. Cuz of tha nature of a list dis operation can be done up in constant time, n' do not invalidate iterators n' references\&. 
.PP
Definizzle at line 974 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBreverse_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::rbegin ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write reverse iterator dat points ta tha last element up in tha list\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 794 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::rbegin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta tha last element up in tha list\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 803 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc > void list::remove (const _Tp &__value)"

.PP
Remove all elements equal ta value\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__value\fP Da value ta remove\&.
.RE
.PP
Removes every last muthafuckin element up in tha list equal ta \fIvalue\fP\&. Remainin elements stay up in list order\&. Note dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 239 of file list\&.tcc\&.
.PP
References std::__addressof(), std::begin(), n' std::end()\&.
.SS "template<typename _Tp , typename _Alloc > template<typename _Predicate > void list::remove_if (_Predicate__pred)"

.PP
Remove all elements satisfyin a predicate\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Predicate\fP Unary predicate function or object\&.
.RE
.PP
Removes every last muthafuckin element up in tha list fo' which tha predicate returns true\&. Remainin elements stay up in list order\&. Note dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 392 of file list\&.tcc\&.
.PP
References std::begin(), n' std::end()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBreverse_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::rend ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write reverse iterator dat points ta one before tha straight-up original gangsta element up in tha list\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 812 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::rend () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta one before tha straight-up original gangsta element up in tha list\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 821 of file stl_list\&.h\&.
.SS "template<typename _Tp , typename _Alloc > void list::resize (size_type__new_size)"

.PP
Resizes tha list ta tha specified number of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__new_size\fP Number of elements tha list should contain\&.
.RE
.PP
This function will resize tha list ta tha specified number of elements\&. If tha number is smalla than tha listz current size tha list is truncated, otherwise default constructed elements is appended\&. 
.PP
Definizzle at line 139 of file list\&.tcc\&.
.PP
References std::begin(), n' std::end()\&.
.SS "template<typename _Tp , typename _Alloc > void list::resize (size_type__new_size, const value_type &__x)"

.PP
Resizes tha list ta tha specified number of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__new_size\fP Number of elements tha list should contain\&. 
.br
\fI__x\fP Data wit which freshly smoked up elements should be populated\&.
.RE
.PP
This function will resize tha list ta tha specified number of elements\&. If tha number is smalla than tha listz current size tha list is truncated, otherwise tha list is extended n' freshly smoked up elements is populated wit given data\&. 
.PP
Definizzle at line 154 of file list\&.tcc\&.
.PP
References std::begin(), n' std::end()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::reverse ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Reverse tha elements up in list\&. Reverse tha order of elements up in tha list up in linear time\&. 
.PP
Definizzle at line 1449 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::list\fP< _Tp, _Alloc >::size () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns tha number of elements up in tha list\&. 
.PP
Definizzle at line 873 of file stl_list\&.h\&.
.SS "template<typename _Tp , typename _Alloc > void list::sort ()"

.PP
Sort tha elements\&. Right back up in yo muthafuckin ass. Sorts tha elementz of dis list up in NlogN time\&. Equivalent elements remain up in list order\&. 
.PP
Definizzle at line 354 of file list\&.tcc\&.
.PP
References std::begin(), std::list< _Tp, _Alloc >::begin(), std::list< _Tp, _Alloc >::empty(), std::list< _Tp, _Alloc >::merge(), std::list< _Tp, _Alloc >::splice(), n' std::list< _Tp, _Alloc >::swap()\&.
.SS "template<typename _Tp , typename _Alloc > template<typename _StrictWeakOrderin > void list::sort (_StrictWeakOrdering__comp)"

.PP
Sort tha elements accordin ta comparison function\&. Right back up in yo muthafuckin ass. Sorts tha elementz of dis list up in NlogN time\&. Equivalent elements remain up in list order\&. 
.PP
Definizzle at line 431 of file list\&.tcc\&.
.PP
References std::begin(), std::list< _Tp, _Alloc >::begin(), std::list< _Tp, _Alloc >::empty(), std::list< _Tp, _Alloc >::merge(), std::list< _Tp, _Alloc >::splice(), n' std::list< _Tp, _Alloc >::swap()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::splice (\fBiterator\fP__position, \fBlist\fP< _Tp, _Alloc > &&__x)\fC [inline]\fP"

.PP
Insert contentz of another list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP Iterator referencin tha element ta bang before\&. 
.br
\fI__x\fP Source list\&.
.RE
.PP
Da elementz of \fI__x\fP is banged up in constant time up in front of tha element referenced by \fI__position\fP\&. \fI__x\fP becomes a empty list\&.
.PP
Requires dis != \fI__x\fP\&. 
.PP
Definizzle at line 1248 of file stl_list\&.h\&.
.PP
Referenced by std::list< __inp, __rebind_inp >::insert(), n' std::list< _Tp, _Alloc >::sort()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::splice (\fBiterator\fP__position, \fBlist\fP< _Tp, _Alloc > &&__x, \fBiterator\fP__i)\fC [inline]\fP"

.PP
Insert element from another list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP Iterator referencin tha element ta bang before\&. 
.br
\fI__x\fP Source list\&. 
.br
\fI__i\fP Iterator referencin tha element ta move\&.
.RE
.PP
Removes tha element up in list \fI__x\fP referenced by \fI__i\fP n' bangs it tha fuck into tha current list before \fI__position\fP\&. 
.PP
Definizzle at line 1278 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::splice (\fBiterator\fP__position, \fBlist\fP< _Tp, _Alloc > &&__x, \fBiterator\fP__first, \fBiterator\fP__last)\fC [inline]\fP"

.PP
Insert range from another list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP Iterator referencin tha element ta bang before\&. 
.br
\fI__x\fP Source list\&. 
.br
\fI__first\fP Iterator referencin tha start of range up in x\&. 
.br
\fI__last\fP Iterator referencin tha end of range up in x\&.
.RE
.PP
Removes elements up in tha range [__first,__last) n' bangs dem before \fI__position\fP up in constant time\&.
.PP
Undefined if \fI__position\fP is up in [__first,__last)\&. 
.PP
Definizzle at line 1314 of file stl_list\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::swap (\fBlist\fP< _Tp, _Alloc > &__x)\fC [inline]\fP"

.PP
Swaps data wit another list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A list of tha same element n' allocator types\&.
.RE
.PP
This exchanges tha elements between two lists up in constant time\&. Note dat tha global std::swap() function is specialized such dat std::swap(l1,l2) will feed ta dis function\&. 
.PP
Definizzle at line 1210 of file stl_list\&.h\&.
.PP
Referenced by std::list< __inp, __rebind_inp >::operator=(), std::list< _Tp, _Alloc >::sort(), n' std::swap()\&.
.SS "template<typename _Tp , typename _Alloc > void list::unique ()"

.PP
Remove consecutizzle duplicate elements\&. For each consecutizzle set of elements wit tha same value, remove all but tha straight-up original gangsta one\&. Remainin elements stay up in list order\&. Note dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 267 of file list\&.tcc\&.
.PP
References std::begin(), n' std::end()\&.
.SS "template<typename _Tp , typename _Alloc > template<typename _BinaryPredicate > void list::unique (_BinaryPredicate__binary_pred)"

.PP
Remove consecutizzle elements satisfyin a predicate\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_BinaryPredicate\fP Binary predicate function or object\&.
.RE
.PP
For each consecutizzle set of elements [first,last) dat satisfy predicate(first,i) where i be a iterator up in [first,last), remove all but tha straight-up original gangsta one\&. Remainin elements stay up in list order\&. Note dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 410 of file list\&.tcc\&.
.PP
References std::begin(), n' std::end()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
