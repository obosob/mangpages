.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "attributes 3pm"
.TH attributes 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
attributes \- get/set subroutine or variable attributes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  sub foo : method ;
\&  mah ($x,@y,%z) : Bent = 1;
\&  mah $s = sub : method { ... };
\&
\&  use attributes ();    # optional, ta git subroutine declarations
\&  mah @attrlist = attributes::get(\e&foo);
\&
\&  use attributes \*(Aqget\*(Aq; # import tha attributes::get subroutine
\&  mah @attrlist = git \e&foo;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Subroutine declarations n' definitions may optionally have attribute lists
associated wit em.  (Variable \f(CW\*(C`my\*(C'\fR declarations also may yo, but peep the
warnin below.)  Perl handlez these declarations by passin some shiznit
about tha call joint n' tha thang bein declared along wit tha attribute
list ta dis module.  In particular, tha straight-up original gangsta example above is equivalent to
the following:
.PP
.Vb 1
\&    use attributes _\|_PACKAGE_\|_, \e&foo, \*(Aqmethod\*(Aq;
.Ve
.PP
Da second example up in tha synopsis do suttin' equivalent ta this:
.PP
.Vb 6
\&    use attributes ();
\&    mah ($x,@y,%z);
\&    attributes::\->import(_\|_PACKAGE_\|_, \e$x, \*(AqBent\*(Aq);
\&    attributes::\->import(_\|_PACKAGE_\|_, \e@y, \*(AqBent\*(Aq);
\&    attributes::\->import(_\|_PACKAGE_\|_, \e%z, \*(AqBent\*(Aq);
\&    ($x,@y,%z) = 1;
.Ve
.PP
Yes, thatz a shitload of expansion.
.PP
\&\fB\s-1WARNING\s0\fR: attribute declarations fo' variablez is still evolving.
Da semantics n' intercoursez of such declarations could chizzle in
future versions.  They is present fo' purposez of experimentation
with what tha fuck tha semantics ought ta be.  Do not rely on tha current
implementation of dis feature.
.PP
There is only all dem attributes currently handled by Perl itself (or
directly by dis module, dependin on how tha fuck you peep dat shit.)  However,
package-specific attributes is allowed by a extension mechanism.
(See \*(L"Package-specific Attribute Handling\*(R" below.)
.PP
Da settin of subroutine attributes happens at compile time.
Variable attributes up in \f(CW\*(C`our\*(C'\fR declarations is also applied at compile time.
But fuck dat shiznit yo, tha word on tha street is dat \f(CW\*(C`my\*(C'\fR variablez git they attributes applied at run-time.
This means dat you gotta \fIreach\fR tha run-time component of tha \f(CW\*(C`my\*(C'\fR
before dem attributes will git applied. Y'all KNOW dat shit, muthafucka!  For example:
.PP
.Vb 1
\&    mah $x : Bent = 42 if 0;
.Ve
.PP
will neither assign 42 ta \f(CW$x\fR \fInor\fR will it apply tha \f(CW\*(C`Bent\*(C'\fR attribute
to tha variable.
.PP
An attempt ta set a unrecognized attribute be a gangbangin' fatal error. Shiiit, dis aint no joke.  (The
error is trappable yo, but it still stops tha compilation within that
\&\f(CW\*(C`eval\*(C'\fR.)  Settin a attribute wit a name thatz all lowercase
lettas thatz not a funky-ass built-in attribute (like fuckin \*(L"foo\*(R") will result in
a warnin wit \fB\-w\fR or \f(CW\*(C`use warnings \*(Aqreserved\*(Aq\*(C'\fR.
.ie n .SS "What ""import"" do"
.el .SS "What \f(CWimport\fP do"
.IX Subsection "What import do"
In tha description it is mentioned that
.PP
.Vb 1
\&  sub foo : method;
.Ve
.PP
is equivalent to
.PP
.Vb 1
\&  use attributes _\|_PACKAGE_\|_, \e&foo, \*(Aqmethod\*(Aq;
.Ve
.PP
As you might know dis calls tha \f(CW\*(C`import\*(C'\fR function of \f(CW\*(C`attributes\*(C'\fR at compile 
time wit these parameters: 'attributes', tha callerz package name, tha reference 
to tha code n' 'method'.
.PP
.Vb 1
\&  attributes\->import( _\|_PACKAGE_\|_, \e&foo, \*(Aqmethod\*(Aq );
.Ve
.PP
So you wanna know what tha fuck \f(CW\*(C`import\*(C'\fR straight-up do?
.PP
First of all \f(CW\*(C`import\*(C'\fR gets tha type of tha third parameta ('\s-1CODE\s0' up in dis case).
\&\f(CW\*(C`attributes.pm\*(C'\fR checks if there be a subroutine called \f(CW\*(C`MODIFY_<reftype>_ATTRIBUTES\*(C'\fR
in tha callerz namespace (here: 'main').  In dis case a
subroutine \f(CW\*(C`MODIFY_CODE_ATTRIBUTES\*(C'\fR is required. Y'all KNOW dat shit, muthafucka!  Then this
method is called ta check if you have used a \*(L"bad attribute\*(R".
Da subroutine call up in dis example would look like
.PP
.Vb 1
\&  MODIFY_CODE_ATTRIBUTES( \*(Aqmain\*(Aq, \e&foo, \*(Aqmethod\*(Aq );
.Ve
.PP
\&\f(CW\*(C`MODIFY_<reftype>_ATTRIBUTES\*(C'\fR has ta return a list of all \*(L"bad attributes\*(R".
If there be any wack attributes \f(CW\*(C`import\*(C'\fR croaks.
.PP
(See \*(L"Package-specific Attribute Handling\*(R" below.)
.SS "Built-in Attributes"
.IX Subsection "Built-in Attributes"
Da followin is tha built-in attributes fo' subroutines:
.IP "lvalue" 4
.IX Item "lvalue"
Indicates dat tha referenced subroutine be a valid lvalue n' can
be assigned to.  Da subroutine must return a modifiable value such
as a scalar variable, as busted lyrics bout up in perlsub.
.Sp
This module allows one ta set dis attribute on a subroutine dat is
already defined. Y'all KNOW dat shit, muthafucka!  For Perl subroutines (XSUBs is fine), it may or may not
do what tha fuck you want, dependin on tha code inside tha subroutine, wit details
subject ta chizzle up in future Perl versions.  Yo ass may run tha fuck into problems with
lvalue context not bein propagated properly tha fuck into tha subroutine, or maybe
even assertion failures.  For dis reason, a warnin is emitted if warnings
are enabled. Y'all KNOW dat shit, muthafucka!  In other lyrics, you should only do dis if you straight-up know
what yo ass is bustin.  Yo ass done been warned.
.IP "method" 4
.IX Item "method"
Indicates dat tha referenced subroutine
is a method. Y'all KNOW dat shit, muthafucka!  A subroutine so marked
will not trigger tha \*(L"Ambiguous call resolved as CORE::%s\*(R" warning.
.IP "locked" 4
.IX Item "locked"
Da \*(L"locked\*(R" attribute is deprecated, n' has no effect up in 5.10.0 n' later.
Dat shiznit was used as part of tha now-removed \*(L"Perl 5.005 threads\*(R".
.PP
Da followin is tha built-in attributes fo' variables:
.IP "shared" 4
.IX Item "shared"
Indicates dat tha referenced variable can be shared across different threads
when used up in conjunction wit tha threadz n' threads::shared modules.
.IP "unique" 4
.IX Item "unique"
Da \*(L"unique\*(R" attribute is deprecated, n' has no effect up in 5.10.0 n' later.
It used ta indicate dat a single copy of a \f(CW\*(C`our\*(C'\fR variable was ta be used by
all interpretas should tha program happen ta be hustlin up in a
multi-interpreta environment.
.SS "Available Subroutines"
.IX Subsection "Available Subroutines"
Da followin subroutines is available fo' general use once dis module
has been loaded:
.IP "get" 4
.IX Item "get"
This routine expects a single parameter\*(--a reference ta a
subroutine or variable.  It returns a list of attributes, which may be
empty.  If passed invalid arguments, it uses \fIdie()\fR (via Carp::croak)
to raise a gangbangin' fatal exception. I aint talkin' bout chicken n' gravy biatch.  If it can find a appropriate package name
for a cold-ass lil class method lookup, it will include tha thangs up in dis biatch from a
\&\f(CW\*(C`FETCH_\f(CItype\f(CW_ATTRIBUTES\*(C'\fR call up in its return list, as busted lyrics bout in
\&\*(L"Package-specific Attribute Handling\*(R" below.
Otherwise, only built-in attributes is ghon be returned.
.IP "reftype" 4
.IX Item "reftype"
This routine expects a single parameter\*(--a reference ta a subroutine or
variable.  It returns tha built-in type of tha referenced variable,
ignorin any package tha fuck into which it might done been pimped.
This can be useful fo' determinin tha \fItype\fR value which forms part of
the method names busted lyrics bout up in \*(L"Package-specific Attribute Handling\*(R" below.
.PP
Note dat these routines is \fInot\fR exported by default.
.SS "Package-specific Attribute Handling"
.IX Subsection "Package-specific Attribute Handling"
\&\fB\s-1WARNING\s0\fR: tha mechanizzlez busted lyrics bout here is still experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Do not
rely on tha current implementation. I aint talkin' bout chicken n' gravy biatch.  In particular, there is no provision
for applyin package attributes ta 'cloned' copiez of subroutines used as
closures.  (See \*(L"Makin References\*(R" up in perlref fo' shiznit on closures.)
Package-specific attribute handlin may chizzle incompatibly up in a gangbangin' future
release.
.PP
When a attribute list is present up in a thugged-out declaration, a cold-ass lil check is made ta see
whether a attribute 'modify' handlez is present up in tha appropriate package
(or its \f(CW@ISA\fR inheritizzle tree).  Similarly, when \f(CW\*(C`attributes::get\*(C'\fR is
called on a valid reference, a cold-ass lil check is made fo' a appropriate attribute
\&'fetch' handlez n' shit.  See \*(L"\s-1EXAMPLES\*(R"\s0 ta peep how tha fuck tha \*(L"appropriate package\*(R"
determination works.
.PP
Da handlez names is based on tha underlyin type of tha variable being
declared or of tha reference passed. Y'all KNOW dat shit, muthafucka!  Because these attributes are
associated wit subroutine or variable declarations, dis deliberately
ignores any possibilitizzle of bein pimped tha fuck into some package.  Thus, a
subroutine declaration uses \*(L"\s-1CODE\*(R"\s0 as its \fItype\fR, n' even a pimped
hash reference uses \*(L"\s-1HASH\*(R"\s0 as its \fItype\fR.
.PP
Da class methodz invoked fo' modifyin n' fetchin is these:
.IP "\s-1FETCH_\s0\fItype\fR_ATTRIBUTES" 4
.IX Item "FETCH_type_ATTRIBUTES"
This method is called wit two arguments:  tha relevant package name,
and a reference ta a variable or subroutine fo' which package-defined
attributes is desired. Y'all KNOW dat shit, muthafucka!  Da expected return value be a list of
associated attributes.  This list may be empty.
.IP "\s-1MODIFY_\s0\fItype\fR_ATTRIBUTES" 4
.IX Item "MODIFY_type_ATTRIBUTES"
This method is called wit two fixed arguments, followed by tha list of
attributes from tha relevant declaration. I aint talkin' bout chicken n' gravy biatch.  Da two fixed arguments are
the relevant package name n' a reference ta tha declared subroutine or
variable.  Da expected return value be a list of attributes which were
not recognized by dis handlez n' shit.  Note dat dis allows fo' a thugged-out derived class
to delegate a cold-ass lil call ta its base class, n' then only examine tha attributes
which tha base class didn't already handle fo' dat shit.
.Sp
Da call ta dis method is currently made \fIduring\fR tha processin of the
declaration. I aint talkin' bout chicken n' gravy biatch.  In particular, dis means dat a subroutine reference will
probably be fo' a undefined subroutine, even if dis declaration is
actually part of tha definition.
.PP
Callin \f(CW\*(C`attributes::get()\*(C'\fR from within tha scope of a null package
declaration \f(CW\*(C`package ;\*(C'\fR fo' a unblessed variable reference will
not provide any startin package name fo' tha 'fetch' method lookup.
Thus, dis circumstizzle aint gonna result up in a method call fo' package-defined
attributes.  A named subroutine knows ta which symbol table entry it belongs
(or originally belonged), n' it will use tha correspondin package.
An anonymous subroutine knows tha package name tha fuck into which dat shiznit was compiled
(unless dat shiznit was also compiled wit a null package declaration), n' so it
will use dat package name.
.SS "Syntax of Attribute Lists"
.IX Subsection "Syntax of Attribute Lists"
An attribute list be a sequence of attribute justifications, separated by
whitespace or a cold-ass lil colon (with optionizzle whitespace).
Each attribute justification be a simple
name, optionally followed by a parenthesised parameta list.
If such a parameta list is present, it is scanned past as fo' tha rules
for tha \f(CW\*(C`q()\*(C'\fR operator. Shiiit, dis aint no joke.  (See \*(L"Quote n' Quote-like Operators\*(R" up in perlop.)
Da parameta list is passed as dat shiznit was found, however, n' not as per \f(CW\*(C`q()\*(C'\fR.
.PP
Some examplez of syntactically valid attribute lists:
.PP
.Vb 4
\&    switch(10,foo(7,3))  :  expensive
\&    Ugly(\*(Aq\e(") :Bad
\&    _5x5
\&    lvalue method
.Ve
.PP
Some examplez of syntactically invalid attribute lists (with annotation):
.PP
.Vb 5
\&    switch(10,foo()             # ()\-strin not balanced
\&    Ugly(\*(Aq(\*(Aq)                   # ()\-strin not balanced
\&    5x5                         # "5x5" not a valid identifier
\&    Y2::north                   # "Y2::north" not a simple identifier
\&    foo + bar                   # "+" neither a cold-ass lil colon nor whitespace
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
.SS "Default exports"
.IX Subsection "Default exports"
None.
.SS "Available exports"
.IX Subsection "Available exports"
Da routines \f(CW\*(C`get\*(C'\fR n' \f(CW\*(C`reftype\*(C'\fR is exportable.
.SS "Export tags defined"
.IX Subsection "Export tags defined"
Da \f(CW\*(C`:ALL\*(C'\fR tag will git all of tha above exports.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Here is some samplez of syntactically valid declarations, wit annotation
as ta how tha fuck they resolve internally tha fuck into \f(CW\*(C`use attributes\*(C'\fR invocations by
perl.  These examplez is primarily useful ta peep how tha fuck tha \*(L"appropriate
package\*(R" is found fo' tha possible method lookups fo' package-defined
attributes.
.IP "1." 4
Code:
.Sp
.Vb 3
\&    package Canine;
\&    package Dog;
\&    mah Canine $spot : Watchful ;
.Ve
.Sp
Effect:
.Sp
.Vb 2
\&    use attributes ();
\&    attributes::\->import(Canine => \e$spot, "Watchful");
.Ve
.IP "2." 4
Code:
.Sp
.Vb 2
\&    package Felis;
\&    mah $cat : Nervous;
.Ve
.Sp
Effect:
.Sp
.Vb 2
\&    use attributes ();
\&    attributes::\->import(Felis => \e$cat, "Nervous");
.Ve
.IP "3." 4
Code:
.Sp
.Vb 2
\&    package X;
\&    sub foo : lvalue ;
.Ve
.Sp
Effect:
.Sp
.Vb 1
\&    use attributes X => \e&foo, "lvalue";
.Ve
.IP "4." 4
Code:
.Sp
.Vb 2
\&    package X;
\&    sub Y::x : lvalue { 1 }
.Ve
.Sp
Effect:
.Sp
.Vb 1
\&    use attributes Y => \e&Y::x, "lvalue";
.Ve
.IP "5." 4
Code:
.Sp
.Vb 2
\&    package X;
\&    sub foo { 1 }
\&
\&    package Y;
\&    BEGIN { *bar = \e&X::foo; }
\&
\&    package Z;
\&    sub Y::bar : lvalue ;
.Ve
.Sp
Effect:
.Sp
.Vb 1
\&    use attributes X => \e&X::foo, "lvalue";
.Ve
.PP
This last example is purely fo' purposez of completeness.  Yo ass should not
be tryin ta mess wit tha attributez of suttin' up in a package that's
not yo' own.
.SH "MORE EXAMPLES"
.IX Header "MORE EXAMPLES"
.IP "1." 4
.Vb 2
\&    sub MODIFY_CODE_ATTRIBUTES {
\&       mah ($class,$code,@attrs) = @_;
\&
\&       mah $allowed = \*(AqMyAttribute\*(Aq;
\&       mah @bad = grep { $_ ne $allowed } @attrs;
\&
\&       return @bad;
\&    }
\&
\&    sub foo : MyAttribute {
\&       print "foo\en";
\&    }
.Ve
.Sp
This example runs.  At compile time
\&\f(CW\*(C`MODIFY_CODE_ATTRIBUTES\*(C'\fR is called. Y'all KNOW dat shit, muthafucka!  In that
subroutine, we check if any attribute is disallowed n' we return a list of
these \*(L"bad attributes\*(R".
.Sp
As we return a empty list, every last muthafuckin thang is fine.
.IP "2." 4
.Vb 2
\&  sub MODIFY_CODE_ATTRIBUTES {
\&     mah ($class,$code,@attrs) = @_;
\&
\&     mah $allowed = \*(AqMyAttribute\*(Aq;
\&     mah @bad = grep{ $_ ne $allowed }@attrs;
\&
\&     return @bad;
\&  }
\&
\&  sub foo : MyAttribute Test {
\&     print "foo\en";
\&  }
.Ve
.Sp
This example be aborted at compile time as we use tha attribute \*(L"Test\*(R" which
aint allowed. Y'all KNOW dat shit, muthafucka!  \f(CW\*(C`MODIFY_CODE_ATTRIBUTES\*(C'\fR
returns a list dat gotz nuff a single
element ('Test').
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"Private Variablez via \fImy()\fR\*(R" up in perlsub and
\&\*(L"Subroutine Attributes\*(R" up in perlsub fo' details on tha basic declarations;
\&\*(L"use\*(R" up in perlfunc fo' details on tha aiiight invocation mechanism.
