.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BIO_s_bio 3"
.TH BIO_s_bio 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
BIO_s_bio, BIO_make_bio_pair, BIO_destroy_bio_pair, BIO_shutdown_wr, 
BIO_set_write_buf_size, BIO_get_write_buf_size, BIO_new_bio_pair,
BIO_get_write_guarantee, BIO_ctrl_get_write_guarantee, BIO_get_read_request,
BIO_ctrl_get_read_request, BIO_ctrl_reset_read_request \- BIO pair BIO
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bio.h>
\&
\& BIO_METHOD *BIO_s_bio(void);
\&
\& #define BIO_make_bio_pair(b1,b2)   (int)BIO_ctrl(b1,BIO_C_MAKE_BIO_PAIR,0,b2)
\& #define BIO_destroy_bio_pair(b)    (int)BIO_ctrl(b,BIO_C_DESTROY_BIO_PAIR,0,NULL)
\&
\& #define BIO_shutdown_wr(b) (int)BIO_ctrl(b, BIO_C_SHUTDOWN_WR, 0, NULL)
\&
\& #define BIO_set_write_buf_size(b,size) (int)BIO_ctrl(b,BIO_C_SET_WRITE_BUF_SIZE,size,NULL)
\& #define BIO_get_write_buf_size(b,size) (size_t)BIO_ctrl(b,BIO_C_GET_WRITE_BUF_SIZE,size,NULL)
\&
\& int BIO_new_bio_pair(BIO **bio1, size_t writebuf1, BIO **bio2, size_t writebuf2);
\&
\& #define BIO_get_write_guarantee(b) (int)BIO_ctrl(b,BIO_C_GET_WRITE_GUARANTEE,0,NULL)
\& size_t BIO_ctrl_get_write_guarantee(BIO *b);
\&
\& #define BIO_get_read_request(b)    (int)BIO_ctrl(b,BIO_C_GET_READ_REQUEST,0,NULL)
\& size_t BIO_ctrl_get_read_request(BIO *b);
\&
\& int BIO_ctrl_reset_read_request(BIO *b);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIBIO_s_bio()\fR returns tha method fo' a \s-1BIO\s0 pair fo' realz. A \s-1BIO\s0 pair be a pair of source/sink
BIOs where data freestyled ta either half of tha pair is buffered n' can be read from
the other half. Both halves must probably by handled by tha same application thread
since no lockin is done on tha internal data structures.
.PP
Since \s-1BIO\s0 chains typically end up in a source/sink \s-1BIO\s0 it is possible ta make this
one half of a \s-1BIO\s0 pair n' have all tha data processed by tha chain under application
control.
.PP
One typical use of \s-1BIO\s0 pairs is ta place \s-1TLS/SSL I/O\s0 under application control, this
can be used when tha application wishes ta bust a non standard transhiznit for
\&\s-1TLS/SSL\s0 or tha aiiight socket routines is inappropriate.
.PP
Calls ta \fIBIO_read()\fR will read data from tha buffer or request a retry if no
data be available.
.PP
Calls ta \fIBIO_write()\fR will place data up in tha buffer or request a retry if the
buffer is full.
.PP
Da standard calls \fIBIO_ctrl_pending()\fR n' \fIBIO_ctrl_wpending()\fR can be used to
determine tha amount of pendin data up in tha read or write buffer.
.PP
\&\fIBIO_reset()\fR clears any data up in tha write buffer.
.PP
\&\fIBIO_make_bio_pair()\fR joins two separate BIOs tha fuck into a cold-ass lil connected pair.
.PP
\&\fIBIO_destroy_pair()\fR destroys tha association between two connected BIOs. Freeing
up any half of tha pair will automatically destroy tha association.
.PP
\&\fIBIO_shutdown_wr()\fR is used ta close down a \s-1BIO \s0\fBb\fR fo' realz. Afta dis call no further
writes on \s-1BIO \s0\fBb\fR is allowed (they will return a error). Readz on tha other
half of tha pair will return any pendin data or \s-1EOF\s0 when all pendin data has
been read.
.PP
\&\fIBIO_set_write_buf_size()\fR sets tha write buffer size of \s-1BIO \s0\fBb\fR ta \fBsize\fR.
If tha size aint initialized a thugged-out default value is used. Y'all KNOW dat shit, muthafucka! This is currently
17K, sufficient fo' a maximum size \s-1TLS\s0 record.
.PP
\&\fIBIO_get_write_buf_size()\fR returns tha size of tha write buffer.
.PP
\&\fIBIO_new_bio_pair()\fR combines tha calls ta \fIBIO_new()\fR, \fIBIO_make_bio_pair()\fR and
\&\fIBIO_set_write_buf_size()\fR ta create a cold-ass lil connected pair of BIOs \fBbio1\fR, \fBbio2\fR
with write buffer sizes \fBwritebuf1\fR n' \fBwritebuf2\fR. If either size is
zero then tha default size is used. Y'all KNOW dat shit, muthafucka!  \fIBIO_new_bio_pair()\fR do not check whether
\&\fBbio1\fR or \fBbio2\fR do point ta some other \s-1BIO,\s0 tha joints is overwritten,
\&\fIBIO_free()\fR aint called.
.PP
\&\fIBIO_get_write_guarantee()\fR n' \fIBIO_ctrl_get_write_guarantee()\fR return tha maximum
length of data dat can be currently freestyled ta tha \s-1BIO.\s0 Writes larger than this
value will return a value from \fIBIO_write()\fR less than tha amount axed or if the
buffer is full request a retry. \fIBIO_ctrl_get_write_guarantee()\fR be a gangbangin' function
whereas \fIBIO_get_write_guarantee()\fR be a macro.
.PP
\&\fIBIO_get_read_request()\fR n' \fIBIO_ctrl_get_read_request()\fR return the
amount of data requested, or tha buffer size if it is less, if the
last read attempt all up in tha other half of tha \s-1BIO\s0 pair failed cuz of an
empty buffer n' shit.  This can be used ta determine how tha fuck much data should be
written ta tha \s-1BIO\s0 so tha next read will succeed: dis is most useful
in \s-1TLS/SSL\s0 applications where tha amount of data read is usually
meaningful rather than just a funky-ass buffer size fo' realz. Afta a successful read
this call will return zero.  It also will return zero once freshly smoked up data
has been freestyled satisfyin tha read request or part of dat shit.
Note dat \fIBIO_get_read_request()\fR never returns a amount larger
than dat returned by \fIBIO_get_write_guarantee()\fR.
.PP
\&\fIBIO_ctrl_reset_read_request()\fR can also be used ta reset tha value returned by
\&\fIBIO_get_read_request()\fR ta zero.
.SH "NOTES"
.IX Header "NOTES"
Both halvez of a \s-1BIO\s0 pair should be freed. Y'all KNOW dat shit, muthafucka! That is even if one half is implicit
freed cuz of a \fIBIO_free_all()\fR or \fISSL_free()\fR call tha other half need ta be freed.
.PP
When used up in bidirectionizzle applications (like fuckin \s-1TLS/SSL\s0) care should be taken to
flush any data up in tha write buffer n' shit. This can be done by callin \fIBIO_pending()\fR
on tha other half of tha pair and, if any data is pending, readin it n' sending
it ta tha underlyin transport. This must be done before any aiiight processing
(like fuckin callin \fIselect()\fR ) cuz of a request n' \fIBIO_should_read()\fR bein true.
.PP
To peep why dis is blingin consider a cold-ass lil case where a request is busted using
\&\fIBIO_write()\fR n' a response read wit \fIBIO_read()\fR, dis can occur durin an
\&\s-1TLS/SSL\s0 handshake fo' example. \fIBIO_write()\fR will succeed n' place data up in tha write
buffer n' shit. \fIBIO_read()\fR will initially fail n' \fIBIO_should_read()\fR is ghon be true. If
the application then waits fo' data ta be available on tha underlyin transport
before flushin tha write buffer it aint NEVER gonna succeed cuz tha request was
never sent!
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIBIO_new_bio_pair()\fR returns 1 on success, wit tha freshly smoked up BIOs available in
\&\fBbio1\fR n' \fBbio2\fR, or 0 on failure, wit \s-1NULL\s0 pointas stored tha fuck into the
locations fo' \fBbio1\fR n' \fBbio2\fR. Peep tha error stack fo' mo' shiznit.
.PP
[\s-1XXXXX:\s0 Mo' return joints need ta be added here]
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Da \s-1BIO\s0 pair can be used ta have full control over tha network access of an
application. I aint talkin' bout chicken n' gravy biatch. Da application can call \fIselect()\fR on tha socket as required
without havin ta go all up in tha SSL-interface.
.PP
.Vb 6
\& BIO *internal_bio, *network_bio;
\& ...
\& BIO_new_bio_pair(internal_bio, 0, network_bio, 0);
\& SSL_set_bio(ssl, internal_bio, internal_bio);
\& SSL_operations();
\& ...
\&
\& application |   TLS\-engine
\&    |        |
\&    +\-\-\-\-\-\-\-\-\-\-> SSL_operations()
\&             |     /\e    ||
\&             |     ||    \e/
\&             |   BIO\-pair (internal_bio)
\&    +\-\-\-\-\-\-\-\-\-\-< BIO\-pair (network_bio)
\&    |        |
\&  socket     |
\&
\&  ...
\&  SSL_free(ssl);                /* implicitly frees internal_bio */
\&  BIO_free(network_bio);
\&  ...
.Ve
.PP
As tha \s-1BIO\s0 pair will only buffer tha data n' never directly access the
connection, it behaves non-blockin n' will return as soon as tha write
buffer is full or tha read buffer is drained. Y'all KNOW dat shit, muthafucka! Then tha application has to
flush tha write buffer and/or fill tha read buffer.
.PP
Use tha \fIBIO_ctrl_pending()\fR, ta smoke up whether data is buffered up in tha \s-1BIO\s0
and must be transfered ta tha network. Use \fIBIO_ctrl_get_read_request()\fR to
smoke up, how tha fuck nuff bytes must be freestyled tha fuck into tha buffer before the
\&\fISSL_operation()\fR can successfully be continued.
.SH "WARNING"
.IX Header "WARNING"
As tha data is buffered, \fISSL_operation()\fR may return wit a \s-1ERROR_SSL_WANT_READ\s0
condizzle yo, but there is still data up in tha write buffer n' shiznit fo' realz. An application must
not rely on tha error value of \fISSL_operation()\fR but must assure dat the
write buffer be always flushed first. Otherwise a thugged-out deadlock may occur as
the peer might be waitin fo' tha data before bein able ta continue.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fISSL_set_bio\fR\|(3), \fIssl\fR\|(3), \fIbio\fR\|(3),
\&\fIBIO_should_retry\fR\|(3), \fIBIO_read\fR\|(3)
