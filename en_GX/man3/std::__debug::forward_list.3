" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::__debug::forward_list< _Tp, _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits forward_list< _Tp, _Alloc >, n' \fB__gnu_debug::_Safe_sequence< forward_list< _Tp, _Alloc > >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef 
.br
\fB__gnu_debug::_Safe_iterator\fP
.br
< \fB_Base_const_iterator\fP, 
.br
\fBforward_list\fP > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef _Base::const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef _Base::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef _Base::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef 
.br
\fB__gnu_debug::_Safe_iterator\fP
.br
< \fB_Base_iterator\fP, \fBforward_list\fP > \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Base::pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Base::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef _Base::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Tp \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBforward_list\fP (const _Alloc &__al=_Alloc())"
.br
.ti -1c
.RI "\fBforward_list\fP (const \fBforward_list\fP &__list, const _Alloc &__al)"
.br
.ti -1c
.RI "\fBforward_list\fP (\fBforward_list\fP &&__list, const _Alloc &__al)"
.br
.ti -1c
.RI "\fBforward_list\fP (size_type __n, const _Alloc &__al=_Alloc())"
.br
.ti -1c
.RI "\fBforward_list\fP (size_type __n, const _Tp &__value, const _Alloc &__al=_Alloc())"
.br
.ti -1c
.RI "template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> \fBforward_list\fP (_InputIterator __first, _InputIterator __last, const _Alloc &__al=_Alloc())"
.br
.ti -1c
.RI "\fBforward_list\fP (const \fBforward_list\fP &__list)"
.br
.ti -1c
.RI "\fBforward_list\fP (\fBforward_list\fP &&__list) noexcept"
.br
.ti -1c
.RI "\fBforward_list\fP (\fBstd::initializer_list\fP< _Tp > __il, const _Alloc &__al=_Alloc())"
.br
.ti -1c
.RI "void \fB_M_attach\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)  throw ()"
.br
.ti -1c
.RI "\fB_Base\fP & \fB_M_base\fP () noexcept"
.br
.ti -1c
.RI "const \fB_Base\fP & \fB_M_base\fP () const noexcept"
.br
.ti -1c
.RI "void \fB_M_detach\fP (\fB_Safe_iterator_base\fP *__it)"
.br
.ti -1c
.RI "void \fB_M_detach_single\fP (\fB_Safe_iterator_base\fP *__it)  throw ()"
.br
.ti -1c
.RI "void \fB_M_invalidate_all\fP () const "
.br
.ti -1c
.RI "void \fB_M_invalidate_if\fP (_Predicate __pred)"
.br
.ti -1c
.RI "void \fB_M_transfer_from_if\fP (_Safe_sequence &__from, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> void \fBassign\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBassign\fP (size_type __n, const _Tp &__val)"
.br
.ti -1c
.RI "void \fBassign\fP (\fBstd::initializer_list\fP< _Tp > __il)"
.br
.ti -1c
.RI "\fBiterator\fP \fBbefore_begin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbefore_begin\fP () const noexcept"
.br
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbefore_begin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBiterator\fP \fBemplace_after\fP (\fBconst_iterator\fP __pos, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const noexcept"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase_after\fP (\fBconst_iterator\fP __pos)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase_after\fP (\fBconst_iterator\fP __pos, \fBconst_iterator\fP __last)"
.br
.ti -1c
.RI "reference \fBfront\fP ()"
.br
.ti -1c
.RI "const_reference \fBfront\fP () const "
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert_after\fP (\fBconst_iterator\fP __pos, const _Tp &__val)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert_after\fP (\fBconst_iterator\fP __pos, _Tp &&__val)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert_after\fP (\fBconst_iterator\fP __pos, size_type __n, const _Tp &__val)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> \fBiterator\fP \fBinsert_after\fP (\fBconst_iterator\fP __pos, _InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert_after\fP (\fBconst_iterator\fP __pos, \fBstd::initializer_list\fP< _Tp > __il)"
.br
.ti -1c
.RI "void \fBmerge\fP (\fBforward_list\fP &&__list)"
.br
.ti -1c
.RI "void \fBmerge\fP (\fBforward_list\fP &__list)"
.br
.ti -1c
.RI "template<typename _Comp > void \fBmerge\fP (\fBforward_list\fP &&__list, _Comp __comp)"
.br
.ti -1c
.RI "template<typename _Comp > void \fBmerge\fP (\fBforward_list\fP &__list, _Comp __comp)"
.br
.ti -1c
.RI "\fBforward_list\fP & \fBoperator=\fP (const \fBforward_list\fP &__list)"
.br
.ti -1c
.RI "\fBforward_list\fP & \fBoperator=\fP (\fBforward_list\fP &&__list) noexcept(_Node_alloc_traits::_S_nothrow_move())"
.br
.ti -1c
.RI "\fBforward_list\fP & \fBoperator=\fP (\fBstd::initializer_list\fP< _Tp > __il)"
.br
.ti -1c
.RI "void \fBpop_front\fP ()"
.br
.ti -1c
.RI "void \fBremove\fP (const _Tp &__val)"
.br
.ti -1c
.RI "template<typename _Pred > void \fBremove_if\fP (_Pred __pred)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __sz)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __sz, const value_type &__val)"
.br
.ti -1c
.RI "void \fBsplice_after\fP (\fBconst_iterator\fP __pos, \fBforward_list\fP &&__list)"
.br
.ti -1c
.RI "void \fBsplice_after\fP (\fBconst_iterator\fP __pos, \fBforward_list\fP &__list)"
.br
.ti -1c
.RI "void \fBsplice_after\fP (\fBconst_iterator\fP __pos, \fBforward_list\fP &&__list, \fBconst_iterator\fP __i)"
.br
.ti -1c
.RI "void \fBsplice_after\fP (\fBconst_iterator\fP __pos, \fBforward_list\fP &__list, \fBconst_iterator\fP __i)"
.br
.ti -1c
.RI "void \fBsplice_after\fP (\fBconst_iterator\fP __pos, \fBforward_list\fP &&__list, \fBconst_iterator\fP __before, \fBconst_iterator\fP __last)"
.br
.ti -1c
.RI "void \fBsplice_after\fP (\fBconst_iterator\fP __pos, \fBforward_list\fP &__list, \fBconst_iterator\fP __before, \fBconst_iterator\fP __last)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBforward_list\fP &__list) noexcept(_Node_alloc_traits::_S_nothrow_swap())"
.br
.ti -1c
.RI "void \fBunique\fP ()"
.br
.ti -1c
.RI "template<typename _BinPred > void \fBunique\fP (_BinPred __binary_pred)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_const_iterators\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_iterators\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_detach_all\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_singular\fP ()"
.br
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()  throw ()"
.br
.ti -1c
.RI "void \fB_M_revalidate_singular\fP ()"
.br
.ti -1c
.RI "void \fB_M_swap\fP (_Safe_sequence_base &__x)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>>class std::__debug::forward_list< _Tp, _Alloc >"
Class std::forward_list wit safety/checking/debug instrumentation\&. 
.PP
Definizzle at line 44 of file debug/forward_list\&.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Attach a iterator ta dis sequence\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach_single (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Detach a iterator from dis sequence 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_all ()\fC [protected]\fP, \fC [inherited]\fP"
Detach all iterators, leavin dem singular\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence_base::~_Safe_sequence_base()\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_single (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Detach all singular iterators\&. 
.PP
\fBPostcondition:\fP
.RS 4
for all iterators i attached ta dis sequence, i->_M_version == _M_version\&. 
.RE
.PP

.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_sequence_base::_M_get_mutex ()\fC [protected]\fP, \fC [inherited]\fP"
For use up in _Safe_sequence\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_invalidate_all () const\fC [inline]\fP, \fC [inherited]\fP"
Invalidates all iterators\&. 
.PP
Definizzle at line 233 of file safe_base\&.h\&.
.PP
References __gnu_debug::_Safe_sequence_base::_M_version\&.
.SS "void \fB__gnu_debug::_Safe_sequence\fP< \fBforward_list\fP< _Tp, _Alloc >  >::_M_invalidate_if (_Predicate__pred)\fC [inherited]\fP"
Invalidates all iterators \fCx\fP dat reference dis sequence, is not singular, n' fo' which \fC__pred(x)\fP returns \fCtrue\fP\&. \fC__pred\fP is ghon be invoked wit tha aiiight iterators nested up in tha safe ones\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_revalidate_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Revalidates all attached singular iterators\&. This method may be used ta validate iterators dat was invalidated before (but fo' some reason, like fuckin a exception, need ta become valid again)\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_swap (\fB_Safe_sequence_base\fP &__x)\fC [protected]\fP, \fC [inherited]\fP"
Swap dis sequence wit tha given sequence\&. This operation also swaps ballershizzle of tha iterators, so dat when tha operation is complete all iterators dat originally referenced one container now reference tha other container\&. 
.SS "void \fB__gnu_debug::_Safe_sequence\fP< \fBforward_list\fP< _Tp, _Alloc >  >::_M_transfer_from_if (\fB_Safe_sequence\fP< \fBforward_list\fP< _Tp, _Alloc > > &__from, _Predicate__pred)\fC [inherited]\fP"
Transfers all iterators \fCx\fP dat reference \fCfrom\fP sequence, is not singular, n' fo' which \fC__pred(x)\fP returns \fCtrue\fP\&. \fC__pred\fP is ghon be invoked wit tha aiiight iterators nested up in tha safe ones\&. 
.SH "Member Data Documentation"
.PP 
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_sequence_base::_M_const_iterators\fC [inherited]\fP"

.PP
Da list of constant iterators dat reference dis container\&. 
.PP
Definizzle at line 184 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_sequence_base::_M_iterators\fC [inherited]\fP"

.PP
Da list of mutable iterators dat reference dis container\&. 
.PP
Definizzle at line 181 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "unsigned int __gnu_debug::_Safe_sequence_base::_M_version\fC [mutable]\fP, \fC [inherited]\fP"

.PP
Da container version number\&. This number may never be 0\&. 
.PP
Definizzle at line 187 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence_base::_M_invalidate_all(), n' __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
