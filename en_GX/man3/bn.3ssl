.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bn 3"
.TH bn 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
bn \- multiprecision integer arithmetics
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bn.h>
\&
\& BIGNUM *BN_new(void);
\& void BN_free(BIGNUM *a);
\& void BN_init(BIGNUM *);
\& void BN_clear(BIGNUM *a);
\& void BN_clear_free(BIGNUM *a);
\&
\& BN_CTX *BN_CTX_new(void);
\& void BN_CTX_init(BN_CTX *c);
\& void BN_CTX_free(BN_CTX *c);
\&
\& BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);
\& BIGNUM *BN_dup(const BIGNUM *a);
\&
\& BIGNUM *BN_swap(BIGNUM *a, BIGNUM *b);
\&
\& int BN_num_bytes(const BIGNUM *a);
\& int BN_num_bits(const BIGNUM *a);
\& int BN_num_bits_word(BN_ULONG w);
\&
\& void BN_set_negative(BIGNUM *a, int n);
\& int  BN_is_negative(const BIGNUM *a);
\&
\& int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
\& int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
\& int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);
\& int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);
\& int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d,
\&         BN_CTX *ctx);
\& int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
\& int BN_nnmod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
\& int BN_mod_add(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
\&         BN_CTX *ctx);
\& int BN_mod_sub(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
\&         BN_CTX *ctx);
\& int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
\&         BN_CTX *ctx);
\& int BN_mod_sqr(BIGNUM *ret, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
\& int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);
\& int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p,
\&         const BIGNUM *m, BN_CTX *ctx);
\& int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);
\&
\& int BN_add_word(BIGNUM *a, BN_ULONG w);
\& int BN_sub_word(BIGNUM *a, BN_ULONG w);
\& int BN_mul_word(BIGNUM *a, BN_ULONG w);
\& BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w);
\& BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w);
\&
\& int BN_cmp(BIGNUM *a, BIGNUM *b);
\& int BN_ucmp(BIGNUM *a, BIGNUM *b);
\& int BN_is_zero(BIGNUM *a);
\& int BN_is_one(BIGNUM *a);
\& int BN_is_word(BIGNUM *a, BN_ULONG w);
\& int BN_is_odd(BIGNUM *a);
\&
\& int BN_zero(BIGNUM *a);
\& int BN_one(BIGNUM *a);
\& const BIGNUM *BN_value_one(void);
\& int BN_set_word(BIGNUM *a, unsigned long w);
\& unsigned long BN_get_word(BIGNUM *a);
\&
\& int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);
\& int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);
\& int BN_rand_range(BIGNUM *rnd, BIGNUM *range);
\& int BN_pseudo_rand_range(BIGNUM *rnd, BIGNUM *range);
\&
\& BIGNUM *BN_generate_prime(BIGNUM *ret, int bits,int safe, BIGNUM *add,
\&         BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg);
\& int BN_is_prime(const BIGNUM *p, int nchecks,
\&         void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg);
\&
\& int BN_set_bit(BIGNUM *a, int n);
\& int BN_clear_bit(BIGNUM *a, int n);
\& int BN_is_bit_set(const BIGNUM *a, int n);
\& int BN_mask_bits(BIGNUM *a, int n);
\& int BN_lshift(BIGNUM *r, const BIGNUM *a, int n);
\& int BN_lshift1(BIGNUM *r, BIGNUM *a);
\& int BN_rshift(BIGNUM *r, BIGNUM *a, int n);
\& int BN_rshift1(BIGNUM *r, BIGNUM *a);
\&
\& int BN_bn2bin(const BIGNUM *a, unsigned char *to);
\& BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);
\& char *BN_bn2hex(const BIGNUM *a);
\& char *BN_bn2dec(const BIGNUM *a);
\& int BN_hex2bn(BIGNUM **a, const char *str);
\& int BN_dec2bn(BIGNUM **a, const char *str);
\& int BN_print(BIO *fp, const BIGNUM *a);
\& int BN_print_fp(FILE *fp, const BIGNUM *a);
\& int BN_bn2mpi(const BIGNUM *a, unsigned char *to);
\& BIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret);
\&
\& BIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n,
\&     BN_CTX *ctx);
\&
\& BN_RECP_CTX *BN_RECP_CTX_new(void);
\& void BN_RECP_CTX_init(BN_RECP_CTX *recp);
\& void BN_RECP_CTX_free(BN_RECP_CTX *recp);
\& int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *m, BN_CTX *ctx);
\& int BN_mod_mul_reciprocal(BIGNUM *r, BIGNUM *a, BIGNUM *b,
\&        BN_RECP_CTX *recp, BN_CTX *ctx);
\&
\& BN_MONT_CTX *BN_MONT_CTX_new(void);
\& void BN_MONT_CTX_init(BN_MONT_CTX *ctx);
\& void BN_MONT_CTX_free(BN_MONT_CTX *mont);
\& int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *m, BN_CTX *ctx);
\& BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from);
\& int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,
\&         BN_MONT_CTX *mont, BN_CTX *ctx);
\& int BN_from_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,
\&         BN_CTX *ctx);
\& int BN_to_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,
\&         BN_CTX *ctx);
\&
\& BN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai,
\&        BIGNUM *mod);
\& void BN_BLINDING_free(BN_BLINDING *b);
\& int BN_BLINDING_update(BN_BLINDING *b,BN_CTX *ctx);
\& int BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);
\& int BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);
\& int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b,
\&        BN_CTX *ctx);
\& int BN_BLINDING_invert_ex(BIGNUM *n,const BIGNUM *r,BN_BLINDING *b,
\&        BN_CTX *ctx);
\& unsigned long BN_BLINDING_get_thread_id(const BN_BLINDING *);
\& void BN_BLINDING_set_thread_id(BN_BLINDING *, unsigned long);
\& unsigned long BN_BLINDING_get_flags(const BN_BLINDING *);
\& void BN_BLINDING_set_flags(BN_BLINDING *, unsigned long);
\& BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,
\&        const BIGNUM *e, BIGNUM *m, BN_CTX *ctx,
\&        int (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
\&                          const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx),
\&        BN_MONT_CTX *m_ctx);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This library performs arithmetic operations on integerz of arbitrary
size. Dat shiznit was freestyled fo' use up in hood key cryptography, like fuckin \s-1RSA\s0
and Diffie-Hellman.
.PP
It uses dynamic memory allocation fo' storin its data structures.
That means dat there is no limit on tha size of tha numbers
manipulated by these functions yo, but return joints must always be
checked up in case a memory allocation error has occurred.
.PP
Da basic object up in dis library be a \fB\s-1BIGNUM\s0\fR. Well shiiiit, it is used ta hold a
single big-ass integer n' shit. This type should be considered opaque n' fields
should not be modified or accessed directly.
.PP
Da creation of \fB\s-1BIGNUM\s0\fR objects is busted lyrics bout up in \fIBN_new\fR\|(3);
\&\fIBN_add\fR\|(3) raps bout most of tha arithmetic operations.
Comparison is busted lyrics bout up in \fIBN_cmp\fR\|(3); \fIBN_zero\fR\|(3)
raps bout certain assignments, \fIBN_rand\fR\|(3) tha generation of
random numbers, \fIBN_generate_prime\fR\|(3) deals wit prime
numbers n' \fIBN_set_bit\fR\|(3) wit bit operations. Da conversion
of \fB\s-1BIGNUM\s0\fRs ta external formats is busted lyrics bout up in \fIBN_bn2bin\fR\|(3).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIbn_internal\fR\|(3),
\&\fIdh\fR\|(3), \fIerr\fR\|(3), \fIrand\fR\|(3), \fIrsa\fR\|(3),
\&\fIBN_new\fR\|(3), \fIBN_CTX_new\fR\|(3),
\&\fIBN_copy\fR\|(3), \fIBN_swap\fR\|(3), \fIBN_num_bytes\fR\|(3),
\&\fIBN_add\fR\|(3), \fIBN_add_word\fR\|(3),
\&\fIBN_cmp\fR\|(3), \fIBN_zero\fR\|(3), \fIBN_rand\fR\|(3),
\&\fIBN_generate_prime\fR\|(3), \fIBN_set_bit\fR\|(3),
\&\fIBN_bn2bin\fR\|(3), \fIBN_mod_inverse\fR\|(3),
\&\fIBN_mod_mul_reciprocal\fR\|(3),
\&\fIBN_mod_mul_montgomery\fR\|(3),
\&\fIBN_BLINDING_new\fR\|(3)
