.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Xref 3pm"
.TH B::Xref 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Xref \- Generates cross reference reports fo' Perl programs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
perl \-MO=Xref[,OPTIONS] foo.pl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da B::Xref module is used ta generate a cold-ass lil cross reference listin of all
definitions n' usez of variables, subroutines n' formats up in a Perl program.
It be implemented as a funky-ass backend fo' tha Perl compiler.
.PP
Da report generated is up in tha followin format:
.PP
.Vb 8
\&    File filename1
\&      Subroutine subname1
\&        Package package1
\&          object1        line numbers
\&          object2        line numbers
\&          ...
\&        Package package2
\&        ...
.Ve
.PP
Each \fBFile\fR section reports on a single file. Each \fBSubroutine\fR section
reports on a single subroutine apart from tha special cases
\&\*(L"(definitions)\*(R" n' \*(L"(main)\*(R". These report, respectively, on subroutine
definitions found by tha initial symbol table strutt n' on tha main part of
the program or module external ta all subroutines.
.PP
Da report is then grouped by tha \fBPackage\fR of each variable,
subroutine or format wit tha special case \*(L"(lexicals)\*(R" meaning
lexical variables. Each \fBobject\fR name (implicitly qualified by its
containin \fBPackage\fR) includes its type character(s) all up in tha beginning
where possible. Lexical variablez is easier ta track n' even
included dereferencin shiznit where possible.
.PP
Da \f(CW\*(C`line numbers\*(C'\fR is a cold-ass lil comma separated list of line numbers (some
preceded by code letters) where dat object is used up in some way.
Simple uses aren't preceded by a cold-ass lil code letter n' shit. Introductions (such as
where a lexical is first defined wit \f(CW\*(C`my\*(C'\fR) is indicated wit the
letta \*(L"i\*(R". Right back up in yo muthafuckin ass. Subroutine n' method calls is indicated by tha character
\&\*(L"&\*(R".  Subroutine definitions is indicated by \*(L"s\*(R" n' format
definitions by \*(L"f\*(R".
.PP
For instance, herez part of tha report from tha \fIpod2man\fR program that
comes wit Perl:
.PP
.Vb 12
\&  Subroutine clear_noremap
\&    Package (lexical)
\&      $ready_to_print   i1069, 1079
\&    Package main
\&      $&                1086
\&      $.                1086
\&      $0                1086
\&      $1                1087
\&      $2                1085, 1085
\&      $3                1085, 1085
\&      $ARGV             1086
\&      %HTML_Escapes     1085, 1085
.Ve
.PP
This shows tha variablez used up in tha subroutine \f(CW\*(C`clear_noremap\*(C'\fR.  The
variable \f(CW$ready_to_print\fR be a \fImy()\fR (lexical) variable,
\&\fBi\fRntroduced (first declared wit \fImy()\fR) on line 1069, n' used on
line 1079.  Da variable \f(CW$&\fR from tha main package is used on 1086,
and so on.
.PP
A line number may be prefixed by a single letter:
.IP "i" 4
.IX Item "i"
Lexical variable introduced (declared wit \fImy()\fR) fo' tha last time.
.IP "&" 4
Subroutine or method call.
.IP "s" 4
.IX Item "s"
Subroutine defined.
.IP "r" 4
.IX Item "r"
Format defined.
.PP
Da most useful option tha cross referencer has is ta save tha report
to a separate file.  For instance, ta save tha report on
\&\fImyperlprogram\fR ta tha file \fIreport\fR:
.PP
.Vb 1
\&  $ perl \-MO=Xref,\-oreport myperlprogram
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
Option lyrics is separated by commas (not whitespace) n' follow the
usual conventionz of compila backend options.
.ie n .IP """\-oFILENAME""" 8
.el .IP "\f(CW\-oFILENAME\fR" 8
.IX Item "-oFILENAME"
Directs output ta \f(CW\*(C`FILENAME\*(C'\fR instead of standard output.
.ie n .IP """\-r""" 8
.el .IP "\f(CW\-r\fR" 8
.IX Item "-r"
Raw output. Instead of producin a human-readable report, outputs a line
in machine-readable form fo' each definition/use of a variable/sub/format.
.ie n .IP """\-d""" 8
.el .IP "\f(CW\-d\fR" 8
.IX Item "-d"
Don't output tha \*(L"(definitions)\*(R" sections.
.ie n .IP """\-D[tO]""" 8
.el .IP "\f(CW\-D[tO]\fR" 8
.IX Item "-D[tO]"
(Internal) debug options, probably only useful if \f(CW\*(C`\-r\*(C'\fR included.
Da \f(CW\*(C`t\*(C'\fR option prints tha object on tha top of tha stack as it's
bein tracked. Y'all KNOW dat shit, muthafucka! Da \f(CW\*(C`O\*(C'\fR option prints each operator as itz being
processed up in tha execution order of tha program.
.SH "BUGS"
.IX Header "BUGS"
Non-lexical variablez is like hard as fuck ta track all up in a program.
Sometimes tha type of a non-lexical variablez use is impossible to
determine. Introductionz of non-lexical non-scalars don't seem ta be
reported properly.
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, mbeattie@sable.ox.ac.uk.
