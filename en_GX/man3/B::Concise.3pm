.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Concise 3pm"
.TH B::Concise 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Concise \- Walk Perl syntax tree, printin concise info bout ops
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    perl \-MO=Concise[,OPTIONS] foo.pl
\&
\&    use B::Concise qw(set_style add_callback);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This compila backend prints tha internal OPz of a Perl programz syntax
tree up in one of nuff muthafuckin space-efficient text formats suitable fo' debugging
the inner workingz of perl or other compila backends. Well shiiiit, it can print OPs in
the order they step tha fuck up in tha \s-1OP\s0 tree, up in tha order they will execute, or
in a text approximation ta they tree structure, n' tha format of the
information displayed is customizable. Its function is similar ta dat of
perlz \fB\-Dx\fR debuggin flag or tha \fBB::Terse\fR module yo, but it is more
sophisticated n' flexible.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Herez two outputs (or 'renderings'), rockin tha \-exec n' \-basic
(i.e. default) formattin conventions on tha same code snippet.
.PP
.Vb 9
\&    % perl \-MO=Concise,\-exec \-e \*(Aq$a = $b + 42\*(Aq
\&    1  <0> enter
\&    2  <;> nextstate(main 1 \-e:1) v
\&    3  <#> gvsv[*b] s
\&    4  <$> const[IV 42] s
\& *  5  <2> add[t3] sK/2
\&    6  <#> gvsv[*a] s
\&    7  <2> sassign vKS/2
\&    8  <@> leave[1 ref] vKP/REFC
.Ve
.PP
In dis \-exec rendering, each opcode is executed up in tha order shown.
Da add opcode, marked wit '*', is discussed up in mo' detail.
.PP
Da 1st column is tha opz sequence number, startin at 1, n' is
displayed up in base 36 by default.  Here they purely linear; the
sequences is straight-up helpful when lookin at code wit loops and
branches.
.PP
Da symbol between angle brackets indicates tha opz type, for
example; <2> be a \s-1BINOP,\s0 <@> a \s-1LISTOP,\s0 n' <#> be a \s-1PADOP,\s0 which is
used up in threaded perls. (see \*(L"\s-1OP\s0 class abbreviations\*(R").
.PP
Da opname, as up in \fB'add[t1]'\fR, may be followed by op-specific
information up in parentheses or brackets (ex \fB'[t1]'\fR).
.PP
Da op-flags (ex \fB'sK/2'\fR) is busted lyrics bout up in (\*(L"\s-1OP\s0 flags
abbreviations\*(R").
.PP
.Vb 11
\&    % perl \-MO=Concise \-e \*(Aq$a = $b + 42\*(Aq
\&    8  <@> leave[1 ref] vKP/REFC \->(end)
\&    1     <0> enta \->2
\&    2     <;> nextstate(main 1 \-e:1) v \->3
\&    7     <2> sassign vKS/2 \->8
\& *  5        <2> add[t1] sK/2 \->6
\&    \-           <1> ex\-rv2sv sK/1 \->4
\&    3              <$> gvsv(*b) s \->4
\&    4           <$> const(IV 42) s \->5
\&    \-        <1> ex\-rv2sv sKRM*/1 \->7
\&    6           <$> gvsv(*a) s \->7
.Ve
.PP
Da default renderin is top-down, so they not up in execution order.
This form reflects tha way tha stack is used ta parse n' evaluate
expressions; tha add operates on tha two terms below it up in tha tree.
.PP
Nullops step tha fuck up as \f(CW\*(C`ex\-opname\*(C'\fR, where \fIopname\fR be a op dat has been
optimized away by perl.  They're displayed wit a sequence-number of
\&'\-', cuz they is not executed (they don't step tha fuck up in previous
example), they printed here cuz they reflect tha parse.
.PP
Da arrow points ta tha sequence number of tha next op; they not
displayed up in \-exec mode, fo' obvious reasons.
.PP
Note dat cuz dis renderin was done on a non-threaded perl, the
PADOPs up in tha previous examplez is now SVOPs, n' some (but not all)
of tha square brackets done been replaced by round ones.  This be a
subtle feature ta provide some visual distinction between renderings
on threaded n' un-threaded perls.
.SH "OPTIONS"
.IX Header "OPTIONS"
Arguments dat don't start wit a hyphen is taken ta be tha names of
subroutines or formats ta render; if no
such functions is specified, tha main
body of tha program (outside any subroutines, n' not includin use'd
or require'd files) is rendered. Y'all KNOW dat shit, muthafucka!  Passin \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`UNITCHECK\*(C'\fR,
\&\f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR, or \f(CW\*(C`END\*(C'\fR will cause all of tha corresponding
special blocks ta be printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Arguments must follow options.
.PP
Options affect how tha fuck thangs is rendered (ie printed).  They're presented
here by they visual effect, 1st bein strongest.  They're grouped
accordin ta how tha fuck they interrelate; within each crew tha options are
mutually exclusive (unless otherwise stated).
.SS "Options fo' Opcode Ordering"
.IX Subsection "Options fo' Opcode Ordering"
These options control tha 'vertical display' of opcodes.  Da display
\&'order' be also called 'mode' elsewhere up in dis document.
.IP "\fB\-basic\fR" 4
.IX Item "-basic"
Print OPs up in tha order they step tha fuck up in tha \s-1OP\s0 tree (a preorder
traversal, startin all up in tha root). Da indentation of each \s-1OP\s0 shows its
level up in tha tree, n' tha '\->' all up in tha end of tha line indicates the
next opcode up in execution order n' shit.  This mode is tha default, so tha flag
is included simply fo' completeness.
.IP "\fB\-exec\fR" 4
.IX Item "-exec"
Print OPs up in tha order they would normally execute (for tha majority
of constructs dis be a postorder traversal of tha tree, endin at the
root). In most cases tha \s-1OP\s0 dat probably bigs up a given \s-1OP\s0 will
appear directly below it; alternate paths is shown by indentation. I aint talkin' bout chicken n' gravy biatch. In
cases like loops when control jumps outta a linear path, a 'goto'
line is generated.
.IP "\fB\-tree\fR" 4
.IX Item "-tree"
Print OPs up in a text approximation of a tree, wit tha root of tha tree
at tha left n' 'left\-to\-right' order of lil pimps transformed into
\&'top\-to\-bottom'. Because dis mode grows both ta tha right n' down,
it aint suitable fo' big-ass programs (unless you gotz a straight-up wide
terminal).
.SS "Options fo' Line-Style"
.IX Subsection "Options fo' Line-Style"
These options select tha line-style (or just style) used ta render
each opcode, n' dictates what tha fuck info is straight-up printed tha fuck into each line.
.IP "\fB\-concise\fR" 4
.IX Item "-concise"
Use tha authorz straight-up set of formattin conventions. This is the
default, of course.
.IP "\fB\-terse\fR" 4
.IX Item "-terse"
Use formattin conventions dat emulate tha output of \fBB::Terse\fR. The
basic mode be almost indistinguishable from tha real \fBB::Terse\fR, n' the
exec mode looks straight-up similar yo, but is up in a mo' logical order n' lacks
curly brackets, n' you can put dat on yo' toast. \fBB::Terse\fR aint gots a tree mode, so tha tree mode
is only vaguely reminiscent of \fBB::Terse\fR.
.IP "\fB\-linenoise\fR" 4
.IX Item "-linenoise"
Use formattin conventions up in which tha name of each \s-1OP,\s0 rather than being
written up in full, is represented by a one\- or two-characta abbreviation.
This is mainly a joke.
.IP "\fB\-debug\fR" 4
.IX Item "-debug"
Use formattin conventions reminiscent of \fBB::Debug\fR; these aren't
very concise at all.
.IP "\fB\-env\fR" 4
.IX Item "-env"
Use formattin conventions read from tha environment variables
\&\f(CW\*(C`B_CONCISE_FORMAT\*(C'\fR, \f(CW\*(C`B_CONCISE_GOTO_FORMAT\*(C'\fR, n' \f(CW\*(C`B_CONCISE_TREE_FORMAT\*(C'\fR.
.SS "Options fo' tree-specific formatting"
.IX Subsection "Options fo' tree-specific formatting"
.IP "\fB\-compact\fR" 4
.IX Item "-compact"
Use a tree format up in which tha minimum amount of space is used fo' the
lines connectin nodes (one characta up in most cases). This squeezes out
a few precious columnz of screen real estate.
.IP "\fB\-loose\fR" 4
.IX Item "-loose"
Use a tree format dat uses longer edges ta separate \s-1OP\s0 nodes. This format
tendz ta look betta than tha compact one, especially up in \s-1ASCII,\s0 n' is
the default.
.IP "\fB\-vt\fR" 4
.IX Item "-vt"
Use tree connectin charactas drawn from tha \s-1VT100\s0 line-drawin set.
This looks betta if yo' terminal supports dat shit.
.IP "\fB\-ascii\fR" 4
.IX Item "-ascii"
Draw tha tree wit standard \s-1ASCII\s0 charactas like \f(CW\*(C`+\*(C'\fR n' \f(CW\*(C`|\*(C'\fR. These don't
look as clean as tha \s-1VT100\s0 charactas yo, but they'll work wit almost any
terminal (or tha horizontal scrollin mode of \fIless\fR\|(1)) n' is suitable
for text documentation or email. This is tha default.
.PP
These is pairwise exclusive, i.e. compact or loose, vt or ascii.
.SS "Options controllin sequence numbering"
.IX Subsection "Options controllin sequence numbering"
.IP "\fB\-base\fR\fIn\fR" 4
.IX Item "-basen"
Print \s-1OP\s0 sequence numbers up in base \fIn\fR. If \fIn\fR is pimped outa than 10, the
digit fo' 11 is ghon be 'a', n' so on. I aint talkin' bout chicken n' gravy biatch. If \fIn\fR is pimped outa than 36, tha digit
for 37 is ghon be 'A', n' so on until 62. Values pimped outa than 62 is not
currently supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da default is 36.
.IP "\fB\-bigendian\fR" 4
.IX Item "-bigendian"
Print sequence numbers wit da most thugged-out dope digit first. This is the
usual convention fo' Arabic numerals, n' tha default.
.IP "\fB\-lilendian\fR" 4
.IX Item "-lilendian"
Print sequence numbers wit tha least dope digit first.  This is
obviously mutually exclusive wit bigendian.
.SS "Other options"
.IX Subsection "Other options"
.IP "\fB\-src\fR" 4
.IX Item "-src"
With dis option, tha renderin of each statement (startin wit the
nextstate \s-1OP\s0) is ghon be preceded by tha 1st line of source code that
generates dat shit.  For example:
.Sp
.Vb 10
\&    1  <0> enter
\&    # 1: mah $i;
\&    2  <;> nextstate(main 1 junk.pl:1) v:{
\&    3  <0> padsv[$i:1,10] vM/LVINTRO
\&    # 3: fo' $i (0..9) {
\&    4  <;> nextstate(main 3 junk.pl:3) v:{
\&    5  <0> pushmark s
\&    6  <$> const[IV 0] s
\&    7  <$> const[IV 9] s
\&    8  <{> enteriter(next\->j last\->m redo\->9)[$i:1,10] lKS
\&    k  <0> ita s
\&    l  <|> and(other\->9) vK/1
\&    # 4:     print "line ";
\&    9      <;> nextstate(main 2 junk.pl:4) v
\&    a      <0> pushmark s
\&    b      <$> const[PV "line "] s
\&    c      <@> print vK
\&    # 5:     print "$i\en";
\&    ...
.Ve
.ie n .IP "\fB\-stash=""somepackage""\fR" 4
.el .IP "\fB\-stash=``somepackage''\fR" 4
.IX Item "-stash=somepackage"
With this, \*(L"somepackage\*(R" is ghon be required, then tha stash is
inspected, n' each function is rendered.
.PP
Da followin options is pairwise exclusive.
.IP "\fB\-main\fR" 4
.IX Item "-main"
Include tha main program up in tha output, even if subroutines was also
specified. Y'all KNOW dat shit, muthafucka!  This renderin is normally suppressed when a subroutine
name or reference is given.
.IP "\fB\-nomain\fR" 4
.IX Item "-nomain"
This restores tha default behavior afta you've chizzled it wit '\-main'
(itz not normally needed).  If no subroutine name/ref is given, main is
rendered, regardless of dis flag.
.IP "\fB\-nobanner\fR" 4
.IX Item "-nobanner"
Renderings probably include a funky-ass banner line identifyin tha function name
or stringified subref.  This suppresses tha printin of tha banner.
.Sp
\&\s-1TBC:\s0 Remove tha stringified coderef; while it serves up a 'cookie' for
each function rendered, tha dem scooby snacks used should be 1,2,3.. not a
random hex-address.  It also complicates strang comparison of two
different trees.
.IP "\fB\-banner\fR" 4
.IX Item "-banner"
restores default banner behavior.
.IP "\fB\-banneris\fR => subref" 4
.IX Item "-banneris => subref"
\&\s-1TBC:\s0 a hookpoint (and a option ta set it) fo' a user-supplied
function ta produce a funky-ass banner appropriate fo' playas needs.  It aint nuthin but not
ideal, cuz tha rendering-state variables, which is a natural
candidate fo' use up in concise.t, is unavailable ta tha user.
.SS "Option Stickiness"
.IX Subsection "Option Stickiness"
If you invoke Concise mo' than once up in a program, you should know that
the options is 'sticky'.  This means dat tha options you provide in
the first call is ghon be remembered fo' tha 2nd call, unless you
re-specify or chizzle em.
.SH "ABBREVIATIONS"
.IX Header "ABBREVIATIONS"
Da concise steez uses symbols ta convey maximum info wit minimal
clutta (like hex addresses).  With just a lil practice, you can
start ta peep tha flowers, not just tha branches, up in tha trees.
.SS "\s-1OP\s0 class abbreviations"
.IX Subsection "OP class abbreviations"
These symbols step tha fuck up before tha op-name, n' indicate the
B:: namespace dat represents tha ops up in yo' Perl code.
.PP
.Vb 11
\&    0      OP (aka BASEOP)  An OP wit no children
\&    1      UNOP             An OP wit one child
\&    2      BINOP            An OP wit two children
\&    |      LOGOP            A control branch OP
\&    @      LISTOP           An OP dat could have fuckin shitloadz of children
\&    /      PMOP             An OP wit a regular expression
\&    $      SVOP             An OP wit a SV
\&    "      PVOP             An OP wit a string
\&    {      LOOP             An OP dat holdz pointas fo' a loop
\&    ;      COP              An OP dat marks tha start of a statement
\&    #      PADOP            An OP wit a GV on tha pad
.Ve
.SS "\s-1OP\s0 flags abbreviations"
.IX Subsection "OP flags abbreviations"
\&\s-1OP\s0 flags is either hood or private.  Da hood flags alta the
behavior of each opcode up in consistent ways, n' is represented by 0
or mo' single characters.
.PP
.Vb 12
\&    v      OPf_WANT_VOID    Want not a god damn thang (void context)
\&    s      OPf_WANT_SCALAR  Want single value (scalar context)
\&    l      OPf_WANT_LIST    Want list of any length (list context)
\&                            Want is unknown
\&    K      OPf_KIDS         There be a gangbangin' firstborn child.
\&    P      OPf_PARENS       This operator was parenthesized.
\&                             (Or block needz explicit scope entry.)
\&    R      OPf_REF          Certified reference.
\&                             (Return container, not containee).
\&    M      OPf_MOD          Will modify (lvalue).
\&    S      OPf_STACKED      Some arg be arrivin on tha stack.
\&    *      OPf_SPECIAL      Do suttin' weird fo' dis op (see op.h)
.Ve
.PP
Private flags, if any is set fo' a opcode, is displayed afta a '/'
.PP
.Vb 2
\&    8  <@> leave[1 ref] vKP/REFC \->(end)
\&    7     <2> sassign vKS/2 \->8
.Ve
.PP
They're opcode specific, n' occur less often than tha hood ones, so
they represented by short mnemonics instead of single-chars; see
\&\fIop.h\fR fo' gory details, or try dis quick 2\-liner:
.PP
.Vb 2
\&  $> perl \-MB::Concise \-de 1
\&  DB<1> |x \e%B::Concise::priv
.Ve
.SH "FORMATTING SPECIFICATIONS"
.IX Header "FORMATTING SPECIFICATIONS"
For each line-style ('concise', 'terse', 'linenoise', etc.) there are
3 format-specs which control how tha fuck OPs is rendered.
.PP
Da first is tha 'default' format, which is used up in both basic n' exec
modes ta print all opcodes.  Da 2nd, goto-format, is used up in exec
mode when branches is encountered. Y'all KNOW dat shit, muthafucka!  They're not real opcodes, n' are
inserted ta be lookin like a cold-ass lil closin curly brace.  Da tree-format is tree
specific.
.PP
When a line is rendered, tha erect format-spec is copied n' scanned
for tha followin items; data is substituted in, n' other
manipulations like basic indentin is done, fo' each opcode rendered.
.PP
There is 3 kindz of shit dat may be populated; special patterns,
#vars, n' literal text, which is copied verbatim.  (Yes, itz a set
of s///g steps.)
.SS "Special Patterns"
.IX Subsection "Special Patterns"
These shit is tha primitives used ta big-ass up indenting, n' to
select text from amongst alternatives.
.IP "\fB(x(\fR\fIexec_text\fR\fB;\fR\fIbasic_text\fR\fB)x)\fR" 4
.IX Item "(x(exec_text;basic_text)x)"
Generates \fIexec_text\fR up in exec mode, or \fIbasic_text\fR up in basic mode.
.IP "\fB(*(\fR\fItext\fR\fB)*)\fR" 4
.IX Item "(*(text)*)"
Generates one copy of \fItext\fR fo' each indentation level.
.IP "\fB(*(\fR\fItext1\fR\fB;\fR\fItext2\fR\fB)*)\fR" 4
.IX Item "(*(text1;text2)*)"
Generates one fewer copiez of \fItext1\fR than tha indentation level, followed
by one copy of \fItext2\fR if tha indentation level is mo' than 0.
.IP "\fB(?(\fR\fItext1\fR\fB#\fR\fIvar\fR\fIText2\fR\fB)?)\fR" 4
.IX Item "(?(text1#varText2)?)"
If tha value of \fIvar\fR is legit (not empty or zero), generates the
value of \fIvar\fR surrounded by \fItext1\fR n' \fIText2\fR, otherwise
nothing.
.IP "\fB~\fR" 4
.IX Item "~"
Any number of tildes n' surroundin whitespace is ghon be collapsed to
a single space.
.SS "# Variables"
.IX Subsection "# Variables"
These #vars represent opcode propertizzles dat you may want as part of
your rendering.  Da '#' is intended as a private sigil; a #var's
value is interpolated tha fuck into tha style-line, much like \*(L"read \f(CW$this\fR\*(R".
.PP
These vars take 3 forms:
.IP "\fB#\fR\fIvar\fR" 4
.IX Item "#var"
A property named 'var' be assumed ta exist fo' tha opcodes, n' is
interpolated tha fuck into tha rendering.
.IP "\fB#\fR\fIvar\fR\fIN\fR" 4
.IX Item "#varN"
Generates tha value of \fIvar\fR, left justified ta fill \fIN\fR spaces.
Note dat dis means while you can have propertizzles 'foo' n' 'foo2',
you cannot render 'foo2' yo, but you could wit 'foo2a'.  Yo ass would be
wise not ta rely on dis behavior goin forward ;\-)
.IP "\fB#\fR\fIVar\fR" 4
.IX Item "#Var"
This ucfirst form of #var generates a tag-value form of itself for
display; it converts '#Var' tha fuck into a 'Var => #var' style, which is then
handled as busted lyrics bout above.  (Imp-note: #Vars cannot be used for
conditional-fills, cuz tha => #var transform is done afta tha check
for #Varz value).
.PP
Da followin variablez is 'defined' by B::Concise; when they are
used up in a style, they respectizzle joints is plugged tha fuck into the
renderin of each opcode.
.PP
Only a shitload of these is used by tha standard styles, tha others are
provided fo' you ta delve tha fuck into optree mechanics, should you wish to
add a freshly smoked up steez (see \*(L"add_style\*(R" below) dat uses em.  Yo ass can
also add freshly smoked up ones rockin \*(L"add_callback\*(R".
.IP "\fB#addr\fR" 4
.IX Item "#addr"
Da address of tha \s-1OP,\s0 up in hexadecimal.
.IP "\fB#arg\fR" 4
.IX Item "#arg"
Da OP-specific shiznit of tha \s-1OP \s0(like fuckin tha \s-1SV\s0 fo' a \s-1SVOP,\s0 the
non-local exit pointas fo' a \s-1LOOP,\s0 etc.) enclosed up in parentheses.
.IP "\fB#class\fR" 4
.IX Item "#class"
Da B\-determined class of tha \s-1OP,\s0 up in all caps.
.IP "\fB#classsym\fR" 4
.IX Item "#classsym"
A single symbol abbreviatin tha class of tha \s-1OP.\s0
.IP "\fB#coplabel\fR" 4
.IX Item "#coplabel"
Da label of tha statement or block tha \s-1OP\s0 is tha start of, if any.
.IP "\fB#exname\fR" 4
.IX Item "#exname"
Da name of tha \s-1OP,\s0 or 'ex\-foo' if tha \s-1OP\s0 be a null dat used ta be a gangbangin' foo.
.IP "\fB#extarg\fR" 4
.IX Item "#extarg"
Da target of tha \s-1OP,\s0 or not a god damn thang fo' a nulled \s-1OP.\s0
.IP "\fB#firstaddr\fR" 4
.IX Item "#firstaddr"
Da address of tha \s-1OP\s0z first child, up in hexadecimal.
.IP "\fB#flags\fR" 4
.IX Item "#flags"
Da \s-1OP\s0z flags, abbreviated as a seriez of symbols.
.IP "\fB#flagval\fR" 4
.IX Item "#flagval"
Da numeric value of tha \s-1OP\s0z flags.
.IP "\fB#hints\fR" 4
.IX Item "#hints"
Da \s-1COP\s0z hint flags, rendered wit abbreviated names if possible fo' realz. An empty
strin if dis aint a \s-1COP.\s0 Here is tha symbols used:
.Sp
.Vb 10
\&    $ strict refs
\&    & strict subs
\&    * strict vars
\&   x$ explicit use/no strict refs
\&   x& explicit use/no strict subs
\&   x* explicit use/no strict vars
\&    i integers
\&    l locale
\&    b bytes
\&    { block scope
\&    % localise %^H
\&    < open in
\&    > open out
\&    I overload int
\&    F overload float
\&    B overload binary
\&    S overload string
\&    R overload re
\&    T taint
\&    E eval
\&    X filetest access
\&    U utf\-8
.Ve
.IP "\fB#hintsval\fR" 4
.IX Item "#hintsval"
Da numeric value of tha \s-1COP\s0z hint flags, or a empty strang if dis is not
a \s-1COP.\s0
.IP "\fB#hyphseq\fR" 4
.IX Item "#hyphseq"
Da sequence number of tha \s-1OP,\s0 or a hyphen if it aint gots one.
.IP "\fB#label\fR" 4
.IX Item "#label"
\&'\s-1NEXT\s0', '\s-1LAST\s0', or '\s-1REDO\s0' if tha \s-1OP\s0 be a target of one of dem up in exec
mode, or empty otherwise.
.IP "\fB#lastaddr\fR" 4
.IX Item "#lastaddr"
Da address of tha \s-1OP\s0z last child, up in hexadecimal.
.IP "\fB#name\fR" 4
.IX Item "#name"
Da \s-1OP\s0z name.
.IP "\fB#NAME\fR" 4
.IX Item "#NAME"
Da \s-1OP\s0z name, up in all caps.
.IP "\fB#next\fR" 4
.IX Item "#next"
Da sequence number of tha \s-1OP\s0z next \s-1OP.\s0
.IP "\fB#nextaddr\fR" 4
.IX Item "#nextaddr"
Da address of tha \s-1OP\s0z next \s-1OP,\s0 up in hexadecimal.
.IP "\fB#noise\fR" 4
.IX Item "#noise"
A one\- or two-characta abbreviation fo' tha \s-1OP\s0z name.
.IP "\fB#private\fR" 4
.IX Item "#private"
Da \s-1OP\s0z private flags, rendered wit abbreviated names if possible.
.IP "\fB#privval\fR" 4
.IX Item "#privval"
Da numeric value of tha \s-1OP\s0z private flags.
.IP "\fB#seq\fR" 4
.IX Item "#seq"
Da sequence number of tha \s-1OP.\s0 Note dat dis be a sequence number
generated by B::Concise.
.IP "\fB#seqnum\fR" 4
.IX Item "#seqnum"
5.8.x n' earlier only. 5.9 n' lata do not provide all dis bullshit.
.Sp
Da real sequence number of tha \s-1OP,\s0 as a regular number n' not adjusted
to be relatizzle ta tha start of tha real program. (This will generally be
a fairly big-ass number cuz all of \fBB::Concise\fR is compiled before
your program is).
.IP "\fB#opt\fR" 4
.IX Item "#opt"
Whether or not tha op has been optimised by tha peephole optimiser.
.Sp
Only available up in 5.9 n' later.
.IP "\fB#sibaddr\fR" 4
.IX Item "#sibaddr"
Da address of tha \s-1OP\s0z next youngest sibling, up in hexadecimal.
.IP "\fB#svaddr\fR" 4
.IX Item "#svaddr"
Da address of tha \s-1OP\s0z \s-1SV,\s0 if it has a \s-1SV,\s0 up in hexadecimal.
.IP "\fB#svclass\fR" 4
.IX Item "#svclass"
Da class of tha \s-1OP\s0z \s-1SV,\s0 if it has one, up in all caps (e.g., '\s-1IV\s0').
.IP "\fB#svval\fR" 4
.IX Item "#svval"
Da value of tha \s-1OP\s0z \s-1SV,\s0 if it has one, up in a gangbangin' finger-lickin' dirty-ass short human-readable format.
.IP "\fB#targ\fR" 4
.IX Item "#targ"
Da numeric value of tha \s-1OP\s0z targ.
.IP "\fB#targarg\fR" 4
.IX Item "#targarg"
Da name of tha variable tha \s-1OP\s0z targ refers to, if any, otherwise the
letta t followed by tha \s-1OP\s0z targ up in decimal.
.IP "\fB#targarglife\fR" 4
.IX Item "#targarglife"
Same as \fB#targarg\fR yo, but followed by tha \s-1COP\s0 sequence numbers dat delimit
the variablez gametime (or 'end' fo' a variable up in a open scope) fo' a
variable.
.IP "\fB#typenum\fR" 4
.IX Item "#typenum"
Da numeric value of tha \s-1OP\s0z type, up in decimal.
.SH "One-Liner Command tips"
.IX Header "One-Liner Command tips"
.IP "perl \-MO=Concise,bar foo.pl" 4
.IX Item "perl -MO=Concise,bar foo.pl"
Rendaz only \fIbar()\fR from foo.pl.  To peep main, drop tha ',bar'.  To see
both, add ',\-main'
.IP "perl \-MDigest::MD5=md5 \-MO=Concise,md5 \-e1" 4
.IX Item "perl -MDigest::MD5=md5 -MO=Concise,md5 -e1"
Identifies md5 as a \s-1XS\s0 function. I aint talkin' bout chicken n' gravy biatch.  Da export is needed so dat \s-1BC\s0 can
find it up in main.
.IP "perl \-MPOSIX \-MO=Concise,_POSIX_ARG_MAX \-e1" 4
.IX Item "perl -MPOSIX -MO=Concise,_POSIX_ARG_MAX -e1"
Identifies _POSIX_ARG_MAX as a cold-ass lil constant sub, optimized ta a \s-1IV.\s0
Although \s-1POSIX\s0 aint entirely consistent across platforms, dis is
likely ta be present up in virtually all of em.
.IP "perl \-MPOSIX \-MO=Concise,a \-e 'print _POSIX_SAVED_IDS'" 4
.IX Item "perl -MPOSIX -MO=Concise,a -e 'print _POSIX_SAVED_IDS'"
This rendaz a print statement, which includes a cold-ass lil call ta tha function.
It aint nuthin but identical ta renderin a gangbangin' file wit a use call n' dat single
statement, except fo' tha filename which appears up in tha nextstate ops.
.IP "perl \-MPOSIX \-MO=Concise,a \-e 'sub a{_POSIX_SAVED_IDS}'" 4
.IX Item "perl -MPOSIX -MO=Concise,a -e 'sub a{_POSIX_SAVED_IDS}'"
This is \fBvery\fR similar ta previous, only tha straight-up original gangsta two ops differ n' shit.  This
subroutine renderin is mo' representative, insofar as a single main
program gonna git nuff subs.
.ie n .IP "perl \-MB::Concise \-e 'B::Concise::compile(""\-exec"",""\-src"", \e%B::Concise::)\->()'" 4
.el .IP "perl \-MB::Concise \-e 'B::Concise::compile(``\-exec'',``\-src'', \e%B::Concise::)\->()'" 4
.IX Item "perl -MB::Concise -e 'B::Concise::compile(-exec,-src, %B::Concise::)->()'"
This rendaz all functions up in tha B::Concise package wit tha source
lines.  It eschews tha O framework so dat tha stashref can be passed
directly ta \fIB::Concise::compile()\fR.  See \-stash option fo' a more
convenient way ta render a package.
.SH "Usin B::Concise outside of tha O framework"
.IX Header "Usin B::Concise outside of tha O framework"
Da common (and original) usage of B::Concise was fo' command-line
renderingz of simple code, as given up in \s-1EXAMPLE. \s0 But you can also use
\&\fBB::Concise\fR from yo' code, n' call \fIcompile()\fR directly, and
repeatedly.  By bustin so, you can avoid tha compile-time only
operation of O.pm, n' even use tha debugger ta step through
\&\fIB::Concise::compile()\fR itself.
.PP
Once you bustin this, you may alta Concise output by addin new
renderin styles, n' by optionally addin callback routines which
populate freshly smoked up variables, if such was referenced from dem (just
added) styles.
.SS "Example: Alterin Concise Renderings"
.IX Subsection "Example: Alterin Concise Renderings"
.Vb 9
\&    use B::Concise qw(set_style add_callback);
\&    add_style($yourStyleName => $defaultfmt, $gotofmt, $treefmt);
\&    add_callback
\&      ( sub {
\&            mah ($h, $op, $format, $level, $stylename) = @_;
\&            $h\->{variable} = some_func($op);
\&        });
\&    $walker = B::Concise::compile(@options,@subnames,@subrefs);
\&    $walker\->();
.Ve
.SS "\fIset_style()\fP"
.IX Subsection "set_style()"
\&\fBset_style\fR accepts 3 arguments, n' thugged-out shiznit tha three format-specs
comprisin a line-style (basic-exec, goto, tree).  It has one minor
drawback though; it don't regista tha steez under a freshly smoked up name.  This
can become a issue if you render mo' than once n' switch styles.
Thus you may prefer ta use \fIadd_style()\fR and/or \fIset_style_standard()\fR
instead.
.SS "set_style_standard($name)"
.IX Subsection "set_style_standard($name)"
This restores one of tha standard line-styles: \f(CW\*(C`terse\*(C'\fR, \f(CW\*(C`concise\*(C'\fR,
\&\f(CW\*(C`linenoise\*(C'\fR, \f(CW\*(C`debug\*(C'\fR, \f(CW\*(C`env\*(C'\fR, tha fuck into effect.  It also accepts style
names previously defined wit \fIadd_style()\fR.
.SS "add_style ()"
.IX Subsection "add_style ()"
This subroutine accepts a freshly smoked up steez name n' three steez arguments as
above, n' creates, registers, n' selects tha newly named style.  It is
an error ta re-add a style; call \fIset_style_standard()\fR ta switch between
several styles.
.SS "add_callback ()"
.IX Subsection "add_callback ()"
If yo' newly minted stylez refer ta any freshly smoked up #variables, you gonna need
to define a cold-ass lil callback subroutine dat will populate (or modify) them
variables.  They is then available fo' use up in tha steez you've
chosen.
.PP
Da callbacks is called fo' each opcode hit up by Concise, up in the
same order as they is added. Y'all KNOW dat shit, muthafucka!  Each subroutine is passed five
parameters.
.PP
.Vb 6
\&  1 fo' realz. A hashref, containin tha variable names n' joints which are
\&     populated tha fuck into tha report\-line fo' tha op
\&  2. tha op, as a B<B::OP> object
\&  3. a reference ta tha format string
\&  4. tha formattin (indent) level
\&  5. tha selected stylename
.Ve
.PP
To define yo' own variables, simply add dem ta tha hash, or chizzle
existin joints if you need to.  Da level n' format is passed up in as
references ta scalars yo, but it is unlikely dat they will need ta be
changed or even used.
.SS "Hustlin \fIB::Concise::compile()\fP"
.IX Subsection "Hustlin B::Concise::compile()"
\&\fBcompile\fR accepts options as busted lyrics bout above up in \*(L"\s-1OPTIONS\*(R"\s0, and
arguments, which is either coderefs, or subroutine names.
.PP
It constructs n' returns a \f(CW$treewalker\fR coderef, which when invoked,
traverses, or strutts, n' rendaz tha optreez of tha given arguments to
\&\s-1STDOUT. \s0 Yo ass can reuse this, n' can chizzle tha renderin steez used
each time; thereafta tha coderef rendaz up in tha freshly smoked up style.
.PP
\&\fBwalk_output\fR lets you chizzle tha print destination from \s-1STDOUT\s0 to
another open filehandle, or tha fuck into a strang passed as a ref (unless
you've built perl wit \-Uuseperlio).
.PP
.Vb 7
\&    mah $walker = B::Concise::compile(\*(Aq\-terse\*(Aq,\*(AqaFuncName\*(Aq, \e&aSubRef);  # 1
\&    strutt_output(\emy $buf);
\&    $walker\->();                        # 1 rendaz \-terse
\&    set_style_standard(\*(Aqconcise\*(Aq);      # 2
\&    $walker\->();                        # 2 rendaz \-concise
\&    $walker\->(@new);                    # 3 rendaz whatever
\&    print "3 different renderings: terse, concise, n' @new: $buf\en";
.Ve
.PP
When \f(CW$walker\fR is called, it traverses tha subroutines supplied when it
was pimped, n' rendaz dem rockin tha current style.  Yo ass can chizzle
the steez afterwardz up in nuff muthafuckin different ways:
.PP
.Vb 3
\&  1. call C<compile>, alterin steez or mode/order
\&  2. call C<set_style_standard>
\&  3. call $walker, passin @new options
.Ve
.PP
Passin freshly smoked up options ta tha \f(CW$walker\fR is tha easiest way ta chizzle
amongst any pre-defined stylez (the ones you add is automatically
recognized as options), n' is tha only way ta alta renderin order
without callin compile again. I aint talkin' bout chicken n' gravy biatch.  Note however dat renderin state is
still shared amongst multiple \f(CW$walker\fR objects, so they must still be
used up in a cold-ass lil coordinated manner.
.SS "\fIB::Concise::reset_sequence()\fP"
.IX Subsection "B::Concise::reset_sequence()"
This function (not exported) lets you reset tha sequence numbers (note
that they numbered arbitrarily, they goal bein ta be human
readable).  Its purpose is mostly ta support testing, i.e. ta compare
the concise output from two identical anonymous subroutines (but
different instances).  Without tha reset, B::Concise, seein that
they separate optrees, generates different sequence numbers in
the output.
.SS "Errors"
.IX Subsection "Errors"
Errors up in renderin (non-existent function-name, non-existent coderef)
are freestyled ta tha \s-1STDOUT,\s0 or wherever you've set it via
\&\fIwalk_output()\fR.
.PP
Errors rockin tha various *style* calls, n' wack args ta \fIwalk_output()\fR,
result up in \fIdie()\fR.  Use a eval if you wish ta catch these errors and
continue processing.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stephen McCamant, <smcc@CSUA.Berkeley.EDU>.
