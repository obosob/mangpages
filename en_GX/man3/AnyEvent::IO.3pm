.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::IO 3"
.TH AnyEvent::IO 3 "2013-07-30" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::IO \- tha DBI of asynchronous I/O implementations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent::IO;
\&
\&   # load /etc/passwd, call clalback wit tha file data when done.
\&   aio_load "/etc/passwd", sub {
\&      mah ($data) = @_
\&         or return AE::log error => "/etc/passwd: $!";
\&
\&      warn "/etc/passwd gotz nuff ", ($data =~ y/://) , " colons.\en";
\&   };
\&
\&   # tha rest of tha SYNOPSIS do tha same yo, but wit individual I/O calls
\&
\&   # also import O_XXX flags
\&   use AnyEvent::IO qw(:DEFAULT :flags);
\&
\&   mah $filedata = AE::cv;
\&
\&   # first open tha file
\&   aio_open "/etc/passwd", O_RDONLY, 0, sub {
\&      mah ($fh) = @_
\&         or return AE::log error => "/etc/passwd: $!";
\&
\&      # now stat tha file ta git tha size
\&      aio_stat $fh, sub {
\&         @_
\&            or return AE::log error => "/etc/passwd: $!";
\&
\&         mah $size = \-s _;
\&
\&         # now read all tha file data
\&         aio_read $fh, $size, sub {
\&            mah ($data) = @_
\&               or return AE::log error => "/etc/passwd: $!";
\&
\&            $size == length $data
\&               or return AE::log error => "/etc/passwd: short read, file chizzled?";
\&
\&            # mostly tha same as aio_load, above \- $data gotz nuff
\&            # tha file contents now, nahmeean?
\&            $filedata\->($data);
\&         };
\&      };
\&   };
\&
\&   mah $passwd = $filedata\->recv;
\&   warn length $passwd, " octets.\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up functions dat do I/O up in a asynchronous fashion. I aint talkin' bout chicken n' gravy biatch. It
is ta I/O tha same as AnyEvent is ta event libraries \- it only
\&\fIinterfaces\fR ta other implementations or ta a portable pure-perl
implementation (which do not, however, do asynchronous I/O).
.PP
Da only other implementation dat is supported (or even known ta the
author) is \s-1IO::AIO\s0, which is used automatically when it can be loaded
(via AnyEvent::AIO, which also need ta be installed). If it is not
available, then AnyEvent::IO falls back ta its synchronous pure-perl
implementation.
.PP
Unlike AnyEvent, which model ta use is currently decided at module load
time, not at first use. Future releases might chizzle all dis bullshit.
.SS "\s-1RATIONALE\s0"
.IX Subsection "RATIONALE"
While disk I/O often seems \*(L"instant\*(R" compared to, say, socket I/O, there
are nuff thangs where yo' program can block fo' extended time periods
when bustin disk I/O. For example, you access a gangbangin' finger-lickin' disk on a \s-1NFS\s0 server and
it is gone \- can take ages ta respond again, if eva n' shit. Or yo' system is
extremely busy cuz it creates or restores a funky-ass backup \- readin data from
disk can then take seconds. Or you use Linux, which fo' all kindsa muthafuckin muthafuckin years has
a close-to-broken \s-1VM/IO\s0 subsystem dat can often induce minutes or mo' of
delay fo' disk I/O, even under what tha fuck I would consider light I/O loads.
.PP
Whatever tha thang, some programs just can't afford ta block fo' long
times (say, half a second or more), cuz they need ta respond as fast
as possible.
.PP
For dem cases, you need asynchronous I/O.
.PP
Da problem is, AnyEvent itself sometimes readz disk filez (for example,
when lookin at \fI/etc/hosts\fR), n' under tha above thangs, dis can
brin yo' program ta a cold-ass lil complete halt even if yo' program otherwise
takes care ta only use asynchronous I/O fo' every last muthafuckin thang (e.g. by using
\&\s-1IO::AIO\s0).
.PP
On tha other hand, requirin \s-1IO::AIO\s0 fo' AnyEvent is clearly
impossible, as AnyEvent promises ta stay pure-perl, n' tha overhead of
\&\s-1IO::AIO\s0 fo' lil' small-ass programs would be immense, especially when asynchronous
I/O aint even needed.
.PP
Clearly, dis calls fo' a abstraction layer, n' dat is what tha fuck yo ass is
lookin at right now :\-)
.SS "\s-1ASYNCHRONOUS VS.\s0 NON-BLOCKING"
.IX Subsection "ASYNCHRONOUS VS. NON-BLOCKING"
Many playas is continuously trippin on what tha fuck tha difference is between
asynchronous I/O n' non-blockin I/O. In fact, dem two terms are
not well defined, which often make it hard ta even rap bout the
difference yo. Here be a gangbangin' finger-lickin' dirty-ass short guideline dat should leave you less
confused. Y'all KNOW dat shit, muthafucka! Well shiiiit, it only talks bout read operations yo, but tha reasonin works
with other I/O operations as well.
.PP
Non-blockin I/O means dat data is served up by some external means,
automatically \- dat is, suttin' \fIpushes\fR data towardz yo' file
handle, without you havin ta do anything. Non-blockin means dat if
your operatin system currently has no data (or \s-1EOF,\s0 or some error)
available fo' you, it aint gonna wait (\*(L"block\*(R") as it would normally do,
but immediately return wit a error (e.g. \f(CW\*(C`EWOULDBLOCK\*(C'\fR \- \*(L"I would have
blocked yo, but you forbid it\*(R").
.PP
Yo crazy-ass program can then wait fo' data ta arrive by other means, fo' example,
an I/O watcher which  drops some lyrics ta you when ta re-attempt tha read, afta which it
can try ta read again, n' so on.
.PP
Often, you would expect dis ta work fo' disk filez as well \- if tha data
aint already up in memory, one might wanna wait fo' it n' then re-attempt
the read fo' example. While dis is sound reasoning, tha \s-1POSIX API\s0 do
not support this, cuz disk drives n' file systems do not bust data
\&\*(L"on they own\*(R", n' mo' so, tha \s-1OS\s0 already knows dat data is there, it
doesn't need ta \*(L"wait\*(R" until it arrives from some external entity, it only
needz ta transfer tha data from disk ta yo' memory buffer.
.PP
So basically, while tha concept is sound, tha existin \s-1OS\s0 APIs do not
support all dis bullshit. Therefore, it make no sense ta switch a gangbangin' finger-lickin' disk file handle
into non-blockin mode \- it will behave exactly tha same as up in blocking
mode, namely it will block until tha data has been read from tha disk.
.PP
Da alternatizzle ta non-blockin I/O dat straight-up works wit disk files
is probably called \fIasynchronous I/O\fR fo' realz. Asynchronous, cuz tha actual
I/O is done while yo' program do suttin' else: there is no need to
call tha read function ta peep if data is there, you only order tha read
once, n' it will notify you when tha read has finished n' tha data is
your buffer \- all tha work is done up in tha background.
.PP
This works wit disk files, n' even wit sockets n' other sources. It
is, however, not straight-up efficient when used wit sources dat could be
driven up in a non-blockin way, cuz it probably has higher overhead
in tha \s-1OS\s0 than non-blockin I/O, cuz it tizzles memory buffers fo' a
potentially unlimited time n' often only a limited number of operations
can be done up in parallel.
.PP
Thatz why asynchronous I/O make most sense when confronted wit disk
files, n' non-blockin I/O only make sense wit sockets, pipes and
similar streamin sources.
.SH "IMPORT TAGS"
.IX Header "IMPORT TAGS"
By default, dis module exports all \f(CW\*(C`aio_\*(C'\fRxxx functions. In addition,
the followin import tags can be used:
.PP
.Vb 2
\&   :aio       all aio_* functions, same as WHAT!EFAULT
\&   :flags     tha fcntl open flags (O_CREAT, O_RDONLY, ...)
.Ve
.SH "API NOTES"
.IX Header "API NOTES"
Da functions up in dis module is not meant ta be da most thugged-out versatile or
the highest-performers (they is not straight-up slow either, of course). They
are primarily meant ta give playaz of yo' code tha option ta do tha I/O
asynchronously (by installin \s-1IO::AIO\s0 n' AnyEvent::AIO),
without addin a thugged-out dependency on dem modules.
.SS "\s-1NAMING\s0"
.IX Subsection "NAMING"
All tha functions up in dis module implement a I/O operation, probably with
the same or similar name as tha Perl built-in dat they mimic yo, but with
an \f(CW\*(C`aio_\*(C'\fR prefix. If you like you can be thinkin of tha \f(CW\*(C`aio_\*(C'\fRxxx functions as
\&\*(L"AnyEvent I/O\*(R" or \*(L"Asynchronous I/O\*(R" variantz of Perl built-ins.
.SS "\s-1CALLING CONVENTIONS AND ERROR REPORTING\s0"
.IX Subsection "CALLING CONVENTIONS AND ERROR REPORTING"
Each function expects a cold-ass lil callback as they last argument. Da callback is
usually called wit tha result data or result code fo' realz. An error is usually
signalled by passin no arguments ta tha callback, which is then free to
peep \f(CW$!\fR fo' tha error code.
.PP
This make all of tha followin formz of error checkin valid:
.PP
.Vb 3
\&   aio_open ...., sub {
\&      mah $fh = shift   # scalar assignment \- will assign undef on error
\&         or return AE::log error => "...";
\&
\&      mah ($fh) = @_    # list assignment \- is ghon be 0 elements on error
\&         or return AE::log error => "...";
\&
\&      @_               # check tha number of elements directly
\&         or return AE::log error => "...";
.Ve
.SS "\s-1CAVEAT: RELATIVE PATHS\s0"
.IX Subsection "CAVEAT: RELATIVE PATHS"
When a path is specified, dis path \fImust be a absolute\fR path, unless
you make certain dat not a god damn thang up in yo' process calls \f(CW\*(C`chdir\*(C'\fR or an
equivalent function while tha request executes.
.SS "\s-1CAVEAT: OTHER SHARED STATE\s0"
.IX Subsection "CAVEAT: OTHER SHARED STATE"
Changin tha \f(CW\*(C`umask\*(C'\fR while any requests execute dat create filez (or
otherwise rely on tha current umask) thangs up in dis biatch up in undefined behaviour \-
likewise changin anythang else dat would chizzle tha outcome, such as
your effectizzle user or crew \s-1ID.\s0
.SS "\s-1CALLBACKS MIGHT BE CALLED BEFORE FUNCTION RETURNS TO CALLER\s0"
.IX Subsection "CALLBACKS MIGHT BE CALLED BEFORE FUNCTION RETURNS TO CALLER"
Unlike other functions up in tha AnyEvent module crew, these functions
\&\fImay\fR call yo' callback instantly, before returning. This should not be
a real problem, as these functions never return anythang useful.
.SS "\s-1BEHAVIOUR AT PROGRAM EXIT\s0"
.IX Subsection "BEHAVIOUR AT PROGRAM EXIT"
Both AnyEvent::IO::Perl n' AnyEvent::IO::IOAIO implementations
make shizzle dat operations dat have started is ghon be finished on a cold-ass lil clean
programs exit. That make programs work dat start some I/O operations and
then exit. For example dis complete program:
.PP
.Vb 1
\&   use AnyEvent::IO;
\&
\&   aio_stat "path1", sub {
\&      aio_stat "path2", sub {
\&         warn "both stats done\en";
\&      };
\&   };
.Ve
.PP
Starts a \f(CW\*(C`stat\*(C'\fR operation n' then exits by \*(L"fallin off tha end\*(R" of
the program. Nevertheless, \fIboth\fR \f(CW\*(C`stat\*(C'\fR operations is ghon be executed,
as AnyEvent::IO waits fo' all outstandin requests ta finish n' you can
start freshly smoked up requests from request callbacks.
.PP
In fact, since AnyEvent::IO::Perl is currently synchronous, the
program will do both stats before fallin off tha end yo, but with
AnyEvent::IO::IOAIO, tha program first fallz of tha end, then tha stats
are executed.
.PP
While not guaranteed, dis behaviour is ghon be present up in future versions,
if reasonably possible (which is extreemly likely :).
.SH "GLOBAL VARIABLES AND FUNCTIONS"
.IX Header "GLOBAL VARIABLES AND FUNCTIONS"
.ie n .IP "$AnyEvent::IO::MODEL" 4
.el .IP "\f(CW$AnyEvent::IO::MODEL\fR" 4
.IX Item "$AnyEvent::IO::MODEL"
Gotz Nuff tha package name of tha backend I/O model up in use \- all up in tha moment,
this is probably \f(CW\*(C`AnyEvent::IO::Perl\*(C'\fR or \f(CW\*(C`AnyEvent::IO::IOAIO\*(C'\fR.
.ie n .IP "aio_load $path, $cb\->($data)" 4
.el .IP "aio_load \f(CW$path\fR, \f(CW$cb\fR\->($data)" 4
.IX Item "aio_load $path, $cb->($data)"
Tries ta open \f(CW$path\fR n' read its contents tha fuck into memory (obviously,
should only be used on filez dat is \*(L"small enough\*(R"), then passes dem to
the callback as a string.
.Sp
Example: load \fI/etc/hosts\fR.
.Sp
.Vb 3
\&   aio_load "/etc/hosts", sub {
\&      mah ($hosts) = @_
\&         or return AE::log error => "/etc/hosts: $!";
\&
\&      AE::log info => "/etc/hosts gotz nuff ", ($hosts =~ y/\en/), " lines\en";
\&   };
.Ve
.ie n .IP "aio_open $path, $flags, $mode, $cb\->($fh)" 4
.el .IP "aio_open \f(CW$path\fR, \f(CW$flags\fR, \f(CW$mode\fR, \f(CW$cb\fR\->($fh)" 4
.IX Item "aio_open $path, $flags, $mode, $cb->($fh)"
Tries ta open tha file specified by \f(CW$path\fR wit tha O_XXX\-flags
\&\f(CW$flags\fR (from tha Fcntl module, or peep below) n' tha mode \f(CW$mode\fR (a
phat value is 0666 fo' \f(CW\*(C`O_CREAT\*(C'\fR, n' \f(CW0\fR otherwise).
.Sp
Da (normal, standard, perl) file handle associated wit tha opened file
is then passed ta tha callback.
.Sp
This works straight-up much like Perlz \f(CW\*(C`sysopen\*(C'\fR function.
.Sp
Changin tha \f(CW\*(C`umask\*(C'\fR while dis request executes thangs up in dis biatch up in undefined
behaviour \- likewise changin anythang else dat would chizzle tha outcome,
like fuckin yo' effectizzle user or crew \s-1ID.\s0
.Sp
To avoid havin ta load Fcntl, dis module serves up constants
for \f(CW\*(C`O_RDONLY\*(C'\fR, \f(CW\*(C`O_WRONLY\*(C'\fR, \f(CW\*(C`O_RDWR\*(C'\fR, \f(CW\*(C`O_CREAT\*(C'\fR, \f(CW\*(C`O_EXCL\*(C'\fR,
\&\f(CW\*(C`O_TRUNC\*(C'\fR n' \f(CW\*(C`O_APPEND\*(C'\fR \- you can either access dem directly
(\f(CW\*(C`AnyEvent::IO::O_RDONLY\*(C'\fR) or import dem by specifyin tha \f(CW\*(C`:flags\*(C'\fR
import tag (see \s-1SYNOPSIS\s0).
.Sp
Example: securely open a gangbangin' file up in \fI/var/tmp\fR, fail if it exists or be a symlink.
.Sp
.Vb 1
\&   use AnyEvent::IO qw(:flags);
\&
\&   aio_open "/var/tmp/mytmp$$", O_CREAT | O_EXCL | O_RDWR, 0600, sub {
\&      mah ($fh) = @_
\&         or return AE::log error => "$! \- denial of steez attack?";
\&
\&      # now our crazy asses have $fh
\&   };
.Ve
.ie n .IP "aio_close $fh, $cb\->($success)" 4
.el .IP "aio_close \f(CW$fh\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_close $fh, $cb->($success)"
Closes tha file handle (yes, close can block yo' process indefinitely)
and passes a legit value ta tha callback on success.
.Sp
Cuz of idiosyncrasies up in perl, instead of callin \f(CW\*(C`close\*(C'\fR, tha file
handle might git closed by \f(CW\*(C`dup2\*(C'\fR'in another file descriptor over
it, dat is, tha \f(CW$fh\fR might still be open yo, but can be closed safely
afterwardz n' must not be used fo' anything.
.Sp
Example: close a gangbangin' file handle, n' dirty as we are, do not even bother
to check fo' errors.
.Sp
.Vb 1
\&   aio_close $fh, sub { };
.Ve
.ie n .IP "aio_read $fh, $length, $cb\->($data)" 4
.el .IP "aio_read \f(CW$fh\fR, \f(CW$length\fR, \f(CW$cb\fR\->($data)" 4
.IX Item "aio_read $fh, $length, $cb->($data)"
Tries ta read \f(CW$length\fR octets from tha current posizzle from \f(CW$fh\fR and
passes these bytes ta \f(CW$cb\fR. Otherwise tha semantics is straight-up much like
those of Perlz \f(CW\*(C`sysread\*(C'\fR.
.Sp
If less than \f(CW$length\fR octets done been read, \f(CW$data\fR will contain
only dem bytes straight-up read. Y'all KNOW dat shit, muthafucka! At \s-1EOF, \s0\f(CW$data\fR is ghon be a zero-length
string. If a error occurs, then not a god damn thang is passed ta tha callback.
.Sp
Obviously, multiple \f(CW\*(C`aio_read\*(C'\fRz or \f(CW\*(C`aio_write\*(C'\fRz all up in tha same time on file
handlez pluggin tha underlyin open file description thangs up in dis biatch up in undefined
behaviour, cuz of pluggin of tha current file offset (and less obviously
so, cuz \s-1OS X\s0 aint thread safe n' corrupts data when you try).
.Sp
Example: read 128 octets from a gangbangin' file.
.Sp
.Vb 3
\&   aio_read $fh, 128, sub {
\&      mah ($data) = @_
\&         or return AE::log error "read from fh: $!";
\&  
\&      if (length $data) {
\&         print "read ", length $data, " octets.\en";
\&      } else {
\&         print "EOF\en";
\&      }
\&   };
.Ve
.ie n .IP "aio_seek $fh, $offset, $whence, $callback\->($offs)" 4
.el .IP "aio_seek \f(CW$fh\fR, \f(CW$offset\fR, \f(CW$whence\fR, \f(CW$callback\fR\->($offs)" 4
.IX Item "aio_seek $fh, $offset, $whence, $callback->($offs)"
Seeks tha filehandle ta tha freshly smoked up \f(CW$offset\fR, similarly ta Perl's
\&\f(CW\*(C`sysseek\*(C'\fR. Da \f(CW$whence\fR is tha traditionizzle joints (\f(CW0\fR ta count from
start, \f(CW1\fR ta count from tha current posizzle n' \f(CW2\fR ta count from the
end).
.Sp
Da resultin absolute offset is ghon be passed ta tha callback on success.
.Sp
Example: measure tha size of tha file up in tha old-fashioned way rockin seek.
.Sp
.Vb 3
\&   aio_seek $fh, 0, 2, sub {
\&      mah ($size) = @_
\&         or return AE::log error => "seek ta end failed: $!";
\&
\&      # maybe we need ta seek ta tha beginnin again?
\&      aio_seek $fh, 0, 0, sub {
\&         # now we is hopefully all up in tha beginning
\&      };
\&   };
.Ve
.ie n .IP "aio_write $fh, $data, $cb\->($length)" 4
.el .IP "aio_write \f(CW$fh\fR, \f(CW$data\fR, \f(CW$cb\fR\->($length)" 4
.IX Item "aio_write $fh, $data, $cb->($length)"
Tries ta write tha octets up in \f(CW$data\fR ta tha current posizzle of \f(CW$fh\fR
and passes tha actual number of bytes freestyled ta tha \f(CW$cb\fR. Otherwise the
semantics is straight-up much like dem of Perlz \f(CW\*(C`syswrite\*(C'\fR.
.Sp
If less than \f(CW\*(C`length $data\*(C'\fR octets done been written, \f(CW$length\fR will
reflect dis shit. If a error occurs, then not a god damn thang is passed ta tha callback.
.Sp
Obviously, multiple \f(CW\*(C`aio_read\*(C'\fRz or \f(CW\*(C`aio_write\*(C'\fRz all up in tha same time on file
handlez pluggin tha underlyin open file description thangs up in dis biatch up in undefined
behaviour, cuz of pluggin of tha current file offset (and less obviously
so, cuz \s-1OS X\s0 aint thread safe n' corrupts data when you try).
.ie n .IP "aio_truncate $fh_or_path, $new_length, $cb\->($success)" 4
.el .IP "aio_truncate \f(CW$fh_or_path\fR, \f(CW$new_length\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_truncate $fh_or_path, $new_length, $cb->($success)"
Calls \f(CW\*(C`truncate\*(C'\fR on tha path or perl file handle n' passes a legit value
to tha callback on success.
.Sp
Example: truncate \fI/etc/passwd\fR ta zero length \- dis only works on
systems dat support \f(CW\*(C`truncate\*(C'\fR, should not be tried up fo' obvious
reasons n' debian will probably open yte another securitizzle bug bout this
example.
.Sp
.Vb 4
\&   aio_truncate "/etc/passwd", sub {
\&      @_
\&         or return AE::log error => "/etc/passwd: $! \- is you root enough?";
\&   };
.Ve
.ie n .IP "aio_utime $fh_or_path, $atime, $mtime, $cb\->($success)" 4
.el .IP "aio_utime \f(CW$fh_or_path\fR, \f(CW$atime\fR, \f(CW$mtime\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_utime $fh_or_path, $atime, $mtime, $cb->($success)"
Calls \f(CW\*(C`utime\*(C'\fR on tha path or perl file handle n' passes a legit value to
the callback on success.
.Sp
Da special case of both \f(CW$atime\fR n' \f(CW$mtime\fR bein \f(CW\*(C`undef\*(C'\fR sets the
times ta tha current time, on systems dat support all dis bullshit.
.Sp
Example: try ta bust a nut on \fIfile\fR.
.Sp
.Vb 1
\&   aio_utime "file", undef, undef, sub { };
.Ve
.ie n .IP "aio_chown $fh_or_path, $uid, $gid, $cb\->($success)" 4
.el .IP "aio_chown \f(CW$fh_or_path\fR, \f(CW$uid\fR, \f(CW$gid\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_chown $fh_or_path, $uid, $gid, $cb->($success)"
Calls \f(CW\*(C`chown\*(C'\fR on tha path or perl file handle n' passes a legit value to
the callback on success.
.Sp
If \f(CW$uid\fR or \f(CW$gid\fR can be specified as \f(CW\*(C`undef\*(C'\fR, up in which case the
uid or gid of tha file aint chizzled. Y'all KNOW dat shit, muthafucka! This differs from Perlz \f(CW\*(C`chown\*(C'\fR
built-in, which wants \f(CW\*(C`\-1\*(C'\fR fo' all dis bullshit.
.Sp
Example: update tha crew of \fIfile\fR ta 0 (root) yo, but leave tha balla ridin' solo.
.Sp
.Vb 4
\&   aio_chown "file", undef, 0, sub {
\&      @_
\&         or return AE::log error => "chown \*(Aqfile\*(Aq: $!";
\&   };
.Ve
.ie n .IP "aio_chmod $fh_or_path, $perms, $cb\->($success)" 4
.el .IP "aio_chmod \f(CW$fh_or_path\fR, \f(CW$perms\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_chmod $fh_or_path, $perms, $cb->($success)"
Calls \f(CW\*(C`chmod\*(C'\fR on tha path or perl file handle n' passes a legit value to
the callback on success.
.Sp
Example: chizzle \fIfile\fR ta be user/group/world\-readable yo, but leave tha other flags
alone.
.Sp
.Vb 3
\&   aio_stat "file", sub {
\&      @_
\&         or return AE::log error => "file: $!";
\&
\&      aio_chmod "file", (stat _)[2] & 07777 | 00444, sub { };
\&   };
.Ve
.ie n .IP "aio_stat $fh_or_path, $cb\->($success)" 4
.el .IP "aio_stat \f(CW$fh_or_path\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_stat $fh_or_path, $cb->($success)"
.PD 0
.ie n .IP "aio_lstat $path, $cb\->($success)" 4
.el .IP "aio_lstat \f(CW$path\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_lstat $path, $cb->($success)"
.PD
Calls \f(CW\*(C`stat\*(C'\fR or \f(CW\*(C`lstat\*(C'\fR on tha path or perl file handle n' passes a
true value ta tha callback on success.
.Sp
Da stat data is ghon be available by \f(CW\*(C`stat\*(C'\fR'in tha \f(CW\*(C`_\*(C'\fR file handle
(e.g. \f(CW\*(C`\-x _\*(C'\fR, \f(CW\*(C`stat _\*(C'\fR n' so on).
.Sp
Example: peep if we can find tha number of subdirectoriez of \fI/etc\fR.
.Sp
.Vb 3
\&   aio_stat "/etc", sub {
\&      @_
\&         or return AE::log error => "/etc: $!";
\&
\&      (stat _)[3] >= 2
\&         or return AE::log warn => "/etc has low link count \- non\-POSIX filesystem?";
\&
\&      print "/etc has ", (stat _)[3] \- 2, " subdirectories.\en";
\&   };
.Ve
.ie n .IP "aio_link $oldpath, $newpath, $cb\->($success)" 4
.el .IP "aio_link \f(CW$oldpath\fR, \f(CW$newpath\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_link $oldpath, $newpath, $cb->($success)"
Calls \f(CW\*(C`link\*(C'\fR on tha paths n' passes a legit value ta tha callback on
success.
.Sp
Example: link "\fIfile\fR ta \fIfile.bak\fR, then rename \fIfile.new\fR over \fIfile\fR,
to atomically replace dat shit.
.Sp
.Vb 3
\&   aio_link "file", "file.bak", sub {
\&      @_
\&         or return AE::log error => "file: $!";
\&
\&      aio_rename "file.new", "file", sub {
\&         @_
\&            or return AE::log error => "file.new: $!";
\&
\&         print "file atomically replaced by file.new, backup file.bak\en";
\&      };
\&   };
.Ve
.ie n .IP "aio_symlink $oldpath, $newpath, $cb\->($success)" 4
.el .IP "aio_symlink \f(CW$oldpath\fR, \f(CW$newpath\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_symlink $oldpath, $newpath, $cb->($success)"
Calls \f(CW\*(C`symlink\*(C'\fR on tha paths n' passes a legit value ta tha callback on
success.
.Sp
Example: create a symlink "\fIslink\fR containin \*(L"random data\*(R".
.Sp
.Vb 4
\&   aio_symlink "random data", "slink", sub {
\&      @_
\&         or return AE::log error => "slink: $!";
\&   };
.Ve
.ie n .IP "aio_readlink $path, $cb\->($target)" 4
.el .IP "aio_readlink \f(CW$path\fR, \f(CW$cb\fR\->($target)" 4
.IX Item "aio_readlink $path, $cb->($target)"
Calls \f(CW\*(C`readlink\*(C'\fR on tha paths n' passes tha link target strang ta the
callback.
.Sp
Example: read tha symlink called Fyslink> n' verify dat it gotz nuff \*(L"random data\*(R".
.Sp
.Vb 3
\&  aio_readlink "slink", sub {
\&     mah ($target) = @_
\&        or return AE::log error => "slink: $!";
\&
\&     $target eq "random data"
\&        or AE::log critical => "omg, tha ghetto will end!";
\&  };
.Ve
.ie n .IP "aio_rename $oldpath, $newpath, $cb\->($success)" 4
.el .IP "aio_rename \f(CW$oldpath\fR, \f(CW$newpath\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_rename $oldpath, $newpath, $cb->($success)"
Calls \f(CW\*(C`rename\*(C'\fR on tha paths n' passes a legit value ta tha callback on
success.
.Sp
See \f(CW\*(C`aio_link\*(C'\fR fo' a example.
.ie n .IP "aio_unlink $path, $cb\->($success)" 4
.el .IP "aio_unlink \f(CW$path\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_unlink $path, $cb->($success)"
Tries ta unlink tha object at \f(CW$path\fR n' passes a legit value ta the
callback on success.
.Sp
Example: try ta delete tha file \fItmpfile.dat~\fR.
.Sp
.Vb 1
\&   aio_unlink "tmpfile.dat~", sub { };
.Ve
.ie n .IP "aio_mkdir $path, $perms, $cb\->($success)" 4
.el .IP "aio_mkdir \f(CW$path\fR, \f(CW$perms\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_mkdir $path, $perms, $cb->($success)"
Calls \f(CW\*(C`mkdir\*(C'\fR on tha path wit tha given permissions \f(CW$perms\fR (when in
doubt, \f(CW0777\fR be a phat value) n' passes a legit value ta tha callback on
success.
.Sp
Example: try ta create tha directory \fIsubdir\fR n' leave it ta whoeveer
comes afta our asses ta check whether it worked.
.Sp
.Vb 1
\&   aio_mkdir "subdir", 0777, sub { };
.Ve
.ie n .IP "aio_rmdir $path, $cb\->($success)" 4
.el .IP "aio_rmdir \f(CW$path\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_rmdir $path, $cb->($success)"
Tries ta remove tha directory at \f(CW$path\fR n' passes a legit value ta the
callback on success.
.Sp
Example: try ta remove tha directory \fIsubdir\fR n' don't give a thugged-out damn if
that fails.
.Sp
.Vb 1
\&   aio_rmdir "subdir", sub { };
.Ve
.ie n .IP "aio_readdir $path, $cb\->(\e@names)" 4
.el .IP "aio_readdir \f(CW$path\fR, \f(CW$cb\fR\->(\e@names)" 4
.IX Item "aio_readdir $path, $cb->(@names)"
Readz all filenames from tha directory specified by \f(CW$path\fR n' passes
them ta tha callback, as a array reference wit tha names (without a path
prefix). Da \fI.\fR n' \fI..\fR names is ghon be filtered up first.
.Sp
Da orderin of tha file names is undefined \- backendz dat is capable
of it (e.g. \s-1IO::AIO\s0) will return tha orderin dat most likely is
fastest ta \f(CW\*(C`stat\*(C'\fR through, n' furthermore put entries dat likely are
directories first up in tha array.
.Sp
If you need dopest performizzle up in recursive directory traversal or when
lookin at straight-up big-ass directories, yo ass be advised ta use \s-1IO::AIO\s0
directly, specifically tha \f(CW\*(C`aio_readdirx\*(C'\fR n' \f(CW\*(C`aio_scandir\*(C'\fR functions,
which have mo' options ta tune performance.
.Sp
Example: recursively scan a gangbangin' finger-lickin' directory hierarchy, silently skip diretcories
we couldn't read n' print all others.
.Sp
.Vb 3
\&   sub scan($); # visibility\-in\-next statement aint so useful these days
\&   sub scan($) {
\&      mah ($path) = @_;
\&
\&      aio_readdir $path, sub {
\&         mah ($names) = @_
\&            or return;
\&
\&         print "$path\en";
\&
\&         fo' mah $name (@$names) {
\&            aio_lstat "$path/$name", sub {
\&               scan "$path/$name"
\&                  if \-d _;
\&            };
\&         }
\&      };
\&   }
\&
\&   scan "/etc";
.Ve
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
See tha description of \f(CW\*(C`PERL_ANYEVENT_IO_MODEL\*(C'\fR up in tha AnyEvent
manpage.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://anyevent.schmorp.de
.Ve
