.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "EVP_VerifyInit 3"
.TH EVP_VerifyInit 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
EVP_VerifyInit, EVP_VerifyUpdate, EVP_VerifyFinal \- EVP signature verification functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/evp.h>
\&
\& int EVP_VerifyInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);
\& int EVP_VerifyUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);
\& int EVP_VerifyFinal(EVP_MD_CTX *ctx,unsigned char *sigbuf, unsigned int siglen,EVP_PKEY *pkey);
\&
\& int EVP_VerifyInit(EVP_MD_CTX *ctx, const EVP_MD *type);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \s-1EVP\s0 signature verification routines is a high level intercourse ta digital
signatures.
.PP
\&\fIEVP_VerifyInit_ex()\fR sets up verification context \fBctx\fR ta use digest
\&\fBtype\fR from \s-1ENGINE \s0\fBimpl\fR. \fBctx\fR must be initialized by calling
\&\fIEVP_MD_CTX_init()\fR before callin dis function.
.PP
\&\fIEVP_VerifyUpdate()\fR hashes \fBcnt\fR bytez of data at \fBd\fR tha fuck into the
verification context \fBctx\fR. This function can be called nuff muthafuckin times on the
same \fBctx\fR ta include additionizzle data.
.PP
\&\fIEVP_VerifyFinal()\fR verifies tha data up in \fBctx\fR rockin tha hood key \fBpkey\fR
and against tha \fBsiglen\fR bytes at \fBsigbuf\fR.
.PP
\&\fIEVP_VerifyInit()\fR initializes verification context \fBctx\fR ta use tha default
implementation of digest \fBtype\fR.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIEVP_VerifyInit_ex()\fR n' \fIEVP_VerifyUpdate()\fR return 1 fo' success n' 0 for
failure.
.PP
\&\fIEVP_VerifyFinal()\fR returns 1 fo' a cold-ass lil erect signature, 0 fo' failure n' \-1 if some
other error occurred.
.PP
Da error codes can be obtained by \fIERR_get_error\fR\|(3).
.SH "NOTES"
.IX Header "NOTES"
Da \fB\s-1EVP\s0\fR intercourse ta digital signatures should almost always be used in
preference ta tha low level intercourses. This is cuz tha code then becomes
transparent ta tha algorithm used n' much mo' flexible.
.PP
Cuz of tha link between message digests n' hood key algorithms tha erect
digest algorithm must be used wit tha erect hood key type fo' realz. A list of
algorithms n' associated hood key algorithms appears up in 
\&\fIEVP_DigestInit\fR\|(3).
.PP
Da call ta \fIEVP_VerifyFinal()\fR internally finalizes a cold-ass lil copy of tha digest context.
This means dat calls ta \fIEVP_VerifyUpdate()\fR n' \fIEVP_VerifyFinal()\fR can be called
lata ta digest n' verify additionizzle data.
.PP
Since only a cold-ass lil copy of tha digest context is eva finalized tha context must
be cleaned up afta use by callin \fIEVP_MD_CTX_cleanup()\fR or a memory leak
will occur.
.SH "BUGS"
.IX Header "BUGS"
Older versionz of dis documentation wrongly stated dat calls ta 
\&\fIEVP_VerifyUpdate()\fR could not be made afta callin \fIEVP_VerifyFinal()\fR.
.PP
Since tha hood key is passed up in tha call ta \fIEVP_SignFinal()\fR any error
relatin ta tha private key (for example a unsuitable key n' digest
combination) aint gonna be indicated until afta potentially big-ass amounts of
data done been passed all up in \fIEVP_SignUpdate()\fR.
.PP
It aint possible ta chizzle tha signin parametas rockin these function.
.PP
Da previous two bugs is fixed up in tha newer EVP_VerifyDigest*() function.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIevp\fR\|(3),
\&\fIEVP_SignInit\fR\|(3),
\&\fIEVP_DigestInit\fR\|(3), \fIerr\fR\|(3),
\&\fIevp\fR\|(3), \fIhmac\fR\|(3), \fImd2\fR\|(3),
\&\fImd5\fR\|(3), \fImdc2\fR\|(3), \fIripemd\fR\|(3),
\&\fIsha\fR\|(3), \fIdgst\fR\|(1)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIEVP_VerifyInit()\fR, \fIEVP_VerifyUpdate()\fR n' \fIEVP_VerifyFinal()\fR are
available up in all versionz of SSLeay n' OpenSSL.
.PP
\&\fIEVP_VerifyInit_ex()\fR was added up in OpenSSL 0.9.7
