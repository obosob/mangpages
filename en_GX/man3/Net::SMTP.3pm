.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::SMTP 3pm"
.TH Net::SMTP 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::SMTP \- Simple Mail Transfer Protocol Client
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::SMTP;
\&
\&    # Constructors
\&    $smtp = Net::SMTP\->new(\*(Aqmailhost\*(Aq);
\&    $smtp = Net::SMTP\->new(\*(Aqmailhost\*(Aq, Timeout => 60);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements a cold-ass lil client intercourse ta tha \s-1SMTP\s0 n' \s-1ESMTP\s0
protocol, enablin a perl5 application ta rap ta \s-1SMTP\s0 servers. This
documentation assumes dat yo ass is familiar wit tha conceptz of the
\&\s-1SMTP\s0 protocol busted lyrics bout up in \s-1RFC821.\s0
.PP
A freshly smoked up Net::SMTP object must be pimped wit tha \fInew\fR method. Y'all KNOW dat shit, muthafucka! Once
this has been done, all \s-1SMTP\s0 commandz is accessed all up in dis object.
.PP
Da Net::SMTP class be a subclass of Net::Cmd n' IO::Socket::INET.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This example prints tha mail domain name of tha \s-1SMTP\s0 server known as mailhost:
.PP
.Vb 1
\&    #!/usr/local/bin/perl \-w
\&
\&    use Net::SMTP;
\&
\&    $smtp = Net::SMTP\->new(\*(Aqmailhost\*(Aq);
\&    print $smtp\->domain,"\en";
\&    $smtp\->quit;
.Ve
.PP
This example sendz a lil' small-ass message ta tha postmasta all up in tha \s-1SMTP\s0 server
known as mailhost:
.PP
.Vb 1
\&    #!/usr/local/bin/perl \-w
\&
\&    use Net::SMTP;
\&
\&    $smtp = Net::SMTP\->new(\*(Aqmailhost\*(Aq);
\&
\&    $smtp\->mail($ENV{USER});
\&    $smtp\->to(\*(Aqpostmaster\*(Aq);
\&
\&    $smtp\->data();
\&    $smtp\->datasend("To: postmaster\en");
\&    $smtp\->datasend("\en");
\&    $smtp\->datasend("A simple test message\en");
\&    $smtp\->dataend();
\&
\&    $smtp\->quit;
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "new ( [ \s-1HOST \s0] [, \s-1OPTIONS \s0] )" 4
.IX Item "new ( [ HOST ] [, OPTIONS ] )"
This is tha constructor fo' a freshly smoked up Net::SMTP object. \f(CW\*(C`HOST\*(C'\fR is the
name of tha remote host ta which a \s-1SMTP\s0 connection is required.
.Sp
\&\f(CW\*(C`HOST\*(C'\fR is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If \f(CW\*(C`HOST\*(C'\fR aint given then it may instead be
passed as tha \f(CW\*(C`Host\*(C'\fR option busted lyrics bout below. If neither is given then
the \f(CW\*(C`SMTP_Hosts\*(C'\fR specified up in \f(CW\*(C`Net::Config\*(C'\fR is ghon be used.
.Sp
\&\f(CW\*(C`OPTIONS\*(C'\fR is passed up in a hash like fashion, rockin key n' value pairs.
Possible options are:
.Sp
\&\fBHello\fR \- \s-1SMTP\s0 requires dat you identify yo ass. This option
specifies a strang ta pass as yo' mail domain. I aint talkin' bout chicken n' gravy biatch. If not given localhost.localdomain
will be used.
.Sp
\&\fBHost\fR \- \s-1SMTP\s0 host ta connect to. Well shiiiit, it may be a single scalar, as defined for
the \f(CW\*(C`PeerAddr\*(C'\fR option up in IO::Socket::INET, or a reference to
an array wit hosts ta try up in turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da \*(L"host\*(R" method will return tha value
which was used ta connect ta tha host.
.Sp
\&\fBLocalAddr\fR n' \fBLocalPort\fR \- These parametas is passed directly
to IO::Socket ta allow bindin tha socket ta a local port.
.Sp
\&\fBTimeout\fR \- Maximum time, up in seconds, ta wait fo' a response from the
\&\s-1SMTP\s0 server (default: 120)
.Sp
\&\fBExactAddresses\fR \- If legit tha all \s-1ADDRESS\s0 arguments must be as
defined by \f(CW\*(C`addr\-spec\*(C'\fR up in \s-1RFC2822.\s0 If not given, or false, then
Net::SMTP will attempt ta extract tha address from tha value passed.
.Sp
\&\fBDebug\fR \- Enable debuggin shiznit
.Sp
Example:
.Sp
.Vb 5
\&    $smtp = Net::SMTP\->new(\*(Aqmailhost\*(Aq,
\&                           Wuz crackalackin' => \*(Aqmy.mail.domain\*(Aq,
\&                           Timeout => 30,
\&                           Debug   => 1,
\&                          );
\&
\&    # tha same
\&    $smtp = Net::SMTP\->new(
\&                           Host => \*(Aqmailhost\*(Aq,
\&                           Wuz crackalackin' => \*(Aqmy.mail.domain\*(Aq,
\&                           Timeout => 30,
\&                           Debug   => 1,
\&                          );
\&
\&    # Connect ta tha default server from Net::config
\&    $smtp = Net::SMTP\->new(
\&                           Wuz crackalackin' => \*(Aqmy.mail.domain\*(Aq,
\&                           Timeout => 30,
\&                          );
.Ve
.SH "METHODS"
.IX Header "METHODS"
Unless otherwise stated all methodz return either a \fItrue\fR or \fIfalse\fR
value, wit \fItrue\fR meanin dat tha operation was a success. When a method
states dat it returns a value, failure is ghon be returned as \fIundef\fR or an
empty list.
.IP "banner ()" 4
.IX Item "banner ()"
Returns tha banner message which tha server replied wit when the
initial connection was made.
.IP "domain ()" 4
.IX Item "domain ()"
Returns tha domain dat tha remote \s-1SMTP\s0 server identified itself as during
connection.
.IP "wassup ( \s-1DOMAIN \s0)" 4
.IX Item "wassup ( DOMAIN )"
Tell tha remote server tha mail domain which yo ass is up in rockin tha \s-1EHLO\s0
command (or \s-1HELO\s0 if \s-1EHLO\s0 fails).  Since dis method is invoked
automatically when tha Net::SMTP object is constructed tha user should
normally not gotta call it manually.
.IP "host ()" 4
.IX Item "host ()"
Returns tha value used by tha constructor, n' passed ta IO::Socket::INET,
to connect ta tha host.
.IP "etrn ( \s-1DOMAIN \s0)" 4
.IX Item "etrn ( DOMAIN )"
Request a queue run fo' tha \s-1DOMAIN\s0 given.
.IP "auth ( \s-1USERNAME, PASSWORD \s0)" 4
.IX Item "auth ( USERNAME, PASSWORD )"
Attempt \s-1SASL\s0 authentication.
.IP "mail ( \s-1ADDRESS\s0 [, \s-1OPTIONS\s0] )" 4
.IX Item "mail ( ADDRESS [, OPTIONS] )"
.PD 0
.IP "send ( \s-1ADDRESS \s0)" 4
.IX Item "send ( ADDRESS )"
.IP "send_or_mail ( \s-1ADDRESS \s0)" 4
.IX Item "send_or_mail ( ADDRESS )"
.IP "send_and_mail ( \s-1ADDRESS \s0)" 4
.IX Item "send_and_mail ( ADDRESS )"
.PD
Send tha appropriate command ta tha server \s-1MAIL, SEND, SOML\s0 or \s-1SAML. \s0\f(CW\*(C`ADDRESS\*(C'\fR
is tha address of tha sender n' shit. This initiates tha bustin  of a message. The
method \f(CW\*(C`recipient\*(C'\fR should be called fo' each address dat tha message is to
be busted to.
.Sp
Da \f(CW\*(C`mail\*(C'\fR method can some additionizzle \s-1ESMTP OPTIONS\s0 which is passed
in hash like fashion, rockin key n' value pairs.  Possible options are:
.Sp
.Vb 8
\& Size        => <bytes>
\& Return      => "FULL" | "HDRS"
\& Bits        => "7" | "8" | "binary"
\& Transaction => <ADDRESS>
\& Envelope    => <ENVID>     # xtext\-encodes its argument
\& ENVID       => <ENVID>     # similar ta Envelope yo, but expects argument encoded
\& XVERP       => 1
\& AUTH        => <submitter> # encoded address accordin ta RFC 2554
.Ve
.Sp
Da \f(CW\*(C`Return\*(C'\fR n' \f(CW\*(C`Envelope\*(C'\fR parametas is used fo' \s-1DSN \s0(Delivery
Status Notification).
.Sp
Da submitta address up in \f(CW\*(C`AUTH\*(C'\fR option is sposed ta fuckin be up in a gangbangin' format as
required by \s-1RFC 2554,\s0 up in a RFC2821\-quoted form n' xtext-encoded, or <> .
.IP "reset ()" 4
.IX Item "reset ()"
Reset tha statuz of tha server n' shit. This may be called afta a message has been 
initiated yo, but before any data has been sent, ta quit tha bustin  of the
message.
.IP "recipient ( \s-1ADDRESS\s0 [, \s-1ADDRESS,\s0 [...]] [, \s-1OPTIONS \s0] )" 4
.IX Item "recipient ( ADDRESS [, ADDRESS, [...]] [, OPTIONS ] )"
Notify tha server dat tha current message should be busted ta all of the
addresses given. I aint talkin' bout chicken n' gravy biatch. Each address is busted as a separate command ta tha server.
Should tha bustin  of any address result up in a gangbangin' failure then tha process is
aborted n' a \fIfalse\fR value is returned. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is up ta tha user ta call
\&\f(CW\*(C`reset\*(C'\fR if they so desire.
.Sp
Da \f(CW\*(C`recipient\*(C'\fR method can also pass additionizzle case-sensitizzle \s-1OPTIONS\s0 as an
anonymous hash rockin key n' value pairs.  Possible options are:
.Sp
.Vb 3
\&  Notify  => [\*(AqNEVER\*(Aq] or [\*(AqSUCCESS\*(Aq,\*(AqFAILURE\*(Aq,\*(AqDELAY\*(Aq]  (see below)
\&  ORcpt   => <ORCPT>
\&  SkipWack => 1        (to ignore wack addresses)
.Ve
.Sp
If \f(CW\*(C`SkipBad\*(C'\fR is legit tha \f(CW\*(C`recipient\*(C'\fR aint gonna return a error when a funky-ass bad
address is encountered n' it will return a array of addresses dat did
succeed.
.Sp
.Vb 5
\&  $smtp\->recipient($recipient1,$recipient2);  # Good
\&  $smtp\->recipient($recipient1,$recipient2, { SkipWack => 1 });  # Good
\&  $smtp\->recipient($recipient1,$recipient2, { Notify => [\*(AqFAILURE\*(Aq,\*(AqDELAY\*(Aq], SkipWack => 1 });  # Good
\&  @goodrecips=$smtp\->recipient(@recipients, { Notify => [\*(AqFAILURE\*(Aq], SkipWack => 1 });  # Good
\&  $smtp\->recipient("$recipient,$recipient2"); # BAD
.Ve
.Sp
Notify is used ta request Delivery Status Notifications (DSNs) yo, but your
\&\s-1SMTP/ESMTP\s0 steez may not respect dis request dependin upon its version and
your cribz \s-1SMTP\s0 configuration.
.Sp
Leavin up tha Notify option probably defaults a \s-1SMTP\s0 steez ta its default
behavior equivalent ta ['\s-1FAILURE\s0'] notifications only yo, but again n' again n' again dis may be
dependent upon yo' cribz \s-1SMTP\s0 configuration.
.Sp
Da \s-1NEVER\s0 keyword must step tha fuck up by itself if used within tha Notify option n' \*(L"requests
that a \s-1DSN\s0 not be moonwalked back ta tha sender under any conditions.\*(R"
.Sp
.Vb 1
\&  {Notify => [\*(AqNEVER\*(Aq]}
\&
\&  $smtp\->recipient(@recipients, { Notify => [\*(AqNEVER\*(Aq], SkipWack => 1 });  # Good
.Ve
.Sp
Yo ass may use any combination of these three joints '\s-1SUCCESS\s0','\s-1FAILURE\s0','\s-1DELAY\s0' in
the anonymous array reference as defined by \s-1RFC3461 \s0(see http://rfc.net/rfc3461.html
for mo' shiznit. I aint talkin' bout chicken n' gravy biatch.  Note: quotations up in dis topic from same.).
.Sp
A Notify parameta of '\s-1SUCCESS\s0' or '\s-1FAILURE\s0' \*(L"requests dat a \s-1DSN\s0 be issued on
successful delivery or delivery failure, respectively.\*(R"
.Sp
A Notify parameta of '\s-1DELAY\s0' \*(L"indicates tha senderz willingnizz ta receive
delayed DSNs.  Delayed DSNs may be issued if delivery of a message has been
delayed fo' a unusual amount of time (as determined by tha Message Transfer
Agent (\s-1MTA\s0) at which tha message is delayed) yo, but tha final delivery status
(whether successful or failure) cannot be determined. Y'all KNOW dat shit, muthafucka!  Da absence of tha \s-1DELAY\s0
keyword up in a \s-1NOTIFY\s0 parameta requests dat a \*(R"delayed\*(L" \s-1DSN NOT\s0 be issued under
any conditions.\*(R"
.Sp
.Vb 1
\&  {Notify => [\*(AqSUCCESS\*(Aq,\*(AqFAILURE\*(Aq,\*(AqDELAY\*(Aq]}
\&
\&  $smtp\->recipient(@recipients, { Notify => [\*(AqFAILURE\*(Aq,\*(AqDELAY\*(Aq], SkipWack => 1 });  # Good
.Ve
.Sp
ORcpt be also part of tha \s-1SMTP DSN\s0 extension accordin ta \s-1RFC3461.\s0
It be used ta pass along tha original gangsta recipient dat tha mail was first
sent to.  Da machine dat generates a \s-1DSN\s0 will use dis address ta inform
the sender, cuz his schmoooove ass can't know if recipients git rewritten by mail servers.
It be sposed ta fuckin be up in a gangbangin' format as required by \s-1RFC3461,\s0 xtext-encoded.
.IP "to ( \s-1ADDRESS\s0 [, \s-1ADDRESS\s0 [...]] )" 4
.IX Item "to ( ADDRESS [, ADDRESS [...]] )"
.PD 0
.IP "cc ( \s-1ADDRESS\s0 [, \s-1ADDRESS\s0 [...]] )" 4
.IX Item "cc ( ADDRESS [, ADDRESS [...]] )"
.IP "bcc ( \s-1ADDRESS\s0 [, \s-1ADDRESS\s0 [...]] )" 4
.IX Item "bcc ( ADDRESS [, ADDRESS [...]] )"
.PD
Synonyms fo' \f(CW\*(C`recipient\*(C'\fR.
.IP "data ( [ \s-1DATA \s0] )" 4
.IX Item "data ( [ DATA ] )"
Initiate tha bustin  of tha data from tha current message.
.Sp
\&\f(CW\*(C`DATA\*(C'\fR may be a reference ta a list or a list. If specified tha contents
of \f(CW\*(C`DATA\*(C'\fR n' a termination strang \f(CW".\er\en"\fR is busted ta tha server n' shiznit fo' realz. And the
result is ghon be legit if tha data was accepted.
.Sp
If \f(CW\*(C`DATA\*(C'\fR aint specified then tha result will indicate dat tha server
wishes tha data ta be sent. Da data must then be busted rockin tha \f(CW\*(C`datasend\*(C'\fR
and \f(CW\*(C`dataend\*(C'\fR methodz busted lyrics bout up in Net::Cmd.
.IP "expand ( \s-1ADDRESS \s0)" 4
.IX Item "expand ( ADDRESS )"
Request tha server ta expand tha given address Returns a array
which gotz nuff tha text read from tha server.
.IP "verify ( \s-1ADDRESS \s0)" 4
.IX Item "verify ( ADDRESS )"
Verify dat \f(CW\*(C`ADDRESS\*(C'\fR be a legitimate mailin address.
.Sp
Most cribs probably disable dis feature up in they \s-1SMTP\s0 steez configuration.
Use \*(L"Debug => 1\*(R" option under \fInew()\fR ta peep if disabled.
.ie n .IP "help ( [ $subject ] )" 4
.el .IP "help ( [ \f(CW$subject\fR ] )" 4
.IX Item "help ( [ $subject ] )"
Request help text from tha server n' shit. Returns tha text or undef upon failure
.IP "quit ()" 4
.IX Item "quit ()"
Send tha \s-1QUIT\s0 command ta tha remote \s-1SMTP\s0 server n' close tha socket connection.
.SH "ADDRESSES"
.IX Header "ADDRESSES"
Net::SMTP attempts ta \s-1DWIM\s0 wit addresses dat is passed. Y'all KNOW dat shit, muthafucka! For
example a application might extract Da From: line from a email
and pass dat ta \fImail()\fR. While dis may work, it aint recommended.
Da application should straight-up bust a module like Mail::Address
to extract tha mail address n' pass dis shit.
.PP
If \f(CW\*(C`ExactAddresses\*(C'\fR is passed ta tha constructor, then addresses
should be a valid rfc2821\-quoted address, although Net::SMTP will
accept accept tha address surrounded by angle brackets.
.PP
.Vb 3
\& funky user@domain      WRONG
\& "funny user"@domain    RIGHT, recommended
\& <"funny user"@domain>  OK
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::Cmd
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@pobox.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1995\-2004 Graham Barr fo' realz. All muthafuckin rights reserved.
This program is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
