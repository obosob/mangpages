.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "integer 3pm"
.TH integer 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
integer \- Perl pragma ta use integer arithmetic instead of floatin point
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use integer;
\&    $x = 10/3;
\&    # $x is now 3, not 3.33333333333333333
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This  drops some lyrics ta tha compila ta use integer operations from here ta tha end
of tha enclosin \s-1BLOCK. \s0 On nuff machines, dis don't matta a pimped out
deal fo' most computations yo, but on dem without floatin point
hardware, it can cook up a funky-ass big-ass difference up in performance.
.PP
Note dat dis only affects how tha fuck most of tha arithmetic n' relational
\&\fBoperators\fR handle they operandz n' thangs up in dis biatch, n' \fBnot\fR how tha fuck all
numbers everywhere is treated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Specifically, \f(CW\*(C`use integer;\*(C'\fR has the
effect dat before computin tha thangs up in dis biatch of tha arithmetic operators
(+, \-, *, /, %, +=, \-=, *=, /=, %=, n' unary minus), tha comparison
operators (<, <=, >, >=, ==, !=, <=>), n' tha bitwise operators (|, &,
^, <<, >>, |=, &=, ^=, <<=, >>=), tha operandz have they fractional
portions truncated (or floored), n' tha result gonna git its
fractionizzle portion truncated as well.  In addition, tha range of
operandz n' thangs up in dis biatch is restricted ta dat of familiar twoz complement
integers, i.e., \-(2**31) .. (2**31\-1) on 32\-bit architectures, and
\&\-(2**63) .. (2**63\-1) on 64\-bit architectures.  For example, dis code
.PP
.Vb 7
\&    use integer;
\&    $x = 5.8;
\&    $y = 2.5;
\&    $z = 2.7;
\&    $a = 2**31 \- 1;  # Largest positizzle integer on 32\-bit machines
\&    $, = ", ";
\&    print $x, \-$x, $x + $y, $x \- $y, $x / $y, $x * $y, $y == $z, $a, $a + 1;
.Ve
.PP
will print:  5.8, \-5, 7, 3, 2, 10, 1, 2147483647, \-2147483648
.PP
Note dat \f(CW$x\fR is still printed as havin its legit non-integer value of
5.8 since it wasn't operated on. I aint talkin' bout chicken n' gravy biatch.  And note too tha wrap-around from the
largest positizzle integer ta tha phattest wack one.   Also, arguments
passed ta functions n' tha joints returned by dem is \fBnot\fR affected
by \f(CW\*(C`use integer;\*(C'\fR.  E.g.,
.PP
.Vb 3
\&    srand(1.5);
\&    $, = ", ";
\&    print sin(.5), cos(.5), atan2(1,2), sqrt(2), rand(10);
.Ve
.PP
will give tha same result wit or without \f(CW\*(C`use integer;\*(C'\fR  Da power
operator \f(CW\*(C`**\*(C'\fR be also not affected, so dat 2 ** .5 be always the
square root of 2.  Now, it so happens dat tha pre\- n' post\- increment
and decrement operators, ++ n' \-\-, is not affected by \f(CW\*(C`use integer;\*(C'\fR
either n' shit.  Some may rightly consider dis ta be a funky-ass bug \*(-- but at least it's
a long-standin one.
.PP
Finally, \f(CW\*(C`use integer;\*(C'\fR also has a additionizzle affect on tha bitwise
operators.  Normally, tha operandz n' thangs up in dis biatch is treated as
\&\fBunsigned\fR integers yo, but wit \f(CW\*(C`use integer;\*(C'\fR tha operandz n' thangs up in dis biatch
are \fBsigned\fR.  This means, among other thangs, dat ~0 is \-1, n' \-2 &
\&\-5 is \-6.
.PP
Internally, natizzle integer arithmetic (as provided by yo' C compiler)
is used. Y'all KNOW dat shit, muthafucka!  This means dat Perlz own semantics fo' arithmetic
operations may not be preserved. Y'all KNOW dat shit, muthafucka!  One common source of shiznit is the
moduluz of wack numbers, which Perl do one way yo, but yo' hardware
may do another.
.PP
.Vb 4
\&    % perl \-le \*(Aqprint (4 % \-3)\*(Aq
\&    \-2
\&    % perl \-Minteger \-le \*(Aqprint (4 % \-3)\*(Aq
\&    1
.Ve
.PP
See \*(L"Pragmatic Modules\*(R" up in perlmodlib, \*(L"Integer Arithmetic\*(R" up in perlop
