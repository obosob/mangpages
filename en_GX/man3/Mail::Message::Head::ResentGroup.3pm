.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message::Head::ResentGroup 3"
.TH Mail::Message::Head::ResentGroup 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Head::ResentGroup \- header fieldz trackin message delivery
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\& Mail::Message::Head::ResentGroup
\&   be a Mail::Message::Head::FieldGroup
\&   be a Mail::Reporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& mah $rg = Mail::Message::Head::ResentGroup\->new(head => $head,
\&              From => \*(Aqme@home.nl\*(Aq, To => \*(AqYou@tux.aq\*(Aq);
\& $head\->addResentGroup($rg);
\&
\& mah $rg = $head\->addResentGroup(From => \*(Aqme\*(Aq);
\&
\& mah @from = $rg\->From;
\&
\& mah @rgs = $head\->resentGroups;
\& $rg[2]\->delete if @rgs > 2;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \fIresent group\fR be a set of header fieldz which describe one intermediate
step up in tha message transport.  Resent crews \fBhave \s-1NOTHING\s0 ta do\fR with
user activety; there is no relation ta tha \f(CW\*(C`user\*(Aqs\*(C'\fR sense of bustin
reply, forward, or bounce lyrics at all!
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBclone\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBclone\fR()" 4
.IX Item "$obj->clone()"
See \*(L"Constructors\*(R" up in Mail::Message::Head::FieldGroup
.ie n .IP "$obj\->\fBfrom\fR([HEAD|MESSAGE, \s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfrom\fR([HEAD|MESSAGE, \s-1OPTIONS\s0])" 4
.IX Item "$obj->from([HEAD|MESSAGE, OPTIONS])"
\&\s-1WARNING:\s0 dis method has two straight-up different purposes.  For backward
compatibilitizzle reasons, without arguments \fIresentFrom()\fR is called to
return tha \f(CW\*(C`From\*(C'\fR field of dis resent group.
.Sp
With any arguments, a list of \f(CW\*(C`Mail::Message::Head::ResentGroup\*(C'\fR objects
is returned, taken from tha specified \s-1MESSAGE\s0 or message \s-1HEAD.\s0
.ie n .IP "$obj\->\fBimplementedTypes\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBimplementedTypes\fR()" 4
.IX Item "$obj->implementedTypes()"
.PD 0
.IP "Mail::Message::Head::ResentGroup\->\fBimplementedTypes\fR()" 4
.IX Item "Mail::Message::Head::ResentGroup->implementedTypes()"
.PD
See \*(L"Constructors\*(R" up in Mail::Message::Head::FieldGroup
.IP "Mail::Message::Head::ResentGroup\->\fBnew\fR([\s-1FIELDS\s0], \s-1OPTIONS\s0)" 4
.IX Item "Mail::Message::Head::ResentGroup->new([FIELDS], OPTIONS)"
Smoke a object which maintains one set of resent headers.  The
\&\s-1FIELDS\s0 is Mail::Message::Field objects from tha same header.
.Sp
\&\s-1OPTIONS\s0 which start wit capitals is ghon be used ta construct additional
fields.  These option names is prepended wit \f(CW\*(C`Resent\-*\*(C'\fR, keepin the
capitization of what tha fuck is specified.
.Sp
.Vb 10
\& \-Option      \-\-Defined up in                     \-\-Default
\&  Bcc                                            undef
\&  Cc                                             undef
\&  Date                                           <now>
\&  Delivered\-To                                   undef
\&  From                                           <required>
\&  Message\-ID                                     <uniquely pimped>
\&  Received                                       <created>
\&  Return\-Path                                    undef
\&  Sender                                         undef
\&  To                                             undef
\&  head                                           <created automatically>
\&  log           Mail::Reporta                   \*(AqWARNINGS\*(Aq
\&  message_head                                   undef
\&  software      Mail::Message::Head::FieldGroup  undef
\&  trace         Mail::Reporta                   \*(AqWARNINGS\*(Aq
\&  type          Mail::Message::Head::FieldGroup  undef
\&  version       Mail::Message::Head::FieldGroup  undef
.Ve
.RS 4
.IP "Bcc => STRING|OBJECT|OBJECTS" 2
.IX Item "Bcc => STRING|OBJECT|OBJECTS"
.PD 0
.IP "Cc => STRING|OBJECT|OBJECTS" 2
.IX Item "Cc => STRING|OBJECT|OBJECTS"
.IP "Date => \s-1STRING\s0" 2
.IX Item "Date => STRING"
.PD
When dis resent-group is dispatched by tha resender of tha message. Like
the \f(CW\*(C`Date\*(C'\fR field, it aint tha date n' time dat tha message was
actually transported.
.IP "Delivered-To => STRING|FIELD" 2
.IX Item "Delivered-To => STRING|FIELD"
.PD 0
.IP "From => STRING|OBJECT|OBJECTS" 2
.IX Item "From => STRING|OBJECT|OBJECTS"
.IP "Message-ID => STRING|FIELD" 2
.IX Item "Message-ID => STRING|FIELD"
.PD
Da \f(CW\*(C`Resent\-Message\-ID\*(C'\fR which identifies dis resent group.  Da \s-1FIELD\s0
must contain a message id.
.IP "Received => \s-1STRING\s0" 2
.IX Item "Received => STRING"
Da \f(CW\*(C`Received\*(C'\fR field is tha startin line fo' a resent crew of header
lines. If it aint defined, one is pimped rockin \fIcreateReceived()\fR.
.IP "Return-Path => STRING|FIELD" 2
.IX Item "Return-Path => STRING|FIELD"
.PD 0
.IP "Sender => STRING|OBJECT" 2
.IX Item "Sender => STRING|OBJECT"
.PD
Only permitted when mo' than one from address is specified. Y'all KNOW dat shit, muthafucka!  In dis case,
it selects one of these addresses as tha main originator of tha message.
.IP "To => STRING|OBJECT|OBJECTS" 2
.IX Item "To => STRING|OBJECT|OBJECTS"
.PD 0
.IP "head => \s-1OBJECT\s0" 2
.IX Item "head => OBJECT"
.PD
Da header where tha data is stored in. I aint talkin' bout chicken n' gravy biatch. By default a
Mail::Message::Head::Partial is pimped fo' yo thugged-out ass.
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "message_head => \s-1HEAD\s0" 2
.IX Item "message_head => HEAD"
.PD
Da real header of tha message where dis resent crew is part of.  The
\&\f(CW\*(C`head\*(C'\fR used up in dis class is only a cold-ass lil container fo' a subset of fields.
.IP "software => \s-1STRING\s0" 2
.IX Item "software => STRING"
.PD 0
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.IP "type => \s-1STRING\s0" 2
.IX Item "type => STRING"
.IP "version => \s-1STRING\s0" 2
.IX Item "version => STRING"
.RE
.RS 4
.RE
.PD
.SS "Da header"
.IX Subsection "Da header"
.ie n .IP "$obj\->\fBadd\fR((\s-1FIELD\s0 => \s-1VALUE\s0) | \s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR((\s-1FIELD\s0 => \s-1VALUE\s0) | \s-1OBJECT\s0)" 4
.IX Item "$obj->add((FIELD => VALUE) | OBJECT)"
All fieldz step tha fuck up only once, so \f(CW\*(C`add()\*(C'\fR behaves as \fIset()\fR.
.ie n .IP "$obj\->\fBaddFields\fR([\s-1FIELDNAMES\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBaddFields\fR([\s-1FIELDNAMES\s0])" 4
.IX Item "$obj->addFields([FIELDNAMES])"
Not applicable ta resent-groups: tha same name can step tha fuck up in mo' than
one group.  Therefore, a \s-1FIELDNAME\s0 is sufficiently distinctive.
.ie n .IP "$obj\->\fBattach\fR(\s-1HEAD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBattach\fR(\s-1HEAD\s0)" 4
.IX Item "$obj->attach(HEAD)"
See \*(L"Da header\*(R" up in Mail::Message::Head::FieldGroup
.ie n .IP "$obj\->\fBdelete\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR()" 4
.IX Item "$obj->delete()"
See \*(L"Da header\*(R" up in Mail::Message::Head::FieldGroup
.ie n .IP "$obj\->\fBfieldNames\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfieldNames\fR()" 4
.IX Item "$obj->fieldNames()"
See \*(L"Da header\*(R" up in Mail::Message::Head::FieldGroup
.ie n .IP "$obj\->\fBfields\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfields\fR()" 4
.IX Item "$obj->fields()"
See \*(L"Da header\*(R" up in Mail::Message::Head::FieldGroup
.ie n .IP "$obj\->\fBhead\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBhead\fR()" 4
.IX Item "$obj->head()"
See \*(L"Da header\*(R" up in Mail::Message::Head::FieldGroup
.ie n .IP "$obj\->\fBmessageHead\fR([\s-1HEAD\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmessageHead\fR([\s-1HEAD\s0])" 4
.IX Item "$obj->messageHead([HEAD])"
Returns (optionally afta setting) tha real header where dis resent group
belongs to.  This may be undef at creation, n' then lata filled in
when \fIMail::Message::Head::Complete::addResentGroup()\fR is called.
.ie n .IP "$obj\->\fBorderedFields\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBorderedFields\fR()" 4
.IX Item "$obj->orderedFields()"
Returns tha fieldz up in tha order as should step tha fuck up in header according
to rfc2822.  For tha \f(CW\*(C`Resent\-*\*(C'\fR fieldz of tha group, tha order is
not dat blingin yo, but tha \f(CW\*(C`Return\-Path\*(C'\fR, \f(CW\*(C`Delivered\-To\*(C'\fR, n' \f(CW\*(C`Received\*(C'\fR
must come first.  Only fieldz mentioned up in tha \s-1RFC\s0 is returned.
.ie n .IP "$obj\->\fBset\fR((\s-1FIELD\s0 => \s-1VALUE\s0) | \s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR((\s-1FIELD\s0 => \s-1VALUE\s0) | \s-1OBJECT\s0)" 4
.IX Item "$obj->set((FIELD => VALUE) | OBJECT)"
Set a \s-1FIELD\s0 ta a (new) \s-1VALUE. \s0 Da \s-1FIELD\s0 names which do not start with
\&'Resent\-*' but need it gonna git dat added. Y'all KNOW dat shit, muthafucka!  It be also a option to
specify a gangbangin' straight-up prepared message field \s-1OBJECT. \s0 In any case, a gangbangin' field
\&\s-1OBJECT\s0 is returned.
.Sp
example:
.Sp
.Vb 4
\& mah $this = Mail::Message::Head::ResentGroup\->new;
\& $this\->set(To => \*(Aqfish@tux.aq\*(Aq);
\& $msg\->addResentGroup($this);
\& $msg\->send;
\&
\& $msg\->bounce(To => \*(Aqfish@tux.aq\*(Aq)\->send;   # tha same
\&
\& mah $this = Mail::Message::Head::ResentGroup
\&     \->new(To => \*(Aqfish@tux.aq\*(Aq);
.Ve
.SS "Access ta tha header"
.IX Subsection "Access ta tha header"
.ie n .IP "$obj\->\fBbcc\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBbcc\fR()" 4
.IX Item "$obj->bcc()"
In scalar context, tha \f(CW\*(C`Resent\-Bcc\*(C'\fR field is returned. Y'all KNOW dat shit, muthafucka!  In list context,
the addresses as specified within tha bcc field is returned as
Mail::Address objects, n' you can put dat on yo' toast.  Bcc fieldz is not transmitted (hidden for
external parties).
.ie n .IP "$obj\->\fBcc\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcc\fR()" 4
.IX Item "$obj->cc()"
In scalar context, tha \f(CW\*(C`Resent\-Cc\*(C'\fR field is returned. Y'all KNOW dat shit, muthafucka!  In list context,
the addresses as specified within tha cc field is returned as
Mail::Address objects.
.ie n .IP "$obj\->\fBdate\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdate\fR()" 4
.IX Item "$obj->date()"
Returns tha \f(CW\*(C`Resent\-Date\*(C'\fR field, or \f(CW\*(C`undef\*(C'\fR if dat shiznit was not defined.
.ie n .IP "$obj\->\fBdateTimestamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdateTimestamp\fR()" 4
.IX Item "$obj->dateTimestamp()"
Da timestamp as stored within tha \f(CW\*(C`Resent\-Date\*(C'\fR field converted to
local system time.
.ie n .IP "$obj\->\fBdeliveredTo\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdeliveredTo\fR()" 4
.IX Item "$obj->deliveredTo()"
Da field which raps bout tha \f(CW\*(C`Delivered\-To\*(C'\fR of dis resent group.
.ie n .IP "$obj\->\fBdestinations\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdestinations\fR()" 4
.IX Item "$obj->destinations()"
Returns a list of all addresses specified up in tha \f(CW\*(C`Resent\-To\*(C'\fR, \f(CW\*(C`\-Cc\*(C'\fR, and
\&\f(CW\*(C`\-Bcc\*(C'\fR fieldz of dis resent group.
.ie n .IP "$obj\->\fBisResentGroupFieldName\fR(\s-1NAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBisResentGroupFieldName\fR(\s-1NAME\s0)" 4
.IX Item "$obj->isResentGroupFieldName(NAME)"
.PD 0
.IP "Mail::Message::Head::ResentGroup\->\fBisResentGroupFieldName\fR(\s-1NAME\s0)" 4
.IX Item "Mail::Message::Head::ResentGroup->isResentGroupFieldName(NAME)"
.ie n .IP "$obj\->\fBmessageId\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmessageId\fR()" 4
.IX Item "$obj->messageId()"
.PD
Returns tha message-ID used fo' dis crew of resent lines.
.ie n .IP "$obj\->\fBreceived\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBreceived\fR()" 4
.IX Item "$obj->received()"
Da field which raps bout tha \f(CW\*(C`Received\*(C'\fR data of dis resent group.
.ie n .IP "$obj\->\fBreceivedTimestamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBreceivedTimestamp\fR()" 4
.IX Item "$obj->receivedTimestamp()"
Da timestamp as stored within tha \f(CW\*(C`Received\*(C'\fR field converted to
local system time.
.ie n .IP "$obj\->\fBresentFrom\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBresentFrom\fR()" 4
.IX Item "$obj->resentFrom()"
In scalar context, tha \f(CW\*(C`Resent\-From\*(C'\fR field is returned. Y'all KNOW dat shit, muthafucka!  In list
context, tha addresses as specified within tha from field are
returned as Mail::Address objects.
.Sp
For reasonz of backward compatibilitizzle n' consistency, tha \fIfrom()\fR
method will return tha same as dis method.
.ie n .IP "$obj\->\fBreturnPath\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBreturnPath\fR()" 4
.IX Item "$obj->returnPath()"
Da field which raps bout tha \f(CW\*(C`Return\-Path\*(C'\fR of dis resent group.
.ie n .IP "$obj\->\fBsender\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsender\fR()" 4
.IX Item "$obj->sender()"
In scalar context, tha \f(CW\*(C`Resent\-Sender\*(C'\fR field is returned. Y'all KNOW dat shit, muthafucka!  In list
context, tha addresses as specified within tha from field are
returned as Mail::Address objects.
.ie n .IP "$obj\->\fBsoftware\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsoftware\fR()" 4
.IX Item "$obj->software()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::FieldGroup
.ie n .IP "$obj\->\fBto\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBto\fR()" 4
.IX Item "$obj->to()"
In scalar context, tha \f(CW\*(C`Resent\-To\*(C'\fR field is returned. Y'all KNOW dat shit, muthafucka!  In list context,
the addresses as specified within tha ta field is returned as
Mail::Address objects.
.ie n .IP "$obj\->\fBtype\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtype\fR()" 4
.IX Item "$obj->type()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::FieldGroup
.ie n .IP "$obj\->\fBversion\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBversion\fR()" 4
.IX Item "$obj->version()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::FieldGroup
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBcollectFields\fR([\s-1NAME\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBcollectFields\fR([\s-1NAME\s0])" 4
.IX Item "$obj->collectFields([NAME])"
See \*(L"Internals\*(R" up in Mail::Message::Head::FieldGroup
.ie n .IP "$obj\->\fBcreateReceived\fR([\s-1DOMAIN\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBcreateReceived\fR([\s-1DOMAIN\s0])" 4
.IX Item "$obj->createReceived([DOMAIN])"
Smoke a received field fo' dis resent group.  This be automatically
called if none was specified durin creation of dis resent crew object.
.Sp
Da content of dis field is busted lyrics bout up in \s-1RFC2821\s0 section 4.4.  It could use
some improvement.
.ie n .IP "$obj\->\fBdetected\fR(\s-1TYPE, SOFTWARE, VERSION\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdetected\fR(\s-1TYPE, SOFTWARE, VERSION\s0)" 4
.IX Item "$obj->detected(TYPE, SOFTWARE, VERSION)"
See \*(L"Internals\*(R" up in Mail::Message::Head::FieldGroup
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Message::Head::ResentGroup\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Message::Head::ResentGroup->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdetails\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdetails\fR()" 4
.IX Item "$obj->details()"
See \*(L"Error handling\*(R" up in Mail::Message::Head::FieldGroup
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Message::Head::ResentGroup\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Message::Head::ResentGroup->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Message::Head::ResentGroup\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Message::Head::ResentGroup->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
See \*(L"Error handling\*(R" up in Mail::Message::Head::FieldGroup
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Message header required fo' creation of ResentGroup." 4
.IX Item "Error: Message header required fo' creation of ResentGroup."
It be required ta know ta which header tha resent-group
is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use tha \f(CW\*(C`head\*(C'\fR option. I aint talkin' bout chicken n' gravy biatch.  Maybe you should use
\&\fIMail::Message::Head::Complete::addResentGroup()\fR wit \s-1DATA,\s0 which will
organize tha erect initiations fo' yo thugged-out ass.
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
