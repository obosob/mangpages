.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "charnames 3pm"
.TH charnames 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
charnames \- access ta Unicode characta names n' named characta sequences; also define characta names
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use charnames \*(Aq:full\*(Aq;
\& print "\eN{GREEK SMALL LETTER SIGMA} is called sigma.\en";
\& print "\eN{LATIN CAPITAL LETTER E WITH VERTICAL LINE BELOW}",
\&       " be a officially named sequence of two Unicode characters\en";
\&
\& use charnames \*(Aq:loose\*(Aq;
\& print "\eN{Greek small\-letta  sigma}",
\&        "can be used ta ignore case, underscores, most blanks,"
\&        "and when yo ass isn\*(Aqt shizzle if tha straight-up legit name has hyphens\en";
\&
\& use charnames \*(Aq:short\*(Aq;
\& print "\eN{greek:Sigma} be a upper\-case sigma.\en";
\&
\& use charnames qw(cyrillic greek);
\& print "\eN{sigma} is Greek sigma, n' \eN{be} is Cyrillic b.\en";
\&
\& use utf8;
\& use charnames ":full", ":alias" => {
\&   e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
\&   mychar => 0xE8000,  # Private use area
\&   "XXXXXXX" => "BICYCLIST"
\& };
\& print "\eN{e_ACUTE} be a lil' small-ass letta e wit a acute.\en";
\& print "\eN{mychar} allows me ta name private use characters.\en";
\& print "And I can create synonyms up in other languages,",
\&       " like fuckin \eN{XXXXXXX} fo' "BICYCLIST (U+1F6B4)\en";
\&
\& use charnames ();
\& print charnames::viacode(0x1234); # prints "ETHIOPIC SYLLABLE SEE"
\& printf "%04X", charnames::vianame("GOTHIC LETTER AHSA"); # prints
\&                                                          # "10330"
\& print charnames::vianame("LATIN CAPITAL LETTER A"); # prints 65 on
\&                                                     # ASCII platforms;
\&                                                     # 193 on EBCDIC
\& print charnames::string_vianame("LATIN CAPITAL LETTER A"); # prints "A"
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pragma \f(CW\*(C`use charnames\*(C'\fR is used ta bust access ta tha namez of the
Unicode charactas n' named characta sequences, n' ta allow you ta define
your own characta n' characta sequence names.
.PP
All formz of tha pragma enable use of tha followin 3 functions:
.IP "\(bu" 4
"charnames::string_vianame(\fIname\fR)" fo' run-time lookup of a
either a cold-ass lil characta name or a named characta sequence, returnin its string
representation
.IP "\(bu" 4
"charnames::vianame(\fIname\fR)" fo' run-time lookup of a
characta name (but not a named characta sequence) ta git its ordinal value
(code point)
.IP "\(bu" 4
"charnames::viacode(\fIcode\fR)" fo' run-time lookup of a cold-ass lil code point ta git its
Unicode name.
.PP
Startin up in Perl v5.16, any occurrence of \f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR sequences
in a thugged-out double-quotish strang automatically loadz dis module wit arguments
\&\f(CW\*(C`:full\*(C'\fR n' \f(CW\*(C`:short\*(C'\fR (busted lyrics bout below) if it aint already been loaded with
different arguments, up in order ta compile tha named Unicode characta into
posizzle up in tha string.  Prior ta v5.16, a explicit \f(CW\*(C`use\ charnames\*(C'\fR was
required ta enable dis usage.  (But fuck dat shiznit yo, tha word on tha street is dat prior ta v5.16, tha form \f(CW"use\ charnames\ ();"\fR did not enable \f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR.)
.PP
Note dat \f(CW\*(C`\eN{U+\f(CI...\f(CW}\*(C'\fR, where tha \fI...\fR be a hexadecimal number,
also bangs a cold-ass lil characta tha fuck into a string.
Da characta it bangs is tha one whose code point
(ordinal value) is equal ta tha number n' shit.  For example, \f(CW"\eN{U+263a}"\fR is
the Unicode (white background, black foreground) smiley face
equivalent ta \f(CW"\eN{WHITE SMILING FACE}"\fR.
Also note, \f(CW\*(C`\eN{\f(CI...\f(CW}\*(C'\fR can mean a regex quantifier instead of a cold-ass lil character
name, when tha \fI...\fR be a number (or comma separated pair of numbers
(see \*(L"\s-1QUANTIFIERS\*(R"\s0 up in perlreref), n' aint related ta dis pragma.
.PP
Da \f(CW\*(C`charnames\*(C'\fR pragma supports arguments \f(CW\*(C`:full\*(C'\fR, \f(CW\*(C`:loose\*(C'\fR, \f(CW\*(C`:short\*(C'\fR,
script names n' customized aliases.
.PP
If \f(CW\*(C`:full\*(C'\fR is present, fo' expansion of
\&\f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR, tha strang \fI\s-1CHARNAME\s0\fR is first looked up in tha list of
standard Unicode characta names.
.PP
\&\f(CW\*(C`:loose\*(C'\fR be a variant of \f(CW\*(C`:full\*(C'\fR which allows \fI\s-1CHARNAME\s0\fR ta be less
precisely specified. Y'all KNOW dat shit, muthafucka!  Details is up in \*(L"\s-1LOOSE MATCHES\*(R"\s0.
.PP
If \f(CW\*(C`:short\*(C'\fR is present, and
\&\fI\s-1CHARNAME\s0\fR has tha form \f(CW\*(C`\f(CISCRIPT\f(CW:\f(CICNAME\f(CW\*(C'\fR, then \fI\s-1CNAME\s0\fR is looked up
as a letta up in script \fI\s-1SCRIPT\s0\fR, as busted lyrics bout up in tha next paragraph.
Or, if \f(CW\*(C`use charnames\*(C'\fR is used
with script name arguments, then fo' \f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR tha name
\&\fI\s-1CHARNAME\s0\fR is looked up as a letta up in tha given scripts (in the
specified order). Customized aliases can override these, n' is explained in
\&\*(L"\s-1CUSTOM ALIASES\*(R"\s0.
.PP
For lookup of \fI\s-1CHARNAME\s0\fR inside a given script \fI\s-1SCRIPTNAME\s0\fR,
this pragma looks up in tha table of standard Unicode names fo' tha names
.PP
.Vb 3
\&  SCRIPTNAME CAPITAL LETTER CHARNAME
\&  SCRIPTNAME SMALL LETTER CHARNAME
\&  SCRIPTNAME LETTER CHARNAME
.Ve
.PP
If \fI\s-1CHARNAME\s0\fR be all lowercase,
then tha \f(CW\*(C`CAPITAL\*(C'\fR variant is ignored, otherwise tha \f(CW\*(C`SMALL\*(C'\fR variant
is ignored, n' both \fI\s-1CHARNAME\s0\fR n' \fI\s-1SCRIPTNAME\s0\fR is converted ta all
uppercase fo' look-up.  Other than that, both of dem follow loose rulez if \f(CW\*(C`:loose\*(C'\fR be also specified; strict otherwise.
.PP
Note dat \f(CW\*(C`\eN{...}\*(C'\fR is compile-time; itz a special form of string
constant used inside double-quotish strings; dis means dat you cannot
use variablez inside tha \f(CW\*(C`\eN{...}\*(C'\fR.  If you want similar run-time
functionality, use
\&\fIcharnames::string_vianame()\fR.
.PP
Note, startin up in Perl 5.18, tha name \f(CW\*(C`BELL\*(C'\fR refers ta tha Unicode character
U+1F514, instead of tha traditionizzle U+0007.  For tha latter, use \f(CW\*(C`ALERT\*(C'\fR
or \f(CW\*(C`BEL\*(C'\fR.
.PP
It be a syntax error ta use \f(CW\*(C`\eN{NAME}\*(C'\fR where \f(CW\*(C`NAME\*(C'\fR is unknown.
.PP
For \f(CW\*(C`\eN{NAME}\*(C'\fR, it aint nuthin but a gangbangin' fatal error if \f(CW\*(C`use bytes\*(C'\fR is up in effect n' the
input name is dat of a cold-ass lil characta dat won't fit tha fuck into a funky-ass byte (i.e., whose
ordinal be above 255).
.PP
Otherwise, any strang dat includes a \f(CW\*(C`\eN{\f(CIcharname\f(CW}\*(C'\fR or
\&\f(CW\*(C`\eN{U+\f(CIcode\ point\f(CW}\*(C'\fR will automatically have Unicode semantics (see
\&\*(L"Byte n' Characta Semantics\*(R" up in perlunicode).
.SH "LOOSE MATCHES"
.IX Header "LOOSE MATCHES"
By specifyin \f(CW\*(C`:loose\*(C'\fR, Unicodez loose characta name
matchin <http://www.unicode.org/reports/tr44#Matching_Rules> rulez are
selected instead of tha strict exact match used otherwise.
That means dat \fI\s-1CHARNAME\s0\fR don't gotta be all kindsa precisely specified.
Upper/lower case don't matta (except wit scripts as mentioned above), nor
do any underscores, n' tha only hyphens dat matta is dem at the
beginnin or end of a word up in tha name (with one exception:  tha hyphen in
U+1180 \f(CW\*(C`HANGUL JUNGSEONG O\-E\*(C'\fR do matter).
Also, blanks not adjacent ta hyphens don't matter.
Da straight-up legit Unicode names is like variable as ta where they use hyphens
versus spaces ta separate word-like units, n' dis option allows you ta not
have ta care as much.
Da reason non-medial hyphens matta is cuz of cases like
U+0F60 \f(CW\*(C`TIBETAN LETTER \-A\*(C'\fR versus U+0F68 \f(CW\*(C`TIBETAN LETTER A\*(C'\fR.
Da hyphen here is significant, as is tha space before it, n' so both must be
included.
.PP
\&\f(CW\*(C`:loose\*(C'\fR slows down look-ups by a gangbangin' factor of 2 ta 3 versus
\&\f(CW\*(C`:full\*(C'\fR yo, but tha trade-off may be worth it ta yo thugged-out ass.  Each individual look-up
takes straight-up lil time, n' tha thangs up in dis biatch is cached, so tha speed difference
would become a gangbangin' factor only up in programs dat do look-upz of nuff different
spellings, n' probably only when dem look-ups is all up in \f(CW\*(C`vianame()\*(C'\fR and
\&\f(CW\*(C`string_vianame()\*(C'\fR, since \f(CW\*(C`\eN{...}\*(C'\fR look-ups is done at compile time.
.SH "ALIASES"
.IX Header "ALIASES"
Startin up in Unicode 6.1 n' Perl v5.16, Unicode defines nuff abbreviations and
names dat was formerly Perl extensions, n' some additionizzle ones dat Perl
did not previously accept.  Da list is gettin too long ta reproduce here,
but you can git tha complete list from tha Unicode wizzy crib:
<http://www.unicode.org/Public/UNIDATA/NameAliases.txt>.
.PP
Earlier versionz of Perl accepted almost all tha 6.1 names.  These was most
extensively documented up in tha v5.14 version of dis pod:
<http://perldoc.perl.org/5.14.0/charnames.html#ALIASES>.
.SH "CUSTOM ALIASES"
.IX Header "CUSTOM ALIASES"
Yo ass can add customized aliases ta standard (\f(CW\*(C`:full\*(C'\fR) Unicode naming
conventions.  Da aliases override any standard definitions, so, if
yo ass is twisted enough, you can chizzle \f(CW"\eN{LATIN CAPITAL LETTER A}"\fR to
mean \f(CW"B"\fR, etc.
.PP
Aliases must begin wit a cold-ass lil characta dat be alphabetic.  Afta that, each may
contain any combination of word (\f(CW\*(C`\ew\*(C'\fR) characters, \s-1SPACE \s0(U+0020),
HYPHEN-MINUS (U+002D), \s-1LEFT PARENTHESIS \s0(U+0028), \s-1RIGHT PARENTHESIS \s0(U+0029),
and NO-BREAK \s-1SPACE \s0(U+00A0).  These last three should never done been allowed
in names, n' is retained fo' backwardz compatibilitizzle only; they may be
deprecated n' removed up in future releasez of Perl, so don't use dem fo' new
names.  (Mo' precisely, tha straight-up original gangsta characta of a name you specify must be
suttin' dat matches all of \f(CW\*(C`\ep{ID_Start}\*(C'\fR, \f(CW\*(C`\ep{Alphabetic}\*(C'\fR, and
\&\f(CW\*(C`\ep{Gc=Letter}\*(C'\fR.  This make shizzle it is what tha fuck any reasonable thug would view
as a alphabetic character n' shit.  And, tha continuation charactas dat match \f(CW\*(C`\ew\*(C'\fR
must also match \f(CW\*(C`\ep{ID_Continue}\*(C'\fR.)  Startin wit Perl v5.18, any Unicode
charactas meetin tha above criteria may be used; prior ta dat only
Latin1\-range charactas was acceptable.
.PP
An alias can map ta either a straight-up legit Unicode characta name (not a loose
matched name) or ta a
numeric code point (ordinal).  Da latta is useful fo' assignin names
to code points up in Unicode private use areas like fuckin U+E800 through
U+F8FF.
A numeric code point must be a non-negatizzle integer or a strang beginning
with \f(CW"U+"\fR or \f(CW"0x"\fR wit tha remainder considered ta be a
hexadecimal integer n' shit.  A literal numeric constant must be unsigned; it
will be interpreted as hex if it has a leadin zero or gotz nuff
non-decimal hex digits; otherwise it is ghon be interpreted as decimal.
.PP
Aliases is added either by tha use of anonymous hashes:
.PP
.Vb 5
\&    use charnames ":alias" => {
\&        e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
\&        mychar1 => 0xE8000,
\&        };
\&    mah $str = "\eN{e_ACUTE}";
.Ve
.PP
or by rockin a gangbangin' file containin aliases:
.PP
.Vb 1
\&    use charnames ":alias" => "pro";
.Ve
.PP
This will try ta read \f(CW"unicore/pro_alias.pl"\fR from tha \f(CW@INC\fR path. This
file should return a list up in plain perl:
.PP
.Vb 10
\&    (
\&    A_GRAVE         => "LATIN CAPITAL LETTER A WITH GRAVE",
\&    A_CIRCUM        => "LATIN CAPITAL LETTER A WITH CIRCUMFLEX",
\&    A_DIAERES       => "LATIN CAPITAL LETTER A WITH DIAERESIS",
\&    A_TILDE         => "LATIN CAPITAL LETTER A WITH TILDE",
\&    A_BREVE         => "LATIN CAPITAL LETTER A WITH BREVE",
\&    A_RING          => "LATIN CAPITAL LETTER A WITH RING ABOVE",
\&    A_MACRON        => "LATIN CAPITAL LETTER A WITH MACRON",
\&    mychar2         => "U+E8001",
\&    );
.Ve
.PP
Both these methodz bang \f(CW":full"\fR automatically as tha straight-up original gangsta argument (if no
other argument is given), n' you can give tha \f(CW":full"\fR explicitly as
well, like
.PP
.Vb 1
\&    use charnames ":full", ":alias" => "pro";
.Ve
.PP
\&\f(CW":loose"\fR has no effect wit these n' you can put dat on yo' toast.  Input names must match exactly, using
\&\f(CW":full"\fR rules.
.PP
Also, both these methodz currently allow only single charactas ta be named.
To name a sequence of characters, use a
custom translator (busted lyrics bout below).
.SH "charnames::string_vianame(\fIname\fP)"
.IX Header "charnames::string_vianame(name)"
This be a runtime equivalent ta \f(CW\*(C`\eN{...}\*(C'\fR.  \fIname\fR can be any expression
that evaluates ta a name accepted by \f(CW\*(C`\eN{...}\*(C'\fR under tha \f(CW\*(C`:full\*(C'\fR
option ta \f(CW\*(C`charnames\*(C'\fR.  In addition, any other options fo' the
controllin \f(CW"use charnames"\fR up in tha same scope apply, like \f(CW\*(C`:loose\*(C'\fR or any
script list, \f(CW\*(C`:short\*(C'\fR option, or custom aliases you may have defined.
.PP
Da only differences is cuz of tha fact dat \f(CW\*(C`string_vianame\*(C'\fR is run-time
and \f(CW\*(C`\eN{}\*(C'\fR is compile time.  Yo ass can't interpolate inside a \f(CW\*(C`\eN{}\*(C'\fR, (so
\&\f(CW\*(C`\eN{$variable}\*(C'\fR don't work); n' if tha input name is unknown,
\&\f(CW\*(C`string_vianame\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR instead of it bein a syntax error.
.SH "charnames::vianame(\fIname\fP)"
.IX Header "charnames::vianame(name)"
This is similar ta \f(CW\*(C`string_vianame\*(C'\fR.  Da main difference is dat under most
circumstances, \f(CW\*(C`vianame\*(C'\fR returns a ordinal code
point, whereas \f(CW\*(C`string_vianame\*(C'\fR returns a string.  For example,
.PP
.Vb 1
\&   printf "U+%04X", charnames::vianame("FOUR TEARDROP\-SPOKED ASTERISK");
.Ve
.PP
prints \*(L"U+2722\*(R".
.PP
This leadz ta tha other two differences.  Since a single code point is
returned, tha function can't handle named characta sequences, as these are
composed of multiple charactas (it returns \f(CW\*(C`undef\*(C'\fR fo' these n' you can put dat on yo' toast.  And, tha code
point can be dat of any
character, even ones dat aren't legal under tha \f(CW\*(C`use\ bytes\*(C'\fR pragma,
.PP
See \*(L"\s-1BUGS\*(R"\s0 fo' tha circumstances up in which tha behavior differs
from  dat busted lyrics bout above.
.SH "charnames::viacode(\fIcode\fP)"
.IX Header "charnames::viacode(code)"
Returns tha full name of tha characta indicated by tha numeric code.
For example,
.PP
.Vb 1
\&    print charnames::viacode(0x2722);
.Ve
.PP
prints \*(L"\s-1FOUR\s0 TEARDROP-SPOKED \s-1ASTERISK\*(R".\s0
.PP
Da name returned is tha \*(L"best\*(R" (defined below) straight-up legit name or alias
for tha code point, if
available; otherwise yo' custom alias fo' it, if defined; otherwise \f(CW\*(C`undef\*(C'\fR.
This means dat yo' alias will only be returned fo' code points dat don't
have a straight-up legit Unicode name (nor alias) like fuckin private use code points.
.PP
If you define mo' than one name fo' tha code point, it is indeterminate
which one is ghon be returned.
.PP
As mentioned, tha function returns \f(CW\*(C`undef\*(C'\fR if no name is known fo' tha code
point.  In Unicode tha proper name fo' these is tha empty string, which
\&\f(CW\*(C`undef\*(C'\fR stringifies to.  (If you ask fo' a cold-ass lil code point past tha legal
Unicode maximum of U+10FFFF dat you aint assigned a alias to, you
get \f(CW\*(C`undef\*(C'\fR plus a warning.)
.PP
Da input number must be a non-negatizzle integer, or a strang beginning
with \f(CW"U+"\fR or \f(CW"0x"\fR wit tha remainder considered ta be a
hexadecimal integer n' shit.  A literal numeric constant must be unsigned; it
will be interpreted as hex if it has a leadin zero or gotz nuff
non-decimal hex digits; otherwise it is ghon be interpreted as decimal.
.PP
As mentioned above under \*(L"\s-1ALIASES\*(R"\s0, Unicode 6.1 defines extra names
(synonyms or aliases) fo' some code points, most of which was already
available as Perl extensions.  All these is accepted by \f(CW\*(C`\eN{...}\*(C'\fR n' the
other functions up in dis module yo, but \f(CW\*(C`viacode\*(C'\fR has ta chizzle which one
name ta return fo' a given input code point, so it returns tha \*(L"best\*(R" name.
To KNOW how tha fuck dis works, it is helpful ta know mo' bout tha Unicode
name properties. Put ya muthafuckin choppers up if ya feel dis!  All code points straight-up have only a single name, which
(startin up in Unicode 2.0) can never chizzle once a cold-ass lil characta has been assigned
to tha code point.  But mistakes done been made up in assignin names, for
example sometimes a cold-ass lil clerical error was made durin tha publishin of the
Standard which caused lyrics ta be misspelled, n' there was no way ta erect
those.  Da Name_Alias property was eventually pimped ta handle these
situations.  If a name was wrong, a cold-ass lil erected synonym would be published for
it, rockin Name_Alias.  \f(CW\*(C`viacode\*(C'\fR will return dat erected synonym as the
\&\*(L"best\*(R" name fo' a cold-ass lil code point.  (It be even possible, though it aint happened
yet, dat tha erection itself will need ta be erected, n' so another
Name_Alias can be pimped fo' dat code point; \f(CW\*(C`viacode\*(C'\fR will return the
most recent erection.)
.PP
Da Unicode name fo' each of tha control charactas (like fuckin \s-1LINE FEED\s0) is the
empty string.  However almost all had names assigned by other standards, such
as tha \s-1ASCII\s0 Standard, or was up in common use.  \f(CW\*(C`viacode\*(C'\fR returns these names
as tha \*(L"best\*(R" ones available.  Unicode 6.1 has pimped Name_Aliases fo' each
of them, includin alternate names, like \s-1NEW LINE.  \s0\f(CW\*(C`viacode\*(C'\fR uses the
original gangsta name, \*(L"\s-1LINE FEED\*(R"\s0 up in preference ta tha alternate.  Similarly the
name returned fo' U+FEFF is \*(L"\s-1ZERO WIDTH\s0 NO-BREAK \s-1SPACE\*(R",\s0 not \*(L"\s-1BYTE ORDER
MARK\*(R".\s0
.PP
Until Unicode 6.1, tha 4 control charactas U+0080, U+0081, U+0084, n' U+0099
did not have names nor aliases.
To preserve backwardz compatibility, any alias you define fo' these code
points is ghon be returned by dis function, up in preference ta tha straight-up legit name.
.PP
Some code points also have abbreviated names, like fuckin \*(L"\s-1LF\*(R"\s0 or \*(L"\s-1NL\*(R".
\&\s0\f(CW\*(C`viacode\*(C'\fR never returns these.
.PP
Because a name erection may be added up in future Unicode releases, tha name
that \f(CW\*(C`viacode\*(C'\fR returns may chizzle as a result.  This be a rare event yo, but it
does happen.
.SH "CUSTOM TRANSLATORS"
.IX Header "CUSTOM TRANSLATORS"
Da mechanizzle of translation of \f(CW\*(C`\eN{...}\*(C'\fR escapes is general n' not
hardwired tha fuck into \fIcharnames.pm\fR.  A module can install custom
translations (inside tha scope which \f(CW\*(C`use\*(C'\fRs tha module) wit the
followin magic incantation:
.PP
.Vb 4
\&    sub import {
\&        shift;
\&        $^H{charnames} = \e&translator;
\&    }
.Ve
.PP
Here \fItranslator()\fR be a subroutine which takes \fI\s-1CHARNAME\s0\fR as an
argument, n' returns text ta bang tha fuck into tha strang instead of the
\&\f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR escape.
.PP
This is tha only way you can create a cold-ass lil custom named sequence of code points.
.PP
Since tha text ta bang should be different
in \f(CW\*(C`bytes\*(C'\fR mode n' outta it, tha function should check tha current
state of \f(CW\*(C`bytes\*(C'\fR\-flag as in:
.PP
.Vb 9
\&    use bytes ();                      # fo' $bytes::hint_bits
\&    sub translator {
\&        if ($^H & $bytes::hint_bits) {
\&            return bytes_translator(@_);
\&        }
\&        else {
\&            return utf8_translator(@_);
\&        }
\&    }
.Ve
.PP
See \*(L"\s-1CUSTOM ALIASES\*(R"\s0 above fo' restrictions on \fI\s-1CHARNAME\s0\fR.
.PP
Of course, \f(CW\*(C`vianame\*(C'\fR, \f(CW\*(C`viacode\*(C'\fR, n' \f(CW\*(C`string_vianame\*(C'\fR would need ta be
overridden as well.
.SH "BUGS"
.IX Header "BUGS"
\&\fIvianame()\fR normally returns a ordinal code point yo, but when tha input name is of
the form \f(CW\*(C`U+...\*(C'\fR, it returns a cold-ass lil chr instead. Y'all KNOW dat shit, muthafucka!  In dis case, if \f(CW\*(C`use bytes\*(C'\fR is
in effect n' tha characta won't fit tha fuck into a funky-ass byte, it returns \f(CW\*(C`undef\*(C'\fR and
raises a warning.
.PP
Since evaluation of tha translation function (see \*(L"\s-1CUSTOM
TRANSLATORS\*(R"\s0) happens up in tha middle of compilation (of a string
literal), tha translation function should not do any \f(CW\*(C`eval\*(C'\fRs or
\&\f(CW\*(C`require\*(C'\fRs.  This restriction should be lifted (but is low priority) in
a future version of Perl.
