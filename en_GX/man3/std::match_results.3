" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::match_results< _Bi_iter, _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBstd::vector< sub_match< _Bi_ita >, _Alloc >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "bool \fBready\fP () const "
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef 
.br
_Alloc_traits::const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< const_iterator > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef _Base::pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< iterator > \fBreverse_iterator\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "pointa \fB_M_allocate\fP (size_t __n)"
.br
.ti -1c
.RI "pointa \fB_M_allocate_and_copy\fP (size_type __n, _ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "void \fB_M_assign_aux\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_assign_aux\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_assign_dispatch\fP (_Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "void \fB_M_assign_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "size_type \fB_M_check_len\fP (size_type __n, const char *__s) const"
.br
.ti -1c
.RI "void \fB_M_deallocate\fP (pointa __p, size_t __n)"
.br
.ti -1c
.RI "void \fB_M_default_append\fP (size_type __n)"
.br
.ti -1c
.RI "void \fB_M_default_initialize\fP (size_type __n)"
.br
.ti -1c
.RI "void \fB_M_emplace_back_aux\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "void \fB_M_erase_at_end\fP (pointa __pos)"
.br
.ti -1c
.RI "void \fB_M_fill_assign\fP (size_type __n, const \fBvalue_type\fP &__val)"
.br
.ti -1c
.RI "void \fB_M_fill_initialize\fP (size_type __n, const \fBvalue_type\fP &__value)"
.br
.ti -1c
.RI "void \fB_M_fill_insert\fP (iterator __pos, size_type __n, const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "_Tp_alloc_type & \fB_M_get_Tp_allocator\fP () noexcept"
.br
.ti -1c
.RI "const _Tp_alloc_type & \fB_M_get_Tp_allocator\fP () const noexcept"
.br
.ti -1c
.RI "void \fB_M_initialize_dispatch\fP (_Integer __n, _Integer __value, __true_type)"
.br
.ti -1c
.RI "void \fB_M_initialize_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "void \fB_M_insert_aux\fP (iterator __position, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "void \fB_M_insert_dispatch\fP (iterator __pos, _Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "void \fB_M_insert_dispatch\fP (iterator __pos, _InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "void \fB_M_range_check\fP (size_type __n) const"
.br
.ti -1c
.RI "void \fB_M_range_initialize\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_range_initialize\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_range_insert\fP (iterator __pos, _InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_range_insert\fP (iterator __pos, _ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "bool \fB_M_shrink_to_fit\fP ()"
.br
.ti -1c
.RI "void \fBassign\fP (size_type __n, const \fBvalue_type\fP &__val)"
.br
.ti -1c
.RI "void \fBassign\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBassign\fP (\fBinitializer_list\fP< \fBvalue_type\fP > __l)"
.br
.ti -1c
.RI "\fBreference\fP \fBat\fP (size_type __n)"
.br
.ti -1c
.RI "\fBconst_reference\fP \fBat\fP (size_type __n) const"
.br
.ti -1c
.RI "\fBreference\fP \fBback\fP ()"
.br
.ti -1c
.RI "\fBconst_reference\fP \fBback\fP () const"
.br
.ti -1c
.RI "iterator \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "size_type \fBcapacity\fP () const noexcept"
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const noexcept"
.br
.ti -1c
.RI "\fBsub_match\fP< _Bi_ita > * \fBdata\fP () noexcept"
.br
.ti -1c
.RI "const \fBsub_match\fP< _Bi_ita > * \fBdata\fP () const noexcept"
.br
.ti -1c
.RI "iterator \fBemplace\fP (iterator __position, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "void \fBemplace_back\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "iterator \fBend\fP () noexcept"
.br
.ti -1c
.RI "iterator \fBerase\fP (iterator __position)"
.br
.ti -1c
.RI "iterator \fBerase\fP (iterator __first, iterator __last)"
.br
.ti -1c
.RI "\fBreference\fP \fBfront\fP ()"
.br
.ti -1c
.RI "\fBconst_reference\fP \fBfront\fP () const"
.br
.ti -1c
.RI "iterator \fBinsert\fP (iterator __position, const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "iterator \fBinsert\fP (iterator __position, \fBvalue_type\fP &&__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (iterator __position, \fBinitializer_list\fP< \fBvalue_type\fP > __l)"
.br
.ti -1c
.RI "void \fBinsert\fP (iterator __position, size_type __n, const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (iterator __position, _InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "\fBreference\fP \fBoperator[]\fP (size_type __n)"
.br
.ti -1c
.RI "\fBconst_reference\fP \fBoperator[]\fP (size_type __n) const"
.br
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.ti -1c
.RI "void \fBpush_back\fP (const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "void \fBpush_back\fP (\fBvalue_type\fP &&__x)"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBreserve\fP (size_type __n)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size, const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "void \fBshrink_to_fit\fP ()"
.br
.ti -1c
.RI "void \fBswap\fP (\fBvector\fP &__x) noexcept(_Alloc_traits::_S_nothrow_swap())"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "_Vector_impl \fB_M_impl\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fB__detail::_SpecializedResults< _Bi_iter, _Alloc >\fP"
.br
.in -1c
.SS "10\&.? Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef \fBsub_match\fP< _Bi_ita > \fBvalue_type\fP"
.br
.ti -1c
.RI "typedef const \fBvalue_type\fP & \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fBconst_reference\fP \fBreference\fP"
.br
.ti -1c
.RI "typedef _Base_type::const_iterator \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef const_iterator \fBiterator\fP"
.br
.ti -1c
.RI "typedef 
.br
__iter_traits::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef __iter_traits::value_type \fBchar_type\fP"
.br
.ti -1c
.RI "typedef \fBallocator_traits\fP
.br
< _Alloc >::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef \fBstd::basic_string\fP
.br
< char_type > \fBstring_type\fP"
.br
.in -1c
.SS "28\&.10\&.1 Construction, Copying, n' Destruction"

.in +1c
.ti -1c
.RI "\fBmatch_results\fP (const _Alloc &__a=_Alloc())"
.br
.ti -1c
.RI "\fBmatch_results\fP (const \fBmatch_results\fP &__rhs)"
.br
.ti -1c
.RI "\fBmatch_results\fP (\fBmatch_results\fP &&__rhs) noexcept"
.br
.ti -1c
.RI "\fBmatch_results\fP & \fBoperator=\fP (const \fBmatch_results\fP &__rhs)"
.br
.ti -1c
.RI "\fBmatch_results\fP & \fBoperator=\fP (\fBmatch_results\fP &&__rhs)"
.br
.ti -1c
.RI "\fB~match_results\fP ()"
.br
.in -1c
.SS "28\&.10\&.2 Size"

.in +1c
.ti -1c
.RI "size_type \fBsize\fP () const "
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const "
.br
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.in -1c
.SS "10\&.3 Element Access"

.in +1c
.ti -1c
.RI "difference_type \fBlength\fP (size_type __sub=0) const "
.br
.ti -1c
.RI "difference_type \fBposition\fP (size_type __sub=0) const "
.br
.ti -1c
.RI "\fBstring_type\fP \fBstr\fP (size_type __sub=0) const "
.br
.ti -1c
.RI "\fBconst_reference\fP \fBoperator[]\fP (size_type __sub) const "
.br
.ti -1c
.RI "\fBconst_reference\fP \fBprefix\fP () const "
.br
.ti -1c
.RI "\fBconst_reference\fP \fBsuffix\fP () const "
.br
.ti -1c
.RI "const_iterator \fBbegin\fP () const "
.br
.ti -1c
.RI "const_iterator \fBcbegin\fP () const "
.br
.ti -1c
.RI "const_iterator \fBend\fP () const "
.br
.ti -1c
.RI "const_iterator \fBcend\fP () const "
.br
.in -1c
.SS "10\&.4 Formatting"
These functions big-ass up formatted substitution of tha matched characta sequences tha fuck into they target\&. Da format specifiers n' escape sequences accepted by these functions is determined by they \fCflags\fP parameta as documented above\&. 
.in +1c
.ti -1c
.RI "template<typename _Out_ita > _Out_ita \fBformat\fP (_Out_ita __out, const char_type *__fmt_first, const char_type *__fmt_last, match_flag_type __flags=\fBregex_constants::format_default\fP) const "
.br
.ti -1c
.RI "template<typename _Out_ita , typename _St , typename _Sa > _Out_ita \fBformat\fP (_Out_ita __out, const \fBbasic_string\fP< char_type, _St, _Sa > &__fmt, match_flag_type __flags=\fBregex_constants::format_default\fP) const "
.br
.ti -1c
.RI "template<typename _Out_ita , typename _St , typename _Sa > \fBbasic_string\fP< char_type, _St, _Sa > \fBformat\fP (const \fBbasic_string\fP< char_type, _St, _Sa > &__fmt, match_flag_type __flags=\fBregex_constants::format_default\fP) const "
.br
.ti -1c
.RI "\fBstring_type\fP \fBformat\fP (const char_type *__fmt, match_flag_type __flags=\fBregex_constants::format_default\fP) const "
.br
.in -1c
.SS "10\&.5 Allocator"

.in +1c
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const "
.br
.in -1c
.SS "10\&.6 Swap"

.in +1c
.ti -1c
.RI "void \fBswap\fP (\fBmatch_results\fP &__that)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >>class std::match_results< _Bi_iter, _Alloc >"
Da thangs up in dis biatch of a match or search operation\&. 

A collection of characta sequences representin tha result of a regular expression match\&. Right back up in yo muthafuckin ass. Storage fo' tha collection be allocated n' freed as necessary by tha member functionz of class template match_results\&.
.PP
This class satisfies tha Sequence requirements, wit tha exception dat only tha operations defined fo' a cold-ass lil const-qualified Sequence is supported\&.
.PP
Da sub_match object stored at index 0 represents sub-expression 0, i\&.e\&. tha whole match\&. In dis case tha sub_match member matched be always true\&. Da sub_match object stored at index n denotes what tha fuck matched tha marked sub-expression n within tha matched expression\&. If tha sub-expression n participated up in a regular expression match then tha sub_match member matched evaluates ta true, n' thugz first n' second denote tha range of charactas [first, second) which formed dat match\&. Otherwise matched is false, n' thugz first n' second point ta tha end of tha sequence dat was searched\&. 
.PP
Definizzle at line 1429 of file regex\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> \fBstd::match_results\fP< _Bi_iter, _Alloc >::\fBmatch_results\fP (const _Alloc &__a = \fC_Alloc()\fP)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Constructs a thugged-out default match_results container\&. 
.PP
\fBPostcondition:\fP
.RS 4
size() returns 0 n' str() returns a empty string\&. 
.RE
.PP

.PP
Definizzle at line 1478 of file regex\&.h\&.
.PP
Referenced by std::match_results< _FwdIterT, _Alloc >::operator=()\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> \fBstd::match_results\fP< _Bi_iter, _Alloc >::\fBmatch_results\fP (const \fBmatch_results\fP< _Bi_iter, _Alloc > &__rhs)\fC [inline]\fP"

.PP
Copy constructs a match_results\&. 
.PP
Definizzle at line 1485 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> \fBstd::match_results\fP< _Bi_iter, _Alloc >::\fBmatch_results\fP (\fBmatch_results\fP< _Bi_iter, _Alloc > &&__rhs)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Move constructs a match_results\&. 
.PP
Definizzle at line 1492 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> \fBstd::match_results\fP< _Bi_iter, _Alloc >::~\fBmatch_results\fP ()\fC [inline]\fP"

.PP
Destroys a match_results object\&. 
.PP
Definizzle at line 1519 of file regex\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> const_iterator \fBstd::match_results\fP< _Bi_iter, _Alloc >::begin () const\fC [inline]\fP"

.PP
Gets a iterator ta tha start of tha sub_match collection\&. 
.PP
Definizzle at line 1676 of file regex\&.h\&.
.PP
Referenced by std::operator==()\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> const_iterator \fBstd::match_results\fP< _Bi_iter, _Alloc >::cbegin () const\fC [inline]\fP"

.PP
Gets a iterator ta tha start of tha sub_match collection\&. 
.PP
Definizzle at line 1683 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> const_iterator \fBstd::match_results\fP< _Bi_iter, _Alloc >::cend () const\fC [inline]\fP"

.PP
Gets a iterator ta one-past-the-end of tha collection\&. 
.PP
Definizzle at line 1697 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> bool \fBstd::match_results\fP< _Bi_iter, _Alloc >::empty () const\fC [inline]\fP"

.PP
Indicates if tha match_results gotz nuff no thangs up in dis biatch\&. 
.PP
\fBReturn joints:\fP
.RS 4
\fItrue\fP Da match_results object is empty\&. 
.br
\fIfalse\fP Da match_results object aint empty\&. 
.RE
.PP

.PP
Definizzle at line 1563 of file regex\&.h\&.
.PP
Referenced by std::match_results< _FwdIterT, _Alloc >::end(), std::operator==(), std::match_results< _FwdIterT, _Alloc >::prefix(), n' std::match_results< _FwdIterT, _Alloc >::suffix()\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> const_iterator \fBstd::match_results\fP< _Bi_iter, _Alloc >::end () const\fC [inline]\fP"

.PP
Gets a iterator ta one-past-the-end of tha collection\&. 
.PP
Definizzle at line 1690 of file regex\&.h\&.
.PP
Referenced by std::match_results< _FwdIterT, _Alloc >::cend(), n' std::operator==()\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> template<typename _Out_ita > _Out_ita \fBstd::match_results\fP< _Bi_iter, _Alloc >::format (_Out_iter__out, const char_type *__fmt_first, const char_type *__fmt_last, match_flag_type__flags = \fC\fBregex_constants::format_default\fP\fP) const\fC [inline]\fP"

.PP
\fBPrecondition:\fP
.RS 4
ready() == legit 
.RE
.PP
\fBTodo\fP
.RS 4
Implement dis function\&. 
.RE
.PP

.PP
Definizzle at line 1718 of file regex\&.h\&.
.PP
Referenced by std::match_results< _FwdIterT, _Alloc >::format()\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> template<typename _Out_ita , typename _St , typename _Sa > _Out_ita \fBstd::match_results\fP< _Bi_iter, _Alloc >::format (_Out_iter__out, const \fBbasic_string\fP< char_type, _St, _Sa > &__fmt, match_flag_type__flags = \fC\fBregex_constants::format_default\fP\fP) const\fC [inline]\fP"

.PP
\fBPrecondition:\fP
.RS 4
ready() == legit 
.RE
.PP

.PP
Definizzle at line 1728 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> template<typename _Out_ita , typename _St , typename _Sa > \fBbasic_string\fP<char_type, _St, _Sa> \fBstd::match_results\fP< _Bi_iter, _Alloc >::format (const \fBbasic_string\fP< char_type, _St, _Sa > &__fmt, match_flag_type__flags = \fC\fBregex_constants::format_default\fP\fP) const\fC [inline]\fP"

.PP
\fBPrecondition:\fP
.RS 4
ready() == legit 
.RE
.PP

.PP
Definizzle at line 1740 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> \fBstring_type\fP \fBstd::match_results\fP< _Bi_iter, _Alloc >::format (const char_type *__fmt, match_flag_type__flags = \fC\fBregex_constants::format_default\fP\fP) const\fC [inline]\fP"

.PP
\fBPrecondition:\fP
.RS 4
ready() == legit 
.RE
.PP

.PP
Definizzle at line 1752 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> allocator_type \fBstd::match_results\fP< _Bi_iter, _Alloc >::get_allocator () const\fC [inline]\fP"

.PP
Gets a cold-ass lil copy of tha allocator\&. 
.PP
Definizzle at line 1773 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> difference_type \fBstd::match_results\fP< _Bi_iter, _Alloc >::length (size_type__sub = \fC0\fP) const\fC [inline]\fP"

.PP
Gets tha length of tha indicated submatch\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__sub\fP indicates tha submatch\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
ready() == true
.RE
.PP
This function returns tha length of tha indicated submatch, or tha length of tha entire match if \fC__sub\fP is zero (the default)\&. 
.PP
Definizzle at line 1582 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> size_type \fBstd::match_results\fP< _Bi_iter, _Alloc >::max_size () const\fC [inline]\fP"

.PP
Gets tha number of matches n' submatches\&. Da number of matches fo' a given regular expression is ghon be either 0 if there was no match or mark_count() + 1 if a match was successful\&. Right back up in yo muthafuckin ass. Some matches may be empty\&.
.PP
\fBReturns:\fP
.RS 4
the number of matches found\&. 
.RE
.PP

.PP
Definizzle at line 1554 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> \fBmatch_results\fP& \fBstd::match_results\fP< _Bi_iter, _Alloc >::operator= (const \fBmatch_results\fP< _Bi_iter, _Alloc > &__rhs)\fC [inline]\fP"

.PP
Assigns rhs ta *this\&. 
.PP
Definizzle at line 1500 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> \fBmatch_results\fP& \fBstd::match_results\fP< _Bi_iter, _Alloc >::operator= (\fBmatch_results\fP< _Bi_iter, _Alloc > &&__rhs)\fC [inline]\fP"

.PP
Move-assigns rhs ta *this\&. 
.PP
Definizzle at line 1510 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> \fBconst_reference\fP \fBstd::match_results\fP< _Bi_iter, _Alloc >::operator[] (size_type__sub) const\fC [inline]\fP"

.PP
Gets a sub_match reference fo' tha match or submatch\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__sub\fP indicates tha submatch\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
ready() == true
.RE
.PP
This function gets a reference ta tha indicated submatch, or tha entire match if \fC__sub\fP is zero\&.
.PP
If \fC__sub\fP >= size() then dis function returns a sub_match wit a special value indicatin no submatch\&. 
.PP
Definizzle at line 1630 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> difference_type \fBstd::match_results\fP< _Bi_iter, _Alloc >::posizzle (size_type__sub = \fC0\fP) const\fC [inline]\fP"

.PP
Gets tha offset of tha beginnin of tha indicated submatch\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__sub\fP indicates tha submatch\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
ready() == true
.RE
.PP
This function returns tha offset from tha beginnin of tha target sequence ta tha beginnin of tha submatch, unless tha value of \fC__sub\fP is zero (the default), up in which case dis function returns tha offset from tha beginnin of tha target sequence ta tha beginnin of tha match\&.
.PP
Returns -1 if \fC__sub\fP is outta range\&. 
.PP
Definizzle at line 1599 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> \fBconst_reference\fP \fBstd::match_results\fP< _Bi_iter, _Alloc >::prefix () const\fC [inline]\fP"

.PP
Gets a sub_match representin tha match prefix\&. 
.PP
\fBPrecondition:\fP
.RS 4
ready() == true
.RE
.PP
This function gets a reference ta a sub_match object representin tha part of tha target range between tha start of tha target range n' tha start of tha match\&. 
.PP
Definizzle at line 1647 of file regex\&.h\&.
.PP
Referenced by std::operator==(), n' std::match_results< _FwdIterT, _Alloc >::position()\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> bool \fBstd::match_results\fP< _Bi_iter, _Alloc >::ready () const\fC [inline]\fP"

.PP
Indicates if tha match_results is ready\&. 
.PP
\fBReturn joints:\fP
.RS 4
\fItrue\fP Da object has a gangbangin' fully-established result state\&. 
.br
\fIfalse\fP Da object aint ready\&. 
.RE
.PP

.PP
Definizzle at line 1530 of file regex\&.h\&.
.PP
Referenced by std::operator==(), std::match_results< _FwdIterT, _Alloc >::operator[](), std::match_results< _FwdIterT, _Alloc >::prefix(), n' std::match_results< _FwdIterT, _Alloc >::suffix()\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> size_type \fBstd::match_results\fP< _Bi_iter, _Alloc >::size () const\fC [inline]\fP"

.PP
Gets tha number of matches n' submatches\&. Da number of matches fo' a given regular expression is ghon be either 0 if there was no match or mark_count() + 1 if a match was successful\&. Right back up in yo muthafuckin ass. Some matches may be empty\&.
.PP
\fBReturns:\fP
.RS 4
the number of matches found\&. 
.RE
.PP

.PP
Definizzle at line 1547 of file regex\&.h\&.
.PP
Referenced by std::match_results< _FwdIterT, _Alloc >::empty(), std::operator==(), std::match_results< _FwdIterT, _Alloc >::operator[](), n' std::match_results< _FwdIterT, _Alloc >::position()\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> \fBstring_type\fP \fBstd::match_results\fP< _Bi_iter, _Alloc >::str (size_type__sub = \fC0\fP) const\fC [inline]\fP"

.PP
Gets tha match or submatch converted ta a strang type\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__sub\fP indicates tha submatch\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
ready() == true
.RE
.PP
This function gets tha submatch (or match, if \fC__sub\fP is zero) extracted from tha target range n' converted ta tha associated strang type\&. 
.PP
Definizzle at line 1615 of file regex\&.h\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> \fBconst_reference\fP \fBstd::match_results\fP< _Bi_iter, _Alloc >::suffix () const\fC [inline]\fP"

.PP
Gets a sub_match representin tha match suffix\&. 
.PP
\fBPrecondition:\fP
.RS 4
ready() == true
.RE
.PP
This function gets a reference ta a sub_match object representin tha part of tha target range between tha end of tha match n' tha end of tha target range\&. 
.PP
Definizzle at line 1664 of file regex\&.h\&.
.PP
Referenced by std::operator==()\&.
.SS "template<typename _Bi_iter, typename _Alloc = allocator<sub_match<_Bi_iter> >> void \fBstd::match_results\fP< _Bi_iter, _Alloc >::swap (\fBmatch_results\fP< _Bi_iter, _Alloc > &__that)\fC [inline]\fP"

.PP
Swaps tha contentz of two match_results\&. 
.PP
Definizzle at line 1787 of file regex\&.h\&.
.PP
Referenced by std::swap()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
