.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "URI 3"
.TH URI 3 "2012-03-25" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
URI \- Uniform Resource Identifiers (absolute n' relative)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& $u1 = URI\->new("http://www.perl.com");
\& $u2 = URI\->new("foo", "http");
\& $u3 = $u2\->abs($u1);
\& $u4 = $u3\->clone;
\& $u5 = URI\->new("HTTP://WWW.perl.com:80")\->canonical;
\&
\& $str = $u\->as_string;
\& $str = "$u";
\&
\& $scheme = $u\->scheme;
\& $opaque = $u\->opaque;
\& $path   = $u\->path;
\& $frag   = $u\->fragment;
\&
\& $u\->scheme("ftp");
\& $u\->host("ftp.perl.com");
\& $u\->path("cpan/");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements tha \f(CW\*(C`URI\*(C'\fR class.  Objectz of dis class
represent \*(L"Uniform Resource Identifier references\*(R" as specified up in \s-1RFC
2396 \s0(and updated by \s-1RFC 2732\s0).
.PP
A Uniform Resource Identifier be a cold-ass lil compact strang of charactas that
identifies a abstract or physical resource.  A Uniform Resource
Identifier can be further classified as either a Uniform Resource Locator
(\s-1URL\s0) or a Uniform Resource Name (\s-1URN\s0).  Da distinction between \s-1URL\s0
and \s-1URN\s0 do not matta ta tha \f(CW\*(C`URI\*(C'\fR class intercourse fo' realz. A
\&\*(L"URI-reference\*(R" be a \s-1URI\s0 dat may have additionizzle shiznit attached
in tha form of a gangbangin' fragment identifier.
.PP
An absolute \s-1URI\s0 reference consistz of three parts:  a \fIscheme\fR, a
\&\fIscheme-specific part\fR n' a \fIfragment\fR identifier n' shit.  A subset of \s-1URI\s0
references share a cold-ass lil common syntax fo' hierarchical namespaces.  For
these, tha scheme-specific part is further fucked up down into
\&\fIauthority\fR, \fIpath\fR n' \fIquery\fR components, n' you can put dat on yo' toast.  These URIs can also
take tha form of relatizzle \s-1URI\s0 references, where tha scheme (and
usually also tha authority) component is missin yo, but implied by the
context of tha \s-1URI\s0 reference.  Da three formz of \s-1URI\s0 reference
syntax is summarized as bigs up:
.PP
.Vb 3
\&  <scheme>:<scheme\-specific\-part>#<fragment>
\&  <scheme>://<authority><path>?<query>#<fragment>
\&  <path>?<query>#<fragment>
.Ve
.PP
Da components tha fuck into which a \s-1URI\s0 reference can be divided depend on the
\&\fIscheme\fR.  Da \f(CW\*(C`URI\*(C'\fR class serves up methodz ta git n' set the
individual components, n' you can put dat on yo' toast.  Da methodz available fo' a specific
\&\f(CW\*(C`URI\*(C'\fR object depend on tha scheme.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
Da followin methodz construct freshly smoked up \f(CW\*(C`URI\*(C'\fR objects:
.ie n .IP "$uri = \s-1URI\-\s0>new( $str )" 4
.el .IP "\f(CW$uri\fR = \s-1URI\-\s0>new( \f(CW$str\fR )" 4
.IX Item "$uri = URI->new( $str )"
.PD 0
.ie n .IP "$uri = \s-1URI\-\s0>new( $str, $scheme )" 4
.el .IP "\f(CW$uri\fR = \s-1URI\-\s0>new( \f(CW$str\fR, \f(CW$scheme\fR )" 4
.IX Item "$uri = URI->new( $str, $scheme )"
.PD
Constructs a freshly smoked up \s-1URI\s0 object.  Da string
representation of a \s-1URI\s0 is given as argument, together wit a optional
scheme justification. I aint talkin' bout chicken n' gravy biatch.  Common \s-1URI\s0 wrappers like "" n' <>, as well as
leadin n' trailin white space, is automatically removed from
the \f(CW$str\fR argument before it is processed further.
.Sp
Da constructor determines tha scheme, maps dis ta a appropriate
\&\s-1URI\s0 subclass, constructs a freshly smoked up object of dat class n' returns dat shit.
.Sp
Da \f(CW$scheme\fR argument is only used when \f(CW$str\fR be a
relatizzle \s-1URI. \s0 It can be either a simple strang that
denotes tha scheme, a strang containin a absolute \s-1URI\s0 reference, or
an absolute \f(CW\*(C`URI\*(C'\fR object.  If no \f(CW$scheme\fR is specified fo' a relative
\&\s-1URI\s0 \f(CW$str\fR, then \f(CW$str\fR is simply treated as a generic \s-1URI \s0(no scheme-specific
methodz available).
.Sp
Da set of charactas available fo' buildin \s-1URI\s0 references is
restricted (see URI::Escape).  Charactas outside dis set are
automatically escaped by tha \s-1URI\s0 constructor.
.ie n .IP "$uri = \s-1URI\-\s0>new_abs( $str, $base_uri )" 4
.el .IP "\f(CW$uri\fR = \s-1URI\-\s0>new_abs( \f(CW$str\fR, \f(CW$base_uri\fR )" 4
.IX Item "$uri = URI->new_abs( $str, $base_uri )"
Constructs a freshly smoked up absolute \s-1URI\s0 object.  Da \f(CW$str\fR argument can
denote a relatizzle or absolute \s-1URI. \s0 If relative, then it is
absolutized rockin \f(CW$base_uri\fR as base. Da \f(CW$base_uri\fR must be a absolute
\&\s-1URI.\s0
.ie n .IP "$uri = URI::file\->new( $filename )" 4
.el .IP "\f(CW$uri\fR = URI::file\->new( \f(CW$filename\fR )" 4
.IX Item "$uri = URI::file->new( $filename )"
.PD 0
.ie n .IP "$uri = URI::file\->new( $filename, $os )" 4
.el .IP "\f(CW$uri\fR = URI::file\->new( \f(CW$filename\fR, \f(CW$os\fR )" 4
.IX Item "$uri = URI::file->new( $filename, $os )"
.PD
Constructs a freshly smoked up \fIfile\fR \s-1URI\s0 from a gangbangin' file name.  See URI::file.
.ie n .IP "$uri = URI::file\->new_abs( $filename )" 4
.el .IP "\f(CW$uri\fR = URI::file\->new_abs( \f(CW$filename\fR )" 4
.IX Item "$uri = URI::file->new_abs( $filename )"
.PD 0
.ie n .IP "$uri = URI::file\->new_abs( $filename, $os )" 4
.el .IP "\f(CW$uri\fR = URI::file\->new_abs( \f(CW$filename\fR, \f(CW$os\fR )" 4
.IX Item "$uri = URI::file->new_abs( $filename, $os )"
.PD
Constructs a freshly smoked up absolute \fIfile\fR \s-1URI\s0 from a gangbangin' file name.  See
URI::file.
.ie n .IP "$uri = URI::file\->cwd" 4
.el .IP "\f(CW$uri\fR = URI::file\->cwd" 4
.IX Item "$uri = URI::file->cwd"
Returns tha current hustlin directory as a \fIfile\fR \s-1URI. \s0 See
URI::file.
.ie n .IP "$uri\->clone" 4
.el .IP "\f(CW$uri\fR\->clone" 4
.IX Item "$uri->clone"
Returns a cold-ass lil copy of tha \f(CW$uri\fR.
.SH "COMMON METHODS"
.IX Header "COMMON METHODS"
Da methodz busted lyrics bout up in dis section is available fo' all \f(CW\*(C`URI\*(C'\fR
objects.
.PP
Methodz dat give access ta componentz of a \s-1URI\s0 always return the
old value of tha component.  Da value returned is \f(CW\*(C`undef\*(C'\fR if the
component was not present.  There is generally a gangbangin' finger-lickin' difference between a
component dat is empty (represented as \f(CW""\fR) n' a cold-ass lil component dat is
missin (represented as \f(CW\*(C`undef\*(C'\fR).  If a accessor method is given an
argument, it thugged-out shiznit tha correspondin component up in addizzle to
returnin tha oldschool value of tha component.  Passin a undefined
argument removes tha component (if possible).  Da description of
each accessor method indicates whether tha component is passed as
an escaped (percent-encoded) or a unescaped string.  A component dat can be further
divided tha fuck into sub-parts is probably passed escaped, as unescapin might
change its semantics.
.PP
Da common methodz available fo' all \s-1URI\s0 are:
.ie n .IP "$uri\->scheme" 4
.el .IP "\f(CW$uri\fR\->scheme" 4
.IX Item "$uri->scheme"
.PD 0
.ie n .IP "$uri\->scheme( $new_scheme )" 4
.el .IP "\f(CW$uri\fR\->scheme( \f(CW$new_scheme\fR )" 4
.IX Item "$uri->scheme( $new_scheme )"
.PD
Sets n' returns tha scheme part of tha \f(CW$uri\fR.  If tha \f(CW$uri\fR is
relative, then \f(CW$uri\fR\->scheme returns \f(CW\*(C`undef\*(C'\fR.  If called wit an
argument, it thugged-out shiznit tha scheme of \f(CW$uri\fR, possibly changin the
class of \f(CW$uri\fR, n' returns tha oldschool scheme value.  Da method croaks
if tha freshly smoked up scheme name is illegal; a scheme name must begin wit a
letta n' must consist of only US-ASCII letters, numbers, n' a gangbangin' few
special marks: \*(L".\*(R", \*(L"+\*(R", \*(L"\-\*(R".  This restriction effectively means
that tha scheme must be passed unescaped. Y'all KNOW dat shit, muthafucka!  Passin a undefined
argument ta tha scheme method make tha \s-1URI\s0 relatizzle (if possible).
.Sp
Letta case do not matta fo' scheme names.  Da string
returned by \f(CW$uri\fR\->scheme be always lowercase.  If you want tha scheme
just as dat shiznit was freestyled up in tha \s-1URI\s0 up in its original gangsta case,
you can use tha \f(CW$uri\fR\->_scheme method instead.
.ie n .IP "$uri\->opaque" 4
.el .IP "\f(CW$uri\fR\->opaque" 4
.IX Item "$uri->opaque"
.PD 0
.ie n .IP "$uri\->opaque( $new_opaque )" 4
.el .IP "\f(CW$uri\fR\->opaque( \f(CW$new_opaque\fR )" 4
.IX Item "$uri->opaque( $new_opaque )"
.PD
Sets n' returns tha scheme-specific part of tha \f(CW$uri\fR
(everythang between tha scheme n' tha fragment)
as a escaped string.
.ie n .IP "$uri\->path" 4
.el .IP "\f(CW$uri\fR\->path" 4
.IX Item "$uri->path"
.PD 0
.ie n .IP "$uri\->path( $new_path )" 4
.el .IP "\f(CW$uri\fR\->path( \f(CW$new_path\fR )" 4
.IX Item "$uri->path( $new_path )"
.PD
Sets n' returns tha same ol' dirty value as \f(CW$uri\fR\->opaque unless tha \s-1URI\s0
supports tha generic syntax fo' hierarchical namespaces.
In dat case tha generic method is overridden ta set n' return
the part of tha \s-1URI\s0 between tha \fIhost name\fR n' tha \fIfragment\fR.
.ie n .IP "$uri\->fragment" 4
.el .IP "\f(CW$uri\fR\->fragment" 4
.IX Item "$uri->fragment"
.PD 0
.ie n .IP "$uri\->fragment( $new_frag )" 4
.el .IP "\f(CW$uri\fR\->fragment( \f(CW$new_frag\fR )" 4
.IX Item "$uri->fragment( $new_frag )"
.PD
Returns tha fragment identifier of a \s-1URI\s0 reference
as a escaped string.
.ie n .IP "$uri\->as_string" 4
.el .IP "\f(CW$uri\fR\->as_string" 4
.IX Item "$uri->as_string"
Returns a \s-1URI\s0 object ta a plain \s-1ASCII\s0 string.  \s-1URI\s0 objects are
also converted ta plain strings automatically by overloading.  This
means dat \f(CW$uri\fR objects can be used as plain strings up in most Perl
constructs.
.ie n .IP "$uri\->as_iri" 4
.el .IP "\f(CW$uri\fR\->as_iri" 4
.IX Item "$uri->as_iri"
Returns a Unicode strang representin tha \s-1URI. \s0 Escaped \s-1UTF\-8\s0 sequences
representin non-ASCII charactas is turned tha fuck into they correspondin Unicode
code point.
.ie n .IP "$uri\->canonical" 4
.el .IP "\f(CW$uri\fR\->canonical" 4
.IX Item "$uri->canonical"
Returns a normalized version of tha \s-1URI. \s0 Da rules
for normalization is scheme-dependent.  They probably involve
lowercasin tha scheme n' Internizzle host name components,
removin tha explicit port justification if it matches tha default port,
uppercasin all escape sequences, n' unescapin octets dat can be
betta represented as plain characters.
.Sp
For efficiency reasons, if tha \f(CW$uri\fR be already up in normalized form,
then a reference ta it is returned instead of a cold-ass lil copy.
.ie n .IP "$uri\->eq( $other_uri )" 4
.el .IP "\f(CW$uri\fR\->eq( \f(CW$other_uri\fR )" 4
.IX Item "$uri->eq( $other_uri )"
.PD 0
.ie n .IP "URI::eq( $first_uri, $other_uri )" 4
.el .IP "URI::eq( \f(CW$first_uri\fR, \f(CW$other_uri\fR )" 4
.IX Item "URI::eq( $first_uri, $other_uri )"
.PD
Tests whether two \s-1URI\s0 references is equal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  \s-1URI\s0 references
that normalize ta tha same strang is considered equal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da method
can also be used as a plain function which can also test two string
arguments.
.Sp
If you need ta test whether two \f(CW\*(C`URI\*(C'\fR object references denote the
same object, use tha '==' operator.
.ie n .IP "$uri\->abs( $base_uri )" 4
.el .IP "\f(CW$uri\fR\->abs( \f(CW$base_uri\fR )" 4
.IX Item "$uri->abs( $base_uri )"
Returns a absolute \s-1URI\s0 reference.  If \f(CW$uri\fR be already
absolute, then a reference ta it is simply returned. Y'all KNOW dat shit, muthafucka!  If tha \f(CW$uri\fR
is relative, then a freshly smoked up absolute \s-1URI\s0 is constructed by combinin the
\&\f(CW$uri\fR n' tha \f(CW$base_uri\fR, n' returned.
.ie n .IP "$uri\->rel( $base_uri )" 4
.el .IP "\f(CW$uri\fR\->rel( \f(CW$base_uri\fR )" 4
.IX Item "$uri->rel( $base_uri )"
Returns a relatizzle \s-1URI\s0 reference if it is possible to
make one dat denotes tha same ol' dirty resource relatizzle ta \f(CW$base_uri\fR.
If not, then \f(CW$uri\fR is simply returned.
.ie n .IP "$uri\->secure" 4
.el .IP "\f(CW$uri\fR\->secure" 4
.IX Item "$uri->secure"
Returns a \s-1TRUE\s0 value if tha \s-1URI\s0 is considered ta point ta a resource on
a secure channel, like fuckin a \s-1SSL\s0 or \s-1TLS\s0 encrypted one.
.SH "GENERIC METHODS"
.IX Header "GENERIC METHODS"
Da followin methodz is available ta schemes dat use the
common/generic syntax fo' hierarchical namespaces.  Da descriptions of
schemes below indicate which these are.  Unknown schemes are
assumed ta support tha generic syntax, n' therefore tha following
methods:
.ie n .IP "$uri\->authority" 4
.el .IP "\f(CW$uri\fR\->authority" 4
.IX Item "$uri->authority"
.PD 0
.ie n .IP "$uri\->authority( $new_authoritizzle )" 4
.el .IP "\f(CW$uri\fR\->authority( \f(CW$new_authority\fR )" 4
.IX Item "$uri->authority( $new_authoritizzle )"
.PD
Sets n' returns tha escaped authoritizzle component
of tha \f(CW$uri\fR.
.ie n .IP "$uri\->path" 4
.el .IP "\f(CW$uri\fR\->path" 4
.IX Item "$uri->path"
.PD 0
.ie n .IP "$uri\->path( $new_path )" 4
.el .IP "\f(CW$uri\fR\->path( \f(CW$new_path\fR )" 4
.IX Item "$uri->path( $new_path )"
.PD
Sets n' returns tha escaped path component of
the \f(CW$uri\fR (the part between tha host name n' tha query or fragment).
Da path can never be undefined yo, but it can be tha empty string.
.ie n .IP "$uri\->path_query" 4
.el .IP "\f(CW$uri\fR\->path_query" 4
.IX Item "$uri->path_query"
.PD 0
.ie n .IP "$uri\->path_query( $new_path_query )" 4
.el .IP "\f(CW$uri\fR\->path_query( \f(CW$new_path_query\fR )" 4
.IX Item "$uri->path_query( $new_path_query )"
.PD
Sets n' returns tha escaped path n' query
components as a single entity.  Da path n' tha query are
separated by a \*(L"?\*(R" character yo, but tha query can itself contain \*(L"?\*(R".
.ie n .IP "$uri\->path_segments" 4
.el .IP "\f(CW$uri\fR\->path_segments" 4
.IX Item "$uri->path_segments"
.PD 0
.ie n .IP "$uri\->path_segments( $segment, ... )" 4
.el .IP "\f(CW$uri\fR\->path_segments( \f(CW$segment\fR, ... )" 4
.IX Item "$uri->path_segments( $segment, ... )"
.PD
Sets n' returns tha path.  In a scalar context, it returns
the same value as \f(CW$uri\fR\->path.  In a list context, it returns the
unescaped path segments dat make up tha path.  Path segments that
have parametas is returned as a anonymous array.  Da first element
is tha unescaped path segment proper;  subsequent elements is escaped
parameta strings.  Such a anonymous array uses overloadin so it can
be treated as a strang too yo, but dis strang do not include the
parameters.
.Sp
Note dat absolute paths have tha empty strang as they first
\&\fIpath_segment\fR, i.e. tha \fIpath\fR \f(CW\*(C`/foo/bar\*(C'\fR have 3
\&\fIpath_segments\fR; "\*(L", \*(R"foo\*(L" n' \*(R"bar".
.ie n .IP "$uri\->query" 4
.el .IP "\f(CW$uri\fR\->query" 4
.IX Item "$uri->query"
.PD 0
.ie n .IP "$uri\->query( $new_query )" 4
.el .IP "\f(CW$uri\fR\->query( \f(CW$new_query\fR )" 4
.IX Item "$uri->query( $new_query )"
.PD
Sets n' returns tha escaped query component of
the \f(CW$uri\fR.
.ie n .IP "$uri\->query_form" 4
.el .IP "\f(CW$uri\fR\->query_form" 4
.IX Item "$uri->query_form"
.PD 0
.ie n .IP "$uri\->query_form( $key1 => $val1, $key2 => $val2, ... )" 4
.el .IP "\f(CW$uri\fR\->query_form( \f(CW$key1\fR => \f(CW$val1\fR, \f(CW$key2\fR => \f(CW$val2\fR, ... )" 4
.IX Item "$uri->query_form( $key1 => $val1, $key2 => $val2, ... )"
.ie n .IP "$uri\->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )" 4
.el .IP "\f(CW$uri\fR\->query_form( \f(CW$key1\fR => \f(CW$val1\fR, \f(CW$key2\fR => \f(CW$val2\fR, ..., \f(CW$delim\fR )" 4
.IX Item "$uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )"
.ie n .IP "$uri\->query_form( \e@key_value_pairs )" 4
.el .IP "\f(CW$uri\fR\->query_form( \e@key_value_pairs )" 4
.IX Item "$uri->query_form( @key_value_pairs )"
.ie n .IP "$uri\->query_form( \e@key_value_pairs, $delim )" 4
.el .IP "\f(CW$uri\fR\->query_form( \e@key_value_pairs, \f(CW$delim\fR )" 4
.IX Item "$uri->query_form( @key_value_pairs, $delim )"
.ie n .IP "$uri\->query_form( \e%hash )" 4
.el .IP "\f(CW$uri\fR\->query_form( \e%hash )" 4
.IX Item "$uri->query_form( %hash )"
.ie n .IP "$uri\->query_form( \e%hash, $delim )" 4
.el .IP "\f(CW$uri\fR\->query_form( \e%hash, \f(CW$delim\fR )" 4
.IX Item "$uri->query_form( %hash, $delim )"
.PD
Sets n' returns query components dat use the
\&\fIapplication/x\-www\-form\-urlencoded\fR format.  Key/value pairs are
separated by \*(L"&\*(R", n' tha key is separated from tha value by a \*(L"=\*(R"
character.
.Sp
Da form can be set either by passin separate key/value pairs, or via
an array or hash reference.  Passin a empty array or a empty hash
removes tha query component, whereas passin no arguments at all leaves
the component unchanged. Y'all KNOW dat shit, muthafucka!  Da order of keys is undefined if a hash
reference is passed. Y'all KNOW dat shit, muthafucka!  Da oldschool value be always returned as a list of
separate key/value pairs.  Assignin dis list ta a hash is unwise as
the keys returned might repeat.
.Sp
Da joints passed when settin tha form can be plain strings or
references ta arrayz of strings.  Passin a array of joints has the
same effect as passin tha key repeatedly wit one value at a time.
All tha followin statements have tha same effect:
.Sp
.Vb 5
\&    $uri\->query_form(foo => 1, foo => 2);
\&    $uri\->query_form(foo => [1, 2]);
\&    $uri\->query_form([ foo => 1, foo => 2 ]);
\&    $uri\->query_form([ foo => [1, 2] ]);
\&    $uri\->query_form({ foo => [1, 2] });
.Ve
.Sp
Da \f(CW$delim\fR parameta can be passed as \*(L";\*(R" ta force tha key/value pairs
to be delimited by \*(L";\*(R" instead of \*(L"&\*(R" up in tha query string.  This
practice is often recommended fo' URLs embedded up in \s-1HTML\s0 or \s-1XML\s0
documents as dis avoidz tha shiznit of escapin tha \*(L"&\*(R" character.
Yo ass might also set tha \f(CW$URI::DEFAULT_QUERY_FORM_DELIMITER\fR variable to
\&\*(L";\*(R" fo' tha same global effect.
.Sp
Da \f(CW\*(C`URI::QueryParam\*(C'\fR module can be loaded ta add further methodz to
manipulate tha form of a \s-1URI. \s0 See URI::QueryParam fo' details.
.ie n .IP "$uri\->query_keywords" 4
.el .IP "\f(CW$uri\fR\->query_keywords" 4
.IX Item "$uri->query_keywords"
.PD 0
.ie n .IP "$uri\->query_keywords( $keywords, ... )" 4
.el .IP "\f(CW$uri\fR\->query_keywords( \f(CW$keywords\fR, ... )" 4
.IX Item "$uri->query_keywords( $keywords, ... )"
.ie n .IP "$uri\->query_keywords( \e@keywordz )" 4
.el .IP "\f(CW$uri\fR\->query_keywords( \e@keywordz )" 4
.IX Item "$uri->query_keywords( @keywordz )"
.PD
Sets n' returns query components dat use the
keywordz separated by \*(L"+\*(R" format.
.Sp
Da keywordz can be set either by passin separate keywordz directly
or by passin a reference ta a array of keywords.  Passin a empty
array removes tha query component, whereas passin no arguments at
all leaves tha component unchanged. Y'all KNOW dat shit, muthafucka!  Da oldschool value be always returned
as a list of separate lyrics.
.SH "SERVER METHODS"
.IX Header "SERVER METHODS"
For schemes where tha \fIauthority\fR component denotes a Internizzle host,
the followin methodz is available up in addizzle ta tha generic
methods.
.ie n .IP "$uri\->userinfo" 4
.el .IP "\f(CW$uri\fR\->userinfo" 4
.IX Item "$uri->userinfo"
.PD 0
.ie n .IP "$uri\->userinfo( $new_userinfo )" 4
.el .IP "\f(CW$uri\fR\->userinfo( \f(CW$new_userinfo\fR )" 4
.IX Item "$uri->userinfo( $new_userinfo )"
.PD
Sets n' returns tha escaped userinfo part of the
authoritizzle component.
.Sp
For some schemes dis be a user name n' a password separated by
a colon. I aint talkin' bout chicken n' gravy biatch.  This practice aint recommended. Y'all KNOW dat shit, muthafucka! Embeddin passwordz in
clear text (like fuckin \s-1URI\s0) has proven ta be a securitizzle risk up in almost
every case where it has been used.
.ie n .IP "$uri\->host" 4
.el .IP "\f(CW$uri\fR\->host" 4
.IX Item "$uri->host"
.PD 0
.ie n .IP "$uri\->host( $new_host )" 4
.el .IP "\f(CW$uri\fR\->host( \f(CW$new_host\fR )" 4
.IX Item "$uri->host( $new_host )"
.PD
Sets n' returns tha unescaped hostname.
.Sp
If tha \f(CW$new_host\fR strang endz wit a cold-ass lil colon n' a number, then this
number also sets tha port.
.Sp
For IPv6 addresses tha brackets round tha raw address is removed up in tha return
value from \f(CW$uri\fR\->host.  When settin tha host attribute ta a IPv6 address you
can bust a raw address or one enclosed up in brackets, n' you can put dat on yo' toast.  Da address need ta be
enclosed up in brackets if you wanna pass up in a freshly smoked up port value as well.
.ie n .IP "$uri\->ihost" 4
.el .IP "\f(CW$uri\fR\->ihost" 4
.IX Item "$uri->ihost"
Returns tha host up in Unicode form.  Any \s-1IDNA\s0 A\-labels is turned tha fuck into U\-labels.
.ie n .IP "$uri\->port" 4
.el .IP "\f(CW$uri\fR\->port" 4
.IX Item "$uri->port"
.PD 0
.ie n .IP "$uri\->port( $new_port )" 4
.el .IP "\f(CW$uri\fR\->port( \f(CW$new_port\fR )" 4
.IX Item "$uri->port( $new_port )"
.PD
Sets n' returns tha port.  Da port be a simple integer
that should be pimped outa than 0.
.Sp
If a port aint specified explicitly up in tha \s-1URI,\s0 then tha \s-1URI\s0 schemez default port
is returned. Y'all KNOW dat shit, muthafucka! If you don't want tha default port
substituted, then you can use tha \f(CW$uri\fR\->_port method instead.
.ie n .IP "$uri\->host_port" 4
.el .IP "\f(CW$uri\fR\->host_port" 4
.IX Item "$uri->host_port"
.PD 0
.ie n .IP "$uri\->host_port( $new_host_port )" 4
.el .IP "\f(CW$uri\fR\->host_port( \f(CW$new_host_port\fR )" 4
.IX Item "$uri->host_port( $new_host_port )"
.PD
Sets n' returns tha host n' port as a single
unit.  Da returned value includes a port, even if it matches the
default port.  Da host part n' tha port part is separated by a
colon: \*(L":\*(R".
.Sp
For IPv6 addresses tha bracketin is preserved; thus
\&\s-1URI\-\s0>new(\*(L"http://[::1]/\*(R")\->host_port returns \*(L"[::1]:80\*(R".  Contrast dis with
\&\f(CW$uri\fR\->host which will remove tha brackets.
.ie n .IP "$uri\->default_port" 4
.el .IP "\f(CW$uri\fR\->default_port" 4
.IX Item "$uri->default_port"
Returns tha default port of tha \s-1URI\s0 scheme ta which \f(CW$uri\fR
belongs.  For \fIhttp\fR dis is tha number 80, fo' \fIftp\fR this
is tha number 21, etc.  Da default port fo' a scheme can not be
changed.
.SH "SCHEME-SPECIFIC SUPPORT"
.IX Header "SCHEME-SPECIFIC SUPPORT"
Scheme-specific support is provided fo' tha followin \s-1URI\s0 schemes.  For \f(CW\*(C`URI\*(C'\fR
objects dat do not belong ta one of these, you can only use tha common and
generic methods.
.IP "\fBdata\fR:" 4
.IX Item "data:"
Da \fIdata\fR \s-1URI\s0 scheme is specified up in \s-1RFC 2397. \s0 It allows inclusion
of lil' small-ass data shit as \*(L"immediate\*(R" data, as if it had been included
externally.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belongin ta tha data scheme support tha common methods
and two freshly smoked up methodz ta access they scheme-specific components:
\&\f(CW$uri\fR\->media_type n' \f(CW$uri\fR\->data.  See URI::data fo' details.
.IP "\fBfile\fR:" 4
.IX Item "file:"
An oldschool justification of tha \fIfile\fR \s-1URI\s0 scheme is found up in \s-1RFC 1738.
A\s0 freshly smoked up \s-1RFC 2396\s0 based justification up in not available yet yo, but file \s-1URI\s0
references is up in common use.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belongin ta tha file scheme support tha common and
generic methods.  In addition, they provide two methodz fo' mappin file URIs
back ta local file names; \f(CW$uri\fR\->file n' \f(CW$uri\fR\->dir. Shiiit, dis aint no joke.  See URI::file
for details.
.IP "\fBftp\fR:" 4
.IX Item "ftp:"
An oldschool justification of tha \fIftp\fR \s-1URI\s0 scheme is found up in \s-1RFC 1738.  A\s0
new \s-1RFC 2396\s0 based justification up in not available yet yo, but ftp \s-1URI\s0
references is up in common use.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belongin ta tha ftp scheme support tha common,
generic n' server methods.  In addition, they provide two methodz for
accessin tha userinfo sub-components: \f(CW$uri\fR\->user n' \f(CW$uri\fR\->password.
.IP "\fBgopher\fR:" 4
.IX Item "gopher:"
Da \fIgopher\fR \s-1URI\s0 scheme is specified in
<draft\-murali\-url\-gopher\-1996\-12\-04> n' will hopefully be available
as a \s-1RFC 2396\s0 based justification.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belongin ta tha gopher scheme support tha common,
generic n' server methods. In addition, they support some methodz for
accessin gopher-specific path components: \f(CW$uri\fR\->gopher_type,
\&\f(CW$uri\fR\->selector, \f(CW$uri\fR\->search, \f(CW$uri\fR\->string.
.IP "\fBhttp\fR:" 4
.IX Item "http:"
Da \fIhttp\fR \s-1URI\s0 scheme is specified up in \s-1RFC 2616.\s0
Da scheme is used ta reference resources hosted by \s-1HTTP\s0 servers.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belongin ta tha http scheme support tha common,
generic n' server methods.
.IP "\fBhttps\fR:" 4
.IX Item "https:"
Da \fIhttps\fR \s-1URI\s0 scheme be a Netscape invention which is commonly
implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da scheme is used ta reference \s-1HTTP\s0 servers all up in \s-1SSL\s0
connections.  Its syntax is tha same ol' dirty as http yo, but tha default
port is different.
.IP "\fBldap\fR:" 4
.IX Item "ldap:"
Da \fIldap\fR \s-1URI\s0 scheme is specified up in \s-1RFC 2255.  LDAP\s0 is the
Lightweight Directory Access Protocol.  An ldap \s-1URI\s0 raps bout a \s-1LDAP\s0
search operation ta big-ass up ta retrieve shiznit from a \s-1LDAP\s0
directory.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belongin ta tha ldap scheme support tha common,
generic n' server methodz as well as ldap-specific methods: \f(CW$uri\fR\->dn,
\&\f(CW$uri\fR\->attributes, \f(CW$uri\fR\->scope, \f(CW$uri\fR\->filter, \f(CW$uri\fR\->extensions.  See
URI::ldap fo' details.
.IP "\fBldapi\fR:" 4
.IX Item "ldapi:"
Like tha \fIldap\fR \s-1URI\s0 scheme yo, but uses a \s-1UNIX\s0 domain socket.  The
server methodz is not supported, n' tha local socket path is
available as \f(CW$uri\fR\->un_path.  Da \fIldapi\fR scheme is used by the
OpenLDAP package.  There is no real justification fo' it yo, but it is
mentioned up in various OpenLDAP manual pages.
.IP "\fBldaps\fR:" 4
.IX Item "ldaps:"
Like tha \fIldap\fR \s-1URI\s0 scheme yo, but uses a \s-1SSL\s0 connection. I aint talkin' bout chicken n' gravy biatch.  This
scheme is deprecated, as tha preferred way is ta use tha \fIstart_tls\fR
mechanism.
.IP "\fBmailto\fR:" 4
.IX Item "mailto:"
Da \fImailto\fR \s-1URI\s0 scheme is specified up in \s-1RFC 2368. \s0 Da scheme was
originally used ta designate tha Internizzle mailin address of an
individual or service.  It has (in \s-1RFC 2368\s0) been extended ta allow
settin of other mail header fieldz n' tha message body.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belongin ta tha mailto scheme support tha common
methodz n' tha generic query methods.  In addition, they support the
followin mailto-specific methods: \f(CW$uri\fR\->to, \f(CW$uri\fR\->headers.
.Sp
Note dat tha \*(L"foo@example.com\*(R" part of a mailto is \fInot\fR the
\&\f(CW\*(C`userinfo\*(C'\fR n' \f(CW\*(C`host\*(C'\fR but instead tha \f(CW\*(C`path\*(C'\fR.  This allows a
mailto \s-1URI\s0 ta contain multiple comma separated email addresses.
.IP "\fBmms\fR:" 4
.IX Item "mms:"
Da \fImms\fR \s-1URL\s0 justification can be found at <http://sdp.ppona.com/>.
\&\f(CW\*(C`URI\*(C'\fR objects belongin ta tha mms scheme support tha common,
generic, n' server methods, wit tha exception of userinfo and
query-related sub-components.
.IP "\fBnews\fR:" 4
.IX Item "news:"
Da \fInews\fR, \fInntp\fR n' \fIsnews\fR \s-1URI\s0 schemes is specified in
<draft\-gilman\-news\-url\-01> n' will hopefully be available as a \s-1RFC
2396\s0 based justification soon.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belongin ta tha shizzle scheme support tha common,
generic n' server methods.  In addition, they provide some methodz to
access tha path: \f(CW$uri\fR\->group n' \f(CW$uri\fR\->message.
.IP "\fBnntp\fR:" 4
.IX Item "nntp:"
See \fInews\fR scheme.
.IP "\fBpop\fR:" 4
.IX Item "pop:"
Da \fIpop\fR \s-1URI\s0 scheme is specified up in \s-1RFC 2384.\s0 Da scheme is used to
reference a \s-1POP3\s0 mailbox.
.Sp
\&\f(CW\*(C`URI\*(C'\fR objects belongin ta tha pop scheme support tha common, generic
and server methods.  In addition, they provide two methodz ta access the
userinfo components: \f(CW$uri\fR\->user n' \f(CW$uri\fR\->auth
.IP "\fBrlogin\fR:" 4
.IX Item "rlogin:"
An oldschool justification of tha \fIrlogin\fR \s-1URI\s0 scheme is found up in \s-1RFC
1738. \s0\f(CW\*(C`URI\*(C'\fR objects belongin ta tha rlogin scheme support the
common, generic n' server methods.
.IP "\fBrtsp\fR:" 4
.IX Item "rtsp:"
Da \fIrtsp\fR \s-1URL\s0 justification can be found up in section 3.2 of \s-1RFC 2326.
\&\s0\f(CW\*(C`URI\*(C'\fR objects belongin ta tha rtsp scheme support tha common,
generic, n' server methods, wit tha exception of userinfo and
query-related sub-components.
.IP "\fBrtspu\fR:" 4
.IX Item "rtspu:"
Da \fIrtspu\fR \s-1URI\s0 scheme is used ta rap ta \s-1RTSP\s0 servers over \s-1UDP\s0
instead of \s-1TCP. \s0 Da syntax is tha same ol' dirty as rtsp.
.IP "\fBrsync\fR:" 4
.IX Item "rsync:"
Hype bout rsync be available from <http://rsync.samba.org/>.
\&\f(CW\*(C`URI\*(C'\fR objects belongin ta tha rsync scheme support tha common,
generic n' server methods.  In addition, they provide methodz to
access tha userinfo sub-components: \f(CW$uri\fR\->user n' \f(CW$uri\fR\->password.
.IP "\fBsip\fR:" 4
.IX Item "sip:"
Da \fIsip\fR \s-1URI\s0 justification is busted lyrics bout up in sections 19.1 n' 25
of \s-1RFC 3261.  \s0\f(CW\*(C`URI\*(C'\fR objects belongin ta tha sip scheme support the
common, generic, n' server methodz wit tha exception of path related
sub-components, n' you can put dat on yo' toast.  In addition, they provide two methodz ta git n' set
\&\fIsip\fR parameters: \f(CW$uri\fR\->params_form n' \f(CW$uri\fR\->params.
.IP "\fBsips\fR:" 4
.IX Item "sips:"
See \fIsip\fR scheme.  Its syntax is tha same ol' dirty as sip yo, but tha default
port is different.
.IP "\fBsnews\fR:" 4
.IX Item "snews:"
See \fInews\fR scheme.  Its syntax is tha same ol' dirty as shizzle yo, but tha default
port is different.
.IP "\fBtelnet\fR:" 4
.IX Item "telnet:"
An oldschool justification of tha \fItelnet\fR \s-1URI\s0 scheme is found up in \s-1RFC
1738. \s0\f(CW\*(C`URI\*(C'\fR objects belongin ta tha telnet scheme support the
common, generic n' server methods.
.IP "\fBtn3270\fR:" 4
.IX Item "tn3270:"
These URIs is used like \fItelnet\fR URIs but fo' connections ta \s-1IBM\s0
mainframes.  \f(CW\*(C`URI\*(C'\fR objects belongin ta tha tn3270 scheme support the
common, generic n' server methods.
.IP "\fBssh\fR:" 4
.IX Item "ssh:"
Hype bout ssh be available at <http://www.openssh.com/>.
\&\f(CW\*(C`URI\*(C'\fR objects belongin ta tha ssh scheme support tha common,
generic n' server methods. In addition, they provide methodz to
access tha userinfo sub-components: \f(CW$uri\fR\->user n' \f(CW$uri\fR\->password.
.IP "\fBurn\fR:" 4
.IX Item "urn:"
Da syntax of Uniform Resource Names is specified up in \s-1RFC 2141.  \s0\f(CW\*(C`URI\*(C'\fR
objects belongin ta tha urn scheme provide tha common methods, n' also the
methodz \f(CW$uri\fR\->nid n' \f(CW$uri\fR\->nss, which return tha Namespace Identifier
and tha Namespace-Specific Strin respectively.
.Sp
Da Namespace Identifier basically works like tha Scheme identifier of
URIs, n' further divides tha \s-1URN\s0 namespace.  Namespace Identifier
assignments is maintained at
<http://www.iana.org/assignments/urn\-namespaces>.
.Sp
Letta case aint dope fo' tha Namespace Identifier n' shit.  It is
always returned up in lower case by tha \f(CW$uri\fR\->nid method. Y'all KNOW dat shit, muthafucka!  Da \f(CW$uri\fR\->_nid
method can be used if you want it up in its original gangsta case.
.IP "\fBurn\fR:\fBisbn\fR:" 4
.IX Item "urn:isbn:"
Da \f(CW\*(C`urn:isbn:\*(C'\fR namespace gotz nuff Internationistic Standard Book
Numbers (ISBNs) n' is busted lyrics bout up in \s-1RFC 3187.  A \s0\f(CW\*(C`URI\*(C'\fR object belonging
to dis namespace has tha followin extra methodz (if the
Business::ISBN module be available): \f(CW$uri\fR\->isbn,
\&\f(CW$uri\fR\->isbn_publisher_code, \f(CW$uri\fR\->isbn_group_code (formerly isbn_country_code,
which is still supported by thangs a thugged-out deprecation warning), \f(CW$uri\fR\->isbn_as_ean.
.IP "\fBurn\fR:\fBoid\fR:" 4
.IX Item "urn:oid:"
Da \f(CW\*(C`urn:oid:\*(C'\fR namespace gotz nuff Object Identifiers (OIDs) n' is
busted lyrics bout up in \s-1RFC 3061. \s0 An object identifier consistz of sequencez of digits
separated by dots, n' you can put dat on yo' toast.  A \f(CW\*(C`URI\*(C'\fR object belongin ta dis namespace has an
additionizzle method called \f(CW$uri\fR\->oid dat can be used ta get/set tha oid
value.  In a list context, oid numbers is returned as separate elements.
.SH "CONFIGURATION VARIABLES"
.IX Header "CONFIGURATION VARIABLES"
Da followin configuration variablez influence how tha fuck tha class n' its
methodz behave:
.ie n .IP "$URI::ABS_ALLOW_RELATIVE_SCHEME" 4
.el .IP "\f(CW$URI::ABS_ALLOW_RELATIVE_SCHEME\fR" 4
.IX Item "$URI::ABS_ALLOW_RELATIVE_SCHEME"
Some olda parsers used ta allow tha scheme name ta be present up in the
relatizzle \s-1URL\s0 if dat shiznit was tha same ol' dirty as tha base \s-1URL\s0 scheme.  \s-1RFC 2396\s0 says
that dis should be avoided yo, but you can enable dis oldschool behaviour by
settin tha \f(CW$URI::ABS_ALLOW_RELATIVE_SCHEME\fR variable ta a \s-1TRUE\s0 value.
Da difference is demonstrated by tha followin examples:
.Sp
.Vb 2
\&  URI\->new("http:foo")\->abs("http://host/a/b")
\&      ==>  "http:foo"
\&
\&  local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
\&  URI\->new("http:foo")\->abs("http://host/a/b")
\&      ==>  "http:/host/a/foo"
.Ve
.ie n .IP "$URI::ABS_REMOTE_LEADING_DOTS" 4
.el .IP "\f(CW$URI::ABS_REMOTE_LEADING_DOTS\fR" 4
.IX Item "$URI::ABS_REMOTE_LEADING_DOTS"
Yo ass can also have tha \fIabs()\fR method ignore excess \*(L"..\*(R"
segments up in tha relatizzle \s-1URI\s0 by settin \f(CW$URI::ABS_REMOTE_LEADING_DOTS\fR
to a \s-1TRUE\s0 value.  Da difference is demonstrated by tha following
examples:
.Sp
.Vb 2
\&  URI\->new("../../../foo")\->abs("http://host/a/b")
\&      ==> "http://host/../../foo"
\&
\&  local $URI::ABS_REMOTE_LEADING_DOTS = 1;
\&  URI\->new("../../../foo")\->abs("http://host/a/b")
\&      ==> "http://host/foo"
.Ve
.ie n .IP "$URI::DEFAULT_QUERY_FORM_DELIMITER" 4
.el .IP "\f(CW$URI::DEFAULT_QUERY_FORM_DELIMITER\fR" 4
.IX Item "$URI::DEFAULT_QUERY_FORM_DELIMITER"
This value can be set ta \*(L";\*(R" ta have tha query form \f(CW\*(C`key=value\*(C'\fR pairs
delimited by \*(L";\*(R" instead of \*(L"&\*(R" which is tha default.
.SH "BUGS"
.IX Header "BUGS"
There is some thangs dat is not like right:
.IP "\(bu" 4
Usin regexp variablez like \f(CW$1\fR directly as arguments ta tha \s-1URI\s0 accessor methods
does not work too well wit current perl implementations.  I would argue
that dis is straight-up a funky-ass bug up in perl.  Da workaround is ta quote
them. Example:
.Sp
.Vb 2
\&   /(...)/ || die;
\&   $u\->query("$1");
.Ve
.IP "\(bu" 4
Da escapin (percent encoding) of chars up in tha 128 .. 255 range passed ta the
\&\s-1URI\s0 constructor or when settin \s-1URI\s0 parts rockin tha accessor methodz depend on
the state of tha internal \s-1UTF8\s0 flag (see utf8::is_utf8) of tha strang passed.
If tha \s-1UTF8\s0 flag is set tha \s-1UTF\-8\s0 encoded version of tha characta is cement
encoded. Y'all KNOW dat shit, muthafucka!  If tha \s-1UTF8\s0 flag aint set tha Latin\-1 version (byte) of the
characta is cement encoded. Y'all KNOW dat shit, muthafucka!  This basically exposes tha internal encodin of
Perl strings.
.SH "PARSING URIs WITH REGEXP"
.IX Header "PARSING URIs WITH REGEXP"
As a alternatizzle ta dis module, tha followin (official) regular
expression can be used ta decode a \s-1URI:\s0
.PP
.Vb 2
\&  my($scheme, $authority, $path, $query, $fragment) =
\&  $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\e?([^#]*))?(?:#(.*))?|;
.Ve
.PP
Da \f(CW\*(C`URI::Split\*(C'\fR module serves up tha function \fIuri_split()\fR as a
readable alternative.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
URI::file, URI::WithBase, URI::QueryParam, URI::Escape,
URI::Split, URI::Heuristic
.PP
\&\s-1RFC 2396: \s0\*(L"Uniform Resource Identifiers (\s-1URI\s0): Generic Syntax\*(R",
Berners-Lee, Fielding, Masinter, August 1998.
.PP
<http://www.iana.org/assignments/uri\-schemes>
.PP
<http://www.iana.org/assignments/urn\-namespaces>
.PP
<http://www.w3.org/Addressing/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2009 Gisle Aas.
.PP
Copyright 1995 Martijn Koster.
.PP
This program is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
.SH "AUTHORS / ACKNOWLEDGMENTS"
.IX Header "AUTHORS / ACKNOWLEDGMENTS"
This module is based on tha \f(CW\*(C`URI::URL\*(C'\fR module, which up in turn was
(distantly) based on tha \f(CW\*(C`wwwurl.pl\*(C'\fR code up in tha libwww-perl for
perl4 pimped by Roy Fielding, as part of tha Arcadia project at the
Universitizzle of California, Irvine, wit contributions from Brooks
Cutter.
.PP
\&\f(CW\*(C`URI::URL\*(C'\fR was pimped by Gisle Aas, Slim Tim Bunce, Roy Fieldin and
Martijn Kosta wit input from other playas on tha libwww-perl mailing
list.
.PP
\&\f(CW\*(C`URI\*(C'\fR n' related subclasses was pimped by Gisle Aas.
