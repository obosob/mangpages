.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Complex 3pm"
.TH Math::Complex 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Complex \- complex numbers n' associated mathematical functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Math::Complex;
\&
\&        $z = Math::Complex\->make(5, 6);
\&        $t = 4 \- 3*i + $z;
\&        $j = cplxe(1, 2*pi/3);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package lets you create n' manipulate complex numbers. By default,
\&\fIPerl\fR limits itself ta real numbers yo, but a extra \f(CW\*(C`use\*(C'\fR statement brangs
full complex support, along wit a gangbangin' full set of mathematical functions
typically associated wit and/or extended ta complex numbers.
.PP
If you wonder what tha fuck complex numbers are, they was invented ta be able ta solve
the followin equation:
.PP
.Vb 1
\&        x*x = \-1
.Ve
.PP
and by definition, tha solution is noted \fIi\fR (engineers use \fIj\fR instead since
\&\fIi\fR probably denotes a intensitizzle yo, but tha name do not matter). Da number
\&\fIi\fR be a pure \fIimaginary\fR number.
.PP
Da arithmetics wit pure imaginary numbers works just like you would expect
it wit real numbers... you just gotta remember that
.PP
.Vb 1
\&        i*i = \-1
.Ve
.PP
so you have:
.PP
.Vb 5
\&        5i + 7i = i * (5 + 7) = 12i
\&        4i \- 3i = i * (4 \- 3) = i
\&        4i * 2i = \-8
\&        6i / 2i = 3
\&        1 / i = \-i
.Ve
.PP
Complex numbers is numbers dat have both a real part n' a imaginary
part, n' is probably noted:
.PP
.Vb 1
\&        a + bi
.Ve
.PP
where \f(CW\*(C`a\*(C'\fR is tha \fIreal\fR part n' \f(CW\*(C`b\*(C'\fR is tha \fIimaginary\fR part. The
arithmetic wit complex numbers is straightforward. Y'all KNOW dat shit, muthafucka! Yo ass have to
keep track of tha real n' tha imaginary parts yo, but otherwise the
rulez used fo' real numbers just apply:
.PP
.Vb 2
\&        (4 + 3i) + (5 \- 2i) = (4 + 5) + i(3 \- 2) = 9 + i
\&        (2 + i) * (4 \- i) = 2*4 + 4i \-2i \-i*i = 8 + 2i + 1 = 9 + 2i
.Ve
.PP
A graphical representation of complex numbers is possible up in a plane
(also called tha \fIcomplex plane\fR yo, but itz straight-up a 2D plane).
Da number
.PP
.Vb 1
\&        z = a + bi
.Ve
.PP
is tha point whose coordinates is (a, b) fo' realz. Actually, it would
be tha vector originatin from (0, 0) ta (a, b). Well shiiiit, it bigs up dat tha addition
of two complex numbers be a vectorial addition.
.PP
Since there be a funky-ass bijection between a point up in tha 2D plane n' a cold-ass lil complex
number (i.e. tha mappin is unique n' reciprocal), a cold-ass lil complex number
can also be uniquely identified wit polar coordinates:
.PP
.Vb 1
\&        [rho, theta]
.Ve
.PP
where \f(CW\*(C`rho\*(C'\fR is tha distizzle ta tha origin, n' \f(CW\*(C`theta\*(C'\fR tha angle between
the vector n' tha \fIx\fR axis. There be a notation fo' dis rockin the
exponential form, which is:
.PP
.Vb 1
\&        rho * exp(i * theta)
.Ve
.PP
where \fIi\fR is tha hyped imaginary number introduced above. Conversion
between dis form n' tha cartesian form \f(CW\*(C`a + bi\*(C'\fR is immediate:
.PP
.Vb 2
\&        a = rho * cos(theta)
\&        b = rho * sin(theta)
.Ve
.PP
which be also expressed by dis formula:
.PP
.Vb 1
\&        z = rho * exp(i * theta) = rho * (cos theta + i * sin theta)
.Ve
.PP
In other lyrics, itz tha projection of tha vector onto tha \fIx\fR n' \fIy\fR
axes. Mathematicians call \fIrho\fR tha \fInorm\fR or \fImodulus\fR n' \fItheta\fR
the \fIargument\fR of tha complex number n' shit. Da \fInorm\fR of \f(CW\*(C`z\*(C'\fR is
marked here as \f(CWabs(z)\fR.
.PP
Da polar notation (also known as tha trigonometric representation) is
much mo' handy fo' struttin multiplications n' divisions of
complex numbers, whilst tha cartesian notation is betta suited for
additions n' subtractions. Real numbers is on tha \fIx\fR axis, and
therefore \fIy\fR or \fItheta\fR is zero or \fIpi\fR.
.PP
All tha common operations dat can be performed on a real number have
been defined ta work on complex numbers as well, n' is merely
\&\fIextensions\fR of tha operations defined on real numbers. This means
they keep they natural meanin when there is no imaginary part, provided
the number is within they definizzle set.
.PP
For instance, tha \f(CW\*(C`sqrt\*(C'\fR routine which computes tha square root of
its argument is only defined fo' non-negatizzle real numbers n' yieldz a
non-negatizzle real number (it be a application from \fBR+\fR ta \fBR+\fR).
If we allow it ta return a cold-ass lil complex number, then it can be extended to
negatizzle real numbers ta become a application from \fBR\fR ta \fBC\fR (the
set of complex numbers):
.PP
.Vb 1
\&        sqrt(x) = x >= 0 ? sqrt(x) : sqrt(\-x)*i
.Ve
.PP
It can also be extended ta be a application from \fBC\fR ta \fBC\fR,
whilst its restriction ta \fBR\fR behaves as defined above by using
the followin definition:
.PP
.Vb 1
\&        sqrt(z = [r,t]) = sqrt(r) * exp(i * t/2)
.Ve
.PP
Indeed, a wack real number can be noted \f(CW\*(C`[x,pi]\*(C'\fR (the modulus
\&\fIx\fR be always non-negative, so \f(CW\*(C`[x,pi]\*(C'\fR is straight-up \f(CW\*(C`\-x\*(C'\fR, a negative
number) n' tha above definizzle states that
.PP
.Vb 1
\&        sqrt([x,pi]) = sqrt(x) * exp(i*pi/2) = [sqrt(x),pi/2] = sqrt(x)*i
.Ve
.PP
which is exactly what tha fuck our crazy asses had defined fo' wack real numbers above.
Da \f(CW\*(C`sqrt\*(C'\fR returns only one of tha solutions: if you want tha both,
use tha \f(CW\*(C`root\*(C'\fR function.
.PP
All tha common mathematical functions defined on real numbers that
are extended ta complex numbers share dat same property of working
\&\fIas usual\fR when tha imaginary part is zero (otherwise, it would not
be called a extension, would it?).
.PP
A \fInew\fR operation possible on a cold-ass lil complex number dat is
the identitizzle fo' real numbers is called tha \fIconjugate\fR, n' is noted
with a horizontal bar above tha number, or \f(CW\*(C`~z\*(C'\fR here.
.PP
.Vb 2
\&         z = a + bi
\&        ~z = a \- bi
.Ve
.PP
Simple... Now look:
.PP
.Vb 1
\&        z * ~z = (a + bi) * (a \- bi) = a*a + b*b
.Ve
.PP
We saw dat tha norm of \f(CW\*(C`z\*(C'\fR was noted \f(CWabs(z)\fR n' was defined as the
distizzle ta tha origin, also known as:
.PP
.Vb 1
\&        rho = abs(z) = sqrt(a*a + b*b)
.Ve
.PP
so
.PP
.Vb 1
\&        z * ~z = abs(z) ** 2
.Ve
.PP
If z be a pure real number (i.e. \f(CW\*(C`b == 0\*(C'\fR), then tha above yields:
.PP
.Vb 1
\&        a * a = abs(a) ** 2
.Ve
.PP
which is legit (\f(CW\*(C`abs\*(C'\fR has tha regular meanin fo' real number, i.e. stands
for tha absolute value). This example explains why tha norm of \f(CW\*(C`z\*(C'\fR is
noted \f(CWabs(z)\fR: it extendz tha \f(CW\*(C`abs\*(C'\fR function ta complex numbers, yet
is tha regular \f(CW\*(C`abs\*(C'\fR we know when tha complex number straight-up has no
imaginary part... This justifies \fIa posteriori\fR our use of tha \f(CW\*(C`abs\*(C'\fR
notation fo' tha norm.
.SH "OPERATIONS"
.IX Header "OPERATIONS"
Given tha followin notations:
.PP
.Vb 3
\&        z1 = a + bi = r1 * exp(i * t1)
\&        z2 = c + di = r2 * exp(i * t2)
\&        z = <any complex or real number>
.Ve
.PP
the followin (overloaded) operations is supported on complex numbers:
.PP
.Vb 10
\&        z1 + z2 = (a + c) + i(b + d)
\&        z1 \- z2 = (a \- c) + i(b \- d)
\&        z1 * z2 = (r1 * r2) * exp(i * (t1 + t2))
\&        z1 / z2 = (r1 / r2) * exp(i * (t1 \- t2))
\&        z1 ** z2 = exp(z2 * log z1)
\&        ~z = a \- bi
\&        abs(z) = r1 = sqrt(a*a + b*b)
\&        sqrt(z) = sqrt(r1) * exp(i * t/2)
\&        exp(z) = exp(a) * exp(i * b)
\&        log(z) = log(r1) + i*t
\&        sin(z) = 1/2i (exp(i * z1) \- exp(\-i * z))
\&        cos(z) = 1/2 (exp(i * z1) + exp(\-i * z))
\&        atan2(y, x) = atan(y / x) # Mindin tha right quadrant, note tha order.
.Ve
.PP
Da definizzle used fo' complex argumentz of \fIatan2()\fR is
.PP
.Vb 1
\&       \-i log((x + iy)/sqrt(x*x+y*y))
.Ve
.PP
Note dat atan2(0, 0) aint well-defined.
.PP
Da followin extra operations is supported on both real n' complex
numbers:
.PP
.Vb 4
\&        Re(z) = a
\&        Im(z) = b
\&        arg(z) = t
\&        abs(z) = r
\&
\&        cbrt(z) = z ** (1/3)
\&        log10(z) = log(z) / log(10)
\&        logn(z, n) = log(z) / log(n)
\&
\&        tan(z) = sin(z) / cos(z)
\&
\&        csc(z) = 1 / sin(z)
\&        sec(z) = 1 / cos(z)
\&        cot(z) = 1 / tan(z)
\&
\&        asin(z) = \-i * log(i*z + sqrt(1\-z*z))
\&        acos(z) = \-i * log(z + i*sqrt(1\-z*z))
\&        atan(z) = i/2 * log((i+z) / (i\-z))
\&
\&        acsc(z) = asin(1 / z)
\&        asec(z) = acos(1 / z)
\&        acot(z) = atan(1 / z) = \-i/2 * log((i+z) / (z\-i))
\&
\&        sinh(z) = 1/2 (exp(z) \- exp(\-z))
\&        cosh(z) = 1/2 (exp(z) + exp(\-z))
\&        tanh(z) = sinh(z) / cosh(z) = (exp(z) \- exp(\-z)) / (exp(z) + exp(\-z))
\&
\&        csch(z) = 1 / sinh(z)
\&        sech(z) = 1 / cosh(z)
\&        coth(z) = 1 / tanh(z)
\&
\&        asinh(z) = log(z + sqrt(z*z+1))
\&        acosh(z) = log(z + sqrt(z*z\-1))
\&        atanh(z) = 1/2 * log((1+z) / (1\-z))
\&
\&        acsch(z) = asinh(1 / z)
\&        asech(z) = acosh(1 / z)
\&        acoth(z) = atanh(1 / z) = 1/2 * log((1+z) / (z\-1))
.Ve
.PP
\&\fIarg\fR, \fIabs\fR, \fIlog\fR, \fIcsc\fR, \fIcot\fR, \fIacsc\fR, \fIacot\fR, \fIcsch\fR,
\&\fIcoth\fR, \fIacosech\fR, \fIacotanh\fR, have aliases \fIrho\fR, \fItheta\fR, \fIln\fR,
\&\fIcosec\fR, \fIcotan\fR, \fIacosec\fR, \fIacotan\fR, \fIcosech\fR, \fIcotanh\fR,
\&\fIacosech\fR, \fIacotanh\fR, respectively.  \f(CW\*(C`Re\*(C'\fR, \f(CW\*(C`Im\*(C'\fR, \f(CW\*(C`arg\*(C'\fR, \f(CW\*(C`abs\*(C'\fR,
\&\f(CW\*(C`rho\*(C'\fR, n' \f(CW\*(C`theta\*(C'\fR can be used also as mutators.  Da \f(CW\*(C`cbrt\*(C'\fR
returns only one of tha solutions: if you want all three, use the
\&\f(CW\*(C`root\*(C'\fR function.
.PP
Da \fIroot\fR function be available ta compute all tha \fIn\fR
rootz of some complex, where \fIn\fR be a strictly positizzle integer.
There is exactly \fIn\fR such roots, returned as a list. Gettin the
number mathematicians call \f(CW\*(C`j\*(C'\fR such that:
.PP
.Vb 1
\&        1 + j + j*j = 0;
.Ve
.PP
is a simple matta of writing:
.PP
.Vb 1
\&        $j = ((root(1, 3))[1];
.Ve
.PP
Da \fIk\fRth root fo' \f(CW\*(C`z = [r,t]\*(C'\fR is given by:
.PP
.Vb 1
\&        (root(z, n))[k] = r**(1/n) * exp(i * (t + 2*k*pi)/n)
.Ve
.PP
Yo ass can return tha \fIk\fRth root directly by \f(CW\*(C`root(z, n, k)\*(C'\fR,
indexin startin from \fIzero\fR n' endin at \fIn \- 1\fR.
.PP
Da \fIspaceship\fR numeric comparison operator, <=>, be also
defined. Y'all KNOW dat shit, muthafucka! In order ta ensure its restriction ta real numbers is conform
to what tha fuck you would expect, tha comparison is run on tha real part of
the complex number first, n' imaginary parts is compared only when
the real parts match.
.SH "CREATION"
.IX Header "CREATION"
To create a cold-ass lil complex number, use either:
.PP
.Vb 2
\&        $z = Math::Complex\->make(3, 4);
\&        $z = cplx(3, 4);
.Ve
.PP
if you know tha cartesian form of tha number, or
.PP
.Vb 1
\&        $z = 3 + 4*i;
.Ve
.PP
if you like. To create a number rockin tha polar form, use either:
.PP
.Vb 2
\&        $z = Math::Complex\->emake(5, pi/3);
\&        $x = cplxe(5, pi/3);
.Ve
.PP
instead. Y'all KNOW dat shit, muthafucka! Da first argument is tha modulus, tha second is tha angle
(in radians, tha full circle is 2*pi).  (Mnemonic: \f(CW\*(C`e\*(C'\fR is used as a
notation fo' complex numbers up in tha polar form).
.PP
It be possible ta write:
.PP
.Vb 1
\&        $x = cplxe(\-3, pi/4);
.Ve
.PP
but dat is ghon be silently converted tha fuck into \f(CW\*(C`[3,\-3pi/4]\*(C'\fR, since the
modulus must be non-negatizzle (it represents tha distizzle ta tha origin
in tha complex plane).
.PP
It be also possible ta git a cold-ass lil complex number as either argument of the
\&\f(CW\*(C`make\*(C'\fR, \f(CW\*(C`emake\*(C'\fR, \f(CW\*(C`cplx\*(C'\fR, n' \f(CW\*(C`cplxe\*(C'\fR: tha appropriate component of
the argument is ghon be used.
.PP
.Vb 2
\&        $z1 = cplx(\-2,  1);
\&        $z2 = cplx($z1, 4);
.Ve
.PP
Da \f(CW\*(C`new\*(C'\fR, \f(CW\*(C`make\*(C'\fR, \f(CW\*(C`emake\*(C'\fR, \f(CW\*(C`cplx\*(C'\fR, n' \f(CW\*(C`cplxe\*(C'\fR will also
understand a single (string) argument of tha forms
.PP
.Vb 5
\&        2\-3i
\&        \-3i
\&        [2,3]
\&        [2,\-3pi/4]
\&        [2]
.Ve
.PP
in which case tha appropriate cartesian n' exponential components
will be parsed from tha strang n' used ta create freshly smoked up complex numbers.
Da imaginary component n' tha theta, respectively, will default ta zero.
.PP
Da \f(CW\*(C`new\*(C'\fR, \f(CW\*(C`make\*(C'\fR, \f(CW\*(C`emake\*(C'\fR, \f(CW\*(C`cplx\*(C'\fR, n' \f(CW\*(C`cplxe\*(C'\fR will also
understand tha case of no arguments: dis means plain zero or (0, 0).
.SH "DISPLAYING"
.IX Header "DISPLAYING"
When printed, a cold-ass lil complex number is probably shown under its cartesian
style \fIa+bi\fR yo, but there be legitimate cases where tha polar style
\&\fI[r,t]\fR is mo' appropriate.  Da process of convertin tha complex
number tha fuck into a strang dat can be displayed is known as \fIstringification\fR.
.PP
By callin tha class method \f(CW\*(C`Math::Complex::display_format\*(C'\fR and
supplyin either \f(CW"polar"\fR or \f(CW"cartesian"\fR as a argument, you
override tha default display style, which is \f(CW"cartesian"\fR. Not
supplyin any argument returns tha current settings.
.PP
This default can be overridden on a per-number basis by callin the
\&\f(CW\*(C`display_format\*(C'\fR method instead. Y'all KNOW dat shit, muthafucka! As before, not supplyin any argument
returns tha current display steez fo' dis number n' shit. Otherwise whatever you
specify is ghon be tha freshly smoked up display steez fo' \fIthis\fR particular number.
.PP
For instance:
.PP
.Vb 1
\&        use Math::Complex;
\&
\&        Math::Complex::display_format(\*(Aqpolar\*(Aq);
\&        $j = (root(1, 3))[1];
\&        print "j = $j\en";               # Prints "j = [1,2pi/3]"
\&        $j\->display_format(\*(Aqcartesian\*(Aq);
\&        print "j = $j\en";               # Prints "j = \-0.5+0.866025403784439i"
.Ve
.PP
Da polar steez attempts ta emphasize arguments like \fIk*pi/n\fR
(where \fIn\fR be a positizzle integer n' \fIk\fR a integer within [\-9, +9]),
this is called \fIpolar pretty-printing\fR.
.PP
For tha reverse of stringifying, peep tha \f(CW\*(C`make\*(C'\fR n' \f(CW\*(C`emake\*(C'\fR.
.SS "\s-1CHANGED IN PERL 5.6\s0"
.IX Subsection "CHANGED IN PERL 5.6"
Da \f(CW\*(C`display_format\*(C'\fR class method n' tha corresponding
\&\f(CW\*(C`display_format\*(C'\fR object method can now be called using
a parameta hash instead of just a one parameter.
.PP
Da oldschool display format style, which can have joints \f(CW"cartesian"\fR or
\&\f(CW"polar"\fR, can be chizzled rockin tha \f(CW"style"\fR parameter.
.PP
.Vb 1
\&        $j\->display_format(style => "polar");
.Ve
.PP
Da one parameta callin convention also still works.
.PP
.Vb 1
\&        $j\->display_format("polar");
.Ve
.PP
There is two freshly smoked up display parameters.
.PP
Da first one is \f(CW"format"\fR, which be a \fIsprintf()\fR\-style format string
to be used fo' both numeric partz of tha complex number(s).  Da is
somewhat system-dependent but most often it correspondz ta \f(CW"%.15g"\fR.
Yo ass can revert ta tha default by settin tha \f(CW\*(C`format\*(C'\fR ta \f(CW\*(C`undef\*(C'\fR.
.PP
.Vb 1
\&        # tha $j from tha above example
\&
\&        $j\->display_format(\*(Aqformat\*(Aq => \*(Aq%.5f\*(Aq);
\&        print "j = $j\en";               # Prints "j = \-0.50000+0.86603i"
\&        $j\->display_format(\*(Aqformat\*(Aq => undef);
\&        print "j = $j\en";               # Prints "j = \-0.5+0.86603i"
.Ve
.PP
Notice dat dis affects also tha return jointz of the
\&\f(CW\*(C`display_format\*(C'\fR methods: up in list context tha whole parameta hash
will be returned, as opposed ta only tha steez parameta value.
This be a potential incompatibilitizzle wit earlier versions if you
have been callin tha \f(CW\*(C`display_format\*(C'\fR method up in list context.
.PP
Da second freshly smoked up display parameta is \f(CW"polar_pretty_print"\fR, which can
be set ta legit or false, tha default bein true.  See tha previous
section fo' what tha fuck dis means.
.SH "USAGE"
.IX Header "USAGE"
Thanks ta overloading, tha handlin of arithmetics wit complex numbers
is simple n' almost transparent.
.PP
Here is some examples:
.PP
.Vb 1
\&        use Math::Complex;
\&
\&        $j = cplxe(1, 2*pi/3);  # $j ** 3 == 1
\&        print "j = $j, j**3 = ", $j ** 3, "\en";
\&        print "1 + j + j**2 = ", 1 + $j + $j**2, "\en";
\&
\&        $z = \-16 + 0*i;                 # Force it ta be a cold-ass lil complex
\&        print "sqrt($z) = ", sqrt($z), "\en";
\&
\&        $k = exp(i * 2*pi/3);
\&        print "$j \- $k = ", $j \- $k, "\en";
\&
\&        $z\->Re(3);                      # Re, Im, arg, abs,
\&        $j\->arg(2);                     # (the last two aka rho, theta)
\&                                        # can be used also as mutators.
.Ve
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.SS "\s-1PI\s0"
.IX Subsection "PI"
Da constant \f(CW\*(C`pi\*(C'\fR n' some handy multiplez of it (pi2, pi4,
and pip2 (pi/2) n' pip4 (pi/4)) is also available if separately
exported:
.PP
.Vb 2
\&    use Math::Complex \*(Aq:pi\*(Aq; 
\&    $third_of_circle = pi2 / 3;
.Ve
.SS "Inf"
.IX Subsection "Inf"
Da floatin point infinitizzle can be exported as a subroutine \fIInf()\fR:
.PP
.Vb 4
\&    use Math::Complex qw(Inf sinh);
\&    mah $AlsoInf = Inf() + 42;
\&    mah $AnotherInf = sinh(1e42);
\&    print "$AlsoInf is $AnotherInf\en" if $AlsoInf == $AnotherInf;
.Ve
.PP
Note dat tha stringified form of infinitizzle varies between platforms:
it can be fo' example any of
.PP
.Vb 4
\&   inf
\&   infinity
\&   INF
\&   1.#INF
.Ve
.PP
or it can be suttin' else.
.PP
Also note dat up in some platforms tryin ta use tha infinitizzle in
arithmetic operations may result up in Perl crashin cuz using
an infinitizzle causes \s-1SIGFPE\s0 or its moral equivalent ta be sent.
Da way ta ignore dis is
.PP
.Vb 1
\&  local $SIG{FPE} = sub { };
.Ve
.SH "ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO"
.IX Header "ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO"
Da division (/) n' tha followin functions
.PP
.Vb 5
\&        log     ln      log10   logn
\&        tan     sec     csc     cot
\&        atan    asec    acsc    acot
\&        tanh    sech    csch    coth
\&        atanh   asech   acsch   acoth
.Ve
.PP
cannot be computed fo' all arguments cuz dat would mean dividing
by zero or takin logarithm of zero. These thangs cause fatal
runtime errors lookin like this
.PP
.Vb 3
\&        cot(0): Division by zero.
\&        (Because up in tha definizzle of cot(0), tha divisor sin(0) is 0)
\&        Died at ...
.Ve
.PP
or
.PP
.Vb 2
\&        atanh(\-1): Logarithm of zero.
\&        Died at...
.Ve
.PP
For tha \f(CW\*(C`csc\*(C'\fR, \f(CW\*(C`cot\*(C'\fR, \f(CW\*(C`asec\*(C'\fR, \f(CW\*(C`acsc\*(C'\fR, \f(CW\*(C`acot\*(C'\fR, \f(CW\*(C`csch\*(C'\fR, \f(CW\*(C`coth\*(C'\fR,
\&\f(CW\*(C`asech\*(C'\fR, \f(CW\*(C`acsch\*(C'\fR, tha argument cannot be \f(CW0\fR (zero).  For the
logarithmic functions n' tha \f(CW\*(C`atanh\*(C'\fR, \f(CW\*(C`acoth\*(C'\fR, tha argument cannot
be \f(CW1\fR (one).  For tha \f(CW\*(C`atanh\*(C'\fR, \f(CW\*(C`acoth\*(C'\fR, tha argument cannot be
\&\f(CW\*(C`\-1\*(C'\fR (minus one).  For tha \f(CW\*(C`atan\*(C'\fR, \f(CW\*(C`acot\*(C'\fR, tha argument cannot be
\&\f(CW\*(C`i\*(C'\fR (the imaginary unit).  For tha \f(CW\*(C`atan\*(C'\fR, \f(CW\*(C`acoth\*(C'\fR, tha argument
cannot be \f(CW\*(C`\-i\*(C'\fR (the wack imaginary unit).  For tha \f(CW\*(C`tan\*(C'\fR,
\&\f(CW\*(C`sec\*(C'\fR, \f(CW\*(C`tanh\*(C'\fR, tha argument cannot be \fIpi/2 + k * pi\fR, where \fIk\fR
is any integer n' shit.  atan2(0, 0) is undefined, n' if tha complex arguments
are used fo' \fIatan2()\fR, a gangbangin' finger-lickin' division by zero will happen if z1**2+z2**2 == 0.
.PP
Note dat cuz we is operatin on approximationz of real numbers,
these errors can happen when merely `too close' ta tha singularities
listed above.
.SH "ERRORS DUE TO INDIGESTIBLE ARGUMENTS"
.IX Header "ERRORS DUE TO INDIGESTIBLE ARGUMENTS"
Da \f(CW\*(C`make\*(C'\fR n' \f(CW\*(C`emake\*(C'\fR accept both real n' complex arguments.
When they cannot recognize tha arguments they will take a thugged-out dirtnap wit error
lyrics like tha following
.PP
.Vb 4
\&    Math::Complex::make: Cannot take real part of ...
\&    Math::Complex::make: Cannot take real part of ...
\&    Math::Complex::emake: Cannot take rho of ...
\&    Math::Complex::emake: Cannot take theta of ...
.Ve
.SH "BUGS"
.IX Header "BUGS"
Sayin \f(CW\*(C`use Math::Complex;\*(C'\fR exports nuff mathematical routines up in the
calla environment n' even overrides some (\f(CW\*(C`sqrt\*(C'\fR, \f(CW\*(C`log\*(C'\fR, \f(CW\*(C`atan2\*(C'\fR).
This is construed as a gangbangin' feature by tha Authors, actually... ;\-)
.PP
All routines expect ta be given real or complex numbers. Don't attempt to
use BigFloat, since Perl has currently no rule ta disambiguate a '+'
operation (for instance) between two overloaded entities.
.PP
In Cray \s-1UNICOS\s0 there is some strange numerical instabilitizzle dat thangs up in dis biatch
in \fIroot()\fR, \fIcos()\fR, \fIsin()\fR, \fIcosh()\fR, \fIsinh()\fR, losin accuracy fast.  Beware.
Da bug may be up in \s-1UNICOS\s0 math libs, up in \s-1UNICOS C\s0 compiler, up in Math::Complex.
Whatever it is, it do not manifest itself anywhere else where Perl runs.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::Trig
.SH "AUTHORS"
.IX Header "AUTHORS"
Daniel S. Lewart <\fIlewart!at!uiuc.edu\fR>,
Jarkko Hietaniemi <\fIjhi!at!iki.fi\fR>,
Raphael Manfredi <\fIRaphael_Manfredi!at!pobox.com\fR>,
Zefram <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
