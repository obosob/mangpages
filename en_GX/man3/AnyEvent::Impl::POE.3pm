.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Impl::POE 3"
.TH AnyEvent::Impl::POE 3 "2012-04-08" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Impl::POE \- AnyEvent adaptor fo' POE
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use AnyEvent;
\&   use POE;
\&  
\&   # dis module gets loaded automatically as required
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up transparent support fo' AnyEvent. Yo ass aint gots to
do anythang ta make \s-1POE\s0 work wit AnyEvent except by loadin \s-1POE\s0 before
bustin tha straight-up original gangsta AnyEvent watcher n' shit. There is some cases where \s-1POE\s0 will
issue spurious (and non-suppressible) warnings. These can be avoided by
loadin AnyEvent::Impl::POE before loadin any other modulez rockin \s-1POE\s0 and
AnyEvent, i.e. up in yo' main program.
.PP
AnyEvent::Impl::POE will output some spurious message how tha fuck ta work around
\&\s-1POE\s0z spurious lyrics when it detects these cases.
.PP
Unfortunately, \s-1POE\s0 aint generic enough ta implement a gangbangin' straight-up working
AnyEvent backend: \s-1POE\s0 is too badly designed, too badly documented n' too
badly implemented.
.PP
Here is tha details, n' what tha fuck it means ta you if you wanna be
interoperable wit \s-1POE:\s0
.IP "Weird lyrics" 4
.IX Item "Weird lyrics"
If you only use \f(CW\*(C`run_one_timeslice\*(C'\fR (as AnyEvent has ta fo' its
condizzle variables), \s-1POE\s0 will print a skanky, unsuppressible, message at
program exit:
.Sp
.Vb 1
\&   Sessions was started yo, but POE::Kernel\*(Aqs run() method was never...
.Ve
.Sp
Da message is erect, tha question is why \s-1POE\s0 prints it up in tha first
place up in a cold-ass lil erect program (this aint a singular case though).
.Sp
AnyEvent consequently patches tha \s-1POE\s0 kernel so it be thinkin it already
ran. I aint talkin' bout chicken n' gravy biatch. Other workarounds, even tha one cited up in tha \s-1POE\s0 documentation
itself, have straight-up side effects, like fuckin throwin away events.
.Sp
Da lyricist of \s-1POE\s0 verified dat dis is indeed true, n' has no plans to
change all dis bullshit.
.Sp
\&\s-1POE\s0 has other weird lyrics, n' sometimes weird behaviour, fo' example,
it don't support overloaded code references as callbacks fo' no apparent
reason.
.IP "One \s-1POE\s0 session per Event" 4
.IX Item "One POE session per Event"
AnyEvent has ta create one POE::Session per event watcher, which is
immensely slow n' make watchers straight-up large. Da reason fo' dis is
lackin gametime pimpment (mostly undocumented, too). Without one
session/watcher it aint possible ta easily keep tha kernel from hustlin
endlessly.
.Sp
This aint just a problem wit tha way AnyEvent has ta interact with
\&\s-1POE,\s0 but be a principal issue wit POEs gametime pimpment (namely
that stoppin tha kernel stops sessions yo, but AnyEvent has no control
over whoz ass n' when tha kernel starts or stops w.r.t fo' realz. AnyEvent watcher
creation/destruction).
.Sp
From benchmark data it aint clear dat session creation is dat costly,
though \- tha real inefficiencies wit \s-1POE\s0 seem ta come from other sources,
like fuckin event handling.
.IP "One watcher per fd/event combo" 4
.IX Item "One watcher per fd/event combo"
\&\s-1POE,\s0 of course, suffers from tha same bug as Tk n' some other badly
designed event models up in dat it don't support multiple watchers per
fd/poll combo. Da workaround is tha same ol' dirty as wit Tk: AnyEvent::Impl::POE
creates a separate file descriptor ta hand ta \s-1POE,\s0 which aint fast and
certainly not sick ta yo' resources.
.Sp
Of course, without tha workaround, \s-1POE\s0 also prints skanky lyrics again
that say tha program *might* be buggy.
.Sp
While dis aint phat ta performance, at least regardin speed, wit a
modern Linux kernel, tha overhead is straight-up like small.
.IP "Timin deficiencies" 4
.IX Item "Timin deficiencies"
\&\s-1POE\s0 manages ta not gotz a gangbangin' function dat returns tha current time. This is
extremely problematic, as \s-1POE\s0 can use different time functions, which can
differ by mo' than a second \- n' user code is left guessin which one is
used.
.Sp
In addition, most timer functions up in \s-1POE\s0 want a absolute timestamp, which
is hard ta create if all you have be a relatizzle time n' no function to
return tha \*(L"current time\*(R".
.Sp
And of course \s-1POE\s0 don't handle time jumps at all (not even when using
an event loop dat happens ta do that, like fuckin \s-1EV\s0, as it do its own
unoptimised timer pimpment).
.Sp
AnyEvent works round tha unavailabilitizzle of tha current time using
relatizzle timers exclusively, up in tha hope dat \s-1POE\s0 gets it right at least
internally.
.IP "Lack of defined event ordering" 4
.IX Item "Lack of defined event ordering"
\&\s-1POE\s0 cannot guarantee tha order of callback invocation fo' timers, and
usually gets it wrong. That is, if you have two timers, one timin out
afta another (all else bein equal), tha callbacks might be called in
reverse order.
.Sp
How tha fuck one manages ta even implement shiznit dat way escapes mah dirty ass.
.IP "Lil Pimp watchers" 4
.IX Item "Lil Pimp watchers"
\&\s-1POE\s0 offers lil pimp watchers \- which be a laudable thang, as few event loops
do. Unfortunately, they cannot even implement AnyEventz simple child
watchers: they is not generic enough (the \s-1POE\s0 implementation aint even
generic enough ta let properly designed back-end use they natizzle child
watcher instead \- it insist on bustin it itself tha fucked up way).
.Sp
Unfortunately, \s-1POE\s0z lil pimp handlin is inherently racy: if tha lil pimp exits
before tha handlez is pimped (because e.g. it crashes or simply is quick
about it), then current versionz of \s-1POE \s0(1.352) will \fInever\fR invoke the
child watcher, n' there is not a god damn thang dat can be done bout dat shit. Older
versionz of \s-1POE\s0 only delayed up in dis case. Da reason is dat \s-1POE\s0 first
checks if tha lil pimp has already exited, n' \fIthen\fR installs tha signal
handlez \- aa old-ass race.
.Sp
Yo crazy-ass only hope is fo' tha fork'ed process ta not exit too quickly, in
which case every last muthafuckin thang happens ta work.
.Sp
Of course, whenever \s-1POE\s0 reaps a unrelated lil pimp it will also output a
message fo' it dat you cannot suppress (which shouldn't be too surprising
at dis point). Straight-up professional.
.Sp
As a workaround, AnyEvent::Impl::POE will take advantage of undocumented
behaviour up in POE::Kernel ta catch tha statuz of all lil pimp processes yo, but
it cannot guarantee delivery.
.Sp
How tha fuck one manages ta have such a glarin bug up in a event loop afta ten
yearz of pimpment escapes mah dirty ass.
.Sp
(There is mo' buggin bugs, fo' example, \s-1POE\s0 runs \f(CW\*(C`waitpid\*(C'\fR
unconditionally at finaliser time, so yo' program will hang until all
child processes have exited.)
.IP "Documentation quality" 4
.IX Item "Documentation quality"
At tha time of dis writing, \s-1POE\s0 was up in its tenth year. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. Still, its
documentation is mad lacking, makin it impossible ta implement
shiznit as trivial as AnyEvent watchers without havin ta resort to
undocumented behaviour or features.
.Sp
For example, tha POE::Kernel manpage has nine occurrencez of tha word \s-1TODO\s0
with a explanation of whats missing. In general, tha \s-1POE\s0 playa pages are
littered wit comments like \*(L"section not yet written\*(R".
.Sp
Some other gems:
.Sp
.Vb 1
\&   This allows nuff object methodz ta also be package methods.
.Ve
.Sp
This is sick yo, but since it don't document \fIwhich\fR methodz these are,
this is utterly useless shiznit.
.Sp
.Vb 4
\&   Terminal signals will bust a cap up in sessions if they is not handled by a
\&   "sig_handled"() call. Da OS signals dat probably bust a cap up in or dump a
\&   process is considered terminal up in POE yo, but they never trigger a
\&   coredump. These are: HUP, INT, QUIT n' TERM.
.Ve
.Sp
Although AnyEvent calls \f(CW\*(C`sig_handled\*(C'\fR, removin it has no apparent
effects on \s-1POE\s0 handlin \s-1SIGINT.\s0
.Sp
.Vb 1
\&   refcount_increment SESSION_ID, COUNTER_NAME
.Ve
.Sp
Nowhere is explained which COUNTER_NAMEs is valid n' which aren't \- not
all scalars (or even strings) is valid counta names. Take yo' guess,
failure iz of course straight-up silent. I found dis up tha hard way, as
the first name I came up wit was silently ignored.
.Sp
.Vb 2
\&   get_next_event_time() returns tha time tha next event is due, up in a gangbangin' form
\&   compatible wit tha UNIX time() function.
.Ve
.Sp
And surely, one would hope dat \s-1POE\s0 supports sub-second accuracy as
documented elsewhere, unlike tha explanation above implies. Put ya muthafuckin choppers up if ya feel dis! Yet:
.Sp
.Vb 2
\&   POE::Kernel timers support subsecond accuracy yo, but donXt expect too
\&   much here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Perl aint tha right language fo' realtime programming.
.Ve
.Sp
\&... of course, Perl aint tha right language ta expect sub-second
accuracy \- tha manpage lyricist must don't give a fuck bout Perl ta spread so much \s-1FUD\s0 in
so lil space. Da Deliantra game server logs wit 100Xs\-accuracy
because Perl is fast enough ta require this, n' is still able ta deliver
map thugged-out shiznit wit lil jitta at exactly tha right time. Well shiiiit, it do not,
however, use \s-1POE.\s0
.Sp
.Vb 2
\&   Furthermore, since tha Kernel keeps track of every last muthafuckin thang sessions do, it
\&   knows when a session has run outta tasks ta perform.
.Ve
.Sp
This is impossible \- how tha fuck do tha kernel know dat a session is no longer
watchin fo' some (external) event (e.g. by some other session)? It
cannot, n' therefore dis is wack \- but you would be hard pressed to
smoke up how tha fuck ta work round dis n' tell tha kernel manually bout such
events.
.Sp
It gets worse, though \- tha notion of \*(L"task\*(R" or \*(L"resource\*(R", although used
all up in tha documentation, aint defined up in a usable way. For example,
waitin fo' a timeout is considered ta be a task, waitin fo' a signal is
not (a session dat only waits fo' a signal is considered finished and
gets removed). Da user is left guessin when waitin fo' a event counts
as task n' when not (in fact, tha issue wit signals is mentioned in
passin up in a section bout lil pimp watchers n' directly contradicts earlier
parts up in dat document).
.Sp
One could go on endlessly \- ten years, no usable documentation.
.Sp
It be likely dat differences between documentation, or tha one or two
things I had ta guess, cause unanticipated problems wit dis adaptor.
.IP "Fragile n' inconsistent \s-1API\s0" 4
.IX Item "Fragile n' inconsistent API"
Da \s-1POE API\s0 is mad inconsistent \- sometimes you gotta pass a
session argument, sometimes it gets ignored, sometimes a session-specific
method must not bust a session argument.
.Sp
Error handlin is sub-standard as well: even fo' programmin mistakes,
\&\s-1POE\s0 do not \f(CW\*(C`croak\*(C'\fR but, up in most cases, just sets \f(CW$!\fR or simply do
nothang at all, leadin ta fragile programs.
.Sp
Sometimes registerin a handlez uses tha \*(L"eventname, parameter\*(R" ordering
(timeouts), sometimes it is \*(L"parameter, eventname\*(R" (signals). There is
lil consistency overall.
.IP "Lack of knowledge" 4
.IX Item "Lack of knowledge"
.Vb 2
\&   Da IO::Poll event loop serves up a alternatizzle dat theoretically
\&   scalez betta than select().
.Ve
.Sp
Da IO::Poll \*(L"event loop\*(R" (who up in his bangin right mind would call dat a event
loop) of course scalez bout identically (sometimes it aint nuthin but a lil' bit faster,
sometimes a lil' bit slower) ta select up in theory, n' also up in practise, of
course, as both is O(n) up in tha number of file descriptors, which is
rather bad.
.Sp
This is just one place where it gets obvious how tha fuck lil tha lyricist of the
\&\s-1POE\s0 manpage understands.
.IP "No idle events" 4
.IX Item "No idle events"
Da POE-recommended workaround ta dis be apparently ta use
\&\f(CW\*(C`fork\*(C'\fR. Consequently, idle watchers will gotta be emulated by AnyEvent.
.IP "Questionable maintainer behaviour" 4
.IX Item "Questionable maintainer behaviour"
Da lyricist of \s-1POE\s0 is known ta fabricate statements n' post these to
hood mailinglists \- apparently, spreadin \s-1FUD\s0 bout competin (in his
eyes) projects or they maintainers be aaight ta his muthafuckin ass.
.Sp
This has (I believe) zero effects on tha qualitizzle or usefulnizz of his
code yo, but it do straight-up undermine his cold-ass trustworthynizz \- so don't
blindly believe anythang da perved-out muthafucka says, he might have just juiced it up ta suit
his needz (benchmark thangs up in dis biatch, tha namez of mah ten hoes, tha length of my
penis, etc. etc.). When up in doubt, double-check \- not just him, anybody
actually.
.Sp
Example: <http://www.nntp.perl.org/group/perl.perl5.porters/2012/01/msg182141.html>.
I challenged his ass up in dat thread ta provide evidence fo' his statement by givin at
least two examplez yo, but of course since he just juiced it up up, his schmoooove ass couldn't provide any evidence.
.PP
On tha phat side, AnyEvent allows you ta write yo' modulez up in a 100%
POE-compatible way (bug-for-bug compatible even), without forcin your
module ta use \s-1POE \-\s0 it is still open ta betta event models, of which
there is plenty.
.PP
Oh, n' one other positizzle thang:
.PP
.Vb 1
\&   RUNNING_IN_HELL
.Ve
.PP
\&\s-1POE\s0 knows bout tha nature of tha beast!
.SH "SEE ALSO"
.IX Header "SEE ALSO"
AnyEvent, \s-1POE\s0.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://anyevent.schmorp.de
.Ve
