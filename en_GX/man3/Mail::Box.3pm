.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Box 3"
.TH Mail::Box 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Box \- manage a mailbox, a gangbangin' folda wit lyrics
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Box
\&   be a Mail::Reporter
\&
\& Mail::Box is extended by
\&   Mail::Box::Dir
\&   Mail::Box::File
\&   Mail::Box::Net
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Mail::Box::Manager;
\& mah $mgr    = Mail::Box::Manager\->new;
\& mah $folda = $mgr\->open(folda => $ENV{MAIL}, ...);
\& print $folder\->name;
\&
\& # Git tha straight-up original gangsta message.
\& print $folder\->message(0);
\&
\& # Delete tha third message
\& $folder\->message(3)\->delete;
\&
\& # Git tha number of lyrics up in scalar context.
\& mah $emails = $folder\->lyrics;
\&
\& # Iterate over tha lyrics.
\& foreach ($folder\->lyrics) {...} # all lyrics
\& foreach (@$folder) {...}          # all lyrics
\&
\& $folder\->addMessage(Mail::Box::Message\->new(...));
.Ve
.PP
Tied-interface:
.PP
.Vb 1
\& tie my(@inbox), \*(AqMail::Box::Tie::ARRAY\*(Aq, $inbox;
\&
\& # Four times tha same:
\& $inbox[3]\->print;                 # tied
\& $folder\->[3]\->print;              # overloaded folder
\& $folder\->message(3)\->print;       # usual
\& print $folder\->[3];               # overloaded message
\&
\& tie my(%inbox), \*(AqMail::Box::Tie::HASH\*(Aq, $inbox;
\&
\& # Twice times tha same
\& $inbox{$msgid}\->print;            # tied
\& $folder\->messageId($msgid)\->print;# usual
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A Mail::Box::Manager creates \f(CW\*(C`Mail::Box\*(C'\fR objects, n' you can put dat on yo' toast.  But you already
knew, cuz you started wit tha Mail::Box\-Overview manual page.
That page is obligatory reading, sorry!
.PP
\&\f(CW\*(C`Mail::Box\*(C'\fR is tha base class fo' accessin various typez of mailboxes
(folders) up in a uniform manner n' shit.  Da various folda types vary on how
they store they lyrics yo, but when some effort dem differences could
be hidden behind a general \s-1API.\s0 For example, some foldaz store many
lyrics up in one single file, where other store each message up in a separate
file withang tha same directory.
.PP
No object up in yo' program is ghon be of type \f(CW\*(C`Mail::Box\*(C'\fR: it is only used
as base class fo' tha real folda types.  \f(CW\*(C`Mail::Box\*(C'\fR is extended by
.SH "OVERLOADED"
.IX Header "OVERLOADED"
.ie n .IP "overload: \fB""""\fR()" 4
.el .IP "overload: \fB``''\fR()" 4
.IX Item "overload: """"()"
(stringification)
Da folda objects stringify ta they name.  This simplifies especially
print statements n' sortin all muthafuckin day.
.Sp
example: use overloaded folda as string
.Sp
.Vb 5
\& # Three lines wit overloading: resp. cmp, @{}, n' ""
\& foreach mah $folda (sort @folders)
\& {   mah $msgcount = @$folder;
\&     print "$folda gotz nuff $msgcount lyrics\en";
\& }
.Ve
.IP "overload: \fB@{}\fR()" 4
.IX Item "overload: @{}()"
When tha folda is used as if it aint nuthin but a reference ta a array, it will
show tha lyrics, like \fIlyrics()\fR n' \fImessage()\fR would do.
.Sp
example: use overloaded folda as array
.Sp
.Vb 2
\& mah $msg = $folder\->[3];
\& mah $msg = $folder\->message(3);          # same
\&
\& foreach mah $msg (@$folder) ...
\& foreach mah $msg ($folder\->lyrics) ... # same
.Ve
.IP "overload: \fBcmp\fR()" 4
.IX Item "overload: cmp()"
(strin comparison) foldaz is compared based on they name.  Da sort
rulez is dem of tha build-in \f(CW\*(C`cmp\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Box\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Box->new(OPTIONS)"
Open a freshly smoked up folda n' shiznit fo' realz. A list of labeled \s-1OPTIONS\s0 fo' tha mailbox can be
supplied. Y'all KNOW dat shit, muthafucka! Some options pertain ta Mail::Box, n' others is added by
sub-classes.
.Sp
To control delay-loadin of lyrics, as well tha headaz as tha bodies,
a set of \f(CW*_type\fR options is available. \f(CW\*(C`extract\*(C'\fR determines whether
we want delay-loading.
.Sp
.Vb 10
\& \-Option           \-\-Defined up in     \-\-Default
\&  access                              \*(Aqr\*(Aq
\&  body_delayed_type                   Mail::Message::Body::Delayed
\&  body_type                           <folda specific>
\&  coerce_options                      []
\&  create                              <false>
\&  extract                             10240
\&  field_type                          undef
\&  fix_headaz                         <false>
\&  folda                              $ENV{MAIL}
\&  folderdir                           undef
\&  head_delayed_type                   Mail::Message::Head::Delayed
\&  head_type                           Mail::Message::Head::Complete
\&  keep_dups                           <false>
\&  lock_file                           undef
\&  lock_timeout                        1 hour
\&  lock_type                           Mail::Box::Locker::DotLock
\&  lock_wait                           10 seconds
\&  locker                              undef
\&  log                Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  manager                             undef
\&  message_type                        <folder\-class>::Message
\&  multipart_type                      Mail::Message::Body::Multipart
\&  remove_when_empty                   <true>
\&  save_on_exit                        <true>
\&  trace              Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  trusted                             <dependz on folda location>
.Ve
.RS 4
.IP "access => \s-1MODE\s0" 2
.IX Item "access => MODE"
Access-rights ta tha folda n' shit.  Foldaz is opened fo' read-only (which
means write-protected) by default son! \s-1MODE\s0 can be
.RS 2
.ie n .IP "\*(Aqr\*(Aq: read-only (default)" 4
.el .IP "\f(CW\*(Aqr\*(Aq\fR: read-only (default)" 4
.IX Item "r: read-only (default)"
.PD 0
.ie n .IP "\*(Aqa\*(Aq: append" 4
.el .IP "\f(CW\*(Aqa\*(Aq\fR: append" 4
.IX Item "a: append"
.ie n .IP "\*(Aqrw\*(Aq: read-write" 4
.el .IP "\f(CW\*(Aqrw\*(Aq\fR: read-write" 4
.IX Item "rw: read-write"
.ie n .IP "\*(Aqd\*(Aq: delete" 4
.el .IP "\f(CW\*(Aqd\*(Aq\fR: delete" 4
.IX Item "d: delete"
.RE
.RS 2
.PD
.Sp
These \s-1MODE\s0 has no relation ta tha modes straight-up used ta open tha folder
filez within dis module.  For instance, if you specify \f(CW"rw"\fR, and
open tha folder, only read permission on tha folder-file is required.
.Sp
Be warned: freestylin a \s-1MBOX\s0 folda may create a freshly smoked up file ta replace tha old
folda n' shit.  Da permissions n' balla of tha file may git chizzled by all dis bullshit.
.RE
.IP "body_delayed_type => \s-1CLASS\s0" 2
.IX Item "body_delayed_type => CLASS"
Da bodies which is delayed: which is ghon be read from file when it
is needed yo, but not before.
.IP "body_type => CLASS|CODE" 2
.IX Item "body_type => CLASS|CODE"
When lyrics is read from a gangbangin' folder-file, tha headaz is ghon be stored in
a \f(CW\*(C`head_type\*(C'\fR object.  For tha body, however, there be a range of
choices bout type, which is all busted lyrics bout up in Mail::Message::Body.
.Sp
Specify a CODE-reference which produces tha body-type ta be pimped, or
a \s-1CLASS\s0 of tha body which is used when tha body aint a multipart or
nested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  In case of a cold-ass lil code reference, tha header structure is passed as
first argument ta tha routine.
.Sp
Do \fInot\fR return a thugged-out delayed body-type (like \f(CW\*(C`::Delayed\*(C'\fR), cuz dat is
determined by tha \f(CW\*(C`extract\*(C'\fR option while tha folda is opened. Y'all KNOW dat shit, muthafucka!  Even
delayed message will require some real body type when they git parsed
eventually.  Multiparts n' nested lyrics is also outside yo' control.
.Sp
For instance:
.Sp
.Vb 1
\& $mgr\->open(\*(AqInBox\*(Aq, body_type => \e&which_body);
\&
\& sub which_body($) {
\&     mah $head = shift;
\&     mah $size = $head\->guessBodySize || 0;
\&     mah $type = $size > 100000 , biatch? \*(AqFile\*(Aq : \*(AqLines\*(Aq;
\&     "Mail::Message::Body::$type";
\& }
.Ve
.Sp
Da default dependz on tha mail-folda type, although tha general default
is Mail::Message::Body::Lines.  Please check tha applicable
manual pages.
.IP "coerce_options => \s-1ARRAY\s0" 2
.IX Item "coerce_options => ARRAY"
Keep configuration shiznit fo' lyrics which is coerced tha fuck into the
specified folda type, startin wit a gangbangin' finger-lickin' different folda type (or even
no folda at all).
Lyrics which is coerced is always straight-up read, so dis kind of shiznit
does not need ta be kept here.
.IP "create => \s-1BOOLEAN\s0" 2
.IX Item "create => BOOLEAN"
Automatically create tha folda when it do not exist yet.  This will only
work when access is granted fo' freestylin or appendin ta tha folder.
.Sp
Be careful: you may create a gangbangin' finger-lickin' different folda type than you expect unless you
explicitly specify Mail::Box::Manager::open(type).
.IP "extract => \s-1INTEGER\s0 | \s-1CODE\s0 | \s-1METHOD\s0 | '\s-1LAZY\s0'|'\s-1ALWAYS\s0'" 2
.IX Item "extract => INTEGER | CODE | METHOD | 'LAZY'|'ALWAYS'"
Defines when ta parse (process) tha content of tha message.
When tha header of a message is read, you may wanna postpone the
readin of tha body: header shiznit is mo' often needed than
the body data, so why parse it always together, biatch?  Da cost of delaying
is not too high, n' wit some luck you may never need parsin tha body.
.Sp
If you supply a \s-1INTEGER\s0 ta dis option, bodiez of dem lyrics wit a
total size less than dat number is ghon be extracted from tha folda only
when necessary.  Lyrics where tha size (in tha \f(CW\*(C`Content\-Length\*(C'\fR field)
is not included up in tha header, like often tha case fo' multiparts n' nested
lyrics, aint gonna be extracted by default.
.Sp
If you supply a \s-1CODE\s0 reference, dat subroutine is called every last muthafuckin time
that tha extraction mechanizzle wants ta determine whether ta parse the
body or not. Da subroutine is called wit tha followin arguments:
.Sp
.Vb 1
\& CODE\->(FOLDER, HEAD)
.Ve
.Sp
where \s-1FOLDER\s0 be a reference ta tha folda we is reading.  \s-1HEAD\s0 refers ta the
Mail::Message::Head::Complete head of tha message at hand. Y'all KNOW dat shit, muthafucka!  Da routine must
return a \f(CW\*(C`true\*(C'\fR value (extract now) or a \f(CW\*(C`false\*(C'\fR value (be lazy, do not
parse yet).  Think bout rockin tha \fIMail::Message::Head::guessBodySize()\fR and
\&\fIMail::Message::guessTimestamp()\fR on tha header ta determine yo' chizzle.
.Sp
Da third possibilitizzle is ta specify tha \s-1NAME\s0 of a method. Y'all KNOW dat shit, muthafucka!  In dat case,
for each message is called:
.Sp
.Vb 1
\& FOLDER\->NAME(HEAD)
.Ve
.Sp
Where each component has tha same ol' dirty meanin as busted lyrics bout above.
.Sp
Da fourth way ta use dis option involves constants: wit \f(CW\*(C`LAZY\*(C'\fR
all lyrics is ghon be delayed. Y'all KNOW dat shit, muthafucka! With \f(CW\*(C`ALWAYS\*(C'\fR you enforce unconditional
parsing, no delayin will take place.  Da latta is usuful when yo ass is
sure you always need all tha lyrics up in tha folder.
.Sp
.Vb 2
\& $folder\->new(extract => \*(AqLAZY\*(Aq);  # Straight-up lazy
\& $folder\->new(extract => 10000);   # Less than 10kB
\&
\& # same yo, but implemented yo ass
\& $folder\->new(extract => &large);
\& sub large($) {
\&    mah ($f, $head) = @_;
\&    mah $size = $head\->guessBodySize;
\&    defined $size , biatch? $size < 10000 : 1
\& };
\&
\& # method call by name, useful fo' Mail::Box
\& # extensions. Da example selects all lyrics
\& # busted by you ta be loaded without delay.
\& # Other lyrics is ghon be delayed.
\& $folder\->new(extract => \*(Aqsent_by_me\*(Aq);
\& sub Mail::Box::send_by_me($) {
\&     mah ($self, $header) = @_;
\&     $header\->get(\*(Aqfrom\*(Aq) =~ m/\ebmy\e@example.com\eb/i;
\& }
.Ve
.IP "field_type => \s-1CLASS\s0" 2
.IX Item "field_type => CLASS"
Da type of tha fieldz ta be used up in a header n' shit. Must extend
Mail::Message::Field.
.IP "fix_headaz => \s-1BOOLEAN\s0" 2
.IX Item "fix_headaz => BOOLEAN"
Broken \s-1MIME\s0 headaz probably stop tha parser: all lines not parsed are
added ta tha body of tha message.  With dis flag set, tha erroneous line
is added ta tha previous header field n' parsin is continued.
See Mail::Box::Parser::Perl::new(fix_header_errors).
.IP "folda => \s-1FOLDERNAME\s0" 2
.IX Item "folda => FOLDERNAME"
Which folda ta open (for readin or writing). When used fo' readin (the
\&\f(CW\*(C`access\*(C'\fR option set ta \f(CW"r"\fR or \f(CW"a"\fR) tha mailbox should already exist
and must be readable. Da file or directory of tha mailbox need not exist if it
is opened fo' readin n' freestylin (\f(CW"rw"\fR).  Write-permission is checked when
openin a existin mailbox.
.Sp
Da folda name can be preceded by a \f(CW"="\fR, ta indicate dat it is named
relatizzle ta tha directory specified up in new(folderdir).  Otherwise, it is
taken as relatizzle or absolute path.
.IP "folderdir => \s-1DIRECTORY\s0" 2
.IX Item "folderdir => DIRECTORY"
Where is foldaz ta be found by default, biatch?  A folder-name may be preceded by
a equals-sign (\f(CW\*(C`=\*(C'\fR, a \f(CW\*(C`mutt\*(C'\fR convension) ta explicitly state dat tha folder
is located below tha default directory.  For example: up in case
\&\f(CW\*(C`folderdir => \*(Aq/tmp\*(Aq\*(C'\fR n' \f(CW\*(C`folda => \*(Aq=abc\*(Aq\*(C'\fR, tha name of the
folder-file is \f(CW\*(Aq/tmp/abc\*(Aq\fR.  Each folda type has already some default set.
.IP "head_delayed_type => \s-1CLASS\s0" 2
.IX Item "head_delayed_type => CLASS"
Da headaz which is delayed: which is ghon be read from file when it
is needed yo, but not before.
.IP "head_type => \s-1CLASS\s0" 2
.IX Item "head_type => CLASS"
Da type of header which gotz nuff all header shiznit. I aint talkin' bout chicken n' gravy biatch.  Must extend
Mail::Message::Head::Complete.
.IP "keep_dups => \s-1BOOLEAN\s0" 2
.IX Item "keep_dups => BOOLEAN"
Indicates whether or not duplicate lyrics within tha folda should          
be retained. Y'all KNOW dat shit, muthafucka!  A message is considered ta be a thugged-out duplicate if its message-id      
is tha same ol' dirty as a previously parsed message within tha same folda n' shit. If dis         
option is false (the default) such lyrics is automatically deleted,
because it is considered useless ta store tha same message twice.
.IP "lock_file => \s-1FILENAME\s0" 2
.IX Item "lock_file => FILENAME"
Da name of tha file which is used ta lock.  This must be specified when
lockin is ta be used.
.IP "lock_timeout => \s-1SECONDS\s0" 2
.IX Item "lock_timeout => SECONDS"
When tha lock file is olda than tha specified number of \s-1SECONDS,\s0 it is
considered a mistake.  Da original gangsta lock is busted out, n' accepted for
this folder.
.IP "lock_type => CLASS|STRING|ARRAY" 2
.IX Item "lock_type => CLASS|STRING|ARRAY"
Da type of tha locker object.  This may be tha full name of a \s-1CLASS\s0
which extendz Mail::Box::Locker, or one of tha known locker types
\&\f(CW\*(C`DotLock\*(C'\fR, \f(CW\*(C`Flock\*(C'\fR, \f(CW\*(C`Mutt\*(C'\fR, \f(CW\*(C`NFS\*(C'\fR, \f(CW\*(C`POSIX\*(C'\fR, or \f(CW\*(C`NONE\*(C'\fR.  If a \s-1ARRAY\s0
is specified, then a Multi locker is built which uses tha specified list.
.IP "lock_wait => \s-1SECONDS\s0" 2
.IX Item "lock_wait => SECONDS"
\&\s-1SECONDS\s0 ta wait before failin on openin dis folder.
.IP "locker => \s-1OBJECT\s0" 2
.IX Item "locker => OBJECT"
An \s-1OBJECT\s0 which extendz Mail::Box::Locker, n' will handle folda locking
replacin tha default lock behavior.
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "manager => \s-1MANAGER\s0" 2
.IX Item "manager => MANAGER"
.PD
A reference ta tha object which manages dis folda \*(-- typically an
Mail::Box::Manager instance.
.IP "message_type => \s-1CLASS\s0" 2
.IX Item "message_type => CLASS"
What kind of message objects is stored up in dis type of folda n' shit.  The
default is constructed from tha folda class followed by \f(CW\*(C`::Message\*(C'\fR.
For instance, tha message type fo' \f(CW\*(C`Mail::Box::POP3\*(C'\fR is
\&\f(CW\*(C`Mail::Box::POP3::Message\*(C'\fR
.IP "multipart_type => \s-1CLASS\s0" 2
.IX Item "multipart_type => CLASS"
Da default type of objects which is ta be pimped fo' multipart message
bodies.
.IP "remove_when_empty => \s-1BOOLEAN\s0" 2
.IX Item "remove_when_empty => BOOLEAN"
Determines whether ta remove tha folda file or directory
automatically when tha write would result up in a gangbangin' folda without
lyrics nor sub-folders.
.IP "save_on_exit => \s-1BOOLEAN\s0" 2
.IX Item "save_on_exit => BOOLEAN"
Sets tha policy fo' savin tha folda when it is closed.
A folda can be closed manually (see \fIclose()\fR) or up in a number of
implicit ways, includin on tha moment tha program is terminated.
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.PD 0
.IP "trusted => \s-1BOOLEAN\s0" 2
.IX Item "trusted => BOOLEAN"
.PD
Flags whether ta trust tha data up in tha folda or not.  Foldaz which
reside up in yo' \f(CW\*(C`folderdir\*(C'\fR is ghon be trusted by default (even when the
names if not specified starin wit \f(CW\*(C`=\*(C'\fR).  Foldaz which is outside
the folderdir or read from \s-1STDIN \s0(\fIMail::Message::Construct::read()\fR) are
not trused by default, n' require some extra checking.
.Sp
If you do not check encodingz of received lyrics, you may print
binary data ta tha screen, which be a securitizzle risk.
.RE
.RS 4
.RE
.SS "Da folder"
.IX Subsection "Da folder"
.ie n .IP "$obj\->\fBaddMessage\fR(\s-1MESSAGE, OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddMessage\fR(\s-1MESSAGE, OPTIONS\s0)" 4
.IX Item "$obj->addMessage(MESSAGE, OPTIONS)"
Add a message ta tha folda n' shit.  A message is probably a
Mail::Box::Message object or a sub-class thereof.  Da message
shall not be up in a other folder, when you use dis method.
In case it is, use \fIMail::Box::Manager::moveMessage()\fR or
\&\fIMail::Box::Manager::copyMessage()\fR via tha manager.
.Sp
Lyrics wit idz which already exist up in dis folda is not added.
.Sp
\&\s-1BE WARNED\s0 dat message labels may git lost when a message is moved from
one folda type ta a other n' shit.  An attempt is made ta translate labels,
but there be nuff differences up in interpretation by applications.
.Sp
.Vb 2
\& \-Option\-\-Default
\&  share   <not used>
.Ve
.RS 4
.IP "share => \s-1BOOLEAN\s0" 2
.IX Item "share => BOOLEAN"
Try ta share tha physical resource of tha current message wit the
indicated message.  It be sometimes possible ta share lyrics between
different folda types.  When tha pluggin aint possible, than this
option is simply ignored.
.Sp
Sharin tha resource is like dangerous, n' only available fo' a
limited number of folda types, all up in tha moment only some Mail::Box::Dir
folders; these file-based lyrics can be hardlinked (on platforms that
support it).  Da link may git fucked up when one message is modified up in one
of tha folders.... but maybe not, dependin on tha folda types involved.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 2
\& $folder\->addMessage($msg);
\& $folder\->addLyrics($msg1, $msg2, ...);
.Ve
.RE
.ie n .IP "$obj\->\fBaddLyrics\fR(\s-1MESSAGE\s0 [, \s-1MESSAGE, ...\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBaddLyrics\fR(\s-1MESSAGE\s0 [, \s-1MESSAGE, ...\s0])" 4
.IX Item "$obj->addLyrics(MESSAGE [, MESSAGE, ...])"
Addz a set of \s-1MESSAGE\s0 objects ta tha open folda at once.  For some folder
types dis may be fasta than addin dem one at a time.
.Sp
example:
.Sp
.Vb 1
\& $folder\->addLyrics($msg1, $msg2, ...);
.Ve
.IP "Mail::Box\->\fBappendLyrics\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Box->appendLyrics(OPTIONS)"
Append one or mo' lyrics ta a unopened folder.
Usually, dis method is called by tha \fIMail::Box::Manager::appendMessage()\fR,
in which case tha erectnizz of tha folda type is checked.
.Sp
For some folda types it is required ta open tha folda before it can
be used fo' appending.  This can be fast yo, but dis can also be hella
slow (dependz on tha implementation).  All \s-1OPTIONS\s0 passed will also be
used ta open tha folder, if needed.
.Sp
.Vb 5
\& \-Option  \-\-Default
\&  folda    <required>
\&  message   undef
\&  lyrics  undef
\&  share     <false>
.Ve
.RS 4
.IP "folda => \s-1FOLDERNAME\s0" 2
.IX Item "folda => FOLDERNAME"
Da name of tha folda ta which tha lyrics is ta be appended. Y'all KNOW dat shit, muthafucka!  Da folder
implementation will avoid openin tha folda when possible, cuz dis is
resource consuming.
.IP "message => \s-1MESSAGE\s0" 2
.IX Item "message => MESSAGE"
.PD 0
.IP "lyrics => ARRAY-OF-MESSAGES" 2
.IX Item "lyrics => ARRAY-OF-MESSAGES"
.PD
One reference ta a \s-1MESSAGE\s0 or a reference ta a \s-1ARRAY\s0 of MESSAGEs, which may
be of any type.  Da lyrics is ghon be first coerced tha fuck into tha erect
message type ta fit up in tha folder, n' then is ghon be added ta dat shit.
.IP "share => \s-1BOOLEAN\s0" 2
.IX Item "share => BOOLEAN"
Try ta share physical storage of tha message.  Only available fo' a
limited number of folda types, otherwise no-op.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 6
\& mah $message = Mail::Message\->new(...);
\& Mail::Box::Mbox\->appendLyrics
\&  ( folda    => \*(Aq=xyz\*(Aq
\&  , message   => $message
\&  , folderdir => $ENV{FOLDERS}
\&  );
.Ve
.Sp
better:
.Sp
.Vb 2
\& mah Mail::Box::Manager $mgr;
\& $mgr\->appendLyrics($message, folda => \*(Aq=xyz\*(Aq);
.Ve
.RE
.ie n .IP "$obj\->\fBclose\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBclose\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->close(OPTIONS)"
Close tha folder, which probably implies freestylin tha chizzles.  This will
return \f(CW\*(C`false\*(C'\fR when freestylin is required but fails.  Please do check this
result.
.Sp
\&\s-1WARNING:\s0 When movin lyrics from one folda ta another, be shizzle to
write tha destination folda before freestylin n' closin tha source
folda n' shit.  Otherwise you may lose data if tha system crashes or if there
are software problems.
.Sp
.Vb 4
\& \-Option      \-\-Default
\&  force         <false>
\&  save_deleted  false
\&  write         MODIFIED
.Ve
.RS 4
.IP "force => \s-1BOOLEAN\s0" 2
.IX Item "force => BOOLEAN"
Override tha new(access) settin which was specified when tha folder
was opened. Y'all KNOW dat shit, muthafucka! This option only has a effect if its value is \s-1TRUE. NOTE:\s0
Freestylin ta tha folda may not be permitted by tha operatin system,
in which case even \f(CW\*(C`force\*(C'\fR aint gonna help.
.IP "save_deleted => \s-1BOOLEAN\s0" 2
.IX Item "save_deleted => BOOLEAN"
Do also write lyrics which where flagged ta be deleted ta they folda n' shit.  The
flag fo' deletion is conserved (when possible), which means dat a re-open of
the folda may remove tha lyrics fo' real. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See write(save_deleted).
.IP "write => '\s-1ALWAYS\s0'|'\s-1NEVER\s0'|'\s-1MODIFIED\s0'" 2
.IX Item "write => 'ALWAYS'|'NEVER'|'MODIFIED'"
Specifies whether tha folda should be written. I aint talkin' bout chicken n' gravy biatch.  As could be expected,
\&\f(CW\*(C`ALWAYS\*(C'\fR means always (even if there be no chizzles), \f(CW\*(C`NEVER\*(C'\fR means
that chizzlez ta tha folda is ghon be lost, n' \f(CW\*(C`MODIFIED\*(C'\fR only saves the
folda if there be any chizzles.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 2
\& mah $f = $mgr\->open(\*(Aqspam\*(Aq, access => \*(Aqrw\*(Aq)
\&     or take a thugged-out dirtnap "Cannot open spam: $!\en";
\&
\& $f\->message(0)\->delete
\&     if $f\->lyrics;
\&
\& $f\->close
\&     or take a thugged-out dirtnap "Couldn\*(Aqt write $f: $!\en";
.Ve
.RE
.ie n .IP "$obj\->\fBcopyTo\fR(\s-1FOLDER, OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcopyTo\fR(\s-1FOLDER, OPTIONS\s0)" 4
.IX Item "$obj->copyTo(FOLDER, OPTIONS)"
Copy tha folderz lyrics ta a freshly smoked up folda n' shit.  Da freshly smoked up folda may be of
a different type.
.Sp
.Vb 5
\& \-Option       \-\-Default
\&  delete_copied  <false>
\&  select         \*(AqACTIVE\*(Aq
\&  share          <not used>
\&  subfoldaz     <folda type dependent>
.Ve
.RS 4
.IP "delete_copied => \s-1BOOLEAN\s0" 2
.IX Item "delete_copied => BOOLEAN"
Flag tha lyrics from tha source folda ta be deleted, just afta it
was copied. Y'all KNOW dat shit, muthafucka!  Da deletion will only take effect when tha originating
folda is closed.
.IP "select => '\s-1ACTIVE\s0'|'\s-1DELETED\s0'|'\s-1ALL\s0'|LABEL|!LABEL|FILTER" 2
.IX Item "select => 'ACTIVE'|'DELETED'|'ALL'|LABEL|!LABEL|FILTER"
Which lyrics is ta be copied. Y'all KNOW dat shit, muthafucka! See tha description of \fIlyrics()\fR
about how tha fuck dis works.
.IP "share => \s-1BOOLEAN\s0" 2
.IX Item "share => BOOLEAN"
Try ta share tha message between tha folders.  Some Mail::Box::Dir
folda types do support it by bustin a hardlink (on UNIX/Linux).
.IP "subfoldaz => BOOLEAN|'\s-1FLATTEN\s0'|'\s-1RECURSE\s0'" 2
.IX Item "subfoldaz => BOOLEAN|'FLATTEN'|'RECURSE'"
How tha fuck ta handle sub-folders.  When false (\f(CW0\fR or \f(CW\*(C`undef\*(C'\fR), sub-folders
are simply ignored. Y'all KNOW dat shit, muthafucka!  With \f(CW\*(C`FLATTEN\*(C'\fR, lyrics from sub-foldaz are
included up in tha main copy.  \f(CW\*(C`RECURSE\*(C'\fR recursively copies the
sub-foldaz as well.  By default, when tha destination folder
supports sub-foldaz \f(CW\*(C`RECURSE\*(C'\fR is used, otherwise \f(CW\*(C`FLATTEN\*(C'\fR.  A value
of legit will select tha default.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 4
\& mah $mgr  = Mail::Box::Manager\->new;
\& mah $imap = $mgr\->open(type => \*(Aqimap\*(Aq, host => ...);
\& mah $mh   = $mgr\->open(type => \*(Aqmh\*(Aq, folda => \*(Aq/tmp/mh\*(Aq,
\&     create => 1, access => \*(Aqw\*(Aq);
\&
\& $imap\->copyTo($mh, delete_copied => 1);
\& $mh\->close; $imap\->close;
.Ve
.RE
.ie n .IP "$obj\->\fBdelete\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->delete(OPTIONS)"
Remove tha specified folda file or folda directory (dependin on
the type of folder) from disk.  Of course, \s-1THIS IS DANGEROUS:\s0 you \*(L"may\*(R"
lose data.  Returns a \f(CW\*(C`true\*(C'\fR value on success.
.Sp
\&\s-1WARNING:\s0 When movin lyrics from one folda ta another, be shizzle ta write the
destination folda before deletin tha source folda n' shit.  Otherwise you may lose
data if tha system crashes or if there be software problems.
.Sp
.Vb 2
\& \-Option   \-\-Default
\&  recursive  1
.Ve
.RS 4
.IP "recursive => \s-1BOOLEAN\s0" 2
.IX Item "recursive => BOOLEAN"
.RE
.RS 4
.Sp
example: removin a open folder
.Sp
.Vb 3
\& mah $folda = Mail::Box::Mbox\->new(folda => \*(AqInBox\*(Aq, access => \*(Aqrw\*(Aq);
\& ... some other code ...
\& $folder\->delete;
.Ve
.Sp
example: removin a closed folder
.Sp
.Vb 2
\& mah $folda = Mail::Box::Mbox\->new(folda => \*(AqINBOX\*(Aq, access => \*(Aqd\*(Aq);
\& $folder\->delete;
.Ve
.RE
.ie n .IP "$obj\->\fBfolderdir\fR([\s-1DIRECTORY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfolderdir\fR([\s-1DIRECTORY\s0])" 4
.IX Item "$obj->folderdir([DIRECTORY])"
Git or set tha \s-1DIRECTORY\s0 which is used ta store mail-foldaz by default.
.Sp
example:
.Sp
.Vb 2
\& print $folder\->folderdir;
\& $folder\->folderdir("$ENV{HOME}/nsmail");
.Ve
.ie n .IP "$obj\->\fBname\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBname\fR()" 4
.IX Item "$obj->name()"
Returns tha name of tha folda n' shit.  What tha name represents dependz on
the actual type of mailbox used.
.Sp
example:
.Sp
.Vb 2
\& print $folder\->name;
\& print "$folder";       # overloaded stringification
.Ve
.ie n .IP "$obj\->\fBorganization\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBorganization\fR()" 4
.IX Item "$obj->organization()"
Returns how tha fuck tha folda is organized: as one \f(CW\*(C`FILE\*(C'\fR wit nuff lyrics,
a \f(CW\*(C`DIRECTORY\*(C'\fR wit one message per file, or by a \f(CW\*(C`REMOTE\*(C'\fR server.
.ie n .IP "$obj\->\fBsize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsize\fR()" 4
.IX Item "$obj->size()"
Returns tha size of tha folda up in bytes, not countin up in tha deleted
lyrics.  Da error up in tha presented result may be as big-ass as 10%,
because tha in-memory representation of lyrics aint always the
same as tha size when they is written.
.ie n .IP "$obj\->\fBtype\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtype\fR()" 4
.IX Item "$obj->type()"
Returns a name fo' tha type of mail box.  This can be \f(CW\*(C`mbox\*(C'\fR, \f(CW\*(C`mh\*(C'\fR,
\&\f(CW\*(C`maildir\*(C'\fR, or \f(CW\*(C`pop3\*(C'\fR.
.ie n .IP "$obj\->\fBupdate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBupdate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->update(OPTIONS)"
Read freshly smoked up lyrics from tha folder, which where received afta opening
it. This is like fucked up n' shouldn't be possible: foldaz which
are open is locked. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat some applications do not use locks or the
wrong kind of locks. This method readz tha chizzlez (not always failsafe)
and incorporates dem up in tha open folda administration.
.Sp
Da \s-1OPTIONS\s0 is extra joints which is passed ta the
\&\fIupdateLyrics()\fR method which is bustin tha actual work here.
.ie n .IP "$obj\->\fBurl\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBurl\fR()" 4
.IX Item "$obj->url()"
Represent tha folda as a \s-1URL \s0(Universal Resource Locator) string.  Yo ass may
pass such a \s-1URL\s0 as folda name ta \fIMail::Box::Manager::open()\fR.
.Sp
example:
.Sp
.Vb 4
\& print $folder\->url;
\& # may result in
\& #   mbox:/var/mail/markov   or
\& #   pop3://user:password@pop.aol.com:101
.Ve
.SS "Folda flags"
.IX Subsection "Folda flags"
.ie n .IP "$obj\->\fBaccess\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaccess\fR()" 4
.IX Item "$obj->access()"
Returns tha access mode of tha folder, as set by new(access)
.ie n .IP "$obj\->\fBisModified\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisModified\fR()" 4
.IX Item "$obj->isModified()"
Checks if tha folder, as stored up in memory, is modified. Y'all KNOW dat shit, muthafucka!  A legit value is
returned when any of tha lyrics is ta be deleted, has chizzled, or lyrics
were added afta tha folda was read from file.
.Sp
\&\s-1WARNING:\s0 dis flag aint related ta a external chizzle ta tha folder
structure on disk.  Have a peep \fIupdate()\fR fo' dis shit.
.ie n .IP "$obj\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.IX Item "$obj->modified([BOOLEAN])"
Sets whether tha folda is modified or not.
.ie n .IP "$obj\->\fBwritable\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwritable\fR()" 4
.IX Item "$obj->writable()"
Checks whether tha current folda is writable.
.Sp
example:
.Sp
.Vb 1
\& $folder\->addMessage($msg) if $folder\->writable;
.Ve
.SS "Da lyrics"
.IX Subsection "Da lyrics"
.ie n .IP "$obj\->\fBcurrent\fR([NUMBER|MESSAGE|MESSAGE\-ID])" 4
.el .IP "\f(CW$obj\fR\->\fBcurrent\fR([NUMBER|MESSAGE|MESSAGE\-ID])" 4
.IX Item "$obj->current([NUMBER|MESSAGE|MESSAGE-ID])"
Some mail-readaz keep tha \fIcurrent\fR message, which represents tha last
used message.  This method returns [afta setting] tha current message.
Yo ass may specify a \s-1NUMBER,\s0 ta specify dat that message number is ta be
selected as current, or a \s-1MESSAGE/MESSAGE\-ID \s0(as long as yo ass is sure
that tha header be already loaded, otherwise they is not recognized).
.Sp
example:
.Sp
.Vb 2
\& $folder\->current(0);
\& $folder\->current($message);
.Ve
.ie n .IP "$obj\->\fBfind\fR(MESSAGE-ID)" 4
.el .IP "\f(CW$obj\fR\->\fBfind\fR(MESSAGE-ID)" 4
.IX Item "$obj->find(MESSAGE-ID)"
Like \fImessageId()\fR, dis method searches fo' a message wit the
MESSAGE-ID, returnin tha correspondin message object.  But fuck dat shiznit yo, tha word on tha street is dat \f(CW\*(C`find\*(C'\fR
will cause unparsed message up in tha folda ta be parsed until tha message-id
is found. Y'all KNOW dat shit, muthafucka!  Da folda is ghon be scanned back ta front.
.ie n .IP "$obj\->\fBfindFirstLabeled\fR(\s-1LABEL,\s0 [\s-1BOOLEAN,\s0 [\s-1ARRAY\-OF\-MSGS\s0]])" 4
.el .IP "\f(CW$obj\fR\->\fBfindFirstLabeled\fR(\s-1LABEL,\s0 [\s-1BOOLEAN,\s0 [\s-1ARRAY\-OF\-MSGS\s0]])" 4
.IX Item "$obj->findFirstLabeled(LABEL, [BOOLEAN, [ARRAY-OF-MSGS]])"
Find tha straight-up original gangsta message which has dis \s-1LABEL\s0 wit tha erect setting. The
\&\s-1BOOLEAN\s0 indicates whether any legit value or any false value is to
be found. Y'all KNOW dat shit, muthafucka!  By default, a legit value is searched for. Shiiit, dis aint no joke.  When a message
does not have tha axed label, it is taken as false.
.Sp
example: lookin fo' a labeled message
.Sp
.Vb 1
\& mah $current = $folder\->findFirstLabeled(\*(Aqcurrent\*(Aq);
\&
\& mah $first   = $folder\->findFirstLabeled(seen => 0);
\&
\& mah $last    = $folder\->findFirstLabeled(seen => 0,
\&                 [ reverse $self\->lyrics(\*(AqACTIVE\*(Aq) ] )
.Ve
.ie n .IP "$obj\->\fBmessage\fR(\s-1INDEX\s0 [,MESSAGE])" 4
.el .IP "\f(CW$obj\fR\->\fBmessage\fR(\s-1INDEX\s0 [,MESSAGE])" 4
.IX Item "$obj->message(INDEX [,MESSAGE])"
Git or set a message wit on a cold-ass lil certain index.  Lyrics which is flagged
for deletion is counted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Negatizzle indexes start all up in tha end of tha folder.
.Sp
example:
.Sp
.Vb 4
\& mah $msg = $folder\->message(3);
\& $folder\->message(3)\->delete;   # status chizzlez ta \`deleted\*(Aq
\& $folder\->message(3, $msg);
\& print $folder\->message(\-1);    # last message.
.Ve
.ie n .IP "$obj\->\fBmessageId\fR(MESSAGE-ID [,MESSAGE])" 4
.el .IP "\f(CW$obj\fR\->\fBmessageId\fR(MESSAGE-ID [,MESSAGE])" 4
.IX Item "$obj->messageId(MESSAGE-ID [,MESSAGE])"
With one argument, returns tha message up in tha folda wit tha specified
MESSAGE-ID. If a reference ta a message object is passed as tha optional
second argument, tha message is first stored up in tha folder, replacin any
existin message whose message \s-1ID\s0 is MESSAGE-ID. (Da message \s-1ID\s0 of \s-1MESSAGE\s0
need not match MESSAGE-ID.)
.Sp
!!WARNING!!: when tha message headaz is delay-parsed, tha message
might be up in tha folda but not yet parsed tha fuck into memory. In dis case, use
\&\fIfind()\fR instead of \f(CW\*(C`messageId()\*(C'\fR if you straight-up need a thorough search.
This is especially tha case fo' directory organized foldaz without
special indexi, like Mail::Box::MH.
.Sp
Da MESSAGE-ID may still be up in angles, which is ghon be stripped. Y'all KNOW dat shit, muthafucka!  In that
case blanks (which origin from header line folding) is removed like a muthafucka.  Other
info round tha anglez is ghon be removed like a muthafucka.
.Sp
example:
.Sp
.Vb 4
\& mah $msg = $folder\->messageId(\*(Aq<complex\-message.id>\*(Aq);
\& $folder\->messageId("<complex\-message\en.id>", $msg);
\& mah $msg = $folder\->messageId(\*(Aqcomplex\-message.id\*(Aq);
\& mah $msg = $folder\->messageId(\*(Aqgarbage <complex\-message.id> trash\*(Aq);
.Ve
.ie n .IP "$obj\->\fBmessageIds\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmessageIds\fR()" 4
.IX Item "$obj->messageIds()"
Returns a list of \fIall\fR message-idz up in tha folder, including
those of lyrics which is ta be deleted.
.Sp
For some folder-types (like \s-1MH\s0), dis method may cause all message-files
to be read. Y'all KNOW dat shit, muthafucka!  See they respectizzle manual pages.
.Sp
example:
.Sp
.Vb 3
\& foreach mah $id ($folder\->messageIds) {
\&    $folder\->messageId($id)\->print;
\& }
.Ve
.ie n .IP "$obj\->\fBlyrics\fR(['\s-1ALL\s0',RANGE,'\s-1ACTIVE\s0','\s-1DELETED\s0',LABEL,!LABEL,FILTER])" 4
.el .IP "\f(CW$obj\fR\->\fBlyrics\fR(['\s-1ALL\s0',RANGE,'\s-1ACTIVE\s0','\s-1DELETED\s0',LABEL,!LABEL,FILTER])" 4
.IX Item "$obj->lyrics(['ALL',RANGE,'ACTIVE','DELETED',LABEL,!LABEL,FILTER])"
Returns multiple lyrics from tha folda n' shit.  Da default is \f(CW\*(C`ALL\*(C'\fR
which will return (as expected maybe) all tha lyrics up in the
folda n' shit.  Da \f(CW\*(C`ACTIVE\*(C'\fR flag will return tha lyrics not flagged for
deletion. I aint talkin' bout chicken n' gravy biatch.  This is tha opposite of \f(CW\*(C`DELETED\*(C'\fR, which returns all
lyrics from tha folda which is ghon be deleted when tha folda is
closed.
.Sp
Yo ass may also specify a \s-1RANGE:\s0 two numbers specifyin begin n' end
index up in tha array of lyrics.  Negatizzle indexes count from the
end of tha folda n' shit.  When a index is out-of-range, tha returned
list is ghon be shorta without disses.
.Sp
Everythang else than tha predefined names is peeped as labels.  Da lyrics
which have dat label set is ghon be returned. Y'all KNOW dat shit, muthafucka!  When tha sequence starts
with a exclamation mark (!), tha search result is reversed.
.Sp
For mo' complex searches, you can specify a \s-1FILTER,\s0 which is
simply a cold-ass lil code reference.  Da message is passed as only argument.
.Sp
example:
.Sp
.Vb 2
\& foreach mah $message ($folder\->lyrics) {...}
\& foreach mah $message (@$folder) {...}
\&
\& # twice tha same
\& mah @lyrics   = $folder\->lyrics;
\& mah @lyrics   = $folder\->lyrics(\*(AqALL\*(Aq);
\&
\& # Selection based on a range (begin, end)
\& mah $subset     = $folder\->lyrics(10,\-8);
\&
\& # twice tha same:
\& mah @not_deleted= grep {not $_\->isDeleted}
\&                     $folder\->lyrics;
\& mah @not_deleted= $folder\->lyrics(\*(AqACTIVE\*(Aq);
\&
\& # scalar context tha number of lyrics
\& mah $nr_of_msgs = $folder\->lyrics;
\&
\& # third message, via overloading
\& $folder\->[2];
\&
\& # Selection based on labels
\& $mgr\->moveLyrics($spam, $inbox\->message(\*(Aqspam\*(Aq));
\& $mgr\->moveLyrics($archive, $inbox\->message(\*(Aqseen\*(Aq));
.Ve
.ie n .IP "$obj\->\fBnrLyrics\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBnrLyrics\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->nrLyrics(OPTIONS)"
Simply calls \fIlyrics()\fR up in scalar context ta return a cold-ass lil count instead
of tha lyrics itself.  Some playas seem ta KNOW dis better.
Note dat \fInrLyrics()\fR will default ta returnin a cold-ass lil count of
\&\f(CW\*(C`ALL\*(C'\fR lyrics up in tha folder, includin both \f(CW\*(C`ACTIVE\*(C'\fR n' \f(CW\*(C`DELETED\*(C'\fR.
.Sp
Da \s-1OPTIONS\s0 is passed ta (and explained in) \fIlyrics()\fR.
.ie n .IP "$obj\->\fBscanForLyrics\fR(\s-1MESSAGE,\s0 MESSAGE-IDS, \s-1TIMESPAN, WINDOW\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBscanForLyrics\fR(\s-1MESSAGE,\s0 MESSAGE-IDS, \s-1TIMESPAN, WINDOW\s0)" 4
.IX Item "$obj->scanForLyrics(MESSAGE, MESSAGE-IDS, TIMESPAN, WINDOW)"
Yo ass start wit a \s-1MESSAGE,\s0 n' is lookin fo' a set of lyrics
which is related ta dat shit.  For instance, lyrics which step tha fuck up in
the 'In\-Reply\-To' n' 'Reference' header fieldz of dat message.
These lyrics is known by they MESSAGE-IDS n' you wanna find
them up in tha folder.
.Sp
When all message-idz is known, then looking-up lyrics is simple:
they is found up in a plain hash rockin \fImessageId()\fR.  But Mail::Box
is lazy where it can, all kindsa muthafuckin lyrics may not done been read from
file yet, n' thatz tha preferred thang, cuz dat saves
time n' memory.
.Sp
It aint smart-ass ta search fo' tha lyrics from front ta back in
the folder: tha chances is much higher dat related message
reside closely ta each other n' shit.  Therefore, dis method starts
scannin tha folda from tha specified \s-1MESSAGE,\s0 back ta tha front
of tha folder.
.Sp
Da \s-1TIMESPAN\s0 can be used ta terminizzle tha search based on tha time
enclosed up in tha message.  When tha constant strang \f(CW\*(C`EVER\*(C'\fR is used as
\&\s-1TIMESPAN,\s0 then tha search aint limited by dis shit.  When a integer
is specified, it is ghon be used as absolute time up in time-ticks as
provided by yo' platform dependent \f(CW\*(C`time\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  In other cases,
it is passed ta \fItimespan2seconds()\fR ta determine tha threshold
as time relatizzle ta tha messagez time.
.Sp
Da \s-1WINDOW\s0 is used ta limit tha search up in number of lyrics ta be
scanned as integer or constant strang \f(CW\*(C`ALL\*(C'\fR.
.Sp
Returned is tha message-idz which was not found durin tha scan.
Be warned dat a message-id could already be known n' therefore not
found: check dat first.
.Sp
example: scannin all up in a gangbangin' folda fo' a message
.Sp
.Vb 3
\& mah $refs   = $msg\->get(\*(AqReferences\*(Aq) or return;
\& mah @msgidz = $ref =~ m/\e<([^>]+\e>/g;
\& mah @failed = $folder\->scanForLyrics($msg, \e@msgids, \*(Aq3 days\*(Aq, 50);
.Ve
.SS "Sub-folders"
.IX Subsection "Sub-folders"
.ie n .IP "$obj\->\fBlistSubFolders\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlistSubFolders\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->listSubFolders(OPTIONS)"
.PD 0
.IP "Mail::Box\->\fBlistSubFolders\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Box->listSubFolders(OPTIONS)"
.PD
List tha namez of all sub-foldaz ta dis folder, not recursively
decending.  Use these names as argument ta \fIopenSubFolder()\fR, ta get
access ta dat folder.
.Sp
For \s-1MBOX\s0 folders, sub-foldaz is simulated.
.Sp
.Vb 5
\& \-Option    \-\-Default
\&  check       <false>
\&  folda      <from callin object>
\&  folderdir   <from folder>
\&  skip_empty  <false>
.Ve
.RS 4
.IP "check => \s-1BOOLEAN\s0" 2
.IX Item "check => BOOLEAN"
Should all returned foldernames be checked ta be shizzle dat they is of
the right type, biatch?  Each sub-folda may need ta be opened ta check this,
with a gangbangin' folda type dependent penalty (in some cases straight-up expensive).
.IP "folda => \s-1FOLDERNAME\s0" 2
.IX Item "folda => FOLDERNAME"
Da folda whose sub-foldaz should be listed.
.IP "folderdir => \s-1DIRECTORY\s0" 2
.IX Item "folderdir => DIRECTORY"
.PD 0
.IP "skip_empty => \s-1BOOL\s0" 2
.IX Item "skip_empty => BOOL"
.PD
Shall empty foldaz (foldaz which currently do not contain any lyrics)
be included, biatch?  Empty foldaz is not useful ta open yo, but may be useful
to save to.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 2
\& mah $folda = $mgr\->open(\*(Aq=in/new\*(Aq);
\& mah @subs = $folder\->listSubFolders;
\&
\& mah @subs = Mail::Box::Mbox\->listSubFolders(folda => \*(Aq=in/new\*(Aq);
\& mah @subs = Mail::Box::Mbox\->listSubFolders; # toplevel folders.
.Ve
.RE
.ie n .IP "$obj\->\fBnameOfSubFolder\fR(\s-1SUBNAME,\s0 [\s-1PARENTNAME\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBnameOfSubFolder\fR(\s-1SUBNAME,\s0 [\s-1PARENTNAME\s0])" 4
.IX Item "$obj->nameOfSubFolder(SUBNAME, [PARENTNAME])"
.PD 0
.IP "Mail::Box\->\fBnameOfSubFolder\fR(\s-1SUBNAME,\s0 [\s-1PARENTNAME\s0])" 4
.IX Item "Mail::Box->nameOfSubFolder(SUBNAME, [PARENTNAME])"
.PD
Returns tha constructed name of tha folda wit \s-1NAME,\s0 which be a
sub-folda of dis current one.  Yo ass have either ta booty-call dis method
as instizzle method, or specify a \s-1PARENTNAME.\s0
.Sp
example: how tha fuck ta git tha name of a subfolder
.Sp
.Vb 2
\& mah $sub = Mail::Box::Mbox\->nameOfSubfolder(\*(Aqxyz\*(Aq, \*(Aqabc\*(Aq);
\& print $sub;                        # abc/xyz
\&
\& mah $f = Mail::Box::Mbox\->new(folda => \*(Aqabc\*(Aq);
\& print $f\->nameOfSubfolder(\*(Aqxyz\*(Aq);  # abc/xyz
\&
\& mah $sub = Mail::Box::Mbox\->nameOfSubfolder(\*(Aqxyz\*(Aq, undef);
\& print $sub;                        # xyz
.Ve
.ie n .IP "$obj\->\fBopenRelatedFolder\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBopenRelatedFolder\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->openRelatedFolder(OPTIONS)"
Open a gangbangin' folda (usually a sub-folder) wit tha same options as dis one.
If there be a gangbangin' folda manager up in use, it is ghon be informed bout dis new
folda n' shit.  \s-1OPTIONS\s0 overrule tha options which where used fo' tha folder
this method is called upon.
.ie n .IP "$obj\->\fBopenSubFolder\fR(\s-1SUBNAME, OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBopenSubFolder\fR(\s-1SUBNAME, OPTIONS\s0)" 4
.IX Item "$obj->openSubFolder(SUBNAME, OPTIONS)"
Open (or create, if it do not exist yet) a freshly smoked up subfolda up in an
existin folder.
.Sp
example:
.Sp
.Vb 2
\& mah $folda = Mail::Box::Mbox\->new(folda => \*(Aq=Inbox\*(Aq);
\& mah $sub    = $folder\->openSubFolder(\*(Aqread\*(Aq);
.Ve
.ie n .IP "$obj\->\fBtopFolderWithLyrics\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtopFolderWithLyrics\fR()" 4
.IX Item "$obj->topFolderWithLyrics()"
.PD 0
.IP "Mail::Box\->\fBtopFolderWithLyrics\fR()" 4
.IX Item "Mail::Box->topFolderWithLyrics()"
.PD
Some folda types can have lyrics up in tha top-level folder, some other
can't.
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBcoerce\fR(\s-1MESSAGE, OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcoerce\fR(\s-1MESSAGE, OPTIONS\s0)" 4
.IX Item "$obj->coerce(MESSAGE, OPTIONS)"
Coerce tha \s-1MESSAGE\s0 ta be of tha erect type ta be placed up in the
folda n' shit.  Yo ass can specify Mail::Internizzle n' MIME::Entitizzle objects
here: they is ghon be translated tha fuck into Mail::Message lyrics first.
.ie n .IP "$obj\->\fBcreate\fR(\s-1FOLDERNAME, OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreate\fR(\s-1FOLDERNAME, OPTIONS\s0)" 4
.IX Item "$obj->create(FOLDERNAME, OPTIONS)"
.PD 0
.IP "Mail::Box\->\fBcreate\fR(\s-1FOLDERNAME, OPTIONS\s0)" 4
.IX Item "Mail::Box->create(FOLDERNAME, OPTIONS)"
.PD
Smoke a gangbangin' folda n' shit.  If tha folda already exists, it is ghon be left unchanged.
Da folda is pimped yo, but not opened hommie!  If you wanna open a gangbangin' file which
may need ta be pimped, then use \fIMail::Box::Manager::open()\fR wit the
create flag, or Mail::Box::new(create).
.Sp
.Vb 2
\& \-Option   \-\-Default
\&  folderdir  undef
.Ve
.RS 4
.IP "folderdir => \s-1DIRECTORY\s0" 2
.IX Item "folderdir => DIRECTORY"
When tha foldername is preceded by a \f(CW\*(C`=\*(C'\fR, tha \f(CW\*(C`folderdir\*(C'\fR directory
will be searched fo' tha named folder.
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBdetermineBodyType\fR(\s-1MESSAGE, HEAD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdetermineBodyType\fR(\s-1MESSAGE, HEAD\s0)" 4
.IX Item "$obj->determineBodyType(MESSAGE, HEAD)"
Determine which kind of body is ghon be pimped fo' dis message when
readin tha folda initially.
.IP "Mail::Box\->\fBfoundIn\fR([\s-1FOLDERNAME\s0], \s-1OPTIONS\s0)" 4
.IX Item "Mail::Box->foundIn([FOLDERNAME], OPTIONS)"
Determine if tha specified folda iz of tha type handled by the
folda class. This method is extended by each folda sub-type.
.Sp
Da \s-1FOLDERNAME\s0 specifies tha name of tha folder, as is specified by the
application. I aint talkin' bout chicken n' gravy biatch.  Yo ass need ta specified tha \f(CW\*(C`folder\*(C'\fR option when you skip
this first argument.
.Sp
\&\s-1OPTIONS\s0 be a list of extra shiznit fo' tha request.  Read
the documentation fo' each type of folda fo' type specific options yo, but
each folda class will at least support tha \f(CW\*(C`folderdir\*(C'\fR option:
.Sp
.Vb 2
\& \-Option   \-\-Default
\&  folderdir  undef
.Ve
.RS 4
.IP "folderdir => \s-1DIRECTORY\s0" 2
.IX Item "folderdir => DIRECTORY"
Da location where tha foldaz of dis class is stored by default.  If the
user specifies a name startin wit a \f(CW\*(C`=\*(C'\fR, dat indicates dat tha folda is
to be found up in dis default \s-1DIRECTORY.\s0
.RE
.RS 4
.Sp
example:
.Sp
.Vb 3
\& Mail::Box::Mbox\->foundIn(\*(Aq=markov\*(Aq,
\&     folderdir => "$ENV{HOME}/Mail");
\& Mail::Box::MH\->foundIn(folda => \*(Aq=markov\*(Aq);
.Ve
.RE
.ie n .IP "$obj\->\fBlineSeparator\fR([STRING|'\s-1CR\s0'|'\s-1LF\s0'|'\s-1CRLF\s0'])" 4
.el .IP "\f(CW$obj\fR\->\fBlineSeparator\fR([STRING|'\s-1CR\s0'|'\s-1LF\s0'|'\s-1CRLF\s0'])" 4
.IX Item "$obj->lineSeparator([STRING|'CR'|'LF'|'CRLF'])"
Returns tha characta or charactas used ta separate lines up in tha folder
file, optionally afta settin it ta \s-1STRING,\s0 or one of tha constants.
Da first line of tha folda sets tha default.
.Sp
\&\s-1UNIX\s0 uses a \s-1LF\s0 character, Mac a \s-1CR,\s0 n' Windows both a \s-1CR\s0 n' a \s-1LF. \s0 Each
separator is ghon be represented by a \*(L"\en\*(R" within yo' program.  However,
when processin platform foreign folders, complications appear. Shiiit, dis aint no joke.  Think about
the \f(CW\*(C`Size\*(C'\fR field up in tha header.
.Sp
When tha separator is chizzled, tha whole folda me be rewritten. I aint talkin' bout chicken n' gravy biatch.  Although,
that may not be required.
.ie n .IP "$obj\->\fBlocker\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlocker\fR()" 4
.IX Item "$obj->locker()"
Returns tha lockin object.
.ie n .IP "$obj\->\fBread\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->read(OPTIONS)"
Read lyrics from tha folda tha fuck into memory.  Da \s-1OPTIONS\s0 is folder
specific.  Do not call \f(CW\*(C`read()\*(C'\fR yo ass: it is ghon be called fo' you
when you open tha folda via tha manager or instantiate a gangbangin' folder
object directly.
.Sp
\&\s-1NOTE:\s0 if yo ass is copyin lyrics from one folda ta another, use
\&\fIaddLyrics()\fR instead of \f(CW\*(C`read()\*(C'\fR.
.Sp
example:
.Sp
.Vb 3
\& mah $mgr = Mail::Box::Manager\->new;
\& mah $folda = $mgr\->open(\*(AqInBox\*(Aq);             # implies read
\& mah $folda = Mail::Box::Mbox\->new(folda => \*(AqInbox\*(Aq); # same
.Ve
.ie n .IP "$obj\->\fBreadLyrics\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBreadLyrics\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->readLyrics(OPTIONS)"
Called by \fIread()\fR ta straight-up read tha lyrics from one specific
folda type.  Da \fIread()\fR organizes tha general activities.
.Sp
Da \s-1OPTIONS\s0 is \f(CW\*(C`trusted\*(C'\fR, \f(CW\*(C`head_type\*(C'\fR, \f(CW\*(C`field_type\*(C'\fR,
\&\f(CW\*(C`message_type\*(C'\fR, \f(CW\*(C`body_delayed_type\*(C'\fR, n' \f(CW\*(C`head_delayed_type\*(C'\fR as
defined by tha folda at hand. Y'all KNOW dat shit, muthafucka!  Da defaults is tha constructor
defaults (see \fInew()\fR).
.ie n .IP "$obj\->\fBstoreMessage\fR(\s-1MESSAGE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBstoreMessage\fR(\s-1MESSAGE\s0)" 4
.IX Item "$obj->storeMessage(MESSAGE)"
Store tha message up in tha folda without tha checks as performed by
\&\fIaddMessage()\fR.
.ie n .IP "$obj\->\fBtoBeThreaded\fR(\s-1MESSAGES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBtoBeThreaded\fR(\s-1MESSAGES\s0)" 4
.IX Item "$obj->toBeThreaded(MESSAGES)"
Da specified message is locked n loaded ta be removed from a thread.
This is ghon be passed on ta tha mail-manager, which keeps a overview on
which thread-detection objects is floatin around.
.ie n .IP "$obj\->\fBtoBeUnthreaded\fR(\s-1MESSAGES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBtoBeUnthreaded\fR(\s-1MESSAGES\s0)" 4
.IX Item "$obj->toBeUnthreaded(MESSAGES)"
Da specified message is locked n loaded ta be included up in a thread.
This is ghon be passed on ta tha mail-manager, which keeps a overview on
which thread-detection objects is floatin around.
.ie n .IP "$obj\->\fBupdateLyrics\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBupdateLyrics\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->updateLyrics(OPTIONS)"
Called by \fIupdate()\fR ta read lyrics which arrived up in tha folder
afta dat shiznit was opened. Y'all KNOW dat shit, muthafucka!  Sometimes, external applications dump lyrics
in a gangbangin' folda without lockin (or rockin a gangbangin' finger-lickin' different lock than your
application do).
.Sp
Although dis is like a thugged-out dangerous, it only fails when a gangbangin' folda is
updated (reordered or message removed) at exactly tha same time as
new lyrics arrive.  These collisions is sparse.
.Sp
Da options is tha same as fo' \fIreadLyrics()\fR.
.ie n .IP "$obj\->\fBwrite\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBwrite\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->write(OPTIONS)"
Write tha data ta disk.  Da folda (a \f(CW\*(C`true\*(C'\fR value) is returned if
successful naaahhmean, biatch?  Deleted lyrics is transformed tha fuck into destroyed lyrics:
their memory is freed.
.Sp
\&\s-1WARNING:\s0 When movin lyrics from one folda ta another, be shizzle to
write (or \fIclose()\fR) tha destination folda before freestylin (or closing)
the source folder: otherwise you may lose data if tha system crashes or
if there be software problems.
.Sp
To write a gangbangin' folda ta a gangbangin' finger-lickin' different file, you must first create a freshly smoked up folder,
then move all tha lyrics, n' then write or \fIclose()\fR dat freshly smoked up folder.
.Sp
.Vb 3
\& \-Option      \-\-Default
\&  force         <false>
\&  save_deleted  <false>
.Ve
.RS 4
.IP "force => \s-1BOOLEAN\s0" 2
.IX Item "force => BOOLEAN"
Override write-protection wit new(access) while openin tha folder
(whenever possible, it may still be blocked by tha operatin system).
.IP "save_deleted => \s-1BOOLEAN\s0" 2
.IX Item "save_deleted => BOOLEAN"
Do also write lyrics which where flagged ta be deleted ta they folda n' shit.  The
flag fo' deletion is conserved (when possible), which means dat a re-open of
the folda may remove tha lyrics fo' real. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See close(save_deleted).
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBwriteLyrics\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBwriteLyrics\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->writeLyrics(OPTIONS)"
Called by \fIwrite()\fR ta straight-up write tha lyrics from one specific
folda type.  Da \f(CW\*(C`write\*(C'\fR organizes tha general activities. Put ya muthafuckin choppers up if ya feel dis!  All options
to \fIwrite()\fR is passed ta \f(CW\*(C`writeLyrics\*(C'\fR as well.  Besides, all dem extra
are added by \f(CW\*(C`write\*(C'\fR itself.
.Sp
.Vb 2
\& \-Option  \-\-Default
\&  lyrics  <required>
.Ve
.RS 4
.IP "lyrics => \s-1ARRAY\s0" 2
.IX Item "lyrics => ARRAY"
Da lyrics ta be written, which be a sub-set of all lyrics up in the
current folder.
.RE
.RS 4
.RE
.SS "Other methods"
.IX Subsection "Other methods"
.ie n .IP "$obj\->\fBtimespan2seconds\fR(\s-1TIME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBtimespan2seconds\fR(\s-1TIME\s0)" 4
.IX Item "$obj->timespan2seconds(TIME)"
.PD 0
.IP "Mail::Box\->\fBtimespan2seconds\fR(\s-1TIME\s0)" 4
.IX Item "Mail::Box->timespan2seconds(TIME)"
.PD
\&\s-1TIME\s0 be a string, which starts wit a gangbangin' float, n' then one of the
wordz 'hour', 'hours', 'day', 'days', 'week', or 'weeks'.  For instance:
\&'1 hour' or '4 weeks'.
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Box\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Box->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Box\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Box->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Box\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Box->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
This method is called by Perl when a folder-object is no longer accessible
by tha rest of tha program.
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Different kindz of folders"
.IX Subsection "Different kindz of folders"
In general, there be three classez of folders: dem playas whoz ass crew lyrics
per file, dem playas whoz ass crew lyrics up in a gangbangin' finger-lickin' directory, n' dem do not
provide direct access ta tha message data.  These folda types are
each based on a gangbangin' finger-lickin' different base class.
.IP "\(bu" 4
File based foldaz Mail::Box::File
.Sp
File based foldaz maintain a gangbangin' folda (a set of lyrics) up in one
single file.  Da advantage is dat yo' folda has only one
single file ta access, which speeds-up thangs when all lyrics
must be accessed at once.
.Sp
One of tha main disadvantages over directory based folders
is dat you gotta construct some means ta keep all message apart.
For instizzle \s-1MBOX\s0 addz a message separator line between tha lyrics
in tha file, n' dis line can cause mad drama wit tha message's
contents.
.Sp
Where access ta all lyrics at once is fasta up in file based folders,
access ta a single message is (much) slower, cuz tha whole folder
must be read. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat up in directory based foldaz you gotta figure-out
which message you need, which may be a hassle as well.
.Sp
Examplez of file based foldaz is \s-1MBOX, DBX,\s0 n' NetScape.
.IP "\(bu" 4
Directory based foldaz Mail::Box::Dir
.Sp
In stead of collectin multiple lyrics up in one file, you can also
put each message up in a separate file n' collect dem filez up in a
directory ta represent a gangbangin' folder.
.Sp
Da main disadvantagez of these foldaz is tha enormous amount of
tiny filez you probably git up in yo' file-system.  It be mad
slow ta search all up in yo' whole folder, cuz nuff filez have
to be opened ta do so.
.Sp
Da dopest feature of dis organization is dat each message is kept
exactly as dat shiznit was received, n' can be processed wit external scripts
as well: you do not need any mail user agent (\s-1MUA\s0).
.Sp
Examplez of directoy organized foldaz is \s-1MH,\s0 Maildir, \s-1EMH,\s0 n' \s-1XMH.\s0
.IP "\(bu" 4
Network (external) foldaz Mail::Box::Net
.Sp
Where both types busted lyrics bout before provide direct access ta the
message data, maintain these folda types tha message data fo' you:
you gotta request fo' lyrics or partz of em.  These folders
do not gotz a gangbangin' filename, file-system privileges n' system locking
to worry bout yo, but typically require a hostname, folda n' message
IDs, n' authorization.
.Sp
Examplez of these folda types is tha ghettofab \s-1POP\s0 n' \s-1IMAP,\s0 and
database oriented message storage.
.SS "Available folda types"
.IX Subsection "Available folda types"
.IP "\(bu" 4
Mail::Box::Dbx (read only)
.Sp
Dbx filez is pimped by Outlook Express. Usin tha external (optional)
Mail::Transport::Dbx module, you can read these folders, even
when yo ass is hustlin MailBox on a UNIX/Linux platform.
.Sp
Freestylin n' deletin lyrics aint supported by tha library, and
therefore not by MailBox. Read access is enough ta do folda conversions,
for instance.
.IP "\(bu" 4
Mail::Box::IMAP4 (partially)
.Sp
Da \s-1IMAP\s0 protocol is straight-up complex.  Some parts is implemented to
create (sub-optimal but usable) \s-1IMAP\s0 clients, n' you can put dat on yo' toast.  Besides, there are
also some parts fo' \s-1IMAP\s0 servers present.  Da most blingin lacking
feature is support fo' encrypted connections.
.IP "\(bu" 4
Mail::Box::Maildir
.Sp
Maildir foldaz gotz a gangbangin' finger-lickin' directory fo' each folda n' shit.  A folda directory
gotz nuff \f(CW\*(C`tmp\*(C'\fR, \f(CW\*(C`new\*(C'\fR, n' \f(CW\*(C`cur\*(C'\fR sub-directories, each containting
lyrics wit a gangbangin' finger-lickin' different purpose.  Filez wit freshly smoked up lyrics is pimped
in \f(CW\*(C`tmp\*(C'\fR, then moved ta \f(CW\*(C`new\*(C'\fR (ready ta be accepted).  Later, they are
moved ta tha \f(CW\*(C`cur\*(C'\fR directory (accepted).  Each message is one file with
a name startin wit timestamp.  Da name also gotz nuff flags bout the
statuz of tha message.
.Sp
Maildir foldaz can not be used on Windows by reason of file-name
limitations on dat platform.
.IP "\(bu" 4
Mail::Box::Mbox
.Sp
A folda type up in which all related lyrics is stored up in one file.  This
is a straight-up common folda type fo' \s-1UNIX.\s0
.IP "\(bu" 4
Mail::Box::MH
.Sp
This folda creates a gangbangin' finger-lickin' directory fo' each folder, n' a message is one
file inside dat directory.  Da message filez is numbered sequentially
on order of arrival. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  A special \f(CW\*(C`.mh_sequences\*(C'\fR file maintains flags
about tha lyrics.
.IP "\(bu" 4
Mail::Box::POP3 (read/delete only)
.Sp
\&\s-1POP3\s0 be a protocol which can be used ta retreive lyrics from a
remote system.  Afta tha connection ta a \s-1POP\s0 server is made, the
lyrics can be looked at n' removed as if they is on tha local
system.
.IP "\(bu" 4
Mail::Box::Netzwert
.Sp
Da Netzwert folda type is optimized fo' mailbox handlin on a cold-ass lil cluster
of systems wit a gangbangin' finger-lickin' dirty-ass shared \s-1NFS\s0 storage.  Da code aint busted out under
\&\s-1GPL \s0(yet)
.PP
Other folda types is on tha (long) wishlist ta git implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Please,
help implementin mo' of em.
.SS "Folda class implementation"
.IX Subsection "Folda class implementation"
Da class structure of foldaz is straight-up close ta dat of lyrics.  For
instance, a Mail::Box::File::Message relates ta a Mail::Box::File
folda n' shit.  Da folda types are:
.PP
.Vb 10
\&                    Mail::Box::Netzwert
\& Mail::Box::Mbox   | Mail::Box::Maildir Mail::Box::POP3
\& |  Mail::Box::Dbx | | Mail::Box::MH    |  Mail::Box::IMAP4
\& |  |               | | |                 |  |
\& |  |               | | |                 |  |
\& Mail::Box::File   Mail::Box::Dir       Mail::Box::Net
\&       |                  |                   |
\&       \`\-\-\-\-\-\-\-\-\-\-\-\-\-\-.   |   .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&                      |   |   |
\&                      Mail::Box
\&                          |
\&                          |
\&                    Mail::Reporta (general base class)
.Ve
.PP
By far most folda features is implemented up in Mail::Box, so
available ta all folda types.  Sometimes, features which appear
in only a shitload of tha folda types is simulated fo' foldaz dat miss
them, like sub-folda support fo' \s-1MBOX.\s0
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Warning: Chizzlez not freestyled ta read-only folda $self." 4
.el .IP "Warning: Chizzlez not freestyled ta read-only folda \f(CW$self\fR." 4
.IX Item "Warning: Chizzlez not freestyled ta read-only folda $self."
Yo ass have opened tha folda read-only \-\-which is tha default set
by new(access)\-\-, made modifications, n' now wanna close dat shit.
Set close(force) if you wanna overrule tha access mode, or close
the folda wit close(write) set ta \f(CW\*(C`NEVER\*(C'\fR.
.IP "Error: Copyin failed fo' one message." 4
.IX Item "Error: Copyin failed fo' one message."
For some reason, fo' instizzle disc full, removed by external process, or
read-protection, it is impossible ta copy one of tha lyrics.  Copyin will
proceed fo' tha other lyrics.
.ie n .IP "Error: Destination folda $name aint writable." 4
.el .IP "Error: Destination folda \f(CW$name\fR aint writable." 4
.IX Item "Error: Destination folda $name aint writable."
Da folda where tha lyrics is copied ta aint opened wit write
access (see new(access)).  This has no relation wit write permission
to tha folda which is controled by yo' operatin system.
.ie n .IP "Warning: Different lyrics wit id $msgid" 4
.el .IP "Warning: Different lyrics wit id \f(CW$msgid\fR" 4
.IX Item "Warning: Different lyrics wit id $msgid"
Da message id is discovered mo' than once within tha same folda yo, but the
content of tha message seems ta be different.  This should not be possible:
each message must be unique.
.ie n .IP "Error: Folda $name is opened read-only" 4
.el .IP "Error: Folda \f(CW$name\fR is opened read-only" 4
.IX Item "Error: Folda $name is opened read-only"
Yo ass can not write ta dis folda unless you have opened tha folda to
write or append wit new(access), or tha \f(CW\*(C`force\*(C'\fR option is set true.
.ie n .IP "Error: Folda $name not deleted: not writable." 4
.el .IP "Error: Folda \f(CW$name\fR not deleted: not writable." 4
.IX Item "Error: Folda $name not deleted: not writable."
Da folda must be opened wit write access via new(access), otherwise
removin it is ghon be refused. Y'all KNOW dat shit, muthafucka!  So, you may have write-access accordin to
the operatin system yo, but dat aint gonna automatically mean dat this
\&\f(CW\*(C`delete\*(C'\fR method permits you to.  Da reverse remark is valid as well.
.IP "Error: Invalid timespan '$timespan' specified." 4
.IX Item "Error: Invalid timespan '$timespan' specified."
Da strang do not follow tha strict rulez of tha time span syntax which
is permitted as parameter.
.IP "Warning: Message-id '$msgid' do not contain a thugged-out domain." 4
.IX Item "Warning: Message-id '$msgid' do not contain a thugged-out domain."
Accordin ta tha RFCs, message-idz need ta contain a unique random part,
then a \f(CW\*(C`@\*(C'\fR, n' then a thugged-out domain name.  This is made ta avoid tha creation
of two lyrics wit tha same id. Y'all KNOW dat shit, muthafucka!  Da warnin emerges when tha \f(CW\*(C`@\*(C'\fR is
missin from tha string.
.IP "Error: No folda name specified." 4
.IX Item "Error: No folda name specified."
Yo ass did not specify tha name of a gangbangin' folda ta be opened. Y'all KNOW dat shit, muthafucka!  Use the
new(folder) option or set tha \f(CW\*(C`MAIL\*(C'\fR environment variable.
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.ie n .IP "Error: Unable ta create subfolda $name of $folder." 4
.el .IP "Error: Unable ta create subfolda \f(CW$name\fR of \f(CW$folder\fR." 4
.IX Item "Error: Unable ta create subfolda $name of $folder."
Da copy includes tha subfoldaz yo, but fo' some reason dat shiznit was not possible
to copy one of these n' you can put dat on yo' toast.  Copyin will proceed fo' all other sub-folders.
.ie n .IP "Error: Freestylin folda $name failed" 4
.el .IP "Error: Freestylin folda \f(CW$name\fR failed" 4
.IX Item "Error: Freestylin folda $name failed"
For some reason (you probably gots mo' error lyrics bout dis problem)
it is impossible ta write tha folder, although you should cuz there
were chizzlez made.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
