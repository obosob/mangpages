.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "open 3pm"
.TH open 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
open \- perl pragma ta set default PerlIO layers fo' input n' output
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use open IN  => ":crlf", OUT => ":bytes";
\&    use open OUT => \*(Aq:utf8\*(Aq;
\&    use open IO  => ":encoding(iso\-8859\-7)";
\&
\&    use open IO  => \*(Aq:locale\*(Aq;
\&
\&    use open \*(Aq:encoding(utf8)\*(Aq;
\&    use open \*(Aq:locale\*(Aq;
\&    use open \*(Aq:encoding(iso\-8859\-7)\*(Aq;
\&
\&    use open \*(Aq:std\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Full-fledged support fo' I/O layers is now implemented provided
Perl is configured ta use PerlIO as its \s-1IO\s0 system (which is now the
default).
.PP
Da \f(CW\*(C`open\*(C'\fR pragma serves as one of tha intercourses ta declare default
\&\*(L"layers\*(R" (also known as \*(L"disciplines\*(R") fo' all I/O fo' realz. Any two-argument
\&\fIopen()\fR, \fIreadpipe()\fR (aka qx//) n' similar operators found within the
lexical scope of dis pragma will use tha declared defaults.
Even three-argument opens may be affected by dis pragma
when they don't specify \s-1IO\s0 layers up in \s-1MODE.\s0
.PP
With tha \f(CW\*(C`IN\*(C'\fR subpragma you can declare tha default layers
of input streams, n' wit tha \f(CW\*(C`OUT\*(C'\fR subpragma you can declare
the default layerz of output streams.  With tha \f(CW\*(C`IO\*(C'\fR  subpragma
you can control both input n' output streams simultaneously.
.PP
If you gotz a legacy encoding, you can use tha \f(CW\*(C`:encoding(...)\*(C'\fR tag.
.PP
If you wanna set yo' encodin layers based on your
locale environment variables, you can use tha \f(CW\*(C`:locale\*(C'\fR tag.
For example:
.PP
.Vb 9
\&    $ENV{LANG} = \*(Aqru_RU.KOI8\-R\*(Aq;
\&    # tha :locale will probe tha locale environment variablez like LANG
\&    use open OUT => \*(Aq:locale\*(Aq;
\&    open(O, ">koi8");
\&    print O chr(0x430); # Unicode CYRILLIC SMALL LETTER A = KOI8\-R 0xc1
\&    close O;
\&    open(I, "<koi8");
\&    printf "%#x\en", ord(<I>), "\en"; # dis should print 0xc1
\&    close I;
.Ve
.PP
These is equivalent
.PP
.Vb 2
\&    use open \*(Aq:encoding(utf8)\*(Aq;
\&    use open IO => \*(Aq:encoding(utf8)\*(Aq;
.Ve
.PP
as is these
.PP
.Vb 2
\&    use open \*(Aq:locale\*(Aq;
\&    use open IO => \*(Aq:locale\*(Aq;
.Ve
.PP
and these
.PP
.Vb 2
\&    use open \*(Aq:encoding(iso\-8859\-7)\*(Aq;
\&    use open IO => \*(Aq:encoding(iso\-8859\-7)\*(Aq;
.Ve
.PP
Da matchin of encodin names is loose: case do not matter, and
many encodings have nuff muthafuckin aliases.  See Encode::Supported for
details n' tha list of supported locales.
.PP
When \fIopen()\fR is given a explicit list of layers (with tha three-arg
syntax), they override tha list declared rockin dis pragma.  \fIopen()\fR can
also be given a single colon (:) fo' a layer name, ta override dis pragma
and use tha default (\f(CW\*(C`:raw\*(C'\fR on Unix, \f(CW\*(C`:crlf\*(C'\fR on Windows).
.PP
Da \f(CW\*(C`:std\*(C'\fR subpragma on its own has no effect yo, but if combined with
the \f(CW\*(C`:utf8\*(C'\fR or \f(CW\*(C`:encoding\*(C'\fR subpragmas, it converts tha standard
filehandlez (\s-1STDIN, STDOUT, STDERR\s0) ta comply wit encodin selected
for input/output handles.  For example, if both input n' up are
chosen ta be \f(CW\*(C`:encoding(utf8)\*(C'\fR, a \f(CW\*(C`:std\*(C'\fR will mean dat \s-1STDIN, STDOUT,\s0
and \s-1STDERR\s0 is also up in \f(CW\*(C`:encoding(utf8)\*(C'\fR.  On tha other hand, if only
output is chosen ta be up in \f(CW\*(C`:encoding(koi8r)\*(C'\fR, a \f(CW\*(C`:std\*(C'\fR will cause
only tha \s-1STDOUT\s0 n' \s-1STDERR\s0 ta be up in \f(CW\*(C`koi8r\*(C'\fR.  Da \f(CW\*(C`:locale\*(C'\fR subpragma
implicitly turns on \f(CW\*(C`:std\*(C'\fR.
.PP
Da logic of \f(CW\*(C`:locale\*(C'\fR is busted lyrics bout up in full up in encoding,
but up in short it is first tryin nl_langinfo(\s-1CODESET\s0) n' then
guessin from tha \s-1LC_ALL\s0 n' \s-1LANG\s0 locale environment variables.
.PP
Directory handlez may also support PerlIO layers up in tha future.
.SH "NONPERLIO FUNCTIONALITY"
.IX Header "NONPERLIO FUNCTIONALITY"
If Perl aint built ta use PerlIO as its \s-1IO\s0 system then only tha two
pseudo-layers \f(CW\*(C`:bytes\*(C'\fR n' \f(CW\*(C`:crlf\*(C'\fR is available.
.PP
Da \f(CW\*(C`:bytes\*(C'\fR layer correspondz ta \*(L"binary mode\*(R" n' tha \f(CW\*(C`:crlf\*(C'\fR
layer correspondz ta \*(L"text mode\*(R" on platforms dat distinguish
between tha two modes when openin filez (which is nuff DOS-like
platforms, includin Windows).  These two layers is no-ops on
platforms where \fIbinmode()\fR be a no-op yo, but big-ass up they functions
everywhere if PerlIO is enabled.
.SH "IMPLEMENTATION DETAILS"
.IX Header "IMPLEMENTATION DETAILS"
There be a cold-ass lil class method up in \f(CW\*(C`PerlIO::Layer\*(C'\fR \f(CW\*(C`find\*(C'\fR which is
implemented as \s-1XS\s0 code.  It be called by \f(CW\*(C`import\*(C'\fR ta validate the
layers:
.PP
.Vb 1
\&   PerlIO::Layer::\->find("perlio")
.Ve
.PP
Da return value (if defined) be a Perl object, of class
\&\f(CW\*(C`PerlIO::Layer\*(C'\fR which is pimped by tha C code up in \fIperlio.c\fR.  As
yet there is not a god damn thang useful you can do wit tha object all up in tha perl
level.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"binmode\*(R" up in perlfunc, \*(L"open\*(R" up in perlfunc, perlunicode, PerlIO,
encoding
