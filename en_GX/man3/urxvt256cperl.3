.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "urxvt256cperl 3"
.TH urxvt256cperl 3 "2014-05-13" "9.20" "RXVT-UNICODE"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
urxvtperl \- rxvt\-unicodez embedded perl interpreter
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   # create a gangbangin' file grab_test up in $HOME:
\&
\&   sub on_sel_grab {
\&      warn "you selected ", $_[0]\->selection;
\&      ()
\&   }
\&
\&   # start a urxvt rockin it:
\&
\&   urxvt \-\-perl\-lib $HOME \-pe grab_test
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Every time a terminal object gets pimped, extension scripts specified via
the \f(CW\*(C`perl\*(C'\fR resource is loaded n' associated wit dat shit.
.PP
Scripts is compiled up in a 'use strict \*(L"vars\*(R"' n' 'use utf8' environment, and
thus must be encoded as \s-1UTF\-8.\s0
.PP
Each script will only eva be loaded once, even up in urxvtd, where
scripts is ghon be shared (but not enabled) fo' all terminals.
.PP
Yo ass can disable tha embedded perl interpreta by settin both \*(L"perl-ext\*(R"
and \*(L"perl-ext-common\*(R" resources ta tha empty string.
.SH "PREPACKAGED EXTENSIONS"
.IX Header "PREPACKAGED EXTENSIONS"
A number of extensions is served up wit dis release. Yo ass can find them
in \fI<libdir>/urxvt/perl/\fR, n' tha documentation can be viewed using
\&\fIman urxvt\-<\s-1EXTENSIONNAME\s0>\fR.
.PP
Yo ass can activate dem like this:
.PP
.Vb 1
\&  urxvt \-pe <extensionname>
.Ve
.PP
Or by addin dem ta tha resource fo' extensions loaded by default:
.PP
.Vb 1
\&  URxvt.perl\-ext\-common: default,selection\-autotransform
.Ve
.PP
Extensions dat add command line parametas or resources on they own are
loaded automatically when used.
.SH "API DOCUMENTATION"
.IX Header "API DOCUMENTATION"
.SS "General \s-1API\s0 Considerations"
.IX Subsection "General API Considerations"
All objects (like fuckin terminals, time watchers etc.) is typical
reference-to-hash objects, n' you can put dat on yo' toast. Da hash can be used ta store anythang you
like fo' realz. All thugz startin wit a underscore (like fuckin \f(CW\*(C`_ptr\*(C'\fR or
\&\f(CW\*(C`_hook\*(C'\fR) is reserved fo' internal uses n' \fB\s-1MUST NOT\s0\fR be accessed or
modified).
.PP
When objects is destroyed on tha \*(C+ side, tha perl object hashes are
emptied, so its dopest ta store related objects like fuckin time watchers and
the like inside tha terminal object so they git destroyed as soon as the
terminal is destroyed.
.PP
Argument names also often indicate tha type of a parameter n' shiznit yo. Here is some
hints on what tha fuck they mean:
.ie n .IP "$text" 4
.el .IP "\f(CW$text\fR" 4
.IX Item "$text"
Rxvt-unicodez special way of encodin text, where one \*(L"unicode\*(R" character
always represents one screen cell. Right back up in yo muthafuckin ass. See ROW_t fo' a gangbangin' finger-lickin' rap of dis format.
.ie n .IP "$string" 4
.el .IP "\f(CW$string\fR" 4
.IX Item "$string"
A perl text string, wit a emphasis on \fItext\fR. Well shiiiit, it can store all unicode
charactas n' is ta be distinguished wit text encoded up in a specific
encodin (often locale-specific) n' binary data.
.ie n .IP "$octets" 4
.el .IP "\f(CW$octets\fR" 4
.IX Item "$octets"
Either binary data or \- mo' common \- a text strang encoded up in a
locale-specific way.
.ie n .IP "$keysym" 4
.el .IP "\f(CW$keysym\fR" 4
.IX Item "$keysym"
an integer dat be a valid X11 keysym code. Yo ass can convert a string
into a keysym n' viceversa by rockin \f(CW\*(C`XStringToKeysym\*(C'\fR and
\&\f(CW\*(C`XKeysymToString\*(C'\fR.
.SS "Extension Objects"
.IX Subsection "Extension Objects"
Every perl extension be a perl class fo' realz. A separate perl object is pimped
for each terminal, n' each terminal has its own set of extension objects,
which is passed as tha straight-up original gangsta parameta ta hooks. Right back up in yo muthafuckin ass. So extensions can use
their \f(CW$self\fR object without havin ta be thinkin bout clashes wit other
extensions or other terminals, wit tha exception of methodz n' members
that begin wit a underscore characta \f(CW\*(C`_\*(C'\fR: these is reserved for
internal use.
.PP
Although it aint a \f(CW\*(C`urxvt::term\*(C'\fR object, you can call all methodz of the
\&\f(CW\*(C`urxvt::term\*(C'\fR class on dis object.
.PP
Additionizzle methodz only supported fo' extension objects is busted lyrics bout in
the \f(CW\*(C`urxvt::extension\*(C'\fR section below.
.SS "Hooks"
.IX Subsection "Hooks"
Da followin subroutines can be declared up in extension files, n' will be
called whenever tha relevant event happens.
.PP
Da first argument passed ta dem be a extension object as busted lyrics bout in
the up in tha \f(CW\*(C`Extension Objects\*(C'\fR section.
.PP
\&\fBAll\fR of these hooks must return a funky-ass boolean value. If any of tha called
hooks returns true, then tha event counts as bein \fIconsumed\fR, n' the
relevant action might not be carried up by tha \*(C+ code.
.PP
\&\fIWhen up in doubt, return a gangbangin' false value (preferably \f(CI\*(C`()\*(C'\fI).\fR
.ie n .IP "on_init $term" 4
.el .IP "on_init \f(CW$term\fR" 4
.IX Item "on_init $term"
Called afta a freshly smoked up terminal object has been initialized yo, but before
windows is pimped or tha command gets run. I aint talkin' bout chicken n' gravy biatch. Most methodz is unsafe to
call or serve up senseless data, as terminal size n' other characteristics
have not yet been determined. Y'all KNOW dat shit, muthafucka! Yo ass can safely query n' chizzle resources
and options, though cause I gots dem finger-lickin' chickens wit tha siz-auce. For nuff purposes tha \f(CW\*(C`on_start\*(C'\fR hook be a funky-ass better
place.
.ie n .IP "on_start $term" 4
.el .IP "on_start \f(CW$term\fR" 4
.IX Item "on_start $term"
Called all up in tha straight-up end of initialisation of a freshly smoked up terminal, just before
tryin ta map (display) tha toplevel n' returnin ta tha main loop.
.ie n .IP "on_destroy $term" 4
.el .IP "on_destroy \f(CW$term\fR" 4
.IX Item "on_destroy $term"
Called whenever suttin' tries ta destroy terminal, when tha terminal is
still straight-up functionizzle (not fo' long, though).
.ie n .IP "on_reset $term" 4
.el .IP "on_reset \f(CW$term\fR" 4
.IX Item "on_reset $term"
Called afta tha screen is \*(L"reset\*(R" fo' any reason, like fuckin resizin or
control sequences yo. Here is where you can react on chizzlez ta size-related
variables.
.ie n .IP "on_child_start $term, $pid" 4
.el .IP "on_child_start \f(CW$term\fR, \f(CW$pid\fR" 4
.IX Item "on_child_start $term, $pid"
Called just afta tha lil pimp process has been \f(CW\*(C`fork\*(C'\fRed.
.ie n .IP "on_child_exit $term, $status" 4
.el .IP "on_child_exit \f(CW$term\fR, \f(CW$status\fR" 4
.IX Item "on_child_exit $term, $status"
Called just afta tha lil pimp process has exited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. \f(CW$status\fR is tha status
from \f(CW\*(C`waitpid\*(C'\fR.
.ie n .IP "on_sel_make $term, $eventtime" 4
.el .IP "on_sel_make \f(CW$term\fR, \f(CW$eventtime\fR" 4
.IX Item "on_sel_make $term, $eventtime"
Called whenever a selection has been made by tha user yo, but before the
selection text is copied, so chizzlez ta tha beginning, end or type of the
selection is ghon be honored.
.Sp
Returnin a legit value aborts selection makin by urxvt, up in which case you
have ta cook up a selection yo ass by callin \f(CW\*(C`$term\->selection_grab\*(C'\fR.
.ie n .IP "on_sel_grab $term, $eventtime" 4
.el .IP "on_sel_grab \f(CW$term\fR, \f(CW$eventtime\fR" 4
.IX Item "on_sel_grab $term, $eventtime"
Called whenever a selection has been copied yo, but before tha selection is
axed from tha server n' shit.  Da selection text can be queried n' chizzled
by callin \f(CW\*(C`$term\->selection\*(C'\fR.
.Sp
Returnin a legit value aborts selection grabbing. Well shiiiit, it will still be highlighted.
.ie n .IP "on_sel_extend $term" 4
.el .IP "on_sel_extend \f(CW$term\fR" 4
.IX Item "on_sel_extend $term"
Called whenever tha user tries ta extend tha selection (e.g. wit a thugged-out double
click) n' is either supposed ta return false (normal operation), or
should extend tha selection itself n' return legit ta suppress tha built-in
processing. This can happen multiple times, as long as tha callback
returns true, it is ghon be called on every last muthafuckin further click by tha user n' is
supposed ta enpimpin' tha selection mo' n' more, if possible.
.Sp
See tha \fIselection\fR example extension.
.ie n .IP "on_view_change $term, $offset" 4
.el .IP "on_view_change \f(CW$term\fR, \f(CW$offset\fR" 4
.IX Item "on_view_change $term, $offset"
Called whenever tha view offset chizzles, i.e. tha user or program
scrolls. Offset \f(CW0\fR means display tha aiiight terminal, positizzle joints
show dis nuff linez of scrollback.
.ie n .IP "on_scroll_back $term, $lines, $saved" 4
.el .IP "on_scroll_back \f(CW$term\fR, \f(CW$lines\fR, \f(CW$saved\fR" 4
.IX Item "on_scroll_back $term, $lines, $saved"
Called whenever lines scroll outta tha terminal area tha fuck into tha scrollback
buffer n' shit. \f(CW$lines\fR is tha number of lines scrolled up n' may be larger
than tha scroll back buffer or tha terminal.
.Sp
It be called before lines is scrolled up (so rows 0 .. min ($lines \- 1,
\&\f(CW$nrow\fR \- 1) represent tha lines ta be scrolled out). \f(CW$saved\fR is tha total
number of lines dat is ghon be up in tha scrollback buffer.
.ie n .IP "on_osc_seq $term, $op, $args, $resp" 4
.el .IP "on_osc_seq \f(CW$term\fR, \f(CW$op\fR, \f(CW$args\fR, \f(CW$resp\fR" 4
.IX Item "on_osc_seq $term, $op, $args, $resp"
Called on every last muthafuckin \s-1OSC\s0 sequence n' can be used ta suppress it or modify its
behaviour. Shiiit, dis aint no joke. Da default should be ta return a empty list fo' realz. A legit value
suppresses execution of tha request straight-up. Make shizzle you don't get
confused by recursive invocations when you output a \s-1OSC\s0 sequence within
this callback.
.Sp
\&\f(CW\*(C`on_osc_seq_perl\*(C'\fR should be used fo' freshly smoked up behaviour.
.ie n .IP "on_osc_seq_perl $term, $args, $resp" 4
.el .IP "on_osc_seq_perl \f(CW$term\fR, \f(CW$args\fR, \f(CW$resp\fR" 4
.IX Item "on_osc_seq_perl $term, $args, $resp"
Called whenever tha \fB\s-1ESC \s0] 777 ; strang \s-1ST\s0\fR command sequence (\s-1OSC\s0 =
operatin system command) is processed. Y'all KNOW dat shit, muthafucka! Cursor posizzle n' other state
information is up-to-date when dis happens. For interoperability, the
strin should start wit tha extension name (sans \-osc) n' a semicolon,
to distinguish it from commandz fo' other extensions, n' dis might be
enforced up in tha future.
.Sp
For example, \f(CW\*(C`overlay\-osc\*(C'\fR uses this:
.Sp
.Vb 2
\&   sub on_osc_seq_perl {
\&      mah ($self, $osc, $resp) = @_;
\&
\&      return unless $osc =~ s/^overlay;//;
\&
\&      ... process remainin $osc string
\&   }
.Ve
.Sp
Be careful not eva ta trust (in a securitizzle sense) tha data you receive,
as its source can not easily be controlled (e\-mail content, lyrics from
other playas on tha same system etc.).
.Sp
For responses, \f(CW$resp\fR gotz nuff tha end-of-args separator used by the
sender.
.ie n .IP "on_add_lines $term, $string" 4
.el .IP "on_add_lines \f(CW$term\fR, \f(CW$string\fR" 4
.IX Item "on_add_lines $term, $string"
Called whenever text be bout ta be output, wit tha text as argument. You
can filter/change n' output tha text yo ass by returnin a legit value
and callin \f(CW\*(C`$term\->scr_add_lines\*(C'\fR yo ass. Please note dat this
might be straight-up slow, however, as yo' hook is called fo' \fBall\fR text being
output.
.ie n .IP "on_tt_write $term, $octets" 4
.el .IP "on_tt_write \f(CW$term\fR, \f(CW$octets\fR" 4
.IX Item "on_tt_write $term, $octets"
Called whenever some data is freestyled ta tha tty/pty n' can be used to
suppress or filta tty input.
.ie n .IP "on_tt_paste $term, $octets" 4
.el .IP "on_tt_paste \f(CW$term\fR, \f(CW$octets\fR" 4
.IX Item "on_tt_paste $term, $octets"
Called whenever text be bout ta be pasted, wit tha text as argument. You
can filter/change n' paste tha text yo ass by returnin a legit value
and callin \f(CW\*(C`$term\->tt_paste\*(C'\fR yo ass. \f(CW$octets\fR is
locale-encoded.
.ie n .IP "on_line_update $term, $row" 4
.el .IP "on_line_update \f(CW$term\fR, \f(CW$row\fR" 4
.IX Item "on_line_update $term, $row"
Called whenever a line was updated or chizzled. Y'all KNOW dat shit, muthafucka! Can be used ta filter
screen output (e.g. underline urls or other useless stuff). Only lines
that is bein shown is ghon be filtered, and, cuz of performizzle reasons,
not always immediately.
.Sp
Da row number be always tha topmost row of tha line if tha line spans
multiple rows.
.Sp
Please note that, if you chizzle tha line, then tha hook might git called
lata wit tha already-modified line (e.g. if unrelated parts chizzle), so
you cannot just toggle rendizzle bits yo, but only set em.
.ie n .IP "on_refresh_begin $term" 4
.el .IP "on_refresh_begin \f(CW$term\fR" 4
.IX Item "on_refresh_begin $term"
Called just before tha screen gets redrawn. I aint talkin' bout chicken n' gravy biatch. Can be used fo' overlay or
similar effects by modifyin tha terminal contents up in refresh_begin, and
restorin dem up in refresh_end yo, but it ain't no stoppin cause I be still poppin'. Da built-in overlay n' selection display
code is run afta dis hook, n' takes precedence.
.ie n .IP "on_refresh_end $term" 4
.el .IP "on_refresh_end \f(CW$term\fR" 4
.IX Item "on_refresh_end $term"
Called just afta tha screen gets redrawn. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See \f(CW\*(C`on_refresh_begin\*(C'\fR.
.ie n .IP "on_user_command $term, $string" 4
.el .IP "on_user_command \f(CW$term\fR, \f(CW$string\fR" 4
.IX Item "on_user_command $term, $string"
Called whenever a user-configured event is bein activated (e.g. via
a \f(CW\*(C`perl:string\*(C'\fR action bound ta a key, peep description of tha \fBkeysym\fR
resource up in tha \fIurxvt\fR\|(1) manpage).
.Sp
Da event is simply tha action string. This intercourse be assumed ta chizzle
slightly up in tha future.
.ie n .IP "on_register_command $term, $keysym, $modifiermask, $string" 4
.el .IP "on_register_command \f(CW$term\fR, \f(CW$keysym\fR, \f(CW$modifiermask\fR, \f(CW$string\fR" 4
.IX Item "on_register_command $term, $keysym, $modifiermask, $string"
Called afta parsin a keysym resource but before registerin the
associated binding. If dis hook returns \s-1TRUE\s0 tha bindin is not
registered. Y'all KNOW dat shit, muthafucka! Well shiiiit, it can be used ta modify a funky-ass bindin by calling
\&\f(CW\*(C`register_command\*(C'\fR.
.ie n .IP "on_resize_all_windows $term, $new_width, $new_height" 4
.el .IP "on_resize_all_windows \f(CW$term\fR, \f(CW$new_width\fR, \f(CW$new_height\fR" 4
.IX Item "on_resize_all_windows $term, $new_width, $new_height"
Called just afta tha freshly smoked up window size has been calculated yo, but before
windows is straight-up bein resized or hints is bein set. If dis hook
returns \s-1TRUE,\s0 settin of tha window hints is bein skipped.
.ie n .IP "on_x_event $term, $event" 4
.el .IP "on_x_event \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_x_event $term, $event"
Called on every last muthafuckin X event received on tha vt window (and possibly other
windows). Right back up in yo muthafuckin ass. Should only be used as a last resort. Most event structure
thugz is not passed.
.ie n .IP "on_root_event $term, $event" 4
.el .IP "on_root_event \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_root_event $term, $event"
Like \f(CW\*(C`on_x_event\*(C'\fR yo, but is called fo' events on tha root window.
.ie n .IP "on_focus_in $term" 4
.el .IP "on_focus_in \f(CW$term\fR" 4
.IX Item "on_focus_in $term"
Called whenever tha window gets tha keyboard focus, before rxvt-unicode
does focus up in processing.
.ie n .IP "on_focus_out $term" 4
.el .IP "on_focus_out \f(CW$term\fR" 4
.IX Item "on_focus_out $term"
Called whenever tha window loses keyboard focus, before rxvt-unicode do
focus up processing.
.ie n .IP "on_configure_notify $term, $event" 4
.el .IP "on_configure_notify \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_configure_notify $term, $event"
.PD 0
.ie n .IP "on_property_notify $term, $event" 4
.el .IP "on_property_notify \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_property_notify $term, $event"
.ie n .IP "on_key_press $term, $event, $keysym, $octets" 4
.el .IP "on_key_press \f(CW$term\fR, \f(CW$event\fR, \f(CW$keysym\fR, \f(CW$octets\fR" 4
.IX Item "on_key_press $term, $event, $keysym, $octets"
.ie n .IP "on_key_release $term, $event, $keysym" 4
.el .IP "on_key_release \f(CW$term\fR, \f(CW$event\fR, \f(CW$keysym\fR" 4
.IX Item "on_key_release $term, $event, $keysym"
.ie n .IP "on_button_press $term, $event" 4
.el .IP "on_button_press \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_button_press $term, $event"
.ie n .IP "on_button_release $term, $event" 4
.el .IP "on_button_release \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_button_release $term, $event"
.ie n .IP "on_motion_notify $term, $event" 4
.el .IP "on_motion_notify \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_motion_notify $term, $event"
.ie n .IP "on_map_notify $term, $event" 4
.el .IP "on_map_notify \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_map_notify $term, $event"
.ie n .IP "on_unmap_notify $term, $event" 4
.el .IP "on_unmap_notify \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_unmap_notify $term, $event"
.PD
Called whenever tha correspondin X event is received fo' tha terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If
the hook returns true, then tha event is ghon be ignored by rxvt-unicode.
.Sp
Da event be a hash wit most joints as named by Xlib (see tha XEvent
manpage), wit tha additionizzle thugz \f(CW\*(C`row\*(C'\fR n' \f(CW\*(C`col\*(C'\fR, which is the
(real, not screen-based) row n' column under tha mouse cursor.
.Sp
\&\f(CW\*(C`on_key_press\*(C'\fR additionally receives tha strang rxvt-unicode would
output, if any, up in locale-specific encoding.
.Sp
subwindow.
.ie n .IP "on_client_message $term, $event" 4
.el .IP "on_client_message \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_client_message $term, $event"
.PD 0
.ie n .IP "on_wm_protocols $term, $event" 4
.el .IP "on_wm_protocols \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_wm_protocols $term, $event"
.ie n .IP "on_wm_delete_window $term, $event" 4
.el .IP "on_wm_delete_window \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_wm_delete_window $term, $event"
.PD
Called when various typez of ClientMessage events is received (all with
format=32, \s-1WM_PROTOCOLS\s0 or \s-1WM_PROTOCOLS:WM_DELETE_WINDOW\s0).
.ie n .IP "on_bell $term" 4
.el .IP "on_bell \f(CW$term\fR" 4
.IX Item "on_bell $term"
Called on receipt of a funky-ass bell character.
.ie n .SS "Variablez up in tha ""urxvt"" Package"
.el .SS "Variablez up in tha \f(CWurxvt\fP Package"
.IX Subsection "Variablez up in tha urxvt Package"
.ie n .IP "$urxvt::LIBDIR" 4
.el .IP "\f(CW$urxvt::LIBDIR\fR" 4
.IX Item "$urxvt::LIBDIR"
Da rxvt-unicode library directory, where, among other thangs, tha perl
modulez n' scripts is stored.
.ie n .IP "$urxvt::RESCLASS, $urxvt::RESCLASS" 4
.el .IP "\f(CW$urxvt::RESCLASS\fR, \f(CW$urxvt::RESCLASS\fR" 4
.IX Item "$urxvt::RESCLASS, $urxvt::RESCLASS"
Da resource class n' name rxvt-unicode uses ta look up X resources.
.ie n .IP "$urxvt::RXVTNAME" 4
.el .IP "\f(CW$urxvt::RXVTNAME\fR" 4
.IX Item "$urxvt::RXVTNAME"
Da basename of tha installed binaries, probably \f(CW\*(C`urxvt\*(C'\fR.
.ie n .IP "$urxvt::TERM" 4
.el .IP "\f(CW$urxvt::TERM\fR" 4
.IX Item "$urxvt::TERM"
Da current terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. This variable stores tha current \f(CW\*(C`urxvt::term\*(C'\fR
object, whenever a cold-ass lil callback/hook is executing.
.ie n .IP "@urxvt::TERM_INIT" 4
.el .IP "\f(CW@urxvt::TERM_INIT\fR" 4
.IX Item "@urxvt::TERM_INIT"
All code references up in dis array is ghon be called as methodz of tha next newly
created \f(CW\*(C`urxvt::term\*(C'\fR object (durin tha \f(CW\*(C`on_init\*(C'\fR phase). Da array
gets cleared before tha code references dat was up in it is bein executed,
so references can push theyselves onto it again n' again n' again if they so desire.
.Sp
This complements ta tha perl-eval command line option yo, but gets executed
first.
.ie n .IP "@urxvt::TERM_EXT" 4
.el .IP "\f(CW@urxvt::TERM_EXT\fR" 4
.IX Item "@urxvt::TERM_EXT"
Works similar ta \f(CW@TERM_INIT\fR yo, but gotz nuff perl package/class names, which
get registered as aiiight extensions afta callin tha hooks up in \f(CW@TERM_INIT\fR
but before other extensions. Gets cleared just like \f(CW@TERM_INIT\fR.
.ie n .SS "Functions up in tha ""urxvt"" Package"
.el .SS "Functions up in tha \f(CWurxvt\fP Package"
.IX Subsection "Functions up in tha urxvt Package"
.ie n .IP "urxvt::fatal $errormessage" 4
.el .IP "urxvt::fatal \f(CW$errormessage\fR" 4
.IX Item "urxvt::fatal $errormessage"
Fatally aborts execution wit tha given error message (which should
include a trailin newline) fo' realz. Avoid at all costs muthafucka! Da only time this
is aaight (and useful) is up in tha init hook, where it prevents the
terminal from startin up.
.ie n .IP "urxvt::warn $string" 4
.el .IP "urxvt::warn \f(CW$string\fR" 4
.IX Item "urxvt::warn $string"
Calls \f(CW\*(C`rxvt_warn\*(C'\fR wit tha given strang which should include a trailing
newline. Da module also overwrites tha \f(CW\*(C`warn\*(C'\fR builtin wit a gangbangin' function
that calls dis function.
.Sp
Usin dis function has tha advantage dat its output endz up in the
correct place, e.g. on stderr of tha connectin urxvtc client.
.Sp
Lyrics gotz a size limit of 1023 bytes currently.
.ie n .IP "@terms = urxvt::termlist" 4
.el .IP "\f(CW@terms\fR = urxvt::termlist" 4
.IX Item "@terms = urxvt::termlist"
Returns all urxvt::term objects dat exist up in dis process, regardless of
whether they is started, bein destroyed etc., so be careful naaahhmean, biatch? Only term
objects dat have perl extensions attached is ghon be returned (because there
is no urxvt::term object associated wit others).
.ie n .IP "$time = urxvt::NOW" 4
.el .IP "\f(CW$time\fR = urxvt::NOW" 4
.IX Item "$time = urxvt::NOW"
Returns tha \*(L"current time\*(R" (as per tha event loop).
.IP "urxvt::CurrentTime" 4
.IX Item "urxvt::CurrentTime"
.PD 0
.IP "urxvt::ShiftMask, LockMask, ControlMask, Mod1Mask, Mod2Mask, Mod3Mask, Mod4Mask, Mod5Mask, Button1Mask, Button2Mask, Button3Mask, Button4Mask, Button5Mask, AnyModifier" 4
.IX Item "urxvt::ShiftMask, LockMask, ControlMask, Mod1Mask, Mod2Mask, Mod3Mask, Mod4Mask, Mod5Mask, Button1Mask, Button2Mask, Button3Mask, Button4Mask, Button5Mask, AnyModifier"
.IP "urxvt::NoEventMask, KeyPressMask, KeyReleaseMask, ButtonPressMask, ButtonReleaseMask, EnterWindowMask, LeaveWindowMask, PointerMotionMask, PointerMotionHintMask, Button1MotionMask, Button2MotionMask, Button3MotionMask, Button4MotionMask, Button5MotionMask, ButtonMotionMask, KeymapStateMask, ExposureMask, VisibilityChangeMask, StructureNotifyMask, ResizeRedirectMask, SubstructureNotifyMask, SubstructureRedirectMask, FocusChangeMask, PropertyChangeMask, ColormapChangeMask, OwnerGrabButtonMask" 4
.IX Item "urxvt::NoEventMask, KeyPressMask, KeyReleaseMask, ButtonPressMask, ButtonReleaseMask, EnterWindowMask, LeaveWindowMask, PointerMotionMask, PointerMotionHintMask, Button1MotionMask, Button2MotionMask, Button3MotionMask, Button4MotionMask, Button5MotionMask, ButtonMotionMask, KeymapStateMask, ExposureMask, VisibilityChangeMask, StructureNotifyMask, ResizeRedirectMask, SubstructureNotifyMask, SubstructureRedirectMask, FocusChangeMask, PropertyChangeMask, ColormapChangeMask, OwnerGrabButtonMask"
.IP "urxvt::KeyPress, KeyRelease, ButtonPress, ButtonRelease, MotionNotify, EnterNotify, LeaveNotify, FocusIn, FocusOut, KeymapNotify, Expose, GraphicsExpose, NoExpose, VisibilityNotify, CreateNotify, DestroyNotify, UnmapNotify, MapNotify, MapRequest, ReparentNotify, ConfigureNotify, ConfigureRequest, GravityNotify, ResizeRequest, CirculateNotify, CirculateRequest, PropertyNotify, SelectionClear, SelectionRequest, SelectionNotify, ColormapNotify, ClientMessage, MappingNotify" 4
.IX Item "urxvt::KeyPress, KeyRelease, ButtonPress, ButtonRelease, MotionNotify, EnterNotify, LeaveNotify, FocusIn, FocusOut, KeymapNotify, Expose, GraphicsExpose, NoExpose, VisibilityNotify, CreateNotify, DestroyNotify, UnmapNotify, MapNotify, MapRequest, ReparentNotify, ConfigureNotify, ConfigureRequest, GravityNotify, ResizeRequest, CirculateNotify, CirculateRequest, PropertyNotify, SelectionClear, SelectionRequest, SelectionNotify, ColormapNotify, ClientMessage, MappingNotify"
.PD
Various constants fo' use up in X calls n' event processing.
.SS "\s-1RENDITION\s0"
.IX Subsection "RENDITION"
Rendizzle bitsets contain shiznit bout colour, font, font stylez and
similar shiznit fo' each screen cell.
.PP
Da followin \*(L"macros\*(R" deal wit chizzlez up in rendizzle sets, n' you can put dat on yo' toast. Yo ass should
never just create a funky-ass bitset, you should always modify a existin one,
as they contain blingin shiznit required fo' erect operation of
rxvt-unicode.
.ie n .IP "$rend = urxvt::DEFAULT_RSTYLE" 4
.el .IP "\f(CW$rend\fR = urxvt::DEFAULT_RSTYLE" 4
.IX Item "$rend = urxvt::DEFAULT_RSTYLE"
Returns tha default rendition, as used when tha terminal is startin up or
bein reset. Useful as a funky-ass base ta start when bustin renditions.
.ie n .IP "$rend = urxvt::OVERLAY_RSTYLE" 4
.el .IP "\f(CW$rend\fR = urxvt::OVERLAY_RSTYLE" 4
.IX Item "$rend = urxvt::OVERLAY_RSTYLE"
Return tha rendizzle mask used fo' overlays by default.
.ie n .IP "$rendbit = urxvt::RS_Bold, urxvt::RS_Italic, urxvt::RS_Blink, urxvt::RS_RVid, urxvt::RS_Uline" 4
.el .IP "\f(CW$rendbit\fR = urxvt::RS_Bold, urxvt::RS_Italic, urxvt::RS_Blink, urxvt::RS_RVid, urxvt::RS_Uline" 4
.IX Item "$rendbit = urxvt::RS_Bold, urxvt::RS_Italic, urxvt::RS_Blink, urxvt::RS_RVid, urxvt::RS_Uline"
Return tha bit dat enabled bold, italic, blink, reverse-video and
underline, respectively. To enable such a style, just logically \s-1OR\s0 it into
the bitset.
.ie n .IP "$foreground = urxvt::GET_BASEFG $rend" 4
.el .IP "\f(CW$foreground\fR = urxvt::GET_BASEFG \f(CW$rend\fR" 4
.IX Item "$foreground = urxvt::GET_BASEFG $rend"
.PD 0
.ie n .IP "$background = urxvt::GET_BASEBG $rend" 4
.el .IP "\f(CW$background\fR = urxvt::GET_BASEBG \f(CW$rend\fR" 4
.IX Item "$background = urxvt::GET_BASEBG $rend"
.PD
Return tha foreground/background colour index, respectively.
.ie n .IP "$rend = urxvt::SET_FGCOLOR $rend, $new_colour" 4
.el .IP "\f(CW$rend\fR = urxvt::SET_FGCOLOR \f(CW$rend\fR, \f(CW$new_colour\fR" 4
.IX Item "$rend = urxvt::SET_FGCOLOR $rend, $new_colour"
.PD 0
.ie n .IP "$rend = urxvt::SET_BGCOLOR $rend, $new_colour" 4
.el .IP "\f(CW$rend\fR = urxvt::SET_BGCOLOR \f(CW$rend\fR, \f(CW$new_colour\fR" 4
.IX Item "$rend = urxvt::SET_BGCOLOR $rend, $new_colour"
.ie n .IP "$rend = urxvt::SET_COLOR $rend, $new_fg, $new_bg" 4
.el .IP "\f(CW$rend\fR = urxvt::SET_COLOR \f(CW$rend\fR, \f(CW$new_fg\fR, \f(CW$new_bg\fR" 4
.IX Item "$rend = urxvt::SET_COLOR $rend, $new_fg, $new_bg"
.PD
Replace tha foreground/background colour up in tha rendizzle mask wit the
specified one.
.ie n .IP "$value = urxvt::GET_CUSTOM $rend" 4
.el .IP "\f(CW$value\fR = urxvt::GET_CUSTOM \f(CW$rend\fR" 4
.IX Item "$value = urxvt::GET_CUSTOM $rend"
Return tha \*(L"custom\*(R" value: Every rendizzle has 5 bits fo' use by
extensions. They can be set n' chizzled as you like n' is initially
zero.
.ie n .IP "$rend = urxvt::SET_CUSTOM $rend, $new_value" 4
.el .IP "\f(CW$rend\fR = urxvt::SET_CUSTOM \f(CW$rend\fR, \f(CW$new_value\fR" 4
.IX Item "$rend = urxvt::SET_CUSTOM $rend, $new_value"
Change tha custom value.
.ie n .SS "Da ""urxvt::term::extension"" class"
.el .SS "Da \f(CWurxvt::term::extension\fP class"
.IX Subsection "Da urxvt::term::extension class"
Each extension attached ta a terminal object is represented by
a \f(CW\*(C`urxvt::term::extension\*(C'\fR object.
.PP
Yo ass can use these objects, which is passed ta all callbacks ta store any
state related ta tha terminal n' extension instance.
.PP
Da methodz (And data members) documented below can be called on extension
objects, up in addizzle ta booty-call methodz documented fo' tha <urxvt::term>
class.
.ie n .IP "$urxvt_term = $self\->{term}" 4
.el .IP "\f(CW$urxvt_term\fR = \f(CW$self\fR\->{term}" 4
.IX Item "$urxvt_term = $self->{term}"
Returns tha \f(CW\*(C`urxvt::term\*(C'\fR object associated wit dis instizzle of the
extension. I aint talkin' bout chicken n' gravy biatch. This member \fImust not\fR be chizzled up in any way.
.ie n .IP "$self\->enable ($hook_name => $cb[, $hook_name => $cb..])" 4
.el .IP "\f(CW$self\fR\->enable ($hook_name => \f(CW$cb\fR[, \f(CW$hook_name\fR => \f(CW$cb\fR..])" 4
.IX Item "$self->enable ($hook_name => $cb[, $hook_name => $cb..])"
Dynamically enable tha given hooks (named without tha \f(CW\*(C`on_\*(C'\fR prefix) for
this extension, replacin any previous hook. This is useful when you want
to overwrite time-critical hooks only temporarily.
.Sp
To install additionizzle callbacks fo' tha same hook, you can use tha \f(CW\*(C`on\*(C'\fR
method of tha \f(CW\*(C`urxvt::term\*(C'\fR class.
.ie n .IP "$self\->disable ($hook_name[, $hook_name..])" 4
.el .IP "\f(CW$self\fR\->disable ($hook_name[, \f(CW$hook_name\fR..])" 4
.IX Item "$self->disable ($hook_name[, $hook_name..])"
Dynamically disable tha given hooks.
.ie n .IP "$guard = $self\->on ($hook_name => $cb[, $hook_name => $cb..])" 4
.el .IP "\f(CW$guard\fR = \f(CW$self\fR\->on ($hook_name => \f(CW$cb\fR[, \f(CW$hook_name\fR => \f(CW$cb\fR..])" 4
.IX Item "$guard = $self->on ($hook_name => $cb[, $hook_name => $cb..])"
Similar ta tha \f(CW\*(C`enable\*(C'\fR enable yo, but installs additionizzle callbacks for
the given hook(s) (that is, it don't replace existin callbacks), and
returns a guard object. When tha guard object is destroyed tha callbacks
are disabled again.
.ie n .IP "$self\->x_resource ($pattern)" 4
.el .IP "\f(CW$self\fR\->x_resource ($pattern)" 4
.IX Item "$self->x_resource ($pattern)"
.PD 0
.ie n .IP "$self\->x_resource_boolean ($pattern)" 4
.el .IP "\f(CW$self\fR\->x_resource_boolean ($pattern)" 4
.IX Item "$self->x_resource_boolean ($pattern)"
.PD
These methodz support a additionizzle \f(CW\*(C`%\*(C'\fR prefix when called on an
extension object \- peep tha description of these methodz up in the
\&\f(CW\*(C`urxvt::term\*(C'\fR class fo' details.
.ie n .SS "Da ""urxvt::anyevent"" Class"
.el .SS "Da \f(CWurxvt::anyevent\fP Class"
.IX Subsection "Da urxvt::anyevent Class"
Da sole purpose of dis class is ta serve up a intercourse ta the
\&\f(CW\*(C`AnyEvent\*(C'\fR module \- any module rockin it will work inside urxvt without
further programming. Da only exception is dat you cannot wait on
condizzle variablez yo, but non-blockin condvar use is ok.
.PP
In practical terms dis means is dat you cannot use blockin APIs yo, but
the non-blockin variant should work.
.ie n .SS "Da ""urxvt::term"" Class"
.el .SS "Da \f(CWurxvt::term\fP Class"
.IX Subsection "Da urxvt::term Class"
.ie n .IP "$term = freshly smoked up urxvt::term $envhashref, $rxvtname, [arg...]" 4
.el .IP "\f(CW$term\fR = freshly smoked up urxvt::term \f(CW$envhashref\fR, \f(CW$rxvtname\fR, [arg...]" 4
.IX Item "$term = freshly smoked up urxvt::term $envhashref, $rxvtname, [arg...]"
Creates a freshly smoked up terminal, straight-up similar as if you had started it wit system
\&\f(CW\*(C`$rxvtname, arg...\*(C'\fR. \f(CW$envhashref\fR must be a reference ta a \f(CW%ENV\fR\-like
hash which defines tha environment of tha freshly smoked up terminal.
.Sp
Croaks (and probably outputs a error message) if tha freshly smoked up instance
couldn't be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Returns \f(CW\*(C`undef\*(C'\fR if tha freshly smoked up instizzle didn't
initialise perl, n' tha terminal object otherwise. Da \f(CW\*(C`init\*(C'\fR and
\&\f(CW\*(C`start\*(C'\fR hooks is ghon be called before dis call returns, n' is free to
refer ta global data (which is race free).
.ie n .IP "$term\->destroy" 4
.el .IP "\f(CW$term\fR\->destroy" 4
.IX Item "$term->destroy"
Destroy tha terminal object (close tha window, free resources
etc.). Please note dat urxvt aint gonna exit as long as any event
watchers (timers, io watchers) is still active.
.ie n .IP "$term\->exec_async ($cmd[, @args])" 4
.el .IP "\f(CW$term\fR\->exec_async ($cmd[, \f(CW@args\fR])" 4
.IX Item "$term->exec_async ($cmd[, @args])"
Works like tha combination of tha \f(CW\*(C`fork\*(C'\fR/\f(CW\*(C`exec\*(C'\fR builtins, which executes
(\*(L"starts\*(R") programs up in tha background. Y'all KNOW dat shit, muthafucka! This function takes care of setting
the user environment before exec'in tha command (e.g. \f(CW\*(C`PATH\*(C'\fR) n' should
be preferred over explicit calls ta \f(CW\*(C`exec\*(C'\fR or \f(CW\*(C`system\*(C'\fR.
.Sp
Returns tha pid of tha subprocess or \f(CW\*(C`undef\*(C'\fR on error.
.ie n .IP "$isset = $term\->option ($optval[, $set])" 4
.el .IP "\f(CW$isset\fR = \f(CW$term\fR\->option ($optval[, \f(CW$set\fR])" 4
.IX Item "$isset = $term->option ($optval[, $set])"
Returns legit if tha option specified by \f(CW$optval\fR is enabled, and
optionally chizzle it fo' realz. All option joints is stored by name up in tha hash
\&\f(CW%urxvt::OPTION\fR. Options not enabled up in dis binary is not up in tha hash.
.Sp
Here be a likely non-exhaustizzle list of option names, please peep the
source file \fI/src/optinc.h\fR ta peep tha actual list:
.Sp
.Vb 7
\& borderLess buffered console cursorBlink cursorUnderline hold iconic
\& insecure intensityStylez iso14755 iso14755_52 jumpScroll loginShell
\& mapAlert meta8 mouseWheelScrollPage override_redirect pastableTabs
\& pointerBlank reverseVideo scrollBar scrollBar_floatin scrollBar_right
\& scrollTtyKeypress scrollTtyOutput scrollWithBuffer secondaryScreen
\& secondaryScroll skipBuiltinGlyphs skipScroll transparent tripleclickwords
\& urgentOnBell utmpInhibit visualBell
.Ve
.ie n .IP "$value = $term\->resource ($name[, $newval])" 4
.el .IP "\f(CW$value\fR = \f(CW$term\fR\->resource ($name[, \f(CW$newval\fR])" 4
.IX Item "$value = $term->resource ($name[, $newval])"
Returns tha current resource value associated wit a given name and
optionally sets a freshly smoked up value. Right back up in yo muthafuckin ass. Settin joints is most useful up in tha \f(CW\*(C`init\*(C'\fR
hook. Unset resources is returned n' accepted as \f(CW\*(C`undef\*(C'\fR.
.Sp
Da freshly smoked up value must be properly encoded ta a suitable characta encoding
before passin it ta dis method. Y'all KNOW dat shit, muthafucka! Similarly, tha returned value may need
to be converted from tha used encodin ta text.
.Sp
Resource names is as defined up in \fIsrc/rsinc.h\fR. Colours can be specified
as resource namez of tha form \f(CW\*(C`color+<index>\*(C'\fR, e.g. \f(CW\*(C`color+5\*(C'\fR. (will
likely chizzle).
.Sp
Please note dat resource strings will currently only be freed when the
terminal is destroyed, so changin options frequently will smoke memory.
.Sp
Here be a likely non-exhaustizzle list of resource names, not all of which
are supported up in every last muthafuckin build, please peep tha source file \fI/src/rsinc.h\fR
to peep tha actual list:
.Sp
.Vb 10
\&  answerbackstrin backgroundPixmap backspace_key blurradius
\&  boldFont boldItalicFont borderLess buffered chdir color cursorBlink
\&  cursorUnderline cutchars delete_key depth display_name embed ext_bwidth
\&  fade font geometry hold iconName iconfile imFont imLocale inputMethod
\&  insecure int_bwidth intensityStylez iso14755 iso14755_52 italicFont
\&  jumpScroll letterSpace lineSpace loginShell mapAlert meta8 modifier
\&  mouseWheelScrollPage name override_redirect pastableTabs path perl_eval
\&  perl_ext_1 perl_ext_2 perl_lib pointerBlank pointerBlankDelay
\&  preeditType print_pipe pty_fd reverseVideo saveLines scrollBar
\&  scrollBar_align scrollBar_floatin scrollBar_right scrollBar_thickness
\&  scrollTtyKeypress scrollTtyOutput scrollWithBuffer scrollstyle
\&  secondaryScreen secondaryScroll shade skipBuiltinGlyphs skipScroll
\&  term_name title transient_for transparent tripleclickwordz urgentOnBell
\&  utmpInhibit visualBell
.Ve
.ie n .IP "$value = $term\->x_resource ($pattern)" 4
.el .IP "\f(CW$value\fR = \f(CW$term\fR\->x_resource ($pattern)" 4
.IX Item "$value = $term->x_resource ($pattern)"
Returns tha X\-Resource fo' tha given pattern, excludin tha program or
class name, i.e.  \f(CW\*(C`$term\->x_resource ("boldFont")\*(C'\fR should return the
same value as used by dis instizzle of rxvt-unicode. Returns \f(CW\*(C`undef\*(C'\fR if no
resource wit dat pattern exists.
.Sp
Extensions dat define extra resource or command line arguments also need
to call dis method ta access they joints.
.Sp
If tha method is called on a extension object (basically, from an
extension), then tha special prefix \f(CW\*(C`%.\*(C'\fR is ghon be replaced by tha name of
the extension n' a thugged-out dot, n' tha lone strang \f(CW\*(C`%\*(C'\fR is ghon be replaced by the
extension name itself. This make it possible ta code extensions so you
can rename dem n' git a freshly smoked up set of commandline switches n' resources
without havin ta chizzle tha actual code.
.Sp
This method should only be called durin tha \f(CW\*(C`on_start\*(C'\fR hook, as there is
only one resource database per display, n' lata invocations might return
the wack resources.
.ie n .IP "$value = $term\->x_resource_boolean ($pattern)" 4
.el .IP "\f(CW$value\fR = \f(CW$term\fR\->x_resource_boolean ($pattern)" 4
.IX Item "$value = $term->x_resource_boolean ($pattern)"
Like \f(CW\*(C`x_resource\*(C'\fR, above yo, but interprets tha strang value as a funky-ass boolean
and returns \f(CW1\fR fo' legit joints, \f(CW0\fR fo' false joints n' \f(CW\*(C`undef\*(C'\fR if
the resource or option aint specified.
.Sp
Yo ass should always use dis method ta parse boolean resources.
.ie n .IP "$success = $term\->parse_keysym ($key, $octets)" 4
.el .IP "\f(CW$success\fR = \f(CW$term\fR\->parse_keysym ($key, \f(CW$octets\fR)" 4
.IX Item "$success = $term->parse_keysym ($key, $octets)"
Addz a key bindin exactly as specified via a resource. Right back up in yo muthafuckin ass. See the
\&\f(CW\*(C`keysym\*(C'\fR resource up in tha \fIurxvt\fR\|(1) manpage.
.ie n .IP "$term\->register_command ($keysym, $modifiermask, $string)" 4
.el .IP "\f(CW$term\fR\->register_command ($keysym, \f(CW$modifiermask\fR, \f(CW$string\fR)" 4
.IX Item "$term->register_command ($keysym, $modifiermask, $string)"
Addz a key binding. This be a lower level api compared to
\&\f(CW\*(C`parse_keysym\*(C'\fR, as it expects a parsed key description, n' can be
used only inside either tha \f(CW\*(C`on_init\*(C'\fR hook, ta add a funky-ass binding, or the
\&\f(CW\*(C`on_register_command\*(C'\fR hook, ta modify a parsed binding.
.ie n .IP "$rend = $term\->rstyle ([$new_rstyle])" 4
.el .IP "\f(CW$rend\fR = \f(CW$term\fR\->rstyle ([$new_rstyle])" 4
.IX Item "$rend = $term->rstyle ([$new_rstyle])"
Return n' optionally chizzle tha current rendition. I aint talkin' bout chicken n' gravy biatch. Text dat is output by
the terminal application will use dis style.
.ie n .IP "($row, $col) = $term\->screen_cur ([$row, $col])" 4
.el .IP "($row, \f(CW$col\fR) = \f(CW$term\fR\->screen_cur ([$row, \f(CW$col\fR])" 4
.IX Item "($row, $col) = $term->screen_cur ([$row, $col])"
Return tha current coordinatez of tha text cursor posizzle n' optionally
set it (which is probably wack as applications don't expect that).
.ie n .IP "($row, $col) = $term\->selection_mark ([$row, $col])" 4
.el .IP "($row, \f(CW$col\fR) = \f(CW$term\fR\->selection_mark ([$row, \f(CW$col\fR])" 4
.IX Item "($row, $col) = $term->selection_mark ([$row, $col])"
.PD 0
.ie n .IP "($row, $col) = $term\->selection_beg ([$row, $col])" 4
.el .IP "($row, \f(CW$col\fR) = \f(CW$term\fR\->selection_beg ([$row, \f(CW$col\fR])" 4
.IX Item "($row, $col) = $term->selection_beg ([$row, $col])"
.ie n .IP "($row, $col) = $term\->selection_end ([$row, $col])" 4
.el .IP "($row, \f(CW$col\fR) = \f(CW$term\fR\->selection_end ([$row, \f(CW$col\fR])" 4
.IX Item "($row, $col) = $term->selection_end ([$row, $col])"
.PD
Return tha current jointz of tha selection mark, begin or end positions.
.Sp
When arguments is given, then tha selection coordinates is set to
\&\f(CW$row\fR n' \f(CW$col\fR, n' tha selection screen is set ta tha current
screen.
.ie n .IP "$screen = $term\->selection_screen ([$screen])" 4
.el .IP "\f(CW$screen\fR = \f(CW$term\fR\->selection_screen ([$screen])" 4
.IX Item "$screen = $term->selection_screen ([$screen])"
Returns tha current selection screen, n' then optionally sets dat shit.
.ie n .IP "$term\->selection_make ($eventtime[, $rectangular])" 4
.el .IP "\f(CW$term\fR\->selection_make ($eventtime[, \f(CW$rectangular\fR])" 4
.IX Item "$term->selection_make ($eventtime[, $rectangular])"
Tries ta cook up a selection as set by \f(CW\*(C`selection_beg\*(C'\fR and
\&\f(CW\*(C`selection_end\*(C'\fR. If \f(CW$rectangular\fR is legit (default: false), a
rectangular selection is ghon be made. This is tha preferred function ta make
a selection.
.ie n .IP "$success = $term\->selection_grab ($eventtime[, $clipboard])" 4
.el .IP "\f(CW$success\fR = \f(CW$term\fR\->selection_grab ($eventtime[, \f(CW$clipboard\fR])" 4
.IX Item "$success = $term->selection_grab ($eventtime[, $clipboard])"
Try ta acquire ballershizzle of tha primary (clipboard if \f(CW$clipboard\fR is
true) selection from tha server n' shit. Da correspondin text can be set
with tha next method. Y'all KNOW dat shit, muthafucka! No visual feedback is ghon be given. I aint talkin' bout chicken n' gravy biatch. This function
is mostly useful from within \f(CW\*(C`on_sel_grab\*(C'\fR hooks.
.ie n .IP "$oldtext = $term\->selection ([$newtext, $clipboard])" 4
.el .IP "\f(CW$oldtext\fR = \f(CW$term\fR\->selection ([$newtext, \f(CW$clipboard\fR])" 4
.IX Item "$oldtext = $term->selection ([$newtext, $clipboard])"
Return tha current selection (clipboard if \f(CW$clipboard\fR is true) text
and optionally replace it by \f(CW$newtext\fR.
.ie n .IP "$term\->selection_clear ([$clipboard])" 4
.el .IP "\f(CW$term\fR\->selection_clear ([$clipboard])" 4
.IX Item "$term->selection_clear ([$clipboard])"
Revoke ballershizzle of tha primary (clipboard if \f(CW$clipboard\fR is true) selection.
.ie n .IP "$term\->overlay_simple ($x, $y, $text)" 4
.el .IP "\f(CW$term\fR\->overlay_simple ($x, \f(CW$y\fR, \f(CW$text\fR)" 4
.IX Item "$term->overlay_simple ($x, $y, $text)"
Smoke a simple multi-line overlay box. Right back up in yo muthafuckin ass. See tha next method fo' details.
.ie n .IP "$term\->overlay ($x, $y, $width, $height[, $rstyle[, $border]])" 4
.el .IP "\f(CW$term\fR\->overlay ($x, \f(CW$y\fR, \f(CW$width\fR, \f(CW$height\fR[, \f(CW$rstyle\fR[, \f(CW$border\fR]])" 4
.IX Item "$term->overlay ($x, $y, $width, $height[, $rstyle[, $border]])"
Smoke a freshly smoked up (empty) overlay all up in tha given posizzle wit tha given
width/height. \f(CW$rstyle\fR defines tha initial rendizzle style
(default: \f(CW\*(C`OVERLAY_RSTYLE\*(C'\fR).
.Sp
If \f(CW$border\fR is \f(CW2\fR (default), then a thugged-out decoratizzle border is ghon be put
around tha box.
.Sp
If either \f(CW$x\fR or \f(CW$y\fR is negative, then dis is counted from the
right/bottom side, respectively.
.Sp
This method returns a urxvt::overlay object. Da overlay is ghon be visible
as long as tha perl object is referenced.
.Sp
Da methodz currently supported on \f(CW\*(C`urxvt::overlay\*(C'\fR objects are:
.RS 4
.ie n .IP "$overlay\->set ($x, $y, $text[, $rend])" 4
.el .IP "\f(CW$overlay\fR\->set ($x, \f(CW$y\fR, \f(CW$text\fR[, \f(CW$rend\fR])" 4
.IX Item "$overlay->set ($x, $y, $text[, $rend])"
Similar ta \f(CW\*(C`$term\->ROW_t\*(C'\fR n' \f(CW\*(C`$term\->ROW_r\*(C'\fR up in dat it puts
text up in rxvt-unicodez special encodin n' a array of rendizzle joints
at a specific posizzle inside tha overlay.
.Sp
If \f(CW$rend\fR is missing, then tha rendizzle aint gonna be chizzled.
.ie n .IP "$overlay\->hide" 4
.el .IP "\f(CW$overlay\fR\->hide" 4
.IX Item "$overlay->hide"
If visible, hide tha overlay yo, but do not destroy dat shit.
.ie n .IP "$overlay\->show" 4
.el .IP "\f(CW$overlay\fR\->show" 4
.IX Item "$overlay->show"
If hidden, display tha overlay again.
.RE
.RS 4
.RE
.ie n .IP "$popup = $term\->popup ($event)" 4
.el .IP "\f(CW$popup\fR = \f(CW$term\fR\->popup ($event)" 4
.IX Item "$popup = $term->popup ($event)"
Creates a freshly smoked up \f(CW\*(C`urxvt::popup\*(C'\fR object dat implements a popup menu fo'sho. The
\&\f(CW$event\fR \fImust\fR be tha event causin tha menu ta pop up (a button event,
currently).
.ie n .IP "$cellwidth = $term\->strwidth ($string)" 4
.el .IP "\f(CW$cellwidth\fR = \f(CW$term\fR\->strwidth ($string)" 4
.IX Item "$cellwidth = $term->strwidth ($string)"
Returns tha number of screen-cells dis strang would need. Y'all KNOW dat shit, muthafucka! Correctly
accounts fo' wide n' combinin characters.
.ie n .IP "$octets = $term\->locale_encode ($string)" 4
.el .IP "\f(CW$octets\fR = \f(CW$term\fR\->locale_encode ($string)" 4
.IX Item "$octets = $term->locale_encode ($string)"
Convert tha given text strang tha fuck into tha correspondin locale encoding.
.ie n .IP "$strin = $term\->locale_decode ($octets)" 4
.el .IP "\f(CW$string\fR = \f(CW$term\fR\->locale_decode ($octets)" 4
.IX Item "$strin = $term->locale_decode ($octets)"
Convert tha given locale-encoded octets tha fuck into a perl string.
.ie n .IP "$term\->scr_xor_span ($beg_row, $beg_col, $end_row, $end_col[, $rstyle])" 4
.el .IP "\f(CW$term\fR\->scr_xor_span ($beg_row, \f(CW$beg_col\fR, \f(CW$end_row\fR, \f(CW$end_col\fR[, \f(CW$rstyle\fR])" 4
.IX Item "$term->scr_xor_span ($beg_row, $beg_col, $end_row, $end_col[, $rstyle])"
XORs tha rendizzle joints up in tha given span wit tha provided value
(default: \f(CW\*(C`RS_RVid\*(C'\fR), which \fI\s-1MUST NOT\s0\fR contain font styles. Useful in
refresh hooks ta provide effects similar ta tha selection.
.ie n .IP "$term\->scr_xor_rect ($beg_row, $beg_col, $end_row, $end_col[, $rstyle1[, $rstyle2]])" 4
.el .IP "\f(CW$term\fR\->scr_xor_rect ($beg_row, \f(CW$beg_col\fR, \f(CW$end_row\fR, \f(CW$end_col\fR[, \f(CW$rstyle1\fR[, \f(CW$rstyle2\fR]])" 4
.IX Item "$term->scr_xor_rect ($beg_row, $beg_col, $end_row, $end_col[, $rstyle1[, $rstyle2]])"
Similar ta \f(CW\*(C`scr_xor_span\*(C'\fR yo, but xors a rectangle instead. Y'all KNOW dat shit, muthafucka! Trailing
whitespace will additionally be xored wit tha \f(CW$rstyle2\fR, which defaults
to \f(CW\*(C`RS_RVid | RS_Uline\*(C'\fR, which removes reverse vizzle again n' again n' again n' underlines
it instead. Y'all KNOW dat shit, muthafucka! Both stylez \fI\s-1MUST NOT\s0\fR contain font styles.
.ie n .IP "$term\->scr_bell" 4
.el .IP "\f(CW$term\fR\->scr_bell" 4
.IX Item "$term->scr_bell"
Rin tha bell!
.ie n .IP "$term\->scr_add_lines ($string)" 4
.el .IP "\f(CW$term\fR\->scr_add_lines ($string)" 4
.IX Item "$term->scr_add_lines ($string)"
Write tha given text strang ta tha screen, as if output by tha application
runnin inside tha terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Well shiiiit, it may not contain command sequences (escape
codes) yo, but is free ta use line feeds, carriage returns n' tabs. The
strin be a aiiight text string, not up in locale-dependent encoding.
.Sp
Normally its not a phat scam ta use dis function, as programs might be
confused by chizzlez up in cursor posizzle or scrolling. Its useful inside a
\&\f(CW\*(C`on_add_lines\*(C'\fR hook, though.
.ie n .IP "$term\->scr_change_screen ($screen)" 4
.el .IP "\f(CW$term\fR\->scr_change_screen ($screen)" 4
.IX Item "$term->scr_change_screen ($screen)"
Switch ta given screen \- 0 primary, 1 secondary.
.ie n .IP "$term\->cmd_parse ($octets)" 4
.el .IP "\f(CW$term\fR\->cmd_parse ($octets)" 4
.IX Item "$term->cmd_parse ($octets)"
Similar ta \f(CW\*(C`scr_add_lines\*(C'\fR yo, but tha argument must be up in the
locale-specific encodin of tha terminal n' can contain command sequences
(escape codes) dat is ghon be interpreted.
.ie n .IP "$term\->tt_write ($octets)" 4
.el .IP "\f(CW$term\fR\->tt_write ($octets)" 4
.IX Item "$term->tt_write ($octets)"
Write tha octets given up in \f(CW$octets\fR ta tha tty (i.e. as program input). To
pass charactas instead of octets, you should convert yo' strings first
to tha locale-specific encodin rockin \f(CW\*(C`$term\->locale_encode\*(C'\fR.
.ie n .IP "$term\->tt_paste ($octets)" 4
.el .IP "\f(CW$term\fR\->tt_paste ($octets)" 4
.IX Item "$term->tt_paste ($octets)"
Write tha octets given up in \f(CW$octets\fR ta tha tty as a paste, convertin \s-1NL\s0 to
\&\s-1CR\s0 n' bracketin tha data wit control sequences if bracketed paste mode
is set.
.ie n .IP "$old_events = $term\->pty_ev_events ([$new_events])" 4
.el .IP "\f(CW$old_events\fR = \f(CW$term\fR\->pty_ev_events ([$new_events])" 4
.IX Item "$old_events = $term->pty_ev_events ([$new_events])"
Replaces tha event mask of tha pty watcher by tha given event mask. Can
be used ta suppress input n' output handlin ta tha pty/tty. Right back up in yo muthafuckin ass. See the
description of \f(CW\*(C`urxvt::timer\->events\*(C'\fR. Make shizzle ta always restore
the previous value.
.ie n .IP "$fd = $term\->pty_fd" 4
.el .IP "\f(CW$fd\fR = \f(CW$term\fR\->pty_fd" 4
.IX Item "$fd = $term->pty_fd"
Returns tha masta file descriptor fo' tha pty up in use, or \f(CW\*(C`\-1\*(C'\fR if no pty
is used.
.ie n .IP "$windowid = $term\->parent" 4
.el .IP "\f(CW$windowid\fR = \f(CW$term\fR\->parent" 4
.IX Item "$windowid = $term->parent"
Return tha window id of tha toplevel window.
.ie n .IP "$windowid = $term\->vt" 4
.el .IP "\f(CW$windowid\fR = \f(CW$term\fR\->vt" 4
.IX Item "$windowid = $term->vt"
Return tha window id of tha terminal window.
.ie n .IP "$term\->vt_emask_add ($x_event_mask)" 4
.el .IP "\f(CW$term\fR\->vt_emask_add ($x_event_mask)" 4
.IX Item "$term->vt_emask_add ($x_event_mask)"
Addz tha specified events ta tha vt event mask. Useful e.g. when you want
to receive pointa events all tha times:
.Sp
.Vb 1
\&   $term\->vt_emask_add (urxvt::PointerMotionMask);
.Ve
.ie n .IP "$term\->set_urgency ($set)" 4
.el .IP "\f(CW$term\fR\->set_urgency ($set)" 4
.IX Item "$term->set_urgency ($set)"
Enable/disable tha urgency hint on tha toplevel window.
.ie n .IP "$term\->focus_in" 4
.el .IP "\f(CW$term\fR\->focus_in" 4
.IX Item "$term->focus_in"
.PD 0
.ie n .IP "$term\->focus_out" 4
.el .IP "\f(CW$term\fR\->focus_out" 4
.IX Item "$term->focus_out"
.ie n .IP "$term\->key_press ($state, $keycode[, $time])" 4
.el .IP "\f(CW$term\fR\->key_press ($state, \f(CW$keycode\fR[, \f(CW$time\fR])" 4
.IX Item "$term->key_press ($state, $keycode[, $time])"
.ie n .IP "$term\->key_release ($state, $keycode[, $time])" 4
.el .IP "\f(CW$term\fR\->key_release ($state, \f(CW$keycode\fR[, \f(CW$time\fR])" 4
.IX Item "$term->key_release ($state, $keycode[, $time])"
.PD
Deliver various fake events ta ta terminal.
.ie n .IP "$window_width = $term\->width" 4
.el .IP "\f(CW$window_width\fR = \f(CW$term\fR\->width" 4
.IX Item "$window_width = $term->width"
.PD 0
.ie n .IP "$window_height = $term\->height" 4
.el .IP "\f(CW$window_height\fR = \f(CW$term\fR\->height" 4
.IX Item "$window_height = $term->height"
.ie n .IP "$font_width = $term\->fwidth" 4
.el .IP "\f(CW$font_width\fR = \f(CW$term\fR\->fwidth" 4
.IX Item "$font_width = $term->fwidth"
.ie n .IP "$font_height = $term\->fheight" 4
.el .IP "\f(CW$font_height\fR = \f(CW$term\fR\->fheight" 4
.IX Item "$font_height = $term->fheight"
.ie n .IP "$font_ascent = $term\->fbase" 4
.el .IP "\f(CW$font_ascent\fR = \f(CW$term\fR\->fbase" 4
.IX Item "$font_ascent = $term->fbase"
.ie n .IP "$terminal_rows = $term\->nrow" 4
.el .IP "\f(CW$terminal_rows\fR = \f(CW$term\fR\->nrow" 4
.IX Item "$terminal_rows = $term->nrow"
.ie n .IP "$terminal_columns = $term\->ncol" 4
.el .IP "\f(CW$terminal_columns\fR = \f(CW$term\fR\->ncol" 4
.IX Item "$terminal_columns = $term->ncol"
.ie n .IP "$has_focus = $term\->focus" 4
.el .IP "\f(CW$has_focus\fR = \f(CW$term\fR\->focus" 4
.IX Item "$has_focus = $term->focus"
.ie n .IP "$is_mapped = $term\->mapped" 4
.el .IP "\f(CW$is_mapped\fR = \f(CW$term\fR\->mapped" 4
.IX Item "$is_mapped = $term->mapped"
.ie n .IP "$max_scrollback = $term\->saveLines" 4
.el .IP "\f(CW$max_scrollback\fR = \f(CW$term\fR\->saveLines" 4
.IX Item "$max_scrollback = $term->saveLines"
.ie n .IP "$nrow_plus_saveLines = $term\->total_rows" 4
.el .IP "\f(CW$nrow_plus_saveLines\fR = \f(CW$term\fR\->total_rows" 4
.IX Item "$nrow_plus_saveLines = $term->total_rows"
.ie n .IP "$topmost_scrollback_row = $term\->top_row" 4
.el .IP "\f(CW$topmost_scrollback_row\fR = \f(CW$term\fR\->top_row" 4
.IX Item "$topmost_scrollback_row = $term->top_row"
.PD
Return various integers describin terminal characteristics.
.ie n .IP "$x_display = $term\->display_id" 4
.el .IP "\f(CW$x_display\fR = \f(CW$term\fR\->display_id" 4
.IX Item "$x_display = $term->display_id"
Return tha \s-1DISPLAY\s0 used by rxvt-unicode.
.ie n .IP "$lc_ctype = $term\->locale" 4
.el .IP "\f(CW$lc_ctype\fR = \f(CW$term\fR\->locale" 4
.IX Item "$lc_ctype = $term->locale"
Returns tha \s-1LC_CTYPE\s0 category strang used by dis rxvt-unicode.
.ie n .IP "$env = $term\->env" 4
.el .IP "\f(CW$env\fR = \f(CW$term\fR\->env" 4
.IX Item "$env = $term->env"
Returns a cold-ass lil copy of tha environment up in effect fo' tha terminal as a hashref
similar ta \f(CW\*(C`\e%ENV\*(C'\fR.
.ie n .IP "@envv = $term\->envv" 4
.el .IP "\f(CW@envv\fR = \f(CW$term\fR\->envv" 4
.IX Item "@envv = $term->envv"
Returns tha environment as array of stringz of tha form \f(CW\*(C`VAR=VALUE\*(C'\fR.
.ie n .IP "@argv = $term\->argv" 4
.el .IP "\f(CW@argv\fR = \f(CW$term\fR\->argv" 4
.IX Item "@argv = $term->argv"
Return tha argument vector as dis terminal, similar ta \f(CW@ARGV\fR yo, but
includes tha program name as first element.
.ie n .IP "$modifiermask = $term\->ModLevel3Mask" 4
.el .IP "\f(CW$modifiermask\fR = \f(CW$term\fR\->ModLevel3Mask" 4
.IX Item "$modifiermask = $term->ModLevel3Mask"
.PD 0
.ie n .IP "$modifiermask = $term\->ModMetaMask" 4
.el .IP "\f(CW$modifiermask\fR = \f(CW$term\fR\->ModMetaMask" 4
.IX Item "$modifiermask = $term->ModMetaMask"
.ie n .IP "$modifiermask = $term\->ModNumLockMask" 4
.el .IP "\f(CW$modifiermask\fR = \f(CW$term\fR\->ModNumLockMask" 4
.IX Item "$modifiermask = $term->ModNumLockMask"
.PD
Return tha modifier masks correspondin ta tha \*(L"\s-1ISO\s0 Level 3 Shift\*(R" (often
AltGr), tha meta key (often Alt) n' tha num lock key, if applicable.
.ie n .IP "$screen = $term\->current_screen" 4
.el .IP "\f(CW$screen\fR = \f(CW$term\fR\->current_screen" 4
.IX Item "$screen = $term->current_screen"
Returns tha currently displayed screen (0 primary, 1 secondary).
.ie n .IP "$cursor_is_hidden = $term\->hidden_cursor" 4
.el .IP "\f(CW$cursor_is_hidden\fR = \f(CW$term\fR\->hidden_cursor" 4
.IX Item "$cursor_is_hidden = $term->hidden_cursor"
Returns whether tha cursor is currently hidden or not.
.ie n .IP "$view_start = $term\->view_start ([$newvalue])" 4
.el .IP "\f(CW$view_start\fR = \f(CW$term\fR\->view_start ([$newvalue])" 4
.IX Item "$view_start = $term->view_start ([$newvalue])"
Returns tha row number of tha topmost displayed line. Maximum value is
\&\f(CW0\fR, which displays tha aiiight terminal contents, n' you can put dat on yo' toast. Lower joints scroll
this nuff lines tha fuck into tha scrollback buffer.
.ie n .IP "$term\->want_refresh" 4
.el .IP "\f(CW$term\fR\->want_refresh" 4
.IX Item "$term->want_refresh"
Requests a screen refresh fo' realz. At tha next opportunity, rxvt-unicode will
compare tha on-screen display wit its stored representation. I aint talkin' bout chicken n' gravy biatch. If they
differ, it redraws tha differences.
.Sp
Used afta changin terminal contents ta display em.
.ie n .IP "$text = $term\->ROW_t ($row_number[, $new_text[, $start_col]])" 4
.el .IP "\f(CW$text\fR = \f(CW$term\fR\->ROW_t ($row_number[, \f(CW$new_text\fR[, \f(CW$start_col\fR]])" 4
.IX Item "$text = $term->ROW_t ($row_number[, $new_text[, $start_col]])"
Returns tha text of tha entire row wit number \f(CW$row_number\fR. Row \f(CW\*(C`$term\->top_row\*(C'\fR
is tha topmost terminal line, row \f(CW\*(C`$term\->nrow\-1\*(C'\fR is tha bottommost
terminal line. Nothang is ghon be returned if a nonexistent line
is requested.
.Sp
If \f(CW$new_text\fR is specified, it will replace charactas up in tha current
line, startin at column \f(CW$start_col\fR (default \f(CW0\fR), which is useful
to replace only partz of a line. Da font index up in tha rendizzle will
automatically be updated.
.Sp
\&\f(CW$text\fR is up in a special encoding: tabs n' wide charactas dat use more
than one cell when displayed is padded wit \f(CW$urxvt::NOCHAR\fR (chr 65535)
characters. Charactas wit combinin charactas n' other charactas that
do not fit tha fuck into tha aiiight text encodin is ghon be replaced wit characters
in tha private use area.
.Sp
Yo ass gotta obey dis encodin when changin text. Da advantage is
that \f(CW\*(C`substr\*(C'\fR n' similar functions work on screen cells n' not on
characters.
.Sp
Da methodz \f(CW\*(C`$term\->special_encode\*(C'\fR n' \f(CW\*(C`$term\->special_decode\*(C'\fR
can be used ta convert aiiight strings tha fuck into dis encodin n' vice versa.
.ie n .IP "$rend = $term\->ROW_r ($row_number[, $new_rend[, $start_col]])" 4
.el .IP "\f(CW$rend\fR = \f(CW$term\fR\->ROW_r ($row_number[, \f(CW$new_rend\fR[, \f(CW$start_col\fR]])" 4
.IX Item "$rend = $term->ROW_r ($row_number[, $new_rend[, $start_col]])"
Like \f(CW\*(C`$term\->ROW_t\*(C'\fR yo, but returns a arrayref wit rendition
bitsets, n' you can put dat on yo' toast. Rendizzle bitsets contain shiznit bout colour, font, font
stylez n' similar shiznit. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See also \f(CW\*(C`$term\->ROW_t\*(C'\fR.
.Sp
When settin rendition, tha font mask is ghon be ignored.
.Sp
See tha section on \s-1RENDITION,\s0 above.
.ie n .IP "$length = $term\->ROW_l ($row_number[, $new_length])" 4
.el .IP "\f(CW$length\fR = \f(CW$term\fR\->ROW_l ($row_number[, \f(CW$new_length\fR])" 4
.IX Item "$length = $term->ROW_l ($row_number[, $new_length])"
Returns tha number of screen cells dat is up in use (\*(L"the line
length\*(R"). Unlike tha urxvt core, dis returns \f(CW\*(C`$term\->ncol\*(C'\fR if the
line is joined wit tha followin one.
.ie n .IP "$bool = $term\->is_longer ($row_number)" 4
.el .IP "\f(CW$bool\fR = \f(CW$term\fR\->is_longer ($row_number)" 4
.IX Item "$bool = $term->is_longer ($row_number)"
Returns legit if tha row is part of a multiple-row logical \*(L"line\*(R" (i.e.
joined wit tha followin row), which means all charactas is up in use
and it is continued on tha next row (and possibly a cold-ass lil continuation of the
previous row(s)).
.ie n .IP "$line = $term\->line ($row_number)" 4
.el .IP "\f(CW$line\fR = \f(CW$term\fR\->line ($row_number)" 4
.IX Item "$line = $term->line ($row_number)"
Smoke n' return a freshly smoked up \f(CW\*(C`urxvt::line\*(C'\fR object dat stores shiznit
about tha logical line dat row \f(CW$row_number\fR is part of. Well shiiiit, it supports the
followin methods:
.RS 4
.ie n .IP "$text = $line\->t ([$new_text])" 4
.el .IP "\f(CW$text\fR = \f(CW$line\fR\->t ([$new_text])" 4
.IX Item "$text = $line->t ([$new_text])"
Returns or replaces tha full text of tha line, similar ta \f(CW\*(C`ROW_t\*(C'\fR
.ie n .IP "$rend = $line\->r ([$new_rend])" 4
.el .IP "\f(CW$rend\fR = \f(CW$line\fR\->r ([$new_rend])" 4
.IX Item "$rend = $line->r ([$new_rend])"
Returns or replaces tha full rendizzle array of tha line, similar ta \f(CW\*(C`ROW_r\*(C'\fR
.ie n .IP "$length = $line\->l" 4
.el .IP "\f(CW$length\fR = \f(CW$line\fR\->l" 4
.IX Item "$length = $line->l"
Returns tha length of tha line up in cells, similar ta \f(CW\*(C`ROW_l\*(C'\fR.
.ie n .IP "$rownum = $line\->beg" 4
.el .IP "\f(CW$rownum\fR = \f(CW$line\fR\->beg" 4
.IX Item "$rownum = $line->beg"
.PD 0
.ie n .IP "$rownum = $line\->end" 4
.el .IP "\f(CW$rownum\fR = \f(CW$line\fR\->end" 4
.IX Item "$rownum = $line->end"
.PD
Return tha row number of tha first/last row of tha line, respectively.
.ie n .IP "$offset = $line\->offset_of ($row, $col)" 4
.el .IP "\f(CW$offset\fR = \f(CW$line\fR\->offset_of ($row, \f(CW$col\fR)" 4
.IX Item "$offset = $line->offset_of ($row, $col)"
Returns tha characta offset of tha given row|col pair within tha logical
line. Works fo' rows outside tha line, too, n' returns corresponding
offsets outside tha string.
.ie n .IP "($row, $col) = $line\->coord_of ($offset)" 4
.el .IP "($row, \f(CW$col\fR) = \f(CW$line\fR\->coord_of ($offset)" 4
.IX Item "($row, $col) = $line->coord_of ($offset)"
Translates a strang offset tha fuck into terminal coordinates again.
.RE
.RS 4
.RE
.ie n .IP "$text = $term\->special_encode $string" 4
.el .IP "\f(CW$text\fR = \f(CW$term\fR\->special_encode \f(CW$string\fR" 4
.IX Item "$text = $term->special_encode $string"
Converts a perl strang tha fuck into tha special encodin used by rxvt-unicode,
where one characta correspondz ta one screen cell. Right back up in yo muthafuckin ass. See
\&\f(CW\*(C`$term\->ROW_t\*(C'\fR fo' details.
.ie n .IP "$strin = $term\->special_decode $text" 4
.el .IP "\f(CW$string\fR = \f(CW$term\fR\->special_decode \f(CW$text\fR" 4
.IX Item "$strin = $term->special_decode $text"
Converts rxvt-unicodes text representation tha fuck into a perl string. Right back up in yo muthafuckin ass. See
\&\f(CW\*(C`$term\->ROW_t\*(C'\fR fo' details.
.ie n .IP "$success = $term\->grab_button ($button, $modifiermask[, $window = $term\->vt])" 4
.el .IP "\f(CW$success\fR = \f(CW$term\fR\->grab_button ($button, \f(CW$modifiermask\fR[, \f(CW$window\fR = \f(CW$term\fR\->vt])" 4
.IX Item "$success = $term->grab_button ($button, $modifiermask[, $window = $term->vt])"
.PD 0
.ie n .IP "$term\->ungrab_button ($button, $modifiermask[, $window = $term\->vt])" 4
.el .IP "\f(CW$term\fR\->ungrab_button ($button, \f(CW$modifiermask\fR[, \f(CW$window\fR = \f(CW$term\fR\->vt])" 4
.IX Item "$term->ungrab_button ($button, $modifiermask[, $window = $term->vt])"
.PD
Register/unregista a synchronous button grab. Right back up in yo muthafuckin ass. See tha XGrabButton
manpage.
.ie n .IP "$success = $term\->grab ($eventtime[, $sync])" 4
.el .IP "\f(CW$success\fR = \f(CW$term\fR\->grab ($eventtime[, \f(CW$sync\fR])" 4
.IX Item "$success = $term->grab ($eventtime[, $sync])"
Calls XGrabPointa n' XGrabKeyboard up in asynchronous (default) or
synchronous (\f(CW$sync\fR is true) fo' realz. Also rethugz tha grab timestamp.
.ie n .IP "$term\->allow_events_async" 4
.el .IP "\f(CW$term\fR\->allow_events_async" 4
.IX Item "$term->allow_events_async"
Calls XAllowEvents wit AsyncBoth fo' da most thugged-out recent grab.
.ie n .IP "$term\->allow_events_sync" 4
.el .IP "\f(CW$term\fR\->allow_events_sync" 4
.IX Item "$term->allow_events_sync"
Calls XAllowEvents wit SyncBoth fo' da most thugged-out recent grab.
.ie n .IP "$term\->allow_events_replay" 4
.el .IP "\f(CW$term\fR\->allow_events_replay" 4
.IX Item "$term->allow_events_replay"
Calls XAllowEvents wit both ReplayPointa n' ReplayKeyboard fo' da most thugged-out
recent grab.
.ie n .IP "$term\->ungrab" 4
.el .IP "\f(CW$term\fR\->ungrab" 4
.IX Item "$term->ungrab"
Calls XUngrabPointa n' XUngrabKeyboard fo' da most thugged-out recent grab. Is called automatically on
evaluation errors, as it is betta ta lose tha grab up in tha error case as
the session.
.ie n .IP "$atom = $term\->XInternAtom ($atom_name[, $only_if_exists])" 4
.el .IP "\f(CW$atom\fR = \f(CW$term\fR\->XInternAtom ($atom_name[, \f(CW$only_if_exists\fR])" 4
.IX Item "$atom = $term->XInternAtom ($atom_name[, $only_if_exists])"
.PD 0
.ie n .IP "$atom_name = $term\->XGetAtomName ($atom)" 4
.el .IP "\f(CW$atom_name\fR = \f(CW$term\fR\->XGetAtomName ($atom)" 4
.IX Item "$atom_name = $term->XGetAtomName ($atom)"
.ie n .IP "@atoms = $term\->XListPropertizzles ($window)" 4
.el .IP "\f(CW@atoms\fR = \f(CW$term\fR\->XListPropertizzles ($window)" 4
.IX Item "@atoms = $term->XListPropertizzles ($window)"
.ie n .IP "($type,$format,$octets) = $term\->XGetWindowProperty ($window, $property)" 4
.el .IP "($type,$format,$octets) = \f(CW$term\fR\->XGetWindowProperty ($window, \f(CW$property\fR)" 4
.IX Item "($type,$format,$octets) = $term->XGetWindowProperty ($window, $property)"
.ie n .IP "$term\->XChangeProperty ($window, $property, $type, $format, $octets)" 4
.el .IP "\f(CW$term\fR\->XChangeProperty ($window, \f(CW$property\fR, \f(CW$type\fR, \f(CW$format\fR, \f(CW$octets\fR)" 4
.IX Item "$term->XChangeProperty ($window, $property, $type, $format, $octets)"
.ie n .IP "$term\->XDeleteProperty ($window, $property)" 4
.el .IP "\f(CW$term\fR\->XDeleteProperty ($window, \f(CW$property\fR)" 4
.IX Item "$term->XDeleteProperty ($window, $property)"
.ie n .IP "$window = $term\->DefaultRootWindow" 4
.el .IP "\f(CW$window\fR = \f(CW$term\fR\->DefaultRootWindow" 4
.IX Item "$window = $term->DefaultRootWindow"
.ie n .IP "$term\->XReparentWindow ($window, $parent, [$x, $y])" 4
.el .IP "\f(CW$term\fR\->XReparentWindow ($window, \f(CW$parent\fR, [$x, \f(CW$y\fR])" 4
.IX Item "$term->XReparentWindow ($window, $parent, [$x, $y])"
.ie n .IP "$term\->XMapWindow ($window)" 4
.el .IP "\f(CW$term\fR\->XMapWindow ($window)" 4
.IX Item "$term->XMapWindow ($window)"
.ie n .IP "$term\->XUnmapWindow ($window)" 4
.el .IP "\f(CW$term\fR\->XUnmapWindow ($window)" 4
.IX Item "$term->XUnmapWindow ($window)"
.ie n .IP "$term\->XMoveResizeWindow ($window, $x, $y, $width, $height)" 4
.el .IP "\f(CW$term\fR\->XMoveResizeWindow ($window, \f(CW$x\fR, \f(CW$y\fR, \f(CW$width\fR, \f(CW$height\fR)" 4
.IX Item "$term->XMoveResizeWindow ($window, $x, $y, $width, $height)"
.ie n .IP "($x, $y, $child_window) = $term\->XTranslateCoordinates ($src, $dst, $x, $y)" 4
.el .IP "($x, \f(CW$y\fR, \f(CW$child_window\fR) = \f(CW$term\fR\->XTranslateCoordinates ($src, \f(CW$dst\fR, \f(CW$x\fR, \f(CW$y\fR)" 4
.IX Item "($x, $y, $child_window) = $term->XTranslateCoordinates ($src, $dst, $x, $y)"
.ie n .IP "$term\->XChangeInput ($window, $add_events[, $del_events])" 4
.el .IP "\f(CW$term\fR\->XChangeInput ($window, \f(CW$add_events\fR[, \f(CW$del_events\fR])" 4
.IX Item "$term->XChangeInput ($window, $add_events[, $del_events])"
.ie n .IP "$keysym = $term\->XStringToKeysym ($string)" 4
.el .IP "\f(CW$keysym\fR = \f(CW$term\fR\->XStringToKeysym ($string)" 4
.IX Item "$keysym = $term->XStringToKeysym ($string)"
.ie n .IP "$strin = $term\->XKeysymToStrin ($keysym)" 4
.el .IP "\f(CW$string\fR = \f(CW$term\fR\->XKeysymToStrin ($keysym)" 4
.IX Item "$strin = $term->XKeysymToStrin ($keysym)"
.PD
Various X or X\-related functions. Da \f(CW$term\fR object only serves as
the source of tha display, otherwise dem functions map more-or-less
directly onto tha X functionz of tha same name.
.ie n .SS "Da ""urxvt::popup"" Class"
.el .SS "Da \f(CWurxvt::popup\fP Class"
.IX Subsection "Da urxvt::popup Class"
.ie n .IP "$popup\->add_title ($title)" 4
.el .IP "\f(CW$popup\fR\->add_title ($title)" 4
.IX Item "$popup->add_title ($title)"
Addz a non-clickable title ta tha popup.
.ie n .IP "$popup\->add_separator ([$sepchr])" 4
.el .IP "\f(CW$popup\fR\->add_separator ([$sepchr])" 4
.IX Item "$popup->add_separator ([$sepchr])"
Creates a separator, optionally rockin tha characta given as \f(CW$sepchr\fR.
.ie n .IP "$popup\->add_button ($text, $cb)" 4
.el .IP "\f(CW$popup\fR\->add_button ($text, \f(CW$cb\fR)" 4
.IX Item "$popup->add_button ($text, $cb)"
Addz a cold-ass lil clickable button ta tha popup. \f(CW$cb\fR is called whenever it is
selected.
.ie n .IP "$popup\->add_toggle ($text, $initial_value, $cb)" 4
.el .IP "\f(CW$popup\fR\->add_toggle ($text, \f(CW$initial_value\fR, \f(CW$cb\fR)" 4
.IX Item "$popup->add_toggle ($text, $initial_value, $cb)"
Addz a toggle/checkbox item ta tha popup. Da callback gets called
whenever it gets toggled, wit a funky-ass boolean indicatin its freshly smoked up value as its
first argument.
.ie n .IP "$popup\->show" 4
.el .IP "\f(CW$popup\fR\->show" 4
.IX Item "$popup->show"
Displays tha popup (which is initially hidden).
.ie n .SS "Da ""urxvt::timer"" Class"
.el .SS "Da \f(CWurxvt::timer\fP Class"
.IX Subsection "Da urxvt::timer Class"
This class implements timer watchers/events, n' you can put dat on yo' toast. Time is represented as a
fractionizzle number of secondz since tha epoch. Example:
.PP
.Vb 8
\&   $term\->{overlay} = $term\->overlay (\-1, 0, 8, 1, urxvt::OVERLAY_RSTYLE, 0);
\&   $term\->{timer} = urxvt::timer
\&                    \->new
\&                    \->interval (1)
\&                    \->cb (sub {
\&                       $term\->{overlay}\->set (0, 0,
\&                          sprintf "%2d:%02d:%02d", (localtime urxvt::NOW)[2,1,0]);
\&                    });
.Ve
.ie n .IP "$timer = freshly smoked up urxvt::timer" 4
.el .IP "\f(CW$timer\fR = freshly smoked up urxvt::timer" 4
.IX Item "$timer = freshly smoked up urxvt::timer"
Smoke a freshly smoked up timer object up in started state. Well shiiiit, it is scheduled ta fire
immediately.
.ie n .IP "$timer = $timer\->cb (sub { mah ($timer) = @_; ... })" 4
.el .IP "\f(CW$timer\fR = \f(CW$timer\fR\->cb (sub { mah ($timer) = \f(CW@_\fR; ... })" 4
.IX Item "$timer = $timer->cb (sub { mah ($timer) = @_; ... })"
Set tha callback ta be called when tha timer triggers.
.ie n .IP "$timer = $timer\->set ($tstamp[, $interval])" 4
.el .IP "\f(CW$timer\fR = \f(CW$timer\fR\->set ($tstamp[, \f(CW$interval\fR])" 4
.IX Item "$timer = $timer->set ($tstamp[, $interval])"
Set tha time tha event is generated ta \f(CW$tstamp\fR (and optionally specifies a
new \f(CW$interval\fR).
.ie n .IP "$timer = $timer\->interval ($interval)" 4
.el .IP "\f(CW$timer\fR = \f(CW$timer\fR\->interval ($interval)" 4
.IX Item "$timer = $timer->interval ($interval)"
By default (and when \f(CW$interval\fR is \f(CW0\fR), tha timer will automatically
stop afta it has fired once. If \f(CW$interval\fR is non-zero, then tha timer
is automatically rescheduled all up in tha given intervals.
.ie n .IP "$timer = $timer\->start" 4
.el .IP "\f(CW$timer\fR = \f(CW$timer\fR\->start" 4
.IX Item "$timer = $timer->start"
Start tha timer.
.ie n .IP "$timer = $timer\->start ($tstamp[, $interval])" 4
.el .IP "\f(CW$timer\fR = \f(CW$timer\fR\->start ($tstamp[, \f(CW$interval\fR])" 4
.IX Item "$timer = $timer->start ($tstamp[, $interval])"
Set tha event trigger time ta \f(CW$tstamp\fR n' start tha timer n' shit. Optionally
also replaces tha interval.
.ie n .IP "$timer = $timer\->afta ($delay[, $interval])" 4
.el .IP "\f(CW$timer\fR = \f(CW$timer\fR\->afta ($delay[, \f(CW$interval\fR])" 4
.IX Item "$timer = $timer->afta ($delay[, $interval])"
Like \f(CW\*(C`start\*(C'\fR yo, but sets tha expiry timer ta c<urxvt::NOW + \f(CW$delay\fR>.
.ie n .IP "$timer = $timer\->stop" 4
.el .IP "\f(CW$timer\fR = \f(CW$timer\fR\->stop" 4
.IX Item "$timer = $timer->stop"
Quit tha timer.
.ie n .SS "Da ""urxvt::iow"" Class"
.el .SS "Da \f(CWurxvt::iow\fP Class"
.IX Subsection "Da urxvt::iow Class"
This class implements io watchers/events, n' you can put dat on yo' toast. Example:
.PP
.Vb 12
\&  $term\->{socket} = ...
\&  $term\->{iow} = urxvt::iow
\&                 \->new
\&                 \->fd (fileno $term\->{socket})
\&                 \->events (urxvt::EV_READ)
\&                 \->start
\&                 \->cb (sub {
\&                   mah ($iow, $revents) = @_;
\&                   # $revents must be 1 here, no need ta check
\&                   sysread $term\->{socket}, mah $buf, 8192
\&                      or end\-of\-file;
\&                 });
.Ve
.ie n .IP "$iow = freshly smoked up urxvt::iow" 4
.el .IP "\f(CW$iow\fR = freshly smoked up urxvt::iow" 4
.IX Item "$iow = freshly smoked up urxvt::iow"
Smoke a freshly smoked up io watcher object up in stopped state.
.ie n .IP "$iow = $iow\->cb (sub { mah ($iow, $reventmask) = @_; ... })" 4
.el .IP "\f(CW$iow\fR = \f(CW$iow\fR\->cb (sub { mah ($iow, \f(CW$reventmask\fR) = \f(CW@_\fR; ... })" 4
.IX Item "$iow = $iow->cb (sub { mah ($iow, $reventmask) = @_; ... })"
Set tha callback ta be called when io events is triggered. Y'all KNOW dat shit, muthafucka! \f(CW$reventmask\fR
is a funky-ass bitset as busted lyrics bout up in tha \f(CW\*(C`events\*(C'\fR method.
.ie n .IP "$iow = $iow\->fd ($fd)" 4
.el .IP "\f(CW$iow\fR = \f(CW$iow\fR\->fd ($fd)" 4
.IX Item "$iow = $iow->fd ($fd)"
Set tha file descriptor (not handle) ta watch.
.ie n .IP "$iow = $iow\->events ($eventmask)" 4
.el .IP "\f(CW$iow\fR = \f(CW$iow\fR\->events ($eventmask)" 4
.IX Item "$iow = $iow->events ($eventmask)"
Set tha event mask ta watch. Da only allowed joints are
\&\f(CW\*(C`urxvt::EV_READ\*(C'\fR n' \f(CW\*(C`urxvt::EV_WRITE\*(C'\fR, which might be ORed
together, or \f(CW\*(C`urxvt::EV_NONE\*(C'\fR.
.ie n .IP "$iow = $iow\->start" 4
.el .IP "\f(CW$iow\fR = \f(CW$iow\fR\->start" 4
.IX Item "$iow = $iow->start"
Start watchin fo' axed events on tha given handle.
.ie n .IP "$iow = $iow\->stop" 4
.el .IP "\f(CW$iow\fR = \f(CW$iow\fR\->stop" 4
.IX Item "$iow = $iow->stop"
Quit watchin fo' events on tha given file handle.
.ie n .SS "Da ""urxvt::iw"" Class"
.el .SS "Da \f(CWurxvt::iw\fP Class"
.IX Subsection "Da urxvt::iw Class"
This class implements idle watchers, dat git called automatically when
the process is idle. They should return as fast as possible, afta bustin
some useful work.
.ie n .IP "$iw = freshly smoked up urxvt::iw" 4
.el .IP "\f(CW$iw\fR = freshly smoked up urxvt::iw" 4
.IX Item "$iw = freshly smoked up urxvt::iw"
Smoke a freshly smoked up idle watcher object up in stopped state.
.ie n .IP "$iw = $iw\->cb (sub { mah ($iw) = @_; ... })" 4
.el .IP "\f(CW$iw\fR = \f(CW$iw\fR\->cb (sub { mah ($iw) = \f(CW@_\fR; ... })" 4
.IX Item "$iw = $iw->cb (sub { mah ($iw) = @_; ... })"
Set tha callback ta be called when tha watcher triggers.
.ie n .IP "$timer = $timer\->start" 4
.el .IP "\f(CW$timer\fR = \f(CW$timer\fR\->start" 4
.IX Item "$timer = $timer->start"
Start tha watcher.
.ie n .IP "$timer = $timer\->stop" 4
.el .IP "\f(CW$timer\fR = \f(CW$timer\fR\->stop" 4
.IX Item "$timer = $timer->stop"
Quit tha watcher.
.ie n .SS "Da ""urxvt::pw"" Class"
.el .SS "Da \f(CWurxvt::pw\fP Class"
.IX Subsection "Da urxvt::pw Class"
This class implements process watchers. They create a event whenever a
process exits, afta which they stop automatically.
.PP
.Vb 9
\&   mah $pid = fork;
\&   ...
\&   $term\->{pw} = urxvt::pw
\&                    \->new
\&                    \->start ($pid)
\&                    \->cb (sub {
\&                       mah ($pw, $exit_status) = @_;
\&                       ...
\&                    });
.Ve
.ie n .IP "$pw = freshly smoked up urxvt::pw" 4
.el .IP "\f(CW$pw\fR = freshly smoked up urxvt::pw" 4
.IX Item "$pw = freshly smoked up urxvt::pw"
Smoke a freshly smoked up process watcher up in stopped state.
.ie n .IP "$pw = $pw\->cb (sub { mah ($pw, $exit_status) = @_; ... })" 4
.el .IP "\f(CW$pw\fR = \f(CW$pw\fR\->cb (sub { mah ($pw, \f(CW$exit_status\fR) = \f(CW@_\fR; ... })" 4
.IX Item "$pw = $pw->cb (sub { mah ($pw, $exit_status) = @_; ... })"
Set tha callback ta be called when tha timer triggers.
.ie n .IP "$pw = $timer\->start ($pid)" 4
.el .IP "\f(CW$pw\fR = \f(CW$timer\fR\->start ($pid)" 4
.IX Item "$pw = $timer->start ($pid)"
Tells tha watcher ta start watchin fo' process \f(CW$pid\fR.
.ie n .IP "$pw = $pw\->stop" 4
.el .IP "\f(CW$pw\fR = \f(CW$pw\fR\->stop" 4
.IX Item "$pw = $pw->stop"
Quit tha watcher.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.SS "\s-1URXVT_PERL_VERBOSITY\s0"
.IX Subsection "URXVT_PERL_VERBOSITY"
This variable controls tha verbositizzle level of tha perl extension. I aint talkin' bout chicken n' gravy biatch yo. Higher
numbers indicate mo' verbose output.
.IP "== 0 \- fatal lyrics" 4
.IX Item "== 0 - fatal lyrics"
.PD 0
.IP ">= 3 \- script loadin n' pimpment" 4
.IX Item ">= 3 - script loadin n' pimpment"
.IP ">=10 \- all called hooks" 4
.IX Item ">=10 - all called hooks"
.IP ">=11 \- hook return joints" 4
.IX Item ">=11 - hook return joints"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://software.schmorp.de/pkg/rxvt\-unicode
.Ve
