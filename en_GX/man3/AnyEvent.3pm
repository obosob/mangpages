.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent 3"
.TH AnyEvent 3 "2013-08-21" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent \- tha DBI of event loop programming
.PP
EV, Event, Glib, Tk, Perl, Event::Lib, Irssi, rxvt\-unicode, IO::Async, Qt,
FLTK n' POE is various supported event loops/environments.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent;
\&
\&   # if you prefer function calls, peep tha AE manpage for
\&   # a alternatizzle API.
\&
\&   # file handle or descriptor readable
\&   mah $w = AnyEvent\->io (fh => $fh, poll => "r", cb => sub { ...  });
\&
\&   # one\-shot or repeatin timers
\&   mah $w = AnyEvent\->timer (afta => $seconds, cb => sub { ...  });
\&   mah $w = AnyEvent\->timer (afta => $seconds, interval => $seconds, cb => ...);
\&
\&   print AnyEvent\->now;  # prints current event loop time
\&   print AnyEvent\->time; # be thinkin Time::HiRes::time or simply CORE::time.
\&
\&   # POSIX signal
\&   mah $w = AnyEvent\->signal (signal => "TERM", cb => sub { ... });
\&
\&   # lil pimp process exit
\&   mah $w = AnyEvent\->child (pid => $pid, cb => sub {
\&      mah ($pid, $status) = @_;
\&      ...
\&   });
\&
\&   # called when event loop idle (if applicable)
\&   mah $w = AnyEvent\->idle (cb => sub { ... });
\&
\&   mah $w = AnyEvent\->condvar; # stores whether a cold-ass lil condizzle was flagged
\&   $w\->send; # raise up current n' all future recv\*(Aqs
\&   $w\->recv; # entas "main loop" till $condvar gets \->send
\&   # bust a cold-ass lil condvar up in callback mode:
\&   $w\->cb (sub { $_[0]\->recv });
.Ve
.SH "INTRODUCTION/TUTORIAL"
.IX Header "INTRODUCTION/TUTORIAL"
This manpage is mainly a reference manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If yo ass is interested
in a tutorial or some gentle introduction, gotz a peep the
AnyEvent::Intro manpage.
.SH "SUPPORT"
.IX Header "SUPPORT"
An \s-1FAQ\s0 document be available as AnyEvent::FAQ.
.PP
There also be a mailinglist fo' discussin all thangs AnyEvent, n' a \s-1IRC\s0
channel, like a muthafucka.
.PP
See tha AnyEvent project page all up in tha \fBSchmorpforge Ta-Sa Software
Repository\fR, at <http://anyevent.schmorp.de>, fo' mo' info.
.SH "WHY YOU SHOULD USE THIS MODULE (OR NOT)"
.IX Header "WHY YOU SHOULD USE THIS MODULE (OR NOT)"
Glib, \s-1POE,\s0 IO::Async, Event... \s-1CPAN\s0 offers event models by tha dozen
nowadays. Right back up in yo muthafuckin ass. So what tha fuck is different bout AnyEvent?
.PP
Executizzle Summary: AnyEvent is \fIcompatible\fR, AnyEvent is \fIfree of
policy\fR n' AnyEvent is \fIsmall n' efficient\fR.
.PP
First n' foremost, \fIAnyEvent aint a event model\fR itself, it only
interfaces ta whatever event model tha main program happens ta use, up in a
pragmatic way. For event models n' certain classez of immortals alike,
the statement \*(L"there can only be one\*(R" be a funky-ass bitta reality: In general,
only one event loop can be actizzle all up in tha same time up in a process fo' realz. AnyEvent
cannot chizzle dis yo, but it can hide tha differences between dem event
loops.
.PP
Da goal of AnyEvent is ta offer module authors tha mobilitizzle ta do event
programmin (waitin fo' I/O or timer events) without subscribin ta a
religion, a way of living, n' most blinginly: without forcin your
module playas tha fuck into tha same thang by forcin dem ta use tha same event
model you use.
.PP
For modulez like \s-1POE\s0 or IO::Async (which be a total misnomer as it is
actually bustin all I/O \fIsynchronously\fR...), rockin dem up in yo' module is
like joinin a cold-ass lil cult: Afta you join, yo ass is dependent on dem n' you
cannot use anythang else, as they is simply incompatible ta every last muthafuckin thang
that aint em. Whatz worse, all tha potential playaz of your
module is \fIalso\fR forced ta use tha same event loop you use.
.PP
AnyEvent is different: AnyEvent + \s-1POE\s0 works fine fo' realz. AnyEvent + Glib works
fine fo' realz. AnyEvent + Tk works fine etc. etc. but none of these work together
with tha rest: \s-1POE + EV\s0, biatch? No go. Tk + Event, biatch? No go fo' realz. Again: if yo' module
uses one of them, every last muthafuckin user of yo' module has ta use it, like a muthafucka. But if
your module uses AnyEvent, it works transparently wit all event models it
supports (includin shiznit like IO::Async, as long as dem use one of the
supported event loops. Well shiiiit, it is easy as fuck  ta add freshly smoked up event loops ta AnyEvent, too,
so it is future-proof).
.PP
In addizzle ta bein free of havin ta use \fIthe one n' only legit event
model\fR, AnyEvent also is free of bloat n' policy: wit \s-1POE\s0 or similar
modules, you git a enormous amount of code n' strict rulez you have to
follow fo' realz. AnyEvent, on tha other hand, is lean n' ta tha point, by only
offerin tha functionalitizzle dat is necessary, up in as thin as a wrapper as
technologically possible.
.PP
Of course, AnyEvent comes wit a funky-ass big-ass (and straight-up optional!) toolbox
of useful functionality, like fuckin a asynchronous \s-1DNS\s0 resolver, 100%
non-blockin connects (even wit \s-1TLS/SSL,\s0 IPv6 n' on fucked up platforms
like fuckin Windows) n' fuckin shitloadz of real-world knowledge n' workaroundz for
platform bugs n' differences.
.PP
Now, if you \fIdo want\fR fuckin shitloadz of policy (this can arguably be somewhat
useful) n' you wanna force yo' playas ta use tha one n' only event
model, you should \fInot\fR use dis module.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
AnyEvent serves up a uniform intercourse ta various event loops. This
allows module authors ta use event loop functionalitizzle without forcing
module playas ta bust a specific event loop implementation (since more
than one event loop cannot coexist peacefully).
.PP
Da intercourse itself is vaguely similar yo, but not identical ta tha Event
module.
.PP
Durin tha straight-up original gangsta call of any watcher-creation method, tha module tries
to detect tha currently loaded event loop by probin whether one of the
followin modulez be already loaded: \s-1EV\s0, AnyEvent::Loop,
Event, Glib, Tk, Event::Lib, Qt, \s-1POE\s0. Da first one
found is used. Y'all KNOW dat shit, muthafucka! If none is detected, tha module tries ta load tha first
four modulez up in tha order given; but note dat if \s-1EV\s0 is not
available, tha pure-perl AnyEvent::Loop should always work, so
the other two is not normally tried.
.PP
Because AnyEvent first checks fo' modulez dat is already loaded, loading
an event model explicitly before first rockin AnyEvent will likely make
that model tha default. For example:
.PP
.Vb 2
\&   use Tk;
\&   use AnyEvent;
\&
\&   # . fo' realz. AnyEvent will likely default ta Tk
.Ve
.PP
Da \fIlikely\fR means that, if any module loadz another event model and
starts rockin it, all bets is off \- dis case should be straight-up rare though,
as straight-up few modulez hardcode event loops without announcin dis hella
loudly.
.PP
Da pure-perl implementation of AnyEvent is called \f(CW\*(C`AnyEvent::Loop\*(C'\fR. Like
other event modulez you can load it explicitly n' trip off tha high
availabilitizzle of dat event loop :)
.SH "WATCHERS"
.IX Header "WATCHERS"
AnyEvent has tha central concept of a \fIwatcher\fR, which be a object that
stores relevant data fo' each kind of event yo ass is waitin for, such as
the callback ta call, tha file handle ta peep it, etc.
.PP
These watchers is aiiight Perl objects wit aiiight Perl gametime fo' realz. After
bustin a watcher it will immediately \*(L"watch\*(R" fo' events n' invoke the
callback when tha event occurs (of course, only when tha event model
is up in control).
.PP
Note dat \fBcallbacks must not permanently chizzle global variables\fR
potentially up in use by tha event loop (like fuckin \f(CW$_\fR or \f(CW$[\fR) n' dat \fBcallbacks must not \f(CB\*(C`die\*(C'\fB\fR. Da forma is phat programmin practice in
Perl n' tha latta stems from tha fact dat exception handlin differs
widely between event loops.
.PP
To disable a watcher you gotta destroy it (e.g. by settin the
variable you store it up in ta \f(CW\*(C`undef\*(C'\fR or otherwise deletin all references
to it).
.PP
All watchers is pimped by callin a method on tha \f(CW\*(C`AnyEvent\*(C'\fR class.
.PP
Many watchers either is used wit \*(L"recursion\*(R" (repeatin timers for
example), or need ta refer ta they watcher object up in other ways.
.PP
One way ta big up dat is dis pattern:
.PP
.Vb 4
\&   mah $w; $w = AnyEvent\->type (arg => value ..., cb => sub {
\&      # you can use $w here, fo' example ta undef it
\&      undef $w;
\&   });
.Ve
.PP
Note dat \f(CW\*(C`my $w; $w =\*(C'\fR combination. I aint talkin' bout chicken n' gravy biatch. This is necessary cuz up in Perl,
my variablez is only visible afta tha statement up in which they are
declared.
.SS "I/O \s-1WATCHERS\s0"
.IX Subsection "I/O WATCHERS"
.Vb 5
\&   $w = AnyEvent\->io (
\&      fh   => <filehandle_or_fileno>,
\&      poll => <"r" or "w">,
\&      cb   => <callback>,
\&   );
.Ve
.PP
Yo ass can create a I/O watcher by callin tha \f(CW\*(C`AnyEvent\->io\*(C'\fR method
with tha followin mandatory key-value pairs as arguments:
.PP
\&\f(CW\*(C`fh\*(C'\fR is tha Perl \fIfile handle\fR (or a naked file descriptor) ta watch
for events (AnyEvent might or might not keep a reference ta dis file
handle). Note dat only file handlez pointin ta thangs fo' which
non-blockin operation make sense is allowed. Y'all KNOW dat shit, muthafucka! This includes sockets,
most characta devices, pipes, fifos n' so on yo, but not fo' example files
or block devices.
.PP
\&\f(CW\*(C`poll\*(C'\fR must be a strang dat is either \f(CW\*(C`r\*(C'\fR or \f(CW\*(C`w\*(C'\fR, which creates a
watcher waitin fo' \*(L"r\*(R"eadable or \*(L"w\*(R"ritable events, respectively.
.PP
\&\f(CW\*(C`cb\*(C'\fR is tha callback ta invoke each time tha file handle becomes ready.
.PP
Although tha callback might git passed parameters, they value and
presence is undefined n' you cannot rely on em. Portable AnyEvent
callbacks cannot use arguments passed ta I/O watcher callbacks.
.PP
Da I/O watcher might use tha underlyin file descriptor or a cold-ass lil copy of dat shit.
Yo ass must not close a gangbangin' file handle as long as any watcher be actizzle on the
underlyin file descriptor.
.PP
Some event loops issue spurious readinizz notifications, so you should
always use non-blockin calls when reading/writin from/to yo' file
handles.
.PP
Example: wait fo' readabilitizzle of \s-1STDIN,\s0 then read a line n' disable the
watcher.
.PP
.Vb 5
\&   mah $w; $w = AnyEvent\->io (fh => \e*STDIN, poll => \*(Aqr\*(Aq, cb => sub {
\&      chomp (my $input = <STDIN>);
\&      warn "read: $input\en";
\&      undef $w;
\&   });
.Ve
.SS "\s-1TIME WATCHERS\s0"
.IX Subsection "TIME WATCHERS"
.Vb 1
\&   $w = AnyEvent\->timer (afta => <seconds>, cb => <callback>);
\&
\&   $w = AnyEvent\->timer (
\&      afta    => <fractional_seconds>,
\&      interval => <fractional_seconds>,
\&      cb       => <callback>,
\&   );
.Ve
.PP
Yo ass can create a time watcher by callin tha \f(CW\*(C`AnyEvent\->timer\*(C'\fR
method wit tha followin mandatory arguments:
.PP
\&\f(CW\*(C`after\*(C'\fR specifies afta how tha fuck nuff secondz (fractionizzle joints are
supported) tha callback should be invoked. Y'all KNOW dat shit, muthafucka! \f(CW\*(C`cb\*(C'\fR is tha callback ta invoke
in dat case.
.PP
Although tha callback might git passed parameters, they value and
presence is undefined n' you cannot rely on em. Portable AnyEvent
callbacks cannot use arguments passed ta time watcher callbacks.
.PP
Da callback will normally be invoked only once. If you specify another
parameter, \f(CW\*(C`interval\*(C'\fR, as a strictly positizzle number (> 0), then the
callback is ghon be invoked regularly at dat interval (in fractional
seconds) afta tha straight-up original gangsta invocation. I aint talkin' bout chicken n' gravy biatch. If \f(CW\*(C`interval\*(C'\fR is specified wit a
false value, then it is treated as if it was not specified at all.
.PP
Da callback is ghon be rescheduled before invokin tha callback yo, but no
attempt is made ta avoid timer drift up in most backends, so tha interval is
only approximate.
.PP
Example: fire a event afta 7.7 seconds.
.PP
.Vb 3
\&   mah $w = AnyEvent\->timer (afta => 7.7, cb => sub {
\&      warn "timeout\en";
\&   });
\&
\&   # ta quit tha timer:
\&   undef $w;
.Ve
.PP
Example 2: fire a event afta 0.5 seconds, then roughly every last muthafuckin second.
.PP
.Vb 3
\&   mah $w = AnyEvent\->timer (afta => 0.5, interval => 1, cb => sub {
\&      warn "timeout\en";
\&   });
.Ve
.PP
\fI\s-1TIMING ISSUES\s0\fR
.IX Subsection "TIMING ISSUES"
.PP
There is two ways ta handle timers: based on real time (relative, \*(L"fire
in 10 seconds\*(R") n' based on wallclock time (absolute, \*(L"fire at 12
o'clock\*(R").
.PP
While most event loops expect timers ta specified up in a relatizzle way, they
use absolute time internally. This cook up a gangbangin' finger-lickin' difference when yo' clock
\&\*(L"jumps\*(R", fo' example, when ntp decides ta set yo' clock backwardz from
the wack date of 2014\-01\-01 ta 2008\-01\-01, a watcher dat is supposed to
fire \*(L"afta a second\*(R" might straight-up take six muthafuckin years ta finally fire.
.PP
AnyEvent cannot compensate fo' all dis bullshit. Da only event loop dat is conscious
of these thangs is \s-1EV\s0, which offers both relatizzle (ev_timer, based
on legit relatizzle time) n' absolute (ev_periodic, based on wallclock time)
timers.
.PP
AnyEvent always prefers relatizzle timers, if available, matchin the
AnyEvent \s-1API.\s0
.PP
AnyEvent has two additionizzle methodz dat return tha \*(L"current time\*(R":
.IP "AnyEvent\->time" 4
.IX Item "AnyEvent->time"
This returns tha \*(L"current wallclock time\*(R" as a gangbangin' fractionizzle number of
secondz since tha Epoch (the same thang as \f(CW\*(C`time\*(C'\fR or \f(CW\*(C`Time::HiRes::time\*(C'\fR
return, n' tha result is guaranteed ta be compatible wit them).
.Sp
It progresses independently of any event loop processing, i.e. each call
will check tha system clock, which probably gets updated frequently.
.IP "AnyEvent\->now" 4
.IX Item "AnyEvent->now"
This also returns tha \*(L"current wallclock time\*(R" yo, but unlike \f(CW\*(C`time\*(C'\fR, above,
this value might chizzle only once per event loop iteration, dependin on
the event loop (most return tha same time as \f(CW\*(C`time\*(C'\fR, above). This is the
time dat AnyEventz timers git scheduled against.
.Sp
\&\fIIn almost all cases (in all cases if you couldn't give a fuckin shit), dis is the
function ta booty-call when you wanna know tha current time.\fR
.Sp
This function be also often fasta then \f(CW\*(C`AnyEvent\->time\*(C'\fR, and
thus tha preferred method if you want some timestamp (for example,
AnyEvent::Handle uses dis ta update its activitizzle timeouts).
.Sp
Da rest of dis section is only of relevizzle if you try ta be straight-up exact
with yo' timing; you can skip it without a wack conscience.
.Sp
For a practical example of when these times differ, consider Event::Lib
and \s-1EV\s0 n' tha followin set-up:
.Sp
Da event loop is hustlin n' has just invoked one of yo' callbacks at
time=500 (assume no other callbacks delay processing). In yo' callback,
you wait a second by executin \f(CW\*(C`sleep 1\*(C'\fR (blockin tha process fo' a
second) n' then (at time=501) you create a relatizzle timer dat fires
afta three seconds.
.Sp
With Event::Lib, \f(CW\*(C`AnyEvent\->time\*(C'\fR n' \f(CW\*(C`AnyEvent\->now\*(C'\fR will
both return \f(CW501\fR, cuz dat is tha current time, n' tha timer will
be scheduled ta fire at time=504 (\f(CW501\fR + \f(CW3\fR).
.Sp
With \s-1EV\s0, \f(CW\*(C`AnyEvent\->time\*(C'\fR returns \f(CW501\fR (as dat is tha current
time) yo, but \f(CW\*(C`AnyEvent\->now\*(C'\fR returns \f(CW500\fR, as dat is tha time the
last event processin phase started. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. With \s-1EV\s0, yo' timer gets scheduled
to run at time=503 (\f(CW500\fR + \f(CW3\fR).
.Sp
In one sense, Event::Lib is mo' exact, as it uses tha current time
regardless of any delays introduced by event processing. But fuck dat shiznit yo, tha word on tha street is dat most
callbacks do not expect big-ass delays up in processing, so dis causes a
higher drift (and a shitload mo' system calls ta git tha current time).
.Sp
In another sense, \s-1EV\s0 is mo' exact, as yo' timer is ghon be scheduled at
the same time, regardless of how tha fuck long event processin straight-up took.
.Sp
In either case, if you care (and up in most cases, you don't), then you
can git whatever behaviour you want wit any event loop, by takin the
difference between \f(CW\*(C`AnyEvent\->time\*(C'\fR n' \f(CW\*(C`AnyEvent\->now\*(C'\fR into
account.
.IP "AnyEvent\->now_update" 4
.IX Item "AnyEvent->now_update"
Some event loops (like fuckin \s-1EV\s0 or AnyEvent::Loop) cache tha current
time fo' each loop iteration (see tha rap of AnyEvent\->now,
above).
.Sp
When a cold-ass lil callback runs fo' a long-ass time (or when tha process chills), then
this \*(L"current\*(R" time will differ substantially from tha real time, which
might affect timers n' time-outs.
.Sp
When dis is tha case, you can call dis method, which will update the
event loopz scam of \*(L"current time\*(R".
.Sp
A typical example would be a script up in a wizzy server (e.g. \f(CW\*(C`mod_perl\*(C'\fR) \-
when mod_perl executes tha script, then tha event loop gonna git tha wrong
idea bout tha \*(L"current time\*(R" (bein potentially far up in tha past, when the
script ran tha last time). In dat case you should arrange a cold-ass lil call ta \f(CW\*(C`AnyEvent\->now_update\*(C'\fR each time tha wizzy server process wakes up again
(e.g. all up in tha start of yo' script, or up in a handlez).
.Sp
Note dat uppimpin tha time \fImight\fR cause some events ta be handled.
.SS "\s-1SIGNAL WATCHERS\s0"
.IX Subsection "SIGNAL WATCHERS"
.Vb 1
\&   $w = AnyEvent\->signal (signal => <uppercase_signal_name>, cb => <callback>);
.Ve
.PP
Yo ass can peep fo' signals rockin a signal watcher, \f(CW\*(C`signal\*(C'\fR is tha signal
\&\fIname\fR up in uppercase n' without any \f(CW\*(C`SIG\*(C'\fR prefix, \f(CW\*(C`cb\*(C'\fR is tha Perl
callback ta be invoked whenever a signal occurs.
.PP
Although tha callback might git passed parameters, they value and
presence is undefined n' you cannot rely on em. Portable AnyEvent
callbacks cannot use arguments passed ta signal watcher callbacks.
.PP
Multiple signal occurrences can be clumped together tha fuck into one callback
invocation, n' callback invocation is ghon be synchronous. Right back up in yo muthafuckin ass. Synchronous means
that it might take a while until tha signal gets handled by tha process,
but it is guaranteed not ta interrupt any other callbacks.
.PP
Da main advantage of rockin these watchers is dat you can share a signal
between multiple watchers, n' AnyEvent will ensure dat signals will not
interrupt yo' program at wack times.
.PP
This watcher might use \f(CW%SIG\fR (dependin on tha event loop used),
so programs overwritin dem signals directly will likely not work
correctly.
.PP
Example: exit on \s-1SIGINT\s0
.PP
.Vb 1
\&   mah $w = AnyEvent\->signal (signal => "INT", cb => sub { exit 1 });
.Ve
.PP
\fIRestart Behaviour\fR
.IX Subsection "Restart Behaviour"
.PP
While restart behaviour is up ta tha event loop implementation, most will
not restart syscalls (that includes Async::Interrupt n' AnyEvent's
pure perl implementation).
.PP
\fISafe/Unsafe Signals\fR
.IX Subsection "Safe/Unsafe Signals"
.PP
Perl signals can be either \*(L"safe\*(R" (synchronous ta opcode handling)
or \*(L"unsafe\*(R" (asynchronous) \- tha forma might delay signal delivery
indefinitely, tha latta might corrupt yo' memory.
.PP
AnyEvent signal handlezs are, up in addition, synchronous ta tha event loop,
i.e. they aint gonna interrupt yo' hustlin perl program but will only be
called as part of tha aiiight event handlin (just like timer, I/O etc.
callbacks, too).
.PP
\fISignal Races, Delays n' Workarounds\fR
.IX Subsection "Signal Races, Delays n' Workarounds"
.PP
Many event loops (e.g. Glib, Tk, Qt, IO::Async) do not support
attachin callbacks ta signals up in a generic way, which be a bitch ass muthafucka,
as you cannot do race-free signal handlin up in perl, requiring
C libraries fo' all dis bullshit fo' realz. AnyEvent will try ta do its best, which
means up in some cases, signals is ghon be delayed. Y'all KNOW dat shit, muthafucka! Da maximum time
a signal might be delayed is 10 secondz by default yo, but can
be overriden via \f(CW$ENV{PERL_ANYEVENT_MAX_SIGNAL_LATENCY}\fR or
\&\f(CW$AnyEvent::MAX_SIGNAL_LATENCY\fR \- peep tha \*(L"\s-1ENVIRONMENT VARIABLES\*(R"\s0
section fo' details.
.PP
All these problems can be avoided by installin tha optional
Async::Interrupt module, which works wit most event loops. Well shiiiit, it will not
work wit inherently fucked up event loops like fuckin Event or Event::Lib
(and not wit \s-1POE\s0 currently). For them, you just gotta suffer the
delays.
.SS "\s-1CHILD PROCESS WATCHERS\s0"
.IX Subsection "CHILD PROCESS WATCHERS"
.Vb 1
\&   $w = AnyEvent\->child (pid => <process id>, cb => <callback>);
.Ve
.PP
Yo ass can also peep fo' a cold-ass lil lil pimp process exit n' catch its exit status.
.PP
Da lil pimp process is specified by tha \f(CW\*(C`pid\*(C'\fR argument (on some backends,
usin \f(CW0\fR watches fo' any lil pimp process exit, on others dis will
croak). Da watcher is ghon be triggered only when tha lil pimp process has
finished n' a exit status be available, not on any trace events
(stopped/continued).
.PP
Da callback is ghon be called wit tha pid n' exit status (as returned by
waitpid), so unlike other watcher types, you \fIcan\fR rely on lil pimp watcher
callback arguments.
.PP
This watcher type works by installin a signal handlez fo' \f(CW\*(C`SIGCHLD\*(C'\fR,
and since it cannot be shared, not a god damn thang else should use \s-1SIGCHLD\s0 or reap
random lil pimp processes (waitin fo' specific lil pimp processes, e.g. inside
\&\f(CW\*(C`system\*(C'\fR, is just fine).
.PP
There be a slight catch ta lil pimp watchers, however: you probably start them
\&\fIafter\fR tha lil pimp process was pimped, n' dis means tha process could
have exited already (and no \s-1SIGCHLD\s0 is ghon be busted no mo').
.PP
Not all event models handle dis erectly (neither \s-1POE\s0 nor IO::Async do,
see they AnyEvent::Impl manpages fo' details) yo, but even fo' event models
that \fIdo\fR handle dis erectly, they probably need ta be loaded before
the process exits (i.e. before you fork up in tha straight-up original gangsta place) fo' realz. AnyEvent's
pure perl event loop handlez all cases erectly regardless of when you
start tha watcher.
.PP
This means you cannot create a cold-ass lil lil pimp watcher as tha straight-up first
thang up in a AnyEvent program, you \fIhave\fR ta create at least one
watcher before you \f(CW\*(C`fork\*(C'\fR tha lil pimp (alternatively, you can call
\&\f(CW\*(C`AnyEvent::detect\*(C'\fR).
.PP
As most event loops do not support waitin fo' lil pimp events, they will be
emulated by AnyEvent up in most cases, up in which case tha latency n' race
problems mentioned up in tha description of signal watchers apply.
.PP
Example: fork a process n' wait fo' it
.PP
.Vb 1
\&   mah $done = AnyEvent\->condvar;
\&  
\&   mah $pid = fork or exit 5;
\&  
\&   mah $w = AnyEvent\->child (
\&      pid => $pid,
\&      cb  => sub {
\&         mah ($pid, $status) = @_;
\&         warn "pid $pid exited wit status $status";
\&         $done\->send;
\&      },
\&   );
\&  
\&   # do suttin' else, then wait fo' process exit
\&   $done\->recv;
.Ve
.SS "\s-1IDLE WATCHERS\s0"
.IX Subsection "IDLE WATCHERS"
.Vb 1
\&   $w = AnyEvent\->idle (cb => <callback>);
.Ve
.PP
This will repeatedly invoke tha callback afta tha process becomes idle,
until either tha watcher is destroyed or freshly smoked up events done been detected.
.PP
Idle watchers is useful when there be a need ta do somethang yo, but it
is not so blingin (or wise) ta do it instantly. Da callback will be
invoked only when there is \*(L"nothang betta ta do\*(R", which is usually
defined as \*(L"all outstandin events done been handled n' no freshly smoked up events
have been detected\*(R". That means dat idle watchers ideally git invoked
when tha event loop has just polled fo' freshly smoked up events but none have been
detected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Instead of blockin ta wait fo' mo' events, tha idle watchers
will be invoked.
.PP
Unfortunately, most event loops do not straight-up support idle watchers (only
\&\s-1EV,\s0 Event n' Glib do it up in a usable fashion) \- fo' tha rest, AnyEvent
will simply call tha callback \*(L"from time ta time\*(R".
.PP
Example: read lines from \s-1STDIN,\s0 but only process dem when the
program is otherwise idle:
.PP
.Vb 4
\&   mah @lines; # read data
\&   mah $idle_w;
\&   mah $io_w = AnyEvent\->io (fh => \e*STDIN, poll => \*(Aqr\*(Aq, cb => sub {
\&      push @lines, scalar <STDIN>;
\&
\&      # start a idle watcher, if not already done
\&      $idle_w ||= AnyEvent\->idle (cb => sub {
\&         # handle only one line, when there be lines left
\&         if (my $line = shift @lines) {
\&            print "handled when idle: $line";
\&         } else {
\&            # otherwise disable tha idle watcher again
\&            undef $idle_w;
\&         }
\&      });
\&   });
.Ve
.SS "\s-1CONDITION VARIABLES\s0"
.IX Subsection "CONDITION VARIABLES"
.Vb 1
\&   $cv = AnyEvent\->condvar;
\&
\&   $cv\->send (<list>);
\&   mah @res = $cv\->recv;
.Ve
.PP
If yo ass is familiar wit some event loops yo big-ass booty is ghon know dat all of them
require you ta run some blockin \*(L"loop\*(R", \*(L"run\*(R" or similar function that
will actively peep fo' freshly smoked up events n' call yo' callbacks.
.PP
AnyEvent is slightly different: it expects some muthafucka else ta run tha event
loop n' will only block when necessary (usually when holla'd at by tha user).
.PP
Da tool ta do dat is called a \*(L"condizzle variable\*(R", so called cuz
they represent a cold-ass lil condizzle dat must become true.
.PP
Now is probably a phat time ta peep tha examplez further below.
.PP
Condizzle variablez can be pimped by callin tha \f(CW\*(C`AnyEvent\->condvar\*(C'\fR method, probably without arguments, n' you can put dat on yo' toast. Da only argument pair allowed is
\&\f(CW\*(C`cb\*(C'\fR, which specifies a cold-ass lil callback ta be called when tha condizzle variable
becomes true, wit tha condizzle variable as tha straight-up original gangsta argument (but not
the thangs up in dis biatch).
.PP
Afta creation, tha condizzle variable is \*(L"false\*(R" until it becomes \*(L"true\*(R"
by callin tha \f(CW\*(C`send\*(C'\fR method (or callin tha condizzle variable as if it
were a cold-ass lil callback, read bout tha caveats up in tha description fo' tha \f(CW\*(C`\->send\*(C'\fR method).
.PP
Since condizzle variablez is da most thugged-out complex part of tha AnyEvent \s-1API,\s0 here are
some different menstrual modelz of what tha fuck they is \- pick tha ones you can connect to:
.IP "\(bu" 4
Condizzle variablez is like callbacks \- you can call dem (and pass dem instead
of callbacks). Unlike callbacks however, you can also wait fo' dem ta be called.
.IP "\(bu" 4
Condizzle variablez is signals \- one side can emit or bust them,
the other side can wait fo' them, or install a handlez dat is called when
the signal fires.
.IP "\(bu" 4
Condizzle variablez is like \*(L"Merge Points\*(R" \- points up in yo' program
where you merge multiple independent thangs up in dis biatch/control flows tha fuck into one.
.IP "\(bu" 4
Condizzle variablez represent a transaction \- functions dat start
some kind of transaction can return them, leavin tha calla tha chizzle
between waitin up in a funky-ass blockin fashion, or settin a cold-ass lil callback.
.IP "\(bu" 4
Condizzle variablez represent future joints, or promises ta deliver
some result, long before tha result be available.
.PP
Condizzle variablez is straight-up useful ta signal dat suttin' has finished,
for example, if you write a module dat do asynchronous http requests,
then a cold-ass lil condizzle variable would be tha ideal muthafucka ta signal the
availabilitizzle of thangs up in dis biatch. Da user can either act when tha callback is
called or can synchronously \f(CW\*(C`\->recv\*(C'\fR fo' tha thangs up in dis biatch.
.PP
Yo ass can also use dem ta simulate traditionizzle event loops \- fo' example,
you can block yo' main program until a event occurs \- fo' example, you
could \f(CW\*(C`\->recv\*(C'\fR up in yo' main program until tha user clicks tha Quit
button of yo' app, which would \f(CW\*(C`\->send\*(C'\fR tha \*(L"quit\*(R" event.
.PP
Note dat condizzle variablez recurse tha fuck into tha event loop \- if you have
two piecez of code dat call \f(CW\*(C`\->recv\*(C'\fR up in a round-robin fashion, you
lose. Therefore, condizzle variablez is phat ta export ta yo' calla yo, but
you should avoid bustin a funky-ass blockin wait yo ass, at least up in callbacks,
as dis asks fo' shit.
.PP
Condizzle variablez is represented by hash refs up in perl, n' tha keys
used by AnyEvent itself is all named \f(CW\*(C`_ae_XXX\*(C'\fR ta make subclassing
easy (it is often useful ta build yo' own transaction class on top of
AnyEvent). To subclass, use \f(CW\*(C`AnyEvent::CondVar\*(C'\fR as base class n' call
its \f(CW\*(C`new\*(C'\fR method up in yo' own \f(CW\*(C`new\*(C'\fR method.
.PP
There is two \*(L"sides\*(R" ta a cold-ass lil condizzle variable \- tha \*(L"producer side\*(R" which
eventually calls \f(CW\*(C`\-> send\*(C'\fR, n' tha \*(L"consumer side\*(R", which waits
for tha bust ta occur.
.PP
Example: wait fo' a timer.
.PP
.Vb 2
\&   # condition: "wait till tha timer is fired"
\&   mah $timer_fired = AnyEvent\->condvar;
\&
\&   # create tha timer \- we could wait for, say
\&   # a handle becomign ready, or even an
\&   # AnyEvent::HTTP request ta finish yo, but
\&   # up in dis case, we simply bust a timer:
\&   mah $w = AnyEvent\->timer (
\&      afta => 1,
\&      cb    => sub { $timer_fired\->send },
\&   );
\&
\&   # dis "blocks" (while handlin events) till tha callback
\&   # calls \->send
\&   $timer_fired\->recv;
.Ve
.PP
Example: wait fo' a timer yo, but take advantage of tha fact dat condition
variablez is also callable directly.
.PP
.Vb 3
\&   mah $done = AnyEvent\->condvar;
\&   mah $delay = AnyEvent\->timer (afta => 5, cb => $done);
\&   $done\->recv;
.Ve
.PP
Example: Imagine a \s-1API\s0 dat returns a cold-ass lil condvar n' don't support
callbacks. This is how tha fuck you cook up a synchronous call, fo' example from
the main program:
.PP
.Vb 1
\&   use AnyEvent::CouchDB;
\&
\&   ...
\&
\&   mah @info = $couchdb\->info\->recv;
.Ve
.PP
And dis is how tha fuck you would just set a cold-ass lil callback ta be called whenever the
results is available:
.PP
.Vb 3
\&   $couchdb\->info\->cb (sub {
\&      mah @info = $_[0]\->recv;
\&   });
.Ve
.PP
\fI\s-1METHODS FOR PRODUCERS\s0\fR
.IX Subsection "METHODS FOR PRODUCERS"
.PP
These methodz should only be used by tha producin side, i.e. the
code/module dat eventually sendz tha signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Note dat it be also
the balla side which creates tha condvar up in most cases yo, but it aint
uncommon fo' tha thug ta create it as well.
.ie n .IP "$cv\->send (...)" 4
.el .IP "\f(CW$cv\fR\->send (...)" 4
.IX Item "$cv->send (...)"
Flag tha condizzle as locked n loaded \- a hustlin \f(CW\*(C`\->recv\*(C'\fR n' all further
calls ta \f(CW\*(C`recv\*(C'\fR will (eventually) return afta dis method has been
called. Y'all KNOW dat shit, muthafucka! If no muthafucka is waitin tha bust is ghon be remembered.
.Sp
If a cold-ass lil callback has been set on tha condizzle variable, it is called
immediately from within send.
.Sp
Any arguments passed ta tha \f(CW\*(C`send\*(C'\fR call is ghon be returned by all
future \f(CW\*(C`\->recv\*(C'\fR calls.
.Sp
Condizzle variablez is overloaded so one can call dem directly (as if
they was a cold-ass lil code reference). Callin dem directly is tha same ol' dirty as calling
\&\f(CW\*(C`send\*(C'\fR.
.ie n .IP "$cv\->croak ($error)" 4
.el .IP "\f(CW$cv\fR\->croak ($error)" 4
.IX Item "$cv->croak ($error)"
Similar ta send yo, but causes all calls ta \f(CW\*(C`\->recv\*(C'\fR ta invoke
\&\f(CW\*(C`Carp::croak\*(C'\fR wit tha given error message/object/scalar.
.Sp
This can be used ta signal any errors ta tha condizzle variable
user/consumer n' shit. Bustin it dis way instead of callin \f(CW\*(C`croak\*(C'\fR directly
delays tha error detection yo, but has tha overwhelmin advantage dat it
diagnoses tha error all up in tha place where tha result is expected, n' not
deep up in some event callback wit no connection ta tha actual code causing
the problem.
.ie n .IP "$cv\->begin ([group callback])" 4
.el .IP "\f(CW$cv\fR\->begin ([group callback])" 4
.IX Item "$cv->begin ([group callback])"
.PD 0
.ie n .IP "$cv\->end" 4
.el .IP "\f(CW$cv\fR\->end" 4
.IX Item "$cv->end"
.PD
These two methodz can be used ta combine nuff transactions/events into
one. For example, a gangbangin' function dat pings nuff hosts up in parallel might want
to bust a cold-ass lil condizzle variable fo' tha whole process.
.Sp
Every call ta \f(CW\*(C`\->begin\*(C'\fR will increment a cold-ass lil counter, n' every last muthafuckin call to
\&\f(CW\*(C`\->end\*(C'\fR will decrement dat shit.  If tha counta reaches \f(CW0\fR up in \f(CW\*(C`\->end\*(C'\fR, tha (last) callback passed ta \f(CW\*(C`begin\*(C'\fR is ghon be executed, passin the
condvar as first argument. That callback is \fIsupposed\fR ta booty-call \f(CW\*(C`\->send\*(C'\fR yo, but dat aint required. Y'all KNOW dat shit, muthafucka! If no crew callback was set, \f(CW\*(C`send\*(C'\fR will
be called without any arguments.
.Sp
Yo ass can be thinkin of \f(CW\*(C`$cv\->send\*(C'\fR givin you a \s-1OR\s0 condizzle (one call
sends), while \f(CW\*(C`$cv\->begin\*(C'\fR n' \f(CW\*(C`$cv\->end\*(C'\fR givin you a \s-1AND\s0
condizzle (all \f(CW\*(C`begin\*(C'\fR calls must be \f(CW\*(C`end\*(C'\fR'ed before tha condvar sends).
.Sp
Letz start wit a simple example: you have two I/O watchers (for example,
\&\s-1STDOUT\s0 n' \s-1STDERR\s0 fo' a program), n' you wanna wait fo' both streams to
close before activatin a cold-ass lil condvar:
.Sp
.Vb 1
\&   mah $cv = AnyEvent\->condvar;
\&
\&   $cv\->begin; # first watcher
\&   mah $w1 = AnyEvent\->io (fh => $fh1, cb => sub {
\&      defined sysread $fh1, mah $buf, 4096
\&         or $cv\->end;
\&   });
\&
\&   $cv\->begin; # second watcher
\&   mah $w2 = AnyEvent\->io (fh => $fh2, cb => sub {
\&      defined sysread $fh2, mah $buf, 4096
\&         or $cv\->end;
\&   });
\&
\&   $cv\->recv;
.Ve
.Sp
This works cuz fo' every last muthafuckin event source (\s-1EOF\s0 on file handle), there is
one call ta \f(CW\*(C`begin\*(C'\fR, so tha condvar waits fo' all calls ta \f(CW\*(C`end\*(C'\fR before
sending.
.Sp
Da pin example mentioned above is slightly mo' fucked up, as the
there is thangs up in dis biatch ta be passwd back, n' tha number of tasks dat are
begun can potentially be zero:
.Sp
.Vb 1
\&   mah $cv = AnyEvent\->condvar;
\&
\&   mah %result;
\&   $cv\->begin (sub { shift\->send (\e%result) });
\&
\&   fo' mah $host (@list_of_hosts) {
\&      $cv\->begin;
\&      ping_host_then_call_callback $host, sub {
\&         $result{$host} = ...;
\&         $cv\->end;
\&      };
\&   }
\&
\&   $cv\->end;
\&
\&   ...
\&
\&   mah $results = $cv\->recv;
.Ve
.Sp
This code fragment supposedly pings a fuckin shitload of hosts n' calls
\&\f(CW\*(C`send\*(C'\fR afta thangs up in dis biatch fo' all then have done been gathered \- up in any
order n' shit. To bust dis, tha code thangs a cold-ass lil call ta \f(CW\*(C`begin\*(C'\fR when it starts
each pin request n' calls \f(CW\*(C`end\*(C'\fR when it has received some result for
it. Right back up in yo muthafuckin ass. Since \f(CW\*(C`begin\*(C'\fR n' \f(CW\*(C`end\*(C'\fR only maintain a cold-ass lil counter, tha order up in which
results arrive aint relevant.
.Sp
There be a additionizzle bracketin call ta \f(CW\*(C`begin\*(C'\fR n' \f(CW\*(C`end\*(C'\fR outside the
loop, which serves two blingin purposes: first, it sets tha callback
to be called once tha counta reaches \f(CW0\fR, n' second, it ensures that
\&\f(CW\*(C`send\*(C'\fR is called even when \f(CW\*(C`no\*(C'\fR hosts is bein pinged (the loop
doesn't execute once).
.Sp
This is tha general pattern when you \*(L"fan out\*(R" tha fuck into multiple (but
potentially zero) subrequests: use a outa \f(CW\*(C`begin\*(C'\fR/\f(CW\*(C`end\*(C'\fR pair ta set
the callback n' ensure \f(CW\*(C`end\*(C'\fR is called at least once, n' then, fo' each
subrequest you start, call \f(CW\*(C`begin\*(C'\fR n' fo' each subrequest you finish,
call \f(CW\*(C`end\*(C'\fR.
.PP
\fI\s-1METHODS FOR CONSUMERS\s0\fR
.IX Subsection "METHODS FOR CONSUMERS"
.PP
These methodz should only be used by tha consumin side, i.e. the
code awaits tha condition.
.ie n .IP "$cv\->recv" 4
.el .IP "\f(CW$cv\fR\->recv" 4
.IX Item "$cv->recv"
Wait (blockin if necessary) until tha \f(CW\*(C`\->send\*(C'\fR or \f(CW\*(C`\->croak\*(C'\fR methodz done been called on \f(CW$cv\fR, while servicin other watchers
normally.
.Sp
Yo ass can only wait once on a cold-ass lil condizzle \- additionizzle calls is valid but
will return immediately.
.Sp
If a error condizzle has been set by callin \f(CW\*(C`\->croak\*(C'\fR, then this
function will call \f(CW\*(C`croak\*(C'\fR.
.Sp
In list context, all parametas passed ta \f(CW\*(C`send\*(C'\fR is ghon be returned,
in scalar context only tha straight-up original gangsta one is ghon be returned.
.Sp
Note dat bustin a funky-ass blockin wait up in a cold-ass lil callback aint supported by any
event loop, dat is, recursive invocation of a funky-ass blockin \f(CW\*(C`\->recv\*(C'\fR is
not allowed n' tha \f(CW\*(C`recv\*(C'\fR call will \f(CW\*(C`croak\*(C'\fR if such a cold-ass lil condizzle is
detected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This requirement can be dropped by relyin on Coro::AnyEvent
, which allows you ta do a funky-ass blockin \f(CW\*(C`\->recv\*(C'\fR from any thread
that don't run tha event loop itself. Coro::AnyEvent is loaded
automatically when Coro is used wit AnyEvent, so code do not need
to do anythang special ta take advantage of that: any code dat would
normally block yo' program cuz it calls \f(CW\*(C`recv\*(C'\fR, be executed up in an
\&\f(CW\*(C`async\*(C'\fR thread instead without blockin other threads.
.Sp
Not all event models support a funky-ass blockin wait \- some take a thugged-out dirtnap up in dat case
(programs might wanna do dat ta stay interactive), so \fIif yo ass is
usin dis from a module, never require a funky-ass blockin wait\fR. Instead, let the
calla decizzle whether tha call will block or not (for example, by coupling
condizzle variablez wit some kind of request thangs up in dis biatch n' supporting
callbacks so tha calla knows dat gettin tha result aint gonna block,
while still supportin blockin waits if tha calla so desires).
.Sp
Yo ass can ensure dat \f(CW\*(C`\->recv\*(C'\fR never blocks by settin a cold-ass lil callback and
only callin \f(CW\*(C`\->recv\*(C'\fR from within dat callback (or at a later
time). This will work even when tha event loop do not support blocking
waits otherwise.
.ie n .IP "$bool = $cv\->ready" 4
.el .IP "\f(CW$bool\fR = \f(CW$cv\fR\->ready" 4
.IX Item "$bool = $cv->ready"
Returns legit when tha condizzle is \*(L"true\*(R", i.e. whether \f(CW\*(C`send\*(C'\fR or
\&\f(CW\*(C`croak\*(C'\fR done been called.
.ie n .IP "$cb = $cv\->cb ($cb\->($cv))" 4
.el .IP "\f(CW$cb\fR = \f(CW$cv\fR\->cb ($cb\->($cv))" 4
.IX Item "$cb = $cv->cb ($cb->($cv))"
This be a mutator function dat returns tha callback set n' optionally
replaces it before bustin so.
.Sp
Da callback is ghon be called when tha condizzle becomes \*(L"true\*(R", i.e. when
\&\f(CW\*(C`send\*(C'\fR or \f(CW\*(C`croak\*(C'\fR is called, wit tha only argument bein the
condizzle variable itself. If tha condizzle be already true, the
callback is called immediately when it is set. Callin \f(CW\*(C`recv\*(C'\fR inside
the callback or at any lata time is guaranteed not ta block.
.SH "SUPPORTED EVENT LOOPS/BACKENDS"
.IX Header "SUPPORTED EVENT LOOPS/BACKENDS"
Da available backend classes is (every class has its own manpage):
.IP "Backendz dat is autoprobed when no other event loop can be found." 4
.IX Item "Backendz dat is autoprobed when no other event loop can be found."
\&\s-1EV\s0 is tha preferred backend when no other event loop seems ta be in
use. If \s-1EV\s0 aint installed, then AnyEvent will fall back ta its own
pure-perl implementation, which be available everywhere as it comes with
AnyEvent itself.
.Sp
.Vb 2
\&   AnyEvent::Impl::EV        based on EV (interface ta libev, dopest chizzle).
\&   AnyEvent::Impl::Perl      pure\-perl AnyEvent::Loop, fast n' portable.
.Ve
.IP "Backendz dat is transparently bein picked up when they is used." 4
.IX Item "Backendz dat is transparently bein picked up when they is used."
These is ghon be used if they is already loaded when tha straight-up original gangsta watcher
is pimped, up in which case it be assumed dat tha application is using
them. This means dat AnyEvent will automatically pick tha right backend
when tha main program loadz a event module before anythang starts to
create watchers. Nothang special need ta be done by tha main program.
.Sp
.Vb 9
\&   AnyEvent::Impl::Event     based on Event, straight-up stable, few glitches.
\&   AnyEvent::Impl::Glib      based on Glib, slow but straight-up stable.
\&   AnyEvent::Impl::Tk        based on Tk, straight-up broken.
\&   AnyEvent::Impl::EventLib  based on Event::Lib, leaks memory n' worse.
\&   AnyEvent::Impl::POE       based on POE, straight-up slow, some limitations.
\&   AnyEvent::Impl::Irssi     used when hustlin within irssi.
\&   AnyEvent::Impl::IOAsync   based on IO::Async.
\&   AnyEvent::Impl::Cocoa     based on Cocoa::EventLoop.
\&   AnyEvent::Impl::FLTK      based on FLTK (fltk 2 binding).
.Ve
.IP "Backendz wit special needs." 4
.IX Item "Backendz wit special needs."
Qt requires tha Qt::Application ta be instantiated first yo, but will
otherwise be picked up automatically fo' realz. As long as tha main program
instantiates tha application before any AnyEvent watchers is pimped,
everythang should just work.
.Sp
.Vb 1
\&   AnyEvent::Impl::Qt        based on Qt.
.Ve
.IP "Event loops dat is indirectly supported via other backends." 4
.IX Item "Event loops dat is indirectly supported via other backends."
Some event loops can be supported via other modules:
.Sp
There is no direct support fo' WxWidgets (Wx) or Prima.
.Sp
\&\fBWxWidgets\fR has no support fo' watchin file handles. But fuck dat shiznit yo, tha word on tha street is dat you can
use WxWidgets all up in tha \s-1POE\s0 adaptor, as \s-1POE\s0 has a Wx backend dat simply
polls 20 times per second, which was considered ta be too wack ta even
consider fo' AnyEvent.
.Sp
\&\fBPrima\fR aint supported as no muthafucka seems ta be rockin it yo, but it has a \s-1POE\s0
backend, so it can be supported all up in \s-1POE.\s0
.Sp
AnyEvent knows bout both Prima n' Wx, however, n' will try to
load \s-1POE\s0 when detectin them, up in tha hope dat \s-1POE\s0 will pick dem up,
in which case every last muthafuckin thang is ghon be automatic.
.SH "GLOBAL VARIABLES AND FUNCTIONS"
.IX Header "GLOBAL VARIABLES AND FUNCTIONS"
These is not normally required ta use AnyEvent yo, but can be useful to
write AnyEvent extension modules.
.ie n .IP "$AnyEvent::MODEL" 4
.el .IP "\f(CW$AnyEvent::MODEL\fR" 4
.IX Item "$AnyEvent::MODEL"
Gotz Nuff \f(CW\*(C`undef\*(C'\fR until tha straight-up original gangsta watcher is bein pimped, before the
backend has been autodetected.
.Sp
Afterwardz it gotz nuff tha event model dat is bein used, which is the
name of tha Perl class implementin tha model. This class is probably one
of tha \f(CW\*(C`AnyEvent::Impl::xxx\*(C'\fR modulez yo, but can be any other class up in the
case AnyEvent has been extended at runtime (e.g. up in \fIrxvt-unicode\fR it
will be \f(CW\*(C`urxvt::anyevent\*(C'\fR).
.IP "AnyEvent::detect" 4
.IX Item "AnyEvent::detect"
Returns \f(CW$AnyEvent::MODEL\fR, forcin autodetection of tha event model
if necessary. Yo ass should only call dis function right before you would
have pimped a AnyEvent watcher anyway, dat is, as late as possible at
runtime, n' not e.g. durin initialisation of yo' module.
.Sp
Da effect of callin dis function be as if a watcher had been pimped
(specifically, actions dat happen \*(L"when tha straight-up original gangsta watcher is pimped\*(R"
happen when callin detetc as well).
.Sp
If you need ta do some initialisation before AnyEvent watchers are
created, use \f(CW\*(C`post_detect\*(C'\fR.
.ie n .IP "$guard = AnyEvent::post_detect { \s-1BLOCK \s0}" 4
.el .IP "\f(CW$guard\fR = AnyEvent::post_detect { \s-1BLOCK \s0}" 4
.IX Item "$guard = AnyEvent::post_detect { BLOCK }"
Arranges fo' tha code block ta be executed as soon as tha event model is
autodetected (or immediately if dat has already happened).
.Sp
Da block is ghon be executed \fIafter\fR tha actual backend has been detected
(\f(CW$AnyEvent::MODEL\fR is set) yo, but \fIbefore\fR any watchers have been
created, so it is possible ta e.g. patch \f(CW@AnyEvent::ISA\fR or do
other initialisations \- peep tha sourcez of AnyEvent::Strict or
AnyEvent::AIO ta peep how tha fuck dis is used.
.Sp
Da most common usage is ta create some global watchers, without forcing
event module detection too early, fo' example, AnyEvent::AIO creates
and installs tha global \s-1IO::AIO\s0 watcher up in a \f(CW\*(C`post_detect\*(C'\fR block to
avoid autodetectin tha event module at load time.
.Sp
If called up in scalar or list context, then it creates n' returns a object
that automatically removes tha callback again n' again n' again when it is destroyed (or
\&\f(CW\*(C`undef\*(C'\fR when tha hook was immediately executed). Right back up in yo muthafuckin ass. See AnyEvent::AIO for
a case where dis is useful.
.Sp
Example: Smoke a watcher fo' tha \s-1IO::AIO\s0 module n' store it in
\&\f(CW$WATCHER\fR yo, but do so only do so afta tha event loop is initialised.
.Sp
.Vb 1
\&   our WATCHER;
\&
\&   mah $guard = AnyEvent::post_detect {
\&      $WATCHER = AnyEvent\->io (fh => IO::AIO::poll_fileno, poll => \*(Aqr\*(Aq, cb => \e&IO::AIO::poll_cb);
\&   };
\&
\&   # tha ||= is blingin up in case post_detect immediately runs tha block,
\&   # as ta not clobber tha newly\-created watcher n' shit. assignin both watcher and
\&   # post_detect guard ta tha same variable has tha advantage of playas being
\&   # able ta just C<undef $WATCHER> if tha watcher causes dem grief.
\&
\&   $WATCHER ||= $guard;
.Ve
.ie n .IP "@AnyEvent::post_detect" 4
.el .IP "\f(CW@AnyEvent::post_detect\fR" 4
.IX Item "@AnyEvent::post_detect"
If there be any code references up in dis array (you can \f(CW\*(C`push\*(C'\fR ta it
before or afta loadin AnyEvent), then they is ghon be called directly
afta tha event loop has been chosen.
.Sp
Yo ass should check \f(CW$AnyEvent::MODEL\fR before addin ta dis array, though:
if it is defined then tha event loop has already been detected, n' the
array is ghon be ignored.
.Sp
Best use \f(CW\*(C`AnyEvent::post_detect { BLOCK }\*(C'\fR when yo' application allows
it, as it takes care of these details.
.Sp
This variable is mainly useful fo' modulez dat can do suttin' useful
when AnyEvent is used n' thus wanna know when it is initialised yo, but do
not need ta even load it by default. This array serves up tha means ta hook
into AnyEvent passively, without loadin dat shit.
.Sp
Example: To load Coro::AnyEvent whenever Coro n' AnyEvent is used
together, you could put dis tha fuck into Coro (this is tha actual code used by
Coro ta accomplish this):
.Sp
.Vb 8
\&   if (defined $AnyEvent::MODEL) {
\&      # AnyEvent already initialised, so load Coro::AnyEvent
\&      require Coro::AnyEvent;
\&   } else {
\&      # AnyEvent not yet initialised, so make shizzle ta load Coro::AnyEvent
\&      # as soon as it is
\&      push @AnyEvent::post_detect, sub { require Coro::AnyEvent };
\&   }
.Ve
.IP "AnyEvent::postpone { \s-1BLOCK \s0}" 4
.IX Item "AnyEvent::postpone { BLOCK }"
Arranges fo' tha block ta be executed quicker than a muthafucka yo, but not before
the call itself returns. In practise, tha block is ghon be executed just
before tha event loop polls fo' freshly smoked up events, or shortly afterwards.
.Sp
This function never returns anythang (to make tha \f(CW\*(C`return postpone { ...
}\*(C'\fR idiom mo' useful.
.Sp
To KNOW tha usefulnizz of dis function, consider a gangbangin' function that
asynchronously do suttin' fo' you n' returns some transaction
object or guard ta let you quit tha operation. I aint talkin' bout chicken n' gravy biatch. For example,
\&\f(CW\*(C`AnyEvent::Socket::tcp_connect\*(C'\fR:
.Sp
.Vb 5
\&   # start a cold-ass lil conenction attempt unless one be active
\&   $self\->{connect_guard} ||= AnyEvent::Socket::tcp_connect "www.example.net", 80, sub {
\&      delete $self\->{connect_guard};
\&      ...
\&   };
.Ve
.Sp
Imagine dat dis function could instantly call tha callback, for
example, cuz it detects a obvious error like fuckin a wack port
number n' shit. Invokin tha callback before tha function returns causes problems
however: tha callback is ghon be called n' will try ta delete tha guard
object. But since tha function aint returned yet, there is not a god damn thang to
delete. When tha function eventually returns it will assign tha guard
object ta \f(CW\*(C`$self\->{connect_guard}\*(C'\fR, where it will likely never be
deleted, so tha program be thinkin it is still tryin ta connect.
.Sp
This is where \f(CW\*(C`AnyEvent::postpone\*(C'\fR should be used. Y'all KNOW dat shit, muthafucka! Instead of callin the
callback directly on error:
.Sp
.Vb 2
\&   $cb\->(undef), return # signal error ta callback, BAD!
\&      if $some_error_condition;
.Ve
.Sp
It should use \f(CW\*(C`postpone\*(C'\fR:
.Sp
.Vb 2
\&   AnyEvent::postpone { $cb\->(undef) }, return # signal error ta callback, later
\&      if $some_error_condition;
.Ve
.ie n .IP "AnyEvent::log $level, $msg[, @args]" 4
.el .IP "AnyEvent::log \f(CW$level\fR, \f(CW$msg\fR[, \f(CW@args\fR]" 4
.IX Item "AnyEvent::log $level, $msg[, @args]"
Log tha given \f(CW$msg\fR all up in tha given \f(CW$level\fR.
.Sp
If AnyEvent::Log aint loaded then dis function cook up a simple test
to peep whether tha message is ghon be logged. Y'all KNOW dat shit, muthafucka! If tha test succeedz it will
load AnyEvent::Log n' call \f(CW\*(C`AnyEvent::Log::log\*(C'\fR \- consequently, peep
the AnyEvent::Log documentation fo' details.
.Sp
If tha test fails it will simply return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Right now dis happens when a
numerical loglevel is used n' it is larger than tha level specified via
\&\f(CW$ENV{PERL_ANYEVENT_VERBOSE}\fR.
.Sp
If you wanna sprinkle loadz of loggin calls round yo' code, consider
bustin a logger callback wit tha \f(CW\*(C`AnyEvent::Log::logger\*(C'\fR function,
which can reduce typing, codesize n' can reduce tha loggin overhead
enourmously.
.SH "WHAT TO DO IN A MODULE"
.IX Header "WHAT TO DO IN A MODULE"
As a module lyricist, you should \f(CW\*(C`use AnyEvent\*(C'\fR n' call AnyEvent methods
freely yo, but you should not load a specific event module or rely on dat shit.
.PP
Be careful when you create watchers up in tha module body \- AnyEvent will
decizzle which event module ta use as soon as tha straight-up original gangsta method is called, so
by callin AnyEvent up in yo' module body you force tha user of yo' module
to load tha event module first.
.PP
Never call \f(CW\*(C`\->recv\*(C'\fR on a cold-ass lil condizzle variable unless you \fIknow\fR that
the \f(CW\*(C`\->send\*(C'\fR method has been called on it already. This is
because it will stall tha whole program, n' tha whole point of using
events is ta stay interactive.
.PP
It be fine, however, ta booty-call \f(CW\*(C`\->recv\*(C'\fR when tha user of yo' module
requests it (i.e. if you create a http request object ad gotz a method
called \f(CW\*(C`results\*(C'\fR dat returns tha thangs up in dis biatch, it may call \f(CW\*(C`\->recv\*(C'\fR
freely, as tha user of yo' module knows what tha fuck her ass is bustin fo' realz. Always).
.SH "WHAT TO DO IN THE MAIN PROGRAM"
.IX Header "WHAT TO DO IN THE MAIN PROGRAM"
There will always be a single main program \- tha only place dat should
dictate which event model ta use.
.PP
If tha program aint event-based, it need not do anythang special, even
when it dependz on a module dat uses a AnyEvent. If tha program itself
uses AnyEvent yo, but do not care which event loop is used, all it needs
to do is \f(CW\*(C`use AnyEvent\*(C'\fR. In either case, AnyEvent will chizzle tha best
available loop implementation.
.PP
If tha main program relies on a specific event model \- fo' example, in
Gtk2 programs you gotta rely on tha Glib module \- you should load the
event module before loadin AnyEvent or any module dat uses it: generally
speaking, you should load it as early as possible. Da reason is that
modulez might create watchers when they is loaded, n' AnyEvent will
decizzle on tha event model ta use as soon as it creates watchers, n' it
might chizzle tha wack one unless you load tha erect one yo ass.
.PP
Yo ass can chose ta bust a pure-perl implementation by loadin the
\&\f(CW\*(C`AnyEvent::Loop\*(C'\fR module, which gives you similar behaviour
everywhere yo, but lettin AnyEvent chose tha model is generally better.
.SS "\s-1MAINLOOP EMULATION\s0"
.IX Subsection "MAINLOOP EMULATION"
Sometimes (often fo' short test scripts, or even standalone programs who
only wanna use AnyEvent), you do not wanna run a specific event loop.
.PP
In dat case, you can bust a cold-ass lil condizzle variable like this:
.PP
.Vb 1
\&   AnyEvent\->condvar\->recv;
.Ve
.PP
This has tha effect of enterin tha event loop n' loopin alllll muthafuckin day.
.PP
Note dat probably yo' program has some exit condition, up in which case
it is betta ta use tha \*(L"traditional\*(R" approach of storin a cold-ass lil condition
variable somewhere, waitin fo' it, n' bustin  it when tha program should
exit cleanly.
.SH "OTHER MODULES"
.IX Header "OTHER MODULES"
Da followin be a non-exhaustizzle list of additionizzle modulez dat use
AnyEvent as a cold-ass lil client n' can therefore be mixed easily wit other
AnyEvent modulez n' other event loops up in tha same program. Right back up in yo muthafuckin ass. Some of the
modulez come as part of AnyEvent, tha others is available via \s-1CPAN \s0(see
<http://search.cpan.org/search?m=module&q=anyevent%3A%3A*> for
a longer non-exhaustizzle list), n' tha list is heavily biased towards
modulez of tha AnyEvent lyricist his dirty ass :)
.IP "AnyEvent::Util (part of tha AnyEvent distribution)" 4
.IX Item "AnyEvent::Util (part of tha AnyEvent distribution)"
Gotz Nuff various utilitizzle functions dat replace often-used blocking
functions like fuckin \f(CW\*(C`inet_aton\*(C'\fR wit event/callback\-based versions.
.IP "AnyEvent::Socket (part of tha AnyEvent distribution)" 4
.IX Item "AnyEvent::Socket (part of tha AnyEvent distribution)"
Provides various utilitizzle functions fo' (internizzle protocol) sockets,
addresses n' name resolution. I aint talkin' bout chicken n' gravy biatch fo' realz. Also functions ta create non-blockin tcp
connections or tcp servers, wit IPv6 n' \s-1SRV\s0 record support n' more.
.IP "AnyEvent::Handle (part of tha AnyEvent distribution)" 4
.IX Item "AnyEvent::Handle (part of tha AnyEvent distribution)"
Provide read n' write buffers, manages watchers fo' readz n' writes,
supports raw n' formatted I/O, I/O queued n' straight-up transparent and
non-blockin \s-1SSL/TLS \s0(via AnyEvent::TLS).
.IP "AnyEvent::DNS (part of tha AnyEvent distribution)" 4
.IX Item "AnyEvent::DNS (part of tha AnyEvent distribution)"
Provides rich asynchronous \s-1DNS\s0 resolver capabilities.
.IP "AnyEvent::HTTP, AnyEvent::IRC, AnyEvent::XMPP, AnyEvent::GPSD, AnyEvent::IGS, AnyEvent::FCP" 4
.IX Item "AnyEvent::HTTP, AnyEvent::IRC, AnyEvent::XMPP, AnyEvent::GPSD, AnyEvent::IGS, AnyEvent::FCP"
Implement event-based intercourses ta tha protocolz of tha same name (for
the curious, \s-1IGS\s0 is tha Internationistic Go Server n' \s-1FCP\s0 is tha Freenet
Client Protocol).
.IP "AnyEvent::AIO (part of tha AnyEvent distribution)" 4
.IX Item "AnyEvent::AIO (part of tha AnyEvent distribution)"
Truly asynchronous (as opposed ta non-blocking) I/O, should be up in the
toolbox of every last muthafuckin event programmer n' shiznit fo' realz. AnyEvent::AIO transparently fuses
\&\s-1IO::AIO\s0 n' AnyEvent together, givin AnyEvent access ta event-based
file I/O, n' much more.
.IP "AnyEvent::Filesys::Notify" 4
.IX Item "AnyEvent::Filesys::Notify"
AnyEvent is phat fo' non-blockin shiznit yo, but it can't detect file or
path chizzlez (e.g. \*(L"watch dis directory fo' freshly smoked up files\*(R", \*(L"watch this
file fo' chizzles\*(R"). Da AnyEvent::Filesys::Notify module promises to
do just dat up in a portbale fashion, supportin inotify on GNU/Linux and
some weird, without doubt broken, shiznit on \s-1OS X\s0 ta monitor files. Well shiiiit, it can
fall back ta blockin scans at regular intervals transparently on other
platforms, so itz bout as portable as it gets.
.Sp
(I aint used it mah dirty ass yo, but I aint heard anybody complainin about
it yet).
.IP "AnyEvent::DBI" 4
.IX Item "AnyEvent::DBI"
Executes \s-1DBI\s0 requests asynchronously up in a proxy process fo' you,
notifyin you up in a event-based way when tha operation is finished.
.IP "AnyEvent::HTTPD" 4
.IX Item "AnyEvent::HTTPD"
A simple embedded webserver.
.IP "AnyEvent::FastPing" 4
.IX Item "AnyEvent::FastPing"
Da fastest pin up in tha westside.
.IP "Coro" 4
.IX Item "Coro"
Has special support fo' AnyEvent via Coro::AnyEvent, which allows you
to simply invert tha flow control \- don't call us, we will call you:
.Sp
.Vb 3
\&   async {
\&      Coro::AnyEvent::sleep 5; # creates a 5s timer n' waits fo' it
\&      print "5 secondz later!\en";
\&
\&      Coro::AnyEvent::readable *STDIN; # uses a I/O watcher
\&      mah $line = <STDIN>; # works fo' ttys
\&
\&      AnyEvent::HTTP::http_get "url", Coro::rouse_cb;
\&      mah ($body, $hdr) = Coro::rouse_wait;
\&   };
.Ve
.SH "SIMPLIFIED AE API"
.IX Header "SIMPLIFIED AE API"
Startin wit version 5.0, AnyEvent officially supports a second, much
simpler, \s-1API\s0 dat is designed ta reduce tha calling, typin n' memory
overhead by rockin function call syntax n' a gangbangin' fixed number of parameters.
.PP
See tha \s-1AE\s0 manpage fo' details.
.SH "ERROR AND EXCEPTION HANDLING"
.IX Header "ERROR AND EXCEPTION HANDLING"
In general, AnyEvent do not do any error handlin \- it relies on the
calla ta do dat if required. Y'all KNOW dat shit, muthafucka! Da AnyEvent::Strict module (see also
the \f(CW\*(C`PERL_ANYEVENT_STRICT\*(C'\fR environment variable, below) serves up strict
checkin of all AnyEvent methods, however, which is highly useful during
development.
.PP
As fo' exception handlin (i.e. runtime errors n' exceptions thrown while
executin a cold-ass lil callback), dis aint only highly event-loop specific yo, but
also not up in any way wrapped by dis module, as dis is tha thang of tha main
program.
.PP
Da pure perl event loop simply re-throws tha exception (usually
within \f(CW\*(C`condvar\->recv\*(C'\fR), tha Event n' \s-1EV\s0 modulez call \f(CW\*(C`$Event/EV::DIED\->()\*(C'\fR, Glib uses \f(CW\*(C`install_exception_handlez\*(C'\fR and
so on.
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
AnyEvent supports a fuckin shitload of environment variablez dat tune the
runtime behaviour. Shiiit, dis aint no joke. They is probably evaluated when AnyEvent is
loaded, initialised, or a submodule dat uses dem is loaded. Y'all KNOW dat shit, muthafucka! Many of
them also cause AnyEvent ta load additionizzle modulez \- fo' example,
\&\f(CW\*(C`PERL_ANYEVENT_DEBUG_WRAP\*(C'\fR causes tha AnyEvent::Debug module ta be
loaded.
.PP
All tha environment variablez documented here start with
\&\f(CW\*(C`PERL_ANYEVENT_\*(C'\fR, which is what tha fuck AnyEvent considaz its own
namespace. Other modulez is encouraged (but by no means required) ta use
\&\f(CW\*(C`PERL_ANYEVENT_SUBMODULE\*(C'\fR if they have registered tha AnyEvent::Submodule
namespace on \s-1CPAN,\s0 fo' any submodule. For example, AnyEvent::HTTP could
be sposed ta fuckin use \f(CW\*(C`PERL_ANYEVENT_HTTP_PROXY\*(C'\fR (it should not access env
variablez startin wit \f(CW\*(C`AE_\*(C'\fR, peep below).
.PP
All variablez can also be set via tha \f(CW\*(C`AE_\*(C'\fR prefix, dat is, instead
of settin \f(CW\*(C`PERL_ANYEVENT_VERBOSE\*(C'\fR you can also set \f(CW\*(C`AE_VERBOSE\*(C'\fR. In
case there be a cold-ass lil clash btween anyevent n' another program dat uses
\&\f(CW\*(C`AE_something\*(C'\fR you can set tha correspondin \f(CW\*(C`PERL_ANYEVENT_something\*(C'\fR
variable ta tha empty string, as dem variablez take precedence.
.PP
When AnyEvent is first loaded, it copies all \f(CW\*(C`AE_xxx\*(C'\fR env variables
to they \f(CW\*(C`PERL_ANYEVENT_xxx\*(C'\fR counterpart unless dat variable already
exists, n' you can put dat on yo' toast. If taint mode is on, then AnyEvent will remove \fIall\fR environment
variablez startin wit \f(CW\*(C`PERL_ANYEVENT_\*(C'\fR from \f(CW%ENV\fR (or replace them
with \f(CW\*(C`undef\*(C'\fR or tha empty string, if tha corresapondin \f(CW\*(C`AE_\*(C'\fR variable
is set).
.PP
Da exact algorithm is currently:
.PP
.Vb 3
\&   1. if taint mode enabled, delete all PERL_ANYEVENT_xyz variablez from %ENV
\&   2. copy over AE_xyz ta PERL_ANYEVENT_xyz unless tha latta alraedy exists
\&   3. if taint mode enabled, set all PERL_ANYEVENT_xyz variablez ta undef.
.Ve
.PP
This ensures dat lil pimp processes aint gonna peep tha \f(CW\*(C`AE_\*(C'\fR variables.
.PP
Da followin environment variablez is currently known ta AnyEvent:
.ie n .IP """PERL_ANYEVENT_VERBOSE""" 4
.el .IP "\f(CWPERL_ANYEVENT_VERBOSE\fR" 4
.IX Item "PERL_ANYEVENT_VERBOSE"
By default, AnyEvent will log lyrics wit loglevel \f(CW4\fR (\f(CW\*(C`error\*(C'\fR) or
higher (see AnyEvent::Log). Yo ass can set dis environment variable ta a
numerical loglevel ta make AnyEvent mo' (or less) talkative.
.Sp
If you wanna do mo' than just set tha global loggin level
you should gotz a peep \f(CW\*(C`PERL_ANYEVENT_LOG\*(C'\fR, which allows much more
complex justifications.
.Sp
When set ta \f(CW0\fR (\f(CW\*(C`off\*(C'\fR), then no lyrics whatsoever is ghon be logged with
everythang else at defaults.
.Sp
When set ta \f(CW5\fR or higher (\f(CW\*(C`warn\*(C'\fR), AnyEvent warns bout unexpected
conditions, like fuckin not bein able ta load tha event model specified by
\&\f(CW\*(C`PERL_ANYEVENT_MODEL\*(C'\fR, or a guard callback throwin a exception \- this
is tha minimum recommended level fo' use durin pimpment.
.Sp
When set ta \f(CW7\fR or higher (info), AnyEvent reports which event model it
chooses.
.Sp
When set ta \f(CW8\fR or higher (debug), then AnyEvent will report extra
information on which optionizzle modulez it loadz n' how tha fuck it implements
certain features.
.ie n .IP """PERL_ANYEVENT_LOG""" 4
.el .IP "\f(CWPERL_ANYEVENT_LOG\fR" 4
.IX Item "PERL_ANYEVENT_LOG"
Accepts rather complex loggin justifications. For example, you could log
all \f(CW\*(C`debug\*(C'\fR lyrics of some module ta stderr, warnings n' above to
stderr, n' errors n' above ta syslog, with:
.Sp
.Vb 1
\&   PERL_ANYEVENT_LOG=Some::Module=debug,+log:filter=warn,+%syslog:%syslog=error,syslog
.Ve
.Sp
For tha rather extensive details, peep AnyEvent::Log.
.Sp
This variable is evaluated when AnyEvent (or AnyEvent::Log) is loaded,
so will take effect even before AnyEvent has initialised itself.
.Sp
Note dat specifyin dis environment variable causes tha AnyEvent::Log
module ta be loaded, while \f(CW\*(C`PERL_ANYEVENT_VERBOSE\*(C'\fR do not, so only
usin tha latta saves all dem hundred kB of memory unless a module
explicitly needz tha extra featurez of AnyEvent::Log.
.ie n .IP """PERL_ANYEVENT_STRICT""" 4
.el .IP "\f(CWPERL_ANYEVENT_STRICT\fR" 4
.IX Item "PERL_ANYEVENT_STRICT"
AnyEvent do not do much argument checkin by default, as thorough
argument checkin is straight-up costly. Right back up in yo muthafuckin ass. Settin dis variable ta a legit value
will cause AnyEvent ta load \f(CW\*(C`AnyEvent::Strict\*(C'\fR n' then ta thoroughly
check tha arguments passed ta most method calls. If it findz any problems,
it will croak.
.Sp
In other lyrics, enablez \*(L"strict\*(R" mode.
.Sp
Unlike \f(CW\*(C`use strict\*(C'\fR (or its modern cousin, \f(CW\*(C`use common::sense\*(C'\fR, it is definitely recommended ta keep it off up in thang. I aint talkin' bout chicken n' gravy biatch. Keeping
\&\f(CW\*(C`PERL_ANYEVENT_STRICT=1\*(C'\fR up in yo' environment while pimpin programs
can be straight-up useful, however.
.ie n .IP """PERL_ANYEVENT_DEBUG_SHELL""" 4
.el .IP "\f(CWPERL_ANYEVENT_DEBUG_SHELL\fR" 4
.IX Item "PERL_ANYEVENT_DEBUG_SHELL"
If dis env variable is nonempty, then its contents is ghon be interpreted by
\&\f(CW\*(C`AnyEvent::Socket::parse_hostport\*(C'\fR n' \f(CW\*(C`AnyEvent::Debug::shell\*(C'\fR (after
replacin every last muthafuckin occurizzle of \f(CW$$\fR by tha process pid). Da shell object
is saved up in \f(CW$AnyEvent::Debug::SHELL\fR.
.Sp
This happens when tha straight-up original gangsta watcher is pimped.
.Sp
For example, ta bind a thugged-out debug shell on a unix domain socket in
\&\fI/tmp/debug<pid>.sock\fR, you could use this:
.Sp
.Vb 2
\&   PERL_ANYEVENT_DEBUG_SHELL=/tmp/debug\e$\e$.sock perlprog
\&   # hook tha fuck up wit e.g.: socat readline /tmp/debug123.sock
.Ve
.Sp
Or ta bind ta tcp port 4545 on localhost:
.Sp
.Vb 2
\&   PERL_ANYEVENT_DEBUG_SHELL=127.0.0.1:4545 perlprog
\&   # hook tha fuck up wit e.g.: telnet localhost 4545
.Ve
.Sp
Note dat bustin sockets up in \fI/tmp\fR or on localhost is straight-up unsafe on
multiuser systems.
.ie n .IP """PERL_ANYEVENT_DEBUG_WRAP""" 4
.el .IP "\f(CWPERL_ANYEVENT_DEBUG_WRAP\fR" 4
.IX Item "PERL_ANYEVENT_DEBUG_WRAP"
Can be set ta \f(CW0\fR, \f(CW1\fR or \f(CW2\fR n' enablez wrappin of all watchers for
debuggin purposes. Right back up in yo muthafuckin ass. See \f(CW\*(C`AnyEvent::Debug::wrap\*(C'\fR fo' details.
.ie n .IP """PERL_ANYEVENT_MODEL""" 4
.el .IP "\f(CWPERL_ANYEVENT_MODEL\fR" 4
.IX Item "PERL_ANYEVENT_MODEL"
This can be used ta specify tha event model ta be used by AnyEvent, before
auto detection n' \-probin kicks in.
.Sp
It normally be a strang consistin entirely of \s-1ASCII\s0 lettas (e.g. \f(CW\*(C`EV\*(C'\fR
or \f(CW\*(C`IOAsync\*(C'\fR). Da strang \f(CW\*(C`AnyEvent::Impl::\*(C'\fR gets prepended n' the
resultin module name is loaded n' \- if tha load was successful \- used as
event model backend yo, but it ain't no stoppin cause I be still poppin'. If it fails ta load then AnyEvent will proceed with
auto detection n' \-probing.
.Sp
If tha strang endz wit \f(CW\*(C`::\*(C'\fR instead (e.g. \f(CW\*(C`AnyEvent::Impl::EV::\*(C'\fR) then
nothang gets prepended n' tha module name is used as-is (hint: \f(CW\*(C`::\*(C'\fR at
the end of a strang designates a module name n' quotes it appropriately).
.Sp
For example, ta force tha pure perl model (AnyEvent::Loop::Perl) you
could start yo' program like this:
.Sp
.Vb 1
\&   PERL_ANYEVENT_MODEL=Perl perl ...
.Ve
.ie n .IP """PERL_ANYEVENT_IO_MODEL""" 4
.el .IP "\f(CWPERL_ANYEVENT_IO_MODEL\fR" 4
.IX Item "PERL_ANYEVENT_IO_MODEL"
Da current file I/O model \- peep AnyEvent::IO fo' mo' info.
.Sp
At tha moment, only \f(CW\*(C`Perl\*(C'\fR (small, pure-perl, synchronous) and
\&\f(CW\*(C`IOAIO\*(C'\fR (truly asynchronous) is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da default is \f(CW\*(C`IOAIO\*(C'\fR if
AnyEvent::AIO can be loaded, otherwise it is \f(CW\*(C`Perl\*(C'\fR.
.ie n .IP """PERL_ANYEVENT_PROTOCOLS""" 4
.el .IP "\f(CWPERL_ANYEVENT_PROTOCOLS\fR" 4
.IX Item "PERL_ANYEVENT_PROTOCOLS"
Used by both AnyEvent::DNS n' AnyEvent::Socket ta determine preferences
for IPv4 or IPv6. Da default is unspecified (and might chizzle, or be tha result
of auto probing).
.Sp
Must be set ta a cold-ass lil comma-separated list of protocols or address crews,
current supported: \f(CW\*(C`ipv4\*(C'\fR n' \f(CW\*(C`ipv6\*(C'\fR. Only protocols mentioned will be
used, n' preference is ghon be given ta protocols mentioned earlier up in the
list.
.Sp
This variable can effectively be used fo' denial-of-service attacks
against local programs (e.g. when setuid), although tha impact is likely
small, as tha program has ta handle conenction n' other failures anyways.
.Sp
Examples: \f(CW\*(C`PERL_ANYEVENT_PROTOCOLS=ipv4,ipv6\*(C'\fR \- prefer IPv4 over IPv6,
but support both n' try ta use both.  \f(CW\*(C`PERL_ANYEVENT_PROTOCOLS=ipv4\*(C'\fR
\&\- only support IPv4, never try ta resolve or contact IPv6
addresses. \f(CW\*(C`PERL_ANYEVENT_PROTOCOLS=ipv6,ipv4\*(C'\fR support either IPv4 or
IPv6 yo, but prefer IPv6 over IPv4.
.ie n .IP """PERL_ANYEVENT_HOSTS""" 4
.el .IP "\f(CWPERL_ANYEVENT_HOSTS\fR" 4
.IX Item "PERL_ANYEVENT_HOSTS"
This variable, if specified, overrides tha \fI/etc/hosts\fR file used by
AnyEvent::Socket\f(CW\*(C`::resolve_sockaddr\*(C'\fR, i.e. hosts aliases is ghon be read
from dat file instead.
.ie n .IP """PERL_ANYEVENT_EDNS0""" 4
.el .IP "\f(CWPERL_ANYEVENT_EDNS0\fR" 4
.IX Item "PERL_ANYEVENT_EDNS0"
Used by AnyEvent::DNS ta decizzle whether ta use tha \s-1EDNS0\s0 extension for
\&\s-1DNS.\s0 This extension is generally useful ta reduce \s-1DNS\s0 traffic, especially
when \s-1DNSSEC\s0 is involved yo, but some (broken) firewalls drop such \s-1DNS\s0
packets, which is why it is off by default.
.Sp
Settin dis variable ta \f(CW1\fR will cause AnyEvent::DNS ta announce
\&\s-1EDNS0\s0 up in its \s-1DNS\s0 requests.
.ie n .IP """PERL_ANYEVENT_MAX_FORKS""" 4
.el .IP "\f(CWPERL_ANYEVENT_MAX_FORKS\fR" 4
.IX Item "PERL_ANYEVENT_MAX_FORKS"
Da maximum number of lil pimp processes dat \f(CW\*(C`AnyEvent::Util::fork_call\*(C'\fR
will create up in parallel.
.ie n .IP """PERL_ANYEVENT_MAX_OUTSTANDING_DNS""" 4
.el .IP "\f(CWPERL_ANYEVENT_MAX_OUTSTANDING_DNS\fR" 4
.IX Item "PERL_ANYEVENT_MAX_OUTSTANDING_DNS"
Da default value fo' tha \f(CW\*(C`max_outstanding\*(C'\fR parameta fo' tha default \s-1DNS\s0
resolver \- dis is tha maximum number of parallel \s-1DNS\s0 requests dat are
sent ta tha \s-1DNS\s0 server.
.ie n .IP """PERL_ANYEVENT_MAX_SIGNAL_LATENCY""" 4
.el .IP "\f(CWPERL_ANYEVENT_MAX_SIGNAL_LATENCY\fR" 4
.IX Item "PERL_ANYEVENT_MAX_SIGNAL_LATENCY"
Perl has inherently racy signal handlin (you can basically chizzle between
losin signals n' memory corruption) \- pure perl event loops (including
\&\f(CW\*(C`AnyEvent::Loop\*(C'\fR, when \f(CW\*(C`Async::Interrupt\*(C'\fR aint available) therefore
have ta poll regularly ta avoid losin signals.
.Sp
Some event loops is racy yo, but don't poll regularly, n' some event loops
are freestyled up in C but is still racy. For dem event loops, AnyEvent
installs a timer dat regularly wakes up tha event loop.
.Sp
By default, tha interval fo' dis timer is \f(CW10\fR secondz yo, but you can
override dis delay wit dis environment variable (or by setting
the \f(CW$AnyEvent::MAX_SIGNAL_LATENCY\fR variable before bustin signal
watchers).
.Sp
Lower joints increase \s-1CPU \s0(and juice) usage, higher joints can introduce
long delays when reapin lil pimps or waitin fo' signals.
.Sp
Da AnyEvent::Async module, if available, is ghon be used ta avoid this
pollin (with most event loops).
.ie n .IP """PERL_ANYEVENT_RESOLV_CONF""" 4
.el .IP "\f(CWPERL_ANYEVENT_RESOLV_CONF\fR" 4
.IX Item "PERL_ANYEVENT_RESOLV_CONF"
Da absolute path ta a \fIresolv.conf\fR\-style file ta use instead of
\&\fI/etc/resolv.conf\fR (or tha OS-specific configuration) up in tha default
resolver, or tha empty strang ta select tha default configuration.
.ie n .IP """PERL_ANYEVENT_CA_FILE"", ""PERL_ANYEVENT_CA_PATH""." 4
.el .IP "\f(CWPERL_ANYEVENT_CA_FILE\fR, \f(CWPERL_ANYEVENT_CA_PATH\fR." 4
.IX Item "PERL_ANYEVENT_CA_FILE, PERL_ANYEVENT_CA_PATH."
When neither \f(CW\*(C`ca_file\*(C'\fR nor \f(CW\*(C`ca_path\*(C'\fR was specified during
AnyEvent::TLS context creation, n' either of these environment
variablez is nonempty, they is ghon be used ta specify \s-1CA\s0 certificate
locations instead of a system-dependent default.
.ie n .IP """PERL_ANYEVENT_AVOID_GUARD"" n' ""PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT""" 4
.el .IP "\f(CWPERL_ANYEVENT_AVOID_GUARD\fR n' \f(CWPERL_ANYEVENT_AVOID_ASYNC_INTERRUPT\fR" 4
.IX Item "PERL_ANYEVENT_AVOID_GUARD n' PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT"
When these is set ta \f(CW1\fR, then tha respectizzle modulez is not
loaded. Y'all KNOW dat shit, muthafucka! Mostly phat fo' testin AnyEvent itself.
.SH "SUPPLYING YOUR OWN EVENT MODEL INTERFACE"
.IX Header "SUPPLYING YOUR OWN EVENT MODEL INTERFACE"
This be a advanced topic dat you do not normally need ta use AnyEvent in
a module. This section is only of use ta event loop authors whoz ass want to
provide AnyEvent compatibility.
.PP
If you need ta support another event library which aint directly
supported by AnyEvent, you can supply yo' own intercourse ta it by
pushing, before tha straight-up original gangsta watcher gets pimped, tha package name of
the event module n' tha package name of tha intercourse ta use onto
\&\f(CW@AnyEvent::REGISTRY\fR. Yo ass can do dat before n' even without loading
AnyEvent, so it is reasonably skanky.
.PP
Example:
.PP
.Vb 1
\&   push @AnyEvent::REGISTRY, [urxvt => urxvt::anyevent::];
.Ve
.PP
This  drops some lyrics ta AnyEvent ta (literally) use tha \f(CW\*(C`urxvt::anyevent::\*(C'\fR
package/class when it findz tha \f(CW\*(C`urxvt\*(C'\fR package/module be already loaded.
.PP
When AnyEvent is loaded n' axed ta find a suitable event model, it
will first check fo' tha presence of urxvt by tryin ta \f(CW\*(C`use\*(C'\fR the
\&\f(CW\*(C`urxvt::anyevent\*(C'\fR module.
.PP
Da class should provide implementations fo' all watcher types. Right back up in yo muthafuckin ass. See
AnyEvent::Impl::EV (source code), AnyEvent::Impl::Glib (Source code)
and so on fo' actual examples. Use \f(CW\*(C`perldoc \-m AnyEvent::Impl::Glib\*(C'\fR to
see tha sources.
.PP
If you don't provide \f(CW\*(C`signal\*(C'\fR n' \f(CW\*(C`child\*(C'\fR watchers than AnyEvent will
provide suitable (hopefully) replacements.
.PP
Da above example aint fictitious, tha \fIrxvt-unicode\fR (a.k.a. urxvt)
terminal emulator uses tha above line as-is fo' realz. An intercourse aint included
in AnyEvent cuz it don't make sense outside tha embedded interpreter
inside \fIrxvt-unicode\fR, n' it is updated n' maintained as part of the
\&\fIrxvt-unicode\fR distribution.
.PP
\&\fIrxvt-unicode\fR also cheats a lil' bit by not providin blockin access to
condizzle variables: code blockin while waitin fo' a cold-ass lil condizzle will
\&\f(CW\*(C`die\*(C'\fR. This still works wit most modules/usages, n' blockin calls must
not be done up in a interactizzle application, so it make sense.
.SH "EXAMPLE PROGRAM"
.IX Header "EXAMPLE PROGRAM"
Da followin program uses a I/O watcher ta read data from \s-1STDIN,\s0 a timer
to display a message once per second, n' a cold-ass lil condizzle variable ta quit the
program when tha user entas quit:
.PP
.Vb 1
\&   use AnyEvent;
\&
\&   mah $cv = AnyEvent\->condvar;
\&
\&   mah $io_watcher = AnyEvent\->io (
\&      fh   => \e*STDIN,
\&      poll => \*(Aqr\*(Aq,
\&      cb   => sub {
\&         warn "io event <$_[0]>\en";   # will always output <r>
\&         chomp (my $input = <STDIN>); # read a line
\&         warn "read: $input\en";       # output what tha fuck has been read
\&         $cv\->send if $input =~ /^q/i; # quit program if /^q/i
\&      },
\&   );
\&
\&   mah $time_watcher = AnyEvent\->timer (afta => 1, interval => 1, cb => sub {
\&      warn "timeout\en"; # print \*(Aqtimeout\*(Aq at most every last muthafuckin second
\&   });
\&
\&   $cv\->recv; # wait until user entas /^q/i
.Ve
.SH "REAL-WORLD EXAMPLE"
.IX Header "REAL-WORLD EXAMPLE"
Consider tha Net::FCP module. Well shiiiit, it features (among others) tha following
\&\s-1API\s0 calls, which is ta freenet what tha fuck \s-1HTTP GET\s0 requests is ta http:
.PP
.Vb 1
\&   mah $data = $fcp\->client_get ($url); # blocks
\&
\&   mah $transaction = $fcp\->txn_client_get ($url); # do not block
\&   $transaction\->cb ( sub { ... } ); # set optionizzle result callback
\&   mah $data = $transaction\->result; # possibly blocks
.Ve
.PP
Da \f(CW\*(C`client_get\*(C'\fR method works like \f(CW\*(C`LWP::Simple::get\*(C'\fR: it requests the
given \s-1URL\s0 n' waits till tha data has arrived. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is defined ta be:
.PP
.Vb 1
\&   sub client_get { $_[0]\->txn_client_get ($_[1])\->result }
.Ve
.PP
And up in fact be automatically generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This is tha blockin \s-1API\s0 of
Net::FCP, n' it works as simple as up in any other, similar, module.
.PP
Mo' fucked up is \f(CW\*(C`txn_client_get\*(C'\fR: It only creates a transaction
(completion, result, ...) object n' initiates tha transaction.
.PP
.Vb 1
\&   mah $txn = bless { }, Net::FCP::Txn::;
.Ve
.PP
It also creates a cold-ass lil condizzle variable dat is used ta signal tha completion
of tha request:
.PP
.Vb 1
\&   $txn\->{finished} = AnyAvent\->condvar;
.Ve
.PP
It then creates a socket up in non-blockin mode.
.PP
.Vb 6
\&   socket $txn\->{fh}, ...;
\&   fcntl $txn\->{fh}, F_SETFL, O_NONBLOCK;
\&   connect $txn\->{fh}, ...
\&      n' !$!{EWOULDBLOCK}
\&      n' !$!{EINPROGRESS}
\&      n' Carp::croak "unable ta connect: $!\en";
.Ve
.PP
Then it creates a write-watcher which gets called whenever a error occurs
or tha connection succeeds:
.PP
.Vb 1
\&   $txn\->{w} = AnyEvent\->io (fh => $txn\->{fh}, poll => \*(Aqw\*(Aq, cb => sub { $txn\->fh_ready_w });
.Ve
.PP
And returns dis transaction object. Da \f(CW\*(C`fh_ready_w\*(C'\fR callback gets
called as soon as tha event loop detects dat tha socket is locked n loaded for
writing.
.PP
Da \f(CW\*(C`fh_ready_w\*(C'\fR method make tha socket blockin again, writes the
request data n' replaces tha watcher by a read watcher (waitin fo' reply
data). Da actual code is mo' fucked up yo, but dat don't matta for
this example:
.PP
.Vb 4
\&   fcntl $txn\->{fh}, F_SETFL, 0;
\&   syswrite $txn\->{fh}, $txn\->{request}
\&      or take a thugged-out dirtnap "connection or write error";
\&   $txn\->{w} = AnyEvent\->io (fh => $txn\->{fh}, poll => \*(Aqr\*(Aq, cb => sub { $txn\->fh_ready_r });
.Ve
.PP
Again, \f(CW\*(C`fh_ready_r\*(C'\fR waits till all data has arrived, n' then stores the
result n' signals any possible waitas dat tha request has finished:
.PP
.Vb 1
\&   sysread $txn\->{fh}, $txn\->{buf}, length $txn\->{$buf};
\&
\&   if (end\-of\-file or data complete) {
\&     $txn\->{result} = $txn\->{buf};
\&     $txn\->{finished}\->send;
\&     $txb\->{cb}\->($txn) of $txn\->{cb}; # also call callback
\&   }
.Ve
.PP
Da \f(CW\*(C`result\*(C'\fR method, finally, just waits fo' tha finished signal (if the
request was already finished, it don't wait, of course, n' returns the
data:
.PP
.Vb 2
\&   $txn\->{finished}\->recv;
\&   return $txn\->{result};
.Ve
.PP
Da actual code goes further n' collects all errors (\f(CW\*(C`die\*(C'\fRs, exceptions)
that occurred durin request processing. Da \f(CW\*(C`result\*(C'\fR method detects
whether a exception as thrown (it is stored inside tha \f(CW$txn\fR object)
and just throws tha exception, which means connection errors n' other
problems git reported ta tha code dat tries ta use tha result, not up in a
random callback.
.PP
All of dis enablez tha followin usage styles:
.PP
1. Blocking:
.PP
.Vb 1
\&   mah $data = $fcp\->client_get ($url);
.Ve
.PP
2. Blockin yo, but hustlin up in parallel:
.PP
.Vb 3
\&   mah @datas = map $_\->result,
\&                  map $fcp\->txn_client_get ($_),
\&                     @urls;
.Ve
.PP
Both blockin examplez work without tha module user havin ta know
anythang bout events.
.PP
3a. Event-based up in a main program, rockin any supported event module:
.PP
.Vb 1
\&   use EV;
\&
\&   $fcp\->txn_client_get ($url)\->cb (sub {
\&      mah $txn = shift;
\&      mah $data = $txn\->result;
\&      ...
\&   });
\&
\&   EV::loop;
.Ve
.PP
3b. Da module user could use AnyEvent, too:
.PP
.Vb 1
\&   use AnyEvent;
\&
\&   mah $quit = AnyEvent\->condvar;
\&
\&   $fcp\->txn_client_get ($url)\->cb (sub {
\&      ...
\&      $quit\->send;
\&   });
\&
\&   $quit\->recv;
.Ve
.SH "BENCHMARKS"
.IX Header "BENCHMARKS"
To hit you wit a scam of tha performizzle n' overheadz dat AnyEvent adds
over tha event loops theyselves n' ta hit you wit a impression of tha speed
of various event loops I prepared some benchmarks.
.SS "\s-1BENCHMARKING ANYEVENT OVERHEAD\s0"
.IX Subsection "BENCHMARKING ANYEVENT OVERHEAD"
Here be a funky-ass benchmark of various supported event models used natively and
all up in AnyEvent. Da benchmark creates a shitload of timers (with a zero
timeout) n' I/O watchers (watchin \s-1STDOUT,\s0 a pty, ta become writable,
which it is), lets dem fire exactly once n' destroys dem again.
.PP
Source code fo' dis benchmark is found as \fIeg/bench\fR up in tha AnyEvent
distribution. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it uses tha \s-1AE\s0 intercourse, which cook up a real difference
for tha \s-1EV\s0 n' Perl backendz only.
.PP
\fIExplanation of tha columns\fR
.IX Subsection "Explanation of tha columns"
.PP
\&\fIwatcher\fR is tha number of event watchers pimped/destroyed. Y'all KNOW dat shit, muthafucka! Since
different event models feature vastly different performances, each event
loop was given a fuckin shitload of watchers so dat overall runtime be acceptable
and similar between tested event loop (and keep dem from crashing): Glib
would probably take thousandz of muthafuckin years if axed ta process tha same ol' dirty number
of watchers as \s-1EV\s0 up in dis benchmark.
.PP
\&\fIbytes\fR is tha number of bytes (as measured by tha resident set size,
\&\s-1RSS\s0) consumed by each watcher n' shit. This method of measurin captures both C
and Perl-based overheads.
.PP
\&\fIcreate\fR is tha time, up in microsecondz (millionthz of seconds), dat it
takes ta create a single watcher n' shit. Da callback be a cold-ass lil closure shared between
all watchers, ta avoid addin memory overhead. Y'all KNOW dat shit, muthafucka! That means closure creation
and memory usage aint included up in tha figures.
.PP
\&\fIinvoke\fR is tha time, up in microseconds, used ta invoke a simple
callback. Da callback simply counts down a Perl variable n' afta it was
invoked \*(L"watcher\*(R" times, it would \f(CW\*(C`\->send\*(C'\fR a cold-ass lil condvar once to
signal tha end of dis phase.
.PP
\&\fIdestroy\fR is tha time, up in microseconds, dat it takes ta destroy a single
watcher.
.PP
\fIResults\fR
.IX Subsection "Results"
.PP
.Vb 10
\&          name watchers bytes create invoke destroy comment
\&         EV/EV   100000   223   0.47   0.43    0.27 EV natizzle intercourse
\&        EV/Any   100000   223   0.48   0.42    0.26 EV + AnyEvent watchers
\&  Coro::EV/Any   100000   223   0.47   0.42    0.26 coroutines + Coro::Signal
\&      Perl/Any   100000   431   2.70   0.74    0.92 pure perl implementation
\&   Event/Event    16000   516  31.16  31.84    0.82 Event natizzle intercourse
\&     Event/Any    16000  1203  42.61  34.79    1.80 Event + AnyEvent watchers
\&   IOAsync/Any    16000  1911  41.92  27.45   16.81 via IO::Async::Loop::IO_Poll
\&   IOAsync/Any    16000  1726  40.69  26.37   15.25 via IO::Async::Loop::Epoll
\&      Glib/Any    16000  1118  89.00  12.57   51.17 quadratic behaviour
\&        Tk/Any     2000  1346  20.96  10.75    8.00 SEGV wit >> 2000 watchers
\&       POE/Any     2000  6951 108.97 795.32   14.24 via POE::Loop::Event
\&       POE/Any     2000  6648  94.79 774.40  575.51 via POE::Loop::Select
.Ve
.PP
\fIRap\fR
.IX Subsection "Rap"
.PP
Da benchmark do \fInot\fR measure scalabilitizzle of tha event loop hella
well. For example, a select-based event loop (like fuckin tha pure perl one)
can never compete wit a event loop dat uses epoll when tha number of
file descriptors grows high. In dis benchmark, all events become locked n loaded at
the same time, so select/poll\-based implementations git a unnatural speed
boost.
.PP
Also, note dat tha number of watchers probably has a nonlinear effect on
overall speed, dat is, bustin twice as nuff watchers don't take twice
the time \- probably it takes longer n' shit. This puts event loops tested wit a
higher number of watchers at a gangbangin' finger-lickin' disadvantage.
.PP
To put tha range of thangs up in dis biatch tha fuck into perspective, consider dat on the
benchmark machine, handlin a event takes roughly 1600 \s-1CPU\s0 cyclez with
\&\s-1EV, 3100 CPU\s0 cyclez wit AnyEventz pure perl loop n' almost 3000000 \s-1CPU\s0
cyclez wit \s-1POE.\s0
.PP
\&\f(CW\*(C`EV\*(C'\fR is tha sole leader regardin speed n' memory use, which is both
maximal/minimal, respectively. When rockin tha \s-1AE\s0 \s-1API\s0 there is zero
overhead (when goin all up in tha AnyEvent \s-1API\s0 create be bout 5\-6 times
slower, wit other times bein equal, so still uses far less memory than
any other event loop n' is still fasta than Event natively).
.PP
Da pure perl implementation is hit up in all dem dope spots (both the
constant timeout n' tha use of a single fd hit optimisations up in tha perl
interpreta n' tha backend itself). Nevertheless dis shows dat it
addz straight-up lil overhead up in itself. Like any select-based backend its
performizzle becomes straight-up wack wit fuckin shitloadz of file descriptors (and few of
them active), of course yo, but dis was not subject of dis benchmark.
.PP
Da \f(CW\*(C`Event\*(C'\fR module has a relatively high setup n' callback invocation
cost yo, but overall scores up in on tha third place.
.PP
\&\f(CW\*(C`IO::Async\*(C'\fR performs admirably well, bout on par wit \f(CW\*(C`Event\*(C'\fR, even
when rockin its pure perl backend.
.PP
\&\f(CW\*(C`Glib\*(C'\fRz memory usage is like a lil' bit higher yo, but it features a
fasta callback invocation n' overall endz up in tha same class as
\&\f(CW\*(C`Event\*(C'\fR. But fuck dat shiznit yo, tha word on tha street is dat Glib scalez mad badly, doublin tha number of
watchers increases tha processin time by mo' than a gangbangin' factor of four,
makin it straight-up unusable when rockin larger numberz of watchers
(note dat only a single file descriptor was used up in tha benchmark, so
inefficienciez of \f(CW\*(C`poll\*(C'\fR do not account fo' this).
.PP
Da \f(CW\*(C`Tk\*(C'\fR adaptor works relatively well. Da fact dat it crashes with
more than 2000 watchers be a funky-ass big-ass setback, however, as erectnizz takes
precedence over speed. Y'all KNOW dat shit, muthafucka! Nevertheless, its performizzle is surprising, as the
file descriptor is \fIdup()\fRed fo' each watcher n' shit. This shows dat tha \fIdup()\fR
employed by some adaptors aint a funky-ass big-ass performizzle issue (it do incur a
hidden memory cost inside tha kernel which aint reflected up in tha figures
above).
.PP
\&\f(CW\*(C`POE\*(C'\fR, regardless of underlyin event loop (whether rockin its pure perl
select-based backend or tha Event module, tha POE-EV backend couldn't
be tested cuz it wasn't working) shows abysmal performizzle and
memory usage wit AnyEvent: Watchers use almost 30 times as much memory
as \s-1EV\s0 watchers, n' 10 times as much memory as Event (the high memory
requirements is caused by requirin a session fo' each watcher). Watcher
invocation speed be almost 900 times slower than wit AnyEventz pure perl
implementation.
.PP
Da design of tha \s-1POE\s0 adaptor class up in AnyEvent can not straight-up account
for tha performizzle issues, though, as session creation overhead is
small compared ta execution of tha state machine, which is coded pretty
optimally within AnyEvent::Impl::POE (and while dem hoes agrees that
usin multiple sessions aint a phat approach, especially regarding
memory usage, even tha lyricist of \s-1POE\s0 could not come up wit a gangbangin' faster
design).
.PP
\fISummary\fR
.IX Subsection "Summary"
.IP "\(bu" 4
Usin \s-1EV\s0 all up in AnyEvent is fasta than any other event loop
(even when used without AnyEvent) yo, but most event loops have acceptable
performizzle wit or without AnyEvent.
.IP "\(bu" 4
Da overhead AnyEvent addz is probably much smalla than tha overhead of
the actual event loop, only wit mad fast event loops like fuckin \s-1EV\s0
does AnyEvent add dope overhead.
.IP "\(bu" 4
Yo ass should avoid \s-1POE\s0 like tha plague if you want performizzle or
reasonable memory usage.
.SS "\s-1BENCHMARKING THE LARGE SERVER CASE\s0"
.IX Subsection "BENCHMARKING THE LARGE SERVER CASE"
This benchmark straight-up benchmarks tha event loop itself. Well shiiiit, it works by
bustin a fuckin shitload of \*(L"servers\*(R": each server consistz of a socket pair, a
timeout watcher dat gets reset on activitizzle (but never fires), n' a I/O
watcher waitin fo' input on one side of tha socket. Each time tha socket
watcher readz a funky-ass byte it will write dat byte ta a random other \*(L"server\*(R".
.PP
Da effect is dat there is ghon be a shitload of I/O watchers, only part of which
are actizzle at any one point (so there be a cold-ass lil constant number of active
fdz fo' each loop iteration yo, but which fdz these is is random). The
timeout is reset each time suttin' is read cuz dat reflects how
most timeouts work (and puts extra heat on tha event loops).
.PP
In dis benchmark, we use 10000 socket pairs (20000 sockets), of which 100
(1%) is active. This mirrors tha activitizzle of big-ass servers wit many
connections, most of which is idle at any one point up in time.
.PP
Source code fo' dis benchmark is found as \fIeg/bench2\fR up in tha AnyEvent
distribution. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it uses tha \s-1AE\s0 intercourse, which cook up a real difference
for tha \s-1EV\s0 n' Perl backendz only.
.PP
\fIExplanation of tha columns\fR
.IX Subsection "Explanation of tha columns"
.PP
\&\fIsockets\fR is tha number of sockets, n' twice tha number of \*(L"servers\*(R" (as
each server has a read n' write socket end).
.PP
\&\fIcreate\fR is tha time it takes ta create a socket pair (which is
nontrivial) n' two watchers: a I/O watcher n' a timeout watcher.
.PP
\&\fIrequest\fR, da most thugged-out blingin value, is tha time it takes ta handle a
single \*(L"request\*(R", dat is, readin tha token from tha pipe n' forwarding
it ta another server n' shit. This includes deletin tha oldschool timeout n' bustin
a freshly smoked up one dat moves tha timeout tha fuck into tha future.
.PP
\fIResults\fR
.IX Subsection "Results"
.PP
.Vb 8
\&     name sockets create  request 
\&       EV   20000  62.66     7.99 
\&     Perl   20000  68.32    32.64 
\&  IOAsync   20000 174.06   101.15 epoll
\&  IOAsync   20000 174.67   610.84 poll
\&    Event   20000 202.69   242.91 
\&     Glib   20000 557.01  1689.52 
\&      POE   20000 341.54 12086.32 uses POE::Loop::Event
.Ve
.PP
\fIRap\fR
.IX Subsection "Rap"
.PP
This benchmark \fIdoes\fR measure scalabilitizzle n' overall performizzle of the
particular event loop.
.PP
\&\s-1EV\s0 be again n' again n' again fastest. Right back up in yo muthafuckin ass. Since it is rockin epoll on mah system, tha setup time
is relatively high, though.
.PP
Perl surprisingly comes second. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is much fasta than tha C\-based event
loops Event n' Glib.
.PP
IO::Async performs straight-up well when rockin its epoll backend, n' still quite
phat compared ta Glib when rockin its pure perl backend.
.PP
Event suffers from high setup time as well (peep its code n' you will
understand why). Callback invocation also has a high overhead compared to
the \f(CW\*(C`$_\->() fo' ..\*(C'\fR\-style loop dat tha Perl event loop uses. Event
uses select or poll up in basically all documented configurations.
.PP
Glib is hit hard by its quadratic behaviour w.r.t. nuff watchers. It
clearly fails ta big-ass up wit nuff filehandlez or up in busy servers.
.PP
\&\s-1POE\s0 is still straight-up outta tha picture, takin over 1000 times as long
as \s-1EV,\s0 n' over 100 times as long as tha Perl implementation, even though
it uses a C\-based event loop up in dis case.
.PP
\fISummary\fR
.IX Subsection "Summary"
.IP "\(bu" 4
Da pure perl implementation performs mad well.
.IP "\(bu" 4
Avoid Glib or \s-1POE\s0 up in big-ass projects where performizzle matters.
.SS "\s-1BENCHMARKING SMALL SERVERS\s0"
.IX Subsection "BENCHMARKING SMALL SERVERS"
While event loops should scale (and select-based ones do not...) even to
pimpin' servers, most programs we (or I WHAT! straight-up write have only a gangbangin' few
I/O watchers.
.PP
In dis benchmark, I use tha same benchmark program as up in tha big-ass server
case yo, but it uses only eight \*(L"servers\*(R", of which three is actizzle at any
one time. This should reflect performizzle fo' a lil' small-ass server relatively
well.
.PP
Da columns is identical ta tha previous table.
.PP
\fIResults\fR
.IX Subsection "Results"
.PP
.Vb 6
\&    name sockets create request 
\&      EV      16  20.00    6.54 
\&    Perl      16  25.75   12.62 
\&   Event      16  81.27   35.86 
\&    Glib      16  32.63   15.48 
\&     POE      16 261.87  276.28 uses POE::Loop::Event
.Ve
.PP
\fIRap\fR
.IX Subsection "Rap"
.PP
Da benchmark tries ta test tha performizzle of a typical small
server n' shit. While knowin how tha fuck various event loops big-ass up is interesting, keep
in mind dat they overhead up in dis case is probably not as blingin, due
to tha lil' small-ass absolute number of watchers (that is, you need efficiency and
speed most when you have fuckin shitloadz of watchers, not when you only have all dem of
them).
.PP
\&\s-1EV\s0 be again n' again n' again fastest.
.PP
Perl again n' again n' again comes second. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is noticeably fasta than tha C\-based event
loops Event n' Glib, although tha difference is too lil' small-ass ta straight-up
matter.
.PP
\&\s-1POE\s0 also performs much betta up in dis case yo, but is is still far behind the
others.
.PP
\fISummary\fR
.IX Subsection "Summary"
.IP "\(bu" 4
C\-based event loops big-ass up straight-up well wit lil' small-ass number of
watchers, as tha pimpment overhead dominates.
.SS "\s-1THE\s0 IO::Lambda \s-1BENCHMARK\s0"
.IX Subsection "THE IO::Lambda BENCHMARK"
Recently I was holla'd at bout tha benchmark up in tha IO::Lambda manpage, which
could be misinterpreted ta make AnyEvent look bad. Y'all KNOW dat shit, muthafucka! In fact, tha benchmark
simply compares IO::Lambda wit \s-1POE,\s0 n' IO::Lambda looks betta (which
shouldn't come as a surprise ta anybody) fo' realz. As such, tha benchmark is
fine, n' mostly shows dat tha AnyEvent backend from IO::Lambda aint
very optimal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. But how tha fuck would AnyEvent compare when used without tha extra
baggage, biatch? To explore this, I freestyled tha equivalent benchmark fo' AnyEvent.
.PP
Da benchmark itself creates a echo-server, n' then, fo' 500 times,
connects ta tha echo server, sendz a line, waits fo' tha reply, n' then
creates tha next connection. I aint talkin' bout chicken n' gravy biatch. This be a rather wack benchmark, as it don't
test tha efficiency of tha framework or much non-blockin I/O yo, but it be a
benchmark nevertheless.
.PP
.Vb 9
\&   name                    runtime
\&   Lambda/select           0.330 sec
\&      + optimized          0.122 sec
\&   Lambda/AnyEvent         0.327 sec
\&      + optimized          0.138 sec
\&   Raw sockets/select      0.077 sec
\&   POE/select, components  0.662 sec
\&   POE/select, raw sockets 0.226 sec
\&   POE/select, optimized   0.404 sec
\&
\&   AnyEvent/select/nb      0.085 sec
\&   AnyEvent/EV/nb          0.068 sec
\&      +state machine       0.134 sec
.Ve
.PP
Da benchmark be also a lil' bit unfair (my fault): tha IO::Lambda/POE
benchmarks straight-up make blockin connects n' use 100% blockin I/O,
defeatin tha purpose of a event-based solution. I aint talkin' bout chicken n' gravy biatch fo' realz. All of tha newly
written AnyEvent benchmarks use 100% non-blockin connects (using
AnyEvent::Socket::tcp_connect n' tha asynchronous pure perl \s-1DNS\s0
resolver), so AnyEvent be at a gangbangin' finger-lickin' disadvantage here, as non-blockin connects
generally require a shitload mo' bookkeepin n' event handlin than blocking
connects (which involve a single syscall only).
.PP
Da last AnyEvent benchmark additionally uses AnyEvent::Handle, which
offers similar expressive juice as \s-1POE\s0 n' IO::Lambda, rockin conventional
Perl syntax. This means dat both tha echo server n' tha client is 100%
non-blocking, further placin it at a gangbangin' finger-lickin' disadvantage.
.PP
As you can see, tha AnyEvent + \s-1EV\s0 combination even beats the
hand-optimised \*(L"raw sockets benchmark\*(R", while AnyEvent + its pure perl
backend easily beats IO::Lambda n' \s-1POE.\s0
.PP
And even tha 100% non-blockin version freestyled rockin tha high-level (and
slow WHAT! AnyEvent::Handle abstraction beats both \s-1POE\s0 n' IO::Lambda
higher level (\*(L"unoptimised\*(R") abstractions by a big-ass margin, even though
it do all of \s-1DNS,\s0 tcp-connect n' socket I/O up in a non-blockin way.
.PP
Da two AnyEvent benchmarks programs can be found as \fIeg/ae0.pl\fR and
\&\fIeg/ae2.pl\fR up in tha AnyEvent distribution, tha remainin benchmarks are
part of tha IO::Lambda distribution n' was used without any chizzles.
.SH "SIGNALS"
.IX Header "SIGNALS"
AnyEvent currently installs handlezs fo' these signals:
.IP "\s-1SIGCHLD\s0" 4
.IX Item "SIGCHLD"
A handlez fo' \f(CW\*(C`SIGCHLD\*(C'\fR is installed by AnyEventz lil pimp watcher
emulation fo' event loops dat do not support dem natively fo' realz. Also, some
event loops install a similar handlez.
.Sp
Additionally, when AnyEvent is loaded n' \s-1SIGCHLD\s0 is set ta \s-1IGNORE,\s0 then
AnyEvent will reset it ta default, ta avoid losin lil pimp exit statuses.
.IP "\s-1SIGPIPE\s0" 4
.IX Item "SIGPIPE"
A no-op handlez is installed fo' \f(CW\*(C`SIGPIPE\*(C'\fR when \f(CW$SIG{PIPE}\fR is \f(CW\*(C`undef\*(C'\fR
when AnyEvent gets loaded.
.Sp
Da rationale fo' dis is dat AnyEvent playas probably do not straight-up depend
on \s-1SIGPIPE\s0 delivery (which is purely a optimisation fo' shell use, or
badly-written programs) yo, but \f(CW\*(C`SIGPIPE\*(C'\fR can cause spurious n' rare
program exits as a shitload of playas do not expect \f(CW\*(C`SIGPIPE\*(C'\fR when freestylin to
some random socket.
.Sp
Da rationale fo' installin a no-op handlez as opposed ta ignorin it is
that dis way, tha handlez is ghon be restored ta defaults on exec.
.Sp
Feel free ta install yo' own handlez, or reset it ta defaults.
.SH "RECOMMENDED/OPTIONAL MODULES"
.IX Header "RECOMMENDED/OPTIONAL MODULES"
One of AnyEventz main goals is ta be 100% Pure\-Perl(tm): only perl (and
its built-in modules) is required ta use dat shit.
.PP
That do not mean dat AnyEvent won't take advantage of some additional
modulez if they is installed.
.PP
This section explains which additionizzle modulez is ghon be used, n' how tha fuck they
affect AnyEventz operation.
.IP "Async::Interrupt" 4
.IX Item "Async::Interrupt"
This slightly arcane module is used ta implement fast signal handling: To
my knowledge, there is no way ta do straight-up race-free n' quick
signal handlin up in pure perl. To ensure dat signals still get
delivered, AnyEvent will start a interval timer ta raise up perl (and
catch tha signals) wit some delay (default is 10 seconds, look for
\&\f(CW$AnyEvent::MAX_SIGNAL_LATENCY\fR).
.Sp
If dis module be available, then it is ghon be used ta implement signal
catching, which means dat signals aint gonna be delayed, n' tha event loop
will not be interrupted regularly, which is mo' efficient (and phat for
battery game on laptops).
.Sp
This affects not just tha pure-perl event loop yo, but also other event loops
that have no signal handlin on they own (e.g. Glib, Tk, Qt).
.Sp
Some event loops (\s-1POE,\s0 Event, Event::Lib) offer signal watchers natively,
and either employ they own workaroundz (\s-1POE\s0) or use AnyEventz workaround
(usin \f(CW$AnyEvent::MAX_SIGNAL_LATENCY\fR). Installin Async::Interrupt
does not a god damn thang fo' dem backends.
.IP "\s-1EV\s0" 4
.IX Item "EV"
This module aint straight-up \*(L"optional\*(R", as it is simply one of tha backend
event loops dat AnyEvent can use. But fuck dat shiznit yo, tha word on tha street is dat it is simply tha dopest event
loop available up in termz of features, speed n' stability: It supports
the AnyEvent \s-1API\s0 optimally, implements all tha watcher types up in \s-1XS,\s0 do
automatic timer adjustments even when no monotonic clock be available,
can take avdantage of advanced kernel intercourses like fuckin \f(CW\*(C`epoll\*(C'\fR and
\&\f(CW\*(C`kqueue\*(C'\fR, n' is tha fastest backend \fIby far\fR. Yo ass can even embed
Glib/Gtk2 up in it (or vice versa, peep EV::Glib n' Glib::EV).
.Sp
If you only use backendz dat rely on another event loop (e.g. \f(CW\*(C`Tk\*(C'\fR),
then dis module will do not a god damn thang fo' yo thugged-out ass.
.IP "Guard" 4
.IX Item "Guard"
Da guard module, when used, is ghon be used ta implement
\&\f(CW\*(C`AnyEvent::Util::guard\*(C'\fR. This speedz up guardz considerably (and uses a
lot less memory) yo, but otherwise don't affect guard operation much. Well shiiiit, it is
purely used fo' performance.
.IP "\s-1JSON\s0 n' \s-1JSON::XS\s0" 4
.IX Item "JSON n' JSON::XS"
One of these modulez is required when you wanna read or write \s-1JSON\s0 data
via AnyEvent::Handle. \s-1JSON\s0 be also freestyled up in pure-perl yo, but can take
advantage of tha ultra-high-speed \s-1JSON::XS\s0 module when it is installed.
.IP "Net::SSLeay" 4
.IX Item "Net::SSLeay"
Implementin \s-1TLS/SSL\s0 up in Perl is certainly interestin yo, but not hella
worthwhile: If dis module is installed, then AnyEvent::Handle (with
the help of AnyEvent::TLS), gains tha mobilitizzle ta do \s-1TLS/SSL.\s0
.IP "Time::HiRes" 4
.IX Item "Time::HiRes"
This module is part of perl since release 5.008. Well shiiiit, it is ghon be used when the
chosen event library do not come wit a timin source of its own. I aint talkin' bout chicken n' gravy biatch. The
pure-perl event loop (AnyEvent::Loop) will additionally load it to
try ta bust a monotonic clock fo' timin stability.
.IP "AnyEvent::AIO (and \s-1IO::AIO\s0)" 4
.IX Item "AnyEvent::AIO (and IO::AIO)"
Da default implementation of AnyEvent::IO is ta do I/O synchronously,
stoppin programs while they access tha disk, which is fine fo' a shitload of
programs.
.Sp
Installin AnyEvent::AIO (and its \s-1IO::AIO\s0 dependency) make it switch to
a legit asynchronous implementation, so event processin can continue even
while waitin fo' disk I/O.
.SH "FORK"
.IX Header "FORK"
Most event libraries is not fork-safe. Da ones whoz ass is probably are
because they rely on inefficient but fork-safe \f(CW\*(C`select\*(C'\fR or \f(CW\*(C`poll\*(C'\fR calls
\&\- higher performizzle APIs like fuckin \s-1BSD\s0z kqueue or tha dreaded Linux epoll
are probably badly thought-out hacks dat is incompatible wit fork in
one way or another n' shit. Only \s-1EV\s0 is straight-up fork-aware n' ensures dat you
continue event-processin up in both parent n' lil pimp (or both, if you know
what yo ass is bustin).
.PP
This means that, up in general, you cannot fork n' do event processin in
the lil pimp if tha event library was initialised before tha fork (which
usually happens when tha straight-up original gangsta AnyEvent watcher is pimped, or tha library
is loaded).
.PP
If you gotta fork, you must either do so \fIbefore\fR bustin yo' first
watcher \s-1OR\s0 you must not use AnyEvent at all up in tha lil pimp \s-1OR\s0 you must do
suttin' straight-up outta tha scope of AnyEvent.
.PP
Da problem of bustin event processin up in tha parent \fIand\fR tha child
is much mo' fucked up: even fo' backendz dat \fIare\fR fork-aware or
fork-safe, they behaviour aint probably what tha fuck you want: fork clones all
watchers, dat means all timers, I/O watchers etc. is actizzle up in both
parent n' child, which be almost never what tha fuck you want. USin \f(CW\*(C`exec\*(C'\fR
to start worker lil pimps from some kind of manage rprocess is usually
preferred, cuz it is much easier n' cleaner, all up in tha expense of having
to have another binary.
.SH "SECURITY CONSIDERATIONS"
.IX Header "SECURITY CONSIDERATIONS"
AnyEvent can be forced ta load any event model via
\&\f(CW$ENV\fR{\s-1PERL_ANYEVENT_MODEL\s0}. While dis cannot (to mah knowledge) be used to
execute arbitrary code or directly bust access, it can easily be used to
make tha program hang or malfunction up in subtle ways, as AnyEvent watchers
will not be actizzle when tha program uses a gangbangin' finger-lickin' different event model than
specified up in tha variable.
.PP
Yo ass can make AnyEvent straight-up ignore dis variable by deletin it
before tha straight-up original gangsta watcher gets pimped, e.g. wit a \f(CW\*(C`BEGIN\*(C'\fR block:
.PP
.Vb 1
\&   BEGIN { delete $ENV{PERL_ANYEVENT_MODEL} }
\&  
\&   use AnyEvent;
.Ve
.PP
Similar considerations apply ta \f(CW$ENV\fR{\s-1PERL_ANYEVENT_VERBOSE\s0}, as dat can
be used ta probe what tha fuck backend is used n' bust other shiznit (which is
probably even less useful ta a attacker than \s-1PERL_ANYEVENT_MODEL\s0), and
\&\f(CW$ENV\fR{\s-1PERL_ANYEVENT_STRICT\s0}.
.PP
Note dat AnyEvent will remove \fIall\fR environment variablez startin with
\&\f(CW\*(C`PERL_ANYEVENT_\*(C'\fR from \f(CW%ENV\fR when it is loaded while taint mode is
enabled.
.SH "BUGS"
.IX Header "BUGS"
Perl 5.8 has a shitload of memleaks dat sometimes hit dis module n' is hard
to work around. Y'all KNOW dat shit, muthafucka! If you suffer from memleaks, first upgrade ta Perl 5.10
and check wether tha leaks still show up. (Perl 5.10.0 has other buggin
memleaks, like fuckin leakin on \f(CW\*(C`map\*(C'\fR n' \f(CW\*(C`grep\*(C'\fR but it is probably not as
pronounced).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Tutorial/Introduction: AnyEvent::Intro.
.PP
\&\s-1FAQ: \s0AnyEvent::FAQ.
.PP
Utilitizzle functions: AnyEvent::Util (misc. grab-bag), AnyEvent::Log
(simply logging).
.PP
Development/Debugging: AnyEvent::Strict (stricta checking),
AnyEvent::Debug (interactizzle shell, watcher tracing).
.PP
Supported event modules: AnyEvent::Loop, \s-1EV\s0, EV::Glib,
Glib::EV, Event, Glib::Event, Glib, Tk, Event::Lib,
Qt, \s-1POE\s0, \s-1FLTK\s0.
.PP
Implementations: AnyEvent::Impl::EV, AnyEvent::Impl::Event,
AnyEvent::Impl::Glib, AnyEvent::Impl::Tk, AnyEvent::Impl::Perl,
AnyEvent::Impl::EventLib, AnyEvent::Impl::Qt,
AnyEvent::Impl::POE, AnyEvent::Impl::IOAsync, Anyevent::Impl::Irssi,
AnyEvent::Impl::FLTK.
.PP
Non-blockin handles, pipes, stream sockets, \s-1TCP\s0 clients and
servers: AnyEvent::Handle, AnyEvent::Socket, AnyEvent::TLS.
.PP
Asynchronous File I/O: AnyEvent::IO.
.PP
Asynchronous \s-1DNS: \s0AnyEvent::DNS.
.PP
Thread support: Coro, Coro::AnyEvent, Coro::EV, Coro::Event.
.PP
Nontrivial usage examples: AnyEvent::GPSD, AnyEvent::IRC,
AnyEvent::HTTP.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\&   Marc Lehmann <schmorp@schmorp.de>
\&   http://anyevent.schmorp.de
.Ve
