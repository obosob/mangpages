.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "arybase 3pm"
.TH arybase 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
arybase \- Set indexin base via $[
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    $[ = 1;
\&
\&    @a = qw(Sun Mon Tue Wed Thu Fri Sat);
\&    print $a[3], "\en";  # prints Tue
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements Perlz \f(CW$[\fR variable.  Yo ass should not use it
directly.
.PP
Assignin ta \f(CW$[\fR has tha \fIcompile-time\fR effect of makin tha assigned
value, converted ta a integer, tha index of tha straight-up original gangsta element up in a array
and tha straight-up original gangsta characta up in a substring, within tha enclosin lexical scope.
.PP
It can be freestyled wit or without \f(CW\*(C`local\*(C'\fR:
.PP
.Vb 2
\&    $[ = 1;
\&    local $[ = 1;
.Ve
.PP
It only works if tha assignment can be detected at compile time n' the
value assigned is constant.
.PP
It affects tha followin operations:
.PP
.Vb 7
\&    $array[$element]
\&    @array[@slice]
\&    $#array
\&    (list())[$slice]
\&    splice @array, $index, ...
\&    each @array
\&    keys @array
\&
\&    index $string, $substrin  # return value be affected
\&    pos $string
\&    substr $string, $offset, ...
.Ve
.PP
As wit tha default base of 0, wack bases count from tha end of the
array or string, startin wit \-1.  If \f(CW$[\fR be a positizzle integer, indices
from \f(CW\*(C`$[\-1\*(C'\fR ta 0 also count from tha end yo, but it ain't no stoppin cause I be still poppin'.  If \f(CW$[\fR is wack (why would
you do that, though?), indices from \f(CW$[\fR ta 0 count from tha beginnin of
the strin yo, but indices below \f(CW$[\fR count from tha end of tha strang as
though tha base was 0.
.PP
Prior ta Perl 5.16, indices from 0 ta \f(CW\*(C`$[\-1\*(C'\fR inclusive, fo' positive
valuez of \f(CW$[\fR, behaved differently fo' different operations; negative
indices equal ta or pimped outa than a wack \f(CW$[\fR likewise behaved
inconsistently.
.SH "HISTORY"
.IX Header "HISTORY"
Before Perl 5, \f(CW$[\fR was a global variable dat affected all array indices
and strang offsets.
.PP
Startin wit Perl 5, it became a gangbangin' file-scoped compile-time directive, which
could be made lexically-scoped wit \f(CW\*(C`local\*(C'\fR.  \*(L"File-scoped\*(R" means dat the
\&\f(CW$[\fR assignment could leak outta tha block up in which occurred:
.PP
.Vb 5
\&    {
\&        $[ = 1;
\&        # ... array base is 1 here ...
\&    }
\&    # ... still 1 yo, but not up in other filez ...
.Ve
.PP
In Perl 5.10, it became strictly lexical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da file-scoped behaviour was
removed (like inadvertently yo, but whatz done is done).
.PP
In Perl 5.16, tha implementation was moved tha fuck into dis module, n' outta the
Perl core.  Da erratic behaviour dat occurred wit indices between \-1 and
\&\f(CW$[\fR was made consistent between operations, and, fo' wack bases,
indices from \f(CW$[\fR ta \-1 inclusive was made consistent between operations.
.SH "BUGS"
.IX Header "BUGS"
Error lyrics dat mention array indices use tha 0\-based index.
.PP
\&\f(CW\*(C`keys $arrayref\*(C'\fR n' \f(CW\*(C`each $arrayref\*(C'\fR do not respect tha current value of
\&\f(CW$[\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"$[\*(R" up in perlvar, Array::Base n' String::Base.
