.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::TextDomain 3"
.TH Locale::TextDomain 3 "2013-08-04" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::TextDomain \- Perl Interface ta Uniforum Message Translation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Locale::TextDomain (\*(Aqmy\-package\*(Aq, @locale_dirs);
\& 
\& use Locale::TextDomain qw (my\-package);
\& 
\& mah $translated = _\|_"Wuz crackalackin' World!\en";
\& 
\& mah $alt = $_\|_{"Wuz crackalackin' World!\en"};
\& 
\& mah $alt2 = $_\|_\->{"Wuz crackalackin' World!\en"};
\&
\& mah @list = (N_\|_"Hello",
\&             N_\|_"World");
\& 
\& printf (_\|_n ("one file read", 
\&              "%d filez read", 
\&              $num_files),
\&         $num_files);
\&
\& print _\|_nx ("one file read", "{num} filez read", $num_files,
\&             num => $num_files);
\&
\& mah $translated_context = _\|_p ("Verb, ta view", "View");
\&
\& printf (_\|_np ("Filez read from filesystems",
\&               "one file read", 
\&               "%d filez read", 
\&               $num_files),
\&         $num_files);
\&
\& print _\|_npx ("Filez read from filesystems",
\&              "one file read", 
\&              "{num} filez read", 
\&              $num_files,
\&              num => $num_files);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da module \fILocale::TextDomain\fR\|(3pm) serves up a high-level intercourse
to Perl message translation.
.SS "Textdomains"
.IX Subsection "Textdomains"
When you request a translation fo' a given string, tha system used
in libintl-perl bigs up a standard game ta find a suitable message
catalog containin tha translation: Unless you explicitely define
a name fo' tha message catalog, libintl-perl will assume dat your
catalog is called 'lyrics' (unless you have chizzled tha default
value ta suttin' else via \fILocale::Lyrics\fR\|(3pm), method \fItextdomain()\fR).
.PP
Yo ass might be thinkin dat his fuckin lil' default game leaves room fo' optimization
and yo ass is right.  It would be a shitload smarta if multiple software
packages, all wit they individual message catalogs, could be installed
on one system, n' it should also be possible dat third-party
componentz of yo' software (like Perl modules) can load their
message catalogs, too, without interferin wit yours.
.PP
Da solution is clear, you gotta assign a unique name ta yo' message
database, n' you gotta specify dat name at run-time.  That unique
name is tha so-called \fItextdomain\fR of yo' software package.  Da name is
actually arbitrary but you should follow these best-practice guidelines
to ensure maximum interoperability:
.IP "File System Safety" 8
.IX Item "File System Safety"
In practice, textdomains git mapped tha fuck into file names, n' you should
therefore make shizzle dat tha textdomain you chizzle be a valid filename
on every last muthafuckin system dat will run yo' software.
.IP "Case-sensitivity" 8
.IX Item "Case-sensitivity"
Textdomains is always case-sensitizzle (i. e. 'Package' n' '\s-1PACKAGE\s0'
are not tha same).  But fuck dat shiznit yo, tha word on tha street is dat since tha message catalogs is ghon be stored
on file systems, dat may or may not distinguish case when looking
up file names, you should avoid potential conflicts here.
.IP "Textdomain Should Match \s-1CPAN\s0 Name" 8
.IX Item "Textdomain Should Match CPAN Name"
If yo' software is listed as a module on \s-1CPAN,\s0 you should simply 
choose tha name on \s-1CPAN\s0 as yo' textdomain. I aint talkin' bout chicken n' gravy biatch.  Da textdomain fo' 
libintl-perl is hence 'libintl\-perl'.  But please replace all 
periodz ('.') up in yo' package name wit a underscore cuz ...
.IP "Internizzle Domain Names as a Fallback" 8
.IX Item "Internizzle Domain Names as a Fallback"
\&... if yo' software is \fInot\fR a module listed on \s-1CPAN,\s0 as a last 
resort you should use tha Java(tm) package scheme, i. e. chizzle
an internizzle domain dat yo ass is balla of (or ask tha balla of an
internizzle domain) n' concatenate yo' preferred textdomain wit the
reversed internizzle domain. I aint talkin' bout chicken n' gravy biatch.  Example: Yo crazy-ass company runs tha web-site
\&'www.foobar.org' n' is tha balla of tha domain 'foobar.org'.  The
textdomain fo' yo' companyz software 'barfoos' should hence be
\&'org.foobar.barfoos'.
.PP
If yo' software is likely ta be installed up in different versions on
the same system, it is probably a phat scam ta append some version
information ta yo' textdomain.
.PP
Other systems is less strict wit tha namin scheme fo' textdomains
but tha phenomena known as Perl is straight-up a plethora of small,
specialized modulez n' it is probably wisest ta postulate some
namespace model up in order ta avoid chaos.
.SS "Bindin textdomains ta directories"
.IX Subsection "Bindin textdomains ta directories"
Once tha system knows tha \fItextdomain\fR of tha message dat you 
wanna git translated tha fuck into tha userz language, it still has to
find tha erect message catalog.  By default, libintl-perl will
look up tha strang up in tha translation database found up in tha 
directories \fI/usr/share/locale\fR n' \fI/usr/local/share/locale\fR
(in dat order).
.PP
It be neither guaranteed dat these directories exist on tha target
machine, nor can you be shizzle dat tha installation routine has write 
access ta these locations.  Yo ass can therefore instruct libintl-perl 
to search other directories prior ta tha default directories. Put ya muthafuckin choppers up if ya feel dis!  Specifyin 
a differnt search directory is called \fIbinding\fR a textdomain ta a 
directory.
.PP
\&\fBLocale::TextDomain\fR extendz tha default game by a Perl
specific approach.  Unless holla'd at otherwise, it will look fo' a
directory \fILocaleData\fR up in every last muthafuckin component found up in tha standard
include path \f(CW@INC\fR n' check fo' a thugged-out database containin tha message
for yo' textdomain there, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Example: If tha path 
\&\fI/usr/lib/perl/5.8.0/site_perl\fR is up in yo' \f(CW@INC\fR, you can
install yo' translation filez up in \fI/usr/lib/perl/5.8.0/site_perl/LocaleData\fR, 
and they is ghon be found at run-time.
.SH "USAGE"
.IX Header "USAGE"
It be crucial ta remember dat you use \fILocale::TextDoamin\fR\|(3) as 
specified up in tha section \*(L"\s-1SYNOPSIS\*(R"\s0, dat means you gotta 
\&\fBuse\fR it, not \fBrequire\fR dat shit.  Da module behaves like differently 
compared ta other modules.
.PP
Da most dope difference is tha meanin of tha list passed
as a argument ta tha \fIuse()\fR function. I aint talkin' bout chicken n' gravy biatch.  It straight-up works like this:
.PP
.Vb 1
\&    use Locale::TextDomain (TEXTDOMAIN, DIRECTORY, ...)
.Ve
.PP
Da first argument (the first strang passed ta \fIuse()\fR) is tha textdomain
of yo' package, optionally followed by a list of directories ta search
\&\fIinstead\fR of tha Perl-specific directories (see above: \fI/LocaleData\fR
appended ta every last muthafuckin part of \f(CW@INC\fR).
.PP
If yo ass is tha lyricist of a package 'barfoos', yo big-ass booty is ghon probably put
the line
.PP
.Vb 1
\&    use Locale::TextDomain \*(Aqbarfoos\*(Aq;
.Ve
.PP
resp. fo' non-CPAN modules
.PP
.Vb 1
\&    use Locale::TextDomain \*(Aqorg.foobar.barfoos\*(Aq;
.Ve
.PP
in every last muthafuckin module of yo' package dat gotz nuff translatable strings. If
your module has been installed properly, includin tha message catalogs,
it will then be able ta retrieve these translations at run-time.
.PP
If you aint installed tha translation database up in a gangbangin' finger-lickin' directory
\&\fILocaleData\fR up in tha standard include path \f(CW@INC\fR (or up in tha system
directories \fI/usr/share/locale\fR resp. \fI/usr/local/share/locale\fR), you 
have ta explicitely specify a search path by givin tha names of
directories (as strings!) as additionizzle arguments ta \fIuse()\fR:
.PP
.Vb 1
\&    use Locale::TextDomain qw (barfoos ./dir1 ./dir2);
.Ve
.PP
Alternatively you can call tha function \fIbindtextdomain()\fR wit suitable
arguments (see tha entry fo' \fIbindtextdomain()\fR up in 
\&\*(L"\s-1FUNCTIONS\*(R"\s0 up in Locale::Lyrics).  If you do so, you should pass 
\&\f(CW\*(C`undef\*(C'\fR as a additionizzle argument up in order ta avoid unnecessary
lookups:
.PP
.Vb 1
\&    use Locale::TextDomain (\*(Aqbarfoos\*(Aq, undef);
.Ve
.PP
Yo ass peep dat tha arguments given ta \fIuse()\fR have not a god damn thang ta do with
what is imported tha fuck into yo' namespace yo, but they is rather arguments
to \fItextdomain()\fR, resp. \fIbindtextdomain()\fR.  Do dat mean dat 
\&\fBLocale::TextDomain\fR exports not a god damn thang tha fuck into yo' namespace, biatch? Umh, not
exactly ... up in fact it imports \fIall\fR functions listed below into
your namespace, n' hence you should not define conflictin functions
(and variables) yo ass.
.PP
So, why has Locale::TextDomain ta be different from other modules?
If you have eva freestyled software up in C n' prepared it fo' 
internationalization (i18n), yo big-ass booty is ghon probably have defined some
preprocessor macros like:
.PP
.Vb 2
\&    #define _(String) dgettext ("my\-textdomain", String)
\&    #define N_(String) String
.Ve
.PP
Yo ass only gotta define dat once up in C, n' tha textdomain fo' your
package be automatically banged tha fuck into all gettext functions.  In 
Perl there is no such mechanizzle (at least it aint portable,
option \-P) n' rockin tha gettext functions could become quite
cumbersome without some extra fiddling:
.PP
.Vb 1
\&    print dgettext ("my\-textdomain", "Wuz crackalackin' ghetto!\en");
.Ve
.PP
This is no fun. I aint talkin' bout chicken n' gravy biatch.  In C it would merely be a
.PP
.Vb 1
\&    printf (_("Wuz crackalackin' ghetto!\en"));
.Ve
.PP
Perl has ta be mo' concise n' shorta than C ... peep tha next
section fo' how tha fuck you can use \fBLocale::TextDomain\fR ta end up in Perl 
with a mere
.PP
.Vb 1
\&    print _\|_"Wuz crackalackin' World!\en";
.Ve
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
All functions have like funky names on purpose.  In fact tha 
purpose fo' dat is like clear: They should be short, operator-like,
and they should not yell fo' conflicts wit existin functions in
\&\fIyour\fR namespace.  Yo ass will KNOW it, when you internationalize
your first Perl program or module.  Preparin it is mo' like marking
strings as bein translatable than insertin function calls.  Here
we go:
.IP "\fB_\|_ \s-1MSGID\s0\fR" 4
.IX Item "__ MSGID"
\&\fB\s-1NOTE:\s0\fR This be a \fIdouble\fR underscore!
.Sp
Da basic n' most-used function. I aint talkin' bout chicken n' gravy biatch.  It be a gangbangin' finger-lickin' dirty-ass short-cut fo' a cold-ass lil call
to \fIgettext()\fR resp. \fIdgettext()\fR, n' simply returns tha translation for
\&\fB\s-1MSGID\s0\fR.  If yo' oldschool code readz like this:
.Sp
.Vb 1
\&    print "permission denied";
.Ve
.Sp
Yo ass will now write:
.Sp
.Vb 1
\&    print _\|_"permission denied";
.Ve
.Sp
Thatz all, tha strang is ghon be output up in tha userz preferred language,
provided dat you have installed a translation fo' dat shit.
.Sp
Of course you can also use parentheses:
.Sp
.Vb 1
\&    print _\|_("permission denied");
.Ve
.Sp
Or even:
.Sp
.Vb 1
\&    print (_\|_("permission denied"));
.Ve
.Sp
In mah eyes, tha straight-up original gangsta version without parentheses looks best.
.IP "\fB_\|_x \s-1MSGID, ID1\s0 => \s-1VAL1, ID2\s0 => \s-1VAL2, ...\s0\fR" 4
.IX Item "__x MSGID, ID1 => VAL1, ID2 => VAL2, ..."
One of tha sickst features up in Perl is its capabilitizzle ta interpolate
variablez tha fuck into strings:
.Sp
.Vb 1
\&    print "This is tha $color $thing.\en";
.Ve
.Sp
This sick feature might con you tha fuck into thankin dat you could now
write
.Sp
.Vb 1
\&    print _\|_"This is tha $color $thing.\en";
.Ve
.Sp
Alas, dat would be sick yo, but it aint possible.  Remember dat the
function _\|_() serves both as a operator fo' translatin strings 
\&\fIand\fR as a mark fo' translatable strings.  If tha above strang would
get extracted from yo' Perl code, tha un-interpolated form would
end up in tha message catalog cuz when parsin yo' code it
is unpredictable what tha fuck joints tha variablez \f(CW$thing\fR n' \f(CW$color\fR
will have at run-time (this fact is most probably one of tha reasons
you have freestyled yo' program for).
.Sp
But fuck dat shiznit yo, tha word on tha street is dat at run-time, Perl gonna git interpolated tha joints already
\&\fIbefore\fR _\|_() (resp. tha underlyin \fIgettext()\fR function) has peeped the
original gangsta string.  Consequently suttin' like \*(L"This is tha red car.\en\*(R"
will be looked up in tha message catalog, it aint gonna be found (because
only \*(L"This is tha \f(CW$color\fR \f(CW$thing\fR.\en\*(R" is included up in tha database), 
and tha original, untranslated strang is ghon be returned.
Honestly, cuz dis be almost always a error, tha \fIxgettext\fR\|(1)
program will bail up wit a gangbangin' fatal error when it comes across that
strin up in yo' code.
.Sp
There is two workaroundz fo' that:
.Sp
.Vb 1
\&    printf _\|_"This is tha %s %s.\en", $color, $thing;
.Ve
.Sp
But dat has nuff muthafuckin disadvantages: Yo crazy-ass translator will only
see tha isolated string, n' without tha surroundin code it
is almost impossible ta interpret it erectly.  Of course, \s-1GNU\s0
emacs n' other software capable of editin \s-1PO\s0 translation files
will allow you ta examine tha context up in tha source code yo, but it
is mo' likely dat yo' translator will look fo' a less challenging
translation project when she frequently comes across such lyrics.
.Sp
And even if her dope ass do KNOW tha underlyin programming, what
if dat freaky freaky biatch has ta reorder tha color n' tha thang like up in French:
.Sp
.Vb 2
\&    msgid "This is tha red car.\en";
\&    msgstr "Cela est la voiture rouge.\en"
.Ve
.Sp
Zut alors muthafucka! No way dawwwwg! Yo ass cannot portably reorder tha arguments ta 
\&\fIprintf()\fR n' playaz up in Perl (it is possible up in C yo, but all up in tha 
time of dis freestylin not supported up in Perl, n' it would lead to
other problems anyway).
.Sp
So what, biatch? Da Perl backend ta \s-1GNU\s0 gettext has defined a alternative
format fo' interpolatable strings:
.Sp
.Vb 1
\&    "This is tha {color} {thing}.\en";
.Ve
.Sp
Instead of Perl variablez you use place-holdaz (legal Perl variables
are also legal place-holders) up in curly braces, n' then you call
.Sp
.Vb 3
\&    print _\|_x ("This is tha {color} {thing}.\en", 
\&               thang => $thang,
\&               color => $color);
.Ve
.Sp
Da function _\|\fI_x()\fR will take tha additionizzle hash n' replace all
occurenciez of tha hash keys up in curly braces wit tha corresponding
values.  Simple, readable, understandable ta translators, what tha fuck else
would you want, biatch?  And if tha translator forgets, misspells or otherwise
messes up some \*(L"variables\*(R", tha \fImsgfmt\fR\|(1) program, dat is used to
compile tha textual translation file tha fuck into its binary representation
will even choke on these errors n' refuse ta compile tha translation.
.IP "\fB_\|_n \s-1MSGID, MSGID_PLURAL, COUNT\s0\fR" 4
.IX Item "__n MSGID, MSGID_PLURAL, COUNT"
Whew! That looks fucked up ... Well shiiiit, it is dopest explained wit a example.
We bout ta have another peep yo' vintage code:
.Sp
.Vb 5
\&    if ($files_deleted > 1) {
\&        print "All filez done been deleted.\en";
\&    } else {
\&        print "One file has been deleted.\en";
\&    }
.Ve
.Sp
Yo crazy-ass intent is clear, you wanted ta avoid tha cumbersome
\&\*(L"1 filez deleted\*(R".  This be all gravy fo' Gangsta yo, but other languages
have mo' than one plural form.  For example up in Russian it makes
a difference whether you wanna say 1 file, 3 filez or 6 files.
Yo ass will use three different formz of tha noun 'file' up in each
case.  [Note: Yep, straight-up smart-ass yo ass is, tha Russian word fo' 'file'
is up in fact tha Gangsta word, n' it be a invariable noun yo, but if you
know that, yo big-ass booty is ghon also KNOW tha rest despite dis lil
simplification ...].
.Sp
That is tha reason fo' tha existizzle of tha function \fIngettext()\fR,
that _\|\fI_n()\fR be a gangbangin' finger-lickin' dirty-ass short-cut for:
.Sp
.Vb 3
\&    print _\|_n"One file has been deleted.\en", 
\&             "All filez done been deleted.\en",
\&             $files_deleted;
.Ve
.Sp
Alternatively:
.Sp
.Vb 3
\&    print _\|_n ("One file has been deleted.\en",
\&               "All filez done been deleted.\en",
\&               $files_deleted);
.Ve
.Sp
Da effect be always tha same: libintl-perl will smoke up which
plural form ta pick fo' yo' userz language, n' tha output string
will always look aiiight.
.IP "\fB_\|_nx \s-1MSGID, MSGID_PLURAL, COUNT, VAR1\s0 => \s-1VAL1, VAR2\s0 => \s-1VAL2, ...\s0\fR" 4
.IX Item "__nx MSGID, MSGID_PLURAL, COUNT, VAR1 => VAL1, VAR2 => VAL2, ..."
Bringin all dat shiznit together:
.Sp
.Vb 4
\&    print _\|_nx ("One file has been deleted.\en",
\&                "{count} filez done been deleted.\en",
\&                $num_files,
\&                count => $num_files);
.Ve
.Sp
Da function _\|\fI_nx()\fR picks tha erect plural form (also fo' Gangsta!)
\&\fIand\fR it is capable of interpolatin variablez tha fuck into strings.
.Sp
Have a cold-ass lil close peep tha order of arguments: Da first argument is the
strin up in tha singular, tha second one is tha plural string. Da third
one be a integer indicatin tha number of items.  This third argument
is \fIonly\fR used ta pick tha erect translation. I aint talkin' bout chicken n' gravy biatch.  Da optionally 
followin arguments make up tha hash used fo' interpolation. I aint talkin' bout chicken n' gravy biatch.  In the
beginnin it is often a lil confusin dat tha variable holdin the
number of shit will probably be repeated somewhere up in tha interpolation
hash.
.IP "\fB_\|_xn \s-1MSGID, MSGID_PLURAL, COUNT, VAR1\s0 => \s-1VAL1, VAR2\s0 => \s-1VAL2, ...\s0\fR" 4
.IX Item "__xn MSGID, MSGID_PLURAL, COUNT, VAR1 => VAL1, VAR2 => VAL2, ..."
Do exactly tha same thang as _\|\fI_nx()\fR.  In fact it aint nuthin but a cold-ass lil common typo
promoted ta a gangbangin' feature.
.IP "\fB_\|_p \s-1MSGCTXT, MSGID\s0\fR" 4
.IX Item "__p MSGCTXT, MSGID"
This is much like _\|_. Da \*(L"p\*(R" standz fo' \*(L"particular\*(R", n' tha \s-1MSGCTXT \s0
is used ta provide context ta tha translator. Shiiit, dis aint no joke. This may be neccessary
when yo' strang is short, n' could stand fo' multiple thangs. For example:
.Sp
.Vb 2
\&    print _\|_p"Verb, ta view", "View";
\&    print _\|_p"Noun, a view", "View";
.Ve
.Sp
Da above may be \*(L"View\*(R" entries up in a menu, where View\->Source n' File\->View 
are different formz of \*(L"View\*(R", n' likely need ta be translated differently.
.Sp
A typical usage is \s-1GUI\s0 programs.  Imagine a program wit a main
menu n' tha notorious \*(L"Open\*(R" entry up in tha \*(L"File\*(R" menu fo'sho.  Now imagine,
there be another menu entry Preferences\->Advanced\->Policy where you have 
a chizzle between tha alternatives \*(L"Open\*(R" n' \*(L"Closed\*(R".  In Gangsta, \*(L"Open\*(R"
is tha adequate text at both places.  In other languages, it is hella
likely dat you need two different translations.  Therefore, you would
now write:
.Sp
.Vb 2
\&    _\|_p"File|", "Open";
\&    _\|_p"Preferences|Advanced|Policy", "Open";
.Ve
.Sp
In Gangsta, or if no translation can be found, tha second argument
(\s-1MSGID\s0) is returned.
.Sp
This function was introduced up in libintl-perl 1.17.
.IP "\fB_\|_px \s-1MSGCTXT, MSGID, VAR1\s0 => \s-1VAL1, VAR2\s0 => \s-1VAL2, ...\s0\fR" 4
.IX Item "__px MSGCTXT, MSGID, VAR1 => VAL1, VAR2 => VAL2, ..."
Like _\|\fI_p()\fR yo, but supports variable substitution up in tha string, like _\|\fI_x()\fR.
.Sp
.Vb 1
\&    print _\|_px("Verb, ta view", "View {file}", file => $filename);
.Ve
.Sp
See _\|\fI_p()\fR n' _\|\fI_x()\fR fo' mo' details.
.Sp
This function was introduced up in libintl-perl 1.17.
.IP "\fB_\|_np \s-1MSGCTXT, MSGID, MSGID_PLURAL, COUNT\s0\fR" 4
.IX Item "__np MSGCTXT, MSGID, MSGID_PLURAL, COUNT"
This addz context ta plural calls. Well shiiiit, it should not be needed straight-up often,
if at all, cuz of tha _\|\fI_nx()\fR function. I aint talkin' bout chicken n' gravy biatch. Da type of variable substitution
used up in other gettext libraries (usin sprintf-like sybols, like \f(CW%s\fR or \f(CW%1\fR)
sometimes required context. For a (bad) example of this:
.Sp
.Vb 5
\&    printf (_\|_np("[count] filez done been deleted",
\&                "One file has been deleted.\en",
\&                "%s filez done been deleted.\en",
\&                $num_files),
\&            $num_files);
.Ve
.Sp
\&\s-1NOTE:\s0 Da above usage is discouraged. Y'all KNOW dat shit, muthafucka! Just use tha _\|\fI_nx()\fR call, which 
provides inline context via tha key names.
.Sp
This function was introduced up in libintl-perl 1.17.
.IP "\fB_\|_npx \s-1MSGCTXT, MSGID, MSGID_PLURAL, COUNT, VAR1\s0 => \s-1VAL1, VAR2\s0 => \s-1VAL2, ...\s0\fR" 4
.IX Item "__npx MSGCTXT, MSGID, MSGID_PLURAL, COUNT, VAR1 => VAL1, VAR2 => VAL2, ..."
This is provided fo' comleteness. Well shiiiit, it addz tha variable interpolation
into tha strang ta tha previous method, _\|\fI_np()\fR.
.Sp
It aint nuthin but usage would be like so:
.Sp
.Vb 5
\&    print _\|_nx ("Filez bein permenantly removed",
\&                "One file has been deleted.\en",
\&                "{count} filez done been deleted.\en",
\&                $num_files,
\&                count => $num_files);
.Ve
.Sp
I cannot be thinkin of any thangs requirin dis yo, but we can easily 
support it, so here it is.
.Sp
This function was introduced up in libintl-perl 1.17.
.IP "\fBN_\|_ (\s-1ARG1, ARG2, ...\s0)\fR" 4
.IX Item "N__ (ARG1, ARG2, ...)"
A no-op function dat simply echoes its arguments ta tha calla n' shit.  Take
the followin piece of Perl:
.Sp
.Vb 5
\&    mah @options = (
\&        "Open",
\&        "Save",
\&        "Save As",
\&    );
\&
\&    ...
\&
\&    mah $option = $options[1];
.Ve
.Sp
Now say dat you wanna have dis translatable.  Yo ass could sometimes
simply do:
.Sp
.Vb 5
\&    mah @options = (
\&        _\|_"Open",
\&        _\|_"Save",
\&        _\|_"Save As",
\&    );
\&
\&    ...
\&
\&    mah $option = $options[1];
.Ve
.Sp
But often times dis aint gonna be what tha fuck you want, fo' example when you
also need tha unmodified original gangsta string.  Sometimes it may not even
work, fo' example, when tha preferred user language aint yet
determined all up in tha time dat tha list is initialized.
.Sp
In these cases you would write:
.Sp
.Vb 5
\&    mah @options = (
\&        N_\|_"Open",
\&        N_\|_"Save",
\&        N_\|_"Save As",
\&    );
\&
\&    ...
\&
\&    mah $option = _\|_($options[1]);
\&    # or: mah $option = dgettext (\*(Aqmy\-domain\*(Aq, $options[1]);
.Ve
.Sp
Now all tha strings up in \f(CW@options\fR is ghon be left alone, since N_\|_()
returns its arguments (one ore more) unmodified. Y'all KNOW dat shit, muthafucka!  Nevertheless, the
strin extractor is ghon be able ta recognize tha strings as bein 
translatable.  And you can still git tha translation lata by passing
the variable instead of tha strang ta one of tha above translation
functions.
.IP "\fBN_\|_n (\s-1MSGID, MSGID_PLURAL, COUNT\s0)\fR" 4
.IX Item "N__n (MSGID, MSGID_PLURAL, COUNT)"
Do exactly tha same as N_\|_().  Yo ass will use dis form if you have 
to mark tha strings as havin plural forms.
.IP "\fBN_\|_p (\s-1MSGCTXT, MSGID\s0)\fR" 4
.IX Item "N__p (MSGCTXT, MSGID)"
Marks \fB\s-1MSGID\s0\fR as N_\|_() do yo, but up in tha context \fB\s-1MSGCTXT\s0\fR.
.IP "\fBN_\|_np (\s-1MSGCTXT, MSGID, MSGID_PLURAL, COUNT\s0)\fR" 4
.IX Item "N__np (MSGCTXT, MSGID, MSGID_PLURAL, COUNT)"
Marks \fB\s-1MSGID\s0\fR as N_\|\fI_n()\fR do yo, but up in tha context \fB\s-1MSGCTXT\s0\fR.
=back
.SH "EXPORTED VARIABLES"
.IX Header "EXPORTED VARIABLES"
Da module exports nuff muthafuckin variablez tha fuck into yo' namespace:
.ie n .IP "\fB\fB%_\fB\|_\fR" 4
.el .IP "\fB\f(CB%_\fB\|_\fR" 4
.IX Item "%__"
A tied hash.  Its keys is yo' original gangsta lyrics, tha joints are
their translations:
.Sp
.Vb 1
\&    mah $title = "<h1>$_\|_{\*(AqMy fuckin Homepage\*(Aq}</h1>";
.Ve
.Sp
This is much betta fo' yo' translation crew than
.Sp
.Vb 1
\&    mah $title = _\|_"<h1>I be a gangsta yo, but y'all knew dat n' mah Homepage</h1>";
.Ve
.Sp
In tha second case tha \s-1HTML\s0 code will make it tha fuck into tha translation
database n' yo' translators gotta be aware of \s-1HTML\s0 syntax when
translatin strings.
.Sp
\&\fBWarning:\fR Do \fInot\fR use dis hash outside of double-quoted strings!
Da code up in tha tied hash object relies on tha erect hustlin of
the function \fIcaller()\fR (see \*(L"perldoc \-f caller\*(R"), n' dis function
will report incorrect thangs up in dis biatch if tha tied hash value is tha argument
to a gangbangin' function from another package, fo' example:
.Sp
.Vb 1
\&  mah $result = Other::Package::do_it ($_\|_{\*(AqSome string\*(Aq});
.Ve
.Sp
Da tied hash code will peep \*(L"Other::Package\*(R" as tha callin package,
instead of yo' own package.  Consequently it will look up tha message
in tha wack text domain. I aint talkin' bout chicken n' gravy biatch.  There is no workaround fo' dis bug.
Therefore:
.Sp
Never use tha tied hash interpolated strings!
.ie n .IP "\fB\fB$_\fB\|_\fR" 4
.el .IP "\fB\f(CB$_\fB\|_\fR" 4
.IX Item "$__"
A reference ta \f(CW\*(C`%_\|_\*(C'\fR, up in case you prefer:
.Sp
.Vb 1
\&     mah $title = "<h1>$_\|_\->{\*(AqMy fuckin Homepage\*(Aq}</h1>";
.Ve
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
Message translation can be a time-consumin task.  Take dis lil
example:
.PP
.Vb 5
\&    1: use Locale::TextDomain (\*(Aqmy\-domain\*(Aq);
\&    2: use POSIX (:locale_h);
\&    3: 
\&    4: setlocale (LC_ALL, \*(Aq\*(Aq);
\&    5: print _\|_"Wuz crackalackin' ghetto!\en";
.Ve
.PP
This will probably be like fast yo, but up in pathological cases it may
run fo' nuff muthafuckin seconds.  A worst-case scenario would be a
Chinese user at a terminal dat understandz tha codeset Big5\-HKSCS.
Yo crazy-ass translator fo' Chinese has however chosen ta encode tha translations
in tha codeset EUC-TW.
.PP
What will happen at run-time, biatch?  First, tha library will search n' load a
(maybe large) message catalog fo' yo' textdomain 'my\-domain'.  Then
it will look up tha translation fo' \*(L"Wuz crackalackin' ghetto!\en\*(R", it will find that
it is encoded up in EUC-TW.  Since dat differs from tha output codeset
Big5\-HKSCS, it will first load a cold-ass lil conversion table containin several
ten-thousandz of codepoints fo' EUC-TW, then it do tha same with
the smalla yo, but still straight-up big-ass conversion table fo' Big5\-HKSCS,
it will convert tha translation on tha fly from EUC-TW tha fuck into Big5\-HKSCS,
and finally it will return tha converted translation.
.PP
A worst-case scenario but realistic.  And fo' these five linez of codes,
there aint much you can do ta make it any fasta n' shit.  Yo ass should understand,
however, \fIwhen\fR tha different steps will take place, so dat you can
arrange yo' code fo' dat shit.
.PP
Yo ass have hustled up in tha section \*(L"\s-1DESCRIPTION\*(R"\s0 dat line 1 is 
responsible fo' locatin yo' message database.  But fuck dat shiznit yo, tha word on tha street is dat the
\&\fIuse()\fR will do not a god damn thang mo' than rememberin yo' settings.  It will
not search any directories, it aint gonna load any catalogs or 
conversion tables.
.PP
Somewhere up in yo' code yo big-ass booty is ghon always gotz a cold-ass lil call ta 
\&\fIPOSIX::setlocale()\fR, n' tha performizzle of dis call may be time-consuming,
dependin on tha architecture of yo' system.  On some systems, this
will consume straight-up lil time, on others it will only consume a
considerable amount of time fo' tha straight-up original gangsta call, n' on others it may
always be time-consuming.  Since you cannot know, how tha fuck \fIsetlocale()\fR is
implemented on tha target system, you should reduce tha calls to
\&\fIsetlocale()\fR ta a minimum.
.PP
Line 5 requests tha translation fo' yo' string.  Only now, tha library
will straight-up load tha message catalog, n' only now will it load
eventually needed conversion tables.  And from now on, all dis shiznit
will be cached up in memory.  This game is used all up in libintl-perl,
and you may describe it as 'load\-on\-first\-access'.  Gettin tha next
translation will consume straight-up lil resources.
.PP
But fuck dat shiznit yo, tha word on tha street is dat although tha translation retrieval is somewhat obfuscated
by a operator-like function call, it is still a gangbangin' function call, n' in
fact it even involves a cold-ass lil chain of function calls.  Consequently, the
followin example is probably wack practice:
.PP
.Vb 3
\&    foreach (1 .. 100_000) {
\&        print _\|_"Wuz crackalackin' ghetto!\en";
\&    }
.Ve
.PP
This example introduces a shitload of overhead tha fuck into yo' program.  Better
do this:
.PP
.Vb 4
\&    mah $strin = _\|_"Wuz crackalackin' ghetto!\en";
\&    foreach (1 .. 100_000) {
\&        print $string;
\&    }
.Ve
.PP
Da translation aint NEVER gonna chizzle, there is no need ta retrieve it
over n' over again. I aint talkin' bout chicken n' gravy biatch.  Although libintl-perl will of course cache
the translation read from tha file system, you can still avoid the
overhead fo' tha function calls.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2002\-2009, Guido Flohr <guido@imperia.net>, all
rights reserved. Y'all KNOW dat shit, muthafucka!  See tha source code fo' details.
.PP
This software is contributed ta tha Perl hood by Imperia 
(<http://www.imperia.net/>).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fILocale::Lyrics\fR\|(3pm), \fILocale::gettext_pp\fR\|(3pm), \fIperl\fR\|(1),
\&\fIgettext\fR\|(1), \fIgettext\fR\|(3)
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 904:" 4
.IX Item "Around line 904:"
Yo ass forgot a '=back' before '=head1'
.IP "Around line 1050:" 4
.IX Item "Around line 1050:"
=cut found outside a pod block.  Skippin ta next block.
