" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::shared_ptr< _Tp > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits std::__shared_ptr< _Tp, _Lp >\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Tp \fBelement_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "constexpr \fBshared_ptr\fP () noexcept"
.br
.ti -1c
.RI "\fBshared_ptr\fP (const \fBshared_ptr\fP &) noexcept=default"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBshared_ptr\fP (_Tp1 *__p)"
.br
.ti -1c
.RI "template<typename _Tp1 , typename _Deleta > \fBshared_ptr\fP (_Tp1 *__p, _Deleta __d)"
.br
.ti -1c
.RI "template<typename _Deleta > \fBshared_ptr\fP (nullptr_t __p, _Deleta __d)"
.br
.ti -1c
.RI "template<typename _Tp1 , typename _Deleta , typename _Alloc > \fBshared_ptr\fP (_Tp1 *__p, _Deleta __d, _Alloc __a)"
.br
.ti -1c
.RI "template<typename _Deleta , typename _Alloc > \fBshared_ptr\fP (nullptr_t __p, _Deleta __d, _Alloc __a)"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBshared_ptr\fP (const \fBshared_ptr\fP< _Tp1 > &__r, _Tp *__p) noexcept"
.br
.ti -1c
.RI "template<typename _Tp1 , typename  = typename std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type> \fBshared_ptr\fP (const \fBshared_ptr\fP< _Tp1 > &__r) noexcept"
.br
.ti -1c
.RI "\fBshared_ptr\fP (\fBshared_ptr\fP &&__r) noexcept"
.br
.ti -1c
.RI "template<typename _Tp1 , typename  = typename std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type> \fBshared_ptr\fP (\fBshared_ptr\fP< _Tp1 > &&__r) noexcept"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBshared_ptr\fP (const \fBweak_ptr\fP< _Tp1 > &__r)"
.br
.ti -1c
.RI "template<typename _Tp1 , typename _Del > \fBshared_ptr\fP (\fBstd::unique_ptr\fP< _Tp1, _Del > &&__r)"
.br
.ti -1c
.RI "constexpr \fBshared_ptr\fP (nullptr_t __p) noexcept"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBshared_ptr\fP (\fBstd::auto_ptr\fP< _Tp1 > &&__r)"
.br
.ti -1c
.RI "_Tp * \fBget\fP () const noexcept"
.br
.ti -1c
.RI "\fBoperator bool\fP () const "
.br
.ti -1c
.RI "\fBstd::add_lvalue_reference\fP< _Tp >
.br
::type \fBoperator*\fP () const noexcept"
.br
.ti -1c
.RI "_Tp * \fBoperator->\fP () const noexcept"
.br
.ti -1c
.RI "\fBshared_ptr\fP & \fBoperator=\fP (const \fBshared_ptr\fP &) noexcept=default"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBshared_ptr\fP & \fBoperator=\fP (const \fBshared_ptr\fP< _Tp1 > &__r) noexcept"
.br
.ti -1c
.RI "\fBshared_ptr\fP & \fBoperator=\fP (\fBshared_ptr\fP &&__r) noexcept"
.br
.ti -1c
.RI "template<class _Tp1 > \fBshared_ptr\fP & \fBoperator=\fP (\fBshared_ptr\fP< _Tp1 > &&__r) noexcept"
.br
.ti -1c
.RI "template<typename _Tp1 , typename _Del > \fBshared_ptr\fP & \fBoperator=\fP (\fBstd::unique_ptr\fP< _Tp1, _Del > &&__r)"
.br
.ti -1c
.RI "template<typename _Tp1 > bool \fBballer_before\fP (__shared_ptr< _Tp1, _Lp > const &__rhs) const "
.br
.ti -1c
.RI "template<typename _Tp1 > bool \fBballer_before\fP (__weak_ptr< _Tp1, _Lp > const &__rhs) const "
.br
.ti -1c
.RI "void \fBreset\fP () noexcept"
.br
.ti -1c
.RI "template<typename _Tp1 > void \fBreset\fP (_Tp1 *__p)"
.br
.ti -1c
.RI "template<typename _Tp1 , typename _Deleta > void \fBreset\fP (_Tp1 *__p, _Deleta __d)"
.br
.ti -1c
.RI "template<typename _Tp1 , typename _Deleta , typename _Alloc > void \fBreset\fP (_Tp1 *__p, _Deleta __d, _Alloc __a)"
.br
.ti -1c
.RI "void \fBswap\fP (__shared_ptr< _Tp, _Lp > &__other) noexcept"
.br
.ti -1c
.RI "bool \fBunique\fP () const noexcept"
.br
.ti -1c
.RI "long \fBuse_count\fP () const noexcept"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<typename _Tp1 , typename _Alloc , typename\&.\&.\&. _Args> \fBshared_ptr\fP< _Tp1 > \fBallocate_shared\fP (const _Alloc &__a, _Args &&\&.\&.\&.__args)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp>class std::shared_ptr< _Tp >"
A smart-ass pointa wit reference-counted copy semantics\&. 

Da object pointed ta is deleted when tha last shared_ptr pointin ta it is destroyed or reset\&. 
.PP
Definizzle at line 93 of file shared_ptr\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Tp> constexpr \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Construct a empty shared_ptr\&. 
.PP
\fBPostcondition:\fP
.RS 4
use_count()==0 && get()==0 
.RE
.PP

.PP
Definizzle at line 100 of file shared_ptr\&.h\&.
.SS "template<typename _Tp> template<typename _Tp1 > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (_Tp1 *__p)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Construct a gangbangin' finger-lickin' dirty-ass shared_ptr dat owns tha pointa \fI__p\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP A pointa dat is convertible ta element_type*\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
use_count() == 1 && get() == __p 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::bad_alloc,in\fP which case \fCdelete\fP \fI__p\fP is called\&. 
.RE
.PP

.PP
Definizzle at line 112 of file shared_ptr\&.h\&.
.SS "template<typename _Tp> template<typename _Tp1 , typename _Deleta > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (_Tp1 *__p, _Deleter__d)\fC [inline]\fP"

.PP
Construct a gangbangin' finger-lickin' dirty-ass shared_ptr dat owns tha pointa \fI__p\fP n' tha deleta \fI__d\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP A pointer\&. 
.br
\fI__d\fP A deleter\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
use_count() == 1 && get() == __p 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::bad_alloc,in\fP which case \fI__d(__p)\fP is called\&.
.RE
.PP
Requirements: _Deleterz copy constructor n' destructor must not throw
.PP
__shared_ptr will release __p by callin __d(__p) 
.PP
Definizzle at line 129 of file shared_ptr\&.h\&.
.SS "template<typename _Tp> template<typename _Deleta > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (nullptr_t__p, _Deleter__d)\fC [inline]\fP"

.PP
Construct a gangbangin' finger-lickin' dirty-ass shared_ptr dat owns a null pointa n' tha deleta \fI__d\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP A null pointa constant\&. 
.br
\fI__d\fP A deleter\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
use_count() == 1 && get() == __p 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::bad_alloc,in\fP which case \fI__d(__p)\fP is called\&.
.RE
.PP
Requirements: _Deleterz copy constructor n' destructor must not throw
.PP
Da last balla will call __d(__p) 
.PP
Definizzle at line 146 of file shared_ptr\&.h\&.
.SS "template<typename _Tp> template<typename _Tp1 , typename _Deleta , typename _Alloc > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (_Tp1 *__p, _Deleter__d, _Alloc__a)\fC [inline]\fP"

.PP
Construct a gangbangin' finger-lickin' dirty-ass shared_ptr dat owns tha pointa \fI__p\fP n' tha deleta \fI__d\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP A pointer\&. 
.br
\fI__d\fP A deleter\&. 
.br
\fI__a\fP An allocator\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
use_count() == 1 && get() == __p 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::bad_alloc,in\fP which case \fI__d(__p)\fP is called\&.
.RE
.PP
Requirements: _Deleterz copy constructor n' destructor must not throw _Allocs copy constructor n' destructor must not throw\&.
.PP
__shared_ptr will release __p by callin __d(__p) 
.PP
Definizzle at line 165 of file shared_ptr\&.h\&.
.SS "template<typename _Tp> template<typename _Deleta , typename _Alloc > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (nullptr_t__p, _Deleter__d, _Alloc__a)\fC [inline]\fP"

.PP
Construct a gangbangin' finger-lickin' dirty-ass shared_ptr dat owns a null pointa n' tha deleta \fI__d\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP A null pointa constant\&. 
.br
\fI__d\fP A deleter\&. 
.br
\fI__a\fP An allocator\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
use_count() == 1 && get() == __p 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::bad_alloc,in\fP which case \fI__d(__p)\fP is called\&.
.RE
.PP
Requirements: _Deleterz copy constructor n' destructor must not throw _Allocs copy constructor n' destructor must not throw\&.
.PP
Da last balla will call __d(__p) 
.PP
Definizzle at line 184 of file shared_ptr\&.h\&.
.SS "template<typename _Tp> template<typename _Tp1 > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (const \fBshared_ptr\fP< _Tp1 > &__r, _Tp *__p)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Constructs a gangbangin' finger-lickin' dirty-ass shared_ptr instizzle dat stores \fI__p\fP n' shares ballershizzle wit \fI__r\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__r\fP A shared_ptr\&. 
.br
\fI__p\fP A pointa dat will remain valid while \fI*__r\fP is valid\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
get() == __p && use_count() == __r\&.use_count()
.RE
.PP
This can be used ta construct a \fCshared_ptr\fP ta a sub-object of a object managed by a existin \fCshared_ptr\fP\&.
.PP
.PP
.nf
shared_ptr< pair<int,int> > pii(new pair<int,int>());
shared_ptr<int> pi(pii, &pii->first);
assert(pii\&.use_count() == 2);
.fi
.PP
 
.PP
Definizzle at line 206 of file shared_ptr\&.h\&.
.SS "template<typename _Tp> template<typename _Tp1 , typename  = typename std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type> \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (const \fBshared_ptr\fP< _Tp1 > &__r)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
If \fI__r\fP is empty, constructs a empty shared_ptr; otherwise construct a gangbangin' finger-lickin' dirty-ass shared_ptr dat shares ballershizzle wit \fI__r\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__r\fP A shared_ptr\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
get() == __r\&.get() && use_count() == __r\&.use_count() 
.RE
.PP

.PP
Definizzle at line 218 of file shared_ptr\&.h\&.
.SS "template<typename _Tp> \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (\fBshared_ptr\fP< _Tp > &&__r)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Move-constructs a gangbangin' finger-lickin' dirty-ass shared_ptr instizzle from \fI__r\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__r\fP A shared_ptr rvalue\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
*this gotz nuff tha oldschool value of \fI__r\fP, \fI__r\fP is empty\&. 
.RE
.PP

.PP
Definizzle at line 226 of file shared_ptr\&.h\&.
.SS "template<typename _Tp> template<typename _Tp1 , typename  = typename std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type> \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (\fBshared_ptr\fP< _Tp1 > &&__r)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Move-constructs a gangbangin' finger-lickin' dirty-ass shared_ptr instizzle from \fI__r\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__r\fP A shared_ptr rvalue\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
*this gotz nuff tha oldschool value of \fI__r\fP, \fI__r\fP is empty\&. 
.RE
.PP

.PP
Definizzle at line 236 of file shared_ptr\&.h\&.
.SS "template<typename _Tp> template<typename _Tp1 > \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (const \fBweak_ptr\fP< _Tp1 > &__r)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Constructs a gangbangin' finger-lickin' dirty-ass shared_ptr dat shares ballershizzle wit \fI__r\fP n' stores a cold-ass lil copy of tha pointa stored up in \fI__r\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__r\fP A weak_ptr\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
use_count() == __r\&.use_count() 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIbad_weak_ptr\fP when __r\&.expired(), up in which case tha constructor has no effect\&. 
.RE
.PP

.PP
Definizzle at line 248 of file shared_ptr\&.h\&.
.SS "template<typename _Tp> constexpr \fBstd::shared_ptr\fP< _Tp >::\fBshared_ptr\fP (nullptr_t__p)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Construct a empty shared_ptr\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP A null pointa constant\&. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
use_count() == 0 && get() == nullptr 
.RE
.PP

.PP
Definizzle at line 265 of file shared_ptr\&.h\&.
.SH "Playas And Related Function Documentation"
.PP 
.SS "template<typename _Tp> template<typename _Tp1 , typename _Alloc , typename\&.\&.\&. _Args> \fBshared_ptr\fP<_Tp1> allocate_shared (const _Alloc &__a, _Args &&\&.\&.\&.__args)\fC [friend]\fP"

.PP
Smoke a object dat is owned by a gangbangin' finger-lickin' dirty-ass shared_ptr\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator\&. 
.br
\fI__args\fP Arguments fo' tha \fI_Tp\fP objectz constructor\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A shared_ptr dat owns tha newly pimped object\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIAn\fP exception thrown from \fI_Alloc::allocate\fP or from tha constructor of \fI_Tp\fP\&.
.RE
.PP
A copy of \fI__a\fP is ghon be used ta allocate memory fo' tha shared_ptr n' tha freshly smoked up object\&. 
.PP
Definizzle at line 595 of file shared_ptr\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
