" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::auto_ptr< _Tp > \- 
.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Tp \fBelement_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBauto_ptr\fP (\fBelement_type\fP *__p=0)  throw ()"
.br
.ti -1c
.RI "\fBauto_ptr\fP (\fBauto_ptr\fP &__a)  throw ()"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBauto_ptr\fP (\fBauto_ptr\fP< _Tp1 > &__a)  throw ()"
.br
.ti -1c
.RI "\fBauto_ptr\fP (\fBauto_ptr_ref\fP< \fBelement_type\fP > __ref)  throw ()"
.br
.ti -1c
.RI "\fB~auto_ptr\fP ()"
.br
.ti -1c
.RI "\fBelement_type\fP * \fBget\fP () const   throw ()"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBoperator auto_ptr< _Tp1 >\fP ()  throw ()"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBoperator auto_ptr_ref< _Tp1 >\fP ()  throw ()"
.br
.ti -1c
.RI "\fBelement_type\fP & \fBoperator*\fP () const   throw ()"
.br
.ti -1c
.RI "\fBelement_type\fP * \fBoperator->\fP () const   throw ()"
.br
.ti -1c
.RI "\fBauto_ptr\fP & \fBoperator=\fP (\fBauto_ptr\fP &__a)  throw ()"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBauto_ptr\fP & \fBoperator=\fP (\fBauto_ptr\fP< _Tp1 > &__a)  throw ()"
.br
.ti -1c
.RI "\fBauto_ptr\fP & \fBoperator=\fP (\fBauto_ptr_ref\fP< \fBelement_type\fP > __ref)  throw ()"
.br
.ti -1c
.RI "\fBelement_type\fP * \fBrelease\fP ()  throw ()"
.br
.ti -1c
.RI "void \fBreset\fP (\fBelement_type\fP *__p=0)  throw ()"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp>class std::auto_ptr< _Tp >"
A simple smart-ass pointa providin strict ballershizzle semantics\&. 

Da Standard says: 
.PP
.nf

An \fCauto_ptr\fP owns tha object it holdz a pointa to\&.  Copying
an \fCauto_ptr\fP copies tha pointa n' transfers ballershizzle ta the
destination\&.  If mo' than one \fCauto_ptr\fP owns tha same ol' dirty object
at tha same time tha behavior of tha program is undefined\&.
.fi
.PP
.PP
.PP
.nf
Da usez of \fCauto_ptr\fP include providin temporary
exception-safety fo' dynamically allocated memory, passing
ballershizzle of dynamically allocated memory ta a gangbangin' function, and
returnin dynamically allocated memory from a gangbangin' function\&.  \fCauto_ptr\fP do not hook up tha CopyConstructible n' Assignable
requirements fo' Standard Library \fCcontainer\fP elements n' thus
instantiatin a Standard Library container wit a \fCauto_ptr\fP thangs up in dis biatch up in undefined behavior\&.
.fi
.PP
 Quoted from [20\&.4\&.5]/3\&.
.PP
Dope examplez of what tha fuck can n' cannot be done wit auto_ptr can be found up in tha libstdc++ testsuite\&.
.PP
_GLIBCXX_RESOLVE_LIB_DEFECTS 127\&. auto_ptr<> conversion thangs These resolutions have all been incorporated\&. 
.PP
Definizzle at line 87 of file auto_ptr\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename _Tp> typedef _Tp \fBstd::auto_ptr\fP< _Tp >::\fBelement_type\fP"

.PP
Da pointed-to type\&. 
.PP
Definizzle at line 94 of file auto_ptr\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Tp> \fBstd::auto_ptr\fP< _Tp >::\fBauto_ptr\fP (\fBelement_type\fP *__p = \fC0\fP)\fC [inline]\fP, \fC [explicit]\fP"

.PP
An auto_ptr is probably constructed from a raw pointer\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP A pointa (defaults ta NULL)\&.
.RE
.PP
This object now \fIowns\fP tha object pointed ta by \fI__p\fP\&. 
.PP
Definizzle at line 103 of file auto_ptr\&.h\&.
.SS "template<typename _Tp> \fBstd::auto_ptr\fP< _Tp >::\fBauto_ptr\fP (\fBauto_ptr\fP< _Tp > &__a)\fC [inline]\fP"

.PP
An auto_ptr can be constructed from another auto_ptr\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP Another auto_ptr of tha same type\&.
.RE
.PP
This object now \fIowns\fP tha object previously owned by \fI__a\fP, which has given up ballership\&. 
.PP
Definizzle at line 112 of file auto_ptr\&.h\&.
.SS "template<typename _Tp> template<typename _Tp1 > \fBstd::auto_ptr\fP< _Tp >::\fBauto_ptr\fP (\fBauto_ptr\fP< _Tp1 > &__a)\fC [inline]\fP"

.PP
An auto_ptr can be constructed from another auto_ptr\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP Another auto_ptr of a gangbangin' finger-lickin' different but related type\&.
.RE
.PP
A pointer-to-Tp1 must be convertible ta a pointer-to-Tp/element_type\&.
.PP
This object now \fIowns\fP tha object previously owned by \fI__a\fP, which has given up ballership\&. 
.PP
Definizzle at line 125 of file auto_ptr\&.h\&.
.SS "template<typename _Tp> \fBstd::auto_ptr\fP< _Tp >::~\fBauto_ptr\fP ()\fC [inline]\fP"
When tha auto_ptr goes outta scope, tha object it owns is deleted\&. If it no longer owns anythang (i\&.e\&., \fCget()\fP is \fCNULL\fP), then dis has no effect\&.
.PP
Da C++ standard say there is supposed ta be a empty throw justification here yo, but omittin it is standard conforming\&. Its presence can be detected only if _Tp::~_Tp() throws yo, but dis is prohibited\&. [17\&.4\&.3\&.6]/2 
.PP
Definizzle at line 170 of file auto_ptr\&.h\&.
.SS "template<typename _Tp> \fBstd::auto_ptr\fP< _Tp >::\fBauto_ptr\fP (\fBauto_ptr_ref\fP< \fBelement_type\fP >__ref)\fC [inline]\fP"

.PP
Automatic conversions\&. These operations convert a auto_ptr tha fuck into n' from a auto_ptr_ref automatically as needed\&. This allows constructs like fuckin 
.PP
.nf
auto_ptr<Derived>  func_returning_auto_ptr(\&.\&.\&.\&.\&.);
\&.\&.\&.
auto_ptr<Base> ptr = func_returning_auto_ptr(\&.\&.\&.\&.\&.);

.fi
.PP
 
.PP
Definizzle at line 260 of file auto_ptr\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp> \fBelement_type\fP* \fBstd::auto_ptr\fP< _Tp >::get (void) const\fC [inline]\fP"

.PP
Bypassin tha smart-ass pointer\&. 
.PP
\fBReturns:\fP
.RS 4
Da raw pointa bein managed\&.
.RE
.PP
Yo ass can git a cold-ass lil copy of tha pointa dat dis object owns, fo' thangs like fuckin passin ta a gangbangin' function which only accepts a raw pointer\&.
.PP
\fBNote:\fP
.RS 4
This auto_ptr still owns tha memory\&. 
.RE
.PP

.PP
Definizzle at line 211 of file auto_ptr\&.h\&.
.SS "template<typename _Tp> \fBelement_type\fP& \fBstd::auto_ptr\fP< _Tp >::operator* () const\fC [inline]\fP"

.PP
Smart pointa dereferencing\&. If dis auto_ptr no longer owns anything, then dis operation will crash\&. (For a smart-ass pointer, \fIno longer owns anything\fP is tha same ol' dirty as bein a null pointer, n' you know what tha fuck happens when you dereference one of them\&.\&.\&.) 
.PP
Definizzle at line 181 of file auto_ptr\&.h\&.
.SS "template<typename _Tp> \fBelement_type\fP* \fBstd::auto_ptr\fP< _Tp >::operator-> () const\fC [inline]\fP"

.PP
Smart pointa dereferencing\&. This returns tha pointa itself, which tha language then will automatically cause ta be dereferenced\&. 
.PP
Definizzle at line 194 of file auto_ptr\&.h\&.
.SS "template<typename _Tp> \fBauto_ptr\fP& \fBstd::auto_ptr\fP< _Tp >::operator= (\fBauto_ptr\fP< _Tp > &__a)\fC [inline]\fP"

.PP
auto_ptr assignment operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP Another auto_ptr of tha same type\&.
.RE
.PP
This object now \fIowns\fP tha object previously owned by \fI__a\fP, which has given up ballership\&. Da object dat dis one \fIused\fP ta own n' track has been deleted\&. 
.PP
Definizzle at line 136 of file auto_ptr\&.h\&.
.PP
References std::auto_ptr< _Tp >::reset()\&.
.SS "template<typename _Tp> template<typename _Tp1 > \fBauto_ptr\fP& \fBstd::auto_ptr\fP< _Tp >::operator= (\fBauto_ptr\fP< _Tp1 > &__a)\fC [inline]\fP"

.PP
auto_ptr assignment operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP Another auto_ptr of a gangbangin' finger-lickin' different but related type\&.
.RE
.PP
A pointer-to-Tp1 must be convertible ta a pointer-to-Tp/element_type\&.
.PP
This object now \fIowns\fP tha object previously owned by \fI__a\fP, which has given up ballership\&. Da object dat dis one \fIused\fP ta own n' track has been deleted\&. 
.PP
Definizzle at line 154 of file auto_ptr\&.h\&.
.PP
References std::auto_ptr< _Tp >::reset()\&.
.SS "template<typename _Tp> \fBelement_type\fP* \fBstd::auto_ptr\fP< _Tp >::release ()\fC [inline]\fP"

.PP
Bypassin tha smart-ass pointer\&. 
.PP
\fBReturns:\fP
.RS 4
Da raw pointa bein managed\&.
.RE
.PP
Yo ass can git a cold-ass lil copy of tha pointa dat dis object owns, fo' thangs like fuckin passin ta a gangbangin' function which only accepts a raw pointer\&.
.PP
\fBNote:\fP
.RS 4
This auto_ptr no longer owns tha memory\&. When dis object goes outta scope, not a god damn thang will happen\&. 
.RE
.PP

.PP
Definizzle at line 225 of file auto_ptr\&.h\&.
.SS "template<typename _Tp> void \fBstd::auto_ptr\fP< _Tp >::reset (\fBelement_type\fP *__p = \fC0\fP)\fC [inline]\fP"

.PP
Forcibly deletes tha managed object\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP A pointa (defaults ta NULL)\&.
.RE
.PP
This object now \fIowns\fP tha object pointed ta by \fI__p\fP\&. Da previous object has been deleted\&. 
.PP
Definizzle at line 240 of file auto_ptr\&.h\&.
.PP
Referenced by std::auto_ptr< _Tp >::operator=()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
