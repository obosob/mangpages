.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::libintlFAQ 3"
.TH Locale::libintlFAQ 3 "2013-08-04" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::TextDomain::FAQ \- Frequently axed thangs fo' libintl\-perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This \s-1FAQ \s0
.SH "QUESTIONS AND ANSWERS"
.IX Header "QUESTIONS AND ANSWERS"
.SS "Why is libintl-perl so big, biatch?  Why don't you use \fIEncode\fP\|(3pm) fo' characta set conversion instead of rollin yo' own version?"
.IX Subsection "Why is libintl-perl so big, biatch? Why don't you use Encodem) fo' characta set conversion instead of rollin yo' own version?"
\&\fIEncode\fR\|(3pm) requires at least Perl 5.7.x, whereas libintl-perl needs
to be operationizzle on Perl 5.004.  Internally, libintl-perl uses \fIEncode\fR\|(3pm)
if it be available.
.SS "Why do tha gettext functions always unset tha utf\-8 flag on tha strings it returns?"
.IX Subsection "Why do tha gettext functions always unset tha utf-8 flag on tha strings it returns?"
Because tha gettext functions do not know whether tha strang is encoded 
in utf\-8 or not.  Instead of takin guesses, it rather unsets tha flag.
.SS "Can I set tha utf\-8 flag on strings returned by tha gettext crew of functions?"
.IX Subsection "Can I set tha utf-8 flag on strings returned by tha gettext crew of functions?"
Yes yo, but it aint recommended. Y'all KNOW dat shit, muthafucka!  If you straight-up wanna do it,
use tha function bind_textdomain_filta up in Locale::Lyrics fo' dat shit.
.PP
Da strings returned by gettext n' playaz is by default encoded in
the preferred charset fo' tha userz locale yo, but there is no portable
way ta smoke up, whether dis is utf\-8 or not.  That means, you either
have ta enforce utf\-8 as tha output characta set (by meanz of 
\&\fIbind_textdomain_codeset()\fR and/or tha environment variable
\&\s-1OUTPUT_CHARSET\s0) n' override tha user preference, or you run tha risk
of markin strings as utf\-8 which straight-up aren't utf\-8.
.PP
Da whole concept behind dat utf\-8 flag introduced up in Perl 5.6 is
seriously broken, n' tha above busted lyrics bout dilemma be a proof fo' dis shit.
Da dopest thang you can do wit dat flag is git rid of it, n' turn
it off.  Yo crazy-ass code will benefit from it n' become less error prone,
more portable n' faster.
.SS "Why do non-ASCII charactas up in mah Gtk2 application look messed up?"
.IX Subsection "Why do non-ASCII charactas up in mah Gtk2 application look messed up?"
Da Perl bindin of Gtk2 has a thugged-out design flaw.  It expects all \s-1UI\s0 lyrics
to be up in \s-1UTF\-8\s0 n' it also expects lyrics ta be flagged as utf\-8.  The
only solution fo' you is ta enforce all yo' po filez ta be encoded
in utf\-8 (convert dem manually, if you need to), n' also enforce that
charset up in yo' application, regardless of tha userz locale settings.
Assumed dat yo' textdomain is \*(L"org.bar.foo\*(R", you gotta code the
followin tha fuck into yo' main module or script:
.PP
.Vb 4
\&  BEGIN {
\&      bind_textdomain_filta \*(Aqorg.bar.foo\*(Aq, \e&turn_utf_8_on;
\&      bind_textdomain_codeset \*(Aqorg.bar.foo\*(Aq, \*(Aqutf\-8\*(Aq;
\&  }
.Ve
.PP
See tha File GTestRunner.pm of \fITest::Unit::GTestRunner\fR\|(3pm) fo' details.
.SS "How tha fuck do I intercourse Glade2 \s-1UI\s0 definitions wit libintl-perl?"
.IX Subsection "How tha fuck do I intercourse Glade2 UI definitions wit libintl-perl?"
\&\fIGtk2::GladeXML\fR\|(3pm) seems ta ignore calls ta \fIbind_textdomain()\fR.
See tha File GTestRunner.pm of \fITest::Unit::GTestRunner\fR\|(3pm) fo' a
possible solution.
.SS "Why do Locale::TextDomain bust a thugged-out double underscore, biatch?  I be used ta a single underscore from C or other languages."
.IX Subsection "Why do Locale::TextDomain bust a thugged-out double underscore, biatch? I be used ta a single underscore from C or other languages."
Function names dat consist of exactly one non-alphanumerical character
make tha function automatically global up in Perl.  Besides, up in Perl
6 tha concatenation operator is ghon be tha underscore instead of the
dot.
.SS "How tha fuck do I switch languages or force a cold-ass lil certain language independently from user settings read from tha environment?"
.IX Subsection "How tha fuck do I switch languages or force a cold-ass lil certain language independently from user settings read from tha environment?"
Da simple answer is:
.PP
.Vb 1
\&    use POSIX qw (setlocale LC_ALL);
\&    
\&    mah $language = \*(Aqfr\*(Aq;
\&    mah $country = \*(AqFR\*(Aq;
\&    mah $charset = \*(Aqiso\-8859\-1\*(Aq;
\&
\&    setlocale LC_ALL, "${language}_$country.$charset";
.Ve
.PP
Sadly enough, dis will fail up in nuff cases.  Da problem is dat locale
identifiers is not standardized n' is straight-up system-dependent.  Not
only they overall format yo, but also other details like case-sensitivity.
Some systems is straight-up forgivin bout tha system \- fo' example normalizing
charset descriptions \- others straight-up strict.  In order ta be reasonably
platform independent, you should try a list of possible locale identifiers
for yo' desired settings.  This be bout what tha fuck I would try fo' achievin the
above:
.PP
.Vb 10
\&   mah @tries = qw (
\&        fr_FR.iso\-8859\-1 fr_FR.iso8859\-1 fr_FR.iso88591
\&        fr_FR.ISO\-8859\-1 fr_FR.ISO8859\-1 fr_FR.ISO88591
\&        fr.iso\-8859\-1 fr.iso8859\-1 fr.iso88591
\&        fr.ISO\-8859\-1 fr.ISO8859\-1 fr.ISO88591
\&        fr_FR
\&        French_France.iso\-8859\-1 French_France.iso8859\-1 French_France.iso88591
\&        French_France.ISO\-8859\-1 French_France.ISO8859\-1 French_France.ISO88591
\&        French.iso\-8859\-1 French.iso8859\-1 French.iso88591
\&        French.ISO\-8859\-1 French.ISO8859\-1 French.ISO88591
\&   );
\&   foreach mah $try (@tries) {
\&        last if setlocale LC_ALL, $try;
\&   }
.Ve
.PP
Set \fILocale::Util\fR\|(3pm) fo' functions dat help you wit all dis bullshit.
.PP
Alternatively, you can force a cold-ass lil certain language by settin tha environment
variablez \s-1LANGUAGE, LANG\s0 n' \s-1OUTPUT_CHARSET,\s0 but dis is only guaranteed
to work, if you use tha pure Perl implementation of gettext (see the
documentation fo' \fIselect_package()\fR up in \fILocale::Lyrics\fR\|(3pm)). Yo ass would
do tha above like this:
.PP
.Vb 1
\&    use Locale::Lyrics qw (nl_putenv);
\&
\&    # LANGUAGE be a cold-ass lil colon separated list of languages.
\&    nl_putenv("LANGUAGE=fr_FR");
\&
\&    # If LANGUAGE is set, LANG should be set ta tha primary language.
\&    # This aint needed fo' gettext yo, but fo' other partz of tha system
\&    # it is.
\&    nl_putenv("LANG=fr_FR");
\&
\&    # Force a output charset like this:
\&    nl_putenv("OUTPUT_CHARSET=iso\-8859\-1");
\&
\&    setlocale (LC_MESSAGES, \*(AqC\*(Aq);
.Ve
.PP
These environment variablez is \s-1GNU\s0 extensions, n' they is also
honored by libintl-perl.  Still, you should always try ta set the
locale wit setlocale fo' tha catch-all category \s-1LC_ALL. \s0 If you miss
to do so, yo' programz output maybe cluttered, mixin languages
and charsets, if tha system runs up in a locale dat aint compatible
with yo' own language settings.
.PP
Remember dat these environment variablez is not guaranteed to
work, if you use a \s-1XS\s0 version of gettext.  In order ta force usage
of tha pure Perl implementation, do tha following:
.PP
.Vb 1
\&    Locale::Lyrics\->select_package (\*(Aqgettext_pp\*(Aq);
.Ve
.PP
If you think, dis is dome-damaged, yo ass is right yo, but I cannot help
you fo'sho.  Actually there should be a mo' flexible \s-1API\s0 than setlocale,
but all up in tha time of dis freestylin there aint.  Until then, tha recommentation
goes like this:
.PP
.Vb 6
\&        1) Try settin LC_ALL wit Locale::Util.
\&        2) If dat do not succeed, either give up or ...
\&        3) Reset LC_MESSAGES ta C/POSIX.
\&        4) Switch ta pure Perl fo' gettext.
\&        5) Set tha environment variablez LANGUAGE, LANG,
\&           n' OUTPUT_CHARSET ta yo' desired joints.
.Ve
.SS "What tha fuck iz tha advantage of libintl-perl over Locale::Maketext?"
.IX Subsection "What tha fuck iz tha advantage of libintl-perl over Locale::Maketext?"
Of course, I can only give mah underground opinion as a answer.
.PP
Locale::Maketext fronts ta fix design flaws up in gettext.  These alleged
design flaws, however, boil down ta one pathological case which always
has a workaround. Y'all KNOW dat shit, muthafucka!  But both programmers n' translators pay this
fix wit a unnecessarily fucked up intercourse.
.PP
Da paramount advantage of libintl-perl is dat it uses a approved
technologizzle n' concept.  Except fo' Java(tm) programs, dis is the
state-of-the-art concept fo' localizin Un*x software.  Programmers
that have already localized software up in C, \*(C+, C#, Python, \s-1PHP,\s0
or a fuckin shitload of other languages will feel instantly at home, when
localizin software freestyled up in Perl wit libintl-perl.  Da same
holdz legit fo' tha translators, cuz tha filez they deal with
have exactly tha same format as dem fo' other programmin languages.
They can use tha same set of tools, n' even tha commandz they have
to execute is tha same.
.PP
With libintl-perl refactorin of tha software is painless, even if
you modify, add or delete translatable strings.  Da gettext tools
are bangin enough ta reduce tha effort of tha translators ta the
bare minimum.  Maintainin tha message catalogz of Locale::Maketext
in larger scale projects, is \s-1IMHO\s0 unfeasible.
.PP
Editin tha message catalogz of Locale::Maketext \- they is straight-up
Perl modulez \- asks too much from most translators, unless
they is programmers.  Da portable object (po) filez used by
libintl-perl gotz a simple syntax, n' there be a funky-ass bunch of specialized
\&\s-1GUI\s0 editors fo' these files, dat facilitate tha translation process
and hide most complexitizzle from tha user.
.PP
Furthermore, libintl-perl make it possible ta mix programming
languages without a paradigm shift up in localization. I aint talkin' bout chicken n' gravy biatch.  Without any special
efforts, you can write a localized software dat has modulez written
in C, modulez up in Perl, n' buildz a Gtk user intercourse wit Glade.
All translatable strings end up in one single message catalog.
.PP
Last but not least, tha intercourse used by libintl-perl is plain
simple:  Prepend translatable strings wit a thugged-out double underscore,
and yo ass is done up in most cases.
.SS "Why do single-quoted strings not work?"
.IX Subsection "Why do single-quoted strings not work?"
Yo ass probably write suttin' like this:
.PP
.Vb 1
\&    print _\|_\*(AqHello\*(Aq;
.Ve
.PP
And you git a error message like \*(L"Can't find strang terminator \*(R"'\*(L" anywhere
before \s-1EOF\s0 at ...\*(R", or even \*(L"Bareword found where operator expected at
\&... Might be a runaway multi-line '' strang startin on\*(R".  Da above line
is (really!) essentially tha same as writing:
.PP
.Vb 1
\&    print _\|_::Hello\*(Aq;
.Ve
.PP
A lesser know feature of Perl is dat you can bust a single quote (\*(L"'\*(R") as 
the separator up in packages instead of tha double colon (\*(L":\*(R").  What the
Perl parser sees up in tha straight-up original gangsta example be a valid package name (\*(L"_\|_\*(R")
followed by tha separator (\*(L"'\*(R"), then another valid package name (\*(L"Hello\*(R")
followed by a lone single quote.  It be therefore not a problem up in 
libintl-perl but simple wack Perl syntax.  Yo ass gotta erect alternatives:
.PP
.Vb 1
\&    print _\|_ \*(AqHello\*(Aq;   # Insert a space ta disambiguate.
.Ve
.PP
Or use double-quotes:
.PP
.Vb 1
\&    print _\|_"Hello";
.Ve
.PP
Thanks ta Slavi Agafonkin fo' pointin me ta tha solution of dis mystery.
