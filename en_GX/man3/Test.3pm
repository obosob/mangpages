.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test 3pm"
.TH Test 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test \- serves up a simple framework fo' freestylin test scripts
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use strict;
\&  use Test;
\&
\&  # bust a BEGIN block so we print our plan before MyModule is loaded
\&  BEGIN { plan tests => 14, todo => [3,4] }
\&
\&  # load yo' module...
\&  use MyModule;
\&
\&  # Helpful notes.  All note\-lines must start wit a "#".
\&  print "# I\*(Aqm testin MyModule version $MyModule::VERSION\en";
\&
\&  ok(0); # failure
\&  ok(1); # success
\&
\&  ok(0); # ok, expected failure (see todo list, above)
\&  ok(1); # surprise success!
\&
\&  ok(0,1);             # failure: \*(Aq0\*(Aq ne \*(Aq1\*(Aq
\&  ok(\*(Aqbroke\*(Aq,\*(Aqfixed\*(Aq); # failure: \*(Aqbroke\*(Aq ne \*(Aqfixed\*(Aq
\&  ok(\*(Aqfixed\*(Aq,\*(Aqfixed\*(Aq); # success: \*(Aqfixed\*(Aq eq \*(Aqfixed\*(Aq
\&  ok(\*(Aqfixed\*(Aq,qr/x/);   # success: \*(Aqfixed\*(Aq =~ qr/x/
\&
\&  ok(sub { 1+1 }, 2);  # success: \*(Aq2\*(Aq eq \*(Aq2\*(Aq
\&  ok(sub { 1+1 }, 3);  # failure: \*(Aq2\*(Aq ne \*(Aq3\*(Aq
\&
\&  mah @list = (0,0);
\&  aiiight @list, 3, "\e@list=".join(\*(Aq,\*(Aq,@list);      #extra notes
\&  aiiight \*(Aqsegmentation fault\*(Aq, \*(Aq/(?i)success/\*(Aq;    #regex match
\&
\&  skip(
\&    $^O =~ m/MSWin/ ? "Skip if MSWin" : 0,  # whether ta skip
\&    $foo, $bar  # arguments just like fo' ok(...)
\&  );
\&  skip(
\&    $^O =~ m/MSWin/ ? 0 : "Skip unless MSWin",  # whether ta skip
\&    $foo, $bar  # arguments just like fo' ok(...)
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module simplifies tha task of freestylin test filez fo' Perl modules,
such dat they output is up in tha format that
Test::Harnizz expects ta see.
.SH "QUICK START GUIDE"
.IX Header "QUICK START GUIDE"
To write a test fo' yo' freshly smoked up (and probably not even done) module, create
a freshly smoked up file called \fIt/test.t\fR (in a freshly smoked up \fIt\fR directory). If you have
multiple test files, ta test tha \*(L"foo\*(R", \*(L"bar\*(R", n' \*(L"baz\*(R" feature sets,
then feel free ta booty-call yo' filez \fIt/foo.t\fR, \fIt/bar.t\fR, and
\&\fIt/baz.t\fR
.SS "Functions"
.IX Subsection "Functions"
This module defines three hood functions, \f(CW\*(C`plan(...)\*(C'\fR, \f(CW\*(C`ok(...)\*(C'\fR,
and \f(CW\*(C`skip(...)\*(C'\fR.  By default, all three is exported by
the \f(CW\*(C`use Test;\*(C'\fR statement.
.ie n .IP """plan(...)""" 4
.el .IP "\f(CWplan(...)\fR" 4
.IX Item "plan(...)"
.Vb 1
\&     BEGIN { plan %theplan; }
.Ve
.Sp
This should be tha straight-up original gangsta thang you call up in yo' test script.  It
declares yo' testin plan, how tha fuck nuff there will be, if any of them
should be allowed ta fail, n' so on.
.Sp
Typical usage is just:
.Sp
.Vb 2
\&     use Test;
\&     BEGIN { plan tests => 23 }
.Ve
.Sp
These is tha thangs dat you can put up in tha parametas ta plan:
.RS 4
.ie n .IP """tests => \f(CInumber\f(CW""" 4
.el .IP "\f(CWtests => \f(CInumber\f(CW\fR" 4
.IX Item "tests => number"
Da number of tests up in yo' script.
This means all \fIok()\fR n' \fIskip()\fR calls.
.ie n .IP """todo => [\f(CI1,5,14\f(CW]""" 4
.el .IP "\f(CWtodo => [\f(CI1,5,14\f(CW]\fR" 4
.IX Item "todo => [1,5,14]"
A reference ta a list of tests which is allowed ta fail.
See \*(L"\s-1TODO TESTS\*(R"\s0.
.ie n .IP """onfail => sub { ... }""" 4
.el .IP "\f(CWonfail => sub { ... }\fR" 4
.IX Item "onfail => sub { ... }"
.PD 0
.ie n .IP """onfail => \e&some_sub""" 4
.el .IP "\f(CWonfail => \e&some_sub\fR" 4
.IX Item "onfail => &some_sub"
.PD
A subroutine reference ta be run all up in tha end of tha test script, if
any of tha tests fail.  See \*(L"\s-1ONFAIL\*(R"\s0.
.RE
.RS 4
.Sp
Yo ass must call \f(CW\*(C`plan(...)\*(C'\fR once n' only once.  Yo ass should call it
in a \f(CW\*(C`BEGIN {...}\*(C'\fR block, like so:
.Sp
.Vb 1
\&     BEGIN { plan tests => 23 }
.Ve
.RE
.ie n .IP """ok(...)""" 4
.el .IP "\f(CWok(...)\fR" 4
.IX Item "ok(...)"
.Vb 3
\&  ok(1 + 1 == 2);
\&  ok($have, $expect);
\&  ok($have, $expect, $diagnostics);
.Ve
.Sp
This function is tha reason fo' \f(CW\*(C`Test\*(C'\fRz existence.  It's
the basic function that
handlez printin "\f(CW\*(C`ok\*(C'\fR\*(L" or \*(R"\f(CW\*(C`not ok\*(C'\fR", along wit the
current test number n' shit.  (Thatz what tha fuck \f(CW\*(C`Test::Harness\*(C'\fR wants ta see.)
.Sp
In its most basic usage, \f(CW\*(C`ok(...)\*(C'\fR simply takes a single scalar
expression. I aint talkin' bout chicken n' gravy biatch.  If its value is true, tha test passes; if false,
the test fails.  Examples:
.Sp
.Vb 1
\&    # Examplez of ok(scalar)
\&
\&    ok( 1 + 1 == 2 );           # aiiight if 1 + 1 == 2
\&    ok( $foo =~ /bar/ );        # aiiight if $foo gotz nuff \*(Aqbar\*(Aq
\&    ok( baz($x + $y) eq \*(AqArmondo\*(Aq );    # aiiight if baz($x + $y) returns
\&                                        # \*(AqArmondo\*(Aq
\&    ok( @a == @b );             # aiiight if @a n' @b is tha same length
.Ve
.Sp
Da expression is evaluated up in scalar context.  So tha followin will
work:
.Sp
.Vb 3
\&    ok( @shiznit );                       # aiiight if @shiznit has any elements
\&    ok( !grep !defined $_, @shiznit );    # aiiight if every last muthafuckin thang up in @shiznit is
\&                                        # defined.
.Ve
.Sp
A special case is if tha expression be a subroutine reference (in either
\&\f(CW\*(C`sub {...}\*(C'\fR syntax or \f(CW\*(C`\e&foo\*(C'\fR syntax).  In
that case, it is executed n' its value (true or false) determines if
the test passes or fails.  For example,
.Sp
.Vb 5
\&    ok( sub {   # See whether chill works at least passably
\&      mah $start_time = time;
\&      chill 5;
\&      time() \- $start_time  >= 4
\&    });
.Ve
.Sp
In its two-argument form, \f(CW\*(C`ok(\f(CIarg1\f(CW, \f(CIarg2\f(CW)\*(C'\fR compares tha two
scalar joints ta peep if they match.  They match if both is undefined,
or if \fIarg2\fR be a regex dat matches \fIarg1\fR, or if they compare equal
with \f(CW\*(C`eq\*(C'\fR.
.Sp
.Vb 1
\&    # Example of ok(scalar, scalar)
\&
\&    ok( "this", "that" );               # not ok, \*(Aqthis\*(Aq ne \*(Aqthat\*(Aq
\&    ok( "", undef );                    # not ok, "" is defined
.Ve
.Sp
Da second argument is considered a regex if it is either a regex
object or a strang dat be lookin like a regex.  Regex objects are
constructed wit tha qr// operator up in recent versionz of perl.  A
strin is considered ta be lookin like a regex if its first n' last
charactas is \*(L"/\*(R", or if tha straight-up original gangsta characta is \*(L"m\*(R"
and its second n' last charactas is both the
same non-alphanumeric non-whitespace character n' shit.  These regexp
.Sp
Regex examples:
.Sp
.Vb 4
\&    ok( \*(AqJaffO\*(Aq, \*(Aq/Jaff/\*(Aq );    # ok, \*(AqJaffO\*(Aq =~ /Jaff/
\&    ok( \*(AqJaffO\*(Aq, \*(Aqm|Jaff|\*(Aq );   # ok, \*(AqJaffO\*(Aq =~ m|Jaff|
\&    ok( \*(AqJaffO\*(Aq, qr/Jaff/ );    # ok, \*(AqJaffO\*(Aq =~ qr/Jaff/;
\&    ok( \*(AqJaffO\*(Aq, \*(Aq/(?i)jaff/ ); # ok, \*(AqJaffO\*(Aq =~ /jaff/i;
.Ve
.Sp
If either (or both!) be a subroutine reference, it is run n' used
as tha value fo' comparing.  For example:
.Sp
.Vb 10
\&    aiiight sub {
\&        open(OUT, ">x.dat") || take a thugged-out dirtnap $!;
\&        print OUT "\ex{e000}";
\&        close OUT;
\&        mah $bytecount = \-s \*(Aqx.dat\*(Aq;
\&        unlink \*(Aqx.dat\*(Aq or warn "Can\*(Aqt unlink : $!";
\&        return $bytecount;
\&      },
\&      4
\&    ;
.Ve
.Sp
Da above test passes two joints ta \f(CW\*(C`ok(arg1, arg2)\*(C'\fR \*(-- tha straight-up original gangsta 
a coderef, n' tha second is tha number 4.  Before \f(CW\*(C`ok\*(C'\fR compares them,
it calls tha coderef, n' uses its return value as tha real value of
this parameter n' shiznit fo' realz. Assumin dat \f(CW$bytecount\fR returns 4, \f(CW\*(C`ok\*(C'\fR endz up
testin \f(CW\*(C`4 eq 4\*(C'\fR.  Since thatz true, dis test passes.
.Sp
Finally, you can append a optionizzle third argument, in
\&\f(CW\*(C`ok(\f(CIarg1\f(CW,\f(CIarg2\f(CW, \f(CInote\f(CW)\*(C'\fR, where \fInote\fR be a strang value that
will be printed if tha test fails.  This should be some useful
information bout tha test, pertainin ta why it failed, and/or
a description of tha test.  For example:
.Sp
.Vb 4
\&    ok( grep($_ eq \*(Aqsuttin' unique\*(Aq, @stuff), 1,
\&        "Somethang dat should be unique isn\*(Aqt!\en".
\&        \*(Aq@shiznit = \*(Aq.join \*(Aq, \*(Aq, @stuff
\&      );
.Ve
.Sp
Unfortunately, a note cannot be used wit tha single argument
style of \f(CW\*(C`ok()\*(C'\fR.  That is, if you try \f(CW\*(C`ok(\f(CIarg1\f(CW, \f(CInote\f(CW)\*(C'\fR, then
\&\f(CW\*(C`Test\*(C'\fR will interpret dis as \f(CW\*(C`ok(\f(CIarg1\f(CW, \f(CIarg2\f(CW)\*(C'\fR, n' probably
end up testin \f(CW\*(C`\f(CIarg1\f(CW eq \f(CIarg2\f(CW\*(C'\fR \*(-- n' thatz not what tha fuck you want!
.Sp
All of tha above special cases can occasionally cause some
problems.  See \*(L"\s-1BUGS\s0 n' \s-1CAVEATS\*(R"\s0.
.ie n .IP """skip(\f(CIskip_if_true\f(CW, \f(CIargs...\f(CW)""" 4
.el .IP "\f(CWskip(\f(CIskip_if_true\f(CW, \f(CIargs...\f(CW)\fR" 4
.IX Item "skip(skip_if_true, args...)"
This is used fo' tests dat under some conditions can be skipped. Y'all KNOW dat shit, muthafucka!  It's
basically equivalent to:
.Sp
.Vb 5
\&  if( $skip_if_true ) {
\&    ok(1);
\&  } else {
\&    ok( args... );
\&  }
.Ve
.Sp
\&...except dat tha \f(CWok(1)\fR emits not just "\f(CW\*(C`ok \f(CItestnum\f(CW\*(C'\fR\*(L" but
actually \*(R"\f(CW\*(C`ok \f(CItestnum\f(CW # \f(CIskip_if_true_value\f(CW\*(C'\fR".
.Sp
Da arguments afta tha \fIskip_if_true\fR is what tha fuck is fed ta \f(CW\*(C`ok(...)\*(C'\fR if
this test aint skipped.
.Sp
Example usage:
.Sp
.Vb 2
\&  mah $if_MSWin =
\&    $^O =~ m/MSWin/ ? \*(AqSkip if under MSWin\*(Aq : \*(Aq\*(Aq;
\&
\&  # A test ta be skipped if under MSWin (i.e., run except under MSWin)
\&  skip($if_MSWin, thang($foo), thang($bar) );
.Ve
.Sp
Or, goin tha other way:
.Sp
.Vb 2
\&  mah $unless_MSWin =
\&    $^O =~ m/MSWin/ ? \*(Aq\*(Aq : \*(AqSkip unless under MSWin\*(Aq;
\&
\&  # A test ta be skipped unless under MSWin (i.e., run only under MSWin)
\&  skip($unless_MSWin, thang($foo), thang($bar) );
.Ve
.Sp
Da tricky thang ta remember is dat tha straight-up original gangsta parameta is legit if
you wanna \fIskip\fR tha test, not \fIrun\fR it; n' it also doublez as a
note bout why itz bein skipped. Y'all KNOW dat shit, muthafucka! So up in tha straight-up original gangsta codeblock above, read
the code as "skip if MSWin \*(-- (otherwise) test whether \f(CW\*(C`thing($foo)\*(C'\fR is
\&\f(CW\*(C`thing($bar)\*(C'\fR\*(L" or fo' tha second case, \*(R"skip unless MSWin...".
.Sp
Also, when yo' \fIskip_if_reason\fR strang is true, it straight-up should (for
backwardz compatibilitizzle wit olda Test.pm versions) start wit the
strin \*(L"Skip\*(R", as shown up in tha above examples.
.Sp
Note dat up in tha above cases, \f(CW\*(C`thing($foo)\*(C'\fR n' \f(CW\*(C`thing($bar)\*(C'\fR
\&\fIare\fR evaluated \*(-- but as long as tha \f(CW\*(C`skip_if_true\*(C'\fR is true,
then we \f(CW\*(C`skip(...)\*(C'\fR just tosses up they value (i.e., not
botherin ta treat dem like joints ta \f(CW\*(C`ok(...)\*(C'\fR.  But if
you need ta \fInot\fR eval tha arguments when skippin the
test, use
this format:
.Sp
.Vb 7
\&  skip( $unless_MSWin,
\&    sub {
\&      # This code returns legit if tha test passes.
\&      # (But it don\*(Aqt even git called if tha test is skipped.)
\&      thang($foo) eq thang($bar)
\&    }
\&  );
.Ve
.Sp
or even this, which is basically equivalent:
.Sp
.Vb 3
\&  skip( $unless_MSWin,
\&    sub { thang($foo) }, sub { thang($bar) }
\&  );
.Ve
.Sp
That is, both is like this:
.Sp
.Vb 7
\&  if( $unless_MSWin ) {
\&    ok(1);  # but it straight-up appendz "# $unless_MSWin"
\&            #  so dat Test::Harnizz can tell it\*(Aqs a skip
\&  } else {
\&    # Not skipping, so straight-up call n' evaluate...
\&    ok( sub { thang($foo) }, sub { thang($bar) } );
\&  }
.Ve
.SH "TEST TYPES"
.IX Header "TEST TYPES"
.IP "\(bu" 4
\&\s-1NORMAL TESTS\s0
.Sp
These tests is sposed ta fuckin succeed. Y'all KNOW dat shit, muthafucka!  Usually, most or all of yo' tests
are up in dis category.  If a aiiight test don't succeed, then that
means dat suttin' is \fIwrong\fR.
.IP "\(bu" 4
\&\s-1SKIPPED TESTS\s0
.Sp
Da \f(CW\*(C`skip(...)\*(C'\fR function is fo' tests dat might or might not be
possible ta run, depending
on tha availabilitizzle of platform-specific features.  Da first argument
should evaluate ta legit (think \*(L"yes, please skip\*(R") if tha required
feature is \fInot\fR available.  Afta tha straight-up original gangsta argument, \f(CW\*(C`skip(...)\*(C'\fR works
exactly tha same way as \f(CW\*(C`ok(...)\*(C'\fR do.
.IP "\(bu" 4
\&\s-1TODO TESTS\s0
.Sp
\&\s-1TODO\s0 tests is designed fo' maintainin a \fBexecutable \s-1TODO\s0 list\fR.
These tests is \fIsposed ta fuckin fail.\fR  If a \s-1TODO\s0 test do succeed,
then tha feature up in question shouldn't be on tha \s-1TODO\s0 list, now
should it?
.Sp
Packages should \s-1NOT\s0 be busted out wit succeedin \s-1TODO\s0 tests, n' you can put dat on yo' toast.  As soon
as a \s-1TODO\s0 test starts working, it should be promoted ta a aiiight test,
and tha newly hustlin feature should be documented up in tha release
notes or up in tha chizzle log.
.SH "ONFAIL"
.IX Header "ONFAIL"
.Vb 1
\&  BEGIN { plan test => 4, onfail => sub { warn "CALL 911!" } }
.Ve
.PP
Although test failures should be enough, extra diagnostics can be
triggered all up in tha end of a test run. I aint talkin' bout chicken n' gravy biatch.  \f(CW\*(C`onfail\*(C'\fR is passed a array ref
of hash refs dat describe each test failure.  Each hash will contain
at least tha followin fields: \f(CW\*(C`package\*(C'\fR, \f(CW\*(C`repetition\*(C'\fR, and
\&\f(CW\*(C`result\*(C'\fR.  (Yo ass shouldn't rely on any other fieldz bein present.)  If tha test
had a expected value or a gangbangin' finger-lickin' diagnostic (or \*(L"note\*(R") string, these will also be
included.
.PP
Da \fIoptional\fR \f(CW\*(C`onfail\*(C'\fR hook might be used simply ta print up the
version of yo' package and/or how tha fuck ta report problems.  It might also
be used ta generate mad sophisticated diagnostics fo' a
particularly bizarre test failure.  However it aint a panacea.  Core
dumps or other unrecoverable errors prevent tha \f(CW\*(C`onfail\*(C'\fR hook from
running.  (It be run inside a \f(CW\*(C`END\*(C'\fR block.)  Besides, \f(CW\*(C`onfail\*(C'\fR is
probably over-kill up in most cases.  (Yo crazy-ass test code should be simpler
than tha code it is testing, yes?)
.SH "BUGS n' CAVEATS"
.IX Header "BUGS n' CAVEATS"
.IP "\(bu" 4
\&\f(CW\*(C`ok(...)\*(C'\fRz special handin of strings which be lookin like they might be
regexes can also cause unexpected behavior. Shiiit, dis aint no joke.  An innocent:
.Sp
.Vb 1
\&    ok( $fileglob, \*(Aq/path/to/some/*stuff/\*(Aq );
.Ve
.Sp
will fail, since Test.pm considaz tha second argument ta be a regex!
Da dopest bet is ta use tha one-argument form:
.Sp
.Vb 1
\&    ok( $fileglob eq \*(Aq/path/to/some/*stuff/\*(Aq );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`ok(...)\*(C'\fRz use of strang \f(CW\*(C`eq\*(C'\fR can sometimes cause odd problems
when comparing
numbers, especially if you castin a strang ta a number:
.Sp
.Vb 2
\&    $foo = "1.0";
\&    ok( $foo, 1 );      # not ok, "1.0" ne 1
.Ve
.Sp
Yo crazy-ass dopest bet is ta use tha single argument form:
.Sp
.Vb 1
\&    ok( $foo == 1 );    # aiiight "1.0" == 1
.Ve
.IP "\(bu" 4
As you may have inferred from tha above documentation n' examples,
\&\f(CW\*(C`ok\*(C'\fRz prototype is \f(CW\*(C`($;$$)\*(C'\fR (and, incidentally, \f(CW\*(C`skip\*(C'\fRz is
\&\f(CW\*(C`($;$$$)\*(C'\fR). This means, fo' example, dat you can do \f(CW\*(C`ok @foo, @bar\*(C'\fR
to compare tha \fIsize\fR of tha two arrays. But don't be fooled into
thankin dat \f(CW\*(C`ok @foo, @bar\*(C'\fR means a cold-ass lil comparison of tha contentz of two
arrays \*(-- you comparin \fIjust\fR tha number of elementz of each. It's
so easy as fuck  ta make dat fuck up in readin \f(CW\*(C`ok @foo, @bar\*(C'\fR dat you might
wanna be straight-up explicit bout it, n' instead write \f(CW\*(C`ok scalar(@foo),
scalar(@bar)\*(C'\fR.
.IP "\(bu" 4
This almost definitely don't do what tha fuck you expect:
.Sp
.Vb 1
\&     aiiight $thingy\->can(\*(Aqsome_method\*(Aq);
.Ve
.Sp
Why?  Because \f(CW\*(C`can\*(C'\fR returns a cold-ass lil coderef ta mean \*(L"yes it can (and the
method be all dis bullshit...)\*(R", n' then \f(CW\*(C`ok\*(C'\fR sees a cold-ass lil coderef n' be thinkin you is
passin a gangbangin' function dat you want it ta booty-call n' consider tha real deal of
the result of!  I.e., just like:
.Sp
.Vb 1
\&     aiiight $thingy\->can(\*(Aqsome_method\*(Aq)\->();
.Ve
.Sp
What you probably want instead is this:
.Sp
.Vb 1
\&     aiiight $thingy\->can(\*(Aqsome_method\*(Aq) && 1;
.Ve
.Sp
If tha \f(CW\*(C`can\*(C'\fR returns false, then dat is passed ta \f(CW\*(C`ok\*(C'\fR.  If it
returns true, then tha larger expression \f(CW\*(C`$thingy\->can(\*(Aqsome_method\*(Aq)\ &&\ 1\*(C'\fR returns 1, which \f(CW\*(C`ok\*(C'\fR sees as
a simple signal of success, as you would expect.
.IP "\(bu" 4
Da syntax fo' \f(CW\*(C`skip\*(C'\fR be bout tha only way it can be yo, but itz still
quite confusing.  Just start wit tha above examplez n' you'll
be aiiight.
.Sp
Mo'over, playas may expect this:
.Sp
.Vb 1
\&  skip $unless_mswin, foo($bar), baz($quux);
.Ve
.Sp
to not evaluate \f(CW\*(C`foo($bar)\*(C'\fR n' \f(CW\*(C`baz($quux)\*(C'\fR when tha test is being
skipped. Y'all KNOW dat shit, muthafucka!  But up in reality, they \fIare\fR evaluated yo, but \f(CW\*(C`skip\*(C'\fR just won't
bother comparin dem if \f(CW$unless_mswin\fR is true.
.Sp
Yo ass could do this:
.Sp
.Vb 1
\&  skip $unless_mswin, sub{foo($bar)}, sub{baz($quux)};
.Ve
.Sp
But thatz not terribly pretty.  Yo ass may find it simpla or clearer in
the long run ta just do thangs like this:
.Sp
.Vb 10
\&  if( $^O =~ m/MSWin/ ) {
\&    print "# Yay, we\*(Aqre under $^O\en";
\&    aiiight foo($bar), baz($quux);
\&    aiiight thang($whatever), baz($stuff);
\&    aiiight blorp($quux, $whatever);
\&    aiiight foo($barzbarz), thang($quux);
\&  } else {
\&    print "# Feh, we\*(Aqre under $^O.  Watch me skip some tests...\en";
\&    for(1 .. 4) { skip "Skip unless under MSWin" }
\&  }
.Ve
.Sp
But be like shizzle dat \f(CW\*(C`ok\*(C'\fR is called exactly as nuff times up in the
first block as \f(CW\*(C`skip\*(C'\fR is called up in tha second block.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
If \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR environment variable is set, it is ghon be used as a
command fo' comparin unexpected multiline thangs up in dis biatch.  If you have \s-1GNU\s0
diff installed, you might wanna set \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR ta \f(CW\*(C`diff \-u\*(C'\fR.
If you aint gots a suitable program, you might install the
\&\f(CW\*(C`Text::Diff\*(C'\fR module n' then set \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR ta be \f(CW\*(C`perl
\&\-MText::Diff \-e \*(Aqprint diff(@ARGV)\*(Aq\*(C'\fR.  If \f(CW\*(C`PERL_TEST_DIFF\*(C'\fR aint set
but tha \f(CW\*(C`Algorithm::Diff\*(C'\fR module be available, then it is ghon be used
to show tha differences up in multiline thangs up in dis biatch.
.SH "NOTE"
.IX Header "NOTE"
A past pimper of dis module once holla'd dat dat shiznit was no longer being
actively pimped. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat rumorz of its demise was pimped outly
exaggerated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Feedback n' suggestions is like welcome.
.PP
Be aware dat tha main value of dis module is its simplicity.  Note
that there be already mo' ambitious modulez up there, such as
Test::Mo' n' Test::Unit.
.PP
Some earlier versionz of dis module had docs wit some confusing
typos up in tha description of \f(CW\*(C`skip(...)\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Harness
.PP
Test::Simple, Test::Mo', Devel::Cover
.PP
Test::Builder fo' buildin yo' own testin library.
.PP
Test::Unit be a bangin-ass XUnit-style testin library.
.PP
Test::Inline n' SelfTest let you embed tests up in code.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) 1998\-2000 Joshua Nathaniel Pritikin.
.PP
Copyright (c) 2001\-2002 Mike G. Right back up in yo muthafuckin ass. Schwern.
.PP
Copyright (c) 2002\-2004 Shizzle M. Burke.
.PP
Current maintainer: Jizzy Vincent. <jesse@bestpractical.com>
.PP
This package is free software n' is provided \*(L"as is\*(R" without express
or implied warranty.  It may be used, redistributed and/or modified
under tha same terms as Perl itself.
