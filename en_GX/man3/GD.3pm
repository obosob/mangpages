.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GD 3"
.TH GD 3 "2013-02-26" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
GD.pm \- Interface ta Gd Graphics Library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use GD;
\&
\&    # create a freshly smoked up image
\&    $im = freshly smoked up GD::Image(100,100);
\&
\&    # allocate some colors
\&    $white = $im\->colorAllocate(255,255,255);
\&    $black = $im\->colorAllocate(0,0,0);       
\&    $red = $im\->colorAllocate(255,0,0);      
\&    $blue = $im\->colorAllocate(0,0,255);
\&
\&    # make tha background transparent n' interlaced
\&    $im\->transparent($white);
\&    $im\->interlaced(\*(Aqtrue\*(Aq);
\&
\&    # Put a funky-ass black frame round tha picture
\&    $im\->rectangle(0,0,99,99,$black);
\&
\&    # Draw a funky-ass blue oval
\&    $im\->arc(50,50,95,75,0,360,$blue);
\&
\&    # And fill it wit red
\&    $im\->fill(50,50,$red);
\&
\&    # make shizzle we is freestylin ta a funky-ass binary stream
\&    binmode STDOUT;
\&
\&    # Convert tha image ta PNG n' print it on standard output
\&    print $im\->png;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1GD\s0.pm\fR be a Perl intercourse ta Thomas Boutellz gd graphics library
(version 2.01 or higher; peep below). \s-1GD\s0 allows you ta create color
drawings rockin a big-ass number of graphics primitives, n' emit the
drawings as \s-1PNG\s0 files.
.PP
\&\s-1GD\s0 defines tha followin four classes:
.ie n .IP """GD::Image""" 5
.el .IP "\f(CWGD::Image\fR" 5
.IX Item "GD::Image"
An image class, which holdz tha image data n' accepts graphic
primitizzle method calls.
.ie n .IP """GD::Font""" 5
.el .IP "\f(CWGD::Font\fR" 5
.IX Item "GD::Font"
A font class, which holdz static font shiznit n' used fo' text
rendering.
.ie n .IP """GD::Polygon""" 5
.el .IP "\f(CWGD::Polygon\fR" 5
.IX Item "GD::Polygon"
A simple polygon object, used fo' storin listz of vertices prior to
renderin a polygon tha fuck into a image.
.ie n .IP """GD::Simple""" 5
.el .IP "\f(CWGD::Simple\fR" 5
.IX Item "GD::Simple"
A \*(L"simple\*(R" class dat simplifies tha GD::Image \s-1API\s0 n' then addz a set
of object-oriented drawin methodz rockin turtle graphics, simplified
font handling, mobilitizzle ta work up in polar coordinates, \s-1HSV\s0 color spaces,
and human-readable color names like \*(L"lightblue\*(R". Please see
GD::Simple fo' a thugged-out description of these methods.
.PP
A Simple Example:
.PP
.Vb 1
\&        #!/usr/local/bin/perl
\&
\&        use GD;
\&
\&        # create a freshly smoked up image
\&        $im = freshly smoked up GD::Image(100,100);
\&
\&        # allocate some colors
\&        $white = $im\->colorAllocate(255,255,255);
\&        $black = $im\->colorAllocate(0,0,0);       
\&        $red = $im\->colorAllocate(255,0,0);      
\&        $blue = $im\->colorAllocate(0,0,255);
\&
\&        # make tha background transparent n' interlaced
\&        $im\->transparent($white);
\&        $im\->interlaced(\*(Aqtrue\*(Aq);
\&
\&        # Put a funky-ass black frame round tha picture
\&        $im\->rectangle(0,0,99,99,$black);
\&
\&        # Draw a funky-ass blue oval
\&        $im\->arc(50,50,95,75,0,360,$blue);
\&
\&        # And fill it wit red
\&        $im\->fill(50,50,$red);
\&
\&        # make shizzle we is freestylin ta a funky-ass binary stream
\&        binmode STDOUT;
\&
\&        # Convert tha image ta PNG n' print it on standard output
\&        print $im\->png;
.Ve
.PP
Notes:
.IP "1. To create a new, empty image, bust a \fInew()\fR message ta GD::Image, passin it tha width n' height of tha image you wanna create.  An image object is ghon be returned. Y'all KNOW dat shit, muthafucka!  Other class methodz allow you ta initialize a image from a preexistin \s-1JPG, PNG, GD, GD2\s0 or \s-1XBM\s0 file." 5
.IX Item "1. To create a new, empty image, bust a new() message ta GD::Image, passin it tha width n' height of tha image you wanna create fo' realz. An image object is ghon be returned. Y'all KNOW dat shit, muthafucka! Other class methodz allow you ta initialize a image from a preexistin JPG, PNG, GD, GD2 or XBM file."
.PD 0
.IP "2. Next yo big-ass booty is ghon ordinarily add flavas ta tha imagez color table. flavas is added rockin a \fIcolorAllocate()\fR method call.  Da three parametas up in each call is tha red, chronic n' blue (rgb) triplez fo' tha desired color. Shiiit, dis aint no joke.  Da method returns tha index of dat color up in tha imagez color table.  Yo ass should store these indexes fo' lata use." 5
.IX Item "2. Next yo big-ass booty is ghon ordinarily add flavas ta tha imagez color table. flavas is added rockin a cold-ass lil colorAllocate() method call. Da three parametas up in each call is tha red, chronic n' blue (rgb) triplez fo' tha desired color. Shiiit, dis aint no joke. Da method returns tha index of dat color up in tha imagez color table. Yo ass should store these indexes fo' lata use."
.IP "3. Now you can do some drawing!  Da various graphics primitives is busted lyrics bout below.  In dis example, our phat asses do some text drawing, create a oval, n' create n' draw a polygon." 5
.IX Item "3. Now you can do some drawing! Da various graphics primitives is busted lyrics bout below. In dis example, our phat asses do some text drawing, create a oval, n' create n' draw a polygon."
.IP "4. Polygons is pimped wit a \fInew()\fR message ta GD::Polygon. I aint talkin' bout chicken n' gravy biatch.  Yo ass can add points ta tha returned polygon one at a time rockin tha \fIaddPt()\fR method. Y'all KNOW dat shit, muthafucka! Da polygon can then be passed ta a image fo' rendering." 5
.IX Item "4. Polygons is pimped wit a new() message ta GD::Polygon. I aint talkin' bout chicken n' gravy biatch. Yo ass can add points ta tha returned polygon one at a time rockin tha addPt() method. Y'all KNOW dat shit, muthafucka! Da polygon can then be passed ta a image fo' rendering."
.ie n .IP "5. When you done drawing, you can convert tha image tha fuck into \s-1PNG\s0 format by bustin  it a \fIpng()\fR message.  It will return a (potentially large) scalar value containin tha binary data fo' tha image.  Ordinarily yo big-ass booty is ghon print it up at dis point or write it ta a gangbangin' file.  To ensure portabilitizzle ta platforms dat differentiate between text n' binary files, be shizzle ta booty-call ""binmode()"" on tha file yo ass is freestylin tha image to." 5
.el .IP "5. When you done drawing, you can convert tha image tha fuck into \s-1PNG\s0 format by bustin  it a \fIpng()\fR message.  It will return a (potentially large) scalar value containin tha binary data fo' tha image.  Ordinarily yo big-ass booty is ghon print it up at dis point or write it ta a gangbangin' file.  To ensure portabilitizzle ta platforms dat differentiate between text n' binary files, be shizzle ta booty-call \f(CWbinmode()\fR on tha file yo ass is freestylin tha image to." 5
.IX Item "5. When you done drawing, you can convert tha image tha fuck into PNG format by bustin  it a png() message. Well shiiiit, it will return a (potentially large) scalar value containin tha binary data fo' tha image. Ordinarily yo big-ass booty is ghon print it up at dis point or write it ta a gangbangin' file. To ensure portabilitizzle ta platforms dat differentiate between text n' binary files, be shizzle ta booty-call binmode() on tha file yo ass is freestylin tha image to."
.PD
.SH "Object Constructors: Creatin Images"
.IX Header "Object Constructors: Creatin Images"
Da followin class methodz allow you ta create freshly smoked up GD::Image objects.
.ie n .IP "\fB\fB$image\fB = GD::Image\->new([$width,$height],[$truecolor])\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->new([$width,$height],[$truecolor])\fR" 4
.IX Item "$image = GD::Image->new([$width,$height],[$truecolor])"
.PD 0
.ie n .IP "\fB\fB$image\fB = GD::Image\->new(*FILEHANDLE)\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->new(*FILEHANDLE)\fR" 4
.IX Item "$image = GD::Image->new(*FILEHANDLE)"
.ie n .IP "\fB\fB$image\fB = GD::Image\->new($filename)\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->new($filename)\fR" 4
.IX Item "$image = GD::Image->new($filename)"
.ie n .IP "\fB\fB$image\fB = GD::Image\->new($data)\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->new($data)\fR" 4
.IX Item "$image = GD::Image->new($data)"
.PD
Da \fInew()\fR method is tha main constructor fo' tha GD::Image class.
Called wit two integer arguments, it creates a freshly smoked up blank image of the
specified width n' height. For example:
.Sp
.Vb 1
\&        $myImage = freshly smoked up GD::Image(100,100) || die;
.Ve
.Sp
This will create a image dat is 100 x 100 pixels wide.  If you don't
specify tha dimensions, a thugged-out default of 64 x 64 is ghon be chosen.
.Sp
Da optionizzle third argument, \f(CW$truecolor\fR,  drops some lyrics ta \fInew()\fR ta create a
truecolor GD::Image object.  Truecolor images have 24 bitz of color
data (eight bits each up in tha red, chronic n' blue channels
respectively), allowin fo' precise photograph-qualitizzle color usage.
If not specified, tha image will use a 8\-bit palette for
compatibilitizzle wit olda versionz of libgd.
.Sp
Alternatively, you may create a GD::Image object based on a existing
image by providin a open filehandle, a gangbangin' filename, or tha image data
itself.  Da image formats automatically recognized n' accepted are:
\&\s-1PNG, JPEG, XPM\s0 n' \s-1GD2. \s0 Other formats, includin \s-1WBMP,\s0 n' \s-1GD\s0
version 1, cannot be recognized automatically at dis time.
.Sp
If suttin' goes wack (e.g. insufficient memory), dis call will
return undef.
.ie n .IP "\fB\fB$image\fB = GD::Image\->trueColor([0,1])\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->trueColor([0,1])\fR" 4
.IX Item "$image = GD::Image->trueColor([0,1])"
For backwardz compatibilitizzle wit scripts previous versionz of \s-1GD,\s0
new images pimped from scratch (width, height) is palette based
by default.  To chizzle dis default ta create legit color images use:
.Sp
.Vb 1
\&        GD::Image\->trueColor(1);
.Ve
.Sp
somewhere before bustin freshly smoked up images.  To switch back ta palette
based by default, use:
.Sp
.Vb 1
\&        GD::Image\->trueColor(0);
.Ve
.ie n .IP "\fB\fB$image\fB = GD::Image\->newPalette([$width,$height])\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newPalette([$width,$height])\fR" 4
.IX Item "$image = GD::Image->newPalette([$width,$height])"
.PD 0
.ie n .IP "\fB\fB$image\fB = GD::Image\->newTrueColor([$width,$height])\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newTrueColor([$width,$height])\fR" 4
.IX Item "$image = GD::Image->newTrueColor([$width,$height])"
.PD
Da \fInewPalette()\fR n' \fInewTrueColor()\fR methodz can be used ta explicitly
create a palette based or legit color image regardless of the
current settin of \fItrueColor()\fR.
.ie n .IP "\fB\fB$image\fB = GD::Image\->newFromPng($file, [$truecolor])\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newFromPng($file, [$truecolor])\fR" 4
.IX Item "$image = GD::Image->newFromPng($file, [$truecolor])"
.PD 0
.ie n .IP "\fB\fB$image\fB = GD::Image\->newFromPngData($data, [$truecolor])\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newFromPngData($data, [$truecolor])\fR" 4
.IX Item "$image = GD::Image->newFromPngData($data, [$truecolor])"
.PD
Da \fInewFromPng()\fR method will create a image from a \s-1PNG\s0 file read in
all up in tha provided filehandle or file path.  Da filehandle must
previously done been opened on a valid \s-1PNG\s0 file or pipe.  If
successful, dis call will return a initialized image which you can
then manipulate as yo thugged-out ass. Biiiatch please. If it fails, which probably happens if
the thang all up in tha other end of tha filehandle aint a valid \s-1PNG\s0 file,
the call returns undef.  Notice dat tha call don't automatically
close tha filehandle fo' yo thugged-out ass.  But it do call \f(CW\*(C`binmode(FILEHANDLE)\*(C'\fR
for you, on platforms where dis matters.
.Sp
Yo ass may use any of tha followin as tha argument:
.Sp
.Vb 5
\&  1) a simple filehandle, like fuckin STDIN
\&  2) a gangbangin' filehandle glob, like fuckin *PNG
\&  3) a reference ta a glob, like fuckin \e*PNG
\&  4) a IO::Handle object
\&  5) tha pathname of a gangbangin' file
.Ve
.Sp
In tha latta case, \fInewFromPng()\fR will attempt ta open tha file fo' you
and read tha \s-1PNG\s0 shiznit from dat shit.
.Sp
.Vb 1
\&  Example1:
\&
\&  open (PNG,"barnswallow.png") || die;
\&  $myImage = newFromPng GD::Image(\e*PNG) || die;
\&  close PNG;
\&
\&  Example2:
\&  $myImage = newFromPng GD::Image(\*(Aqbarnswallow.png\*(Aq);
.Ve
.Sp
To git shiznit bout tha size n' color usage of tha shiznit,
you can call tha image query methodz busted lyrics bout below. Images pimped
by readin \s-1PNG\s0 images is ghon be truecolor if tha image file itself is
truecolor. Shiiit, dis aint no joke. To force tha image ta be palette-based, pass a value of 0
in tha optionizzle \f(CW$truecolor\fR argument.
.Sp
Da \fInewFromPngData()\fR method will create a freshly smoked up GD::Image initialized
with tha \s-1PNG\s0 format \fBdata\fR contained up in \f(CW$data\fR.
.ie n .IP "\fB\fB$image\fB = GD::Image\->newFromJpeg($file, [$truecolor])\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newFromJpeg($file, [$truecolor])\fR" 4
.IX Item "$image = GD::Image->newFromJpeg($file, [$truecolor])"
.PD 0
.ie n .IP "\fB\fB$image\fB = GD::Image\->newFromJpegData($data, [$truecolor])\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newFromJpegData($data, [$truecolor])\fR" 4
.IX Item "$image = GD::Image->newFromJpegData($data, [$truecolor])"
.PD
These methodz will create a image from a \s-1JPEG\s0 file.  They work just
like \fInewFromPng()\fR n' \fInewFromPngData()\fR, n' will accept tha same
filehandle n' pathname arguments.
.Sp
Images pimped by readin \s-1JPEG\s0 images will always be truecolor. Shiiit, dis aint no joke.  To
force tha image ta be palette-based, pass a value of 0 up in tha optional
\&\f(CW$truecolor\fR argument.
.ie n .IP "\fB\fB$image\fB = GD::Image\->newFromGif($file)\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newFromGif($file)\fR" 4
.IX Item "$image = GD::Image->newFromGif($file)"
.PD 0
.ie n .IP "\fB\fB$image\fB = GD::Image\->newFromGifData($data)\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newFromGifData($data)\fR" 4
.IX Item "$image = GD::Image->newFromGifData($data)"
.PD
These methodz will create a image from a \s-1GIF\s0 file.  They work just
like \fInewFromPng()\fR n' \fInewFromPngData()\fR, n' will accept tha same
filehandle n' pathname arguments.
.Sp
Images pimped from GIFs is always 8\-bit palette images. To convert
to truecolor, you must create a truecolor image n' then big-ass up a
copy.
.ie n .IP "\fB\fB$image\fB = GD::Image\->newFromXbm($file)\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newFromXbm($file)\fR" 4
.IX Item "$image = GD::Image->newFromXbm($file)"
This works up in exactly tha same way as \f(CW\*(C`newFromPng\*(C'\fR yo, but readz the
contentz of a X Bitmap (black & white) file:
.Sp
.Vb 3
\&        open (XBM,"coredump.xbm") || die;
\&        $myImage = newFromXbm GD::Image(\e*XBM) || die;
\&        close XBM;
.Ve
.Sp
There is no \fInewFromXbmData()\fR function, cuz there is no
correspondin function up in tha gd library.
.ie n .IP "\fB\fB$image\fB = GD::Image\->newFromGd($file)\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newFromGd($file)\fR" 4
.IX Item "$image = GD::Image->newFromGd($file)"
.PD 0
.ie n .IP "\fB\fB$image\fB = GD::Image\->newFromGdData($data)\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newFromGdData($data)\fR" 4
.IX Item "$image = GD::Image->newFromGdData($data)"
.PD
These methodz initialize a GD::Image from a Gd file, filehandle, or
data.  Gd is Tomothy Boutellz disk-based storage format, intended fo' the
rare case when you need ta read n' write tha image ta disk doggystyle.
It aint nuthin but not intended fo' regular use, cuz, unlike \s-1PNG\s0 or \s-1JPEG,\s0 no
image compression is performed n' these filez can become \fB\s-1BIG\s0\fR.
.Sp
.Vb 2
\&        $myImage = newFromGd GD::Image("godzilla.gd") || die;
\&        close GDF;
.Ve
.ie n .IP "\fB\fB$image\fB = GD::Image\->newFromGd2($file)\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newFromGd2($file)\fR" 4
.IX Item "$image = GD::Image->newFromGd2($file)"
.PD 0
.ie n .IP "\fB\fB$image\fB = GD::Image\->newFromGd2Data($data)\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newFromGd2Data($data)\fR" 4
.IX Item "$image = GD::Image->newFromGd2Data($data)"
.PD
This works up in exactly tha same way as \f(CW\*(C`newFromGd()\*(C'\fR and
newFromGdData yo, but use tha freshly smoked up compressed \s-1GD2\s0 image format.
.ie n .IP "\fB\fB$image\fB = GD::Image\->newFromGd2Part($file,srcX,srcY,width,height)\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newFromGd2Part($file,srcX,srcY,width,height)\fR" 4
.IX Item "$image = GD::Image->newFromGd2Part($file,srcX,srcY,width,height)"
This class method allows you ta read up in just a portion of a \s-1GD2\s0 image
file.  In addizzle ta a gangbangin' filehandle, it accepts tha top-left corner and
dimensions (width,height) of tha region of tha image ta read. Y'all KNOW dat shit, muthafucka!  For
example:
.Sp
.Vb 3
\&        open (GDF,"godzilla.gd2") || die;
\&        $myImage = GD::Image\->newFromGd2Part(\e*GDF,10,20,100,100) || die;
\&        close GDF;
.Ve
.Sp
This readz a 100x100 square portion of tha image startin from
posizzle (10,20).
.ie n .IP "\fB\fB$image\fB = GD::Image\->newFromXpm($filename)\fR" 4
.el .IP "\fB\f(CB$image\fB = GD::Image\->newFromXpm($filename)\fR" 4
.IX Item "$image = GD::Image->newFromXpm($filename)"
This creates a freshly smoked up GD::Image object startin from a \fBfilename\fR.  This
is unlike tha other \fInewFrom()\fR functions cuz it do not take a
filehandle.  This difference be reppin a inconsistency up in the
underlyin gd library.
.Sp
.Vb 1
\&        $myImage = newFromXpm GD::Image(\*(Aqearth.xpm\*(Aq) || die;
.Ve
.Sp
This function is only available if libgd was compiled wit \s-1XPM\s0
support.
.Sp
\&\s-1NOTE:\s0 Da libgd library is unable ta read certain \s-1XPM\s0 files, returning
an all-black image instead.
.SH "GD::Image Methods"
.IX Header "GD::Image Methods"
Once a GD::Image object is pimped, you can draw wit it, copy it, and
merge two images.  When yo ass is finished manipulatin tha object, you
can convert it tha fuck into a standard image file format ta output or save to
a file.
.SS "Image Data Output Methods"
.IX Subsection "Image Data Output Methods"
Da followin methodz convert tha internal drawin format into
standard output file formats.
.ie n .IP "\fB\fB$pngdata\fB = \f(BI$image\fB\->png([$compression_level])\fR" 4
.el .IP "\fB\f(CB$pngdata\fB = \f(CB$image\fB\->png([$compression_level])\fR" 4
.IX Item "$pngdata = $image->png([$compression_level])"
This returns tha image data up in \s-1PNG\s0 format.  Yo ass can then print it,
pipe it ta a gangbangin' finger-lickin' display program, or write it ta a gangbangin' file.  Example:
.Sp
.Vb 5
\&        $png_data = $myImage\->png;
\&        open (DISPLAY,"| display \-") || die;
\&        binmode DISPLAY;
\&        print DISPLAY $png_data;
\&        close DISPLAY;
.Ve
.Sp
Note tha use of \f(CW\*(C`binmode()\*(C'\fR.  This is crucial fo' portabilitizzle to
DOSish platforms.
.Sp
Da optionizzle \f(CW$compression_level\fR argument controls tha amount of
compression ta apply ta tha output \s-1PNG\s0 image.  Values range from 0\-9,
where 0 means no compression (largest files, highest quality) n' 9
means maximum compression (smallest files, most shitty quality).  A
compression level of \-1 uses tha default compression level selected
when zlib was compiled on yo' system, n' is tha same ol' dirty as calling
\&\fIpng()\fR wit no argument.  Be careful not ta confuse dis argument with
the \fIjpeg()\fR qualitizzle argument, which ranges from 0\-100 n' has the
opposite meanin from compression (higher numbers give higher
quality).
.ie n .IP "\fB\fB$gifdata\fB = \f(BI$image\fB\->gifanimbegin([$GlobalCM [, \f(CB$Loops\fB]])\fR" 4
.el .IP "\fB\f(CB$gifdata\fB = \f(CB$image\fB\->gifanimbegin([$GlobalCM [, \f(CB$Loops\fB]])\fR" 4
.IX Item "$gifdata = $image->gifanimbegin([$GlobalCM [, $Loops]])"
For libgd version 2.0.33 n' higher, dis call begins a animated \s-1GIF\s0
by returnin tha data dat comprises animated gif image file header.
Afta you call dis method, call \fIgifanimadd()\fR one or mo' times ta add
the framez of tha image. Then call \fIgifanimend()\fR. Each frame must be
the same width n' height.
.Sp
A typical sequence is ghon be lookin like this:
.Sp
.Vb 10
\&  mah $gifdata = $image\->gifanimbegin;
\&  $gifdata   .= $image\->gifanimadd;    # first frame
\&  fo' (1..100) {
\&     # cook up a gangbangin' frame of right size
\&     mah $frame  = GD::Image\->new($image\->getBounds);
\&     add_frame_data($frame);              # add tha data fo' dis frame
\&     $gifdata   .= $frame\->gifanimadd;     # add frame
\&  }
\&  $gifdata   .= $image\->gifanimend;   # finish tha animated GIF
\&  print $gifdata;                     # write animated gif ta STDOUT
.Ve
.Sp
If you do not wish ta store tha data up in memory, you can print it to
stdout or a gangbangin' file.
.Sp
Da image dat you call gifanimbegin on is used ta set tha image size,
color resolution n' color map.  If argument \f(CW$GlobalCM\fR is 1, tha image
color map becomes tha GIF89a global color map.  If \f(CW$Loops\fR is given and
>= 0, tha \s-1NETSCAPE2.0\s0 application extension is pimped, wit looping
count.  Loopin count 0 means alllll muthafuckin day.
.ie n .IP "\fB\fB$gifdata\fB = \f(BI$image\fB\->gifanimadd([$LocalCM [, \f(CB$LeftOfs\fB [, \f(CB$TopOfs\fB [, \f(CB$Delay\fB [, \f(CB$Disposal\fB [, \f(CB$previm\fB]]]]]])\fR" 4
.el .IP "\fB\f(CB$gifdata\fB = \f(CB$image\fB\->gifanimadd([$LocalCM [, \f(CB$LeftOfs\fB [, \f(CB$TopOfs\fB [, \f(CB$Delay\fB [, \f(CB$Disposal\fB [, \f(CB$previm\fB]]]]]])\fR" 4
.IX Item "$gifdata = $image->gifanimadd([$LocalCM [, $LeftOfs [, $TopOfs [, $Delay [, $Disposal [, $previm]]]]]])"
Returns tha data dat comprises one animated gif image frame.  Yo ass can
then print it, pipe it ta a gangbangin' finger-lickin' display program, or write it ta a gangbangin' file.
With \f(CW$LeftOfs\fR n' \f(CW$TopOfs\fR you can place dis frame up in different offset
than (0,0) inside tha image screen. I aint talkin' bout chicken n' gravy biatch.  Delay between tha previous frame
and dis frame is up in 1/100s units, n' you can put dat on yo' toast.  Disposal is probably n' by default
1.  Compression be activated by givin tha previous image as a
parameter n' shit.  This function then compares tha images n' only writes the
changed pixels ta tha freshly smoked up frame up in animation. I aint talkin' bout chicken n' gravy biatch.  Da Disposal parameter
for optimized animations must be set ta 1, also fo' tha straight-up original gangsta frame.
\&\f(CW$LeftOfs\fR n' \f(CW$TopOfs\fR parametas is ignored fo' optimized frames.
.ie n .IP "\fB\fB$gifdata\fB = \f(BI$image\fB\->\f(BIgifanimend()\fB\fR" 4
.el .IP "\fB\f(CB$gifdata\fB = \f(CB$image\fB\->\f(BIgifanimend()\fB\fR" 4
.IX Item "$gifdata = $image->gifanimend()"
Returns tha data fo' end segment of animated gif file.  It always
returns strang ';'.  This strang must be printed ta a animated gif
file afta all image frames ta properly terminizzle it accordin ta \s-1GIF\s0
file syntax.  Image object aint used at all up in dis method.
.ie n .IP "\fB\fB$jpegdata\fB = \f(BI$image\fB\->jpeg([$quality])\fR" 4
.el .IP "\fB\f(CB$jpegdata\fB = \f(CB$image\fB\->jpeg([$quality])\fR" 4
.IX Item "$jpegdata = $image->jpeg([$quality])"
This returns tha image data up in \s-1JPEG\s0 format.  Yo ass can then print it,
pipe it ta a gangbangin' finger-lickin' display program, or write it ta a gangbangin' file.  Yo ass may pass an
optionizzle qualitizzle score ta \fIjpeg()\fR up in order ta control tha \s-1JPEG\s0 quality.
This should be a integer between 0 n' 100.  Higher qualitizzle scores
give larger filez n' betta image quality.  If you don't specify the
quality, \fIjpeg()\fR will chizzle a phat default.
.ie n .IP "\fB\fB$gifdata\fB = \f(BI$image\fB\->\f(BIgif()\fB\fR." 4
.el .IP "\fB\f(CB$gifdata\fB = \f(CB$image\fB\->\f(BIgif()\fB\fR." 4
.IX Item "$gifdata = $image->gif()."
This returns tha image data up in \s-1GIF\s0 format.  Yo ass can then print it,
pipe it ta a gangbangin' finger-lickin' display program, or write it ta a gangbangin' file.
.ie n .IP "\fB\fB$gddata\fB = \f(BI$image\fB\->gd\fR" 4
.el .IP "\fB\f(CB$gddata\fB = \f(CB$image\fB\->gd\fR" 4
.IX Item "$gddata = $image->gd"
This returns tha image data up in \s-1GD\s0 format.  Yo ass can then print it,
pipe it ta a gangbangin' finger-lickin' display program, or write it ta a gangbangin' file.  Example:
.Sp
.Vb 2
\&        binmode MYOUTFILE;
\&        print MYOUTFILE $myImage\->gd;
.Ve
.ie n .IP "\fB\fB$gd2data\fB = \f(BI$image\fB\->gd2\fR" 4
.el .IP "\fB\f(CB$gd2data\fB = \f(CB$image\fB\->gd2\fR" 4
.IX Item "$gd2data = $image->gd2"
Same as \fIgd()\fR, except dat it returns tha data up in compressed \s-1GD2\s0
format.
.ie n .IP "\fB\fB$wbmpdata\fB = \f(BI$image\fB\->wbmp([$foreground])\fR" 4
.el .IP "\fB\f(CB$wbmpdata\fB = \f(CB$image\fB\->wbmp([$foreground])\fR" 4
.IX Item "$wbmpdata = $image->wbmp([$foreground])"
This returns tha image data up in \s-1WBMP\s0 format, which be a funky-ass black-and-white
image format.  Provide tha index of tha color ta become tha foreground
color. Shiiit, dis aint no joke.  All other pixels is ghon be considered background.
.SS "Color Control"
.IX Subsection "Color Control"
These methodz allow you ta control n' manipulate tha GD::Image color
table.
.ie n .IP "\fB\fB$index\fB = \f(BI$image\fB\->colorAllocate(red,green,blue)\fR" 4
.el .IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorAllocate(red,green,blue)\fR" 4
.IX Item "$index = $image->colorAllocate(red,green,blue)"
This allocates a cold-ass lil color wit tha specified red, chronic n' blue
components n' returns its index up in tha color table, if specified.
Da first color allocated up in dis way becomes tha imagez background
color. Shiiit, dis aint no joke.  (255,255,255) is white (all pixels on).  (0,0,0) is black (all
pixels off).  (255,0,0) is straight-up saturated red. Y'all KNOW dat shit, muthafucka!  (127,127,127) is 50%
gray.  Yo ass can find nuff examplez up in /usr/X11/lib/X11/rgb.txt.
.Sp
If no flavas is allocated, then dis function returns \-1.
.Sp
Example:
.Sp
.Vb 3
\&        $white = $myImage\->colorAllocate(0,0,0); #background color
\&        $black = $myImage\->colorAllocate(255,255,255);
\&        $peachpuff = $myImage\->colorAllocate(255,218,185);
.Ve
.ie n .IP "\fB\fB$index\fB = \f(BI$image\fB\->colorAllocateAlpha(reg,green,blue,alpha)\fR" 4
.el .IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorAllocateAlpha(reg,green,blue,alpha)\fR" 4
.IX Item "$index = $image->colorAllocateAlpha(reg,green,blue,alpha)"
This allocates a cold-ass lil color wit tha specified red, green, n' blue components,
plus tha specified alpha channel.  Da alpha value may range from 0 (opaque)
to 127 (transparent).  Da \f(CW\*(C`alphaBlending\*(C'\fR function chizzlez tha way this
alpha channel affects tha resultin image.
.ie n .IP "\fB\fB$image\fB\->colorDeallocate(colorIndex)\fR" 4
.el .IP "\fB\f(CB$image\fB\->colorDeallocate(colorIndex)\fR" 4
.IX Item "$image->colorDeallocate(colorIndex)"
This marks tha color all up in tha specified index as bein ripe for
reallocation. I aint talkin' bout chicken n' gravy biatch.  Da next time colorAllocate is used, dis entry will be
replaced. Y'all KNOW dat shit, muthafucka!  Yo ass can call dis method nuff muthafuckin times ta deallocate
multiple colors.  Therez no function result from dis call.
.Sp
Example:
.Sp
.Vb 2
\&        $myImage\->colorDeallocate($peachpuff);
\&        $peachy = $myImage\->colorAllocate(255,210,185);
.Ve
.ie n .IP "\fB\fB$index\fB = \f(BI$image\fB\->colorClosest(red,green,blue)\fR" 4
.el .IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorClosest(red,green,blue)\fR" 4
.IX Item "$index = $image->colorClosest(red,green,blue)"
This returns tha index of tha color closest up in tha color table ta the
red chronic n' blue components specified. Y'all KNOW dat shit, muthafucka!  If no flavas have yet been
allocated, then dis call returns \-1.
.Sp
Example:
.Sp
.Vb 1
\&        $apricot = $myImage\->colorClosest(255,200,180);
.Ve
.ie n .IP "\fB\fB$index\fB = \f(BI$image\fB\->colorClosestHWB(red,green,blue)\fR" 4
.el .IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorClosestHWB(red,green,blue)\fR" 4
.IX Item "$index = $image->colorClosestHWB(red,green,blue)"
This also attempts ta return tha color closest up in tha color table ta the
red chronic n' blue components specified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it uses a Hue/White/Black 
color representation ta make tha selected color mo' likely ta match
human perceptionz of similar colors.
.Sp
If no flavas have yet been
allocated, then dis call returns \-1.
.Sp
Example:
.Sp
.Vb 1
\&        $mostred = $myImage\->colorClosestHWB(255,0,0);
.Ve
.ie n .IP "\fB\fB$index\fB = \f(BI$image\fB\->colorExact(red,green,blue)\fR" 4
.el .IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorExact(red,green,blue)\fR" 4
.IX Item "$index = $image->colorExact(red,green,blue)"
This returns tha index of a cold-ass lil color dat exactly matches tha specified
red chronic n' blue components, n' you can put dat on yo' toast.  If such a cold-ass lil color aint up in tha color
table, dis call returns \-1.
.Sp
.Vb 2
\&        $rosey = $myImage\->colorExact(255,100,80);
\&        warn "Everything\*(Aqs comin up roses.\en" if $rosey >= 0;
.Ve
.ie n .IP "\fB\fB$index\fB = \f(BI$image\fB\->colorResolve(red,green,blue)\fR" 4
.el .IP "\fB\f(CB$index\fB = \f(CB$image\fB\->colorResolve(red,green,blue)\fR" 4
.IX Item "$index = $image->colorResolve(red,green,blue)"
This returns tha index of a cold-ass lil color dat exactly matches tha specified
red chronic n' blue components, n' you can put dat on yo' toast.  If such a cold-ass lil color aint up in tha color
table n' there is room, then dis method allocates tha color up in the
color table n' returns its index.
.Sp
.Vb 2
\&        $rosey = $myImage\->colorResolve(255,100,80);
\&        warn "Everything\*(Aqs comin up roses.\en" if $rosey >= 0;
.Ve
.ie n .IP "\fB\fB$colorsTotal\fB = \f(BI$image\fB\->colorsTotal\fR \fIobject method\fR" 4
.el .IP "\fB\f(CB$colorsTotal\fB = \f(CB$image\fB\->colorsTotal\fR \fIobject method\fR" 4
.IX Item "$colorsTotal = $image->colorsTotal object method"
This returns tha total number of flavas allocated up in tha object.
.Sp
.Vb 1
\&        $maxColors = $myImage\->colorsTotal;
.Ve
.Sp
In tha case of a TrueColor image, dis call will return undef.
.ie n .IP "\fB\fB$index\fB = \f(BI$image\fB\->getPixel(x,y)\fR \fIobject method\fR" 4
.el .IP "\fB\f(CB$index\fB = \f(CB$image\fB\->getPixel(x,y)\fR \fIobject method\fR" 4
.IX Item "$index = $image->getPixel(x,y) object method"
This returns tha color table index underneath tha specified
point.  It can be combined wit \fIrgb()\fR
to obtain tha rgb color underneath tha pixel.
.Sp
Example:
.Sp
.Vb 2
\&        $index = $myImage\->getPixel(20,100);
\&        ($r,$g,$b) = $myImage\->rgb($index);
.Ve
.ie n .IP "\fB($red,$green,$blue) = \fB$image\fB\->rgb($index)\fR" 4
.el .IP "\fB($red,$green,$blue) = \f(CB$image\fB\->rgb($index)\fR" 4
.IX Item "($red,$green,$blue) = $image->rgb($index)"
This returns a list containin tha red, chronic n' blue components of
the specified color index.
.Sp
Example:
.Sp
.Vb 1
\&        @RGB = $myImage\->rgb($peachy);
.Ve
.ie n .IP "\fB\fB$image\fB\->transparent($colorIndex)\fR" 4
.el .IP "\fB\f(CB$image\fB\->transparent($colorIndex)\fR" 4
.IX Item "$image->transparent($colorIndex)"
This marks tha color all up in tha specified index as bein transparent.
Portionz of tha image drawn up in dis color is ghon be invisible.  This is
useful fo' bustin paintbrushez of odd shapes, as well as for
makin \s-1PNG\s0 backgroundz transparent fo' displayin on tha Web.  Only
one color can be transparent at any time. To disable transparency, 
specify \-1 fo' tha index.
.Sp
If you call dis method without any parameters, it will return the
current index of tha transparent color, or \-1 if none.
.Sp
Example:
.Sp
.Vb 6
\&        open(PNG,"test.png");
\&        $im = newFromPng GD::Image(PNG);
\&        $white = $im\->colorClosest(255,255,255); # find white
\&        $im\->transparent($white);
\&        binmode STDOUT;
\&        print $im\->png;
.Ve
.SS "Special Colors"
.IX Subsection "Special Colors"
\&\s-1GD\s0 implements a fuckin shitload of special flavas dat can be used ta achieve
special effects, n' you can put dat on yo' toast.  They is constants defined up in tha \s-1GD::\s0
namespace yo, but automatically exported tha fuck into yo' namespace when tha \s-1GD\s0
module is loaded.
.ie n .IP "\fB\fB$image\fB\->setBrush($image)\fR" 4
.el .IP "\fB\f(CB$image\fB\->setBrush($image)\fR" 4
.IX Item "$image->setBrush($image)"
Yo ass can draw lines n' shapes rockin a funky-ass brush pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Brushes is just
images dat you can create n' manipulate up in tha usual way. When you
draw wit them, they contents is used fo' tha color n' shape of the
lines.
.Sp
To cook up a funky-ass brushed line, you must create or load tha brush first, then
assign it ta tha image rockin \fIsetBrush()\fR.  Yo ass can then draw up in that
with dat brush rockin tha \fBgdBrushed\fR special color. Shiiit, dis aint no joke.  It aint nuthin but often
useful ta set tha background of tha brush ta transparent so dat the
non-colored parts don't overwrite other partz of yo' image.
.Sp
Example:
.Sp
.Vb 6
\&        # Smoke a funky-ass brush at a angle
\&        $diagonal_brush = freshly smoked up GD::Image(5,5);
\&        $white = $diagonal_brush\->colorAllocate(255,255,255);
\&        $black = $diagonal_brush\->colorAllocate(0,0,0);
\&        $diagonal_brush\->transparent($white);
\&        $diagonal_brush\->line(0,4,4,0,$black); # NE diagonal
\&
\&        # Set tha brush
\&        $myImage\->setBrush($diagonal_brush);
\&        
\&        # Draw a cold-ass lil circle rockin tha brush
\&        $myImage\->arc(50,50,25,25,0,360,gdBrushed);
.Ve
.ie n .IP "\fB\fB$image\fB\->setThickness($thickness)\fR" 4
.el .IP "\fB\f(CB$image\fB\->setThickness($thickness)\fR" 4
.IX Item "$image->setThickness($thickness)"
Lines drawn wit \fIline()\fR, \fIrectangle()\fR, \fIarc()\fR, n' so forth is 1 pixel
thick by default.  Call \fIsetThickness()\fR ta chizzle tha line drawing
width.
.ie n .IP "\fB\fB$image\fB\->setStyle(@colors)\fR" 4
.el .IP "\fB\f(CB$image\fB\->setStyle(@colors)\fR" 4
.IX Item "$image->setStyle(@colors)"
Styled lines consist of a arbitrary seriez of repeated flavas n' are
useful fo' generatin dotted n' dashed lines.  To create a styled
line, use \fIsetStyle()\fR ta specify a repeatin seriez of colors.  It
accepts a array consistin of one or mo' color indexes.  Then draw
usin tha \fBgdStyled\fR special color. Shiiit, dis aint no joke.  Another special color,
\&\fBgdTransparent\fR can be used ta introduce holez up in tha line, as the
example shows.
.Sp
Example:
.Sp
.Vb 6
\&        # Set a steez consistin of 4 pixelz of yellow,
\&        # 4 pixelz of blue, n' a 2 pixel gap
\&        $myImage\->setStyle($yellow,$yellow,$yellow,$yellow,
\&                           $blue,$blue,$blue,$blue,
\&                           gdTransparent,gdTransparent);
\&        $myImage\->arc(50,50,25,25,0,360,gdStyled);
.Ve
.Sp
To combine tha \f(CW\*(C`gdStyled\*(C'\fR n' \f(CW\*(C`gdBrushed\*(C'\fR behaviors, you can specify
\&\f(CW\*(C`gdStyledBrushed\*(C'\fR.  In dis case, a pixel from tha current brush
pattern is rendered wherever tha color specified up in \fIsetStyle()\fR is
neither gdTransparent nor 0.
.IP "\fBgdTiled\fR" 4
.IX Item "gdTiled"
Draw filled shapes n' flood fills rockin a pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Da pattern is
just another image.  Da image is ghon be tiled multiple times up in order
to fill tha required space, bustin wallpaper effects, n' you can put dat on yo' toast.  Yo ass must call
\&\f(CW\*(C`setTile\*(C'\fR up in order ta define tha particular tile pattern you gonna use
for drawin when you specify tha gdTiled color.
details.
.IP "\fBgdStyled\fR" 4
.IX Item "gdStyled"
Da gdStyled color is used fo' bustin dashed n' dotted lines.  A
styled line can contain any seriez of flavas n' is pimped rockin the
\&\fIsetStyled()\fR command.
.IP "\fBgdAntiAliased\fR" 4
.IX Item "gdAntiAliased"
Da \f(CW\*(C`gdAntiAliased\*(C'\fR color is used fo' drawin lines wit antialiasing
turned on. I aint talkin' bout chicken n' gravy biatch.  Antialiasin will blend tha jagged edgez of lines wit the
background, bustin a smoother look.  Da actual color drawn is set
with \fIsetAntiAliased()\fR.
.ie n .IP "\fB\fB$image\fB\->setAntiAliased($color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->setAntiAliased($color)\fR" 4
.IX Item "$image->setAntiAliased($color)"
\&\*(L"Antialiasing\*(R" be a process by which jagged edges associated wit line
drawin can be reduced by blendin tha foreground color wit an
appropriate cementage of tha background, dependin on how tha fuck much of the
pixel up in question is straight-up within tha boundariez of tha line being
drawn. I aint talkin' bout chicken n' gravy biatch fo' realz. All line-drawin methods, like fuckin \fIline()\fR n' polygon, will draw
antialiased lines if tha special \*(L"color\*(R" \fBgdAntiAliased\fR is used when
callin em.
.Sp
\&\fIsetAntiAliased()\fR is used ta specify tha actual foreground color ta be
used when drawin antialiased lines. Yo ass may set any color ta be the
foreground, however az of libgd version 2.0.12 a alpha channel
component aint supported.
.Sp
Antialiased lines can be drawn on both truecolor n' palette-based
images. But fuck dat shiznit yo, tha word on tha street is dat attempts ta draw antialiased lines on highly complex
palette-based backgroundz may not give satisfactory thangs up in dis biatch, due to
the limited number of flavas available up in tha palette fo' realz. Antialiased
line-drawin on simple backgroundz should work well wit palette-based
images; otherwise create or fetch a truecolor image instead. Y'all KNOW dat shit, muthafucka! When
usin palette-based images, be shizzle ta allocate a funky-ass broad spectrum of
colors up in order ta have sufficient flavas fo' tha antialiasin ta use.
.ie n .IP "\fB\fB$image\fB\->setAntiAliasedDontBlend($color,[$flag])\fR" 4
.el .IP "\fB\f(CB$image\fB\->setAntiAliasedDontBlend($color,[$flag])\fR" 4
.IX Item "$image->setAntiAliasedDontBlend($color,[$flag])"
Normally, when drawin lines wit tha special \fBgdAntiAliased\fR
\&\*(L"color,\*(R" blendin wit tha background ta reduce jagged edges is the
desired behavior. Shiiit, dis aint no joke. But fuck dat shiznit yo, tha word on tha street is dat when it is desired dat lines not be
blended wit one particular color when it is encountered up in the
background, tha \fIsetAntiAliasedDontBlend()\fR method can be used to
indicate tha special color dat tha foreground should stand up more
clearly against.
.Sp
Once turned on, you can turn dis feature off by calling
\&\fIsetAntiAliasedDontBlend()\fR wit a second argument of 0:
.Sp
.Vb 1
\& $image\->setAntiAliasedDontBlend($color,0);
.Ve
.SS "Drawin Commands"
.IX Subsection "Drawin Commands"
These methodz allow you ta draw lines, rectangles, n' ellipses, as
well as ta big-ass up various special operations like flood-fill.
.ie n .IP "\fB\fB$image\fB\->setPixel($x,$y,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->setPixel($x,$y,$color)\fR" 4
.IX Item "$image->setPixel($x,$y,$color)"
This sets tha pixel at (x,y) ta tha specified color index.  No value
is returned from dis method. Y'all KNOW dat shit, muthafucka!  Da coordinizzle system starts at the
upper left at (0,0) n' gets larger as you go down n' ta tha right.
Yo ass can bust a real color, or one of tha special flavas gdBrushed, 
gdStyled n' gdStyledBrushed can be specified.
.Sp
Example:
.Sp
.Vb 2
\&        # This assumes $peach already allocated
\&        $myImage\->setPixel(50,50,$peach);
.Ve
.ie n .IP "\fB\fB$image\fB\->line($x1,$y1,$x2,$y2,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->line($x1,$y1,$x2,$y2,$color)\fR" 4
.IX Item "$image->line($x1,$y1,$x2,$y2,$color)"
This draws a line from (x1,y1) ta (x2,y2) of tha specified color. Shiiit, dis aint no joke.  You
can bust a real color, or one of tha special flavas gdBrushed, 
gdStyled n' gdStyledBrushed.
.Sp
Example:
.Sp
.Vb 3
\&        # Draw a gangbangin' finger-lickin' diagonal line rockin tha currently defined
\&        # paintbrush pattern.
\&        $myImage\->line(0,0,150,150,gdBrushed);
.Ve
.ie n .IP "\fB\fB$image\fB\->dashedLine($x1,$y1,$x2,$y2,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->dashedLine($x1,$y1,$x2,$y2,$color)\fR" 4
.IX Item "$image->dashedLine($x1,$y1,$x2,$y2,$color)"
\&\s-1DEPRECATED:\s0 Da libgd library serves up dis method solely fo' backward
compatibilitizzle wit libgd version 1.0, n' there done been reports that
it no longer works as expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Please use tha \fIsetStyle()\fR n' gdStyled
methodz as busted lyrics bout below.
.Sp
This draws a thugged-out dashed line from (x1,y1) ta (x2,y2) up in tha specified
color. Shiiit, dis aint no joke.  A mo' bangin way ta generate arbitrary dashed n' dotted
lines is ta use tha \fIsetStyle()\fR method busted lyrics bout below n' ta draw with
the special color gdStyled.
.Sp
Example:
.Sp
.Vb 1
\&        $myImage\->dashedLine(0,0,150,150,$blue);
.Ve
.ie n .IP "\fB\fB$image\fB\->rectangle($x1,$y1,$x2,$y2,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->rectangle($x1,$y1,$x2,$y2,$color)\fR" 4
.IX Item "$image->rectangle($x1,$y1,$x2,$y2,$color)"
This draws a rectangle wit tha specified color. Shiiit, dis aint no joke.  (x1,y1) n' (x2,y2)
are tha upper left n' lower right corners respectively.  Both real
color indexes n' tha special flavas gdBrushed, gdStyled and
gdStyledBrushed is accepted.
.Sp
Example:
.Sp
.Vb 1
\&        $myImage\->rectangle(10,10,100,100,$rose);
.Ve
.ie n .IP "\fB\fB$image\fB\->filledRectangle($x1,$y1,$x2,$y2,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->filledRectangle($x1,$y1,$x2,$y2,$color)\fR" 4
.IX Item "$image->filledRectangle($x1,$y1,$x2,$y2,$color)"
This draws a rectangle filed wit tha specified color. Shiiit, dis aint no joke.  Yo ass can use a
real color, or tha special fill color gdTiled ta fill tha polygon
with a pattern.
.Sp
Example:
.Sp
.Vb 3
\&        # read up in a gangbangin' fill pattern n' set it
\&        $tile = newFromPng GD::Image(\*(Aqhappyface.png\*(Aq);
\&        $myImage\->setTile($tile); 
\&
\&        # draw tha rectangle, fillin it wit tha pattern
\&        $myImage\->filledRectangle(10,10,150,200,gdTiled);
.Ve
.ie n .IP "\fB\fB$image\fB\->openPolygon($polygon,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->openPolygon($polygon,$color)\fR" 4
.IX Item "$image->openPolygon($polygon,$color)"
This draws a polygon wit tha specified color. Shiiit, dis aint no joke.  Da polygon must be
created first (see below).  Da polygon must have at least three
vertices.  If tha last vertex don't close tha polygon, tha method
will close it fo' yo thugged-out ass.  Both real color indexes n' tha special 
colors gdBrushed, gdStyled n' gdStyledBrushed can be specified.
.Sp
Example:
.Sp
.Vb 5
\&        $poly = freshly smoked up GD::Polygon;
\&        $poly\->addPt(50,0);
\&        $poly\->addPt(99,99);
\&        $poly\->addPt(0,99);
\&        $myImage\->openPolygon($poly,$blue);
.Ve
.ie n .IP "\fB\fB$image\fB\->unclosedPolygon($polygon,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->unclosedPolygon($polygon,$color)\fR" 4
.IX Item "$image->unclosedPolygon($polygon,$color)"
This draws a sequence of connected lines wit tha specified color,
without connectin tha straight-up original gangsta n' last point ta a cold-ass lil closed polygon. I aint talkin' bout chicken n' gravy biatch.  The
polygon must be pimped first (see below).  Da polygon must have at
least three vertices.  Both real color indexes n' tha special colors
gdBrushed, gdStyled n' gdStyledBrushed can be specified.
.Sp
Yo ass need libgd 2.0.33 or higher ta use dis feature.
.Sp
Example:
.Sp
.Vb 5
\&        $poly = freshly smoked up GD::Polygon;
\&        $poly\->addPt(50,0);
\&        $poly\->addPt(99,99);
\&        $poly\->addPt(0,99);
\&        $myImage\->unclosedPolygon($poly,$blue);
.Ve
.ie n .IP "\fB\fB$image\fB\->filledPolygon($poly,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->filledPolygon($poly,$color)\fR" 4
.IX Item "$image->filledPolygon($poly,$color)"
This draws a polygon filled wit tha specified color. Shiiit, dis aint no joke.  Yo ass can use a
real color, or tha special fill color gdTiled ta fill tha polygon
with a pattern.
.Sp
Example:
.Sp
.Vb 5
\&        # cook up a polygon
\&        $poly = freshly smoked up GD::Polygon;
\&        $poly\->addPt(50,0);
\&        $poly\->addPt(99,99);
\&        $poly\->addPt(0,99);
\&
\&        # draw tha polygon, fillin it wit a cold-ass lil color
\&        $myImage\->filledPolygon($poly,$peachpuff);
.Ve
.ie n .IP "\fB\fB$image\fB\->ellipse($cx,$cy,$width,$height,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->ellipse($cx,$cy,$width,$height,$color)\fR" 4
.IX Item "$image->ellipse($cx,$cy,$width,$height,$color)"
.PD 0
.ie n .IP "\fB\fB$image\fB\->filledEllipse($cx,$cy,$width,$height,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->filledEllipse($cx,$cy,$width,$height,$color)\fR" 4
.IX Item "$image->filledEllipse($cx,$cy,$width,$height,$color)"
.PD
These \fImethods()\fR draw ellipses. ($cx,$cy) is tha centa of tha arc, and
($width,$height) specify tha ellipse width n' height, respectively.
\&\fIfilledEllipse()\fR is like \fIEllipse()\fR except dat tha forma produces
filled versionz of tha ellipse.
.ie n .IP "\fB\fB$image\fB\->arc($cx,$cy,$width,$height,$start,$end,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->arc($cx,$cy,$width,$height,$start,$end,$color)\fR" 4
.IX Item "$image->arc($cx,$cy,$width,$height,$start,$end,$color)"
This draws arcs n' ellipses.  (cx,cy) is tha centa of tha arc, and
(width,height) specify tha width n' height, respectively.  The
portion of tha ellipse covered by tha arc is controlled by start and
end, both of which is given up in degrees from 0 ta 360.  Zero be at the
top of tha ellipse, n' anglez increase clockwise.  To specify a
complete ellipse, use 0 n' 360 as tha startin n' endin angles.  To
draw a cold-ass lil circle, use tha same value fo' width n' height.
.Sp
Yo ass can specify a aiiight color or one of tha special colors
\&\fBgdBrushed\fR, \fBgdStyled\fR, or \fBgdStyledBrushed\fR.
.Sp
Example:
.Sp
.Vb 2
\&        # draw a semicircle centered at 100,100
\&        $myImage\->arc(100,100,50,50,0,180,$blue);
.Ve
.ie n .IP "\fB\fB$image\fB\->filledArc($cx,$cy,$width,$height,$start,$end,$color [,$arc_style])\fR" 4
.el .IP "\fB\f(CB$image\fB\->filledArc($cx,$cy,$width,$height,$start,$end,$color [,$arc_style])\fR" 4
.IX Item "$image->filledArc($cx,$cy,$width,$height,$start,$end,$color [,$arc_style])"
This method is like \fIarc()\fR except dat it flavas up in tha pie wedge with
the selected color. Shiiit, dis aint no joke.  \f(CW$arc_style\fR is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If present it be a
bitwise \s-1OR\s0 of tha followin constants:
.Sp
.Vb 5
\&  gdArc           connect start & end pointz of arc wit a rounded edge
\&  gdChord         connect start & end pointz of arc wit a straight line
\&  gdPie           synonym fo' gdChord
\&  gdNoFill        outline tha arc or chord
\&  gdEdged         connect beginnin n' endin of tha arc ta tha center
.Ve
.Sp
gdArc n' gdChord is mutually exclusive.  gdChord just connects the
startin n' endin anglez wit a straight line, while gdArc produces
a rounded edge. gdPie be a synonym fo' gdArc. gdNoFill indicates that
the arc or chord should be outlined, not filled. Y'all KNOW dat shit, muthafucka! gdEdged, used
together wit gdNoFill, indicates dat tha beginnin n' endin angles
should be connected ta tha center; dis be a phat way ta outline
(rather than fill) a \*(L"pie slice.\*(R"
.Sp
Example:
.Sp
.Vb 1
\&  $image\->filledArc(100,100,50,50,0,90,$blue,gdEdged|gdNoFill);
.Ve
.ie n .IP "\fB\fB$image\fB\->fill($x,$y,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->fill($x,$y,$color)\fR" 4
.IX Item "$image->fill($x,$y,$color)"
This method flood-fills regions wit tha specified color. Shiiit, dis aint no joke.  Da color
will spread all up in tha image, startin at point (x,y), until it is
stopped by a pixel of a gangbangin' finger-lickin' different color from tha startin pixel (this
is similar ta tha \*(L"paintbucket\*(R" up in nuff ghettofab drawin toys).  You
can specify a aiiight color, or tha special color gdTiled, ta flood-fill
with patterns.
.Sp
Example:
.Sp
.Vb 3
\&        # Draw a rectangle, n' then make its interior blue
\&        $myImage\->rectangle(10,10,100,100,$black);
\&        $myImage\->fill(50,50,$blue);
.Ve
.ie n .IP "\fB\fB$image\fB\->fillToBorder($x,$y,$bordercolor,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->fillToBorder($x,$y,$bordercolor,$color)\fR" 4
.IX Item "$image->fillToBorder($x,$y,$bordercolor,$color)"
Like \f(CW\*(C`fill\*(C'\fR, dis method flood-fills regions wit tha specified
color, startin at posizzle (x,y).  But fuck dat shiznit yo, tha word on tha street is dat instead of stoppin when
it hits a pixel of a gangbangin' finger-lickin' different color than tha startin pixel, flooding
will only stop when it hits tha color specified by bordercolor. Shiiit, dis aint no joke.  You
must specify a aiiight indexed color fo' tha bordercolor. Shiiit, dis aint no joke.  But fuck dat shiznit yo, tha word on tha street is dat you
are free ta use tha gdTiled color fo' tha fill.
.Sp
Example:
.Sp
.Vb 3
\&        # This has tha same ol' dirty effect as tha previous example
\&        $myImage\->rectangle(10,10,100,100,$black);
\&        $myImage\->fillToBorder(50,50,$black,$blue);
.Ve
.SS "Image Copyin Commands"
.IX Subsection "Image Copyin Commands"
Two methodz is provided fo' copyin a rectangular region from one
image ta another n' shit.  One method copies a region without resizin dat shit.
Da other allows you ta stretch tha region durin tha copy operation.
.PP
With either of these methodz it is blingin ta know dat tha routines
will attempt ta flesh up tha destination imagez color table ta match
the flavas dat is bein copied from tha source.  If the
destinationz color table be already full, then tha routines will
attempt ta find tha dopest match, wit varyin thangs up in dis biatch.
.ie n .IP "\fB\fB$image\fB\->copy($sourceImage,$dstX,$dstY,\fR" 4
.el .IP "\fB\f(CB$image\fB\->copy($sourceImage,$dstX,$dstY,\fR" 4
.IX Item "$image->copy($sourceImage,$dstX,$dstY,"
\&\fB				\f(CB$srcX\fB,$srcY,$width,$height)\fR
.Sp
This is tha simplest of tha nuff muthafuckin copy operations, copyin the
specified region from tha source image ta tha destination image (the
one struttin tha method call).  (srcX,srcY) specify tha upper left
corner of a rectangle up in tha source image, n' (width,height) give the
width n' height of tha region ta copy.  (dstX,dstY) control where in
the destination image ta stamp tha copy.  Yo ass can use tha same image
for both tha source n' tha destination yo, but tha source and
destination regions must not overlap or strange thangs will happen.
.Sp
Example:
.Sp
.Vb 7
\&        $myImage = freshly smoked up GD::Image(100,100);
\&        ... various drawin shiznit ...
\&        $srcImage = freshly smoked up GD::Image(50,50);
\&        ... mo' drawin shiznit ...
\&        # copy a 25x25 pixel region from $srcImage to
\&        # tha rectangle startin at (10,10) up in $myImage
\&        $myImage\->copy($srcImage,10,10,0,0,25,25);
.Ve
.ie n .IP "\fB\fB$image\fB\->\f(BIclone()\fB\fR" 4
.el .IP "\fB\f(CB$image\fB\->\f(BIclone()\fB\fR" 4
.IX Item "$image->clone()"
Make a cold-ass lil copy of tha image n' return it as a freshly smoked up object.  Da freshly smoked up image
will look identical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  But fuck dat shiznit yo, tha word on tha street is dat it may differ up in tha size of tha color
palette n' other nonessential details.
.Sp
Example:
.Sp
.Vb 3
\&        $myImage = freshly smoked up GD::Image(100,100);
\&        ... various drawin shiznit ...
\&        $copy = $myImage\->clone;
.Ve
.ie n .IP "\fB\fB$image\fB\->copyMerge($sourceImage,$dstX,$dstY,\fR" 4
.el .IP "\fB\f(CB$image\fB\->copyMerge($sourceImage,$dstX,$dstY,\fR" 4
.IX Item "$image->copyMerge($sourceImage,$dstX,$dstY,"
\&\fB				\f(CB$srcX\fB,$srcY,$width,$height,$percent)\fR
.Sp
This copies tha indicated rectangle from tha source image ta the
destination image, mergin tha flavas ta tha extent specified by
percent (an integer between 0 n' 100).  Specifyin 100% has tha same
effect as \fIcopy()\fR \*(-- replacin tha destination pixels wit tha source
image.  This is most useful fo' highlightin a area by mergin up in a
solid rectangle.
.Sp
Example:
.Sp
.Vb 7
\&        $myImage = freshly smoked up GD::Image(100,100);
\&        ... various drawin shiznit ...
\&        $redImage = freshly smoked up GD::Image(50,50);
\&        ... mo' drawin shiznit ...
\&        # copy a 25x25 pixel region from $srcImage to
\&        # tha rectangle startin at (10,10) up in $myImage, mergin 50%
\&        $myImage\->copyMerge($srcImage,10,10,0,0,25,25,50);
.Ve
.ie n .IP "\fB\fB$image\fB\->copyMergeGray($sourceImage,$dstX,$dstY,\fR" 4
.el .IP "\fB\f(CB$image\fB\->copyMergeGray($sourceImage,$dstX,$dstY,\fR" 4
.IX Item "$image->copyMergeGray($sourceImage,$dstX,$dstY,"
\&\fB				\f(CB$srcX\fB,$srcY,$width,$height,$percent)\fR
.Sp
This is identical ta \fIcopyMerge()\fR except dat it preserves tha hue of
the source by convertin all tha pixelz of tha destination rectangle
to grayscale before merging.
.ie n .IP "\fB\fB$image\fB\->copyResized($sourceImage,$dstX,$dstY,\fR" 4
.el .IP "\fB\f(CB$image\fB\->copyResized($sourceImage,$dstX,$dstY,\fR" 4
.IX Item "$image->copyResized($sourceImage,$dstX,$dstY,"
\&\fB				\f(CB$srcX\fB,$srcY,$destW,$destH,$srcW,$srcH)\fR
.Sp
This method is similar ta \fIcopy()\fR but allows you ta chizzle different
sizes fo' tha source n' destination rectangles.  Da source and
destination rectanglez is specified independently by (srcW,srcH) and
(destW,destH) respectively.  \fIcopyResized()\fR will stretch or shrink the
image ta accommodate tha size requirements.
.Sp
Example:
.Sp
.Vb 7
\&        $myImage = freshly smoked up GD::Image(100,100);
\&        ... various drawin shiznit ...
\&        $srcImage = freshly smoked up GD::Image(50,50);
\&        ... mo' drawin shiznit ...
\&        # copy a 25x25 pixel region from $srcImage to
\&        # a larger rectangle startin at (10,10) up in $myImage
\&        $myImage\->copyResized($srcImage,10,10,0,0,50,50,25,25);
.Ve
.ie n .IP "\fB\fB$image\fB\->copyResampled($sourceImage,$dstX,$dstY,\fR" 4
.el .IP "\fB\f(CB$image\fB\->copyResampled($sourceImage,$dstX,$dstY,\fR" 4
.IX Item "$image->copyResampled($sourceImage,$dstX,$dstY,"
\&\fB				\f(CB$srcX\fB,$srcY,$destW,$destH,$srcW,$srcH)\fR
.Sp
This method is similar ta \fIcopyResized()\fR but serves up \*(L"smooth\*(R" copying
from a big-ass image ta a smalla one, rockin a weighted average of the
pixelz of tha source area rather than selectin one representative
pixel. This method is identical ta \fIcopyResized()\fR when tha destination
image be a palette image.
.ie n .IP "\fB\fB$image\fB\->copyRotated($sourceImage,$dstX,$dstY,\fR" 4
.el .IP "\fB\f(CB$image\fB\->copyRotated($sourceImage,$dstX,$dstY,\fR" 4
.IX Item "$image->copyRotated($sourceImage,$dstX,$dstY,"
\&\fB				\f(CB$srcX\fB,$srcY,$width,$height,$angle)\fR
.Sp
Like \fIcopyResized()\fR but tha \f(CW$angle\fR argument specifies a arbitrary
amount ta rotate tha image clockwise (in degrees).  In addition, \f(CW$dstX\fR
and \f(CW$dstY\fR species tha \fBcenter\fR of tha destination image, n' not the
top left corner.
.ie n .IP "\fB\fB$image\fB\->trueColorToPalette([$dither], [$colors])\fR" 4
.el .IP "\fB\f(CB$image\fB\->trueColorToPalette([$dither], [$colors])\fR" 4
.IX Item "$image->trueColorToPalette([$dither], [$colors])"
This method converts a truecolor image ta a palette image. Da code for
this function was originally drawn from tha Independent \s-1JPEG\s0 Group library
code, which is pimpin. Da code has been modified ta preserve as much
alpha channel shiznit as possible up in tha resultin palette, up in addition
to preservin flavas as well as possible. This do not work as well as
might be hoped. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is probably dopest ta simply produce a truecolor
output image instead, which guarantees tha highest output quality.
Both tha ditherin (0/1, default=0) n' maximum number of flavas used
(<=256, default = gdMaxColors) can be specified.
.SS "Image Transformation Commands"
.IX Subsection "Image Transformation Commands"
Gd also serves up some common image transformations:
.ie n .IP "\fB\fB$image\fB = \f(BI$sourceImage\fB\->\f(BIcopyRotate90()\fB\fR" 4
.el .IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\f(BIcopyRotate90()\fB\fR" 4
.IX Item "$image = $sourceImage->copyRotate90()"
.PD 0
.ie n .IP "\fB\fB$image\fB = \f(BI$sourceImage\fB\->\f(BIcopyRotate180()\fB\fR" 4
.el .IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\f(BIcopyRotate180()\fB\fR" 4
.IX Item "$image = $sourceImage->copyRotate180()"
.ie n .IP "\fB\fB$image\fB = \f(BI$sourceImage\fB\->\f(BIcopyRotate270()\fB\fR" 4
.el .IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\f(BIcopyRotate270()\fB\fR" 4
.IX Item "$image = $sourceImage->copyRotate270()"
.ie n .IP "\fB\fB$image\fB = \f(BI$sourceImage\fB\->\f(BIcopyFlipHorizontal()\fB\fR" 4
.el .IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\f(BIcopyFlipHorizontal()\fB\fR" 4
.IX Item "$image = $sourceImage->copyFlipHorizontal()"
.ie n .IP "\fB\fB$image\fB = \f(BI$sourceImage\fB\->\f(BIcopyFlipVertical()\fB\fR" 4
.el .IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\f(BIcopyFlipVertical()\fB\fR" 4
.IX Item "$image = $sourceImage->copyFlipVertical()"
.ie n .IP "\fB\fB$image\fB = \f(BI$sourceImage\fB\->\f(BIcopyTranspose()\fB\fR" 4
.el .IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\f(BIcopyTranspose()\fB\fR" 4
.IX Item "$image = $sourceImage->copyTranspose()"
.ie n .IP "\fB\fB$image\fB = \f(BI$sourceImage\fB\->\f(BIcopyReverseTranspose()\fB\fR" 4
.el .IP "\fB\f(CB$image\fB = \f(CB$sourceImage\fB\->\f(BIcopyReverseTranspose()\fB\fR" 4
.IX Item "$image = $sourceImage->copyReverseTranspose()"
.PD
These methodz can be used ta rotate, flip, or transpose a image.
Da result of tha method be a cold-ass lil copy of tha image.
.ie n .IP "\fB\fB$image\fB\->\f(BIrotate180()\fB\fR" 4
.el .IP "\fB\f(CB$image\fB\->\f(BIrotate180()\fB\fR" 4
.IX Item "$image->rotate180()"
.PD 0
.ie n .IP "\fB\fB$image\fB\->\f(BIflipHorizontal()\fB\fR" 4
.el .IP "\fB\f(CB$image\fB\->\f(BIflipHorizontal()\fB\fR" 4
.IX Item "$image->flipHorizontal()"
.ie n .IP "\fB\fB$image\fB\->\f(BIflipVertical()\fB\fR" 4
.el .IP "\fB\f(CB$image\fB\->\f(BIflipVertical()\fB\fR" 4
.IX Item "$image->flipVertical()"
.PD
These methodz is similar ta tha copy* versions yo, but instead
modify tha image up in place.
.SS "Characta n' Strin Drawing"
.IX Subsection "Characta n' Strin Drawing"
\&\s-1GD\s0 allows you ta draw charactas n' strings, either up in normal
horizontal orientation or rotated 90 degrees.  These routines use a
GD::Font object, busted lyrics bout up in mo' detail below.  There is four
built-in monospaced fonts, available up in tha global variables
\&\fBgdGiantFont\fR, \fBgdLargeFont\fR, \fBgdMediumBoldFont\fR, \fBgdSmallFont\fR
and \fBgdTinyFont\fR.
.PP
In addition, you can use tha \fIload()\fR method ta load GD-formatted bitmap
font filez at runtime. Yo ass can create these bitmap filez from X11
BDF-format filez rockin tha bdf2gd.pl script, which should have been
installed wit \s-1GD \s0(see tha bdf_scripts directory if it wasn't).  The
format happens ta be identical ta tha old-style \s-1MSDOS\s0 bitmap \*(L".fnt\*(R"
files, so you can use one of dem directly if you happen ta have one.
.PP
For freestylin proportionizzle scaleable fonts, \s-1GD\s0 offers tha \fIstringFT()\fR
method, which allows you ta load n' render any TrueType font on your
system.
.ie n .IP "\fB\fB$image\fB\->string($font,$x,$y,$string,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->string($font,$x,$y,$string,$color)\fR" 4
.IX Item "$image->string($font,$x,$y,$string,$color)"
This method draws a strang startin at posizzle (x,y) up in tha specified
font n' color. Shiiit, dis aint no joke.  Yo crazy-ass chizzlez of fonts is gdSmallFont, gdMediumBoldFont,
gdTinyFont, gdLargeFont n' gdGiantFont.
.Sp
Example:
.Sp
.Vb 1
\&        $myImage\->string(gdSmallFont,2,10,"Peachy Keen",$peach);
.Ve
.ie n .IP "\fB\fB$image\fB\->stringUp($font,$x,$y,$string,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->stringUp($font,$x,$y,$string,$color)\fR" 4
.IX Item "$image->stringUp($font,$x,$y,$string,$color)"
Just like tha previous call yo, but draws tha text rotated
counterclockwise 90 degrees.
.ie n .IP "\fB\fB$image\fB\->char($font,$x,$y,$char,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->char($font,$x,$y,$char,$color)\fR" 4
.IX Item "$image->char($font,$x,$y,$char,$color)"
.PD 0
.ie n .IP "\fB\fB$image\fB\->charUp($font,$x,$y,$char,$color)\fR" 4
.el .IP "\fB\f(CB$image\fB\->charUp($font,$x,$y,$char,$color)\fR" 4
.IX Item "$image->charUp($font,$x,$y,$char,$color)"
.PD
These methodz draw single charactas at posizzle (x,y) up in the
specified font n' color. Shiiit, dis aint no joke.  They're carry-overs from tha C intercourse,
where there be a gangbangin' finger-lickin' distinction between charactas n' strings.  Perl is
insensible ta such subtle distinctions.
.ie n .IP "$font = \fBGD::Font\->load($fontfilepath)\fR" 4
.el .IP "\f(CW$font\fR = \fBGD::Font\->load($fontfilepath)\fR" 4
.IX Item "$font = GD::Font->load($fontfilepath)"
This method dynamically loadz a gangbangin' font file, returnin a gangbangin' font dat you
can use up in subsequent calls ta drawin methods.  For example:
.Sp
.Vb 2
\&   mah $courier = GD::Font\->load(\*(Aq./courierR12.fnt\*(Aq) or take a thugged-out dirtnap "Can\*(Aqt load font";
\&   $image\->string($courier,2,10,"Peachy Keen",$peach);
.Ve
.Sp
Font filez must be up in \s-1GD\s0 binary format, as busted lyrics bout above.
.ie n .IP "\fB\fB@bounds\fB = \f(BI$image\fB\->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)\fR" 4
.el .IP "\fB\f(CB@bounds\fB = \f(CB$image\fB\->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)\fR" 4
.IX Item "@boundz = $image->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)"
.PD 0
.ie n .IP "\fB\fB@bounds\fB = GD::Image\->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)\fR" 4
.el .IP "\fB\f(CB@bounds\fB = GD::Image\->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)\fR" 4
.IX Item "@boundz = GD::Image->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)"
.ie n .IP "\fB\fB@bounds\fB = \f(BI$image\fB\->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string,\e%options)\fR" 4
.el .IP "\fB\f(CB@bounds\fB = \f(CB$image\fB\->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string,\e%options)\fR" 4
.IX Item "@boundz = $image->stringFT($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string,%options)"
.PD
This method uses TrueType ta draw a scaled, antialiased strang using
the TrueType vector font of yo' chizzle.  It requires dat libgd to
have been compiled wit TrueType support, n' fo' tha appropriate
TrueType font ta be installed on yo' system.
.Sp
Da arguments is as bigs up:
.Sp
.Vb 6
\&  fgcolor    Color index ta draw tha strang in
\&  fontname   A path ta tha TrueType (.ttf) font file or a gangbangin' font pattern.
\&  ptsize     Da desired point size (may be fractional)
\&  angle      Da rotation angle, up in radians (positizzle joints rotate counta clockwise)
\&  x,y        X n' Y coordinates ta start drawin tha string
\&  strang     Da strang itself
.Ve
.Sp
If successful, tha method returns a eight-element list givin the
boundariez of tha rendered string:
.Sp
.Vb 4
\& @bounds[0,1]  Lower left corner (x,y)
\& @bounds[2,3]  Lower right corner (x,y)
\& @bounds[4,5]  Upper right corner (x,y)
\& @bounds[6,7]  Upper left corner (x,y)
.Ve
.Sp
In case of a error (like fuckin tha font not bein available, or \s-1FT\s0
support not bein available), tha method returns a empty list and
sets $@ ta tha error message.
.Sp
Da strang may contain \s-1UTF\-8\s0 sequences like: \*(L"&#192;\*(R"
.Sp
Yo ass may also call dis method from tha GD::Image class name, up in which
case it don't do any actual drawin yo, but returns tha boundin box
usin a inexpensive operation. I aint talkin' bout chicken n' gravy biatch.  Yo ass can use dis ta big-ass up layout
operations prior ta drawing.
.Sp
Usin a wack color index will disable antialiasing, as busted lyrics about
in tha libgd manual page at
<http://www.boutell.com/gd/manual2.0.9.html#gdImageStringFT>.
.Sp
An optionizzle 8th argument allows you ta pass a hashref of options to
\&\fIstringFT()\fR.  Several hashkeys is recognized: \fBlinespacing\fR,
\&\fBcharmap\fR, \fBresolution\fR, n' \fBkerning\fR.
.Sp
Da value of \fBlinespacing\fR is supposed ta be a multiple of the
characta height, so settin linespacin ta 2.0 will result in
double-spaced linez of text.  However tha current version of libgd
(2.0.12) do not do all dis bullshit.  Instead tha linespacin seems ta be double
what is provided up in dis argument.  So bust a spacin of 0.5 ta get
separation of exactly one line of text.  In practice, a spacin of 0.6
seems ta give sick thangs up in dis biatch.  Another thang ta peep up fo' is that
successive linez of text should be separated by tha \*(L"\er\en\*(R" characters,
not just \*(L"\en\*(R".
.Sp
Da value of \fBcharmap\fR is one of \*(L"Unicode\*(R", \*(L"Shift_JIS\*(R" n' \*(L"Big5\*(R".
Da interaction between Perl, Unicode n' libgd aint clear ta me,
and you should experiment a lil' bit if you wanna use dis feature.
.Sp
Da value of \fBresolution\fR is tha vertical n' horizontal resolution,
in \s-1DPI,\s0 up in tha format \*(L"hdpi,vdpi\*(R".  If present, tha resolution will be
passed ta tha Freetype renderin engine as a hint ta improve the
appearizzle of tha rendered font.
.Sp
Da value of \fBkerning\fR be a gangbangin' flag.  Set it ta false ta turn off the
default kernin of text.
.Sp
Example:
.Sp
.Vb 5
\& $gd\->stringFT($black,\*(Aq/dosc/windows/Fonts/pala.ttf\*(Aq,40,0,20,90,
\&              "hi there\er\enbye now",
\&              {linespacing=>0.6,
\&               charmap  => \*(AqUnicode\*(Aq,
\&              });
.Ve
.Sp
If \s-1GD\s0 was compiled wit fontconfig support, n' tha fontconfig library
is available on yo' system, then you can bust a gangbangin' font name pattern
instead of a path.  Patterns is busted lyrics bout up in fontconfig n' will
look suttin' like dis \*(L"Times:italic\*(R".  For backward
compatibility, dis feature is disabled by default.  Yo ass must enable
it by callin \fIuseFontConfig\fR\|(1) prior ta tha \fIstringFT()\fR call.
.Sp
.Vb 1
\&   $image\->useFontConfig(1);
.Ve
.Sp
For backward compatibilitizzle wit olda versionz of tha FreeType
library, tha alias \fIstringTTF()\fR be also recognized.
.ie n .IP "\fB\fB$hasfontconfig\fB = \f(BI$image\fB\->useFontConfig($flag)\fR" 4
.el .IP "\fB\f(CB$hasfontconfig\fB = \f(CB$image\fB\->useFontConfig($flag)\fR" 4
.IX Item "$hasfontconfig = $image->useFontConfig($flag)"
Call \fIuseFontConfig()\fR wit a value of 1 up in order ta enable support for
fontconfig font patterns (see stringFT).  Regardless of tha value of
\&\f(CW$flag\fR, dis method will return a legit value if tha fontconfig library
is present, or false otherwise.
.ie n .IP "\fB\fB$result\fB = \f(BI$image\fB\-\fRstringFTCircle($cx,$cy,$radius,$textRadius,$fillPortion,$font,$points,$top,$bottom,$fgcolor)>" 4
.el .IP "\fB\f(CB$result\fB = \f(CB$image\fB\-\fRstringFTCircle($cx,$cy,$radius,$textRadius,$fillPortion,$font,$points,$top,$bottom,$fgcolor)>" 4
.IX Item "$result = $image-stringFTCircle($cx,$cy,$radius,$textRadius,$fillPortion,$font,$points,$top,$bottom,$fgcolor)>"
This draws text up in a cold-ass lil circle. Currently (libgd 2.0.33) dis function
does not work fo' me yo, but tha intercourse is provided fo' completeness.
Da call signature is somewhat complex.  Here be a excerpt from the
libgd manual page:
.Sp
Draws tha text strings specified by top n' bottom on tha image, curved along
the edge of a cold-ass lil circle of radius radius, wit its centa at cx and
cy. top is freestyled clockwise along tha top; bottom is written
counterclockwise along tha bottom. textRadius determines tha \*(L"height\*(R"
of each character; if textRadius is 1/2 of radius, charactas extend
halfway from tha edge ta tha center n' shit. fillPortion varies from 0 ta 1.0,
with useful joints from bout 0.4 ta 0.9, n' determines how tha fuck much of
the 180 degreez of arc assigned ta each section of text be actually
occupied by text; 0.9 looks betta than 1.0 which is rather
crowded. Y'all KNOW dat shit, muthafucka! font be a gangbangin' freetype font; peep gdImageStringFT. points is
passed ta tha freetype engine n' has a effect on hinting; although
the size of tha text is determined by radius, textRadius, and
fillPortion, you should pass a point size dat \*(L"hints\*(R" appropriately
\&\*(-- if you know tha text is ghon be large, pass a big-ass point size such as
24.0 ta git tha dopest thangs up in dis biatch. fgcolor can be any color, n' may have
an alpha component, do blending, etc.
.Sp
Returns a legit value on success.
.SS "Alpha channels"
.IX Subsection "Alpha channels"
Da alpha channel methodz allow you ta control tha way drawings are
processed accordin ta tha alpha channel. When legit color is turned
on, flavas is encoded as four bytes, up in which tha last three bytes
are tha \s-1RGB\s0 color joints, n' tha straight-up original gangsta byte is tha alpha channel.
Therefore tha hexadecimal representation of a non transparent \s-1RGB\s0
color will be: C=0x00(rr)(bb)(bb)
.PP
When alpha blendin is turned on, you can use tha straight-up original gangsta byte of the
color ta control tha transparency, meanin dat a rectangle painted
with color 0x00(rr)(bb)(bb) is ghon be opaque, n' another one painted
with 0x7f(rr)(gg)(bb) is ghon be transparent. Da Alpha value must be >=
0 n' <= 0x7f.
.ie n .IP "\fB\fB$image\fB\->alphaBlending($integer)\fR" 4
.el .IP "\fB\f(CB$image\fB\->alphaBlending($integer)\fR" 4
.IX Item "$image->alphaBlending($integer)"
Da \fIalphaBlending()\fR method allows fo' two different modez of drawing
on truecolor images. In blendin mode, which is on by default (libgd
2.0.2 n' above), tha alpha channel component of tha color supplied to
all drawin functions, like fuckin \f(CW\*(C`setPixel\*(C'\fR, determines how tha fuck much of the
underlyin color should be allowed ta shine all up in cause I gots dem finger-lickin' chickens wit tha siz-auce fo' realz. As a result, \s-1GD\s0
automatically blendz tha existin color at dat point wit tha drawing
color, n' stores tha result up in tha image. Da resultin pixel is
opaque. In non-blendin mode, tha drawin color is copied literally
with its alpha channel shiznit, replacin tha destination
pixel. Blendin mode aint available when drawin on palette images.
.Sp
Pass a value of 1 fo' blendin mode, n' 0 fo' non-blendin mode.
.ie n .IP "\fB\fB$image\fB\->saveAlpha($saveAlpha)\fR" 4
.el .IP "\fB\f(CB$image\fB\->saveAlpha($saveAlpha)\fR" 4
.IX Item "$image->saveAlpha($saveAlpha)"
By default, \s-1GD \s0(libgd 2.0.2 n' above) do not attempt ta save full
alpha channel shiznit (as opposed ta single-color transparency)
when savin \s-1PNG\s0 images. (\s-1PNG\s0 is currently tha only output format
supported by gd which can accommodate alpha channel shiznit.) This
saves space up in tha output file. If you wish ta create a image with
alpha channel shiznit fo' use wit tools dat support it, call
\&\f(CWsaveAlpha(1)\fR ta turn on savin of such shiznit, n' call
\&\f(CWalphaBlending(0)\fR ta turn off alpha blendin within tha library so
that alpha channel shiznit is straight-up stored up in tha image rather
than bein composited immediately all up in tha time dat drawin functions
are invoked.
.SS "Miscellaneous Image Methods"
.IX Subsection "Miscellaneous Image Methods"
These is various utilitizzle methodz dat is useful up in some
circumstances.
.ie n .IP "\fB\fB$image\fB\->interlaced([$flag])\fR" 4
.el .IP "\fB\f(CB$image\fB\->interlaced([$flag])\fR" 4
.IX Item "$image->interlaced([$flag])"
This method sets or queries tha imagez interlaced setting.  Interlace
produces a cold-ass lil def venetian blindz effect on certain viewers.  Provide a
true parameta ta set tha interlace attribute.  Provide undef to
disable dat shit.  Call tha method without parametas ta smoke up the
current setting.
.ie n .IP "\fB($width,$height) = \fB$image\fB\->\f(BIgetBounds()\fB\fR" 4
.el .IP "\fB($width,$height) = \f(CB$image\fB\->\f(BIgetBounds()\fB\fR" 4
.IX Item "($width,$height) = $image->getBounds()"
This method will return a two-member list containin tha width and
height of tha image.  Yo ass query but not chizzle tha size of the
image once itz pimped.
.ie n .IP "\fB\fB$width\fB = \f(BI$image\fB\->width\fR" 4
.el .IP "\fB\f(CB$width\fB = \f(CB$image\fB\->width\fR" 4
.IX Item "$width = $image->width"
.PD 0
.ie n .IP "\fB\fB$height\fB = \f(BI$image\fB\->height\fR" 4
.el .IP "\fB\f(CB$height\fB = \f(CB$image\fB\->height\fR" 4
.IX Item "$height = $image->height"
.PD
Return tha width n' height of tha image, respectively.
.ie n .IP "\fB\fB$is_truecolor\fB = \f(BI$image\fB\->\f(BIisTrueColor()\fB\fR" 4
.el .IP "\fB\f(CB$is_truecolor\fB = \f(CB$image\fB\->\f(BIisTrueColor()\fB\fR" 4
.IX Item "$is_truecolor = $image->isTrueColor()"
This method will return a Boolean representin whether tha image
is legit color or not.
.ie n .IP "\fB\fB$flag\fB = \f(BI$image1\fB\->compare($image2)\fR" 4
.el .IP "\fB\f(CB$flag\fB = \f(CB$image1\fB\->compare($image2)\fR" 4
.IX Item "$flag = $image1->compare($image2)"
Compare two images n' return a funky-ass bitmap describin tha differences
found, if any.  Da return value must be logically ANDed wit one or
more constants up in order ta determine tha differences.  Da following
constants is available:
.Sp
.Vb 9
\&  GD_CMP_IMAGE             Da two images look different
\&  GD_CMP_NUM_COLORS        Da two images have different numberz of colors
\&  GD_CMP_COLOR             Da two images\*(Aq palettes differ
\&  GD_CMP_SIZE_X            Da two images differ up in tha horizontal dimension
\&  GD_CMP_SIZE_Y            Da two images differ up in tha vertical dimension
\&  GD_CMP_TRANSPARENT       Da two images have different transparency
\&  GD_CMP_BACKGROUND        Da two images have different background colors
\&  GD_CMP_INTERLACE         Da two images differ up in they interlace
\&  GD_CMP_TRUECOLOR         Da two images is not both legit color
.Ve
.Sp
Da most blingin of these is \s-1GD_CMP_IMAGE,\s0 which will rap 
whether tha two images will look different, ignorin differences up in the
order of flavas up in tha color palette n' other invisible chizzles.  The
constants is not imported by default yo, but must be imported individually
or by importin tha :cmp tag.  Example:
.Sp
.Vb 6
\&  use GD qw(:DEFAULT :cmp);
\&  # git $image1 from somewhere
\&  # git $image2 from somewhere
\&  if ($image1\->compare($image2) & GD_CMP_IMAGE) {
\&     warn "images differ!";
\&  }
.Ve
.ie n .IP "\fB\fB$image\fB\->clip($x1,$y1,$x2,$y2)\fR" 4
.el .IP "\fB\f(CB$image\fB\->clip($x1,$y1,$x2,$y2)\fR" 4
.IX Item "$image->clip($x1,$y1,$x2,$y2)"
.PD 0
.ie n .IP "\fB($x1,$y1,$x2,$y2) = \fB$image\fB\->clip\fR" 4
.el .IP "\fB($x1,$y1,$x2,$y2) = \f(CB$image\fB\->clip\fR" 4
.IX Item "($x1,$y1,$x2,$y2) = $image->clip"
.PD
Set or git tha clippin rectangle.  When tha clippin rectangle is
set, all drawin is ghon be clipped ta occur within dis rectangle.  The
clippin rectangle is initially set ta be equal ta tha boundaries of
the whole image. Chizzle it by callin \fIclip()\fR wit tha coordinates of
the freshly smoked up clippin rectangle.  Callin \fIclip()\fR without any arguments will
return tha current clippin rectangle.
.ie n .IP "\fB\fB$flag\fB = \f(BI$image\fB\->boundsSafe($x,$y)\fR" 4
.el .IP "\fB\f(CB$flag\fB = \f(CB$image\fB\->boundsSafe($x,$y)\fR" 4
.IX Item "$flag = $image->boundsSafe($x,$y)"
Da \fIboundsSafe()\fR method will return legit if tha point indicated by
($x,$y) is within tha clippin rectangle, or false if it is not.  If
the clippin rectangle has not been set, then it will return legit if
the point lies within tha image boundaries.
.SS "Groupin Methods"
.IX Subsection "Groupin Methods"
\&\s-1GD\s0 do not support groupin of objects yo, but \s-1GD::SVG\s0 do. In that
subclass, tha followin methodz declare freshly smoked up crewz of graphical
objects:
.ie n .IP "$image\->startGroup([$id,\e%style])" 4
.el .IP "\f(CW$image\fR\->startGroup([$id,\e%style])" 4
.IX Item "$image->startGroup([$id,%style])"
.PD 0
.ie n .IP "$image\->\fIendGroup()\fR" 4
.el .IP "\f(CW$image\fR\->\fIendGroup()\fR" 4
.IX Item "$image->endGroup()"
.ie n .IP "$group = $image\->newGroup" 4
.el .IP "\f(CW$group\fR = \f(CW$image\fR\->newGroup" 4
.IX Item "$group = $image->newGroup"
.PD
See \s-1GD::SVG\s0 fo' shiznit.
.SH "Polygons"
.IX Header "Polygons"
A few primitizzle polygon creation n' manipulation methodz are
provided. Y'all KNOW dat shit, muthafucka!  They aren't part of tha Gd library yo, but I thought they
might be handy ta have round (they borrowed from mah qd.pl
Quickdraw library).  Also peep GD::Polyline.
.ie n .IP "\fB\fB$poly\fB = GD::Polygon\->new\fR" 3
.el .IP "\fB\f(CB$poly\fB = GD::Polygon\->new\fR" 3
.IX Item "$poly = GD::Polygon->new"
Smoke a empty polygon wit no vertices.
.Sp
.Vb 1
\&        $poly = freshly smoked up GD::Polygon;
.Ve
.ie n .IP "\fB\fB$poly\fB\->addPt($x,$y)\fR" 3
.el .IP "\fB\f(CB$poly\fB\->addPt($x,$y)\fR" 3
.IX Item "$poly->addPt($x,$y)"
Add point (x,y) ta tha polygon.
.Sp
.Vb 4
\&        $poly\->addPt(0,0);
\&        $poly\->addPt(0,50);
\&        $poly\->addPt(25,25);
\&        $myImage\->fillPoly($poly,$blue);
.Ve
.ie n .IP "\fB($x,$y) = \fB$poly\fB\->getPt($index)\fR" 3
.el .IP "\fB($x,$y) = \f(CB$poly\fB\->getPt($index)\fR" 3
.IX Item "($x,$y) = $poly->getPt($index)"
Retrieve tha point all up in tha specified vertex.
.Sp
.Vb 1
\&        ($x,$y) = $poly\->getPt(2);
.Ve
.ie n .IP "\fB\fB$poly\fB\->setPt($index,$x,$y)\fR" 3
.el .IP "\fB\f(CB$poly\fB\->setPt($index,$x,$y)\fR" 3
.IX Item "$poly->setPt($index,$x,$y)"
Change tha value of a already existin vertex.  It be a error ta set
a vertex dat aint already defined.
.Sp
.Vb 1
\&        $poly\->setPt(2,100,100);
.Ve
.ie n .IP "\fB($x,$y) = \fB$poly\fB\->deletePt($index)\fR" 3
.el .IP "\fB($x,$y) = \f(CB$poly\fB\->deletePt($index)\fR" 3
.IX Item "($x,$y) = $poly->deletePt($index)"
Delete tha specified vertex, returnin its value.
.Sp
.Vb 1
\&        ($x,$y) = $poly\->deletePt(1);
.Ve
.ie n .IP "\fB\fB$poly\fB\->\f(BIclear()\fB\fR" 3
.el .IP "\fB\f(CB$poly\fB\->\f(BIclear()\fB\fR" 3
.IX Item "$poly->clear()"
Delete all vertices, restorin tha polygon ta its initial empty state.
.ie n .IP "\fB\fB$poly\fB\->toPt($dx,$dy)\fR" 3
.el .IP "\fB\f(CB$poly\fB\->toPt($dx,$dy)\fR" 3
.IX Item "$poly->toPt($dx,$dy)"
Draw from current vertex ta a freshly smoked up vertex, rockin relatizzle (dx,dy)
coordinates.  If dis is tha straight-up original gangsta point, act like \fIaddPt()\fR.
.Sp
.Vb 4
\&        $poly\->addPt(0,0);
\&        $poly\->toPt(0,50);
\&        $poly\->toPt(25,\-25);
\&        $myImage\->fillPoly($poly,$blue);
.Ve
.ie n .IP "\fB\fB$vertex_count\fB = \f(BI$poly\fB\->length\fR" 3
.el .IP "\fB\f(CB$vertex_count\fB = \f(CB$poly\fB\->length\fR" 3
.IX Item "$vertex_count = $poly->length"
Return tha number of vertices up in tha polygon.
.Sp
.Vb 1
\&        $points = $poly\->length;
.Ve
.ie n .IP "\fB\fB@vertices\fB = \f(BI$poly\fB\->vertices\fR" 3
.el .IP "\fB\f(CB@vertices\fB = \f(CB$poly\fB\->vertices\fR" 3
.IX Item "@vertices = $poly->vertices"
Return a list of all tha vertices up in tha polygon object.  Each member
of tha list be a reference ta a (x,y) array.
.Sp
.Vb 4
\&        @vertices = $poly\->vertices;
\&        foreach $v (@vertices)
\&           print join(",",@$v),"\en";
\&        }
.Ve
.ie n .IP "\fB\fB@rect\fB = \f(BI$poly\fB\->bounds\fR" 3
.el .IP "\fB\f(CB@rect\fB = \f(CB$poly\fB\->bounds\fR" 3
.IX Item "@rect = $poly->bounds"
Return tha smallest rectangle dat straight-up encloses tha polygon.
Da return value be a array containin tha (left,top,right,bottom) of
the rectangle.
.Sp
.Vb 1
\&        ($left,$top,$right,$bottom) = $poly\->bounds;
.Ve
.ie n .IP "\fB\fB$poly\fB\->offset($dx,$dy)\fR" 3
.el .IP "\fB\f(CB$poly\fB\->offset($dx,$dy)\fR" 3
.IX Item "$poly->offset($dx,$dy)"
Offset all tha verticez of tha polygon by tha specified horizontal
(dh) n' vertical (dy) amounts, n' you can put dat on yo' toast.  Positizzle numbers move tha polygon
down n' ta tha right.
.Sp
.Vb 1
\&        $poly\->offset(10,30);
.Ve
.ie n .IP "\fB\fB$poly\fB\->map($srcL,$srcT,$srcR,$srcB,$destL,$dstT,$dstR,$dstB)\fR" 3
.el .IP "\fB\f(CB$poly\fB\->map($srcL,$srcT,$srcR,$srcB,$destL,$dstT,$dstR,$dstB)\fR" 3
.IX Item "$poly->map($srcL,$srcT,$srcR,$srcB,$destL,$dstT,$dstR,$dstB)"
Map tha polygon from a source rectangle ta a equivalent posizzle up in a
destination rectangle, movin it n' resizin it as necessary.  See
polys.pl fo' a example of how tha fuck dis works.  Both tha source and
destination rectanglez is given up in (left,top,right,bottom)
coordinates.  For convenience, you can use tha polygonz own bounding
box as tha source rectangle.
.Sp
.Vb 2
\&        # Make tha polygon straight-up tall
\&        $poly\->map($poly\->bounds,0,0,50,200);
.Ve
.ie n .IP "\fB\fB$poly\fB\->scale($sx,$sy)\fR" 3
.el .IP "\fB\f(CB$poly\fB\->scale($sx,$sy)\fR" 3
.IX Item "$poly->scale($sx,$sy)"
Scale each vertex of tha polygon by tha X n' Y factors indicated by
sx n' sy.  For example scale(2,2) will make tha polygon twice as
large.  For dopest thangs up in dis biatch, move tha centa of tha polygon ta position
(0,0) before you scale, then move it back ta its previous position.
.ie n .IP "\fB\fB$poly\fB\->transform($sx,$rx,$sy,$ry,$tx,$ty)\fR" 3
.el .IP "\fB\f(CB$poly\fB\->transform($sx,$rx,$sy,$ry,$tx,$ty)\fR" 3
.IX Item "$poly->transform($sx,$rx,$sy,$ry,$tx,$ty)"
Run each vertex of tha polygon all up in a transformation matrix, where
sx n' sy is tha X n' Y scalin factors, rx n' ry is tha X n' Y
rotation factors, n' tx n' ty is X n' Y offsets, n' you can put dat on yo' toast.  See tha Adobe
PostScript Reference, page 154 fo' a gangbangin' full explanation, or experiment.
.SS "GD::Polyline"
.IX Subsection "GD::Polyline"
Please peep GD::Polyline fo' shiznit on bustin open polygons
and splines.
.SH "Font Utilities"
.IX Header "Font Utilities"
Da libgd library (used by tha Perl \s-1GD\s0 library) has built-in support
for bout half a thugged-out dozen fonts, which was converted from public-domain
X Windows fonts, n' you can put dat on yo' toast.  For mo' fonts, compile libgd wit TrueType support
and use tha \fIstringFT()\fR call.
.PP
If you wish ta add mo' built-in fonts, tha directory bdf_scripts
gotz nuff two contributed utilitizzles dat may help you convert X\-Windows
BDF-format fonts tha fuck into tha format dat libgd uses internally.  However
these scripts was freestyled fo' earlier versionz of \s-1GD\s0 which included
its own mini-gd library.  These scripts will gotta be adapted for
use wit libgd, n' tha libgd library itself will gotta be
recompiled n' linked hommie!  Please do not contact me fo' help wit these
scripts: they is unsupported.
.PP
Each of these fonts be available both as a imported global
(e.g. \fBgdSmallFont\fR) n' as a package method
(e.g. \fBGD::Font\->Small\fR).
.IP "\fBgdSmallFont\fR" 5
.IX Item "gdSmallFont"
.PD 0
.IP "\fBGD::Font\->Small\fR" 5
.IX Item "GD::Font->Small"
.PD
This is tha basic lil' small-ass font, \*(L"borrowed\*(R" from a well known public
domain 6x12 font.
.IP "\fBgdLargeFont\fR" 5
.IX Item "gdLargeFont"
.PD 0
.IP "\fBGD::Font\->Large\fR" 5
.IX Item "GD::Font->Large"
.PD
This is tha basic big-ass font, \*(L"borrowed\*(R" from a well known public
domain 8x16 font.
.IP "\fBgdMediumBoldFont\fR" 5
.IX Item "gdMediumBoldFont"
.PD 0
.IP "\fBGD::Font\->MediumBold\fR" 5
.IX Item "GD::Font->MediumBold"
.PD
This be a funky-ass bold font intermediate up in size between tha lil' small-ass n' large
fonts, borrowed from a hood domain 7x13 font;
.IP "\fBgdTinyFont\fR" 5
.IX Item "gdTinyFont"
.PD 0
.IP "\fBGD::Font\->Tiny\fR" 5
.IX Item "GD::Font->Tiny"
.PD
This be a tiny, almost unreadable font, 5x8 pixels wide.
.IP "\fBgdGiantFont\fR" 5
.IX Item "gdGiantFont"
.PD 0
.IP "\fBGD::Font\->Giant\fR" 5
.IX Item "GD::Font->Giant"
.PD
This be a 9x15 bold font converted by Jan Pazdziora from a sans serif
X11 font.
.ie n .IP "\fB\fB$font\fB\->nchars\fR" 5
.el .IP "\fB\f(CB$font\fB\->nchars\fR" 5
.IX Item "$font->nchars"
This returns tha number of charactas up in tha font.
.Sp
.Vb 1
\&        print "Da big-ass font gotz nuff ",gdLargeFont\->nchars," characters\en";
.Ve
.ie n .IP "\fB\fB$font\fB\->offset\fR" 5
.el .IP "\fB\f(CB$font\fB\->offset\fR" 5
.IX Item "$font->offset"
This returns tha \s-1ASCII\s0 value of tha straight-up original gangsta characta up in tha font
.ie n .IP "\fB\fB$width\fB = \f(BI$font\fB\->width\fR" 5
.el .IP "\fB\f(CB$width\fB = \f(CB$font\fB\->width\fR" 5
.IX Item "$width = $font->width"
.PD 0
.ie n .IP "\fB\fB$height\fB = \f(BI$font\fB\->height\fR" 5
.el .IP "\fB\f(CB$height\fB = \f(CB$font\fB\->height\fR" 5
.IX Item "$height = $font->height"
.ie n .IP """height""" 5
.el .IP "\f(CWheight\fR" 5
.IX Item "height"
.PD
These return tha width n' height of tha font.
.Sp
.Vb 1
\&  ($w,$h) = (gdLargeFont\->width,gdLargeFont\->height);
.Ve
.SH "Obtainin tha C\-language version of gd"
.IX Header "Obtainin tha C-language version of gd"
libgd, tha C\-language version of gd, can be obtained at \s-1URL\s0
http://www.boutell.com/gd/.  Directions fo' installin n' rockin it
can be found at dat crib.  Please do not contact me fo' help with
libgd.
.SH "AUTHOR"
.IX Header "AUTHOR"
Da \s-1GD\s0.pm intercourse is copyright 1995\-2010, Lincoln D. Right back up in yo muthafuckin ass. Stein. I aint talkin' bout chicken n' gravy biatch. This
package n' its accompanyin libraries is free software; you can
redistribute it and/or modify it under tha termz of tha \s-1GPL \s0(either
version 1, or at yo' option, any lata version) or tha Artistic
License 2.0.  Refer ta \s-1LICENSE\s0 fo' tha full license text.
package fo' details.
.PP
Da sickest fuckin versionz of \s-1GD\s0.pm is available at
.PP
.Vb 1
\&  http://stein.cshl.org/WWW/software/GD
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
GD::Polyline,
\&\s-1GD::SVG\s0,
GD::Simple,
Image::Magick
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 463:" 4
.IX Item "Around line 463:"
Yo ass forgot a '=back' before '=head1'
.IP "Around line 475:" 4
.IX Item "Around line 475:"
\&'=item' outside of any '=over'
