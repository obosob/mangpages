.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_CTX_use_certificate 3"
.TH SSL_CTX_use_certificate 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_CTX_use_certificate, SSL_CTX_use_certificate_ASN1, SSL_CTX_use_certificate_file, SSL_use_certificate, SSL_use_certificate_ASN1, SSL_use_certificate_file, SSL_CTX_use_certificate_chain_file, SSL_CTX_use_PrivateKey, SSL_CTX_use_PrivateKey_ASN1, SSL_CTX_use_PrivateKey_file, SSL_CTX_use_RSAPrivateKey, SSL_CTX_use_RSAPrivateKey_ASN1, SSL_CTX_use_RSAPrivateKey_file, SSL_use_PrivateKey_file, SSL_use_PrivateKey_ASN1, SSL_use_PrivateKey, SSL_use_RSAPrivateKey, SSL_use_RSAPrivateKey_ASN1, SSL_use_RSAPrivateKey_file, SSL_CTX_check_private_key, SSL_check_private_key \- load certificate n' key data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);
\& int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, unsigned char *d);
\& int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type);
\& int SSL_use_certificate(SSL *ssl, X509 *x);
\& int SSL_use_certificate_ASN1(SSL *ssl, unsigned char *d, int len);
\& int SSL_use_certificate_file(SSL *ssl, const char *file, int type);
\&
\& int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file);
\&
\& int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
\& int SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx, unsigned char *d,
\&                                 long len);
\& int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);
\& int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);
\& int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, unsigned char *d, long len);
\& int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type);
\& int SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey);
\& int SSL_use_PrivateKey_ASN1(int pk,SSL *ssl, unsigned char *d, long len);
\& int SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type);
\& int SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa);
\& int SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len);
\& int SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type);
\&
\& int SSL_CTX_check_private_key(const SSL_CTX *ctx);
\& int SSL_check_private_key(const SSL *ssl);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These functions load tha certificates n' private keys tha fuck into tha \s-1SSL_CTX\s0
or \s-1SSL\s0 object, respectively.
.PP
Da SSL_CTX_* class of functions loadz tha certificates n' keys tha fuck into the
\&\s-1SSL_CTX\s0 object \fBctx\fR. Da shiznit is passed ta \s-1SSL\s0 objects \fBssl\fR
created from \fBctx\fR wit \fISSL_new\fR\|(3) by copying, so that
changes applied ta \fBctx\fR do not propagate ta already existin \s-1SSL\s0 objects.
.PP
Da SSL_* class of functions only loadz certificates n' keys tha fuck into a
specific \s-1SSL\s0 object. Da specific shiznit is kept, when
\&\fISSL_clear\fR\|(3) is called fo' dis \s-1SSL\s0 object.
.PP
\&\fISSL_CTX_use_certificate()\fR loadz tha certificate \fBx\fR tha fuck into \fBctx\fR,
\&\fISSL_use_certificate()\fR loadz \fBx\fR tha fuck into \fBssl\fR. Da rest of the
certificates needed ta form tha complete certificate chain can be
specified rockin the
\&\fISSL_CTX_add_extra_chain_cert\fR\|(3)
function.
.PP
\&\fISSL_CTX_use_certificate_ASN1()\fR loadz tha \s-1ASN1\s0 encoded certificate from
the memory location \fBd\fR (with length \fBlen\fR) tha fuck into \fBctx\fR,
\&\fISSL_use_certificate_ASN1()\fR loadz tha \s-1ASN1\s0 encoded certificate tha fuck into \fBssl\fR.
.PP
\&\fISSL_CTX_use_certificate_file()\fR loadz tha straight-up original gangsta certificate stored up in \fBfile\fR
into \fBctx\fR. Da formattin \fBtype\fR of tha certificate must be specified
from tha known types \s-1SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1.\s0
\&\fISSL_use_certificate_file()\fR loadz tha certificate from \fBfile\fR tha fuck into \fBssl\fR.
See tha \s-1NOTES\s0 section on why \fISSL_CTX_use_certificate_chain_file()\fR
should be preferred.
.PP
\&\fISSL_CTX_use_certificate_chain_file()\fR loadz a cold-ass lil certificate chain from 
\&\fBfile\fR tha fuck into \fBctx\fR. Da certificates must be up in \s-1PEM\s0 format n' must
be sorted startin wit tha subjectz certificate (actual client or server
certificate), followed by intermediate \s-1CA\s0 certificates if applicable, and
endin all up in tha highest level (root) \s-1CA.\s0
There is no correspondin function hustlin on a single \s-1SSL\s0 object.
.PP
\&\fISSL_CTX_use_PrivateKey()\fR addz \fBpkey\fR as private key ta \fBctx\fR.
\&\fISSL_CTX_use_RSAPrivateKey()\fR addz tha private key \fBrsa\fR of type \s-1RSA\s0
to \fBctx\fR. \fISSL_use_PrivateKey()\fR addz \fBpkey\fR as private key ta \fBssl\fR;
\&\fISSL_use_RSAPrivateKey()\fR addz \fBrsa\fR as private key of type \s-1RSA\s0 ta \fBssl\fR.
If a cold-ass lil certificate has already been set n' tha private do not belong
to tha certificate a error is returned. Y'all KNOW dat shit, muthafucka! To chizzle a cold-ass lil certificate, private
key pair tha freshly smoked up certificate need ta be set wit \fISSL_use_certificate()\fR
or \fISSL_CTX_use_certificate()\fR before settin tha private key with
\&\fISSL_CTX_use_PrivateKey()\fR or \fISSL_use_PrivateKey()\fR.
.PP
\&\fISSL_CTX_use_PrivateKey_ASN1()\fR addz tha private key of type \fBpk\fR
stored at memory location \fBd\fR (length \fBlen\fR) ta \fBctx\fR.
\&\fISSL_CTX_use_RSAPrivateKey_ASN1()\fR addz tha private key of type \s-1RSA\s0
stored at memory location \fBd\fR (length \fBlen\fR) ta \fBctx\fR.
\&\fISSL_use_PrivateKey_ASN1()\fR n' \fISSL_use_RSAPrivateKey_ASN1()\fR add tha private
key ta \fBssl\fR.
.PP
\&\fISSL_CTX_use_PrivateKey_file()\fR addz tha straight-up original gangsta private key found in
\&\fBfile\fR ta \fBctx\fR. Da formattin \fBtype\fR of tha certificate must be specified
from tha known types \s-1SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1.\s0
\&\fISSL_CTX_use_RSAPrivateKey_file()\fR addz tha straight-up original gangsta private \s-1RSA\s0 key found in
\&\fBfile\fR ta \fBctx\fR. \fISSL_use_PrivateKey_file()\fR addz tha straight-up original gangsta private key found
in \fBfile\fR ta \fBssl\fR; \fISSL_use_RSAPrivateKey_file()\fR addz tha straight-up original gangsta private
\&\s-1RSA\s0 key found ta \fBssl\fR.
.PP
\&\fISSL_CTX_check_private_key()\fR checks tha consistency of a private key with
the correspondin certificate loaded tha fuck into \fBctx\fR. If mo' than one
key/certificate pair (\s-1RSA/DSA\s0) is installed, tha last item installed will
be checked. Y'all KNOW dat shit, muthafucka! If e.g. tha last item was a \s-1RSA\s0 certificate or key, tha \s-1RSA\s0
key/certificate pair is ghon be checked. Y'all KNOW dat shit, muthafucka! \fISSL_check_private_key()\fR performs
the same check fo' \fBssl\fR. If no key/certificate was explicitly added for
this \fBssl\fR, tha last item added tha fuck into \fBctx\fR is ghon be checked.
.SH "NOTES"
.IX Header "NOTES"
Da internal certificate store of OpenSSL can hold two private key/certificate
pairs at a time: one key/certificate of type \s-1RSA\s0 n' one key/certificate
of type \s-1DSA.\s0 Da certificate used dependz on tha cipher select, see
also \fISSL_CTX_set_cipher_list\fR\|(3).
.PP
When readin certificates n' private keys from file, filez of type
\&\s-1SSL_FILETYPE_ASN1 \s0(also known as \fB\s-1DER\s0\fR, binary encoding) can only contain
one certificate or private key, consequently 
\&\fISSL_CTX_use_certificate_chain_file()\fR is only applicable ta \s-1PEM\s0 formatting.
Filez of type \s-1SSL_FILETYPE_PEM\s0 can contain mo' than one item.
.PP
\&\fISSL_CTX_use_certificate_chain_file()\fR addz tha straight-up original gangsta certificate found
in tha file ta tha certificate store. Da other certificates is added
to tha store of chain certificates using
\&\fISSL_CTX_add_extra_chain_cert\fR\|(3).
There exists only one extra chain store, so dat tha same chain be appended
to both typez of certificates, \s-1RSA\s0 n' \s-1DSA\s0! If it aint intended ta use
both type of certificate all up in tha same time, it is recommended ta use the
\&\fISSL_CTX_use_certificate_chain_file()\fR instead of the
\&\fISSL_CTX_use_certificate_file()\fR function up in order ta allow tha use of
complete certificate chains even when no trusted \s-1CA\s0 storage is used or
when tha \s-1CA\s0 issuin tha certificate shall not be added ta tha trusted
\&\s-1CA\s0 storage.
.PP
If additionizzle certificates is needed ta complete tha chain durin the
\&\s-1TLS\s0 negotiation, \s-1CA\s0 certificates is additionally looked up in the
locationz of trusted \s-1CA\s0 certificates, see
\&\fISSL_CTX_load_verify_locations\fR\|(3).
.PP
Da private keys loaded from file can be encrypted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In order ta successfully
load encrypted keys, a gangbangin' function returnin tha passphrase must have been
supplied, see
\&\fISSL_CTX_set_default_passwd_cb\fR\|(3).
(Certificate filez might be encrypted as well from tha technical point
of view, it however do not make sense as tha data up in tha certificate
is considered hood anyway.)
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
On success, tha functions return 1.
Otherwise check up tha error stack ta smoke up tha reason.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIssl\fR\|(3), \fISSL_new\fR\|(3), \fISSL_clear\fR\|(3),
\&\fISSL_CTX_load_verify_locations\fR\|(3),
\&\fISSL_CTX_set_default_passwd_cb\fR\|(3),
\&\fISSL_CTX_set_cipher_list\fR\|(3),
\&\fISSL_CTX_set_client_cert_cb\fR\|(3),
\&\fISSL_CTX_add_extra_chain_cert\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
Support fo' \s-1DER\s0 encoded private keys (\s-1SSL_FILETYPE_ASN1\s0) in
\&\fISSL_CTX_use_PrivateKey_file()\fR n' \fISSL_use_PrivateKey_file()\fR was added
in 0.9.8 .
