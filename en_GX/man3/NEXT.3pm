.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "NEXT 3pm"
.TH NEXT 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
NEXT.pm \- Provide a pseudo\-class NEXT (et al) dat allows method redispatch
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use NEXT;
\&
\&    package A;
\&    sub A::method   { print "$_[0]: A method\en";   $_[0]\->NEXT::method() }
\&    sub A::DESTROY  { print "$_[0]: A dtor\en";     $_[0]\->NEXT::DESTROY() }
\&
\&    package B;
\&    use base qw( A );
\&    sub B::AUTOLOAD { print "$_[0]: B AUTOLOAD\en"; $_[0]\->NEXT::AUTOLOAD() }
\&    sub B::DESTROY  { print "$_[0]: B dtor\en";     $_[0]\->NEXT::DESTROY() }
\&
\&    package C;
\&    sub C::method   { print "$_[0]: C method\en";   $_[0]\->NEXT::method() }
\&    sub C::AUTOLOAD { print "$_[0]: C AUTOLOAD\en"; $_[0]\->NEXT::AUTOLOAD() }
\&    sub C::DESTROY  { print "$_[0]: C dtor\en";     $_[0]\->NEXT::DESTROY() }
\&
\&    package D;
\&    use base qw( B C );
\&    sub D::method   { print "$_[0]: D method\en";   $_[0]\->NEXT::method() }
\&    sub D::AUTOLOAD { print "$_[0]: D AUTOLOAD\en"; $_[0]\->NEXT::AUTOLOAD() }
\&    sub D::DESTROY  { print "$_[0]: D dtor\en";     $_[0]\->NEXT::DESTROY() }
\&
\&    package main;
\&
\&    mah $obj = bless {}, "D";
\&
\&    $obj\->method();             # Calls D::method, A::method, C::method
\&    $obj\->missing_method(); # Calls D::AUTOLOAD, B::AUTOLOAD, C::AUTOLOAD
\&
\&    # Clean\-up calls D::DESTROY, B::DESTROY, A::DESTROY, C::DESTROY
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1NEXT\s0.pm addz a pseudoclass named \f(CW\*(C`NEXT\*(C'\fR ta any program
that uses dat shit. If a method \f(CW\*(C`m\*(C'\fR calls \f(CW\*(C`$self\->NEXT::m()\*(C'\fR, tha call to
\&\f(CW\*(C`m\*(C'\fR is redispatched as if tha callin method had not originally been found.
.PP
In other lyrics, a cold-ass lil call ta \f(CW\*(C`$self\->NEXT::m()\*(C'\fR resumes tha depth-first,
left-to-right search of \f(CW$self\fRz class hierarchy dat resulted up in the
original gangsta call ta \f(CW\*(C`m\*(C'\fR.
.PP
Note dat dis aint tha same thang as \f(CW\*(C`$self\->SUPER::m()\*(C'\fR, which
begins a freshly smoked up dispatch dat is restricted ta searchin tha ancestors
of tha current class. \f(CW\*(C`$self\->NEXT::m()\*(C'\fR can backtrack
past tha current class \*(-- ta look fo' a suitable method up in other
ancestorz of \f(CW$self\fR \*(-- whereas \f(CW\*(C`$self\->SUPER::m()\*(C'\fR cannot.
.PP
A typical use would be up in tha destructorz of a cold-ass lil class hierarchy,
as illustrated up in tha synopsis above. Each class up in tha hierarchy
has a \s-1DESTROY\s0 method dat performs some class-specific action
and then redispatches tha call up tha hierarchy fo' realz. As a result,
when a object of class D is destroyed, tha destructorz of \fIall\fR
its parent classes is called (in depth-first, left-to-right order).
.PP
Another typical use of redispatch would be up in \f(CW\*(C`AUTOLOAD\*(C'\fR'ed methods.
If such a method determined dat dat shiznit was not able ta handle a
particular call, it might chizzle ta redispatch dat call, up in the
hope dat some other \f(CW\*(C`AUTOLOAD\*(C'\fR (above it, or ta its left) might
do better.
.PP
By default, if a redispatch attempt fails ta find another method
elsewhere up in tha objects class hierarchy, it on tha fuckin' down-lowly gives up n' do
nothang (but peep \*(L"Enforcin redispatch\*(R"). This gracious acquiescence
is also unlike tha (generally buggin) behaviour of \f(CW\*(C`SUPER\*(C'\fR, which
throws a exception if it cannot redispatch.
.PP
Note dat it aint nuthin but a gangbangin' fatal error fo' any method (includin \f(CW\*(C`AUTOLOAD\*(C'\fR)
to attempt ta redispatch any method dat aint gots the
same name. For example:
.PP
.Vb 1
\&        sub D::oops { print "oops!\en"; $_[0]\->NEXT::other_method() }
.Ve
.SS "Enforcin redispatch"
.IX Subsection "Enforcin redispatch"
It be possible ta make \f(CW\*(C`NEXT\*(C'\fR redispatch mo' demandingly (i.e. like
\&\f(CW\*(C`SUPER\*(C'\fR do), so dat tha redispatch throws a exception if it cannot
find a \*(L"next\*(R" method ta call.
.PP
To do this, simple invoke tha redispatch as:
.PP
.Vb 1
\&        $self\->NEXT::ACTUAL::method();
.Ve
.PP
rather than:
.PP
.Vb 1
\&        $self\->NEXT::method();
.Ve
.PP
Da \f(CW\*(C`ACTUAL\*(C'\fR  drops some lyrics ta \f(CW\*(C`NEXT\*(C'\fR dat there must straight-up be a next method ta call,
or it should throw a exception.
.PP
\&\f(CW\*(C`NEXT::ACTUAL\*(C'\fR is most commonly used up in \f(CW\*(C`AUTOLOAD\*(C'\fR methods, as a means to
decline a \f(CW\*(C`AUTOLOAD\*(C'\fR request yo, but preserve tha aiiight exception-on-failure 
semantics:
.PP
.Vb 8
\&        sub AUTOLOAD {
\&                if ($AUTOLOAD =~ /foo|bar/) {
\&                        # handle here
\&                }
\&                else {  # try elsewhere
\&                        shift()\->NEXT::ACTUAL::AUTOLOAD(@_);
\&                }
\&        }
.Ve
.PP
By rockin \f(CW\*(C`NEXT::ACTUAL\*(C'\fR, if there is no other \f(CW\*(C`AUTOLOAD\*(C'\fR ta handle the
method call, a exception is ghon be thrown (as probably happens up in tha absence of
a suitable \f(CW\*(C`AUTOLOAD\*(C'\fR).
.SS "Avoidin repetitions"
.IX Subsection "Avoidin repetitions"
If \f(CW\*(C`NEXT\*(C'\fR redispatchin is used up in tha methodz of a \*(L"diamond\*(R" class hierarchy:
.PP
.Vb 5
\&        #     A   B
\&        #    / \e /
\&        #   C   D
\&        #    \e /
\&        #     E
\&
\&        use NEXT;
\&
\&        package A;                 
\&        sub foo { print "called A::foo\en"; shift\->NEXT::foo() }
\&
\&        package B;                 
\&        sub foo { print "called B::foo\en"; shift\->NEXT::foo() }
\&
\&        package C; @ISA = qw( A );
\&        sub foo { print "called C::foo\en"; shift\->NEXT::foo() }
\&
\&        package D; @ISA = qw(A B);
\&        sub foo { print "called D::foo\en"; shift\->NEXT::foo() }
\&
\&        package E; @ISA = qw(C D);
\&        sub foo { print "called E::foo\en"; shift\->NEXT::foo() }
\&
\&        E\->foo();
.Ve
.PP
then derived classes may (re\-)inherit base-class methodz all up in two or
more distinct paths (e.g. up in tha way \f(CW\*(C`E\*(C'\fR inherits \f(CW\*(C`A::foo\*(C'\fR twice \*(--
all up in \f(CW\*(C`C\*(C'\fR n' \f(CW\*(C`D\*(C'\fR). In such cases, a sequence of \f(CW\*(C`NEXT\*(C'\fR redispatches
will invoke tha multiply inherited method as nuff times as it is
inherited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. For example, tha above code prints:
.PP
.Vb 6
\&        called E::foo
\&        called C::foo
\&        called A::foo
\&        called D::foo
\&        called A::foo
\&        called B::foo
.Ve
.PP
(i.e. \f(CW\*(C`A::foo\*(C'\fR is called twice).
.PP
In some cases dis \fImay\fR be tha desired effect within a gangbangin' finger-lickin' diamond hierarchy,
but up in others (e.g. fo' destructors) it may be mo' appropriate ta 
call each method only once durin a sequence of redispatches.
.PP
To cover such cases, you can redispatch methodz via:
.PP
.Vb 1
\&        $self\->NEXT::DISTINCT::method();
.Ve
.PP
rather than:
.PP
.Vb 1
\&        $self\->NEXT::method();
.Ve
.PP
This causes tha redispatcher ta only visit each distinct \f(CW\*(C`method\*(C'\fR method
once. That is, ta skip any classes up in tha hierarchy dat it has
already hit up durin redispatch. Right back up in yo muthafuckin ass. So, fo' example, if the
previous example was rewritten:
.PP
.Vb 2
\&        package A;                 
\&        sub foo { print "called A::foo\en"; shift\->NEXT::DISTINCT::foo() }
\&
\&        package B;                 
\&        sub foo { print "called B::foo\en"; shift\->NEXT::DISTINCT::foo() }
\&
\&        package C; @ISA = qw( A );
\&        sub foo { print "called C::foo\en"; shift\->NEXT::DISTINCT::foo() }
\&
\&        package D; @ISA = qw(A B);
\&        sub foo { print "called D::foo\en"; shift\->NEXT::DISTINCT::foo() }
\&
\&        package E; @ISA = qw(C D);
\&        sub foo { print "called E::foo\en"; shift\->NEXT::DISTINCT::foo() }
\&
\&        E\->foo();
.Ve
.PP
then it would print:
.PP
.Vb 5
\&        called E::foo
\&        called C::foo
\&        called A::foo
\&        called D::foo
\&        called B::foo
.Ve
.PP
and omit tha second call ta \f(CW\*(C`A::foo\*(C'\fR (since it would not be distinct
from tha straight-up original gangsta call ta \f(CW\*(C`A::foo\*(C'\fR).
.PP
Note dat you can also use:
.PP
.Vb 1
\&        $self\->NEXT::DISTINCT::ACTUAL::method();
.Ve
.PP
or:
.PP
.Vb 1
\&        $self\->NEXT::ACTUAL::DISTINCT::method();
.Ve
.PP
to git both unique invocation \fIand\fR exception-on-failure.
.PP
Note that, fo' oldschool compatibility, you can also use
\&\f(CW\*(C`NEXT::UNSEEN\*(C'\fR instead of \f(CW\*(C`NEXT::DISTINCT\*(C'\fR.
.SS "Invokin all versionz of a method wit a single call"
.IX Subsection "Invokin all versionz of a method wit a single call"
Yet another pseudo-class dat \s-1NEXT\s0.pm serves up is \f(CW\*(C`EVERY\*(C'\fR.
Its behaviour is considerably simpla than dat of tha \f(CW\*(C`NEXT\*(C'\fR crew.
A call to:
.PP
.Vb 1
\&        $obj\->EVERY::foo();
.Ve
.PP
calls \fIevery\fR method named \f(CW\*(C`foo\*(C'\fR dat tha object up in \f(CW$obj\fR has inherited.
That is:
.PP
.Vb 1
\&        use NEXT;
\&
\&        package A; @ISA = qw(B D X);
\&        sub foo { print "A::foo " }
\&
\&        package B; @ISA = qw(D X);
\&        sub foo { print "B::foo " }
\&
\&        package X; @ISA = qw(D);
\&        sub foo { print "X::foo " }
\&
\&        package D;
\&        sub foo { print "D::foo " }
\&
\&        package main;
\&
\&        mah $obj = bless {}, \*(AqA\*(Aq;
\&        $obj\->EVERY::foo();        # prints" A::foo B::foo X::foo D::foo
.Ve
.PP
Prefixin a method call wit \f(CW\*(C`EVERY::\*(C'\fR causes every last muthafuckin method up in the
objectz hierarchy wit dat name ta be invoked. Y'all KNOW dat shit, muthafucka! As tha above example
illustrates, they is not called up in Perlz usual \*(L"left-most-depth-first\*(R"
order n' shit. Instead, they is called \*(L"breadth-first-dependency-wise\*(R".
.PP
That means dat tha inheritizzle tree of tha object is traversed breadth-first
and tha resultin order of classes is used as tha sequence up in which methods
are called. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat that sequence is modified by imposin a rule dat the
appropriate method of a thugged-out derived class must be called before tha same method of
any ancestral class. Thatz why, up in tha above example, \f(CW\*(C`X::foo\*(C'\fR is called
before \f(CW\*(C`D::foo\*(C'\fR, even though \f(CW\*(C`D\*(C'\fR comes before \f(CW\*(C`X\*(C'\fR up in \f(CW@B::ISA\fR.
.PP
In general, there be a no need ta worry bout tha order of calls. They will be
left-to-right, breadth-first, most-derived-first. This works perfectly for
most inherited methodz (includin destructors) yo, but is inappropriate for
some kindz of methodz (like fuckin constructors, cloners, debuggers, and
initializers) where itz mo' appropriate dat tha least-derived methodz be
called first (as more-derived methodz may rely on tha behaviour of their
\&\*(L"ancestors\*(R"). In dat case, instead of rockin tha \f(CW\*(C`EVERY\*(C'\fR pseudo-class:
.PP
.Vb 1
\&        $obj\->EVERY::foo();        # prints" A::foo B::foo X::foo D::foo
.Ve
.PP
you can use tha \f(CW\*(C`EVERY::LAST\*(C'\fR pseudo-class:
.PP
.Vb 1
\&        $obj\->EVERY::LAST::foo();  # prints" D::foo X::foo B::foo A::foo
.Ve
.PP
which reverses tha order of method call.
.PP
Whichever version is used, tha actual methodz is called up in tha same
context (list, scalar, or void) as tha original gangsta call via \f(CW\*(C`EVERY\*(C'\fR, n' return:
.IP "\(bu" 4
A hash of array references up in list context. Each entry of tha hash has the
fully qualified method name as its key n' a reference ta a array containing
the methodz list-context return joints as its value.
.IP "\(bu" 4
A reference ta a hash of scalar joints up in scalar context. Each entry of tha hash has the
fully qualified method name as its key n' tha methodz scalar-context return joints as its value.
.IP "\(bu" 4
Nothang up in void context (obviously).
.ie n .SS "Usin ""EVERY"" methods"
.el .SS "Usin \f(CWEVERY\fP methods"
.IX Subsection "Usin EVERY methods"
Da typical way ta use a \f(CW\*(C`EVERY\*(C'\fR call is ta wrap it up in another base
method, dat all classes inherit. For example, ta ensure dat every
destructor a object inherits is straight-up called (as opposed ta just the
left-most-depth-first-est one):
.PP
.Vb 2
\&        package Base;
\&        sub DESTROY { $_[0]\->EVERY::Destroy }
\&
\&        package Derived1; 
\&        use base \*(AqBase\*(Aq;
\&        sub Destroy {...}
\&
\&        package Derived2; 
\&        use base \*(AqBase\*(Aq, \*(AqDerived1\*(Aq;
\&        sub Destroy {...}
.Ve
.PP
et cetera. Every derived class than needz its own clean-up
behaviour simply addz its own \f(CW\*(C`Destroy\*(C'\fR method (\fInot\fR a \f(CW\*(C`DESTROY\*(C'\fR method),
which tha call ta \f(CW\*(C`EVERY::LAST::Destroy\*(C'\fR up in tha inherited destructor
then erectly picks up.
.PP
Likewise, ta create a cold-ass lil class hierarchy up in which every last muthafuckin initializer inherited by
a freshly smoked up object is invoked:
.PP
.Vb 6
\&        package Base;
\&        sub freshly smoked up {
\&                mah ($class, %args) = @_;
\&                mah $obj = bless {}, $class;
\&                $obj\->EVERY::LAST::Init(\e%args);
\&        }
\&
\&        package Derived1; 
\&        use base \*(AqBase\*(Aq;
\&        sub Init {
\&                mah ($argsref) = @_;
\&                ...
\&        }
\&
\&        package Derived2; 
\&        use base \*(AqBase\*(Aq, \*(AqDerived1\*(Aq;
\&        sub Init {
\&                mah ($argsref) = @_;
\&                ...
\&        }
.Ve
.PP
et cetera. Every derived class than needz some additionizzle initialization
behaviour simply addz its own \f(CW\*(C`Init\*(C'\fR method (\fInot\fR a \f(CW\*(C`new\*(C'\fR method),
which tha call ta \f(CW\*(C`EVERY::LAST::Init\*(C'\fR up in tha inherited constructor
then erectly picks up.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Because itz a module, not a integral part of tha interpreter, \s-1NEXT\s0.pm
has ta guess where tha surroundin call was found up in tha method
look-up sequence. In tha presence of diamond inheritizzle patterns
it occasionally guesses wrong.
.PP
It aint nuthin but also too slow (despite caching).
.PP
Comment, suggestions, n' patches welcome.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\& Copyright (c) 2000\-2001, Damian Conway fo' realz. All Rights Reserved.
\& This module is free software. Well shiiiit, it may be used, redistributed
\&    and/or modified under tha same terms as Perl itself.
.Ve
