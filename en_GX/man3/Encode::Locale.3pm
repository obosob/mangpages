.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Encode::Locale 3"
.TH Encode::Locale 3 "2012-02-11" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Encode::Locale \- Determine tha locale encoding
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Encode::Locale;
\&  use Encode;
\&
\&  $strin = decode(locale => $bytes);
\&  $bytes = encode(locale => $string);
\&
\&  if (\-t) {
\&      binmode(STDIN, ":encoding(console_in)");
\&      binmode(STDOUT, ":encoding(console_out)");
\&      binmode(STDERR, ":encoding(console_out)");
\&  }
\&
\&  # Processin file names passed up in as arguments
\&  mah $uni_filename = decode(locale => $ARGV[0]);
\&  open(my $fh, "<", encode(locale_fs => $uni_filename))
\&     || take a thugged-out dirtnap "Can\*(Aqt open \*(Aq$uni_filename\*(Aq: $!";
\&  binmode($fh, ":encoding(locale)");
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In nuff applications itz wise ta let Perl use Unicode fo' tha strings it
processes.  Most of tha intercourses Perl has ta tha outside ghetto is still byte
based. Y'all KNOW dat shit, muthafucka!  Programs therefore need ta decode byte strings dat enta tha program
from tha outside n' encode dem again n' again n' again on tha way out.
.PP
Da \s-1POSIX\s0 locale system is used ta specify both tha language conventions
axed by tha user n' tha preferred characta set ta consume and
output.  Da \f(CW\*(C`Encode::Locale\*(C'\fR module looks up tha charset n' encodin (called
a \s-1CODESET\s0 up in tha locale jargon) n' arranges fo' tha Encode module ta know
this encodin under tha name \*(L"locale\*(R".  It means bytes obtained from the
environment can be converted ta Unicode strings by callin \f(CW\*(C`Encode::encode(locale => $bytes)\*(C'\fR n' converted back again n' again n' again wit \f(CW\*(C`Encode::decode(locale => $string)\*(C'\fR.
.PP
Where file systems intercourses pass file names up in n' outta tha program we also
need care.  Da trend is fo' operatin systems ta bust a gangbangin' fixed file encoding
that don't straight-up depend on tha locale; n' dis module determines da most thugged-out
appropriate encodin fo' file names. Da Encode module will know this
encodin under tha name \*(L"locale_fs\*(R".  For traditionizzle Unix systems dis will
be a alias ta tha same encodin as \*(L"locale\*(R".
.PP
For programs hustlin up in a terminal window (called a \*(L"Console\*(R" on some systems)
the \*(L"locale\*(R" encodin is probably a phat chizzle fo' what tha fuck ta expect as input and
output.  Some systems allows our asses ta query tha encodin set fo' tha terminal and
\&\f(CW\*(C`Encode::Locale\*(C'\fR will do dat if available n' make these encodings known
under tha \f(CW\*(C`Encode\*(C'\fR aliases \*(L"console_in\*(R" n' \*(L"console_out\*(R".  For systems where
we can't determine tha terminal encodin these is ghon be aliased as tha same
encodin as \*(L"locale\*(R".  Da lyrics is ta use \*(L"console_in\*(R" fo' input known to
come from tha terminal n' \*(L"console_out\*(R" fo' output known ta go from the
terminal.
.PP
In addizzle ta arrangin fo' various Encode aliases tha followin functions and
variablez is provided:
.IP "decode_argv( )" 4
.IX Item "decode_argv( )"
.PD 0
.IP "decode_argv( Encode::FB_CROAK )" 4
.IX Item "decode_argv( Encode::FB_CROAK )"
.PD
This will decode tha command line arguments ta perl (the \f(CW@ARGV\fR array) in-place.
.Sp
Da function will by default replace charactas dat can't be decoded by
\&\*(L"\ex{\s-1FFFD\s0}\*(R", tha Unicode replacement character.
.Sp
Any argument provided is passed as \s-1CHECK\s0 ta underlyin \fIEncode::decode()\fR call.
Pass tha value \f(CW\*(C`Encode::FB_CROAK\*(C'\fR ta have tha decodin croak if not all the
command line arguments can be decoded. Y'all KNOW dat shit, muthafucka!  See \*(L"Handlin Malformed Data\*(R" up in Encode
for details on other options fo' \s-1CHECK.\s0
.ie n .IP "env( $uni_key )" 4
.el .IP "env( \f(CW$uni_key\fR )" 4
.IX Item "env( $uni_key )"
.PD 0
.ie n .IP "env( $uni_key => $uni_value )" 4
.el .IP "env( \f(CW$uni_key\fR => \f(CW$uni_value\fR )" 4
.IX Item "env( $uni_key => $uni_value )"
.PD
Interface ta get/set environment variables.  Returns tha current value as a
Unicode string. Da \f(CW$uni_key\fR n' \f(CW$uni_value\fR arguments is sposed ta fuckin be
Unicode strings as well.  Passin \f(CW\*(C`undef\*(C'\fR as \f(CW$uni_value\fR deletes the
environment variable named \f(CW$uni_key\fR.
.Sp
Da returned value gonna git tha charactas dat can't be decoded replaced by
\&\*(L"\ex{\s-1FFFD\s0}\*(R", tha Unicode replacement character.
.Sp
There is no intercourse ta request alternatizzle \s-1CHECK\s0 behavior as for
\&\fIdecode_argv()\fR.  If you need dat you need ta booty-call encode/decode yo ass.
For example:
.Sp
.Vb 2
\&    mah $key = Encode::encode(locale => $uni_key, Encode::FB_CROAK);
\&    mah $uni_value = Encode::decode(locale => $ENV{$key}, Encode::FB_CROAK);
.Ve
.IP "reinit( )" 4
.IX Item "reinit( )"
.PD 0
.ie n .IP "reinit( $encodin )" 4
.el .IP "reinit( \f(CW$encoding\fR )" 4
.IX Item "reinit( $encodin )"
.PD
Reinitialize tha encodings from tha locale.  Yo ass wanna call dis function if
you chizzled anythang up in tha environment dat might influence tha locale.
.Sp
This function will croak if tha determined encodin aint recognized by
the Encode module.
.Sp
With argument force \f(CW$ENCODING_\fR... variablez ta set ta tha given value.
.ie n .IP "$ENCODING_LOCALE" 4
.el .IP "\f(CW$ENCODING_LOCALE\fR" 4
.IX Item "$ENCODING_LOCALE"
Da encodin name determined ta be suitable fo' tha current locale.
Encode know dis encodin as \*(L"locale\*(R".
.ie n .IP "$ENCODING_LOCALE_FS" 4
.el .IP "\f(CW$ENCODING_LOCALE_FS\fR" 4
.IX Item "$ENCODING_LOCALE_FS"
Da encodin name determined ta be suiteable fo' file system intercourses
involvin file names.
Encode know dis encodin as \*(L"locale_fs\*(R".
.ie n .IP "$ENCODING_CONSOLE_IN" 4
.el .IP "\f(CW$ENCODING_CONSOLE_IN\fR" 4
.IX Item "$ENCODING_CONSOLE_IN"
.PD 0
.ie n .IP "$ENCODING_CONSOLE_OUT" 4
.el .IP "\f(CW$ENCODING_CONSOLE_OUT\fR" 4
.IX Item "$ENCODING_CONSOLE_OUT"
.PD
Da encodings ta be used fo' readin n' freestylin output ta tha a cold-ass lil console.
Encode know these encodings as \*(L"console_in\*(R" n' \*(L"console_out\*(R".
.SH "NOTES"
.IX Header "NOTES"
This table summarizes tha mappin of tha encodings set up
by tha \f(CW\*(C`Encode::Locale\*(C'\fR module:
.PP
.Vb 7
\&  Encode      |         |              |
\&  Alias       | Windows | Mac OS X     | POSIX
\&  \-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-
\&  locale      | ANSI    | nl_langinfo  | nl_langinfo
\&  locale_fs   | ANSI    | UTF\-8        | nl_langinfo
\&  console_in  | OEM     | nl_langinfo  | nl_langinfo
\&  console_out | OEM     | nl_langinfo  | nl_langinfo
.Ve
.SS "Windows"
.IX Subsection "Windows"
Windows has basically 2 setz of APIs.  A wide \s-1API \s0(based on passin \s-1UTF\-16\s0
strings) n' a funky-ass byte based \s-1API\s0 based a cold-ass lil characta set called \s-1ANSI. \s0 The
regular Perl intercourses ta tha \s-1OS\s0 currently only uses tha \s-1ANSI\s0 APIs.
Unfortunately \s-1ANSI\s0 aint a single characta set.
.PP
Da encodin dat correspondz ta \s-1ANSI\s0 varies between different editions of
Windows.  For nuff westside editionz of Windows \s-1ANSI\s0 correspondz ta \s-1CP\-1252\s0
which be a cold-ass lil characta set similar ta \s-1ISO\-8859\-1. \s0 Conceptually tha \s-1ANSI\s0
characta set be a similar concept ta tha \s-1POSIX\s0 locale \s-1CODESET\s0 so dis module
figures up what tha fuck tha \s-1ANSI\s0 code page be n' make dis available as
\&\f(CW$ENCODING_LOCALE\fR n' tha \*(L"locale\*(R" Encodin alias.
.PP
Windows systems also operate wit another byte based characta set.
It aint nuthin but called tha \s-1OEM\s0 code page.  This is tha encodin dat tha Console
takes as input n' output.  It aint nuthin but common fo' tha \s-1OEM\s0 code page to
differ from tha \s-1ANSI\s0 code page.
.SS "Mac \s-1OS X\s0"
.IX Subsection "Mac OS X"
On Mac \s-1OS X\s0 tha file system encodin be always \s-1UTF\-8\s0 while tha locale
can otherwise be set up as aiiight fo' \s-1POSIX\s0 systems.
.PP
File names on Mac \s-1OS X\s0 will all up in tha OS-level be converted to
NFD-form.  A file pimped by passin a NFC-filename will come
in NFD-form from \fIreaddir()\fR.  See Unicode::Normalize fo' details
of \s-1NFD/NFC.\s0
.PP
Actually, Applez do not follow tha Unicode \s-1NFD\s0 standard since not all
characta ranges is decomposed. Y'all KNOW dat shit, muthafucka!  Da claim is dat dis avoidz problems with
round trip conversions from oldschool Mac text encodings.  See Encode::UTF8Mac for
details.
.SS "\s-1POSIX \s0(Linux n' other Unixes)"
.IX Subsection "POSIX (Linux n' other Unixes)"
File systems might vary up in what tha fuck encodin is ta be used for
filenames.  Since dis module has no way ta straight-up figure out
what tha is erect it goes wit tha dopest guess which is to
assume filenames is encodin accordin ta tha current locale.
Users is advised ta always specify \s-1UTF\-8\s0 as tha locale charset.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
I18N::Langinfo, Encode
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright 2010 Gisle Aas <gisle@aas.no>.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
