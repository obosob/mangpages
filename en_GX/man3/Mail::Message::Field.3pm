.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message::Field 3"
.TH Mail::Message::Field 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Field \- one line of a message header
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Message::Field
\&   be a Mail::Reporter
\&
\& Mail::Message::Field is extended by
\&   Mail::Message::Field::Fast
\&   Mail::Message::Field::Flex
\&   Mail::Message::Field::Full
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\& mah $field = Mail::Message::Field\->new(From => \*(Aqfish@tux.aq\*(Aq);
\& print $field\->name;
\& print $field\->body;
\& print $field\->comment;
\& print $field\->content;  # body & comment
\& $field\->print(\e*OUT);
\& print $field\->string;
\& print "$field\en";
\& print $field\->attribute(\*(Aqcharset\*(Aq) || \*(Aqus\-ascii\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This implementation bigs up tha guidelinez of rfc2822 as close as possible,
and may there produce a gangbangin' finger-lickin' different output than implementations based on
the obsolete rfc822.  But fuck dat shiznit yo, tha word on tha street is dat tha oldschool output will still be accepted.
.PP
These objects each store one header line, n' facilitates access routines to
the shiznit hidden up in dat shit.  Also, you may want ta git a peep the
added methodz of a message:
.PP
.Vb 4
\& mah @from    = $message\->from;
\& mah $sender  = $message\->sender;
\& mah $subject = $message\->subject;
\& mah $msgid   = $message\->messageId;
\&
\& mah @to      = $message\->to;
\& mah @cc      = $message\->cc;
\& mah @bcc     = $message\->bcc;
\& mah @dest    = $message\->destinations;
\&
\& mah $other   = $message\->get(\*(AqReply\-To\*(Aq);
.Ve
.SH "OVERLOADED"
.IX Header "OVERLOADED"
.ie n .IP "overload: \fB""""\fR()" 4
.el .IP "overload: \fB``''\fR()" 4
.IX Item "overload: """"()"
(stringification) produces tha unfolded body of tha field, which may
be what tha fuck you expect.  This is what tha fuck make what tha fuck tha field object seems
to be a simple string. Da strang is produced by \fIunfoldedBody()\fR.
.Sp
example:
.Sp
.Vb 2
\& print $msg\->get(\*(Aqsubject\*(Aq);  # via overloading
\& print $msg\->get(\*(Aqsubject\*(Aq)\->unfoldedBody; # same
\&
\& mah $subject = $msg\->get(\*(Aqsubject\*(Aq) || \*(Aqyour mail\*(Aq;
\& print "Re: $subject\en";
.Ve
.IP "overload: \fB0+\fR()" 4
.IX Item "overload: 0+()"
(numification) When tha field is numeric, tha value is ghon be returned.
Da result is produced by \fItoInt()\fR.  If tha value aint erect,
a \f(CW0\fR is produced, ta simplify calculations.
.IP "overload: \fB<=\fR>()" 4
.IX Item "overload: <=>()"
(numeric comparison) Compare tha integer field contents wit something
else.
.Sp
example:
.Sp
.Vb 2
\& if($msg\->get(\*(AqContent\-Length\*(Aq) > 10000) ...
\& if($msg\->size > 10000) ... ; # same yo, but better
.Ve
.IP "overload: \fBbool\fR()" 4
.IX Item "overload: bool()"
Always true, ta make it possible ta say \f(CW\*(C`if($field)\*(C'\fR.
.IP "overload: \fBcmp\fR()" 4
.IX Item "overload: cmp()"
(strin comparison) Compare tha unfolded body of a gangbangin' field wit a other
field or a string, rockin tha buildin \f(CW\*(C`cmp\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBclone\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBclone\fR()" 4
.IX Item "$obj->clone()"
Smoke a cold-ass lil copy of dis field object.
.IP "Mail::Message::Field\->\fBnew\fR(\s-1DATA\s0)" 4
.IX Item "Mail::Message::Field->new(DATA)"
See \fIMail::Message::Field::Fast::new()\fR,
\&\fIMail::Message::Field::Flex::new()\fR,
and \fIMail::Message::Field::Full::new()\fR.
By default, a \f(CW\*(C`Fast\*(C'\fR field is produced.
.Sp
.Vb 3
\& \-Option\-\-Defined up in     \-\-Default
\&  log     Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  trace   Mail::Reporta   \*(AqWARNINGS\*(Aq
.Ve
.RS 4
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.RE
.RS 4
.RE
.PD
.SS "Da field"
.IX Subsection "Da field"
.ie n .IP "$obj\->\fBisStructured\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisStructured\fR()" 4
.IX Item "$obj->isStructured()"
.PD 0
.IP "Mail::Message::Field\->\fBisStructured\fR()" 4
.IX Item "Mail::Message::Field->isStructured()"
.PD
Some fieldz is busted lyrics bout up in tha RFCs as bein \fIstructured\fR: havin a
well busted lyrics bout syntax.  These fieldz have common scams bout comments
and tha like, what tha fuck they do not share wit unstructured fields, like
the \f(CW\*(C`Subject\*(C'\fR field.
.Sp
example:
.Sp
.Vb 2
\& mah $field = Mail::Message::Field\->new(From => \*(Aqme\*(Aq);
\& if($field\->isStructured)
\&
\& Mail::Message::Field\->isStructured(\*(AqFrom\*(Aq);
.Ve
.ie n .IP "$obj\->\fBlength\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlength\fR()" 4
.IX Item "$obj->length()"
Returns tha total length of tha field up in characters, which includes the
fieldz name, body n' foldin characters.
.ie n .IP "$obj\->\fBnrLines\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnrLines\fR()" 4
.IX Item "$obj->nrLines()"
Returns tha number of lines needed ta display dis header-line.
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
Print tha whole header-line ta tha specified file-handle. One line may
result up in mo' than one printed line, cuz of tha foldin of long
lines.  Da \s-1FILEHANDLE\s0 defaults ta tha selected handle.
.ie n .IP "$obj\->\fBsize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsize\fR()" 4
.IX Item "$obj->size()"
Returns tha number of bytes needed ta display dis header-line, Same
as \fIlength()\fR.
.ie n .IP "$obj\->\fBstring\fR([\s-1WRAP\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBstring\fR([\s-1WRAP\s0])" 4
.IX Item "$obj->string([WRAP])"
Returns tha field as string.  By default, dis returns tha same ol' dirty as
\&\fIfolded()\fR. But fuck dat shiznit yo, tha word on tha street is dat tha optionizzle \s-1WRAP\s0 will cause ta re-fold ta take
place (without changin tha foldin stored inside tha field).
.ie n .IP "$obj\->\fBtoDisclose\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtoDisclose\fR()" 4
.IX Item "$obj->toDisclose()"
Returns whether dis field can be disclosed ta other people, fo' instance
when bustin  tha message ta a other party.  Returns a \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR
condition.
See also \fIMail::Message::Head::Complete::printUndisclosed()\fR.
.SS "Access ta tha name"
.IX Subsection "Access ta tha name"
.ie n .IP "$obj\->\fBName\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBName\fR()" 4
.IX Item "$obj->Name()"
Returns tha name of dis field up in original gangsta casing.  See \fIname()\fR as well.
.ie n .IP "$obj\->\fBname\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBname\fR()" 4
.IX Item "$obj->name()"
Returns tha name of dis field, wit all charactas lower-cased for
ease of comparison. I aint talkin' bout chicken n' gravy biatch.  See \fIName()\fR as well.
.ie n .IP "$obj\->\fBwellformedName\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBwellformedName\fR([\s-1STRING\s0])" 4
.IX Item "$obj->wellformedName([STRING])"
(Instizzle method class method)
As instizzle method, tha current fieldz name is erectly formatted
and returned. Y'all KNOW dat shit, muthafucka!  When a \s-1STRING\s0 is used, dat one is formatted.
.Sp
example:
.Sp
.Vb 2
\& print Mail::Message::Field\->Name(\*(Aqcontent\-type\*(Aq)
\&   # \-\->  Content\-Type
\&
\& mah $field = $head\->get(\*(Aqdate\*(Aq);
\& print $field\->Name;
\&   # \-\->  Date
.Ve
.SS "Access ta tha body"
.IX Subsection "Access ta tha body"
.ie n .IP "$obj\->\fBbody\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBbody\fR()" 4
.IX Item "$obj->body()"
This method may be what tha fuck you want yo, but usually, tha \fIfoldedBody()\fR and
\&\fIunfoldedBody()\fR is what tha fuck yo ass is lookin for. Shiiit, dis aint no joke.  This method is
cultural heritage, n' should be avoided.
.Sp
Returns tha body of tha field. Y'all KNOW dat shit, muthafucka!  When dis field is structured, it will
be \fBstripped\fR from every last muthafuckin thang what tha fuck is behind tha straight-up original gangsta semi-color (\f(CW\*(C`;\*(C'\fR).
In any case, tha strang is unfolded. Y'all KNOW dat shit, muthafucka!  
Whether tha field is structured is defined by \fIisStructured()\fR.
.ie n .IP "$obj\->\fBfolded\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfolded\fR()" 4
.IX Item "$obj->folded()"
Returns tha folded version of tha whole header n' shit.  When tha header is
shorta than tha wrap length, a list of one line is returned. Y'all KNOW dat shit, muthafucka!  Otherwise
more lines is ghon be returned, all but tha straight-up original gangsta startin wit at least
one blank.  See also \fIfoldedBody()\fR ta git tha same shiznit without
the fieldz name.
.Sp
In scalar context, tha lines is delived tha fuck into one string, which is
a lil fasta cuz thatz tha way they is stored internally...
.Sp
example:
.Sp
.Vb 3
\& mah @lines = $field\->folded;
\& print $field\->folded;
\& print scalar $field\->folded; # faster
.Ve
.ie n .IP "$obj\->\fBfoldedBody\fR([\s-1BODY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfoldedBody\fR([\s-1BODY\s0])" 4
.IX Item "$obj->foldedBody([BODY])"
Returns tha body as a set of lines. In scalar context, dis is ghon be one line
containin newlines.  Be warned bout tha newlines when you do
pattern-matchin on tha result of thie method.
.Sp
Da optionizzle \s-1BODY\s0 argument chizzlez tha fieldz body.  Da foldin of the
argument must be erect.
.ie n .IP "$obj\->\fBstripCFWS\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBstripCFWS\fR([\s-1STRING\s0])" 4
.IX Item "$obj->stripCFWS([STRING])"
.PD 0
.IP "Mail::Message::Field\->\fBstripCFWS\fR([\s-1STRING\s0])" 4
.IX Item "Mail::Message::Field->stripCFWS([STRING])"
.PD
Remove tha \fIcomments\fR n' \fIfoldin white spaces\fR from tha \s-1STRING. \s0 Without
strin n' only as instizzle method, tha \fIunfoldedBody()\fR is bein stripped
and returned.
.Sp
\&\s-1WARNING:\s0 This operation is only allowed fo' structured header fieldz (which
are defined by tha various RFCs as bein so.  Yo ass don't want parts within
braces which is up in tha Subject header line ta be removed, ta give an
example.
.ie n .IP "$obj\->\fBunfoldedBody\fR([\s-1BODY,\s0 [\s-1WRAP\s0]])" 4
.el .IP "\f(CW$obj\fR\->\fBunfoldedBody\fR([\s-1BODY,\s0 [\s-1WRAP\s0]])" 4
.IX Item "$obj->unfoldedBody([BODY, [WRAP]])"
Returns tha body as one single line, where all foldin shiznit (if
available) is removed. Y'all KNOW dat shit, muthafucka!  This line will also \s-1NOT\s0 end on a new-line.
.Sp
Da optionizzle \s-1BODY\s0 argument chizzlez tha fieldz body.  Da right foldin is
performed before assignment.  Da \s-1WRAP\s0 may be specified ta enforce a
foldin size.
.Sp
example:
.Sp
.Vb 2
\& mah $body = $field\->unfoldedBody;
\& print "$field";   # via overloading
.Ve
.SS "Access ta tha content"
.IX Subsection "Access ta tha content"
.ie n .IP "$obj\->\fBaddresses\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddresses\fR()" 4
.IX Item "$obj->addresses()"
Returns a list of Mail::Address objects, which represent the
e\-mail addresses found up in dis header line.
.Sp
example:
.Sp
.Vb 2
\& mah @addr = $message\->head\->get(\*(Aqto\*(Aq)\->addresses;
\& mah @addr = $message\->to;
.Ve
.ie n .IP "$obj\->\fBattribute\fR(\s-1NAME\s0 [, \s-1VALUE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBattribute\fR(\s-1NAME\s0 [, \s-1VALUE\s0])" 4
.IX Item "$obj->attribute(NAME [, VALUE])"
Git tha value of a attribute, optionally afta settin it ta a freshly smoked up value.
Attributes is part of some header lines, n' hide theyselves up in the
comment field. Y'all KNOW dat shit, muthafucka!  If tha attribute do not exist, then \f(CW\*(C`undef\*(C'\fR is
returned. Y'all KNOW dat shit, muthafucka!  Da attribute is still encoded.
.Sp
example:
.Sp
.Vb 2
\& mah $field = Mail::Message::Field\->new(
\&  \*(AqContent\-Type: text/plain; charset="us\-ascii"\*(Aq);
\&
\& print $field\->attribute(\*(Aqcharset\*(Aq);
\&   # \-\-> us\-ascii
\&
\& print $field\->attribute(\*(Aqbitmap\*(Aq) || \*(Aqno\*(Aq
\&   # \-\-> no
\&
\& $field\->atrribute(filename => \*(Aq/tmp/xyz\*(Aq);
\& $field\->print;
\&   # \-\-> Content\-Type: text/plain; charset="us\-ascii";
\&   #       filename="/tmp/xyz"
\&   # Automatically folded, n' no doublez pimped.
.Ve
.ie n .IP "$obj\->\fBattributes\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBattributes\fR()" 4
.IX Item "$obj->attributes()"
Returns a list of key-value pairs, where tha joints is not yet decoded.
.Sp
example:
.Sp
.Vb 1
\& mah %attributes = $head\->get(\*(AqContent\-Disposition\*(Aq)\->attributes;
.Ve
.ie n .IP "$obj\->\fBcomment\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBcomment\fR([\s-1STRING\s0])" 4
.IX Item "$obj->comment([STRING])"
Returns tha unfolded comment (part afta a semi-colon) up in a structureed
header-line. optionally afta settin it ta a freshly smoked up \s-1STRING\s0 first.
When \f(CW\*(C`undef\*(C'\fR is specified as \s-1STRING,\s0 tha comment is removed.
Whether tha field is structured is defined by \fIisStructured()\fR.
.Sp
Da \fIcomment\fR part of a header field often gotz nuff \f(CW\*(C`attributes\*(C'\fR.  Often
it is preferred ta use \fIattribute()\fR on em.
.ie n .IP "$obj\->\fBstudy\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstudy\fR()" 4
.IX Item "$obj->study()"
Study tha header field up in detail: turn on tha full parsin n' detailed
understandin of tha content of tha fields.  Mail::Message::Field::Fast
and Mail::Message::Field::Fast objects is ghon be transformed tha fuck into any
Mail::Message::Field::Full object.
.Sp
example:
.Sp
.Vb 3
\& mah $subject = $msg\->head\->get(\*(Aqsubject\*(Aq)\->study;
\& mah $subject = $msg\->head\->study(\*(Aqsubject\*(Aq);  # same
\& mah $subject = $msg\->study(\*(Aqsubject\*(Aq);        # same
.Ve
.ie n .IP "$obj\->\fBtoDate\fR([\s-1TIME\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtoDate\fR([\s-1TIME\s0])" 4
.IX Item "$obj->toDate([TIME])"
.PD 0
.IP "Mail::Message::Field\->\fBtoDate\fR([\s-1TIME\s0])" 4
.IX Item "Mail::Message::Field->toDate([TIME])"
.PD
Convert a timestamp tha fuck into a rfc2822 compliant date format.  This differs
from tha default output of \f(CW\*(C`localtime\*(C'\fR up in scalar context.  Without
argument, tha \f(CW\*(C`localtime\*(C'\fR is used ta git tha current time. \s-1TIME\s0 can
be specified as one numeric (like tha result of \f(CW\*(C`time()\*(C'\fR) n' as list
(like produced by c<\fIlocaltime()\fR> up in list context).
.Sp
Be shizzle ta have yo' timezone set right, especially when dis script
runs automatically.
.Sp
example:
.Sp
.Vb 3
\& mah $now = time;
\& Mail::Message::Field\->toDate($now);
\& Mail::Message::Field\->toDate(time);
\&
\& Mail::Message::Field\->toDate(localtime);
\& Mail::Message::Field\->toDate;      # same
\& # returns sometin like:
\& #     Wed, 28 Aug 2002 10:40:25 +0200
.Ve
.ie n .IP "$obj\->\fBtoInt\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtoInt\fR()" 4
.IX Item "$obj->toInt()"
Returns tha value which is related ta dis field as integer n' shit.  A check is
performed whether dis is right.
.SS "Other methods"
.IX Subsection "Other methods"
.ie n .IP "$obj\->\fBdateToTimestamp\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdateToTimestamp\fR(\s-1STRING\s0)" 4
.IX Item "$obj->dateToTimestamp(STRING)"
.PD 0
.IP "Mail::Message::Field\->\fBdateToTimestamp\fR(\s-1STRING\s0)" 4
.IX Item "Mail::Message::Field->dateToTimestamp(STRING)"
.PD
Convert a \s-1STRING\s0 which represents n' \s-1RFC\s0 compliant time strang into
a timestamp like is produced by tha \f(CW\*(C`time\*(C'\fR function.
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBconsume\fR(\s-1LINE\s0 | (\s-1NAME\s0,BODY|OBJECTS))" 4
.el .IP "\f(CW$obj\fR\->\fBconsume\fR(\s-1LINE\s0 | (\s-1NAME\s0,BODY|OBJECTS))" 4
.IX Item "$obj->consume(LINE | (NAME,BODY|OBJECTS))"
Accepts a whole field \s-1LINE,\s0 or a pair wit tha fieldz \s-1NAME\s0 n' \s-1BODY.\s0 In
the latta case, tha \s-1BODY\s0 data may be specified as array of \s-1OBJECTS\s0 which
are stringified. Y'all KNOW dat shit, muthafucka!  Returned be a sickly formatted pair of two strings: the
fieldz name n' a gangbangin' folded body.
.Sp
This method is called by \fInew()\fR, n' probably not by a application
program. Da details bout convertin tha \s-1OBJECTS\s0 ta a gangbangin' field content
are explained up in \*(L"Specifyin field data\*(R".
.ie n .IP "$obj\->\fBdefaultWrapLength\fR([\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultWrapLength\fR([\s-1LENGTH\s0])" 4
.IX Item "$obj->defaultWrapLength([LENGTH])"
Any field from any header fo' any message gonna git dis default wrapping.
This is maintained up in one global variable.  Without a specified \s-1LENGTH,\s0
the current value is returned. Y'all KNOW dat shit, muthafucka!  Da default is 78.
.ie n .IP "$obj\->\fBfold\fR(\s-1NAME, BODY,\s0 [\s-1MAXCHARS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold\fR(\s-1NAME, BODY,\s0 [\s-1MAXCHARS\s0])" 4
.IX Item "$obj->fold(NAME, BODY, [MAXCHARS])"
.PD 0
.IP "Mail::Message::Field\->\fBfold\fR(\s-1NAME, BODY,\s0 [\s-1MAXCHARS\s0])" 4
.IX Item "Mail::Message::Field->fold(NAME, BODY, [MAXCHARS])"
.PD
Make tha header field wit \s-1NAME\s0 fold tha fuck into multiple lines.
Rappin bout is performed by insertin newlines before a funky-ass blanks up in the
\&\s-1BODY,\s0 such dat no line exceedz tha \s-1MAXCHARS\s0 n' each line be as long
as possible.
.Sp
Da \s-1RFC\s0 requests fo' foldin on sick spots yo, but dis request is
mainly ignored cuz it would make foldin too slow.
.ie n .IP "$obj\->\fBsetWrapLength\fR([\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBsetWrapLength\fR([\s-1LENGTH\s0])" 4
.IX Item "$obj->setWrapLength([LENGTH])"
Force tha wrappin of dis field ta tha specified \s-1LENGTH\s0 characters. The
wrappin is performed wit \fIfold()\fR n' tha thangs up in dis biatch stored within
the field object.
.Sp
example: refoldin tha field
.Sp
.Vb 1
\& $field\->setWrapLength(99);
.Ve
.ie n .IP "$obj\->\fBstringifyData\fR(STRING|ARRAY|OBJECTS)" 4
.el .IP "\f(CW$obj\fR\->\fBstringifyData\fR(STRING|ARRAY|OBJECTS)" 4
.IX Item "$obj->stringifyData(STRING|ARRAY|OBJECTS)"
This method implements tha translation of user supplied objects into
ascii fields.  Da process is explained up in \*(L"Specifyin field data\*(R".
.ie n .IP "$obj\->\fBunfold\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBunfold\fR(\s-1STRING\s0)" 4
.IX Item "$obj->unfold(STRING)"
Da reverse action of \fIfold()\fR: all lines which form tha body of a gangbangin' field
are joined tha fuck into one by removin all line terminators (even tha last).
Possible leadin blanks on tha straight-up original gangsta line is removed as well.
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Message::Field\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Message::Field->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Message::Field\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Message::Field->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Message::Field\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Message::Field->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Field syntax"
.IX Subsection "Field syntax"
Fieldz is stored up in tha header of a message, which is represented by
Mail::Message::Head objects fo' realz. A field be a cold-ass lil combination of a \fIname\fR,
\&\fIbody\fR, n' \fIattributes\fR.  Especially tha term \*(L"body\*(R" is cause for
confusion: sometimes tha attributes is considered ta be part of tha body.
.PP
Da name of tha field is followed by a cold-ass lil colon ("\f(CW\*(C`:\*(C'\fR\*(L", not preceded by
blanks yo, but followed by one blank).  Each attribute is preceded by
a separate semi-colon (\*(R"\f(CW\*(C`;\*(C'\fR").  Namez of fieldz is case-insensitizzle and
cannot contain blanks.
.PP
\fIFoldin fields\fR
.IX Subsection "Foldin fields"
.PP
Fieldz which is long can be folded ta span mo' than one line.  Da real
limit fo' lines up in lyrics is only at 998 characters, however such long
lines is not easy as fuck  ta read without support of a application. I aint talkin' bout chicken n' gravy biatch.  Therefore
rfc2822 (which defines tha message syntax) specifies explicitly that
field lines can be re-formatted tha fuck into multiple sorta lines without chizzle
of meaning, by addin new-line charactas ta any field before any blank or
tab.
.PP
Usually, tha lines is reformatted ta create lines which is 78 characters
maximum. Right back up in yo muthafuckin ass. Some applications try harder ta fold on sick spots, like before
attributes.  Especially tha \f(CW\*(C`Received\*(C'\fR field is often manually folded into
some sick layout.  In most cases however, it is preferred ta produce lines
which is as long as possible but max 78.
.PP
\&\s-1BE WARNED\s0 dat all fieldz can be subjected ta folding, n' dat you usually
want tha unfolded value.
.PP
\fIStructured fields\fR
.IX Subsection "Structured fields"
.PP
Da rfc2822 raps on some big-ass number of header fieldz explicitly.  These
fieldz gotz a thugged-out defined meaning.  For a shitload of tha fields, like tha \f(CW\*(C`Subject\*(C'\fR
field, tha meanin is straight forward tha contents itself.  These fields
are tha \fIUnstructured Fields\fR.
.PP
Other fieldz gotz a well defined internal syntax cuz they content is
needed by e\-mail applications. For instance, tha \f(CW\*(C`To\*(C'\fR field gotz nuff
addresses which must be understood by all applications up in tha same way.
These is tha \fIStructured Fields\fR, peep \fIisStructured()\fR.
.PP
\fIComments up in fields\fR
.IX Subsection "Comments up in fields"
.PP
Stuctured fieldz can contain comments, which is piecez of text enclosed in
parenthesis.  These comments can be placed close ta anywhere up in tha line
and must be ignored be tha application. I aint talkin' bout chicken n' gravy biatch.  Not all applications is capable
of handlin comments erectly up in all circumstances.
.SS "Gettin a gangbangin' field"
.IX Subsection "Gettin a gangbangin' field"
As nuff programs as there be handlin e\-mail, as nuff variations on
accessin tha header shiznit is requested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Be careful which way
you access tha data: read tha variations busted lyrics bout here n' decide
which solution suites yo' needz best.
.PP
\fIUsin \fIget()\fI field\fR
.IX Subsection "Usin get() field"
.PP
Da \f(CW\*(C`get()\*(C'\fR intercourse is copied from other Perl modulez which can
handle e\-mail lyrics.  Many applications which simply replace
Mail::Internizzle objects by Mail::Message objects will work
without modification.
.PP
There is mo' than one git method. Y'all KNOW dat shit, muthafucka!  Da exact thangs up in dis biatch depend on which
get you use.  When \fIMail::Message::get()\fR is called, yo big-ass booty is ghon git the
unfolded, stripped from comments, stripped from attributes contents of
the field as \fBstring\fR.  Character-set encodings will still be up in the
string.  If tha same fieldname appears mo' than once up in tha header,
only tha last value is returned.
.PP
When \fIMail::Message::Head::get()\fR is called up in scalar context, the
last field wit tha specified name is returned as field \fBobject\fR.
This object strinigfies tha fuck into tha unfolded contentz of tha field, including
attributes n' comments, n' you can put dat on yo' toast.  In list context, all appearancez of tha field
in tha header is returned as objects.
.PP
\&\s-1BE WARNED\s0 dat some lines seem unique yo, but is not accordin ta the
straight-up legit rfc.  For instance, \f(CW\*(C`To\*(C'\fR fieldz can step tha fuck up mo' than once.
If yo' program calls \f(CW\*(C`get(\*(Aqto\*(Aq)\*(C'\fR up in scalar context, some shiznit
is lost.
.PP
\fIUsin \fIstudy()\fI field\fR
.IX Subsection "Usin study() field"
.PP
As tha name \f(CW\*(C`study\*(C'\fR already implies, dis way of accessin tha fieldz is
much mo' thorough but also slower n' shit.  Da \f(CW\*(C`study\*(C'\fR of a gangbangin' field is like a
\&\f(CW\*(C`get\*(C'\fR yo, but serves up easy as fuck  access ta tha content of tha field n' handles
character-set decodin erectly.
.PP
Da \fIMail::Message::study()\fR method will only return tha last field
with dat name as object.  \fIMail::Message::Head::study()\fR and
\&\fIMail::Message::Field::study()\fR return all fieldz when used up in list
context.
.PP
\fIUsin resent groups\fR
.IX Subsection "Usin resent groups"
.PP
Some fieldz belong together up in a crew of fields.  For instance, a set
of lines is used ta define one step up in tha mail transhiznit process.  Each
step addz a \f(CW\*(C`Received\*(C'\fR line, n' optionally some \f(CW\*(C`Resent\-*\*(C'\fR lines and
\&\f(CW\*(C`Return\-Path\*(C'\fR.  These crewz of lines shall stay together n' up in order
when tha message header is processed.
.PP
Da \f(CW\*(C`Mail::Message::Head::ResentGroup\*(C'\fR object simplifies tha access to
these related fields.  These resent crews can be deleted as a whole,
or erectly constructed.
.SS "Da fieldz data"
.IX Subsection "Da fieldz data"
There is nuff ways ta git tha fieldz info as object, n' there be also
many ways ta process dis data within tha field.
.PP
\fIAccess ta tha field\fR
.IX Subsection "Access ta tha field"
.IP "\(bu" 4
\&\fIstring()\fR
.Sp
Returns tha text of tha body exactly as is ghon be printed ta file when
\&\fIprint()\fR is called, so name, main body, n' attributes.
.IP "\(bu" 4
\&\fIfoldedBody()\fR
.Sp
Returns tha text of tha body, like \fIstring()\fR yo, but without tha name of
the field.
.IP "\(bu" 4
\&\fIunfoldedBody()\fR
.Sp
Returns tha text of tha body, like \fIfoldedBody()\fR yo, but then wit all
new-lines removed. Y'all KNOW dat shit, muthafucka!  This is tha aiiight way ta git tha content of
unstructured fields.  Character-set encodings will still be up in place.
Fieldz is stringified tha fuck into they unfolded representation.
.IP "\(bu" 4
\&\fIstripCFWS()\fR
.Sp
Returns tha text of structured fields, where new-lines n' comments are
removed from tha string.  This be a phat start fo' parsin tha field,
for instizzle ta find e\-mail addresses up in em.
.IP "\(bu" 4
\&\fIMail::Message::Field::Full::decodedBody()\fR
.Sp
Studied fieldz can produce tha unfolded text decoded tha fuck into utf8 strings.
This be a high-rollin' process yo, but tha only erect way ta git tha field's
data.  Mo' useful fo' playas whoz ass is not livin up in \s-1ASCII\s0 space.
.IP "\(bu" 4
Studied fields
.Sp
Studied fieldz have bangin methodz ta provide ways ta access n' produce
the contentz of (structured) fieldz exactly as tha involved rfcs prescribe.
.PP
\fIUsin simplified field access\fR
.IX Subsection "Usin simplified field access"
.PP
Some fieldz is accessed dat often dat there be support methodz to
provide simplified access.  All these methodz is called upon a message
directly.
.PP
\fISpecifyin field data\fR
.IX Subsection "Specifyin field data"
.PP
Field data can be anything, straight fuckin dependent on tha type
of field at hand. Y'all KNOW dat shit, muthafucka! If you decizzle ta contruct tha fieldz hella
carefully via some Mail::Message::Field::Full extension (like via
Mail::Message::Field::Addresses objects), then you gonna git protection
build-in. I aint talkin' bout chicken n' gravy biatch.  But fuck dat shiznit yo, tha word on tha street is dat you can bluntly create any Mail::Message::Field
object based on some data.
.PP
When you create a gangbangin' field, you may specify a string, object, or a array
of strings n' objects, n' you can put dat on yo' toast.  On tha moment, objects is only used ta help
the construction on e\-mail addresses, however you may add a shitload of your
own.
.PP
Da followin rulez (implemented up in \fIstringifyData()\fR) is obeyed given
the argument is:
.IP "\(bu" 4
a string
.Sp
Da strang must be followin tha (fucked up) rulez of tha rfc2822, and
is made field content as specified. Y'all KNOW dat shit, muthafucka!  When tha strang aint terminated
by a new-line (\f(CW"\en"\fR) it is ghon be folded accordin ta tha standard rules.
.IP "\(bu" 4
a Mail::Address object
.Sp
Da most used Perl object ta parse n' produce address lines.  This object
does not KNOW characta set encodings up in phrases.
.IP "\(bu" 4
a Mail::Identitizzle object
.Sp
As part of tha User::Identitizzle distribution, dis object has full
understandin of tha meanin of one e\-mail address, related ta a person.
All features defined by rfc2822 is implemented.
.IP "\(bu" 4
a User::Identitizzle object
.Sp
A thug is specified, which may have mo' than one Mail::Identity's
defined. Y'all KNOW dat shit, muthafucka!  Some methods, like \fIMail::Message::reply()\fR and
\&\fIMail::Message::forward()\fR try ta select tha right e\-mail address
smart (see they method descriptions) yo, but up in other cases tha first
e\-mail address found is used.
.IP "\(bu" 4
a User::Identity::Collection::Emails object
.Sp
All Mail::Identitizzle objects up in tha collection is ghon be included in
the field as a crew caryin tha name of tha collection.
.IP "\(bu" 4
any other object
.Sp
For all other objects, tha stringification overload is used ta produce
the field content.
.IP "\(bu" 4
an \s-1ARRAY\s0
.Sp
Yo ass may also specify a array wit a mixture of any of tha above.  The
elements is ghon be joined as comma-separated list.  If you do not want
commaz inbetween, yo big-ass booty is ghon gotta process tha array yo ass.
.SS "Field class implementation"
.IX Subsection "Field class implementation"
For performizzle reasons only, there be three typez of fields: the
fast, tha flexible, n' tha full understander:
.IP "\(bu" 4
Mail::Message::Field::Fast
.Sp
\&\f(CW\*(C`Fast\*(C'\fR objects is not derived from a \f(CW\*(C`Mail::Reporter\*(C'\fR.  Da consideration
is dat fieldz is so often pimped, n' such a lil' small-ass objects all up in tha same
time, dat setting-up a loggin fo' each of tha objects is relatively
expensive n' not straight-up useful.
Da fast field implementation uses a array ta store tha data: that
will be fasta than rockin a hash.  Fast fieldz is not easily inheritable,
because tha object creation n' initiation is merged tha fuck into one method.
.IP "\(bu" 4
Mail::Message::Field::Flex
.Sp
Da flexible implementation uses a hash ta store tha data.  Da \fInew()\fR
and \f(CW\*(C`init\*(C'\fR methodz is split, so dis object is extensible.
.IP "\(bu" 4
Mail::Message::Field::Full
.Sp
With a gangbangin' full implementation of all applicable RFCs (about 5), tha best
understandin of tha fieldz is reached. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat dis comes with
a straight-up memory n' performizzle penalty.  These objects is pimped
from fast or flex header fieldz when \fIstudy()\fR is called.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Warning: Field content aint numerical: $content" 4
.el .IP "Warning: Field content aint numerical: \f(CW$content\fR" 4
.IX Item "Warning: Field content aint numerical: $content"
Da numeric value of a gangbangin' field be axed (for instizzle tha \f(CW\*(C`Lines\*(C'\fR or
\&\f(CW\*(C`Content\-Length\*(C'\fR fieldz should be numerical), however tha data gotz nuff
weird characters.
.ie n .IP "Warning: Illegal characta up in field name $name" 4
.el .IP "Warning: Illegal characta up in field name \f(CW$name\fR" 4
.IX Item "Warning: Illegal characta up in field name $name"
A freshly smoked up field is bein pimped which do contain charactas not permitted
by tha RFCs.  Usin dis field up in lyrics may break other e\-mail clients
or transfer agents, n' therefore mutulate or extinguish yo' message.
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
