.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Yapp 3"
.TH Parse::Yapp 3 "2013-08-04" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Yapp \- Perl extension fo' generatin n' rockin LALR parsers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  yapp \-m MyParser grammar_file.yp
\&
\&  ...
\&
\&  use MyParser;
\&
\&  $parser=new MyParser();
\&  $value=$parser\->YYParse(yylex => \e&lexer_sub, yyerror => \e&error_sub);
\&
\&  $nberr=$parser\->YYNberr();
\&
\&  $parser\->YYData\->{DATA}= [ \*(AqAnything\*(Aq, \*(AqYo ass Want\*(Aq ];
\&
\&  $data=$parser\->YYData\->{DATA}[0];
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Parse::Yapp (Yet Another Perl Parser compiler) be a cold-ass lil collection of modules
that let you generate n' use yacc like thread safe (reentrant) parsers with
perl object oriented intercourse.
.PP
Da script yapp be a gangbangin' front-end ta tha Parse::Yapp module n' let you
easily create a Perl \s-1OO\s0 parser from a input grammar file.
.SS "Da Grammar file"
.IX Subsection "Da Grammar file"
.ie n .IP """Comments""" 4
.el .IP "\f(CWComments\fR" 4
.IX Item "Comments"
Through all yo' files, comments is either Perl style, introduced by \fI#\fR
up ta tha end of line, or C style, enclosed between  \fI/*\fR n' \fI*/\fR.
.ie n .IP """Tokens n' strang literals""" 4
.el .IP "\f(CWTokens n' strang literals\fR" 4
.IX Item "Tokens n' strang literals"
Through all tha grammar files, two kind of symbols may appear:
\&\fINon-terminal\fR symbols, called also \fIleft-hand-side\fR symbols,
which is tha namez of yo' rules, n' \fITerminal\fR symbols, called
also \fITokens\fR.
.Sp
Tokens is tha symbols yo' lexer function will feed yo' parser with
(see below). They iz of two flavours: symbolic tokens n' string
literals.
.Sp
Non-terminals n' symbolic tokens share tha same identifier syntax:
.Sp
.Vb 1
\&                [A\-Za\-z][A\-Za\-z0\-9_]*
.Ve
.Sp
Strin literals is enclosed up in single quotes n' can contain almost
anything. They is ghon be output ta yo' parser file double-quoted, making
any special characta as such. '"', '$' n' '@' is ghon be automatically
quoted wit '\e', makin they freestylin mo' natural. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. On tha other hand,
if you need a single quote inside yo' literal, just quote it wit '\e'.
.Sp
Yo ass cannot gotz a literal \fI'error'\fR up in yo' grammar as it would
confuse tha driver wit tha \fIerror\fR token. I aint talkin' bout chicken n' gravy biatch. Use a symbolic token instead.
In case you inadvertently use it, dis will produce a warnin spittin some lyrics ta you
you should have freestyled it \fIerror\fR n' will treat it as if it was the
\&\fIerror\fR token, which is certainly \s-1NOT\s0 what tha fuck you meant.
.ie n .IP """Grammar file syntax""" 4
.el .IP "\f(CWGrammar file syntax\fR" 4
.IX Item "Grammar file syntax"
It be straight-up close ta yacc syntax (in fact, \fIParse::Yapp\fR should compile
a clean \fIyacc\fR grammar without any modification, whereas tha opposite
is not true).
.Sp
This file is divided up in three sections, separated by \f(CW\*(C`%%\*(C'\fR:
.Sp
.Vb 5
\&        header section
\&        %%
\&        rulez section
\&        %%
\&        foota section
.Ve
.RS 4
.IP "\fBDa Header Section\fR section may optionally contain:" 4
.IX Item "Da Header Section section may optionally contain:"
.PD 0
.IP "*" 4
.PD
One or mo' code blocks enclosed inside \f(CW\*(C`%{\*(C'\fR n' \f(CW\*(C`%}\*(C'\fR just like in
yacc. They may contain any valid Perl code n' is ghon be copied verbatim
at tha straight-up beginnin of tha parser module. They is not as useful as
they is up in yacc yo, but you can use them, fo' example, fo' global variable
declarations, though yo big-ass booty is ghon notice lata dat such global variablez can
be avoided ta cook up a reentrant parser module.
.IP "*" 4
Precedence declarations, introduced by \f(CW%left\fR, \f(CW%right\fR n' \f(CW%nonassoc\fR
specifyin associativity, followed by tha list of tokens or litterals
havin tha same precedence n' associativity.
Da precedence beein tha latta declared is ghon be havin tha highest level.
(see tha yacc or bison manuals fo' a gangbangin' full explanation of how tha fuck they work,
as they is implemented exactly tha same way up in Parse::Yapp)
.IP "*" 4
\&\f(CW%start\fR followed by a rulez left hand side, declarin dis rule to
be tha startin rule of yo' grammar. Shiiit, dis aint no joke. Da default, when \f(CW%start\fR is not
used, is tha straight-up original gangsta rule up in yo' grammar section.
.IP "*" 4
\&\f(CW%token\fR followed by a list of symbols, forcin dem ta be recognized
as tokens, generatin a syntax error if used up in tha left hand side of
a rule declaration.
Note dat up in Parse::Yapp, you \fIdon't\fR need ta declare tokens as up in yacc: any
symbol not appearin as a left hand side of a rule is considered ta be
a token.
Other yacc declarations or constructs like fuckin \f(CW%type\fR n' \f(CW%union\fR are
parsed but (almost) ignored.
.IP "*" 4
\&\f(CW%expect\fR followed by a number, suppress warnings bout number of Shift/Reduce
conflicts when both numbers match, a la bison.
.RE
.RS 4
.RE
.IP "\fBDa Rule Section\fR gotz nuff yo' grammar rules:" 4
.IX Item "Da Rule Section gotz nuff yo' grammar rules:"
A rule is made of a left-hand-side symbol, followed by a \f(CW\*(Aq:\*(Aq\fR n' one
or mo' right-hand-sides separated by \f(CW\*(Aq|\*(Aq\fR n' terminated by a \f(CW\*(Aq;\*(Aq\fR:
.Sp
.Vb 3
\&    exp:    exp \*(Aq+\*(Aq exp
\&        |   exp \*(Aq\-\*(Aq exp
\&        ;
.Ve
.Sp
A right hand side may be empty:
.Sp
.Vb 3
\&    input:  #empty
\&        |   input line
\&        ;
.Ve
.Sp
(if you have mo' than one empty rhs, Parse::Yapp will issue a warning,
as dis is probably a mistake, n' yo big-ass booty is ghon certainly gotz a reduce/reduce
conflict)
.Sp
A rhs may be followed by a optionizzle \f(CW%prec\fR directive, followed
by a token, givin tha rule a explicit precedence (see yacc manuals
for its precise meaning) n' optionizzle semantic action code block (see
below).
.Sp
.Vb 4
\&    exp:   \*(Aq\-\*(Aq exp %prec NEG { \-$_[1] }
\&        |  exp \*(Aq+\*(Aq exp       { $_[1] + $_[3] }
\&        |  NUM
\&        ;
.Ve
.Sp
Note dat up in Parse::Yapp, a lhs \fIcannot\fR step tha fuck up mo' than once as
a rule name (This differs from yacc).
.ie n .IP """Da foota section""" 4
.el .IP "\f(CWDa foota section\fR" 4
.IX Item "Da foota section"
may contain any valid Perl code n' is ghon be appended all up in tha straight-up end
of yo' parser module yo. Here you can write yo' lexer, error report
subs n' anythang relevant ta you parser.
.ie n .IP """Semantic actions""" 4
.el .IP "\f(CWSemantic actions\fR" 4
.IX Item "Semantic actions"
Semantic actions is run every last muthafuckin time a \fIreduction\fR occurs up in the
parsin flow n' they must return a semantic value.
.Sp
They is (usually yo, but peep below \f(CW\*(C`In rule actions\*(C'\fR) freestyled at
the straight-up end of tha rhs, enclosed wit \f(CW\*(C`{ }\*(C'\fR, n' is copied verbatim
to yo' parser file, inside of tha rulez table.
.Sp
Be aware dat matchin braces up in Perl is much mo' hard as fuck than
in C: inside strings they don't need ta match. While up in C it is
very easy as fuck  ta detect tha beginnin of a strang construct, or a
single character, it is much mo' hard as fuck up in Perl, as there
are all kindsa muthafuckin wayz of freestylin such literals. Right back up in yo muthafuckin ass. So there is no check
for dat todizzle. It make me wanna hollar playa! If you need a funky-ass brace up in a thugged-out double-quoted string, just
quote it (\f(CW\*(C`\e{\*(C'\fR or \f(CW\*(C`\e}\*(C'\fR). For single-quoted strings, yo big-ass booty is ghon need
to cook up a cold-ass lil comment matchin it \fIin th right order\fR.
Sorry fo' tha inconvenience.
.Sp
.Vb 9
\&    {
\&        "{ My fuckin strang block }".
\&        "\e{ My fuckin other strang block \e}".
\&        qq/ My fuckin unmatched brace \e} /.
\&        # Force tha match: {
\&        q/ fo' mah closin brace } /
\&        q/ My fuckin openin brace { /
\&        # must be closed: }
\&    }
.Ve
.Sp
All of these constructs should work.
.Sp
In Parse::Yapp, semantic actions is called like aiiight Perl sub calls,
with they arguments passed up in \f(CW@_\fR, n' they semantic value are
their return joints.
.Sp
\&\f(CW$_\fR[1] ta \f(CW$_\fR[n] is tha parametas just as \f(CW$1\fR ta \f(CW$n\fR up in yacc, while
\&\f(CW$_\fR[0] is tha parser object itself.
.Sp
Havin \f(CW$_\fR[0] beein tha parser object itself allows you ta call
parser methods. Thats how tha fuck tha yacc macros is implemented:
.Sp
.Vb 4
\&        yyerrok is done by callin $_[0]\->YYErrok
\&        YYERROR is done by callin $_[0]\->YYError
\&        YYACCEPT is done by callin $_[0]\->YYAccept
\&        YYABORT is done by callin $_[0]\->YYAbort
.Ve
.Sp
All dem methodz explicitly return \fIundef\fR, fo' convenience.
.Sp
.Vb 1
\&    YYRECOVERING is done by callin $_[0]\->YYRecovering
.Ve
.Sp
Four useful methodz up in error recovery sub
.Sp
.Vb 4
\&    $_[0]\->YYCurtok
\&    $_[0]\->YYCurval
\&    $_[0]\->YYExpect
\&    $_[0]\->YYLexer
.Ve
.Sp
return respectivly tha current input token dat made tha parse fail,
its semantic value (both can be used ta modify they joints too yo, but
\&\fIknow what tha fuck yo ass is bustin\fR ! See \fIError reportin routine\fR section for
an example), a list which gotz nuff tha tokens tha parser expected when
the failure occured n' a reference ta tha lexer routine.
.Sp
Note dat if \f(CW\*(C`$_[0]\->YYCurtok\*(C'\fR is declared as a \f(CW%nonassoc\fR token,
it can be included up in \f(CW\*(C`$_[0]\->YYExpect\*(C'\fR list whenever tha input
try ta use it up in a associatizzle way. This aint a funky-ass bug: tha token
\&\s-1IS\s0 sposed ta fuckin report a error if encountered.
.Sp
To detect such a thang up in yo' error reportin sub, tha following
example should do tha trick:
.Sp
.Vb 4
\&        grep { $_[0]\->YYCurtok eq $_ } $_[0]\->YYExpect
\&    n' do {
\&        #Non\-associatizzle token used up in a associatizzle expression
\&    };
.Ve
.Sp
Accessin semantics joints on tha left of yo' reducin rule is done
all up in tha method
.Sp
.Vb 1
\&    $_[0]\->YYSemval( index )
.Ve
.Sp
where index be a integer n' shit. Its value bein \fI1 .. n\fR returns tha same ol' dirty joints
than \fI\f(CI$_\fI[1] .. \f(CI$_\fI[n]\fR yo, but \fI\-n .. 0\fR returns joints on tha left of tha rule
beein reduced (It be related ta \fI$\-n .. \f(CI$0\fI .. \f(CI$n\fI\fR up in yacc yo, but you
cannot use \fI\f(CI$_\fI[0]\fR or \fI\f(CI$_\fI[\-n]\fR constructs up in Parse::Yapp fo' obvious reasons)
.Sp
There be also a provision fo' a user data area up in tha parser object,
accessed by tha method:
.Sp
.Vb 1
\&    $_[0]\->YYData
.Ve
.Sp
which returns a reference ta a anonymous hash, which let you have
all of yo' parsin data held inside tha object (see tha Calc.yp
or ParseYapp.yp filez up in tha distribution fo' some examples).
Thatz how tha fuck you can make you parser module reentrant: all of your
module states n' variablez is held inside tha parser object.
.Sp
Note: unfortunatly, method calls up in Perl gotz a shitload of overhead,
      n' when YYData is used, it may be called a big-ass number
      of times. If yo' is not a *real* purist n' efficiency
      is yo' concern, you may access directly tha user-space
      up in tha object: \f(CW$parser\fR\->{\s-1USER\s0} wich be a reference ta an
      anonymous hash array, n' then benchmark.
.Sp
If no action is specified fo' a rule, tha equivalant of a thugged-out default
action is run, which returns tha straight-up original gangsta parameter:
.Sp
.Vb 1
\&   { $_[1] }
.Ve
.ie n .IP """In rule actions""" 4
.el .IP "\f(CWIn rule actions\fR" 4
.IX Item "In rule actions"
It be also possible ta embed semantic actions inside of a rule:
.Sp
.Vb 1
\&    typedef:    TYPE { $type = $_[1] } identlist { ... } ;
.Ve
.Sp
When tha Parse::Yappz parser encounta such a embedded action, it modifies
the grammar as if you freestyled (although \f(CW@x\fR\-1 aint a legal lhs value):
.Sp
.Vb 2
\&    @x\-1:   /* empty */ { $type = $_[1] };
\&    typedef:    TYPE @x\-1 identlist { ... } ;
.Ve
.Sp
where \fIx\fR be a sequential number incremented fo' each \*(L"in rule\*(R" action,
and \fI\-1\fR represents tha \*(L"dot position\*(R" up in tha rule where tha action arises.
.Sp
In such actions, you can use \fI\f(CI$_\fI[1]..$_[n]\fR variables, which is the
semantic joints on tha left of yo' action.
.Sp
Be aware dat tha way Parse::Yapp modifies yo' grammar cuz of
\&\fIin rule actions\fR can produce, up in some cases, spurious conflicts
that wouldn't happen otherwise.
.ie n .IP """Generatin tha Parser Module""" 4
.el .IP "\f(CWGeneratin tha Parser Module\fR" 4
.IX Item "Generatin tha Parser Module"
Now dat you grammar file is written, you can use yapp on it
to generate yo' parser module:
.Sp
.Vb 1
\&    yapp \-v Calc.yp
.Ve
.Sp
will create two filez \fICalc.pm\fR, yo' parser module, n' \fICalc.output\fR
a verbose output of yo' parser rules, conflicts, warnings, states
and summary.
.Sp
What yo' is missin now be a lexer routine.
.ie n .IP """Da Lexer sub""" 4
.el .IP "\f(CWDa Lexer sub\fR" 4
.IX Item "Da Lexer sub"
is called each time tha parser need ta read tha next token.
.Sp
It be called wit only one argument dat is tha parser object itself,
so you can access its methods, specially the
.Sp
.Vb 1
\&    $_[0]\->YYData
.Ve
.Sp
data area.
.Sp
It be its duty ta return tha next token n' value ta tha parser.
They \f(CW\*(C`must\*(C'\fR be returned as a list of two variables, tha straight-up original gangsta one
is tha token known by tha parser (symbolic or literal), tha second
one beein anythang you want (usually tha content of tha token, or the
literal value) from a simple scalar value ta any complex reference,
as tha parsin driver never use it but ta booty-call semantic actions:
.Sp
.Vb 5
\&    ( \*(AqNUMBER\*(Aq, $num )
\&or
\&    ( \*(Aq>=\*(Aq, \*(Aq>=\*(Aq )
\&or
\&    ( \*(AqARRAY\*(Aq, [ @values ] )
.Ve
.Sp
When tha lexer reach tha end of input, it must return tha \f(CW\*(Aq\*(Aq\fR
empty token wit a undef value:
.Sp
.Vb 1
\&     ( \*(Aq\*(Aq, undef )
.Ve
.Sp
Note dat yo' lexer should \fInever\fR return \f(CW\*(Aqerror\*(Aq\fR as token
value: fo' tha driver, dis is tha error token used fo' error
recovery n' would lead ta odd erections.
.Sp
Now dat you have yo' lexer written, maybe yo big-ass booty is ghon need ta output
meaningful error lyrics, instead of tha default which is ta print
\&'Parse error.' on \s-1STDERR.\s0
.Sp
So yo big-ass booty is ghon need a Error reportin sub.
.ie n .IP """Error reportin routine""" 4
.el .IP "\f(CWError reportin routine\fR" 4
.IX Item "Error reportin routine"
If you want one, write it knowin dat it is passed as parameter
the parser object. Right back up in yo muthafuckin ass. So you can share shiznit whith tha lexer
routine like doggystyle.
.Sp
Yo ass can also use tha \f(CW\*(C`$_[0]\->YYErrok\*(C'\fR method up in it, which will
resume parsin as if no error occured. Y'all KNOW dat shit, muthafucka! Of course, since tha invalid
token is still invalid, you supposed ta fix tha problem by
yo ass.
.Sp
Da method \f(CW\*(C`$_[0]\->YYLexer\*(C'\fR may help you, as it returns a reference
to tha lexer routine, n' can be called as
.Sp
.Vb 1
\&    ($tok,$val)=&{$_[0]\->Lexer}
.Ve
.Sp
to git tha next token n' semantic value from tha input stream. To
make dem current fo' tha parser, use:
.Sp
.Vb 1
\&    ($_[0]\->YYCurtok, $_[0]\->YYCurval) = ($tok, $val)
.Ve
.Sp
and know what tha fuck you bustin...
.ie n .IP """Parsing""" 4
.el .IP "\f(CWParsing\fR" 4
.IX Item "Parsing"
Now you've gots every last muthafuckin thang ta do tha parsing.
.Sp
First, use tha parser module:
.Sp
.Vb 1
\&    use Calc;
.Ve
.Sp
Then create tha parser object:
.Sp
.Vb 1
\&    $parser=new Calc;
.Ve
.Sp
Now, call tha YYParse method, spittin some lyrics ta it where ta find tha lexer
and error report subs:
.Sp
.Vb 2
\&    $result=$parser\->YYParse(yylex => \e&Lexer,
\&                           yyerror => \e&ErrorReport);
.Ve
.Sp
(assumin Lexer n' ErrorReport subs done been freestyled up in yo' current
package)
.Sp
Da order up in which parametas step tha fuck up is unimportant.
.Sp
Et voila.
.Sp
Da YYParse method will do tha parse, then return tha last semantic
value returned, or undef if error recovery cannot recover.
.Sp
If you need ta be shizzle tha parse has been successful (in case your
last returned semantic value \fIis\fR undef) cook up a cold-ass lil call to:
.Sp
.Vb 1
\&    $parser\->YYNberr()
.Ve
.Sp
which returns tha total number of time tha error reportin sub has been called.
.ie n .IP """Error Recovery""" 4
.el .IP "\f(CWError Recovery\fR" 4
.IX Item "Error Recovery"
in Parse::Yapp is implemented tha same way it is up in yacc.
.ie n .IP """Debuggin Parser""" 4
.el .IP "\f(CWDebuggin Parser\fR" 4
.IX Item "Debuggin Parser"
To debug yo' parser, you can call tha YYParse method wit a thugged-out debug parameter:
.Sp
.Vb 1
\&    $parser\->YYParse( ... , yydebug => value, ... )
.Ve
.Sp
where value be a funky-ass bitfield, each bit representin a specific debug output:
.Sp
.Vb 6
\&    Bit Value    Outputs
\&    0x01         Token readin (useful fo' Lexer debugging)
\&    0x02         States shiznit
\&    0x04         Driver actions (shifts, reduces, accept...)
\&    0x08         Parse Stack dump
\&    0x10         Error Recovery tracing
.Ve
.Sp
To gotz a gangbangin' full debuggin ouput, use
.Sp
.Vb 1
\&    debug => 0x1F
.Ve
.Sp
Debuggin output is busted ta \s-1STDERR,\s0 n' be aware dat it can produce
\&\f(CW\*(C`huge\*(C'\fR outputs.
.ie n .IP """Standalone Parsers""" 4
.el .IP "\f(CWStandalone Parsers\fR" 4
.IX Item "Standalone Parsers"
By default, tha parser modulez generated will need tha Parse::Yapp
module installed on tha system ta run. I aint talkin' bout chicken n' gravy biatch. They use tha Parse::Yapp::Driver
which can be safely shared between parsers up in tha same script.
.Sp
In tha case you'd prefer ta git a standalone module generated, use
the \f(CW\*(C`\-s\*(C'\fR switch wit yapp: dis will automagically copy tha driver
code tha fuck into yo' module so you can use/distribute it without tha need
of tha Parse::Yapp module, makin it straight-up a \f(CW\*(C`Standalone Parser\*(C'\fR.
.Sp
If you do so, please remember ta include Parse::Yappz copyright notice
in yo' main module copyright, so others can know bout Parse::Yapp module.
.ie n .IP """Source file line numbers""" 4
.el .IP "\f(CWSource file line numbers\fR" 4
.IX Item "Source file line numbers"
by default is ghon be included up in tha generated parser module, which will help
to find tha guilty line up in yo' source file up in case of a syntax error.
Yo ass can disable dis feature by compilin yo' grammar wit yapp using
the \f(CW\*(C`\-n\*(C'\fR switch.
.SH "BUGS AND SUGGESTIONS"
.IX Header "BUGS AND SUGGESTIONS"
If you find bugs, be thinkin of anythang dat could improve Parse::Yapp
or have any thangs related ta it, feel free ta contact tha lyricist.
.SH "AUTHOR"
.IX Header "AUTHOR"
Francois Desarmenien  <francois@fdesar.net>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIyapp\fR\|(1) \fIperl\fR\|(1) \fIyacc\fR\|(1) \fIbison\fR\|(1).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Da Parse::Yapp module n' its related modulez n' shell scripts is copyright
(c) 1998\-2001 Francois Desarmenien, Frizzle fo' realz. All muthafuckin rights reserved.
.PP
Yo ass may use n' distribute dem under tha termz of either
the \s-1GNU\s0 General Public License or tha Artistic License,
as specified up in tha Perl \s-1README\s0 file.
.PP
If you use tha \*(L"standalone parser\*(R" option so playas don't need ta install
Parse::Yapp on they systems up in order ta run you software, dis copyright
noticed should be included up in yo' software copyright too, n' tha copyright
notice up in tha embedded driver should be left untouched.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 112:" 4
.IX Item "Around line 112:"
Expected text afta =item, not a funky-ass bullet
.IP "Around line 121:" 4
.IX Item "Around line 121:"
Expected text afta =item, not a funky-ass bullet
.IP "Around line 130:" 4
.IX Item "Around line 130:"
Expected text afta =item, not a funky-ass bullet
.IP "Around line 136:" 4
.IX Item "Around line 136:"
Expected text afta =item, not a funky-ass bullet
.IP "Around line 147:" 4
.IX Item "Around line 147:"
Expected text afta =item, not a funky-ass bullet
