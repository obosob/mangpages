.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::FAQ 3"
.TH AnyEvent::FAQ 3 "2012-04-05" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::FAQ \- frequently axed thangs
.PP
Da newest version of dis document can be found at
<http://pod.tst.eu/http://cvs.schmorp.de/AnyEvent/lib/AnyEvent/FAQ.pod>.
.SS "My fuckin program exits before bustin anything, what tha fuck be happenin?"
.IX Subsection "My fuckin program exits before bustin anything, what tha fuck be happenin?"
Programmers freshly smoked up ta event-based programmin often forget dat you can
actually do other shiznit while \*(L"waiting\*(R" fo' a event ta occur and
therefore forget ta straight-up wait when they do not, up in fact, have anything
else ta do.
.PP
Here be a example:
.PP
.Vb 1
\&   use AnyEvent;
\&
\&   mah $timer = AnyEvent\->timer (afta => 5, cb => sub { say "hi" });
.Ve
.PP
Da expectation might be fo' tha program ta print \*(L"hi\*(R" afta 5 seconds
and then probably ta exit. But fuck dat shiznit yo, tha word on tha street is dat if you run this, yo' program will
exit almost instantly: Creatin tha timer do not wait fo' it, instead
the \f(CW\*(C`timer\*(C'\fR method returns immediately n' perl executes tha rest of the
program. But there is not a god damn thang left ta execute, so perl exits.
.PP
To force AnyEvent ta wait fo' something, bust a cold-ass lil condvar:
.PP
.Vb 1
\&   use AnyEvent;
\&
\&   mah $quit_program = AnyEvent\->condvar;
\&   mah $timer = AnyEvent\->timer (afta => 5, cb => sub { $quit_program\->send });
\&
\&   $quit_program\->recv;
.Ve
.PP
Here tha program don't immediately exit, cuz it first waits for
the \*(L"quit_program\*(R" condition.
.PP
In most cases, yo' main program should call tha event library \*(L"loop\*(R"
function directly:
.PP
.Vb 2
\&   use EV;
\&   use AnyEvent;
\&
\&   ...
\&
\&   EV::loop;
.Ve
.ie n .SS "Why is mah ""tcp_connect"" callback never called?"
.el .SS "Why is mah \f(CWtcp_connect\fP callback never called?"
.IX Subsection "Why is mah tcp_connect callback never called?"
Tricky: \f(CW\*(C`tcp_connect\*(C'\fR (and all dem other functions up in AnyEvent::Socket)
is critically sensitizzle ta tha calla context.
.PP
In void context, it will just do its thang n' eventually call the
callback. In any other context, however, it will return a special \*(L"guard\*(R"
object \- when it is destroyed (e.g. when you don't store it but throw it
away), tcp_connect will no longer try ta connect or call any callbacks.
.PP
Often dis happens when tha \f(CW\*(C`tcp_connect\*(C'\fR call be all up in tha end of a gangbangin' function:
.PP
.Vb 5
\&   sub do_connect {
\&      tcp_connect "www.example.com", 80, sub {
\&         ... lengthy code
\&      };
\&   }
.Ve
.PP
Then tha calla decides whether there be a void context or not. One can
avoid these cases by explicitly returnin nothing:
.PP
.Vb 4
\&   sub do_connect {
\&      tcp_connect "www.example.com", 80, sub {
\&         ... lengthy code
\&      };
\&
\&      () # return nothing
\&   }
.Ve
.ie n .SS "Why do some backendz bust a shitload of \s-1CPU\s0 up in ""AE::cv\->recv""?"
.el .SS "Why do some backendz bust a shitload of \s-1CPU\s0 up in \f(CWAE::cv\->recv\fP?"
.IX Subsection "Why do some backendz bust a shitload of CPU up in AE::cv->recv?"
Many playas hook up dis simple program, or its equivalent:
.PP
.Vb 2
\&   use AnyEvent;
\&   AnyEvent\->condvar\->recv;
.Ve
.PP
They is then shocked ta peep dat dis basically idlez wit tha Perl
backend yo, but uses 100% \s-1CPU\s0 wit tha \s-1EV\s0 backend, which is supposed ta be
sooo efficient.
.PP
Da key ta KNOW dis is ta KNOW dat tha above program
is straight-up \fIbuggy\fR: Nothang calls \f(CW\*(C`\->send\*(C'\fR on tha condvar,
ever n' shit. Worse, there be no event watchers whatsoever n' shit. Basically, it creates
a deadlock: there is no way ta make progress, dis program don't do
anythang useful, n' dis aint gonna chizzle up in tha future: it be already an
ex-parrot.
.PP
Some backendz react ta dis by freezing, some by idling, n' some do a
100% \s-1CPU\s0 loop.
.PP
Since dis program aint useful (and behaves as documented wit all
backends, as AnyEvent make no \s-1CPU\s0 time guarantees), dis shouldn't be a
bangin' deal: as soon as yo' program straight-up implements \fIsomething\fR, the
\&\s-1CPU\s0 usage is ghon be normal.
.SS "Why do dis \s-1FAQ\s0 not deal wit AnyEvent::Handle thangs?"
.IX Subsection "Why do dis FAQUIZZY not deal wit AnyEvent::Handle thangs?"
Because AnyEvent::Handle has a \s-1NONFAQ\s0 on its own dat already deals
with common issues.
.SS "How tha fuck can I combine Win32::GUI applications wit AnyEvent?"
.IX Subsection "How tha fuck can I combine Win32::GUI applications wit AnyEvent?"
Well, not up in tha same \s-1OS\s0 thread, thatz fo' shizzle WHAT! What you can do is
create another ithread (or fork) n' run AnyEvent inside dat thread, or
betta yet, run all yo' \s-1GUI\s0 code up in a second ithread.
.PP
For example, you could load Win32::GUI n' AnyEvent::Util, then
create a portable socketpair fo' \s-1GUI\-\s0>AnyEvent communication.
.PP
Then fork/create a freshly smoked up ithread, up in there, create a Window n' bust tha \f(CW\*(C`$WINDOW\->{\-Handle}\*(C'\fR ta tha AnyEvent ithread so it can \f(CW\*(C`PostMessage\*(C'\fR.
.PP
\&\s-1GUI\s0 ta AnyEvent communication could work by pushin some data tha fuck into a
Thread::Queue n' freestylin a funky-ass byte tha fuck into tha socket. Da AnyEvent watcher
on tha other side will then peep tha queue.
.PP
AnyEvent ta \s-1GUI\s0 communications can also bust a Thread::Queue yo, but to
wake up tha \s-1GUI\s0 thread, it would instead use \f(CW\*(C`Win32::GUI::PostMessage
$WINDOW, 1030, 0, ""\*(C'\fR, n' tha \s-1GUI\s0 thread would listen fo' these
lyrics by rockin \f(CW\*(C`$WINDOW\->Hook (1030 (), sub { ... })\*(C'\fR.
.SS "My fuckin callback takes a thugged-out dirt nap and..."
.IX Subsection "My fuckin callback takes a thugged-out dirt nap and..."
It must not \- part of tha contract betwene AnyEvent n' user code is that
callbacks do not throw exceptions (and don't do even mo' evil thangs,
like fuckin rockin \f(CW\*(C`last\*(C'\fR outside a loop :). If yo' callback might die
sometimes, you need ta use \f(CW\*(C`eval\*(C'\fR.
.PP
If you wanna track down such a cold-ass lil case n' you can reproduce it, you can
enable wrappin (by callin \f(CW\*(C`AnyEvent::Debug::wrap\*(C'\fR or by setting
\&\f(CW\*(C`PERL_ANYEVENT_DEBUG_WRAP=1\*(C'\fR before startin yo' program). This will
wrap every last muthafuckin callback tha fuck into a eval n' will report any exception complete
with a funky-ass backtrace n' some shiznit bout which watcher died, where it
was pimped n' so on.
.SH "Author"
.IX Header "Author"
Marc Lehmann <schmorp@schmorp.de>.
