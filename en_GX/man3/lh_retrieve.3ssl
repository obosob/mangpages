.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "lhash 3"
.TH lhash 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
lh_new, lh_free, lh_insert, lh_delete, lh_retrieve, lh_doall, lh_doall_arg, lh_error \- dynamic hash table
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/lhash.h>
\&
\& DECLARE_LHASH_OF(<type>);
\&
\& LHASH *lh_<type>_new();
\& void lh_<type>_free(LHASH_OF(<type> *table);
\&
\& <type> *lh_<type>_insert(LHASH_OF(<type> *table, <type> *data);
\& <type> *lh_<type>_delete(LHASH_OF(<type> *table, <type> *data);
\& <type> *lh_retrieve(LHASH_OF<type> *table, <type> *data);
\&
\& void lh_<type>_doall(LHASH_OF(<type> *table, LHASH_DOALL_FN_TYPE func);
\& void lh_<type>_doall_arg(LHASH_OF(<type> *table, LHASH_DOALL_ARG_FN_TYPE func,
\&          <type2>, <type2> *arg);
\&
\& int lh_<type>_error(LHASH_OF(<type> *table);
\&
\& typedef int (*LHASH_COMP_FN_TYPE)(const void *, const void *);
\& typedef unsigned long (*LHASH_HASH_FN_TYPE)(const void *);
\& typedef void (*LHASH_DOALL_FN_TYPE)(const void *);
\& typedef void (*LHASH_DOALL_ARG_FN_TYPE)(const void *, const void *);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This library implements type-checked dynamic hash tables. Da hash
table entries can be arbitrary structures. Usually they consist of key
and value fields.
.PP
lh_<type>\fI_new()\fR creates a freshly smoked up \fB\s-1LHASH_OF\s0(<type\fR> structure ta store
arbitrary data entries, n' serves up tha 'hash' n' 'compare'
callbacks ta be used up in organisin tha tablez entries. Put ya muthafuckin choppers up if ya feel dis!  Da \fBhash\fR
callback takes a pointa ta a table entry as its argument n' returns
an unsigned long hash value fo' its key field. Y'all KNOW dat shit, muthafucka!  Da hash value is
normally truncated ta a juice of 2, so make shizzle dat yo' hash
function returns well mixed low order bits, n' you can put dat on yo' toast.  Da \fBcompare\fR callback
takes two arguments (pointas ta two hash table entries), n' returns
0 if they keys is equal, non-zero otherwise.  If yo' hash table
will contain shit of some particular type n' tha \fBhash\fR and
\&\fBcompare\fR callbacks hash/compare these types, then the
\&\fB\s-1DECLARE_LHASH_HASH_FN\s0\fR n' \fB\s-1IMPLEMENT_LHASH_COMP_FN\s0\fR macros can be
used ta create callback wrapperz of tha prototypes required by
lh_<type>\fI_new()\fR.  These provide per-variable casts before callin the
type-specific callbacks freestyled by tha application lyricist.  These
macros, as well as dem used fo' tha \*(L"doall\*(R" callbacks, is defined
as;
.PP
.Vb 7
\& #define DECLARE_LHASH_HASH_FN(name, o_type) \e
\&         unsigned long name##_LHASH_HASH(const void *);
\& #define IMPLEMENT_LHASH_HASH_FN(name, o_type) \e
\&         unsigned long name##_LHASH_HASH(const void *arg) { \e
\&                 const o_type *a = arg; \e
\&                 return name##_hash(a); }
\& #define LHASH_HASH_FN(name) name##_LHASH_HASH
\&
\& #define DECLARE_LHASH_COMP_FN(name, o_type) \e
\&         int name##_LHASH_COMP(const void *, const void *);
\& #define IMPLEMENT_LHASH_COMP_FN(name, o_type) \e
\&         int name##_LHASH_COMP(const void *arg1, const void *arg2) { \e
\&                 const o_type *a = arg1;                    \e
\&                 const o_type *b = arg2; \e
\&                 return name##_cmp(a,b); }
\& #define LHASH_COMP_FN(name) name##_LHASH_COMP
\&
\& #define DECLARE_LHASH_DOALL_FN(name, o_type) \e
\&         void name##_LHASH_DOALL(void *);
\& #define IMPLEMENT_LHASH_DOALL_FN(name, o_type) \e
\&         void name##_LHASH_DOALL(void *arg) { \e
\&                 o_type *a = arg; \e
\&                 name##_doall(a); }
\& #define LHASH_DOALL_FN(name) name##_LHASH_DOALL
\&
\& #define DECLARE_LHASH_DOALL_ARG_FN(name, o_type, a_type) \e
\&         void name##_LHASH_DOALL_ARG(void *, void *);
\& #define IMPLEMENT_LHASH_DOALL_ARG_FN(name, o_type, a_type) \e
\&         void name##_LHASH_DOALL_ARG(void *arg1, void *arg2) { \e
\&                 o_type *a = arg1; \e
\&                 a_type *b = arg2; \e
\&                 name##_doall_arg(a, b); }
\& #define LHASH_DOALL_ARG_FN(name) name##_LHASH_DOALL_ARG
\&
\& An example of a hash table storin (pointas to) structurez of type \*(AqSTUFF\*(Aq
\& could be defined as bigs up;
\&
\& /* Calculates tha hash value of \*(Aqtohash\*(Aq (implemented elsewhere) */
\& unsigned long STUFF_hash(const STUFF *tohash);
\& /* Ordaz \*(Aqarg1\*(Aq n' \*(Aqarg2\*(Aq (implemented elsewhere) */
\& int stuff_cmp(const STUFF *arg1, const STUFF *arg2);
\& /* Smoke tha type\-safe wrapper functions fo' use up in tha LHASH internals */
\& static IMPLEMENT_LHASH_HASH_FN(stuff, STUFF);
\& static IMPLEMENT_LHASH_COMP_FN(stuff, STUFF);
\& /* ... */
\& int main(int argc, char *argv[]) {
\&         /* Smoke tha freshly smoked up hash table rockin tha hash/compare wrappers */
\&         LHASH_OF(STUFF) *hashtable = lh_STUFF_new(LHASH_HASH_FN(STUFF_hash),
\&                                   LHASH_COMP_FN(STUFF_cmp));
\&         /* ... */
\& }
.Ve
.PP
lh_<type>\fI_free()\fR frees tha \fB\s-1LHASH_OF\s0(<type\fR> structure
\&\fBtable\fR fo' realz. Allocated hash table entries aint gonna be freed; consider
usin lh_<type>\fI_doall()\fR ta deallocate any remainin entries up in the
hash table (see below).
.PP
lh_<type>\fI_insert()\fR bangs tha structure pointed ta by \fBdata\fR into
\&\fBtable\fR.  If there already be a entry wit tha same key, tha old
value is replaced. Y'all KNOW dat shit, muthafucka! Note dat lh_<type>\fI_insert()\fR stores pointers, the
data is not copied.
.PP
lh_<type>\fI_delete()\fR deletes a entry from \fBtable\fR.
.PP
lh_<type>\fI_retrieve()\fR looks up a entry up in \fBtable\fR. Normally, \fBdata\fR
is a structure wit tha key field(s) set; tha function will return a
pointa ta a gangbangin' straight-up populated structure.
.PP
lh_<type>\fI_doall()\fR will, fo' every last muthafuckin entry up in tha hash table, call
\&\fBfunc\fR wit tha data item as its parameter n' shit.  For lh_<type>\fI_doall()\fR
and lh_<type>\fI_doall_arg()\fR, function pointa castin should be avoided
in tha callbacks (see \fB\s-1NOTE\s0\fR) \- instead use tha declare/implement
macros ta create type-checked wrappers dat cast variablez prior to
callin yo' type-specific callbacks.  An example of dis is
illustrated here where tha callback is used ta cleanup resources for
items up in tha hash table prior ta tha hashtable itself being
deallocated:
.PP
.Vb 9
\& /* Cleans up resources belongin ta \*(Aqa\*(Aq (this is implemented elsewhere) */
\& void STUFF_cleanup_doall(STUFF *a);
\& /* Implement a prototype\-compatible wrapper fo' "STUFF_cleanup" */
\& IMPLEMENT_LHASH_DOALL_FN(STUFF_cleanup, STUFF)
\&         /* ... then lata up in tha code ... */
\& /* So ta run "STUFF_cleanup" against all shit up in a hash table ... */
\& lh_STUFF_doall(hashtable, LHASH_DOALL_FN(STUFF_cleanup));
\& /* Then tha hash table itself can be deallocated */
\& lh_STUFF_free(hashtable);
.Ve
.PP
When bustin this, be careful if you delete entries from tha hash table
in yo' callbacks: tha table may decrease up in size, movin tha item
that yo ass is currently on down lower up in tha hash table \- dis could
cause some entries ta be skipped durin tha iteration. I aint talkin' bout chicken n' gravy biatch.  Da second
best solution ta dis problem is ta set hash\->down_load=0 before
you start (which will stop tha hash table eva decreasin up in size).
Da dopest solution is probably ta avoid deletin shit from tha hash
table inside a \*(L"doall\*(R" callback!
.PP
lh_<type>\fI_doall_arg()\fR is tha same ol' dirty as lh_<type>\fI_doall()\fR except that
\&\fBfunc\fR is ghon be called wit \fBarg\fR as tha second argument n' \fBfunc\fR
should be of type \fB\s-1LHASH_DOALL_ARG_FN_TYPE\s0\fR (a callback prototype
that is passed both tha table entry n' a extra argument).  As with
\&\fIlh_doall()\fR, you can instead chizzle ta declare yo' callback wit a
prototype matchin tha types yo ass is dealin wit n' use the
declare/implement macros ta create compatible wrappers dat cast
variablez before callin yo' type-specific callbacks.  An example of
this is demonstrated here (printin all hash table entries ta a \s-1BIO\s0
that is provided by tha caller):
.PP
.Vb 8
\& /* Prints item \*(Aqa\*(Aq ta \*(Aqoutput_bio\*(Aq (this is implemented elsewhere) */
\& void STUFF_print_doall_arg(const STUFF *a, BIO *output_bio);
\& /* Implement a prototype\-compatible wrapper fo' "STUFF_print" */
\& static IMPLEMENT_LHASH_DOALL_ARG_FN(STUFF, const STUFF, BIO)
\&         /* ... then lata up in tha code ... */
\& /* Print up tha entire hashtable ta a particular BIO */
\& lh_STUFF_doall_arg(hashtable, LHASH_DOALL_ARG_FN(STUFF_print), BIO,
\&                    logging_bio);
.Ve
.PP
lh_<type>\fI_error()\fR can be used ta determine if a error occurred up in tha last
operation. I aint talkin' bout chicken n' gravy biatch. lh_<type>\fI_error()\fR be a macro.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
lh_<type>\fI_new()\fR returns \fB\s-1NULL\s0\fR on error, otherwise a pointa ta tha new
\&\fB\s-1LHASH\s0\fR structure.
.PP
When a hash table entry is replaced, lh_<type>\fI_insert()\fR returns tha value
bein replaced. Y'all KNOW dat shit, muthafucka! \fB\s-1NULL\s0\fR is returned on aiiight operation n' on error.
.PP
lh_<type>\fI_delete()\fR returns tha entry bein deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \fB\s-1NULL\s0\fR is returned if
there is no such value up in tha hash table.
.PP
lh_<type>\fI_retrieve()\fR returns tha hash table entry if it has been found,
\&\fB\s-1NULL\s0\fR otherwise.
.PP
lh_<type>\fI_error()\fR returns 1 if a error occurred up in tha last operation, 0
otherwise.
.PP
lh_<type>\fI_free()\fR, lh_<type>\fI_doall()\fR n' lh_<type>\fI_doall_arg()\fR return no joints.
.SH "NOTE"
.IX Header "NOTE"
Da various \s-1LHASH\s0 macros n' callback types exist ta make it possible
to write type-checked code without resortin ta function-prototype
castin \- a evil dat make application code much harder to
audit/verify n' also opens tha window of opportunitizzle fo' stack
corruption n' other hard-to-find bugs.  It also, apparently, violates
ANSI-C.
.PP
Da \s-1LHASH\s0 code regardz table entries as constant data.  As such, it
internally represents \fIlh_insert()\fR'd shit wit a \*(L"const void *\*(R"
pointa type.  This is why callbacks like fuckin dem used by \fIlh_doall()\fR
and \fIlh_doall_arg()\fR declare they prototypes wit \*(L"const\*(R", even fo' the
parametas dat pass back tha table items' data pointas \- for
consistency, user-provided data is \*(L"const\*(R" at all times as far as the
\&\s-1LHASH\s0 code is concerned. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat as callaz is theyselves providing
these pointers, they can chizzle whether they too should be treating
all such parametas as constant.
.PP
As a example, a hash table may be maintained by code that, for
reasonz of encapsulation, has only \*(L"const\*(R" access ta tha data being
indexed up in tha hash table (ie. it is returned as \*(L"const\*(R" from
elsewhere up in they code) \- up in dis case tha \s-1LHASH\s0 prototypes are
appropriate as-is.  Conversely, if tha calla is responsible fo' the
life-time of tha data up in question, then they may well wish ta make
modifications ta table item passed back up in tha \fIlh_doall()\fR or
\&\fIlh_doall_arg()\fR callbacks (see tha \*(L"STUFF_cleanup\*(R" example above).  If
so, tha calla can either cast tha \*(L"const\*(R" away (if they providing
the raw callbacks theyselves) or use tha macros ta declare/implement
the wrapper functions without \*(L"const\*(R" types.
.PP
Callaz dat only have \*(L"const\*(R" access ta data they indexin up in a
table, yet declare callbacks without constant types (or cast the
\&\*(L"const\*(R" away theyselves), is therefore bustin they own risks/bugs
without bein encouraged ta do so by tha \s-1API. \s0 On a related note,
those auditin code should pay special attention ta any instances of
DECLARE/IMPLEMENT_LHASH_DOALL_[\s-1ARG_\s0]_FN macros dat provide types
without any \*(L"const\*(R" qualifiers.
.SH "BUGS"
.IX Header "BUGS"
lh_<type>\fI_insert()\fR returns \fB\s-1NULL\s0\fR both fo' success n' error.
.SH "INTERNALS"
.IX Header "INTERNALS"
Da followin description is based on tha SSLeay documentation:
.PP
Da \fBlhash\fR library implements a hash table busted lyrics bout up in the
\&\fICommunicationz of tha \s-1ACM\s0\fR up in 1991.  What make dis hash table
different is dat as tha table fills, tha hash table is increased (or
decreased) up in size via \fIOPENSSL_realloc()\fR.  When a 'resize' is done, instead of
all hashes bein redistributed over twice as nuff 'buckets', one
bucket is split.  So when a 'expand' is done, there is only a minimal
cost ta redistribute some joints, n' you can put dat on yo' toast.  Subsequent bangs will cause more
single 'bucket' redistributions but there aint NEVER gonna be a sudden large
cost cuz of redistributin all tha 'buckets'.
.PP
Da state fo' a particular hash table is kept up in tha \fB\s-1LHASH\s0\fR structure.
Da decision ta increase or decrease tha hash table size is made
dependin on tha 'load' of tha hash table.  Da load is tha number of
items up in tha hash table divided by tha size of tha hash table.  The
default joints is as bigs up.  If (hash\->up_load < load) =>
expand. Y'all KNOW dat shit, muthafucka!  if (hash\->down_load > load) => contract.  The
\&\fBup_load\fR has a thugged-out default value of 1 n' \fBdown_load\fR has a thugged-out default value
of 2.  These numbers can be modified by tha application by just
playin wit tha \fBup_load\fR n' \fBdown_load\fR variables.  Da 'load' is
kept up in a gangbangin' form which is multiplied by 256.  So
hash\->up_load=8*256; will cause a load of 8 ta be set.
.PP
If yo ass is horny bout performizzle tha field ta peep is
num_comp_calls.  Da hash library keeps track of tha 'hash' value for
each item so when a lookup is done, tha 'hashes' is compared, if
there be a match, then a gangbangin' full compare is done, and
hash\->num_comp_calls is incremented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If num_comp_calls aint equal
to num_delete plus num_retrieve it means dat yo' hash function is
generatin hashes dat is tha same fo' different joints, n' you can put dat on yo' toast.  It is
probably worth changin yo' hash function if dis is tha case cuz
even if yo' hash table has 10 shit up in a 'bucket', it can be searched
with 10 \fBunsigned long\fR compares n' 10 linked list traverses.  This
will be much less high-rollin' dat 10 calls ta yo' compare function.
.PP
\&\fIlh_strhash()\fR be a thugged-out demo strang hashin function:
.PP
.Vb 1
\& unsigned long lh_strhash(const char *c);
.Ve
.PP
Since tha \fB\s-1LHASH\s0\fR routines would normally be passed structures, this
routine would not normally be passed ta lh_<type>\fI_new()\fR, rather it would be
used up in tha function passed ta lh_<type>\fI_new()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIlh_stats\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
Da \fBlhash\fR library be available up in all versionz of SSLeay n' OpenSSL.
\&\fIlh_error()\fR was added up in SSLeay 0.9.1b.
.PP
This manpage is derived from tha SSLeay documentation.
.PP
In OpenSSL 0.9.7, all lhash functions dat was passed function pointers
were chizzled fo' betta type safety, n' tha function types \s-1LHASH_COMP_FN_TYPE,
LHASH_HASH_FN_TYPE, LHASH_DOALL_FN_TYPE\s0 n' \s-1LHASH_DOALL_ARG_FN_TYPE \s0
became available.
.PP
In OpenSSL 1.0.0, tha lhash intercourse was revamped fo' even better
type checking.
