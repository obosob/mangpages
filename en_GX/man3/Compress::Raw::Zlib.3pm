.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Compress::Raw::Zlib 3"
.TH Compress::Raw::Zlib 3 "2013-08-11" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Compress::Raw::Zlib \- Low\-Level Interface ta zlib compression library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Compress::Raw::Zlib ;
\&
\&    ($d, $status) = freshly smoked up Compress::Raw::Zlib::Deflate( [OPT] ) ;
\&    $status = $d\->deflate($input, $output) ;
\&    $status = $d\->flush($output [, $flush_type]) ;
\&    $d\->deflateReset() ;
\&    $d\->deflateParams(OPTS) ;
\&    $d\->deflateTune(OPTS) ;
\&    $d\->dict_adler() ;
\&    $d\->crc32() ;
\&    $d\->adler32() ;
\&    $d\->total_in() ;
\&    $d\->total_out() ;
\&    $d\->msg() ;
\&    $d\->get_Strategy();
\&    $d\->get_Level();
\&    $d\->get_BufSize();
\&
\&    ($i, $status) = freshly smoked up Compress::Raw::Zlib::Inflate( [OPT] ) ;
\&    $status = $i\->inflate($input, $output [, $eof]) ;
\&    $status = $i\->inflateSync($input) ;
\&    $i\->inflateReset() ;
\&    $i\->dict_adler() ;
\&    $d\->crc32() ;
\&    $d\->adler32() ;
\&    $i\->total_in() ;
\&    $i\->total_out() ;
\&    $i\->msg() ;
\&    $d\->get_BufSize();
\&
\&    $crc = adler32($buffer [,$crc]) ;
\&    $crc = crc32($buffer [,$crc]) ;
\&
\&    $crc = adler32_combine($crc1, $crc2, $len2)l
\&    $crc = crc32_combine($adler1, $adler2, $len2)
\&
\&    mah $version = Compress::Raw::Zlib::zlib_version();
\&    mah $flags = Compress::Raw::Zlib::zlibCompileFlags();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \fICompress::Raw::Zlib\fR module serves up a Perl intercourse ta tha \fIzlib\fR
compression library (see \*(L"\s-1AUTHOR\*(R"\s0 fo' details bout where ta get
\&\fIzlib\fR).
.SH "Compress::Raw::Zlib::Deflate"
.IX Header "Compress::Raw::Zlib::Deflate"
This section defines a intercourse dat allows in-memory compression using
the \fIdeflate\fR intercourse provided by zlib.
.PP
Here be a thugged-out definizzle of tha intercourse available:
.ie n .SS "\fB($d, \fP\fB$status\fP\fB) = freshly smoked up Compress::Raw::Zlib::Deflate( [\s-1OPT\s0] ) \fP"
.el .SS "\fB($d, \fP\f(CB$status\fP\fB) = freshly smoked up Compress::Raw::Zlib::Deflate( [\s-1OPT\s0] ) \fP"
.IX Subsection "($d, $status) = freshly smoked up Compress::Raw::Zlib::Deflate( [OPT] ) "
Initialises a thugged-out deflation object.
.PP
If yo ass is familiar wit tha \fIzlib\fR library, it combines the
featurez of tha \fIzlib\fR functions \f(CW\*(C`deflateInit\*(C'\fR, \f(CW\*(C`deflateInit2\*(C'\fR
and \f(CW\*(C`deflateSetDictionary\*(C'\fR.
.PP
If successful, it will return tha initialised deflation object, \f(CW$d\fR
and a \f(CW$status\fR of \f(CW\*(C`Z_OK\*(C'\fR up in a list context. In scalar context it
returns tha deflation object, \f(CW$d\fR, only.
.PP
If not successful, tha returned deflation object, \f(CW$d\fR, will be
\&\fIundef\fR n' \f(CW$status\fR will hold tha a \fIzlib\fR error code.
.PP
Da function optionally takes a fuckin shitload of named options specified as
\&\f(CW\*(C`Name => value\*(C'\fR pairs. This allows individual options ta be
tailored without havin ta specify dem all up in tha parameta list.
.PP
For backward compatibility, it be also possible ta pass tha parameters
as a reference ta a hash containin tha name=>value pairs.
.PP
Below be a list of tha valid options:
.IP "\fB\-Level\fR" 5
.IX Item "-Level"
Defines tha compression level. Valid joints is 0 all up in 9,
\&\f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR, \f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, and
\&\f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
.Sp
Da default is \f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
.IP "\fB\-Method\fR" 5
.IX Item "-Method"
Defines tha compression method. Y'all KNOW dat shit, muthafucka! Da only valid value at present (and
the default) is \f(CW\*(C`Z_DEFLATED\*(C'\fR.
.IP "\fB\-WindowBits\fR" 5
.IX Item "-WindowBits"
To compress a \s-1RFC 1950\s0 data stream, set \f(CW\*(C`WindowBits\*(C'\fR ta a positive
number between 8 n' 15.
.Sp
To compress a \s-1RFC 1951\s0 data stream, set \f(CW\*(C`WindowBits\*(C'\fR ta \f(CW\*(C`\-MAX_WBITS\*(C'\fR.
.Sp
To compress a \s-1RFC 1952\s0 data stream (i.e. gzip), set \f(CW\*(C`WindowBits\*(C'\fR to
\&\f(CW\*(C`WANT_GZIP\*(C'\fR.
.Sp
For a thugged-out definizzle of tha meanin n' valid joints fo' \f(CW\*(C`WindowBits\*(C'\fR
refer ta tha \fIzlib\fR documentation fo' \fIdeflateInit2\fR.
.Sp
Defaults ta \f(CW\*(C`MAX_WBITS\*(C'\fR.
.IP "\fB\-MemLevel\fR" 5
.IX Item "-MemLevel"
For a thugged-out definizzle of tha meanin n' valid joints fo' \f(CW\*(C`MemLevel\*(C'\fR
refer ta tha \fIzlib\fR documentation fo' \fIdeflateInit2\fR.
.Sp
Defaults ta \s-1MAX_MEM_LEVEL.\s0
.IP "\fB\-Strategy\fR" 5
.IX Item "-Strategy"
Defines tha game used ta tune tha compression. I aint talkin' bout chicken n' gravy biatch. Da valid joints are
\&\f(CW\*(C`Z_DEFAULT_STRATEGY\*(C'\fR, \f(CW\*(C`Z_FILTERED\*(C'\fR, \f(CW\*(C`Z_RLE\*(C'\fR, \f(CW\*(C`Z_FIXED\*(C'\fR and
\&\f(CW\*(C`Z_HUFFMAN_ONLY\*(C'\fR.
.Sp
Da default is \f(CW\*(C`Z_DEFAULT_STRATEGY\*(C'\fR.
.IP "\fB\-Dictionary\fR" 5
.IX Item "-Dictionary"
When a gangbangin' finger-lickin' doggtionary is specified \fICompress::Raw::Zlib\fR will automatically
call \f(CW\*(C`deflateSetDictionary\*(C'\fR directly afta callin \f(CW\*(C`deflateInit\*(C'\fR. The
Adler32 value fo' tha doggtionary can be obtained by callin tha method 
\&\f(CW\*(C`$d\->dict_adler()\*(C'\fR.
.Sp
Da default is no dictionary.
.IP "\fB\-Bufsize\fR" 5
.IX Item "-Bufsize"
Sets tha initial size fo' tha output buffer used by tha \f(CW\*(C`$d\->deflate\*(C'\fR
and \f(CW\*(C`$d\->flush\*(C'\fR methods. If tha buffer has ta be
reallocated ta increase tha size, it will grow up in increments of
\&\f(CW\*(C`Bufsize\*(C'\fR.
.Sp
Da default buffer size is 4096.
.IP "\fB\-AppendOutput\fR" 5
.IX Item "-AppendOutput"
This option controls how tha fuck data is freestyled ta tha output buffer by the
\&\f(CW\*(C`$d\->deflate\*(C'\fR n' \f(CW\*(C`$d\->flush\*(C'\fR methods.
.Sp
If tha \f(CW\*(C`AppendOutput\*(C'\fR option is set ta false, tha output buffers up in the
\&\f(CW\*(C`$d\->deflate\*(C'\fR n' \f(CW\*(C`$d\->flush\*(C'\fR  methodz is ghon be truncated before
uncompressed data is freestyled ta em.
.Sp
If tha option is set ta true, uncompressed data is ghon be appended ta the
output buffer up in tha \f(CW\*(C`$d\->deflate\*(C'\fR n' \f(CW\*(C`$d\->flush\*(C'\fR methods.
.Sp
This option defaults ta false.
.IP "\fB\-CRC32\fR" 5
.IX Item "-CRC32"
If set ta true, a cold-ass lil crc32 checksum of tha uncompressed data will be
calculated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha \f(CW\*(C`$d\->crc32\*(C'\fR method ta retrieve dis value.
.Sp
This option defaults ta false.
.IP "\fB\-ADLER32\fR" 5
.IX Item "-ADLER32"
If set ta true, a adler32 checksum of tha uncompressed data will be
calculated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha \f(CW\*(C`$d\->adler32\*(C'\fR method ta retrieve dis value.
.Sp
This option defaults ta false.
.PP
Here be a example of rockin tha \f(CW\*(C`Compress::Raw::Zlib::Deflate\*(C'\fR optional
parameta list ta override tha default buffer size n' compression
level fo' realz. All other options will take they default joints.
.PP
.Vb 2
\&    mah $d = freshly smoked up Compress::Raw::Zlib::Deflate ( \-Bufsize => 300, 
\&                                               \-Level   => Z_BEST_SPEED ) ;
.Ve
.ie n .SS "\fB\fP\fB$status\fP\fB = \fP\fB$d\fP\fB\->deflate($input, \fP\fB$output\fP\fB)\fP"
.el .SS "\fB\fP\f(CB$status\fP\fB = \fP\f(CB$d\fP\fB\->deflate($input, \fP\f(CB$output\fP\fB)\fP"
.IX Subsection "$status = $d->deflate($input, $output)"
Deflates tha contentz of \f(CW$input\fR n' writes tha compressed data to
\&\f(CW$output\fR.
.PP
Da \f(CW$input\fR n' \f(CW$output\fR parametas can be either scalars or scalar
references.
.PP
When finished, \f(CW$input\fR is ghon be straight-up processed (assumin there
were no errors). If tha deflation was successful it writes tha deflated
data ta \f(CW$output\fR n' returns a status value of \f(CW\*(C`Z_OK\*(C'\fR.
.PP
On error, it returns a \fIzlib\fR error code.
.PP
If tha \f(CW\*(C`AppendOutput\*(C'\fR option is set ta legit up in tha constructor for
the \f(CW$d\fR object, tha compressed data is ghon be appended ta \f(CW$output\fR. If
it is false, \f(CW$output\fR is ghon be truncated before any compressed data is
written ta dat shit.
.PP
\&\fBNote\fR: This method aint gonna necessarily write compressed data to
\&\f(CW$output\fR every last muthafuckin time it is called. Y'all KNOW dat shit, muthafucka! So do not assume dat there has been
an error if tha contentz of \f(CW$output\fR is empty on returnin from
this method. Y'all KNOW dat shit, muthafucka! As long as tha return code from tha method is \f(CW\*(C`Z_OK\*(C'\fR,
the deflate has succeeded.
.ie n .SS "\fB\fP\fB$status\fP\fB = \fP\fB$d\fP\fB\->flush($output [, \fP\fB$flush_type\fP\fB]) \fP"
.el .SS "\fB\fP\f(CB$status\fP\fB = \fP\f(CB$d\fP\fB\->flush($output [, \fP\f(CB$flush_type\fP\fB]) \fP"
.IX Subsection "$status = $d->flush($output [, $flush_type]) "
Typically used ta finish tha deflation. I aint talkin' bout chicken n' gravy biatch fo' realz. Any pendin output will be
written ta \f(CW$output\fR.
.PP
Returns \f(CW\*(C`Z_OK\*(C'\fR if successful.
.PP
Note dat flushin can seriously degrade tha compression ratio, so it
should only be used ta terminizzle a thugged-out decompression (usin \f(CW\*(C`Z_FINISH\*(C'\fR) or
when you wanna create a \fIfull flush point\fR (usin \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR).
.PP
By default tha \f(CW\*(C`flush_type\*(C'\fR used is \f(CW\*(C`Z_FINISH\*(C'\fR. Other valid joints
for \f(CW\*(C`flush_type\*(C'\fR is \f(CW\*(C`Z_NO_FLUSH\*(C'\fR, \f(CW\*(C`Z_PARTIAL_FLUSH\*(C'\fR, \f(CW\*(C`Z_SYNC_FLUSH\*(C'\fR
and \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR. Well shiiiit, it is straight fuckin recommended dat you only set the
\&\f(CW\*(C`flush_type\*(C'\fR parameta if you straight-up KNOW tha implications of
what it do. Right back up in yo muthafuckin ass. See tha \f(CW\*(C`zlib\*(C'\fR documentation fo' details.
.PP
If tha \f(CW\*(C`AppendOutput\*(C'\fR option is set ta legit up in tha constructor for
the \f(CW$d\fR object, tha compressed data is ghon be appended ta \f(CW$output\fR. If
it is false, \f(CW$output\fR is ghon be truncated before any compressed data is
written ta dat shit.
.ie n .SS "\fB\fP\fB$status\fP\fB = \fP\fB$d\fP\fB\->\fP\f(BIdeflateReset()\fP\fB \fP"
.el .SS "\fB\fP\f(CB$status\fP\fB = \fP\f(CB$d\fP\fB\->\fP\f(BIdeflateReset()\fP\fB \fP"
.IX Subsection "$status = $d->deflateReset() "
This method will reset tha deflation object \f(CW$d\fR. Well shiiiit, it can be used when you
are compressin multiple data streams n' wanna use tha same object to
compress each of em. Well shiiiit, it should only be used once tha previous data stream
has been flushed successfully, i.e. a cold-ass lil call ta \f(CW\*(C`$d\->flush(Z_FINISH)\*(C'\fR has
returned \f(CW\*(C`Z_OK\*(C'\fR.
.PP
Returns \f(CW\*(C`Z_OK\*(C'\fR if successful.
.ie n .SS "\fB\fP\fB$status\fP\fB = \fP\fB$d\fP\fB\->deflateParams([\s-1OPT\s0])\fP"
.el .SS "\fB\fP\f(CB$status\fP\fB = \fP\f(CB$d\fP\fB\->deflateParams([\s-1OPT\s0])\fP"
.IX Subsection "$status = $d->deflateParams([OPT])"
Change settings fo' tha deflate object \f(CW$d\fR.
.PP
Da list of tha valid options is shown below. Options not specified
will remain unchanged.
.IP "\fB\-Level\fR" 5
.IX Item "-Level"
Defines tha compression level. Valid joints is 0 all up in 9,
\&\f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR, \f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, and
\&\f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
.IP "\fB\-Strategy\fR" 5
.IX Item "-Strategy"
Defines tha game used ta tune tha compression. I aint talkin' bout chicken n' gravy biatch. Da valid joints are
\&\f(CW\*(C`Z_DEFAULT_STRATEGY\*(C'\fR, \f(CW\*(C`Z_FILTERED\*(C'\fR n' \f(CW\*(C`Z_HUFFMAN_ONLY\*(C'\fR.
.IP "\fB\-BufSize\fR" 5
.IX Item "-BufSize"
Sets tha initial size fo' tha output buffer used by tha \f(CW\*(C`$d\->deflate\*(C'\fR
and \f(CW\*(C`$d\->flush\*(C'\fR methods. If tha buffer has ta be
reallocated ta increase tha size, it will grow up in increments of
\&\f(CW\*(C`Bufsize\*(C'\fR.
.ie n .SS "\fB\fP\fB$status\fP\fB = \fP\fB$d\fP\fB\->deflateTune($good_length, \fP\fB$max_lazy\fP\fB, \fP\fB$nice_length\fP\fB, \fP\fB$max_chain\fP\fB)\fP"
.el .SS "\fB\fP\f(CB$status\fP\fB = \fP\f(CB$d\fP\fB\->deflateTune($good_length, \fP\f(CB$max_lazy\fP\fB, \fP\f(CB$nice_length\fP\fB, \fP\f(CB$max_chain\fP\fB)\fP"
.IX Subsection "$status = $d->deflateTune($good_length, $max_lazy, $nice_length, $max_chain)"
Tune tha internal settings fo' tha deflate object \f(CW$d\fR. This option is
only available if yo ass is hustlin zlib 1.2.2.3 or better.
.PP
Refer ta tha documentation up in zlib.h fo' instructions on how tha fuck ta fly
\&\f(CW\*(C`deflateTune\*(C'\fR.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BIdict_adler()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BIdict_adler()\fP\fB\fP"
.IX Subsection "$d->dict_adler()"
Returns tha adler32 value fo' tha dictionary.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BIcrc32()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BIcrc32()\fP\fB\fP"
.IX Subsection "$d->crc32()"
Returns tha crc32 value fo' tha uncompressed data ta date.
.PP
If tha \f(CW\*(C`CRC32\*(C'\fR option aint enabled up in tha constructor fo' dis object,
this method will always return 0;
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BIadler32()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BIadler32()\fP\fB\fP"
.IX Subsection "$d->adler32()"
Returns tha adler32 value fo' tha uncompressed data ta date.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BImsg()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BImsg()\fP\fB\fP"
.IX Subsection "$d->msg()"
Returns tha last error message generated by zlib.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BItotal_in()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BItotal_in()\fP\fB\fP"
.IX Subsection "$d->total_in()"
Returns tha total number of bytes uncompressed bytes input ta deflate.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BItotal_out()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BItotal_out()\fP\fB\fP"
.IX Subsection "$d->total_out()"
Returns tha total number of compressed bytes output from deflate.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BIget_Strategy()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BIget_Strategy()\fP\fB\fP"
.IX Subsection "$d->get_Strategy()"
Returns tha deflation game currently used. Y'all KNOW dat shit, muthafucka! Valid joints are
\&\f(CW\*(C`Z_DEFAULT_STRATEGY\*(C'\fR, \f(CW\*(C`Z_FILTERED\*(C'\fR n' \f(CW\*(C`Z_HUFFMAN_ONLY\*(C'\fR.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BIget_Level()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BIget_Level()\fP\fB\fP"
.IX Subsection "$d->get_Level()"
Returns tha compression level bein used.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BIget_BufSize()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BIget_BufSize()\fP\fB\fP"
.IX Subsection "$d->get_BufSize()"
Returns tha buffer size used ta carry up tha compression.
.SS "Example"
.IX Subsection "Example"
Here be a trivial example of rockin \f(CW\*(C`deflate\*(C'\fR. Well shiiiit, it simply readz standard
input, deflates it n' writes it ta standard output.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&
\&    use Compress::Raw::Zlib ;
\&
\&    binmode STDIN;
\&    binmode STDOUT;
\&    mah $x = freshly smoked up Compress::Raw::Zlib::Deflate
\&       or take a thugged-out dirtnap "Cannot create a thugged-out deflation stream\en" ;
\&
\&    mah ($output, $status) ;
\&    while (<>)
\&    {
\&        $status = $x\->deflate($_, $output) ;
\&    
\&        $status == Z_OK
\&            or take a thugged-out dirtnap "deflation failed\en" ;
\&    
\&        print $output ;
\&    }
\&    
\&    $status = $x\->flush($output) ;
\&    
\&    $status == Z_OK
\&        or take a thugged-out dirtnap "deflation failed\en" ;
\&    
\&    print $output ;
.Ve
.SH "Compress::Raw::Zlib::Inflate"
.IX Header "Compress::Raw::Zlib::Inflate"
This section defines a intercourse dat allows in-memory uncompression using
the \fIinflate\fR intercourse provided by zlib.
.PP
Here be a thugged-out definizzle of tha intercourse:
.ie n .SS "\fB ($i, \fP\fB$status\fP\fB) = freshly smoked up Compress::Raw::Zlib::Inflate( [\s-1OPT\s0] ) \fP"
.el .SS "\fB ($i, \fP\f(CB$status\fP\fB) = freshly smoked up Compress::Raw::Zlib::Inflate( [\s-1OPT\s0] ) \fP"
.IX Subsection " ($i, $status) = freshly smoked up Compress::Raw::Zlib::Inflate( [OPT] ) "
Initialises a inflation object.
.PP
In a list context it returns tha inflation object, \f(CW$i\fR, n' the
\&\fIzlib\fR status code (\f(CW$status\fR). In a scalar context it returns the
inflation object only.
.PP
If successful, \f(CW$i\fR will hold tha inflation object n' \f(CW$status\fR will
be \f(CW\*(C`Z_OK\*(C'\fR.
.PP
If not successful, \f(CW$i\fR is ghon be \fIundef\fR n' \f(CW$status\fR will hold the
\&\fIzlib\fR error code.
.PP
Da function optionally takes a fuckin shitload of named options specified as
\&\f(CW\*(C`\-Name => value\*(C'\fR pairs. This allows individual options ta be
tailored without havin ta specify dem all up in tha parameta list.
.PP
For backward compatibility, it be also possible ta pass tha parameters
as a reference ta a hash containin tha \f(CW\*(C`name=>value\*(C'\fR pairs.
.PP
Here be a list of tha valid options:
.IP "\fB\-WindowBits\fR" 5
.IX Item "-WindowBits"
To uncompress a \s-1RFC 1950\s0 data stream, set \f(CW\*(C`WindowBits\*(C'\fR ta a positive
number between 8 n' 15.
.Sp
To uncompress a \s-1RFC 1951\s0 data stream, set \f(CW\*(C`WindowBits\*(C'\fR ta \f(CW\*(C`\-MAX_WBITS\*(C'\fR.
.Sp
To uncompress a \s-1RFC 1952\s0 data stream (i.e. gzip), set \f(CW\*(C`WindowBits\*(C'\fR to
\&\f(CW\*(C`WANT_GZIP\*(C'\fR.
.Sp
To auto-detect n' uncompress a \s-1RFC 1950\s0 or \s-1RFC 1952\s0 data stream (i.e.
gzip), set \f(CW\*(C`WindowBits\*(C'\fR ta \f(CW\*(C`WANT_GZIP_OR_ZLIB\*(C'\fR.
.Sp
For a gangbangin' full definizzle of tha meanin n' valid joints fo' \f(CW\*(C`WindowBits\*(C'\fR
refer ta tha \fIzlib\fR documentation fo' \fIinflateInit2\fR.
.Sp
Defaults ta \f(CW\*(C`MAX_WBITS\*(C'\fR.
.IP "\fB\-Bufsize\fR" 5
.IX Item "-Bufsize"
Sets tha initial size fo' tha output buffer used by tha \f(CW\*(C`$i\->inflate\*(C'\fR
method. Y'all KNOW dat shit, muthafucka! If tha output buffer up in dis method has ta be reallocated to
increase tha size, it will grow up in incrementz of \f(CW\*(C`Bufsize\*(C'\fR.
.Sp
Default is 4096.
.IP "\fB\-Dictionary\fR" 5
.IX Item "-Dictionary"
Da default is no dictionary.
.IP "\fB\-AppendOutput\fR" 5
.IX Item "-AppendOutput"
This option controls how tha fuck data is freestyled ta tha output buffer by the
\&\f(CW\*(C`$i\->inflate\*(C'\fR method.
.Sp
If tha option is set ta false, tha output buffer up in tha \f(CW\*(C`$i\->inflate\*(C'\fR
method is ghon be truncated before uncompressed data is freestyled ta dat shit.
.Sp
If tha option is set ta true, uncompressed data is ghon be appended ta the
output buffer by tha \f(CW\*(C`$i\->inflate\*(C'\fR method.
.Sp
This option defaults ta false.
.IP "\fB\-CRC32\fR" 5
.IX Item "-CRC32"
If set ta true, a cold-ass lil crc32 checksum of tha uncompressed data will be
calculated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha \f(CW\*(C`$i\->crc32\*(C'\fR method ta retrieve dis value.
.Sp
This option defaults ta false.
.IP "\fB\-ADLER32\fR" 5
.IX Item "-ADLER32"
If set ta true, a adler32 checksum of tha uncompressed data will be
calculated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha \f(CW\*(C`$i\->adler32\*(C'\fR method ta retrieve dis value.
.Sp
This option defaults ta false.
.IP "\fB\-ConsumeInput\fR" 5
.IX Item "-ConsumeInput"
If set ta true, dis option will remove compressed data from tha input
buffer of tha \f(CW\*(C`$i\->inflate\*(C'\fR method as tha inflate progresses.
.Sp
This option can be useful when yo ass is processin compressed data dat is
embedded up in another file/buffer n' shit. In dis case tha data dat immediately
bigs up tha compressed stream is ghon be left up in tha input buffer.
.Sp
This option defaults ta true.
.IP "\fB\-LimitOutput\fR" 5
.IX Item "-LimitOutput"
Da \f(CW\*(C`LimitOutput\*(C'\fR option chizzlez tha behavior of tha \f(CW\*(C`$i\->inflate\*(C'\fR
method so dat tha amount of memory used by tha output buffer can be
limited.
.Sp
When \f(CW\*(C`LimitOutput\*(C'\fR is used tha size of tha output buffer used will either
be tha value of tha \f(CW\*(C`Bufsize\*(C'\fR option or tha amount of memory already
allocated ta \f(CW$output\fR, whichever is larger n' shit. Predictin tha output size
available is tricky, so don't rely on gettin a exact output buffer size.
.Sp
When \f(CW\*(C`LimitOutout\*(C'\fR aint specified \f(CW\*(C`$i\->inflate\*(C'\fR will use as much
memory as it takes ta write all tha uncompressed data it creates by
uncompressin tha input buffer.
.Sp
If \f(CW\*(C`LimitOutput\*(C'\fR is enabled, tha \f(CW\*(C`ConsumeInput\*(C'\fR option will also be
enabled.
.Sp
This option defaults ta false.
.Sp
See \*(L"Da LimitOutput option\*(R" fo' a gangbangin' finger-lickin' rap on why \f(CW\*(C`LimitOutput\*(C'\fR is
needed n' how tha fuck ta use dat shit.
.PP
Here be a example of rockin a optionizzle parameta ta override tha default
buffer size.
.PP
.Vb 1
\&    mah ($i, $status) = freshly smoked up Compress::Raw::Zlib::Inflate( \-Bufsize => 300 ) ;
.Ve
.ie n .SS "\fB \fP\fB$status\fP\fB = \fP\fB$i\fP\fB\->inflate($input, \fP\fB$output\fP\fB [,$eof]) \fP"
.el .SS "\fB \fP\f(CB$status\fP\fB = \fP\f(CB$i\fP\fB\->inflate($input, \fP\f(CB$output\fP\fB [,$eof]) \fP"
.IX Subsection " $status = $i->inflate($input, $output [,$eof]) "
Inflates tha complete contentz of \f(CW$input\fR n' writes tha uncompressed
data ta \f(CW$output\fR. Da \f(CW$input\fR n' \f(CW$output\fR parametas can either be
scalars or scalar references.
.PP
Returns \f(CW\*(C`Z_OK\*(C'\fR if successful n' \f(CW\*(C`Z_STREAM_END\*(C'\fR if tha end of the
compressed data has been successfully reached.
.PP
If not successful \f(CW$status\fR will hold tha \fIzlib\fR error code.
.PP
If tha \f(CW\*(C`ConsumeInput\*(C'\fR option has been set ta legit when the
\&\f(CW\*(C`Compress::Raw::Zlib::Inflate\*(C'\fR object is pimped, tha \f(CW$input\fR parameter
is modified by \f(CW\*(C`inflate\*(C'\fR. On completion it will contain what tha fuck remains
of tha input buffer afta inflation. I aint talkin' bout chicken n' gravy biatch. In practice, dis means dat when
the return status is \f(CW\*(C`Z_OK\*(C'\fR tha \f(CW$input\fR parameta will contain an
empty string, n' when tha return status is \f(CW\*(C`Z_STREAM_END\*(C'\fR tha \f(CW$input\fR
parameta will gotz nuff what tha fuck (if anything) was stored up in tha input buffer
afta tha deflated data stream.
.PP
This feature is useful when processin a gangbangin' file format dat encapsulates
a compressed data stream (e.g. gzip, zip) n' there is useful data
immediately afta tha deflation stream.
.PP
If tha \f(CW\*(C`AppendOutput\*(C'\fR option is set ta legit up in tha constructor for
this object, tha uncompressed data is ghon be appended ta \f(CW$output\fR. If
it is false, \f(CW$output\fR is ghon be truncated before any uncompressed data
is freestyled ta dat shit.
.PP
Da \f(CW$eof\fR parameta needz a lil' bit of explanation.
.PP
Prior ta version 1.2.0, zlib assumed dat there was at least one trailing
byte immediately afta tha compressed data stream when dat shiznit was carryin out
decompression. I aint talkin' bout chicken n' gravy biatch. This normally aint a problem cuz tha majoritizzle of zlib
applications guarantee dat there is ghon be data directly afta the
compressed data stream.  For example, both gzip (\s-1RFC 1950\s0) n' zip both
define trailin data dat bigs up tha compressed data stream.
.PP
Da \f(CW$eof\fR parameta only need ta be used if \fBall\fR of tha following
conditions apply
.IP "1." 5
Yo ass is either rockin a cold-ass lil copy of zlib dat is olda than version 1.2.0 or you
want yo' application code ta be able ta run wit as nuff different
versionz of zlib as possible.
.IP "2." 5
Yo ass have set tha \f(CW\*(C`WindowBits\*(C'\fR parameta ta \f(CW\*(C`\-MAX_WBITS\*(C'\fR up in tha constructor
for dis object, i.e. yo ass is uncompressin a raw deflated data stream
(\s-1RFC 1951\s0).
.IP "3." 5
There is no data immediately afta tha compressed data stream.
.PP
If \fBall\fR of these is tha case, then you need ta set tha \f(CW$eof\fR parameter
to legit on tha final call (and only tha final call) ta \f(CW\*(C`$i\->inflate\*(C'\fR.
.PP
If you have built dis module wit zlib >= 1.2.0, tha \f(CW$eof\fR parameta is
ignored. Y'all KNOW dat shit, muthafucka! Yo ass can still set it if you want yo, but it won't be used behind the
scenes.
.ie n .SS "\fB\fP\fB$status\fP\fB = \fP\fB$i\fP\fB\->inflateSync($input)\fP"
.el .SS "\fB\fP\f(CB$status\fP\fB = \fP\f(CB$i\fP\fB\->inflateSync($input)\fP"
.IX Subsection "$status = $i->inflateSync($input)"
This method can be used ta attempt ta recover phat data from a cold-ass lil compressed
data stream dat is partially corrupt.
It scans \f(CW$input\fR until it reaches either a \fIfull flush point\fR or the
end of tha buffer.
.PP
If a \fIfull flush point\fR is found, \f(CW\*(C`Z_OK\*(C'\fR is returned n' \f(CW$input\fR
will be have all data up ta tha flush point removed. Y'all KNOW dat shit, muthafucka! This data can then be
passed ta tha \f(CW\*(C`$i\->inflate\*(C'\fR method ta be uncompressed.
.PP
Any other return code means dat a gangbangin' flush point was not found. Y'all KNOW dat shit, muthafucka! If more
data be available, \f(CW\*(C`inflateSync\*(C'\fR can be called repeatedly wit more
compressed data until tha flush point is found.
.PP
Note \fIfull flush points\fR is not present by default up in compressed
data streams. They must done been added explicitly when tha data stream
was pimped by callin \f(CW\*(C`Compress::Deflate::flush\*(C'\fR  wit \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR.
.ie n .SS "\fB\fP\fB$status\fP\fB = \fP\fB$i\fP\fB\->\fP\f(BIinflateReset()\fP\fB \fP"
.el .SS "\fB\fP\f(CB$status\fP\fB = \fP\f(CB$i\fP\fB\->\fP\f(BIinflateReset()\fP\fB \fP"
.IX Subsection "$status = $i->inflateReset() "
This method will reset tha inflation object \f(CW$i\fR. Well shiiiit, it can be used when you
are uncompressin multiple data streams n' wanna use tha same object to
uncompress each of em.
.PP
Returns \f(CW\*(C`Z_OK\*(C'\fR if successful.
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BIdict_adler()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BIdict_adler()\fP\fB\fP"
.IX Subsection "$i->dict_adler()"
Returns tha adler32 value fo' tha dictionary.
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BIcrc32()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BIcrc32()\fP\fB\fP"
.IX Subsection "$i->crc32()"
Returns tha crc32 value fo' tha uncompressed data ta date.
.PP
If tha \f(CW\*(C`CRC32\*(C'\fR option aint enabled up in tha constructor fo' dis object,
this method will always return 0;
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BIadler32()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BIadler32()\fP\fB\fP"
.IX Subsection "$i->adler32()"
Returns tha adler32 value fo' tha uncompressed data ta date.
.PP
If tha \f(CW\*(C`ADLER32\*(C'\fR option aint enabled up in tha constructor fo' dis object,
this method will always return 0;
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BImsg()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BImsg()\fP\fB\fP"
.IX Subsection "$i->msg()"
Returns tha last error message generated by zlib.
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BItotal_in()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BItotal_in()\fP\fB\fP"
.IX Subsection "$i->total_in()"
Returns tha total number of bytes compressed bytes input ta inflate.
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BItotal_out()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BItotal_out()\fP\fB\fP"
.IX Subsection "$i->total_out()"
Returns tha total number of uncompressed bytes output from inflate.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BIget_BufSize()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BIget_BufSize()\fP\fB\fP"
.IX Subsection "$d->get_BufSize()"
Returns tha buffer size used ta carry up tha decompression.
.SS "Examples"
.IX Subsection "Examples"
Here be a example of rockin \f(CW\*(C`inflate\*(C'\fR.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&    
\&    use Compress::Raw::Zlib;
\&    
\&    mah $x = freshly smoked up Compress::Raw::Zlib::Inflate()
\&       or take a thugged-out dirtnap "Cannot create a inflation stream\en" ;
\&    
\&    mah $input = \*(Aq\*(Aq ;
\&    binmode STDIN;
\&    binmode STDOUT;
\&    
\&    mah ($output, $status) ;
\&    while (read(STDIN, $input, 4096))
\&    {
\&        $status = $x\->inflate($input, $output) ;
\&    
\&        print $output ;
\&    
\&        last if $status != Z_OK ;
\&    }
\&    
\&    take a thugged-out dirtnap "inflation failed\en"
\&        unless $status == Z_STREAM_END ;
.Ve
.PP
Da next example show how tha fuck ta use tha \f(CW\*(C`LimitOutput\*(C'\fR option. I aint talkin' bout chicken n' gravy biatch. Notice tha use
of two nested loops up in dis case. Da outa loop readz tha data from the
input source \- \s-1STDIN\s0 n' tha inner loop repeatedly calls \f(CW\*(C`inflate\*(C'\fR until
\&\f(CW$input\fR is exhausted, we git a error, or tha end of tha stream is
reached. Y'all KNOW dat shit, muthafucka! One point worth rememberin is by rockin tha \f(CW\*(C`LimitOutput\*(C'\fR option
you also git \f(CW\*(C`ConsumeInput\*(C'\fR set as well \- dis make tha code below much
simpler.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&    
\&    use Compress::Raw::Zlib;
\&    
\&    mah $x = freshly smoked up Compress::Raw::Zlib::Inflate(LimitOutput => 1)
\&       or take a thugged-out dirtnap "Cannot create a inflation stream\en" ;
\&    
\&    mah $input = \*(Aq\*(Aq ;
\&    binmode STDIN;
\&    binmode STDOUT;
\&    
\&    mah ($output, $status) ;
\&
\&  OUTER:
\&    while (read(STDIN, $input, 4096))
\&    {
\&        do
\&        {
\&            $status = $x\->inflate($input, $output) ;
\&
\&            print $output ;
\&
\&            last OUTER
\&                unless $status == Z_OK || $status == Z_BUF_ERROR ;
\&        }
\&        while ($status == Z_OK && length $input);
\&    }
\&    
\&    take a thugged-out dirtnap "inflation failed\en"
\&        unless $status == Z_STREAM_END ;
.Ve
.SH "CHECKSUM FUNCTIONS"
.IX Header "CHECKSUM FUNCTIONS"
Two functions is provided by \fIzlib\fR ta calculate checksums. For the
Perl intercourse, tha order of tha two parametas up in both functions has
been reversed. Y'all KNOW dat shit, muthafucka! This allows both hustlin checksums n' one off
calculations ta be done.
.PP
.Vb 2
\&    $crc = adler32($buffer [,$crc]) ;
\&    $crc = crc32($buffer [,$crc]) ;
.Ve
.PP
Da buffer parametas can either be a scalar or a scalar reference.
.PP
If tha \f(CW$crc\fR parametas is \f(CW\*(C`undef\*(C'\fR, tha crc value is ghon be reset.
.PP
If you have built dis module wit zlib 1.2.3 or better, two more
CRC-related functions is available.
.PP
.Vb 2
\&    $crc = adler32_combine($crc1, $crc2, $len2)l
\&    $crc = crc32_combine($adler1, $adler2, $len2)
.Ve
.PP
These functions allow checksums ta be merged.
.SH "Misc"
.IX Header "Misc"
.ie n .SS "my $version = \fICompress::Raw::Zlib::zlib_version()\fP;"
.el .SS "my \f(CW$version\fP = \fICompress::Raw::Zlib::zlib_version()\fP;"
.IX Subsection "my $version = Compress::Raw::Zlib::zlib_version();"
Returns tha version of tha zlib library.
.ie n .SS "my $flags = \fICompress::Raw::Zlib::zlibCompileFlags()\fP;"
.el .SS "my \f(CW$flags\fP = \fICompress::Raw::Zlib::zlibCompileFlags()\fP;"
.IX Subsection "my $flags = Compress::Raw::Zlib::zlibCompileFlags();"
Returns tha flags indicatin compile-time options dat was used ta build 
the zlib library. Right back up in yo muthafuckin ass. See tha zlib documentation fo' a thugged-out description of tha flags
returned by \f(CW\*(C`zlibCompileFlags\*(C'\fR.
.PP
Note dat when tha zlib sources is built along wit dis module the
\&\f(CW\*(C`sprintf\*(C'\fR flags (bits 24, 25 n' 26) should be ignored.
.PP
If yo ass is rockin zlib 1.2.0 or older, \f(CW\*(C`zlibCompileFlags\*(C'\fR will return 0.
.SH "Da LimitOutput option."
.IX Header "Da LimitOutput option."
By default \f(CW\*(C`$i\->inflate($input, $output)\*(C'\fR will uncompress \fIall\fR data
in \f(CW$input\fR n' write \fIall\fR of tha uncompressed data it has generated to
\&\f(CW$output\fR. This make tha intercourse ta \f(CW\*(C`inflate\*(C'\fR much simpla \- if the
method has uncompressed \f(CW$input\fR successfully \fIall\fR compressed data in
\&\f(CW$input\fR gonna git been dealt with. Right back up in yo muthafuckin ass. So if yo ass is readin from a input
source n' uncompressin as you go tha code will look suttin' like this
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&    
\&    use Compress::Raw::Zlib;
\&    
\&    mah $x = freshly smoked up Compress::Raw::Zlib::Inflate()
\&       or take a thugged-out dirtnap "Cannot create a inflation stream\en" ;
\&    
\&    mah $input = \*(Aq\*(Aq ;
\&    
\&    mah ($output, $status) ;
\&    while (read(STDIN, $input, 4096))
\&    {
\&        $status = $x\->inflate($input, $output) ;
\&    
\&        print $output ;
\&    
\&        last if $status != Z_OK ;
\&    }
\&    
\&    take a thugged-out dirtnap "inflation failed\en"
\&        unless $status == Z_STREAM_END ;
.Ve
.PP
Da points ta note are
.IP "\(bu" 5
Da main processin loop up in tha code handlez readin of compressed data
from \s-1STDIN.\s0
.IP "\(bu" 5
Da status code returned from \f(CW\*(C`inflate\*(C'\fR will only trigger termination of
the main processin loop if it aint \f(CW\*(C`Z_OK\*(C'\fR. When \f(CW\*(C`LimitOutput\*(C'\fR has not
been used tha \f(CW\*(C`Z_OK\*(C'\fR status means dat tha end of tha compressed
data stream has been reached or there has been a error up in uncompression.
.IP "\(bu" 5
Afta tha call ta \f(CW\*(C`inflate\*(C'\fR \fIall\fR of tha uncompressed data up in \f(CW$input\fR
will done been processed. Y'all KNOW dat shit, muthafucka! This means tha subsequent call ta \f(CW\*(C`read\*(C'\fR can
overwrite itz contents without any problem.
.PP
For most use-cases tha behavior busted lyrics bout above be aaight (this module
and itz predecessor, \f(CW\*(C`Compress::Zlib\*(C'\fR, have used it fo' over 10 years
without a issue) yo, but up in all dem straight-up specific use-cases tha amount of
memory required fo' \f(CW$output\fR can prohibitively large. For example, if the
compressed data stream gotz nuff tha same ol' dirty pattern repeated thousandz of
times, a relatively lil' small-ass compressed data stream can uncompress into
hundredz of megabytes.  Remember \f(CW\*(C`inflate\*(C'\fR will keep allocatin memory
until \fIall\fR tha uncompressed data has been freestyled ta tha output buffer \-
the size of \f(CW$output\fR is unbounded.
.PP
Da \f(CW\*(C`LimitOutput\*(C'\fR option is designed ta help wit dis use-case.
.PP
Da main difference up in yo' code when rockin \f(CW\*(C`LimitOutput\*(C'\fR is havin to
deal wit cases where tha \f(CW$input\fR parameta still gotz nuff some
uncompressed data dat \f(CW\*(C`inflate\*(C'\fR aint processed yet. Da status code
returned from \f(CW\*(C`inflate\*(C'\fR is ghon be \f(CW\*(C`Z_OK\*(C'\fR if uncompression took place and
\&\f(CW\*(C`Z_BUF_ERROR\*(C'\fR if tha output buffer is full.
.PP
Below is typical code dat shows how tha fuck ta use \f(CW\*(C`LimitOutput\*(C'\fR.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&    
\&    use Compress::Raw::Zlib;
\&    
\&    mah $x = freshly smoked up Compress::Raw::Zlib::Inflate(LimitOutput => 1)
\&       or take a thugged-out dirtnap "Cannot create a inflation stream\en" ;
\&    
\&    mah $input = \*(Aq\*(Aq ;
\&    binmode STDIN;
\&    binmode STDOUT;
\&    
\&    mah ($output, $status) ;
\&
\&  OUTER:
\&    while (read(STDIN, $input, 4096))
\&    {
\&        do
\&        {
\&            $status = $x\->inflate($input, $output) ;
\&
\&            print $output ;
\&
\&            last OUTER
\&                unless $status == Z_OK || $status == Z_BUF_ERROR ;
\&        }
\&        while ($status == Z_OK && length $input);
\&    }
\&    
\&    take a thugged-out dirtnap "inflation failed\en"
\&        unless $status == Z_STREAM_END ;
.Ve
.PP
Points ta note dis time:
.IP "\(bu" 5
There is now two nested loops up in tha code: tha outa loop fo' readin the
compressed data from \s-1STDIN,\s0 as before; n' tha inner loop ta carry up the
uncompression.
.IP "\(bu" 5
There is two exit points from tha inner uncompression loop.
.Sp
Firstly when \f(CW\*(C`inflate\*(C'\fR has returned a status other than \f(CW\*(C`Z_OK\*(C'\fR or
\&\f(CW\*(C`Z_BUF_ERROR\*(C'\fR.  This means dat either tha end of tha compressed data
stream has been reached (\f(CW\*(C`Z_STREAM_END\*(C'\fR) or there be a error up in the
compressed data. In either of these cases there is no point up in continuing
with readin tha compressed data, so both loops is terminated.
.Sp
Da second exit point tests if there be any data left up in tha input buffer,
\&\f(CW$input\fR \- remember dat tha \f(CW\*(C`ConsumeInput\*(C'\fR option be automatically
enabled when \f(CW\*(C`LimitOutput\*(C'\fR is used. Y'all KNOW dat shit, muthafucka!  When tha input buffer has been
exhausted, tha outa loop can run again n' again n' again n' overwrite a now empty
\&\f(CW$input\fR.
.SH "ACCESSING ZIP FILES"
.IX Header "ACCESSING ZIP FILES"
Although it is possible (with some effort on yo' part) ta use dis module
to access .zip files, there be other perl modulez available dat will do
all tha mad bullshit fo' yo thugged-out ass. Peep up \f(CW\*(C`Archive::Zip\*(C'\fR,
\&\f(CW\*(C`Archive::Zip::SimpleZip\*(C'\fR, \f(CW\*(C`IO::Compress::Zip\*(C'\fR and
\&\f(CW\*(C`IO::Uncompress::Unzip\*(C'\fR.
.SH "FAQ"
.IX Header "FAQ"
.SS "Compatibilitizzle wit Unix compress/uncompress."
.IX Subsection "Compatibilitizzle wit Unix compress/uncompress."
This module aint compatible wit Unix \f(CW\*(C`compress\*(C'\fR.
.PP
If you have tha \f(CW\*(C`uncompress\*(C'\fR program available, you can use dis ta read
compressed files
.PP
.Vb 4
\&    open F, "uncompress \-c $filename |";
\&    while (<F>)
\&    {
\&        ...
.Ve
.PP
Alternatively, if you have tha \f(CW\*(C`gunzip\*(C'\fR program available, you can use
this ta read compressed files
.PP
.Vb 4
\&    open F, "gunzip \-c $filename |";
\&    while (<F>)
\&    {
\&        ...
.Ve
.PP
and dis ta write compress files, if you have tha \f(CW\*(C`compress\*(C'\fR program
available
.PP
.Vb 4
\&    open F, "| compress \-c $filename ";
\&    print F "data";
\&    ...
\&    close F ;
.Ve
.SS "Accessin .tar.Z files"
.IX Subsection "Accessin .tar.Z files"
See previous \s-1FAQ\s0 item.
.PP
If tha \f(CW\*(C`Archive::Tar\*(C'\fR module is installed n' either tha \f(CW\*(C`uncompress\*(C'\fR or
\&\f(CW\*(C`gunzip\*(C'\fR programs is available, you can use one of these workaroundz to
read \f(CW\*(C`.tar.Z\*(C'\fR files.
.PP
Firstly wit \f(CW\*(C`uncompress\*(C'\fR
.PP
.Vb 3
\&    use strict;
\&    use warnings;
\&    use Archive::Tar;
\&
\&    open F, "uncompress \-c $filename |";
\&    mah $tar = Archive::Tar\->new(*F);
\&    ...
.Ve
.PP
and dis wit \f(CW\*(C`gunzip\*(C'\fR
.PP
.Vb 3
\&    use strict;
\&    use warnings;
\&    use Archive::Tar;
\&
\&    open F, "gunzip \-c $filename |";
\&    mah $tar = Archive::Tar\->new(*F);
\&    ...
.Ve
.PP
Similarly, if tha \f(CW\*(C`compress\*(C'\fR program be available, you can use dis to
write a \f(CW\*(C`.tar.Z\*(C'\fR file
.PP
.Vb 4
\&    use strict;
\&    use warnings;
\&    use Archive::Tar;
\&    use IO::File;
\&
\&    mah $fh = freshly smoked up IO::File "| compress \-c >$filename";
\&    mah $tar = Archive::Tar\->new();
\&    ...
\&    $tar\->write($fh);
\&    $fh\->close ;
.Ve
.SS "Zlib Library Version Support"
.IX Subsection "Zlib Library Version Support"
By default \f(CW\*(C`Compress::Raw::Zlib\*(C'\fR will build wit a private copy of version
1.2.5 of tha zlib library. (See tha \fI\s-1README\s0\fR file fo' details of
how ta override dis behaviour)
.PP
If you decizzle ta bust a gangbangin' finger-lickin' different version of tha zlib library, you need ta be
aware of tha followin issues
.IP "\(bu" 5
First off, you must have zlib 1.0.5 or better.
.IP "\(bu" 5
Yo ass need ta have zlib 1.2.1 or betta if you wanna use tha \f(CW\*(C`\-Merge\*(C'\fR
option wit \f(CW\*(C`IO::Compress::Gzip\*(C'\fR, \f(CW\*(C`IO::Compress::Deflate\*(C'\fR and
\&\f(CW\*(C`IO::Compress::RawDeflate\*(C'\fR.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
All tha \fIzlib\fR constants is automatically imported when you make use
of \fICompress::Raw::Zlib\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Compress::Zlib, IO::Compress::Gzip, IO::Uncompress::Gunzip, IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate, IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress
.PP
IO::Compress::FAQ
.PP
File::GlobMapper, Archive::Zip,
Archive::Tar,
IO::Zlib
.PP
For \s-1RFC 1950, 1951\s0 n' 1952 peep 
\&\fIhttp://www.faqs.org/rfcs/rfc1950.html\fR,
\&\fIhttp://www.faqs.org/rfcs/rfc1951.html\fR and
\&\fIhttp://www.faqs.org/rfcs/rfc1952.html\fR
.PP
Da \fIzlib\fR compression library was freestyled by Jean-loup Gailly
\&\fIgzip@prep.ai.mit.edu\fR n' Mark Adla \fImadler@alumni.caltech.edu\fR.
.PP
Da primary joint fo' tha \fIzlib\fR compression library is
\&\fIhttp://www.zlib.org\fR.
.PP
Da primary joint fo' gzip is \fIhttp://www.gzip.org\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module was freestyled by Pizzle Marquess, \fIpmqs@cpan.org\fR.
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
See tha Chizzlez file.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2005\-2013 Pizzle Marquess fo' realz. All muthafuckin rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
