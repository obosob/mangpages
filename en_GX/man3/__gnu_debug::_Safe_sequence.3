" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_debug::_Safe_sequence< _Sequence > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fB__gnu_debug::_Safe_sequence_base\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_attach\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)  throw ()"
.br
.ti -1c
.RI "void \fB_M_detach\fP (\fB_Safe_iterator_base\fP *__it)"
.br
.ti -1c
.RI "void \fB_M_detach_single\fP (\fB_Safe_iterator_base\fP *__it)  throw ()"
.br
.ti -1c
.RI "void \fB_M_invalidate_all\fP () const "
.br
.ti -1c
.RI "template<typename _Predicate > void \fB_M_invalidate_if\fP (_Predicate __pred)"
.br
.ti -1c
.RI "template<typename _Predicate > void \fB_M_transfer_from_if\fP (\fB_Safe_sequence\fP &__from, _Predicate __pred)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_const_iterators\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_iterators\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_detach_all\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_singular\fP ()"
.br
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()  throw ()"
.br
.ti -1c
.RI "void \fB_M_revalidate_singular\fP ()"
.br
.ti -1c
.RI "void \fB_M_swap\fP (\fB_Safe_sequence_base\fP &__x)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Sequence>class __gnu_debug::_Safe_sequence< _Sequence >"
Base class fo' constructin a \fIsafe\fP sequence type dat tracks iterators dat reference it\&. 

Da class template _Safe_sequence simplifies tha construction of \fIsafe\fP sequences dat track tha iterators dat reference tha sequence, so dat tha iterators is notified of chizzlez up in tha sequence dat may affect they operation, e\&.g\&., if tha container invalidates its iterators or is destructed\&. This class template may only be used by derivin from it n' passin tha name of tha derived class as its template parameta via tha curiously recurrin template pattern\&. Da derived class must have \fCiterator\fP n' \fCconst_iterator\fP types dat is instantiationz of class template _Safe_iterator fo' dis sequence\&. Iterators will then be tracked automatically\&. 
.PP
Definizzle at line 52 of file formatter\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Attach a iterator ta dis sequence\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach_single (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Detach a iterator from dis sequence 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_all ()\fC [protected]\fP, \fC [inherited]\fP"
Detach all iterators, leavin dem singular\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence_base::~_Safe_sequence_base()\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_single (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Detach all singular iterators\&. 
.PP
\fBPostcondition:\fP
.RS 4
for all iterators i attached ta dis sequence, i->_M_version == _M_version\&. 
.RE
.PP

.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_sequence_base::_M_get_mutex ()\fC [protected]\fP, \fC [inherited]\fP"
For use up in _Safe_sequence\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_invalidate_all () const\fC [inline]\fP, \fC [inherited]\fP"
Invalidates all iterators\&. 
.PP
Definizzle at line 233 of file safe_base\&.h\&.
.PP
References __gnu_debug::_Safe_sequence_base::_M_version\&.
.SS "template<typename _Sequence > template<typename _Predicate > void \fB__gnu_debug::_Safe_sequence\fP< _Sequence >::_M_invalidate_if (_Predicate__pred)"
Invalidates all iterators \fCx\fP dat reference dis sequence, is not singular, n' fo' which \fC__pred(x)\fP returns \fCtrue\fP\&. \fC__pred\fP is ghon be invoked wit tha aiiight iterators nested up in tha safe ones\&. 
.PP
Definizzle at line 38 of file safe_sequence\&.tcc\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_revalidate_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Revalidates all attached singular iterators\&. This method may be used ta validate iterators dat was invalidated before (but fo' some reason, like fuckin a exception, need ta become valid again)\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_swap (\fB_Safe_sequence_base\fP &__x)\fC [protected]\fP, \fC [inherited]\fP"
Swap dis sequence wit tha given sequence\&. This operation also swaps ballershizzle of tha iterators, so dat when tha operation is complete all iterators dat originally referenced one container now reference tha other container\&. 
.SS "template<typename _Sequence > template<typename _Predicate > void \fB__gnu_debug::_Safe_sequence\fP< _Sequence >::_M_transfer_from_if (\fB_Safe_sequence\fP< _Sequence > &__from, _Predicate__pred)"
Transfers all iterators \fCx\fP dat reference \fCfrom\fP sequence, is not singular, n' fo' which \fC__pred(x)\fP returns \fCtrue\fP\&. \fC__pred\fP is ghon be invoked wit tha aiiight iterators nested up in tha safe ones\&. 
.PP
Definizzle at line 69 of file safe_sequence\&.tcc\&.
.PP
References __gnu_debug::_Safe_sequence_base::_M_const_iterators, __gnu_debug::_Safe_iterator_base::_M_detach_single(), __gnu_debug::_Safe_sequence_base::_M_get_mutex(), __gnu_debug::_Safe_sequence_base::_M_iterators, __gnu_debug::_Safe_iterator_base::_M_next, __gnu_debug::_Safe_iterator_base::_M_prior, __gnu_debug::_Safe_iterator_base::_M_sequence, n' __gnu_debug::_Safe_sequence_base::_M_version\&.
.SH "Member Data Documentation"
.PP 
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_sequence_base::_M_const_iterators\fC [inherited]\fP"

.PP
Da list of constant iterators dat reference dis container\&. 
.PP
Definizzle at line 184 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_sequence_base::_M_iterators\fC [inherited]\fP"

.PP
Da list of mutable iterators dat reference dis container\&. 
.PP
Definizzle at line 181 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "unsigned int __gnu_debug::_Safe_sequence_base::_M_version\fC [mutable]\fP, \fC [inherited]\fP"

.PP
Da container version number\&. This number may never be 0\&. 
.PP
Definizzle at line 187 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence_base::_M_invalidate_all(), n' __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
