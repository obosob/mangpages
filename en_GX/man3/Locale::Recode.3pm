.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Recode 3"
.TH Locale::Recode 3 "2013-08-04" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Recode \- Object\-Oriented Portable Charset Conversion
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Locale::Recode;
\&
\&  $cd = Locale::Recode\->new (from => \*(AqUTF\-8\*(Aq,
\&                             ta   => \*(AqISO\-8859\-1\*(Aq);
\&
\&  take a thugged-out dirtnap $cd\->getError if $cd\->getError;
\&
\&  $cd\->recode ($text) or take a thugged-out dirtnap $cd\->getError;
\&
\&  $mime_name = Locale::Recode\->resolveAlias (\*(Aqlatin\-1\*(Aq);
\&
\&  $supported = Locale::Recode\->getSupported;
\&
\&  $complete = Locale::Recode\->getCharsets;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up routines dat convert textual data from one
codeset ta another up in a portable way.  Da module has been started
before \fIEncode\fR\|(3) was written. I aint talkin' bout chicken n' gravy biatch.  It aint nuthin but main purpose todizzle is ta provide
charset conversion even when \fIEncode\fR\|(3) aint available on tha system.
It should also work fo' olda Perl versions without Unicode support.
.PP
Internally \fILocale::Recode\fR\|(3) will use \fIEncode\fR\|(3) whenever possible,
to allow fo' a gangbangin' fasta conversion n' fo' a wider range of supported
charsets, n' will only fall back ta tha Perl implementation when
\&\fIEncode\fR\|(3) aint available or do not support a particular charset
that \fILocale::Recode\fR\|(3) do.
.PP
\&\fILocale::Recode\fR\|(3) is part of libintl-perl, n' itz main purpose is
actually ta implement a portable charset conversion framework for
the message translation facilitizzles busted lyrics bout up in \fILocale::TextDomain\fR\|(3).
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
Da constructor \f(CW\*(C`new()\*(C'\fR requires two named arguments:
.IP "\fBfrom\fR" 4
.IX Item "from"
Da encodin of tha original gangsta data.  Case don't matter, aliases
are resolved.
.IP "\fBto\fR" 4
.IX Item "to"
Da target encoding.  Again, case don't matter, n' aliases
are resolved.
.PP
Da constructor aint NEVER gonna fail.  In case of a error, tha object's
internal state is set ta wack n' it will refuse ta do any conversions.
Yo ass can inquire tha reason fo' tha failure wit tha method
\&\fIgetError()\fR.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
Da followin object methodz is available.
.IP "\fBrecode (\s-1STRING\s0)\fR" 4
.IX Item "recode (STRING)"
Converts \fB\s-1STRING\s0\fR from tha source encodin tha fuck into tha destination
encoding.  In case of success, a truth value is returned, false
otherwise.  Yo ass can inquire tha reason fo' tha failure wit the
method \fIgetError()\fR.
.IP "\fBgetError\fR" 4
.IX Item "getError"
Returns either false if tha object aint up in a error state or
an error message.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
Da object serves up some additionizzle class methods:
.IP "\fBgetSupported\fR" 4
.IX Item "getSupported"
Returns a reference ta a list of all supported charsets, n' you can put dat on yo' toast.  This
may implicitely load additionizzle \fIEncode\fR\|(3) conversions like 
\&\fIEncode::HanExtra\fR\|(3) which may produce considerable load on your
system.
.Sp
Da method is therefore not intended fo' regular use but rather
for gettin resp. displayin \fIonce\fR a list of available encodings.
.Sp
Da thugz of tha list is all converted ta uppercase!
.IP "\fBgetCharsets\fR" 4
.IX Item "getCharsets"
Like \fIgetSupported()\fR but also returns all available aliases.
.SH "SUPPORTED CHARSETS"
.IX Header "SUPPORTED CHARSETS"
Da range of supported charsets is system-dependent.  Da following
somewhat special charsets is always available:
.IP "\fB\s-1UTF\-8\s0\fR" 4
.IX Item "UTF-8"
\&\s-1UTF\-8\s0 be available independently of yo' Perl version. I aint talkin' bout chicken n' gravy biatch.  For Perl 5.6
or betta or up in tha presence of \fIEncode\fR\|(3), conversions is not done
in Perl but wit tha intercourses provided by these facilitizzles which
are freestyled up in C, hence much faster.
.Sp
Encodin data \fIinto\fR \s-1UTF\-8\s0 is fast, even if it is done up in Perl.
Decodin it up in Perl may become like slow.  If you frequently have
to decode \s-1UTF\-8\s0 wit \fBLocale::Recode\fR yo big-ass booty is ghon probably want to
make shizzle dat you do dat wit Perl 5.6 or beter, or install \fIEncode\fR\|(3) to
speed up thangs.
.IP "\fB\s-1INTERNAL\s0\fR" 4
.IX Item "INTERNAL"
\&\s-1UTF\-8\s0 is fast ta write but hard ta read fo' applications.  It be 
therefore not da most thugged-out shitty fo' internal strang representation but not
far from dis shit.  \fILocale::Recode\fR\|(3) stores strings internally as a
reference ta a array of integer joints like most programmin languages
(Perl be a exception) do, tradin memory fo' performance.
.Sp
Da integer joints is tha \s-1UCS\-4\s0 codez of tha charactas up in host
byte order.
.Sp
Da encodin \fB\s-1INTERNAL\s0\fR is directly availabe via \fILocale::Recode\fR\|(3)
but of course you should not straight-up use it fo' data exchange, unless
you know what tha fuck yo ass is bustin.
.PP
\&\fILocale::Recode\fR\|(3) has natizzle support fo' a plethora of other encodings,
most of dem 8 bit encodings dat is fast ta decode, includin most
encodings used on ghettofab micros like tha ISO\-8859\-* seriez of encodings,
most Windows\-* encodings (also known as CP*), Macintosh, Atari, etc.
.SH "NAMES AND ALIASES"
.IX Header "NAMES AND ALIASES"
Each charset resp. encodin be available internally under a unique
name.  Whenever tha shiznit was available, tha preferred \s-1MIME\s0 name
(see <http://www.iana.org/assignments/character\-sets/>) was chosen as 
the internal name.
.PP
Alias handlin is like strict.  Da module do not make wild guesses
at what tha fuck you mean (\*(L"Whatz tha meanin of tha acronym \s-1JIS\*(R"\s0 be a valid
alias fo' \*(L"7bit\-jis\*(R" up in \fIEncode\fR\|(3) ....) but aims at providin common
aliases only.  Da same applies ta so-called aliases dat is straight-up 
mistakes, like \*(L"utf8\*(R" fo' \s-1UTF\-8.\s0
.PP
Da module knows all aliases dat is listed wit tha \s-1IANA\s0 character
set registry (<http://www.iana.org/assignments/character\-sets/>), plus
those known ta libiconv version 1.8, n' a funky-ass bunch of additionizzle ones.
.SH "CONVERSION TABLES"
.IX Header "CONVERSION TABLES"
Da conversion tablez have either been taken from straight-up legit sources
like tha \s-1IANA\s0 or tha Unicode Consortium, from Bruno Haiblez libiconv,
or from tha sourcez of tha \s-1GNU\s0 libc n' tha regression tests fo' 
libintl-perl will check fo' conformizzle here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  For some encodings dis data
differs from \fIEncode\fR\|(3)z data which would cause these tests ta fail.  
In these cases, tha module aint gonna invoke tha \fIEncode\fR\|(3) methodz yo, but
will fall back ta tha internal implementation fo' tha sake of 
consistency.
.PP
Da few encodings dat is affected is so simple dat yo big-ass booty is ghon not
experience any real performizzle penalty unless you convert big-ass chunks
of data.  But tha package aint straight-up intended fo' such use anyway, and
since \fIEncode\fR\|(3) is relatively new, I rather be thinkin dat tha differences
are bugs up in Encode which is ghon be fixed soon.
.SH "BUGS"
.IX Header "BUGS"
Da module should provide fall back conversions fo' other Unicode
encodin schemes like \s-1UCS\-2, UCS\-4 \s0(big\- n' lil-endian).
.PP
Da pure Perl \s-1UTF\-8\s0 decoder aint gonna always handle corrupt \s-1UTF\-8\s0
correctly, especially all up in tha end n' all up in tha beginnin of tha string.
This aint likely ta be fixed, since tha modulez intention is not
to be a cold-ass lil consistency checker fo' \s-1UTF\-8\s0 data.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2002\-2009, Guido Flohr <guido@imperia.net>, all
rights reserved. Y'all KNOW dat shit, muthafucka!  See tha source code fo' details.
.PP
This software is contributed ta tha Perl hood by Imperia 
(<http://www.imperia.net/>).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIEncode\fR\|(3), \fIiconv\fR\|(3), \fIiconv\fR\|(1), \fIrecode\fR\|(1), \fIperl\fR\|(1)
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 369:" 4
.IX Item "Around line 369:"
=cut found outside a pod block.  Skippin ta next block.
