.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Manip::DM6 3"
.TH Date::Manip::DM6 3 "2014-12-05" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::DM6 \- Date manipulation routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Date::Manip;
\&
\&   $version = DateManipVersion($flag);
\&
\&   Date_Init("VAR=VAL","VAR=VAL",...);
\&
\&   $date = ParseDate(\e@args);
\&   $date = ParseDate($string);
\&   $date = ParseDate(\e$string);
\&
\&   $date = ParseDateString($string);
\&
\&   $date = ParseDateFormat($format,$string);
\&
\&   @date = UnixDate($date,@format);
\&   $date = UnixDate($date,@format);
\&
\&   $delta = ParseDateDelta(\e@args   [,$mode]);
\&   $delta = ParseDateDelta($strin  [,$mode]);
\&   $delta = ParseDateDelta(\e$strin [,$mode]);
\&
\&   @str = Delta_Format($delta, [$mode,] $dec,@format);
\&   $str = Delta_Format($delta, [$mode,] $dec,@format);
\&
\&   $recur = ParseRecur($string,$base,$date0,$date1,$flags);
\&   @dates = ParseRecur($string,$base,$date0,$date1,$flags);
\&
\&   $flag = Date_Cmp($date1,$date2);
\&
\&   $d = DateCalc($d1,$d2 [,$errref] [,$mode]);
\&
\&   $date = Date_SetTime($date,$hr,$min,$sec);
\&   $date = Date_SetTime($date,$time);
\&
\&   $date = Date_SetDateField($date,$field,$val [,$nocheck]);
\&
\&   $date = Date_GetPrev($date,$dow,$todizzle,$hr,$min,$sec);
\&   $date = Date_GetPrev($date,$dow,$todizzle,$time);
\&
\&   $date = Date_GetNext($date,$dow,$todizzle,$hr,$min,$sec);
\&   $date = Date_GetNext($date,$dow,$todizzle,$time);
\&
\&   $name = Date_IsHoliday($date);
\&   @name = Date_IsHoliday($date);
\&
\&   $listref = Events_List($date);
\&   $listref = Events_List($date0,$date1);
\&
\&   $date = Date_ConvTZ($date,$from,$to);
\&
\&   $flag = Date_IsWorkDay($date [,$flag]);
\&
\&   $date = Date_NextWorkDay($date,$off [,$time]);
\&
\&   $date = Date_PrevWorkDay($date,$off [,$time]);
\&
\&   $date = Date_NearestWorkDay($date [,$tomorrowfirst]);
.Ve
.PP
In tha followin routines, \f(CW$y\fR may be entered as either a 2 or 4 digit
year (it is ghon be converted ta a 4 digit year based on tha variable
YYtoYYYY busted lyrics bout below).  Month n' dizzle should be numeric up in all
cases.
.PP
.Vb 12
\&   $dizzle = Date_DayOfWeek($m,$d,$y);
\&   $secs = Date_SecsSince1970($m,$d,$y,$h,$mn,$s);
\&   $secs = Date_SecsSince1970GMT($m,$d,$y,$h,$mn,$s);
\&   $days = Date_DaysSince1BC($m,$d,$y);
\&   $dizzle = Date_DayOfYear($m,$d,$y);
\&   ($y,$m,$d,$h,$mn,$s) = Date_NthDayOfYear($y,$n);
\&   $days = Date_DaysInYear($y);
\&   $days = Date_DaysInMonth($m,$y);
\&   $wkno = Date_WeekOfYear($m,$d,$y,$first);
\&   $flag = Date_LeapYear($y);
\&   $dizzle = Date_DaySuffix($d);
\&   $tz = Date_TimeZone();
.Ve
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBDateManipVersion\fR" 4
.IX Item "DateManipVersion"
.Vb 1
\&   $version = DateManipVersion($flag);
.Ve
.Sp
Returns tha version of Date::Manip.  If \f(CW$flag\fR is non-zero, timezone shiznit
is also returned.
.IP "\fBDate_Init\fR" 4
.IX Item "Date_Init"
.Vb 1
\&   Date_Init("VAR=VAL","VAR=VAL",...);
.Ve
.Sp
Da Date_Init function is used ta set any of tha Date::Manip configuration
variablez busted lyrics bout up in tha Date::Manip::Config document.
.Sp
Da strings ta pass up in iz of tha form \*(L"VAR=VAL\*(R".  Any number may be
included n' they can come up in any order n' shit.  \s-1VAR\s0 may be any configuration
variable.  \s-1VAL\s0 be any allowed value fo' dat variable.  For example,
to switch from Gangsta ta French n' use non-US format (so dat 12/10
is Oct 12), do tha following:
.Sp
.Vb 1
\&   Date_Init("Language=French","DateFormat=non\-US");
.Ve
.Sp
Note dat variablez is parsed up in tha order they is given, so
\&\*(L"DateFormat=non\-US\*(R", \*(L"ConfigFile=./manip.cnf\*(R" may not give the
expected result. To be safe, ConfigFile should always step tha fuck up first in
the list.
.IP "\fBParseDate\fR" 4
.IX Item "ParseDate"
.Vb 3
\&   $date = ParseDate(\e@args);
\&   $date = ParseDate($string);
\&   $date = ParseDate(\e$string);
.Ve
.Sp
This takes a array or a strang containin a thugged-out date n' parses dat shit.  When the
date is included as a array (for example, tha arguments ta a program) the
array should contain a valid date up in tha straight-up original gangsta one or mo' elements
(elements afta a valid date is ignored).  Elements containin a valid
date is shifted from tha array.  Da phattest possible number of elements
which can be erectly interpreted as a valid date is always used. Y'all KNOW dat shit, muthafucka!  If a
strin is entered rather than a array, dat strang is tested fo' a valid
date.  Da strang is unmodified, even if passed up in by reference.
.Sp
Da ParseDate routine is primarily used ta handle command line arguments.
If you gotz a cold-ass lil command where you wanna enta a thugged-out date as a cold-ass lil command line
argument, you can use Date::Manip ta make suttin' like tha following
work:
.Sp
.Vb 1
\&   mycommand \-date Dec 10 1997 \-arg \-arg2
.Ve
.Sp
No mo' readin playa pages ta smoke up what tha fuck date format is required up in a
man page.
.Sp
Oldschool note: dis is originally why tha Date::Manip routines were
written (though long before they was busted out as tha Date::Manip module).
I was rockin a funky-ass bunch of programs (primarily batch queue managers) where
dates n' times was entered as command line options n' I was getting
highly annoyed all up in tha nuff different (but not compatible) ways dat they
had ta be entered. Y'all KNOW dat shit, muthafucka!  Date::Manip originally consisted of basically 1 routine
which I could pass \*(L"@ARGV\*(R" ta n' have it remove a thugged-out date from tha beginning.
.IP "\fBParseDateString\fR" 4
.IX Item "ParseDateString"
.Vb 1
\&   $date = ParseDateString($string);
.Ve
.Sp
This parses a strang containin a thugged-out date n' returns dat shit. Refer ta the
Date::Manip::Date documentation fo' valid date formats, n' you can put dat on yo' toast. Da date
returned is up in tha local time unit.
.IP "\fBParseDateFormat\fR" 4
.IX Item "ParseDateFormat"
.Vb 1
\&   $date = ParseDateFormat($format,$string);
.Ve
.Sp
This parses a strang containin a thugged-out date based on a gangbangin' format strang and
returns tha date. Refer ta tha Date::Manip::Date documentation fo' the
parse_format method fo' mo' shiznit. I aint talkin' bout chicken n' gravy biatch. Da date returned is up in the
local time unit.
.IP "\fBUnixDate\fR" 4
.IX Item "UnixDate"
.Vb 2
\&   $out = UnixDate($date,$in);
\&   @out = UnixDate($date,@in);
.Ve
.Sp
This takes a thugged-out date n' a list of strings containin formats roughly
identical ta tha format strings used by tha \s-1UNIX\s0 \fIdate\fR\|(1) command.
Each format is parsed n' a array of strings correspondin ta each
format is returned.
.Sp
Da formats is busted lyrics bout up in tha Date::Manip::Date document.
.IP "\fBParseDateDelta\fR" 4
.IX Item "ParseDateDelta"
.Vb 3
\&   $delta = ParseDateDelta(\e@args   [,$mode]);
\&   $delta = ParseDateDelta($strin  [,$mode]);
\&   $delta = ParseDateDelta(\e$strin [,$mode]);
.Ve
.Sp
In tha straight-up original gangsta form, it takes a array n' shifts a valid delta from dat shit.
In tha other two forms, it parses a strang ta peep if it gotz nuff a
valid delta.
.Sp
A valid delta is returned if found. Y'all KNOW dat shit, muthafucka! Otherwise, a empty strang is
returned.
.Sp
Da delta can be converted ta 'exact', 'semi', or 'approx' rockin the
Date::Manip::Delta::convert method if \f(CW$mode\fR is passed in.
.IP "\fBDelta_Format\fR" 4
.IX Item "Delta_Format"
.Vb 2
\&   $out = Delta_Format($delta [,$mode], $dec,$in);
\&   @out = Delta_Format($delta [,$mode], $dec,@in);
.Ve
.Sp
This is similar ta tha UnixDate routine except dat it extracts shiznit
from a thugged-out delta.
.Sp
When formattin fieldz up in a thugged-out delta, tha Date::Manip 6.00 formats have chizzled
and is much mo' bangin naaahhmean? Da oldschool 5.xx formats is still available for
the Delta_Format command fo' backward compatibility. These formats include:
.Sp
.Vb 1
\&   %Xv  : print tha value of tha field X
\&
\&   %Xd  : print tha value of tha field X n' all
\&          smalla units up in termz of X
\&
\&   %Xh  : print tha value of field X n' all
\&          larger units up in termz of X
\&
\&   %Xt  : print tha value of all fieldz in
\&          termz of X
.Ve
.Sp
These make use of tha \f(CW$mode\fR n' \f(CW$dec\fR arguments ta determine how tha fuck to
format tha shiznit.
.Sp
\&\f(CW$dec\fR be a integer, n' is required, It  drops some lyrics ta tha number of decimal
places ta use.
.Sp
\&\f(CW$mode\fR is either \*(L"exact\*(R", \*(L"semi\*(R", or \*(L"approx\*(R" n' defaults ta \*(L"exact\*(R"
if it aint included.
.Sp
In \*(L"exact\*(R" mode, only exact relationshizzlez is used. Y'all KNOW dat shit, muthafucka!  This means that
there can be no mixin of tha Y/M, W/D, n' H/MN/S segments (for
non-businizz deltas, or Y/M, W, n' D/H/MN/S segments fo' bidnizz
deltas) cuz there is no exact relation between tha fieldz of each
set.
.Sp
In \*(L"semi\*(R" mode, tha semi-approximate relationshizzlez is used so
there is no mixin between Y/M n' W/D/H/MN/S.
.Sp
In \*(L"approx\*(R" mode, approximate relationshizzlez is used so all fields
can mix.
.Sp
Da semi-approximate n' approximate relationshizzlez is busted lyrics bout in
the Date::Manip::Delta manual.
.Sp
So, up in \*(L"exact\*(R" mode, wit a non-businizz delta, n' \f(CW$dec\fR = 2, the
followin is equivalent:
.Sp
.Vb 7
\&   oldschool steez    freshly smoked up style
\&   \-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-
\&   %Xv          %Xv
\&   %hd          %.2hhs
\&   %hh          %.2hdh
\&   %ht          %.2hds
\&   %yd          %.2yyM
.Ve
.Sp
In \*(L"approximate\*(R" mode, tha followin is equivalent:
.Sp
.Vb 7
\&   oldschool steez    freshly smoked up style
\&   \-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-
\&   %Xv          %Xv
\&   %hd          %.2hhs
\&   %hh          %.2hdh
\&   %ht          %.2hys
\&   %yd          %.2yys
.Ve
.Sp
If you wanna use tha freshly smoked up steez formats up in Delta_Format, use one of
the calls:
.Sp
.Vb 2
\&   Delta_Format($delta, @in);
\&   Delta_Format($delta, undef, @in);
.Ve
.Sp
If tha straight-up original gangsta element of \f(CW@in\fR be a integer, you gotta use tha 2nd
form.
.Sp
Da oldschool formats will remain available fo' tha time being, though at
some point they may be deprecated.
.IP "\fBDateCalc\fR" 4
.IX Item "DateCalc"
.Vb 1
\& $d = DateCalc($d1,$d2 [,\e$err] [,$mode]);
.Ve
.Sp
This takes two dates, deltas, or one of each n' performs tha appropriate
calculation wit em.  Dates must be a strang dat can be parsed by
ParseDateString.  Deltas must be a strang dat can be parsed by
ParseDateDelta.  Two deltas add together ta form a third delta.  A date
and a thugged-out delta returns a 2nd date.  Two dates return a thugged-out delta (the difference
between tha two dates).
.Sp
Since tha two shit can be interpreted as either dates or deltas, and
since nuff strings can be interpreted as both a thugged-out date or a thugged-out delta, it
is a phat scam ta pass tha input all up in ParseDateDelta,
if appropriate if there be any ambiguity. For example, tha string
\&\*(L"09:00:00\*(R" can be interpreted either as a thugged-out date (todizzle at 9:00:00) or a
delta (9 hours). To avoid unexpected thangs up in dis biatch, avoid callin DateCalc
as:
.Sp
.Vb 1
\&  $d = DateCalc("09:00:00",$someothervalue);
.Ve
.Sp
Instead, call it as:
.Sp
.Vb 1
\&  $d = DateCalc(ParseDate("09:00:00"),$someothervalue);
.Ve
.Sp
to force it ta be a thugged-out date, or:
.Sp
.Vb 1
\&  $d = DateCalc(ParseDateDelta("09:00:00"),$someothervalue);
.Ve
.Sp
to force it ta be a thugged-out delta. This will avoid unexpected thangs up in dis biatch.
Passin suttin' all up in ParseDate is optionizzle since they will be
treated as dates by default (and fo' performizzle reasons, you is
betta off not callin ParseDate).
.Sp
If there is no ambiguity, yo ass is betta off \s-1NOT\s0 bustin dis for
performizzle reasons. If tha delta be a funky-ass bidnizz delta, you definitely
should \s-1NOT\s0 do all dis bullshit.
.Sp
One other thang ta note is dat when parsin dates, a thugged-out delta can
be interpreted as a thugged-out date relatizzle ta now, nahmeean? DateCalc will \s-1ALWAYS\s0
treat a thugged-out delta as a thugged-out delta, \s-1NOT\s0 a thugged-out date.
.Sp
For details on how tha fuck calculations is done, refer ta tha Date::Manip::Calc
documentation.
.Sp
By default, math is done rockin a exact mode.
.Sp
If two deltas, or a thugged-out date n' a thugged-out delta is passed in, \f(CW$mode\fR may be used
to force tha delta ta be either bidnizz or non-businizz mode deltas.
If \f(CW$mode\fR is 0 or 1, tha delta(s) is ghon be non-business. Otherwise,
they is ghon be bidnizz deltas. If \f(CW$mode\fR is passed in, it is ghon be used
only if tha bidnizz or non-businizz state was not explicitly set in
the delta.
.Sp
If two dates is passed in, \f(CW$mode\fR is used ta determine tha type of
calculation. I aint talkin' bout chicken n' gravy biatch.  By default, a exact delta is produced. Y'all KNOW dat shit, muthafucka!  If \f(CW$mode\fR is 1,
an approximate delta is produced. Y'all KNOW dat shit, muthafucka!  If \f(CW$mode\fR is 2, a funky-ass bidnizz
approximate (bapprox) mode calculation is done.  If \f(CW$mode\fR is 3, a
exact bidnizz mode delta is produced.
.Sp
If \e$err is passed in, it is set to:
   1 is returned if \f(CW$d1\fR aint a thugged-out delta or date
   2 is returned if \f(CW$d2\fR aint a thugged-out delta or date
   3 if any other error occurs.
This argument is optionizzle yo, but if included, it must come before \f(CW$mode\fR.
.Sp
Nothang is returned if a error occurs.
.IP "\fBParseRecur\fR" 4
.IX Item "ParseRecur"
.Vb 2
\&   $recur = ParseRecur($strin [,$base,$date0,$date1,$flags]);
\&   @dates = ParseRecur($strin [,$base,$date0,$date1,$flags]);
.Ve
.Sp
This parses a strang containin a recurrence n' returns a gangbangin' straight-up specified
recurrence, or a list of dates referred to.
.Sp
\&\f(CW$string\fR can be any of tha forms:
.Sp
.Vb 5
\&   FREQ
\&   FREQ*FLAGS
\&   FREQ*FLAGS*BASE
\&   FREQ*FLAGS*BASE*DATE0
\&   FREQ*FLAGS*BASE*DATE0*DATE1
.Ve
.Sp
where \s-1FREQ\s0 be a gangbangin' frequence (see tha Date::Manip::Delta documentation),
\&\s-1FLAGS\s0 be a cold-ass lil comma separated list of flags, n' \s-1BASE, DATE0,\s0 n' \s-1DATE1\s0 are
date strings. Da dates n' flags can also be passed up in as \f(CW$base\fR, \f(CW$date0\fR,
\&\f(CW$date1\fR, n' \f(CW$flags\fR, n' these will override any joints up in \f(CW$string\fR.
.Sp
In scalar context, tha straight-up specified recurrence (or as much shiznit
as be available) is ghon be returned. Y'all KNOW dat shit, muthafucka! In list context, a list of dates will
be returned.
.IP "\fBDate_Cmp\fR" 4
.IX Item "Date_Cmp"
.Vb 1
\&   $flag = Date_Cmp($date1,$date2);
.Ve
.Sp
This takes two dates n' compares em fo' realz. Any dates dat can be parsed will be
compared.
.IP "\fBDate_GetPrev\fR" 4
.IX Item "Date_GetPrev"
.Vb 4
\&   $date = Date_GetPrev($date,$dow, $curr [,$hr,$min,$sec]);
\&   $date = Date_GetPrev($date,$dow, $curr [,$time]);
\&   $date = Date_GetPrev($date,undef,$curr,$hr,$min,$sec);
\&   $date = Date_GetPrev($date,undef,$curr,$time);
.Ve
.Sp
This takes a thugged-out date (any strang dat may be parsed by ParseDateString) n' finds
the previous occurrence of either a thugged-out dizzle of tha week, or a cold-ass lil certain time of day.
.Sp
This is documented up in tha \*(L"prev\*(R" method up in Date::Manip::Date, except that
here, \f(CW$time\fR be a strang (\s-1HH, HH:MN:,\s0 or \s-1HH:MN:SS\s0), n' \f(CW$dow\fR may be a string
of tha form \*(L"Fri\*(R" or \*(L"Friday\*(R".
.IP "\fBDate_GetNext\fR" 4
.IX Item "Date_GetNext"
.Vb 4
\&   $date = Date_GetNext($date,$dow, $curr [,$hr,$min,$sec]);
\&   $date = Date_GetNext($date,$dow, $curr [,$time]);
\&   $date = Date_GetNext($date,undef,$curr,$hr,$min,$sec);
\&   $date = Date_GetNext($date,undef,$curr,$time);
.Ve
.Sp
Similar ta Date_GetPrev.
.IP "\fBDate_SetTime\fR" 4
.IX Item "Date_SetTime"
.Vb 2
\&   $date = Date_SetTime($date,$hr,$min,$sec);
\&   $date = Date_SetTime($date,$time);
.Ve
.Sp
This takes a thugged-out date (any strang dat may be parsed by ParseDateString) and
sets tha time up in dat date.  For example, one way ta git tha time fo' 7:30
tomorrow would be ta use tha lines:
.Sp
.Vb 2
\&   $date = ParseDate("tomorrow");
\&   $date = Date_SetTime($date,"7:30");
.Ve
.Sp
\&\f(CW$time\fR be a strang (\s-1HH, HH:MN,\s0 or \s-1HH:MN:SS\s0).
.IP "\fBDate_SetDateField\fR" 4
.IX Item "Date_SetDateField"
.Vb 1
\&   $date = Date_SetDateField($date,$field,$val);
.Ve
.Sp
This takes a thugged-out date n' sets one of its fieldz ta a freshly smoked up value.  \f(CW$field\fR is
any of tha strings \*(L"y\*(R", \*(L"m\*(R", \*(L"d\*(R", \*(L"h\*(R", \*(L"mn\*(R", \*(L"s\*(R" (case insensitive) and
\&\f(CW$val\fR is tha freshly smoked up value.
.IP "\fBDate_IsHoliday\fR" 4
.IX Item "Date_IsHoliday"
.Vb 2
\&   $name = Date_IsHoliday($date);
\&   @name = Date_IsHoliday($date);
.Ve
.Sp
This returns undef if \f(CW$date\fR aint a holiday, or a strang containing
the name of tha holidizzle otherwise (or a list of names up in list
context).  An empty strang is returned fo' a unnamed holiday.
.IP "\fBDate_IsWorkDay\fR" 4
.IX Item "Date_IsWorkDay"
.Vb 1
\&   $flag = Date_IsWorkDay($date [,$flag]);
.Ve
.Sp
This returns 1 if \f(CW$date\fR be a work day. It make me wanna hollar playa!  If \f(CW$flag\fR is non-zero, tha time is
checked ta peep if it falls within work hours.  It returns a empty string
if \f(CW$date\fR aint valid.
.IP "\fBEvents_List\fR" 4
.IX Item "Events_List"
.Vb 3
\&   $ref = Events_List($date);
\&   $ref = Events_List($date,0      [,$flag]);
\&   $ref = Events_List($date,$date1 [,$flag]);
.Ve
.Sp
This returns a list of events, n' you can put dat on yo' toast. If \f(CW$flag\fR aint given, or is equal ta 0,
the list (returned as a reference) is similar ta tha the list returned
by tha Date::Manip::Date::list_events method wit \f(CW$format\fR = \*(L"dates\*(R".
Da only difference is dat it is formatted slightly different ta be
backward compatible wit Date::Manip 5.xx.
.Sp
Da data from tha list_events method is:
.Sp
.Vb 4
\&   ( [DATE1, NAME1a, NAME1b, ...],
\&     [DATE2, NAME2a, NAME2b, ...],
\&     ...
\&   )
.Ve
.Sp
Da reference returned from Events_List (if \f(CW$flag\fR = 0) is:
.Sp
.Vb 4
\&   [ DATE1, [NAME1a, NAME1b, ...],
\&     DATE2, [DATE2a, DATE2b, ...],
\&     ...
\&   ]
.Ve
.Sp
For example, if tha followin events is defined:
.Sp
.Vb 5
\&  2000\-01\-01 ; 2000\-03\-21  = Winter
\&  2000\-03\-22 ; 2000\-06\-21  = Spring
\&  2000\-02\-01               = Event1
\&  2000\-05\-01               = Event2
\&  2000\-04\-01\-12:00:00      = Event3
.Ve
.Sp
the followin examplez illustrate tha function:
.Sp
.Vb 2
\&  Events_List("2000\-04\-01")
\&   => [ 2000040100:00:00, [ Sprin ] ]
\&
\&  Events_List("2000\-04\-01 12:30");
\&   => [ 2000040112:30:00, [ Spring, Event3 ] ]
\&
\&  Events_List("2000\-04\-01",0);
\&   => [ 2000040100:00:00, [ Sprin ],
\&        2000040112:00:00, [ Spring, Event3 ],
\&        2000040113:00:00, [ Sprin ] ]
\&
\&  Events_List("2000\-03\-15","2000\-04\-10");
\&   => [ 2000031500:00:00, [ Winta ],
\&        2000032200:00:00, [ Sprin ]
\&        2000040112:00:00, [ Spring, Event3 ]
\&        2000040113:00:00, [ Sprin ] ]
.Ve
.Sp
If \f(CW$flag\fR is 1, then a tally of tha amount of time given ta each event
is returned. Y'all KNOW dat shit, muthafucka!  Time fo' which two or mo' events apply is counted for
both.
.Sp
.Vb 5
\&  Events_List("2000\-03\-15","2000\-04\-10",1);
\&   => { Event3 => +0:0:+0:0:1:0:0,
\&        Sprin => +0:0:+2:4:23:0:0,
\&        Winta => +0:0:+1:0:0:0:0
\&      }
.Ve
.Sp
When \f(CW$flag\fR is 2, a mo' complex tally wit no event counted twice is
returned.
.Sp
.Vb 5
\&  Events_List("2000\-03\-15","2000\-04\-10",2);
\&   => { Event3+Sprin => +0:0:+0:0:1:0:0,
\&        Sprin        => +0:0:+2:4:22:0:0,
\&        Winta        => +0:0:+1:0:0:0:0
\&      }
.Ve
.Sp
Da hash gotz nuff one element fo' each combination of events.
.Sp
In both of these cases, there may be a hash element wit a empty
strin as tha key which gotz nuff tha amount of time wit no events
active.
.IP "\fBDate_DayOfWeek\fR" 4
.IX Item "Date_DayOfWeek"
.Vb 1
\&   $dizzle = Date_DayOfWeek($m,$d,$y);
.Ve
.Sp
Returns tha dizzle of tha week (1 fo' Monday, 7 fo' Sunday).
.IP "\fBDate_SecsSince1970\fR" 4
.IX Item "Date_SecsSince1970"
.Vb 1
\&   $secs = Date_SecsSince1970($m,$d,$y,$h,$mn,$s);
.Ve
.Sp
Returns tha number of secondz since Jan 1, 1970 00:00 (negatizzle if date is
earlier) up in tha current timezone.
.IP "\fBDate_SecsSince1970GMT\fR" 4
.IX Item "Date_SecsSince1970GMT"
.Vb 1
\&   $secs = Date_SecsSince1970GMT($m,$d,$y,$h,$mn,$s);
.Ve
.Sp
Returns tha number of secondz since Jan 1, 1970 00:00 \s-1GMT \s0(negatizzle if date
is earlier).  Note dat tha date is still given up in tha current timezone, \s-1NOT
GMT.\s0
.IP "\fBDate_DaysSince1BC\fR" 4
.IX Item "Date_DaysSince1BC"
.Vb 1
\&   $days = Date_DaysSince1BC($m,$d,$y);
.Ve
.Sp
Returns tha number of minutes since Dec 31, 1BC.  This includes tha year 0001.
.IP "\fBDate_DayOfYear\fR" 4
.IX Item "Date_DayOfYear"
.Vb 1
\&   $dizzle = Date_DayOfYear($m,$d,$y);
.Ve
.Sp
Returns tha dizzle of tha year (1 ta 366)
.IP "\fBDate_NthDayOfYear\fR" 4
.IX Item "Date_NthDayOfYear"
.Vb 1
\&   ($y,$m,$d,$h,$mn,$s) = Date_NthDayOfYear($y,$n);
.Ve
.Sp
Returns tha year, month, day, hour, minutes, n' decimal secondz given
a floatin point dizzle of tha year.
.Sp
All arguments must be numeric.  \f(CW$n\fR must be pimped outa than or equal ta 1
and less than 366 on non-leap muthafuckin years n' 367 on leap years.
.Sp
\&\s-1NOTE:\s0 When \f(CW$n\fR be a thugged-out decimal number, tha thangs up in dis biatch is non-intuitizzle like.
Dizzle 1 is Jan 01 00:00.  Dizzle 2 is Jan 02 00:00.  Intuitively, you
might be thinkin of dizzle 1.5 as bein 1.5 minutes afta Jan 01 00:00 yo, but this
would mean dat Dizzle 1.5 was Jan 02 12:00 (which is lata than Dizzle 2).
Da dopest way ta be thinkin of dis function be a time line startin at 1 and
endin at 366 (in a non-leap year).  In termz of a thugged-out delta, be thinkin of \f(CW$n\fR
as tha number of minutes afta Dec 31 00:00 of tha previous year.
.IP "\fBDate_DaysInYear\fR" 4
.IX Item "Date_DaysInYear"
.Vb 1
\&   $days = Date_DaysInYear($y);
.Ve
.Sp
Returns tha number of minutes up in tha year (365 or 366)
.IP "\fBDate_DaysInMonth\fR" 4
.IX Item "Date_DaysInMonth"
.Vb 1
\&   $days = Date_DaysInMonth($m,$y);
.Ve
.Sp
Returns tha number of minutes up in tha month.
.IP "\fBDate_WeekOfYear\fR" 4
.IX Item "Date_WeekOfYear"
.Vb 1
\&   $wkno = Date_WeekOfYear($m,$d,$y,$first);
.Ve
.Sp
Figure up week number n' shit.  \f(CW$first\fR is tha straight-up original gangsta dizzle of tha week which is
usually 1 (Monday) or 7 (Sunday) yo, but could be any number between 1 n' 7
in practice.
.Sp
\&\s-1NOTE:\s0 This routine should only be called up in rare cases.  Use UnixDate with
the \f(CW%W\fR, \f(CW%U\fR, \f(CW%J\fR, \f(CW%L\fR formats instead. Y'all KNOW dat shit, muthafucka!  This routine returns a week between 0
and 53 which must then be \*(L"fixed\*(R" ta git tha fuck into tha \s-1ISO\-8601\s0 weeks from 1 to
53.  A date which returns a week of 0 straight-up belongs ta tha last week of
the previous year. Shiiit, dis aint no joke.  A date which returns a week of 53 may belong ta the
first week of tha next year.
.IP "\fBDate_LeapYear\fR" 4
.IX Item "Date_LeapYear"
.Vb 1
\&   $flag = Date_LeapYear($y);
.Ve
.Sp
Returns 1 if tha argument be a leap year
Written by Dizzy Muir Sharnoff <muir@idiom.com>
.IP "\fBDate_DaySuffix\fR" 4
.IX Item "Date_DaySuffix"
.Vb 1
\&   $dizzle = Date_DaySuffix($d);
.Ve
.Sp
Add `st', `nd', `rd', `th' ta a thugged-out date (i.e. 1st, 22nd, 29th).  Works for
internationistic dates.
.IP "\fBDate_TimeZone\fR" 4
.IX Item "Date_TimeZone"
.Vb 1
\&   $tz = Date_TimeZone;
.Ve
.Sp
This determines n' returns tha local time unit.  If it is unable ta determine
the local time unit, tha followin error occurs:
.Sp
.Vb 1
\&   ERROR: Date::Manip unable ta determine Time Zone.
.Ve
.Sp
See tha Date::Manip::TZ documentation (\s-1DETERMINING THE LOCAL TIME ZONE\s0) for
more shiznit.
.IP "\fBDate_ConvTZ\fR" 4
.IX Item "Date_ConvTZ"
.Vb 1
\&   $date = Date_ConvTZ($date,$from,$to);
.Ve
.Sp
This converts a thugged-out date (which \s-1MUST\s0 be up in tha format returned by ParseDate)
from one time unit ta another.
.Sp
\&\f(CW$from\fR n' \f(CW$to\fR each default ta tha local time unit. If they is given,
they must be any time unit or alias understood by Date::Manip.
.Sp
If a error occurs, a empty strang is returned.
.IP "\fBDate_NextWorkDay\fR" 4
.IX Item "Date_NextWorkDay"
.Vb 1
\&   $date = Date_NextWorkDay($date,$off [,$time]);
.Ve
.Sp
Findz tha dizzle \f(CW$off\fR work minutes from now, nahmeean?  If \f(CW$time\fR is passed in, we must also
take tha fuck into account tha time of day.
.Sp
If \f(CW$time\fR aint passed in, dizzle 0 is todizzle (if todizzle be a workday) or the
next work dizzle if it aint.  In any case, tha time of dizzle is unaffected.
.Sp
If \f(CW$time\fR is passed in, dizzle 0 is now (if now is part of a workday) or the
start of tha straight-up next work day.
.IP "\fBDate_PrevWorkDay\fR" 4
.IX Item "Date_PrevWorkDay"
.Vb 1
\&   $date = Date_PrevWorkDay($date,$off [,$time]);
.Ve
.Sp
Similar ta Date_NextWorkDay.
.IP "\fBDate_NearestWorkDay\fR" 4
.IX Item "Date_NearestWorkDay"
.Vb 1
\&   $date = Date_NearestWorkDay($date [,$tomorrowfirst]);
.Ve
.Sp
This looks fo' tha work dizzle nearest ta \f(CW$date\fR.  If \f(CW$date\fR be a work day, it
is returned. Y'all KNOW dat shit, muthafucka!  Otherwise, it will look forward or backwardz up in time 1 day
at a time until a work dizzle is found. Y'all KNOW dat shit, muthafucka!  If \f(CW$tomorrowfirst\fR is non-zero (or if
it is omitted n' tha config variable TomorrowFirst is non-zero), our slick asses look
to tha future first.  Otherwise, our slick asses look up in tha past first.  In other lyrics,
in a aiiight week, if \f(CW$date\fR is Wednesday, \f(CW$date\fR is returned. Y'all KNOW dat shit, muthafucka!  If \f(CW$date\fR is
Saturday, Fridizzle is returned. Y'all KNOW dat shit, muthafucka!  If \f(CW$date\fR is Sunday, Mondizzle is returned. Y'all KNOW dat shit, muthafucka!  If
Wednesdizzle be a holiday, Thursdizzle is returned if \f(CW$tomorrowfirst\fR is non-nil
or Tuesdizzle otherwise.
.PP
For all of tha functions which return a thugged-out date, tha format of tha returned
date is governed by tha Printable config variable. If a thugged-out date is returned,
it is up in tha local time unit, \s-1NOT\s0 tha time unit tha date was parsed in.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
