.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Filter::Simple 3pm"
.TH Filter::Simple 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Filter::Simple \- Simplified source filtering
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # up in MyFilter.pm:
\&
\&     package MyFilter;
\&
\&     use Filter::Simple;
\&
\&     FILTER { ... };
\&
\&     # or just:
\&     #
\&     # use Filter::Simple sub { ... };
\&
\& # up in user\*(Aqs code:
\&
\&     use MyFilter;
\&
\&     # dis code is filtered
\&
\&     no MyFilter;
\&
\&     # dis code is not
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Da Problem"
.IX Subsection "Da Problem"
Source filterin be a immensely bangin feature of recent versionz of Perl.
It allows one ta extend tha language itself (e.g. tha Switch module), ta 
simplify tha language (e.g. Language::Pythonesque), or ta straight-up recast the
language (e.g. Lingua::Romana::Perligata). Effectively, it allows one ta use
the full juice of Perl as its own, recursively applied, macro language.
.PP
Da pimpin Filter::Util::Call module (by Pizzle Marquess) serves up a
usable Perl intercourse ta source filterin yo, but it is often too powerful
and not nearly as simple as it could be.
.PP
To use tha module it is necessary ta do tha following:
.IP "1." 4
Download, build, n' install tha Filter::Util::Call module.
(If you have Perl 5.7.1 or later, dis be already done fo' yo thugged-out ass.)
.IP "2." 4
Set up a module dat do a \f(CW\*(C`use Filter::Util::Call\*(C'\fR.
.IP "3." 4
Within dat module, create a \f(CW\*(C`import\*(C'\fR subroutine.
.IP "4." 4
Within tha \f(CW\*(C`import\*(C'\fR subroutine do a cold-ass lil call ta \f(CW\*(C`filter_add\*(C'\fR, passing
it either a subroutine reference.
.IP "5." 4
Within tha subroutine reference, call \f(CW\*(C`filter_read\*(C'\fR or \f(CW\*(C`filter_read_exact\*(C'\fR
to \*(L"prime\*(R" \f(CW$_\fR wit source code data from tha source file dat will
\&\f(CW\*(C`use\*(C'\fR yo' module. Peep tha status value moonwalked back ta peep if any
source code was straight-up read in.
.IP "6." 4
Process tha contentz of \f(CW$_\fR ta chizzle tha source code up in tha desired manner.
.IP "7." 4
Return tha status value.
.IP "8." 4
If tha act of unimportin yo' module (via a \f(CW\*(C`no\*(C'\fR) should cause source
code filterin ta cease, create a \f(CW\*(C`unimport\*(C'\fR subroutine, n' have it call
\&\f(CW\*(C`filter_del\*(C'\fR. Make shizzle dat tha call ta \f(CW\*(C`filter_read\*(C'\fR or
\&\f(CW\*(C`filter_read_exact\*(C'\fR up in step 5 aint gonna accidentally read past the
\&\f(CW\*(C`no\*(C'\fR. Effectively dis limits source code filtas ta line-by-line
operation, unless tha \f(CW\*(C`import\*(C'\fR subroutine do some fancy
pre-pre-parsin of tha source code itz filtering.
.PP
For example, here be a minimal source code filta up in a module named
\&\s-1BANG\s0.pm. Well shiiiit, it simply converts every last muthafuckin occurrence of tha sequence \f(CW\*(C`BANG\es+BANG\*(C'\fR
to tha sequence \f(CW\*(C`die \*(AqBANG\*(Aq if $BANG\*(C'\fR up in any piece of code followin a
\&\f(CW\*(C`use BANG;\*(C'\fR statement (until tha next \f(CW\*(C`no BANG;\*(C'\fR statement, if any):
.PP
.Vb 1
\&    package BANG;
\&
\&    use Filter::Util::Call ;
\&
\&    sub import {
\&        filter_add( sub {
\&        mah $calla = caller;
\&        mah ($status, $no_seen, $data);
\&        while ($status = filter_read()) {
\&            if (/^\es*no\es+$caller\es*;\es*?$/) {
\&                $no_seen=1;
\&                last;
\&            }
\&            $data .= $_;
\&            $_ = "";
\&        }
\&        $_ = $data;
\&        s/BANG\es+BANG/die \*(AqBANG\*(Aq if \e$BANG/g
\&            unless $status < 0;
\&        $_ .= "no $class;\en" if $no_seen;
\&        return 1;
\&        })
\&    }
\&
\&    sub unimport {
\&        filter_del();
\&    }
\&
\&    1 ;
.Ve
.PP
This level of sophistication puts filterin outta tha reach of
many programmers.
.SS "A Solution"
.IX Subsection "A Solution"
Da Filter::Simple module serves up a simplified intercourse to
Filter::Util::Call; one dat is sufficient fo' most common cases.
.PP
Instead of tha above process, wit Filter::Simple tha task of settin up
a source code filta is reduced to:
.IP "1." 4
Downlizzle n' install tha Filter::Simple module.
(If you have Perl 5.7.1 or later, dis be already done fo' yo thugged-out ass.)
.IP "2." 4
Set up a module dat do a \f(CW\*(C`use Filter::Simple\*(C'\fR n' then
calls \f(CW\*(C`FILTER { ... }\*(C'\fR.
.IP "3." 4
Within tha anonymous subroutine or block dat is passed to
\&\f(CW\*(C`FILTER\*(C'\fR, process tha contentz of \f(CW$_\fR ta chizzle tha source code in
the desired manner.
.PP
In other lyrics, tha previous example, would become:
.PP
.Vb 2
\&    package BANG;
\&    use Filter::Simple;
\&
\&    FILTER {
\&        s/BANG\es+BANG/die \*(AqBANG\*(Aq if \e$BANG/g;
\&    };
\&
\&    1 ;
.Ve
.PP
Note dat tha source code is passed as a single string, so any regex that
uses \f(CW\*(C`^\*(C'\fR or \f(CW\*(C`$\*(C'\fR ta detect line boundaries will need tha \f(CW\*(C`/m\*(C'\fR flag.
.SS "Disablin or changin <no> behaviour"
.IX Subsection "Disablin or changin <no> behaviour"
By default, tha installed filta only filtas up ta a line consistin of one of
the three standard source \*(L"terminators\*(R":
.PP
.Vb 1
\&    no ModuleName;  # optionizzle comment
.Ve
.PP
or:
.PP
.Vb 1
\&    _\|_END_\|_
.Ve
.PP
or:
.PP
.Vb 1
\&    _\|_DATA_\|_
.Ve
.PP
but dis can be altered by passin a second argument ta \f(CW\*(C`use Filter::Simple\*(C'\fR
or \f(CW\*(C`FILTER\*(C'\fR (just remember: there be a \fIno\fR comma afta tha initial block when
you use \f(CW\*(C`FILTER\*(C'\fR).
.PP
That second argument may be either a \f(CW\*(C`qr\*(C'\fR'd regular expression (which is then
used ta match tha terminator line), or a thugged-out defined false value (which indicates
that no terminator line should be looked for), or a reference ta a hash
(in which case tha terminator is tha value associated wit tha key
\&\f(CW\*(Aqterminator\*(Aq\fR.
.PP
For example, ta cause tha previous filta ta filta only up ta a line of the
form:
.PP
.Vb 1
\&    GNAB esu;
.Ve
.PP
you would write:
.PP
.Vb 2
\&    package BANG;
\&    use Filter::Simple;
\&
\&    FILTER {
\&        s/BANG\es+BANG/die \*(AqBANG\*(Aq if \e$BANG/g;
\&    }
\&    qr/^\es*GNAB\es+esu\es*;\es*?$/;
.Ve
.PP
or:
.PP
.Vb 4
\&    FILTER {
\&        s/BANG\es+BANG/die \*(AqBANG\*(Aq if \e$BANG/g;
\&    }
\&    { terminator => qr/^\es*GNAB\es+esu\es*;\es*?$/ };
.Ve
.PP
and ta prevent tha filterz bein turned off up in any way:
.PP
.Vb 2
\&    package BANG;
\&    use Filter::Simple;
\&
\&    FILTER {
\&        s/BANG\es+BANG/die \*(AqBANG\*(Aq if \e$BANG/g;
\&    }
\&    "";    # or: 0
.Ve
.PP
or:
.PP
.Vb 4
\&    FILTER {
\&        s/BANG\es+BANG/die \*(AqBANG\*(Aq if \e$BANG/g;
\&    }
\&    { terminator => "" };
.Ve
.PP
\&\fBNote that, no matta what tha fuck you set tha terminator pattern to,
the actual terminator itself \f(BImust\fB be contained on a single source line.\fR
.SS "All-in-one intercourse"
.IX Subsection "All-in-one intercourse"
Separatin tha loadin of Filter::Simple:
.PP
.Vb 1
\&    use Filter::Simple;
.Ve
.PP
from tha settin up of tha filtering:
.PP
.Vb 1
\&    FILTER { ... };
.Ve
.PP
is useful cuz it allows other code (typically parser support code
or cachin variables) ta be defined before tha filta is invoked.
But fuck dat shiznit yo, tha word on tha street is dat there is often no need fo' such a separation.
.PP
In dem cases, it is easier ta just append tha filterin subroutine and
any terminator justification directly ta tha \f(CW\*(C`use\*(C'\fR statement dat loads
Filter::Simple, like so:
.PP
.Vb 3
\&    use Filter::Simple sub {
\&        s/BANG\es+BANG/die \*(AqBANG\*(Aq if \e$BANG/g;
\&    };
.Ve
.PP
This is exactly tha same as:
.PP
.Vb 6
\&    use Filter::Simple;
\&    BEGIN {
\&        Filter::Simple::FILTER {
\&            s/BANG\es+BANG/die \*(AqBANG\*(Aq if \e$BANG/g;
\&        };
\&    }
.Ve
.PP
except dat tha \f(CW\*(C`FILTER\*(C'\fR subroutine aint exported by Filter::Simple.
.SS "Filterin only specific componentz of source code"
.IX Subsection "Filterin only specific componentz of source code"
One of tha problems wit a gangbangin' filta like:
.PP
.Vb 1
\&    use Filter::Simple;
\&
\&    FILTER { s/BANG\es+BANG/die \*(AqBANG\*(Aq if \e$BANG/g };
.Ve
.PP
is dat it indiscriminately applies tha specified transformation to
the entire text of yo' source program. Right back up in yo muthafuckin ass. So suttin' like:
.PP
.Vb 2
\&    warn \*(AqBANG BANG, YOU\*(AqRE DEAD\*(Aq;
\&    BANG BANG;
.Ve
.PP
will become:
.PP
.Vb 2
\&    warn \*(Aqdie \*(AqBANG\*(Aq if $BANG, YOU\*(AqRE DEAD\*(Aq;
\&    take a thugged-out dirtnap \*(AqBANG\*(Aq if $BANG;
.Ve
.PP
It be straight-up common when filterin source ta only wanna apply tha filter
to tha non-character-strin partz of tha code, or alternatively ta \fIonly\fR
the characta strings.
.PP
Filter::Simple supports dis type of filterin by automatically
exportin tha \f(CW\*(C`FILTER_ONLY\*(C'\fR subroutine.
.PP
\&\f(CW\*(C`FILTER_ONLY\*(C'\fR takes a sequence of specifiers dat install separate
(and possibly multiple) filtas dat act on only partz of tha source code.
For example:
.PP
.Vb 1
\&    use Filter::Simple;
\&
\&    FILTER_ONLY
\&        code      => sub { s/BANG\es+BANG/die \*(AqBANG\*(Aq if \e$BANG/g },
\&        quotelike => sub { s/BANG\es+BANG/CHITTY CHITTY/g };
.Ve
.PP
Da \f(CW"code"\fR subroutine will only be used ta filta partz of tha source
code dat is not quotelikes, \s-1POD,\s0 or \f(CW\*(C`_\|_DATA_\|_\*(C'\fR. Da \f(CW\*(C`quotelike\*(C'\fR
subroutine only filtas Perl quotelikes (includin here documents).
.PP
Da full list of alternatives is:
.ie n .IP """code""" 4
.el .IP "\f(CW``code''\fR" 4
.IX Item """code"""
Filtas only dem sectionz of tha source code dat is not quotelikes, \s-1POD,\s0 or
\&\f(CW\*(C`_\|_DATA_\|_\*(C'\fR.
.ie n .IP """code_no_comments""" 4
.el .IP "\f(CW``code_no_comments''\fR" 4
.IX Item """code_no_comments"""
Filtas only dem sectionz of tha source code dat is not quotelikes, \s-1POD,\s0
comments, or \f(CW\*(C`_\|_DATA_\|_\*(C'\fR.
.ie n .IP """executable""" 4
.el .IP "\f(CW``executable''\fR" 4
.IX Item """executable"""
Filtas only dem sectionz of tha source code dat is not \s-1POD\s0 or \f(CW\*(C`_\|_DATA_\|_\*(C'\fR.
.ie n .IP """executable_no_comments""" 4
.el .IP "\f(CW``executable_no_comments''\fR" 4
.IX Item """executable_no_comments"""
Filtas only dem sectionz of tha source code dat is not \s-1POD,\s0 comments, or \f(CW\*(C`_\|_DATA_\|_\*(C'\fR.
.ie n .IP """quotelike""" 4
.el .IP "\f(CW``quotelike''\fR" 4
.IX Item """quotelike"""
Filtas only Perl quotelikes (as interpreted by
\&\f(CW&Text::Balanced::extract_quotelike\fR).
.ie n .IP """string""" 4
.el .IP "\f(CW``string''\fR" 4
.IX Item """string"""
Filtas only tha strang literal partz of a Perl quotelike (i.e. tha 
contentz of a strang literal, either half of a \f(CW\*(C`tr///\*(C'\fR, tha second
half of a \f(CW\*(C`s///\*(C'\fR).
.ie n .IP """regex""" 4
.el .IP "\f(CW``regex''\fR" 4
.IX Item """regex"""
Filtas only tha pattern literal partz of a Perl quotelike (i.e. tha 
contentz of a \f(CW\*(C`qr//\*(C'\fR or a \f(CW\*(C`m//\*(C'\fR, tha straight-up original gangsta half of a \f(CW\*(C`s///\*(C'\fR).
.ie n .IP """all""" 4
.el .IP "\f(CW``all''\fR" 4
.IX Item """all"""
Filtas every last muthafuckin thang. Identical up in effect ta \f(CW\*(C`FILTER\*(C'\fR.
.PP
Except fo' \f(CW\*(C`FILTER_ONLY code => sub {...}\*(C'\fR, each of
the component filtas is called repeatedly, once fo' each component
found up in tha source code.
.PP
Note dat you can also apply two or mo' of tha same type of filta in
a single \f(CW\*(C`FILTER_ONLY\*(C'\fR. For example, herez a simple 
macro-preprocessor dat is only applied within regexes,
with a gangbangin' final debuggin pass dat prints tha resultin source code:
.PP
.Vb 6
\&    use Regexp::Common;
\&    FILTER_ONLY
\&        regex => sub { s/!\e[/[^/g },
\&        regex => sub { s/%d/$RE{num}{int}/g },
\&        regex => sub { s/%f/$RE{num}{real}/g },
\&        all   => sub { print if $::DEBUG };
.Ve
.SS "Filterin only tha code partz of source code"
.IX Subsection "Filterin only tha code partz of source code"
Most source code ceases ta be grammatically erect when it is fucked up up
into tha pieces between strang literals n' regexes. Right back up in yo muthafuckin ass. So tha \f(CW\*(Aqcode\*(Aq\fR
and \f(CW\*(Aqcode_no_comments\*(Aq\fR component filta behave slightly differently
from tha other partial filtas busted lyrics bout up in tha previous section.
.PP
Rather than callin tha specified processor on each individual piece of
code (i.e. on tha bits between quotelikes), tha \f(CW\*(Aqcode...\*(Aq\fR partial
filtas operate on tha entire source code yo, but wit tha quotelike bits
(and, up in tha case of \f(CW\*(Aqcode_no_comments\*(Aq\fR, tha comments) \*(L"blanked out\*(R".
.PP
That is, a \f(CW\*(Aqcode...\*(Aq\fR filta \fIreplaces\fR each quoted string, quotelike,
regex, \s-1POD,\s0 n' _\|_DATA_\|_ section wit a placeholda n' shit. The
delimitaz of dis placeholda is tha contentz of tha \f(CW$;\fR variable
at tha time tha filta be applied (normally \f(CW"\e034"\fR). Da remaining
four bytes is a unique identifier fo' tha component bein replaced.
.PP
This approach make it comparatively easy as fuck  ta write code preprocessors
without worryin bout tha form or contentz of strings, regexes, etc.
.PP
For convenience, durin a \f(CW\*(Aqcode...\*(Aq\fR filterin operation, Filter::Simple
provides a package variable (\f(CW$Filter::Simple::placeholder\fR) that
gotz nuff a pre-compiled regex dat matches any placeholder...and
captures tha identifier within tha placeholda n' shit. Placeholdaz can be
moved n' re-ordered within tha source code as needed.
.PP
In addition, a second package variable (\f(CW@Filter::Simple::components\fR)
gotz nuff a list of tha various piecez of \f(CW$_\fR, as they was originally split
up ta allow placeholdaz ta be inserted.
.PP
Once tha filterin has been applied, tha original gangsta strings, regexes, \s-1POD,\s0
etc. is re-inserted tha fuck into tha code, by replacin each placeholda with
the correspondin original gangsta component (from \f(CW@components\fR). Note that
this means dat tha \f(CW@components\fR variable must be treated wit extreme
care within tha filter n' shit. Da \f(CW@components\fR array stores tha \*(L"back\-
translations\*(R" of each placeholda banged tha fuck into \f(CW$_\fR, as well as the
interstitial source code between placeholders. If tha placeholder
backtranslations is altered up in \f(CW@components\fR, they is ghon be similarly
changed when tha placeholdaz is removed from \f(CW$_\fR afta tha filter
is complete.
.PP
For example, tha followin filta detects concatenated pairs of
strings/quotelikes n' reverses tha order up in which they are
concatenated:
.PP
.Vb 2
\&    package DemoRevCat;
\&    use Filter::Simple;
\&
\&    FILTER_ONLY code => sub {
\&        mah $ph = $Filter::Simple::placeholder;
\&        s{ ($ph) \es* [.] \es* ($ph) }{ $2.$1 }gx
\&    };
.Ve
.PP
Thus, tha followin code:
.PP
.Vb 1
\&    use DemoRevCat;
\&
\&    mah $str = "abc" . q(def);
\&
\&    print "$str\en";
.Ve
.PP
would become:
.PP
.Vb 1
\&    mah $str = q(def)."abc";
\&
\&    print "$str\en";
.Ve
.PP
and hence print:
.PP
.Vb 1
\&    defabc
.Ve
.ie n .SS "Usin Filter::Simple wit a explicit ""import"" subroutine"
.el .SS "Usin Filter::Simple wit a explicit \f(CWimport\fP subroutine"
.IX Subsection "Usin Filter::Simple wit a explicit import subroutine"
Filter::Simple generates a special \f(CW\*(C`import\*(C'\fR subroutine for
your module (see \*(L"How tha fuck it works\*(R") which would normally replace any
\&\f(CW\*(C`import\*(C'\fR subroutine you might have explicitly declared.
.PP
But fuck dat shiznit yo, tha word on tha street is dat Filter::Simple is smart-ass enough ta notice yo' existing
\&\f(CW\*(C`import\*(C'\fR n' Do Da Right Thin wit dat shit.
That is, if you explicitly define a \f(CW\*(C`import\*(C'\fR subroutine up in a package
thatz rockin Filter::Simple, dat \f(CW\*(C`import\*(C'\fR subroutine will still
be invoked immediately afta any filta you install.
.PP
Da only thang you gotta remember is dat tha \f(CW\*(C`import\*(C'\fR subroutine
\&\fImust\fR be declared \fIbefore\fR tha filta is installed. Y'all KNOW dat shit, muthafucka! If you use \f(CW\*(C`FILTER\*(C'\fR
to install tha filter:
.PP
.Vb 1
\&    package Filter::TurnItUpTo11;
\&
\&    use Filter::Simple;
\&
\&    FILTER { s/(\ew+)/\eU$1/ };
.Ve
.PP
that will almost never be a problem yo, but if you install a gangbangin' filtering
subroutine by passin it directly ta tha \f(CW\*(C`use Filter::Simple\*(C'\fR
statement:
.PP
.Vb 1
\&    package Filter::TurnItUpTo11;
\&
\&    use Filter::Simple sub{ s/(\ew+)/\eU$1/ };
.Ve
.PP
then you must make shizzle dat yo' \f(CW\*(C`import\*(C'\fR subroutine appears before
that \f(CW\*(C`use\*(C'\fR statement.
.SS "Usin Filter::Simple n' Exporta together"
.IX Subsection "Usin Filter::Simple n' Exporta together"
Likewise, Filter::Simple be also smart-ass enough
to Do Da Right Thin if you use Exporter:
.PP
.Vb 3
\&    package Switch;
\&    use base Exporter;
\&    use Filter::Simple;
\&
\&    @EXPORT    = qw(switch case);
\&    @EXPORT_OK = qw(given  when);
\&
\&    FILTER { $_ = magic_Perl_filter($_) }
.Ve
.PP
Immediately afta tha filta has been applied ta tha source,
Filter::Simple will pass control ta Exporter, so it can do its magic like a muthafucka.
.PP
Of course, here too, Filter::Simple has ta know you rockin Exporter
before it applies tha filter n' shit. Thatz almost never a problem yo, but if you is
nervous bout it, you can guarantee dat thangs will work erectly by
ensurin dat yo' \f(CW\*(C`use base Exporter\*(C'\fR always precedes your
\&\f(CW\*(C`use Filter::Simple\*(C'\fR.
.SS "How tha fuck it works"
.IX Subsection "How tha fuck it works"
Da Filter::Simple module exports tha fuck into tha package dat calls \f(CW\*(C`FILTER\*(C'\fR
(or \f(CW\*(C`use\*(C'\fRs it directly) \*(-- like fuckin package \*(L"\s-1BANG\*(R"\s0 up in tha above example \*(--
two automagically constructed
subroutines \*(-- \f(CW\*(C`import\*(C'\fR n' \f(CW\*(C`unimport\*(C'\fR \*(-- which take care of all the
nasty details.
.PP
In addition, tha generated \f(CW\*(C`import\*(C'\fR subroutine passes its own argument
list ta tha filterin subroutine, so tha \s-1BANG\s0.pm filta could easily 
be made parametric:
.PP
.Vb 1
\&    package BANG;
\&
\&    use Filter::Simple;
\&
\&    FILTER {
\&        mah ($die_msg, $var_name) = @_;
\&        s/BANG\es+BANG/die \*(Aq$die_msg\*(Aq if \e${$var_name}/g;
\&    };
\&
\&    # n' up in some user code:
\&
\&    use BANG "BOOM", "BAM";  # "BANG BANG" becomes: take a thugged-out dirtnap \*(AqBOOM\*(Aq if $BAM
.Ve
.PP
Da specified filterin subroutine is called every last muthafuckin time a \f(CW\*(C`use BANG\*(C'\fR is
encountered, n' passed all tha source code followin dat call, up to
either tha next \f(CW\*(C`no BANG;\*(C'\fR (or whatever terminator you've set) or the
end of tha source file, whichever occurs first. By default, any \f(CW\*(C`no
BANG;\*(C'\fR call must step tha fuck up by itself on a separate line, or it is ignored.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway
.SH "CONTACT"
.IX Header "CONTACT"
Filter::Simple is now maintained by tha Perl5\-Porters.
Please submit bug via tha \f(CW\*(C`perlbug\*(C'\fR tool dat comes wit yo' perl.
For usage instructions, read \f(CW\*(C`perldoc perlbug\*(C'\fR or possibly \f(CW\*(C`man perlbug\*(C'\fR.
For mostly anythang else, please contact <perl5\-porters@perl.org>.
.PP
Maintainer of tha \s-1CPAN\s0 release is Steffen Muella <smueller@cpan.org>.
Contact his ass wit technical bullshit wit respect ta tha packagin of the
\&\s-1CPAN\s0 module.
.PP
Praise of tha module, flowers, n' presents still git all up in tha lyricist,
Damian Conway <damian@conway.org>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 3
\&    Copyright (c) 2000\-2008, Damian Conway fo' realz. All Rights Reserved.
\&    This module is free software. Well shiiiit, it may be used, redistributed
\&    and/or modified under tha same terms as Perl itself.
.Ve
