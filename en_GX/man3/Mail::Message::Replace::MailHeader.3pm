.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message::Replace::MailHeader 3"
.TH Mail::Message::Replace::MailHeader 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Replace::MailHeader \- fake Mail::Header
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\& Mail::Message::Replace::MailHeader
\&   be a Mail::Message::Head::Complete
\&   be a Mail::Message::Head
\&   be a Mail::Reporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& !!! ALPHA CODE !!!
\&
\& # chizzle
\& use Mail::Internet;
\& use Mail::Header;
\& # into
\& use Mail::Message::Replace::MailInternet;
\& # up in existin code, n' tha code should still work yo, but
\& # wit tha Mail::Message features.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module be a wrapper round a Mail::Message::Head::Complete,
which simulates a Mail::Header object.  Da name-space of dat module
is hijacked n' nuff methodz is added.
.PP
Most methodz will work without any chizzle yo, but you should test your
software again. I aint talkin' bout chicken n' gravy biatch.  Lil Small-Ass chizzlez done been made ta \fIfold_length()\fR,
\&\fIheader_hashref()\fR.
.SH "OVERLOADED"
.IX Header "OVERLOADED"
.ie n .IP "overload: \fB""""\fR()" 4
.el .IP "overload: \fB``''\fR()" 4
.IX Item "overload: """"()"
See \*(L"\s-1OVERLOADED\*(R"\s0 up in Mail::Message::Head
.IP "overload: \fBbool\fR()" 4
.IX Item "overload: bool()"
See \*(L"\s-1OVERLOADED\*(R"\s0 up in Mail::Message::Head
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBbuild\fR([PAIR|FIELD]\-LIST)" 4
.el .IP "\f(CW$obj\fR\->\fBbuild\fR([PAIR|FIELD]\-LIST)" 4
.IX Item "$obj->build([PAIR|FIELD]-LIST)"
See \*(L"Constructors\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBclone\fR([NAMES|ARRAY\-OF\-NAMES|REGEXS])" 4
.el .IP "\f(CW$obj\fR\->\fBclone\fR([NAMES|ARRAY\-OF\-NAMES|REGEXS])" 4
.IX Item "$obj->clone([NAMES|ARRAY-OF-NAMES|REGEXS])"
See \*(L"Constructors\*(R" up in Mail::Message::Head::Complete
.IP "Mail::Message::Replace::MailHeader\->\fBnew\fR([\s-1ARG\s0], \s-1OPTIONS\s0)" 4
.IX Item "Mail::Message::Replace::MailHeader->new([ARG], OPTIONS)"
Da \s-1ARG\s0 be a array wit header lines.
.Sp
.Vb 9
\& \-Option    \-\-Defined up in         \-\-Default
\&  FoldLength                       79
\&  MailFrom                         \*(AqKEEP\*(Aq
\&  Modify                           <false>
\&  field_type  Mail::Message::Head  Mail::Message::Field::Fast
\&  log         Mail::Reporta       \*(AqWARNINGS\*(Aq
\&  message     Mail::Message::Head  undef
\&  modified    Mail::Message::Head  <false>
\&  trace       Mail::Reporta       \*(AqWARNINGS\*(Aq
.Ve
.RS 4
.IP "FoldLength => \s-1INTEGER\s0" 2
.IX Item "FoldLength => INTEGER"
.PD 0
.IP "MailFrom => '\s-1IGNORE\s0'|'\s-1ERROR\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'" 2
.IX Item "MailFrom => 'IGNORE'|'ERROR'|'COERCE'|'KEEP'"
.PD
How tha fuck ta handle tha \f(CW\*(C`From \*(C'\fR lines.  See \fImail_from()\fR.
.IP "Modify => \s-1BOOLEAN\s0" 2
.IX Item "Modify => BOOLEAN"
Reformat all header lines when they come in: chizzle tha folding.
.IP "field_type => \s-1CLASS\s0" 2
.IX Item "field_type => CLASS"
.PD 0
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.IP "message => \s-1MESSAGE\s0" 2
.IX Item "message => MESSAGE"
.IP "modified => \s-1BOOLEAN\s0" 2
.IX Item "modified => BOOLEAN"
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.RE
.RS 4
.RE
.PD
.SS "Da header"
.IX Subsection "Da header"
.ie n .IP "$obj\->\fBisDelayed\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDelayed\fR()" 4
.IX Item "$obj->isDelayed()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBisEmpty\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisEmpty\fR()" 4
.IX Item "$obj->isEmpty()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBisModified\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisModified\fR()" 4
.IX Item "$obj->isModified()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBknownNames\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBknownNames\fR()" 4
.IX Item "$obj->knownNames()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBmessage\fR([\s-1MESSAGE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmessage\fR([\s-1MESSAGE\s0])" 4
.IX Item "$obj->message([MESSAGE])"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.IX Item "$obj->modified([BOOLEAN])"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBnrLines\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnrLines\fR()" 4
.IX Item "$obj->nrLines()"
See \*(L"Da header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBorderedFields\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBorderedFields\fR()" 4
.IX Item "$obj->orderedFields()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBsize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsize\fR()" 4
.IX Item "$obj->size()"
See \*(L"Da header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBwrap\fR(\s-1INTEGER\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBwrap\fR(\s-1INTEGER\s0)" 4
.IX Item "$obj->wrap(INTEGER)"
See \*(L"Da header\*(R" up in Mail::Message::Head::Complete
.SS "Access ta tha header"
.IX Subsection "Access ta tha header"
.ie n .IP "$obj\->\fBadd\fR(\s-1LINE,\s0 [\s-1INDEX\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(\s-1LINE,\s0 [\s-1INDEX\s0])" 4
.IX Item "$obj->add(LINE, [INDEX])"
Add a header line, which simply calls \f(CW\*(C`Mail::Message::Head::add()\*(C'\fR on
the header fo' tha specified \s-1LINE. \s0 Da \s-1INDEX\s0 is ignored, tha unfolded
body of tha field is returned.
.ie n .IP "$obj\->\fBaddListGroup\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddListGroup\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addListGroup(OBJECT)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBaddResentGroup\fR(RESENT\-GROUP|DATA)" 4
.el .IP "\f(CW$obj\fR\->\fBaddResentGroup\fR(RESENT\-GROUP|DATA)" 4
.IX Item "$obj->addResentGroup(RESENT-GROUP|DATA)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBaddSpamGroup\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddSpamGroup\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addSpamGroup(OBJECT)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBcount\fR(\s-1NAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcount\fR(\s-1NAME\s0)" 4
.IX Item "$obj->count(NAME)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBdelete\fR(\s-1TAG,\s0 [\s-1INDEX\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1TAG,\s0 [\s-1INDEX\s0])" 4
.IX Item "$obj->delete(TAG, [INDEX])"
Delete tha fieldz wit tha specified \s-1TAG. \s0 Da deleted fieldz are
returned. Y'all KNOW dat shit, muthafucka!  If no index is given, then all is removed.
.ie n .IP "$obj\->\fBget\fR(\s-1NAME,\s0 [\s-1INDEX\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR(\s-1NAME,\s0 [\s-1INDEX\s0])" 4
.IX Item "$obj->get(NAME, [INDEX])"
Git all tha header fieldz wit tha specified \s-1NAME. \s0 In scalar context,
only tha straight-up original gangsta fittin \s-1NAME\s0 is returned. Y'all KNOW dat shit, muthafucka!  Even when only one \s-1NAME\s0 is
specified, multiple lines may be returned up in list context: some fields
appear mo' than once up in a header.
.ie n .IP "$obj\->\fBgrepNames\fR([NAMES|ARRAY\-OF\-NAMES|REGEXS])" 4
.el .IP "\f(CW$obj\fR\->\fBgrepNames\fR([NAMES|ARRAY\-OF\-NAMES|REGEXS])" 4
.IX Item "$obj->grepNames([NAMES|ARRAY-OF-NAMES|REGEXS])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBlistGroup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlistGroup\fR()" 4
.IX Item "$obj->listGroup()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBnames\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnames\fR()" 4
.IX Item "$obj->names()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBprintSelected\fR(\s-1FILEHANDLE, \s0(STRING|REGEXP)s)" 4
.el .IP "\f(CW$obj\fR\->\fBprintSelected\fR(\s-1FILEHANDLE, \s0(STRING|REGEXP)s)" 4
.IX Item "$obj->printSelected(FILEHANDLE, (STRING|REGEXP)s)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBprintUndisclosed\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprintUndisclosed\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->printUndisclosed([FILEHANDLE])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBremoveContentInfo\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBremoveContentInfo\fR()" 4
.IX Item "$obj->removeContentInfo()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBremoveField\fR(\s-1FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBremoveField\fR(\s-1FIELD\s0)" 4
.IX Item "$obj->removeField(FIELD)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBremoveFields\fR(STRING|REGEXP, [STRING|REGEXP, ...])" 4
.el .IP "\f(CW$obj\fR\->\fBremoveFields\fR(STRING|REGEXP, [STRING|REGEXP, ...])" 4
.IX Item "$obj->removeFields(STRING|REGEXP, [STRING|REGEXP, ...])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBremoveFieldsExcept\fR(STRING|REGEXP, [STRING|REGEXP, ...])" 4
.el .IP "\f(CW$obj\fR\->\fBremoveFieldsExcept\fR(STRING|REGEXP, [STRING|REGEXP, ...])" 4
.IX Item "$obj->removeFieldsExcept(STRING|REGEXP, [STRING|REGEXP, ...])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBremoveListGroup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBremoveListGroup\fR()" 4
.IX Item "$obj->removeListGroup()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBremoveResentGroups\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBremoveResentGroups\fR()" 4
.IX Item "$obj->removeResentGroups()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBremoveSpamGroups\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBremoveSpamGroups\fR()" 4
.IX Item "$obj->removeSpamGroups()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBreplace\fR(\s-1TAG, LINE,\s0 [\s-1INDEX\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreplace\fR(\s-1TAG, LINE,\s0 [\s-1INDEX\s0])" 4
.IX Item "$obj->replace(TAG, LINE, [INDEX])"
Replace tha field named \s-1TAG.\s0 from place \s-1INDEX \s0(by default tha first) by
the \s-1LINE. \s0 When \s-1TAG\s0 is \f(CW\*(C`undef\*(C'\fR, it is ghon be extracted from tha \s-1LINE\s0 first.
This calls \fIMail::Message::Head::Complete::reset()\fR on tha messagez head.
.ie n .IP "$obj\->\fBresentGroups\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBresentGroups\fR()" 4
.IX Item "$obj->resentGroups()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBreset\fR(\s-1NAME, FIELDS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBreset\fR(\s-1NAME, FIELDS\s0)" 4
.IX Item "$obj->reset(NAME, FIELDS)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBset\fR(\s-1FIELD\s0 | \s-1LINE\s0 | (\s-1NAME, BODY\s0 [,ATTRS]))" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1FIELD\s0 | \s-1LINE\s0 | (\s-1NAME, BODY\s0 [,ATTRS]))" 4
.IX Item "$obj->set(FIELD | LINE | (NAME, BODY [,ATTRS]))"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBspamDetected\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBspamDetected\fR()" 4
.IX Item "$obj->spamDetected()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBspamGroups\fR([\s-1NAMES\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBspamGroups\fR([\s-1NAMES\s0])" 4
.IX Item "$obj->spamGroups([NAMES])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBstring\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstring\fR()" 4
.IX Item "$obj->string()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBstudy\fR(\s-1NAME\s0 [,INDEX])" 4
.el .IP "\f(CW$obj\fR\->\fBstudy\fR(\s-1NAME\s0 [,INDEX])" 4
.IX Item "$obj->study(NAME [,INDEX])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head
.SS "Bout tha body"
.IX Subsection "Bout tha body"
.ie n .IP "$obj\->\fBguessBodySize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBguessBodySize\fR()" 4
.IX Item "$obj->guessBodySize()"
See \*(L"Bout tha body\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBguessTimeStamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBguessTimeStamp\fR()" 4
.IX Item "$obj->guessTimeStamp()"
See \*(L"Bout tha body\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBisMultipart\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisMultipart\fR()" 4
.IX Item "$obj->isMultipart()"
See \*(L"Bout tha body\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBrecvstamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBrecvstamp\fR()" 4
.IX Item "$obj->recvstamp()"
See \*(L"Bout tha body\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBtimestamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtimestamp\fR()" 4
.IX Item "$obj->timestamp()"
See \*(L"Bout tha body\*(R" up in Mail::Message::Head::Complete
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBaddNoRealize\fR(\s-1FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddNoRealize\fR(\s-1FIELD\s0)" 4
.IX Item "$obj->addNoRealize(FIELD)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBaddOrderedFields\fR(\s-1FIELDS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddOrderedFields\fR(\s-1FIELDS\s0)" 4
.IX Item "$obj->addOrderedFields(FIELDS)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBcreateFromLine\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcreateFromLine\fR()" 4
.IX Item "$obj->createFromLine()"
See \*(L"Internals\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBcreateMessageId\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcreateMessageId\fR()" 4
.IX Item "$obj->createMessageId()"
See \*(L"Internals\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBfileLocation\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfileLocation\fR()" 4
.IX Item "$obj->fileLocation()"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBload\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBload\fR()" 4
.IX Item "$obj->load()"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBmessageIdPrefix\fR([\s-1PREFIX,\s0 [\s-1HOSTNAME\s0]|CODE])" 4
.el .IP "\f(CW$obj\fR\->\fBmessageIdPrefix\fR([\s-1PREFIX,\s0 [\s-1HOSTNAME\s0]|CODE])" 4
.IX Item "$obj->messageIdPrefix([PREFIX, [HOSTNAME]|CODE])"
.PD 0
.IP "Mail::Message::Replace::MailHeader\->\fBmessageIdPrefix\fR([\s-1PREFIX,\s0 [\s-1HOSTNAME\s0]|CODE])" 4
.IX Item "Mail::Message::Replace::MailHeader->messageIdPrefix([PREFIX, [HOSTNAME]|CODE])"
.PD
See \*(L"Internals\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBmoveLocation\fR(\s-1DISTANCE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBmoveLocation\fR(\s-1DISTANCE\s0)" 4
.IX Item "$obj->moveLocation(DISTANCE)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBsetNoRealize\fR(\s-1FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBsetNoRealize\fR(\s-1FIELD\s0)" 4
.IX Item "$obj->setNoRealize(FIELD)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Message::Replace::MailHeader\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Message::Replace::MailHeader->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Message::Replace::MailHeader\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Message::Replace::MailHeader->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Message::Replace::MailHeader\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Message::Replace::MailHeader->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SS "Access ta tha header"
.IX Subsection "Access ta tha header"
.SS "Simulatin Mail::Header"
.IX Subsection "Simulatin Mail::Header"
.ie n .IP "$obj\->\fBas_string\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBas_string\fR()" 4
.IX Item "$obj->as_string()"
Returns tha whole header as one big-ass scalar.
Calls \fIMail::Message::Head::Complete::string()\fR.
.ie n .IP "$obj\->\fBcleanup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcleanup\fR()" 4
.IX Item "$obj->cleanup()"
Cleanup memory usage.  Not needed here.
.ie n .IP "$obj\->\fBcombine\fR(\s-1TAG,\s0 [\s-1WITH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBcombine\fR(\s-1TAG,\s0 [\s-1WITH\s0])" 4
.IX Item "$obj->combine(TAG, [WITH])"
I do not peep any valid reason fo' dis command, so did not implement dat shit.
.ie n .IP "$obj\->\fBdup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdup\fR()" 4
.IX Item "$obj->dup()"
Duplicate tha header, which is simply \fIclone()\fR.
.ie n .IP "$obj\->\fBempty\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBempty\fR()" 4
.IX Item "$obj->empty()"
Clean-out tha whole hash. Betta not use dis (simply create another
header object), although it should work.
.ie n .IP "$obj\->\fBexists\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBexists\fR()" 4
.IX Item "$obj->exists()"
Returns whether there be any fields.
.ie n .IP "$obj\->\fBextract\fR(\s-1ARRAY\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBextract\fR(\s-1ARRAY\s0)" 4
.IX Item "$obj->extract(ARRAY)"
Extract (and remove) header fieldz from tha array.
.ie n .IP "$obj\->\fBfold\fR([\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold\fR([\s-1LENGTH\s0])" 4
.IX Item "$obj->fold([LENGTH])"
Refold all fieldz up in tha header, ta \s-1LENGTH\s0 or whatever \fIfold_length()\fR
returns.
.ie n .IP "$obj\->\fBfold_length\fR([[\s-1TAG\s0], \s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold_length\fR([[\s-1TAG\s0], \s-1LENGTH\s0])" 4
.IX Item "$obj->fold_length([[TAG], LENGTH])"
Returns tha line wrap, optionally afta settin it ta \s-1LENGTH. \s0 The
old value is returned. Y'all KNOW dat shit, muthafucka!  Da \s-1TAG\s0 argument is ignored, cuz it is
silly ta have different lines fold up in different ways.  This method
cannot be called statically no mo'.
.ie n .IP "$obj\->\fBheader\fR([\s-1ARRAY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBheader\fR([\s-1ARRAY\s0])" 4
.IX Item "$obj->header([ARRAY])"
Extract tha fieldz from tha \s-1ARRAY,\s0 if specified, n' then fold tha fields.
Returned be a array wit all fields, produced via \fIorderedFields()\fR.
.ie n .IP "$obj\->\fBheader_hashref\fR(\s-1HASH\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBheader_hashref\fR(\s-1HASH\s0)" 4
.IX Item "$obj->header_hashref(HASH)"
If yo ass is rockin dis method, you must be fuckin wack... anyway: I do not want to
support it fo' now: use \fIadd()\fR n' playas.
.ie n .IP "$obj\->\fBmail_from\fR(['\s-1IGNORE\s0'|'\s-1ERROR\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'])" 4
.el .IP "\f(CW$obj\fR\->\fBmail_from\fR(['\s-1IGNORE\s0'|'\s-1ERROR\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'])" 4
.IX Item "$obj->mail_from(['IGNORE'|'ERROR'|'COERCE'|'KEEP'])"
What ta do when a header line up in tha form `From ' is encountered. Y'all KNOW dat shit, muthafucka! Valid
values is \f(CW\*(C`IGNORE\*(C'\fR \- ignore n' discard tha header, \f(CW\*(C`ERROR\*(C'\fR \- invoke
an error (call die), \f(CW\*(C`COERCE\*(C'\fR \- rename dem as Mail-From n' \f(CW\*(C`KEEP\*(C'\fR
\&\- keep em.
.ie n .IP "$obj\->\fBmodify\fR([\s-1BOOLEAN\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmodify\fR([\s-1BOOLEAN\s0])" 4
.IX Item "$obj->modify([BOOLEAN])"
Refold tha headaz when they is added.
.ie n .IP "$obj\->\fBread\fR(\s-1FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR(\s-1FILE\s0)" 4
.IX Item "$obj->read(FILE)"
Read tha header from tha \s-1FILE.\s0
.ie n .IP "$obj\->\fBtags\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtags\fR()" 4
.IX Item "$obj->tags()"
Returns all tha namez of fields, implemented by
\&\fIMail::Message::Head::Complete::names()\fR.
.ie n .IP "$obj\->\fBunfold\fR([\s-1TAG\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBunfold\fR([\s-1TAG\s0])" 4
.IX Item "$obj->unfold([TAG])"
Remove tha foldin fo' all instancez of \s-1TAG,\s0 or all fieldz at once.
.SS "Da nasty bits"
.IX Subsection "Da nasty bits"
.ie n .IP "$obj\->\fBisa\fR(\s-1CLASS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBisa\fR(\s-1CLASS\s0)" 4
.IX Item "$obj->isa(CLASS)"
.PD 0
.IP "Mail::Message::Replace::MailHeader\->\fBisa\fR(\s-1CLASS\s0)" 4
.IX Item "Mail::Message::Replace::MailHeader->isa(CLASS)"
.PD
Of course, tha \f(CW\*(C`isa()\*(C'\fR class inheritizzle check should not peep our
nasty trick.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Warning: Cannot remove field $name from header: not found." 4
.el .IP "Warning: Cannot remove field \f(CW$name\fR from header: not found." 4
.IX Item "Warning: Cannot remove field $name from header: not found."
Yo ass ask ta remove a gangbangin' field which aint known up in tha header n' shit.  Using
\&\fIdelete()\fR, \fIreset()\fR, or \fIset()\fR ta do tha thang aint gonna result
in warnings: dem methodz check tha existence of tha field first.
.IP "Warning: Field objects have a implied name ($name)" 4
.IX Item "Warning: Field objects have a implied name ($name)"
.PD 0
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
.PD
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
