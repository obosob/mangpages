.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "version::Internals 3"
.TH version::Internals 3 "2014-01-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
version::Internals \- Perl extension fo' Version Objects
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Overloaded version objects fo' all modern versionz of Perl.  This documents
the internal data representation n' underlyin code fo' version.pm.  See
\&\fIversion.pod\fR fo' everyday usage.  This document is only useful fo' users
horny bout tha gory details.
.SH "WHAT IS A VERSION?"
.IX Header "WHAT IS A VERSION?"
For tha purposez of dis module, a version \*(L"number\*(R" be a sequence of
positizzle integer joints separated by one or mo' decimal points and
optionally a single underscore.  This correspondz ta what tha fuck Perl itself
uses fo' a version, as well as extendin tha \*(L"version as number\*(R" that
is discussed up in tha various editionz of tha Camel book.
.PP
There is straight-up two distinct kindz of version objects:
.IP "Decimal Versions" 4
.IX Item "Decimal Versions"
Any version which \*(L"looks like a number\*(R", peep \*(L"Decimal Versions\*(R".  This
also includes versions wit a single decimal point n' a single embedded
underscore, peep \*(L"Alpha Versions\*(R", even though these must be quoted
to preserve tha underscore formatting.
.IP "Dotted-Decimal Versions" 4
.IX Item "Dotted-Decimal Versions"
Also referred ta as \*(L"Dotted-Integer\*(R", these gotz nuff mo' than one decimal
point n' may have a optionizzle embedded underscore, peep Dotted-Decimal
Versions.  This is what tha fuck is commonly used up in most open source software as
the \*(L"external\*(R" version (the one used as part of tha tag or tarfile name).
A leadin 'v' characta is now required n' will warn if it missing.
.PP
Both of these methodz will produce similar version objects, up in that
the default stringification will yield tha version \*(L"Normal Form\*(R" only
if required:
.PP
.Vb 3
\&  $v  = version\->new(1.002);     # 1.002 yo, but compares like 1.2.0
\&  $v  = version\->new(1.002003);  # 1.002003
\&  $v2 = version\->new("v1.2.3");  # v1.2.3
.Ve
.PP
In specific, version numbers initialized as \*(L"Decimal Versions\*(R" will
stringify as they was originally pimped (i.e. tha same strang dat was
passed ta \f(CW\*(C`new()\*(C'\fR.  Version numbers initialized as \*(L"Dotted-Decimal Versions\*(R"
will be stringified as \*(L"Normal Form\*(R".
.SS "Decimal Versions"
.IX Subsection "Decimal Versions"
These correspond ta oldschool versionz of Perl itself prior ta 5.6.0,
as well as all other modulez which follow tha Camel rulez fo' the
\&\f(CW$VERSION\fR scalar. Shiiit, dis aint no joke.  A Decimal version is initialized wit what tha fuck looks like
a floatin point number n' shit.  Leadin zeros \fBare\fR dope n' trailing
zeros is implied so dat a minimum of three places is maintained
between subversions.  What dis means is dat any subversion (digits
to tha right of tha decimal place) dat gotz nuff less than three digits
will have trailin zeros added ta make up tha difference yo, but only for
purposez of comparison wit other version objects, n' you can put dat on yo' toast.  For example:
.PP
.Vb 7
\&                                   # Prints     Equivalent to
\&  $v = version\->new(      1.2);    # 1.2        v1.200.0
\&  $v = version\->new(     1.02);    # 1.02       v1.20.0
\&  $v = version\->new(    1.002);    # 1.002      v1.2.0
\&  $v = version\->new(   1.0023);    # 1.0023     v1.2.300
\&  $v = version\->new(  1.00203);    # 1.00203    v1.2.30
\&  $v = version\->new( 1.002003);    # 1.002003   v1.2.3
.Ve
.PP
All of tha precedin examplez is legit whether or not tha input value is
quoted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da blingin feature is dat tha input value gotz nuff only a
single decimal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See also \*(L"Alpha Versions\*(R".
.PP
\&\s-1IMPORTANT NOTE:\s0 As shown above, if yo' Decimal version gotz nuff more
than 3 dope digits afta tha decimal place, it is ghon be split on
each multiple of 3, so 1.0003 is equivalent ta v1.0.300, cuz of tha need
to remain compatible wit Perlz own 5.005_03 == 5.5.30 interpretation.
Any trailin zeros is ignored fo' mathematical comparison purposes.
.SS "Dotted-Decimal Versions"
.IX Subsection "Dotted-Decimal Versions"
These is tha newest form of versions, n' correspond ta Perlz own
version steez beginnin wit 5.6.0.  Startin wit Perl 5.10.0,
and most likely Perl 6, dis is likely ta be tha preferred form.  This
method normally requires dat tha input parameta be quoted, although
Perlz afta 5.8.1 can use v\-strings as a special form of quotin yo, but
this is highly discouraged.
.PP
Unlike \*(L"Decimal Versions\*(R", Dotted-Decimal Versions have mo' than
a single decimal point, e.g.:
.PP
.Vb 6
\&                                   # Prints
\&  $v = version\->new( "v1.200");    # v1.200.0
\&  $v = version\->new("v1.20.0");    # v1.20.0
\&  $v = qv("v1.2.3");               # v1.2.3
\&  $v = qv("1.2.3");                # v1.2.3
\&  $v = qv("1.20");                 # v1.20.0
.Ve
.PP
In general, Dotted-Decimal Versions permit tha top billin amount of freedom
to specify a version, whereas Decimal Versions enforce a cold-ass lil certain
uniformity.
.PP
Just like \*(L"Decimal Versions\*(R", Dotted-Decimal Versions can be used as
\&\*(L"Alpha Versions\*(R".
.SS "Alpha Versions"
.IX Subsection "Alpha Versions"
For module authors rockin \s-1CPAN,\s0 tha convention has been ta note unstable
releases wit a underscore up in tha version string. (See \s-1CPAN\s0.)  version.pm
bigs up dis convention n' alpha releases will test as bein newer than the
more recent stable release, n' less than tha next stable release.  Only the
last element may be separated by a underscore:
.PP
.Vb 2
\&  # Declaring
\&  use version 0.77; our $VERSION = version\->declare("v1.2_3");
\&
\&  # Parsing
\&  $v1 = version\->parse("v1.2_3");
\&  $v1 = version\->parse("1.002_003");
.Ve
.PP
Note dat you \fBmust\fR quote tha version when freestylin a alpha Decimal version.
Da stringified form of Decimal versions will always be tha same strang that
was used ta initialize tha version object.
.SS "Regular Expressions fo' Version Parsing"
.IX Subsection "Regular Expressions fo' Version Parsing"
A formalized definizzle of tha legal forms fo' version strings is
included up in tha \f(CW\*(C`version::regex\*(C'\fR class.  Primitives is included for
common elements, although they is scoped ta tha file so they is useful
for reference purposes only.  There is two publicly accessible scalars
that can be used up in other code (not exported):
.ie n .IP "$version::LAX" 4
.el .IP "\f(CW$version::LAX\fR" 4
.IX Item "$version::LAX"
This regexp covers all of tha legal forms allowed under tha current
version strang parser n' shit.  This aint ta say dat all of these forms
are recommended, n' a shitload of dem can only be used when quoted.
.Sp
For dotted decimals:
.Sp
.Vb 3
\&    v1.2
\&    1.2345.6
\&    v1.23_4
.Ve
.Sp
Da leadin 'v' is optionizzle if two or mo' decimals appear. Shiiit, dis aint no joke.  If only
a single decimal is included, then tha leadin 'v' is required to
trigger tha dotted-decimal parsing.  A leadin zero is permitted,
though not recommended except when quoted, cuz of tha risk that
Perl will treat tha number as octal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  A trailin underscore plus one
or mo' digits denotes a alpha or pimpment release (and must be
quoted ta be parsed properly).
.Sp
For decimal versions:
.Sp
.Vb 3
\&    1
\&    1.2345
\&    1.2345_01
.Ve
.Sp
an integer portion, a optionizzle decimal point, n' optionally one or
more digits ta tha right of tha decimal is all required. Y'all KNOW dat shit, muthafucka!  A trailing
underscore is permitted n' a leadin zero is permitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Just like
the lax dotted-decimal version, quotin tha joints is required for
alpha/development forms ta be parsed erectly.
.ie n .IP "$version::STRICT" 4
.el .IP "\f(CW$version::STRICT\fR" 4
.IX Item "$version::STRICT"
This regexp covers a much mo' limited set of formats n' constitutes
the dopest practices fo' initializin version objects, n' you can put dat on yo' toast.  Whether you chizzle
to employ decimal or dotted-decimal fo' be a underground preference however.
.RS 4
.IP "v1.234.5" 4
.IX Item "v1.234.5"
For dotted-decimal versions, a leadin 'v' is required, wit three or
more sub-versionz of no mo' than three digits, n' you can put dat on yo' toast.  A leadin 0 (zero)
before tha straight-up original gangsta sub-version (in tha above example, '1') be also
prohibited.
.IP "2.3456" 4
.IX Item "2.3456"
For decimal versions, a integer portion (no leadin 0), a thugged-out decimal point,
and one or mo' digits ta tha right of tha decimal is all required.
.RE
.RS 4
.RE
.PP
Both of tha provided scalars is already compiled as regular expressions
and do not contain either anchors or implicit groupings, so they can be
included up in yo' own regular expressions freely.  For example, consider
the followin code:
.PP
.Vb 6
\&        ($pkg, $ver) =~ /
\&                ^[ \et]*
\&                use [ \et]+($PKGNAME)
\&                (?:[ \et]+($version::STRICT))?
\&                [ \et]*;
\&        /x;
.Ve
.PP
This would match a line of tha form:
.PP
.Vb 1
\&        use Foo::Bar::Baz v1.2.3;       # legal only up in Perl 5.8.1+
.Ve
.PP
where \f(CW$PKGNAME\fR be another regular expression dat defines tha legal
forms fo' package names.
.SH "IMPLEMENTATION DETAILS"
.IX Header "IMPLEMENTATION DETAILS"
.SS "Equivalence between Decimal n' Dotted-Decimal Versions"
.IX Subsection "Equivalence between Decimal n' Dotted-Decimal Versions"
When Perl 5.6.0 was busted out, tha decision was made ta provide a
transformation between tha old-style decimal versions n' new-style
dotted-decimal versions:
.PP
.Vb 2
\&  5.6.0    == 5.006000
\&  5.005_04 == 5.5.40
.Ve
.PP
Da floatin point number is taken n' split first on tha single decimal
place, then each crew of three digits ta tha right of tha decimal make up
the next digit, n' so on until tha number of dope digits is exhausted,
\&\fBplus\fR enough trailin zeros ta reach tha next multiple of three.
.PP
This was tha method dat version.pm adopted as well.  Some examplez may be
helpful:
.PP
.Vb 9
\&                            equivalent
\&  decimal    zero\-padded    dotted\-decimal
\&  \-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  1.2        1.200          v1.200.0
\&  1.02       1.020          v1.20.0
\&  1.002      1.002          v1.2.0
\&  1.0023     1.002300       v1.2.300
\&  1.00203    1.002030       v1.2.30
\&  1.002003   1.002003       v1.2.3
.Ve
.SS "Quotin Rules"
.IX Subsection "Quotin Rules"
Because of tha nature of tha Perl parsin n' tokenizin routines,
certain initialization joints \fBmust\fR be quoted up in order ta erectly
parse as tha intended version, especially when rockin tha \f(CW\*(C`declare\*(C'\fR or
\&\*(L"\fIqv()\fR\*(R" methods.  While you do not gotta quote decimal numbers when
bustin version objects, it be always safe ta quote \fBall\fR initial joints
when rockin version.pm methods, as dis will ensure dat what tha fuck you type is
what is used.
.PP
Additionally, if you quote yo' initializer, then tha quoted value dat goes
\&\fBin\fR is ghon be exactly what tha fuck comes \fBout\fR when yo' \f(CW$VERSION\fR is printed
(stringified).  If you do not quote yo' value, Perlz aiiight numeric handling
comes tha fuck into play n' you may not git back what tha fuck you was expecting.
.PP
If you bust a mathematic formula dat resolves ta a gangbangin' floatin point number,
yo ass is dependent on Perlz conversion routines ta yield tha version you
expect.  Yo ass is pretty safe by dividin by a juice of 10, fo' example,
but other operations is not likely ta be what tha fuck you intend yo, but it ain't no stoppin cause I be still poppin'.  For example:
.PP
.Vb 4
\&  $VERSION = version\->new((qw$Revision: 1.4)[1]/10);
\&  print $VERSION;          # yieldz 0.14
\&  $V2 = version\->new(100/9); # Integer overflow up in decimal number
\&  print $V2;               # yieldz suttin' like 11.111.111.100
.Ve
.PP
Perl 5.8.1 n' beyond is able ta automatically quote v\-strings but
that aint possible up in earlier versionz of Perl.  In other lyrics:
.PP
.Vb 2
\&  $version = version\->new("v2.5.4");  # legal up in all versionz of Perl
\&  $newvers = version\->new(v2.5.4);    # legal only up in Perl >= 5.8.1
.Ve
.SS "What bout v\-strings?"
.IX Subsection "What bout v-strings?"
There is two ways ta enta v\-strings: a funky-ass bare number wit two or more
decimal points, or a funky-ass bare number wit one or mo' decimal points n' a
leadin 'v' characta (also bare).  For example:
.PP
.Vb 2
\&  $vs1 = 1.2.3; # encoded as \e1\e2\e3
\&  $vs2 = v1.2;  # encoded as \e1\e2
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat tha use of bare v\-strings ta initialize version objects is
\&\fBstrongly\fR discouraged up in all circumstances.  Also, bare
v\-strings is not straight-up supported up in any version of Perl prior to
5.8.1.
.PP
If you insist on rockin bare v\-strings wit Perl > 5.6.0, be aware of the
followin limitations:
.PP
1) For Perl releases 5.6.0 all up in 5.8.0, tha v\-strin code merely guesses,
based on some characteristics of v\-strings.  Yo ass \fBmust\fR bust a three part
version, e.g. 1.2.3 or v1.2.3 up in order fo' dis heuristic ta be successful.
.PP
2) For Perl releases 5.8.1 n' later, v\-strings have chizzled up in tha Perl
core ta be magical, which means dat tha version.pm code can automatically
determine whether tha v\-strin encodin was used.
.PP
3) In all cases, a version pimped rockin v\-strings gonna git a stringified
form dat has a leadin 'v' character, fo' tha simple reason dat sometimes
it is impossible ta tell whether one was present initially.
.SS "Version Object Internals"
.IX Subsection "Version Object Internals"
version.pm serves up a overloaded version object dat is designed ta both
encapsulate tha authorz intended \f(CW$VERSION\fR assignment as well as make it
completely natural ta use dem objects as if they was numbers (e.g. for
comparisons).  To do this, a version object gotz nuff both tha original
representation as typed by tha lyricist, as well as a parsed representation
to ease comparisons.  Version objects employ overload methodz to
simplify code dat need ta compare, print, etc tha objects.
.PP
Da internal structure of version objects be a pimped hash wit several
components:
.PP
.Vb 11
\&    bless( {
\&      \*(Aqoriginal\*(Aq => \*(Aqv1.2.3_4\*(Aq,
\&      \*(Aqalpha\*(Aq => 1,
\&      \*(Aqqv\*(Aq => 1,
\&      \*(Aqversion\*(Aq => [
\&        1,
\&        2,
\&        3,
\&        4
\&      ]
\&    }, \*(Aqversion\*(Aq );
.Ve
.IP "original" 4
.IX Item "original"
A faithful representation of tha value used ta initialize dis version
object.  Da only time dis aint gonna be precisely tha same characters
that exist up in tha source file is if a gangbangin' finger-lickin' dirty-ass short dotted-decimal version like
v1.2 was used (in which case it will contain 'v1.2').  This form is
\&\fB\s-1STRONGLY\s0\fR discouraged, up in dat it will confuse you n' yo' users.
.IP "qv" 4
.IX Item "qv"
A boolean dat denotes whether dis be a thugged-out decimal or dotted-decimal version.
See \*(L"\fIis_qv()\fR\*(R" up in version.
.IP "alpha" 4
.IX Item "alpha"
A boolean dat denotes whether dis be a alpha version. I aint talkin' bout chicken n' gravy biatch.  \s-1NOTE:\s0 dat the
underscore can only step tha fuck up in tha last position. I aint talkin' bout chicken n' gravy biatch.  See \*(L"\fIis_alpha()\fR\*(R" up in version.
.IP "version" 4
.IX Item "version"
An array of non-negatizzle integers dat is used fo' comparison purposes with
other version objects.
.SS "Replacement \s-1UNIVERSAL::VERSION\s0"
.IX Subsection "Replacement UNIVERSAL::VERSION"
In addizzle ta tha version objects, dis modulez also replaces tha core
\&\s-1UNIVERSAL::VERSION\s0 function wit one dat uses version objects fo' its
comparisons.  Da return from dis operator be always tha stringified form
as a simple scalar (i.e. not a object) yo, but tha warnin message generated
includes either tha stringified form or tha aiiight form, dependin on how
it was called.
.PP
For example:
.PP
.Vb 2
\&  package Foo;
\&  $VERSION = 1.2;
\&
\&  package Bar;
\&  $VERSION = "v1.3.5"; # works wit all Perl\*(Aqs (since it is quoted)
\&
\&  package main;
\&  use version;
\&
\&  print $Foo::VERSION; # prints 1.2
\&
\&  print $Bar::VERSION; # prints 1.003005
\&
\&  eval "use foo 10";
\&  print $@; # prints "foo version 10 required..."
\&  eval "use foo 1.3.5; # work up in Perl 5.6.1 or better
\&  print $@; # prints "foo version 1.3.5 required..."
\&
\&  eval "use bar 1.3.6";
\&  print $@; # prints "bar version 1.3.6 required..."
\&  eval "use bar 1.004"; # note Decimal version
\&  print $@; # prints "bar version 1.004 required..."
.Ve
.PP
\&\s-1IMPORTANT NOTE:\s0 This may mean dat code which searches fo' a specific
strin (to determine whether a given module be available) may need ta be
changed. Y'all KNOW dat shit, muthafucka!  It be always betta ta use tha built-in comparison implicit in
\&\f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR, rather than manually pokin at \f(CW\*(C`class\->VERSION\*(C'\fR
and then bustin a cold-ass lil comparison yo ass.
.PP
Da replacement \s-1UNIVERSAL::VERSION,\s0 when used as a gangbangin' function, like this:
.PP
.Vb 1
\&  print $module\->VERSION;
.Ve
.PP
will also exclusively return tha stringified form.  See \*(L"Stringification\*(R"
for mo' details.
.SH "USAGE DETAILS"
.IX Header "USAGE DETAILS"
.SS "Usin modulez dat use version.pm"
.IX Subsection "Usin modulez dat use version.pm"
As much as possible, tha version.pm module remains compatible wit all
current code.  But fuck dat shiznit yo, tha word on tha street is dat if yo' module is rockin a module dat has defined
\&\f(CW$VERSION\fR rockin tha version class, there be a cold-ass lil couple thangs ta be
aware of.  For purposez of rap, we will assume dat our crazy asses have the
followin module installed:
.PP
.Vb 4
\&  package Example;
\&  use version;  $VERSION = qv(\*(Aq1.2.2\*(Aq);
\&  ...module code here...
\&  1;
.Ve
.IP "Decimal versions always work" 4
.IX Item "Decimal versions always work"
Code of tha form:
.Sp
.Vb 1
\&  use Example 1.002003;
.Ve
.Sp
will always work erectly.  Da \f(CW\*(C`use\*(C'\fR will big-ass up a automatic
\&\f(CW$VERSION\fR comparison rockin tha floatin point number given as tha first
term afta tha module name (e.g. above 1.002.003).  In dis case, the
installed module is too oldschool fo' tha axed line, so you would peep an
error like:
.Sp
.Vb 1
\&  Example version 1.002003 (v1.2.3) required\-\-this is only version 1.002002 (v1.2.2)...
.Ve
.IP "Dotted-Decimal version work sometimes" 4
.IX Item "Dotted-Decimal version work sometimes"
With Perl >= 5.6.2, you can also bust a line like this:
.Sp
.Vb 1
\&  use Example 1.2.3;
.Ve
.Sp
and it will again n' again n' again work (i.e. give tha error message as above), even with
releasez of Perl which do not normally support v\-strings (see \*(L"What bout v\-strings?\*(R" above).  This has ta do wit dat fact dat \f(CW\*(C`use\*(C'\fR only checks
to peep if tha second term \fIlooks like a number\fR n' passes dat ta the
replacement \s-1UNIVERSAL::VERSION\s0.  This aint legit up in Perl 5.005_04,
however, so yo ass is \fBstrongly encouraged\fR ta always bust a Decimal version
in yo' code, even fo' dem versionz of Perl which support tha Dotted-Decimal
version.
.SS "Object Methods"
.IX Subsection "Object Methods"
.IP "\fInew()\fR" 4
.IX Item "new()"
Like nuff \s-1OO\s0 intercourses, tha \fInew()\fR method is used ta initialize version
objects, n' you can put dat on yo' toast.  If two arguments is passed ta \f(CW\*(C`new()\*(C'\fR, tha \fBsecond\fR one will be
used as if it was prefixed wit \*(L"v\*(R".  This is ta support oldschool use of the
\&\f(CW\*(C`qw\*(C'\fR operator wit tha \s-1CVS\s0 variable \f(CW$Revision\fR, which be automatically
incremented by \s-1CVS\s0 every last muthafuckin time tha file is committed ta tha repository.
.Sp
In order ta facilitate dis feature, tha following
code can be employed:
.Sp
.Vb 1
\&  $VERSION = version\->new(qw$Revision: 2.7 $);
.Ve
.Sp
and tha version object is ghon be pimped as if tha followin code
were used:
.Sp
.Vb 1
\&  $VERSION = version\->new("v2.7");
.Ve
.Sp
In other lyrics, tha version is ghon be automatically parsed outta the
string, n' it is ghon be quoted ta preserve tha meanin \s-1CVS\s0 normally
carries fo' versions.  Da \s-1CVS\s0 \f(CW$Revision\fR$ increments differently from
Decimal versions (i.e. 1.10 bigs up 1.9), so it must be handled as if
it was a Dotted-Decimal Version.
.Sp
A freshly smoked up version object can be pimped as a cold-ass lil copy of a existin version
object, either as a cold-ass lil class method:
.Sp
.Vb 2
\&  $v1 = version\->new(12.3);
\&  $v2 = version\->new($v1);
.Ve
.Sp
or as a object method:
.Sp
.Vb 2
\&  $v1 = version\->new(12.3);
\&  $v2 = $v1\->new(12.3);
.Ve
.Sp
and up in each case, \f(CW$v1\fR n' \f(CW$v2\fR is ghon be identical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  \s-1NOTE:\s0 if you create
a freshly smoked up object rockin a existin object like this:
.Sp
.Vb 1
\&  $v2 = $v1\->new();
.Ve
.Sp
the freshly smoked up object \fBwill not\fR be a cold-ass lil clone of tha existin object.  In the
example case, \f(CW$v2\fR is ghon be a empty object of tha same type as \f(CW$v1\fR.
.IP "\fIqv()\fR" 4
.IX Item "qv()"
An alternate way ta create a freshly smoked up version object be all up in tha exported
\&\fIqv()\fR sub.  This aint strictly like other q, biatch? operators (like qq, qw),
in dat tha only delimitas supported is parentheses (or spaces).  It is
the dopest way ta initialize a gangbangin' finger-lickin' dirty-ass short version without triggerin tha floating
point interpretation. I aint talkin' bout chicken n' gravy biatch.  For example:
.Sp
.Vb 2
\&  $v1 = qv(1.2);         # v1.2.0
\&  $v2 = qv("1.2");       # also v1.2.0
.Ve
.Sp
As you can see, either a funky-ass bare number or a quoted strang can usually
be used interchangeably, except up in tha case of a trailin zero, which
must be quoted ta be converted properly.  For dis reason, it is strongly
recommended dat all initializers ta \fIqv()\fR be quoted strings instead of
bare numbers.
.Sp
To prevent tha \f(CW\*(C`qv()\*(C'\fR function from bein exported ta tha callerz namespace,
either use version wit a null parameter:
.Sp
.Vb 1
\&  use version ();
.Ve
.Sp
or just require version, like this:
.Sp
.Vb 1
\&  require version;
.Ve
.Sp
Both methodz will prevent tha \fIimport()\fR method from firin n' exportin the
\&\f(CW\*(C`qv()\*(C'\fR sub.
.PP
For tha subsequent examples, tha followin three objects is ghon be used:
.PP
.Vb 3
\&  $ver   = version\->new("1.2.3.4"); # peep "Quotin Rules"
\&  $alpha = version\->new("1.2.3_4"); # peep "Alpha Versions"
\&  $nver  = version\->new(1.002);     # peep "Decimal Versions"
.Ve
.IP "Normal Form" 4
.IX Item "Normal Form"
For any version object which is initialized wit multiple decimal
places (either quoted or if possible v\-string), or initialized using
the \fIqv()\fR operator, tha stringified representation is returned in
a normalized or reduced form (no extraneous zeros), n' wit a leadin 'v':
.Sp
.Vb 6
\&  print $ver\->normal;         # prints as v1.2.3.4
\&  print $ver\->stringify;      # ditto
\&  print $ver;                 # ditto
\&  print $nver\->normal;        # prints as v1.2.0
\&  print $nver\->stringify;     # prints as 1.002,
\&                              # peep "Stringification"
.Ve
.Sp
In order ta preserve tha meanin of tha processed version, the
normalized representation will always contain at least three sub terms.
In other lyrics, tha followin is guaranteed ta always be true:
.Sp
.Vb 3
\&  mah $newver = version\->new($ver\->stringify);
\&  if ($newver eq $ver ) # always true
\&    {...}
.Ve
.IP "Numification" 4
.IX Item "Numification"
Although all mathematical operations on version objects is forbidden
by default, it is possible ta retrieve a number which corresponds
to tha version object all up in tha use of tha \f(CW$obj\fR\->numify
method. Y'all KNOW dat shit, muthafucka!  For formattin purposes, when displayin a number which
correspondz a version object, all sub versions is assumed ta have
three decimal places.  So fo' example:
.Sp
.Vb 2
\&  print $ver\->numify;         # prints 1.002003004
\&  print $nver\->numify;        # prints 1.002
.Ve
.Sp
Unlike tha stringification operator, there is never any need ta append
trailin zeros ta preserve tha erect version value.
.IP "Stringification" 4
.IX Item "Stringification"
Da default stringification fo' version objects returns exactly tha same
strin as was used ta create it, whether you used \f(CW\*(C`new()\*(C'\fR or \f(CW\*(C`qv()\*(C'\fR,
with one exception. I aint talkin' bout chicken n' gravy biatch.  Da sole exception is if tha object was pimped using
\&\f(CW\*(C`qv()\*(C'\fR n' tha initializer did not have two decimal places or a leading
\&'v' (both optional), then tha stringified form gonna git a leadin 'v'
prepended, up in order ta support round-trip processing.
.Sp
For example:
.Sp
.Vb 7
\&  Initialized as          Stringifies to
\&  ==============          ==============
\&  version\->new("1.2")       1.2
\&  version\->new("v1.2")     v1.2
\&  qv("1.2.3")               1.2.3
\&  qv("v1.3.5")             v1.3.5
\&  qv("1.2")                v1.2   ### exceptionizzle case
.Ve
.Sp
See also \s-1UNIVERSAL::VERSION\s0, as dis also returns tha stringified form
when used as a cold-ass lil class method.
.Sp
\&\s-1IMPORTANT NOTE:\s0 There is one exceptionizzle cases shown up in tha above table
where tha \*(L"initializer\*(R" aint stringwise equivalent ta tha stringified
representation. I aint talkin' bout chicken n' gravy biatch.  If you use tha \f(CW\*(C`qv\*(C'\fR() operator on a version without a
leadin 'v' \fBand\fR wit only a single decimal place, tha stringified output
will gotz a leadin 'v', ta preserve tha sense.  See tha \*(L"\fIqv()\fR\*(R" operator
for mo' details.
.Sp
\&\s-1IMPORTANT NOTE 2:\s0 Attemptin ta bypass tha aiiight stringification rulez by
manually applyin \fInumify()\fR n' \fInormal()\fR  will sometimes yield
surprisin thangs up in dis biatch:
.Sp
.Vb 1
\&  print version\->new(version\->new("v1.0")\->numify)\->normal; # v1.0.0
.Ve
.Sp
Da reason fo' dis is dat tha \fInumify()\fR operator will turn \*(L"v1.0\*(R"
into tha equivalent strang \*(L"1.000000\*(R".  Forcin tha outa version object
to \fInormal()\fR form will display tha mathematically equivalent \*(L"v1.0.0\*(R".
.Sp
As tha example up in \*(L"\fInew()\fR\*(R" shows, you can always create a cold-ass lil copy of an
existin version object wit tha same value by tha straight-up compact:
.Sp
.Vb 1
\&  $v2 = $v1\->new($v1);
.Ve
.Sp
and be assured dat both \f(CW$v1\fR n' \f(CW$v2\fR is ghon be straight-up equivalent,
down ta tha same internal representation as well as stringification.
.IP "Comparison operators" 4
.IX Item "Comparison operators"
Both \f(CW\*(C`cmp\*(C'\fR n' \f(CW\*(C`<=>\*(C'\fR operators big-ass up tha same comparison between
terms (upgradin ta a version object automatically).  Perl automatically
generates all of tha other comparison operators based on dem two.
In addizzle ta tha obvious equalitizzles listed below, appendin a single
trailin 0 term do not chizzle tha value of a version fo' comparison
purposes.  In other lyrics \*(L"v1.2\*(R" n' \*(L"1.2.0\*(R" will compare as identical.
.Sp
For example, tha followin relations hold:
.Sp
.Vb 7
\&  As Number        As Strin           Truth Value
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-\-
\&  $ver >  1.0      $ver gt "1.0"       true
\&  $ver <  2.5      $ver lt             true
\&  $ver != 1.3      $ver ne "1.3"       true
\&  $ver == 1.2      $ver eq "1.2"       false
\&  $ver == 1.2.3.4  $ver eq "1.2.3.4"   peep rap below
.Ve
.Sp
It be probably dopest ta chose either tha Decimal notation or tha string
notation n' stick wit it, ta reduce mad drama.  Perl6 version objects
\&\fBmay\fR only support Decimal comparisons.  See also \*(L"Quotin Rules\*(R".
.Sp
\&\s-1WARNING:\s0 Comparin version wit unequal numberz of decimal points (whether
explicitly or implicitly initialized), may yield unexpected thangs up in dis biatch at
first glance.  For example, tha followin inequalitizzles hold:
.Sp
.Vb 2
\&  version\->new(0.96)     > version\->new(0.95); # 0.960.0 > 0.950.0
\&  version\->new("0.96.1") < version\->new(0.95); # 0.096.1 < 0.950.0
.Ve
.Sp
For dis reason, it is dopest ta use either exclusively \*(L"Decimal Versions\*(R" or
\&\*(L"Dotted-Decimal Versions\*(R" wit multiple decimal points.
.IP "Logical Operators" 4
.IX Item "Logical Operators"
If you need ta test whether a version object
has been initialized, you can simply test it directly:
.Sp
.Vb 2
\&  $vobj = version\->new($something);
\&  if ( $vobj )   # legit only if $suttin' was non\-blank
.Ve
.Sp
Yo ass can also test whether a version object be a alpha version, for
example ta prevent tha use of some feature not present up in tha main
release:
.Sp
.Vb 3
\&  $vobj = version\->new("1.2_3"); # MUST QUOTE
\&  ...later...
\&  if ( $vobj\->is_alpha )       # True
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Jizzy Peading-a-ling <jpeacock@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl.
