.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message::Head::FieldGroup 3"
.TH Mail::Message::Head::FieldGroup 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Head::FieldGroup \- a sub set of fieldz up in a header
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Message::Head::FieldGroup
\&   be a Mail::Reporter
\&
\& Mail::Message::Head::FieldGroup is extended by
\&   Mail::Message::Head::ListGroup
\&   Mail::Message::Head::ResentGroup
\&   Mail::Message::Head::SpamGroup
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Never instantiated directly.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Some fieldz gotz a cold-ass lil combined meaning: a set of fieldz which represent
one intermediate step durin tha transhiznit of tha message (a
\&\fIresent group\fR, implemented up in Mail::Message::Head::ResentGroup), 
fieldz added by mailin list software (implemented in
Mail::Message::Head::ListGroup), or fieldz added by Spam detection
related software (implemented by Mail::Message::Head::SpamGroup).
Each set of fieldz can be extracted or added as crew wit objects
which is based on tha implementation up in dis class.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBclone\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBclone\fR()" 4
.IX Item "$obj->clone()"
Make a cold-ass lil copy of dis object.  Da collected fieldnames is copied n' the
list type shiznit. I aint talkin' bout chicken n' gravy biatch.  No deep copy is made fo' tha header: dis is
only copied as reference.
.ie n .IP "$obj\->\fBfrom\fR(HEAD|MESSAGE)" 4
.el .IP "\f(CW$obj\fR\->\fBfrom\fR(HEAD|MESSAGE)" 4
.IX Item "$obj->from(HEAD|MESSAGE)"
Smoke a crew of fieldz based on tha specified \s-1MESSAGE\s0 or message \s-1HEAD.\s0
This may return one or mo' of tha objects, which dependz on the
type of group.  Mailin list fieldz is all stored up in one object,
where resent n' spam crews can step tha fuck up mo' than once.
.ie n .IP "$obj\->\fBimplementedTypes\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBimplementedTypes\fR()" 4
.IX Item "$obj->implementedTypes()"
.PD 0
.IP "Mail::Message::Head::FieldGroup\->\fBimplementedTypes\fR()" 4
.IX Item "Mail::Message::Head::FieldGroup->implementedTypes()"
.PD
Returns a list of strings containin all possible return joints for
\&\fItype()\fR.
.IP "Mail::Message::Head::FieldGroup\->\fBnew\fR(\s-1FIELDS, OPTIONS\s0)" 4
.IX Item "Mail::Message::Head::FieldGroup->new(FIELDS, OPTIONS)"
Construct a object which maintains one set of header \s-1FIELDS. \s0 The
\&\s-1FIELDS\s0 may be specified as \f(CW\*(C`Mail::Message::Field\*(C'\fR objects or as key-value
pairs.  Da \s-1OPTIONS\s0 n' \s-1FIELDS \s0(as key-value pair) can be mixed: they are
distinguished by they name, where tha fieldz always start wit a cold-ass lil capital.
Da field objects must aways lead tha \s-1OPTIONS.\s0
.Sp
.Vb 7
\& \-Option  \-\-Defined up in     \-\-Default
\&  head                       undef
\&  log       Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  software                   undef
\&  trace     Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  type                       undef
\&  version                    undef
.Ve
.RS 4
.IP "head => \s-1HEAD\s0" 2
.IX Item "head => HEAD"
Da header \s-1HEAD\s0 object is used ta store tha grouped fieldz in.
If no header is specified, a Mail::Message::Head::Partial is pimped
for yo thugged-out ass.  If you wish ta scan tha existin fieldz up in a header, then use
the \fIfrom()\fR method.
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "software => \s-1STRING\s0" 2
.IX Item "software => STRING"
.PD
Name of tha software which produced tha fields.
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.PD 0
.IP "type => \s-1STRING\s0" 2
.IX Item "type => STRING"
.PD
Group name fo' tha fields.  Often tha same, or close
to tha same \s-1STRING,\s0 as tha \f(CW\*(C`software\*(C'\fR option gotz nuff.
.IP "version => \s-1STRING\s0" 2
.IX Item "version => STRING"
Version number fo' tha software which produced tha fields.
.RE
.RS 4
.RE
.SS "Da header"
.IX Subsection "Da header"
.ie n .IP "$obj\->\fBadd\fR((\s-1FIELD, VALUE\s0) | \s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR((\s-1FIELD, VALUE\s0) | \s-1OBJECT\s0)" 4
.IX Item "$obj->add((FIELD, VALUE) | OBJECT)"
Add a gangbangin' field ta tha header, rockin tha field group.  When tha field group
is already attached ta a real message header, it will step tha fuck up in that
one as well as bein registed up in dis set.  If no header is defined,
the field only appears internally.
.Sp
example: addin a gangbangin' field ta a thugged-out detached list group
.Sp
.Vb 4
\& mah $this = Mail::Message::Head::ListGroup\->new(...);
\& $this\->add(\*(AqList\-Id\*(Aq => \*(Aqmailbox\*(Aq);
\& $msg\->addListGroup($this);
\& $msg\->send;
.Ve
.Sp
example: addin a gangbangin' field ta a attached list group
.Sp
.Vb 2
\& mah $lg = Mail::Message::Head::ListGroup\->from($msg);
\& $lg\->add(\*(AqList\-Id\*(Aq => \*(Aqmailbox\*(Aq);
.Ve
.ie n .IP "$obj\->\fBaddFields\fR([\s-1FIELDNAMES\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBaddFields\fR([\s-1FIELDNAMES\s0])" 4
.IX Item "$obj->addFields([FIELDNAMES])"
Add some \s-1FIELDNAMES\s0 ta tha set.
.ie n .IP "$obj\->\fBattach\fR(\s-1HEAD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBattach\fR(\s-1HEAD\s0)" 4
.IX Item "$obj->attach(HEAD)"
Add a crew of fieldz ta a message \s-1HEAD. \s0 Da fieldz is ghon be cloned(!)
into tha header, so dat tha field crew object can be used again.
.Sp
example: attachin a list crew ta a message
.Sp
.Vb 3
\& mah $lg = Mail::Message::Head::ListGroup\->new(...);
\& $lg\->attach($msg\->head);
\& $msg\->head\->addListGroup($lg);   # same
\&
\& $msg\->head\->addSpamGroup($sg);   # also implemented wit attach
.Ve
.ie n .IP "$obj\->\fBdelete\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR()" 4
.IX Item "$obj->delete()"
Remove all tha header lines which is combined up in dis fieldz group,
from tha header.
.ie n .IP "$obj\->\fBfieldNames\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfieldNames\fR()" 4
.IX Item "$obj->fieldNames()"
Return tha namez of tha fieldz which is used up in dis group.
.ie n .IP "$obj\->\fBfields\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfields\fR()" 4
.IX Item "$obj->fields()"
Return tha fieldz which is defined fo' dis group.
.ie n .IP "$obj\->\fBhead\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBhead\fR()" 4
.IX Item "$obj->head()"
Returns tha header object, which includes these fields.
.SS "Access ta tha header"
.IX Subsection "Access ta tha header"
.ie n .IP "$obj\->\fBsoftware\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsoftware\fR()" 4
.IX Item "$obj->software()"
Returns tha name of tha software as is defined up in tha headers.  Da may
be slightly different from tha return value of \fItype()\fR yo, but usually
not too different.
.ie n .IP "$obj\->\fBtype\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtype\fR()" 4
.IX Item "$obj->type()"
Returns a abstract name fo' tha field group; which software is
controlin dat shit.  \f(CW\*(C`undef\*(C'\fR is returned up in case tha type aint known.
Valid names is crew type dependent: peep tha applicable manual
pages.  A list of all types can be retreived wit \fIimplementedTypes()\fR.
.ie n .IP "$obj\->\fBversion\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBversion\fR()" 4
.IX Item "$obj->version()"
Returns tha version number of tha software used ta produce tha fields.
Some kindz of software do leave such a trace, other cases will return
\&\f(CW\*(C`undef\*(C'\fR
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBcollectFields\fR([\s-1NAME\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBcollectFields\fR([\s-1NAME\s0])" 4
.IX Item "$obj->collectFields([NAME])"
Scan tha header fo' fieldz which is probably contained up in field group
with tha specified \s-1NAME. \s0 For mailinglist groups, you can not specify
a \s-1NAME:\s0 only one set of headaz is ghon be found (all headaz is considered
to be produced by exactly one package of mailinglist software).
.Sp
This method be automatically called when a gangbangin' field crew is
constructed via \fIfrom()\fR on a existin header or message.
.Sp
Returned is tha namez of tha list header fieldz found, up in scalar
context tha amount of fields.  An empty list/zero indicates dat there
was no crew ta be found.
.Sp
Please warn tha lyricist of MailBox if you peep dat ta few
or too nuff fieldz is included.
.ie n .IP "$obj\->\fBdetected\fR(\s-1TYPE, SOFTWARE, VERSION\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdetected\fR(\s-1TYPE, SOFTWARE, VERSION\s0)" 4
.IX Item "$obj->detected(TYPE, SOFTWARE, VERSION)"
Sets tha joints fo' tha field crew type, software, n' version,
prossibly ta \f(CW\*(C`undef\*(C'\fR.
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Message::Head::FieldGroup\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Message::Head::FieldGroup->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdetails\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdetails\fR()" 4
.IX Item "$obj->details()"
Produce shiznit bout tha detected/created field group, which may be
helpful durin debugging.  A sickly formatted strang is returned.
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Message::Head::FieldGroup\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Message::Head::FieldGroup->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Message::Head::FieldGroup\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Message::Head::FieldGroup->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
Print tha crew ta tha specified \s-1FILEHANDLE\s0 or \s-1GLOB. \s0 This is probably only
useful fo' debuggin purposed. Y'all KNOW dat shit, muthafucka!  Da output defaults ta tha selected file
handle.
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
