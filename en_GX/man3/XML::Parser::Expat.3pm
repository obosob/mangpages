.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Expat 3"
.TH Expat 3 "2011-06-03" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Parser::Expat \- Lowlevel access ta Jizzy Clarkz expat XML parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use XML::Parser::Expat;
\&
\& $parser = XML::Parser::Expat\->new;
\& $parser\->setHandlezs(\*(AqStart\*(Aq => \e&sh,
\&                      \*(AqEnd\*(Aq   => \e&eh,
\&                      \*(AqChar\*(Aq  => \e&ch);
\& open(FOO, \*(Aq<\*(Aq, \*(Aqinfo.xml\*(Aq) or take a thugged-out dirtnap "Couldn\*(Aqt open";
\& $parser\->parse(*FOO);
\& close(FOO);
\& # $parser\->parse(\*(Aq<foo id="me"> here <em>we</em> go </foo>\*(Aq);
\&
\& sub sh
\& {
\&   mah ($p, $el, %atts) = @_;
\&   $p\->setHandlezs(\*(AqChar\*(Aq => \e&spec)
\&     if ($el eq \*(Aqspecial\*(Aq);
\&   ...
\& }
\&
\& sub eh
\& {
\&   mah ($p, $el) = @_;
\&   $p\->setHandlezs(\*(AqChar\*(Aq => \e&ch)  # Special elements won\*(Aqt contain
\&     if ($el eq \*(Aqspecial\*(Aq);         # other special elements
\&   ...
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up a intercourse ta Jizzy Clarkz \s-1XML\s0 parser, expat fo' realz. As in
expat, a single instizzle of tha parser can only parse one document. Calls
to parsestrin afta tha straight-up original gangsta fo' a given instizzle will take a thugged-out dirt nap.
.PP
Expat (and XML::Parser::Expat) is event based. Y'all KNOW dat shit, muthafucka! As tha parser recognizes
partz of tha document (say tha start or end of a \s-1XML\s0 element), then any
handlezs registered fo' dat type of a event is called wit suitable
parameters.
.SH "METHODS"
.IX Header "METHODS"
.IP "new" 4
.IX Item "new"
This be a cold-ass lil class method, tha constructor fo' XML::Parser::Expat. Options are
passed as keyword value pairs. Da recognized options are:
.RS 4
.IP "\(bu" 4
ProtocolEncoding
.Sp
Da protocol encodin name. Da default is none. Da expat built-in
encodings are: \f(CW\*(C`UTF\-8\*(C'\fR, \f(CW\*(C`ISO\-8859\-1\*(C'\fR, \f(CW\*(C`UTF\-16\*(C'\fR, n' \f(CW\*(C`US\-ASCII\*(C'\fR.
Other encodings may be used if they have encodin maps up in one of the
directories up in tha \f(CW@Encoding_Path\fR list. Right back up in yo muthafuckin ass. Settin tha protocol encoding
overrides any encodin up in tha \s-1XML\s0 declaration.
.IP "\(bu" 4
Namespaces
.Sp
When dis option is given wit a legit value, then tha parser do namespace
processing. By default, namespace processin is turned off. When it is
turned on, tha parser consumes \fIxmlns\fR attributes n' strips off prefixes
from element n' attributes names where dem prefixes gotz a thugged-out defined
namespace fo' realz. A namez namespace can be found rockin tha \*(L"namespace\*(R" method
and two names can be checked fo' absolute equalitizzle wit tha \*(L"eq_name\*(R"
method.
.IP "\(bu" 4
NoExpand
.Sp
Normally, tha parser will try ta expand references ta entitizzles defined in
the internal subset. If dis option is set ta a legit value, n' a thugged-out default
handlez be also set, then tha default handlez is ghon be called when an
entitizzle reference is peeped up in text. This has no effect if a thugged-out default handlez
has not been registered, n' it has no effect on tha expansion of entity
references inside attribute joints.
.IP "\(bu" 4
Stream_Delimiter
.Sp
This option takes a strang value. When dis strang is found ridin' solo on a line
while parsin from a stream, then tha parse is ended as if it saw a end of
file. Da intended use is wit a stream of xml documents up in a \s-1MIME\s0 multipart
format. Da strang should not contain a trailin newline.
.IP "\(bu" 4
ErrorContext
.Sp
When dis option is defined, errors is reported up in context. Da value
of ErrorContext should be tha number of lines ta show on either side of
the line up in which tha error occurred.
.IP "\(bu" 4
ParseParamEnt
.Sp
Unless standalone is set ta \*(L"yes\*(R" up in tha \s-1XML\s0 declaration, settin dis to
a legit value allows tha external \s-1DTD\s0 ta be read, n' parameta entities
to be parsed n' expanded.
.IP "\(bu" 4
Base
.Sp
Da base ta use fo' relatizzle pathnames or URLs. This can also be done by
usin tha base method.
.RE
.RS 4
.RE
.IP "setHandlezs(\s-1TYPE, HANDLER\s0 [, \s-1TYPE, HANDLER\s0 [...]])" 4
.IX Item "setHandlezs(TYPE, HANDLER [, TYPE, HANDLER [...]])"
This method registas handlezs fo' tha various events, n' you can put dat on yo' toast. If no handlezs are
registered, then a cold-ass lil call ta parsestrin or parsefile will only determine if
the correspondin \s-1XML\s0 document is well formed (by returnin without error.)
This may be called from within a handlez, afta tha parse has started.
.Sp
Settin a handlez ta suttin' dat evaluates ta false unsets that
handlez.
.Sp
This method returns a list of type, handlez pairs correspondin ta the
input. Da handlezs returned is tha ones dat was up in effect before the
call ta setHandlezs.
.Sp
Da recognized events n' tha parametas passed ta tha corresponding
handlezs are:
.RS 4
.IP "\(bu" 4
Start             (Parser, Element [, Attr, Val [,...]])
.Sp
This event is generated when a \s-1XML\s0 start tag is recognized. Y'all KNOW dat shit, muthafucka! Parser is
an XML::Parser::Expat instance. Element is tha name of tha \s-1XML\s0 element that
is opened wit tha start tag. Da Attr & Val pairs is generated fo' each
attribute up in tha start tag.
.IP "\(bu" 4
End               (Parser, Element)
.Sp
This event is generated when a \s-1XML\s0 end tag is recognized. Y'all KNOW dat shit, muthafucka! Note that
an \s-1XML\s0 empty tag (<foo/>) generates both a start n' a end event.
.Sp
There be always a lower level start n' end handlez installed dat wrap
the correspondin callbacks. This is ta handle tha context mechanism.
A consequence of dis is dat tha default handlez (see below) will not
see a start tag or end tag unless tha default_current method is called.
.IP "\(bu" 4
Char              (Parser, String)
.Sp
This event is generated when non-markup is recognized. Y'all KNOW dat shit, muthafucka! Da non-markup
sequence of charactas is up in Strin fo' realz. A single non-markup sequence of
charactas may generate multiple calls ta dis handlez n' shit. Whatever the
encodin of tha strang up in tha original gangsta document, dis is given ta the
handlez up in \s-1UTF\-8.\s0
.IP "\(bu" 4
Proc              (Parser, Target, Data)
.Sp
This event is generated when a processin instruction is recognized.
.IP "\(bu" 4
Comment           (Parser, String)
.Sp
This event is generated when a cold-ass lil comment is recognized.
.IP "\(bu" 4
CdataStart        (Parser)
.Sp
This is called all up in tha start of a \s-1CDATA\s0 section.
.IP "\(bu" 4
CdataEnd          (Parser)
.Sp
This is called all up in tha end of a \s-1CDATA\s0 section.
.IP "\(bu" 4
Default           (Parser, String)
.Sp
This is called fo' any charactas dat aint gots a registered handlez.
This includes both charactas dat is part of markup fo' which no
events is generated (markup declarations) n' charactas that
could generate events yo, but fo' which no handlez has been registered.
.Sp
Whatever tha encodin up in tha original gangsta document, tha strang is returned to
the handlez up in \s-1UTF\-8.\s0
.IP "\(bu" 4
Unparsed          (Parser, Entity, Base, Sysid, Pubid, Notation)
.Sp
This is called fo' a thugged-out declaration of a unparsed entity. Entitizzle is tha name
of tha entity. Base is tha base ta be used fo' resolvin a relatizzle \s-1URI.\s0
Sysid is tha system id. Y'all KNOW dat shit, muthafucka! Pubid is tha hood id. Y'all KNOW dat shit, muthafucka! Notation is tha notation
name. Base n' Pubid may be undefined.
.IP "\(bu" 4
Notation          (Parser, Notation, Base, Sysid, Pubid)
.Sp
This is called fo' a thugged-out declaration of notation. I aint talkin' bout chicken n' gravy biatch. Notation is tha notation name.
Base is tha base ta be used fo' resolvin a relatizzle \s-1URI.\s0 Sysid is tha system
id. Y'all KNOW dat shit, muthafucka! Pubid is tha hood id. Y'all KNOW dat shit, muthafucka! Base, Sysid, n' Pubid may all be undefined.
.IP "\(bu" 4
ExternEnt         (Parser, Base, Sysid, Pubid)
.Sp
This is called when a external entitizzle is referenced. Y'all KNOW dat shit, muthafucka! Base is tha base ta be
used fo' resolvin a relatizzle \s-1URI.\s0 Sysid is tha system id. Y'all KNOW dat shit, muthafucka! Pubid is tha public
id. Y'all KNOW dat shit, muthafucka! Base, n' Pubid may be undefined.
.Sp
This handlez should either return a string, which represents tha contents of
the external entity, or return a open filehandle dat can be read ta obtain
the contentz of tha external entity, or return undef, which indicates the
external entitizzle couldn't be found n' will generate a parse error.
.Sp
If a open filehandle is returned, it must be returned as either a glob
(*FOO) or as a reference ta a glob (e.g. a instizzle of IO::Handle).
.IP "\(bu" 4
ExternEntFin      (Parser)
.Sp
This is called afta a external entitizzle has been parsed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it allows
applications ta big-ass up cleanup on actions performed up in tha above
ExternEnt handlez.
.IP "\(bu" 4
Entitizzle            (Parser, Name, Val, Sysid, Pubid, Ndata, IsParam)
.Sp
This is called when a entitizzle is declared. Y'all KNOW dat shit, muthafucka! For internal entities, tha Val
parameta will contain tha value n' tha remainin three parametas will
be undefined. Y'all KNOW dat shit, muthafucka! For external entities, tha Val parameter
will be undefined, tha Sysid parameta gonna git tha system id, tha Pubid
parameta gonna git tha hood id if dat shiznit was provided (it is ghon be undefined
otherwise), tha Ndata parameta will contain tha notation fo' unparsed
entities. Put ya muthafuckin choppers up if ya feel dis! If dis be a parameta entitizzle declaration, then tha IsParam
parameta is true.
.Sp
Note dat dis handlez n' tha Unparsed handlez above overlap. If both are
set, then dis handlez aint gonna be called fo' unparsed entities.
.IP "\(bu" 4
Element           (Parser, Name, Model)
.Sp
Da element handlez is called when a element declaration is found. Y'all KNOW dat shit, muthafucka! Name is
the element name, n' Model is tha content model as an
XML::Parser::ContentModel object. Right back up in yo muthafuckin ass. See \*(L"XML::Parser::ContentModel Methods\*(R"
for methodz available fo' dis class.
.IP "\(bu" 4
Attlist           (Parser, Elname, Attname, Type, Default, Fixed)
.Sp
This handlez is called fo' each attribute up in a \s-1ATTLIST\s0 declaration.
So a \s-1ATTLIST\s0 declaration dat has multiple attributes
will generate multiple calls ta dis handlez n' shit. Da Elname parameta is the
name of tha element wit which tha attribute is bein associated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da Attname
parameta is tha name of tha attribute. Type is tha attribute type, given as
a string. Default is tha default value, which will either be \*(L"#REQUIRED\*(R",
\&\*(L"#IMPLIED\*(R" or a quoted strang (i.e. tha returned strang will begin n' end
with a quote character). If Fixed is true, then dis be a gangbangin' fixed attribute.
.IP "\(bu" 4
Doctype           (Parser, Name, Sysid, Pubid, Internal)
.Sp
This handlez is called fo' \s-1DOCTYPE\s0 declarations. Name is tha document type
name. Right back up in yo muthafuckin ass. Sysid is tha system id of tha document type, if dat shiznit was provided,
otherwise itz undefined. Y'all KNOW dat shit, muthafucka! Pubid is tha hood id of tha document type,
which is ghon be undefined if no hood id was given. I aint talkin' bout chicken n' gravy biatch. Internal will be
true or false, indicatin whether or not tha doctype declaration gotz nuff
an internal subset.
.IP "\(bu" 4
DoctypeFin        (Parser)
.Sp
This handlez is called afta parsin of tha \s-1DOCTYPE\s0 declaration has finished,
includin any internal or external \s-1DTD\s0 declarations.
.IP "\(bu" 4
XMLDecl           (Parser, Version, Encoding, Standalone)
.Sp
This handlez is called fo' \s-1XML\s0 declarations. Version be a strang containg
the version. I aint talkin' bout chicken n' gravy biatch. Encodin is either undefined or gotz nuff a encodin string.
Standalone is either undefined, or legit or false. Undefined indicates
that no standalone parameta was given up in tha \s-1XML\s0 declaration. I aint talkin' bout chicken n' gravy biatch. True or
false indicates \*(L"yes\*(R" or \*(L"no\*(R" respectively.
.RE
.RS 4
.RE
.IP "namespace(name)" 4
.IX Item "namespace(name)"
Return tha \s-1URI\s0 of tha namespace dat tha name belongs to. If tha name don't
belong ta any namespace, a undef is returned. Y'all KNOW dat shit, muthafucka! This is only valid on names
received all up in tha Start or End handlezs from a single document, or through
a call ta tha generate_ns_name method. Y'all KNOW dat shit, muthafucka! In other lyrics, don't use names
generated from one instizzle of XML::Parser::Expat wit other instances.
.IP "eq_name(name1, name2)" 4
.IX Item "eq_name(name1, name2)"
Return legit if name1 n' name2 is identical (i.e. same name n' from
the same namespace.) This is only meaningful if both names was obtained
all up in tha Start or End handlezs from a single document, or through
a call ta tha generate_ns_name method.
.IP "generate_ns_name(name, namespace)" 4
.IX Item "generate_ns_name(name, namespace)"
Return a name, associated wit a given namespace, phat fo' rockin wit the
above 2 methods. Da namespace argument should be tha namespace \s-1URI,\s0 not
a prefix.
.IP "new_ns_prefixes" 4
.IX Item "new_ns_prefixes"
When called from a start tag handlez, returns namespace prefixes declared
with dis start tag. If called elsewere (or if there was no namespace
prefixes declared), it returns a empty list. Right back up in yo muthafuckin ass. Settin of tha default
namespace is indicated wit '#default' as a prefix.
.IP "expand_ns_prefix(prefix)" 4
.IX Item "expand_ns_prefix(prefix)"
Return tha uri ta which tha given prefix is currently bound. Y'all KNOW dat shit, muthafucka! Returns
undef if tha prefix aint currently bound. Y'all KNOW dat shit, muthafucka! Use '#default' ta find the
current bindin of tha default namespace (if any).
.IP "current_ns_prefixes" 4
.IX Item "current_ns_prefixes"
Return a list of currently bound namespace prefixes. Da order of the
the prefixes up in tha list has no meaning. If tha default namespace is
currently bound, '#default' appears up in tha list.
.IP "recognized_string" 4
.IX Item "recognized_string"
Returns tha strang from tha document dat was recognized up in order ta call
the current handlez n' shit. For instance, when called from a start handlez, it
will give our asses tha the start-tag string. Da strang is encoded up in \s-1UTF\-8.\s0
This method don't return a meaningful strang inside declaration handlezs.
.IP "original_string" 4
.IX Item "original_string"
Returns tha verbatim strang from tha document dat was recognized in
order ta booty-call tha current handlez n' shit. Da strang is up in tha original gangsta document
encoding. This method don't return a meaningful strang inside declaration
handlezs.
.IP "default_current" 4
.IX Item "default_current"
When called from a handlez, causes tha sequence of charactas dat generated
the correspondin event ta be busted ta tha default handlez (if one is
registered). Use of dis method is deprecated up in favor tha recognized_string
method, which you can use without installin a thugged-out default handlez n' shit. This
method don't serve up a meaningful strang ta tha default handlez when
called from inside declaration handlezs.
.IP "xpcroak(message)" 4
.IX Item "xpcroak(message)"
Concatenate onto tha given message tha current line number within the
\&\s-1XML\s0 document plus tha message implied by ErrorContext. Then croak with
the formed message.
.IP "xpcarp(message)" 4
.IX Item "xpcarp(message)"
Concatenate onto tha given message tha current line number within the
\&\s-1XML\s0 document plus tha message implied by ErrorContext. Then carp with
the formed message.
.IP "current_line" 4
.IX Item "current_line"
Returns tha line number of tha current posizzle of tha parse.
.IP "current_column" 4
.IX Item "current_column"
Returns tha column number of tha current posizzle of tha parse.
.IP "current_byte" 4
.IX Item "current_byte"
Returns tha current posizzle of tha parse.
.IP "base([\s-1NEWBASE\s0]);" 4
.IX Item "base([NEWBASE]);"
Returns tha current value of tha base fo' resolvin relatizzle URIs. If
\&\s-1NEWBASE\s0 is supplied, chizzlez tha base ta dat value.
.IP "context" 4
.IX Item "context"
Returns a list of element names dat represent open elements, wit the
last one bein tha innermost. Inside start n' end tag handlezs, this
will be tha tag of tha parent element.
.IP "current_element" 4
.IX Item "current_element"
Returns tha name of tha innermost currently opened element. Inside
start or end handlezs, returns tha parent of tha element associated
with dem tags.
.IP "in_element(\s-1NAME\s0)" 4
.IX Item "in_element(NAME)"
Returns legit if \s-1NAME\s0 is equal ta tha name of tha innermost currently opened
element. If namespace processin is bein used n' you wanna check
against a name dat may be up in a namespace, then use tha generate_ns_name
method ta create tha \s-1NAME\s0 argument.
.IP "within_element(\s-1NAME\s0)" 4
.IX Item "within_element(NAME)"
Returns tha number of times tha given name appears up in tha context list.
If namespace processin is bein used n' you wanna check
against a name dat may be up in a namespace, then use tha generate_ns_name
method ta create tha \s-1NAME\s0 argument.
.IP "depth" 4
.IX Item "depth"
Returns tha size of tha context list.
.IP "element_index" 4
.IX Item "element_index"
Returns a integer dat is tha depth-first visit order of tha current
element. This is ghon be zero outside of tha root element. For example,
this will return 1 when called from tha start handlez fo' tha root element
start tag.
.IP "skip_until(\s-1INDEX\s0)" 4
.IX Item "skip_until(INDEX)"
\&\s-1INDEX\s0 be a integer dat represents a element index. When dis method
is called, all handlezs is suspended until tha start tag fo' a element
that has a index number equal ta \s-1INDEX\s0 is seen. I aint talkin' bout chicken n' gravy biatch. If a start handlez has
been set, then dis is tha straight-up original gangsta tag dat tha start handlez will see
afta skip_until has been called.
.IP "position_in_context(\s-1LINES\s0)" 4
.IX Item "position_in_context(LINES)"
Returns a strang dat shows tha current parse position. I aint talkin' bout chicken n' gravy biatch. \s-1LINES\s0 should be
an integer >= 0 dat represents tha number of lines on either side of the
current parse line ta place tha fuck into tha returned string.
.IP "xml_escape(\s-1TEXT\s0 [, \s-1CHAR\s0 [, \s-1CHAR ...\s0]])" 4
.IX Item "xml_escape(TEXT [, CHAR [, CHAR ...]])"
Returns \s-1TEXT\s0 wit markup charactas turned tha fuck into characta entitizzles fo' realz. Any
additionizzle charactas provided as arguments is also turned tha fuck into character
references where found up in \s-1TEXT.\s0
.IP "parse (\s-1SOURCE\s0)" 4
.IX Item "parse (SOURCE)"
Da \s-1SOURCE\s0 parameta should either be a strang containin tha whole \s-1XML\s0
document, or it should be a open IO::Handle. Only a single document
may be parsed fo' a given instizzle of XML::Parser::Expat, so dis will croak
if itz been called previously fo' dis instance.
.IP "parsestring(\s-1XML_DOC_STRING\s0)" 4
.IX Item "parsestring(XML_DOC_STRING)"
Parses tha given strang as a \s-1XML\s0 document. Only a single document may be
parsed fo' a given instizzle of XML::Parser::Expat, so dis will take a thugged-out dirtnap if either
parsestrin or parsefile has been called fo' dis instizzle previously.
.Sp
This method is deprecated up in favor of tha parse method.
.IP "parsefile(\s-1FILENAME\s0)" 4
.IX Item "parsefile(FILENAME)"
Parses tha \s-1XML\s0 document up in tha given file. Will take a thugged-out dirtnap if parsestrin or
parsefile has been called previously fo' dis instance.
.IP "is_defaulted(\s-1ATTNAME\s0)" 4
.IX Item "is_defaulted(ATTNAME)"
\&\s-1NO LONGER WORKS.\s0 To smoke up if a attribute is defaulted please use
the specified_attr method.
.IP "specified_attr" 4
.IX Item "specified_attr"
When tha start handlez receives listz of attributes n' joints, the
non-defaulted (i.e. explicitly specified) attributes occur up in tha list
first. This method returns tha number of specified shit up in tha list.
So if dis number is equal ta tha length of tha list, there was no
defaulted joints, n' you can put dat on yo' toast. Otherwise tha number points ta tha index of the
first defaulted attribute name.
.IP "finish" 4
.IX Item "finish"
Unsets all handlezs (includin internal ones dat set context) yo, but expat
continues parsin ta tha end of tha document or until it findz a error.
It should finish up a shitload fasta than wit tha handlezs set.
.IP "release" 4
.IX Item "release"
There is data structures used by XML::Parser::Expat dat have circular
references. This means dat these structures aint NEVER gonna be garbage
collected unless these references is explicitly broken. I aint talkin' bout chicken n' gravy biatch. Callin this
method breaks dem references (and make tha instizzle unusable.)
.Sp
Normally, higher level calls handle dis fo' you yo, but if yo ass is using
XML::Parser::Expat directly, then itz yo' responsibilitizzle ta booty-call dat shit.
.SS "XML::Parser::ContentModel Methods"
.IX Subsection "XML::Parser::ContentModel Methods"
Da element declaration handlezs is passed objectz of dis class as the
content model of tha element declaration. I aint talkin' bout chicken n' gravy biatch. They also represent content
particles, componentz of a cold-ass lil content model.
.PP
When referred ta as a string, these objects is automagicly converted ta a
strin representation of tha model (or content particle).
.IP "isempty" 4
.IX Item "isempty"
This method returns legit if tha object is \*(L"\s-1EMPTY\*(R",\s0 false otherwise.
.IP "isany" 4
.IX Item "isany"
This method returns legit if tha object is \*(L"\s-1ANY\*(R",\s0 false otherwise.
.IP "ismixed" 4
.IX Item "ismixed"
This method returns legit if tha object is \*(L"(#PCDATA)\*(R" or \*(L"(#PCDATA|...)*\*(R",
false otherwise.
.IP "isname" 4
.IX Item "isname"
This method returns if tha object be a element name.
.IP "ischoice" 4
.IX Item "ischoice"
This method returns legit if tha object be a cold-ass lil chizzle of content particles.
.IP "isseq" 4
.IX Item "isseq"
This method returns legit if tha object be a sequence of content particles.
.IP "quant" 4
.IX Item "quant"
This method returns undef or a strang representin tha quantifier
('?', '*', '+') associated wit tha model or particle.
.IP "children" 4
.IX Item "children"
This method returns undef or (for mixed, chizzle, n' sequence types)
an array of component content particles. There will always be at least
one component fo' chizzlez n' sequences yo, but fo' a mixed content model
of pure \s-1PCDATA, \*(L"\s0(#PCDATA)\*(R", then a undef is returned.
.SS "XML::Parser::ExpatNB Methods"
.IX Subsection "XML::Parser::ExpatNB Methods"
Da class XML::Parser::ExpatNB be a subclass of XML::Parser::Expat used
for non-blockin access ta tha expat library. Well shiiiit, it do not support tha parse,
parsestring, or parsefile methodz yo, but it do have these additionizzle methods:
.IP "parse_more(\s-1DATA\s0)" 4
.IX Item "parse_more(DATA)"
Feed expat mo' text ta munch on.
.IP "parse_done" 4
.IX Item "parse_done"
Tell expat dat itz gotten tha whole document.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "XML::Parser::Expat::load_encoding(\s-1ENCODING\s0)" 4
.IX Item "XML::Parser::Expat::load_encoding(ENCODING)"
Load a external encoding. \s-1ENCODING\s0 is either tha name of a encodin or
the name of a gangbangin' file. Da basename is converted ta lowercase n' a '.enc'
extension be appended unless there be a one already there, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Then, unless
itz a absolute pathname (i.e. begins wit '/'), tha straight-up original gangsta file by that
name discovered up in tha \f(CW@Encoding_Path\fR path list is used.
.Sp
Da encodin up in tha file is loaded n' kept up in tha \f(CW%Encoding_Table\fR
table. Earlier encodingz of tha same name is replaced.
.Sp
This function be automatically called by expat when it encountas a encoding
it don't give a fuck about. Expat shouldn't call dis twice fo' tha same
encodin name. Da only reason playas should use dis function is to
explicitly load a encodin not contained up in tha \f(CW@Encoding_Path\fR list.
.SH "AUTHORS"
.IX Header "AUTHORS"
Larry Wall <\fIlarry@wall.org\fR> freestyled version 1.0.
.PP
Clark Cooper <\fIcoopercc@netheaven.com\fR> picked up support, chizzled tha \s-1API\s0
for dis version (2.x), provided documentation, n' added some standard
package features.
