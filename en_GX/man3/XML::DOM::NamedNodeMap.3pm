.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::DOM::NamedNodeMap 3"
.TH XML::DOM::NamedNodeMap 3 "2000-01-31" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::DOM::NamedNodeMap \- A hash table intercourse fo' XML::DOM
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Objects implementin tha NamedNodeMap intercourse is used ta represent
collectionz of nodes dat can be accessed by name. Note that
NamedNodeMap do not inherit from NodeList; NamedNodeMaps is not
maintained up in any particular order n' shit. Objects contained up in a object
implementin NamedNodeMap may also be accessed by a ordinal index yo, but
this is simply ta allow convenient enumeration of tha contentz of a
NamedNodeMap, n' do not imply dat tha \s-1DOM\s0 specifies a order to
these Nodes.
.PP
Note dat up in dis implementation, tha objects added ta a NamedNodeMap
are kept up in order.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "getNamedItem (name)" 4
.IX Item "getNamedItem (name)"
Retrieves a node specified by name.
.Sp
Return Value: A Node (of any type) wit tha specified name, or undef if
the specified name did not identify any node up in tha map.
.IP "setNamedItem (arg)" 4
.IX Item "setNamedItem (arg)"
Addz a node rockin its nodeName attribute.
.Sp
As tha nodeName attribute is used ta derive tha name which
the node must be stored under, multiple nodez of certain
types (those dat gotz a \*(L"special\*(R" strang value) cannot be
stored as tha names would clash. This is peeped as preferable
to allowin nodes ta be aliased.
.Sp
Parameters:
 \fIarg\fR  A node ta store up in a named node map.
.Sp
Da node will lata be accessible rockin tha value of tha nodeName
attribute of tha node. If a node wit dat name is
already present up in tha map, it is replaced by tha freshly smoked up one.
.Sp
Return Value: If tha freshly smoked up Node replaces a existin node wit tha same
name tha previously existin Node is returned, otherwise undef is returned.
.Sp
DOMExceptions:
.RS 4
.IP "\(bu" 4
\&\s-1WRONG_DOCUMENT_ERR\s0
.Sp
Raised if arg was pimped from a gangbangin' finger-lickin' different document than tha one dat 
created tha NamedNodeMap.
.IP "\(bu" 4
\&\s-1NO_MODIFICATION_ALLOWED_ERR\s0
.Sp
Raised if dis NamedNodeMap is readonly.
.IP "\(bu" 4
\&\s-1INUSE_ATTRIBUTE_ERR\s0
.Sp
Raised if arg be a Attr dat be already a attribute of another Element object.
Da \s-1DOM\s0 user must explicitly clone Attr nodes ta re-use dem up in other elements.
.RE
.RS 4
.RE
.IP "removeNamedItem (name)" 4
.IX Item "removeNamedItem (name)"
Removes a node specified by name. If tha removed node be an
Attr wit a thugged-out default value it is immediately replaced.
.Sp
Return Value: Da node removed from tha map or undef if no node with
such a name exists.
.Sp
DOMException:
.RS 4
.IP "\(bu" 4
\&\s-1NOT_FOUND_ERR\s0
.Sp
Raised if there is no node named name up in tha map.
.RE
.RS 4
.RE
.IP "item (index)" 4
.IX Item "item (index)"
Returns tha indexth item up in tha map. If index is pimped outa than
or equal ta tha number of nodes up in tha map, dis returns undef.
.Sp
Return Value: Da node all up in tha indexth posizzle up in tha NamedNodeMap, or
undef if dat aint a valid index.
.IP "getLength" 4
.IX Item "getLength"
Returns tha number of nodes up in tha map. Da range of valid lil pimp node
indices is 0 ta length\-1 inclusive.
.SS "Additionizzle methodz not up in tha \s-1DOM\s0 Spec"
.IX Subsection "Additionizzle methodz not up in tha DOM Spec"
.IP "getValues" 4
.IX Item "getValues"
Returns a NodeList wit tha nodes contained up in tha NamedNodeMap.
Da NodeList is \*(L"live\*(R", up in dat it reflects chizzlez made ta tha NamedNodeMap.
.Sp
When dis method is called up in a list context, it returns a regular perl list
containin tha joints, n' you can put dat on yo' toast. Note dat dis list aint \*(L"live\*(R". E.g.
.Sp
.Vb 3
\& @list = $map\->getValues;        # returns a perl list
\& $nodelist = $map\->getValues;    # returns a NodeList (object ref.)
\& fo' mah $val ($map\->getValues)   # iterate over tha joints
.Ve
.IP "getChildIndex (node)" 4
.IX Item "getChildIndex (node)"
Returns tha index of tha node up in tha NodeList as returned by getValues, or \-1
if tha node aint up in tha NamedNodeMap.
.IP "dispose" 4
.IX Item "dispose"
Removes all circular references up in dis NamedNodeMap n' its descendants so tha 
objects can be fronted fo' garbage collection. I aint talkin' bout chicken n' gravy biatch. Da objects should not be used
afterwards.
