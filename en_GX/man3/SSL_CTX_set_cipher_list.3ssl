.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_CTX_set_cipher_list 3"
.TH SSL_CTX_set_cipher_list 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_CTX_set_cipher_list, SSL_set_cipher_list \- chizzle list of available SSL_CIPHERs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& int SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str);
\& int SSL_set_cipher_list(SSL *ssl, const char *str);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISSL_CTX_set_cipher_list()\fR sets tha list of available ciphers fo' \fBctx\fR
usin tha control strang \fBstr\fR. Da format of tha strang is busted lyrics about
in \fIciphers\fR\|(1). Da list of ciphers is inherited by all
\&\fBssl\fR objects pimped from \fBctx\fR.
.PP
\&\fISSL_set_cipher_list()\fR sets tha list of ciphers only fo' \fBssl\fR.
.SH "NOTES"
.IX Header "NOTES"
Da control strang \fBstr\fR should be universally usable n' not depend
on detailz of tha library configuration (ciphers compiled in). Thus no
syntax checkin takes place. Items dat is not recognized, cuz the
correspondin ciphers is not compiled up in or cuz they is mistyped,
are simply ignored. Y'all KNOW dat shit, muthafucka! Failure is only flagged if no ciphers could be collected
at all.
.PP
It should be noted, dat inclusion of a cold-ass lil cipher ta be used tha fuck into tha list is
a necessary condition. I aint talkin' bout chicken n' gravy biatch. On tha client side, tha inclusion tha fuck into tha list is
also sufficient. On tha server side, additionizzle restrictions apply fo' realz. All ciphers
have additionizzle requirements, n' you can put dat on yo' toast. \s-1ADH\s0 ciphers don't need a cold-ass lil certificate yo, but
DH-parametas must done been set fo' realz. All other ciphers need a cold-ass lil corresponding
certificate n' key.
.PP
A \s-1RSA\s0 cipher can only be chosen, when a \s-1RSA\s0 certificate be available.
\&\s-1RSA\s0 export ciphers wit a keylength of 512 bits fo' tha \s-1RSA\s0 key require
a temporary 512 bit \s-1RSA\s0 key, as typically tha supplied key has a length
of 1024 bit (see
\&\fISSL_CTX_set_tmp_rsa_callback\fR\|(3)).
\&\s-1RSA\s0 ciphers rockin \s-1EDH\s0 need a cold-ass lil certificate n' key n' additionizzle DH-parameters
(see \fISSL_CTX_set_tmp_dh_callback\fR\|(3)).
.PP
A \s-1DSA\s0 cipher can only be chosen, when a \s-1DSA\s0 certificate be available.
\&\s-1DSA\s0 ciphers always use \s-1DH\s0 key exchange n' therefore need DH-parameters
(see \fISSL_CTX_set_tmp_dh_callback\fR\|(3)).
.PP
When these conditions is not kicked it wit fo' any cipher up in tha list (e.g. a
client only supports export \s-1RSA\s0 ciphers wit a asymmetric key length
of 512 bits n' tha server aint configured ta use temporary \s-1RSA\s0
keys), tha \*(L"no shared cipher\*(R" (\s-1SSL_R_NO_SHARED_CIPHER\s0) error is generated
and tha handshake will fail.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fISSL_CTX_set_cipher_list()\fR n' \fISSL_set_cipher_list()\fR return 1 if any cipher
could be selected n' 0 on complete failure.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIssl\fR\|(3), \fISSL_get_ciphers\fR\|(3),
\&\fISSL_CTX_use_certificate\fR\|(3),
\&\fISSL_CTX_set_tmp_rsa_callback\fR\|(3),
\&\fISSL_CTX_set_tmp_dh_callback\fR\|(3),
\&\fIciphers\fR\|(1)
