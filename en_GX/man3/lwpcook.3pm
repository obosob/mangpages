.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "lwpcook 3"
.TH lwpcook 3 "2012-02-11" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
lwpcook \- Da libwww\-perl cookbook
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document contain some examplez dat show typical usage of the
libwww-perl library.  Yo ass should consult tha documentation fo' the
individual modulez fo' mo' detail.
.PP
All examplez should be runnable programs. Yo ass can, up in most cases, test
the code sections by pipin tha program text directly ta perl.
.SH "GET"
.IX Header "GET"
It be straight-up easy as fuck  ta use dis library ta just fetch documents from the
net.  Da LWP::Simple module serves up tha \fIget()\fR function dat return
the document specified by its \s-1URL\s0 argument:
.PP
.Vb 2
\&  use LWP::Simple;
\&  $doc = git \*(Aqhttp://search.cpan.org/dist/libwww\-perl/\*(Aq;
.Ve
.PP
or, as a perl one-liner rockin tha \fIgetprint()\fR function:
.PP
.Vb 1
\&  perl \-MLWP::Simple \-e \*(Aqgetprint "http://search.cpan.org/dist/libwww\-perl/"\*(Aq
.Ve
.PP
or, how tha fuck bout fetchin tha sickest fuckin perl by hustlin dis command:
.PP
.Vb 3
\&  perl \-MLWP::Simple \-e \*(Aq
\&    getstore "ftp://ftp.sunet.se/pub/lang/perl/CPAN/src/latest.tar.gz",
\&             "perl.tar.gz"\*(Aq
.Ve
.PP
Yo ass will probably first wanna find a \s-1CPAN\s0 joint closer ta you by
runnin suttin' like tha followin command:
.PP
.Vb 1
\&  perl \-MLWP::Simple \-e \*(Aqgetprint "http://www.cpan.org/SITES.html"\*(Aq
.Ve
.PP
Enough of dis simple stuff!  Da \s-1LWP\s0 object oriented intercourse gives
you mo' control over tha request busted ta tha server n' shit.  Usin this
interface you have full control over headaz busted n' how tha fuck you want to
handle tha response returned.
.PP
.Vb 4
\&  use LWP::UserAgent;
\&  $ua = LWP::UserAgent\->new;
\&  $ua\->agent("$0/0.1 " . $ua\->agent);
\&  # $ua\->agent("Mozilla/8.0") # pretend we is straight-up capable browser
\&
\&  $req = HTTP::Request\->new(
\&     GET => \*(Aqhttp://search.cpan.org/dist/libwww\-perl/\*(Aq);
\&  $req\->header(\*(AqAccept\*(Aq => \*(Aqtext/html\*(Aq);
\&
\&  # bust request
\&  $res = $ua\->request($req);
\&
\&  # check tha outcome
\&  if ($res\->is_success) {
\&     print $res\->decoded_content;
\&  }
\&  else {
\&     print "Error: " . $res\->status_line . "\en";
\&  }
.Ve
.PP
Da lwp-request program (alias \s-1GET\s0) dat is distributed wit the
library can also be used ta fetch documents from \s-1WWW\s0 servers.
.SH "HEAD"
.IX Header "HEAD"
If you just wanna check if a thugged-out document is present (i.e. tha \s-1URL\s0 is
valid) try ta run code dat be lookin like this:
.PP
.Vb 1
\&  use LWP::Simple;
\&
\&  if (head($url)) {
\&     # aiiight document exists
\&  }
.Ve
.PP
Da \fIhead()\fR function straight-up returns a list of meta-information about
the document.  Da first three jointz of tha list returned is the
document type, tha size of tha document, n' tha age of tha document.
.PP
Mo' control over tha request or access ta all header joints returned
require dat you use tha object oriented intercourse busted lyrics bout fo' \s-1GET\s0
above.  Just s/GET/HEAD/g.
.SH "POST"
.IX Header "POST"
There is no simple procedural intercourse fo' postin data ta a \s-1WWW\s0 server n' shit.  You
must use tha object oriented intercourse fo' all dis bullshit. Da most common \s-1POST\s0
operation is ta access a \s-1WWW\s0 form application:
.PP
.Vb 2
\&  use LWP::UserAgent;
\&  $ua = LWP::UserAgent\->new;
\&
\&  mah $req = HTTP::Request\->new(
\&      POST => \*(Aqhttp://rt.cpan.org/Public/Dist/Display.html\*(Aq);
\&  $req\->content_type(\*(Aqapplication/x\-www\-form\-urlencoded\*(Aq);
\&  $req\->content(\*(AqStatus=Active&Name=libwww\-perl\*(Aq);
\&
\&  mah $res = $ua\->request($req);
\&  print $res\->as_string;
.Ve
.PP
Lazy playas use tha HTTP::Request::Common module ta set up a suitable
\&\s-1POST\s0 request message (it handlez all tha escapin issues) n' has a
suitable default fo' tha content_type:
.PP
.Vb 3
\&  use HTTP::Request::Common qw(POST);
\&  use LWP::UserAgent;
\&  $ua = LWP::UserAgent\->new;
\&
\&  mah $req = POST \*(Aqhttp://rt.cpan.org/Public/Dist/Display.html\*(Aq,
\&                [ Status => \*(AqActive\*(Aq, Name => \*(Aqlibwww\-perl\*(Aq ];
\&
\&  print $ua\->request($req)\->as_string;
.Ve
.PP
Da lwp-request program (alias \s-1POST\s0) dat is distributed wit the
library can also be used fo' postin data.
.SH "PROXIES"
.IX Header "PROXIES"
Some cribs use proxies ta go all up in fire wall machines, or just as
cache up in order ta improve performance.  Proxies can also be used for
accessin resources all up in protocols not supported directly (or
supported badly :\-) by tha libwww-perl library.
.PP
Yo ass should initialize yo' proxy settin before you start sending
requests:
.PP
.Vb 7
\&  use LWP::UserAgent;
\&  $ua = LWP::UserAgent\->new;
\&  $ua\->env_proxy; # initialize from environment variables
\&  # or
\&  $ua\->proxy(ftp  => \*(Aqhttp://proxy.myorg.com\*(Aq);
\&  $ua\->proxy(wais => \*(Aqhttp://proxy.myorg.com\*(Aq);
\&  $ua\->no_proxy(qw(no se fi));
\&
\&  mah $req = HTTP::Request\->new(GET => \*(Aqwais://xxx.com/\*(Aq);
\&  print $ua\->request($req)\->as_string;
.Ve
.PP
Da LWP::Simple intercourse will call \fIenv_proxy()\fR fo' you automatically.
Applications dat use tha \f(CW$ua\fR\->\fIenv_proxy()\fR method will normally not
use tha \f(CW$ua\fR\->\fIproxy()\fR n' \f(CW$ua\fR\->\fIno_proxy()\fR methods.
.PP
Some proxies also require dat you bust it a username/password in
order ta let requests all up in cause I gots dem finger-lickin' chickens wit tha siz-auce.  Yo ass should be able ta add the
required header, wit suttin' like this:
.PP
.Vb 1
\& use LWP::UserAgent;
\&
\& $ua = LWP::UserAgent\->new;
\& $ua\->proxy([\*(Aqhttp\*(Aq, \*(Aqftp\*(Aq] => \*(Aqhttp://username:password@proxy.myorg.com\*(Aq);
\&
\& $req = HTTP::Request\->new(\*(AqGET\*(Aq,"http://www.perl.com");
\&
\& $res = $ua\->request($req);
\& print $res\->decoded_content if $res\->is_success;
.Ve
.PP
Replace \f(CW\*(C`proxy.myorg.com\*(C'\fR, \f(CW\*(C`username\*(C'\fR and
\&\f(CW\*(C`password\*(C'\fR wit suttin' suitable fo' yo' crib.
.SH "ACCESS TO PROTECTED DOCUMENTS"
.IX Header "ACCESS TO PROTECTED DOCUMENTS"
Documents protected by basic authorization can easily be accessed
like this:
.PP
.Vb 5
\&  use LWP::UserAgent;
\&  $ua = LWP::UserAgent\->new;
\&  $req = HTTP::Request\->new(GET => \*(Aqhttp://www.linpro.no/secret/\*(Aq);
\&  $req\->authorization_basic(\*(Aqaas\*(Aq, \*(Aqmypassword\*(Aq);
\&  print $ua\->request($req)\->as_string;
.Ve
.PP
Da other alternatizzle is ta provide a subclass of \fILWP::UserAgent\fR that
overrides tha \fIget_basic_credentials()\fR method. Y'all KNOW dat shit, muthafucka! Study tha \fIlwp-request\fR
program fo' a example of all dis bullshit.
.SH "COOKIES"
.IX Header "COOKIES"
Some cribs like ta play game wit cookies. Put ya muthafuckin choppers up if ya feel dis!  By default \s-1LWP\s0 ignores
cookies provided by tha servers it visits, n' you can put dat on yo' toast.  \s-1LWP\s0 will collect cookies
and respond ta cookie requests if you set up a cold-ass lil cookie jar.
.PP
.Vb 2
\&  use LWP::UserAgent;
\&  use HTTP::Cookies;
\&
\&  $ua = LWP::UserAgent\->new;
\&  $ua\->cookie_jar(HTTP::Cookies\->new(file => "lwpcookies.txt",
\&                                     autosave => 1));
\&
\&  # n' then bust requests just as you used ta do
\&  $res = $ua\->request(HTTP::Request\->new(GET => "http://no.yahoo.com/"));
\&  print $res\->status_line, "\en";
.Ve
.PP
As you visit cribs dat bust you dem scooby snacks ta keep, then tha file
\&\fIlwpcookies.txt"\fR will grow.
.SH "HTTPS"
.IX Header "HTTPS"
URLs wit https scheme is accessed up in exactly tha same way as with
http scheme, provided dat a \s-1SSL\s0 intercourse module fo' \s-1LWP\s0 has been
properly installed (see tha \fI\s-1README.SSL\s0\fR file found up in the
libwww-perl distribution fo' mo' details).  If no \s-1SSL\s0 intercourse is
installed fo' \s-1LWP\s0 ta use, then yo big-ass booty is ghon git \*(L"501 Protocol scheme
\&'https' aint supported\*(R" errors when accessin such URLs.
.PP
Herez a example of fetchin n' printin a \s-1WWW\s0 page rockin \s-1SSL:\s0
.PP
.Vb 1
\&  use LWP::UserAgent;
\&
\&  mah $ua = LWP::UserAgent\->new;
\&  mah $req = HTTP::Request\->new(GET => \*(Aqhttps://www.helsinki.fi/\*(Aq);
\&  mah $res = $ua\->request($req);
\&  if ($res\->is_success) {
\&      print $res\->as_string;
\&  }
\&  else {
\&      print "Failed: ", $res\->status_line, "\en";
\&  }
.Ve
.SH "MIRRORING"
.IX Header "MIRRORING"
If you wanna mirror documents from a \s-1WWW\s0 server, then try ta run
code similar ta dis at regular intervals:
.PP
.Vb 1
\&  use LWP::Simple;
\&
\&  %mirrors = (
\&     \*(Aqhttp://www.sn.no/\*(Aq                       => \*(Aqsn.html\*(Aq,
\&     \*(Aqhttp://www.perl.com/\*(Aq                    => \*(Aqperl.html\*(Aq,
\&     \*(Aqhttp://search.cpan.org/distlibwww\-perl/\*(Aq => \*(Aqlwp.html\*(Aq,
\&     \*(Aqgopher://gopher.sn.no/\*(Aq                  => \*(Aqgopher.html\*(Aq,
\&  );
\&
\&  while (($url, $localfile) = each(%mirrors)) {
\&     mirror($url, $localfile);
\&  }
.Ve
.PP
Or, as a perl one-liner:
.PP
.Vb 1
\&  perl \-MLWP::Simple \-e \*(Aqmirror("http://www.perl.com/", "perl.html")\*(Aq;
.Ve
.PP
Da document aint gonna be transferred unless it has been updated.
.SH "LARGE DOCUMENTS"
.IX Header "LARGE DOCUMENTS"
If tha document you wanna fetch is too big-ass ta be kept up in memory,
then you have two alternatives.  Yo ass can instruct tha library ta write
the document content ta a gangbangin' file (second \f(CW$ua\fR\->\fIrequest()\fR argument be a gangbangin' file
name):
.PP
.Vb 2
\&  use LWP::UserAgent;
\&  $ua = LWP::UserAgent\->new;
\&
\&  mah $req = HTTP::Request\->new(GET =>
\&     \*(Aqhttp://www.cpan.org/authors/Gisle_Aas/libwww\-perl\-6.02.tar.gz\*(Aq);
\&  $res = $ua\->request($req, "libwww\-perl.tar.gz");
\&  if ($res\->is_success) {
\&     print "ok\en";
\&  }
\&  else {
\&     print $res\->status_line, "\en";
\&  }
.Ve
.PP
Or you can process tha document as it arrives (second \f(CW$ua\fR\->\fIrequest()\fR
argument be a cold-ass lil code reference):
.PP
.Vb 3
\&  use LWP::UserAgent;
\&  $ua = LWP::UserAgent\->new;
\&  $URL = \*(Aqftp://ftp.unit.no/pub/rfc/rfc\-index.txt\*(Aq;
\&
\&  mah $expected_length;
\&  mah $bytes_received = 0;
\&  mah $res =
\&     $ua\->request(HTTP::Request\->new(GET => $URL),
\&               sub {
\&                   my($chunk, $res) = @_;
\&                   $bytes_received += length($chunk);
\&                   unless (defined $expected_length) {
\&                      $expected_length = $res\->content_length || 0;
\&                   }
\&                   if ($expected_length) {
\&                        printf STDERR "%d%% \- ",
\&                                  100 * $bytes_received / $expected_length;
\&                   }
\&                   print STDERR "$bytes_received bytes received\en";
\&
\&                   # XXX Should straight-up do suttin' wit tha chunk itself
\&                   # print $chunk;
\&               });
\&   print $res\->status_line, "\en";
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1996\-2001, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
