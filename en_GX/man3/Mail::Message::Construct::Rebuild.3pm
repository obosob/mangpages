.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message::Construct::Rebuild 3"
.TH Mail::Message::Construct::Rebuild 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Construct::Rebuild \- modify a Mail::Message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& mah $cleanup = $msg\->rebuild;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Modifyin existin lyrics be a pain, certainly if dis has ta be
done up in a automated fashion. I aint talkin' bout chicken n' gravy biatch.  Da problems is especially had when
multiparts gotta be pimped or removed. Y'all KNOW dat shit, muthafucka!  Da \fIrebuild()\fR method
tries ta simplify dis task n' add some standard features.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructin a message"
.IX Subsection "Constructin a message"
.ie n .IP "$obj\->\fBrebuild\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBrebuild\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->rebuild(OPTIONS)"
Reconstruct a existin message tha fuck into suttin' new.  Returned be a new
message when there was modifications made, \f(CW\*(C`undef\*(C'\fR if tha message has
no body left, or tha original gangsta message when no modifications had ta be
made.
.Sp
Examplez of use: you gotz a message which only gotz nuff html, n' you
wanna translate it tha fuck into a multipart which gotz nuff tha original gangsta html
and tha textual translation of dat shit.  Or, you gotz a message wit parts
flagged ta be deleted, n' you want dem chizzlez be incorparted up in the
memory structure.  Another possibility: clear all tha resent groups
(see Mail::Message::Head::ResentGroup) from tha header, before it is
written ta file.
.Sp
Reconstructin be a hazardous task, where multi level multiparts and
nested lyrics come tha fuck into play.  Da rebuild method tries ta simplify
handin these lyrics fo' yo thugged-out ass.
.Sp
.Vb 4
\& \-Option         \-\-Default
\&  extra_rulez      []
\&  keep_message_id  <false>
\&  rulez            <see text>
.Ve
.RS 4
.IP "extra_rulez => \s-1ARRAY\s0" 2
.IX Item "extra_rulez => ARRAY"
Da standard set of rules, which is tha default fo' tha \f(CW\*(C`rules\*(C'\fR option,
is a moderest setting.  In stead of copyin dat list tha fuck into a gangbangin' full set
of rulez of yo' own, you can also specify only some additionizzle rules
which is ghon be prependend ta tha default rule set.
.Sp
Da order of tha rulez is bigged up, which means dat you do not always
need ta rewrite tha whole rule is (see \f(CW\*(C`rule\*(C'\fR option).  For instance,
the extra rule of \f(CW\*(C`removeDeletedParts\*(C'\fR returns a \f(CW\*(C`undef\*(C'\fR, which
means dat it cancels tha effect of tha default rule \f(CW\*(C`replaceDeletedParts\*(C'\fR.
.IP "keep_message_id => \s-1BOOLEAN\s0" 2
.IX Item "keep_message_id => BOOLEAN"
Da message-id be a unique identification of tha message: no two lyrics
with different content shall exist anywhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  However up in practice, when
a message is chizzled durin transmission, tha id is often incorrectly
not chizzled. Y'all KNOW dat shit, muthafucka!  This may lead ta complications up in application which see
both lyrics wit tha same id.
.IP "rulez => \s-1ARRAY\s0" 2
.IX Item "rulez => ARRAY"
Da \s-1ARRAY\s0 be a list of rules, which each describe a action which will
be called on each part which is found up in tha message.  Most rules
probably won't match yo, but some will brang chizzlez ta tha content.
Rulez can be specified as method name, or as code reference.  See the
\&\*(L"\s-1DETAILS\*(R"\s0 chapta up in dis manual page, n' \fIrecursiveRebuildPart()\fR.
.Sp
By default, only tha relatively safe transformations is performed:
\&\f(CW\*(C`replaceDeletedParts\*(C'\fR, \f(CW\*(C`descendMultiparts\*(C'\fR, \f(CW\*(C`descendNested\*(C'\fR,
\&\f(CW\*(C`flattenMultiparts\*(C'\fR, \f(CW\*(C`flattenEmptyMultiparts\*(C'\fR.  In tha future, more
safe transformations may be added ta dis list.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 3
\& # remove all deleted parts
\& mah $cleaned = $msg\->rebuild(keep_message_id => 1);
\& $folder\->addMessage($cleaned) if defined $cleaned;
\&
\& # Replace deleted parts by a place\-holder
\& mah $cleaned = $msg\->rebuild
\&   ( keep_message_id => 1
\&   , extra_rulez => [ \*(AqremoveEmpty\*(Aq, \*(AqflattenMultiparts\*(Aq ]
\&   );
.Ve
.RE
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBrecursiveRebuildPart\fR(\s-1PART, OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBrecursiveRebuildPart\fR(\s-1PART, OPTIONS\s0)" 4
.IX Item "$obj->recursiveRebuildPart(PART, OPTIONS)"
.Vb 2
\& \-Option\-\-Default
\&  rulez   <required>
.Ve
.RS 4
.IP "rulez => ARRAY-OF-RULES" 2
.IX Item "rulez => ARRAY-OF-RULES"
Rulez is method names which can be called on lyrics n' message parts
objects, n' you can put dat on yo' toast.  Da \s-1ARRAY\s0 can also list code references which can be called.
In any case, each rule is ghon be called tha same way:
.Sp
.Vb 1
\& $code\->(MESSAGE, PART)
.Ve
.Sp
Da return can be \f(CW\*(C`undef\*(C'\fR or any complex construct based on a
Mail::Message::Part or coerceable tha fuck into such a part.  For each part,
all rulez is called up in sequence.  When a rule returns a cold-ass lil chizzled object,
the rulez will start all over again, however \f(CW\*(C`undef\*(C'\fR will immediately
stop dat shit.
.RE
.RS 4
.RE
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Rebuildin a message"
.IX Subsection "Rebuildin a message"
Modifyin a existin message be a cold-ass lil fucked up thang.  Not only do you need
to know what tha fuck yo ass is willin ta chizzle yo, but you gotta take care about
multiparts (possibly nested up in multiple levels), rfc822 encapsulated
lyrics, header field consistency, n' so on. I aint talkin' bout chicken n' gravy biatch.  Da \fIrebuild()\fR method
let you focus on tha task, n' takes care of tha rest.
.PP
Da \fIrebuild()\fR method uses rulez ta transform tha one message tha fuck into an
other n' shit.  If one or mo' of tha rulez apply, a freshly smoked up message is ghon be returned.
A simple numeric comparison  drops some lyrics ta whether tha message has chizzled. Y'all KNOW dat shit, muthafucka!  For
example
.PP
.Vb 2
\& print "No chizzle"
\&    if $message == $message\->rebuild;
.Ve
.PP
Transformation is made wit a set of rules.  Each rule performs only a
small step, which make is easily configurable.  Da rulez is ordered,
and when one cook up a cold-ass lil chizzle ta tha result, tha result is ghon be passed
to all tha rulez again n' again n' again until no rule cook up a cold-ass lil chizzle on tha part no mo'.
A rule may also return \f(CW\*(C`undef\*(C'\fR up in which case tha part is ghon be removed
from tha (resulting) message.
.PP
\fIGeneral rules\fR
.IX Subsection "General rules"
.PP
This sections raps bout tha general configuration rules: all like straight
forward transformations on tha message structure.  Da rulez marked wit (*)
are used by default.
.IP "\(bu" 4
descendMultiparts (*)
.Sp
Apply tha rulez ta tha partz of (possibly nested) multiparts, not only to
the top-level message.
.IP "\(bu" 4
descendNested (*)
.Sp
Apply tha rulez ta tha \f(CW\*(C`message/rfc822\*(C'\fR encapsulated message as well.
.IP "\(bu" 4
flattenEmptyMultiparts (*)
.Sp
Multipart lyrics which aint gots any parts left is replaced by
a single part which gotz nuff tha preamble, epilogue n' a funky-ass brief
explanation.
.IP "\(bu" 4
flattenMultiparts (*)
.Sp
When a multipart gotz nuff only one part, dat part will take tha place of
the multipart: tha removal of a level of nesting.  This way, tha preamble
and epilogue of tha multipart (which aint gots a meaning, officially)
are lost.
.IP "\(bu" 4
flattenNesting
.Sp
Remove tha \f(CW\*(C`message/rfc822\*(C'\fR encapsulation. I aint talkin' bout chicken n' gravy biatch.  Only tha content related
linez of tha encapsulated body is preserved one level higher n' shit.  Other
information is ghon be lost, which is often not too bad.
.IP "\(bu" 4
removeDeletedParts
.Sp
All parts which is flagged fo' deletion is removed from tha message
without leavin a trace.  If a nested message is encountered which has
its encapsulated content flagged fo' deletion, it is ghon be removed as
a whole.
.IP "\(bu" 4
removeEmptyMultiparts
.Sp
Multipart lyrics which aint gots any parts left is removed. Y'all KNOW dat shit, muthafucka!  The
information up in preamble n' epiloge is lost.
.IP "\(bu" 4
removeEmptyBodies
.Sp
Simple message bodies which do not contain any linez of content are
removed. Y'all KNOW dat shit, muthafucka!  This will loose tha shiznit which is stored up in the
headaz of these bodies.
.IP "\(bu" 4
replaceDeletedParts (*)
.Sp
All partz of tha message which is flagged fo' deletion is replace
by a message which say dat tha part is deleted.
.PP
Yo ass can specify a selection of these rulez wit rebuild(rules) and
rebuild(extra_rules).
.PP
\fIConversion rules\fR
.IX Subsection "Conversion rules"
.PP
This section raps bout tha rulez which try ta be smart-ass wit the
content.  Please contribute wit scams n' implementations.
.IP "\(bu" 4
removeHtmlAlternativeToText
.Sp
When a multipart alternatizzle is encountered, which gotz nuff both a
plain text n' a html part, then tha html part is flagged for
deletion. I aint talkin' bout chicken n' gravy biatch.  Especially useful up in combination wit tha \f(CW\*(C`removeDeletedParts\*(C'\fR
and \f(CW\*(C`flattenMultiparts\*(C'\fR rules.
.IP "\(bu" 4
textAlternativeForHtml
.Sp
Any \f(CW\*(C`text/html\*(C'\fR part which aint accompanied by a alternative
plain text part gonna git one added. Y'all KNOW dat shit, muthafucka!  Yo ass must gotz a working
Mail::Message::Convert::HtmlFormatText, which means that
HTML::TreeBuilder n' HTML::FormatText  must be installed on
your system.
.PP
\fIAddin yo' own rules\fR
.IX Subsection "Addin yo' own rules"
.PP
If you have designed yo' own rule, please consider contributin this
to Mail::Box; it may be useful fo' other playas as well.
.PP
Each rule is called
.PP
.Vb 1
\& mah $new = $code\->($message, $part, %options)
.Ve
.PP
where tha \f(CW%options\fR is defined by tha \f(CW\*(C`rebuild()\*(C'\fR method internals fo' realz. At
least tha \f(CW\*(C`rules\*(C'\fR option is passed, which be a gangbangin' full expansion of all
the rulez which is ghon be applied.
.PP
Yo crazy-ass subroutine shall return \f(CW$part\fR if no chizzlez is needed,
\&\f(CW\*(C`undef\*(C'\fR if tha part should be removed, n' any newly constructed
\&\f(CW\*(C`Mail::Message::Part\*(C'\fR when a cold-ass lil chizzle is required. Y'all KNOW dat shit, muthafucka!  It be easiest to
start lookin all up in tha source code of dis package, n' copy from a
comparible routine.
.PP
When you have yo' own routine, you simply call:
.PP
.Vb 2
\& mah $rebuild_message = $message\->rebuild
\&  ( extra_rulez => [ \e&my_own_rule, \*(Aqother_rule\*(Aq ] );
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Error: No rebuild rule $name defined." 4
.el .IP "Error: No rebuild rule \f(CW$name\fR defined." 4
.IX Item "Error: No rebuild rule $name defined."
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
