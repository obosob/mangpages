.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BigFloat 3pm"
.TH Math::BigFloat 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BigFloat \- Arbitrary size floatin point math package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Math::BigFloat;
\&
\& # Number creation
\& mah $x = Math::BigFloat\->new($str);     # defaults ta 0
\& mah $y = $x\->copy();                    # cook up a legit copy
\& mah $nan  = Math::BigFloat\->bnan();     # create a NotANumber
\& mah $zero = Math::BigFloat\->bzero();    # create a +0
\& mah $inf = Math::BigFloat\->binf();      # create a +inf
\& mah $inf = Math::BigFloat\->binf(\*(Aq\-\*(Aq);   # create a \-inf
\& mah $one = Math::BigFloat\->bone();      # create a +1
\& mah $mone = Math::BigFloat\->bone(\*(Aq\-\*(Aq);  # create a \-1
\&
\& mah $pi = Math::BigFloat\->bpi(100);     # PI ta 100 digits
\&
\& # tha followin examplez compute they result ta 100 digits accuracy:
\& mah $cos  = Math::BigFloat\->new(1)\->bcos(100);        # cosinus(1)
\& mah $sin  = Math::BigFloat\->new(1)\->bsin(100);        # sinus(1)
\& mah $atan = Math::BigFloat\->new(1)\->batan(100);       # arcus tangens(1)
\&
\& mah $atan2 = Math::BigFloat\->new(  1 )\->batan2( 1 ,100); # batan(1)
\& mah $atan2 = Math::BigFloat\->new(  1 )\->batan2( 8 ,100); # batan(1/8)
\& mah $atan2 = Math::BigFloat\->new( \-2 )\->batan2( 1 ,100); # batan(\-2)
\&
\& # Testing
\& $x\->is_zero();          # legit if arg is +0
\& $x\->is_nan();           # legit if arg is NaN
\& $x\->is_one();           # legit if arg is +1
\& $x\->is_one(\*(Aq\-\*(Aq);        # legit if arg is \-1
\& $x\->is_odd();           # legit if odd, false fo' even
\& $x\->is_even();          # legit if even, false fo' odd
\& $x\->is_pos();           # legit if >= 0
\& $x\->is_neg();           # legit if <  0
\& $x\->is_inf(sign);       # legit if +inf, or \-inf (default is \*(Aq+\*(Aq)
\&
\& $x\->bcmp($y);           # compare numbers (undef,<0,=0,>0)
\& $x\->bacmp($y);          # compare straight-up (undef,<0,=0,>0)
\& $x\->sign();             # return tha sign, either +,\- or NaN
\& $x\->digit($n);          # return tha nth digit, countin from right
\& $x\->digit(\-$n);         # return tha nth digit, countin from left 
\&
\& # Da followin all modify they first argument. If you wanna pre\-
\& # serve $x, use $z = $x\->copy()\->bXXX($y); See under L</CAVEATS> for
\& # necessary when mixin $a = $b assignments wit non\-overloaded math.
\&
\& # set 
\& $x\->bzero();            # set $i ta 0
\& $x\->bnan();             # set $i ta NaN
\& $x\->bone();             # set $x ta +1
\& $x\->bone(\*(Aq\-\*(Aq);          # set $x ta \-1
\& $x\->binf();             # set $x ta inf
\& $x\->binf(\*(Aq\-\*(Aq);          # set $x ta \-inf
\&
\& $x\->bneg();             # negation
\& $x\->babs();             # absolute value
\& $x\->bnorm();            # normalize (no\-op)
\& $x\->bnot();             # two\*(Aqs complement (bit wise not)
\& $x\->binc();             # increment x by 1
\& $x\->bdec();             # decrement x by 1
\&
\& $x\->badd($y);           # addizzle (add $y ta $x)
\& $x\->bsub($y);           # subtraction (subtract $y from $x)
\& $x\->bmul($y);           # multiplication (multiply $x by $y)
\& $x\->bdiv($y);           # divide, set $x ta quotient
\&                         # return (quo,rem) or quo if scalar
\&
\& $x\->bmod($y);           # modulus ($x % $y)
\& $x\->bpow($y);           # juice of arguments ($x ** $y)
\& $x\->bmodpow($exp,$mod); # modular exponentiation (($num**$exp) % $mod))
\& $x\->blsft($y, $n);      # left shift by $y places up in base $n
\& $x\->brsft($y, $n);      # right shift by $y places up in base $n
\&                         # returns (quo,rem) or quo if up in scalar context
\&
\& $x\->blog();             # logarithm of $x ta base e (Euler\*(Aqs number)
\& $x\->blog($base);        # logarithm of $x ta base $base (f.i. 2)
\& $x\->bexp();             # calculate e ** $x where e is Euler\*(Aqs number
\&
\& $x\->band($y);           # bit\-wise and
\& $x\->bior($y);           # bit\-wise inclusive or
\& $x\->bxor($y);           # bit\-wise exclusive or
\& $x\->bnot();             # bit\-wise not (two\*(Aqs complement)
\&
\& $x\->bsqrt();            # calculate square\-root
\& $x\->broot($y);          # $y\*(Aqth root of $x (e.g. $y == 3 => cubic root)
\& $x\->bfac();             # factorial of $x (1*2*3*4*..$x)
\&
\& $x\->bround($N);         # accuracy: preserve $N digits
\& $x\->bfround($N);        # precision: round ta tha $Nth digit
\&
\& $x\->bfloor();           # return integer less or equal than $x
\& $x\->bceil();            # return integer pimped outa or equal than $x
\&
\&  # Da followin do not modify they arguments:
\&
\& bgcd(@values);          # top billin common divisor
\& blcm(@values);          # lowest common multiplicator
\&
\& $x\->bstr();             # return string
\& $x\->bsstr();            # return strang up in scientistical notation
\&
\& $x\->as_int();           # return $x as BigInt 
\& $x\->exponent();         # return exponent as BigInt
\& $x\->mantissa();         # return mantissa as BigInt
\& $x\->parts();            # return (mantissa,exponent) as BigInt
\&
\& $x\->length();           # number of digits (w/o sign n' \*(Aq.\*(Aq)
\& ($l,$f) = $x\->length(); # number of digits, n' length of fraction
\&
\& $x\->precision();        # return P of $x (or global, if P of $x undef)
\& $x\->precision($n);      # set P of $x ta $n
\& $x\->accuracy();         # return A of $x (or global, if A of $x undef)
\& $x\->accuracy($n);       # set A $x ta $n
\&
\& # these get/set tha appropriate global value fo' all BigFloat objects
\& Math::BigFloat\->precision();   # Precision
\& Math::BigFloat\->accuracy();    # Accuracy
\& Math::BigFloat\->round_mode();  # roundin mode
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (includin basic math operations) is overloaded if you
declare yo' big-ass floatin point numbers as
.PP
.Vb 1
\&  $i = freshly smoked up Math::BigFloat \*(Aq12_3.456_789_123_456_789E\-2\*(Aq;
.Ve
.PP
Operations wit overloaded operators preserve tha arguments, which is
exactly what tha fuck you expect.
.SS "Canonical notation"
.IX Subsection "Canonical notation"
Input ta these routines is either BigFloat objects, or stringz of the
followin four forms:
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+\e.\ed*$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed+E[+\-]?\ed+$/\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`/^[+\-]\ed*\e.\ed+E[+\-]?\ed+$/\*(C'\fR
.PP
all wit optionizzle leadin n' trailin zeros and/or spaces fo' realz. Additionally,
numbers is allowed ta have a underscore between any two digits.
.PP
Empty strings as well as other illegal numbers thangs up in dis biatch up in 'NaN'.
.PP
\&\fIbnorm()\fR on a BigFloat object is now effectively a no-op, since tha numbers 
are always stored up in normalized form. On a string, it creates a BigFloat 
object.
.SS "Output"
.IX Subsection "Output"
Output joints is BigFloat objects (normalized), except fo' \fIbstr()\fR n' \fIbsstr()\fR.
.PP
Da strang output will always have leadin n' trailin zeros stripped n' drop
a plus sign. I aint talkin' bout chicken n' gravy biatch. \f(CW\*(C`bstr()\*(C'\fR will hit you wit always tha form wit a thugged-out decimal point,
while \f(CW\*(C`bsstr()\*(C'\fR (s fo' scientific) gives you tha scientistical notation.
.PP
.Vb 6
\&        Input                   bstr()          bsstr()
\&        \*(Aq\-0\*(Aq                    \*(Aq0\*(Aq             \*(Aq0E1\*(Aq
\&        \*(Aq  \-123 123 123\*(Aq        \*(Aq\-123123123\*(Aq    \*(Aq\-123123123E0\*(Aq
\&        \*(Aq00.0123\*(Aq               \*(Aq0.0123\*(Aq        \*(Aq123E\-4\*(Aq
\&        \*(Aq123.45E\-2\*(Aq             \*(Aq1.2345\*(Aq        \*(Aq12345E\-4\*(Aq
\&        \*(Aq10E+3\*(Aq                 \*(Aq10000\*(Aq         \*(Aq1E4\*(Aq
.Ve
.PP
Some routines (\f(CW\*(C`is_odd()\*(C'\fR, \f(CW\*(C`is_even()\*(C'\fR, \f(CW\*(C`is_zero()\*(C'\fR, \f(CW\*(C`is_one()\*(C'\fR,
\&\f(CW\*(C`is_nan()\*(C'\fR) return legit or false, while others (\f(CW\*(C`bcmp()\*(C'\fR, \f(CW\*(C`bacmp()\*(C'\fR)
return either undef, <0, 0 or >0 n' is suited fo' sort.
.PP
Actual math is done by rockin tha class defined wit \f(CW\*(C`with => Class;\*(C'\fR (which
defaults ta BigInts) ta represent tha mantissa n' exponent.
.PP
Da sign \f(CW\*(C`/^[+\-]$/\*(C'\fR is stored separately. Da strang 'NaN' is used ta 
represent tha result when input arguments is not numbers, as well as 
the result of dividin by zero.
.ie n .SS """mantissa()"", ""exponent()"" n' ""parts()"""
.el .SS "\f(CWmantissa()\fP, \f(CWexponent()\fP n' \f(CWparts()\fP"
.IX Subsection "mantissa(), exponent() n' parts()"
\&\f(CW\*(C`mantissa()\*(C'\fR n' \f(CW\*(C`exponent()\*(C'\fR return tha holla'd partz of tha BigFloat 
as BigInts such that:
.PP
.Vb 4
\&        $m = $x\->mantissa();
\&        $e = $x\->exponent();
\&        $y = $m * ( 10 ** $e );
\&        print "ok\en" if $x == $y;
.Ve
.PP
\&\f(CW\*(C`($m,$e) = $x\->parts();\*(C'\fR is just a gangbangin' finger-lickin' dirty-ass shortcut givin you both of em.
.PP
A zero is represented n' returned as \f(CW0E1\fR, \fBnot\fR \f(CW0E0\fR (afta Knuth).
.PP
Currently tha mantissa is reduced as much as possible, favourin higher
exponents over lower ones (e.g. returnin 1e7 instead of 10e6 or 10000000e0).
This might chizzle up in tha future, so do not depend on dat shit.
.SS "Accuracy vs. Precision"
.IX Subsection "Accuracy vs. Precision"
See also: Rounding.
.PP
Math::BigFloat supports both precision (roundin ta a cold-ass lil certain place before or
afta tha dot) n' accuracy (roundin ta a cold-ass lil certain number of digits). For a
full documentation, examplez n' tips on these topics please peep tha large
section bout roundin up in Math::BigInt.
.PP
Since thangs like \f(CWsqrt(2)\fR or \f(CW\*(C`1 / 3\*(C'\fR must presented wit a limited
accuracy lest a operation consumes all resources, each operation produces
no mo' than tha axed number of digits.
.PP
If there is no global precision or accuracy set, \fBand\fR tha operation in
question was not called wit a axed precision or accuracy, \fBand\fR the
input \f(CW$x\fR has no accuracy or precision set, then a gangbangin' fallback parameta will
be used. Y'all KNOW dat shit, muthafucka! For oldschool reasons, it is called \f(CW\*(C`div_scale\*(C'\fR n' can be accessed
via:
.PP
.Vb 2
\&        $d = Math::BigFloat\->div_scale();       # query
\&        Math::BigFloat\->div_scale($n);          # set ta $n digits
.Ve
.PP
Da default value fo' \f(CW\*(C`div_scale\*(C'\fR is 40.
.PP
In case tha result of one operation has mo' digits than specified,
it is rounded. Y'all KNOW dat shit, muthafucka! Da roundin mode taken is either tha default mode, or tha one
supplied ta tha operation afta tha \fIscale\fR:
.PP
.Vb 7
\&    $x = Math::BigFloat\->new(2);
\&    Math::BigFloat\->accuracy(5);              # 5 digits max
\&    $y = $x\->copy()\->bdiv(3);                 # will give 0.66667
\&    $y = $x\->copy()\->bdiv(3,6);               # will give 0.666667
\&    $y = $x\->copy()\->bdiv(3,6,undef,\*(Aqodd\*(Aq);   # will give 0.666667
\&    Math::BigFloat\->round_mode(\*(Aqzero\*(Aq);
\&    $y = $x\->copy()\->bdiv(3,6);               # will also give 0.666667
.Ve
.PP
Note dat \f(CW\*(C`Math::BigFloat\->accuracy()\*(C'\fR n' \f(CW\*(C`Math::BigFloat\->precision()\*(C'\fR
set tha global variables, n' thus \fBany\fR newly pimped number is ghon be subject
to tha global roundin \fBimmediately\fR. This means dat up in tha examplez above, the
\&\f(CW3\fR as argument ta \f(CW\*(C`bdiv()\*(C'\fR will also git a accuracy of \fB5\fR.
.PP
It be less confusin ta either calculate tha result fully, n' afterwards
round it explicitly, or use tha additionizzle parametas ta tha math
functions like so:
.PP
.Vb 4
\&        use Math::BigFloat;
\&        $x = Math::BigFloat\->new(2);
\&        $y = $x\->copy()\->bdiv(3);
\&        print $y\->bround(5),"\en";               # will give 0.66667
\&
\&        or
\&
\&        use Math::BigFloat;
\&        $x = Math::BigFloat\->new(2);
\&        $y = $x\->copy()\->bdiv(3,5);             # will give 0.66667
\&        print "$y\en";
.Ve
.SS "Rounding"
.IX Subsection "Rounding"
.IP "ffround ( +$scale )" 2
.IX Item "ffround ( +$scale )"
Roundz ta tha \f(CW$scale\fR'th place left from tha '.', countin from tha dot.
Da first digit is numbered 1.
.IP "ffround ( \-$scale )" 2
.IX Item "ffround ( -$scale )"
Roundz ta tha \f(CW$scale\fR'th place right from tha '.', countin from tha dot.
.IP "ffround ( 0 )" 2
.IX Item "ffround ( 0 )"
Roundz ta a integer.
.IP "fround  ( +$scale )" 2
.IX Item "fround ( +$scale )"
Preserves accuracy ta \f(CW$scale\fR digits from tha left (aka dope digits)
and padz tha rest wit zeros. If tha number is between 1 n' \-1, the
significant digits count from tha straight-up original gangsta non-zero afta tha '.'
.IP "fround  ( \-$scale ) n' fround ( 0 )" 2
.IX Item "fround ( -$scale ) n' fround ( 0 )"
These is effectively no-ops.
.PP
All roundin functions take as a second parameta a roundin mode from one of
the following: 'even', 'odd', '+inf', '\-inf', 'zero', 'trunc' or 'common'.
.PP
Da default roundin mode is 'even'. By using
\&\f(CW\*(C`Math::BigFloat\->round_mode($round_mode);\*(C'\fR you can git n' set tha default
mode fo' subsequent rounding. Da usage of \f(CW\*(C`$Math::BigFloat::$round_mode\*(C'\fR is
no longer supported.
Da second parameta ta tha round functions then overrides tha default
temporarily.
.PP
Da \f(CW\*(C`as_number()\*(C'\fR function returns a BigInt from a Math::BigFloat. Well shiiiit, it uses
\&'trunc' as roundin mode ta make it equivalent to:
.PP
.Vb 2
\&        $x = 2.5;
\&        $y = int($x) + 2;
.Ve
.PP
Yo ass can override dis by passin tha desired roundin mode as parameta to
\&\f(CW\*(C`as_number()\*(C'\fR:
.PP
.Vb 2
\&        $x = Math::BigFloat\->new(2.5);
\&        $y = $x\->as_number(\*(Aqodd\*(Aq);      # $y = 3
.Ve
.SH "METHODS"
.IX Header "METHODS"
Math::BigFloat supports all methodz dat Math::BigInt supports, except it
calculates non-integer thangs up in dis biatch when possible. Please peep Math::BigInt
for a gangbangin' full description of each method. Y'all KNOW dat shit, muthafucka! Below is just da most thugged-out blingin
differences:
.SS "accuracy"
.IX Subsection "accuracy"
.Vb 3
\&        $x\->accuracy(5);             # local fo' $x
\&        CLASS\->accuracy(5);          # global fo' all thugz of CLASS
\&                                     # Note: This also applies ta new()!
\&
\&        $A = $x\->accuracy();         # read up accuracy dat affects $x
\&        $A = CLASS\->accuracy();      # read up global accuracy
.Ve
.PP
Set or git tha global or local accuracy, aka how tha fuck nuff dope digits the
results have. If you set a global accuracy, then dis also applies ta \fInew()\fR!
.PP
Warning! Da accuracy \fIsticks\fR, e.g. once you pimped a number under the
influence of \f(CW\*(C`CLASS\->accuracy($A)\*(C'\fR, all thangs up in dis biatch from math operations with
that number will also be rounded.
.PP
In most cases, you should probably round tha thangs up in dis biatch explicitly rockin one of
\&\*(L"\fIround()\fR\*(R" up in Math::BigInt, \*(L"\fIbround()\fR\*(R" up in Math::BigInt or \*(L"\fIbfround()\fR\*(R" up in Math::BigInt or by passin tha desired accuracy
to tha math operation as additionizzle parameter:
.PP
.Vb 4
\&        mah $x = Math::BigInt\->new(30000);
\&        mah $y = Math::BigInt\->new(7);
\&        print scalar $x\->copy()\->bdiv($y, 2);           # print 4300
\&        print scalar $x\->copy()\->bdiv($y)\->bround(2);   # print 4300
.Ve
.SS "\fIprecision()\fP"
.IX Subsection "precision()"
.Vb 4
\&        $x\->precision(\-2);      # local fo' $x, round all up in tha second
\&                                # digit right of tha dot
\&        $x\->precision(2);       # ditto, round all up in tha second digit left
\&                                # of tha dot
\&
\&        CLASS\->precision(5);    # Global fo' all thugz of CLASS
\&                                # This also applies ta new()!
\&        CLASS\->precision(\-5);   # ditto
\&
\&        $P = CLASS\->precision();    # read up global precision
\&        $P = $x\->precision();       # read up precision dat affects $x
.Ve
.PP
Note: Yo ass probably wanna use \*(L"accuracy\*(R" instead. Y'all KNOW dat shit, muthafucka! With \*(L"accuracy\*(R" you
set tha number of digits each result should have, wit \*(L"\fIprecision()\fR\*(R" you
set tha place where ta round!
.SS "\fIbexp()\fP"
.IX Subsection "bexp()"
.Vb 1
\&        $x\->bexp($accuracy);            # calculate e ** X
.Ve
.PP
Calculates tha expression \f(CW\*(C`e ** $x\*(C'\fR where \f(CW\*(C`e\*(C'\fR is Eulerz number.
.PP
This method was added up in v1.82 of Math::BigInt (April 2007).
.SS "\fIbnok()\fP"
.IX Subsection "bnok()"
.Vb 1
\&        $x\->bnok($y);   # x over y (binomial coefficient n over k)
.Ve
.PP
Calculates tha binomial coefficient n over k, also called tha \*(L"choose\*(R"
function. I aint talkin' bout chicken n' gravy biatch. Da result is equivalent to:
.PP
.Vb 3
\&        ( n )      n!
\&        | \- |  = \-\-\-\-\-\-\-
\&        ( k )    k!(n\-k)!
.Ve
.PP
This method was added up in v1.84 of Math::BigInt (April 2007).
.SS "\fIbpi()\fP"
.IX Subsection "bpi()"
.Vb 1
\&        print Math::BigFloat\->bpi(100), "\en";
.Ve
.PP
Calculate \s-1PI\s0 ta N digits (includin tha 3 before tha dot). Da result is
rounded accordin ta tha current roundin mode, which defaults ta \*(L"even\*(R".
.PP
This method was added up in v1.87 of Math::BigInt (June 2007).
.SS "\fIbcos()\fP"
.IX Subsection "bcos()"
.Vb 2
\&        mah $x = Math::BigFloat\->new(1);
\&        print $x\->bcos(100), "\en";
.Ve
.PP
Calculate tha cosinuz of \f(CW$x\fR, modifyin \f(CW$x\fR up in place.
.PP
This method was added up in v1.87 of Math::BigInt (June 2007).
.SS "\fIbsin()\fP"
.IX Subsection "bsin()"
.Vb 2
\&        mah $x = Math::BigFloat\->new(1);
\&        print $x\->bsin(100), "\en";
.Ve
.PP
Calculate tha sinuz of \f(CW$x\fR, modifyin \f(CW$x\fR up in place.
.PP
This method was added up in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan2()\fP"
.IX Subsection "batan2()"
.Vb 3
\&        mah $y = Math::BigFloat\->new(2);
\&        mah $x = Math::BigFloat\->new(3);
\&        print $y\->batan2($x), "\en";
.Ve
.PP
Calculate tha arcus tangez of \f(CW$y\fR divided by \f(CW$x\fR, modifyin \f(CW$y\fR up in place.
See also \*(L"\fIbatan()\fR\*(R".
.PP
This method was added up in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan()\fP"
.IX Subsection "batan()"
.Vb 2
\&        mah $x = Math::BigFloat\->new(1);
\&        print $x\->batan(100), "\en";
.Ve
.PP
Calculate tha arcus tangez of \f(CW$x\fR, modifyin \f(CW$x\fR up in place. Right back up in yo muthafuckin ass. See also \*(L"\fIbatan2()\fR\*(R".
.PP
This method was added up in v1.87 of Math::BigInt (June 2007).
.SS "\fIbmuladd()\fP"
.IX Subsection "bmuladd()"
.Vb 1
\&        $x\->bmuladd($y,$z);
.Ve
.PP
Multiply \f(CW$x\fR by \f(CW$y\fR, n' then add \f(CW$z\fR ta tha result.
.PP
This method was added up in v1.87 of Math::BigInt (June 2007).
.SH "Autobustin constants"
.IX Header "Autobustin constants"
Afta \f(CW\*(C`use Math::BigFloat \*(Aq:constant\*(Aq\*(C'\fR all tha floatin point constants
in tha given scope is converted ta \f(CW\*(C`Math::BigFloat\*(C'\fR. This conversion
happens at compile time.
.PP
In particular
.PP
.Vb 1
\&  perl \-MMath::BigFloat=:constant \-e \*(Aqprint 2E\-100,"\en"\*(Aq
.Ve
.PP
prints tha value of \f(CW\*(C`2E\-100\*(C'\fR. Note dat without conversion of 
constants tha expression 2E\-100 is ghon be calculated as aiiight floatin point 
number.
.PP
Please note dat ':constant' do not affect integer constants, nor binary 
nor hexadecimal constants, n' you can put dat on yo' toast. Use bignum or Math::BigInt ta git dis to
work.
.SS "Math library"
.IX Subsection "Math library"
Math wit tha numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent ta saying:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqCalc\*(Aq;
.Ve
.PP
Yo ass can chizzle dis by using:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqGMP\*(Aq;
.Ve
.PP
\&\fBNote\fR: General purpose packages should not be explicit bout tha library
to use; let tha script lyricist decizzle which is best.
.PP
Note: Da keyword 'lib' will warn when tha axed library could not be
loaded. Y'all KNOW dat shit, muthafucka! To suppress tha warnin use 'try' instead:
.PP
.Vb 1
\&        use Math::BigFloat try => \*(AqGMP\*(Aq;
.Ve
.PP
If yo' script works wit big-ass numbers n' Calc is too slow fo' them,
you can also fo' tha loadin of one of these libraries n' if none
of dem can be used, tha code will die:
.PP
.Vb 1
\&        use Math::BigFloat only => \*(AqGMP,Pari\*(Aq;
.Ve
.PP
Da followin would first try ta find Math::BigInt::Foo, then
Math::BigInt::Bar, n' when dis also fails, revert ta Math::BigInt::Calc:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
See tha respectizzle low-level library documentation fo' further details.
.PP
Please note dat Math::BigFloat do \fBnot\fR use tha denoted library itself,
but it merely passes tha lib argument ta Math::BigInt. Right back up in yo muthafuckin ass. So, instead of tha need
to do:
.PP
.Vb 2
\&        use Math::BigInt lib => \*(AqGMP\*(Aq;
\&        use Math::BigFloat;
.Ve
.PP
you can roll all dat shiznit tha fuck into one line:
.PP
.Vb 1
\&        use Math::BigFloat lib => \*(AqGMP\*(Aq;
.Ve
.PP
It be also possible ta just require Math::BigFloat:
.PP
.Vb 1
\&        require Math::BigFloat;
.Ve
.PP
This will load tha necessary thangs (like BigInt) when they is needed, and
automatically.
.PP
See Math::BigInt fo' mo' details than you eva wanted ta know bout using
a different low-level library.
.SS "Usin Math::BigInt::Lite"
.IX Subsection "Usin Math::BigInt::Lite"
For backwardz compatibilitizzle reasons it is still possible to
request a gangbangin' finger-lickin' different storage class fo' use wit Math::BigFloat:
.PP
.Vb 1
\&        use Math::BigFloat wit => \*(AqMath::BigInt::Lite\*(Aq;
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat dis request is ignored, as tha current code now uses tha low-level
math library fo' directly storin tha number parts.
.SH "EXPORTS"
.IX Header "EXPORTS"
\&\f(CW\*(C`Math::BigFloat\*(C'\fR exports not a god damn thang by default yo, but can export tha \f(CW\*(C`bpi()\*(C'\fR method:
.PP
.Vb 1
\&        use Math::BigFloat qw/bpi/;
\&
\&        print bpi(10), "\en";
.Ve
.SH "BUGS"
.IX Header "BUGS"
Please peep tha file \s-1BUGS\s0 up in tha \s-1CPAN\s0 distribution Math::BigInt fo' known bugs.
.SH "CAVEATS"
.IX Header "CAVEATS"
Do not try ta be smart-ass ta bang some operations up in between switching
libraries:
.PP
.Vb 4
\&    require Math::BigFloat;
\&    mah $matta = Math::BigFloat\->bone() + 4;    # load BigInt n' Calc
\&    Math::BigFloat\->import( lib => \*(AqPari\*(Aq );    # load Pari, too
\&    mah $anti_matta = Math::BigFloat\->bone()+4; # now use Pari
.Ve
.PP
This will create objects wit numbers stored up in two different backend libraries,
and \fB\s-1VERY BAD THINGS\s0\fR will happen when you use these together:
.PP
.Vb 1
\&        mah $flash_and_bang = $matta + $anti_matter;    # Don\*(Aqt do this!
.Ve
.IP "stringify, \fIbstr()\fR" 1
.IX Item "stringify, bstr()"
Both stringify n' \fIbstr()\fR now drop tha leadin '+'. Da oldschool code would return
\&'+1.23', tha freshly smoked up returns '1.23'. Right back up in yo muthafuckin ass. See tha documentation up in Math::BigInt for
reasonin n' details.
.IP "bdiv" 1
.IX Item "bdiv"
Da followin will probably not print what tha fuck you expect:
.Sp
.Vb 1
\&        print $c\->bdiv(123.456),"\en";
.Ve
.Sp
It prints both quotient n' remainder since print works up in list context fo' realz. Also,
\&\fIbdiv()\fR will modify \f(CW$c\fR, so be careful naaahhmean? Yo ass probably wanna use
.Sp
.Vb 2
\&    print $c / 123.456,"\en";
\&    print scalar $c\->bdiv(123.456),"\en";  # or if you wanna modify $c
.Ve
.Sp
instead.
.IP "brsft" 1
.IX Item "brsft"
Da followin will probably not print what tha fuck you expect:
.Sp
.Vb 2
\&        mah $c = Math::BigFloat\->new(\*(Aq3.14159\*(Aq);
\&        print $c\->brsft(3,10),"\en";     # prints 0.00314153.1415
.Ve
.Sp
It prints both quotient n' remainder, since print calls \f(CW\*(C`brsft()\*(C'\fR up in list
context fo' realz. Also, \f(CW\*(C`$c\->brsft()\*(C'\fR will modify \f(CW$c\fR, so be careful.
Yo ass probably wanna use
.Sp
.Vb 3
\&        print scalar $c\->copy()\->brsft(3,10),"\en";
\&        # or if you straight-up wanna modify $c
\&        print scalar $c\->brsft(3,10),"\en";
.Ve
.Sp
instead.
.IP "Modifyin n' =" 1
.IX Item "Modifyin n' ="
Beware of:
.Sp
.Vb 2
\&        $x = Math::BigFloat\->new(5);
\&        $y = $x;
.Ve
.Sp
It aint gonna do what tha fuck you think, e.g. bustin a cold-ass lil copy of \f(CW$x\fR. Instead it just makes
a second reference ta tha \fBsame\fR object n' stores it up in \f(CW$y\fR. Thus anything
that modifies \f(CW$x\fR will modify \f(CW$y\fR (except overloaded math operators), n' vice
versa. Right back up in yo muthafuckin ass. See Math::BigInt fo' details n' how tha fuck ta avoid dis shit.
.IP "bpow" 1
.IX Item "bpow"
\&\f(CW\*(C`bpow()\*(C'\fR now modifies tha straight-up original gangsta argument, unlike tha oldschool code which left
it ridin' solo n' only returned tha result. This is ta be consistent with
\&\f(CW\*(C`badd()\*(C'\fR etc. Da first will modify \f(CW$x\fR, tha second one won't:
.Sp
.Vb 3
\&        print bpow($x,$i),"\en";         # modify $x
\&        print $x\->bpow($i),"\en";        # ditto
\&        print $x ** $i,"\en";            # leave $x alone
.Ve
.IP "\fIprecision()\fR vs. \fIaccuracy()\fR" 1
.IX Item "precision() vs. accuracy()"
A common pitfall is ta use \*(L"\fIprecision()\fR\*(R" when you wanna round a result to
a certain number of digits:
.Sp
.Vb 1
\&    use Math::BigFloat;
\&
\&    Math::BigFloat\->precision(4);            # do not do what tha fuck you
\&                                             # be thinkin it do
\&    mah $x = Math::BigFloat\->new(12345);      # roundz $x ta "12000"!
\&    print "$x\en";                            # print "12000"
\&    mah $y = Math::BigFloat\->new(3);          # roundz $y ta "0"!
\&    print "$y\en";                            # print "0"
\&    $z = $x / $y;                            # 12000 / 0 => NaN!
\&    print "$z\en";
\&    print $z\->precision(),"\en";              # 4
.Ve
.Sp
Replacin \*(L"\fIprecision()\fR\*(R" wit \*(L"accuracy\*(R" is probably not what tha fuck you want, either:
.Sp
.Vb 1
\&    use Math::BigFloat;
\&
\&    Math::BigFloat\->accuracy(4);             # enablez global rounding:
\&    mah $x = Math::BigFloat\->new(123456);     # rounded immediately
\&                                             #   ta "12350"
\&    print "$x\en";                            # print "123500"
\&    mah $y = Math::BigFloat\->new(3);          # rounded ta "3
\&    print "$y\en";                            # print "3"
\&    print $z = $x\->copy()\->bdiv($y),"\en";    # 41170
\&    print $z\->accuracy(),"\en";               # 4
.Ve
.Sp
What you wanna use instead is:
.Sp
.Vb 1
\&    use Math::BigFloat;
\&
\&    mah $x = Math::BigFloat\->new(123456);     # no rounding
\&    print "$x\en";                            # print "123456"
\&    mah $y = Math::BigFloat\->new(3);          # no rounding
\&    print "$y\en";                            # print "3"
\&    print $z = $x\->copy()\->bdiv($y,4),"\en";  # 41150
\&    print $z\->accuracy(),"\en";               # undef
.Ve
.Sp
In addizzle ta computin what tha fuck you expected, tha last example also do \fBnot\fR
\&\*(L"taint\*(R" tha result wit a accuracy or precision setting, which would
influence any further operation.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::BigInt, Math::BigRat n' Math::Big as well as
Math::BigInt::Pari n'  Math::BigInt::GMP.
.PP
Da pragmas bignum, bigint n' bigrat might also be of interest
because they solve tha autoupgrading/downgradin issue, at least kinda.
.PP
Da package at <http://search.cpan.org/~tels/Math\-BigInt> gotz nuff
more documentation includin a gangbangin' full version history, testcases, empty
subclass filez n' benchmarks.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Mark Biggar, overloaded intercourse by Ilya Zakharevich.
All Out rewritten by Tels <http://bloodgate.com> up in 2001 \- 2006, n' still
at it up in 2007.
