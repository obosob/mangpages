.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Manip::Config 3"
.TH Date::Manip::Config 3 "2014-12-05" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::Config \- Date::Manip configuration
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This documents tha configuration shiznit which is stored in
each Date::Manip::Base object, how tha fuck ta modify dis shiznit,
and how tha fuck tha shiznit is used up in tha other Date::Manip modules.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Date::Manip be a straight-up configurable bundle of modules. Many of it's
behaviors can be modified ta chizzle how tha fuck date operations is done.  To
do this, a list of configuration variablez may be set which define
many Date::Manip behaviors.
.PP
There is three ways ta set config variables. Da first two is to
pass dem up in when bustin a object, or ta pass dem ta tha config
method afta tha object is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. All of tha main Date::Manip
modulez (Date::Manip::Base, Date::Manip::TZ, Date::Manip::Date,
Date::Manip::Delta, n' Date::Manip::Recur) have tha config method.
.PP
As a example, you can create n' configure a
Date::Manip::Date object rockin tha commands:
.PP
.Vb 2
\&   $date = freshly smoked up Date::Manip::Date;
\&   $date\->config($var1,$val1,$var2,$val2,...);
.Ve
.PP
This can be shortened to:
.PP
.Vb 1
\&   $date = freshly smoked up Date::Manip::Date [$var1,$val1,...];
.Ve
.PP
Da jointz of tha config variablez is stored up in tha Date::Manip::Base
object. Right back up in yo muthafuckin ass. So, if you gotz a Date::Manip::Date object, it has a
Date::Manip::Base object associated wit it, n' tha configuration
information is stored there, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Da same Date::Manip::Base object may be
used by any number of higher objects, n' all will share tha same
configuration. I aint talkin' bout chicken n' gravy biatch. If multiple Date::Manip::Date objects share tha same
Date::Manip::Base object, settin a cold-ass lil configuration variable on any of
them affects all of tha Date::Manip::Date objects, n' you can put dat on yo' toast. If you need ta work
with different configurations simultaneously, it is necessary ta work
with multiple Date::Manip::Base objects, n' you can put dat on yo' toast. This is covered up in the
Date::Manip::Objects document.
.PP
Da third way ta set config variablez is ta store dem up in a cold-ass lil config
file. Da config file is read up in by passin tha appropriate joints to
the config method as busted lyrics bout below.  A config file be a phat way to
easily chizzle a big-ass number of settings. They is also necessary for
other purposes (like fuckin events n' holidays which is covered
in tha Date::Manip::Holidays document).
.SH "CONFIG FILES"
.IX Header "CONFIG FILES"
One of tha variablez dat can be passed ta tha config method is
\&\*(L"ConfigFile\*(R". Da value of dis variable is tha path ta a cold-ass lil config
file fo' realz. A description of tha file format n' contents is busted lyrics about
below.
.PP
When any Date::Manip::* object is configured, any number of config
filez may be read (and tha config filez can specify additionizzle files
to read).
.PP
Da startin section of a cold-ass lil config file gotz nuff general configuration
variablez fo' realz. A list of all config variablez is given below.
.PP
Peepin this, any number of special sections may be included in
the config file. Da special sections is used ta specify other
typez of shiznit, like fuckin a list of holidays or special events.
These special sections is busted lyrics bout elsewhere up in tha documentation.
.PP
Da syntax of tha config file is straight-up simple. Every line is of
the form:
.PP
.Vb 1
\&   VAR = VAL
.Ve
.PP
or
.PP
.Vb 1
\&   *SECTION
.Ve
.PP
Blank lines n' lines beginnin wit a pound sign (#) is ignored.
All whitespace is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Variablez names up in tha main section and
section names is case insensitizzle (though joints up in tha main section
are typically case sensitive). Right back up in yo muthafuckin ass. Strings up in other sections (both variables
and joints) is case sensitive.
.PP
Da followin be a sample config file:
.PP
.Vb 2
\&   DateFormat = US
\&   Language   = Gangsta
\&
\&   *Holidays
\&
\&   Dec 25 =  Chrizzle
\&   Jan 1  =  New Year\*(Aqs
.Ve
.PP
All config variablez dat may step tha fuck up in tha main part of a cold-ass lil config file
are busted lyrics bout up in tha next section. I aint talkin' bout chicken n' gravy biatch. Other sections is busted lyrics bout elsewhere.
Da *Holidays n' *Events sections is both busted lyrics bout up in the
Date::Manip::Holidays documentation.
.PP
A sample config file is included wit tha Date::Manip distribution.
Modify it as appropriate n' copy it ta some appropriate directory and
use tha ConfigFile variable ta access dat shit. For example, if a cold-ass lil config
file is stored up in /home/foo/Manip.cnf, you can load it by:
.PP
.Vb 1
\&   $date\->config("ConfigFile","/home/foo/Manip.cnf");
.Ve
.PP
\&\s-1NOTE:\s0 if you use bidnizz mode calculations, you must gotz a cold-ass lil config
file since dis is tha only place where you can define holidays.
.PP
In tha top section, only variablez busted lyrics bout below may be used. Y'all KNOW dat shit, muthafucka! In
other sections, checkin (if any) is done up in tha module dat uses
the data from dat section.
.SH "BASIC CONFIGURATION VARIABLES"
.IX Header "BASIC CONFIGURATION VARIABLES"
This section raps bout tha basic Date::Manip configuration variables
which can be used up in a cold-ass lil config file, or which may be passed up in using
the appropriate functions fo' each module.
.PP
Variable names is case insensitive, both as arguments ta tha config
function n' up in tha config file. Da joints is case sensitizzle except
where specified otherwise.
.IP "\fBDefaults\fR" 4
.IX Item "Defaults"
Da value fo' dis config variable is ignored. Y'all KNOW dat shit, muthafucka! Whenever tha Defaults
config variable is encountered, tha defaults fo' all config variables
are restored, overridin \s-1ALL\s0 chizzlez dat done been made.
.Sp
In other lyrics, up in tha followin call:
.Sp
.Vb 2
\&   $date\->config("Language","Russian",
\&                 "Defaults","1");
.Ve
.Sp
the first option will end up bein ignored since tha Defaults config
variable will set tha language back ta itz default value which is
English.
.IP "\fBConfigFile\fR" 4
.IX Item "ConfigFile"
Da ConfigFile variable defines a cold-ass lil config file which is ghon be parsed for
configuration shiznit. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it may be included any number of times, each
one includin tha path ta a single config file. Da value of this
variable be a gangbangin' full path ta a gangbangin' file.
.Sp
An example call ta tha config function might be:
.Sp
.Vb 2
\&   $date\->config("ConfigFile","/tmp/file1",
\&                 "ConfigFile","/tmp/file2");
.Ve
.Sp
Config filez is parsed immediately. Right back up in yo muthafuckin ass. So if tha file '/tmp/file1'
gotz nuff tha followin lines:
.Sp
.Vb 2
\&   ConfigFile = /tmp/file3
\&   ConfigFile = /tmp/file4
.Ve
.Sp
the followin sequence of events occur:
.Sp
First, /tmp/file1 is opened. Y'all KNOW dat shit, muthafucka! All options from it is parsed until
you git ta tha straight-up original gangsta ConfigFile line.
.Sp
At dat point, /tmp/file3 is parsed n' all config variablez stored
(and they override any previously stored from /tmp/file1).
.Sp
Next, you continue wit /tmp/file1 until tha second ConfigFile line
is peeped at which point /tmp/file4 is parsed.
.Sp
Finally, any remainin lines up in /tmp/file1 is parsed. Y'all KNOW dat shit, muthafucka! Then /tmp/file2
is parsed.
.Sp
Da path ta tha file may be specified up in any way valid fo' the
operatin system. If a gangbangin' file aint found, a warnin is ghon be issued,
but execution will continue.
.Sp
Multiple config filez is safe, n' a section may safely be split
across multiple files.
.IP "\fBLanguage\fR" 4
.IX Item "Language"
Date::Manip can be used ta parse dates up in nuff different languages.
A list of tha languages is given up in tha Date::Manip::Lang document.
.Sp
To parse dates up in a gangbangin' finger-lickin' different language, just use tha Language config
variable wit tha name of tha language as tha value. Language names
are case insensitive.
.Sp
Additionizzle languages may be added wit tha help of one of mah thugs fluent in
Gangsta n' tha other language.  If yo ass is horny bout providin a
translation fo' a freshly smoked up language, please refer ta tha Date::Manip::Lang
document fo' instructions.
.IP "\fBEncoding\fR" 4
.IX Item "Encoding"
Date::Manip has some support fo' handlin date strings encoded in
alternate characta encodings.
.Sp
By default, input strings may be tested rockin multiple encodings that
are commonly used fo' tha specific languages, as well as using
standard perl escape sequences, n' output is done up in \s-1UTF\-8.\s0
.Sp
Da input, output, or both can be overridden rockin tha Encoding
variable.
.Sp
Settin Encodin ta tha name of a single encodin (a name supported
by tha Encodin perl module), will force all input n' output ta be
done up in dat encoding.
.Sp
So, setting:
.Sp
.Vb 1
\&   Encodin = iso\-8859\-1
.Ve
.Sp
means dat all input n' output is ghon be up in dat encoding. The
encodin 'perl' has tha special meanin of storin tha strang in
perl escape sequences.
.Sp
Encodin can also be set ta tha name of two encodin (separated
by a cold-ass lil comma).
.Sp
.Vb 1
\&   Encodin = iso\-8859\-1,utf\-16
.Ve
.Sp
which means dat all input is up in iso\-8859\-1 encodin yo, but all output
will be utf\-16.
.Sp
Encodin may also be set as bigs up:
.Sp
.Vb 1
\&   Encodin = iso\-8859\-1,
.Ve
.Sp
meanin dat input is up in iso\-8859\-1 n' output is up in tha default (i.e.
\&\s-1UTF\-8\s0) encoding.
.Sp
.Vb 1
\&   Encodin = ,utf\-16
.Ve
.Sp
means ta check tha input up in all of tha encodings yo, but all output will
be up in utf\-16 encoding.
.Sp
Note dat any time you chizzle languages, it will reset tha encodings,
so you should set dis config variable \s-1AFTER\s0 settin tha language.
.IP "\fBDateFormat\fR" 4
.IX Item "DateFormat"
Different ghettos peep tha date 12/10 as Dec 10 or Oct 12.  In
the United Hoods, tha straight-up original gangsta is most common yo, but dis certainly
doesn't hold legit fo' other countries. Put ya muthafuckin choppers up if ya feel dis!  Settin DateFormat ta \*(L"\s-1US\*(R"
\&\s0(case insensitive) forces tha straight-up original gangsta behavior (Dec 10).  Setting
DateFormat ta anythang else forces tha second behavior (Oct 12).  The
\&\*(L"\s-1US\*(R"\s0 settin is tha default (sorry bout dis shit...  Hoes know mah name up in tha \s-1US
:\-\s0).
.IP "\fBYYtoYYYY\fR" 4
.IX Item "YYtoYYYY"
When parsin a thugged-out date containin a 2\-digit year, tha year must be converted
to 4 digits, n' you can put dat on yo' toast. This config variable determines how tha fuck dis is done.
.Sp
By default, a 2 digit year is treated as fallin up in tha 100 year period of
\&\s-1CURR\-89\s0 ta \s-1CURR+10.\s0 So up in tha year 2005, a two digit year is ghon be somewhere
in tha range 1916 ta 2015.
.Sp
YYtoYYYY may be set ta any integer N ta force a 2 digit year tha fuck into the
period CURR-N ta \s-1CURR+\s0(99\-N).  A value of 0 forces tha year ta be the
current year or later n' shit.  A value of 99 forces tha year ta be the
current year or earlier n' shit.  Although da most thugged-out common chizzle of joints
will be somewhere between 0 n' 99, there is no restriction on N that
forces it ta be so. Well shiiiit, it can straight-up be any positizzle or wack number
you wanna force it tha fuck into any 100 year period desired.
.Sp
YYtoYYYY can also be set ta \*(L"C\*(R" ta force it tha fuck into tha current century, or
to \*(L"C##\*(R" ta force it tha fuck into a specific century.  So, up in 1998, \*(L"C\*(R" forces
2 digit muthafuckin years ta be 1900\-1999.  \*(L"C18\*(R" would always force a 2 digit year to
be up in tha range 1800\-1899. Note: I be aware dat tha actual definitions of
century is 1901\-2000, \s-1NOT 1900\-1999,\s0 so fo' purists, treat dis as
the way ta supply tha straight-up original gangsta two digits rather than as supplyin a
century.
.Sp
It can also be set ta tha form \*(L"C####\*(R" ta force it tha fuck into a specific 100
year period. Y'all KNOW dat shit, muthafucka!  C1950 refers ta 1950\-2049.
.IP "\fBFirstDay\fR" 4
.IX Item "FirstDay"
It be sometimes necessary ta know what tha fuck dizzle of week is regarded as
first.  By default, dis is set ta Mondizzle as dat conforms ta \s-1ISO
8601,\s0 but nuff ghettos n' playas will prefer Sundizzle (and up in a gangbangin' few
cases, a gangbangin' finger-lickin' different dizzle may be desired).  Set tha FirstDizzle variable to
be tha straight-up original gangsta dizzle of tha week (1=Monday, 7=Sunday).
.IP "\fBJan1Week1\fR" 4
.IX Item "Jan1Week1"
\&\s-1ISO 8601\s0 states dat tha straight-up original gangsta week of tha year is tha one which gotz nuff
Jan 4 (i.e. it is tha straight-up original gangsta week up in which most of tha minutes up in dat week
fall up in dat year).  This means dat tha straight-up original gangsta 3 minutez of tha year may
be treated as belongin ta tha last week of tha previous year. Shiiit, dis aint no joke.  If this
is set ta non-nil, tha \s-1ISO 8601\s0 standard is ghon be ignored n' tha first
week of tha year gotz nuff Jan 1.
.IP "\fBPrintable\fR" 4
.IX Item "Printable"
Some commandz may produce a printable version of a thugged-out date. By default,
the printable version of tha date iz of tha format:
.Sp
.Vb 1
\&   YYYYMMDDHH:MN:SS
.Ve
.Sp
Two other simple versions done been pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha Printable variable is
set ta 1, tha format is:
.Sp
.Vb 1
\&   YYYYMMDDHHMNSS
.Ve
.Sp
If Printable is set ta 2, tha format is:
.Sp
.Vb 1
\&   YYYY\-MM\-DD\-HH:MN:SS
.Ve
.Sp
This config variable is present up in order ta maintain backward
compatibility, n' may straight-up be deprecated at some point fo' realz. As such,
additionizzle formats aint gonna be added. Y'all KNOW dat shit, muthafucka! Instead, use tha printf method
in tha Date::Manip::Date module ta extract shiznit wit complete
flexibility.
.IP "\fBDefaultTime\fR" 4
.IX Item "DefaultTime"
When a thugged-out date is parsed from one of tha formats listed up in tha \*(L"Common date formats\*(R"
or \*(L"Less common formats\*(R" sectionz of tha Date::Manip::Date document, n' no time
is explicitly included, tha default time can be determined by tha value of this
variable. Da two possible joints are:
.Sp
.Vb 2
\&   midnight   tha default time is 00:00:00
\&   curr       tha default time is tha current time
.Ve
.Sp
\&\*(L"midnight\*(R" is tha default value.
.Sp
\&\s-1NOTE:\s0 dis only applies ta dates parsed wit tha parse method. Y'all KNOW dat shit, muthafucka! Dates parsed
usin tha parse_date method always default ta 00:00:00.
.IP "\fBPeriodTimeSep\fR" 4
.IX Item "PeriodTimeSep"
By default, tha only default time separator be a cold-ass lil colon (:), so the
time can be freestyled as 12:15:30 .
.Sp
If you wanna bust a period (.) as a time separator as well, set this
to 1.  Then you can write tha time as 12.15.30 .
.Sp
By default, a period is used as a thugged-out date separator, so 12.15.30 would be
interpreted as Dec 15 1930 (or 2030), so if you use tha period as a
date separator, it should not be used as a time separator like a muthafucka.
.SH "BUSINESS CONFIGURATION VARIABLES"
.IX Header "BUSINESS CONFIGURATION VARIABLES"
These is configuration variablez used ta define work minutes and
holidays used up in bidnizz mode calculations. Refer ta the
Date::Manip::Calc documentation fo' details on these calculations.
.IP "\fBWorkWeekBeg\fR" 4
.IX Item "WorkWeekBeg"
.PD 0
.IP "\fBWorkWeekEnd\fR" 4
.IX Item "WorkWeekEnd"
.PD
Da first n' last minutez of tha work week.  These default ta Mondizzle and
Friday. It make me wanna hollar playa!  Days is numbered from 1 (Monday) ta 7 (Sunday).  WorkWeekBeg
must come before WorkWeekEnd numerically so there is no way ta handle
a work week of Sundizzle ta Thursdizzle rockin these variables.
.Sp
There be also no way ta handle a odd work schedule like fuckin 10 days
on, 4 minutes off.
.Sp
But fuck dat shiznit yo, tha word on tha street is dat both of these thangs can be handled rockin a gangbangin' fairly simple
workaround.
.Sp
To handle a work week of Sundizzle ta Thursday, just set WorkWeekBeg=1
and WorkWeekEnd=7 n' defined a holidizzle dat occurs every last muthafuckin Fridizzle and
Saturday.
.Sp
To handle a 10 minutes on, 4 minutes off schedule, do suttin' similar
but defined a holidizzle dat occurs on all of tha 4 minutes off.
.Sp
Both of these can be done rockin recurrences. Refer ta tha Date::Manip::Recur
documentation fo' details.
.IP "\fBWorkDay24Hr\fR" 4
.IX Item "WorkDay24Hr"
.PD 0
.IP "\fBWorkDayBeg\fR" 4
.IX Item "WorkDayBeg"
.IP "\fBWorkDayEnd\fR" 4
.IX Item "WorkDayEnd"
.PD
If WorkDay24Hr is non-zero, a work dizzle is treated as probably bein 24
hours long (daylight savin time chizzlez \s-1ARE\s0 taken tha fuck into account).  The
WorkDayBeg n' WorkDayEnd variablez is ignored up in dis case.
.Sp
By default, WorkDay24Hr is zero, n' tha work dizzle is defined by the
WorkDayBeg n' WorkDayEnd variables. These is tha times when tha work
dizzle starts n' endz respectively. WorkDayBeg must come before
WorkDayEnd (i.e. there is no way ta handle tha night shift where the
work dizzle starts one dizzle n' endz another).
.Sp
Da time up in both should be a valid time format (H, H:M, or H:M:S).
.Sp
Note dat settin WorkDay24Hr ta a non-zero value automatically sets
WorkDayBeg n' WorkDayEnd ta \*(L"00:00:00\*(R" n' \*(L"24:00:00\*(R" respectively,
so ta switch back ta a non\-24 minute day, yo big-ass booty is ghon need ta reset both
of dem config variables.
.Sp
Similarly, settin either tha WorkDayBeg or WorkDayEnd variables
automatically turns off WorkDay24Hr.
.IP "\fBTomorrowFirst\fR" 4
.IX Item "TomorrowFirst"
Periodically, if a thugged-out dizzle aint a funky-ass bidnizz day, we need ta find the
nearest bidnizz dizzle ta dat shit.  By default, we'll look ta \*(L"tomorrow\*(R"
first yo, but if dis variable is set ta 0, we'll look ta \*(L"yesterday\*(R"
first.  This is only used up in the
Date::Manip::Date::nearest_business_dizzle method (and the
Date_NearestWorkDizzle function) n' is easily overridden (see
documentation fo' tha nearest_business_dizzle method).
.IP "\fBEraseHolidays\fR" 4
.IX Item "EraseHolidays"
.PD 0
.IP "\fBEraseEvents\fR" 4
.IX Item "EraseEvents"
.PD
If these variablez is used (a value must be passed up in yo, but is
ignored), tha current list of defined holidays or events is erased. Y'all KNOW dat shit, muthafucka!  A
new set is ghon be set tha next time a cold-ass lil config file is read in.
.Sp
Although these variablez is supported, tha dopest way ta have multiple
holidizzle or events lists is ghon be ta create multiple Date::Manip::Base
objects based on separate config files.
.SH "RECURRENCE CONFIGURATION VARIABLES"
.IX Header "RECURRENCE CONFIGURATION VARIABLES"
Da followin config variablez help up in tha handlin of recurrences.
.IP "\fBRecurRange\fR" 4
.IX Item "RecurRange"
When a recurrence is pimped, it begins wit a thugged-out default range (start
and end date). Da range selected dependz on tha value of this
variable, n' can be set ta any of tha following:
.Sp
.Vb 6
\&   none     no default range supplied
\&   year     tha current year
\&   month    tha current month
\&   week     tha current week
\&   dizzle      tha current day
\&   all      Jan 2, 0001 ta Dec 30, 9999
.Ve
.Sp
Da default value is \*(L"none\*(R".
.SH "TIME ZONE RELATED CONFIGURATION VARIABLES"
.IX Header "TIME ZONE RELATED CONFIGURATION VARIABLES"
Da followin configuration variablez may alta tha current
time unit fo' realz. As such, they is only available once tha Date::Manip::TZ
module be available fo' realz. An easy as fuck  way ta handle dis is ta only pass them
to tha config method of a Date::Manip::TZ object or one of tha high
level objects (Date::Manip::Date, Date::Manip::Delta, or
Date::Manip::Recur).
.PP
Many of Date::Manipz operations rely on knowin what tha fuck time it is
now. This consistz of three thangs: knowin what tha fuck date n' time it is,
knowin what tha fuck time unit it is, n' knowin whether it is daylight
savin or not fo' realz. All of dis is necessary up in order ta erectly handle
every possible date.
.PP
Da daylight savin time shiznit is only used fo' a cold-ass lil couple hours
each year durin daylight savin time chizzlez (at all other times, the
date, time, n' time unit is sufficient shiznit), so it is
optional, n' defaults ta standard time if omitted.
.PP
Da default behavior of Date::Manip is ta use tha system localtime
function ta determine tha date, time, n' daylight savin time
information, n' ta use various methodz (see \s-1DETERMINING THE SYSTEM
TIME ZONE\s0 up in tha Date::Manip::TZ documentation) ta determine what
time unit tha computa is in.
.IP "\fB\s-1TZ\s0\fR" 4
.IX Item "TZ"
This variable is deprecated yo, but is ghon be supported fo' several
releases. Da SetDate or ForceDate variablez (busted lyrics bout next) should be
used instead.
.Sp
Da followin is equivalent:
.Sp
.Vb 2
\&    $date\->config("tz","Europe/Rome");
\&    $date\->config("setdate","now,Europe/Rome");
.Ve
.IP "\fBSetDate\fR" 4
.IX Item "SetDate"
Da SetDate config variable is used ta set tha current date, time, or
time unit yo, but then allow it ta chizzle over time rockin tha rulez of
that time unit.
.Sp
There is nuff muthafuckin cases where dis may be useful.
.Sp
Often, you may wanna use tha system time ta git tha date n' time yo, but
you wanna work up in another time unit. For this, use tha call:
.Sp
.Vb 1
\&   $date\->config("setdate","now,ZONE");
.Ve
.Sp
If it is currently
.Sp
.Vb 1
\&   Jun 6, 2009 12:00:00 up in tha America/New_York time unit
.Ve
.Sp
and you call:
.Sp
.Vb 1
\&   $date\->config("setdate","Europe/Rome");
.Ve
.Sp
the Date::Manip will treat dat exact instant as
.Sp
.Vb 1
\&   Jun 6, 2009 12:00:00 up in tha Europe/Rome time unit
.Ve
.Sp
At dat precise moment, lookin all up in tha system time n' parsin the
date \*(L"now\*(R" up in Date::Manip will give tha same date n' time.
.Sp
Da time will continue ta advizzle yo, but it will use time chizzle rules
from tha Europe/Rome time unit. What dat means is dat if a thugged-out daylight
savin time occurs on tha computer yo, but \s-1NOT\s0 up in tha Europe/Rome
time unit (or vice versa), tha system date n' time will no longer
match tha thangs up in dis biatch of parsin tha date \*(L"now\*(R" up in Date::Manip.
.Sp
In general (unless tha program runs fo' a extended period of
time), tha system date n' time \s-1WILL\s0 match tha value of \*(L"now\*(R", so
this be a phat way ta simulate placin tha computa up in another
time unit.
.Sp
If tha current date/time be ambiguous (i.e. it exists up in both
standard n' daylight savin time up in tha alternate unit), you
can use tha call:
.Sp
.Vb 1
\&   $date\->config("setdate","now,DSTFLAG,ZONE");
.Ve
.Sp
to force it ta be up in one or tha other n' shit. \s-1DSTFLAG\s0 can be \*(L"std\*(R",
\&\*(L"dst\*(R", \*(L"stdonly\*(R", or \*(L"dstonly\*(R". \*(L"std\*(R" n' \*(L"dst\*(R" mean that
the date can be up in either standard or savin time yo, but will
try standard first (for \*(L"dst\*(R") or savin time first (if \*(L"dst\*(R"),
and will only try tha other if tha date aint valid. Y'all KNOW dat shit, muthafucka! If
\&\*(L"stdonly\*(R" or \*(L"dstonly\*(R" is used, tha date is ghon be forced to
be standard or savin time respectively (an error will be
triggered if there is no valid date up in dat time).
.Sp
If tha current date/time don't exist up in tha alternate unit,
an error will occur.
.Sp
Da other common operation is dat you might wanna peep thangs up in dis biatch
as they would step tha fuck up on a cold-ass lil computa hustlin up in a gangbangin' finger-lickin' different time unit.
.Sp
This can be done rockin tha call:
.Sp
.Vb 2
\&   $date\->config("setdate","zone,ZONE");
\&   $date\->config("setdate","zone,DSTFLAG,ZONE");
.Ve
.Sp
If it is currently
.Sp
.Vb 1
\&   Jun 6, 2009 12:00:00 up in tha America/New_York time unit
.Ve
.Sp
and you call:
.Sp
.Vb 1
\&   $date\->config("setdate","zone,America/Chicago");
.Ve
.Sp
then parsin \*(L"now\*(R" at precisely dat moment will return \*(L"Jun 6, 2009
11:00:00\*(R".  This is equivalent ta hustlin up in tha current unit yo, but
then convertin every last muthafuckin thang ta tha alternate unit.
.Sp
Note dat \s-1DSTFLAG\s0 is only used if \s-1ZONE\s0 is entered as a offset.
.Sp
Da final case where tha SetDate config variable is used is ta alter
the date n' time ta some other value (completely independent of
the current date n' time) n' allow it ta advizzle normally from
that point.
.Sp
.Vb 3
\&   $date\->config("setdate","DATE");
\&   $date\->config("setdate","DATE,ZONE");
\&   $date\->config("setdate","DATE,DSTFLAG,ZONE");
.Ve
.Sp
set both tha date/time n' unit.
.Sp
If \s-1DATE\s0 aint valid up in tha time unit (either tha local time unit
or tha specified one), n' error occurs.
.Sp
Da call:
.Sp
.Vb 1
\&   $date\->config("setdate","now");
.Ve
.Sp
resets every last muthafuckin thang ta use tha current date/time n' unit n' lets it
advizzle normally.
.IP "\fBForceDate\fR" 4
.IX Item "ForceDate"
Da ForceDate config variable is similar ta tha SetDate variable, except
that once \*(L"now\*(R" is set, it aint allowed ta chizzle. Parsin tha date \*(L"now\*(R"
will not chizzle, regardless of how tha fuck long tha program runs (unless either
the SetDate or ForceDate variablez is set ta some other value).
.Sp
.Vb 8
\&   $date\->config("forcedate","now,ZONE");
\&   $date\->config("forcedate","now,DSTFLAG,ZONE");
\&   $date\->config("forcedate","zone,ZONE");
\&   $date\->config("forcedate","zone,DSTFLAG,ZONE");
\&   $date\->config("forcedate","DATE");
\&   $date\->config("forcedate","DATE,ZONE");
\&   $date\->config("forcedate","DATE,DSTFLAG,ZONE");
\&   $date\->config("forcedate","now");
.Ve
.Sp
all set \*(L"now\*(R" up in tha same way as tha SetDate variable.  Spaces afta commas are
ignored.
.PP
\&\s-1ZONE\s0 can be any time unit name, alias, abbreviation, or offset, and
the dopest time unit is ghon be determined from all given shiznit.
.PP
It should be noted dat settin tha SetDate or ForceDate variable
twice will always refer ta tha system date/time as a startin point.
For example, if a program is hustlin, n' calls tha method:
.PP
.Vb 1
\&   $date\->config("forcedate","now");
.Ve
.PP
at Jun 6, 2009 at 12:00, dat time is ghon be treated as now from that
point on. I aint talkin' bout chicken n' gravy biatch. If tha same call is done a minute later, \*(L"now\*(R" will then
be Jun 6, 2009 at 13:00 from dat moment on.
.PP
Since tha current date is used up in tha date parsin routines, no
parsin can be done on tha \s-1DATE\s0 value up in any of tha calls.  Instead,
\&\s-1DATE\s0 must be a thugged-out date up in one of tha two formats:
.PP
.Vb 2
\&   YYYY\-MM\-DD\-HH:MN:SS
\&   YYYYMMDDHH:MN:SS
.Ve
.SH "DEPRECATED CONFIGURATION VARIABLES"
.IX Header "DEPRECATED CONFIGURATION VARIABLES"
Da followin config variablez is currently supported yo, but are
deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  They is ghon be removed up in a gangbangin' future Date::Manip release:
.IP "\fB\s-1TZ\s0\fR" 4
.IX Item "TZ"
This is discussed above. Use SetDate or ForceDate instead.
.Sp
Scheduled fo' removal 2013\-12\-01 .
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
None known.
.SH "BUGS AND QUESTIONS"
.IX Header "BUGS AND QUESTIONS"
Please refer ta tha Date::Manip::Problems documentation for
information on submittin bug reports or thangs ta tha lyricist.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
