.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Harnizz 3"
.TH TAP::Harnizz 3 "2013-05-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Harnizz \- Run test scripts wit statistics
.SH "VERSION"
.IX Header "VERSION"
Version 3.28
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This be a simple test harnizz which allows tests ta be run n' thangs up in dis biatch
automatically aggregated n' output ta \s-1STDOUT.\s0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use TAP::Harness;
\& mah $harnizz = TAP::Harness\->new( \e%args );
\& $harness\->runtests(@tests);
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 5
\& mah %args = (
\&    verbositizzle => 1,
\&    lib     => [ \*(Aqlib\*(Aq, \*(Aqblib/lib\*(Aq, \*(Aqblib/arch\*(Aq ],
\& )
\& mah $harnizz = TAP::Harness\->new( \e%args );
.Ve
.PP
Da constructor returns a freshly smoked up \f(CW\*(C`TAP::Harness\*(C'\fR object. Well shiiiit, it accepts an
optionizzle hashref whose allowed keys are:
.IP "\(bu" 4
\&\f(CW\*(C`verbosity\*(C'\fR
.Sp
Set tha verbositizzle level:
.Sp
.Vb 6
\&     1   verbose        Print individual test thangs up in dis biatch ta STDOUT.
\&     0   normal
\&    \-1   on tha down-low          Suppress some test output (mostly failures 
\&                        while tests is hustlin).
\&    \-2   straight-up on tha down-low   Suppress every last muthafuckin thang but tha tests summary.
\&    \-3   silent         Suppress every last muthafuckin thang.
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`timer\*(C'\fR
.Sp
Append run time fo' each test ta output. Uses Time::HiRes if
available.
.IP "\(bu" 4
\&\f(CW\*(C`failures\*(C'\fR
.Sp
Show test failures (this be a no-op if \f(CW\*(C`verbose\*(C'\fR is selected).
.IP "\(bu" 4
\&\f(CW\*(C`comments\*(C'\fR
.Sp
Show test comments (this be a no-op if \f(CW\*(C`verbose\*(C'\fR is selected).
.IP "\(bu" 4
\&\f(CW\*(C`show_count\*(C'\fR
.Sp
Update tha hustlin test count durin testing.
.IP "\(bu" 4
\&\f(CW\*(C`normalize\*(C'\fR
.Sp
Set ta a legit value ta normalize tha \s-1TAP\s0 dat is emitted up in verbose modes.
.IP "\(bu" 4
\&\f(CW\*(C`lib\*(C'\fR
.Sp
Accepts a scalar value or array ref of scalar joints indicatin which
paths ta allowed libraries should be included if Perl tests are
executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Naturally, dis only make sense up in tha context of tests
written up in Perl.
.IP "\(bu" 4
\&\f(CW\*(C`switches\*(C'\fR
.Sp
Accepts a scalar value or array ref of scalar joints indicatin which
switches should be included if Perl tests is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Naturally, this
only make sense up in tha context of tests freestyled up in Perl.
.IP "\(bu" 4
\&\f(CW\*(C`test_args\*(C'\fR
.Sp
A reference ta a \f(CW@INC\fR steez array of arguments ta be passed ta each
test program.
.Sp
.Vb 1
\&  test_args => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq],
.Ve
.Sp
if you wanna pass different arguments ta each test then you should
pass a hash of arrays, keyed by tha alias fo' each test:
.Sp
.Vb 4
\&  test_args => {
\&    my_test    => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq],
\&    other_test => [\*(Aqbaz\*(Aq],
\&  }
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`color\*(C'\fR
.Sp
Attempt ta produce color output.
.IP "\(bu" 4
\&\f(CW\*(C`exec\*(C'\fR
.Sp
Typically, Perl tests is run all up in all dis bullshit. But fuck dat shiznit yo, tha word on tha street is dat anythang which
spits up \s-1TAP\s0 is fine. Yo ass can use dis argument ta specify tha name of
the program (and optionizzle switches) ta run yo' tests with:
.Sp
.Vb 1
\&  exec => [\*(Aq/usr/bin/ruby\*(Aq, \*(Aq\-w\*(Aq]
.Ve
.Sp
Yo ass can also pass a subroutine reference up in order ta determine and
return tha proper program ta run based on a given test script. The
subroutine reference should expect tha TAP::Harnizz object itself as the
first argument, n' tha file name as tha second argument. Well shiiiit, it should
return a array reference containin tha command ta be run n' including
the test file name. Well shiiiit, it can also simply return \f(CW\*(C`undef\*(C'\fR, up in which case
TAP::Harnizz will fall back on executin tha test script up in Perl:
.Sp
.Vb 2
\&    exec => sub {
\&        mah ( $harness, $test_file ) = @_;
\&
\&        # Let Perl tests run.
\&        return undef if $test_file =~ /[.]t$/;
\&        return [ qw( /usr/bin/ruby \-w ), $test_file ]
\&          if $test_file =~ /[.]rb$/;
\&      }
.Ve
.Sp
If tha subroutine returns a scalar wit a newline or a gangbangin' filehandle, it
will be interpreted as raw \s-1TAP\s0 or as a \s-1TAP\s0 stream, respectively.
.IP "\(bu" 4
\&\f(CW\*(C`merge\*(C'\fR
.Sp
If \f(CW\*(C`merge\*(C'\fR is legit tha harnizz will create parsers dat merge \s-1STDOUT\s0
and \s-1STDERR\s0 together fo' any processes they start.
.IP "\(bu" 4
\&\f(CW\*(C`sources\*(C'\fR
.Sp
\&\fI\s-1NEW\s0 ta 3.18\fR.
.Sp
If set, \f(CW\*(C`sources\*(C'\fR must be a hashref containin tha namez of the
TAP::Parser::SourceHandlezs ta load and/or configure.  Da joints is a
hash of configuration dat is ghon be accessible ta ta tha source handlezs via
\&\*(L"config_for\*(R" up in TAP::Parser::Source.
.Sp
For example:
.Sp
.Vb 5
\&  sources => {
\&    Perl => { exec => \*(Aq/path/to/custom/perl\*(Aq },
\&    File => { extensions => [ \*(Aq.tap\*(Aq, \*(Aq.txt\*(Aq ] },
\&    MyCustom => { some => \*(Aqconfig\*(Aq },
\&  }
.Ve
.Sp
Da \f(CW\*(C`sources\*(C'\fR parameta affects how tha fuck \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR n' \f(CW\*(C`exec\*(C'\fR parameters
are handled.
.Sp
For mo' details, peep tha \f(CW\*(C`sources\*(C'\fR parameta up in \*(L"new\*(R" up in TAP::Parser,
TAP::Parser::Source, n' TAP::Parser::IteratorFactory.
.IP "\(bu" 4
\&\f(CW\*(C`aggregator_class\*(C'\fR
.Sp
Da name of tha class ta use ta aggregate test thangs up in dis biatch. Da default is
TAP::Parser::Aggregator.
.IP "\(bu" 4
\&\f(CW\*(C`version\*(C'\fR
.Sp
\&\fI\s-1NEW\s0 ta 3.22\fR.
.Sp
Assume dis \s-1TAP\s0 version fo' TAP::Parser instead of default \s-1TAP\s0
version 12.
.IP "\(bu" 4
\&\f(CW\*(C`formatter_class\*(C'\fR
.Sp
Da name of tha class ta use ta format output. Da default is
TAP::Formatter::Console, or TAP::Formatter::File if tha output
aint a \s-1TTY.\s0
.IP "\(bu" 4
\&\f(CW\*(C`multiplexer_class\*(C'\fR
.Sp
Da name of tha class ta use ta multiplex tests durin parallel testing.
Da default is TAP::Parser::Multiplexer.
.IP "\(bu" 4
\&\f(CW\*(C`parser_class\*(C'\fR
.Sp
Da name of tha class ta use ta parse \s-1TAP.\s0 Da default is
TAP::Parser.
.IP "\(bu" 4
\&\f(CW\*(C`scheduler_class\*(C'\fR
.Sp
Da name of tha class ta use ta schedule test execution. I aint talkin' bout chicken n' gravy biatch. Da default is
TAP::Parser::Scheduler.
.IP "\(bu" 4
\&\f(CW\*(C`formatter\*(C'\fR
.Sp
If set \f(CW\*(C`formatter\*(C'\fR must be a object dat is capable of formattin the
\&\s-1TAP\s0 output. Right back up in yo muthafuckin ass. See TAP::Formatter::Console fo' a example.
.IP "\(bu" 4
\&\f(CW\*(C`errors\*(C'\fR
.Sp
If parse errors is found up in tha \s-1TAP\s0 output, a note of dis will be
made up in tha summary report. To peep all of tha parse errors, set this
argument ta true:
.Sp
.Vb 1
\&  errors => 1
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`directives\*(C'\fR
.Sp
If set ta a legit value, only test thangs up in dis biatch wit directives will be
displayed. Y'all KNOW dat shit, muthafucka! This overrides other settings like fuckin \f(CW\*(C`verbose\*(C'\fR or
\&\f(CW\*(C`failures\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`ignore_exit\*(C'\fR
.Sp
If set ta a legit value instruct \f(CW\*(C`TAP::Parser\*(C'\fR ta ignore exit n' wait
status from test scripts.
.IP "\(bu" 4
\&\f(CW\*(C`jobs\*(C'\fR
.Sp
Da maximum number of parallel tests ta run at any time.  Which tests
can be run up in parallel is controlled by \f(CW\*(C`rules\*(C'\fR.  Da default is to
run only one test at a time.
.IP "\(bu" 4
\&\f(CW\*(C`rules\*(C'\fR
.Sp
A reference ta a hash of rulez dat control which tests may be executed in
parallel. If no rulez is declared, all tests is eligible fo' bein run in
parallel yo. Here some simple examples. For tha full detailz of tha data structure
and tha related glob-style pattern matching, see
\&\*(L"Rulez data structure\*(R" up in TAP::Parser::Scheduler.
.Sp
.Vb 4
\&    # Run all tests up in sequence, except dem startin wit "p"
\&    $harness\->rules({
\&        par => \*(Aqt/p*.t\*(Aq
\&    });
\&
\&    # Run all tests up in parallel, except dem startin wit "p"
\&    $harness\->rules({
\&        seq => [
\&                  { seq => \*(Aqt/p*.t\*(Aq },
\&                  { par => \*(Aq**\*(Aq     },
\&               ],
\&    });
\&
\&    # Run some  startup tests up in sequence, then some parallel tests than some
\&    # teardown tests up in sequence.
\&    $harness\->rules({
\&        seq => [
\&            { seq => \*(Aqt/startup/*.t\*(Aq },
\&            { par => [\*(Aqt/a/*.t\*(Aq,\*(Aqt/b/*.t\*(Aq,\*(Aqt/c/*.t\*(Aq], }
\&            { seq => \*(Aqt/shutdown/*.t\*(Aq },
\&        ],
\&
\&    });
.Ve
.Sp
This be a experimenstrual feature n' tha intercourse may chizzle.
.IP "\(bu" 4
\&\f(CW\*(C`stdout\*(C'\fR
.Sp
A filehandle fo' catchin standard output.
.IP "\(bu" 4
\&\f(CW\*(C`trap\*(C'\fR
.Sp
Attempt ta print summary shiznit if run is interrupted by
\&\s-1SIGINT \s0(Ctrl-C).
.PP
Any keys fo' which tha value is \f(CW\*(C`undef\*(C'\fR is ghon be ignored.
.SS "Instizzle Methods"
.IX Subsection "Instizzle Methods"
\fI\f(CI\*(C`runtests\*(C'\fI\fR
.IX Subsection "runtests"
.PP
.Vb 1
\&    $harness\->runtests(@tests);
.Ve
.PP
Accepts a array of \f(CW@tests\fR ta be run. I aint talkin' bout chicken n' gravy biatch. This should generally be the
namez of test filez yo, but dis aint required. Y'all KNOW dat shit, muthafucka! Each element up in \f(CW@tests\fR
will be passed ta \f(CW\*(C`TAP::Parser::new()\*(C'\fR as a \f(CW\*(C`source\*(C'\fR. Right back up in yo muthafuckin ass. See
TAP::Parser fo' mo' shiznit.
.PP
It be possible ta provide aliases dat is ghon be displayed up in place of the
test name by supplyin tha test as a reference ta a array containing
\&\f(CW\*(C`[ $test, $alias ]\*(C'\fR:
.PP
.Vb 2
\&    $harness\->runtests( [ \*(Aqt/foo.t\*(Aq, \*(AqFoo Once\*(Aq ],
\&                        [ \*(Aqt/foo.t\*(Aq, \*(AqFoo Twice\*(Aq ] );
.Ve
.PP
Normally it be a error ta attempt ta run tha same test twice fo' realz. Aliases
allow you ta overcome dis limitation by givin each run of tha test a
unique name.
.PP
Tests is ghon be run up in tha order found.
.PP
If tha environment variable \f(CW\*(C`PERL_TEST_HARNESS_DUMP_TAP\*(C'\fR is defined it
should name a gangbangin' finger-lickin' directory tha fuck into which a cold-ass lil copy of tha raw \s-1TAP\s0 fo' each test
will be written. I aint talkin' bout chicken n' gravy biatch. \s-1TAP\s0 is freestyled ta filez named fo' each test.
Subdirectories is ghon be pimped as needed.
.PP
Returns a TAP::Parser::Aggregator containin tha test thangs up in dis biatch.
.PP
\fI\f(CI\*(C`summary\*(C'\fI\fR
.IX Subsection "summary"
.PP
.Vb 1
\&  $harness\->summary( $aggregator );
.Ve
.PP
Output tha summary fo' a TAP::Parser::Aggregator.
.PP
\fI\f(CI\*(C`aggregate_tests\*(C'\fI\fR
.IX Subsection "aggregate_tests"
.PP
.Vb 1
\&  $harness\->aggregate_tests( $aggregate, @tests );
.Ve
.PP
Run tha named tests n' display a summary of result. Tests is ghon be run
in tha order found.
.PP
Test thangs up in dis biatch is ghon be added ta tha supplied TAP::Parser::Aggregator.
\&\f(CW\*(C`aggregate_tests\*(C'\fR may be called multiple times ta run nuff muthafuckin sets of
tests, n' you can put dat on yo' toast. Multiple \f(CW\*(C`Test::Harness\*(C'\fR instances may be used ta pass thangs up in dis biatch
to a single aggregator so dat different partz of a cold-ass lil complex test suite
may be run rockin different \f(CW\*(C`TAP::Harness\*(C'\fR settings. This is useful, for
example, up in tha case where some tests should run up in parallel but others
are unsuitable fo' parallel execution.
.PP
.Vb 8
\&    mah $formatta   = TAP::Formatter::Console\->new;
\&    mah $ser_harnizz = TAP::Harness\->new( { formatta => $formatta } );
\&    mah $par_harnizz = TAP::Harness\->new(
\&        {   formatta => $formatter,
\&            thangs      => 9
\&        }
\&    );
\&    mah $aggregator = TAP::Parser::Aggregator\->new;
\&
\&    $aggregator\->start();
\&    $ser_harness\->aggregate_tests( $aggregator, @ser_tests );
\&    $par_harness\->aggregate_tests( $aggregator, @par_tests );
\&    $aggregator\->stop();
\&    $formatter\->summary($aggregator);
.Ve
.PP
Note dat fo' simpla testin requirements it will often be possible to
replace tha above code wit a single call ta \f(CW\*(C`runtests\*(C'\fR.
.PP
Each element of tha \f(CW@tests\fR array is either:
.IP "\(bu" 4
the source name of a test ta run
.IP "\(bu" 4
a reference ta a [ source name, display name ] array
.PP
In tha case of a perl test suite, typically \fIsource names\fR is simply tha file
namez of tha test scripts ta run.
.PP
When you supply a separate display name it becomes possible ta run a
test mo' than once; tha display name is effectively tha alias by which
the test is known inside tha harness. Da harnizz don't care if it
runs tha same ol' dirty test mo' than once when each invocation uses a
different name.
.PP
\fI\f(CI\*(C`make_scheduler\*(C'\fI\fR
.IX Subsection "make_scheduler"
.PP
Called by tha harnizz when it need ta create a
TAP::Parser::Schedula n' shit. Override up in a subclass ta provide an
alternatizzle schedula n' shit. \f(CW\*(C`make_scheduler\*(C'\fR is passed tha list of tests
that was passed ta \f(CW\*(C`aggregate_tests\*(C'\fR.
.PP
\fI\f(CI\*(C`jobs\*(C'\fI\fR
.IX Subsection "jobs"
.PP
Gets or sets tha number of concurrent test runs tha harnizz is
handling.  By default, dis value is 1 \*(-- fo' parallel testing, this
should be set higher.
.PP
\fI\f(CI\*(C`make_parser\*(C'\fI\fR
.IX Subsection "make_parser"
.PP
Make a freshly smoked up parser n' display formatta session. I aint talkin' bout chicken n' gravy biatch. Typically used and/or
overridden up in subclasses.
.PP
.Vb 1
\&    mah ( $parser, $session ) = $harness\->make_parser;
.Ve
.PP
\fI\f(CI\*(C`finish_parser\*(C'\fI\fR
.IX Subsection "finish_parser"
.PP
Terminizzle use of a parser n' shit. Typically used and/or overridden in
subclasses. Da parser aint destroyed as a result of all dis bullshit.
.SH "CONFIGURING"
.IX Header "CONFIGURING"
\&\f(CW\*(C`TAP::Harness\*(C'\fR is designed ta be easy as fuck  ta configure.
.SS "Plugins"
.IX Subsection "Plugins"
\&\f(CW\*(C`TAP::Parser\*(C'\fR plugins let you chizzle tha way \s-1TAP\s0 is \fIinput\fR ta n' \fIoutput\fR
from tha parser.
.PP
TAP::Parser::SourceHandlezs handle \s-1TAP \s0\fIinput\fR.  Yo ass can configure them
and load custom handlezs rockin tha \f(CW\*(C`sources\*(C'\fR parameta ta \*(L"new\*(R".
.PP
TAP::Formattas handle \s-1TAP \s0\fIoutput\fR.  Yo ass can load custom formattas by
usin tha \f(CW\*(C`formatter_class\*(C'\fR parameta ta \*(L"new\*(R".  To configure a gangbangin' formatter,
you currently need ta instantiate it outside of TAP::Harnizz n' pass it in
with tha \f(CW\*(C`formatter\*(C'\fR parameta ta \*(L"new\*(R".  This \fImay\fR be addressed by adding
a \fIformatters\fR parameta ta \*(L"new\*(R" up in tha future.
.ie n .SS """Module::Build"""
.el .SS "\f(CWModule::Build\fP"
.IX Subsection "Module::Build"
Module::Build version \f(CW0.30\fR supports \f(CW\*(C`TAP::Harness\*(C'\fR.
.PP
To load \f(CW\*(C`TAP::Harness\*(C'\fR plugins, you gonna need ta use tha \f(CW\*(C`tap_harness_args\*(C'\fR
parameta ta \f(CW\*(C`new\*(C'\fR, typically from yo' \f(CW\*(C`Build.PL\*(C'\fR.  For example:
.PP
.Vb 10
\&  Module::Build\->new(
\&      module_name        => \*(AqMyApp\*(Aq,
\&      test_file_exts     => [qw(.t .tap .txt)],
\&      use_tap_harnizz    => 1,
\&      tap_harness_args   => {
\&          sources => {
\&              MyCustom => {},
\&              File => {
\&                  extensions => [\*(Aq.tap\*(Aq, \*(Aq.txt\*(Aq],
\&              },
\&          },
\&          formatter_class => \*(AqTAP::Formatter::HTML\*(Aq,
\&      },
\&      build_requires     => {
\&          \*(AqModule::Build\*(Aq => \*(Aq0.30\*(Aq,
\&          \*(AqTAP::Harness\*(Aq  => \*(Aq3.18\*(Aq,
\&      },
\&  )\->create_build_script;
.Ve
.PP
See \*(L"new\*(R"
.ie n .SS """ExtUtils::MakeMaker"""
.el .SS "\f(CWExtUtils::MakeMaker\fP"
.IX Subsection "ExtUtils::MakeMaker"
ExtUtils::MakeMaker do not support TAP::Harnizz out-of-the-box.
.ie n .SS """prove"""
.el .SS "\f(CWprove\fP"
.IX Subsection "prove"
prove supports \f(CW\*(C`TAP::Harness\*(C'\fR plugins, n' has a plugin system of its
own. I aint talkin' bout chicken n' gravy biatch.  See \*(L"\s-1FORMATTERS\*(R"\s0 up in prove, \*(L"\s-1SOURCE HANDLERS\*(R"\s0 up in prove n' App::Prove
for mo' details.
.SH "WRITING PLUGINS"
.IX Header "WRITING PLUGINS"
If you can't configure \f(CW\*(C`TAP::Harness\*(C'\fR ta do what tha fuck you want, n' you can't find
an existin plugin, consider freestylin one.
.PP
Da two primary use cases supported by TAP::Harnizz fo' plugins is \fIinput\fR
and \fIoutput\fR:
.IP "Customize how tha fuck \s-1TAP\s0 gets tha fuck into tha parser" 2
.IX Item "Customize how tha fuck TAP gets tha fuck into tha parser"
To do this, you can either extend a existin TAP::Parser::SourceHandlez,
or write yo' own. I aint talkin' bout chicken n' gravy biatch.  It aint nuthin but a pimpin' simple \s-1API,\s0 n' they can be loaded and
configured rockin tha \f(CW\*(C`sources\*(C'\fR parameta ta \*(L"new\*(R".
.IP "Customize how tha fuck \s-1TAP\s0 thangs up in dis biatch is output from tha parser" 2
.IX Item "Customize how tha fuck TAP thangs up in dis biatch is output from tha parser"
To do this, you can either extend a existin TAP::Formatter, or write your
own. I aint talkin' bout chicken n' gravy biatch.  Freestylin formattas is a lil' bit mo' involved than freestylin a
\&\fISourceHandlez\fR, as you gonna need ta KNOW tha TAP::Parser \s-1API.  A\s0
phat place ta start is by understandin how tha fuck \*(L"aggregate_tests\*(R" works.
.Sp
Custom formattas can be loaded configured rockin tha \f(CW\*(C`formatter_class\*(C'\fR
parameta ta \*(L"new\*(R".
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
If you can't configure \f(CW\*(C`TAP::Harness\*(C'\fR ta do exactly what tha fuck you want, n' writing
a plugin aint a option, consider extendin dat shit.  It be designed ta be (mostly)
easy ta subclass, though tha cases when sub-classin is necessary should be few
and far between.
.SS "Methods"
.IX Subsection "Methods"
Da followin methodz is ones you may wish ta override if you want to
subclass \f(CW\*(C`TAP::Harness\*(C'\fR.
.ie n .IP """new""" 4
.el .IP "``new''" 4
.IX Item "new"
.PD 0
.ie n .IP """runtests""" 4
.el .IP "``runtests''" 4
.IX Item "runtests"
.ie n .IP """summary""" 4
.el .IP "``summary''" 4
.IX Item "summary"
.PD
.SH "REPLACING"
.IX Header "REPLACING"
If you like tha \f(CW\*(C`prove\*(C'\fR utilitizzle n' TAP::Parser but you want your
own harness, all you need ta do is write one n' provide \f(CW\*(C`new\*(C'\fR and
\&\f(CW\*(C`runtests\*(C'\fR methods. Then you can use tha \f(CW\*(C`prove\*(C'\fR utilitizzle like so:
.PP
.Vb 1
\& prove \-\-harnizz My::Test::Harness
.Ve
.PP
Note dat while \f(CW\*(C`prove\*(C'\fR accepts a list of tests (or thangs ta be
tested), \f(CW\*(C`new\*(C'\fR has a gangbangin' fairly rich set of arguments, n' you can put dat on yo' toast. You'll probably want
to read over dis code carefully ta peep how tha fuck all of dem is bein used.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Harness
