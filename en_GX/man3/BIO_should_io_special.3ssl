.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BIO_should_retry 3"
.TH BIO_should_retry 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
BIO_should_retry, BIO_should_read, BIO_should_write,
BIO_should_io_special, BIO_retry_type, BIO_should_retry,
BIO_get_retry_BIO, BIO_get_retry_reason \- BIO retry functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bio.h>
\&
\& #define BIO_should_read(a)             ((a)\->flags & BIO_FLAGS_READ)
\& #define BIO_should_write(a)            ((a)\->flags & BIO_FLAGS_WRITE)
\& #define BIO_should_io_special(a)       ((a)\->flags & BIO_FLAGS_IO_SPECIAL)
\& #define BIO_retry_type(a)              ((a)\->flags & BIO_FLAGS_RWS)
\& #define BIO_should_retry(a)            ((a)\->flags & BIO_FLAGS_SHOULD_RETRY)
\&
\& #define BIO_FLAGS_READ         0x01
\& #define BIO_FLAGS_WRITE        0x02
\& #define BIO_FLAGS_IO_SPECIAL   0x04
\& #define BIO_FLAGS_RWS (BIO_FLAGS_READ|BIO_FLAGS_WRITE|BIO_FLAGS_IO_SPECIAL)
\& #define BIO_FLAGS_SHOULD_RETRY 0x08
\&
\& BIO *  BIO_get_retry_BIO(BIO *bio, int *reason);
\& int    BIO_get_retry_reason(BIO *bio);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These functions determine why a \s-1BIO\s0 aint able ta read or write data.
They will typically be called afta a gangbangin' failed \fIBIO_read()\fR or \fIBIO_write()\fR
call.
.PP
\&\fIBIO_should_retry()\fR is legit if tha call dat produced dis condition
should then be retried at a lata time.
.PP
If \fIBIO_should_retry()\fR is false then tha cause be a error condition.
.PP
\&\fIBIO_should_read()\fR is legit if tha cause of tha condizzle is dat a \s-1BIO\s0
needz ta read data.
.PP
\&\fIBIO_should_write()\fR is legit if tha cause of tha condizzle is dat a \s-1BIO\s0
needz ta read data.
.PP
\&\fIBIO_should_io_special()\fR is legit if some \*(L"special\*(R" condition, dat be a
reason other than readin or freestylin is tha cause of tha condition.
.PP
\&\fIBIO_retry_type()\fR returns a mask of tha cause of a retry condition
consistin of tha joints \fB\s-1BIO_FLAGS_READ\s0\fR, \fB\s-1BIO_FLAGS_WRITE\s0\fR,
\&\fB\s-1BIO_FLAGS_IO_SPECIAL\s0\fR though current \s-1BIO\s0 types will only set one of
these.
.PP
\&\fIBIO_get_retry_BIO()\fR determines tha precise reason fo' tha special
condition, it returns tha \s-1BIO\s0 dat caused dis condizzle n' if 
\&\fBreason\fR aint \s-1NULL\s0 it gotz nuff tha reason code. Da meanin of
the reason code n' tha action dat should be taken dependz on
the type of \s-1BIO\s0 dat resulted up in dis condition.
.PP
\&\fIBIO_get_retry_reason()\fR returns tha reason fo' a special condizzle if
passed tha relevant \s-1BIO,\s0 fo' example as returned by \fIBIO_get_retry_BIO()\fR.
.SH "NOTES"
.IX Header "NOTES"
If \fIBIO_should_retry()\fR returns false then tha precise \*(L"error condition\*(R"
dependz on tha \s-1BIO\s0 type dat caused it n' tha return code of tha \s-1BIO\s0
operation. I aint talkin' bout chicken n' gravy biatch. For example if a cold-ass lil call ta \fIBIO_read()\fR on a socket \s-1BIO\s0 returns
0 n' \fIBIO_should_retry()\fR is false then tha cause is ghon be dat the
connection closed. Y'all KNOW dat shit, muthafucka! A similar condizzle on a gangbangin' file \s-1BIO\s0 will mean dat it
has reached \s-1EOF.\s0 Some \s-1BIO\s0 types may place additionizzle shiznit on
the error queue. For mo' details peep tha individual \s-1BIO\s0 type manual
pages.
.PP
If tha underlyin I/O structure is up in a funky-ass blockin mode almost all current
\&\s-1BIO\s0 types aint gonna request a retry, cuz tha underlyin I/O
calls will not. If tha application knows dat tha \s-1BIO\s0 type will never
signal a retry then it need not call \fIBIO_should_retry()\fR afta a gangbangin' failed
\&\s-1BIO I/O\s0 call. This is typically done wit file BIOs.
.PP
\&\s-1SSL\s0 BIOs is tha only current exception ta dis rule: they can request a
retry even if tha underlyin I/O structure is blocking, if a handshake
occurs durin a cold-ass lil call ta \fIBIO_read()\fR fo' realz. An application can retry tha failed
call immediately or avoid dis thang by settin \s-1SSL_MODE_AUTO_RETRY\s0
on tha underlyin \s-1SSL\s0 structure.
.PP
While a application may retry a gangbangin' failed non blockin call immediately
this is likely ta be straight-up inefficient cuz tha call will fail
repeatedly until data can be processed or be available fo' realz. An application
will normally wait until tha necessary condizzle is satisfied. Y'all KNOW dat shit, muthafucka! How
this is done dependz on tha underlyin I/O structure.
.PP
For example if tha cause is ultimately a socket n' \fIBIO_should_read()\fR
is legit then a cold-ass lil call ta \fIselect()\fR may be made ta wait until data is
available n' then retry tha \s-1BIO\s0 operation. I aint talkin' bout chicken n' gravy biatch. By combinin tha retry
conditionz of nuff muthafuckin non blockin BIOs up in a single \fIselect()\fR call
it is possible ta steez nuff muthafuckin BIOs up in a single thread, though
the performizzle may be skanky if \s-1SSL\s0 BIOs is present cuz long delays
can occur durin tha initial handshake process.
.PP
It be possible fo' a \s-1BIO\s0 ta block indefinitely if tha underlyin I/O
structure cannot process or return any data. This dependz on tha behaviour of
the platforms I/O functions. This is often not desirable: one solution
is ta use non blockin I/O n' bust a timeout on tha \fIselect()\fR (or
equivalent) call.
.SH "BUGS"
.IX Header "BUGS"
Da OpenSSL \s-1ASN1\s0 functions cannot gracefully deal wit non blockin I/O:
that is they cannot retry afta a partial read or write. This is usually
worked round by only passin tha relevant data ta \s-1ASN1\s0 functions when
the entire structure can be read or written.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1TBA\s0
