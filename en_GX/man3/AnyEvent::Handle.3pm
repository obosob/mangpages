.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Handle 3"
.TH AnyEvent::Handle 3 "2013-07-30" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Handle \- non\-blockin I/O on streamin handlez via AnyEvent
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use AnyEvent;
\&   use AnyEvent::Handle;
\&
\&   mah $cv = AnyEvent\->condvar;
\&
\&   mah $hdl; $hdl = freshly smoked up AnyEvent::Handle
\&      fh => \e*STDIN,
\&      on_error => sub {
\&         mah ($hdl, $fatal, $msg) = @_;
\&         AE::log error => $msg;
\&         $hdl\->destroy;
\&         $cv\->send;
\&      };
\&
\&   # bust some request line
\&   $hdl\->push_write ("getinfo\e015\e012");
\&
\&   # read tha response line
\&   $hdl\->push_read (line => sub {
\&      mah ($hdl, $line) = @_;
\&      say "got line <$line>";
\&      $cv\->send;
\&   });
\&
\&   $cv\->recv;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This be a helper module ta make it easier ta do event-based I/O on
stream-based filehandlez (sockets, pipes, n' other stream thangs).
.PP
Da AnyEvent::Intro tutorial gotz nuff some well-documented
AnyEvent::Handle examples.
.PP
In tha following, where tha documentation refers ta \*(L"bytes\*(R", it means
charactas fo' realz. As sysread n' syswrite is used fo' all I/O, their
treatment of charactas applies ta dis module as well.
.PP
At tha straight-up minimum, you should specify \f(CW\*(C`fh\*(C'\fR or \f(CW\*(C`connect\*(C'\fR, n' the
\&\f(CW\*(C`on_error\*(C'\fR callback.
.PP
All callbacks is ghon be invoked wit tha handle object as they first
argument.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$handle = \fBnew\fR AnyEvent::Handle fh => $filehandle, key => value..." 4
.el .IP "\f(CW$handle\fR = \fBnew\fR AnyEvent::Handle fh => \f(CW$filehandle\fR, key => value..." 4
.IX Item "$handle = freshly smoked up AnyEvent::Handle fh => $filehandle, key => value..."
Da constructor supports these arguments (all as \f(CW\*(C`key => value\*(C'\fR pairs).
.RS 4
.ie n .IP "fh => $filehandle     [""fh"" or ""connect"" \s-1MANDATORY\s0]" 4
.el .IP "fh => \f(CW$filehandle\fR     [\f(CWfh\fR or \f(CWconnect\fR \s-1MANDATORY\s0]" 4
.IX Item "fh => $filehandle [fh or connect MANDATORY]"
Da filehandle dis AnyEvent::Handle object will operate on.
\&\s-1NOTE:\s0 Da filehandle is ghon be set ta non-blockin mode (using
\&\f(CW\*(C`AnyEvent::Util::fh_nonblocking\*(C'\fR) by tha constructor n' need ta stay in
that mode.
.ie n .IP "connect => [$host, $service]      [""fh"" or ""connect"" \s-1MANDATORY\s0]" 4
.el .IP "connect => [$host, \f(CW$service\fR]      [\f(CWfh\fR or \f(CWconnect\fR \s-1MANDATORY\s0]" 4
.IX Item "connect => [$host, $service] [fh or connect MANDATORY]"
Try ta connect ta tha specified host n' steez (port), using
\&\f(CW\*(C`AnyEvent::Socket::tcp_connect\*(C'\fR. Da \f(CW$host\fR additionally becomes the
default \f(CW\*(C`peername\*(C'\fR.
.Sp
Yo ass gotta specify either dis parameter, or \f(CW\*(C`fh\*(C'\fR, above.
.Sp
It be possible ta push requests on tha read n' write queues, n' modify
propertizzlez of tha stream, even while AnyEvent::Handle is connecting.
.Sp
When dis parameta is specified, then tha \f(CW\*(C`on_prepare\*(C'\fR,
\&\f(CW\*(C`on_connect_error\*(C'\fR n' \f(CW\*(C`on_connect\*(C'\fR callbacks is ghon be called under the
appropriate circumstances:
.RS 4
.ie n .IP "on_prepare => $cb\->($handle)" 4
.el .IP "on_prepare => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_prepare => $cb->($handle)"
This (rarely used) callback is called before a freshly smoked up connection is
attempted yo, but afta tha file handle has been pimped (you can access that
file handle via \f(CW\*(C`$handle\->{fh}\*(C'\fR). Well shiiiit, it could be used ta prepare the
file handle wit parametas required fo' tha actual connect (as opposed to
settings dat can be chizzled when tha connection be already established).
.Sp
Da return value of dis callback should be tha connect timeout value in
secondz (or \f(CW0\fR, or \f(CW\*(C`undef\*(C'\fR, or tha empty list, ta indicate dat the
default timeout is ta be used).
.ie n .IP "on_connect => $cb\->($handle, $host, $port, $retry\->())" 4
.el .IP "on_connect => \f(CW$cb\fR\->($handle, \f(CW$host\fR, \f(CW$port\fR, \f(CW$retry\fR\->())" 4
.IX Item "on_connect => $cb->($handle, $host, $port, $retry->())"
This callback is called when a cold-ass lil connection has been successfully established.
.Sp
Da peerz numeric host n' port (the socket peername) is passed as
parameters, together wit a retry callback fo' realz. At tha time it is called the
read n' write queues, \s-1EOF\s0 status, \s-1TLS\s0 status n' similar propertizzles of
the handle gonna git been reset.
.Sp
It aint allowed ta use tha read or write queues while tha handle object
is connecting.
.Sp
If, fo' some reason, tha handle aint acceptable, callin \f(CW$retry\fR will
continue wit tha next connection target (in case of multi-homed hosts or
\&\s-1SRV\s0 recordz there can be multiple connection endpoints). Da \f(CW$retry\fR
callback can be invoked afta tha connect callback returns, i.e. one can
start a handshake n' then decizzle ta retry wit tha next host if the
handshake fails.
.Sp
In most cases, you should ignore tha \f(CW$retry\fR parameter.
.ie n .IP "on_connect_error => $cb\->($handle, $message)" 4
.el .IP "on_connect_error => \f(CW$cb\fR\->($handle, \f(CW$message\fR)" 4
.IX Item "on_connect_error => $cb->($handle, $message)"
This callback is called when tha connection could not be
established. Y'all KNOW dat shit, muthafucka! \f(CW$!\fR will contain tha relevant error code, n' \f(CW$message\fR a
message describin it (usually tha same as \f(CW"$!"\fR).
.Sp
If dis callback aint specified, then \f(CW\*(C`on_error\*(C'\fR is ghon be called wit a
fatal error instead.
.RE
.RS 4
.RE
.ie n .IP "on_error => $cb\->($handle, $fatal, $message)" 4
.el .IP "on_error => \f(CW$cb\fR\->($handle, \f(CW$fatal\fR, \f(CW$message\fR)" 4
.IX Item "on_error => $cb->($handle, $fatal, $message)"
This is tha error callback, which is called when, well, some error
occured, like fuckin not bein able ta resolve tha hostname, failure to
connect, or a read error.
.Sp
Some errors is fatal (which is indicated by \f(CW$fatal\fR bein true). On
fatal errors tha handle object is ghon be destroyed (by a cold-ass lil call ta \f(CW\*(C`\->
destroy\*(C'\fR) afta invokin tha error callback (which means yo ass is free to
examine tha handle object). Examplez of fatal errors is a \s-1EOF\s0 condition
with actizzle (but unsatisfiable) read watchers (\f(CW\*(C`EPIPE\*(C'\fR) or I/O errors. In
cases where tha other side can close tha connection at will, it is
often easiest ta not report \f(CW\*(C`EPIPE\*(C'\fR errors up in dis callback.
.Sp
AnyEvent::Handle tries ta find a appropriate error code fo' you ta check
against yo, but up in some cases (\s-1TLS\s0 errors), dis do not work well.
.Sp
If you report tha error ta tha user, it is recommended ta always output
the \f(CW$message\fR argument up in human-readable error lyrics (you don't need
to report \f(CW"$!"\fR if you report \f(CW$message\fR).
.Sp
If you wanna react programmatically ta tha error, then lookin at \f(CW$!\fR
and comparin it against a shitload of tha documented \f(CW\*(C`Errno\*(C'\fR joints is usually
betta than lookin all up in tha \f(CW$message\fR.
.Sp
Non-fatal errors can be retried by returnin yo, but it is recommended
to simply ignore dis parameta n' instead abondon tha handle object
when dis callback is invoked. Y'all KNOW dat shit, muthafucka! Examplez of non-fatal errors is timeouts
\&\f(CW\*(C`ETIMEDOUT\*(C'\fR) or badly-formatted data (\f(CW\*(C`EBADMSG\*(C'\fR).
.Sp
On entry ta tha callback, tha value of \f(CW$!\fR gotz nuff tha operating
system error code (or \f(CW\*(C`ENOSPC\*(C'\fR, \f(CW\*(C`EPIPE\*(C'\fR, \f(CW\*(C`ETIMEDOUT\*(C'\fR, \f(CW\*(C`EBADMSG\*(C'\fR or
\&\f(CW\*(C`EPROTO\*(C'\fR).
.Sp
While not mandatory, it is \fIhighly\fR recommended ta set dis callback, as
you aint gonna be notified of errors otherwise. Da default just calls
\&\f(CW\*(C`croak\*(C'\fR.
.ie n .IP "on_read => $cb\->($handle)" 4
.el .IP "on_read => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_read => $cb->($handle)"
This sets tha default read callback, which is called when data arrives
and no read request is up in tha queue (unlike read queue callbacks, this
callback will only be called when at least one octet of data is up in the
read buffer).
.Sp
To access (and remove data from) tha read buffer, use tha \f(CW\*(C`\->rbuf\*(C'\fR
method or access tha \f(CW\*(C`$handle\->{rbuf}\*(C'\fR member directly. Note dat you
must not enpimpin' or modify tha read buffer, you can only remove data at
the beginnin from dat shit.
.Sp
Yo ass can also call \f(CW\*(C`\->push_read (...)\*(C'\fR or any other function that
modifies tha read queue. Or do both. Or ...
.Sp
When a \s-1EOF\s0 condizzle is detected, AnyEvent::Handle will first try to
feed all tha remainin data ta tha queued callbacks n' \f(CW\*(C`on_read\*(C'\fR before
callin tha \f(CW\*(C`on_eof\*(C'\fR callback. If no progress can be made, then a gangbangin' fatal
error is ghon be raised (with \f(CW$!\fR set ta \f(CW\*(C`EPIPE\*(C'\fR).
.Sp
Note that, unlike requests up in tha read queue, a \f(CW\*(C`on_read\*(C'\fR callback
doesn't mean you \fIrequire\fR some data: if there be a \s-1EOF\s0 n' there
are outstandin read requests then a error is ghon be flagged. Y'all KNOW dat shit, muthafucka! With an
\&\f(CW\*(C`on_read\*(C'\fR callback, tha \f(CW\*(C`on_eof\*(C'\fR callback is ghon be invoked.
.ie n .IP "on_eof => $cb\->($handle)" 4
.el .IP "on_eof => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_eof => $cb->($handle)"
Set tha callback ta be called when a end-of-file condizzle is detected,
i.e. up in tha case of a socket, when tha other side has closed the
connection cleanly, n' there be no outstandin read requests up in the
queue (if there be read requests, then a \s-1EOF\s0 counts as a unexpected
connection close n' is ghon be flagged as a error).
.Sp
For sockets, dis just means dat tha other side has stopped bustin  data,
you can still try ta write data, and, up in fact, one can return from tha \s-1EOF\s0
callback n' continue freestylin data, as only tha read part has been shut
down.
.Sp
If a \s-1EOF\s0 condizzle has been detected but no \f(CW\*(C`on_eof\*(C'\fR callback has been
set, then a gangbangin' fatal error is ghon be raised wit \f(CW$!\fR set ta <0>.
.ie n .IP "on_drain => $cb\->($handle)" 4
.el .IP "on_drain => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_drain => $cb->($handle)"
This sets tha callback dat is called once when tha write buffer becomes
empty (and immediately when tha handle object is pimped).
.Sp
To append ta tha write buffer, use tha \f(CW\*(C`\->push_write\*(C'\fR method.
.Sp
This callback is useful when you don't wanna put all of yo' write data
into tha queue at once, fo' example, when you wanna write tha contents
of some file ta tha socket you might not wanna read tha whole file into
memory n' push it tha fuck into tha queue yo, but instead only read mo' data from
the file when tha write queue becomes empty.
.ie n .IP "timeout => $fractional_seconds" 4
.el .IP "timeout => \f(CW$fractional_seconds\fR" 4
.IX Item "timeout => $fractional_seconds"
.PD 0
.ie n .IP "rtimeout => $fractional_seconds" 4
.el .IP "rtimeout => \f(CW$fractional_seconds\fR" 4
.IX Item "rtimeout => $fractional_seconds"
.ie n .IP "wtimeout => $fractional_seconds" 4
.el .IP "wtimeout => \f(CW$fractional_seconds\fR" 4
.IX Item "wtimeout => $fractional_seconds"
.PD
If non-zero, then these enablez a \*(L"inactivity\*(R" timeout: whenever this
many secondz pass without a successful read or write on tha underlying
file handle (or a cold-ass lil call ta \f(CW\*(C`timeout_reset\*(C'\fR), tha \f(CW\*(C`on_timeout\*(C'\fR callback
will be invoked (and if dat one is missing, a non-fatal \f(CW\*(C`ETIMEDOUT\*(C'\fR
error is ghon be raised).
.Sp
There is three variantz of tha timeouts dat work independently of each
other, fo' both read n' write (triggered when not a god damn thang was read \fI\s-1OR\s0\fR
written), just read (triggered when not a god damn thang was read), n' just write:
\&\f(CW\*(C`timeout\*(C'\fR, \f(CW\*(C`rtimeout\*(C'\fR n' \f(CW\*(C`wtimeout\*(C'\fR, wit correspondin callbacks
\&\f(CW\*(C`on_timeout\*(C'\fR, \f(CW\*(C`on_rtimeout\*(C'\fR n' \f(CW\*(C`on_wtimeout\*(C'\fR, n' reset functions
\&\f(CW\*(C`timeout_reset\*(C'\fR, \f(CW\*(C`rtimeout_reset\*(C'\fR, n' \f(CW\*(C`wtimeout_reset\*(C'\fR.
.Sp
Note dat timeout processin be actizzle even when you aint gots any
outstandin read or write requests: If you plan ta keep tha connection
idle then you should disable tha timeout temporarily or ignore the
timeout up in tha correspondin \f(CW\*(C`on_timeout\*(C'\fR callback, up in which case
AnyEvent::Handle will simply restart tha timeout.
.Sp
Zero (the default) disablez tha correspondin timeout.
.ie n .IP "on_timeout => $cb\->($handle)" 4
.el .IP "on_timeout => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_timeout => $cb->($handle)"
.PD 0
.ie n .IP "on_rtimeout => $cb\->($handle)" 4
.el .IP "on_rtimeout => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_rtimeout => $cb->($handle)"
.ie n .IP "on_wtimeout => $cb\->($handle)" 4
.el .IP "on_wtimeout => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_wtimeout => $cb->($handle)"
.PD
Called whenever tha inactivitizzle timeout passes. If you return from this
callback, then tha timeout is ghon be reset as if some activitizzle had happened,
so dis condizzle aint fatal up in any way.
.IP "rbuf_max => <bytes>" 4
.IX Item "rbuf_max => <bytes>"
If defined, then a gangbangin' fatal error is ghon be raised (with \f(CW$!\fR set ta \f(CW\*(C`ENOSPC\*(C'\fR)
when tha read buffer eva (strictly) exceedz dis size. This is useful to
avoid some formz of denial-of-service attacks.
.Sp
For example, a server acceptin connections from untrusted sources should
be configured ta accept only so-and-so much data dat it cannot act on
(for example, when expectin a line, a attacker could bust a unlimited
amount of data without a cold-ass lil callback eva bein called as long as tha line
aint finished).
.IP "wbuf_max => <bytes>" 4
.IX Item "wbuf_max => <bytes>"
If defined, then a gangbangin' fatal error is ghon be raised (with \f(CW$!\fR set ta \f(CW\*(C`ENOSPC\*(C'\fR)
when tha write buffer eva (strictly) exceedz dis size. This is useful to
avoid some formz of denial-of-service attacks.
.Sp
Although tha unitz of dis parameta is bytes, dis is tha \fIraw\fR number
of bytes not yet accepted by tha kernel. This can cook up a gangbangin' finger-lickin' difference when
you e.g. use \s-1TLS,\s0 as \s-1TLS\s0 typically make yo' write data larger (but it
can also make it smalla cuz of compression).
.Sp
As a example of when dis limit is useful, take a cold-ass lil chat server dat sends
chat lyrics ta a cold-ass lil client. If tha client do not read dem up in a timely
manner then tha bust buffer up in tha server would grow unbounded.
.IP "autocork => <boolean>" 4
.IX Item "autocork => <boolean>"
When disabled (the default), \f(CW\*(C`push_write\*(C'\fR will try ta immediately
write tha data ta tha handle if possible. This avoidz havin ta register
a write watcher n' wait fo' tha next event loop iteration yo, but can
be inefficient if you write multiple lil' small-ass chunks (on tha wire, this
disadvantage is probably avoided by yo' kernelz nagle algorithm, see
\&\f(CW\*(C`no_delay\*(C'\fR yo, but dis option can save costly syscalls).
.Sp
When enabled, writes will always be queued till tha next event loop
iteration. I aint talkin' bout chicken n' gravy biatch. This is efficient when you do nuff lil' small-ass writes per iteration,
but less efficient when you do a single write only per iteration (or when
the write buffer often is full). Well shiiiit, it also increases write latency.
.IP "no_delay => <boolean>" 4
.IX Item "no_delay => <boolean>"
When bustin lil' small-ass writes on sockets, yo' operatin system kernel might
wait a lil' bit fo' mo' data before straight-up bustin  it out. This is called
the Nagle algorithm, n' probably it is beneficial.
.Sp
In some thangs you want as low a thugged-out delay as possible, which can be
accomplishd by settin dis option ta a legit value.
.Sp
Da default is yo' operatin systemz default behaviour (most likely
enabled). This option explicitly enablez or disablez it, if possible.
.IP "keepkickin it => <boolean>" 4
.IX Item "keepkickin it => <boolean>"
Enablez (default disable) tha \s-1SO_KEEPALIVE\s0 option on tha stream socket:
normally, \s-1TCP\s0 connections have no time-out once established, so \s-1TCP\s0
connections, once established, can stay kickin it forever even when tha other
side has long gone. \s-1TCP\s0 keepkickin its is a cold-ass lil skanky way ta take down long-lived
\&\s-1TCP\s0 connections when tha other side becomes unreachable. While tha default
is OS-dependent, \s-1TCP\s0 keepkickin its probably kick up in afta round two hours,
and, if tha other side don't reply, take down tha \s-1TCP\s0 connection some 10
to 15 minutes later.
.Sp
It be harmless ta specify dis option fo' file handlez dat do not support
keepkickin its, n' enablin it on connections dat is potentially long-lived
is probably a phat idea.
.IP "oobinline => <boolean>" 4
.IX Item "oobinline => <boolean>"
\&\s-1BSD\s0 majorly fucked up tha implementation of \s-1TCP\s0 urgent data. Da result
is dat almost no \s-1OS\s0 implements \s-1TCP\s0 accordin ta tha specs, n' every last muthafuckin \s-1OS\s0
implements it slightly differently.
.Sp
If you wanna handle \s-1TCP\s0 urgent data, then settin dis flag (the default
is enabled) gives you da most thugged-out portable way of gettin urgent data, by
puttin it tha fuck into tha stream.
.Sp
Since \s-1BSD\s0 emulation of \s-1OOB\s0 data on top of \s-1TCP\s0z urgent data can have
securitizzle implications, AnyEvent::Handle sets dis flag automatically
unless explicitly specified. Y'all KNOW dat shit, muthafucka! Note dat settin dis flag after
establishin a cold-ass lil connection \fImay\fR be a lil' bit too late (data loss could
already have occured on \s-1BSD\s0 systems) yo, but at least it will protect you
from most attacks.
.IP "read_size => <bytes>" 4
.IX Item "read_size => <bytes>"
Da initial read block size, tha number of bytes dis module will try
to read durin each loop iteration. I aint talkin' bout chicken n' gravy biatch. Each handle object will consume
at least dis amount of memory fo' tha read buffer as well, so when
handlin nuff connections peep up fo' memory requirements). Right back up in yo muthafuckin ass. See also
\&\f(CW\*(C`max_read_size\*(C'\fR. Default: \f(CW2048\fR.
.IP "max_read_size => <bytes>" 4
.IX Item "max_read_size => <bytes>"
Da maximum read buffer size used by tha dynamic adjustment
algorithm: Each time AnyEvent::Handle can read \f(CW\*(C`read_size\*(C'\fR bytes in
one go it will double \f(CW\*(C`read_size\*(C'\fR up ta tha maximum given by this
option. I aint talkin' bout chicken n' gravy biatch. Default: \f(CW131072\fR or \f(CW\*(C`read_size\*(C'\fR, whichever is higher.
.IP "low_water_mark => <bytes>" 4
.IX Item "low_water_mark => <bytes>"
Sets tha number of bytes (default: \f(CW0\fR) dat make up a \*(L"empty\*(R" write
buffer: If tha buffer reaches dis size or gets even samlla it is
considered empty.
.Sp
Sometimes it can be beneficial (for performizzle reasons) ta add data to
the write buffer before it is straight-up drained yo, but dis be a rare case, as
the operatin system kernel probably buffers data as well, so tha default
is phat up in almost all cases.
.IP "linger => <seconds>" 4
.IX Item "linger => <seconds>"
If dis is non-zero (default: \f(CW3600\fR), tha destructor of the
AnyEvent::Handle object will check whether there is still outstanding
write data n' will install a watcher dat will write dis data ta the
socket. No errors is ghon be reported (this mostly matches how tha fuck tha operating
system treats outstandin data at socket close time).
.Sp
This aint gonna work fo' partial \s-1TLS\s0 data dat could not be encoded
yet. This data is ghon be lost. Callin tha \f(CW\*(C`stoptls\*(C'\fR method up in time might
help.
.ie n .IP "peername => $string" 4
.el .IP "peername => \f(CW$string\fR" 4
.IX Item "peername => $string"
A strang used ta identify tha remote joint \- probably tha \s-1DNS\s0 hostname
(\fInot\fR \s-1IDN\s0!) used ta create tha connection, rarely tha \s-1IP\s0 address.
.Sp
Apart from bein useful up in error lyrics, dis strang be also used up in \s-1TLS\s0
peername verification (see \f(CW\*(C`verify_peername\*(C'\fR up in AnyEvent::TLS). This
verification is ghon be skipped when \f(CW\*(C`peername\*(C'\fR aint specified or is
\&\f(CW\*(C`undef\*(C'\fR.
.ie n .IP "tls => ""accept"" | ""connect"" | Net::SSLeay::SSL object" 4
.el .IP "tls => ``accept'' | ``connect'' | Net::SSLeay::SSL object" 4
.IX Item "tls => accept | connect | Net::SSLeay::SSL object"
When dis parameta is given, it enablez \s-1TLS \s0(\s-1SSL\s0) mode, dat means
AnyEvent will start a \s-1TLS\s0 handshake as soon as tha connection has been
established n' will transparently encrypt/decrypt data afterwards.
.Sp
All \s-1TLS\s0 protocol errors is ghon be signalled as \f(CW\*(C`EPROTO\*(C'\fR, wit an
appropriate error message.
.Sp
\&\s-1TLS\s0 mode requires Net::SSLeay ta be installed (it is ghon be loaded
automatically when you try ta create a \s-1TLS\s0 handle): dis module don't
have a thugged-out dependency on dat module, so if yo' module requires it, you have
to add tha dependency yo ass. If Net::SSLeay cannot be loaded or is too
old, you git a \f(CW\*(C`EPROTO\*(C'\fR error.
.Sp
Unlike \s-1TCP, TLS\s0 has a server n' client side: fo' tha \s-1TLS\s0 server side, use
\&\f(CW\*(C`accept\*(C'\fR, n' fo' tha \s-1TLS\s0 client side of a cold-ass lil connection, use \f(CW\*(C`connect\*(C'\fR
mode.
.Sp
Yo ass can also provide yo' own \s-1TLS\s0 connection object yo, but you have
to make shizzle dat you call either \f(CW\*(C`Net::SSLeay::set_connect_state\*(C'\fR
or \f(CW\*(C`Net::SSLeay::set_accept_state\*(C'\fR on it before you pass it to
AnyEvent::Handle fo' realz. Also, dis module will take ballershizzle of dis connection
object.
.Sp
At some future point, AnyEvent::Handle might switch ta another \s-1TLS\s0
implementation, then tha option ta use yo' own session object will go
away.
.Sp
\&\fB\s-1IMPORTANT:\s0\fR since Net::SSLeay \*(L"objects\*(R" is straight-up only integers,
passin up in tha wack integer will lead ta certain crash. This most often
happens when one uses a stylish \f(CW\*(C`tls => 1\*(C'\fR n' is surprised bout the
segmentation fault.
.Sp
Use tha \f(CW\*(C`\->starttls\*(C'\fR method if you need ta start \s-1TLS\s0 negotiation later.
.ie n .IP "tls_ctx => $anyevent_tls" 4
.el .IP "tls_ctx => \f(CW$anyevent_tls\fR" 4
.IX Item "tls_ctx => $anyevent_tls"
Use tha given \f(CW\*(C`AnyEvent::TLS\*(C'\fR object ta create tha freshly smoked up \s-1TLS\s0 connection
(unless a cold-ass lil connection object was specified directly). If this
parameta is missin (or \f(CW\*(C`undef\*(C'\fR), then AnyEvent::Handle will use
\&\f(CW\*(C`AnyEvent::Handle::TLS_CTX\*(C'\fR.
.Sp
Instead of a object, you can also specify a hash reference wit \f(CW\*(C`key
=> value\*(C'\fR pairs. Those is ghon be passed ta AnyEvent::TLS ta create a
new \s-1TLS\s0 context object.
.ie n .IP "on_starttls => $cb\->($handle, $success[, $error_message])" 4
.el .IP "on_starttls => \f(CW$cb\fR\->($handle, \f(CW$success\fR[, \f(CW$error_message\fR])" 4
.IX Item "on_starttls => $cb->($handle, $success[, $error_message])"
This callback is ghon be invoked when tha \s-1TLS/SSL\s0 handshake has finished. Y'all KNOW dat shit, muthafucka! If
\&\f(CW$success\fR is true, then tha \s-1TLS\s0 handshake succeeded, otherwise it failed
(\f(CW\*(C`on_stoptls\*(C'\fR aint gonna be called up in dis case).
.Sp
Da session up in \f(CW\*(C`$handle\->{tls}\*(C'\fR can still be examined up in this
callback, even when tha handshake was not successful.
.Sp
\&\s-1TLS\s0 handshake failures aint gonna cause \f(CW\*(C`on_error\*(C'\fR ta be invoked when this
callback is up in effect, instead, tha error message is ghon be passed ta \f(CW\*(C`on_starttls\*(C'\fR.
.Sp
Without dis callback, handshake failures lead ta \f(CW\*(C`on_error\*(C'\fR being
called as usual.
.Sp
Note dat you cannot just call \f(CW\*(C`starttls\*(C'\fR again n' again n' again up in dis callback. If you
need ta do that, start a zero-second timer instead whose callback can
then call \f(CW\*(C`\->starttls\*(C'\fR again.
.ie n .IP "on_stoptls => $cb\->($handle)" 4
.el .IP "on_stoptls => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_stoptls => $cb->($handle)"
When a SSLv3/TLS shutdown/close notify/EOF is detected n' dis callback is
set, then it is ghon be invoked afta freein tha \s-1TLS\s0 session. I aint talkin' bout chicken n' gravy biatch. If it is not,
then a \s-1TLS\s0 shutdown condizzle is ghon be treated like a aiiight \s-1EOF\s0 condition
on tha handle.
.Sp
Da session up in \f(CW\*(C`$handle\->{tls}\*(C'\fR can still be examined up in this
callback.
.Sp
This callback will only be called on \s-1TLS\s0 shutdowns, not when the
underlyin handle signals \s-1EOF.\s0
.IP "json => \s-1JSON\s0 or \s-1JSON::XS\s0 object" 4
.IX Item "json => JSON or JSON::XS object"
This is tha json coder object used by tha \f(CW\*(C`json\*(C'\fR read n' write types.
.Sp
If you don't supply it, then AnyEvent::Handle will create n' use a
suitable one (on demand), which will write n' expect \s-1UTF\-8\s0 encoded \s-1JSON\s0
texts.
.Sp
Note dat yo ass is responsible ta depend on tha \s-1JSON\s0 module if you want to
use dis functionality, as AnyEvent aint gots a thugged-out dependency itself.
.RE
.RS 4
.RE
.ie n .IP "$fh = $handle\->fh" 4
.el .IP "\f(CW$fh\fR = \f(CW$handle\fR\->fh" 4
.IX Item "$fh = $handle->fh"
This method returns tha file handle used ta create tha AnyEvent::Handle object.
.ie n .IP "$handle\->on_error ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_error ($cb)" 4
.IX Item "$handle->on_error ($cb)"
Replace tha current \f(CW\*(C`on_error\*(C'\fR callback (see tha \f(CW\*(C`on_error\*(C'\fR constructor argument).
.ie n .IP "$handle\->on_eof ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_eof ($cb)" 4
.IX Item "$handle->on_eof ($cb)"
Replace tha current \f(CW\*(C`on_eof\*(C'\fR callback (see tha \f(CW\*(C`on_eof\*(C'\fR constructor argument).
.ie n .IP "$handle\->on_timeout ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_timeout ($cb)" 4
.IX Item "$handle->on_timeout ($cb)"
.PD 0
.ie n .IP "$handle\->on_rtimeout ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_rtimeout ($cb)" 4
.IX Item "$handle->on_rtimeout ($cb)"
.ie n .IP "$handle\->on_wtimeout ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_wtimeout ($cb)" 4
.IX Item "$handle->on_wtimeout ($cb)"
.PD
Replace tha current \f(CW\*(C`on_timeout\*(C'\fR, \f(CW\*(C`on_rtimeout\*(C'\fR or \f(CW\*(C`on_wtimeout\*(C'\fR
callback, or disablez tha callback (but not tha timeout) if \f(CW$cb\fR =
\&\f(CW\*(C`undef\*(C'\fR. Right back up in yo muthafuckin ass. See tha \f(CW\*(C`timeout\*(C'\fR constructor argument n' method.
.ie n .IP "$handle\->autocork ($boolean)" 4
.el .IP "\f(CW$handle\fR\->autocork ($boolean)" 4
.IX Item "$handle->autocork ($boolean)"
Enablez or disablez tha current autocork behaviour (see \f(CW\*(C`autocork\*(C'\fR
constructor argument). Chizzlez will only take effect on tha next write.
.ie n .IP "$handle\->no_delay ($boolean)" 4
.el .IP "\f(CW$handle\fR\->no_delay ($boolean)" 4
.IX Item "$handle->no_delay ($boolean)"
Enablez or disablez tha \f(CW\*(C`no_delay\*(C'\fR settin (see constructor argument of
the same name fo' details).
.ie n .IP "$handle\->keepkickin it ($boolean)" 4
.el .IP "\f(CW$handle\fR\->keepkickin it ($boolean)" 4
.IX Item "$handle->keepkickin it ($boolean)"
Enablez or disablez tha \f(CW\*(C`keepkickin it\*(C'\fR settin (see constructor argument of
the same name fo' details).
.ie n .IP "$handle\->oobinline ($boolean)" 4
.el .IP "\f(CW$handle\fR\->oobinline ($boolean)" 4
.IX Item "$handle->oobinline ($boolean)"
Enablez or disablez tha \f(CW\*(C`oobinline\*(C'\fR settin (see constructor argument of
the same name fo' details).
.ie n .IP "$handle\->keepkickin it ($boolean)" 4
.el .IP "\f(CW$handle\fR\->keepkickin it ($boolean)" 4
.IX Item "$handle->keepkickin it ($boolean)"
Enablez or disablez tha \f(CW\*(C`keepkickin it\*(C'\fR settin (see constructor argument of
the same name fo' details).
.ie n .IP "$handle\->on_starttls ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_starttls ($cb)" 4
.IX Item "$handle->on_starttls ($cb)"
Replace tha current \f(CW\*(C`on_starttls\*(C'\fR callback (see tha \f(CW\*(C`on_starttls\*(C'\fR constructor argument).
.ie n .IP "$handle\->on_stoptls ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_stoptls ($cb)" 4
.IX Item "$handle->on_stoptls ($cb)"
Replace tha current \f(CW\*(C`on_stoptls\*(C'\fR callback (see tha \f(CW\*(C`on_stoptls\*(C'\fR constructor argument).
.ie n .IP "$handle\->rbuf_max ($max_octets)" 4
.el .IP "\f(CW$handle\fR\->rbuf_max ($max_octets)" 4
.IX Item "$handle->rbuf_max ($max_octets)"
Configures tha \f(CW\*(C`rbuf_max\*(C'\fR settin (\f(CW\*(C`undef\*(C'\fR disablez it).
.ie n .IP "$handle\->wbuf_max ($max_octets)" 4
.el .IP "\f(CW$handle\fR\->wbuf_max ($max_octets)" 4
.IX Item "$handle->wbuf_max ($max_octets)"
Configures tha \f(CW\*(C`wbuf_max\*(C'\fR settin (\f(CW\*(C`undef\*(C'\fR disablez it).
.ie n .IP "$handle\->timeout ($seconds)" 4
.el .IP "\f(CW$handle\fR\->timeout ($seconds)" 4
.IX Item "$handle->timeout ($seconds)"
.PD 0
.ie n .IP "$handle\->rtimeout ($seconds)" 4
.el .IP "\f(CW$handle\fR\->rtimeout ($seconds)" 4
.IX Item "$handle->rtimeout ($seconds)"
.ie n .IP "$handle\->wtimeout ($seconds)" 4
.el .IP "\f(CW$handle\fR\->wtimeout ($seconds)" 4
.IX Item "$handle->wtimeout ($seconds)"
.PD
Configures (or disables) tha inactivitizzle timeout.
.Sp
Da timeout is ghon be checked instantly, so dis method might destroy the
handle before it returns.
.ie n .IP "$handle\->timeout_reset" 4
.el .IP "\f(CW$handle\fR\->timeout_reset" 4
.IX Item "$handle->timeout_reset"
.PD 0
.ie n .IP "$handle\->rtimeout_reset" 4
.el .IP "\f(CW$handle\fR\->rtimeout_reset" 4
.IX Item "$handle->rtimeout_reset"
.ie n .IP "$handle\->wtimeout_reset" 4
.el .IP "\f(CW$handle\fR\->wtimeout_reset" 4
.IX Item "$handle->wtimeout_reset"
.PD
Reset tha activitizzle timeout, as if data was received or sent.
.Sp
These methodz is skanky ta call.
.SS "\s-1WRITE QUEUE\s0"
.IX Subsection "WRITE QUEUE"
AnyEvent::Handle manages two queues per handle, one fo' freestylin n' one
for reading.
.PP
Da write queue is straight-up simple: you can add data ta its end, and
AnyEvent::Handle will automatically try ta git rid of it fo' yo thugged-out ass.
.PP
When data could be freestyled n' tha write buffer is shorta then tha low
wata mark, tha \f(CW\*(C`on_drain\*(C'\fR callback is ghon be invoked once.
.ie n .IP "$handle\->on_drain ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_drain ($cb)" 4
.IX Item "$handle->on_drain ($cb)"
Sets tha \f(CW\*(C`on_drain\*(C'\fR callback or clears it (see tha description of
\&\f(CW\*(C`on_drain\*(C'\fR up in tha constructor).
.Sp
This method may invoke callbacks (and therefore tha handle might be
destroyed afta it returns).
.ie n .IP "$handle\->push_write ($data)" 4
.el .IP "\f(CW$handle\fR\->push_write ($data)" 4
.IX Item "$handle->push_write ($data)"
Queues tha given scalar ta be written. I aint talkin' bout chicken n' gravy biatch. Yo ass can push as much data as
you want (only limited by tha available memory n' \f(CW\*(C`wbuf_max\*(C'\fR), as
\&\f(CW\*(C`AnyEvent::Handle\*(C'\fR buffers it independently of tha kernel.
.Sp
This method may invoke callbacks (and therefore tha handle might be
destroyed afta it returns).
.ie n .IP "$handle\->push_write (type => @args)" 4
.el .IP "\f(CW$handle\fR\->push_write (type => \f(CW@args\fR)" 4
.IX Item "$handle->push_write (type => @args)"
Instead of formattin yo' data yo ass, you can also let dis module
do tha thang by specifyin a type n' type-specific arguments, n' you can put dat on yo' toast. You
can also specify tha (fully qualified) name of a package, up in which
case AnyEvent tries ta load tha package n' then expects ta find the
\&\f(CW\*(C`anyevent_write_type\*(C'\fR function inside (see \*(L"custom write types\*(R", below).
.Sp
Predefined types is (if you have scams fo' additionizzle types, feel free to
drop by n' tell us):
.RS 4
.ie n .IP "netstrin => $string" 4
.el .IP "netstrin => \f(CW$string\fR" 4
.IX Item "netstrin => $string"
Formats tha given value as netstring
(http://cr.yp.to/proto/netstrings.txt, dis aint a recommendation ta use them).
.ie n .IP "packstrin => $format, $data" 4
.el .IP "packstrin => \f(CW$format\fR, \f(CW$data\fR" 4
.IX Item "packstrin => $format, $data"
An octet strang prefixed wit a encoded length. Da encodin \f(CW$format\fR
uses tha same ol' dirty format as a Perl \f(CW\*(C`pack\*(C'\fR format yo, but must specify a single
integer only (only one of \f(CW\*(C`cCsSlLqQiInNvVjJw\*(C'\fR be allowed, plus an
optionizzle \f(CW\*(C`!\*(C'\fR, \f(CW\*(C`<\*(C'\fR or \f(CW\*(C`>\*(C'\fR modifier).
.ie n .IP "json => $array_or_hashref" 4
.el .IP "json => \f(CW$array_or_hashref\fR" 4
.IX Item "json => $array_or_hashref"
Encodes tha given hash or array reference tha fuck into a \s-1JSON\s0 object. Unless you
provide yo' own \s-1JSON\s0 object, dis means it is ghon be encoded ta \s-1JSON\s0 text
in \s-1UTF\-8.\s0
.Sp
\&\s-1JSON\s0 objects (and arrays) is self-delimiting, so you can write \s-1JSON\s0 at
one end of a handle n' read dem all up in tha other end without rockin any
additionizzle framing.
.Sp
Da generated \s-1JSON\s0 text is guaranteed not ta contain any newlines: While
this module don't need delimitas afta or between \s-1JSON\s0 texts ta be
able ta read them, nuff other languages depend on dis shit.
.Sp
A simple \s-1RPC\s0 protocol dat interoperates easily wit others is ta send
\&\s-1JSON\s0 arrays (or objects, although arrays is probably tha betta chizzle as
they mimic how tha fuck function argument passin works) n' a newline afta each
\&\s-1JSON\s0 text:
.Sp
.Vb 2
\&   $handle\->push_write (json => ["method", "arg1", "arg2"]); # whatever
\&   $handle\->push_write ("\e012");
.Ve
.Sp
An AnyEvent::Handle receiver would simply use tha \f(CW\*(C`json\*(C'\fR read type and
rely on tha fact dat tha newline is ghon be skipped as leadin whitespace:
.Sp
.Vb 1
\&   $handle\->push_read (json => sub { mah $array = $_[1]; ... });
.Ve
.Sp
Other languages could read single lines terminated by a newline n' pass
this line tha fuck into they \s-1JSON\s0 decoder of chizzle.
.ie n .IP "storable => $reference" 4
.el .IP "storable => \f(CW$reference\fR" 4
.IX Item "storable => $reference"
Freezes tha given reference rockin Storable n' writes it ta the
handle. Uses tha \f(CW\*(C`nfreeze\*(C'\fR format.
.RE
.RS 4
.RE
.ie n .IP "$handle\->push_shutdown" 4
.el .IP "\f(CW$handle\fR\->push_shutdown" 4
.IX Item "$handle->push_shutdown"
Sometimes you know you wanna close tha socket afta freestylin yo' data
before dat shiznit was straight-up written. I aint talkin' bout chicken n' gravy biatch. One way ta do dat is ta replace your
\&\f(CW\*(C`on_drain\*(C'\fR handlez by a cold-ass lil callback dat shuts down tha socket (and set
\&\f(CW\*(C`low_water_mark\*(C'\fR ta \f(CW0\fR). This method be a gangbangin' finger-lickin' dirty-ass shorthand fo' just that, and
replaces tha \f(CW\*(C`on_drain\*(C'\fR callback with:
.Sp
.Vb 1
\&   sub { shutdown $_[0]{fh}, 1 }
.Ve
.Sp
This simply shuts down tha write side n' signals a \s-1EOF\s0 condizzle ta the
the peer.
.Sp
Yo ass can rely on tha aiiight read queue n' \f(CW\*(C`on_eof\*(C'\fR handling
afterwards. This is tha cleanest way ta close a cold-ass lil connection.
.Sp
This method may invoke callbacks (and therefore tha handle might be
destroyed afta it returns).
.ie n .IP "custom write types \- Package::anyevent_write_type $handle, @args" 4
.el .IP "custom write types \- Package::anyevent_write_type \f(CW$handle\fR, \f(CW@args\fR" 4
.IX Item "custom write types - Package::anyevent_write_type $handle, @args"
Instead of one of tha predefined types, you can also specify tha name of
a package fo' realz. AnyEvent will try ta load tha package n' then expects ta find
a function named \f(CW\*(C`anyevent_write_type\*(C'\fR inside. If it aint found, it
progressively tries ta load tha parent package until it either findz the
function (good) or runs outta packages (bad).
.Sp
Whenever tha given \f(CW\*(C`type\*(C'\fR is used, \f(CW\*(C`push_write\*(C'\fR will tha function with
the handle object n' tha remainin arguments.
.Sp
Da function is supposed ta return a single octet strang dat will be
appended ta tha write buffer, so you can menstrually treat dis function as a
\&\*(L"arguments ta on-the-wire-format\*(R" converter.
.Sp
Example: implement a cold-ass lil custom write type \f(CW\*(C`join\*(C'\fR dat joins tha remaining
arguments rockin tha straight-up original gangsta one.
.Sp
.Vb 1
\&   $handle\->push_write (My::Type => " ", 1,2,3);
\&
\&   # uses tha followin package, which can be defined up in tha "My::Type" or in
\&   # tha "My" modulez ta be auto\-loaded, or just bout anywhere when the
\&   # My::Type::anyevent_write_type is defined before invokin dat shit.
\&
\&   package My::Type;
\&
\&   sub anyevent_write_type {
\&      mah ($handle, $delim, @args) = @_;
\&
\&      join $delim, @args
\&   }
.Ve
.SS "\s-1READ QUEUE\s0"
.IX Subsection "READ QUEUE"
AnyEvent::Handle manages two queues per handle, one fo' freestylin n' one
for reading.
.PP
Da read queue is mo' complex than tha write queue. Well shiiiit, it can be used up in two
ways, tha \*(L"simple\*(R" way, rockin only \f(CW\*(C`on_read\*(C'\fR n' tha \*(L"complex\*(R" way, using
a queue.
.PP
In tha simple case, you just install a \f(CW\*(C`on_read\*(C'\fR callback n' whenever
new data arrives, it is ghon be called. Y'all KNOW dat shit, muthafucka! Yo ass can then remove some data (if
enough is there) from tha read buffer (\f(CW\*(C`$handle\->rbuf\*(C'\fR). Or you can
leave tha data there if you wanna accumulate mo' (e.g. when only a
partial message has been received so far), or chizzle tha read queue with
e.g. \f(CW\*(C`push_read\*(C'\fR.
.PP
In tha mo' complex case, you wanna queue multiple callbacks. In this
case, AnyEvent::Handle will call tha straight-up original gangsta queued callback each time new
data arrives (also tha last time it is queued) n' remove it when it has
done its thang (see \f(CW\*(C`push_read\*(C'\fR, below).
.PP
This way you can, fo' example, push three line-reads, followed by reading
a chunk of data, n' AnyEvent::Handle will execute dem up in order.
.PP
Example 1: \s-1EPP\s0 protocol parser n' shit. \s-1EPP\s0 sendz 4 byte length info, followed by
the specified number of bytes which give a \s-1XML\s0 datagram.
.PP
.Vb 6
\&   # up in tha default state, expect some header bytes
\&   $handle\->on_read (sub {
\&      # some data is here, now queue tha length\-header\-read (4 octets)
\&      shift\->unshift_read (chunk => 4, sub {
\&         # header arrived, decode
\&         mah $len = unpack "N", $_[1];
\&
\&         # now read tha payload
\&         shift\->unshift_read (chunk => $len, sub {
\&            mah $xml = $_[1];
\&            # handle xml
\&         });
\&      });
\&   });
.Ve
.PP
Example 2: Implement a cold-ass lil client fo' a protocol dat replies either wit \*(L"\s-1OK\*(R"\s0
and another line or \*(L"\s-1ERROR\*(R"\s0 fo' tha straight-up original gangsta request dat is sent, n' 64
bytes fo' tha second request. Cuz of tha availabilitizzle of a queue, we can
just pipeline bustin  both requests n' manipulate tha queue as necessary
in tha callbacks.
.PP
When tha straight-up original gangsta callback is called n' sees a \*(L"\s-1OK\*(R"\s0 response, it will
\&\f(CW\*(C`unshift\*(C'\fR another line-read. Y'all KNOW dat shit, muthafucka! This line-read is ghon be queued \fIbefore\fR the
64\-byte chunk callback.
.PP
.Vb 2
\&   # request one, returns either "OK + extra line" or "ERROR"
\&   $handle\->push_write ("request 1\e015\e012");
\&
\&   # we expect "ERROR" or "OK" as response, so push a line read
\&   $handle\->push_read (line => sub {
\&      # if we gots a "OK", we gotta _prepend_ another line,
\&      # so it is ghon be read before tha second request readz its 64 bytes
\&      # which is already up in tha queue when dis callback is called
\&      # our phat asses don\*(Aqt do dis up in case we gots a error
\&      if ($_[1] eq "OK") {
\&         $_[0]\->unshift_read (line => sub {
\&            mah $response = $_[1];
\&            ...
\&         });
\&      }
\&   });
\&
\&   # request two, simply returns 64 octets
\&   $handle\->push_write ("request 2\e015\e012");
\&
\&   # simply read 64 bytes, always
\&   $handle\->push_read (chunk => 64, sub {
\&      mah $response = $_[1];
\&      ...
\&   });
.Ve
.ie n .IP "$handle\->on_read ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_read ($cb)" 4
.IX Item "$handle->on_read ($cb)"
This replaces tha currently set \f(CW\*(C`on_read\*(C'\fR callback, or clears it (when
the freshly smoked up callback is \f(CW\*(C`undef\*(C'\fR). Right back up in yo muthafuckin ass. See tha description of \f(CW\*(C`on_read\*(C'\fR up in the
constructor.
.Sp
This method may invoke callbacks (and therefore tha handle might be
destroyed afta it returns).
.ie n .IP "$handle\->rbuf" 4
.el .IP "\f(CW$handle\fR\->rbuf" 4
.IX Item "$handle->rbuf"
Returns tha read buffer (as a modifiable lvalue). Yo ass can also access the
read buffer directly as tha \f(CW\*(C`\->{rbuf}\*(C'\fR member, if you want (this is
much faster, n' no less clean).
.Sp
Da only operation allowed on tha read buffer (apart from lookin at it)
is removin data from its beginning. Otherwise modifyin or appendin to
it aint allowed n' will lead ta hard-to-track-down bugs.
.Sp
\&\s-1NOTE:\s0 Da read buffer should only be used or modified up in tha \f(CW\*(C`on_read\*(C'\fR
callback or when \f(CW\*(C`push_read\*(C'\fR or \f(CW\*(C`unshift_read\*(C'\fR is used wit a single
callback (i.e. untyped). Typed \f(CW\*(C`push_read\*(C'\fR n' \f(CW\*(C`unshift_read\*(C'\fR methods
will manage tha read buffer on they own.
.ie n .IP "$handle\->push_read ($cb)" 4
.el .IP "\f(CW$handle\fR\->push_read ($cb)" 4
.IX Item "$handle->push_read ($cb)"
.PD 0
.ie n .IP "$handle\->unshift_read ($cb)" 4
.el .IP "\f(CW$handle\fR\->unshift_read ($cb)" 4
.IX Item "$handle->unshift_read ($cb)"
.PD
Append tha given callback ta tha end of tha queue (\f(CW\*(C`push_read\*(C'\fR) or
prepend it (\f(CW\*(C`unshift_read\*(C'\fR).
.Sp
Da callback is called each time some additionizzle read data arrives.
.Sp
It must check whether enough data is up in tha read buffer already.
.Sp
If not enough data be available, it must return tha empty list or a gangbangin' false
value, up in which case it is ghon be called repeatedly until enough data is
available (or a error condizzle is detected).
.Sp
If enough data was available, then tha callback must remove all data it is
horny bout (which can be none at all) n' return a legit value fo' realz. Afta returning
true, it is ghon be removed from tha queue.
.Sp
These methodz may invoke callbacks (and therefore tha handle might be
destroyed afta it returns).
.ie n .IP "$handle\->push_read (type => @args, $cb)" 4
.el .IP "\f(CW$handle\fR\->push_read (type => \f(CW@args\fR, \f(CW$cb\fR)" 4
.IX Item "$handle->push_read (type => @args, $cb)"
.PD 0
.ie n .IP "$handle\->unshift_read (type => @args, $cb)" 4
.el .IP "\f(CW$handle\fR\->unshift_read (type => \f(CW@args\fR, \f(CW$cb\fR)" 4
.IX Item "$handle->unshift_read (type => @args, $cb)"
.PD
Instead of providin a cold-ass lil callback dat parses tha data itself you can chose
between a fuckin shitload of predefined parsin formats, fo' chunkz of data, lines
etc. Yo ass can also specify tha (fully qualified) name of a package, in
which case AnyEvent tries ta load tha package n' then expects ta find the
\&\f(CW\*(C`anyevent_read_type\*(C'\fR function inside (see \*(L"custom read types\*(R", below).
.Sp
Predefined types is (if you have scams fo' additionizzle types, feel free to
drop by n' tell us):
.RS 4
.ie n .IP "chunk => $octets, $cb\->($handle, $data)" 4
.el .IP "chunk => \f(CW$octets\fR, \f(CW$cb\fR\->($handle, \f(CW$data\fR)" 4
.IX Item "chunk => $octets, $cb->($handle, $data)"
Invoke tha callback only once \f(CW$octets\fR bytes done been read. Y'all KNOW dat shit, muthafucka! Pass the
data read ta tha callback. Da callback aint NEVER gonna be called wit less
data.
.Sp
Example: read 2 bytes.
.Sp
.Vb 3
\&   $handle\->push_read (chunk => 2, sub {
\&      say "yay " . unpack "H*", $_[1];
\&   });
.Ve
.ie n .IP "line => [$eol, ]$cb\->($handle, $line, $eol)" 4
.el .IP "line => [$eol, ]$cb\->($handle, \f(CW$line\fR, \f(CW$eol\fR)" 4
.IX Item "line => [$eol, ]$cb->($handle, $line, $eol)"
Da callback is ghon be called only once a gangbangin' full line (includin tha end of
line marker, \f(CW$eol\fR) has been read. Y'all KNOW dat shit, muthafucka! This line (excludin tha end of line
marker) is ghon be passed ta tha callback as second argument (\f(CW$line\fR), and
the end of line marker as tha third argument (\f(CW$eol\fR).
.Sp
Da end of line marker, \f(CW$eol\fR, can be either a string, up in which case it
will be interpreted as a gangbangin' fixed record end marker, or it can be a regex
object (e.g. pimped by \f(CW\*(C`qr\*(C'\fR), up in which case it is interpreted as a
regular expression.
.Sp
Da end of line marker argument \f(CW$eol\fR is optional, if it is missin (\s-1NOT\s0
undef), then \f(CW\*(C`qr|\e015?\e012|\*(C'\fR is used (which is phat fo' most internet
protocols).
.Sp
Partial lines all up in tha end of tha stream aint NEVER gonna be returned, as they are
not marked by tha end of line marker.
.ie n .IP "regex => $accept[, $reject[, $skip], $cb\->($handle, $data)" 4
.el .IP "regex => \f(CW$accept\fR[, \f(CW$reject\fR[, \f(CW$skip\fR], \f(CW$cb\fR\->($handle, \f(CW$data\fR)" 4
.IX Item "regex => $accept[, $reject[, $skip], $cb->($handle, $data)"
Makes a regex match against tha regex object \f(CW$accept\fR n' returns
everythang up ta n' includin tha match.
.Sp
Example: read a single line terminated by '\en'.
.Sp
.Vb 1
\&   $handle\->push_read (regex => qr<\en>, sub { ... });
.Ve
.Sp
If \f(CW$reject\fR is given n' not undef, then it determines when tha data is
to be rejected: it is matched against tha data when tha \f(CW$accept\fR regex
does not match n' generates a \f(CW\*(C`EBADMSG\*(C'\fR error when it matches. This is
useful ta quickly reject wack data (to avoid waitin fo' a timeout or a
receive buffer overflow).
.Sp
Example: expect a single decimal number followed by whitespace, reject
anythang else (not tha use of a anchor).
.Sp
.Vb 1
\&   $handle\->push_read (regex => qr<^[0\-9]+\es>, qr<[^0\-9]>, sub { ... });
.Ve
.Sp
If \f(CW$skip\fR is given n' not \f(CW\*(C`undef\*(C'\fR, then it is ghon be matched against
the receive buffer when neither \f(CW$accept\fR nor \f(CW$reject\fR match,
and every last muthafuckin thang precedin n' includin tha match is ghon be accepted
unconditionally. This is useful ta skip big-ass amountz of data dat you
know cannot be matched, so dat tha \f(CW$accept\fR or \f(CW$reject\fR regex do not
have ta start matchin from tha beginning. This is purely a optimisation
and is probably worth it only when you expect mo' than all dem kilobytes.
.Sp
Example: expect a http header, which endz at \f(CW\*(C`\e015\e012\e015\e012\*(C'\fR. Right back up in yo muthafuckin ass. Since we
expect tha header ta be straight-up big-ass (it aint up in practice yo, but...), we use
a skip regex ta skip initial portions. Da skip regex is tricky up in that
it only accepts suttin' not endin up in either \e015 or \e012, as these are
required fo' tha accept regex.
.Sp
.Vb 5
\&   $handle\->push_read (regex =>
\&      qr<\e015\e012\e015\e012>,
\&      undef, # no reject
\&      qr<^.*[^\e015\e012]>,
\&      sub { ... });
.Ve
.ie n .IP "netstrin => $cb\->($handle, $string)" 4
.el .IP "netstrin => \f(CW$cb\fR\->($handle, \f(CW$string\fR)" 4
.IX Item "netstrin => $cb->($handle, $string)"
A netstrin (http://cr.yp.to/proto/netstrings.txt, dis aint a endorsement).
.Sp
Throws a error wit \f(CW$!\fR set ta \s-1EBADMSG\s0 on format violations.
.ie n .IP "packstrin => $format, $cb\->($handle, $string)" 4
.el .IP "packstrin => \f(CW$format\fR, \f(CW$cb\fR\->($handle, \f(CW$string\fR)" 4
.IX Item "packstrin => $format, $cb->($handle, $string)"
An octet strang prefixed wit a encoded length. Da encodin \f(CW$format\fR
uses tha same ol' dirty format as a Perl \f(CW\*(C`pack\*(C'\fR format yo, but must specify a single
integer only (only one of \f(CW\*(C`cCsSlLqQiInNvVjJw\*(C'\fR be allowed, plus an
optionizzle \f(CW\*(C`!\*(C'\fR, \f(CW\*(C`<\*(C'\fR or \f(CW\*(C`>\*(C'\fR modifier).
.Sp
For example, \s-1DNS\s0 over \s-1TCP\s0 uses a prefix of \f(CW\*(C`n\*(C'\fR (2 octet network order),
\&\s-1EPP\s0 uses a prefix of \f(CW\*(C`N\*(C'\fR (4 octtes).
.Sp
Example: read a funky-ass block of data prefixed by its length up in BER-encoded
format (very efficient).
.Sp
.Vb 3
\&   $handle\->push_read (packstrin => "w", sub {
\&      mah ($handle, $data) = @_;
\&   });
.Ve
.ie n .IP "json => $cb\->($handle, $hash_or_arrayref)" 4
.el .IP "json => \f(CW$cb\fR\->($handle, \f(CW$hash_or_arrayref\fR)" 4
.IX Item "json => $cb->($handle, $hash_or_arrayref)"
Readz a \s-1JSON\s0 object or array, decodes it n' passes it ta the
callback. When a parse error occurs, a \f(CW\*(C`EBADMSG\*(C'\fR error is ghon be raised.
.Sp
If a \f(CW\*(C`json\*(C'\fR object was passed ta tha constructor, then dat is ghon be used
for tha final decode, otherwise it will create a \s-1JSON\s0 coder expectin \s-1UTF\-8.\s0
.Sp
This read type uses tha incremenstrual parser available wit \s-1JSON\s0 version
2.09 (and \s-1JSON::XS\s0 version 2.2) n' above. Yo ass gotta provide a
dependency on yo' own: dis module will load tha \s-1JSON\s0 module yo, but
AnyEvent do not depend on it itself.
.Sp
Since \s-1JSON\s0 texts is straight-up self-delimiting, tha \f(CW\*(C`json\*(C'\fR read n' write
types is a ideal simple \s-1RPC\s0 protocol: just exchange \s-1JSON\s0 datagrams. Right back up in yo muthafuckin ass. See
the \f(CW\*(C`json\*(C'\fR write type description, above, fo' a actual example.
.ie n .IP "storable => $cb\->($handle, $ref)" 4
.el .IP "storable => \f(CW$cb\fR\->($handle, \f(CW$ref\fR)" 4
.IX Item "storable => $cb->($handle, $ref)"
Deserialises a Storable frozen representation as freestyled by the
\&\f(CW\*(C`storable\*(C'\fR write type (BER-encoded length prefix followed by nfreeze'd
data).
.Sp
Raises \f(CW\*(C`EBADMSG\*(C'\fR error if tha data could not be decoded.
.ie n .IP "tls_detect => $cb\->($handle, $detect, $major, $minor)" 4
.el .IP "tls_detect => \f(CW$cb\fR\->($handle, \f(CW$detect\fR, \f(CW$major\fR, \f(CW$minor\fR)" 4
.IX Item "tls_detect => $cb->($handle, $detect, $major, $minor)"
Checks tha input stream fo' a valid \s-1SSL\s0 or \s-1TLS\s0 handshake TLSPaintext
record without consumin anything. Only \s-1SSL\s0 version 3 or higher
is handled, up ta tha fictituous protocol 4.x (but both \s-1SSL3+\s0 and
SSL2\-compatible framin is supported).
.Sp
If it detects dat tha input data is likely \s-1TLS,\s0 it calls tha callback
with a legit value fo' \f(CW$detect\fR n' tha (on-wire) \s-1TLS\s0 version as second
and third argument (\f(CW$major\fR is \f(CW3\fR, n' \f(CW$minor\fR is 0..3 fo' \s-1SSL
3.0, TLS 1.0, 1.1\s0 n' 1.2, respectively).  If it detects tha input to
be definitely not \s-1TLS,\s0 it calls tha callback wit a gangbangin' false value for
\&\f(CW$detect\fR.
.Sp
Da callback could use dis shiznit ta decizzle whether or not ta start
\&\s-1TLS\s0 negotiation.
.Sp
In all cases tha data read so far is passed ta tha followin read
handlezs.
.Sp
Usually you wanna use tha \f(CW\*(C`tls_autostart\*(C'\fR read type instead.
.Sp
If you wanna design a protocol dat works up in tha presence of \s-1TLS\s0
dtection, make shizzle dat any non-TLS data don't start wit tha octet 22
(\s-1ASCII SYN, 16\s0 hex) or 128\-255 (i.e. highest bit set). Da checks this
read type do is a lil' bit mo' strict yo, but might losen up in tha future to
accomodate protocol chizzles.
.Sp
This read type do not rely on AnyEvent::TLS (and thus, not on
Net::SSLeay).
.ie n .IP "tls_autostart => $tls[, $tls_ctx]" 4
.el .IP "tls_autostart => \f(CW$tls\fR[, \f(CW$tls_ctx\fR]" 4
.IX Item "tls_autostart => $tls[, $tls_ctx]"
Tries ta detect a valid \s-1SSL\s0 or \s-1TLS\s0 handshake. If one is detected, it tries
to start tls by callin \f(CW\*(C`starttls\*(C'\fR wit tha given arguments.
.Sp
In practise, \f(CW$tls\fR must be \f(CW\*(C`accept\*(C'\fR, or a Net::SSLeay context dat has
been configured ta accept, as servers do not normally bust a handshake on
their own n' ths cannot be detected up in dis way.
.Sp
See \f(CW\*(C`tls_detect\*(C'\fR above fo' mo' details.
.Sp
Example: give tha client a cold-ass lil chizzle ta start \s-1TLS\s0 before acceptin a text
line.
.Sp
.Vb 4
\&   $hdl\->push_read (tls_detect => "accept");
\&   $hdl\->push_read (line => sub {
\&      print "received ", ($_[0]{tls} ? "encrypted" : "cleartext"), " <$_[1]>\en";
\&   });
.Ve
.RE
.RS 4
.RE
.ie n .IP "custom read types \- Package::anyevent_read_type $handle, $cb, @args" 4
.el .IP "custom read types \- Package::anyevent_read_type \f(CW$handle\fR, \f(CW$cb\fR, \f(CW@args\fR" 4
.IX Item "custom read types - Package::anyevent_read_type $handle, $cb, @args"
Instead of one of tha predefined types, you can also specify tha name
of a package fo' realz. AnyEvent will try ta load tha package n' then expects to
find a gangbangin' function named \f(CW\*(C`anyevent_read_type\*(C'\fR inside. If it aint found, it
progressively tries ta load tha parent package until it either findz the
function (good) or runs outta packages (bad).
.Sp
Whenever dis type is used, \f(CW\*(C`push_read\*(C'\fR will invoke tha function wit the
handle object, tha original gangsta callback n' tha remainin arguments.
.Sp
Da function is supposed ta return a cold-ass lil callback (usually a cold-ass lil closure) that
works as a plain read callback (see \f(CW\*(C`\->push_read ($cb)\*(C'\fR), so you can
mentally treat tha function as a \*(L"configurable read type ta read callback\*(R"
converter.
.Sp
It should invoke tha original gangsta callback when it is done readin (remember
to pass \f(CW$handle\fR as first argument as all other callbacks do that,
although there is no strict requirement on this).
.Sp
For examples, peep tha source of dis module (\fIperldoc \-m
AnyEvent::Handle\fR, search fo' \f(CW\*(C`register_read_type\*(C'\fR)).
.ie n .IP "$handle\->stop_read" 4
.el .IP "\f(CW$handle\fR\->stop_read" 4
.IX Item "$handle->stop_read"
.PD 0
.ie n .IP "$handle\->start_read" 4
.el .IP "\f(CW$handle\fR\->start_read" 4
.IX Item "$handle->start_read"
.PD
In rare cases you straight-up do not wanna read anythang from the
socket. In dis case you can call \f(CW\*(C`stop_read\*(C'\fR. Neither \f(CW\*(C`on_read\*(C'\fR nor
any queued callbacks is ghon be executed then. I aint talkin' bout chicken n' gravy biatch. To start readin again, call
\&\f(CW\*(C`start_read\*(C'\fR.
.Sp
Note dat AnyEvent::Handle will automatically \f(CW\*(C`start_read\*(C'\fR fo' you when
you chizzle tha \f(CW\*(C`on_read\*(C'\fR callback or push/unshift a read callback, n' it
will automatically \f(CW\*(C`stop_read\*(C'\fR fo' you when neither \f(CW\*(C`on_read\*(C'\fR is set nor
there is any read requests up in tha queue.
.Sp
In olda versionz of dis module (<= 5.3), these methodz had no effect,
as \s-1TLS\s0 do not support half-duplex connections. In current versions they
work as expected, as dis behaviour is required ta avoid certain resource
attacks, where tha program would be forced ta read (and buffer) arbitrary
amountz of data before bein able ta bust some data. Da drawback is that
some readingz of tha the \s-1SSL/TLS\s0 justifications basically require this
battle ta be working, as \s-1SSL/TLS\s0 implementations might stall bustin  data
durin a rehandshake.
.Sp
As a guideline, durin tha initial handshake, you should not stop reading,
and as a cold-ass lil client, it might cause problems, dependin on yo' application.
.ie n .IP "$handle\->starttls ($tls[, $tls_ctx])" 4
.el .IP "\f(CW$handle\fR\->starttls ($tls[, \f(CW$tls_ctx\fR])" 4
.IX Item "$handle->starttls ($tls[, $tls_ctx])"
Instead of startin \s-1TLS\s0 negotiation immediately when tha AnyEvent::Handle
object is pimped, you can also do dat at a lata time by calling
\&\f(CW\*(C`starttls\*(C'\fR. Right back up in yo muthafuckin ass. See tha \f(CW\*(C`tls\*(C'\fR constructor argument fo' general info.
.Sp
Startin \s-1TLS\s0 is currently a asynchronous operation \- when you push some
write data n' then call \f(CW\*(C`\->starttls\*(C'\fR then \s-1TLS\s0 negotiation will start
immediately, afta which tha queued write data is then sent. This might
change up in future versions, so dopest make shizzle you have no outstandin write
data when callin dis method.
.Sp
Da first argument is tha same ol' dirty as tha \f(CW\*(C`tls\*(C'\fR constructor argument (either
\&\f(CW"connect"\fR, \f(CW"accept"\fR or a existin Net::SSLeay object).
.Sp
Da second argument is tha optionizzle \f(CW\*(C`AnyEvent::TLS\*(C'\fR object dat is used
when AnyEvent::Handle has ta create its own \s-1TLS\s0 connection object, or
a hash reference wit \f(CW\*(C`key => value\*(C'\fR pairs dat is ghon be used to
construct a freshly smoked up context.
.Sp
Da \s-1TLS\s0 connection object will end up in \f(CW\*(C`$handle\->{tls}\*(C'\fR, tha \s-1TLS\s0
context up in \f(CW\*(C`$handle\->{tls_ctx}\*(C'\fR afta dis call n' can be used or
changed ta yo' liking. Note dat tha handshake might have already started
when dis function returns.
.Sp
Cuz of bugs up in OpenSSL, it might or might not be possible ta do multiple
handshakes on tha same stream. Well shiiiit, it is dopest ta not attempt ta use the
stream afta stoppin \s-1TLS.\s0
.Sp
This method may invoke callbacks (and therefore tha handle might be
destroyed afta it returns).
.ie n .IP "$handle\->stoptls" 4
.el .IP "\f(CW$handle\fR\->stoptls" 4
.IX Item "$handle->stoptls"
Shuts down tha \s-1SSL\s0 connection \- dis cook up a proper \s-1EOF\s0 handshake by
sendin a cold-ass lil close notify ta tha other side yo, but since OpenSSL don't
support non-blockin shut downs, it aint guaranteed dat you can re-use
the stream afterwards.
.Sp
This method may invoke callbacks (and therefore tha handle might be
destroyed afta it returns).
.ie n .IP "$handle\->resettls" 4
.el .IP "\f(CW$handle\fR\->resettls" 4
.IX Item "$handle->resettls"
This rarely-used method simply resets n' \s-1TLS\s0 state on tha handle, usually
causin data loss.
.Sp
One case where it may be useful is when you wanna skip over tha data in
the stream but yo ass is not horny bout interpretin it, so data loss is
no concern.
.ie n .IP "$handle\->destroy" 4
.el .IP "\f(CW$handle\fR\->destroy" 4
.IX Item "$handle->destroy"
Shuts down tha handle object as much as possible \- dis call ensures that
no further callbacks is ghon be invoked n' as nuff resources as possible
will be freed. Y'all KNOW dat shit, muthafucka! Any method yo big-ass booty is ghon call on tha handle object after
destroyin it up in dis way is ghon be silently ignored (and it will return the
empty list).
.Sp
Normally, you can just \*(L"forget\*(R" any references ta a AnyEvent::Handle
object n' it will simply shut down. I aint talkin' bout chicken n' gravy biatch. This works up in fatal error n' \s-1EOF\s0
callbacks, as well as code outside. Well shiiiit, it do \fI\s-1NOT\s0\fR work up in a read or write
callback, so when you wanna destroy tha AnyEvent::Handle object from
within such a callback. Yo ass \fI\s-1MUST\s0\fR call \f(CW\*(C`\->destroy\*(C'\fR explicitly in
that case.
.Sp
Destroyin tha handle object up in dis way has tha advantage dat callbacks
will be removed as well, so if dem is tha only reference holdaz (as
is common), then one don't need ta do anythang special ta break any
reference cycles.
.Sp
Da handle might still linger up in tha background n' write up remaining
data, as specified by tha \f(CW\*(C`linger\*(C'\fR option, however.
.ie n .IP "$handle\->destroyed" 4
.el .IP "\f(CW$handle\fR\->destroyed" 4
.IX Item "$handle->destroyed"
Returns false as long as tha handle aint been destroyed by a cold-ass lil call ta \f(CW\*(C`\->destroy\*(C'\fR, legit otherwise.
.Sp
Can be useful ta decizzle whether tha handle is still valid afta some
callback possibly destroyed tha handle. For example, \f(CW\*(C`\->push_write\*(C'\fR,
\&\f(CW\*(C`\->starttls\*(C'\fR n' other methodz can call user callbacks, which up in turn
can destroy tha handle, so work can be avoided by checkin sometimes:
.Sp
.Vb 3
\&   $hdl\->starttls ("accept");
\&   return if $hdl\->destroyed;
\&   $hdl\->push_write (...
.Ve
.Sp
Note dat tha call ta \f(CW\*(C`push_write\*(C'\fR will silently be ignored if tha handle
has been destroyed, so often you can just ignore tha possibilitizzle of the
handle bein destroyed.
.IP "AnyEvent::Handle::TLS_CTX" 4
.IX Item "AnyEvent::Handle::TLS_CTX"
This function creates n' returns tha AnyEvent::TLS object used by default
for \s-1TLS\s0 mode.
.Sp
Da context is pimped by callin AnyEvent::TLS without any arguments.
.SH "NONFREQUENTLY ASKED QUESTIONS"
.IX Header "NONFREQUENTLY ASKED QUESTIONS"
.ie n .IP "I ""undef"" tha AnyEvent::Handle reference inside mah callback n' still git further invocations!" 4
.el .IP "I \f(CWundef\fR tha AnyEvent::Handle reference inside mah callback n' still git further invocations!" 4
.IX Item "I undef tha AnyEvent::Handle reference inside mah callback n' still git further invocations!"
Thatz cuz AnyEvent::Handle keeps a reference ta itself when handling
read or write callbacks.
.Sp
It be only safe ta \*(L"forget\*(R" tha reference inside \s-1EOF\s0 or error callbacks,
from within all other callbacks, you need ta explicitly call tha \f(CW\*(C`\->destroy\*(C'\fR method.
.ie n .IP "Why is mah ""on_eof"" callback never called?" 4
.el .IP "Why is mah \f(CWon_eof\fR callback never called?" 4
.IX Item "Why is mah on_eof callback never called?"
Probably cuz yo' \f(CW\*(C`on_error\*(C'\fR callback is bein called instead: When
you have outstandin requests up in yo' read queue, then a \s-1EOF\s0 is
considered a error as you clearly expected some data.
.Sp
To avoid this, make shizzle you have a empty read queue whenever yo' handle
is supposed ta be \*(L"idle\*(R" (i.e. connection closes is O.K.). Yo ass can set
an \f(CW\*(C`on_read\*(C'\fR handlez dat simply pushes tha straight-up original gangsta read requests up in the
queue.
.Sp
See also tha next question, which explains dis up in a lil' bit mo' detail.
.IP "How tha fuck can I serve requests up in a loop?" 4
.IX Item "How tha fuck can I serve requests up in a loop?"
Most protocols consist of some setup phase (authentication fo' example)
followed by a request handlin phase, where tha server waits fo' requests
and handlez them, up in a loop.
.Sp
There is two blingin variants: Da first (traditional, better) variant
handlez requests until tha server gets some \s-1QUIT\s0 command, causin it to
close tha connection first (highly desirable fo' a funky-ass busy \s-1TCP\s0 server) fo' realz. A
client droppin tha connection be a error, which means dis variant can
detect a unexpected detection close.
.Sp
To handle dis case, always make shizzle you gotz a non-empty read queue, by
pushin tha \*(L"read request start\*(R" handlez on it:
.Sp
.Vb 3
\&   # we assume a request starts wit a single line
\&   mah @start_request; @start_request = (line => sub {
\&      mah ($hdl, $line) = @_;
\&
\&      ... handle request
\&
\&      # push next request read, possibly from a nested callback
\&      $hdl\->push_read (@start_request);
\&   });
\&
\&   # auth done, now go tha fuck into request handlin loop
\&   # now push tha straight-up original gangsta @start_request
\&   $hdl\->push_read (@start_request);
.Ve
.Sp
By always havin a outstandin \f(CW\*(C`push_read\*(C'\fR, tha handle always expects
some data n' raises tha \f(CW\*(C`EPIPE\*(C'\fR error when tha connction is dropped
unexpectedly.
.Sp
Da second variant be a protocol where tha client can drop tha connection
at any time. For \s-1TCP,\s0 dis means dat tha server machine may run up of
sockets easier, n' up in general, it means you cannot distinguish a protocl
failure/client crash from a aiiight connection close. Nevertheless, these
kindz of protocols is common (and sometimes even tha dopest solution ta the
problem).
.Sp
Havin a outstandin read request at all times is possible if you ignore
\&\f(CW\*(C`EPIPE\*(C'\fR errors yo, but dis don't help wit when tha client drops the
connection durin a request, which would still be a error.
.Sp
A betta solution is ta push tha initial request read up in a \f(CW\*(C`on_read\*(C'\fR
callback. This avoidz a error, as when tha server don't expect data
(i.e. is idly waitin fo' tha next request, a \s-1EOF\s0 aint gonna raise an
error yo, but simply result up in a \f(CW\*(C`on_eof\*(C'\fR callback. Well shiiiit, it be also a lil' bit slower
and simpler:
.Sp
.Vb 3
\&   # auth done, now go tha fuck into request handlin loop
\&   $hdl\->on_read (sub {
\&      mah ($hdl) = @_;
\&
\&      # called each time we receive data but tha read queue is empty
\&      # simply start read tha request
\&
\&      $hdl\->push_read (line => sub {
\&         mah ($hdl, $line) = @_;
\&
\&         ... handle request
\&
\&         # do not a god damn thang special when tha request has been handled, just
\&         # let tha request queue go empty.
\&      });
\&   });
.Ve
.IP "I git different callback invocations up in \s-1TLS\s0 mode/Why can't I pause reading?" 4
.IX Item "I git different callback invocations up in TLS mode/Why can't I pause reading?"
Unlike, say, \s-1TCP, TLS\s0 connections do not consist of two independent
communication channels, one fo' each direction. I aint talkin' bout chicken n' gravy biatch. Or put differently, the
read n' write directions is not independent of each other: you cannot
write data unless yo ass be also prepared ta read, n' vice versa.
.Sp
This means that, up in \s-1TLS\s0 mode, you might git \f(CW\*(C`on_error\*(C'\fR or \f(CW\*(C`on_eof\*(C'\fR
callback invocations when yo ass is not expectin any read data \- tha reason
is dat AnyEvent::Handle always readz up in \s-1TLS\s0 mode.
.Sp
Durin tha connection, you gotta make shizzle dat you always have a
non-empty read-queue, or a \f(CW\*(C`on_read\*(C'\fR watcher n' shiznit fo' realz. At tha end of the
connection (or when you no longer wanna use it) you can call the
\&\f(CW\*(C`destroy\*(C'\fR method.
.IP "How tha fuck do I read data until tha other side closes tha connection?" 4
.IX Item "How tha fuck do I read data until tha other side closes tha connection?"
If you just wanna read yo' data tha fuck into a perl scalar, tha easiest way
to bust dis is by settin a \f(CW\*(C`on_read\*(C'\fR callback dat do nothing,
clearin tha \f(CW\*(C`on_eof\*(C'\fR callback n' up in tha \f(CW\*(C`on_error\*(C'\fR callback, tha data
will be up in \f(CW\*(C`$_[0]{rbuf}\*(C'\fR:
.Sp
.Vb 5
\&   $handle\->on_read (sub { });
\&   $handle\->on_eof (undef);
\&   $handle\->on_error (sub {
\&      mah $data = delete $_[0]{rbuf};
\&   });
.Ve
.Sp
Note dat dis example removes tha \f(CW\*(C`rbuf\*(C'\fR member from tha handle object,
which aint normally allowed by tha \s-1API.\s0 It be expressly permitted in
this case only, as tha handle object need ta be destroyed afterwards.
.Sp
Da reason ta use \f(CW\*(C`on_error\*(C'\fR is dat \s-1TCP\s0 connections, cuz of latencies
and packets loss, might git closed like violently wit a error, when in
fact all data has been received.
.Sp
It be probably betta ta use acknowledgements when transferrin data,
to make shizzle tha other side aint just took a dirt nap n' you gots tha data
intact. This be also one reason why all kindsa muthafuckin internizzle protocols have an
explicit \s-1QUIT\s0 command.
.IP "I don't wanna destroy tha handle too early \- how tha fuck do I wait until all data has been written?" 4
.IX Item "I don't wanna destroy tha handle too early - how tha fuck do I wait until all data has been written?"
Afta freestylin yo' last bitz of data, set tha \f(CW\*(C`on_drain\*(C'\fR callback
and destroy tha handle up in there \- wit tha default settin of
\&\f(CW\*(C`low_water_mark\*(C'\fR dis is ghon be called precisely when all data has been
written ta tha socket:
.Sp
.Vb 5
\&   $handle\->push_write (...);
\&   $handle\->on_drain (sub {
\&      AE::log debug => "All data submitted ta tha kernel.";
\&      undef $handle;
\&   });
.Ve
.Sp
If you just wanna queue some data n' then signal \s-1EOF\s0 ta tha other side,
consider rockin \f(CW\*(C`\->push_shutdown\*(C'\fR instead.
.IP "I wanna contact a \s-1TLS/SSL\s0 server, I couldn't give a fuckin shiznit bout security." 4
.IX Item "I wanna contact a TLS/SSL server, I couldn't give a fuckin shiznit bout security."
If yo' \s-1TLS\s0 server be a pure \s-1TLS\s0 server (e.g. \s-1HTTPS\s0) dat only speaks \s-1TLS,\s0
connect ta it n' then create tha AnyEvent::Handle wit tha \f(CW\*(C`tls\*(C'\fR
parameter:
.Sp
.Vb 2
\&   tcp_connect $host, $port, sub {
\&      mah ($fh) = @_;
\&
\&      mah $handle = freshly smoked up AnyEvent::Handle
\&         fh  => $fh,
\&         tls => "connect",
\&         on_error => sub { ... };
\&
\&      $handle\->push_write (...);
\&   };
.Ve
.IP "I wanna contact a \s-1TLS/SSL\s0 server, I do care bout security." 4
.IX Item "I wanna contact a TLS/SSL server, I do care bout security."
Then you should additionally enable certificate verification, including
peername verification, if tha protocol you use supports it (see
AnyEvent::TLS, \f(CW\*(C`verify_peername\*(C'\fR).
.Sp
E.g. fo' \s-1HTTPS:\s0
.Sp
.Vb 2
\&   tcp_connect $host, $port, sub {
\&      mah ($fh) = @_;
\&
\&       mah $handle = freshly smoked up AnyEvent::Handle
\&          fh       => $fh,
\&          peername => $host,
\&          tls      => "connect",
\&          tls_ctx  => { verify => 1, verify_peername => "https" },
\&          ...
.Ve
.Sp
Note dat you must specify tha hostname you connected ta (or whatever
\&\*(L"peername\*(R" tha protocol needs) as tha \f(CW\*(C`peername\*(C'\fR argument, otherwise no
peername verification is ghon be done.
.Sp
Da above will use tha system-dependent default set of trusted \s-1CA\s0
certificates. If you wanna check against a specific \s-1CA,\s0 add the
\&\f(CW\*(C`ca_file\*(C'\fR (or \f(CW\*(C`ca_cert\*(C'\fR) arguments ta \f(CW\*(C`tls_ctx\*(C'\fR:
.Sp
.Vb 5
\&       tls_ctx  => {
\&          verify          => 1,
\&          verify_peername => "https",
\&          ca_file         => "my\-ca\-cert.pem",
\&       },
.Ve
.IP "I wanna create a \s-1TLS/SSL\s0 server, how tha fuck do I do that?" 4
.IX Item "I wanna create a TLS/SSL server, how tha fuck do I do that?"
Well, you first need ta git a server certificate n' key. Yo ass have
three options: a) ask a \s-1CA \s0(buy one, use cacert.org etc.) b) create a
self-signed certificate (cheap. check tha search engine of yo' chizzle,
there is nuff tutorials on tha net) or c) make yo' own \s-1CA \s0(tinyca2 be a
nice program fo' dat purpose).
.Sp
Then create a gangbangin' file wit yo' private key (in \s-1PEM\s0 format, see
AnyEvent::TLS), followed by tha certificate (also up in \s-1PEM\s0 format). The
file should then be lookin like this:
.Sp
.Vb 4
\&   \-\-\-\-\-BEGIN RSA PRIVATE KEY\-\-\-\-\-
\&   ...header data
\&   ... fuckin shitloadz of base64\*(Aqy\-stuff
\&   \-\-\-\-\-END RSA PRIVATE KEY\-\-\-\-\-
\&
\&   \-\-\-\-\-BEGIN CERTIFICATE\-\-\-\-\-
\&   ... fuckin shitloadz of base64\*(Aqy\-stuff
\&   \-\-\-\-\-END CERTIFICATE\-\-\-\-\-
.Ve
.Sp
Da blingin bits is tha \*(L"\s-1PRIVATE KEY\*(R"\s0 n' \*(L"\s-1CERTIFICATE\*(R"\s0 parts, n' you can put dat on yo' toast.  Then
specify dis file as \f(CW\*(C`cert_file\*(C'\fR:
.Sp
.Vb 2
\&   tcp_server undef, $port, sub {
\&      mah ($fh) = @_;
\&
\&      mah $handle = freshly smoked up AnyEvent::Handle
\&         fh       => $fh,
\&         tls      => "accept",
\&         tls_ctx  => { cert_file => "my\-server\-keycert.pem" },
\&         ...
.Ve
.Sp
When you have intermediate \s-1CA\s0 certificates dat yo' clients might not
know about, just append dem ta tha \f(CW\*(C`cert_file\*(C'\fR.
.SH "SUBCLASSING AnyEvent::Handle"
.IX Header "SUBCLASSING AnyEvent::Handle"
In nuff cases, you might wanna subclass AnyEvent::Handle.
.PP
To make dis easier, a given version of AnyEvent::Handle uses these
conventions:
.IP "\(bu" 4
all constructor arguments become object members.
.Sp
At least initially, when you pass a \f(CW\*(C`tls\*(C'\fR\-argument ta tha constructor it
will end up in \f(CW\*(C`$handle\->{tls}\*(C'\fR. Those thugz might be chizzled or
mutated lata on (for example \f(CW\*(C`tls\*(C'\fR will hold tha \s-1TLS\s0 connection object).
.IP "\(bu" 4
other object member names is prefixed wit a \f(CW\*(C`_\*(C'\fR.
.Sp
All object thugz not explicitly documented (internal use) is prefixed
with a underscore character, so tha remainin non\-\f(CW\*(C`_\*(C'\fR\-namespace is free
for use fo' subclasses.
.IP "\(bu" 4
all thugz not documented here n' not prefixed wit a underscore
are free ta use up in subclasses.
.Sp
Of course, freshly smoked up versionz of AnyEvent::Handle may introduce mo' \*(L"public\*(R"
member variablez yo, but thatz just game fo' realz. At least it is documented.
.SH "AUTHOR"
.IX Header "AUTHOR"
Robin Redeker \f(CW\*(C`<elmex at ta\-sa.org>\*(C'\fR, Marc Lehmann <schmorp@schmorp.de>.
