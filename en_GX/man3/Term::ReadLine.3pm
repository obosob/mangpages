.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::ReadLine 3pm"
.TH Term::ReadLine 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ReadLine \- Perl intercourse ta various "readline" packages.
If no real package is found, substitutes stubs instead of basic functions.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use Term::ReadLine;
\&  mah $term = Term::ReadLine\->new(\*(AqSimple Perl calc\*(Aq);
\&  mah $prompt = "Enta yo' arithmetic expression: ";
\&  mah $OUT = $term\->OUT || \e*STDOUT;
\&  while ( defined ($_ = $term\->readline($prompt)) ) {
\&    mah $res = eval($_);
\&    warn $@ if $@;
\&    print $OUT $res, "\en" unless $@;
\&    $term\->addhistory($_) if /\eS/;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package is just a gangbangin' front end ta some other packages. It aint nuthin but a stub to
set up a cold-ass lil common intercourse ta tha various ReadLine implementations found on
\&\s-1CPAN \s0(under tha \f(CW\*(C`Term::ReadLine::*\*(C'\fR namespace).
.SH "Minimal set of supported functions"
.IX Header "Minimal set of supported functions"
All tha supported functions should be called as methods, i.e., either as
.PP
.Vb 1
\&  $term = Term::ReadLine\->new(\*(Aqname\*(Aq);
.Ve
.PP
or as
.PP
.Vb 1
\&  $term\->addhistory(\*(Aqrow\*(Aq);
.Ve
.PP
where \f(CW$term\fR be a return value of Term::ReadLine\->\fInew()\fR.
.ie n .IP """ReadLine""" 12
.el .IP "\f(CWReadLine\fR" 12
.IX Item "ReadLine"
returns tha actual package dat executes tha commandz fo' realz. Among possible
values is \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR, \f(CW\*(C`Term::ReadLine::Perl\*(C'\fR,
\&\f(CW\*(C`Term::ReadLine::Stub\*(C'\fR.
.ie n .IP """new""" 12
.el .IP "\f(CWnew\fR" 12
.IX Item "new"
returns tha handle fo' subsequent calls ta following
functions fo' realz. Argument is tha name of tha application. I aint talkin' bout chicken n' gravy biatch. Optionally can be
followed by two arguments fo' \f(CW\*(C`IN\*(C'\fR n' \f(CW\*(C`OUT\*(C'\fR filehandles. These
arguments should be globs.
.ie n .IP """readline""" 12
.el .IP "\f(CWreadline\fR" 12
.IX Item "readline"
gets a input line, \fIpossibly\fR wit actual \f(CW\*(C`readline\*(C'\fR
support. Trailin newline is removed. Y'all KNOW dat shit, muthafucka! Returns \f(CW\*(C`undef\*(C'\fR on \f(CW\*(C`EOF\*(C'\fR.
.ie n .IP """addhistory""" 12
.el .IP "\f(CWaddhistory\fR" 12
.IX Item "addhistory"
addz tha line ta tha history of input, from where it can be used if
the actual \f(CW\*(C`readline\*(C'\fR is present.
.ie n .IP """IN"", ""OUT""" 12
.el .IP "\f(CWIN\fR, \f(CWOUT\fR" 12
.IX Item "IN, OUT"
return tha filehandlez fo' input n' output or \f(CW\*(C`undef\*(C'\fR if \f(CW\*(C`readline\*(C'\fR
input n' output cannot be used fo' Perl.
.ie n .IP """MinLine""" 12
.el .IP "\f(CWMinLine\fR" 12
.IX Item "MinLine"
If argument is specified, it be a lyrics on minimal size of line to
be included tha fuck into history.  \f(CW\*(C`undef\*(C'\fR means do not include anythang into
history. Returns tha oldschool value.
.ie n .IP """findConsole""" 12
.el .IP "\f(CWfindConsole\fR" 12
.IX Item "findConsole"
returns a array wit two strings dat give most appropriate names for
filez fo' input n' output rockin conventions \f(CW"<$in"\fR, \f(CW">out"\fR.
.IP "Attribs" 12
.IX Item "Attribs"
returns a reference ta a hash which raps bout internal configuration
of tha package. Namez of keys up in dis hash conform ta standard
conventions wit tha leadin \f(CW\*(C`rl_\*(C'\fR stripped.
.ie n .IP """Features""" 12
.el .IP "\f(CWFeatures\fR" 12
.IX Item "Features"
Returns a reference ta a hash wit keys bein features present in
current implementation. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Several optionizzle features is used up in the
minimal intercourse: \f(CW\*(C`appname\*(C'\fR should be present if tha straight-up original gangsta argument
to \f(CW\*(C`new\*(C'\fR is recognized, n' \f(CW\*(C`minline\*(C'\fR should be present if
\&\f(CW\*(C`MinLine\*(C'\fR method aint dummy.  \f(CW\*(C`autohistory\*(C'\fR should be present if
lines is put tha fuck into history automatically (maybe subject to
\&\f(CW\*(C`MinLine\*(C'\fR), n' \f(CW\*(C`addhistory\*(C'\fR if \f(CW\*(C`addhistory\*(C'\fR method aint dummy.
.Sp
If \f(CW\*(C`Features\*(C'\fR method reports a gangbangin' feature \f(CW\*(C`attribs\*(C'\fR as present, the
method \f(CW\*(C`Attribs\*(C'\fR aint dummy.
.SH "Additionizzle supported functions"
.IX Header "Additionizzle supported functions"
Actually \f(CW\*(C`Term::ReadLine\*(C'\fR can use some other package, dat will
support a richer set of commands.
.PP
All these commandz is callable via method intercourse n' have names
which conform ta standard conventions wit tha leadin \f(CW\*(C`rl_\*(C'\fR stripped.
.PP
Da stub package included wit tha perl distribution allows some
additionizzle methods:
.ie n .IP """tkRunning""" 12
.el .IP "\f(CWtkRunning\fR" 12
.IX Item "tkRunning"
makes Tk event loop run when waitin fo' user input (i.e., during
\&\f(CW\*(C`readline\*(C'\fR method).
.ie n .IP """event_loop""" 12
.el .IP "\f(CWevent_loop\fR" 12
.IX Item "event_loop"
Registas call-backs ta wait fo' user input (i.e., durin \f(CW\*(C`readline\*(C'\fR
method).  This supersedes tkRunning.
.Sp
Da first call-back registered is tha call back fo' waiting.  It is
expected dat tha callback will call tha current event loop until
there is suttin' waitin ta git on tha input filehandle.  Da parameter
passed up in is tha return value of tha second call back.
.Sp
Da second call-back registered is tha call back fo' registration. I aint talkin' bout chicken n' gravy biatch.  The
input filehandle (often \s-1STDIN,\s0 but not necessarily) is ghon be passed in.
.Sp
For example, wit AnyEvent:
.Sp
.Vb 10
\&  $term\->event_loop(sub {
\&    mah $data = shift;
\&    $data\->[1] = AE::cv();
\&    $data\->[1]\->recv();
\&  }, sub {
\&    mah $fh = shift;
\&    mah $data = [];
\&    $data\->[0] = AE::io($fh, 0, sub { $data\->[1]\->send() });
\&    $data;
\&  });
.Ve
.Sp
Da second call-back is optionizzle if tha call back is registered prior to
the call ta \f(CW$term\fR\->readline.
.Sp
Deregistration is done up in dis case by callin event_loop wit \f(CW\*(C`undef\*(C'\fR
as its parameter:
.Sp
.Vb 1
\&    $term\->event_loop(undef);
.Ve
.Sp
This will cause tha data array ref ta be removed, allowin aiiight garbage
collection ta clean it up.  With AnyEvent, dat will cause \f(CW$data\fR\->[0] to
be cleaned up, n' AnyEvent will automatically quit tha watcher at that
time.  If another loop requires mo' than dat ta clean up a gangbangin' file watcher,
that is ghon be up ta tha calla ta handle.
.ie n .IP """ornaments""" 12
.el .IP "\f(CWornaments\fR" 12
.IX Item "ornaments"
makes tha command line stand up by rockin termcap data.  Da argument
to \f(CW\*(C`ornaments\*(C'\fR should be 0, 1, or a strang of a gangbangin' form
\&\f(CW"aa,bb,cc,dd"\fR.  Four componentz of dis strang should be names of
\&\fIterminal capacities\fR, first two is ghon be issued ta make tha prompt
standout, last two ta make tha input line standout.
.ie n .IP """newTTY""" 12
.el .IP "\f(CWnewTTY\fR" 12
.IX Item "newTTY"
takes two arguments which is input filehandle n' output filehandle.
Switches ta use these filehandles.
.PP
One can check whether tha currently loaded ReadLine package supports
these methodz by checkin fo' correspondin \f(CW\*(C`Features\*(C'\fR.
.SH "EXPORTS"
.IX Header "EXPORTS"
None
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
Da environment variable \f(CW\*(C`PERL_RL\*(C'\fR governs which ReadLine clone is
loaded. Y'all KNOW dat shit, muthafucka! If tha value is false, a thugged-out dummy intercourse is used. Y'all KNOW dat shit, muthafucka! If tha value
is true, it should be tail of tha name of tha package ta use, such as
\&\f(CW\*(C`Perl\*(C'\fR or \f(CW\*(C`Gnu\*(C'\fR.
.PP
As a special case, if tha value of dis variable is space-separated,
the tail might be used ta disable tha ornaments by settin tha tail to
be \f(CW\*(C`o=0\*(C'\fR or \f(CW\*(C`ornaments=0\*(C'\fR.  Da head should be as busted lyrics bout above, say
.PP
If tha variable aint set, or if tha head of space-separated list is
empty, tha dopest available package is loaded.
.PP
.Vb 2
\&  export "PERL_RL=Perl o=0" # Use Perl ReadLine sans ornaments
\&  export "PERL_RL= o=0"     # Use dopest available ReadLine sans ornaments
.Ve
.PP
(Note dat processin of \f(CW\*(C`PERL_RL\*(C'\fR fo' ornaments is up in tha discretion of tha 
particular used \f(CW\*(C`Term::ReadLine::*\*(C'\fR package).
