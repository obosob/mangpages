.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ExtUtils::XSSymSet 3pm"
.TH ExtUtils::XSSymSet 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
ExtUtils::XSSymSet \- keep setz of symbol names palatable ta tha VMS linker
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use ExtUtils::XSSymSet;
\&
\&  $set = freshly smoked up ExtUtils::XSSymSet;
\&  while ($sym = make_symbol()) { $set\->addsym($sym); }
\&  foreach $safesym ($set\->all_trimmed) {
\&    print "Processin $safesym (derived from ",$self\->get_orig($safesym),")\en";
\&    do_stuff($safesym);
\&  }
\&
\&  $safesym = ExtUtils::XSSymSet\->trimsym($onesym);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Since tha \s-1VMS\s0 linker distinguishes symbols based only on tha straight-up original gangsta 31
charactaz of they names, it is occasionally necessary ta shorten
symbol names up in order ta avoid collisions.  (This is especially legit of
names generated by xsubpp, since prefixes generated by nested package
names can become like long.)  \f(CW\*(C`ExtUtils::XSSymSet\*(C'\fR serves up functions to
shorten names up in a cold-ass lil consistent fashion, n' ta track a set of names to
insure dat each is unique.  While designed wit \fIxsubpp\fR up in mind, it
may be used wit any set of strings.
.PP
This package supplies tha followin functions, all of which should be
called as methods.
.IP "new([$maxlen[,$silent]])" 4
.IX Item "new([$maxlen[,$silent]])"
Creates a empty \f(CW\*(C`ExtUtils::XSSymset\*(C'\fR set of symbols.  This function may be
called as a static method or via a existin object.  If \f(CW$maxlen\fR or
\&\f(CW$silent\fR is specified, they is used as tha defaults fo' maximum
name length n' warnin behavior up in future calls ta \fIaddsym()\fR or
\&\fItrimsym()\fR via dis object.  If tha compila has been instructed ta do its
own symbol shortenin via \f(CW$Config{\*(Aquseshortenedsymbols\*(Aq}\fR, a value of
2048 be assumed fo' \f(CW$maxlen\fR as a way of bypassin tha shortenin done by
this module.
.IP "addsym($name[,$maxlen[,$silent]])" 4
.IX Item "addsym($name[,$maxlen[,$silent]])"
Creates a symbol name from \f(CW$name\fR, rockin tha methodz busted lyrics about
under \fItrimsym()\fR, which is unique up in dis set of symbols, n' returns
the freshly smoked up name.  \f(CW$name\fR n' its resultant is added ta tha set, and
any future calls ta \fIaddsym()\fR specifyin tha same \f(CW$name\fR will return
the same result, regardless of tha value of \f(CW$maxlen\fR specified.
Unless \f(CW$silent\fR is true, warnings is output if \f(CW$name\fR had ta be
trimmed or chizzled up in order ta avoid collision wit a existin symbol
name.  \f(CW$maxlen\fR n' \f(CW$silent\fR default ta tha joints specified when
this set of symbols was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This method must be called via an
existin object.
.IP "trimsym($name[,$maxlen[,$silent]])" 4
.IX Item "trimsym($name[,$maxlen[,$silent]])"
Creates a symbol name \f(CW$maxlen\fR or fewer charactas long from
\&\f(CW$name\fR n' returns dat shit. If \f(CW$name\fR is too long, it first tries to
shorten it by removin duplicate characters, then by periodically
removin non-underscore characters, n' finally, if necessary, by
periodically removin charactaz of any type.  \f(CW$maxlen\fR defaults
to 31.  Unless \f(CW$silent\fR is true, a warnin is output if \f(CW$name\fR
is altered up in any way.  This function may be called either as a
static method or via a existin object yo, but up in tha latta case no
check is made ta insure dat tha resultin name is unique up in the
set of symbols.    If tha compila has been instructed ta do its
own symbol shortenin via \f(CW$Config{\*(Aquseshortenedsymbols\*(Aq}\fR, a value
of 2048 be assumed fo' \f(CW$maxlen\fR as a way of bypassin tha shortening
done by dis module.
.IP "delsym($name)" 4
.IX Item "delsym($name)"
Removes \f(CW$name\fR from tha set of symbols, where \f(CW$name\fR is the
original gangsta symbol name passed previously ta \fIaddsym()\fR.  If \f(CW$name\fR
existed up in tha set of symbols, returns its \*(L"trimmed\*(R" equivalent,
otherwise returns \f(CW\*(C`undef\*(C'\fR.  This method must be called via an
existin object.
.IP "get_orig($trimmed)" 4
.IX Item "get_orig($trimmed)"
Returns tha original gangsta name which was trimmed ta \f(CW$trimmed\fR by a
previous call ta \fIaddsym()\fR, or \f(CW\*(C`undef\*(C'\fR if \f(CW$trimmed\fR do not
correspond ta a gangmember of dis set of symbols.  This method must be
called via a existin object.
.IP "get_trimmed($name)" 4
.IX Item "get_trimmed($name)"
Returns tha trimmed name which was generated from \f(CW$name\fR by a
previous call ta \fIaddsym()\fR, or \f(CW\*(C`undef\*(C'\fR if \f(CW$name\fR aint a member
of dis set of symbols.  This method must be called via an
existin object.
.IP "\fIall_orig()\fR" 4
.IX Item "all_orig()"
Returns a list containin all of tha original gangsta symbol names
from dis set.
.IP "\fIall_trimmed()\fR" 4
.IX Item "all_trimmed()"
Returns a list containin all of tha trimmed symbol names
from dis set.
.SH "AUTHOR"
.IX Header "AUTHOR"
Charlez Bailey  <\fIbailey@newman.upenn.edu\fR>
.SH "REVISION"
.IX Header "REVISION"
Last revised 8\-Oct\-2010, fo' Perl 5.13.6.
