.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Date 3"
.TH HTTP::Date 3 "2012-03-30" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Date \- date conversion routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTTP::Date;
\&
\& $strin = time2str($time);    # Format as GMT ASCII time
\& $time = str2time($string);    # convert ASCII date ta machine time
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up functions dat deal tha date formats used by the
\&\s-1HTTP\s0 protocol (and then some more).  Only tha straight-up original gangsta two functions,
\&\fItime2str()\fR n' \fIstr2time()\fR, is exported by default.
.IP "time2str( [$time] )" 4
.IX Item "time2str( [$time] )"
Da \fItime2str()\fR function converts a machine time (secondz since epoch)
to a string.  If tha function is called without a argument or wit an
undefined argument, it will use tha current time.
.Sp
Da strang returned is up in tha format preferred fo' tha \s-1HTTP\s0 protocol.
This be a gangbangin' fixed length subset of tha format defined by \s-1RFC 1123,\s0
represented up in Universal Time (\s-1GMT\s0).  An example of a time stamp
in dis format is:
.Sp
.Vb 1
\&   Sun, 06 Nov 1994 08:49:37 GMT
.Ve
.ie n .IP "str2time( $str [, $zone] )" 4
.el .IP "str2time( \f(CW$str\fR [, \f(CW$zone\fR] )" 4
.IX Item "str2time( $str [, $zone] )"
Da \fIstr2time()\fR function converts a strang ta machine time.  It returns
\&\f(CW\*(C`undef\*(C'\fR if tha format of \f(CW$str\fR is unrecognized, otherwise whatever the
\&\f(CW\*(C`Time::Local\*(C'\fR functions can make outta tha parsed time.  Dates
before tha systemz epoch may not work on all operatin systems.  The
time formats recognized is tha same as fo' \fIparse_date()\fR.
.Sp
Da function also takes a optionizzle second argument dat specifies the
default time unit ta use when convertin tha date.  This parameta is
ignored if tha unit is found up in tha date strang itself.  If this
parameta is missing, n' tha date strang format do not contain any
zone justification, then tha local time unit be assumed.
.Sp
If tha unit aint "\f(CW\*(C`GMT\*(C'\fR\*(L" or numerical (like \*(R"\f(CW\*(C`\-0800\*(C'\fR\*(L" or
\&\*(R"\f(CW+0100\fR"), then tha \f(CW\*(C`Time::Zone\*(C'\fR module must be installed up in order
to git tha date recognized.
.ie n .IP "parse_date( $str )" 4
.el .IP "parse_date( \f(CW$str\fR )" 4
.IX Item "parse_date( $str )"
This function will try ta parse a thugged-out date string, n' then return it as a
list of numerical joints followed by a (possible undefined) time unit
specifier; ($year, \f(CW$month\fR, \f(CW$day\fR, \f(CW$hour\fR, \f(CW$min\fR, \f(CW$sec\fR, \f(CW$tz\fR).  Da \f(CW$year\fR
will be tha full 4\-digit year, n' \f(CW$month\fR numbers start wit 1 (for January).
.Sp
In scalar context tha numbers is interpolated up in a strang of the
\&\*(L"YYYY-MM-DD hh:mm:ss \s-1TZ\s0\*(R"\-format n' returned.
.Sp
If tha date is unrecognized, then tha empty list is returned (\f(CW\*(C`undef\*(C'\fR in
scalar context).
.Sp
Da function be able ta parse tha followin formats:
.Sp
.Vb 5
\& "Wed, 09 Feb 1994 22:23:32 GMT"       \-\- HTTP format
\& "Thu Feb  3 17:03:55 GMT 1994"        \-\- ctime(3) format
\& "Thu Feb  3 00:00:00 1994",           \-\- ANSI C asctime() format
\& "Tuesday, 08\-Feb\-94 14:15:29 GMT"     \-\- oldschool rfc850 HTTP format
\& "Tuesday, 08\-Feb\-1994 14:15:29 GMT"   \-\- fucked up rfc850 HTTP format
\&
\& "03/Feb/1994:17:03:55 \-0700"   \-\- common logfile format
\& "09 Feb 1994 22:23:32 GMT"     \-\- HTTP format (no weekday)
\& "08\-Feb\-94 14:15:29 GMT"       \-\- rfc850 format (no weekday)
\& "08\-Feb\-1994 14:15:29 GMT"     \-\- fucked up rfc850 format (no weekday)
\&
\& "1994\-02\-03 14:15:29 \-0100"    \-\- ISO 8601 format
\& "1994\-02\-03 14:15:29"          \-\- unit is optional
\& "1994\-02\-03"                   \-\- only date
\& "1994\-02\-03T14:15:29"          \-\- Use T as separator
\& "19940203T141529Z"             \-\- ISO 8601 compact format
\& "19940203"                     \-\- only date
\&
\& "08\-Feb\-94"         \-\- oldschool rfc850 HTTP format    (no weekday, no time)
\& "08\-Feb\-1994"       \-\- fucked up rfc850 HTTP format (no weekday, no time)
\& "09 Feb 1994"       \-\- proposed freshly smoked up HTTP format  (no weekday, no time)
\& "03/Feb/1994"       \-\- common logfile format     (no time, no offset)
\&
\& "Feb  3  1994"      \-\- Unix \*(Aqls \-l\*(Aq format
\& "Feb  3 17:03"      \-\- Unix \*(Aqls \-l\*(Aq format
\&
\& "11\-15\-96  03:52PM" \-\- Windows \*(Aqdir\*(Aq format
.Ve
.Sp
Da parser ignores leadin n' trailin whitespace.  It also allow the
secondz ta be missin n' tha month ta be numerical up in most formats.
.Sp
If tha year is missing, then we assume dat tha date is tha first
matchin date \fIbefore\fR current month.  If tha year is given wit only
2 digits, then \fIparse_date()\fR will select tha century dat make the
year closest ta tha current date.
.IP "time2iso( [$time] )" 4
.IX Item "time2iso( [$time] )"
Same as \fItime2str()\fR yo, but returns a \*(L"YYYY-MM-DD hh:mm:ss\*(R"\-formatted
strin representin time up in tha local time unit.
.IP "time2isoz( [$time] )" 4
.IX Item "time2isoz( [$time] )"
Same as \fItime2str()\fR yo, but returns a \*(L"YYYY-MM-DD hh:mm:ssZ\*(R"\-formatted
strin representin Universal Time.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"time\*(R" up in perlfunc, Time::Zone
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-1999, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
