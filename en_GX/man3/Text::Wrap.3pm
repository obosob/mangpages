.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Wrap 3pm"
.TH Text::Wrap 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Wrap \- line wrappin ta form simple paragraphs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBExample 1\fR
.PP
.Vb 1
\&        use Text::Wrap;
\&
\&        $initial_tab = "\et";    # Tab before first line
\&        $subsequent_tab = "";   # All other lines flush left
\&
\&        print wrap($initial_tab, $subsequent_tab, @text);
\&        print fill($initial_tab, $subsequent_tab, @text);
\&
\&        $lines = wrap($initial_tab, $subsequent_tab, @text);
\&
\&        @paragraphs = fill($initial_tab, $subsequent_tab, @text);
.Ve
.PP
\&\fBExample 2\fR
.PP
.Vb 1
\&        use Text::Wrap qw(wrap $columns $huge);
\&
\&        $columns = 132;         # Wrap at 132 characters
\&        $huge = \*(Aqdie\*(Aq;
\&        $huge = \*(Aqwrap\*(Aq;
\&        $huge = \*(Aqoverflow\*(Aq;
.Ve
.PP
\&\fBExample 3\fR
.PP
.Vb 1
\&        use Text::Wrap;
\&
\&        $Text::Wrap::columns = 72;
\&        print wrap(\*(Aq\*(Aq, \*(Aq\*(Aq, @text);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Text::Wrap::wrap()\*(C'\fR be a straight-up simple paragraph formatter n' shit.  It formats a
single paragraph at a time by breakin lines at word boundaries.
Indentation is controlled fo' tha straight-up original gangsta line (\f(CW$initial_tab\fR) and
all subsequent lines (\f(CW$subsequent_tab\fR) independently.  Please note: 
\&\f(CW$initial_tab\fR n' \f(CW$subsequent_tab\fR is tha literal strings dat will
be used: it is unlikely you would wanna pass up in a number.
.PP
\&\f(CW\*(C`Text::Wrap::fill()\*(C'\fR be a simple multi-paragraph formatter n' shit.  It formats
each paragraph separately n' then joins dem together when itz done.  It
will destroy any whitespace up in tha original gangsta text.  It breaks text into
paragraphs by lookin fo' whitespace afta a newline.  In other respects,
it acts like \fIwrap()\fR.
.PP
\&\f(CW\*(C`wrap()\*(C'\fR compresses trailin whitespace tha fuck into one newline, n' \f(CW\*(C`fill()\*(C'\fR
deletes all trailin whitespace.
.PP
Both \f(CW\*(C`wrap()\*(C'\fR n' \f(CW\*(C`fill()\*(C'\fR return a single string.
.PP
Unlike tha oldschool Unix \fIfmt\fR\|(1) utility, dis module erectly accounts for
any Unicode combinin charactas (like fuckin diacriticals) dat may occur
in each line fo' both expansion n' unexpansion. I aint talkin' bout chicken n' gravy biatch.  These is overstrike
charactas dat do not increment tha logical position. I aint talkin' bout chicken n' gravy biatch.  Make sure
you have tha appropriate Unicode settings enabled.
.SH "OVERRIDES"
.IX Header "OVERRIDES"
\&\f(CW\*(C`Text::Wrap::wrap()\*(C'\fR has a fuckin shitload of variablez dat control its behavior.
Because other modulez might be rockin \f(CW\*(C`Text::Wrap::wrap()\*(C'\fR it is suggested
that you leave these variablez alone biaaatch!  If you can't do that, then 
use \f(CW\*(C`local($Text::Wrap::VARIABLE) = YOURVALUE\*(C'\fR when you chizzle the
values so dat tha original gangsta value is restored. Y'all KNOW dat shit, muthafucka!  This \f(CW\*(C`local()\*(C'\fR trick
will not work if you import tha variable tha fuck into yo' own namespace.
.PP
Lines is wrapped at \f(CW$Text::Wrap::columns\fR columns (default value: 76).
\&\f(CW$Text::Wrap::columns\fR should be set ta tha full width of yo' output
device.  In fact, every last muthafuckin resultin line gonna git length of no mo' than
\&\f(CW\*(C`$columns \- 1\*(C'\fR.
.PP
It be possible ta control which charactas terminizzle lyrics by
modifyin \f(CW$Text::Wrap::break\fR. Right back up in yo muthafuckin ass. Set dis ta a strang such as
\&\f(CW\*(Aq[\es:]\*(Aq\fR (to break before spaces or colons) or a pre-compiled regexp
like fuckin \f(CW\*(C`qr/[\es\*(Aq]/\*(C'\fR (to break before spaces or apostrophes). The
default is simply \f(CW\*(Aq\es\*(Aq\fR; dat is, lyrics is terminated by spaces.
(This means, among other thangs, dat trailin punctuation  such as
full stops or commas stay wit tha word they is \*(L"attached\*(R" to.)
Settin \f(CW$Text::Wrap::break\fR ta a regular expression dat don't
eat any charactas (like just a gangbangin' forward look-ahead assertion) will
cause warnings.
.PP
Beginner note: In example 2, above \f(CW$columns\fR is imported into
the local namespace, n' set locally.  In example 3,
\&\f(CW$Text::Wrap::columns\fR is set up in its own namespace without importin dat shit.
.PP
\&\f(CW\*(C`Text::Wrap::wrap()\*(C'\fR starts its work by expandin all tha tabs up in its
input tha fuck into spaces.  Da last thang it do it ta turn spaces back
into tabs.  If you do not want tabs up in yo' thangs up in dis biatch, set 
\&\f(CW$Text::Wrap::unexpand\fR ta a gangbangin' false value.  Likewise if you do not
wanna use 8\-characta tabstops, set \f(CW$Text::Wrap::tabstop\fR to
the number of charactas you do want fo' yo' tabstops.
.PP
If you wanna separate yo' lines wit suttin' other than \f(CW\*(C`\en\*(C'\fR
then set \f(CW$Text::Wrap::separator\fR ta yo' preference.  This replaces
all newlines wit \f(CW$Text::Wrap::separator\fR.  If you just wanna 
preserve existin newlines but add freshly smoked up breaks wit suttin' else, set
\&\f(CW$Text::Wrap::separator2\fR instead.
.PP
When lyrics dat is longer than \f(CW$columns\fR is encountered, they
are fucked up up.  \f(CW\*(C`wrap()\*(C'\fR addz a \f(CW"\en"\fR at column \f(CW$columns\fR.
This behavior can be overridden by settin \f(CW$huge\fR to
\&'die' or ta 'overflow'.  When set ta 'die', big-ass lyrics will cause
\&\f(CW\*(C`die()\*(C'\fR ta be called. Y'all KNOW dat shit, muthafucka!  When set ta 'overflow', big-ass lyrics will be
left intact.
.PP
Oldschool notes: 'die' used ta be tha default value of
\&\f(CW$huge\fR.  Now, 'wrap' is tha default value.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Code:
.PP
.Vb 4
\&  print wrap("\et","",<<END);
\&  This be a lil' bit of text dat forms 
\&  a aiiight book\-style indented paragraph
\&  END
.Ve
.PP
Result:
.PP
.Vb 3
\&  "     This be a lil' bit of text dat forms
\&  a aiiight book\-style indented paragraph   
\&  "
.Ve
.PP
Code:
.PP
.Vb 3
\&  $Text::Wrap::columns=20;
\&  $Text::Wrap::separator="|";
\&  print wrap("","","This be a lil' bit of text dat forms a aiiight book\-style paragraph");
.Ve
.PP
Result:
.PP
.Vb 1
\&  "This be a lil' bit of|text dat forms a|normal book\-style|paragraph"
.Ve
.SH "SUBVERSION"
.IX Header "SUBVERSION"
This module comes up in two flavors: one fo' modern perls (5.10 n' above)
and one fo' ancient obsolete perls.  Da version fo' modern perls has
support fo' Unicode.  Da version fo' oldschool perls do not.  Yo ass can tell
which version you have installed by lookin at \f(CW$Text::Wrap::SUBVERSION\fR:
it is \f(CW\*(C`old\*(C'\fR fo' obsolete perls n' \f(CW\*(C`modern\*(C'\fR fo' current perls.
.PP
This playa page is fo' tha version fo' modern perls n' so thatz probably
what you've got.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For erect handlin of Eastside Asian half\- n' full-width characters, 
see Text::WrapI18N.  For mo' detailed controls: Text::Format.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dizzy Muir Sharnoff <cpan@dave.sharnoff.org> wit help from Slim Tim Pierce and
many nuff others.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 1996\-2009 Dizzy Muir Sharnoff.  
Copyright (C) 2012 Google, Inc.
This module may be modified, used, copied, n' redistributed at yo' own risk.
Publicly redistributed modified versions must bust a gangbangin' finger-lickin' different name.
