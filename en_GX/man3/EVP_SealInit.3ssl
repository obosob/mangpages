.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "EVP_SealInit 3"
.TH EVP_SealInit 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
EVP_SealInit, EVP_SealUpdate, EVP_SealFinal \- EVP envelope encryption
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/evp.h>
\&
\& int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&                  unsigned char **ek, int *ekl, unsigned char *iv,
\&                  EVP_PKEY **pubk, int npubk);
\& int EVP_SealUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&         int *outl, unsigned char *in, int inl);
\& int EVP_SealFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&         int *outl);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \s-1EVP\s0 envelope routines is a high level intercourse ta envelope
encryption. I aint talkin' bout chicken n' gravy biatch. They generate a random key n' \s-1IV \s0(if required) then
\&\*(L"envelope\*(R" it by rockin hood key encryption. I aint talkin' bout chicken n' gravy biatch. Data can then be
encrypted rockin dis key.
.PP
\&\fIEVP_SealInit()\fR initializes a cold-ass lil cipher context \fBctx\fR fo' encryption
with cipher \fBtype\fR rockin a random secret key n' \s-1IV. \s0\fBtype\fR is normally
supplied by a gangbangin' function like fuckin \fIEVP_des_cbc()\fR. Da secret key is encrypted
usin one or mo' hood keys, dis allows tha same ol' dirty encrypted data ta be
decrypted rockin any of tha correspondin private keys. \fBek\fR be a array of
buffers where tha hood key encrypted secret key is ghon be written, each buffer
must contain enough room fo' tha correspondin encrypted key: dat is
\&\fBek[i]\fR must have room fo' \fBEVP_PKEY_size(pubk[i])\fR bytes. Da actual
size of each encrypted secret key is freestyled ta tha array \fBekl\fR. \fBpubk\fR is
an array of \fBnpubk\fR hood keys.
.PP
Da \fBiv\fR parameta be a funky-ass buffer where tha generated \s-1IV\s0 is freestyled to. Well shiiiit, it must
contain enough room fo' tha correspondin cipherz \s-1IV,\s0 as determined by (for
example) EVP_CIPHER_iv_length(type).
.PP
If tha cipher do not require a \s-1IV\s0 then tha \fBiv\fR parameta is ignored
and can be \fB\s-1NULL\s0\fR.
.PP
\&\fIEVP_SealUpdate()\fR n' \fIEVP_SealFinal()\fR have exactly tha same properties
as tha \fIEVP_EncryptUpdate()\fR n' \fIEVP_EncryptFinal()\fR routines, as 
documented on tha \fIEVP_EncryptInit\fR\|(3) manual
page.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIEVP_SealInit()\fR returns 0 on error or \fBnpubk\fR if successful.
.PP
\&\fIEVP_SealUpdate()\fR n' \fIEVP_SealFinal()\fR return 1 fo' success n' 0 for
failure.
.SH "NOTES"
.IX Header "NOTES"
Because a random secret key is generated tha random number generator
must be seeded before callin \fIEVP_SealInit()\fR.
.PP
Da hood key must be \s-1RSA\s0 cuz it is tha only OpenSSL hood key
algorithm dat supports key transport.
.PP
Envelope encryption is tha usual method of rockin hood key encryption
on big-ass amountz of data, dis is cuz hood key encryption is slow
but symmetric encryption is fast. Right back up in yo muthafuckin ass. So symmetric encryption is used for
bulk encryption n' tha lil' small-ass random symmetric key used is transferred
usin hood key encryption.
.PP
It be possible ta booty-call \fIEVP_SealInit()\fR twice up in tha same way as
\&\fIEVP_EncryptInit()\fR. Da first call should have \fBnpubk\fR set ta 0
and (afta settin any cipher parameters) it should be called again
with \fBtype\fR set ta \s-1NULL.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIevp\fR\|(3), \fIrand\fR\|(3),
\&\fIEVP_EncryptInit\fR\|(3),
\&\fIEVP_OpenInit\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIEVP_SealFinal()\fR did not return a value before OpenSSL 0.9.7.
