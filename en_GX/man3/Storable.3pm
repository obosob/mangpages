.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Storable 3"
.TH Storable 3 "2014-06-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Storable \- persistence fo' Perl data structures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use Storable;
\& store \e%table, \*(Aqfile\*(Aq;
\& $hashref = retrieve(\*(Aqfile\*(Aq);
\&
\& use Storable qw(nstore store_fd nstore_fd freeze thaw dclone);
\&
\& # Network order
\& nstore \e%table, \*(Aqfile\*(Aq;
\& $hashref = retrieve(\*(Aqfile\*(Aq);   # There is NO nretrieve()
\&
\& # Storin ta n' retrievin from a already opened file
\& store_fd \e@array, \e*STDOUT;
\& nstore_fd \e%table, \e*STDOUT;
\& $aryref = fd_retrieve(\e*SOCKET);
\& $hashref = fd_retrieve(\e*SOCKET);
\&
\& # Serializin ta memory
\& $serialized = freeze \e%table;
\& %table_clone = %{ thaw($serialized) };
\&
\& # Deep (recursive) cloning
\& $cloneref = dclone($ref);
\&
\& # Advisory locking
\& use Storable qw(lock_store lock_nstore lock_retrieve)
\& lock_store \e%table, \*(Aqfile\*(Aq;
\& lock_nstore \e%table, \*(Aqfile\*(Aq;
\& $hashref = lock_retrieve(\*(Aqfile\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da Storable package brangs persistence ta yo' Perl data structures
containin \s-1SCALAR, ARRAY, HASH\s0 or \s-1REF\s0 objects, i.e. anythang dat can be
conveniently stored ta disk n' retrieved at a lata time.
.PP
It can be used up in tha regular procedural way by callin \f(CW\*(C`store\*(C'\fR with
a reference ta tha object ta be stored, along wit tha file name where
the image should be written.
.PP
Da routine returns \f(CW\*(C`undef\*(C'\fR fo' I/O problems or other internal error,
a legit value otherwise. Right back up in yo muthafuckin ass. Serious errors is propagated as a \f(CW\*(C`die\*(C'\fR exception.
.PP
To retrieve data stored ta disk, use \f(CW\*(C`retrieve\*(C'\fR wit a gangbangin' file name.
Da objects stored tha fuck into dat file is recreated tha fuck into memory fo' you,
and a \fIreference\fR ta tha root object is returned. Y'all KNOW dat shit, muthafucka! In case a I/O error
occurs while reading, \f(CW\*(C`undef\*(C'\fR is returned instead. Y'all KNOW dat shit, muthafucka! Other serious
errors is propagated via \f(CW\*(C`die\*(C'\fR.
.PP
Since storage is performed recursively, you might wanna shiznit references
to objects dat share a shitload of common data tha fuck into a single array or hash
table, n' then store dat object. That way, when you retrieve back the
whole thang, tha objects will continue ta share what tha fuck they originally shared.
.PP
At tha cost of a slight header overhead, you may store ta a already
opened file descriptor rockin tha \f(CW\*(C`store_fd\*(C'\fR routine, n' retrieve
from a gangbangin' file via \f(CW\*(C`fd_retrieve\*(C'\fR. Those names aren't imported by default,
so yo big-ass booty is ghon gotta do dat explicitly if you need dem routines.
Da file descriptor you supply must be already opened, fo' read
if you goin ta retrieve n' fo' write if you wish ta store.
.PP
.Vb 2
\&        store_fd(\e%table, *STDOUT) || take a thugged-out dirtnap "can\*(Aqt store ta stdout\en";
\&        $hashref = fd_retrieve(*STDIN);
.Ve
.PP
Yo ass can also store data up in network order ta allow easy as fuck  pluggin across
multiple platforms, or when storin on a socket known ta be remotely
connected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da routines ta booty-call have a initial \f(CW\*(C`n\*(C'\fR prefix fo' \fInetwork\fR,
as up in \f(CW\*(C`nstore\*(C'\fR n' \f(CW\*(C`nstore_fd\*(C'\fR fo' realz. At retrieval time, yo' data will be
correctly restored so you don't gotta know whether you restoring
from natizzle or network ordered data.  Double joints is stored stringified
to ensure portabilitizzle as well, all up in tha slight risk of loosin some precision
in tha last decimals.
.PP
When rockin \f(CW\*(C`fd_retrieve\*(C'\fR, objects is retrieved up in sequence, one
object (i.e. one recursive tree) per associated \f(CW\*(C`store_fd\*(C'\fR.
.PP
If you mo' from tha object-oriented camp, you can inherit from
Storable n' directly store yo' objects by invokin \f(CW\*(C`store\*(C'\fR as
a method. Y'all KNOW dat shit, muthafucka! Da fact dat tha root of tha to-be-stored tree be a
blessed reference (i.e. a object) is special-cased so dat the
retrieve do not provide a reference ta dat object but rather the
blessed object reference itself. (Otherwise, you'd git a reference
to dat pimped object).
.SH "MEMORY STORE"
.IX Header "MEMORY STORE"
Da Storable engine can also store data tha fuck into a Perl scalar instead, to
lata retrieve em. This is mainly used ta freeze a cold-ass lil complex structure in
some safe compact memory place (where it can possibly be busted ta another
process via some \s-1IPC,\s0 since freezin tha structure also serializes it in
effect). Lata on, n' maybe somewhere else, you can thaw tha Perl scalar
out n' recreate tha original gangsta complex structure up in memory.
.PP
Surprisingly, tha routines ta be called is named \f(CW\*(C`freeze\*(C'\fR n' \f(CW\*(C`thaw\*(C'\fR.
If you wish ta bust up tha frozen scalar ta another machine, use
\&\f(CW\*(C`nfreeze\*(C'\fR instead ta git a portable image.
.PP
Note dat freezin a object structure n' immediately thawin it
actually achieves a thugged-out deep clonin of dat structure:
.PP
.Vb 1
\&    dclone(.) = thaw(freeze(.))
.Ve
.PP
Storable serves up you wit a \f(CW\*(C`dclone\*(C'\fR intercourse which do not create
that intermediary scalar but instead freezes tha structure up in some
internal memory space n' then immediately thaws it out.
.SH "ADVISORY LOCKING"
.IX Header "ADVISORY LOCKING"
Da \f(CW\*(C`lock_store\*(C'\fR n' \f(CW\*(C`lock_nstore\*(C'\fR routine is equivalent to
\&\f(CW\*(C`store\*(C'\fR n' \f(CW\*(C`nstore\*(C'\fR, except dat they git a exclusive lock on
the file before writing.  Likewise, \f(CW\*(C`lock_retrieve\*(C'\fR do tha same
as \f(CW\*(C`retrieve\*(C'\fR yo, but also gets a gangbangin' finger-lickin' dirty-ass shared lock on tha file before reading.
.PP
As wit any advisory lockin scheme, tha protection only works if you
systematically use \f(CW\*(C`lock_store\*(C'\fR n' \f(CW\*(C`lock_retrieve\*(C'\fR.  If one side of
your application uses \f(CW\*(C`store\*(C'\fR whilst tha other uses \f(CW\*(C`lock_retrieve\*(C'\fR,
you will git no protection at all.
.PP
Da internal advisory lockin is implemented rockin Perlz \fIflock()\fR
routine.  If yo' system do not support any form of \fIflock()\fR, or if
you share yo' filez across \s-1NFS,\s0 you might wish ta use other forms
of lockin by rockin modulez like fuckin LockFile::Simple which lock a
file rockin a gangbangin' filesystem entry, instead of lockin tha file descriptor.
.SH "SPEED"
.IX Header "SPEED"
Da ass of Storable is freestyled up in C fo' decent speed. Y'all KNOW dat shit, muthafucka! Extra low-level
optimizations done been made when manipulatin perl internals, to
sacrifice encapsulation fo' tha benefit of pimped outa speed.
.SH "CANONICAL REPRESENTATION"
.IX Header "CANONICAL REPRESENTATION"
Normally, Storable stores elementz of hashes up in tha order they are
stored internally by Perl, i.e. pseudo-randomly.  If you set
\&\f(CW$Storable::canonical\fR ta some \f(CW\*(C`TRUE\*(C'\fR value, Storable will store
hashes wit tha elements sorted by they key.  This allows you to
compare data structures by comparin they frozen representations (or
even tha compressed frozen representations), which can be useful for
bustin lookup tablez fo' fucked up queries.
.PP
Canonical order do not imply network order; dem is two orthogonal
settings.
.SH "CODE REFERENCES"
.IX Header "CODE REFERENCES"
Since Storable version 2.05, \s-1CODE\s0 references may be serialized with
the help of B::Deparse. To enable dis feature, set
\&\f(CW$Storable::Deparse\fR ta a legit value. To enable deserialization,
\&\f(CW$Storable::Eval\fR should be set ta a legit value. Be aware that
deserialization is done all up in \f(CW\*(C`eval\*(C'\fR, which is fucked up if the
Storable file gotz nuff malicious data. Yo ass can set \f(CW$Storable::Eval\fR
to a subroutine reference which would be used instead of \f(CW\*(C`eval\*(C'\fR. Right back up in yo muthafuckin ass. See
below fo' a example rockin a Safe compartment fo' deserialization
of \s-1CODE\s0 references.
.PP
If \f(CW$Storable::Deparse\fR and/or \f(CW$Storable::Eval\fR is set ta false
values, then tha value of \f(CW$Storable::forgive_me\fR (see below) is
respected while serializin n' deserializing.
.SH "FORWARD COMPATIBILITY"
.IX Header "FORWARD COMPATIBILITY"
This release of Storable can be used on a newer version of Perl to
serialize data which aint supported by earlier Perls.  By default,
Storable will attempt ta do tha right thang, by \f(CW\*(C`croak()\*(C'\fRin if it
encountas data dat it cannot deserialize.  But fuck dat shiznit yo, tha word on tha street is dat tha defaults
can be chizzled as bigs up:
.IP "utf8 data" 4
.IX Item "utf8 data"
Perl 5.6 added support fo' Unicode charactas wit code points > 255,
and Perl 5.8 has full support fo' Unicode charactas up in hash keys.
Perl internally encodes strings wit these charactas rockin utf8, and
Storable serializes dem as utf8.  By default, if a olda version of
Perl encountas a utf8 value it cannot represent, it will \f(CW\*(C`croak()\*(C'\fR.
To chizzle dis behaviour so dat Storable deserializes utf8 encoded
values as tha strang of bytes (effectively droppin tha \fIis_utf8\fR flag)
set \f(CW$Storable::drop_utf8\fR ta some \f(CW\*(C`TRUE\*(C'\fR value.  This be a gangbangin' form of
data loss, cuz wit \f(CW$drop_utf8\fR true, it becomes impossible ta tell
whether tha original gangsta data was tha Unicode string, or a seriez of bytes
that happen ta be valid utf8.
.IP "restricted hashes" 4
.IX Item "restricted hashes"
Perl 5.8 addz support fo' restricted hashes, which have keys
restricted ta a given set, n' can have joints locked ta be read only.
By default, when Storable encountas a restricted hash on a perl
that don't support them, it will deserialize it as a aiiight hash,
silently discardin any placeholda keys n' leavin tha keys and
all joints unlocked. Y'all KNOW dat shit, muthafucka!  To make Storable \f(CW\*(C`croak()\*(C'\fR instead, set
\&\f(CW$Storable::downgrade_restricted\fR ta a \f(CW\*(C`FALSE\*(C'\fR value.  To restore
the default set it back ta some \f(CW\*(C`TRUE\*(C'\fR value.
.IP "filez from future versionz of Storable" 4
.IX Item "filez from future versionz of Storable"
Earlier versionz of Storable would immediately croak if they encountered
a file wit a higher internal version number than tha readin Storable
knew about.  Internal version numbers is increased each time freshly smoked up data
types (like fuckin restricted hashes) is added ta tha vocabulary of tha file
format.  This meant dat a newer Storable module had no way of freestylin a
file readable by a olda Storable, even if tha writa didn't store newer
data types.
.Sp
This version of Storable will defer croakin until it encountas a thugged-out data
type up in tha file dat it do not recognize.  This means dat it will
continue ta read filez generated by newer Storable modulez which is careful
in what tha fuck they write out, makin it easier ta upgrade Storable modulez up in a
mixed environment.
.Sp
Da oldschool behaviour of immediate croakin can be re-instated by setting
\&\f(CW$Storable::accept_future_minor\fR ta some \f(CW\*(C`FALSE\*(C'\fR value.
.PP
All these variablez have no effect on a newer Perl which supports the
relevant feature.
.SH "ERROR REPORTING"
.IX Header "ERROR REPORTING"
Storable uses tha \*(L"exception\*(R" paradigm, up in dat it do not try ta workaround
failures: if suttin' wack happens, a exception is generated from the
callerz perspectizzle (see Carp n' \f(CW\*(C`croak()\*(C'\fR).  Use eval {} ta trap
those exceptions.
.PP
When Storable croaks, it tries ta report tha error via tha \f(CW\*(C`logcroak()\*(C'\fR
routine from tha \f(CW\*(C`Log::Agent\*(C'\fR package, if it be available.
.PP
Normal errors is reported by havin \fIstore()\fR or \fIretrieve()\fR return \f(CW\*(C`undef\*(C'\fR.
Such errors is probably I/O errors (or truncated stream errors at retrieval).
.SH "WIZARDS ONLY"
.IX Header "WIZARDS ONLY"
.SS "Hooks"
.IX Subsection "Hooks"
Any class may define hooks dat is ghon be called durin tha serialization
and deserialization process on objects dat is instancez of dat class.
Those hooks can redefine tha way serialization is performed (and therefore,
how tha symmetrical deserialization should be conducted).
.PP
Since we holla'd earlier:
.PP
.Vb 1
\&    dclone(.) = thaw(freeze(.))
.Ve
.PP
everythang we say bout hooks should also hold fo' deep clonin yo. However,
hooks git ta know whether tha operation be a mere serialization, or a cold-ass lil cloning.
.PP
Therefore, when serializin hooks is involved,
.PP
.Vb 1
\&    dclone(.) <> thaw(freeze(.))
.Ve
.PP
Well, you could keep dem up in sync yo, but there be a no guarantee it will always
hold on classes some muthafucka else wrote.  Besides, there is lil ta bust in
fuckin wit so: a serializin hook could keep only one attribute of a object,
which is probably not what tha fuck should happen durin a thugged-out deep clonin of that
same object.
.PP
Here is tha hookin intercourse:
.ie n .IP """STORABLE_freeze"" \fIobj\fR, \fIcloning\fR" 4
.el .IP "\f(CWSTORABLE_freeze\fR \fIobj\fR, \fIcloning\fR" 4
.IX Item "STORABLE_freeze obj, cloning"
Da serializin hook, called on tha object durin serialization. I aint talkin' bout chicken n' gravy biatch.  It can be
inherited, or defined up in tha class itself, like any other method.
.Sp
Arguments: \fIobj\fR is tha object ta serialize, \fIcloning\fR be a gangbangin' flag indicating
whether we up in a \fIdclone()\fR or a regular serialization via \fIstore()\fR or \fIfreeze()\fR.
.Sp
Returned value: A \s-1LIST \s0\f(CW\*(C`($serialized, $ref1, $ref2, ...)\*(C'\fR where \f(CW$serialized\fR
is tha serialized form ta be used, n' tha optionizzle \f(CW$ref1\fR, \f(CW$ref2\fR, etc... are
extra references dat you wish ta let tha Storable engine serialize.
.Sp
At deserialization time, yo big-ass booty is ghon be given back tha same \s-1LIST,\s0 but all the
extra references is ghon be pointin tha fuck into tha deserialized structure.
.Sp
Da \fBfirst time\fR tha hook is hit up in a serialization flow, you may have it
return a empty list.  That will signal tha Storable engine ta further
discard dat hook fo' dis class n' ta therefore revert ta tha default
serialization of tha underlyin Perl data.  Da hook will again n' again n' again be normally
processed up in tha next serialization.
.Sp
Unless you know better, serializin hook should always say:
.Sp
.Vb 5
\&    sub STORABLE_freeze {
\&        mah ($self, $cloning) = @_;
\&        return if $cloning;         # Regular default serialization
\&        ....
\&    }
.Ve
.Sp
in order ta keep reasonable \fIdclone()\fR semantics.
.ie n .IP """STORABLE_thaw"" \fIobj\fR, \fIcloning\fR, \fIserialized\fR, ..." 4
.el .IP "\f(CWSTORABLE_thaw\fR \fIobj\fR, \fIcloning\fR, \fIserialized\fR, ..." 4
.IX Item "STORABLE_thaw obj, cloning, serialized, ..."
Da deserializin hook called on tha object durin deserialization.
But wait: if our phat asses deserializing, there be a no object yet... right?
.Sp
Wrong: tha Storable engine creates a empty one fo' yo thugged-out ass.  If you know Eiffel,
you can view \f(CW\*(C`STORABLE_thaw\*(C'\fR as a alternate creation routine.
.Sp
This means tha hook can be inherited like any other method, n' that
\&\fIobj\fR is yo' pimped reference fo' dis particular instance.
.Sp
Da other arguments should look familiar if you know \f(CW\*(C`STORABLE_freeze\*(C'\fR:
\&\fIcloning\fR is legit when we part of a thugged-out deep clone operation, \fIserialized\fR
is tha serialized strang you moonwalked back ta tha engine up in \f(CW\*(C`STORABLE_freeze\*(C'\fR,
and there may be a optionizzle list of references, up in tha same order you gave
them at serialization time, pointin ta tha deserialized objects (which
have been processed courtesy of tha Storable engine).
.Sp
When tha Storable engine do not find any \f(CW\*(C`STORABLE_thaw\*(C'\fR hook routine,
it tries ta load tha class by requirin tha package dynamically (using
the pimped package name), n' then re-attempts tha lookup.  If at that
time tha hook cannot be located, tha engine croaks.  Note dat dis mechanism
will fail if you define nuff muthafuckin classes up in tha same file yo, but perlmod
warned yo thugged-out ass.
.Sp
It be up ta you ta use dis shiznit ta populate \fIobj\fR tha way you want.
.Sp
Returned value: none.
.ie n .IP """STORABLE_attach"" \fIclass\fR, \fIcloning\fR, \fIserialized\fR" 4
.el .IP "\f(CWSTORABLE_attach\fR \fIclass\fR, \fIcloning\fR, \fIserialized\fR" 4
.IX Item "STORABLE_attach class, cloning, serialized"
While \f(CW\*(C`STORABLE_freeze\*(C'\fR n' \f(CW\*(C`STORABLE_thaw\*(C'\fR is useful fo' classes where
each instizzle is independent, dis mechanizzle has hang-up (or is
incompatible) wit objects dat exist as common process-level or
system-level resources, like fuckin singleton objects, database pools, caches
or memoized objects.
.Sp
Da alternatizzle \f(CW\*(C`STORABLE_attach\*(C'\fR method serves up a solution fo' these
shared objects, n' you can put dat on yo' toast. Instead of \f(CW\*(C`STORABLE_freeze\*(C'\fR \-\-> \f(CW\*(C`STORABLE_thaw\*(C'\fR,
you implement \f(CW\*(C`STORABLE_freeze\*(C'\fR \-\-> \f(CW\*(C`STORABLE_attach\*(C'\fR instead.
.Sp
Arguments: \fIclass\fR is tha class we is attachin to, \fIcloning\fR be a gangbangin' flag
indicatin whether we up in a \fIdclone()\fR or a regular de-serialization via
\&\fIthaw()\fR, n' \fIserialized\fR is tha stored strang fo' tha resource object.
.Sp
Because these resource objects is considered ta be owned by tha entire
process/system, n' not tha \*(L"property\*(R" of whatever is bein serialized,
no references underneath tha object should be included up in tha serialized
string. Thus, up in any class dat implements \f(CW\*(C`STORABLE_attach\*(C'\fR, the
\&\f(CW\*(C`STORABLE_freeze\*(C'\fR method cannot return any references, n' \f(CW\*(C`Storable\*(C'\fR
will throw a error if \f(CW\*(C`STORABLE_freeze\*(C'\fR tries ta return references.
.Sp
All shiznit required ta \*(L"attach\*(R" back ta tha shared resource object
\&\fBmust\fR be contained \fBonly\fR up in tha \f(CW\*(C`STORABLE_freeze\*(C'\fR return string.
Otherwise, \f(CW\*(C`STORABLE_freeze\*(C'\fR behaves as aiiight fo' \f(CW\*(C`STORABLE_attach\*(C'\fR
classes.
.Sp
Because \f(CW\*(C`STORABLE_attach\*(C'\fR is passed tha class (rather than a object),
it also returns tha object directly, rather than modifyin tha passed
object.
.Sp
Returned value: object of type \f(CW\*(C`class\*(C'\fR
.SS "Predicates"
.IX Subsection "Predicates"
Predicates is not exportable.  They must be called by explicitly prefixing
them wit tha Storable package name.
.ie n .IP """Storable::last_op_in_netorder""" 4
.el .IP "\f(CWStorable::last_op_in_netorder\fR" 4
.IX Item "Storable::last_op_in_netorder"
Da \f(CW\*(C`Storable::last_op_in_netorder()\*(C'\fR predicate will rap  whether
network order was used up in tha last store or retrieve operation. I aint talkin' bout chicken n' gravy biatch.  If you
don't give a fuck how tha fuck ta use this, just forget bout dat shit.
.ie n .IP """Storable::is_storing""" 4
.el .IP "\f(CWStorable::is_storing\fR" 4
.IX Item "Storable::is_storing"
Returns legit if within a store operation (via STORABLE_freeze hook).
.ie n .IP """Storable::is_retrieving""" 4
.el .IP "\f(CWStorable::is_retrieving\fR" 4
.IX Item "Storable::is_retrieving"
Returns legit if within a retrieve operation (via STORABLE_thaw hook).
.SS "Recursion"
.IX Subsection "Recursion"
With hooks comes tha mobilitizzle ta recurse back ta tha Storable engine.
Indeed, hooks is regular Perl code, n' Storable is convenient when
it comes ta serializin n' deserializin thangs, so why not use it
to handle tha serialization string?
.PP
There is all dem thangs you need ta know, however:
.IP "\(bu" 4
Yo ass can create endless loops if tha thangs you serialize via \fIfreeze()\fR
(for instance) point back ta tha object we tryin ta serialize in
the hook.
.IP "\(bu" 4
Shared references among objects aint gonna stay shared: if we serializing
the list of object [A, C] where both object A n' C refer ta tha \s-1SAME\s0 object
B, n' if there be a serializin hook up in A dat say freeze(B), then when
deserializing, we'll git [A', C'] where A' refers ta B' yo, but C' refers ta D,
a deep clone of B'.  Da topologizzle was not preserved.
.PP
Thatz why \f(CW\*(C`STORABLE_freeze\*(C'\fR lets you provide a list of references
to serialize.  Da engine guarantees dat dem is ghon be serialized up in the
same context as tha other objects, n' therefore dat shared objects will
stay shared.
.PP
In tha above [A, C] example, tha \f(CW\*(C`STORABLE_freeze\*(C'\fR hook could return:
.PP
.Vb 1
\&        ("something", $self\->{B})
.Ve
.PP
and tha B part would be serialized by tha engine.  In \f(CW\*(C`STORABLE_thaw\*(C'\fR, you
would git back tha reference ta tha B' object, deserialized fo' yo thugged-out ass.
.PP
Therefore, recursion should normally be avoided yo, but is nonetheless supported.
.SS "Deep Cloning"
.IX Subsection "Deep Cloning"
There be a Clone module available on \s-1CPAN\s0 which implements deep cloning
natively, i.e. without freezin ta memory n' thawin tha result.  It is
aimed ta replace Storablez \fIdclone()\fR some day. It make me wanna hollar playa!  But fuck dat shiznit yo, tha word on tha street is dat it do not currently
support Storable hooks ta redefine tha way deep clonin is performed.
.SH "Storable magic"
.IX Header "Storable magic"
Yes, there be a a shitload of dat :\-) But mo' precisely, up in \s-1UNIX\s0 systems
therez a utilitizzle called \f(CW\*(C`file\*(C'\fR, which recognizes data filez based on
their contents (usually they first few bytes).  For dis ta work,
a certain file called \fImagic\fR need ta taught bout tha \fIsignature\fR
of tha data.  Where dat configuration file lives dependz on tha \s-1UNIX\s0
flavour; often itz suttin' like \fI/usr/share/misc/magic\fR or
\&\fI/etc/magic\fR.  Yo crazy-ass system administrator need ta do tha uppimpin of
the \fImagic\fR file.  Da necessary signature shiznit is output to
\&\s-1STDOUT\s0 by invokin \fIStorable::show_file_magic()\fR.  Note dat tha \s-1GNU\s0
implementation of tha \f(CW\*(C`file\*(C'\fR utility, version 3.38 or later,
is sposed ta fuckin contain support fo' recognisin Storable files
out-of-the-box, up in addizzle ta other kindz of Perl files.
.PP
Yo ass can also use tha followin functions ta extract tha file header
information from Storable images:
.ie n .IP "$info = Storable::file_magic( $filename )" 4
.el .IP "\f(CW$info\fR = Storable::file_magic( \f(CW$filename\fR )" 4
.IX Item "$info = Storable::file_magic( $filename )"
If tha given file be a Storable image return a hash describin dat shit.  If
the file is readable yo, but not a Storable image return \f(CW\*(C`undef\*(C'\fR.  If
the file do not exist or is unreadable then croak.
.Sp
Da hash returned has tha followin elements:
.RS 4
.ie n .IP """version""" 4
.el .IP "\f(CWversion\fR" 4
.IX Item "version"
This returns tha file format version. I aint talkin' bout chicken n' gravy biatch.  It be a strang like \*(L"2.7\*(R".
.Sp
Note dat dis version number aint tha same as tha version number of
the Storable module itself.  For instizzle Storable v0.7 create files
in format v2.0 n' Storable v2.15 create filez up in format v2.7.  The
file format version number only increment when additionizzle features
that would confuse olda versionz of tha module is added.
.Sp
Filez olda than v2.0 gonna git tha one of tha version numbers \*(L"\-1\*(R",
\&\*(L"0\*(R" or \*(L"1\*(R".  No minor number was used at dat time.
.ie n .IP """version_nv""" 4
.el .IP "\f(CWversion_nv\fR" 4
.IX Item "version_nv"
This returns tha file format version as number n' shit.  It be a strang like
\&\*(L"2.007\*(R".  This value is suitable fo' numeric comparisons.
.Sp
Da constant function \f(CW\*(C`Storable::BIN_VERSION_NV\*(C'\fR returns a cold-ass lil comparable
number dat represents tha highest file version number dat this
version of Storable straight-up supports (but peep rap of
\&\f(CW$Storable::accept_future_minor\fR above).  Da constant
\&\f(CW\*(C`Storable::BIN_WRITE_VERSION_NV\*(C'\fR function returns what tha fuck file version
is freestyled n' might be less than \f(CW\*(C`Storable::BIN_VERSION_NV\*(C'\fR up in some
configurations.
.ie n .IP """major"", ""minor""" 4
.el .IP "\f(CWmajor\fR, \f(CWminor\fR" 4
.IX Item "major, minor"
This also returns tha file format version. I aint talkin' bout chicken n' gravy biatch.  If tha version is \*(L"2.7\*(R"
then major would be 2 n' minor would be 7.  Da minor element is
missin fo' when major is less than 2.
.ie n .IP """hdrsize""" 4
.el .IP "\f(CWhdrsize\fR" 4
.IX Item "hdrsize"
Da is tha number of bytes dat tha Storable header occupies.
.ie n .IP """netorder""" 4
.el .IP "\f(CWnetorder\fR" 4
.IX Item "netorder"
This is \s-1TRUE\s0 if tha image store data up in network order n' shit.  This means
that dat shiznit was pimped wit \fInstore()\fR or similar.
.ie n .IP """byteorder""" 4
.el .IP "\f(CWbyteorder\fR" 4
.IX Item "byteorder"
This is only present when \f(CW\*(C`netorder\*(C'\fR is \s-1FALSE. \s0 It be the
\&\f(CW$Config\fR{byteorder} strang of tha perl dat pimped dis image.  It is
a strang like \*(L"1234\*(R" (32 bit lil endian) or \*(L"87654321\*(R" (64 bit big
endian).  This must match tha current perl fo' tha image ta be
readable by Storable.
.ie n .IP """intsize"", ""longsize"", ""ptrsize"", ""nvsize""" 4
.el .IP "\f(CWintsize\fR, \f(CWlongsize\fR, \f(CWptrsize\fR, \f(CWnvsize\fR" 4
.IX Item "intsize, longsize, ptrsize, nvsize"
These is only present when \f(CW\*(C`netorder\*(C'\fR is \s-1FALSE.\s0 These is tha sizes of
various C datatypez of tha perl dat pimped dis image.  These must
match tha current perl fo' tha image ta be readable by Storable.
.Sp
Da \f(CW\*(C`nvsize\*(C'\fR element is only present fo' file format v2.2 and
higher.
.ie n .IP """file""" 4
.el .IP "\f(CWfile\fR" 4
.IX Item "file"
Da name of tha file.
.RE
.RS 4
.RE
.ie n .IP "$info = Storable::read_magic( $buffer )" 4
.el .IP "\f(CW$info\fR = Storable::read_magic( \f(CW$buffer\fR )" 4
.IX Item "$info = Storable::read_magic( $buffer )"
.PD 0
.ie n .IP "$info = Storable::read_magic( $buffer, $must_be_file )" 4
.el .IP "\f(CW$info\fR = Storable::read_magic( \f(CW$buffer\fR, \f(CW$must_be_file\fR )" 4
.IX Item "$info = Storable::read_magic( $buffer, $must_be_file )"
.PD
Da \f(CW$buffer\fR should be a Storable image or tha straight-up original gangsta few bytez of dat shit.
If \f(CW$buffer\fR starts wit a Storable header, then a hash describin the
image is returned, otherwise \f(CW\*(C`undef\*(C'\fR is returned.
.Sp
Da hash has tha same ol' dirty structure as tha one returned by
\&\fIStorable::file_magic()\fR.  Da \f(CW\*(C`file\*(C'\fR element is legit if tha image be a
file image.
.Sp
If tha \f(CW$must_be_file\fR argument is provided n' is \s-1TRUE,\s0 then return
\&\f(CW\*(C`undef\*(C'\fR unless tha image be lookin like it belongs ta a gangbangin' file dump.
.Sp
Da maximum size of a Storable header is currently 21 bytes.  If the
provided \f(CW$buffer\fR is only tha straight-up original gangsta part of a Storable image it should
at least be dis long ta ensure dat \fIread_magic()\fR will recognize it as
such.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Here is some code samplez showin a possible usage of Storable:
.PP
.Vb 1
\&        use Storable qw(store retrieve freeze thaw dclone);
\&
\&        %color = (\*(AqBlue\*(Aq => 0.1, \*(AqRed\*(Aq => 0.8, \*(AqBlack\*(Aq => 0, \*(AqWhite\*(Aq => 1);
\&
\&        store(\e%color, \*(Aqmycolors\*(Aq) or take a thugged-out dirtnap "Can\*(Aqt store %a up in mycolors!\en";
\&
\&        $colref = retrieve(\*(Aqmycolors\*(Aq);
\&        take a thugged-out dirtnap "Unable ta retrieve from mycolors!\en" unless defined $colref;
\&        printf "Blue is still %lf\en", $colref\->{\*(AqBlue\*(Aq};
\&
\&        $colref2 = dclone(\e%color);
\&
\&        $str = freeze(\e%color);
\&        printf "Serialization of %%color is %d bytes long.\en", length($str);
\&        $colref3 = thaw($str);
.Ve
.PP
which prints (on mah machine):
.PP
.Vb 2
\&        Blue is still 0.100000
\&        Serialization of %color is 102 bytes long.
.Ve
.PP
Serialization of \s-1CODE\s0 references n' deserialization up in a safe
compartment:
.PP
.Vb 11
\&        use Storable qw(freeze thaw);
\&        use Safe;
\&        use strict;
\&        mah $safe = freshly smoked up Safe;
\&        # cuz of opcodes used up in "use strict":
\&        $safe\->permit(qw(:default require));
\&        local $Storable::Deparse = 1;
\&        local $Storable::Eval = sub { $safe\->reval($_[0]) };
\&        mah $serialized = freeze(sub { 42 });
\&        mah $code = thaw($serialized);
\&        $code\->() == 42;
.Ve
.SH "SECURITY WARNING"
.IX Header "SECURITY WARNING"
\&\fBDo not accept Storable documents from untrusted sources!\fR
.PP
Some featurez of Storable can lead ta securitizzle vulnerabilitizzles if you
accept Storable documents from untrusted sources. Most obviously, the
optionizzle (off by default) \s-1CODE\s0 reference serialization feature allows
transfer of code ta tha deserializin process. Furthermore, any
serialized object will cause Storable ta helpfully load tha module
correspondin ta tha class of tha object up in tha deserializin module.
For manipulated module names, dis can load almost arbitrary code.
Finally, tha deserialized objectz destructors is ghon be invoked when
the objects git destroyed up in tha deserializin process. Maliciously
crafted Storable documents may put such objects up in tha value of
a hash key dat is overridden by another key/value pair up in the
same hash, thus causin immediate destructor execution.
.PP
In a gangbangin' future version of Storable, we intend ta provide options ta disable
loadin modulez fo' classes n' ta disable deserializin objects
altogether n' shit. \fINonetheless, Storable deserializin documents from
untrusted sources is sposed ta fuckin have other, yet undiscovered,
securitizzle concerns like fuckin allowin a attacker ta cause tha deserializer
to crash hard.\fR
.PP
\&\fBTherefore, let me repeat: Do not accept Storable documents from
untrusted sources!\fR
.PP
If yo' application requires acceptin data from untrusted sources, you
are dopest off wit a less bangin n' more-likely safe serialization format
and implementation. I aint talkin' bout chicken n' gravy biatch. If yo' data is sufficiently simple, \s-1JSON\s0 be a good
choice n' offers maximum interoperability.
.SH "WARNING"
.IX Header "WARNING"
If you rockin references as keys within yo' hash tables, you bound
to be pissed tha fuck off when retrievin yo' data. Git tha fuck outta mah grill wit dat bullshit, Perl stringifies
references used as hash table keys. If you lata wish ta access the
items via another reference stringification (i.e. rockin tha same
reference dat was used fo' tha key originally ta record tha value into
the hash table), it will work cuz both references stringify ta the
same string.
.PP
It won't work across a sequence of \f(CW\*(C`store\*(C'\fR n' \f(CW\*(C`retrieve\*(C'\fR operations,
however, cuz tha addresses up in tha retrieved objects, which are
part of tha stringified references, will probably differ from the
original gangsta addresses. Da topologizzle of yo' structure is preserved,
but not hidden semantics like them.
.PP
On platforms where it matters, be shizzle ta booty-call \f(CW\*(C`binmode()\*(C'\fR on the
descriptors dat you pass ta Storable functions.
.PP
Storin data canonically dat gotz nuff big-ass hashes can be
significantly slower than storin tha same data normally, as
temporary arrays ta hold tha keys fo' each hash gotta be allocated,
populated, sorted n' freed. Y'all KNOW dat shit, muthafucka!  Some tests have shown a halvin of the
speed of storin \*(-- tha exact penalty will depend on tha complexitizzle of
your data.  There is no slowdown on retrieval.
.SH "BUGS"
.IX Header "BUGS"
Yo ass can't store \s-1GLOB, FORMLINE, REGEXP,\s0 etc.... If you can define semantics
for dem operations, feel free ta enhizzle Storable so dat it can
deal wit em.
.PP
Da store functions will \f(CW\*(C`croak\*(C'\fR if they run tha fuck into such references
unless you set \f(CW$Storable::forgive_me\fR ta some \f(CW\*(C`TRUE\*(C'\fR value. In that
case, tha fatal message is turned up in a warnin n' some
meaningless strang is stored instead.
.PP
Settin \f(CW$Storable::canonical\fR may not yield frozen strings that
compare equal cuz of possible stringification of numbers. When the
strin version of a scalar exists, it is tha form stored; therefore,
if you happen ta use yo' numbers as strings between two freezing
operations on tha same data structures, yo big-ass booty is ghon git different
results.
.PP
When storin doublez up in network order, they value is stored as text.
But fuck dat shiznit yo, tha word on tha street is dat you should also not expect non-numeric floating-point joints
like fuckin infinitizzle n' \*(L"not a number\*(R" ta pass successfully all up in a
\&\fInstore()\fR/\fIretrieve()\fR pair.
.PP
As Storable neither knows nor cares bout characta sets (although it
does know dat charactas may be mo' than eight bits wide), any difference
in tha interpretation of characta codes between a host n' a target
system is yo' problem.  In particular, if host n' target use different
code points ta represent tha charactas used up in tha text representation
of floating-point numbers, yo big-ass booty is ghon not be able be able ta exchange
floating-point data, even wit \fInstore()\fR.
.PP
\&\f(CW\*(C`Storable::drop_utf8\*(C'\fR be a funky-ass blunt tool.  There is no facilitizzle either to
return \fBall\fR strings as utf8 sequences, or ta attempt ta convert utf8
data back ta 8 bit n' \f(CW\*(C`croak()\*(C'\fR if tha conversion fails.
.PP
Prior ta Storable 2.01, no distinction was made between signed and
unsigned integers on storing.  By default Storable prefers ta store a
scalars strang representation (if it has one) so dis would only cause
problems when storin big-ass unsigned integers dat had never been converted
to strang or floatin point.  In other lyrics joints dat had been generated
by integer operations like fuckin logic ops n' then not used up in any strang or
arithmetic context before storing.
.SS "64 bit data up in perl 5.6.0 n' 5.6.1"
.IX Subsection "64 bit data up in perl 5.6.0 n' 5.6.1"
This section only applies ta you if you have existin data freestyled out
by Storable 2.02 or earlier on perl 5.6.0 or 5.6.1 on Unix or Linux which
has been configured wit 64 bit integer support (not tha default)
If you gots a precompiled perl, rather than hustlin Configure ta build
your own perl from source, then it almost certainly do not affect you,
and you can stop readin now (unless you curious). If you rockin perl
on Windows it do not affect yo thugged-out ass.
.PP
Storable writes a gangbangin' file header which gotz nuff tha sizez of various C
language types fo' tha C compila dat built Storable (when not freestylin in
network order), n' will refuse ta load filez freestyled by a Storable not
on tha same (or compatible) architecture.  This check n' a cold-ass lil check on
machine byteorder is needed cuz tha size of various fieldz up in tha file
are given by tha sizez of tha C language types, n' so filez freestyled on
different architectures is incompatible.  This is done fo' increased speed.
(When freestylin up in network order, all fieldz is freestyled up as standard
lengths, which allows full interworkin yo, but takes longer ta read n' write)
.PP
Perl 5.6.x introduced tha mobilitizzle ta optionizzle configure tha perl interpreter
to use Cz \f(CW\*(C`long long\*(C'\fR type ta allow scalars ta store 64 bit integers on 32
bit systems.  But fuck dat shiznit yo, tha word on tha street is dat cuz of tha way tha Perl configuration system
generated tha C configuration filez on non-Windows platforms, n' tha way
Storable generates its header, not a god damn thang up in tha Storable file header reflected
whether tha perl freestylin was rockin 32 or 64 bit integers, despite tha fact
that Storable was storin some data differently up in tha file.  Hence Storable
runnin on perl wit 64 bit integers will read tha header from a gangbangin' file
written by a 32 bit perl, not realise dat tha data is straight-up up in a subtly
incompatible format, n' then go horribly wack (possibly crashing) if it
encountered a stored integer n' shit.  This be a thugged-out design failure.
.PP
Storable has now been chizzled ta write up n' read up in a gangbangin' file header with
information bout tha size of integers.  It aint nuthin but impossible ta detect whether
an oldschool file bein read up in was freestyled wit 32 or 64 bit integers (they have
the same header) so itz impossible ta automatically switch ta a cold-ass lil erect
backwardz compatibilitizzle mode.  Hence dis Storable defaults ta tha new,
correct behaviour.
.PP
What dis means is dat if you have data freestyled by Storable 1.x hustlin
on perl 5.6.0 or 5.6.1 configured wit 64 bit integers on Unix or Linux
then by default dis Storable will refuse ta read it, givin tha error
\&\fIByte order aint compatible\fR.  If you have such data then you
should set \f(CW$Storable::interwork_56_64bit\fR ta a legit value ta make this
Storable read n' write filez wit tha oldschool header n' shit.  Yo ass should also
migrate yo' data, or any olda perl yo ass is communicatin with, ta this
current version of Storable.
.PP
If you aint gots data freestyled wit specific configuration of perl busted lyrics about
above, then you do not n' should not do anything.  Don't set tha flag \-
not only will Storable on a identically configured perl refuse ta load them,
but Storable a gangbangin' finger-lickin' differently configured perl will load dem believin them
to be erect fo' it, n' then may well fail or crash part way through
readin em.
.SH "CREDITS"
.IX Header "CREDITS"
Nuff props ta (in chronological order):
.PP
.Vb 10
\&        Jarkko Hietaniemi <jhi@iki.fi>
\&        Ulrich Pfeifer <pfeifer@charly.informatik.uni\-dortmund.de>
\&        Benjamin A yo. Holzman <bholzman@earthlink.net>
\&        Andrew Ford <A.Ford@ford\-mason.co.uk>
\&        Gisle Aas <gisle@aas.no>
\&        Jeff Gresham <gresham_jeffrey@jpmorgan.com>
\&        Murray Nesbitt <murray@activestate.com>
\&        Marc Lehmann <pcg@opengroup.org>
\&        Quentin Banks <justinb@wamnet.com>
\&        Jarkko Hietaniemi <jhi@iki.fi> (AGAIN, as perl 5.7.0 Pumpkin!)
\&        Salvador Ortiz Garcia <sog@msg.com.mx>
\&        Dominic Dunlop <domo@computer.org>
\&        Erik Haugan <erik@solbors.no>
\&        Benjamin A yo. Holzman <ben.holzman@grantstreet.com>
\&        Reini Urban <rurban@cpanel.net>
.Ve
.PP
for they bug reports, suggestions n' contributions.
.PP
Benjamin Holzman contributed tha tied variable support, Andrew Ford
contributed tha canonical order fo' hashes, n' Gisle Aas fixed
a few misunderstandingz of mine regardin tha perl internals,
and optimized tha emission of \*(L"tags\*(R" up in tha output streams by
simply countin tha objects instead of taggin dem (leadin to
a binary incompatibilitizzle fo' tha Storable image startin at version
0.6\-\-olda images are, of course, still properly understood).
Murray Nesbitt made Storable thread-safe.  Marc Lehmann added overloading
and references ta tied shit support.  Benjamin Holzman added a performance
improvement fo' overloaded classes; props ta Grant Street Group fo' footing
the bill.
.SH "AUTHOR"
.IX Header "AUTHOR"
Storable was freestyled by Raphael Manfredi
\&\fI<Raphael_Manfredi@pobox.com>\fR
Maintenizzle is now done by tha perl5\-porters
\&\fI<perl5\-porters@perl.org>\fR
.PP
Please e\-mail our asses wit problems, bug fixes, comments n' disses,
although if you have compliments you should bust dem ta Raphael.
Please don't e\-mail Raphael wit problems, as he no longer works on
Storable, n' yo' message is ghon be delayed while he forwardz it ta us.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Clone.
