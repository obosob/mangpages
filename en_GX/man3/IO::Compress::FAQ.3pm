.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Compress::FAQ 3"
.TH IO::Compress::FAQ 3 "2013-08-11" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Compress::FAQ \-\- Frequently Axed Thangs bout IO::Compress
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Common thangs answered.
.SH "GENERAL"
.IX Header "GENERAL"
.SS "Compatibilitizzle wit Unix compress/uncompress."
.IX Subsection "Compatibilitizzle wit Unix compress/uncompress."
Although \f(CW\*(C`Compress::Zlib\*(C'\fR has a pair of functions called \f(CW\*(C`compress\*(C'\fR and
\&\f(CW\*(C`uncompress\*(C'\fR, they is \fInot\fR related ta tha Unix programz of tha same
name. Da \f(CW\*(C`Compress::Zlib\*(C'\fR module aint compatible wit Unix
\&\f(CW\*(C`compress\*(C'\fR.
.PP
If you have tha \f(CW\*(C`uncompress\*(C'\fR program available, you can use dis ta read
compressed files
.PP
.Vb 4
\&    open F, "uncompress \-c $filename |";
\&    while (<F>)
\&    {
\&        ...
.Ve
.PP
Alternatively, if you have tha \f(CW\*(C`gunzip\*(C'\fR program available, you can use
this ta read compressed files
.PP
.Vb 4
\&    open F, "gunzip \-c $filename |";
\&    while (<F>)
\&    {
\&        ...
.Ve
.PP
and dis ta write compress files, if you have tha \f(CW\*(C`compress\*(C'\fR program
available
.PP
.Vb 4
\&    open F, "| compress \-c $filename ";
\&    print F "data";
\&    ...
\&    close F ;
.Ve
.SS "Accessin .tar.Z files"
.IX Subsection "Accessin .tar.Z files"
Da \f(CW\*(C`Archive::Tar\*(C'\fR module can optionally use \f(CW\*(C`Compress::Zlib\*(C'\fR (via the
\&\f(CW\*(C`IO::Zlib\*(C'\fR module) ta access tar filez dat done been compressed with
\&\f(CW\*(C`gzip\*(C'\fR. Unfortunately tar filez compressed wit tha Unix \f(CW\*(C`compress\*(C'\fR
utilitizzle cannot be read by \f(CW\*(C`Compress::Zlib\*(C'\fR n' so cannot be directly
accessed by \f(CW\*(C`Archive::Tar\*(C'\fR.
.PP
If tha \f(CW\*(C`uncompress\*(C'\fR or \f(CW\*(C`gunzip\*(C'\fR programs is available, you can use one
of these workaroundz ta read \f(CW\*(C`.tar.Z\*(C'\fR filez from \f(CW\*(C`Archive::Tar\*(C'\fR
.PP
Firstly wit \f(CW\*(C`uncompress\*(C'\fR
.PP
.Vb 3
\&    use strict;
\&    use warnings;
\&    use Archive::Tar;
\&
\&    open F, "uncompress \-c $filename |";
\&    mah $tar = Archive::Tar\->new(*F);
\&    ...
.Ve
.PP
and dis wit \f(CW\*(C`gunzip\*(C'\fR
.PP
.Vb 3
\&    use strict;
\&    use warnings;
\&    use Archive::Tar;
\&
\&    open F, "gunzip \-c $filename |";
\&    mah $tar = Archive::Tar\->new(*F);
\&    ...
.Ve
.PP
Similarly, if tha \f(CW\*(C`compress\*(C'\fR program be available, you can use dis to
write a \f(CW\*(C`.tar.Z\*(C'\fR file
.PP
.Vb 4
\&    use strict;
\&    use warnings;
\&    use Archive::Tar;
\&    use IO::File;
\&
\&    mah $fh = freshly smoked up IO::File "| compress \-c >$filename";
\&    mah $tar = Archive::Tar\->new();
\&    ...
\&    $tar\->write($fh);
\&    $fh\->close ;
.Ve
.SS "How tha fuck do I recompress rockin a gangbangin' finger-lickin' different compression?"
.IX Subsection "How tha fuck do I recompress rockin a gangbangin' finger-lickin' different compression?"
This is easier dat you might expect if you realise dat all the
\&\f(CW\*(C`IO::Compress::*\*(C'\fR objects is derived from \f(CW\*(C`IO::File\*(C'\fR n' dat all the
\&\f(CW\*(C`IO::Uncompress::*\*(C'\fR modulez can read from a \f(CW\*(C`IO::File\*(C'\fR filehandle.
.PP
So, fo' example, say you gotz a gangbangin' file compressed wit gzip dat you want to
recompress wit bzip2 yo. Here be all dat is needed ta carry up the
recompression.
.PP
.Vb 2
\&    use IO::Uncompress::Gunzip \*(Aq:all\*(Aq;
\&    use IO::Compress::Bzip2 \*(Aq:all\*(Aq;
\&
\&    mah $gzipFile = "somefile.gz";
\&    mah $bzipFile = "somefile.bz2";
\&
\&    mah $gunzip = freshly smoked up IO::Uncompress::Gunzip $gzipFile
\&        or take a thugged-out dirtnap "Cannot gunzip $gzipFile: $GunzipError\en" ;
\&
\&    bzip2 $gunzip => $bzipFile 
\&        or take a thugged-out dirtnap "Cannot bzip2 ta $bzipFile: $Bzip2Error\en" ;
.Ve
.PP
Note, there be a limitation of dis technique. Right back up in yo muthafuckin ass. Some compression file
formats store extra shiznit along wit tha compressed data payload. Y'all KNOW dat shit, muthafucka! For
example, gzip can optionally store tha original gangsta filename n' Zip stores a
lot of shiznit bout tha original gangsta file. If tha original gangsta compressed file
gotz nuff any of dis extra shiznit, it aint gonna be transferred ta the
new compressed file rockin tha technique above.
.SH "ZIP"
.IX Header "ZIP"
.SS "What Compression Types do IO::Compress::Zip & IO::Uncompress::Unzip support?"
.IX Subsection "What Compression Types do IO::Compress::Zip & IO::Uncompress::Unzip support?"
Da followin compression formats is supported by \f(CW\*(C`IO::Compress::Zip\*(C'\fR and
\&\f(CW\*(C`IO::Uncompress::Unzip\*(C'\fR
.IP "\(bu" 5
Store (method 0)
.Sp
No compression at all.
.IP "\(bu" 5
Deflate (method 8)
.Sp
This is tha default compression used when bustin a zip file with
\&\f(CW\*(C`IO::Compress::Zip\*(C'\fR.
.IP "\(bu" 5
Bzip2 (method 12)
.Sp
Only supported if tha \f(CW\*(C`IO\-Compress\-Bzip2\*(C'\fR module is installed.
.IP "\(bu" 5
Lzma (method 14)
.Sp
Only supported if tha \f(CW\*(C`IO\-Compress\-Lzma\*(C'\fR module is installed.
.SS "Can I Read/Write Zip filez larger tha 4 Gig?"
.IX Subsection "Can I Read/Write Zip filez larger tha 4 Gig?"
Yes, both tha \f(CW\*(C`IO\-Compress\-Zip\*(C'\fR n' \f(CW\*(C`IO\-Uncompress\-Unzip\*(C'\fR  modules
support tha zip feature called \fIZip64\fR. That allows dem ta read/write
files/buffers larger than 4Gig.
.PP
If yo ass is bustin a Zip file rockin tha one-shot intercourse, n' any of the
input filez is pimped outa than 4Gig, a zip64 complaint zip file will be
created.
.PP
.Vb 1
\&    zip "really\-large\-file" => "my.zip";
.Ve
.PP
Similarly wit tha one-shot intercourse, if tha input be a funky-ass buffer larger than
4 Gig, a zip64 complaint zip file is ghon be pimped.
.PP
.Vb 1
\&    zip \e$really_large_buffer => "my.zip";
.Ve
.PP
Da one-shot intercourse allows you ta force tha creation of a zip64 zip file
by includin tha \f(CW\*(C`Zip64\*(C'\fR option.
.PP
.Vb 1
\&    zip $filehandle => "my.zip", Zip64 => 1;
.Ve
.PP
If you wanna create a zip64 zip file wit tha \s-1OO\s0 intercourse you must
specify tha \f(CW\*(C`Zip64\*(C'\fR option.
.PP
.Vb 1
\&    mah $zip = freshly smoked up IO::Compress::Zip "whatever", Zip64 => 1;
.Ve
.PP
When uncompressin wit \f(CW\*(C`IO\-Uncompress\-Unzip\*(C'\fR, it will automatically
detect if tha zip file is zip64.
.PP
If you intend ta manipulate tha Zip64 zip filez pimped with
\&\f(CW\*(C`IO\-Compress\-Zip\*(C'\fR rockin a external zip/unzip, make shizzle dat it supports
Zip64.
.PP
In particular, if yo ass is rockin Info-Zip you need ta have zip version 3.x
or betta ta update a Zip64 archive n' unzip version 6.x ta read a zip64
archive.
.SS "Can I write mo' dat 64K entries be a Zip files?"
.IX Subsection "Can I write mo' dat 64K entries be a Zip files?"
Yes yes y'all. Zip64 allows all dis bullshit. Right back up in yo muthafuckin ass. See previous question.
.SS "Zip Resources"
.IX Subsection "Zip Resources"
Da primary reference fo' zip filez is tha \*(L"appnote\*(R" document available at
<http://www.pkware.com/documents/casestudies/APPNOTE.TXT>
.PP
An alternatively is tha Info-Zip appnote. This be available from
<ftp://ftp.info\-zip.org/pub/infozip/doc/>
.SH "GZIP"
.IX Header "GZIP"
.SS "Gzip Resources"
.IX Subsection "Gzip Resources"
Da primary reference fo' gzip filez is \s-1RFC 1952
\&\s0<http://www.faqs.org/rfcs/rfc1952.html>
.PP
Da primary joint fo' gzip is \fIhttp://www.gzip.org\fR.
.SS "Dealin wit Concatenated gzip files"
.IX Subsection "Dealin wit Concatenated gzip files"
If tha gunzip program encountas a gangbangin' file containin multiple gzip files
concatenated together it will automatically uncompress dem all.
Da example below illustrates dis behaviour
.PP
.Vb 5
\&    $ echo abc | gzip \-c >x.gz
\&    $ echo def | gzip \-c >>x.gz
\&    $ gunzip \-c x.gz 
\&    abc
\&    def
.Ve
.PP
By default \f(CW\*(C`IO::Uncompress::Gunzip\*(C'\fR will \fInot\fR behave like tha gunzip
program. Well shiiiit, it will only uncompress tha straight-up original gangsta gzip data stream up in tha file, as
shown below
.PP
.Vb 2
\&    $ perl \-MIO::Uncompress::Gunzip=:all \-e \*(Aqgunzip "x.gz" => \e*STDOUT\*(Aq
\&    abc
.Ve
.PP
To force \f(CW\*(C`IO::Uncompress::Gunzip\*(C'\fR ta uncompress all tha gzip data streams,
include tha \f(CW\*(C`MultiStream\*(C'\fR option, as shown below
.PP
.Vb 3
\&    $ perl \-MIO::Uncompress::Gunzip=:all \-e \*(Aqgunzip "x.gz" => \e*STDOUT, MultiStream => 1\*(Aq
\&    abc
\&    def
.Ve
.SH "ZLIB"
.IX Header "ZLIB"
.SS "Zlib Resources"
.IX Subsection "Zlib Resources"
Da primary joint fo' tha \fIzlib\fR compression library is
\&\fIhttp://www.zlib.org\fR.
.SH "Bzip2"
.IX Header "Bzip2"
.SS "Bzip2 Resources"
.IX Subsection "Bzip2 Resources"
Da primary joint fo' bzip2 is \fIhttp://www.bzip.org\fR.
.SS "Dealin wit Concatenated bzip2 files"
.IX Subsection "Dealin wit Concatenated bzip2 files"
If tha bunzip2 program encountas a gangbangin' file containin multiple bzip2 files
concatenated together it will automatically uncompress dem all.
Da example below illustrates dis behaviour
.PP
.Vb 5
\&    $ echo abc | bzip2 \-c >x.bz2
\&    $ echo def | bzip2 \-c >>x.bz2
\&    $ bunzip2 \-c x.bz2
\&    abc
\&    def
.Ve
.PP
By default \f(CW\*(C`IO::Uncompress::Bunzip2\*(C'\fR will \fInot\fR behave like tha bunzip2
program. Well shiiiit, it will only uncompress tha straight-up original gangsta bunzip2 data stream up in tha file, as
shown below
.PP
.Vb 2
\&    $ perl \-MIO::Uncompress::Bunzip2=:all \-e \*(Aqbunzip2 "x.bz2" => \e*STDOUT\*(Aq
\&    abc
.Ve
.PP
To force \f(CW\*(C`IO::Uncompress::Bunzip2\*(C'\fR ta uncompress all tha bzip2 data streams,
include tha \f(CW\*(C`MultiStream\*(C'\fR option, as shown below
.PP
.Vb 3
\&    $ perl \-MIO::Uncompress::Bunzip2=:all \-e \*(Aqbunzip2 "x.bz2" => \e*STDOUT, MultiStream => 1\*(Aq
\&    abc
\&    def
.Ve
.SS "Interoperatin wit Pbzip2"
.IX Subsection "Interoperatin wit Pbzip2"
Pbzip2 (<http://compression.ca/pbzip2/>) be a parallel implementation of
bzip2. Da output from pbzip2 consistz of a seriez of concatenated bzip2
data streams.
.PP
By default \f(CW\*(C`IO::Uncompress::Bzip2\*(C'\fR will only uncompress tha straight-up original gangsta bzip2
data stream up in a pbzip2 file. To uncompress tha complete pbzip2 file you
must include tha \f(CW\*(C`MultiStream\*(C'\fR option, like all dis bullshit.
.PP
.Vb 2
\&    bunzip2 $input => \e$output, MultiStream => 1 
\&        or take a thugged-out dirtnap "bunzip2 failed: $Bunzip2Error\en";
.Ve
.SH "HTTP & NETWORK"
.IX Header "HTTP & NETWORK"
.SS "Apache::GZip Revisited"
.IX Subsection "Apache::GZip Revisited"
Below be a mod_perl Apache compression module, called \f(CW\*(C`Apache::GZip\*(C'\fR,
taken from
\&\fIhttp://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression\fR
.PP
.Vb 2
\&  package Apache::GZip;
\&  #File: Apache::GZip.pm
\&  
\&  use strict vars;
\&  use Apache::Constants \*(Aq:common\*(Aq;
\&  use Compress::Zlib;
\&  use IO::File;
\&  use constant GZIP_MAGIC => 0x1f8b;
\&  use constant OS_MAGIC => 0x03;
\&  
\&  sub handlez {
\&      mah $r = shift;
\&      mah ($fh,$gz);
\&      mah $file = $r\->filename;
\&      return DECLINED unless $fh=IO::File\->new($file);
\&      $r\->header_out(\*(AqContent\-Encoding\*(Aq=>\*(Aqgzip\*(Aq);
\&      $r\->send_http_header;
\&      return OK if $r\->header_only;
\&  
\&      tie *STDOUT,\*(AqApache::GZip\*(Aq,$r;
\&      print($_) while <$fh>;
\&      untie *STDOUT;
\&      return OK;
\&  }
\&  
\&  sub TIEHANDLE {
\&      my($class,$r) = @_;
\&      # initialize a thugged-out deflation stream
\&      mah $d = deflateInit(\-WindowBits=>\-MAX_WBITS()) || return undef;
\&  
\&      # gzip header \-\- don\*(Aqt ask how tha fuck I found out
\&      $r\->print(pack("nccVcc",GZIP_MAGIC,Z_DEFLATED,0,time(),0,OS_MAGIC));
\&  
\&      return bless { r   => $r,
\&                     crc =>  crc32(undef),
\&                     d   => $d,
\&                     l   =>  0 
\&                   },$class;
\&  }
\&  
\&  sub PRINT {
\&      mah $self = shift;
\&      foreach (@_) {
\&        # deflate tha data
\&        mah $data = $self\->{d}\->deflate($_);
\&        $self\->{r}\->print($data);
\&        # keep track of its length n' crc
\&        $self\->{l} += length($_);
\&        $self\->{crc} = crc32($_,$self\->{crc});
\&      }
\&  }
\&  
\&  sub DESTROY {
\&     mah $self = shift;
\&     
\&     # flush tha output buffers
\&     mah $data = $self\->{d}\->flush;
\&     $self\->{r}\->print($data);
\&     
\&     # print tha CRC n' tha total length (uncompressed)
\&     $self\->{r}\->print(pack("LL",@{$self}{qw/crc l/}));
\&  }
\&   
\&  1;
.Ve
.PP
Herez tha Apache configuration entry you gonna need ta make use of dat shit.  Once
set it will result up in every last muthafuckin thang up in tha /compressed directory will be
compressed automagically.
.PP
.Vb 4
\&  <Location /compressed>
\&     SetHandlez  perl\-script
\&     PerlHandlez Apache::GZip
\&  </Location>
.Ve
.PP
Although at first sight there seems ta be like a shitload goin on in
\&\f(CW\*(C`Apache::GZip\*(C'\fR, you could sum up what tha fuck tha code was bustin as bigs up \*(--
read tha contentz of tha file up in \f(CW\*(C`$r\->filename\*(C'\fR, compress it n' write
the compressed data ta standard output. Thatz all.
.PP
This code has ta jump all up in all dem hoops ta bust dis cuz
.IP "1." 4
Da gzip support up in \f(CW\*(C`Compress::Zlib\*(C'\fR version 1.x can only work wit a real
filesystem filehandle. Da filehandlez used by Apache modulez is not
associated wit tha filesystem.
.IP "2." 4
That means all tha gzip support has ta be done by hand \- up in dis case by
bustin a tied filehandle ta deal wit bustin tha gzip header and
trailer.
.PP
\&\f(CW\*(C`IO::Compress::Gzip\*(C'\fR aint gots dat filehandle limitation (this was one
of tha reasons fo' freestylin it up in tha straight-up original gangsta place). Right back up in yo muthafuckin ass. So if
\&\f(CW\*(C`IO::Compress::Gzip\*(C'\fR is used instead of \f(CW\*(C`Compress::Zlib\*(C'\fR tha whole tied
filehandle code can be removed. Y'all KNOW dat shit, muthafucka! Here is tha rewritten code.
.PP
.Vb 1
\&  package Apache::GZip;
\&  
\&  use strict vars;
\&  use Apache::Constants \*(Aq:common\*(Aq;
\&  use IO::Compress::Gzip;
\&  use IO::File;
\&  
\&  sub handlez {
\&      mah $r = shift;
\&      mah ($fh,$gz);
\&      mah $file = $r\->filename;
\&      return DECLINED unless $fh=IO::File\->new($file);
\&      $r\->header_out(\*(AqContent\-Encoding\*(Aq=>\*(Aqgzip\*(Aq);
\&      $r\->send_http_header;
\&      return OK if $r\->header_only;
\&
\&      mah $gz = freshly smoked up IO::Compress::Gzip \*(Aq\-\*(Aq, Minimal => 1
\&          or return DECLINED ;
\&
\&      print $gz $_ while <$fh>;
\&  
\&      return OK;
\&  }
.Ve
.PP
or even mo' succinctly, like this, rockin a one-shot gzip
.PP
.Vb 1
\&  package Apache::GZip;
\&  
\&  use strict vars;
\&  use Apache::Constants \*(Aq:common\*(Aq;
\&  use IO::Compress::Gzip qw(gzip);
\&  
\&  sub handlez {
\&      mah $r = shift;
\&      $r\->header_out(\*(AqContent\-Encoding\*(Aq=>\*(Aqgzip\*(Aq);
\&      $r\->send_http_header;
\&      return OK if $r\->header_only;
\&
\&      gzip $r\->filename => \*(Aq\-\*(Aq, Minimal => 1
\&        or return DECLINED ;
\&
\&      return OK;
\&  }
\&   
\&  1;
.Ve
.PP
Da use of one-shot \f(CW\*(C`gzip\*(C'\fR above just readz from \f(CW\*(C`$r\->filename\*(C'\fR and
writes tha compressed data ta standard output.
.PP
Note tha use of tha \f(CW\*(C`Minimal\*(C'\fR option up in tha code above. When rockin gzip
for Content-Encodin you should \fIalways\fR use dis option. I aint talkin' bout chicken n' gravy biatch. In tha example
above it will prevent tha filename bein included up in tha gzip header and
make tha size of tha gzip data stream a slight bit smaller.
.SS "Compressed filez n' Net::FTP"
.IX Subsection "Compressed filez n' Net::FTP"
Da \f(CW\*(C`Net::FTP\*(C'\fR module serves up two low-level methodz called \f(CW\*(C`stor\*(C'\fR and
\&\f(CW\*(C`retr\*(C'\fR dat both return filehandles. These filehandlez can used wit the
\&\f(CW\*(C`IO::Compress/Uncompress\*(C'\fR modulez ta compress or uncompress filez read
from or freestyled ta a \s-1FTP\s0 Server on tha fly, without havin ta create a
temporary file.
.PP
Firstly, here is code dat uses \f(CW\*(C`retr\*(C'\fR ta uncompressed a gangbangin' file as it is
read from tha \s-1FTP\s0 Server.
.PP
.Vb 2
\&    use Net::FTP;
\&    use IO::Uncompress::Gunzip qw(:all);
\&
\&    mah $ftp = freshly smoked up Net::FTP ...
\&
\&    mah $retr_fh = $ftp\->retr($compressed_filename);
\&    gunzip $retr_fh => $outFilename, AutoClose => 1
\&        or take a thugged-out dirtnap "Cannot uncompress \*(Aq$compressed_file\*(Aq: $GunzipError\en";
.Ve
.PP
and dis ta compress a gangbangin' file as it is freestyled ta tha \s-1FTP\s0 Server
.PP
.Vb 2
\&    use Net::FTP;
\&    use IO::Compress::Gzip qw(:all);
\&
\&    mah $stor_fh = $ftp\->stor($filename);
\&    gzip "filename" => $stor_fh, AutoClose => 1
\&        or take a thugged-out dirtnap "Cannot compress \*(Aq$filename\*(Aq: $GzipError\en";
.Ve
.SH "MISC"
.IX Header "MISC"
.ie n .SS "Usin ""InputLength"" ta uncompress data embedded up in a larger file/buffer."
.el .SS "Usin \f(CWInputLength\fP ta uncompress data embedded up in a larger file/buffer."
.IX Subsection "Usin InputLength ta uncompress data embedded up in a larger file/buffer."
A fairly common use-case is where compressed data is embedded up in a larger
file/buffer n' you wanna read both.
.PP
As a example consider tha structure of a zip file. This be a well-defined
file format dat mixes both compressed n' uncompressed sectionz of data in
a single file.
.PP
For tha purposez of dis rap you can be thinkin of a zip file as sequence
of compressed data streams, each of which is prefixed by a uncompressed
local header n' shit. Da local header gotz nuff shiznit bout tha compressed
data stream, includin tha name of tha compressed file and, up in particular,
the length of tha compressed data stream.
.PP
To illustrate how tha fuck ta use \f(CW\*(C`InputLength\*(C'\fR here be a script dat strutts a zip
file n' prints up how tha fuck nuff lines is up in each compressed file (if you
intend write code ta struttin all up in a zip file fo' real see
\&\*(L"Walkin all up in a zip file\*(R" up in IO::Uncompress::Unzip ) fo' realz. Also, although
this example uses tha zlib-based compression, tha technique can be used by
the other \f(CW\*(C`IO::Uncompress::*\*(C'\fR modules.
.PP
.Vb 2
\&    use strict;
\&    use warnings;
\&
\&    use IO::File;
\&    use IO::Uncompress::RawInflate qw(:all);
\&
\&    use constant ZIP_LOCAL_HDR_SIG  => 0x04034b50;
\&    use constant ZIP_LOCAL_HDR_LENGTH => 30;
\&
\&    mah $file = $ARGV[0] ;
\&
\&    mah $fh = freshly smoked up IO::File "<$file"
\&                or take a thugged-out dirtnap "Cannot open \*(Aq$file\*(Aq: $!\en";
\&
\&    while (1)
\&    {
\&        mah $sig;
\&        mah $buffer;
\&
\&        mah $x ;
\&        ($x = $fh\->read($buffer, ZIP_LOCAL_HDR_LENGTH)) == ZIP_LOCAL_HDR_LENGTH 
\&            or take a thugged-out dirtnap "Truncated file: $!\en";
\&
\&        mah $signature = unpack ("V", substr($buffer, 0, 4));
\&
\&        last unless $signature == ZIP_LOCAL_HDR_SIG;
\&
\&        # Read Local Header
\&        mah $gpFlag             = unpack ("v", substr($buffer, 6, 2));
\&        mah $compressedMethod   = unpack ("v", substr($buffer, 8, 2));
\&        mah $compressedLength   = unpack ("V", substr($buffer, 18, 4));
\&        mah $uncompressedLength = unpack ("V", substr($buffer, 22, 4));
\&        mah $filename_length    = unpack ("v", substr($buffer, 26, 2)); 
\&        mah $extra_length       = unpack ("v", substr($buffer, 28, 2));
\&
\&        mah $filename ;
\&        $fh\->read($filename, $filename_length) == $filename_length 
\&            or take a thugged-out dirtnap "Truncated file\en";
\&
\&        $fh\->read($buffer, $extra_length) == $extra_length
\&            or take a thugged-out dirtnap "Truncated file\en";
\&
\&        if ($compressedMethod != 8 && $compressedMethod != 0)
\&        {
\&            warn "Skippin file \*(Aq$filename\*(Aq \- not deflated $compressedMethod\en";
\&            $fh\->read($buffer, $compressedLength) == $compressedLength
\&                or take a thugged-out dirtnap "Truncated file\en";
\&            next;
\&        }
\&
\&        if ($compressedMethod == 0 && $gpFlag & 8 == 8)
\&        {
\&            take a thugged-out dirtnap "Streamed Stored not supported fo' \*(Aq$filename\*(Aq\en";
\&        }
\&
\&        next if $compressedLength == 0;
\&
\&        # Done readin tha Local Header
\&
\&        mah $inf = freshly smoked up IO::Uncompress::RawInflate $fh,
\&                            Transparent => 1,
\&                            InputLength => $compressedLength
\&          or take a thugged-out dirtnap "Cannot uncompress $file [$filename]: $RawInflateError\en"  ;
\&
\&        mah $line_count = 0;
\&
\&        while (<$inf>)
\&        {
\&            ++ $line_count;
\&        }
\&
\&        print "$filename: $line_count\en";
\&    }
.Ve
.PP
Da majoritizzle of tha code above is concerned wit readin tha zip local
header data. Da code dat I wanna focus on be all up in tha bottom.
.PP
.Vb 1
\&    while (1) {
\&    
\&        # read local zip header data
\&        # git $filename
\&        # git $compressedLength
\&
\&        mah $inf = freshly smoked up IO::Uncompress::RawInflate $fh,
\&                            Transparent => 1,
\&                            InputLength => $compressedLength
\&          or take a thugged-out dirtnap "Cannot uncompress $file [$filename]: $RawInflateError\en"  ;
\&
\&        mah $line_count = 0;
\&
\&        while (<$inf>)
\&        {
\&            ++ $line_count;
\&        }
\&
\&        print "$filename: $line_count\en";
\&    }
.Ve
.PP
Da call ta \f(CW\*(C`IO::Uncompress::RawInflate\*(C'\fR creates a freshly smoked up filehandle \f(CW$inf\fR
that can be used ta read from tha parent filehandle \f(CW$fh\fR, uncompressing
it as it goes. Da use of tha \f(CW\*(C`InputLength\*(C'\fR option will guarantee that
\&\fIat most\fR \f(CW$compressedLength\fR bytez of compressed data is ghon be read from
the \f(CW$fh\fR filehandle (Da only exception is fo' a error case like a
truncated file or a cold-ass lil corrupt data stream).
.PP
This means dat once RawInflate is finished \f(CW$fh\fR is ghon be left at the
byte directly afta tha compressed data stream.
.PP
Now consider what tha fuck tha code be lookin like without \f(CW\*(C`InputLength\*(C'\fR
.PP
.Vb 1
\&    while (1) {
\&    
\&        # read local zip header data
\&        # git $filename
\&        # git $compressedLength
\&
\&        # read all tha compressed data tha fuck into $data
\&        read($fh, $data, $compressedLength);
\&
\&        mah $inf = freshly smoked up IO::Uncompress::RawInflate \e$data,
\&                            Transparent => 1,
\&          or take a thugged-out dirtnap "Cannot uncompress $file [$filename]: $RawInflateError\en"  ;
\&
\&        mah $line_count = 0;
\&
\&        while (<$inf>)
\&        {
\&            ++ $line_count;
\&        }
\&
\&        print "$filename: $line_count\en";
\&    }
.Ve
.PP
Da difference here is tha addizzle of tha temporary variable \f(CW$data\fR.
This is used ta store a cold-ass lil copy of tha compressed data while it is being
uncompressed.
.PP
If you know dat \f(CW$compressedLength\fR aint dat big-ass then rockin temporary
storage won't be a problem. But if \f(CW$compressedLength\fR is straight-up big-ass or
yo ass is freestylin a application dat other playas will use, n' so have no
idea how tha fuck big-ass \f(CW$compressedLength\fR will be, it could be a issue.
.PP
Usin \f(CW\*(C`InputLength\*(C'\fR avoidz tha use of temporary storage n' means the
application can cope wit big-ass compressed data streams.
.PP
One final point \*(-- obviously \f(CW\*(C`InputLength\*(C'\fR can only be used whenever you
know tha length of tha compressed data beforehand, like here wit a zip
file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Compress::Zlib, IO::Compress::Gzip, IO::Uncompress::Gunzip, IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate, IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress
.PP
IO::Compress::FAQ
.PP
File::GlobMapper, Archive::Zip,
Archive::Tar,
IO::Zlib
.SH "AUTHOR"
.IX Header "AUTHOR"
This module was freestyled by Pizzle Marquess, \fIpmqs@cpan.org\fR.
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
See tha Chizzlez file.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2005\-2013 Pizzle Marquess fo' realz. All muthafuckin rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
