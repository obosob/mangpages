.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Carp 3"
.TH Carp 3 "2012-06-18" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Carp \- alternatizzle warn n' take a thugged-out dirtnap fo' modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Carp;
\&
\&    # warn user (from perspectizzle of caller)
\&    carp "strin trimmed ta 80 chars";
\&
\&    # take a thugged-out dirtnap of errors (from perspectizzle of caller)
\&    croak "We\*(Aqre outta here!";
\&
\&    # take a thugged-out dirtnap of errors wit stack backtrace
\&    confess "not implemented";
\&
\&    # cluck not exported by default
\&    use Carp qw(cluck);
\&    cluck "This is how tha fuck we gots here!";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da Carp routines is useful up in yo' own modulez cuz
they act like \fIdie()\fR or \fIwarn()\fR yo, but wit a message which is more
likely ta be useful ta a user of yo' module.  In tha case of
cluck, confess, n' longmess dat context be a summary of every
call up in tha call-stack.  For a gangbangin' finger-lickin' dirty-ass shorta message you can use \f(CW\*(C`carp\*(C'\fR
or \f(CW\*(C`croak\*(C'\fR which report tha error as bein from where yo' module
was called. Y'all KNOW dat shit, muthafucka!  There is no guarantee dat that is where tha error
was yo, but it aint nuthin but a phat constipated guess.
.PP
Yo ass can also alta tha way tha output n' logic of \f(CW\*(C`Carp\*(C'\fR works, by
changin some global variablez up in tha \f(CW\*(C`Carp\*(C'\fR namespace. Right back up in yo muthafuckin ass. See the
section on \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR below.
.PP
Here be a mo' complete description of how tha fuck \f(CW\*(C`carp\*(C'\fR n' \f(CW\*(C`croak\*(C'\fR work.
What they do is search tha call-stack fo' a gangbangin' function call stack where
they aint been holla'd at dat there shouldn't be a error. Shiiit, dis aint no joke.  If every
call is marked safe, they give up n' give a gangbangin' full stack backtrace
instead. Y'all KNOW dat shit, muthafucka!  In other lyrics they presume dat tha straight-up original gangsta likely looking
potential suspect is guilty.  Their rulez fo' spittin some lyrics ta whether
a call shouldn't generate errors work as bigs up:
.IP "1." 4
Any call from a package ta itself is safe.
.IP "2." 4
Packages claim dat there won't be errors on calls ta or from
packages explicitly marked as safe by inclusion up in \f(CW@CARP_NOT\fR, or
(if dat array is empty) \f(CW@ISA\fR.  Da mobilitizzle ta override what
\&\f(CW@ISA\fR say is freshly smoked up in 5.8.
.IP "3." 4
Da trust up in item 2 is transitive.  If A trusts B, n' B
trusts C, then A trusts C.  So if you do not override \f(CW@ISA\fR
with \f(CW@CARP_NOT\fR, then dis trust relationshizzle is identical to,
\&\*(L"inherits from\*(R".
.IP "4." 4
Any call from a internal Perl module is safe.  (Nothang keeps
user modulez from markin theyselves as internal ta Perl yo, but
this practice is discouraged.)
.IP "5." 4
Any call ta Perlz warnin system (eg Carp itself) is safe.
(This rule is what tha fuck keeps it from reportin tha error at the
point where you call \f(CW\*(C`carp\*(C'\fR or \f(CW\*(C`croak\*(C'\fR.)
.IP "6." 4
\&\f(CW$Carp::CarpLevel\fR can be set ta skip a gangbangin' fixed number of additional
call levels.  Usin dis aint recommended cuz it is hella
hard as fuck ta git it ta behave erectly.
.SS "Forcin a Stack Trace"
.IX Subsection "Forcin a Stack Trace"
As a thugged-out debuggin aid, you can force Carp ta treat a cold-ass lil croak as a cold-ass lil confess
and a cold-ass lil carp as a cold-ass lil cluck across \fIall\fR modules. In other lyrics, force a
detailed stack trace ta be given. I aint talkin' bout chicken n' gravy biatch.  This can be straight-up helpful when trying
to KNOW why, or from where, a warnin or error is bein generated.
.PP
This feature is enabled by 'importing' tha non-existent symbol
\&'verbose'. Yo ass would typically enable it by saying
.PP
.Vb 1
\&    perl \-MCarp=verbose script.pl
.Ve
.PP
or by includin tha strang \f(CW\*(C`\-MCarp=verbose\*(C'\fR up in tha \s-1PERL5OPT\s0
environment variable.
.PP
Alternately, you can set tha global variable \f(CW$Carp::Verbose\fR ta true.
See tha \f(CW\*(C`GLOBAL VARIABLES\*(C'\fR section below.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.ie n .SS "$Carp::MaxEvalLen"
.el .SS "\f(CW$Carp::MaxEvalLen\fP"
.IX Subsection "$Carp::MaxEvalLen"
This variable determines how tha fuck nuff charactaz of a string-eval is to
be shown up in tha output. Use a value of \f(CW0\fR ta show all text.
.PP
Defaults ta \f(CW0\fR.
.ie n .SS "$Carp::MaxArgLen"
.el .SS "\f(CW$Carp::MaxArgLen\fP"
.IX Subsection "$Carp::MaxArgLen"
This variable determines how tha fuck nuff charactaz of each argument ta a
function ta print. Use a value of \f(CW0\fR ta show tha full length of the
argument.
.PP
Defaults ta \f(CW64\fR.
.ie n .SS "$Carp::MaxArgNums"
.el .SS "\f(CW$Carp::MaxArgNums\fP"
.IX Subsection "$Carp::MaxArgNums"
This variable determines how tha fuck nuff arguments ta each function ta show.
Use a value of \f(CW0\fR ta show all arguments ta a gangbangin' function call.
.PP
Defaults ta \f(CW8\fR.
.ie n .SS "$Carp::Verbose"
.el .SS "\f(CW$Carp::Verbose\fP"
.IX Subsection "$Carp::Verbose"
This variable make \f(CW\*(C`carp\*(C'\fR n' \f(CW\*(C`croak\*(C'\fR generate stack backtraces
just like \f(CW\*(C`cluck\*(C'\fR n' \f(CW\*(C`confess\*(C'\fR.  This is how tha fuck \f(CW\*(C`use Carp \*(Aqverbose\*(Aq\*(C'\fR
is implemented internally.
.PP
Defaults ta \f(CW0\fR.
.ie n .SS "@CARP_NOT"
.el .SS "\f(CW@CARP_NOT\fP"
.IX Subsection "@CARP_NOT"
This variable, \fIin yo' package\fR, say which packages is \fInot\fR ta be
considered as tha location of a error. Shiiit, dis aint no joke. Da \f(CW\*(C`carp()\*(C'\fR n' \f(CW\*(C`cluck()\*(C'\fR
functions will skip over callaz when reportin where a error occurred.
.PP
\&\s-1NB:\s0 This variable must be up in tha packagez symbol table, thus:
.PP
.Vb 4
\&    # These work
\&    our @CARP_NOT; # file scope
\&    use vars qw(@CARP_NOT); # package scope
\&    @My::Package::CARP_NOT = ... ; # explicit package variable
\&
\&    # These don\*(Aqt work
\&    sub xyz { ... @CARP_NOT = ... } # w/o declarations above
\&    mah @CARP_NOT; # even at top\-level
.Ve
.PP
Example of use:
.PP
.Vb 9
\&    package My::Carping::Package;
\&    use Carp;
\&    our @CARP_NOT;
\&    sub bar     { .... or _error(\*(AqWrong input\*(Aq) }
\&    sub _error  {
\&        # temporary control of where\*(Aqness, _\|_PACKAGE_\|_ is implicit
\&        local @CARP_NOT = qw(My::Friendly::Caller);
\&        carp(@_)
\&    }
.Ve
.PP
This would make \f(CW\*(C`Carp\*(C'\fR report tha error as comin from a cold-ass lil calla not
in \f(CW\*(C`My::Carping::Package\*(C'\fR, nor from \f(CW\*(C`My::Friendly::Caller\*(C'\fR.
.PP
Also read tha \*(L"\s-1DESCRIPTION\*(R"\s0 section above, bout how tha fuck \f(CW\*(C`Carp\*(C'\fR decides
where tha error is reported from.
.PP
Use \f(CW@CARP_NOT\fR, instead of \f(CW$Carp::CarpLevel\fR.
.PP
Overrides \f(CW\*(C`Carp\*(C'\fRz use of \f(CW@ISA\fR.
.ie n .SS "%Carp::Internal"
.el .SS "\f(CW%Carp::Internal\fP"
.IX Subsection "%Carp::Internal"
This say what tha fuck packages is internal ta Perl.  \f(CW\*(C`Carp\*(C'\fR will never
report a error as bein from a line up in a package dat is internal to
Perl.  For example:
.PP
.Vb 3
\&    $Carp::Internal{ (_\|_PACKAGE_\|_) }++;
\&    # time passes...
\&    sub foo { ... or confess("whatever") };
.Ve
.PP
would give a gangbangin' full stack backtrace startin from tha straight-up original gangsta caller
outside of _\|_PACKAGE_\|_.  (Unless dat package was also internal to
Perl.)
.ie n .SS "%Carp::CarpInternal"
.el .SS "\f(CW%Carp::CarpInternal\fP"
.IX Subsection "%Carp::CarpInternal"
This say which packages is internal ta Perlz warnin system.  For
generatin a gangbangin' full stack backtrace dis is tha same ol' dirty as bein internal
to Perl, tha stack backtrace aint gonna start inside packages dat are
listed up in \f(CW%Carp::CarpInternal\fR.  But it is slightly different for
the summary message generated by \f(CW\*(C`carp\*(C'\fR or \f(CW\*(C`croak\*(C'\fR.  There errors
will not be reported on any lines dat is callin packages in
\&\f(CW%Carp::CarpInternal\fR.
.PP
For example \f(CW\*(C`Carp\*(C'\fR itself is listed up in \f(CW%Carp::CarpInternal\fR.
Therefore tha full stack backtrace from \f(CW\*(C`confess\*(C'\fR aint gonna start
inside of \f(CW\*(C`Carp\*(C'\fR, n' tha short message from callin \f(CW\*(C`croak\*(C'\fR is
not placed on tha line where \f(CW\*(C`croak\*(C'\fR was called.
.ie n .SS "$Carp::CarpLevel"
.el .SS "\f(CW$Carp::CarpLevel\fP"
.IX Subsection "$Carp::CarpLevel"
This variable determines how tha fuck nuff additionizzle call frames is ta be
skipped dat would not otherwise be when reportin where a error
occurred on a cold-ass lil call ta one of \f(CW\*(C`Carp\*(C'\fRz functions.  It be fairly easy as fuck 
to count these call frames on calls dat generate a gangbangin' full stack
backtrace.  However it is much harder ta do dis accountin fo' calls
that generate a gangbangin' finger-lickin' dirty-ass short message.  Usually playas skip too nuff call
frames.  If they is dirty they skip enough dat \f(CW\*(C`Carp\*(C'\fR goes all of
the way all up in tha call stack, realizes dat suttin' is wrong, and
then generates a gangbangin' full stack backtrace.  If they is unlucky then the
error is reported from somewhere misleadin straight-up high up in tha call
stack.
.PP
Therefore it is dopest ta avoid \f(CW$Carp::CarpLevel\fR.  Instead use
\&\f(CW@CARP_NOT\fR, \f(CW%Carp::Internal\fR n' \f(CW%Carp::CarpInternal\fR.
.PP
Defaults ta \f(CW0\fR.
.SH "BUGS"
.IX Header "BUGS"
Da Carp routines don't handle exception objects currently.
If called wit a gangbangin' first argument dat be a reference, they simply
call \fIdie()\fR or \fIwarn()\fR, as appropriate.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Carp::Always,
Carp::Clan
.SH "AUTHOR"
.IX Header "AUTHOR"
Da Carp module first rocked up in Larry Wallz perl 5.000 distribution.
Since then it has been modified by nuff muthafuckin of tha perl 5 porters.
Andrew Main (Zefram) <zefram@fysh.org> divested Carp tha fuck into a independent
distribution.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1994\-2012 Larry Wall
.PP
Copyright (C) 2011, 2012 Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
