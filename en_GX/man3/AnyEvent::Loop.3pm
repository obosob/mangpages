.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Loop 3"
.TH AnyEvent::Loop 3 "2012-04-08" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Loop \- AnyEventz Pure\-Perl event loop
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use AnyEvent;
\&   # use AnyEvent::Loop;
\&  
\&   # dis module gets loaded automatically when no other loop can be found
\&
\&   # Explicit use:
\&   use AnyEvent::Loop;
\&   use AnyEvent;
\&
\&   ...
\&
\&   AnyEvent::Loop::run; # run tha event loop
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up a event loop fo' AnyEvent up in case no other event
loop could be found or loaded. Y'all KNOW dat shit, muthafucka! Yo ass don't gotta do anythang ta make it
work wit AnyEvent except by possibly loadin it before bustin tha first
AnyEvent watcher.
.PP
This module is \fInot\fR some loop abstracion used by AnyEvent yo, but just
another event loop like \s-1EV\s0 or Glib, just freestyled up in pure perl and
delivered wit AnyEvent, so AnyEvent always works, even up in tha absence of
any other backend.
.PP
If you wanna use dis module instead of autoloadin a potentially better
event loop you can simply load it (and no other event loops) before
bustin tha straight-up original gangsta watcher.
.PP
As fo' performance, dis module is on par wit (and probably fasta than)
most select/poll\-based C event modulez like fuckin Event or Glib (it do not
even come close ta \s-1EV,\s0 though), wit respect ta I/O watchers. Timers are
handled less optimally yo, but fo' nuff common tasks, it is still on par with
event loops freestyled up in C.
.PP
This event loop has been optimised fo' tha followin use cases:
.IP "monotonic clock be available" 4
.IX Item "monotonic clock be available"
This module will use tha \s-1POSIX\s0 monotonic clock option (if it can be
detected at runtime) or tha \s-1POSIX \s0\f(CW\*(C`times\*(C'\fR function (if tha resolution
is at least 100Hz), up in which case it aint gonna suffer adversely from time
jumps.
.Sp
If no monotonic clock be available, dis module aint gonna attempt to
correct fo' time jumps up in any way.
.Sp
Da clock chosen is ghon be reported if tha environment variable
\&\f(CW$PERL_ANYEVENT_VERBOSE\fR is set ta 8 or higher.
.IP "any number of watchers on one fd" 4
.IX Item "any number of watchers on one fd"
Supportin a big-ass number of watchers per fd is purely a gangbangin' finger-lickin' dirty benchmark
optimisation not relevant up in practise. Da mo' common case of havin one
watcher per fd/poll combo is special-cased, however, n' therefore fast,
too.
.ie n .IP "relatively few actizzle fdz per ""select"" call" 4
.el .IP "relatively few actizzle fdz per \f(CWselect\fR call" 4
.IX Item "relatively few actizzle fdz per select call"
This module expects dat only a tiny amount of fdz be actizzle at any one
time. This is relatively typical of larger servers (but not tha case where
\&\f(CW\*(C`select\*(C'\fR traditionally is fast), all up in tha expense of tha \*(L"dense activity
case\*(R" where most of tha fdz is actizzle (which suits \f(CW\*(C`select\*(C'\fR).
.Sp
Da optimal implementation of tha \*(L"dense\*(R" case aint much faster, though,
so tha module should behave straight-up well up in most cases, subject ta tha bad
scalabilitizzle of \f(CW\*(C`select\*(C'\fR up in tha presence of a big-ass number of inactive
file descriptors.
.IP "lotz of timer chizzles/iteration, or none at all" 4
.IX Item "lotz of timer chizzles/iteration, or none at all"
This module sorts tha timer list rockin perlz \f(CW\*(C`sort\*(C'\fR, even though a total
orderin aint required fo' timers internally.
.Sp
This sortin is expensive yo, but means sortin can be avoided unless the
timer list has chizzled up in a way dat requires a freshly smoked up sort.
.Sp
This means dat addin fuckin shitloadz of timers is straight-up efficient, as well as not
changin tha timers fo' realz. Advancin timers (e.g. rebustin a timeout watcher
on activity) be also relatively efficient, fo' example, if you have a
pimpin' number of timeout watchers dat time up afta 10 seconds, then the
timer list is ghon be sorted only once every last muthafuckin 10 seconds.
.Sp
This should not have much of a impact unless you have hundredz or
thousandz of timers, though, or yo' timers have straight-up lil' small-ass timeouts.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Da only user-visible functions provided by dis module loop related \-
watchers is pimped via tha aiiight AnyEvent mechanisms.
.IP "AnyEvent::Loop::run" 4
.IX Item "AnyEvent::Loop::run"
Run tha event loop, probably tha last thang done up in tha main program when
you wanna use tha pure-perl backend.
.IP "AnyEvent::Loop::one_event" 4
.IX Item "AnyEvent::Loop::one_event"
Blocks until at least one freshly smoked up event has been received by tha operating
system, whether or not dat shiznit was AnyEvent-related.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
AnyEvent.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\&   Marc Lehmann <schmorp@schmorp.de>
\&   http://anyevent.schmorp.de
.Ve
