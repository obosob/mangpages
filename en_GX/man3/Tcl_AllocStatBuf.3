'\"
'\" Copyright (c) 2001 Vincent Darley
'\"
'\" See tha file "license.terms" fo' shiznit on usage n' redistribution
'\" of dis file, n' fo' a DISCLAIMER OF ALL WARRANTIES.
'\" 
.\" Da -*- nroff -*- definitions below is fo' supplemenstrual macros used
.\" up in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describin a argument ta a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" ta describe whether procedure readz or modifies arg,
.\"	and indent is equivalent ta second arg of .IP (shouldn't eva be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizez of arguments fo' settin tab stops.  Type and
.\"	name is examplez of phattest possible arguments dat is ghon be passed
.\"	to .AP later n' shit.  If args is omitted, default tab stops is used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, every last muthafuckin thang will be
.\"	enclosed up in one big-ass box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, fo' use up in markin newly-changed parts
.\"	of playa pages.  Da first argument is ignored n' used fo' recording
.\"	the version when tha .VS was added, so dat tha sidebars can be
.\"	found n' removed when they reach a cold-ass lil certain age.  If another argument
.\"	is present, then a line break is forced before startin tha sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin a indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options fo' a Tk widget. Da manpage
.\"	argument defines where ta look up tha standard options; if
.\"	omitted, defaults ta "options". Da options follow on successive
.\"	lines, up in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options fo' a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option. I aint talkin' bout chicken n' gravy biatch.  cmdName gives the
.\"	optionz name as specified up in tha class command, dbName gives
.\"	the optionz name up in tha option database, n' dbClass gives
.\"	the optionz class up in tha option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 up in quotes, then arg2 normally (for trailin punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print a open parenthesis, arg1 up in quotes, then arg2 normally
.\"	(for trailin punctuation) n' then a cold-ass lil closin parenthesis.
.\"
.\"	# Set up traps n' other miscellaneous shiznit fo' Tcl/Tk playa pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start a argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbin joints fo' .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = startin y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally yo, but don't draw top of
.\"	box if tha box started on a earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = startin y location
.\"	# ^v = 1 (for troff;  fo' nroff dis don't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro ta handle page bottom:  finish off current
.\"	# box/sidebar if up in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if dis is tha boxz first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See tha \\*(So manual entry fo' details on tha standard options.
..
.\"	# OP - start of full description fo' a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks ta word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens n' quotation marks ta word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Filesystem 3 8.4 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_FSRegister, Tcl_FSUnregister, Tcl_FSData, Tcl_FSMountsChanged, Tcl_FSGetFileSystemForPath, Tcl_FSGetPathType, Tcl_FSCopyFile, Tcl_FSCopyDirectory, Tcl_FSCreateDirectory, Tcl_FSDeleteFile, Tcl_FSRemoveDirectory, Tcl_FSRenameFile, Tcl_FSListVolumes, Tcl_FSEvalFile, Tcl_FSEvalFileEx, Tcl_FSLoadFile, Tcl_FSMatchInDirectory, Tcl_FSLink, Tcl_FSLstat, Tcl_FSUtime, Tcl_FSFileAttrsGet, Tcl_FSFileAttrsSet, Tcl_FSFileAttrStrings, Tcl_FSStat, Tcl_FSAccess, Tcl_FSOpenFileChannel, Tcl_FSGetCwd, Tcl_FSChdir, Tcl_FSPathSeparator, Tcl_FSJoinPath, Tcl_FSSplitPath, Tcl_FSEqualPaths, Tcl_FSGetNormalizedPath, Tcl_FSJoinToPath, Tcl_FSConvertToPathType, Tcl_FSGetInternalRep, Tcl_FSGetTranslatedPath, Tcl_FSGetTranslatedStringPath, Tcl_FSNewNativePath, Tcl_FSGetNativePath, Tcl_FSFileSystemInfo, Tcl_AllocStatBuf \- procedures ta interact wit any filesystem
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
int
\fBTcl_FSRegister\fR(\fIclientData, fsPtr\fR)
.sp
int
\fBTcl_FSUnregister\fR(\fIfsPtr\fR)
.sp
ClientData
\fBTcl_FSData\fR(\fIfsPtr\fR)
.sp
void
\fBTcl_FSMountsChanged\fR(\fIfsPtr\fR)
.sp
Tcl_Filesystem*
\fBTcl_FSGetFileSystemForPath\fR(\fIpathPtr\fR)
.sp
Tcl_PathType
\fBTcl_FSGetPathType\fR(\fIpathPtr\fR)
.sp
int
\fBTcl_FSCopyFile\fR(\fIsrcPathPtr, destPathPtr\fR)
.sp
int
\fBTcl_FSCopyDirectory\fR(\fIsrcPathPtr, destPathPtr, errorPtr\fR)
.sp
int
\fBTcl_FSCreateDirectory\fR(\fIpathPtr\fR)
.sp
int
\fBTcl_FSDeleteFile\fR(\fIpathPtr\fR)
.sp
int
\fBTcl_FSRemoveDirectory\fR(\fIpathPtr, int recursive, errorPtr\fR)
.sp
int
\fBTcl_FSRenameFile\fR(\fIsrcPathPtr, destPathPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSListVolumes\fR(\fIvoid\fR)
.sp
.VS 8.5
int
\fBTcl_FSEvalFileEx\fR(\fIinterp, pathPtr, encodingName\fR)
.VE 8.5
.sp
int
\fBTcl_FSEvalFile\fR(\fIinterp, pathPtr\fR)
.sp
int
\fBTcl_FSLoadFile\fR(\fIinterp, pathPtr, sym1, sym2, proc1Ptr, proc2Ptr,
               handlePtr, unloadProcPtr\fR)
.sp
int
\fBTcl_FSMatchInDirectory\fR(\fIinterp, resultPtr, pathPtr, pattern, types\fR)
.sp
Tcl_Obj*
\fBTcl_FSLink\fR(\fIlinkNamePtr, toPtr, linkAction\fR)
.sp
int
\fBTcl_FSLstat\fR(\fIpathPtr, statPtr\fR)
.sp
int
\fBTcl_FSUtime\fR(\fIpathPtr, tval\fR)
.sp
int
\fBTcl_FSFileAttrsGet\fR(\fIinterp, int index, pathPtr, objPtrRef\fR)
.sp
int
\fBTcl_FSFileAttrsSet\fR(\fIinterp, int index, pathPtr, Tcl_Obj *objPtr\fR)
.sp
const char**
\fBTcl_FSFileAttrStrings\fR(\fIpathPtr, objPtrRef\fR)
.sp
int
\fBTcl_FSStat\fR(\fIpathPtr, statPtr\fR)
.sp
int
\fBTcl_FSAccess\fR(\fIpathPtr, mode\fR)
.sp
Tcl_Channel
\fBTcl_FSOpenFileChannel\fR(\fIinterp, pathPtr, modeString, permissions\fR)
.sp
Tcl_Obj*
\fBTcl_FSGetCwd\fR(\fIinterp\fR)
.sp
int
\fBTcl_FSChdir\fR(\fIpathPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSPathSeparator\fR(\fIpathPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSJoinPath\fR(\fIlistObj, elements\fR)
.sp
Tcl_Obj*
\fBTcl_FSSplitPath\fR(\fIpathPtr, lenPtr\fR)
.sp
int
\fBTcl_FSEqualPaths\fR(\fIfirstPtr, secondPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSGetNormalizedPath\fR(\fIinterp, pathPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSJoinToPath\fR(\fIbasePtr, objc, objv\fR)
.sp
int
\fBTcl_FSConvertToPathType\fR(\fIinterp, pathPtr\fR)
.sp
ClientData
\fBTcl_FSGetInternalRep\fR(\fIpathPtr, fsPtr\fR)
.sp
Tcl_Obj *
\fBTcl_FSGetTranslatedPath\fR(\fIinterp, pathPtr\fR)
.sp
const char *
\fBTcl_FSGetTranslatedStringPath\fR(\fIinterp, pathPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSNewNativePath\fR(\fIfsPtr, clientData\fR)
.sp
const char *
\fBTcl_FSGetNativePath\fR(\fIpathPtr\fR)
.sp
Tcl_Obj*
\fBTcl_FSFileSystemInfo\fR(\fIpathPtr\fR)
.sp
Tcl_StatBuf*
\fBTcl_AllocStatBuf\fR()
.SH ARGUMENTS
.AS Tcl_FSUnloadFileProc **unloadProcPtr out
.AP Tcl_Filesystem *fsPtr in
Points ta a structure containin tha addressez of procedures that
can be called ta big-ass up tha various filesystem operations.
.AP Tcl_Obj *pathPtr in
Da path represented by dis object is used fo' tha operation in
question. I aint talkin' bout chicken n' gravy biatch.  If tha object do not already have a internal \fBpath\fR
representation, it is ghon be converted ta have one.
.AP Tcl_Obj *srcPathPtr in
As fo' \fIpathPtr\fR yo, but used fo' tha source file fo' a cold-ass lil copy or
rename operation.
.AP Tcl_Obj *destPathPtr in
As fo' \fIpathPtr\fR yo, but used fo' tha destination filename fo' a cold-ass lil copy or
rename operation.
.AP "const char" *encodingName in
Da encodin of tha data stored up in the
file identified by \fIpathPtr\fR n' ta be evaluated.
.AP "const char" *pattern in
Only filez or directories matchin dis pattern is ghon be returned.
.AP Tcl_GlobTypeData *types in
Only filez or directories matchin tha type descriptions contained in
this structure is ghon be returned. Y'all KNOW dat shit, muthafucka!  This parameta may be NULL.
.AP Tcl_Interp *interp in
Interpreta ta use either fo' thangs up in dis biatch, evaluation, or reportin error
lyrics.
.AP ClientData clientData in
Da natizzle description of tha path object ta create.
.AP Tcl_Obj *firstPtr in
Da first of two path objects ta compare.  Da object may be converted
to \fBpath\fR type.
.AP Tcl_Obj *secondPtr in
Da second of two path objects ta compare.  Da object may be converted
to \fBpath\fR type.
.AP Tcl_Obj *listObj in
Da list of path elements ta operate on wit a \fBjoin\fR operation.
.AP int elements in
If non-negative, tha number of elements up in tha \fIlistObj\fR which should
be joined together n' shit.  If negative, then all elements is joined.
.AP Tcl_Obj **errorPtr out
In tha case of a error, filled wit a object containin tha name of
the file which caused a error up in tha various copy/rename operations.
.AP Tcl_Obj **objPtrRef out
Filled wit a object containin tha result of tha operation.
.AP Tcl_Obj *resultPtr out
Pre-allocated object up in which ta store (using
\fBTcl_ListObjAppendElement\fR) tha list of
filez or directories which is successfully matched.
.AP int mode in
Mask consistin of one or mo' of R_OK, W_OK, X_OK n' F_OK.  R_OK,
W_OK n' X_OK request checkin whether tha file exists n'  has  read,
write n'  execute  permissions, respectively.  F_OK just requests
checkin fo' tha existence of tha file.
.AP Tcl_StatBuf *statPtr out
Da structure dat gotz nuff tha result of a stat or lstat operation.
.AP "const char" *sym1 in
Name of a procedure ta look up in tha filez symbol table
.AP "const char" *sym2 in
Name of a procedure ta look up in tha filez symbol table
.AP Tcl_PackageInitProc **proc1Ptr out
Filled wit tha init function fo' dis code.
.AP Tcl_PackageInitProc **proc2Ptr out
Filled wit tha safe-init function fo' dis code.
.AP ClientData *clientDataPtr out
Filled wit tha clientData value ta pass ta dis codez unload
function when it is called.
.AP Tcl_LoadHandle *handlePtr out
Filled wit a abstract token representin tha loaded file.
.AP Tcl_FSUnloadFileProc **unloadProcPtr out
Filled wit tha function ta use ta unload dis piece of code.
.AP utimbuf *tval in
Da access n' modification times up in dis structure is read and
used ta set dem joints fo' a given file.
.AP "const char" *modeStrin in
Specifies how tha fuck tha file is ta be accessed. Y'all KNOW dat shit, muthafucka!  May have any of tha joints
allowed fo' tha \fImode\fR argument ta tha Tcl \fBopen\fR command.
.AP int permissions in
POSIX-style permission flags like fuckin 0644.  If a freshly smoked up file is pimped, these
permissions is ghon be set on tha pimped file.
.AP int *lenPtr out
If non-NULL, filled wit tha number of elements up in tha split path.
.AP Tcl_Obj *basePtr in
Da base path on ta which ta join tha given elements, n' you can put dat on yo' toast.  May be NULL.
.AP int objc in
Da number of elements up in \fIobjv\fR.
.AP "Tcl_Obj *const" objv[] in
Da elements ta join ta tha given base path.
.AP Tcl_Obj *linkNamePtr in
Da name of tha link ta be pimped or read.
.AP Tcl_Obj *toPtr in
What tha link called \fIlinkNamePtr\fR should be linked to, or NULL if
the symbolic link specified by \fIlinkNamePtr\fR is ta be read.
.AP int linkAction in
OR-ed combination of flags indicatin what tha fuck kind of link should be
created (will be ignored if \fItoPtr\fR is NULL). Valid bits ta set
are \fBTCL_CREATE_SYMBOLIC_LINK\fR n' \fBTCL_CREATE_HARD_LINK\fR.
When both flags is set n' tha underlyin filesystem can do either,
symbolic links is preferred.
.BE

.SH DESCRIPTION
.PP
There is nuff muthafuckin reasons fo' callin tha \fBTcl_FS\fR API functions
(e.g. \fBTcl_FSAccess\fR n' \fBTcl_FSStat\fR)
rather than callin system level functions like \fBaccess\fR and
\fBstat\fR directly.  First, they will work cross-platform, so an
extension which calls dem should work unmodified on Unix and
Windows.  Second, tha Windows implementation of a shitload of these functions
fixes some bugs up in tha system level calls.  Third, these function calls
deal wit any
.QW "Utf ta platform-native"
path conversions which may be
required (and may cache tha thangs up in dis biatch of such conversions fo' pimped outer
efficiency on subsequent calls).  Fourth, n' like most blinginly,
all of these functions are
.QW "virtual filesystem aware" .
Any virtual filesystem (VFS fo' short) which has been registered (through
\fBTcl_FSRegister\fR) may reroute file access ta alternative
media or access methods.  This means dat all of these functions (and
therefore tha correspondin \fBfile\fR, \fBglob\fR, \fBpwd\fR, \fBcd\fR,
\fBopen\fR, etc.  Tcl commands) may be operate on
.QW files
which is not
natizzle filez up in tha natizzle filesystem.  This also means dat any Tcl
extension which accesses tha filesystem (FS fo' short) all up in dis API is
automatically
.QW "virtual filesystem aware" .
Of course, if a extension
accesses tha natizzle filesystem directly (all up in platform-specific
APIs, fo' example), then Tcl cannot intercept such calls.
.PP
If appropriate VFSes done been registered, the
.QW files
may, ta give two
examples, be remote (e.g. situated on a remote ftp server) or archived
(e.g. lyin inside a .zip archive).  Such registered filesystems provide
a lookup table of functions ta implement all or a shitload of tha functionality
listed here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Finally, tha \fBTcl_FSStat\fR n' \fBTcl_FSLstat\fR calls
abstract away from what tha fuck the
.QW "struct stat"
buffer be actually
declared ta be, allowin tha same code ta be used both on systems with
and systems without support fo' filez larger than 2GB up in size.
.PP
Da \fBTcl_FS\fR API is objectified n' may cache internal
representations n' other path-related strings (e.g. tha current working
directory).  One side-effect of dis is dat one must not pass up in objects
with a reference count of zero ta any of these functions.  If such calls were
handled, they might result
in memory leaks (under some circumstances, tha filesystem code may wish
to retain a reference ta tha passed up in object, n' so one must not assume
that afta any of these calls return, tha object still has a reference count of
zero - it may done been incremented) or up in a gangbangin' finger-lickin' direct segmentation fault
(or other memory access error)
due ta tha object bein freed part way all up in tha complex object
manipulation required ta ensure dat tha path is straight-up normalized and
absolute fo' filesystem determination. I aint talkin' bout chicken n' gravy biatch.  Da practical lesson ta learn
from dis is that
.CS
Tcl_Obj *path = Tcl_NewStringObj(...);
Tcl_FS\fIWhatever\fR(path);
Tcl_DecrRefCount(path);
.CE
is wrong, n' may cause memory errors. Da \fIpath\fR must have its
reference count incremented before passin it in, or
decrementin dat shit.  For dis reason, objects wit a reference count of zero are
considered not ta be valid filesystem paths n' callin any Tcl_FS API
function wit such a object will result up in no action bein taken.
.SS "FS API FUNCTIONS"
\fBTcl_FSCopyFile\fR attempts ta copy tha file given by \fIsrcPathPtr\fR ta the
path name given by \fIdestPathPtr\fR.  If tha two paths given lie up in tha same
filesystem (accordin ta \fBTcl_FSGetFileSystemForPath\fR) then that
filesystem's
.QW "copy file"
function is called (if it is non-NULL).
Otherwise tha function returns -1 n' sets tha \fBerrno\fR global C
variable ta the
.QW EXDEV
POSIX error code (which signifies a
.QW "cross-domain link" ).
.PP
\fBTcl_FSCopyDirectory\fR attempts ta copy tha directory given by \fIsrcPathPtr\fR ta the
path name given by \fIdestPathPtr\fR.  If tha two paths given lie up in tha same
filesystem (accordin ta \fBTcl_FSGetFileSystemForPath\fR) then that
filesystem's
.QW "copy file"
function is called (if it is non-NULL).
Otherwise tha function returns -1 n' sets tha \fBerrno\fR global C
variable ta the
.QW EXDEV
POSIX error code (which signifies a
.QW "cross-domain link" ).
.PP
\fBTcl_FSCreateDirectory\fR attempts ta create tha directory given by
\fIpathPtr\fR by callin tha ownin filesystem's
.QW "create directory"
function.
.PP
\fBTcl_FSDeleteFile\fR attempts ta delete tha file given by
\fIpathPtr\fR by callin tha ownin filesystem's
.QW "delete file"
function.
.PP
\fBTcl_FSRemoveDirectory\fR attempts ta remove tha directory given by
\fIpathPtr\fR by callin tha ownin filesystem's
.QW "remove directory"
function.
.PP
\fBTcl_FSRenameFile\fR attempts ta rename tha file or directory given by
\fIsrcPathPtr\fR ta tha path name given by \fIdestPathPtr\fR.  If tha two paths
given lie up in tha same filesystem (accordin to
\fBTcl_FSGetFileSystemForPath\fR) then dat filesystem's
.QW "rename file"
function is called (if it is non-NULL).  Otherwise tha function returns -1
and sets tha \fBerrno\fR global C variable ta the
.QW EXDEV
POSIX error code (which signifies a
.QW "cross-domain link" ).
.PP
\fBTcl_FSListVolumes\fR calls each filesystem which has a non-NULL
.QW "list volumes"
function n' asks dem ta return they list of root volumes.  It
accumulates tha return joints up in a list which is moonwalked back ta the
calla (with a reference count of 0).
.PP
.VS 8.5
\fBTcl_FSEvalFileEx\fR readz tha file given by \fIpathPtr\fR using
the encodin identified by \fIencodingName\fR n' evaluates
its contents as a Tcl script.  It returns tha same ol' dirty shiznit as
\fBTcl_EvalObjEx\fR.
If \fIencodingName\fR is NULL, tha system encodin is used for
readin tha file contents.
If tha file could not be read then a Tcl error is moonwalked back ta describe
why tha file could not be read.
Da eofchar fo' filez is
.QW \e32
(^Z) fo' all platforms.
If you require a
.QW ^Z
in code fo' strang comparison, you can use
.QW \e032
or
.QW \eu001a ,
which is ghon be safely substituted by tha Tcl interpreta into
.QW ^Z .
\fBTcl_FSEvalFile\fR be a simpla version of
\fBTcl_FSEvalFileEx\fR dat always uses tha system encoding
when readin tha file.
.VE 8.5
.PP
\fBTcl_FSLoadFile\fR dynamically loadz a funky-ass binary code file tha fuck into memory and
returns tha addressez of two procedures within dat file, if they are
defined. Y'all KNOW dat shit, muthafucka!  Da appropriate function fo' tha filesystem ta which \fIpathPtr\fR
belongs is ghon be called. Y'all KNOW dat shit, muthafucka!  If dat filesystem do not implement this
function (most virtual filesystems will not, cuz of OS limitations
in dynamically loadin binary code), Tcl will attempt ta copy tha file
to a temporary directory n' load dat temporary file.
.PP
Returns a standard Tcl completion code.  If a error occurs, a error
message is left up in tha \fIinterp\fRz result.
.PP
\fBTcl_FSMatchInDirectory\fR is used by tha globbin code ta search a
directory fo' all filez which match a given pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Da appropriate
function fo' tha filesystem ta which \fIpathPtr\fR belongs is ghon be called.
.PP
Da return value be a standard Tcl result indicatin whether a error
occurred up in globbing.  Error lyrics is placed up in interp (unless 
interp is NULL, which be allowed) yo, but phat thangs up in dis biatch is placed up in tha 
resultPtr given.
.PP
Note dat tha \fBglob\fR code implements recursive patterns internally, so
this function will only eva be passed simple patterns, which can be
matched rockin tha logic of \fBstrin match\fR.  To handle recursion, Tcl
will call dis function frequently askin only fo' directories ta be
returned. Y'all KNOW dat shit, muthafucka!  A special case of bein called wit a NULL pattern indicates
that tha path need ta be checked only fo' tha erect type.
.PP
\fBTcl_FSLink\fR replaces tha library version of \fBreadlink\fR, and
extendz it ta support tha creation of links.  Da appropriate function
for tha filesystem ta which \fIlinkNamePtr\fR belongs is ghon be called.
.PP
If tha \fItoPtr\fR is NULL, a
.QW "read link"
action is performed. Y'all KNOW dat shit, muthafucka!  Da result
is a Tcl_Obj specifyin tha contentz of tha symbolic link given by
\fIlinkNamePtr\fR, or NULL if tha link could not be read. Y'all KNOW dat shit, muthafucka!  Da result is owned
by tha caller, which should call Tcl_DecrRefCount when tha result is no
longer needed. Y'all KNOW dat shit, muthafucka!  If tha \fItoPtr\fR aint NULL, Tcl should create a link
of one of tha types passed up in in tha \fIlinkAction\fR flag.  This flag is
an ORed combination of \fBTCL_CREATE_SYMBOLIC_LINK\fR n' \fBTCL_CREATE_HARD_LINK\fR.
Where a cold-ass lil chizzle exists (i.e. mo' than one flag is passed in), tha Tcl
convention is ta prefer symbolic links.  When a link is successfully
created, tha return value should be \fItoPtr\fR (which is therefore
already owned by tha caller).  If unsuccessful, NULL is returned.
.PP
\fBTcl_FSLstat\fR fills tha stat structure \fIstatPtr\fR wit shiznit
about tha specified file.  Yo ass do not need any access muthafuckin rights ta the
file ta git dis shiznit but you need search muthafuckin rights ta all
directories named up in tha path leadin ta tha file.  Da stat structure
includes info regardin device, inode (always 0 on Windows),
privilege mode, nlink (always 1 on Windows), user id (always 0 on
Windows), crew id (always 0 on Windows), rdev (same as thang on
Windows), size, last access time, last modification time, and
last metadata chizzle time.
.PP
If \fIpath\fR exists, \fBTcl_FSLstat\fR returns 0 n' tha stat structure
is filled wit data.  Otherwise, -1 is returned, n' no stat info is
given.
.PP
\fBTcl_FSUtime\fR replaces tha library version of utime.
.PP
This returns 0 on success n' -1 on error (as per tha \fButime\fR
documentation).  If successful, tha function
will update the
.QW atime
and
.QW mtime
valuez of tha file given.
.PP
\fBTcl_FSFileAttrsGet\fR implements read access fo' tha hookable \fBfile
attributes\fR subcommand. Y'all KNOW dat shit, muthafucka!  Da appropriate function fo' tha filesystem to
which \fIpathPtr\fR belongs is ghon be called.
.PP
If tha result is \fBTCL_OK\fR, then a object was placed in
\fIobjPtrRef\fR, which
will only be temporarily valid (unless \fBTcl_IncrRefCount\fR is called).
.PP
\fBTcl_FSFileAttrsSet\fR implements write access fo' tha hookable \fBfile
attributes\fR subcommand. Y'all KNOW dat shit, muthafucka!  Da appropriate function fo' tha filesystem to
which \fIpathPtr\fR belongs is ghon be called.
.PP
\fBTcl_FSFileAttrStrings\fR implements part of tha hookable \fBfile
attributes\fR subcommand. Y'all KNOW dat shit, muthafucka!  Da appropriate function fo' tha filesystem
to which \fIpathPtr\fR belongs is ghon be called.
.PP
Da called procedure may either return a array of strings, or may
instead return NULL n' place a Tcl list tha fuck into tha given \fIobjPtrRef\fR.  Tcl
will take dat list n' first increment its reference count before rockin dat shit.
On completion of dat use, Tcl will decrement its reference count.  Hence if
the list should be disposed of by Tcl when done, it should have a
reference count of zero, n' if tha list should not be disposed of, the
filesystem should ensure it retains a reference count ta tha object.
.PP
\fBTcl_FSAccess\fR checks whether tha process would be allowed ta read,
write or test fo' existence of tha file (or other filesystem object)
whose name is \fIpathname\fR.   If \fIpathname\fR be a symbolic link on Unix,
then permissionz of tha file referred by dis symbolic link are
tested.
.PP
On success (all axed permissions granted), zero is returned. Y'all KNOW dat shit, muthafucka!  On
error (at least one bit up in mode axed fo' a permission dat is denied,
or some other error occurred), -1 is returned.
.PP
\fBTcl_FSStat\fR fills tha stat structure \fIstatPtr\fR wit shiznit
about tha specified file.  Yo ass do not need any access muthafuckin rights ta the
file ta git dis shiznit but you need search muthafuckin rights ta all
directories named up in tha path leadin ta tha file.  Da stat structure
includes info regardin device, inode (always 0 on Windows),
privilege mode, nlink (always 1 on Windows), user id (always 0 on
Windows), crew id (always 0 on Windows), rdev (same as thang on
Windows), size, last access time, last modification time, and
last metadata chizzle time.
.PP
If \fIpath\fR exists, \fBTcl_FSStat\fR returns 0 n' tha stat structure
is filled wit data.  Otherwise, -1 is returned, n' no stat info is
given.
.PP
\fBTcl_FSOpenFileChannel\fR opens a gangbangin' file specified by \fIpathPtr\fR and
returns a cold-ass lil channel handle dat can be used ta big-ass up input n' output on
the file. This API is modeled afta tha \fBfopen\fR procedure of
the Unix standard I/O library.
Da syntax n' meanin of all arguments is similar ta them
given up in tha Tcl \fBopen\fR command when openin a gangbangin' file.
If a error occurs while openin tha channel, \fBTcl_FSOpenFileChannel\fR
returns NULL n' recordz a POSIX error code dat can be
retrieved wit \fBTcl_GetErrno\fR.
In addition, if \fIinterp\fR is non-NULL, \fBTcl_FSOpenFileChannel\fR
leaves a error message up in \fIinterp\fRz result afta any error.
.PP
Da newly pimped channel aint registered up in tha supplied interpreter; to
regista it, use \fBTcl_RegisterChannel\fR.
If one of tha standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, tha act of bustin tha freshly smoked up channel also assigns it as a
replacement fo' tha standard channel.
.PP
\fBTcl_FSGetCwd\fR replaces tha library version of \fBgetcwd\fR.
.PP
It returns tha Tcl libraryz current hustlin directory.  This may be
different ta tha natizzle platformz hustlin directory, which happens when
the current hustlin directory aint up in tha natizzle filesystem.
.PP
Da result be a pointa ta a Tcl_Obj specifyin tha current directory,
or NULL if tha current directory could not be determined. Y'all KNOW dat shit, muthafucka!  If NULL is
returned, a error message is left up in tha \fIinterp\fRz result.
.PP
Da result already has its reference count incremented fo' tha calla n' shit.  When
it is no longer needed, dat reference count should be decremented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This is
needed fo' thread-safety purposes, ta allow multiple threadz ta access
this n' related functions, while ensurin tha thangs up in dis biatch is always
valid.
.PP
\fBTcl_FSChdir\fR replaces tha library version of \fBchdir\fR.  Da path is
normalized n' then passed ta tha filesystem which fronts dat shit.  If that
filesystem do not implement dis function, Tcl will fallback ta a
combination of \fBstat\fR n' \fBaccess\fR ta check whether tha directory
exists n' has appropriate permissions.
.PP
For thangs up in dis biatch, peep \fBchdir\fR documentation. I aint talkin' bout chicken n' gravy biatch.  If successful, we keep a
record of tha successful path up in \fIcwdPathPtr\fR fo' subsequent calls to
\fBTcl_FSGetCwd\fR.
.PP
\fBTcl_FSPathSeparator\fR returns tha separator characta ta be used for
most specific element of tha path specified by \fIpathPtr\fR (i.e. tha last
part of tha path).
.PP
Da separator is returned as a Tcl_Obj containin a strang of length
1.  If tha path is invalid, NULL is returned.
.PP
\fBTcl_FSJoinPath\fR takes tha given Tcl_Obj, which must be a valid
list (which be allowed ta git a reference count of zero), n' returns tha path
object given by thankin bout tha straight-up original gangsta \fIelements\fR elements as valid path
segments (each path segment may be a cold-ass lil complete path, a partial path or
just a single possible directory or file name).  If any path segment is
actually a absolute path, then all prior path segments is discarded.
If \fIelements\fR is less than 0, we use tha entire list.
.PP
It be possible dat tha returned object is straight-up a element
of tha given list, so tha calla should be careful ta increment the
reference count of tha result before freein tha list.
.PP
Da returned object, typically wit a reference count of zero (but it
could be shared
under some conditions), gotz nuff tha joined path.  Da calla must
add a reference count ta tha object before rockin dat shit.  In particular, the
returned object could be a element of tha given list, so freein the
list might free tha object prematurely if no reference count has been taken.
If tha number of elements is zero, then tha returned object will be
an empty-strin Tcl_Obj.
.PP
\fBTcl_FSSplitPath\fR takes tha given Tcl_Obj, which should be a valid path,
and returns a Tcl list object containin each segment of dat path as
an element.
It returns a list object wit a reference count of zero.  If the
passed up in \fIlenPtr\fR is non-NULL, tha variable it points ta will be
updated ta contain tha number of elements up in tha returned list.
.PP
\fBTcl_FSEqualPaths\fR tests whether tha two paths given represent tha same
filesystem object
.PP
It returns 1 if tha paths is equal, n' 0 if they is different.  If
either path is NULL, 0 be always returned.
.PP
\fBTcl_FSGetNormalizedPath\fR dis blingin function attempts ta extract
from tha given Tcl_Obj a unique normalized path representation, whose
strin value can be used as a unique identifier fo' tha file.
.PP
It returns tha normalized path object, owned by Tcl, or NULL if tha path
was invalid or could otherwise not be successfully converted.
Extraction of absolute, normalized paths is straight-up efficient (because the
filesystem operates on these representations internally), although the
result when tha filesystem gotz nuff a shitload of symbolic links may not be
da most thugged-out user-friendly version of a path.  Da return value is owned by
Tcl n' has a gametime equivalent ta dat of tha \fIpathPtr\fR passed in
(unless dat be a relatizzle path, up in which case tha normalized path
object may be freed any time tha cwd chizzles) - tha calla can of
course increment tha refCount if it wishes ta maintain a cold-ass lil copy fo' longer.
.PP
\fBTcl_FSJoinToPath\fR takes tha given object, which should probably be a
valid path or NULL, n' joins onto it tha array of paths segments
given.
.PP
Returns object, typically wit refCount of zero (but it could be shared
under some conditions), containin tha joined path.  Da calla must
add a refCount ta tha object before rockin dat shit.  If any of tha objects
passed tha fuck into dis function (pathPtr or path elements) gotz a refCount
of zero, they is ghon be freed when dis function returns.
.PP
\fBTcl_FSConvertToPathType\fR tries ta convert tha given Tcl_Obj ta a valid
Tcl path type, takin account of tha fact dat tha cwd may have chizzled
even if dis object be already supposedly of tha erect type.
Da filename may begin with
.QW ~
(to indicate current userz home directory) or
.QW ~<user>
(to indicate any userz home directory).
.PP
If tha conversion succeedz (i.e. tha object be a valid path up in one of
the current filesystems), then \fBTCL_OK\fR is returned. Y'all KNOW dat shit, muthafucka!  Otherwise
\fBTCL_ERROR\fR is returned, n' a error message may
be left up in tha interpreter.
.PP
\fBTcl_FSGetInternalRep\fR extracts tha internal representation of a given
path object, up in tha given filesystem.  If tha path object belongs ta a
different filesystem, we return NULL. If tha internal representation is
currently NULL, we attempt ta generate it, by callin tha filesystem's
\fBTcl_FSCreateInternalRepProc\fR.
.PP
Returns NULL or a valid internal path representation. I aint talkin' bout chicken n' gravy biatch.  This internal
representation is cached, so dat repeated calls ta dis function will
not require additionizzle conversions.
.PP
\fBTcl_FSGetTranslatedPath\fR attempts ta extract tha translated path
from tha given Tcl_Obj.
.PP
If tha translation succeedz (i.e. tha object be a valid path), then it is
returned. Y'all KNOW dat shit, muthafucka!  Otherwise NULL is ghon be returned, n' a error message may be
left up in tha interpreter n' shit.  A
.QW translated
path is one which gotz nuff no
.QW ~
or
.QW ~user
sequences (these done been expanded ta they current
representation up in tha filesystem).  Da object returned is owned by the
caller, which must store it or call Tcl_DecrRefCount ta ensure memory is
freed. Y'all KNOW dat shit, muthafucka!  This function iz of lil practical use, and
\fBTcl_FSGetNormalizedPath\fR or \fBTcl_GetNativePath\fR is usually
betta functions ta use fo' most purposes.
.PP
\fBTcl_FSGetTranslatedStringPath\fR do tha same as
\fBTcl_FSGetTranslatedPath\fR yo, but returns a cold-ass lil characta strang or NULL.
Da strang returned is dynamically allocated n' owned by tha caller,
which must store it or call \fBckfree\fR ta ensure it is freed. Y'all KNOW dat shit, muthafucka!  Again,
\fBTcl_FSGetNormalizedPath\fR or \fBTcl_GetNativePath\fR is usually
betta functions ta use fo' most purposes.
.PP
\fBTcl_FSNewNativePath\fR performs suttin' like tha reverse of the
usual obj->path->nativerep conversions.  If some code retrieves a path
in natizzle form (from, e.g. \fBreadlink\fR or a natizzle dialog), n' dat path
is ta be used all up in tha Tcl level, then callin dis function be an
efficient way of bustin tha appropriate path object type.
.PP
Da resultin object be a pure
.QW path
object, which will only receive
a UTF-8 strang representation if dat is required by some Tcl code.
.PP
\fBTcl_FSGetNativePath\fR is fo' use by tha Win/Unix native
filesystems, so dat they can easily retrieve tha natizzle (char* or
TCHAR*) representation of a path.  This function be a cold-ass lil convenience
wrapper round \fBTcl_FSGetInternalRep\fR, n' assumes tha native
representation is string-based. Y'all KNOW dat shit, muthafucka!  It may be desirable up in tha future to
have non-string-based natizzle representations (for example, on MacOSX, a
representation rockin a gangbangin' fileSpec of FSRef structure would probably be
more efficient).  On Windows a gangbangin' full Unicode representation would allow
for pathz of unlimited length.  Currently tha representation is simply a
characta strang which may contain either tha relatizzle path or a
complete, absolute normalized path up in tha natizzle encodin (complex
conditions dictate which of these is ghon be provided, so neither can be
relied upon, unless tha path is known ta be absolute).  If you need a
natizzle path which must be absolute, then you should ask fo' tha native
version of a normalized path.  If fo' some reason a non-absolute,
non-normalized version of tha path is needed, dat must be constructed
separately (e.g. rockin \fBTcl_FSGetTranslatedPath\fR).
.PP
Da natizzle representation is cached so dat repeated calls ta this
function aint gonna require additionizzle conversions.  Da return value is
owned by Tcl n' has a gametime equivalent ta dat of tha \fIpathPtr\fR
passed up in (unless dat be a relatizzle path, up in which case tha native
representation may be freed any time tha cwd chizzles).
.PP
\fBTcl_FSFileSystemInfo\fR returns a list of two elements, n' you can put dat on yo' toast.  Da first
element is tha name of tha filesystem (e.g.
.QW natizzle ,
.QW vfs ,
.QW zip ,
or
.QW prowrap ,
like), n' tha second is tha particular type of the
given path within dat filesystem (which is filesystem dependent).  The
second element may be empty if tha filesystem do not provide a
further categorization of files.
.PP
A valid list object is returned, unless tha path object is not
recognized, when NULL is ghon be returned.
.PP
\fBTcl_FSGetFileSystemForPath\fR returns tha a pointa ta the
\fBTcl_Filesystem\fR which accepts dis path as valid.
.PP
If no filesystem will accept tha path, NULL is returned.
.PP
\fBTcl_FSGetPathType\fR determines whether tha given path is relative
to tha current directory, relatizzle ta tha current volume, or
absolute.
.PP
It returns one of \fBTCL_PATH_ABSOLUTE\fR, \fBTCL_PATH_RELATIVE\fR, or
\fBTCL_PATH_VOLUME_RELATIVE\fR
.PP
\fBTcl_AllocStatBuf\fR allocates a \fITcl_StatBuf\fR on tha system
heap (which may be deallocated by bein passed ta \fBckfree\fR.)  This
allows extensions ta invoke \fBTcl_FSStat\fR n' \fBTcl_FSLStat\fR
without bein dependent on tha size of tha buffer n' shit.  That up in turn
dependz on tha flags used ta build Tcl.
.SH "THE VIRTUAL FILESYSTEM API"
.PP
A filesystem serves up a \fBTcl_Filesystem\fR structure dat gotz nuff
pointas ta functions dat implement tha various operations on a
filesystem; these operations is invoked as needed by tha generic
layer, which generally occurs all up in tha functions listed above.
.PP
Da \fBTcl_Filesystem\fR structures is manipulated rockin tha following
methods.
.PP
\fBTcl_FSRegister\fR takes a pointa ta a gangbangin' filesystem structure n' an
optionizzle piece of data ta associated wit dat filesystem.  On calling
this function, Tcl will attach tha filesystem ta tha list of known
filesystems, n' it will become straight-up functionizzle immediately.  Tcl do
not check if tha same filesystem is registered multiple times (and in
general dat aint a phat thang ta do).  \fBTCL_OK\fR is ghon be returned.
.PP
\fBTcl_FSUnregister\fR removes tha given filesystem structure from
the list of known filesystems, if it is known, n' returns \fBTCL_OK\fR.  If
the filesystem aint currently registered, \fBTCL_ERROR\fR is returned.
.PP
\fBTcl_FSData\fR will return tha ClientData associated wit tha given
filesystem, if dat filesystem is registered. Y'all KNOW dat shit, muthafucka!  Otherwise it will
return NULL.
.PP
\fBTcl_FSMountsChanged\fR is used ta inform tha Tclz core that
the set of mount points fo' tha given (already registered) filesystem
have chizzled, n' dat cached file representations may therefore no
longer be erect.
.SS "THE TCL_FILESYSTEM STRUCTURE"
.PP
Da \fBTcl_Filesystem\fR structure gotz nuff tha followin fields:
.CS
typedef struct Tcl_Filesystem {
    const char *\fItypeName\fR;
    int \fIstructureLength\fR;
    Tcl_FSVersion \fIversion\fR;
    Tcl_FSPathInFilesystemProc *\fIpathInFilesystemProc\fR;
    Tcl_FSDupInternalRepProc *\fIdupInternalRepProc\fR;
    Tcl_FSFreeInternalRepProc *\fIfreeInternalRepProc\fR;
    Tcl_FSInternalToNormalizedProc *\fIinternalToNormalizedProc\fR;
    Tcl_FSCreateInternalRepProc *\fIcreateInternalRepProc\fR;
    Tcl_FSNormalizePathProc *\fInormalizePathProc\fR;
    Tcl_FSFilesystemPathTypeProc *\fIfilesystemPathTypeProc\fR;
    Tcl_FSFilesystemSeparatorProc *\fIfilesystemSeparatorProc\fR;
    Tcl_FSStatProc *\fIstatProc\fR;
    Tcl_FSAccessProc *\fIaccessProc\fR;
    Tcl_FSOpenFileChannelProc *\fIopenFileChannelProc\fR;
    Tcl_FSMatchInDirectoryProc *\fImatchInDirectoryProc\fR;
    Tcl_FSUtimeProc *\fIutimeProc\fR;
    Tcl_FSLinkProc *\fIlinkProc\fR;
    Tcl_FSListVolumesProc *\fIlistVolumesProc\fR;
    Tcl_FSFileAttrStringsProc *\fIfileAttrStringsProc\fR;
    Tcl_FSFileAttrsGetProc *\fIfileAttrsGetProc\fR;
    Tcl_FSFileAttrsSetProc *\fIfileAttrsSetProc\fR;
    Tcl_FSCreateDirectoryProc *\fIcreateDirectoryProc\fR;
    Tcl_FSRemoveDirectoryProc *\fIremoveDirectoryProc\fR;
    Tcl_FSDeleteFileProc *\fIdeleteFileProc\fR;
    Tcl_FSCopyFileProc *\fIcopyFileProc\fR;
    Tcl_FSRenameFileProc *\fIrenameFileProc\fR;
    Tcl_FSCopyDirectoryProc *\fIcopyDirectoryProc\fR;
    Tcl_FSLstatProc *\fIlstatProc\fR;
    Tcl_FSLoadFileProc *\fIloadFileProc\fR;
    Tcl_FSGetCwdProc *\fIgetCwdProc\fR;
    Tcl_FSChdirProc *\fIchdirProc\fR;
} Tcl_Filesystem;
.CE
.PP
Except fo' tha straight-up original gangsta three fieldz up in dis structure which contain
simple data elements, all entries contain addressez of functions called
by tha generic filesystem layer ta big-ass up tha complete range of
filesystem related actions.
.PP
Da nuff functions up in dis structure is fucked up down tha fuck into three
categories: infrastructure functions (almost all of which must be
implemented), operationizzle functions (which must be implemented if a
complete filesystem is provided), n' efficiency functions (which need
only be implemented if they can be done so efficiently, or if they have
side-effects which is required by tha filesystem; Tcl has less
efficient emulations it can fall back on).  It be blingin ta note
that, up in tha current version of Tcl, most of these fallbacks is only
used ta handle commandz initiated up in Tcl, not up in C. What dis means is,
that if a \fBfile rename\fR command is issued up in Tcl, n' tha relevant
filesystem(s) do not implement they \fITcl_FSRenameFileProc\fR, Tcl's
core will instead fallback on a cold-ass lil combination of other filesystem
functions (it will use \fITcl_FSCopyFileProc\fR followed by
\fITcl_FSDeleteFileProc\fR, n' if \fITcl_FSCopyFileProc\fR is not
implemented there be a gangbangin' further fallback).  But fuck dat shiznit yo, tha word on tha street is dat if a
\fITcl_FSRenameFileProc\fR command is issued all up in tha C level, no such
fallbacks occur. Shiiit, dis aint no joke.  This is legit except fo' tha last four entries up in the
filesystem table (\fBlstat\fR, \fBload\fR, \fBgetcwd\fR n' \fBchdir\fR)
for which fallbacks do up in fact occur all up in tha C level.
.PP
Any functions which take path names up in Tcl_Obj form take
those names up in UTF\-8 form.  Da filesystem infrastructure API is
designed ta support efficient, cached conversion of these UTF\-8 paths
to other natizzle representations.
.SS "EXAMPLE FILESYSTEM DEFINITION"
.PP
Here is tha filesystem lookup table used by the
.QW vfs
extension which allows filesystem actions ta be implemented up in Tcl.
.CS
static Tcl_Filesystem vfsFilesystem = {
    "tclvfs",
    sizeof(Tcl_Filesystem),
    TCL_FILESYSTEM_VERSION_1,
    &VfsPathInFilesystem,
    &VfsDupInternalRep,
    &VfsFreeInternalRep,
    /* No internal ta normalized, since our phat asses don't create
     * any pure 'internal' Tcl_Obj path representations */
    NULL,
    /* No create natizzle rep function, since our phat asses don't use
     * it n' don't chizzle ta support uses of
     * Tcl_FSNewNativePath */
    NULL,
    /* Normalize path aint needed - we assume paths only
     * have one representation */
    NULL,
    &VfsFilesystemPathType,
    &VfsFilesystemSeparator,
    &VfsStat,
    &VfsAccess,
    &VfsOpenFileChannel,
    &VfsMatchInDirectory,
    &VfsUtime,
    /* We chizzle not ta support symbolic links inside our
     * VFSz */
    NULL,
    &VfsListVolumes,
    &VfsFileAttrStrings,
    &VfsFileAttrsGet,
    &VfsFileAttrsSet,
    &VfsCreateDirectory,
    &VfsRemoveDirectory,
    &VfsDeleteFile,
    /* No copy file; use tha core fallback mechanizzle */
    NULL,
    /* No rename file; use tha core fallback mechanizzle */
    NULL,
    /* No copy directory; use tha core fallback mechanizzle */
    NULL,
    /* Core will use stat fo' lstat */
    NULL,
    /* No load; use tha core fallback mechanizzle */
    NULL,
    /* Us dudes don't need a getcwd or chdir; tha corez own
     * internal value is suitable */
    NULL,
    NULL
};
.CE
.SH "FILESYSTEM INFRASTRUCTURE"
.PP
These fieldz contain basic shiznit bout tha filesystem structure
and addressez of functions which is used ta associate
a particular filesystem wit a gangbangin' file path, n' deal wit tha internal
handlin of path representations, fo' example copyin n' freein such
representations.
.SS TYPENAME
.PP
Da \fItypeName\fR field gotz nuff a null-terminated strang that
identifies tha type of tha filesystem implemented, e.g.
.QW natizzle ,
.QW zip
or
.QW vfs .
.SS "STRUCTURE LENGTH"
.PP
Da \fIstructureLength\fR field is generally implemented as
\fIsizeof(Tcl_Filesystem)\fR, n' is there ta allow easier
binary backwardz compatibilitizzle if tha size of tha structure
changes up in a gangbangin' future Tcl release.
.SS VERSION
.PP
Da \fIversion\fR field should be set ta \fBTCL_FILESYSTEM_VERSION_1\fR.
.SS PATHINFILESYSTEMPROC
.PP
Da \fIpathInFilesystemProc\fR field gotz nuff tha address of a gangbangin' function
which is called ta determine whether a given path object belongs ta this
filesystem or not.  Tcl will only call tha rest of tha filesystem
functions wit a path fo' which dis function has returned \fBTCL_OK\fR.
If tha path do not belong, -1 should be returned (the behaviour of Tcl
for any other return value aint defined).  If \fBTCL_OK\fR is returned,
then tha optionizzle \fIclientDataPtr\fR output parameta can be used to
return a internal (filesystem specific) representation of tha path,
which is ghon be cached inside tha path object, n' may be retrieved
efficiently by tha other filesystem functions.  Tcl will simultaneously
cache tha fact dat dis path belongs ta dis filesystem.  Such caches
are invalidated when filesystem structures is added or removed from
Tclz internal list of known filesystems.
.PP
.CS
typedef int Tcl_FSPathInFilesystemProc(
        Tcl_Obj *\fIpathPtr\fR,
        ClientData *\fIclientDataPtr\fR);
.CE
.SS DUPINTERNALREPPROC
.PP
This function cook up a cold-ass lil copy of a pathz internal representation, n' is
called when Tcl need ta duplicate a path object.  If NULL, Tcl will
simply not copy tha internal representation, which may then need ta be
regenerated later.
.PP
.CS
typedef ClientData Tcl_FSDupInternalRepProc(
        ClientData \fIclientData\fR);
.CE
.SS FREEINTERNALREPPROC
Jacked tha internal representation. I aint talkin' bout chicken n' gravy biatch.  This must be implemented if internal
representations need freein (i.e. if some memory be allocated when an
internal representation is generated) yo, but may otherwise be NULL.
.PP
.CS
typedef void Tcl_FSFreeInternalRepProc(
        ClientData \fIclientData\fR);
.CE
.SS INTERNALTONORMALIZEDPROC
.PP
Function ta convert internal representation ta a normalized path.  Only
required if tha filesystem creates pure path objects wit no string/path
representation. I aint talkin' bout chicken n' gravy biatch.  Da return value be a Tcl object whose string
representation is tha normalized path.
.PP
.CS
typedef Tcl_Obj* Tcl_FSInternalToNormalizedProc(
        ClientData \fIclientData\fR);
.CE
.SS CREATEINTERNALREPPROC
.PP
Function ta take a path object, n' calculate a internal
representation fo' it, n' store dat natizzle representation up in the
object.  May be NULL if paths have no internal representation, or if
the \fITcl_FSPathInFilesystemProc\fR fo' dis filesystem always
immediately creates a internal representation fo' paths it accepts.
.PP
.CS
typedef ClientData Tcl_FSCreateInternalRepProc(
        Tcl_Obj *\fIpathPtr\fR);
.CE
.SS NORMALIZEPATHPROC
.PP
Function ta normalize a path.  Should be implemented fo' all
filesystems which can have multiple strang representations fo' tha same
path object.  In Tcl, every
.QW path
must gotz a single unique
.QW normalized
strin representation. I aint talkin' bout chicken n' gravy biatch.  Dependin on tha filesystem,
there may be mo' than one unnormalized strang representation which
refers ta dat path (e.g. a relatizzle path, a path wit different
characta case if tha filesystem is case insensitive, a path contain a
reference ta a home directory such as
.QW ~ ,
a path containin symbolic
links, etc).  If tha straight-up last component up in tha path be a symbolic
link, it should not be converted tha fuck into tha object it points ta (but
its case or other aspects should be made unique).  All other path
components should be converted from symbolic links.  This one
exception is required ta smoke wit Tclz semantics wit \fBfile
delete\fR, \fBfile rename\fR, \fBfile copy\fR operatin on symbolic links.
This function may be called wit \fInextCheckpoint\fR either
at tha beginnin of tha path (i.e. zero), all up in tha end of tha path, or
at any intermediate file separator up in tha path.  It will never
point ta any other arbitrary posizzle up in tha path. In tha last of
the three valid cases, tha implementation can assume dat tha path
up ta n' includin tha file separator is known n' normalized.
.PP
.CS
typedef int Tcl_FSNormalizePathProc(
        Tcl_Interp *\fIinterp\fR,
        Tcl_Obj *\fIpathPtr\fR,
        int \fInextCheckpoint\fR);
.CE
.SH "FILESYSTEM OPERATIONS"
.PP
Da fieldz up in dis section of tha structure contain addresses of
functions which is called ta carry up tha basic filesystem
operations.  A filesystem which expects ta be used wit tha complete
standard Tcl command set must implement all of these n' you can put dat on yo' toast.  If some of
them is not implemented, then certain Tcl commandz may fail when
operatin on paths within dat filesystem.  But fuck dat shiznit yo, tha word on tha street is dat up in some instances
this may be desirable (for example, a read-only filesystem should not
implement tha last four functions, n' a gangbangin' filesystem which do not
support symbolic links need not implement tha \fBreadlink\fR function,
etc.  Da Tcl core expects filesystems ta behave up in dis way).
.SS FILESYSTEMPATHTYPEPROC
.PP
Function ta determine tha type of a path up in dis filesystem.  May be
NULL, up in which case no type shiznit is ghon be available ta playas of
the filesystem.  The
.QW type
is used only fo' shiznital purposes,
and should be returned as tha strang representation of tha Tcl_Obj
which is returned. Y'all KNOW dat shit, muthafucka!  A typical return value might be
.QW networked ,
.QW zip
or
.QW ftp .
Da Tcl_Obj result is owned by tha filesystem n' so Tcl will
increment tha refCount of dat object if it wishes ta retain a reference
to dat shit.
.PP
.CS
typedef Tcl_Obj* Tcl_FSFilesystemPathTypeProc(
        Tcl_Obj *\fIpathPtr\fR);
.CE
.SS FILESYSTEMSEPARATORPROC
.PP
Function ta return tha separator character(s) fo' dis filesystem.
This need only be implemented if tha filesystem wishes ta use a
different separator than tha standard string
.QW / .
Amongst other
uses, it is returned by tha \fBfile separator\fR command. Y'all KNOW dat shit, muthafucka!  The
return value should be a object wit refCount of zero.
.PP
.CS
typedef Tcl_Obj* Tcl_FSFilesystemSeparatorProc(
        Tcl_Obj *\fIpathPtr\fR);
.CE
.SS STATPROC
.PP
Function ta process a \fBTcl_FSStat\fR call.  Must be implemented fo' any
reasonable filesystem, since nuff Tcl level commandz depend crucially
upon it (e.g. \fBfile atime\fR, \fBfile isdirectory\fR, \fBfile size\fR,
\fBglob\fR).
.PP
.CS
typedef int Tcl_FSStatProc(
        Tcl_Obj *\fIpathPtr\fR,
        Tcl_StatBuf *\fIstatPtr\fR);
.CE
.PP
Da \fBTcl_FSStatProc\fR fills tha stat structure \fIstatPtr\fR with
information bout tha specified file.  Yo ass do not need any access
rights ta tha file ta git dis shiznit but you need search rights
to all directories named up in tha path leadin ta tha file.  Da stat
structure includes info regardin device, inode (always 0 on Windows),
privilege mode, nlink (always 1 on Windows), user id (always 0 on
Windows), crew id (always 0 on Windows), rdev (same as thang on
Windows), size, last access time, last modification time, and
last metadata chizzle time.
.PP
If tha file represented by \fIpathPtr\fR exists, the
\fBTcl_FSStatProc\fR returns 0 n' tha stat structure is filled with
data.  Otherwise, -1 is returned, n' no stat info is given.
.SS ACCESSPROC
.PP
Function ta process a \fBTcl_FSAccess\fR call.  Must be implemented for
any reasonable filesystem, since nuff Tcl level commandz depend crucially
upon it (e.g. \fBfile exists\fR, \fBfile readable\fR).
.PP
.CS
typedef int Tcl_FSAccessProc(
        Tcl_Obj *\fIpathPtr\fR,
        int \fImode\fR);
.CE
.PP
Da \fBTcl_FSAccessProc\fR checks whether tha process would be allowed
to read, write or test fo' existence of tha file (or other filesystem
object) whose name is up in \fIpathPtr\fR.  If tha pathname refers ta a
symbolic link, then the
permissionz of tha file referred by dis symbolic link should be tested.
.PP
On success (all axed permissions granted), zero is returned. Y'all KNOW dat shit, muthafucka!  On
error (at least one bit up in mode axed fo' a permission dat is denied,
or some other  error occurred), -1 is returned.
.SS OPENFILECHANNELPROC
.PP
Function ta process a \fBTcl_FSOpenFileChannel\fR call.  Must be
implemented fo' any reasonable filesystem, since any operations
which require open or accessin a gangbangin' filez contents will use it
(e.g. \fBopen\fR, \fBencoding\fR, n' nuff Tk commands).
.PP
.CS
typedef Tcl_Channel Tcl_FSOpenFileChannelProc(
        Tcl_Interp *\fIinterp\fR,
        Tcl_Obj *\fIpathPtr\fR,
        int \fImode\fR,
        int \fIpermissions\fR);
.CE
.PP
Da \fBTcl_FSOpenFileChannelProc\fR opens a gangbangin' file specified by
\fIpathPtr\fR n' returns a cold-ass lil channel handle dat can be used ta perform
input n' output on tha file.  This API is modeled afta tha \fBfopen\fR
procedure of tha Unix standard I/O library.  Da syntax n' meanin of
all arguments is similar ta dem given up in tha Tcl \fBopen\fR command
when openin a gangbangin' file, where tha \fImode\fR argument be a cold-ass lil combination of
the POSIX flags O_RDONLY, O_WRONLY, etc.  If a error occurs while
openin tha channel, tha \fBTcl_FSOpenFileChannelProc\fR returns NULL and
recordz a POSIX error code dat can be retrieved wit \fBTcl_GetErrno\fR.
In addition, if \fIinterp\fR is non-NULL, the
\fBTcl_FSOpenFileChannelProc\fR leaves a error message up in \fIinterp\fR's
result afta any error.
.PP
Da newly pimped channel must not registered up in tha supplied
interpreter; dat task is up ta tha calla of
\fBTcl_FSOpenFileChannel\fR (if necessary). If one of
the standard channels, \fBstdin, stdout\fR or \fBstderr\fR was
previously closed, tha act of bustin tha freshly smoked up channel also assigns it
as a replacement fo' tha standard channel.
.SS MATCHINDIRECTORYPROC
.PP
Function ta process a \fBTcl_FSMatchInDirectory\fR call.  If not
implemented, then glob n' recursive copy functionalitizzle is ghon be lacking
in tha filesystem (and dis may impact commandz like \fBencodin names\fR
which use glob functionalitizzle internally).
.PP
.CS
typedef int Tcl_FSMatchInDirectoryProc(
        Tcl_Interp* \fIinterp\fR,
        Tcl_Obj *\fIresultPtr\fR,
        Tcl_Obj *\fIpathPtr\fR,
        const char *\fIpattern\fR,
        Tcl_GlobTypeData *\fItypes\fR);
.CE
.PP
Da function should return all filez or directories (or other filesystem
objects) which match tha given pattern n' accord wit tha \fItypes\fR
specification given. I aint talkin' bout chicken n' gravy biatch.  There is two ways up in which dis function may be
called. Y'all KNOW dat shit, muthafucka!  If \fIpattern\fR is NULL, then \fIpathPtr\fR be a gangbangin' full path
specification of a single file or directory which should be checked for
existence n' erect type.  Otherwise, \fIpathPtr\fR be a gangbangin' finger-lickin' directory, the
contentz of which tha function should search fo' filez or directories
which have tha erect type.  In either case, \fIpathPtr\fR can be
assumed ta be both non-NULL n' non-empty.  It aint currently
documented whether \fIpathPtr\fR gonna git a gangbangin' file separator at its end of
not, so code should be flexible ta both possibilities.
.PP
Da return value be a standard Tcl result indicatin whether a error
occurred up in tha matchin process.  Error lyrics is placed in
\fIinterp\fR, unless \fIinterp\fR up in NULL up in which case no error
message need be generated; on a \fBTCL_OK\fR result, thangs up in dis biatch should be 
added ta tha \fIresultPtr\fR object given (which can be assumed ta be a 
valid unshared Tcl list).  Da matches added
to \fIresultPtr\fR should include any path prefix given up in \fIpathPtr\fR
(this probably means they is ghon be absolute path justifications).
Note dat if no matches is found, dat simply leadz ta a empty
result; errors is only signaled fo' actual file or filesystem
problems which may occur durin tha matchin process.
.PP
Da \fBTcl_GlobTypeData\fR structure passed up in tha \fItypes\fR 
parameta gotz nuff tha followin fields:
.CS
typedef struct Tcl_GlobTypeData {
        /* Correspondz ta bcdpfls as up in 'find -t' */
        int \fItype\fR;
        /* Correspondz ta file permissions */
        int \fIperm\fR;
        /* Acceptable mac type */
        Tcl_Obj *\fImacType\fR;
        /* Acceptable mac creator */
        Tcl_Obj *\fImacCreator\fR;
} Tcl_GlobTypeData;
.CE
.PP
There is two specific cases which it is blingin ta handle erectly,
both when \fItypes\fR is non-NULL. Da two cases is when \fItypes->types
& TCL_GLOB_TYPE_DIR\fR or \fItypes->types & TCL_GLOB_TYPE_MOUNT\fR are
true (and up in particular when tha other flags is false).  In tha straight-up original gangsta of
these cases, tha function must list tha contained directories. Put ya muthafuckin choppers up if ya feel dis!  Tcl uses
this ta implement recursive globbing, so it is critical dat filesystems
implement directory matchin erectly.  In tha second of these cases,
with \fBTCL_GLOB_TYPE_MOUNT\fR, tha filesystem must list tha mount points
which lie within tha given \fIpathPtr\fR (and up in dis case, \fIpathPtr\fR
need not lie within tha same filesystem - different ta all other cases in
which dis function is called).  Support fo' dis is critical if Tcl is
to have seamless transitions between from one filesystem ta another.
.SS UTIMEPROC
.PP
Function ta process a \fBTcl_FSUtime\fR call.  Required ta allow setting
(not reading) of times wit \fBfile mtime\fR, \fBfile atime\fR n' the
open-r/open-w/fcopy implementation of \fBfile copy\fR.
.PP
.CS
typedef int Tcl_FSUtimeProc(
        Tcl_Obj *\fIpathPtr\fR,
        struct utimbuf *\fItval\fR);
.CE
.PP
Da access n' modification timez of tha file specified by \fIpathPtr\fR
should be chizzled ta tha joints given up in tha \fItval\fR structure.
.PP
Da return value should be 0 on success n' -1 on a error, as
with tha system \fButime\fR.
.SS LINKPROC
.PP
Function ta process a \fBTcl_FSLink\fR call.  Should be implemented
only if tha filesystem supports links, n' may otherwise be NULL.
.PP
.CS
typedef Tcl_Obj* Tcl_FSLinkProc(
        Tcl_Obj *\fIlinkNamePtr\fR,
        Tcl_Obj *\fItoPtr\fR,
        int \fIlinkAction\fR);
.CE
.PP
If \fItoPtr\fR is NULL, tha function is bein axed ta read the
contentz of a link.  Da result be a Tcl_Obj specifyin tha contents of
the link given by \fIlinkNamePtr\fR, or NULL if tha link could
not be read. Y'all KNOW dat shit, muthafucka!  Da result is owned by tha calla (and should therefore
have its ref count incremented before bein returned).  Any callers
should call Tcl_DecrRefCount on dis result when it is no longer needed.
If \fItoPtr\fR aint NULL, tha function should attempt ta create a link.
Da result up in dis case should be \fItoPtr\fR if tha link was successful
and NULL otherwise.  In dis case tha result aint owned by tha caller
(i.e. no ref count manipulation on either end is needed). Right back up in yo muthafuckin ass. See
the documentation fo' \fBTcl_FSLink\fR fo' tha erect interpretation
of tha \fIlinkAction\fR flags.
.SS LISTVOLUMESPROC
.PP
Function ta list any filesystem volumes added by dis filesystem.
Should be implemented only if tha filesystem addz volumes all up in tha head
of tha filesystem, so dat they can be returned by \fBfile volumes\fR.
.PP
.CS
typedef Tcl_Obj* Tcl_FSListVolumesProc(void);
.CE
.PP
Da result should be a list of volumes added by dis filesystem, or
NULL (or a empty list) if no volumes is provided. Y'all KNOW dat shit, muthafucka!  Da result object
is considered ta be owned by tha filesystem (not by Tclz core) yo, but
should be given a refCount fo' Tcl.  Tcl will use tha contentz of the
list n' then decrement dat refCount.  This allows filesystems to
choose whether they straight-up wanna retain a
.QW "masta list"
of volumes
or not (if not, they generate tha list on tha fly n' pass it ta Tcl
with a refCount of 1 n' then forget bout tha list, if fo'sho, then
they simply increment tha refCount of they masta list n' pass it
to Tcl which will copy tha contents n' then decrement tha count back
to where it was).
.PP
Therefore, Tcl considaz return joints from dis proc ta be read-only.
.SS FILEATTRSTRINGSPROC
.PP
Function ta list all attribute strings which is valid fo' this
filesystem.  If not implemented tha filesystem aint gonna support
the \fBfile attributes\fR command. Y'all KNOW dat shit, muthafucka!  This allows arbitrary additional
information ta be attached ta filez up in tha filesystem.  If it is
not implemented, there is no need ta implement tha \fBget\fR n' \fBset\fR
methods.
.PP
.CS
typedef const char** Tcl_FSFileAttrStringsProc(
        Tcl_Obj *\fIpathPtr\fR,
        Tcl_Obj** \fIobjPtrRef\fR);
.CE
.PP
Da called function may either return a array of strings, or may
instead return NULL n' place a Tcl list tha fuck into tha given \fIobjPtrRef\fR.  Tcl
will take dat list n' first increment its reference count before rockin dat shit.
On completion of dat use, Tcl will decrement its reference count.  Hence if
the list should be disposed of by Tcl when done, it should have a
reference count of zero, n' if tha list should not be disposed of, the
filesystem should ensure it returns a object wit a reference count
of at least one.
.SS FILEATTRSGETPROC
.PP
Function ta process a \fBTcl_FSFileAttrsGet\fR call, used by \fBfile
attributes\fR.
.PP
.CS
typedef int Tcl_FSFileAttrsGetProc(
        Tcl_Interp *\fIinterp\fR,
        int \fIindex\fR,
        Tcl_Obj *\fIpathPtr\fR,
        Tcl_Obj **\fIobjPtrRef\fR);
.CE
.PP
Returns a standard Tcl return code.  Da attribute value retrieved,
which correspondz ta tha \fIindex\fR'th element up in tha list returned by
the \fBTcl_FSFileAttrStringsProc\fR, be a Tcl_Obj placed up in \fIobjPtrRef\fR (if
\fBTCL_OK\fR was returned) n' is likely ta git a reference count of zero.  Either
way we must either store it somewhere (e.g. tha Tcl result), or
Incr/Decr its reference count ta ensure it is properly freed.
.SS FILEATTRSSETPROC
.PP
Function ta process a \fBTcl_FSFileAttrsSet\fR call, used by \fBfile
attributes\fR.  If tha filesystem is read-only, there is no need
to implement all dis bullshit.
.PP
.CS
typedef int Tcl_FSFileAttrsSetProc(
        Tcl_Interp *\fIinterp\fR,
        int \fIindex\fR,
        Tcl_Obj *\fIpathPtr\fR,
        Tcl_Obj *\fIobjPtr\fR);
.CE
.PP
Da attribute value of tha \fIindex\fR'th element up in tha list returned by
the Tcl_FSFileAttrStringsProc should be set ta tha \fIobjPtr\fR given.
.SS CREATEDIRECTORYPROC
.PP
Function ta process a \fBTcl_FSCreateDirectory\fR call.  Should be
implemented unless tha FS is read-only.
.PP
.CS
typedef int Tcl_FSCreateDirectoryProc(
        Tcl_Obj *\fIpathPtr\fR);
.CE
.PP
Da return value be a standard Tcl result indicatin whether a error
occurred up in tha process.  If successful, a freshly smoked up directory should have
been added ta tha filesystem up in tha location specified by
\fIpathPtr\fR.
.SS REMOVEDIRECTORYPROC
.PP
Function ta process a \fBTcl_FSRemoveDirectory\fR call.  Should be
implemented unless tha FS is read-only.
.PP
.CS
typedef int Tcl_FSRemoveDirectoryProc(
        Tcl_Obj *\fIpathPtr\fR,
        int \fIrecursive\fR,
        Tcl_Obj **\fIerrorPtr\fR);
.CE
.PP
Da return value be a standard Tcl result indicatin whether a error
occurred up in tha process.  If successful, tha directory specified by
\fIpathPtr\fR should done been removed from tha filesystem.  If the
\fIrecursive\fR flag is given, then a non-empty directory should be
deleted without error. Shiiit, dis aint no joke.  If dis flag aint given, then n' the
directory is non-empty a POSIX
.QW EEXIST
error should be signaled. Y'all KNOW dat shit, muthafucka!  If an
error do occur, tha name of tha file or directory which caused the
error should be placed up in \fIerrorPtr\fR.
.SS DELETEFILEPROC
.PP
Function ta process a \fBTcl_FSDeleteFile\fR call.  Should be implemented
unless tha FS is read-only.
.PP
.CS
typedef int Tcl_FSDeleteFileProc(
        Tcl_Obj *\fIpathPtr\fR);
.CE
.PP
Da return value be a standard Tcl result indicatin whether a error
occurred up in tha process.  If successful, tha file specified by
\fIpathPtr\fR should done been removed from tha filesystem.  Note that,
if tha filesystem supports symbolic links, Tcl will always call this
function n' not Tcl_FSRemoveDirectoryProc when needed ta delete them
(even if they is symbolic links ta directories).
.SH "FILESYSTEM EFFICIENCY"
.PP
These functions need not be implemented fo' a particular filesystem
because tha core has a gangbangin' fallback implementation available. Right back up in yo muthafuckin ass. See each
individual description fo' tha consequencez of leavin tha field NULL.
.SS LSTATPROC
.PP
Function ta process a \fBTcl_FSLstat\fR call.  If not implemented, Tcl
will attempt ta use tha \fIstatProc\fR defined above instead. Y'all KNOW dat shit, muthafucka!  Therefore
it need only be implemented if a gangbangin' filesystem can differentiate between
\fBstat\fR n' \fBlstat\fR calls.
.PP
.CS
typedef int Tcl_FSLstatProc(
        Tcl_Obj *\fIpathPtr\fR,
        Tcl_StatBuf *\fIstatPtr\fR);
.CE
.PP
Da behavior of dis function is straight-up similar ta dat of the
\fBTcl_FSStatProc\fR defined above, except dat if it be applied
to a symbolic link, it returns shiznit bout tha link, not
about tha target file.
.SS COPYFILEPROC
.PP
Function ta process a \fBTcl_FSCopyFile\fR call.  If not implemented Tcl
will fall back on \fBopen\fR-r, \fBopen\fR-w n' \fBfcopy\fR as a
copyin mechanism.
Therefore it need only be implemented if tha filesystem can perform
that action mo' efficiently.
.PP
.CS
typedef int Tcl_FSCopyFileProc(
        Tcl_Obj *\fIsrcPathPtr\fR,
        Tcl_Obj *\fIdestPathPtr\fR);
.CE
.PP
Da return value be a standard Tcl result indicatin whether a error
occurred up in tha copyin process.  Note that, \fIdestPathPtr\fR is the
name of tha file which should become tha copy of \fIsrcPathPtr\fR. It
is never tha name of a gangbangin' finger-lickin' directory tha fuck into which \fIsrcPathPtr\fR could be
copied (i.e. tha function is much simpla than tha Tcl level \fBfile
copy\fR subcommand).  Note that,
if tha filesystem supports symbolic links, Tcl will always call this
function n' not \fIcopyDirectoryProc\fR when needed ta copy them
(even if they is symbolic links ta directories).  Finally, if the
filesystem determines it cannot support tha \fBfile copy\fR action,
callin \fBTcl_SetErrno(EXDEV)\fR n' returnin a non-\fBTCL_OK\fR
result will tell Tcl ta use its standard fallback mechanisms.
.SS RENAMEFILEPROC
.PP
Function ta process a \fBTcl_FSRenameFile\fR call.  If not implemented,
Tcl will fall back on a cold-ass lil copy n' delete mechanism.  Therefore it need
only be implemented if tha filesystem can big-ass up dat action more
efficiently.
.PP
.CS
typedef int Tcl_FSRenameFileProc(
        Tcl_Obj *\fIsrcPathPtr\fR,
        Tcl_Obj *\fIdestPathPtr\fR);
.CE
.PP
Da return value be a standard Tcl result indicatin whether a error
occurred up in tha renamin process.  If the
filesystem determines it cannot support tha \fBfile rename\fR action,
callin \fBTcl_SetErrno(EXDEV)\fR n' returnin a non-\fBTCL_OK\fR
result will tell Tcl ta use its standard fallback mechanisms.
.SS COPYDIRECTORYPROC
.PP
Function ta process a \fBTcl_FSCopyDirectory\fR call.  If not
implemented, Tcl will fall back on a recursive \fBfile mkdir\fR, \fBfile copy\fR
mechanism.  Therefore it need only be implemented if tha filesystem can
perform dat action mo' efficiently.
.PP
.CS
typedef int Tcl_FSCopyDirectoryProc(
        Tcl_Obj *\fIsrcPathPtr\fR,
        Tcl_Obj *\fIdestPathPtr\fR,
        Tcl_Obj **\fIerrorPtr\fR);
.CE
.PP
Da return value be a standard Tcl result indicatin whether a error
occurred up in tha copyin process.  If a error do occur, tha name of
the file or directory which caused tha error should be placed in
\fIerrorPtr\fR. Note that, \fIdestPathPtr\fR is tha name of the
directory-name which should become tha mirror-image of
\fIsrcPathPtr\fR. Well shiiiit, it aint tha name of a gangbangin' finger-lickin' directory tha fuck into which
\fIsrcPathPtr\fR should be copied (i.e. tha function is much simpler
than tha Tcl level \fBfile copy\fR subcommand).  Finally, if the
filesystem determines it cannot support tha directory copy action,
callin \fBTcl_SetErrno(EXDEV)\fR n' returnin a non-\fBTCL_OK\fR
result will tell Tcl ta use its standard fallback mechanisms.
.SS LOADFILEPROC
.PP
Function ta process a \fBTcl_FSLoadFile\fR call.  If not implemented, Tcl
will fall back on a cold-ass lil copy ta native-temp followed by a \fBTcl_FSLoadFile\fR on
that temporary copy.  Therefore it need only be implemented if the
filesystem can load code directly, or it can be implemented simply to
return \fBTCL_ERROR\fR ta disable load functionalitizzle up in dis filesystem
entirely.
.PP
.CS
typedef int Tcl_FSLoadFileProc(
        Tcl_Interp *\fIinterp\fR,
        Tcl_Obj *\fIpathPtr\fR,
        Tcl_LoadHandle *\fIhandlePtr\fR,
        Tcl_FSUnloadFileProc *\fIunloadProcPtr\fR);
.CE
.PP
Returns a standard Tcl completion code.  If a error occurs, a error
message is left up in tha \fIinterp\fRz result.  Da function dynamically loadz a
binary code file tha fuck into memory.  On a successful load, tha \fIhandlePtr\fR
should be filled wit a token fo' tha dynamically loaded file, n' the
\fIunloadProcPtr\fR should be filled up in wit tha address of a procedure.
Da unload procedure is ghon be called wit tha given \fBTcl_LoadHandle\fR as its
only parameta when Tcl need ta unload tha file.  For example, fo' the
natizzle filesystem, tha \fBTcl_LoadHandle\fR returned is currently a token
which can be used up in tha private \fBTclpFindSymbol\fR ta access functions
in tha freshly smoked up code.  Each filesystem is free ta define the
\fBTcl_LoadHandle\fR as it requires.  Finally, if the
filesystem determines it cannot support tha file load action,
callin \fBTcl_SetErrno(EXDEV)\fR n' returnin a non-\fBTCL_OK\fR
result will tell Tcl ta use its standard fallback mechanisms.
.SS UNLOADFILEPROC
.PP
Function ta unload a previously successfully loaded file.  If load was
implemented, then dis should also be implemented, if there be any
cleanup action required.
.PP
.CS
typedef void Tcl_FSUnloadFileProc(
        Tcl_LoadHandle \fIloadHandle\fR);
.CE
.SS GETCWDPROC     
.PP
Function ta process a \fBTcl_FSGetCwd\fR call.  Most filesystems need not
implement all dis bullshit.  It will probably only be called once, if \fBgetcwd\fR is
called before \fBchdir\fR.  May be NULL.
.PP
.CS
typedef Tcl_Obj* Tcl_FSGetCwdProc(
        Tcl_Interp *\fIinterp\fR);
.CE
.PP
If tha filesystem supports a natizzle notion of a cold-ass lil current working
directory (which might like chizzle independent of Tcl), this
function should return dat cwd as tha result, or NULL if tha current
directory could not be determined (e.g. tha user do not have
appropriate permissions on tha cwd directory).  If NULL is returned, an
error message is left up in tha \fIinterp\fRz result.
.SS CHDIRPROC
.PP
Function ta process a \fBTcl_FSChdir\fR call.  If filesystems do not
implement this, it is ghon be emulated by a seriez of directory access
checks.  Otherwise, virtual filesystems which do implement it need only
respond wit a positizzle return result if tha \fIpathPtr\fR be a valid,
accessible directory up in they filesystem.  They need not remember the
result, since dat is ghon be automatically remembered fo' use by
\fBTcl_FSGetCwd\fR.
Real filesystems should carry up tha erect action (i.e. call the
correct system \fBchdir\fR API).
.PP
.CS
typedef int Tcl_FSChdirProc(
        Tcl_Obj *\fIpathPtr\fR);
.CE
.PP
Da \fBTcl_FSChdirProc\fR chizzlez tha applications current working
directory ta tha value specified up in \fIpathPtr\fR. Da function returns
-1 on error or 0 on success.
.SH "SEE ALSO"
cd(n), file(n), load(n), open(n), pwd(n), unload(n)
.SH KEYWORDS
stat, access, filesystem, vfs, virtual
