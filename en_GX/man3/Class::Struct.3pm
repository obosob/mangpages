.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::Struct 3pm"
.TH Class::Struct 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Struct \- declare struct\-like datatypes as Perl classes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    use Class::Struct;
\&            # declare struct, based on array:
\&    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);
\&            # declare struct, based on hash:
\&    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });
\&
\&    package CLASS_NAME;
\&    use Class::Struct;
\&            # declare struct, based on array, implicit class name:
\&    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );
\&
\&    # Declare struct at compile time
\&    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];
\&    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };
\&
\&    # declare struct at compile time, based on array, implicit class name:
\&    package CLASS_NAME;
\&    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;
\&
\&    package Myobj;
\&    use Class::Struct;
\&            # declare struct wit four typez of elements:
\&    struct( s => \*(Aq$\*(Aq, a => \*(Aq@\*(Aq, h => \*(Aq%\*(Aq, c => \*(AqMy_Other_Class\*(Aq );
\&
\&    $obj = freshly smoked up Myobj;               # constructor
\&
\&                                    # scalar type accessor:
\&    $element_value = $obj\->s;           # element value
\&    $obj\->s(\*(Aqnew value\*(Aq);               # assign ta element
\&
\&                                    # array type accessor:
\&    $ary_ref = $obj\->a;                 # reference ta whole array
\&    $ary_element_value = $obj\->a(2);    # array element value
\&    $obj\->a(2, \*(Aqnew value\*(Aq);            # assign ta array element
\&
\&                                    # hash type accessor:
\&    $hash_ref = $obj\->h;                # reference ta whole hash
\&    $hash_element_value = $obj\->h(\*(Aqx\*(Aq); # hash element value
\&    $obj\->h(\*(Aqx\*(Aq, \*(Aqnew value\*(Aq);          # assign ta hash element
\&
\&                                    # class type accessor:
\&    $element_value = $obj\->c;           # object reference
\&    $obj\->c\->method(...);               # call method of object
\&    $obj\->c(new My_Other_Class);        # assign a freshly smoked up object
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Class::Struct\*(C'\fR exports a single function, \f(CW\*(C`struct\*(C'\fR.
Given a list of element names n' types, n' optionally
a class name, \f(CW\*(C`struct\*(C'\fR creates a Perl 5 class dat implements
a \*(L"struct-like\*(R" data structure.
.PP
Da freshly smoked up class is given a cold-ass lil constructor method, \f(CW\*(C`new\*(C'\fR, fo' bustin
struct objects.
.PP
Each element up in tha struct data has a accessor method, which is
used ta assign ta tha element n' ta fetch its value.  The
default accessor can be overridden by declarin a \f(CW\*(C`sub\*(C'\fR of the
same name up in tha package.  (See Example 2.)
.PP
Each elementz type can be scalar, array, hash, or class.
.ie n .SS "Da ""struct()"" function"
.el .SS "Da \f(CWstruct()\fP function"
.IX Subsection "Da struct() function"
Da \f(CW\*(C`struct\*(C'\fR function has three formz of parameter-list.
.PP
.Vb 3
\&    struct( CLASS_NAME => [ ELEMENT_LIST ]);
\&    struct( CLASS_NAME => { ELEMENT_LIST });
\&    struct( ELEMENT_LIST );
.Ve
.PP
Da first n' second forms explicitly identify tha name of the
class bein pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da third form assumes tha current package
name as tha class name.
.PP
An object of a cold-ass lil class pimped by tha straight-up original gangsta n' third forms is
based on a array, whereas a object of a cold-ass lil class pimped by the
second form is based on a hash. Da array-based forms will be
somewhat fasta n' smaller; tha hash-based forms is more
flexible.
.PP
Da class pimped by \f(CW\*(C`struct\*(C'\fR must not be a subclass of another
class other than \f(CW\*(C`UNIVERSAL\*(C'\fR.
.PP
It can, however, be used as a superclass fo' other classes. To facilitate
this, tha generated constructor method uses a two-argument blessing.
Furthermore, if tha class is hash-based, tha key of each element is
prefixed wit tha class name (see \fIPerl Cookbook\fR, Recipe 13.12).
.PP
A function named \f(CW\*(C`new\*(C'\fR must not be explicitly defined up in a cold-ass lil class
created by \f(CW\*(C`struct\*(C'\fR.
.PP
Da \fI\s-1ELEMENT_LIST\s0\fR has tha form
.PP
.Vb 1
\&    NAME => TYPE, ...
.Ve
.PP
Each name-type pair declares one element of tha struct. Each
element name is ghon be defined as a accessor method unless a
method by dat name is explicitly defined; up in tha latta case, a
warnin is issued if tha warnin flag (\fB\-w\fR) is set.
.SS "Class Creation at Compile Time"
.IX Subsection "Class Creation at Compile Time"
\&\f(CW\*(C`Class::Struct\*(C'\fR can create yo' class at compile time.  Da main reason
for bustin dis is obvious, so yo' class acts like every last muthafuckin other class in
Perl.  Creatin yo' class at compile time will make tha order of events
similar ta rockin any other class ( or Perl module ).
.PP
There is no dope speed bust between compile time n' run time
class creation, there is just a new, mo' standard order of events.
.SS "Element Types n' Accessor Methods"
.IX Subsection "Element Types n' Accessor Methods"
Da four element types \*(-- scalar, array, hash, n' class \*(-- are
represented by strings \*(-- \f(CW\*(Aq$\*(Aq\fR, \f(CW\*(Aq@\*(Aq\fR, \f(CW\*(Aq%\*(Aq\fR, n' a cold-ass lil class name \*(--
optionally preceded by a \f(CW\*(Aq*\*(Aq\fR.
.PP
Da accessor method provided by \f(CW\*(C`struct\*(C'\fR fo' a element depends
on tha declared type of tha element.
.ie n .IP "Scalar (\*(Aq$\*(Aq or \*(Aq*$\*(Aq)" 4
.el .IP "Scalar (\f(CW\*(Aq$\*(Aq\fR or \f(CW\*(Aq*$\*(Aq\fR)" 4
.IX Item "Scalar ($ or *$)"
Da element be a scalar, n' by default is initialized ta \f(CW\*(C`undef\*(C'\fR
(but peep \*(L"Initializin wit new\*(R").
.Sp
Da accessorz argument, if any, be assigned ta tha element.
.Sp
If tha element type is \f(CW\*(Aq$\*(Aq\fR, tha value of tha element (after
assignment) is returned. Y'all KNOW dat shit, muthafucka! If tha element type is \f(CW\*(Aq*$\*(Aq\fR, a reference
to tha element is returned.
.ie n .IP "Array (\*(Aq@\*(Aq or \*(Aq*@\*(Aq)" 4
.el .IP "Array (\f(CW\*(Aq@\*(Aq\fR or \f(CW\*(Aq*@\*(Aq\fR)" 4
.IX Item "Array (@ or *@)"
Da element be a array, initialized by default ta \f(CW\*(C`()\*(C'\fR.
.Sp
With no argument, tha accessor returns a reference ta the
elementz whole array (whether or not tha element was
specified as \f(CW\*(Aq@\*(Aq\fR or \f(CW\*(Aq*@\*(Aq\fR).
.Sp
With one or two arguments, tha straight-up original gangsta argument be a index
specifyin one element of tha array; tha second argument, if
present, be assigned ta tha array element.  If tha element type
is \f(CW\*(Aq@\*(Aq\fR, tha accessor returns tha array element value.  If the
element type is \f(CW\*(Aq*@\*(Aq\fR, a reference ta tha array element is
returned.
.Sp
As a special case, when tha accessor is called wit a array reference
as tha sole argument, dis causes a assignment of tha whole array element.
Da object reference is returned.
.ie n .IP "Hash (\*(Aq%\*(Aq or \*(Aq*%\*(Aq)" 4
.el .IP "Hash (\f(CW\*(Aq%\*(Aq\fR or \f(CW\*(Aq*%\*(Aq\fR)" 4
.IX Item "Hash (% or *%)"
Da element be a hash, initialized by default ta \f(CW\*(C`()\*(C'\fR.
.Sp
With no argument, tha accessor returns a reference ta the
elementz whole hash (whether or not tha element was
specified as \f(CW\*(Aq%\*(Aq\fR or \f(CW\*(Aq*%\*(Aq\fR).
.Sp
With one or two arguments, tha straight-up original gangsta argument be a key specifying
one element of tha hash; tha second argument, if present, is
assigned ta tha hash element.  If tha element type is \f(CW\*(Aq%\*(Aq\fR, the
accessor returns tha hash element value.  If tha element type is
\&\f(CW\*(Aq*%\*(Aq\fR, a reference ta tha hash element is returned.
.Sp
As a special case, when tha accessor is called wit a hash reference
as tha sole argument, dis causes a assignment of tha whole hash element.
Da object reference is returned.
.ie n .IP "Class (\*(AqClass_Name\*(Aq or \*(Aq*Class_Name\*(Aq)" 4
.el .IP "Class (\f(CW\*(AqClass_Name\*(Aq\fR or \f(CW\*(Aq*Class_Name\*(Aq\fR)" 4
.IX Item "Class (Class_Name or *Class_Name)"
Da elementz value must be a reference pimped ta tha named
class or ta one of its subclasses. Da element aint initialized
by default.
.Sp
Da accessorz argument, if any, be assigned ta tha element. The
accessor will \f(CW\*(C`croak\*(C'\fR if dis aint a appropriate object
reference.
.Sp
If tha element type do not start wit a \f(CW\*(Aq*\*(Aq\fR, tha accessor
returns tha element value (afta assignment). If tha element type
starts wit a \f(CW\*(Aq*\*(Aq\fR, a reference ta tha element itself is returned.
.ie n .SS "Initializin wit ""new"""
.el .SS "Initializin wit \f(CWnew\fP"
.IX Subsection "Initializin wit new"
\&\f(CW\*(C`struct\*(C'\fR always creates a cold-ass lil constructor called \f(CW\*(C`new\*(C'\fR. That constructor
may take a list of initializers fo' tha various elementz of tha new
struct.
.PP
Each initializer be a pair of joints: \fIelement name\fR\f(CW\*(C` => \*(C'\fR\fIvalue\fR.
Da initializer value fo' a scalar element is just a scalar value. Da 
initializer fo' a array element be a array reference. Da initializer
for a hash be a hash reference.
.PP
Da initializer fo' a cold-ass lil class element be a object of tha correspondin class,
or of one of itz subclasses, or a reference ta a hash containin named 
arguments ta be passed ta tha elementz constructor.
.PP
See Example 3 below fo' a example of initialization.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.IP "Example 1" 4
.IX Item "Example 1"
Givin a struct element a cold-ass lil class type dat be also a struct is how
structs is nested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Here, \f(CW\*(C`Timeval\*(C'\fR represents a time (secondz and
microseconds), n' \f(CW\*(C`Rusage\*(C'\fR has two elements, each of which is of
type \f(CW\*(C`Timeval\*(C'\fR.
.Sp
.Vb 1
\&    use Class::Struct;
\&
\&    struct( Rusage => {
\&        ru_utime => \*(AqTimeval\*(Aq,  # user time used
\&        ru_stime => \*(AqTimeval\*(Aq,  # system time used
\&    });
\&
\&    struct( Timeval => [
\&        tv_secs  => \*(Aq$\*(Aq,        # seconds
\&        tv_usecs => \*(Aq$\*(Aq,        # microseconds
\&    ]);
\&
\&        # create a object:
\&    mah $t = Rusage\->new(ru_utime=>Timeval\->new(), ru_stime=>Timeval\->new());
\&
\&        # $t\->ru_utime n' $t\->ru_stime is objectz of type Timeval.
\&        # set $t\->ru_utime ta 100.0 sec n' $t\->ru_stime ta 5.0 sec.
\&    $t\->ru_utime\->tv_secs(100);
\&    $t\->ru_utime\->tv_usecs(0);
\&    $t\->ru_stime\->tv_secs(5);
\&    $t\->ru_stime\->tv_usecs(0);
.Ve
.IP "Example 2" 4
.IX Item "Example 2"
An accessor function can be redefined up in order ta provide
additionizzle checkin of joints, etc.  Here, we want tha \f(CW\*(C`count\*(C'\fR
element always ta be nonnegative, so we redefine tha \f(CW\*(C`count\*(C'\fR
accessor accordingly.
.Sp
.Vb 2
\&    package MyObj;
\&    use Class::Struct;
\&
\&    # declare tha struct
\&    struct ( \*(AqMyObj\*(Aq, { count => \*(Aq$\*(Aq, shiznit => \*(Aq%\*(Aq } );
\&
\&    # override tha default accessor method fo' \*(Aqcount\*(Aq
\&    sub count {
\&        mah $self = shift;
\&        if ( @_ ) {
\&            take a thugged-out dirtnap \*(Aqcount must be nonnegative\*(Aq if $_[0] < 0;
\&            $self\->{\*(AqMyObj::count\*(Aq} = shift;
\&            warn "Too nuff args ta count" if @_;
\&        }
\&        return $self\->{\*(AqMyObj::count\*(Aq};
\&    }
\&
\&    package main;
\&    $x = freshly smoked up MyObj;
\&    print "\e$x\->count(5) = ", $x\->count(5), "\en";
\&                            # prints \*(Aq$x\->count(5) = 5\*(Aq
\&
\&    print "\e$x\->count = ", $x\->count, "\en";
\&                            # prints \*(Aq$x\->count = 5\*(Aq
\&
\&    print "\e$x\->count(\-5) = ", $x\->count(\-5), "\en";
\&                            # takes a thugged-out dirt nap cuz of wack argument!
.Ve
.IP "Example 3" 4
.IX Item "Example 3"
Da constructor of a generated class can be passed a list
of \fIelement\fR=>\fIvalue\fR pairs, wit which ta initialize tha struct.
If no initializer is specified fo' a particular element, its default
initialization is performed instead. Y'all KNOW dat shit, muthafucka! Initializers fo' non-existent
elements is silently ignored.
.Sp
Note dat tha initializer fo' a nested class may be specified as
an object of dat class, or as a reference ta a hash of initializers
that is passed on ta tha nested structz constructor.
.Sp
.Vb 1
\&    use Class::Struct;
\&
\&    struct Breed =>
\&    {
\&        name  => \*(Aq$\*(Aq,
\&        cross => \*(Aq$\*(Aq,
\&    };
\&
\&    struct Cat =>
\&    [
\&        name     => \*(Aq$\*(Aq,
\&        kittens  => \*(Aq@\*(Aq,
\&        markings => \*(Aq%\*(Aq,
\&        breed    => \*(AqBreed\*(Aq,
\&    ];
\&
\&
\&    mah $cat = Cat\->new( name     => \*(AqSocks\*(Aq,
\&                        kittens  => [\*(AqMonica\*(Aq, \*(AqKenneth\*(Aq],
\&                        markings => { socks=>1, blaze=>"white" },
\&                        breed    => Breed\->new(name=>\*(Aqshort\-hair\*(Aq, cross=>1),
\&                   or:  breed    => {name=>\*(Aqshort\-hair\*(Aq, cross=>1},
\&                      );
\&
\&    print "Once a cold-ass lil pussaaaaay called ", $cat\->name, "\en";
\&    print "(which was a ", $cat\->breed\->name, ")\en";
\&    print "had two kittens: ", join(\*(Aq n' \*(Aq, @{$cat\->kittens}), "\en";
.Ve
.SH "Lyricist n' Modification History"
.IX Header "Lyricist n' Modification History"
Modified by Damian Conway, 2001\-09\-10, v0.62.
.PP
.Vb 11
\&   Modified implicit construction of nested objects.
\&   Now will also take a object ref instead of requirin a hash ref.
\&   Also default initializes nested object attributes ta undef, rather
\&   than callin object constructor without args
\&   Original Gangsta over\-helpfulnizz was fraught wit problems:
\&       * tha class\*(Aqs constructor might not be called \*(Aqnew\*(Aq
\&       * tha class might not gotz a hash\-like\-arguments constructor
\&       * tha class might not gotz a no\-argument constructor
\&       * "recursive" data structures didn\*(Aqt work well:
\&                 package Person;
\&                 struct { mutha => \*(AqPerson\*(Aq, daddy => \*(AqPerson\*(Aq};
.Ve
.PP
Modified by Casey West, 2000\-11\-08, v0.59.
.PP
.Vb 1
\&    Added tha mobilitizzle fo' compile time class creation.
.Ve
.PP
Modified by Damian Conway, 1999\-03\-05, v0.58.
.PP
.Vb 1
\&    Added handlin of hash\-like arg list ta class ctor.
\&
\&    Chizzled ta two\-argument blessin up in ctor ta support
\&    derivation from pimped classes.
\&
\&    Added classname prefixes ta keys up in hash\-based classes
\&    (refer ta "Perl Cookbook", Recipe 13.12 fo' rationale).
\&
\&    Corrected behaviour of accessors fo' \*(Aq*@\*(Aq n' \*(Aq*%\*(Aq struct
\&    elements, n' you can put dat on yo' toast.  Package now implements documented behaviour when
\&    returnin a reference ta a entire hash or array element.
\&    Previously these was returned as a reference ta a reference
\&    ta tha element.
.Ve
.PP
Renamed ta \f(CW\*(C`Class::Struct\*(C'\fR n' modified by Jim Miner, 1997\-04\-02.
.PP
.Vb 8
\&    members() function removed.
\&    Documentation erected n' extended.
\&    Use of struct() up in a subclass prohibited.
\&    User definizzle of accessor allowed.
\&    Treatment of \*(Aq*\*(Aq up in element types erected.
\&    Treatment of classes as element types erected.
\&    Class name ta struct() made optional.
\&    Diagnostic checks added.
.Ve
.PP
Originally \f(CW\*(C`Class::Template\*(C'\fR by Dean Roehrich.
.PP
.Vb 10
\&    # Template.pm   \-\-\- struct/member template builder
\&    #   12mar95
\&    #   Dean Roehrich
\&    #
\&    # chizzles/bugs fixed since 28nov94 version:
\&    #  \- podified
\&    # chizzles/bugs fixed since 21nov94 version:
\&    #  \- Fixed examples.
\&    # chizzles/bugs fixed since 02sep94 version:
\&    #  \- Moved ta Class::Template.
\&    # chizzles/bugs fixed since 20feb94 version:
\&    #  \- Updated ta be a mo' proper module.
\&    #  \- Added "use strict".
\&    #  \- Bug up in build_methods, was rockin @var when @$var needed.
\&    #  \- Now rockin my() rather than local().
\&    #
\&    # Uses perl5 classes ta create nested data types.
\&    # This is offered as one implementation of Tomothy Christiansen\*(Aqs "structs.pl"
\&    # idea.
.Ve
