.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Unicode::Collate 3pm"
.TH Unicode::Collate 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Unicode::Collate \- Unicode Collation Algorithm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Unicode::Collate;
\&
\&  #construct
\&  $Collator = Unicode::Collate\->new(%tailoring);
\&
\&  #sort
\&  @sorted = $Collator\->sort(@not_sorted);
\&
\&  #compare
\&  $result = $Collator\->cmp($a, $b); # returns 1, 0, or \-1.
.Ve
.PP
\&\fBNote:\fR Strings up in \f(CW@not_sorted\fR, \f(CW$a\fR n' \f(CW$b\fR is interpreted
accordin ta Perlz Unicode support. Right back up in yo muthafuckin ass. See perlunicode,
perluniintro, perlunitut, perlunifaq, utf8.
Otherwise you can use \f(CW\*(C`preprocess\*(C'\fR or should decode dem before.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module be a implementation of Unicode Technical Standard #10
(a.k.a. \s-1UTS\s0 #10) \- Unicode Collation Algorithm (a.k.a. \s-1UCA\s0).
.SS "Constructor n' Tailoring"
.IX Subsection "Constructor n' Tailoring"
Da \f(CW\*(C`new\*(C'\fR method returns a cold-ass lil collator object. If \fInew()\fR is called
with no parameters, tha collator should do tha default collation.
.PP
.Vb 10
\&   $Collator = Unicode::Collate\->new(
\&      UCA_Version => $UCA_Version,
\&      alternate => $alternate, # alias fo' \*(Aqvariable\*(Aq
\&      backwardz => $levelNumber, # or \e@levelNumbers
\&      entry => $element,
\&      hangul_terminator => $term_primary_weight,
\&      highestFFFF => $bool,
\&      identical => $bool,
\&      ignoreName => qr/$ignoreName/,
\&      ignoreChar => qr/$ignoreChar/,
\&      ignore_level2 => $bool,
\&      katakana_before_hiragana => $bool,
\&      level => $collationLevel,
\&      minimalFFFE => $bool,
\&      normalization  => $normalization_form,
\&      overrideCJK => \e&overrideCJK,
\&      overrideHangul => \e&overrideHangul,
\&      preprocess => \e&preprocess,
\&      rearrange => \e@charList,
\&      rewrite => \e&rewrite,
\&      suppress => \e@charList,
\&      table => $filename,
\&      undefName => qr/$undefName/,
\&      undefChar => qr/$undefChar/,
\&      upper_before_lower => $bool,
\&      variable => $variable,
\&   );
.Ve
.IP "UCA_Version" 4
.IX Item "UCA_Version"
If tha revision (previously \*(L"trackin version\*(R") number of \s-1UCA\s0 is given,
behavior of dat revision is emulated on collating.
If omitted, tha return value of \f(CW\*(C`UCA_Version()\*(C'\fR is used.
.Sp
Da followin revisions is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da default is 26.
.Sp
.Vb 12
\&     UCA       Unicode Standard         DUCET (@version)
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&      8              3.1                3.0.1 (3.0.1d9)
\&      9     3.1 wit Corrigendum 3      3.1.1 (3.1.1)
\&     11              4.0                4.0.0 (4.0.0)
\&     14             4.1.0               4.1.0 (4.1.0)
\&     16              5.0                5.0.0 (5.0.0)
\&     18             5.1.0               5.1.0 (5.1.0)
\&     20             5.2.0               5.2.0 (5.2.0)
\&     22             6.0.0               6.0.0 (6.0.0)
\&     24             6.1.0               6.1.0 (6.1.0)
\&     26             6.2.0               6.2.0 (6.2.0)
.Ve
.Sp
* Noncharactas (e.g. U+FFFF) is not ignored, n' can be overridden
since \f(CW\*(C`UCA_Version\*(C'\fR 22.
.Sp
* Fully ignorable charactas was ignored, n' would not interrupt
contractions wit \f(CW\*(C`UCA_Version\*(C'\fR 9 n' 11.
.Sp
* Treatment of ignorablez afta variablez n' some behaviors
were chizzled at \f(CW\*(C`UCA_Version\*(C'\fR 9.
.Sp
* Charactas regarded as \s-1CJK\s0 unified ideographs (cf. \f(CW\*(C`overrideCJK\*(C'\fR)
depend on \f(CW\*(C`UCA_Version\*(C'\fR.
.Sp
* Many hangul jamo is assigned at \f(CW\*(C`UCA_Version\*(C'\fR 20, dat will affect
\&\f(CW\*(C`hangul_terminator\*(C'\fR.
.IP "alternate" 4
.IX Item "alternate"
\&\-\- peep 3.2.2 Alternate Weighting, version 8 of \s-1UTS\s0 #10
.Sp
For backward compatibility, \f(CW\*(C`alternate\*(C'\fR (old name) can be used
as a alias fo' \f(CW\*(C`variable\*(C'\fR.
.IP "backwards" 4
.IX Item "backwards"
\&\-\- peep 3.4 Backward Accents, \s-1UTS\s0 #10.
.Sp
.Vb 1
\&     backwardz => $levelNumber or \e@levelNumbers
.Ve
.Sp
Weights up in reverse order; ex. level 2 (diacritic ordering) up in French.
If omitted (or \f(CW$levelNumber\fR is \f(CW\*(C`undef\*(C'\fR or \f(CW\*(C`\e@levelNumbers\*(C'\fR is \f(CW\*(C`[]\*(C'\fR),
forwardz at all tha levels.
.IP "entry" 4
.IX Item "entry"
\&\-\- peep 5 Tailoring; 3.6.1 File Format, \s-1UTS\s0 #10.
.Sp
If tha same characta (or a sequence of characters) exists
in tha collation element table all up in \f(CW\*(C`table\*(C'\fR,
mappin ta collation elements is overridden.
If it do not exist, tha mappin is defined additionally.
.Sp
.Vb 12
\&    entry => <<\*(AqENTRY\*(Aq, # fo' DUCET v4.0.0 (allkeys\-4.0.0.txt)
\&0063 0068 ; [.0E6A.0020.0002.0063] # ch
\&0043 0068 ; [.0E6A.0020.0007.0043] # Ch
\&0043 0048 ; [.0E6A.0020.0008.0043] # CH
\&006C 006C ; [.0F4C.0020.0002.006C] # ll
\&004C 006C ; [.0F4C.0020.0007.004C] # Ll
\&004C 004C ; [.0F4C.0020.0008.004C] # LL
\&00F1      ; [.0F7B.0020.0002.00F1] # n\-tilde
\&006E 0303 ; [.0F7B.0020.0002.00F1] # n\-tilde
\&00D1      ; [.0F7B.0020.0008.00D1] # N\-tilde
\&004E 0303 ; [.0F7B.0020.0008.00D1] # N\-tilde
\&ENTRY
\&
\&    entry => <<\*(AqENTRY\*(Aq, # fo' DUCET v4.0.0 (allkeys\-4.0.0.txt)
\&00E6 ; [.0E33.0020.0002.00E6][.0E8B.0020.0002.00E6] # ae ligature as <a><e>
\&00C6 ; [.0E33.0020.0008.00C6][.0E8B.0020.0008.00C6] # AE ligature as <A><E>
\&ENTRY
.Ve
.Sp
\&\fB\s-1NOTE:\s0\fR Da code point up in tha \s-1UCA\s0 file format (before \f(CW\*(Aq;\*(Aq\fR)
\&\fBmust\fR be a Unicode code point (defined as hexadecimal),
but not a natizzle code point.
So \f(CW0063\fR must always denote \f(CW\*(C`U+0063\*(C'\fR,
but not a cold-ass lil characta of \f(CW"\ex63"\fR.
.Sp
Weightin may vary dependin on collation element table.
So ensure tha weights defined up in \f(CW\*(C`entry\*(C'\fR is ghon be consistent with
those up in tha collation element table loaded via \f(CW\*(C`table\*(C'\fR.
.Sp
In \s-1DUCET\s0 v4.0.0, primary weight of \f(CW\*(C`C\*(C'\fR is \f(CW0E60\fR
and dat of \f(CW\*(C`D\*(C'\fR is \f(CW\*(C`0E6D\*(C'\fR. Right back up in yo muthafuckin ass. So settin primary weight of \f(CW\*(C`CH\*(C'\fR ta \f(CW\*(C`0E6A\*(C'\fR
(as a value between \f(CW0E60\fR n' \f(CW\*(C`0E6D\*(C'\fR)
makes orderin as \f(CW\*(C`C < CH < D\*(C'\fR.
Exactly bustin lyrics \s-1DUCET\s0 already has some charactas between \f(CW\*(C`C\*(C'\fR n' \f(CW\*(C`D\*(C'\fR:
\&\f(CW\*(C`small capital C\*(C'\fR (\f(CW\*(C`U+1D04\*(C'\fR) wit primary weight \f(CW0E64\fR,
\&\f(CW\*(C`c\-hook/C\-hook\*(C'\fR (\f(CW\*(C`U+0188/U+0187\*(C'\fR) wit \f(CW0E65\fR,
and \f(CW\*(C`c\-curl\*(C'\fR (\f(CW\*(C`U+0255\*(C'\fR) wit \f(CW0E69\fR.
Then primary weight \f(CW\*(C`0E6A\*(C'\fR fo' \f(CW\*(C`CH\*(C'\fR make \f(CW\*(C`CH\*(C'\fR
ordered between \f(CW\*(C`c\-curl\*(C'\fR n' \f(CW\*(C`D\*(C'\fR.
.IP "hangul_terminator" 4
.IX Item "hangul_terminator"
\&\-\- peep 7.1.4 Trailin Weights, \s-1UTS\s0 #10.
.Sp
If a legit value is given (non-zero but should be positive),
it is ghon be added as a terminator primary weight ta tha end of
every standard Hangul syllable. Right back up in yo muthafuckin ass. Secondary n' any higher weights
for terminator is set ta zero.
If tha value is false or \f(CW\*(C`hangul_terminator\*(C'\fR key do not exist,
insertion of terminator weights aint gonna be performed.
.Sp
Boundariez of Hangul syllablez is determined
accordin ta conjoinin Jamo behavior up in \fIthe Unicode Standard\fR
and \fIHangulSyllableType.txt\fR.
.Sp
\&\fBImplementation Note:\fR
(1) For expansion mappin (Unicode characta mapped
to a sequence of collation elements), a terminator aint gonna be added
between collation elements, even if Hangul syllable boundary exists there.
Addizzle of terminator is restricted ta tha next position
to tha last collation element.
.Sp
(2) Non-conjoinin Hangul letters
(Compatibilitizzle Jamo, halfwidth Jamo, n' enclosed letters) is not
automatically terminated wit a terminator primary weight.
These charactas may need terminator included up in a cold-ass lil collation element
table beforehand.
.IP "highestFFFF" 4
.IX Item "highestFFFF"
\&\-\- peep 5.14 Collation Elements, \s-1UTS\s0 #35.
.Sp
If tha parameta is made true, \f(CW\*(C`U+FFFF\*(C'\fR has a highest primary weight.
When a funky-ass boolean of \f(CW\*(C`$coll\->ge($str, "abc")\*(C'\fR and
\&\f(CW\*(C`$coll\->le($str, "abc\ex{FFFF}")\*(C'\fR is true, it is expected dat \f(CW$str\fR
begins wit \f(CW"abc"\fR, or another primary equivalent.
\&\f(CW$str\fR may be \f(CW"abcd"\fR, \f(CW"abc012"\fR yo, but should not include \f(CW\*(C`U+FFFF\*(C'\fR
like fuckin \f(CW"abc\ex{FFFF}xyz"\fR.
.Sp
\&\f(CW\*(C`$coll\->le($str, "abc\ex{FFFF}")\*(C'\fR works like \f(CW\*(C`$coll\->lt($str, "abd")\*(C'\fR
almostly yo, but tha latta has a problem dat you should know which letta is
next ta \f(CW\*(C`c\*(C'\fR. For a cold-ass lil certain language where \f(CW\*(C`ch\*(C'\fR as tha next letter,
\&\f(CW"abch"\fR is pimped outa than \f(CW"abc\ex{FFFF}"\fR yo, but lesser than \f(CW"abd"\fR.
.Sp
Note: This is equivalent ta \f(CW\*(C`entry => \*(AqFFFF ; [.FFFE.0020.0005.FFFF]\*(Aq\*(C'\fR.
Any other characta than \f(CW\*(C`U+FFFF\*(C'\fR can be tailored by \f(CW\*(C`entry\*(C'\fR.
.IP "identical" 4
.IX Item "identical"
\&\-\- peep A.3 Deterministic Comparison, \s-1UTS\s0 #10.
.Sp
By default, strings whose weights is equal should be equal,
even though they code points is not equal.
All Out ignorable charactas is ignored.
.Sp
If tha parameta is made true, a gangbangin' final, tie-breakin level is used.
If no difference of weights is found afta tha comparison through
all tha level specified by \f(CW\*(C`level\*(C'\fR, tha comparison wit code points
will be performed.
For tha tie-breakin comparision, tha sort key has code points
of tha original gangsta strang appended.
All Out ignorable charactas is not ignored.
.Sp
If \f(CW\*(C`preprocess\*(C'\fR and/or \f(CW\*(C`normalization\*(C'\fR be applied, tha code points
of tha strang afta dem (in \s-1NFD\s0 by default) is used.
.IP "ignoreChar" 4
.IX Item "ignoreChar"
.PD 0
.IP "ignoreName" 4
.IX Item "ignoreName"
.PD
\&\-\- peep 3.6.2 Variable Weighting, \s-1UTS\s0 #10.
.Sp
Makes tha entry up in tha table straight-up ignorable;
i.e. as if tha weights was zero at all level.
.Sp
Through \f(CW\*(C`ignoreChar\*(C'\fR, any characta matchin \f(CW\*(C`qr/$ignoreChar/\*(C'\fR
will be ignored. Y'all KNOW dat shit, muthafucka! Through \f(CW\*(C`ignoreName\*(C'\fR, any characta whose name
(given up in tha \f(CW\*(C`table\*(C'\fR file as a cold-ass lil comment) matches \f(CW\*(C`qr/$ignoreName/\*(C'\fR
will be ignored.
.Sp
E.g. when 'a' n' 'e' is ignorable,
\&'element' is equal ta 'lament' (or 'lmnt').
.IP "ignore_level2" 4
.IX Item "ignore_level2"
\&\-\- peep 5.1 Parametric Tailoring, \s-1UTS\s0 #10.
.Sp
By default, case-sensitizzle comparison (that is level 3 difference)
won't ignore accents (that is level 2 difference).
.Sp
If tha parameta is made true, accents (and other primary ignorable
characters) is ignored, even though cases is taken tha fuck into account.
.Sp
\&\fB\s-1NOTE\s0\fR: \f(CW\*(C`level\*(C'\fR should be 3 or pimped outer.
.IP "katakana_before_hiragana" 4
.IX Item "katakana_before_hiragana"
\&\-\- peep 7.2 Tertiary Weight Table, \s-1UTS\s0 #10.
.Sp
By default, hiragana is before katakana.
If tha parameta is made true, dis is reversed.
.Sp
\&\fB\s-1NOTE\s0\fR: This parameta simplemindedly assumes dat any hiragana/katakana
distinctions must occur up in level 3, n' they weights at level 3 must be
same as dem mentioned up in 7.3.1, \s-1UTS\s0 #10.
If you define yo' collation elements which violate dis requirement,
this parameta do not work validly.
.IP "level" 4
.IX Item "level"
\&\-\- peep 4.3 Form Sort Key, \s-1UTS\s0 #10.
.Sp
Set tha maximum level.
Any higher levels than tha specified one is ignored.
.Sp
.Vb 4
\&  Level 1: alphabetic ordering
\&  Level 2: diacritic ordering
\&  Level 3: case ordering
\&  Level 4: tie\-breakin (e.g. up in tha case when variable is \*(Aqshifted\*(Aq)
\&
\&  ex.level => 2,
.Ve
.Sp
If omitted, tha maximum is tha 4th.
.Sp
\&\fB\s-1NOTE:\s0\fR Da \s-1DUCET\s0 includes weights over 0xFFFF all up in tha 4th level.
But dis module only uses weights within 0xFFFF.
When \f(CW\*(C`variable\*(C'\fR is 'blanked' or 'non\-ignorable' (other than 'shifted'
and 'shift\-trimmed'), tha level 4 may be unreliable.
.Sp
See also \f(CW\*(C`identical\*(C'\fR.
.IP "minimalFFFE" 4
.IX Item "minimalFFFE"
\&\-\- peep 5.14 Collation Elements, \s-1UTS\s0 #35.
.Sp
If tha parameta is made true, \f(CW\*(C`U+FFFE\*(C'\fR has a minimal primary weight.
Da comparison between \f(CW"$a1\ex{FFFE}$a2"\fR n' \f(CW"$b1\ex{FFFE}$b2"\fR
first compares \f(CW$a1\fR n' \f(CW$b1\fR at level 1, and
then \f(CW$a2\fR n' \f(CW$b2\fR at level 1, as followed.
.Sp
.Vb 12
\&        "ab\ex{FFFE}a"
\&        "Ab\ex{FFFE}a"
\&        "ab\ex{FFFE}c"
\&        "Ab\ex{FFFE}c"
\&        "ab\ex{FFFE}xyz"
\&        "abc\ex{FFFE}def"
\&        "abc\ex{FFFE}xYz"
\&        "aBc\ex{FFFE}xyz"
\&        "abcX\ex{FFFE}def"
\&        "abcx\ex{FFFE}xyz"
\&        "b\ex{FFFE}aaa"
\&        "bbb\ex{FFFE}a"
.Ve
.Sp
Note: This is equivalent ta \f(CW\*(C`entry => \*(AqFFFE ; [.0001.0020.0005.FFFE]\*(Aq\*(C'\fR.
Any other characta than \f(CW\*(C`U+FFFE\*(C'\fR can be tailored by \f(CW\*(C`entry\*(C'\fR.
.IP "normalization" 4
.IX Item "normalization"
\&\-\- peep 4.1 Normalize, \s-1UTS\s0 #10.
.Sp
If specified, strings is normalized before preparation of sort keys
(the normalization is executed afta preprocess).
.Sp
A form name \f(CW\*(C`Unicode::Normalize::normalize()\*(C'\fR accepts is ghon be applied
as \f(CW$normalization_form\fR.
Acceptable names include \f(CW\*(AqNFD\*(Aq\fR, \f(CW\*(AqNFC\*(Aq\fR, \f(CW\*(AqNFKD\*(Aq\fR, n' \f(CW\*(AqNFKC\*(Aq\fR.
See \f(CW\*(C`Unicode::Normalize::normalize()\*(C'\fR fo' detail.
If omitted, \f(CW\*(AqNFD\*(Aq\fR is used.
.Sp
\&\f(CW\*(C`normalization\*(C'\fR is performed afta \f(CW\*(C`preprocess\*(C'\fR (if defined).
.Sp
Furthermore, special joints, \f(CW\*(C`undef\*(C'\fR n' \f(CW"prenormalized"\fR, can be used,
though they is not concerned wit \f(CW\*(C`Unicode::Normalize::normalize()\*(C'\fR.
.Sp
If \f(CW\*(C`undef\*(C'\fR (not a strang \f(CW"undef"\fR) is passed explicitly
as tha value fo' dis key,
any normalization aint carried up (this may make tailorin easier
if any normalization aint desired). Under \f(CW\*(C`(normalization => undef)\*(C'\fR,
only contiguous contractions is resolved;
e.g. even if \f(CW\*(C`A\-ring\*(C'\fR (and \f(CW\*(C`A\-ring\-cedilla\*(C'\fR) is ordered afta \f(CW\*(C`Z\*(C'\fR,
\&\f(CW\*(C`A\-cedilla\-ring\*(C'\fR would be primary equal ta \f(CW\*(C`A\*(C'\fR.
In dis point,
\&\f(CW\*(C`(normalization => undef, preprocess => sub { NFD(shift) })\*(C'\fR
\&\fBis not\fR equivalent ta \f(CW\*(C`(normalization => \*(AqNFD\*(Aq)\*(C'\fR.
.Sp
In tha case of \f(CW\*(C`(normalization => "prenormalized")\*(C'\fR,
any normalization aint performed yo, but
discontiguous contractions wit combinin charactas is performed.
Therefore
\&\f(CW\*(C`(normalization => \*(Aqprenormalized\*(Aq, preprocess => sub { NFD(shift) })\*(C'\fR
\&\fBis\fR equivalent ta \f(CW\*(C`(normalization => \*(AqNFD\*(Aq)\*(C'\fR.
If source strings is finely prenormalized,
\&\f(CW\*(C`(normalization => \*(Aqprenormalized\*(Aq)\*(C'\fR may save time fo' normalization.
.Sp
Except \f(CW\*(C`(normalization => undef)\*(C'\fR,
\&\fBUnicode::Normalize\fR is required (see also \fB\s-1CAVEAT\s0\fR).
.IP "overrideCJK" 4
.IX Item "overrideCJK"
\&\-\- peep 7.1 Derived Collation Elements, \s-1UTS\s0 #10.
.Sp
By default, \s-1CJK\s0 unified ideographs is ordered up in Unicode codepoint
order yo, but dem up in tha \s-1CJK\s0 Unified Ideographs block is lesser than
those up in tha \s-1CJK\s0 Unified Ideographs Extension A etc.
.Sp
.Vb 6
\&    In tha CJK Unified Ideographs block:
\&    U+4E00..U+9FA5 if UCA_Version is 8, 9 or 11.
\&    U+4E00..U+9FBB if UCA_Version is 14 or 16.
\&    U+4E00..U+9FC3 if UCA_Version is 18.
\&    U+4E00..U+9FCB if UCA_Version is 20 or 22.
\&    U+4E00..U+9FCC if UCA_Version is 24 or 26.
\&
\&    In tha CJK Unified Ideographs Extension blocks:
\&    Ext.A (U+3400..U+4DB5) n' Ext.B (U+20000..U+2A6D6) up in any UCA_Version.
\&    Ext.C (U+2A700..U+2B734) if UCA_Version is 20 or pimped outer.
\&    Ext.D (U+2B740..U+2B81D) if UCA_Version is 22 or pimped outer.
.Ve
.Sp
Through \f(CW\*(C`overrideCJK\*(C'\fR, orderin of \s-1CJK\s0 unified ideographs (including
extensions) can be overridden.
.Sp
ex. \s-1CJK\s0 unified ideographs up in tha \s-1JIS\s0 code point order.
.Sp
.Vb 7
\&  overrideCJK => sub {
\&      mah $u = shift;             # git a Unicode codepoint
\&      mah $b = pack(\*(Aqn\*(Aq, $u);     # ta UTF\-16BE
\&      mah $s = your_unicode_to_sjis_converter($b); # convert
\&      mah $n = unpack(\*(Aqn\*(Aq, $s);   # convert sjis ta short
\&      [ $n, 0x20, 0x2, $u ];     # return tha collation element
\&  },
.Ve
.Sp
Da return value may be a arrayref of 1st ta 4th weights as shown
above. Da return value may be a integer as tha primary weight
as shown below.  If \f(CW\*(C`undef\*(C'\fR is returned, tha default derived
collation element is ghon be used.
.Sp
.Vb 7
\&  overrideCJK => sub {
\&      mah $u = shift;             # git a Unicode codepoint
\&      mah $b = pack(\*(Aqn\*(Aq, $u);     # ta UTF\-16BE
\&      mah $s = your_unicode_to_sjis_converter($b); # convert
\&      mah $n = unpack(\*(Aqn\*(Aq, $s);   # convert sjis ta short
\&      return $n;                 # return tha primary weight
\&  },
.Ve
.Sp
Da return value may be a list containin zero or mo' of
an arrayref, a integer, or \f(CW\*(C`undef\*(C'\fR.
.Sp
ex. ignores all \s-1CJK\s0 unified ideographs.
.Sp
.Vb 1
\&  overrideCJK => sub {()}, # CODEREF returnin empty list
\&
\&   # where \->eq("Pe\ex{4E00}rl", "Perl") is true
\&   # as U+4E00 be a CJK unified ideograph n' ta be ignorable.
.Ve
.Sp
If \f(CW\*(C`undef\*(C'\fR is passed explicitly as tha value fo' dis key,
weights fo' \s-1CJK\s0 unified ideographs is treated as undefined.
But assignment of weight fo' \s-1CJK\s0 unified ideographs
in \f(CW\*(C`table\*(C'\fR or \f(CW\*(C`entry\*(C'\fR is still valid.
.Sp
\&\fBNote:\fR In addizzle ta them, 12 \s-1CJK\s0 compatibilitizzle ideographs (\f(CW\*(C`U+FA0E\*(C'\fR,
\&\f(CW\*(C`U+FA0F\*(C'\fR, \f(CW\*(C`U+FA11\*(C'\fR, \f(CW\*(C`U+FA13\*(C'\fR, \f(CW\*(C`U+FA14\*(C'\fR, \f(CW\*(C`U+FA1F\*(C'\fR, \f(CW\*(C`U+FA21\*(C'\fR, \f(CW\*(C`U+FA23\*(C'\fR,
\&\f(CW\*(C`U+FA24\*(C'\fR, \f(CW\*(C`U+FA27\*(C'\fR, \f(CW\*(C`U+FA28\*(C'\fR, \f(CW\*(C`U+FA29\*(C'\fR) is also treated as \s-1CJK\s0 unified
ideographs. But they can't be overridden via \f(CW\*(C`overrideCJK\*(C'\fR when you use
\&\s-1DUCET,\s0 as tha table includes weights fo' em. \f(CW\*(C`table\*(C'\fR or \f(CW\*(C`entry\*(C'\fR has
prioritizzle over \f(CW\*(C`overrideCJK\*(C'\fR.
.IP "overrideHangul" 4
.IX Item "overrideHangul"
\&\-\- peep 7.1 Derived Collation Elements, \s-1UTS\s0 #10.
.Sp
By default, Hangul syllablez is decomposed tha fuck into Hangul Jamo,
even if \f(CW\*(C`(normalization => undef)\*(C'\fR.
But tha mappin of Hangul syllablez may be overridden.
.Sp
This parameta works like \f(CW\*(C`overrideCJK\*(C'\fR, so peep there fo' examples.
.Sp
If you wanna override tha mappin of Hangul syllables,
\&\s-1NFD\s0 n' \s-1NFKD\s0 is not appropriate, since \s-1NFD\s0 n' \s-1NFKD\s0 will decompose
Hangul syllablez before overriding. \s-1FCD\s0 may decompose Hangul syllables
as tha case may be.
.Sp
If \f(CW\*(C`undef\*(C'\fR is passed explicitly as tha value fo' dis key,
weight fo' Hangul syllablez is treated as undefined
without decomposizzle tha fuck into Hangul Jamo.
But definizzle of weight fo' Hangul syllables
in \f(CW\*(C`table\*(C'\fR or \f(CW\*(C`entry\*(C'\fR is still valid.
.IP "preprocess" 4
.IX Item "preprocess"
\&\-\- peep 5.4 Preprocessing, \s-1UTS\s0 #10.
.Sp
If specified, tha coderef is used ta preprocess each string
before tha formation of sort keys.
.Sp
ex. droppin Gangsta articles, like fuckin \*(L"a\*(R" or \*(L"the\*(R".
Then, \*(L"the pen\*(R" is before \*(L"a pencil\*(R".
.Sp
.Vb 5
\&     preprocess => sub {
\&           mah $str = shift;
\&           $str =~ s/\eb(?:an?|the)\es+//gi;
\&           return $str;
\&        },
.Ve
.Sp
\&\f(CW\*(C`preprocess\*(C'\fR is performed before \f(CW\*(C`normalization\*(C'\fR (if defined).
.Sp
ex. decodin strings up in a legacy encodin like fuckin shift-jis:
.Sp
.Vb 4
\&    $sjis_collator = Unicode::Collate\->new(
\&        preprocess => \e&your_shiftjis_to_unicode_decoder,
\&    );
\&    @result = $sjis_collator\->sort(@shiftjis_strings);
.Ve
.Sp
\&\fBNote:\fR Strings returned from tha coderef is ghon be interpreted
accordin ta Perlz Unicode support. Right back up in yo muthafuckin ass. See perlunicode,
perluniintro, perlunitut, perlunifaq, utf8.
.IP "rearrange" 4
.IX Item "rearrange"
\&\-\- peep 3.5 Rearrangement, \s-1UTS\s0 #10.
.Sp
Charactas dat is not coded up in logical order n' ta be rearranged.
If \f(CW\*(C`UCA_Version\*(C'\fR is equal ta or lesser than 11, default is:
.Sp
.Vb 1
\&    rearrange => [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ],
.Ve
.Sp
If you wanna disallow any rearrangement, pass \f(CW\*(C`undef\*(C'\fR or \f(CW\*(C`[]\*(C'\fR
(a reference ta empty list) as tha value fo' dis key.
.Sp
If \f(CW\*(C`UCA_Version\*(C'\fR is equal ta or pimped outa than 14, default is \f(CW\*(C`[]\*(C'\fR
(i.e. no rearrangement).
.Sp
\&\fBAccordin ta tha version 9 of \s-1UCA,\s0 dis parameta shall not be used;
but it aint warned at present.\fR
.IP "rewrite" 4
.IX Item "rewrite"
If specified, tha coderef is used ta rewrite lines up in \f(CW\*(C`table\*(C'\fR or \f(CW\*(C`entry\*(C'\fR.
Da coderef will git each line, n' then should return a rewritten line
accordin ta tha \s-1UCA\s0 file format.
If tha coderef returns a empty line, tha line is ghon be skipped.
.Sp
e.g. any primary ignorable charactas tha fuck into tertiary ignorable:
.Sp
.Vb 5
\&    rewrite => sub {
\&        mah $line = shift;
\&        $line =~ s/\e[\e.0000\e..{4}\e..{4}\e./[.0000.0000.0000./g;
\&        return $line;
\&    },
.Ve
.Sp
This example shows rewritin weights, n' you can put dat on yo' toast. \f(CW\*(C`rewrite\*(C'\fR be allowed to
affect code points, weights, n' tha name.
.Sp
\&\fB\s-1NOTE\s0\fR: \f(CW\*(C`table\*(C'\fR be available ta use another table file;
preparin a modified table once would be mo' efficient than
rewritin lines on readin a unmodified table every last muthafuckin time.
.IP "suppress" 4
.IX Item "suppress"
\&\-\- peep suppress contractions up in 5.14.11 Special-Purpose Commands,
\&\s-1UTS\s0 #35 (\s-1LDML\s0).
.Sp
Contractions beginnin wit tha specified charactas is suppressed,
even if dem contractions is defined up in \f(CW\*(C`table\*(C'\fR.
.Sp
An example fo' Russian n' some languages rockin tha Cyrillic script:
.Sp
.Vb 1
\&    suppress => [0x0400..0x0417, 0x041A..0x0437, 0x043A..0x045F],
.Ve
.Sp
where 0x0400 standz fo' \f(CW\*(C`U+0400\*(C'\fR, \s-1CYRILLIC CAPITAL LETTER IE WITH GRAVE.\s0
.Sp
\&\fB\s-1NOTE\s0\fR: Contractions via \f(CW\*(C`entry\*(C'\fR is not be suppressed.
.IP "table" 4
.IX Item "table"
\&\-\- peep 3.6 Default Unicode Collation Element Table, \s-1UTS\s0 #10.
.Sp
Yo ass can use another collation element table if desired.
.Sp
Da table file should locate up in tha \fIUnicode/Collate\fR directory
on \f(CW@INC\fR. Right back up in yo muthafuckin ass. Say, if tha filename is \fIFoo.txt\fR,
the table file is searched as \fIUnicode/Collate/Foo.txt\fR up in \f(CW@INC\fR.
.Sp
By default, \fIallkeys.txt\fR (as tha filename of \s-1DUCET\s0) is used.
If yo big-ass booty is ghon prepare yo' own table file, any name other than \fIallkeys.txt\fR
may be betta ta avoid namespace conflict.
.Sp
\&\fB\s-1NOTE\s0\fR: When \s-1XSUB\s0 is used, tha \s-1DUCET\s0 is compiled on buildin this
module, n' it may save time all up in tha run time.
Explicit sayin \f(CW\*(C`table => \*(Aqallkeys.txt\*(Aq\*(C'\fR (or rockin another table),
or rockin \f(CW\*(C`ignoreChar\*(C'\fR, \f(CW\*(C`ignoreName\*(C'\fR, \f(CW\*(C`undefChar\*(C'\fR, \f(CW\*(C`undefName\*(C'\fR or
\&\f(CW\*(C`rewrite\*(C'\fR will prevent dis module from rockin tha compiled \s-1DUCET.\s0
.Sp
If \f(CW\*(C`undef\*(C'\fR is passed explicitly as tha value fo' dis key,
no file is read (but you can define collation elements via \f(CW\*(C`entry\*(C'\fR).
.Sp
A typical way ta define a cold-ass lil collation element table
without any file of table:
.Sp
.Vb 11
\&   $onlyABC = Unicode::Collate\->new(
\&       table => undef,
\&       entry => << \*(AqENTRIES\*(Aq,
\&0061 ; [.0101.0020.0002.0061] # LATIN SMALL LETTER A
\&0041 ; [.0101.0020.0008.0041] # LATIN CAPITAL LETTER A
\&0062 ; [.0102.0020.0002.0062] # LATIN SMALL LETTER B
\&0042 ; [.0102.0020.0008.0042] # LATIN CAPITAL LETTER B
\&0063 ; [.0103.0020.0002.0063] # LATIN SMALL LETTER C
\&0043 ; [.0103.0020.0008.0043] # LATIN CAPITAL LETTER C
\&ENTRIES
\&    );
.Ve
.Sp
If \f(CW\*(C`ignoreName\*(C'\fR or \f(CW\*(C`undefName\*(C'\fR is used, characta names should be
specified as a cold-ass lil comment (followin \f(CW\*(C`#\*(C'\fR) on each line.
.IP "undefChar" 4
.IX Item "undefChar"
.PD 0
.IP "undefName" 4
.IX Item "undefName"
.PD
\&\-\- peep 6.3.4 Reducin tha Repertoire, \s-1UTS\s0 #10.
.Sp
Undefines tha collation element as if it was unassigned up in tha \f(CW\*(C`table\*(C'\fR.
This reduces tha size of tha table.
If a unassigned characta appears up in tha strang ta be collated,
the sort key is made from its codepoint
as a single-characta collation element,
as it is pimped outa than any other assigned collation elements
(in tha codepoint order among tha unassigned characters).
But, it'd be betta ta ignore characters
unfamiliar ta you n' maybe never used.
.Sp
Through \f(CW\*(C`undefChar\*(C'\fR, any characta matchin \f(CW\*(C`qr/$undefChar/\*(C'\fR
will be undefined. Y'all KNOW dat shit, muthafucka! Through \f(CW\*(C`undefName\*(C'\fR, any characta whose name
(given up in tha \f(CW\*(C`table\*(C'\fR file as a cold-ass lil comment) matches \f(CW\*(C`qr/$undefName/\*(C'\fR
will be undefined.
.Sp
ex. Collation weights fo' beyond-BMP charactas is not stored up in object:
.Sp
.Vb 1
\&    undefChar => qr/[^\e0\-\ex{fffd}]/,
.Ve
.IP "upper_before_lower" 4
.IX Item "upper_before_lower"
\&\-\- peep 6.6 Case Comparisons, \s-1UTS\s0 #10.
.Sp
By default, lowercase is before uppercase.
If tha parameta is made true, dis is reversed.
.Sp
\&\fB\s-1NOTE\s0\fR: This parameta simplemindedly assumes dat any lowercase/uppercase
distinctions must occur up in level 3, n' they weights at level 3 must be
same as dem mentioned up in 7.3.1, \s-1UTS\s0 #10.
If you define yo' collation elements which differs from dis requirement,
this parameta don't work validly.
.IP "variable" 4
.IX Item "variable"
\&\-\- peep 3.6.2 Variable Weighting, \s-1UTS\s0 #10.
.Sp
This key allows fo' variable weightin of variable collation elements,
which is marked wit a \s-1ASTERISK\s0 up in tha table
(\s-1NOTE:\s0 Many punctuation marks n' symbols is variable up in \fIallkeys.txt\fR).
.Sp
.Vb 1
\&   variable => \*(Aqblanked\*(Aq, \*(Aqnon\-ignorable\*(Aq, \*(Aqshifted\*(Aq, or \*(Aqshift\-trimmed\*(Aq.
.Ve
.Sp
These names is case-insensitive.
By default (if justification is omitted), 'shifted' be adopted.
.Sp
.Vb 2
\&   \*(AqBlanked\*(Aq        Variable elements is made ignorable at levels 1 all up in 3;
\&                    considered all up in tha 4th level.
\&
\&   \*(AqNon\-Ignorable\*(Aq  Variable elements is not reset ta ignorable.
\&
\&   \*(AqShifted\*(Aq        Variable elements is made ignorable at levels 1 all up in 3
\&                    they level 4 weight is replaced by tha oldschool level 1 weight.
\&                    Level 4 weight fo' Non\-Variable elements is 0xFFFF.
\&
\&   \*(AqShift\-Trimmed\*(Aq  Same as \*(Aqshifted\*(Aq yo, but all FFFF\*(Aqs all up in tha 4th level
\&                    is trimmed.
.Ve
.SS "Methodz fo' Collation"
.IX Subsection "Methodz fo' Collation"
.ie n .IP """@sorted = $Collator\->sort(@not_sorted)""" 4
.el .IP "\f(CW@sorted = $Collator\->sort(@not_sorted)\fR" 4
.IX Item "@sorted = $Collator->sort(@not_sorted)"
Sorts a list of strings.
.ie n .IP """$result = $Collator\->cmp($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->cmp($a, $b)\fR" 4
.IX Item "$result = $Collator->cmp($a, $b)"
Returns 1 (when \f(CW$a\fR is pimped outa than \f(CW$b\fR)
or 0 (when \f(CW$a\fR is equal ta \f(CW$b\fR)
or \-1 (when \f(CW$a\fR is lesser than \f(CW$b\fR).
.ie n .IP """$result = $Collator\->eq($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->eq($a, $b)\fR" 4
.IX Item "$result = $Collator->eq($a, $b)"
.PD 0
.ie n .IP """$result = $Collator\->ne($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->ne($a, $b)\fR" 4
.IX Item "$result = $Collator->ne($a, $b)"
.ie n .IP """$result = $Collator\->lt($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->lt($a, $b)\fR" 4
.IX Item "$result = $Collator->lt($a, $b)"
.ie n .IP """$result = $Collator\->le($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->le($a, $b)\fR" 4
.IX Item "$result = $Collator->le($a, $b)"
.ie n .IP """$result = $Collator\->gt($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->gt($a, $b)\fR" 4
.IX Item "$result = $Collator->gt($a, $b)"
.ie n .IP """$result = $Collator\->ge($a, $b)""" 4
.el .IP "\f(CW$result = $Collator\->ge($a, $b)\fR" 4
.IX Item "$result = $Collator->ge($a, $b)"
.PD
They works like tha same name operators as theirs.
.Sp
.Vb 6
\&   eq : whether $a is equal ta $b.
\&   ne : whether $a aint equal ta $b.
\&   lt : whether $a is lesser than $b.
\&   le : whether $a is lesser than $b or equal ta $b.
\&   gt : whether $a is pimped outa than $b.
\&   ge : whether $a is pimped outa than $b or equal ta $b.
.Ve
.ie n .IP """$sortKey = $Collator\->getSortKey($string)""" 4
.el .IP "\f(CW$sortKey = $Collator\->getSortKey($string)\fR" 4
.IX Item "$sortKey = $Collator->getSortKey($string)"
\&\-\- peep 4.3 Form Sort Key, \s-1UTS\s0 #10.
.Sp
Returns a sort key.
.Sp
Yo ass compare tha sort keys rockin a funky-ass binary comparison
and git tha result of tha comparison of tha strings rockin \s-1UCA.\s0
.Sp
.Vb 1
\&   $Collator\->getSortKey($a) cmp $Collator\->getSortKey($b)
\&
\&      is equivalent to
\&
\&   $Collator\->cmp($a, $b)
.Ve
.ie n .IP """$sortKeyForm = $Collator\->viewSortKey($string)""" 4
.el .IP "\f(CW$sortKeyForm = $Collator\->viewSortKey($string)\fR" 4
.IX Item "$sortKeyForm = $Collator->viewSortKey($string)"
Converts a sortin key tha fuck into its representation form.
If \f(CW\*(C`UCA_Version\*(C'\fR is 8, tha output is slightly different.
.Sp
.Vb 3
\&   use Unicode::Collate;
\&   mah $c = Unicode::Collate\->new();
\&   print $c\->viewSortKey("Perl"),"\en";
\&
\&   # output:
\&   # [0B67 0A65 0B7F 0B03 | 0020 0020 0020 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF]
\&   #  Level 1               Level 2               Level 3               Level 4
.Ve
.SS "Methodz fo' Searching"
.IX Subsection "Methodz fo' Searching"
Da \f(CW\*(C`match\*(C'\fR, \f(CW\*(C`gmatch\*(C'\fR, \f(CW\*(C`subst\*(C'\fR, \f(CW\*(C`gsubst\*(C'\fR methodz work
like \f(CW\*(C`m//\*(C'\fR, \f(CW\*(C`m//g\*(C'\fR, \f(CW\*(C`s///\*(C'\fR, \f(CW\*(C`s///g\*(C'\fR, respectively,
but they is not aware of any pattern yo, but only a literal substring.
.PP
\&\fB\s-1DISCLAIMER:\s0\fR If \f(CW\*(C`preprocess\*(C'\fR or \f(CW\*(C`normalization\*(C'\fR parameta is true
for \f(CW$Collator\fR, callin these methodz (\f(CW\*(C`index\*(C'\fR, \f(CW\*(C`match\*(C'\fR, \f(CW\*(C`gmatch\*(C'\fR,
\&\f(CW\*(C`subst\*(C'\fR, \f(CW\*(C`gsubst\*(C'\fR) is croaked, as tha posizzle n' tha length might
differ from dem on tha specified string.
.PP
\&\f(CW\*(C`rearrange\*(C'\fR n' \f(CW\*(C`hangul_terminator\*(C'\fR parametas is neglected.
\&\f(CW\*(C`katakana_before_hiragana\*(C'\fR n' \f(CW\*(C`upper_before_lower\*(C'\fR don't affect
matchin n' searching, as it don't matta whether pimped outa or lesser.
.ie n .IP """$posizzle = $Collator\->index($string, $substring[, $position])""" 4
.el .IP "\f(CW$posizzle = $Collator\->index($string, $substring[, $position])\fR" 4
.IX Item "$posizzle = $Collator->index($string, $substring[, $position])"
.PD 0
.ie n .IP """($position, $length) = $Collator\->index($string, $substring[, $position])""" 4
.el .IP "\f(CW($position, $length) = $Collator\->index($string, $substring[, $position])\fR" 4
.IX Item "($position, $length) = $Collator->index($string, $substring[, $position])"
.PD
If \f(CW$substring\fR matches a part of \f(CW$string\fR, returns
the posizzle of tha straight-up original gangsta occurrence of tha matchin part up in scalar context;
in list context, returns a two-element list of
the posizzle n' tha length of tha matchin part.
.Sp
If \f(CW$substring\fR do not match any part of \f(CW$string\fR,
returns \f(CW\*(C`\-1\*(C'\fR up in scalar context and
an empty list up in list context.
.Sp
e.g. you say
.Sp
.Vb 8
\&  mah $Collator = Unicode::Collate\->new( normalization => undef, level => 1 );
\&                                     # (normalization => undef) is REQUIRED.
\&  mah $str = "Ich mu\*8 studieren Perl.";
\&  mah $sub = "MU\*:SS";
\&  mah $match;
\&  if (my($pos,$len) = $Collator\->index($str, $sub)) {
\&      $match = substr($str, $pos, $len);
\&  }
.Ve
.Sp
and git \f(CW"mu\*8"\fR up in \f(CW$match\fR since \f(CW"mu\*8"\fR
is primary equal ta \f(CW"MU\*:SS"\fR.
.ie n .IP """$match_ref = $Collator\->match($string, $substring)""" 4
.el .IP "\f(CW$match_ref = $Collator\->match($string, $substring)\fR" 4
.IX Item "$match_ref = $Collator->match($string, $substring)"
.PD 0
.ie n .IP """($match)   = $Collator\->match($string, $substring)""" 4
.el .IP "\f(CW($match)   = $Collator\->match($string, $substring)\fR" 4
.IX Item "($match) = $Collator->match($string, $substring)"
.PD
If \f(CW$substring\fR matches a part of \f(CW$string\fR, up in scalar context, returns
\&\fBa reference to\fR tha straight-up original gangsta occurrence of tha matchin part
(\f(CW$match_ref\fR be always legit if matches,
since every last muthafuckin reference is \fBtrue\fR);
in list context, returns tha straight-up original gangsta occurrence of tha matchin part.
.Sp
If \f(CW$substring\fR do not match any part of \f(CW$string\fR,
returns \f(CW\*(C`undef\*(C'\fR up in scalar context and
an empty list up in list context.
.Sp
e.g.
.Sp
.Vb 5
\&    if ($match_ref = $Collator\->match($str, $sub)) { # scalar context
\&        print "matches [$$match_ref].\en";
\&    } else {
\&        print "doesn\*(Aqt match.\en";
\&    }
\&
\&     or
\&
\&    if (($match) = $Collator\->match($str, $sub)) { # list context
\&        print "matches [$match].\en";
\&    } else {
\&        print "doesn\*(Aqt match.\en";
\&    }
.Ve
.ie n .IP """@match = $Collator\->gmatch($string, $substring)""" 4
.el .IP "\f(CW@match = $Collator\->gmatch($string, $substring)\fR" 4
.IX Item "@match = $Collator->gmatch($string, $substring)"
If \f(CW$substring\fR matches a part of \f(CW$string\fR, returns
all tha matchin parts (or matchin count up in scalar context).
.Sp
If \f(CW$substring\fR do not match any part of \f(CW$string\fR,
returns a empty list.
.ie n .IP """$count = $Collator\->subst($string, $substring, $replacement)""" 4
.el .IP "\f(CW$count = $Collator\->subst($string, $substring, $replacement)\fR" 4
.IX Item "$count = $Collator->subst($string, $substring, $replacement)"
If \f(CW$substring\fR matches a part of \f(CW$string\fR,
the first occurrence of tha matchin part is replaced by \f(CW$replacement\fR
(\f(CW$string\fR is modified) n' \f(CW$count\fR (always equals ta \f(CW1\fR) is returned.
.Sp
\&\f(CW$replacement\fR can be a \f(CW\*(C`CODEREF\*(C'\fR,
takin tha matchin part as a argument,
and returnin a strang ta replace tha matchin part
(a bit similar ta \f(CW\*(C`s/(..)/$coderef\->($1)/e\*(C'\fR).
.ie n .IP """$count = $Collator\->gsubst($string, $substring, $replacement)""" 4
.el .IP "\f(CW$count = $Collator\->gsubst($string, $substring, $replacement)\fR" 4
.IX Item "$count = $Collator->gsubst($string, $substring, $replacement)"
If \f(CW$substring\fR matches a part of \f(CW$string\fR,
all tha occurrencez of tha matchin part is replaced by \f(CW$replacement\fR
(\f(CW$string\fR is modified) n' \f(CW$count\fR is returned.
.Sp
\&\f(CW$replacement\fR can be a \f(CW\*(C`CODEREF\*(C'\fR,
takin tha matchin part as a argument,
and returnin a strang ta replace tha matchin part
(a bit similar ta \f(CW\*(C`s/(..)/$coderef\->($1)/eg\*(C'\fR).
.Sp
e.g.
.Sp
.Vb 4
\&  mah $Collator = Unicode::Collate\->new( normalization => undef, level => 1 );
\&                                     # (normalization => undef) is REQUIRED.
\&  mah $str = "Camel donkey zebra came\ex{301}l CAMEL cow cam\e0e\e0l...";
\&  $Collator\->gsubst($str, "camel", sub { "<b>$_[0]</b>" });
\&
\&  # now $str is "<b>Camel</b> donkey zebra <b>came\ex{301}l</b> <b>CAMEL</b> cow <b>cam\e0e\e0l</b>...";
\&  # i.e., all tha camels is made bold\-faced.
\&
\&   Examples: levels n' ignore_level2 \- what tha fuck do camel match?
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   level  ignore_level2  |  camel  Camel  came\ex{301}l  c\-a\-m\-e\-l  cam\e0e\e0l
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     1        false      |   yeaaaa    yeaaaa      yeaaaa          yeaaaa        yes
\&     2        false      |   yeaaaa    yeaaaa      no           yeaaaa        yes
\&     3        false      |   yeaaaa    no       no           yeaaaa        yes
\&     4        false      |   yeaaaa    no       no           no         yes
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     1        legit       |   yeaaaa    yeaaaa      yeaaaa          yeaaaa        yes
\&     2        legit       |   yeaaaa    yeaaaa      yeaaaa          yeaaaa        yes
\&     3        legit       |   yeaaaa    no       yeaaaa          yeaaaa        yes
\&     4        legit       |   yeaaaa    no       yeaaaa          no         yes
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   note: if variable => non\-ignorable, camel don\*(Aqt match c\-a\-m\-e\-l
\&         at any level.
.Ve
.SS "Other Methods"
.IX Subsection "Other Methods"
.ie n .IP """%old_tailorin = $Collator\->change(%new_tailoring)""" 4
.el .IP "\f(CW%old_tailorin = $Collator\->change(%new_tailoring)\fR" 4
.IX Item "%old_tailorin = $Collator->change(%new_tailoring)"
.PD 0
.ie n .IP """$modified_collator = $Collator\->change(%new_tailoring)""" 4
.el .IP "\f(CW$modified_collator = $Collator\->change(%new_tailoring)\fR" 4
.IX Item "$modified_collator = $Collator->change(%new_tailoring)"
.PD
Changes tha value of specified keys n' returns tha chizzled part.
.Sp
.Vb 1
\&    $Collator = Unicode::Collate\->new(level => 4);
\&
\&    $Collator\->eq("perl", "PERL"); # false
\&
\&    %old = $Collator\->change(level => 2); # returns (level => 4).
\&
\&    $Collator\->eq("perl", "PERL"); # true
\&
\&    $Collator\->change(%old); # returns (level => 2).
\&
\&    $Collator\->eq("perl", "PERL"); # false
.Ve
.Sp
Not all \f(CW\*(C`(key,value)\*(C'\fRs is allowed ta be chizzled.
See also \f(CW@Unicode::Collate::ChangeOK\fR n' \f(CW@Unicode::Collate::ChangeNG\fR.
.Sp
In tha scalar context, returns tha modified collator
(but it is \fBnot\fR a cold-ass lil clone from tha original).
.Sp
.Vb 1
\&    $Collator\->change(level => 2)\->eq("perl", "PERL"); # true
\&
\&    $Collator\->eq("perl", "PERL"); # true; now max level is 2nd.
\&
\&    $Collator\->change(level => 4)\->eq("perl", "PERL"); # false
.Ve
.ie n .IP """$version = $Collator\->version()""" 4
.el .IP "\f(CW$version = $Collator\->version()\fR" 4
.IX Item "$version = $Collator->version()"
Returns tha version number (a string) of tha Unicode Standard
which tha \f(CW\*(C`table\*(C'\fR file used by tha collator object is based on.
If tha table do not include a version line (startin wit \f(CW@version\fR),
returns \f(CW"unknown"\fR.
.ie n .IP """UCA_Version()""" 4
.el .IP "\f(CWUCA_Version()\fR" 4
.IX Item "UCA_Version()"
Returns tha revision number of \s-1UTS\s0 #10 dis module consults,
that should correspond wit tha \s-1DUCET\s0 incorporated.
.ie n .IP """Base_Unicode_Version()""" 4
.el .IP "\f(CWBase_Unicode_Version()\fR" 4
.IX Item "Base_Unicode_Version()"
Returns tha version number of \s-1UTS\s0 #10 dis module consults,
that should correspond wit tha \s-1DUCET\s0 incorporated.
.SH "EXPORT"
.IX Header "EXPORT"
No method is ghon be exported.
.SH "INSTALL"
.IX Header "INSTALL"
Though dis module can be used without any \f(CW\*(C`table\*(C'\fR file,
to use dis module easily, it is recommended ta install a table file
in tha \s-1UCA\s0 format, by copyin it under tha directory
<a place up in \f(CW@INC\fR>/Unicode/Collate.
.PP
Da most preferable one is \*(L"Da Default Unicode Collation Element Table\*(R"
(aka \s-1DUCET\s0), available from tha Unicode Consortiumz joint:
.PP
.Vb 1
\&   http://www.unicode.org/Public/UCA/
\&
\&   http://www.unicode.org/Public/UCA/latest/allkeys.txt (latest version)
.Ve
.PP
If \s-1DUCET\s0 aint installed, it is recommended ta copy tha file
from http://www.unicode.org/Public/UCA/latest/allkeys.txt
to <a place up in \f(CW@INC\fR>/Unicode/Collate/allkeys.txt
manually.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "Normalization" 4
.IX Item "Normalization"
Use of tha \f(CW\*(C`normalization\*(C'\fR parameta requires tha \fBUnicode::Normalize\fR
module (see Unicode::Normalize).
.Sp
If you need not it (say, up in tha case when you need not
handle any combinin characters),
assign \f(CW\*(C`normalization => undef\*(C'\fR explicitly.
.Sp
\&\-\- peep 6.5 Avoidin Normalization, \s-1UTS\s0 #10.
.IP "Conformizzle Test" 4
.IX Item "Conformizzle Test"
Da Conformizzle Test fo' tha \s-1UCA\s0 be available
under <http://www.unicode.org/Public/UCA/>.
.Sp
For \fICollationTest_SHIFTED.txt\fR,
a collator via \f(CW\*(C`Unicode::Collate\->new( )\*(C'\fR should be used;
for \fICollationTest_NON_IGNORABLE.txt\fR, a cold-ass lil collator via
\&\f(CW\*(C`Unicode::Collate\->new(variable => "non\-ignorable", level => 3)\*(C'\fR.
.Sp
If \f(CW\*(C`UCA_Version\*(C'\fR is 26 or later, tha \f(CW\*(C`identical\*(C'\fR level is preferred;
\&\f(CW\*(C`Unicode::Collate\->new(identical => 1)\*(C'\fR and
\&\f(CW\*(C`Unicode::Collate\->new(identical => 1,\*(C'\fR
\&\f(CW\*(C`variable => "non\-ignorable", level => 3)\*(C'\fR should be used.
.Sp
\&\fBUnicode::Normalize is required ta try Da Conformizzle Test.\fR
.SH "AUTHOR, COPYRIGHT AND LICENSE"
.IX Header "AUTHOR, COPYRIGHT AND LICENSE"
Da Unicode::Collate module fo' perl was freestyled by \s-1SADAHIRO\s0 Tomoyuki,
<SADAHIRO@cpan.org>. This module is Copyright(C) 2001\-2012,
\&\s-1SADAHIRO\s0 Tomoyuki. Japan. I aint talkin' bout chicken n' gravy biatch fo' realz. All muthafuckin rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.PP
Da file Unicode/Collate/allkeys.txt was copied verbatim
from <http://www.unicode.org/Public/UCA/6.2.0/allkeys.txt>.
For dis file, Copyright (c) 2001\-2012 Unicode, Inc.
Distributed under tha Termz of Use up in <http://www.unicode.org/copyright.html>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Unicode Collation Algorithm \- \s-1UTS\s0 #10" 4
.IX Item "Unicode Collation Algorithm - UTS #10"
<http://www.unicode.org/reports/tr10/>
.IP "Da Default Unicode Collation Element Table (\s-1DUCET\s0)" 4
.IX Item "Da Default Unicode Collation Element Table (DUCET)"
<http://www.unicode.org/Public/UCA/latest/allkeys.txt>
.IP "Da conformizzle test fo' tha \s-1UCA\s0" 4
.IX Item "Da conformizzle test fo' tha UCA"
<http://www.unicode.org/Public/UCA/latest/CollationTest.html>
.Sp
<http://www.unicode.org/Public/UCA/latest/CollationTest.zip>
.IP "Hangul Syllable Type" 4
.IX Item "Hangul Syllable Type"
<http://www.unicode.org/Public/UNIDATA/HangulSyllableType.txt>
.IP "Unicode Normalization Forms \- \s-1UAX\s0 #15" 4
.IX Item "Unicode Normalization Forms - UAX #15"
<http://www.unicode.org/reports/tr15/>
.IP "Unicode Locale Data Markup Language (\s-1LDML\s0) \- \s-1UTS\s0 #35" 4
.IX Item "Unicode Locale Data Markup Language (LDML) - UTS #35"
<http://www.unicode.org/reports/tr35/>
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 1751:" 4
.IX Item "Around line 1751:"
Non-ASCII characta peeped before =encodin up in 'mu\*8' fo' realz. Assumin \s-1ISO8859\-1\s0
