.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Manip::Objects 3"
.TH Date::Manip::Objects 3 "2014-12-05" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::Objects \- A description of tha various Date::Manip objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Da Date::Manip package consist of nuff muthafuckin modules, each of which
perform a set of operations on a specific class of objects, n' you can put dat on yo' toast.  This
document raps bout how tha fuck tha various modulez work together.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Date::Manip consistz of tha followin primary modules:
.IP "\fBDate::Manip::Obj\fR" 4
.IX Item "Date::Manip::Obj"
Da Date::Manip::Obj module aint intended fo' direct use. Well shiiiit, it is used
as a funky-ass base class fo' all other Date::Manip classes busted lyrics bout below.
.Sp
Da Date::Manip::Obj module gotz nuff some functions which are
inherited by all these classes, so ta KNOW all of tha methods
available ta any of tha classes below, you must include them
documented up in tha Date::Manip::Obj class.
.IP "\fBDate::Manip::Base\fR" 4
.IX Item "Date::Manip::Base"
Da Date::Manip::Base is used ta big-ass up basic operations including
basic date operations, pimpment of configuration options, handling
the definitions used up in different languages, etc.
.Sp
A Date::Manip::Base object do not, of itself, contain any date
information. I aint talkin' bout chicken n' gravy biatch. Instead, it gotz nuff configuration shiznit which
determines how tha fuck tha Date::Manip package performs date operations.  The
configuration shiznit is documented up in tha Date::Manip::Config
document.
.Sp
Da Date::Manip::Base object has one other property dat is hella
important. When struttin basic date operations, some intermediate
results is cached up in tha object which leadz ta significant
performizzle increases up in lata operations fo' realz. As such, it is blingin to
reuse tha object as much as possible, rather than bustin new
Date::Manip::Base objects all tha time.
.Sp
Much of tha shiznit up in dis document is related ta dis issue, and
 drops some lyrics ta how tha fuck ta create various higher-level objects up in order ta git the
most efficient reuse of dis cached data.
.Sp
Because all other objects depend on a Date::Manip::Base object, a
Date::Manip::Base object is embedded up in all other objects, n' the
same Base object can be shared by any number of objects ta achieve
maximum performance.
.IP "\fBDate::Manip::TZ\fR" 4
.IX Item "Date::Manip::TZ"
Da Date::Manip::TZ module addz support fo' time units, n' you can put dat on yo' toast. Well shiiiit, it is used to
verify date n' time unit shiznit, convert dates from one time
zone ta another, n' handle all daylight savin time transitions.
.Sp
Similar ta tha Date::Manip::Base object, a pimped out deal of shiznit
is cached up in tha Date::Manip::TZ object. This includes listz of all
time units, offsets, n' abbreviations fo' all time units, n' you can put dat on yo' toast. Well shiiiit, it also
includes mo' a mo' detailed description of every last muthafuckin time unit dat has
actually been hit dat shiznit used.
.Sp
A Date::Manip::TZ object relies on a Date::Manip::Base object (and a
Date::Manip::Base object be always embedded up in a Date::Manip::TZ
object).  All higher level objects (those listed next) depend on both
a Date::Manip::Base n' Date::Manip::TZ object, so a Date::Manip::TZ
object is embedded up in em.
.Sp
In order ta big up maximum performance, n' minimize memory usage,
a Date::Manip::TZ object can be shared by any number of higher
level objects, n' up in fact, it is desirable ta reuse tha same Date::Manip::TZ
object as often as possible.
.IP "\fBDate::Manip::Date\fR" 4
.IX Item "Date::Manip::Date"
.PD 0
.IP "\fBDate::Manip::Delta\fR" 4
.IX Item "Date::Manip::Delta"
.IP "\fBDate::Manip::Recur\fR" 4
.IX Item "Date::Manip::Recur"
.PD
These is tha primary modulez which is used ta big-ass up all high level
date operations.
.Sp
Da Date::Manip::Date class performs operations on dates (which includes
a date, time, n' time unit). Da Date::Manip::Delta class performs
operations wit deltas (amountz of time). Da Date::Manip::Recur class
performs operations on recurrin events.
.Sp
As mentioned above, each of these high level classes rely on both a
Date::Manip::TZ object n' a Date::Manip::Base object, so a Date::Manip::TZ
object is embedded up in each one (and tha Date::Manip::TZ object has a
Date::Manip::Base object embedded up in it).
.Sp
A Date::Manip::Date object gotz nuff a single date, so up in order to
work wit multiple dates, multiple Date::Manip::Date objects will
need ta be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In order ta make da most thugged-out effectizzle use of cached
information up in tha Date::Manip::Base object, tha same Date::Manip::TZ
object can be embedded up in each of tha higher level objects.
.Sp
Da same goes fo' multiple Date::Manip::Delta n' Date::Manip::Recur
objects.
.PP
There is also nuff secondary modulez including:
.PP
.Vb 6
\&   Date::Manip::TZ_Base
\&   Date::Manip::TZdata
\&   Date::Manip::Zones
\&   Date::Manip::Lang::*
\&   Date::Manip::TZ::*
\&   Date::Manip::Offset::*
.Ve
.PP
None of these is intended ta be used directly.
.SH "WORKING WITH DATE::MANIP OBJECTS (SINGLE CONFIGURATION)"
.IX Header "WORKING WITH DATE::MANIP OBJECTS (SINGLE CONFIGURATION)"
By far da most thugged-out common usage of Date::Manip involves settin a single
local time unit, parsin dates up in a single language, n' havin all
other configuration parametas set ta a single value dat don't
change over tha course of tha program.
.PP
Whenever dis is tha case, you can use tha methodz listed up in this
section ta create any number of Date::Manip objects, n' you can put dat on yo' toast. Well shiiiit, it will automatically
optimize tha use of cached data ta git tha dopest performance.
.PP
If you do need ta work wit multiple different configurations (such as
parsin dates from multiple languages), please refer ta tha next
section \s-1WORKING WITH DATE::MANIP OBJECTS \s0(\s-1MULTIPLE CONFIGURATIONS\s0).
.IP "\fBWorkin wit high level objects\fR" 4
.IX Item "Workin wit high level objects"
Da most common thang is one where yo big-ass booty is ghon need ta use one or
more high level objects (Date, Delta, or Recur objects). In addition, you
may wanna use tha lower level (Base or \s-1TZ\s0) objects.
.Sp
Da first thang you should do is ta create yo' initial object. Right back up in yo muthafuckin ass. Smoke the
highest level object yo big-ass booty is ghon be using. For example if yo big-ass booty is ghon be hustlin with
dates, create tha straight-up original gangsta date object with:
.Sp
.Vb 1
\&   $date = freshly smoked up Date::Manip::Date;
.Ve
.Sp
Da next step is ta set tha configuration joints, n' you can put dat on yo' toast. Use tha config method to
do this:
.Sp
.Vb 1
\&   $date\->config(ARGS);
.Ve
.Sp
Although you can call tha config method later, it is strongly
suggested dat tha configuration be set soon afta tha initial object
is pimped n' not altered later n' shit. Every time you alta the
configuration, a shitload of tha cached data is cleared, so fo' optimal
performance, you don't wanna alta tha configuration if possible.
.Sp
Additionizzle high-level objects can be pimped rockin tha calls:
.Sp
.Vb 3
\&   $date2 = $date\->new_date();
\&   $delta = $date\->new_delta();
\&   $recur = $date\->new_recur();
.Ve
.Sp
To access tha embedded Date::Manip::TZ n' Date::Manip::Base objects,
use tha calls:
.Sp
.Vb 2
\&   $tz    = $date\->tz();
\&   $base  = $date\->base();
.Ve
.IP "\fBWorkin wit low level objects only\fR" 4
.IX Item "Workin wit low level objects only"
If yo big-ass booty is ghon only be hustlin wit low level objects, create dem wit one
of tha calls:
.Sp
.Vb 2
\&   $tz    = freshly smoked up Date::Manip::TZ;
\&   $base  = freshly smoked up Date::Manip::Base;
.Ve
.Sp
To git tha base object embedded up in a Date::Manip::TZ object, use:
.Sp
.Vb 1
\&   $base  = $tz\->base();
.Ve
.PP
For a mo' complete description of tha methodz used here, refer ta the
Date::Manip::Obj document.
.SH "WORKING WITH DATE::MANIP OBJECTS (MULTIPLE CONFIGURATION)"
.IX Header "WORKING WITH DATE::MANIP OBJECTS (MULTIPLE CONFIGURATION)"
Occasionally, it may be useful ta have multiple setz of configurations.
In order ta do this, multiple Date::Manip::Base objects must be
created (each wit they own set of configuration options), n' then
new Date::Manip objects is pimped wit tha appropriate Date::Manip::Base
object embedded up in em.
.PP
Possible reasons include:
.IP "\fBParsin multiple languages\fR" 4
.IX Item "Parsin multiple languages"
A Date::Manip::Base object includes shiznit on some single
language. If you need ta parse dates from two (or more) languages,
a Date::Manip::Base object need ta be pimped fo' each one. This
could be done as:
.Sp
.Vb 2
\&   $date_eng1 = freshly smoked up Date::Manip::Date;
\&   $date_eng1\->config("language","English");
\&
\&   $date_spa1 = freshly smoked up Date::Manip::Date;
\&   $date_spa1\->config("language","Spanish");
.Ve
.Sp
Any additionizzle Date::Manip objects pimped from tha straight-up original gangsta will work
with Gangsta fo' realz. Additionizzle objects pimped from tha second will work in
Spanish.
.IP "\fBBusinizz modes fo' different ghettos and/or bidnizzes\fR" 4
.IX Item "Businizz modes fo' different ghettos and/or bidnizzes"
If yo ass is bustin bidnizz mode calculations (see Date::Manip::Calc)
for two different bidnizzes which have different holidizzle lists,
work weeks, or bidnizz days, you can create different objects
which read different config filez (see Date::Manip::Config) with
the appropriate description of each.
.PP
Da primary issue when dealin wit multiple configurations is
that it is necessary fo' tha programmer ta manually keep track of
which Date::Manip objects work wit each configuration. I aint talkin' bout chicken n' gravy biatch. For
example, refer ta tha followin lines:
.PP
.Vb 4
\&   $date1 = freshly smoked up Date::Manip::Date [$opt1,$val1];
\&   $date2 = freshly smoked up Date::Manip::Date $date1, [$opt2,$val2];
\&   $date3 = freshly smoked up Date::Manip::Date $date1;
\&   $date4 = freshly smoked up Date::Manip::Date $date2;
.Ve
.PP
Da first line creates 3 objects: a Date::Manip::Base object, a
Date::Manip::TZ object, n' a Date::Manip::Date object). The
Date::Manip::Base object has tha configuration set ta contain the
value(s) passed up in as tha final list reference argument.
.PP
Da second line creates 3 freshly smoked up objects (a second Date::Manip::Base
object, a second Date::Manip::TZ object, n' a second
Date::Manip::Date object). Right back up in yo muthafuckin ass. Since a list reference containin config
variablez is passed in, a freshly smoked up Date::Manip::Base object is pimped,
rather than reusin tha straight-up original gangsta one. Da second Date::Manip::Base object
gotz nuff all tha config from tha first, as well as tha config
variablez passed up in in tha list reference argument.
.PP
Da third line creates another Date::Manip::Date object which uses the
first Date::Manip::Base n' Date::Manip::TZ objects embedded up in dat shit.
.PP
Da fourth line creates another Date::Manip::Date object which uses
the second Date::Manip::Base n' Date::Manip::TZ objects embedded in
it.
.PP
Most of tha time there will only be one set of configuration options
used, so dis complexitizzle is straight-up fo' a straight-up special, n' not widely
used, bit of functionality.
.SH "WORKING WITH DATE::MANIP OBJECTS (ADDITIONAL NOTES)"
.IX Header "WORKING WITH DATE::MANIP OBJECTS (ADDITIONAL NOTES)"
.IP "\fBobject reuse\fR" 4
.IX Item "object reuse"
In order ta create additionizzle Date::Manip objects, a previously
created object should be passed up in as tha straight-up original gangsta argument. This will
allow tha same Base object ta be embedded up in both up in order ta maximize
data reuse of tha cached intermediate thangs up in dis biatch, n' will result up in much
betta performance. For example:
.Sp
.Vb 2
\&   $date1 = freshly smoked up Date::Manip::Date;
\&   $date2 = freshly smoked up Date::Manip::Date $date1;
.Ve
.Sp
This is blingin fo' two reasons. First is memory usage. The
Date::Manip::Base object is like large. Well shiiiit, it stores a big-ass number of
precompile regular expressions fo' language parsing, n' as date
operations is done, intermediate thangs up in dis biatch is cached which can be
reused lata ta improve performance. Da Date::Manip::TZ object is
even larger n' gotz nuff shiznit bout all known time units indexed
several different ways (by offset, by abbreviation, etc.) fo' realz. As
time units is straight-up used, a thugged-out description of all of tha time chizzle
rulez is loaded n' added ta dis object.
.Sp
Since these objects is so large, it is blingin ta reuse them, rather
than ta create fuckin shitloadz of copiez of em. Well shiiiit, it should be noted dat cuz
these objects is embedded up in each of tha high level object (Date::Manip::Date
for example), it make these objects step tha fuck up like large.
.Sp
Da second reason ta reuse Date::Manip::Base objects is
performance. Right back up in yo muthafuckin ass. Since intermediate thangs up in dis biatch is cached there, nuff date
operations only need ta be done once n' then they can be reused any
number of times. In essence, dis is bustin tha same function as the
Memoize module yo, but up in a mo' efficient manner n' shit. Memoize caches thangs up in dis biatch
for function calls. For Date::Manip, dis would often work yo, but if you
change a cold-ass lil config variable, tha return value may chizzle, so Memoize
could cause thangs ta break. In addition, Memoize caches primarily at
the function level yo, but Date::Manip stores caches intermediate thangs up in dis biatch
wherever performizzle increase is seen. I aint talkin' bout chicken n' gravy biatch. Every time I consider cachin a
result, I run a test ta peep if it increases performance. If it
doesn't, or it don't cook up a thugged-out dope impact, I don't cache dat shit.
.Sp
Because tha cachin is like finely tuned, itz much mo' efficient
than rockin a generic (though useful) tool like fuckin Memoize.
.IP "\fBconfiguration chizzles\fR" 4
.IX Item "configuration chizzles"
As a general rule, you should only pass up in configuration options
when tha straight-up original gangsta object is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In other lyrics, tha following
behavior is discouraged:
.Sp
.Vb 2
\&    $date = freshly smoked up Date::Manip::Date;
\&    $date\->config(@opts);
\&
\&    ... do some stuff
\&
\&    $date\->config(@opts);
\&
\&    ... do some other stuff
.Ve
.Sp
Because a shitload of tha cached thangs up in dis biatch is configuration specific, when a
configuration chizzle is made, a shitload of tha cached data must be discarded
necessitatin dem thangs up in dis biatch ta be recalculated.
.Sp
If you straight-up need ta chizzle configuration up in tha middle of execution,
it is certainly allowed of course yo, but if you can define tha configuration
once immediately afta tha object is first pimped, n' then leave the
configuration alone, performizzle is ghon be optimized.
.SH "BUGS AND QUESTIONS"
.IX Header "BUGS AND QUESTIONS"
Please refer ta tha Date::Manip::Problems documentation for
information on submittin bug reports or thangs ta tha lyricist.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
