.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Harness::Beyond 3"
.TH TAP::Harness::Beyond 3 "2013-05-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "Beyond make test"
.IX Header "Beyond make test"
Test::Harnizz is responsible fo' hustlin test scripts, analysing
their output n' reportin success or failure. When I type 
\&\fImake test\fR (or \fI./Build test\fR) fo' a module, Test::Harnizz is usually
used ta run tha tests (not all modulez use Test::Harnizz but the
majoritizzle do).
.PP
To start explorin a shitload of tha featurez of Test::Harnizz I need to
switch from \fImake test\fR ta tha \fIprove\fR command (which ships with
Test::Harness). For tha followin examplez I be bout ta also need a recent
version of Test::Harnizz installed; 3.14 is current as I write.
.PP
For tha examplez I be goin ta assume dat our crazy asses hustlin wit a
\&'normal' Perl module distribution. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Specifically I be bout ta assume that
typin \fImake\fR or \fI./Build\fR causes tha built, ready-to-install module
code ta be available below ./blib/lib n' ./blib/arch n' that
therez a gangbangin' finger-lickin' directory called 't' dat gotz nuff our tests, n' you can put dat on yo' toast. Test::Harness
aint hardwired ta dat configuration but it  saves me from explaining
which filez live where fo' each example.
.PP
Back ta \fIprove\fR; like \fImake test\fR it runs a test suite \- but it
provides far mo' control over which tests is executed, up in what
order n' how tha fuck they thangs up in dis biatch is reported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Typically \fImake test\fR
runs all tha test scripts below tha 't' directory. To do tha same
thang wit prove I type:
.PP
.Vb 1
\&  prove \-rb t
.Ve
.PP
Da switches here is \-r ta recurse tha fuck into any directories below 't'
and \-b which addz ./blib/lib n' ./blib/arch ta Perlz include path
so dat tha tests can find tha code they is ghon be testing. If I'm
testin a module of which a earlier version be already installed
I need ta be careful bout tha include path ta make shizzle I be not
runnin mah tests against tha installed version rather than tha new
one dat I be hustlin on.
.PP
Unlike \fImake test\fR, typin \fIprove\fR don't automatically rebuild
my module. If I forget ta make before prove I'ma be testin against
olda versionz of dem filez \- which inevitably leadz ta mad drama.
I either git tha fuck into tha g-thang of typing
.PP
.Vb 1
\&  make && prove \-rb t
.Ve
.PP
or \- if I have no \s-1XS\s0 code dat need ta be built I use tha modules
below \fIlib\fR instead
.PP
.Vb 1
\&  prove \-Ilib \-r t
.Ve
.PP
So far I've shown you not a god damn thang dat \fImake test\fR don't do. Let's
fix dis shit.
.SS "Saved State"
.IX Subsection "Saved State"
If I have failin tests up in a test suite dat consistz of mo' than
a handful of scripts n' takes mo' than all dem secondz ta run it
rapidly becomes tedious ta run tha whole test suite repeatedly as
I track down tha problems.
.PP
I can tell prove just ta run tha tests dat is failin like this:
.PP
.Vb 1
\&  prove \-b t/this_fails.t t/so_does_this.t
.Ve
.PP
That speedz thangs up but I gotta cook up a note of which tests are
failin n' make shizzle dat I run dem tests, n' you can put dat on yo' toast. Instead I can use
provez \-\-state switch n' have it keep track of failin tests for
me. First I do a cold-ass lil complete run of tha test suite n' tell prove to
save tha thangs up in dis biatch:
.PP
.Vb 1
\&  prove \-rb \-\-state=save t
.Ve
.PP
That stores a machine readable summary of tha test run up in a gangbangin' file
called '.prove' up in tha current directory. If I have failures I can
then run just tha failin scripts like this:
.PP
.Vb 1
\&  prove \-b \-\-state=failed
.Ve
.PP
I can also tell prove ta save tha thangs up in dis biatch again n' again n' again so dat it thugged-out shit
its scam of which tests failed:
.PP
.Vb 1
\&  prove \-b \-\-state=failed,save
.Ve
.PP
As soon as one of mah failin tests passes it is ghon be removed from
the list of failed tests, n' you can put dat on yo' toast. Eventually I fix dem all n' prove can
find no failin tests ta run:
.PP
.Vb 2
\&  Files=0, Tests=0, 0 wallclock secs ( 0.00 usr + 0.00 sys = 0.00 CPU)
\&  Result: NOTESTS
.Ve
.PP
As I work on a particular part of mah module itz most likely that
the tests dat cover dat code will fail. I'd like ta run tha whole
test suite but have it prioritize these 'hot' tests, n' you can put dat on yo' toast. I can tell
prove ta do this:
.PP
.Vb 1
\&  prove \-rb \-\-state=hot,save t
.Ve
.PP
All tha tests will run but dem dat failed most recently will be
run first. If no tests have failed since I started savin state all
tests will run up in they aiiight order n' shit. This combines full test
coverage wit early notification of failures.
.PP
Da \-\-state switch supports a fuckin shitload of options; fo' example ta run
failed tests first followed by all remainin tests ordered by the
timestampz of tha test scripts \- n' save tha thangs up in dis biatch \- I can use
.PP
.Vb 1
\&  prove \-rb \-\-state=failed,new,save t
.Ve
.PP
See tha prove documentation (type prove \-\-man) fo' tha full list
of state options.
.PP
When I tell prove ta save state it writes a gangbangin' file called '.prove'
('_prove' on Windows) up in tha current directory. It aint nuthin but a \s-1YAML\s0 document
so itz like easy as fuck  ta write toolz of yo' own dat work on tha saved
test state \- but tha format aint officially documented so it might
change without (much) warnin up in tha future.
.SS "Parallel Testing"
.IX Subsection "Parallel Testing"
If mah tests take too long ta run I may be able ta speed dem up by
runnin multiple test scripts up in parallel. This is particularly
effectizzle if tha tests is I/O bound or if I have multiple \s-1CPU\s0
cores. I tell prove ta run mah tests up in parallel like this:
.PP
.Vb 1
\&  prove \-rb \-j 9 t
.Ve
.PP
Da \-j switch enablez parallel testing; tha number dat bigs up it
is tha maximum number of tests ta run up in parallel. Right back up in yo muthafuckin ass. Sometimes tests
that pass when run sequentially will fail when run up in parallel. For
example if two different test scripts use tha same temporary file
or attempt ta listen on tha same socket I be bout ta have problems hustlin
them up in parallel. If I peep unexpected failures I need ta check my
tests ta work up which of dem is tramplin on tha same resource
and rename temporary filez or add locks as appropriate.
.PP
To git da most thugged-out performizzle benefit I wanna have tha test scripts
that take tha longest ta run start first \- otherwise I be bout ta be waiting
for tha one test dat takes nearly a minute ta complete afta all
the others is done. I can use tha \-\-state switch ta run tha tests
in slowest ta fastest order:
.PP
.Vb 1
\&  prove \-rb \-j 9 \-\-state=slow,save t
.Ve
.SS "Non-Perl Tests"
.IX Subsection "Non-Perl Tests"
Da Test Anythang Protocol (http://testanything.org/) aint just
for Perl. Just bout any language can be used ta write tests that
output \s-1TAP.\s0 There is \s-1TAP\s0 based testin libraries fo' C, \*(C+, \s-1PHP,\s0
Python n' nuff others. If I can't find a \s-1TAP\s0 library fo' mah language
of chizzle itz easy as fuck  ta generate valid \s-1TAP.\s0 It be lookin like this:
.PP
.Vb 4
\&  1..3 
\&  aiiight 1 \- init OK 
\&  aiiight 2 \- opened file 
\&  not aiiight 3 \- appended ta file
.Ve
.PP
Da first line is tha plan \- it specifies tha number of tests I'm
goin ta run so dat itz easy as fuck  ta check dat tha test script didn't
exit before hustlin all tha expected tests, n' you can put dat on yo' toast. Da followin lines are
the test thangs up in dis biatch \- 'ok' fo' pass, 'not ok' fo' fail. Each test has
a number and, optionally, a thugged-out description. I aint talkin' bout chicken n' gravy biatch fo' realz. And thatz it fo' realz. Any language
that can produce output like dat on \s-1STDOUT\s0 can be used ta write
tests.
.PP
Recently I've been rekindlin a two-decades-old interest up in Forth.
Evidently I gots a masochistic streak dat even Perl can't satisfy.
I wanna write tests up in Forth n' run dem rockin prove (you can
find mah gforth \s-1TAP\s0 experiments at
https://svn.hexten.net/andy/Forth/Testing/). I can use tha \-\-exec
switch ta tell prove ta run tha tests rockin gforth like this:
.PP
.Vb 1
\&  prove \-r \-\-exec gforth t
.Ve
.PP
Alternately, if tha language used ta write mah tests allows a gangbangin' finger-lickin' dirty-ass shebang
line I can use dat ta specify tha interpreter n' shiznit yo. Herez a test written
in \s-1PHP:\s0
.PP
.Vb 6
\&  #!/usr/bin/php 
\&  <?php
\&    print "1..2\en"; 
\&    print "ok 1\en"; 
\&    print "not aiiight 2\en";
\&  ?>
.Ve
.PP
If I save dat as t/phptest.t tha shebang line will ensure dat it
runs erectly along wit all mah other tests.
.SS "Mixin it up"
.IX Subsection "Mixin it up"
Subtle interdependencies between test programs can mask problems \-
for example a earlier test may neglect ta remove a temporary file
that affects tha behaviour of a lata test. To find dis kind of
problem I use tha \-\-shuffle n' \-\-reverse options ta run mah tests
in random or reversed order.
.SS "Rollin My fuckin Own"
.IX Subsection "Rollin My fuckin Own"
If I need a gangbangin' feature dat prove don't provide I can easily write mah own.
.PP
Typically you gonna wanna chizzle how tha fuck \s-1TAP\s0 gets \fIinput\fR tha fuck into n' \fIoutput\fR
from tha parser n' shit.  App::Prove supports arbitrary plugins, n' TAP::Harness
supports custom \fIformatters\fR n' \fIsource handlezs\fR dat you can load using
either prove or Module::Build; there be nuff examplez ta base mine on.
For mo' details peep App::Prove, TAP::Parser::SourceHandlez, and
TAP::Formatter::Base.
.PP
If freestylin a plugin aint enough, you can write yo' own test harness; one of
the motives fo' tha 3.00 rewrite of Test::Harnizz was ta make it easier to
subclass n' extend.
.PP
Da Test::Harnizz module be a cold-ass lil compatibilitizzle wrapper round TAP::Harness.
For freshly smoked up applications I should use TAP::Harnizz directly fo' realz. As we'll
see, prove uses TAP::Harness.
.PP
When I run prove it processes its arguments, figures up which test
scripts ta run n' then passes control ta TAP::Harnizz ta run the
tests, parse, analyse n' present tha thangs up in dis biatch. By subclassing
TAP::Harnizz I can customise nuff aspectz of tha test run.
.PP
I wanna log mah test thangs up in dis biatch up in a thugged-out database so I can track them
over time. To do dis I override tha summary method up in TAP::Harness.
I start wit a simple prototype dat dumps tha thangs up in dis biatch as a \s-1YAML\s0
document:
.PP
.Vb 1
\&  package My::TAP::Harness;
\&
\&  use base qw( TAP::Harnizz ); use YAML;
\&
\&  sub summary {
\&    mah ( $self, $aggregate ) = @_; 
\&    print Dump( $aggregate );
\&    $self\->SUPER::summary( $aggregate );
\&  }
\&
\&  1;
.Ve
.PP
I need ta tell prove ta use mah My::TAP::Harness. If My::TAP::Harness
is on Perlz \f(CW@INC\fR include path I can
.PP
.Vb 1
\&  prove \-\-harness=My::TAP::Harnizz \-rb t
.Ve
.PP
If I aint gots My::TAP::Harnizz installed on \f(CW@INC\fR I need ta provide
the erect path ta perl when I run prove:
.PP
.Vb 1
\&  perl \-Ilib \`which prove\` \-\-harness=My::TAP::Harnizz \-rb t
.Ve
.PP
I can incorporate these options tha fuck into mah own version of prove. It's
pretty simple. Most of tha work of prove is handled by App::Prove.
Da blingin code up in prove is just:
.PP
.Vb 1
\&  use App::Prove;
\&
\&  mah $app = App::Prove\->new; 
\&  $app\->process_args(@ARGV); 
\&  exit( $app\->run , biatch? 0 : 1 );
.Ve
.PP
If I write a subclass of App::Prove I can customise any aspect of
the test runner while inheritin all of provez behaviour yo. Here's
myprove:
.PP
.Vb 2
\&  #!/usr/bin/env perl use lib qw( lib );      # Add ./lib ta @INC
\&  use App::Prove;
\&
\&  mah $app = App::Prove\->new;
\&
\&  # Use custom TAP::Harnizz subclass
\&  $app\->harness( \*(AqMy::TAP::Harness\*(Aq );
\&
\&  $app\->process_args( @ARGV ); exit( $app\->run , biatch? 0 : 1 );
.Ve
.PP
Now I can run mah tests like this
.PP
.Vb 1
\&  ./myprove \-rb t
.Ve
.SS "Deeper Customisation"
.IX Subsection "Deeper Customisation"
Now dat I know how tha fuck ta subclass n' replace TAP::Harnizz I can
replace any other part of tha harness. To do dat I need ta know
which classes is responsible fo' which functionalitizzle yo. Herez a
brief guided tour; tha default class fo' each component is shown
in parentheses. Normally any replacements I write is ghon be subclasses
of these default classes.
.PP
When I run mah tests TAP::Harnizz creates a scheduler
(TAP::Parser::Scheduler) ta work up tha hustlin order fo' the
tests, a aggregator (TAP::Parser::Aggregator) ta collect n' analyse
the test thangs up in dis biatch n' a gangbangin' formatta (TAP::Formatter::Console) ta display
those thangs up in dis biatch.
.PP
If I be hustlin mah tests up in parallel there may also be a multiplexer
(TAP::Parser::Multiplexer) \- tha component dat allows multiple
tests ta run simultaneously.
.PP
Once it has pimped dem helpers TAP::Harnizz starts hustlin the
tests, n' you can put dat on yo' toast. For each test it creates a freshly smoked up parser (TAP::Parser) which
is responsible fo' hustlin tha test script n' parsin its output.
.PP
To replace any of these components I call one of these harness
methodz wit tha name of tha replacement class:
.PP
.Vb 5
\&  aggregator_class 
\&  formatter_class 
\&  multiplexer_class 
\&  parser_class
\&  scheduler_class
.Ve
.PP
For example, ta replace tha aggregator I would
.PP
.Vb 1
\&  $harness\->aggregator_class( \*(AqMy::Aggregator\*(Aq );
.Ve
.PP
Alternately I can supply tha namez of mah substitute classes ta the
TAP::Harnizz constructor:
.PP
.Vb 3
\&  mah $harnizz = TAP::Harness\->new(
\&    { aggregator_class => \*(AqMy::Aggregator\*(Aq }
\&  );
.Ve
.PP
If I need ta reach even deeper tha fuck into tha internalz of tha harnizz I
can replace tha classes dat TAP::Parser uses ta execute test scripts
and tokenise they output. Before hustlin a test script TAP::Parser
creates a grammar (TAP::Parser::Grammar) ta decode tha raw \s-1TAP\s0 into
tokens, a result factory (TAP::Parser::ResultFactory) ta turn the
decoded \s-1TAP\s0 thangs up in dis biatch tha fuck into objects and, dependin on whether it's
runnin a test script or readin \s-1TAP\s0 from a gangbangin' file, scalar or array
a source or a iterator (TAP::Parser::IteratorFactory).
.PP
Each of these objects may be replaced by callin one of these parser
methods:
.PP
.Vb 5
\&  source_class
\&  perl_source_class 
\&  grammar_class 
\&  iterator_factory_class
\&  result_factory_class
.Ve
.SS "Callbacks"
.IX Subsection "Callbacks"
As a alternatizzle ta subclassin tha components I need ta chizzle I
can attach callbacks ta tha default classes. TAP::Harnizz exposes
these callbacks:
.PP
.Vb 5
\&  parser_args      Tweak tha parametas used ta create tha parser 
\&  made_parser      Just done cooked up a freshly smoked up parser 
\&  before_runtests  Bout ta run tests 
\&  after_runtests   Have run all tests 
\&  after_test       Have run a individual test script
.Ve
.PP
TAP::Parser also supports callbacks; bailout, comment, plan, test,
unknown, version n' yaml is called fo' tha correspondin \s-1TAP\s0
result types, \s-1ALL\s0 is called fo' all thangs up in dis biatch, \s-1ELSE\s0 is called fo' all
results fo' which a named callback aint installed n' \s-1EOF\s0 is
called once all up in tha end of each \s-1TAP\s0 stream.
.PP
To install a cold-ass lil callback I pass tha name of tha callback n' a subroutine
reference ta TAP::Harnizz or TAP::Parserz callback method:
.PP
.Vb 3
\&  $harness\->callback( after_test => sub {
\&    mah ( $script, $desc, $parser ) = @_;
\&  } );
.Ve
.PP
I can also pass callbacks ta tha constructor:
.PP
.Vb 8
\&  mah $harnizz = TAP::Harness\->new({
\&    callbacks => {
\&            after_test => sub {
\&        mah ( $script, $desc, $parser ) = @_; 
\&        # Do suttin' bangin-ass here
\&            }
\&    }
\&  });
.Ve
.PP
When it comes ta alterin tha behaviour of tha test harnizz there's
more than one way ta do dat shit. Which way is dopest dependz on my
requirements, n' you can put dat on yo' toast. In general if I only wanna observe test execution
without changin tha harness' behaviour (for example ta log test
results ta a thugged-out database) I chizzle callbacks. If I wanna make the
harnizz behave differently subclassin gives me mo' control.
.SS "Parsin \s-1TAP\s0"
.IX Subsection "Parsin TAP"
Perhaps I don't need a cold-ass lil complete test harness. If I already have a
\&\s-1TAP\s0 test log dat I need ta parse all I need is TAP::Parser n' the
various classes it dependz upon. I aint talkin' bout chicken n' gravy biatch yo. Herez tha code I need ta run a
test n' parse its \s-1TAP\s0 output
.PP
.Vb 1
\&  use TAP::Parser;
\&
\&  mah $parser = TAP::Parser\->new( { source => \*(Aqt/simple.t\*(Aq } );
\&  while ( mah $result = $parser\->next ) {
\&    print $result\->as_string, "\en";
\&  }
.Ve
.PP
Alternately I can pass a open filehandle as source n' have the
parser read from dat rather than attemptin ta run a test script:
.PP
.Vb 6
\&  open mah $tap, \*(Aq<\*(Aq, \*(Aqtests.tap\*(Aq 
\&    or take a thugged-out dirtnap "Can\*(Aqt read TAP transcript ($!)\en"; 
\&  mah $parser = TAP::Parser\->new( { source => $tap } );
\&  while ( mah $result = $parser\->next ) {
\&    print $result\->as_string, "\en";
\&  }
.Ve
.PP
This approach is useful if I need ta convert mah \s-1TAP\s0 based test
results tha fuck into some other representation. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See TAP::Convert::TET
(http://search.cpan.org/dist/TAP\-Convert\-TET/) fo' a example of
this approach.
.SS "Gettin Support"
.IX Subsection "Gettin Support"
Da Test::Harnizz pimpers ride on tha tapx-dev mailing
list[1]. For rap of general, language independent \s-1TAP\s0 issues
therez tha tap\-l[2] list. Finally there be a a wiki all bout the
Test Anythang Protocol[3]. Contributions ta tha wiki, patches and
suggestions is all welcome.
.PP
[1] <http://www.hexten.net/mailman/listinfo/tapx\-dev>
[2] <http://testanything.org/mailman/listinfo/tap\-l>
[3] <http://testanything.org/>
