.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "buffer 3"
.TH buffer 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
BUF_MEM_new, BUF_MEM_free, BUF_MEM_grow, BUF_strdup \- simple
characta arrays structure
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/buffer.h>
\&
\& BUF_MEM *BUF_MEM_new(void);
\&
\& void   BUF_MEM_free(BUF_MEM *a);
\&
\& int    BUF_MEM_grow(BUF_MEM *str, int len);
\&
\& char * BUF_strdup(const char *str);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da buffer library handlez simple characta arrays. Buffers is used for
various purposes up in tha library, most notably memory BIOs.
.PP
Da library uses tha \s-1BUF_MEM\s0 structure defined up in buffer.h:
.PP
.Vb 6
\& typedef struct buf_mem_st
\& {
\&        int length;     /* current number of bytes */
\&        char *data;
\&        int max;        /* size of buffer */
\& } BUF_MEM;
.Ve
.PP
\&\fBlength\fR is tha current size of tha buffer up in bytes, \fBmax\fR is tha amount of
memory allocated ta tha buffer n' shit. There is three functions which handle these
and one \*(L"miscellaneous\*(R" function.
.PP
\&\fIBUF_MEM_new()\fR allocates a freshly smoked up buffer of zero size.
.PP
\&\fIBUF_MEM_free()\fR frees up a already existin buffer n' shit. Da data is zeroed
before freein up in case tha buffer gotz nuff sensitizzle data.
.PP
\&\fIBUF_MEM_grow()\fR chizzlez tha size of a already existin buffer to
\&\fBlen\fR fo' realz. Any data already up in tha buffer is preserved if it increases in
size.
.PP
\&\fIBUF_strdup()\fR copies a null terminated strang tha fuck into a funky-ass block of allocated
memory n' returns a pointa ta tha allocated block.
Unlike tha standard C library \fIstrdup()\fR dis function uses \fIOPENSSL_malloc()\fR n' so
should be used up in preference ta tha standard library \fIstrdup()\fR cuz it can
be used fo' memory leak checkin or replacin tha \fImalloc()\fR function.
.PP
Da memory allocated from \fIBUF_strdup()\fR should be freed up rockin tha \fIOPENSSL_free()\fR
function.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIBUF_MEM_new()\fR returns tha buffer or \s-1NULL\s0 on error.
.PP
\&\fIBUF_MEM_free()\fR has no return value.
.PP
\&\fIBUF_MEM_grow()\fR returns zero on error or tha freshly smoked up size (i.e. \fBlen\fR).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIbio\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIBUF_MEM_new()\fR, \fIBUF_MEM_free()\fR n' \fIBUF_MEM_grow()\fR is available up in all
versionz of SSLeay n' OpenSSL. \fIBUF_strdup()\fR was added up in SSLeay 0.8.
