.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Compress::Zlib 3"
.TH Compress::Zlib 3 "2013-08-11" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Compress::Zlib \- Interface ta zlib compression library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Compress::Zlib ;
\&
\&    ($d, $status) = deflateInit( [OPT] ) ;
\&    $status = $d\->deflate($input, $output) ;
\&    $status = $d\->flush([$flush_type]) ;
\&    $d\->deflateParams(OPTS) ;
\&    $d\->deflateTune(OPTS) ;
\&    $d\->dict_adler() ;
\&    $d\->crc32() ;
\&    $d\->adler32() ;
\&    $d\->total_in() ;
\&    $d\->total_out() ;
\&    $d\->msg() ;
\&    $d\->get_Strategy();
\&    $d\->get_Level();
\&    $d\->get_BufSize();
\&
\&    ($i, $status) = inflateInit( [OPT] ) ;
\&    $status = $i\->inflate($input, $output [, $eof]) ;
\&    $status = $i\->inflateSync($input) ;
\&    $i\->dict_adler() ;
\&    $d\->crc32() ;
\&    $d\->adler32() ;
\&    $i\->total_in() ;
\&    $i\->total_out() ;
\&    $i\->msg() ;
\&    $d\->get_BufSize();
\&
\&    $dest = compress($source) ;
\&    $dest = uncompress($source) ;
\&
\&    $gz = gzopen($filename or filehandle, $mode) ;
\&    $bytesread = $gz\->gzread($buffer [,$size]) ;
\&    $bytesread = $gz\->gzreadline($line) ;
\&    $byteswritten = $gz\->gzwrite($buffer) ;
\&    $status = $gz\->gzflush($flush) ;
\&    $offset = $gz\->gztell() ;
\&    $status = $gz\->gzseek($offset, $whence) ;
\&    $status = $gz\->gzclose() ;
\&    $status = $gz\->gzeof() ;
\&    $status = $gz\->gzsetparams($level, $strategy) ;
\&    $errstrin = $gz\->gzerror() ; 
\&    $gzerrno
\&
\&    $dest = Compress::Zlib::memGzip($buffer) ;
\&    $dest = Compress::Zlib::memGunzip($buffer) ;
\&
\&    $crc = adler32($buffer [,$crc]) ;
\&    $crc = crc32($buffer [,$crc]) ;
\&
\&    $crc = adler32_combine($crc1, $crc2, $len2)l
\&    $crc = crc32_combine($adler1, $adler2, $len2)
\&
\&    mah $version = Compress::Raw::Zlib::zlib_version();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \fICompress::Zlib\fR module serves up a Perl intercourse ta tha \fIzlib\fR
compression library (see \*(L"\s-1AUTHOR\*(R"\s0 fo' details bout where ta get
\&\fIzlib\fR).
.PP
Da \f(CW\*(C`Compress::Zlib\*(C'\fR module can be split tha fuck into two general areas of
functionality, namely a simple read/write intercourse ta \fIgzip\fR files
and a low-level in-memory compression/decompression intercourse.
.PP
Each of these areas is ghon be discussed up in tha followin sections.
.SS "Notes fo' playaz of Compress::Zlib version 1"
.IX Subsection "Notes fo' playaz of Compress::Zlib version 1"
Da main chizzle up in \f(CW\*(C`Compress::Zlib\*(C'\fR version 2.x is dat it do not now
interface directly ta tha zlib library. Instead it uses the
\&\f(CW\*(C`IO::Compress::Gzip\*(C'\fR n' \f(CW\*(C`IO::Uncompress::Gunzip\*(C'\fR modulez for
reading/writin gzip files, n' tha \f(CW\*(C`Compress::Raw::Zlib\*(C'\fR module fo' some
low-level zlib access.
.PP
Da intercourse provided by version 2 of dis module should be 100% backward
compatible wit version 1. If you find a gangbangin' finger-lickin' difference up in tha expected
behaviour please contact tha lyricist (See \*(L"\s-1AUTHOR\*(R"\s0). Right back up in yo muthafuckin ass. See \*(L"\s-1GZIP INTERFACE\*(R"\s0
.PP
With tha creation of tha \f(CW\*(C`IO::Compress\*(C'\fR n' \f(CW\*(C`IO::Uncompress\*(C'\fR modulez no
new features is planned fo' \f(CW\*(C`Compress::Zlib\*(C'\fR \- tha freshly smoked up modulez do
everythang dat \f(CW\*(C`Compress::Zlib\*(C'\fR do n' then some. Development on
\&\f(CW\*(C`Compress::Zlib\*(C'\fR is ghon be limited ta bug fixes only.
.PP
If yo ass is freestylin freshly smoked up code, yo' first port of call should be one of the
new \f(CW\*(C`IO::Compress\*(C'\fR or \f(CW\*(C`IO::Uncompress\*(C'\fR modules.
.SH "GZIP INTERFACE"
.IX Header "GZIP INTERFACE"
A number of functions is supplied up in \fIzlib\fR fo' readin n' writing
\&\fIgzip\fR filez dat conform ta \s-1RFC 1952.\s0 This module serves up a intercourse
to most of em.
.PP
If you have previously used \f(CW\*(C`Compress::Zlib\*(C'\fR 1.x, tha following
enhancements/changes done been made ta tha \f(CW\*(C`gzopen\*(C'\fR intercourse:
.IP "1." 5
If you wanna open either \s-1STDIN\s0 or \s-1STDOUT\s0 wit \f(CW\*(C`gzopen\*(C'\fR, you can now
optionally use tha special filename "\f(CW\*(C`\-\*(C'\fR" as a synonym fo' \f(CW\*(C`\e*STDIN\*(C'\fR and
\&\f(CW\*(C`\e*STDOUT\*(C'\fR.
.IP "2." 5
In \f(CW\*(C`Compress::Zlib\*(C'\fR version 1.x, \f(CW\*(C`gzopen\*(C'\fR used tha zlib library ta open
the underlyin file. This made thangs especially tricky when a Perl
filehandle was passed ta \f(CW\*(C`gzopen\*(C'\fR. Behind tha scenes tha numeric C file
descriptor had ta be extracted from tha Perl filehandle n' dis passed to
the zlib library.
.Sp
Apart from bein non-portable ta some operatin systems, dis made it
hard as fuck ta use \f(CW\*(C`gzopen\*(C'\fR up in thangs where you wanted ta extract/create
a gzip data stream dat is embedded up in a larger file, without havin to
resort ta openin n' closin tha file multiple times.
.Sp
It also juiced it up impossible ta pass a perl filehandle dat wasn't associated
with a real filesystem file, like, say, a \f(CW\*(C`IO::String\*(C'\fR.
.Sp
In \f(CW\*(C`Compress::Zlib\*(C'\fR version 2.x, tha \f(CW\*(C`gzopen\*(C'\fR intercourse has been
completely rewritten ta use tha IO::Compress::Gzip
for freestylin gzip filez n' IO::Uncompress::Gunzip
for readin gzip files. None of tha limitations mentioned above apply.
.IP "3." 5
Addizzle of \f(CW\*(C`gzseek\*(C'\fR ta provide a restricted \f(CW\*(C`seek\*(C'\fR intercourse.
.IP "4." 5
Added \f(CW\*(C`gztell\*(C'\fR.
.PP
A mo' complete n' flexible intercourse fo' reading/writin gzip
files/buffers is included wit tha module \f(CW\*(C`IO\-Compress\-Zlib\*(C'\fR. Right back up in yo muthafuckin ass. See
IO::Compress::Gzip and
IO::Uncompress::Gunzip fo' mo' details.
.ie n .IP "\fB\fB$gz\fB = gzopen($filename, \f(BI$mode\fB)\fR" 5
.el .IP "\fB\f(CB$gz\fB = gzopen($filename, \f(CB$mode\fB)\fR" 5
.IX Item "$gz = gzopen($filename, $mode)"
.PD 0
.ie n .IP "\fB\fB$gz\fB = gzopen($filehandle, \f(BI$mode\fB)\fR" 5
.el .IP "\fB\f(CB$gz\fB = gzopen($filehandle, \f(CB$mode\fB)\fR" 5
.IX Item "$gz = gzopen($filehandle, $mode)"
.PD
This function opens either tha \fIgzip\fR file \f(CW$filename\fR fo' readin or
writin or attaches ta tha opened filehandle, \f(CW$filehandle\fR. 
It returns a object on success n' \f(CW\*(C`undef\*(C'\fR on failure.
.Sp
When freestylin a gzip file dis intercourse will \fIalways\fR create tha smallest
possible gzip header (exactly 10 bytes). If you want pimped outa control over
what gets stored up in tha gzip header (like tha original gangsta filename or a
comment) use IO::Compress::Gzip instead. Y'all KNOW dat shit, muthafucka! Similarly if
you wanna read tha contentz of tha gzip header use
IO::Uncompress::Gunzip.
.Sp
Da second parameter, \f(CW$mode\fR, is used ta specify whether tha file is
opened fo' readin or freestylin n' ta optionally specify a cold-ass lil compression
level n' compression game when writing. Da format of tha \f(CW$mode\fR
parameta is similar ta tha mode parameta ta tha 'C' function \f(CW\*(C`fopen\*(C'\fR,
so \*(L"rb\*(R" is used ta open fo' reading, \*(L"wb\*(R" fo' freestylin n' \*(L"ab\*(R" for
appendin (writin all up in tha end of tha file).
.Sp
To specify a cold-ass lil compression level when writing, append a gangbangin' finger-lickin' digit between 0
and 9 ta tha mode strang \*(-- 0 means no compression n' 9 means maximum
compression.
If no compression level is specified Z_DEFAULT_COMPRESSION is used.
.Sp
To specify tha compression game when writing, append 'f' fo' filtered
data, 'h' fo' Huffman only compression, or 'R' fo' run-length encoding.
If no game is specified Z_DEFAULT_STRATEGY is used.
.Sp
So, fo' example, \*(L"wb9\*(R" means open fo' freestylin wit tha maximum compression
usin tha default game n' \*(L"wb4R\*(R" means open fo' freestylin wit compression
level 4 n' run-length encoding.
.Sp
Refer ta tha \fIzlib\fR documentation fo' tha exact format of tha \f(CW$mode\fR
parameter.
.ie n .IP "\fB\fB$bytesread\fB = \f(BI$gz\fB\->gzread($buffer [, \f(CB$size\fB]) ;\fR" 5
.el .IP "\fB\f(CB$bytesread\fB = \f(CB$gz\fB\->gzread($buffer [, \f(CB$size\fB]) ;\fR" 5
.IX Item "$bytesread = $gz->gzread($buffer [, $size]) ;"
Readz \f(CW$size\fR bytes from tha compressed file tha fuck into \f(CW$buffer\fR. If
\&\f(CW$size\fR aint specified, it will default ta 4096. If tha scalar
\&\f(CW$buffer\fR aint big-ass enough, it is ghon be extended automatically.
.Sp
Returns tha number of bytes straight-up read. Y'all KNOW dat shit, muthafucka! On \s-1EOF\s0 it returns 0 n' in
the case of a error, \-1.
.ie n .IP "\fB\fB$bytesread\fB = \f(BI$gz\fB\->gzreadline($line) ;\fR" 5
.el .IP "\fB\f(CB$bytesread\fB = \f(CB$gz\fB\->gzreadline($line) ;\fR" 5
.IX Item "$bytesread = $gz->gzreadline($line) ;"
Readz tha next line from tha compressed file tha fuck into \f(CW$line\fR.
.Sp
Returns tha number of bytes straight-up read. Y'all KNOW dat shit, muthafucka! On \s-1EOF\s0 it returns 0 n' in
the case of a error, \-1.
.Sp
It be legal ta intermix calls ta \f(CW\*(C`gzread\*(C'\fR n' \f(CW\*(C`gzreadline\*(C'\fR.
.Sp
To maintain backward compatibilitizzle wit version 1.x of dis module
\&\f(CW\*(C`gzreadline\*(C'\fR ignores tha \f(CW$/\fR variable \- it \fIalways\fR uses tha string
\&\f(CW"\en"\fR as tha line delimiter.
.Sp
If you wanna read a gzip file a line at a time n' have it respect the
\&\f(CW$/\fR variable (or \f(CW$INPUT_RECORD_SEPARATOR\fR, or \f(CW$RS\fR when \f(CW\*(C`English\*(C'\fR is
in use) peep IO::Uncompress::Gunzip.
.ie n .IP "\fB\fB$byteswritten\fB = \f(BI$gz\fB\->gzwrite($buffer) ;\fR" 5
.el .IP "\fB\f(CB$byteswritten\fB = \f(CB$gz\fB\->gzwrite($buffer) ;\fR" 5
.IX Item "$byteswritten = $gz->gzwrite($buffer) ;"
Writes tha contentz of \f(CW$buffer\fR ta tha compressed file. Returns the
number of bytes straight-up written, or 0 on error.
.ie n .IP "\fB\fB$status\fB = \f(BI$gz\fB\->gzflush($flush_type) ;\fR" 5
.el .IP "\fB\f(CB$status\fB = \f(CB$gz\fB\->gzflush($flush_type) ;\fR" 5
.IX Item "$status = $gz->gzflush($flush_type) ;"
Flushes all pendin output tha fuck into tha compressed file.
.Sp
This method takes a optionizzle parameter, \f(CW$flush_type\fR, dat controls
how tha flushin is ghon be carried out. By default tha \f(CW$flush_type\fR
used is \f(CW\*(C`Z_FINISH\*(C'\fR. Other valid joints fo' \f(CW$flush_type\fR are
\&\f(CW\*(C`Z_NO_FLUSH\*(C'\fR, \f(CW\*(C`Z_SYNC_FLUSH\*(C'\fR, \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR n' \f(CW\*(C`Z_BLOCK\*(C'\fR. Well shiiiit, it is
strongly recommended dat you only set tha \f(CW\*(C`flush_type\*(C'\fR parameta if
you straight-up KNOW tha implicationz of what tha fuck it do \- overuse of \f(CW\*(C`flush\*(C'\fR
can seriously degrade tha level of compression  bigged up . Y'all KNOW dat shit, muthafucka! See tha \f(CW\*(C`zlib\*(C'\fR
documentation fo' details.
.Sp
Returns 0 on success.
.ie n .IP "\fB\fB$offset\fB = \f(BI$gz\fB\->\f(BIgztell()\fB ;\fR" 5
.el .IP "\fB\f(CB$offset\fB = \f(CB$gz\fB\->\f(BIgztell()\fB ;\fR" 5
.IX Item "$offset = $gz->gztell() ;"
Returns tha uncompressed file offset.
.ie n .IP "\fB\fB$status\fB = \f(BI$gz\fB\->gzseek($offset, \f(CB$whence\fB) ;\fR" 5
.el .IP "\fB\f(CB$status\fB = \f(CB$gz\fB\->gzseek($offset, \f(CB$whence\fB) ;\fR" 5
.IX Item "$status = $gz->gzseek($offset, $whence) ;"
Provides a sub-set of tha \f(CW\*(C`seek\*(C'\fR functionality, wit tha restriction
that it is only legal ta seek forward up in tha compressed file.
It be a gangbangin' fatal error ta attempt ta seek backward.
.Sp
When opened fo' writing, empty partz of tha file gonna git \s-1NULL \s0(0x00)
bytes freestyled ta em.
.Sp
Da \f(CW$whence\fR parameta should be one of \s-1SEEK_SET, SEEK_CUR\s0 or \s-1SEEK_END.\s0
.Sp
Returns 1 on success, 0 on failure.
.ie n .IP "\fB\fB$gz\fB\->gzclose\fR" 5
.el .IP "\fB\f(CB$gz\fB\->gzclose\fR" 5
.IX Item "$gz->gzclose"
Closes tha compressed file fo' realz. Any pendin data is flushed ta tha file
before it is closed.
.Sp
Returns 0 on success.
.ie n .IP "\fB\fB$gz\fB\->gzsetparams($level, \f(BI$strategy\fB\fR" 5
.el .IP "\fB\f(CB$gz\fB\->gzsetparams($level, \f(CB$strategy\fB\fR" 5
.IX Item "$gz->gzsetparams($level, $strategy"
Change settings fo' tha deflate stream \f(CW$gz\fR.
.Sp
Da list of tha valid options is shown below. Options not specified
will remain unchanged.
.Sp
Note: This method is only available if yo ass is hustlin zlib 1.0.6 or better.
.RS 5
.ie n .IP "\fB\fB$level\fB\fR" 5
.el .IP "\fB\f(CB$level\fB\fR" 5
.IX Item "$level"
Defines tha compression level. Valid joints is 0 all up in 9,
\&\f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR, \f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, and
\&\f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
.ie n .IP "\fB\fB$strategy\fB\fR" 5
.el .IP "\fB\f(CB$strategy\fB\fR" 5
.IX Item "$strategy"
Defines tha game used ta tune tha compression. I aint talkin' bout chicken n' gravy biatch. Da valid joints are
\&\f(CW\*(C`Z_DEFAULT_STRATEGY\*(C'\fR, \f(CW\*(C`Z_FILTERED\*(C'\fR n' \f(CW\*(C`Z_HUFFMAN_ONLY\*(C'\fR.
.RE
.RS 5
.RE
.ie n .IP "\fB\fB$gz\fB\->gzerror\fR" 5
.el .IP "\fB\f(CB$gz\fB\->gzerror\fR" 5
.IX Item "$gz->gzerror"
Returns tha \fIzlib\fR error message or number fo' tha last operation
associated wit \f(CW$gz\fR. Da return value is ghon be tha \fIzlib\fR error
number when used up in a numeric context n' tha \fIzlib\fR error message
when used up in a strang context. Da \fIzlib\fR error number constants,
shown below, is available fo' use.
.Sp
.Vb 7
\&    Z_OK
\&    Z_STREAM_END
\&    Z_ERRNO
\&    Z_STREAM_ERROR
\&    Z_DATA_ERROR
\&    Z_MEM_ERROR
\&    Z_BUF_ERROR
.Ve
.ie n .IP "\fB\fB$gzerrno\fB\fR" 5
.el .IP "\fB\f(CB$gzerrno\fB\fR" 5
.IX Item "$gzerrno"
Da \f(CW$gzerrno\fR scalar holdz tha error code associated wit da most thugged-out
recent \fIgzip\fR routine. Note dat unlike \f(CW\*(C`gzerror()\*(C'\fR, tha error is
\&\fInot\fR associated wit a particular file.
.Sp
As wit \f(CW\*(C`gzerror()\*(C'\fR it returns a error number up in numeric context and
an error message up in strang context. Unlike \f(CW\*(C`gzerror()\*(C'\fR though, the
error message will correspond ta tha \fIzlib\fR message when tha error is
associated wit \fIzlib\fR itself, or tha \s-1UNIX\s0 error message when it is
not (i.e. \fIzlib\fR returned \f(CW\*(C`Z_ERRORNO\*(C'\fR).
.Sp
As there be a overlap between tha error numbers used by \fIzlib\fR and
\&\s-1UNIX, \s0\f(CW$gzerrno\fR should only be used ta check fo' tha presence of
\&\fIan\fR error up in numeric context. Use \f(CW\*(C`gzerror()\*(C'\fR ta check fo' specific
\&\fIzlib\fR errors. Da \fIgzcat\fR example below shows how tha fuck tha variable can
be used safely.
.SS "Examples"
.IX Subsection "Examples"
Here be a example script which uses tha intercourse. Well shiiiit, it implements a
\&\fIgzcat\fR function.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&    
\&    use Compress::Zlib ;
\&    
\&    # use stdin if no filez supplied
\&    @ARGV = \*(Aq\-\*(Aq unless @ARGV ;
\&    
\&    foreach mah $file (@ARGV) {
\&        mah $buffer ;
\&    
\&        mah $gz = gzopen($file, "rb") 
\&             or take a thugged-out dirtnap "Cannot open $file: $gzerrno\en" ;
\&    
\&        print $buffer while $gz\->gzread($buffer) > 0 ;
\&    
\&        take a thugged-out dirtnap "Error readin from $file: $gzerrno" . ($gzerrno+0) . "\en" 
\&            if $gzerrno != Z_STREAM_END ;
\&        
\&        $gz\->gzclose() ;
\&    }
.Ve
.PP
Below be a script which make use of \f(CW\*(C`gzreadline\*(C'\fR. Well shiiiit, it implements a
very simple \fIgrep\fR like script.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&    
\&    use Compress::Zlib ;
\&    
\&    take a thugged-out dirtnap "Usage: gzgrep pattern [file...]\en"
\&        unless @ARGV >= 1;
\&    
\&    mah $pattern = shift ;
\&    
\&    # use stdin if no filez supplied
\&    @ARGV = \*(Aq\-\*(Aq unless @ARGV ;
\&    
\&    foreach mah $file (@ARGV) {
\&        mah $gz = gzopen($file, "rb") 
\&             or take a thugged-out dirtnap "Cannot open $file: $gzerrno\en" ;
\&    
\&        while ($gz\->gzreadline($_) > 0) {
\&            print if /$pattern/ ;
\&        }
\&    
\&        take a thugged-out dirtnap "Error readin from $file: $gzerrno\en" 
\&            if $gzerrno != Z_STREAM_END ;
\&        
\&        $gz\->gzclose() ;
\&    }
.Ve
.PP
This script, \fIgzstream\fR, do tha opposite of tha \fIgzcat\fR script
above. Well shiiiit, it readz from standard input n' writes a gzip data stream to
standard output.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&    
\&    use Compress::Zlib ;
\&    
\&    binmode STDOUT;  # gzopen only sets it on tha fd
\&    
\&    mah $gz = gzopen(\e*STDOUT, "wb")
\&          or take a thugged-out dirtnap "Cannot open stdout: $gzerrno\en" ;
\&    
\&    while (<>) {
\&        $gz\->gzwrite($_) 
\&          or take a thugged-out dirtnap "error writing: $gzerrno\en" ;
\&    }
\&
\&    $gz\->gzclose ;
.Ve
.SS "Compress::Zlib::memGzip"
.IX Subsection "Compress::Zlib::memGzip"
This function is used ta create a in-memory gzip file wit tha minimum
possible gzip header (exactly 10 bytes).
.PP
.Vb 2
\&    $dest = Compress::Zlib::memGzip($buffer) 
\&        or take a thugged-out dirtnap "Cannot compress: $gzerrno\en";
.Ve
.PP
If successful, it returns tha in-memory gzip file. Otherwise it returns
\&\f(CW\*(C`undef\*(C'\fR n' tha \f(CW$gzerrno\fR variable will store tha zlib error code.
.PP
Da \f(CW$buffer\fR parameta can either be a scalar or a scalar reference.
.PP
See IO::Compress::Gzip fo' a alternatizzle way to
carry up in-memory gzip compression.
.SS "Compress::Zlib::memGunzip"
.IX Subsection "Compress::Zlib::memGunzip"
This function is used ta uncompress a in-memory gzip file.
.PP
.Vb 2
\&    $dest = Compress::Zlib::memGunzip($buffer) 
\&        or take a thugged-out dirtnap "Cannot uncompress: $gzerrno\en";
.Ve
.PP
If successful, it returns tha uncompressed gzip file. Otherwise it
returns \f(CW\*(C`undef\*(C'\fR n' tha \f(CW$gzerrno\fR variable will store tha zlib error
code.
.PP
Da \f(CW$buffer\fR parameta can either be a scalar or a scalar reference. The
contentz of tha \f(CW$buffer\fR parameta is destroyed afta callin dis function.
.PP
If \f(CW$buffer\fR consistz of multiple concatenated gzip data streams only the
first is ghon be uncompressed. Y'all KNOW dat shit, muthafucka! Use \f(CW\*(C`gunzip\*(C'\fR wit tha \f(CW\*(C`MultiStream\*(C'\fR option in
the \f(CW\*(C`IO::Uncompress::Gunzip\*(C'\fR module if you need ta deal wit concatenated
data streams.
.PP
See IO::Uncompress::Gunzip fo' a alternatizzle way
to carry up in-memory gzip uncompression.
.SH "COMPRESS/UNCOMPRESS"
.IX Header "COMPRESS/UNCOMPRESS"
Two functions is provided ta big-ass up in-memory compression/uncompression of
\&\s-1RFC 1950\s0 data streams. They is called \f(CW\*(C`compress\*(C'\fR n' \f(CW\*(C`uncompress\*(C'\fR.
.ie n .IP "\fB\fB$dest\fB = compress($source [, \f(BI$level\fB] ) ;\fR" 5
.el .IP "\fB\f(CB$dest\fB = compress($source [, \f(CB$level\fB] ) ;\fR" 5
.IX Item "$dest = compress($source [, $level] ) ;"
Compresses \f(CW$source\fR. If successful it returns tha compressed
data. Otherwise it returns \fIundef\fR.
.Sp
Da source buffer, \f(CW$source\fR, can either be a scalar or a scalar
reference.
.Sp
Da \f(CW$level\fR parameta defines tha compression level. Valid joints are
0 all up in 9, \f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR,
\&\f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, n' \f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
If \f(CW$level\fR aint specified \f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR is ghon be used.
.ie n .IP "\fB\fB$dest\fB = uncompress($source) ;\fR" 5
.el .IP "\fB\f(CB$dest\fB = uncompress($source) ;\fR" 5
.IX Item "$dest = uncompress($source) ;"
Uncompresses \f(CW$source\fR. If successful it returns tha uncompressed
data. Otherwise it returns \fIundef\fR.
.Sp
Da source buffer can either be a scalar or a scalar reference.
.PP
Please note: tha two functions defined above is \fInot\fR compatible with
the Unix commandz of tha same name.
.PP
See IO::Deflate n' IO::Inflate included with
this distribution fo' a alternatizzle intercourse fo' reading/writin \s-1RFC 1950\s0
files/buffers.
.SH "Deflate Interface"
.IX Header "Deflate Interface"
This section defines a intercourse dat allows in-memory compression using
the \fIdeflate\fR intercourse provided by zlib.
.PP
Here be a thugged-out definizzle of tha intercourse available:
.ie n .SS "\fB($d, \fP\fB$status\fP\fB) = deflateInit( [\s-1OPT\s0] )\fP"
.el .SS "\fB($d, \fP\f(CB$status\fP\fB) = deflateInit( [\s-1OPT\s0] )\fP"
.IX Subsection "($d, $status) = deflateInit( [OPT] )"
Initialises a thugged-out deflation stream.
.PP
It combines tha featurez of tha \fIzlib\fR functions \f(CW\*(C`deflateInit\*(C'\fR,
\&\f(CW\*(C`deflateInit2\*(C'\fR n' \f(CW\*(C`deflateSetDictionary\*(C'\fR.
.PP
If successful, it will return tha initialised deflation stream, \f(CW$d\fR
and \f(CW$status\fR of \f(CW\*(C`Z_OK\*(C'\fR up in a list context. In scalar context it
returns tha deflation stream, \f(CW$d\fR, only.
.PP
If not successful, tha returned deflation stream (\f(CW$d\fR) will be
\&\fIundef\fR n' \f(CW$status\fR will hold tha exact \fIzlib\fR error code.
.PP
Da function optionally takes a fuckin shitload of named options specified as
\&\f(CW\*(C`\-Name=>value\*(C'\fR pairs. This allows individual options ta be
tailored without havin ta specify dem all up in tha parameta list.
.PP
For backward compatibility, it be also possible ta pass tha parameters
as a reference ta a hash containin tha name=>value pairs.
.PP
Da function takes one optionizzle parameter, a reference ta a hash.  The
contentz of tha hash allow tha deflation intercourse ta be tailored.
.PP
Here be a list of tha valid options:
.IP "\fB\-Level\fR" 5
.IX Item "-Level"
Defines tha compression level. Valid joints is 0 all up in 9,
\&\f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR, \f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, and
\&\f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
.Sp
Da default is Z_DEFAULT_COMPRESSION.
.IP "\fB\-Method\fR" 5
.IX Item "-Method"
Defines tha compression method. Y'all KNOW dat shit, muthafucka! Da only valid value at present (and
the default) is Z_DEFLATED.
.IP "\fB\-WindowBits\fR" 5
.IX Item "-WindowBits"
To create a \s-1RFC 1950\s0 data stream, set \f(CW\*(C`WindowBits\*(C'\fR ta a positizzle number.
.Sp
To create a \s-1RFC 1951\s0 data stream, set \f(CW\*(C`WindowBits\*(C'\fR ta \f(CW\*(C`\-MAX_WBITS\*(C'\fR.
.Sp
For a gangbangin' full definizzle of tha meanin n' valid joints fo' \f(CW\*(C`WindowBits\*(C'\fR refer
to tha \fIzlib\fR documentation fo' \fIdeflateInit2\fR.
.Sp
Defaults ta \s-1MAX_WBITS.\s0
.IP "\fB\-MemLevel\fR" 5
.IX Item "-MemLevel"
For a thugged-out definizzle of tha meanin n' valid joints fo' \f(CW\*(C`MemLevel\*(C'\fR
refer ta tha \fIzlib\fR documentation fo' \fIdeflateInit2\fR.
.Sp
Defaults ta \s-1MAX_MEM_LEVEL.\s0
.IP "\fB\-Strategy\fR" 5
.IX Item "-Strategy"
Defines tha game used ta tune tha compression. I aint talkin' bout chicken n' gravy biatch. Da valid joints are
\&\f(CW\*(C`Z_DEFAULT_STRATEGY\*(C'\fR, \f(CW\*(C`Z_FILTERED\*(C'\fR n' \f(CW\*(C`Z_HUFFMAN_ONLY\*(C'\fR.
.Sp
Da default is Z_DEFAULT_STRATEGY.
.IP "\fB\-Dictionary\fR" 5
.IX Item "-Dictionary"
When a gangbangin' finger-lickin' doggtionary is specified \fICompress::Zlib\fR will automatically
call \f(CW\*(C`deflateSetDictionary\*(C'\fR directly afta callin \f(CW\*(C`deflateInit\*(C'\fR. The
Adler32 value fo' tha doggtionary can be obtained by callin tha method 
\&\f(CW\*(C`$d\-\*(C'\fR\fIdict_adler()\fR>.
.Sp
Da default is no dictionary.
.IP "\fB\-Bufsize\fR" 5
.IX Item "-Bufsize"
Sets tha initial size fo' tha deflation buffer n' shit. If tha buffer has ta be
reallocated ta increase tha size, it will grow up in increments of
\&\f(CW\*(C`Bufsize\*(C'\fR.
.Sp
Da default is 4096.
.PP
Here be a example of rockin tha \f(CW\*(C`deflateInit\*(C'\fR optionizzle parameta list
to override tha default buffer size n' compression level fo' realz. All other
options will take they default joints.
.PP
.Vb 2
\&    deflateInit( \-Bufsize => 300, 
\&                 \-Level => Z_BEST_SPEED  ) ;
.Ve
.ie n .SS "\fB($out, \fP\fB$status\fP\fB) = \fP\fB$d\fP\fB\->deflate($buffer)\fP"
.el .SS "\fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$d\fP\fB\->deflate($buffer)\fP"
.IX Subsection "($out, $status) = $d->deflate($buffer)"
Deflates tha contentz of \f(CW$buffer\fR. Da buffer can either be a scalar
or a scalar reference.  When finished, \f(CW$buffer\fR will be
completely processed (assumin there was no errors). If tha deflation
was successful it returns tha deflated output, \f(CW$out\fR, n' a status
value, \f(CW$status\fR, of \f(CW\*(C`Z_OK\*(C'\fR.
.PP
On error, \f(CW$out\fR is ghon be \fIundef\fR n' \f(CW$status\fR will contain the
\&\fIzlib\fR error code.
.PP
In a scalar context \f(CW\*(C`deflate\*(C'\fR will return \f(CW$out\fR only.
.PP
As wit tha \fIdeflate\fR function up in \fIzlib\fR, it aint necessarily the
case dat any output is ghon be produced by dis method. Y'all KNOW dat shit, muthafucka! So don't rely on
the fact dat \f(CW$out\fR is empty fo' a error test.
.ie n .SS "\fB($out, \fP\fB$status\fP\fB) = \fP\fB$d\fP\fB\->\fP\f(BIflush()\fP\fB\fP =head2 \fB($out, \fP\fB$status\fP\fB) = \fP\fB$d\fP\fB\->flush($flush_type)\fP"
.el .SS "\fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$d\fP\fB\->\fP\f(BIflush()\fP\fB\fP =head2 \fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$d\fP\fB\->flush($flush_type)\fP"
.IX Subsection "($out, $status) = $d->flush() =head2 ($out, $status) = $d->flush($flush_type)"
Typically used ta finish tha deflation. I aint talkin' bout chicken n' gravy biatch fo' realz. Any pendin output will be
returned via \f(CW$out\fR.
\&\f(CW$status\fR gonna git a value \f(CW\*(C`Z_OK\*(C'\fR if successful.
.PP
In a scalar context \f(CW\*(C`flush\*(C'\fR will return \f(CW$out\fR only.
.PP
Note dat flushin can seriously degrade tha compression ratio, so it
should only be used ta terminizzle a thugged-out decompression (usin \f(CW\*(C`Z_FINISH\*(C'\fR) or
when you wanna create a \fIfull flush point\fR (usin \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR).
.PP
By default tha \f(CW\*(C`flush_type\*(C'\fR used is \f(CW\*(C`Z_FINISH\*(C'\fR. Other valid joints
for \f(CW\*(C`flush_type\*(C'\fR is \f(CW\*(C`Z_NO_FLUSH\*(C'\fR, \f(CW\*(C`Z_PARTIAL_FLUSH\*(C'\fR, \f(CW\*(C`Z_SYNC_FLUSH\*(C'\fR
and \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR. Well shiiiit, it is straight fuckin recommended dat you only set the
\&\f(CW\*(C`flush_type\*(C'\fR parameta if you straight-up KNOW tha implications of
what it do. Right back up in yo muthafuckin ass. See tha \f(CW\*(C`zlib\*(C'\fR documentation fo' details.
.ie n .SS "\fB\fP\fB$status\fP\fB = \fP\fB$d\fP\fB\->deflateParams([\s-1OPT\s0])\fP"
.el .SS "\fB\fP\f(CB$status\fP\fB = \fP\f(CB$d\fP\fB\->deflateParams([\s-1OPT\s0])\fP"
.IX Subsection "$status = $d->deflateParams([OPT])"
Change settings fo' tha deflate stream \f(CW$d\fR.
.PP
Da list of tha valid options is shown below. Options not specified
will remain unchanged.
.IP "\fB\-Level\fR" 5
.IX Item "-Level"
Defines tha compression level. Valid joints is 0 all up in 9,
\&\f(CW\*(C`Z_NO_COMPRESSION\*(C'\fR, \f(CW\*(C`Z_BEST_SPEED\*(C'\fR, \f(CW\*(C`Z_BEST_COMPRESSION\*(C'\fR, and
\&\f(CW\*(C`Z_DEFAULT_COMPRESSION\*(C'\fR.
.IP "\fB\-Strategy\fR" 5
.IX Item "-Strategy"
Defines tha game used ta tune tha compression. I aint talkin' bout chicken n' gravy biatch. Da valid joints are
\&\f(CW\*(C`Z_DEFAULT_STRATEGY\*(C'\fR, \f(CW\*(C`Z_FILTERED\*(C'\fR n' \f(CW\*(C`Z_HUFFMAN_ONLY\*(C'\fR.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BIdict_adler()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BIdict_adler()\fP\fB\fP"
.IX Subsection "$d->dict_adler()"
Returns tha adler32 value fo' tha dictionary.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BImsg()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BImsg()\fP\fB\fP"
.IX Subsection "$d->msg()"
Returns tha last error message generated by zlib.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BItotal_in()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BItotal_in()\fP\fB\fP"
.IX Subsection "$d->total_in()"
Returns tha total number of bytes uncompressed bytes input ta deflate.
.ie n .SS "\fB\fP\fB$d\fP\fB\->\fP\f(BItotal_out()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$d\fP\fB\->\fP\f(BItotal_out()\fP\fB\fP"
.IX Subsection "$d->total_out()"
Returns tha total number of compressed bytes output from deflate.
.SS "Example"
.IX Subsection "Example"
Here be a trivial example of rockin \f(CW\*(C`deflate\*(C'\fR. Well shiiiit, it simply readz standard
input, deflates it n' writes it ta standard output.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&
\&    use Compress::Zlib ;
\&
\&    binmode STDIN;
\&    binmode STDOUT;
\&    mah $x = deflateInit()
\&       or take a thugged-out dirtnap "Cannot create a thugged-out deflation stream\en" ;
\&
\&    mah ($output, $status) ;
\&    while (<>)
\&    {
\&        ($output, $status) = $x\->deflate($_) ;
\&    
\&        $status == Z_OK
\&            or take a thugged-out dirtnap "deflation failed\en" ;
\&    
\&        print $output ;
\&    }
\&    
\&    ($output, $status) = $x\->flush() ;
\&    
\&    $status == Z_OK
\&        or take a thugged-out dirtnap "deflation failed\en" ;
\&    
\&    print $output ;
.Ve
.SH "Inflate Interface"
.IX Header "Inflate Interface"
This section defines tha intercourse available dat allows in-memory
uncompression rockin tha \fIdeflate\fR intercourse provided by zlib.
.PP
Here be a thugged-out definizzle of tha intercourse:
.ie n .SS "\fB($i, \fP\fB$status\fP\fB) = \fP\f(BIinflateInit()\fP\fB\fP"
.el .SS "\fB($i, \fP\f(CB$status\fP\fB) = \fP\f(BIinflateInit()\fP\fB\fP"
.IX Subsection "($i, $status) = inflateInit()"
Initialises a inflation stream.
.PP
In a list context it returns tha inflation stream, \f(CW$i\fR, n' the
\&\fIzlib\fR status code up in \f(CW$status\fR. In a scalar context it returns the
inflation stream only.
.PP
If successful, \f(CW$i\fR will hold tha inflation stream n' \f(CW$status\fR will
be \f(CW\*(C`Z_OK\*(C'\fR.
.PP
If not successful, \f(CW$i\fR is ghon be \fIundef\fR n' \f(CW$status\fR will hold the
\&\fIzlib\fR error code.
.PP
Da function optionally takes a fuckin shitload of named options specified as
\&\f(CW\*(C`\-Name=>value\*(C'\fR pairs. This allows individual options ta be
tailored without havin ta specify dem all up in tha parameta list.
.PP
For backward compatibility, it be also possible ta pass tha parameters
as a reference ta a hash containin tha name=>value pairs.
.PP
Da function takes one optionizzle parameter, a reference ta a hash.  The
contentz of tha hash allow tha deflation intercourse ta be tailored.
.PP
Here be a list of tha valid options:
.IP "\fB\-WindowBits\fR" 5
.IX Item "-WindowBits"
To uncompress a \s-1RFC 1950\s0 data stream, set \f(CW\*(C`WindowBits\*(C'\fR ta a positizzle number.
.Sp
To uncompress a \s-1RFC 1951\s0 data stream, set \f(CW\*(C`WindowBits\*(C'\fR ta \f(CW\*(C`\-MAX_WBITS\*(C'\fR.
.Sp
For a gangbangin' full definizzle of tha meanin n' valid joints fo' \f(CW\*(C`WindowBits\*(C'\fR refer
to tha \fIzlib\fR documentation fo' \fIinflateInit2\fR.
.Sp
Defaults ta \s-1MAX_WBITS.\s0
.IP "\fB\-Bufsize\fR" 5
.IX Item "-Bufsize"
Sets tha initial size fo' tha inflation buffer n' shit. If tha buffer has ta be
reallocated ta increase tha size, it will grow up in increments of
\&\f(CW\*(C`Bufsize\*(C'\fR.
.Sp
Default is 4096.
.IP "\fB\-Dictionary\fR" 5
.IX Item "-Dictionary"
Da default is no dictionary.
.PP
Here be a example of rockin tha \f(CW\*(C`inflateInit\*(C'\fR optionizzle parameta to
override tha default buffer size.
.PP
.Vb 1
\&    inflateInit( \-Bufsize => 300 ) ;
.Ve
.ie n .SS "\fB($out, \fP\fB$status\fP\fB) = \fP\fB$i\fP\fB\->inflate($buffer)\fP"
.el .SS "\fB($out, \fP\f(CB$status\fP\fB) = \fP\f(CB$i\fP\fB\->inflate($buffer)\fP"
.IX Subsection "($out, $status) = $i->inflate($buffer)"
Inflates tha complete contentz of \f(CW$buffer\fR. Da buffer can either be
a scalar or a scalar reference.
.PP
Returns \f(CW\*(C`Z_OK\*(C'\fR if successful n' \f(CW\*(C`Z_STREAM_END\*(C'\fR if tha end of the
compressed data has been successfully reached. Y'all KNOW dat shit, muthafucka! 
If not successful, \f(CW$out\fR is ghon be \fIundef\fR n' \f(CW$status\fR will hold
the \fIzlib\fR error code.
.PP
Da \f(CW$buffer\fR parameta is modified by \f(CW\*(C`inflate\*(C'\fR. On completion it
will contain what tha fuck remainz of tha input buffer afta inflation. I aint talkin' bout chicken n' gravy biatch. This
means dat \f(CW$buffer\fR is ghon be a empty strang when tha return status is
\&\f(CW\*(C`Z_OK\*(C'\fR. When tha return status is \f(CW\*(C`Z_STREAM_END\*(C'\fR tha \f(CW$buffer\fR
parameta will gotz nuff what tha fuck (if anything) was stored up in tha input
buffer afta tha deflated data stream.
.PP
This feature is useful when processin a gangbangin' file format dat encapsulates
a  compressed data stream (e.g. gzip, zip).
.ie n .SS "\fB\fP\fB$status\fP\fB = \fP\fB$i\fP\fB\->inflateSync($buffer)\fP"
.el .SS "\fB\fP\f(CB$status\fP\fB = \fP\f(CB$i\fP\fB\->inflateSync($buffer)\fP"
.IX Subsection "$status = $i->inflateSync($buffer)"
Scans \f(CW$buffer\fR until it reaches either a \fIfull flush point\fR or the
end of tha buffer.
.PP
If a \fIfull flush point\fR is found, \f(CW\*(C`Z_OK\*(C'\fR is returned n' \f(CW$buffer\fR
will be have all data up ta tha flush point removed. Y'all KNOW dat shit, muthafucka! This can then be
passed ta tha \f(CW\*(C`deflate\*(C'\fR method.
.PP
Any other return code means dat a gangbangin' flush point was not found. Y'all KNOW dat shit, muthafucka! If more
data be available, \f(CW\*(C`inflateSync\*(C'\fR can be called repeatedly wit more
compressed data until tha flush point is found.
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BIdict_adler()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BIdict_adler()\fP\fB\fP"
.IX Subsection "$i->dict_adler()"
Returns tha adler32 value fo' tha dictionary.
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BImsg()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BImsg()\fP\fB\fP"
.IX Subsection "$i->msg()"
Returns tha last error message generated by zlib.
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BItotal_in()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BItotal_in()\fP\fB\fP"
.IX Subsection "$i->total_in()"
Returns tha total number of bytes compressed bytes input ta inflate.
.ie n .SS "\fB\fP\fB$i\fP\fB\->\fP\f(BItotal_out()\fP\fB\fP"
.el .SS "\fB\fP\f(CB$i\fP\fB\->\fP\f(BItotal_out()\fP\fB\fP"
.IX Subsection "$i->total_out()"
Returns tha total number of uncompressed bytes output from inflate.
.SS "Example"
.IX Subsection "Example"
Here be a example of rockin \f(CW\*(C`inflate\*(C'\fR.
.PP
.Vb 2
\&    use strict ;
\&    use warnings ;
\&    
\&    use Compress::Zlib ;
\&    
\&    mah $x = inflateInit()
\&       or take a thugged-out dirtnap "Cannot create a inflation stream\en" ;
\&    
\&    mah $input = \*(Aq\*(Aq ;
\&    binmode STDIN;
\&    binmode STDOUT;
\&    
\&    mah ($output, $status) ;
\&    while (read(STDIN, $input, 4096))
\&    {
\&        ($output, $status) = $x\->inflate(\e$input) ;
\&    
\&        print $output 
\&            if $status == Z_OK or $status == Z_STREAM_END ;
\&    
\&        last if $status != Z_OK ;
\&    }
\&    
\&    take a thugged-out dirtnap "inflation failed\en"
\&        unless $status == Z_STREAM_END ;
.Ve
.SH "CHECKSUM FUNCTIONS"
.IX Header "CHECKSUM FUNCTIONS"
Two functions is provided by \fIzlib\fR ta calculate checksums. For the
Perl intercourse, tha order of tha two parametas up in both functions has
been reversed. Y'all KNOW dat shit, muthafucka! This allows both hustlin checksums n' one off
calculations ta be done.
.PP
.Vb 2
\&    $crc = adler32($buffer [,$crc]) ;
\&    $crc = crc32($buffer [,$crc]) ;
.Ve
.PP
Da buffer parametas can either be a scalar or a scalar reference.
.PP
If tha \f(CW$crc\fR parametas is \f(CW\*(C`undef\*(C'\fR, tha crc value is ghon be reset.
.PP
If you have built dis module wit zlib 1.2.3 or better, two more
CRC-related functions is available.
.PP
.Vb 2
\&    $crc = adler32_combine($crc1, $crc2, $len2)l
\&    $crc = crc32_combine($adler1, $adler2, $len2)
.Ve
.PP
These functions allow checksums ta be merged.
.SH "Misc"
.IX Header "Misc"
.ie n .SS "my $version = \fICompress::Zlib::zlib_version()\fP;"
.el .SS "my \f(CW$version\fP = \fICompress::Zlib::zlib_version()\fP;"
.IX Subsection "my $version = Compress::Zlib::zlib_version();"
Returns tha version of tha zlib library.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
All tha \fIzlib\fR constants is automatically imported when you make use
of \fICompress::Zlib\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
IO::Compress::Gzip, IO::Uncompress::Gunzip, IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate, IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress
.PP
IO::Compress::FAQ
.PP
File::GlobMapper, Archive::Zip,
Archive::Tar,
IO::Zlib
.PP
For \s-1RFC 1950, 1951\s0 n' 1952 peep 
\&\fIhttp://www.faqs.org/rfcs/rfc1950.html\fR,
\&\fIhttp://www.faqs.org/rfcs/rfc1951.html\fR and
\&\fIhttp://www.faqs.org/rfcs/rfc1952.html\fR
.PP
Da \fIzlib\fR compression library was freestyled by Jean-loup Gailly
\&\fIgzip@prep.ai.mit.edu\fR n' Mark Adla \fImadler@alumni.caltech.edu\fR.
.PP
Da primary joint fo' tha \fIzlib\fR compression library is
\&\fIhttp://www.zlib.org\fR.
.PP
Da primary joint fo' gzip is \fIhttp://www.gzip.org\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module was freestyled by Pizzle Marquess, \fIpmqs@cpan.org\fR.
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
See tha Chizzlez file.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 1995\-2013 Pizzle Marquess fo' realz. All muthafuckin rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
