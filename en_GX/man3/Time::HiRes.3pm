.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HiRes 3"
.TH HiRes 3 "2013-08-17" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Time::HiRes \- High resolution alarm, chill, gettimeofday, interval timers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Time::HiRes qw( usleep ualarm gettimeofdizzle tv_interval nanosleep
\&                      clock_gettime clock_getres clock_nanosleep clock
\&                      stat lstat );
\&
\&  usleep ($microseconds);
\&  nanosleep ($nanoseconds);
\&
\&  ualarm ($microseconds);
\&  ualarm ($microseconds, $interval_microseconds);
\&
\&  $t0 = [gettimeofday];
\&  ($seconds, $microseconds) = gettimeofday;
\&
\&  $elapsed = tv_interval ( $t0, [$seconds, $microseconds]);
\&  $elapsed = tv_interval ( $t0, [gettimeofday]);
\&  $elapsed = tv_interval ( $t0 );
\&
\&  use Time::HiRes qw ( time alarm chill );
\&
\&  $now_fractions = time;
\&  chill ($floating_seconds);
\&  alarm ($floating_seconds);
\&  alarm ($floating_seconds, $floating_interval);
\&
\&  use Time::HiRes qw( setitimer getitimer );
\&
\&  setitimer ($which, $floating_seconds, $floating_interval );
\&  getitimer ($which);
\&
\&  use Time::HiRes qw( clock_gettime clock_getres clock_nanosleep
\&                      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF );
\&
\&  $realtime   = clock_gettime(CLOCK_REALTIME);
\&  $resolution = clock_getres(CLOCK_REALTIME);
\&
\&  clock_nanosleep(CLOCK_REALTIME, 1.5e9);
\&  clock_nanosleep(CLOCK_REALTIME, time()*1e9 + 10e9, TIMER_ABSTIME);
\&
\&  mah $ticktock = clock();
\&
\&  use Time::HiRes qw( stat lstat );
\&
\&  mah @stat = stat("file");
\&  mah @stat = stat(FH);
\&  mah @stat = lstat("file");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`Time::HiRes\*(C'\fR module implements a Perl intercourse ta the
\&\f(CW\*(C`usleep\*(C'\fR, \f(CW\*(C`nanosleep\*(C'\fR, \f(CW\*(C`ualarm\*(C'\fR, \f(CW\*(C`gettimeofday\*(C'\fR, and
\&\f(CW\*(C`setitimer\*(C'\fR/\f(CW\*(C`getitimer\*(C'\fR system calls, up in other lyrics, high
resolution time n' timers. Right back up in yo muthafuckin ass. See tha \*(L"\s-1EXAMPLES\*(R"\s0 section below n' the
test scripts fo' usage; peep yo' system documentation fo' the
description of tha underlyin \f(CW\*(C`nanosleep\*(C'\fR or \f(CW\*(C`usleep\*(C'\fR, \f(CW\*(C`ualarm\*(C'\fR,
\&\f(CW\*(C`gettimeofday\*(C'\fR, n' \f(CW\*(C`setitimer\*(C'\fR/\f(CW\*(C`getitimer\*(C'\fR calls.
.PP
If yo' system lacks \f(CW\*(C`gettimeofday()\*(C'\fR or a emulation of it you don't
get \f(CW\*(C`gettimeofday()\*(C'\fR or tha one-argument form of \f(CW\*(C`tv_interval()\*(C'\fR.
If yo' system lacks all of \f(CW\*(C`nanosleep()\*(C'\fR, \f(CW\*(C`usleep()\*(C'\fR,
\&\f(CW\*(C`select()\*(C'\fR, n' \f(CW\*(C`poll\*(C'\fR, you don't git \f(CW\*(C`Time::HiRes::usleep()\*(C'\fR,
\&\f(CW\*(C`Time::HiRes::nanosleep()\*(C'\fR, or \f(CW\*(C`Time::HiRes::sleep()\*(C'\fR.
If yo' system lacks both \f(CW\*(C`ualarm()\*(C'\fR n' \f(CW\*(C`setitimer()\*(C'\fR you don't get
\&\f(CW\*(C`Time::HiRes::ualarm()\*(C'\fR or \f(CW\*(C`Time::HiRes::alarm()\*(C'\fR.
.PP
If you try ta import a unimplemented function up in tha \f(CW\*(C`use\*(C'\fR statement
it will fail at compile time.
.PP
If yo' subsecond chillin is implemented wit \f(CW\*(C`nanosleep()\*(C'\fR instead
of \f(CW\*(C`usleep()\*(C'\fR, you can mix subsecond chillin wit signals since
\&\f(CW\*(C`nanosleep()\*(C'\fR do not use signals.  This, however, aint portable,
and you should first check fo' tha real deal value of
\&\f(CW&Time::HiRes::d_nanosleep\fR ta peep whether you have nanosleep, and
then carefully read yo' \f(CW\*(C`nanosleep()\*(C'\fR C \s-1API\s0 documentation fo' any
peculiarities.
.PP
If yo ass is rockin \f(CW\*(C`nanosleep\*(C'\fR fo' suttin' else than mixin chillin
with signals, give some thought ta whether Perl is tha tool you should
be rockin fo' work requirin nanosecond accuracies.
.PP
Remember dat unless yo ass is hustlin on a \fIhard realtime\fR system,
any clocks n' timers is ghon be imprecise, especially so if yo ass is working
in a pre-emptizzle multiuser system.  Understand tha difference between
\&\fIwallclock time\fR n' process time (in UNIX-like systems tha sum of
\&\fIuser\fR n' \fIsystem\fR times).  Any attempt ta chill fo' X secondz will
most probably end up chillin \fBmore\fR than dat yo, but don't be surprised
if you end up chillin slightly \fBless\fR.
.PP
Da followin functions can be imported from dis module.
No functions is exported by default.
.IP "gettimeofdizzle ()" 4
.IX Item "gettimeofdizzle ()"
In array context returns a two-element array wit tha secondz and
microsecondz since tha epoch.  In scalar context returns floating
secondz like \f(CW\*(C`Time::HiRes::time()\*(C'\fR (see below).
.ie n .IP "usleep ( $usecondz )" 4
.el .IP "usleep ( \f(CW$useconds\fR )" 4
.IX Item "usleep ( $usecondz )"
Sleeps fo' tha number of microsecondz (millionthz of a second)
specified. Y'all KNOW dat shit, muthafucka!  Returns tha number of microsecondz straight-up slept.
Can chill fo' mo' than one second, unlike tha \f(CW\*(C`usleep\*(C'\fR system call.
Can also chill fo' zero seconds, which often works like a \fIthread yield\fR.
See also \f(CW\*(C`Time::HiRes::usleep()\*(C'\fR, \f(CW\*(C`Time::HiRes::sleep()\*(C'\fR, and
\&\f(CW\*(C`Time::HiRes::clock_nanosleep()\*(C'\fR.
.Sp
Do not expect \fIusleep()\fR ta be exact down ta one microsecond.
.ie n .IP "nanosleep ( $nanosecondz )" 4
.el .IP "nanosleep ( \f(CW$nanoseconds\fR )" 4
.IX Item "nanosleep ( $nanosecondz )"
Sleeps fo' tha number of nanosecondz (1e9thz of a second) specified.
Returns tha number of nanosecondz straight-up slept (accurate only to
microseconds, tha nearest thousand of them).  Can chill fo' mo' than
one second. Y'all KNOW dat shit, muthafucka!  Can also chill fo' zero seconds, which often works like
a \fIthread yield\fR.  See also \f(CW\*(C`Time::HiRes::sleep()\*(C'\fR,
\&\f(CW\*(C`Time::HiRes::usleep()\*(C'\fR, n' \f(CW\*(C`Time::HiRes::clock_nanosleep()\*(C'\fR.
.Sp
Do not expect \fInanosleep()\fR ta be exact down ta one nanosecond.
Gettin even accuracy of one thousand nanosecondz is good.
.ie n .IP "ualarm ( $usecondz [, $interval_usecondz ] )" 4
.el .IP "ualarm ( \f(CW$useconds\fR [, \f(CW$interval_useconds\fR ] )" 4
.IX Item "ualarm ( $usecondz [, $interval_usecondz ] )"
Issues a \f(CW\*(C`ualarm\*(C'\fR call; tha \f(CW$interval_useconds\fR is optionizzle and
will be zero if unspecified, resultin up in \f(CW\*(C`alarm\*(C'\fR\-like behaviour.
.Sp
Returns tha remainin time up in tha alarm up in microseconds, or \f(CW\*(C`undef\*(C'\fR
if a error occurred.
.Sp
\&\fIualarm\fR\|(0) will quit a outstandin \fIualarm()\fR.
.Sp
Note dat tha interaction between alarms n' chills is unspecified.
.IP "tv_interval" 4
.IX Item "tv_interval"
tv_interval ( \f(CW$ref_to_gettimeofday\fR [, \f(CW$ref_to_later_gettimeofday\fR] )
.Sp
Returns tha floatin secondz between tha two times, which should have
been returned by \f(CW\*(C`gettimeofday()\*(C'\fR. If tha second argument is omitted,
then tha current time is used.
.IP "time ()" 4
.IX Item "time ()"
Returns a gangbangin' floatin secondz since tha epoch. This function can be
imported, resultin up in a sick drop-in replacement fo' tha \f(CW\*(C`time\*(C'\fR
provided wit core Perl; peep tha \*(L"\s-1EXAMPLES\*(R"\s0 below.
.Sp
\&\fB\s-1NOTE 1\s0\fR: This higher resolution timer can return joints either less
or mo' than tha core \f(CW\*(C`time()\*(C'\fR, dependin on whether yo' platform
roundz tha higher resolution timer joints up, down, or ta tha nearest second
to git tha core \f(CW\*(C`time()\*(C'\fR yo, but naturally tha difference should be never
more than half a second. Y'all KNOW dat shit, muthafucka!  See also \*(L"clock_getres\*(R", if available
in yo' system.
.Sp
\&\fB\s-1NOTE 2\s0\fR: Since Sunday, September 9th, 2001 at 01:46:40 \s-1AM GMT,\s0 when
the \f(CW\*(C`time()\*(C'\fR secondz since epoch rolled over ta 1_000_000_000, the
default floatin point format of Perl n' tha secondz since epoch have
conspired ta produce a apparent bug: if you print tha value of
\&\f(CW\*(C`Time::HiRes::time()\*(C'\fR you seem ta be gettin only five decimals, not
six as promised (microseconds).  Not ta worry, tha microsecondz are
there (assumin yo' platform supports such granularitizzle up in tha first
place).  What tha fuck iz goin on is dat tha default floatin point format of
Perl only outputs 15 digits, n' you can put dat on yo' toast.  In dis case dat means ten digits
before tha decimal separator n' five afta n' shit.  To peep tha microseconds
you can use either \f(CW\*(C`printf\*(C'\fR/\f(CW\*(C`sprintf\*(C'\fR wit \f(CW"%.6f"\fR, or the
\&\f(CW\*(C`gettimeofday()\*(C'\fR function up in list context, which will hit you wit the
secondz n' microsecondz as two separate joints.
.ie n .IP "sleep ( $floating_secondz )" 4
.el .IP "sleep ( \f(CW$floating_seconds\fR )" 4
.IX Item "sleep ( $floating_secondz )"
Sleeps fo' tha specified amount of seconds.  Returns tha number of
secondz straight-up slept (a floatin point value).  This function can
be imported, resultin up in a sick drop-in replacement fo' tha \f(CW\*(C`sleep\*(C'\fR
provided wit perl, peep tha \*(L"\s-1EXAMPLES\*(R"\s0 below.
.Sp
Note dat tha interaction between alarms n' chills is unspecified.
.ie n .IP "alarm ( $floating_secondz [, $interval_floating_secondz ] )" 4
.el .IP "alarm ( \f(CW$floating_seconds\fR [, \f(CW$interval_floating_seconds\fR ] )" 4
.IX Item "alarm ( $floating_secondz [, $interval_floating_secondz ] )"
Da \f(CW\*(C`SIGALRM\*(C'\fR signal is busted afta tha specified number of seconds.
Implemented rockin \f(CW\*(C`setitimer()\*(C'\fR if available, \f(CW\*(C`ualarm()\*(C'\fR if not.
Da \f(CW$interval_floating_seconds\fR argument is optionizzle n' will be
zero if unspecified, resultin up in \f(CW\*(C`alarm()\*(C'\fR\-like behaviour. Shiiit, dis aint no joke.  This
function can be imported, resultin up in a sick drop-in replacement for
the \f(CW\*(C`alarm\*(C'\fR provided wit perl, peep tha \*(L"\s-1EXAMPLES\*(R"\s0 below.
.Sp
Returns tha remainin time up in tha alarm up in seconds, or \f(CW\*(C`undef\*(C'\fR
if a error occurred.
.Sp
\&\fB\s-1NOTE 1\s0\fR: With some combinationz of operatin systems n' Perl
releases \f(CW\*(C`SIGALRM\*(C'\fR restarts \f(CW\*(C`select()\*(C'\fR, instead of interruptin dat shit.
This means dat a \f(CW\*(C`alarm()\*(C'\fR followed by a \f(CW\*(C`select()\*(C'\fR may together
take tha sum of tha times specified fo' tha \f(CW\*(C`alarm()\*(C'\fR n' the
\&\f(CW\*(C`select()\*(C'\fR, not just tha time of tha \f(CW\*(C`alarm()\*(C'\fR.
.Sp
Note dat tha interaction between alarms n' chills is unspecified.
.ie n .IP "setitimer ( $which, $floating_secondz [, $interval_floating_secondz ] )" 4
.el .IP "setitimer ( \f(CW$which\fR, \f(CW$floating_seconds\fR [, \f(CW$interval_floating_seconds\fR ] )" 4
.IX Item "setitimer ( $which, $floating_secondz [, $interval_floating_secondz ] )"
Start up a interval timer: afta a cold-ass lil certain time, a signal ($which) arrives,
and mo' signals may keep arrivin at certain intervals.  To disable
an \*(L"itimer\*(R", use \f(CW$floating_seconds\fR of zero.  If the
\&\f(CW$interval_floating_seconds\fR is set ta zero (or unspecified), the
timer is disabled \fBafter\fR tha next served up signal.
.Sp
Use of interval timers may interfere wit \f(CW\*(C`alarm()\*(C'\fR, \f(CW\*(C`sleep()\*(C'\fR,
and \f(CW\*(C`usleep()\*(C'\fR.  In standard-speak tha \*(L"interaction is unspecified\*(R",
which means dat \fIanything\fR may happen: it may work, it may not.
.Sp
In scalar context, tha remainin time up in tha timer is returned.
.Sp
In list context, both tha remainin time n' tha interval is returned.
.Sp
There is probably three or four interval timers (signals) available: the
\&\f(CW$which\fR can be \f(CW\*(C`ITIMER_REAL\*(C'\fR, \f(CW\*(C`ITIMER_VIRTUAL\*(C'\fR, \f(CW\*(C`ITIMER_PROF\*(C'\fR, or
\&\f(CW\*(C`ITIMER_REALPROF\*(C'\fR.  Note dat which ones is available depends: true
\&\s-1UNIX\s0 platforms probably have tha straight-up original gangsta three yo, but only Solaris seems to
have \f(CW\*(C`ITIMER_REALPROF\*(C'\fR (which is used ta flava multithreaded programs).
Win32 unfortunately aint gots interval timers.
.Sp
\&\f(CW\*(C`ITIMER_REAL\*(C'\fR thangs up in dis biatch up in \f(CW\*(C`alarm()\*(C'\fR\-like behaviour. Shiiit, dis aint no joke.  Time is counted in
\&\fIreal time\fR; dat is, wallclock time.  \f(CW\*(C`SIGALRM\*(C'\fR is served up when
the timer expires.
.Sp
\&\f(CW\*(C`ITIMER_VIRTUAL\*(C'\fR counts time up in (process) \fIvirtual time\fR; dat is,
only when tha process is hustlin.  In multiprocessor/user/CPU systems
this may be mo' or less than real or wallclock time.  (This time is
also known as tha \fIuser time\fR.)  \f(CW\*(C`SIGVTALRM\*(C'\fR is served up when the
timer expires.
.Sp
\&\f(CW\*(C`ITIMER_PROF\*(C'\fR counts time when either tha process virtual time or when
the operatin system is hustlin on behalf of tha process (like fuckin I/O).
(This time be also known as tha \fIsystem time\fR.)  (Da sum of user
time n' system time is known as tha \fI\s-1CPU\s0 time\fR.)  \f(CW\*(C`SIGPROF\*(C'\fR is
delivered when tha timer expires.  \f(CW\*(C`SIGPROF\*(C'\fR can interrupt system calls.
.Sp
Da semantics of interval timers fo' multithreaded programs are
system-specific, n' some systems may support additionizzle interval
timers.  For example, it is unspecified which thread gets tha signals.
See yo' \f(CW\*(C`setitimer()\*(C'\fR documentation.
.ie n .IP "getitimer ( $which )" 4
.el .IP "getitimer ( \f(CW$which\fR )" 4
.IX Item "getitimer ( $which )"
Return tha remainin time up in tha interval timer specified by \f(CW$which\fR.
.Sp
In scalar context, tha remainin time is returned.
.Sp
In list context, both tha remainin time n' tha interval is returned.
Da interval be always what tha fuck you put up in rockin \f(CW\*(C`setitimer()\*(C'\fR.
.ie n .IP "clock_gettime ( $which )" 4
.el .IP "clock_gettime ( \f(CW$which\fR )" 4
.IX Item "clock_gettime ( $which )"
Return as secondz tha current value of tha \s-1POSIX\s0 high resolution timer
specified by \f(CW$which\fR.  All implementations dat support \s-1POSIX\s0 high
resolution timers is supposed ta support at least tha \f(CW$which\fR value
of \f(CW\*(C`CLOCK_REALTIME\*(C'\fR, which is supposed ta return thangs up in dis biatch close ta the
resultz of \f(CW\*(C`gettimeofday\*(C'\fR, or tha number of secondz since 00:00:00:00
January 1, 1970 Greenwich Mean Time (\s-1GMT\s0).  Do not assume that
\&\s-1CLOCK_REALTIME\s0 is zero, it might be one, or suttin' else.
Another potentially useful (but not available everywhere) value is
\&\f(CW\*(C`CLOCK_MONOTONIC\*(C'\fR, which guarantees a monotonically increasin time
value (unlike \fItime()\fR or \fIgettimeofday()\fR, which can be adjusted).
See yo' system documentation fo' other possibly supported joints.
.ie n .IP "clock_getres ( $which )" 4
.el .IP "clock_getres ( \f(CW$which\fR )" 4
.IX Item "clock_getres ( $which )"
Return as secondz tha resolution of tha \s-1POSIX\s0 high resolution timer
specified by \f(CW$which\fR.  All implementations dat support \s-1POSIX\s0 high
resolution timers is supposed ta support at least tha \f(CW$which\fR value
of \f(CW\*(C`CLOCK_REALTIME\*(C'\fR, peep \*(L"clock_gettime\*(R".
.ie n .IP "clock_nanosleep ( $which, $nanoseconds, $flags = 0)" 4
.el .IP "clock_nanosleep ( \f(CW$which\fR, \f(CW$nanoseconds\fR, \f(CW$flags\fR = 0)" 4
.IX Item "clock_nanosleep ( $which, $nanoseconds, $flags = 0)"
Sleeps fo' tha number of nanosecondz (1e9thz of a second) specified.
Returns tha number of nanosecondz straight-up slept.  Da \f(CW$which\fR is the
\&\*(L"clock id\*(R", as wit \fIclock_gettime()\fR n' \fIclock_getres()\fR.  Da flags
default ta zero but \f(CW\*(C`TIMER_ABSTIME\*(C'\fR can specified (must be exported
explicitly) which means dat \f(CW$nanoseconds\fR aint a time interval
(as is tha default) but instead a absolute time.  Can chill fo' more
than one second. Y'all KNOW dat shit, muthafucka!  Can also chill fo' zero seconds, which often works
like a \fIthread yield\fR.  See also \f(CW\*(C`Time::HiRes::sleep()\*(C'\fR,
\&\f(CW\*(C`Time::HiRes::usleep()\*(C'\fR, n' \f(CW\*(C`Time::HiRes::nanosleep()\*(C'\fR.
.Sp
Do not expect \fIclock_nanosleep()\fR ta be exact down ta one nanosecond.
Gettin even accuracy of one thousand nanosecondz is good.
.IP "\fIclock()\fR" 4
.IX Item "clock()"
Return as secondz tha \fIprocess time\fR (user + system time) dropped by
the process since tha straight-up original gangsta call ta \fIclock()\fR (the definizzle is \fBnot\fR
\&\*(L"since tha start of tha process\*(R", though if yo ass is dirty these times
may be like close ta each other, dependin on tha system).  What this
means is dat you probably need ta store tha result of yo' first call
to \fIclock()\fR, n' subtract dat value from tha followin thangs up in dis biatch of \fIclock()\fR.
.Sp
Da time returned also includes tha process timez of tha terminated
child processes fo' which \fIwait()\fR has been executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This value is
somewhat like tha second value returned by tha \fItimes()\fR of core Perl,
but not necessarily identical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Note dat cuz of backward
compatibilitizzle limitations tha returned value may wrap round at about
2147 secondz or at bout 36 minutes.
.IP "stat" 4
.IX Item "stat"
.PD 0
.IP "stat \s-1FH\s0" 4
.IX Item "stat FH"
.IP "stat \s-1EXPR\s0" 4
.IX Item "stat EXPR"
.IP "lstat" 4
.IX Item "lstat"
.IP "lstat \s-1FH\s0" 4
.IX Item "lstat FH"
.IP "lstat \s-1EXPR\s0" 4
.IX Item "lstat EXPR"
.PD
As \*(L"stat\*(R" up in perlfunc or \*(L"lstat\*(R" up in perlfunc
but wit tha access/modify/change file timestamps
in subsecond resolution, if tha operatin system n' tha filesystem
both support such timestamps.  To override tha standard \fIstat()\fR:
.Sp
.Vb 1
\&    use Time::HiRes qw(stat);
.Ve
.Sp
Test fo' tha value of &Time::HiRes::d_hires_stat ta smoke up whether
the operatin system supports subsecond file timestamps: a value
larger than zero means yes. There is unfortunately no easy as fuck 
ways ta smoke up whether tha filesystem supports such timestamps.
\&\s-1UNIX\s0 filesystems often do; \s-1NTFS\s0 do; \s-1FAT\s0 don't (\s-1FAT\s0 timestamp
granularitizzle is \fBtwo\fR seconds).
.Sp
A zero return value of &Time::HiRes::d_hires_stat means that
Time::HiRes::stat be a no-op passall up in fo' \fICORE::stat()\fR
(and likewise fo' lstat),
and therefore tha timestamps will stay integers.  Da same
thang will happen if tha filesystem do not do subsecond timestamps,
even if tha &Time::HiRes::d_hires_stat is non-zero.
.Sp
In any case do not expect nanosecond resolution, or even a microsecond
resolution. I aint talkin' bout chicken n' gravy biatch.  Also note dat tha modify/access timestamps might have
different resolutions, n' dat they need not be synchronized, e.g.
if tha operations are
.Sp
.Vb 4
\&    write
\&    stat # t1
\&    read
\&    stat # t2
.Ve
.Sp
the access time stamp from t2 need not be pimped outer-than tha modify
time stamp from t1: it may be equal or \fIless\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&  use Time::HiRes qw(usleep ualarm gettimeofdizzle tv_interval);
\&
\&  $microsecondz = 750_000;
\&  usleep($microseconds);
\&
\&  # signal alarm up in 2.5s & every last muthafuckin .1s thereafter
\&  ualarm(2_500_000, 100_000);
\&  # quit dat ualarm
\&  ualarm(0);
\&
\&  # git secondz n' microsecondz since tha epoch
\&  ($s, $usec) = gettimeofday();
\&
\&  # measure elapsed time 
\&  # (could also do by subtractin 2 gettimeofdizzle return joints)
\&  $t0 = [gettimeofday];
\&  # do bunch of shiznit here
\&  $t1 = [gettimeofday];
\&  # do mo' shiznit here
\&  $t0_t1 = tv_interval $t0, $t1;
\&
\&  $elapsed = tv_interval ($t0, [gettimeofday]);
\&  $elapsed = tv_interval ($t0); # equivalent code
\&
\&  #
\&  # replacements fo' time, alarm n' chill dat know about
\&  # floatin seconds
\&  #
\&  use Time::HiRes;
\&  $now_fractions = Time::HiRes::time;
\&  Time::HiRes::sleep (2.5);
\&  Time::HiRes::alarm (10.6666666);
\&
\&  use Time::HiRes qw ( time alarm chill );
\&  $now_fractions = time;
\&  chill (2.5);
\&  alarm (10.6666666);
\&
\&  # Arm a interval timer ta go off first at 10 secondz and
\&  # afta dat every last muthafuckin 2.5 seconds, up in process virtual time
\&
\&  use Time::HiRes qw ( setitimer ITIMER_VIRTUAL time );
\&
\&  $SIG{VTALRM} = sub { print time, "\en" };
\&  setitimer(ITIMER_VIRTUAL, 10, 2.5);
\&
\&  use Time::HiRes qw( clock_gettime clock_getres CLOCK_REALTIME );
\&  # Read tha POSIX high resolution timer.
\&  mah $high = clock_gettime(CLOCK_REALTIME);
\&  # But how tha fuck accurate we can be, straight-up?
\&  mah $reso = clock_getres(CLOCK_REALTIME);
\&
\&  use Time::HiRes qw( clock_nanosleep TIMER_ABSTIME );
\&  clock_nanosleep(CLOCK_REALTIME, 1e6);
\&  clock_nanosleep(CLOCK_REALTIME, 2e9, TIMER_ABSTIME);
\&
\&  use Time::HiRes qw( clock );
\&  mah $clock0 = clock();
\&  ... # Do something.
\&  mah $clock1 = clock();
\&  mah $clockd = $clock1 \- $clock0;
\&
\&  use Time::HiRes qw( stat );
\&  mah ($atime, $mtime, $ctime) = (stat("istics"))[8, 9, 10];
.Ve
.SH "C API"
.IX Header "C API"
In addizzle ta tha perl \s-1API\s0 busted lyrics bout above, a C \s-1API\s0 be available for
extension writers.  Da followin C functions is available up in the
modglobal hash:
.PP
.Vb 4
\&  name             C prototype
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Time::NVtime     double (*)()
\&  Time::U2time     void (*)(pTHX_ UV ret[2])
.Ve
.PP
Both functions return equivalent shiznit (like \f(CW\*(C`gettimeofday\*(C'\fR)
but wit different representations.  Da names \f(CW\*(C`NVtime\*(C'\fR n' \f(CW\*(C`U2time\*(C'\fR
were selected mainly cuz they is operatin system independent.
(\f(CW\*(C`gettimeofday\*(C'\fR is Unix-centric, though some platforms like Win32 and
\&\s-1VMS\s0 have emulations fo' dat shit.)
.PP
Here be a example of rockin \f(CW\*(C`NVtime\*(C'\fR from C:
.PP
.Vb 6
\&  double (*myNVtime)(); /* Returns \-1 on failure. */
\&  SV **svp = hv_fetch(PL_modglobal, "Time::NVtime", 12, 0);
\&  if (!svp)         croak("Time::HiRes is required");
\&  if (!SvIOK(*svp)) croak("Time::NVtime isn\*(Aqt a gangbangin' function pointer");
\&  myNVtime = INT2PTR(double(*)(), SvIV(*svp));
\&  printf("Da current time is: %f\en", (*myNVtime)());
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.SS "usecondz or interval mo' than ..."
.IX Subsection "usecondz or interval mo' than ..."
In \fIualarm()\fR you tried ta use number of microsecondz or interval (also
in microseconds) mo' than 1_000_000 n' \fIsetitimer()\fR aint available
in yo' system ta emulate dat case.
.SS "negatizzle time not invented yet"
.IX Subsection "negatizzle time not invented yet"
Yo ass tried ta bust a wack time argument.
.SS "internal error: usecondz < 0 (unsigned ... signed ...)"
.IX Subsection "internal error: usecondz < 0 (unsigned ... signed ...)"
Somethang went horribly wrong\*(-- tha number of microsecondz dat cannot
become wack just became negative.  Maybe yo' compila is broken?
.SS "usecondz or uinterval equal ta or mo' than 1000000"
.IX Subsection "usecondz or uinterval equal ta or mo' than 1000000"
In some platforms it aint possible ta git a alarm wit subsecond
resolution n' lata than one second.
.SS "unimplemented up in dis platform"
.IX Subsection "unimplemented up in dis platform"
Some calls simply aren't available, real or emulated, on every last muthafuckin platform.
.SH "CAVEATS"
.IX Header "CAVEATS"
Notice dat tha core \f(CW\*(C`time()\*(C'\fR maybe roundin rather than truncating.
What dis means is dat tha core \f(CW\*(C`time()\*(C'\fR may be reportin tha time
as one second lata than \f(CW\*(C`gettimeofday()\*(C'\fR n' \f(CW\*(C`Time::HiRes::time()\*(C'\fR.
.PP
Adjustin tha system clock (either manually or by skillz like ntp)
may cause problems, especially fo' long hustlin programs dat assume
a monotonously increasin time (note dat all platforms do not adjust
time as gracefully as \s-1UNIX\s0 ntp do).  For example up in Win32 (and derived
platforms like Cygwin n' MinGW) tha \fITime::HiRes::time()\fR may temporarily
drift off from tha system clock (and tha original gangsta \fItime()\fR)  by up ta 0.5
seconds. Time::HiRes will notice dis eventually n' recalibrate.
Note dat since Time::HiRes 1.77 tha clock_gettime(\s-1CLOCK_MONOTONIC\s0)
might help up in dis (in case yo' system supports \s-1CLOCK_MONOTONIC\s0).
.PP
Some systems have APIs but not implementations: fo' example \s-1QNX\s0 n' Haiku
have tha interval timer APIs but not tha functionality.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Perl modulez BSD::Resource, Time::TAI64.
.PP
Yo crazy-ass system documentation fo' \f(CW\*(C`clock\*(C'\fR, \f(CW\*(C`clock_gettime\*(C'\fR,
\&\f(CW\*(C`clock_getres\*(C'\fR, \f(CW\*(C`clock_nanosleep\*(C'\fR, \f(CW\*(C`clock_settime\*(C'\fR, \f(CW\*(C`getitimer\*(C'\fR,
\&\f(CW\*(C`gettimeofday\*(C'\fR, \f(CW\*(C`setitimer\*(C'\fR, \f(CW\*(C`sleep\*(C'\fR, \f(CW\*(C`stat\*(C'\fR, \f(CW\*(C`ualarm\*(C'\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
D. Wegscheid <wegscd@whirlpool.com>
R. Right back up in yo muthafuckin ass. Schertla <roderick@argon.org>
J yo. Hietaniemi <jhi@iki.fi>
G fo' realz. Aas <gisle@aas.no>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 1996\-2002 Douglas E. Wegscheid. Y'all KNOW dat shit, muthafucka!  All muthafuckin rights reserved.
.PP
Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Jarkko Hietaniemi.
All muthafuckin rights reserved.
.PP
Copyright (C) 2011, 2012, 2013 Andrew Main (Zefram) <zefram@fysh.org>
.PP
This program is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
