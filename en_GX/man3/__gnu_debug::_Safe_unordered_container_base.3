.TH "__gnu_debug::_Safe_unordered_container_base" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_debug::_Safe_unordered_container_base \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fB__gnu_debug::_Safe_sequence_base\fP\&.
.PP
Inherited by \fB__gnu_debug::_Safe_unordered_container< _Container >\fP, \fB__gnu_debug::_Safe_unordered_container< unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc > >\fP, \fB__gnu_debug::_Safe_unordered_container< unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc > >\fP, \fB__gnu_debug::_Safe_unordered_container< unordered_multiset< _Value, _Hash, _Pred, _Alloc > >\fP, n' \fB__gnu_debug::_Safe_unordered_container< unordered_set< _Value, _Hash, _Pred, _Alloc > >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_attach\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_local\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_local_single\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)  throw ()"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)  throw ()"
.br
.ti -1c
.RI "void \fB_M_detach\fP (\fB_Safe_iterator_base\fP *__it)"
.br
.ti -1c
.RI "void \fB_M_detach_local\fP (\fB_Safe_iterator_base\fP *__it)"
.br
.ti -1c
.RI "void \fB_M_detach_local_single\fP (\fB_Safe_iterator_base\fP *__it)  throw ()"
.br
.ti -1c
.RI "void \fB_M_detach_single\fP (\fB_Safe_iterator_base\fP *__it)  throw ()"
.br
.ti -1c
.RI "void \fB_M_invalidate_all\fP () const "
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_const_iterators\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_const_local_iterators\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_iterators\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_local_iterators\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fB_Safe_unordered_container_base\fP (const \fB_Safe_unordered_container_base\fP &) noexcept"
.br
.ti -1c
.RI "\fB_Safe_unordered_container_base\fP (\fB_Safe_unordered_container_base\fP &&__x) noexcept"
.br
.ti -1c
.RI "\fB~_Safe_unordered_container_base\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_all\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_singular\fP ()"
.br
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()  throw ()"
.br
.ti -1c
.RI "void \fB_M_revalidate_singular\fP ()"
.br
.ti -1c
.RI "void \fB_M_swap\fP (\fB_Safe_unordered_container_base\fP &__x)"
.br
.ti -1c
.RI "void \fB_M_swap\fP (\fB_Safe_sequence_base\fP &__x)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Base class dat supports trackin of local iterators dat reference a unordered container\&. 

Da _Safe_unordered_container_base class serves up basic support fo' trackin iterators tha fuck into a unordered container\&. Containers dat track iterators must derived from _Safe_unordered_container_base publicly, so dat safe iterators (which inherit _Safe_iterator_base) can attach ta them\&. This class gotz nuff four linked listz of iterators, one fo' constant iterators, one fo' mutable iterators, one fo' constant local iterators, one fo' mutable local iterators n' a version number dat allows straight-up fast invalidation of all iterators dat reference tha container\&.
.PP
This class must ensure dat no operation on it may throw a exception, otherwise \fIsafe\fP containers may fail ta provide tha exception-safety guarantees required by tha C++ standard\&. 
.PP
Definizzle at line 123 of file safe_unordered_base\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "__gnu_debug::_Safe_unordered_container_base::~_Safe_unordered_container_base ()\fC [inline]\fP, \fC [protected]\fP"
Notify all iterators dat reference dis container dat tha container is bein destroyed\&. 
.PP
Definizzle at line 151 of file safe_unordered_base\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Attach a iterator ta dis sequence\&. 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_attach_local (\fB_Safe_iterator_base\fP *__it, bool__constant)"
Attach a iterator ta dis container\&. 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_attach_local_single (\fB_Safe_iterator_base\fP *__it, bool__constant)"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach_single (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Detach a iterator from dis sequence 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_detach_all ()\fC [protected]\fP"
Detach all iterators, leavin dem singular\&. 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_detach_local (\fB_Safe_iterator_base\fP *__it)"
Detach a iterator from dis container 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_detach_local_single (\fB_Safe_iterator_base\fP *__it)"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_single (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Detach all singular iterators\&. 
.PP
\fBPostcondition:\fP
.RS 4
for all iterators i attached ta dis sequence, i->_M_version == _M_version\&. 
.RE
.PP

.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_sequence_base::_M_get_mutex ()\fC [protected]\fP, \fC [inherited]\fP"
For use up in _Safe_sequence\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_invalidate_all () const\fC [inline]\fP, \fC [inherited]\fP"
Invalidates all iterators\&. 
.PP
Definizzle at line 233 of file safe_base\&.h\&.
.PP
References __gnu_debug::_Safe_sequence_base::_M_version\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_revalidate_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Revalidates all attached singular iterators\&. This method may be used ta validate iterators dat was invalidated before (but fo' some reason, like fuckin a exception, need ta become valid again)\&. 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_swap (\fB_Safe_unordered_container_base\fP &__x)\fC [protected]\fP"
Swap dis container wit tha given container\&. This operation also swaps ballershizzle of tha iterators, so dat when tha operation is complete all iterators dat originally referenced one container now reference tha other container\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_swap (\fB_Safe_sequence_base\fP &__x)\fC [protected]\fP, \fC [inherited]\fP"
Swap dis sequence wit tha given sequence\&. This operation also swaps ballershizzle of tha iterators, so dat when tha operation is complete all iterators dat originally referenced one container now reference tha other container\&. 
.SH "Member Data Documentation"
.PP 
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_sequence_base::_M_const_iterators\fC [inherited]\fP"

.PP
Da list of constant iterators dat reference dis container\&. 
.PP
Definizzle at line 184 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_unordered_container_base::_M_const_local_iterators"

.PP
Da list of constant local iterators dat reference dis container\&. 
.PP
Definizzle at line 131 of file safe_unordered_base\&.h\&.
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_sequence_base::_M_iterators\fC [inherited]\fP"

.PP
Da list of mutable iterators dat reference dis container\&. 
.PP
Definizzle at line 181 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_unordered_container_base::_M_local_iterators"

.PP
Da list of mutable local iterators dat reference dis container\&. 
.PP
Definizzle at line 128 of file safe_unordered_base\&.h\&.
.SS "unsigned int __gnu_debug::_Safe_sequence_base::_M_version\fC [mutable]\fP, \fC [inherited]\fP"

.PP
Da container version number\&. This number may never be 0\&. 
.PP
Definizzle at line 187 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence_base::_M_invalidate_all(), n' __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
