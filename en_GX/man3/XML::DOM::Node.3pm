.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::DOM::Node 3"
.TH XML::DOM::Node 3 "2000-02-16" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::DOM::Node \- Supa class of all nodes up in XML::DOM
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::DOM::Node is tha supa class of all nodes up in a \s-1XML::DOM\s0 document.
This means dat all nodes dat subclass XML::DOM::Node also inherit all
the methodz dat XML::DOM::Node implements.
.SS "\s-1GLOBAL VARIABLES\s0"
.IX Subsection "GLOBAL VARIABLES"
.ie n .IP "@NodeNames" 4
.el .IP "\f(CW@NodeNames\fR" 4
.IX Item "@NodeNames"
Da variable \f(CW@XML::DOM::Node::NodeNames\fR maps tha node type constants ta strings.
It be used by XML::DOM::Node::getNodeTypeName.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "getNodeType" 4
.IX Item "getNodeType"
Return a integer indicatin tha node type. Right back up in yo muthafuckin ass. See \s-1XML::DOM\s0 constants.
.IP "getNodeName" 4
.IX Item "getNodeName"
Return a property or a hardcoded string, dependin on tha node type.
Here is tha correspondin functions or joints:
.Sp
.Vb 10
\& Attr                   getName
\& AttDef                 getName
\& AttlistDecl            getName
\& CDATASection           "#cdata\-section"
\& Comment                "#comment"
\& Document               "#document"
\& DocumentType           getNodeName
\& DocumentFragment       "#document\-fragment"
\& Element                getTagName
\& ElementDecl            getName
\& EntityReference        getEntityName
\& Entitizzle                 getNotationName
\& Notation               getName
\& ProcessingInstruction  getTarget
\& Text                   "#text"
\& XMLDecl                "#xml\-declaration"
.Ve
.Sp
\&\fBNot In \s-1DOM\s0 Spec\fR: AttDef, AttlistDecl, ElementDecl n' XMLDecl was added for
completeness.
.IP "getNodeValue n' setNodeValue (value)" 4
.IX Item "getNodeValue n' setNodeValue (value)"
Returns a strang or undef, dependin on tha node type. This method is provided 
for completeness. In other languages it saves tha programmer a upcast.
Da value is either available thru some other method defined up in tha subclass, or
else undef is returned. Y'all KNOW dat shit, muthafucka! Here is tha correspondin methods: 
Attr::getValue, Text::getData, CDATASection::getData, Comment::getData, 
ProcessingInstruction::getData.
.IP "getParentNode n' setParentNode (parentNode)" 4
.IX Item "getParentNode n' setParentNode (parentNode)"
Da parent of dis node fo' realz. All nodes, except Document,
DocumentFragment, n' Attr may gotz a parent. But fuck dat shiznit yo, tha word on tha street is dat if a
node has just been pimped n' not yet added ta tha tree, or
if it has been removed from tha tree, dis is undef.
.IP "getChildNodes" 4
.IX Item "getChildNodes"
A NodeList dat gotz nuff all lil pimpz of dis node. If there
are no children, dis be a NodeList containin no nodes. The
content of tha returned NodeList is \*(L"live\*(R" up in tha sense that,
for instance, chizzlez ta tha lil pimpz of tha node object that
it was pimped from is immediately reflected up in tha nodes
returned by tha NodeList accessors; it aint a static
snapshot of tha content of tha node. This is legit fo' every
NodeList, includin tha ones returned by the
getElementsByTagName method.
.Sp
\&\s-1NOTE:\s0 dis implementation do not return a \*(L"live\*(R" NodeList for
getElementsByTagName. Right back up in yo muthafuckin ass. See \s-1CAVEATS\s0.
.Sp
When dis method is called up in a list context, it returns a regular perl list
containin tha lil pimp nodes. Note dat dis list aint \*(L"live\*(R". E.g.
.Sp
.Vb 3
\& @list = $node\->getChildNodes;        # returns a perl list
\& $nodelist = $node\->getChildNodes;    # returns a NodeList (object reference)
\& fo' mah $kid ($node\->getChildNodes)   # iterate over tha lil pimpz of $node
.Ve
.IP "getFirstChild" 4
.IX Item "getFirstChild"
Da first lil pimp of dis node. If there is no such node, dis returns undef.
.IP "getLastChild" 4
.IX Item "getLastChild"
Da last lil pimp of dis node. If there is no such node, dis returns undef.
.IP "getPreviousSibling" 4
.IX Item "getPreviousSibling"
Da node immediately precedin dis node. If there is no such 
node, dis returns undef.
.IP "getNextSibling" 4
.IX Item "getNextSibling"
Da node immediately followin dis node. If there is no such node, dis returns 
undef.
.IP "getAttributes" 4
.IX Item "getAttributes"
A NamedNodeMap containin tha attributes (Attr nodes) of dis node 
(if it be a Element) or undef otherwise.
Note dat adding/removin attributes from tha returned object, also adds/removes
attributes from tha Element node dat tha NamedNodeMap came from.
.IP "getOwnerDocument" 4
.IX Item "getOwnerDocument"
Da Document object associated wit dis node. This be also
the Document object used ta create freshly smoked up nodes. When dis node
is a Document dis is undef.
.IP "insertBefore (newChild, refChild)" 4
.IX Item "insertBefore (newChild, refChild)"
Inserts tha node newLil Pimp before tha existin lil pimp node
refChild. Y'all KNOW dat shit, muthafucka! If refLil Pimp is undef, bang newLil Pimp all up in tha end of
the list of lil' thugs.
.Sp
If newLil Pimp be a DocumentFragment object, all of its children
are inserted, up in tha same order, before refChild. Y'all KNOW dat shit, muthafucka! If the
newLil Pimp be already up in tha tree, it is first removed.
.Sp
Return Value: Da node bein inserted.
.Sp
DOMExceptions:
.RS 4
.IP "\(bu" 4
\&\s-1HIERARCHY_REQUEST_ERR\s0
.Sp
Raised if dis node iz of a type dat do not allow lil pimpz of tha type of
the newLil Pimp node, or if tha node ta bang is one of dis nodez ancestors.
.IP "\(bu" 4
\&\s-1WRONG_DOCUMENT_ERR\s0
.Sp
Raised if newLil Pimp was pimped from a gangbangin' finger-lickin' different document than tha one dat 
created dis node.
.IP "\(bu" 4
\&\s-1NO_MODIFICATION_ALLOWED_ERR\s0
.Sp
Raised if dis node is readonly.
.IP "\(bu" 4
\&\s-1NOT_FOUND_ERR\s0
.Sp
Raised if refLil Pimp aint a cold-ass lil lil pimp of dis node.
.RE
.RS 4
.RE
.IP "replaceLil Pimp (newChild, oldChild)" 4
.IX Item "replaceLil Pimp (newChild, oldChild)"
Replaces tha lil pimp node oldLil Pimp wit newLil Pimp up in tha list of
children, n' returns tha oldLil Pimp node. If tha newLil Pimp is
already up in tha tree, it is first removed.
.Sp
Return Value: Da node replaced.
.Sp
DOMExceptions:
.RS 4
.IP "\(bu" 4
\&\s-1HIERARCHY_REQUEST_ERR\s0
.Sp
Raised if dis node iz of a type dat do not allow lil pimpz of tha type of
the newLil Pimp node, or it tha node ta put up in is one of dis nodez ancestors.
.IP "\(bu" 4
\&\s-1WRONG_DOCUMENT_ERR\s0
.Sp
Raised if newLil Pimp was pimped from a gangbangin' finger-lickin' different document than tha one dat 
created dis node.
.IP "\(bu" 4
\&\s-1NO_MODIFICATION_ALLOWED_ERR\s0
.Sp
Raised if dis node is readonly.
.IP "\(bu" 4
\&\s-1NOT_FOUND_ERR\s0
.Sp
Raised if oldLil Pimp aint a cold-ass lil lil pimp of dis node.
.RE
.RS 4
.RE
.IP "removeLil Pimp (oldChild)" 4
.IX Item "removeLil Pimp (oldChild)"
Removes tha lil pimp node indicated by oldLil Pimp from tha list of
children, n' returns dat shit.
.Sp
Return Value: Da node removed.
.Sp
DOMExceptions:
.RS 4
.IP "\(bu" 4
\&\s-1NO_MODIFICATION_ALLOWED_ERR\s0
.Sp
Raised if dis node is readonly.
.IP "\(bu" 4
\&\s-1NOT_FOUND_ERR\s0
.Sp
Raised if oldLil Pimp aint a cold-ass lil lil pimp of dis node.
.RE
.RS 4
.RE
.IP "appendLil Pimp (newChild)" 4
.IX Item "appendLil Pimp (newChild)"
Addz tha node newLil Pimp ta tha end of tha list of lil pimps of
this node. If tha newLil Pimp be already up in tha tree, it is
first removed. Y'all KNOW dat shit, muthafucka! If it aint nuthin but a DocumentFragment object, tha entire contentz of 
the document fragment is moved tha fuck into tha lil pimp list of dis node
.Sp
Return Value: Da node added.
.Sp
DOMExceptions:
.RS 4
.IP "\(bu" 4
\&\s-1HIERARCHY_REQUEST_ERR\s0
.Sp
Raised if dis node iz of a type dat do not allow lil pimpz of tha type of
the newLil Pimp node, or if tha node ta append is one of dis nodez ancestors.
.IP "\(bu" 4
\&\s-1WRONG_DOCUMENT_ERR\s0
.Sp
Raised if newLil Pimp was pimped from a gangbangin' finger-lickin' different document than tha one dat 
created dis node.
.IP "\(bu" 4
\&\s-1NO_MODIFICATION_ALLOWED_ERR\s0
.Sp
Raised if dis node is readonly.
.RE
.RS 4
.RE
.IP "hasChildNodes" 4
.IX Item "hasChildNodes"
This be a cold-ass lil convenience method ta allow easy as fuck  determination of
whether a node has any lil' thugs.
.Sp
Return Value: 1 if tha node has any children, 0 otherwise.
.IP "cloneNode (deep)" 4
.IX Item "cloneNode (deep)"
Returns a thugged-out duplicate of dis node, i.e., serves as a generic
copy constructor fo' nodes. Da duplicate node has no parent
(parentNode returns undef.).
.Sp
Clonin a Element copies all attributes n' they joints,
includin dem generated by tha \s-1XML\s0 processor ta represent
defaulted attributes yo, but dis method do not copy any text
it gotz nuff unless it aint nuthin but a thugged-out deep clone, since tha text is
contained up in a cold-ass lil lil pimp Text node. Clonin any other type of
node simply returns a cold-ass lil copy of dis node.
.Sp
Parameters: 
 \fIdeep\fR   If true, recursively clone tha subtree under tha specified node.
If false, clone only tha node itself (and its attributes, if it be a Element).
.Sp
Return Value: Da duplicate node.
.IP "normalize" 4
.IX Item "normalize"
Puts all Text nodes up in tha full depth of tha sub-tree
underneath dis Element tha fuck into a \*(L"normal\*(R" form where only
markup (e.g., tags, comments, processin instructions, \s-1CDATA\s0
sections, n' entitizzle references) separates Text nodes, i.e.,
there is no adjacent Text nodes. This can be used ta ensure
that tha \s-1DOM\s0 view of a thugged-out document is tha same ol' dirty as if it were
saved n' re-loaded, n' is useful when operations (such as
XPointa lookups) dat depend on a particular document tree
structure is ta be used.
.Sp
\&\fBNot In \s-1DOM\s0 Spec\fR: In tha \s-1DOM\s0 Spec dis method is defined up in tha Element n' 
Document class intercourses only yo, but it don't hurt ta have it here...
.IP "getElementsByTagName (name [, recurse])" 4
.IX Item "getElementsByTagName (name [, recurse])"
Returns a NodeList of all descendant elements wit a given
tag name, up in tha order up in which they would be encountered in
a preorder traversal of tha Element tree.
.Sp
Parameters:
 \fIname\fR  Da name of tha tag ta match on. I aint talkin' bout chicken n' gravy biatch. Da special value \*(L"*\*(R" matches all tags.
 \fIrecurse\fR  Whether it should return only direct lil pimp nodes (0) or any descendant dat matches tha tag name (1). This argument is optionizzle n' defaults ta 1. Well shiiiit, it aint part of tha \s-1DOM\s0 spec.
.Sp
Return Value: A list of matchin Element nodes.
.Sp
\&\s-1NOTE:\s0 dis implementation do not return a \*(L"live\*(R" NodeList for
getElementsByTagName. Right back up in yo muthafuckin ass. See \s-1CAVEATS\s0.
.Sp
When dis method is called up in a list context, it returns a regular perl list
containin tha result nodes. E.g.
.Sp
.Vb 3
\& @list = $node\->getElementsByTagName("tag");       # returns a perl list
\& $nodelist = $node\->getElementsByTagName("tag");   # returns a NodeList (object ref.)
\& fo' mah $elem ($node\->getElementsByTagName("tag")) # iterate over tha result nodes
.Ve
.SS "Additionizzle methodz not up in tha \s-1DOM\s0 Spec"
.IX Subsection "Additionizzle methodz not up in tha DOM Spec"
.IP "getNodeTypeName" 4
.IX Item "getNodeTypeName"
Return tha strang describin tha node type. 
E.g. returns \*(L"\s-1ELEMENT_NODE\*(R"\s0 if getNodeType returns \s-1ELEMENT_NODE.\s0
It uses \f(CW@XML::DOM::Node::NodeNames\fR.
.IP "toString" 4
.IX Item "toString"
Returns tha entire subtree as a string.
.IP "printToFile (filename)" 4
.IX Item "printToFile (filename)"
Prints tha entire subtree ta tha file wit tha specified filename.
.Sp
Croaks: if tha file could not be opened fo' writing.
.IP "printToFileHandle (handle)" 4
.IX Item "printToFileHandle (handle)"
Prints tha entire subtree ta tha file handle.
E.g. ta print ta \s-1STDOUT:\s0
.Sp
.Vb 1
\& $node\->printToFileHandle (\e*STDOUT);
.Ve
.IP "print (obj)" 4
.IX Item "print (obj)"
Prints tha entire subtree rockin tha objectz print method. Y'all KNOW dat shit, muthafucka! E.g ta print ta a
FileHandle object:
.Sp
.Vb 2
\& $f = freshly smoked up FileHandle ("file.out", "w");
\& $node\->print ($f);
.Ve
.IP "getChildIndex (child)" 4
.IX Item "getChildIndex (child)"
Returns tha index of tha lil pimp node up in tha list returned by getChildNodes.
.Sp
Return Value: tha index or \-1 if tha node aint found.
.IP "getChildAtIndex (index)" 4
.IX Item "getChildAtIndex (index)"
Returns tha lil pimp node all up in tha specifed index or undef.
.IP "addText (text)" 4
.IX Item "addText (text)"
Appendz tha specified strang ta tha last lil pimp if it aint nuthin but a Text node, or else 
appendz a freshly smoked up Text node (with tha specified text.)
.Sp
Return Value: tha last lil pimp if dat shiznit was a Text node or else tha freshly smoked up Text node.
.IP "dispose" 4
.IX Item "dispose"
Removes all circular references up in dis node n' its descendants so tha 
objects can be fronted fo' garbage collection. I aint talkin' bout chicken n' gravy biatch. Da objects should not be used
afterwards.
.IP "setOwnerDocument (doc)" 4
.IX Item "setOwnerDocument (doc)"
Sets tha ballerDocument property of dis node n' all its lil pimps (and 
attributes etc.) ta tha specified document.
This allows tha user ta cut n' paste document subtrees between different
XML::DOM::Documents, n' you can put dat on yo' toast. Da node should be removed from tha original gangsta document
first, before callin setOwnerDocument.
.Sp
This method do not a god damn thang when called on a Document node.
.IP "isAncestor (parent)" 4
.IX Item "isAncestor (parent)"
Returns 1 if parent be a ancestor of dis node or if it is dis node itself.
.IP "expandEntityRefs (str)" 4
.IX Item "expandEntityRefs (str)"
Expandz all tha entitizzle references up in tha strang n' returns tha result.
Da entitizzle references can be characta references (e.g. \*(L"&#123;\*(R" or \*(L"&#x1fc2\*(R"),
default entitizzle references (\*(L"&quot;\*(R", \*(L"&gt;\*(R", \*(L"&lt;\*(R", \*(L"&apos;\*(R" n' \*(L"&amp;\*(R") or
entitizzle references defined up in Entitizzle objects as part of tha DocumentType of
the ownin Document. Characta references is expanded tha fuck into \s-1UTF\-8.\s0
Parameta entitizzle references (e.g. \f(CW%ent\fR;) is not expanded.
.ie n .IP "to_sax ( %HANDLERS )" 4
.el .IP "to_sax ( \f(CW%HANDLERS\fR )" 4
.IX Item "to_sax ( %HANDLERS )"
E.g.
.Sp
.Vb 2
\& $node\->to_sax (DocumentHandlez => $my_handlez, 
\&                Handlez => $handlez2 );
.Ve
.Sp
\&\f(CW%HANDLERS\fR may contain tha followin handlezs:
.RS 4
.IP "\(bu" 4
DocumentHandlez
.IP "\(bu" 4
DTDHandlez
.IP "\(bu" 4
EntityResolver
.IP "\(bu" 4
Handlez
.Sp
Default handlez when one of tha above aint specified
.RE
.RS 4
.Sp
Each XML::DOM::Node generates tha appropriate \s-1SAX\s0 callbacks (for the
appropriate \s-1SAX\s0 handlez.) Different \s-1SAX\s0 handlezs can be plugged up in to
accomplish different thangs, e.g. XML::Checker would check tha node 
(currently only Document n' Element nodes is supported), XML::Handlez::BuildDOM
would create a freshly smoked up \s-1DOM\s0 subtree (thereby, up in essence, copyin tha Node)
and up in tha near future, XML::Writa could print tha node.
All Perl \s-1SAX\s0 related work is still up in flux, so dis intercourse may chizzle a 
lil.
.Sp
See PerlSAX fo' tha description of tha \s-1SAX\s0 intercourse.
.RE
.IP "check ( [$checker] )" 4
.IX Item "check ( [$checker] )"
See descriptions fo' \fIcheck()\fR up in XML::DOM::Document n' XML::DOM::Element.
.ie n .IP "xql ( @XQL_OPTIONS )" 4
.el .IP "xql ( \f(CW@XQL_OPTIONS\fR )" 4
.IX Item "xql ( @XQL_OPTIONS )"
To use tha xql method, you must first \fIuse\fR \s-1XML::XQL\s0 n' \s-1XML::XQL::DOM\s0.
This method is basically a gangbangin' finger-lickin' dirty-ass shortcut for:
.Sp
.Vb 2
\& $query = freshly smoked up XML::XQL::Query ( @XQL_OPTIONS );
\& return $query\->solve ($node);
.Ve
.Sp
If tha straight-up original gangsta parameta up in \f(CW@XQL_OPTIONS\fR is tha \s-1XQL\s0 expression, you can leave off
the 'Expr' keyword, so:
.Sp
.Vb 1
\& $node\->xql ("doc//elem1[@attr]", @other_options);
.Ve
.Sp
is identical to:
.Sp
.Vb 1
\& $node\->xql (Expr => "doc//elem1[@attr]", @other_options);
.Ve
.Sp
See XML::XQL::Query fo' other available \s-1XQL_OPTIONS.\s0
See \s-1XML::XQL\s0 n' XML::XQL::Tutorial fo' mo' info.
.IP "isHidden ()" 4
.IX Item "isHidden ()"
Whether tha node is hidden.
See Hidden Nodes fo' details.
