.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BIO_f_ssl 3"
.TH BIO_f_ssl 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
BIO_f_ssl, BIO_set_ssl, BIO_get_ssl, BIO_set_ssl_mode, BIO_set_ssl_renegotiate_bytes,
BIO_get_num_renegotiates, BIO_set_ssl_renegotiate_timeout, BIO_new_ssl,
BIO_new_ssl_connect, BIO_new_buffer_ssl_connect, BIO_ssl_copy_session_id,
BIO_ssl_shutdown \- SSL BIO
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& #include <openssl/bio.h>
\& #include <openssl/ssl.h>
\&
\& BIO_METHOD *BIO_f_ssl(void);
\&
\& #define BIO_set_ssl(b,ssl,c)   BIO_ctrl(b,BIO_C_SET_SSL,c,(char *)ssl)
\& #define BIO_get_ssl(b,sslp)    BIO_ctrl(b,BIO_C_GET_SSL,0,(char *)sslp)
\& #define BIO_set_ssl_mode(b,client)     BIO_ctrl(b,BIO_C_SSL_MODE,client,NULL)
\& #define BIO_set_ssl_renegotiate_bytes(b,num) \e
\&        BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_BYTES,num,NULL);
\& #define BIO_set_ssl_renegotiate_timeout(b,seconds) \e
\&        BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT,seconds,NULL);
\& #define BIO_get_num_renegotiates(b) \e
\&        BIO_ctrl(b,BIO_C_SET_SSL_NUM_RENEGOTIATES,0,NULL);
\&
\& BIO *BIO_new_ssl(SSL_CTX *ctx,int client);
\& BIO *BIO_new_ssl_connect(SSL_CTX *ctx);
\& BIO *BIO_new_buffer_ssl_connect(SSL_CTX *ctx);
\& int BIO_ssl_copy_session_id(BIO *to,BIO *from);
\& void BIO_ssl_shutdown(BIO *bio);
\&
\& #define BIO_do_handshake(b)    BIO_ctrl(b,BIO_C_DO_STATE_MACHINE,0,NULL)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIBIO_f_ssl()\fR returns tha \s-1SSL BIO\s0 method. Y'all KNOW dat shit, muthafucka! This be a gangbangin' filta \s-1BIO\s0 which
is a wrapper round tha OpenSSL \s-1SSL\s0 routines addin a \s-1BIO \s0\*(L"flavour\*(R" to
\&\s-1SSL I/O. \s0
.PP
I/O performed on a \s-1SSL BIO\s0 communicates rockin tha \s-1SSL\s0 protocol with
the SSLs read n' write BIOs. If a \s-1SSL\s0 connection aint established
then a attempt is made ta establish one on tha straight-up original gangsta I/O call.
.PP
If a \s-1BIO\s0 be appended ta a \s-1SSL BIO\s0 rockin \fIBIO_push()\fR it be automatically
used as tha \s-1SSL\s0 BIOs read n' write BIOs.
.PP
Callin \fIBIO_reset()\fR on a \s-1SSL BIO\s0 closes down any current \s-1SSL\s0 connection
by callin \fISSL_shutdown()\fR. \fIBIO_reset()\fR is then busted ta tha next \s-1BIO\s0 in
the chain: dis will typically disconnect tha underlyin transport.
Da \s-1SSL BIO\s0 is then reset ta tha initial accept or connect state.
.PP
If tha close flag is set when a \s-1SSL BIO\s0 is freed then tha internal
\&\s-1SSL\s0 structure be also freed rockin \fISSL_free()\fR.
.PP
\&\fIBIO_set_ssl()\fR sets tha internal \s-1SSL\s0 pointa of \s-1BIO \s0\fBb\fR ta \fBssl\fR using
the close flag \fBc\fR.
.PP
\&\fIBIO_get_ssl()\fR retrieves tha \s-1SSL\s0 pointa of \s-1BIO \s0\fBb\fR, it can then be
manipulated rockin tha standard \s-1SSL\s0 library functions.
.PP
\&\fIBIO_set_ssl_mode()\fR sets tha \s-1SSL BIO\s0 mode ta \fBclient\fR. If \fBclient\fR
is 1 client mode is set. If \fBclient\fR is 0 server mode is set.
.PP
\&\fIBIO_set_ssl_renegotiate_bytes()\fR sets tha renegotiate byte count
to \fBnum\fR. When set afta every last muthafuckin \fBnum\fR bytez of I/O (read n' write) 
the \s-1SSL\s0 session be automatically renegotiated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. \fBnum\fR must be at
least 512 bytes.
.PP
\&\fIBIO_set_ssl_renegotiate_timeout()\fR sets tha renegotiate timeout to
\&\fBseconds\fR. When tha renegotiate timeout elapses tha session is
automatically renegotiated.
.PP
\&\fIBIO_get_num_renegotiates()\fR returns tha total number of session
renegotiations cuz of I/O or timeout.
.PP
\&\fIBIO_new_ssl()\fR allocates a \s-1SSL BIO\s0 rockin \s-1SSL_CTX \s0\fBctx\fR n' using
client mode if \fBclient\fR is non zero.
.PP
\&\fIBIO_new_ssl_connect()\fR creates a freshly smoked up \s-1BIO\s0 chain consistin of an
\&\s-1SSL BIO \s0(usin \fBctx\fR) followed by a cold-ass lil connect \s-1BIO.\s0
.PP
\&\fIBIO_new_buffer_ssl_connect()\fR creates a freshly smoked up \s-1BIO\s0 chain consisting
of a funky-ass bufferin \s-1BIO,\s0 a \s-1SSL BIO \s0(usin \fBctx\fR) n' a cold-ass lil connect
\&\s-1BIO.\s0
.PP
\&\fIBIO_ssl_copy_session_id()\fR copies a \s-1SSL\s0 session id between 
\&\s-1BIO\s0 chains \fBfrom\fR n' \fBto\fR. Well shiiiit, it do dis by locatin the
\&\s-1SSL\s0 BIOs up in each chain n' callin \fISSL_copy_session_id()\fR on
the internal \s-1SSL\s0 pointer.
.PP
\&\fIBIO_ssl_shutdown()\fR closes down a \s-1SSL\s0 connection on \s-1BIO\s0
chain \fBbio\fR. Well shiiiit, it do dis by locatin tha \s-1SSL BIO\s0 up in the
chain n' callin \fISSL_shutdown()\fR on its internal \s-1SSL\s0
pointer.
.PP
\&\fIBIO_do_handshake()\fR attempts ta complete a \s-1SSL\s0 handshake on the
supplied \s-1BIO\s0 n' establish tha \s-1SSL\s0 connection. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it returns 1
if tha connection was established successfully fo' realz. A zero or negative
value is returned if tha connection could not be established, the
call \fIBIO_should_retry()\fR should be used fo' non blockin connect BIOs
to determine if tha call should be retried. Y'all KNOW dat shit, muthafucka! If a \s-1SSL\s0 connection has
already been established dis call has no effect.
.SH "NOTES"
.IX Header "NOTES"
\&\s-1SSL\s0 BIOs is exceptionizzle up in dat if tha underlyin transport
is non blockin they can still request a retry up in exceptional
circumstances. Right back up in yo muthafuckin ass. Specifically dis will happen if a session
renegotiation takes place durin a \fIBIO_read()\fR operation, one
case where dis happens is when \s-1SGC\s0 or step up occurs.
.PP
In OpenSSL 0.9.6 n' lata tha \s-1SSL\s0 flag \s-1SSL_AUTO_RETRY\s0 can be
set ta disable dis behaviour. Shiiit, dis aint no joke. That is when dis flag is set
an \s-1SSL BIO\s0 rockin a funky-ass blockin transhiznit aint NEVER gonna request a
retry.
.PP
Since unknown \fIBIO_ctrl()\fR operations is busted all up in filter
BIOs tha servers name n' port can be set rockin \fIBIO_set_host()\fR
on tha \s-1BIO\s0 returned by \fIBIO_new_ssl_connect()\fR without having
to locate tha connect \s-1BIO\s0 first.
.PP
Applications do not gotta call \fIBIO_do_handshake()\fR but may wish
to do so ta separate tha handshake process from other I/O
processing.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\s-1TBA\s0
.SH "EXAMPLE"
.IX Header "EXAMPLE"
This \s-1SSL/TLS\s0 client example, attempts ta retrieve a page from an
\&\s-1SSL/TLS\s0 wizzy server n' shit. Da I/O routines is identical ta dem of the
unencrypted example up in \fIBIO_s_connect\fR\|(3).
.PP
.Vb 5
\& BIO *sbio, *out;
\& int len;
\& char tmpbuf[1024];
\& SSL_CTX *ctx;
\& SSL *ssl;
\&
\& ERR_load_crypto_strings();
\& ERR_load_SSL_strings();
\& OpenSSL_add_all_algorithms();
\&
\& /* Us thugs would seed tha PRNG here if tha platform didn\*(Aqt
\&  * do it automatically
\&  */
\&
\& ctx = SSL_CTX_new(SSLv23_client_method());
\&
\& /* We\*(Aqd normally set some shiznit like tha verify paths and
\&  * mode here cuz as thangs stand dis will connect to
\&  * any server whose certificate is signed by any CA.
\&  */
\&
\& sbio = BIO_new_ssl_connect(ctx);
\&
\& BIO_get_ssl(sbio, &ssl);
\&
\& if(!ssl) {
\&   fprintf(stderr, "Can\*(Aqt locate SSL pointer\en");
\&   /* whatever ... */
\& }
\&
\& /* Don\*(Aqt want any retries */
\& SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);
\&
\& /* We might wanna do other thangs wit ssl here */
\&
\& BIO_set_conn_hostname(sbio, "localhost:https");
\&
\& up = BIO_new_fp(stdout, BIO_NOCLOSE);
\& if(BIO_do_connect(sbio) <= 0) {
\&        fprintf(stderr, "Error connectin ta server\en");
\&        ERR_print_errors_fp(stderr);
\&        /* whatever ... */
\& }
\&
\& if(BIO_do_handshake(sbio) <= 0) {
\&        fprintf(stderr, "Error establishin SSL connection\en");
\&        ERR_print_errors_fp(stderr);
\&        /* whatever ... */
\& }
\&
\& /* Could examine ssl here ta git connection info */
\&
\& BIO_puts(sbio, "GET / HTTP/1.0\en\en");
\& for(;;) {      
\&        len = BIO_read(sbio, tmpbuf, 1024);
\&        if(len <= 0) break;
\&        BIO_write(out, tmpbuf, len);
\& }
\& BIO_free_all(sbio);
\& BIO_free(out);
.Ve
.PP
Here be a simple server example. Well shiiiit, it make use of a funky-ass buffering
\&\s-1BIO\s0 ta allow lines ta be read from tha \s-1SSL BIO\s0 rockin BIO_gets.
It creates a pseudo wizzy page containin tha actual request from
a client n' also echoes tha request ta standard output.
.PP
.Vb 5
\& BIO *sbio, *bbio, *acpt, *out;
\& int len;
\& char tmpbuf[1024];
\& SSL_CTX *ctx;
\& SSL *ssl;
\&
\& ERR_load_crypto_strings();
\& ERR_load_SSL_strings();
\& OpenSSL_add_all_algorithms();
\&
\& /* Might seed PRNG here */
\&
\& ctx = SSL_CTX_new(SSLv23_server_method());
\&
\& if (!SSL_CTX_use_certificate_file(ctx,"server.pem",SSL_FILETYPE_PEM)
\&        || !SSL_CTX_use_PrivateKey_file(ctx,"server.pem",SSL_FILETYPE_PEM)
\&        || !SSL_CTX_check_private_key(ctx)) {
\&
\&        fprintf(stderr, "Error settin up SSL_CTX\en");
\&        ERR_print_errors_fp(stderr);
\&        return 0;
\& }
\&
\& /* Might do other thangs here like settin verify locations and
\&  * DH and/or RSA temporary key callbacks
\&  */
\&
\& /* New SSL BIO setup as server */
\& sbio=BIO_new_ssl(ctx,0);
\&
\& BIO_get_ssl(sbio, &ssl);
\&
\& if(!ssl) {
\&   fprintf(stderr, "Can\*(Aqt locate SSL pointer\en");
\&   /* whatever ... */
\& }
\&
\& /* Don\*(Aqt want any retries */
\& SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);
\&
\& /* Smoke tha bufferin BIO */
\&
\& bbio = BIO_new(BIO_f_buffer());
\&
\& /* Add ta chain */
\& sbio = BIO_push(bbio, sbio);
\&
\& acpt=BIO_new_accept("4433");
\&
\& /* By bustin dis when a freshly smoked up connection is established
\&  * we automatically have sbio banged tha fuck into dat shit. The
\&  * BIO chain is now \*(Aqswallowed\*(Aq by tha accept BIO and
\&  * is ghon be freed when tha accept BIO is freed. Y'all KNOW dat shit, muthafucka! 
\&  */
\& 
\& BIO_set_accept_bios(acpt,sbio);
\&
\& up = BIO_new_fp(stdout, BIO_NOCLOSE);
\&
\& /* Setup accept BIO */
\& if(BIO_do_accept(acpt) <= 0) {
\&        fprintf(stderr, "Error settin up accept BIO\en");
\&        ERR_print_errors_fp(stderr);
\&        return 0;
\& }
\&
\& /* Now wait fo' incomin connection */
\& if(BIO_do_accept(acpt) <= 0) {
\&        fprintf(stderr, "Error up in connection\en");
\&        ERR_print_errors_fp(stderr);
\&        return 0;
\& }
\&
\& /* We only want one connection so remove n' free
\&  * accept BIO
\&  */
\&
\& sbio = BIO_pop(acpt);
\&
\& BIO_free_all(acpt);
\&
\& if(BIO_do_handshake(sbio) <= 0) {
\&        fprintf(stderr, "Error up in SSL handshake\en");
\&        ERR_print_errors_fp(stderr);
\&        return 0;
\& }
\&
\& BIO_puts(sbio, "HTTP/1.0 200 OK\er\enContent\-type: text/plain\er\en\er\en");
\& BIO_puts(sbio, "\er\enConnection Established\er\enRequest headers:\er\en");
\& BIO_puts(sbio, "\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\er\en");
\&
\& for(;;) {
\&        len = BIO_gets(sbio, tmpbuf, 1024);
\&        if(len <= 0) break;
\&        BIO_write(sbio, tmpbuf, len);
\&        BIO_write(out, tmpbuf, len);
\&        /* Look fo' blank line signifyin end of headers*/
\&        if((tmpbuf[0] == \*(Aq\er\*(Aq) || (tmpbuf[0] == \*(Aq\en\*(Aq)) break;
\& }
\&
\& BIO_puts(sbio, "\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\er\en");
\& BIO_puts(sbio, "\er\en");
\&
\& /* Since there be a funky-ass bufferin BIO present our crazy asses had betta flush it */
\& BIO_flush(sbio);
\&
\& BIO_free_all(sbio);
.Ve
.SH "BUGS"
.IX Header "BUGS"
In OpenSSL versions before 1.0.0 tha \fIBIO_pop()\fR call was handled incorrectly,
the I/O \s-1BIO\s0 reference count was incorrectly incremented (instead of
decremented) n' dissociated wit tha \s-1SSL BIO\s0 even if tha \s-1SSL BIO\s0 was not
explicitly bein popped (e.g. a pop higher up tha chain) fo' realz. Applications which
included workaroundz fo' dis bug (e.g. freein BIOs mo' than once) should
be modified ta handle dis fix or they may free up a already freed \s-1BIO.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1TBA\s0
