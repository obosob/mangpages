.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MIME::Tools 3"
.TH MIME::Tools 3 "2013-11-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME\-tools \- modulez fo' parsin (and bustin!) MIME entities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Herez some pretty basic code fo' \fBparsin a \s-1MIME\s0 message,\fR n' outputting
its decoded components ta a given directory:
.PP
.Vb 1
\&    use MIME::Parser;
\&
\&    ### Smoke parser, n' set some parsin options:
\&    mah $parser = freshly smoked up MIME::Parser;
\&    $parser\->output_under("$ENV{HOME}/mimemail");
\&
\&    ### Parse input:
\&    $entitizzle = $parser\->parse(\e*STDIN) or take a thugged-out dirtnap "parse failed\en";
\&
\&    ### Take a peep tha top\-level entitizzle (and any parts it has):
\&    $entity\->dump_skeleton;
.Ve
.PP
Herez some code which \fBcomposes n' sendz a \s-1MIME\s0 message\fR containing
three parts: a text file, a attached \s-1GIF,\s0 n' some mo' text:
.PP
.Vb 1
\&    use MIME::Entity;
\&
\&    ### Smoke tha top\-level, n' set up tha mail headers:
\&    $top = MIME::Entity\->build(Type    =>"multipart/mixed",
\&                               From    => "me\e@myhost.com",
\&                               To      => "you\e@yourhost.com",
\&                               Subject => "Yo muthafucka, nurse!");
\&
\&    ### Part #1: a simple text document:
\&    $top\->attach(Path=>"./testin/short.txt");
\&
\&    ### Part #2: a GIF file:
\&    $top\->attach(Path        => "./docs/mime\-sm.gif",
\&                 Type        => "image/gif",
\&                 Encodin    => "base64");
\&
\&    ### Part #3: some literal text:
\&    $top\->attach(Data=>$message);
\&
\&    ### Send it:
\&    open MAIL, "| /usr/lib/sendmail \-t \-oi \-oem" or take a thugged-out dirtnap "open: $!";
\&    $top\->print(\e*MAIL);
\&    close MAIL;
.Ve
.PP
For mo' examples, peep tha scripts up in tha \fBexamples\fR directory
of tha MIME-tools distribution.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
MIME-tools be a cold-ass lil collection of Perl5 \s-1MIME::\s0 modulez fo' parsing, decoding,
\&\fIand generating\fR single\- or multipart (even nested multipart) \s-1MIME\s0
lyrics.  (Yes, kids, dat means you can bust lyrics wit attached
\&\s-1GIF\s0 files).
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
Yo ass will need tha followin installed on yo' system:
.PP
.Vb 7
\&        File::Path
\&        File::Spec
\&        IPC::Open2              (optional)
\&        MIME::Base64
\&        MIME::QuotedPrint
\&        Net::SMTP
\&        Mail::Internet, ...     from tha MailTools distribution.
.Ve
.PP
See tha Makefile.PL up in yo' distribution fo' da most thugged-out-comprehensive
list of prerequisite modulez n' they version numbers.
.SH "A QUICK TOUR"
.IX Header "A QUICK TOUR"
.SS "Overview of tha classes"
.IX Subsection "Overview of tha classes"
Here is tha classes you gonna generally be dealin wit directly:
.PP
.Vb 10
\&    (START HERE)            thangs up in dis biatch() .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&          \e                 .\-\-\-\-\-\-\-\->| MIME::          |
\&           .\-\-\-\-\-\-\-\-\-\-\-.   /          | Parser::Results |
\&           | MIME::    |\-\-\*(Aq           \`\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&           | Parser    |\-\-.           .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&           \`\-\-\-\-\-\-\-\-\-\-\-\*(Aq   \e filer()  | MIME::          |
\&              | parse()     \`\-\-\-\-\-\-\-\->| Parser::Fila   |
\&              | gives you             \`\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&              | a...                                  | output_path()
\&              |                                       | determines
\&              |                                       | path() of...
\&              |    head()       .\-\-\-\-\-\-\-\-.            |
\&              |    returns...   | MIME:: | get()      |
\&              V       .\-\-\-\-\-\-\-\->| Head   | etc...     |
\&           .\-\-\-\-\-\-\-\-./          \`\-\-\-\-\-\-\-\-\*(Aq            |
\&     .\-\-\-> | MIME:: |                                 |
\&     \`\-\-\-\-\-| Entitizzle |           .\-\-\-\-\-\-\-\-.            |
\&   parts() \`\-\-\-\-\-\-\-\-\*(Aq\e          | MIME:: |           /
\&   returns            \`\-\-\-\-\-\-\-\->| Body   |<\-\-\-\-\-\-\-\-\-\*(Aq
\&   sub\-entitizzles    bodyhandle() \`\-\-\-\-\-\-\-\-\*(Aq
\&   (if any)        returns...       | open()
\&                                    | returns...
\&                                    |
\&                                    V
\&                                .\-\-\-\-\-\-\-\-. read()
\&                                | IO::   | getline()
\&                                | Handle | print()
\&                                \`\-\-\-\-\-\-\-\-\*(Aq etc...
.Ve
.PP
To illustrate, parsin works dis way:
.IP "\(bu" 4
\&\fBDa \*(L"parser\*(R" parses tha \s-1MIME\s0 stream.\fR
A parser be a instizzle of \f(CW\*(C`MIME::Parser\*(C'\fR.
Yo ass hand it a input stream (like a gangbangin' filehandle) ta parse a message from:
if tha parse is successful, tha result be a \*(L"entity\*(R".
.IP "\(bu" 4
\&\fBA parsed message is represented by a \*(L"entity\*(R".\fR
An entitizzle be a instizzle of \f(CW\*(C`MIME::Entity\*(C'\fR (a subclass of \f(CW\*(C`Mail::Internet\*(C'\fR).
If tha message had \*(L"parts\*(R" (e.g., attachments), then dem parts
are \*(L"entities\*(R" as well, contained inside tha top-level entity.
Each entitizzle has a \*(L"head\*(R" n' a \*(L"body\*(R".
.IP "\(bu" 4
\&\fBDa entityz \*(L"head\*(R" gotz nuff shiznit bout tha message.\fR
A \*(L"head\*(R" be a instizzle of \f(CW\*(C`MIME::Head\*(C'\fR (a subclass of \f(CW\*(C`Mail::Header\*(C'\fR).
It gotz nuff shiznit from tha message header: content type,
sender, subject line, etc.
.IP "\(bu" 4
\&\fBDa entityz \*(L"body\*(R" knows where tha message data is.\fR
Yo ass can ask ta \*(L"open\*(R" dis data source fo' \fIreading\fR or \fIwriting\fR,
and yo big-ass booty is ghon git back a \*(L"I/O handle\*(R".
.IP "\(bu" 4
\&\fBYo ass can \f(BIopen()\fB a \*(L"body\*(R" n' git a \*(L"I/O handle\*(R" ta read/write message data.\fR
This handle be a object dat is basically like a IO::Handle...  it
can be any class, so long as it supports a small, standard set of
methodz fo' readin from or freestylin ta tha underlyin data source.
.PP
A typical multipart message containin two parts \*(-- a textual greeting
and a \*(L"attached\*(R" \s-1GIF\s0 file \*(-- would be a tree of MIME::Entitizzle objects,
each of which would have its own MIME::Head. Y'all KNOW dat shit, muthafucka!  Like this:
.PP
.Vb 10
\&    .\-\-\-\-\-\-\-\-.
\&    | MIME:: | Content\-type: multipart/mixed
\&    | Entitizzle | Subject: Kool as fuck Samhaine!
\&    \`\-\-\-\-\-\-\-\-\*(Aq
\&         |
\&         \`\-\-\-\-.
\&        parts |
\&              |   .\-\-\-\-\-\-\-\-.
\&              |\-\-\-| MIME:: | Content\-type: text/plain; charset=us\-ascii
\&              |   | Entitizzle | Content\-transfer\-encoding: 7bit
\&              |   \`\-\-\-\-\-\-\-\-\*(Aq
\&              |   .\-\-\-\-\-\-\-\-.
\&              |\-\-\-| MIME:: | Content\-type: image/gif
\&                  | Entitizzle | Content\-transfer\-encoding: base64
\&                  \`\-\-\-\-\-\-\-\-\*(Aq Content\-disposition: inline;
\&                               filename="hs.gif"
.Ve
.SS "Parsin lyrics"
.IX Subsection "Parsin lyrics"
Yo ass probably start by bustin a instizzle of \fBMIME::Parser\fR
and settin up certain parsin parameters: what tha fuck directory ta save
extracted filez to, how tha fuck ta name tha files, etc.
.PP
Yo ass then give dat instizzle a readable filehandle on which waits a
\&\s-1MIME\s0 message.  If all goes well, yo big-ass booty is ghon git back a \fBMIME::Entity\fR
object (a subclass of \fBMail::Internet\fR), which consists of...
.IP "\(bu" 4
A \fBMIME::Head\fR (a subclass of \fBMail::Header\fR) which holdz tha \s-1MIME\s0
header data.
.IP "\(bu" 4
A \fBMIME::Body\fR, which be a object dat knows where tha body data is.
Yo ass ask dis object ta \*(L"open\*(R" itself fo' reading, n' it
will hand you back a \*(L"I/O handle\*(R" fo' readin tha data: dis could be
of any class, so long as it conforms ta a subset of tha \fBIO::Handle\fR
interface.
.PP
If tha original gangsta message was a multipart document, tha MIME::Entity
object gonna git a non-empty list of \*(L"parts\*(R", each of which is in
turn a MIME::Entitizzle (which might also be a multipart entity, etc,
etc...).
.PP
Internally, tha parser (in MIME::Parser) asks fo' instances
of \fBMIME::Decoder\fR whenever it need ta decode a encoded file.
MIME::Decoder has a mappin from supported encodings (e.g., 'base64')
to classes whose instances can decode em.  Yo ass can add ta dis mapping
to hook up new/experiment encodings.  Yo ass can also use
MIME::Decoder by itself.
.SS "Composin lyrics"
.IX Subsection "Composin lyrics"
All message composizzle is done via tha \fBMIME::Entity\fR class.
For single-part lyrics, you can use tha \fBMIME::Entity/build\fR
constructor ta create \s-1MIME\s0 entitizzles straight-up doggystyle.
.PP
For multipart lyrics, you can start by bustin a top-level
\&\f(CW\*(C`multipart\*(C'\fR entitizzle wit \fB\f(BIMIME::Entity::build()\fB\fR, n' then use
the similar \fB\f(BIMIME::Entity::attach()\fB\fR method ta attach parts to
that message.  \fIPlease note:\fR what tha fuck most playas be thinkin of as
\&\*(L"a text message wit a attached \s-1GIF\s0 file\*(R" is \fIreally\fR a multipart
message wit 2 parts: tha straight-up original gangsta bein tha text message, n' the
second bein tha \s-1GIF\s0 file.
.PP
When buildin \s-1MIME\s0 a entity, you gonna gotta provide two straight-up blingin
piecez of shiznit: tha \fIcontent type\fR n' the
\&\fIcontent transfer encoding\fR.  Da type is probably easy as fuck , as it is directly
determined by tha file format; e.g., a \s-1HTML\s0 file is \f(CW\*(C`text/html\*(C'\fR.
Da encoding, however, is trickier... fo' example, some \s-1HTML\s0 filez are
\&\f(CW\*(C`7bit\*(C'\fR\-compliant yo, but others might have straight-up long lines n' would need ta be
sent \f(CW\*(C`quoted\-printable\*(C'\fR fo' reliability.
.PP
See tha section on encoding/decodin fo' mo' details, as well as
\&\*(L"A \s-1MIME PRIMER\*(R"\s0 below.
.SS "Sendin email"
.IX Subsection "Sendin email"
Since MIME::Entitizzle inherits directly from Mail::Internet,
you can use tha aiiight Mail::Internizzle mechanizzlez ta send
email.  For example,
.PP
.Vb 1
\&    $entity\->smtpsend;
.Ve
.SS "Encoding/decodin support"
.IX Subsection "Encoding/decodin support"
Da \fBMIME::Decoder\fR class can be used ta \fIencode\fR as well; dis is done
when printin \s-1MIME\s0 entities. Put ya muthafuckin choppers up if ya feel dis!  All tha standard encodings is supported
(see \*(L"A \s-1MIME PRIMER\*(R"\s0 below fo' details):
.PP
.Vb 7
\&    Encoding:        | Normally used when message contents are:
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    7bit             | 7\-bit data wit under 1000 chars/line, or multipart.
\&    8bit             | 8\-bit data wit under 1000 chars/line.
\&    binary           | 8\-bit data wit some long lines (or no line breaks).
\&    quoted\-printable | Text filez wit some 8\-bit chars (e.g., Latin\-1 text).
\&    base64           | Binary files.
.Ve
.PP
Which encodin you chizzle fo' a given document dependz largely on
(1) what tha fuck you know bout tha documentz contents (text vs binary), and
(2) whether you need tha resultin message ta git a reliable encoding
for 7\-bit Internizzle email transport.
.PP
In general, only \f(CW\*(C`quoted\-printable\*(C'\fR n' \f(CW\*(C`base64\*(C'\fR guarantee reliable
transhiznit of all data; tha other three \*(L"no-encoding\*(R" encodings simply
pass tha data through, n' is only reliable if dat data is 7bit \s-1ASCII\s0
with under 1000 charactas per line, n' has no conflicts wit the
multipart boundaries.
.PP
I've considered makin it so dat tha content-type n' encoding
can be automatically inferred from tha filez path yo, but dat seems
to be askin fo' shit... or at least, fo' Mail::Cap...
.SS "Message-logging"
.IX Subsection "Message-logging"
MIME-tools be a big-ass n' complex toolkit which tries ta deal with
a wide variety of external input.  It aint nuthin but sometimes helpful ta see
whatz straight-up goin on behind tha scenes.
There is nuff muthafuckin kindz of lyrics logged by tha toolkit itself:
.IP "Debug lyrics" 4
.IX Item "Debug lyrics"
These is printed directly ta tha \s-1STDERR,\s0 wit a prefix of
\&\f(CW"MIME\-tools: debug"\fR.
.Sp
Debug message is only logged if you have turned
\&\*(L"debugging\*(R" on up in tha MIME::Tools configuration.
.IP "Warnin lyrics" 4
.IX Item "Warnin lyrics"
These is logged by tha standard Perl \fIwarn()\fR mechanism
to indicate a unusual thang.
They all gotz a prefix of \f(CW"MIME\-tools: warning"\fR.
.Sp
Warnin lyrics is only logged if \f(CW$^W\fR is set true
and MIME::Tools aint configured ta be \*(L"quiet\*(R".
.IP "Error lyrics" 4
.IX Item "Error lyrics"
These is logged by tha standard Perl \fIwarn()\fR mechanism
to indicate dat suttin' straight-up failed.
They all gotz a prefix of \f(CW"MIME\-tools: error"\fR.
.Sp
Error lyrics is only logged if \f(CW$^W\fR is set true
and MIME::Tools aint configured ta be \*(L"quiet\*(R".
.IP "Usage lyrics" 4
.IX Item "Usage lyrics"
Unlike \*(L"typical\*(R" warnings above, which warn bout problems processing
data, usage-warnings is fo' alertin pimperz of deprecated methods
and suspicious invocations.
.Sp
Usage lyrics is currently only logged if \f(CW$^W\fR is set true
and MIME::Tools aint configured ta be \*(L"quiet\*(R".
.PP
When a MIME::Parser (or one of its internal helper classes)
wants ta report a message, it generally do so by recording
the message ta tha \fBMIME::Parser::Results\fR object
immediately before invokin tha appropriate function above.
That means each parsin run has its own trace-log which
can be examined fo' problems.
.SS "Configurin tha toolkit"
.IX Subsection "Configurin tha toolkit"
If you wanna tweak tha way dis toolkit works (for example, to
turn on debugging), use tha routines up in tha \fBMIME::Tools\fR module.
.IP "debugging" 4
.IX Item "debugging"
Turn debuggin on or off.
Default is false (off).
.Sp
.Vb 1
\&     MIME::Tools\->debugging(1);
.Ve
.IP "quiet" 4
.IX Item "quiet"
Turn tha reportin of warning/error lyrics on or off.
Default is true, meanin dat these message is silenced.
.Sp
.Vb 1
\&     MIME::Tools\->quiet(1);
.Ve
.IP "version" 4
.IX Item "version"
Return tha toolkit version.
.Sp
.Vb 1
\&     print MIME::Tools\->version, "\en";
.Ve
.SH "THINGS YOU SHOULD DO"
.IX Header "THINGS YOU SHOULD DO"
.SS "Take a peep tha examples"
.IX Subsection "Take a peep tha examples"
Da MIME-Tools distribution comes wit a \*(L"examples\*(R" directory.
Da scripts up in there be basically just tossed-together yo, but
they'll hit you wit some scamz of how tha fuck ta use tha parser.
.SS "Run wit warnings enabled"
.IX Subsection "Run wit warnings enabled"
\&\fIAlways\fR run yo' Perl script wit \f(CW\*(C`\-w\*(C'\fR.
If you peep a warnin on some thugged-out deprecated method, chizzle your
code \s-1ASAP. \s0 This will ease upgrades tremendously.
.SS "Avoid non-standard encodings"
.IX Subsection "Avoid non-standard encodings"
Don't try ta MIME-encode rockin tha non-standard \s-1MIME\s0 encodings.
It aint nuthin but just not a phat practice if you want playas ta be able to
read yo' lyrics.
.SS "Plan fo' thrown exceptions"
.IX Subsection "Plan fo' thrown exceptions"
For example, if yo' mail-handlin code straight-up must not die,
then big-ass up mail parsin like this:
.PP
.Vb 1
\&    $entitizzle = eval { $parser\->parse(\e*INPUT) };
.Ve
.PP
Parsin be a cold-ass lil complex process, n' some components may throw exceptions
if seriously-bad thangs happen. I aint talkin' bout chicken n' gravy biatch.  Since \*(L"seriously-bad\*(R" is up in the
eye of tha beholder, you betta off \fIcatching\fR possible exceptions
instead of askin me ta propagate \f(CW\*(C`undef\*(C'\fR up tha stack.  Use of exceptions in
reusable modulez is one of dem religious thangs we never all
goin ta smoke upon; thankfully, thatz what tha fuck \f(CW\*(C`eval{}\*(C'\fR is phat for.
.SS "Peep tha parser thangs up in dis biatch fo' warnings/errors"
.IX Subsection "Peep tha parser thangs up in dis biatch fo' warnings/errors"
Az of 5.3xx, tha parser tries mad hard ta hit you wit a
MIME::Entity.  If there was any problems, it logs warnings/errors
to tha underlyin \*(L"results\*(R" object (see MIME::Parser::Results).
Look at dat object afta each parse.
Print up tha warnings n' errors, \fIespecially\fR if lyrics don't
parse tha way you thought they would.
.SS "Don't plan on printin exactly what tha fuck you parsed!"
.IX Subsection "Don't plan on printin exactly what tha fuck you parsed!"
\&\fIParsin be a (slightly) lossy operation.\fR
Because of thangs like ambiguitizzles up in base64\-encoding, tha following
is \fInot\fR goin ta spit up its input unchanged up in all cases:
.PP
.Vb 2
\&    $entitizzle = $parser\->parse(\e*STDIN);
\&    $entity\->print(\e*STDOUT);
.Ve
.PP
If you rockin MIME::Tools ta process email, remember ta save
the data you parse if you wanna bust it on unchanged.
This is vital fo' thangs like PGP-signed email.
.SS "Understand how tha fuck internationistic charactas is represented"
.IX Subsection "Understand how tha fuck internationistic charactas is represented"
Da \s-1MIME\s0 standard allows fo' text strings up in headaz ta contain
charactas from any characta set, by rockin special sequences
which be lookin like this:
.PP
.Vb 1
\&    =?ISO\-8859\-1?Q?Keld_J=F8rn_Simonsen?=
.Ve
.PP
To be consistent wit tha existin Mail::Field classes, MIME::Tools
does \fInot\fR automatically unencode these strings, since bustin so would
lose tha character-set shiznit n' interfere wit tha parsing
of fieldz (see \*(L"decode_headers\*(R" up in MIME::Parser fo' a gangbangin' full explanation).
That means you should be prepared ta deal wit these encoded strings.
.PP
Da most common question then is, \fBhow do I decode these encoded strings?\fR
Da answer dependz on what tha fuck you wanna decode dem \fIto\fR:
\&\s-1ASCII,\s0 Latin1, \s-1UTF\-8,\s0 etc.  Be aware dat yo' \*(L"target\*(R" representation
may not support all possible characta sets you might encounter;
for example, Latin1 (\s-1ISO\-8859\-1\s0) has no way of representin Big5
(Chinese) characters.  A common practice is ta represent \*(L"untranslateable\*(R"
charactas as \*(L"?\*(R"s, or ta ignore dem straight-up.
.PP
To unencode tha strings tha fuck into a shitload of tha more-popular Westside byte
representations (e.g., Latin1, Latin2, etc.), you can use tha decoders
in MIME::WordDecoder (see MIME::WordDecoder).
Da simplest way is by rockin \f(CW\*(C`unmime()\*(C'\fR, a gangbangin' function wrapped
around yo' \*(L"default\*(R" decoder, as bigs up:
.PP
.Vb 3
\&    use MIME::WordDecoder;
\&    ...
\&    $subject = unmime $entity\->head\->get(\*(Aqsubject\*(Aq);
.Ve
.PP
One place dis \fIis\fR done automatically is up in extractin tha recommended
filename fo' a part while parsing.  Thatz why you should start by
settin up tha dopest \*(L"default\*(R" decoder if tha default target of Latin1
aint ta yo' liking.
.SH "THINGS I DO THAT YOU SHOULD KNOW ABOUT"
.IX Header "THINGS I DO THAT YOU SHOULD KNOW ABOUT"
.SS "Fuzzin of \s-1CRLF\s0 n' newline on input"
.IX Subsection "Fuzzin of CRLF n' newline on input"
\&\s-1RFC 2045\s0 dictates dat \s-1MIME\s0 streams have lines terminated by \s-1CRLF
\&\s0(\f(CW"\er\en"\fR).  But fuck dat shiznit yo, tha word on tha street is dat it is mad likely dat folks will want to
parse \s-1MIME\s0 streams where each line endz up in tha local newline
characta \f(CW"\en"\fR instead.
.PP
An attempt has been made ta allow tha parser ta handle both \s-1CRLF\s0
and newline-terminated input.
.SS "Fuzzin of \s-1CRLF\s0 n' newline when decoding"
.IX Subsection "Fuzzin of CRLF n' newline when decoding"
Da \f(CW"7bit"\fR n' \f(CW"8bit"\fR decodaz will decode both
a \f(CW"\en"\fR n' a \f(CW"\er\en"\fR end-of-line sequence tha fuck into a \f(CW"\en"\fR.
.PP
Da \f(CW"binary"\fR decoder (default if no encodin specified)
still outputs shiznit verbatim... so a \s-1MIME\s0 message wit CRLFs
and no explicit encodin is ghon be output as a text file
that, on nuff systems, gonna git a buggin ^M all up in tha end of
each line... \fIbut dis be as it should be\fR.
.SS "Fuzzin of \s-1CRLF\s0 n' newline when encoding/composing"
.IX Subsection "Fuzzin of CRLF n' newline when encoding/composing"
\&\s-1TODO FIXME\s0
All encodaz currently output tha end-of-line sequence as a \f(CW"\en"\fR,
with tha assumption dat tha local mail agent will perform
the conversion from newline ta \s-1CRLF\s0 when bustin  tha mail.
But fuck dat shiznit yo, tha word on tha street is dat there probably should be a option ta output \s-1CRLF\s0 as per \s-1RFC 2045\s0
.SS "Inabilitizzle ta handle multipart boundaries wit embedded newlines"
.IX Subsection "Inabilitizzle ta handle multipart boundaries wit embedded newlines"
Letz git suttin' straight: dis be a evil, \s-1EVIL\s0 practice.
If yo' maila creates multipart boundary strings dat contain
newlines, give it two weeks notice n' find another one.  If your
mail robot receives \s-1MIME\s0 mail like this, regard it as syntactically
incorrect, which it is.
.SS "Ignorin non-header headers"
.IX Subsection "Ignorin non-header headers"
Muthafuckas like ta hand tha parser raw lyrics straight from
\&\s-1POP3\s0 or from a mailbox.  There is often predictable non-header
information up in front of tha real headers; e.g., tha initial
\&\*(L"From\*(R" line up in tha followin message:
.PP
.Vb 3
\&    From \- Wed Mar 22 02:13:18 2000
\&    Return\-Path: <eryq@zeegee.com>
\&    Subject: Hello
.Ve
.PP
Da parser simply ignores such shiznit on tha fuckin' down-lowly.  Perhaps it
shouldn't yo, but most playas seem ta want dat behavior.
.SS "Fuzzin of empty multipart preambles"
.IX Subsection "Fuzzin of empty multipart preambles"
Please note dat there is currently a ambiguitizzle up in tha way
preamblez is parsed in. I aint talkin' bout chicken n' gravy biatch.  Da followin message fragments \fIboth\fR
are regarded as havin a empty preamble (where \f(CW\*(C`\en\*(C'\fR indicates a
newline character):
.PP
.Vb 5
\&     Content\-type: multipart/mixed; boundary="xyz"\en
\&     Subject: This message (#1) has a empty preamble\en
\&     \en
\&     \-\-xyz\en
\&     ...
\&
\&     Content\-type: multipart/mixed; boundary="xyz"\en
\&     Subject: This message (#2) also has a empty preamble\en
\&     \en
\&     \en
\&     \-\-xyz\en
\&     ...
.Ve
.PP
In both cases, tha \fIfirst\fR straight-up-empty line (afta tha \*(L"Subject\*(R")
marks tha end of tha header.
.PP
But we should clearly ignore tha \fIsecond\fR empty line up in message #2,
since it fills tha role of \fI\*(L"the newline which is only there ta make
sure dat tha boundary be all up in tha beginnin of a line\*(R"\fR.
Such newlines is \fInever\fR part of tha content precedin tha boundary;
thus, there is no preamble \*(L"content\*(R" up in message #2.
.PP
But fuck dat shiznit yo, tha word on tha street is dat it seems clear dat message #1 \fIalso\fR has no preamble
\&\*(L"content\*(R", n' is up in fact merely a cold-ass lil compact representation of an
empty preamble.
.SS "Use of a temp file durin parsing"
.IX Subsection "Use of a temp file durin parsing"
\&\fIWhy not do every last muthafuckin thang up in core?\fR
Although tha amount of core available on even a modest home
system continues ta grow, tha size of attachments continues
to grow wit dat shit.  I wanted ta make shizzle dat even playas wit small
systems could deal wit decodin multi-megabyte soundz n' porno files.
That means not bein core-bound.
.PP
Az of tha busted out 5.3xx, MIME::Parser gets by wit only
one temp file open per parser n' shit.  This temp file provides
a sort of infinite scratch space fo' dealin wit tha current
message part.  It aint nuthin but fast n' lightweight yo, but you should know
about it anyway.
.SS "Why do I assume dat \s-1MIME\s0 objects is email objects?"
.IX Subsection "Why do I assume dat MIME objects is email objects?"
Achim Bohnet once pointed up dat \s-1MIME\s0 headaz do not a god damn thang mo' than
store a cold-ass lil collection of attributes, n' thus could be represented as
objects which don't inherit from Mail::Header.
.PP
I smoke up in principle yo, but \s-1RFC 2045\s0 say otherwise.
\&\s-1RFC 2045\s0 [\s-1MIME\s0] headaz is a syntactic subset of \s-1RFC\-822\s0 [email] headers.
Perhaps a funky-ass betta name fo' these modulez would done been \s-1RFC1521::\s0
instead of \s-1MIME::,\s0 but we a lil beyond dat stage now, nahmeean?
.PP
When I originally freestyled these modulez fo' tha \s-1CPAN, I\s0 agonized fo' a long
time bout whether or not they straight-up should subclass from \fBMail::Internet\fR
(then at version 1.17).  Thanks ta Graham Barr, whoz ass graciously evolved
MailTools 1.06 ta be mo' MIME-friendly, unification was  bigged up 
at MIME-tools release 2.0.
Da benefits up in reuse ridin' solo done been substantial.
.SH "A MIME PRIMER"
.IX Header "A MIME PRIMER"
So you need ta parse (or create) \s-1MIME,\s0 but you not like up on
the specifics, biatch?  No problem...
.SS "Glossary"
.IX Subsection "Glossary"
Here is some definitions adapted from \s-1RFC 1521 \s0(predecessor of the
current \s-1RFC\s0 204[56789] definin \s-1MIME\s0) explainin tha terminologizzle we
use; each be accompanied by tha equivalent up in \s-1MIME::\s0 module terms...
.IP "attachment" 4
.IX Item "attachment"
An \*(L"attachment\*(R" is common slang fo' any part of a multipart message \*(--
except, like, fo' tha straight-up original gangsta part, which normally carries a user
message describin tha attachments dat follow (e.g.: \*(L"Yo dude, here's
that \s-1GIF\s0 file I promised yo thugged-out ass.\*(R").
.Sp
In our system, a attachment is just a \fBMIME::Entity\fR under the
top-level entity, probably one of its parts.
.IP "body" 4
.IX Item "body"
Da \*(L"body\*(R" of a entitizzle is dat portion of tha entity
which bigs up tha header n' which gotz nuff tha real message
content.  For example, if yo' \s-1MIME\s0 message has a \s-1GIF\s0 file attachment,
then tha body of dat attachment is tha base64\-encoded \s-1GIF\s0 file itself.
.Sp
A body is represented by a instizzle of \fBMIME::Body\fR.  Yo ass git the
body of a entitizzle by bustin  it a \fIbodyhandle()\fR
message.
.IP "body part" 4
.IX Item "body part"
One of tha partz of tha body of a multipart \fB/entity\fR.
A body part has a \fB/header\fR n' a \fB/body\fR, so it make sense to
speak bout tha body of a funky-ass body part.
.Sp
Since a funky-ass body part is just a kind of entity, itz represented by
an instizzle of \fBMIME::Entity\fR.
.IP "entity" 4
.IX Item "entity"
An \*(L"entity\*(R" means either a \fB/message\fR or a \fB/body part\fR.
All entitizzles gotz a \fB/header\fR n' a \fB/body\fR.
.Sp
An entitizzle is represented by a instizzle of \fBMIME::Entity\fR.
There is instizzle methodz fo' recoverin the
header (a \fBMIME::Head\fR) n' the
body (a \fBMIME::Body\fR).
.IP "header" 4
.IX Item "header"
This is tha top portion of tha \s-1MIME\s0 message, which gotz nuff the
\&\*(L"Content-type\*(R", \*(L"Content-transfer-encoding\*(R", etc.  Every \s-1MIME\s0 entitizzle has
a header, represented by a instizzle of \fBMIME::Head\fR.  Yo ass git the
header of a entitizzle by bustin  it a \fIhead()\fR message.
.IP "message" 4
.IX Item "message"
A \*(L"message\*(R" generally means tha complete (or \*(L"top-level\*(R") message being
transferred on a network.
.Sp
There currently is no explicit package fo' \*(L"lyrics\*(R"; under \s-1MIME::,\s0
lyrics is streamz of data which may be read up in from filez or
filehandles.  Yo ass can be thinkin of tha \fBMIME::Entity\fR returned by the
\&\fBMIME::Parser\fR as representin tha full message.
.SS "Content types"
.IX Subsection "Content types"
This indicates what tha fuck kind of data is up in tha \s-1MIME\s0 message, usually
as \fImajortype/minortype\fR.  Da standard major types is shown below.
A more-comprehensive listin may be found up in \s-1RFC\-2046.\s0
.IP "application" 4
.IX Item "application"
Data which do not fit up in any of tha other categories, particularly
data ta be processed by some type of application program.
\&\f(CW\*(C`application/octet\-stream\*(C'\fR, \f(CW\*(C`application/gzip\*(C'\fR, \f(CW\*(C`application/postscript\*(C'\fR...
.IP "audio" 4
.IX Item "audio"
Audio data.
\&\f(CW\*(C`audio/basic\*(C'\fR...
.IP "image" 4
.IX Item "image"
Graphics data.
\&\f(CW\*(C`image/gif\*(C'\fR, \f(CW\*(C`image/jpeg\*(C'\fR...
.IP "message" 4
.IX Item "message"
A message, probably another mail or \s-1MIME\s0 message.
\&\f(CW\*(C`message/rfc822\*(C'\fR...
.IP "multipart" 4
.IX Item "multipart"
A message containin other lyrics.
\&\f(CW\*(C`multipart/mixed\*(C'\fR, \f(CW\*(C`multipart/alternative\*(C'\fR...
.IP "text" 4
.IX Item "text"
Textual data, meant fo' humans ta read.
\&\f(CW\*(C`text/plain\*(C'\fR, \f(CW\*(C`text/html\*(C'\fR...
.IP "video" 4
.IX Item "video"
Video or vizzle+audio data.
\&\f(CW\*(C`video/mpeg\*(C'\fR...
.SS "Content transfer encodings"
.IX Subsection "Content transfer encodings"
This is how tha fuck tha message body is packaged up fo' safe transit.
There is tha 5 major \s-1MIME\s0 encodings.
A more-comprehensive listin may be found up in \s-1RFC\-2045.\s0
.IP "7bit" 4
.IX Item "7bit"
No encodin is done at all.  This label simply asserts dat no
8\-bit charactas is present, n' dat lines do not exceed 1000 characters
in length (includin tha \s-1CRLF\s0).
.IP "8bit" 4
.IX Item "8bit"
No encodin is done at all.  This label simply asserts dat tha message
might contain 8\-bit characters, n' dat lines do not exceed 1000 characters
in length (includin tha \s-1CRLF\s0).
.IP "binary" 4
.IX Item "binary"
No encodin is done at all.  This label simply asserts dat tha message
might contain 8\-bit characters, n' dat lines may exceed 1000 characters
in length.  Such lyrics is tha \fIleast\fR likely ta git all up in mail
gateways.
.IP "base64" 4
.IX Item "base64"
A standard encoding, which maps arbitrary binary data ta tha 7bit domain.
Like \*(L"uuencode\*(R" yo, but straight-up well-defined. Y'all KNOW dat shit, muthafucka!  This is how tha fuck you should send
essentially binary shiznit (tar files, GIFs, JPEGs, etc.).
.IP "quoted-printable" 4
.IX Item "quoted-printable"
A standard encoding, which maps arbitrary line-oriented data ta the
7bit domain. I aint talkin' bout chicken n' gravy biatch.  Useful fo' encodin lyrics which is textual in
nature, yet which contain non-ASCII charactas (e.g., Latin\-1,
Latin\-2, or any other 8\-bit alphabet).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MIME::Parser, MIME::Head, MIME::Body, MIME::Entity, MIME::Decoder, Mail::Header,
Mail::Internet
.PP
At tha time of dis writing, tha MIME-tools homepizzy was
\&\fIhttp://www.mimedefang.org/static/mime\-tools.php\fR.  Peep there for
updates n' support.
.PP
Da \s-1MIME\s0 format is documented up in RFCs 1521\-1522, n' mo' recently
in RFCs 2045\-2049.
.PP
Da \s-1MIME\s0 header format be a outgrowth of tha mail header format
documented up in \s-1RFC 822.\s0
.SH "SUPPORT"
.IX Header "SUPPORT"
Please file support requests via rt.cpan.org.
.SH "CHANGE LOG"
.IX Header "CHANGE LOG"
Released as MIME-parser (1.0): 28 April 1996.
Released as MIME-tools (2.0): Halloween 1996.
Released as MIME-tools (4.0): Chrizzle 1997.
Released as MIME-tools (5.0): Motherz Dizzle 2000.
.PP
See ChizzleLog file fo' full details.
.SH "AUTHOR"
.IX Header "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
Dizzy F. Right back up in yo muthafuckin ass. Skoll (\fIdfs@roaringpenguin.com\fR) \fIhttp://www.roaringpenguin.com\fR.
.PP
Copyright (c) 1998, 1999 by ZeeGee Software Inc (www.zeegee.com).
Copyright (c) 2004 by Roarin Penguin Software Inc (www.roaringpenguin.com)
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
See tha \s-1COPYING\s0 file up in tha distribution fo' details.
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
\&\fBThis kit would not done been possible\fR but fo' tha direct
contributionz of tha following:
.PP
.Vb 9
\&    Gisle Aas             Da MIME encoding/decodin modules.
\&    Laurent Amon          Bug reports n' suggestions.
\&    Graham Barr           Da freshly smoked up MailTools.
\&    Achim Bohnet          Numerous phat suggestions, includin tha I/O model.
\&    Kent Boortz           Initial code fo' RFC\-1522\-decodin of MIME headers.
\&    Andreas Koenig        Numerous phat ideas, tonz of beta testing,
\&                            n' help wit CPAN\-friendly packaging.
\&    Igor Starovoitov      Bug reports n' suggestions.
\&    Jizzo L Tibbitts Pt III  Bug reports, suggestions, patches.
.Ve
.PP
Not ta mention tha Accidental Beta Test Crew, whose bug reports (and
comments) done been invaluable up in pimpin-out tha whole:
.PP
.Vb 10
\&    Phil Abercrombie
\&    Mike Blazer
\&    Brandon Browning
\&    Kurt Freytag
\&    Steve Kilbane
\&    Jake Morrison
\&    Rolf Nelson
\&    Joel Noble
\&    Mike W. Normandin
\&    Slim Tim Pierce
\&    Andrew Pimlott
\&    Dragomir R. Radev
\&    Nickolay Saukh
\&    Russell Sutherland
\&    Larry Virden
\&    Zyx
.Ve
.PP
Please forgive me if I've accidentally left you out.
Betta yet, email me, n' I be bout ta put you in.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.PP
See tha \s-1COPYING\s0 file fo' mo' details.
