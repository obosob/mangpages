.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::WrapTie 3"
.TH IO::WrapTie 3 "2005-02-10" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::WrapTie \- wrap tieable objects up in IO::Handle intercourse
.PP
This is currently Alpha code, busted out fo' comments, n' you can put dat on yo' toast.  
  Please give me yo' feedback!
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
First of all, you gonna need \fItie()\fR, so:
.PP
.Vb 1
\&   require 5.004;
.Ve
.PP
\&\fIFunction intercourse (experimental).\fR
Use dis wit any existin class...
.PP
.Vb 2
\&   use IO::WrapTie;
\&   use FooHandle;                  ### implements TIEHANDLE intercourse
\&
\&   ### Suppose we want a "FooHandle\->new(&FOO_RDWR, 2)".
\&   ### We can instead say...
\&
\&   $FH = wraptie(\*(AqFooHandle\*(Aq, &FOO_RDWR, 2); 
\&
\&   ### Now we can use...    
\&   print $FH "Yo muthafucka, ";            ### traditionizzle operator syntax...
\&   $FH\->print("world!\en");         ### ...and OO syntax as well!
.Ve
.PP
\&\fI\s-1OO\s0 intercourse (preferred).\fR
Yo ass can inherit from tha IO::WrapTie::Slave mixin ta git a
nifty \f(CW\*(C`new_tie()\*(C'\fR constructor...
.PP
.Vb 2
\&   #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-    
\&   package FooHandle;                        ### a cold-ass lil class which can TIEHANDLE
\&
\&   use IO::WrapTie;  
\&   @ISA = qw(IO::WrapTie::Slave);            ### inherit new_tie()
\&   ...
\&
\&
\&   #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-    
\&   package main; 
\&
\&   $FH = FooHandle\->new_tie(&FOO_RDWR, 2);   ### $FH be a IO::WrapTie::Master
\&   print $FH "Yo muthafucka, ";                      ### traditionizzle operator syntax
\&   $FH\->print("world!\en");                   ### OO syntax
.Ve
.PP
See IO::Scalar as a example.  It also shows you how tha fuck ta create classes
which work both wit n' without 5.004.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Suppose you gotz a cold-ass lil class \f(CW\*(C`FooHandle\*(C'\fR, where...
.IP "\(bu" 4
\&\fBFooHandle do not inherit from IO::Handle;\fR dat is, it performs
filehandle-like I/O yo, but ta suttin' other than a underlying
file descriptor. Shiiit, dis aint no joke.  Dope examplez is IO::Scalar (for printin ta a
string) n' IO::Lines (for printin ta a array of lines).
.IP "\(bu" 4
\&\fBFooHandle implements tha \s-1TIEHANDLE\s0 intercourse\fR (see perltie);
that is, it serves up methodz \s-1TIEHANDLE, GETC, PRINT, PRINTF,
READ,\s0 n' \s-1READLINE.\s0
.IP "\(bu" 4
\&\fBFooHandle implements tha traditionizzle \s-1OO\s0 intercourse\fR of
FileHandle n' IO::Handle; i.e., it gotz nuff methodz like \fIgetline()\fR, 
\&\fIread()\fR, \fIprint()\fR, \fIseek()\fR, \fItell()\fR, \fIeof()\fR, etc.
.PP
Normally, playaz of yo' class would have two options:
.IP "\(bu" 4
\&\fBUse only \s-1OO\s0 syntax,\fR n' forsake named I/O operators like 'print'.
.IP "\(bu" 4
\&\fBUse wit tie,\fR n' forsake treatin it as a gangbangin' first-class object 
(i.e., class-specific methodz can only be invoked all up in tha underlying
object via \fItied()\fR... givin tha object a \*(L"split personality\*(R").
.PP
But now wit IO::WrapTie, you can say:
.PP
.Vb 4
\&    $WT = wraptie(\*(AqFooHandle\*(Aq, &FOO_RDWR, 2);
\&    $WT\->print("Yo muthafucka, ghetto\en");   ### OO syntax
\&    print $WT "Yes!\en";             ### Named operator syntax too!
\&    $WT\->weird_stuff;               ### Other methods!
.Ve
.PP
And if you authorin a cold-ass lil class like FooHandle, just have it inherit 
from \f(CW\*(C`IO::WrapTie::Slave\*(C'\fR n' dat first line becomes even prettier:
.PP
.Vb 1
\&    $WT = FooHandle\->new_tie(&FOO_RDWR, 2);
.Ve
.PP
\&\fBDa bottom line:\fR now, almost any class can look n' work exactly like
an IO::Handle... n' be used both wit \s-1OO\s0 n' non-OO filehandle syntax.
.SH "HOW IT ALL WORKS"
.IX Header "HOW IT ALL WORKS"
.SS "Da data structures"
.IX Subsection "Da data structures"
Consider dis example code, rockin classes up in dis distribution:
.PP
.Vb 2
\&    use IO::Scalar;
\&    use IO::WrapTie;
\&
\&    $WT = wraptie(\*(AqIO::Scalar\*(Aq,\e$s);
\&    print $WT "Yo muthafucka, ";
\&    $WT\->print("world!\en");
.Ve
.PP
In it, tha \fIwraptie()\fR function creates a thugged-out data structure as bigs up:
.PP
.Vb 10
\&                          * $WT be a pimped reference ta a tied filehandle
\&              $WT           glob; dat glob is tied ta tha "Slave" object.
\&               |          * Yo ass would do all yo' i/o wit $WT directly.
\&               |       
\&               |
\&               |     ,\-\-\-isa\-\-> IO::WrapTie::Masta >\-\-isa\-\-> IO::Handle
\&               V    /
\&        .\-\-\-\-\-\-\-\-\-\-\-\-\-. 
\&        |             | 
\&        |             |   * Perl i/o operators work on tha tied object,  
\&        |  "Master"   |     invokin tha TIEHANDLE methods.
\&        |             |   * Method invocations is delegated ta tha tied 
\&        |             |     slave.
\&        \`\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq 
\&               |    
\&    tied(*$WT) |     .\-\-\-isa\-\-> IO::WrapTie::Slave
\&               V    /   
\&        .\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&        |             |
\&        |   "Slave"   |   * Instizzle of FileHandle\-like class which don\*(Aqt
\&        |             |     straight-up use file descriptors, like IO::Scalar.
\&        |  IO::Scalar |   * Da slave can be any kind of object.
\&        |             |   * Must implement tha TIEHANDLE intercourse.
\&        \`\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.Ve
.PP
\&\fI\s-1NOTE:\s0\fR just as a IO::Handle is straight-up just a pimped reference ta a 
\&\fItraditional\fR filehandle glob... so also, a IO::WrapTie::Masta 
is straight-up just a pimped reference ta a gangbangin' filehandle 
glob \fIwhich has been tied ta some \*(L"slave\*(R" class.\fR
.SS "How tha fuck \fIwraptie()\fP works"
.IX Subsection "How tha fuck wraptie() works"
.IP "1." 4
Da call ta function \f(CW\*(C`wraptie(SLAVECLASS, TIEARGS...)\*(C'\fR is 
passed onto \f(CW\*(C`IO::WrapTie::Master::new()\*(C'\fR.  
Note dat class IO::WrapTie::Masta be a subclass of IO::Handle.
.IP "2." 4
Da \f(CW\*(C`IO::WrapTie::Master::new\*(C'\fR method creates a freshly smoked up IO::Handle object,
reblessed tha fuck into class IO::WrapTie::Masta n' shit.  This object is tha \fImaster\fR, 
which is ghon be returned from tha constructor. Shiiit, dis aint no joke.  At tha same time...
.IP "3." 4
Da \f(CW\*(C`new\*(C'\fR method also creates tha \fIslave\fR: dis be a instizzle 
of \s-1SLAVECLASS\s0 which is pimped by tyin tha masterz IO::Handle 
to \s-1SLAVECLASS\s0 via \f(CW\*(C`tie(HANDLE, SLAVECLASS, TIEARGS...)\*(C'\fR.  
This call ta \f(CW\*(C`tie()\*(C'\fR creates tha slave up in tha followin manner:
.IP "4." 4
Class \s-1SLAVECLASS\s0 is busted tha message \f(CW\*(C`TIEHANDLE(TIEARGS...)\*(C'\fR; it 
will probably delegate dis ta \f(CW\*(C`SLAVECLASS::new(TIEARGS...)\*(C'\fR, resulting
in a freshly smoked up instizzle of \s-1SLAVECLASS\s0 bein pimped n' returned.
.IP "5." 4
Once both masta n' slave done been pimped, tha masta is returned
to tha caller.
.SS "How tha fuck I/O operators work (on tha master)"
.IX Subsection "How tha fuck I/O operators work (on tha master)"
Consider rockin a i/o operator on tha master:
.PP
.Vb 1
\&    print $WT "Yo muthafucka, ghetto!\en";
.Ve
.PP
Since tha masta ($WT) is straight-up a [blessed] reference ta a glob, 
the aiiight Perl i/o operators like \f(CW\*(C`print\*(C'\fR may be used on dat shit.
They will just operate on tha symbol part of tha glob.
.PP
Since tha glob is tied ta tha slave, tha slavez \s-1PRINT\s0 method 
(part of tha \s-1TIEHANDLE\s0 intercourse) is ghon be automatically invoked.
.PP
If tha slave be a IO::Scalar, dat means IO::Scalar::PRINT is ghon be 
invoked, n' dat method happens ta delegate ta tha \f(CW\*(C`print()\*(C'\fR method 
of tha same class.  So tha \fIreal\fR work is ultimately done by 
\&\fIIO::Scalar::print()\fR.
.SS "How tha fuck methodz work (on tha master)"
.IX Subsection "How tha fuck methodz work (on tha master)"
Consider rockin a method on tha master:
.PP
.Vb 1
\&    $WT\->print("Yo muthafucka, ghetto!\en");
.Ve
.PP
Since tha masta ($WT) is pimped tha fuck into tha class IO::WrapTie::Master,
Perl first attempts ta find a \f(CW\*(C`print()\*(C'\fR method there, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Failin that,
Perl next attempts ta find a \f(CW\*(C`print()\*(C'\fR method up in tha superclass,
IO::Handle.  It just so happens dat there \fIis\fR such a method;
that method merely invokes tha \f(CW\*(C`print\*(C'\fR i/o operator on tha self object...
and fo' that, peep above!
.PP
But letz suppose our phat asses dealin wit a method which \fIaint\fR part
of IO::Handle... fo' example:
.PP
.Vb 1
\&    mah $sref = $WT\->sref;
.Ve
.PP
In dis case, tha intuitizzle behavior is ta have tha masta delegate the
method invocation ta tha slave (now do you peep where tha designations
come from?).  This is indeed what tha fuck happens: IO::WrapTie::Masta gotz nuff
an \s-1AUTOLOAD\s0 method which performs tha delegation.
.PP
So: when \f(CW\*(C`sref()\*(C'\fR can't be found up in IO::Handle, tha \s-1AUTOLOAD\s0 method
of IO::WrapTie::Masta is invoked, n' tha standard behavior of
delegatin tha method ta tha underlyin slave (here, a IO::Scalar)
is done.
.PP
Sometimes, ta git dis ta work properly, you may need ta create 
a subclass of IO::WrapTie::Masta which be a effectizzle masta for
\&\fIyour\fR class, n' do tha delegation there.
.SH "NOTES"
.IX Header "NOTES"
\&\fBWhy not simply use tha objectz \s-1OO\s0 intercourse?\fR 
    Because dat means forsakin tha use of named operators
like \fIprint()\fR, n' you may need ta pass tha object ta a subroutine
which will attempt ta use dem operators:
.PP
.Vb 2
\&    $O = FooHandle\->new(&FOO_RDWR, 2);
\&    $O\->print("Yo muthafucka, ghetto\en");  ### OO syntax be all gravy, BUT....
\&
\&    sub nope { print $_[0] "Nope!\en" }
\& X  nope($O);                     ### ERROR!!! (not a glob ref)
.Ve
.PP
\&\fBWhy not simply use \f(BItie()\fB?\fR 
    Because (1) you gotta use \fItied()\fR ta invoke methodz up in the
objectz hood intercourse (yuck), n' (2) you may need ta pass 
the tied symbol ta another subroutine which will attempt ta treat 
it up in a OO-way... n' dat will break it:
.PP
.Vb 2
\&    tie *T, \*(AqFooHandle\*(Aq, &FOO_RDWR, 2; 
\&    print T "Yo muthafucka, ghetto\en";   ### Operator be all gravy, BUT... 
\&
\&    tied(*T)\->other_stuff;      ### yuck! AND...
\&
\&    sub nope { shift\->print("Nope!\en") }
\& X  nope(\e*T);                  ### ERROR!!! (method "print" on unblessed ref)
.Ve
.PP
\&\fBWhy a masta n' slave? 
  Why not simply write FooHandle ta inherit from IO::Handle?\fR
    I tried this, wit a implementation similar ta dat of IO::Socket.  
Da problem is dat \fIthe whole point is ta use dis wit objects
that aint gots a underlyin file/socket descriptor.\fR.
Subclassin IO::Handle will work fine fo' tha \s-1OO\s0 stuff, n' fine wit 
named operators \fIif\fR you \fItie()\fR... but if you just attempt ta say:
.PP
.Vb 2
\&    $IO = FooHandle\->new(&FOO_RDWR, 2);
\&    print $IO "Hello!\en";
.Ve
.PP
you git a warnin from Perl like:
.PP
.Vb 1
\&    Filehandle GEN001 never opened
.Ve
.PP
because itz tryin ta do system-level i/o on a (unopened) file 
descriptor. Shiiit, dis aint no joke.  To avoid this, you apparently gotta \fItie()\fR tha handle...
which brangs our asses right back ta where we started hommie!  At least the
IO::WrapTie mixin lets our asses say:
.PP
.Vb 2
\&    $IO = FooHandle\->new_tie(&FOO_RDWR, 2);
\&    print $IO "Hello!\en";
.Ve
.PP
and so aint \fItoo\fR bad. Y'all KNOW dat shit, muthafucka!  \f(CW\*(C`:\-)\*(C'\fR
.SH "WARNINGS"
.IX Header "WARNINGS"
Remember: dis shiznit is fo' bustin FileHandle-like i/o on thangs
\&\fIwithout underlyin file descriptors\fR.  If you have a underlying
file descriptor, you betta off just inheritin from IO::Handle.
.PP
\&\fBBe aware dat \f(BInew_tie()\fB always returns a instizzle of a
kind of IO::WrapTie::Master...\fR it do \fBnot\fR return a instizzle 
of tha i/o class you tyin to!
.PP
Invokin some methodz on tha masta object causes \s-1AUTOLOAD\s0 ta delegate
them ta tha slave object... so it \fIlooks\fR like you manipulatin a 
\&\*(L"FooHandle\*(R" object directly yo, but you not.
.PP
I aint explored all tha ramificationz of dis use of \fItie()\fR.
\&\fIHere there be dragons\fR.
.SH "VERSION"
.IX Header "VERSION"
\&\f(CW$Id:\fR WrapTie.pm,v 1.2 2005/02/10 21:21:53 dfs Exp $
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Primary Maintainer" 4
.IX Item "Primary Maintainer"
Dizzy F. Right back up in yo muthafuckin ass. Skoll (\fIdfs@roaringpenguin.com\fR).
.IP "Original Gangsta Author" 4
.IX Item "Original Gangsta Author"
Eryq (\fIeryq@zeegee.com\fR).
President, ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 481:" 4
.IX Item "Around line 481:"
\&'=item' outside of any '=over'
.Sp
=over without closin =back
