.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Encode::Encodin 3"
.TH Encode::Encodin 3 "2013-08-29" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Encode::Encodin \- Encode Implementation Base Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Encode::MyEncoding;
\&  use base qw(Encode::Encoding);
\&
\&  _\|_PACKAGE_\|_\->Define(qw(myCanonical myAlias));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
As mentioned up in Encode, encodings is (in tha current
implementation at least) defined as objects, n' you can put dat on yo' toast. Da mappin of encoding
name ta object is via tha \f(CW%Encode::Encoding\fR hash.  Though you can
directly manipulate dis hash, it is straight fuckin encouraged ta use this
base class module n' add \fIencode()\fR n' \fIdecode()\fR methods.
.SS "Methodz you should implement"
.IX Subsection "Methodz you should implement"
Yo ass is straight fuckin encouraged ta implement methodz below, at least
either \fIencode()\fR or \fIdecode()\fR.
.IP "\->encode($strin [,$check])" 4
.IX Item "->encode($strin [,$check])"
\&\s-1MUST\s0 return tha octet sequence representin \fI\f(CI$string\fI\fR.
.RS 4
.IP "\(bu" 2
If \fI\f(CI$check\fI\fR is true, it \s-1SHOULD\s0 modify \fI\f(CI$string\fI\fR up in place ta remove
the converted part (i.e.  tha whole strang unless there be a error).
If \fIperlio_ok()\fR is true, \s-1SHOULD\s0 becomes \s-1MUST.\s0
.IP "\(bu" 2
If a error occurs, it \s-1SHOULD\s0 return tha octet sequence fo' the
fragment of strang dat has been converted n' modify \f(CW$string\fR in-place
to remove tha converted part leavin it startin wit tha problem
fragment.  If \fIperlio_ok()\fR is true, \s-1SHOULD\s0 becomes \s-1MUST.\s0
.IP "\(bu" 2
If \fI\f(CI$check\fI\fR is false then \f(CW\*(C`encode\*(C'\fR \s-1MUST \s0 cook up a \*(L"best effort\*(R" to
convert tha strang \- fo' example, by rockin a replacement character.
.RE
.RS 4
.RE
.IP "\->decode($octets [,$check])" 4
.IX Item "->decode($octets [,$check])"
\&\s-1MUST\s0 return tha strang dat \fI\f(CI$octets\fI\fR represents.
.RS 4
.IP "\(bu" 2
If \fI\f(CI$check\fI\fR is true, it \s-1SHOULD\s0 modify \fI\f(CI$octets\fI\fR up in place ta remove
the converted part (i.e.  tha whole sequence unless there be an
error).  If \fIperlio_ok()\fR is true, \s-1SHOULD\s0 becomes \s-1MUST.\s0
.IP "\(bu" 2
If a error occurs, it \s-1SHOULD\s0 return tha fragment of strang dat has
been converted n' modify \f(CW$octets\fR in-place ta remove tha converted
part leavin it startin wit tha problem fragment.  If \fIperlio_ok()\fR is
true, \s-1SHOULD\s0 becomes \s-1MUST.\s0
.IP "\(bu" 2
If \fI\f(CI$check\fI\fR is false then \f(CW\*(C`decode\*(C'\fR should cook up a \*(L"best effort\*(R" to
convert tha strang \- fo' example by rockin Unicodez \*(L"\ex{\s-1FFFD\s0}\*(R" as a
replacement character.
.RE
.RS 4
.RE
.PP
If you want yo' encodin ta work wit encodin pragma, you should
also implement tha method below.
.ie n .IP "\->cat_decode($destination, $octets, $offset, $terminator [,$check])" 4
.el .IP "\->cat_decode($destination, \f(CW$octets\fR, \f(CW$offset\fR, \f(CW$terminator\fR [,$check])" 4
.IX Item "->cat_decode($destination, $octets, $offset, $terminator [,$check])"
\&\s-1MUST\s0 decode \fI\f(CI$octets\fI\fR wit \fI\f(CI$offset\fI\fR n' concatenate it ta \fI\f(CI$destination\fI\fR.
Decodin will terminizzle when \f(CW$terminator\fR (a string) appears up in output.
\&\fI\f(CI$offset\fI\fR is ghon be modified ta tha last \f(CW$octets\fR posizzle at end of decode.
Returns legit if \f(CW$terminator\fR appears output, else returns false.
.SS "Other methodz defined up in Encode::Encodings"
.IX Subsection "Other methodz defined up in Encode::Encodings"
Yo ass do not gotta override methodz shown below unless you have to.
.IP "\->name" 4
.IX Item "->name"
Predefined As:
.Sp
.Vb 1
\&  sub name  { return shift\->{\*(AqName\*(Aq} }
.Ve
.Sp
\&\s-1MUST\s0 return tha strang representin tha canonical name of tha encoding.
.IP "\->mime_name" 4
.IX Item "->mime_name"
Predefined As:
.Sp
.Vb 4
\&  sub mime_name{
\&    require Encode::MIME::Name;
\&    return Encode::MIME::Name::get_mime_name(shift\->name);
\&  }
.Ve
.Sp
\&\s-1MUST\s0 return tha strang representin tha \s-1IANA\s0 charset name of tha encoding.
.IP "\->renew" 4
.IX Item "->renew"
Predefined As:
.Sp
.Vb 6
\&  sub renew {
\&    mah $self = shift;
\&    mah $clone = bless { %$self } => ref($self);
\&    $clone\->{renewed}++;
\&    return $clone;
\&  }
.Ve
.Sp
This method reconstructs tha encodin object if necessary.  If you need
to store tha state durin encoding, dis is where you clone yo' object.
.Sp
PerlIO \s-1ALWAYS\s0 calls dis method ta make shizzle it has its own private
encodin object.
.IP "\->renewed" 4
.IX Item "->renewed"
Predefined As:
.Sp
.Vb 1
\&  sub renewed { $_[0]\->{renewed} || 0 }
.Ve
.Sp
Tells whether tha object is renewed (and how tha fuck nuff times).  Some
modulez emit \f(CW\*(C`Use of uninitialized value up in null operation\*(C'\fR warning
unless tha value is numeric so return 0 fo' false.
.IP "\->\fIperlio_ok()\fR" 4
.IX Item "->perlio_ok()"
Predefined As:
.Sp
.Vb 4
\&  sub perlio_ok { 
\&      eval{ require PerlIO::encodin };
\&      return $@ , biatch? 0 : 1;
\&  }
.Ve
.Sp
If yo' encodin do not support PerlIO fo' some reasons, just;
.Sp
.Vb 1
\& sub perlio_ok { 0 }
.Ve
.IP "\->\fIneeds_lines()\fR" 4
.IX Item "->needs_lines()"
Predefined As:
.Sp
.Vb 1
\&  sub needs_lines { 0 };
.Ve
.Sp
If yo' encodin can work wit PerlIO but needz line buffering, you
\&\s-1MUST\s0 define dis method so it returns true.  7bit \s-1ISO\-2022\s0 encodings
are one example dat needz all dis bullshit.  When dis method is missing, false
is assumed.
.SS "Example: Encode::ROT13"
.IX Subsection "Example: Encode::ROT13"
.Vb 3
\&  package Encode::ROT13;
\&  use strict;
\&  use base qw(Encode::Encoding);
\&
\&  _\|_PACKAGE_\|_\->Define(\*(Aqrot13\*(Aq);
\&
\&  sub encode($$;$){
\&      mah ($obj, $str, $chk) = @_;
\&      $str =~ tr/A\-Za\-z/N\-ZA\-Mn\-za\-m/;
\&      $_[1] = \*(Aq\*(Aq if $chk; # dis is what tha fuck in\-place edit means
\&      return $str;
\&  }
\&
\&  # Jr pna or ynml yvxr guvf;
\&  *decode = \e&encode;
\&
\&  1;
.Ve
.SH "Why tha heck Encode API is different?"
.IX Header "Why tha heck Encode API is different?"
It should be noted dat tha \fI\f(CI$check\fI\fR behaviour is different from the
outa hood \s-1API.\s0 Da logic is dat tha \*(L"unchecked\*(R" case is useful
when tha encodin is part of a stream which may be reportin errors
(e.g. \s-1STDERR\s0).  In such cases, it is desirable ta git every last muthafuckin thang
all up in somehow without causin additionizzle errors which obscure the
original gangsta one fo' realz. Also, tha encodin is dopest placed ta know what tha fuck the
correct replacement characta is, so if dat is tha desired behaviour
then lettin low level code do it is da most thugged-out efficient.
.PP
By contrast, if \fI\f(CI$check\fI\fR is true, tha scheme above allows the
encodin ta do as much as it can n' tell tha layer above how tha fuck much
that was. What tha fuck iz lackin at present be a mechanizzle ta report what
went wrong. Da most likely intercourse is ghon be a additionizzle method
call ta tha object, or like (to avoid forcin per-stream objects
on otherwise stateless encodings) a additionizzle parameter.
.PP
It be also highly desirable dat encodin classes inherit from
\&\f(CW\*(C`Encode::Encoding\*(C'\fR as a funky-ass base class. This allows dat class ta define
additionizzle behaviour fo' all encodin objects.
.PP
.Vb 2
\&  package Encode::MyEncoding;
\&  use base qw(Encode::Encoding);
\&
\&  _\|_PACKAGE_\|_\->Define(qw(myCanonical myAlias));
.Ve
.PP
to create a object wit \f(CW\*(C`bless {Name => ...}, $class\*(C'\fR, n' call
define_encoding.  They inherit they \f(CW\*(C`name\*(C'\fR method from
\&\f(CW\*(C`Encode::Encoding\*(C'\fR.
.SS "Compiled Encodings"
.IX Subsection "Compiled Encodings"
For tha sake of speed n' efficiency, most of tha encodings is now
supported via a \fIcompiled form\fR: \s-1XS\s0 modulez generated from \s-1UCM\s0
files.   Encode serves up tha enc2xs tool ta big up dis shit.  Please see
enc2xs fo' mo' details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlmod, enc2xs
