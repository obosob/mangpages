.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "EVP_PKEY_keygen 3"
.TH EVP_PKEY_keygen 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
EVP_PKEY_keygen_init, EVP_PKEY_keygen, EVP_PKEY_paramgen_init, EVP_PKEY_paramgen, EVP_PKEY_CTX_set_cb, EVP_PKEY_CTX_get_cb, EVP_PKEY_CTX_get_keygen_info, EVP_PKEVP_PKEY_CTX_set_app_data, EVP_PKEY_CTX_get_app_data \- key n' parameta generation functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/evp.h>
\&
\& int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);
\& int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
\& int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);
\& int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
\&
\& typedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *ctx);
\&
\& void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);
\& EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);
\&
\& int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx);
\&
\& void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);
\& void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \fIEVP_PKEY_keygen_init()\fR function initializes a hood key algorithm
context rockin key \fBpkey\fR fo' a key genration operation.
.PP
Da \fIEVP_PKEY_keygen()\fR function performs a key generation operation, tha 
generated key is freestyled ta \fBppkey\fR.
.PP
Da functions \fIEVP_PKEY_paramgen_init()\fR n' \fIEVP_PKEY_paramgen()\fR is similar
except parametas is generated.
.PP
Da function \fIEVP_PKEY_set_cb()\fR sets tha key or parameta generation callback
to \fBcb\fR. Da function \fIEVP_PKEY_CTX_get_cb()\fR returns tha key or parameter
generation callback.
.PP
Da function \fIEVP_PKEY_CTX_get_keygen_info()\fR returns parametas associated
with tha generation operation. I aint talkin' bout chicken n' gravy biatch. If \fBidx\fR is \-1 tha total number of
parametas available is returned. Y'all KNOW dat shit, muthafucka! Any non wack value returns tha value of
that parameter n' shit. \fIEVP_PKEY_CTX_gen_keygen_info()\fR wit a non-negatizzle value for
\&\fBidx\fR should only be called within tha generation callback.
.PP
If tha callback returns 0 then tha key genration operation be aborted n' an
error occurs. This might occur durin a time consumin operation where
a user clicks on a \*(L"cancel\*(R" button.
.PP
Da functions \fIEVP_PKEY_CTX_set_app_data()\fR n' \fIEVP_PKEY_CTX_get_app_data()\fR set
and retrieve a opaque pointer n' shit. This can be used ta set some application
defined value which can be retrieved up in tha callback: fo' example a handle
which is used ta update a \*(L"progress dialog\*(R".
.SH "NOTES"
.IX Header "NOTES"
Afta tha call ta \fIEVP_PKEY_keygen_init()\fR or \fIEVP_PKEY_paramgen_init()\fR algorithm
specific control operations can be performed ta set any appropriate parameters
for tha operation.
.PP
Da functions \fIEVP_PKEY_keygen()\fR n' \fIEVP_PKEY_paramgen()\fR can be called mo' than
once on tha same context if nuff muthafuckin operations is performed rockin tha same
parameters.
.PP
Da meanin of tha parametas passed ta tha callback will depend on the
algorithm n' tha specifiic implementation of tha algorithm. Right back up in yo muthafuckin ass. Some might not
give any useful shiznit at all durin key or parameta generation. I aint talkin' bout chicken n' gravy biatch. Others
might not even call tha callback.
.PP
Da operation performed by key or parameta generation dependz on tha algorithm
used. Y'all KNOW dat shit, muthafucka! In some cases (e.g. \s-1EC\s0 wit a supplied named curve) tha \*(L"generation\*(R"
option merely sets tha appropriate fieldz up in a \s-1EVP_PKEY\s0 structure.
.PP
In OpenSSL a \s-1EVP_PKEY\s0 structure containin a private key also gotz nuff the
hood key components n' parametas (if any) fo' realz. An OpenSSL private key is
equivalent ta what tha fuck some libraries call a \*(L"key pair\*(R" fo' realz. A private key can be used
in functions which require tha use of a hood key or parameters.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIEVP_PKEY_keygen_init()\fR, \fIEVP_PKEY_paramgen_init()\fR, \fIEVP_PKEY_keygen()\fR and
\&\fIEVP_PKEY_paramgen()\fR return 1 fo' success n' 0 or a wack value fo' failure.
In particular a return value of \-2 indicates tha operation aint supported by
the hood key algorithm.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Generate a 2048 bit \s-1RSA\s0 key:
.PP
.Vb 2
\& #include <openssl/evp.h>
\& #include <openssl/rsa.h>
\&
\& EVP_PKEY_CTX *ctx;
\& EVP_PKEY *pkey = NULL;
\& ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
\& if (!ctx)
\&        /* Error occurred */
\& if (EVP_PKEY_keygen_init(ctx) <= 0)
\&        /* Error */
\& if (EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048) <= 0)
\&        /* Error */
\&
\& /* Generate key */
\& if (EVP_PKEY_keygen(ctx, &pkey) <= 0)
\&        /* Error */
.Ve
.PP
Generate a key from a set of parameters:
.PP
.Vb 2
\& #include <openssl/evp.h>
\& #include <openssl/rsa.h>
\&
\& EVP_PKEY_CTX *ctx;
\& EVP_PKEY *pkey = NULL, *param;
\& /* Assumed param is set up already */
\& ctx = EVP_PKEY_CTX_new(param);
\& if (!ctx)
\&        /* Error occurred */
\& if (EVP_PKEY_keygen_init(ctx) <= 0)
\&        /* Error */
\&
\& /* Generate key */
\& if (EVP_PKEY_keygen(ctx, &pkey) <= 0)
\&        /* Error */
.Ve
.PP
Example of generation callback fo' OpenSSL hood key implementations:
.PP
.Vb 1
\& /* Application data be a BIO ta output status ta */
\&
\& EVP_PKEY_CTX_set_app_data(ctx, status_bio);
\&
\& static int genpkey_cb(EVP_PKEY_CTX *ctx)
\&        {
\&        char c=\*(Aq*\*(Aq;
\&        BIO *b = EVP_PKEY_CTX_get_app_data(ctx);
\&        int p;
\&        p = EVP_PKEY_CTX_get_keygen_info(ctx, 0);
\&        if (p == 0) c=\*(Aq.\*(Aq;
\&        if (p == 1) c=\*(Aq+\*(Aq;
\&        if (p == 2) c=\*(Aq*\*(Aq;
\&        if (p == 3) c=\*(Aq\en\*(Aq;
\&        BIO_write(b,&c,1);
\&        (void)BIO_flush(b);
\&        return 1;
\&        }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIEVP_PKEY_CTX_new\fR\|(3),
\&\fIEVP_PKEY_encrypt\fR\|(3),
\&\fIEVP_PKEY_decrypt\fR\|(3),
\&\fIEVP_PKEY_sign\fR\|(3),
\&\fIEVP_PKEY_verify\fR\|(3),
\&\fIEVP_PKEY_verify_recover\fR\|(3),
\&\fIEVP_PKEY_derive\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
These functions was first added ta OpenSSL 1.0.0.
