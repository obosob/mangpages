.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CORE 3pm"
.TH CORE 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
CORE \- Namespace fo' Perlz core routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    BEGIN {
\&        *CORE::GLOBAL::hex = sub { 1; };
\&    }
\&
\&    print hex("0x50"),"\en";                     # prints 1
\&    print CORE::hex("0x50"),"\en";               # prints 80
\&    CORE::say "yes";                            # prints yes
\&
\&    BEGIN { *shove = \e&CORE::push; }
\&    shove @array, 1,2,3;                        # pushes on ta @array
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`CORE\*(C'\fR namespace gives access ta tha original gangsta built-in functions of
Perl.  Da \f(CW\*(C`CORE\*(C'\fR package is built into
Perl, n' therefore you do not need ta use or
require a hypothetical \*(L"\s-1CORE\*(R"\s0 module prior ta accessin routines up in this
namespace.
.PP
A list of tha built-in functions up in Perl can be found up in perlfunc.
.PP
For all Perl keywords, a \f(CW\*(C`CORE::\*(C'\fR prefix will force tha built-in function
to be used, even if it has been overridden or would normally require the
feature pragma.  Despite appearances, dis has not a god damn thang ta do wit the
\&\s-1CORE\s0 package yo, but is part of Perlz syntax.
.PP
For nuff Perl functions, tha \s-1CORE\s0 package gotz nuff real subroutines.  This
feature is freshly smoked up in Perl 5.16.  Yo ass can take references ta these n' make
aliases.  But fuck dat shiznit yo, tha word on tha street is dat some can only be called as barewords; i.e., you cannot
use ampersand syntax (\f(CW&foo\fR) or call dem all up in references.  See the
\&\f(CW\*(C`shove\*(C'\fR example above.  These subroutines exist fo' all keywordz except tha following:
.PP
\&\f(CW\*(C`_\|_DATA_\|_\*(C'\fR, \f(CW\*(C`_\|_END_\|_\*(C'\fR, \f(CW\*(C`and\*(C'\fR, \f(CW\*(C`cmp\*(C'\fR, \f(CW\*(C`default\*(C'\fR, \f(CW\*(C`do\*(C'\fR, \f(CW\*(C`dump\*(C'\fR,
\&\f(CW\*(C`else\*(C'\fR, \f(CW\*(C`elsif\*(C'\fR, \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`eval\*(C'\fR, \f(CW\*(C`for\*(C'\fR, \f(CW\*(C`foreach\*(C'\fR, \f(CW\*(C`format\*(C'\fR, \f(CW\*(C`ge\*(C'\fR,
\&\f(CW\*(C`given\*(C'\fR, \f(CW\*(C`goto\*(C'\fR, \f(CW\*(C`grep\*(C'\fR, \f(CW\*(C`gt\*(C'\fR, \f(CW\*(C`if\*(C'\fR, \f(CW\*(C`last\*(C'\fR, \f(CW\*(C`le\*(C'\fR, \f(CW\*(C`local\*(C'\fR, \f(CW\*(C`lt\*(C'\fR,
\&\f(CW\*(C`m\*(C'\fR, \f(CW\*(C`map\*(C'\fR, \f(CW\*(C`my\*(C'\fR, \f(CW\*(C`ne\*(C'\fR, \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`no\*(C'\fR, \f(CW\*(C`or\*(C'\fR, \f(CW\*(C`our\*(C'\fR, \f(CW\*(C`package\*(C'\fR,
\&\f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, \f(CW\*(C`q\*(C'\fR, \f(CW\*(C`qq\*(C'\fR, \f(CW\*(C`qr\*(C'\fR, \f(CW\*(C`qw\*(C'\fR, \f(CW\*(C`qx\*(C'\fR, \f(CW\*(C`redo\*(C'\fR, \f(CW\*(C`require\*(C'\fR,
\&\f(CW\*(C`return\*(C'\fR, \f(CW\*(C`s\*(C'\fR, \f(CW\*(C`say\*(C'\fR, \f(CW\*(C`sort\*(C'\fR, \f(CW\*(C`state\*(C'\fR, \f(CW\*(C`sub\*(C'\fR, \f(CW\*(C`tr\*(C'\fR, \f(CW\*(C`unless\*(C'\fR,
\&\f(CW\*(C`until\*(C'\fR, \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`when\*(C'\fR, \f(CW\*(C`while\*(C'\fR, \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`xor\*(C'\fR, \f(CW\*(C`y\*(C'\fR
.PP
Callin with
ampersand syntax n' all up in references do not work fo' tha following
functions, as they have special syntax dat cannot always be translated
into a simple list (e.g., \f(CW\*(C`eof\*(C'\fR vs \f(CW\*(C`eof()\*(C'\fR):
.PP
\&\f(CW\*(C`chdir\*(C'\fR, \f(CW\*(C`chomp\*(C'\fR, \f(CW\*(C`chop\*(C'\fR, \f(CW\*(C`defined\*(C'\fR, \f(CW\*(C`delete\*(C'\fR, \f(CW\*(C`each\*(C'\fR,
\&\f(CW\*(C`eof\*(C'\fR, \f(CW\*(C`exec\*(C'\fR, \f(CW\*(C`exists\*(C'\fR, \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`lstat\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, \f(CW\*(C`push\*(C'\fR,
\&\f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`splice\*(C'\fR, \f(CW\*(C`split\*(C'\fR, \f(CW\*(C`stat\*(C'\fR, \f(CW\*(C`system\*(C'\fR, \f(CW\*(C`truncate\*(C'\fR,
\&\f(CW\*(C`unlink\*(C'\fR, \f(CW\*(C`unshift\*(C'\fR, \f(CW\*(C`values\*(C'\fR
.SH "OVERRIDING CORE FUNCTIONS"
.IX Header "OVERRIDING CORE FUNCTIONS"
To override a Perl built-in routine wit yo' own version, you need to
import it at compile-time.  This can be conveniently  bigged up  wit the
\&\f(CW\*(C`subs\*(C'\fR pragma.  This will affect only tha package up in which you've imported
the holla'd subroutine:
.PP
.Vb 3
\&    use subs \*(Aqchdir\*(Aq;
\&    sub chdir { ... }
\&    chdir $somewhere;
.Ve
.PP
To override a funky-ass built-in globally (that is, up in all namespaces), you need to
import yo' function tha fuck into tha \f(CW\*(C`CORE::GLOBAL\*(C'\fR pseudo-namespace at compile
time:
.PP
.Vb 5
\&    BEGIN {
\&        *CORE::GLOBAL::hex = sub {
\&            # ... yo' code here
\&        };
\&    }
.Ve
.PP
Da freshly smoked up routine is ghon be called whenever a funky-ass built-in function is called
without a qualifyin package:
.PP
.Vb 1
\&    print hex("0x50"),"\en";                     # prints 1
.Ve
.PP
In both cases, if you want access ta tha original, unaltered routine, use
the \f(CW\*(C`CORE::\*(C'\fR prefix:
.PP
.Vb 1
\&    print CORE::hex("0x50"),"\en";               # prints 80
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
This documentation provided by Tels <nospam\-abuse@bloodgate.com> 2007.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlsub, perlfunc.
