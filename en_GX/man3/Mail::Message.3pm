.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message 3"
.TH Mail::Message 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message \- general message object
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 9
\& Mail::Message has extra code in
\&   Mail::Message::Construct
\&   Mail::Message::Construct::Bounce
\&   Mail::Message::Construct::Build
\&   Mail::Message::Construct::Forward
\&   Mail::Message::Construct::Read
\&   Mail::Message::Construct::Rebuild
\&   Mail::Message::Construct::Reply
\&   Mail::Message::Construct::Text
\&
\& Mail::Message
\&   be a Mail::Reporter
\&
\& Mail::Message is extended by
\&   Mail::Box::Message
\&   Mail::Message::Dummy
\&   Mail::Message::Part
\&   Mail::Message::Replace::MailInternet
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Mail::Box::Manager;
\& mah $mgr    = Mail::Box::Manager\->new;
\& mah $folda = $mgr\->open(folda => \*(AqInBox\*(Aq);
\& mah $msg    = $folder\->message(2);    # $msg be a Mail::Message now
\&
\& mah $subject = $msg\->subject;         # Da message\*(Aqs subject
\& mah @cc      = $msg\->cc;              # List of Mail::Address\*(Aqes
\&
\& mah $msg       = Mail::Message\->build(...);
\& mah $reply_msg = Mail::Message\->reply(...);
\& mah $frwd_msg  = Mail::Message\->forward(...);
\&
\& mah Mail::Message::Head $head = $msg\->head;
\& mah Mail::Message::Body $body = $msg\->decoded;
\& $msg\->decoded\->print($outfile);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \f(CW\*(C`Mail::Message\*(C'\fR object be a cold-ass lil container fo' MIME-encoded message shiznit,
as defined by \s-1RFC2822. \s0 Everythang what tha fuck aint specificly related ta storing
the lyrics up in mailboxes (folders) is implemented up in dis class.  Methods
which is related ta foldaz is implemented up in tha Mail::Box::Message
extension.
.PP
Da main methodz is \fIget()\fR, ta git shiznit from a message header
field, n' \fIdecoded()\fR ta git tha intended content of a message.
But there be nuff mo' which can assist yo' program.
.PP
Complex message handling, like construction of replies n' forwards, are
implemented up in separate packages which is autoloaded tha fuck into dis class.
This means you can simply use these methodz as if they is part of dis class.
Those package add functionalitizzle ta all kindz of message objects.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBclone\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBclone\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->clone(OPTIONS)"
Smoke a cold-ass lil copy of dis message.  Returned be a \f(CW\*(C`Mail::Message\*(C'\fR object.
Da head n' body, tha log n' trace levels is taken. I aint talkin' bout chicken n' gravy biatch.  Labels are
copied wit tha message yo, but tha delete n' modified flags is not.
.Sp
\&\s-1BE WARNED:\s0 tha clone of any kind of message (or a message part)
will \fBalways\fR be a \f(CW\*(C`Mail::Message\*(C'\fR object.  For example, a
Mail::Box::Messagez clone is detached from tha folda of its original.
When you use \fIMail::Box::addMessage()\fR wit tha cloned message at hand,
then tha clone will automatically be coerced tha fuck into tha right message type
to be added.
.Sp
See also \fIMail::Box::Message::copyTo()\fR n' \fIMail::Box::Message::moveTo()\fR.
.Sp
.Vb 4
\& \-Option      \-\-Default
\&  shallow       <false>
\&  shallow_body  <false>
\&  shallow_head  <false>
.Ve
.RS 4
.IP "shallow => \s-1BOOLEAN\s0" 2
.IX Item "shallow => BOOLEAN"
When a gangbangin' finger-lickin' dirty-ass shallow clone is made, tha header n' body of tha message will not
be cloned yo, but shared. Y'all KNOW dat shit, muthafucka!  This is like dangerous: fo' instizzle up in some
folda types, tha header fieldz is used ta store folda flags.  When
one of both shallow clones chizzle tha flags, dat will update tha header
and thereby be visible up in both.
.Sp
There is thangs where a gangbangin' finger-lickin' dirty-ass shallow clone can be used safely.  For instance,
when \fIMail::Box::Message::moveTo()\fR is used n' yo ass is shizzle dat the
original gangsta message cannot git undeleted afta tha move.
.IP "shallow_body => \s-1BOOLEAN\s0" 2
.IX Item "shallow_body => BOOLEAN"
A rather safe bet, cuz yo ass is not allowed ta modify tha body of a
message: you may only set a freshly smoked up body wit \fIbody()\fR.
.IP "shallow_head => \s-1BOOLEAN\s0" 2
.IX Item "shallow_head => BOOLEAN"
Only tha head uses is reused, not tha body.  This is probably a wack chizzle,
because tha header fieldz can be updated, fo' instizzle when labels chizzle.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 1
\& $copy = $msg\->clone;
.Ve
.RE
.IP "Mail::Message\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Message->new(OPTIONS)"
.Vb 10
\& \-Option    \-\-Defined up in     \-\-Default
\&  body                         undef
\&  body_type                    Mail::Message::Body::Lines
\&  deleted                      <false>
\&  field_type                   undef
\&  head                         undef
\&  head_type                    Mail::Message::Head::Complete
\&  labels                       {}
\&  log         Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  messageId                    undef
\&  modified                     <false>
\&  trace       Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  trusted                      <false>
.Ve
.RS 4
.IP "body => \s-1OBJECT\s0" 2
.IX Item "body => OBJECT"
Instantiate tha message wit a funky-ass body which has been pimped somewhere
before tha message is constructed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \s-1OBJECT\s0 must be a sub-class
of Mail::Message::Body.  See also \fIbody()\fR n' \fIstoreBody()\fR.
.IP "body_type => \s-1CLASS\s0" 2
.IX Item "body_type => CLASS"
Default type of body ta be pimped fo' \fIreadBody()\fR.
.IP "deleted => \s-1BOOLEAN\s0" 2
.IX Item "deleted => BOOLEAN"
Is tha file deleted from tha start?
.IP "field_type => \s-1CLASS\s0" 2
.IX Item "field_type => CLASS"
.PD 0
.IP "head => \s-1OBJECT\s0" 2
.IX Item "head => OBJECT"
.PD
Instantiate tha message wit a head which has been pimped somewhere
before tha message is constructed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \s-1OBJECT\s0 must be a (sub\-)class
of Mail::Message::Head. Y'all KNOW dat shit, muthafucka! See also \fIhead()\fR.
.IP "head_type => \s-1CLASS\s0" 2
.IX Item "head_type => CLASS"
Default type of head ta be pimped fo' \fIreadHead()\fR.
.IP "labels => ARRAY|HASH" 2
.IX Item "labels => ARRAY|HASH"
Initial jointz of tha labels.  In case of Mail::Box::Message's, this
shall reflect tha state tha message is in. I aint talkin' bout chicken n' gravy biatch.  For newly constructed
Mail::Message's, dis may be anythang you want, cuz \fIcoerce()\fR
will take care of tha folda specifics once tha message be added ta one.
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "messageId => \s-1STRING\s0" 2
.IX Item "messageId => STRING"
.PD
Da id on which dis message can be recognized. Y'all KNOW dat shit, muthafucka!  If none specified and
not defined up in tha header \-\-but one is needed\*(-- there is ghon be one assigned
to tha message ta be able ta pass unique message-idz between objects.
.IP "modified => \s-1BOOLEAN\s0" 2
.IX Item "modified => BOOLEAN"
Flags dis message as bein modified from tha beginnin on. I aint talkin' bout chicken n' gravy biatch.  Usually,
modification be auto-detected yo, but there may be reasons ta be extra
explicit.
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.PD 0
.IP "trusted => \s-1BOOLEAN\s0" 2
.IX Item "trusted => BOOLEAN"
.PD
Is dis message from a trusted source?  If not, tha content must be
checked before use.  This checkin is ghon be performed when the
body data is decoded or used fo' transmission.
.RE
.RS 4
.RE
.SS "Constructin a message"
.IX Subsection "Constructin a message"
.ie n .IP "$obj\->\fBbounce\fR([RG\-OBJECT|OPTIONS])" 4
.el .IP "\f(CW$obj\fR\->\fBbounce\fR([RG\-OBJECT|OPTIONS])" 4
.IX Item "$obj->bounce([RG-OBJECT|OPTIONS])"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Bounce
.IP "Mail::Message\->\fBbuild\fR([MESSAGE|PART|BODY], \s-1CONTENT\s0)" 4
.IX Item "Mail::Message->build([MESSAGE|PART|BODY], CONTENT)"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Build
.IP "Mail::Message\->\fBbuildFromBody\fR(\s-1BODY,\s0 [\s-1HEAD\s0], \s-1HEADERS\s0)" 4
.IX Item "Mail::Message->buildFromBody(BODY, [HEAD], HEADERS)"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Build
.ie n .IP "$obj\->\fBforward\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBforward\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->forward(OPTIONS)"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardAttach\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBforwardAttach\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->forwardAttach(OPTIONS)"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardEncapsulate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBforwardEncapsulate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->forwardEncapsulate(OPTIONS)"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardInline\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBforwardInline\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->forwardInline(OPTIONS)"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardNo\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBforwardNo\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->forwardNo(OPTIONS)"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardPostlude\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBforwardPostlude\fR()" 4
.IX Item "$obj->forwardPostlude()"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardPrelude\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBforwardPrelude\fR()" 4
.IX Item "$obj->forwardPrelude()"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardSubject\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBforwardSubject\fR(\s-1STRING\s0)" 4
.IX Item "$obj->forwardSubject(STRING)"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Forward
.IP "Mail::Message\->\fBread\fR(FILEHANDLE|SCALAR|REF\-SCALAR|ARRAY\-OF\-LINES, \s-1OPTIONS\s0)" 4
.IX Item "Mail::Message->read(FILEHANDLE|SCALAR|REF-SCALAR|ARRAY-OF-LINES, OPTIONS)"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Read
.ie n .IP "$obj\->\fBrebuild\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBrebuild\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->rebuild(OPTIONS)"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Rebuild
.ie n .IP "$obj\->\fBreply\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBreply\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->reply(OPTIONS)"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Reply
.ie n .IP "$obj\->\fBreplyPrelude\fR([STRING|FIELD|ADDRESS|ARRAY\-OF\-THINGS])" 4
.el .IP "\f(CW$obj\fR\->\fBreplyPrelude\fR([STRING|FIELD|ADDRESS|ARRAY\-OF\-THINGS])" 4
.IX Item "$obj->replyPrelude([STRING|FIELD|ADDRESS|ARRAY-OF-THINGS])"
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Reply
.ie n .IP "$obj\->\fBreplySubject\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBreplySubject\fR(\s-1STRING\s0)" 4
.IX Item "$obj->replySubject(STRING)"
.PD 0
.IP "Mail::Message\->\fBreplySubject\fR(\s-1STRING\s0)" 4
.IX Item "Mail::Message->replySubject(STRING)"
.PD
See \*(L"Constructin a message\*(R" up in Mail::Message::Construct::Reply
.SS "Da message"
.IX Subsection "Da message"
.ie n .IP "$obj\->\fBcontainer\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcontainer\fR()" 4
.IX Item "$obj->container()"
If tha message be a part of another message, \f(CW\*(C`container\*(C'\fR returns the
reference ta tha containin body.
.Sp
example:
.Sp
.Vb 3
\& mah Mail::Message $msg = ...
\& return unless $msg\->body\->isMultipart;
\& mah $part   = $msg\->body\->part(2);
\&
\& return unless $part\->body\->isMultipart;
\& mah $nested = $part\->body\->part(3);
\&
\& $nested\->container;  # returns $msg\->body
\& $nested\->toplevel;   # returns $msg
\& $msg\->container;     # returns undef
\& $msg\->toplevel;      # returns $msg
\& $msg\->isPart;        # returns false
\& $part\->isPart;       # returns true
.Ve
.ie n .IP "$obj\->\fBisDummy\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDummy\fR()" 4
.IX Item "$obj->isDummy()"
Dummy lyrics is used ta fill holez up in linked-list n' such, where only
a message-id is known yo, but not tha place of tha header of body data.
.Sp
This method be also available fo' Mail::Message::Dummy objects,
where dis will return \f(CW\*(C`true\*(C'\fR.  On any extension of \f(CW\*(C`Mail::Message\*(C'\fR,
this will return \f(CW\*(C`false\*(C'\fR.
.ie n .IP "$obj\->\fBisPart\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisPart\fR()" 4
.IX Item "$obj->isPart()"
Returns legit if tha message be a part of another message.  This is
the case fo' Mail::Message::Part extensionz of \f(CW\*(C`Mail::Message\*(C'\fR.
.ie n .IP "$obj\->\fBmessageId\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmessageId\fR()" 4
.IX Item "$obj->messageId()"
Retrieve tha messagez id. Y'all KNOW dat shit, muthafucka!  Every message has a unique message-id. Y'all KNOW dat shit, muthafucka!  This id
is used mainly fo' recognizin rap threads.
.ie n .IP "$obj\->\fBpartNumber\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBpartNumber\fR()" 4
.IX Item "$obj->partNumber()"
Returns a strang representin tha location of dis part.  In case the
top message be a single message, 'undef' is returned. Y'all KNOW dat shit, muthafucka!  When it be a
multipart, '1' upto tha number of multiparts is returned. Y'all KNOW dat shit, muthafucka!  A multi-level
nested part may fo' instizzle return '2.5.1'.
.Sp
Usually, dis strang is straight-up short.  Numberin bigs up tha \s-1IMAP4\s0 design,
see \s-1RFC2060\s0 secion 6.4.5.
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
Print tha message ta tha FILE-HANDLE, which defaults ta tha selected
filehandle, without tha encapsulation sometimes required by a gangbangin' folder
type, like \fIwrite()\fR do.
.Sp
example:
.Sp
.Vb 2
\& $message\->print(\e*STDERR);  # ta tha error output
\& $message\->print;            # ta tha selected file
\&
\& mah $out = IO::File\->new(\*(Aqout\*(Aq, \*(Aqw\*(Aq);
\& $message\->print($out);      # no encapsulation: no folder
\& $message\->write($out);      # wit encapsulation: is folder.
.Ve
.ie n .IP "$obj\->\fBsend\fR([\s-1MAILER\s0], \s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBsend\fR([\s-1MAILER\s0], \s-1OPTIONS\s0)" 4
.IX Item "$obj->send([MAILER], OPTIONS)"
Transmit tha message ta anythang outside dis Perl program.  \s-1MAILER\s0
is a Mail::Transport::Send object.  When tha \s-1MAILER\s0 aint specified, one
will be pimped, n' kept as default fo' tha next lyrics as well.
.Sp
Da \s-1OPTIONS\s0 is maila specific, n' a mixture of what tha fuck is usable for
the creation of tha maila object n' tha bustin  itself.  Therefore, see
for possible options \fIMail::Transport::Send::new()\fR and
\&\fIMail::Transport::Send::send()\fR.
.Sp
example:
.Sp
.Vb 1
\& $message\->send;
.Ve
.Sp
is short (but lil less flexibile) for
.Sp
.Vb 2
\& mah $maila = Mail::Transport::SMTP\->new(@smtpopts);
\& $mailer\->send($message, @sendopts);
.Ve
.Sp
See examples/send.pl up in tha distribution of Mail::Box.
.Sp
example:
.Sp
.Vb 1
\& $message\->send(via => \*(Aqsendmail\*(Aq)
.Ve
.ie n .IP "$obj\->\fBsize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsize\fR()" 4
.IX Item "$obj->size()"
Returns a estimated size of tha whole message up in bytes.  In nuff occasions,
the functions which process tha message further, fo' instizzle \fIsend()\fR
or \fIprint()\fR will need ta add/change header lines or add \s-1CR\s0 characters,
so tha size is only a estimate wit all dem cement margin of tha real
result.
.Sp
Da computation assumes dat each line endin is represented by one
characta (like \s-1UNIX,\s0 MacOS, n' sometimes Cygwin), n' not two characters
(like Windows n' sometimes Cygwin).  If you write tha message ta file on
a system which uses \s-1CR\s0 n' \s-1LF\s0 ta end a single line (all Windows versions),
the result up in dat file is ghon be at least \fInrLines()\fR larger than this
method returns.
.ie n .IP "$obj\->\fBtoplevel\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtoplevel\fR()" 4
.IX Item "$obj->toplevel()"
Returns a reference ta tha main message, which is ghon be tha current
message if tha message aint part of another message.
.ie n .IP "$obj\->\fBwrite\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBwrite\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->write([FILEHANDLE])"
Write tha message ta tha FILE-HANDLE, which defaults ta tha selected
\&\s-1FILEHANDLE,\s0 wit all surroundin shiznit which is needed ta put
it erectly up in a gangbangin' folda file.
.Sp
In most cases, tha result of \f(CW\*(C`write\*(C'\fR is ghon be tha same as wit \fIprint()\fR.
Da main exception is fo' Mbox folda lyrics, which will git printed
with they leadin 'From ' line n' a trailin blank.  Each line of
their body which starts wit 'From ' gonna git a '>' added up in front.
.SS "Da header"
.IX Subsection "Da header"
.ie n .IP "$obj\->\fBbcc\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBbcc\fR()" 4
.IX Item "$obj->bcc()"
Returns tha addresses which is specified on tha \f(CW\*(C`Bcc\*(C'\fR header line (or lines)
A list of Mail::Address objects is returned.
\&\f(CW\*(C`Bcc\*(C'\fR standz fo' \fIBlind Carbon Copy\fR: destinationz of tha message which are
not listed up in tha lyrics straight-up sent.  So, dis field is ghon be empty
for received lyrics yo, but may be present up in lyrics you construct yo ass.
.ie n .IP "$obj\->\fBcc\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcc\fR()" 4
.IX Item "$obj->cc()"
Returns tha addresses which is specified on tha \f(CW\*(C`Cc\*(C'\fR header line (or lines)
A list of Mail::Address objects is returned. Y'all KNOW dat shit, muthafucka!  \f(CW\*(C`Cc\*(C'\fR standz for
\&\fICarbon Copy\fR; tha playas addressed on dis line receive tha message
informational, n' is probably not sposed ta fuckin reply on its content.
.ie n .IP "$obj\->\fBdate\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdate\fR()" 4
.IX Item "$obj->date()"
Method has been removed fo' reasonz of consistency.  Use \fItimestamp()\fR
or \f(CW\*(C`$msg\->head\->get(\*(AqDate\*(Aq)\*(C'\fR.
.ie n .IP "$obj\->\fBdestinations\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdestinations\fR()" 4
.IX Item "$obj->destinations()"
Returns a list of Mail::Address objects which gotz nuff tha combined
info of actizzle \f(CW\*(C`To\*(C'\fR, \f(CW\*(C`Cc\*(C'\fR, n' \f(CW\*(C`Bcc\*(C'\fR addresses.  Double addresses are
removed if detectable.
.ie n .IP "$obj\->\fBfrom\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfrom\fR()" 4
.IX Item "$obj->from()"
Returns tha addresses from tha senders.  It be possible ta have mo' than
one address specified up in tha \f(CW\*(C`From\*(C'\fR field of tha message, according
to tha justification. I aint talkin' bout chicken n' gravy biatch. Therefore a list of Mail::Address objects is
returned, which probably has length 1.
.Sp
If you need only one address from a sender, fo' instizzle ta create a
\&\*(L"original gangsta message by\*(R" line up in constructed forwarded message body, then use
\&\fIsender()\fR.
.Sp
example: rockin \fIfrom()\fR ta git all sender addresses
.Sp
.Vb 1
\& mah @from = $message\->from;
.Ve
.ie n .IP "$obj\->\fBget\fR(\s-1FIELDNAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR(\s-1FIELDNAME\s0)" 4
.IX Item "$obj->get(FIELDNAME)"
Returns tha value which is stored up in tha header field wit tha specified
name.  Da \s-1FIELDNAME\s0 is case insensitive.  Da \fIunfolded body\fR of the
field is returned, stripped from any attributes.
See \fIMail::Message::Field::body()\fR.
.Sp
If tha field has multiple appearances up in tha header, only tha last
instizzle is returned. Y'all KNOW dat shit, muthafucka!  If you need mo' complex handin of fields, then
call \fIMail::Message::Head::get()\fR yo ass.  See \fIstudy()\fR when you
wanna be smart, bustin tha betta (but slower) thang.
.Sp
example: tha \fIget()\fR short-cut fo' header fields
.Sp
.Vb 1
\& print $msg\->get(\*(AqContent\-Type\*(Aq), "\en";
.Ve
.Sp
Is equivalent to:
.Sp
.Vb 1
\& print $msg\->head\->get(\*(AqContent\-Type\*(Aq)\->body, "\en";
.Ve
.ie n .IP "$obj\->\fBguessTimestamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBguessTimestamp\fR()" 4
.IX Item "$obj->guessTimestamp()"
Return a estimate on tha time dis message was sent.  Da data is
derived from tha header, where it can be derived from tha \f(CW\*(C`date\*(C'\fR and
\&\f(CW\*(C`received\*(C'\fR lines.  For MBox-like foldaz you may git tha date from
the from-line as well.
.Sp
This method may return \f(CW\*(C`undef\*(C'\fR if tha header aint parsed or only
partially known. I aint talkin' bout chicken n' gravy biatch.  If you require a time, then use tha \fItimestamp()\fR
method, busted lyrics bout below.
.Sp
example: rockin \fIguessTimestamp()\fR ta git a transmission date
.Sp
.Vb 1
\& print "Receipt ", ($message\->timestamp || \*(Aqunknown\*(Aq), "\en";
.Ve
.ie n .IP "$obj\->\fBhead\fR([\s-1HEAD\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBhead\fR([\s-1HEAD\s0])" 4
.IX Item "$obj->head([HEAD])"
Return (optionally afta setting) tha \s-1HEAD\s0 of dis message.
Da head must be a (sub\-)class of Mail::Message::Head.
When tha head be added, status shiznit is taken from it
and transformed tha fuck into labels.  Mo' labels can be added by the
\&\s-1LABELS\s0 hash.  They is added later.
.Sp
example:
.Sp
.Vb 3
\& mah $header = Mail::Message::Head\->new;
\& $msg\->head($header);    # set
\& mah $head = $msg\->head;  # get
.Ve
.ie n .IP "$obj\->\fBnrLines\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnrLines\fR()" 4
.IX Item "$obj->nrLines()"
Returns tha number of lines used fo' tha whole message.
.ie n .IP "$obj\->\fBsender\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsender\fR()" 4
.IX Item "$obj->sender()"
Returns exactly one address, which is tha originator of dis message.
Da returned Mail::Address object is taken from tha \f(CW\*(C`Sender\*(C'\fR header
field, unless dat field do not exists, up in which case tha first
address from tha \f(CW\*(C`From\*(C'\fR field is taken. I aint talkin' bout chicken n' gravy biatch.  If none of both provide
an address, \f(CW\*(C`undef\*(C'\fR is returned.
.Sp
example: rockin \fIsender()\fR ta git exactly one sender address
.Sp
.Vb 2
\& mah $sender = $message\->sender;
\& print "Reply to: ", $sender\->format, "\en" if defined $sender;
.Ve
.ie n .IP "$obj\->\fBstudy\fR(\s-1FIELDNAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBstudy\fR(\s-1FIELDNAME\s0)" 4
.IX Item "$obj->study(FIELDNAME)"
Study tha content of a gangbangin' field, like \fIget()\fR do, wit as main difference
that a Mail::Message::Field::Full object is returned. Y'all KNOW dat shit, muthafucka!  These objects
stringify ta a utf8 decoded representation of tha data contained in
the field, where \fIget()\fR do not decode.  When tha field do not exist,
then \f(CW\*(C`undef\*(C'\fR is returned. Y'all KNOW dat shit, muthafucka!  See \fIMail::Message::Field::study()\fR.
.Sp
example: tha \fIstudy()\fR short-cut fo' header fields
.Sp
.Vb 1
\& print $msg\->study(\*(Aqto\*(Aq), "\en";
.Ve
.Sp
Is equivalent to:
.Sp
.Vb 2
\& print $msg\->head\->study(\*(Aqto\*(Aq), "\en";       # and
\& print $msg\->head\->get(\*(Aqto\*(Aq)\->study, "\en";
.Ve
.Sp
or better:
 if(my \f(CW$to\fR = \f(CW$msg\fR\->study('to')) { print \*(L"$to\en\*(R" }
 if(my \f(CW$to\fR = \f(CW$msg\fR\->get('to')) { print \f(CW$to\fR\->study, \*(L"\en\*(R" }
.ie n .IP "$obj\->\fBsubject\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsubject\fR()" 4
.IX Item "$obj->subject()"
Returns tha messagez subject, or tha empty string.  Da subject may
have encoded charactas up in it; use \fIstudy()\fR ta git rit of dis shit.
.Sp
example: rockin \fIsubject()\fR ta git tha messagez subject
.Sp
.Vb 2
\& print $msg\->subject;
\& print $msg\->study(\*(Aqsubject\*(Aq);
.Ve
.ie n .IP "$obj\->\fBtimestamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtimestamp\fR()" 4
.IX Item "$obj->timestamp()"
Git a phat timestamp fo' tha message, don't matta how tha fuck much work it is.
Da value returned is compatible wit tha platform dependent result of
function \fItime()\fR.
.Sp
In these days, tha timestamp as supplied by tha message (in tha \f(CW\*(C`Date\*(C'\fR
field) aint trustable at all: nuff spammers produce illegal or
unreal dates ta influence they location up in tha displayed folder.
.Sp
To start, tha received headaz is tried fo' a thugged-out date (see
\&\fIMail::Message::Head::Complete::recvstamp()\fR) n' only then tha \f(CW\*(C`Date\*(C'\fR
field. Y'all KNOW dat shit, muthafucka!  In straight-up rare cases, only wit some locally produced lyrics,
no stamp can be found.
.ie n .IP "$obj\->\fBto\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBto\fR()" 4
.IX Item "$obj->to()"
Returns tha addresses which is specified on tha \f(CW\*(C`To\*(C'\fR header line (or lines).
A list of Mail::Address objects is returned. Y'all KNOW dat shit, muthafucka!  Da playas addressed
here is tha targetz of tha content, n' should read it contents
carefully.
.Sp
example: rockin \fIto()\fR ta git all primar destination addresses
.Sp
.Vb 1
\& mah @to = $message\->to;
.Ve
.SS "Da body"
.IX Subsection "Da body"
.ie n .IP "$obj\->\fBbody\fR([\s-1BODY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBbody\fR([\s-1BODY\s0])" 4
.IX Item "$obj->body([BODY])"
Return tha body of dis message.  \s-1BE WARNED\s0 dat dis returns
you a object which may be encoded: use \fIdecoded()\fR ta git a funky-ass body
with usable data.
.Sp
With options, a freshly smoked up \s-1BODY\s0 is set fo' dis message.  This is \fBnot\fR
for aiiight use unless you KNOW tha consequences: you chizzle
the message content without changin tha message-ID.  Da right
way ta go is via
.Sp
.Vb 3
\& $message = Mail::Message\->buildFromBody($body);  # or
\& $message = Mail::Message\->build($body);          # or
\& $message = $origmsg\->forward(body => $body);
.Ve
.Sp
Da \s-1BODY\s0 must be a (sub\-)class of Mail::Message::Body.  In dis case,
information from tha specified body is ghon be copied tha fuck into tha header n' shit.  The
body object is ghon be encoded if needed, cuz lyrics freestyled ta file
or transmitted shall not contain binary data.  Da converted body
is returned.
.Sp
When \s-1BODY\s0 is \f(CW\*(C`undef\*(C'\fR, tha current message body is ghon be dissected from
the message.  All relation is ghon be cut.  Da body is returned, and
can be connected ta a gangbangin' finger-lickin' different message.
.Sp
example:
.Sp
.Vb 2
\& mah $body      = $msg\->body;
\& mah @encoded   = $msg\->body\->lines;
\&
\& mah $new       = Mail::Message::Body\->new(mime_type => \*(Aqtext/html\*(Aq);
\& mah $converted = $msg\->body($new);
.Ve
.ie n .IP "$obj\->\fBcontentType\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcontentType\fR()" 4
.IX Item "$obj->contentType()"
Returns tha content type header line, or \f(CW\*(C`text/plain\*(C'\fR if it is not
defined. Y'all KNOW dat shit, muthafucka!  Da parametas is ghon be stripped off.
.ie n .IP "$obj\->\fBdecoded\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdecoded\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->decoded(OPTIONS)"
Decodes tha body of dis message, n' returns it as a funky-ass body object.
Short fo' \f(CW\*(C`<$msg\-\*(C'\fRbody\->decoded>>  All \s-1OPTIONS\s0 is passed-on.
.ie n .IP "$obj\->\fBencode\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBencode\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->encode(OPTIONS)"
Encode tha message ta a cold-ass lil certain format.  Read tha details up in the
dedicated manual page Mail::Message::Body::Encode.  Da \s-1OPTIONS\s0 which
can be specified here is dem of tha \fIMail::Message::Body::encode()\fR
method.
.ie n .IP "$obj\->\fBisMultipart\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisMultipart\fR()" 4
.IX Item "$obj->isMultipart()"
Peep whether dis message be a multipart message (has attachments).  To
find dis out, we need at least tha header of tha message; there is no
need ta read tha body of tha message ta detect all dis bullshit.
.ie n .IP "$obj\->\fBisNested\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisNested\fR()" 4
.IX Item "$obj->isNested()"
Returns \f(CW\*(C`true\*(C'\fR fo' \f(CW\*(C`message/rfc822\*(C'\fR lyrics n' message parts.
.ie n .IP "$obj\->\fBparts\fR(['\s-1ALL\s0'|'\s-1ACTIVE\s0'|'\s-1DELETED\s0'|'\s-1RECURSE\s0'|FILTER])" 4
.el .IP "\f(CW$obj\fR\->\fBparts\fR(['\s-1ALL\s0'|'\s-1ACTIVE\s0'|'\s-1DELETED\s0'|'\s-1RECURSE\s0'|FILTER])" 4
.IX Item "$obj->parts(['ALL'|'ACTIVE'|'DELETED'|'RECURSE'|FILTER])"
Returns tha \fIparts\fR of dis message. Usually, tha term \fIpart\fR is used
with \fImultipart\fR lyrics: lyrics which is encapsulated up in tha body
of a message.  To abstract dis concept: dis method will return you
all header-body combinations which is stored within dis message
\&\fBexcept\fR tha multipart n' message/rfc822 wrappers.
Objects returned is \f(CW\*(C`Mail::Message\*(C'\fRz n' Mail::Message::Part's.
.Sp
Da option default ta '\s-1ALL\s0', which will return tha message itself for
single-parts, tha nested content of a message/rfc822 object, respectively
the partz of a multipart without recursion. I aint talkin' bout chicken n' gravy biatch.  In case of '\s-1RECURSE\s0', the
partz of multiparts is ghon be collected recursively.  This option cannot
be combined wit tha other options, which you may want: it dat case
you gotta test yo ass.
.Sp
\&'\s-1ACTIVE\s0' n' '\s-1DELETED\s0' check fo' tha deleted flag on lyrics and
message parts, n' you can put dat on yo' toast.  Da \s-1FILTER\s0 be a cold-ass lil code reference, which is called for
each part of tha message; each part as \f(CW\*(C`RECURSE\*(C'\fR would return.
.Sp
example:
.Sp
.Vb 2
\& mah @parts = $msg\->parts;           # $msg not multipart: returns ($msg)
\& mah $parts = $msg\->parts(\*(AqACTIVE\*(Aq); # returns ($msg)
\&
\& $msg\->delete;
\& mah @parts = $msg\->parts;           # returns ($msg)
\& mah $parts = $msg\->parts(\*(AqACTIVE\*(Aq); # returns ()
.Ve
.SS "Flags"
.IX Subsection "Flags"
.ie n .IP "$obj\->\fBdelete\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR()" 4
.IX Item "$obj->delete()"
Flag tha message ta be deleted, which be a gangbangin' finger-lickin' dirty-ass shortcut for
 \f(CW$msg\fR\->label(deleted => time);
Da real deletion only takes place on a synchronization of tha folder.
See \fIdeleted()\fR as well.
.Sp
Da time stamp of tha moment of deletion is stored as value yo, but that
is not always preserved up in tha folda (dependz on tha implementation).
When tha same message is deleted mo' than once, tha last time stamp
will stay.
.Sp
example:
.Sp
.Vb 4
\& $message\->delete;
\& $message\->deleted(1);  # exactly tha same
\& $message\->label(deleted => 1);
\& delete $message;
.Ve
.ie n .IP "$obj\->\fBdeleted\fR([\s-1BOOLEAN\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdeleted\fR([\s-1BOOLEAN\s0])" 4
.IX Item "$obj->deleted([BOOLEAN])"
Set tha delete flag fo' dis message.  Without argument, tha method
returns tha same ol' dirty as \fIisDeleted()\fR, which is preferred. Y'all KNOW dat shit, muthafucka!  When a true
value is given, \fIdelete()\fR is called.
.Sp
example:
.Sp
.Vb 2
\& $message\->deleted(1);          # delete
\& $message\->delete;              # delete (preferred)
\&
\& $message\->deleted(0);          # undelete
\&
\& if($message\->deleted) {...}    # check
\& if($message\->isDeleted) {...}  # check (preferred)
.Ve
.ie n .IP "$obj\->\fBisDeleted\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDeleted\fR()" 4
.IX Item "$obj->isDeleted()"
Short-cut for
 \f(CW$msg\fR\->label('deleted')
.Sp
For some folda types, yo big-ass booty is ghon git tha time of deletion up in return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  This
dependz on tha implementation.
.Sp
example:
.Sp
.Vb 1
\& next if $message\->isDeleted;
\&
\& if(my $when = $message\->isDeleted) {
\&    print scalar localtime $when;
\& }
.Ve
.ie n .IP "$obj\->\fBisModified\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisModified\fR()" 4
.IX Item "$obj->isModified()"
Returns whether dis message is flagged as bein modified. Y'all KNOW dat shit, muthafucka!  Modifications
are chizzlez up in header lines, when a freshly smoked up body is set ta tha message
(dangerous), or when labels chizzle.
.ie n .IP "$obj\->\fBlabel\fR(LABEL|PAIRS)" 4
.el .IP "\f(CW$obj\fR\->\fBlabel\fR(LABEL|PAIRS)" 4
.IX Item "$obj->label(LABEL|PAIRS)"
Return tha value of tha \s-1LABEL,\s0 optionally afta settin some joints, n' you can put dat on yo' toast.  In
case of settin joints, you specify key-value \s-1PAIRS.\s0
.Sp
Labels is used ta store knowledge bout handlin of tha message within
the folda n' shit.  Flags bout whether a message was read, replied to, or
scheduled fo' deletion.
.Sp
Some labels is taken from tha headerz \f(CW\*(C`Status\*(C'\fR n' \f(CW\*(C`X\-Status\*(C'\fR lines.
Folda types like \s-1MH\s0 define a separate label file, n' Maildir adds
lettas ta tha message filename.  But tha MailBox labels is always the
same.
.Sp
example:
.Sp
.Vb 3
\& print $message\->label(\*(Aqseen\*(Aq);
\& if($message\->label(\*(Aqseen\*(Aq)) {...};
\& $message\->label(seen => 1);
\&
\& $message\->label(deleted => 1);  # same as $message\->delete
.Ve
.ie n .IP "$obj\->\fBlabels\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlabels\fR()" 4
.IX Item "$obj->labels()"
Returns all known labels. In \s-1SCALAR\s0 context, it returns tha knowledge
as reference ta a hash.  This be a reference ta tha original gangsta data yo, but
you shall *not* chizzle dat data directly: call \f(CW\*(C`label\*(C'\fR for
changes!
.Sp
In \s-1LIST\s0 context, you git a list of names which is defined. Y'all KNOW dat shit, muthafucka!  Be warned
that they aint gonna all evaluate ta true, although most of dem will.
.ie n .IP "$obj\->\fBlabelsToStatus\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlabelsToStatus\fR()" 4
.IX Item "$obj->labelsToStatus()"
When tha labels was chizzled, dat may effect tha \f(CW\*(C`Status\*(C'\fR and/or
\&\f(CW\*(C`X\-Status\*(C'\fR header linez of mbox lyrics.  Read bout tha relation
between these fieldz n' tha labels up in tha \s-1DETAILS\s0 chapter.
.Sp
Da method will carefully only affect tha result of \fImodified()\fR when
there be a real chizzle of flags, so not fo' each call ta \fIlabel()\fR.
.ie n .IP "$obj\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.IX Item "$obj->modified([BOOLEAN])"
Returns (optionally afta setting) whether dis message is flagged as
bein modified. Y'all KNOW dat shit, muthafucka!  See \fIisModified()\fR.
.ie n .IP "$obj\->\fBstatusToLabels\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstatusToLabels\fR()" 4
.IX Item "$obj->statusToLabels()"
Update tha labels accordin tha status lines up in tha header n' shit.  See the
description up in tha \s-1DETAILS\s0 chapter.
.SS "Da whole message as text"
.IX Subsection "Da whole message as text"
.ie n .IP "$obj\->\fBfile\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfile\fR()" 4
.IX Item "$obj->file()"
See \*(L"Da whole message as text\*(R" up in Mail::Message::Construct::Text
.ie n .IP "$obj\->\fBlines\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlines\fR()" 4
.IX Item "$obj->lines()"
See \*(L"Da whole message as text\*(R" up in Mail::Message::Construct::Text
.ie n .IP "$obj\->\fBprintStructure\fR([FILEHANDLE|undef],[\s-1INDENT\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprintStructure\fR([FILEHANDLE|undef],[\s-1INDENT\s0])" 4
.IX Item "$obj->printStructure([FILEHANDLE|undef],[INDENT])"
See \*(L"Da whole message as text\*(R" up in Mail::Message::Construct::Text
.ie n .IP "$obj\->\fBstring\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstring\fR()" 4
.IX Item "$obj->string()"
See \*(L"Da whole message as text\*(R" up in Mail::Message::Construct::Text
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBclonedFrom\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBclonedFrom\fR()" 4
.IX Item "$obj->clonedFrom()"
Returns tha \s-1MESSAGE\s0 which is tha source of dis message, which was
created by a \fIclone()\fR operation.
.IP "Mail::Message\->\fBcoerce\fR(\s-1MESSAGE, OPTIONS\s0)" 4
.IX Item "Mail::Message->coerce(MESSAGE, OPTIONS)"
Coerce a \s-1MESSAGE\s0 tha fuck into a Mail::Message.  In some occasions, fo' instance
where you add a message ta a gangbangin' folder, dis coercion be automatically
called ta ensure dat tha erect message type is stored.
.Sp
Da coerced message is returned on success, otherwise \f(CW\*(C`undef\*(C'\fR.  The
coerced message may be a reblessed version of tha original gangsta message
or a freshly smoked up object.  In case tha message has ta be specialized, for
instizzle from a general Mail::Message tha fuck into a Mail::Box::Mbox::Message,
no copy is needed. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat ta coerce a Mail::Internizzle object into
a Mail::Message, a shitload of copyin n' convertin will take place.
.Sp
Valid MESSAGEs which can be coerced tha fuck into Mail::Message objects
are of type
.RS 4
.IP "\(bu" 4
Any type of Mail::Box::Message
.IP "\(bu" 4
MIME::Entitizzle objects, rockin Mail::Message::Convert::MimeEntity
.IP "\(bu" 4
Mail::Internizzle objects, rockin Mail::Message::Convert::MailInternet
.IP "\(bu" 4
Email::Simple objects, rockin Mail::Message::Convert::EmailSimple
.IP "\(bu" 4
Email::Abstract objects
.RE
.RS 4
.Sp
Mail::Message::Part's, which is extensionz of \f(CW\*(C`Mail::Message\*(C'\fR's,
can also be coerced directly from a Mail::Message::Body.
.Sp
example:
.Sp
.Vb 2
\& mah $folda  = Mail::Box::Mbox\->new;
\& mah $message = Mail::Message\->build(...);
\&
\& mah $coerced = Mail::Box::Mbox::Message\->coerce($message);
\& $folder\->addMessage($coerced);
.Ve
.Sp
Simpla replacement fo' tha previous two lines:
.Sp
.Vb 1
\& mah $coerced = $folder\->addMessage($message);
.Ve
.RE
.ie n .IP "$obj\->\fBisDelayed\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDelayed\fR()" 4
.IX Item "$obj->isDelayed()"
Peep whether tha message is delayed (not yet read from file).  Returns
true or false, dependent on tha body type.
.ie n .IP "$obj\->\fBreadBody\fR(\s-1PARSER, HEAD\s0 [, \s-1BODYTYPE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreadBody\fR(\s-1PARSER, HEAD\s0 [, \s-1BODYTYPE\s0])" 4
.IX Item "$obj->readBody(PARSER, HEAD [, BODYTYPE])"
Read a funky-ass body of a message.  Da \s-1PARSER\s0 is tha access ta tha folder's
file, n' tha \s-1HEAD\s0 be already read. Y'all KNOW dat shit, muthafucka!  Hype from tha \s-1HEAD\s0 is used
to create expectations bout tha messagez length yo, but also ta determine
the mime-type n' encodingz of tha body data.
.Sp
Da \s-1BODYTYPE\s0 determines which kind of body is ghon be made n' defaults to
the value specified by new(body_type).
\&\s-1BODYTYPE\s0 may be tha name of a funky-ass body class, or a reference
to a routine which returns tha bodyz class when passed tha \s-1HEAD\s0 as only
argument.
.ie n .IP "$obj\->\fBreadFromParser\fR(\s-1PARSER,\s0 [\s-1BODYTYPE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreadFromParser\fR(\s-1PARSER,\s0 [\s-1BODYTYPE\s0])" 4
.IX Item "$obj->readFromParser(PARSER, [BODYTYPE])"
Read one message from file.  Da \s-1PARSER\s0 is opened on tha file.  First
\&\fIreadHead()\fR is called, n' tha head is stored up in tha message.  Then
\&\fIreadBody()\fR is called, ta produce a funky-ass body.  Also tha body be added to
the message without decodings bein done.
.Sp
Da optionizzle \s-1BODYTYPE\s0 may be a funky-ass body class or a reference ta a cold-ass lil code
which returns a funky-ass body-class based on tha header.
.ie n .IP "$obj\->\fBreadHead\fR(\s-1PARSER\s0 [,CLASS])" 4
.el .IP "\f(CW$obj\fR\->\fBreadHead\fR(\s-1PARSER\s0 [,CLASS])" 4
.IX Item "$obj->readHead(PARSER [,CLASS])"
Read a head tha fuck into a object of tha specified \s-1CLASS. \s0 Da \s-1CLASS\s0 defaults to
new(head_type).  Da \s-1PARSER\s0 is tha access ta tha folderz file.
.ie n .IP "$obj\->\fBrecursiveRebuildPart\fR(\s-1PART, OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBrecursiveRebuildPart\fR(\s-1PART, OPTIONS\s0)" 4
.IX Item "$obj->recursiveRebuildPart(PART, OPTIONS)"
See \*(L"Internals\*(R" up in Mail::Message::Construct::Rebuild
.ie n .IP "$obj\->\fBstoreBody\fR(\s-1BODY\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBstoreBody\fR(\s-1BODY\s0)" 4
.IX Item "$obj->storeBody(BODY)"
Where tha \fIbody()\fR method can be used ta set n' git a funky-ass body, wit all
the necessary checks, dis method is bluntly addin tha specified body
to tha message.  No conversions, not checking.
.ie n .IP "$obj\->\fBtakeMessageId\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtakeMessageId\fR([\s-1STRING\s0])" 4
.IX Item "$obj->takeMessageId([STRING])"
Take tha message-id from tha \s-1STRING,\s0 or create one when tha \f(CW\*(C`undef\*(C'\fR
is specified. Y'all KNOW dat shit, muthafucka!  If not \s-1STRING\s0 nor \f(CW\*(C`undef\*(C'\fR is given, tha current header
of tha message be axed fo' tha value of tha \f(CW\*(AqMessage\-ID\*(Aq\fR field.
.Sp
Anglez (if present) is removed from tha id.
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"\s-1METHODS\*(R"\s0 up in Mail::Message::Construct
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Message\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Message->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Message\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Message->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Message\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Message->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBshortSize\fR([\s-1VALUE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBshortSize\fR([\s-1VALUE\s0])" 4
.IX Item "$obj->shortSize([VALUE])"
.PD 0
.IP "Mail::Message\->\fBshortSize\fR([\s-1VALUE\s0])" 4
.IX Item "Mail::Message->shortSize([VALUE])"
.PD
Represent a integer \s-1VALUE\s0 representin tha size of file or memory,
(which can be large) tha fuck into a gangbangin' finger-lickin' dirty-ass short strang rockin M n' K (Megabytes
and Kilobytes).  Without \s-1VALUE,\s0 tha size of tha message head is used.
.ie n .IP "$obj\->\fBshortString\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBshortString\fR()" 4
.IX Item "$obj->shortString()"
Convert tha message header ta a gangbangin' finger-lickin' dirty-ass short strang (without trailin newline),
representin da most thugged-out blingin facts (for debuggin purposes only).  For
now, it only reports size n' subject.
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
When a message is ta accessible no mo' by any userz reference, Perl
will call \s-1DESTROY\s0 fo' final clean-up.  In dis case, tha head and
body is busted out, n' de-registered fo' tha folda n' shit.  Yo ass shall not call
this yo ass!
.ie n .IP "$obj\->\fBdestruct\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdestruct\fR()" 4
.IX Item "$obj->destruct()"
Remove tha shiznit contained up in tha message object.  This will be
ignored when mo' than one reference ta tha same message object exists,
because tha method has tha same ol' dirty effect as assignin \f(CW\*(C`undef\*(C'\fR ta the
variable which gotz nuff tha reference.  Normal garbage collection will
call \s-1\fIDESTROY\s0()\fR when possible.
.Sp
This method is only provided ta hide differences wit lyrics which are
located up in folders: they \fIMail::Box::Message::destruct()\fR works quite
differently.
.Sp
example: of Mail::Message destruct
.Sp
.Vb 3
\& mah $msg = Mail::Message\->read;
\& $msg\->destruct;
\& $msg = undef;    # same
.Ve
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Structure of a Message"
.IX Subsection "Structure of a Message"
A MIME-compliant message is build upon two parts: tha \fIheader\fR n' the
\&\fIbody\fR.
.PP
\fIDa header\fR
.IX Subsection "Da header"
.PP
Da header be a list of fields, some spannin mo' than one line
(\fIfolded\fR) each spittin some lyrics ta suttin' bout tha message yo. Hype stored
in here is fo' instizzle tha sender of tha message, tha receivers of
the message, when dat shiznit was transported, how tha fuck dat shiznit was transported, etc.
Headaz can grow like large.
.PP
In MailBox, each message object manages exactly one header object
(a Mail::Message::Head) n' one body object (a Mail::Message::Body).
Da header gotz nuff a list of header fields, which is represented by
Mail::Message::Field objects.
.PP
\fIDa body\fR
.IX Subsection "Da body"
.PP
Da body gotz nuff tha \*(L"payload\*(R": tha data ta be transfered.
Da data can be encoded, only accessible wit a specific application,
and may use some weird character-set, like Vietnamese; tha MailBox
distribution tries ta assist you wit handlin these e\-mails without
the need ta know all tha details.  This additionizzle shiznit
(\*(L"meta-information\*(R") bout tha body data is stored up in tha header.
Da header gotz nuff mo' shiznit, fo' instizzle bout tha message
transhiznit n' relations ta other lyrics.
.SS "Message object implementation"
.IX Subsection "Message object implementation"
Da general scam bout tha structure of a message is
.PP
.Vb 7
\& Mail::Message
\&  |  |
\&  |  \`\-has\-one\-\-Mail::Message::Body
\&  |
\&  \`\-\-\-\-has\-one\-\-Mail::Message::Head
\&                  |
\&                  \`\-has\-many\-\-Mail::Message::Field
.Ve
.PP
However: there be bout 7 kindz of body objects, 3 kindz of headaz and
3 kindz of fields.  Yo ass will probably not peep too much of these kinds,
because they is merely pimped fo' performizzle reasons n' can be used
all tha same, wit tha exception of tha multipart bodies.
.PP
A multipart body is either a Mail::Message::Body::Multipart
(mime type \f(CW\*(C`multipart/*\*(C'\fR) or a Mail::Message::Body::Nested
(mime type \f(CW\*(C`message/rfc822\*(C'\fR).  These bodies is mo' complex:
.PP
.Vb 7
\& Mail::Message::Body::Multipart
\&  |
\&  \`\-has\-many\-\-Mail::Message::Part
\&               |  |
\&               |  \`\-has\-one\-\-Mail::Message::Body
\&               |
\&               \`\-\-\-\-has\-one\-\-Mail::Message::Head
.Ve
.PP
Before you try ta reconstruct multiparts or nested lyrics yo ass,
you can betta take a peep Mail::Message::Construct::Rebuild.
.SS "Message class implementation"
.IX Subsection "Message class implementation"
Da class structure of lyrics is straight-up close ta dat of folders.  For
instance, a Mail::Box::File::Message relates ta a Mail::Box::File
folder.
.PP
As extra level of inheritance, it has a Mail::Message, which
is a message without location. I aint talkin' bout chicken n' gravy biatch.  And there be a special case of
message: Mail::Message::Part be a message encapsulated up in a
multipart body.
.PP
Da message types are:
.PP
.Vb 10
\& Mail::Box::Mbox::Message            Mail::Box::POP3::Message
\& |  Mail::Box::Dbx::Message      Mail::Box::IMAP4::Message  |
\& |  |                                                    |  |
\& Mail::Box::File::Message             Mail::Box::Net::Message
\&         |                                      |
\&         |       Mail::Box::Maildir::Message    |
\&         |       |   Mail::Box::MH::Message     |
\&         |       |   |                          |
\&         |       Mail::Box::Dir::Message        |
\&         |                |                     |
\&         \`\-\-\-\-\-\-\-\-\-\-\-\-.   |   .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&                      |   |   |
\&                   Mail::Box::Message    Mail::Message::Part
\&                          |                     |
\&                          |       .\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&                          |       |
\&                      Mail::Message
\&                          |
\&                          |
\&                    Mail::Reporta (general base class)
.Ve
.PP
By far most folda features is implemented up in Mail::Box, so
available ta all folda types.  Sometimes, features which appear
in only a shitload of tha folda types is simulated fo' foldaz dat miss
them, like sub-folda support fo' \s-1MBOX.\s0
.PP
Two strange other message types is defined:
the Mail::Message::Dummy, which fills holez in
Mail::Box::Thread::Node lists, n' a Mail::Box::Message::Destructed,
this be a on purpose demolished message ta reduce memory consumption.
.SS "Labels"
.IX Subsection "Labels"
Labels (also named \*(L"Flags\*(R") is used ta indicate some special condizzle on
the message, primary targeted on organizationizzle issues: which lyrics are
already read or should be deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  There be a straight-up phat user relation
to labels.
.PP
Da main complication is dat each folda type has its own way of storing
labels.  To give a indication: \s-1MBOX\s0 foldaz use \f(CW\*(C`Status\*(C'\fR n' \f(CW\*(C`X\-Status\*(C'\fR
header fields, \s-1MH\s0 uses a \f(CW\*(C`.mh\-sequences\*(C'\fR file, \s-1MAILDIR\s0 encodes tha flags
in tha messagez filename, n' \s-1IMAP\s0 has flags as part of tha protocol.
.PP
Besides, some folda types can store labels wit user defined names,
where other lack dat feature.  Some foldaz have case-insensitive
labels, other don't. Read all bout tha specifics up in tha manual page of
the message type you straight-up have.
.PP
\fIPredefined labels\fR
.IX Subsection "Predefined labels"
.PP
To standardize tha folda types, MailBox has defined tha followin labels,
which can be used wit tha \fIlabel()\fR n' \fIlabels()\fR methodz on all kinds
of lyrics:
.IP "\(bu" 4
deleted
.Sp
This message is flagged ta be deleted once tha folda closes.  Be hella
careful bout tha concept of 'delete' up in a gangbangin' folda context : it is only a
flag, n' do not involve immediate action!  This means, fo' instance,
that tha memory which is used by Perl ta store tha message aint busted out
immediately (see \fIdestruct()\fR if you need to).
.Sp
Da methodz \fIdelete()\fR, \fIdeleted()\fR, n' \fIisDeleted()\fR is only
short-cuts fo' managin tha \f(CW\*(C`delete\*(C'\fR label (az of MailBox 2.052).
.IP "\(bu" 4
draft
.Sp
Da user has prepared dis message yo, but is has not been bust (yet).  This
flag aint automatically added ta a message by MailBox, n' has only
a meanin up in user applications.
.IP "\(bu" 4
flagged
.Sp
Lyrics can be \fIflagged\fR fo' some purpose, fo' instizzle as result of
a search fo' spam up in a gangbangin' folda n' shit.  Da \fIMail::Box::lyrics()\fR method
can be used ta collect all these flagged lyrics from tha folder.
.Sp
Probably it is mo' useful ta use a understandable name (like \f(CW\*(C`spam\*(C'\fR)
for these selections, however these self-defined labels can not stored
in all folda types.
.IP "\(bu" 4
old
.Sp
Da message was already up in tha folda when dat shiznit was opened tha last time,
so was not recently added ta tha folda n' shit.  This flag aint NEVER gonna automatically
be set by MailBox, cuz it would probably conflict wit tha user's
idea of what tha fuck is old.
.IP "\(bu" 4
passed
.Sp
Not often used or kept, dis flag indicates dat tha message was bounced
or forwarded ta one of mah thugs.
.IP "\(bu" 4
replied
.Sp
Da user (or application) has busted a message back ta tha sender of
the message, as response of dis one.  This flag be automatically
set if you use \fIreply()\fR yo, but not wit \fIforward()\fR or \fIbounce()\fR.
.IP "\(bu" 4
seen
.Sp
When dis flag is set, tha receiver of tha message has consumed tha message.
A mail user agent (\s-1MUA\s0) will set dis flag when tha user has opened the
message once.
.PP
\fIStatus n' X\-Status fields\fR
.IX Subsection "Status n' X-Status fields"
.PP
Mbox foldaz have no special meanz of storin shiznit bout lyrics
(except tha message separator line), n' therefore gotta revert to
addin fieldz ta tha message header when suttin' special comes up.
This feature be also enabled fo' \s-1POP3,\s0 although whether dat works
dependz on tha \s-1POP\s0 server.
.PP
All applications which can handle mbox foldaz support tha \f(CW\*(C`Status\*(C'\fR and
\&\f(CW\*(C`X\-Status\*(C'\fR field convensions.  Da followin encodin is used:
.PP
.Vb 5
\& Flag   Field       Label
\& R      Status   => peeped    (Read)
\& O      Status   => oldschool     (not recent)
\& A      X\-Status => replied (Answered)
\& F      X\-Status => flagged
.Ve
.PP
There is no special flag fo' \f(CW\*(C`deleted\*(C'\fR, which most other foldaz support:
lyrics flagged ta be deleted aint NEVER gonna be freestyled ta a gangbangin' folda file when
it is closed.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Error: Cannot coerce a $class object tha fuck into a $class object" 4
.el .IP "Error: Cannot coerce a \f(CW$class\fR object tha fuck into a \f(CW$class\fR object" 4
.IX Item "Error: Cannot coerce a $class object tha fuck into a $class object"
.PD 0
.ie n .IP "Error: Cannot include forward source as $include." 4
.el .IP "Error: Cannot include forward source as \f(CW$include\fR." 4
.IX Item "Error: Cannot include forward source as $include."
.PD
Unknown alternatizzle fo' tha forward(include).  Valid chizzlez are
\&\f(CW\*(C`NO\*(C'\fR, \f(CW\*(C`INLINE\*(C'\fR, \f(CW\*(C`ATTACH\*(C'\fR, n' \f(CW\*(C`ENCAPSULATE\*(C'\fR.
.ie n .IP "Error: Cannot include reply source as $include." 4
.el .IP "Error: Cannot include reply source as \f(CW$include\fR." 4
.IX Item "Error: Cannot include reply source as $include."
Unknown alternatizzle fo' tha \f(CW\*(C`include\*(C'\fR option of \fIreply()\fR.  Valid
choices is \f(CW\*(C`NO\*(C'\fR, \f(CW\*(C`INLINE\*(C'\fR, n' \f(CW\*(C`ATTACH\*(C'\fR.
.IP "Error: Method bounce requires To, Cc, or Bcc" 4
.IX Item "Error: Method bounce requires To, Cc, or Bcc"
Da message \fIbounce()\fR method forwardz a received message off ta one of mah thugs
else without modification; you must specified itz freshly smoked up destination.
If you have tha urge not ta specify any destination, you probably
are lookin fo' \fIreply()\fR. When you wish ta modify tha content, use
\&\fIforward()\fR.
.IP "Error: Method forwardAttach requires a preamble" 4
.IX Item "Error: Method forwardAttach requires a preamble"
.PD 0
.IP "Error: Method forwardEncapsulate requires a preamble" 4
.IX Item "Error: Method forwardEncapsulate requires a preamble"
.IP "Error: No address ta create forwarded to." 4
.IX Item "Error: No address ta create forwarded to."
.PD
If a gangbangin' forward message is pimped, a thugged-out destination address must be specified.
.IP "Error: No default maila found ta bust message." 4
.IX Item "Error: No default maila found ta bust message."
Da message \fIsend()\fR mechanizzle had not enough shiznit ta automatically
find a mail transfer agent ta busted dis message.  Specify a mailer
explicitly rockin tha \f(CW\*(C`via\*(C'\fR options.
.ie n .IP "Error: No rebuild rule $name defined." 4
.el .IP "Error: No rebuild rule \f(CW$name\fR defined." 4
.IX Item "Error: No rebuild rule $name defined."
.PD 0
.IP "Error: Only \fIbuild()\fR Mail::Message's; they is not up in a gangbangin' folda yet" 4
.IX Item "Error: Only build() Mail::Message's; they is not up in a gangbangin' folda yet"
.PD
Yo ass may wish ta construct a message ta be stored up in a some kind
of folda yo, but you need ta do dat up in two steps.  First, create a
normal Mail::Message, n' then add it ta tha folda n' shit.  Durin this
\&\fIMail::Box::addMessage()\fR process, tha message will git \fIcoerce()\fR\-d
into tha right message type, addin storage shiznit n' tha like.
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.IP "Error: coercion starts wit some object" 4
.IX Item "Error: coercion starts wit some object"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
