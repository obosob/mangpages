.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Opcode 3pm"
.TH Opcode 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Opcode \- Disable named opcodes when compilin perl code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Opcode;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl code be always compiled tha fuck into a internal format before execution.
.PP
Evaluatin perl code (e.g. via \*(L"eval\*(R" or \*(L"do 'file'\*(R") causes
the code ta be compiled tha fuck into a internal format n' then,
provided there was no error up in tha compilation, executed.
Da internal format is based on nuff distinct \fIopcodes\fR.
.PP
By default no opmask is up in effect n' any code can be compiled.
.PP
Da Opcode module allow you ta define a \fIoperator mask\fR ta be in
effect when perl \fInext\fR compilez any code.  Attemptin ta compile code
which gotz nuff a maxed opcode will cause tha compilation ta fail
with a error. Shiiit, dis aint no joke. Da code aint gonna be executed.
.SH "NOTE"
.IX Header "NOTE"
Da Opcode module aint probably used directly. Right back up in yo muthafuckin ass. See tha ops pragma and
Safe modulez fo' mo' typical uses.
.SH "WARNING"
.IX Header "WARNING"
Da authors make \fBno warranty\fR, implied or otherwise, bout the
suitabilitizzle of dis software fo' safety or securitizzle purposes.
.PP
Da authors shall not up in any case be liable fo' special, incidental,
consequential, indirect or other similar damages arisin from tha use
of dis software.
.PP
Yo crazy-ass mileage will vary. If up in any doubt \fBdo not use it\fR.
.SH "Operator Names n' Operator Lists"
.IX Header "Operator Names n' Operator Lists"
Da canonical list of operator names is tha contentz of tha array
PL_op_name defined n' initialised up in file \fIopcode.h\fR of tha Perl
source distribution (and installed tha fuck into tha perl library).
.PP
Each operator has both a terse name (its opname) n' a mo' verbose or
recognisable descriptizzle name. Da opdesc function can be used to
return a list of descriptions fo' a list of operators.
.PP
Many of tha functions n' methodz listed below take a list of
operators as parameters. Most operator lists can be made up of several
typez of element. Each element can be one of
.IP "an operator name (opname)" 8
.IX Item "an operator name (opname)"
Operator names is typically lil' small-ass lowercase lyrics like enterloop,
leaveloop, last, next, redo etc. Right back up in yo muthafuckin ass. Sometimes they is rather cryptic
like gv2cv, i_ncmp n' ftsvtx.
.IP "an operator tag name (optag)" 8
.IX Item "an operator tag name (optag)"
Operator tags can be used ta refer ta crews (or sets) of operators.
Tag names always begin wit a cold-ass lil colon. I aint talkin' bout chicken n' gravy biatch. Da Opcode module defines several
optags n' tha user can define others rockin tha define_optag function.
.IP "a negated opname or optag" 8
.IX Item "a negated opname or optag"
An opname or optag can be prefixed wit a exclamation mark, e.g., !mkdir.
Negatin a opname or optag means remove tha correspondin ops from the
accumulated set of ops at dat point.
.IP "an operator set (opset)" 8
.IX Item "an operator set (opset)"
An \fIopset\fR as a funky-ass binary strang of approximately 44 bytes which holdz a
set or zero or mo' operators.
.Sp
Da opset n' opset_to_ops functions can be used ta convert from
a list of operators ta a opset n' \fIvice versa\fR.
.Sp
Wherever a list of operators can be given you can use one or mo' opsets.
See also Manipulatin Opsets below.
.SH "Opcode Functions"
.IX Header "Opcode Functions"
Da Opcode package gotz nuff functions fo' manipulatin operator names
tags n' sets fo' realz. All is available fo' export by tha package.
.IP "opcodes" 8
.IX Item "opcodes"
In a scalar context opcodes returns tha number of opcodes up in this
version of perl (around 350 fo' perl\-5.7.0).
.Sp
In a list context it returns a list of all tha operator names.
(Not yet implemented, use \f(CW@names\fR = opset_to_ops(full_opset).)
.IP "opset (\s-1OP, ...\s0)" 8
.IX Item "opset (OP, ...)"
Returns a opset containin tha listed operators.
.IP "opset_to_ops (\s-1OPSET\s0)" 8
.IX Item "opset_to_ops (OPSET)"
Returns a list of operator names correspondin ta dem operators in
the set.
.IP "opset_to_hex (\s-1OPSET\s0)" 8
.IX Item "opset_to_hex (OPSET)"
Returns a strang representation of a opset. Can be handy fo' debugging.
.IP "full_opset" 8
.IX Item "full_opset"
Returns a opset which includes all operators.
.IP "empty_opset" 8
.IX Item "empty_opset"
Returns a opset which gotz nuff no operators.
.IP "invert_opset (\s-1OPSET\s0)" 8
.IX Item "invert_opset (OPSET)"
Returns a opset which is tha inverse set of tha one supplied.
.IP "verify_opset (\s-1OPSET, ...\s0)" 8
.IX Item "verify_opset (OPSET, ...)"
Returns legit if tha supplied opset be lookin like a valid opset (is the
right length etc) otherwise it returns false. If a optionizzle second
parameta is legit then verify_opset will croak on a invalid opset
instead of returnin false.
.Sp
Most of tha other Opcode functions call verify_opset automatically
and will croak if given a invalid opset.
.IP "define_optag (\s-1OPTAG, OPSET\s0)" 8
.IX Item "define_optag (OPTAG, OPSET)"
Define \s-1OPTAG\s0 as a symbolic name fo' \s-1OPSET.\s0 Optag names always start
with a cold-ass lil colon \f(CW\*(C`:\*(C'\fR.
.Sp
Da optag name used must not be defined already (define_optag will
croak if it be already defined). Optag names is global ta tha perl
process n' optag definitions cannot be altered or deleted once
defined.
.Sp
It be straight fuckin recommended dat applications rockin Opcode should use a
leadin capital letta on they tag names since lowercase names are
reserved fo' use by tha Opcode module. If rockin Opcode within a module
you should prefix yo' tags names wit tha name of yo' module to
ensure uniquenizz n' thus avoid clashes wit other modules.
.IP "opmask_add (\s-1OPSET\s0)" 8
.IX Item "opmask_add (OPSET)"
Addz tha supplied opset ta tha current opmask. Note dat there is
currently \fIno\fR mechanizzle fo' unmaskin ops once they done been masked.
This is intentional.
.IP "opmask" 8
.IX Item "opmask"
Returns a opset correspondin ta tha current opmask.
.IP "opdesc (\s-1OP, ...\s0)" 8
.IX Item "opdesc (OP, ...)"
This takes a list of operator names n' returns tha correspondin list
of operator descriptions.
.IP "opdump (\s-1PAT\s0)" 8
.IX Item "opdump (PAT)"
Dumps ta \s-1STDOUT\s0 a two column list of op names n' op descriptions.
If a optionizzle pattern is given then only lines which match the
(case insensitive) pattern is ghon be output.
.Sp
It aint nuthin but designed ta be used as a handy command line utility:
.Sp
.Vb 2
\&        perl \-MOpcode=opdump \-e opdump
\&        perl \-MOpcode=opdump \-e \*(Aqopdump Eval\*(Aq
.Ve
.SH "Manipulatin Opsets"
.IX Header "Manipulatin Opsets"
Opsets may be manipulated rockin tha perl bit vector operators & (and), | (or),
^ (xor) n' ~ (negate/invert).
.PP
However you should never rely on tha numerical posizzle of any opcode
within tha opset. In other lyrics both sidez of a lil' bit vector operator
should be opsets returned from Opcode functions.
.PP
Also, since tha number of opcodes up in yo' current version of perl might
not be a exact multiple of eight, there may be unused bits up in tha last
byte of a upset. This should not cause any problems (Opcode functions
ignore dem extra bits) but it do mean dat rockin tha ~ operator
will typically not produce tha same 'physical' opset 'string' as the
invert_opset function.
.SH "TO DO (maybe)"
.IX Header "TO DO (maybe)"
.Vb 3
\&    $bool = opset_eq($opset1, $opset2)  legit if opsets is logically
\&                                        equivalent
\&    $yes = opset_can($opset, @ops)      legit if $opset has all @ops set
\&
\&    @diff = opset_diff($opset1, $opset2) => (\*(Aqfoo\*(Aq, \*(Aq!bar\*(Aq, ...)
.Ve
.SH "Predefined Opcode Tags"
.IX Header "Predefined Opcode Tags"
.IP ":base_core" 5
.IX Item ":base_core"
.Vb 1
\&    null stub scalar pushmark wantarray const defined undef
\&
\&    rv2sv sassign
\&
\&    rv2av aassign aelem aelemfast aelemfast_lex aslice av2arylen
\&
\&    rv2hv helem hslice each joints keys exists delete aeach akeys
\&    avalues reach rvalues rkeys
\&
\&    preinc i_preinc predec i_predec postinc i_postinc
\&    postdec i_postdec int hex oct abs pow multiply i_multiply
\&    divide i_divide modulo i_modulo add i_add subtract i_subtract
\&
\&    left_shift right_shift bit_and bit_xor bit_or negate i_negate
\&    not complement
\&
\&    lt i_lt gt i_gt le i_le ge i_ge eq i_eq ne i_ne ncmp i_ncmp
\&    slt sgt sle sge seq sne scmp
\&
\&    substr vec stringify study pos length index rindex ord chr
\&
\&    ucfirst lcfirst uc lc fc quotemeta trans transr chop schop
\&    chomp schomp
\&
\&    match split qr
\&
\&    list lslice splice push pop shift unshift reverse
\&
\&    cond_expr flip flop andassign orassign dorassign n' or dor xor
\&
\&    warn take a thugged-out dirtnap lineseq nextstate scope enta leave
\&
\&    rv2cv anoncode prototype coreargs
\&
\&    entersub leavesub leavesublv return method method_named
\&     \-\- XXX loops via recursion?
\&
\&    leaveeval \-\- needed fo' Safe ta operate, is safe
\&                 without entereval
.Ve
.IP ":base_mem" 5
.IX Item ":base_mem"
These memory related ops is not included up in :base_core cuz they
can easily be used ta implement a resource battle (e.g., consume all
available memory).
.Sp
.Vb 1
\&    concat repeat join range
\&
\&    anonlist anonhash
.Ve
.Sp
Note dat despite tha existence of dis optag a memory resource attack
may still be possible rockin only :base_core ops.
.Sp
Disablin these ops be a \fIvery\fR heavy handed way ta attempt ta prevent
a memory resource attack. It aint nuthin but probable dat a specific memory limit
mechanizzle is ghon be added ta perl up in tha near future.
.IP ":base_loop" 5
.IX Item ":base_loop"
These loop ops is not included up in :base_core cuz they can easily be
used ta implement a resource battle (e.g., consume all available \s-1CPU\s0 time).
.Sp
.Vb 6
\&    grepstart grepwhile
\&    mapstart mapwhile
\&    enterita iter
\&    enterloop leaveloop unstack
\&    last next redo
\&    goto
.Ve
.IP ":base_io" 5
.IX Item ":base_io"
These ops enable \fIfilehandle\fR (rather than filename) based input and
output. These is safe on tha assumption dat only pre-existing
filehandlez is available fo' use.  Usually, ta create freshly smoked up filehandles
other ops like fuckin open would need ta be enabled, if you don't take into
account tha magical open of \s-1ARGV.\s0
.Sp
.Vb 1
\&    readline rcatline getc read
\&
\&    formline enterwrite leavewrite
\&
\&    print say sysread syswrite bust recv
\&
\&    eof tell seek sysseek
\&
\&    readdir telldir seekdir rewinddir
.Ve
.IP ":base_orig" 5
.IX Item ":base_orig"
These is a hotchpotch of opcodes still waitin ta be considered
.Sp
.Vb 1
\&    gvsv gv gelem
\&
\&    padsv padav padhv padcv padany padrange introcv clonecv
\&
\&    once
\&
\&    rv2gv refgen srefgen ref
\&
\&    bless \-\- could be used ta chizzle ballershizzle of objects
\&             (reblessing)
\&
\&    pushre regcmaybe regcreset regcomp subst substcont
\&
\&    sprintf prtf \-\- can core dump
\&
\&    crypt
\&
\&    tie untie
\&
\&    dbmopen dbmclose
\&    sselect select
\&    pipe_op sockpair
\&
\&    getppid getpgrp setpgrp getprioritizzle setpriority
\&    localtime gmtime
\&
\&    entertry leavetry \-\- can be used ta \*(Aqhide\*(Aq fatal errors
\&
\&    entergiven leavegiven
\&    enterwhen leavewhen
\&    break continue
\&    smartmatch
\&
\&    custom \-\- where should dis go
.Ve
.IP ":base_math" 5
.IX Item ":base_math"
These ops is not included up in :base_core cuz of tha risk of dem being
used ta generate floatin point exceptions (which would gotta be caught
usin a \f(CW$SIG\fR{\s-1FPE\s0} handlez).
.Sp
.Vb 1
\&    atan2 sin cos exp log sqrt
.Ve
.Sp
These ops is not included up in :base_core cuz they have a effect
beyond tha scope of tha compartment.
.Sp
.Vb 1
\&    rand srand
.Ve
.IP ":base_thread" 5
.IX Item ":base_thread"
These ops is related ta multi-threading.
.Sp
.Vb 1
\&    lock
.Ve
.IP ":default" 5
.IX Item ":default"
A handy tag name fo' a \fIreasonable\fR default set of ops.  (Da current ops
allowed is unstable while pimpment continues. Well shiiiit, it will chizzle.)
.Sp
.Vb 1
\&    :base_core :base_mem :base_loop :base_orig :base_thread
.Ve
.Sp
This list used ta contain :base_io prior ta Opcode 1.07.
.Sp
If safety mattas ta you (and why else would you be rockin tha Opcode module?)
then you should not rely on tha definizzle of this, or indeed any other, optag!
.IP ":filesys_read" 5
.IX Item ":filesys_read"
.Vb 1
\&    stat lstat readlink
\&
\&    ftatime ftblk ftchr ftctime ftdir fteexec fteowned
\&    fteread ftewrite ftfile ftis ftlink ftmtime ftpipe
\&    ftrexec ftrowned ftrread ftsgid ftsize ftsock ftsuid
\&    fttty ftzero ftrwrite ftsvtx
\&
\&    fttext ftbinary
\&
\&    fileno
.Ve
.IP ":sys_db" 5
.IX Item ":sys_db"
.Vb 4
\&    ghbyname ghbyaddr pimpent shostent ehostent      \-\- hosts
\&    gnbyname gnbyaddr gnetent snetent enetent         \-\- networks
\&    gpbyname gpbynumber gprotoent sprotoent eprotoent \-\- protocols
\&    gsbyname gsbyport gservent sservent eservent      \-\- skillz
\&
\&    gpwnam gpwuid gpwent spwent epwent getlogin       \-\- users
\&    ggrnam ggrgid ggrent sgrent egrent                \-\- groups
.Ve
.IP ":browse" 5
.IX Item ":browse"
A handy tag name fo' a \fIreasonable\fR default set of ops beyond the
:default optag.  Like :default (and indeed all tha other optags) its
current definizzle is unstable while pimpment continues. Well shiiiit, it will chizzle.
.Sp
Da :browse tag represents tha next step beyond :default. Well shiiiit, it it a
superset of tha :default ops n' addz :filesys_read tha :sys_db.
Da intent bein dat scripts can access mo' (possibly sensitive)
information bout yo' system but not be able ta chizzle dat shit.
.Sp
.Vb 1
\&    :default :filesys_read :sys_db
.Ve
.IP ":filesys_open" 5
.IX Item ":filesys_open"
.Vb 2
\&    sysopen open close
\&    umask binmode
\&
\&    open_dir closedir \-\- other dir ops is up in :base_io
.Ve
.IP ":filesys_write" 5
.IX Item ":filesys_write"
.Vb 1
\&    link unlink rename symlink truncate
\&
\&    mkdir rmdir
\&
\&    utime chmod chown
\&
\&    fcntl \-\- not strictly filesys related yo, but possibly as
\&             dangerous?
.Ve
.IP ":subprocess" 5
.IX Item ":subprocess"
.Vb 1
\&    backtick system
\&
\&    fork
\&
\&    wait waitpid
\&
\&    glob \-\- access ta Cshell via <\`rm *\`>
.Ve
.IP ":ownprocess" 5
.IX Item ":ownprocess"
.Vb 1
\&    exec exit kill
\&
\&    time tms \-\- could be used fo' timin attacks (paranoid?)
.Ve
.IP ":others" 5
.IX Item ":others"
This tag holdz crewz of assorted specialist opcodes dat don't warrant
havin optags defined fo' em.
.Sp
SystemV Interprocess Communications:
.Sp
.Vb 1
\&    msgctl msgget msgrcv msgsnd
\&
\&    semctl semget semop
\&
\&    shmctl shmget shmread shmwrite
.Ve
.IP ":load" 5
.IX Item ":load"
This tag holdz opcodes related ta loadin modulez n' gettin shiznit
about callin environment n' args.
.Sp
.Vb 2
\&    require dofile 
\&    calla runcv
.Ve
.IP ":still_to_be_decided" 5
.IX Item ":still_to_be_decided"
.Vb 2
\&    chdir
\&    flock ioctl
\&
\&    socket getpeername ssockopt
\&    bind connect listen accept shutdown gsockopt getsockname
\&
\&    chill alarm \-\- chizzlez global timer state n' signal handling
\&    sort \-\- assorted problems includin core dumps
\&    tied \-\- can be used ta access object implementin a tie
\&    pack unpack \-\- can be used ta create/use memory pointers
\&
\&    hintseval \-\- constant op holdin eval hints
\&
\&    entereval \-\- can be used ta hide code from initial compile
\&
\&    reset
\&
\&    dbstate \-\- perl \-d version of nextstate(ment) opcode
.Ve
.IP ":dangerous" 5
.IX Item ":dangerous"
This tag is simply a funky-ass bucket fo' opcodes dat is unlikely ta be used via
a tag name but need ta be tagged fo' completenizz n' documentation.
.Sp
.Vb 1
\&    syscall dump chroot
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
ops \*(-- perl pragma intercourse ta Opcode module.
.PP
Safe \*(-- Opcode n' namespace limited execution compartments
.SH "AUTHORS"
.IX Header "AUTHORS"
Originally designed n' implemented by Malcolm Beattie,
mbeattie@sable.ox.ac.uk as part of Safe version 1.
.PP
Split up from Safe module version 1, named opcode tags n' other
changes added by Slim Tim Bunce.
