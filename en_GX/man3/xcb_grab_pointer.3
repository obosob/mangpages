.TH xcb_grab_pointa 3  2013-08-04 "XCB" "XCB Requests"
.ad l
.SH NAME
xcb_grab_pointa \- Grab tha pointer
.SH SYNOPSIS
.hy 0
.B #include <xcb/xproto.h>
.SS Request function
.HP
xcb_grab_pointer_cookie_t \fBxcb_grab_pointer\fP(xcb_connection_t\ *\fIconn\fP, uint8_t\ \fIballer_events\fP, xcb_window_t\ \fIgrab_window\fP, uint16_t\ \fIevent_mask\fP, uint8_t\ \fIpointer_mode\fP, uint8_t\ \fIkeyboard_mode\fP, xcb_window_t\ \fIconfine_to\fP, xcb_cursor_t\ \fIcursor\fP, xcb_timestamp_t\ \fItime\fP);
.PP
.SS Reply datastructure
.nf
.sp
typedef struct xcb_grab_pointer_reply_t {
    uint8_t  \fIresponse_type\fP;
    uint8_t  \fIstatus\fP;
    uint16_t \fIsequence\fP;
    uint32_t \fIlength\fP;
} \fBxcb_grab_pointer_reply_t\fP;
.fi
.SS Reply function
.HP
xcb_grab_pointer_reply_t *\fBxcb_grab_pointer_reply\fP(xcb_connection_t\ *\fIconn\fP, xcb_grab_pointer_cookie_t\ \fIcookie\fP, xcb_generic_error_t\ **\fIe\fP);
.br
.hy 1
.SH REQUEST ARGUMENTS
.IP \fIconn\fP 1i
Da XCB connection ta X11.
.IP \fIballer_events\fP 1i
If 1, tha \fIgrab_window\fP will still git tha pointa events, n' you can put dat on yo' toast. If 0, events is not
reported ta tha \fIgrab_window\fP.
.IP \fIgrab_window\fP 1i
Specifies tha window on which tha pointa should be grabbed.
.IP \fIevent_mask\fP 1i
Specifies which pointa events is reported ta tha client.

TODO: which joints?
.IP \fIpointer_mode\fP 1i
One of tha followin joints:
.RS 1i
.IP \fIXCB_GRAB_MODE_SYNC\fP 1i
Da state of tha keyboard appears ta freeze: No further keyboard events are
generated by tha server until tha grabbin client thangs a releasing
\fIAllowEvents\fP request or until tha keyboard grab is busted out.
.IP \fIXCB_GRAB_MODE_ASYNC\fP 1i
Keyboard event processin continues normally.
.RE
.RS 1i


.RE
.IP \fIkeyboard_mode\fP 1i
One of tha followin joints:
.RS 1i
.IP \fIXCB_GRAB_MODE_SYNC\fP 1i
Da state of tha keyboard appears ta freeze: No further keyboard events are
generated by tha server until tha grabbin client thangs a releasing
\fIAllowEvents\fP request or until tha keyboard grab is busted out.
.IP \fIXCB_GRAB_MODE_ASYNC\fP 1i
Keyboard event processin continues normally.
.RE
.RS 1i


.RE
.IP \fIconfine_to\fP 1i
Specifies tha window ta confine tha pointa up in (the user aint gonna be able to
move tha pointa outta dat window).

Da special value \fIXCB_NONE\fP means don't confine tha pointer.
.IP \fIcursor\fP 1i
Specifies tha cursor dat should be displayed or \fIXCB_NONE\fP ta not chizzle the
cursor.
.IP \fItime\fP 1i
Da time argument allows you ta avoid certain circumstances dat come up if
applications take a long-ass time ta respond or if there be long network delays.
Consider a thang where you have two applications, both of which normally
grab tha pointa when clicked on. I aint talkin' bout chicken n' gravy biatch. If both applications specify tha timestamp
from tha event, tha second application may raise up fasta n' successfully grab
the pointa before tha straight-up original gangsta application. I aint talkin' bout chicken n' gravy biatch. Da first application then will get
an indication dat tha other application grabbed tha pointa before its request
was processed.

Da special value \fIXCB_CURRENT_TIME\fP is ghon be replaced wit tha current server
time.
.SH REPLY FIELDS
.IP \fIresponse_type\fP 1i
Da type of dis reply, up in dis case \fIXCB_GRAB_POINTER\fP. This field be also present up in tha \fIxcb_generic_reply_t\fP n' can be used ta tell replies apart from each other.
.IP \fIsequence\fP 1i
Da sequence number of tha last request processed by tha X11 server.
.IP \fIlength\fP 1i
Da length of tha reply, up in lyrics (a word is 4 bytes).
.IP \fIstatus\fP 1i
One of tha followin joints:
.RS 1i
.IP \fIXCB_GRAB_STATUS_SUCCESS\fP 1i
TODO: NOT YET DOCUMENTED.
.IP \fIXCB_GRAB_STATUS_ALREADY_GRABBED\fP 1i
TODO: NOT YET DOCUMENTED.
.IP \fIXCB_GRAB_STATUS_INVALID_TIME\fP 1i
TODO: NOT YET DOCUMENTED.
.IP \fIXCB_GRAB_STATUS_NOT_VIEWABLE\fP 1i
TODO: NOT YET DOCUMENTED.
.IP \fIXCB_GRAB_STATUS_FROZEN\fP 1i
TODO: NOT YET DOCUMENTED.
.RE
.RS 1i
TODO: NOT YET DOCUMENTED.
.RE
.SH DESCRIPTION
Actively grabs control of tha pointer n' shit. Further pointa events is reported only ta tha grabbin client. Overrides any actizzle pointa grab by dis client.
.SH RETURN VALUE
Returns a \fIxcb_grab_pointer_cookie_t\fP. Errors gotta be handled when callin tha reply function \fIxcb_grab_pointer_reply\fP.

If you wanna handle errors up in tha event loop instead, use \fIxcb_grab_pointer_unchecked\fP. Right back up in yo muthafuckin ass. See \fBxcb-requests(3)\fP fo' details.
.SH ERRORS
.IP \fIxcb_window_error_t\fP 1i
Da specified \fIwindow\fP do not exist.
.IP \fIxcb_value_error_t\fP 1i
TODO: reasons?
.SH EXAMPLE
.nf
.sp
/*
 * Grabs tha pointa actively
 *
 */
void my_example(xcb_connection *conn, xcb_screen_t *screen, xcb_cursor_t cursor) {
    xcb_grab_pointer_cookie_t cookie;
    xcb_grab_pointer_reply_t *reply;

    cookie = xcb_grab_pointer(
        conn,
        false,               /* git all pointa events specified by tha followin mask */
        screen->root,        /* grab tha root window */
        XCB_NONE,            /* which events ta let all up in */
        XCB_GRAB_MODE_ASYNC, /* pointa events should continue as aiiight */
        XCB_GRAB_MODE_ASYNC, /* keyboard mode */
        XCB_NONE,            /* confine_to = up in which window should tha cursor stay */
        cursor,              /* we chizzle tha cursor ta whatever tha user wanted */
        XCB_CURRENT_TIME
    );

    if ((reply = xcb_grab_pointer_reply(conn, cookie, NULL))) {
        if (reply->status == XCB_GRAB_STATUS_SUCCESS)
            printf("successfully grabbed tha pointer\\n");
        free(preply);
    }
}
.fi
.SH SEE ALSO
.BR xcb-requests (3),
.BR xcb-examplez (3),
.BR xcb_grab_keyboard (3)
.SH AUTHOR
Generated from xproto.xml. Contact xcb@lists.freedesktop.org fo' erections n' improvements.
