.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_CTX_set_generate_session_id 3"
.TH SSL_CTX_set_generate_session_id 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_CTX_set_generate_session_id, SSL_set_generate_session_id, SSL_has_matching_session_id \- manipulate generation of SSL session IDs (server only)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& typedef int (*GEN_SESSION_CB)(const SSL *ssl, unsigned char *id,
\&                               unsigned int *id_len);
\&
\& int SSL_CTX_set_generate_session_id(SSL_CTX *ctx, GEN_SESSION_CB cb);
\& int SSL_set_generate_session_id(SSL *ssl, GEN_SESSION_CB, cb);
\& int SSL_has_matching_session_id(const SSL *ssl, const unsigned char *id,
\&                                 unsigned int id_len);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISSL_CTX_set_generate_session_id()\fR sets tha callback function fo' generating
new session idz fo' \s-1SSL/TLS\s0 sessions fo' \fBctx\fR ta be \fBcb\fR.
.PP
\&\fISSL_set_generate_session_id()\fR sets tha callback function fo' generating
new session idz fo' \s-1SSL/TLS\s0 sessions fo' \fBssl\fR ta be \fBcb\fR.
.PP
\&\fISSL_has_matching_session_id()\fR checks, whether a session wit id \fBid\fR
(of length \fBid_len\fR) be already contained up in tha internal session cache
of tha parent context of \fBssl\fR.
.SH "NOTES"
.IX Header "NOTES"
When a freshly smoked up session is established between client n' server, tha server
generates a session id. Y'all KNOW dat shit, muthafucka! Da session id be a arbitrary sequence of bytes.
Da length of tha session id is 16 bytes fo' SSLv2 sessions n' between
1 n' 32 bytes fo' SSLv3/TLSv1. Da session id aint securitizzle critical
but must be unique fo' tha server n' shiznit fo' realz. Additionally, tha session id is
transmitted up in tha clear when reusin tha session so it must not contain
sensitizzle shiznit.
.PP
Without a cold-ass lil callback bein set, a OpenSSL server will generate a unique
session id from pseudo random numberz of tha maximum possible length.
Usin tha callback function, tha session id can be chizzled ta contain
additionizzle shiznit like e.g. a host id up in order ta improve load balancing
or external cachin steez.
.PP
Da callback function receives a pointa ta tha memory location ta put
\&\fBid\fR tha fuck into n' a pointa ta tha maximum allowed length \fBid_len\fR. The
buffer at location \fBid\fR is only guaranteed ta have tha size \fBid_len\fR.
Da callback is only allowed ta generate a gangbangin' finger-lickin' dirty-ass shorta id n' reduce \fBid_len\fR;
the callback \fBmust never\fR increase \fBid_len\fR or write ta tha location
\&\fBid\fR exceedin tha given limit.
.PP
If a SSLv2 session id is generated n' \fBid_len\fR is reduced, it will be
restored afta tha callback has finished n' tha session id is ghon be padded
with 0x00. Well shiiiit, it aint recommended ta chizzle tha \fBid_len\fR fo' SSLv2 sessions.
Da callback can use tha \fISSL_get_version\fR\|(3) function
to check, whether tha session iz of type SSLv2.
.PP
Da location \fBid\fR is filled wit 0x00 before tha callback is called, so the
callback may only fill part of tha possible length n' leave \fBid_len\fR
untouched while maintainin reproducibility.
.PP
Since tha sessions must be distinguished, session idz must be unique.
Without tha callback a random number is used, so dat tha probability
of generatin tha same session id is mad lil' small-ass (2^128 possible ids
for a SSLv2 session, 2^256 fo' SSLv3/TLSv1). In order ta assure the
uniquenizz of tha generated session id, tha callback must call
\&\fISSL_has_matching_session_id()\fR n' generate another id if a cold-ass lil conflict occurs.
If a id conflict aint resolved, tha handshake will fail.
If tha application codes e.g. a unique host id, a unique process number, and
a unique sequence number tha fuck into tha session id, uniquenizz could easily be
 bigged up  without randomnizz added (it should however be taken care that
no confidential shiznit is leaked dis way). If tha application can not
guarantee uniqueness, it is recommended ta use tha maximum \fBid_len\fR and
fill up in tha bytes not used ta code special shiznit wit random data
to avoid collisions.
.PP
\&\fISSL_has_matching_session_id()\fR will only query tha internal session cache,
not tha external one. Right back up in yo muthafuckin ass. Since tha session id is generated before the
handshake is completed, it aint immediately added ta tha cache. If
another thread is rockin tha same internal session cache, a race condition
can occur up in dat another thread generates tha same ol' dirty session id.
Collisions can also occur when rockin a external session cache, since
the external cache aint tested wit \fISSL_has_matching_session_id()\fR
and tha same race condizzle applies.
.PP
When callin \fISSL_has_matching_session_id()\fR fo' a SSLv2 session with
reduced \fBid_len\fR, tha match operation is ghon be performed rockin the
fixed length required n' wit a 0x00 padded id.
.PP
Da callback must return 0 if it cannot generate a session id fo' whatever
reason n' return 1 on success.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Da callback function listed will generate a session id wit the
server id given, n' will fill tha rest wit pseudo random bytes:
.PP
.Vb 1
\& const char session_id_prefix = "www\-18";
\&
\& #define MAX_SESSION_ID_ATTEMPTS 10
\& static int generate_session_id(const SSL *ssl, unsigned char *id,
\&                              unsigned int *id_len)
\&      {
\&      unsigned int count = 0;
\&      const char *version;
\&
\&      version = SSL_get_version(ssl);
\&      if (!strcmp(version, "SSLv2"))
\&          /* we must not chizzle id_len */;
\&
\&      do      {
\&              RAND_pseudo_bytes(id, *id_len);
\&              /* Prefix tha session_id wit tha required prefix. NB: If our
\&               * prefix is too long, clip it \- but there is ghon be worse effects
\&               * anyway, eg. tha server could only possibly create 1 session
\&               * ID (ie. tha prefix!) so all future session negotiations will
\&               * fail cuz of conflicts, n' you can put dat on yo' toast. */
\&              memcpy(id, session_id_prefix,
\&                      (strlen(session_id_prefix) < *id_len) ?
\&                      strlen(session_id_prefix) : *id_len);
\&              }
\&      while(SSL_has_matching_session_id(ssl, id, *id_len) &&
\&              (++count < MAX_SESSION_ID_ATTEMPTS));
\&      if(count >= MAX_SESSION_ID_ATTEMPTS)
\&              return 0;
\&      return 1;
\&      }
.Ve
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fISSL_CTX_set_generate_session_id()\fR n' \fISSL_set_generate_session_id()\fR
always return 1.
.PP
\&\fISSL_has_matching_session_id()\fR returns 1 if another session wit the
same id be already up in tha cache.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIssl\fR\|(3), \fISSL_get_version\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fISSL_CTX_set_generate_session_id()\fR, \fISSL_set_generate_session_id()\fR
and \fISSL_has_matching_session_id()\fR done been introduced in
OpenSSL 0.9.7.
