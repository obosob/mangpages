" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::tr2::dynamic_bitset< _WordT, _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBstd::tr2::__dynamic_bitset_base< _WordT, _Alloc >\fP\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBreference\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fB__dynamic_bitset_base\fP
.br
< _WordT, _Alloc > \fB_Base\fP"
.br
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef _WordT \fBblock_type\fP"
.br
.ti -1c
.RI "typedef bool \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBdynamic_bitset\fP (const allocator_type &__alloc=allocator_type())"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP (size_type __nbits, unsigned long long __val=0ULL, const allocator_type &__alloc=allocator_type())"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP (\fBinitializer_list\fP< block_type > __il, const allocator_type &__alloc=allocator_type())"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc1 > \fBdynamic_bitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc1 > &__str, typename \fBbasic_string\fP< _CharT, _Traits, _Alloc1 >::size_type __pos=0, typename \fBbasic_string\fP< _CharT, _Traits, _Alloc1 >::size_type __n=\fBstd::basic_string\fP< _CharT, _Traits, _Alloc1 >::npos, _CharT __zero=_CharT('0'), _CharT __one=_CharT('1'), const allocator_type &__alloc=allocator_type())"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP (const char *__str, const allocator_type &__alloc=allocator_type())"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP (const \fBdynamic_bitset\fP &__b)"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP (\fBdynamic_bitset\fP &&__b)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > void \fB_M_copy_from_ptr\fP (const _CharT *, size_t, size_t, size_t, _CharT, _CharT)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc1 > void \fB_M_copy_from_string\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc1 > &__str, size_t __pos, size_t __n, _CharT __zero=_CharT('0'), _CharT __one=_CharT('1'))"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc1 > void \fB_M_copy_to_string\fP (\fBstd::basic_string\fP< _CharT, _Traits, _Alloc1 > &__str, _CharT __zero=_CharT('0'), _CharT __one=_CharT('1')) const "
.br
.ti -1c
.RI "bool \fBall\fP () const "
.br
.ti -1c
.RI "bool \fBany\fP () const "
.br
.ti -1c
.RI "void \fBappend\fP (block_type __block)"
.br
.ti -1c
.RI "void \fBappend\fP (\fBinitializer_list\fP< block_type > __il)"
.br
.ti -1c
.RI "template<typename _BlockInputIterator > void \fBappend\fP (_BlockInputIterator __first, _BlockInputIterator __last)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "size_type \fBcount\fP () const noexcept"
.br
.ti -1c
.RI "bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "size_type \fBfind_first\fP () const "
.br
.ti -1c
.RI "size_type \fBfind_next\fP (size_t __prev) const "
.br
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > & \fBflip\fP ()"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > & \fBflip\fP (size_type __pos)"
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const "
.br
.ti -1c
.RI "bool \fBis_proper_subset_of\fP (const \fBdynamic_bitset\fP &__b) const "
.br
.ti -1c
.RI "bool \fBis_subset_of\fP (const \fBdynamic_bitset\fP &__b) const "
.br
.ti -1c
.RI "constexpr size_type \fBmax_size\fP () noexcept"
.br
.ti -1c
.RI "bool \fBnone\fP () const "
.br
.ti -1c
.RI "size_type \fBnum_blocks\fP () const noexcept"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP & \fBoperator=\fP (const \fBdynamic_bitset\fP &__b)"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP & \fBoperator=\fP (\fBdynamic_bitset\fP &&__b)"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > \fBoperator~\fP () const "
.br
.ti -1c
.RI "void \fBpush_back\fP (bool __bit)"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > & \fBreset\fP ()"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > & \fBreset\fP (size_type __pos)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __nbits, bool __value=false)"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > & \fBset\fP ()"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > & \fBset\fP (size_type __pos, bool __val=true)"
.br
.ti -1c
.RI "size_type \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "void \fBswap\fP (\fBdynamic_bitset\fP &__b)"
.br
.ti -1c
.RI "bool \fBtest\fP (size_type __pos) const "
.br
.ti -1c
.RI "template<typename _CharT  = char, typename _Traits  = std::char_traits<_CharT>, typename _Alloc1  = std::allocator<_CharT>> \fBstd::basic_string\fP< _CharT, 
.br
_Traits, _Alloc1 > \fBto_string\fP (_CharT __zero=_CharT('0'), _CharT __one=_CharT('1')) const "
.br
.ti -1c
.RI "unsigned long long \fBto_ullong\fP () const "
.br
.ti -1c
.RI "unsigned long \fBto_ulong\fP () const "
.br
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > & \fBoperator&=\fP (const \fBdynamic_bitset\fP< _WordT, _Alloc > &__rhs)"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > & \fBoperator&=\fP (\fBdynamic_bitset\fP< _WordT, _Alloc > &&__rhs)"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > & \fBoperator|=\fP (const \fBdynamic_bitset\fP< _WordT, _Alloc > &__rhs)"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > & \fBoperator^=\fP (const \fBdynamic_bitset\fP< _WordT, _Alloc > &__rhs)"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > & \fBoperator-=\fP (const \fBdynamic_bitset\fP< _WordT, _Alloc > &__rhs)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > & \fBoperator<<=\fP (size_type __pos)"
.br
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > & \fBoperator>>=\fP (size_type __pos)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBreference\fP \fBoperator[]\fP (size_type __pos)"
.br
.ti -1c
.RI "const_reference \fBoperator[]\fP (size_type __pos) const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > \fBoperator<<\fP (size_type __pos) const "
.br
.ti -1c
.RI "\fBdynamic_bitset\fP< _WordT, _Alloc > \fBoperator>>\fP (size_type __pos) const "
.br
.in -1c
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const size_type \fBbits_per_block\fP"
.br
.ti -1c
.RI "static const size_type \fBnpos\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "size_t \fB_M_are_all_aux\fP () const "
.br
.ti -1c
.RI "void \fB_M_assign\fP (const \fB__dynamic_bitset_base\fP &__b)"
.br
.ti -1c
.RI "void \fB_M_clear\fP ()"
.br
.ti -1c
.RI "void \fB_M_do_and\fP (const \fB__dynamic_bitset_base\fP &__x)"
.br
.ti -1c
.RI "void \fB_M_do_append_block\fP (block_type __block, size_type __pos)"
.br
.ti -1c
.RI "size_t \fB_M_do_count\fP () const "
.br
.ti -1c
.RI "void \fB_M_do_dif\fP (const \fB__dynamic_bitset_base\fP &__x)"
.br
.ti -1c
.RI "size_type \fB_M_do_find_first\fP (size_t __not_found) const "
.br
.ti -1c
.RI "size_type \fB_M_do_find_next\fP (size_t __prev, size_t __not_found) const "
.br
.ti -1c
.RI "void \fB_M_do_flip\fP ()"
.br
.ti -1c
.RI "void \fB_M_do_left_shift\fP (size_t __shift)"
.br
.ti -1c
.RI "void \fB_M_do_or\fP (const \fB__dynamic_bitset_base\fP &__x)"
.br
.ti -1c
.RI "void \fB_M_do_reset\fP ()"
.br
.ti -1c
.RI "void \fB_M_do_right_shift\fP (size_t __shift)"
.br
.ti -1c
.RI "void \fB_M_do_set\fP ()"
.br
.ti -1c
.RI "unsigned long long \fB_M_do_to_ullong\fP () const "
.br
.ti -1c
.RI "unsigned long \fB_M_do_to_ulong\fP () const "
.br
.ti -1c
.RI "void \fB_M_do_xor\fP (const \fB__dynamic_bitset_base\fP &__x)"
.br
.ti -1c
.RI "allocator_type \fB_M_get_allocator\fP () const "
.br
.ti -1c
.RI "block_type & \fB_M_getword\fP (size_type __pos)"
.br
.ti -1c
.RI "block_type \fB_M_getword\fP (size_type __pos) const "
.br
.ti -1c
.RI "block_type & \fB_M_hiword\fP ()"
.br
.ti -1c
.RI "block_type \fB_M_hiword\fP () const "
.br
.ti -1c
.RI "bool \fB_M_is_any\fP () const "
.br
.ti -1c
.RI "bool \fB_M_is_equal\fP (const \fB__dynamic_bitset_base\fP &__x) const "
.br
.ti -1c
.RI "bool \fB_M_is_less\fP (const \fB__dynamic_bitset_base\fP &__x) const "
.br
.ti -1c
.RI "bool \fB_M_is_proper_subset_of\fP (const \fB__dynamic_bitset_base\fP &__b) const "
.br
.ti -1c
.RI "bool \fB_M_is_subset_of\fP (const \fB__dynamic_bitset_base\fP &__b)"
.br
.ti -1c
.RI "void \fB_M_resize\fP (size_t __nbits, bool __value)"
.br
.ti -1c
.RI "size_type \fB_M_size\fP () const noexcept"
.br
.ti -1c
.RI "void \fB_M_swap\fP (\fB__dynamic_bitset_base\fP &__b)"
.br
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static block_type \fB_S_maskbit\fP (size_type __pos) noexcept"
.br
.ti -1c
.RI "static size_type \fB_S_whichbit\fP (size_type __pos) noexcept"
.br
.ti -1c
.RI "static size_type \fB_S_whichbyte\fP (size_type __pos) noexcept"
.br
.ti -1c
.RI "static size_type \fB_S_whichword\fP (size_type __pos) noexcept"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBstd::vector\fP< block_type, 
.br
allocator_type > \fB_M_w\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static const size_type \fB_S_bits_per_block\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBreference\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>>class std::tr2::dynamic_bitset< _WordT, _Alloc >"
Da dynamic_bitset class represents a sequence of bits\&. 

(Note dat dynamic_bitset do \fInot\fP hook up tha formal requirementz of a \fCcontainer\fP\&. Mainly, it lacks iterators\&.)
.PP
Da template argument, \fINb\fP, may be any non-negatizzle number, specifyin tha number of bits (e\&.g\&., '0', '12', '1024*1024')\&.
.PP
In tha general unoptimized case, storage be allocated up in word-sized blocks\&. Let B be tha number of bits up in a word, then (Nb+(B-1))/B lyrics is ghon be used fo' storage\&. B - NbB bits is unused\&. (They is tha high-order bits up in tha highest word\&.) It be a cold-ass lil class invariant dat dem unused bits is always zero\&.
.PP
If you be thinkin of dynamic_bitset as 'a simple array of bits,' be aware dat yo' menstrual picture is reversed: a thugged-out dynamic_bitset behaves tha same ol' dirty way as bits up in integers do, wit tha bit at index 0 up in tha 'least dope / right-hand' position, n' tha bit at index Nb-1 up in tha 'most dope / left-hand' position\&. Thus, unlike other containers, a thugged-out dynamic_bitsetz index 'counts from right ta left,' ta put it straight-up loosely\&.
.PP
This behavior is preserved when translatin ta n' from strings\&. For example, tha straight-up original gangsta line of tha followin program probably prints 'b('a') is 0001100001' on a modern ASCII system\&.
.PP
.PP
.nf
#include <dynamic_bitset>
#include <iostream>
#include <sstream>

usin namespace std;

int main()
{
    long         a = 'a';
    dynamic_bitset   b(a);

    cout << "b('a') is " << b << endl;

    ostringstream s;
    s << b;
    strang  str = s\&.str();
    cout << "index 3 up in tha strang is " << str[3] << " but\n"
         << "index 3 up in tha bitset is " << b[3] << endl;
}
.fi
.PP
.PP
Also see: http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt12ch33s02.html fo' a thugged-out description of extensions\&.
.PP
Most of tha actual code aint contained up in dynamic_bitset<> itself yo, but up in tha base class __dynamic_bitset_base\&. Da base class works wit whole lyrics, not wit individual bits\&. This allows our asses ta specialize __dynamic_bitset_base fo' tha blingin special case where tha dynamic_bitset is only a single word\&.
.PP
Extra mad drama can result cuz of tha fact dat tha storage fo' __dynamic_bitset_base \fIis\fP a vector, n' is indexed as such\&. This is carefully encapsulated\&. 
.PP
Definizzle at line 569 of file dynamic_bitset\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::\fBdynamic_bitset\fP (const allocator_type &__alloc = \fCallocator_type()\fP)\fC [inline]\fP, \fC [explicit]\fP"

.PP
All bits set ta zero\&. 
.PP
Definizzle at line 721 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::\fBdynamic_bitset\fP (size_type__nbits, unsigned long long__val = \fC0ULL\fP, const allocator_type &__alloc = \fCallocator_type()\fP)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Initial bits bitwise-copied from a single word (others set ta zero)\&. 
.PP
Definizzle at line 727 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> template<typename _CharT , typename _Traits , typename _Alloc1 > \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::\fBdynamic_bitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc1 > &__str, typename \fBbasic_string\fP< _CharT, _Traits, _Alloc1 >::size_type__pos = \fC0\fP, typename \fBbasic_string\fP< _CharT, _Traits, _Alloc1 >::size_type__n = \fC\fBstd::basic_string\fP<_CharT, _Traits, _Alloc1>::npos\fP, _CharT__zero = \fC_CharT('0')\fP, _CharT__one = \fC_CharT('1')\fP, const allocator_type &__alloc = \fCallocator_type()\fP)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Use a subset of a string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP A strang of '0' n' '1' characters\&. 
.br
\fI__pos\fP Index of tha straight-up original gangsta characta up in \fC__str\fP ta use\&. 
.br
\fI__n\fP Da number of charactas ta copy\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fC__pos\fP is bigger tha size of \fC__str\fP\&. 
.br
\fIstd::invalid_argument\fP If a cold-ass lil characta appears up in tha strang which is neither '0' nor '1'\&. 
.RE
.PP

.PP
Definizzle at line 749 of file dynamic_bitset\&.
.PP
References std::tr2::dynamic_bitset< _WordT, _Alloc >::resize(), n' std::basic_string< _CharT, _Traits, _Alloc >::size()\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::\fBdynamic_bitset\fP (const char *__str, const allocator_type &__alloc = \fCallocator_type()\fP)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Construct from a string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP A strang of '0' n' '1' characters\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::invalid_argument\fP If a cold-ass lil characta appears up in tha strang which is neither '0' nor '1'\&. 
.RE
.PP

.PP
Definizzle at line 777 of file dynamic_bitset\&.
.PP
References std::tr2::dynamic_bitset< _WordT, _Alloc >::resize()\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::\fBdynamic_bitset\fP (const \fBdynamic_bitset\fP< _WordT, _Alloc > &__b)\fC [inline]\fP"

.PP
Copy constructor\&. 
.PP
Definizzle at line 793 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::\fBdynamic_bitset\fP (\fBdynamic_bitset\fP< _WordT, _Alloc > &&__b)\fC [inline]\fP"

.PP
Move constructor\&. 
.PP
Definizzle at line 800 of file dynamic_bitset\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> bool \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::all () const\fC [inline]\fP"

.PP
Tests whether all tha bits is on\&. 
.PP
\fBReturns:\fP
.RS 4
True if all tha bits is set\&. 
.RE
.PP

.PP
Definizzle at line 1187 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> bool \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::any () const\fC [inline]\fP"

.PP
Tests whether any of tha bits is on\&. 
.PP
\fBReturns:\fP
.RS 4
True if at least one bit is set\&. 
.RE
.PP

.PP
Definizzle at line 1195 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> void \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::append (block_type__block)\fC [inline]\fP"

.PP
Append a funky-ass block\&. 
.PP
Definizzle at line 881 of file dynamic_bitset\&.
.PP
Referenced by std::tr2::dynamic_bitset< _WordT, _Alloc >::append()\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> template<typename _BlockInputIterator > void \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::append (_BlockInputIterator__first, _BlockInputIterator__last)\fC [inline]\fP"

.PP
Append a iterator range of blocks\&. 
.PP
Definizzle at line 899 of file dynamic_bitset\&.
.PP
References std::tr2::dynamic_bitset< _WordT, _Alloc >::append()\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> void \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::clear ()\fC [inline]\fP"

.PP
Clear tha bitset\&. 
.PP
Definizzle at line 859 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> size_type \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::count () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns tha number of bits which is set\&. 
.PP
Definizzle at line 1143 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> bool \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::empty () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns legit if tha dynamic_bitset is empty\&. 
.PP
Definizzle at line 1158 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> size_type \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::find_first () const\fC [inline]\fP"

.PP
Findz tha index of tha straight-up original gangsta 'on' bit\&. 
.PP
\fBReturns:\fP
.RS 4
Da index of tha straight-up original gangsta bit set, or size() if not found\&. 
.RE
.PP
\fBSee Also:\fP
.RS 4
find_next 
.RE
.PP

.PP
Definizzle at line 1223 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> size_type \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::find_next (size_t__prev) const\fC [inline]\fP"

.PP
Findz tha index of tha next 'on' bit afta prev\&. 
.PP
\fBReturns:\fP
.RS 4
Da index of tha next bit set, or size() if not found\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fI__prev\fP Where ta start searching\&. 
.RE
.PP
\fBSee Also:\fP
.RS 4
find_first 
.RE
.PP

.PP
Definizzle at line 1233 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc>& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::flip ()\fC [inline]\fP"

.PP
Togglez every last muthafuckin bit ta its opposite value\&. 
.PP
Definizzle at line 1038 of file dynamic_bitset\&.
.PP
Referenced by std::tr2::dynamic_bitset< _WordT, _Alloc >::operator~()\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc>& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::flip (size_type__pos)\fC [inline]\fP"

.PP
Togglez a given bit ta its opposite value\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos\fP Da index of tha bit\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fI__pos\fP is bigger tha size of tha set\&. 
.RE
.PP

.PP
Definizzle at line 1051 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> allocator_type \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::get_allocator () const\fC [inline]\fP"

.PP
Return tha allocator fo' tha bitset\&. 
.PP
Definizzle at line 841 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> constexpr size_type \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::max_size ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns tha maximum size of a thugged-out dynamic_bitset object havin tha same type as *this\&. Da real answer is max() * bits_per_block but is likely ta overflow\&. 
.PP
Definizzle at line 1165 of file dynamic_bitset\&.
.PP
References std::numeric_limits< _Tp >::max()\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> bool \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::none () const\fC [inline]\fP"

.PP
Tests whether any of tha bits is on\&. 
.PP
\fBReturns:\fP
.RS 4
True if none of tha bits is set\&. 
.RE
.PP

.PP
Definizzle at line 1203 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> size_type \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::num_blocks () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns tha total number of blocks\&. 
.PP
Definizzle at line 1153 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc>& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator&= (const \fBdynamic_bitset\fP< _WordT, _Alloc > &__rhs)\fC [inline]\fP"

.PP
Operations on dynamic_bitsets\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__rhs\fP A same-sized dynamic_bitset\&.
.RE
.PP
These should be self-explanatory\&. 
.PP
Definizzle at line 914 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc>& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator&= (\fBdynamic_bitset\fP< _WordT, _Alloc > &&__rhs)\fC [inline]\fP"

.PP
Operations on dynamic_bitsets\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__rhs\fP A same-sized dynamic_bitset\&.
.RE
.PP
These should be self-explanatory\&. 
.PP
Definizzle at line 921 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc>& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator-= (const \fBdynamic_bitset\fP< _WordT, _Alloc > &__rhs)\fC [inline]\fP"

.PP
Operations on dynamic_bitsets\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__rhs\fP A same-sized dynamic_bitset\&.
.RE
.PP
These should be self-explanatory\&. 
.PP
Definizzle at line 942 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc> \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator<< (size_type__pos) const\fC [inline]\fP"

.PP
Self-explanatory\&. 
.PP
Definizzle at line 1209 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc>& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator<<= (size_type__pos)\fC [inline]\fP"

.PP
Operations on dynamic_bitsets\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos\fP Da number of places ta shift\&.
.RE
.PP
These should be self-explanatory\&. 
.PP
Definizzle at line 957 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator= (const \fBdynamic_bitset\fP< _WordT, _Alloc > &__b)\fC [inline]\fP"

.PP
Assignment\&. 
.PP
Definizzle at line 818 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator= (\fBdynamic_bitset\fP< _WordT, _Alloc > &&__b)\fC [inline]\fP"

.PP
Move assignment\&. 
.PP
Definizzle at line 831 of file dynamic_bitset\&.
.PP
References std::tr2::dynamic_bitset< _WordT, _Alloc >::swap()\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc> \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator>> (size_type__pos) const\fC [inline]\fP"

.PP
Self-explanatory\&. 
.PP
Definizzle at line 1213 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc>& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator>>= (size_type__pos)\fC [inline]\fP"

.PP
Operations on dynamic_bitsets\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos\fP Da number of places ta shift\&.
.RE
.PP
These should be self-explanatory\&. 
.PP
Definizzle at line 970 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBreference\fP \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator[] (size_type__pos)\fC [inline]\fP"

.PP
Array-indexin support\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos\fP Index tha fuck into tha dynamic_bitset\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A bool fo' a 'const dynamic_bitset'\&. For non-const bitsets, a instizzle of tha reference proxy class\&. 
.RE
.PP
\fBNote:\fP
.RS 4
These operators do no range checkin n' throw no exceptions, as required by DR 11 ta tha standard\&. 
.RE
.PP

.PP
Definizzle at line 1073 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> const_reference \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator[] (size_type__pos) const\fC [inline]\fP"

.PP
Array-indexin support\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos\fP Index tha fuck into tha dynamic_bitset\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A bool fo' a 'const dynamic_bitset'\&. For non-const bitsets, a instizzle of tha reference proxy class\&. 
.RE
.PP
\fBNote:\fP
.RS 4
These operators do no range checkin n' throw no exceptions, as required by DR 11 ta tha standard\&. 
.RE
.PP

.PP
Definizzle at line 1077 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc>& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator^= (const \fBdynamic_bitset\fP< _WordT, _Alloc > &__rhs)\fC [inline]\fP"

.PP
Operations on dynamic_bitsets\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__rhs\fP A same-sized dynamic_bitset\&.
.RE
.PP
These should be self-explanatory\&. 
.PP
Definizzle at line 935 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc>& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator|= (const \fBdynamic_bitset\fP< _WordT, _Alloc > &__rhs)\fC [inline]\fP"

.PP
Operations on dynamic_bitsets\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__rhs\fP A same-sized dynamic_bitset\&.
.RE
.PP
These should be self-explanatory\&. 
.PP
Definizzle at line 928 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc> \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::operator~ () const\fC [inline]\fP"

.PP
See tha no-argument flip()\&. 
.PP
Definizzle at line 1060 of file dynamic_bitset\&.
.PP
References std::tr2::dynamic_bitset< _WordT, _Alloc >::flip()\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> void \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::push_back (bool__bit)\fC [inline]\fP"

.PP
Push a lil' bit onto tha high end of tha bitset\&. 
.PP
Definizzle at line 869 of file dynamic_bitset\&.
.PP
References std::tr2::dynamic_bitset< _WordT, _Alloc >::size()\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc>& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::reset ()\fC [inline]\fP"

.PP
Sets every last muthafuckin bit ta false\&. 
.PP
Definizzle at line 1013 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc>& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::reset (size_type__pos)\fC [inline]\fP"

.PP
Sets a given bit ta false\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos\fP Da index of tha bit\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fI__pos\fP is bigger tha size of tha set\&.
.RE
.PP
Same as freestylin \fCset(__pos, false)\fP\&. 
.PP
Definizzle at line 1027 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> void \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::resize (size_type__nbits, bool__value = \fCfalse\fP)\fC [inline]\fP"

.PP
Resize tha bitset\&. 
.PP
Definizzle at line 848 of file dynamic_bitset\&.
.PP
Referenced by std::tr2::dynamic_bitset< _WordT, _Alloc >::dynamic_bitset(), n' std::tr2::operator>>()\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc>& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::\fBset\fP ()\fC [inline]\fP"

.PP
Sets every last muthafuckin bit ta true\&. 
.PP
Definizzle at line 988 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> \fBdynamic_bitset\fP<_WordT, _Alloc>& \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::\fBset\fP (size_type__pos, bool__val = \fCtrue\fP)\fC [inline]\fP"

.PP
Sets a given bit ta a particular value\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos\fP Da index of tha bit\&. 
.br
\fI__val\fP Either legit or false, defaults ta true\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fI__pos\fP is bigger tha size of tha set\&. 
.RE
.PP

.PP
Definizzle at line 1002 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> size_type \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::size () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns tha total number of bits\&. 
.PP
Definizzle at line 1148 of file dynamic_bitset\&.
.PP
Referenced by std::tr2::operator>>(), n' std::tr2::dynamic_bitset< _WordT, _Alloc >::push_back()\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> void \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::swap (\fBdynamic_bitset\fP< _WordT, _Alloc > &__b)\fC [inline]\fP"

.PP
Swap wit another bitset\&. 
.PP
Definizzle at line 808 of file dynamic_bitset\&.
.PP
Referenced by std::tr2::dynamic_bitset< _WordT, _Alloc >::operator=()\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> bool \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::test (size_type__pos) const\fC [inline]\fP"

.PP
Tests tha value of a funky-ass bit\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos\fP Da index of a funky-ass bit\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da value at \fI__pos\fP\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fI__pos\fP is bigger tha size of tha set\&. 
.RE
.PP

.PP
Definizzle at line 1175 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> template<typename _CharT  = char, typename _Traits  = std::char_traits<_CharT>, typename _Alloc1  = std::allocator<_CharT>> \fBstd::basic_string\fP<_CharT, _Traits, _Alloc1> \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::to_strin (_CharT__zero = \fC_CharT('0')\fP, _CharT__one = \fC_CharT('1')\fP) const\fC [inline]\fP"

.PP
Returns a cold-ass lil characta interpretation of tha dynamic_bitset\&. 
.PP
\fBReturns:\fP
.RS 4
Da strang equivalent of tha bits\&.
.RE
.PP
Note tha orderin of tha bits: decreasin characta positions correspond ta increasin bit positions (see tha main class notes fo' a example)\&. 
.PP
Definizzle at line 1113 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> unsigned long long \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::to_ullong () const\fC [inline]\fP"

.PP
Returns a numerical interpretation of tha dynamic_bitset\&. 
.PP
\fBReturns:\fP
.RS 4
Da integral equivalent of tha bits\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::overflow_error\fP If there be too nuff bits ta be represented up in a \fCunsigned\fP \fClong\fP\&. 
.RE
.PP

.PP
Definizzle at line 1098 of file dynamic_bitset\&.
.SS "template<typename _WordT = unsigned long long, typename _Alloc = std::allocator<_WordT>> unsigned long \fBstd::tr2::dynamic_bitset\fP< _WordT, _Alloc >::to_ulong () const\fC [inline]\fP"

.PP
Returns a numerical interpretation of tha dynamic_bitset\&. 
.PP
\fBReturns:\fP
.RS 4
Da integral equivalent of tha bits\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::overflow_error\fP If there be too nuff bits ta be represented up in a \fCunsigned\fP \fClong\fP\&. 
.RE
.PP

.PP
Definizzle at line 1088 of file dynamic_bitset\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
