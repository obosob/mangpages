.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Gnu 3"
.TH Gnu 3 "2013-08-04" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ReadLine::Gnu \- Perl extension fo' tha GNU Readline/History Library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use Term::ReadLine;
\&  $term = freshly smoked up Term::ReadLine \*(AqProgramName\*(Aq;
\&  while ( defined ($_ = $term\->readline(\*(Aqprompt>\*(Aq)) ) {
\&    ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Overview"
.IX Subsection "Overview"
This be a implementation of Term::ReadLine rockin tha \s-1GNU\s0
Readline/History Library.
.PP
For basic functions object oriented intercourse is provided. Y'all KNOW dat shit, muthafucka! These are
busted lyrics bout up in tha section \*(L"Standard Methods\*(R" and
"\f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR Functions".
.PP
This package also has tha intercourse wit tha almost all functions and
variablez which is documented up in tha \s-1GNU\s0 Readline/History Library
Manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  They is documented up in tha section
"\f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR Functions"
and
"\f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR Variables"
briefly.  For mo' detail of tha \s-1GNU\s0 Readline/History Library, see
\&'\s-1GNU\s0 Readline Library Manual' n' '\s-1GNU\s0 History Library Manual'.
.PP
Da sample programs under \f(CW\*(C`eg/\*(C'\fR directory n' test programs under
\&\f(CW\*(C`t/\*(C'\fR directory up in tha \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR distribution include
many example of dis module.
.SS "Standard Methods"
.IX Subsection "Standard Methods"
These methodz is standard methodz defined by \fBTerm::ReadLine\fR.
.ie n .IP """ReadLine""" 4
.el .IP "\f(CWReadLine\fR" 4
.IX Item "ReadLine"
returns tha actual package dat executes tha commands. If you have
installed dis package,  possible value is \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR.
.ie n .IP """new(NAME,[IN[,OUT]])""" 4
.el .IP "\f(CWnew(NAME,[IN[,OUT]])\fR" 4
.IX Item "new(NAME,[IN[,OUT]])"
returns tha handle fo' subsequent calls ta followin functions.
Argument is tha name of tha application. I aint talkin' bout chicken n' gravy biatch.  Optionally can be followed
by two arguments fo' \f(CW\*(C`IN\*(C'\fR n' \f(CW\*(C`OUT\*(C'\fR file handles. These arguments
should be globs.
.ie n .IP """readline(PROMPT[,PREPUT])""" 4
.el .IP "\f(CWreadline(PROMPT[,PREPUT])\fR" 4
.IX Item "readline(PROMPT[,PREPUT])"
gets a input line, wit actual \f(CW\*(C`GNU Readline\*(C'\fR support.  Trailing
newline is removed. Y'all KNOW dat shit, muthafucka!  Returns \f(CW\*(C`undef\*(C'\fR on \f(CW\*(C`EOF\*(C'\fR.  \f(CW\*(C`PREPUT\*(C'\fR be an
optionizzle argument meanin tha initial value of input.
.Sp
Da optionizzle argument \f(CW\*(C`PREPUT\*(C'\fR is granted only if tha value \f(CW\*(C`preput\*(C'\fR
is up in \f(CW\*(C`Features\*(C'\fR.
.Sp
\&\f(CW\*(C`PROMPT\*(C'\fR may include some escape sequences.  Use
\&\f(CW\*(C`RL_PROMPT_START_IGNORE\*(C'\fR ta begin a sequence of non-printing
characters, n' \f(CW\*(C`RL_PROMPT_END_IGNORE\*(C'\fR ta end of such a sequence.
.ie n .IP """AddHistory(LINE1, LINE2, ...)""" 4
.el .IP "\f(CWAddHistory(LINE1, LINE2, ...)\fR" 4
.IX Item "AddHistory(LINE1, LINE2, ...)"
addz tha lines ta tha history of input, from where it can be used if
the actual \f(CW\*(C`readline\*(C'\fR is present.
.ie n .IP """IN"", ""OUT""" 4
.el .IP "\f(CWIN\fR, \f(CWOUT\fR" 4
.IX Item "IN, OUT"
return tha file handlez fo' input n' output or \f(CW\*(C`undef\*(C'\fR if
\&\f(CW\*(C`readline\*(C'\fR input n' output cannot be used fo' Perl.
.ie n .IP """MinLine([MAX])""" 4
.el .IP "\f(CWMinLine([MAX])\fR" 4
.IX Item "MinLine([MAX])"
If argument \f(CW\*(C`MAX\*(C'\fR is specified, it be a lyrics on minimal size of
line ta be included tha fuck into history.  \f(CW\*(C`undef\*(C'\fR means do not include
anythang tha fuck into history.  Returns tha oldschool value.
.ie n .IP """findConsole""" 4
.el .IP "\f(CWfindConsole\fR" 4
.IX Item "findConsole"
returns a array wit two strings dat give most appropriate names for
filez fo' input n' output rockin conventions \f(CW"<$in"\fR, \f(CW">$out"\fR.
.ie n .IP """Attribs""" 4
.el .IP "\f(CWAttribs\fR" 4
.IX Item "Attribs"
returns a reference ta a hash which raps bout internal configuration
(variables) of tha package.  Namez of keys up in dis hash conform to
standard conventions wit tha leadin \f(CW\*(C`rl_\*(C'\fR stripped.
.Sp
See section \*(L"Variables\*(R" fo' supported variables.
.ie n .IP """Features""" 4
.el .IP "\f(CWFeatures\fR" 4
.IX Item "Features"
Returns a reference ta a hash wit keys bein features present in
current implementation. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Several optionizzle features is used up in the
minimal intercourse: \f(CW\*(C`appname\*(C'\fR should be present if tha straight-up original gangsta argument
to \f(CW\*(C`new\*(C'\fR is recognized, n' \f(CW\*(C`minline\*(C'\fR should be present if
\&\f(CW\*(C`MinLine\*(C'\fR method aint dummy.  \f(CW\*(C`autohistory\*(C'\fR should be present if
lines is put tha fuck into history automatically (maybe subject to
\&\f(CW\*(C`MinLine\*(C'\fR), n' \f(CW\*(C`addHistory\*(C'\fR if \f(CW\*(C`AddHistory\*(C'\fR method aint dummy. 
\&\f(CW\*(C`preput\*(C'\fR means tha second argument ta \f(CW\*(C`readline\*(C'\fR method is processed.
\&\f(CW\*(C`getHistory\*(C'\fR n' \f(CW\*(C`setHistory\*(C'\fR denote dat tha correspondin methodz is 
present. \f(CW\*(C`tkRunning\*(C'\fR denotes dat a Tk application may run while ReadLine
is gettin input.
.ie n .SS """Term::ReadLine::Gnu"" Functions"
.el .SS "\f(CWTerm::ReadLine::Gnu\fP Functions"
.IX Subsection "Term::ReadLine::Gnu Functions"
All these \s-1GNU\s0 Readline/History Library functions is callable via
method intercourse n' have names which conform ta standard conventions
with tha leadin \f(CW\*(C`rl_\*(C'\fR stripped.
.PP
Almost methodz have lower level functions in
\&\f(CW\*(C`Term::ReadLine::Gnu::XS\*(C'\fR package.  To use dem full qualified name
is required. Y'all KNOW dat shit, muthafucka!  Usin method intercourse is preferred.
.IP "Readline Convenience Functions" 4
.IX Item "Readline Convenience Functions"
.RS 4
.PD 0
.IP "Namin Function" 4
.IX Item "Namin Function"
.RS 4
.ie n .IP """add_defun(NAME, FUNC [,KEY=\-1])""" 4
.el .IP "\f(CWadd_defun(NAME, FUNC [,KEY=\-1])\fR" 4
.IX Item "add_defun(NAME, FUNC [,KEY=-1])"
.PD
Add name ta tha Perl function \f(CW\*(C`FUNC\*(C'\fR.  If optionizzle argument \f(CW\*(C`KEY\*(C'\fR is
specified, bind it ta tha \f(CW\*(C`FUNC\*(C'\fR.  Returns reference to
\&\f(CW\*(C`FunctionPtr\*(C'\fR.
.Sp
.Vb 4
\&  Example:
\&        # name name \`reverse\-line\*(Aq ta a gangbangin' function reverse_line(),
\&        # n' bind it ta "\eC\-t"
\&        $term\->add_defun(\*(Aqreverse\-line\*(Aq, \e&reverse_line, ord "\ect");
.Ve
.RE
.RS 4
.RE
.IP "Selectin a Keymap" 4
.IX Item "Selectin a Keymap"
.RS 4
.PD 0
.ie n .IP """make_bare_keymap""" 4
.el .IP "\f(CWmake_bare_keymap\fR" 4
.IX Item "make_bare_keymap"
.PD
.Vb 1
\&        Keymap  rl_make_bare_keymap()
.Ve
.ie n .IP """copy_keymap(MAP)""" 4
.el .IP "\f(CWcopy_keymap(MAP)\fR" 4
.IX Item "copy_keymap(MAP)"
.Vb 1
\&        Keymap  rl_copy_keymap(Keymap|str map)
.Ve
.ie n .IP """make_keymap""" 4
.el .IP "\f(CWmake_keymap\fR" 4
.IX Item "make_keymap"
.Vb 1
\&        Keymap  rl_make_keymap()
.Ve
.ie n .IP """discard_keymap(MAP)""" 4
.el .IP "\f(CWdiscard_keymap(MAP)\fR" 4
.IX Item "discard_keymap(MAP)"
.Vb 1
\&        Keymap  rl_discard_keymap(Keymap|str map)
.Ve
.ie n .IP """free_keymap(MAP)""" 4
.el .IP "\f(CWfree_keymap(MAP)\fR" 4
.IX Item "free_keymap(MAP)"
.Vb 1
\&        void    rl_free_keymap(Keymap|str map)
.Ve
.ie n .IP """get_keymap""" 4
.el .IP "\f(CWget_keymap\fR" 4
.IX Item "get_keymap"
.Vb 1
\&        Keymap  rl_get_keymap()
.Ve
.ie n .IP """set_keymap(MAP)""" 4
.el .IP "\f(CWset_keymap(MAP)\fR" 4
.IX Item "set_keymap(MAP)"
.Vb 1
\&        Keymap  rl_set_keymap(Keymap|str map)
.Ve
.ie n .IP """get_keymap_by_name(NAME)""" 4
.el .IP "\f(CWget_keymap_by_name(NAME)\fR" 4
.IX Item "get_keymap_by_name(NAME)"
.Vb 1
\&        Keymap  rl_get_keymap_by_name(str name)
.Ve
.ie n .IP """get_keymap_name(MAP)""" 4
.el .IP "\f(CWget_keymap_name(MAP)\fR" 4
.IX Item "get_keymap_name(MAP)"
.Vb 1
\&        str     rl_get_keymap_name(Keymap map)
.Ve
.RE
.RS 4
.RE
.IP "Bindin Keys" 4
.IX Item "Bindin Keys"
.RS 4
.PD 0
.ie n .IP """bind_key(KEY, FUNCTION [,MAP])""" 4
.el .IP "\f(CWbind_key(KEY, FUNCTION [,MAP])\fR" 4
.IX Item "bind_key(KEY, FUNCTION [,MAP])"
.PD
.Vb 2
\&        int     rl_bind_key(int key, FunctionPtr|str function,
\&                            Keymap|str map = rl_get_keymap())
.Ve
.Sp
Bind \f(CW\*(C`KEY\*(C'\fR ta tha \f(CW\*(C`FUNCTION\*(C'\fR.  \f(CW\*(C`FUNCTION\*(C'\fR is tha name added by the
\&\f(CW\*(C`add_defun\*(C'\fR method. Y'all KNOW dat shit, muthafucka!  If optionizzle argument \f(CW\*(C`MAP\*(C'\fR is specified, binds
in \f(CW\*(C`MAP\*(C'\fR.  Returns non-zero up in case of error.
.ie n .IP """bind_key_if_unbound(KEY, FUNCTION [,MAP])""" 4
.el .IP "\f(CWbind_key_if_unbound(KEY, FUNCTION [,MAP])\fR" 4
.IX Item "bind_key_if_unbound(KEY, FUNCTION [,MAP])"
.Vb 2
\&        int     rl_bind_key_if_unbound(int key, FunctionPtr|str function,
\&                                       Keymap|str map = rl_get_keymap()) #GRL5.0
.Ve
.ie n .IP """unbind_key(KEY [,MAP])""" 4
.el .IP "\f(CWunbind_key(KEY [,MAP])\fR" 4
.IX Item "unbind_key(KEY [,MAP])"
.Vb 1
\&        int     rl_unbind_key(int key, Keymap|str map = rl_get_keymap())
.Ve
.Sp
Bind \f(CW\*(C`KEY\*(C'\fR ta tha null function. I aint talkin' bout chicken n' gravy biatch.  Returns non-zero up in case of error.
.ie n .IP """unbind_function(FUNCTION [,MAP])""" 4
.el .IP "\f(CWunbind_function(FUNCTION [,MAP])\fR" 4
.IX Item "unbind_function(FUNCTION [,MAP])"
.Vb 2
\&        int     rl_unbind_function(FunctionPtr|str function,
\&                                   Keymap|str map = rl_get_keymap())
.Ve
.ie n .IP """unbind_command(COMMAND [,MAP])""" 4
.el .IP "\f(CWunbind_command(COMMAND [,MAP])\fR" 4
.IX Item "unbind_command(COMMAND [,MAP])"
.Vb 2
\&        int     rl_unbind_command(str command,
\&                                  Keymap|str map = rl_get_keymap())
.Ve
.ie n .IP """bind_keyseq(KEYSEQ, FUNCTION [,MAP])""" 4
.el .IP "\f(CWbind_keyseq(KEYSEQ, FUNCTION [,MAP])\fR" 4
.IX Item "bind_keyseq(KEYSEQ, FUNCTION [,MAP])"
.Vb 2
\&        int     rl_bind_keyseq(str keyseq, FunctionPtr|str function,
\&                               Keymap|str map = rl_get_keymap()) # GRL 5.0
.Ve
.ie n .IP """set_key(KEYSEQ, FUNCTION [,MAP])""" 4
.el .IP "\f(CWset_key(KEYSEQ, FUNCTION [,MAP])\fR" 4
.IX Item "set_key(KEYSEQ, FUNCTION [,MAP])"
.Vb 2
\&        int     rl_set_key(str keyseq, FunctionPtr|str function,
\&                           Keymap|str map = rl_get_keymap())
.Ve
.ie n .IP """bind_keyseq_if_unbound(KEYSEQ, FUNCTION [,MAP])""" 4
.el .IP "\f(CWbind_keyseq_if_unbound(KEYSEQ, FUNCTION [,MAP])\fR" 4
.IX Item "bind_keyseq_if_unbound(KEYSEQ, FUNCTION [,MAP])"
.Vb 2
\&        int     rl_bind_keyseq_if_unbound(str keyseq, FunctionPtr|str function,
\&                                          Keymap|str map = rl_get_keymap()) # GRL 5.0
.Ve
.ie n .IP """generic_bind(TYPE, KEYSEQ, DATA, [,MAP])""" 4
.el .IP "\f(CWgeneric_bind(TYPE, KEYSEQ, DATA, [,MAP])\fR" 4
.IX Item "generic_bind(TYPE, KEYSEQ, DATA, [,MAP])"
.Vb 3
\&        int     rl_generic_bind(int type, str keyseq,
\&                                FunctionPtr|Keymap|str data,
\&                                Keymap|str map = rl_get_keymap())
.Ve
.ie n .IP """parse_and_bind(LINE)""" 4
.el .IP "\f(CWparse_and_bind(LINE)\fR" 4
.IX Item "parse_and_bind(LINE)"
.Vb 1
\&        void    rl_parse_and_bind(str line)
.Ve
.Sp
Parse \f(CW\*(C`LINE\*(C'\fR as if it had been read from tha \fI~/.inputrc\fR file and
perform any key bindings n' variable assignments found. Y'all KNOW dat shit, muthafucka!  For more
detail peep '\s-1GNU\s0 Readline Library Manual'.
.ie n .IP """read_init_file([FILENAME])""" 4
.el .IP "\f(CWread_init_file([FILENAME])\fR" 4
.IX Item "read_init_file([FILENAME])"
.Vb 1
\&        int     rl_read_init_file(str filename = \*(Aq~/.inputrc\*(Aq)
.Ve
.RE
.RS 4
.RE
.IP "Associatin Function Names n' Bindings" 4
.IX Item "Associatin Function Names n' Bindings"
.RS 4
.PD 0
.ie n .IP """named_function(NAME)""" 4
.el .IP "\f(CWnamed_function(NAME)\fR" 4
.IX Item "named_function(NAME)"
.PD
.Vb 1
\&        FunctionPtr rl_named_function(str name)
.Ve
.ie n .IP """get_function_name(FUNCTION)""" 4
.el .IP "\f(CWget_function_name(FUNCTION)\fR" 4
.IX Item "get_function_name(FUNCTION)"
.Vb 1
\&        str     rl_get_function_name(FunctionPtr function)
.Ve
.ie n .IP """function_of_keyseq(KEYMAP [,MAP])""" 4
.el .IP "\f(CWfunction_of_keyseq(KEYMAP [,MAP])\fR" 4
.IX Item "function_of_keyseq(KEYMAP [,MAP])"
.Vb 3
\&        (FunctionPtr|Keymap|str data, int type)
\&                rl_function_of_keyseq(str keyseq,
\&                                      Keymap|str map = rl_get_keymap())
.Ve
.ie n .IP """invoking_keyseqs(FUNCTION [,MAP])""" 4
.el .IP "\f(CWinvoking_keyseqs(FUNCTION [,MAP])\fR" 4
.IX Item "invoking_keyseqs(FUNCTION [,MAP])"
.Vb 2
\&        (@str)  rl_invoking_keyseqs(FunctionPtr|str function,
\&                                    Keymap|str map = rl_get_keymap())
.Ve
.ie n .IP """function_dumper([READABLE])""" 4
.el .IP "\f(CWfunction_dumper([READABLE])\fR" 4
.IX Item "function_dumper([READABLE])"
.Vb 1
\&        void    rl_function_dumper(int readable = 0)
.Ve
.ie n .IP """list_funmap_names""" 4
.el .IP "\f(CWlist_funmap_names\fR" 4
.IX Item "list_funmap_names"
.Vb 1
\&        void    rl_list_funmap_names()
.Ve
.ie n .IP """funmap_names""" 4
.el .IP "\f(CWfunmap_names\fR" 4
.IX Item "funmap_names"
.Vb 1
\&        (@str)  rl_funmap_names()
.Ve
.ie n .IP """add_funmap_entry(NAME, FUNCTION)""" 4
.el .IP "\f(CWadd_funmap_entry(NAME, FUNCTION)\fR" 4
.IX Item "add_funmap_entry(NAME, FUNCTION)"
.Vb 1
\&        int     rl_add_funmap_entry(char *name, FunctionPtr|str function)
.Ve
.RE
.RS 4
.RE
.IP "Allowin Undoing" 4
.IX Item "Allowin Undoing"
.RS 4
.PD 0
.ie n .IP """begin_undo_group""" 4
.el .IP "\f(CWbegin_undo_group\fR" 4
.IX Item "begin_undo_group"
.PD
.Vb 1
\&        int     rl_begin_undo_group()
.Ve
.ie n .IP """end_undo_group""" 4
.el .IP "\f(CWend_undo_group\fR" 4
.IX Item "end_undo_group"
.Vb 1
\&        int     rl_end_undo_group()
.Ve
.ie n .IP """add_undo(WHAT, START, END, TEXT)""" 4
.el .IP "\f(CWadd_undo(WHAT, START, END, TEXT)\fR" 4
.IX Item "add_undo(WHAT, START, END, TEXT)"
.Vb 1
\&        int     rl_add_undo(int what, int start, int end, str text)
.Ve
.ie n .IP """free_undo_list""" 4
.el .IP "\f(CWfree_undo_list\fR" 4
.IX Item "free_undo_list"
.Vb 1
\&        void    rl_free_undo_list()
.Ve
.ie n .IP """do_undo""" 4
.el .IP "\f(CWdo_undo\fR" 4
.IX Item "do_undo"
.Vb 1
\&        int     rl_do_undo()
.Ve
.ie n .IP """modifying([START [,END]])""" 4
.el .IP "\f(CWmodifying([START [,END]])\fR" 4
.IX Item "modifying([START [,END]])"
.Vb 1
\&        int     rl_modifying(int start = 0, int end = rl_end)
.Ve
.RE
.RS 4
.RE
.IP "Redisplay" 4
.IX Item "Redisplay"
.RS 4
.PD 0
.ie n .IP """redisplay""" 4
.el .IP "\f(CWredisplay\fR" 4
.IX Item "redisplay"
.PD
.Vb 1
\&        void    rl_redisplay()
.Ve
.ie n .IP """forced_update_display""" 4
.el .IP "\f(CWforced_update_display\fR" 4
.IX Item "forced_update_display"
.Vb 1
\&        int     rl_forced_update_display()
.Ve
.ie n .IP """on_new_line""" 4
.el .IP "\f(CWon_new_line\fR" 4
.IX Item "on_new_line"
.Vb 1
\&        int     rl_on_new_line()
.Ve
.ie n .IP """on_new_line_with_prompt""" 4
.el .IP "\f(CWon_new_line_with_prompt\fR" 4
.IX Item "on_new_line_with_prompt"
.Vb 1
\&        int     rl_on_new_line_with_prompt()    # GRL 4.1
.Ve
.ie n .IP """reset_line_state""" 4
.el .IP "\f(CWreset_line_state\fR" 4
.IX Item "reset_line_state"
.Vb 1
\&        int     rl_reset_line_state()
.Ve
.ie n .IP "rl_show_char(C)" 4
.el .IP "\f(CWrl_show_char(C)\fR" 4
.IX Item "rl_show_char(C)"
.Vb 1
\&        int     rl_show_char(int c)
.Ve
.ie n .IP """message(FMT[, ...])""" 4
.el .IP "\f(CWmessage(FMT[, ...])\fR" 4
.IX Item "message(FMT[, ...])"
.Vb 1
\&        int     rl_message(str fmt, ...)
.Ve
.ie n .IP """crlf""" 4
.el .IP "\f(CWcrlf\fR" 4
.IX Item "crlf"
.Vb 1
\&        int     rl_crlf()                       # GRL 4.2
.Ve
.ie n .IP """clear_message""" 4
.el .IP "\f(CWclear_message\fR" 4
.IX Item "clear_message"
.Vb 1
\&        int     rl_clear_message()
.Ve
.ie n .IP """save_prompt""" 4
.el .IP "\f(CWsave_prompt\fR" 4
.IX Item "save_prompt"
.Vb 1
\&        void    rl_save_prompt()
.Ve
.ie n .IP """restore_prompt""" 4
.el .IP "\f(CWrestore_prompt\fR" 4
.IX Item "restore_prompt"
.Vb 1
\&        void    rl_restore_prompt()
.Ve
.ie n .IP """expand_prompt(PROMPT)""" 4
.el .IP "\f(CWexpand_prompt(PROMPT)\fR" 4
.IX Item "expand_prompt(PROMPT)"
.Vb 1
\&        int     rl_expand_prompt(str prompt)    # GRL 4.2
.Ve
.ie n .IP """set_prompt(PROMPT)""" 4
.el .IP "\f(CWset_prompt(PROMPT)\fR" 4
.IX Item "set_prompt(PROMPT)"
.Vb 1
\&        int     rl_set_prompt(const str prompt) # GRL 4.2
.Ve
.RE
.RS 4
.RE
.IP "Modifyin Text" 4
.IX Item "Modifyin Text"
.RS 4
.PD 0
.ie n .IP """insert_text(TEXT)""" 4
.el .IP "\f(CWinsert_text(TEXT)\fR" 4
.IX Item "insert_text(TEXT)"
.PD
.Vb 1
\&        int     rl_insert_text(str text)
.Ve
.ie n .IP """delete_text([START [,END]])""" 4
.el .IP "\f(CWdelete_text([START [,END]])\fR" 4
.IX Item "delete_text([START [,END]])"
.Vb 1
\&        int     rl_delete_text(int start = 0, int end = rl_end)
.Ve
.ie n .IP """copy_text([START [,END]])""" 4
.el .IP "\f(CWcopy_text([START [,END]])\fR" 4
.IX Item "copy_text([START [,END]])"
.Vb 1
\&        str     rl_copy_text(int start = 0, int end = rl_end)
.Ve
.ie n .IP """kill_text([START [,END]])""" 4
.el .IP "\f(CWkill_text([START [,END]])\fR" 4
.IX Item "kill_text([START [,END]])"
.Vb 1
\&        int     rl_kill_text(int start = 0, int end = rl_end)
.Ve
.ie n .IP """push_macro_input(MACRO)""" 4
.el .IP "\f(CWpush_macro_input(MACRO)\fR" 4
.IX Item "push_macro_input(MACRO)"
.Vb 1
\&        int     rl_push_macro_input(str macro)
.Ve
.RE
.RS 4
.RE
.IP "Characta Input" 4
.IX Item "Characta Input"
.RS 4
.PD 0
.ie n .IP """read_key""" 4
.el .IP "\f(CWread_key\fR" 4
.IX Item "read_key"
.PD
.Vb 1
\&        int     rl_read_key()
.Ve
.ie n .IP """getc(STREAM)""" 4
.el .IP "\f(CWgetc(STREAM)\fR" 4
.IX Item "getc(STREAM)"
.Vb 1
\&        int     rl_getc(FILE *STREAM)
.Ve
.ie n .IP "stuff_char(C)" 4
.el .IP "\f(CWstuff_char(C)\fR" 4
.IX Item "stuff_char(C)"
.Vb 1
\&        int     rl_stuff_char(int c)
.Ve
.ie n .IP "execute_next(C)" 4
.el .IP "\f(CWexecute_next(C)\fR" 4
.IX Item "execute_next(C)"
.Vb 1
\&        int     rl_execute_next(int c)          # GRL 4.2
.Ve
.ie n .IP """clear_pending_input()""" 4
.el .IP "\f(CWclear_pending_input()\fR" 4
.IX Item "clear_pending_input()"
.Vb 1
\&        int     rl_clear_pending_input()        # GRL 4.2
.Ve
.ie n .IP """set_keyboard_input_timeout(uSEC)""" 4
.el .IP "\f(CWset_keyboard_input_timeout(uSEC)\fR" 4
.IX Item "set_keyboard_input_timeout(uSEC)"
.Vb 1
\&        int     rl_set_keyboard_input_timeout(int usec) # GRL 4.2
.Ve
.RE
.RS 4
.RE
.IP "Terminal Management" 4
.IX Item "Terminal Management"
.RS 4
.PD 0
.ie n .IP """prep_terminal(META_FLAG)""" 4
.el .IP "\f(CWprep_terminal(META_FLAG)\fR" 4
.IX Item "prep_terminal(META_FLAG)"
.PD
.Vb 1
\&        void    rl_prep_terminal(int META_FLAG) # GRL 4.2
.Ve
.ie n .IP """deprep_terminal()""" 4
.el .IP "\f(CWdeprep_terminal()\fR" 4
.IX Item "deprep_terminal()"
.Vb 1
\&        void    rl_deprep_terminal()            # GRL 4.2
.Ve
.ie n .IP """tty_set_default_bindings(KMAP)""" 4
.el .IP "\f(CWtty_set_default_bindings(KMAP)\fR" 4
.IX Item "tty_set_default_bindings(KMAP)"
.Vb 1
\&        void    rl_tty_set_default_bindings([Keymap KMAP])      # GRL 4.2
.Ve
.ie n .IP """tty_unset_default_bindings(KMAP)""" 4
.el .IP "\f(CWtty_unset_default_bindings(KMAP)\fR" 4
.IX Item "tty_unset_default_bindings(KMAP)"
.Vb 1
\&        void    rl_tty_unset_default_bindings([Keymap KMAP])    # GRL 5.0
.Ve
.ie n .IP """reset_terminal([TERMINAL_NAME])""" 4
.el .IP "\f(CWreset_terminal([TERMINAL_NAME])\fR" 4
.IX Item "reset_terminal([TERMINAL_NAME])"
.Vb 1
\&        int     rl_reset_terminal(str terminal_name = getenv($TERM)) # GRL 4.2
.Ve
.RE
.RS 4
.RE
.IP "Utilitizzle Functions" 4
.IX Item "Utilitizzle Functions"
.RS 4
.PD 0
.ie n .IP """save_state(READLINE_STATE)""" 4
.el .IP "\f(CWsave_state(READLINE_STATE)\fR" 4
.IX Item "save_state(READLINE_STATE)"
.PD
.Vb 2
\&        NOT IMPLEMENTED YET!
\&        int     rl_save_state(struct readline_state *sp)        # GRL 6.0
.Ve
.ie n .IP """restore_state(READLINE_STATE)""" 4
.el .IP "\f(CWrestore_state(READLINE_STATE)\fR" 4
.IX Item "restore_state(READLINE_STATE)"
.Vb 2
\&        NOT IMPLEMENTED YET!
\&        int     rl_restore_state(struct readline_state *sp)     # GRL 6.0
.Ve
.ie n .IP """replace_line(TEXT [,CLEAR_UNDO])""" 4
.el .IP "\f(CWreplace_line(TEXT [,CLEAR_UNDO])\fR" 4
.IX Item "replace_line(TEXT [,CLEAR_UNDO])"
.Vb 1
\&        int     rl_replace_line(str text, int clear_undo)       # GRL 4.3
.Ve
.ie n .IP """initialize""" 4
.el .IP "\f(CWinitialize\fR" 4
.IX Item "initialize"
.Vb 1
\&        int     rl_initialize()
.Ve
.ie n .IP """ding""" 4
.el .IP "\f(CWding\fR" 4
.IX Item "ding"
.Vb 1
\&        int     rl_ding()
.Ve
.ie n .IP "alphabetic(C)" 4
.el .IP "\f(CWalphabetic(C)\fR" 4
.IX Item "alphabetic(C)"
.Vb 1
\&        int     rl_alphabetic(int C)
.Ve
.ie n .IP """display_match_list(MATCHES [,LEN [,MAX]])""" 4
.el .IP "\f(CWdisplay_match_list(MATCHES [,LEN [,MAX]])\fR" 4
.IX Item "display_match_list(MATCHES [,LEN [,MAX]])"
.Vb 1
\&        void    rl_display_match_list(\e@matches, len = $#maches, max) # GRL 4.0
.Ve
.Sp
Since tha straight-up original gangsta element of a array \f(CW@matches\fR as treated as a possible
completion, it aint displayed. Y'all KNOW dat shit, muthafucka!  See tha descriptions of
\&\f(CW\*(C`completion_matches()\*(C'\fR.
.Sp
When \f(CW\*(C`MAX\*(C'\fR is ommited, tha max length of a item up in \f(CW@matches\fR is used.
.RE
.RS 4
.RE
.IP "Miscellaneous Functions" 4
.IX Item "Miscellaneous Functions"
.RS 4
.PD 0
.ie n .IP """macro_bind(KEYSEQ, MACRO [,MAP])""" 4
.el .IP "\f(CWmacro_bind(KEYSEQ, MACRO [,MAP])\fR" 4
.IX Item "macro_bind(KEYSEQ, MACRO [,MAP])"
.PD
.Vb 1
\&        int     rl_macro_bind(const str keyseq, const str macro, Keymap map)
.Ve
.ie n .IP """macro_dumper(READABLE)""" 4
.el .IP "\f(CWmacro_dumper(READABLE)\fR" 4
.IX Item "macro_dumper(READABLE)"
.Vb 1
\&        int     rl_macro_dumper(int readline)
.Ve
.ie n .IP """variable_bind(VARIABLE, VALUE)""" 4
.el .IP "\f(CWvariable_bind(VARIABLE, VALUE)\fR" 4
.IX Item "variable_bind(VARIABLE, VALUE)"
.Vb 1
\&        int     rl_variable_bind(const str variable, const str value)
.Ve
.ie n .IP """variable_value(VARIABLE)""" 4
.el .IP "\f(CWvariable_value(VARIABLE)\fR" 4
.IX Item "variable_value(VARIABLE)"
.Vb 1
\&        str     rl_variable_value(const str variable)   # GRL 5.1
.Ve
.ie n .IP """variable_dumper(READABLE)""" 4
.el .IP "\f(CWvariable_dumper(READABLE)\fR" 4
.IX Item "variable_dumper(READABLE)"
.Vb 1
\&        int     rl_variable_dumper(int readline)
.Ve
.ie n .IP """set_paren_blink_timeout(uSEC)""" 4
.el .IP "\f(CWset_paren_blink_timeout(uSEC)\fR" 4
.IX Item "set_paren_blink_timeout(uSEC)"
.Vb 1
\&        int     rl_set_paren_blink_timeout(usec)        # GRL 4.2
.Ve
.ie n .IP """get_termcap(cap)""" 4
.el .IP "\f(CWget_termcap(cap)\fR" 4
.IX Item "get_termcap(cap)"
.Vb 1
\&        str     rl_get_termcap(cap)
.Ve
.RE
.RS 4
.RE
.IP "Alternate Interface" 4
.IX Item "Alternate Interface"
.RS 4
.PD 0
.ie n .IP """callback_handlez_install(PROMPT, LHANDLER)""" 4
.el .IP "\f(CWcallback_handlez_install(PROMPT, LHANDLER)\fR" 4
.IX Item "callback_handlez_install(PROMPT, LHANDLER)"
.PD
.Vb 1
\&        void    rl_callback_handlez_install(str prompt, pfunc lhandlez)
.Ve
.ie n .IP """callback_read_char""" 4
.el .IP "\f(CWcallback_read_char\fR" 4
.IX Item "callback_read_char"
.Vb 1
\&        void    rl_callback_read_char()
.Ve
.ie n .IP """callback_handlez_remove""" 4
.el .IP "\f(CWcallback_handlez_remove\fR" 4
.IX Item "callback_handlez_remove"
.Vb 1
\&        void    rl_callback_handlez_remove()
.Ve
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "Readline Signal Handling" 4
.IX Item "Readline Signal Handling"
.RS 4
.PD 0
.ie n .IP """cleanup_after_signal""" 4
.el .IP "\f(CWcleanup_after_signal\fR" 4
.IX Item "cleanup_after_signal"
.PD
.Vb 1
\&        void    rl_cleanup_after_signal()       # GRL 4.0
.Ve
.ie n .IP """free_line_state""" 4
.el .IP "\f(CWfree_line_state\fR" 4
.IX Item "free_line_state"
.Vb 1
\&        void    rl_free_line_state()    # GRL 4.0
.Ve
.ie n .IP """reset_after_signal""" 4
.el .IP "\f(CWreset_after_signal\fR" 4
.IX Item "reset_after_signal"
.Vb 1
\&        void    rl_reset_after_signal() # GRL 4.0
.Ve
.ie n .IP """echo_signal_char""" 4
.el .IP "\f(CWecho_signal_char\fR" 4
.IX Item "echo_signal_char"
.Vb 1
\&        void    rl_echo_signal_char(int sig)    # GRL 6.0
.Ve
.ie n .IP """resize_terminal""" 4
.el .IP "\f(CWresize_terminal\fR" 4
.IX Item "resize_terminal"
.Vb 1
\&        void    rl_resize_terminal()    # GRL 4.0
.Ve
.ie n .IP """set_screen_size(ROWS, COLS)""" 4
.el .IP "\f(CWset_screen_size(ROWS, COLS)\fR" 4
.IX Item "set_screen_size(ROWS, COLS)"
.Vb 1
\&        void    rl_set_screen_size(int ROWS, int COLS)  # GRL 4.2
.Ve
.ie n .IP """get_screen_size()""" 4
.el .IP "\f(CWget_screen_size()\fR" 4
.IX Item "get_screen_size()"
.Vb 1
\&        (int rows, int cols)    rl_get_screen_size()    # GRL 4.2
.Ve
.ie n .IP """reset_screen_size()""" 4
.el .IP "\f(CWreset_screen_size()\fR" 4
.IX Item "reset_screen_size()"
.Vb 1
\&        void    rl_reset_screen_size()  # GRL 5.1
.Ve
.ie n .IP """set_signals""" 4
.el .IP "\f(CWset_signals\fR" 4
.IX Item "set_signals"
.Vb 1
\&        int     rl_set_signals()        # GRL 4.0
.Ve
.ie n .IP """clear_signals""" 4
.el .IP "\f(CWclear_signals\fR" 4
.IX Item "clear_signals"
.Vb 1
\&        int     rl_clear_signals()      # GRL 4.0
.Ve
.RE
.RS 4
.RE
.IP "Completion Functions" 4
.IX Item "Completion Functions"
.RS 4
.PD 0
.ie n .IP """complete_internal([WHAT_TO_DO])""" 4
.el .IP "\f(CWcomplete_internal([WHAT_TO_DO])\fR" 4
.IX Item "complete_internal([WHAT_TO_DO])"
.PD
.Vb 1
\&        int     rl_complete_internal(int what_to_do = TAB)
.Ve
.ie n .IP """completion_mode(FUNCTION)""" 4
.el .IP "\f(CWcompletion_mode(FUNCTION)\fR" 4
.IX Item "completion_mode(FUNCTION)"
.Vb 1
\&        int     rl_completion_mode(FunctionPtr|str function)
.Ve
.ie n .IP """completion_matches(TEXT [,FUNC])""" 4
.el .IP "\f(CWcompletion_matches(TEXT [,FUNC])\fR" 4
.IX Item "completion_matches(TEXT [,FUNC])"
.Vb 2
\&        (@str)  rl_completion_matches(str text,
\&                                      pfunc func = filename_completion_function)
.Ve
.ie n .IP """filename_completion_function(TEXT, STATE)""" 4
.el .IP "\f(CWfilename_completion_function(TEXT, STATE)\fR" 4
.IX Item "filename_completion_function(TEXT, STATE)"
.Vb 1
\&        str     rl_filename_completion_function(str text, int state)
.Ve
.ie n .IP """username_completion_function(TEXT, STATE)""" 4
.el .IP "\f(CWusername_completion_function(TEXT, STATE)\fR" 4
.IX Item "username_completion_function(TEXT, STATE)"
.Vb 1
\&        str     rl_username_completion_function(str text, int state)
.Ve
.ie n .IP """list_completion_function(TEXT, STATE)""" 4
.el .IP "\f(CWlist_completion_function(TEXT, STATE)\fR" 4
.IX Item "list_completion_function(TEXT, STATE)"
.Vb 1
\&        str     list_completion_function(str text, int state)
.Ve
.RE
.RS 4
.RE
.IP "History Functions" 4
.IX Item "History Functions"
.RS 4
.PD 0
.IP "Initializin History n' State Management" 4
.IX Item "Initializin History n' State Management"
.RS 4
.ie n .IP """using_history""" 4
.el .IP "\f(CWusing_history\fR" 4
.IX Item "using_history"
.PD
.Vb 1
\&        void    using_history()
.Ve
.RE
.RS 4
.RE
.IP "History List Management" 4
.IX Item "History List Management"
.RS 4
.PD 0
.ie n .IP """addhistory(STRING[, STRING, ...])""" 4
.el .IP "\f(CWaddhistory(STRING[, STRING, ...])\fR" 4
.IX Item "addhistory(STRING[, STRING, ...])"
.PD
.Vb 1
\&        void    add_history(str string)
.Ve
.ie n .IP """StifleHistory(MAX)""" 4
.el .IP "\f(CWStifleHistory(MAX)\fR" 4
.IX Item "StifleHistory(MAX)"
.Vb 1
\&        int     stifle_history(int max|undef)
.Ve
.Sp
stiflez tha history list, rememberin only tha last \f(CW\*(C`MAX\*(C'\fR entries.
If \f(CW\*(C`MAX\*(C'\fR is undef, rethugz all entries. Put ya muthafuckin choppers up if ya feel dis!  This be a replacement
of \fIunstifle_history()\fR.
.ie n .IP """unstifle_history""" 4
.el .IP "\f(CWunstifle_history\fR" 4
.IX Item "unstifle_history"
.Vb 1
\&        int     unstifle_history()
.Ve
.Sp
This is equivalent wit 'stifle_history(undef)'.
.ie n .IP """SetHistory(LINE1 [, LINE2, ...])""" 4
.el .IP "\f(CWSetHistory(LINE1 [, LINE2, ...])\fR" 4
.IX Item "SetHistory(LINE1 [, LINE2, ...])"
sets tha history of input, from where it can be used if tha actual
\&\f(CW\*(C`readline\*(C'\fR is present.
.ie n .IP """add_history_time(STRING)""" 4
.el .IP "\f(CWadd_history_time(STRING)\fR" 4
.IX Item "add_history_time(STRING)"
.Vb 1
\&        void    add_history_time(str string)    # GRL 5.0
.Ve
.ie n .IP """remove_history(WHICH)""" 4
.el .IP "\f(CWremove_history(WHICH)\fR" 4
.IX Item "remove_history(WHICH)"
.Vb 1
\&        str     remove_history(int which)
.Ve
.ie n .IP """replace_history_entry(WHICH, LINE)""" 4
.el .IP "\f(CWreplace_history_entry(WHICH, LINE)\fR" 4
.IX Item "replace_history_entry(WHICH, LINE)"
.Vb 1
\&        str     replace_history_entry(int which, str line)
.Ve
.ie n .IP """clear_history""" 4
.el .IP "\f(CWclear_history\fR" 4
.IX Item "clear_history"
.Vb 1
\&        void    clear_history()
.Ve
.ie n .IP """history_is_stifled""" 4
.el .IP "\f(CWhistory_is_stifled\fR" 4
.IX Item "history_is_stifled"
.Vb 1
\&        int     history_is_stifled()
.Ve
.RE
.RS 4
.RE
.IP "Hype Bout tha History List" 4
.IX Item "Hype Bout tha History List"
.RS 4
.PD 0
.ie n .IP """where_history""" 4
.el .IP "\f(CWwhere_history\fR" 4
.IX Item "where_history"
.PD
.Vb 1
\&        int     where_history()
.Ve
.ie n .IP """current_history""" 4
.el .IP "\f(CWcurrent_history\fR" 4
.IX Item "current_history"
.Vb 1
\&        str     current_history()
.Ve
.ie n .IP """history_get(OFFSET)""" 4
.el .IP "\f(CWhistory_get(OFFSET)\fR" 4
.IX Item "history_get(OFFSET)"
.Vb 1
\&        str     history_get(offset)
.Ve
.ie n .IP """history_get_time(OFFSET)""" 4
.el .IP "\f(CWhistory_get_time(OFFSET)\fR" 4
.IX Item "history_get_time(OFFSET)"
.Vb 1
\&        time_t  history_get_time(offset)
.Ve
.ie n .IP """history_total_bytes""" 4
.el .IP "\f(CWhistory_total_bytes\fR" 4
.IX Item "history_total_bytes"
.Vb 1
\&        int     history_total_bytes()
.Ve
.ie n .IP """GetHistory""" 4
.el .IP "\f(CWGetHistory\fR" 4
.IX Item "GetHistory"
returns tha history of input as a list, if actual \f(CW\*(C`readline\*(C'\fR is present.
.RE
.RS 4
.RE
.IP "Movin Around tha History List" 4
.IX Item "Movin Around tha History List"
.RS 4
.PD 0
.ie n .IP """history_set_pos(POS)""" 4
.el .IP "\f(CWhistory_set_pos(POS)\fR" 4
.IX Item "history_set_pos(POS)"
.PD
.Vb 1
\&        int     history_set_pos(int pos)
.Ve
.ie n .IP """previous_history""" 4
.el .IP "\f(CWprevious_history\fR" 4
.IX Item "previous_history"
.Vb 1
\&        str     previous_history()
.Ve
.ie n .IP """next_history""" 4
.el .IP "\f(CWnext_history\fR" 4
.IX Item "next_history"
.Vb 1
\&        str     next_history()
.Ve
.RE
.RS 4
.RE
.IP "Searchin tha History List" 4
.IX Item "Searchin tha History List"
.RS 4
.PD 0
.ie n .IP """history_search(STRING [,DIRECTION])""" 4
.el .IP "\f(CWhistory_search(STRING [,DIRECTION])\fR" 4
.IX Item "history_search(STRING [,DIRECTION])"
.PD
.Vb 1
\&        int     history_search(str string, int direction = \-1)
.Ve
.ie n .IP """history_search_prefix(STRING [,DIRECTION])""" 4
.el .IP "\f(CWhistory_search_prefix(STRING [,DIRECTION])\fR" 4
.IX Item "history_search_prefix(STRING [,DIRECTION])"
.Vb 1
\&        int     history_search_prefix(str string, int direction = \-1)
.Ve
.ie n .IP """history_search_pos(STRING [,DIRECTION [,POS]])""" 4
.el .IP "\f(CWhistory_search_pos(STRING [,DIRECTION [,POS]])\fR" 4
.IX Item "history_search_pos(STRING [,DIRECTION [,POS]])"
.Vb 3
\&        int     history_search_pos(str string,
\&                                   int direction = \-1,
\&                                   int pos = where_history())
.Ve
.RE
.RS 4
.RE
.IP "Managin tha History File" 4
.IX Item "Managin tha History File"
.RS 4
.PD 0
.ie n .IP """ReadHistory([FILENAME [,FROM [,TO]]])""" 4
.el .IP "\f(CWReadHistory([FILENAME [,FROM [,TO]]])\fR" 4
.IX Item "ReadHistory([FILENAME [,FROM [,TO]]])"
.PD
.Vb 2
\&        int     read_history(str filename = \*(Aq~/.history\*(Aq,
\&                             int from = 0, int ta = \-1)
\&
\&        int     read_history_range(str filename = \*(Aq~/.history\*(Aq,
\&                                   int from = 0, int ta = \-1)
.Ve
.Sp
addz tha contentz of \f(CW\*(C`FILENAME\*(C'\fR ta tha history list, a line at a
time.  If \f(CW\*(C`FILENAME\*(C'\fR is false, then read from \fI~/.history\fR.  Start
readin at line \f(CW\*(C`FROM\*(C'\fR n' end at \f(CW\*(C`TO\*(C'\fR.  If \f(CW\*(C`FROM\*(C'\fR is omitted or
zero, start all up in tha beginning.  If \f(CW\*(C`TO\*(C'\fR is omitted or less than
\&\f(CW\*(C`FROM\*(C'\fR, then read until tha end of tha file.  Returns legit if
successful, or false if not.  \f(CW\*(C`read_history()\*(C'\fR be a aliase of
\&\f(CW\*(C`read_history_range()\*(C'\fR.
.ie n .IP """WriteHistory([FILENAME])""" 4
.el .IP "\f(CWWriteHistory([FILENAME])\fR" 4
.IX Item "WriteHistory([FILENAME])"
.Vb 1
\&        int     write_history(str filename = \*(Aq~/.history\*(Aq)
.Ve
.Sp
writes tha current history ta \f(CW\*(C`FILENAME\*(C'\fR, overwritin \f(CW\*(C`FILENAME\*(C'\fR if
necessary.  If \f(CW\*(C`FILENAME\*(C'\fR is false, then write tha history list to
\&\fI~/.history\fR.  Returns legit if successful, or false if not.
.ie n .IP """append_history(NELEMENTS [,FILENAME])""" 4
.el .IP "\f(CWappend_history(NELEMENTS [,FILENAME])\fR" 4
.IX Item "append_history(NELEMENTS [,FILENAME])"
.Vb 1
\&        int     append_history(int nelements, str filename = \*(Aq~/.history\*(Aq)
.Ve
.ie n .IP """history_truncate_file([FILENAME [,NLINES]])""" 4
.el .IP "\f(CWhistory_truncate_file([FILENAME [,NLINES]])\fR" 4
.IX Item "history_truncate_file([FILENAME [,NLINES]])"
.Vb 2
\&        int     history_truncate_file(str filename = \*(Aq~/.history\*(Aq,
\&                                      int nlines = 0)
.Ve
.RE
.RS 4
.RE
.IP "History Expansion" 4
.IX Item "History Expansion"
.RS 4
.PD 0
.ie n .IP """history_expand(LINE)""" 4
.el .IP "\f(CWhistory_expand(LINE)\fR" 4
.IX Item "history_expand(LINE)"
.PD
.Vb 1
\&        (int result, str expansion) history_expand(str line)
.Ve
.Sp
Note dat dis function returns \f(CW\*(C`expansion\*(C'\fR up in scalar context.
.ie n .IP """get_history_event(STRING, CINDEX [,QCHAR])""" 4
.el .IP "\f(CWget_history_event(STRING, CINDEX [,QCHAR])\fR" 4
.IX Item "get_history_event(STRING, CINDEX [,QCHAR])"
.Vb 3
\&        (str text, int cindex) = get_history_event(str  string,
\&                                                   int  cindex,
\&                                                   char qchar = \*(Aq\e0\*(Aq)
.Ve
.ie n .IP """history_tokenize(LINE)""" 4
.el .IP "\f(CWhistory_tokenize(LINE)\fR" 4
.IX Item "history_tokenize(LINE)"
.Vb 1
\&        (@str)  history_tokenize(str line)
.Ve
.ie n .IP """history_arg_extract(LINE, [FIRST [,LAST]])""" 4
.el .IP "\f(CWhistory_arg_extract(LINE, [FIRST [,LAST]])\fR" 4
.IX Item "history_arg_extract(LINE, [FIRST [,LAST]])"
.Vb 1
\&        str history_arg_extract(str line, int first = 0, int last = \*(Aq$\*(Aq)
.Ve
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.ie n .SS """Term::ReadLine::Gnu"" Variables"
.el .SS "\f(CWTerm::ReadLine::Gnu\fP Variables"
.IX Subsection "Term::ReadLine::Gnu Variables"
Peepin \s-1GNU\s0 Readline/History Library variablez can be accessed from
Perl program.  See '\s-1GNU\s0 Readline Library Manual' n' ' \s-1GNU\s0 History
Library Manual' fo' each variable.  Yo ass can access dem with
\&\f(CW\*(C`Attribs\*(C'\fR methods.  Namez of keys up in dis hash conform ta standard
conventions wit tha leadin \f(CW\*(C`rl_\*(C'\fR stripped.
.PP
Examples:
.PP
.Vb 3
\&    $attribs = $term\->Attribs;
\&    $v = $attribs\->{library_version};   # rl_library_version
\&    $v = $attribs\->{history_base};      # history_base
.Ve
.IP "Readline Variables" 4
.IX Item "Readline Variables"
.Vb 10
\&        str rl_line_buffer
\&        int rl_point
\&        int rl_end
\&        int rl_mark
\&        int rl_done
\&        int rl_num_chars_to_read (GRL 4.2)
\&        int rl_pending_input
\&        int rl_dispatchin (GRL 4.2)
\&        int rl_erase_empty_line (GRL 4.0)
\&        str rl_prompt (read only)
\&        str rl_display_prompt (GRL 6.0)
\&        int rl_already_prompted (GRL 4.1)
\&        str rl_library_version (read only)
\&        int rl_readline_version (read only)
\&        int rl_gnu_readline_p (GRL 4.2)
\&        str rl_terminal_name
\&        str rl_readline_name
\&        filehandle rl_instream
\&        filehandle rl_outstream
\&        int rl_prefer_env_winsize (GRL 5.1)
\&        pfunc rl_last_func (GRL 4.2)
\&        pfunc rl_startup_hook
\&        pfunc rl_pre_input_hook (GRL 4.0)
\&        pfunc rl_event_hook
\&        pfunc rl_getc_function
\&        pfunc rl_redisplay_function
\&        pfunc rl_prep_term_function (GRL 4.2)
\&        pfunc rl_deprep_term_function (GRL 4.2)
\&        Keymap rl_executing_keymap (read only)
\&        Keymap rl_binding_keymap (read only)
\&        str rl_executing_macro (GRL 4.2)
\&        int rl_readline_state (GRL 4.2)
\&        int rl_explicit_arg (GRL 4.2)
\&        int rl_numeric_arg (GRL 4.2)
\&        int rl_editing_mode (GRL 4.2)
.Ve
.IP "Signal Handlin Variables" 4
.IX Item "Signal Handlin Variables"
.Vb 2
\&        int rl_catch_signals (GRL 4.0)
\&        int rl_catch_sigwinch (GRL 4.0)
.Ve
.IP "Completion Variables" 4
.IX Item "Completion Variables"
.Vb 10
\&        pfunc rl_completion_entry_function
\&        pfunc rl_attempted_completion_function
\&        pfunc rl_filename_quoting_function
\&        pfunc rl_filename_dequoting_function
\&        pfunc rl_char_is_quoted_p
\&        int rl_completion_query_items
\&        str rl_basic_word_break_characters
\&        str rl_basic_quote_characters
\&        str rl_completer_word_break_characters
\&        pfunc rl_completion_word_break_hook (GRL 5.0)
\&        str rl_completer_quote_characters
\&        str rl_filename_quote_characters
\&        str rl_special_prefixes
\&        int rl_completion_append_character
\&        int rl_completion_suppress_append (GRL 4.3)
\&        int rl_completion_quote_charactor (GRL 5.0)
\&        int rl_completion_suppress_quote (GRL 5.0)
\&        int rl_completion_found_quote (GRL 5.0)
\&        int rl_completion_mark_symlink_dirs (GRL 4.3)
\&        int rl_ignore_completion_duplicates
\&        int rl_filename_completion_desired
\&        int rl_filename_quoting_desired
\&        int rl_attempted_completion_over (GRL 4.2)
\&        int rl_sort_completion_matches (GRL 6.0)
\&        int rl_completion_type (GRL 4.2)
\&        int rl_completion_invoking_key (GRL 6.0)
\&        int rl_inhibit_completion
\&        pfunc rl_ignore_some_completion_function
\&        pfunc rl_directory_completion_hook
\&        pfunc rl_completion_display_matches_hook (GRL 4.0)
.Ve
.IP "History Variables" 4
.IX Item "History Variables"
.Vb 12
\&        int history_base
\&        int history_length
\&        int history_max_entries (called \`max_input_history\*(Aq. read only)
\&        int history_write_timestamps (GRL 5.0)
\&        char history_expansion_char
\&        char history_subst_char
\&        char history_comment_char
\&        str history_word_delimitas (GRL 4.2)
\&        str history_no_expand_chars
\&        str history_search_delimiter_chars
\&        int history_quotes_inhibit_expansion
\&        pfunc history_inhibit_expansion_function
.Ve
.IP "Function References" 4
.IX Item "Function References"
.Vb 9
\&        rl_getc
\&        rl_redisplay
\&        rl_callback_read_char
\&        rl_display_match_list
\&        rl_filename_completion_function
\&        rl_username_completion_function
\&        list_completion_function
\&        shadow_redisplay
\&        Tk_getc
.Ve
.SS "Custom Completion"
.IX Subsection "Custom Completion"
In dis section variablez n' functions fo' custom completion is
busted lyrics bout wit examples.
.PP
Most of descriptions up in dis section is cited from \s-1GNU\s0 Readline
Library manual.
.ie n .IP """rl_completion_entry_function""" 4
.el .IP "\f(CWrl_completion_entry_function\fR" 4
.IX Item "rl_completion_entry_function"
This variable holdz reference refers ta a generator function for
\&\f(CW\*(C`completion_matches()\*(C'\fR.
.Sp
A generator function is called repeatedly from
\&\f(CW\*(C`completion_matches()\*(C'\fR, returnin a strang each time.  Da arguments
to tha generator function is \f(CW\*(C`TEXT\*(C'\fR n' \f(CW\*(C`STATE\*(C'\fR.  \f(CW\*(C`TEXT\*(C'\fR is the
partial word ta be completed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \f(CW\*(C`STATE\*(C'\fR is zero tha last time the
function is called, allowin tha generator ta big-ass up any necessary
initialization, n' a positizzle non-zero integer fo' each subsequent
call.  When tha generator function returns \f(CW\*(C`undef\*(C'\fR dis signals
\&\f(CW\*(C`completion_matches()\*(C'\fR dat there be no mo' possibilitizzles left.
.Sp
If tha value is undef, built-in \f(CW\*(C`filename_completion_function\*(C'\fR is
used.
.Sp
A sample generator function, \f(CW\*(C`list_completion_function\*(C'\fR, is defined
in Gnu.pm.  Yo ass can use it as bigs up;
.Sp
.Vb 11
\&    use Term::ReadLine;
\&    ...
\&    mah $term = freshly smoked up Term::ReadLine \*(Aqsample\*(Aq;
\&    mah $attribs = $term\->Attribs;
\&    ...
\&    $attribs\->{completion_entry_function} =
\&        $attribs\->{list_completion_function};
\&    ...
\&    $attribs\->{completion_word} =
\&        [qw(reference ta a list of lyrics which you wanna use fo' completion)];
\&    $term\->readline("custom completion>");
.Ve
.Sp
See also \f(CW\*(C`completion_matches\*(C'\fR.
.ie n .IP """rl_attempted_completion_function""" 4
.el .IP "\f(CWrl_attempted_completion_function\fR" 4
.IX Item "rl_attempted_completion_function"
A reference ta a alternatizzle function ta create matches.
.Sp
Da function is called wit \f(CW\*(C`TEXT\*(C'\fR, \f(CW\*(C`LINE_BUFFER\*(C'\fR, \f(CW\*(C`START\*(C'\fR, and
\&\f(CW\*(C`END\*(C'\fR.  \f(CW\*(C`LINE_BUFFER\*(C'\fR be a cold-ass lil current input buffer string.  \f(CW\*(C`START\*(C'\fR
and \f(CW\*(C`END\*(C'\fR is indices up in \f(CW\*(C`LINE_BUFFER\*(C'\fR sayin what tha fuck tha boundaries of
\&\f(CW\*(C`TEXT\*(C'\fR are.
.Sp
If dis function exists n' returns null list or \f(CW\*(C`undef\*(C'\fR, or if this
variable is set ta \f(CW\*(C`undef\*(C'\fR, then a internal function
\&\f(CW\*(C`rl_complete()\*(C'\fR will call tha value of
\&\f(CW$rl_completion_entry_function\fR ta generate matches, otherwise the
array of strings returned is ghon be used.
.Sp
Da default value of dis variable is \f(CW\*(C`undef\*(C'\fR.  Yo ass can use it as bigs up;
.Sp
.Vb 10
\&    use Term::ReadLine;
\&    ...
\&    mah $term = freshly smoked up Term::ReadLine \*(Aqsample\*(Aq;
\&    mah $attribs = $term\->Attribs;
\&    ...
\&    sub sample_completion {
\&        mah ($text, $line, $start, $end) = @_;
\&        # If first word then username completion, else filename completion
\&        if (substr($line, 0, $start) =~ /^\es*$/) {
\&            return $term\->completion_matches($text,
\&                                             $attribs\->{\*(Aqusername_completion_function\*(Aq});
\&        } else {
\&            return ();
\&        }
\&    }
\&    ...
\&    $attribs\->{attempted_completion_function} = \e&sample_completion;
.Ve
.ie n .IP """completion_matches(TEXT, ENTRY_FUNC)""" 4
.el .IP "\f(CWcompletion_matches(TEXT, ENTRY_FUNC)\fR" 4
.IX Item "completion_matches(TEXT, ENTRY_FUNC)"
Returns a array of strings which be a list of completions for
\&\f(CW\*(C`TEXT\*(C'\fR.  If there be no completions, returns \f(CW\*(C`undef\*(C'\fR.  Da first
entry up in tha returned array is tha substitution fo' \f(CW\*(C`TEXT\*(C'\fR.  The
remainin entries is tha possible completions.
.Sp
\&\f(CW\*(C`ENTRY_FUNC\*(C'\fR be a generator function which has two arguments, and
returns a string.  Da first argument is \f(CW\*(C`TEXT\*(C'\fR.  Da second be a
state argument; it is zero on tha straight-up original gangsta call, n' non-zero on
subsequent calls.  \f(CW\*(C`ENTRY_FUNC\*(C'\fR returns a \f(CW\*(C`undef\*(C'\fR ta tha calla when
there is no mo' matches.
.Sp
If tha value of \f(CW\*(C`ENTRY_FUNC\*(C'\fR is undef, built-in
\&\f(CW\*(C`filename_completion_function\*(C'\fR is used.
.Sp
\&\f(CW\*(C`completion_matches\*(C'\fR be a Perl wrapper function of a internal
function \f(CW\*(C`completion_matches()\*(C'\fR.  See also
\&\f(CW$rl_completion_entry_function\fR.
.ie n .IP """completion_function""" 4
.el .IP "\f(CWcompletion_function\fR" 4
.IX Item "completion_function"
A variable whose content be a reference ta a gangbangin' function which returns a
list of muthafuckas ta complete.
.Sp
This variable is compatible wit \f(CW\*(C`Term::ReadLine::Perl\*(C'\fR n' straight-up easy as fuck 
to use.
.Sp
.Vb 9
\&    use Term::ReadLine;
\&    ...
\&    mah $term = freshly smoked up Term::ReadLine \*(Aqsample\*(Aq;
\&    mah $attribs = $term\->Attribs;
\&    ...
\&    $attribs\->{completion_function} = sub {
\&        mah ($text, $line, $start) = @_;
\&        return qw(a list of muthafuckas ta complete);
\&    }
.Ve
.ie n .IP """list_completion_function(TEXT, STATE)""" 4
.el .IP "\f(CWlist_completion_function(TEXT, STATE)\fR" 4
.IX Item "list_completion_function(TEXT, STATE)"
A sample generator function defined by \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR.
Example code at \f(CW\*(C`rl_completion_entry_function\*(C'\fR shows how tha fuck ta use this
function.
.ie n .SS """Term::ReadLine::Gnu"" Specific Features"
.el .SS "\f(CWTerm::ReadLine::Gnu\fP Specific Features"
.IX Subsection "Term::ReadLine::Gnu Specific Features"
.ie n .IP """Term::ReadLine::Gnu"" Specific Functions" 4
.el .IP "\f(CWTerm::ReadLine::Gnu\fR Specific Functions" 4
.IX Item "Term::ReadLine::Gnu Specific Functions"
.RS 4
.PD 0
.ie n .IP """CallbackHandlezInstall(PROMPT, LHANDLER)""" 4
.el .IP "\f(CWCallbackHandlezInstall(PROMPT, LHANDLER)\fR" 4
.IX Item "CallbackHandlezInstall(PROMPT, LHANDLER)"
.PD
This method serves up tha function \f(CW\*(C`rl_callback_handlez_install()\*(C'\fR
with tha followin addtionizzle feature compatible wit \f(CW\*(C`readline\*(C'\fR
method; ornament feature, \f(CW\*(C`Term::ReadLine::Perl\*(C'\fR compatible
completion function, histroy expansion, n' addizzle ta history
buffer.
.ie n .IP """call_function(FUNCTION, [COUNT [,KEY]])""" 4
.el .IP "\f(CWcall_function(FUNCTION, [COUNT [,KEY]])\fR" 4
.IX Item "call_function(FUNCTION, [COUNT [,KEY]])"
.Vb 1
\&        int     rl_call_function(FunctionPtr|str function, count = 1, key = \-1)
.Ve
.ie n .IP """rl_get_all_function_names""" 4
.el .IP "\f(CWrl_get_all_function_names\fR" 4
.IX Item "rl_get_all_function_names"
Returns a list of all function names.
.ie n .IP """shadow_redisplay""" 4
.el .IP "\f(CWshadow_redisplay\fR" 4
.IX Item "shadow_redisplay"
A redisplay function fo' password input.  Yo ass can use it as bigs up;
.Sp
.Vb 2
\&        $attribs\->{redisplay_function} = $attribs\->{shadow_redisplay};
\&        $line = $term\->readline("password> ");
.Ve
.ie n .IP """rl_filename_list""" 4
.el .IP "\f(CWrl_filename_list\fR" 4
.IX Item "rl_filename_list"
Returns muthafuckaz of filename ta complete.  This function can be used
with \f(CW\*(C`completion_function\*(C'\fR n' is implemented fo' tha compatibility
with \f(CW\*(C`Term::ReadLine::Perl\*(C'\fR.
.ie n .IP """list_completion_function""" 4
.el .IP "\f(CWlist_completion_function\fR" 4
.IX Item "list_completion_function"
See tha description of section \*(L"Custom Completion\*(R".
.RE
.RS 4
.RE
.ie n .IP """Term::ReadLine::Gnu"" Specific Variables" 4
.el .IP "\f(CWTerm::ReadLine::Gnu\fR Specific Variables" 4
.IX Item "Term::ReadLine::Gnu Specific Variables"
.RS 4
.PD 0
.ie n .IP """do_expand""" 4
.el .IP "\f(CWdo_expand\fR" 4
.IX Item "do_expand"
.PD
When true, tha history expansion is enabled. Y'all KNOW dat shit, muthafucka!  By default false.
.ie n .IP """completion_function""" 4
.el .IP "\f(CWcompletion_function\fR" 4
.IX Item "completion_function"
See tha description of section \*(L"Custom Completion\*(R".
.ie n .IP """completion_word""" 4
.el .IP "\f(CWcompletion_word\fR" 4
.IX Item "completion_word"
A reference ta a list of muthafuckas ta complete for
\&\f(CW\*(C`list_completion_function\*(C'\fR.
.RE
.RS 4
.RE
.ie n .IP """Term::ReadLine::Gnu"" Specific Commands" 4
.el .IP "\f(CWTerm::ReadLine::Gnu\fR Specific Commands" 4
.IX Item "Term::ReadLine::Gnu Specific Commands"
.RS 4
.PD 0
.ie n .IP """history\-expand\-line""" 4
.el .IP "\f(CWhistory\-expand\-line\fR" 4
.IX Item "history-expand-line"
.PD
Da equivalent of tha Bash \f(CW\*(C`history\-expand\-line\*(C'\fR editin command.
.ie n .IP """operate\-and\-get\-next""" 4
.el .IP "\f(CWoperate\-and\-get\-next\fR" 4
.IX Item "operate-and-get-next"
Da equivalent of tha Korn shell \f(CW\*(C`operate\-and\-get\-next\-history\-line\*(C'\fR
editin command n' tha Bash \f(CW\*(C`operate\-and\-get\-next\*(C'\fR.
.Sp
This command is bound ta \f(CW\*(C`\eC\-o\*(C'\fR by default fo' tha compatibilitizzle with
the Bash n' \f(CW\*(C`Term::ReadLine::Perl\*(C'\fR.
.ie n .IP """display\-readline\-version""" 4
.el .IP "\f(CWdisplay\-readline\-version\fR" 4
.IX Item "display-readline-version"
Shows tha version of \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR n' tha one of tha \s-1GNU\s0
Readline Library.
.ie n .IP """change\-ornaments""" 4
.el .IP "\f(CWchange\-ornaments\fR" 4
.IX Item "change-ornaments"
Change ornaments interactively.
.RE
.RS 4
.RE
.SH "FILES"
.IX Header "FILES"
.IP "\fI~/.inputrc\fR" 4
.IX Item "~/.inputrc"
Readline init file.  Usin dis file it is possible dat you would
like ta bust a gangbangin' finger-lickin' different set of key bindings.  When a program which
uses tha Readline library starts up, tha init file is read, n' the
key bindings is set.
.Sp
Conditionizzle key bindin be also available.  Da program name which is
specified by tha straight-up original gangsta argument of \f(CW\*(C`new\*(C'\fR method is used as the
application construct.
.Sp
For example, when yo' program call \f(CW\*(C`new\*(C'\fR method like this;
.Sp
.Vb 3
\&        ...
\&        $term = freshly smoked up Term::ReadLine \*(AqPerlSh\*(Aq;
\&        ...
.Ve
.Sp
your \fI~/.inputrc\fR can define key bindings only fo' it as bigs up;
.Sp
.Vb 7
\&        ...
\&        $if PerlSh
\&        Meta\-Rubout: backward\-kill\-word
\&        "\eC\-x\eC\-r": re\-read\-init\-file
\&        "\ee[11~": "Function Key 1"
\&        $endif
\&        ...
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
None.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\s-1GNU\s0 Readline Library Manual" 4
.IX Item "GNU Readline Library Manual"
.PD 0
.IP "\s-1GNU\s0 History Library Manual" 4
.IX Item "GNU History Library Manual"
.ie n .IP """Term::ReadLine""" 4
.el .IP "\f(CWTerm::ReadLine\fR" 4
.IX Item "Term::ReadLine"
.ie n .IP """Term::ReadLine::Perl"" (Term\-ReadLine\-Perl\-xx.tar.gz)" 4
.el .IP "\f(CWTerm::ReadLine::Perl\fR (Term\-ReadLine\-Perl\-xx.tar.gz)" 4
.IX Item "Term::ReadLine::Perl (Term-ReadLine-Perl-xx.tar.gz)"
.IP "\fIeg/*\fR n' \fIt/*\fR up in tha Term::ReadLine::Gnu distribution" 4
.IX Item "eg/* n' t/* up in tha Term::ReadLine::Gnu distribution"
.IP "Articlez related ta Term::ReadLine::Gnu" 4
.IX Item "Articlez related ta Term::ReadLine::Gnu"
.RS 4
.IP "effectizzle perl programming" 4
.IX Item "effectizzle perl programming"
.PD
.Vb 1
\&        http://www.usenix.org/publications/login/2000\-7/features/effective.html
.Ve
.Sp
This article demonstrates how tha fuck ta integrate Term::ReadLine::Gnu tha fuck into an
interactizzle command line program.
.IP "eijiro (Japanese)" 4
.IX Item "eijiro (Japanese)"
.Vb 1
\&        http://bulknews.net/lib/columns/02_eijiro/column.html
.Ve
.Sp
A command line intercourse ta Eijiro, Japanese-Gangsta dictionary
service on \s-1WWW.\s0
.RE
.RS 4
.RE
.IP "Works which use Term::ReadLine::Gnu" 4
.IX Item "Works which use Term::ReadLine::Gnu"
.RS 4
.PD 0
.IP "Perl Debugger" 4
.IX Item "Perl Debugger"
.PD
.Vb 1
\&        perl \-d
.Ve
.IP "Da Perl Shell (psh)" 4
.IX Item "Da Perl Shell (psh)"
.Vb 1
\&        http://www.focusresearch.com/gregor/psh/
.Ve
.Sp
Da Perl Shell be a gangbangin' finger-lickin' dirty-ass shell dat combines tha interactizzle nature of a
Unix shell wit tha juice of Perl.
.Sp
A programmable completion feature compatible wit bash is implemented.
.IP "\s-1SPP \s0(Synopsys Plus Perl)" 4
.IX Item "SPP (Synopsys Plus Perl)"
.Vb 1
\&        http://www.stanford.edu/~jsolomon/SPP/
.Ve
.Sp
\&\s-1SPP \s0(Synopsys Plus Perl) be a Perl module dat wraps round Synopsys'
shell programs.  \s-1SPP\s0 is inspired by tha original gangsta dc_perl freestyled by
Steve Golson yo, but itz a entirely freshly smoked up implementation. I aint talkin' bout chicken n' gravy biatch.  Why is it
called \s-1SPP\s0 n' not dc_perl?  Well, \s-1SPP\s0 was freestyled ta wrap round any
of Synopsys' shells.
.IP "\s-1PFM \s0(Personal File Manager fo' Unix/Linux)" 4
.IX Item "PFM (Personal File Manager fo' Unix/Linux)"
.Vb 1
\&        http://p\-f\-m.sourceforge.net/
.Ve
.Sp
Pfm be a terminal-based file manager freestyled up in Perl, based on \s-1PFM.COM\s0
for MS-DOS (originally by Pizzle Culley n' Henk de Heer).
.IP "Da soundgrab" 4
.IX Item "Da soundgrab"
.Vb 1
\&        http://rawrec.sourceforge.net/soundgrab/soundgrab.html
.Ve
.Sp
soundgrab is designed ta help you slice up a funky-ass big-ass long raw audio file
(by default 44.1 kHz 2 channel signed sixteen bit lil endian) and
save yo' straight-up sections ta other files. Well shiiiit, it do dis by providing
you wit a cold-ass lil cassette playa like command line intercourse.
.IP "\s-1PDL \s0(Da Perl Data Language)" 4
.IX Item "PDL (Da Perl Data Language)"
.Vb 1
\&        http://pdl.perl.org/index_en.html
.Ve
.Sp
\&\s-1PDL \s0(``Perl Data Language'') gives standard Perl tha mobilitizzle to
compactly store n' speedily manipulate tha big-ass N\-dimensionizzle data
arrays which is tha bread n' butta of scientistical computing.
.IP "\s-1PIQT \s0(Perl Interactizzle \s-1DBI\s0 Query Tool)" 4
.IX Item "PIQT (Perl Interactizzle DBI Query Tool)"
.Vb 1
\&        http://piqt.sourceforge.net/
.Ve
.Sp
\&\s-1PIQT\s0 be a interactizzle query tool rockin tha Perl \s-1DBI\s0 database
interface. Well shiiiit, it supports ReadLine, serves up a funky-ass built up in scriptin language
with a Lisp like syntax, a online help system, n' uses wrappers to
interface ta tha \s-1DBD\s0 modules.
.IP "Ghostscript Shell" 4
.IX Item "Ghostscript Shell"
.Vb 1
\&        http://www.panix.com/~jdf/gshell/
.Ve
.Sp
It serves up a gangbangin' thugged-out way ta fuck wit tha Ghostscript interpreter,
includin command history n' auto-completion of Postscript font names
and reserved lyrics.
.IP "vshnu (the New Visual Shell)" 4
.IX Item "vshnu (the New Visual Shell)"
.Vb 1
\&        http://www.cs.indiana.edu/~kinzler/vshnu/
.Ve
.Sp
A visual shell n' \s-1CLI\s0 shell supplement.
.RE
.RS 4
.Sp
If you know any other works which can be listed here, please let me
know.
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
Hiroo Hayashi \f(CW\*(C`<hiroo.hayashi@computer.org>\*(C'\fR
.PP
\&\f(CW\*(C`http://www.perl.org/CPAN/authors/Hiroo_HAYASHI/\*(C'\fR
.SH "TODO"
.IX Header "TODO"
\&\s-1GTK+\s0 support up in addizzle ta Tk.
.SH "BUGS"
.IX Header "BUGS"
\&\f(CW\*(C`rl_add_defun()\*(C'\fR can define up ta 16 functions.
.PP
Ornament feature works only on prompt strings.  It requires straight-up hard
hackin of \f(CW\*(C`display.c:rl_redisplay()\*(C'\fR up in \s-1GNU\s0 Readline library to
ornament input line.
.PP
\&\f(CW\*(C`newTTY()\*(C'\fR aint tested yet.
