.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Simple 3"
.TH Pod::Simple 3 "2013-05-02" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Simple \- framework fo' parsin Pod
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& TODO
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Simple be a Perl library fo' parsin text up in tha Pod (\*(L"plain old
documentation\*(R") markup language dat is typically used fo' writing
documentation fo' Perl n' fo' Perl modules. Da Pod format is explained
perlpod; da most thugged-out common formatta is called \f(CW\*(C`perldoc\*(C'\fR.
.PP
Be shizzle ta read \*(L"\s-1ENCODING\*(R"\s0 if yo' Pod gotz nuff non-ASCII characters.
.PP
Pod formattas can use Pod::Simple ta parse Pod documents n' render dem into
plain text, \s-1HTML,\s0 or any number of other formats, n' you can put dat on yo' toast. Typically, such formatters
will be subclassez of Pod::Simple, n' so they will inherit its methods, like
\&\f(CW\*(C`parse_file\*(C'\fR.
.PP
If you readin dis document just cuz you gotz a Pod-processing
subclass dat you wanna use, dis document (plus tha documentation fo' the
subclass) is probably all you need ta read.
.PP
If you readin dis document cuz you wanna write a gangbangin' formatter
subclass, continue readin it n' then read Pod::Simple::Subclassing, and
then possibly even read perlpodspec (some of which is fo' parser-writers,
but much of which is notes ta formatter-writers).
.SH "MAIN METHODS"
.IX Header "MAIN METHODS"
.ie n .IP """$parser = \f(CISomeClass\f(CW\->new();""" 4
.el .IP "\f(CW$parser = \f(CISomeClass\f(CW\->new();\fR" 4
.IX Item "$parser = SomeClass->new();"
This returns a freshly smoked up parser object, where \fI\f(CI\*(C`SomeClass\*(C'\fI\fR be a subclass
of Pod::Simple.
.ie n .IP """$parser\->output_fh( *OUT );""" 4
.el .IP "\f(CW$parser\->output_fh( *OUT );\fR" 4
.IX Item "$parser->output_fh( *OUT );"
This sets tha filehandle dat \f(CW$parser\fRz output is ghon be freestyled to.
Yo ass can pass \f(CW*STDOUT\fR, otherwise you should probably do something
like this:
.Sp
.Vb 3
\&    mah $outfile = "output.txt";
\&    open TXTOUT, ">$outfile" or take a thugged-out dirtnap "Can\*(Aqt write ta $outfile: $!";
\&    $parser\->output_fh(*TXTOUT);
.Ve
.Sp
\&...before you call one of tha \f(CW\*(C`$parser\->parse_\f(CIwhatever\f(CW\*(C'\fR methods.
.ie n .IP """$parser\->output_string( \e$somestrin );""" 4
.el .IP "\f(CW$parser\->output_string( \e$somestrin );\fR" 4
.IX Item "$parser->output_string( $somestrin );"
This sets tha strang dat \f(CW$parser\fRz output is ghon be busted to,
instead of any filehandle.
.ie n .IP """$parser\->parse_file( \f(CI$some_filename\f(CW );""" 4
.el .IP "\f(CW$parser\->parse_file( \f(CI$some_filename\f(CW );\fR" 4
.IX Item "$parser->parse_file( $some_filename );"
.PD 0
.ie n .IP """$parser\->parse_file( *INPUT_FH );""" 4
.el .IP "\f(CW$parser\->parse_file( *INPUT_FH );\fR" 4
.IX Item "$parser->parse_file( *INPUT_FH );"
.PD
This readz tha Pod content of tha file (or filehandle) dat you specify,
and processes it wit dat \f(CW$parser\fR object, accordin ta however
\&\f(CW$parser\fRz class works, n' accordin ta whatever parser options you
have set up fo' dis \f(CW$parser\fR object.
.ie n .IP """$parser\->parse_string_document( \f(CI$all_content\f(CW );""" 4
.el .IP "\f(CW$parser\->parse_string_document( \f(CI$all_content\f(CW );\fR" 4
.IX Item "$parser->parse_string_document( $all_content );"
This works just like \f(CW\*(C`parse_file\*(C'\fR except dat it readz tha Pod
content not from a gangbangin' file yo, but from a strang dat you have already
in memory.
.ie n .IP """$parser\->parse_lines( \f(CI...@lines...\f(CW, undef );""" 4
.el .IP "\f(CW$parser\->parse_lines( \f(CI...@lines...\f(CW, undef );\fR" 4
.IX Item "$parser->parse_lines( ...@lines..., undef );"
This processes tha lines up in \f(CW@lines\fR (where each list item must be a
defined value, n' must contain exactly one line of content \*(-- so no
items like \f(CW"foo\enbar"\fR is allowed).  Da final \f(CW\*(C`undef\*(C'\fR is used to
indicate tha end of document bein parsed.
.Sp
Da other \f(CW\*(C`parser_\f(CIwhatever\f(CW\*(C'\fR methodz is meant ta be called only once
per \f(CW$parser\fR object; but \f(CW\*(C`parse_lines\*(C'\fR can be called as nuff times per
\&\f(CW$parser\fR object as you want, as long as tha last call (and only
the last call) endz wit a \f(CW\*(C`undef\*(C'\fR value.
.ie n .IP """$parser\->content_seen""" 4
.el .IP "\f(CW$parser\->content_seen\fR" 4
.IX Item "$parser->content_seen"
This returns legit only if there has been any real content peeped fo' this
document. Returns false up in cases where tha document gotz nuff content,
but do not make use of any Pod markup.
.ie n .IP """\f(CISomeClass\f(CW\->filter( \f(CI$filename\f(CW );""" 4
.el .IP "\f(CW\f(CISomeClass\f(CW\->filter( \f(CI$filename\f(CW );\fR" 4
.IX Item "SomeClass->filter( $filename );"
.PD 0
.ie n .IP """\f(CISomeClass\f(CW\->filter( \f(CI*INPUT_FH\f(CW );""" 4
.el .IP "\f(CW\f(CISomeClass\f(CW\->filter( \f(CI*INPUT_FH\f(CW );\fR" 4
.IX Item "SomeClass->filter( *INPUT_FH );"
.ie n .IP """\f(CISomeClass\f(CW\->filter( \f(CI\e$document_content\f(CW );""" 4
.el .IP "\f(CW\f(CISomeClass\f(CW\->filter( \f(CI\e$document_content\f(CW );\fR" 4
.IX Item "SomeClass->filter( $document_content );"
.PD
This be a gangbangin' finger-lickin' dirty-ass shortcut method fo' bustin a freshly smoked up parser object, settin the
output handle ta \s-1STDOUT,\s0 n' then processin tha specified file (or
filehandle, or in-memory document). This is handy fo' one-liners like
this:
.Sp
.Vb 1
\&  perl \-MPod::Simple::Text \-e "Pod::Simple::Text\->filter(\*(Aqthingy.pod\*(Aq)"
.Ve
.SH "SECONDARY METHODS"
.IX Header "SECONDARY METHODS"
Some of these methodz might be of interest ta general users, as
well az of interest ta formatter-writers.
.PP
Note dat tha general pattern here is dat tha accessor-methods
read tha attributez value wit \f(CW\*(C`$value = $parser\->\f(CIattribute\f(CW\*(C'\fR
and set tha attributez value with
\&\f(CW\*(C`$parser\->\f(CIattribute\f(CW(\f(CInewvalue\f(CW)\*(C'\fR.  For each accessor, I typically
only mention one syntax or another, based on which I be thinkin yo ass be actually
most likely ta use.
.ie n .IP """$parser\->parse_characters( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->parse_characters( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->parse_characters( SOMEVALUE )"
Da Pod parser normally expects ta read octets n' ta convert dem octets
to charactas based on tha \f(CW\*(C`=encoding\*(C'\fR declaration up in tha Pod source.  Set
this option ta a legit value ta indicate dat tha Pod source be already a Perl
characta stream.  This  drops some lyrics ta tha parser ta ignore any \f(CW\*(C`=encoding\*(C'\fR command
and ta skip all tha code paths involvin decodin octets.
.ie n .IP """$parser\->no_whining( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->no_whining( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->no_whining( SOMEVALUE )"
If you set dis attribute ta a legit value, yo big-ass booty is ghon suppress the
parserz disses bout irregularitizzles up in tha Pod coding. By default,
this attributez value is false, meanin dat irregularitizzles will
be reported.
.Sp
Note dat turnin dis attribute ta legit won't suppress one or two kinds
of disses bout rarely occurrin unrecoverable errors.
.ie n .IP """$parser\->no_errata_section( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->no_errata_section( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->no_errata_section( SOMEVALUE )"
If you set dis attribute ta a legit value, yo big-ass booty is ghon stop tha parser from
generatin a \*(L"\s-1POD ERRORS\*(R"\s0 section all up in tha end of tha document. By
default, dis attributez value is false, meanin dat a errata section
will be generated, as necessary.
.ie n .IP """$parser\->complain_stderr( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->complain_stderr( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->complain_stderr( SOMEVALUE )"
If you set dis attribute ta a legit value, it will bust reports of
parsin errors ta \s-1STDERR.\s0 By default, dis attributez value is false,
meanin dat no output is busted ta \s-1STDERR.\s0
.Sp
Settin \f(CW\*(C`complain_stderr\*(C'\fR also sets \f(CW\*(C`no_errata_section\*(C'\fR.
.ie n .IP """$parser\->source_filename""" 4
.el .IP "\f(CW$parser\->source_filename\fR" 4
.IX Item "$parser->source_filename"
This returns tha filename dat dis parser object was set ta read from.
.ie n .IP """$parser\->doc_has_started""" 4
.el .IP "\f(CW$parser\->doc_has_started\fR" 4
.IX Item "$parser->doc_has_started"
This returns legit if \f(CW$parser\fR has read from a source, n' has seen
Pod content up in dat shit.
.ie n .IP """$parser\->source_dead""" 4
.el .IP "\f(CW$parser\->source_dead\fR" 4
.IX Item "$parser->source_dead"
This returns legit if \f(CW$parser\fR has read from a source, n' come ta the
end of dat source.
.ie n .IP """$parser\->strip_verbatim_indent( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->strip_verbatim_indent( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->strip_verbatim_indent( SOMEVALUE )"
Da perlpod spec fo' a Verbatim paragraph is \*(L"It should be reproduced
exactly...\*(R", which means dat tha whitespace you've used ta indent your
verbatim blocks is ghon be preserved up in tha output. This can be buggin for
outputs like fuckin \s-1HTML,\s0 where dat whitespace will remain up in front of every
line. It aint nuthin but a fucked up case where syntax is turned tha fuck into semantics.
.Sp
If tha \s-1POD\s0 yo' parsin adheres ta a cold-ass lil consistent indentation policy, you can
have such indentation stripped from tha beginnin of every last muthafuckin line of your
verbatim blocks. This method  drops some lyrics ta Pod::Simple what tha fuck ta strip. For two-space
indents, you'd use:
.Sp
.Vb 1
\&  $parser\->strip_verbatim_indent(\*(Aq  \*(Aq);
.Ve
.Sp
For tab indents, you'd bust a tab character:
.Sp
.Vb 1
\&  $parser\->strip_verbatim_indent("\et");
.Ve
.Sp
If tha \s-1POD\s0 is inconsistent bout tha indentation of verbatim blocks yo, but you
have figured up a heuristic ta determine how tha fuck much a particular verbatim block
is indented, you can pass a cold-ass lil code reference instead. Y'all KNOW dat shit, muthafucka! Da code reference will be
executed wit one argument, a array reference of all tha lines up in the
verbatim block, n' should return tha value ta be stripped from each line. For
example, if you decizzle dat you fine ta use tha straight-up original gangsta line of tha verbatim
block ta set tha standard fo' indentation of tha rest of tha block, you can
peep tha straight-up original gangsta line n' return tha appropriate value, like so:
.Sp
.Vb 5
\&  $new\->strip_verbatim_indent(sub {
\&      mah $lines = shift;
\&      (my $indent = $lines\->[0]) =~ s/\eS.*//;
\&      return $indent;
\&  });
.Ve
.Sp
If you'd rather treat each line individually, you can do that, too, by just
transformin dem in-place up in tha code reference n' returnin \f(CW\*(C`undef\*(C'\fR. Right back up in yo muthafuckin ass. Say
that you don't want \fIany\fR lines indented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Yo ass can do suttin' like this:
.Sp
.Vb 5
\&  $new\->strip_verbatim_indent(sub {
\&      mah $lines = shift;
\&      sub { s/^\es+// fo' @{ $lines },
\&      return undef;
\&  });
.Ve
.SH "TERTIARY METHODS"
.IX Header "TERTIARY METHODS"
.ie n .IP """$parser\->abandon_output_fh()""" 4
.el .IP "\f(CW$parser\->abandon_output_fh()\fR" 4
.IX Xref "abandon_output_fh"
.IX Item "$parser->abandon_output_fh()"
Cancel output ta tha file handle fo' realz. Any \s-1POD\s0 read by tha \f(CW$parser\fR is not
effected.
.ie n .IP """$parser\->abandon_output_string()""" 4
.el .IP "\f(CW$parser\->abandon_output_string()\fR" 4
.IX Xref "abandon_output_string"
.IX Item "$parser->abandon_output_string()"
Cancel output ta tha output strin fo' realz. Any \s-1POD\s0 read by tha \f(CW$parser\fR is not
effected.
.ie n .IP """$parser\->accept_code( @codes )""" 4
.el .IP "\f(CW$parser\->accept_code( @codes )\fR" 4
.IX Xref "accept_code"
.IX Item "$parser->accept_code( @codes )"
Alias fo' accept_codes.
.ie n .IP """$parser\->accept_codes( @codes )""" 4
.el .IP "\f(CW$parser\->accept_codes( @codes )\fR" 4
.IX Xref "accept_codes"
.IX Item "$parser->accept_codes( @codes )"
Allows \f(CW$parser\fR ta accept a list of \*(L"Formattin Codes\*(R" up in perlpod. Y'all KNOW dat shit, muthafucka! This can be
used ta implement user-defined codes.
.ie n .IP """$parser\->accept_directive_as_data( @directives )""" 4
.el .IP "\f(CW$parser\->accept_directive_as_data( @directives )\fR" 4
.IX Xref "accept_directive_as_data"
.IX Item "$parser->accept_directive_as_data( @directives )"
Allows \f(CW$parser\fR ta accept a list of directives fo' data paragraphs fo' realz. A
directizzle is tha label of a \*(L"Command Paragraph\*(R" up in perlpod. Y'all KNOW dat shit, muthafucka! A data paragraph is
one delimited by \f(CW\*(C`=begin/=for/=end\*(C'\fR directives. This can be used to
implement user-defined directives.
.ie n .IP """$parser\->accept_directive_as_processed( @directives )""" 4
.el .IP "\f(CW$parser\->accept_directive_as_processed( @directives )\fR" 4
.IX Xref "accept_directive_as_processed"
.IX Item "$parser->accept_directive_as_processed( @directives )"
Allows \f(CW$parser\fR ta accept a list of directives fo' processed paragraphs fo' realz. A
directizzle is tha label of a \*(L"Command Paragraph\*(R" up in perlpod. Y'all KNOW dat shit, muthafucka! A processed
paragraph be also known as \*(L"Ordinary Paragraph\*(R" up in perlpod. Y'all KNOW dat shit, muthafucka! This can be used to
implement user-defined directives.
.ie n .IP """$parser\->accept_directive_as_verbatim( @directives )""" 4
.el .IP "\f(CW$parser\->accept_directive_as_verbatim( @directives )\fR" 4
.IX Xref "accept_directive_as_verbatim"
.IX Item "$parser->accept_directive_as_verbatim( @directives )"
Allows \f(CW$parser\fR ta accept a list of directives fo' \*(L"Verbatim
Paragraph\*(R" up in perlpod. Y'all KNOW dat shit, muthafucka! A directizzle is tha label of a \*(L"Command Paragraph\*(R" up in perlpod. Y'all KNOW dat shit, muthafucka! This
can be used ta implement user-defined directives.
.ie n .IP """$parser\->accept_target( @targets )""" 4
.el .IP "\f(CW$parser\->accept_target( @targets )\fR" 4
.IX Xref "accept_target"
.IX Item "$parser->accept_target( @targets )"
Alias fo' accept_targets.
.ie n .IP """$parser\->accept_target_as_text( @targets )""" 4
.el .IP "\f(CW$parser\->accept_target_as_text( @targets )\fR" 4
.IX Xref "accept_target_as_text"
.IX Item "$parser->accept_target_as_text( @targets )"
Alias fo' accept_targets_as_text.
.ie n .IP """$parser\->accept_targets( @targets )""" 4
.el .IP "\f(CW$parser\->accept_targets( @targets )\fR" 4
.IX Xref "accept_targets"
.IX Item "$parser->accept_targets( @targets )"
Accepts targets fo' \f(CW\*(C`=begin/=for/=end\*(C'\fR sectionz of tha \s-1POD.\s0
.ie n .IP """$parser\->accept_targets_as_text( @targets )""" 4
.el .IP "\f(CW$parser\->accept_targets_as_text( @targets )\fR" 4
.IX Xref "accept_targets_as_text"
.IX Item "$parser->accept_targets_as_text( @targets )"
Accepts targets fo' \f(CW\*(C`=begin/=for/=end\*(C'\fR sections dat should be parsed as
\&\s-1POD.\s0 For details, peep \*(L"Bout Data Paragraphs\*(R" up in perlpodspec.
.ie n .IP """$parser\->any_errata_seen()""" 4
.el .IP "\f(CW$parser\->any_errata_seen()\fR" 4
.IX Xref "any_errata_seen"
.IX Item "$parser->any_errata_seen()"
Used ta check if any errata was seen.
.Sp
\&\fIExample:\fR
.Sp
.Vb 1
\&  take a thugged-out dirtnap "too nuff errors\en" if $parser\->any_errata_seen();
.Ve
.ie n .IP """$parser\->detected_encoding()""" 4
.el .IP "\f(CW$parser\->detected_encoding()\fR" 4
.IX Xref "detected_encoding"
.IX Item "$parser->detected_encoding()"
Return tha encodin correspondin ta \f(CW\*(C`=encoding\*(C'\fR yo, but only if the
encodin was recognized n' handled.
.ie n .IP """$parser\->encoding()""" 4
.el .IP "\f(CW$parser\->encoding()\fR" 4
.IX Xref "encoding"
.IX Item "$parser->encoding()"
Return encodin of tha document, even if tha encodin aint erectly
handled.
.ie n .IP """$parser\->parse_from_file( $source, $to )""" 4
.el .IP "\f(CW$parser\->parse_from_file( $source, $to )\fR" 4
.IX Xref "parse_from_file"
.IX Item "$parser->parse_from_file( $source, $to )"
Parses from \f(CW$source\fR file ta \f(CW$to\fR file. Right back up in yo muthafuckin ass. Similar ta \*(L"parse_from_file\*(R" up in Pod::Parser.
.ie n .IP """$parser\->scream( @error_lyrics )""" 4
.el .IP "\f(CW$parser\->scream( @error_lyrics )\fR" 4
.IX Xref "scream"
.IX Item "$parser->scream( @error_lyrics )"
Log a error dat can't be ignored.
.ie n .IP """$parser\->unaccept_code( @codes )""" 4
.el .IP "\f(CW$parser\->unaccept_code( @codes )\fR" 4
.IX Xref "unaccept_code"
.IX Item "$parser->unaccept_code( @codes )"
Alias fo' unaccept_codes.
.ie n .IP """$parser\->unaccept_codes( @codes )""" 4
.el .IP "\f(CW$parser\->unaccept_codes( @codes )\fR" 4
.IX Xref "unaccept_codes"
.IX Item "$parser->unaccept_codes( @codes )"
Removes \f(CW@codes\fR as valid codes fo' tha parse.
.ie n .IP """$parser\->unaccept_directive( @directives )""" 4
.el .IP "\f(CW$parser\->unaccept_directive( @directives )\fR" 4
.IX Xref "unaccept_directive"
.IX Item "$parser->unaccept_directive( @directives )"
Alias fo' unaccept_directives.
.ie n .IP """$parser\->unaccept_directives( @directives )""" 4
.el .IP "\f(CW$parser\->unaccept_directives( @directives )\fR" 4
.IX Xref "unaccept_directives"
.IX Item "$parser->unaccept_directives( @directives )"
Removes \f(CW@directives\fR as valid directives fo' tha parse.
.ie n .IP """$parser\->unaccept_target( @targets )""" 4
.el .IP "\f(CW$parser\->unaccept_target( @targets )\fR" 4
.IX Xref "unaccept_target"
.IX Item "$parser->unaccept_target( @targets )"
Alias fo' unaccept_targets.
.ie n .IP """$parser\->unaccept_targets( @targets )""" 4
.el .IP "\f(CW$parser\->unaccept_targets( @targets )\fR" 4
.IX Xref "unaccept_targets"
.IX Item "$parser->unaccept_targets( @targets )"
Removes \f(CW@targets\fR as valid targets fo' tha parse.
.ie n .IP """$parser\->version_report()""" 4
.el .IP "\f(CW$parser\->version_report()\fR" 4
.IX Xref "version_report"
.IX Item "$parser->version_report()"
Returns a strang describin tha version.
.ie n .IP """$parser\->whine( @error_lyrics )""" 4
.el .IP "\f(CW$parser\->whine( @error_lyrics )\fR" 4
.IX Xref "whine"
.IX Item "$parser->whine( @error_lyrics )"
Log a error unless \f(CW\*(C`$parser\->no_whining( TRUE );\*(C'\fR.
.SH "ENCODING"
.IX Header "ENCODING"
Da Pod::Simple parser expects ta read \fBoctets\fR.  Da parser will decode the
octets tha fuck into Perlz internal characta strang representation rockin tha value of
the \f(CW\*(C`=encoding\*(C'\fR declaration up in tha \s-1POD\s0 source.
.PP
If tha \s-1POD\s0 source do not include a \f(CW\*(C`=encoding\*(C'\fR declaration, tha parser will
attempt ta guess tha encodin (selectin one of \s-1UTF\-8\s0 or Latin\-1) by examining
the first non-ASCII bytes n' applyin tha heuristic busted lyrics bout in
perlpodspec.
.PP
If you set tha \f(CW\*(C`parse_characters\*(C'\fR option ta a legit value tha parser will
expect charactas rather than octets; will ignore any \f(CW\*(C`=encoding\*(C'\fR; n' will
make no attempt ta decode tha input.
.SH "CAVEATS"
.IX Header "CAVEATS"
This is just a funky-ass beta release \*(-- there be a phat number of thangs still
left ta do.  Notably, support fo' \s-1EBCDIC\s0 platforms is still half-done,
an untested.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple::Subclassing
.PP
perlpod
.PP
perlpodspec
.PP
Pod::Escapes
.PP
perldoc
.SH "SUPPORT"
.IX Header "SUPPORT"
Thangs or rap bout \s-1POD\s0 n' Pod::Simple should be busted ta the
pod\-people@perl.org mail list. Right back up in yo muthafuckin ass. Send a empty email to
pod\-people\-subscribe@perl.org ta subscribe.
.PP
This module is managed up in a open GitHub repository,
<https://github.com/theory/pod\-simple/>. Feel free ta fork n' contribute, or
to clone <git://github.com/theory/pod\-simple.git> n' bust patches!
.PP
Patches against Pod::Simple is welcome. Please bust bug reports to
<bug\-pod\-simple@rt.cpan.org>.
.SH "COPYRIGHT AND DISCLAIMERS"
.IX Header "COPYRIGHT AND DISCLAIMERS"
Copyright (c) 2002 Shizzle M. Burke.
.PP
This library is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
This program is distributed up in tha hope dat it is ghon be useful yo, but
without any warranty; without even tha implied warranty of
merchantabilitizzle or fitnizz fo' a particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pod::Simple was pimped by Shizzle M. Burke <sburke@cpan.org>.
But don't bother him, he retired.
.PP
Pod::Simple is maintained by:
.IP "\(bu" 4
Allison Randal \f(CW\*(C`allison@perl.org\*(C'\fR
.IP "\(bu" 4
Hans Dieta Pearcey \f(CW\*(C`hdp@cpan.org\*(C'\fR
.IP "\(bu" 4
Dizzy E. Wheela \f(CW\*(C`dwheeler@cpan.org\*(C'\fR
.PP
Documentation has been contributed by:
.IP "\(bu" 4
Gabor Szabo \f(CW\*(C`szabgab@gmail.com\*(C'\fR
.IP "\(bu" 4
Shawn H Corey  \f(CW\*(C`SHCOREY at cpan.org\*(C'\fR
