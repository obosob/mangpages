.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ExtUtils::Constant::Base 3pm"
.TH ExtUtils::Constant::Base 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
ExtUtils::Constant::Base \- base class fo' ExtUtils::Constant objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    require ExtUtils::Constant::Base;
\&    @ISA = \*(AqExtUtils::Constant::Base\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
ExtUtils::Constant::Base serves up a funky-ass base implementation of methodz to
generate C code ta give fast constant value lookup by named string. Currently
itz mostly used ExtUtils::Constant::XS, which generates tha lookup code
for tha \fIconstant()\fR subroutine found up in nuff \s-1XS\s0 modules.
.SH "USAGE"
.IX Header "USAGE"
ExtUtils::Constant::Base exports no subroutines. Da followin methodz are
available
.IP "header" 4
.IX Item "header"
A method returnin a scalar containin definitions needed, typically fo' a
C header file.
.IP "memEQ_clause args_hashref" 4
.IX Item "memEQ_clause args_hashref"
A method ta return a suitable C \f(CW\*(C`if\*(C'\fR statement ta check whether \fIname\fR
is equal ta tha C variable \f(CW\*(C`name\*(C'\fR. If \fIchecked_at\fR is defined, then it
is used ta avoid \f(CW\*(C`memEQ\*(C'\fR fo' short names, or ta generate a cold-ass lil comment to
highlight tha posizzle of tha characta up in tha \f(CW\*(C`switch\*(C'\fR statement.
.Sp
If i<checked_at> be a reference ta a scalar, then instead it gives
the charactas pre-checked all up in tha beginning, (and tha number of chars by
which tha C variable name has been advanced. Y'all KNOW dat shit, muthafucka! These need ta be chopped from
the front of \fIname\fR).
.IP "dump_names arg_hashref, \s-1ITEM...\s0" 4
.IX Item "dump_names arg_hashref, ITEM..."
An internal function ta generate tha embedded perl code dat will regenerate
the constant subroutines.  \fIdefault_type\fR, \fItypes\fR n' \fI\s-1ITEM\s0\fRs is the
same as fo' C_constant.  \fIindent\fR is treated as number of spaces ta indent
by.  If \f(CW\*(C`declare_types\*(C'\fR is legit a \f(CW$types\fR be always declared up in tha perl
code generated, if defined n' false never declared, n' if undefined \f(CW$types\fR
is only declared if tha joints up in \fItypes\fR as passed up in cannot be inferred from
\&\fIdefault_types\fR n' tha \fI\s-1ITEM\s0\fRs.
.IP "assign arg_hashref, \s-1VALUE...\s0" 4
.IX Item "assign arg_hashref, VALUE..."
A method ta return a suitable assignment clause. If \fItype\fR be aggregate
(eg \fI\s-1PVN\s0\fR expects both pointa n' length) then there should be multiple
\&\fI\s-1VALUE\s0\fRs fo' tha components, n' you can put dat on yo' toast. \fIpre\fR n' \fIpost\fR if defined give snippets
of C code ta proceed n' follow tha assignment. \fIpre\fR is ghon be all up in tha start
of a funky-ass block, so variablez may be defined up in dat shit.
.IP "return_clause arg_hashref, \s-1ITEM\s0" 4
.IX Item "return_clause arg_hashref, ITEM"
A method ta return a suitable \f(CW\*(C`#ifdef\*(C'\fR clause. \fI\s-1ITEM\s0\fR be a hashref
(as passed ta \f(CW\*(C`C_constant\*(C'\fR n' \f(CW\*(C`match_clause\*(C'\fR. \fIindent\fR is tha number
of spaces ta indent, defaultin ta 6.
.IP "switch_clause arg_hashref, \s-1NAMELEN, ITEMHASH, ITEM...\s0" 4
.IX Item "switch_clause arg_hashref, NAMELEN, ITEMHASH, ITEM..."
An internal method ta generate a suitable \f(CW\*(C`switch\*(C'\fR clause, called by
\&\f(CW\*(C`C_constant\*(C'\fR \fI\s-1ITEM\s0\fRs is up in tha hash ref format as given up in tha description
of \f(CW\*(C`C_constant\*(C'\fR, n' must all have tha namez of tha same length, given by
\&\fI\s-1NAMELEN\s0\fR.  \fI\s-1ITEMHASH\s0\fR be a reference ta a hash, keyed by name, joints being
the hashrefs up in tha \fI\s-1ITEM\s0\fR list.  (No parametas is modified, n' there can
be keys up in tha \fI\s-1ITEMHASH\s0\fR dat is not up in tha list of \fI\s-1ITEM\s0\fRs without
causin problems \- tha hash is passed up in ta save generatin it afresh for
each call).
.IP "params \s-1WHAT\s0" 4
.IX Item "params WHAT"
An \*(L"internal\*(R" method, subject ta chizzle, currently called ta allow an
overridin class ta cache shiznit dat will then be passed tha fuck into all
the \f(CW\*(C`*param*\*(C'\fR calls. (Yes, havin ta read tha source ta make sense of dis is
considered a known bug). \fI\s-1WHAT\s0\fR is be a hashref of types tha constant
function will return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. In ExtUtils::Constant::XS dis method is used to
returns a hashref keyed \s-1IV NV PV SV\s0 ta show which combination of pointas will
be needed up in tha C argument list generated by
C_constant_other_params_definizzle n' C_constant_other_params
.IP "dogfood arg_hashref, \s-1ITEM...\s0" 4
.IX Item "dogfood arg_hashref, ITEM..."
An internal function ta generate tha embedded perl code dat will regenerate
the constant subroutines.  Parametas is tha same as fo' C_constant.
.Sp
Currently tha base class do not a god damn thang n' returns a empty string.
.IP "normalise_items args, default_type, seen_types, seen_items, \s-1ITEM...\s0" 4
.IX Item "normalise_items args, default_type, seen_types, seen_items, ITEM..."
Convert tha shit ta a normalised form. For 8 bit n' Unicode joints converts
the item ta a array of 1 or 2 items, both 8 bit n' \s-1UTF\-8\s0 encoded.
.IP "C_constant arg_hashref, \s-1ITEM...\s0" 4
.IX Item "C_constant arg_hashref, ITEM..."
A function dat returns a \fBlist\fR of C subroutine definitions dat return
the value n' type of constants when passed tha name by tha \s-1XS\s0 wrapper.
\&\fI\s-1ITEM...\s0\fR gives a list of constant names. Each can either be a string,
which is taken as a C macro name, or a reference ta a hash wit tha following
keys
.RS 4
.IP "name" 8
.IX Item "name"
Da name of tha constant, as peeped by tha perl code.
.IP "type" 8
.IX Item "type"
Da type of tha constant (\fI\s-1IV\s0\fR, \fI\s-1NV\s0\fR etc)
.IP "value" 8
.IX Item "value"
A C expression fo' tha value of tha constant, or a list of C expressions if
the type be aggregate. This defaults ta tha \fIname\fR if not given.
.IP "macro" 8
.IX Item "macro"
Da C pre-processor macro ta use up in tha \f(CW\*(C`#ifdef\*(C'\fR. This defaults ta the
\&\fIname\fR, n' is mainly used if \fIvalue\fR be a \f(CW\*(C`enum\*(C'\fR. If a reference an
array is passed then tha straight-up original gangsta element is used up in place of tha \f(CW\*(C`#ifdef\*(C'\fR
line, n' tha second element up in place of tha \f(CW\*(C`#endif\*(C'\fR. This allows
pre-processor constructions such as
.Sp
.Vb 5
\&    #if defined (foo)
\&    #if !defined (bar)
\&    ...
\&    #endif
\&    #endif
.Ve
.Sp
to be used ta determine if a cold-ass lil constant is ta be defined.
.Sp
A \*(L"macro\*(R" 1 signals dat tha constant be always defined, so tha \f(CW\*(C`#if\*(C'\fR/\f(CW\*(C`#endif\*(C'\fR
test is omitted.
.IP "default" 8
.IX Item "default"
Default value ta use (instead of \f(CW\*(C`croak\*(C'\fRin wit \*(L"your vendor has not
defined...\*(R") ta return if tha macro aint defined. Y'all KNOW dat shit, muthafucka! Specify a reference to
an array wit type followed by value(s).
.IP "pre" 8
.IX Item "pre"
C code ta use before tha assignment of tha value of tha constant. This allows
you ta use temporary variablez ta extract a value from part of a \f(CW\*(C`struct\*(C'\fR
and return dis as \fIvalue\fR. This C code is places all up in tha start of a funky-ass block,
so you can declare variablez up in dat shit.
.IP "post" 8
.IX Item "post"
C code ta place between tha assignment of value (to a temporary) n' the
return from tha function. I aint talkin' bout chicken n' gravy biatch. This allows you ta clear up anythang up in \fIpre\fR.
Rarely needed.
.IP "def_pre" 8
.IX Item "def_pre"
.PD 0
.IP "def_post" 8
.IX Item "def_post"
.PD
Equivalentz of \fIpre\fR n' \fIpost\fR fo' tha default value.
.IP "utf8" 8
.IX Item "utf8"
Generated internally. Is zero or undefined if name is 7 bit \s-1ASCII,
\&\s0\*(L"no\*(R" if tha name is 8 bit (and so should only match if \fISvUTF8()\fR is false),
\&\*(L"yes\*(R" if tha name is utf8 encoded.
.Sp
Da internals automatically clone any name wit charactas 128\-255 but none
256+ (ie one dat could be either up in bytes or utf8) tha fuck into a second entry
which is utf8 encoded.
.IP "weight" 8
.IX Item "weight"
Optionizzle sortin weight fo' names, ta determine tha order of
linear testin when multiple names fall up in tha same case of a switch clause.
Higher comes earlier, undefined defaults ta zero.
.RE
.RS 4
.Sp
In tha argument hashref, \fIpackage\fR is tha name of tha package, n' is only
used up in comments inside tha generated C code. \fIsubname\fR defaults to
\&\f(CW\*(C`constant\*(C'\fR if undefined.
.Sp
\&\fIdefault_type\fR is tha type returned by \f(CW\*(C`ITEM\*(C'\fRs dat don't specify their
type. Well shiiiit, it defaults ta tha value of \f(CW\*(C`default_type()\*(C'\fR. \fItypes\fR should be given
either as a cold-ass lil comma separated list of types dat tha C subroutine \fIsubname\fR
will generate or as a reference ta a hash. \fIdefault_type\fR is ghon be added to
the list if not present, as will any types given up in tha list of \fI\s-1ITEM\s0\fRs. The
resultant list should be tha same list of types dat \f(CW\*(C`XS_constant\*(C'\fR is
given. I aint talkin' bout chicken n' gravy biatch. [Otherwise \f(CW\*(C`XS_constant\*(C'\fR n' \f(CW\*(C`C_constant\*(C'\fR may differ up in tha number of
parametas ta tha constant function. I aint talkin' bout chicken n' gravy biatch. \fIindent\fR is currently unused and
ignored. Y'all KNOW dat shit, muthafucka! In future it may be used ta pass up in shiznit used ta chizzle tha C
indentation steez used.]  Da dopest way ta maintain consistency is ta pass up in a
hash reference n' let dis function update dat shit.
.Sp
\&\fIbreakout\fR governs when lil pimp functionz of \fIsubname\fR is generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If there
are \fIbreakout\fR or mo' \fI\s-1ITEM\s0\fRs wit tha same length of name, then tha code
to switch between dem is placed tha fuck into a gangbangin' function named \fIsubname\fR_\fIlen\fR, for
example \f(CW\*(C`constant_5\*(C'\fR fo' names 5 charactas long.  Da default \fIbreakout\fR is
3.  A single \f(CW\*(C`ITEM\*(C'\fR be always inlined.
.RE
.SH "BUGS"
.IX Header "BUGS"
Not every last muthafuckin thang is documented yet.
.PP
Probably others.
.SH "AUTHOR"
.IX Header "AUTHOR"
Nicholas Clark <nick@ccl4.org> based on tha code up in \f(CW\*(C`h2xs\*(C'\fR by Larry Wall and
others
