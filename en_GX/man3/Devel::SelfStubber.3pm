.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Devel::SelfStubber 3pm"
.TH Devel::SelfStubber 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::SelfStubber \- generate stubs fo' a SelfLoadin module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
To generate just tha stubs:
.PP
.Vb 2
\&    use Devel::SelfStubber;
\&    Devel::SelfStubber\->stub(\*(AqMODULENAME\*(Aq,\*(AqMY_LIB_DIR\*(Aq);
.Ve
.PP
or ta generate tha whole module wit stubs banged erectly
.PP
.Vb 3
\&    use Devel::SelfStubber;
\&    $Devel::SelfStubber::JUST_STUBS=0;
\&    Devel::SelfStubber\->stub(\*(AqMODULENAME\*(Aq,\*(AqMY_LIB_DIR\*(Aq);
.Ve
.PP
\&\s-1MODULENAME\s0 is tha Perl module name, e.g. Devel::SelfStubber,
\&\s-1NOT \s0'Devel/SelfStubber' or 'Devel/SelfStubber.pm'.
.PP
\&\s-1MY_LIB_DIR\s0 defaults ta '.' if not present.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Devel::SelfStubber prints tha stubs you need ta put up in tha module
before tha _\|_DATA_\|_ token (or you can git it ta print tha entire
module wit stubs erectly placed). Da stubs ensure dat if
a method is called, it will git loaded. Y'all KNOW dat shit, muthafucka! They is needed specifically
for inherited autoloaded methods.
.PP
This is dopest explained rockin tha followin example:
.PP
Assume four classes, A,B,C & D.
.PP
A is tha root class, B be a subclass of A, C be a subclass of B,
and D be another subclass of A.
.PP
.Vb 5
\&                        A
\&                       / \e
\&                      B   D
\&                     /
\&                    C
.Ve
.PP
If D calls a autoloaded method 'foo' which is defined up in class A,
then tha method is loaded tha fuck into class A, then executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If C then
calls method 'foo', n' dat method was reimplemented up in class
B yo, but set ta be autoloaded, then tha lookup mechanizzle never gets to
the \s-1AUTOLOAD\s0 mechanizzle up in B cuz it first findz tha method
already loaded up in A, n' so erroneously uses dis shit. If tha method
foo had been stubbed up in B, then tha lookup mechanizzle would have
found tha stub, n' erectly loaded n' used tha sub from B.
.PP
So, fo' classes n' subclasses ta have inheritizzle erectly
work wit autoloading, you need ta ensure stubs is loaded.
.PP
Da SelfLoader can load stubs automatically at module initialization
with tha statement 'SelfLoader\->\fIload_stubs()\fR'; yo, but you may wish to
avoid havin tha stub loadin overhead associated wit your
initialization (though note dat tha SelfLoader::load_stubs method
will be called sooner or lata \- at sickest fuckin when tha straight-up original gangsta sub
is bein autoloaded). In dis case, you can put tha sub stubs
before tha _\|_DATA_\|_ token. I aint talkin' bout chicken n' gravy biatch. This can be done manually yo, but this
module allows automatic generation of tha stubs.
.PP
By default it just prints tha stubs yo, but you can set the
global \f(CW$Devel::SelfStubber::JUST_STUBS\fR ta 0 n' it will
print up tha entire module wit tha stubs positioned erectly.
.PP
At tha straight-up least, dis is useful ta peep what tha fuck tha SelfLoader
thinks is stubs \- up in order ta ensure future versionz of the
SelfStubber remain up in step wit tha SelfLoader, the
SelfStubber straight-up uses tha SelfLoader ta determine which
stubs is needed.
