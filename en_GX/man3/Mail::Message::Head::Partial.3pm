.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message::Head::Partial 3"
.TH Mail::Message::Head::Partial 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Head::Partial \- subset of header shiznit of a message
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\& Mail::Message::Head::Partial
\&   be a Mail::Message::Head::Complete
\&   be a Mail::Message::Head
\&   be a Mail::Reporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& mah $partial = $head\->strip;
\& $partial\->isa(\*(AqMail::Message::Head\*(Aq)  # true
\& $partial\->isDelayed                      # false
\& $partial\->isPartial                      # true
\&
\& $partial\->removeFields( qr/^X\-/ );
\& $partial\->removeFieldsExcept( qw/To From/ );
\& $partial\->removeResentGroups;
\& $partial\->removeListGroup;
\& $partial\->removeSpamGroups;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Header shiznit consumes a cold-ass lil considerable amount of memory.  Most of this
information is only useful durin a gangbangin' finger-lickin' dirty-ass short period of time up in yo' program,
or sometimes it aint used at all.  Yo ass then can decizzle ta remove most
of tha header shiznit. I aint talkin' bout chicken n' gravy biatch.  But fuck dat shiznit yo, tha word on tha street is dat be warned dat it is ghon be lost
permanently: tha header (and therefore tha message) gets mutulated!
.SH "OVERLOADED"
.IX Header "OVERLOADED"
.ie n .IP "overload: \fB""""\fR()" 4
.el .IP "overload: \fB``''\fR()" 4
.IX Item "overload: """"()"
See \*(L"\s-1OVERLOADED\*(R"\s0 up in Mail::Message::Head
.IP "overload: \fBbool\fR()" 4
.IX Item "overload: bool()"
See \*(L"\s-1OVERLOADED\*(R"\s0 up in Mail::Message::Head
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBbuild\fR([PAIR|FIELD]\-LIST)" 4
.el .IP "\f(CW$obj\fR\->\fBbuild\fR([PAIR|FIELD]\-LIST)" 4
.IX Item "$obj->build([PAIR|FIELD]-LIST)"
See \*(L"Constructors\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBclone\fR([NAMES|ARRAY\-OF\-NAMES|REGEXS])" 4
.el .IP "\f(CW$obj\fR\->\fBclone\fR([NAMES|ARRAY\-OF\-NAMES|REGEXS])" 4
.IX Item "$obj->clone([NAMES|ARRAY-OF-NAMES|REGEXS])"
See \*(L"Constructors\*(R" up in Mail::Message::Head::Complete
.IP "Mail::Message::Head::Partial\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Message::Head::Partial->new(OPTIONS)"
See \*(L"Constructors\*(R" up in Mail::Message::Head
.SS "Da header"
.IX Subsection "Da header"
.ie n .IP "$obj\->\fBisDelayed\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDelayed\fR()" 4
.IX Item "$obj->isDelayed()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBisEmpty\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisEmpty\fR()" 4
.IX Item "$obj->isEmpty()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBisModified\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisModified\fR()" 4
.IX Item "$obj->isModified()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBknownNames\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBknownNames\fR()" 4
.IX Item "$obj->knownNames()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBmessage\fR([\s-1MESSAGE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmessage\fR([\s-1MESSAGE\s0])" 4
.IX Item "$obj->message([MESSAGE])"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.IX Item "$obj->modified([BOOLEAN])"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBnrLines\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnrLines\fR()" 4
.IX Item "$obj->nrLines()"
See \*(L"Da header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBorderedFields\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBorderedFields\fR()" 4
.IX Item "$obj->orderedFields()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBsize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsize\fR()" 4
.IX Item "$obj->size()"
See \*(L"Da header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBwrap\fR(\s-1INTEGER\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBwrap\fR(\s-1INTEGER\s0)" 4
.IX Item "$obj->wrap(INTEGER)"
See \*(L"Da header\*(R" up in Mail::Message::Head::Complete
.SS "Access ta tha header"
.IX Subsection "Access ta tha header"
.ie n .IP "$obj\->\fBadd\fR(\s-1FIELD\s0 | \s-1LINE\s0 | (\s-1NAME\s0,BODY[,ATTRS]))" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(\s-1FIELD\s0 | \s-1LINE\s0 | (\s-1NAME\s0,BODY[,ATTRS]))" 4
.IX Item "$obj->add(FIELD | LINE | (NAME,BODY[,ATTRS]))"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBaddListGroup\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddListGroup\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addListGroup(OBJECT)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBaddResentGroup\fR(RESENT\-GROUP|DATA)" 4
.el .IP "\f(CW$obj\fR\->\fBaddResentGroup\fR(RESENT\-GROUP|DATA)" 4
.IX Item "$obj->addResentGroup(RESENT-GROUP|DATA)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBaddSpamGroup\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddSpamGroup\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addSpamGroup(OBJECT)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBcleanupOrderedFields\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcleanupOrderedFields\fR()" 4
.IX Item "$obj->cleanupOrderedFields()"
Da header maintains a list of fieldz which is ordered up in sequence of
definition. I aint talkin' bout chicken n' gravy biatch.  It be required ta maintain tha header order ta keep the
related fieldz of resent crews together n' shit.  Da fieldz is also included
in a hash, sorted on they name fo' fast access.
.Sp
Da references ta field objects up in tha hash is real, dem up in tha ordered 
list is weak.  So when field objects is removed from tha hash, their
references up in tha ordered list is automagically undef'd.
.Sp
When nuff fieldz is removed, fo' instizzle wit \fIremoveFields()\fR or
\&\fIremoveFieldsExcept()\fR, then it is useful ta remove tha list of undefs
from tha ordered list as well.  In dem cases, dis method is called
automatically, however you may have yo' own reasons ta booty-call dis method.
.ie n .IP "$obj\->\fBcount\fR(\s-1NAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcount\fR(\s-1NAME\s0)" 4
.IX Item "$obj->count(NAME)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBdelete\fR(\s-1NAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1NAME\s0)" 4
.IX Item "$obj->delete(NAME)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBget\fR(\s-1NAME\s0 [,INDEX])" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR(\s-1NAME\s0 [,INDEX])" 4
.IX Item "$obj->get(NAME [,INDEX])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBgrepNames\fR([NAMES|ARRAY\-OF\-NAMES|REGEXS])" 4
.el .IP "\f(CW$obj\fR\->\fBgrepNames\fR([NAMES|ARRAY\-OF\-NAMES|REGEXS])" 4
.IX Item "$obj->grepNames([NAMES|ARRAY-OF-NAMES|REGEXS])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBlistGroup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlistGroup\fR()" 4
.IX Item "$obj->listGroup()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBnames\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnames\fR()" 4
.IX Item "$obj->names()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBprintSelected\fR(\s-1FILEHANDLE, \s0(STRING|REGEXP)s)" 4
.el .IP "\f(CW$obj\fR\->\fBprintSelected\fR(\s-1FILEHANDLE, \s0(STRING|REGEXP)s)" 4
.IX Item "$obj->printSelected(FILEHANDLE, (STRING|REGEXP)s)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBprintUndisclosed\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprintUndisclosed\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->printUndisclosed([FILEHANDLE])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBremoveContentInfo\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBremoveContentInfo\fR()" 4
.IX Item "$obj->removeContentInfo()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBremoveField\fR(\s-1FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBremoveField\fR(\s-1FIELD\s0)" 4
.IX Item "$obj->removeField(FIELD)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBremoveFields\fR(STRING|REGEXP, [STRING|REGEXP, ...])" 4
.el .IP "\f(CW$obj\fR\->\fBremoveFields\fR(STRING|REGEXP, [STRING|REGEXP, ...])" 4
.IX Item "$obj->removeFields(STRING|REGEXP, [STRING|REGEXP, ...])"
Remove tha fieldz from tha header which is exactly named '\s-1STRING\s0' (case
insensitive) or match tha REGular EXPresssion. I aint talkin' bout chicken n' gravy biatch.  Do not forget ta add the
\&'i' modifier ta tha \s-1REGEXP,\s0 cuz fieldz is case insensitive.
.Sp
See also \fIremoveField()\fR which is used ta remove one field object from
the header n' shit.  Da reverse justification can be made with
\&\f(CW\*(C`removeFieldsExcept()\*(C'\fR.
.Sp
example:
.Sp
.Vb 2
\& $head\->removeFields(\*(Aqbcc\*(Aq, \*(Aqreceived\*(Aq);
\& $head\->removeFields( qr/^content\-/i );
.Ve
.ie n .IP "$obj\->\fBremoveFieldsExcept\fR(STRING|REGEXP, [STRING|REGEXP, ...])" 4
.el .IP "\f(CW$obj\fR\->\fBremoveFieldsExcept\fR(STRING|REGEXP, [STRING|REGEXP, ...])" 4
.IX Item "$obj->removeFieldsExcept(STRING|REGEXP, [STRING|REGEXP, ...])"
Remove all fieldz from tha header which is not equivalent ta one of the
specified STRINGs (case-insensitive) n' which is not matchin one of
the REGular EXPressions.  Do not forget ta add tha 'i' modifier ta the
\&\s-1REGEXP,\s0 cuz fieldz is case insensitive.
.Sp
See also \fIremoveField()\fR which is used ta remove one field object from
the header n' shit.  Da reverse justification can be made wit \f(CW\*(C`removeFields()\*(C'\fR.
.Sp
example:
.Sp
.Vb 2
\& $head\->removeFieldsExcept(\*(Aqsubject\*(Aq, qr/^content\-/i ); 
\& $head\->removeFieldsExcept( qw/subject ta from sender cc/ );
.Ve
.ie n .IP "$obj\->\fBremoveListGroup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBremoveListGroup\fR()" 4
.IX Item "$obj->removeListGroup()"
Removes all header lines which is used ta administa mailin lists.
Which fieldz dat is is explained up in Mail::Message::Head::ListGroup.
Returned is tha number of removed lines.
.ie n .IP "$obj\->\fBremoveResentGroups\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBremoveResentGroups\fR()" 4
.IX Item "$obj->removeResentGroups()"
Removes all header lines which is gangmember of a \fIresent group\fR, which
are explained up in Mail::Message::Head::ResentGroup.  Returned is the
number of removed lines.
.Sp
For removin single crews (for instizzle cuz you wanna keep the
last), use \fIMail::Message::Head::FieldGroup::delete()\fR.
.ie n .IP "$obj\->\fBremoveSpamGroups\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBremoveSpamGroups\fR()" 4
.IX Item "$obj->removeSpamGroups()"
Removes all header lines which was produced by spam detection and
spam-fightin software.  Which fieldz dat is is explained in
Mail::Message::Head::SpamGroup.  Returned is tha number of removed lines.
.ie n .IP "$obj\->\fBresentGroups\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBresentGroups\fR()" 4
.IX Item "$obj->resentGroups()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBreset\fR(\s-1NAME, FIELDS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBreset\fR(\s-1NAME, FIELDS\s0)" 4
.IX Item "$obj->reset(NAME, FIELDS)"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBset\fR(\s-1FIELD\s0 | \s-1LINE\s0 | (\s-1NAME, BODY\s0 [,ATTRS]))" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1FIELD\s0 | \s-1LINE\s0 | (\s-1NAME, BODY\s0 [,ATTRS]))" 4
.IX Item "$obj->set(FIELD | LINE | (NAME, BODY [,ATTRS]))"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBspamDetected\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBspamDetected\fR()" 4
.IX Item "$obj->spamDetected()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBspamGroups\fR([\s-1NAMES\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBspamGroups\fR([\s-1NAMES\s0])" 4
.IX Item "$obj->spamGroups([NAMES])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBstring\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstring\fR()" 4
.IX Item "$obj->string()"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBstudy\fR(\s-1NAME\s0 [,INDEX])" 4
.el .IP "\f(CW$obj\fR\->\fBstudy\fR(\s-1NAME\s0 [,INDEX])" 4
.IX Item "$obj->study(NAME [,INDEX])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head
.SS "Bout tha body"
.IX Subsection "Bout tha body"
.ie n .IP "$obj\->\fBguessBodySize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBguessBodySize\fR()" 4
.IX Item "$obj->guessBodySize()"
See \*(L"Bout tha body\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBguessTimeStamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBguessTimeStamp\fR()" 4
.IX Item "$obj->guessTimeStamp()"
See \*(L"Bout tha body\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBisMultipart\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisMultipart\fR()" 4
.IX Item "$obj->isMultipart()"
See \*(L"Bout tha body\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBrecvstamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBrecvstamp\fR()" 4
.IX Item "$obj->recvstamp()"
See \*(L"Bout tha body\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBtimestamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtimestamp\fR()" 4
.IX Item "$obj->timestamp()"
See \*(L"Bout tha body\*(R" up in Mail::Message::Head::Complete
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBaddNoRealize\fR(\s-1FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddNoRealize\fR(\s-1FIELD\s0)" 4
.IX Item "$obj->addNoRealize(FIELD)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBaddOrderedFields\fR(\s-1FIELDS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddOrderedFields\fR(\s-1FIELDS\s0)" 4
.IX Item "$obj->addOrderedFields(FIELDS)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBcreateFromLine\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcreateFromLine\fR()" 4
.IX Item "$obj->createFromLine()"
See \*(L"Internals\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBcreateMessageId\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcreateMessageId\fR()" 4
.IX Item "$obj->createMessageId()"
See \*(L"Internals\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBfileLocation\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfileLocation\fR()" 4
.IX Item "$obj->fileLocation()"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBload\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBload\fR()" 4
.IX Item "$obj->load()"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBmessageIdPrefix\fR([\s-1PREFIX,\s0 [\s-1HOSTNAME\s0]|CODE])" 4
.el .IP "\f(CW$obj\fR\->\fBmessageIdPrefix\fR([\s-1PREFIX,\s0 [\s-1HOSTNAME\s0]|CODE])" 4
.IX Item "$obj->messageIdPrefix([PREFIX, [HOSTNAME]|CODE])"
.PD 0
.IP "Mail::Message::Head::Partial\->\fBmessageIdPrefix\fR([\s-1PREFIX,\s0 [\s-1HOSTNAME\s0]|CODE])" 4
.IX Item "Mail::Message::Head::Partial->messageIdPrefix([PREFIX, [HOSTNAME]|CODE])"
.PD
See \*(L"Internals\*(R" up in Mail::Message::Head::Complete
.ie n .IP "$obj\->\fBmoveLocation\fR(\s-1DISTANCE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBmoveLocation\fR(\s-1DISTANCE\s0)" 4
.IX Item "$obj->moveLocation(DISTANCE)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBread\fR(\s-1PARSER\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR(\s-1PARSER\s0)" 4
.IX Item "$obj->read(PARSER)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBsetNoRealize\fR(\s-1FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBsetNoRealize\fR(\s-1FIELD\s0)" 4
.IX Item "$obj->setNoRealize(FIELD)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Message::Head::Partial\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Message::Head::Partial->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Message::Head::Partial\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Message::Head::Partial->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Message::Head::Partial\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Message::Head::Partial->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Ordered header fields"
.IX Subsection "Ordered header fields"
.SS "Head class implementation"
.IX Subsection "Head class implementation"
.SS "Subsetz of header fields"
.IX Subsection "Subsetz of header fields"
.SS "Reducin tha header size"
.IX Subsection "Reducin tha header size"
A message header is straight-up big-ass up in memory n' like big-ass on disk, and
therefore a phat muthafucka fo' size reduction. I aint talkin' bout chicken n' gravy biatch.  One way ta reduce the
size is by simply eliminatin superfluous header fields.  Each field
requires at least 100 bytez of run-time memory, so dis may help!
.PP
Before you start playin round wit \fIremoveFields()\fR and
\&\fIremoveFieldsExcept()\fR, you may take a peep two big-ass groups
of fieldz which can be removes as sets: tha resent headaz n' the
mailinglist headers.
.PP
Resent headaz describe tha intermediate steps up in tha transmission
process fo' tha lyrics.  Afta successful delivery, they is rarely
useful.
.PP
When yo ass be archivin a mailinglist, it is hardly eva useful to
store a tha list administration lines fo' each message as well.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Warning: Cannot remove field $name from header: not found." 4
.el .IP "Warning: Cannot remove field \f(CW$name\fR from header: not found." 4
.IX Item "Warning: Cannot remove field $name from header: not found."
Yo ass ask ta remove a gangbangin' field which aint known up in tha header n' shit.  Using
\&\fIdelete()\fR, \fIreset()\fR, or \fIset()\fR ta do tha thang aint gonna result
in warnings: dem methodz check tha existence of tha field first.
.IP "Warning: Field objects have a implied name ($name)" 4
.IX Item "Warning: Field objects have a implied name ($name)"
.PD 0
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
.PD
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
