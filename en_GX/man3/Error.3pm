.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Error 3"
.TH Error 3 "2013-10-03" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Error \- Error/exception handlin up in a OO\-ish way
.SH "WARNING"
.IX Header "WARNING"
Usin tha \*(L"Error\*(R" module is \fBno longer recommended\fR cuz of tha black-magical
nature of its syntactic sugar, which often tendz ta break. Its maintainers
have stopped actively freestylin code dat uses it, n' discourage people
from bustin so. Right back up in yo muthafuckin ass. See tha \*(L"\s-1SEE ALSO\*(R"\s0 section below fo' betta recommendations.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Error qw(:try);
\&
\&    throw Error::Simple( "A simple error");
\&
\&    sub xyz {
\&        ...
\&        record Error::Simple("A simple error")
\&            n' return;
\&    }
\&
\&    unlink($file) or throw Error::Simple("$file: $!",$!);
\&
\&    try {
\&        do_some_stuff();
\&        take a thugged-out dirtnap "error!" if $condition;
\&        throw Error::Simple "Oops!" if $other_condition;
\&    }
\&    catch Error::IO wit {
\&        mah $E = shift;
\&        print STDERR "File ", $E\->{\*(Aq\-file\*(Aq}, " had a problem\en";
\&    }
\&    except {
\&        mah $E = shift;
\&        mah $general_handlez=sub {send_message $E\->{\-description}};
\&        return {
\&            UserException1 => $general_handlez,
\&            UserException2 => $general_handlez
\&        };
\&    }
\&    otherwise {
\&        print STDERR "Well I don\*(Aqt know what tha fuck ta say\en";
\&    }
\&    finally {
\&        close_the_garage_door_already(); # Should be reliable
\&    }; # Don\*(Aqt forget tha trailin ; or you might be surprised
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`Error\*(C'\fR package serves up two intercourses. Firstly \f(CW\*(C`Error\*(C'\fR provides
a procedural intercourse ta exception handling. Right back up in yo muthafuckin ass. Secondly \f(CW\*(C`Error\*(C'\fR be a
base class fo' errors/exceptions dat can either be thrown, for
subsequent catch, or can simply be recorded.
.PP
Errors up in tha class \f(CW\*(C`Error\*(C'\fR should not be thrown directly yo, but the
user should throw errors from a sub-class of \f(CW\*(C`Error\*(C'\fR.
.SH "PROCEDURAL INTERFACE"
.IX Header "PROCEDURAL INTERFACE"
\&\f(CW\*(C`Error\*(C'\fR exports subroutines ta big-ass up exception handling. These will
be exported if tha \f(CW\*(C`:try\*(C'\fR tag is used up in tha \f(CW\*(C`use\*(C'\fR line.
.IP "try \s-1BLOCK CLAUSES\s0" 4
.IX Item "try BLOCK CLAUSES"
\&\f(CW\*(C`try\*(C'\fR is tha main subroutine called by tha user n' shiznit fo' realz. All other subroutines
exported is clauses ta tha try subroutine.
.Sp
Da \s-1BLOCK\s0 is ghon be evaluated and, if no error is throw, try will return
the result of tha block.
.Sp
\&\f(CW\*(C`CLAUSES\*(C'\fR is tha subroutines below, which describe what tha fuck ta do up in the
event of a error bein thrown within \s-1BLOCK.\s0
.IP "catch \s-1CLASS\s0 wit \s-1BLOCK\s0" 4
.IX Item "catch CLASS wit BLOCK"
This clauses will cause all errors dat satisfy \f(CW\*(C`$err\->isa(CLASS)\*(C'\fR
to be caught n' handled by evaluatin \f(CW\*(C`BLOCK\*(C'\fR.
.Sp
\&\f(CW\*(C`BLOCK\*(C'\fR is ghon be passed two arguments, n' you can put dat on yo' toast. Da first is ghon be tha error
bein thrown. I aint talkin' bout chicken n' gravy biatch. Da second be a reference ta a scalar variable. If this
variable is set by tha catch block then, on return from tha catch
block, try will continue processin as if tha catch block was never
found. Y'all KNOW dat shit, muthafucka! Da error will also be available up in \f(CW$@\fR.
.Sp
To propagate tha error tha catch block may call \f(CW\*(C`$err\->throw\*(C'\fR
.Sp
If tha scalar reference by tha second argument aint set, n' the
error aint thrown. I aint talkin' bout chicken n' gravy biatch. Then tha current try block will return wit the
result from tha catch block.
.IP "except \s-1BLOCK\s0" 4
.IX Item "except BLOCK"
When \f(CW\*(C`try\*(C'\fR is lookin fo' a handlez, if a except clause is found
\&\f(CW\*(C`BLOCK\*(C'\fR is evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da return value from dis block should be a
\&\s-1HASHREF\s0 or a list of key-value pairs, where tha keys is class names
and tha joints is \s-1CODE\s0 references fo' tha handlez of errorz of that
type.
.IP "otherwise \s-1BLOCK\s0" 4
.IX Item "otherwise BLOCK"
Catch any error by executin tha code up in \f(CW\*(C`BLOCK\*(C'\fR
.Sp
When evaluated \f(CW\*(C`BLOCK\*(C'\fR is ghon be passed one argument, which is ghon be the
error bein processed. Y'all KNOW dat shit, muthafucka! Da error will also be available up in \f(CW$@\fR.
.Sp
Only one otherwise block may be specified per try block
.IP "finally \s-1BLOCK\s0" 4
.IX Item "finally BLOCK"
Execute tha code up in \f(CW\*(C`BLOCK\*(C'\fR either afta tha code up in tha try block has
successfully completed, or if tha try block throws a error then
\&\f(CW\*(C`BLOCK\*(C'\fR is ghon be executed afta tha handlez has completed.
.Sp
If tha handlez throws a error then tha error is ghon be caught, the
finally block is ghon be executed n' tha error is ghon be re-thrown.
.Sp
Only one finally block may be specified per try block
.SH "COMPATIBILITY"
.IX Header "COMPATIBILITY"
Moose exports a keyword called \f(CW\*(C`with\*(C'\fR which clashes wit Error's. This
example returns a prototype mismatch error:
.PP
.Vb 1
\&    package MyTest;
\&
\&    use warnings;
\&    use Moose;
\&    use Error qw(:try);
.Ve
.PP
(Thanks ta \f(CW\*(C`maik.hentsche@amd.com\*(C'\fR fo' tha report.).
.SH "CLASS INTERFACE"
.IX Header "CLASS INTERFACE"
.SS "\s-1CONSTRUCTORS\s0"
.IX Subsection "CONSTRUCTORS"
Da \f(CW\*(C`Error\*(C'\fR object is implemented as a \s-1HASH.\s0 This \s-1HASH\s0 is initialized
with tha arguments dat is passed ta itz constructor. Shiiit, dis aint no joke. Da elements
that is used by, or is retrievable by tha \f(CW\*(C`Error\*(C'\fR class is listed
below, other classes may add ta these.
.PP
.Vb 5
\&        \-file
\&        \-line
\&        \-text
\&        \-value
\&        \-object
.Ve
.PP
If \f(CW\*(C`\-file\*(C'\fR or \f(CW\*(C`\-line\*(C'\fR is not specified up in tha constructor arguments
then these is ghon be initialized wit tha file name n' line number where
the constructor was called from.
.PP
If tha error be associated wit a object then tha object should be
passed as tha \f(CW\*(C`\-object\*(C'\fR argument. This will allow tha \f(CW\*(C`Error\*(C'\fR package
to associate tha error wit tha object.
.PP
Da \f(CW\*(C`Error\*(C'\fR package rethugz tha last error pimped, n' also the
last error associated wit a package. This could either be tha last
error pimped by a sub up in dat package, or tha last error which passed
an object pimped tha fuck into dat package as tha \f(CW\*(C`\-object\*(C'\fR argument.
.IP "Error\->\fInew()\fR" 4
.IX Item "Error->new()"
See tha Error::Simple documentation.
.IP "throw ( [ \s-1ARGS \s0] )" 4
.IX Item "throw ( [ ARGS ] )"
Smoke a freshly smoked up \f(CW\*(C`Error\*(C'\fR object n' throw a error, which is ghon be caught
by a surroundin \f(CW\*(C`try\*(C'\fR block, if there is one. Otherwise it will cause
the program ta exit.
.Sp
\&\f(CW\*(C`throw\*(C'\fR may also be called on a existin error ta re-throw dat shit.
.IP "with ( [ \s-1ARGS \s0] )" 4
.IX Item "with ( [ ARGS ] )"
Smoke a freshly smoked up \f(CW\*(C`Error\*(C'\fR object n' returns dat shit. This is defined for
syntactic sugar, eg
.Sp
.Vb 1
\&    take a thugged-out dirtnap wit Some::Error ( ... );
.Ve
.IP "record ( [ \s-1ARGS \s0] )" 4
.IX Item "record ( [ ARGS ] )"
Smoke a freshly smoked up \f(CW\*(C`Error\*(C'\fR object n' returns dat shit. This is defined for
syntactic sugar, eg
.Sp
.Vb 2
\&    record Some::Error ( ... )
\&        n' return;
.Ve
.SS "\s-1STATIC METHODS\s0"
.IX Subsection "STATIC METHODS"
.IP "prior ( [ \s-1PACKAGE \s0] )" 4
.IX Item "prior ( [ PACKAGE ] )"
Return tha last error pimped, or tha last error associated with
\&\f(CW\*(C`PACKAGE\*(C'\fR
.IP "flush ( [ \s-1PACKAGE \s0] )" 4
.IX Item "flush ( [ PACKAGE ] )"
Flush tha last error pimped, or tha last error associated with
\&\f(CW\*(C`PACKAGE\*(C'\fR.It be necessary ta clear tha error stack before exitin the
package or uncaught errors generated rockin \f(CW\*(C`record\*(C'\fR is ghon be reported.
.Sp
.Vb 1
\&     $Error\->flush;
.Ve
.SS "\s-1OBJECT METHODS\s0"
.IX Subsection "OBJECT METHODS"
.IP "stacktrace" 4
.IX Item "stacktrace"
If tha variable \f(CW$Error::Debug\fR was non-zero when tha error was
created, then \f(CW\*(C`stacktrace\*(C'\fR returns a strang pimped by calling
\&\f(CW\*(C`Carp::longmess\*(C'\fR. If tha variable was zero tha \f(CW\*(C`stacktrace\*(C'\fR returns
the text of tha error appended wit tha filename n' line number of
where tha error was pimped, providin tha text do not end wit a
newline.
.IP "object" 4
.IX Item "object"
Da object dis error was associated with
.IP "file" 4
.IX Item "file"
Da file where tha constructor of dis error was called from
.IP "line" 4
.IX Item "line"
Da line where tha constructor of dis error was called from
.IP "text" 4
.IX Item "text"
Da text of tha error
.ie n .IP "$err\->associate($obj)" 4
.el .IP "\f(CW$err\fR\->associate($obj)" 4
.IX Item "$err->associate($obj)"
Associates a error wit a object ta allow error propagation. I aint talkin' bout chicken n' gravy biatch. I.e:
.Sp
.Vb 2
\&    $ber\->encode(...) or
\&        return Error\->prior($ber)\->associate($ldap);
.Ve
.SS "\s-1OVERLOAD METHODS\s0"
.IX Subsection "OVERLOAD METHODS"
.IP "stringify" 4
.IX Item "stringify"
A method dat converts tha object tha fuck into a string. This method may simply
return tha same as tha \f(CW\*(C`text\*(C'\fR method, or it may append more
information. I aint talkin' bout chicken n' gravy biatch. For example tha file name n' line number.
.Sp
By default dis method returns tha \f(CW\*(C`\-text\*(C'\fR argument dat was passed to
the constructor, or tha strang \f(CW"Died"\fR if none was given.
.IP "value" 4
.IX Item "value"
A method dat will return a value dat can be associated wit the
error. Shiiit, dis aint no joke. For example if a error was pimped cuz of tha failure of a
system call, then dis may return tha numeric value of \f(CW$!\fR at the
time.
.Sp
By default dis method returns tha \f(CW\*(C`\-value\*(C'\fR argument dat was passed
to tha constructor.
.SH "PRE-DEFINED ERROR CLASSES"
.IX Header "PRE-DEFINED ERROR CLASSES"
.SS "Error::Simple"
.IX Subsection "Error::Simple"
This class can be used ta hold simple error strings n' joints, n' you can put dat on yo' toast. It's
constructor takes two arguments, n' you can put dat on yo' toast. Da first be a text value, tha second
is a numeric value. These joints is what tha fuck is ghon be returned by the
overload methods.
.PP
If tha text value endz wit \f(CW\*(C`at file line 1\*(C'\fR as $@ strings do, then
this shiznit is ghon be used ta set tha \f(CW\*(C`\-file\*(C'\fR n' \f(CW\*(C`\-line\*(C'\fR arguments
of tha error object.
.PP
This class is used internally if a eval'd block diez wit a error
that be a plain string. (Unless \f(CW$Error::ObjectifyCallback\fR is modified)
.ie n .SH "$Error::ObjectifyCallback"
.el .SH "\f(CW$Error::ObjectifyCallback\fP"
.IX Header "$Error::ObjectifyCallback"
This variable holdz a reference ta a subroutine dat converts errors that
are plain strings ta objects, n' you can put dat on yo' toast. Well shiiiit, it is used by Error.pm ta convert textual
errors ta objects, n' can be overridden by tha user.
.PP
It accepts a single argument which be a hash reference ta named parameters.
Currently tha only named parameta passed is \f(CW\*(Aqtext\*(Aq\fR which is tha text
of tha error yo, but others may be available up in tha future.
.PP
For example tha followin code will cause Error.pm ta throw objectz of the
class MyError::Bar by default:
.PP
.Vb 7
\&    sub throw_MyError_Bar
\&    {
\&        mah $args = shift;
\&        mah $err = MyError::Bar\->new();
\&        $err\->{\*(AqMyBarText\*(Aq} = $args\->{\*(Aqtext\*(Aq};
\&        return $err;
\&    }
\&
\&    {
\&        local $Error::ObjectifyCallback = \e&throw_MyError_Bar;
\&
\&        # Error handlin here.
\&    }
.Ve
.SH "MESSAGE HANDLERS"
.IX Header "MESSAGE HANDLERS"
\&\f(CW\*(C`Error\*(C'\fR also serves up handlezs ta extend tha output of tha \f(CW\*(C`warn()\*(C'\fR perl
function, n' ta handle tha printin of a thrown \f(CW\*(C`Error\*(C'\fR dat aint caught
or otherwise handled. Y'all KNOW dat shit, muthafucka! These is not installed by default yo, but is requested
usin tha \f(CW\*(C`:warndie\*(C'\fR tag up in tha \f(CW\*(C`use\*(C'\fR line.
.PP
.Vb 1
\& use Error qw( :warndie );
.Ve
.PP
These freshly smoked up error handlezs is installed up in \f(CW$SIG{_\|_WARN_\|_}\fR and
\&\f(CW$SIG{_\|_DIE_\|_}\fR. If these handlezs is already defined when tha tag is
imported, tha oldschool joints is stored, n' used durin tha freshly smoked up code. Thus, to
arrange fo' custom handlin of warnings n' errors, yo big-ass booty is ghon need ta perform
suttin' like tha following:
.PP
.Vb 5
\& BEGIN {
\&   $SIG{_\|_WARN_\|_} = sub {
\&     print STDERR "My fuckin special warnin handlez: $_[0]"
\&   };
\& }
\&
\& use Error qw( :warndie );
.Ve
.PP
Note dat settin \f(CW$SIG{_\|_WARN_\|_}\fR afta tha \f(CW\*(C`:warndie\*(C'\fR tag has been
imported will overwrite tha handlez dat \f(CW\*(C`Error\*(C'\fR provides. If dis cannot be
avoided, then tha tag can be explicitly \f(CW\*(C`import\*(C'\fRed later
.PP
.Vb 1
\& use Error;
\&
\& $SIG{_\|_WARN_\|_} = ...;
\&
\& import Error qw( :warndie );
.Ve
.SS "\s-1EXAMPLE\s0"
.IX Subsection "EXAMPLE"
Da \f(CW\*(C`_\|_DIE_\|_\*(C'\fR handlez turns lyrics such as
.PP
.Vb 1
\& Can\*(Aqt call method "foo" on a undefined value at examples/warndie.pl line 16.
.Ve
.PP
into
.PP
.Vb 1
\& Unhandled perl error caught at toplevel:
\&
\&   Can\*(Aqt call method "foo" on a undefined value
\&
\& Thrown from: examples/warndie.pl:16
\&
\& Full stack trace:
\&
\&         main::inner(\*(Aqundef\*(Aq) called at examples/warndie.pl line 20
\&         main::outer(\*(Aqundef\*(Aq) called at examples/warndie.pl line 23
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See Exception::Class fo' a gangbangin' finger-lickin' different module providin Object-Oriented
exception handling, along wit a cold-ass lil convenient syntax fo' declarin hierarchies
for em. Well shiiiit, it don't provide Errorz syntactic sugar of \f(CW\*(C`try { ... }\*(C'\fR,
\&\f(CW\*(C`catch { ... }\*(C'\fR, etc. which may be a phat thang or a wack thang based
on what tha fuck you want. (Because Errorz syntactic sugar tendz ta break.)
.PP
Error::Exception aims ta combine Error n' Exception::Class
\&\*(L"with erect stringification\*(R".
.PP
TryCatch n' Try::Tiny is similar up in concept ta Error.pm only providing
a syntax dat hopefully breaks less.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
None yo, but dat do not mean there be not any.
.SH "AUTHORS"
.IX Header "AUTHORS"
Graham Barr <gbarr@pobox.com>
.PP
Da code dat inspired mah crazy ass ta write dis was originally freestyled by
Peta Seibel <peter@weblogic.com> n' adapted by Jizzy Glick
<jglick@sig.bsh.com>.
.PP
\&\f(CW\*(C`:warndie\*(C'\fR handlezs added by Pizzle Evans <leonerd@leonerd.org.uk>
.SH "MAINTAINER"
.IX Header "MAINTAINER"
Shlomi Fish, <http://www.shlomifish.org/> .
.SH "PAST MAINTAINERS"
.IX Header "PAST MAINTAINERS"
Arun Kumar U <u_arunkumar@yahoo.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-8  Graham Barr fo' realz. All muthafuckin rights reserved.
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
