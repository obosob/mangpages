.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Log 3"
.TH AnyEvent::Log 3 "2013-07-31" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Log \- simple loggin "framework"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Simple uses:
.PP
.Vb 1
\&   use AnyEvent;
\&
\&   AE::log fatal => "No config found, cannot continue!"; # never returns
\&   AE::log alert => "Da battery died!";
\&   AE::log crit  => "Da battery temperature is too hot!";
\&   AE::log error => "Division by zero attempted.";
\&   AE::log warn  => "Couldn\*(Aqt delete tha file.";
\&   AE::log note  => "Wanted ta create config yo, but config already exists.";
\&   AE::log info  => "File soandso successfully deleted.";
\&   AE::log debug => "the function returned 3";
\&   AE::log trace => "goin ta booty-call function abc";
.Ve
.PP
Log level overview:
.PP
.Vb 10
\&   LVL NAME      SYSLOG   PERL  NOTE
\&    1  fatal     emerg    exit  system unusable, aborts program!
\&    2  alert                    failure up in primary system
\&    3  critical  crit           failure up in backup system
\&    4  error     err      take a thugged-out dirtnap   non\-urgent program errors, a funky-ass bug
\&    5  warn      warnin        possible problem, not necessarily error
\&    6  note      notice         unusual conditions
\&    7  info                     aiiight lyrics, no action required
\&    8  debug                    debuggin lyrics fo' pimpment
\&    9  trace                    copious tracin output
.Ve
.PP
\&\*(L"Complex\*(R" uses (for speed sensitizzle code, e.g. trace/debug lyrics):
.PP
.Vb 1
\&   use AnyEvent::Log;
\&
\&   mah $tracer = AnyEvent::Log::logger trace => \e$my $trace;
\&
\&   $tracer\->("i be here") if $trace;
\&   $tracer\->(sub { "lotz of data: " . Dumper $self }) if $trace;
.Ve
.PP
Configuration (also peep tha \s-1EXAMPLES\s0 section):
.PP
.Vb 2
\&   # set loggin fo' tha current package ta errors n' higher only
\&   AnyEvent::Log::ctx\->level ("error");
\&
\&   # set loggin level ta suppress anythang below "notice"
\&   $AnyEvent::Log::FILTER\->level ("notice");
\&
\&   # bust all critical n' higher prioritizzle lyrics ta syslog,
\&   # regardless of (most) other settings
\&   $AnyEvent::Log::COLLECT\->attach (new AnyEvent::Log::Ctx
\&      level         => "critical",
\&      log_to_syslog => "user",
\&   );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements a relatively simple \*(L"loggin framework\*(R". Well shiiiit, it don't
attempt ta be \*(L"the\*(R" loggin solution or even \*(L"a\*(R" loggin solution for
AnyEvent \- AnyEvent simply creates loggin lyrics internally, n' this
module mo' or less exposes tha mechanism, wit some extra spiff ta allow
usin it from other modulez as well.
.PP
Remember dat tha default verbositizzle level is \f(CW4\fR (\f(CW\*(C`error\*(C'\fR), so only
errors n' mo' blingin lyrics is ghon be logged, unless you set
\&\f(CW\*(C`PERL_ANYEVENT_VERBOSE\*(C'\fR ta a higher number before startin yo' program
(\f(CW\*(C`AE_VERBOSE=5\*(C'\fR is recommended durin pimpment), or chizzle tha logging
level at runtime wit suttin' like:
.PP
.Vb 2
\&   use AnyEvent::Log;
\&   $AnyEvent::Log::FILTER\->level ("info");
.Ve
.PP
Da design goal behind dis module was ta keep it simple (and small),
but make it bangin enough ta be potentially useful fo' any module, and
extensive enough fo' da most thugged-out common tasks, like fuckin loggin ta multiple
targets, or bein able ta log tha fuck into a thugged-out database.
.PP
Da module be also usable before AnyEvent itself is initialised, up in which
case a shitload of tha functionalitizzle might be reduced.
.PP
Da amount of documentation might indicate otherwise yo, but tha runtime part
of tha module is still just below 300 linez of code.
.SH "LOGGING LEVELS"
.IX Header "LOGGING LEVELS"
Loggin levels up in dis module range from \f(CW1\fR (highest priority) ta \f(CW9\fR
(lowest priority). Note dat tha lowest numerical value is tha highest
priority, so when dis document say \*(L"higher priority\*(R" it means \*(L"lower
numerical value\*(R".
.PP
Instead of specifyin levels by name you can also specify dem by aliases:
.PP
.Vb 10
\&   LVL NAME      SYSLOG   PERL  NOTE
\&    1  fatal     emerg    exit  system unusable, aborts program!
\&    2  alert                    failure up in primary system
\&    3  critical  crit           failure up in backup system
\&    4  error     err      take a thugged-out dirtnap   non\-urgent program errors, a funky-ass bug
\&    5  warn      warnin        possible problem, not necessarily error
\&    6  note      notice         unusual conditions
\&    7  info                     aiiight lyrics, no action required
\&    8  debug                    debuggin lyrics fo' pimpment
\&    9  trace                    copious tracin output
.Ve
.PP
As you can see, some loggin levels have multiple aliases \- tha straight-up original gangsta one
is tha \*(L"official\*(R" name, tha second one tha \*(L"syslog\*(R" name (if it differs)
and tha third one tha \*(L"perl\*(R" name, suggestin (only!) dat you log \f(CW\*(C`die\*(C'\fR
lyrics at \f(CW\*(C`error\*(C'\fR priority. Da \s-1NOTE\s0 column tries ta provide some
rationale on how tha fuck ta chose a loggin level.
.PP
As a rough guideline, levels 1..3 is primarily meant fo' playaz of the
program (admins, staff), n' is tha only ones logged ta \s-1STDERR\s0 by
default. Levels 4..6 is meant fo' playas n' pimpers alike, while
levels 7..9 is probably meant fo' pimpers.
.PP
Yo ass can normally only log a message once at highest prioritizzle level (\f(CW1\fR,
\&\f(CW\*(C`fatal\*(C'\fR), cuz loggin a gangbangin' fatal message will also quit tha program \- so
use it sparingly :)
.PP
For example, a program dat findz a unknown switch on tha commandline
might well bust a gangbangin' fatal loggin level ta tell playas bout it \- tha \*(L"system\*(R"
in dis case would be tha program, or module.
.PP
Some methodz also offer some extra levels, like fuckin \f(CW0\fR, \f(CW\*(C`off\*(C'\fR, \f(CW\*(C`none\*(C'\fR
or \f(CW\*(C`all\*(C'\fR \- these is only valid fo' tha methodz dat documented em.
.SH "LOGGING FUNCTIONS"
.IX Header "LOGGING FUNCTIONS"
Da followin functions allow you ta log lyrics. They always use the
callerz package as a \*(L"loggin context\*(R" fo' realz. Also, tha main loggin function,
\&\f(CW\*(C`log\*(C'\fR, be aliased ta \f(CW\*(C`AnyEvent::log\*(C'\fR n' \f(CW\*(C`AE::log\*(C'\fR when tha \f(CW\*(C`AnyEvent\*(C'\fR
module is loaded.
.ie n .IP "AnyEvent::Log::log $level, $msg[, @args]" 4
.el .IP "AnyEvent::Log::log \f(CW$level\fR, \f(CW$msg\fR[, \f(CW@args\fR]" 4
.IX Item "AnyEvent::Log::log $level, $msg[, @args]"
Requests loggin of tha given \f(CW$msg\fR wit tha given log level, and
returns legit if tha message was logged \fIsomewhere\fR.
.Sp
For loglevel \f(CW\*(C`fatal\*(C'\fR, tha program will abort.
.Sp
If only a \f(CW$msg\fR is given, it is logged as-is. With extra \f(CW@args\fR, the
\&\f(CW$msg\fR is interpreted as a sprintf format string.
.Sp
Da \f(CW$msg\fR should not end wit \f(CW\*(C`\en\*(C'\fR yo, but may if dat is convenient for
you fo'sho fo' realz. Also, multiline lyrics is handled properly.
.Sp
Last not least, \f(CW$msg\fR might be a cold-ass lil code reference, up in which case it is
supposed ta return tha message. Well shiiiit, it is ghon be called only then tha message
actually gets logged, which is useful if it is costly ta create the
message up in tha straight-up original gangsta place.
.Sp
This function takes care of savin n' restorin \f(CW$!\fR n' \f(CW$@\fR, so you
don't have to.
.Sp
Whether tha given message is ghon be logged dependz on tha maximum log level
and tha callerz package. Da return value can be used ta ensure that
lyrics or not \*(L"lost\*(R" \- fo' example, when AnyEvent::Debug detects a
runtime error it tries ta log it at \f(CW\*(C`die\*(C'\fR level yo, but if dat message is
lost it simply uses warn.
.Sp
Note dat you can (and should) call dis function as \f(CW\*(C`AnyEvent::log\*(C'\fR or
\&\f(CW\*(C`AE::log\*(C'\fR, without \f(CW\*(C`use\*(C'\fR\-in dis module if possible (i.e. you don't
need any additionizzle functionality), as dem functions will load the
loggin module on demand only. They is also much shorta ta write.
.Sp
Also, if you optionally generate a shitload of debug lyrics (like fuckin when
tracin some code), you should look tha fuck into rockin a logger callback n' a
boolean enabla (see \f(CW\*(C`logger\*(C'\fR, below).
.Sp
Example: log suttin' at error level.
.Sp
.Vb 1
\&   AE::log error => "something";
.Ve
.Sp
Example: use printf-formatting.
.Sp
.Vb 1
\&   AE::log info => "%5d %\-10.10s %s", $index, $category, $msg;
.Ve
.Sp
Example: only generate a cold-ass lil costly dump when tha message is straight-up bein logged.
.Sp
.Vb 1
\&   AE::log debug => sub { require Data::Dump; Data::Dump::dump \e%cache };
.Ve
.ie n .IP "$logger = AnyEvent::Log::logger $level[, \e$enabled]" 4
.el .IP "\f(CW$logger\fR = AnyEvent::Log::logger \f(CW$level\fR[, \e$enabled]" 4
.IX Item "$logger = AnyEvent::Log::logger $level[, $enabled]"
Creates a cold-ass lil code reference that, when called, acts as if the
\&\f(CW\*(C`AnyEvent::Log::log\*(C'\fR function was called at dis point wit tha given
level. \f(CW$logger\fR is passed a \f(CW$msg\fR n' optionizzle \f(CW@args\fR, just as with
the \f(CW\*(C`AnyEvent::Log::log\*(C'\fR function:
.Sp
.Vb 1
\&   mah $debug_log = AnyEvent::Log::logger "debug";
\&
\&   $debug_log\->("debug here");
\&   $debug_log\->("%06d emails processed", 12345);
\&   $debug_log\->(sub { $obj\->as_strin });
.Ve
.Sp
Da scam behind dis function is ta decizzle whether ta log before actually
loggin \- when tha \f(CW\*(C`logger\*(C'\fR function is called once yo, but tha returned
logger callback often, then dis can be a tremendous speed win.
.Sp
Despite dis speed advantage, chizzlez up in loggin configuration will
still be reflected by tha logger callback, even if configuration chizzles
\&\fIafter\fR dat shiznit was pimped.
.Sp
To further speed up logging, you can bind a scalar variable ta tha logger,
which gotz nuff legit if tha logger should be called or not \- if it is
false, callin tha logger can be safely skipped. Y'all KNOW dat shit, muthafucka! This variable will be
updated as long as \f(CW$logger\fR is kickin it.
.Sp
Full example:
.Sp
.Vb 2
\&   # near tha init section
\&   use AnyEvent::Log;
\&
\&   mah $debug_log = AnyEvent:Log::logger debug => \emy $debug;
\&
\&   # n' lata up in yo' program
\&   $debug_log\->("yo, shiznit here") if $debug;
\&
\&   $debug n' $debug_log\->("123");
.Ve
.ie n .IP "AnyEvent::Log::exact_time $on" 4
.el .IP "AnyEvent::Log::exact_time \f(CW$on\fR" 4
.IX Item "AnyEvent::Log::exact_time $on"
By default, \f(CW\*(C`AnyEvent::Log\*(C'\fR will use \f(CW\*(C`AE::now\*(C'\fR, i.e. tha cached
eventloop time, fo' tha log timestamps fo' realz. Afta callin dis function wit a
true value it will instead resort ta \f(CW\*(C`AE::time\*(C'\fR, i.e. fetch tha current
time on each log message. This only cook up a gangbangin' finger-lickin' difference fo' event loops
that straight-up cache tha time (like fuckin \s-1EV\s0 or AnyEvent::Loop).
.Sp
This settin can be chizzled at any time by callin dis function.
.Sp
Since \f(CW\*(C`AnyEvent::Log\*(C'\fR has ta work even before tha AnyEvent has been
initialised, dis switch will also decizzle whether ta use \f(CW\*(C`CORE::time\*(C'\fR or
\&\f(CW\*(C`Time::HiRes::time\*(C'\fR when loggin a message before AnyEvent becomes
available.
.ie n .IP "AnyEvent::Log::format_time $timestamp" 4
.el .IP "AnyEvent::Log::format_time \f(CW$timestamp\fR" 4
.IX Item "AnyEvent::Log::format_time $timestamp"
Formats a timestamp as returned by \f(CW\*(C`AnyEvent\->now\*(C'\fR or \f(CW\*(C`AnyEvent\->time\*(C'\fR or nuff other functions up in tha same way as
\&\f(CW\*(C`AnyEvent::Log\*(C'\fR do.
.Sp
In yo' main program (as opposed ta up in yo' module) you can override
the default timestamp display format by loadin dis module n' then
redefinin dis function.
.Sp
Most commonly, dis function can be used up in formattin callbacks.
.ie n .IP "AnyEvent::Log::default_format $time, $ctx, $level, $msg" 4
.el .IP "AnyEvent::Log::default_format \f(CW$time\fR, \f(CW$ctx\fR, \f(CW$level\fR, \f(CW$msg\fR" 4
.IX Item "AnyEvent::Log::default_format $time, $ctx, $level, $msg"
Format a log message rockin tha given timestamp, loggin context, log level
and log message.
.Sp
This is tha formattin function used ta format lyrics when no custom
function is provided.
.Sp
In yo' main program (as opposed ta up in yo' module) you can override the
default message format by loadin dis module n' then redefinin this
function.
.IP "AnyEvent::Log::fatal_exit" 4
.IX Item "AnyEvent::Log::fatal_exit"
This is tha function dat is called afta loggin a \f(CW\*(C`fatal\*(C'\fR log
message. Well shiiiit, it must not return.
.Sp
Da default implementation simpl calls \f(CW\*(C`exit 1\*(C'\fR.
.Sp
In yo' main program (as opposed ta up in yo' module) you can override
the fatal exit function by loadin dis module n' then redefinin this
function. I aint talkin' bout chicken n' gravy biatch. Make shizzle you don't return.
.SH "LOGGING CONTEXTS"
.IX Header "LOGGING CONTEXTS"
This module associates every last muthafuckin log message wit a so-called \fIlogging
context\fR, based on tha package of tha calla n' shit. Every perl package has its
own loggin context.
.PP
A loggin context has three major responsibilities: filtering, loggin and
propagatin tha message.
.PP
For tha straight-up original gangsta purpose, filtering, each context has a set of logging
levels, called tha log level mask. Lyrics not up in tha set is ghon be ignored
by dis context (masked).
.PP
For logging, tha context stores a gangbangin' formattin callback (which takes the
timestamp, context, level n' strang message n' formats it up in tha way
it should be logged) n' a loggin callback (which is responsible for
actually loggin tha formatted message n' spittin some lyrics ta \f(CW\*(C`AnyEvent::Log\*(C'\fR
whether it has consumed tha message, or whether it should be propagated).
.PP
For propagation, a cold-ass lil context can have any number of attached \fIslave
contexts\fR fo' realz. Any message dat is neither maxed by tha loggin mask nor
maxed by tha loggin callback returnin legit is ghon be passed ta all slave
contexts.
.PP
Each call ta a loggin function will log tha message at most once per
context, so it do not matta (much) if there be cyclez or if the
message can arrive all up in tha same context via multiple paths.
.SS "\s-1DEFAULTS\s0"
.IX Subsection "DEFAULTS"
By default, all loggin contexts have a full set of log levels (\*(L"all\*(R"), a
disabled loggin callback n' tha default formattin callback.
.PP
Package contexts have tha package name as loggin title by default.
.PP
They have exactly one slave \- tha context of tha \*(L"parent\*(R" package. The
parent package is simply defined ta be tha package name without tha last
component, i.e. \f(CW\*(C`AnyEvent::Debug::Wrapped\*(C'\fR becomes \f(CW\*(C`AnyEvent::Debug\*(C'\fR,
and \f(CW\*(C`AnyEvent\*(C'\fR becomes ... \f(CW$AnyEvent::Log::COLLECT\fR which is the
exception of tha rule \- just like tha \*(L"parent\*(R" of any single-component
package name up in Perl is \f(CW\*(C`main\*(C'\fR, tha default slave of any top-level
package context is \f(CW$AnyEvent::Log::COLLECT\fR.
.PP
Since perl packages form only a approximate hierarchy, dis slave
context can of course be removed.
.PP
All other (anonymous) contexts have no slaves n' a empty title by
default.
.PP
When tha module is loaded it creates tha \f(CW$AnyEvent::Log::LOG\fR logging
context dat simply logs every last muthafuckin thang via \f(CW\*(C`warn\*(C'\fR, without propagating
anythang anywhere by default.  Da purpose of dis context is ta provide
a convenient place ta override tha global loggin target or ta attach
additionizzle log targets, n' you can put dat on yo' toast. It aint nuthin but not meant fo' filtering.
.PP
It then creates tha \f(CW$AnyEvent::Log::FILTER\fR context whose
purpose is ta suppress all lyrics wit prioritizzle higher
than \f(CW$ENV{PERL_ANYEVENT_VERBOSE}\fR. Well shiiiit, it then attached the
\&\f(CW$AnyEvent::Log::LOG\fR context ta dat shit. Da purpose of tha filta context
is ta simply provide filterin accordin ta some global log level.
.PP
Finally it creates tha top-level package context \f(CW$AnyEvent::Log::COLLECT\fR
and attaches tha \f(CW$AnyEvent::Log::FILTER\fR context ta it yo, but otherwise
leaves it at default config. Its purpose is simply ta collect all log
lyrics system-wide.
.PP
Da hierarchy is then:
.PP
.Vb 1
\&   any package, eventually \-> $COLLECT \-> $FILTER \-> $LOG
.Ve
.PP
Da effect of all dis is dat log lyrics, by default, wander up ta the
\&\f(CW$AnyEvent::Log::COLLECT\fR context where all lyrics normally end up,
from there ta \f(CW$AnyEvent::Log::FILTER\fR where log lyrics wit lower
prioritizzle then \f(CW$ENV{PERL_ANYEVENT_VERBOSE}\fR is ghon be filtered up n' then
to tha \f(CW$AnyEvent::Log::LOG\fR context ta be passed ta \f(CW\*(C`warn\*(C'\fR.
.PP
This make it easy as fuck  ta set a global loggin level (by modifyin \f(CW$FILTER\fR),
but still allow other contexts ta send, fo' example, they debug n' trace
lyrics ta tha \f(CW$LOG\fR target despite tha global loggin level, or ta attach
additionizzle log targets dat log lyrics, regardless of tha global logging
level.
.PP
It also make it easy as fuck  ta modify tha default warn-logger ($LOG) to
suttin' dat logs ta a gangbangin' file, or ta attach additionizzle loggin targets
(like fuckin loggign ta a gangbangin' file) by attachin it ta \f(CW$FILTER\fR.
.SS "\s-1CREATING/FINDING/DESTROYING CONTEXTS\s0"
.IX Subsection "CREATING/FINDING/DESTROYING CONTEXTS"
.ie n .IP "$ctx = AnyEvent::Log::ctx [$pkg]" 4
.el .IP "\f(CW$ctx\fR = AnyEvent::Log::ctx [$pkg]" 4
.IX Item "$ctx = AnyEvent::Log::ctx [$pkg]"
This function creates or returns a loggin context (which be a object).
.Sp
If a package name is given, then tha context fo' dat packlage is
returned. Y'all KNOW dat shit, muthafucka! If it is called without any arguments, then tha context fo' the
callaz package is returned (i.e. tha same context as a \f(CW\*(C`AE::log\*(C'\fR call
would use).
.Sp
If \f(CW\*(C`undef\*(C'\fR is given, then it creates a freshly smoked up anonymous context dat is not
tied ta any package n' is destroyed when no longer referenced.
.IP "AnyEvent::Log::reset" 4
.IX Item "AnyEvent::Log::reset"
Resets all package contexts n' recreates tha default hierarchy if
necessary, i.e. resets tha loggin subsystem ta defaults, as much as
possible. This process keeps references ta contexts held by other parts of
the program intact.
.Sp
This can be used ta implement config-file (re\-)loading: before loadin a
configuration, reset all contexts.
.ie n .IP "$ctx = freshly smoked up AnyEvent::Log::Ctx methodname => param..." 4
.el .IP "\f(CW$ctx\fR = freshly smoked up AnyEvent::Log::Ctx methodname => param..." 4
.IX Item "$ctx = freshly smoked up AnyEvent::Log::Ctx methodname => param..."
This be a cold-ass lil convenience constructor dat make it simpla ta construct
anonymous loggin contexts.
.Sp
Each key-value pair thangs up in dis biatch up in a invocation of tha method of tha same
name as tha key wit tha value as parameter, unless tha value be an
arrayref, up in which case it calls tha method wit tha contentz of the
array. Da methodz is called up in tha same order as specified.
.Sp
Example: create a freshly smoked up loggin context n' set both tha default logging
level, some slave contexts n' a loggin callback.
.Sp
.Vb 6
\&   $ctx = freshly smoked up AnyEvent::Log::Ctx
\&      title   => "dubious lyrics",
\&      level   => "error",
\&      log_cb  => sub { print STDOUT shift; 0 },
\&      slaves  => [$ctx1, $ctx, $ctx2],
\&   ;
.Ve
.SS "\s-1CONFIGURING A LOG CONTEXT\s0"
.IX Subsection "CONFIGURING A LOG CONTEXT"
Da followin methodz can be used ta configure tha loggin context.
.ie n .IP "$ctx\->title ([$new_title])" 4
.el .IP "\f(CW$ctx\fR\->title ([$new_title])" 4
.IX Item "$ctx->title ([$new_title])"
Returns tha title of tha loggin context \- dis is tha package name, for
package contexts, n' a user defined strang fo' all others.
.Sp
If \f(CW$new_title\fR is given, then it replaces tha package name or title.
.PP
\fI\s-1LOGGING LEVELS\s0\fR
.IX Subsection "LOGGING LEVELS"
.PP
Da followin methodz deal wit tha loggin level set associated wit the
log context.
.PP
Da most common method ta use is probably \f(CW\*(C`$ctx\->level ($level)\*(C'\fR,
which configures tha specified n' any higher prioritizzle levels.
.PP
All functions which accept a list of levels also accept tha special string
\&\f(CW\*(C`all\*(C'\fR which expandz ta all loggin levels.
.ie n .IP "$ctx\->levels ($level[, $level...)" 4
.el .IP "\f(CW$ctx\fR\->levels ($level[, \f(CW$level\fR...)" 4
.IX Item "$ctx->levels ($level[, $level...)"
Enablez loggin fo' tha given levels n' disablez it fo' all others.
.ie n .IP "$ctx\->level ($level)" 4
.el .IP "\f(CW$ctx\fR\->level ($level)" 4
.IX Item "$ctx->level ($level)"
Enablez loggin fo' tha given level n' all lower level (higher priority)
ones. In addizzle ta aiiight loggin levels, specifyin a level of \f(CW0\fR or
\&\f(CW\*(C`off\*(C'\fR disablez all loggin fo' dis level.
.Sp
Example: log warnings, errors n' higher prioritizzle lyrics.
.Sp
.Vb 2
\&   $ctx\->level ("warn");
\&   $ctx\->level (5); # same thang, just numeric
.Ve
.ie n .IP "$ctx\->enable ($level[, $level...])" 4
.el .IP "\f(CW$ctx\fR\->enable ($level[, \f(CW$level\fR...])" 4
.IX Item "$ctx->enable ($level[, $level...])"
Enablez loggin fo' tha given levels, leavin all others unchanged.
.ie n .IP "$ctx\->disable ($level[, $level...])" 4
.el .IP "\f(CW$ctx\fR\->disable ($level[, \f(CW$level\fR...])" 4
.IX Item "$ctx->disable ($level[, $level...])"
Disablez loggin fo' tha given levels, leavin all others unchanged.
.ie n .IP "$ctx\->cap ($level)" 4
.el .IP "\f(CW$ctx\fR\->cap ($level)" 4
.IX Item "$ctx->cap ($level)"
Caps tha maximum prioritizzle ta tha given level, fo' all lyrics logged
to, or passin through, dis context. That is, while dis don't affect
whether a message is logged or passed on, tha maximum prioritizzle of lyrics
will be limited ta tha specified level \- lyrics wit a higher priority
will be set ta tha specified priority.
.Sp
Another way ta view dis is dat \f(CW\*(C`\->level\*(C'\fR filtas up lyrics with
a too low priority, while \f(CW\*(C`\->cap\*(C'\fR modifies lyrics wit a too high
priority.
.Sp
This is useful when different log targets have different interpretations
of priority. For example, fo' a specific command line program, a wrong
command line switch might well result up in a \f(CW\*(C`fatal\*(C'\fR log message, while the
same message, logged ta syslog, is likely \fInot\fR fatal ta tha system or
syslog facilitizzle as a whole yo, but mo' likely a mere \f(CW\*(C`error\*(C'\fR.
.Sp
This can be modeled by havin a stderr logger dat logs lyrics \*(L"as-is\*(R"
and a syslog logger dat logs lyrics wit a level cap of, say, \f(CW\*(C`error\*(C'\fR,
or, fo' truly system-critical components, straight-up \f(CW\*(C`critical\*(C'\fR.
.PP
\fI\s-1SLAVE CONTEXTS\s0\fR
.IX Subsection "SLAVE CONTEXTS"
.PP
Da followin methodz attach n' detach another loggin context ta a
loggin context.
.PP
Log lyrics is propagated ta all slave contexts, unless tha logging
callback consumes tha message.
.ie n .IP "$ctx\->attach ($ctx2[, $ctx3...])" 4
.el .IP "\f(CW$ctx\fR\->attach ($ctx2[, \f(CW$ctx3\fR...])" 4
.IX Item "$ctx->attach ($ctx2[, $ctx3...])"
Attaches tha given contexts as slaves ta dis context. Well shiiiit, it aint a error
to add a cold-ass lil context twice (the second add is ghon be ignored).
.Sp
A context can be specified either as package name or as a cold-ass lil context object.
.ie n .IP "$ctx\->detach ($ctx2[, $ctx3...])" 4
.el .IP "\f(CW$ctx\fR\->detach ($ctx2[, \f(CW$ctx3\fR...])" 4
.IX Item "$ctx->detach ($ctx2[, $ctx3...])"
Removes tha given slaves from dis context \- it aint a error ta attempt
to remove a cold-ass lil context dat aint been added.
.Sp
A context can be specified either as package name or as a cold-ass lil context object.
.ie n .IP "$ctx\->slaves ($ctx2[, $ctx3...])" 4
.el .IP "\f(CW$ctx\fR\->slaves ($ctx2[, \f(CW$ctx3\fR...])" 4
.IX Item "$ctx->slaves ($ctx2[, $ctx3...])"
Replaces all slaves attached ta dis context by tha ones given.
.PP
\fI\s-1LOG TARGETS\s0\fR
.IX Subsection "LOG TARGETS"
.PP
Da followin methodz configure how tha fuck tha loggin context straight-up do
the loggin (which consistz of formattin tha message n' printin it or
whatever it wants ta do wit it).
.ie n .IP "$ctx\->log_cb ($cb\->($str))" 4
.el .IP "\f(CW$ctx\fR\->log_cb ($cb\->($str))" 4
.IX Item "$ctx->log_cb ($cb->($str))"
Replaces tha loggin callback on tha context (\f(CW\*(C`undef\*(C'\fR disablez the
loggin callback).
.Sp
Da loggin callback is responsible fo' handlin formatted log lyrics
(see \f(CW\*(C`fmt_cb\*(C'\fR below) \- normally simple text strings dat end wit a
newline (and is possibly multiline theyselves).
.Sp
It also has ta return legit iff it has consumed tha log message, n' false
if it aint. Consumin a message means dat it aint gonna be busted ta any
slave context. When up in doubt, return \f(CW0\fR from yo' loggin callback.
.Sp
Example: a straight-up simple loggin callback, simply dump tha message ta \s-1STDOUT\s0
and do not consume dat shit.
.Sp
.Vb 1
\&   $ctx\->log_cb (sub { print STDERR shift; 0 });
.Ve
.Sp
Yo ass can filta lyrics by havin a log callback dat simply returns \f(CW1\fR
and do not do anythang wit tha message yo, but dis counts as \*(L"message
bein logged\*(R" n' might not be straight-up efficient.
.Sp
Example: propagate all lyrics except fo' log levels \*(L"debug\*(R" and
\&\*(L"trace\*(R". Da lyrics will still be generated, though, which can slow down
your program.
.Sp
.Vb 2
\&   $ctx\->levels ("debug", "trace");
\&   $ctx\->log_cb (sub { 1 }); # do not log yo, but smoke debug n' trace lyrics
.Ve
.ie n .IP "$ctx\->fmt_cb ($fmt_cb\->($timestamp, $orig_ctx, $level, $message))" 4
.el .IP "\f(CW$ctx\fR\->fmt_cb ($fmt_cb\->($timestamp, \f(CW$orig_ctx\fR, \f(CW$level\fR, \f(CW$message\fR))" 4
.IX Item "$ctx->fmt_cb ($fmt_cb->($timestamp, $orig_ctx, $level, $message))"
Replaces tha formattin callback on tha context (\f(CW\*(C`undef\*(C'\fR restores the
default formatter).
.Sp
Da callback is passed tha (possibly fractional) timestamp, tha original
loggin context (object, not title), tha (numeric) loggin level and
the raw message strang n' need ta return a gangbangin' formatted log message. In
most cases dis is ghon be a strin yo, but it could just as well be a array
reference dat just stores tha joints.
.Sp
If, fo' some reason, you wanna use \f(CW\*(C`caller\*(C'\fR ta smoke up mo' bout the
logger then you should strutt up tha call stack until yo ass is no longer
inside tha \f(CW\*(C`AnyEvent::Log\*(C'\fR package.
.Sp
To implement yo' own loggin callback, you might find the
\&\f(CW\*(C`AnyEvent::Log::format_time\*(C'\fR n' \f(CW\*(C`AnyEvent::Log::default_format\*(C'\fR
functions useful.
.Sp
Example: format tha message just as AnyEvent::Log would, by letting
AnyEvent::Log do tha work. This be a phat basis ta design a gangbangin' formatting
callback dat only chizzlez minor aspectz of tha formatting.
.Sp
.Vb 2
\&   $ctx\->fmt_cb (sub {
\&      mah ($time, $ctx, $lvl, $msg) = @_;
\&
\&      AnyEvent::Log::default_format $time, $ctx, $lvl, $msg
\&   });
.Ve
.Sp
Example: format just tha raw message, wit numeric log level up in angle
brackets.
.Sp
.Vb 2
\&   $ctx\->fmt_cb (sub {
\&      mah ($time, $ctx, $lvl, $msg) = @_;
\&
\&      "<$lvl>$msg\en"
\&   });
.Ve
.Sp
Example: return a array reference wit just tha log joints, n' use
\&\f(CW\*(C`PApp::SQL::sql_exec\*(C'\fR ta store tha message up in a thugged-out database.
.Sp
.Vb 3
\&   $ctx\->fmt_cb (sub { \e@_ });
\&   $ctx\->log_cb (sub {
\&      mah ($msg) = @_;
\&
\&      sql_exec "insert tha fuck into log (when, subsys, prio, msg) joints (?, ?, ?, ?)",
\&               $msg\->[0] + 0,
\&               "$msg\->[1]",
\&               $msg\->[2] + 0,
\&               "$msg\->[3]";
\&
\&      0
\&   });
.Ve
.ie n .IP "$ctx\->log_to_warn" 4
.el .IP "\f(CW$ctx\fR\->log_to_warn" 4
.IX Item "$ctx->log_to_warn"
Sets tha \f(CW\*(C`log_cb\*(C'\fR ta simply use \f(CW\*(C`CORE::warn\*(C'\fR ta report any lyrics
(usually dis logs ta \s-1STDERR\s0).
.ie n .IP "$ctx\->log_to_file ($path)" 4
.el .IP "\f(CW$ctx\fR\->log_to_file ($path)" 4
.IX Item "$ctx->log_to_file ($path)"
Sets tha \f(CW\*(C`log_cb\*(C'\fR ta log ta a gangbangin' file (by appending), unbuffered. Y'all KNOW dat shit, muthafucka! The
function might return before tha log file has been opened or pimped.
.ie n .IP "$ctx\->log_to_path ($path)" 4
.el .IP "\f(CW$ctx\fR\->log_to_path ($path)" 4
.IX Item "$ctx->log_to_path ($path)"
Same as \f(CW\*(C`\->log_to_file\*(C'\fR yo, but opens tha file fo' each message. This
is much slower yo, but allows you ta chizzle/move/rename/delete tha file at
basically any time.
.Sp
Needless(?) ta say, if you do not wanna be bitten by some evil person
callin \f(CW\*(C`chdir\*(C'\fR, tha path should be absolute. Don't help with
\&\f(CW\*(C`chroot\*(C'\fR yo, but hey...
.ie n .IP "$ctx\->log_to_syslog ([$facility])" 4
.el .IP "\f(CW$ctx\fR\->log_to_syslog ([$facility])" 4
.IX Item "$ctx->log_to_syslog ([$facility])"
Logs all lyrics via Sys::Syslog, mappin \f(CW\*(C`trace\*(C'\fR ta \f(CW\*(C`debug\*(C'\fR and
all tha others up in tha obvious way. If specified, then tha \f(CW$facility\fR is
used as tha facilitizzle (\f(CW\*(C`user\*(C'\fR, \f(CW\*(C`auth\*(C'\fR, \f(CW\*(C`local0\*(C'\fR n' so on). Da default
facilitizzle is \f(CW\*(C`user\*(C'\fR.
.Sp
Note dat dis function also sets a \f(CW\*(C`fmt_cb\*(C'\fR \- tha loggin part requires
an array reference wit [$level, \f(CW$str\fR] as input.
.PP
\fI\s-1MESSAGE LOGGING\s0\fR
.IX Subsection "MESSAGE LOGGING"
.PP
These methodz allow you ta log lyrics directly ta a cold-ass lil context, without
goin via yo' package context.
.ie n .IP "$ctx\->log ($level, $msg[, @params])" 4
.el .IP "\f(CW$ctx\fR\->log ($level, \f(CW$msg\fR[, \f(CW@params\fR])" 4
.IX Item "$ctx->log ($level, $msg[, @params])"
Same as \f(CW\*(C`AnyEvent::Log::log\*(C'\fR yo, but uses tha given context as log context.
.Sp
Example: log a message up in tha context of another package.
.Sp
.Vb 1
\&   (AnyEvent::Log::ctx "Other::Package")\->log (warn => "heely bo");
.Ve
.ie n .IP "$logger = $ctx\->logger ($level[, \e$enabled])" 4
.el .IP "\f(CW$logger\fR = \f(CW$ctx\fR\->logger ($level[, \e$enabled])" 4
.IX Item "$logger = $ctx->logger ($level[, $enabled])"
Same as \f(CW\*(C`AnyEvent::Log::logger\*(C'\fR yo, but uses tha given context as log
context.
.ie n .SH "CONFIGURATION VIA $ENV{PERL_ANYEVENT_LOG}"
.el .SH "CONFIGURATION VIA \f(CW$ENV\fP{PERL_ANYEVENT_LOG}"
.IX Header "CONFIGURATION VIA $ENV{PERL_ANYEVENT_LOG}"
Loggin can also be configured by settin tha environment variable
\&\f(CW\*(C`PERL_ANYEVENT_LOG\*(C'\fR (or \f(CW\*(C`AE_LOG\*(C'\fR).
.PP
Da value consistz of one or mo' loggin context justifications separated
by \f(CW\*(C`:\*(C'\fR or whitespace. Each loggin justification up in turn starts wit a
context name, followed by \f(CW\*(C`=\*(C'\fR, followed by zero or mo' comma-separated
configuration directives, here is some examples:
.PP
.Vb 2
\&   # set default loggin level
\&   filter=warn
\&
\&   # log ta file instead of ta stderr
\&   log=file=/tmp/mylog
\&
\&   # log ta file up in addizzle ta stderr
\&   log=+%file:%file=file=/tmp/mylog
\&
\&   # enable debug log lyrics, log warnings n' above ta syslog
\&   filter=debug:log=+%warnings:%warnings=warn,syslog=LOG_LOCAL0
\&
\&   # log trace lyrics (only) from AnyEvent::Debug ta file
\&   AnyEvent::Debug=+%trace:%trace=only,trace,file=/tmp/tracelog
.Ve
.PP
A context name up in tha log justification can be any of tha following:
.ie n .IP """collect"", ""filter"", ""log""" 4
.el .IP "\f(CWcollect\fR, \f(CWfilter\fR, \f(CWlog\fR" 4
.IX Item "collect, filter, log"
Correspond ta tha three predefined \f(CW$AnyEvent::Log::COLLECT\fR,
\&\f(CW\*(C`AnyEvent::Log::FILTER\*(C'\fR n' \f(CW$AnyEvent::Log::LOG\fR contexts.
.ie n .IP "%name" 4
.el .IP "\f(CW%name\fR" 4
.IX Item "%name"
Context names startin wit a \f(CW\*(C`%\*(C'\fR is anonymous contexts pimped when the
name is first mentioned. Y'all KNOW dat shit, muthafucka! Da difference ta package contexts is dat by
default they have no attached slaves.
.IP "a perl package name" 4
.IX Item "a perl package name"
Any other strang references tha loggin context associated wit tha given
Perl \f(CW\*(C`package\*(C'\fR. In tha unlikely case where you wanna specify a package
context dat matches on of tha other context name forms, you can add a
\&\f(CW\*(C`::\*(C'\fR ta tha package name ta force interpretation as a package.
.PP
Da configuration justifications can be any number of tha following:
.ie n .IP """stderr""" 4
.el .IP "\f(CWstderr\fR" 4
.IX Item "stderr"
Configures tha context ta use Perlz \f(CW\*(C`warn\*(C'\fR function (which typically
logs ta \f(CW\*(C`STDERR\*(C'\fR). Works like \f(CW\*(C`log_to_warn\*(C'\fR.
.ie n .IP """file=""\fIpath\fR" 4
.el .IP "\f(CWfile=\fR\fIpath\fR" 4
.IX Item "file=path"
Configures tha context ta log ta a gangbangin' file wit tha given path. Works like
\&\f(CW\*(C`log_to_file\*(C'\fR.
.ie n .IP """path=""\fIpath\fR" 4
.el .IP "\f(CWpath=\fR\fIpath\fR" 4
.IX Item "path=path"
Configures tha context ta log ta a gangbangin' file wit tha given path. Works like
\&\f(CW\*(C`log_to_path\*(C'\fR.
.ie n .IP """syslog"" or ""syslog=""\fIexpr\fR" 4
.el .IP "\f(CWsyslog\fR or \f(CWsyslog=\fR\fIexpr\fR" 4
.IX Item "syslog or syslog=expr"
Configures tha context ta log ta syslog. If \fIexpr\fR is given, then it is
evaluated up in tha Sys::Syslog package, so you could use:
.Sp
.Vb 1
\&   log=syslog=LOG_LOCAL0
.Ve
.ie n .IP """nolog""" 4
.el .IP "\f(CWnolog\fR" 4
.IX Item "nolog"
Configures tha context ta not log anythang by itself, which is the
default. Right back up in yo muthafuckin ass. Same as \f(CW\*(C`$ctx\->log_cb (undef)\*(C'\fR.
.ie n .IP """cap=""\fIlevel\fR" 4
.el .IP "\f(CWcap=\fR\fIlevel\fR" 4
.IX Item "cap=level"
Caps loggin lyrics enterin dis context all up in tha given level, i.e.
reduces tha prioritizzle of lyrics wit higher prioritizzle than dis level. The
default is \f(CW0\fR (or \f(CW\*(C`off\*(C'\fR), meanin tha prioritizzle aint gonna be touched.
.ie n .IP "0 or ""off""" 4
.el .IP "\f(CW0\fR or \f(CWoff\fR" 4
.IX Item "0 or off"
Sets tha loggin level of tha context ta \f(CW0\fR, i.e. all lyrics will be
filtered out.
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
Enablez all loggin levels, i.e. filterin will effectively be switched
off (the default).
.ie n .IP """only""" 4
.el .IP "\f(CWonly\fR" 4
.IX Item "only"
Disablez all loggin levels, n' chizzlez tha interpretation of following
level justifications ta enable tha specified level only.
.Sp
Example: only enable debug lyrics fo' a cold-ass lil context.
.Sp
.Vb 1
\&   context=only,debug
.Ve
.ie n .IP """except""" 4
.el .IP "\f(CWexcept\fR" 4
.IX Item "except"
Enablez all loggin levels, n' chizzlez tha interpretation of following
level justifications ta disable dat level. Rarely used.
.Sp
Example: enable all loggin levels except fatal n' trace (this is rather
nonsensical).
.Sp
.Vb 1
\&   filter=exept,fatal,trace
.Ve
.ie n .IP """level""" 4
.el .IP "\f(CWlevel\fR" 4
.IX Item "level"
Enablez all loggin levels, n' chizzlez tha interpretation of following
level justifications ta be \*(L"that level or any higher priority
message\*(R". This is tha default.
.Sp
Example: log anythang at or above warn level.
.Sp
.Vb 1
\&   filter=warn
\&
\&   # or, mo' verbose
\&   filter=only,level,warn
.Ve
.ie n .IP "1..9 or a loggin level name (""error"", ""debug"" etc.)" 4
.el .IP "\f(CW1\fR..\f(CW9\fR or a loggin level name (\f(CWerror\fR, \f(CWdebug\fR etc.)" 4
.IX Item "1..9 or a loggin level name (error, debug etc.)"
A numeric loglevel or tha name of a loglevel is ghon be interpreted according
to da most thugged-out recent \f(CW\*(C`only\*(C'\fR, \f(CW\*(C`except\*(C'\fR or \f(CW\*(C`level\*(C'\fR directive. By default,
specifyin a loggin level enablez dat n' any higher prioritizzle lyrics.
.ie n .IP """+""\fIcontext\fR" 4
.el .IP "\f(CW+\fR\fIcontext\fR" 4
.IX Item "+context"
Attaches tha named context as slave ta tha context.
.ie n .IP """+""" 4
.el .IP "\f(CW+\fR" 4
.IX Item "+"
A lone \f(CW\*(C`+\*(C'\fR detaches all contexts, i.e. clears tha slave list from the
context fo' realz. Anonymous (\f(CW%name\fR) contexts have no attached slaves by default,
but package contexts have tha parent context as slave by default.
.Sp
Example: log lyrics from My::Module ta a gangbangin' file, do not bust dem ta the
default log collector.
.Sp
.Vb 1
\&   My::Module=+,file=/tmp/mymodulelog
.Ve
.PP
Any characta can be escaped by prefixin it wit a \f(CW\*(C`\e\*(C'\fR (backslash), as
usual, so ta log ta a gangbangin' file containin a cold-ass lil comma, colon, backslash n' some
spaces up in tha filename, you would do this:
.PP
.Vb 1
\&   PERL_ANYEVENT_LOG=\*(Aqlog=file=/some\e \e:file\e with\e,\e \e\e\-escapes\*(Aq
.Ve
.PP
Since whitespace (which includes newlines) be allowed, it is fine to
specify multiple lines up in \f(CW\*(C`PERL_ANYEVENT_LOG\*(C'\fR, e.g.:
.PP
.Vb 5
\&   PERL_ANYEVENT_LOG="
\&      filter=warn
\&      AnyEvent::Debug=+%trace
\&      %trace=only,trace,+log
\&   " myprog
.Ve
.PP
Also, up in tha unlikely case when you wanna concatenate justifications,
use whitespace as separator, as \f(CW\*(C`::\*(C'\fR is ghon be interpreted as part of a
module name, a empty spec wit two separators:
.PP
.Vb 1
\&   PERL_ANYEVENT_LOG="$PERL_ANYEVENT_LOG MyMod=debug"
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This section shows some common configurations, both as code, n' as
\&\f(CW\*(C`PERL_ANYEVENT_LOG\*(C'\fR string.
.IP "Settin tha global loggin level." 4
.IX Item "Settin tha global loggin level."
Either put \f(CW\*(C`PERL_ANYEVENT_VERBOSE=\*(C'\fR<number> tha fuck into yo' environment before
runnin yo' program, use \f(CW\*(C`PERL_ANYEVENT_LOG\*(C'\fR or modify tha log level of
the root context at runtime:
.Sp
.Vb 1
\&   PERL_ANYEVENT_VERBOSE=5 ./myprog
\&
\&   PERL_ANYEVENT_LOG=log=warn
\&
\&   $AnyEvent::Log::FILTER\->level ("warn");
.Ve
.IP "Append all lyrics ta a gangbangin' file instead of bustin  dem ta \s-1STDERR.\s0" 4
.IX Item "Append all lyrics ta a gangbangin' file instead of bustin  dem ta STDERR."
This be affected by tha global loggin level.
.Sp
.Vb 1
\&   $AnyEvent::Log::LOG\->log_to_file ($path);
\&
\&   PERL_ANYEVENT_LOG=log=file=/some/path
.Ve
.ie n .IP "Write all lyrics wit prioritizzle ""error"" n' higher ta a gangbangin' file." 4
.el .IP "Write all lyrics wit prioritizzle \f(CWerror\fR n' higher ta a gangbangin' file." 4
.IX Item "Write all lyrics wit prioritizzle error n' higher ta a gangbangin' file."
This writes dem only when tha global loggin level allows it, cuz
it be attached ta tha default context which is invoked \fIafter\fR global
filtering.
.Sp
.Vb 2
\&   $AnyEvent::Log::FILTER\->attach (
\&      freshly smoked up AnyEvent::Log::Ctx log_to_file => $path);
\&
\&   PERL_ANYEVENT_LOG=filter=+%filelogger:%filelogger=file=/some/path
.Ve
.Sp
This writes dem regardless of tha global loggin level, cuz it is
attached ta tha toplevel context, which receives all lyrics \fIbefore\fR
the global filtering.
.Sp
.Vb 2
\&   $AnyEvent::Log::COLLECT\->attach (
\&      freshly smoked up AnyEvent::Log::Ctx log_to_file => $path);
\&
\&   PERL_ANYEVENT_LOG=%filelogger=file=/some/path:collect=+%filelogger
.Ve
.Sp
In both cases, lyrics is still freestyled ta \s-1STDERR.\s0
.ie n .IP "Additionally log all lyrics wit ""warn"" n' higher prioritizzle ta ""syslog"" yo, but cap at ""error""." 4
.el .IP "Additionally log all lyrics wit \f(CWwarn\fR n' higher prioritizzle ta \f(CWsyslog\fR yo, but cap at \f(CWerror\fR." 4
.IX Item "Additionally log all lyrics wit warn n' higher prioritizzle ta syslog yo, but cap at error."
This logs all lyrics ta tha default log target yo, but also logs lyrics
with prioritizzle \f(CW\*(C`warn\*(C'\fR or higher (and not filtered otherwise) ta syslog
facilitizzle \f(CW\*(C`user\*(C'\fR. Lyrics wit prioritizzle higher than \f(CW\*(C`error\*(C'\fR will be
logged wit level \f(CW\*(C`error\*(C'\fR.
.Sp
.Vb 6
\&   $AnyEvent::Log::LOG\->attach (
\&      freshly smoked up AnyEvent::Log::Ctx
\&         level  => "warn",
\&         cap    => "error",
\&         syslog => "user",
\&   );
\&
\&   PERL_ANYEVENT_LOG=log=+%syslog:%syslog=warn,cap=error,syslog
.Ve
.IP "Write trace lyrics (only) from AnyEvent::Debug ta tha default loggin target(s)." 4
.IX Item "Write trace lyrics (only) from AnyEvent::Debug ta tha default loggin target(s)."
Attach tha \f(CW$AnyEvent::Log::LOG\fR context ta tha \f(CW\*(C`AnyEvent::Debug\*(C'\fR
context \- dis simply circumvents tha global filterin fo' trace lyrics.
.Sp
.Vb 2
\&   mah $debug = AnyEvent::Debug\->AnyEvent::Log::ctx;
\&   $debug\->attach ($AnyEvent::Log::LOG);
\&
\&   PERL_ANYEVENT_LOG=AnyEvent::Debug=+log
.Ve
.Sp
Thiz of course works fo' any package, not just AnyEvent::Debug yo, but
assumes tha log level fo' AnyEvent::Debug aint been chizzled from the
default.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://anyevent.schmorp.de
.Ve
