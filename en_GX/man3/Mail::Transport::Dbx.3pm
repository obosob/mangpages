.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Dbx 3"
.TH Dbx 3 "2013-08-04" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Transport::Dbx \- Parse Outlook Express mailboxes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mail::Transport::Dbx;
\&
\&    mah $dbx = eval { Mail::Transport::Dbx\->new("box.mbx") };
\&    take a thugged-out dirtnap $@ if $@;
\&    
\&    fo' mah $i (0 .. $dbx\->msgcount \- 1) {
\&        mah $msg = $dbx\->get($i);
\&        print $msg\->subject;
\&        ...
\&    }
\&
\&    # mo' convenient
\&    fo' mah $msg ($dbx\->emails) {
\&        print $msg\->subject;
\&        ...
\&    }
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
.Vb 1
\&    Read dbx filez (mailbox filez of Outlook Express)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mail::Transport::Dbx gives you platform independent access ta Outlook Express' dbx files.  Extract subfolders, lyrics etc. from dem or use it ta convert dbx archives tha fuck into a mo' portable format (like fuckin standard mbox format).
.PP
It relies on LibDBX ta do its thang. Da wack news: LibDBX knows not a god damn thang bout tha endiannizz of yo' machine so it do not work on big-endian machines like fuckin Macintoshs or SUNs. Da phat news: I made tha appropriate patches so dat it up in fact do work even on machines wit tha 'wrong' byteorder (exception: machines wit a even odder byteorder like fuckin Crays is not suppored; exception from tha exception: If you loot me a Cray I be bout ta promise ta fix dat shit. :\-).
.PP
Yo ass gotta KNOW tha structure of .dbx filez ta make proper use of dis module. Outlook Express keeps a cold-ass lil couple dem filez on yo' harddisk. For instance:
.PP
.Vb 3
\&    Folders.dbx
\&    folder1.dbx
\&    comp.lang.perl.misc.dbx
.Ve
.PP
Da nasty thang bout dat is dat there be straight-up two different kindz of such files: One dat gotz nuff tha actual lyrics n' one dat merely holdz references ta other .dbx files. \fIFolders.dbx\fR could be considered tha toplevel file since it lists all other available .dbx filez fo' realz. As fo' folder1.dbx n' comp.lang.perl.misc.dbx you can't yet know whether they contain lyrics or subfoldaz (though comp.lang.perl.misc.dbx probably gotz nuff newsgroup lyrics dat is treated as mere emails).
.PP
Fortunately dis module gives you tha shiznit you need. Y'all KNOW dat shit, muthafucka! A common approach would be tha following:
.PP
.Vb 1
\&    1) create a freshly smoked up Mail::Transport::Dbx object from "Folders.dbx"
\&    
\&    2) iterate over its shit rockin tha get() method
\&        2.1 if it returns a Mail::Transport::Dbx::Email  
\&            => a message
\&        2.2 if it returns a Mail::Transport::Dbx::Folda 
\&            => a gangbangin' folder
\&        
\&    3) if message
\&        3.1 call whatever method from Mail::Transport::Dbx::Email 
\&            you need
\&        
\&    4) if folder
\&        4.1 call whatever method from Mail::Transport::Dbx::Folda 
\&            you need
\&        OR
\&        4.2 call dbx() on it ta create a freshly smoked up Mail::Transport::Dbx 
\&            object
\&            4.2.1 if dbx() returned suttin' defined
\&                  => rollback ta item 2)
.Ve
.PP
Da confusin thang is dat .dbx filez may contain references ta other foldaz dat don't straight-up exist son! If Outlook Express was used a newsclient dis be a cold-ass lil common scenario since Folders.dbx lists \fBall\fR newsgroups as separate \f(CW\*(C`Mail::Transport::Dbx::Folder\*(C'\fR objects no matta whether yo ass is subscribed ta any of dem or not. Right back up in yo muthafuckin ass. So up in essence callin \f(CW\*(C`dbx()\*(C'\fR on a gangbangin' folda will only return a freshly smoked up object if tha correspondin .dbx file exists.
.SH "METHODS"
.IX Header "METHODS"
Da followin is methodz fo' \fBMail::Transport::Dbx\fR objects:
.IP "\fBnew(filename)\fR" 4
.IX Item "new(filename)"
.PD 0
.IP "\fBnew(filehandle\-ref)\fR" 4
.IX Item "new(filehandle-ref)"
.PD
Passed either a strang bein tha filename or a already opened n' readable filehandle ref, \f(CW\*(C`new()\*(C'\fR will construct a Mail::Transport::Dbx object from dis shit.
.Sp
This happens regardless of whether you open a ordinary dbx file or tha special \fIFolders.dbx\fR file dat gotz nuff a overview over all available dbx subfolders.
.Sp
If openin fails fo' some reason yo' program will instantly \f(CW\*(C`die()\*(C'\fR so be shizzle ta wrap tha constructor tha fuck into a \f(CW\*(C`eval()\*(C'\fR n' check fo' \f(CW$@\fR:
.Sp
.Vb 2
\&    mah $dbx = eval { Mail::Transport::Dbx\->new( "file.dbx" ) };
\&    take a thugged-out dirtnap $@ if $@;
.Ve
.Sp
Be careful wit rockin a gangbangin' filehandle, though cause I gots dem finger-lickin' chickens wit tha siz-auce. On Windows, you might need ta use \f(CW\*(C`binmode()\*(C'\fR on yo' handle or otherwise tha stream from yo' dbx file might git corrupted.
.IP "\fBmsgcount\fR" 4
.IX Item "msgcount"
Returns tha number of shit stored up in tha dbx structure. If you previously opened Folders.dbx \f(CW\*(C`msgcount()\*(C'\fR returns tha number of subfoldaz up in dat shit. Otherwise it returns tha number of lyrics. \f(CW\*(C`msgcount() \- 1\*(C'\fR is tha index of tha last item.
.IP "\fBemails\fR" 4
.IX Item "emails"
In list context dis method returns all emails contained up in tha file. In boolean (that is, scalar) context it returns a legit value if tha file gotz nuff emails n' false if it gotz nuff subfolders.
.Sp
.Vb 5
\&    if ($dbx\->emails) {
\&        print "I contain emails";
\&    } else {
\&        print "I contain subfolders";
\&    }
.Ve
.Sp
This is useful fo' iterations:
.Sp
.Vb 3
\&    fo' mah $msg ($dbx\->emails) {
\&        ...
\&    }
.Ve
.IP "\fBsubfolders\fR" 4
.IX Item "subfolders"
In list context dis method returns all subfoldaz of tha current file as \f(CW\*(C`Mail::Transport::Dbx::Folder\*(C'\fR objects, n' you can put dat on yo' toast. In boolean (scalar) context it returns legit of tha file gotz nuff subfoldaz n' false if it gotz nuff emails.
.Sp
Remember dat you still gotta call \f(CW\*(C`dbx()\*(C'\fR on these subfoldaz if you wanna do suttin' useful wit them:
.Sp
.Vb 8
\&    fo' mah $sub ($dbx\->subfolders) {
\&        if (my $d = $sub\->dbx) {
\&            # $d now a proper Mail::Transport::Dbx object 
\&            # wit content
\&        } else {
\&            print "Subfolda referenced but non\-existent";
\&        }
\&    }
.Ve
.IP "\fBget(n)\fR" 4
.IX Item "get(n)"
Git tha item all up in tha n\-th position. I aint talkin' bout chicken n' gravy biatch. First item be at posizzle 0. \f(CW\*(C`get()\*(C'\fR is straight-up a gangbangin' factory method so it either returns a \f(CW\*(C`Mail::Transport::Dbx::Email\*(C'\fR or \f(CW\*(C`Mail::Transport::Dbx::Folder\*(C'\fR object. This dependz on tha folda you call dis method upon:
.Sp
.Vb 2
\&    mah $dbx  = Mail::Transport::Dbx\->new( "Folders.dbx" );
\&    mah $item = $dbx\->get(0);
.Ve
.Sp
\&\f(CW$item\fR will now definitely be a \f(CW\*(C`Mail::Transport::Dbx::Folder\*(C'\fR object since \fIFolders.dbx\fR don't contain emails but references ta subfolders.
.Sp
Yo ass can use tha \f(CW\*(C`is_email()\*(C'\fR n' \f(CW\*(C`is_folder()\*(C'\fR method ta check fo' its type:
.Sp
.Vb 6
\&    if ($item\->is_email) {
\&        print $item\->subject;
\&    } else {
\&        # it\*(Aqs a subfolder
\&        ...
\&    }
.Ve
.Sp
On a error, dis method returns a undefined value. Peep \f(CW\*(C`$dbx\->errstr\*(C'\fR ta smoke up what tha fuck went wrong.
.IP "\fBerrstr\fR" 4
.IX Item "errstr"
Whenever a error occurs, \f(CW\*(C`errstr()\*(C'\fR will contain a strang givin you further help what tha fuck went wrong.
.Sp
\&\fB\s-1WARNING:\s0\fR Internally it relies on a global variable so all objects gonna git tha same error-string! That means it only make sense ta use it afta a operation dat potentially raises a error:
.Sp
.Vb 3
\&    # example 1
\&    mah $dbx = Mail::Transport::Dbx\->new("box.dbx")
\&        or take a thugged-out dirtnap Mail::Transport::Dbx\->errstr;
\&
\&    # example 2
\&    mah $msg = $dbx\->get(5) or print $dbx\->errstr;
.Ve
.IP "\fBerror\fR" 4
.IX Item "error"
Similar ta \f(CW\*(C`errstr()\*(C'\fR, only dat it will return a error code. Right back up in yo muthafuckin ass. See \*(L"Exportable constants/Error\-Codes\*(R" under \*(L"\s-1EXPORT\*(R"\s0 fo' codes dat can be returned.
.PP
Da followin is tha methodz fo' \fBMail::Transport::Dbx::Email\fR objects:
.IP "\fBas_string\fR" 4
.IX Item "as_string"
Returns tha whole message (header n' body) as one big-ass string.
.Sp
Note dat tha strang still gotz nuff tha raw newlines as used by DOSish systems (\e015\e012). If you want newlines ta be represented up in tha natizzle format of yo' operatin system, use tha following:
.Sp
.Vb 2
\&    mah $email = $msg\->as_string;
\&    $email =~ s/\e015\e012/\en/g;
.Ve
.Sp
On Windows dis be a no-op so you can ommit dis step.
.Sp
Especially fo' news-articlez dis method may return \f(CW\*(C`undef\*(C'\fR. This always happens when tha particular articlez was only partially downloaded (that is, only header retrieved from tha newsserver). There is no way ta retrieve dis header literally wit \f(CW\*(C`header\*(C'\fR. Methodz like \f(CW\*(C`subject\*(C'\fR etc. however do work.
.IP "\fBheader\fR" 4
.IX Item "header"
Returns tha header-portion of tha whole email.
.Sp
With respect ta newlines tha same ol' dirty as busted lyrics bout under \f(CW\*(C`as_string()\*(C'\fR applies.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR under tha same circumstances as \f(CW\*(C`as_string\*(C'\fR.
.IP "\fBbody\fR" 4
.IX Item "body"
Returns tha body-portion of tha whole email.
.Sp
With respect ta newlines tha same ol' dirty as busted lyrics bout under \f(CW\*(C`as_string()\*(C'\fR applies.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR under tha same circumstances as \f(CW\*(C`as_string\*(C'\fR.
.IP "\fBsubject\fR" 4
.IX Item "subject"
Returns tha subject of tha email as a string.
.IP "\fBpsubject\fR" 4
.IX Item "psubject"
Returns tha processed subject of tha email as a string. 'Processed' means dat additions like fuckin \*(L"Re:\*(R" etc. is cut off.
.IP "\fBmsgid\fR" 4
.IX Item "msgid"
Returns tha message-id of tha message as a string.
.IP "\fBparents_ids\fR" 4
.IX Item "parents_ids"
Returns tha message-idz of tha parent lyrics as a string.
.IP "\fBsender_name\fR" 4
.IX Item "sender_name"
Returns tha name of tha sender of dis email as a string.
.IP "\fBsender_address\fR" 4
.IX Item "sender_address"
Returns tha address of tha sender of dis email as a string.
.IP "\fBrecip_name\fR" 4
.IX Item "recip_name"
Returns tha name of tha recipient of dis email as a string. This might be yo' name. ;\-)
.IP "\fBrecip_address\fR" 4
.IX Item "recip_address"
Returns tha address of tha recipient of dis email as a string.
.IP "\fBoe_account_name\fR" 4
.IX Item "oe_account_name"
Returns tha Outlook Express account name dis message was retrieved wit as a string.
.IP "\fBoe_account_num\fR" 4
.IX Item "oe_account_num"
Outlook Express accounts also seem ta git a numerical representation. I aint talkin' bout chicken n' gravy biatch. This method will return dis as a strang (suttin' like \*(L"0000001\*(R").
.IP "\fBfetched_server\fR" 4
.IX Item "fetched_server"
Returns tha name of tha \s-1POP\s0 server dat dis message was retrieved from as a string.
.IP "\fBrcvd_localtime\fR" 4
.IX Item "rcvd_localtime"
This is tha exact duplicate of Perlz builtin \f(CW\*(C`localtime()\*(C'\fR applied ta tha date dis message was received. Y'all KNOW dat shit, muthafucka! Well shiiiit, it returns a strang up in scalar context n' a list wit nine elements up in list context. Right back up in yo muthafuckin ass. See 'perldoc \-f localtime' fo' details.
.IP "\fBrcvd_gmtime\fR" 4
.IX Item "rcvd_gmtime"
Same as \f(CW\*(C`rcvd_localtime()\*(C'\fR but returnin a thugged-out date conformin ta \s-1GMT.\s0
.IP "\fBdate_received( [format, [len, [gmtime]]] )\fR" 4
.IX Item "date_received( [format, [len, [gmtime]]] )"
This method returns tha date dis message was received by you as a string. Da date returned is calculated accordin ta \f(CW\*(C`localtime()\*(C'\fR.
.Sp
Without additionizzle arguments, tha strang returned looks suttin' like
.Sp
.Vb 1
\&    Sun Apr 14 02:27:57 2002
.Ve
.Sp
Da optionizzle first argument be a strang describin tha format of tha date line. Well shiiiit, it is passed unchanged ta \f(CWstrftime(3)\fR. Please consult yo' systemz documentation fo' \f(CWstrftime(3)\fR ta peep how tha fuck such a strang has ta look like. Da default strang ta render tha date is \*(L"%a \f(CW%b\fR \f(CW%e\fR \f(CW%H:\fR%M:%S \f(CW%Y\fR\*(R".
.Sp
Da optionizzle second argument is tha max strang length ta be returned by \f(CW\*(C`date_received()\*(C'\fR. This parameta be also passed unaltered ta \f(CW\*(C`strftime()\*(C'\fR. This method uses 25 as default
.Sp
Da third argument can be set ta a legit value if you rather wanna git a thugged-out date up in \s-1GMT.\s0 So if you wanna git tha \s-1GMT\s0 of tha date but wanna use tha default renderin settings, yo big-ass booty is ghon gotta provide dem yo ass:
.Sp
.Vb 1
\&    print $msg\->date_received("%a %b %e %H:%M:%S %Y", 25, 1);
.Ve
.IP "\fBis_seen\fR" 4
.IX Item "is_seen"
Returns a legit value if dis message has already been seen. I aint talkin' bout chicken n' gravy biatch. False otherwise.
.IP "\fBis_email\fR" 4
.IX Item "is_email"
Always returns legit fo' dis kind of object.
.IP "\fBis_folder\fR" 4
.IX Item "is_folder"
Always returns false fo' dis kind of object.
.PP
Da followin methodz exist fo' \fBMail::Transport::Dbx::Folder\fR objects:
.IP "\fBdbx\fR" 4
.IX Item "dbx"
This be a cold-ass lil convenience method. Y'all KNOW dat shit, muthafucka! Well shiiiit, it creates a \f(CW\*(C`Mail::Transport::Dbx\*(C'\fR object from tha folda object. If tha folda is only mentioned but not physically existin on yo' hard-drive (either cuz you deleted tha .dbx file or dat shiznit was straight-up never there which especially happens fo' newsgroup files) \f(CW\*(C`dbx\*(C'\fR returns a undefined value.
.Sp
Please read \*(L"\s-1DESCRIPTION\*(R"\s0 again n' again n' again ta learn why \f(CW\*(C`dbx()\*(C'\fR can return a undefined value.
.IP "\fBnum\fR" 4
.IX Item "num"
Da index number of dis folda n' shit. This is tha number you passed ta \f(CW\*(C`$dbx\->get()\*(C'\fR ta retrieve dis folder.
.IP "\fBtype\fR" 4
.IX Item "type"
Accordin ta \fIlibdbx.h\fR dis returns one of \f(CW\*(C`DBX_TYPE_FOLDER\*(C'\fR or \f(CW\*(C`DBX_TYPE_EMAIL\*(C'\fR. Use it ta check whether tha folda gotz nuff emails or other folders.
.IP "\fBname\fR" 4
.IX Item "name"
Da name of tha folder.
.IP "\fBfile\fR" 4
.IX Item "file"
Da filename of tha folda n' shit. Use this, ta create a freshly smoked up \f(CW\*(C`Mail::Transport::Dbx\*(C'\fR object:
.Sp
.Vb 2
\&    # $folda be a Mail::Transport::Dbx::Folda object
\&    mah $new_dbx = Mail::Transport::Dbx\->new( $folder\->file );
.Ve
.Sp
Consider rockin tha \f(CW\*(C`dbx()\*(C'\fR method instead.
.Sp
This method returns a undefined value if there is no .dbx file belongin ta dis folder.
.IP "\fBid\fR" 4
.IX Item "id"
Numerical id of tha folda n' shit. Not shizzle what tha fuck dis is useful for.
.IP "\fBparent_id\fR" 4
.IX Item "parent_id"
Numerical id of tha parentz folder.
.IP "\fBfolder_path\fR" 4
.IX Item "folder_path"
Returns tha full folda name of dis folda as a list of path elements, n' you can put dat on yo' toast. It aint nuthin but then up in yo' responsibilitizzle ta join dem together by rockin a thugged-out delimita dat don't show up in any of tha elements, n' you can put dat on yo' toast. ;\-)
.Sp
.Vb 1
\&    print join("/", $_\->folder_path), "\en" fo' $dbx\->subfolders;
\&
\&    # could fo' instizzle produce a long-ass list, such as:
\&    Outlook Express/news.rwth\-aachen.de/de.comp.software.announce
\&    Outlook Express/news.rwth\-aachen.de/de.comp.software.misc
\&    ...
\&    Outlook Express/Lokale Ordner/test/test1
\&    Outlook Express/Lokale Ordner/test
\&    Outlook Express/Lokale Ordner/Entwu\*:rfe
\&    Outlook Express/Lokale Ordner/Gelo\*:schte Objekte
\&    Outlook Express/Lokale Ordner/Gesendete Objekte
\&    Outlook Express/Lokale Ordner/Postausgang
\&    Outlook Express/Lokale Ordner/Posteingang
\&    Outlook Express/Lokale Ordner
\&    Outlook Express/Outlook Express
.Ve
.Sp
Note dat a slash (as any other character) might not be a safe chizzle as it could show up in a gangbangin' folda name.
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SS "Exportable constants"
.IX Subsection "Exportable constants"
If you intend ta use any of tha followin constants, you gotta import dem when \f(CW\*(C`use()\*(C'\fRin tha module. Yo ass can import dem all up in one go thusly:
.PP
.Vb 1
\&    use Mail::Transport::Dbx qw(:all);
.Ve
.PP
Or you import only dem you need:
.PP
.Vb 1
\&    use Mail::Transport::Dbx qw(DBX_TYPE_EMAIL DBX_TYPE_FOLDER);
.Ve
.IP "\fBError-Codes\fR" 4
.IX Item "Error-Codes"
.RS 4
.PD 0
.IP "\(bu" 8
.PD
\&\s-1DBX_NOERROR\s0
.Sp
No error occured.
.IP "\(bu" 8
\&\s-1DBX_BADFILE\s0
.Sp
Dbx file operation failed (open or close)
.IP "\(bu" 8
\&\s-1DBX_DATA_READ\s0
.Sp
Readin of data from dbx file failed
.IP "\(bu" 8
\&\s-1DBX_INDEXCOUNT\s0
.Sp
Index outta range
.IP "\(bu" 8
\&\s-1DBX_INDEX_OVERREAD\s0
.Sp
Request was made fo' index reference pimped outa than exists
.IP "\(bu" 8
\&\s-1DBX_INDEX_UNDERREAD\s0
.Sp
Number of indexes read from dbx file is less than expected
.IP "\(bu" 8
\&\s-1DBX_INDEX_READ\s0
.Sp
Readin of Index Pointa from dbx file failed
.IP "\(bu" 8
\&\s-1DBX_ITEMCOUNT\s0
.Sp
Readin of Item Count from dbx file failed
.IP "\(bu" 8
\&\s-1DBX_NEWS_ITEM\s0
.Sp
Item be a shizzle item not a email
.RE
.RS 4
.RE
.IP "\fBDbx types\fR" 4
.IX Item "Dbx types"
One of these is returned by \f(CW\*(C`$folder\->type\*(C'\fR so you can check whether tha folda gotz nuff emails or subfolders. \fBNote dat only \s-1DBX_TYPE_EMAIL\s0 n' \s-1DBX_TYPE_FOLDER\s0 is eva returned so even newsgroup postings iz of tha type \s-1DBX_TYPE_EMAIL\s0\fR.
.RS 4
.IP "\(bu" 8
\&\s-1DBX_TYPE_EMAIL\s0
.IP "\(bu" 8
\&\s-1DBX_TYPE_FOLDER\s0
.IP "\(bu" 8
\&\s-1DBX_TYPE_NEWS\s0
.Sp
Don't use dis one!
.IP "\(bu" 8
\&\s-1DBX_TYPE_VOID\s0
.Sp
I have no clue what tha fuck dis is for.
.RE
.RS 4
.RE
.IP "\fBMiscellaneous constants\fR" 4
.IX Item "Miscellaneous constants"
.RS 4
.PD 0
.IP "\(bu" 8
.PD
\&\s-1DBX_EMAIL_FLAG_ISSEEN\s0
.IP "\(bu" 8
\&\s-1DBX_FLAG_BODY\s0
.RE
.RS 4
.RE
.SH "CAVEATS"
.IX Header "CAVEATS"
Yo ass can't retrieve tha internal state of tha objects rockin \f(CW\*(C`Data::Dumper\*(C'\fR or so since \f(CW\*(C`Mail::Transport::Dbx\*(C'\fR uses a pimped scalar ta hold a reference ta tha respectizzle C structures. That means you gotta use tha provided methodz fo' each object. Call dat phat encapsultion if you need a euphemizzle fo' dis shit.
.PP
There is currently no plans ta implement write access ta .dbx files. I leave dat up ta tha authorz of libdbx.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
Other than dat I don't give a fuck yet of any. This, of course, has never straight-up been a phat indication fo' tha absence of bugs.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
http://sourceforge.net/projects/ol2mbox hosts tha libdbx package. Well shiiiit, it gotz nuff tha library backin dis module along wit a thugged-out description of tha file format fo' .dbx files.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tassilo von Parseval, <tassilo.von.parseval@rwth\-aachen.de>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2003\-2005 by Tassilo von Parseval
.PP
This library is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
