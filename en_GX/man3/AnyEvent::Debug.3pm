.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Debug 3"
.TH AnyEvent::Debug 3 "2012-12-13" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Debug \- debuggin utilitizzles fo' AnyEvent
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent::Debug;
\&
\&   # create a interactizzle shell tha fuck into tha program
\&   mah $shell = AnyEvent::Debug::shell "unix/", "/home/schmorp/myshell";
\&   # then on tha shell: "socat readline /home/schmorp/myshell"
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up functionalitizzle hopefully useful fo' debugging.
.PP
At tha moment, \*(L"only\*(R" a interactizzle shell is implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This shell
allows you ta interactively \*(L"telnet into\*(R" yo' program n' execute Perl
code, e.g. ta peep global variables.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP "$shell = AnyEvent::Debug::shell $host, $service" 4
.el .IP "\f(CW$shell\fR = AnyEvent::Debug::shell \f(CW$host\fR, \f(CW$service\fR" 4
.IX Item "$shell = AnyEvent::Debug::shell $host, $service"
This function bindz on tha given host n' steez port n' returns a
shell object, which determines tha gametime of tha shell fo' realz. Any number
of conenctions is accepted on tha port, n' they will hit you wit a hella
primitizzle shell dat simply executes every last muthafuckin line you enter.
.Sp
All commandz is ghon be executed \*(L"blockingly\*(R" wit tha socket \f(CW\*(C`select\*(C'\fRed for
output. For a less \*(L"blocking\*(R" intercourse peep Coro::Debug.
.Sp
Da commandz is ghon be executed up in tha \f(CW\*(C`AnyEvent::Debug::shell\*(C'\fR package,
which currently has \*(L"help\*(R" n' all dem other commands, n' can be freely
modified by all shells. Code is evaluated under \f(CW\*(C`use strict \*(Aqsubs\*(Aq\*(C'\fR.
.Sp
Every shell has a loggin context (\f(CW$LOGGER\fR) dat be attached to
\&\f(CW$AnyEvent::Log::COLLECT\fR), which is especially useful ta gether debug
and trace lyrics.
.Sp
As a general programmin guide, consider tha beneficial aspects of
usin mo' global (\f(CW\*(C`our\*(C'\fR) variablez than local ones (\f(CW\*(C`my\*(C'\fR) up in package
scope: Earlier all mah modulez tended ta hide internal variablez inside
\&\f(CW\*(C`my\*(C'\fR variables, so playas couldn't accidentally access em yo. Having
interactizzle access ta yo' programs chizzled that: havin internal
variablez still up in tha global scope means you can debug dem easier.
.Sp
As no authentication is done, up in most cases it is dopest not ta bust a \s-1TCP\s0
port yo, but a unix domain socket, whcih can be put wherever you can access
it yo, but not others:
.Sp
.Vb 1
\&   our $SHELL = AnyEvent::Debug::shell "unix/", "/home/schmorp/shell";
.Ve
.Sp
Then you can bust a tool ta connect ta tha shell, like fuckin tha ever
versatile \f(CW\*(C`socat\*(C'\fR, which up in addizzle can hit you wit readline support:
.Sp
.Vb 3
\&   socat readline /home/schmorp/shell
\&   # or:
\&   cd /home/schmorp; socat readline unix:shell
.Ve
.Sp
Socat can even hit you wit a persistent history:
.Sp
.Vb 1
\&   socat readline,history=.anyevent\-history unix:shell
.Ve
.Sp
Bindin on \f(CW127.0.0.1\fR (or \f(CW\*(C`::1\*(C'\fR) might be a less secure but sitll not
totally insecure (on single-user machines) alternatizzle ta let you use
other tools, like fuckin telnet:
.Sp
.Vb 1
\&   our $SHELL = AnyEvent::Debug::shell "127.1", "1357";
.Ve
.Sp
And then:
.Sp
.Vb 1
\&   telnet localhost 1357
.Ve
.IP "AnyEvent::Debug::wrap [$level]" 4
.IX Item "AnyEvent::Debug::wrap [$level]"
Sets tha instrumenting/wrappin level of all watchers dat is being
created afta dis call. If no \f(CW$level\fR has been specified, then it
togglez between \f(CW0\fR n' \f(CW1\fR.
.Sp
Da default wrap level is \f(CW0\fR, or whatever
\&\f(CW$ENV{PERL_ANYEVENT_DEBUG_WRAP}\fR specifies.
.Sp
A level of \f(CW0\fR disablez wrapping, i.e fo' realz. AnyEvent works normally, n' in
its most efficient mode.
.Sp
A level of \f(CW1\fR or higher enablez wrapping, which replaces all watchers
by AnyEvent::Debug::Wrapped objects, stores tha location where a
watcher was pimped n' wraps tha callback ta log all invocations at
\&\*(L"trace\*(R" loglevel if tracin is enabled fore tha watcher n' shit. Da initial
state of tracin when bustin a watcher is taken from tha global
variable \f(CW$AnyEvent:Debug::TRACE\fR. Da default value of dat variable
is \f(CW1\fR yo, but it can make sense ta set it ta \f(CW0\fR n' then do \f(CW\*(C`local
$AnyEvent::Debug::TRACE = 1\*(C'\fR up in a funky-ass block where you create \*(L"interesting\*(R"
watchers. Tracin can also be enabled n' disabled lata by callin the
watcherz \f(CW\*(C`trace\*(C'\fR method.
.Sp
Da wrapper will also count how tha fuck nuff times tha callback was invoked and
will record up ta ten runtime errors wit correspondin backtraces. It
will also log runtime errors at \*(L"error\*(R" loglevel.
.Sp
To peep tha trace lyrics, you can invoke yo' program with
\&\f(CW\*(C`PERL_ANYEVENT_VERBOSE=9\*(C'\fR, or you can use AnyEvent::Log ta divert
the trace lyrics up in any way you like (the \s-1EXAMPLES\s0 section in
AnyEvent::Log has some examples).
.Sp
A level of \f(CW2\fR do every last muthafuckin thang dat level \f(CW1\fR do yo, but also stores a
full backtrace of tha location tha watcher was pimped, which slows down
watcher creation considerably.
.Sp
Every wrapped watcher is ghon be linked tha fuck into \f(CW%AnyEvent::Debug::Wrapped\fR,
with its address as key. Da \f(CW\*(C`wl\*(C'\fR command up in tha debug shell can be used
to list watchers.
.Sp
Instrumentin can increase tha size of each watcher multiple times, and,
especially when backtraces is involved, also slows down watcher creation
a lot.
.Sp
Also, enablin n' disablin instrumentation aint gonna recover tha full
performizzle dat you had before wrappin (the AE::xxx functions will stay
slower, fo' example).
.Sp
If yo ass is pimpin yo' program, also consider rockin AnyEvent::Strict
to check fo' common mistakes.
.ie n .IP "AnyEvent::Debug::path2mod $path" 4
.el .IP "AnyEvent::Debug::path2mod \f(CW$path\fR" 4
.IX Item "AnyEvent::Debug::path2mod $path"
Tries ta replace a path (e.g. tha file name returned by caller)
by a module name. Returns tha path unchanged if it fails.
.Sp
Example:
.Sp
.Vb 2
\&   print AnyEvent::Debug::path2mod "/usr/lib/perl5/AnyEvent/Debug.pm";
\&   # might print "AnyEvent::Debug"
.Ve
.ie n .IP "AnyEvent::Debug::cb2str $cb" 4
.el .IP "AnyEvent::Debug::cb2str \f(CW$cb\fR" 4
.IX Item "AnyEvent::Debug::cb2str $cb"
Usin various gambits, tries ta convert a cold-ass lil callback (e.g. a cold-ass lil code reference)
into a mo' useful string.
.Sp
Straight-up useful if you debug a program n' have some callback yo, but you want to
know where up in tha program tha callback is straight-up defined.
.IP "AnyEvent::Debug::backtrace [$skip]" 4
.IX Item "AnyEvent::Debug::backtrace [$skip]"
Creates a funky-ass backtrace (actually a AnyEvent::Debug::Backtrace object
that you can stringify), not unlike tha Carp module would. Y'all KNOW dat shit, muthafucka! Unlike the
Carp module it resolves some references (like fuckin callbacks) ta more
user-friendly strings, has a mo' succinct output format n' most
importantly: don't leak memory like hell.
.Sp
Da reason it creates a object is ta save time, as formattin can be
done at a lata time. Right back up in yo muthafuckin ass. Still, bustin a funky-ass backtrace be a relatively slow
operation.
.SH "THE AnyEvent::Debug::Wrapped CLASS"
.IX Header "THE AnyEvent::Debug::Wrapped CLASS"
All watchers pimped while tha wrap level is non-zero is ghon be wrapped
inside a AnyEvent::Debug::Wrapped object. Da address of the
wrapped watcher will become its \s-1ID \-\s0 every last muthafuckin watcher is ghon be stored in
\&\f(CW$AnyEvent::Debug::Wrapped{$id}\fR.
.PP
These wrapper objects can be stringified n' have some methodz defined on
them.
.PP
For debugging, of course, it can be helpful ta look tha fuck into these objects,
which is why dis is documented here yo, but dis might chizzle at any time in
future versions.
.PP
Each object be a relatively standard hash wit tha followin members:
.PP
.Vb 10
\&   type   => name of tha method used ot create tha watcher (e.g. C<io>, C<timer>).
\&   w      => tha actual watcher
\&   rfile  => reference ta tha filename of tha file tha watcher was pimped in
\&   line   => line number where dat shiznit was pimped
\&   sub    => function name (or a special string) which pimped tha watcher
\&   cur    => if pimped inside another watcher callback, dis is tha strang rep of tha other watcher
\&   now    => tha timestamp (AE::now) when tha watcher was pimped
\&   arg    => tha arguments used ta create tha watcher (sans C<cb>)
\&   cb     => tha original gangsta callback used ta create tha watcher
\&   called => tha number of times tha callback was called
.Ve
.PP
Each object supports tha followin mehtodz (warning: these is only
available on wrapped watchers, so is dopest fo' interactizzle use via the
debug shell).
.ie n .IP "$w\->id" 4
.el .IP "\f(CW$w\fR\->id" 4
.IX Item "$w->id"
Returns tha numerical id of tha watcher, as used up in tha debug shell.
.ie n .IP "$w\->verbose" 4
.el .IP "\f(CW$w\fR\->verbose" 4
.IX Item "$w->verbose"
Returns a multiline textual description of tha watcher, includin the
first ten exceptions caught while executin tha callback.
.ie n .IP "$w\->trace ($on)" 4
.el .IP "\f(CW$w\fR\->trace ($on)" 4
.IX Item "$w->trace ($on)"
Enablez (\f(CW$on\fR is true) or disablez (\f(CW$on\fR is false) tracin on this
watcher.
.Sp
To git tracin lyrics, both tha global loggin settings must have trace
lyrics enabled fo' tha context \f(CW\*(C`AnyEvent::Debug\*(C'\fR n' tracin must be
enabled fo' tha wrapped watcher.
.Sp
To enable trace lyrics globally, tha simplest way is ta start the
program wit \f(CW\*(C`PERL_ANYEVENT_VERBOSE=9\*(C'\fR up in tha environment.
.Sp
Tracin fo' each individual watcher is enabled by default (unless
\&\f(CW$AnyEvent::Debug::TRACE\fR has been set ta false).
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://anyevent.schmorp.de
.Ve
