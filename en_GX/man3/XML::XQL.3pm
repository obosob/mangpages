.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::XQL 3"
.TH XML::XQL 3 "2013-08-04" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::XQL \- A perl module fo' queryin XML tree structures wit XQL
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use XML::XQL;
\& use XML::XQL::DOM;
\&
\& $parser = freshly smoked up XML::DOM::Parser;
\& $doc = $parser\->parsefile ("file.xml");
\&
\& # Return all elements wit tagName=\*(Aqtitle\*(Aq under tha root element \*(Aqbook\*(Aq
\& $query = freshly smoked up XML::XQL::Query (Expr => "book/title");
\& @result = $query\->solve ($doc);
\& $query\->dispose; # Avoid memory leaks \- Remove circular references
\&
\& # Or (to save some typing)
\& @result = XML::XQL::solve ("book/title", $doc);
\&
\& # Or (to save even mo' typing)
\& @result = $doc\->xql ("book/title");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \s-1XML::XQL\s0 module implements tha \s-1XQL \s0(\s-1XML\s0 Query Language) proposal
submitted ta tha \s-1XSL\s0 Workin Group up in September 1998.
Da spec can be found at: <http://www.w3.org/TandS/QL/QL98/pp/xql.html>
Most of tha contents related ta tha \s-1XQL\s0 syntax can also be found up in the
XML::XQL::Tutorial dat comes wit dis distribution. I aint talkin' bout chicken n' gravy biatch. 
Note dat \s-1XQL\s0 aint tha same as XML-QL!
.PP
Da current implementation only works wit tha \s-1XML::DOM\s0 module yo, but once the
design is stable n' tha major bugs is flushed out, other extensions might
follow, e.g. fo' XML::Grove.
.PP
\&\s-1XQL\s0 was designed ta be extensible n' dis implementation tries ta stick ta dis shit.
Users can add they own functions, methods, comparison operators n' data types.
Pluggin up in a freshly smoked up \s-1XML\s0 tree structure (like XML::Grove) should be a piece of cake.
.PP
To use tha \s-1XQL\s0 module, either
.PP
.Vb 1
\&  use XML::XQL;
.Ve
.PP
or
.PP
.Vb 1
\&  use XML::XQL::Strict;
.Ve
.PP
Da Strict module only serves up tha core \s-1XQL\s0 functionalitizzle as found up in the
\&\s-1XQL\s0 spec. By default (i.e. by rockin \s-1XML::XQL\s0) you git '\s-1XQL+\s0', which has
some additionizzle features.
.PP
See tha section \*(L"Additionizzle Features up in \s-1XQL+\*(R"\s0 fo' tha differences.
.PP
This module is still up in pimpment. Right back up in yo muthafuckin ass. See tha To-do list up in \s-1XQL\s0.pm fo' what
still need ta be done fo' realz. Any suggestions is welcome, tha sooner these 
implementation thangs is resolved, tha fasta we can all use dis module.
.PP
If you find a funky-ass bug, you would do me pimped out favor by bustin  it ta me up in the
form of a test case. Right back up in yo muthafuckin ass. See tha file t/xql_template.t dat comes wit dis distribution.
.PP
If you have freestyled a cold-ass lil def comparison operator, function, method or \s-1XQL\s0 data 
type dat you wanna share, bust it ta tjmather@tjmather.com n' I will
add it ta dis module.
.SH "XML::XQL global functions"
.IX Header "XML::XQL global functions"
.IP "solve (\s-1QUERY_STRING, INPUT_LIST...\s0)" 4
.IX Item "solve (QUERY_STRING, INPUT_LIST...)"
.Vb 1
\& @result = XML::XQL::solve ("doc//book", $doc);
.Ve
.Sp
This is provided as a gangbangin' finger-lickin' dirty-ass shortcut for:
.Sp
.Vb 3
\& $query = freshly smoked up XML::XQL::Query (Expr => "doc//book");
\& @result = $query\->solve ($doc);
\& $query\->dispose;
.Ve
.Sp
Note dat wit \s-1XML::XQL::DOM\s0, you can also write (see XML::DOM::Node
for details):
.Sp
.Vb 1
\& @result = $doc\->xql ("doc//book");
.Ve
.IP "setDocParser (\s-1PARSER\s0)" 4
.IX Item "setDocParser (PARSER)"
Sets tha XML::DOM::Parser dat is used by tha freshly smoked up \s-1XQL+\s0 \fIdocument()\fR method.
By default it uses a XML::DOM::Parser dat was pimped without any arguments,
i.e.
.Sp
.Vb 1
\&  $PARSER = freshly smoked up XML::DOM::Parser;
.Ve
.IP "defineFunction (\s-1NAME, FUNCREF, ARGCOUNT\s0 [, \s-1ALLOWED_OUTSIDE\s0 [, \s-1CONST,\s0 [\s-1QUERY_ARG\s0]]])" 4
.IX Item "defineFunction (NAME, FUNCREF, ARGCOUNT [, ALLOWED_OUTSIDE [, CONST, [QUERY_ARG]]])"
Defines tha \s-1XQL\s0 function (at tha global level, i.e. fo' all newly pimped 
queries) wit tha specified \s-1NAME.\s0 Da \s-1ARGCOUNT\s0 parameta can either be a single
number or a reference ta a list wit numbers. 
A single number expandz ta [\s-1ARGCOUNT, ARGCOUNT\s0]. Da list gotz nuff pairz of 
numbers, indicatin tha number of arguments dat tha function allows. Da value
\&\-1 means infinity. E.g. [2, 5, 7, 9, 12, \-1] means dat tha function can have
2, 3, 4, 5, 7, 8, 9, 12 or mo' arguments.
Da number of arguments is checked when parsin tha \s-1XQL\s0 query string.
.Sp
Da second parameta must be a reference ta a Perl function or a anonymous
sub. E.g. '\e&my_func' or 'sub { ... code ... }'
.Sp
If \s-1ALLOWED_OUTSIDE \s0(default is 0) is set ta 1, tha function or method may 
also be used outside subqueries up in \fInode queries\fR.
(See NodeQuery parameta up in Query constructor)
.Sp
If \s-1CONST \s0(default is 0) is set ta 1, tha function is considered ta be 
\&\*(L"constant\*(R". Right back up in yo muthafuckin ass. See \*(L"Constant Function Invocations\*(R" fo' details.
.Sp
If \s-1QUERY_ARG \s0(default is 0) aint \-1, tha argument wit dat index is
considered ta be a 'query parameter'. If tha query parameta be a subquery, 
that returns multiple joints, tha result list of tha function invocation will
contain one result value fo' each value of tha subquery. 
E.g. 'length(book/author)' will return a list of Numbers, denotin tha strang 
lengthz of all tha lyricist elements returned by 'book/author'.
.Sp
Note dat only methodz (not functions) may step tha fuck up afta a Bang \*(L"!\*(R" operator.
This is checked when parsin tha \s-1XQL\s0 query string.
.Sp
See also: defineMethod
.IP "generateFunction (\s-1NAME, FUNCNAME, RETURN_TYPE\s0 [, \s-1ARGCOUNT\s0 [, \s-1ALLOWED_OUTSIDE\s0 [, \s-1CONST\s0 [, \s-1QUERY_ARG\s0]]]])" 4
.IX Item "generateFunction (NAME, FUNCNAME, RETURN_TYPE [, ARGCOUNT [, ALLOWED_OUTSIDE [, CONST [, QUERY_ARG]]]])"
Generates n' defines a \s-1XQL\s0 function wrapper fo' tha Perl function wit the
name \s-1FUNCNAME.\s0 Da function name is ghon be \s-1NAME\s0 up in \s-1XQL\s0 query expressions.
Da return type should be one of tha builtin \s-1XQL\s0 Data Types or a cold-ass lil class derived
from XML::XQL::PrimitiveType (see \*(L"Addin Data Types\*(R".)
See defineFunction fo' tha meanin of \s-1ARGCOUNT, ALLOWED_OUTSIDE, CONST\s0 and
\&\s-1QUERY_ARG.\s0
.Sp
Function joints is always converted ta Perl strings wit xql_toStrin before
they is passed ta tha Perl function implementation. I aint talkin' bout chicken n' gravy biatch. Da function return value
is cast ta a object of type \s-1RETURN_TYPE,\s0 or ta tha empty list [] if the
result is undef. Well shiiiit, it uses expandType ta expand \s-1XQL\s0 primitizzle type names.
If \s-1RETURN_TYPE\s0 is \*(L"*\*(R", it returns tha function 
result as is, unless tha function result is undef, up in which case it returns [].
.IP "defineMethod (\s-1NAME, FUNCREF, ARGCOUNT\s0 [, \s-1ALLOWED_OUTSIDE\s0])" 4
.IX Item "defineMethod (NAME, FUNCREF, ARGCOUNT [, ALLOWED_OUTSIDE])"
Defines tha \s-1XQL\s0 method (at tha global level, i.e. fo' all newly pimped 
queries) wit tha specified \s-1NAME.\s0 Da \s-1ARGCOUNT\s0 parameta can either be a single
number or a reference ta a list wit numbers. 
A single number expandz ta [\s-1ARGCOUNT, ARGCOUNT\s0]. Da list gotz nuff pairz of 
numbers, indicatin tha number of arguments dat tha method allows. Da value
\&\-1 means infinity. E.g. [2, 5, 7, 9, 12, \-1] means dat tha method can have
2, 3, 4, 5, 7, 8, 9, 12 or mo' arguments.
Da number of arguments is checked when parsin tha \s-1XQL\s0 query string.
.Sp
Da second parameta must be a reference ta a Perl function or a anonymous
sub. E.g. '\e&my_func' or 'sub { ... code ... }'
.Sp
If \s-1ALLOWED_OUTSIDE \s0(default is 0) is set ta 1, tha function or method may 
also be used outside subqueries up in \fInode queries\fR.
(See NodeQuery parameta up in Query constructor)
.Sp
Note dat only methodz (not functions) may step tha fuck up afta a Bang \*(L"!\*(R" operator.
This is checked when parsin tha \s-1XQL\s0 query string.
.Sp
See also: defineFunction
.IP "defineComparisonOperators (\s-1NAME\s0 => \s-1FUNCREF\s0 [, \s-1NAME\s0 => \s-1FUNCREF\s0]*)" 4
.IX Item "defineComparisonOperators (NAME => FUNCREF [, NAME => FUNCREF]*)"
Defines \s-1XQL\s0 comparison operators all up in tha global level.
Da \s-1FUNCREF\s0 parametas must be a references ta a Perl function or a anonymous
sub. E.g. '\e&my_func' or 'sub { ... code ... }'
.Sp
E.g. define tha operators \f(CW$my_op\fR$ n' \f(CW$my_op2\fR$:
.Sp
.Vb 2
\& defineComparisonOperators (\*(Aqmy_op\*(Aq => \e&my_op,
\&                            \*(Aqmy_op2\*(Aq => sub { ... bang code here ... });
.Ve
.IP "defineElementValueConvertor (\s-1TAG_NAME, FUNCREF\s0)" 4
.IX Item "defineElementValueConvertor (TAG_NAME, FUNCREF)"
Defines dat tha result of tha \fIvalue()\fR call fo' Elements wit tha specified
\&\s-1TAG_NAME\s0 uses tha specified function. I aint talkin' bout chicken n' gravy biatch. Da function will receive
two parameters. Da second one is tha \s-1TAG_NAME\s0 of tha Element node 
and tha straight-up original gangsta parameta is tha Element node itself.
\&\s-1FUNCREF\s0 should be a reference ta a Perl function, e.g. \e&my_sub, or
an anonymous sub.
.Sp
E.g. ta define dat all Elements wit tag name 'date\-of\-birth' should return
XML::XQL::Date objects:
.Sp
.Vb 7
\&        defineElementValueConvertor (\*(Aqdate\-of\-birth\*(Aq, sub {
\&                mah $elem = shift;
\&                # Always pass up in tha node as tha second parameter n' shit. This is
\&                # tha reference node fo' tha object, which is used when
\&                # sortin joints up in document order.
\&                freshly smoked up XML::XQL::Date ($elem\->xql_text, $elem); 
\&        });
.Ve
.Sp
These convertors can only be specified at a global level, not on a per query
basis. To undefine a cold-ass lil convertor, simply pass a \s-1FUNCREF\s0 of undef.
.IP "defineAttrValueConvertor (\s-1ELEM_TAG_NAME, ATTR_NAME, FUNCREF\s0)" 4
.IX Item "defineAttrValueConvertor (ELEM_TAG_NAME, ATTR_NAME, FUNCREF)"
Defines dat tha result of tha \fIvalue()\fR call fo' Attributes wit tha specified
\&\s-1ATTR_NAME\s0 n' a parent Element wit tha specified \s-1ELEM_TAG_NAME \s0
uses tha specified function. I aint talkin' bout chicken n' gravy biatch fo' realz. An \s-1ELEM_TAG_NAME\s0 of \*(L"*\*(R" will match regardless of
the tag name of tha parent Element. Da function will receive
3 parameters. Da third one is tha tag name of tha parent Element (even if 
\&\s-1ELEM_TAG_NAME\s0 was \*(L"*\*(R"), tha second is tha \s-1ATTR_NAME\s0 n' tha straight-up original gangsta is tha 
Attribute node itself.
\&\s-1FUNCREF\s0 should be a reference ta a Perl function, e.g. \e&my_sub, or
an anonymous sub.
.Sp
These convertors can only be specified at a global level, not on a per query
basis. To undefine a cold-ass lil convertor, simply pass a \s-1FUNCREF\s0 of undef.
.IP "defineTokenQ (Q)" 4
.IX Item "defineTokenQ (Q)"
Defines tha token fo' tha q// strang delimitas at a global level.
Da default value fo' \s-1XQL+\s0 is 'q', fo' XML::XQL::Strict it is undef.
A value of undef will deactivate dis feature.
.IP "defineTokenQQ (\s-1QQ\s0)" 4
.IX Item "defineTokenQQ (QQ)"
Defines tha token fo' tha qq// strang delimitas at a global level.
Da default value fo' \s-1XQL+\s0 is 'qq', fo' XML::XQL::Strict it is undef.
A value of undef will deactivate dis feature.
.IP "expandType (\s-1TYPE\s0)" 4
.IX Item "expandType (TYPE)"
Used internally ta expand type namez of \s-1XQL\s0 primitizzle types.
E.g. it expandz \*(L"Number\*(R" ta \*(L"XML::XQL::Number\*(R" n' aint case-sensitive, so
\&\*(L"number\*(R" n' \*(L"NuMbEr\*(R" will both expand erectly.
.IP "defineExpandedTypes (\s-1ALIAS, FULL_NAME\s0 [, ...])" 4
.IX Item "defineExpandedTypes (ALIAS, FULL_NAME [, ...])"
For each pair of arguments it allows tha class name \s-1FULL_NAME\s0 ta be abbreviated
with \s-1ALIAS.\s0 Da definitions is used by \fIexpandType()\fR. 
(\s-1ALIAS\s0 be always converted ta lowercase internally, cuz expandType 
is case-insensitive.)
.Sp
Overridin tha \s-1ALIAS\s0 fo' \*(L"date\*(R", also affects tha object type returned by the
\&\fIdate()\fR function.
.IP "setErrorContextDelimitas (\s-1START, END, BOLD_ON, BOLD_OFF\s0)" 4
.IX Item "setErrorContextDelimitas (START, END, BOLD_ON, BOLD_OFF)"
Sets tha delimitas used when printin error lyrics durin query evaluation.
Da default delimitas on Unix is `tput smul` (underline on) n' `tput rmal`
(underline off). On other systems (that aint gots tput), tha delimitas are
\&\*(L">>\*(R" n' \*(L"<<\*(R" resp.
.Sp
When printin tha error message, tha subexpression dat caused tha error will
be enclosed by tha delimiters, i.e. underlined on Unix.
.Sp
For certain subexpressions tha dope keyword, e.g. \*(L"$and$\*(R" is enclosed up in 
the bold delimitas \s-1BOLD_ON \s0(default: `tput bold` on Unix, "\*(L" elsewhere) n' 
\&\s-1BOLD_OFF \s0(default: (`tput rmul` . `tput smul`) on Unix, \*(R"" elsewhere, 
see \f(CW$BoldOff\fR up in \s-1XML::XQL::XQL\s0.pm fo' details.)
.IP "isEmptyList (\s-1VAR\s0)" 4
.IX Item "isEmptyList (VAR)"
Returns 1 if \s-1VAR\s0 is [], else 0. Can be used up in user defined functions.
.SH "Additionizzle Features up in XQL+"
.IX Header "Additionizzle Features up in XQL+"
.IP "Parent operator '..'" 4
.IX Item "Parent operator '..'"
Da '..' operator returns tha parent of tha current node, where '.' would
return tha current node. This aint part of any \s-1XQL\s0 standard, cuz you
would normally use return operators, which is not implemented here.
.IP "Sequence operators ';' n' ';;'" 4
.IX Item "Sequence operators ';' n' ';;'"
Da sequence operators ';' (precedes) n' ';;' (immediately precedes) are
not up in tha \s-1XQL\s0 spec yo, but is busted lyrics bout up in 'Da Design of \s-1XQL\s0' by Jonathan Robie
who is one of tha designerz of \s-1XQL.\s0 It can be found at
<http://www.texcel.no/whitepapers/xql\-design.html>
See also tha \s-1XQL\s0 Tutorial fo' a thugged-out description of what tha fuck they mean.
.IP "q// n' qq// Strin Tokens" 4
.IX Item "q// n' qq// Strin Tokens"
Strin tokens a la q// n' qq// is allowed. Y'all KNOW dat shit, muthafucka! q// evaluates like Perlz single 
quotes n' qq// like Perlz double quotes. Note dat tha default \s-1XQL\s0 strings do
not allow escapin etc., so it aint possible ta define a strang wit both
single n' double quotes. If 'q' n' 'qq' is not ta yo' liking, you may
redefine dem ta suttin' else or undefine dem altogether, by assignin undef
to em. E.g:
.Sp
.Vb 3
\& # at a global level \- shared by all queries (that don\*(Aqt (re)define \*(Aqq\*(Aq)
\& XML::XQL::defineTokenQ (\*(Aqk\*(Aq);
\& XML::XQL::defineTokenQQ (undef);
\&
\& # at a query level \- only defined fo' dis query
\& $query = freshly smoked up XML::XQL::Query (Expr => "book/title", q => \*(Aqk\*(Aq, qq => undef);
.Ve
.Sp
From now on k// works like q// did n' qq// don't work at all no mo'.
.IP "Query strings can have embedded Comments" 4
.IX Item "Query strings can have embedded Comments"
For example:
.Sp
.Vb 2
\& $queryExpr = "book/title          # dis comment is inside tha query string
\&               [. = \*(AqMoby Dick\*(Aq]"; # dis comment is outside
.Ve
.IP "Optionizzle dollar delimitas n' case-insensitizzle \s-1XQL\s0 keywords" 4
.IX Item "Optionizzle dollar delimitas n' case-insensitizzle XQL keywords"
Da followin \s-1XQL\s0 keywordz is case-insensitizzle n' tha dollar sign delimitas 
may be omitted: \f(CW$and\fR$, \f(CW$or\fR$, \f(CW$not\fR$, \f(CW$union\fR$, \f(CW$intersect\fR$, \f(CW$to\fR$, \f(CW$any\fR$, \f(CW$all\fR$,
\&\f(CW$eq\fR$, \f(CW$ne\fR$, \f(CW$lt\fR$, \f(CW$gt\fR$, \f(CW$ge\fR$, \f(CW$le\fR$, \f(CW$ieq\fR$, \f(CW$ine\fR$, \f(CW$ilt\fR$, \f(CW$igt\fR$, \f(CW$ige\fR$, \f(CW$ile\fR$.
.Sp
E.g. \f(CW$AND\fR$, \f(CW$And\fR$, \f(CW$aNd\fR$, and, And, aNd is all valid replacements fo' \f(CW$and\fR$.
.Sp
Note dat \s-1XQL+\s0 comparison operators ($match$, \f(CW$no_match\fR$, \f(CW$isa\fR$, \f(CW$can\fR$) still
require dollar delimitas n' is case-sensitive.
.ie n .IP "Comparison operator: $match$ or '=~'" 4
.el .IP "Comparison operator: \f(CW$match\fR$ or '=~'" 4
.IX Item "Comparison operator: $match$ or '=~'"
E.g. \*(L"book/title =~ '/(Moby|Dick)/']\*(R" will return all book titlez containing
Moby or Dick. Note dat tha match expression need ta be quoted n' should
contain tha // or m// delimitas fo' Perl.
.Sp
When castin tha joints ta be matched, both is converted ta Text.
.ie n .IP "Comparison operator: $no_match$ or '!~'" 4
.el .IP "Comparison operator: \f(CW$no_match\fR$ or '!~'" 4
.IX Item "Comparison operator: $no_match$ or '!~'"
E.g. \*(L"book/title !~ '/(Moby|Dick)/']\*(R" will return all book titlez dat don't 
contain Moby or Dick. Note dat tha match expression need ta be quoted n' 
should contain tha // or m// delimitas fo' Perl.
.Sp
When castin tha joints ta be matched, both is converted ta Text.
.ie n .IP "Comparison operator: $isa$" 4
.el .IP "Comparison operator: \f(CW$isa\fR$" 4
.IX Item "Comparison operator: $isa$"
E.g. '//. \f(CW$isa\fR$ \*(L"XML::XQL::Date\*(R"' returns all elements fo' which tha \fIvalue()\fR 
function returns a XML::XQL::Date object. (Note dat tha \fIvalue()\fR function can
be overridden ta return a specific object type fo' certain elements n' 
attributes.) It uses expandType ta expand \s-1XQL\s0 primitizzle type names.
.ie n .IP "Comparison operator: $can$" 4
.el .IP "Comparison operator: \f(CW$can\fR$" 4
.IX Item "Comparison operator: $can$"
E.g. '//. \f(CW$can\fR$ \*(L"swim\*(R"' returns all elements fo' which tha \fIvalue()\fR 
function returns a object dat implements tha (Perl) \fIswim()\fR method. Y'all KNOW dat shit, muthafucka! 
(Note dat tha \fIvalue()\fR function can be overridden ta return a specific object 
type fo' certain elements n' attributes.)
.IP "Function: once (\s-1QUERY\s0)" 4
.IX Item "Function: once (QUERY)"
E.g. 'once(id(\*(L"foo\*(R"))' will evaluate tha \s-1QUERY\s0 expression only once per query.
Certain query thangs up in dis biatch (like tha above example) will always return tha same
value within a query. Usin \fIonce()\fR will cache tha \s-1QUERY\s0 result fo' the
rest of tha query.
.Sp
Note dat \*(L"constant\*(R" function invocations is always cached.
See also \*(L"Constant Function Invocations\*(R"
.IP "Function: subst (\s-1QUERY, EXPR, EXPR\s0 [,MODIFIERS, [\s-1MODE\s0]])" 4
.IX Item "Function: subst (QUERY, EXPR, EXPR [,MODIFIERS, [MODE]])"
E.g. 'subst(book/title, \*(L"[M|m]oby\*(R", \*(L"Dick\*(R", \*(L"g\*(R")' will replace Moby or moby
with Dick globally (\*(L"g\*(R") up in all book title elements, n' you can put dat on yo' toast. Underneath it uses Perl's
substitute operator s///. Don't worry bout which delimitas is used underneath.
Da function returns all tha book/titlez fo' which a substitution occurred.
Da default \s-1MODIFIERS\s0 strang is "\*(L" (empty.) Da function name may be abbreviated 
to \*(R"s".
.Sp
For most Node types, it converts tha \fIvalue()\fR ta a strang (with xql_toString)
to match tha strang n' xql_setValue ta set tha freshly smoked up value up in case it matched.
For \s-1XQL\s0 primitives (Boolean, Number, Text) n' other data types (e.g. Date) it 
uses xql_toStrin ta match tha Strin n' xql_setValue ta set tha result. 
Beware dat struttin a substitution on a primitizzle dat was found up in tha 
original gangsta \s-1XQL\s0 query expression, chizzlez tha value of dat constant.
.Sp
If \s-1MODE\s0 is 0 (default), it treats Element nodes differently by matchin and
replacin \fItext blocks\fR occurrin up in tha Element node fo' realz. A text block is defined
as tha concatenation of tha raw text of subsequent Text, CDATASection n' 
EntityReference nodes. In dis mode it skips embedded Element nodes.
If a text block matches, it is replaced by a single Text node, regardless
of tha original gangsta node type(s).
.Sp
If \s-1MODE\s0 is 1, it treats Element nodes like tha other nodes, i.e. it converts
the \fIvalue()\fR ta a strang etc. Note dat tha default implementation of \fIvalue()\fR
calls \fItext()\fR, which normalizes whitespace n' includes embedded Element
descendants (recursively.) This is probably not what tha fuck you wanna use up in most
cases yo, but since I aint a professionizzle psycho... :\-)
.IP "Function: map (\s-1QUERY, CODE\s0)" 4
.IX Item "Function: map (QUERY, CODE)"
E.g. 'map(book/title, \*(L"s/[M|m]oby/Dick/g; \f(CW$_\fR\*(R")' will replace Moby or moby
with Dick globally (\*(L"g\*(R") up in all book title elements, n' you can put dat on yo' toast. Underneath it uses Perl's
map operator. Shiiit, dis aint no joke. Da function returns all tha book/titlez fo' which a 
change occurred.
.Sp
??? add mo' specifics
.IP "Function: eval (\s-1EXPR\s0 [,TYPE])" 4
.IX Item "Function: eval (EXPR [,TYPE])"
Evaluates tha Perl expression \s-1EXPR\s0 n' returns a object of tha specified \s-1TYPE.\s0
It uses expandType ta expand \s-1XQL\s0 primitizzle type names.
If tha result of tha eval was undef, tha empty list [] is returned.
.Sp
E.g. 'eval(\*(L"2 + 5\*(R", \*(L"Number\*(R")' returns a Number object wit tha value 7, and
     'eval(\*(L"%ENV{\s-1USER\s0}\*(R")' returns a Text object wit tha user name.
.Sp
Consider rockin \fIonce()\fR ta cache tha return value, when tha invocation will 
return tha same result fo' each invocation within a query.
.Sp
??? add mo' specifics
.IP "Function: freshly smoked up (\s-1TYPE\s0 [, \s-1QUERY\s0 [, \s-1PAR\s0] *])" 4
.IX Item "Function: freshly smoked up (TYPE [, QUERY [, PAR] *])"
Creates a freshly smoked up object of tha specified object \s-1TYPE.\s0 Da constructor may have any
number of arguments, n' you can put dat on yo' toast. Da first argument of tha constructor (the 2nd argument 
of tha \fInew()\fR function) is considered ta be a 'query parameter'.
See defineFunction fo' a thugged-out definizzle of \fIquery parameter\fR.
It uses expandType ta expand \s-1XQL\s0 primitizzle type names.
.IP "Function: document (\s-1QUERY\s0) or doc (\s-1QUERY\s0)" 4
.IX Item "Function: document (QUERY) or doc (QUERY)"
Da \fIdocument()\fR function creates a freshly smoked up XML::XML::Document fo' each result 
of \s-1QUERY \s0(\s-1QUERY\s0 may be a simple strang expression, like \*(L"/usr/enno/file.xml\*(R". 
See t/xql_document.t or below fo' a example wit a mo' complex \s-1QUERY.\s0)
.Sp
\&\fIdocument()\fR may be abbreviated ta \fIdoc()\fR.
.Sp
\&\fIdocument()\fR uses a XML::DOM::Parser underneath, which can be set with
\&\fIXML::XQL::setDocParser()\fR. By default it uses a parser dat was pimped without
any arguments, i.e.
.Sp
.Vb 1
\&  $PARSER = freshly smoked up XML::DOM::Parser;
.Ve
.Sp
Letz try a mo' complex example, assumin \f(CW$doc\fR gotz nuff:
.Sp
.Vb 4
\& <doc>
\&  <file name="file1.xml"/>
\&  <file name="file2.xml"/>
\& </doc>
.Ve
.Sp
Then tha followin query will return two XML::XML::Documents, 
one fo' file1.xml n' one fo' file2.xml:
.Sp
.Vb 1
\& @result = XML::XQL::solve ("document(doc/file/@name)", $doc);
.Ve
.Sp
Da resultin documents can be used as input fo' followin queries, e.g.
.Sp
.Vb 1
\& @result = XML::XQL::solve ("document(doc/file/@name)/root/bla", $doc);
.Ve
.Sp
will return all /root/bla elements from tha documents returned by \fIdocument()\fR.
.IP "Method: DOM_nodeType ()" 4
.IX Item "Method: DOM_nodeType ()"
Returns tha \s-1DOM\s0 node type. Note dat these is mostly tha same as \fInodeType()\fR,
except fo' CDATASection n' EntityReference nodes. \fIDOM_nodeType()\fR returns
4 n' 5 respectively, whereas \fInodeType()\fR returns 3, cuz they is 
considered text nodes.
.IP "Function wrappers fo' Perl builtin functions" 4
.IX Item "Function wrappers fo' Perl builtin functions"
\&\s-1XQL\s0 function wrappers done been provided fo' most Perl builtin functions.
When rockin a Perl builtin function like \*(L"substr\*(R" up in a \s-1XQL+\s0 querry, an
\&\s-1XQL\s0 function wrapper is ghon be generated on tha fly. Da arguments ta these
functions may be regular \s-1XQL+\s0 subqueries (that return one or mo' joints) for
a \fIquery parameter\fR (see generateFunction fo' a thugged-out definition.)
Most wrapperz of Perl builtin functions have argument 0 fo' a query parameter,
except for: chmod (parameta 1 is tha query parameter), chown (2) n' utime (2).
Da followin functions have no query parameter, which means dat all parameters
should be a single value: atan2, rand, srand, sprintf, rename, unlink, system.
.Sp
Da function result is casted ta tha appropriate \s-1XQL\s0 primitizzle type (Number, 
Text or Boolean), or ta a empty list if tha result was undef.
.SS "XPath functions n' methods"
.IX Subsection "XPath functions n' methods"
Da followin functions was found up in tha XPath justification:
.IP "Function: concat (\s-1STRING, STRING,\s0 STRING*)" 4
.IX Item "Function: concat (STRING, STRING, STRING*)"
Da concat function returns tha concatenation of its arguments.
.IP "Function: starts-with (\s-1STRING, STRING\s0)" 4
.IX Item "Function: starts-with (STRING, STRING)"
Da starts-with function returns legit if tha straight-up original gangsta argument strang starts wit 
the second argument string, n' otherwise returns false.
.IP "Function: gotz nuff (\s-1STRING, STRING\s0)" 4
.IX Item "Function: gotz nuff (STRING, STRING)"
Da gotz nuff function returns legit if tha straight-up original gangsta argument strang gotz nuff tha 
second argument string, n' otherwise returns false.
.IP "Function: substring-before (\s-1STRING, STRING\s0)" 4
.IX Item "Function: substring-before (STRING, STRING)"
Da substring-before function returns tha substrin of tha straight-up original gangsta argument 
strin dat precedes tha straight-up original gangsta occurrence of tha second argument string
in tha straight-up original gangsta argument string, or tha empty strang if tha straight-up original gangsta argument 
strin do not contain tha second argument string. For example,
.Sp
.Vb 1
\& substring\-before("1999/04/01","/") returns 1999.
.Ve
.IP "Function: substring-afta (\s-1STRING, STRING\s0)" 4
.IX Item "Function: substring-afta (STRING, STRING)"
Da substring-afta function returns tha substrin of tha straight-up original gangsta argument strang 
that bigs up tha straight-up original gangsta occurrence of tha second argument strang in
the first argument string, or tha empty strang if tha straight-up original gangsta argument strang do
not contain tha second argument string. For example,
.Sp
.Vb 1
\& substring\-after("1999/04/01","/") returns 04/01,
.Ve
.Sp
and
.Sp
.Vb 1
\& substring\-after("1999/04/01","19") returns 99/04/01.
.Ve
.IP "Function: substrin (\s-1STRING, NUMBER\s0 [, \s-1NUMBER\s0] )" 4
.IX Item "Function: substrin (STRING, NUMBER [, NUMBER] )"
Da substrin function returns tha substrin of tha straight-up original gangsta argument startin at 
the posizzle specified up in tha second argument wit length specified in
the third argument. For example,
.Sp
.Vb 1
\& substring("12345",2,3) returns "234".
.Ve
.Sp
If tha third argument aint specified, it returns tha substrin 
startin all up in tha posizzle specified up in tha second argument n' continuin ta 
the end of tha string. For example,
.Sp
.Vb 1
\& substring("12345",2) returns "2345".
.Ve
.Sp
Mo' precisely, each characta up in tha strang is considered 
to gotz a numeric position: tha posizzle of tha straight-up original gangsta characta is 1,
the posizzle of tha second characta is 2 n' so on.
.Sp
\&\s-1NOTE:\s0 This differs from tha \fBsubstr\fR method , up in which the
method treats tha posizzle of tha straight-up original gangsta characta as 0.
.Sp
Da XPath spec say dis bout roundin yo, but dat aint legit up in dis 
implementation: 
\&\fIDa returned substrin gotz nuff dem charactas fo' which tha posizzle of tha 
characta is pimped outa than or equal ta tha rounded value of the
second argument and, if tha third argument is specified, less than tha 
sum of tha rounded value of tha second argument n' tha rounded value of
the third argument; tha comparisons n' addizzle used fo' tha above 
follow tha standard \s-1IEEE 754\s0 rules; roundin is done as if by a cold-ass lil call ta the
round function.\fR
.IP "Method: string-length ( [ \s-1QUERY \s0] )" 4
.IX Item "Method: string-length ( [ QUERY ] )"
Da string-length returns tha number of charactas up in tha string. 
If tha argument is omitted, it defaults ta tha context node
converted ta a string, up in other lyrics tha string-value of tha context node.
.Sp
Note dat tha generated \s-1XQL\s0 wrapper fo' tha Perl built-in \fBsubstr\fR do not
allow tha argument ta be omitted.
.IP "Method: normalize-space ( [ \s-1QUERY \s0] )" 4
.IX Item "Method: normalize-space ( [ QUERY ] )"
Da normalize-space function returns tha argument strang wit whitespace 
normalized by strippin leadin n' trailin whitespace n' replacing
sequencez of whitespace charactas by a single space. Whitespace charactas is 
the same as dem allowed by tha S thang up in \s-1XML.\s0 If the
argument is omitted, it defaults ta tha context node converted ta a string, up in 
other lyrics tha string-value of tha context node.
.IP "Function: translate (\s-1STRING, STRING, STRING\s0)" 4
.IX Item "Function: translate (STRING, STRING, STRING)"
Da translate function returns tha straight-up original gangsta argument strang wit occurrencez of 
charactas up in tha second argument strang replaced by tha characta at
the correspondin posizzle up in tha third argument string. For example,
.Sp
.Vb 1
\& translate("bar","abc","ABC") returns tha strang BAr.
.Ve
.Sp
If there be a
characta up in tha second argument strang wit no characta at a cold-ass lil corresponding
posizzle up in tha third argument strang (because tha second argument
strin is longer than tha third argument string), then occurrencez of dat 
characta up in tha straight-up original gangsta argument strang is removed. Y'all KNOW dat shit, muthafucka! For example,
.Sp
.Vb 1
\& translate("\-\-aaa\-\-","abc\-","ABC") returns "AAA".
.Ve
.Sp
If a cold-ass lil characta occurs mo' than once up in tha second argument string, then tha 
first occurrence determines tha replacement character n' shit. If tha third argument 
strin is longer than tha second argument string, then excess characters
are ignored.
.Sp
\&\s-1NOTE:\s0 Da translate function aint a sufficient solution fo' case conversion 
in all languages fo' realz. A future version may
provide additionizzle functions fo' case conversion.
.Sp
This function was implemented rockin tr///d.
.IP "Function: sum ( \s-1QUERY \s0)" 4
.IX Item "Function: sum ( QUERY )"
Da sum function returns tha sum of tha \s-1QUERY\s0 thangs up in dis biatch, by
convertin tha strang jointz of each result ta a number.
.IP "Function: floor (\s-1NUMBER\s0)" 4
.IX Item "Function: floor (NUMBER)"
Da floor function returns tha phattest (closest ta positizzle infinity) number 
that aint pimped outa than tha argument n' dat be a integer.
.IP "Function: ceilin (\s-1NUMBER\s0)" 4
.IX Item "Function: ceilin (NUMBER)"
Da ceilin function returns tha smallest (closest ta wack infinity) number 
that aint less than tha argument n' dat be a integer.
.IP "Function: round (\s-1NUMBER\s0)" 4
.IX Item "Function: round (NUMBER)"
Da round function returns tha number dat is closest ta tha argument 
and dat be a integer n' shit. If there be two such numbers, then tha one dat is
closest ta positizzle infinitizzle is returned.
.SH "Implementation Details"
.IX Header "Implementation Details"
.IP "\s-1XQL\s0 Builtin Data Types" 4
.IX Item "XQL Builtin Data Types"
Da \s-1XQL\s0 engine uses tha followin object classes internally. Only Number, 
Boolean n' Text is considered \fIprimitizzle \s-1XQL\s0 types\fR:
.RS 4
.IP "\(bu" 4
XML::XQL::Number
.Sp
For integers n' floatin point numbers.
.IP "\(bu" 4
XML::XQL::Boolean
.Sp
For booleans, e.g returned by \fItrue()\fR n' \fIfalse()\fR.
.IP "\(bu" 4
XML::XQL::Text
.Sp
For strang joints.
.IP "\(bu" 4
XML::XQL::Date
.Sp
For date, time n' date/time joints, n' you can put dat on yo' toast. E.g. returned by tha \fIdate()\fR function.
.IP "\(bu" 4
XML::XQL::Node
.Sp
Superclass of all \s-1XML\s0 node types. E.g. all subclassez of XML::DOM::Node subclass
from all dis bullshit.
.IP "\(bu" 4
Perl list reference
.Sp
Listz of joints is passed by reference (i.e. rockin [] delimiters).
Da empty list [] has a thugged-out double meaning. Well shiiiit, it also means 'undef' up in certain 
situations, e.g. when a gangbangin' function invocation or comparison failed.
.RE
.RS 4
.RE
.IP "Type castin up in comparisons" 4
.IX Item "Type castin up in comparisons"
When two joints is compared up in a \s-1XML\s0 comparison (e.g. \f(CW$eq\fR$) tha joints are
first casted ta tha same data type. Node joints is first replaced by their
\&\fIvalue()\fR (i.e. tha \s-1XQL\s0 \fIvalue()\fR function is used, which returns a Text value by 
default yo, but may return any data type if tha user so chizzles.)
Da resultin joints is then casted ta tha type of tha object wit tha highest
\&\fIxql_primType()\fR value. They is as bigs up: Node (0), Text (1), Number (2),
Boolean (3), Date (4), other data types (4 by default yo, but dis may be
overriden by tha user.)
.Sp
E.g. if one value be a Text value n' tha other be a Number, tha Text value is 
cast ta a Number n' tha resultin low-level (Perl) comparison is (for \f(CW$eq\fR$):
.Sp
.Vb 1
\& $number\->xql_toStrin == $text\->xql_toString
.Ve
.Sp
If both was Text joints, it would have been
.Sp
.Vb 1
\& $text1\->xql_toStrin eq $text2\->xql_toString
.Ve
.Sp
Note dat tha \s-1XQL\s0 spec is vague n' even conflictin where it concerns type
casting. This implementation resulted afta rappin' ta Joe Lapp, one of the
spec writers.
.IP "Addin Data Types" 4
.IX Item "Addin Data Types"
If you wanna add yo' own data type, make shizzle it derives from 
XML::XQL::PrimitiveType n' implements tha necessary methods.
.Sp
I'ma add mo' shiznit here ta explain it all yo, but fo' now, peep tha code
for tha primitizzle \s-1XQL\s0 types or tha Date class (XML::XQL::Date up in Date.pm.)
.IP "Document Order" 4
.IX Item "Document Order"
Da \s-1XQL\s0 spec states dat query thangs up in dis biatch always return they joints up in 
\&\fIdocument order\fR, which means tha order up in which they rocked up in tha original
\&\s-1XML\s0 document. Values extracted from Nodes (e.g. wit \fIvalue()\fR, \fItext()\fR, \fIrawText()\fR,
\&\fInodeName()\fR, etc.) always gotz a pointa ta tha reference node (i.e. tha Node
from which tha value was extracted.) These pointas is bigged up when
(intermediate) result lists is sorted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Currently, tha only place where a
result list is sorted is up in a \f(CW$union\fR$ expression, which is tha only place
where tha result list can be unordered.
(If you find dat dis aint true, let me know.)
.Sp
Non-node joints dat have no associated reference node, always end up all up in tha end
of tha result list up in tha order dat they was added.
Da \s-1XQL\s0 spec states dat tha reference node fo' a \s-1XML\s0 Attribute is tha Element
to which it belongs, n' dat tha order of joints wit tha same reference node
is undefined. Y'all KNOW dat shit, muthafucka! This means dat tha order of a Element n' its attributes would 
be undefined.
But since tha \s-1XML::DOM\s0 module keeps track of tha order of tha attributes, the
\&\s-1XQL\s0 engine do tha same, n' therefore, tha attributez of a Element are
sorted n' step tha fuck up afta they parent Element up in a sorted result list.
.IP "Constant Function Invocations" 4
.IX Item "Constant Function Invocations"
If a gangbangin' function always returns tha same ol' dirty value when given \*(L"constant\*(R" arguments,
the function is considered ta be \*(L"constant\*(R" fo' realz. A \*(L"constant\*(R" argument can be
either a \s-1XQL\s0 primitizzle (Number, Boolean, Text) or a \*(L"constant\*(R" function
invocation. I aint talkin' bout chicken n' gravy biatch. E.g.
.Sp
.Vb 5
\& date("12\-03\-1998")
\& true()
\& sin(0.3)
\& length("abc")
\& date(substr("12\-03\-1998 is tha date", 0, 10))
.Ve
.Sp
are constant yo, but not:
.Sp
.Vb 1
\& length(book[2])
.Ve
.Sp
Resultz of constant function invocations is cached n' calculated only once
for each query. Right back up in yo muthafuckin ass. See also tha \s-1CONST\s0 parameta up in defineFunction.
It aint necessary ta wrap constant function invocations up in a \fIonce()\fR call.
.Sp
Constant \s-1XQL\s0 functions are: date, true, false n' a shitload of tha \s-1XQL+\s0
wrappers fo' Perl builtin functions. Function wrappers fo' certain builtins
are not made constant on purpose ta force tha invocation ta be evaluated
every time, e.g. 'mkdir(\*(L"/user/enno/my_dir\*(R", \*(L"0644\*(R")' (although constant
in appearance) may return different thangs up in dis biatch fo' multiple invocations. 
See \f(CW%PerlFunc\fR up in Plus.pm fo' details.
.IP "Function: count ([\s-1QUERY\s0])" 4
.IX Item "Function: count ([QUERY])"
Da \fIcount()\fR function has no parametas up in tha \s-1XQL\s0 spec. In dis implementation
it will return tha number of \s-1QUERY\s0 thangs up in dis biatch when passed a \s-1QUERY\s0 parameter.
.IP "Method: text ([\s-1RECURSE\s0])" 4
.IX Item "Method: text ([RECURSE])"
When expandin a Element node, tha \fItext()\fR method addz tha expanded \fItext()\fR value
of sub-Elements, n' you can put dat on yo' toast. When \s-1RECURSE\s0 is set ta 0 (default is 1), it aint gonna include
sub-elements, n' you can put dat on yo' toast. This is useful e.g. when rockin tha \f(CW$match\fR$ operator up in a recursive
context (usin tha // operator), so it won't return parent Elements when one of
the lil pimps matches.
.IP "Method: rawText ([\s-1RECURSE\s0])" 4
.IX Item "Method: rawText ([RECURSE])"
See \fItext()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
XML::XQL::Query, \s-1XML::XQL::DOM\s0, XML::XQL::Date
.PP
Da Japanese version of dis document can be found on-line at
<http://member.nifty.ne.jp/hippo2000/perltips/xml/xql.htm>
.PP
Da XML::XQL::Tutorial manual page. Da Japanese version can be found at 
<http://member.nifty.ne.jp/hippo2000/perltips/xml/xql/tutorial.htm>
.PP
Da \s-1XQL\s0 spec at <http://www.w3.org/TandS/QL/QL98/pp/xql.html>
.PP
Da Design of \s-1XQL\s0 at <http://www.texcel.no/whitepapers/xql\-design.html>
.PP
Da \s-1DOM\s0 Level 1 justification at <http://www.w3.org/TR/REC\-DOM\-Level\-1>
.PP
Da \s-1XML\s0 spec (Extensible Markup Language 1.0) at <http://www.w3.org/TR/REC\-xml>
.PP
Da XML::Parser n' XML::Parser::Expat manual pages.
.SH "AUTHOR"
.IX Header "AUTHOR"
Enno Derksen is tha original gangsta lyricist.
.PP
Please bust bugs, comments n' suggestions ta T.J. Mather <\fItjmather@tjmather.com\fR>
