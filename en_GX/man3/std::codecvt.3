" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::codecvt< _InternT, _ExternT, _StateT > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBstd::__codecvt_abstract_base< _InternT, _ExternT, _StateT >\fP\&.
.PP
Inherited by \fBstd::codecvt_byname< _InternT, _ExternT, _StateT >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _ExternT \fBextern_type\fP"
.br
.ti -1c
.RI "typedef _InternT \fBintern_type\fP"
.br
.ti -1c
.RI "typedef codecvt_base::result \fBresult\fP"
.br
.ti -1c
.RI "typedef _StateT \fBstate_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBcodecvt\fP (size_t __refs=0)"
.br
.ti -1c
.RI "\fBcodecvt\fP (__c_locale __cloc, size_t __refs=0)"
.br
.ti -1c
.RI "bool \fBalways_noconv\fP () const   throw ()"
.br
.ti -1c
.RI "int \fBencoding\fP () const   throw ()"
.br
.ti -1c
.RI "result \fBin\fP (state_type &__state, const extern_type *__from, const extern_type *__from_end, const extern_type *&__from_next, intern_type *__to, intern_type *__to_end, intern_type *&__to_next) const "
.br
.ti -1c
.RI "int \fBlength\fP (state_type &__state, const extern_type *__from, const extern_type *__end, size_t __max) const "
.br
.ti -1c
.RI "int \fBmax_length\fP () const   throw ()"
.br
.ti -1c
.RI "result \fBout\fP (state_type &__state, const intern_type *__from, const intern_type *__from_end, const intern_type *&__from_next, extern_type *__to, extern_type *__to_end, extern_type *&__to_next) const "
.br
.ti -1c
.RI "result \fBunshift\fP (state_type &__state, extern_type *__to, extern_type *__to_end, extern_type *&__to_next) const "
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static \fBlocale::id\fP \fBid\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual bool \fBdo_always_noconv\fP () const   throw ()"
.br
.ti -1c
.RI "virtual int \fBdo_encoding\fP () const   throw ()"
.br
.ti -1c
.RI "virtual result \fBdo_in\fP (state_type &__state, const extern_type *__from, const extern_type *__from_end, const extern_type *&__from_next, intern_type *__to, intern_type *__to_end, intern_type *&__to_next) const "
.br
.ti -1c
.RI "virtual int \fBdo_length\fP (state_type &, const extern_type *__from, const extern_type *__end, size_t __max) const "
.br
.ti -1c
.RI "virtual int \fBdo_max_length\fP () const   throw ()"
.br
.ti -1c
.RI "virtual result \fBdo_out\fP (state_type &__state, const intern_type *__from, const intern_type *__from_end, const intern_type *&__from_next, extern_type *__to, extern_type *__to_end, extern_type *&__to_next) const "
.br
.ti -1c
.RI "virtual result \fBdo_unshift\fP (state_type &__state, extern_type *__to, extern_type *__to_end, extern_type *&__to_next) const "
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static __c_locale \fB_S_clone_c_locale\fP (__c_locale &__cloc)  throw ()"
.br
.ti -1c
.RI "static void \fB_S_create_c_locale\fP (__c_locale &__cloc, const char *__s, __c_locale __old=0)"
.br
.ti -1c
.RI "static void \fB_S_destroy_c_locale\fP (__c_locale &__cloc)"
.br
.ti -1c
.RI "static __c_locale \fB_S_get_c_locale\fP ()"
.br
.ti -1c
.RI "static const char * \fB_S_get_c_name\fP ()  throw ()"
.br
.ti -1c
.RI "static __c_locale \fB_S_lc_ctype_c_locale\fP (__c_locale __cloc, const char *__s)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "__c_locale \fB_M_c_locale_codecvt\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _InternT, typename _ExternT, typename _StateT>class std::codecvt< _InternT, _ExternT, _StateT >"
Primary class template codecvt\&.
.PP
NB: Generic, mostly useless implementation\&. 
.PP
Definizzle at line 276 of file codecvt\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _InternT , typename _ExternT , typename _StateT > virtual result \fBstd::codecvt\fP< _InternT, _ExternT, _StateT >::do_out (state_type &__state, const intern_type *__from, const intern_type *__from_end, const intern_type *&__from_next, extern_type *__to, extern_type *__to_end, extern_type *&__to_next) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Convert from internal ta external characta set\&. Converts input strang of intern_type ta output strang of extern_type\&. This function be a hook fo' derived classes ta chizzle tha value returned\&. 
.PP
\fBSee Also:\fP
.RS 4
out fo' mo' shiznit\&. 
.RE
.PP

.PP
Implements \fBstd::__codecvt_abstract_base< _InternT, _ExternT, _StateT >\fP\&.
.SS "template<typename _InternT, typename _ExternT, typename _StateT> result \fBstd::__codecvt_abstract_base\fP< _InternT, _ExternT, _StateT >::in (state_type &__state, const extern_type *__from, const extern_type *__from_end, const extern_type *&__from_next, intern_type *__to, intern_type *__to_end, intern_type *&__to_next) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Convert from external ta internal characta set\&. Converts input strang of extern_type ta output strang of intern_type\&. This be analogous ta mbsrtowcs\&. Well shiiiit, it do dis by callin codecvt::do_in\&.
.PP
Da source n' destination characta sets is determined by tha facetz locale, internal n' external types\&.
.PP
Da charactas up in [from,from_end) is converted n' freestyled ta [to,to_end)\&. from_next n' to_next is set ta point ta tha characta followin tha last successfully converted character, respectively\&. If tha result needed no conversion, from_next n' to_next is not affected\&.
.PP
Da \fIstate\fP argument should be initialized if tha input be all up in tha beginnin n' carried from a previous call if continuin conversion\&. There is no guarantees bout how tha fuck \fIstate\fP is used\&.
.PP
Da result returned be a gangmember of codecvt_base::result\&. If all tha input is converted, returns codecvt_base::ok\&. If no conversion is necessary, returns codecvt_base::noconv\&. If tha input endz early or there is insufficient space up in tha output, returns codecvt_base::partial\&. Otherwise tha conversion failed n' codecvt_base::error is returned\&.
.PP
\fBParameters:\fP
.RS 4
\fI__state\fP Persistent conversion state data\&. 
.br
\fI__from\fP Start of input\&. 
.br
\fI__from_end\fP End of input\&. 
.br
\fI__from_next\fP Returns start of unconverted data\&. 
.br
\fI__to\fP Start of output buffer\&. 
.br
\fI__to_end\fP End of output buffer\&. 
.br
\fI__to_next\fP Returns start of unused output area\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
codecvt_base::result\&. 
.RE
.PP

.PP
Definizzle at line 196 of file codecvt\&.h\&.
.SS "template<typename _InternT, typename _ExternT, typename _StateT> result \fBstd::__codecvt_abstract_base\fP< _InternT, _ExternT, _StateT >::out (state_type &__state, const intern_type *__from, const intern_type *__from_end, const intern_type *&__from_next, extern_type *__to, extern_type *__to_end, extern_type *&__to_next) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Convert from internal ta external characta set\&. Converts input strang of intern_type ta output strang of extern_type\&. This be analogous ta wcsrtombs\&. Well shiiiit, it do dis by callin codecvt::do_out\&.
.PP
Da source n' destination characta sets is determined by tha facetz locale, internal n' external types\&.
.PP
Da charactas up in [from,from_end) is converted n' freestyled ta [to,to_end)\&. from_next n' to_next is set ta point ta tha characta followin tha last successfully converted character, respectively\&. If tha result needed no conversion, from_next n' to_next is not affected\&.
.PP
Da \fIstate\fP argument should be initialized if tha input be all up in tha beginnin n' carried from a previous call if continuin conversion\&. There is no guarantees bout how tha fuck \fIstate\fP is used\&.
.PP
Da result returned be a gangmember of codecvt_base::result\&. If all tha input is converted, returns codecvt_base::ok\&. If no conversion is necessary, returns codecvt_base::noconv\&. If tha input endz early or there is insufficient space up in tha output, returns codecvt_base::partial\&. Otherwise tha conversion failed n' codecvt_base::error is returned\&.
.PP
\fBParameters:\fP
.RS 4
\fI__state\fP Persistent conversion state data\&. 
.br
\fI__from\fP Start of input\&. 
.br
\fI__from_end\fP End of input\&. 
.br
\fI__from_next\fP Returns start of unconverted data\&. 
.br
\fI__to\fP Start of output buffer\&. 
.br
\fI__to_end\fP End of output buffer\&. 
.br
\fI__to_next\fP Returns start of unused output area\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
codecvt_base::result\&. 
.RE
.PP

.PP
Definizzle at line 116 of file codecvt\&.h\&.
.SS "template<typename _InternT, typename _ExternT, typename _StateT> result \fBstd::__codecvt_abstract_base\fP< _InternT, _ExternT, _StateT >::unshift (state_type &__state, extern_type *__to, extern_type *__to_end, extern_type *&__to_next) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Reset conversion state\&. Writes charactas ta output dat would restore \fIstate\fP ta initial conditions\&. Da scam is dat if a partial conversion occurs, then tha convertin tha charactas freestyled by dis function would leave tha state up in initial conditions, rather than partial conversion state\&. Well shiiiit, it do dis by callin codecvt::do_unshift()\&.
.PP
For example, if 4 external charactas always converted ta 1 internal character, n' input ta in() had 6 external charactas wit state saved, dis function would write two charactas ta tha output n' set tha state ta initialized conditions\&.
.PP
Da source n' destination characta sets is determined by tha facetz locale, internal n' external types\&.
.PP
Da result returned be a gangmember of codecvt_base::result\&. If tha state could be reset n' data written, returns codecvt_base::ok\&. If no conversion is necessary, returns codecvt_base::noconv\&. If tha output has insufficient space, returns codecvt_base::partial\&. Otherwise tha reset failed n' codecvt_base::error is returned\&.
.PP
\fBParameters:\fP
.RS 4
\fI__state\fP Persistent conversion state data\&. 
.br
\fI__to\fP Start of output buffer\&. 
.br
\fI__to_end\fP End of output buffer\&. 
.br
\fI__to_next\fP Returns start of unused output area\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
codecvt_base::result\&. 
.RE
.PP

.PP
Definizzle at line 155 of file codecvt\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
