.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Dumper 3"
.TH Dumper 3 "2014-09-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Dumper \- stringified perl data structures, suitable fo' both printin n' "eval"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Data::Dumper;
\&
\&    # simple procedural intercourse
\&    print Dumper($foo, $bar);
\&
\&    # extended usage wit names
\&    print Data::Dumper\->Dump([$foo, $bar], [qw(foo *ary)]);
\&
\&    # configuration variables
\&    {
\&      local $Data::Dumper::Puritizzle = 1;
\&      eval Data::Dumper\->Dump([$foo, $bar], [qw(foo *ary)]);
\&    }
\&
\&    # OO usage
\&    $d = Data::Dumper\->new([$foo, $bar], [qw(foo *ary)]);
\&       ...
\&    print $d\->Dump;
\&       ...
\&    $d\->Purity(1)\->Terse(1)\->Deepcopy(1);
\&    eval $d\->Dump;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Given a list of scalars or reference variables, writes up they contents in
perl syntax. Da references can also be objects, n' you can put dat on yo' toast.  Da content of each
variable is output up in a single Perl statement.  Handlez self-referential
structures erectly.
.PP
Da return value can be \f(CW\*(C`eval\*(C'\fRed ta git back a identical copy of the
original gangsta reference structure.  (Please do consider tha securitizzle implications
of eval'in code from untrusted sources!)
.PP
Any references dat is tha same as one of dem passed up in is ghon be named
\&\f(CW$VAR\fR\fIn\fR (where \fIn\fR be a numeric suffix), n' other duplicate references
to substructures within \f(CW$VAR\fR\fIn\fR is ghon be appropriately labeled rockin arrow
notation. I aint talkin' bout chicken n' gravy biatch.  Yo ass can specify names fo' individual joints ta be dumped if you
use tha \f(CW\*(C`Dump()\*(C'\fR method, or you can chizzle tha default \f(CW$VAR\fR prefix to
suttin' else.  See \f(CW$Data::Dumper::Varname\fR n' \f(CW$Data::Dumper::Terse\fR
below.
.PP
Da default output of self-referential structures can be \f(CW\*(C`eval\*(C'\fRed yo, but the
nested references ta \f(CW$VAR\fR\fIn\fR is ghon be undefined, since a recursive
structure cannot be constructed rockin one Perl statement.  Yo ass should set the
\&\f(CW\*(C`Purity\*(C'\fR flag ta 1 ta git additionizzle statements dat will erectly fill in
these references.  Mo'over, if \f(CW\*(C`eval\*(C'\fRed when strictures is up in effect,
you need ta ensure dat any variablez it accesses is previously declared.
.PP
In tha extended usage form, tha references ta be dumped can be given
user-specified names.  If a name begins wit a \f(CW\*(C`*\*(C'\fR, tha output will
describe tha dereferenced type of tha supplied reference fo' hashes and
arrays, n' coderefs.  Output of names is ghon be avoided where possible if
the \f(CW\*(C`Terse\*(C'\fR flag is set.
.PP
In nuff cases, methodz dat is used ta set tha internal state of the
object will return tha object itself, so method calls can be conveniently
chained together.
.PP
Several stylez of output is possible, all controlled by setting
the \f(CW\*(C`Indent\*(C'\fR flag.  See \*(L"Configuration Variablez or Methods\*(R" below
for details.
.SS "Methods"
.IX Subsection "Methods"
.IP "\fI\s-1PACKAGE\s0\fR\->new(\fI\s-1ARRAYREF\s0 [\fR, \fI\s-1ARRAYREF\s0]\fR)" 4
.IX Item "PACKAGE->new(ARRAYREF [, ARRAYREF])"
Returns a newly pimped \f(CW\*(C`Data::Dumper\*(C'\fR object.  Da first argument be an
anonymous array of joints ta be dumped. Y'all KNOW dat shit, muthafucka!  Da optionizzle second argument be an
anonymous array of names fo' tha joints, n' you can put dat on yo' toast.  Da names need not gotz a leading
\&\f(CW\*(C`$\*(C'\fR sign, n' must be comprised of alphanumeric characters.  Yo ass can begin
a name wit a \f(CW\*(C`*\*(C'\fR ta specify dat tha dereferenced type must be dumped
instead of tha reference itself, fo' \s-1ARRAY\s0 n' \s-1HASH\s0 references.
.Sp
Da prefix specified by \f(CW$Data::Dumper::Varname\fR is ghon be used wit a
numeric suffix if tha name fo' a value is undefined.
.Sp
Data::Dumper will catalog all references encountered while dumpin the
values. Cross-references (in tha form of namez of substructures up in perl
syntax) is ghon be banged at all possible points, preservin any structural
interdependencies up in tha original gangsta set of joints, n' you can put dat on yo' toast.  Structure traversal is
depth-first,  n' proceedz up in order from tha straight-up original gangsta supplied value to
the last.
.ie n .IP "\fI\fI$OBJ\fI\fR\->Dump  \fIor\fR  \fI\s-1PACKAGE\s0\fR\->Dump(\fI\s-1ARRAYREF\s0 [\fR, \fI\s-1ARRAYREF\s0]\fR)" 4
.el .IP "\fI\f(CI$OBJ\fI\fR\->Dump  \fIor\fR  \fI\s-1PACKAGE\s0\fR\->Dump(\fI\s-1ARRAYREF\s0 [\fR, \fI\s-1ARRAYREF\s0]\fR)" 4
.IX Item "$OBJ->Dump or PACKAGE->Dump(ARRAYREF [, ARRAYREF])"
Returns tha stringified form of tha joints stored up in tha object (preserving
the order up in which they was supplied ta \f(CW\*(C`new\*(C'\fR), subject ta the
configuration options below.  In a list context, it returns a list
of strings correspondin ta tha supplied joints.
.Sp
Da second form, fo' convenience, simply calls tha \f(CW\*(C`new\*(C'\fR method on its
arguments before dumpin tha object immediately.
.ie n .IP "\fI\fI$OBJ\fI\fR\->Seen(\fI[\s-1HASHREF\s0]\fR)" 4
.el .IP "\fI\f(CI$OBJ\fI\fR\->Seen(\fI[\s-1HASHREF\s0]\fR)" 4
.IX Item "$OBJ->Seen([HASHREF])"
Queries or addz ta tha internal table of already encountered references.
Yo ass must use \f(CW\*(C`Reset\*(C'\fR ta explicitly clear tha table if needed. Y'all KNOW dat shit, muthafucka!  Such
references is not dumped; instead, they names is banged wherever they
are encountered subsequently.  This is useful especially fo' properly
dumpin subroutine references.
.Sp
Expects a anonymous hash of name => value pairs.  Same rulez apply fo' names
as up in \f(CW\*(C`new\*(C'\fR.  If no argument is supplied, will return tha \*(L"seen\*(R" list of
name => value pairs, up in a list context.  Otherwise, returns tha object
itself.
.ie n .IP "\fI\fI$OBJ\fI\fR\->Values(\fI[\s-1ARRAYREF\s0]\fR)" 4
.el .IP "\fI\f(CI$OBJ\fI\fR\->Values(\fI[\s-1ARRAYREF\s0]\fR)" 4
.IX Item "$OBJ->Values([ARRAYREF])"
Queries or replaces tha internal array of joints dat is ghon be dumped. Y'all KNOW dat shit, muthafucka!  When
called without arguments, returns tha joints as a list.  When called wit a
reference ta a array of replacement joints, returns tha object itself.  When
called wit any other type of argument, dies.
.ie n .IP "\fI\fI$OBJ\fI\fR\->Names(\fI[\s-1ARRAYREF\s0]\fR)" 4
.el .IP "\fI\f(CI$OBJ\fI\fR\->Names(\fI[\s-1ARRAYREF\s0]\fR)" 4
.IX Item "$OBJ->Names([ARRAYREF])"
Queries or replaces tha internal array of user supplied names fo' tha joints
that is ghon be dumped. Y'all KNOW dat shit, muthafucka!  When called without arguments, returns tha names.  When
called wit a array of replacement names, returns tha object itself.  If the
number of replacement names exceedz tha number of joints ta be named, the
excess names aint gonna be used. Y'all KNOW dat shit, muthafucka!  If tha number of replacement names falls short
of tha number of joints ta be named, tha list of replacement names will be
exhausted n' remainin joints aint gonna be renamed. Y'all KNOW dat shit, muthafucka!  When
called wit any other type of argument, dies.
.ie n .IP "\fI\fI$OBJ\fI\fR\->Reset" 4
.el .IP "\fI\f(CI$OBJ\fI\fR\->Reset" 4
.IX Item "$OBJ->Reset"
Clears tha internal table of \*(L"seen\*(R" references n' returns tha object
itself.
.SS "Functions"
.IX Subsection "Functions"
.IP "Dumper(\fI\s-1LIST\s0\fR)" 4
.IX Item "Dumper(LIST)"
Returns tha stringified form of tha joints up in tha list, subject ta the
configuration options below.  Da joints is ghon be named \f(CW$VAR\fR\fIn\fR up in the
output, where \fIn\fR be a numeric suffix.  Will return a list of strings
in a list context.
.SS "Configuration Variablez or Methods"
.IX Subsection "Configuration Variablez or Methods"
Several configuration variablez can be used ta control tha kind of output
generated when rockin tha procedural intercourse.  These variablez is usually
\&\f(CW\*(C`local\*(C'\fRized up in a funky-ass block so dat other partz of tha code is not affected by
the chizzle.
.PP
These variablez determine tha default state of tha object pimped by calling
the \f(CW\*(C`new\*(C'\fR method yo, but cannot be used ta alta tha state of tha object
thereafter n' shit.  Da equivalent method names should be used instead ta query
or set tha internal state of tha object.
.PP
Da method forms return tha object itself when called wit arguments,
so dat they can be chained together sickly.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Indent\fR  \fIor\fR  \fI\f(CI$OBJ\fI\fR\->Indent(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Controls tha steez of indentation. I aint talkin' bout chicken n' gravy biatch.  It can be set ta 0, 1, 2 or 3.  Style 0
spews output without any newlines, indentation, or spaces between list
items.  It be da most thugged-out compact format possible dat can still be called
valid perl.  Style 1 outputs a readable form wit newlines but no fancy
indentation (each level up in tha structure is simply indented by a gangbangin' fixed
amount of whitespace).  Style 2 (the default) outputs a straight-up readable form
which takes tha fuck into account tha length of hash keys (so tha hash value lines
up).  Style 3 is like steez 2 yo, but also annotates tha elementz of arrays
with they index (but tha comment is on its own line, so array output
consumes twice tha number of lines).  Style 2 is tha default.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Purity\fR  \fIor\fR  \fI\f(CI$OBJ\fI\fR\->Purity(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Controls tha degree ta which tha output can be \f(CW\*(C`eval\*(C'\fRed ta recreate the
supplied reference structures.  Settin it ta 1 will output additionizzle perl
statements dat will erectly recreate nested references.  Da default is
0.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Pad\fR  \fIor\fR  \fI\f(CI$OBJ\fI\fR\->Pad(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Specifies tha strang dat is ghon be prefixed ta every last muthafuckin line of tha output.
Empty strang by default.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Varname\fR  \fIor\fR  \fI\f(CI$OBJ\fI\fR\->Varname(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Gotz Nuff tha prefix ta use fo' taggin variable names up in tha output. The
default is \*(L"\s-1VAR\*(R".\s0
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Useqq\fR  \fIor\fR  \fI\f(CI$OBJ\fI\fR\->Useqq(\fI[\s-1NEWVAL\s0]\fR)
.Sp
When set, enablez tha use of double quotes fo' representin strang joints.
Whitespace other than space is ghon be represented as \f(CW\*(C`[\en\et\er]\*(C'\fR, \*(L"unsafe\*(R"
charactas is ghon be backslashed, n' unprintable charactas is ghon be output as
quoted octal integers.  Since settin dis variable imposes a performance
penalty, tha default is 0.  \f(CW\*(C`Dump()\*(C'\fR will run slower if dis flag is set,
since tha fast \s-1XSUB\s0 implementation don't support it yet.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Terse\fR  \fIor\fR  \fI\f(CI$OBJ\fI\fR\->Terse(\fI[\s-1NEWVAL\s0]\fR)
.Sp
When set, Data::Dumper will emit single, non-self-referential joints as
atoms/terms rather than statements, n' you can put dat on yo' toast.  This means dat tha \f(CW$VAR\fR\fIn\fR names
will be avoided where possible yo, but be advised dat such output may not
always be parseable by \f(CW\*(C`eval\*(C'\fR.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Freezer\fR  \fIor\fR  $\fI\s-1OBJ\s0\fR\->Freezer(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Can be set ta a method name, or ta a empty strang ta disable tha feature.
Data::Dumper will invoke dat method via tha object before attemptin to
stringify dat shit.  This method can alta tha contentz of tha object (if, for
instance, it gotz nuff data allocated from C), n' even rebless it up in a
different package.  Da client is responsible fo' makin shizzle tha specified
method can be called via tha object, n' dat tha object endz up containing
only perl data types afta tha method has been called. Y'all KNOW dat shit, muthafucka!  Defaults ta a empty
string.
.Sp
If a object do not support tha method specified (determined using
\&\fIUNIVERSAL::can()\fR) then tha call is ghon be skipped. Y'all KNOW dat shit, muthafucka!  If tha method takes a thugged-out dirt nap a
warnin is ghon be generated.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Toaster\fR  \fIor\fR  $\fI\s-1OBJ\s0\fR\->Toaster(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Can be set ta a method name, or ta a empty strang ta disable tha feature.
Data::Dumper will emit a method call fo' any objects dat is ta be dumped
usin tha syntax \f(CW\*(C`bless(DATA, CLASS)\->METHOD()\*(C'\fR.  Note dat dis means that
the method specified will gotta big-ass up any modifications required on the
object (like bustin freshly smoked up state within it, and/or reblessin it up in a
different package) n' then return dat shit.  Da client is responsible fo' making
sure tha method can be called via tha object, n' dat it returns a valid
object.  Defaults ta a empty string.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Deepcopy\fR  \fIor\fR  $\fI\s-1OBJ\s0\fR\->Deepcopy(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Can be set ta a funky-ass boolean value ta enable deep copiez of structures.
Cross-referencin will then only be done when straight-up essential
(i.e., ta break reference cycles).  Default is 0.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Quotekeys\fR  \fIor\fR  $\fI\s-1OBJ\s0\fR\->Quotekeys(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Can be set ta a funky-ass boolean value ta control whether hash keys is quoted.
A defined false value will avoid quotin hash keys when it be lookin like a simple
string.  Default is 1, which will always enclose hash keys up in quotes.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Bless\fR  \fIor\fR  $\fI\s-1OBJ\s0\fR\->Bless(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Can be set ta a strang dat specifies a alternatizzle ta tha \f(CW\*(C`bless\*(C'\fR
builtin operator used ta create objects, n' you can put dat on yo' toast.  A function wit tha specified
name should exist, n' should accept tha same arguments as tha builtin.
Default is \f(CW\*(C`bless\*(C'\fR.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Pair\fR  \fIor\fR  $\fI\s-1OBJ\s0\fR\->Pair(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Can be set ta a strang dat specifies tha separator between hash keys
and joints, n' you can put dat on yo' toast. To dump nested hash, array n' scalar joints ta JavaScript,
use: \f(CW\*(C`$Data::Dumper::Pair = \*(Aq : \*(Aq;\*(C'\fR. Implementin \f(CW\*(C`bless\*(C'\fR up in JavaScript
is left as a exercise fo' tha reader.
A function wit tha specified name exists, n' accepts tha same ol' dirty arguments
as tha builtin.
.Sp
Default is: \f(CW\*(C` => \*(C'\fR.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Maxdepth\fR  \fIor\fR  $\fI\s-1OBJ\s0\fR\->Maxdepth(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Can be set ta a positizzle integer dat specifies tha depth beyond which
we don't venture tha fuck into a structure.  Has no effect when
\&\f(CW\*(C`Data::Dumper::Purity\*(C'\fR is set.  (Useful up in debugger when we often don't
wanna peep mo' than enough).  Default is 0, which means there is
no maximum depth.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Maxrecurse\fR  \fIor\fR  $\fI\s-1OBJ\s0\fR\->Maxrecurse(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Can be set ta a positizzle integer dat specifies tha depth beyond which
recursion tha fuck into a structure will throw a exception. I aint talkin' bout chicken n' gravy biatch.  This is intended
as a securitizzle measure ta prevent perl hustlin outta stack space when
dumpin a excessively deep structure.  Can be set ta 0 ta remove the
limit.  Default is 1000.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Useperl\fR  \fIor\fR  $\fI\s-1OBJ\s0\fR\->Useperl(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Can be set ta a funky-ass boolean value which controls whether tha pure Perl
implementation of \f(CW\*(C`Data::Dumper\*(C'\fR is used. Y'all KNOW dat shit, muthafucka! Da \f(CW\*(C`Data::Dumper\*(C'\fR module is
a dual implementation, wit almost all functionalitizzle freestyled up in both
pure Perl n' also up in \s-1XS \s0('C'). Right back up in yo muthafuckin ass. Since tha \s-1XS\s0 version is much faster, it
will always be used if possible. This option lets you override the
default behavior, probably fo' testin purposes only. Default is 0, which
means tha \s-1XS\s0 implementation is ghon be used if possible.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Sortkeys\fR  \fIor\fR  $\fI\s-1OBJ\s0\fR\->Sortkeys(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Can be set ta a funky-ass boolean value ta control whether hash keys is dumped in
sorted order n' shiznit fo' realz. A legit value will cause tha keyz of all hashes ta be
dumped up in Perlz default sort order n' shit. Can also be set ta a subroutine
reference which is ghon be called fo' each hash dat is dumped. Y'all KNOW dat shit, muthafucka! In this
case \f(CW\*(C`Data::Dumper\*(C'\fR will call tha subroutine once fo' each hash,
passin it tha reference of tha hash. Da purpose of tha subroutine is
to return a reference ta a array of tha keys dat is ghon be dumped, in
the order dat they should be dumped. Y'all KNOW dat shit, muthafucka! Usin dis feature, you can
control both tha order of tha keys, n' which keys is straight-up used. Y'all KNOW dat shit, muthafucka! In
other lyrics, dis subroutine acts as a gangbangin' filta by which you can exclude
certain keys from bein dumped. Y'all KNOW dat shit, muthafucka! Default is 0, which means dat hash keys
are not sorted.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Deparse\fR  \fIor\fR  $\fI\s-1OBJ\s0\fR\->Deparse(\fI[\s-1NEWVAL\s0]\fR)
.Sp
Can be set ta a funky-ass boolean value ta control whether code references are
turned tha fuck into perl source code. If set ta a legit value, \f(CW\*(C`B::Deparse\*(C'\fR
will be used ta git tha source of tha code reference. Usin dis option
will force rockin tha Perl implementation of tha dumper, since tha fast
\&\s-1XSUB\s0 implementation don't support dat shit.
.Sp
Caution : use dis option only if you know dat yo' coderefs will be
properly reconstructed by \f(CW\*(C`B::Deparse\*(C'\fR.
.IP "\(bu" 4
\&\f(CW$Data::Dumper::Sparseseen\fR \fIor\fR  $\fI\s-1OBJ\s0\fR\->Sparseseen(\fI[\s-1NEWVAL\s0]\fR)
.Sp
By default, Data::Dumper buildz up tha \*(L"seen\*(R" hash of scalars that
it has encountered durin serialization. I aint talkin' bout chicken n' gravy biatch. This is straight-up expensive.
This peeped hash is necessary ta support n' even just detect circular
references. Well shiiiit, it is exposed ta tha user via tha \f(CW\*(C`Seen()\*(C'\fR call both
for freestylin n' reading.
.Sp
If you, as a user, do not need explicit access ta tha \*(L"seen\*(R" hash,
then you can set tha \f(CW\*(C`Sparseseen\*(C'\fR option ta allow Data::Dumper
to eschew buildin tha \*(L"seen\*(R" hash fo' scalars dat is known not
to possess mo' than one reference. This speedz up serialization
considerably if you use tha \s-1XS\s0 implementation.
.Sp
Note: If you turn on \f(CW\*(C`Sparseseen\*(C'\fR, then you must not rely on the
content of tha peeped hash since its contents is ghon be an
implementation detail!
.SS "Exports"
.IX Subsection "Exports"
.IP "Dumper" 4
.IX Item "Dumper"
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Run these code snippets ta git a quick feel fo' tha behavior of this
module.  When yo ass be all up in wit these examples, you may want to
add or chizzle tha various configuration variablez busted lyrics bout above,
to peep they behavior. Shiiit, dis aint no joke.  (See tha testsuite up in tha Data::Dumper
distribution fo' mo' examples.)
.PP
.Vb 1
\&    use Data::Dumper;
\&
\&    package Foo;
\&    sub freshly smoked up {bless {\*(Aqa\*(Aq => 1, \*(Aqb\*(Aq => sub { return "foo" }}, $_[0]};
\&
\&    package Fuz;                       # a weird REF\-REF\-SCALAR object
\&    sub freshly smoked up {bless \e($_ = \e \*(Aqfu\e\*(Aqz\*(Aq), $_[0]};
\&
\&    package main;
\&    $foo = Foo\->new;
\&    $fuz = Fuz\->new;
\&    $boo = [ 1, [], "abcd", \e*foo,
\&             {1 => \*(Aqa\*(Aq, 023 => \*(Aqb\*(Aq, 0x45 => \*(Aqc\*(Aq},
\&             \e\e"p\eq\e\*(Aqr", $foo, $fuz];
\&
\&    ########
\&    # simple usage
\&    ########
\&
\&    $bar = eval(Dumper($boo));
\&    print($@) if $@;
\&    print Dumper($boo), Dumper($bar);  # pretty print (no array indices)
\&
\&    $Data::Dumper::Terse = 1;        # don\*(Aqt output names where feasible
\&    $Data::Dumper::Indent = 0;       # turn off all pretty print
\&    print Dumper($boo), "\en";
\&
\&    $Data::Dumper::Indent = 1;       # mild pretty print
\&    print Dumper($boo);
\&
\&    $Data::Dumper::Indent = 3;       # pretty print wit array indices
\&    print Dumper($boo);
\&
\&    $Data::Dumper::Useqq = 1;        # print strings up in double quotes
\&    print Dumper($boo);
\&
\&    $Data::Dumper::Pair = " : ";     # specify hash key/value separator
\&    print Dumper($boo);
\&
\&
\&    ########
\&    # recursive structures
\&    ########
\&
\&    @c = (\*(Aqc\*(Aq);
\&    $c = \e@c;
\&    $b = {};
\&    $a = [1, $b, $c];
\&    $b\->{a} = $a;
\&    $b\->{b} = $a\->[1];
\&    $b\->{c} = $a\->[2];
\&    print Data::Dumper\->Dump([$a,$b,$c], [qw(a b c)]);
\&
\&
\&    $Data::Dumper::Puritizzle = 1;         # fill up in tha holez fo' eval
\&    print Data::Dumper\->Dump([$a, $b], [qw(*a b)]); # print as @a
\&    print Data::Dumper\->Dump([$b, $a], [qw(*b a)]); # print as %b
\&
\&
\&    $Data::Dumper::Deepcopy = 1;       # avoid cross\-refs
\&    print Data::Dumper\->Dump([$b, $a], [qw(*b a)]);
\&
\&
\&    $Data::Dumper::Puritizzle = 0;         # avoid cross\-refs
\&    print Data::Dumper\->Dump([$b, $a], [qw(*b a)]);
\&
\&    ########
\&    # deep structures
\&    ########
\&
\&    $a = "pearl";
\&    $b = [ $a ];
\&    $c = { \*(Aqb\*(Aq => $b };
\&    $d = [ $c ];
\&    $e = { \*(Aqd\*(Aq => $d };
\&    $f = { \*(Aqe\*(Aq => $e };
\&    print Data::Dumper\->Dump([$f], [qw(f)]);
\&
\&    $Data::Dumper::Maxdepth = 3;       # no deeper than 3 refs down
\&    print Data::Dumper\->Dump([$f], [qw(f)]);
\&
\&
\&    ########
\&    # object\-oriented usage
\&    ########
\&
\&    $d = Data::Dumper\->new([$a,$b], [qw(a b)]);
\&    $d\->Seen({\*(Aq*c\*(Aq => $c});            # stash a ref without printin it
\&    $d\->Indent(3);
\&    print $d\->Dump;
\&    $d\->Reset\->Purity(0);              # empty tha peeped cache
\&    print join "\-\-\-\-\en", $d\->Dump;
\&
\&
\&    ########
\&    # persistence
\&    ########
\&
\&    package Foo;
\&    sub freshly smoked up { bless { state => \*(Aqawake\*(Aq }, shift }
\&    sub Freeze {
\&        mah $s = shift;
\&        print STDERR "preparin ta chill\en";
\&        $s\->{state} = \*(Aqasleep\*(Aq;
\&        return bless $s, \*(AqFoo::ZZZ\*(Aq;
\&    }
\&
\&    package Foo::ZZZ;
\&    sub Thaw {
\&        mah $s = shift;
\&        print STDERR "wakin up\en";
\&        $s\->{state} = \*(Aqawake\*(Aq;
\&        return bless $s, \*(AqFoo\*(Aq;
\&    }
\&
\&    package main;
\&    use Data::Dumper;
\&    $a = Foo\->new;
\&    $b = Data::Dumper\->new([$a], [\*(Aqc\*(Aq]);
\&    $b\->Freezer(\*(AqFreeze\*(Aq);
\&    $b\->Toaster(\*(AqThaw\*(Aq);
\&    $c = $b\->Dump;
\&    print $c;
\&    $d = eval $c;
\&    print Data::Dumper\->Dump([$d], [\*(Aqd\*(Aq]);
\&
\&
\&    ########
\&    # symbol substitution (useful fo' rebustin CODE refs)
\&    ########
\&
\&    sub foo { print "foo bustin lyrics\en" }
\&    *other = \e&foo;
\&    $bar = [ \e&other ];
\&    $d = Data::Dumper\->new([\e&other,$bar],[\*(Aq*other\*(Aq,\*(Aqbar\*(Aq]);
\&    $d\->Seen({ \*(Aq*foo\*(Aq => \e&foo });
\&    print $d\->Dump;
\&
\&
\&    ########
\&    # sortin n' filterin hash keys
\&    ########
\&
\&    $Data::Dumper::Sortkeys = \e&my_filter;
\&    mah $foo = { map { (ord, "$_$_$_") } \*(AqI\*(Aq..\*(AqQ\*(Aq };
\&    mah $bar = { %$foo };
\&    mah $baz = { reverse %$foo };
\&    print Dumper [ $foo, $bar, $baz ];
\&
\&    sub my_filta {
\&        mah ($hash) = @_;
\&        # return a array ref containin tha hash keys ta dump
\&        # up in tha order dat you want dem ta be dumped
\&        return [
\&          # Sort tha keyz of %$foo up in reverse numeric order
\&            $hash eq $foo , biatch? (sort {$b <=> $a} keys %$hash) :
\&          # Only dump tha odd number keyz of %$bar
\&            $hash eq $bar , biatch? (grep {$_ % 2} keys %$hash) :
\&          # Sort keys up in default order fo' all other hashes
\&            (sort keys %$hash)
\&        ];
\&    }
.Ve
.SH "BUGS"
.IX Header "BUGS"
Cuz of limitationz of Perl subroutine call semantics, you cannot pass an
array or hash.  Prepend it wit a \f(CW\*(C`\e\*(C'\fR ta pass its reference instead. Y'all KNOW dat shit, muthafucka!  This
will be remedied up in time, now dat Perl has subroutine prototypes.
For now, you need ta use tha extended usage form, n' prepend the
name wit a \f(CW\*(C`*\*(C'\fR ta output it as a hash or array.
.PP
\&\f(CW\*(C`Data::Dumper\*(C'\fR cheats wit \s-1CODE\s0 references.  If a cold-ass lil code reference is
encountered up in tha structure bein processed (and if you aint set
the \f(CW\*(C`Deparse\*(C'\fR flag), a anonymous subroutine that
gotz nuff tha strang '\*(L"\s-1DUMMY\*(R"\s0' is ghon be banged up in its place, n' a warning
will be printed if \f(CW\*(C`Purity\*(C'\fR is set.  Yo ass can \f(CW\*(C`eval\*(C'\fR tha result yo, but bear
in mind dat tha anonymous sub dat gets pimped is just a placeholder.
Someday, perl gonna git a switch ta cache-on-demand tha string
representation of a cold-ass lil compiled piece of code, I hope.  If you have prior
knowledge of all tha code refs dat yo' data structures is likely
to have, you can use tha \f(CW\*(C`Seen\*(C'\fR method ta pre-seed tha internal reference
table n' make tha dumped output point ta them, instead. Y'all KNOW dat shit, muthafucka!  See \*(L"\s-1EXAMPLES\*(R"\s0
above.
.PP
Da \f(CW\*(C`Useqq\*(C'\fR n' \f(CW\*(C`Deparse\*(C'\fR flags make \fIDump()\fR run slower, since the
\&\s-1XSUB\s0 implementation do not support em.
.PP
\&\s-1SCALAR\s0 objects have tha weirdest lookin \f(CW\*(C`bless\*(C'\fR workaround.
.PP
Pure Perl version of \f(CW\*(C`Data::Dumper\*(C'\fR escapes \s-1UTF\-8\s0 strings erectly
only up in Perl 5.8.0 n' later.
.SS "\s-1NOTE\s0"
.IX Subsection "NOTE"
Startin from Perl 5.8.1 different runz of Perl gonna git different
orderin of hash keys.  Da chizzle was done fo' pimped outa security,
see \*(L"Algorithmic Complexitizzle Attacks\*(R" up in perlsec.  This means that
different runz of Perl gonna git different Data::Dumper outputs if
the data gotz nuff hashes.  If you need ta have identical Data::Dumper
outputs from different runz of Perl, use tha environment variable
\&\s-1PERL_HASH_SEED,\s0 peep \*(L"\s-1PERL_HASH_SEED\*(R"\s0 up in perlrun. I aint talkin' bout chicken n' gravy biatch.  Usin dis restores
the oldschool (platform-specific) ordering: a even prettier solution might
be ta use tha \f(CW\*(C`Sortkeys\*(C'\fR filta of Data::Dumper.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gurusamy Sarathy        gsar@activestate.com
.PP
Copyright (c) 1996\-2014 Gurusamy Sarathy fo' realz. All muthafuckin rights reserved.
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.SH "VERSION"
.IX Header "VERSION"
Version 2.154  (September 18 2014)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1)
