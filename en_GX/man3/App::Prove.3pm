.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "App::Prove 3"
.TH App::Prove 3 "2013-05-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
App::Prove \- Implements tha "prove" command.
.SH "VERSION"
.IX Header "VERSION"
Version 3.28
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Test::Harnizz serves up a cold-ass lil command, \f(CW\*(C`prove\*(C'\fR, which runs a \s-1TAP\s0 based
test suite n' prints a report. Da \f(CW\*(C`prove\*(C'\fR command be a minimal
wrapper round a instizzle of dis module.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use App::Prove;
\&
\&    mah $app = App::Prove\->new;
\&    $app\->process_args(@ARGV);
\&    $app\->run;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Smoke a freshly smoked up \f(CW\*(C`App::Prove\*(C'\fR. Optionally a hash ref of attribute
initializers may be passed.
.PP
\fI\f(CI\*(C`state_class\*(C'\fI\fR
.IX Subsection "state_class"
.PP
Getter/setta fo' tha name of tha class used fo' maintainin state.  This
class should either subclass from \f(CW\*(C`App::Prove::State\*(C'\fR or provide a identical
interface.
.PP
\fI\f(CI\*(C`state_manager\*(C'\fI\fR
.IX Subsection "state_manager"
.PP
Getter/setta fo' tha instizzle of tha \f(CW\*(C`state_class\*(C'\fR.
.PP
\fI\f(CI\*(C`add_rc_file\*(C'\fI\fR
.IX Subsection "add_rc_file"
.PP
.Vb 1
\&    $prove\->add_rc_file(\*(Aqmyproj/.proverc\*(Aq);
.Ve
.PP
Called before \f(CW\*(C`process_args\*(C'\fR ta prepend tha contentz of a rc file to
the options.
.PP
\fI\f(CI\*(C`process_args\*(C'\fI\fR
.IX Subsection "process_args"
.PP
.Vb 1
\&    $prove\->process_args(@args);
.Ve
.PP
Processes tha command-line arguments fo' realz. Attributes is ghon be set
appropriately fo' realz. Any filenames may be found up in tha \f(CW\*(C`argv\*(C'\fR attribute.
.PP
Dies on invalid arguments.
.PP
\fI\f(CI\*(C`run\*(C'\fI\fR
.IX Subsection "run"
.PP
Perform whatever actions tha command line args specified. Y'all KNOW dat shit, muthafucka! Da \f(CW\*(C`prove\*(C'\fR
command line tool consistz of tha followin code:
.PP
.Vb 1
\&    use App::Prove;
\&
\&    mah $app = App::Prove\->new;
\&    $app\->process_args(@ARGV);
\&    exit( $app\->run ? 0 : 1 );  # if you need tha exit code
.Ve
.PP
\fI\f(CI\*(C`require_harness\*(C'\fI\fR
.IX Subsection "require_harness"
.PP
Load a harnizz replacement class.
.PP
.Vb 1
\&  $prove\->require_harness($for => $class_name);
.Ve
.PP
\fI\f(CI\*(C`print_version\*(C'\fI\fR
.IX Subsection "print_version"
.PP
Display tha version numberz of tha loaded TAP::Harnizz n' the
current Perl.
.SS "Attributes"
.IX Subsection "Attributes"
Afta command line parsin tha followin attributes reflect tha joints
of tha correspondin command line switches. They may be altered before
callin \f(CW\*(C`run\*(C'\fR.
.ie n .IP """archive""" 4
.el .IP "\f(CWarchive\fR" 4
.IX Item "archive"
.PD 0
.ie n .IP """argv""" 4
.el .IP "\f(CWargv\fR" 4
.IX Item "argv"
.ie n .IP """backwards""" 4
.el .IP "\f(CWbackwards\fR" 4
.IX Item "backwards"
.ie n .IP """blib""" 4
.el .IP "\f(CWblib\fR" 4
.IX Item "blib"
.ie n .IP """color""" 4
.el .IP "\f(CWcolor\fR" 4
.IX Item "color"
.ie n .IP """directives""" 4
.el .IP "\f(CWdirectives\fR" 4
.IX Item "directives"
.ie n .IP """dry""" 4
.el .IP "\f(CWdry\fR" 4
.IX Item "dry"
.ie n .IP """exec""" 4
.el .IP "\f(CWexec\fR" 4
.IX Item "exec"
.ie n .IP """extensions""" 4
.el .IP "\f(CWextensions\fR" 4
.IX Item "extensions"
.ie n .IP """failures""" 4
.el .IP "\f(CWfailures\fR" 4
.IX Item "failures"
.ie n .IP """comments""" 4
.el .IP "\f(CWcomments\fR" 4
.IX Item "comments"
.ie n .IP """formatter""" 4
.el .IP "\f(CWformatter\fR" 4
.IX Item "formatter"
.ie n .IP """harness""" 4
.el .IP "\f(CWharness\fR" 4
.IX Item "harness"
.ie n .IP """ignore_exit""" 4
.el .IP "\f(CWignore_exit\fR" 4
.IX Item "ignore_exit"
.ie n .IP """includes""" 4
.el .IP "\f(CWincludes\fR" 4
.IX Item "includes"
.ie n .IP """jobs""" 4
.el .IP "\f(CWjobs\fR" 4
.IX Item "jobs"
.ie n .IP """lib""" 4
.el .IP "\f(CWlib\fR" 4
.IX Item "lib"
.ie n .IP """merge""" 4
.el .IP "\f(CWmerge\fR" 4
.IX Item "merge"
.ie n .IP """modules""" 4
.el .IP "\f(CWmodules\fR" 4
.IX Item "modules"
.ie n .IP """parse""" 4
.el .IP "\f(CWparse\fR" 4
.IX Item "parse"
.ie n .IP """plugins""" 4
.el .IP "\f(CWplugins\fR" 4
.IX Item "plugins"
.ie n .IP """quiet""" 4
.el .IP "\f(CWquiet\fR" 4
.IX Item "quiet"
.ie n .IP """really_quiet""" 4
.el .IP "\f(CWreally_quiet\fR" 4
.IX Item "really_quiet"
.ie n .IP """recurse""" 4
.el .IP "\f(CWrecurse\fR" 4
.IX Item "recurse"
.ie n .IP """rules""" 4
.el .IP "\f(CWrules\fR" 4
.IX Item "rules"
.ie n .IP """show_count""" 4
.el .IP "\f(CWshow_count\fR" 4
.IX Item "show_count"
.ie n .IP """show_help""" 4
.el .IP "\f(CWshow_help\fR" 4
.IX Item "show_help"
.ie n .IP """show_man""" 4
.el .IP "\f(CWshow_man\fR" 4
.IX Item "show_man"
.ie n .IP """show_version""" 4
.el .IP "\f(CWshow_version\fR" 4
.IX Item "show_version"
.ie n .IP """shuffle""" 4
.el .IP "\f(CWshuffle\fR" 4
.IX Item "shuffle"
.ie n .IP """state""" 4
.el .IP "\f(CWstate\fR" 4
.IX Item "state"
.ie n .IP """state_class""" 4
.el .IP "\f(CWstate_class\fR" 4
.IX Item "state_class"
.ie n .IP """taint_fail""" 4
.el .IP "\f(CWtaint_fail\fR" 4
.IX Item "taint_fail"
.ie n .IP """taint_warn""" 4
.el .IP "\f(CWtaint_warn\fR" 4
.IX Item "taint_warn"
.ie n .IP """test_args""" 4
.el .IP "\f(CWtest_args\fR" 4
.IX Item "test_args"
.ie n .IP """timer""" 4
.el .IP "\f(CWtimer\fR" 4
.IX Item "timer"
.ie n .IP """verbose""" 4
.el .IP "\f(CWverbose\fR" 4
.IX Item "verbose"
.ie n .IP """warnings_fail""" 4
.el .IP "\f(CWwarnings_fail\fR" 4
.IX Item "warnings_fail"
.ie n .IP """warnings_warn""" 4
.el .IP "\f(CWwarnings_warn\fR" 4
.IX Item "warnings_warn"
.ie n .IP """tapversion""" 4
.el .IP "\f(CWtapversion\fR" 4
.IX Item "tapversion"
.ie n .IP """trap""" 4
.el .IP "\f(CWtrap\fR" 4
.IX Item "trap"
.PD
.SH "PLUGINS"
.IX Header "PLUGINS"
\&\f(CW\*(C`App::Prove\*(C'\fR serves up support fo' 3rd\-party plugins.  These is currently
loaded at run-time, \fIafter\fR arguments done been parsed (so you can not
change tha way arguments is processed, sorry), typically wit the
\&\f(CW\*(C`\-P\f(CIplugin\f(CW\*(C'\fR switch, eg:
.PP
.Vb 1
\&  prove \-PMyPlugin
.Ve
.PP
This will search fo' a module named \f(CW\*(C`App::Prove::Plugin::MyPlugin\*(C'\fR, or failing
that, \f(CW\*(C`MyPlugin\*(C'\fR.  If tha plugin can't be found, \f(CW\*(C`prove\*(C'\fR will diss & exit.
.PP
Yo ass can pass a argument ta yo' plugin by appendin a \f(CW\*(C`=\*(C'\fR afta tha plugin
name, eg \f(CW\*(C`\-PMyPlugin=foo\*(C'\fR.  Yo ass can pass multiple arguments rockin commas:
.PP
.Vb 1
\&  prove \-PMyPlugin=foo,bar,baz
.Ve
.PP
These is passed up in ta yo' pluginz \f(CW\*(C`load()\*(C'\fR class method (if it has one),
along wit a reference ta tha \f(CW\*(C`App::Prove\*(C'\fR object dat is invokin yo' plugin:
.PP
.Vb 2
\&  sub load {
\&      mah ($class, $p) = @_;
\&
\&      mah @args = @{ $p\->{args} };
\&      # @args will contain ( \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq )
\&      $p\->{app_prove}\->do_something;
\&      ...
\&  }
.Ve
.PP
Note dat tha userz arguments is also passed ta yo' pluginz \f(CW\*(C`import()\*(C'\fR
function as a list, eg:
.PP
.Vb 5
\&  sub import {
\&      mah ($class, @args) = @_;
\&      # @args will contain ( \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq )
\&      ...
\&  }
.Ve
.PP
This is fo' backwardz compatibility, n' may be deprecated up in tha future.
.SS "Sample Plugin"
.IX Subsection "Sample Plugin"
Herez a sample plugin, fo' yo' reference:
.PP
.Vb 1
\&  package App::Prove::Plugin::Foo;
\&
\&  # Sample plugin, try hustlin with:
\&  # prove \-PFoo=bar \-r \-j3
\&  # prove \-PFoo \-Q
\&  # prove \-PFoo=bar,My::Formatter
\&
\&  use strict;
\&  use warnings;
\&
\&  sub load {
\&      mah ($class, $p) = @_;
\&      mah @args = @{ $p\->{args} };
\&      mah $app  = $p\->{app_prove};
\&
\&      print "loadin plugin: $class, args: ", join(\*(Aq, \*(Aq, @args ), "\en";
\&
\&      # turn on verbosity
\&      $app\->verbose( 1 );
\&
\&      # set tha formatter?
\&      $app\->formatter( $args[1] ) if @args > 1;
\&
\&      # print a shitload of App::Prove\*(Aqs state:
\&      fo' mah $attr (qw( thangs on tha down-low straight-up_quiet recurse verbose )) {
\&          mah $val = $app\->$attr;
\&          $val    = \*(Aqundef\*(Aq unless defined( $val );
\&          print "$attr: $val\en";
\&      }
\&
\&      return 1;
\&  }
\&
\&  1;
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
prove, TAP::Harness
