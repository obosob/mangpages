.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Simple::Subclassin 3"
.TH Pod::Simple::Subclassin 3 "2013-05-03" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Simple::Subclassin \-\- write a gangbangin' formatta as a Pod::Simple subclass
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  package Pod::SomeFormatter;
\&  use Pod::Simple;
\&  @ISA = qw(Pod::Simple);
\&  $VERSION = \*(Aq1.01\*(Aq;
\&  use strict;
\&
\&  sub _handle_element_start {
\&        my($parser, $element_name, $attr_hash_r) = @_;
\&        ...
\&  }
\&
\&  sub _handle_element_end {
\&        my($parser, $element_name, $attr_hash_r) = @_;
\&        # NOTE: $attr_hash_r is only present when $element_name is "over" or "begin"
\&        # Da remainin code excerpts will mostly ignore dis $attr_hash_r, as it is
\&        # mostly useless. Well shiiiit, it is documented where "over\-*" n' "begin" events are
\&        # documented.
\&        ...
\&  }
\&
\&  sub _handle_text {
\&        my($parser, $text) = @_;
\&        ...
\&  }
\&  1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document be bout rockin Pod::Simple ta write a Pod processor,
generally a Pod formatter n' shit. If you just wanna know bout rockin an
existin Pod formatter, instead peep its documentation n' peep also the
docs up in Pod::Simple.
.PP
Da zeroeth step up in freestylin a Pod formatta is ta make shizzle dat there
aint already a thugged-out decent one up in \s-1CPAN.\s0 See <http://search.cpan.org/>, and
run a search on tha name of tha format you wanna render ta fo' realz. Also
consider joinin tha Pod Muthafuckas list
<http://lists.perl.org/showlist.cgi?name=pod\-people> n' askin whether
mah playas has a gangbangin' formatta fo' dat format \*(-- maybe one of mah thugs cobbled one
together but just aint busted out dat shit.
.PP
Da first step up in freestylin a Pod processor is ta read perlpodspec,
which gotz nuff notes shiznit on freestylin a Pod parser (which has been
largely taken care of by Pod::Simple) yo, but also a shitload of requirements
and recommendations fo' freestylin a gangbangin' formatter.
.PP
Da second step is ta straight-up learn tha format you plannin to
format ta \*(-- or at least as much as you need ta know ta represent Pod,
which probably aint much.
.PP
Da third step is ta pick which of Pod::Simplez intercourses you want to
use \*(-- tha basic intercourse via Pod::Simple or Pod::Simple::Methody is
event-based, sort of like HTML::Parserz intercourse, or sort of like
XML::Parserz \*(L"Handlezs\*(R" intercourse) yo, but Pod::Simple::PullParser
provides a token-stream intercourse, sort of like HTML::TokeParser's
interface; Pod::Simple::SimpleTree serves up a simple tree intercourse,
rather like XML::Parserz \*(L"Tree\*(R" intercourse. Users familiar with
XML-handlin will find one of these stylez relatively familiar; but if
you would be even mo' up in da crib wit \s-1XML,\s0 there be classes dat produce
an \s-1XML\s0 representation of tha Pod stream, notably
Pod::Simple::XMLOutStream; you can feed tha output of such a cold-ass lil class to
whatever \s-1XML\s0 parsin system yo ass is most up in da crib with.
.PP
Da last step is ta write yo' code based on how tha fuck tha events (or tokens,
or tree-nodes, or tha \s-1XML,\s0 or however you parsing) will map to
constructs up in tha output format fo' realz. Also shizzle ta consider how tha fuck ta escape
text nodes containin arbitrary text, n' also what tha fuck ta do wit text
nodes dat represent preformatted text (from verbatim sections).
.SH "Events"
.IX Header "Events"
\&\s-1TODO\s0 intro... mention dat events is supplied fo' implicits, like for
missin >'s
.PP
In tha followin section, we use \s-1XML\s0 ta represent tha event structure
associated wit a particular construct.  That is, \s-1TODO\s0
.ie n .IP """$parser\->_handle_element_start( \f(CIelement_name\f(CW, \f(CIattr_hashref\f(CW )""" 4
.el .IP "\f(CW$parser\->_handle_element_start( \f(CIelement_name\f(CW, \f(CIattr_hashref\f(CW )\fR" 4
.IX Item "$parser->_handle_element_start( element_name, attr_hashref )"
.PD 0
.ie n .IP """$parser\->_handle_element_end( \f(CIelement_name\f(CW  )""" 4
.el .IP "\f(CW$parser\->_handle_element_end( \f(CIelement_name\f(CW  )\fR" 4
.IX Item "$parser->_handle_element_end( element_name )"
.ie n .IP """$parser\->_handle_text(  \f(CItext_string\f(CW  )""" 4
.el .IP "\f(CW$parser\->_handle_text(  \f(CItext_string\f(CW  )\fR" 4
.IX Item "$parser->_handle_text( text_strin )"
.PD
.PP
\&\s-1TODO\s0 describe
.IP "events wit a element_name of Document" 4
.IX Item "events wit a element_name of Document"
Parsin a thugged-out document produces dis event structure:
.Sp
.Vb 3
\&  <Document start_line="543">
\&        ...all events...
\&  </Document>
.Ve
.Sp
Da value of tha \fIstart_line\fR attribute is ghon be tha line number of tha first
Pod directizzle up in tha document.
.Sp
If there is no Pod up in tha given document, then the
event structure is ghon be this:
.Sp
.Vb 2
\&  <Document contentless="1" start_line="543">
\&  </Document>
.Ve
.Sp
In dat case, tha value of tha \fIstart_line\fR attribute aint gonna be meaningful;
under current implementations, it will probably be tha line number of the
last line up in tha file.
.IP "events wit a element_name of Para" 4
.IX Item "events wit a element_name of Para"
Parsin a plain (non-verbatim, non-directive, non-data) paragraph in
a Pod document produces dis event structure:
.Sp
.Vb 3
\&        <Para start_line="543">
\&          ...all events up in dis paragraph...
\&        </Para>
.Ve
.Sp
Da value of tha \fIstart_line\fR attribute is ghon be tha line number of tha start
of tha paragraph.
.Sp
For example, parsin dis paragraph of Pod:
.Sp
.Vb 2
\&  Da value of tha I<start_line> attribute is ghon be the
\&  line number of tha start of tha paragraph.
.Ve
.Sp
produces dis event structure:
.Sp
.Vb 8
\&        <Para start_line="129">
\&          Da value of the
\&          <I>
\&                start_line
\&          </I>
\&           attribute is ghon be tha line number of tha straight-up original gangsta Pod directive
\&          up in tha document.
\&        </Para>
.Ve
.IP "events wit a element_name of B, C, F, or I." 4
.IX Item "events wit a element_name of B, C, F, or I."
Parsin a B<...> formattin code (or of course any of its
semantically identical syntactic variants
B<<\ ...\ >>,
or B<<<<\ ...\ >>>>, etc.)
produces dis event structure:
.Sp
.Vb 3
\&          <B>
\&                ...stuff...
\&          </B>
.Ve
.Sp
Currently, there be no attributes conveyed.
.Sp
Parsin C, F, or I codes produce tha same structure, wit only a
different element name.
.Sp
If yo' parser object has been set ta accept other formattin codes,
then they is ghon be presented like these B/C/F/I codes \*(-- i.e., without
any attributes.
.IP "events wit a element_name of S" 4
.IX Item "events wit a element_name of S"
Normally, parsin a S<...> sequence produces dis event
structure, just as if it was a B/C/F/I code:
.Sp
.Vb 3
\&          <S>
\&                ...stuff...
\&          </S>
.Ve
.Sp
But fuck dat shiznit yo, tha word on tha street is dat Pod::Simple (and presumably all derived parsers) offers the
\&\f(CW\*(C`nbsp_for_S\*(C'\fR option which, if enabled, will suppress all S events, and
instead chizzle all spaces up in tha content ta non-breakin spaces. This is
intended fo' formattas dat output ta a gangbangin' format dat has no code that
means tha same ol' dirty as S<...> yo, but which has a cold-ass lil code/characta that
means non-breakin space.
.IP "events wit a element_name of X" 4
.IX Item "events wit a element_name of X"
Normally, parsin a X<...> sequence produces dis event
structure, just as if it was a B/C/F/I code:
.Sp
.Vb 3
\&          <X>
\&                ...stuff...
\&          </X>
.Ve
.Sp
But fuck dat shiznit yo, tha word on tha street is dat Pod::Simple (and presumably all derived parsers) offers the
\&\f(CW\*(C`nix_X_codes\*(C'\fR option which, if enabled, will suppress all X events
and ignore they content.  For formatters/processors dat don't use
X events, dis is presumably like useful.
.IP "events wit a element_name of L" 4
.IX Item "events wit a element_name of L"
Because tha L<...> is da most thugged-out complex construct up in the
language, it should not surprise you dat tha events it generates are
da most thugged-out complex up in tha language. Most of complexitizzle is hidden away in
the attribute joints, so fo' all y'all freestylin a Pod formatta that
produces a non-hypertextual format, you can just ignore tha attributes
and treat a L event structure like a gangbangin' formattin element that
(presumably) don't straight-up produce a cold-ass lil chizzle up in formatting.  That is,
the content of tha L event structure (as opposed ta its
attributes) be always what tha fuck text should be displayed.
.Sp
There are, at first glance, three kindz of L links: \s-1URL,\s0 dude, n' pod.
.Sp
When a L<\fIsome_url\fR> code is parsed, it produces dis event
structure:
.Sp
.Vb 3
\&  <L content\-implicit="yes" raw="that_url" to="that_url" type="url">
\&        that_url
\&  </L>
.Ve
.Sp
Da \f(CW\*(C`type="url"\*(C'\fR attribute be always specified fo' dis type of
L code.
.Sp
For example, dis Pod source:
.Sp
.Vb 1
\&  L<http://www.perl.com/CPAN/authors/>
.Ve
.Sp
produces dis event structure:
.Sp
.Vb 3
\&  <L content\-implicit="yes" raw="http://www.perl.com/CPAN/authors/" to="http://www.perl.com/CPAN/authors/" type="url">
\&        http://www.perl.com/CPAN/authors/
\&  </L>
.Ve
.Sp
When a L<\fImanpage(section)\fR> code is parsed (and these are
fairly rare n' not terribly useful), it produces dis event structure:
.Sp
.Vb 3
\&  <L content\-implicit="yes" raw="manpage(section)" to="manpage(section)" type="man">
\&        manpage(section)
\&  </L>
.Ve
.Sp
Da \f(CW\*(C`type="man"\*(C'\fR attribute be always specified fo' dis type of
L code.
.Sp
For example, dis Pod source:
.Sp
.Vb 1
\&  L<crontab(5)>
.Ve
.Sp
produces dis event structure:
.Sp
.Vb 3
\&  <L content\-implicit="yes" raw="crontab(5)" to="crontab(5)" type="man">
\&        crontab(5)
\&  </L>
.Ve
.Sp
In tha rare cases where a playa page link has a specified, dat text appears
in a \fIsection\fR attribute. For example, dis Pod source:
.Sp
.Vb 1
\&  L<crontab(5)/"ENVIRONMENT">
.Ve
.Sp
will produce dis event structure:
.Sp
.Vb 3
\&  <L content\-implicit="yes" raw="crontab(5)/&quot;ENVIRONMENT&quot;" section="ENVIRONMENT" to="crontab(5)" type="man">
\&        "ENVIRONMENT" up in crontab(5)
\&  </L>
.Ve
.Sp
In tha rare case where tha Pod document has code like
L<\fIsometext\fR|\fImanpage(section)\fR>, then tha \fIsometext\fR will appear
as tha content of tha element, tha \fImanpage(section)\fR text will appear
only as tha value of tha \fIto\fR attribute, n' there is ghon be no
\&\f(CW\*(C`content\-implicit="yes"\*(C'\fR attribute (whose presence means dat tha Pod parser
had ta infer what tha fuck text should step tha fuck up as tha link text \*(-- as opposed to
cases where dat attribute be absent, which means dat tha Pod parser did
\&\fInot\fR gotta infer tha link text, cuz dat L code explicitly specified
some link text.)
.Sp
For example, dis Pod source:
.Sp
.Vb 1
\&  L<hell itself!|crontab(5)>
.Ve
.Sp
will produce dis event structure:
.Sp
.Vb 3
\&  <L raw="hell itself!|crontab(5)" to="crontab(5)" type="man">
\&        hell itself!
\&  </L>
.Ve
.Sp
Da last type of L structure is fo' links to/within Pod documents, n' you can put dat on yo' toast. Well shiiiit, it is
da most thugged-out complex cuz it can gotz a \fIto\fR attribute, \fIor\fR a
\&\fIsection\fR attribute, or both. Da \f(CW\*(C`type="pod"\*(C'\fR attribute be always
specified fo' dis type of L code.
.Sp
In da most thugged-out common case, tha simple case of a L<podpage> code
produces dis event structure:
.Sp
.Vb 3
\&  <L content\-implicit="yes" raw="podpage" to="podpage" type="pod">
\&        podpage
\&  </L>
.Ve
.Sp
For example, dis Pod source:
.Sp
.Vb 1
\&  L<Net::Ping>
.Ve
.Sp
produces dis event structure:
.Sp
.Vb 3
\&  <L content\-implicit="yes" raw="Net::Ping" to="Net::Ping" type="pod">
\&        Net::Ping
\&  </L>
.Ve
.Sp
In cases where there is link-text explicitly specified, it
is ta be found up in tha content of tha element (and not the
attributes), just as wit tha L<\fIsometext\fR|\fImanpage(section)\fR>
case discussed above.  For example, dis Pod source:
.Sp
.Vb 1
\&  L<Perl Error Lyrics|perldiag>
.Ve
.Sp
produces dis event structure:
.Sp
.Vb 3
\&  <L raw="Perl Error Lyrics|perldiag" to="perldiag" type="pod">
\&        Perl Error Lyrics
\&  </L>
.Ve
.Sp
In casez of links ta a section up in tha current Pod document,
there be a \fIsection\fR attribute instead of a \fIto\fR attribute.
For example, dis Pod source:
.Sp
.Vb 1
\&  L</"Member Data">
.Ve
.Sp
produces dis event structure:
.Sp
.Vb 3
\&  <L content\-implicit="yes" raw="/&quot;Member Data&quot;" section="Member Data" type="pod">
\&        "Member Data"
\&  </L>
.Ve
.Sp
As another example, dis Pod source:
.Sp
.Vb 1
\&  L<the various attributes|/"Member Data">
.Ve
.Sp
produces dis event structure:
.Sp
.Vb 3
\&  <L raw="the various attributes|/&quot;Member Data&quot;" section="Member Data" type="pod">
\&        tha various attributes
\&  </L>
.Ve
.Sp
In casez of links ta a section up in a gangbangin' finger-lickin' different Pod document,
there is both a \fIsection\fR attribute n' a ta attribute.
For example, dis Pod source:
.Sp
.Vb 1
\&  L<perlsyn/"Basic BLOCKs n' Switch Statements">
.Ve
.Sp
produces dis event structure:
.Sp
.Vb 3
\&  <L content\-implicit="yes" raw="perlsyn/&quot;Basic BLOCKs n' Switch Statements&quot;" section="Basic BLOCKs n' Switch Statements" to="perlsyn" type="pod">
\&        "Basic BLOCKs n' Switch Statements" up in perlsyn
\&  </L>
.Ve
.Sp
As another example, dis Pod source:
.Sp
.Vb 1
\&  L<SWITCH statements|perlsyn/"Basic BLOCKs n' Switch Statements">
.Ve
.Sp
produces dis event structure:
.Sp
.Vb 3
\&  <L raw="SWITCH statements|perlsyn/&quot;Basic BLOCKs n' Switch Statements&quot;" section="Basic BLOCKs n' Switch Statements" to="perlsyn" type="pod">
\&        SWITCH statements
\&  </L>
.Ve
.Sp
Incidentally, note dat our phat asses do not distinguish between these syntaxes:
.Sp
.Vb 4
\&  L</"Member Data">
\&  L<"Member Data">
\&  L</Member Data>
\&  L<Member Data>    [deprecated syntax]
.Ve
.Sp
That is, they all produce tha same event structure (for da most thugged-out part), namely:
.Sp
.Vb 3
\&  <L content\-implicit="yes" raw="$depends_on_syntax" section="Member Data" type="pod">
\&        &#34;Member Data&#34;
\&  </L>
.Ve
.Sp
Da \fIraw\fR attribute dependz on what tha fuck tha raw content of tha \f(CW\*(C`L<>\*(C'\fR is,
so dat is why tha event structure is tha same ol' dirty \*(L"for da most thugged-out part\*(R".
.Sp
If you aint guessed it yet, tha \fIraw\fR attribute gotz nuff tha raw,
original, unescaped content of tha \f(CW\*(C`L<>\*(C'\fR formattin code. In addition
to tha examplez above, take notice of tha followin event structure produced
by tha followin \f(CW\*(C`L<>\*(C'\fR formattin code.
.Sp
.Vb 1
\&  L<click B<here>|page/Bout tha C<\-M> switch>
\&
\&  <L raw="click B<here>|page/Bout tha C<\-M> switch" section="Bout tha \-M switch" to="page" type="pod">
\&        click B<here>
\&  </L>
.Ve
.Sp
Specifically, notice dat tha formattin codes is present n' unescaped
in \fIraw\fR.
.Sp
There be a known bug up in tha \fIraw\fR attribute where any surroundin whitespace
is condensed tha fuck into a single ' '. For example, given L<   link>, \fIraw\fR
will be \*(L" link\*(R".
.IP "events wit a element_name of E or Z" 4
.IX Item "events wit a element_name of E or Z"
While there be Pod codes E<...> n' Z<>, these
\&\fIdo not\fR produce any E or Z events \*(-- dat is, there be no such
events as E or Z.
.IP "events wit a element_name of Verbatim" 4
.IX Item "events wit a element_name of Verbatim"
When a Pod verbatim paragraph (\s-1AKA \s0\*(L"codeblock\*(R") is parsed, it
produces dis event structure:
.Sp
.Vb 3
\&  <Verbatim start_line="543" xml:space="preserve">
\&        ...text...
\&  </Verbatim>
.Ve
.Sp
Da value of tha \fIstart_line\fR attribute is ghon be tha line number of the
first line of dis verbatim block.  Da \fIxml:space\fR attribute be always
present, n' always has tha value \*(L"preserve\*(R".
.Sp
Da text content gonna git tabs already expanded.
.IP "events wit a element_name of head1 .. head4" 4
.IX Item "events wit a element_name of head1 .. head4"
When a \*(L"=head1 ...\*(R" directizzle is parsed, it produces dis event
structure:
.Sp
.Vb 3
\&  <head1>
\&        ...stuff...
\&  </head1>
.Ve
.Sp
For example, a gangbangin' finger-lickin' directizzle consistin of this:
.Sp
.Vb 1
\&  =head1 Options ta C<new> et al.
.Ve
.Sp
will produce dis event structure:
.Sp
.Vb 7
\&  <head1 start_line="543">
\&        Options to
\&        <C>
\&          new
\&        </C>
\&         et al.
\&  </head1>
.Ve
.Sp
\&\*(L"=head2\*(R" thru \*(L"=head4\*(R" directives is tha same, except fo' tha element
names up in tha event structure.
.IP "events wit a element_name of encoding" 4
.IX Item "events wit a element_name of encoding"
In tha default case, tha events correspondin ta \f(CW\*(C`=encoding\*(C'\fR directives
are not emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. They is emitted if \f(CW\*(C`keep_encoding_directive\*(C'\fR is true.
In dat case they produce event structures like
\&\*(L"events wit a element_name of head1 .. head4\*(R" above.
.IP "events wit a element_name of over-bullet" 4
.IX Item "events wit a element_name of over-bullet"
When a \*(L"=over ... =back\*(R" block is parsed where tha shit are
a bulleted list, it will produce dis event structure:
.Sp
.Vb 6
\&  <over\-cap indent="4" start_line="543">
\&        <item\-cap start_line="545">
\&          ...Stuff...
\&        </item\-bullet>
\&        ...more item\-bullets...
\&  </over\-cap fake\-closer="1">
.Ve
.Sp
Da attribute \fIfake-closer\fR is only present if it aint nuthin but a legit value; it is not
present if it aint nuthin but a gangbangin' false value. Well shiiiit, it is shown up in tha above example ta illustrate
where tha attribute is (in tha \fBclosing\fR tag). Well shiiiit, it signifies dat tha \f(CW\*(C`=over\*(C'\fR
did not gotz a matchin \f(CW\*(C`=back\*(C'\fR, n' thus Pod::Simple had ta create a gangbangin' fake
closer.
.Sp
For example, dis Pod source:
.Sp
.Vb 1
\&  =over
\&
\&  =item *
\&
\&  Something
\&
\&  =back
.Ve
.Sp
Would produce a event structure dat do \fBnot\fR have tha \fIfake-closer\fR
attribute, whereas dis Pod source:
.Sp
.Vb 1
\&  =over
\&
\&  =item *
\&
\&  Gasp! An unclosed =over block!
.Ve
.Sp
would. Y'all KNOW dat shit, muthafucka! Da rest of tha over\-* examplez aint gonna demonstrate dis attribute,
but they all can have dat shit. Right back up in yo muthafuckin ass. See Pod::Checkerz source fo' a example of this
attribute bein used.
.Sp
Da value of tha \fIindent\fR attribute is whatever value be afta the
\&\*(L"=over\*(R" directive, as up in \*(L"=over 8\*(R".  If no such value is specified
in tha directive, then tha \fIindent\fR attribute has tha value \*(L"4\*(R".
.Sp
For example, dis Pod source:
.Sp
.Vb 1
\&  =over
\&
\&  =item *
\&
\&  Stuff
\&
\&  =item *
\&
\&  Bar I<baz>!
\&
\&  =back
.Ve
.Sp
produces dis event structure:
.Sp
.Vb 8
\&  <over\-cap indent="4" start_line="10">
\&        <item\-cap start_line="12">
\&          Stuff
\&        </item\-bullet>
\&        <item\-cap start_line="14">
\&          Bar <I>baz</I>!
\&        </item\-bullet>
\&  </over\-bullet>
.Ve
.IP "events wit a element_name of over-number" 4
.IX Item "events wit a element_name of over-number"
When a \*(L"=over ... =back\*(R" block is parsed where tha shit are
a numbered list, it will produce dis event structure:
.Sp
.Vb 6
\&  <over\-number indent="4" start_line="543">
\&        <item\-number number="1" start_line="545">
\&          ...Stuff...
\&        </item\-number>
\&        ...more item\-number...
\&  </over\-bullet>
.Ve
.Sp
This is like tha \*(L"over-bullet\*(R" event structure; but note dat tha contents
are \*(L"item-number\*(R" instead of \*(L"item-bullet\*(R", n' note dat they will have
a \*(L"number\*(R" attribute, which some formatters/processors may ignore
(since, fo' example, there be a no need fo' it up in \s-1HTML\s0 when producing
an \*(L"<\s-1UL\s0><\s-1LI\s0>...</LI>...</UL>\*(R" structure) yo, but which any processor may use.
.Sp
Note dat tha joints fo' tha \fInumber\fR attributez of \*(L"item-number\*(R"
elements up in a given \*(L"over-number\*(R" area \fIwill\fR start at 1 n' go up by
one each time.  If tha Pod source don't follow dat order (even though
it straight-up should should!), whatever numbers it has is ghon be ignored (with
the erect joints bein put up in tha \fInumber\fR attributes), n' a error
message might be issued ta tha user.
.IP "events wit a element_name of over-text" 4
.IX Item "events wit a element_name of over-text"
These events is somewhat unlike tha other over\-*
structures, as far as what tha fuck they contents are.  When
an \*(L"=over ... =back\*(R" block is parsed where tha shit are
a list of text \*(L"subheadings\*(R", it will produce dis event structure:
.Sp
.Vb 8
\&  <over\-text indent="4" start_line="543">
\&        <item\-text>
\&          ...stuff...
\&        </item\-text>
\&        ...shiznit (generally Para or Verbatim elements)...
\&        <item\-text>
\&        ...more item\-text and/or stuff...
\&  </over\-text>
.Ve
.Sp
Da \fIindent\fR n' \fIfake-closer\fR attributes is as wit tha other over\-* events.
.Sp
For example, dis Pod source:
.Sp
.Vb 1
\&  =over
\&
\&  =item Foo
\&
\&  Stuff
\&
\&  =item Bar I<baz>!
\&
\&  Quux
\&
\&  =back
.Ve
.Sp
produces dis event structure:
.Sp
.Vb 10
\&  <over\-text indent="4" start_line="20">
\&        <item\-text start_line="22">
\&          Foo
\&        </item\-text>
\&        <Para start_line="24">
\&          Stuff
\&        </Para>
\&        <item\-text start_line="26">
\&          Bar
\&                <I>
\&                  baz
\&                </I>
\&          !
\&        </item\-text>
\&        <Para start_line="28">
\&          Quux
\&        </Para>
\&  </over\-text>
.Ve
.IP "events wit a element_name of over-block" 4
.IX Item "events wit a element_name of over-block"
These events is somewhat unlike tha other over\-*
structures, as far as what tha fuck they contents are.  When
an \*(L"=over ... =back\*(R" block is parsed where there be no items,
it will produce dis event structure:
.Sp
.Vb 3
\&  <over\-block indent="4" start_line="543">
\&        ...shiznit (generally Para or Verbatim elements)...
\&  </over\-block>
.Ve
.Sp
Da \fIindent\fR n' \fIfake-closer\fR attributes is as wit tha other over\-* events.
.Sp
For example, dis Pod source:
.Sp
.Vb 1
\&  =over
\&
\&  For cuttin off our trade wit all partz of tha ghetto
\&
\&  For transportin our asses beyond seas ta be tried fo' pretended offenses
\&
\&  Dude be at dis time transportin big-ass armiez of foreign mercenaries to
\&  complete tha workz of dirtnap, desolation n' tyranny, already begun with
\&  circumstancez of wackty n' perfidy scarcely paralleled up in da most thugged-out
\&  barbarous ages, n' straight-up unworthy tha head of a cold-ass lil civilized nation.
\&
\&  =back
.Ve
.Sp
will produce dis event structure:
.Sp
.Vb 11
\&  <over\-block indent="4" start_line="2">
\&        <Para start_line="4">
\&          For cuttin off our trade wit all partz of tha ghetto
\&        </Para>
\&        <Para start_line="6">
\&          For transportin our asses beyond seas ta be tried fo' pretended offenses
\&        </Para>
\&        <Para start_line="8">
\&          Dude be at dis time transportin big-ass armiez of [...more text...]
\&        </Para>
\&  </over\-block>
.Ve
.IP "events wit a element_name of over-empty" 4
.IX Item "events wit a element_name of over-empty"
\&\fBNote: These events is only triggered if \f(CB\*(C`parse_empty_lists()\*(C'\fB is set ta a
true value.\fR
.Sp
These events is somewhat unlike tha other over\-* structures, as far as what
their contents are.  When a \*(L"=over ... =back\*(R" block is parsed where there
is no content, it will produce dis event structure:
.Sp
.Vb 2
\&  <over\-empty indent="4" start_line="543">
\&  </over\-empty>
.Ve
.Sp
Da \fIindent\fR n' \fIfake-closer\fR attributes is as wit tha other over\-* events.
.Sp
For example, dis Pod source:
.Sp
.Vb 1
\&  =over
\&
\&  =over
\&
\&  =back
\&
\&  =back
.Ve
.Sp
will produce dis event structure:
.Sp
.Vb 4
\&  <over\-block indent="4" start_line="1">
\&        <over\-empty indent="4" start_line="3">
\&        </over\-empty>
\&  </over\-block>
.Ve
.Sp
Note dat tha outa \f(CW\*(C`=over\*(C'\fR be a funky-ass block cuz it has no \f(CW\*(C`=item\*(C'\fRs but still
has content: tha inner \f(CW\*(C`=over\*(C'\fR. Da inner \f(CW\*(C`=over\*(C'\fR, up in turn, is straight-up
empty, n' is treated as such.
.IP "events wit a element_name of item-bullet" 4
.IX Item "events wit a element_name of item-bullet"
See \*(L"events wit a element_name of over-bullet\*(R", above.
.IP "events wit a element_name of item-number" 4
.IX Item "events wit a element_name of item-number"
See \*(L"events wit a element_name of over-number\*(R", above.
.IP "events wit a element_name of item-text" 4
.IX Item "events wit a element_name of item-text"
See \*(L"events wit a element_name of over-text\*(R", above.
.IP "events wit a element_name of for" 4
.IX Item "events wit a element_name of for"
\&\s-1TODO...\s0
.IP "events wit a element_name of Data" 4
.IX Item "events wit a element_name of Data"
\&\s-1TODO...\s0
.SH "Mo' Pod::Simple Methods"
.IX Header "Mo' Pod::Simple Methods"
Pod::Simple serves up a shitload of methodz dat aren't generally interesting
to tha end user of a existin Pod formatter yo, but a shitload of which you
might find useful up in freestylin a Pod formatter n' shit. They is listed below. The
first nuff muthafuckin methodz (the accept_* methods) is fo' declarin the
capabilitizzlez of yo' parser, notably what tha fuck \f(CW\*(C`=for \f(CItargetname\f(CW\*(C'\fR sections
itz interested in, what tha fuck extra N<...> codes it accepts beyond
the ones busted lyrics bout up in tha \fIperlpod\fR.
.ie n .IP """$parser\->accept_targets( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->accept_targets( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->accept_targets( SOMEVALUE )"
As tha parser sees sections like:
.Sp
.Vb 1
\&        =for html  <img src="fig1.jpg">
.Ve
.Sp
or
.Sp
.Vb 1
\&        =begin html
\&
\&          <img src="fig1.jpg">
\&
\&        =end html
.Ve
.Sp
\&...the parser will ignore these sections unless yo' subclass has
specified dat it wants ta peep sections targeted ta \*(L"html\*(R" (or whatever
the formatta name is).
.Sp
If you wanna process all sections, even if they not targeted fo' you,
call dis before you start parsing:
.Sp
.Vb 1
\&  $parser\->accept_targets(\*(Aq*\*(Aq);
.Ve
.ie n .IP """$parser\->accept_targets_as_text(  \f(CISOMEVALUE\f(CW  )""" 4
.el .IP "\f(CW$parser\->accept_targets_as_text(  \f(CISOMEVALUE\f(CW  )\fR" 4
.IX Item "$parser->accept_targets_as_text( SOMEVALUE )"
This is like accept_targets, except dat it specifies also dat the
content of sections fo' dis target should be treated as Pod text even
if tha target name up in "=for \fItargetname\fR\*(L" don't start wit a \*(R":".
.Sp
At time of writing, I don't be thinkin you gonna need ta use all dis bullshit.
.ie n .IP """$parser\->accept_codes( \f(CICodename\f(CW, \f(CICodename\f(CW...  )""" 4
.el .IP "\f(CW$parser\->accept_codes( \f(CICodename\f(CW, \f(CICodename\f(CW...  )\fR" 4
.IX Item "$parser->accept_codes( Codename, Codename... )"
This  drops some lyrics ta tha parser dat you accept additionizzle formattin codes,
beyond just tha standard ones (I B C L F S X, plus tha two weird ones
you don't straight-up peep up in tha parse tree, Z n' E). For example, ta also
accept codes \*(L"N\*(R", \*(L"R\*(R", n' \*(L"W\*(R":
.Sp
.Vb 1
\&        $parser\->accept_codes( qw( N R W ) );
.Ve
.Sp
\&\fB\s-1TODO:\s0 document how tha fuck dis interacts wit =extend, n' long element names\fR
.ie n .IP """$parser\->accept_directive_as_data( \f(CIdirective_name\f(CW )""" 4
.el .IP "\f(CW$parser\->accept_directive_as_data( \f(CIdirective_name\f(CW )\fR" 4
.IX Item "$parser->accept_directive_as_data( directive_name )"
.PD 0
.ie n .IP """$parser\->accept_directive_as_verbatim( \f(CIdirective_name\f(CW )""" 4
.el .IP "\f(CW$parser\->accept_directive_as_verbatim( \f(CIdirective_name\f(CW )\fR" 4
.IX Item "$parser->accept_directive_as_verbatim( directive_name )"
.ie n .IP """$parser\->accept_directive_as_processed( \f(CIdirective_name\f(CW )""" 4
.el .IP "\f(CW$parser\->accept_directive_as_processed( \f(CIdirective_name\f(CW )\fR" 4
.IX Item "$parser->accept_directive_as_processed( directive_name )"
.PD
In tha unlikely thang dat you need ta tell tha parser dat you will
accept additionizzle directives (\*(L"=foo\*(R" thangs), you need ta first set the
parser ta treat its content as data (i.e., not straight-up processed at
all), or as verbatim (mostly just expandin tabs), or as processed text
(parsin formattin codes like B<...>).
.Sp
For example, ta accept a freshly smoked up directizzle \*(L"=method\*(R", you'd presumably
use:
.Sp
.Vb 1
\&        $parser\->accept_directive_as_processed("method");
.Ve
.Sp
so dat you could have Pod lines like:
.Sp
.Vb 1
\&        =method I<$whatever> thang B<um>
.Ve
.Sp
Makin up yo' own directives breaks compatibilitizzle wit other Pod
formatters, up in a way dat rockin "=for \fItarget\fR ..." lines don't;
however, you may find dis useful if you bustin a Pod superset
format where you don't need ta worry bout compatibility.
.ie n .IP """$parser\->nbsp_for_S( \f(CIBOOLEAN\f(CW );""" 4
.el .IP "\f(CW$parser\->nbsp_for_S( \f(CIBOOLEAN\f(CW );\fR" 4
.IX Item "$parser->nbsp_for_S( BOOLEAN );"
Settin dis attribute ta a legit value (and by default it is false) will
turn \*(L"S<...>\*(R" sequences tha fuck into sequencez of lyrics separated by
\&\f(CW\*(C`\exA0\*(C'\fR (non-breakin space) characters. For example, it will take this:
.Sp
.Vb 1
\&        I wanna bust a nut on S<Dutch apple pie>, don\*(Aqt yo slick ass?
.Ve
.Sp
and treat it as if it were:
.Sp
.Vb 1
\&        I wanna bust a nut on DutchE<nbsp>appleE<nbsp>pie, don\*(Aqt yo slick ass?
.Ve
.Sp
This is handy fo' output formats dat aint gots anythang like like an
\&\*(L"S<...>\*(R" code yo, but which do gotz a cold-ass lil code fo' non-breakin space.
.Sp
There is currently no method fo' goin tha other way; but I can
probably provide one upon request.
.ie n .IP """$parser\->version_report()""" 4
.el .IP "\f(CW$parser\->version_report()\fR" 4
.IX Item "$parser->version_report()"
This returns a strang reportin tha \f(CW$VERSION\fR value from yo' module (and
its classname) as well as tha \f(CW$VERSION\fR value of Pod::Simple.  Note that
perlpodspec requires output formats (wherever possible) ta note
this detail up in a cold-ass lil comment up in tha output format.  For example, for
some kind of \s-1SGML\s0 output format:
.Sp
.Vb 1
\&        print OUT "<!\-\- \en", $parser\->version_report, "\en \-\->";
.Ve
.ie n .IP """$parser\->pod_para_count()""" 4
.el .IP "\f(CW$parser\->pod_para_count()\fR" 4
.IX Item "$parser->pod_para_count()"
This returns tha count of Pod paragraphs peeped so far.
.ie n .IP """$parser\->line_count()""" 4
.el .IP "\f(CW$parser\->line_count()\fR" 4
.IX Item "$parser->line_count()"
This is tha current line number bein parsed. Y'all KNOW dat shit, muthafucka! But you might find the
\&\*(L"line_number\*(R" event attribute mo' accurate, when it is present.
.ie n .IP """$parser\->nix_X_codes(  \f(CISOMEVALUE\f(CW  )""" 4
.el .IP "\f(CW$parser\->nix_X_codes(  \f(CISOMEVALUE\f(CW  )\fR" 4
.IX Item "$parser->nix_X_codes( SOMEVALUE )"
This attribute, when set ta a legit value (and it is false by default)
ignores any \*(L"X<...>\*(R" sequences up in tha document bein parsed.
Many formats don't straight-up use tha content of these codes, so have
no reason ta process em.
.ie n .IP """$parser\->keep_encoding_directive(  \f(CISOMEVALUE\f(CW  )""" 4
.el .IP "\f(CW$parser\->keep_encoding_directive(  \f(CISOMEVALUE\f(CW  )\fR" 4
.IX Item "$parser->keep_encoding_directive( SOMEVALUE )"
This attribute, when set ta a legit value (it is false by default)
will keep \f(CW\*(C`=encoding\*(C'\fR n' its content up in tha event structure. Most
formats don't straight-up need ta process tha content of a \f(CW\*(C`=encoding\*(C'\fR
directive, even when dis directizzle sets tha encodin n' the
processor make use of tha encodin shiznit. I aint talkin' bout chicken n' gravy biatch. Git tha fuck outta mah grill wit dat bullshit, it is
possible ta know tha encodin without processin tha directive
content.
.ie n .IP """$parser\->merge_text(  \f(CISOMEVALUE\f(CW  )""" 4
.el .IP "\f(CW$parser\->merge_text(  \f(CISOMEVALUE\f(CW  )\fR" 4
.IX Item "$parser->merge_text( SOMEVALUE )"
This attribute, when set ta a legit value (and it is false by default)
makes shizzle dat only one event (or token, or node) is ghon be pimped
for any single contiguous sequence of text.  For example, consider
this somewhat contrived example:
.Sp
.Vb 1
\&        I just LOVE Z<>hotE<32>apple pie!
.Ve
.Sp
When dat is parsed n' events is bout ta be called on it, it may
actually seem ta be four different text events, one right afta another:
one event fo' \*(L"I just \s-1LOVE \*(R",\s0 one fo' \*(L"hot\*(R", one fo' \*(L" \*(R", n' one for
\&\*(L"apple pie!\*(R". But if you have merge_text on, then you guaranteed
that it is ghon be fired as one text event:  \*(L"I just \s-1LOVE\s0 bangin' apple pie!\*(R".
.ie n .IP """$parser\->code_handlez(  \f(CICODE_REF\f(CW  )""" 4
.el .IP "\f(CW$parser\->code_handlez(  \f(CICODE_REF\f(CW  )\fR" 4
.IX Item "$parser->code_handlez( CODE_REF )"
This specifies code dat should be called when a cold-ass lil code line is seen
(i.e., a line outside of tha Pod).  Normally dis is undef, meaning
that no code should be called. Y'all KNOW dat shit, muthafucka!  If you provide a routine, it should
start up like this:
.Sp
.Vb 4
\&        sub get_code_line {  # or whatever you\*(Aqll call it
\&          my($line, $line_number, $parser) = @_;
\&          ...
\&        }
.Ve
.Sp
Note, however, dat sometimes tha Pod events aren't processed up in exactly
the same order as tha code lines is \*(-- i.e., if you gotz a gangbangin' file with
Pod, then code, then mo' Pod, sometimes tha code is ghon be processed (via
whatever you have code_handlez call) before tha all of tha precedin Pod
has been processed.
.ie n .IP """$parser\->cut_handlez(  \f(CICODE_REF\f(CW  )""" 4
.el .IP "\f(CW$parser\->cut_handlez(  \f(CICODE_REF\f(CW  )\fR" 4
.IX Item "$parser->cut_handlez( CODE_REF )"
This is just like tha code_handlez attribute, except dat itz for
\&\*(L"=cut\*(R" lines, not code lines. Da same caveats apply. \*(L"=cut\*(R" lines are
unlikely ta be interestin yo, but dis is included fo' completeness.
.ie n .IP """$parser\->pod_handlez(  \f(CICODE_REF\f(CW  )""" 4
.el .IP "\f(CW$parser\->pod_handlez(  \f(CICODE_REF\f(CW  )\fR" 4
.IX Item "$parser->pod_handlez( CODE_REF )"
This is just like tha code_handlez attribute, except dat itz for
\&\*(L"=pod\*(R" lines, not code lines. Da same caveats apply. \*(L"=pod\*(R" lines are
unlikely ta be interestin yo, but dis is included fo' completeness.
.ie n .IP """$parser\->whiteline_handlez(  \f(CICODE_REF\f(CW  )""" 4
.el .IP "\f(CW$parser\->whiteline_handlez(  \f(CICODE_REF\f(CW  )\fR" 4
.IX Item "$parser->whiteline_handlez( CODE_REF )"
This is just like tha code_handlez attribute, except dat itz for
lines dat is seemingly blank but have whitespace (\*(L" \*(R" and/or \*(L"\et\*(R") on them,
not code lines. Da same caveats apply. These lines is unlikely ta be
interestin yo, but dis is included fo' completeness.
.ie n .IP """$parser\->whine( \f(CIlinenumber\f(CW, \f(CIcomplaint string\f(CW )""" 4
.el .IP "\f(CW$parser\->whine( \f(CIlinenumber\f(CW, \f(CIcomplaint string\f(CW )\fR" 4
.IX Item "$parser->whine( linenumber, complaint strang )"
This notes a problem up in tha Pod, which is ghon be reported ta up in tha \*(L"Pod
Errors\*(R" section of tha document and/or bust ta \s-1STDERR,\s0 dependin on the
valuez of tha attributes \f(CW\*(C`no_whining\*(C'\fR, \f(CW\*(C`no_errata_section\*(C'\fR, and
\&\f(CW\*(C`complain_stderr\*(C'\fR.
.ie n .IP """$parser\->scream( \f(CIlinenumber\f(CW, \f(CIcomplaint string\f(CW )""" 4
.el .IP "\f(CW$parser\->scream( \f(CIlinenumber\f(CW, \f(CIcomplaint string\f(CW )\fR" 4
.IX Item "$parser->scream( linenumber, complaint strang )"
This notes a error like \f(CW\*(C`whine\*(C'\fR do, except dat it is not
suppressible wit \f(CW\*(C`no_whining\*(C'\fR. This should be used only fo' hella
serious errors.
.ie n .IP """$parser\->source_dead(1)""" 4
.el .IP "\f(CW$parser\->source_dead(1)\fR" 4
.IX Item "$parser->source_dead(1)"
This aborts parsin of tha current document, by switchin on tha flag
that indicates dat \s-1EOF\s0 has been seen. I aint talkin' bout chicken n' gravy biatch.  In particularly drastic cases,
you might wanna do all dis bullshit.  It aint nuthin but rather sickr than just calling
\&\f(CW\*(C`die\*(C'\fR!
.ie n .IP """$parser\->hide_line_numbers( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->hide_line_numbers( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->hide_line_numbers( SOMEVALUE )"
Some subclasses dat indiscriminately dump event attributes (well,
except fo' ones beginnin wit \*(L"~\*(R") can use dis object attribute for
refrainin ta dump tha \*(L"start_line\*(R" attribute.
.ie n .IP """$parser\->no_whining( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->no_whining( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->no_whining( SOMEVALUE )"
This attribute, if set ta true, will suppress reportz of non-fatal
error lyrics.  Da default value is false, meanin dat disses
\&\fIare\fR reported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  How tha fuck they git reported dependz on tha joints of
the attributes \f(CW\*(C`no_errata_section\*(C'\fR n' \f(CW\*(C`complain_stderr\*(C'\fR.
.ie n .IP """$parser\->no_errata_section( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->no_errata_section( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->no_errata_section( SOMEVALUE )"
This attribute, if set ta true, will suppress generation of a errata
section. I aint talkin' bout chicken n' gravy biatch.  Da default value is false \*(-- i.e., a errata section will be
generated.
.ie n .IP """$parser\->complain_stderr( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->complain_stderr( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->complain_stderr( SOMEVALUE )"
This attribute, if set ta legit will bust disses ta \s-1STDERR. \s0 The
default value is false \*(-- i.e., disses do not git all up in \s-1STDERR.\s0
.ie n .IP """$parser\->bare_output( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->bare_output( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->bare_output( SOMEVALUE )"
Some formatta subclasses use dis as a gangbangin' flag fo' whether output should
have prologue n' epilogue code omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. For example, settin dis to
true fo' a \s-1HTML\s0 formatta class should omit the
\&\*(L"<html><head><title>...</title><body>...\*(R" prologue n' the
\&\*(L"</body></html>\*(R" epilogue.
.Sp
If you wanna set dis ta true, you should probably also set
\&\f(CW\*(C`no_whining\*(C'\fR or at least \f(CW\*(C`no_errata_section\*(C'\fR ta true.
.ie n .IP """$parser\->preserve_whitespace( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->preserve_whitespace( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->preserve_whitespace( SOMEVALUE )"
If you set dis attribute ta a legit value, tha parser will try to
preserve whitespace up in tha output.  This means dat such formatting
conventions as two spaces afta periodz is ghon be preserved by tha parser.
This is primarily useful fo' output formats dat treat whitespace as
significant (like fuckin text or *roff yo, but not \s-1HTML\s0).
.ie n .IP """$parser\->parse_empty_lists( \f(CISOMEVALUE\f(CW )""" 4
.el .IP "\f(CW$parser\->parse_empty_lists( \f(CISOMEVALUE\f(CW )\fR" 4
.IX Item "$parser->parse_empty_lists( SOMEVALUE )"
If dis attribute is set ta true, tha parser aint gonna ignore empty
\&\f(CW\*(C`=over\*(C'\fR/\f(CW\*(C`=back\*(C'\fR blocks. Da type of \f(CW\*(C`=over\*(C'\fR is ghon be \fIempty\fR, documented
above, \*(L"events wit a element_name of over-empty\*(R".
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Simple \*(-- event-based Pod-parsin framework
.PP
Pod::Simple::Methody \*(-- like Pod::Simple yo, but each sort of event
calls its own method (like \f(CW\*(C`start_head3\*(C'\fR)
.PP
Pod::Simple::PullParser \*(-- a Pod-parsin framework like Pod::Simple,
but wit a token-stream intercourse
.PP
Pod::Simple::SimpleTree \*(-- a Pod-parsin framework like Pod::Simple,
but wit a tree intercourse
.PP
Pod::Simple::Checker \*(-- a simple Pod::Simple subclass dat reads
documents, n' then cook up a plaintext report of any errors found up in the
document
.PP
Pod::Simple::DumpAsXML \*(-- fo' dumpin Pod documents as tidily
indented \s-1XML,\s0 showin each event on its own line
.PP
Pod::Simple::XMLOutStream \*(-- dumps a Pod document as \s-1XML \s0(without
introducin extra whitespace as Pod::Simple::DumpAsXML do).
.PP
Pod::Simple::DumpAsText \*(-- fo' dumpin Pod documents as tidily
indented text, showin each event on its own line
.PP
Pod::Simple::LinkSection \*(-- class fo' objects representin tha joints
of tha \s-1TODO\s0 n' \s-1TODO\s0 attributez of L<...> elements
.PP
Pod::Escapes \*(-- tha module tha Pod::Simple uses fo' evaluating
E<...> content
.PP
Pod::Simple::Text \*(-- a simple plaintext formatta fo' Pod
.PP
Pod::Simple::TextContent \*(-- like Pod::Simple::Text yo, but
makes no effort fo' indent or wrap tha text bein formatted
.PP
Pod::Simple::HTML \*(-- a simple \s-1HTML\s0 formatta fo' Pod
.PP
perlpod
.PP
perlpodspec
.PP
perldoc
.SH "SUPPORT"
.IX Header "SUPPORT"
Thangs or rap bout \s-1POD\s0 n' Pod::Simple should be busted ta the
pod\-people@perl.org mail list. Right back up in yo muthafuckin ass. Send a empty email to
pod\-people\-subscribe@perl.org ta subscribe.
.PP
This module is managed up in a open GitHub repository,
<https://github.com/theory/pod\-simple/>. Feel free ta fork n' contribute, or
to clone <git://github.com/theory/pod\-simple.git> n' bust patches!
.PP
Patches against Pod::Simple is welcome. Please bust bug reports to
<bug\-pod\-simple@rt.cpan.org>.
.SH "COPYRIGHT AND DISCLAIMERS"
.IX Header "COPYRIGHT AND DISCLAIMERS"
Copyright (c) 2002 Shizzle M. Burke.
.PP
This library is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
This program is distributed up in tha hope dat it is ghon be useful yo, but
without any warranty; without even tha implied warranty of
merchantabilitizzle or fitnizz fo' a particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pod::Simple was pimped by Shizzle M. Burke <sburke@cpan.org>.
But don't bother him, he retired.
.PP
Pod::Simple is maintained by:
.IP "\(bu" 4
Allison Randal \f(CW\*(C`allison@perl.org\*(C'\fR
.IP "\(bu" 4
Hans Dieta Pearcey \f(CW\*(C`hdp@cpan.org\*(C'\fR
.IP "\(bu" 4
Dizzy E. Wheela \f(CW\*(C`dwheeler@cpan.org\*(C'\fR
