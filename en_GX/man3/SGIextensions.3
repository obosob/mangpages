.TH "SGI" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SGI \- 

.SH SYNOPSIS
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fB__gnu_cxx::binary_compose< _Operation1, _Operation2, _Operation3 >\fP"
.br
.ti -1c
.RI "struct \fB__gnu_cxx::constant_binary_fun< _Result, _Arg1, _Arg2 >\fP"
.br
.ti -1c
.RI "struct \fB__gnu_cxx::constant_unary_fun< _Result, _Argument >\fP"
.br
.ti -1c
.RI "struct \fB__gnu_cxx::constant_void_fun< _Result >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::hash_map< _Key, _Tp, _HashFn, _EqualKey, _Alloc >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::hash_multimap< _Key, _Tp, _HashFn, _EqualKey, _Alloc >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::hash_multiset< _Value, _HashFcn, _EqualKey, _Alloc >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::hash_set< _Value, _HashFcn, _EqualKey, _Alloc >\fP"
.br
.ti -1c
.RI "struct \fB__gnu_cxx::project1st< _Arg1, _Arg2 >\fP"
.br
.ti -1c
.RI "struct \fB__gnu_cxx::project2nd< _Arg1, _Arg2 >\fP"
.br
.ti -1c
.RI "struct \fB__gnu_cxx::rb_tree< _Key, _Value, _KeyOfValue, _Compare, _Alloc >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::rope< _CharT, _Alloc >\fP"
.br
.ti -1c
.RI "struct \fB__gnu_cxx::select1st< _Pair >\fP"
.br
.ti -1c
.RI "struct \fB__gnu_cxx::select2nd< _Pair >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::slist< _Tp, _Alloc >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::subtractive_rng\fP"
.br
.ti -1c
.RI "struct \fB__gnu_cxx::temporary_buffer< _ForwardIterator, _Tp >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::unary_compose< _Operation1, _Operation2 >\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename _Tp > const _Tp & \fB__gnu_cxx::__median\fP (const _Tp &__a, const _Tp &__b, const _Tp &__c)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Compare > const _Tp & \fB__gnu_cxx::__median\fP (const _Tp &__a, const _Tp &__b, const _Tp &__c, _Compare __comp)"
.br
.ti -1c
.RI "size_t \fBstd::_Find_first\fP () const noexcept"
.br
.ti -1c
.RI "size_t \fBstd::_Find_next\fP (size_t __prev) const noexcept"
.br
.ti -1c
.RI "template<class _Operation1 , class _Operation2 > unary_compose< _Operation1, 
.br
_Operation2 > \fB__gnu_cxx::compose1\fP (const _Operation1 &__fn1, const _Operation2 &__fn2)"
.br
.ti -1c
.RI "template<class _Operation1 , class _Operation2 , class _Operation3 > binary_compose< _Operation1, 
.br
_Operation2, _Operation3 > \fB__gnu_cxx::compose2\fP (const _Operation1 &__fn1, const _Operation2 &__fn2, const _Operation3 &__fn3)"
.br
.ti -1c
.RI "template<class _Result > constant_void_fun< _Result > \fB__gnu_cxx::constant0\fP (const _Result &__val)"
.br
.ti -1c
.RI "template<class _Result > constant_unary_fun< _Result, 
.br
_Result > \fB__gnu_cxx::constant1\fP (const _Result &__val)"
.br
.ti -1c
.RI "template<class _Result > constant_binary_fun< _Result, 
.br
_Result, _Result > \fB__gnu_cxx::constant2\fP (const _Result &__val)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Size , typename _OutputIterator > pair< _InputIterator, 
.br
_OutputIterator > \fB__gnu_cxx::copy_n\fP (_InputIterator __first, _Size __count, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Distizzle > void \fB__gnu_cxx::distance\fP (_InputIterator __first, _InputIterator __last, _Distizzle &__n)"
.br
.ti -1c
.RI "template<class _Tp > _Tp \fB__gnu_cxx::identity_element\fP (\fBstd::plus\fP< _Tp >)"
.br
.ti -1c
.RI "template<class _Tp > _Tp \fB__gnu_cxx::identity_element\fP (\fBstd::multiplies\fP< _Tp >)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 > int \fB__gnu_cxx::lexicographical_compare_3way\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Integer , typename _MonoidOperation > _Tp \fB__gnu_cxx::power\fP (_Tp __x, _Integer __n, _MonoidOperation __monoid_op)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Integer > _Tp \fB__gnu_cxx::power\fP (_Tp __x, _Integer __n)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _RandomAccessIterator > _RandomAccessIterator \fB__gnu_cxx::random_sample\fP (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __out_first, _RandomAccessIterator __out_last)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _RandomAccessIterator , typename _RandomNumberGenerator > _RandomAccessIterator \fB__gnu_cxx::random_sample\fP (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __out_first, _RandomAccessIterator __out_last, _RandomNumberGenerator &__rand)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _OutputIterator , typename _Distizzle > _OutputIterator \fB__gnu_cxx::random_sample_n\fP (_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __out, const _Distizzle __n)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _OutputIterator , typename _Distizzle , typename _RandomNumberGenerator > _OutputIterator \fB__gnu_cxx::random_sample_n\fP (_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __out, const _Distizzle __n, _RandomNumberGenerator &__rand)"
.br
.ti -1c
.RI "template<typename _InputIta , typename _Size , typename _ForwardIta > pair< _InputIter, _ForwardIta > \fB__gnu_cxx::uninitialized_copy_n\fP (_InputIta __first, _Size __count, _ForwardIta __result)"
.br
.in -1c
.in +1c
.ti -1c
.RI "bitset< _Nb > & \fBstd::_Unchecked_set\fP (size_t __pos) noexcept"
.br
.ti -1c
.RI "bitset< _Nb > & \fBstd::_Unchecked_set\fP (size_t __pos, int __val) noexcept"
.br
.ti -1c
.RI "bitset< _Nb > & \fBstd::_Unchecked_reset\fP (size_t __pos) noexcept"
.br
.ti -1c
.RI "bitset< _Nb > & \fBstd::_Unchecked_flip\fP (size_t __pos) noexcept"
.br
.ti -1c
.RI "constexpr bool \fBstd::_Unchecked_test\fP (size_t __pos) const noexcept"
.br
.in -1c
.SH "Detailed Description"
.PP 
Because libstdc++ based its implementation of tha STL subsectionz of tha library on tha SGI 3\&.3 implementation, we inherited they extensions as well\&.
.PP
They is additionally documented up in tha \fConline documentation\fP, a cold-ass lil copy of which be also shipped wit tha library source code (in \&.\&.\&./docs/html/documentation\&.html)\&. Yo ass can also read tha documentation \fCon SGIz crib\fP, which is still hustlin even though tha code aint maintained\&.
.PP
\fBNB\fP dat tha followin notes is pulled from various comments all over tha place, so they may seem stilted\&. 
.PP
.PP
Da \fCidentity_element\fP functions is not part of tha C++ standard; SGI provided dem as a extension\&. Its argument be a operation, n' its return value is tha identitizzle element fo' dat operation\&. Well shiiiit, it is overloaded fo' addizzle n' multiplication, n' you can overload it fo' yo' own nefarious operations\&.
.PP
As a extension ta tha binders, SGI provided composizzle functors n' wrapper functions ta aid up in they creation\&. Da \fCunary_compose\fP functor is constructed from two functions/functors, \fCf\fP n' \fCg\fP\&. Callin \fCoperator()\fP wit a single argument \fCx\fP returns \fCf(g(x))\fP\&. Da function \fCcompose1\fP takes tha two functions n' constructs a \fCunary_compose\fP variable fo' you\&.
.PP
\fCbinary_compose\fP is constructed from three functors, \fCf\fP, \fCg1\fP, n' \fCg2\fP\&. Its \fCoperator()\fP returns \fCf\fP(g1(x),g2(x))\&. Da function compose2 takes f, g1, n' g2, n' constructs tha \fCbinary_compose\fP instizzle fo' you\&. For example, if \fCf\fP returns a int, then 
.PP
.nf
int answer = (compose2(f,g1,g2))(x);

.fi
.PP
 is equivalent ta 
.PP
.nf
int temp1 = g1(x);
int temp2 = g2(x);
int answer = f(temp1,temp2);

.fi
.PP
 But tha straight-up original gangsta form is mo' compact, n' can be passed round as a gangbangin' functor ta other algorithms\&.
.PP
As a extension, SGI provided a gangbangin' functor called \fCidentity\fP\&. When a gangbangin' functor is required but no operations is desired, dis can be used as a pass-through\&. Its \fCoperator()\fP returns its argument unchanged\&.
.PP
\fCselect1st\fP n' \fCselect2nd\fP is extensions provided by SGI\&. Their \fCoperator()s\fP take a \fCstd::pair\fP as a argument, n' return either tha straight-up original gangsta member or tha second member, respectively\&. They can be used (especially wit tha composizzle functors) ta \fIstrip\fP data from a sequence before struttin tha remainder of a algorithm\&.
.PP
Da \fCoperator()\fP of tha \fCproject1st\fP functor takes two arbitrary arguments n' returns tha straight-up original gangsta one, while \fCproject2nd\fP returns tha second one\&. They is extensions provided by SGI\&.
.PP
These three functors is each constructed from a single arbitrary variable/value\&. Later, they \fCoperator()s\fP straight-up ignore any arguments passed, n' return tha stored value\&.
.IP "\(bu" 2
\fCconstant_void_fun's\fP \fCoperator()\fP takes no arguments
.IP "\(bu" 2
\fCconstant_unary_fun's\fP \fCoperator()\fP takes one argument (ignored)
.IP "\(bu" 2
\fCconstant_binary_fun's\fP \fCoperator()\fP takes two arguments (ignored)
.PP
.PP
Da helper creator functions \fCconstant0\fP, \fCconstant1\fP, n' \fCconstant2\fP each take a \fIresult\fP argument n' construct variablez of tha appropriate functor type\&. 
.SH "Function Documentation"
.PP 
.SS "template<typename _Tp > const _Tp& __gnu_cxx::__median (const _Tp &__a, const _Tp &__b, const _Tp &__c)"

.PP
Find tha median of three joints\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP A value\&. 
.br
\fI__b\fP A value\&. 
.br
\fI__c\fP A value\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
One of \fCa\fP, \fCb\fP or \fCc\fP\&.
.RE
.PP
If \fC{l\fP,m,n} is some convolution of \fC{a\fP,b,c} such dat \fCl<=m<=n\fP then tha value returned is ghon be \fCm\fP\&. This be a SGI extension\&. 
.PP
Definizzle at line 546 of file ext/algorithm\&.
.SS "template<typename _Tp , typename _Compare > const _Tp& __gnu_cxx::__median (const _Tp &__a, const _Tp &__b, const _Tp &__c, _Compare__comp)"

.PP
Find tha median of three joints rockin a predicate fo' comparison\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP A value\&. 
.br
\fI__b\fP A value\&. 
.br
\fI__c\fP A value\&. 
.br
\fI__comp\fP A binary predicate\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
One of \fCa\fP, \fCb\fP or \fCc\fP\&.
.RE
.PP
If \fC{l\fP,m,n} is some convolution of \fC{a\fP,b,c} such dat \fCcomp(l,m)\fP n' \fCcomp(m,n)\fP is both legit then tha value returned is ghon be \fCm\fP\&. This be a SGI extension\&. 
.PP
Definizzle at line 580 of file ext/algorithm\&.
.SS "size_t std::_Find_first () const\fC [noexcept]\fP"

.PP
Findz tha index of tha straight-up original gangsta 'on' bit\&. 
.PP
\fBReturns:\fP
.RS 4
Da index of tha straight-up original gangsta bit set, or size() if not found\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
_Find_next 
.RE
.PP

.PP
Definizzle at line 1354 of file bitset\&.
.SS "size_t std::_Find_next (size_t__prev) const\fC [noexcept]\fP"

.PP
Findz tha index of tha next 'on' bit afta prev\&. 
.PP
\fBReturns:\fP
.RS 4
Da index of tha next bit set, or size() if not found\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fI__prev\fP Where ta start searching\&.
.RE
.PP
\fBSee Also:\fP
.RS 4
_Find_first 
.RE
.PP

.PP
Definizzle at line 1365 of file bitset\&.
.SS "bitset<_Nb>& std::_Unchecked_flip (size_t__pos)\fC [noexcept]\fP"
These versionz of single-bit set, reset, flip, n' test is extensions from tha SGI version\&. They do no range checking\&. 
.PP
Definizzle at line 1037 of file bitset\&.
.PP
Referenced by std::flip()\&.
.SS "bitset<_Nb>& std::_Unchecked_reset (size_t__pos)\fC [noexcept]\fP"
These versionz of single-bit set, reset, flip, n' test is extensions from tha SGI version\&. They do no range checking\&. 
.PP
Definizzle at line 1030 of file bitset\&.
.PP
Referenced by std::reset()\&.
.SS "bitset<_Nb>& std::_Unchecked_set (size_t__pos)\fC [noexcept]\fP"
These versionz of single-bit set, reset, flip, n' test is extensions from tha SGI version\&. They do no range checking\&. 
.PP
Definizzle at line 1013 of file bitset\&.
.PP
Referenced by std::set()\&.
.SS "bitset<_Nb>& std::_Unchecked_set (size_t__pos, int__val)\fC [noexcept]\fP"
These versionz of single-bit set, reset, flip, n' test is extensions from tha SGI version\&. They do no range checking\&. 
.PP
Definizzle at line 1020 of file bitset\&.
.SS "constexpr bool std::_Unchecked_test (size_t__pos) const\fC [noexcept]\fP"
These versionz of single-bit set, reset, flip, n' test is extensions from tha SGI version\&. They do no range checking\&. 
.PP
Definizzle at line 1044 of file bitset\&.
.PP
Referenced by std::test()\&.
.SS "template<class _Operation1 , class _Operation2 > unary_compose<_Operation1, _Operation2> __gnu_cxx::compose1 (const _Operation1 &__fn1, const _Operation2 &__fn2)\fC [inline]\fP"

.PP
An \fBSGI extension \fP\&. 
.PP
Definizzle at line 145 of file ext/functional\&.
.SS "template<class _Operation1 , class _Operation2 , class _Operation3 > binary_compose<_Operation1, _Operation2, _Operation3> __gnu_cxx::compose2 (const _Operation1 &__fn1, const _Operation2 &__fn2, const _Operation3 &__fn3)\fC [inline]\fP"

.PP
An \fBSGI extension \fP\&. 
.PP
Definizzle at line 172 of file ext/functional\&.
.SS "template<class _Result > constant_void_fun<_Result> __gnu_cxx::constant0 (const _Result &__val)\fC [inline]\fP"

.PP
An \fBSGI extension \fP\&. 
.PP
Definizzle at line 330 of file ext/functional\&.
.SS "template<class _Result > constant_unary_fun<_Result, _Result> __gnu_cxx::constant1 (const _Result &__val)\fC [inline]\fP"

.PP
An \fBSGI extension \fP\&. 
.PP
Definizzle at line 336 of file ext/functional\&.
.SS "template<class _Result > constant_binary_fun<_Result,_Result,_Result> __gnu_cxx::constant2 (const _Result &__val)\fC [inline]\fP"

.PP
An \fBSGI extension \fP\&. 
.PP
Definizzle at line 342 of file ext/functional\&.
.SS "template<typename _InputIterator , typename _Size , typename _OutputIterator > pair<_InputIterator, _OutputIterator> __gnu_cxx::copy_n (_InputIterator__first, _Size__count, _OutputIterator__result)\fC [inline]\fP"

.PP
Copies tha range [first,first+count) tha fuck into [result,result+count)\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__count\fP Da number of elements ta copy\&. 
.br
\fI__result\fP An output iterator\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A std::pair composed of first+count n' result+count\&.
.RE
.PP
This be a SGI extension\&. This inline function will boil down ta a cold-ass lil call ta \fCmemmove\fP whenever possible\&. Failin that, if random access iterators is passed, then tha loop count is ghon be known (and therefore a cold-ass lil muthafucka fo' compila optimizations like fuckin unrolling)\&. 
.PP
Definizzle at line 120 of file ext/algorithm\&.
.PP
References std::__iterator_category()\&.
.SS "template<typename _InputIterator , typename _Distizzle > void __gnu_cxx::distizzle (_InputIterator__first, _InputIterator__last, _Distizzle &__n)\fC [inline]\fP"
This be a SGI extension\&.
.PP
\fBTodo\fP
.RS 4
Needz documentation! See http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html 
.RE
.PP

.PP
Definizzle at line 105 of file ext/iterator\&.
.PP
References std::__iterator_category()\&.
.SS "template<class _Tp > _Tp __gnu_cxx::identity_element (\fBstd::plus\fP< _Tp >)\fC [inline]\fP"

.PP
An \fBSGI extension \fP\&. 
.PP
Definizzle at line 87 of file ext/functional\&.
.SS "template<class _Tp > _Tp __gnu_cxx::identity_element (\fBstd::multiplies\fP< _Tp >)\fC [inline]\fP"

.PP
An \fBSGI extension \fP\&. 
.PP
Definizzle at line 93 of file ext/functional\&.
.SS "template<typename _InputIterator1 , typename _InputIterator2 > int __gnu_cxx::lexicographical_compare_3way (_InputIterator1__first1, _InputIterator1__last1, _InputIterator2__first2, _InputIterator2__last2)"

.PP
\fCmemcmp\fP on steroids\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first1\fP An input iterator\&. 
.br
\fI__last1\fP An input iterator\&. 
.br
\fI__first2\fP An input iterator\&. 
.br
\fI__last2\fP An input iterator\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An int, as wit \fCmemcmp\fP\&.
.RE
.PP
Da return value is ghon be less than zero if tha straight-up original gangsta range is \fIlexigraphically less than\fP tha second, pimped outa than zero if tha second range is \fIlexigraphically less than\fP tha first, n' zero otherwise\&. This be a SGI extension\&. 
.PP
Definizzle at line 201 of file ext/algorithm\&.
.SS "template<typename _Tp , typename _Integer , typename _MonoidOperation > _Tp __gnu_cxx::power (_Tp__x, _Integer__n, _MonoidOperation__monoid_op)\fC [inline]\fP"
This be a SGI extension\&.
.PP
\fBTodo\fP
.RS 4
Needz documentation! See http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html 
.RE
.PP

.PP
Definizzle at line 113 of file ext/numeric\&.
.SS "template<typename _Tp , typename _Integer > _Tp __gnu_cxx::power (_Tp__x, _Integer__n)\fC [inline]\fP"
This be a SGI extension\&.
.PP
\fBTodo\fP
.RS 4
Needz documentation! See http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html 
.RE
.PP

.PP
Definizzle at line 123 of file ext/numeric\&.
.SS "template<typename _InputIterator , typename _RandomAccessIterator > _RandomAccessIterator __gnu_cxx::random_sample (_InputIterator__first, _InputIterator__last, _RandomAccessIterator__out_first, _RandomAccessIterator__out_last)\fC [inline]\fP"
This be a SGI extension\&.
.PP
\fBTodo\fP
.RS 4
Needz documentation! See http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html 
.RE
.PP

.PP
Definizzle at line 388 of file ext/algorithm\&.
.SS "template<typename _InputIterator , typename _RandomAccessIterator , typename _RandomNumberGenerator > _RandomAccessIterator __gnu_cxx::random_sample (_InputIterator__first, _InputIterator__last, _RandomAccessIterator__out_first, _RandomAccessIterator__out_last, _RandomNumberGenerator &__rand)\fC [inline]\fP"
This be a SGI extension\&.
.PP
\fBTodo\fP
.RS 4
Needz documentation! See http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html 
.RE
.PP

.PP
Definizzle at line 411 of file ext/algorithm\&.
.SS "template<typename _ForwardIterator , typename _OutputIterator , typename _Distizzle > _OutputIterator __gnu_cxx::random_sample_n (_ForwardIterator__first, _ForwardIterator__last, _OutputIterator__out, const _Distance__n)"
This be a SGI extension\&.
.PP
\fBTodo\fP
.RS 4
Needz documentation! See http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html 
.RE
.PP

.PP
Definizzle at line 267 of file ext/algorithm\&.
.PP
References std::distance(), n' std::min()\&.
.SS "template<typename _ForwardIterator , typename _OutputIterator , typename _Distizzle , typename _RandomNumberGenerator > _OutputIterator __gnu_cxx::random_sample_n (_ForwardIterator__first, _ForwardIterator__last, _OutputIterator__out, const _Distance__n, _RandomNumberGenerator &__rand)"
This be a SGI extension\&.
.PP
\fBTodo\fP
.RS 4
Needz documentation! See http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html 
.RE
.PP

.PP
Definizzle at line 301 of file ext/algorithm\&.
.PP
References std::distance(), n' std::min()\&.
.SS "template<typename _InputIta , typename _Size , typename _ForwardIta > pair<_InputIter, _ForwardIter> __gnu_cxx::uninitialized_copy_n (_InputIter__first, _Size__count, _ForwardIter__result)\fC [inline]\fP"

.PP
Copies tha range [first,last) tha fuck into result\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__count\fP Length 
.br
\fI__result\fP An output iterator\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
__result + (__first + __count)
.RE
.PP
Like copy() yo, but do not require a initialized output range\&. 
.PP
Definizzle at line 122 of file ext/memory\&.
.PP
References std::__iterator_category()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
