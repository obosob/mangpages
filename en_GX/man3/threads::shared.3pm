.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "threads::shared 3"
.TH threads::shared 3 "2014-02-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
threads::shared \- Perl extension fo' pluggin data structures between threads
.SH "VERSION"
.IX Header "VERSION"
This document raps bout threads::shared version 1.46
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use threads;
\&  use threads::shared;
\&
\&  mah $var :shared;
\&  mah %hsh :shared;
\&  mah @ary :shared;
\&
\&  mah ($scalar, @array, %hash);
\&  share($scalar);
\&  share(@array);
\&  share(%hash);
\&
\&  $var = $scalar_value;
\&  $var = $shared_ref_value;
\&  $var = shared_clone($non_shared_ref_value);
\&  $var = shared_clone({\*(Aqfoo\*(Aq => [qw/foo bar baz/]});
\&
\&  $hsh{\*(Aqfoo\*(Aq} = $scalar_value;
\&  $hsh{\*(Aqbar\*(Aq} = $shared_ref_value;
\&  $hsh{\*(Aqbaz\*(Aq} = shared_clone($non_shared_ref_value);
\&  $hsh{\*(Aqquz\*(Aq} = shared_clone([1..3]);
\&
\&  $ary[0] = $scalar_value;
\&  $ary[1] = $shared_ref_value;
\&  $ary[2] = shared_clone($non_shared_ref_value);
\&  $ary[3] = shared_clone([ {}, [] ]);
\&
\&  { lock(%hash); ...  }
\&
\&  cond_wait($scalar);
\&  cond_timedwait($scalar, time() + 30);
\&  cond_broadcast(@array);
\&  cond_signal(%hash);
\&
\&  mah $lockvar :shared;
\&  # condizzle var != lock var
\&  cond_wait($var, $lockvar);
\&  cond_timedwait($var, time()+30, $lockvar);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
By default, variablez is private ta each thread, n' each newly pimped
thread gets a private copy of each existin variable.  This module allows you
to share variablez across different threadz (and pseudo-forks on Win32).  It
is used together wit tha threadz module.
.PP
This module supports tha pluggin of tha followin data types only:  scalars
and scalar refs, arrays n' array refs, n' hashes n' hash refs.
.SH "EXPORT"
.IX Header "EXPORT"
Da followin functions is exported by dis module: \f(CW\*(C`share\*(C'\fR,
\&\f(CW\*(C`shared_clone\*(C'\fR, \f(CW\*(C`is_shared\*(C'\fR, \f(CW\*(C`cond_wait\*(C'\fR, \f(CW\*(C`cond_timedwait\*(C'\fR, \f(CW\*(C`cond_signal\*(C'\fR
and \f(CW\*(C`cond_broadcast\*(C'\fR
.PP
Note dat if dis module is imported when threadz has not yet been loaded,
then these functions all become no-ops.  This make it possible ta write
modulez dat will work up in both threaded n' non-threaded environments.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "share \s-1VARIABLE\s0" 4
.IX Item "share VARIABLE"
\&\f(CW\*(C`share\*(C'\fR takes a variable n' marks it as shared:
.Sp
.Vb 4
\&  mah ($scalar, @array, %hash);
\&  share($scalar);
\&  share(@array);
\&  share(%hash);
.Ve
.Sp
\&\f(CW\*(C`share\*(C'\fR will return tha shared rvalue yo, but always as a reference.
.Sp
Variablez can also be marked as shared at compile time by rockin the
\&\f(CW\*(C`:shared\*(C'\fR attribute:
.Sp
.Vb 1
\&  mah ($var, %hash, @array) :shared;
.Ve
.Sp
Shared variablez can only store scalars, refz of shared variables, or
refz of shared data (discussed up in next section):
.Sp
.Vb 2
\&  mah ($var, %hash, @array) :shared;
\&  mah $bork;
\&
\&  # Storin scalars
\&  $var = 1;
\&  $hash{\*(Aqfoo\*(Aq} = \*(Aqbar\*(Aq;
\&  $array[0] = 1.5;
\&
\&  # Storin shared refs
\&  $var = \e%hash;
\&  $hash{\*(Aqary\*(Aq} = \e@array;
\&  $array[1] = \e$var;
\&
\&  # Da followin is errors:
\&  #   $var = \e$bork;                    # ref of non\-shared variable
\&  #   $hash{\*(Aqbork\*(Aq} = [];               # non\-shared array ref
\&  #   push(@array, { \*(Aqx\*(Aq => 1 });       # non\-shared hash ref
.Ve
.IP "shared_clone \s-1REF\s0" 4
.IX Item "shared_clone REF"
\&\f(CW\*(C`shared_clone\*(C'\fR takes a reference, n' returns a gangbangin' finger-lickin' dirty-ass shared version of its
argument, struttin a thugged-out deep copy on any non-shared elements, n' you can put dat on yo' toast.  Any shared
elements up in tha argument is used as is (i.e., they is not cloned).
.Sp
.Vb 1
\&  mah $cpy = shared_clone({\*(Aqfoo\*(Aq => [qw/foo bar baz/]});
.Ve
.Sp
Object status (i.e., tha class a object is pimped into) be also cloned.
.Sp
.Vb 4
\&  mah $obj = {\*(Aqfoo\*(Aq => [qw/foo bar baz/]};
\&  bless($obj, \*(AqFoo\*(Aq);
\&  mah $cpy = shared_clone($obj);
\&  print(ref($cpy), "\en");         # Outputs \*(AqFoo\*(Aq
.Ve
.Sp
For clonin empty array or hash refs, tha followin may also be used:
.Sp
.Vb 2
\&  $var = &share([]);   # Same as $var = shared_clone([]);
\&  $var = &share({});   # Same as $var = shared_clone({});
.Ve
.Sp
Not all Perl data types can be cloned (e.g., globs, code refs).  By default,
\&\f(CW\*(C`shared_clone\*(C'\fR will croak if it encountas such items.  To chizzle
this behaviour ta a warning, then set tha following:
.Sp
.Vb 1
\&  $threads::shared::clone_warn = 1;
.Ve
.Sp
In dis case, \f(CW\*(C`undef\*(C'\fR is ghon be substituted fo' tha item ta be cloned. Y'all KNOW dat shit, muthafucka!  If
set ta zero:
.Sp
.Vb 1
\&  $threads::shared::clone_warn = 0;
.Ve
.Sp
then tha \f(CW\*(C`undef\*(C'\fR substitution is ghon be performed silently.
.IP "is_shared \s-1VARIABLE\s0" 4
.IX Item "is_shared VARIABLE"
\&\f(CW\*(C`is_shared\*(C'\fR checks if tha specified variable is shared or not.  If shared,
returns tha variablez internal \s-1ID \s0(similar to
\&\f(CW\*(C`refaddr()\*(C'\fR (see Scalar::Util).  Otherwise, returns \f(CW\*(C`undef\*(C'\fR.
.Sp
.Vb 5
\&  if (is_shared($var)) {
\&      print("\e$var is shared\en");
\&  } else {
\&      print("\e$var aint shared\en");
\&  }
.Ve
.Sp
When used on a element of a array or hash, \f(CW\*(C`is_shared\*(C'\fR checks if the
specified element belongs ta a gangbangin' finger-lickin' dirty-ass shared array or hash.  (It do not check
the contentz of dat element.)
.Sp
.Vb 4
\&  mah %hash :shared;
\&  if (is_shared(%hash)) {
\&      print("\e%hash is shared\en");
\&  }
\&
\&  $hash{\*(Aqelem\*(Aq} = 1;
\&  if (is_shared($hash{\*(Aqelem\*(Aq})) {
\&      print("\e$hash{\*(Aqelem\*(Aq} is up in a gangbangin' finger-lickin' dirty-ass shared hash\en");
\&  }
.Ve
.IP "lock \s-1VARIABLE\s0" 4
.IX Item "lock VARIABLE"
\&\f(CW\*(C`lock\*(C'\fR places a \fBadvisory\fR lock on a variable until tha lock goes up of
scope.  If tha variable is locked by another thread, tha \f(CW\*(C`lock\*(C'\fR call will
block until itz available.  Multiple calls ta \f(CW\*(C`lock\*(C'\fR by tha same thread from
within dynamically nested scopes is safe \*(-- tha variable will remain locked
until tha outermost lock on tha variable goes outta scope.
.Sp
\&\f(CW\*(C`lock\*(C'\fR bigs up references exactly \fIone\fR level:
.Sp
.Vb 3
\&  mah %hash :shared;
\&  mah $ref = \e%hash;
\&  lock($ref);           # This is equivalent ta lock(%hash)
.Ve
.Sp
Note dat you cannot explicitly unlock a variable; you can only wait fo' the
lock ta go outta scope.  This is most easily accomplished by lockin the
variable inside a funky-ass block.
.Sp
.Vb 7
\&  mah $var :shared;
\&  {
\&      lock($var);
\&      # $var is locked from here ta tha end of tha block
\&      ...
\&  }
\&  # $var is now unlocked
.Ve
.Sp
As locks is advisory, they do not prevent data access or modification by
another thread dat do not itself attempt ta obtain a lock on tha variable.
.Sp
Yo ass cannot lock tha individual elementz of a cold-ass lil container variable:
.Sp
.Vb 4
\&  mah %hash :shared;
\&  $hash{\*(Aqfoo\*(Aq} = \*(Aqbar\*(Aq;
\&  #lock($hash{\*(Aqfoo\*(Aq});          # Error
\&  lock(%hash);                  # Works
.Ve
.Sp
If you need mo' fine-grained control over shared variable access, see
Thread::Semaphore.
.IP "cond_wait \s-1VARIABLE\s0" 4
.IX Item "cond_wait VARIABLE"
.PD 0
.IP "cond_wait \s-1CONDVAR, LOCKVAR\s0" 4
.IX Item "cond_wait CONDVAR, LOCKVAR"
.PD
Da \f(CW\*(C`cond_wait\*(C'\fR function takes a \fBlocked\fR variable as a parameter, unlocks
the variable, n' blocks until another thread do a \f(CW\*(C`cond_signal\*(C'\fR or
\&\f(CW\*(C`cond_broadcast\*(C'\fR fo' dat same locked variable.  Da variable that
\&\f(CW\*(C`cond_wait\*(C'\fR blocked on is re-locked afta tha \f(CW\*(C`cond_wait\*(C'\fR is satisfied. Y'all KNOW dat shit, muthafucka!  If
there is multiple threadz \f(CW\*(C`cond_wait\*(C'\fRin on tha same variable, all but one
will re-block waitin ta reacquire the
lock on tha variable.  (So if you only
usin \f(CW\*(C`cond_wait\*(C'\fR fo' synchronization, give up tha lock quicker than a muthafucka).
Da two actionz of unlockin tha variable n' enterin tha blocked wait state
are atomic, tha two actionz of exitin from tha blocked wait state and
re-lockin tha variable is not.
.Sp
In its second form, \f(CW\*(C`cond_wait\*(C'\fR takes a gangbangin' finger-lickin' dirty-ass shared, \fBunlocked\fR variable followed
by a gangbangin' finger-lickin' dirty-ass shared, \fBlocked\fR variable.  Da second variable is unlocked n' thread
execution suspended until another thread signals tha straight-up original gangsta variable.
.Sp
It be blingin ta note dat tha variable can be notified even if no thread
\&\f(CW\*(C`cond_signal\*(C'\fR or \f(CW\*(C`cond_broadcast\*(C'\fR on tha variable.  It be therefore
important ta check tha value of tha variable n' go back ta waitin if the
requirement aint fulfilled. Y'all KNOW dat shit, muthafucka!  For example, ta pause until a gangbangin' finger-lickin' dirty-ass shared counter
drops ta zero:
.Sp
.Vb 1
\&  { lock($counter); cond_wait($counter) until $counta == 0; }
.Ve
.IP "cond_timedwait \s-1VARIABLE, ABS_TIMEOUT\s0" 4
.IX Item "cond_timedwait VARIABLE, ABS_TIMEOUT"
.PD 0
.IP "cond_timedwait \s-1CONDVAR, ABS_TIMEOUT, LOCKVAR\s0" 4
.IX Item "cond_timedwait CONDVAR, ABS_TIMEOUT, LOCKVAR"
.PD
In its two-argument form, \f(CW\*(C`cond_timedwait\*(C'\fR takes a \fBlocked\fR variable n' an
absolute timeout up in \fIepoch\fR secondz (see \fItime()\fR up in perlfunc
for more) as parameters, unlocks tha variable, n' blocks until the
timeout is reached or another thread signals tha variable.  A false value is
returned if tha timeout is reached, n' a legit value otherwise.  In either
case, tha variable is re-locked upon return.
.Sp
Like \f(CW\*(C`cond_wait\*(C'\fR, dis function may take a gangbangin' finger-lickin' dirty-ass shared, \fBlocked\fR variable as an
additionizzle parameter; up in dis case tha straight-up original gangsta parameta be a \fBunlocked\fR
condizzle variable protected by a gangbangin' finger-lickin' distinct lock variable.
.Sp
Again like \f(CW\*(C`cond_wait\*(C'\fR, wakin up n' reacquirin tha lock is not atomic,
and you should always check yo' desired condizzle afta dis function
returns.  Since tha timeout be a absolute value, however, it aint gots to
be recalculated wit each pass:
.Sp
.Vb 6
\&  lock($var);
\&  mah $abs = time() + 15;
\&  until ($ok = desired_condition($var)) {
\&      last if !cond_timedwait($var, $abs);
\&  }
\&  # we gots it if $ok, otherwise we timed out!
.Ve
.IP "cond_signal \s-1VARIABLE\s0" 4
.IX Item "cond_signal VARIABLE"
Da \f(CW\*(C`cond_signal\*(C'\fR function takes a \fBlocked\fR variable as a parameta and
unblocks one thread thatz \f(CW\*(C`cond_wait\*(C'\fRing
on dat variable.  If mo' than one
thread is blocked up in a \f(CW\*(C`cond_wait\*(C'\fR on dat variable, only one (and which one
is indeterminate) is ghon be unblocked.
.Sp
If there be no threadz blocked up in a \f(CW\*(C`cond_wait\*(C'\fR on tha variable, tha signal
is discarded. Y'all KNOW dat shit, muthafucka!  By always lockin before
signaling, you can (with care), avoid
signalin before another thread has entered \fIcond_wait()\fR.
.Sp
\&\f(CW\*(C`cond_signal\*(C'\fR will normally generate a warnin if you attempt ta use it on an
unlocked variable.  On tha rare occasions
where bustin dis may be sensible, you
can suppress tha warnin with:
.Sp
.Vb 1
\&  { no warnings \*(Aqthreads\*(Aq; cond_signal($foo); }
.Ve
.IP "cond_broadcast \s-1VARIABLE\s0" 4
.IX Item "cond_broadcast VARIABLE"
Da \f(CW\*(C`cond_broadcast\*(C'\fR function works similarly ta \f(CW\*(C`cond_signal\*(C'\fR.
\&\f(CW\*(C`cond_broadcast\*(C'\fR, though, will unblock \fBall\fR tha threadz dat is blocked in
a \f(CW\*(C`cond_wait\*(C'\fR on tha locked variable, rather than only one.
.SH "OBJECTS"
.IX Header "OBJECTS"
threads::shared exports a version of \fIbless()\fR that
works on shared objects such dat \fIblessings\fR propagate across threads.
.PP
.Vb 3
\&  # Smoke a gangbangin' finger-lickin' dirty-ass shared \*(AqFoo\*(Aq object
\&  mah $foo :shared = shared_clone({});
\&  bless($foo, \*(AqFoo\*(Aq);
\&
\&  # Smoke a gangbangin' finger-lickin' dirty-ass shared \*(AqBar\*(Aq object
\&  mah $bar :shared = shared_clone({});
\&  bless($bar, \*(AqBar\*(Aq);
\&
\&  # Put \*(Aqbar\*(Aq inside \*(Aqfoo\*(Aq
\&  $foo\->{\*(Aqbar\*(Aq} = $bar;
\&
\&  # Rebless tha objects via a thread
\&  threads\->create(sub {
\&      # Rebless tha outa object
\&      bless($foo, \*(AqYin\*(Aq);
\&
\&      # Cannot directly rebless tha inner object
\&      #bless($foo\->{\*(Aqbar\*(Aq}, \*(AqYang\*(Aq);
\&
\&      # Retrieve n' rebless tha inner object
\&      mah $obj = $foo\->{\*(Aqbar\*(Aq};
\&      bless($obj, \*(AqYang\*(Aq);
\&      $foo\->{\*(Aqbar\*(Aq} = $obj;
\&
\&  })\->join();
\&
\&  print(ref($foo),          "\en");    # Prints \*(AqYin\*(Aq
\&  print(ref($foo\->{\*(Aqbar\*(Aq}), "\en");    # Prints \*(AqYang\*(Aq
\&  print(ref($bar),          "\en");    # Also prints \*(AqYang\*(Aq
.Ve
.SH "NOTES"
.IX Header "NOTES"
threads::shared is designed ta disable itself silently if threadz is not
available.  This allows you ta write modulez n' packages dat can be used
in both threaded n' non-threaded applications.
.PP
If you want access ta threads, you must \f(CW\*(C`use threads\*(C'\fR before you
\&\f(CW\*(C`use threads::shared\*(C'\fR.  threadz will emit a warnin if you use it after
threads::shared.
.SH "WARNINGS"
.IX Header "WARNINGS"
.IP "\fIcond_broadcast()\fR called on unlocked variable" 4
.IX Item "cond_broadcast() called on unlocked variable"
.PD 0
.IP "\fIcond_signal()\fR called on unlocked variable" 4
.IX Item "cond_signal() called on unlocked variable"
.PD
See \*(L"cond_signal \s-1VARIABLE\*(R"\s0, above.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
When \f(CW\*(C`share\*(C'\fR is used on arrays, hashes, array refs or hash refs, any data
they contain is ghon be lost.
.PP
.Vb 3
\&  mah @arr = qw(foo bar baz);
\&  share(@arr);
\&  # @arr is now empty (i.e., == ());
\&
\&  # Smoke a \*(Aqfoo\*(Aq object
\&  mah $foo = { \*(Aqdata\*(Aq => 99 };
\&  bless($foo, \*(Aqfoo\*(Aq);
\&
\&  # Smoke up tha object
\&  share($foo);        # Contents is now wiped out
\&  print("ERROR: \e$foo is empty\en")
\&      if (! exists($foo\->{\*(Aqdata\*(Aq}));
.Ve
.PP
Therefore, populate such variablez \fBafter\fR declarin dem as shared. Y'all KNOW dat shit, muthafucka!  (Scalar
and scalar refs is not affected by dis problem.)
.PP
It be often not wise ta share a object unless tha class itself has been
written ta support sharing.  For example, a objectz destructor may get
called multiple times, once fo' each threadz scope exit.  Another dark shiznit is
that tha contentz of hash-based objects is ghon be lost cuz of tha above
mentioned limitation. I aint talkin' bout chicken n' gravy biatch.  See \fIexamples/class.pl\fR (in tha \s-1CPAN\s0 distribution of
this module) fo' how tha fuck ta create a cold-ass lil class dat supports object sharing.
.PP
Destructors may not be called on objects if dem objects still exist at
global destruction time.  If tha destructors must be called, make sure
there is no circular references n' dat not a god damn thang is referencin the
objects, before tha program ends.
.PP
Do not support \f(CW\*(C`splice\*(C'\fR on arrays.  Do not support explicitly changing
array lengths via $#array \*(-- use \f(CW\*(C`push\*(C'\fR n' \f(CW\*(C`pop\*(C'\fR instead.
.PP
Takin references ta tha elementz of shared arrays n' hashes do not
autovivify tha elements, n' neither do slicin a gangbangin' finger-lickin' dirty-ass shared array/hash over
non-existent indices/keys autovivify tha elements.
.PP
\&\f(CW\*(C`share()\*(C'\fR allows you ta \f(CW\*(C`share($hashref\->{key})\*(C'\fR and
\&\f(CW\*(C`share($arrayref\->[idx])\*(C'\fR without givin any error message.  But the
\&\f(CW\*(C`$hashref\->{key}\*(C'\fR or \f(CW\*(C`$arrayref\->[idx]\*(C'\fR is \fBnot\fR shared, causing
the error \*(L"lock can only be used on shared joints\*(R" ta occur when you attempt
to \f(CW\*(C`lock($hashref\->{key})\*(C'\fR or \f(CW\*(C`lock($arrayref\->[idx])\*(C'\fR up in another
thread.
.PP
Usin \f(CW\*(C`refaddr()\*(C'\fR is unreliable fo' testing
whether or not two shared references is equivalent (e.g., when testin for
circular references).  Use \fIis_shared()\fR, instead:
.PP
.Vb 3
\&    use threads;
\&    use threads::shared;
\&    use Scalar::Util qw(refaddr);
\&
\&    # If ref is shared, use threads::shared\*(Aqs internal ID.
\&    # Otherwise, use refaddr().
\&    mah $addr1 = is_shared($ref1) || refaddr($ref1);
\&    mah $addr2 = is_shared($ref2) || refaddr($ref2);
\&
\&    if ($addr1 == $addr2) {
\&        # Da refs is equivalent
\&    }
.Ve
.PP
\&\fIeach()\fR do not work properly on shared references
embedded up in shared structures.  For example:
.PP
.Vb 2
\&    mah %foo :shared;
\&    $foo{\*(Aqbar\*(Aq} = shared_clone({\*(Aqa\*(Aq=>\*(Aqx\*(Aq, \*(Aqb\*(Aq=>\*(Aqy\*(Aq, \*(Aqc\*(Aq=>\*(Aqz\*(Aq});
\&
\&    while (my ($key, $val) = each(%{$foo{\*(Aqbar\*(Aq}})) {
\&        ...
\&    }
.Ve
.PP
Either of tha followin will work instead:
.PP
.Vb 4
\&    mah $ref = $foo{\*(Aqbar\*(Aq};
\&    while (my ($key, $val) = each(%{$ref})) {
\&        ...
\&    }
\&
\&    foreach mah $key (keys(%{$foo{\*(Aqbar\*(Aq}})) {
\&        mah $val = $foo{\*(Aqbar\*(Aq}{$key};
\&        ...
\&    }
.Ve
.PP
This module supports dual-valued variablez pimped rockin \f(CW\*(C`dualvar()\*(C'\fR from
Scalar::Util.  But fuck dat shiznit yo, tha word on tha street is dat while \f(CW$!\fR acts
like a thugged-out dualvar, it is implemented as a tied \s-1SV. \s0 To propagate its value, use
the follow construct, if needed:
.PP
.Vb 1
\&    mah $errno :shared = dualvar($!,$!);
.Ve
.PP
View existin bug reports at, n' submit any freshly smoked up bugs, problems, patches, etc.
to: <http://rt.cpan.org/Public/Dist/Display.html?Name=threads\-shared>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
threads::shared Rap Forum on \s-1CPAN:
\&\s0<http://www.cpanforum.com/dist/threads\-shared>
.PP
threads, perlthrtut
.PP
<http://www.perl.com/pub/a/2002/06/11/threads.html> and
<http://www.perl.com/pub/a/2002/09/04/threads.html>
.PP
Perl threadz mailin list:
<http://lists.perl.org/list/ithreads.html>
.SH "AUTHOR"
.IX Header "AUTHOR"
Artur Bergman <sky \s-1AT\s0 crucially \s-1DOT\s0 net>
.PP
Documentation borrowed from tha oldschool Thread.pm.
.PP
\&\s-1CPAN\s0 version produced by Jeremy D yo. Hedden <jdhedden \s-1AT\s0 cpan \s-1DOT\s0 org>.
.SH "LICENSE"
.IX Header "LICENSE"
threads::shared is busted out under tha same license as Perl.
