.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BigInt::Calc 3pm"
.TH Math::BigInt::Calc 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BigInt::Calc \- Pure Perl module ta support Math::BigInt
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This library serves up support fo' big-ass integer calculations. Well shiiiit, it is not
intended ta be used by other modules. Other modulez which support tha same
\&\s-1API \s0(see below) can also be used ta support Math::BigInt, like
Math::BigInt::GMP n' Math::BigInt::Pari.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In dis library, tha numbers is represented up in base B = 10**N, where N is
the phattest possible value dat do not cause overflow up in tha intermediate
computations. Da base B elements is stored up in a array, wit tha least
significant element stored up in array element zero. There is no leadin zero
elements, except a single zero element when tha number is zero.
.PP
For instance, if B = 10000, tha number 1234567890 is represented internally
as [3456, 7890, 12].
.SH "THE Math::BigInt API"
.IX Header "THE Math::BigInt API"
In order ta allow fo' multiple big-ass integer libraries, Math::BigInt was
rewritten ta bust a plug-in library fo' core math routines fo' realz. Any module which
conforms ta tha \s-1API\s0 can be used by Math::BigInt by rockin dis up in yo' program:
.PP
.Vb 1
\&        use Math::BigInt lib => \*(Aqlibname\*(Aq;
.Ve
.PP
\&'libname' is either tha long name, like 'Math::BigInt::Pari', or only tha short
version, like 'Pari'.
.SS "General Notes"
.IX Subsection "General Notes"
A library only need ta deal wit unsigned big-ass integers. Testin of input
parameta validitizzle is done by tha caller, so there is no need ta worry about
underflow (e.g., up in \f(CW\*(C`_sub()\*(C'\fR n' \f(CW\*(C`_dec()\*(C'\fR) nor bout division by zero (e.g.,
in \f(CW\*(C`_div()\*(C'\fR) or similar cases.
.PP
For some methods, tha straight-up original gangsta parameta can be modified. Y'all KNOW dat shit, muthafucka! That includes the
possibilitizzle dat you return a reference ta a cold-ass lil straight-up different object
instead. Y'all KNOW dat shit, muthafucka! Although keepin tha reference n' just changin its contents is
preferred over bustin n' returnin a gangbangin' finger-lickin' different reference.
.PP
Return joints is always objects, strings, Perl scalars, or true/false for
comparison routines.
.SS "\s-1API\s0 version 1"
.IX Subsection "API version 1"
Da followin methodz must be defined up in order ta support tha use by
Math::BigInt v1.70 or later.
.PP
\fI\s-1API\s0 version\fR
.IX Subsection "API version"
.IP "\fI\fIapi_version()\fI\fR" 4
.IX Item "api_version()"
Return \s-1API\s0 version as a Perl scalar, 1 fo' Math::BigInt v1.70, 2 for
Math::BigInt v1.83.
.PP
\fIConstructors\fR
.IX Subsection "Constructors"
.IP "\fI_new(\s-1STR\s0)\fR" 4
.IX Item "_new(STR)"
Convert a strang representin a unsigned decimal number ta a object
representin tha same number n' shit. Da input is normalize, i.e., it matches
\&\f(CW\*(C`^(0|[1\-9]\ed*)$\*(C'\fR.
.IP "\fI\fI_zero()\fI\fR" 4
.IX Item "_zero()"
Return a object representin tha number zero.
.IP "\fI\fI_one()\fI\fR" 4
.IX Item "_one()"
Return a object representin tha number one.
.IP "\fI\fI_two()\fI\fR" 4
.IX Item "_two()"
Return a object representin tha number two.
.IP "\fI\fI_ten()\fI\fR" 4
.IX Item "_ten()"
Return a object representin tha number ten.
.IP "\fI_from_bin(\s-1STR\s0)\fR" 4
.IX Item "_from_bin(STR)"
Return a object given a strang representin a funky-ass binary number n' shit. Da input has a
\&'0b' prefix n' matches tha regular expression \f(CW\*(C`^0[bB](0|1[01]*)$\*(C'\fR.
.IP "\fI_from_oct(\s-1STR\s0)\fR" 4
.IX Item "_from_oct(STR)"
Return a object given a strang representin a octal number n' shit. Da input has a
\&'0' prefix n' matches tha regular expression \f(CW\*(C`^0[1\-7]*$\*(C'\fR.
.IP "\fI_from_hex(\s-1STR\s0)\fR" 4
.IX Item "_from_hex(STR)"
Return a object given a strang representin a hexadecimal number n' shit. Da input
has a '0x' prefix n' matches tha regular expression
\&\f(CW\*(C`^0x(0|[1\-9a\-fA\-F][\eda\-fA\-F]*)$\*(C'\fR.
.PP
\fIMathematical functions\fR
.IX Subsection "Mathematical functions"
.PP
Each of these methodz may modify tha straight-up original gangsta input argument, except \fI\fI_bgcd()\fI\fR,
which shall not modify any input argument, n' \fI\fI_sub()\fI\fR which may modify the
second input argument.
.IP "\fI_add(\s-1OBJ1, OBJ2\s0)\fR" 4
.IX Item "_add(OBJ1, OBJ2)"
Returns tha result of addin \s-1OBJ2\s0 ta \s-1OBJ1.\s0
.IP "\fI_mul(\s-1OBJ1, OBJ2\s0)\fR" 4
.IX Item "_mul(OBJ1, OBJ2)"
Returns tha result of multiplyin \s-1OBJ2\s0 n' \s-1OBJ1.\s0
.IP "\fI_div(\s-1OBJ1, OBJ2\s0)\fR" 4
.IX Item "_div(OBJ1, OBJ2)"
Returns tha result of dividin \s-1OBJ1\s0 by \s-1OBJ2\s0 n' truncatin tha result ta an
integer.
.IP "\fI_sub(\s-1OBJ1, OBJ2, FLAG\s0)\fR" 4
.IX Item "_sub(OBJ1, OBJ2, FLAG)"
.PD 0
.IP "\fI_sub(\s-1OBJ1, OBJ2\s0)\fR" 4
.IX Item "_sub(OBJ1, OBJ2)"
.PD
Returns tha result of subtractin \s-1OBJ2\s0 by \s-1OBJ1.\s0 If \f(CW\*(C`flag\*(C'\fR is false or omitted,
\&\s-1OBJ1\s0 might be modified. Y'all KNOW dat shit, muthafucka! If \f(CW\*(C`flag\*(C'\fR is true, \s-1OBJ2\s0 might be modified.
.IP "\fI_dec(\s-1OBJ\s0)\fR" 4
.IX Item "_dec(OBJ)"
Decrement \s-1OBJ\s0 by one.
.IP "\fI_inc(\s-1OBJ\s0)\fR" 4
.IX Item "_inc(OBJ)"
Increment \s-1OBJ\s0 by one.
.IP "\fI_mod(\s-1OBJ1, OBJ2\s0)\fR" 4
.IX Item "_mod(OBJ1, OBJ2)"
Return \s-1OBJ1\s0 modulo \s-1OBJ2,\s0 i.e., tha remainder afta dividin \s-1OBJ1\s0 by \s-1OBJ2.\s0
.IP "\fI_sqrt(\s-1OBJ\s0)\fR" 4
.IX Item "_sqrt(OBJ)"
Return tha square root of tha object, truncated ta integer.
.IP "\fI_root(\s-1OBJ, N\s0)\fR" 4
.IX Item "_root(OBJ, N)"
Return Nth root of tha object, truncated ta int. N is >= 3.
.IP "\fI_fac(\s-1OBJ\s0)\fR" 4
.IX Item "_fac(OBJ)"
Return factorial of object (1*2*3*4*...).
.IP "\fI_pow(\s-1OBJ1, OBJ2\s0)\fR" 4
.IX Item "_pow(OBJ1, OBJ2)"
Return \s-1OBJ1\s0 ta tha juice of \s-1OBJ2.\s0 By convention, 0**0 = 1.
.IP "\fI_modinv(\s-1OBJ1, OBJ2\s0)\fR" 4
.IX Item "_modinv(OBJ1, OBJ2)"
Return modular multiplicatizzle inverse, i.e., return \s-1OBJ3\s0 so that
.Sp
.Vb 1
\&    (OBJ3 * OBJ1) % OBJ2 = 1 % OBJ2
.Ve
.Sp
Da result is returned as two arguments, n' you can put dat on yo' toast. If tha modular multiplicative
inverse do not exist, both arguments is undefined. Y'all KNOW dat shit, muthafucka! Otherwise, the
arguments is a number (object) n' its sign (\*(L"+\*(R" or \*(L"\-\*(R").
.Sp
Da output value, wit its sign, must either be a positizzle value up in the
range 1,2,...,OBJ2\-1 or tha same value subtracted \s-1OBJ2.\s0 For instance, if the
input arguments is objects representin tha numbers 7 n' 5, tha method
must either return a object representin tha number 3 n' a \*(L"+\*(R" sign, since
(3*7) % 5 = 1 % 5, or a object representin tha number 2 n' \*(L"\-\*(R" sign,
since (\-2*7) % 5 = 1 % 5.
.IP "\fI_modpow(\s-1OBJ1, OBJ2, OBJ3\s0)\fR" 4
.IX Item "_modpow(OBJ1, OBJ2, OBJ3)"
Return modular exponentiation, (\s-1OBJ1\s0 ** \s-1OBJ2\s0) % \s-1OBJ3.\s0
.IP "\fI_rsft(\s-1OBJ, N, B\s0)\fR" 4
.IX Item "_rsft(OBJ, N, B)"
Shift object N digits right up in base B n' return tha resultin object. This is
equivalent ta struttin integer division by B**N n' discardin tha remainder,
except dat it might be much faster, dependin on how tha fuck tha number is represented
internally.
.Sp
For instance, if tha object \f(CW$obj\fR represents tha hexadecimal number 0xabcde,
then \f(CW\*(C`_rsft($obj, 2, 16)\*(C'\fR returns a object representin tha number 0xabc. The
\&\*(L"remainer\*(R", 0xde, is discarded n' not returned.
.IP "\fI_lsft(\s-1OBJ, N, B\s0)\fR" 4
.IX Item "_lsft(OBJ, N, B)"
Shift tha object N digits left up in base B. This is equivalent ta multiplyin by
B**N, except dat it might be much faster, dependin on how tha fuck tha number is
represented internally.
.IP "\fI_log_int(\s-1OBJ, B\s0)\fR" 4
.IX Item "_log_int(OBJ, B)"
Return integer log of \s-1OBJ\s0 ta base \s-1BASE.\s0 This method has two output arguments,
the \s-1OBJECT\s0 n' a \s-1STATUS.\s0 Da \s-1STATUS\s0 is Perl scalar; it is 1 if \s-1OBJ\s0 is tha exact
result, 0 if tha result was truncted ta give \s-1OBJ,\s0 n' undef if it is unknown
whether \s-1OBJ\s0 is tha exact result.
.IP "\fI_gcd(\s-1OBJ1, OBJ2\s0)\fR" 4
.IX Item "_gcd(OBJ1, OBJ2)"
Return tha top billin common divisor of \s-1OBJ1\s0 n' \s-1OBJ2.\s0
.PP
\fIBitwise operators\fR
.IX Subsection "Bitwise operators"
.PP
Each of these methodz may modify tha straight-up original gangsta input argument.
.IP "\fI_and(\s-1OBJ1, OBJ2\s0)\fR" 4
.IX Item "_and(OBJ1, OBJ2)"
Return bitwise and. Y'all KNOW dat shit, muthafucka! If necessary, tha smallest number is padded wit leading
zeros.
.IP "\fI_or(\s-1OBJ1, OBJ2\s0)\fR" 4
.IX Item "_or(OBJ1, OBJ2)"
Return bitwise or. Shiiit, dis aint no joke. If necessary, tha smallest number is padded wit leading
zeros.
.IP "\fI_xor(\s-1OBJ1, OBJ2\s0)\fR" 4
.IX Item "_xor(OBJ1, OBJ2)"
Return bitwise exclusive or. Shiiit, dis aint no joke. If necessary, tha smallest number is padded
with leadin zeros.
.PP
\fIBoolean operators\fR
.IX Subsection "Boolean operators"
.IP "\fI_is_zero(\s-1OBJ\s0)\fR" 4
.IX Item "_is_zero(OBJ)"
Returns a legit value if \s-1OBJ\s0 is zero, n' false value otherwise.
.IP "\fI_is_one(\s-1OBJ\s0)\fR" 4
.IX Item "_is_one(OBJ)"
Returns a legit value if \s-1OBJ\s0 is one, n' false value otherwise.
.IP "\fI_is_two(\s-1OBJ\s0)\fR" 4
.IX Item "_is_two(OBJ)"
Returns a legit value if \s-1OBJ\s0 is two, n' false value otherwise.
.IP "\fI_is_ten(\s-1OBJ\s0)\fR" 4
.IX Item "_is_ten(OBJ)"
Returns a legit value if \s-1OBJ\s0 is ten, n' false value otherwise.
.IP "\fI_is_even(\s-1OBJ\s0)\fR" 4
.IX Item "_is_even(OBJ)"
Return a legit value if \s-1OBJ\s0 be a even integer, n' a gangbangin' false value otherwise.
.IP "\fI_is_odd(\s-1OBJ\s0)\fR" 4
.IX Item "_is_odd(OBJ)"
Return a legit value if \s-1OBJ\s0 be a even integer, n' a gangbangin' false value otherwise.
.IP "\fI_acmp(\s-1OBJ1, OBJ2\s0)\fR" 4
.IX Item "_acmp(OBJ1, OBJ2)"
Compare \s-1OBJ1\s0 n' \s-1OBJ2\s0 n' return \-1, 0, or 1, if \s-1OBJ1\s0 is less than, equal
to, or larger than \s-1OBJ2,\s0 respectively.
.PP
\fIStrin conversion\fR
.IX Subsection "Strin conversion"
.IP "\fI_str(\s-1OBJ\s0)\fR" 4
.IX Item "_str(OBJ)"
Return a strang representin tha object. Da returned strang should have no
leadin zeros, i.e., it should match \f(CW\*(C`^(0|[1\-9]\ed*)$\*(C'\fR.
.IP "\fI_as_bin(\s-1OBJ\s0)\fR" 4
.IX Item "_as_bin(OBJ)"
Return tha binary strang representation of tha number n' shit. Da strang must have a
\&'0b' prefix.
.IP "\fI_as_oct(\s-1OBJ\s0)\fR" 4
.IX Item "_as_oct(OBJ)"
Return tha octal strang representation of tha number n' shit. Da strang must have
a '0x' prefix.
.Sp
Note: This method was required from Math::BigInt version 1.78 yo, but tha required
\&\s-1API\s0 version number was not incremented, so there be olda libraries that
support \s-1API\s0 version 1 yo, but do not support \f(CW\*(C`_as_oct()\*(C'\fR.
.IP "\fI_as_hex(\s-1OBJ\s0)\fR" 4
.IX Item "_as_hex(OBJ)"
Return tha hexadecimal strang representation of tha number n' shit. Da strang must
have a '0x' prefix.
.PP
\fINumeric conversion\fR
.IX Subsection "Numeric conversion"
.IP "\fI_num(\s-1OBJ\s0)\fR" 4
.IX Item "_num(OBJ)"
Given a object, return a Perl scalar number (int/float) representin this
number.
.PP
\fIMiscellaneous\fR
.IX Subsection "Miscellaneous"
.IP "\fI_copy(\s-1OBJ\s0)\fR" 4
.IX Item "_copy(OBJ)"
Return a legit copy of tha object.
.IP "\fI_len(\s-1OBJ\s0)\fR" 4
.IX Item "_len(OBJ)"
Returns tha number of tha decimal digits up in tha number n' shit. Da output be a
Perl scalar.
.IP "\fI_zeros(\s-1OBJ\s0)\fR" 4
.IX Item "_zeros(OBJ)"
Return tha number of trailin decimal zeros. Da output be a Perl scalar.
.IP "\fI_digit(\s-1OBJ, N\s0)\fR" 4
.IX Item "_digit(OBJ, N)"
Return tha Nth digit as a Perl scalar. Shiiit, dis aint no joke. N be a Perl scalar, where zero refers to
the rightmost (least significant) digit, n' wack joints count from the
left (most dope digit). If \f(CW$obj\fR represents tha number 123, then
\&\fI_digit($obj, 0)\fR is 3 n' \fI_digit(123, \-1)\fR is 1.
.IP "\fI_check(\s-1OBJ\s0)\fR" 4
.IX Item "_check(OBJ)"
Return a legit value if tha object is \s-1OK,\s0 n' a gangbangin' false value otherwise. This be a
check routine ta test tha internal state of tha object fo' corruption.
.SS "\s-1API\s0 version 2"
.IX Subsection "API version 2"
Da followin methodz is required fo' a \s-1API\s0 version of 2 or pimped outer.
.PP
\fIConstructors\fR
.IX Subsection "Constructors"
.IP "\fI_1ex(N)\fR" 4
.IX Item "_1ex(N)"
Return a object representin tha number 10**N where N >= 0 be a Perl
scalar.
.PP
\fIMathematical functions\fR
.IX Subsection "Mathematical functions"
.IP "\fI_nok(\s-1OBJ1, OBJ2\s0)\fR" 4
.IX Item "_nok(OBJ1, OBJ2)"
Return tha binomial coefficient \s-1OBJ1\s0 over \s-1OBJ1.\s0
.PP
\fIMiscellaneous\fR
.IX Subsection "Miscellaneous"
.IP "\fI_alen(\s-1OBJ\s0)\fR" 4
.IX Item "_alen(OBJ)"
Return tha approximate number of decimal digitz of tha object. The
output is one Perl scalar. Shiiit, dis aint no joke. This estimate must be pimped outa than or equal
to what tha fuck \f(CW\*(C`_len()\*(C'\fR returns.
.SS "\s-1API\s0 optionizzle methods"
.IX Subsection "API optionizzle methods"
Da followin methodz is optional, n' can be defined if tha underlyin lib
has a gangbangin' fast way ta do em. If undefined, Math::BigInt will use pure Perl (hence
slow) fallback routines ta emulate these:
.PP
\fISigned bitwise operators.\fR
.IX Subsection "Signed bitwise operators."
.PP
Each of these methodz may modify tha straight-up original gangsta input argument.
.IP "\fI_signed_or(\s-1OBJ1, OBJ2, SIGN1, SIGN2\s0)\fR" 4
.IX Item "_signed_or(OBJ1, OBJ2, SIGN1, SIGN2)"
Return tha signed bitwise or.
.IP "\fI_signed_and(\s-1OBJ1, OBJ2, SIGN1, SIGN2\s0)\fR" 4
.IX Item "_signed_and(OBJ1, OBJ2, SIGN1, SIGN2)"
Return tha signed bitwise and.
.IP "\fI_signed_xor(\s-1OBJ1, OBJ2, SIGN1, SIGN2\s0)\fR" 4
.IX Item "_signed_xor(OBJ1, OBJ2, SIGN1, SIGN2)"
Return tha signed bitwise exclusive or.
.SH "WRAP YOUR OWN"
.IX Header "WRAP YOUR OWN"
If you wanna port yo' own most straight-up bangin c\-lib fo' big-ass numbers ta the
Math::BigInt intercourse, you can take any of tha already existin modulez as
a rough guideline. Yo ass should straight-up wrap up tha sickest fuckin BigInt n' BigFloat
testsuites wit yo' module, n' replace up in dem any of tha following:
.PP
.Vb 1
\&        use Math::BigInt;
.Ve
.PP
by this:
.PP
.Vb 1
\&        use Math::BigInt lib => \*(Aqyourlib\*(Aq;
.Ve
.PP
This way you ensure dat yo' library straight-up works 100% within Math::BigInt.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Original Gangsta math code by Mark Biggar, rewritten by Tels <http://bloodgate.com/>
in late 2000.
.IP "\(bu" 4
Separated from BigInt n' shaped \s-1API\s0 wit tha help of Jizzy Peacock.
.IP "\(bu" 4
Fixed, speed-up, streamlined n' enhanced by Tels 2001 \- 2007.
.IP "\(bu" 4
\&\s-1API\s0 documentation erected n' extended by Peta Jizzy Acklam,
<pjacklam@online.no>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::BigInt, Math::BigFloat,
Math::BigInt::GMP, Math::BigInt::FastCalc n' Math::BigInt::Pari.
