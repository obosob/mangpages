.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::Tree::Scannin 3"
.TH HTML::Tree::Scannin 3 "2013-08-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::Tree::Scannin \-\- article: "Scannin HTML"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # This a article, not a module.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da followin article by Shizzle M. Burke first rocked up in \fIDa Perl
Journal\fR #19 n' is copyright 2000 Da Perl Journal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Well shiiiit, it appears
courtesy of Jizzle Orwant n' Da Perl Journal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  This document may be
distributed under tha same terms as Perl itself.
.PP
(Note dat dis is discussed up in chaptas 6 all up in 10 of the
book \fIPerl n' \s-1LWP\s0\fR <http://lwp.interglacial.com/> which
was freestyled afta tha followin documentation, n' which is
available free online. Put ya muthafuckin choppers up if ya feelin dis shiznit!)
.SH "Scannin HTML"
.IX Header "Scannin HTML"
\&\-\- Shizzle M. Burke
.PP
In \fIDa Perl Journal\fR issue 17, Ken MacFarlanez article \*(L"Parsing
\&\s-1HTML\s0 wit HTML::Parser\*(R" raps bout how tha fuck tha HTML::Parser module scans
\&\s-1HTML\s0 source as a stream of start-tags, end-tags, text, comments, etc.
In \s-1TPJ\s0 #18, mah \*(L"Trees\*(R" article kicked round tha scam of tree-shaped
data structures.  Now I be bout ta try ta tie it together, up in a gangbangin' finger-lickin' rap of
\&\s-1HTML\s0 trees.
.PP
Da \s-1CPAN\s0 module HTML::TreeBuilder takes the
tags dat HTML::Parser picks out, n' buildz a parse tree \*(-- a
tree-shaped network of objects...
.Sp
.RS 4
Footnote:
And if you need a quick explanation of objects, peep mah \s-1TPJ17\s0 article \*(L"A
Userz View of Object-Oriented Modules\*(R"; or go whole hog n' git Damian
Conwayz pimpin book \fIObject-Oriented Perl\fR, from Manning
Publications.
.RE
.PP
\&...representin tha structured content of tha \s-1HTML\s0 document.  And once
the document is parsed as a tree, you gonna find tha common tasks
of extractin data from dat \s-1HTML\s0 document/tree ta be quite
straightforward.
.SS "HTML::Parser, HTML::TreeBuilder, n' HTML::Element"
.IX Subsection "HTML::Parser, HTML::TreeBuilder, n' HTML::Element"
Yo ass use HTML::TreeBuilder ta cook up a parse tree outta a \s-1HTML\s0 source
file, by simply saying:
.PP
.Vb 3
\&  use HTML::TreeBuilder;
\&  mah $tree = HTML::TreeBuilder\->new();
\&  $tree\->parse_file(\*(Aqfoo.html\*(Aq);
.Ve
.PP
and then \f(CW$tree\fR gotz nuff a parse tree built from tha \s-1HTML\s0 source from
the file \*(L"foo.html\*(R".  Da way dis parse tree is represented is wit a
network of objects \*(-- \f(CW$tree\fR is tha root, a element wit tag-name
\&\*(L"html\*(R", n' its lil pimps typically include a \*(L"head\*(R" n' \*(L"body\*(R" element,
and so on. I aint talkin' bout chicken n' gravy biatch.  Elements up in tha tree is objectz of tha class
HTML::Element.
.PP
So, if you take dis source:
.PP
.Vb 4
\&  <html><head><title>Doc 1</title></head>
\&  <body>
\&  Stuff <hr> 2000\-08\-17
\&  </body></html>
.Ve
.PP
and feed it ta HTML::TreeBuilder, it'll return a tree of objects that
looks like this:
.PP
.Vb 7
\&               html
\&             /      \e
\&         head        body
\&        /          /   |  \e
\&     title    "Stuff"  hr  "2000\-08\-17"
\&       |
\&    "Doc 1"
.Ve
.PP
This be a pimpin' simple document yo, but if it was any mo' complex,
it'd be a lil' bit hard ta draw up in dat style, since itz sprawl left and
right.  Da same tree can be represented a lil' bit mo' easily sideways,
with indenting:
.PP
.Vb 8
\&  . html
\&     . head
\&        . title
\&           . "Doc 1"
\&     . body
\&        . "Stuff"
\&        . hr
\&        . "2000\-08\-17"
.Ve
.PP
Either way expresses tha same ol' dirty structure.  In dat structure, tha root
node be a object of tha class HTML::Element
.Sp
.RS 4
Footnote:
Well actually, tha root iz of tha class HTML::TreeBuilder yo, but that's
just a subclass of HTML::Element, plus tha few extra methodz like
\&\f(CW\*(C`parse_file\*(C'\fR dat elaborate tha tree
.RE
.PP
, wit tha tag name \*(L"html\*(R", n' wit two children: a HTML::Element
object whose tag names is \*(L"head\*(R" n' \*(L"body\*(R".  And each of them
elements have children, n' so on down. I aint talkin' bout chicken n' gravy biatch.  Not all elements (as we'll
call tha objectz of class HTML::Element) have lil pimps \*(-- tha \*(L"hr\*(R"
element don't.  And note all nodes up in tha tree is elements \*(-- the
text nodes (\*(L"Doc 1\*(R", \*(L"Stuff\*(R", n' \*(L"2000\-08\-17\*(R") is just strings.
.PP
Objectz of tha class HTML::Element each have three noteworthy attributes:
.ie n .IP """_tag"" \*(-- (best accessed as ""$e\->tag"") dis elementz tag-name, lowercased (e.g., ""em"" fo' a ""em"" element)." 4
.el .IP "\f(CW_tag\fR \*(-- (best accessed as \f(CW$e\->tag\fR) dis elementz tag-name, lowercased (e.g., ``em'' fo' a ``em'' element)." 4
.IX Item "_tag (best accessed as $e->tag) dis elementz tag-name, lowercased (e.g., em fo' a em element)."
.RS 4
.RS 4
Footnote: Yes, dis is misnamed. Y'all KNOW dat shit, muthafucka!  In proper \s-1SGML\s0 terminology, dis is
instead called a \*(L"\s-1GI\*(R",\s0 short fo' \*(L"generic identifier\*(R"; n' tha term
\&\*(L"tag\*(R" is used fo' a token of \s-1SGML\s0 source dat represents either
the start of a element (a start-tag like \*(L"<em lang='fr'>\*(R") or tha end
of a element (an end-tag like \*(L"</em>\*(R".  But fuck dat shiznit yo, tha word on tha street is dat since mo' people
claim ta done been abducted by aliens than ta have eva peeped the
\&\s-1SGML\s0 standard, n' since both encountas typically involve a gangbangin' feelin of
\&\*(L"missin time\*(R", it aint surprisin dat tha terminologizzle of tha \s-1SGML\s0
standard aint closely followed.
.RE
.RE
.RS 4
.RE
.ie n .IP """_parent"" \*(-- (best accessed as ""$e\->parent"") tha element dat is $objz parent, or undef if dis element is tha root of its tree." 4
.el .IP "\f(CW_parent\fR \*(-- (best accessed as \f(CW$e\->parent\fR) tha element dat is \f(CW$obj\fRz parent, or undef if dis element is tha root of its tree." 4
.IX Item "_parent (best accessed as $e->parent) tha element dat is $objz parent, or undef if dis element is tha root of its tree."
.PD 0
.ie n .IP """_content"" \*(-- (best accessed as ""$e\->content_list"") tha list of nodes (i.e., elements or text segments) dat is $ez lil' thugs." 4
.el .IP "\f(CW_content\fR \*(-- (best accessed as \f(CW$e\->content_list\fR) tha list of nodes (i.e., elements or text segments) dat is \f(CW$e\fRz lil' thugs." 4
.IX Item "_content (best accessed as $e->content_list) tha list of nodes (i.e., elements or text segments) dat is $ez lil' thugs."
.PD
.PP
Mo'over, if a element object has any attributes up in tha \s-1SGML\s0 sense of
the word, then dem is readable as \f(CW\*(C`$e\->attr(\*(Aqname\*(Aq)\*(C'\fR \*(-- for
example, wit tha object built from havin parsed "<a
\&\fBid='foo'\fR>bar</a>", \f(CW\*(C`$e\->attr(\*(Aqid\*(Aq)\*(C'\fR will return
the strang \*(L"foo\*(R".  Mo'over, \f(CW\*(C`$e\->tag\*(C'\fR on dat object returns the
strin \*(L"a\*(R", \f(CW\*(C`$e\->content_list\*(C'\fR returns a list consistin of just
the single scalar \*(L"bar\*(R", n' \f(CW\*(C`$e\->parent\*(C'\fR returns tha object
thatz dis nodez parent \*(-- which may be, fo' example, a \*(L"p\*(R" element.
.PP
And thatz all dat there is ta it \*(-- you throw \s-1HTML\s0
source at TreeBuilder, n' it returns a tree built of HTML::Element
objects n' some text strings.
.PP
But fuck dat shiznit yo, tha word on tha street is dat what tha fuck do you \fIdo\fR wit a tree of objects?  Muthafuckas code
information tha fuck into \s-1HTML\s0 trees not fo' tha funk of arrangin elements yo, but
to represent tha structure of specific text n' images \*(-- some text is
in dis \*(L"li\*(R" element, some other text is up in dat heading, some
images is up in dat other table cell dat has dem attributes, n' so on.
.PP
Now, it may happen dat you renderin dat whole \s-1HTML\s0 tree tha fuck into some
layout format.  Or you could be tryin ta cook up some fuckin systematic chizzle to
the \s-1HTML\s0 tree before dumpin it up as \s-1HTML\s0 source again. I aint talkin' bout chicken n' gravy biatch.  But, up in my
experience, by far da most thugged-out common programmin task dat Perl
programmers grill wit \s-1HTML\s0 is up in tryin ta extract some piece
of shiznit from a larger document.  Since thatz so common (and
also since it involves concepts dat is basic ta mo' complex tasks),
that is what tha fuck tha rest of dis article is ghon be about.
.SS "Scannin \s-1HTML\s0 trees"
.IX Subsection "Scannin HTML trees"
Suppose you gotz a thousand \s-1HTML\s0 documents, each of dem a press
release.  They all start out:
.PP
.Vb 7
\&  [...lotz of leadin images n' junk...]
\&  <h1>ConGlomCo ta Open New Corporate Office up in Ougadougou</h1>
\&  BAKERSFIELD, CA, 2000\-04\-24 \-\- ConGlomCo\*(Aqs vice prez up in charge
\&  of ghetto conquest, Rock Feldspar, announced todizzle tha openin of a
\&  freshly smoked up crib up in Ougadougou, tha capital hood of Burkino Faso, gateway
\&  ta tha bustlin "Silicon Sahara" of Africa...
\&  [...etc...]
.Ve
.PP
\&...and what tha fuck you've gots ta do is, fo' each document, copy whatever text
is up in tha \*(L"h1\*(R" element, so dat you can, fo' example, cook up a table of
contentz of dat shit.  Now, there be three ways ta do this:
.IP "\(bu" 4
Yo ass can just bust a regexp ta scan tha file fo' a text pattern.
.Sp
For nuff straight-up simple tasks, dis will do fine.  Many \s-1HTML\s0 documents are,
in practice, straight-up consistently formatted as far as placement of
linebreaks n' whitespace, so you could just git away wit scannin the
file like so:
.Sp
.Vb 10
\&  sub get_headin {
\&    mah $filename = $_[0];
\&    local *HTML;
\&    open(HTML, $filename)
\&      or take a thugged-out dirtnap "Couldn\*(Aqt open $filename);
\&    mah $heading;
\&   Line:
\&    while(<HTML>) {
\&      if( m{<h1>(.*?)</h1>}i ) {  # match dat shiznit son!
\&        $headin = $1;
\&        last Line;
\&      }
\&    }
\&    close(HTML);
\&    warn "No headin up in $filename?"
\&     unless defined $heading;
\&    return $heading;
\&  }
.Ve
.Sp
This is quick n' fast yo, but awfully fragile \*(-- if there be a a newline in
the middle of a headingz text, it won't match tha above regexp, and
yo dirty ass is gonna git a error. Shiiit, dis aint no joke.  Da regexp will also fail if tha \*(L"h1\*(R" element's
start-tag has any attributes.  If you gotta adapt yo' code ta fit
more kindz of start-tags, you gonna end up basically reinventin part of
HTML::Parser, at which point you should probably just stop, n' use
HTML::Parser itself:
.IP "\(bu" 4
Yo ass can use HTML::Parser ta scan tha file fo' a \*(L"h1\*(R" start-tag
token, then capture all tha text tokens until tha \*(L"h1\*(R" close-tag.  This
approach is extensively covered up in tha Ken MacFarlanez \s-1TPJ17\s0 article
\&\*(L"Parsin \s-1HTML\s0 wit HTML::Parser\*(R".  (A variant of dis approach is ta use
HTML::TokeParser, which presents a gangbangin' finger-lickin' different n' rather handier
interface ta tha tokens dat HTML::Parser picks out.)
.Sp
Usin HTML::Parser is less fragile than our first approach, since it's
not sensitizzle ta tha exact internal formattin of tha start-tag (much
less whether itz split across two lines).  But fuck dat shiznit yo, tha word on tha street is dat when you need more
information bout tha context of tha \*(L"h1\*(R" element, or if you having
to deal wit any of tha tricky bitz of \s-1HTML,\s0 like fuckin parsin of tables,
yo dirty ass is gonna smoke up tha flat list of tokens dat HTML::Parser returns
aint immediately useful naaahhmean?  To git suttin' useful outta dem tokens,
yo dirty ass is gonna need ta write code dat knows some thangs bout what tha fuck elements
take no content (as wit \*(L"hr\*(R" elements), n' dat a \*(L"</p>\*(R" end-tags
are omissible, so a \*(L"<p>\*(R" will end any currently
open paragraph \*(-- n' you well on yo' way ta pointlessly
reinventin much of tha code up in HTML::TreeBuilder
.RS 4
.Sp
.RS 4
Footnote:
And, as tha thug whoz ass last rewrote dat module, I can attest dat it
wasn't terribly easy as fuck  ta git right son!  Never underestimate tha perversity
of playas codin \s-1HTML.\s0
.RE
.RE
.RS 4
.Sp
, at which point you should probably just stop, n' use
HTML::TreeBuilder itself:
.RE
.IP "\(bu" 4
Yo ass can use HTML::Treebuilder, n' scan tha tree of element
objects dat you git back.
.PP
Da last approach, rockin HTML::TreeBuilder, is tha diametric opposite of
first approach:  Da first approach involves just elementary Perl n' one
regexp, whereas tha TreeBuilder approach involves bein up in da crib with
the concept of tree-shaped data structures n' modulez with
object-oriented intercourses, as well as wit tha particular intercourses
that HTML::TreeBuilder n' HTML::Element provide.
.PP
But fuck dat shiznit yo, tha word on tha street is dat what tha fuck tha TreeBuilder approach has goin fo' it is dat it's
da most thugged-out robust, cuz it involves dealin wit \s-1HTML\s0 up in its \*(L"native\*(R"
format \*(-- it deals wit tha tree structure dat \s-1HTML\s0 code represents,
without any consideration of how tha fuck tha source is coded n' wit what
tags omitted.
.PP
So, ta extract tha text from tha \*(L"h1\*(R" elementz of a \s-1HTML\s0 document:
.PP
.Vb 10
\&  sub get_headin {
\&    mah $tree = HTML::TreeBuilder\->new;
\&    $tree\->parse_file($_[0]);   # !
\&    mah $heading;
\&    mah $h1 = $tree\->look_down(\*(Aq_tag\*(Aq, \*(Aqh1\*(Aq);  # !
\&    if($h1) {
\&      $headin = $h1\->as_text;   # !
\&    } else {
\&      warn "No headin up in $_[0]?";
\&    }
\&    $tree\->delete; # clear memory!
\&    return $heading;
\&  }
.Ve
.PP
This uses some unfamiliar methodz dat need explaining.  The
\&\f(CW\*(C`parse_file\*(C'\fR method dat we've peeped before, buildz a tree based on
source from tha file given. I aint talkin' bout chicken n' gravy biatch.  Da \f(CW\*(C`delete\*(C'\fR method is fo' markin a
treez contents as available fo' garbage collection, when you done
with tha tree.  Da \f(CW\*(C`as_text\*(C'\fR method returns a strang dat gotz nuff
all tha text bits dat is lil pimps (or otherwise descendants) of the
given node \*(-- ta git tha text content of tha \f(CW$h1\fR object, we could
just say:
.PP
.Vb 1
\&  $headin = join \*(Aq\*(Aq, $h1\->content_list;
.Ve
.PP
but dat will work only if we shizzle dat tha \*(L"h1\*(R" elementz children
will be only text bits \*(-- if tha document contained:
.PP
.Vb 1
\&  <h1>Local Man Sees <cite>Blade</cite> Again</h1>
.Ve
.PP
then tha sub-tree would be:
.PP
.Vb 5
\&  . h1
\&    . "Local Man Sees "
\&    . cite
\&      . "Blade"
\&    . " Again\*(Aq
.Ve
.PP
so \f(CW\*(C`join \*(Aq\*(Aq, $h1\->content_list\*(C'\fR is ghon be suttin' like:
.PP
.Vb 1
\&  Local Man Sees HTML::Element=HASH(0x15424040) Again
.Ve
.PP
whereas \f(CW\*(C`$h1\->as_text\*(C'\fR would yield:
.PP
.Vb 1
\&  Local Man Sees Blade Again
.Ve
.PP
and dependin on what tha fuck you bustin wit tha headin text, you might
want tha \f(CW\*(C`as_HTML\*(C'\fR method instead. Y'all KNOW dat shit, muthafucka!  It returns tha (sub)tree
represented as \s-1HTML\s0 source.  \f(CW\*(C`$h1\->as_HTML\*(C'\fR would yield:
.PP
.Vb 1
\&  <h1>Local Man Sees <cite>Blade</cite> Again</h1>
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat if you wanted tha contentz of \f(CW$h1\fR as \s-1HTML,\s0 but not the
\&\f(CW$h1\fR itself, you could say:
.PP
.Vb 5
\&  join \*(Aq\*(Aq,
\&    map(
\&      ref($_) ? $_\->as_HTML : $_,
\&      $h1\->content_list
\&    )
.Ve
.PP
This \f(CW\*(C`map\*(C'\fR iterates over tha nodes up in \f(CW$h1\fRz list of children; and
for each node thatz just a text bit (as \*(L"Local Man Sees \*(R" is), it just
passes all up in dat strang value, n' fo' each node thatz a actual
object (causin \f(CW\*(C`ref\*(C'\fR ta be true), \f(CW\*(C`as_HTML\*(C'\fR will used instead of the
strin value of tha object itself (which would be suttin' quite
useless, as most object joints are).  So dat \f(CW\*(C`as_HTML\*(C'\fR fo' tha \*(L"cite\*(R"
element is ghon be tha strang \*(L"<cite>Blade</cite>\*(R".  And then,
finally, \f(CW\*(C`join\*(C'\fR just puts tha fuck into one strang all tha strings dat the
\&\f(CW\*(C`map\*(C'\fR returns.
.PP
Last but not least, da most thugged-out blingin method up in our \f(CW\*(C`get_heading\*(C'\fR sub
is tha \f(CW\*(C`look_down\*(C'\fR method. Y'all KNOW dat shit, muthafucka!  This method looks down all up in tha subtree
startin all up in tha given object (\f(CW$h1\fR), lookin fo' elements dat meet
criteria you provide.
.PP
Da criteria is specified up in tha methodz argument list.  Each
criterion can consist of two scalars, a key n' a value, which express
that you want elements dat have dat attribute (like \*(L"_tag\*(R", or
\&\*(L"src\*(R") wit tha given value (\*(L"h1\*(R"); or tha criterion can be a
reference ta a subroutine that, when called on tha given element,
returns legit if dat be a node you lookin for. Shiiit, dis aint no joke.  If you specify
several criteria, then thatz taken ta mean dat you want all the
elements dat each satisfy \fIall\fR tha criteria.  (In other lyrics,
therez a \*(L"implicit \s-1AND\*(R".\s0)
.PP
And finally, there be a a lil' bit of a optimization \*(-- if you call the
\&\f(CW\*(C`look_down\*(C'\fR method up in a scalar context, you git just tha \fIfirst\fR node
(or undef if none) \*(-- and, up in fact, once \f(CW\*(C`look_down\*(C'\fR findz dat first
matchin element, it don't bother lookin any further.
.PP
So tha example:
.PP
.Vb 1
\&  $h1 = $tree\->look_down(\*(Aq_tag\*(Aq, \*(Aqh1\*(Aq);
.Ve
.PP
returns tha straight-up original gangsta element at-or-under \f(CW$tree\fR whose \f(CW"_tag"\fR
attribute has tha value \f(CW"h1"\fR.
.SS "Complex Criteria up in Tree Scanning"
.IX Subsection "Complex Criteria up in Tree Scanning"
Now, tha above \f(CW\*(C`look_down\*(C'\fR code be lookin like a shitload of bother, with
barely mo' benefit than just greppin tha file biaaatch!  But consider if your
criteria was mo' fucked up \*(-- suppose you found dat a shitload of the
press releases dat you was scannin had nuff muthafuckin \*(L"h1\*(R" elements,
possibly before or afta tha one you straight-up want.  For example:
.PP
.Vb 8
\&  <h1><center>Smoke up Our Corporate Partner
\&   <br><a href="/dyna/clickthru"
\&     ><img src="/dyna/vend_ad"></a>
\&  </center></h1>
\&  <h1><center>ConGlomCo Prezzy Schreck ta Smoke up Regionizzle HQ
\&   <br><a href="/photos/Schreck_visit_large.jpg"
\&     ><img src="/photos/Schreck_visit.jpg"></a>
\&  </center></h1>
.Ve
.PP
Here, you wanna ignore tha straight-up original gangsta \*(L"h1\*(R" element cuz it gotz nuff an
ad, n' you want tha text from tha second \*(L"h1\*(R".  Da problem is in
formalizin tha way you know dat itz a ad. Y'all KNOW dat shit, muthafucka!  Since ad banners are
always entreatin you ta \*(L"visit\*(R" tha sponsorin crib, you could exclude
\&\*(L"h1\*(R" elements dat contain tha word \*(L"visit\*(R" under them:
.PP
.Vb 6
\&  mah $real_h1 = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqh1\*(Aq,
\&    sub {
\&      $_[0]\->as_text !~ m/\ebvisit/i
\&    }
\&  );
.Ve
.PP
Da first criterion looks fo' \*(L"h1\*(R" elements, n' tha second criterion
limits dem ta only tha ones whose text content don't match
\&\f(CW\*(C`m/\ebvisit/\*(C'\fR.  But unfortunately, dat won't work fo' our example,
since tha second \*(L"h1\*(R" mentions "ConGlomCo Prezzy Schreck to
\&\fIVisit\fR Regionizzle \s-1HQ".\s0
.PP
Instead you could try lookin fo' tha straight-up original gangsta \*(L"h1\*(R" element that
doesn't contain a image:
.PP
.Vb 6
\&  mah $real_h1 = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqh1\*(Aq,
\&    sub {
\&      not $_[0]\->look_down(\*(Aq_tag\*(Aq, \*(Aqimg\*(Aq)
\&    }
\&  );
.Ve
.PP
This criterion sub might seem a lil' bit odd, since it calls \f(CW\*(C`look_down\*(C'\fR
as part of a larger \f(CW\*(C`look_down\*(C'\fR operation yo, but thatz fine.  Note that
when considered as a funky-ass boolean value, a \f(CW\*(C`look_down\*(C'\fR up in a scalar context
value returns false (specifically, undef) if there be a no matchin element
at or under tha given element; n' it returns tha straight-up original gangsta matching
element (which, bein a reference n' object, be always a legit value),
if any matches.  So, here,
.PP
.Vb 3
\&  sub {
\&    not $_[0]\->look_down(\*(Aq_tag\*(Aq, \*(Aqimg\*(Aq)
\&  }
.Ve
.PP
means \*(L"return legit only if dis element has no 'img' element as
descendants (and aint a 'img' element itself).\*(R"
.PP
This erectly filtas up tha straight-up original gangsta \*(L"h1\*(R" dat gotz nuff tha ad yo, but it
also incorrectly filtas up tha second \*(L"h1\*(R" dat gotz nuff a
non-advertisement photo besides tha headline text you want.
.PP
There clearly is detectable differences between tha straight-up original gangsta n' second
\&\*(L"h1\*(R" elements \*(-- tha only second one gotz nuff tha strang \*(L"Schreck\*(R", and
we could just test fo' that:
.PP
.Vb 6
\&  mah $real_h1 = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqh1\*(Aq,
\&    sub {
\&      $_[0]\->as_text =~ m{Schreck}
\&    }
\&  );
.Ve
.PP
And dat works fine fo' dis one example yo, but unless all thousand of
your press releases have \*(L"Schreck\*(R" up in tha headline, thatz just not a
general solution. I aint talkin' bout chicken n' gravy biatch.  But fuck dat shiznit yo, tha word on tha street is dat if all tha ads\-in\-\*(L"h1\*(R"s dat you want to
exclude involve a link whose \s-1URL\s0 involves \*(L"/dyna/\*(R", then you can use
that:
.PP
.Vb 11
\&  mah $real_h1 = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqh1\*(Aq,
\&    sub {
\&      mah $link = $_[0]\->look_down(\*(Aq_tag\*(Aq,\*(Aqa\*(Aq);
\&      return 1 unless $link;
\&        # no link means it\*(Aqs fine
\&      return 0 if $link\->attr(\*(Aqhref\*(Aq) =~ m{/dyna/};
\&        # a link ta there is bad
\&      return 1; # otherwise aiiight
\&    }
\&  );
.Ve
.PP
Or you can peep it another way n' say dat you want tha straight-up original gangsta \*(L"h1\*(R"
element dat either gotz nuff no images, or else whose image has a \*(L"src\*(R"
attribute whose value gotz nuff \*(L"/photos/\*(R":
.PP
.Vb 11
\&  mah $real_h1 = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqh1\*(Aq,
\&    sub {
\&      mah $img = $_[0]\->look_down(\*(Aq_tag\*(Aq,\*(Aqimg\*(Aq);
\&      return 1 unless $img;
\&        # no image means it\*(Aqs fine
\&      return 1 if $img\->attr(\*(Aqsrc\*(Aq) =~ m{/photos/};
\&        # phat if a photo
\&      return 0; # otherwise bad
\&    }
\&  );
.Ve
.PP
Recall dat dis use of \f(CW\*(C`look_down\*(C'\fR up in a scalar context means ta return
the first element at or under \f(CW$tree\fR dat matches all tha criteria.
But if you notice dat you can formulate criteria that'll match several
possible \*(L"h1\*(R" elements, a shitload of which may be bogus but tha \fIlast\fR one
of which be always tha one you want, then you can use \f(CW\*(C`look_down\*(C'\fR up in a
list context, n' just use tha last element of dat list:
.PP
.Vb 6
\&  mah @h1s = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqh1\*(Aq,
\&    ...maybe mo' criteria...
\&  );
\&  take a thugged-out dirtnap "What, no h1s here?" unless @h1s;
\&  mah $real_h1 = $h1s[\-1]; # last or only
.Ve
.SS "A Case Study: Scannin Yahoo Shitz \s-1HTML\s0"
.IX Subsection "A Case Study: Scannin Yahoo Shitz HTML"
Da above (somewhat contrived) case involves extractin data from a
bunch of pre-existin \s-1HTML\s0 files.  In dat sort of thang, if your
code works fo' all tha files, then you know dat tha code \fIworks\fR \*(--
since tha data itz meant ta handle won't go changin or growing; and,
typically, once you've used tha program, you gonna never need ta use it
again.
.PP
Da other kind of thang faced up in nuff data extraction tasks is
where tha program is used recurringly ta handle freshly smoked up data \*(-- such as
from ever-changin Web pages.  As a real-world example of this,
consider a program dat you could use (suppose itz crontabbed) to
extract headline-links from subsectionz of Yahoo Shit
(\f(CW\*(C`http://dailynews.yahoo.com/\*(C'\fR).
.PP
Yahoo Shit has nuff muthafuckin subsections:
.IP "http://dailynews.yahoo.com/h/tc/ fo' technologizzle news" 4
.IX Item "http://dailynews.yahoo.com/h/tc/ fo' technologizzle news"
.PD 0
.IP "http://dailynews.yahoo.com/h/sc/ fo' science news" 4
.IX Item "http://dailynews.yahoo.com/h/sc/ fo' science news"
.IP "http://dailynews.yahoo.com/h/hl/ fo' game news" 4
.IX Item "http://dailynews.yahoo.com/h/hl/ fo' game news"
.IP "http://dailynews.yahoo.com/h/wl/ fo' ghetto news" 4
.IX Item "http://dailynews.yahoo.com/h/wl/ fo' ghetto news"
.IP "http://dailynews.yahoo.com/h/en/ fo' entertainment news" 4
.IX Item "http://dailynews.yahoo.com/h/en/ fo' entertainment news"
.PD
.PP
and others.  All of dem is built on tha same basic \s-1HTML\s0 template \*(--
and a scarily fucked up template it is, especially when you peep
it wit a eye toward makin up rulez dat will select where tha real
headline-links are, while screenin up all tha links ta other parts of
Yahoo, other shizzle skillz, etc.  Yo ass will need ta puzzle
over tha \s-1HTML\s0 source, n' scrutinize tha output of
\&\f(CW\*(C`$tree\->dump\*(C'\fR on tha parse tree of dat \s-1HTML.\s0
.PP
Sometimes tha only way ta pin down what tha fuck you afta is by posizzle in
the tree. For example, headlinez of interest may be up in tha third
column of tha second row of tha second table element up in a page:
.PP
.Vb 4
\&  mah $table = ( $tree\->look_down(\*(Aq_tag\*(Aq,\*(Aqtable\*(Aq) )[1];
\&  mah $row2  = ( $table\->look_down(\*(Aq_tag\*(Aq, \*(Aqtr\*(Aq ) )[1];
\&  mah $col3  = ( $row2\->look\-down(\*(Aq_tag\*(Aq, \*(Aqtd\*(Aq)   )[2];
\&  ...then do thangs wit $col3...
.Ve
.PP
Or they may be all tha links up in a \*(L"p\*(R" element dat has at least three
\&\*(L"br\*(R" elements as children:
.PP
.Vb 8
\&  mah $p = $tree\->look_down(
\&    \*(Aq_tag\*(Aq, \*(Aqp\*(Aq,
\&    sub {
\&      2 < grep { ref($_) n' $_\->tag eq \*(Aqbr\*(Aq }
\&               $_[0]\->content_list
\&    }
\&  );
\&  @links = $p\->look_down(\*(Aq_tag\*(Aq, \*(Aqa\*(Aq);
.Ve
.PP
But almost always, you can git away wit lookin fo' propertizzlez of the
of tha thang itself, rather than just lookin fo' contexts, n' you can put dat on yo' toast.  Now, if
yo ass is dirty, tha document you lookin all up in has clear semantic
tagging, such be as useful up in \s-1CSS\s0 \*(-- note the
class=\*(L"headlinelink\*(R" bit here:
.PP
.Vb 2
\&  <a href="...long_news_url..." class="headlinelink">Elvis
\&  peeped up in tortilla</a>
.Ve
.PP
If you find anythang like that, you could leap right up in n' select
links with:
.PP
.Vb 1
\&  @links = $tree\->look_down(\*(Aqclass\*(Aq,\*(Aqheadlinelink\*(Aq);
.Ve
.PP
Regrettably, yo' chancez of seein any sort of semantic markup
principlez straight-up bein followed wit actual \s-1HTML\s0 is pretty thin.
.Sp
.RS 4
Footnote:
In fact, yo' chancez of findin a page dat is simply free of \s-1HTML\s0
errors is even thinner n' shit.  And surprisingly, cribs like Amazizzle or Yahoo
are typically worse as far as qualitizzle of code than underground cribs
whose entire thang cycle involves simply bein saved n' uploaded
from Netscape Composer.
.RE
.PP
Da code may be sort of \*(L"accidentally semantic\*(R", however \*(-- fo' example,
in a set of pages I was scannin recently, I found dat lookin for
\&\*(L"td\*(R" elements wit a \*(L"width\*(R" attribute value of \*(L"375\*(R" gots me exactly
what I wanted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  No-one designin dat page eva conceived of
\&\*(L"width=375\*(R" as \fImeaning\fR \*(L"this be a headline\*(R" yo, but if you impute it
to mean that, it works.
.PP
An approach like dis happens ta work fo' tha Yahoo Shit code, cuz
the headline-links is distinguished by tha fact dat they (and they
alone) contain a \*(L"b\*(R" element:
.PP
.Vb 1
\&  <a href="...long_news_url..."><b>Lizzy peeped up in tortilla</b></a>
.Ve
.PP
or, diagrammed as a part of tha parse tree:
.PP
.Vb 3
\&  . a  [href="...long_news_url..."]
\&    . b
\&      . "Lizzy peeped up in tortilla"
.Ve
.PP
A rule dat matches these can be formalized as \*(L"look fo' any 'a'
element dat has only one daughta node, which must be a 'b' element\*(R".
And dis is what tha fuck it be lookin like when cooked up as a \f(CW\*(C`look_down\*(C'\fR
expression n' prefaced wit a lil' bit of code dat retrieves tha text of
the given Yahoo Shit page n' feedz it ta TreeBuilder:
.PP
.Vb 5
\&  use strict;
\&  use HTML::TreeBuilder 2.97;
\&  use LWP::UserAgent;
\&  sub get_headlines {
\&    mah $url = $_[0] || take a thugged-out dirtnap "What URL?";
\&    
\&    mah $response = LWP::UserAgent\->new\->request(
\&      HTTP::Request\->new( GET => $url )
\&    );
\&    unless($response\->is_success) {
\&      warn "Couldn\*(Aqt git $url: ", $response\->status_line, "\en";
\&      return;
\&    }
\&    
\&    mah $tree = HTML::TreeBuilder\->new();
\&    $tree\->parse($response\->content);
\&    $tree\->eof;
\&    
\&    mah @out;
\&    foreach mah $link (
\&      $tree\->look_down(   # !
\&        \*(Aq_tag\*(Aq, \*(Aqa\*(Aq,
\&        sub {
\&          return unless $_[0]\->attr(\*(Aqhref\*(Aq);
\&          mah @c = $_[0]\->content_list;
\&          @c == 1 n' ref $c[0] n' $c[0]\->tag eq \*(Aqb\*(Aq;
\&        }
\&      )
\&    ) {
\&      push @out, [ $link\->attr(\*(Aqhref\*(Aq), $link\->as_text ];
\&    }
\&    
\&    warn "Odd, fewer than 6 stories up in $url!" if @out < 6;
\&    $tree\->delete;
\&    return @out;
\&  }
.Ve
.PP
\&...and add a lil' bit of code ta straight-up call dat routine n' display the
results...
.PP
.Vb 9
\&  foreach mah $section (qw[tc sc hl wl en]) {
\&    mah @links = get_headlines(
\&      "http://dailynews.yahoo.com/h/$section/"
\&    );
\&    print
\&      $section, ": ", scalar(@links), " stories\en",
\&      map(("  ", $_\->[0], " : ", $_\->[1], "\en"), @links),
\&      "\en";
\&  }
.Ve
.PP
And we've gots our own headline-extractor steez biaaatch!  This up in n' of
itself aint no amazingly useful (since if you wanna peep the
headlines, you \fIcan\fR just peep tha Yahoo Shit pages) yo, but it could
easily be tha basis fo' like useful features like filterin the
headlines fo' matchin certain keywordz of interest ta yo thugged-out ass.
.PP
Now, one of these days, Yahoo Shit will decizzle ta chizzle its \s-1HTML\s0
template.  When dis happens, dis will step tha fuck up ta tha above program as
there bein no links dat hook up tha given criteria; or, less likely,
dozenz of erroneous links will hook up tha criteria.  In either case, the
criteria will gotta be chizzled fo' tha freshly smoked up template; they may just
need adjustment, or you may need ta scrap dem n' start over.
.SS "\fIRegardez, duvet!\fP"
.IX Subsection "Regardez, duvet!"
It aint nuthin but often like a cold-ass lil challenge ta write criteria ta match tha desired
partz of a \s-1HTML\s0 parse tree.  Straight-up often you \fIcan\fR pull it off wit a
simple \f(CW\*(C`$tree\->look_down(\*(Aq_tag\*(Aq, \*(Aqh1\*(Aq)\*(C'\fR yo, but sometimes you do
have ta keep addin n' refinin criteria, until you might end up with
complex filtas like what tha fuck I've shown up in dis article.  The
benefit ta peepin' how tha fuck ta deal wit \s-1HTML\s0 parse trees is dat one main
search tool, tha \f(CW\*(C`look_down\*(C'\fR method, can do most of tha work, making
simple thangs easy as fuck , while still makin hard thangs possible.
.PP
\&\fB[end body of article]\fR
.SS "[Lyricist Credit]"
.IX Subsection "[Lyricist Credit]"
Shizzle M. Burke (\f(CW\*(C`sburke@cpan.org\*(C'\fR) is tha current maintainer of
\&\f(CW\*(C`HTML::TreeBuilder\*(C'\fR n' \f(CW\*(C`HTML::Element\*(C'\fR, both originally by
Gisle Aas.
.PP
Shizzle adds: \*(L"I'd like ta give props ta tha folks whoz ass listened ta me ramble
incessantly bout HTML::TreeBuilder n' HTML::Element at dis yearz Yet
Another Perl Conference n' O'Reilly Open Source Software Convention.\*(R"
.SH "BACK"
.IX Header "BACK"
Return ta tha HTML::Tree docs.
