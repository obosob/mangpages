.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bigint 3pm"
.TH bigint 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
bigint \- Transparent BigInteger support fo' Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use bigint;
\&
\&  $x = 2 + 4.5,"\en";                    # BigInt 6
\&  print 2 ** 512,"\en";                  # straight-up is what tha fuck you be thinkin it is
\&  print inf + 42,"\en";                  # inf
\&  print NaN * 7,"\en";                   # NaN
\&  print hex("0x1234567890123490"),"\en"; # Perl v5.10.0 or later
\&
\&  {
\&    no bigint;
\&    print 2 ** 256,"\en";                # a aiiight Perl scalar now
\&  }
\&
\&  # Import tha fuck into current package:
\&  use bigint qw/hex oct/;
\&  print hex("0x1234567890123490"),"\en";
\&  print oct("01234567890123490"),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (includin basic math operations) except tha range operator \f(CW\*(C`..\*(C'\fR
are overloaded. Y'all KNOW dat shit, muthafucka! Integer constants is pimped as proper BigInts.
.PP
Floatin point constants is truncated ta integer n' shiznit fo' realz. All parts n' thangs up in dis biatch of
expressions is also truncated.
.PP
Unlike integer, dis pragma creates integer constants dat is only
limited up in they size by tha available memory n' \s-1CPU\s0 time.
.SS "use integer vs. use bigint"
.IX Subsection "use integer vs. use bigint"
There is one lil' small-ass difference between \f(CW\*(C`use integer\*(C'\fR n' \f(CW\*(C`use bigint\*(C'\fR: the
forma aint gonna affect assignments ta variablez n' tha return value of
some functions. \f(CW\*(C`bigint\*(C'\fR truncates these thangs up in dis biatch ta integer too:
.PP
.Vb 8
\&        # perl \-Minteger \-wle \*(Aqprint 3.2\*(Aq
\&        3.2
\&        # perl \-Minteger \-wle \*(Aqprint 3.2 + 0\*(Aq
\&        3
\&        # perl \-Mbigint \-wle \*(Aqprint 3.2\*(Aq
\&        3
\&        # perl \-Mbigint \-wle \*(Aqprint 3.2 + 0\*(Aq
\&        3
\&
\&        # perl \-Mbigint \-wle \*(Aqprint exp(1) + 0\*(Aq
\&        2
\&        # perl \-Mbigint \-wle \*(Aqprint exp(1)\*(Aq
\&        2
\&        # perl \-Minteger \-wle \*(Aqprint exp(1)\*(Aq
\&        2.71828182845905
\&        # perl \-Minteger \-wle \*(Aqprint exp(1) + 0\*(Aq
\&        2
.Ve
.PP
In practice dis make seldom a gangbangin' finger-lickin' difference as \fBparts n' thangs up in dis biatch\fR of
expressions is ghon be truncated anyway yo, but dis can, fo' instance, affect the
return value of subroutines:
.PP
.Vb 2
\&    sub three_integer { use integer; return 3.2; } 
\&    sub three_bigint { use bigint; return 3.2; }
\&
\&    print three_integer(), " ", three_bigint(),"\en";    # prints "3.2 3"
.Ve
.SS "Options"
.IX Subsection "Options"
bigint recognizes some options dat can be passed while loadin it via use.
Da options can (currently) be either a single letta form, or tha long form.
Da followin options exist:
.IP "a or accuracy" 2
.IX Item "a or accuracy"
This sets tha accuracy fo' all math operations. Da argument must be pimped outer
than or equal ta zero. Right back up in yo muthafuckin ass. See Math::BigIntz \fIbround()\fR function fo' details.
.Sp
.Vb 1
\&        perl \-Mbigint=a,2 \-le \*(Aqprint 12345+1\*(Aq
.Ve
.Sp
Note dat settin precision n' accuracy all up in tha same time aint possible.
.IP "p or precision" 2
.IX Item "p or precision"
This sets tha precision fo' all math operations. Da argument can be any
integer n' shit. Negatizzle joints mean a gangbangin' fixed number of digits afta tha dot, and
are <B>ignored</B> since all operations happen up in integer space.
A positizzle value roundz ta dis digit left from tha dot. 0 or 1 mean round to
integer n' is ignore like wack joints.
.Sp
See Math::BigIntz \fIbfround()\fR function fo' details.
.Sp
.Vb 1
\&        perl \-Mbignum=p,5 \-le \*(Aqprint 123456789+123\*(Aq
.Ve
.Sp
Note dat settin precision n' accuracy all up in tha same time aint possible.
.IP "t or trace" 2
.IX Item "t or trace"
This enablez a trace mode n' is primarily fo' debuggin bigint or
Math::BigInt.
.IP "hex" 2
.IX Item "hex"
Override tha built-in \fIhex()\fR method wit a version dat can handle big
integers. This overrides it by exportin it ta tha current package. Under
Perl v5.10.0 n' higher, dis aint so necessary, as \fIhex()\fR is lexically
overridden up in tha current scope whenever tha bigint pragma be active.
.IP "oct" 2
.IX Item "oct"
Override tha built-in \fIoct()\fR method wit a version dat can handle big
integers. This overrides it by exportin it ta tha current package. Under
Perl v5.10.0 n' higher, dis aint so necessary, as \fIoct()\fR is lexically
overridden up in tha current scope whenever tha bigint pragma be active.
.IP "l, lib, try or only" 2
.IX Item "l, lib, try or only"
Load a gangbangin' finger-lickin' different math lib, peep \*(L"Math Library\*(R".
.Sp
.Vb 3
\&        perl \-Mbigint=lib,GMP \-e \*(Aqprint 2 ** 512\*(Aq
\&        perl \-Mbigint=try,GMP \-e \*(Aqprint 2 ** 512\*(Aq
\&        perl \-Mbigint=only,GMP \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
Currently there is no way ta specify mo' than one library on tha command
line. This means tha followin do not work:
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP,Pari \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
This is ghon be hopefully fixed soon ;)
.IP "v or version" 2
.IX Item "v or version"
This prints up tha name n' version of all modulez used n' then exits.
.Sp
.Vb 1
\&        perl \-Mbigint=v
.Ve
.SS "Math Library"
.IX Subsection "Math Library"
Math wit tha numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent ta saying:
.PP
.Vb 1
\&        use bigint lib => \*(AqCalc\*(Aq;
.Ve
.PP
Yo ass can chizzle dis by using:
.PP
.Vb 1
\&        use bignum lib => \*(AqGMP\*(Aq;
.Ve
.PP
Da followin would first try ta find Math::BigInt::Foo, then
Math::BigInt::Bar, n' when dis also fails, revert ta Math::BigInt::Calc:
.PP
.Vb 1
\&        use bigint lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
Usin \f(CW\*(C`lib\*(C'\fR warns if none of tha specified libraries can be found and
Math::BigInt did fall back ta one of tha default libraries.
To suppress dis warning, use \f(CW\*(C`try\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum try => \*(AqGMP\*(Aq;
.Ve
.PP
If you want tha code ta take a thugged-out dirtnap instead of fallin back, use \f(CW\*(C`only\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum only => \*(AqGMP\*(Aq;
.Ve
.PP
Please peep respectizzle module documentation fo' further details.
.SS "Internal Format"
.IX Subsection "Internal Format"
Da numbers is stored as objects, n' they internals might chizzle at anytime,
especially between math operations. Da objects also might belong ta different
classes, like Math::BigInt, or Math::BigInt::Lite. Mixin dem together, even
with aiiight scalars aint extraordinary yo, but aiiight n' expected.
.PP
Yo ass should not depend on tha internal format, all accesses must go through
accessor methods. E.g. lookin at \f(CW$x\fR\->{sign} aint a phat scam since there
is no guaranty dat tha object up in question has such a hash key, nor be a hash
underneath at all.
.SS "Sign"
.IX Subsection "Sign"
Da sign is either '+', '\-', 'NaN', '+inf' or '\-inf'.
Yo ass can access it wit tha \fIsign()\fR method.
.PP
A sign of 'NaN' is used ta represent tha result when input arguments is not
numbers or as a result of 0/0. '+inf' n' '\-inf' represent plus respectively
minus infinity. Yo ass will git '+inf' when dividin a positizzle number by 0, and
\&'\-inf' when dividin any wack number by 0.
.SS "Method calls"
.IX Subsection "Method calls"
Since all numbers is now objects, you can use all functions dat is part of
the BigInt \s-1API.\s0 Yo ass can only use tha \fIbxxx()\fR notation, n' not tha \fIfxxx()\fR
notation, though.
.PP
But a warnin is up in order n' shit. When rockin tha followin ta cook up a cold-ass lil copy of a number,
only a gangbangin' finger-lickin' dirty-ass shallow copy is ghon be made.
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $x = $y = 7;
.Ve
.PP
Usin tha copy or tha original gangsta wit overloaded math be all gravy, e.g. the
followin work:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x + 1, " ", $y,"\en";     # prints 10 9
.Ve
.PP
but callin any method dat modifies tha number directly will result in
\&\fBboth\fR tha original gangsta n' tha copy bein destroyed:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x\->badd(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->binc(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->bmul(2), " ", $y,"\en";        # prints 18 18
.Ve
.PP
Usin methodz dat do not modify yo, but testthe contents works:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $z = 9 if $x\->is_zero();                # works fine
.Ve
.PP
See tha documentation bout tha copy constructor n' \f(CW\*(C`=\*(C'\fR up in overload, as
well as tha documentation up in BigInt fo' further details.
.SS "Methods"
.IX Subsection "Methods"
.IP "\fIinf()\fR" 2
.IX Item "inf()"
A shortcut ta return Math::BigInt\->\fIbinf()\fR. Useful cuz Perl do not always
handle bareword \f(CW\*(C`inf\*(C'\fR properly.
.IP "\fINaN()\fR" 2
.IX Item "NaN()"
A shortcut ta return Math::BigInt\->\fIbnan()\fR. Useful cuz Perl do not always
handle bareword \f(CW\*(C`NaN\*(C'\fR properly.
.IP "e" 2
.IX Item "e"
.Vb 1
\&        # perl \-Mbigint=e \-wle \*(Aqprint e\*(Aq
.Ve
.Sp
Returns Eulerz number \f(CW\*(C`e\*(C'\fR, aka \fIexp\fR\|(1). Note dat under bigint, dis is
truncated ta a integer, n' hence simple '2'.
.IP "\s-1PI\s0" 2
.IX Item "PI"
.Vb 1
\&        # perl \-Mbigint=PI \-wle \*(Aqprint PI\*(Aq
.Ve
.Sp
Returns \s-1PI.\s0 Note dat under bigint, dis is truncated ta a integer, n' hence
simple '3'.
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.Vb 1
\&        bexp($power,$accuracy);
.Ve
.Sp
Returns Eulerz number \f(CW\*(C`e\*(C'\fR raised ta tha appropriate power, to
the wanted accuracy.
.Sp
Note dat under bigint, tha result is truncated ta a integer.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigint=bexp \-wle \*(Aqprint bexp(1,80)\*(Aq
.Ve
.IP "\fIbpi()\fR" 2
.IX Item "bpi()"
.Vb 1
\&        bpi($accuracy);
.Ve
.Sp
Returns \s-1PI\s0 ta tha wanted accuracy. Note dat under bigint, dis is truncated
to a integer, n' hence simple '3'.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigint=bpi \-wle \*(Aqprint bpi(80)\*(Aq
.Ve
.IP "\fIupgrade()\fR" 2
.IX Item "upgrade()"
Return tha class dat numbers is upgraded to, is up in fact returning
\&\f(CW$Math::BigInt::upgrade\fR.
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
.Vb 1
\&        use bigint;
\&
\&        print "in effect\en" if bigint::in_effect;       # true
\&        {
\&          no bigint;
\&          print "in effect\en" if bigint::in_effect;     # false
\&        }
.Ve
.Sp
Returns legit or false if \f(CW\*(C`bigint\*(C'\fR is up in effect up in tha current scope.
.Sp
This method only works on Perl v5.9.4 or later.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "ranges" 2
.IX Item "ranges"
Perl do not allow overloadin of ranges, so you can neither safely use
ranges wit bigint endpoints, nor is tha iterator variable a funky-ass bigint.
.Sp
.Vb 7
\&        use 5.010;
\&        fo' mah $i (12..13) {
\&          fo' mah $j (20..21) {
\&            say $i ** $j;  # produces a gangbangin' floating\-point number,
\&                           # not a funky-ass big-ass integer
\&          }
\&        }
.Ve
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
This method only works on Perl v5.9.4 or later.
.IP "\fIhex()\fR/\fIoct()\fR" 2
.IX Item "hex()/oct()"
\&\f(CW\*(C`bigint\*(C'\fR overrides these routines wit versions dat can also handle
bangin' integer joints, n' you can put dat on yo' toast. Under Perl prior ta version v5.9.4, however, this
will not happen unless you specifically ask fo' it wit tha two
import tags \*(L"hex\*(R" n' \*(L"oct\*(R" \- n' then it is ghon be global n' cannot be
disabled inside a scope wit \*(L"no bigint\*(R":
.Sp
.Vb 1
\&        use bigint qw/hex oct/;
\&
\&        print hex("0x1234567890123456");
\&        {
\&                no bigint;
\&                print hex("0x1234567890123456");
\&        }
.Ve
.Sp
Da second call ta \fIhex()\fR will warn on some non-portable constant.
.Sp
Compare dis to:
.Sp
.Vb 1
\&        use bigint;
\&
\&        # will warn only under Perl olda than v5.9.4
\&        print hex("0x1234567890123456");
.Ve
.SH "MODULES USED"
.IX Header "MODULES USED"
\&\f(CW\*(C`bigint\*(C'\fR is just a thin wrapper round various modulez of tha Math::BigInt
family. Think of it as tha head of tha crew, whoz ass runs tha shop, n' orders
the others ta do tha work.
.PP
Da followin modulez is currently used by bigint:
.PP
.Vb 2
\&        Math::BigInt::Lite      (for speed, n' only if it is loadable)
\&        Math::BigInt
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Some def command line examplez ta impress tha Python crowd ;) Yo ass might want
to compare dem ta tha thangs up in dis biatch under \-Mbignum or \-Mbigrat:
.PP
.Vb 9
\&        perl \-Mbigint \-le \*(Aqprint sqrt(33)\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 2*255\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 4.5+2*255\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 3/7 + 5/7 + 8/3\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 123\->is_odd()\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint log(2)\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 2 ** 0.5\*(Aq
\&        perl \-Mbigint=a,65 \-le \*(Aqprint 2 ** 0.2\*(Aq
\&        perl \-Mbignum=a,65,l,GMP \-le \*(Aqprint 7 ** 7777\*(Aq
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Especially bigrat as up in \f(CW\*(C`perl \-Mbigrat \-le \*(Aqprint 1/3+1/4\*(Aq\*(C'\fR and
bignum as up in \f(CW\*(C`perl \-Mbignum \-le \*(Aqprint sqrt(2)\*(Aq\*(C'\fR.
.PP
Math::BigInt, Math::BigRat n' Math::Big as well
as Math::BigInt::Pari n'  Math::BigInt::GMP.
.SH "AUTHORS"
.IX Header "AUTHORS"
(C) by Tels <http://bloodgate.com/> up in early 2002 \- 2007.
