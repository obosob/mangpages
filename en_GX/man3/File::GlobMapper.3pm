.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::GlobMapper 3"
.TH File::GlobMapper 3 "2011-01-07" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::GlobMapper \- Extend File Glob ta Allow Input n' Output Files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use File::GlobMapper qw( globmap );
\&
\&    mah $aref = globmap $input => $output
\&        or take a thugged-out dirtnap $File::GlobMapper::Error ;
\&
\&    mah $gm = freshly smoked up File::GlobMapper $input => $output
\&        or take a thugged-out dirtnap $File::GlobMapper::Error ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module needz Perl5.005 or better.
.PP
This module takes tha existin \f(CW\*(C`File::Glob\*(C'\fR module as a startin point and
extendz it ta allow freshly smoked up filenames ta be derived from tha filez matched by
\&\f(CW\*(C`File::Glob\*(C'\fR.
.PP
This can be useful when carryin up batch operations on multiple filez that
have both a input filename n' output filename n' tha output file can be
derived from tha input filename. Examplez of operations where dis can be
useful include, file renaming, file copyin n' file compression.
.SS "Behind Da Scenes"
.IX Subsection "Behind Da Scenes"
To help explain what tha fuck \f(CW\*(C`File::GlobMapper\*(C'\fR do, consider what tha fuck code you
would write if you wanted ta rename all filez up in tha current directory
that ended up in \f(CW\*(C`.tar.gz\*(C'\fR ta \f(CW\*(C`.tgz\*(C'\fR. Right back up in yo muthafuckin ass. So say these filez is up in the
current directory
.PP
.Vb 3
\&    alpha.tar.gz
\&    beta.tar.gz
\&    gamma.tar.gz
.Ve
.PP
and they need renamed ta this
.PP
.Vb 3
\&    alpha.tgz
\&    beta.tgz
\&    gamma.tgz
.Ve
.PP
Below be a possible implementation of a script ta carry up tha rename
(error cases done been omitted)
.PP
.Vb 4
\&    foreach mah $old ( glob "*.tar.gz" )
\&    {
\&        mah $new = $old;
\&        $new =~ s#(.*)\e.tar\e.gz$#$1.tgz# ;
\&
\&        rename $old => $new 
\&            or take a thugged-out dirtnap "Cannot rename \*(Aq$old\*(Aq ta \*(Aq$new\*(Aq: $!\en;
\&    }
.Ve
.PP
Notice dat a gangbangin' file glob pattern \f(CW\*(C`*.tar.gz\*(C'\fR was used ta match the
\&\f(CW\*(C`.tar.gz\*(C'\fR files, then a gangbangin' fairly similar regular expression was used in
the substitute ta allow tha freshly smoked up filename ta be pimped.
.PP
Given dat tha file glob is just a cold-ass lil cut-down regular expression n' dat it
has already done a shitload of tha mad bullshit up in pattern matchin tha filenames,
wouldn't it be handy ta be able ta use tha patterns up in tha fileglob to
drive tha freshly smoked up filename?
.PP
Well, thatz \fIexactly\fR what tha fuck \f(CW\*(C`File::GlobMapper\*(C'\fR do.
.PP
Here is same snippet of code rewritten rockin \f(CW\*(C`globmap\*(C'\fR
.PP
.Vb 6
\&    fo' mah $pair (globmap \*(Aq<*.tar.gz>\*(Aq => \*(Aq<#1.tgz>\*(Aq )
\&    {
\&        mah ($from, $to) = @$pair;
\&        rename $from => $to 
\&            or take a thugged-out dirtnap "Cannot rename \*(Aq$old\*(Aq ta \*(Aq$new\*(Aq: $!\en;
\&    }
.Ve
.PP
So how tha fuck do it work?
.PP
Behind tha scenes tha \f(CW\*(C`globmap\*(C'\fR function do a cold-ass lil combination of a
file glob ta match existin filenames followed by a substitute
to create tha freshly smoked up filenames.
.PP
Notice how tha fuck both parametas ta \f(CW\*(C`globmap\*(C'\fR is strings dat is delimited by <>.
This is done ta make dem look mo' like file globs \- it is just syntactic
sugar yo, but it can be handy when you want tha strings ta be visually
distinctive. Da enclosin <> is optional, so you don't gotta use dem \- in
fact tha straight-up original gangsta thang globmap will do is remove these delimitas if they are
present.
.PP
Da first parameta ta \f(CW\*(C`globmap\*(C'\fR, \f(CW\*(C`*.tar.gz\*(C'\fR, be a \fIInput File Glob\fR. 
Once tha enclosin \*(L"< ... >\*(R" is removed, dis is passed (more or
less) unchanged ta \f(CW\*(C`File::Glob\*(C'\fR ta carry up a gangbangin' file match.
.PP
Next tha fileglob \f(CW\*(C`*.tar.gz\*(C'\fR is transformed behind tha scenes tha fuck into a
full Perl regular expression, wit tha additionizzle step of wrappin each
transformed wildcard metacharacta sequence up in parenthesis.
.PP
In dis case tha input fileglob \f(CW\*(C`*.tar.gz\*(C'\fR is ghon be transformed into
this Perl regular expression
.PP
.Vb 1
\&    ([^/]*)\e.tar\e.gz
.Ve
.PP
Rappin bout wit parenthesis allows tha wildcard partz of tha Input File
Glob ta be referenced by tha second parameta ta \f(CW\*(C`globmap\*(C'\fR, \f(CW\*(C`#1.tgz\*(C'\fR,
the \fIOutput File Glob\fR. This parameta operates just like tha replacement
part of a substitute command. Y'all KNOW dat shit, muthafucka! Da difference is dat tha \f(CW\*(C`#1\*(C'\fR syntax
is used ta reference sub-patterns matched up in tha input fileglob, rather
than tha \f(CW$1\fR syntax dat is used wit perl regular expressions. In
this case \f(CW\*(C`#1\*(C'\fR is used ta refer ta tha text matched by tha \f(CW\*(C`*\*(C'\fR up in the
Input File Glob. This make it easier ta use dis module where the
parametas ta \f(CW\*(C`globmap\*(C'\fR is typed all up in tha command line.
.PP
Da final step involves passin each filename matched by tha \f(CW\*(C`*.tar.gz\*(C'\fR
file glob all up in tha derived Perl regular expression up in turn and
expandin tha output fileglob rockin dat shit.
.PP
Da end result of all dis be a list of pairz of filenames. By default
that is what tha fuck is returned by \f(CW\*(C`globmap\*(C'\fR. In dis example tha data structure
returned is ghon be lookin like this
.PP
.Vb 4
\&     ( [\*(Aqalpha.tar.gz\*(Aq => \*(Aqalpha.tgz\*(Aq],
\&       [\*(Aqbeta.tar.gz\*(Aq  => \*(Aqbeta.tgz\*(Aq ],
\&       [\*(Aqgamma.tar.gz\*(Aq => \*(Aqgamma.tgz\*(Aq]
\&     )
.Ve
.PP
Each pair be a array reference wit two elements \- namely tha \fIfrom\fR
filename, dat \f(CW\*(C`File::Glob\*(C'\fR has matched, n' a \fIto\fR filename dat is
derived from tha \fIfrom\fR filename.
.SS "Limitations"
.IX Subsection "Limitations"
\&\f(CW\*(C`File::GlobMapper\*(C'\fR has been kept simple deliberately, so it aint intended to
solve all filename mappin operations. Under tha hood \f(CW\*(C`File::Glob\*(C'\fR (or for
olda versionz of Perl, \f(CW\*(C`File::BSDGlob\*(C'\fR) is used ta match tha files, so you
will never have tha flexibilitizzle of full Perl regular expression.
.SS "Input File Glob"
.IX Subsection "Input File Glob"
Da syntax fo' a Input FileGlob is identical ta \f(CW\*(C`File::Glob\*(C'\fR, except
for tha following
.IP "1." 5
No nested {}
.IP "2." 5
Whitespace do not delimit fileglobs.
.IP "3." 5
Da use of parenthesis can be used ta capture partz of tha input filename.
.IP "4." 5
If a Input glob matches tha same ol' dirty file mo' than once, only tha first
will be used.
.PP
Da syntax
.IP "\fB~\fR" 5
.IX Item "~"
.PD 0
.IP "\fB~user\fR" 5
.IX Item "~user"
.IP "\fB.\fR" 5
.IX Item "."
.PD
Matches a literal '.'.
Equivalent ta tha Perl regular expression
.Sp
.Vb 1
\&    \e.
.Ve
.IP "\fB*\fR" 5
.IX Item "*"
Matches zero or mo' characters, except '/'. Equivalent ta tha Perl
regular expression
.Sp
.Vb 1
\&    [^/]*
.Ve
.IP "\fB?\fR" 5
.IX Item "?"
Matches zero or one character, except '/'. Equivalent ta tha Perl
regular expression
.Sp
.Vb 1
\&    [^/]?
.Ve
.IP "\fB\e\fR" 5
.IX Item ""
Backslash is used, as usual, ta escape tha next character.
.IP "\fB[]\fR" 5
.IX Item "[]"
Characta class.
.IP "\fB{,}\fR" 5
.IX Item "{,}"
Alternation
.IP "\fB()\fR" 5
.IX Item "()"
Capturin parenthesis dat work just like perl
.PP
Any other characta it taken literally.
.SS "Output File Glob"
.IX Subsection "Output File Glob"
Da Output File Glob be a aiiight string, wit 2 glob-like features.
.PP
Da first is tha '*' metacharacter n' shit. This is ghon be replaced by tha complete
filename matched by tha input file glob. Right back up in yo muthafuckin ass. So
.PP
.Vb 1
\&    *.c *.Z
.Ve
.PP
Da second is
.PP
Output FileGlobs take the
.ie n .IP """*""" 5
.el .IP "``*''" 5
.IX Item "*"
Da \*(L"*\*(R" characta is ghon be replaced wit tha complete input filename.
.IP "#1" 5
.IX Item "#1"
Patternz of tha form /#\ed/ is ghon be replaced wit the
.SS "Returned Data"
.IX Subsection "Returned Data"
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "A Rename script"
.IX Subsection "A Rename script"
Below be a simple \*(L"rename\*(R" script dat uses \f(CW\*(C`globmap\*(C'\fR ta determine the
source n' destination filenames.
.PP
.Vb 2
\&    use File::GlobMapper qw(globmap) ;
\&    use File::Copy;
\&
\&    take a thugged-out dirtnap "rename: Usage rename \*(Aqfrom\*(Aq \*(Aqto\*(Aq\en"
\&        unless @ARGV == 2 ;
\&
\&    mah $fromGlob = shift @ARGV;
\&    mah $toGlob   = shift @ARGV;
\&
\&    mah $pairs = globmap($fromGlob, $toGlob)
\&        or take a thugged-out dirtnap $File::GlobMapper::Error;
\&
\&    fo' mah $pair (@$pairs)
\&    {
\&        mah ($from, $to) = @$pair;
\&        move $from => $to ;
\&    }
.Ve
.PP
Here be a example dat renames all c filez ta cpp.
.PP
.Vb 1
\&    $ rename \*(Aq*.c\*(Aq \*(Aq#1.cpp\*(Aq
.Ve
.SS "A few example globmaps"
.IX Subsection "A few example globmaps"
Below is all dem examplez of globmaps
.PP
To copy all yo' .c file ta a funky-ass backup directory
.PP
.Vb 1
\&    \*(Aq</my/home/*.c>\*(Aq    \*(Aq</my/backup/#1.c>\*(Aq
.Ve
.PP
If you wanna compress all
.PP
.Vb 1
\&    \*(Aq</my/home/*.[ch]>\*(Aq    \*(Aq<*.gz>\*(Aq
.Ve
.PP
To uncompress
.PP
.Vb 1
\&    \*(Aq</my/home/*.[ch].gz>\*(Aq    \*(Aq</my/home/#1.#2>\*(Aq
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::Glob
.SH "AUTHOR"
.IX Header "AUTHOR"
Da \fIFile::GlobMapper\fR module was freestyled by Pizzle Marquess, \fIpmqs@cpan.org\fR.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2005 Pizzle Marquess fo' realz. All muthafuckin rights reserved.
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
