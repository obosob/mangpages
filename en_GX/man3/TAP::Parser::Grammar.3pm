.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Grammar 3"
.TH TAP::Parser::Grammar 3 "2013-05-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Grammar \- A grammar fo' tha Test Anythang Protocol.
.SH "VERSION"
.IX Header "VERSION"
Version 3.28
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  use TAP::Parser::Grammar;
\&  mah $grammar = $self\->make_grammar({
\&    iterator => $tap_parser_iterator,
\&    parser   => $tap_parser,
\&    version  => 12,
\&  });
\&
\&  mah $result = $grammar\->tokenize;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser::Grammar\*(C'\fR tokenizes lines from a TAP::Parser::Iterator and
constructs TAP::Parser::Result subclasses ta represent tha tokens.
.PP
Do not attempt ta use dis class directly.  It won't make sense.  It aint nuthin but mainly
here ta ensure dat we is ghon be able ta have pluggable grammars when \s-1TAP\s0 is
expanded at some future date (plus, dis shiznit was straight-up clutterin the
parser).
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 5
\&  mah $grammar = TAP::Parser::Grammar\->new({
\&      iterator => $iterator,
\&      parser   => $parser,
\&      version  => $version,
\&  });
.Ve
.PP
Returns TAP::Parser grammar object dat will parse tha \s-1TAP\s0 stream from the
specified iterator. Shiiit, dis aint no joke.  Both \f(CW\*(C`iterator\*(C'\fR n' \f(CW\*(C`parser\*(C'\fR is required arguments.
If \f(CW\*(C`version\*(C'\fR aint set it defaults ta \f(CW12\fR (see \*(L"set_version\*(R" fo' more
details).
.SS "Instizzle Methods"
.IX Subsection "Instizzle Methods"
\fI\f(CI\*(C`set_version\*(C'\fI\fR
.IX Subsection "set_version"
.PP
.Vb 1
\&  $grammar\->set_version(13);
.Ve
.PP
Tell tha grammar which \s-1TAP\s0 syntax version ta support. Da lowest
supported version is 12 fo' realz. Although '\s-1TAP\s0 version' aint valid version 12
syntax it be accepted so dat higher version numbers may be parsed.
.PP
\fI\f(CI\*(C`tokenize\*(C'\fI\fR
.IX Subsection "tokenize"
.PP
.Vb 1
\&  mah $token = $grammar\->tokenize;
.Ve
.PP
This method will return a TAP::Parser::Result object representin the
current line of \s-1TAP.\s0
.PP
\fI\f(CI\*(C`token_types\*(C'\fI\fR
.IX Subsection "token_types"
.PP
.Vb 1
\&  mah @types = $grammar\->token_types;
.Ve
.PP
Returns tha different typez of tokens which dis grammar can parse.
.PP
\fI\f(CI\*(C`syntax_for\*(C'\fI\fR
.IX Subsection "syntax_for"
.PP
.Vb 1
\&  mah $syntax = $grammar\->syntax_for($token_type);
.Ve
.PP
Returns a pre-compiled regular expression which will match a cold-ass lil chunk of \s-1TAP\s0
correspondin ta tha token type.  For example (not dat you should straight-up pay
attention ta this, \f(CW\*(C`$grammar\->syntax_for(\*(Aqcomment\*(Aq)\*(C'\fR will return
\&\f(CW\*(C`qr/^#(.*)/\*(C'\fR.
.PP
\fI\f(CI\*(C`handlez_for\*(C'\fI\fR
.IX Subsection "handlez_for"
.PP
.Vb 1
\&  mah $handlez = $grammar\->handlez_for($token_type);
.Ve
.PP
Returns a cold-ass lil code reference which, when passed a appropriate line of \s-1TAP,\s0
returns tha lexed token correspondin ta dat line.  As a result, tha basic
\&\s-1TAP\s0 parsin loop looks similar ta tha following:
.PP
.Vb 10
\& mah @tokens;
\& mah $grammar = TAP::Grammar\->new;
\& LINE: while ( defined( mah $line = $parser\->_next_chunk_of_tap ) ) {
\&     fo' mah $type ( $grammar\->token_types ) {
\&         mah $syntax  = $grammar\->syntax_for($type);
\&         if ( $line =~ $syntax ) {
\&             mah $handlez = $grammar\->handlez_for($type);
\&             push @tokens => $grammar\->$handlez($line);
\&             next LINE;
\&         }
\&     }
\&     push @tokens => $grammar\->_make_unknown_token($line);
\& }
.Ve
.SH "TAP GRAMMAR"
.IX Header "TAP GRAMMAR"
\&\fB\s-1NOTE:\s0\fR  This grammar is slightly outta date.  Therez still some rap
about it n' a freshly smoked up one is ghon be provided when our crazy asses have thangs betta defined.
.PP
Da TAP::Parser do not bust a gangbangin' formal grammar cuz \s-1TAP\s0 is essentially a
stream-based protocol.  In fact, itz like legal ta have a infinite stream.
For tha same reason dat our phat asses don't apply regexes ta streams, our asses aint rockin a
formal grammar here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Instead, we parse tha \s-1TAP\s0 up in lines.
.PP
For purposes fo' forward compatibility, any result which do not match the
followin grammar is currently referred ta as
TAP::Parser::Result::Unknown. I aint talkin' bout chicken n' gravy biatch.  It be \fInot\fR a parse error.
.PP
A formal grammar would look similar ta tha following:
.PP
.Vb 4
\& (*
\&     For tha time being, I\*(Aqm ridin' dirty on tha EBNF by allowing
\&     certain terms ta be defined by POSIX characta classes by
\&     rockin tha followin syntax:
\&
\&       digit ::= [:digit:]
\&
\&     As far as I be aware, that\*(Aqs not valid EBNF.  Sue mah dirty ass.  I
\&     didn\*(Aqt know how tha fuck ta write "char" otherwise (Unicode issues).
\&     Suggestions welcome.
\& *)
\&
\& tap            ::= version? { comment | unknown } leading_plan lines
\&                    |
\&                    lines trailing_plan {comment}
\&
\& version        ::= \*(AqTAP version \*(Aq positiveInteger {positiveInteger} "\en"
\&
\& leading_plan   ::= plan skip_directive? "\en"
\&
\& trailing_plan  ::= plan "\en"
\&
\& plan           ::= \*(Aq1..\*(Aq nonNegativeInteger
\&
\& lines          ::= line {line}
\&
\& line           ::= (comment | test | unknown | bailout ) "\en"
\&
\& test           ::= status positiveInteger? description? directive?
\&
\& status         ::= \*(Aqnot \*(Aq? \*(Aqok \*(Aq
\&
\& description    ::= (characta \- (digit | \*(Aq#\*(Aq)) {characta \- \*(Aq#\*(Aq}
\&
\& directizzle      ::= todo_directizzle | skip_directive
\&
\& todo_directizzle ::= hash_mark \*(AqTODO\*(Aq \*(Aq \*(Aq {character}
\&
\& skip_directizzle ::= hash_mark \*(AqSKIP\*(Aq \*(Aq \*(Aq {character}
\&
\& comment        ::= hash_mark {character}
\&
\& hash_mark      ::= \*(Aq#\*(Aq {\*(Aq \*(Aq}
\&
\& bailout        ::= \*(AqBail out!\*(Aq {character}
\&
\& unknown        ::= { (characta \- "\en") }
\&
\& (* POSIX characta classes n' other terminals *)
\&
\& digit              ::= [:digit:]
\& characta          ::= ([:print:] \- "\en")
\& positiveInteger    ::= ( digit \- \*(Aq0\*(Aq ) {digit}
\& nonNegativeInteger ::= digit {digit}
.Ve
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please peep \*(L"\s-1SUBCLASSING\*(R"\s0 up in TAP::Parser fo' a subclassin overview.
.PP
If you \fIreally\fR wanna subclass TAP::Parserz grammar tha dopest thang to
do is read all up in tha code.  Therez no easy as fuck  way of summarizin it here.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Iterator,
TAP::Parser::Result,
