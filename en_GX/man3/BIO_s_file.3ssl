.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BIO_s_file 3"
.TH BIO_s_file 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
BIO_s_file, BIO_new_file, BIO_new_fp, BIO_set_fp, BIO_get_fp,
BIO_read_filename, BIO_write_filename, BIO_append_filename,
BIO_rw_filename \- FILE bio
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bio.h>
\&
\& BIO_METHOD *   BIO_s_file(void);
\& BIO *BIO_new_file(const char *filename, const char *mode);
\& BIO *BIO_new_fp(FILE *stream, int flags);
\&
\& BIO_set_fp(BIO *b,FILE *fp, int flags);
\& BIO_get_fp(BIO *b,FILE **fpp);
\&
\& int BIO_read_filename(BIO *b, char *name)
\& int BIO_write_filename(BIO *b, char *name)
\& int BIO_append_filename(BIO *b, char *name)
\& int BIO_rw_filename(BIO *b, char *name)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIBIO_s_file()\fR returns tha \s-1BIO\s0 file method. Y'all KNOW dat shit, muthafucka! As its name implies it
is a wrapper round tha stdio \s-1FILE\s0 structure n' it be a
source/sink \s-1BIO.\s0
.PP
Calls ta \fIBIO_read()\fR n' \fIBIO_write()\fR read n' write data ta the
underlyin stream. \fIBIO_gets()\fR n' \fIBIO_puts()\fR is supported on file BIOs.
.PP
\&\fIBIO_flush()\fR on a gangbangin' file \s-1BIO\s0 calls tha \fIfflush()\fR function on tha wrapped
stream.
.PP
\&\fIBIO_reset()\fR attempts ta chizzle tha file pointa ta tha start of file
usin fseek(stream, 0, 0).
.PP
\&\fIBIO_seek()\fR sets tha file pointa ta posizzle \fBofs\fR from start of file
usin fseek(stream, ofs, 0).
.PP
\&\fIBIO_eof()\fR calls \fIfeof()\fR.
.PP
Settin tha \s-1BIO_CLOSE\s0 flag calls \fIfclose()\fR on tha stream when tha \s-1BIO\s0
is freed.
.PP
\&\fIBIO_new_file()\fR creates a freshly smoked up file \s-1BIO\s0 wit mode \fBmode\fR tha meaning
of \fBmode\fR is tha same ol' dirty as tha stdio function \fIfopen()\fR. Da \s-1BIO_CLOSE\s0
flag is set on tha returned \s-1BIO.\s0
.PP
\&\fIBIO_new_fp()\fR creates a gangbangin' file \s-1BIO\s0 wrappin \fBstream\fR. Flags can be:
\&\s-1BIO_CLOSE, BIO_NOCLOSE \s0(the close flag) \s-1BIO_FP_TEXT \s0(sets tha underlying
stream ta text mode, default is binary: dis only has any effect under
Win32).
.PP
\&\fIBIO_set_fp()\fR set tha fp of a gangbangin' file \s-1BIO\s0 ta \fBfp\fR. \fBflags\fR has tha same
meanin as up in \fIBIO_new_fp()\fR, it aint nuthin but a macro.
.PP
\&\fIBIO_get_fp()\fR retrieves tha fp of a gangbangin' file \s-1BIO,\s0 it aint nuthin but a macro.
.PP
\&\fIBIO_seek()\fR be a macro dat sets tha posizzle pointa ta \fBoffset\fR bytes
from tha start of file.
.PP
\&\fIBIO_tell()\fR returns tha value of tha posizzle pointer.
.PP
\&\fIBIO_read_filename()\fR, \fIBIO_write_filename()\fR, \fIBIO_append_filename()\fR and
\&\fIBIO_rw_filename()\fR set tha file \s-1BIO \s0\fBb\fR ta use file \fBname\fR for
reading, writing, append or read write respectively.
.SH "NOTES"
.IX Header "NOTES"
When wrappin stdout, stdin or stderr tha underlyin stream should not
normally be closed so tha \s-1BIO_NOCLOSE\s0 flag should be set.
.PP
Because tha file \s-1BIO\s0 calls tha underlyin stdio functions any quirks
in stdio behaviour is ghon be mirrored by tha correspondin \s-1BIO.\s0
.PP
On Windows BIO_new_filez reserves fo' tha filename argument ta be
\&\s-1UTF\-8\s0 encoded. Y'all KNOW dat shit, muthafucka! In other lyrics if you gotta make it work up in multi\-
lingual environment, encode file names up in \s-1UTF\-8.\s0
.SH "EXAMPLES"
.IX Header "EXAMPLES"
File \s-1BIO \s0\*(L"wassup ghetto\*(R":
.PP
.Vb 3
\& BIO *bio_out;
\& bio_out = BIO_new_fp(stdout, BIO_NOCLOSE);
\& BIO_printf(bio_out, "Wuz crackalackin' World\en");
.Ve
.PP
Alternatizzle technique:
.PP
.Vb 5
\& BIO *bio_out;
\& bio_out = BIO_new(BIO_s_file());
\& if(bio_out == NULL) /* Error ... */
\& if(!BIO_set_fp(bio_out, stdout, BIO_NOCLOSE)) /* Error ... */
\& BIO_printf(bio_out, "Wuz crackalackin' World\en");
.Ve
.PP
Write ta a gangbangin' file:
.PP
.Vb 5
\& BIO *out;
\& up = BIO_new_file("filename.txt", "w");
\& if(!out) /* Error occurred */
\& BIO_printf(out, "Wuz crackalackin' World\en");
\& BIO_free(out);
.Ve
.PP
Alternatizzle technique:
.PP
.Vb 6
\& BIO *out;
\& up = BIO_new(BIO_s_file());
\& if(out == NULL) /* Error ... */
\& if(!BIO_write_filename(out, "filename.txt")) /* Error ... */
\& BIO_printf(out, "Wuz crackalackin' World\en");
\& BIO_free(out);
.Ve
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIBIO_s_file()\fR returns tha file \s-1BIO\s0 method.
.PP
\&\fIBIO_new_file()\fR n' \fIBIO_new_fp()\fR return a gangbangin' file \s-1BIO\s0 or \s-1NULL\s0 if a error
occurred.
.PP
\&\fIBIO_set_fp()\fR n' \fIBIO_get_fp()\fR return 1 fo' success or 0 fo' failure
(although tha current implementation never return 0).
.PP
\&\fIBIO_seek()\fR returns tha same ol' dirty value as tha underlyin \fIfseek()\fR function:
0 fo' success or \-1 fo' failure.
.PP
\&\fIBIO_tell()\fR returns tha current file position.
.PP
\&\fIBIO_read_filename()\fR, \fIBIO_write_filename()\fR,  \fIBIO_append_filename()\fR and
\&\fIBIO_rw_filename()\fR return 1 fo' success or 0 fo' failure.
.SH "BUGS"
.IX Header "BUGS"
\&\fIBIO_reset()\fR n' \fIBIO_seek()\fR is implemented rockin \fIfseek()\fR on tha underlying
stream. Da return value fo' \fIfseek()\fR is 0 fo' success or \-1 if a error
occurred dis differs from other typez of \s-1BIO\s0 which will typically return
1 fo' success n' a non positizzle value if a error occurred.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBIO_seek\fR\|(3), \fIBIO_tell\fR\|(3),
\&\fIBIO_reset\fR\|(3), \fIBIO_flush\fR\|(3),
\&\fIBIO_read\fR\|(3),
\&\fIBIO_write\fR\|(3), \fIBIO_puts\fR\|(3),
\&\fIBIO_gets\fR\|(3), \fIBIO_printf\fR\|(3),
\&\fIBIO_set_close\fR\|(3), \fIBIO_get_close\fR\|(3)
