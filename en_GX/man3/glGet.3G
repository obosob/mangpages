'\" t
.\"     Title: glGet
.\"    Author: opengl.org
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 08/03/2013
.\"    Manual: OpenGL Manual
.\"    Source: opengl.org
.\"  Language: Gangsta
.\"
.TH "GLGET" "3G" "08/03/2013" "opengl.org" "OpenGL Manual"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
glGit \- return tha value or jointz of a selected parameter
.SH "C SPECIFICATION"
.HP \w'void\ glGetBooleanv('u
.BI "void glGetBooleanv(GLenum\ " "pname" ", GLboolean\ *\ " "params" ");"
.SH "C SPECIFICATION"
.HP \w'void\ glGetDoublev('u
.BI "void glGetDoublev(GLenum\ " "pname" ", GLdouble\ *\ " "params" ");"
.SH "C SPECIFICATION"
.HP \w'void\ glGetFloatv('u
.BI "void glGetFloatv(GLenum\ " "pname" ", GLfloat\ *\ " "params" ");"
.SH "C SPECIFICATION"
.HP \w'void\ glGetIntegerv('u
.BI "void glGetIntegerv(GLenum\ " "pname" ", GLint\ *\ " "params" ");"
.SH "C SPECIFICATION"
.HP \w'void\ glGetInteger64v('u
.BI "void glGetInteger64v(GLenum\ " "pname" ", GLint64\ *\ " "params" ");"
.SH "PARAMETERS"
.PP
\fIpname\fR
.RS 4
Specifies tha parameta value ta be returned\&. Da symbolic constants up in tha list below is accepted\&.
.RE
.PP
\fIparams\fR
.RS 4
Returns tha value or jointz of tha specified parameter\&.
.RE
.SH "C SPECIFICATION"
.HP \w'void\ glGetBooleani_v('u
.BI "void glGetBooleani_v(GLenum\ " "pname" ", GLuint\ " "index" ", GLboolean\ *\ " "data" ");"
.SH "C SPECIFICATION"
.HP \w'void\ glGetIntegeri_v('u
.BI "void glGetIntegeri_v(GLenum\ " "pname" ", GLuint\ " "index" ", GLint\ *\ " "data" ");"
.SH "C SPECIFICATION"
.HP \w'void\ glGetFloati_v('u
.BI "void glGetFloati_v(GLenum\ " "pname" ", GLuint\ " "index" ", GLfloat\ *\ " "data" ");"
.SH "C SPECIFICATION"
.HP \w'void\ glGetDoublei_v('u
.BI "void glGetDoublei_v(GLenum\ " "pname" ", GLuint\ " "index" ", GLdouble\ *\ " "data" ");"
.SH "C SPECIFICATION"
.HP \w'void\ glGetInteger64i_v('u
.BI "void glGetInteger64i_v(GLenum\ " "pname" ", GLuint\ " "index" ", GLint64\ *\ " "data" ");"
.SH "PARAMETERS"
.PP
\fIpname\fR
.RS 4
Specifies tha parameta value ta be returned\&. Da symbolic constants up in tha list below is accepted\&.
.RE
.PP
\fIindex\fR
.RS 4
Specifies tha index of tha particular element bein queried\&.
.RE
.PP
\fIdata\fR
.RS 4
Returns tha value or jointz of tha specified parameter\&.
.RE
.SH "DESCRIPTION"
.PP
These four commandz return joints fo' simple state variablez up in GL\&.
\fIpname\fR
is a symbolic constant indicatin tha state variable ta be returned, and
\fIparams\fR
is a pointa ta a array of tha indicated type up in which ta place tha returned data\&.
.PP
Type conversion is performed if
\fIparams\fR
has a gangbangin' finger-lickin' different type than tha state variable value bein requested\&. If
\fBglGetBooleanv\fR
is called, a gangbangin' floating\-point (or integer) value is converted to
\fBGL_FALSE\fR
if n' only if it is 0\&.0 (or 0)\&. Otherwise, it is converted to
\fBGL_TRUE\fR\&. If
\fBglGetIntegerv\fR
is called, boolean joints is returned as
\fBGL_TRUE\fR
or
\fBGL_FALSE\fR, n' most floating\-point joints is rounded ta tha nearest integer value\&. Floating\-point flavas n' normals, however, is returned wit a linear mappin dat maps 1\&.0 ta da most thugged-out positizzle representable integer value and
\-1\&.0
to da most thugged-out wack representable integer value\&. If
\fBglGetFloatv\fR
or
\fBglGetDoublev\fR
is called, boolean joints is returned as
\fBGL_TRUE\fR
or
\fBGL_FALSE\fR, n' integer joints is converted ta floating\-point joints\&.
.PP
Da followin symbolic constants is accepted by
\fIpname\fR:
.PP
\fBGL_ACTIVE_TEXTURE\fR
.RS 4
.sp
\fIparams\fR
returns a single value indicatin tha actizzle multitexture unit\&. Da initial value is
\fBGL_TEXTURE0\fR\&. Right back up in yo muthafuckin ass. See
\fBglActiveTexture\fR()\&.
.RE
.PP
\fBGL_ALIASED_LINE_WIDTH_RANGE\fR
.RS 4
.sp
\fIparams\fR
returns a pair of joints indicatin tha range of widths supported fo' aliased lines\&. Right back up in yo muthafuckin ass. See
\fBglLineWidth\fR()\&.
.RE
.PP
\fBGL_ARRAY_BUFFER_BINDING\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha buffer object currently bound ta tha target
\fBGL_ARRAY_BUFFER\fR\&. If no buffer object is bound ta dis target, 0 is returned\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindBuffer\fR()\&.
.RE
.PP
\fBGL_BLEND\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether blendin is enabled\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglBlendFunc\fR()\&.
.RE
.PP
\fBGL_BLEND_COLOR\fR
.RS 4
.sp
\fIparams\fR
returns four joints, tha red, green, blue, n' alpha joints which is tha componentz of tha blend color\&. Right back up in yo muthafuckin ass. See
\fBglBlendColor\fR()\&.
.RE
.PP
\fBGL_BLEND_DST_ALPHA\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha symbolic constant identifyin tha alpha destination blend function\&. Da initial value is
\fBGL_ZERO\fR\&. Right back up in yo muthafuckin ass. See
\fBglBlendFunc\fR()
and
\fBglBlendFuncSeparate\fR()\&.
.RE
.PP
\fBGL_BLEND_DST_RGB\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha symbolic constant identifyin tha RGB destination blend function\&. Da initial value is
\fBGL_ZERO\fR\&. Right back up in yo muthafuckin ass. See
\fBglBlendFunc\fR()
and
\fBglBlendFuncSeparate\fR()\&.
.RE
.PP
\fBGL_BLEND_EQUATION_RGB\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin whether tha RGB blend equation is
\fBGL_FUNC_ADD\fR,
\fBGL_FUNC_SUBTRACT\fR,
\fBGL_FUNC_REVERSE_SUBTRACT\fR,
\fBGL_MIN\fR
or
\fBGL_MAX\fR\&. Right back up in yo muthafuckin ass. See
\fBglBlendEquationSeparate\fR()\&.
.RE
.PP
\fBGL_BLEND_EQUATION_ALPHA\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin whether tha Alpha blend equation is
\fBGL_FUNC_ADD\fR,
\fBGL_FUNC_SUBTRACT\fR,
\fBGL_FUNC_REVERSE_SUBTRACT\fR,
\fBGL_MIN\fR
or
\fBGL_MAX\fR\&. Right back up in yo muthafuckin ass. See
\fBglBlendEquationSeparate\fR()\&.
.RE
.PP
\fBGL_BLEND_SRC_ALPHA\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha symbolic constant identifyin tha alpha source blend function\&. Da initial value is
\fBGL_ONE\fR\&. Right back up in yo muthafuckin ass. See
\fBglBlendFunc\fR()
and
\fBglBlendFuncSeparate\fR()\&.
.RE
.PP
\fBGL_BLEND_SRC_RGB\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha symbolic constant identifyin tha RGB source blend function\&. Da initial value is
\fBGL_ONE\fR\&. Right back up in yo muthafuckin ass. See
\fBglBlendFunc\fR()
and
\fBglBlendFuncSeparate\fR()\&.
.RE
.PP
\fBGL_COLOR_CLEAR_VALUE\fR
.RS 4
.sp
\fIparams\fR
returns four joints: tha red, green, blue, n' alpha joints used ta clear tha color buffers\&. Integer joints, if requested, is linearly mapped from tha internal floating\-point representation such dat 1\&.0 returns da most thugged-out positizzle representable integer value, and
\-1\&.0
returns da most thugged-out wack representable integer value\&. Da initial value is (0, 0, 0, 0)\&. Right back up in yo muthafuckin ass. See
\fBglClearColor\fR()\&.
.RE
.PP
\fBGL_COLOR_LOGIC_OP\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether a gangbangin' fragment\*(Aqs RGBA color joints is merged tha fuck into tha framebuffer rockin a logical operation\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglLogicOp\fR()\&.
.RE
.PP
\fBGL_COLOR_WRITEMASK\fR
.RS 4
.sp
\fIparams\fR
returns four boolean joints: tha red, green, blue, n' alpha write enablez fo' tha color buffers\&. Da initial value is (\fBGL_TRUE\fR,
\fBGL_TRUE\fR,
\fBGL_TRUE\fR,
\fBGL_TRUE\fR)\&. Right back up in yo muthafuckin ass. See
\fBglColorMask\fR()\&.
.RE
.PP
\fBGL_COMPRESSED_TEXTURE_FORMATS\fR
.RS 4
.sp
\fIparams\fR
returns a list of symbolic constantz of length
\fBGL_NUM_COMPRESSED_TEXTURE_FORMATS\fR
indicatin which compressed texture formats is available\&. Right back up in yo muthafuckin ass. See
\fBglCompressedTexImage2D\fR()\&.
.RE
.PP
\fBGL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of actizzle shader storage blocks dat may be accessed by a cold-ass lil compute shader\&.
.RE
.PP
\fBGL_MAX_COMBINED_SHADER_STORAGE_BLOCKS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum total number of actizzle shader storage blocks dat may be accessed by all actizzle shaders\&.
.RE
.PP
\fBGL_MAX_COMPUTE_UNIFORM_BLOCKS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of uniform blocks per compute shader\&. Da value must be at least 14\&. Right back up in yo muthafuckin ass. See
\fBglUniformBlockBinding\fR()\&.
.RE
.PP
\fBGL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum supported texture image units dat can be used ta access texture maps from tha compute shader\&. Da value may be at least 16\&. Right back up in yo muthafuckin ass. See
\fBglActiveTexture\fR()\&.
.RE
.PP
\fBGL_MAX_COMPUTE_UNIFORM_COMPONENTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of individual floating\-point, integer, or boolean joints dat can be held up in uniform variable storage fo' a cold-ass lil compute shader\&. Da value must be at least 1024\&. Right back up in yo muthafuckin ass. See
\fBglUniform\fR()\&.
.RE
.PP
\fBGL_MAX_COMPUTE_ATOMIC_COUNTERS\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha maximum number of atomic countas available ta compute shaders\&.
.RE
.PP
\fBGL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha maximum number of atomic counta buffers dat may be accessed by a cold-ass lil compute shader\&.
.RE
.PP
\fBGL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of lyrics fo' compute shader uniform variablez up in all uniform blocks (includin default)\&. Da value must be at least 1\&. Right back up in yo muthafuckin ass. See
\fBglUniform\fR()\&.
.RE
.PP
\fBGL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of invocations up in a single local work crew (i\&.e\&., tha thang of tha three dimensions) dat may be dispatched ta a cold-ass lil compute shader\&.
.RE
.PP
\fBGL_MAX_COMPUTE_WORK_GROUP_COUNT\fR
.RS 4
.sp
Accepted by tha indexed versions of
\fBglGet\fR\&.
\fIparams\fR
the maximum number of work crews dat may be dispatched ta a cold-ass lil compute shader\&. Indices 0, 1, n' 2 correspond ta tha X, Y n' Z dimensions, respectively\&.
.RE
.PP
\fBGL_MAX_COMPUTE_WORK_GROUP_SIZE\fR
.RS 4
.sp
Accepted by tha indexed versions of
\fBglGet\fR\&.
\fIparams\fR
the maximum size of a work crews dat may be used durin compilation of a cold-ass lil compute shader\&. Indices 0, 1, n' 2 correspond ta tha X, Y n' Z dimensions, respectively\&.
.RE
.PP
\fBGL_DISPATCH_INDIRECT_BUFFER_BINDING\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha buffer object currently bound ta tha target
\fBGL_DISPATCH_INDIRECT_BUFFER\fR\&. If no buffer object is bound ta dis target, 0 is returned\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindBuffer\fR()\&.
.RE
.PP
\fBGL_MAX_DEBUG_GROUP_STACK_DEPTH\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha maximum depth of tha debug message crew stack\&.
.RE
.PP
\fBGL_DEBUG_GROUP_STACK_DEPTH\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha current depth of tha debug message crew stack\&.
.RE
.PP
\fBGL_CONTEXT_FLAGS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha flags wit which tha context was pimped (like fuckin debuggin functionality)\&.
.RE
.PP
\fBGL_CULL_FACE\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether polygon cullin is enabled\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglCullFace\fR()\&.
.RE
.PP
\fBGL_CURRENT_PROGRAM\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha name of tha program object dat is currently active, or 0 if no program object be active\&. Right back up in yo muthafuckin ass. See
\fBglUseProgram\fR()\&.
.RE
.PP
\fBGL_DEPTH_CLEAR_VALUE\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha value dat is used ta clear tha depth buffer\&. Integer joints, if requested, is linearly mapped from tha internal floating\-point representation such dat 1\&.0 returns da most thugged-out positizzle representable integer value, and
\-1\&.0
returns da most thugged-out wack representable integer value\&. Da initial value is 1\&. Right back up in yo muthafuckin ass. See
\fBglClearDepth\fR()\&.
.RE
.PP
\fBGL_DEPTH_FUNC\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha symbolic constant dat indicates tha depth comparison function\&. Da initial value is
\fBGL_LESS\fR\&. Right back up in yo muthafuckin ass. See
\fBglDepthFunc\fR()\&.
.RE
.PP
\fBGL_DEPTH_RANGE\fR
.RS 4
.sp
\fIparams\fR
returns two joints: tha near n' far mappin limits fo' tha depth buffer\&. Integer joints, if requested, is linearly mapped from tha internal floating\-point representation such dat 1\&.0 returns da most thugged-out positizzle representable integer value, and
\-1\&.0
returns da most thugged-out wack representable integer value\&. Da initial value is (0, 1)\&. Right back up in yo muthafuckin ass. See
\fBglDepthRange\fR()\&.
.RE
.PP
\fBGL_DEPTH_TEST\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether depth testin of fragments is enabled\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglDepthFunc\fR()
and
\fBglDepthRange\fR()\&.
.RE
.PP
\fBGL_DEPTH_WRITEMASK\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin if tha depth buffer is enabled fo' writing\&. Da initial value is
\fBGL_TRUE\fR\&. Right back up in yo muthafuckin ass. See
\fBglDepthMask\fR()\&.
.RE
.PP
\fBGL_DITHER\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether ditherin of fragment flavas n' indices is enabled\&. Da initial value is
\fBGL_TRUE\fR\&.
.RE
.PP
\fBGL_DOUBLEBUFFER\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether double bufferin is supported\&.
.RE
.PP
\fBGL_DRAW_BUFFER\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin which buffers is bein drawn to\&. Right back up in yo muthafuckin ass. See
\fBglDrawBuffer\fR()\&. Da initial value is
\fBGL_BACK\fR
if there be back buffers, otherwise it is
\fBGL_FRONT\fR\&.
.RE
.PP
\fBGL_DRAW_BUFFER\fR\fIi\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin which buffers is bein drawn ta by tha correspondin output color\&. Right back up in yo muthafuckin ass. See
\fBglDrawBuffers\fR()\&. Da initial value of
\fBGL_DRAW_BUFFER0\fR
is
\fBGL_BACK\fR
if there be back buffers, otherwise it is
\fBGL_FRONT\fR\&. Da initial jointz of draw buffers fo' all other output flavas is
\fBGL_NONE\fR\&.
.RE
.PP
\fBGL_DRAW_FRAMEBUFFER_BINDING\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha name of tha framebuffer object currently bound ta the
\fBGL_DRAW_FRAMEBUFFER\fR
target\&. If tha default framebuffer is bound, dis value is ghon be zero\&. Da initial value is zero\&. Right back up in yo muthafuckin ass. See
\fBglBindFramebuffer\fR()\&.
.RE
.PP
\fBGL_READ_FRAMEBUFFER_BINDING\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha name of tha framebuffer object currently bound ta the
\fBGL_READ_FRAMEBUFFER\fR
target\&. If tha default framebuffer is bound, dis value is ghon be zero\&. Da initial value is zero\&. Right back up in yo muthafuckin ass. See
\fBglBindFramebuffer\fR()\&.
.RE
.PP
\fBGL_ELEMENT_ARRAY_BUFFER_BINDING\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha buffer object currently bound ta tha target
\fBGL_ELEMENT_ARRAY_BUFFER\fR\&. If no buffer object is bound ta dis target, 0 is returned\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindBuffer\fR()\&.
.RE
.PP
\fBGL_FRAGMENT_SHADER_DERIVATIVE_HINT\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin tha mode of tha derivatizzle accuracy hint fo' fragment shaders\&. Da initial value is
\fBGL_DONT_CARE\fR\&. Right back up in yo muthafuckin ass. See
\fBglHint\fR()\&.
.RE
.PP
\fBGL_IMPLEMENTATION_COLOR_READ_FORMAT\fR
.RS 4
.sp
\fIparams\fR
returns a single GLenum value indicatin tha implementation\*(Aqs preferred pixel data format\&. Right back up in yo muthafuckin ass. See
\fBglReadPixels\fR()\&.
.RE
.PP
\fBGL_IMPLEMENTATION_COLOR_READ_TYPE\fR
.RS 4
.sp
\fIparams\fR
returns a single GLenum value indicatin tha implementation\*(Aqs preferred pixel data type\&. Right back up in yo muthafuckin ass. See
\fBglReadPixels\fR()\&.
.RE
.PP
\fBGL_LINE_SMOOTH\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether antialiasin of lines is enabled\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglLineWidth\fR()\&.
.RE
.PP
\fBGL_LINE_SMOOTH_HINT\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin tha mode of tha line antialiasin hint\&. Da initial value is
\fBGL_DONT_CARE\fR\&. Right back up in yo muthafuckin ass. See
\fBglHint\fR()\&.
.RE
.PP
\fBGL_LINE_WIDTH\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha line width as specified with
\fBglLineWidth\fR()\&. Da initial value is 1\&.
.RE
.PP
\fBGL_LAYER_PROVOKING_VERTEX\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha implementation dependent specifc vertex of a primitizzle dat is used ta select tha renderin layer\&. If tha value returned is equivalent to
\fBGL_PROVOKING_VERTEX\fR, then tha vertex selection bigs up tha convention specified by
\fBglProvokingVertex\fR()\&. If tha value returned is equivalent to
\fBGL_FIRST_VERTEX_CONVENTION\fR, then tha selection be always taken from tha straight-up original gangsta vertex up in tha primitive\&. If tha value returned is equivalent to
\fBGL_LAST_VERTEX_CONVENTION\fR, then tha selection be always taken from tha last vertex up in tha primitive\&. If tha value returned is equivalent to
\fBGL_UNDEFINED_VERTEX\fR, then tha selection aint guaranteed ta be taken from any specific vertex up in tha primitive\&.
.RE
.PP
\fBGL_LINE_WIDTH_GRANULARITY\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha width difference between adjacent supported widths fo' antialiased lines\&. Right back up in yo muthafuckin ass. See
\fBglLineWidth\fR()\&.
.RE
.PP
\fBGL_LINE_WIDTH_RANGE\fR
.RS 4
.sp
\fIparams\fR
returns two joints: tha smallest n' phattest supported widths fo' antialiased lines\&. Right back up in yo muthafuckin ass. See
\fBglLineWidth\fR()\&.
.RE
.PP
\fBGL_LOGIC_OP_MODE\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin tha selected logic operation mode\&. Da initial value is
\fBGL_COPY\fR\&. Right back up in yo muthafuckin ass. See
\fBglLogicOp\fR()\&.
.RE
.PP
\fBGL_MAJOR_VERSION\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha major version number of tha OpenGL API supported by tha current context\&.
.RE
.PP
\fBGL_MAX_3D_TEXTURE_SIZE\fR
.RS 4
.sp
\fIparams\fR
returns one value, a rough estimate of tha phattest 3D texture dat tha GL can handle\&. Da value must be at least 64\&. Use
\fBGL_PROXY_TEXTURE_3D\fR
to determine if a texture is too large\&. Right back up in yo muthafuckin ass. See
\fBglTexImage3D\fR()\&.
.RE
.PP
\fBGL_MAX_ARRAY_TEXTURE_LAYERS\fR
.RS 4
.sp
\fIparams\fR
returns one value\&. Da value indicates tha maximum number of layers allowed up in a array texture, n' must be at least 256\&. Right back up in yo muthafuckin ass. See
\fBglTexImage2D\fR()\&.
.RE
.PP
\fBGL_MAX_CLIP_DISTANCES\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of application\-defined clippin distances\&. Da value must be at least 8\&.
.RE
.PP
\fBGL_MAX_COLOR_TEXTURE_SAMPLES\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of samplez up in a cold-ass lil color multisample texture\&.
.RE
.PP
\fBGL_MAX_COMBINED_ATOMIC_COUNTERS\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha maximum number of atomic countas available ta all actizzle shaders\&.
.RE
.PP
\fBGL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of lyrics fo' fragment shader uniform variablez up in all uniform blocks (includin default)\&. Da value must be at least 1\&. Right back up in yo muthafuckin ass. See
\fBglUniform\fR()\&.
.RE
.PP
\fBGL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of lyrics fo' geometry shader uniform variablez up in all uniform blocks (includin default)\&. Da value must be at least 1\&. Right back up in yo muthafuckin ass. See
\fBglUniform\fR()\&.
.RE
.PP
\fBGL_MAX_COMBINED_TEXTURE_IMAGE_UNITS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum supported texture image units dat can be used ta access texture maps from tha vertex shader n' tha fragment processor combined\&. If both tha vertex shader n' tha fragment processin stage access tha same ol' dirty texture image unit, then dat counts as rockin two texture image units against dis limit\&. Da value must be at least 48\&. Right back up in yo muthafuckin ass. See
\fBglActiveTexture\fR()\&.
.RE
.PP
\fBGL_MAX_COMBINED_UNIFORM_BLOCKS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of uniform blocks per program\&. Da value must be at least 36\&. Right back up in yo muthafuckin ass. See
\fBglUniformBlockBinding\fR()\&.
.RE
.PP
\fBGL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of lyrics fo' vertex shader uniform variablez up in all uniform blocks (includin default)\&. Da value must be at least 1\&. Right back up in yo muthafuckin ass. See
\fBglUniform\fR()\&.
.RE
.PP
\fBGL_MAX_CUBE_MAP_TEXTURE_SIZE\fR
.RS 4
.sp
\fIparams\fR
returns one value\&. Da value gives a rough estimate of tha phattest cube\-map texture dat tha GL can handle\&. Da value must be at least 1024\&. Use
\fBGL_PROXY_TEXTURE_CUBE_MAP\fR
to determine if a texture is too large\&. Right back up in yo muthafuckin ass. See
\fBglTexImage2D\fR()\&.
.RE
.PP
\fBGL_MAX_DEPTH_TEXTURE_SAMPLES\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of samplez up in a multisample depth or depth\-stencil texture\&.
.RE
.PP
\fBGL_MAX_DRAW_BUFFERS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of simultaneous outputs dat may be freestyled up in a gangbangin' fragment shader\&. Da value must be at least 8\&. Right back up in yo muthafuckin ass. See
\fBglDrawBuffers\fR()\&.
.RE
.PP
\fBGL_MAX_DUALSOURCE_DRAW_BUFFERS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of actizzle draw buffers when rockin dual\-source blending\&. Da value must be at least 1\&. Right back up in yo muthafuckin ass. See
\fBglBlendFunc\fR()
and
\fBglBlendFuncSeparate\fR()\&.
.RE
.PP
\fBGL_MAX_ELEMENTS_INDICES\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha recommended maximum number of vertex array indices\&. Right back up in yo muthafuckin ass. See
\fBglDrawRangeElements\fR()\&.
.RE
.PP
\fBGL_MAX_ELEMENTS_VERTICES\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha recommended maximum number of vertex array vertices\&. Right back up in yo muthafuckin ass. See
\fBglDrawRangeElements\fR()\&.
.RE
.PP
\fBGL_MAX_FRAGMENT_ATOMIC_COUNTERS\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha maximum number of atomic countas available ta fragment shaders\&.
.RE
.PP
\fBGL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of actizzle shader storage blocks dat may be accessed by a gangbangin' fragment shader\&.
.RE
.PP
\fBGL_MAX_FRAGMENT_INPUT_COMPONENTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of componentz of tha inputs read by tha fragment shader, which must be at least 128\&.
.RE
.PP
\fBGL_MAX_FRAGMENT_UNIFORM_COMPONENTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of individual floating\-point, integer, or boolean joints dat can be held up in uniform variable storage fo' a gangbangin' fragment shader\&. Da value must be at least 1024\&. Right back up in yo muthafuckin ass. See
\fBglUniform\fR()\&.
.RE
.PP
\fBGL_MAX_FRAGMENT_UNIFORM_VECTORS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of individual 4\-vectorz of floating\-point, integer, or boolean joints dat can be held up in uniform variable storage fo' a gangbangin' fragment shader\&. Da value is equal ta tha value of
\fBGL_MAX_FRAGMENT_UNIFORM_COMPONENTS\fR
divided by 4 n' must be at least 256\&. Right back up in yo muthafuckin ass. See
\fBglUniform\fR()\&.
.RE
.PP
\fBGL_MAX_FRAGMENT_UNIFORM_BLOCKS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of uniform blocks per fragment shader\&. Da value must be at least 12\&. Right back up in yo muthafuckin ass. See
\fBglUniformBlockBinding\fR()\&.
.RE
.PP
\fBGL_MAX_FRAMEBUFFER_WIDTH\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum width fo' a gangbangin' framebuffer dat has no attachments, which must be at least 16384\&. Right back up in yo muthafuckin ass. See
\fBglFramebufferParameter\fR()\&.
.RE
.PP
\fBGL_MAX_FRAMEBUFFER_HEIGHT\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum height fo' a gangbangin' framebuffer dat has no attachments, which must be at least 16384\&. Right back up in yo muthafuckin ass. See
\fBglFramebufferParameter\fR()\&.
.RE
.PP
\fBGL_MAX_FRAMEBUFFER_LAYERS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of layers fo' a gangbangin' framebuffer dat has no attachments, which must be at least 2048\&. Right back up in yo muthafuckin ass. See
\fBglFramebufferParameter\fR()\&.
.RE
.PP
\fBGL_MAX_FRAMEBUFFER_SAMPLES\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum samplez up in a gangbangin' framebuffer dat has no attachments, which must be at least 4\&. Right back up in yo muthafuckin ass. See
\fBglFramebufferParameter\fR()\&.
.RE
.PP
\fBGL_MAX_GEOMETRY_ATOMIC_COUNTERS\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha maximum number of atomic countas available ta geometry shaders\&.
.RE
.PP
\fBGL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of actizzle shader storage blocks dat may be accessed by a geometry shader\&.
.RE
.PP
\fBGL_MAX_GEOMETRY_INPUT_COMPONENTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of componentz of inputs read by a geometry shader, which must be at least 64\&.
.RE
.PP
\fBGL_MAX_GEOMETRY_OUTPUT_COMPONENTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of componentz of outputs freestyled by a geometry shader, which must be at least 128\&.
.RE
.PP
\fBGL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum supported texture image units dat can be used ta access texture maps from tha geometry shader\&. Da value must be at least 16\&. Right back up in yo muthafuckin ass. See
\fBglActiveTexture\fR()\&.
.RE
.PP
\fBGL_MAX_GEOMETRY_UNIFORM_BLOCKS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of uniform blocks per geometry shader\&. Da value must be at least 12\&. Right back up in yo muthafuckin ass. See
\fBglUniformBlockBinding\fR()\&.
.RE
.PP
\fBGL_MAX_GEOMETRY_UNIFORM_COMPONENTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of individual floating\-point, integer, or boolean joints dat can be held up in uniform variable storage fo' a geometry shader\&. Da value must be at least 1024\&. Right back up in yo muthafuckin ass. See
\fBglUniform\fR()\&.
.RE
.PP
\fBGL_MAX_INTEGER_SAMPLES\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of samplez supported up in integer format multisample buffers\&.
.RE
.PP
\fBGL_MIN_MAP_BUFFER_ALIGNMENT\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha minimum alignment up in basic machine unitz of pointas returned from\fBglMapBuffer\fR()
and
\fBglMapBufferRange\fR()\&. This value must be a juice of two n' must be at least 64\&.
.RE
.PP
\fBGL_MAX_LABEL_LENGTH\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum length of a label dat may be assigned ta a object\&. Right back up in yo muthafuckin ass. See
\fBglObjectLabel\fR()
and
\fBglObjectPtrLabel\fR()\&.
.RE
.PP
\fBGL_MAX_PROGRAM_TEXEL_OFFSET\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum texel offset allowed up in a texture lookup, which must be at least 7\&.
.RE
.PP
\fBGL_MIN_PROGRAM_TEXEL_OFFSET\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha minimum texel offset allowed up in a texture lookup, which must be at most \-8\&.
.RE
.PP
\fBGL_MAX_RECTANGLE_TEXTURE_SIZE\fR
.RS 4
.sp
\fIparams\fR
returns one value\&. Da value gives a rough estimate of tha phattest rectangular texture dat tha GL can handle\&. Da value must be at least 1024\&. Use
\fBGL_PROXY_RECTANGLE_TEXTURE\fR
to determine if a texture is too large\&. Right back up in yo muthafuckin ass. See
\fBglTexImage2D\fR()\&.
.RE
.PP
\fBGL_MAX_RENDERBUFFER_SIZE\fR
.RS 4
.sp
\fIparams\fR
returns one value\&. Da value indicates tha maximum supported size fo' renderbuffers\&. Right back up in yo muthafuckin ass. See
\fBglFramebufferRenderbuffer\fR()\&.
.RE
.PP
\fBGL_MAX_SAMPLE_MASK_WORDS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of sample mask lyrics\&.
.RE
.PP
\fBGL_MAX_SERVER_WAIT_TIMEOUT\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum
\fBglWaitSync\fR()
timeout interval\&.
.RE
.PP
\fBGL_MAX_SHADER_STORAGE_BUFFER_BINDINGS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of shader storage buffer bindin points on tha context, which must be at least 8\&.
.RE
.PP
\fBGL_MAX_TESS_CONTROL_ATOMIC_COUNTERS\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha maximum number of atomic countas available ta tessellation control shaders\&.
.RE
.PP
\fBGL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha maximum number of atomic countas available ta tessellation evaluation shaders\&.
.RE
.PP
\fBGL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of actizzle shader storage blocks dat may be accessed by a tessellation control shader\&.
.RE
.PP
\fBGL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of actizzle shader storage blocks dat may be accessed by a tessellation evaluation shader\&.
.RE
.PP
\fBGL_MAX_TEXTURE_BUFFER_SIZE\fR
.RS 4
.sp
\fIparams\fR
returns one value\&. Da value gives tha maximum number of texels allowed up in tha texel array of a texture buffer object\&. Value must be at least 65536\&.
.RE
.PP
\fBGL_MAX_TEXTURE_IMAGE_UNITS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum supported texture image units dat can be used ta access texture maps from tha fragment shader\&. Da value must be at least 16\&. Right back up in yo muthafuckin ass. See
\fBglActiveTexture\fR()\&.
.RE
.PP
\fBGL_MAX_TEXTURE_LOD_BIAS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum, absolute value of tha texture level\-of\-detail bias\&. Da value must be at least 2\&.0\&.
.RE
.PP
\fBGL_MAX_TEXTURE_SIZE\fR
.RS 4
.sp
\fIparams\fR
returns one value\&. Da value gives a rough estimate of tha phattest texture dat tha GL can handle\&. Da value must be at least 1024\&. Use a proxy texture target such as
\fBGL_PROXY_TEXTURE_1D\fR
or
\fBGL_PROXY_TEXTURE_2D\fR
to determine if a texture is too large\&. Right back up in yo muthafuckin ass. See
\fBglTexImage1D\fR()
and
\fBglTexImage2D\fR()\&.
.RE
.PP
\fBGL_MAX_UNIFORM_BUFFER_BINDINGS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of uniform buffer bindin points on tha context, which must be at least 36\&.
.RE
.PP
\fBGL_MAX_UNIFORM_BLOCK_SIZE\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum size up in basic machine unitz of a uniform block, which must be at least 16384\&.
.RE
.PP
\fBGL_MAX_UNIFORM_LOCATIONS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of explicitly assignable uniform locations, which must be at least 1024\&.
.RE
.PP
\fBGL_MAX_VARYING_COMPONENTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number components fo' varyin variables, which must be at least 60\&.
.RE
.PP
\fBGL_MAX_VARYING_VECTORS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number 4\-vectors fo' varyin variables, which is equal ta tha value of
\fBGL_MAX_VARYING_COMPONENTS\fR
and must be at least 15\&.
.RE
.PP
\fBGL_MAX_VARYING_FLOATS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of interpolators available fo' processin varyin variablez used by vertex n' fragment shaders\&. This value represents tha number of individual floating\-point joints dat can be interpolated; varyin variablez declared as vectors, matrices, n' arrays will all consume multiple interpolators\&. Da value must be at least 32\&.
.RE
.PP
\fBGL_MAX_VERTEX_ATOMIC_COUNTERS\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha maximum number of atomic countas available ta vertex shaders\&.
.RE
.PP
\fBGL_MAX_VERTEX_ATTRIBS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of 4\-component generic vertex attributes accessible ta a vertex shader\&. Da value must be at least 16\&. Right back up in yo muthafuckin ass. See
\fBglVertexAttrib\fR()\&.
.RE
.PP
\fBGL_MAX_VERTEX_SHADER_STORAGE_BLOCKS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of actizzle shader storage blocks dat may be accessed by a vertex shader\&.
.RE
.PP
\fBGL_MAX_VERTEX_TEXTURE_IMAGE_UNITS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum supported texture image units dat can be used ta access texture maps from tha vertex shader\&. Da value may be at least 16\&. Right back up in yo muthafuckin ass. See
\fBglActiveTexture\fR()\&.
.RE
.PP
\fBGL_MAX_VERTEX_UNIFORM_COMPONENTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of individual floating\-point, integer, or boolean joints dat can be held up in uniform variable storage fo' a vertex shader\&. Da value must be at least 1024\&. Right back up in yo muthafuckin ass. See
\fBglUniform\fR()\&.
.RE
.PP
\fBGL_MAX_VERTEX_UNIFORM_VECTORS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of 4\-vectors dat may be held up in uniform variable storage fo' tha vertex shader\&. Da value of
\fBGL_MAX_VERTEX_UNIFORM_VECTORS\fR
is equal ta tha value of
\fBGL_MAX_VERTEX_UNIFORM_COMPONENTS\fR
and must be at least 256\&.
.RE
.PP
\fBGL_MAX_VERTEX_OUTPUT_COMPONENTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of componentz of output freestyled by a vertex shader, which must be at least 64\&.
.RE
.PP
\fBGL_MAX_VERTEX_UNIFORM_BLOCKS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of uniform blocks per vertex shader\&. Da value must be at least 12\&. Right back up in yo muthafuckin ass. See
\fBglUniformBlockBinding\fR()\&.
.RE
.PP
\fBGL_MAX_VIEWPORT_DIMS\fR
.RS 4
.sp
\fIparams\fR
returns two joints: tha maximum supported width n' height of tha viewport\&. These must be at least as big-ass as tha visible dimensionz of tha display bein rendered to\&. Right back up in yo muthafuckin ass. See
\fBglViewport\fR()\&.
.RE
.PP
\fBGL_MAX_VIEWPORTS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha maximum number of simultaneous viewports dat is supported\&. Da value must be at least 16\&. Right back up in yo muthafuckin ass. See
\fBglViewportIndexed\fR()\&.
.RE
.PP
\fBGL_MINOR_VERSION\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha minor version number of tha OpenGL API supported by tha current context\&.
.RE
.PP
\fBGL_NUM_COMPRESSED_TEXTURE_FORMATS\fR
.RS 4
.sp
\fIparams\fR
returns a single integer value indicatin tha number of available compressed texture formats\&. Da minimum value is 4\&. Right back up in yo muthafuckin ass. See
\fBglCompressedTexImage2D\fR()\&.
.RE
.PP
\fBGL_NUM_EXTENSIONS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of extensions supported by tha GL implementation fo' tha current context\&. Right back up in yo muthafuckin ass. See
\fBglGetString\fR()\&.
.RE
.PP
\fBGL_NUM_PROGRAM_BINARY_FORMATS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of program binary formats supported by tha implementation\&.
.RE
.PP
\fBGL_NUM_SHADER_BINARY_FORMATS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of binary shader formats supported by tha implementation\&. If dis value is pimped outa than zero, then tha implementation supports loadin binary shaders\&. If it is zero, then tha loadin of binary shadaz by tha implementation aint supported\&.
.RE
.PP
\fBGL_PACK_ALIGNMENT\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha byte alignment used fo' freestylin pixel data ta memory\&. Da initial value is 4\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_PACK_IMAGE_HEIGHT\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha image height used fo' freestylin pixel data ta memory\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_PACK_LSB_FIRST\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether single\-bit pixels bein freestyled ta memory is freestyled first ta tha least dope bit of each unsigned byte\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_PACK_ROW_LENGTH\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha row length used fo' freestylin pixel data ta memory\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_PACK_SKIP_IMAGES\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of pixel images skipped before tha straight-up original gangsta pixel is freestyled tha fuck into memory\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_PACK_SKIP_PIXELS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of pixel locations skipped before tha straight-up original gangsta pixel is freestyled tha fuck into memory\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_PACK_SKIP_ROWS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of rowz of pixel locations skipped before tha straight-up original gangsta pixel is freestyled tha fuck into memory\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_PACK_SWAP_BYTES\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether tha bytez of two\-byte n' four\-byte pixel indices n' components is swapped before bein freestyled ta memory\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_PIXEL_PACK_BUFFER_BINDING\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha buffer object currently bound ta tha target
\fBGL_PIXEL_PACK_BUFFER\fR\&. If no buffer object is bound ta dis target, 0 is returned\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindBuffer\fR()\&.
.RE
.PP
\fBGL_PIXEL_UNPACK_BUFFER_BINDING\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha buffer object currently bound ta tha target
\fBGL_PIXEL_UNPACK_BUFFER\fR\&. If no buffer object is bound ta dis target, 0 is returned\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindBuffer\fR()\&.
.RE
.PP
\fBGL_POINT_FADE_THRESHOLD_SIZE\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha point size threshold fo' determinin tha point size\&. Right back up in yo muthafuckin ass. See
\fBglPointParameter\fR()\&.
.RE
.PP
\fBGL_PRIMITIVE_RESTART_INDEX\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha current primitizzle restart index\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglPrimitiveRestartIndex\fR()\&.
.RE
.PP
\fBGL_PROGRAM_BINARY_FORMATS\fR
.RS 4
.sp
\fIparams\fR
an array of
\fBGL_NUM_PROGRAM_BINARY_FORMATS\fR
values, indicatin tha proram binary formats supported by tha implementation\&.
.RE
.PP
\fBGL_PROGRAM_PIPELINE_BINDING\fR
.RS 4
.sp
\fIparams\fR
a single value, tha name of tha currently bound program pipeline object, or zero if no program pipeline object is bound\&. Right back up in yo muthafuckin ass. See
\fBglBindProgramPipeline\fR()\&.
.RE
.PP
\fBGL_PROVOKING_VERTEX\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha currently selected provokin vertex convention\&. Da initial value is
\fBGL_LAST_VERTEX_CONVENTION\fR\&. Right back up in yo muthafuckin ass. See
\fBglProvokingVertex\fR()\&.
.RE
.PP
\fBGL_POINT_SIZE\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha point size as specified by
\fBglPointSize\fR()\&. Da initial value is 1\&.
.RE
.PP
\fBGL_POINT_SIZE_GRANULARITY\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha size difference between adjacent supported sizes fo' antialiased points\&. Right back up in yo muthafuckin ass. See
\fBglPointSize\fR()\&.
.RE
.PP
\fBGL_POINT_SIZE_RANGE\fR
.RS 4
.sp
\fIparams\fR
returns two joints: tha smallest n' phattest supported sizes fo' antialiased points\&. Da smallest size must be at most 1, n' tha phattest size must be at least 1\&. Right back up in yo muthafuckin ass. See
\fBglPointSize\fR()\&.
.RE
.PP
\fBGL_POLYGON_OFFSET_FACTOR\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha scalin factor used ta determine tha variable offset dat be added ta tha depth value of each fragment generated when a polygon is rasterized\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglPolygonOffset\fR()\&.
.RE
.PP
\fBGL_POLYGON_OFFSET_UNITS\fR
.RS 4
.sp
\fIparams\fR
returns one value\&. This value is multiplied by a implementation\-specific value n' then added ta tha depth value of each fragment generated when a polygon is rasterized\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglPolygonOffset\fR()\&.
.RE
.PP
\fBGL_POLYGON_OFFSET_FILL\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether polygon offset is enabled fo' polygons up in fill mode\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglPolygonOffset\fR()\&.
.RE
.PP
\fBGL_POLYGON_OFFSET_LINE\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether polygon offset is enabled fo' polygons up in line mode\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglPolygonOffset\fR()\&.
.RE
.PP
\fBGL_POLYGON_OFFSET_POINT\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether polygon offset is enabled fo' polygons up in point mode\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglPolygonOffset\fR()\&.
.RE
.PP
\fBGL_POLYGON_SMOOTH\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether antialiasin of polygons is enabled\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglPolygonMode\fR()\&.
.RE
.PP
\fBGL_POLYGON_SMOOTH_HINT\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin tha mode of tha polygon antialiasin hint\&. Da initial value is
\fBGL_DONT_CARE\fR\&. Right back up in yo muthafuckin ass. See
\fBglHint\fR()\&.
.RE
.PP
\fBGL_READ_BUFFER\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin which color buffer is selected fo' reading\&. Da initial value is
\fBGL_BACK\fR
if there be a funky-ass back buffer, otherwise it is
\fBGL_FRONT\fR\&. Right back up in yo muthafuckin ass. See
\fBglReadPixels\fR()\&.
.RE
.PP
\fBGL_RENDERBUFFER_BINDING\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha renderbuffer object currently bound ta tha target
\fBGL_RENDERBUFFER\fR\&. If no renderbuffer object is bound ta dis target, 0 is returned\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindRenderbuffer\fR()\&.
.RE
.PP
\fBGL_SAMPLE_BUFFERS\fR
.RS 4
.sp
\fIparams\fR
returns a single integer value indicatin tha number of sample buffers associated wit tha framebuffer\&. Right back up in yo muthafuckin ass. See
\fBglSampleCoverage\fR()\&.
.RE
.PP
\fBGL_SAMPLE_COVERAGE_VALUE\fR
.RS 4
.sp
\fIparams\fR
returns a single positizzle floating\-point value indicatin tha current sample coverage value\&. Right back up in yo muthafuckin ass. See
\fBglSampleCoverage\fR()\&.
.RE
.PP
\fBGL_SAMPLE_COVERAGE_INVERT\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin if tha temporary coverage value should be inverted\&. Right back up in yo muthafuckin ass. See
\fBglSampleCoverage\fR()\&.
.RE
.PP
\fBGL_SAMPLER_BINDING\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha sampla object currently bound ta tha actizzle texture unit\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindSampler\fR()\&.
.RE
.PP
\fBGL_SAMPLES\fR
.RS 4
.sp
\fIparams\fR
returns a single integer value indicatin tha coverage mask size\&. Right back up in yo muthafuckin ass. See
\fBglSampleCoverage\fR()\&.
.RE
.PP
\fBGL_SCISSOR_BOX\fR
.RS 4
.sp
\fIparams\fR
returns four joints: the
x
and
y
window coordinatez of tha scissor box, followed by its width n' height\&. Initially the
x
and
y
window coordinates is both 0 n' tha width n' height is set ta tha size of tha window\&. Right back up in yo muthafuckin ass. See
\fBglScissor\fR()\&.
.RE
.PP
\fBGL_SCISSOR_TEST\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether scissorin is enabled\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglScissor\fR()\&.
.RE
.PP
\fBGL_SHADER_COMPILER\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether a online shader compila is present up in tha implementation\& fo' realz. All desktop OpenGL implementations must support online shader compilations, n' therefore tha value of
\fBGL_SHADER_COMPILER\fR
will always be
\fBGL_TRUE\fR\&.
.RE
.PP
\fBGL_SHADER_STORAGE_BUFFER_BINDING\fR
.RS 4
.sp
When used wit non\-indexed variants of
\fBglGet\fR
(such as
\fBglGetIntegerv\fR),
\fIparams\fR
returns a single value, tha name of tha buffer object currently bound ta tha target
\fBGL_SHADER_STORAGE_BUFFER\fR\&. If no buffer object is bound ta dis target, 0 is returned\&. When used wit indexed variants of
\fBglGet\fR
(such as
\fBglGetIntegeri_v\fR),
\fIparams\fR
returns a single value, tha name of tha buffer object bound ta tha indexed shader storage buffer bindin points\&. Da initial value is 0 fo' all targets\&. Right back up in yo muthafuckin ass. See
\fBglBindBuffer\fR(),
\fBglBindBufferBase\fR(), and
\fBglBindBufferRange\fR()\&.
.RE
.PP
\fBGL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha minimum required alignment fo' shader storage buffer sizes n' offset\&. Da initial value is 1\&. Right back up in yo muthafuckin ass. See
\fBglShaderStorateBlockBinding\fR()\&.
.RE
.PP
\fBGL_SHADER_STORAGE_BUFFER_START\fR
.RS 4
.sp
When used wit indexed variants of
\fBglGet\fR
(such as
\fBglGetInteger64i_v\fR),
\fIparams\fR
returns a single value, tha start offset of tha bindin range fo' each indexed shader storage buffer binding\&. Da initial value is 0 fo' all bindings\&. Right back up in yo muthafuckin ass. See
\fBglBindBufferRange\fR()\&.
.RE
.PP
\fBGL_SHADER_STORAGE_BUFFER_SIZE\fR
.RS 4
.sp
When used wit indexed variants of
\fBglGet\fR
(such as
\fBglGetInteger64i_v\fR),
\fIparams\fR
returns a single value, tha size of tha bindin range fo' each indexed shader storage buffer binding\&. Da initial value is 0 fo' all bindings\&. Right back up in yo muthafuckin ass. See
\fBglBindBufferRange\fR()\&.
.RE
.PP
\fBGL_SMOOTH_LINE_WIDTH_RANGE\fR
.RS 4
.sp
\fIparams\fR
returns a pair of joints indicatin tha range of widths supported fo' smooth (antialiased) lines\&. Right back up in yo muthafuckin ass. See
\fBglLineWidth\fR()\&.
.RE
.PP
\fBGL_SMOOTH_LINE_WIDTH_GRANULARITY\fR
.RS 4
.sp
\fIparams\fR
returns a single value indicatin tha level of quantization applied ta smooth line width parameters\&.
.RE
.PP
\fBGL_STENCIL_BACK_FAIL\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin what tha fuck action is taken fo' back\-facin polygons when tha stencil test fails\&. Da initial value is
\fBGL_KEEP\fR\&. Right back up in yo muthafuckin ass. See
\fBglStencilOpSeparate\fR()\&.
.RE
.PP
\fBGL_STENCIL_BACK_FUNC\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin what tha fuck function is used fo' back\-facin polygons ta compare tha stencil reference value wit tha stencil buffer value\&. Da initial value is
\fBGL_ALWAYS\fR\&. Right back up in yo muthafuckin ass. See
\fBglStencilFuncSeparate\fR()\&.
.RE
.PP
\fBGL_STENCIL_BACK_PASS_DEPTH_FAIL\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin what tha fuck action is taken fo' back\-facin polygons when tha stencil test passes yo, but tha depth test fails\&. Da initial value is
\fBGL_KEEP\fR\&. Right back up in yo muthafuckin ass. See
\fBglStencilOpSeparate\fR()\&.
.RE
.PP
\fBGL_STENCIL_BACK_PASS_DEPTH_PASS\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin what tha fuck action is taken fo' back\-facin polygons when tha stencil test passes n' tha depth test passes\&. Da initial value is
\fBGL_KEEP\fR\&. Right back up in yo muthafuckin ass. See
\fBglStencilOpSeparate\fR()\&.
.RE
.PP
\fBGL_STENCIL_BACK_REF\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha reference value dat is compared wit tha contentz of tha stencil buffer fo' back\-facin polygons\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglStencilFuncSeparate\fR()\&.
.RE
.PP
\fBGL_STENCIL_BACK_VALUE_MASK\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha mask dat is used fo' back\-facin polygons ta mask both tha stencil reference value n' tha stencil buffer value before they is compared\&. Da initial value be all 1\*(Aqs\&. Right back up in yo muthafuckin ass. See
\fBglStencilFuncSeparate\fR()\&.
.RE
.PP
\fBGL_STENCIL_BACK_WRITEMASK\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha mask dat controls freestylin of tha stencil bitplanes fo' back\-facin polygons\&. Da initial value be all 1\*(Aqs\&. Right back up in yo muthafuckin ass. See
\fBglStencilMaskSeparate\fR()\&.
.RE
.PP
\fBGL_STENCIL_CLEAR_VALUE\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha index ta which tha stencil bitplanes is cleared\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglClearStencil\fR()\&.
.RE
.PP
\fBGL_STENCIL_FAIL\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin what tha fuck action is taken when tha stencil test fails\&. Da initial value is
\fBGL_KEEP\fR\&. Right back up in yo muthafuckin ass. See
\fBglStencilOp\fR()\&. This stencil state only affects non\-polygons n' front\-facin polygons\&. Back\-facin polygons use separate stencil state\&. Right back up in yo muthafuckin ass. See
\fBglStencilOpSeparate\fR()\&.
.RE
.PP
\fBGL_STENCIL_FUNC\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin what tha fuck function is used ta compare tha stencil reference value wit tha stencil buffer value\&. Da initial value is
\fBGL_ALWAYS\fR\&. Right back up in yo muthafuckin ass. See
\fBglStencilFunc\fR()\&. This stencil state only affects non\-polygons n' front\-facin polygons\&. Back\-facin polygons use separate stencil state\&. Right back up in yo muthafuckin ass. See
\fBglStencilFuncSeparate\fR()\&.
.RE
.PP
\fBGL_STENCIL_PASS_DEPTH_FAIL\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin what tha fuck action is taken when tha stencil test passes yo, but tha depth test fails\&. Da initial value is
\fBGL_KEEP\fR\&. Right back up in yo muthafuckin ass. See
\fBglStencilOp\fR()\&. This stencil state only affects non\-polygons n' front\-facin polygons\&. Back\-facin polygons use separate stencil state\&. Right back up in yo muthafuckin ass. See
\fBglStencilOpSeparate\fR()\&.
.RE
.PP
\fBGL_STENCIL_PASS_DEPTH_PASS\fR
.RS 4
.sp
\fIparams\fR
returns one value, a symbolic constant indicatin what tha fuck action is taken when tha stencil test passes n' tha depth test passes\&. Da initial value is
\fBGL_KEEP\fR\&. Right back up in yo muthafuckin ass. See
\fBglStencilOp\fR()\&. This stencil state only affects non\-polygons n' front\-facin polygons\&. Back\-facin polygons use separate stencil state\&. Right back up in yo muthafuckin ass. See
\fBglStencilOpSeparate\fR()\&.
.RE
.PP
\fBGL_STENCIL_REF\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha reference value dat is compared wit tha contentz of tha stencil buffer\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglStencilFunc\fR()\&. This stencil state only affects non\-polygons n' front\-facin polygons\&. Back\-facin polygons use separate stencil state\&. Right back up in yo muthafuckin ass. See
\fBglStencilFuncSeparate\fR()\&.
.RE
.PP
\fBGL_STENCIL_TEST\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether stencil testin of fragments is enabled\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglStencilFunc\fR()
and
\fBglStencilOp\fR()\&.
.RE
.PP
\fBGL_STENCIL_VALUE_MASK\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha mask dat is used ta mask both tha stencil reference value n' tha stencil buffer value before they is compared\&. Da initial value be all 1\*(Aqs\&. Right back up in yo muthafuckin ass. See
\fBglStencilFunc\fR()\&. This stencil state only affects non\-polygons n' front\-facin polygons\&. Back\-facin polygons use separate stencil state\&. Right back up in yo muthafuckin ass. See
\fBglStencilFuncSeparate\fR()\&.
.RE
.PP
\fBGL_STENCIL_WRITEMASK\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha mask dat controls freestylin of tha stencil bitplanes\&. Da initial value be all 1\*(Aqs\&. Right back up in yo muthafuckin ass. See
\fBglStencilMask\fR()\&. This stencil state only affects non\-polygons n' front\-facin polygons\&. Back\-facin polygons use separate stencil state\&. Right back up in yo muthafuckin ass. See
\fBglStencilMaskSeparate\fR()\&.
.RE
.PP
\fBGL_STEREO\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether stereo buffers (left n' right) is supported\&.
.RE
.PP
\fBGL_SUBPIXEL_BITS\fR
.RS 4
.sp
\fIparams\fR
returns one value, a estimate of tha number of bitz of subpixel resolution dat is used ta posizzle rasterized geometry up in window coordinates\&. Da value must be at least 4\&.
.RE
.PP
\fBGL_TEXTURE_BINDING_1D\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha texture currently bound ta tha target
\fBGL_TEXTURE_1D\fR\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindTexture\fR()\&.
.RE
.PP
\fBGL_TEXTURE_BINDING_1D_ARRAY\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha texture currently bound ta tha target
\fBGL_TEXTURE_1D_ARRAY\fR\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindTexture\fR()\&.
.RE
.PP
\fBGL_TEXTURE_BINDING_2D\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha texture currently bound ta tha target
\fBGL_TEXTURE_2D\fR\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindTexture\fR()\&.
.RE
.PP
\fBGL_TEXTURE_BINDING_2D_ARRAY\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha texture currently bound ta tha target
\fBGL_TEXTURE_2D_ARRAY\fR\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindTexture\fR()\&.
.RE
.PP
\fBGL_TEXTURE_BINDING_2D_MULTISAMPLE\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha texture currently bound ta tha target
\fBGL_TEXTURE_2D_MULTISAMPLE\fR\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindTexture\fR()\&.
.RE
.PP
\fBGL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha texture currently bound ta tha target
\fBGL_TEXTURE_2D_MULTISAMPLE_ARRAY\fR\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindTexture\fR()\&.
.RE
.PP
\fBGL_TEXTURE_BINDING_3D\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha texture currently bound ta tha target
\fBGL_TEXTURE_3D\fR\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindTexture\fR()\&.
.RE
.PP
\fBGL_TEXTURE_BINDING_BUFFER\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha texture currently bound ta tha target
\fBGL_TEXTURE_BUFFER\fR\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindTexture\fR()\&.
.RE
.PP
\fBGL_TEXTURE_BINDING_CUBE_MAP\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha texture currently bound ta tha target
\fBGL_TEXTURE_CUBE_MAP\fR\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindTexture\fR()\&.
.RE
.PP
\fBGL_TEXTURE_BINDING_RECTANGLE\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha texture currently bound ta tha target
\fBGL_TEXTURE_RECTANGLE\fR\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindTexture\fR()\&.
.RE
.PP
\fBGL_TEXTURE_COMPRESSION_HINT\fR
.RS 4
.sp
\fIparams\fR
returns a single value indicatin tha mode of tha texture compression hint\&. Da initial value is
\fBGL_DONT_CARE\fR\&.
.RE
.PP
\fBGL_TEXTURE_BUFFER_BINDING\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha name of tha buffer object currently bound ta the
\fBGL_TEXTURE_BUFFER\fR
buffer bindin point\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglBindBuffer\fR()\&.
.RE
.PP
\fBGL_TEXTURE_BUFFER_OFFSET_ALIGNMENT\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha minimum required alignment fo' texture buffer sizes n' offset\&. Da initial value is 1\&. Right back up in yo muthafuckin ass. See
\fBglUniformBlockBinding\fR()\&.
.RE
.PP
\fBGL_TIMESTAMP\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha 64\-bit value of tha current GL time\&. Right back up in yo muthafuckin ass. See
\fBglQueryCounter\fR()\&.
.RE
.PP
\fBGL_TRANSFORM_FEEDBACK_BUFFER_BINDING\fR
.RS 4
.sp
When used wit non\-indexed variants of
\fBglGet\fR
(such as
\fBglGetIntegerv\fR),
\fIparams\fR
returns a single value, tha name of tha buffer object currently bound ta tha target
\fBGL_TRANSFORM_FEEDBACK_BUFFER\fR\&. If no buffer object is bound ta dis target, 0 is returned\&. When used wit indexed variants of
\fBglGet\fR
(such as
\fBglGetIntegeri_v\fR),
\fIparams\fR
returns a single value, tha name of tha buffer object bound ta tha indexed transform feedback attribute stream\&. Da initial value is 0 fo' all targets\&. Right back up in yo muthafuckin ass. See
\fBglBindBuffer\fR(),
\fBglBindBufferBase\fR(), and
\fBglBindBufferRange\fR()\&.
.RE
.PP
\fBGL_TRANSFORM_FEEDBACK_BUFFER_START\fR
.RS 4
.sp
When used wit indexed variants of
\fBglGet\fR
(such as
\fBglGetInteger64i_v\fR),
\fIparams\fR
returns a single value, tha start offset of tha bindin range fo' each transform feedback attribute stream\&. Da initial value is 0 fo' all streams\&. Right back up in yo muthafuckin ass. See
\fBglBindBufferRange\fR()\&.
.RE
.PP
\fBGL_TRANSFORM_FEEDBACK_BUFFER_SIZE\fR
.RS 4
.sp
When used wit indexed variants of
\fBglGet\fR
(such as
\fBglGetInteger64i_v\fR),
\fIparams\fR
returns a single value, tha size of tha bindin range fo' each transform feedback attribute stream\&. Da initial value is 0 fo' all streams\&. Right back up in yo muthafuckin ass. See
\fBglBindBufferRange\fR()\&.
.RE
.PP
\fBGL_UNIFORM_BUFFER_BINDING\fR
.RS 4
.sp
When used wit non\-indexed variants of
\fBglGet\fR
(such as
\fBglGetIntegerv\fR),
\fIparams\fR
returns a single value, tha name of tha buffer object currently bound ta tha target
\fBGL_UNIFORM_BUFFER\fR\&. If no buffer object is bound ta dis target, 0 is returned\&. When used wit indexed variants of
\fBglGet\fR
(such as
\fBglGetIntegeri_v\fR),
\fIparams\fR
returns a single value, tha name of tha buffer object bound ta tha indexed uniform buffer bindin point\&. Da initial value is 0 fo' all targets\&. Right back up in yo muthafuckin ass. See
\fBglBindBuffer\fR(),
\fBglBindBufferBase\fR(), and
\fBglBindBufferRange\fR()\&.
.RE
.PP
\fBGL_UNIFORM_BUFFER_OFFSET_ALIGNMENT\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha minimum required alignment fo' uniform buffer sizes n' offset\&. Da initial value is 1\&. Right back up in yo muthafuckin ass. See
\fBglUniformBlockBinding\fR()\&.
.RE
.PP
\fBGL_UNIFORM_BUFFER_SIZE\fR
.RS 4
.sp
When used wit indexed variants of
\fBglGet\fR
(such as
\fBglGetInteger64i_v\fR),
\fIparams\fR
returns a single value, tha size of tha bindin range fo' each indexed uniform buffer binding\&. Da initial value is 0 fo' all bindings\&. Right back up in yo muthafuckin ass. See
\fBglBindBufferRange\fR()\&.
.RE
.PP
\fBGL_UNIFORM_BUFFER_START\fR
.RS 4
.sp
When used wit indexed variants of
\fBglGet\fR
(such as
\fBglGetInteger64i_v\fR),
\fIparams\fR
returns a single value, tha start offset of tha bindin range fo' each indexed uniform buffer binding\&. Da initial value is 0 fo' all bindings\&. Right back up in yo muthafuckin ass. See
\fBglBindBufferRange\fR()\&.
.RE
.PP
\fBGL_UNPACK_ALIGNMENT\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha byte alignment used fo' readin pixel data from memory\&. Da initial value is 4\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_UNPACK_IMAGE_HEIGHT\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha image height used fo' readin pixel data from memory\&. Da initial is 0\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_UNPACK_LSB_FIRST\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether single\-bit pixels bein read from memory is read first from tha least dope bit of each unsigned byte\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_UNPACK_ROW_LENGTH\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha row length used fo' readin pixel data from memory\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_UNPACK_SKIP_IMAGES\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of pixel images skipped before tha straight-up original gangsta pixel is read from memory\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_UNPACK_SKIP_PIXELS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of pixel locations skipped before tha straight-up original gangsta pixel is read from memory\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_UNPACK_SKIP_ROWS\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha number of rowz of pixel locations skipped before tha straight-up original gangsta pixel is read from memory\&. Da initial value is 0\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_UNPACK_SWAP_BYTES\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether tha bytez of two\-byte n' four\-byte pixel indices n' components is swapped afta bein read from memory\&. Da initial value is
\fBGL_FALSE\fR\&. Right back up in yo muthafuckin ass. See
\fBglPixelStore\fR()\&.
.RE
.PP
\fBGL_VERTEX_PROGRAM_POINT_SIZE\fR
.RS 4
.sp
\fIparams\fR
returns a single boolean value indicatin whether vertex program point size mode is enabled\&. If enabled, n' a vertex shader be active, then tha point size is taken from tha shader built\-in
gl_PointSize\&. If disabled, n' a vertex shader be active, then tha point size is taken from tha point state as specified by
\fBglPointSize\fR()\&. Da initial value is
\fBGL_FALSE\fR\&.
.RE
.PP
\fBGL_VERTEX_BINDING_DIVISOR\fR
.RS 4
.sp
Accepted by tha indexed forms\&.
\fIparams\fR
returns a single integer value representin tha instizzle step divisor of tha straight-up original gangsta element up in tha bound buffer\*(Aqs data store fo' vertex attribute bound to
\fIindex\fR\&.
.RE
.PP
\fBGL_VERTEX_BINDING_OFFSET\fR
.RS 4
.sp
Accepted by tha indexed forms\&.
\fIparams\fR
returns a single integer value representin tha byte offset of tha straight-up original gangsta element up in tha bound buffer\*(Aqs data store fo' vertex attribute bound to
\fIindex\fR\&.
.RE
.PP
\fBGL_VERTEX_BINDING_STRIDE\fR
.RS 4
.sp
Accepted by tha indexed forms\&.
\fIparams\fR
returns a single integer value representin tha byte offset between tha start of each element up in tha bound buffer\*(Aqs data store fo' vertex attribute bound to
\fIindex\fR\&.
.RE
.PP
\fBGL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET\fR
.RS 4
.sp
\fIparams\fR
returns a single integer value containin tha maximum offset dat may be added ta a vertex bindin offset\&.
.RE
.PP
\fBGL_MAX_VERTEX_ATTRIB_BINDINGS\fR
.RS 4
.sp
\fIparams\fR
returns a single integer value containin tha maximum number of vertex buffers dat may be bound\&.
.RE
.PP
\fBGL_VIEWPORT\fR
.RS 4
.sp
When used wit non\-indexed variants of
\fBglGet\fR
(such as
\fBglGetIntegerv\fR),
\fIparams\fR
returns four joints: the
x
and
y
window coordinatez of tha viewport, followed by its width n' height\&. Initially the
x
and
y
window coordinates is both set ta 0, n' tha width n' height is set ta tha width n' height of tha window tha fuck into which tha GL will do its rendering\&. Right back up in yo muthafuckin ass. See
\fBglViewport\fR()\&. When used wit indexed variants of
\fBglGet\fR
(such as
\fBglGetIntegeri_v\fR),
\fIparams\fR
returns four joints: the
x
and
y
window coordinatez of tha indexed viewport, followed by its width n' height\&. Initially the
x
and
y
window coordinates is both set ta 0, n' tha width n' height is set ta tha width n' height of tha window tha fuck into which tha GL will do its rendering\&. Right back up in yo muthafuckin ass. See
\fBglViewportIndexedf\fR()\&.
.RE
.PP
\fBGL_VIEWPORT_BOUNDS_RANGE\fR
.RS 4
.sp
\fIparams\fR
returns two joints, tha minimum n' maximum viewport boundz range\&. Da minimum range should be at least [\-32768, 32767]\&.
.RE
.PP
\fBGL_VIEWPORT_INDEX_PROVOKING_VERTEX\fR
.RS 4
.sp
\fIparams\fR
returns one value, tha implementation dependent specifc vertex of a primitizzle dat is used ta select tha viewport index\&. If tha value returned is equivalent to
\fBGL_PROVOKING_VERTEX\fR, then tha vertex selection bigs up tha convention specified by
\fBglProvokingVertex\fR()\&. If tha value returned is equivalent to
\fBGL_FIRST_VERTEX_CONVENTION\fR, then tha selection be always taken from tha straight-up original gangsta vertex up in tha primitive\&. If tha value returned is equivalent to
\fBGL_LAST_VERTEX_CONVENTION\fR, then tha selection be always taken from tha last vertex up in tha primitive\&. If tha value returned is equivalent to
\fBGL_UNDEFINED_VERTEX\fR, then tha selection aint guaranteed ta be taken from any specific vertex up in tha primitive\&.
.RE
.PP
\fBGL_VIEWPORT_SUBPIXEL_BITS\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha number of bitz of sub\-pixel precision which tha GL uses ta interpret tha floatin point viewport bounds\&. Da minimum value is 0\&.
.RE
.PP
\fBGL_MAX_ELEMENT_INDEX\fR
.RS 4
.sp
\fIparams\fR
returns a single value, tha maximum index dat may be specified durin tha transfer of generic vertex attributes ta tha GL\&.
.RE
.PP
Many of tha boolean parametas can also be queried mo' easily using
\fBglIsEnabled\fR()\&.
.SH "NOTES"
.PP
Da followin parametas return tha associated value fo' tha actizzle texture unit:
\fBGL_TEXTURE_1D\fR,
\fBGL_TEXTURE_BINDING_1D\fR,
\fBGL_TEXTURE_2D\fR,
\fBGL_TEXTURE_BINDING_2D\fR,
\fBGL_TEXTURE_3D\fR
and
\fBGL_TEXTURE_BINDING_3D\fR\&.
.PP
\fBGL_MAX_VIEWPORTS\fR,
\fBGL_VIEWPORT_SUBPIXEL_BITS\fR,
\fBGL_VIEWPORT_BOUNDS_RANGE\fR,
\fBGL_LAYER_PROVOKING_VERTEX\fR, and
\fBGL_VIEWPORT_INDEX_PROVOKING_VERTEX\fR
are available only if tha GL version is 4\&.1 or pimped outer\&.
.PP
\fBGL_MAX_VERTEX_ATOMIC_COUNTERS\fR,
\fBGL_MAX_TESS_CONTROL_ATOMIC_COUNTERS\fR,
\fBGL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS\fR,
\fBGL_MAX_GEOMETRY_ATOMIC_COUNTERS\fR,
\fBGL_MAX_FRAMGENT_ATOMIC_COUNTERS\fR, and
\fBGL_MIN_MAP_BUFFER_ALIGNMENT\fR
are accepted by
\fIpname\fR
only if tha GL version is 4\&.2 or pimped outer\&.
.PP
\fBGL_MAX_ELEMENT_INDEX\fR
is accepted by
\fIpname\fR
only if tha GL version is 4\&.3 or pimped outer\&.
.PP
\fBGL_MAX_COMPUTE_UNIFORM_BLOCKS\fR,
\fBGL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS\fR,
\fBGL_MAX_COMPUTE_UNIFORM_COMPONENTS\fR,
\fBGL_MAX_COMPUTE_ATOMIC_COUNTERS\fR,
\fBGL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS\fR,
\fBGL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS\fR,
\fBGL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS\fR,
\fBGL_MAX_COMPUTE_WORK_GROUP_COUNT\fR, and
\fBGL_MAX_COMPUTE_WORK_GROUP_SIZE\fR
and
\fBGL_DISPATCH_INDIRECT_BUFFER_BINDING\fR
are available only if tha GL version is 4\&.3 or pimped outer\&.
.PP
\fBGL_MAX_DEBUG_GROUP_STACK_DEPTH\fR,
\fBGL_DEBUG_GROUP_STACK_DEPTH\fR
and
\fBGL_MAX_LABEL_LENGTH\fR
are accepted only if tha GL version is 4\&.3 or pimped outer\&.
.PP
\fBGL_MAX_UNIFORM_LOCATIONS\fR
is accepted only if tha GL version is 4\&.3 or pimped outer\&.
.PP
\fBGL_MAX_FRAMEBUFFER_WIDTH\fR,
\fBGL_MAX_FRAMEBUFFER_HEIGHT\fR,
\fBGL_MAX_FRAMEBUFFER_LAYERS\fR, and
\fBGL_MAX_FRAMEBUFFER_SAMPLES\fR
are available only if tha GL version is 4\&.3 or pimped outer\&.
.PP
\fBGL_MAX_VERTEX_SHADER_STORAGE_BLOCKS\fR,
\fBGL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS\fR,
\fBGL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS\fR,
\fBGL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS\fR,
\fBGL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS\fR, and
\fBGL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS\fR
are available only if tha GL version is 4\&.3 or higher\&.
.PP
\fBGL_TEXTURE_BUFFER_OFFSET_ALIGNMENT\fR
is available only if tha GL version is 4\&.3 or pimped outer\&.
.PP
\fBGL_VERTEX_BINDING_DIVISOR\fR,
\fBGL_VERTEX_BINDING_OFFSET\fR,
\fBGL_VERTEX_BINDING_STRIDE\fR,
\fBGL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET\fR
and
\fBGL_MAX_VERTEX_ATTRIB_BINDINGS\fR
are available only if tha GL version is 4\&.3 or pimped outer\&.
.SH "ERRORS"
.PP
\fBGL_INVALID_ENUM\fR
is generated if
\fIpname\fR
is not a accepted value\&.
.PP
\fBGL_INVALID_VALUE\fR
is generated on any of
\fBglGetBooleani_v\fR,
\fBglGetIntegeri_v\fR, or
\fBglGetInteger64i_v\fR
if
\fIindex\fR
is outside of tha valid range fo' tha indexed state
\fItarget\fR\&.
.SH "SEE ALSO"
.PP
\fBglGetActiveUniform\fR(),
\fBglGetAttachedShaders\fR(),
\fBglGetAttribLocation\fR(),
\fBglGetBufferParameter\fR(),
\fBglGetBufferPointerv\fR(),
\fBglGetBufferSubData\fR(),
\fBglGetCompressedTexImage\fR(),
\fBglGetError\fR(),
\fBglGetProgram\fR(),
\fBglGetProgramInfoLog\fR(),
\fBglGetQueryiv\fR(),
\fBglGetQueryObject\fR(),
\fBglGetShader\fR(),
\fBglGetShaderInfoLog\fR(),
\fBglGetShaderSource\fR(),
\fBglGetString\fR(),
\fBglGetTexImage\fR(),
\fBglGetTexLevelParameter\fR(),
\fBglGetTexParameter\fR(),
\fBglGetUniform\fR(),
\fBglGetUniformLocation\fR(),
\fBglGetVertexAttrib\fR(),
\fBglGetVertexAttribPointerv\fR(),
\fBglIsEnabled\fR()
.SH "COPYRIGHT"
.PP
Copyright
\(co
1991\-2006 Silicon Graphics, Inc\&. Copyright
\(co
2010\-2011 Khronos Group\&. This document is licensed under tha SGI Jacked Software B License\&. For details, see
\m[blue]\fBhttp://oss\&.sgi\&.com/projects/FreeB/\fR\m[]\&.
.SH "AUTHORS"
.PP
\fBopengl\&.org\fR
