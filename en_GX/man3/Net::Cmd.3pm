.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Cmd 3pm"
.TH Net::Cmd 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Cmd \- Network Command class (as used by FTP, SMTP etc)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::Cmd;
\&
\&    @ISA = qw(Net::Cmd);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Net::Cmd\*(C'\fR be a cold-ass lil collection of methodz dat can be inherited by a sub class
of \f(CW\*(C`IO::Handle\*(C'\fR. These methodz implement tha functionalitizzle required fo' a
command based protocol, fo' example \s-1FTP\s0 n' \s-1SMTP.\s0
.SH "USER METHODS"
.IX Header "USER METHODS"
These methodz provide a user intercourse ta tha \f(CW\*(C`Net::Cmd\*(C'\fR object.
.IP "debug ( \s-1VALUE \s0)" 4
.IX Item "debug ( VALUE )"
Set tha level of debug shiznit fo' dis object. If \f(CW\*(C`VALUE\*(C'\fR aint given
then tha current state is returned. Y'all KNOW dat shit, muthafucka! Otherwise tha state is chizzled ta 
\&\f(CW\*(C`VALUE\*(C'\fR n' tha previous state returned.
.Sp
Different packages
may implement different levelz of debug but a non-zero value thangs up in dis biatch up in 
copiez of all commandz n' responses also bein busted ta \s-1STDERR.\s0
.Sp
If \f(CW\*(C`VALUE\*(C'\fR is \f(CW\*(C`undef\*(C'\fR then tha debug level is ghon be set ta tha default
debug level fo' tha class.
.Sp
This method can also be called as a \fIstatic\fR method ta set/get tha default
debug level fo' a given class.
.IP "message ()" 4
.IX Item "message ()"
Returns tha text message returned from tha last command
.IP "code ()" 4
.IX Item "code ()"
Returns tha 3\-digit code from tha last command. Y'all KNOW dat shit, muthafucka! If a cold-ass lil command is pending
then tha value 0 is returned
.IP "ok ()" 4
.IX Item "ok ()"
Returns non-zero if tha last code value was pimped outa than zero and
less than 400. This holdz legit fo' most command servers. Right back up in yo muthafuckin ass. Servers
where dis do not hold may override dis method.
.IP "status ()" 4
.IX Item "status ()"
Returns da most thugged-out dope digit of tha current status code. If a cold-ass lil command
is pendin then \f(CW\*(C`CMD_PENDING\*(C'\fR is returned.
.IP "datasend ( \s-1DATA \s0)" 4
.IX Item "datasend ( DATA )"
Send data ta tha remote server, convertin \s-1LF\s0 ta \s-1CRLF.\s0 Any line starting
with a '.' is ghon be prefixed wit another '.'.
\&\f(CW\*(C`DATA\*(C'\fR may be a array or a reference ta a array.
.IP "dataend ()" 4
.IX Item "dataend ()"
End tha bustin  of data ta tha remote server n' shit. This is done by ensurin that
the data already busted endz wit \s-1CRLF\s0 then bustin  '.CRLF' ta end the
transmission. I aint talkin' bout chicken n' gravy biatch. Once dis data has been busted \f(CW\*(C`dataend\*(C'\fR calls \f(CW\*(C`response\*(C'\fR and
returns legit if \f(CW\*(C`response\*(C'\fR returns \s-1CMD_OK.\s0
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
These methodz is not intended ta be called by tha user yo, but used or 
over-ridden by a sub-class of \f(CW\*(C`Net::Cmd\*(C'\fR
.IP "debug_print ( \s-1DIR, TEXT \s0)" 4
.IX Item "debug_print ( DIR, TEXT )"
Print debuggin shiznit. I aint talkin' bout chicken n' gravy biatch. \f(CW\*(C`DIR\*(C'\fR denotes tha direction \fItrue\fR being
data bein busted ta tha server n' shit. Calls \f(CW\*(C`debug_text\*(C'\fR before printin to
\&\s-1STDERR.\s0
.IP "debug_text ( \s-1TEXT \s0)" 4
.IX Item "debug_text ( TEXT )"
This method is called ta print debuggin shiznit. I aint talkin' bout chicken n' gravy biatch. \s-1TEXT\s0 is
the text bein sent. Da method should return tha text ta be printed
.Sp
This is primarily meant fo' tha use of modulez like fuckin \s-1FTP\s0 where passwords
are sent yo, but our phat asses do not wanna display dem up in tha debuggin shiznit.
.IP "command ( \s-1CMD\s0 [, \s-1ARGS, ... \s0])" 4
.IX Item "command ( CMD [, ARGS, ... ])"
Send a cold-ass lil command ta tha command server n' shiznit fo' realz. All arguments a gangbangin' first joined with
a space characta n' \s-1CRLF\s0 be appended, dis strang is then busted ta the
command server.
.Sp
Returns undef upon failure
.IP "unsupported ()" 4
.IX Item "unsupported ()"
Sets tha status code ta 580 n' tha response text ta 'Unsupported command'.
Returns zero.
.IP "response ()" 4
.IX Item "response ()"
Obtain a response from tha server n' shit. Upon success da most thugged-out dope digit
of tha status code is returned. Y'all KNOW dat shit, muthafucka! Upon failure, timeout etc., \fIundef\fR is
returned.
.IP "parse_response ( \s-1TEXT \s0)" 4
.IX Item "parse_response ( TEXT )"
This method is called by \f(CW\*(C`response\*(C'\fR as a method wit one argument. Well shiiiit, it should
return a array of 2 joints, tha 3\-digit status code n' a gangbangin' flag which is true
when dis is part of a multi-line response n' dis line aint tha list.
.IP "getline ()" 4
.IX Item "getline ()"
Retrieve one line, delimited by \s-1CRLF,\s0 from tha remote server n' shit. Returns \fIundef\fR
upon failure.
.Sp
\&\fB\s-1NOTE\s0\fR: If you do use dis method fo' any reason, please remember ta add
some \f(CW\*(C`debug_print\*(C'\fR calls tha fuck into yo' method.
.IP "ungetline ( \s-1TEXT \s0)" 4
.IX Item "ungetline ( TEXT )"
Unget a line of text from tha server.
.IP "rawdatasend ( \s-1DATA \s0)" 4
.IX Item "rawdatasend ( DATA )"
Send data ta tha remote server without struttin any conversions. \f(CW\*(C`DATA\*(C'\fR
is a scalar.
.IP "read_until_dot ()" 4
.IX Item "read_until_dot ()"
Read data from tha remote server until a line consistin of a single '.'.
Any lines startin wit '..' gonna git one of tha '.z removed.
.Sp
Returns a reference ta a list containin tha lines, or \fIundef\fR upon failure.
.IP "tied_fh ()" 4
.IX Item "tied_fh ()"
Returns a gangbangin' filehandle tied ta tha Net::Cmd object.  Afta issuin a
command, you may read from dis filehandle rockin \fIread()\fR or <>.  The
filehandle will return \s-1EOF\s0 when tha final dot is encountered.
Similarly, you may write ta tha filehandle up in order ta bust data to
the server afta issuin a cold-ass lil command dat expects data ta be written.
.Sp
See tha Net::POP3 n' Net::SMTP modulez fo' examplez of all dis bullshit.
.SH "EXPORTS"
.IX Header "EXPORTS"
\&\f(CW\*(C`Net::Cmd\*(C'\fR exports six subroutines, five of these, \f(CW\*(C`CMD_INFO\*(C'\fR, \f(CW\*(C`CMD_OK\*(C'\fR,
\&\f(CW\*(C`CMD_MORE\*(C'\fR, \f(CW\*(C`CMD_REJECT\*(C'\fR n' \f(CW\*(C`CMD_ERROR\*(C'\fR, correspond ta possible thangs up in dis biatch
of \f(CW\*(C`response\*(C'\fR n' \f(CW\*(C`status\*(C'\fR. Da sixth is \f(CW\*(C`CMD_PENDING\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@pobox.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1995\-2006 Graham Barr fo' realz. All muthafuckin rights reserved.
This program is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
