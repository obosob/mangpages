.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Digest 3"
.TH Digest 3 "2011-10-02" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Digest \- Modulez dat calculate message digests
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  $md5  = Digest\->new("MD5");
\&  $sha1 = Digest\->new("SHA\-1");
\&  $sha256 = Digest\->new("SHA\-256");
\&  $sha384 = Digest\->new("SHA\-384");
\&  $sha512 = Digest\->new("SHA\-512");
\&
\&  $hmac = Digest\->HMAC_MD5($key);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`Digest::\*(C'\fR modulez calculate digests, also called \*(L"fingerprints\*(R"
or \*(L"hashes\*(R", of some data, called a message.  Da digest is (usually)
some small/fixed size string.  Da actual size of tha digest depend of
the algorithm used. Y'all KNOW dat shit, muthafucka!  Da message is simply a sequence of arbitrary
bytes or bits.
.PP
An blingin property of tha digest algorithms is dat tha digest is
\&\fIlikely\fR ta chizzle if tha message chizzle up in some way.  Another
property is dat digest functions is one-way functions, dat is it
should be \fIhard\fR ta find a message dat correspond ta some given
digest.  Algorithms differ up in how tha fuck \*(L"likely\*(R" n' how tha fuck \*(L"hard\*(R", as well as
how efficient they is ta compute.
.PP
Note dat tha propertizzlez of tha algorithms chizzle over time, as the
algorithms is analyzed n' machines grow fasta n' shit.  If yo' application
for instizzle dependz on it bein \*(L"impossible\*(R" ta generate tha same
digest fo' a gangbangin' finger-lickin' different message it is wise ta make it easy as fuck  ta plug in
stronger algorithms as tha one used grow weaker n' shit.  Usin tha intercourse
documented here should make it easy as fuck  ta chizzle algorithms later.
.PP
All \f(CW\*(C`Digest::\*(C'\fR modulez provide tha same programmin intercourse.  A
functionizzle intercourse fo' simple use, as well as a object oriented
interface dat can handle lyrics of arbitrary length n' which can
read filez directly.
.PP
Da digest can be served up in three formats:
.IP "\fIbinary\fR" 8
.IX Item "binary"
This is da most thugged-out compact form yo, but it aint well suited fo' printing
or embeddin up in places dat can't handle arbitrary data.
.IP "\fIhex\fR" 8
.IX Item "hex"
A twice as long strang of lowercase hexadecimal digits.
.IP "\fIbase64\fR" 8
.IX Item "base64"
A strang of portable printable characters.  This is tha base64 encoded
representation of tha digest wit any trailin paddin removed. Y'all KNOW dat shit, muthafucka!  The
strin is ghon be bout 30% longer than tha binary version.
MIME::Base64  drops some lyrics ta you mo' bout dis encoding.
.PP
Da functionizzle intercourse is simply importable functions wit tha same
name as tha algorithm.  Da functions take tha message as argument and
return tha digest.  Example:
.PP
.Vb 2
\&  use Digest::MD5 qw(md5);
\&  $digest = md5($message);
.Ve
.PP
There is also versionz of tha functions wit \*(L"_hex\*(R" or \*(L"_base64\*(R"
appended ta tha name, which returns tha digest up in tha indicated form.
.SH "OO INTERFACE"
.IX Header "OO INTERFACE"
Da followin methodz is available fo' all \f(CW\*(C`Digest::\*(C'\fR modules:
.ie n .IP "$ctx = Digest\->\s-1XXX\s0($arg,...)" 4
.el .IP "\f(CW$ctx\fR = Digest\->\s-1XXX\s0($arg,...)" 4
.IX Item "$ctx = Digest->XXX($arg,...)"
.PD 0
.ie n .IP "$ctx = Digest\->new(\s-1XXX\s0 => $arg,...)" 4
.el .IP "\f(CW$ctx\fR = Digest\->new(\s-1XXX\s0 => \f(CW$arg\fR,...)" 4
.IX Item "$ctx = Digest->new(XXX => $arg,...)"
.ie n .IP "$ctx = Digest::XXX\->new($arg,...)" 4
.el .IP "\f(CW$ctx\fR = Digest::XXX\->new($arg,...)" 4
.IX Item "$ctx = Digest::XXX->new($arg,...)"
.PD
Da constructor returns some object dat encapsulate tha state of the
message-digest algorithm.  Yo ass can add data ta tha object n' finally
ask fo' tha digest.  Da \*(L"\s-1XXX\*(R"\s0 should of course be replaced by tha proper
name of tha digest algorithm you wanna use.
.Sp
Da two first forms is simply syntactic sugar which automatically
load tha right module on first use.  Da second form allow you ta use
algorithm names which gotz nuff lettas which is not legal perl
identifiers, e.g. \*(L"\s-1SHA\-1\*(R". \s0 If no implementation fo' tha given algorithm
can be found, then a exception is raised.
.Sp
If \fInew()\fR is called as a instizzle method (i.e. \f(CW$ctx\fR\->new) it will just
reset tha state tha object ta tha state of a newly pimped object.  No
new object is pimped up in dis case, n' tha return value is the
reference ta tha object (i.e. \f(CW$ctx\fR).
.ie n .IP "$other_ctx = $ctx\->clone" 4
.el .IP "\f(CW$other_ctx\fR = \f(CW$ctx\fR\->clone" 4
.IX Item "$other_ctx = $ctx->clone"
Da clone method creates a cold-ass lil copy of tha digest state object n' returns
a reference ta tha copy.
.ie n .IP "$ctx\->reset" 4
.el .IP "\f(CW$ctx\fR\->reset" 4
.IX Item "$ctx->reset"
This is just a alias fo' \f(CW$ctx\fR\->new.
.ie n .IP "$ctx\->add( $data )" 4
.el .IP "\f(CW$ctx\fR\->add( \f(CW$data\fR )" 4
.IX Item "$ctx->add( $data )"
.PD 0
.ie n .IP "$ctx\->add( $chunk1, $chunk2, ... )" 4
.el .IP "\f(CW$ctx\fR\->add( \f(CW$chunk1\fR, \f(CW$chunk2\fR, ... )" 4
.IX Item "$ctx->add( $chunk1, $chunk2, ... )"
.PD
Da strang value of tha \f(CW$data\fR provided as argument be appended ta the
message we calculate tha digest for. Shiiit, dis aint no joke.  Da return value is tha \f(CW$ctx\fR
object itself.
.Sp
If mo' arguments is provided then they is all appended ta the
message, thus all these lines gonna git tha same effect on tha state
of tha \f(CW$ctx\fR object:
.Sp
.Vb 4
\&  $ctx\->add("a"); $ctx\->add("b"); $ctx\->add("c");
\&  $ctx\->add("a")\->add("b")\->add("c");
\&  $ctx\->add("a", "b", "c");
\&  $ctx\->add("abc");
.Ve
.Sp
Most algorithms is only defined fo' stringz of bytes n' dis method
might therefore croak if tha provided arguments contain chars with
ordinal number above 255.
.ie n .IP "$ctx\->addfile( $io_handle )" 4
.el .IP "\f(CW$ctx\fR\->addfile( \f(CW$io_handle\fR )" 4
.IX Item "$ctx->addfile( $io_handle )"
Da \f(CW$io_handle\fR is read until \s-1EOF\s0 n' tha content be appended ta the
message we calculate tha digest for. Shiiit, dis aint no joke.  Da return value is tha \f(CW$ctx\fR
object itself.
.Sp
Da \fIaddfile()\fR method will \fIcroak()\fR if it fails readin data fo' some
reason. I aint talkin' bout chicken n' gravy biatch.  If it croaks it is unpredictable what tha fuck tha state of tha \f(CW$ctx\fR
object is ghon be in. I aint talkin' bout chicken n' gravy biatch. Da \fIaddfile()\fR method might done been able ta read
the file partially before it failed. Y'all KNOW dat shit, muthafucka!  It be probably wise ta discard
or reset tha \f(CW$ctx\fR object if dis occurs.
.Sp
In most cases you wanna make shizzle dat tha \f(CW$io_handle\fR is in
\&\*(L"binmode\*(R" before you pass it as argument ta tha \fIaddfile()\fR method.
.ie n .IP "$ctx\->add_bits( $data, $nbits )" 4
.el .IP "\f(CW$ctx\fR\->add_bits( \f(CW$data\fR, \f(CW$nbits\fR )" 4
.IX Item "$ctx->add_bits( $data, $nbits )"
.PD 0
.ie n .IP "$ctx\->add_bits( $bitstrin )" 4
.el .IP "\f(CW$ctx\fR\->add_bits( \f(CW$bitstring\fR )" 4
.IX Item "$ctx->add_bits( $bitstrin )"
.PD
Da \fIadd_bits()\fR method be a alternatizzle ta \fIadd()\fR dat allow partial
bytes ta be appended ta tha message.  Most playas should just ignore
this method as partial bytes is straight-up unlikely ta be of any practical
use.
.Sp
Da two argument form of \fIadd_bits()\fR will add tha straight-up original gangsta \f(CW$nbits\fR bits
from \f(CW$data\fR.  For tha last potentially partial byte only tha high order
\&\f(CW\*(C`$nbits % 8\*(C'\fR bits is used. Y'all KNOW dat shit, muthafucka!  If \f(CW$nbits\fR is pimped outa than \f(CW\*(C`length($data) * 8\*(C'\fR, then dis method would do tha same as \f(CW\*(C`$ctx\->add($data)\*(C'\fR.
.Sp
Da one argument form of \fIadd_bits()\fR takes a \f(CW$bitstring\fR of \*(L"1\*(R" n' \*(L"0\*(R"
chars as argument.  It aint nuthin but a gangbangin' finger-lickin' dirty-ass shorthand fo' \f(CW\*(C`$ctx\->add_bits(pack("B*",
$bitstring), length($bitstring))\*(C'\fR.
.Sp
Da return value is tha \f(CW$ctx\fR object itself.
.Sp
This example shows two calls dat should have tha same effect:
.Sp
.Vb 2
\&   $ctx\->add_bits("111100001010");
\&   $ctx\->add_bits("\exF0\exA0", 12);
.Ve
.Sp
Most digest algorithms is byte based n' fo' these it aint possible
to add bits dat is not a multiple of 8, n' tha \fIadd_bits()\fR method
will croak if you try.
.ie n .IP "$ctx\->digest" 4
.el .IP "\f(CW$ctx\fR\->digest" 4
.IX Item "$ctx->digest"
Return tha binary digest fo' tha message.
.Sp
Note dat tha \f(CW\*(C`digest\*(C'\fR operation is effectively a thugged-out destructive,
read-once operation. I aint talkin' bout chicken n' gravy biatch. Once it has been performed, tha \f(CW$ctx\fR object is
automatically \f(CW\*(C`reset\*(C'\fR n' can be used ta calculate another digest
value.  Call \f(CW$ctx\fR\->clone\->digest if you wanna calculate tha digest
without resettin tha digest state.
.ie n .IP "$ctx\->hexdigest" 4
.el .IP "\f(CW$ctx\fR\->hexdigest" 4
.IX Item "$ctx->hexdigest"
Same as \f(CW$ctx\fR\->digest yo, but will return tha digest up in hexadecimal form.
.ie n .IP "$ctx\->b64digest" 4
.el .IP "\f(CW$ctx\fR\->b64digest" 4
.IX Item "$ctx->b64digest"
Same as \f(CW$ctx\fR\->digest yo, but will return tha digest as a funky-ass base64 encoded
string.
.SH "Digest speed"
.IX Header "Digest speed"
This table should give some indication on tha relatizzle speed of
different algorithms.  It be sorted by throughput based on a funky-ass benchmark
done wit of some implementationz of dis \s-1API:\s0
.PP
.Vb 1
\& Algorithm      Size    Implementation                  MB/s
\&
\& MD4            128     Digest::MD4 v1.3               165.0
\& MD5            128     Digest::MD5 v2.33               98.8
\& SHA\-256        256     Digest::SHA2 v1.1.0             66.7
\& SHA\-1          160     Digest::SHA v4.3.1              58.9
\& SHA\-1          160     Digest::SHA1 v2.10              48.8
\& SHA\-256        256     Digest::SHA v4.3.1              41.3
\& Haval\-256      256     Digest::Haval256 v1.0.4         39.8
\& SHA\-384        384     Digest::SHA2 v1.1.0             19.6
\& SHA\-512        512     Digest::SHA2 v1.1.0             19.3
\& SHA\-384        384     Digest::SHA v4.3.1              19.2
\& SHA\-512        512     Digest::SHA v4.3.1              19.2
\& Whirlpool      512     Digest::Whirlpool v1.0.2        13.0
\& MD2            128     Digest::MD2 v2.03                9.5
\&
\& Adler\-32        32     Digest::Adler32 v0.03            1.3
\& CRC\-16          16     Digest::CRC v0.05                1.1
\& CRC\-32          32     Digest::CRC v0.05                1.1
\& MD5            128     Digest::Perl::MD5 v1.5           1.0
\& CRC\-CCITT       16     Digest::CRC v0.05                0.8
.Ve
.PP
These numbers was  bigged up  Apr 2004 wit ActivePerl\-5.8.3 hustlin
under Linux on a P4 2.8 GHz \s-1CPU. \s0 Da last 5 entries differ by being
pure perl implementationz of tha algorithms, which explains why they
are so slow.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Digest::Adler32, Digest::CRC, Digest::Haval256,
Digest::HMAC, Digest::MD2, Digest::MD4, Digest::MD5,
Digest::SHA, Digest::SHA1, Digest::SHA2, Digest::Whirlpool
.PP
New digest implementations should consider subclassin from Digest::base.
.PP
MIME::Base64
.PP
http://en.wikipedia.org/wiki/Cryptographic_hash_function
.SH "AUTHOR"
.IX Header "AUTHOR"
Gisle Aas <gisle@aas.no>
.PP
Da \f(CW\*(C`Digest::\*(C'\fR intercourse is based on tha intercourse originally
developed by Neil Winton fo' his \f(CW\*(C`MD5\*(C'\fR module.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.PP
.Vb 2
\&    Copyright 1998\-2006 Gisle Aas.
\&    Copyright 1995,1996 Neil Winton.
.Ve
