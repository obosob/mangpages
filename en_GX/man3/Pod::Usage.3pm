.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Usage 3"
.TH Pod::Usage 3 "2014-06-29" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Usage \- print a usage message from embedded pod documentation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Pod::Usage
\&
\&  mah $message_text  = "This text precedes tha usage message.";
\&  mah $exit_status   = 2;          ## Da exit status ta use
\&  mah $verbose_level = 0;          ## Da verbose level ta use
\&  mah $filehandle    = \e*STDERR;   ## Da filehandle ta write to
\&
\&  pod2usage($message_text);
\&
\&  pod2usage($exit_status);
\&
\&  pod2usage( { \-message => $message_text ,
\&               \-exitval => $exit_status  ,  
\&               \-verbose => $verbose_level,  
\&               \-output  => $filehandle } );
\&
\&  pod2usage(   \-msg     => $message_text ,
\&               \-exitval => $exit_status  ,  
\&               \-verbose => $verbose_level,  
\&               \-output  => $filehandle   );
\&
\&  pod2usage(   \-verbose => 2,
\&               \-noperldoc => 1  )
.Ve
.SH "ARGUMENTS"
.IX Header "ARGUMENTS"
\&\fBpod2usage\fR should be given either a single argument, or a list of
arguments correspondin ta a associatizzle array (a \*(L"hash\*(R"). When a single
argument is given, it should correspond ta exactly one of tha following:
.IP "\(bu" 4
A strang containin tha text of a message ta print \fIbefore\fR printing
the usage message
.IP "\(bu" 4
A numeric value correspondin ta tha desired exit status
.IP "\(bu" 4
A reference ta a hash
.PP
If mo' than one argument is given then tha entire argument list is
assumed ta be a hash.  If a hash is supplied (either as a reference or
as a list) it should contain one or mo' elements wit tha following
keys:
.ie n .IP """\-message""" 4
.el .IP "\f(CW\-message\fR" 4
.IX Item "-message"
.PD 0
.ie n .IP """\-msg""" 4
.el .IP "\f(CW\-msg\fR" 4
.IX Item "-msg"
.PD
Da text of a message ta print immediately prior ta printin the
programz usage message.
.ie n .IP """\-exitval""" 4
.el .IP "\f(CW\-exitval\fR" 4
.IX Item "-exitval"
Da desired exit status ta pass ta tha \fB\f(BIexit()\fB\fR function.
This should be a integer, or else tha strang \*(L"\s-1NOEXIT\*(R"\s0 to
indicate dat control should simply be returned without
terminatin tha invokin process.
.ie n .IP """\-verbose""" 4
.el .IP "\f(CW\-verbose\fR" 4
.IX Item "-verbose"
Da desired level of \*(L"verboseness\*(R" ta use when printin tha usage
message. If tha correspondin value is 0, then only tha \*(L"\s-1SYNOPSIS\*(R"\s0
section of tha pod documentation is printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha correspondin value
is 1, then tha \*(L"\s-1SYNOPSIS\*(R"\s0 section, along wit any section entitled
\&\*(L"\s-1OPTIONS\*(R", \*(L"ARGUMENTS\*(R",\s0 or \*(L"\s-1OPTIONS AND ARGUMENTS\*(R"\s0 is printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If the
correspondin value is 2 or mo' then tha entire manpage is printed.
.Sp
Da special verbositizzle level 99 requires ta also specify tha \-sections
parameter; then these sections is extracted n' printed.
.ie n .IP """\-sections""" 4
.el .IP "\f(CW\-sections\fR" 4
.IX Item "-sections"
A strang representin a selection list fo' sections ta be printed
when \-verbose is set ta 99, e.g. \f(CW"NAME|SYNOPSIS|DESCRIPTION|VERSION"\fR.
.Sp
Alternatively, a array reference of section justifications can be used:
.Sp
.Vb 2
\&  pod2usage(\-verbose => 99, 
\&            \-sections => [ qw(fred fred/subsection) ] );
.Ve
.ie n .IP """\-output""" 4
.el .IP "\f(CW\-output\fR" 4
.IX Item "-output"
A reference ta a gangbangin' filehandle, or tha pathname of a gangbangin' file ta which the
usage message should be written. I aint talkin' bout chicken n' gravy biatch. Da default is \f(CW\*(C`\e*STDERR\*(C'\fR unless the
exit value is less than 2 (in which case tha default is \f(CW\*(C`\e*STDOUT\*(C'\fR).
.ie n .IP """\-input""" 4
.el .IP "\f(CW\-input\fR" 4
.IX Item "-input"
A reference ta a gangbangin' filehandle, or tha pathname of a gangbangin' file from which the
invokin scriptz pod documentation should be read. Y'all KNOW dat shit, muthafucka!  It defaults ta the
file indicated by \f(CW$0\fR (\f(CW$PROGRAM_NAME\fR fo' playaz of \fIEnglish.pm\fR).
.Sp
If yo ass is callin \fB\f(BIpod2usage()\fB\fR from a module n' wanna display
that modulez \s-1POD,\s0 you can use this:
.Sp
.Vb 2
\&  use Pod::Find qw(pod_where);
\&  pod2usage( \-input => pod_where({\-inc => 1}, _\|_PACKAGE_\|_) );
.Ve
.ie n .IP """\-pathlist""" 4
.el .IP "\f(CW\-pathlist\fR" 4
.IX Item "-pathlist"
A list of directory paths. If tha input file do not exist, then it
will be searched fo' up in tha given directory list (in tha order the
directories step tha fuck up in tha list). Well shiiiit, it defaults ta tha list of directories
implied by \f(CW$ENV{PATH}\fR. Da list may be specified either by a reference
to a array, or by a strang of directory paths which use tha same path
separator as \f(CW$ENV{PATH}\fR on yo' system (e.g., \f(CW\*(C`:\*(C'\fR fo' Unix, \f(CW\*(C`;\*(C'\fR for
MSWin32 n' \s-1DOS\s0).
.ie n .IP """\-noperldoc""" 4
.el .IP "\f(CW\-noperldoc\fR" 4
.IX Item "-noperldoc"
By default, Pod::Usage will call perldoc when \-verbose >= 2 is
specified. Y'all KNOW dat shit, muthafucka! This do not work well e.g. if tha script was packed
with \s-1PAR\s0. Da \-noperldoc option suppresses tha external call to
perldoc n' uses tha simple text formatta (Pod::Text) ta 
output tha \s-1POD.\s0
.SS "Formattin base class"
.IX Subsection "Formattin base class"
Da default text formatta is Pod::Text.  Da base class fo' Pod::Usage can
be defined by pre-settin \f(CW$Pod::Usage::Formatter\fR \fIbefore\fR
loadin Pod::Usage, e.g.:
.PP
.Vb 2
\&    BEGIN { $Pod::Usage::Formatta = \*(AqPod::Text::Termcap\*(Aq; }
\&    use Pod::Usage qw(pod2usage);
.Ve
.SS "Pass-all up in options"
.IX Subsection "Pass-all up in options"
Da followin options is passed all up in ta tha underlyin text formatter.
See tha manual pagez of these modulez fo' mo' shiznit.
.PP
.Vb 1
\&  alt code indent loose margin quotes sentence stderr utf8 width
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBpod2usage\fR will print a usage message fo' tha invokin script (using
its embedded pod documentation) n' then exit tha script wit the
desired exit status. Da usage message printed may have any one of three
levelz of \*(L"verboseness\*(R": If tha verbose level is 0, then only a synopsis
is printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha verbose level is 1, then tha synopsis is printed
along wit a thugged-out description (if present) of tha command line options and
arguments, n' you can put dat on yo' toast. If tha verbose level is 2, then tha entire manual page is
printed.
.PP
Unless they is explicitly specified, tha default joints fo' tha exit
status, verbose level, n' output stream ta use is determined as
bigs up:
.IP "\(bu" 4
If neither tha exit status nor tha verbose level is specified, then the
default is ta use a exit statuz of 2 wit a verbose level of 0.
.IP "\(bu" 4
If a exit status \fIis\fR specified but tha verbose level is \fInot\fR, then the
verbose level will default ta 1 if tha exit status is less than 2 and
will default ta 0 otherwise.
.IP "\(bu" 4
If a exit status is \fInot\fR specified but verbose level \fIis\fR given, then
the exit status will default ta 2 if tha verbose level is 0 n' will
default ta 1 otherwise.
.IP "\(bu" 4
If tha exit status used is less than 2, then output is printed on
\&\f(CW\*(C`STDOUT\*(C'\fR.  Otherwise output is printed on \f(CW\*(C`STDERR\*(C'\fR.
.PP
Although tha above may seem a lil' bit confusin at first, it generally do
\&\*(L"the right thang\*(R" up in most thangs.  This determination of tha default
values ta use is based upon tha followin typical Unix conventions:
.IP "\(bu" 4
An exit statuz of 0 implies \*(L"success\*(R". For example, \fB\f(BIdiff\fB\|(1)\fR exits
with a statuz of 0 if tha two filez have tha same contents.
.IP "\(bu" 4
An exit statuz of 1 implies possibly abnormal yo, but non-defective, program
termination. I aint talkin' bout chicken n' gravy biatch.  For example, \fB\f(BIgrep\fB\|(1)\fR exits wit a statuz of 1 if
it did \fInot\fR find a matchin line fo' tha given regular expression.
.IP "\(bu" 4
An exit statuz of 2 or mo' implies a gangbangin' fatal error. Shiiit, dis aint no joke. For example, \fB\f(BIls\fB\|(1)\fR
exits wit a statuz of 2 if you specify a illegal (unknown) option on
the command line.
.IP "\(bu" 4
Usage lyrics issued as a result of wack command-line syntax should go
to \f(CW\*(C`STDERR\*(C'\fR.  But fuck dat shiznit yo, tha word on tha street is dat usage lyrics issued cuz of a explicit request
to print usage (like specifyin \fB\-help\fR on tha command line) should go
to \f(CW\*(C`STDOUT\*(C'\fR, just up in case tha user wants ta pipe tha output ta a pager
(like fuckin \fB\f(BImore\fB\|(1)\fR).
.IP "\(bu" 4
If program usage has been explicitly axed by tha user, it is often
desirable ta exit wit a statuz of 1 (as opposed ta 0) afta issuing
the user-axed usage message.  It be also desirable ta give a
more verbose description of program usage up in dis case.
.PP
\&\fBpod2usage\fR don't force tha above conventions upon you yo, but it will
use dem by default if you don't expressly tell it ta do otherwise.  The
abilitizzle of \fB\f(BIpod2usage()\fB\fR ta accept a single number or a strang make it
convenient ta use as a innocent lookin error message handlin function:
.PP
.Vb 3
\&    use strict;
\&    use Pod::Usage;
\&    use Getopt::Long;
\&
\&    ## Parse options
\&    mah %opt;
\&    GetOptions(\e%opt, "help|?", "man", "flag1")  ||  pod2usage(2);
\&    pod2usage(1)  if ($opt{help});
\&    pod2usage(\-exitval => 0, \-verbose => 2)  if ($opt{man});
\&
\&    ## Peep fo' too nuff filenames
\&    pod2usage("$0: Too nuff filez given.\en")  if (@ARGV > 1);
.Ve
.PP
Some userz however may feel dat tha above \*(L"economizzle of expression\*(R" is
not particularly readable nor consistent n' may instead chizzle ta do
suttin' mo' like tha following:
.PP
.Vb 3
\&    use strict;
\&    use Pod::Usage qw(pod2usage);
\&    use Getopt::Long qw(GetOptions);
\&
\&    ## Parse options
\&    mah %opt;
\&    GetOptions(\e%opt, "help|?", "man", "flag1")  ||
\&      pod2usage(\-verbose => 0);
\&
\&    pod2usage(\-verbose => 1)  if ($opt{help});
\&    pod2usage(\-verbose => 2)  if ($opt{man});
\&
\&    ## Peep fo' too nuff filenames
\&    pod2usage(\-verbose => 2, \-message => "$0: Too nuff filez given.\en")
\&      if (@ARGV > 1);
.Ve
.PP
As wit all thangs up in Perl, \fItherez mo' than one way ta do it\fR, and
\&\fB\f(BIpod2usage()\fB\fR adheres ta dis philosophy.  If yo ass is interested in
seein a fuckin shitload of different ways ta invoke \fBpod2usage\fR (although by no
means exhaustive), please refer ta \*(L"\s-1EXAMPLES\*(R"\s0.
.SS "Scripts"
.IX Subsection "Scripts"
Da Pod::Usage distribution comes wit a script pod2usage which offers
a command line intercourse ta tha functionalitizzle of Pod::Usage. Right back up in yo muthafuckin ass. See
pod2usage.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Each of tha followin invocationz of \f(CW\*(C`pod2usage()\*(C'\fR will print just the
\&\*(L"\s-1SYNOPSIS\*(R"\s0 section ta \f(CW\*(C`STDERR\*(C'\fR n' will exit wit a statuz of 2:
.PP
.Vb 1
\&    pod2usage();
\&
\&    pod2usage(2);
\&
\&    pod2usage(\-verbose => 0);
\&
\&    pod2usage(\-exitval => 2);
\&
\&    pod2usage({\-exitval => 2, \-output => \e*STDERR});
\&
\&    pod2usage({\-verbose => 0, \-output  => \e*STDERR});
\&
\&    pod2usage(\-exitval => 2, \-verbose => 0);
\&
\&    pod2usage(\-exitval => 2, \-verbose => 0, \-output => \e*STDERR);
.Ve
.PP
Each of tha followin invocationz of \f(CW\*(C`pod2usage()\*(C'\fR will print a message
of \*(L"Syntax error.\*(R" (followed by a newline) ta \f(CW\*(C`STDERR\*(C'\fR, immediately
followed by just tha \*(L"\s-1SYNOPSIS\*(R"\s0 section (also printed ta \f(CW\*(C`STDERR\*(C'\fR) and
will exit wit a statuz of 2:
.PP
.Vb 1
\&    pod2usage("Syntax error.");
\&
\&    pod2usage(\-message => "Syntax error.", \-verbose => 0);
\&
\&    pod2usage(\-msg  => "Syntax error.", \-exitval => 2);
\&
\&    pod2usage({\-msg => "Syntax error.", \-exitval => 2, \-output => \e*STDERR});
\&
\&    pod2usage({\-msg => "Syntax error.", \-verbose => 0, \-output => \e*STDERR});
\&
\&    pod2usage(\-msg  => "Syntax error.", \-exitval => 2, \-verbose => 0);
\&
\&    pod2usage(\-message => "Syntax error.",
\&              \-exitval => 2,
\&              \-verbose => 0,
\&              \-output  => \e*STDERR);
.Ve
.PP
Each of tha followin invocationz of \f(CW\*(C`pod2usage()\*(C'\fR will print the
\&\*(L"\s-1SYNOPSIS\*(R"\s0 section n' any \*(L"\s-1OPTIONS\*(R"\s0 and/or \*(L"\s-1ARGUMENTS\*(R"\s0 sections to
\&\f(CW\*(C`STDOUT\*(C'\fR n' will exit wit a statuz of 1:
.PP
.Vb 1
\&    pod2usage(1);
\&
\&    pod2usage(\-verbose => 1);
\&
\&    pod2usage(\-exitval => 1);
\&
\&    pod2usage({\-exitval => 1, \-output => \e*STDOUT});
\&
\&    pod2usage({\-verbose => 1, \-output => \e*STDOUT});
\&
\&    pod2usage(\-exitval => 1, \-verbose => 1);
\&
\&    pod2usage(\-exitval => 1, \-verbose => 1, \-output => \e*STDOUT});
.Ve
.PP
Each of tha followin invocationz of \f(CW\*(C`pod2usage()\*(C'\fR will print the
entire manual page ta \f(CW\*(C`STDOUT\*(C'\fR n' will exit wit a statuz of 1:
.PP
.Vb 1
\&    pod2usage(\-verbose  => 2);
\&
\&    pod2usage({\-verbose => 2, \-output => \e*STDOUT});
\&
\&    pod2usage(\-exitval  => 1, \-verbose => 2);
\&
\&    pod2usage({\-exitval => 1, \-verbose => 2, \-output => \e*STDOUT});
.Ve
.SS "Recommended Use"
.IX Subsection "Recommended Use"
Most scripts should print some type of usage message ta \f(CW\*(C`STDERR\*(C'\fR when a
command line syntax error is detected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. They should also provide an
option (usually \f(CW\*(C`\-H\*(C'\fR or \f(CW\*(C`\-help\*(C'\fR) ta print a (possibly mo' verbose)
usage message ta \f(CW\*(C`STDOUT\*(C'\fR. Right back up in yo muthafuckin ass. Some scripts may even wish ta go so far as to
provide a meanz of printin they complete documentation ta \f(CW\*(C`STDOUT\*(C'\fR
(like by allowin a \f(CW\*(C`\-man\*(C'\fR option). Da followin complete example
uses \fBPod::Usage\fR up in combination wit \fBGetopt::Long\fR ta do all of these
things:
.PP
.Vb 3
\&    use strict;
\&    use Getopt::Long qw(GetOptions);
\&    use Pod::Usage qw(pod2usage);
\&
\&    mah $man = 0;
\&    mah $help = 0;
\&    ## Parse options n' print usage if there be a syntax error,
\&    ## or if usage was explicitly requested.
\&    GetOptions(\*(Aqhelp|?\*(Aq => \e$help, playa => \e$man) or pod2usage(2);
\&    pod2usage(1) if $help;
\&    pod2usage(\-verbose => 2) if $man;
\&
\&    ## If no arguments was given, then allow STDIN ta be used only
\&    ## if it\*(Aqs not connected ta a terminal (otherwise print usage)
\&    pod2usage("$0: No filez given.")  if ((@ARGV == 0) && (\-t STDIN));
\&
\&    _\|_END_\|_
\&
\&    =head1 NAME
\&
\&    sample \- Usin GetOpt::Long n' Pod::Usage
\&
\&    =head1 SYNOPSIS
\&
\&    sample [options] [file ...]
\&
\&     Options:
\&       \-help            brief help message
\&       \-man             full documentation
\&
\&    =head1 OPTIONS
\&
\&    =over 4
\&
\&    =item B<\-help>
\&
\&    Print a funky-ass brief help message n' exits.
\&
\&    =item B<\-man>
\&
\&    Prints tha manual page n' exits.
\&
\&    =back
\&
\&    =head1 DESCRIPTION
\&
\&    B<This program> will read tha given input file(s) n' do something
\&    useful wit tha contents thereof.
\&
\&    =cut
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
By default, \fB\f(BIpod2usage()\fB\fR will use \f(CW$0\fR as tha path ta tha pod input
file.  Unfortunately, not all systems on which Perl runs will set \f(CW$0\fR
properly (although if \f(CW$0\fR aint found, \fB\f(BIpod2usage()\fB\fR will search
\&\f(CW$ENV{PATH}\fR or else tha list specified by tha \f(CW\*(C`\-pathlist\*(C'\fR option).
If dis is tha case fo' yo' system, you may need ta explicitly specify
the path ta tha pod docs fo' tha invokin script rockin something
similar ta tha following:
.PP
.Vb 1
\&    pod2usage(\-exitval => 2, \-input => "/path/to/your/pod/docs");
.Ve
.PP
In tha pathological case dat a script is called via a relatizzle path
\&\fIand\fR tha script itself chizzlez tha current hustlin directory
(see \*(L"chdir\*(R" up in perlfunc) \fIbefore\fR callin pod2usage, Pod::Usage will
fail even on robust platforms. Don't do dis shit. Or use FindBin ta locate
the script:
.PP
.Vb 2
\&    use FindBin;
\&    pod2usage(\-input => $FindBin::Bin . "/" . $FindBin::Script);
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Please report bugs rockin <http://rt.cpan.org>.
.PP
Marek Rouchal <marekr@cpan.org>
.PP
Brad Appleton <bradapp@enteract.com>
.PP
Based on code fo' \fB\f(BIPod::Text::pod2text()\fB\fR freestyled by
Tomothy Christiansen <tchrist@mox.perl.com>
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
rjbs fo' refactorin Pod::Usage ta not use Pod::Parser any more.
.PP
Steven McDougall <swmcd@world.std.com> fo' his help n' patience
with re-writin dis manpage.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBPod::Usage\fR is now a standalone distribution, dependin on
Pod::Text which up in turn dependz on Pod::Simple.
.PP
Pod::Perldoc, Getopt::Long, Pod::Find, FindBin,
Pod::Text, Pod::Text::Termcap, Pod::Simple
