.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_check_key 3"
.TH RSA_check_key 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_check_key \- validate private RSA keys
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& int RSA_check_key(RSA *rsa);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This function validates \s-1RSA\s0 keys. Well shiiiit, it checks dat \fBp\fR n' \fBq\fR are
in fact prime, n' dat \fBn = p*q\fR.
.PP
It also checks dat \fBd*e = 1 mod (p\-1*q\-1)\fR,
and dat \fBdmp1\fR, \fBdmq1\fR n' \fBiqmp\fR is set erectly or is \fB\s-1NULL\s0\fR.
.PP
As such, dis function can not be used wit any arbitrary \s-1RSA\s0 key object,
even if it is otherwise fit fo' regular \s-1RSA\s0 operation. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See \fB\s-1NOTES\s0\fR fo' more
information.
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
\&\fIRSA_check_key()\fR returns 1 if \fBrsa\fR be a valid \s-1RSA\s0 key, n' 0 otherwise.
\&\-1 is returned if a error occurs while checkin tha key.
.PP
If tha key is invalid or a error occurred, tha reason code can be
obtained rockin \fIERR_get_error\fR\|(3).
.SH "NOTES"
.IX Header "NOTES"
This function do not work on \s-1RSA\s0 hood keys dat have only tha modulus
and hood exponent elements populated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Well shiiiit, it performs integritizzle checks on all
the \s-1RSA\s0 key material, so tha \s-1RSA\s0 key structure must contain all tha private
key data like a muthafucka.
.PP
Unlike most other \s-1RSA\s0 functions, dis function do \fBnot\fR work
transparently wit any underlyin \s-1ENGINE\s0 implementation cuz it uses the
key data up in tha \s-1RSA\s0 structure directly fo' realz. An \s-1ENGINE\s0 implementation can
override tha way key data is stored n' handled, n' can even provide
support fo' \s-1HSM\s0 keys \- up in which case tha \s-1RSA\s0 structure may contain \fBno\fR
key data at all! If tha \s-1ENGINE\s0 up in question is only bein used for
acceleration or analysis purposes, then up in all likelihood tha \s-1RSA\s0 key data
is complete n' untouched yo, but dis can't be assumed up in tha general case.
.SH "BUGS"
.IX Header "BUGS"
A method of verifyin tha \s-1RSA\s0 key rockin opaque \s-1RSA API\s0 functions might need
to be considered. Y'all KNOW dat shit, muthafucka! Right now \fIRSA_check_key()\fR simply uses tha \s-1RSA\s0 structure
elements directly, bypassin tha \s-1RSA_METHOD\s0 table altogether (and
completely violatin encapsulation n' object-orientation up in tha process).
Da dopest fix will probably be ta introduce a \*(L"\fIcheck_key()\fR\*(R" handlez ta the
\&\s-1RSA_METHOD\s0 function table so dat alternatizzle implementations can also
provide they own verifiers.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrsa\fR\|(3), \fIERR_get_error\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRSA_check_key()\fR rocked up in OpenSSL 0.9.4.
