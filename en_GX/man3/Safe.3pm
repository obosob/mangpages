.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Safe 3pm"
.TH Safe 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Safe \- Compile n' execute code up in restricted compartments
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Safe;
\&
\&  $compartment = freshly smoked up Safe;
\&
\&  $compartment\->permit(qw(time sort :browse));
\&
\&  $result = $compartment\->reval($unsafe_code);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da Safe extension module allows tha creation of compartments
in which perl code can be evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Each compartment has
.IP "a freshly smoked up namespace" 8
.IX Item "a freshly smoked up namespace"
Da \*(L"root\*(R" of tha namespace (i.e. \*(L"main::\*(R") is chizzled ta a
different package n' code evaluated up in tha compartment cannot
refer ta variablez outside dis namespace, even wit run-time
glob lookups n' other tricks.
.Sp
Code which is compiled outside tha compartment can chizzle ta place
variablez tha fuck into (or \fIshare\fR variablez with) tha compartmentz namespace
and only dat data is ghon be visible ta code evaluated up in the
compartment.
.Sp
By default, tha only variablez shared wit compartments is the
\&\*(L"underscore\*(R" variablez \f(CW$_\fR n' \f(CW@_\fR (and, technically, tha less frequently
used \f(CW%_\fR, tha _ filehandle n' so on). This is cuz otherwise perl
operators which default ta \f(CW$_\fR aint gonna work n' neither will the
assignment of arguments ta \f(CW@_\fR on subroutine entry.
.IP "an operator mask" 8
.IX Item "an operator mask"
Each compartment has a associated \*(L"operator mask\*(R". Recall that
perl code is compiled tha fuck into a internal format before execution.
Evaluatin perl code (e.g. via \*(L"eval\*(R" or \*(L"do 'file'\*(R") causes
the code ta be compiled tha fuck into a internal format n' then,
provided there was no error up in tha compilation, executed.
Code evaluated up in a cold-ass lil compartment compilez subject ta the
compartmentz operator mask fo' realz. Attemptin ta evaluate code up in a
compartment which gotz nuff a maxed operator will cause the
compilation ta fail wit a error. Shiiit, dis aint no joke. Da code aint gonna be executed.
.Sp
Da default operator mask fo' a newly pimped compartment is
the ':default' optag.
.Sp
It be blingin dat you read tha Opcode module documentation
for mo' shiznit, especially fo' detailed definitionz of opnames,
optags n' opsets.
.Sp
Since it is only all up in tha compilation stage dat tha operator mask
applies, controlled access ta potentially unsafe operations can
be  bigged up  by havin a handle ta a wrapper subroutine (written
outside tha compartment) placed tha fuck into tha compartment. For example,
.Sp
.Vb 5
\&    $cpt = freshly smoked up Safe;
\&    sub wrapper {
\&        # vet arguments n' big-ass up potentially unsafe operations
\&    }
\&    $cpt\->share(\*(Aq&wrapper\*(Aq);
.Ve
.SH "WARNING"
.IX Header "WARNING"
Da authors make \fBno warranty\fR, implied or otherwise, bout the
suitabilitizzle of dis software fo' safety or securitizzle purposes.
.PP
Da authors shall not up in any case be liable fo' special, incidental,
consequential, indirect or other similar damages arisin from tha use
of dis software.
.PP
Yo crazy-ass mileage will vary. If up in any doubt \fBdo not use it\fR.
.SH "METHODS"
.IX Header "METHODS"
To create a freshly smoked up compartment, use
.PP
.Vb 1
\&    $cpt = freshly smoked up Safe;
.Ve
.PP
Optionizzle argument is (\s-1NAMESPACE\s0), where \s-1NAMESPACE\s0 is tha root namespace
to use fo' tha compartment (defaults ta \*(L"Safe::Root0\*(R", incremented for
each freshly smoked up compartment).
.PP
Note dat version 1.00 of tha Safe module supported a second optional
parameter, \s-1MASK. \s0 That functionalitizzle has been withdrawn pendin deeper
consideration. I aint talkin' bout chicken n' gravy biatch. Use tha permit n' deny methodz busted lyrics bout below.
.PP
Da followin methodz can then be used on tha compartment
object returned by tha above constructor. Shiiit, dis aint no joke. Da object argument
is implicit up in each case.
.SS "permit (\s-1OP, ...\s0)"
.IX Subsection "permit (OP, ...)"
Permit tha listed operators ta be used when compilin code up in the
compartment (in \fIaddition\fR ta any operators already permitted).
.PP
Yo ass can list opcodes by names, or bust a tag name; see
\&\*(L"Predefined Opcode Tags\*(R" up in Opcode.
.SS "permit_only (\s-1OP, ...\s0)"
.IX Subsection "permit_only (OP, ...)"
Permit \fIonly\fR tha listed operators ta be used when compilin code in
the compartment (\fIno\fR other operators is permitted).
.SS "deny (\s-1OP, ...\s0)"
.IX Subsection "deny (OP, ...)"
Deny tha listed operators from bein used when compilin code up in the
compartment (other operators may still be permitted).
.SS "deny_only (\s-1OP, ...\s0)"
.IX Subsection "deny_only (OP, ...)"
Deny \fIonly\fR tha listed operators from bein used when compilin code
in tha compartment (\fIall\fR other operators is ghon be permitted, so you probably
don't wanna use dis method).
.SS "trap (\s-1OP, ...\s0)"
.IX Subsection "trap (OP, ...)"
.SS "untrap (\s-1OP, ...\s0)"
.IX Subsection "untrap (OP, ...)"
Da trap n' untrap methodz is synonyms fo' deny n' permit
respectfully.
.SS "share (\s-1NAME, ...\s0)"
.IX Subsection "share (NAME, ...)"
This shares tha variable(s) up in tha argument list wit tha compartment.
This be almost identical ta exportin variablez rockin tha Exporter
module.
.PP
Each \s-1NAME\s0 must be tha \fBname\fR of a non-lexical variable, typically
with tha leadin type identifier included. Y'all KNOW dat shit, muthafucka! A bareword is treated as a
function name.
.PP
Examplez of legal names is '$foo' fo' a scalar, '@foo' fo' an
array, '%foo' fo' a hash, '&foo' or 'foo' fo' a subroutine n' '*foo'
for a glob (i.e.  all symbol table entries associated wit \*(L"foo\*(R",
includin scalar, array, hash, sub n' filehandle).
.PP
Each \s-1NAME\s0 be assumed ta be up in tha callin package. Right back up in yo muthafuckin ass. See share_from
for a alternatizzle method (which \f(CW\*(C`share\*(C'\fR uses).
.SS "share_from (\s-1PACKAGE, ARRAYREF\s0)"
.IX Subsection "share_from (PACKAGE, ARRAYREF)"
This method is similar ta \fIshare()\fR but allows you ta explicitly name the
package dat symbols should be shared from. Da symbol names (including
type characters) is supplied as a array reference.
.PP
.Vb 1
\&    $safe\->share_from(\*(Aqmain\*(Aq, [ \*(Aq$foo\*(Aq, \*(Aq%bar\*(Aq, \*(Aqfunc\*(Aq ]);
.Ve
.PP
Names can include package names, which is relatizzle ta tha specified \s-1PACKAGE.\s0
So these two calls have tha same effect:
.PP
.Vb 2
\&    $safe\->share_from(\*(AqScalar::Util\*(Aq, [ \*(Aqreftype\*(Aq ]);
\&    $safe\->share_from(\*(Aqmain\*(Aq, [ \*(AqScalar::Util::reftype\*(Aq ]);
.Ve
.SS "varglob (\s-1VARNAME\s0)"
.IX Subsection "varglob (VARNAME)"
This returns a glob reference fo' tha symbol table entry of \s-1VARNAME\s0 in
the package of tha compartment. \s-1VARNAME\s0 must be tha \fBname\fR of a
variable without any leadin type marker n' shit. For example:
.PP
.Vb 1
\&    ${$cpt\->varglob(\*(Aqfoo\*(Aq)} = "Wuz crackalackin' ghetto";
.Ve
.PP
has tha same ol' dirty effect as:
.PP
.Vb 2
\&    $cpt = freshly smoked up Safe \*(AqRoot\*(Aq;
\&    $Root::foo = "Wuz crackalackin' ghetto";
.Ve
.PP
but avoidz tha need ta know \f(CW$cpt\fRz package name.
.SS "reval (\s-1STRING, STRICT\s0)"
.IX Subsection "reval (STRING, STRICT)"
This evaluates \s-1STRING\s0 as perl code inside tha compartment.
.PP
Da code can only peep tha compartmentz namespace (as returned by the
\&\fBroot\fR method). Da compartmentz root package appears ta be the
\&\f(CW\*(C`main::\*(C'\fR package ta tha code inside tha compartment.
.PP
Any attempt by tha code up in \s-1STRING\s0 ta use a operator which aint permitted
by tha compartment will cause a error (at run-time of tha main program
but at compile-time fo' tha code up in \s-1STRING\s0).  Da error iz of tha form
\&\*(L"'%s' trapped by operation mask...\*(R".
.PP
If a operation is trapped up in dis way, then tha code up in \s-1STRING\s0 will
not be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If such a trapped operation occurs or any other
compile-time or return error, then $@ is set ta tha error message, just
as wit a \fIeval()\fR.
.PP
If there is no error, then tha method returns tha value of tha last
expression evaluated, or a return statement may be used, just as with
subroutines n' \fB\f(BIeval()\fB\fR. Da context (list or scalar) is determined
by tha calla as usual.
.PP
If tha return value of \fIreval()\fR is (or gotz nuff) any code reference,
those code references is wrapped ta be theyselves executed always
in tha compartment. Right back up in yo muthafuckin ass. See \*(L"wrap_code_refs_within\*(R".
.PP
Da formerly undocumented \s-1STRICT\s0 argument sets strictness: if true
\&'use strict;' is used, otherwise it uses 'no strict;'. \fBNote\fR: if
\&\s-1STRICT\s0 is omitted 'no strict;' is tha default.
.PP
Some points ta note:
.PP
If tha entereval op is permitted then tha code can use eval \*(L"...\*(R" to
\&'hide' code which might use denied ops. This aint a major problem
since when tha code tries ta execute tha eval it will fail cuz the
opmask is still up in effect yo. However dis technique would allow def,
and possibly harmful, code ta 'probe' tha boundariez of what tha fuck is
possible.
.PP
Any strang eval which is executed by code executin up in a cold-ass lil compartment,
or by code called from code executin up in a cold-ass lil compartment, is ghon be eval'd
in tha namespace of tha compartment. This is potentially a serious
problem.
.PP
Consider a gangbangin' function \fIfoo()\fR up in package pkg compiled outside a cold-ass lil compartment
but shared wit it fo' realz. Assume tha compartment has a root package called
\&'Root'. If \fIfoo()\fR gotz nuff a eval statement like eval '$foo = 1' then,
normally, \f(CW$pkg::foo\fR is ghon be set ta 1.  If \fIfoo()\fR is called from the
compartment (by whatever means) then instead of settin \f(CW$pkg::foo\fR, the
eval will straight-up set \f(CW$Root::pkg::foo\fR.
.PP
This can easily be demonstrated by rockin a module, like fuckin tha Socket
module, which uses eval \*(L"...\*(R" as part of a \s-1AUTOLOAD\s0 function. I aint talkin' bout chicken n' gravy biatch. Yo ass can
\&'use' tha module outside tha compartment n' share a (autoloaded)
function wit tha compartment. If a autoload is triggered by code in
the compartment, or by any code anywhere dat is called by any means
from tha compartment, then tha eval up in tha Socket modulez \s-1AUTOLOAD\s0
function happens up in tha namespace of tha compartment fo' realz. Any variables
created or used by tha eval'd code is now under tha control of
the code up in tha compartment.
.PP
A similar effect applies ta \fIall\fR runtime symbol lookups up in code
called from a cold-ass lil compartment but not compiled within dat shit.
.SS "rdo (\s-1FILENAME\s0)"
.IX Subsection "rdo (FILENAME)"
This evaluates tha contentz of file \s-1FILENAME\s0 inside tha compartment.
See above documentation on tha \fBreval\fR method fo' further details.
.SS "root (\s-1NAMESPACE\s0)"
.IX Subsection "root (NAMESPACE)"
This method returns tha name of tha package dat is tha root of the
compartmentz namespace.
.PP
Note dat dis behaviour differs from version 1.00 of tha Safe module
where tha root module could be used ta chizzle tha namespace. That
functionalitizzle has been withdrawn pendin deeper consideration.
.SS "mask (\s-1MASK\s0)"
.IX Subsection "mask (MASK)"
This be a get-or-set method fo' tha compartmentz operator mask.
.PP
With no \s-1MASK\s0 argument present, it returns tha current operator mask of
the compartment.
.PP
With tha \s-1MASK\s0 argument present, it sets tha operator mask fo' the
compartment (equivalent ta callin tha deny_only method).
.SS "wrap_code_ref (\s-1CODEREF\s0)"
.IX Subsection "wrap_code_ref (CODEREF)"
Returns a reference ta a anonymous subroutine that, when executed, will call
\&\s-1CODEREF\s0 wit tha Safe compartment 'in effect'.  In other lyrics, wit the
package namespace adjusted n' tha opmask enabled.
.PP
Note dat tha opmask don't affect tha already compiled code, it only affects
any \fIfurther\fR compilation dat tha already compiled code may try ta perform.
.PP
This is particularly useful when applied ta code references returned from \fIreval()\fR.
.PP
(It also serves up a kind of workaround fo' RT#60374: \*(L"Safe.pm sort {} bug with
\&\-Dusethreads\*(R". Right back up in yo muthafuckin ass. See <http://rt.perl.org/rt3//Public/Bug/Display.html?id=60374>
for \fImuch\fR mo' detail.)
.SS "wrap_code_refs_within (...)"
.IX Subsection "wrap_code_refs_within (...)"
Wraps any \s-1CODE\s0 references found within tha arguments by replacin each wit the
result of callin \*(L"wrap_code_ref\*(R" on tha \s-1CODE\s0 reference fo' realz. Any \s-1ARRAY\s0 or \s-1HASH\s0
references up in tha arguments is inspected recursively.
.PP
Returns nothing.
.SH "RISKS"
.IX Header "RISKS"
This section is just a outline of a shitload of tha thangs code up in a cold-ass lil compartment
might do (intentionally or unintentionally) which can have a effect outside
the compartment.
.IP "Memory" 8
.IX Item "Memory"
Consumin all (or nearly all) available memory.
.IP "\s-1CPU\s0" 8
.IX Item "CPU"
Causin infinite loops etc.
.IP "Snooping" 8
.IX Item "Snooping"
Copyin private shiznit outta yo' system. Even suttin' as
simple as yo' user name iz of value ta others. Much useful shiznit
could be gleaned from yo' environment variablez fo' example.
.IP "Signals" 8
.IX Item "Signals"
Causin signals (especially \s-1SIGFPE\s0 n' \s-1SIGALARM\s0) ta affect yo' process.
.Sp
Settin up a signal handlez will need ta be carefully considered
and controlled. Y'all KNOW dat shit, muthafucka!  What mask is up in effect when a signal handlez
gets called?  If a user can git a imported function ta git an
exception n' call tha userz signal handlez, do dat user's
restricted mask git re-instated before tha handlez is called?
Do a imported handlez git called wit its original gangsta mask or
the userz one?
.IP "State Chizzles" 8
.IX Item "State Chizzles"
Ops like fuckin chdir obviously effect tha process as a whole n' not just
the code up in tha compartment. Ops like fuckin rand n' srand gotz a similar
but mo' subtle effect.
.SH "AUTHOR"
.IX Header "AUTHOR"
Originally designed n' implemented by Malcolm Beattie.
.PP
Reworked ta use tha Opcode module n' other chizzlez added by Slim Tim Bunce.
.PP
Currently maintained by tha Perl 5 Porters, <perl5\-porters@perl.org>.
