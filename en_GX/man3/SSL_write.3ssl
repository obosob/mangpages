.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_write 3"
.TH SSL_write 3 "2015-01-13" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_write \- write bytes ta a TLS/SSL connection.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& int SSL_write(SSL *ssl, const void *buf, int num);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISSL_write()\fR writes \fBnum\fR bytes from tha buffer \fBbuf\fR tha fuck into tha specified
\&\fBssl\fR connection.
.SH "NOTES"
.IX Header "NOTES"
If necessary, \fISSL_write()\fR will negotiate a \s-1TLS/SSL\s0 session, if
not already explicitly performed by \fISSL_connect\fR\|(3) or
\&\fISSL_accept\fR\|(3). If the
peer requests a re-negotiation, it is ghon be performed transparently during
the \fISSL_write()\fR operation. I aint talkin' bout chicken n' gravy biatch. Da behaviour of \fISSL_write()\fR dependz on the
underlyin \s-1BIO. \s0
.PP
For tha transparent negotiation ta succeed, tha \fBssl\fR must have been
initialized ta client or server mode. This is bein done by calling
\&\fISSL_set_connect_state\fR\|(3) or \fISSL_set_accept_state()\fR
before tha straight-up original gangsta call ta a \fISSL_read\fR\|(3) or \fISSL_write()\fR function.
.PP
If tha underlyin \s-1BIO\s0 is \fBblocking\fR, \fISSL_write()\fR will only return, once the
write operation has been finished or a error occurred, except when a
renegotiation take place, up in which case a \s-1SSL_ERROR_WANT_READ\s0 may occur. Shiiit, dis aint no joke. 
This behaviour can be controlled wit tha \s-1SSL_MODE_AUTO_RETRY\s0 flag of the
\&\fISSL_CTX_set_mode\fR\|(3) call.
.PP
If tha underlyin \s-1BIO\s0 is \fBnon-blocking\fR, \fISSL_write()\fR will also return,
when tha underlyin \s-1BIO\s0 could not satisfy tha needz of \fISSL_write()\fR
to continue tha operation. I aint talkin' bout chicken n' gravy biatch. In dis case a cold-ass lil call to
\&\fISSL_get_error\fR\|(3) wit the
return value of \fISSL_write()\fR will yield \fB\s-1SSL_ERROR_WANT_READ\s0\fR or
\&\fB\s-1SSL_ERROR_WANT_WRITE\s0\fR fo' realz. As at any time a re-negotiation is possible, a
call ta \fISSL_write()\fR can also cause read operations muthafucka! Da callin process
then must repeat tha call afta takin appropriate action ta satisfy the
needz of \fISSL_write()\fR. Da action dependz on tha underlyin \s-1BIO.\s0 When rockin a
non-blockin socket, not a god damn thang is ta be done yo, but \fIselect()\fR can be used ta check
for tha required condition. I aint talkin' bout chicken n' gravy biatch. When rockin a funky-ass bufferin \s-1BIO,\s0 like a \s-1BIO\s0 pair, data
must be freestyled tha fuck into or retrieved outta tha \s-1BIO\s0 before bein able ta continue.
.PP
\&\fISSL_write()\fR will only return wit success, when tha complete contents
of \fBbuf\fR of length \fBnum\fR has been written. I aint talkin' bout chicken n' gravy biatch. This default behaviour
can be chizzled wit tha \s-1SSL_MODE_ENABLE_PARTIAL_WRITE\s0 option of
\&\fISSL_CTX_set_mode\fR\|(3). When dis flag is set,
\&\fISSL_write()\fR will also return wit success, when a partial write has been
successfully completed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In dis case tha \fISSL_write()\fR operation is considered
completed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da bytes is busted n' a freshly smoked up \fISSL_write()\fR operation wit a new
buffer (with tha already busted bytes removed) must be started.
A partial write is performed wit tha size of a message block, which is
16kB fo' SSLv3/TLSv1.
.SH "WARNING"
.IX Header "WARNING"
When a \fISSL_write()\fR operation has ta be repeated cuz of
\&\fB\s-1SSL_ERROR_WANT_READ\s0\fR or \fB\s-1SSL_ERROR_WANT_WRITE\s0\fR, it must be repeated
with tha same arguments.
.PP
When callin \fISSL_write()\fR wit num=0 bytes ta be busted tha behaviour is
undefined.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
Da followin return joints can occur:
.IP ">0" 4
.IX Item ">0"
Da write operation was successful, tha return value is tha number of
bytes straight-up freestyled ta tha \s-1TLS/SSL\s0 connection.
.ie n .IP "0" 4
.el .IP "\f(CW0\fR" 4
.IX Item "0"
Da write operation was not successful naaahhmean? Probably tha underlyin connection
was closed. Y'all KNOW dat shit, muthafucka! Call \fISSL_get_error()\fR wit tha return value \fBret\fR ta smoke up,
whether a error occurred or tha connection was shut down cleanly
(\s-1SSL_ERROR_ZERO_RETURN\s0).
.Sp
SSLv2 (deprecated) do not support a gangbangin' finger-lickin' dirty-ass shutdown alert protocol, so it can
only be detected, whether tha underlyin connection was closed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it cannot
be checked, why tha closure happened.
.IP "<0" 4
.IX Item "<0"
Da write operation was not successful, cuz either a error occurred
or action must be taken by tha callin process. Call \fISSL_get_error()\fR wit the
return value \fBret\fR ta smoke up tha reason.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fISSL_get_error\fR\|(3), \fISSL_read\fR\|(3),
\&\fISSL_CTX_set_mode\fR\|(3), \fISSL_CTX_new\fR\|(3),
\&\fISSL_connect\fR\|(3), \fISSL_accept\fR\|(3)
\&\fISSL_set_connect_state\fR\|(3),
\&\fIssl\fR\|(3), \fIbio\fR\|(3)
