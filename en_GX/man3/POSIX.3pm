.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "POSIX 3pm"
.TH POSIX 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
POSIX \- Perl intercourse ta IEEE Std 1003.1
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use POSIX ();
\&    use POSIX qw(setsid);
\&    use POSIX qw(:errno_h :fcntl_h);
\&
\&    printf "EINTR is %d\en", EINTR;
\&
\&    $sess_id = POSIX::setsid();
\&
\&    $fd = POSIX::open($path, O_CREAT|O_EXCL|O_WRONLY, 0644);
\&        # note: that\*(Aqs a gangbangin' filedescriptor, *NOT* a gangbangin' filehandle
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \s-1POSIX\s0 module permits you ta access all (or nearly all) tha standard
\&\s-1POSIX 1003.1\s0 identifiers.  Many of these identifiers done been given Perl-ish
interfaces.
.PP
\&\fIEverythang is exported by default\fR wit tha exception of any \s-1POSIX\s0
functions wit tha same name as a funky-ass built-in Perl function, such as
\&\f(CW\*(C`abs\*(C'\fR, \f(CW\*(C`alarm\*(C'\fR, \f(CW\*(C`rmdir\*(C'\fR, \f(CW\*(C`write\*(C'\fR, etc.., which is ghon be exported
only if you ask fo' dem explicitly.  This be a fucked up backwards
compatibilitizzle feature.  Yo ass can stop tha exportin by sayin \f(CW\*(C`use
POSIX ()\*(C'\fR n' then use tha straight-up qualified names (ie. \f(CW\*(C`POSIX::SEEK_END\*(C'\fR),
or by givin a explicit import list.  If you do neither, n' opt fo' the
default, \f(CW\*(C`use POSIX;\*(C'\fR has ta import \fI553 symbols\fR.
.PP
This document gives a cold-ass lil condensed list of tha features available up in tha \s-1POSIX\s0
module.  Consult yo' operatin systemz manpages fo' general shiznit on
most features.  Consult perlfunc fo' functions which is noted as being
identical ta Perlz builtin functions.
.PP
Da first section raps bout \s-1POSIX\s0 functions from tha 1003.1 justification.
Da second section raps bout some classes fo' signal objects, \s-1TTY\s0 objects,
and other miscellaneous objects, n' you can put dat on yo' toast.  Da remainin sections list various
constants n' macros up in a organization which roughly bigs up \s-1IEEE\s0 Std
1003.1b\-1993.
.SH "CAVEATS"
.IX Header "CAVEATS"
A few functions is not implemented cuz they is C specific.  If you
attempt ta booty-call these, they will print a message spittin some lyrics ta you dat they
aren't implemented, n' suggest rockin tha Perl equivalent should one
exist.  For example, tryin ta access tha \fIsetjmp()\fR call will elicit the
message \*(L"\fIsetjmp()\fR is C\-specific: use eval {} instead\*(R".
.PP
Furthermore, some evil vendors will claim 1003.1 compliizzle yo, but up in fact
are not so: they aint gonna pass tha \s-1PCTS \s0(\s-1POSIX\s0 Compliizzle Test Suites).
For example, one vendor may not define \s-1EDEADLK,\s0 or tha semantics of the
errno joints set by \fIopen\fR\|(2) might not be like right.  Perl do not
attempt ta verify \s-1POSIX\s0 compliance.  That means you can currently
successfully say \*(L"use \s-1POSIX\*(R", \s0 n' then lata up in yo' program you find
that yo' vendor has been lax n' there be a no usable \s-1ICANON\s0 macro after
all.  This could be construed ta be a funky-ass bug.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "_exit" 8
.IX Item "_exit"
This is identical ta tha C function \f(CW\*(C`_exit()\*(C'\fR.  It exits tha program
immediately which means among other thangs buffered I/O is \fBnot\fR flushed.
.Sp
Note dat when rockin threadz n' up in Linux dis is \fBnot\fR a phat way to
exit a thread cuz up in Linux processes n' threadz is kind of the
same thang (Note: while dis is tha thang up in early 2003 there are
projects under way ta have threadz wit mo' POSIXly semantics up in Linux).
If you want not ta return from a thread, detach tha thread.
.IP "abort" 8
.IX Item "abort"
This is identical ta tha C function \f(CW\*(C`abort()\*(C'\fR.  It terminates the
process wit a \f(CW\*(C`SIGABRT\*(C'\fR signal unless caught by a signal handlez or
if tha handlez do not return normally (it e.g.  do a \f(CW\*(C`longjmp\*(C'\fR).
.IP "abs" 8
.IX Item "abs"
This is identical ta Perlz builtin \f(CW\*(C`abs()\*(C'\fR function, returning
the absolute value of its numerical argument.
.IP "access" 8
.IX Item "access"
Determines tha accessibilitizzle of a gangbangin' file.
.Sp
.Vb 3
\&        if( POSIX::access( "/", &POSIX::R_OK ) ){
\&                print "have read permission\en";
\&        }
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.  Note: do not use \f(CW\*(C`access()\*(C'\fR for
securitizzle purposes.  Between tha \f(CW\*(C`access()\*(C'\fR call n' tha operation
yo ass is preparin fo' tha permissions might chizzle: a cold-ass lil classic
\&\fIrace condition\fR.
.IP "acos" 8
.IX Item "acos"
This is identical ta tha C function \f(CW\*(C`acos()\*(C'\fR, returning
the arcus cosine of its numerical argument.  See also Math::Trig.
.IP "alarm" 8
.IX Item "alarm"
This is identical ta Perlz builtin \f(CW\*(C`alarm()\*(C'\fR function,
either fo' armin or disarmin tha \f(CW\*(C`SIGARLM\*(C'\fR timer.
.IP "asctime" 8
.IX Item "asctime"
This is identical ta tha C function \f(CW\*(C`asctime()\*(C'\fR.  It returns
a strang of tha form
.Sp
.Vb 1
\&        "Fri Jun  2 18:22:13 2000\en\e0"
.Ve
.Sp
and it is called thusly
.Sp
.Vb 2
\&        $asctime = asctime($sec, $min, $hour, $mday, $mon, $year,
\&                           $wday, $yday, $isdst);
.Ve
.Sp
Da \f(CW$mon\fR is zero-based: January equals \f(CW0\fR.  Da \f(CW$year\fR is
1900\-based: 2001 equals \f(CW101\fR.  \f(CW$wday\fR n' \f(CW$yday\fR default ta zero
(and is probably ignored anyway), n' \f(CW$isdst\fR defaults ta \-1.
.IP "asin" 8
.IX Item "asin"
This is identical ta tha C function \f(CW\*(C`asin()\*(C'\fR, returning
the arcus sine of its numerical argument.  See also Math::Trig.
.IP "assert" 8
.IX Item "assert"
Unimplemented yo, but you can use \*(L"die\*(R" up in perlfunc n' tha Carp module
to big up similar thangs.
.IP "atan" 8
.IX Item "atan"
This is identical ta tha C function \f(CW\*(C`atan()\*(C'\fR, returnin the
arcus tangent of its numerical argument.  See also Math::Trig.
.IP "atan2" 8
.IX Item "atan2"
This is identical ta Perlz builtin \f(CW\*(C`atan2()\*(C'\fR function, returning
the arcus tangent defined by its two numerical arguments, tha \fIy\fR
coordinizzle n' tha \fIx\fR coordinate.  See also Math::Trig.
.IP "atexit" 8
.IX Item "atexit"
\&\fIatexit()\fR is C\-specific: use \f(CW\*(C`END {}\*(C'\fR instead, peep perlsub.
.IP "atof" 8
.IX Item "atof"
\&\fIatof()\fR is C\-specific.  Perl converts strings ta numbers transparently.
If you need ta force a scalar ta a number, add a zero ta dat shit.
.IP "atoi" 8
.IX Item "atoi"
\&\fIatoi()\fR is C\-specific.  Perl converts strings ta numbers transparently.
If you need ta force a scalar ta a number, add a zero ta dat shit.
If you need ta have just tha integer part, peep \*(L"int\*(R" up in perlfunc.
.IP "atol" 8
.IX Item "atol"
\&\fIatol()\fR is C\-specific.  Perl converts strings ta numbers transparently.
If you need ta force a scalar ta a number, add a zero ta dat shit.
If you need ta have just tha integer part, peep \*(L"int\*(R" up in perlfunc.
.IP "bsearch" 8
.IX Item "bsearch"
\&\fIbsearch()\fR not supplied. Y'all KNOW dat shit, muthafucka!  For bustin binary search on wordlists,
see Search::Dict.
.IP "calloc" 8
.IX Item "calloc"
\&\fIcalloc()\fR is C\-specific.  Perl do memory pimpment transparently.
.IP "ceil" 8
.IX Item "ceil"
This is identical ta tha C function \f(CW\*(C`ceil()\*(C'\fR, returnin tha smallest
integer value pimped outa than or equal ta tha given numerical argument.
.IP "chdir" 8
.IX Item "chdir"
This is identical ta Perlz builtin \f(CW\*(C`chdir()\*(C'\fR function, allowing
one ta chizzle tha hustlin (default) directory, peep \*(L"chdir\*(R" up in perlfunc.
.IP "chmod" 8
.IX Item "chmod"
This is identical ta Perlz builtin \f(CW\*(C`chmod()\*(C'\fR function, allowing
one ta chizzle file n' directory permissions, peep \*(L"chmod\*(R" up in perlfunc.
.IP "chown" 8
.IX Item "chown"
This is identical ta Perlz builtin \f(CW\*(C`chown()\*(C'\fR function, allowin one
to chizzle file n' directory ballaz n' groups, peep \*(L"chown\*(R" up in perlfunc.
.IP "clearerr" 8
.IX Item "clearerr"
Use tha method \f(CW\*(C`IO::Handle::clearerr()\*(C'\fR instead, ta reset tha error
state (if any) n' \s-1EOF\s0 state (if any) of tha given stream.
.IP "clock" 8
.IX Item "clock"
This is identical ta tha C function \f(CW\*(C`clock()\*(C'\fR, returnin the
amount of dropped processor time up in microseconds.
.IP "close" 8
.IX Item "close"
Close tha file.  This uses file descriptors like fuckin dem obtained by calling
\&\f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
.Vb 2
\&        $fd = POSIX::open( "foo", &POSIX::O_RDONLY );
\&        POSIX::close( $fd );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.Sp
See also \*(L"close\*(R" up in perlfunc.
.IP "closedir" 8
.IX Item "closedir"
This is identical ta Perlz builtin \f(CW\*(C`closedir()\*(C'\fR function fo' closing
a directory handle, peep \*(L"closedir\*(R" up in perlfunc.
.IP "cos" 8
.IX Item "cos"
This is identical ta Perlz builtin \f(CW\*(C`cos()\*(C'\fR function, fo' returning
the cosine of its numerical argument, peep \*(L"cos\*(R" up in perlfunc.
See also Math::Trig.
.IP "cosh" 8
.IX Item "cosh"
This is identical ta tha C function \f(CW\*(C`cosh()\*(C'\fR, fo' returning
the hyperbolic cosine of its numeric argument.  See also Math::Trig.
.IP "creat" 8
.IX Item "creat"
Smoke a freshly smoked up file.  This returns a gangbangin' file descriptor like tha ones returned by
\&\f(CW\*(C`POSIX::open\*(C'\fR.  Use \f(CW\*(C`POSIX::close\*(C'\fR ta close tha file.
.Sp
.Vb 2
\&        $fd = POSIX::creat( "foo", 0611 );
\&        POSIX::close( $fd );
.Ve
.Sp
See also \*(L"sysopen\*(R" up in perlfunc n' its \f(CW\*(C`O_CREAT\*(C'\fR flag.
.IP "ctermid" 8
.IX Item "ctermid"
Generates tha path name fo' tha controllin terminal.
.Sp
.Vb 1
\&        $path = POSIX::ctermid();
.Ve
.IP "ctime" 8
.IX Item "ctime"
This is identical ta tha C function \f(CW\*(C`ctime()\*(C'\fR n' equivalent
to \f(CW\*(C`asctime(localtime(...))\*(C'\fR, peep \*(L"asctime\*(R" n' \*(L"localtime\*(R".
.IP "cuserid" 8
.IX Item "cuserid"
Git tha login name of tha balla of tha current process.
.Sp
.Vb 1
\&        $name = POSIX::cuserid();
.Ve
.IP "difftime" 8
.IX Item "difftime"
This is identical ta tha C function \f(CW\*(C`difftime()\*(C'\fR, fo' returning
the time difference (in seconds) between two times (as returned
by \f(CW\*(C`time()\*(C'\fR), peep \*(L"time\*(R".
.IP "div" 8
.IX Item "div"
\&\fIdiv()\fR is C\-specific, use \*(L"int\*(R" up in perlfunc on tha usual \f(CW\*(C`/\*(C'\fR division and
the modulus \f(CW\*(C`%\*(C'\fR.
.IP "dup" 8
.IX Item "dup"
This is similar ta tha C function \f(CW\*(C`dup()\*(C'\fR, fo' duplicatin a gangbangin' file
descriptor.
.Sp
This uses file descriptors like fuckin dem obtained by calling
\&\f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "dup2" 8
.IX Item "dup2"
This is similar ta tha C function \f(CW\*(C`dup2()\*(C'\fR, fo' duplicatin a gangbangin' file
descriptor ta a another known file descriptor.
.Sp
This uses file descriptors like fuckin dem obtained by calling
\&\f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "errno" 8
.IX Item "errno"
Returns tha value of errno.
.Sp
.Vb 1
\&        $errno = POSIX::errno();
.Ve
.Sp
This identical ta tha numerical jointz of tha \f(CW$!\fR, peep \*(L"$ERRNO\*(R" up in perlvar.
.IP "execl" 8
.IX Item "execl"
\&\fIexecl()\fR is C\-specific, peep \*(L"exec\*(R" up in perlfunc.
.IP "execle" 8
.IX Item "execle"
\&\fIexecle()\fR is C\-specific, peep \*(L"exec\*(R" up in perlfunc.
.IP "execlp" 8
.IX Item "execlp"
\&\fIexeclp()\fR is C\-specific, peep \*(L"exec\*(R" up in perlfunc.
.IP "execv" 8
.IX Item "execv"
\&\fIexecv()\fR is C\-specific, peep \*(L"exec\*(R" up in perlfunc.
.IP "execve" 8
.IX Item "execve"
\&\fIexecve()\fR is C\-specific, peep \*(L"exec\*(R" up in perlfunc.
.IP "execvp" 8
.IX Item "execvp"
\&\fIexecvp()\fR is C\-specific, peep \*(L"exec\*(R" up in perlfunc.
.IP "exit" 8
.IX Item "exit"
This is identical ta Perlz builtin \f(CW\*(C`exit()\*(C'\fR function fo' exitin the
program, peep \*(L"exit\*(R" up in perlfunc.
.IP "exp" 8
.IX Item "exp"
This is identical ta Perlz builtin \f(CW\*(C`exp()\*(C'\fR function for
returnin tha exponent (\fIe\fR\-based) of tha numerical argument,
see \*(L"exp\*(R" up in perlfunc.
.IP "fabs" 8
.IX Item "fabs"
This is identical ta Perlz builtin \f(CW\*(C`abs()\*(C'\fR function fo' returning
the absolute value of tha numerical argument, peep \*(L"abs\*(R" up in perlfunc.
.IP "fclose" 8
.IX Item "fclose"
Use method \f(CW\*(C`IO::Handle::close()\*(C'\fR instead, or peep \*(L"close\*(R" up in perlfunc.
.IP "fcntl" 8
.IX Item "fcntl"
This is identical ta Perlz builtin \f(CW\*(C`fcntl()\*(C'\fR function,
see \*(L"fcntl\*(R" up in perlfunc.
.IP "fdopen" 8
.IX Item "fdopen"
Use method \f(CW\*(C`IO::Handle::new_from_fd()\*(C'\fR instead, or peep \*(L"open\*(R" up in perlfunc.
.IP "feof" 8
.IX Item "feof"
Use method \f(CW\*(C`IO::Handle::eof()\*(C'\fR instead, or peep \*(L"eof\*(R" up in perlfunc.
.IP "ferror" 8
.IX Item "ferror"
Use method \f(CW\*(C`IO::Handle::error()\*(C'\fR instead.
.IP "fflush" 8
.IX Item "fflush"
Use method \f(CW\*(C`IO::Handle::flush()\*(C'\fR instead.
See also \*(L"$OUTPUT_AUTOFLUSH\*(R" up in perlvar.
.IP "fgetc" 8
.IX Item "fgetc"
Use method \f(CW\*(C`IO::Handle::getc()\*(C'\fR instead, or peep \*(L"read\*(R" up in perlfunc.
.IP "fgetpos" 8
.IX Item "fgetpos"
Use method \f(CW\*(C`IO::Seekable::getpos()\*(C'\fR instead, or peep \*(L"seek\*(R" up in perlfunc.
.IP "fgets" 8
.IX Item "fgets"
Use method \f(CW\*(C`IO::Handle::gets()\*(C'\fR instead. Y'all KNOW dat shit, muthafucka!  Similar ta <>, also known
as \*(L"readline\*(R" up in perlfunc.
.IP "fileno" 8
.IX Item "fileno"
Use method \f(CW\*(C`IO::Handle::fileno()\*(C'\fR instead, or peep \*(L"fileno\*(R" up in perlfunc.
.IP "floor" 8
.IX Item "floor"
This is identical ta tha C function \f(CW\*(C`floor()\*(C'\fR, returnin tha phattest
integer value less than or equal ta tha numerical argument.
.IP "fmod" 8
.IX Item "fmod"
This is identical ta tha C function \f(CW\*(C`fmod()\*(C'\fR.
.Sp
.Vb 1
\&        $r = fmod($x, $y);
.Ve
.Sp
It returns tha remainder \f(CW\*(C`$r = $x \- $n*$y\*(C'\fR, where \f(CW\*(C`$n = trunc($x/$y)\*(C'\fR.
Da \f(CW$r\fR has tha same ol' dirty sign as \f(CW$x\fR n' magnitude (absolute value)
less than tha magnitude of \f(CW$y\fR.
.IP "fopen" 8
.IX Item "fopen"
Use method \f(CW\*(C`IO::File::open()\*(C'\fR instead, or peep \*(L"open\*(R" up in perlfunc.
.IP "fork" 8
.IX Item "fork"
This is identical ta Perlz builtin \f(CW\*(C`fork()\*(C'\fR function
for duplicatin tha current process, peep \*(L"fork\*(R" up in perlfunc
and perlfork if yo ass is up in Windows.
.IP "fpathconf" 8
.IX Item "fpathconf"
Retrieves tha value of a cold-ass lil configurable limit on a gangbangin' file or directory.  This
uses file descriptors like fuckin dem obtained by callin \f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
Da followin will determine tha maximum length of tha longest allowable
pathname on tha filesystem which holdz \fI/var/foo\fR.
.Sp
.Vb 2
\&        $fd = POSIX::open( "/var/foo", &POSIX::O_RDONLY );
\&        $path_max = POSIX::fpathconf( $fd, &POSIX::_PC_PATH_MAX );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "fprintf" 8
.IX Item "fprintf"
\&\fIfprintf()\fR is C\-specific, peep \*(L"printf\*(R" up in perlfunc instead.
.IP "fputc" 8
.IX Item "fputc"
\&\fIfputc()\fR is C\-specific, peep \*(L"print\*(R" up in perlfunc instead.
.IP "fputs" 8
.IX Item "fputs"
\&\fIfputs()\fR is C\-specific, peep \*(L"print\*(R" up in perlfunc instead.
.IP "fread" 8
.IX Item "fread"
\&\fIfread()\fR is C\-specific, peep \*(L"read\*(R" up in perlfunc instead.
.IP "free" 8
.IX Item "free"
\&\fIfree()\fR is C\-specific.  Perl do memory pimpment transparently.
.IP "freopen" 8
.IX Item "freopen"
\&\fIfreopen()\fR is C\-specific, peep \*(L"open\*(R" up in perlfunc instead.
.IP "frexp" 8
.IX Item "frexp"
Return tha mantissa n' exponent of a gangbangin' floating-point number.
.Sp
.Vb 1
\&        ($mantissa, $exponent) = POSIX::frexp( 1.234e56 );
.Ve
.IP "fscanf" 8
.IX Item "fscanf"
\&\fIfscanf()\fR is C\-specific, use <> n' regular expressions instead.
.IP "fseek" 8
.IX Item "fseek"
Use method \f(CW\*(C`IO::Seekable::seek()\*(C'\fR instead, or peep \*(L"seek\*(R" up in perlfunc.
.IP "fsetpos" 8
.IX Item "fsetpos"
Use method \f(CW\*(C`IO::Seekable::setpos()\*(C'\fR instead, or seek \*(L"seek\*(R" up in perlfunc.
.IP "fstat" 8
.IX Item "fstat"
Git file status.  This uses file descriptors like fuckin dem obtained by
callin \f(CW\*(C`POSIX::open\*(C'\fR.  Da data returned is identical ta tha data from
Perlz builtin \f(CW\*(C`stat\*(C'\fR function.
.Sp
.Vb 2
\&        $fd = POSIX::open( "foo", &POSIX::O_RDONLY );
\&        @stats = POSIX::fstat( $fd );
.Ve
.IP "fsync" 8
.IX Item "fsync"
Use method \f(CW\*(C`IO::Handle::sync()\*(C'\fR instead.
.IP "ftell" 8
.IX Item "ftell"
Use method \f(CW\*(C`IO::Seekable::tell()\*(C'\fR instead, or peep \*(L"tell\*(R" up in perlfunc.
.IP "fwrite" 8
.IX Item "fwrite"
\&\fIfwrite()\fR is C\-specific, peep \*(L"print\*(R" up in perlfunc instead.
.IP "getc" 8
.IX Item "getc"
This is identical ta Perlz builtin \f(CW\*(C`getc()\*(C'\fR function,
see \*(L"getc\*(R" up in perlfunc.
.IP "getchar" 8
.IX Item "getchar"
Returns one characta from \s-1STDIN. \s0 Identical ta Perlz \f(CW\*(C`getc()\*(C'\fR,
see \*(L"getc\*(R" up in perlfunc.
.IP "getcwd" 8
.IX Item "getcwd"
Returns tha name of tha current hustlin directory.
See also Cwd.
.IP "getegid" 8
.IX Item "getegid"
Returns tha effectizzle crew identifier n' shit.  Similar ta Perl' s builtin
variable \f(CW$(\fR, peep \*(L"$EGID\*(R" up in perlvar.
.IP "getenv" 8
.IX Item "getenv"
Returns tha value of tha specified environment variable.
Da same shiznit be available all up in tha \f(CW%ENV\fR array.
.IP "geteuid" 8
.IX Item "geteuid"
Returns tha effectizzle user identifier n' shit.  Identical ta Perlz builtin \f(CW$>\fR
variable, peep \*(L"$EUID\*(R" up in perlvar.
.IP "getgid" 8
.IX Item "getgid"
Returns tha userz real crew identifier n' shit.  Similar ta Perlz builtin
variable \f(CW$)\fR, peep \*(L"$GID\*(R" up in perlvar.
.IP "getgrgid" 8
.IX Item "getgrgid"
This is identical ta Perlz builtin \f(CW\*(C`getgrgid()\*(C'\fR function for
returnin crew entries by crew identifiers, see
\&\*(L"getgrgid\*(R" up in perlfunc.
.IP "getgrnam" 8
.IX Item "getgrnam"
This is identical ta Perlz builtin \f(CW\*(C`getgrnam()\*(C'\fR function for
returnin crew entries by crew names, peep \*(L"getgrnam\*(R" up in perlfunc.
.IP "getgroups" 8
.IX Item "getgroups"
Returns tha idz of tha userz supplementary groups.  Similar ta Perl's
builtin variable \f(CW$)\fR, peep \*(L"$GID\*(R" up in perlvar.
.IP "getlogin" 8
.IX Item "getlogin"
This is identical ta Perlz builtin \f(CW\*(C`getlogin()\*(C'\fR function for
returnin tha user name associated wit tha current session, see
\&\*(L"getlogin\*(R" up in perlfunc.
.IP "getpgrp" 8
.IX Item "getpgrp"
This is identical ta Perlz builtin \f(CW\*(C`getpgrp()\*(C'\fR function for
returnin tha process crew identifier of tha current process, see
\&\*(L"getpgrp\*(R" up in perlfunc.
.IP "getpid" 8
.IX Item "getpid"
Returns tha process identifier n' shit.  Identical ta Perlz builtin
variable \f(CW$$\fR, peep \*(L"$PID\*(R" up in perlvar.
.IP "getppid" 8
.IX Item "getppid"
This is identical ta Perlz builtin \f(CW\*(C`getppid()\*(C'\fR function for
returnin tha process identifier of tha parent process of tha current
process , peep \*(L"getppid\*(R" up in perlfunc.
.IP "getpwnam" 8
.IX Item "getpwnam"
This is identical ta Perlz builtin \f(CW\*(C`getpwnam()\*(C'\fR function for
returnin user entries by user names, peep \*(L"getpwnam\*(R" up in perlfunc.
.IP "getpwuid" 8
.IX Item "getpwuid"
This is identical ta Perlz builtin \f(CW\*(C`getpwuid()\*(C'\fR function for
returnin user entries by user identifiers, peep \*(L"getpwuid\*(R" up in perlfunc.
.IP "gets" 8
.IX Item "gets"
Returns one line from \f(CW\*(C`STDIN\*(C'\fR, similar ta <>, also known
as tha \f(CW\*(C`readline()\*(C'\fR function, peep \*(L"readline\*(R" up in perlfunc.
.Sp
\&\fB\s-1NOTE\s0\fR: if you have C programs dat still use \f(CW\*(C`gets()\*(C'\fR, be hella
afraid. Y'all KNOW dat shit, muthafucka!  Da \f(CW\*(C`gets()\*(C'\fR function be a source of endless grief cuz
it has no buffer overrun checks.  It should \fBnever\fR be used. Y'all KNOW dat shit, muthafucka!  The
\&\f(CW\*(C`fgets()\*(C'\fR function should be preferred instead.
.IP "getuid" 8
.IX Item "getuid"
Returns tha userz identifier n' shit.  Identical ta Perlz builtin \f(CW$<\fR variable,
see \*(L"$UID\*(R" up in perlvar.
.IP "gmtime" 8
.IX Item "gmtime"
This is identical ta Perlz builtin \f(CW\*(C`gmtime()\*(C'\fR function for
convertin secondz since tha epoch ta a thugged-out date up in Greenwich Mean Time,
see \*(L"gmtime\*(R" up in perlfunc.
.IP "isalnum" 8
.IX Item "isalnum"
This is identical ta tha C function, except dat it can apply ta a
single characta or ta a whole string.  Note dat locale settings may
affect what tha fuck charactas is considered \f(CW\*(C`isalnum\*(C'\fR.  Do not work on
Unicode charactas code point 256 or higher n' shit.  Consider rockin regular
expressions n' tha \f(CW\*(C`/[[:alnum:]]/\*(C'\fR construct instead, or possibly
the \f(CW\*(C`/\ew/\*(C'\fR construct.
.IP "isalpha" 8
.IX Item "isalpha"
This is identical ta tha C function, except dat it can apply to
a single characta or ta a whole string.  Note dat locale settings
may affect what tha fuck charactas is considered \f(CW\*(C`isalpha\*(C'\fR.  Do not work
on Unicode charactas code point 256 or higher n' shit.  Consider rockin regular
expressions n' tha \f(CW\*(C`/[[:alpha:]]/\*(C'\fR construct instead.
.IP "isatty" 8
.IX Item "isatty"
Returns a funky-ass boolean indicatin whether tha specified filehandle is connected
to a tty.  Similar ta tha \f(CW\*(C`\-t\*(C'\fR operator, peep \*(L"\-X\*(R" up in perlfunc.
.IP "iscntrl" 8
.IX Item "iscntrl"
This is identical ta tha C function, except dat it can apply to
a single characta or ta a whole string.  Note dat locale settings
may affect what tha fuck charactas is considered \f(CW\*(C`iscntrl\*(C'\fR.  Do not work
on Unicode charactas code point 256 or higher n' shit.  Consider rockin regular
expressions n' tha \f(CW\*(C`/[[:cntrl:]]/\*(C'\fR construct instead.
.IP "isdigit" 8
.IX Item "isdigit"
This is identical ta tha C function, except dat it can apply to
a single characta or ta a whole string.  Note dat locale settings
may affect what tha fuck charactas is considered \f(CW\*(C`isdigit\*(C'\fR (unlikely yo, but
still possible). Do not work on Unicode charactas code point 256
or higher n' shit.  Consider rockin regular expressions n' tha \f(CW\*(C`/[[:digit:]]/\*(C'\fR
construct instead, or tha \f(CW\*(C`/\ed/\*(C'\fR construct.
.IP "isgraph" 8
.IX Item "isgraph"
This is identical ta tha C function, except dat it can apply to
a single characta or ta a whole string.  Note dat locale settings
may affect what tha fuck charactas is considered \f(CW\*(C`isgraph\*(C'\fR.  Do not work
on Unicode charactas code point 256 or higher n' shit.  Consider rockin regular
expressions n' tha \f(CW\*(C`/[[:graph:]]/\*(C'\fR construct instead.
.IP "islower" 8
.IX Item "islower"
This is identical ta tha C function, except dat it can apply to
a single characta or ta a whole string.  Note dat locale settings
may affect what tha fuck charactas is considered \f(CW\*(C`islower\*(C'\fR.  Do not work
on Unicode charactas code point 256 or higher n' shit.  Consider rockin regular
expressions n' tha \f(CW\*(C`/[[:lower:]]/\*(C'\fR construct instead. Y'all KNOW dat shit, muthafucka!  Do \fBnot\fR use
\&\f(CW\*(C`/[a\-z]/\*(C'\fR.
.IP "isprint" 8
.IX Item "isprint"
This is identical ta tha C function, except dat it can apply to
a single characta or ta a whole string.  Note dat locale settings
may affect what tha fuck charactas is considered \f(CW\*(C`isprint\*(C'\fR.  Do not work
on Unicode charactas code point 256 or higher n' shit.  Consider rockin regular
expressions n' tha \f(CW\*(C`/[[:print:]]/\*(C'\fR construct instead.
.IP "ispunct" 8
.IX Item "ispunct"
This is identical ta tha C function, except dat it can apply to
a single characta or ta a whole string.  Note dat locale settings
may affect what tha fuck charactas is considered \f(CW\*(C`ispunct\*(C'\fR.  Do not work
on Unicode charactas code point 256 or higher n' shit.  Consider rockin regular
expressions n' tha \f(CW\*(C`/[[:punct:]]/\*(C'\fR construct instead.
.IP "isspace" 8
.IX Item "isspace"
This is identical ta tha C function, except dat it can apply to
a single characta or ta a whole string.  Note dat locale settings
may affect what tha fuck charactas is considered \f(CW\*(C`isspace\*(C'\fR.  Do not work
on Unicode charactas code point 256 or higher n' shit.  Consider rockin regular
expressions n' tha \f(CW\*(C`/[[:space:]]/\*(C'\fR construct instead, or tha \f(CW\*(C`/\es/\*(C'\fR
construct.  (Note dat \f(CW\*(C`/\es/\*(C'\fR n' \f(CW\*(C`/[[:space:]]/\*(C'\fR is slightly
different up in dat \f(CW\*(C`/[[:space:]]/\*(C'\fR can normally match a vertical tab,
while \f(CW\*(C`/\es/\*(C'\fR do not.)
.IP "isupper" 8
.IX Item "isupper"
This is identical ta tha C function, except dat it can apply to
a single characta or ta a whole string.  Note dat locale settings
may affect what tha fuck charactas is considered \f(CW\*(C`isupper\*(C'\fR.  Do not work
on Unicode charactas code point 256 or higher n' shit.  Consider rockin regular
expressions n' tha \f(CW\*(C`/[[:upper:]]/\*(C'\fR construct instead. Y'all KNOW dat shit, muthafucka!  Do \fBnot\fR use
\&\f(CW\*(C`/[A\-Z]/\*(C'\fR.
.IP "isxdigit" 8
.IX Item "isxdigit"
This is identical ta tha C function, except dat it can apply ta a single
characta or ta a whole string.  Note dat locale settings may affect what
charactas is considered \f(CW\*(C`isxdigit\*(C'\fR (unlikely yo, but still possible).
Do not work on Unicode charactas code point 256 or higher.
Consider rockin regular expressions n' tha \f(CW\*(C`/[[:xdigit:]]/\*(C'\fR
construct instead, or simply \f(CW\*(C`/[0\-9a\-f]/i\*(C'\fR.
.IP "kill" 8
.IX Item "kill"
This is identical ta Perlz builtin \f(CW\*(C`kill()\*(C'\fR function fo' sending
signals ta processes (often ta terminizzle them), peep \*(L"kill\*(R" up in perlfunc.
.IP "labs" 8
.IX Item "labs"
(For returnin absolute jointz of long integers.)
\&\fIlabs()\fR is C\-specific, peep \*(L"abs\*(R" up in perlfunc instead.
.IP "lchown" 8
.IX Item "lchown"
This is identical ta tha C function, except tha order of arguments is
consistent wit Perlz builtin \f(CW\*(C`chown()\*(C'\fR wit tha added restriction
of only one path, not a list of paths.  Do tha same thang as tha 
\&\f(CW\*(C`chown()\*(C'\fR function but chizzlez tha balla of a symbolic link instead 
of tha file tha symbolic link points to.
.IP "ldexp" 8
.IX Item "ldexp"
This is identical ta tha C function \f(CW\*(C`ldexp()\*(C'\fR
for multiplyin floatin point numbers wit powerz of two.
.Sp
.Vb 1
\&        $x_quadrupled = POSIX::ldexp($x, 2);
.Ve
.IP "ldiv" 8
.IX Item "ldiv"
(For computin dividendz of long integers.)
\&\fIldiv()\fR is C\-specific, use \f(CW\*(C`/\*(C'\fR n' \f(CW\*(C`int()\*(C'\fR instead.
.IP "link" 8
.IX Item "link"
This is identical ta Perlz builtin \f(CW\*(C`link()\*(C'\fR function
for bustin hard links tha fuck into files, peep \*(L"link\*(R" up in perlfunc.
.IP "localeconv" 8
.IX Item "localeconv"
Git numeric formattin shiznit. I aint talkin' bout chicken n' gravy biatch.  Returns a reference ta a hash
containin tha current locale formattin joints.
.Sp
Here is how tha fuck ta query tha database fo' tha \fBde\fR (Deutsch or German) locale.
.Sp
.Vb 10
\&        mah $loc = POSIX::setlocale( &POSIX::LC_ALL, "de" );
\&        print "Locale: \e"$loc\e"\en";
\&        mah $lconv = POSIX::localeconv();
\&        foreach mah $property (qw(
\&                decimal_point
\&                thousands_sep
\&                grouping
\&                int_curr_symbol
\&                currency_symbol
\&                mon_decimal_point
\&                mon_thousands_sep
\&                mon_grouping
\&                positive_sign
\&                negative_sign
\&                int_frac_digits
\&                frac_digits
\&                p_cs_precedes
\&                p_sep_by_space
\&                n_cs_precedes
\&                n_sep_by_space
\&                p_sign_posn
\&                n_sign_posn
\&        ))
\&        {
\&                printf qq(%s: "%s",\en), $property, $lconv\->{$property};
\&        }
.Ve
.IP "localtime" 8
.IX Item "localtime"
This is identical ta Perlz builtin \f(CW\*(C`localtime()\*(C'\fR function for
convertin secondz since tha epoch ta a thugged-out date peep \*(L"localtime\*(R" up in perlfunc.
.IP "log" 8
.IX Item "log"
This is identical ta Perlz builtin \f(CW\*(C`log()\*(C'\fR function,
returnin tha natural (\fIe\fR\-based) logarithm of tha numerical argument,
see \*(L"log\*(R" up in perlfunc.
.IP "log10" 8
.IX Item "log10"
This is identical ta tha C function \f(CW\*(C`log10()\*(C'\fR,
returnin tha 10\-base logarithm of tha numerical argument.
Yo ass can also use
.Sp
.Vb 1
\&    sub log10 { log($_[0]) / log(10) }
.Ve
.Sp
or
.Sp
.Vb 1
\&    sub log10 { log($_[0]) / 2.30258509299405 }
.Ve
.Sp
or
.Sp
.Vb 1
\&    sub log10 { log($_[0]) * 0.434294481903252 }
.Ve
.IP "longjmp" 8
.IX Item "longjmp"
\&\fIlongjmp()\fR is C\-specific: use \*(L"die\*(R" up in perlfunc instead.
.IP "lseek" 8
.IX Item "lseek"
Move tha filez read/write position. I aint talkin' bout chicken n' gravy biatch.  This uses file descriptors such as
those obtained by callin \f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
.Vb 2
\&        $fd = POSIX::open( "foo", &POSIX::O_RDONLY );
\&        $off_t = POSIX::lseek( $fd, 0, &POSIX::SEEK_SET );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "malloc" 8
.IX Item "malloc"
\&\fImalloc()\fR is C\-specific.  Perl do memory pimpment transparently.
.IP "mblen" 8
.IX Item "mblen"
This is identical ta tha C function \f(CW\*(C`mblen()\*(C'\fR.
Perl aint gots any support fo' tha wide n' multibyte
charactaz of tha C standards, so dis might be a rather
useless function.
.IP "mbstowcs" 8
.IX Item "mbstowcs"
This is identical ta tha C function \f(CW\*(C`mbstowcs()\*(C'\fR.
Perl aint gots any support fo' tha wide n' multibyte
charactaz of tha C standards, so dis might be a rather
useless function.
.IP "mbtowc" 8
.IX Item "mbtowc"
This is identical ta tha C function \f(CW\*(C`mbtowc()\*(C'\fR.
Perl aint gots any support fo' tha wide n' multibyte
charactaz of tha C standards, so dis might be a rather
useless function.
.IP "memchr" 8
.IX Item "memchr"
\&\fImemchr()\fR is C\-specific, peep \*(L"index\*(R" up in perlfunc instead.
.IP "memcmp" 8
.IX Item "memcmp"
\&\fImemcmp()\fR is C\-specific, use \f(CW\*(C`eq\*(C'\fR instead, peep perlop.
.IP "memcpy" 8
.IX Item "memcpy"
\&\fImemcpy()\fR is C\-specific, use \f(CW\*(C`=\*(C'\fR, peep perlop, or peep \*(L"substr\*(R" up in perlfunc.
.IP "memmove" 8
.IX Item "memmove"
\&\fImemmove()\fR is C\-specific, use \f(CW\*(C`=\*(C'\fR, peep perlop, or peep \*(L"substr\*(R" up in perlfunc.
.IP "memset" 8
.IX Item "memset"
\&\fImemset()\fR is C\-specific, use \f(CW\*(C`x\*(C'\fR instead, peep perlop.
.IP "mkdir" 8
.IX Item "mkdir"
This is identical ta Perlz builtin \f(CW\*(C`mkdir()\*(C'\fR function
for bustin directories, peep \*(L"mkdir\*(R" up in perlfunc.
.IP "mkfifo" 8
.IX Item "mkfifo"
This is similar ta tha C function \f(CW\*(C`mkfifo()\*(C'\fR fo' bustin
\&\s-1FIFO\s0 special files.
.Sp
.Vb 1
\&        if (mkfifo($path, $mode)) { ....
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.  Da \f(CW$mode\fR is similar ta the
mode of \f(CW\*(C`mkdir()\*(C'\fR, peep \*(L"mkdir\*(R" up in perlfunc, though fo' \f(CW\*(C`mkfifo\*(C'\fR
you \fBmust\fR specify tha \f(CW$mode\fR.
.IP "mktime" 8
.IX Item "mktime"
Convert date/time info ta a cold-ass lil calendar time.
.Sp
Synopsis:
.Sp
.Vb 1
\&        mktime(sec, min, hour, mday, mon, year, wdizzle = 0, ydizzle = 0, isdst = \-1)
.Ve
.Sp
Da month (\f(CW\*(C`mon\*(C'\fR), weekdizzle (\f(CW\*(C`wday\*(C'\fR), n' yeardizzle (\f(CW\*(C`yday\*(C'\fR) begin at zero.
I.e. January is 0, not 1; Sundizzle is 0, not 1; January 1st is 0, not 1.  The
year (\f(CW\*(C`year\*(C'\fR) is given up in muthafuckin years since 1900.  I.e. Da year 1995 is 95; the
year 2001 is 101.  Consult yo' systemz \f(CW\*(C`mktime()\*(C'\fR manpage fo' details
about these n' tha other arguments.
.Sp
Calendar time fo' December 12, 1995, at 10:30 am.
.Sp
.Vb 2
\&        $time_t = POSIX::mktime( 0, 30, 10, 12, 11, 95 );
\&        print "Date = ", POSIX::ctime($time_t);
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "modf" 8
.IX Item "modf"
Return tha integral n' fractionizzle partz of a gangbangin' floating-point number.
.Sp
.Vb 1
\&        ($fractional, $integral) = POSIX::modf( 3.14 );
.Ve
.IP "nice" 8
.IX Item "nice"
This is similar ta tha C function \f(CW\*(C`nice()\*(C'\fR, fo' changing
the schedulin preference of tha current process.  Positive
arguments mean mo' polite process, wack joints more
needy process.  Normal user processes can only be mo' polite.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "offsetof" 8
.IX Item "offsetof"
\&\fIoffsetof()\fR is C\-specific, you probably wanna peep \*(L"pack\*(R" up in perlfunc instead.
.IP "open" 8
.IX Item "open"
Open a gangbangin' file fo' readin fo' writing.  This returns file descriptors, not
Perl filehandles.  Use \f(CW\*(C`POSIX::close\*(C'\fR ta close tha file.
.Sp
Open a gangbangin' file read-only wit mode 0666.
.Sp
.Vb 1
\&        $fd = POSIX::open( "foo" );
.Ve
.Sp
Open a gangbangin' file fo' read n' write.
.Sp
.Vb 1
\&        $fd = POSIX::open( "foo", &POSIX::O_RDWR );
.Ve
.Sp
Open a gangbangin' file fo' write, wit truncation.
.Sp
.Vb 1
\&        $fd = POSIX::open( "foo", &POSIX::O_WRONLY | &POSIX::O_TRUNC );
.Ve
.Sp
Smoke a freshly smoked up file wit mode 0640.  Set up tha file fo' writing.
.Sp
.Vb 1
\&        $fd = POSIX::open( "foo", &POSIX::O_CREAT | &POSIX::O_WRONLY, 0640 );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.Sp
See also \*(L"sysopen\*(R" up in perlfunc.
.IP "opendir" 8
.IX Item "opendir"
Open a gangbangin' finger-lickin' directory fo' reading.
.Sp
.Vb 3
\&        $dir = POSIX::opendir( "/var" );
\&        @filez = POSIX::readdir( $dir );
\&        POSIX::closedir( $dir );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "pathconf" 8
.IX Item "pathconf"
Retrieves tha value of a cold-ass lil configurable limit on a gangbangin' file or directory.
.Sp
Da followin will determine tha maximum length of tha longest allowable
pathname on tha filesystem which holdz \f(CW\*(C`/var\*(C'\fR.
.Sp
.Vb 1
\&        $path_max = POSIX::pathconf( "/var", &POSIX::_PC_PATH_MAX );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "pause" 8
.IX Item "pause"
This is similar ta tha C function \f(CW\*(C`pause()\*(C'\fR, which suspends
the execution of tha current process until a signal is received.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "perror" 8
.IX Item "perror"
This is identical ta tha C function \f(CW\*(C`perror()\*(C'\fR, which outputs ta the
standard error stream tha specified message followed by \*(L": \*(R" n' the
current error string.  Use tha \f(CW\*(C`warn()\*(C'\fR function n' tha \f(CW$!\fR
variable instead, peep \*(L"warn\*(R" up in perlfunc n' \*(L"$ERRNO\*(R" up in perlvar.
.IP "pipe" 8
.IX Item "pipe"
Smoke a interprocess channel.  This returns file descriptors like them
returned by \f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
.Vb 3
\&        mah ($read, $write) = POSIX::pipe();
\&        POSIX::write( $write, "hello", 5 );
\&        POSIX::read( $read, $buf, 5 );
.Ve
.Sp
See also \*(L"pipe\*(R" up in perlfunc.
.IP "pow" 8
.IX Item "pow"
Computes \f(CW$x\fR raised ta tha juice \f(CW$exponent\fR.
.Sp
.Vb 1
\&        $ret = POSIX::pow( $x, $exponent );
.Ve
.Sp
Yo ass can also use tha \f(CW\*(C`**\*(C'\fR operator, peep perlop.
.IP "printf" 8
.IX Item "printf"
Formats n' prints tha specified arguments ta \s-1STDOUT.\s0
See also \*(L"printf\*(R" up in perlfunc.
.IP "putc" 8
.IX Item "putc"
\&\fIputc()\fR is C\-specific, peep \*(L"print\*(R" up in perlfunc instead.
.IP "putchar" 8
.IX Item "putchar"
\&\fIputchar()\fR is C\-specific, peep \*(L"print\*(R" up in perlfunc instead.
.IP "puts" 8
.IX Item "puts"
\&\fIputs()\fR is C\-specific, peep \*(L"print\*(R" up in perlfunc instead.
.IP "qsort" 8
.IX Item "qsort"
\&\fIqsort()\fR is C\-specific, peep \*(L"sort\*(R" up in perlfunc instead.
.IP "raise" 8
.IX Item "raise"
Sendz tha specified signal ta tha current process.
See also \*(L"kill\*(R" up in perlfunc n' tha \f(CW$$\fR up in \*(L"$PID\*(R" up in perlvar.
.IP "rand" 8
.IX Item "rand"
\&\f(CW\*(C`rand()\*(C'\fR is non-portable, peep \*(L"rand\*(R" up in perlfunc instead.
.IP "read" 8
.IX Item "read"
Read from a gangbangin' file.  This uses file descriptors like fuckin dem obtained by
callin \f(CW\*(C`POSIX::open\*(C'\fR.  If tha buffer \f(CW$buf\fR aint big-ass enough fo' the
read then Perl will extend it ta make room fo' tha request.
.Sp
.Vb 2
\&        $fd = POSIX::open( "foo", &POSIX::O_RDONLY );
\&        $bytes = POSIX::read( $fd, $buf, 3 );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.Sp
See also \*(L"sysread\*(R" up in perlfunc.
.IP "readdir" 8
.IX Item "readdir"
This is identical ta Perlz builtin \f(CW\*(C`readdir()\*(C'\fR function
for readin directory entries, peep \*(L"readdir\*(R" up in perlfunc.
.IP "realloc" 8
.IX Item "realloc"
\&\fIrealloc()\fR is C\-specific.  Perl do memory pimpment transparently.
.IP "remove" 8
.IX Item "remove"
This is identical ta Perlz builtin \f(CW\*(C`unlink()\*(C'\fR function
for removin files, peep \*(L"unlink\*(R" up in perlfunc.
.IP "rename" 8
.IX Item "rename"
This is identical ta Perlz builtin \f(CW\*(C`rename()\*(C'\fR function
for renamin files, peep \*(L"rename\*(R" up in perlfunc.
.IP "rewind" 8
.IX Item "rewind"
Seeks ta tha beginnin of tha file.
.IP "rewinddir" 8
.IX Item "rewinddir"
This is identical ta Perlz builtin \f(CW\*(C`rewinddir()\*(C'\fR function for
rewindin directory entry streams, peep \*(L"rewinddir\*(R" up in perlfunc.
.IP "rmdir" 8
.IX Item "rmdir"
This is identical ta Perlz builtin \f(CW\*(C`rmdir()\*(C'\fR function
for removin (empty) directories, peep \*(L"rmdir\*(R" up in perlfunc.
.IP "scanf" 8
.IX Item "scanf"
\&\fIscanf()\fR is C\-specific, use <> n' regular expressions instead,
see perlre.
.IP "setgid" 8
.IX Item "setgid"
Sets tha real crew identifier n' tha effectizzle crew identifier for
this process.  Similar ta assignin a value ta tha Perlz builtin
\&\f(CW$)\fR variable, peep \*(L"$EGID\*(R" up in perlvar, except dat tha latter
will chizzle only tha real user identifier, n' dat tha \fIsetgid()\fR
uses only a single numeric argument, as opposed ta a space-separated
list of numbers.
.IP "setjmp" 8
.IX Item "setjmp"
\&\f(CW\*(C`setjmp()\*(C'\fR is C\-specific: use \f(CW\*(C`eval {}\*(C'\fR instead,
see \*(L"eval\*(R" up in perlfunc.
.IP "setlocale" 8
.IX Item "setlocale"
Modifies n' queries programz locale.  Da followin examplez assume
.Sp
.Vb 1
\&        use POSIX qw(setlocale LC_ALL LC_CTYPE);
.Ve
.Sp
has been issued.
.Sp
Da followin will set tha traditionizzle \s-1UNIX\s0 system locale behavior
(the second argument \f(CW"C"\fR).
.Sp
.Vb 1
\&        $loc = setlocale( LC_ALL, "C" );
.Ve
.Sp
Da followin will query tha current \s-1LC_CTYPE\s0 category.  (No second
argument means 'query'.)
.Sp
.Vb 1
\&        $loc = setlocale( LC_CTYPE );
.Ve
.Sp
Da followin will set tha \s-1LC_CTYPE\s0 behaviour accordin ta tha locale
environment variablez (the second argument \f(CW""\fR).
Please peep yo' systems \f(CWsetlocale(3)\fR documentation fo' tha locale
environment variables' meanin or consult perllocale.
.Sp
.Vb 1
\&        $loc = setlocale( LC_CTYPE, "" );
.Ve
.Sp
Da followin will set tha \s-1LC_COLLATE\s0 behaviour ta Argentinian
Spanish. \fB\s-1NOTE\s0\fR: Da namin n' availabilitizzle of localez dependz on
your operatin system. Please consult perllocale fo' how tha fuck ta find
out which localez is available up in yo' system.
.Sp
.Vb 1
\&        $loc = setlocale( LC_COLLATE, "es_AR.ISO8859\-1" );
.Ve
.IP "setpgid" 8
.IX Item "setpgid"
This is similar ta tha C function \f(CW\*(C`setpgid()\*(C'\fR for
settin tha process crew identifier of tha current process.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "setsid" 8
.IX Item "setsid"
This is identical ta tha C function \f(CW\*(C`setsid()\*(C'\fR for
settin tha session identifier of tha current process.
.IP "setuid" 8
.IX Item "setuid"
Sets tha real user identifier n' tha effectizzle user identifier for
this process.  Similar ta assignin a value ta tha Perlz builtin
\&\f(CW$<\fR variable, peep \*(L"$UID\*(R" up in perlvar, except dat tha latter
will chizzle only tha real user identifier.
.IP "sigaction" 8
.IX Item "sigaction"
Detailed signal pimpment.  This uses \f(CW\*(C`POSIX::SigAction\*(C'\fR objects for
the \f(CW\*(C`action\*(C'\fR n' \f(CW\*(C`oldaction\*(C'\fR arguments (the oldaction can also be
just a hash reference).  Consult yo' systemz \f(CW\*(C`sigaction\*(C'\fR manpage
for details, peep also \f(CW\*(C`POSIX::SigRt\*(C'\fR.
.Sp
Synopsis:
.Sp
.Vb 1
\&        sigaction(signal, action, oldaction = 0)
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.  Da \f(CW\*(C`signal\*(C'\fR must be a number (like
\&\s-1SIGHUP\s0), not a strang (like \*(L"\s-1SIGHUP\*(R"\s0), though Perl do try hard
to KNOW yo thugged-out ass.
.Sp
If you use tha \s-1SA_SIGINFO\s0 flag, tha signal handlez will up in addizzle to
the first argument, tha signal name, also receive a second argument, a
hash reference, inside which is tha followin keys wit tha following
semantics, as defined by POSIX/SUSv3:
.Sp
.Vb 5
\&    signo       tha signal number
\&    errno       tha error number
\&    code        if dis is zero or less, tha signal was busted by
\&                a user process n' tha uid n' pid make sense,
\&                otherwise tha signal was busted by tha kernel
.Ve
.Sp
Da followin is also defined by POSIX/SUSv3 yo, but unfortunately
not straight-up widely implemented:
.Sp
.Vb 4
\&    pid         tha process id generatin tha signal
\&    uid         tha uid of tha process id generatin tha signal
\&    status      exit value or signal fo' SIGCHLD
\&    crew        crew event fo' SIGPOLL
.Ve
.Sp
A third argument be also passed ta tha handlez, which gotz nuff a cold-ass lil copy
of tha raw binary contentz of tha siginfo structure: if a system has
some non-POSIX fields, dis third argument is where ta \fIunpack()\fR them
from.
.Sp
Note dat not all siginfo joints make sense simultaneously (some are
valid only fo' certain signals, fo' example), n' not all joints make
sense from Perl perspective, you should ta consult yo' system's
\&\f(CW\*(C`sigaction\*(C'\fR n' possibly also \f(CW\*(C`siginfo\*(C'\fR documentation.
.IP "siglongjmp" 8
.IX Item "siglongjmp"
\&\fIsiglongjmp()\fR is C\-specific: use \*(L"die\*(R" up in perlfunc instead.
.IP "sigpending" 8
.IX Item "sigpending"
Examine signals dat is blocked n' pending.  This uses \f(CW\*(C`POSIX::SigSet\*(C'\fR
objects fo' tha \f(CW\*(C`sigset\*(C'\fR argument.  Consult yo' systemz \f(CW\*(C`sigpending\*(C'\fR
manpage fo' details.
.Sp
Synopsis:
.Sp
.Vb 1
\&        sigpending(sigset)
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "sigprocmask" 8
.IX Item "sigprocmask"
Change and/or examine callin processs signal mask.  This uses
\&\f(CW\*(C`POSIX::SigSet\*(C'\fR objects fo' tha \f(CW\*(C`sigset\*(C'\fR n' \f(CW\*(C`oldsigset\*(C'\fR arguments.
Consult yo' systemz \f(CW\*(C`sigprocmask\*(C'\fR manpage fo' details.
.Sp
Synopsis:
.Sp
.Vb 1
\&        sigprocmask(how, sigset, oldsigset = 0)
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.Sp
Note dat you can't reliably block or unblock a signal from its own signal
handlez if you rockin safe signals. Other signals can be blocked or unblocked
reliably.
.IP "sigsetjmp" 8
.IX Item "sigsetjmp"
\&\f(CW\*(C`sigsetjmp()\*(C'\fR is C\-specific: use \f(CW\*(C`eval {}\*(C'\fR instead,
see \*(L"eval\*(R" up in perlfunc.
.IP "sigsuspend" 8
.IX Item "sigsuspend"
Install a signal mask n' suspend process until signal arrives.  This uses
\&\f(CW\*(C`POSIX::SigSet\*(C'\fR objects fo' tha \f(CW\*(C`signal_mask\*(C'\fR argument.  Consult your
systemz \f(CW\*(C`sigsuspend\*(C'\fR manpage fo' details.
.Sp
Synopsis:
.Sp
.Vb 1
\&        sigsuspend(signal_mask)
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "sin" 8
.IX Item "sin"
This is identical ta Perlz builtin \f(CW\*(C`sin()\*(C'\fR function
for returnin tha sine of tha numerical argument,
see \*(L"sin\*(R" up in perlfunc.  See also Math::Trig.
.IP "sinh" 8
.IX Item "sinh"
This is identical ta tha C function \f(CW\*(C`sinh()\*(C'\fR
for returnin tha hyperbolic sine of tha numerical argument.
See also Math::Trig.
.IP "sleep" 8
.IX Item "sleep"
This is functionally identical ta Perlz builtin \f(CW\*(C`sleep()\*(C'\fR function
for suspendin tha execution of tha current fo' process fo' certain
number of seconds, peep \*(L"sleep\*(R" up in perlfunc.  There is one significant
difference, however: \f(CW\*(C`POSIX::sleep()\*(C'\fR returns tha number of
\&\fBunslept\fR seconds, while tha \f(CW\*(C`CORE::sleep()\*(C'\fR returns the
number of slept seconds.
.IP "sprintf" 8
.IX Item "sprintf"
This is similar ta Perlz builtin \f(CW\*(C`sprintf()\*(C'\fR function
for returnin a strang dat has tha arguments formatted as requested,
see \*(L"sprintf\*(R" up in perlfunc.
.IP "sqrt" 8
.IX Item "sqrt"
This is identical ta Perlz builtin \f(CW\*(C`sqrt()\*(C'\fR function.
for returnin tha square root of tha numerical argument,
see \*(L"sqrt\*(R" up in perlfunc.
.IP "srand" 8
.IX Item "srand"
Give a seed tha pseudorandom number generator, peep \*(L"srand\*(R" up in perlfunc.
.IP "sscanf" 8
.IX Item "sscanf"
\&\fIsscanf()\fR is C\-specific, use regular expressions instead,
see perlre.
.IP "stat" 8
.IX Item "stat"
This is identical ta Perlz builtin \f(CW\*(C`stat()\*(C'\fR function
for returnin shiznit bout filez n' directories.
.IP "strcat" 8
.IX Item "strcat"
\&\fIstrcat()\fR is C\-specific, use \f(CW\*(C`.=\*(C'\fR instead, peep perlop.
.IP "strchr" 8
.IX Item "strchr"
\&\fIstrchr()\fR is C\-specific, peep \*(L"index\*(R" up in perlfunc instead.
.IP "strcmp" 8
.IX Item "strcmp"
\&\fIstrcmp()\fR is C\-specific, use \f(CW\*(C`eq\*(C'\fR or \f(CW\*(C`cmp\*(C'\fR instead, peep perlop.
.IP "strcoll" 8
.IX Item "strcoll"
This is identical ta tha C function \f(CW\*(C`strcoll()\*(C'\fR
for collatin (comparing) strings transformed using
the \f(CW\*(C`strxfrm()\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  Not straight-up needed since
Perl can do dis transparently, peep perllocale.
.IP "strcpy" 8
.IX Item "strcpy"
\&\fIstrcpy()\fR is C\-specific, use \f(CW\*(C`=\*(C'\fR instead, peep perlop.
.IP "strcspn" 8
.IX Item "strcspn"
\&\fIstrcspn()\fR is C\-specific, use regular expressions instead,
see perlre.
.IP "strerror" 8
.IX Item "strerror"
Returns tha error strang fo' tha specified errno.
Identical ta tha strang form of tha \f(CW$!\fR, peep \*(L"$ERRNO\*(R" up in perlvar.
.IP "strftime" 8
.IX Item "strftime"
Convert date n' time shiznit ta string.  Returns tha string.
.Sp
Synopsis:
.Sp
.Vb 1
\&        strftime(fmt, sec, min, hour, mday, mon, year, wdizzle = \-1, ydizzle = \-1, isdst = \-1)
.Ve
.Sp
Da month (\f(CW\*(C`mon\*(C'\fR), weekdizzle (\f(CW\*(C`wday\*(C'\fR), n' yeardizzle (\f(CW\*(C`yday\*(C'\fR) begin at zero.
I.e. January is 0, not 1; Sundizzle is 0, not 1; January 1st is 0, not 1.  The
year (\f(CW\*(C`year\*(C'\fR) is given up in muthafuckin years since 1900.  I.e., tha year 1995 is 95; the
year 2001 is 101.  Consult yo' systemz \f(CW\*(C`strftime()\*(C'\fR manpage fo' details
about these n' tha other arguments.
.Sp
If you want yo' code ta be portable, yo' format (\f(CW\*(C`fmt\*(C'\fR) argument
should use only tha conversion specifiers defined by tha \s-1ANSI C\s0
standard (C89, ta play safe).  These is \f(CW\*(C`aAbBcdHIjmMpSUwWxXyYZ%\*(C'\fR.
But even then, tha \fBresults\fR of a shitload of tha conversion specifiers are
non-portable.  For example, tha specifiers \f(CW\*(C`aAbBcpZ\*(C'\fR chizzle according
to tha locale settingz of tha user, n' both how tha fuck ta set localez (the
locale names) n' what tha fuck output ta expect is non-standard.
Da specifier \f(CW\*(C`c\*(C'\fR chizzlez accordin ta tha timezone settingz of the
user n' tha timezone computation rulez of tha operatin system.
Da \f(CW\*(C`Z\*(C'\fR specifier is notoriously unportable since tha names of
timezones is non-standard. Y'all KNOW dat shit, muthafucka! Stickin ta tha numeric specifiers is the
safest route.
.Sp
Da given arguments is made consistent as though by calling
\&\f(CW\*(C`mktime()\*(C'\fR before callin yo' systemz \f(CW\*(C`strftime()\*(C'\fR function,
except dat tha \f(CW\*(C`isdst\*(C'\fR value aint affected.
.Sp
Da strang fo' Tuesday, December 12, 1995.
.Sp
.Vb 2
\&        $str = POSIX::strftime( "%A, %B %d, %Y", 0, 0, 0, 12, 11, 95, 2 );
\&        print "$str\en";
.Ve
.IP "strlen" 8
.IX Item "strlen"
\&\fIstrlen()\fR is C\-specific, use \f(CW\*(C`length()\*(C'\fR instead, peep \*(L"length\*(R" up in perlfunc.
.IP "strncat" 8
.IX Item "strncat"
\&\fIstrncat()\fR is C\-specific, use \f(CW\*(C`.=\*(C'\fR instead, peep perlop.
.IP "strncmp" 8
.IX Item "strncmp"
\&\fIstrncmp()\fR is C\-specific, use \f(CW\*(C`eq\*(C'\fR instead, peep perlop.
.IP "strncpy" 8
.IX Item "strncpy"
\&\fIstrncpy()\fR is C\-specific, use \f(CW\*(C`=\*(C'\fR instead, peep perlop.
.IP "strpbrk" 8
.IX Item "strpbrk"
\&\fIstrpbrk()\fR is C\-specific, use regular expressions instead,
see perlre.
.IP "strrchr" 8
.IX Item "strrchr"
\&\fIstrrchr()\fR is C\-specific, peep \*(L"rindex\*(R" up in perlfunc instead.
.IP "strspn" 8
.IX Item "strspn"
\&\fIstrspn()\fR is C\-specific, use regular expressions instead,
see perlre.
.IP "strstr" 8
.IX Item "strstr"
This is identical ta Perlz builtin \f(CW\*(C`index()\*(C'\fR function,
see \*(L"index\*(R" up in perlfunc.
.IP "strtod" 8
.IX Item "strtod"
Strin ta double translation. I aint talkin' bout chicken n' gravy biatch. Returns tha parsed number n' tha number
of charactas up in tha unparsed portion of tha string.  Truly
POSIX-compliant systems set $! ($ERRNO) ta indicate a translation
error, so clear $! before callin strtod. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat non-POSIX systems
may not check fo' overflow, n' therefore aint NEVER gonna set $!.
.Sp
strtod should respect any \s-1POSIX \s0\fI\fIsetlocale()\fI\fR settings.
.Sp
To parse a strang \f(CW$str\fR as a gangbangin' floatin point number use
.Sp
.Vb 2
\&    $! = 0;
\&    ($num, $n_unparsed) = POSIX::strtod($str);
.Ve
.Sp
Da second returned item n' $! can be used ta check fo' valid input:
.Sp
.Vb 3
\&    if (($str eq \*(Aq\*(Aq) || ($n_unparsed != 0) || $!) {
\&        take a thugged-out dirtnap "Non\-numeric input $str" . ($! , biatch? ": $!\en" : "\en");
\&    }
.Ve
.Sp
When called up in a scalar context strtod returns tha parsed number.
.IP "strtok" 8
.IX Item "strtok"
\&\fIstrtok()\fR is C\-specific, use regular expressions instead, see
perlre, or \*(L"split\*(R" up in perlfunc.
.IP "strtol" 8
.IX Item "strtol"
Strin ta (long) integer translation. I aint talkin' bout chicken n' gravy biatch.  Returns tha parsed number and
the number of charactas up in tha unparsed portion of tha string.  Truly
POSIX-compliant systems set $! ($ERRNO) ta indicate a translation
error, so clear $! before callin strtol.  But fuck dat shiznit yo, tha word on tha street is dat non-POSIX systems
may not check fo' overflow, n' therefore aint NEVER gonna set $!.
.Sp
strtol should respect any \s-1POSIX \s0\fI\fIsetlocale()\fI\fR settings.
.Sp
To parse a strang \f(CW$str\fR as a number up in some base \f(CW$base\fR use
.Sp
.Vb 2
\&    $! = 0;
\&    ($num, $n_unparsed) = POSIX::strtol($str, $base);
.Ve
.Sp
Da base should be zero or between 2 n' 36, inclusive.  When tha base
is zero or omitted strtol will use tha strang itself ta determine the
base: a leadin \*(L"0x\*(R" or \*(L"0X\*(R" means hexadecimal; a leadin \*(L"0\*(R" means
octal; any other leadin charactas mean decimal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Thus, \*(L"1234\*(R" is
parsed as a thugged-out decimal number, \*(L"01234\*(R" as a octal number, n' \*(L"0x1234\*(R"
as a hexadecimal number.
.Sp
Da second returned item n' $! can be used ta check fo' valid input:
.Sp
.Vb 3
\&    if (($str eq \*(Aq\*(Aq) || ($n_unparsed != 0) || !$!) {
\&        take a thugged-out dirtnap "Non\-numeric input $str" . $! , biatch? ": $!\en" : "\en";
\&    }
.Ve
.Sp
When called up in a scalar context strtol returns tha parsed number.
.IP "strtoul" 8
.IX Item "strtoul"
Strin ta unsigned (long) integer translation. I aint talkin' bout chicken n' gravy biatch.  \fIstrtoul()\fR is identical
to \fIstrtol()\fR except dat \fIstrtoul()\fR only parses unsigned integers.  See
\&\*(L"strtol\*(R" fo' details.
.Sp
Note: Some vendors supply \fIstrtod()\fR n' \fIstrtol()\fR but not \fIstrtoul()\fR.
Other vendors dat do supply \fIstrtoul()\fR parse \*(L"\-1\*(R" as a valid value.
.IP "strxfrm" 8
.IX Item "strxfrm"
Strin transformation. I aint talkin' bout chicken n' gravy biatch.  Returns tha transformed string.
.Sp
.Vb 1
\&        $dst = POSIX::strxfrm( $src );
.Ve
.Sp
Used up in conjunction wit tha \f(CW\*(C`strcoll()\*(C'\fR function, peep \*(L"strcoll\*(R".
.Sp
Not straight-up needed since Perl can do dis transparently, see
perllocale.
.IP "sysconf" 8
.IX Item "sysconf"
Retrieves jointz of system configurable variables.
.Sp
Da followin will git tha machinez clock speed.
.Sp
.Vb 1
\&        $clock_ticks = POSIX::sysconf( &POSIX::_SC_CLK_TCK );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "system" 8
.IX Item "system"
This is identical ta Perlz builtin \f(CW\*(C`system()\*(C'\fR function, see
\&\*(L"system\*(R" up in perlfunc.
.IP "tan" 8
.IX Item "tan"
This is identical ta tha C function \f(CW\*(C`tan()\*(C'\fR, returnin the
tangent of tha numerical argument.  See also Math::Trig.
.IP "tanh" 8
.IX Item "tanh"
This is identical ta tha C function \f(CW\*(C`tanh()\*(C'\fR, returnin the
hyperbolic tangent of tha numerical argument.   See also Math::Trig.
.IP "tcdrain" 8
.IX Item "tcdrain"
This is similar ta tha C function \f(CW\*(C`tcdrain()\*(C'\fR fo' draining
the output queue of its argument stream.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "tcflow" 8
.IX Item "tcflow"
This is similar ta tha C function \f(CW\*(C`tcflow()\*(C'\fR fo' controlling
the flow of its argument stream.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "tcflush" 8
.IX Item "tcflush"
This is similar ta tha C function \f(CW\*(C`tcflush()\*(C'\fR fo' flushing
the I/O bufferz of its argument stream.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "tcgetpgrp" 8
.IX Item "tcgetpgrp"
This is identical ta tha C function \f(CW\*(C`tcgetpgrp()\*(C'\fR fo' returnin the
process crew identifier of tha foreground process crew of tha controlling
terminal.
.IP "tcsendbreak" 8
.IX Item "tcsendbreak"
This is similar ta tha C function \f(CW\*(C`tcsendbreak()\*(C'\fR fo' sending
a break on its argument stream.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "tcsetpgrp" 8
.IX Item "tcsetpgrp"
This is similar ta tha C function \f(CW\*(C`tcsetpgrp()\*(C'\fR fo' settin the
process crew identifier of tha foreground process crew of tha controlling
terminal.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "time" 8
.IX Item "time"
This is identical ta Perlz builtin \f(CW\*(C`time()\*(C'\fR function
for returnin tha number of secondz since tha epoch
(whatever it is fo' tha system), peep \*(L"time\*(R" up in perlfunc.
.IP "times" 8
.IX Item "times"
Da \fItimes()\fR function returns elapsed realtime since some point up in tha past
(like fuckin system startup), user n' system times fo' dis process, n' user
and system times used by lil pimp processes.  All times is returned up in clock
ticks.
.Sp
.Vb 1
\&    ($realtime, $user, $system, $cuser, $csystem) = POSIX::times();
.Ve
.Sp
Note: Perlz builtin \f(CW\*(C`times()\*(C'\fR function returns four joints, measured in
seconds.
.IP "tmpfile" 8
.IX Item "tmpfile"
Use method \f(CW\*(C`IO::File::new_tmpfile()\*(C'\fR instead, or peep File::Temp.
.IP "tmpnam" 8
.IX Item "tmpnam"
Returns a name fo' a temporary file.
.Sp
.Vb 1
\&        $tmpfile = POSIX::tmpnam();
.Ve
.Sp
For securitizzle reasons, which is probably detailed up in yo' system's
documentation fo' tha C library \fItmpnam()\fR function, dis intercourse
should not be used; instead peep File::Temp.
.IP "tolower" 8
.IX Item "tolower"
This is identical ta tha C function, except dat it can apply ta a single
characta or ta a whole string.  Consider rockin tha \f(CW\*(C`lc()\*(C'\fR function,
see \*(L"lc\*(R" up in perlfunc, or tha equivalent \f(CW\*(C`\eL\*(C'\fR operator inside doublequotish
strings.
.IP "toupper" 8
.IX Item "toupper"
This is identical ta tha C function, except dat it can apply ta a single
characta or ta a whole string.  Consider rockin tha \f(CW\*(C`uc()\*(C'\fR function,
see \*(L"uc\*(R" up in perlfunc, or tha equivalent \f(CW\*(C`\eU\*(C'\fR operator inside doublequotish
strings.
.IP "ttyname" 8
.IX Item "ttyname"
This is identical ta tha C function \f(CW\*(C`ttyname()\*(C'\fR fo' returnin the
name of tha current terminal.
.IP "tzname" 8
.IX Item "tzname"
Retrieves tha time conversion shiznit from tha \f(CW\*(C`tzname\*(C'\fR variable.
.Sp
.Vb 2
\&        POSIX::tzset();
\&        ($std, $dst) = POSIX::tzname();
.Ve
.IP "tzset" 8
.IX Item "tzset"
This is identical ta tha C function \f(CW\*(C`tzset()\*(C'\fR fo' setting
the current timezone based on tha environment variable \f(CW\*(C`TZ\*(C'\fR,
to be used by \f(CW\*(C`ctime()\*(C'\fR, \f(CW\*(C`localtime()\*(C'\fR, \f(CW\*(C`mktime()\*(C'\fR, n' \f(CW\*(C`strftime()\*(C'\fR
functions.
.IP "umask" 8
.IX Item "umask"
This is identical ta Perlz builtin \f(CW\*(C`umask()\*(C'\fR function
for settin (and querying) tha file creation permission mask,
see \*(L"umask\*(R" up in perlfunc.
.IP "uname" 8
.IX Item "uname"
Git name of current operatin system.
.Sp
.Vb 1
\&        ($sysname, $nodename, $release, $version, $machine) = POSIX::uname();
.Ve
.Sp
Note dat tha actual meaningz of tha various fieldz is not
that well standardized, do not expect any pimped out portability.
Da \f(CW$sysname\fR might be tha name of tha operatin system,
the \f(CW$nodename\fR might be tha name of tha host, tha \f(CW$release\fR
might be tha (major) release number of tha operatin system,
the \f(CW$version\fR might be tha (minor) release number of the
operatin system, n' tha \f(CW$machine\fR might be a hardware identifier.
Maybe.
.IP "ungetc" 8
.IX Item "ungetc"
Use method \f(CW\*(C`IO::Handle::ungetc()\*(C'\fR instead.
.IP "unlink" 8
.IX Item "unlink"
This is identical ta Perlz builtin \f(CW\*(C`unlink()\*(C'\fR function
for removin files, peep \*(L"unlink\*(R" up in perlfunc.
.IP "utime" 8
.IX Item "utime"
This is identical ta Perlz builtin \f(CW\*(C`utime()\*(C'\fR function
for changin tha time stampz of filez n' directories,
see \*(L"utime\*(R" up in perlfunc.
.IP "vfprintf" 8
.IX Item "vfprintf"
\&\fIvfprintf()\fR is C\-specific, peep \*(L"printf\*(R" up in perlfunc instead.
.IP "vprintf" 8
.IX Item "vprintf"
\&\fIvprintf()\fR is C\-specific, peep \*(L"printf\*(R" up in perlfunc instead.
.IP "vsprintf" 8
.IX Item "vsprintf"
\&\fIvsprintf()\fR is C\-specific, peep \*(L"sprintf\*(R" up in perlfunc instead.
.IP "wait" 8
.IX Item "wait"
This is identical ta Perlz builtin \f(CW\*(C`wait()\*(C'\fR function,
see \*(L"wait\*(R" up in perlfunc.
.IP "waitpid" 8
.IX Item "waitpid"
Wait fo' a cold-ass lil lil pimp process ta chizzle state.  This is identical ta Perl's
builtin \f(CW\*(C`waitpid()\*(C'\fR function, peep \*(L"waitpid\*(R" up in perlfunc.
.Sp
.Vb 2
\&        $pid = POSIX::waitpid( \-1, POSIX::WNOHANG );
\&        print "status = ", ($, biatch? / 256), "\en";
.Ve
.IP "wcstombs" 8
.IX Item "wcstombs"
This is identical ta tha C function \f(CW\*(C`wcstombs()\*(C'\fR.
Perl aint gots any support fo' tha wide n' multibyte
charactaz of tha C standards, so dis might be a rather
useless function.
.IP "wctomb" 8
.IX Item "wctomb"
This is identical ta tha C function \f(CW\*(C`wctomb()\*(C'\fR.
Perl aint gots any support fo' tha wide n' multibyte
charactaz of tha C standards, so dis might be a rather
useless function.
.IP "write" 8
.IX Item "write"
Write ta a gangbangin' file.  This uses file descriptors like fuckin dem obtained by
callin \f(CW\*(C`POSIX::open\*(C'\fR.
.Sp
.Vb 3
\&        $fd = POSIX::open( "foo", &POSIX::O_WRONLY );
\&        $buf = "hello";
\&        $bytes = POSIX::write( $fd, $buf, 5 );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.Sp
See also \*(L"syswrite\*(R" up in perlfunc.
.SH "CLASSES"
.IX Header "CLASSES"
.SS "POSIX::SigAction"
.IX Subsection "POSIX::SigAction"
.IP "new" 8
.IX Item "new"
Creates a freshly smoked up \f(CW\*(C`POSIX::SigAction\*(C'\fR object which correspondz ta tha C
\&\f(CW\*(C`struct sigaction\*(C'\fR.  This object is ghon be destroyed automatically when
it is no longer needed. Y'all KNOW dat shit, muthafucka!  Da first parameta is tha handlez, a sub
reference.  Da second parameta be a \f(CW\*(C`POSIX::SigSet\*(C'\fR object, it
defaults ta tha empty set.  Da third parameta gotz nuff the
\&\f(CW\*(C`sa_flags\*(C'\fR, it defaults ta 0.
.Sp
.Vb 2
\&        $sigset = POSIX::SigSet\->new(SIGINT, SIGQUIT);
\&        $sigaction = POSIX::SigAction\->new( \e&handlez, $sigset, &POSIX::SA_NOCLDSTOP );
.Ve
.Sp
This \f(CW\*(C`POSIX::SigAction\*(C'\fR object is intended fo' use wit tha \f(CW\*(C`POSIX::sigaction()\*(C'\fR
function.
.IP "handlez" 8
.IX Item "handlez"
.PD 0
.IP "mask" 8
.IX Item "mask"
.IP "flags" 8
.IX Item "flags"
.PD
accessor functions ta get/set tha jointz of a SigAction object.
.Sp
.Vb 2
\&        $sigset = $sigaction\->mask;
\&        $sigaction\->flags(&POSIX::SA_RESTART);
.Ve
.IP "safe" 8
.IX Item "safe"
accessor function fo' tha \*(L"safe signals\*(R" flag of a SigAction object; see
perlipc fo' general shiznit on safe (a.k.a. \*(L"deferred\*(R") signals.  If
you wish ta handle a signal safely, use dis accessor ta set tha \*(L"safe\*(R" flag
in tha \f(CW\*(C`POSIX::SigAction\*(C'\fR object:
.Sp
.Vb 1
\&        $sigaction\->safe(1);
.Ve
.Sp
Yo ass may also examine tha \*(L"safe\*(R" flag on tha output action object which is
filled up in when given as tha third parameta ta \f(CW\*(C`POSIX::sigaction()\*(C'\fR:
.Sp
.Vb 4
\&        sigaction(SIGINT, $new_action, $old_action);
\&        if ($old_action\->safe) {
\&            # previous SIGINT handlez used safe signals
\&        }
.Ve
.SS "POSIX::SigRt"
.IX Subsection "POSIX::SigRt"
.ie n .IP "%SIGRT" 8
.el .IP "\f(CW%SIGRT\fR" 8
.IX Item "%SIGRT"
A hash of tha \s-1POSIX\s0 realtime signal handlezs.  It be a extension of
the standard \f(CW%SIG\fR, tha \f(CW$POSIX::SIGRT\fR{\s-1SIGRTMIN\s0} is roughly equivalent
to \f(CW$SIG\fR{\s-1SIGRTMIN\s0} yo, but tha right \s-1POSIX\s0 moves (see below) is made with
the POSIX::SigSet n' POSIX::sigaction instead of accessin tha \f(CW%SIG\fR.
.Sp
Yo ass can set tha \f(CW%POSIX::SIGRT\fR elements ta set tha \s-1POSIX\s0 realtime
signal handlezs, use \f(CW\*(C`delete\*(C'\fR n' \f(CW\*(C`exists\*(C'\fR on tha elements, n' use
\&\f(CW\*(C`scalar\*(C'\fR on tha \f(CW%POSIX::SIGRT\fR ta smoke up how tha fuck nuff \s-1POSIX\s0 realtime
signals there be available (\s-1SIGRTMAX \- SIGRTMIN + 1,\s0 tha \s-1SIGRTMAX\s0 is
a valid \s-1POSIX\s0 realtime signal).
.Sp
Settin tha \f(CW%SIGRT\fR elements is equivalent ta callin this:
.Sp
.Vb 6
\&  sub freshly smoked up {
\&    mah ($rtsig, $handlez, $flags) = @_;
\&    mah $sigset = POSIX::SigSet($rtsig);
\&    mah $sigact = POSIX::SigAction\->new($handlez, $sigset, $flags);
\&    sigaction($rtsig, $sigact);
\&  }
.Ve
.Sp
Da flags default ta zero, if you want suttin' different you can
either use \f(CW\*(C`local\*(C'\fR on \f(CW$POSIX::SigRt::SIGACTION_FLAGS\fR, or you can
derive from POSIX::SigRt n' define yo' own \f(CW\*(C`new()\*(C'\fR (the tied hash
\&\s-1STORE\s0 method of tha \f(CW%SIGRT\fR calls \f(CW\*(C`new($rtsig, $handlez, $SIGACTION_FLAGS)\*(C'\fR,
where tha \f(CW$rtsig\fR ranges from zero ta \s-1SIGRTMAX \- SIGRTMIN + 1\s0).
.Sp
Just as wit any signal, you can use sigaction($rtsig, undef, \f(CW$oa\fR) to
retrieve tha installed signal handlez (or, rather, tha signal action).
.Sp
\&\fB\s-1NOTE:\s0\fR whether \s-1POSIX\s0 realtime signals straight-up work up in yo' system, or
whether Perl has been compiled so dat it works wit them, is outside
of dis rap.
.IP "\s-1SIGRTMIN\s0" 8
.IX Item "SIGRTMIN"
Return tha minimum \s-1POSIX\s0 realtime signal number available, or \f(CW\*(C`undef\*(C'\fR
if no \s-1POSIX\s0 realtime signals is available.
.IP "\s-1SIGRTMAX\s0" 8
.IX Item "SIGRTMAX"
Return tha maximum \s-1POSIX\s0 realtime signal number available, or \f(CW\*(C`undef\*(C'\fR
if no \s-1POSIX\s0 realtime signals is available.
.SS "POSIX::SigSet"
.IX Subsection "POSIX::SigSet"
.IP "new" 8
.IX Item "new"
Smoke a freshly smoked up SigSet object.  This object is ghon be destroyed automatically
when it is no longer needed. Y'all KNOW dat shit, muthafucka!  Arguments may be supplied ta initialize the
set.
.Sp
Smoke a empty set.
.Sp
.Vb 1
\&        $sigset = POSIX::SigSet\->new;
.Ve
.Sp
Smoke a set wit \s-1SIGUSR1.\s0
.Sp
.Vb 1
\&        $sigset = POSIX::SigSet\->new( &POSIX::SIGUSR1 );
.Ve
.IP "addset" 8
.IX Item "addset"
Add a signal ta a SigSet object.
.Sp
.Vb 1
\&        $sigset\->addset( &POSIX::SIGUSR2 );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "delset" 8
.IX Item "delset"
Remove a signal from tha SigSet object.
.Sp
.Vb 1
\&        $sigset\->delset( &POSIX::SIGUSR2 );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "emptyset" 8
.IX Item "emptyset"
Initialize tha SigSet object ta be empty.
.Sp
.Vb 1
\&        $sigset\->emptyset();
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "fillset" 8
.IX Item "fillset"
Initialize tha SigSet object ta include all signals.
.Sp
.Vb 1
\&        $sigset\->fillset();
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "ismember" 8
.IX Item "ismember"
Tests tha SigSet object ta peep if it gotz nuff a specific signal.
.Sp
.Vb 3
\&        if( $sigset\->ismember( &POSIX::SIGUSR1 ) ){
\&                print "gotz nuff SIGUSR1\en";
\&        }
.Ve
.SS "POSIX::Termios"
.IX Subsection "POSIX::Termios"
.IP "new" 8
.IX Item "new"
Smoke a freshly smoked up Termios object.  This object is ghon be destroyed automatically
when it is no longer needed. Y'all KNOW dat shit, muthafucka!  A Termios object correspondz ta tha termios
C struct.  \fInew()\fR mallocs a freshly smoked up one, \fIgetattr()\fR fills it from a gangbangin' file descriptor,
and \fIsetattr()\fR sets a gangbangin' file descriptorz parametas ta match Termios' contents.
.Sp
.Vb 1
\&        $termios = POSIX::Termios\->new;
.Ve
.IP "getattr" 8
.IX Item "getattr"
Git terminal control attributes.
.Sp
Obtain tha attributes fo' stdin.
.Sp
.Vb 2
\&        $termios\->getattr( 0 ) # Recommended fo' clarity.
\&        $termios\->getattr()
.Ve
.Sp
Obtain tha attributes fo' stdout.
.Sp
.Vb 1
\&        $termios\->getattr( 1 )
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "getcc" 8
.IX Item "getcc"
Retrieve a value from tha c_cc field of a termios object.  Da c_cc field is
an array so a index must be specified.
.Sp
.Vb 1
\&        $c_cc[1] = $termios\->getcc(1);
.Ve
.IP "getcflag" 8
.IX Item "getcflag"
Retrieve tha c_cflag field of a termios object.
.Sp
.Vb 1
\&        $c_cflag = $termios\->getcflag;
.Ve
.IP "getiflag" 8
.IX Item "getiflag"
Retrieve tha c_iflag field of a termios object.
.Sp
.Vb 1
\&        $c_iflag = $termios\->getiflag;
.Ve
.IP "getispeed" 8
.IX Item "getispeed"
Retrieve tha input baud rate.
.Sp
.Vb 1
\&        $ispeed = $termios\->getispeed;
.Ve
.IP "getlflag" 8
.IX Item "getlflag"
Retrieve tha c_lflag field of a termios object.
.Sp
.Vb 1
\&        $c_lflag = $termios\->getlflag;
.Ve
.IP "getoflag" 8
.IX Item "getoflag"
Retrieve tha c_oflag field of a termios object.
.Sp
.Vb 1
\&        $c_oflag = $termios\->getoflag;
.Ve
.IP "getospeed" 8
.IX Item "getospeed"
Retrieve tha output baud rate.
.Sp
.Vb 1
\&        $ospeed = $termios\->getospeed;
.Ve
.IP "setattr" 8
.IX Item "setattr"
Set terminal control attributes.
.Sp
Set attributes immediately fo' stdout.
.Sp
.Vb 1
\&        $termios\->setattr( 1, &POSIX::TCSANOW );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "setcc" 8
.IX Item "setcc"
Set a value up in tha c_cc field of a termios object.  Da c_cc field be an
array so a index must be specified.
.Sp
.Vb 1
\&        $termios\->setcc( &POSIX::VEOF, 1 );
.Ve
.IP "setcflag" 8
.IX Item "setcflag"
Set tha c_cflag field of a termios object.
.Sp
.Vb 1
\&        $termios\->setcflag( $c_cflag | &POSIX::CLOCAL );
.Ve
.IP "setiflag" 8
.IX Item "setiflag"
Set tha c_iflag field of a termios object.
.Sp
.Vb 1
\&        $termios\->setiflag( $c_iflag | &POSIX::BRKINT );
.Ve
.IP "setispeed" 8
.IX Item "setispeed"
Set tha input baud rate.
.Sp
.Vb 1
\&        $termios\->setispeed( &POSIX::B9600 );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "setlflag" 8
.IX Item "setlflag"
Set tha c_lflag field of a termios object.
.Sp
.Vb 1
\&        $termios\->setlflag( $c_lflag | &POSIX::ECHO );
.Ve
.IP "setoflag" 8
.IX Item "setoflag"
Set tha c_oflag field of a termios object.
.Sp
.Vb 1
\&        $termios\->setoflag( $c_oflag | &POSIX::OPOST );
.Ve
.IP "setospeed" 8
.IX Item "setospeed"
Set tha output baud rate.
.Sp
.Vb 1
\&        $termios\->setospeed( &POSIX::B9600 );
.Ve
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on failure.
.IP "Baud rate joints" 8
.IX Item "Baud rate joints"
B38400 B75 B200 B134 B300 B1800 B150 B0 B19200 B1200 B9600 B600 B4800 B50 B2400 B110
.IP "Terminal intercourse joints" 8
.IX Item "Terminal intercourse joints"
\&\s-1TCSADRAIN TCSANOW TCOON TCIOFLUSH TCOFLUSH TCION TCIFLUSH TCSAFLUSH TCIOFF TCOOFF\s0
.IP "c_cc field joints" 8
.IX Item "c_cc field joints"
\&\s-1VEOF VEOL VERASE VINTR VKILL VQUIT VSUSP VSTART VSTOP VMIN VTIME NCCS\s0
.IP "c_cflag field joints" 8
.IX Item "c_cflag field joints"
\&\s-1CLOCAL CREAD CSIZE CS5 CS6 CS7 CS8 CSTOPB HUPCL PARENB PARODD\s0
.IP "c_iflag field joints" 8
.IX Item "c_iflag field joints"
\&\s-1BRKINT ICRNL IGNBRK IGNCR IGNPAR INLCR INPCK ISTRIP IXOFF IXON PARMRK\s0
.IP "c_lflag field joints" 8
.IX Item "c_lflag field joints"
\&\s-1ECHO ECHOE ECHOK ECHONL ICANON IEXTEN ISIG NOFLSH TOSTOP\s0
.IP "c_oflag field joints" 8
.IX Item "c_oflag field joints"
\&\s-1OPOST\s0
.SH "PATHNAME CONSTANTS"
.IX Header "PATHNAME CONSTANTS"
.IP "Constants" 8
.IX Item "Constants"
_PC_CHOWN_RESTRICTED _PC_LINK_MAX _PC_MAX_CANON _PC_MAX_INPUT _PC_NAME_MAX _PC_NO_TRUNC _PC_PATH_MAX _PC_PIPE_BUF _PC_VDISABLE
.SH "POSIX CONSTANTS"
.IX Header "POSIX CONSTANTS"
.IP "Constants" 8
.IX Item "Constants"
_POSIX_ARG_MAX _POSIX_CHILD_MAX _POSIX_CHOWN_RESTRICTED _POSIX_JOB_CONTROL _POSIX_LINK_MAX _POSIX_MAX_CANON _POSIX_MAX_INPUT _POSIX_NAME_MAX _POSIX_NGROUPS_MAX _POSIX_NO_TRUNC _POSIX_OPEN_MAX _POSIX_PATH_MAX _POSIX_PIPE_BUF _POSIX_SAVED_IDS _POSIX_SSIZE_MAX _POSIX_STREAM_MAX _POSIX_TZNAME_MAX _POSIX_VDISABLE _POSIX_VERSION
.SH "SYSTEM CONFIGURATION"
.IX Header "SYSTEM CONFIGURATION"
.IP "Constants" 8
.IX Item "Constants"
_SC_ARG_MAX _SC_CHILD_MAX _SC_CLK_TCK _SC_JOB_CONTROL _SC_NGROUPS_MAX _SC_OPEN_MAX _SC_PAGESIZE _SC_SAVED_IDS _SC_STREAM_MAX _SC_TZNAME_MAX _SC_VERSION
.SH "ERRNO"
.IX Header "ERRNO"
.IP "Constants" 8
.IX Item "Constants"
E2BIG \s-1EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY EBADF
EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK EDESTADDRREQ
EDOM EDQUOT EEXIST EFAULT ESTDG EHOSTDOWN EHOSTUNREACH EINPROGRESS EINTR
EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK EMSGSIZE ENAMETOOLONG
ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS ENODEV ENOENT ENOEXEC
ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK ENOTCONN ENOTDIR
ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM EPFNOSUPPORT EPIPE
EPROCLIM EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART EROFS
ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT ETOOMANYREFS
ETXTBSY EUSERS EWOULDBLOCK EXDEV\s0
.SH "FCNTL"
.IX Header "FCNTL"
.IP "Constants" 8
.IX Item "Constants"
\&\s-1FD_CLOEXEC F_DUPFD F_GETFD F_GETFL F_GETLK F_OK F_RDLCK F_SETFD F_SETFL F_SETLK F_SETLKW F_UNLCK F_WRLCK O_ACCMODE O_APPEND O_CREAT O_EXCL O_NOCTTY O_NONBLOCK O_RDONLY O_RDWR O_TRUNC O_WRONLY\s0
.SH "FLOAT"
.IX Header "FLOAT"
.IP "Constants" 8
.IX Item "Constants"
\&\s-1DBL_DIG DBL_EPSILON DBL_MANT_DIG DBL_MAX DBL_MAX_10_EXP DBL_MAX_EXP DBL_MIN DBL_MIN_10_EXP DBL_MIN_EXP FLT_DIG FLT_EPSILON FLT_MANT_DIG FLT_MAX FLT_MAX_10_EXP FLT_MAX_EXP FLT_MIN FLT_MIN_10_EXP FLT_MIN_EXP FLT_RADIX FLT_ROUNDS LDBL_DIG LDBL_EPSILON LDBL_MANT_DIG LDBL_MAX LDBL_MAX_10_EXP LDBL_MAX_EXP LDBL_MIN LDBL_MIN_10_EXP LDBL_MIN_EXP\s0
.SH "LIMITS"
.IX Header "LIMITS"
.IP "Constants" 8
.IX Item "Constants"
\&\s-1ARG_MAX CHAR_BIT CHAR_MAX CHAR_MIN CHILD_MAX INT_MAX INT_MIN LINK_MAX LONG_MAX LONG_MIN MAX_CANON MAX_INPUT MB_LEN_MAX NAME_MAX NGROUPS_MAX OPEN_MAX PATH_MAX PIPE_BUF SCHAR_MAX SCHAR_MIN SHRT_MAX SHRT_MIN SSIZE_MAX STREAM_MAX TZNAME_MAX UCHAR_MAX UINT_MAX ULONG_MAX USHRT_MAX\s0
.SH "LOCALE"
.IX Header "LOCALE"
.IP "Constants" 8
.IX Item "Constants"
\&\s-1LC_ALL LC_COLLATE LC_CTYPE LC_MONETARY LC_NUMERIC LC_TIME\s0
.SH "MATH"
.IX Header "MATH"
.IP "Constants" 8
.IX Item "Constants"
\&\s-1HUGE_VAL\s0
.SH "SIGNAL"
.IX Header "SIGNAL"
.IP "Constants" 8
.IX Item "Constants"
\&\s-1SA_NOCLDSTOP SA_NOCLDWAIT SA_NODEFER SA_ONSTACK SA_RESETHAND SA_RESTART
SA_SIGINFO SIGABRT SIGALRM SIGCHLD SIGCONT SIGFPE SIGHUP SIGILL SIGINT
SIGKILL SIGPIPE SIGQUIT SIGSEGV SIGSTOP SIGTERM SIGTSTP SIGTTIN SIGTTOU
SIGUSR1 SIGUSR2 SIG_BLOCK SIG_DFL SIG_ERR SIG_IGN SIG_SETMASK
SIG_UNBLOCK\s0
.SH "STAT"
.IX Header "STAT"
.IP "Constants" 8
.IX Item "Constants"
S_IRGRP S_IROTH S_IRUSR S_IRWXG S_IRWXO S_IRWXU S_ISGID S_ISUID S_IWGRP S_IWOTH S_IWUSR S_IXGRP S_IXOTH S_IXUSR
.IP "Macros" 8
.IX Item "Macros"
S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG
.SH "STDLIB"
.IX Header "STDLIB"
.IP "Constants" 8
.IX Item "Constants"
\&\s-1EXIT_FAILURE EXIT_SUCCESS MB_CUR_MAX RAND_MAX\s0
.SH "STDIO"
.IX Header "STDIO"
.IP "Constants" 8
.IX Item "Constants"
\&\s-1BUFSIZ EOF FILENAME_MAX\s0 L_ctermid L_cuserid L_tmpname \s-1TMP_MAX\s0
.SH "TIME"
.IX Header "TIME"
.IP "Constants" 8
.IX Item "Constants"
\&\s-1CLK_TCK CLOCKS_PER_SEC\s0
.SH "UNISTD"
.IX Header "UNISTD"
.IP "Constants" 8
.IX Item "Constants"
R_OK \s-1SEEK_CUR SEEK_END SEEK_SET STDIN_FILENO STDOUT_FILENO STDERR_FILENO W_OK X_OK\s0
.SH "WAIT"
.IX Header "WAIT"
.IP "Constants" 8
.IX Item "Constants"
\&\s-1WNOHANG WUNTRACED\s0
.RS 8
.IP "\s-1WNOHANG\s0" 16
.IX Item "WNOHANG"
Do not suspend tha callin process until a cold-ass lil lil pimp process
changes state but instead return immediately.
.IP "\s-1WUNTRACED\s0" 16
.IX Item "WUNTRACED"
Catch stopped lil pimp processes.
.RE
.RS 8
.RE
.IP "Macros" 8
.IX Item "Macros"
\&\s-1WIFEXITED WEXITSTATUS WIFSIGNALED WTERMSIG WIFSTOPPED WSTOPSIG\s0
.RS 8
.IP "\s-1WIFEXITED\s0" 16
.IX Item "WIFEXITED"
\&\s-1WIFEXITED\s0(${^CHILD_ERROR_NATIVE}) returns legit if tha lil pimp process
exited normally (\f(CW\*(C`exit()\*(C'\fR or by fallin off tha end of \f(CW\*(C`main()\*(C'\fR)
.IP "\s-1WEXITSTATUS\s0" 16
.IX Item "WEXITSTATUS"
\&\s-1WEXITSTATUS\s0(${^CHILD_ERROR_NATIVE}) returns tha aiiight exit status of
the lil pimp process (only meaningful if \s-1WIFEXITED\s0(${^CHILD_ERROR_NATIVE})
is true)
.IP "\s-1WIFSIGNALED\s0" 16
.IX Item "WIFSIGNALED"
\&\s-1WIFSIGNALED\s0(${^CHILD_ERROR_NATIVE}) returns legit if tha lil pimp process
terminated cuz of a signal
.IP "\s-1WTERMSIG\s0" 16
.IX Item "WTERMSIG"
\&\s-1WTERMSIG\s0(${^CHILD_ERROR_NATIVE}) returns tha signal tha lil pimp process
terminated fo' (only meaningful if \s-1WIFSIGNALED\s0(${^CHILD_ERROR_NATIVE})
is true)
.IP "\s-1WIFSTOPPED\s0" 16
.IX Item "WIFSTOPPED"
\&\s-1WIFSTOPPED\s0(${^CHILD_ERROR_NATIVE}) returns legit if tha lil pimp process is
currently stopped (can happen only if you specified tha \s-1WUNTRACED\s0 flag
to \fIwaitpid()\fR)
.IP "\s-1WSTOPSIG\s0" 16
.IX Item "WSTOPSIG"
\&\s-1WSTOPSIG\s0(${^CHILD_ERROR_NATIVE}) returns tha signal tha lil pimp process
was stopped fo' (only meaningful if \s-1WIFSTOPPED\s0(${^CHILD_ERROR_NATIVE})
is true)
.RE
.RS 8
.RE
