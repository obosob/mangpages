.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Tiny 3"
.TH HTTP::Tiny 3 "2013-11-19" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Tiny \- A small, simple, erect HTTP/1.1 client
.SH "VERSION"
.IX Header "VERSION"
version 0.034
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use HTTP::Tiny;
\&
\&    mah $response = HTTP::Tiny\->new\->get(\*(Aqhttp://example.com/\*(Aq);
\&
\&    take a thugged-out dirtnap "Failed!\en" unless $response\->{success};
\&
\&    print "$response\->{status} $response\->{reason}\en";
\&
\&    while (my ($k, $v) = each %{$response\->{headers}}) {
\&        fo' (ref $v eq \*(AqARRAY\*(Aq , biatch? @$v : $v) {
\&            print "$k: $_\en";
\&        }
\&    }
\&
\&    print $response\->{content} if length $response\->{content};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This be a straight-up simple \s-1HTTP/1.1\s0 client, designed fo' bustin simple \s-1GET\s0
requests without tha overhead of a big-ass framework like LWP::UserAgent.
.PP
It be mo' erect n' mo' complete than HTTP::Lite.  It supports
proxies (currently only non-authenticatin ones) n' redirection. I aint talkin' bout chicken n' gravy biatch.  It
also erectly resumes afta \s-1EINTR.\s0
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    $http = HTTP::Tiny\->new( %attributes );
.Ve
.PP
This constructor returns a freshly smoked up HTTP::Tiny object.  Valid attributes include:
.IP "\(bu" 4
\&\f(CW\*(C`agent\*(C'\fR
.Sp
A user-agent strang (defaults ta 'HTTP\-Tiny/$VERSION'). If \f(CW\*(C`agent\*(C'\fR endz up in a space character, tha default user-agent strang be appended.
.IP "\(bu" 4
\&\f(CW\*(C`cookie_jar\*(C'\fR
.Sp
An instizzle of HTTP::CookieJar or equivalent class dat supports tha \f(CW\*(C`add\*(C'\fR n' \f(CW\*(C`cookie_header\*(C'\fR methods
.IP "\(bu" 4
\&\f(CW\*(C`default_headers\*(C'\fR
.Sp
A hashref of default headaz ta apply ta requests
.IP "\(bu" 4
\&\f(CW\*(C`local_address\*(C'\fR
.Sp
Da local \s-1IP\s0 address ta bind to
.IP "\(bu" 4
\&\f(CW\*(C`max_redirect\*(C'\fR
.Sp
Maximum number of redirects allowed (defaults ta 5)
.IP "\(bu" 4
\&\f(CW\*(C`max_size\*(C'\fR
.Sp
Maximum response size (only when not rockin a thugged-out data callback).  If defined,
responses larger than dis will return a exception.
.IP "\(bu" 4
\&\f(CW\*(C`proxy\*(C'\fR
.Sp
\&\s-1URL\s0 of a proxy server ta use (default is \f(CW$ENV{http_proxy}\fR if set)
.IP "\(bu" 4
\&\f(CW\*(C`no_proxy\*(C'\fR
.Sp
List of domain suffixes dat should not be proxied. Y'all KNOW dat shit, muthafucka!  Must be a cold-ass lil comma-separated strang or a array reference. (default is \f(CW$ENV{no_proxy}\fR)
.IP "\(bu" 4
\&\f(CW\*(C`timeout\*(C'\fR
.Sp
Request timeout up in secondz (default is 60)
.IP "\(bu" 4
\&\f(CW\*(C`verify_SSL\*(C'\fR
.Sp
A boolean dat indicates whether ta validate tha \s-1SSL\s0 certificate of a \f(CW\*(C`https\*(C'\fR
connection (default is false)
.IP "\(bu" 4
\&\f(CW\*(C`SSL_options\*(C'\fR
.Sp
A hashref of \f(CW\*(C`SSL_*\*(C'\fR options ta pass all up in ta IO::Socket::SSL
.PP
Exceptions from \f(CW\*(C`max_size\*(C'\fR, \f(CW\*(C`timeout\*(C'\fR or other errors will result up in a
pseudo-HTTP status code of 599 n' a reason of \*(L"Internal Exception\*(R". The
content field up in tha response will contain tha text of tha exception.
.PP
See \*(L"\s-1SSL SUPPORT\*(R"\s0 fo' mo' on tha \f(CW\*(C`verify_SSL\*(C'\fR n' \f(CW\*(C`SSL_options\*(C'\fR attributes.
.SS "get|head|put|post|delete"
.IX Subsection "get|head|put|post|delete"
.Vb 3
\&    $response = $http\->get($url);
\&    $response = $http\->get($url, \e%options);
\&    $response = $http\->head($url);
.Ve
.PP
These methodz is shorthand fo' callin \f(CW\*(C`request()\*(C'\fR fo' tha given method. Y'all KNOW dat shit, muthafucka!  The
\&\s-1URL\s0 must have unsafe charactas escaped n' internationistic domain names encoded.
See \f(CW\*(C`request()\*(C'\fR fo' valid options n' a thugged-out description of tha response.
.PP
Da \f(CW\*(C`success\*(C'\fR field of tha response is ghon be legit if tha status code is 2XX.
.SS "post_form"
.IX Subsection "post_form"
.Vb 2
\&    $response = $http\->post_form($url, $form_data);
\&    $response = $http\->post_form($url, $form_data, \e%options);
.Ve
.PP
This method executes a \f(CW\*(C`POST\*(C'\fR request n' sendz tha key/value pairs from a
form data hash or array reference ta tha given \s-1URL\s0 wit a \f(CW\*(C`content\-type\*(C'\fR of
\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR.  See documentation fo' the
\&\f(CW\*(C`www_form_urlencode\*(C'\fR method fo' details on tha encoding.
.PP
Da \s-1URL\s0 must have unsafe charactas escaped n' internationistic domain names
encoded. Y'all KNOW dat shit, muthafucka!  See \f(CW\*(C`request()\*(C'\fR fo' valid options n' a thugged-out description of tha response.
Any \f(CW\*(C`content\-type\*(C'\fR header or content up in tha options hashref is ghon be ignored.
.PP
Da \f(CW\*(C`success\*(C'\fR field of tha response is ghon be legit if tha status code is 2XX.
.SS "mirror"
.IX Subsection "mirror"
.Vb 4
\&    $response = $http\->mirror($url, $file, \e%options)
\&    if ( $response\->{success} ) {
\&        print "$file is up ta date\en";
\&    }
.Ve
.PP
Executes a \f(CW\*(C`GET\*(C'\fR request fo' tha \s-1URL\s0 n' saves tha response body ta tha file
name provided. Y'all KNOW dat shit, muthafucka!  Da \s-1URL\s0 must have unsafe charactas escaped n' international
domain names encoded. Y'all KNOW dat shit, muthafucka!  If tha file already exists, tha request will include an
\&\f(CW\*(C`If\-Modified\-Since\*(C'\fR header wit tha modification timestamp of tha file.  You
may specify a gangbangin' finger-lickin' different \f(CW\*(C`If\-Modified\-Since\*(C'\fR header yo ass up in tha \f(CW\*(C`$options\->{headers}\*(C'\fR hash.
.PP
Da \f(CW\*(C`success\*(C'\fR field of tha response is ghon be legit if tha status code is 2XX
or if tha status code is 304 (unmodified).
.PP
If tha file was modified n' tha server response includes a properly
formatted \f(CW\*(C`Last\-Modified\*(C'\fR header, tha file modification time will
be updated accordingly.
.SS "request"
.IX Subsection "request"
.Vb 2
\&    $response = $http\->request($method, $url);
\&    $response = $http\->request($method, $url, \e%options);
.Ve
.PP
Executes a \s-1HTTP\s0 request of tha given method type ('\s-1GET\s0', '\s-1HEAD\s0', '\s-1POST\s0',
\&'\s-1PUT\s0', etc.) on tha given \s-1URL. \s0 Da \s-1URL\s0 must have unsafe charactas escaped and
internationistic domain names encoded.
.PP
If tha \s-1URL\s0 includes a \*(L"user:password\*(R" stanza, they is ghon be used fo' Basic-style
authorization headers.  (Authorization headaz aint gonna be included up in a
repimped up request.) For example:
.PP
.Vb 1
\&    $http\->request(\*(AqGET\*(Aq, \*(Aqhttp://Aladdin:open sesame@example.com/\*(Aq);
.Ve
.PP
If tha \*(L"user:password\*(R" stanza gotz nuff reserved characters, they must
be cement-escaped:
.PP
.Vb 1
\&    $http\->request(\*(AqGET\*(Aq, \*(Aqhttp://john%40example.com:password@example.com/\*(Aq);
.Ve
.PP
A hashref of options may be appended ta modify tha request.
.PP
Valid options are:
.IP "\(bu" 4
\&\f(CW\*(C`headers\*(C'\fR
.Sp
A hashref containin headaz ta include wit tha request.  If tha value for
a header be a array reference, tha header is ghon be output multiple times with
each value up in tha array.  These headaz over-write any default headers.
.IP "\(bu" 4
\&\f(CW\*(C`content\*(C'\fR
.Sp
A scalar ta include as tha body of tha request \s-1OR\s0 a cold-ass lil code reference
that is ghon be called iteratively ta produce tha body of tha request
.IP "\(bu" 4
\&\f(CW\*(C`trailer_callback\*(C'\fR
.Sp
A code reference dat is ghon be called if it exists ta provide a hashref
of trailin headaz (only used wit chunked transfer-encoding)
.IP "\(bu" 4
\&\f(CW\*(C`data_callback\*(C'\fR
.Sp
A code reference dat is ghon be called fo' each chunkz of tha response
body received.
.PP
If tha \f(CW\*(C`content\*(C'\fR option be a cold-ass lil code reference, it is ghon be called iteratively
to provide tha content body of tha request.  It should return tha empty
strin or undef when tha iterator is exhausted.
.PP
If tha \f(CW\*(C`content\*(C'\fR option is tha empty string, no \f(CW\*(C`content\-type\*(C'\fR or
\&\f(CW\*(C`content\-length\*(C'\fR headaz is ghon be generated.
.PP
If tha \f(CW\*(C`data_callback\*(C'\fR option is provided, it is ghon be called iteratively until
the entire response body is received. Y'all KNOW dat shit, muthafucka!  Da first argument is ghon be a string
containin a cold-ass lil chunk of tha response body, tha second argument is ghon be the
in-progress response hash reference, as busted lyrics bout below.  (This allows
customizin tha action of tha callback based on tha \f(CW\*(C`status\*(C'\fR or \f(CW\*(C`headers\*(C'\fR
received prior ta tha content body.)
.PP
Da \f(CW\*(C`request\*(C'\fR method returns a hashref containin tha response.  Da hashref
will have tha followin keys:
.IP "\(bu" 4
\&\f(CW\*(C`success\*(C'\fR
.Sp
Boolean indicatin whether tha operation returned a 2XX status code
.IP "\(bu" 4
\&\f(CW\*(C`url\*(C'\fR
.Sp
\&\s-1URL\s0 dat provided tha response. This is tha \s-1URL\s0 of tha request unless
there was redirections, up in which case it is tha last \s-1URL\s0 queried
in a redirection chain
.IP "\(bu" 4
\&\f(CW\*(C`status\*(C'\fR
.Sp
Da \s-1HTTP\s0 status code of tha response
.IP "\(bu" 4
\&\f(CW\*(C`reason\*(C'\fR
.Sp
Da response phrase returned by tha server
.IP "\(bu" 4
\&\f(CW\*(C`content\*(C'\fR
.Sp
Da body of tha response.  If tha response aint gots any content
or if a thugged-out data callback is provided ta consume tha response body,
this is ghon be tha empty string
.IP "\(bu" 4
\&\f(CW\*(C`headers\*(C'\fR
.Sp
A hashref of header fields.  All header field names is ghon be normalized
to be lower case. If a header is repeated, tha value is ghon be a arrayref;
it will otherwise be a scalar strang containin tha value
.PP
On a exception durin tha execution of tha request, tha \f(CW\*(C`status\*(C'\fR field will
contain 599, n' tha \f(CW\*(C`content\*(C'\fR field will contain tha text of tha exception.
.SS "www_form_urlencode"
.IX Subsection "www_form_urlencode"
.Vb 2
\&    $params = $http\->www_form_urlencode( $data );
\&    $response = $http\->get("http://example.com/query?$params");
.Ve
.PP
This method converts tha key/value pairs from a thugged-out data hash or array reference
into a \f(CW\*(C`x\-www\-form\-urlencoded\*(C'\fR string.  Da keys n' joints from tha data
reference is ghon be \s-1UTF\-8\s0 encoded n' escaped per \s-1RFC 3986. \s0 If a value be an
array reference, tha key is ghon be repeated wit each of tha jointz of tha array
reference.  Da key/value pairs up in tha resultin strang is ghon be sorted by key
and value.
.SH "SSL SUPPORT"
.IX Header "SSL SUPPORT"
Direct \f(CW\*(C`https\*(C'\fR connections is supported only if IO::Socket::SSL 1.56 or
greata n' Net::SSLeay 1.49 or pimped outa is installed. Y'all KNOW dat shit, muthafucka! An exception will be
thrown if a freshly smoked up enough versionz of these modulez not installed or if tha \s-1SSL\s0
encryption fails. There is no support fo' \f(CW\*(C`https\*(C'\fR connections via proxy (i.e.
\&\s-1RFC 2817\s0).
.PP
\&\s-1SSL\s0 serves up two distinct capabilities:
.IP "\(bu" 4
Encrypted communication channel
.IP "\(bu" 4
Verification of server identity
.PP
\&\fBBy default, HTTP::Tiny do not verify server identity\fR.
.PP
Server identitizzle verification is controversial n' potentially tricky cuz it
dependz on a (usually paid) third-party Certificate Authoritizzle (\s-1CA\s0) trust model
to validate a cold-ass lil certificate as legitimate.  This discriminates against servers
with self-signed certificates or certificates signed by free, hood-driven
\&\s-1CA\s0z like fuckin CAcert.org <http://cacert.org>.
.PP
By default, HTTP::Tiny do not make any assumptions bout yo' trust model,
threat level or risk tolerance.  It just aims ta hit you wit a encrypted channel
when you need one.
.PP
Settin tha \f(CW\*(C`verify_SSL\*(C'\fR attribute ta a legit value will make HTTP::Tiny verify
that a \s-1SSL\s0 connection has a valid \s-1SSL\s0 certificate correspondin ta tha host
name of tha connection n' dat tha \s-1SSL\s0 certificate has been verified by a \s-1CA.\s0
Assumin you trust tha \s-1CA,\s0 dis will protect against a man-in-the-middle
battle <http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.  If yo ass is
concerned bout security, you should enable dis option.
.PP
Certificate verification requires a gangbangin' file containin trusted \s-1CA\s0 certificates.
If tha Mozilla::CA module is installed, HTTP::Tiny will use tha \s-1CA\s0 file
included wit it as a source of trusted \s-1CA\s0's.  (This means you trust Mozilla,
the lyricist of Mozilla::CA, tha \s-1CPAN\s0 mirror where you gots Mozilla::CA, the
toolchain used ta install it, n' yo' operatin system security, right?)
.PP
If dat module aint available, then HTTP::Tiny will search several
system-specific default locations fo' a \s-1CA\s0 certificate file:
.IP "\(bu" 4
/etc/ssl/certs/ca\-certificates.crt
.IP "\(bu" 4
/etc/pki/tls/certs/ca\-bundle.crt
.IP "\(bu" 4
/etc/ssl/ca\-bundle.pem
.PP
An exception is ghon be raised if \f(CW\*(C`verify_SSL\*(C'\fR is legit n' no \s-1CA\s0 certificate file
is available.
.PP
If you desire complete control over \s-1SSL\s0 connections, tha \f(CW\*(C`SSL_options\*(C'\fR attribute
lets you provide a hash reference dat is ghon be passed all up in to
\&\f(CW\*(C`IO::Socket::SSL::start_SSL()\*(C'\fR, overridin any options set by HTTP::Tiny. For
example, ta provide yo' own trusted \s-1CA\s0 file:
.PP
.Vb 3
\&    SSL_options => {
\&        SSL_ca_file => $file_path,
\&    }
.Ve
.PP
Da \f(CW\*(C`SSL_options\*(C'\fR attribute could also be used fo' such thangs as providin a
client certificate fo' authentication ta a server or controllin tha chizzle of
cipher used fo' tha \s-1SSL\s0 connection. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See IO::Socket::SSL documentation for
details.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
HTTP::Tiny is \fIconditionally compliant\fR wit the
\&\s-1HTTP/1.1\s0 justification <http://www.w3.org/Protocols/rfc2616/rfc2616.html>.
It attempts ta hook up all \*(L"\s-1MUST\*(R"\s0 requirementz of tha justification yo, but do not
implement all \*(L"\s-1SHOULD\*(R"\s0 requirements.
.PP
Some particular limitationz of note include:
.IP "\(bu" 4
HTTP::Tiny focuses on erect transport.  Users is responsible fo' ensuring
that user-defined headaz n' content is compliant wit tha \s-1HTTP/1.1\s0
specification.
.IP "\(bu" 4
Users must ensure dat URLs is properly escaped fo' unsafe charactas n' that
internationistic domain names is properly encoded ta \s-1ASCII.\s0 See URI::Escape,
URI::_punycode n' Net::IDN::Encode.
.IP "\(bu" 4
Redirection is straight-up strict against tha justification. I aint talkin' bout chicken n' gravy biatch.  Redirection is only
automatic fo' response codes 301, 302 n' 307 if tha request method is '\s-1GET\s0' or
\&'\s-1HEAD\s0'.  Response code 303 be always converted tha fuck into a '\s-1GET\s0' redirection, as
mandated by tha justification. I aint talkin' bout chicken n' gravy biatch.  There is no automatic support fo' status 305
(\*(L"Use proxy\*(R") redirections.
.IP "\(bu" 4
Persistent connections is not supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \f(CW\*(C`Connection\*(C'\fR header will
always be set ta \f(CW\*(C`close\*(C'\fR.
.IP "\(bu" 4
Cookie support requires HTTP::CookieJar or a equivalent class.
.IP "\(bu" 4
Only tha \f(CW\*(C`http_proxy\*(C'\fR environment variable is supported up in tha format
\&\f(CW\*(C`http://HOST:PORT/\*(C'\fR.  If a \f(CW\*(C`proxy\*(C'\fR argument is passed ta \f(CW\*(C`new\*(C'\fR (including
undef), then tha \f(CW\*(C`http_proxy\*(C'\fR environment variable is ignored.
.IP "\(bu" 4
\&\f(CW\*(C`no_proxy\*(C'\fR environment variable is supported up in tha format comma-separated
list of domain extensions proxy should not be used for. Shiiit, dis aint no joke.  If a \f(CW\*(C`no_proxy\*(C'\fR
argument is passed ta \f(CW\*(C`new\*(C'\fR, then tha \f(CW\*(C`no_proxy\*(C'\fR environment variable is
ignored.
.IP "\(bu" 4
There is no provision fo' delayin a request body rockin a \f(CW\*(C`Expect\*(C'\fR header.
Unexpected \f(CW\*(C`1XX\*(C'\fR responses is silently ignored as per tha justification.
.IP "\(bu" 4
Only 'chunked' \f(CW\*(C`Transfer\-Encoding\*(C'\fR is supported.
.IP "\(bu" 4
There is no support fo' a Request-URI of '*' fo' tha '\s-1OPTIONS\s0' request.
.IP "\(bu" 4
There is no support fo' IPv6 of any kind.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
HTTP::Thin \- HTTP::Tiny wrapper wit HTTP::Request/HTTP::Response compatibility
.IP "\(bu" 4
HTTP::Tiny::Mech \- Wrap WWW::Mechanize instizzle up in HTTP::Tiny compatible intercourse
.IP "\(bu" 4
IO::Socket::SSL \- Required fo' \s-1SSL\s0 support
.IP "\(bu" 4
LWP::UserAgent \- If HTTP::Tiny aint enough fo' you, dis is tha \*(L"standard\*(R" way ta do thangs
.IP "\(bu" 4
Mozilla::CA \- Required if you wanna validate \s-1SSL\s0 certificates
.IP "\(bu" 4
Net::SSLeay \- Required fo' \s-1SSL\s0 support
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests all up in tha issue tracker
at <https://github.com/chansen/p5\-http\-tiny/issues>.
Yo ass is ghon be notified automatically of any progress on yo' issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  Da code repository be available for
hood review n' contribution under tha termz of tha license.
.PP
<https://github.com/chansen/p5\-http\-tiny>
.PP
.Vb 1
\&  git clone git://github.com/chansen/p5\-http\-tiny.git
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Christian Hansen <chansen@cpan.org>
.IP "\(bu" 4
Dizzy Golden <dagolden@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Alan Gardner <gardner@pythian.com>
.IP "\(bu" 4
Alessandro Ghedini <al3xbio@gmail.com>
.IP "\(bu" 4
Brad Gilbert <bgills@cpan.org>
.IP "\(bu" 4
Chris Nehren <apeiron@cpan.org>
.IP "\(bu" 4
Chris Weyl <cweyl@alumni.drew.edu>
.IP "\(bu" 4
Claes Jakobsson <claes@surfar.nu>
.IP "\(bu" 4
Craig Berry <cberry@cpan.org>
.IP "\(bu" 4
Dizzy Mitchell <davem@iabyn.com>
.IP "\(bu" 4
Edward Zborowski <ed@rubensteintech.com>
.IP "\(bu" 4
Jizz Robinston <castaway@desert\-island.me.uk>
.IP "\(bu" 4
Lukas Eklund <leklund@gmail.com>
.IP "\(bu" 4
Martin-Louis Bright <mlbright@gmail.com>
.IP "\(bu" 4
Mike Doherty <doherty@cpan.org>
.IP "\(bu" 4
Serguei Trouchelle <stro@cpan.org>
.IP "\(bu" 4
Syohei \s-1YOSHIDA\s0 <syohex@gmail.com>
.IP "\(bu" 4
Tony Cook <tony@develop\-help.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2013 by Christian Hansen.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as tha Perl 5 programmin language system itself.
