.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Response 3"
.TH HTTP::Response 3 "2012-09-30" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Response \- HTTP steez response message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Response objects is returned by tha \fIrequest()\fR method of tha \f(CW\*(C`LWP::UserAgent\*(C'\fR:
.PP
.Vb 8
\&    # ...
\&    $response = $ua\->request($request)
\&    if ($response\->is_success) {
\&        print $response\->decoded_content;
\&    }
\&    else {
\&        print STDERR $response\->status_line, "\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`HTTP::Response\*(C'\fR class encapsulates \s-1HTTP\s0 steez responses.  A
response consistz of a response line, some headers, n' a cold-ass lil content
body. Note dat tha \s-1LWP\s0 library uses \s-1HTTP\s0 steez responses even for
non-HTTP protocol schemes.  Instancez of dis class is usually
created n' returned by tha \fIrequest()\fR method of a \f(CW\*(C`LWP::UserAgent\*(C'\fR
object.
.PP
\&\f(CW\*(C`HTTP::Response\*(C'\fR be a subclass of \f(CW\*(C`HTTP::Message\*(C'\fR n' therefore
inherits its methods.  Da followin additionizzle methodz is available:
.ie n .IP "$r = HTTP::Response\->new( $code )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR )" 4
.IX Item "$r = HTTP::Response->new( $code )"
.PD 0
.ie n .IP "$r = HTTP::Response\->new( $code, $msg )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR, \f(CW$msg\fR )" 4
.IX Item "$r = HTTP::Response->new( $code, $msg )"
.ie n .IP "$r = HTTP::Response\->new( $code, $msg, $header )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR, \f(CW$msg\fR, \f(CW$header\fR )" 4
.IX Item "$r = HTTP::Response->new( $code, $msg, $header )"
.ie n .IP "$r = HTTP::Response\->new( $code, $msg, $header, $content )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR, \f(CW$msg\fR, \f(CW$header\fR, \f(CW$content\fR )" 4
.IX Item "$r = HTTP::Response->new( $code, $msg, $header, $content )"
.PD
Constructs a freshly smoked up \f(CW\*(C`HTTP::Response\*(C'\fR object describin a response with
response code \f(CW$code\fR n' optionizzle message \f(CW$msg\fR.  Da optionizzle \f(CW$header\fR
argument should be a reference ta a \f(CW\*(C`HTTP::Headers\*(C'\fR object or a
plain array reference of key/value pairs.  Da optionizzle \f(CW$content\fR
argument should be a strang of bytes.  Da meaningz of these arguments are
busted lyrics bout below.
.ie n .IP "$r = HTTP::Response\->parse( $str )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->parse( \f(CW$str\fR )" 4
.IX Item "$r = HTTP::Response->parse( $str )"
This constructs a freshly smoked up response object by parsin tha given string.
.ie n .IP "$r\->code" 4
.el .IP "\f(CW$r\fR\->code" 4
.IX Item "$r->code"
.PD 0
.ie n .IP "$r\->code( $code )" 4
.el .IP "\f(CW$r\fR\->code( \f(CW$code\fR )" 4
.IX Item "$r->code( $code )"
.PD
This is used ta get/set tha code attribute.  Da code be a 3 digit
number dat encode tha overall outcome of a \s-1HTTP\s0 response.  The
\&\f(CW\*(C`HTTP::Status\*(C'\fR module provide constants dat provide mnemonic names
for tha code attribute.
.ie n .IP "$r\->message" 4
.el .IP "\f(CW$r\fR\->message" 4
.IX Item "$r->message"
.PD 0
.ie n .IP "$r\->message( $message )" 4
.el .IP "\f(CW$r\fR\->message( \f(CW$message\fR )" 4
.IX Item "$r->message( $message )"
.PD
This is used ta get/set tha message attribute.  Da message be a gangbangin' finger-lickin' dirty-ass short
human readable single line strang dat explains tha response code.
.ie n .IP "$r\->header( $field )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR )" 4
.IX Item "$r->header( $field )"
.PD 0
.ie n .IP "$r\->header( $field => $value )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$r->header( $field => $value )"
.PD
This is used ta get/set header joints n' it is inherited from
\&\f(CW\*(C`HTTP::Headers\*(C'\fR via \f(CW\*(C`HTTP::Message\*(C'\fR.  See HTTP::Headaz for
details n' other similar methodz dat can be used ta access the
headers.
.ie n .IP "$r\->content" 4
.el .IP "\f(CW$r\fR\->content" 4
.IX Item "$r->content"
.PD 0
.ie n .IP "$r\->content( $bytes )" 4
.el .IP "\f(CW$r\fR\->content( \f(CW$bytes\fR )" 4
.IX Item "$r->content( $bytes )"
.PD
This is used ta get/set tha raw content n' it is inherited from the
\&\f(CW\*(C`HTTP::Message\*(C'\fR base class.  See HTTP::Message fo' details and
other methodz dat can be used ta access tha content.
.ie n .IP "$r\->decoded_content( %options )" 4
.el .IP "\f(CW$r\fR\->decoded_content( \f(CW%options\fR )" 4
.IX Item "$r->decoded_content( %options )"
This will return tha content afta any \f(CW\*(C`Content\-Encoding\*(C'\fR and
charsets done been decoded. Y'all KNOW dat shit, muthafucka!  See HTTP::Message fo' details.
.ie n .IP "$r\->request" 4
.el .IP "\f(CW$r\fR\->request" 4
.IX Item "$r->request"
.PD 0
.ie n .IP "$r\->request( $request )" 4
.el .IP "\f(CW$r\fR\->request( \f(CW$request\fR )" 4
.IX Item "$r->request( $request )"
.PD
This is used ta get/set tha request attribute.  Da request attribute
is a reference ta tha the request dat caused dis response.  It do
not gotta be tha same request passed ta tha \f(CW$ua\fR\->\fIrequest()\fR method,
because there might done been redirects n' authorization retries in
between.
.ie n .IP "$r\->previous" 4
.el .IP "\f(CW$r\fR\->previous" 4
.IX Item "$r->previous"
.PD 0
.ie n .IP "$r\->previous( $response )" 4
.el .IP "\f(CW$r\fR\->previous( \f(CW$response\fR )" 4
.IX Item "$r->previous( $response )"
.PD
This is used ta get/set tha previous attribute.  Da previous
attribute is used ta link together chainz of responses.  Yo ass get
chainz of responses if tha straight-up original gangsta response is redirect or unauthorized.
Da value is \f(CW\*(C`undef\*(C'\fR if dis is tha straight-up original gangsta response up in a cold-ass lil chain.
.Sp
Note dat tha method \f(CW$r\fR\->redirects is provided as a mo' convenient
way ta access tha response chain.
.ie n .IP "$r\->status_line" 4
.el .IP "\f(CW$r\fR\->status_line" 4
.IX Item "$r->status_line"
Returns tha strang \*(L"<code> <message>\*(R".  If tha message attribute
is not set then tha straight-up legit name of <code> (see HTTP::Status)
is substituted.
.ie n .IP "$r\->base" 4
.el .IP "\f(CW$r\fR\->base" 4
.IX Item "$r->base"
Returns tha base \s-1URI\s0 fo' dis response.  Da return value is ghon be a
reference ta a \s-1URI\s0 object.
.Sp
Da base \s-1URI\s0 is obtained from one tha followin sources (in priority
order):
.RS 4
.IP "1." 4
Embedded up in tha document content, fo' instizzle <\s-1BASE\s0 HREF=\*(L"...\*(R">
in \s-1HTML\s0 documents.
.IP "2." 4
A \*(L"Content-Base:\*(R" or a \*(L"Content-Location:\*(R" header up in tha response.
.Sp
For backwardz compatibilitizzle wit olda \s-1HTTP\s0 implementations we will
also look fo' tha \*(L"Base:\*(R" header.
.IP "3." 4
Da \s-1URI\s0 used ta request dis response. This might not be tha original
\&\s-1URI\s0 dat was passed ta \f(CW$ua\fR\->\fIrequest()\fR method, cuz we might have
received some redirect responses first.
.RE
.RS 4
.Sp
If none of these sources provide a absolute \s-1URI,\s0 undef is returned.
.Sp
When tha \s-1LWP\s0 protocol modulez produce tha HTTP::Response object, then
any base \s-1URI\s0 embedded up in tha document (step 1) will already have
initialized tha \*(L"Content-Base:\*(R" header n' shit. This means dat dis method
only performs tha last 2 steps (the content aint always available
either).
.RE
.ie n .IP "$r\->filename" 4
.el .IP "\f(CW$r\fR\->filename" 4
.IX Item "$r->filename"
Returns a gangbangin' filename fo' dis response.  Note dat bustin sanitizzle checks
on tha returned filename (eg. removin charactas dat cannot be used
on tha target filesystem where tha filename would be used, and
launderin it fo' securitizzle purposes) is tha callerz responsibility;
the only related thang done by dis method is dat it cook up a simple
attempt ta return a plain filename wit no precedin path segments.
.Sp
Da filename is obtained from one tha followin sources (in priority
order):
.RS 4
.IP "1." 4
A \*(L"Content-Disposition:\*(R" header up in tha response.  Proper decodin of
\&\s-1RFC 2047\s0 encoded filenames requires tha \f(CW\*(C`MIME::QuotedPrint\*(C'\fR (for \*(L"Q\*(R"
encoding), \f(CW\*(C`MIME::Base64\*(C'\fR (for \*(L"B\*(R" encoding), n' \f(CW\*(C`Encode\*(C'\fR modules.
.IP "2." 4
A \*(L"Content-Location:\*(R" header up in tha response.
.IP "3." 4
Da \s-1URI\s0 used ta request dis response. This might not be tha original
\&\s-1URI\s0 dat was passed ta \f(CW$ua\fR\->\fIrequest()\fR method, cuz we might have
received some redirect responses first.
.RE
.RS 4
.Sp
If a gangbangin' filename cannot be derived from any of these sources, undef is
returned.
.RE
.ie n .IP "$r\->as_string" 4
.el .IP "\f(CW$r\fR\->as_string" 4
.IX Item "$r->as_string"
.PD 0
.ie n .IP "$r\->as_string( $eol )" 4
.el .IP "\f(CW$r\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$r->as_string( $eol )"
.PD
Returns a textual representation of tha response.
.ie n .IP "$r\->is_info" 4
.el .IP "\f(CW$r\fR\->is_info" 4
.IX Item "$r->is_info"
.PD 0
.ie n .IP "$r\->is_success" 4
.el .IP "\f(CW$r\fR\->is_success" 4
.IX Item "$r->is_success"
.ie n .IP "$r\->is_redirect" 4
.el .IP "\f(CW$r\fR\->is_redirect" 4
.IX Item "$r->is_redirect"
.ie n .IP "$r\->is_error" 4
.el .IP "\f(CW$r\fR\->is_error" 4
.IX Item "$r->is_error"
.PD
These methodz indicate if tha response was shiznital, successful, a
redirection, or a error. Shiiit, dis aint no joke.  See HTTP::Status fo' tha meanin of these.
.ie n .IP "$r\->error_as_HTML" 4
.el .IP "\f(CW$r\fR\->error_as_HTML" 4
.IX Item "$r->error_as_HTML"
Returns a strang containin a cold-ass lil complete \s-1HTML\s0 document indicatin what
error occurred. Y'all KNOW dat shit, muthafucka!  This method should only be called when \f(CW$r\fR\->is_error
is \s-1TRUE.\s0
.ie n .IP "$r\->redirects" 4
.el .IP "\f(CW$r\fR\->redirects" 4
.IX Item "$r->redirects"
Returns tha list of redirect responses dat lead up ta dis response
by followin tha \f(CW$r\fR\->previous chain. I aint talkin' bout chicken n' gravy biatch.  Da list order is crazy oldschool first.
.Sp
In scalar context return tha number of redirect responses leadin up
to dis one.
.ie n .IP "$r\->current_age" 4
.el .IP "\f(CW$r\fR\->current_age" 4
.IX Item "$r->current_age"
Calculates tha \*(L"current age\*(R" of tha response as specified by \s-1RFC 2616\s0
section 13.2.3.  Da age of a response is tha time since dat shiznit was sent
by tha origin server n' shit.  Da returned value be a number representin the
age up in seconds.
.ie n .IP "$r\->freshness_lifetime( %opt )" 4
.el .IP "\f(CW$r\fR\->freshness_lifetime( \f(CW%opt\fR )" 4
.IX Item "$r->freshness_lifetime( %opt )"
Calculates tha \*(L"freshnizz gametime\*(R" of tha response as specified by
\&\s-1RFC 2616\s0 section 13.2.4.  Da \*(L"freshnizz gametime\*(R" is tha length of
time between tha generation of a response n' its expiration time.
Da returned value is tha number of secondz until expiry.
.Sp
If tha response do not contain a \*(L"Expires\*(R" or a \*(L"Cache-Control\*(R"
header, then dis function will apply some simple heuristic based on
the \*(L"Last-Modified\*(R" header ta determine a suitable gametime.  The
followin options might be passed ta control tha heuristics:
.RS 4
.ie n .IP "heuristic_expiry => $bool" 4
.el .IP "heuristic_expiry => \f(CW$bool\fR" 4
.IX Item "heuristic_expiry => $bool"
If passed as a \s-1FALSE\s0 value, don't apply heuristics n' just return
\&\f(CW\*(C`undef\*(C'\fR when \*(L"Expires\*(R" or \*(L"Cache-Control\*(R" is lacking.
.ie n .IP "h_lastmod_fraction => $num" 4
.el .IP "h_lastmod_fraction => \f(CW$num\fR" 4
.IX Item "h_lastmod_fraction => $num"
This number represent tha fraction of tha difference since the
\&\*(L"Last-Modified\*(R" timestamp ta make tha expiry time.  Da default is
\&\f(CW0.10\fR, tha suggested typical settin of 10% up in \s-1RFC 2616.\s0
.ie n .IP "h_min => $sec" 4
.el .IP "h_min => \f(CW$sec\fR" 4
.IX Item "h_min => $sec"
This is tha lower limit of tha heuristic expiry age ta use.  The
default is \f(CW60\fR (1 minute).
.ie n .IP "h_max => $sec" 4
.el .IP "h_max => \f(CW$sec\fR" 4
.IX Item "h_max => $sec"
This is tha upper limit of tha heuristic expiry age ta use.  The
default is \f(CW86400\fR (24 hours).
.ie n .IP "h_default => $sec" 4
.el .IP "h_default => \f(CW$sec\fR" 4
.IX Item "h_default => $sec"
This is tha expiry age ta use when not a god damn thang else applies. Put ya muthafuckin choppers up if ya feel dis!  Da default
is \f(CW3600\fR (1 hour) or \*(L"h_min\*(R" if pimped outer.
.RE
.RS 4
.RE
.ie n .IP "$r\->is_fresh( %opt )" 4
.el .IP "\f(CW$r\fR\->is_fresh( \f(CW%opt\fR )" 4
.IX Item "$r->is_fresh( %opt )"
Returns \s-1TRUE\s0 if tha response is fresh, based on tha joints of
\&\fIfreshness_lifetime()\fR n' \fIcurrent_age()\fR.  If tha response is no longer
fresh, then it has ta be re-fetched or re-validated by tha origin
server.
.Sp
Options might be passed ta control expiry heuristics, peep the
description of \fIfreshness_lifetime()\fR.
.ie n .IP "$r\->fresh_until( %opt )" 4
.el .IP "\f(CW$r\fR\->fresh_until( \f(CW%opt\fR )" 4
.IX Item "$r->fresh_until( %opt )"
Returns tha time (secondz since epoch) when dis entitizzle is no longer fresh.
.Sp
Options might be passed ta control expiry heuristics, peep the
description of \fIfreshness_lifetime()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Headers, HTTP::Message, HTTP::Status, HTTP::Request
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2004 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
