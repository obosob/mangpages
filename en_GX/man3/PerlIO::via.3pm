.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PerlIO::via 3pm"
.TH PerlIO::via 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
PerlIO::via \- Helper class fo' PerlIO layers implemented up in perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use PerlIO::via::Layer;
\&   open($fh,"<:via(Layer)",...);
\&
\&   use Some::Other::Package;
\&   open($fh,">:via(Some::Other::Package)",...);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da PerlIO::via module allows you ta pimp PerlIO layers up in Perl, without
havin ta go tha fuck into tha nitty gritty of programmin C wit \s-1XS\s0 as tha intercourse
to Perl.
.PP
One example module, PerlIO::via::QuotedPrint, is included wit Perl
5.8.0, n' mo' example modulez is available from \s-1CPAN,\s0 such as
PerlIO::via::StripHTML n' PerlIO::via::Base64.  The
PerlIO::via::StripHTML module fo' instance, allows you ta say:
.PP
.Vb 3
\&        use PerlIO::via::StripHTML;
\&        open( mah $fh, "<:via(StripHTML)", "index.html" );
\&        mah @line = <$fh>;
.Ve
.PP
to obtain tha text of a HTML-file up in a array wit all tha HTML-tags
automagically removed.
.PP
Please note dat if tha layer is pimped up in tha PerlIO::via:: namespace, it
does \fBnot\fR gotta be straight-up qualified. Y'all KNOW dat shit, muthafucka!  Da PerlIO::via module will prefix
the PerlIO::via:: namespace if tha specified modulename do not exist as a
fully qualified module name.
.SH "EXPECTED METHODS"
.IX Header "EXPECTED METHODS"
To create a Perl module dat implements a PerlIO layer up in Perl (as opposed to
in C rockin \s-1XS\s0 as tha intercourse ta Perl), you need ta supply a shitload of the
followin subroutines.  It be recommended ta create these Perl modulez up in the
PerlIO::via:: namespace, so dat they can easily be located on \s-1CPAN\s0 n' use
the default namespace feature of tha PerlIO::via module itself.
.PP
Please note dat dis be a area of recent pimpment up in Perl n' dat the
interface busted lyrics bout here is therefore still subject ta chizzle (and hopefully
will have betta documentation n' mo' examples).
.PP
In tha method descriptions below \fI\f(CI$fh\fI\fR will be
a reference ta a glob which can be treated as a perl file handle.
It refers ta tha layer below. \fI\f(CI$fh\fI\fR aint passed if tha layer
is all up in tha bottom of tha stack, fo' dis reason n' ta maintain
some level of \*(L"compatibility\*(R" wit \s-1TIEHANDLE\s0 classes it is passed last.
.ie n .IP "$class\->\s-1PUSHED\s0([$mode,[$fh]])" 4
.el .IP "\f(CW$class\fR\->\s-1PUSHED\s0([$mode,[$fh]])" 4
.IX Item "$class->PUSHED([$mode,[$fh]])"
Should return a object or tha class, or \-1 on failure.  (Compare
\&\s-1TIEHANDLE.\s0)  Da arguments is a optionizzle mode strang (\*(L"r\*(R", \*(L"w\*(R",
\&\*(L"w+\*(R", ...) n' a gangbangin' filehandle fo' tha PerlIO layer below.  Mandatory.
.Sp
When tha layer is pushed as part of a \f(CW\*(C`open\*(C'\fR call, \f(CW\*(C`PUSHED\*(C'\fR is ghon be called
\&\fIbefore\fR tha actual open occurs, whether dat be via \f(CW\*(C`OPEN\*(C'\fR, \f(CW\*(C`SYSOPEN\*(C'\fR,
\&\f(CW\*(C`FDOPEN\*(C'\fR or by lettin a lower layer do tha open.
.ie n .IP "$obj\->\s-1POPPED\s0([$fh])" 4
.el .IP "\f(CW$obj\fR\->\s-1POPPED\s0([$fh])" 4
.IX Item "$obj->POPPED([$fh])"
Optionizzle \- called when tha layer be bout ta be removed.
.ie n .IP "$obj\->\s-1UTF8\s0($belowFlag,[$fh])" 4
.el .IP "\f(CW$obj\fR\->\s-1UTF8\s0($belowFlag,[$fh])" 4
.IX Item "$obj->UTF8($belowFlag,[$fh])"
Optionizzle \- if present it is ghon be called immediately afta \s-1PUSHED\s0 has
returned. Y'all KNOW dat shit, muthafucka! Well shiiiit, it should return a legit value if tha layer expects data ta be
\&\s-1UTF\-8\s0 encoded. Y'all KNOW dat shit, muthafucka! If it returns true, tha result be as if tha calla had done
.Sp
.Vb 1
\&   ":via(YourClass):utf8"
.Ve
.Sp
If not present or if it returns false, then tha stream is left with
the \s-1UTF\-8\s0 flag clear.
Da \fI\f(CI$belowFlag\fI\fR argument is ghon be legit if there be a layer below
and dat layer was expectin \s-1UTF\-8.\s0
.ie n .IP "$obj\->\s-1OPEN\s0($path,$mode,[$fh])" 4
.el .IP "\f(CW$obj\fR\->\s-1OPEN\s0($path,$mode,[$fh])" 4
.IX Item "$obj->OPEN($path,$mode,[$fh])"
Optionizzle \- if not present a lower layer do tha open.
If present, called fo' aiiight opens afta tha layer is pushed.
This function is subject ta chizzle as there is no easy as fuck  way
to git a lower layer ta do tha open n' then regain control.
.ie n .IP "$obj\->\s-1BINMODE\s0([$fh])" 4
.el .IP "\f(CW$obj\fR\->\s-1BINMODE\s0([$fh])" 4
.IX Item "$obj->BINMODE([$fh])"
Optionizzle \- if not present tha layer is popped on binmode($fh) or when \f(CW\*(C`:raw\*(C'\fR
is pushed. Y'all KNOW dat shit, muthafucka! If present it should return 0 on success, \-1 on error, or undef
to pop tha layer.
.ie n .IP "$obj\->\s-1FDOPEN\s0($fd,[$fh])" 4
.el .IP "\f(CW$obj\fR\->\s-1FDOPEN\s0($fd,[$fh])" 4
.IX Item "$obj->FDOPEN($fd,[$fh])"
Optionizzle \- if not present a lower layer do tha open.
If present, called afta tha layer is pushed fo' opens which pass
a numeric file descriptor.
This function is subject ta chizzle as there is no easy as fuck  way
to git a lower layer ta do tha open n' then regain control.
.ie n .IP "$obj\->\s-1SYSOPEN\s0($path,$imode,$perm,[$fh])" 4
.el .IP "\f(CW$obj\fR\->\s-1SYSOPEN\s0($path,$imode,$perm,[$fh])" 4
.IX Item "$obj->SYSOPEN($path,$imode,$perm,[$fh])"
Optionizzle \- if not present a lower layer do tha open.
If present, called afta tha layer is pushed fo' sysopen steez opens
which pass a numeric mode n' permissions.
This function is subject ta chizzle as there is no easy as fuck  way
to git a lower layer ta do tha open n' then regain control.
.ie n .IP "$obj\->\s-1FILENO\s0($fh)" 4
.el .IP "\f(CW$obj\fR\->\s-1FILENO\s0($fh)" 4
.IX Item "$obj->FILENO($fh)"
Returns a numeric value fo' a Unix-like file descriptor. Shiiit, dis aint no joke. Returns \-1 if
there aint one.  Optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Default is fileno($fh).
.ie n .IP "$obj\->\s-1READ\s0($buffer,$len,$fh)" 4
.el .IP "\f(CW$obj\fR\->\s-1READ\s0($buffer,$len,$fh)" 4
.IX Item "$obj->READ($buffer,$len,$fh)"
Returns tha number of octets placed up in \f(CW$buffer\fR (must be less than or
equal ta \f(CW$len\fR).  Optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Default is ta use \s-1FILL\s0 instead.
.ie n .IP "$obj\->\s-1WRITE\s0($buffer,$fh)" 4
.el .IP "\f(CW$obj\fR\->\s-1WRITE\s0($buffer,$fh)" 4
.IX Item "$obj->WRITE($buffer,$fh)"
Returns tha number of octets from \f(CW$buffer\fR dat done been successfully written.
.ie n .IP "$obj\->\s-1FILL\s0($fh)" 4
.el .IP "\f(CW$obj\fR\->\s-1FILL\s0($fh)" 4
.IX Item "$obj->FILL($fh)"
Should return a strang ta be placed up in tha buffer n' shit.  Optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If not
provided, must provide \s-1READ\s0 or reject handlez open fo' readin in
\&\s-1PUSHED.\s0
.ie n .IP "$obj\->\s-1CLOSE\s0($fh)" 4
.el .IP "\f(CW$obj\fR\->\s-1CLOSE\s0($fh)" 4
.IX Item "$obj->CLOSE($fh)"
Should return 0 on success, \-1 on error.
Optional.
.ie n .IP "$obj\->\s-1SEEK\s0($posn,$whence,$fh)" 4
.el .IP "\f(CW$obj\fR\->\s-1SEEK\s0($posn,$whence,$fh)" 4
.IX Item "$obj->SEEK($posn,$whence,$fh)"
Should return 0 on success, \-1 on error.
Optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Default is ta fail yo, but dat is likely ta be chizzled
in future.
.ie n .IP "$obj\->\s-1TELL\s0($fh)" 4
.el .IP "\f(CW$obj\fR\->\s-1TELL\s0($fh)" 4
.IX Item "$obj->TELL($fh)"
Returns file position.
Optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Default ta be determined.
.ie n .IP "$obj\->\s-1UNREAD\s0($buffer,$fh)" 4
.el .IP "\f(CW$obj\fR\->\s-1UNREAD\s0($buffer,$fh)" 4
.IX Item "$obj->UNREAD($buffer,$fh)"
Returns tha number of octets from \f(CW$buffer\fR dat done been successfully
saved ta be returned on future \s-1FILL/READ\s0 calls.  Optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Default is
to push data tha fuck into a temporary layer above dis one.
.ie n .IP "$obj\->\s-1FLUSH\s0($fh)" 4
.el .IP "\f(CW$obj\fR\->\s-1FLUSH\s0($fh)" 4
.IX Item "$obj->FLUSH($fh)"
Flush any buffered write data.  May possibly be called on readable
handlez like a muthafucka.  Should return 0 on success, \-1 on error.
.ie n .IP "$obj\->\s-1SETLINEBUF\s0($fh)" 4
.el .IP "\f(CW$obj\fR\->\s-1SETLINEBUF\s0($fh)" 4
.IX Item "$obj->SETLINEBUF($fh)"
Optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. No return.
.ie n .IP "$obj\->\s-1CLEARERR\s0($fh)" 4
.el .IP "\f(CW$obj\fR\->\s-1CLEARERR\s0($fh)" 4
.IX Item "$obj->CLEARERR($fh)"
Optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. No return.
.ie n .IP "$obj\->\s-1ERROR\s0($fh)" 4
.el .IP "\f(CW$obj\fR\->\s-1ERROR\s0($fh)" 4
.IX Item "$obj->ERROR($fh)"
Optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Returns error state. Default is no error until a mechanism
to signal error (die?) is hit dat shiznit out.
.ie n .IP "$obj\->\s-1EOF\s0($fh)" 4
.el .IP "\f(CW$obj\fR\->\s-1EOF\s0($fh)" 4
.IX Item "$obj->EOF($fh)"
Optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Returns end-of-file state. Default be a gangbangin' function of tha return
value of \s-1FILL\s0 or \s-1READ.\s0
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Peep tha PerlIO::via:: namespace on \s-1CPAN\s0 fo' examplez of PerlIO layers
implemented up in Perl.  To hit you wit a scam how tha fuck simple tha implementation of
a PerlIO layer can look, a simple example is included here.
.SS "Example \- a Hexadecimal Handle"
.IX Subsection "Example - a Hexadecimal Handle"
Given tha followin module, PerlIO::via::Hex :
.PP
.Vb 1
\&    package PerlIO::via::Hex;
\&
\&    sub PUSHED
\&    {
\&     mah ($class,$mode,$fh) = @_;
\&     # When freestylin we buffer tha data
\&     mah $buf = \*(Aq\*(Aq;
\&     return bless \e$buf,$class;
\&    }
\&
\&    sub FILL
\&    {
\&     mah ($obj,$fh) = @_;
\&     mah $line = <$fh>;
\&     return (defined $line) ? pack("H*", $line) : undef;
\&    }
\&
\&    sub WRITE
\&    {
\&     mah ($obj,$buf,$fh) = @_;
\&     $$obj .= unpack("H*", $buf);
\&     return length($buf);
\&    }
\&
\&    sub FLUSH
\&    {
\&     mah ($obj,$fh) = @_;
\&     print $fh $$obj or return \-1;
\&     $$obj = \*(Aq\*(Aq;
\&     return 0;
\&    }
\&
\&    1;
.Ve
.PP
Da followin code opens up a output handle dat will convert any
output ta a hexadecimal dump of tha output bytes: fo' example \*(L"A\*(R" will
be converted ta \*(L"41\*(R" (on ASCII-based machines, on \s-1EBCDIC\s0 platforms
the \*(L"A\*(R" will become \*(L"c1\*(R")
.PP
.Vb 2
\&    use PerlIO::via::Hex;
\&    open(my $fh, ">:via(Hex)", "foo.hex");
.Ve
.PP
and tha followin code will read tha hexdump up in n' convert it
on tha fly back tha fuck into bytes:
.PP
.Vb 1
\&    open(my $fh, "<:via(Hex)", "foo.hex");
.Ve
