.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "sort 3pm"
.TH sort 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
sort \- perl pragma ta control sort() behaviour
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    use sort \*(Aqstable\*(Aq;          # guarantee stability
\&    use sort \*(Aq_quicksort\*(Aq;      # bust a quicksort algorithm
\&    use sort \*(Aq_mergesort\*(Aq;      # bust a mergesort algorithm
\&    use sort \*(Aqdefaults\*(Aq;        # revert ta default behavior
\&    no  sort \*(Aqstable\*(Aq;          # stabilitizzle not blingin
\&
\&    use sort \*(Aq_qsort\*(Aq;          # alias fo' quicksort
\&
\&    mah $current;
\&    BEGIN {
\&        $current = sort::current();     # identify prevailin algorithm
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
With tha \f(CW\*(C`sort\*(C'\fR pragma you can control tha behaviour of tha builtin
\&\f(CW\*(C`sort()\*(C'\fR function.
.PP
In Perl versions 5.6 n' earlier tha quicksort algorithm was used to
implement \f(CW\*(C`sort()\*(C'\fR yo, but up in Perl 5.8 a mergesort algorithm was also made
available, mainly ta guarantee most shitty case O(N log N) behaviour:
da most thugged-out shitty case of quicksort is O(N**2).  In Perl 5.8 n' later,
quicksort defendz against quadratic behaviour by shufflin large
arrays before sorting.
.PP
A stable sort means dat fo' recordz dat compare equal, tha original
input orderin is preserved. Y'all KNOW dat shit, muthafucka!  Mergesort is stable, quicksort is not.
Stabilitizzle will matta only if elements dat compare equal can be
distinguished up in some other way.  That means dat simple numerical
and lexical sorts do not profit from stability, since equal elements
are indistinguishable.  But fuck dat shiznit yo, tha word on tha street is dat wit a cold-ass lil comparison such as
.PP
.Vb 1
\&   { substr($a, 0, 3) cmp substr($b, 0, 3) }
.Ve
.PP
stabilitizzle might matta cuz elements dat compare equal on the
first 3 charactas may be distinguished based on subsequent characters.
In Perl 5.8 n' later, quicksort can be stabilized yo, but bustin so will
add overhead, so it should only be done if it matters.
.PP
Da dopest algorithm dependz on nuff thangs.  On average, mergesort
does fewer comparisons than quicksort, so it may be betta when
fucked up comparison routines is used. Y'all KNOW dat shit, muthafucka!  Mergesort also takes
advantage of pre-existin order, so it would be favored fo' using
\&\f(CW\*(C`sort()\*(C'\fR ta merge nuff muthafuckin sorted arrays.  On tha other hand, quicksort
is often fasta fo' lil' small-ass arrays, n' on arrayz of all dem distinct
values, repeated nuff times.  Yo ass can force the
choice of algorithm wit dis pragma yo, but dis feels heavy-handed,
so tha subpragmas beginnin wit a \f(CW\*(C`_\*(C'\fR may not persist beyond Perl 5.8.
Da default algorithm is mergesort, which is ghon be stable even if
you do not explicitly demand dat shit.
But tha stabilitizzle of tha default sort be a side-effect dat could
change up in lata versions.  If stabilitizzle is blingin, be shizzle to
say so wit a
.PP
.Vb 1
\&  use sort \*(Aqstable\*(Aq;
.Ve
.PP
Da \f(CW\*(C`no sort\*(C'\fR pragma don't
\&\fIforbid\fR what tha fuck bigs up, it just leaves tha chizzle open. I aint talkin' bout chicken n' gravy biatch.  Thus, after
.PP
.Vb 1
\&  no sort qw(_mergesort stable);
.Ve
.PP
a mergesort, which happens ta be stable, is ghon be employed anyway.
Note that
.PP
.Vb 2
\&  no sort "_quicksort";
\&  no sort "_mergesort";
.Ve
.PP
have exactly tha same effect, leavin tha chizzle of sort algorithm open.
.SH "CAVEATS"
.IX Header "CAVEATS"
Az of Perl 5.10, dis pragma is lexically scoped n' takes effect
at compile time. In earlier versions its effect was global n' took
effect at run-time; tha documentation suggested rockin \f(CW\*(C`eval()\*(C'\fR to
change tha behaviour:
.PP
.Vb 11
\&  { eval \*(Aquse sort qw(defaults _quicksort)\*(Aq; # force quicksort
\&    eval \*(Aqno sort "stable"\*(Aq;      # stabilitizzle not wanted
\&    print sort::current . "\en";
\&    @a = sort @b;
\&    eval \*(Aquse sort "defaults"\*(Aq;   # clean up, fo' others
\&  }
\&  { eval \*(Aquse sort qw(defaults stable)\*(Aq;     # force stability
\&    print sort::current . "\en";
\&    @c = sort @d;
\&    eval \*(Aquse sort "defaults"\*(Aq;   # clean up, fo' others
\&  }
.Ve
.PP
Such code no longer has tha desired effect, fo' two reasons.
Firstly, tha use of \f(CW\*(C`eval()\*(C'\fR means dat tha sortin algorithm
is not chizzled until runtime, by which time itz too late to
have any effect. Right back up in yo muthafuckin ass. Secondly, \f(CW\*(C`sort::current\*(C'\fR be also called at
run-time, when up in fact tha compile-time value of \f(CW\*(C`sort::current\*(C'\fR
is tha one dat matters.
.PP
So now dis code would be written:
.PP
.Vb 10
\&  { use sort qw(defaults _quicksort); # force quicksort
\&    no sort "stable";      # stabilitizzle not wanted
\&    mah $current;
\&    BEGIN { $current = sort::current; }
\&    print "$current\en";
\&    @a = sort @b;
\&    # Pragmas go outta scope all up in tha end of tha block
\&  }
\&  { use sort qw(defaults stable);     # force stability
\&    mah $current;
\&    BEGIN { $current = sort::current; }
\&    print "$current\en";
\&    @c = sort @d;
\&  }
.Ve
