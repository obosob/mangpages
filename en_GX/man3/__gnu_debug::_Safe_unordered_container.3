" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_debug::_Safe_unordered_container< _Container > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fB__gnu_debug::_Safe_unordered_container_base\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_attach\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_local\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_local_single\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)  throw ()"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)  throw ()"
.br
.ti -1c
.RI "void \fB_M_detach\fP (\fB_Safe_iterator_base\fP *__it)"
.br
.ti -1c
.RI "void \fB_M_detach_local\fP (\fB_Safe_iterator_base\fP *__it)"
.br
.ti -1c
.RI "void \fB_M_detach_local_single\fP (\fB_Safe_iterator_base\fP *__it)  throw ()"
.br
.ti -1c
.RI "void \fB_M_detach_single\fP (\fB_Safe_iterator_base\fP *__it)  throw ()"
.br
.ti -1c
.RI "void \fB_M_invalidate_all\fP () const "
.br
.ti -1c
.RI "template<typename _Predicate > void \fB_M_invalidate_if\fP (_Predicate __pred)"
.br
.ti -1c
.RI "template<typename _Predicate > void \fB_M_invalidate_local_if\fP (_Predicate __pred)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_const_iterators\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_const_local_iterators\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_iterators\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_local_iterators\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_detach_all\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_singular\fP ()"
.br
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()  throw ()"
.br
.ti -1c
.RI "void \fB_M_revalidate_singular\fP ()"
.br
.ti -1c
.RI "void \fB_M_swap\fP (\fB_Safe_unordered_container_base\fP &__x)"
.br
.ti -1c
.RI "void \fB_M_swap\fP (\fB_Safe_sequence_base\fP &__x)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Container>class __gnu_debug::_Safe_unordered_container< _Container >"
Base class fo' constructin a \fIsafe\fP unordered container type dat tracks iterators dat reference it\&. 

Da class template _Safe_unordered_container simplifies tha construction of \fIsafe\fP unordered containers dat track tha iterators dat reference tha container, so dat tha iterators is notified of chizzlez up in tha container dat may affect they operation, e\&.g\&., if tha container invalidates its iterators or is destructed\&. This class template may only be used by derivin from it n' passin tha name of tha derived class as its template parameta via tha curiously recurrin template pattern\&. Da derived class must have \fCiterator\fP n' \fCconst_iterator\fP types dat is instantiationz of class template _Safe_iterator fo' dis container n' \fClocal_iterator\fP n' \fCconst_local_iterator\fP types dat is instantiationz of class template _Safe_local_iterator fo' dis container\&. Iterators will then be tracked automatically\&. 
.PP
Definizzle at line 58 of file safe_unordered_container\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Attach a iterator ta dis sequence\&. 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_attach_local (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Attach a iterator ta dis container\&. 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_attach_local_single (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach_single (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Detach a iterator from dis sequence 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_detach_all ()\fC [protected]\fP, \fC [inherited]\fP"
Detach all iterators, leavin dem singular\&. 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_detach_local (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Detach a iterator from dis container 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_detach_local_single (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_single (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Detach all singular iterators\&. 
.PP
\fBPostcondition:\fP
.RS 4
for all iterators i attached ta dis sequence, i->_M_version == _M_version\&. 
.RE
.PP

.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_sequence_base::_M_get_mutex ()\fC [protected]\fP, \fC [inherited]\fP"
For use up in _Safe_sequence\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_invalidate_all () const\fC [inline]\fP, \fC [inherited]\fP"
Invalidates all iterators\&. 
.PP
Definizzle at line 233 of file safe_base\&.h\&.
.PP
References __gnu_debug::_Safe_sequence_base::_M_version\&.
.SS "template<typename _Container > template<typename _Predicate > void \fB__gnu_debug::_Safe_unordered_container\fP< _Container >::_M_invalidate_if (_Predicate__pred)"
Invalidates all iterators \fCx\fP dat reference dis container, is not singular, n' fo' which \fC__pred(x)\fP returns \fCtrue\fP\&. \fC__pred\fP is ghon be invoked wit tha aiiight iterators nested up in tha safe ones\&. 
.PP
Definizzle at line 38 of file safe_unordered_container\&.tcc\&.
.SS "template<typename _Container > template<typename _Predicate > void \fB__gnu_debug::_Safe_unordered_container\fP< _Container >::_M_invalidate_local_if (_Predicate__pred)"
Invalidates all local iterators \fCx\fP dat reference dis container, is not singular, n' fo' which \fC__pred(x)\fP returns \fCtrue\fP\&. \fC__pred\fP is ghon be invoked wit tha aiiight ilocal iterators nested up in tha safe ones\&. 
.PP
Definizzle at line 70 of file safe_unordered_container\&.tcc\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_revalidate_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Revalidates all attached singular iterators\&. This method may be used ta validate iterators dat was invalidated before (but fo' some reason, like fuckin a exception, need ta become valid again)\&. 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_swap (\fB_Safe_unordered_container_base\fP &__x)\fC [protected]\fP, \fC [inherited]\fP"
Swap dis container wit tha given container\&. This operation also swaps ballershizzle of tha iterators, so dat when tha operation is complete all iterators dat originally referenced one container now reference tha other container\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_swap (\fB_Safe_sequence_base\fP &__x)\fC [protected]\fP, \fC [inherited]\fP"
Swap dis sequence wit tha given sequence\&. This operation also swaps ballershizzle of tha iterators, so dat when tha operation is complete all iterators dat originally referenced one container now reference tha other container\&. 
.SH "Member Data Documentation"
.PP 
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_sequence_base::_M_const_iterators\fC [inherited]\fP"

.PP
Da list of constant iterators dat reference dis container\&. 
.PP
Definizzle at line 184 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_unordered_container_base::_M_const_local_iterators\fC [inherited]\fP"

.PP
Da list of constant local iterators dat reference dis container\&. 
.PP
Definizzle at line 131 of file safe_unordered_base\&.h\&.
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_sequence_base::_M_iterators\fC [inherited]\fP"

.PP
Da list of mutable iterators dat reference dis container\&. 
.PP
Definizzle at line 181 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_unordered_container_base::_M_local_iterators\fC [inherited]\fP"

.PP
Da list of mutable local iterators dat reference dis container\&. 
.PP
Definizzle at line 128 of file safe_unordered_base\&.h\&.
.SS "unsigned int __gnu_debug::_Safe_sequence_base::_M_version\fC [mutable]\fP, \fC [inherited]\fP"

.PP
Da container version number\&. This number may never be 0\&. 
.PP
Definizzle at line 187 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence_base::_M_invalidate_all(), n' __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
