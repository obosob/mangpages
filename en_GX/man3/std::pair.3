" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::pair< _T1, _T2 > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherited by \fBstd::sub_match< _Bi_ita >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _T1 \fBfirst_type\fP"
.br
.ti -1c
.RI "typedef _T2 \fBsecond_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "constexpr \fBpair\fP ()"
.br
.ti -1c
.RI "constexpr \fBpair\fP (const _T1 &__a, const _T2 &__b)"
.br
.ti -1c
.RI "template<class _U1 , class _U2 , class  = typename enable_if<__and_<is_convertible<const _U1&, _T1>,				is_convertible<const _U2&, _T2>>::value>::type> constexpr \fBpair\fP (const \fBpair\fP< _U1, _U2 > &__p)"
.br
.ti -1c
.RI "constexpr \fBpair\fP (const \fBpair\fP &)=default"
.br
.ti -1c
.RI "constexpr \fBpair\fP (\fBpair\fP &&)=default"
.br
.ti -1c
.RI "template<class _U1 , class  = typename enable_if<is_convertible<_U1, _T1>::value>::type> constexpr \fBpair\fP (_U1 &&__x, const _T2 &__y)"
.br
.ti -1c
.RI "template<class _U2 , class  = typename enable_if<is_convertible<_U2, _T2>::value>::type> constexpr \fBpair\fP (const _T1 &__x, _U2 &&__y)"
.br
.ti -1c
.RI "template<class _U1 , class _U2 , class  = typename enable_if<__and_<is_convertible<_U1, _T1>,				is_convertible<_U2, _T2>>::value>::type> constexpr \fBpair\fP (_U1 &&__x, _U2 &&__y)"
.br
.ti -1c
.RI "template<class _U1 , class _U2 , class  = typename enable_if<__and_<is_convertible<_U1, _T1>,				is_convertible<_U2, _T2>>::value>::type> constexpr \fBpair\fP (\fBpair\fP< _U1, _U2 > &&__p)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args1, typename\&.\&.\&. _Args2> \fBpair\fP (\fBpiecewise_construct_t\fP, \fBtuple\fP< _Args1\&.\&.\&.>, \fBtuple\fP< _Args2\&.\&.\&.>)"
.br
.ti -1c
.RI "\fBpair\fP & \fBoperator=\fP (const \fBpair\fP &__p)"
.br
.ti -1c
.RI "\fBpair\fP & \fBoperator=\fP (\fBpair\fP &&__p) noexcept(__and_< \fBis_nothrow_move_assignable\fP< _T1 >, \fBis_nothrow_move_assignable\fP< _T2 >>::value)"
.br
.ti -1c
.RI "template<class _U1 , class _U2 > \fBpair\fP & \fBoperator=\fP (const \fBpair\fP< _U1, _U2 > &__p)"
.br
.ti -1c
.RI "template<class _U1 , class _U2 > \fBpair\fP & \fBoperator=\fP (\fBpair\fP< _U1, _U2 > &&__p)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBpair\fP &__p) noexcept(noexcept(swap(\fBfirst\fP, __p\&.first))&&noexcept(swap(\fBsecond\fP, __p\&.second)))"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "_T1 \fBfirst\fP"
.br
.ti -1c
.RI "_T2 \fBsecond\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class _T1, class _T2>struct std::pair< _T1, _T2 >"
Struct holdin two objectz of arbitrary type\&. 


.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_T1\fP Type of first object\&. 
.br
\fI_T2\fP Type of second object\&. 
.RE
.PP

.PP
Definizzle at line 96 of file stl_pair\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "template<class _T1, class _T2> typedef _T2 \fBstd::pair\fP< _T1, _T2 >::\fBsecond_type\fP"

.PP
\fCfirst_type\fP is tha straight-up original gangsta bound type 
.PP
Definizzle at line 99 of file stl_pair\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class _T1, class _T2> constexpr \fBstd::pair\fP< _T1, _T2 >::\fBpair\fP ()\fC [inline]\fP"

.PP
\fCsecond\fP be a cold-ass lil copy of tha second object Da default constructor creates \fCfirst\fP n' \fCsecond\fP rockin they respectizzle default constructors\&. 
.PP
Definizzle at line 108 of file stl_pair\&.h\&.
.SS "template<class _T1, class _T2> constexpr \fBstd::pair\fP< _T1, _T2 >::\fBpair\fP (const _T1 &__a, const _T2 &__b)\fC [inline]\fP"
Two objects may be passed ta a \fCpair\fP constructor ta be copied\&. 
.PP
Definizzle at line 112 of file stl_pair\&.h\&.
.SS "template<class _T1, class _T2> template<class _U1 , class _U2 , class  = typename enable_if<__and_<is_convertible<const _U1&, _T1>,				is_convertible<const _U2&, _T2>>::value>::type> constexpr \fBstd::pair\fP< _T1, _T2 >::\fBpair\fP (const \fBpair\fP< _U1, _U2 > &__p)\fC [inline]\fP"
There be also a templated copy ctor fo' tha \fCpair\fP class itself\&. 
.PP
Definizzle at line 124 of file stl_pair\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "template<class _T1, class _T2> _T1 \fBstd::pair\fP< _T1, _T2 >::first"

.PP
\fCsecond_type\fP is tha second bound type 
.PP
Definizzle at line 101 of file stl_pair\&.h\&.
.PP
Referenced by std::_Temporary_buffer< _ForwardIterator, _Tp >::_Temporary_buffer(), std::set< _StateIdT >::insert(), std::operator<(), n' std::operator==()\&.
.SS "template<class _T1, class _T2> _T2 \fBstd::pair\fP< _T1, _T2 >::second"

.PP
\fCfirst\fP be a cold-ass lil copy of tha straight-up original gangsta object 
.PP
Definizzle at line 102 of file stl_pair\&.h\&.
.PP
Referenced by std::_Temporary_buffer< _ForwardIterator, _Tp >::_Temporary_buffer(), std::set< _StateIdT >::insert(), n' std::operator==()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
