.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bytes 3pm"
.TH bytes 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
bytes \- Perl pragma ta force byte semantics rather than characta semantics
.SH "NOTICE"
.IX Header "NOTICE"
This pragma reflects early attempts ta incorporate Unicode tha fuck into perl and
has since been superseded. Y'all KNOW dat shit, muthafucka! Well shiiiit, it breaks encapsulation (i.e. it exposes the
innardz of how tha fuck tha perl executable currently happens ta store a string),
and use of dis module fo' anythang other than debuggin purposes is
strongly discouraged. Y'all KNOW dat shit, muthafucka! If you feel dat tha functions here within might be
useful fo' yo' application, dis possibly indicates a mismatch between
your menstrual model of Perl Unicode n' tha current reality. In dat case,
you may wish ta read a shitload of tha perl Unicode documentation:
perluniintro, perlunitut, perlunifaq n' perlunicode.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&    use bytes;
\&    ... chr(...);       # or bytes::chr
\&    ... index(...);     # or bytes::index
\&    ... length(...);    # or bytes::length
\&    ... ord(...);       # or bytes::ord
\&    ... rindex(...);    # or bytes::rindex
\&    ... substr(...);    # or bytes::substr
\&    no bytes;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`use bytes\*(C'\fR pragma disablez characta semantics fo' tha rest of the
lexical scope up in which it appears.  \f(CW\*(C`no bytes\*(C'\fR can be used ta reverse
the effect of \f(CW\*(C`use bytes\*(C'\fR within tha current lexical scope.
.PP
Perl normally assumes characta semantics up in tha presence of character
data (i.e. data dat has come from a source dat has been marked as
bein of a particular characta encoding). When \f(CW\*(C`use bytes\*(C'\fR is in
effect, tha encodin is temporarily ignored, n' each strang is treated
as a seriez of bytes.
.PP
As a example, when Perl sees \f(CW\*(C`$x = chr(400)\*(C'\fR, it encodes tha character
in \s-1UTF\-8\s0 n' stores it up in \f(CW$x\fR. Then it is marked as characta data, so,
for instance, \f(CW\*(C`length $x\*(C'\fR returns \f(CW1\fR. But fuck dat shiznit yo, tha word on tha street is dat up in tha scope of the
\&\f(CW\*(C`bytes\*(C'\fR pragma, \f(CW$x\fR is treated as a seriez of bytes \- tha bytes dat make
up tha \s-1UTF8\s0 encodin \- n' \f(CW\*(C`length $x\*(C'\fR returns \f(CW2\fR:
.PP
.Vb 8
\&    $x = chr(400);
\&    print "Length is ", length $x, "\en";     # "Length is 1"
\&    printf "Contents is %vd\en", $x;         # "Contents is 400"
\&    { 
\&        use bytes; # or "require bytes; bytes::length()"
\&        print "Length is ", length $x, "\en"; # "Length is 2"
\&        printf "Contents is %vd\en", $x;     # "Contents is 198.144"
\&    }
.Ve
.PP
\&\fIchr()\fR, \fIord()\fR, \fIsubstr()\fR, \fIindex()\fR n' \fIrindex()\fR behave similarly.
.PP
For mo' on tha implications n' differences between character
semantics n' byte semantics, peep perluniintro n' perlunicode.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
\&\fIbytes::substr()\fR do not work as a \fIlvalue()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perluniintro, perlunicode, utf8
