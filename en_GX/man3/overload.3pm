.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "overload 3pm"
.TH overload 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
overload \- Package fo' overloadin Perl operations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package SomeThing;
\&
\&    use overload
\&        \*(Aq+\*(Aq => \e&myadd,
\&        \*(Aq\-\*(Aq => \e&mysub;
\&        # etc
\&    ...
\&
\&    package main;
\&    $a = SomeThing\->new( 57 );
\&    $b = 5 + $a;
\&    ...
\&    if (overload::Overloaded $b) {...}
\&    ...
\&    $strval = overload::StrVal $b;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This pragma allows overloadin of Perlz operators fo' a cold-ass lil class.
To overload built-in functions, peep \*(L"Overridin Built-in Functions\*(R" up in perlsub instead.
.SS "Fundamentals"
.IX Subsection "Fundamentals"
\fIDeclaration\fR
.IX Subsection "Declaration"
.PP
Argumentz of tha \f(CW\*(C`use overload\*(C'\fR directizzle is (key, value) pairs.
For tha full set of legal keys, peep \*(L"Overloadable Operations\*(R" below.
.PP
Operator implementations (the joints) can be subroutines,
references ta subroutines, or anonymous subroutines
\&\- up in other lyrics, anythang legal inside a \f(CW\*(C`&{ ... }\*(C'\fR call.
Values specified as strings is interpreted as method names.
Thus
.PP
.Vb 5
\&    package Number;
\&    use overload
\&        "\-" => "minus",
\&        "*=" => \e&muas,
\&        \*(Aq""\*(Aq => sub { ...; };
.Ve
.PP
declares dat subtraction is ta be implemented by method \f(CW\*(C`minus()\*(C'\fR
in tha class \f(CW\*(C`Number\*(C'\fR (or one of its base classes),
and dat tha function \f(CW\*(C`Number::muas()\*(C'\fR is ta be used fo' the
assignment form of multiplication, \f(CW\*(C`*=\*(C'\fR.
It also defines a anonymous subroutine ta implement stringification:
this is called whenever a object pimped tha fuck into tha package \f(CW\*(C`Number\*(C'\fR
is used up in a strang context (this subroutine might, fo' example,
return tha number as a Roman numeral).
.PP
\fICallin Conventions n' Magic Autogeneration\fR
.IX Subsection "Callin Conventions n' Magic Autogeneration"
.PP
Da followin sample implementation of \f(CW\*(C`minus()\*(C'\fR (which assumes
that \f(CW\*(C`Number\*(C'\fR objects is simply pimped references ta scalars)
illustrates tha callin conventions:
.PP
.Vb 8
\&    package Number;
\&    sub minus {
\&        mah ($self, $other, $swap) = @_;
\&        mah $result = $$self \- $other;         # *
\&        $result = \-$result if $swap;
\&        ref $result ? $result : bless \e$result;
\&    }
\&    # * may recurse once \- peep table below
.Ve
.PP
Three arguments is passed ta all subroutines specified up in the
\&\f(CW\*(C`use overload\*(C'\fR directizzle (with one exception \- peep \*(L"nomethod\*(R").
Da first of these is tha operand providin tha overloaded
operator implementation \-
in dis case, tha object whose \f(CW\*(C`minus()\*(C'\fR method is bein called.
.PP
Da second argument is tha other operand, or \f(CW\*(C`undef\*(C'\fR up in the
case of a unary operator.
.PP
Da third argument is set ta \s-1TRUE\s0 if (and only if) tha two
operandz done been swapped. Y'all KNOW dat shit, muthafucka!  Perl may do dis ta ensure dat the
first argument (\f(CW$self\fR) be a object implementin tha overloaded
operation, up in line wit general object callin conventions.
For example, if \f(CW$x\fR n' \f(CW$y\fR is \f(CW\*(C`Number\*(C'\fRs:
.PP
.Vb 5
\&    operation   |   generates a cold-ass lil call to
\&    ============|======================
\&    $x \- $y     |   minus($x, $y, \*(Aq\*(Aq)
\&    $x \- 7      |   minus($x, 7, \*(Aq\*(Aq)
\&    7 \- $x      |   minus($x, 7, 1)
.Ve
.PP
Perl may also use \f(CW\*(C`minus()\*(C'\fR ta implement other operators which
have not been specified up in tha \f(CW\*(C`use overload\*(C'\fR directive,
accordin ta tha rulez fo' \*(L"Magic Autogeneration\*(R" busted lyrics bout later.
For example, tha \f(CW\*(C`use overload\*(C'\fR above declared no subroutine
for any of tha operators \f(CW\*(C`\-\-\*(C'\fR, \f(CW\*(C`neg\*(C'\fR (the overload key for
unary minus), or \f(CW\*(C`\-=\*(C'\fR.  Thus
.PP
.Vb 5
\&    operation   |   generates a cold-ass lil call to
\&    ============|======================
\&    \-$x         |   minus($x, 0, 1)
\&    $x\-\-        |   minus($x, 1, undef)
\&    $x \-= 3     |   minus($x, 3, undef)
.Ve
.PP
Note tha \f(CW\*(C`undef\*(C'\fRs:
where autogeneration thangs up in dis biatch up in tha method fo' a standard
operator which do not chizzle either of its operands, such
as \f(CW\*(C`\-\*(C'\fR, bein used ta implement a operator which chizzles
the operand (\*(L"mutators\*(R": here, \f(CW\*(C`\-\-\*(C'\fR n' \f(CW\*(C`\-=\*(C'\fR),
Perl passes undef as tha third argument.
This still evaluates as \s-1FALSE,\s0 consistent wit tha fact that
the operandz aint been swapped yo, but gives tha subroutine
a chizzle ta alta its behaviour up in these cases.
.PP
In all tha above examples, \f(CW\*(C`minus()\*(C'\fR is required
only ta return tha result of tha subtraction:
Perl takes care of tha assignment ta \f(CW$x\fR.
In fact, such methodz should \fInot\fR modify they operands,
even if \f(CW\*(C`undef\*(C'\fR is passed as tha third argument
(see \*(L"Overloadable Operations\*(R").
.PP
Da same aint legit of implementationz of \f(CW\*(C`++\*(C'\fR n' \f(CW\*(C`\-\-\*(C'\fR:
these is sposed ta fuckin modify they operand.
An appropriate implementation of \f(CW\*(C`\-\-\*(C'\fR might look like
.PP
.Vb 3
\&    use overload \*(Aq\-\-\*(Aq => "decr",
\&        # ...
\&    sub decr { \-\-${$_[0]}; }
.Ve
.PP
\fIMathemagic, Mutators, n' Copy Constructors\fR
.IX Subsection "Mathemagic, Mutators, n' Copy Constructors"
.PP
Da term 'mathemagic' raps bout tha overloaded implementation
of mathematical operators.
Mathemagical operations raise a issue.
Consider tha code:
.PP
.Vb 2
\&    $a = $b;
\&    \-\-$a;
.Ve
.PP
If \f(CW$a\fR n' \f(CW$b\fR is scalars then afta these statements
.PP
.Vb 1
\&    $a == $b \- 1
.Ve
.PP
An object, however, be a reference ta pimped data, so if
\&\f(CW$a\fR n' \f(CW$b\fR is objects then tha assignment \f(CW\*(C`$a = $b\*(C'\fR
copies only tha reference, leavin \f(CW$a\fR n' \f(CW$b\fR referring
to tha same object data.
One might therefore expect tha operation \f(CW\*(C`\-\-$a\*(C'\fR ta decrement
\&\f(CW$b\fR as well as \f(CW$a\fR.
But fuck dat shiznit yo, tha word on tha street is dat dis would not be consistent wit how tha fuck we expect the
mathematical operators ta work.
.PP
Perl resolves dis dilemma by transparently callin a cold-ass lil copy
constructor before callin a method defined ta implement
a mutator (\f(CW\*(C`\-\-\*(C'\fR, \f(CW\*(C`+=\*(C'\fR, n' so on.).
In tha above example, when Perl reaches tha decrement
statement, it cook up a cold-ass lil copy of tha object data up in \f(CW$a\fR and
assigns ta \f(CW$a\fR a reference ta tha copied data.
Only then do it call \f(CW\*(C`decr()\*(C'\fR, which altas tha copied
data, leavin \f(CW$b\fR unchanged.
Thus tha object metaphor is preserved as far as possible,
while mathemagical operations still work accordin ta the
arithmetic metaphor.
.PP
Note: tha precedin paragraph raps bout what tha fuck happens when
Perl autogenerates tha copy constructor fo' a object based
on a scalar.
For other cases, peep \*(L"Copy Constructor\*(R".
.SS "Overloadable Operations"
.IX Subsection "Overloadable Operations"
Da complete list of keys dat can be specified up in tha \f(CW\*(C`use overload\*(C'\fR
directizzle is given, separated by spaces, up in tha jointz of the
hash \f(CW%overload::ops\fR:
.PP
.Vb 10
\& with_assign      => \*(Aq+ \- * / % ** << >> x .\*(Aq,
\& assign           => \*(Aq+= \-= *= /= %= **= <<= >>= x= .=\*(Aq,
\& num_comparison   => \*(Aq< <= > >= == !=\*(Aq,
\& \*(Aq3way_comparison\*(Aq=> \*(Aq<=> cmp\*(Aq,
\& str_comparison   => \*(Aqlt le gt ge eq ne\*(Aq,
\& binary           => \*(Aq& &= | |= ^ ^=\*(Aq,
\& unary            => \*(Aqneg ! ~\*(Aq,
\& mutators         => \*(Aq++ \-\-\*(Aq,
\& func             => \*(Aqatan2 cos sin exp abs log sqrt int\*(Aq,
\& conversion       => \*(Aqbool "" 0+ qr\*(Aq,
\& iterators        => \*(Aq<>\*(Aq,
\& filetest         => \*(Aq\-X\*(Aq,
\& dereferencin    => \*(Aq${} @{} %{} &{} *{}\*(Aq,
\& matchin         => \*(Aq~~\*(Aq,
\& special          => \*(Aqnomethod fallback =\*(Aq
.Ve
.PP
Most of tha overloadable operators map one-to-one ta these keys.
Exceptions, includin additionizzle overloadable operations not
apparent from dis hash, is included up in tha notes which follow.
.PP
A warnin is issued if a attempt is made ta regista a operator not found
above.
.IP "\(bu" 5
\&\f(CW\*(C`not\*(C'\fR
.Sp
Da operator \f(CW\*(C`not\*(C'\fR aint a valid key fo' \f(CW\*(C`use overload\*(C'\fR.
But fuck dat shiznit yo, tha word on tha street is dat if tha operator \f(CW\*(C`!\*(C'\fR is overloaded then tha same
implementation is ghon be used fo' \f(CW\*(C`not\*(C'\fR
(since tha two operators differ only up in precedence).
.IP "\(bu" 5
\&\f(CW\*(C`neg\*(C'\fR
.Sp
Da key \f(CW\*(C`neg\*(C'\fR is used fo' unary minus ta disambiguate it from
binary \f(CW\*(C`\-\*(C'\fR.
.IP "\(bu" 5
\&\f(CW\*(C`++\*(C'\fR, \f(CW\*(C`\-\-\*(C'\fR
.Sp
Assumin they is ta behave analogously ta Perlz \f(CW\*(C`++\*(C'\fR n' \f(CW\*(C`\-\-\*(C'\fR,
overloaded implementationz of these operators is required to
mutate they operands.
.Sp
No distinction is made between prefix n' postfix formz of the
increment n' decrement operators: these differ only up in the
point at which Perl calls tha associated subroutine when
evaluatin a expression.
.IP "\(bu" 5
\&\fIAssignments\fR
.Sp
.Vb 2
\&    +=  \-=  *=  /=  %=  **=  <<=  >>=  x=  .=
\&    &=  |=  ^=
.Ve
.Sp
Simple assignment aint overloadable (the \f(CW\*(Aq=\*(Aq\fR key is used
for tha \*(L"Copy Constructor\*(R").
Perl do gotz a way ta make assignments ta a object do whatever
you want yo, but dis involves rockin \fItie()\fR, not overload \-
see \*(L"tie\*(R" up in perlfunc n' tha \*(L"\s-1COOKBOOK\*(R"\s0 examplez below.
.Sp
Da subroutine fo' tha assignment variant of a operator is
required only ta return tha result of tha operation.
It be permitted ta chizzle tha value of its operand
(this is safe cuz Perl calls tha copy constructor first),
but dis is optionizzle since Perl assigns tha returned value to
the left-hand operand anyway.
.Sp
An object dat overloadz a assignment operator do so only in
respect of assignments ta dat object.
In other lyrics, Perl never calls tha correspondin methodz with
the third argument (the \*(L"swap\*(R" argument) set ta \s-1TRUE.\s0
For example, tha operation
.Sp
.Vb 1
\&    $a *= $b
.Ve
.Sp
cannot lead ta \f(CW$b\fRz implementation of \f(CW\*(C`*=\*(C'\fR bein called,
even if \f(CW$a\fR be a scalar.
(It can, however, generate a cold-ass lil call ta \f(CW$b\fRz method fo' \f(CW\*(C`*\*(C'\fR).
.IP "\(bu" 5
\&\fINon-mutators wit a mutator variant\fR
.Sp
.Vb 2
\&     +  \-  *  /  %  **  <<  >>  x  .
\&     &  |  ^
.Ve
.Sp
As busted lyrics bout above,
Perl may call methodz fo' operators like \f(CW\*(C`+\*(C'\fR n' \f(CW\*(C`&\*(C'\fR up in tha course
of implementin missin operations like \f(CW\*(C`++\*(C'\fR, \f(CW\*(C`+=\*(C'\fR, n' \f(CW\*(C`&=\*(C'\fR.
While these methodz may detect dis usage by testin tha definedness
of tha third argument, they should up in all cases avoid changin their
operands.
This is cuz Perl do not call tha copy constructor before
invokin these methods.
.IP "\(bu" 5
\&\f(CW\*(C`int\*(C'\fR
.Sp
Traditionally, tha Perl function \f(CW\*(C`int\*(C'\fR roundz ta 0
(see \*(L"int\*(R" up in perlfunc), n' so fo' floating-point-like types one
should follow tha same semantic.
.IP "\(bu" 5
\&\fIString, numeric, boolean, n' regexp conversions\fR
.Sp
.Vb 1
\&    ""  0+  bool
.Ve
.Sp
These conversions is invoked accordin ta context as necessary.
For example, tha subroutine fo' \f(CW\*(Aq""\*(Aq\fR (stringify) may be used
where tha overloaded object is passed as a argument ta \f(CW\*(C`print\*(C'\fR,
and dat fo' \f(CW\*(Aqbool\*(Aq\fR where it is tested up in tha condizzle of a gangbangin' flow
control statement (like \f(CW\*(C`while\*(C'\fR) or tha ternary \f(CW\*(C`?:\*(C'\fR operation.
.Sp
Of course, up in contexts like, fo' example, \f(CW\*(C`$obj + 1\*(C'\fR, Perl will
invoke \f(CW$obj\fRz implementation of \f(CW\*(C`+\*(C'\fR rather than (in this
example) convertin \f(CW$obj\fR ta a number rockin tha numify method
\&\f(CW\*(Aq0+\*(Aq\fR (an exception ta dis is when no method has been provided
for \f(CW\*(Aq+\*(Aq\fR n' \*(L"fallback\*(R" is set ta \s-1TRUE\s0).
.Sp
Da subroutines fo' \f(CW\*(Aq""\*(Aq\fR, \f(CW\*(Aq0+\*(Aq\fR, n' \f(CW\*(Aqbool\*(Aq\fR can return
any arbitrary Perl value.
If tha correspondin operation fo' dis value is overloaded too,
the operation is ghon be called again n' again n' again wit dis value.
.Sp
As a special case if tha overload returns tha object itself then it will
be used directly.  An overloaded conversion returnin tha object is
probably a funky-ass bug, cuz you likely ta git suttin' dat looks like
\&\f(CW\*(C`YourPackage=HASH(0x8172b34)\*(C'\fR.
.Sp
.Vb 1
\&    qr
.Ve
.Sp
Da subroutine fo' \f(CW\*(Aqqr\*(Aq\fR is used wherever tha object is
interpolated tha fuck into or used as a regexp, includin when it
appears on tha \s-1RHS\s0 of a \f(CW\*(C`=~\*(C'\fR or \f(CW\*(C`!~\*(C'\fR operator.
.Sp
\&\f(CW\*(C`qr\*(C'\fR must return a cold-ass lil compiled regexp, or a ref ta a cold-ass lil compiled regexp
(like fuckin \f(CW\*(C`qr//\*(C'\fR returns), n' any further overloadin on tha return
value is ghon be ignored.
.IP "\(bu" 5
\&\fIIteration\fR
.Sp
If \f(CW\*(C`<>\*(C'\fR is overloaded then tha same implementation is used
for both tha \fIread-filehandle\fR syntax \f(CW\*(C`<$var>\*(C'\fR and
\&\fIglobbing\fR syntax \f(CW\*(C`<${var}>\*(C'\fR.
.IP "\(bu" 5
\&\fIFile tests\fR
.Sp
Da key \f(CW\*(Aq\-X\*(Aq\fR is used ta specify a subroutine ta handle all the
filetest operators (\f(CW\*(C`\-f\*(C'\fR, \f(CW\*(C`\-x\*(C'\fR, n' so on: peep \*(L"\-X\*(R" up in perlfunc for
the full list);
it aint possible ta overload any filetest operator individually.
To distinguish them, tha letta followin tha '\-' is passed as the
second argument (that is, up in tha slot dat fo' binary operators
is used ta pass tha second operand).
.Sp
Callin a overloaded filetest operator do not affect tha stat value
associated wit tha special filehandle \f(CW\*(C`_\*(C'\fR.  It still refers ta the
result of tha last \f(CW\*(C`stat\*(C'\fR, \f(CW\*(C`lstat\*(C'\fR or unoverloaded filetest.
.Sp
This overload was introduced up in Perl 5.12.
.IP "\(bu" 5
\&\fIMatching\fR
.Sp
Da key \f(CW"~~"\fR allows you ta override tha smart-ass matchin logic used by
the \f(CW\*(C`~~\*(C'\fR operator n' tha switch construct (\f(CW\*(C`given\*(C'\fR/\f(CW\*(C`when\*(C'\fR).  See
\&\*(L"Switch Statements\*(R" up in perlsyn n' feature.
.Sp
Unusually, tha overloaded implementation of tha smart-ass match operator
does not git full control of tha smart-ass match behaviour.
In particular, up in tha followin code:
.Sp
.Vb 2
\&    package Foo;
\&    use overload \*(Aq~~\*(Aq => \*(Aqmatch\*(Aq;
\&
\&    mah $obj =  Foo\->new();
\&    $obj ~~ [ 1,2,3 ];
.Ve
.Sp
the smart-ass match do \fInot\fR invoke tha method call like this:
.Sp
.Vb 1
\&    $obj\->match([1,2,3],0);
.Ve
.Sp
rather, tha smart-ass match distributizzle rule takes precedence, so \f(CW$obj\fR is
smart matched against each array element up in turn until a match is found,
so you may peep between one n' three of these calls instead:
.Sp
.Vb 3
\&    $obj\->match(1,0);
\&    $obj\->match(2,0);
\&    $obj\->match(3,0);
.Ve
.Sp
Consult tha match table up in  \*(L"Smartmatch Operator\*(R" up in perlop for
detailz of when overloadin is invoked.
.IP "\(bu" 5
\&\fIDereferencing\fR
.Sp
.Vb 1
\&    ${}  @{}  %{}  &{}  *{}
.Ve
.Sp
If these operators is not explicitly overloaded then they
work up in tha aiiight way, yieldin tha underlyin scalar,
array, or whatever stores tha object data (or tha appropriate
error message if tha dereference operator don't match it).
Definin a cold-ass lil catch-all \f(CW\*(Aqnomethod\*(Aq\fR (see below)
makes no difference ta dis as tha catch-all function will
not be called ta implement a missin dereference operator.
.Sp
If a thugged-out dereference operator is overloaded then it must return a
\&\fIreference\fR of tha appropriate type (for example, the
subroutine fo' key \f(CW\*(Aq${}\*(Aq\fR should return a reference ta a
scalar, not a scalar), or another object which overloadz the
operator: dat is, tha subroutine only determines what tha fuck is
dereferenced n' tha actual dereferencin is left ta Perl.
As a special case, if tha subroutine returns tha object itself
then it aint gonna be called again n' again n' again \- avoidin infinite recursion.
.IP "\(bu" 5
\&\fISpecial\fR
.Sp
.Vb 1
\&    nomethod  fallback  =
.Ve
.Sp
See "Special Keys fo' \f(CW\*(C`use overload\*(C'\fR".
.SS "Magic Autogeneration"
.IX Subsection "Magic Autogeneration"
If a method fo' a operation aint found then Perl tries to
autogenerate a substitute implementation from tha operations
that done been defined.
.PP
Note: tha behaviour busted lyrics bout up in dis section can be disabled
by settin \f(CW\*(C`fallback\*(C'\fR ta \s-1FALSE \s0(see \*(L"fallback\*(R").
.PP
In tha followin tables, numbers indicate priority.
For example, tha table below states that,
if no implementation fo' \f(CW\*(Aq!\*(Aq\fR has been defined then Perl will
implement it rockin \f(CW\*(Aqbool\*(Aq\fR (that is, by invertin tha value
returned by tha method fo' \f(CW\*(Aqbool\*(Aq\fR);
if boolean conversion be also unimplemented then Perl will
use \f(CW\*(Aq0+\*(Aq\fR or, failin that, \f(CW\*(Aq""\*(Aq\fR.
.PP
.Vb 10
\&    operator | can be autogenerated from
\&             |
\&             | 0+   ""   bool   .   x
\&    =========|==========================
\&       0+    |       1     2
\&       ""    |  1          2
\&       bool  |  1    2
\&       int   |  1    2     3
\&       !     |  2    3     1
\&       qr    |  2    1     3
\&       .     |  2    1     3
\&       x     |  2    1     3
\&       .=    |  3    2     4    1
\&       x=    |  3    2     4        1
\&       <>    |  2    1     3
\&       \-X    |  2    1     3
.Ve
.PP
Note: Da iterator (\f(CW\*(Aq<>\*(Aq\fR) n' file test (\f(CW\*(Aq\-X\*(Aq\fR)
operators work as normal: if tha operand aint a pimped glob or
\&\s-1IO\s0 reference then it is converted ta a strang (usin tha method
for \f(CW\*(Aq""\*(Aq\fR, \f(CW\*(Aq0+\*(Aq\fR, or \f(CW\*(Aqbool\*(Aq\fR) ta be interpreted as a glob
or filename.
.PP
.Vb 10
\&    operator | can be autogenerated from
\&             |
\&             |  <   <=>   neg   \-=    \-
\&    =========|==========================
\&       neg   |                        1
\&       \-=    |                        1
\&       \-\-    |                   1    2
\&       abs   | a1    a2    b1        b2    [*]
\&       <     |        1
\&       <=    |        1
\&       >     |        1
\&       >=    |        1
\&       ==    |        1
\&       !=    |        1
\&
\&    * one from [a1, a2] n' one from [b1, b2]
.Ve
.PP
Just as numeric comparisons can be autogenerated from tha method
for \f(CW\*(Aq<=>\*(Aq\fR, strang comparisons can be autogenerated from
that fo' \f(CW\*(Aqcmp\*(Aq\fR:
.PP
.Vb 3
\&     operators          |  can be autogenerated from
\&    ====================|===========================
\&     lt gt le ge eq ne  |  cmp
.Ve
.PP
Similarly, autogeneration fo' keys \f(CW\*(Aq+=\*(Aq\fR n' \f(CW\*(Aq++\*(Aq\fR be analogous
to \f(CW\*(Aq\-=\*(Aq\fR n' \f(CW\*(Aq\-\-\*(Aq\fR above:
.PP
.Vb 6
\&    operator | can be autogenerated from
\&             |
\&             |  +=    +
\&    =========|==========================
\&        +=   |        1
\&        ++   |   1    2
.Ve
.PP
And other assignment variations is analogous to
\&\f(CW\*(Aq+=\*(Aq\fR n' \f(CW\*(Aq\-=\*(Aq\fR (and similar ta \f(CW\*(Aq.=\*(Aq\fR n' \f(CW\*(Aqx=\*(Aq\fR above):
.PP
.Vb 3
\&              operator ||  *= /= %= **= <<= >>= &= ^= |=
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-||\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    autogenerated from ||  *  /  %  **  <<  >>  &  ^  |
.Ve
.PP
Note also dat tha copy constructor (key \f(CW\*(Aq=\*(Aq\fR) may be
autogenerated yo, but only fo' objects based on scalars.
See \*(L"Copy Constructor\*(R".
.PP
\fIMinimal Set of Overloaded Operations\fR
.IX Subsection "Minimal Set of Overloaded Operations"
.PP
Since some operations can be automatically generated from others, there is
a minimal set of operations dat need ta be overloaded up in order ta have
the complete set of overloaded operations at onez disposal.
Of course, tha autogenerated operations may not do exactly what tha fuck tha user
expects, n' you can put dat on yo' toast.  Da minimal set is:
.PP
.Vb 6
\&    + \- * / % ** << >> x
\&    <=> cmp
\&    & | ^ ~
\&    atan2 cos sin exp log sqrt int
\&    "" 0+ bool
\&    ~~
.Ve
.PP
Of tha conversions, only one of string, boolean or numeric is
needed cuz each can be generated from either of tha other two.
.ie n .SS "Special Keys fo' ""use overload"""
.el .SS "Special Keys fo' \f(CWuse overload\fP"
.IX Subsection "Special Keys fo' use overload"
\fI\f(CI\*(C`nomethod\*(C'\fI\fR
.IX Subsection "nomethod"
.PP
Da \f(CW\*(Aqnomethod\*(Aq\fR key is used ta specify a cold-ass lil catch-all function to
be called fo' any operator dat aint individually overloaded.
Da specified function is ghon be passed four parameters.
Da first three arguments coincizzle wit dem dat would have been
passed ta tha correspondin method if it had been defined.
Da fourth argument is tha \f(CW\*(C`use overload\*(C'\fR key fo' dat missing
method.
.PP
For example, if \f(CW$a\fR be a object pimped tha fuck into a package declaring
.PP
.Vb 1
\&    use overload \*(Aqnomethod\*(Aq => \*(Aqcatch_all\*(Aq, # ...
.Ve
.PP
then tha operation
.PP
.Vb 1
\&    3 + $a
.Ve
.PP
could (unless a method is specifically declared fo' tha key
\&\f(CW\*(Aq+\*(Aq\fR) result up in a cold-ass lil call
.PP
.Vb 1
\&    catch_all($a, 3, 1, \*(Aq+\*(Aq)
.Ve
.PP
See \*(L"How tha fuck Perl Chizzlez a Operator Implementation\*(R".
.PP
\fI\f(CI\*(C`fallback\*(C'\fI\fR
.IX Subsection "fallback"
.PP
Da value assigned ta tha key \f(CW\*(Aqfallback\*(Aq\fR  drops some lyrics ta Perl how tha fuck hard
it should try ta find a alternatizzle way ta implement a missing
operator.
.IP "\(bu" 4
defined yo, but \s-1FALSE\s0
.Sp
.Vb 1
\&    use overload "fallback" => 0, # ... ;
.Ve
.Sp
This disablez \*(L"Magic Autogeneration\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`undef\*(C'\fR
.Sp
In tha default case where no value is explicitly assigned to
\&\f(CW\*(C`fallback\*(C'\fR, magic autogeneration is enabled.
.IP "\(bu" 4
\&\s-1TRUE\s0
.Sp
Da same as fo' \f(CW\*(C`undef\*(C'\fR yo, but if a missin operator cannot be
autogenerated then, instead of issuin a error message, Perl
is allowed ta revert ta what tha fuck it would have done fo' that
operator if there had been no \f(CW\*(C`use overload\*(C'\fR directive.
.Sp
Note: up in most cases, particularly tha \*(L"Copy Constructor\*(R",
this is unlikely ta be appropriate behaviour.
.PP
See \*(L"How tha fuck Perl Chizzlez a Operator Implementation\*(R".
.PP
\fICopy Constructor\fR
.IX Subsection "Copy Constructor"
.PP
As mentioned above,
this operation is called when a mutator be applied ta a reference
that shares its object wit some other reference.
For example, if \f(CW$b\fR is mathemagical, n' \f(CW\*(Aq++\*(Aq\fR is overloaded
with \f(CW\*(Aqincr\*(Aq\fR, n' \f(CW\*(Aq=\*(Aq\fR is overloaded wit \f(CW\*(Aqclone\*(Aq\fR, then the
code
.PP
.Vb 3
\&    $a = $b;
\&    # ... (other code which do not modify $a or $b) ...
\&    ++$b;
.Ve
.PP
would be executed up in a manner equivalent to
.PP
.Vb 4
\&    $a = $b;
\&    # ...
\&    $b = $b\->clone(undef, "");
\&    $b\->incr(undef, "");
.Ve
.PP
Note:
.IP "\(bu" 4
Da subroutine fo' \f(CW\*(Aq=\*(Aq\fR do not overload tha Perl assignment
operator: it is used only ta allow mutators ta work as busted lyrics about
here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  (See \*(L"Assignments\*(R" above.)
.IP "\(bu" 4
As fo' other operations, tha subroutine implementin '=' is passed
three arguments, though tha last two is always \f(CW\*(C`undef\*(C'\fR n' \f(CW\*(Aq\*(Aq\fR.
.IP "\(bu" 4
Da copy constructor is called only before a cold-ass lil call ta a gangbangin' function
declared ta implement a mutator, fo' example, if \f(CW\*(C`++$b;\*(C'\fR up in the
code above is effected via a method declared fo' key \f(CW\*(Aq++\*(Aq\fR
(or 'nomethod', passed \f(CW\*(Aq++\*(Aq\fR as tha fourth argument) or, by
autogeneration, \f(CW\*(Aq+=\*(Aq\fR.
It aint called if tha increment operation is effected by a cold-ass lil call
to tha method fo' \f(CW\*(Aq+\*(Aq\fR since, up in tha equivalent code,
.Sp
.Vb 2
\&    $a = $b;
\&    $b = $b + 1;
.Ve
.Sp
the data referred ta by \f(CW$a\fR is unchanged by tha assignment to
\&\f(CW$b\fR of a reference ta freshly smoked up object data.
.IP "\(bu" 4
Da copy constructor aint called if Perl determines dat it is
unnecessary cuz there is no other reference ta tha data being
modified.
.IP "\(bu" 4
If \f(CW\*(Aqfallback\*(Aq\fR is undefined or \s-1TRUE\s0 then a cold-ass lil copy constructor
can be autogenerated yo, but only fo' objects based on scalars.
In other cases it need ta be defined explicitly.
Where a objectz data is stored as, fo' example, a array of
scalars, tha followin might be appropriate:
.Sp
.Vb 1
\&    use overload \*(Aq=\*(Aq => sub { bless [ @{$_[0]} ] },  # ...
.Ve
.IP "\(bu" 4
If \f(CW\*(Aqfallback\*(Aq\fR is \s-1TRUE\s0 n' no copy constructor is defined then,
for objects not based on scalars, Perl may silently fall back on
simple assignment \- dat is, assignment of tha object reference.
In effect, dis disablez tha copy constructor mechanizzle since
no freshly smoked up copy of tha object data is pimped.
This be almost certainly not what tha fuck you want.
(It is, however, consistent: fo' example, Perlz fallback fo' the
\&\f(CW\*(C`++\*(C'\fR operator is ta increment tha reference itself.)
.SS "How tha fuck Perl Chizzlez a Operator Implementation"
.IX Subsection "How tha fuck Perl Chizzlez a Operator Implementation"
Which is checked first, \f(CW\*(C`nomethod\*(C'\fR or \f(CW\*(C`fallback\*(C'\fR?
If tha two operandz of a operator iz of different types and
both overload tha operator, which implementation is used?
Da followin is tha precedence rules:
.IP "1." 4
If tha straight-up original gangsta operand has declared a subroutine ta overload the
operator then use dat implementation.
.IP "2." 4
Otherwise, if fallback is \s-1TRUE\s0 or undefined fo' the
first operand then peep if the
rulez fo' autogeneration
allows another of its operators ta be used instead.
.IP "3." 4
Unless tha operator be a assignment (\f(CW\*(C`+=\*(C'\fR, \f(CW\*(C`\-=\*(C'\fR, etc.),
repeat step (1) up in respect of tha second operand.
.IP "4." 4
Repeat Step (2) up in respect of tha second operand.
.IP "5." 4
If tha straight-up original gangsta operand has a \*(L"nomethod\*(R" method then use dis shit.
.IP "6." 4
If tha second operand has a \*(L"nomethod\*(R" method then use dis shit.
.IP "7." 4
If \f(CW\*(C`fallback\*(C'\fR is \s-1TRUE\s0 fo' both operands
then big-ass up tha usual operation fo' tha operator,
treatin tha operandz as numbers, strings, or booleans
as appropriate fo' tha operator (see note).
.IP "8." 4
Nothang hit dat shiznit \- take a thugged-out dirt nap.
.PP
Where there is only one operand (or only one operand with
overloading) tha checks up in respect of tha other operand above are
skipped.
.PP
There is exceptions ta tha above rulez fo' dereference operations
(which, if Step 1 fails, always fall back ta tha normal, built-in
implementations \- peep Dereferencing), n' fo' \f(CW\*(C`~~\*(C'\fR (which has its
own set of rulez \- peep \f(CW\*(C`Matching\*(C'\fR under \*(L"Overloadable Operations\*(R"
above).
.PP
Note on Step 7: some operators gotz a gangbangin' finger-lickin' different semantic depending
on tha type of they operands.
As there is no way ta instruct Perl ta treat tha operandz as, e.g.,
numbers instead of strings, tha result here may not be what tha fuck you
expect.
See \*(L"\s-1BUGS AND PITFALLS\*(R"\s0.
.SS "Losin Overloading"
.IX Subsection "Losin Overloading"
Da restriction fo' tha comparison operation is dat even if, fo' example,
\&\f(CW\*(C`cmp\*(C'\fR should return a pimped reference, tha autogenerated \f(CW\*(C`lt\*(C'\fR
function will produce only a standard logical value based on the
numerical value of tha result of \f(CW\*(C`cmp\*(C'\fR.  In particular, a working
numeric conversion is needed up in dis case (possibly expressed up in terms of
other conversions).
.PP
Similarly, \f(CW\*(C`.=\*(C'\fR  n' \f(CW\*(C`x=\*(C'\fR operators lose they mathemagical properties
if tha strang conversion substitution be applied.
.PP
When you \fIchop()\fR a mathemagical object it is promoted ta a strang n' its
mathemagical propertizzles is lost.  Da same can happen wit other
operations as well.
.SS "Inheritizzle n' Overloading"
.IX Subsection "Inheritizzle n' Overloading"
Overloadin respects inheritizzle via tha \f(CW@ISA\fR hierarchy.
Inheritizzle interacts wit overloadin up in two ways.
.ie n .IP "Method names up in tha ""use overload"" directive" 4
.el .IP "Method names up in tha \f(CWuse overload\fR directive" 4
.IX Item "Method names up in tha use overload directive"
If \f(CW\*(C`value\*(C'\fR in
.Sp
.Vb 1
\&  use overload key => value;
.Ve
.Sp
is a string, it is interpreted as a method name \- which may
(in tha usual way) be inherited from another class.
.IP "Overloadin of a operation is inherited by derived classes" 4
.IX Item "Overloadin of a operation is inherited by derived classes"
Any class derived from a overloaded class be also overloaded
and inherits its operator implementations.
If tha same operator is overloaded up in mo' than one ancestor
then tha implementation is determined by tha usual inheritance
rules.
.Sp
For example, if \f(CW\*(C`A\*(C'\fR inherits from \f(CW\*(C`B\*(C'\fR n' \f(CW\*(C`C\*(C'\fR (in dat order),
\&\f(CW\*(C`B\*(C'\fR overloadz \f(CW\*(C`+\*(C'\fR wit \f(CW\*(C`\e&D::plus_sub\*(C'\fR, n' \f(CW\*(C`C\*(C'\fR overloads
\&\f(CW\*(C`+\*(C'\fR by \f(CW"plus_meth"\fR, then tha subroutine \f(CW\*(C`D::plus_sub\*(C'\fR will
be called ta implement operation \f(CW\*(C`+\*(C'\fR fo' a object up in package \f(CW\*(C`A\*(C'\fR.
.PP
Note dat up in Perl version prior ta 5.18 inheritizzle of tha \f(CW\*(C`fallback\*(C'\fR key
was not governed by tha above rules.  Da value of \f(CW\*(C`fallback\*(C'\fR up in tha straight-up original gangsta 
overloaded ancestor was used. Y'all KNOW dat shit, muthafucka!  This was fixed up in 5.18 ta follow tha usual
rulez of inheritance.
.SS "Run-time Overloading"
.IX Subsection "Run-time Overloading"
Since all \f(CW\*(C`use\*(C'\fR directives is executed at compile-time, tha only way to
change overloadin durin run-time is to
.PP
.Vb 1
\&    eval \*(Aquse overload "+" => \e&addmethod\*(Aq;
.Ve
.PP
Yo ass can also use
.PP
.Vb 1
\&    eval \*(Aqno overload "+", "\-\-", "<="\*(Aq;
.Ve
.PP
though tha use of these constructs durin run-time is questionable.
.SS "Public Functions"
.IX Subsection "Public Functions"
Package \f(CW\*(C`overload.pm\*(C'\fR serves up tha followin hood functions:
.IP "overload::StrVal(arg)" 5
.IX Item "overload::StrVal(arg)"
Gives tha strang value of \f(CW\*(C`arg\*(C'\fR as up in the
absence of stringify overloading.  If you
are rockin dis ta git tha address of a reference (useful fo' checkin if two
references point ta tha same thang) then you may be betta off using
\&\f(CW\*(C`Scalar::Util::refaddr()\*(C'\fR, which is faster.
.IP "overload::Overloaded(arg)" 5
.IX Item "overload::Overloaded(arg)"
Returns legit if \f(CW\*(C`arg\*(C'\fR is subject ta overloadin of some operations.
.IP "overload::Method(obj,op)" 5
.IX Item "overload::Method(obj,op)"
Returns \f(CW\*(C`undef\*(C'\fR or a reference ta tha method dat implements \f(CW\*(C`op\*(C'\fR.
.SS "Overloadin Constants"
.IX Subsection "Overloadin Constants"
For some applications, tha Perl parser manglez constants too much.
It be possible ta hook tha fuck into dis process via \f(CW\*(C`overload::constant()\*(C'\fR
and \f(CW\*(C`overload::remove_constant()\*(C'\fR functions.
.PP
These functions take a hash as a argument.  Da recognized keyz of dis hash
are:
.IP "integer" 8
.IX Item "integer"
to overload integer constants,
.IP "float" 8
.IX Item "float"
to overload floatin point constants,
.IP "binary" 8
.IX Item "binary"
to overload octal n' hexadecimal constants,
.IP "q" 8
.IX Item "q"
to overload \f(CW\*(C`q\*(C'\fR\-quoted strings, constant piecez of \f(CW\*(C`qq\*(C'\fR\- n' \f(CW\*(C`qx\*(C'\fR\-quoted
strings n' here-documents,
.IP "qr" 8
.IX Item "qr"
to overload constant piecez of regular expressions.
.PP
Da correspondin joints is references ta functions which take three arguments:
the first one is tha \fIinitial\fR strang form of tha constant, tha second one
is how tha fuck Perl interprets dis constant, tha third one is how tha fuck tha constant is used.
Note dat tha initial strang form do not
contain strang delimiters, n' has backslashes up in backslash-delimiter
combinations stripped (thus tha value of delimita aint relevant for
processin of dis string).  Da return value of dis function is how tha fuck this
constant is goin ta be interpreted by Perl.  Da third argument is undefined
unless fo' overloaded \f(CW\*(C`q\*(C'\fR\- n' \f(CW\*(C`qr\*(C'\fR\- constants, it is \f(CW\*(C`q\*(C'\fR up in single-quote
context (be reppin strings, regular expressions, n' single-quote \s-1HERE\s0
documents), it is \f(CW\*(C`tr\*(C'\fR fo' argumentz of \f(CW\*(C`tr\*(C'\fR/\f(CW\*(C`y\*(C'\fR operators,
it is \f(CW\*(C`s\*(C'\fR fo' right-hand side of \f(CW\*(C`s\*(C'\fR\-operator, n' it is \f(CW\*(C`qq\*(C'\fR otherwise.
.PP
Since a expression \f(CW"ab$cd,,"\fR is just a gangbangin' finger-lickin' dirty-ass shortcut fo' \f(CW\*(Aqab\*(Aq . $cd . \*(Aq,,\*(Aq\fR,
it is expected dat overloaded constant strings is equipped wit reasonable
overloaded catenation operator, otherwise absurd thangs up in dis biatch will result.
Similarly, wack numbers is considered as negationz of positizzle constants.
.PP
Note dat it is probably meaningless ta booty-call tha functions \fIoverload::constant()\fR
and \fIoverload::remove_constant()\fR from anywhere but \fIimport()\fR n' \fIunimport()\fR methods.
From these methodz they may be called as
.PP
.Vb 6
\&    sub import {
\&       shift;
\&       return unless @_;
\&       take a thugged-out dirtnap "unknown import: @_" unless @_ == 1 n' $_[0] eq \*(Aq:constant\*(Aq;
\&       overload::constant integer => sub {Math::BigInt\->new(shift)};
\&    }
.Ve
.SH "IMPLEMENTATION"
.IX Header "IMPLEMENTATION"
What bigs up is subject ta chizzle \s-1RSN.\s0
.PP
Da table of methodz fo' all operations is cached up in magic fo' the
symbol table hash fo' tha package.  Da cache is invalidated during
processin of \f(CW\*(C`use overload\*(C'\fR, \f(CW\*(C`no overload\*(C'\fR, freshly smoked up function
definitions, n' chizzlez up in \f(CW@ISA\fR.
.PP
(Every SVish thang has a magic queue, n' magic be a entry up in that
queue.  This is how tha fuck a single variable may participate up in multiple
formz of magic simultaneously.  For instance, environment variables
regularly have two forms at once: they \f(CW%ENV\fR magic n' they taint
magic.  But fuck dat shiznit yo, tha word on tha street is dat tha magic which implements overloadin be applied to
the stashes, which is rarely used directly, thus should not slow down
Perl.)
.PP
If a package uses overload, it carries a special flag.  This flag be also
set when freshly smoked up function is defined or \f(CW@ISA\fR is modified. Y'all KNOW dat shit, muthafucka!  There is ghon be a
slight speed penalty on tha straight-up first operation thereafta dat supports
overloading, while tha overload tablez is updated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If there is no
overloadin present, tha flag is turned off.  Thus tha only speed penalty
thereafta is tha checkin of dis flag.
.PP
It be expected dat arguments ta methodz dat is not explicitly supposed
to be chizzled is constant (but dis aint enforced).
.SH "COOKBOOK"
.IX Header "COOKBOOK"
Please add examplez ta what tha fuck bigs up!
.SS "Two-face Scalars"
.IX Subsection "Two-face Scalars"
Put dis up in \fItwo_face.pm\fR up in yo' Perl library directory:
.PP
.Vb 6
\&  package two_face;             # Scalars wit separate strang and
\&                                # numeric joints.
\&  sub freshly smoked up { mah $p = shift; bless [@_], $p }
\&  use overload \*(Aq""\*(Aq => \e&str, \*(Aq0+\*(Aq => \e&num, fallback => 1;
\&  sub num {shift\->[1]}
\&  sub str {shift\->[0]}
.Ve
.PP
Use it as bigs up:
.PP
.Vb 4
\&  require two_face;
\&  mah $seven = two_face\->new("vii", 7);
\&  printf "seven=$seven, seven=%d, eight=%d\en", $seven, $seven+1;
\&  print "seven gotz nuff \*(Aqi\*(Aq\en" if $seven =~ /i/;
.Ve
.PP
(Da second line creates a scalar which has both a strang value, n' a
numeric value.)  This prints:
.PP
.Vb 2
\&  seven=vii, seven=7, eight=8
\&  seven gotz nuff \*(Aqi\*(Aq
.Ve
.SS "Two-face References"
.IX Subsection "Two-face References"
Suppose you wanna create a object which be accessible as both an
array reference n' a hash reference.
.PP
.Vb 12
\&  package two_refs;
\&  use overload \*(Aq%{}\*(Aq => \e&gethash, \*(Aq@{}\*(Aq => sub { $ {shift()} };
\&  sub freshly smoked up {
\&    mah $p = shift;
\&    bless \e [@_], $p;
\&  }
\&  sub gethash {
\&    mah %h;
\&    mah $self = shift;
\&    tie %h, ref $self, $self;
\&    \e%h;
\&  }
\&
\&  sub TIEHASH { mah $p = shift; bless \e shift, $p }
\&  mah %fields;
\&  mah $i = 0;
\&  $fields{$_} = $i++ foreach qw{zero one two three};
\&  sub STORE {
\&    mah $self = ${shift()};
\&    mah $key = $fields{shift()};
\&    defined $key or take a thugged-out dirtnap "Out of crew access";
\&    $$self\->[$key] = shift;
\&  }
\&  sub FETCH {
\&    mah $self = ${shift()};
\&    mah $key = $fields{shift()};
\&    defined $key or take a thugged-out dirtnap "Out of crew access";
\&    $$self\->[$key];
\&  }
.Ve
.PP
Now one can access a object rockin both tha array n' hash syntax:
.PP
.Vb 3
\&  mah $bar = two_refs\->new(3,4,5,6);
\&  $bar\->[2] = 11;
\&  $bar\->{two} == 11 or take a thugged-out dirtnap \*(Aqbad hash fetch\*(Aq;
.Ve
.PP
Note nuff muthafuckin blingin featurez of dis example.  First of all, the
\&\fIactual\fR type of \f(CW$bar\fR be a scalar reference, n' our phat asses do not overload
the scalar dereference.  Thus we can git tha \fIactual\fR non-overloaded
contentz of \f(CW$bar\fR by just rockin \f(CW$$bar\fR (what our phat asses do up in functions which
overload dereference).  Similarly, tha object returned by the
\&\s-1\fITIEHASH\s0()\fR method be a scalar reference.
.PP
Second, we create a freshly smoked up tied hash each time tha hash syntax is used.
This allows our asses not ta worry on some possibilitizzle of a reference loop,
which would lead ta a memory leak.
.PP
Both these problems can be cured. Y'all KNOW dat shit, muthafucka!  Say, if we wanna overload hash
dereference on a reference ta a object which is \fIimplemented\fR as a
hash itself, tha only problem one has ta circumvent is how tha fuck ta access
this \fIactual\fR hash (as opposed ta tha \fIvirtual\fR hash exhibited by the
overloaded dereference operator).  Here is one possible fetchin routine:
.PP
.Vb 8
\&  sub access_hash {
\&    mah ($self, $key) = (shift, shift);
\&    mah $class = ref $self;
\&    bless $self, \*(Aqoverload::dummy\*(Aq; # Disable overloadin of %{}
\&    mah $out = $self\->{$key};
\&    bless $self, $class;        # Restore overloading
\&    $out;
\&  }
.Ve
.PP
To remove creation of tha tied hash on each access, one may a extra
level of indirection which allows a non-circular structure of references:
.PP
.Vb 10
\&  package two_refs1;
\&  use overload \*(Aq%{}\*(Aq => sub { ${shift()}\->[1] },
\&               \*(Aq@{}\*(Aq => sub { ${shift()}\->[0] };
\&  sub freshly smoked up {
\&    mah $p = shift;
\&    mah $a = [@_];
\&    mah %h;
\&    tie %h, $p, $a;
\&    bless \e [$a, \e%h], $p;
\&  }
\&  sub gethash {
\&    mah %h;
\&    mah $self = shift;
\&    tie %h, ref $self, $self;
\&    \e%h;
\&  }
\&
\&  sub TIEHASH { mah $p = shift; bless \e shift, $p }
\&  mah %fields;
\&  mah $i = 0;
\&  $fields{$_} = $i++ foreach qw{zero one two three};
\&  sub STORE {
\&    mah $a = ${shift()};
\&    mah $key = $fields{shift()};
\&    defined $key or take a thugged-out dirtnap "Out of crew access";
\&    $a\->[$key] = shift;
\&  }
\&  sub FETCH {
\&    mah $a = ${shift()};
\&    mah $key = $fields{shift()};
\&    defined $key or take a thugged-out dirtnap "Out of crew access";
\&    $a\->[$key];
\&  }
.Ve
.PP
Now if \f(CW$baz\fR is overloaded like this, then \f(CW$baz\fR be a reference ta a
reference ta tha intermediate array, which keeps a reference ta an
actual array, n' tha access hash.  Da \fItie()\fRin object fo' tha access
hash be a reference ta a reference ta tha actual array, so
.IP "\(bu" 4
There is no loopz of references.
.IP "\(bu" 4
Both \*(L"objects\*(R" which is pimped tha fuck into tha class \f(CW\*(C`two_refs1\*(C'\fR are
references ta a reference ta a array, thus references ta a \fIscalar\fR.
Thus tha accessor expression \f(CW\*(C`$$foo\->[$ind]\*(C'\fR involves no
overloaded operations.
.SS "Symbolic Calculator"
.IX Subsection "Symbolic Calculator"
Put dis up in \fIsymbolic.pm\fR up in yo' Perl library directory:
.PP
.Vb 2
\&  package symbolic;             # Primitizzle symbolic calculator
\&  use overload nomethod => \e&wrap;
\&
\&  sub freshly smoked up { shift; bless [\*(Aqn\*(Aq, @_] }
\&  sub wrap {
\&    mah ($obj, $other, $inv, $meth) = @_;
\&    ($obj, $other) = ($other, $obj) if $inv;
\&    bless [$meth, $obj, $other];
\&  }
.Ve
.PP
This module is straight-up unusual as overloaded modulez go: it do not
provide any usual overloaded operators, instead it serves up an
implementation fo' "\f(CW\*(C`nomethod\*(C'\fR".  In dis example tha \f(CW\*(C`nomethod\*(C'\fR
subroutine returns a object which encapsulates operations done over
the objects: \f(CW\*(C`symbolic\->new(3)\*(C'\fR gotz nuff \f(CW\*(C`[\*(Aqn\*(Aq, 3]\*(C'\fR, \f(CW\*(C`2 +
symbolic\->new(3)\*(C'\fR gotz nuff \f(CW\*(C`[\*(Aq+\*(Aq, 2, [\*(Aqn\*(Aq, 3]]\*(C'\fR.
.PP
Here be a example of tha script which \*(L"calculates\*(R" tha side of
circumscribed octagon rockin tha above package:
.PP
.Vb 4
\&  require symbolic;
\&  mah $ita = 1;                 # 2**($iter+2) = 8
\&  mah $side = symbolic\->new(1);
\&  mah $cnt = $iter;
\&
\&  while ($cnt\-\-) {
\&    $side = (sqrt(1 + $side**2) \- 1)/$side;
\&  }
\&  print "OK\en";
.Ve
.PP
Da value of \f(CW$side\fR is
.PP
.Vb 2
\&  [\*(Aq/\*(Aq, [\*(Aq\-\*(Aq, [\*(Aqsqrt\*(Aq, [\*(Aq+\*(Aq, 1, [\*(Aq**\*(Aq, [\*(Aqn\*(Aq, 1], 2]],
\&                       undef], 1], [\*(Aqn\*(Aq, 1]]
.Ve
.PP
Note dat while we obtained dis value rockin a sick lil script,
there is no simple way ta \fIuse\fR dis value.  In fact dis value may
be inspected up in debugger (see perldebug) yo, but only if
\&\f(CW\*(C`bareStringify\*(C'\fR \fBO\fRption is set, n' not via \f(CW\*(C`p\*(C'\fR command.
.PP
If one attempts ta print dis value, then tha overloaded operator
\&\f(CW""\fR is ghon be called, which will call \f(CW\*(C`nomethod\*(C'\fR operator. Shiiit, dis aint no joke.  The
result of dis operator is ghon be stringified again yo, but dis result is
again of type \f(CW\*(C`symbolic\*(C'\fR, which will lead ta a infinite loop.
.PP
Add a pretty-printa method ta tha module \fIsymbolic.pm\fR:
.PP
.Vb 8
\&  sub pretty {
\&    mah ($meth, $a, $b) = @{+shift};
\&    $a = \*(Aqu\*(Aq unless defined $a;
\&    $b = \*(Aqu\*(Aq unless defined $b;
\&    $a = $a\->pretty if ref $a;
\&    $b = $b\->pretty if ref $b;
\&    "[$meth $a $b]";
\&  }
.Ve
.PP
Now one can finish tha script by
.PP
.Vb 1
\&  print "side = ", $side\->pretty, "\en";
.Ve
.PP
Da method \f(CW\*(C`pretty\*(C'\fR is bustin object-to-strin conversion, so it
is natural ta overload tha operator \f(CW""\fR rockin dis method. Y'all KNOW dat shit, muthafucka!  However,
inside such a method it aint necessary ta pretty-print the
\&\fIcomponents\fR \f(CW$a\fR n' \f(CW$b\fR of a object.  In tha above subroutine
\&\f(CW"[$meth $a $b]"\fR be a cold-ass lil catenation of some strings n' components \f(CW$a\fR
and \f(CW$b\fR.  If these components use overloading, tha catenation operator
will look fo' a overloaded operator \f(CW\*(C`.\*(C'\fR; if not present, it will
look fo' a overloaded operator \f(CW""\fR.  Thus it is enough ta use
.PP
.Vb 7
\&  use overload nomethod => \e&wrap, \*(Aq""\*(Aq => \e&str;
\&  sub str {
\&    mah ($meth, $a, $b) = @{+shift};
\&    $a = \*(Aqu\*(Aq unless defined $a;
\&    $b = \*(Aqu\*(Aq unless defined $b;
\&    "[$meth $a $b]";
\&  }
.Ve
.PP
Now one can chizzle tha last line of tha script to
.PP
.Vb 1
\&  print "side = $side\en";
.Ve
.PP
which outputs
.PP
.Vb 1
\&  side = [/ [\- [sqrt [+ 1 [** [n 1 u] 2]] u] 1] [n 1 u]]
.Ve
.PP
and one can inspect tha value up in debugger rockin all tha possible
methods.
.PP
Somethang is still amiss: consider tha loop variable \f(CW$cnt\fR of the
script.  Dat shiznit was a number, not a object.  We cannot make dis value of
type \f(CW\*(C`symbolic\*(C'\fR, since then tha loop aint gonna terminate.
.PP
Indeed, ta terminizzle tha cycle, tha \f(CW$cnt\fR should become false.
But fuck dat shiznit yo, tha word on tha street is dat tha operator \f(CW\*(C`bool\*(C'\fR fo' checkin falsitizzle is overloaded (this
time via overloaded \f(CW""\fR), n' returns a long-ass string, thus any object
of type \f(CW\*(C`symbolic\*(C'\fR is true.  To overcome this, we need a way to
compare a object ta 0.  In fact, it is easier ta write a numeric
conversion routine.
.PP
Here is tha text of \fIsymbolic.pm\fR wit such a routine added (and
slightly modified \fIstr()\fR):
.PP
.Vb 3
\&  package symbolic;             # Primitizzle symbolic calculator
\&  use overload
\&    nomethod => \e&wrap, \*(Aq""\*(Aq => \e&str, \*(Aq0+\*(Aq => \e&num;
\&
\&  sub freshly smoked up { shift; bless [\*(Aqn\*(Aq, @_] }
\&  sub wrap {
\&    mah ($obj, $other, $inv, $meth) = @_;
\&    ($obj, $other) = ($other, $obj) if $inv;
\&    bless [$meth, $obj, $other];
\&  }
\&  sub str {
\&    mah ($meth, $a, $b) = @{+shift};
\&    $a = \*(Aqu\*(Aq unless defined $a;
\&    if (defined $b) {
\&      "[$meth $a $b]";
\&    } else {
\&      "[$meth $a]";
\&    }
\&  }
\&  mah %subr = ( n => sub {$_[0]},
\&               sqrt => sub {sqrt $_[0]},
\&               \*(Aq\-\*(Aq => sub {shift() \- shift()},
\&               \*(Aq+\*(Aq => sub {shift() + shift()},
\&               \*(Aq/\*(Aq => sub {shift() / shift()},
\&               \*(Aq*\*(Aq => sub {shift() * shift()},
\&               \*(Aq**\*(Aq => sub {shift() ** shift()},
\&             );
\&  sub num {
\&    mah ($meth, $a, $b) = @{+shift};
\&    mah $subr = $subr{$meth}
\&      or take a thugged-out dirtnap "Do not know how tha fuck ta ($meth) up in symbolic";
\&    $a = $a\->num if ref $a eq _\|_PACKAGE_\|_;
\&    $b = $b\->num if ref $b eq _\|_PACKAGE_\|_;
\&    $subr\->($a,$b);
\&  }
.Ve
.PP
All tha work of numeric conversion is done up in \f(CW%subr\fR n' \fInum()\fR.  Of
course, \f(CW%subr\fR aint complete, it gotz nuff only operators used up in the
example below.  Here is tha extra-credit question: why do we need an
explicit recursion up in \fInum()\fR?  (Answer be all up in tha end of dis section.)
.PP
Use dis module like this:
.PP
.Vb 4
\&  require symbolic;
\&  mah $ita = symbolic\->new(2);  # 16\-gon
\&  mah $side = symbolic\->new(1);
\&  mah $cnt = $iter;
\&
\&  while ($cnt) {
\&    $cnt = $cnt \- 1;            # Mutator \*(Aq\-\-\*(Aq not implemented
\&    $side = (sqrt(1 + $side**2) \- 1)/$side;
\&  }
\&  printf "%s=%f\en", $side, $side;
\&  printf "pi=%f\en", $side*(2**($iter+2));
.Ve
.PP
It prints (without all kindsa muthafuckin line breaks)
.PP
.Vb 4
\&  [/ [\- [sqrt [+ 1 [** [/ [\- [sqrt [+ 1 [** [n 1] 2]]] 1]
\&                          [n 1]] 2]]] 1]
\&     [/ [\- [sqrt [+ 1 [** [n 1] 2]]] 1] [n 1]]]=0.198912
\&  pi=3.182598
.Ve
.PP
Da above module is straight-up primitive.  It do not implement
mutator methodz (\f(CW\*(C`++\*(C'\fR, \f(CW\*(C`\-=\*(C'\fR n' so on), do not do deep copying
(not required without mutators!), n' implements only dem arithmetic
operations which is used up in tha example.
.PP
To implement most arithmetic operations is easy as fuck ; one should just use
the tablez of operations, n' chizzle tha code which fills \f(CW%subr\fR to
.PP
.Vb 12
\&  mah %subr = ( \*(Aqn\*(Aq => sub {$_[0]} );
\&  foreach mah $op (split " ", $overload::ops{with_assign}) {
\&    $subr{$op} = $subr{"$op="} = eval "sub {shift() $op shift()}";
\&  }
\&  mah @bins = qw(binary 3way_comparison num_comparison str_comparison);
\&  foreach mah $op (split " ", "@overload::ops{ @bins }") {
\&    $subr{$op} = eval "sub {shift() $op shift()}";
\&  }
\&  foreach mah $op (split " ", "@overload::ops{qw(unary func)}") {
\&    print "definin \*(Aq$op\*(Aq\en";
\&    $subr{$op} = eval "sub {$op shift()}";
\&  }
.Ve
.PP
Since subroutines implementin assignment operators is not required
to modify they operandz (see \*(L"Overloadable Operations\*(R" above),
we do not need anythang special ta make \f(CW\*(C`+=\*(C'\fR n' playaz work,
besides addin these operators ta \f(CW%subr\fR n' definin a cold-ass lil copy
constructor (needed since Perl has no way ta know dat the
implementation of \f(CW\*(Aq+=\*(Aq\fR do not mutate tha argument \-
see \*(L"Copy Constructor\*(R").
.PP
To implement a cold-ass lil copy constructor, add \f(CW\*(C`\*(Aq=\*(Aq => \e&cpy\*(C'\fR ta \f(CW\*(C`use overload\*(C'\fR
line, n' code (this code assumes dat mutators chizzle thangs one level
deep only, so recursive copyin aint needed):
.PP
.Vb 4
\&  sub cpy {
\&    mah $self = shift;
\&    bless [@$self], ref $self;
\&  }
.Ve
.PP
To make \f(CW\*(C`++\*(C'\fR n' \f(CW\*(C`\-\-\*(C'\fR work, we need ta implement actual mutators,
either directly, or up in \f(CW\*(C`nomethod\*(C'\fR.  We continue ta do thangs inside
\&\f(CW\*(C`nomethod\*(C'\fR, thus add
.PP
.Vb 4
\&    if ($meth eq \*(Aq++\*(Aq or $meth eq \*(Aq\-\-\*(Aq) {
\&      @$obj = ($meth, (bless [@$obj]), 1); # Avoid circular reference
\&      return $obj;
\&    }
.Ve
.PP
afta tha straight-up original gangsta line of \fIwrap()\fR.  This aint a most effective
implementation, one may consider
.PP
.Vb 1
\&  sub inc { $_[0] = bless [\*(Aq++\*(Aq, shift, 1]; }
.Ve
.PP
instead.
.PP
As a gangbangin' final remark, note dat one can fill \f(CW%subr\fR by
.PP
.Vb 10
\&  mah %subr = ( \*(Aqn\*(Aq => sub {$_[0]} );
\&  foreach mah $op (split " ", $overload::ops{with_assign}) {
\&    $subr{$op} = $subr{"$op="} = eval "sub {shift() $op shift()}";
\&  }
\&  mah @bins = qw(binary 3way_comparison num_comparison str_comparison);
\&  foreach mah $op (split " ", "@overload::ops{ @bins }") {
\&    $subr{$op} = eval "sub {shift() $op shift()}";
\&  }
\&  foreach mah $op (split " ", "@overload::ops{qw(unary func)}") {
\&    $subr{$op} = eval "sub {$op shift()}";
\&  }
\&  $subr{\*(Aq++\*(Aq} = $subr{\*(Aq+\*(Aq};
\&  $subr{\*(Aq\-\-\*(Aq} = $subr{\*(Aq\-\*(Aq};
.Ve
.PP
This finishes implementation of a primitizzle symbolic calculator in
50 linez of Perl code.  Since tha numeric jointz of subexpressions
are not cached, tha calculator is straight-up slow.
.PP
Here is tha answer fo' tha exercise: In tha case of \fIstr()\fR, we need no
explicit recursion since tha overloaded \f(CW\*(C`.\*(C'\fR\-operator will fall back
to a existin overloaded operator \f(CW""\fR.  Overloaded arithmetic
operators \fIdo not\fR fall back ta numeric conversion if \f(CW\*(C`fallback\*(C'\fR is
not explicitly requested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Thus without a explicit recursion \fInum()\fR
would convert \f(CW\*(C`[\*(Aq+\*(Aq, $a, $b]\*(C'\fR ta \f(CW\*(C`$a + $b\*(C'\fR, which would just rebuild
the argument of \fInum()\fR.
.PP
If you wonder why defaults fo' conversion is different fo' \fIstr()\fR and
\&\fInum()\fR, note how tha fuck easy as fuck  dat shiznit was ta write tha symbolic calculator. Shiiit, dis aint no joke.  This
simplicitizzle is cuz of a appropriate chizzle of defaults, n' you can put dat on yo' toast.  One extra
note: cuz of tha explicit recursion \fInum()\fR is mo' fragile than \fIsym()\fR:
we need ta explicitly check fo' tha type of \f(CW$a\fR n' \f(CW$b\fR.  If components
\&\f(CW$a\fR n' \f(CW$b\fR happen ta be of some related type, dis may lead ta problems.
.SS "\fIReally\fP Symbolic Calculator"
.IX Subsection "Straight-Up Symbolic Calculator"
One may wonder why we call tha above calculator symbolic.  Da reason
is dat tha actual calculation of tha value of expression is postponed
until tha value is \fIused\fR.
.PP
To peep it up in action, add a method
.PP
.Vb 5
\&  sub STORE {
\&    mah $obj = shift;
\&    $#$obj = 1;
\&    @$obj\->[0,1] = (\*(Aq=\*(Aq, shift);
\&  }
.Ve
.PP
to tha package \f(CW\*(C`symbolic\*(C'\fR.  Afta dis chizzle one can do
.PP
.Vb 3
\&  mah $a = symbolic\->new(3);
\&  mah $b = symbolic\->new(4);
\&  mah $c = sqrt($a**2 + $b**2);
.Ve
.PP
and tha numeric value of \f(CW$c\fR becomes 5.  But fuck dat shiznit yo, tha word on tha street is dat afta calling
.PP
.Vb 1
\&  $a\->STORE(12);  $b\->STORE(5);
.Ve
.PP
the numeric value of \f(CW$c\fR becomes 13.  There is no diggity now dat tha module
symbolic serves up a \fIsymbolic\fR calculator indeed.
.PP
To hide tha rough edges under tha hood, provide a \fItie()\fRd intercourse ta the
package \f(CW\*(C`symbolic\*(C'\fR.  Add methods
.PP
.Vb 3
\&  sub TIESCALAR { mah $pack = shift; $pack\->new(@_) }
\&  sub FETCH { shift }
\&  sub nop {  }          # Around a funky-ass bug
.Ve
.PP
(the bug, fixed up in Perl 5.14, is busted lyrics bout up in \*(L"\s-1BUGS\*(R"\s0).  One can use this
new intercourse as
.PP
.Vb 3
\&  tie $a, \*(Aqsymbolic\*(Aq, 3;
\&  tie $b, \*(Aqsymbolic\*(Aq, 4;
\&  $a\->nop;  $b\->nop;    # Around a funky-ass bug
\&
\&  mah $c = sqrt($a**2 + $b**2);
.Ve
.PP
Now numeric value of \f(CW$c\fR is 5.  Afta \f(CW\*(C`$a = 12; $b = 5\*(C'\fR tha numeric value
of \f(CW$c\fR becomes 13.  To insulate tha user of tha module add a method
.PP
.Vb 1
\&  sub vars { mah $p = shift; tie($_, $p), $_\->nop foreach @_; }
.Ve
.PP
Now
.PP
.Vb 3
\&  mah ($a, $b);
\&  symbolic\->vars($a, $b);
\&  mah $c = sqrt($a**2 + $b**2);
\&
\&  $a = 3; $b = 4;
\&  printf "c5  %s=%f\en", $c, $c;
\&
\&  $a = 12; $b = 5;
\&  printf "c13  %s=%f\en", $c, $c;
.Ve
.PP
shows dat tha numeric value of \f(CW$c\fR bigs up chizzlez ta tha jointz of \f(CW$a\fR
and \f(CW$b\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ilya Zakharevich <\fIilya@math.mps.ohio\-state.edu\fR>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Da \f(CW\*(C`overloading\*(C'\fR pragma can be used ta enable or disable overloaded
operations within a lexical scope \- peep overloading.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
When Perl is run wit tha \fB\-Do\fR switch or its equivalent, overloading
induces diagnostic lyrics.
.PP
Usin tha \f(CW\*(C`m\*(C'\fR command of Perl debugger (see perldebug) one can
deduce which operations is overloaded (and which ancestor triggers
this overloading).  Say, if \f(CW\*(C`eq\*(C'\fR is overloaded, then tha method \f(CW\*(C`(eq\*(C'\fR
is shown by debugger n' shit.  Da method \f(CW\*(C`()\*(C'\fR correspondz ta tha \f(CW\*(C`fallback\*(C'\fR
key (in fact a presence of dis method shows dat dis package has
overloadin enabled, n' it is what tha fuck is used by tha \f(CW\*(C`Overloaded\*(C'\fR
function of module \f(CW\*(C`overload\*(C'\fR).
.PP
Da module might issue tha followin warnings:
.IP "Odd number of arguments fo' overload::constant" 4
.IX Item "Odd number of arguments fo' overload::constant"
(W) Da call ta overload::constant contained a odd number of arguments.
Da arguments should come up in pairs.
.IP "'%s' aint a overloadable type" 4
.IX Item "'%s' aint a overloadable type"
(W) Yo ass tried ta overload a cold-ass lil constant type tha overload package is unaware of.
.IP "'%s' aint a cold-ass lil code reference" 4
.IX Item "'%s' aint a cold-ass lil code reference"
(W) Da second (fourth, sixth, ...) argument of overload::constant needs
to be a cold-ass lil code reference.  Either a anonymous subroutine, or a reference
to a subroutine.
.IP "overload arg '%s' is invalid" 4
.IX Item "overload arg '%s' is invalid"
(W) \f(CW\*(C`use overload\*(C'\fR was passed a argument it did not
recognize.  Did yo dirty ass mistype a operator?
.SH "BUGS AND PITFALLS"
.IX Header "BUGS AND PITFALLS"
.IP "\(bu" 4
A pitfall when fallback is \s-1TRUE\s0 n' Perl resorts ta a funky-ass built-in
implementation of a operator is dat some operators have more
than one semantic, fo' example \f(CW\*(C`|\*(C'\fR:
.Sp
.Vb 5
\&        use overload \*(Aq0+\*(Aq => sub { $_[0]\->{n}; },
\&            fallback => 1;
\&        mah $x = bless { n => 4 }, "main";
\&        mah $y = bless { n => 8 }, "main";
\&        print $x | $y, "\en";
.Ve
.Sp
Yo ass might expect dis ta output \*(L"12\*(R".
In fact, it prints \*(L"<\*(R": tha \s-1ASCII\s0 result of treatin \*(L"|\*(R"
as a funky-ass bitwise strang operator \- dat is, tha result of treating
the operandz as tha strings \*(L"4\*(R" n' \*(L"8\*(R" rather than numbers.
Da fact dat numify (\f(CW\*(C`0+\*(C'\fR) is implemented but stringify
(\f(CW""\fR) aint make no difference since tha latta is simply
autogenerated from tha former.
.Sp
Da only way ta chizzle dis is ta provide yo' own subroutine
for \f(CW\*(Aq|\*(Aq\fR.
.IP "\(bu" 4
Magic autogeneration increases tha potential fo' inadvertently
bustin self-referential structures.
Currently Perl aint gonna free self-referential
structures until cyclez is explicitly broken.
For example,
.Sp
.Vb 2
\&    use overload \*(Aq+\*(Aq => \*(Aqadd\*(Aq;
\&    sub add { bless [ \e$_[0], \e$_[1] ] };
.Ve
.Sp
is askin fo' shit, since
.Sp
.Vb 1
\&    $obj += $y;
.Ve
.Sp
will effectively become
.Sp
.Vb 1
\&    $obj = add($obj, $y, undef);
.Ve
.Sp
with tha same result as
.Sp
.Vb 1
\&    $obj = [\e$obj, \e$foo];
.Ve
.Sp
Even if no \fIexplicit\fR assignment-variantz of operators is present in
the script, they may be generated by tha optimizer.
For example,
.Sp
.Vb 1
\&    "obj = $obj\en"
.Ve
.Sp
may be optimized to
.Sp
.Vb 1
\&    mah $tmp = \*(Aqobj = \*(Aq . $obj;  $tmp .= "\en";
.Ve
.IP "\(bu" 4
Da symbol table is filled wit names lookin like line-noise.
.IP "\(bu" 4
This bug was fixed up in Perl 5.18 yo, but may still trip you up if yo ass is using
olda versions:
.Sp
For tha purpose of inheritizzle every last muthafuckin overloaded package behaves as if
\&\f(CW\*(C`fallback\*(C'\fR is present (possibly undefined).  This may create
interestin effects if some package aint overloaded yo, but inherits
from two overloaded packages.
.IP "\(bu" 4
Before Perl 5.14, tha relation between overloadin n' \fItie()\fRin was broken.
Overloadin was triggered or not based on tha \fIprevious\fR class of the
\&\fItie()\fRd variable.
.Sp
This happened cuz tha presence of overloadin was checked
too early, before any \fItie()\fRd access was attempted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If the
class of tha value \s-1\fIFETCH\s0()\fRed from tha tied variable do not
change, a simple workaround fo' code dat is ta run on olda Perl
versions is ta access tha value (via \f(CW\*(C`() = $foo\*(C'\fR or some such)
immediately afta \fItie()\fRing, so dat afta dis call tha \fIprevious\fR class
coincides wit tha current one.
.IP "\(bu" 4
Barewordz is not covered by overloaded strang constants.
.IP "\(bu" 4
Da range operator \f(CW\*(C`..\*(C'\fR cannot be overloaded.
