.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Select 3"
.TH Pod::Select 3 "2013-06-01" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Select, podselect() \- extract selected sectionz of POD from input
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Pod::Select;
\&
\&    ## Select all tha POD sections fo' each file up in @filelist
\&    ## n' print tha result on standard output.
\&    podselect(@filelist);
\&
\&    ## Same as above yo, but write ta tmp.out
\&    podselect({\-output => "tmp.out"}, @filelist):
\&
\&    ## Select from tha given filelist, only dem POD sections dat are
\&    ## within a 1st level section named any of: NAME, SYNOPSIS, OPTIONS.
\&    podselect({\-sections => ["NAME|SYNOPSIS", "OPTIONS"]}, @filelist):
\&
\&    ## Select tha "DESCRIPTION" section of tha PODs from STDIN n' write
\&    ## tha result ta STDERR.
\&    podselect({\-output => ">&STDERR", \-sections => ["DESCRIPTION"]}, \e*STDIN);
.Ve
.PP
or
.PP
.Vb 1
\&    use Pod::Select;
\&
\&    ## Smoke a parser object fo' selectin POD sections from tha input
\&    $parser = freshly smoked up Pod::Select();
\&
\&    ## Select all tha POD sections fo' each file up in @filelist
\&    ## n' print tha result ta tmp.out.
\&    $parser\->parse_from_file("<&STDIN", "tmp.out");
\&
\&    ## Select from tha given filelist, only dem POD sections dat are
\&    ## within a 1st level section named any of: NAME, SYNOPSIS, OPTIONS.
\&    $parser\->select("NAME|SYNOPSIS", "OPTIONS");
\&    fo' (@filelist) { $parser\->parse_from_file($_); }
\&
\&    ## Select tha "DESCRIPTION" n' "SEE ALSO" sectionz of tha PODs from
\&    ## STDIN n' write tha result ta STDERR.
\&    $parser\->select("DESCRIPTION");
\&    $parser\->add_selection("SEE ALSO");
\&    $parser\->parse_from_filehandle(\e*STDIN, \e*STDERR);
.Ve
.SH "REQUIRES"
.IX Header "REQUIRES"
perl5.005, Pod::Parser, Exporter, Carp
.SH "EXPORTS"
.IX Header "EXPORTS"
\&\fIpodselect()\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\f(BIpodselect()\fB\fR be a gangbangin' function which will extract specified sections of
pod documentation from a input stream. This mobilitizzle is provided by the
\&\fBPod::Select\fR module which be a subclass of \fBPod::Parser\fR.
\&\fBPod::Select\fR serves up a method named \fB\f(BIselect()\fB\fR ta specify tha set of
\&\s-1POD\s0 sections ta select fo' processing/printing. \fB\f(BIpodselect()\fB\fR merely
creates a \fBPod::Select\fR object n' then invokes tha \fB\f(BIpodselect()\fB\fR
followed by \fB\f(BIparse_from_file()\fB\fR.
.SH "SECTION SPECIFICATIONS"
.IX Header "SECTION SPECIFICATIONS"
\&\fB\f(BIpodselect()\fB\fR n' \fB\f(BIPod::Select::select()\fB\fR may be given one or more
\&\*(L"section justifications\*(R" ta restrict tha text processed ta only the
desired set of sections n' they correspondin subsections.  A section
specification be a strang containin one or mo' Perl-style regular
expressions separated by forward slashes (\*(L"/\*(R").  If you need ta use a
forward slash literally within a section title you can escape it wit a
backslash (\*(L"\e/\*(R").
.PP
Da formal syntax of a section justification is:
.IP "\(bu" 4
\&\fIhead1\-title\-regex\fR/\fIhead2\-title\-regex\fR/...
.PP
Any omitted or empty regular expressions will default ta \*(L".*\*(R".
Please note dat each regular expression given is implicitly
anchored by addin \*(L"^\*(R" n' \*(L"$\*(R" ta tha beginnin n' end yo, but it ain't no stoppin cause I be still poppin'.  Also, if a
given regular expression starts wit a \*(L"!\*(R" character, then the
expression is \fInegated\fR (so \f(CW\*(C`!foo\*(C'\fR would match anythang \fIexcept\fR
\&\f(CW\*(C`foo\*(C'\fR).
.PP
Some example section justifications follow.
.IP "\(bu" 4
Match tha \f(CW\*(C`NAME\*(C'\fR n' \f(CW\*(C`SYNOPSIS\*(C'\fR sections n' all of they subsections:
.Sp
\&\f(CW\*(C`NAME|SYNOPSIS\*(C'\fR
.IP "\(bu" 4
Match only tha \f(CW\*(C`Question\*(C'\fR n' \f(CW\*(C`Answer\*(C'\fR subsectionz of tha \f(CW\*(C`DESCRIPTION\*(C'\fR
section:
.Sp
\&\f(CW\*(C`DESCRIPTION/Question|Answer\*(C'\fR
.IP "\(bu" 4
Match tha \f(CW\*(C`Comments\*(C'\fR subsection of \fIall\fR sections:
.Sp
\&\f(CW\*(C`/Comments\*(C'\fR
.IP "\(bu" 4
Match all subsectionz of \f(CW\*(C`DESCRIPTION\*(C'\fR \fIexcept\fR fo' \f(CW\*(C`Comments\*(C'\fR:
.Sp
\&\f(CW\*(C`DESCRIPTION/!Comments\*(C'\fR
.IP "\(bu" 4
Match tha \f(CW\*(C`DESCRIPTION\*(C'\fR section but do \fInot\fR match any of its subsections:
.Sp
\&\f(CW\*(C`DESCRIPTION/!.+\*(C'\fR
.IP "\(bu" 4
Match all top level sections but none of they subsections:
.Sp
\&\f(CW\*(C`/!.+\*(C'\fR
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
Da followin methodz is provided up in dis module. Each one takes a
reference ta tha object itself as a implicit first parameter.
.SH "\fB\fP\f(BIcurr_headings()\fP\fB\fP"
.IX Header "curr_headings()"
.Vb 2
\&            ($head1, $head2, $head3, ...) = $parser\->curr_headings();
\&            $head1 = $parser\->curr_headings(1);
.Ve
.PP
This method returns a list of tha currently actizzle section headings and
subheadings up in tha document bein parsed. Y'all KNOW dat shit, muthafucka! Da list of headings returned
correspondz ta da most thugged-out recently parsed paragraph of tha input.
.PP
If a argument is given, it must correspond ta tha desired section
headin number, up in which case only tha specified section headin is
returned. Y'all KNOW dat shit, muthafucka! If there is no current section headin all up in tha specified
level, then \f(CW\*(C`undef\*(C'\fR is returned.
.SH "\fB\fP\f(BIselect()\fP\fB\fP"
.IX Header "select()"
.Vb 1
\&            $parser\->select($section_spec1,$section_spec2,...);
.Ve
.PP
This method is used ta select tha particular sections n' subsections of
\&\s-1POD\s0 documentation dat is ta be printed and/or processed. Y'all KNOW dat shit, muthafucka! Da existing
set of selected sections is \fIreplaced\fR wit tha given set of sections.
See \fB\f(BIadd_selection()\fB\fR fo' addin ta tha current set of selected
sections.
.PP
Each of tha \f(CW$section_spec\fR arguments should be a section justification
as busted lyrics bout up in \*(L"\s-1SECTION SPECIFICATIONS\*(R"\s0.  Da section justifications
are parsed by dis method n' tha resultin regular expressions are
stored up in tha invokin object.
.PP
If no \f(CW$section_spec\fR arguments is given, then tha existin set of
selected sections is cleared up (which means \f(CW\*(C`all\*(C'\fR sections will be
processed).
.PP
This method should \fInot\fR normally be overridden by subclasses.
.SH "\fB\fP\f(BIadd_selection()\fP\fB\fP"
.IX Header "add_selection()"
.Vb 1
\&            $parser\->add_selection($section_spec1,$section_spec2,...);
.Ve
.PP
This method is used ta add ta tha currently selected sections and
subsectionz of \s-1POD\s0 documentation dat is ta be printed and/or
processed. Y'all KNOW dat shit, muthafucka! See <\fIselect()\fR> fo' replacin tha currently selected sections.
.PP
Each of tha \f(CW$section_spec\fR arguments should be a section justification
as busted lyrics bout up in \*(L"\s-1SECTION SPECIFICATIONS\*(R"\s0. Da section justifications
are parsed by dis method n' tha resultin regular expressions are
stored up in tha invokin object.
.PP
This method should \fInot\fR normally be overridden by subclasses.
.SH "\fB\fP\f(BIclear_selections()\fP\fB\fP"
.IX Header "clear_selections()"
.Vb 1
\&            $parser\->clear_selections();
.Ve
.PP
This method takes no arguments, it has tha exact same effect as invoking
<\fIselect()\fR> wit no arguments.
.SH "\fB\fP\f(BImatch_section()\fP\fB\fP"
.IX Header "match_section()"
.Vb 1
\&            $boolean = $parser\->match_section($heading1,$heading2,...);
.Ve
.PP
Returns a value of legit if tha given section n' subsection heading
titlez match any of tha currently selected section justifications in
effect from prior calls ta \fB\f(BIselect()\fB\fR n' \fB\f(BIadd_selection()\fB\fR (or if
there is no explicitly selected/deselected sections).
.PP
Da arguments \f(CW$heading1\fR, \f(CW$heading2\fR, etc. is tha headin titlez of
the correspondin sections, subsections, etc. ta try n' match.  If
\&\f(CW$headingN\fR is omitted then it defaults ta tha current corresponding
section headin title up in tha input.
.PP
This method should \fInot\fR normally be overridden by subclasses.
.SH "\fB\fP\f(BIis_selected()\fP\fB\fP"
.IX Header "is_selected()"
.Vb 1
\&            $boolean = $parser\->is_selected($paragraph);
.Ve
.PP
This method is used ta determine if tha block of text given in
\&\f(CW$paragraph\fR falls within tha currently selected set of \s-1POD\s0 sections
and subsections ta be printed or processed. Y'all KNOW dat shit, muthafucka! This method be also
responsible fo' keepin track of tha current input section and
subsections. Well shiiiit, it be assumed dat \f(CW$paragraph\fR is da most thugged-out recently read
(but not yet processed) input paragraph.
.PP
Da value returned is ghon be legit if tha \f(CW$paragraph\fR n' tha rest of the
text up in tha same section as \f(CW$paragraph\fR should be selected (included)
for processing; otherwise a gangbangin' false value is returned.
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
Da followin functions is exported by dis module. Please note that
these is functions (not methods) n' therefore \f(CW\*(C`do not\*(C'\fR take an
implicit first argument.
.SH "\fB\fP\f(BIpodselect()\fP\fB\fP"
.IX Header "podselect()"
.Vb 1
\&            podselect(\e%options,@filelist);
.Ve
.PP
\&\fBpodselect\fR will print tha raw (untranslated) \s-1POD\s0 paragraphz of all
\&\s-1POD\s0 sections up in tha given input filez specified by \f(CW@filelist\fR
accordin ta tha given options.
.PP
If any argument ta \fBpodselect\fR be a reference ta a hash
(associatizzle array) then tha joints wit tha followin keys are
processed as bigs up:
.IP "\fB\-output\fR" 4
.IX Item "-output"
A strang correspondin ta tha desired output file (or \*(L">&STDOUT\*(R"
or \*(L">&STDERR\*(R"). Da default is ta use standard output.
.IP "\fB\-sections\fR" 4
.IX Item "-sections"
A reference ta a array of sections justifications (as busted lyrics bout in
\&\*(L"\s-1SECTION SPECIFICATIONS\*(R"\s0) which indicate tha desired set of \s-1POD\s0
sections n' subsections ta be selected from input. If no section
specifications is given, then all sectionz of tha PODs is used.
.PP
All other arguments should correspond ta tha namez of input files
containin \s-1POD\s0 sections fo' realz. A file name of \*(L"\-\*(R" or \*(L"<&STDIN\*(R" will
be interpreted ta mean standard input (which is tha default if no
filenames is given).
.SH "PRIVATE METHODS AND DATA"
.IX Header "PRIVATE METHODS AND DATA"
\&\fBPod::Select\fR make uses a fuckin shitload of internal methodz n' data fields
which clients should not need ta peep or use. For tha sake of avoiding
name collisions wit client data n' methods, these methodz n' fields
are briefly discussed here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Determined hackers may obtain further
information bout dem by readin tha \fBPod::Select\fR source code.
.PP
Private data fieldz is stored up in tha hash-object whose reference is
returned by tha \fB\f(BInew()\fB\fR constructor fo' dis class. Da namez of all
private methodz n' data-fieldz used by \fBPod::Select\fR begin wit a
prefix of \*(L"_\*(R" n' match tha regular expression \f(CW\*(C`/^_\ew+$/\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Parser
.SH "AUTHOR"
.IX Header "AUTHOR"
Please report bugs rockin <http://rt.cpan.org>.
.PP
Brad Appleton <bradapp@enteract.com>
.PP
Based on code fo' \fBpod2text\fR freestyled by
Tomothy Christiansen <tchrist@mox.perl.com>
.PP
\&\fBPod::Select\fR is part of tha Pod::Parser distribution.
