.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ReadKey 3"
.TH ReadKey 3 "2005-01-11" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ReadKey \- A perl module fo' simple terminal control
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&        use Term::ReadKey;
\&        ReadMode 4; # Turn off controls keys
\&        while (not defined ($key = ReadKey(\-1))) {
\&                # No key yet
\&        }
\&        print "Git key $key\en";
\&        ReadMode 0; # Reset tty mode before exiting
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Term::ReadKey be a cold-ass lil compiled perl module all bout providin simple
control over terminal driver modes (cbreak, raw, cooked, etc.,) support for
non-blockin reads, if tha architecture allows, n' some generalized handy
functions fo' hustlin wit terminals. One of tha main goals is ta have the
functions as portable as possible, so you can just plug up in \*(L"use
Term::ReadKey\*(R" on any architecture n' gotz a phat likelyhood of it working.
.IP "ReadMode \s-1MODE\s0 [, Filehandle]" 8
.IX Item "ReadMode MODE [, Filehandle]"
Takes a integer argument, which can currently be one of tha followin 
values:
.Sp
.Vb 8
\&    0    Restore original gangsta settings.
\&    1    Chizzle ta cooked mode.
\&    2    Chizzle ta cooked mode wit echo off. 
\&          (Dope fo' passwords)
\&    3    Chizzle ta cbreak mode.
\&    4    Chizzle ta raw mode.
\&    5    Chizzle ta ultra\-raw mode. 
\&          (LF ta CR/LF translation turned off) 
\&          
\&    Or, you may use tha synonyms:
\&    
\&    restore
\&    normal
\&    noecho
\&    cbreak
\&    raw
\&    ultra\-raw
.Ve
.Sp
These functions is automatically applied ta tha \s-1STDIN\s0 handle if no
other handle is supplied. Y'all KNOW dat shit, muthafucka! Modes 0 n' 5 have some special properties
worth mentioning: not only will mode 0 restore original gangsta settings yo, but it
cause tha next ReadMode call ta save a freshly smoked up set of default settings. Mode
5 is similar ta mode 4, except no \s-1CR/LF\s0 translation is performed, n' if
possible, paritizzle is ghon be disabled (only if not bein used by tha terminal,
however n' shit. Well shiiiit, it is no different from mode 4 under Windows.)
.Sp
If yo ass is executin another program dat may be changin tha terminal mode,
you will either wanna say
.Sp
.Vb 3
\&    ReadMode 1
\&    system(\*(Aqsomeprogram\*(Aq);
\&    ReadMode 1;
.Ve
.Sp
which resets tha settings afta tha program has run, or:
.Sp
.Vb 4
\&    $somemode=1;
\&    ReadMode 0;
\&    system(\*(Aqsomeprogram\*(Aq);
\&    ReadMode 1;
.Ve
.Sp
which recordz any chizzlez tha program may have made, before resettin the
mode.
.IP "ReadKey \s-1MODE\s0 [, Filehandle]" 8
.IX Item "ReadKey MODE [, Filehandle]"
Takes a integer argument, which can currently be one of tha followin 
values:
.Sp
.Vb 3
\&    0    Perform a aiiight read rockin getc
\&    \-1   Perform a non\-blocked read
\&    >0   Perform a timed read
.Ve
.Sp
(If tha filehandle aint supplied, it will default ta \s-1STDIN.\s0) If there is
nothang waitin up in tha buffer durin a non-blocked read, then undef will be
returned. Y'all KNOW dat shit, muthafucka! Note dat if tha \s-1OS\s0 do not provide any known mechanizzle for
non-blockin reads, then a \f(CW\*(C`ReadKey \-1\*(C'\fR can take a thugged-out dirtnap wit a gangbangin' fatal error. Shiiit, dis aint no joke. This
will hopefully not be common.
.Sp
If \s-1MODE\s0 is pimped outa then zero, then ReadKey will use it as a timeout value in
secondz (fractionizzle secondz is allowed), n' won't return \f(CW\*(C`undef\*(C'\fR until
that time expires. (Note, again, dat some \s-1OS\s0z may not support dis timeout
behaviour.) If \s-1MODE\s0 is less then zero, then dis is treated as a timeout
of zero, n' thus will return immediately if no characta is waitin fo' realz. A \s-1MODE\s0
of zero, however, will act like a aiiight getc.
.Sp
There is currently some limitations wit dis call under Windows. Well shiiiit, it may be
possible dat non-blockin readz will fail when readin repeatin keys from
more then one console.
.IP "ReadLine \s-1MODE\s0 [, Filehandle]" 8
.IX Item "ReadLine MODE [, Filehandle]"
Takes a integer argument, which can currently be one of tha followin 
values:
.Sp
.Vb 3
\&    0    Perform a aiiight read rockin scalar(<FileHandle>)
\&    \-1   Perform a non\-blocked read
\&    >0   Perform a timed read
.Ve
.Sp
If there is not a god damn thang waitin up in tha buffer durin a non-blocked read, then
undef is ghon be returned. Y'all KNOW dat shit, muthafucka! Note dat if tha \s-1OS\s0 do not provide any known
mechanizzle fo' non-blockin reads, then a \f(CW\*(C`ReadLine 1\*(C'\fR can take a thugged-out dirtnap wit a gangbangin' fatal
error. Shiiit, dis aint no joke. This will hopefully not be common. I aint talkin' bout chicken n' gravy biatch. Note dat a non-blockin test is
only performed fo' tha straight-up original gangsta characta up in tha line, not tha entire line.
This call will probably \fBnot\fR do what tha fuck you assume, especially with
ReadModez higher then 1. For example, pressin Space n' then Backspace
would step tha fuck up ta leave you where you started yo, but any timeouts would now
be suspended.
.Sp
This call is currently not available under Windows.
.IP "GetTerminalSize [Filehandle]" 8
.IX Item "GetTerminalSize [Filehandle]"
Returns either a empty array if dis operation is unsupported, or a gangbangin' four
element array containing: tha width of tha terminal up in characters, the
height of tha terminal up in character, tha width up in pixels, n' tha height in
pixels. (Da pixel size will only be valid up in some environments.)
.Sp
Under Windows, dis function must be called wit a \*(L"output\*(R" filehandle,
like fuckin \s-1STDOUT,\s0 or a handle opened ta \s-1CONOUT$.\s0
.IP "SetTerminalSize \s-1WIDTH,HEIGHT,XPIX,YPIX\s0 [, Filehandle]" 8
.IX Item "SetTerminalSize WIDTH,HEIGHT,XPIX,YPIX [, Filehandle]"
Return \-1 on failure, 0 otherwise. Note dat dis terminal size is only for
\&\fBinformative\fR value, n' changin tha size via dis mechanizzle will \fBnot\fR
change tha size of tha screen. I aint talkin' bout chicken n' gravy biatch. For example, XTerm uses a cold-ass lil call like dis when
it resizes tha screen. I aint talkin' bout chicken n' gravy biatch. If any of tha freshly smoked up measurements vary from tha old, the
\&\s-1OS\s0 will probably bust a \s-1SIGWINCH\s0 signal ta anythang readin dat tty or pty.
.Sp
This call do not work under Windows.
.IP "GetSpeedz [, Filehandle]" 8
.IX Item "GetSpeedz [, Filehandle]"
Returns either a empty array if tha operation is unsupported, or a two
value array containin tha terminal up in n' up speeds, up in \fBdecimal\fR. E.g,
an up in speed of 9600 baud n' a up speed of 4800 baud would be returned as
(9600,4800). Note dat currently tha up in n' up speedz will always be
identical up in some \s-1OS\s0's. No speedz is reported under Windows.
.IP "GetControlChars [, Filehandle]" 8
.IX Item "GetControlChars [, Filehandle]"
Returns a array containin key/value pairs suitable fo' a hash. Da pairs
consist of a key, tha name of tha control character/signal, n' tha value
of dat character, as a single character n' shit. This call do not a god damn thang under Windows.
.Sp
Each key is ghon be a entry from tha followin list:
.Sp
.Vb 10
\&        DISCARD
\&        DSUSPEND
\&        EOF
\&        EOL
\&        EOL2
\&        ERASE
\&        ERASEWORD
\&        INTERRUPT
\&        KILL
\&        MIN
\&        QUIT
\&        QUOTENEXT
\&        REPRINT
\&        START
\&        STATUS
\&        STOP
\&        SUSPEND
\&        SWITCH
\&        TIME
.Ve
.Sp
Thus, tha followin will always return tha current interrupt character,
regardless of platform.
.Sp
.Vb 2
\&        %keys = GetControlChars;
\&        $int = $keys{INTERRUPT};
.Ve
.IP "SetControlChars [, Filehandle]" 8
.IX Item "SetControlChars [, Filehandle]"
Takes a array containin key/value pairs, as a hash will produce. Da pairs
should consist of a key dat is tha name of a legal control
character/signal, n' tha value should be either a single character, or a
number up in tha range 0\-255. Right back up in yo muthafuckin ass. SetControlChars will take a thugged-out dirtnap wit a runtime error if
an invalid characta name is passed or there be a error changin the
settings. Da list of valid names is easily available via
.Sp
.Vb 2
\&        %cchars = GetControlChars();
\&        @cnames = keys %cchars;
.Ve
.Sp
This call do not a god damn thang under Windows.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kenneth Albanowski <kjahds@kjahds.com>
.PP
Currently maintained by Jonathan Stowe <jns@gellyfish.com>
