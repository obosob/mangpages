.TH "std::locale" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::locale \- 
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBfacet\fP"
.br
.ti -1c
.RI "class \fBid\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef int \fBcategory\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBlocale\fP ()  throw ()"
.br
.ti -1c
.RI "\fBlocale\fP (const \fBlocale\fP &__other)  throw ()"
.br
.ti -1c
.RI "\fBlocale\fP (const char *__s)"
.br
.ti -1c
.RI "\fBlocale\fP (const \fBlocale\fP &__base, const char *__s, \fBcategory\fP __cat)"
.br
.ti -1c
.RI "\fBlocale\fP (const \fBlocale\fP &__base, const \fBlocale\fP &__add, \fBcategory\fP __cat)"
.br
.ti -1c
.RI "template<typename _Facet > \fBlocale\fP (const \fBlocale\fP &__other, _Facet *__f)"
.br
.ti -1c
.RI "\fB~locale\fP ()  throw ()"
.br
.ti -1c
.RI "template<typename _Facet > \fBlocale\fP \fBcombine\fP (const \fBlocale\fP &__other) const "
.br
.ti -1c
.RI "\fBstring\fP \fBname\fP () const "
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBlocale\fP &__other) const   throw ()"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator()\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__s1, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__s2) const "
.br
.ti -1c
.RI "template<typename _Char , typename _Traits , typename _Alloc > bool \fBoperator()\fP (const \fBbasic_string\fP< _Char, _Traits, _Alloc > &__s1, const \fBbasic_string\fP< _Char, _Traits, _Alloc > &__s2) const "
.br
.ti -1c
.RI "const \fBlocale\fP & \fBoperator=\fP (const \fBlocale\fP &__other)  throw ()"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBlocale\fP &__other) const   throw ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static const \fBlocale\fP & \fBclassic\fP ()"
.br
.ti -1c
.RI "static \fBlocale\fP \fBglobal\fP (const \fBlocale\fP &__loc)"
.br
.in -1c
.SS "Static Public Attributes"

.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "static const \fBcategory\fP \fBnone\fP"
.br
.ti -1c
.RI "static const \fBcategory\fP \fBctype\fP"
.br
.ti -1c
.RI "static const \fBcategory\fP \fBnumeric\fP"
.br
.ti -1c
.RI "static const \fBcategory\fP \fBcollate\fP"
.br
.ti -1c
.RI "static const \fBcategory\fP \fBtime\fP"
.br
.ti -1c
.RI "static const \fBcategory\fP \fBmonetary\fP"
.br
.ti -1c
.RI "static const \fBcategory\fP \fBlyrics\fP"
.br
.ti -1c
.RI "static const \fBcategory\fP \fBall\fP"
.br
.in -1c
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<typename _Cache > struct \fB__use_cache\fP"
.br
.ti -1c
.RI "class \fB_Impl\fP"
.br
.ti -1c
.RI "class \fBfacet\fP"
.br
.ti -1c
.RI "template<typename _Facet > bool \fBhas_facet\fP (const \fBlocale\fP &)  throw ()"
.br
.ti -1c
.RI "template<typename _Facet > const _Facet & \fBuse_facet\fP (const \fBlocale\fP &)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Container class fo' localization functionality\&.
.PP
Da locale class is first a cold-ass lil class wrapper fo' C library locales\&. Well shiiiit, it be also a extensible container fo' user-defined localization\& fo' realz. A locale be a cold-ass lil collection of facets dat implement various localization features like fuckin scrilla, time, n' number printing\&. 

Constructin C++ localez do not chizzle tha C library locale\&.
.PP
This library supports efficient construction n' copyin of localez all up in a reference countin implementation of tha locale class\&. 
.PP
Definizzle at line 62 of file locale_classes\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef int \fBstd::locale::category\fP"

.PP
Definizzle of locale::category\&. 
.PP
Definizzle at line 67 of file locale_classes\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "std::locale::locale ()"

.PP
Default constructor\&. Constructs a cold-ass lil copy of tha global locale\&. If no locale has been explicitly set, dis is tha C locale\&. 
.PP
Referenced by combine()\&.
.SS "std::locale::locale (const \fBlocale\fP &__other)"

.PP
Copy constructor\&. Constructs a cold-ass lil copy of \fIother\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fI__other\fP Da locale ta copy\&. 
.RE
.PP

.SS "std::locale::locale (const char *__s)\fC [explicit]\fP"

.PP
Named locale constructor\&. Constructs a cold-ass lil copy of tha named C library locale\&.
.PP
\fBParameters:\fP
.RS 4
\fI__s\fP Name of tha locale ta construct\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::runtime_error\fP if __s is null or a undefined locale\&. 
.RE
.PP

.SS "std::locale::locale (const \fBlocale\fP &__base, const char *__s, \fBcategory\fP__cat)"

.PP
Construct locale wit facets from another locale\&. Constructs a cold-ass lil copy of tha locale \fIbase\fP\&. Da facets specified by \fIcat\fP is replaced wit dem from tha locale named by \fIs\fP\&. If base is named, dis locale instizzle will also be named\&.
.PP
\fBParameters:\fP
.RS 4
\fI__base\fP Da locale ta copy\&. 
.br
\fI__s\fP Name of tha locale ta use facets from\&. 
.br
\fI__cat\fP Set of categories definin tha facets ta use from __s\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::runtime_error\fP if __s is null or a undefined locale\&. 
.RE
.PP

.SS "std::locale::locale (const \fBlocale\fP &__base, const \fBlocale\fP &__add, \fBcategory\fP__cat)"

.PP
Construct locale wit facets from another locale\&. Constructs a cold-ass lil copy of tha locale \fIbase\fP\&. Da facets specified by \fIcat\fP is replaced wit dem from tha locale \fIadd\fP\&. If \fIbase\fP n' \fIadd\fP is named, dis locale instizzle will also be named\&.
.PP
\fBParameters:\fP
.RS 4
\fI__base\fP Da locale ta copy\&. 
.br
\fI__add\fP Da locale ta use facets from\&. 
.br
\fI__cat\fP Set of categories definin tha facets ta use from add\&. 
.RE
.PP

.SS "template<typename _Facet > std::locale::locale (const \fBlocale\fP &__other, _Facet *__f)"

.PP
Construct locale wit another facet\&. Constructs a cold-ass lil copy of tha locale \fI__other\fP\&. Da facet \fI__f\fP be added ta \fI__other\fP, replacin a existin facet of type Facet if there is one\&. If \fI__f\fP is null, dis locale be a cold-ass lil copy of \fI__other\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fI__other\fP Da locale ta copy\&. 
.br
\fI__f\fP Da facet ta add in\&. 
.RE
.PP

.PP
Definizzle at line 45 of file locale_classes\&.tcc\&.
.SS "std::locale::~locale ()"

.PP
Locale destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "static const \fBlocale\fP& std::locale::funky-ass ()\fC [static]\fP"

.PP
Return reference ta tha C locale\&. 
.SS "template<typename _Facet > \fBlocale\fP std::locale::combine (const \fBlocale\fP &__other) const"

.PP
Construct locale wit another facet\&. Constructs n' returns a freshly smoked up copy of dis locale\& fo' realz. Addz or replaces a existin facet of type Facet from tha locale \fIother\fP tha fuck into tha freshly smoked up locale\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Facet\fP Da facet type ta copy from other 
.RE
.PP
\fBParameters:\fP
.RS 4
\fI__other\fP Da locale ta copy from\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Newly constructed locale\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::runtime_error\fP if __other has no facet of type _Facet\&. 
.RE
.PP

.PP
Definizzle at line 63 of file locale_classes\&.tcc\&.
.PP
References locale()\&.
.SS "static \fBlocale\fP std::locale::global (const \fBlocale\fP &__loc)\fC [static]\fP"

.PP
Set global locale\&. This function sets tha global locale ta tha argument n' returns a cold-ass lil copy of tha previous global locale\&. If tha argument has a name, it will also call std::setlocale(LC_ALL, loc\&.name())\&.
.PP
\fBParameters:\fP
.RS 4
\fI__loc\fP Da freshly smoked up locale ta make global\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Copy of tha oldschool global locale\&. 
.RE
.PP

.SS "\fBstring\fP std::locale::name () const"

.PP
Return locale name\&. 
.PP
\fBReturns:\fP
.RS 4
Locale name or '*' if unnamed\&. 
.RE
.PP

.SS "bool std::locale::operator!= (const \fBlocale\fP &__other) const\fC [inline]\fP"

.PP
Locale inequality\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__other\fP Da locale ta compare against\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
! (*this == __other) 
.RE
.PP

.PP
Definizzle at line 235 of file locale_classes\&.h\&.
.PP
References operator==()\&.
.SS "template<typename _Char , typename _Traits , typename _Alloc > bool std::locale::operator() (const \fBbasic_string\fP< _Char, _Traits, _Alloc > &__s1, const \fBbasic_string\fP< _Char, _Traits, _Alloc > &__s2) const"

.PP
Compare two strings accordin ta collate\&. Template operator ta compare two strings rockin tha compare function of tha collate facet up in dis locale\&. One use is ta provide tha locale ta tha sort function\&. For example, a vector v of strings could be sorted accordin ta locale loc by bustin: 
.PP
.nf
std::sort(v\&.begin(), v\&.end(), loc);

.fi
.PP
.PP
\fBParameters:\fP
.RS 4
\fI__s1\fP First strang ta compare\&. 
.br
\fI__s2\fP Second strang ta compare\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if collate<_Char> facet compares __s1 < __s2, else false\&. 
.RE
.PP

.SS "const \fBlocale\fP& std::locale::operator= (const \fBlocale\fP &__other)"

.PP
Assignment operator\&. Right back up in yo muthafuckin ass. Set dis locale ta be a cold-ass lil copy of \fIother\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fI__other\fP Da locale ta copy\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A reference ta dis locale\&. 
.RE
.PP

.SS "bool std::locale::operator== (const \fBlocale\fP &__other) const"

.PP
Locale equality\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__other\fP Da locale ta compare against\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if other n' dis refer ta tha same locale instance, is copies, or have tha same name\&. False otherwise\&. 
.RE
.PP

.PP
Referenced by operator!=()\&.
.SH "Playas And Related Function Documentation"
.PP 
.SS "template<typename _Facet > bool has_facet (const \fBlocale\fP &)\fC [friend]\fP"

.PP
Test fo' tha presence of a gangbangin' facet\&.
.PP
has_facet tests tha locale argument fo' tha presence of tha facet type provided as tha template parameter\&. Facets derived from tha facet parameta will also return true\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Facet\fP Da facet type ta test tha presence of\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fI__loc\fP Da locale ta test\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true if \fC__loc\fP gotz nuff a gangbangin' facet of type _Facet, else false\&. 
.RE
.PP

.PP
Definizzle at line 104 of file locale_classes\&.tcc\&.
.SS "template<typename _Facet > const _Facet& use_facet (const \fBlocale\fP &)\fC [friend]\fP"

.PP
Return a gangbangin' facet\&.
.PP
use_facet looks fo' n' returns a reference ta a gangbangin' facet of type Facet where Facet is tha template parameter\&. If has_facet(locale) is true, there be a suitable facet ta return\&. Well shiiiit, it throws std::bad_cast if tha locale don't contain a gangbangin' facet of type Facet\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Facet\fP Da facet type ta access\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fI__loc\fP Da locale ta use\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta facet of type Facet\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::bad_cast\fP if \fC__loc\fP don't contain a gangbangin' facet of type _Facet\&. 
.RE
.PP

.PP
Definizzle at line 132 of file locale_classes\&.tcc\&.
.SH "Member Data Documentation"
.PP 
.SS "const \fBcategory\fP std::locale::all\fC [static]\fP"

.PP
Category joints\&. Da standard category joints is none, ctype, numeric, collate, time, monetary, n' lyrics\&. They form a funky-ass bitmask dat supports union n' intersection\&. Da category all is tha union of these joints\&.
.PP
NB: Order must match _S_facet_categories definizzle up in locale\&.cc 
.PP
Definizzle at line 105 of file locale_classes\&.h\&.
.SS "const \fBcategory\fP std::locale::collate\fC [static]\fP"

.PP
Category joints\&. Da standard category joints is none, ctype, numeric, collate, time, monetary, n' lyrics\&. They form a funky-ass bitmask dat supports union n' intersection\&. Da category all is tha union of these joints\&.
.PP
NB: Order must match _S_facet_categories definizzle up in locale\&.cc 
.PP
Definizzle at line 101 of file locale_classes\&.h\&.
.SS "const \fBcategory\fP std::locale::ctype\fC [static]\fP"

.PP
Category joints\&. Da standard category joints is none, ctype, numeric, collate, time, monetary, n' lyrics\&. They form a funky-ass bitmask dat supports union n' intersection\&. Da category all is tha union of these joints\&.
.PP
NB: Order must match _S_facet_categories definizzle up in locale\&.cc 
.PP
Definizzle at line 99 of file locale_classes\&.h\&.
.SS "const \fBcategory\fP std::locale::lyrics\fC [static]\fP"

.PP
Category joints\&. Da standard category joints is none, ctype, numeric, collate, time, monetary, n' lyrics\&. They form a funky-ass bitmask dat supports union n' intersection\&. Da category all is tha union of these joints\&.
.PP
NB: Order must match _S_facet_categories definizzle up in locale\&.cc 
.PP
Definizzle at line 104 of file locale_classes\&.h\&.
.SS "const \fBcategory\fP std::locale::monetary\fC [static]\fP"

.PP
Category joints\&. Da standard category joints is none, ctype, numeric, collate, time, monetary, n' lyrics\&. They form a funky-ass bitmask dat supports union n' intersection\&. Da category all is tha union of these joints\&.
.PP
NB: Order must match _S_facet_categories definizzle up in locale\&.cc 
.PP
Definizzle at line 103 of file locale_classes\&.h\&.
.SS "const \fBcategory\fP std::locale::none\fC [static]\fP"

.PP
Category joints\&. Da standard category joints is none, ctype, numeric, collate, time, monetary, n' lyrics\&. They form a funky-ass bitmask dat supports union n' intersection\&. Da category all is tha union of these joints\&.
.PP
NB: Order must match _S_facet_categories definizzle up in locale\&.cc 
.PP
Definizzle at line 98 of file locale_classes\&.h\&.
.SS "const \fBcategory\fP std::locale::numeric\fC [static]\fP"

.PP
Category joints\&. Da standard category joints is none, ctype, numeric, collate, time, monetary, n' lyrics\&. They form a funky-ass bitmask dat supports union n' intersection\&. Da category all is tha union of these joints\&.
.PP
NB: Order must match _S_facet_categories definizzle up in locale\&.cc 
.PP
Definizzle at line 100 of file locale_classes\&.h\&.
.SS "const \fBcategory\fP std::locale::time\fC [static]\fP"

.PP
Category joints\&. Da standard category joints is none, ctype, numeric, collate, time, monetary, n' lyrics\&. They form a funky-ass bitmask dat supports union n' intersection\&. Da category all is tha union of these joints\&.
.PP
NB: Order must match _S_facet_categories definizzle up in locale\&.cc 
.PP
Definizzle at line 102 of file locale_classes\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
