" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_debug::basic_string< _CharT, _Traits, _Allocator > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBstd::basic_string< _CharT, _Traits, _Allocator >\fP, n' \fB__gnu_debug::_Safe_sequence< basic_string< _CharT, _Traits, _Allocator > >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Allocator \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef 
.br
\fB__gnu_debug::_Safe_iterator\fP
.br
< typename 
.br
_Base::const_iterator, 
.br
\fBbasic_string\fP > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef _Base::const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef _Base::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< \fBconst_iterator\fP > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef _Base::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef 
.br
\fB__gnu_debug::_Safe_iterator\fP
.br
< typename _Base::iterator, 
.br
\fBbasic_string\fP > \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Base::pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Base::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< \fBiterator\fP > \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef _Base::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Traits \fBtraits_type\fP"
.br
.ti -1c
.RI "typedef _Traits::char_type \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBbasic_string\fP (const _Allocator &__a=_Allocator())"
.br
.ti -1c
.RI "\fBbasic_string\fP (const \fB_Base\fP &\fB__base\fP)"
.br
.ti -1c
.RI "\fBbasic_string\fP (const \fBbasic_string\fP &__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP (const \fBbasic_string\fP &__str, size_type __pos, size_type __n=\fB_Base::npos\fP, const _Allocator &__a=_Allocator())"
.br
.ti -1c
.RI "\fBbasic_string\fP (const _CharT *__s, size_type __n, const _Allocator &__a=_Allocator())"
.br
.ti -1c
.RI "\fBbasic_string\fP (const _CharT *__s, const _Allocator &__a=_Allocator())"
.br
.ti -1c
.RI "\fBbasic_string\fP (size_type __n, _CharT __c, const _Allocator &__a=_Allocator())"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBbasic_string\fP (_InputIterator __begin, _InputIterator __end, const _Allocator &__a=_Allocator())"
.br
.ti -1c
.RI "\fBbasic_string\fP (\fBbasic_string\fP &&__str) noexcept"
.br
.ti -1c
.RI "\fBbasic_string\fP (\fBstd::initializer_list\fP< _CharT > __l, const _Allocator &__a=_Allocator())"
.br
.ti -1c
.RI "void \fB_M_attach\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)  throw ()"
.br
.ti -1c
.RI "\fB_Base\fP & \fB_M_base\fP () noexcept"
.br
.ti -1c
.RI "const \fB_Base\fP & \fB_M_base\fP () const noexcept"
.br
.ti -1c
.RI "void \fB_M_detach\fP (\fB_Safe_iterator_base\fP *__it)"
.br
.ti -1c
.RI "void \fB_M_detach_single\fP (\fB_Safe_iterator_base\fP *__it)  throw ()"
.br
.ti -1c
.RI "void \fB_M_invalidate_all\fP () const "
.br
.ti -1c
.RI "void \fB_M_invalidate_if\fP (_Predicate __pred)"
.br
.ti -1c
.RI "void \fB_M_transfer_from_if\fP (\fB_Safe_sequence\fP &__from, _Predicate __pred)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBappend\fP (const \fBbasic_string\fP &__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBappend\fP (const \fBbasic_string\fP &__str, size_type __pos, size_type __n)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBappend\fP (const _CharT *__s, size_type __n)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBappend\fP (const _CharT *__s)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBappend\fP (size_type __n, _CharT __c)"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBbasic_string\fP & \fBappend\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBappend\fP (const \fBbasic_string\fP &__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBappend\fP (const \fBbasic_string\fP &__str, size_type __pos, size_type __n)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBappend\fP (initializer_list< _CharT > __l)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBassign\fP (const \fBbasic_string\fP &__x)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBassign\fP (\fBbasic_string\fP &&__x)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBassign\fP (const \fBbasic_string\fP &__str, size_type __pos, size_type __n)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBassign\fP (const _CharT *__s, size_type __n)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBassign\fP (const _CharT *__s)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBassign\fP (size_type __n, _CharT __c)"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBbasic_string\fP & \fBassign\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBassign\fP (\fBstd::initializer_list\fP< _CharT > __l)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBassign\fP (const \fBbasic_string\fP &__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBassign\fP (\fBbasic_string\fP &&__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBassign\fP (const \fBbasic_string\fP &__str, size_type __pos, size_type __n)"
.br
.ti -1c
.RI "const_reference \fBat\fP (size_type __n) const"
.br
.ti -1c
.RI "reference \fBat\fP (size_type __n)"
.br
.ti -1c
.RI "reference \fBback\fP ()"
.br
.ti -1c
.RI "const_reference \fBback\fP () const"
.br
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "const _CharT * \fBc_str\fP () const noexcept"
.br
.ti -1c
.RI "size_type \fBcapacity\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "int \fBcompare\fP (const \fBbasic_string\fP &__str) const "
.br
.ti -1c
.RI "int \fBcompare\fP (size_type __pos1, size_type __n1, const \fBbasic_string\fP &__str) const "
.br
.ti -1c
.RI "int \fBcompare\fP (size_type __pos1, size_type __n1, const \fBbasic_string\fP &__str, size_type __pos2, size_type __n2) const "
.br
.ti -1c
.RI "int \fBcompare\fP (const _CharT *__s) const "
.br
.ti -1c
.RI "int \fBcompare\fP (size_type __pos1, size_type __n1, const _CharT *__s) const "
.br
.ti -1c
.RI "int \fBcompare\fP (size_type __pos1, size_type __n1, const _CharT *__s, size_type __n2) const "
.br
.ti -1c
.RI "int \fBcompare\fP (const \fBbasic_string\fP &__str) const"
.br
.ti -1c
.RI "int \fBcompare\fP (size_type __pos, size_type __n, const \fBbasic_string\fP &__str) const"
.br
.ti -1c
.RI "int \fBcompare\fP (size_type __pos1, size_type __n1, const \fBbasic_string\fP &__str, size_type __pos2, size_type __n2) const"
.br
.ti -1c
.RI "size_type \fBcopy\fP (_CharT *__s, size_type __n, size_type __pos=0) const "
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const noexcept"
.br
.ti -1c
.RI "const _CharT * \fBdata\fP () const noexcept"
.br
.ti -1c
.RI "bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const noexcept"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBerase\fP (size_type __pos=0, size_type __n=\fB_Base::npos\fP)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __position)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __first, \fBiterator\fP __last)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __position)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __first, \fBiterator\fP __last)"
.br
.ti -1c
.RI "size_type \fBfind\fP (const \fBbasic_string\fP &__str, size_type __pos=0) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind\fP (const _CharT *__s, size_type __pos, size_type __n) const "
.br
.ti -1c
.RI "size_type \fBfind\fP (const _CharT *__s, size_type __pos=0) const "
.br
.ti -1c
.RI "size_type \fBfind\fP (_CharT __c, size_type __pos=0) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind\fP (const \fBbasic_string\fP &__str, size_type __pos=0) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind_first_not_of\fP (const \fBbasic_string\fP &__str, size_type __pos=0) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind_first_not_of\fP (const _CharT *__s, size_type __pos, size_type __n) const "
.br
.ti -1c
.RI "size_type \fBfind_first_not_of\fP (const _CharT *__s, size_type __pos=0) const "
.br
.ti -1c
.RI "size_type \fBfind_first_not_of\fP (_CharT __c, size_type __pos=0) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind_first_not_of\fP (const \fBbasic_string\fP &__str, size_type __pos=0) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind_first_of\fP (const \fBbasic_string\fP &__str, size_type __pos=0) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind_first_of\fP (const _CharT *__s, size_type __pos, size_type __n) const "
.br
.ti -1c
.RI "size_type \fBfind_first_of\fP (const _CharT *__s, size_type __pos=0) const "
.br
.ti -1c
.RI "size_type \fBfind_first_of\fP (_CharT __c, size_type __pos=0) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind_first_of\fP (const \fBbasic_string\fP &__str, size_type __pos=0) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind_last_not_of\fP (const \fBbasic_string\fP &__str, size_type __pos=\fB_Base::npos\fP) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind_last_not_of\fP (const _CharT *__s, size_type __pos, size_type __n) const "
.br
.ti -1c
.RI "size_type \fBfind_last_not_of\fP (const _CharT *__s, size_type __pos=\fB_Base::npos\fP) const "
.br
.ti -1c
.RI "size_type \fBfind_last_not_of\fP (_CharT __c, size_type __pos=\fB_Base::npos\fP) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind_last_not_of\fP (const \fBbasic_string\fP &__str, size_type __pos=\fBnpos\fP) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind_last_of\fP (const \fBbasic_string\fP &__str, size_type __pos=\fB_Base::npos\fP) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind_last_of\fP (const _CharT *__s, size_type __pos, size_type __n) const "
.br
.ti -1c
.RI "size_type \fBfind_last_of\fP (const _CharT *__s, size_type __pos=\fB_Base::npos\fP) const "
.br
.ti -1c
.RI "size_type \fBfind_last_of\fP (_CharT __c, size_type __pos=\fB_Base::npos\fP) const noexcept"
.br
.ti -1c
.RI "size_type \fBfind_last_of\fP (const \fBbasic_string\fP &__str, size_type __pos=\fBnpos\fP) const noexcept"
.br
.ti -1c
.RI "reference \fBfront\fP ()"
.br
.ti -1c
.RI "const_reference \fBfront\fP () const"
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const noexcept"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBinsert\fP (size_type __pos1, const \fBbasic_string\fP &__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBinsert\fP (size_type __pos1, const \fBbasic_string\fP &__str, size_type __pos2, size_type __n)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBinsert\fP (size_type __pos, const _CharT *__s, size_type __n)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBinsert\fP (size_type __pos, const _CharT *__s)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBinsert\fP (size_type __pos, size_type __n, _CharT __c)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBiterator\fP __p, _CharT __c)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __p, size_type __n, _CharT __c)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fBinsert\fP (\fBiterator\fP __p, _InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __p, \fBstd::initializer_list\fP< _CharT > __l)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __p, size_type __n, _CharT __c)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __p, _InputIterator __beg, _InputIterator __end)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __p, initializer_list< _CharT > __l)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBinsert\fP (size_type __pos1, const \fBbasic_string\fP &__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBinsert\fP (size_type __pos1, const \fBbasic_string\fP &__str, size_type __pos2, size_type __n)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBiterator\fP __p, _CharT __c)"
.br
.ti -1c
.RI "size_type \fBlength\fP () const noexcept"
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const noexcept"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBoperator+=\fP (const \fBbasic_string\fP &__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBoperator+=\fP (const _CharT *__s)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBoperator+=\fP (_CharT __c)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBoperator+=\fP (\fBstd::initializer_list\fP< _CharT > __l)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBoperator+=\fP (const \fBbasic_string\fP &__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBoperator=\fP (const \fBbasic_string\fP &__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBoperator=\fP (const _CharT *__s)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBoperator=\fP (_CharT __c)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBoperator=\fP (\fBbasic_string\fP &&__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBoperator=\fP (\fBstd::initializer_list\fP< _CharT > __l)"
.br
.ti -1c
.RI "const_reference \fBoperator[]\fP (size_type __pos) const "
.br
.ti -1c
.RI "reference \fBoperator[]\fP (size_type __pos)"
.br
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.ti -1c
.RI "void \fBpush_back\fP (_CharT __c)"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const noexcept"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (size_type __pos1, size_type __n1, const \fBbasic_string\fP &__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (size_type __pos1, size_type __n1, const \fBbasic_string\fP &__str, size_type __pos2, size_type __n2)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (size_type __pos, size_type __n1, const _CharT *__s, size_type __n2)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (size_type __pos, size_type __n1, const _CharT *__s)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (size_type __pos, size_type __n1, size_type __n2, _CharT __c)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, const \fBbasic_string\fP &__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, const _CharT *__s, size_type __n)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, const _CharT *__s)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, size_type __n, _CharT __c)"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, _InputIterator __j1, _InputIterator __j2)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, \fBstd::initializer_list\fP< _CharT > __l)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (size_type __pos, size_type __n, const \fBbasic_string\fP &__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (size_type __pos1, size_type __n1, const \fBbasic_string\fP &__str, size_type __pos2, size_type __n2)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, const \fBbasic_string\fP &__str)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, const _CharT *__s, size_type __n)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, const _CharT *__s)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, size_type __n, _CharT __c)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, _InputIterator __k1, _InputIterator __k2)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, _CharT *__k1, _CharT *__k2)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, const _CharT *__k1, const _CharT *__k2)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, \fBiterator\fP __k1, \fBiterator\fP __k2)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, \fBconst_iterator\fP __k1, \fBconst_iterator\fP __k2)"
.br
.ti -1c
.RI "\fBbasic_string\fP & \fBreplace\fP (\fBiterator\fP __i1, \fBiterator\fP __i2, initializer_list< _CharT > __l)"
.br
.ti -1c
.RI "void \fBreserve\fP (size_type __res_arg=0)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __n, _CharT __c)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __n)"
.br
.ti -1c
.RI "size_type \fBrfind\fP (const \fBbasic_string\fP &__str, size_type __pos=\fB_Base::npos\fP) const noexcept"
.br
.ti -1c
.RI "size_type \fBrfind\fP (const _CharT *__s, size_type __pos, size_type __n) const "
.br
.ti -1c
.RI "size_type \fBrfind\fP (const _CharT *__s, size_type __pos=\fB_Base::npos\fP) const "
.br
.ti -1c
.RI "size_type \fBrfind\fP (_CharT __c, size_type __pos=\fB_Base::npos\fP) const noexcept"
.br
.ti -1c
.RI "size_type \fBrfind\fP (const \fBbasic_string\fP &__str, size_type __pos=\fBnpos\fP) const noexcept"
.br
.ti -1c
.RI "void \fBshrink_to_fit\fP ()"
.br
.ti -1c
.RI "size_type \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "\fBbasic_string\fP \fBsubstr\fP (size_type __pos=0, size_type __n=\fB_Base::npos\fP) const "
.br
.ti -1c
.RI "void \fBswap\fP (\fBbasic_string\fP< _CharT, _Traits, _Allocator > &__x)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBbasic_string\fP &__s)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_const_iterators\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_iterators\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const size_type \fBnpos\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_detach_all\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_singular\fP ()"
.br
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()  throw ()"
.br
.ti -1c
.RI "void \fB_M_revalidate_singular\fP ()"
.br
.ti -1c
.RI "void \fB_M_swap\fP (\fB_Safe_sequence_base\fP &__x)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _CharT, typename _Traits = std::char_traits<_CharT>, typename _Allocator = std::allocator<_CharT>>class __gnu_debug::basic_string< _CharT, _Traits, _Allocator >"
Class std::basic_strin wit safety/checking/debug instrumentation\&. 
.PP
Definizzle at line 41 of file debug/string\&.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Attach a iterator ta dis sequence\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach_single (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Detach a iterator from dis sequence 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_all ()\fC [protected]\fP, \fC [inherited]\fP"
Detach all iterators, leavin dem singular\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence_base::~_Safe_sequence_base()\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_single (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Detach all singular iterators\&. 
.PP
\fBPostcondition:\fP
.RS 4
for all iterators i attached ta dis sequence, i->_M_version == _M_version\&. 
.RE
.PP

.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_sequence_base::_M_get_mutex ()\fC [protected]\fP, \fC [inherited]\fP"
For use up in _Safe_sequence\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_invalidate_all () const\fC [inline]\fP, \fC [inherited]\fP"
Invalidates all iterators\&. 
.PP
Definizzle at line 233 of file safe_base\&.h\&.
.PP
References __gnu_debug::_Safe_sequence_base::_M_version\&.
.SS "void \fB__gnu_debug::_Safe_sequence\fP< \fBbasic_string\fP< _CharT, _Traits, _Allocator >  >::_M_invalidate_if (_Predicate__pred)\fC [inherited]\fP"
Invalidates all iterators \fCx\fP dat reference dis sequence, is not singular, n' fo' which \fC__pred(x)\fP returns \fCtrue\fP\&. \fC__pred\fP is ghon be invoked wit tha aiiight iterators nested up in tha safe ones\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_revalidate_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Revalidates all attached singular iterators\&. This method may be used ta validate iterators dat was invalidated before (but fo' some reason, like fuckin a exception, need ta become valid again)\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_swap (\fB_Safe_sequence_base\fP &__x)\fC [protected]\fP, \fC [inherited]\fP"
Swap dis sequence wit tha given sequence\&. This operation also swaps ballershizzle of tha iterators, so dat when tha operation is complete all iterators dat originally referenced one container now reference tha other container\&. 
.SS "void \fB__gnu_debug::_Safe_sequence\fP< \fBbasic_string\fP< _CharT, _Traits, _Allocator >  >::_M_transfer_from_if (\fB_Safe_sequence\fP< \fBbasic_string\fP< _CharT, _Traits, _Allocator > > &__from, _Predicate__pred)\fC [inherited]\fP"
Transfers all iterators \fCx\fP dat reference \fCfrom\fP sequence, is not singular, n' fo' which \fC__pred(x)\fP returns \fCtrue\fP\&. \fC__pred\fP is ghon be invoked wit tha aiiight iterators nested up in tha safe ones\&. 
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::append (const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str)\fC [inherited]\fP"

.PP
Append a strang ta dis string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP Da strang ta append\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP

.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::append (const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str, size_type__pos, size_type__n)\fC [inherited]\fP"

.PP
Append a substring\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP Da strang ta append\&. 
.br
\fI__pos\fP Index of tha straight-up original gangsta characta of str ta append\&. 
.br
\fI__n\fP Da number of charactas ta append\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP if \fI__pos\fP aint a valid index\&.
.RE
.PP
This function appendz \fI__n\fP charactas from \fI__str\fP startin at \fI__pos\fP ta dis string\&. If \fI__n\fP is is larger than tha number of available charactas up in \fI__str\fP, tha remainder of \fI__str\fP be appended\&. 
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::append (\fBinitializer_list\fP< _CharT >__l)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Append a initializer_list of characters\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP Da initializer_list of charactas ta append\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP

.PP
Definizzle at line 1030 of file basic_string\&.h\&.
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::assign (const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str)\fC [inherited]\fP"

.PP
Set value ta contentz of another string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP Source strang ta use\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP

.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::assign (\fBbasic_string\fP< _CharT, _Traits, _Allocator > &&__str)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Set value ta contentz of another string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP Source strang ta use\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&.
.RE
.PP
This function sets dis strang ta tha exact contentz of \fI__str\fP\&. \fI__str\fP be a valid yo, but unspecified string\&. 
.PP
Definizzle at line 1079 of file basic_string\&.h\&.
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::assign (const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str, size_type__pos, size_type__n)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Set value ta a substrin of a string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP Da strang ta use\&. 
.br
\fI__pos\fP Index of tha straight-up original gangsta characta of str\&. 
.br
\fI__n\fP Number of charactas ta use\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP if \fIpos\fP aint a valid index\&.
.RE
.PP
This function sets dis strang ta tha substrin of \fI__str\fP consistin of \fI__n\fP charactas at \fI__pos\fP\&. If \fI__n\fP is is larger than tha number of available charactas up in \fI__str\fP, tha remainder of \fI__str\fP is used\&. 
.PP
Definizzle at line 1100 of file basic_string\&.h\&.
.SS "const_reference \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::at (size_type__n) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Provides access ta tha data contained up in tha string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha characta ta access\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (const) reference ta tha character\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fIn\fP be a invalid index\&.
.RE
.PP
This function serves up fo' less thuggy data access\&. Da parameta is first checked dat it is up in tha range of tha string\&. Da function throws out_of_range if tha check fails\&. 
.PP
Definizzle at line 864 of file basic_string\&.h\&.
.SS "reference \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::at (size_type__n)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Provides access ta tha data contained up in tha string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha characta ta access\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read/write reference ta tha character\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fIn\fP be a invalid index\&.
.RE
.PP
This function serves up fo' less thuggy data access\&. Da parameta is first checked dat it is up in tha range of tha string\&. Da function throws out_of_range if tha check fails\&. Right back up in yo muthafuckin ass. Success thangs up in dis biatch up in unsharin tha string\&. 
.PP
Definizzle at line 883 of file basic_string\&.h\&.
.SS "reference \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::back ()\fC [inline]\fP, \fC [inherited]\fP"
Returns a read/write reference ta tha data all up in tha last element of tha string\&. 
.PP
Definizzle at line 913 of file basic_string\&.h\&.
.SS "const_reference \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::back () const\fC [inline]\fP, \fC [inherited]\fP"
Returns a read-only (constant) reference ta tha data all up in tha last element of tha string\&. 
.PP
Definizzle at line 921 of file basic_string\&.h\&.
.SS "size_type \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::capacitizzle () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns tha total number of charactas dat tha strang can hold before needin ta allocate mo' memory\&. 
.PP
Definizzle at line 776 of file basic_string\&.h\&.
.SS "int \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::compare (const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Compare ta a string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP Strin ta compare against\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Integer < 0, 0, or > 0\&.
.RE
.PP
Returns a integer < 0 if dis strang is ordered before \fI__str\fP, 0 if they joints is equivalent, or > 0 if dis strang is ordered afta \fI__str\fP\&. Determines tha effectizzle length rlen of tha strings ta compare as tha smallest of size() n' str\&.size()\&. Da function then compares tha two strings by callin traits::compare(data(), str\&.data(),rlen)\&. If tha result of tha comparison is nonzero returns it, otherwise tha shorta one is ordered first\&. 
.PP
Definizzle at line 2225 of file basic_string\&.h\&.
.SS "int \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::compare (size_type__pos, size_type__n, const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str) const\fC [inherited]\fP"

.PP
Compare substrin ta a string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos\fP Index of first characta of substring\&. 
.br
\fI__n\fP Number of charactas up in substring\&. 
.br
\fI__str\fP Strin ta compare against\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Integer < 0, 0, or > 0\&.
.RE
.PP
Form tha substrin of dis strang from tha \fI__n\fP charactas startin at \fI__pos\fP\&. Returns a integer < 0 if tha substrin is ordered before \fI__str\fP, 0 if they joints is equivalent, or > 0 if tha substrin is ordered afta \fI__str\fP\&. Determines tha effectizzle length rlen of tha strings ta compare as tha smallest of tha length of tha substrin n' \fI__str\&.size()\fP\&. Da function then compares tha two strings by callin traits::compare(substring\&.data(),str\&.data(),rlen)\&. If tha result of tha comparison is nonzero returns it, otherwise tha shorta one is ordered first\&. 
.SS "int \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::compare (size_type__pos1, size_type__n1, const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str, size_type__pos2, size_type__n2) const\fC [inherited]\fP"

.PP
Compare substrin ta a substring\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos1\fP Index of first characta of substring\&. 
.br
\fI__n1\fP Number of charactas up in substring\&. 
.br
\fI__str\fP Strin ta compare against\&. 
.br
\fI__pos2\fP Index of first characta of substrin of str\&. 
.br
\fI__n2\fP Number of charactas up in substrin of str\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Integer < 0, 0, or > 0\&.
.RE
.PP
Form tha substrin of dis strang from tha \fI__n1\fP charactas startin at \fI__pos1\fP\&. Form tha substrin of \fI__str\fP from tha \fI__n2\fP charactas startin at \fI__pos2\fP\&. Returns a integer < 0 if dis substrin is ordered before tha substrin of \fI__str\fP, 0 if they joints is equivalent, or > 0 if dis substrin is ordered afta tha substrin of \fI__str\fP\&. Determines tha effectizzle length rlen of tha strings ta compare as tha smallest of tha lengthz of tha substrings\&. Da function then compares tha two strings by callin traits::compare(substring\&.data(),str\&.substr(pos2,n2)\&.data(),rlen)\&. If tha result of tha comparison is nonzero returns it, otherwise tha shorta one is ordered first\&. 
.SS "bool \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::empty () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns legit if tha strang is empty\&. Equivalent ta \fC*this == ''\fP\&. 
.PP
Definizzle at line 811 of file basic_string\&.h\&.
.SS "\fBiterator\fP \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::erase (iterator__position)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Remove one character\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP Iterator referencin tha characta ta remove\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
iterator referencin same location afta removal\&.
.RE
.PP
Removes tha characta at \fI__position\fP from dis string\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1378 of file basic_string\&.h\&.
.SS "\fBiterator\fP \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::erase (iterator__first, iterator__last)\fC [inherited]\fP"

.PP
Remove a range of characters\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP Iterator referencin tha straight-up original gangsta characta ta remove\&. 
.br
\fI__last\fP Iterator referencin tha end of tha range\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator referencin location of first afta removal\&.
.RE
.PP
Removes tha charactas up in tha range [first,last) from dis string\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.SS "size_type \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::find (const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str, size_type__pos = \fC0\fP) const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Find posizzle of a string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP Strin ta locate\&. 
.br
\fI__pos\fP Index of characta ta search from (default 0)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Index of start of first occurrence\&.
.RE
.PP
Startin from \fI__pos\fP, searches forward fo' value of \fI__str\fP within dis string\&. If found, returns tha index where it begins\&. If not found, returns npos\&. 
.PP
Definizzle at line 1846 of file basic_string\&.h\&.
.SS "size_type \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::find_first_not_of (const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str, size_type__pos = \fC0\fP) const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Find posizzle of a cold-ass lil characta not up in string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP Strin containin charactas ta avoid\&. 
.br
\fI__pos\fP Index of characta ta search from (default 0)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Index of first occurrence\&.
.RE
.PP
Startin from \fI__pos\fP, searches forward fo' a cold-ass lil characta not contained up in \fI__str\fP within dis string\&. If found, returns tha index where dat shiznit was found\&. If not found, returns npos\&. 
.PP
Definizzle at line 2079 of file basic_string\&.h\&.
.SS "size_type \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::find_first_of (const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str, size_type__pos = \fC0\fP) const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Find posizzle of a cold-ass lil characta of string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP Strin containin charactas ta locate\&. 
.br
\fI__pos\fP Index of characta ta search from (default 0)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Index of first occurrence\&.
.RE
.PP
Startin from \fI__pos\fP, searches forward fo' one of tha charactaz of \fI__str\fP within dis string\&. If found, returns tha index where dat shiznit was found\&. If not found, returns npos\&. 
.PP
Definizzle at line 1952 of file basic_string\&.h\&.
.SS "size_type \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::find_last_not_of (const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str, size_type__pos = \fC\fBnpos\fP\fP) const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Find last posizzle of a cold-ass lil characta not up in string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP Strin containin charactas ta avoid\&. 
.br
\fI__pos\fP Index of characta ta search back from (default end)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Index of last occurrence\&.
.RE
.PP
Startin from \fI__pos\fP, searches backward fo' a cold-ass lil characta not contained up in \fI__str\fP within dis string\&. If found, returns tha index where dat shiznit was found\&. If not found, returns npos\&. 
.PP
Definizzle at line 2142 of file basic_string\&.h\&.
.SS "size_type \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::find_last_of (const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str, size_type__pos = \fC\fBnpos\fP\fP) const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Find last posizzle of a cold-ass lil characta of string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP Strin containin charactas ta locate\&. 
.br
\fI__pos\fP Index of characta ta search back from (default end)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Index of last occurrence\&.
.RE
.PP
Startin from \fI__pos\fP, searches backward fo' one of tha charactaz of \fI__str\fP within dis string\&. If found, returns tha index where dat shiznit was found\&. If not found, returns npos\&. 
.PP
Definizzle at line 2016 of file basic_string\&.h\&.
.SS "reference \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::front ()\fC [inline]\fP, \fC [inherited]\fP"
Returns a read/write reference ta tha data all up in tha straight-up original gangsta element of tha string\&. 
.PP
Definizzle at line 897 of file basic_string\&.h\&.
.SS "const_reference \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::front () const\fC [inline]\fP, \fC [inherited]\fP"
Returns a read-only (constant) reference ta tha data all up in tha straight-up original gangsta element of tha string\&. 
.PP
Definizzle at line 905 of file basic_string\&.h\&.
.SS "allocator_type \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::get_allocator () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Return copy of allocator used ta construct dis string\&. 
.PP
Definizzle at line 1817 of file basic_string\&.h\&.
.SS "void \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::insert (iterator__p, size_type__n, _CharT__c)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Insert multiple characters\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP Iterator referencin location up in strang ta bang at\&. 
.br
\fI__n\fP Number of charactas ta bang 
.br
\fI__c\fP Da characta ta insert\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&.
.RE
.PP
Inserts \fI__n\fP copiez of characta \fI__c\fP startin all up in tha posizzle referenced by iterator \fI__p\fP\&. If addin charactas causes tha length ta exceed max_size(), length_error is thrown\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1185 of file basic_string\&.h\&.
.SS "void \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::insert (iterator__p, _InputIterator__beg, _InputIterator__end)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Insert a range of characters\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP Iterator referencin location up in strang ta bang at\&. 
.br
\fI__beg\fP Start of range\&. 
.br
\fI__end\fP End of range\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&.
.RE
.PP
Inserts charactas up in range [__beg,__end)\&. If addin charactas causes tha length ta exceed max_size(), length_error is thrown\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1202 of file basic_string\&.h\&.
.SS "void \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::insert (iterator__p, \fBinitializer_list\fP< _CharT >__l)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Insert a initializer_list of characters\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP Iterator referencin location up in strang ta bang at\&. 
.br
\fI__l\fP Da initializer_list of charactas ta insert\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&. 
.RE
.PP

.PP
Definizzle at line 1213 of file basic_string\&.h\&.
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::insert (size_type__pos1, const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Insert value of a string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos1\fP Iterator referencin location up in strang ta bang at\&. 
.br
\fI__str\fP Da strang ta insert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&.
.RE
.PP
Inserts value of \fI__str\fP startin at \fI__pos1\fP\&. If addin charactas causes tha length ta exceed max_size(), length_error is thrown\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1233 of file basic_string\&.h\&.
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::insert (size_type__pos1, const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str, size_type__pos2, size_type__n)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Insert a substring\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos1\fP Iterator referencin location up in strang ta bang at\&. 
.br
\fI__str\fP Da strang ta insert\&. 
.br
\fI__pos2\fP Start of charactas up in str ta insert\&. 
.br
\fI__n\fP Number of charactas ta insert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&. 
.br
\fIstd::out_of_range\fP If \fIpos1\fP > size() or \fI__pos2\fP > \fIstr\&.size()\fP\&.
.RE
.PP
Startin at \fIpos1\fP, bang \fI__n\fP characta of \fI__str\fP beginnin wit \fI__pos2\fP\&. If addin charactas causes tha length ta exceed max_size(), length_error is thrown\&. If \fI__pos1\fP is beyond tha end of dis strang or \fI__pos2\fP is beyond tha end of \fI__str\fP, out_of_range is thrown\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1255 of file basic_string\&.h\&.
.SS "\fBiterator\fP \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::insert (iterator__p, _CharT__c)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Insert one character\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP Iterator referencin posizzle up in strang ta bang at\&. 
.br
\fI__c\fP Da characta ta insert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator referencin newly banged char\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&.
.RE
.PP
Inserts characta \fI__c\fP at posizzle referenced by \fI__p\fP\&. If addin characta causes tha length ta exceed max_size(), length_error is thrown\&. If \fI__p\fP is beyond end of string, out_of_range is thrown\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1337 of file basic_string\&.h\&.
.SS "size_type \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::length () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Returns tha number of charactas up in tha string, not includin any null-termination\&. 
.PP
Definizzle at line 721 of file basic_string\&.h\&.
.SS "size_type \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::max_size () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Returns tha size() of tha phattest possible string\&. 
.PP
Definizzle at line 726 of file basic_string\&.h\&.
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::operator+= (const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Append a strang ta dis string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP Da strang ta append\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP

.PP
Definizzle at line 932 of file basic_string\&.h\&.
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::replace (size_type__pos, size_type__n, const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Replace charactas wit value from another string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos\fP Index of first characta ta replace\&. 
.br
\fI__n\fP Number of charactas ta be replaced\&. 
.br
\fI__str\fP Strin ta insert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fIpos\fP is beyond tha end of dis string\&. 
.br
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&.
.RE
.PP
Removes tha charactas up in tha range [__pos,__pos+__n) from dis string\&. In place, tha value of \fI__str\fP is inserted\&. If \fI__pos\fP is beyond end of string, out_of_range is thrown\&. If tha length of tha result exceedz max_size(), length_error is thrown\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1429 of file basic_string\&.h\&.
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::replace (size_type__pos1, size_type__n1, const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str, size_type__pos2, size_type__n2)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Replace charactas wit value from another string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos1\fP Index of first characta ta replace\&. 
.br
\fI__n1\fP Number of charactas ta be replaced\&. 
.br
\fI__str\fP Strin ta insert\&. 
.br
\fI__pos2\fP Index of first characta of str ta use\&. 
.br
\fI__n2\fP Number of charactas from str ta use\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fI__pos1\fP > size() or \fI__pos2\fP > __str\&.size()\&. 
.br
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&.
.RE
.PP
Removes tha charactas up in tha range [__pos1,__pos1 + n) from dis string\&. In place, tha value of \fI__str\fP is inserted\&. If \fI__pos\fP is beyond end of string, out_of_range is thrown\&. If tha length of tha result exceedz max_size(), length_error is thrown\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1451 of file basic_string\&.h\&.
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::replace (iterator__i1, iterator__i2, const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Replace range of charactas wit string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__i1\fP Iterator referencin start of range ta replace\&. 
.br
\fI__i2\fP Iterator referencin end of range ta replace\&. 
.br
\fI__str\fP Strin value ta insert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&.
.RE
.PP
Removes tha charactas up in tha range [__i1,__i2)\&. In place, tha value of \fI__str\fP is inserted\&. If tha length of result exceedz max_size(), length_error is thrown\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1538 of file basic_string\&.h\&.
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::replace (iterator__i1, iterator__i2, const _CharT *__s, size_type__n)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Replace range of charactas wit C substring\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__i1\fP Iterator referencin start of range ta replace\&. 
.br
\fI__i2\fP Iterator referencin end of range ta replace\&. 
.br
\fI__s\fP C strang value ta insert\&. 
.br
\fI__n\fP Number of charactas from s ta insert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&.
.RE
.PP
Removes tha charactas up in tha range [__i1,__i2)\&. In place, tha straight-up original gangsta \fI__n\fP charactaz of \fI__s\fP is inserted\&. If tha length of result exceedz max_size(), length_error is thrown\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1557 of file basic_string\&.h\&.
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::replace (iterator__i1, iterator__i2, const _CharT *__s)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Replace range of charactas wit C string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__i1\fP Iterator referencin start of range ta replace\&. 
.br
\fI__i2\fP Iterator referencin end of range ta replace\&. 
.br
\fI__s\fP C strang value ta insert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&.
.RE
.PP
Removes tha charactas up in tha range [__i1,__i2)\&. In place, tha charactaz of \fI__s\fP is inserted\&. If tha length of result exceedz max_size(), length_error is thrown\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1578 of file basic_string\&.h\&.
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::replace (iterator__i1, iterator__i2, size_type__n, _CharT__c)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Replace range of charactas wit multiple characters\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__i1\fP Iterator referencin start of range ta replace\&. 
.br
\fI__i2\fP Iterator referencin end of range ta replace\&. 
.br
\fI__n\fP Number of charactas ta insert\&. 
.br
\fI__c\fP Characta ta insert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&.
.RE
.PP
Removes tha charactas up in tha range [__i1,__i2)\&. In place, \fI__n\fP copiez of \fI__c\fP is inserted\&. If tha length of result exceedz max_size(), length_error is thrown\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1599 of file basic_string\&.h\&.
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::replace (iterator__i1, iterator__i2, _InputIterator__k1, _InputIterator__k2)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Replace range of charactas wit range\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__i1\fP Iterator referencin start of range ta replace\&. 
.br
\fI__i2\fP Iterator referencin end of range ta replace\&. 
.br
\fI__k1\fP Iterator referencin start of range ta insert\&. 
.br
\fI__k2\fP Iterator referencin end of range ta insert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&.
.RE
.PP
Removes tha charactas up in tha range [__i1,__i2)\&. In place, charactas up in tha range [__k1,__k2) is inserted\&. If tha length of result exceedz max_size(), length_error is thrown\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1623 of file basic_string\&.h\&.
.SS "\fBbasic_string\fP& \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::replace (iterator__i1, iterator__i2, \fBinitializer_list\fP< _CharT >__l)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Replace range of charactas wit initializer_list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__i1\fP Iterator referencin start of range ta replace\&. 
.br
\fI__i2\fP Iterator referencin end of range ta replace\&. 
.br
\fI__l\fP Da initializer_list of charactas ta insert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference ta dis string\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If freshly smoked up length exceedz \fCmax_size()\fP\&.
.RE
.PP
Removes tha charactas up in tha range [__i1,__i2)\&. In place, charactas up in tha range [__k1,__k2) is inserted\&. If tha length of result exceedz max_size(), length_error is thrown\&. Da value of tha strang don't chizzle if a error is thrown\&. 
.PP
Definizzle at line 1692 of file basic_string\&.h\&.
.SS "void \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::reserve (size_type__res_arg = \fC0\fP)\fC [inherited]\fP"

.PP
Attempt ta preallocate enough memory fo' specified number of characters\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__res_arg\fP Number of charactas required\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If \fI__res_arg\fP exceedz \fCmax_size()\fP\&.
.RE
.PP
This function attempts ta reserve enough memory fo' tha strang ta hold tha specified number of characters\&. If tha number axed is mo' than max_size(), length_error is thrown\&.
.PP
Da advantage of dis function is dat if optimal code be a necessitizzle n' tha user can determine tha strang length dat is ghon be required, tha user can reserve tha memory up in advance, n' thus prevent a possible reallocation of memory n' copyin of strang data\&. 
.SS "size_type \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::rfind (const \fBbasic_string\fP< _CharT, _Traits, _Allocator > &__str, size_type__pos = \fC\fBnpos\fP\fP) const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Find last posizzle of a string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__str\fP Strin ta locate\&. 
.br
\fI__pos\fP Index of characta ta search back from (default end)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Index of start of last occurrence\&.
.RE
.PP
Startin from \fI__pos\fP, searches backward fo' value of \fI__str\fP within dis string\&. If found, returns tha index where it begins\&. If not found, returns npos\&. 
.PP
Definizzle at line 1891 of file basic_string\&.h\&.
.SS "size_type \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::size () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Returns tha number of charactas up in tha string, not includin any null-termination\&. 
.PP
Definizzle at line 715 of file basic_string\&.h\&.
.SS "void \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::swap (\fBbasic_string\fP< _CharT, _Traits, _Allocator > &__s)\fC [inherited]\fP"

.PP
Swap contents wit another string\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__s\fP Strin ta swap with\&.
.RE
.PP
Exchanges tha contentz of dis strang wit dat of \fI__s\fP up in constant time\&. 
.SH "Member Data Documentation"
.PP 
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_sequence_base::_M_const_iterators\fC [inherited]\fP"

.PP
Da list of constant iterators dat reference dis container\&. 
.PP
Definizzle at line 184 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_sequence_base::_M_iterators\fC [inherited]\fP"

.PP
Da list of mutable iterators dat reference dis container\&. 
.PP
Definizzle at line 181 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "unsigned int __gnu_debug::_Safe_sequence_base::_M_version\fC [mutable]\fP, \fC [inherited]\fP"

.PP
Da container version number\&. This number may never be 0\&. 
.PP
Definizzle at line 187 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence_base::_M_invalidate_all(), n' __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "const size_type \fBstd::basic_string\fP< _CharT, _Traits, _Allocator  >::npos\fC [static]\fP, \fC [inherited]\fP"

.PP
Value returned by various member functions when they fail\&. 
.PP
Definizzle at line 285 of file basic_string\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
