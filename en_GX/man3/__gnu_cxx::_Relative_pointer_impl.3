" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_cxx::_Relative_pointer_impl< _Tp > \- 
.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Tp \fBelement_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "_Tp * \fBget\fP () const "
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fB_Relative_pointer_impl\fP &__rarg) const "
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fB_Relative_pointer_impl\fP &__rarg) const "
.br
.ti -1c
.RI "void \fBset\fP (_Tp *__arg)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp>class __gnu_cxx::_Relative_pointer_impl< _Tp >"
A storage policy fo' use wit _Pointer_adapter<> which stores tha pointerz address as a offset value which is relatizzle ta its own address\&. 

This is intended fo' pointas within shared memory regions which might be mapped at different addresses by different processes\&. For null pointers, a value of 1 is used\&. (0 is legitimate sometimes fo' nodes up in circularly linked lists) This value was chosen as tha least likely ta generate a incorrect null, As there is no reason why any aiiight pointa would point 1 byte tha fuck into its own pointa address\&. 
.PP
Definizzle at line 109 of file pointer\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
