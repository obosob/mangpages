" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::__debug::set< _Key, _Compare, _Allocator > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits set< _Key, _Compare, _Allocator >, n' \fB__gnu_debug::_Safe_sequence< set< _Key, _Compare, _Allocator > >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Allocator \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef 
.br
\fB__gnu_debug::_Safe_iterator\fP
.br
< \fB_Base_const_iterator\fP, \fBset\fP > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef _Base::const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef _Base::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< \fBconst_iterator\fP > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef _Base::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef 
.br
\fB__gnu_debug::_Safe_iterator\fP
.br
< \fB_Base_iterator\fP, \fBset\fP > \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Compare \fBkey_compare\fP"
.br
.ti -1c
.RI "typedef _Key \fBkey_type\fP"
.br
.ti -1c
.RI "typedef _Base::pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Base::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< \fBiterator\fP > \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef _Base::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Compare \fBvalue_compare\fP"
.br
.ti -1c
.RI "typedef _Key \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBset\fP (const _Compare &__comp=_Compare(), const _Allocator &__a=_Allocator())"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBset\fP (_InputIterator __first, _InputIterator __last, const _Compare &__comp=_Compare(), const _Allocator &__a=_Allocator())"
.br
.ti -1c
.RI "\fBset\fP (const \fBset\fP &__x)"
.br
.ti -1c
.RI "\fBset\fP (const \fB_Base\fP &__x)"
.br
.ti -1c
.RI "\fBset\fP (\fBset\fP &&__x) noexcept(\fBis_nothrow_copy_constructible\fP< _Compare >::value)"
.br
.ti -1c
.RI "\fBset\fP (\fBinitializer_list\fP< value_type > __l, const _Compare &__comp=_Compare(), const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "void \fB_M_attach\fP (_Safe_iterator_base *__it, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (_Safe_iterator_base *__it, bool __constant)  throw ()"
.br
.ti -1c
.RI "\fB_Base\fP & \fB_M_base\fP () noexcept"
.br
.ti -1c
.RI "const \fB_Base\fP & \fB_M_base\fP () const noexcept"
.br
.ti -1c
.RI "void \fB_M_detach\fP (_Safe_iterator_base *__it)"
.br
.ti -1c
.RI "void \fB_M_detach_single\fP (_Safe_iterator_base *__it)  throw ()"
.br
.ti -1c
.RI "void \fB_M_invalidate_all\fP () const "
.br
.ti -1c
.RI "void \fB_M_invalidate_if\fP (_Predicate __pred)"
.br
.ti -1c
.RI "void \fB_M_transfer_from_if\fP (_Safe_sequence &__from, _Predicate __pred)"
.br
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const noexcept"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBstd::pair\fP< \fBiterator\fP, bool > \fBemplace\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBiterator\fP \fBemplace_hint\fP (\fBconst_iterator\fP __pos, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const noexcept"
.br
.ti -1c
.RI "\fBstd::pair\fP< \fBiterator\fP, \fBiterator\fP > \fBequal_range\fP (const key_type &__x)"
.br
.ti -1c
.RI "\fBstd::pair\fP< \fBconst_iterator\fP, 
.br
\fBconst_iterator\fP > \fBequal_range\fP (const key_type &__x) const "
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBconst_iterator\fP __position)"
.br
.ti -1c
.RI "size_type \fBerase\fP (const key_type &__x)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBconst_iterator\fP __first, \fBconst_iterator\fP __last)"
.br
.ti -1c
.RI "\fBiterator\fP \fBfind\fP (const key_type &__x)"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBfind\fP (const key_type &__x) const "
.br
.ti -1c
.RI "\fBstd::pair\fP< \fBiterator\fP, bool > \fBinsert\fP (const value_type &__x)"
.br
.ti -1c
.RI "\fBstd::pair\fP< \fBiterator\fP, bool > \fBinsert\fP (value_type &&__x)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP __position, const value_type &__x)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP __position, value_type &&__x)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fBinsert\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "\fBiterator\fP \fBlower_bound\fP (const key_type &__x)"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBlower_bound\fP (const key_type &__x) const "
.br
.ti -1c
.RI "\fBset\fP & \fBoperator=\fP (const \fBset\fP &__x)"
.br
.ti -1c
.RI "\fBset\fP & \fBoperator=\fP (\fBset\fP &&__x)"
.br
.ti -1c
.RI "\fBset\fP & \fBoperator=\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBswap\fP (\fBset\fP &__x)"
.br
.ti -1c
.RI "\fBiterator\fP \fBupper_bound\fP (const key_type &__x)"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBupper_bound\fP (const key_type &__x) const "
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "_Safe_iterator_base * \fB_M_const_iterators\fP"
.br
.ti -1c
.RI "_Safe_iterator_base * \fB_M_iterators\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_detach_all\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_singular\fP ()"
.br
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()  throw ()"
.br
.ti -1c
.RI "void \fB_M_revalidate_singular\fP ()"
.br
.ti -1c
.RI "void \fB_M_swap\fP (_Safe_sequence_base &__x)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Key, typename _Compare = std::less<_Key>, typename _Allocator = std::allocator<_Key>>class std::__debug::set< _Key, _Compare, _Allocator >"
Class std::set wit safety/checking/debug instrumentation\&. 
.PP
Definizzle at line 43 of file debug/set\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Attach a iterator ta dis sequence\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach_single (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Detach a iterator from dis sequence 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_all ()\fC [protected]\fP, \fC [inherited]\fP"
Detach all iterators, leavin dem singular\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence_base::~_Safe_sequence_base()\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_single (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Detach all singular iterators\&. 
.PP
\fBPostcondition:\fP
.RS 4
for all iterators i attached ta dis sequence, i->_M_version == _M_version\&. 
.RE
.PP

.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_sequence_base::_M_get_mutex ()\fC [protected]\fP, \fC [inherited]\fP"
For use up in _Safe_sequence\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_invalidate_all () const\fC [inline]\fP, \fC [inherited]\fP"
Invalidates all iterators\&. 
.PP
Definizzle at line 233 of file safe_base\&.h\&.
.PP
References __gnu_debug::_Safe_sequence_base::_M_version\&.
.SS "void \fB__gnu_debug::_Safe_sequence\fP< \fBset\fP< _Key, _Compare, _Allocator >  >::_M_invalidate_if (_Predicate__pred)\fC [inherited]\fP"
Invalidates all iterators \fCx\fP dat reference dis sequence, is not singular, n' fo' which \fC__pred(x)\fP returns \fCtrue\fP\&. \fC__pred\fP is ghon be invoked wit tha aiiight iterators nested up in tha safe ones\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_revalidate_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Revalidates all attached singular iterators\&. This method may be used ta validate iterators dat was invalidated before (but fo' some reason, like fuckin a exception, need ta become valid again)\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_swap (\fB_Safe_sequence_base\fP &__x)\fC [protected]\fP, \fC [inherited]\fP"
Swap dis sequence wit tha given sequence\&. This operation also swaps ballershizzle of tha iterators, so dat when tha operation is complete all iterators dat originally referenced one container now reference tha other container\&. 
.SS "void \fB__gnu_debug::_Safe_sequence\fP< \fBset\fP< _Key, _Compare, _Allocator >  >::_M_transfer_from_if (\fB_Safe_sequence\fP< \fBset\fP< _Key, _Compare, _Allocator > > &__from, _Predicate__pred)\fC [inherited]\fP"
Transfers all iterators \fCx\fP dat reference \fCfrom\fP sequence, is not singular, n' fo' which \fC__pred(x)\fP returns \fCtrue\fP\&. \fC__pred\fP is ghon be invoked wit tha aiiight iterators nested up in tha safe ones\&. 
.SH "Member Data Documentation"
.PP 
.SS "_Safe_iterator_base* __gnu_debug::_Safe_sequence_base::_M_const_iterators\fC [inherited]\fP"

.PP
Da list of constant iterators dat reference dis container\&. 
.PP
Definizzle at line 184 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "_Safe_iterator_base* __gnu_debug::_Safe_sequence_base::_M_iterators\fC [inherited]\fP"

.PP
Da list of mutable iterators dat reference dis container\&. 
.PP
Definizzle at line 181 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "unsigned int __gnu_debug::_Safe_sequence_base::_M_version\fC [mutable]\fP, \fC [inherited]\fP"

.PP
Da container version number\&. This number may never be 0\&. 
.PP
Definizzle at line 187 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence_base::_M_invalidate_all(), n' __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
