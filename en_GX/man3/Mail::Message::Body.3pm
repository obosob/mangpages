.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message::Body 3"
.TH Mail::Message::Body 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Body \- tha data of a funky-ass body up in a message
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\& Mail::Message::Body has extra code in
\&   Mail::Message::Body::Construct
\&   Mail::Message::Body::Encode
\&
\& Mail::Message::Body
\&   be a Mail::Reporter
\&
\& Mail::Message::Body is extended by
\&   Mail::Message::Body::File
\&   Mail::Message::Body::Lines
\&   Mail::Message::Body::Multipart
\&   Mail::Message::Body::Nested
\&   Mail::Message::Body::String
\&
\& Mail::Message::Body is realized by
\&   Mail::Message::Body::Delayed
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\& mah Mail::Message $msg = ...;
\& mah $body  = $msg\->body;
\& mah @text  = $body\->lines;
\& mah $text  = $body\->string;
\& mah $file  = $body\->file;  # IO::File
\& $body\->print(\e*FILE);
\&
\& mah $content_type = $body\->type;
\& mah $transfer_encodin = $body\->transferEncoding;
\& mah $encoded = $body\->encode(mime_type => \*(Aqtext/html\*(Aq,
\&    charset => \*(Aqus\-ascii\*(Aq, transfer_encodin => \*(Aqnone\*(Aq);\en";
\& mah $decoded = $body\->decoded;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da encodin n' decodin functionalitizzle of a Mail::Message::Body is
implemented up in tha Mail::Message::Body::Encode package.  That package is
automatically loaded when encodin n' decodin of lyrics need ta take
place.  Methodz ta simply build a process body objects is implemented
in Mail::Message::Body::Construct.
.PP
Da body of a message (a Mail::Message object) is stored up in one of the
many body types.  Da functionalitizzle of each body type is equivalent yo, but there
are performizzle differences.  Each body type has its own documentation
with details bout its implementation.
.SH "OVERLOADED"
.IX Header "OVERLOADED"
.ie n .IP "overload: \fB""""\fR()" 4
.el .IP "overload: \fB``''\fR()" 4
.IX Item "overload: """"()"
(stringification) Returns tha body as strang \-\-which will trigger
completion\*(-- unless called ta produce a strang fo' \f(CW\*(C`Carp\*(C'\fR.  Da latter
to avoid deep recursions.
.Sp
example: stringification of body
.Sp
.Vb 1
\& print $msg\->body;   # implicit by print
\&
\& mah $body = $msg\->body;
\& mah $x    = "$body"; # explicit by interpolation
.Ve
.IP "overload: \fB'==' n' '!='\fR()" 4
.IX Item "overload: '==' n' '!='()"
(numeric comparison) compares if two references point ta the
same message.  This only produces erect thangs up in dis biatch is both arguments
are message references \fBwithin tha same folder\fR.
.Sp
example: use of numeric comparison on a funky-ass body
.Sp
.Vb 5
\& mah $skip = $folder\->message(3);
\& foreach mah $msg (@$folder)
\& {   next if $msg == $skip;
\&     $msg\->send;
\& }
.Ve
.IP "overload: \fB@{}\fR()" 4
.IX Item "overload: @{}()"
When a funky-ass body object is used as bein a array reference, tha lines of
the body is returned. Y'all KNOW dat shit, muthafucka!  This is tha same ol' dirty as rockin \fIlines()\fR.
.Sp
example: rockin a funky-ass body as array
.Sp
.Vb 2
\& print $body\->lines\->[1];  # second line
\& print $body\->[1];         # same
\&
\& mah @lines = $body\->lines;
\& mah @lines = @$body;       # same
.Ve
.IP "overload: \fBbool\fR()" 4
.IX Item "overload: bool()"
Always returns a legit value, which is needed ta have overloaded
objects ta be used as up in \f(CW\*(C`if($body)\*(C'\fR.  Otherwise, \f(CW\*(C`if(defined $body)\*(C'\fR
would be needed ta avoid a runtime error.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBclone\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBclone\fR()" 4
.IX Item "$obj->clone()"
Return a cold-ass lil copy of dis body, probably ta be included up in a cold-ass lil cloned
message. Use \fIMail::Message::clone()\fR fo' a whole message.
.IP "Mail::Message::Body\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Message::Body->new(OPTIONS)"
\&\s-1BE WARNED\s0 that, what tha fuck you specify here is encodings n' such which are
already up in place.  Da options aint gonna trigger conversions.  When you
need conversions, first create a funky-ass body wit options which tell what tha fuck you've
got, n' then call \fIencode()\fR fo' what tha fuck you need.
.Sp
.Vb 10
\& \-Option           \-\-Defined up in     \-\-Default
\&  based_on                            undef
\&  charset                             \*(AqPERL\*(Aq or <undef>
\&  checked                             <false>
\&  content_id                          undef
\&  data                                undef
\&  description                         undef
\&  disposizzle                         undef
\&  eol                                 \*(AqNATIVE\*(Aq
\&  file                                undef
\&  log                Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  message                             undef
\&  mime_type                           \*(Aqtext/plain\*(Aq
\&  modified                            <false>
\&  trace              Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  transfer_encodin                   \*(Aqnone\*(Aq
.Ve
.RS 4
.IP "based_on => \s-1BODY\s0" 2
.IX Item "based_on => BODY"
Da shiznit bout encodings must be taken from tha specified \s-1BODY,\s0
unless specified differently.
.IP "charset => CHARSET|'\s-1PERL\s0'" 2
.IX Item "charset => CHARSET|'PERL'"
Defines tha character-set which is used up in tha data.  Only useful in
combination wit a \f(CW\*(C`mime_type\*(C'\fR which refers ta \f(CW\*(C`text\*(C'\fR up in any shape,
which do not contain a explicit charset already.  This field is
case-insensitive.
.Sp
When a known \s-1CHARSET\s0 is provided n' tha mime type say \*(L"text\*(R", then the
data is sposed ta fuckin be bytes up in dat particular encodin (see Encode).
When '\s-1PERL\s0' is given, then then tha data is up in Perlz internal encoding
(either latin1 or utf8, you shouldn't know!) Mo' details in
\&\*(L"Characta encodin \s-1PERL\*(R"\s0
.IP "checked => \s-1BOOLEAN\s0" 2
.IX Item "checked => BOOLEAN"
Whether tha added shiznit has been check not ta contain illegal
octets wit respect ta tha transfer encodin n' mime type.  If not
checked, n' then set as body fo' a message, it will be.
.IP "content_id => \s-1STRING\s0" 2
.IX Item "content_id => STRING"
In multipart/related \s-1MIME\s0 content, tha content_id is required to
allow access ta tha related content via a cold-ass lil cid:<...> descriptor of
an inline disposition.
.Sp
A \f(CW\*(C`Content\-ID\*(C'\fR is supposed ta be globally unique.  As such, it
is common ta append '@computer.domain' ta tha end of some unique
string.  As other content up in tha multipart/related container also
needz ta know what tha fuck dis \f(CW\*(C`Content\-ID\*(C'\fR is, dis should be left to
the imagination of tha thug makin tha content (for now).
.Sp
As a \s-1MIME\s0 header field, tha \f(CW\*(C`Content\-ID\*(C'\fR strang is sposed ta fuckin
be inside angle brackets
.IP "data => ARRAY-OF-LINES | \s-1STRING\s0" 2
.IX Item "data => ARRAY-OF-LINES | STRING"
Da content of tha body.  Da only way ta set tha content of a funky-ass body
is durin tha creation of tha body.  So if you wanna modify tha content
of a message, you need ta create a freshly smoked up body wit tha freshly smoked up content and
add dat ta tha body.  Da reason behind this, is dat erect encodings
and body shiznit must be guaranteed. Y'all KNOW dat shit, muthafucka!  It avoidz yo' hassle in
calculatin tha number of lines up in tha body, n' checkin whether bad
charactas is enclosed up in text.
.Sp
Specify a reference ta a \s-1ARRAY\s0 of lines, each terminated by a newline.
Or one \s-1STRING\s0 which may contain multiple lines, separated n' terminated
by a newline.
.IP "description => STRING|FIELD" 2
.IX Item "description => STRING|FIELD"
Informal shiznit bout tha body content.  Da data relates ta the
\&\f(CW\*(C`Content\-Description\*(C'\fR field. Y'all KNOW dat shit, muthafucka!  Specify a \s-1STRING\s0 which will become the
field content, or a real \s-1FIELD.\s0
.IP "disposizzle => STRING|FIELD" 2
.IX Item "disposizzle => STRING|FIELD"
How tha fuck dis message can be decomposed. Y'all KNOW dat shit, muthafucka!  Da data relates ta the
\&\f(CW\*(C`Content\-Disposition\*(C'\fR field. Y'all KNOW dat shit, muthafucka!  Specify a \s-1STRING\s0 which will become the
field content, or a real \s-1FIELD.\s0
.Sp
Da content of dis field is specified up in \s-1RFC 1806. \s0 Da body of the
field can be \f(CW\*(C`inline\*(C'\fR, ta indicate dat tha body is intended ta be
displayed automatically upon display of tha message. Use \f(CW\*(C`attachment\*(C'\fR
to indicate dat they is separate from tha main body of tha mail
message, n' dat they display should not be automatic yo, but contingent
upon some further action of tha user.
.Sp
Da \f(CW\*(C`filename\*(C'\fR attribute specifies a name ta which is suggested ta the
reader of tha message when it is extracted.
.IP "eol => '\s-1CR\s0'|'\s-1LF\s0'|'\s-1CRLF\s0'|'\s-1NATIVE\s0'" 2
.IX Item "eol => 'CR'|'LF'|'CRLF'|'NATIVE'"
Convert tha message tha fuck into havin tha specified strang as line terminator
for all lines up in tha body.  \f(CW\*(C`NATIVE\*(C'\fR is used ta represent tha \f(CW\*(C`\en\*(C'\fR
on tha current platform n' is ghon be translated up in tha applicable one.
.Sp
\&\s-1BE WARNED\s0 dat foldaz wit a non-natizzle encodin may step tha fuck up on your
platform, fo' instizzle up in Windows foldaz handled from a \s-1UNIX\s0 system.
Da eol encodin has effect on tha size of tha body!
.IP "file => FILENAME|FILEHANDLE|IOHANDLE" 2
.IX Item "file => FILENAME|FILEHANDLE|IOHANDLE"
Read tha data from tha specified file, file handle, or object of
type \f(CW\*(C`IO::Handle\*(C'\fR.
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "message => \s-1MESSAGE\s0" 2
.IX Item "message => MESSAGE"
.PD
Da message where dis body belongs to.
.IP "mime_type => STRING|FIELD|MIME" 2
.IX Item "mime_type => STRING|FIELD|MIME"
Da type of data which be added. Y'all KNOW dat shit, muthafucka!  Yo ass may specify a cold-ass lil content of a header
line as \s-1STRING,\s0 or a \s-1FIELD\s0 object.  Yo ass may also specify a MIME::Type
object.  In any case, it is ghon be kept internally as
a real field (a Mail::Message::Field object).  This relates ta the
\&\f(CW\*(C`Content\-Type\*(C'\fR header field.
.Sp
A mime-type justification consistz of two parts: a general class (\f(CW\*(C`text\*(C'\fR,
\&\f(CW\*(C`image\*(C'\fR, \f(CW\*(C`application\*(C'\fR, etc) n' a specific sub-class.  Examplez for
specific classes wit \f(CW\*(C`text\*(C'\fR is \f(CW\*(C`plain\*(C'\fR, \f(CW\*(C`html\*(C'\fR, n' \f(CW\*(C`xml\*(C'\fR.  This
field is case-insensitizzle but case preserving.  Da default mime-type
is \f(CW\*(C`text/plain\*(C'\fR,
.IP "modified => \s-1BOOLEAN\s0" 2
.IX Item "modified => BOOLEAN"
Whether tha body is flagged modified, directly from its creation.
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.PD 0
.IP "transfer_encodin => STRING|FIELD" 2
.IX Item "transfer_encodin => STRING|FIELD"
.PD
Da encodin dat tha data has.  If tha data is ta be encoded, than you
will gotta call \fIencode()\fR afta tha body is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  That will
return a freshly smoked up encoded body.  This field is case-insensitizzle n' relates
to tha \f(CW\*(C`Content\-Transfer\-Encoding\*(C'\fR field up in tha header.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 2
\& mah $body = Mail::Message::Body::String\->new(file => \e*IN,
\&    mime_type => \*(Aqtext/html; charset="ISO\-8859\-1"\*(Aq);
\&
\& mah $body = Mail::Message::Body::Lines\->new(data => [\*(Aqfirst\*(Aq, $second],
\&    charset => \*(AqISO\-10646\*(Aq, transfer_encodin => \*(Aqnone\*(Aq);
\&
\& mah $body = Mail::Message::Body::Lines\->new(data => \e@lines,
\&    transfer_encodin => \*(Aqbase64\*(Aq);
\&
\& mah $body = Mail::Message::Body::Lines\->new(file => \*(Aqpicture.gif\*(Aq,
\&    mime_type => \*(Aqimage/gif\*(Aq, content_id => \*(Aq<12345@example.com>\*(Aq,
\&    disposizzle => \*(Aqinline\*(Aq);
.Ve
.RE
.SS "Constructin a funky-ass body"
.IX Subsection "Constructin a funky-ass body"
.ie n .IP "$obj\->\fBattach\fR(\s-1MESSAGES, OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBattach\fR(\s-1MESSAGES, OPTIONS\s0)" 4
.IX Item "$obj->attach(MESSAGES, OPTIONS)"
See \*(L"Constructin a funky-ass body\*(R" up in Mail::Message::Body::Construct
.ie n .IP "$obj\->\fBcheck\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcheck\fR()" 4
.IX Item "$obj->check()"
See \*(L"Constructin a funky-ass body\*(R" up in Mail::Message::Body::Encode
.ie n .IP "$obj\->\fBconcatenate\fR(\s-1COMPONENTS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBconcatenate\fR(\s-1COMPONENTS\s0)" 4
.IX Item "$obj->concatenate(COMPONENTS)"
See \*(L"Constructin a funky-ass body\*(R" up in Mail::Message::Body::Construct
.ie n .IP "$obj\->\fBdecoded\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdecoded\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->decoded(OPTIONS)"
Returns a funky-ass body, a object which is (a sub\-)class of a Mail::Message::Body,
which gotz nuff a simplified representation of textual data.  Da returned
object may be tha object where dis is called on yo, but may also be a new
body of any type.
.Sp
.Vb 1
\& mah $dec = $body\->decoded;
.Ve
.Sp
is equivalent with
.Sp
.Vb 5
\& mah $dec = $body\->encode
\&   ( mime_type         => \*(Aqtext/plain\*(Aq
\&   , transfer_encodin => \*(Aqnone\*(Aq
\&   , charset           => \*(AqPERL\*(Aq
\&   );
.Ve
.Sp
Da \f(CW$dec\fR which is returned be a funky-ass body.  Ask wit tha \fImimeType()\fR method
what is produced. Y'all KNOW dat shit, muthafucka!  This \f(CW$dec\fR body is \fBnot related ta a header\fR.
.Sp
.Vb 2
\& \-Option     \-\-Default
\&  result_type  <same as current>
.Ve
.RS 4
.IP "result_type => \s-1CLASS\s0" 2
.IX Item "result_type => CLASS"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBencode\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBencode\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->encode(OPTIONS)"
.PD
See \*(L"Constructin a funky-ass body\*(R" up in Mail::Message::Body::Encode
.ie n .IP "$obj\->\fBencoded\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBencoded\fR()" 4
.IX Item "$obj->encoded()"
See \*(L"Constructin a funky-ass body\*(R" up in Mail::Message::Body::Encode
.ie n .IP "$obj\->\fBeol\fR(['\s-1CR\s0'|'\s-1LF\s0'|'\s-1CRLF\s0'|'\s-1NATIVE\s0'])" 4
.el .IP "\f(CW$obj\fR\->\fBeol\fR(['\s-1CR\s0'|'\s-1LF\s0'|'\s-1CRLF\s0'|'\s-1NATIVE\s0'])" 4
.IX Item "$obj->eol(['CR'|'LF'|'CRLF'|'NATIVE'])"
Returns tha characta (or characters) which is used ta separate lines
within dis body.  When a kind of separator is specified, tha body is
translated ta contain tha specified line endings.
.Sp
example:
.Sp
.Vb 2
\& mah $body = $msg\->decoded\->eol(\*(AqNATIVE\*(Aq);
\& mah $char = $msg\->decoded\->eol;
.Ve
.ie n .IP "$obj\->\fBforeachLine\fR(\s-1CODE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBforeachLine\fR(\s-1CODE\s0)" 4
.IX Item "$obj->foreachLine(CODE)"
See \*(L"Constructin a funky-ass body\*(R" up in Mail::Message::Body::Construct
.ie n .IP "$obj\->\fBstripSignature\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBstripSignature\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->stripSignature(OPTIONS)"
See \*(L"Constructin a funky-ass body\*(R" up in Mail::Message::Body::Construct
.ie n .IP "$obj\->\fBunify\fR(\s-1BODY\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBunify\fR(\s-1BODY\s0)" 4
.IX Item "$obj->unify(BODY)"
See \*(L"Constructin a funky-ass body\*(R" up in Mail::Message::Body::Encode
.SS "Da body"
.IX Subsection "Da body"
.ie n .IP "$obj\->\fBisDelayed\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDelayed\fR()" 4
.IX Item "$obj->isDelayed()"
Returns a legit or false value, dependin on whether tha body of this
message has been read from file.  This can only false fo' a
Mail::Message::Body::Delayed.
.ie n .IP "$obj\->\fBisMultipart\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisMultipart\fR()" 4
.IX Item "$obj->isMultipart()"
Returns whether dis message-body gotz nuff parts which is lyrics
by theyselves.
.ie n .IP "$obj\->\fBisNested\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisNested\fR()" 4
.IX Item "$obj->isNested()"
Only legit fo' a message body which gotz nuff exactly one sub-message:
the \f(CW\*(C`Mail::Message::Body::Nested\*(C'\fR body type.
.ie n .IP "$obj\->\fBmessage\fR([\s-1MESSAGE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmessage\fR([\s-1MESSAGE\s0])" 4
.IX Item "$obj->message([MESSAGE])"
Returns tha message (or message part) where dis body belongs to,
optionally settin it ta a freshly smoked up \s-1MESSAGE\s0 first.  If \f(CW\*(C`undef\*(C'\fR is passed,
the body is ghon be disconnected from tha message.
.ie n .IP "$obj\->\fBpartNumberOf\fR(\s-1PART\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBpartNumberOf\fR(\s-1PART\s0)" 4
.IX Item "$obj->partNumberOf(PART)"
Returns a strang fo' multiparts n' nested, otherwise a error. Shiiit, dis aint no joke.  It is
used up in \fIMail::Message::partNumber()\fR.
.SS "Bout tha payload"
.IX Subsection "Bout tha payload"
.ie n .IP "$obj\->\fBcharset\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcharset\fR()" 4
.IX Item "$obj->charset()"
Returns tha characta set which is used up in tha text body as string.  This
is part of tha result of what tha fuck tha \f(CW\*(C`type\*(C'\fR method returns.
.ie n .IP "$obj\->\fBchecked\fR([\s-1BOOLEAN\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBchecked\fR([\s-1BOOLEAN\s0])" 4
.IX Item "$obj->checked([BOOLEAN])"
Returns whether tha body encodin has been checked or not (optionally
afta settin tha flag ta a freshly smoked up value).
.ie n .IP "$obj\->\fBcontentId\fR([STRING|FIELD])" 4
.el .IP "\f(CW$obj\fR\->\fBcontentId\fR([STRING|FIELD])" 4
.IX Item "$obj->contentId([STRING|FIELD])"
Returns (optionally afta setting) tha id (unique reference) of a
message part.  Da related header field is \f(CW\*(C`Content\-ID\*(C'\fR.
A Mail::Message::Field object is returned (which stringifies into
the field content).  Da field content is ghon be \f(CW\*(C`none\*(C'\fR if no disposition
was specified.
.Sp
Da argument can be a \s-1STRING \s0(which is converted tha fuck into a gangbangin' field), or a
fully prepared header \s-1FIELD.\s0
.ie n .IP "$obj\->\fBdescription\fR([STRING|FIELD])" 4
.el .IP "\f(CW$obj\fR\->\fBdescription\fR([STRING|FIELD])" 4
.IX Item "$obj->description([STRING|FIELD])"
Returns (optionally afta setting) tha informal description of tha body
content.  Da related header field is \f(CW\*(C`Content\-Description\*(C'\fR.
A Mail::Message::Field object is returned (which stringifies into
the field content).  Da field content is ghon be \f(CW\*(C`none\*(C'\fR if no disposition
was specified.
.Sp
Da argument can be a \s-1STRING \s0(which is converted tha fuck into a gangbangin' field), or a
fully prepared header field.
.ie n .IP "$obj\->\fBdisposition\fR([STRING|FIELD])" 4
.el .IP "\f(CW$obj\fR\->\fBdisposition\fR([STRING|FIELD])" 4
.IX Item "$obj->disposition([STRING|FIELD])"
Returns (optionally afta setting) how tha fuck tha message can be disposed
(unpacked).  Da related header field is \f(CW\*(C`Content\-Disposition\*(C'\fR.
A Mail::Message::Field object is returned (which stringifies into
the field content).  Da field content is ghon be \f(CW\*(C`none\*(C'\fR if no disposition
was specified.
.Sp
Da argument can be a \s-1STRING \s0(which is converted tha fuck into a gangbangin' field), or a
fully prepared header field.
.ie n .IP "$obj\->\fBdispositionFilename\fR([\s-1DIRECTORY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdispositionFilename\fR([\s-1DIRECTORY\s0])" 4
.IX Item "$obj->dispositionFilename([DIRECTORY])"
See \*(L"Bout tha payload\*(R" up in Mail::Message::Body::Encode
.ie n .IP "$obj\->\fBisBinary\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisBinary\fR()" 4
.IX Item "$obj->isBinary()"
See \*(L"Bout tha payload\*(R" up in Mail::Message::Body::Encode
.ie n .IP "$obj\->\fBisText\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisText\fR()" 4
.IX Item "$obj->isText()"
See \*(L"Bout tha payload\*(R" up in Mail::Message::Body::Encode
.ie n .IP "$obj\->\fBmimeType\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmimeType\fR()" 4
.IX Item "$obj->mimeType()"
Returns a MIME::Type object which is related ta dis bodyz type.  This
differs from tha \f(CW\*(C`type\*(C'\fR method, which thangs up in dis biatch up in a Mail::Message::Field.
.Sp
example:
.Sp
.Vb 2
\& if($body\->mimeType eq \*(Aqtext/html\*(Aq) {...}
\& print $body\->mimeType\->simplified;
.Ve
.ie n .IP "$obj\->\fBnrLines\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnrLines\fR()" 4
.IX Item "$obj->nrLines()"
Returns tha number of lines up in tha message body.  For multi-part lyrics,
this includes tha header lines n' boundariez of all tha parts.
.ie n .IP "$obj\->\fBsize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsize\fR()" 4
.IX Item "$obj->size()"
Da total number of bytes up in tha message body. Da size of tha body
is computed up in tha shape it is in. I aint talkin' bout chicken n' gravy biatch. For example, if dis be a funky-ass base64
encoded message, tha size of tha encoded data is returned; you may
want ta booty-call \fIMail::Message::decoded()\fR first.
.ie n .IP "$obj\->\fBtransferEncoding\fR([STRING|FIELD])" 4
.el .IP "\f(CW$obj\fR\->\fBtransferEncoding\fR([STRING|FIELD])" 4
.IX Item "$obj->transferEncoding([STRING|FIELD])"
Returns tha transfer-encodin of tha data within dis body as
Mail::Message::Field (which stringifies ta its content).  If it
needz ta be chizzled, call tha \fIencode()\fR or \fIdecoded()\fR method.
When no encodin is present, tha field gotz nuff tha text \f(CW\*(C`none\*(C'\fR.
.Sp
Da optionizzle \s-1STRING\s0 or \s-1FIELD\s0 enforces a freshly smoked up encodin ta be set, without the
actual required translations.
.Sp
example:
.Sp
.Vb 3
\& mah $transfer = $msg\->decoded\->transferEncoding;
\& $transfer\->print;   # \-\-> Content\-Encoding: base64
\& print $transfer;    # \-\-> base64
\&
\& if($msg\->body\->transferEncodin eq \*(Aqnone\*(Aq) {...}
.Ve
.ie n .IP "$obj\->\fBtype\fR([STRING|FIELD])" 4
.el .IP "\f(CW$obj\fR\->\fBtype\fR([STRING|FIELD])" 4
.IX Item "$obj->type([STRING|FIELD])"
Returns tha type of shiznit tha body gotz nuff as
Mail::Message::Field object.  Da type is taken from tha header
field \f(CW\*(C`Content\-Type\*(C'\fR. If tha header did not contain dat field,
then yo big-ass booty is ghon git a thugged-out default field containin \f(CW\*(C`text/plain\*(C'\fR.
.Sp
Yo ass probably can betta use \fImimeType()\fR, cuz dat will return a
clever object wit type shiznit.
.Sp
example:
.Sp
.Vb 3
\& mah $msg     = $folder\->message(6);
\& $msg\->get(\*(AqContent\-Type\*(Aq)\->print;
\&    # \-\-> Content\-Type: text/plain; charset="us\-ascii"
\&
\& mah $content = $msg\->decoded;
\& mah $type    = $content\->type;
\&
\& print "This be a $type message\en";
\&    # \-\-> This be a text/plain; charset="us\-ascii" message
\&
\& print "This be a ", $type\->body, "message\en";
\&    # \-\-> This be a text/plain message
\&
\& print "Comment: ", $type\->comment, "\en";
\&    # \-\-> Comment: charset="us\-ascii"
.Ve
.SS "Access ta tha payload"
.IX Subsection "Access ta tha payload"
.ie n .IP "$obj\->\fBendsOnNewline\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBendsOnNewline\fR()" 4
.IX Item "$obj->endsOnNewline()"
Returns whether tha last line of tha body is terminated by a new-line
(in transhiznit it will become a \s-1CRLF\s0).  An empty body will return true
as well: tha newline be reppin tha line before dat shit.
.ie n .IP "$obj\->\fBfile\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfile\fR()" 4
.IX Item "$obj->file()"
Return tha content of tha body as a gangbangin' file handle.  Da returned stream may
be a real file, or a simulated file up in any form dat Perl supports, n' you can put dat on yo' toast.  While
you may not be able ta write ta tha file handle, you can read from dat shit.
.Sp
\&\s-1WARNING:\s0 Even if tha file handle supports writing, do not write
to tha file handle. If you do, a shitload of tha internal jointz of the
Mail::Message::Body may not be updated.
.ie n .IP "$obj\->\fBlines\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlines\fR()" 4
.IX Item "$obj->lines()"
Return tha content of tha body as a list of lines (in \s-1LIST\s0 context) or a
reference ta a array of lines (in \s-1SCALAR\s0 context).  In scalar context the
array of lines is cached ta avoid needless copyin n' therefore provide
much fasta access fo' big-ass lyrics.
.Sp
To just git tha number of lines up in tha body, use tha \fInrLines()\fR method,
which is probably much mo' efficient.
.Sp
\&\s-1BE WARNED:\s0 For some typez of bodies tha reference will refer ta the
original gangsta data. Yo ass must not chizzle tha referenced data! If you do, some of
the essential internal variablez of tha Mail::Message::Body may not be
updated.
.Sp
example:
.Sp
.Vb 3
\& mah @lines    = $body\->lines;     # copies lines
\& mah $line3    = ($body\->lines)[3] # only one copy
\& print $lines[0];
\&
\& mah $linesref = $body\->lines;     # reference ta originals
\& mah $line3    = $body\->lines\->[3] # only one copy (faster)
\& print $linesref\->[0];
\&
\& print $body\->[0];                # by overloading
.Ve
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
Print tha body ta tha specified \s-1FILEHANDLE \s0(defaults ta tha selected handle).
Da handle may be a \s-1GLOB,\s0 a IO::File object, or... any object wit a
\&\f(CW\*(C`print()\*(C'\fR method will do.  Nothang useful is returned.
.ie n .IP "$obj\->\fBprintEscapedFrom\fR(\s-1FILEHANDLE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBprintEscapedFrom\fR(\s-1FILEHANDLE\s0)" 4
.IX Item "$obj->printEscapedFrom(FILEHANDLE)"
Print tha body ta tha specified \s-1FILEHANDLE\s0 but all lines which start
with 'From ' (optionally already preceded by >'s) will habe a >
added up in front.  Nothang useful is returned.
.ie n .IP "$obj\->\fBstring\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstring\fR()" 4
.IX Item "$obj->string()"
Return tha content of tha body as a scalar (a single string).  This is
a copy of tha internally kept shiznit.
.Sp
example:
.Sp
.Vb 2
\& mah $text = $body\->string;
\& print "Body: $body\en";     # by overloading
.Ve
.ie n .IP "$obj\->\fBstripTrailingNewline\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstripTrailingNewline\fR()" 4
.IX Item "$obj->stripTrailingNewline()"
Remove tha newline from tha last line, or tha last line if it do not
contain anythang else than a newline.
.ie n .IP "$obj\->\fBwrite\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBwrite\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->write(OPTIONS)"
Write tha content of tha body ta a gangbangin' file.  Be warned dat you may want to
decode tha body before freestylin dat shiznit son!
.Sp
.Vb 2
\& \-Option  \-\-Default
\&  filename  <required>
.Ve
.RS 4
.IP "filename => \s-1FILENAME\s0" 2
.IX Item "filename => FILENAME"
.RE
.RS 4
.Sp
example: write tha data ta a gangbangin' file
.Sp
.Vb 4
\& use File::Temp;
\& mah $fn = tempfile;
\& $message\->decoded\->write(filename => $fn)
\&    or take a thugged-out dirtnap "Couldn\*(Aqt write ta $fn: $!\en";
.Ve
.Sp
example: rockin tha content-disposizzle shiznit ta write
.Sp
.Vb 5
\& use File::Temp;
\& mah $dir = tempdir; mkdir $dir or die;
\& mah $fn  = $message\->body\->dispositionFilename($dir);
\& $message\->decoded\->write(filename => $fn)
\&    or take a thugged-out dirtnap "Couldn\*(Aqt write ta $fn: $!\en";
.Ve
.RE
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBaddTransferEncHandlez\fR(\s-1NAME,\s0 CLASS|OBJECT)" 4
.el .IP "\f(CW$obj\fR\->\fBaddTransferEncHandlez\fR(\s-1NAME,\s0 CLASS|OBJECT)" 4
.IX Item "$obj->addTransferEncHandlez(NAME, CLASS|OBJECT)"
.PD 0
.IP "Mail::Message::Body\->\fBaddTransferEncHandlez\fR(\s-1NAME,\s0 CLASS|OBJECT)" 4
.IX Item "Mail::Message::Body->addTransferEncHandlez(NAME, CLASS|OBJECT)"
.PD
See \*(L"Internals\*(R" up in Mail::Message::Body::Encode
.ie n .IP "$obj\->\fBcontentInfoFrom\fR(\s-1HEAD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcontentInfoFrom\fR(\s-1HEAD\s0)" 4
.IX Item "$obj->contentInfoFrom(HEAD)"
Transfer tha body related info from tha header tha fuck into dis body.
.ie n .IP "$obj\->\fBcontentInfoTo\fR(\s-1HEAD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcontentInfoTo\fR(\s-1HEAD\s0)" 4
.IX Item "$obj->contentInfoTo(HEAD)"
Copy tha content shiznit (the \f(CW\*(C`Content\-*\*(C'\fR fields) tha fuck into tha specified
\&\s-1HEAD. \s0 Da body was pimped from raw data without tha required shiznit,
which must be added. Y'all KNOW dat shit, muthafucka!  See also \fIcontentInfoFrom()\fR.
.ie n .IP "$obj\->\fBfileLocation\fR([\s-1BEGIN,END\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfileLocation\fR([\s-1BEGIN,END\s0])" 4
.IX Item "$obj->fileLocation([BEGIN,END])"
Da location of tha body up in tha file.  Returned a list containin begin and
end yo, but it ain't no stoppin cause I be still poppin'.  Da begin is tha offsetz of tha straight-up original gangsta byte if tha folda used for
this body.  Da end is tha offset of tha straight-up original gangsta byte of tha next message.
.ie n .IP "$obj\->\fBgetTransferEncHandlez\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBgetTransferEncHandlez\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->getTransferEncHandlez(TYPE)"
See \*(L"Internals\*(R" up in Mail::Message::Body::Encode
.ie n .IP "$obj\->\fBisModified\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisModified\fR()" 4
.IX Item "$obj->isModified()"
Returns whether tha body has chizzled.
.ie n .IP "$obj\->\fBload\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBload\fR()" 4
.IX Item "$obj->load()"
Be shizzle dat tha body is loaded. Y'all KNOW dat shit, muthafucka!  This returns tha loaded body.
.ie n .IP "$obj\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.IX Item "$obj->modified([BOOLEAN])"
Change tha body modification flag.  This will force a re-write of tha body
to a gangbangin' folda file when it is closed. Y'all KNOW dat shit, muthafucka!  It be like fucked up ta chizzle the
body: tha same body may be shared between lyrics within yo' program.
.Sp
Especially be warned dat you gotta chizzle tha message-id when you
change tha body of tha message: no two lyrics should have tha same id.
.Sp
Without value, tha current settin is returned, although you can betta use
\&\fIisModified()\fR.
.ie n .IP "$obj\->\fBmoveLocation\fR([\s-1DISTANCE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmoveLocation\fR([\s-1DISTANCE\s0])" 4
.IX Item "$obj->moveLocation([DISTANCE])"
Move tha registration of tha message ta a freshly smoked up location over \s-1DISTANCE. \s0 This
is called when tha message is freestyled ta a freshly smoked up version of tha same
folder-file.
.ie n .IP "$obj\->\fBread\fR(\s-1PARSER, HEAD, BODYTYPE\s0 [,CHARS [,LINES]])" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR(\s-1PARSER, HEAD, BODYTYPE\s0 [,CHARS [,LINES]])" 4
.IX Item "$obj->read(PARSER, HEAD, BODYTYPE [,CHARS [,LINES]])"
Read tha body wit tha \s-1PARSER\s0 from file. Da implementation of dis method
will differ between typez of bodies. Put ya muthafuckin choppers up if ya feel dis!  Da \s-1BODYTYPE\s0 argument be a cold-ass lil class name
or a cold-ass lil code reference of a routine which can produce a cold-ass lil class name, n' is
used up in multipart bodies ta determine tha type of tha body fo' each part.
.Sp
Da \s-1CHARS\s0 argument is tha estimated number of bytes up in tha body, or
\&\f(CW\*(C`undef\*(C'\fR when dis aint known. I aint talkin' bout chicken n' gravy biatch.  This data can sometimes be derived from
the header (the \f(CW\*(C`Content\-Length\*(C'\fR line) or file-size.
.Sp
Da second argument is tha estimated number of \s-1LINES\s0 of tha body.  It be less
useful than tha \s-1CHARS\s0 but may be of help determinin whether tha message
separator is trustworthy.  This value may be found up in tha \f(CW\*(C`Lines\*(C'\fR field
of tha header.
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
When a unknown method is called on a message body object, dis may
not be problematic.  For performizzle reasons, some methodz are
implemented up in separate files, n' only demand-loaded. Y'all KNOW dat shit, muthafucka!  If this
delayed compilation of additionizzle modulez do not help, a error
will be produced.
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Message::Body\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Message::Body->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Message::Body\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Message::Body->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Message::Body\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Message::Body->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Access ta tha body"
.IX Subsection "Access ta tha body"
A body can be contained up in a message yo, but may also live without a message.
In both cases it stores data, n' tha same thangs can be asked: what
type of data it is, how tha fuck nuff bytes n' lines, what tha fuck encodin is used. Y'all KNOW dat shit, muthafucka!  Any
body can be encoded n' decoded, returnin a freshly smoked up body object.  But fuck dat shiznit yo, tha word on tha street is dat 
bodies which is part of a message will always be up in a gangbangin' finger-lickin' dirty-ass shape dat they can
be freestyled ta a gangbangin' file or bust ta somewhere: they is ghon be encoded if needed.
.SS "Body class implementation"
.IX Subsection "Body class implementation"
Da body of a message can be stored up in nuff ways.  Roughly, the
implementations can be split up in two groups: tha data collectors and
the complex bodies. Put ya muthafuckin choppers up if ya feel dis! Da primer implement various ways ta access data,
and is full compatible: they only differ up in performizzle n' memory
footprint under different circumstances.  Da latta is pimped to
handle complex multiparts n' lazy extraction.
.PP
\fIData collector bodies\fR
.IX Subsection "Data collector bodies"
.IP "\(bu" 4
Mail::Message::Body::String
.Sp
Da whole message body is stored up in one scalar. Shiiit, dis aint no joke.  Lil Small-Ass lyrics can be
contained dis way without performizzle penalties.
.IP "\(bu" 4
Mail::Message::Body::Lines
.Sp
Each line of tha message body is stored as single scalar. Shiiit, dis aint no joke.  This be a
useful representation fo' a thugged-out detailed look up in tha message body, which is
usually line-organized.
.IP "\(bu" 4
Mail::Message::Body::File
.Sp
Da message body is stored up in a external temporary file.  This type of
storage is especially useful when tha body is large, tha total folda is
large, or memory is limited.
.IP "\(bu" 4
Mail::Message::Body::InFolder
.Sp
\&\s-1NOT IMPLEMENTED YET.\s0
Da message is kept up in tha folder, n' is only taken up when the
content is chizzled.
.IP "\(bu" 4
Mail::Message::Body::External
.Sp
\&\s-1NOT IMPLEMENTED YET.\s0
Da message is kept up in a separate file, probably cuz tha message body
is large.  Da difference wit tha \f(CW\*(C`::External\*(C'\fR object is dat dis external
storage stays dis way between closin n' openin of a gangbangin' folda n' shit. The
\&\f(CW\*(C`::External\*(C'\fR object only uses a gangbangin' file when tha folda is open.
.PP
\fIComplex bodies\fR
.IX Subsection "Complex bodies"
.IP "\(bu" 4
Mail::Message::Body::Delayed
.Sp
Da message-body aint yet read yo, but tha exact location of the
body is known so tha message can be read when needed. Y'all KNOW dat shit, muthafucka!  This is part of
the lazy extraction mechanism.  Once extracted, tha object can become
any simple or complex body.
.IP "\(bu" 4
Mail::Message::Body::Multipart
.Sp
Da message body gotz nuff a set of sub-lyrics (which can contain
multipart bodies theyselves).  Each sub-message be a instance
of Mail::Message::Part, which be a extension of Mail::Message.
.IP "\(bu" 4
Mail::Message::Body::Nested
.Sp
Nested lyrics, like \f(CW\*(C`message/rfc822\*(C'\fR: they contain a message in
the body.  For most code, they simply behave like multiparts.
.SS "Characta encodin \s-1PERL\s0"
.IX Subsection "Characta encodin PERL"
A body object can be part of a message, or stand-alone.  In case it
is a part of a message, tha \*(L"transhiznit encoding\*(R" n' tha content must
be up in a gangbangin' finger-lickin' dirty-ass shape dat tha data can be transported via \s-1SMTP.\s0
.PP
But fuck dat shiznit yo, tha word on tha street is dat when you wanna process tha body data up in simple Perl (or when
you construct tha body data from aiiight Perl strings), you need ta be
aware of Perlz internal representation of strings. That can either be
latin1 or utf8 (not real \s-1UTF\-8,\s0 but suttin' alike, peep tha perlunicode
manual page)  So, before you start rockin tha data from a incomin message,
do
.PP
.Vb 2
\&    mah $body  = $msg\->decoded;
\&    mah @lines = $body\->lines;
.Ve
.PP
Now, tha body has character-set '\s-1PERL\s0' (when it is text)
.PP
When you create a freshly smoked up body which gotz nuff text content (the default),
it is ghon be pimped wit character-set '\s-1PERL\s0' unless you specify a
character-set explicitly.
.PP
.Vb 2
\&   mah $body = Mail::Box::Body::Lines\->new(data => \e@lines);
\&   # now mime=text/plain, charset=PERL
\&
\&   mah $msg  = Mail::Message\->buildFromBody($body);
\&   $msg\->body($body);
\&   $msg\->attach($body);   # etc
\&   # these all will convert tha charset=PERL tha fuck into real utf\-8
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Warning: Charset $name aint known" 4
.el .IP "Warning: Charset \f(CW$name\fR aint known" 4
.IX Item "Warning: Charset $name aint known"
Da encodin or decodin of a message body encountas a cold-ass lil characta set which
is not understood by Perlz Encode module.
.ie n .IP "Warning: No decoder defined fo' transfer encodin $name." 4
.el .IP "Warning: No decoder defined fo' transfer encodin \f(CW$name\fR." 4
.IX Item "Warning: No decoder defined fo' transfer encodin $name."
Da data (message body) is encoded up in a way which aint currently understood,
therefore no decodin (or recoding) can take place.
.ie n .IP "Warning: No encoder defined fo' transfer encodin $name." 4
.el .IP "Warning: No encoder defined fo' transfer encodin \f(CW$name\fR." 4
.IX Item "Warning: No encoder defined fo' transfer encodin $name."
Da data (message body) has been decoded yo, but tha required encodin is
unknown. I aint talkin' bout chicken n' gravy biatch.  Da decoded data is returned.
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.ie n .IP "Warning: Unknown line terminator $eol ignored" 4
.el .IP "Warning: Unknown line terminator \f(CW$eol\fR ignored" 4
.IX Item "Warning: Unknown line terminator $eol ignored"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
