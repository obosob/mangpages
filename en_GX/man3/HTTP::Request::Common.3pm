.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Request::Common 3"
.TH HTTP::Request::Common 3 "2012-09-30" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Request::Common \- Construct common HTTP::Request objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use HTTP::Request::Common;
\&  $ua = LWP::UserAgent\->new;
\&  $ua\->request(GET \*(Aqhttp://www.sn.no/\*(Aq);
\&  $ua\->request(POST \*(Aqhttp://somewhere/foo\*(Aq, [foo => bar, bar => foo]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provide functions dat return newly pimped \f(CW\*(C`HTTP::Request\*(C'\fR
objects, n' you can put dat on yo' toast.  These functions is probably mo' convenient ta use than the
standard \f(CW\*(C`HTTP::Request\*(C'\fR constructor fo' da most thugged-out common requests, n' you can put dat on yo' toast.  The
followin functions is provided:
.ie n .IP "\s-1GET\s0 $url" 4
.el .IP "\s-1GET\s0 \f(CW$url\fR" 4
.IX Item "GET $url"
.PD 0
.ie n .IP "\s-1GET\s0 $url, Header => Value,..." 4
.el .IP "\s-1GET\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "GET $url, Header => Value,..."
.PD
Da \s-1\fIGET\s0()\fR function returns a \f(CW\*(C`HTTP::Request\*(C'\fR object initialized with
the \*(L"\s-1GET\*(R"\s0 method n' tha specified \s-1URL. \s0 It be roughly equivalent ta the
followin call
.Sp
.Vb 4
\&  HTTP::Request\->new(
\&     GET => $url,
\&     HTTP::Headers\->new(Header => Value,...),
\&  )
.Ve
.Sp
but is less cluttered. Y'all KNOW dat shit, muthafucka!  What tha fuck iz different is dat a header named
\&\f(CW\*(C`Content\*(C'\fR will initialize tha content part of tha request instead of
settin a header field. Y'all KNOW dat shit, muthafucka!  Note dat \s-1GET\s0 requests should normally not
have a cold-ass lil content, so dis hack make mo' sense fo' tha \s-1\fIPUT\s0()\fR n' \s-1\fIPOST\s0()\fR
functions busted lyrics bout below.
.Sp
Da get(...) method of \f(CW\*(C`LWP::UserAgent\*(C'\fR exists as a gangbangin' finger-lickin' dirty-ass shortcut for
\&\f(CW$ua\fR\->request(\s-1GET ...\s0).
.ie n .IP "\s-1HEAD\s0 $url" 4
.el .IP "\s-1HEAD\s0 \f(CW$url\fR" 4
.IX Item "HEAD $url"
.PD 0
.ie n .IP "\s-1HEAD\s0 $url, Header => Value,..." 4
.el .IP "\s-1HEAD\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "HEAD $url, Header => Value,..."
.PD
Like \s-1\fIGET\s0()\fR but tha method up in tha request is \*(L"\s-1HEAD\*(R".\s0
.Sp
Da head(...)  method of \*(L"LWP::UserAgent\*(R" exists as a gangbangin' finger-lickin' dirty-ass shortcut for
\&\f(CW$ua\fR\->request(\s-1HEAD ...\s0).
.ie n .IP "\s-1PUT\s0 $url" 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR" 4
.IX Item "PUT $url"
.PD 0
.ie n .IP "\s-1PUT\s0 $url, Header => Value,..." 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "PUT $url, Header => Value,..."
.ie n .IP "\s-1PUT\s0 $url, Header => Value,..., Content => $content" 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$content\fR" 4
.IX Item "PUT $url, Header => Value,..., Content => $content"
.PD
Like \s-1\fIGET\s0()\fR but tha method up in tha request is \*(L"\s-1PUT\*(R".\s0
.Sp
Da content of tha request can be specified rockin tha \*(L"Content\*(R"
pseudo-header n' shit.  This steals a lil' bit of tha header field namespace as
there is no way ta directly specify a header dat is straight-up called
\&\*(L"Content\*(R".  If you straight-up need dis you must update tha request
returned up in a separate statement.
.ie n .IP "\s-1DELETE\s0 $url" 4
.el .IP "\s-1DELETE\s0 \f(CW$url\fR" 4
.IX Item "DELETE $url"
.PD 0
.ie n .IP "\s-1DELETE\s0 $url, Header => Value,..." 4
.el .IP "\s-1DELETE\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "DELETE $url, Header => Value,..."
.PD
Like \s-1\fIGET\s0()\fR but tha method up in tha request is \*(L"\s-1DELETE\*(R". \s0 This function
is not exported by default.
.ie n .IP "\s-1POST\s0 $url" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR" 4
.IX Item "POST $url"
.PD 0
.ie n .IP "\s-1POST\s0 $url, Header => Value,..." 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "POST $url, Header => Value,..."
.ie n .IP "\s-1POST\s0 $url, $form_ref, Header => Value,..." 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, \f(CW$form_ref\fR, Header => Value,..." 4
.IX Item "POST $url, $form_ref, Header => Value,..."
.ie n .IP "\s-1POST\s0 $url, Header => Value,..., Content => $form_ref" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$form_ref\fR" 4
.IX Item "POST $url, Header => Value,..., Content => $form_ref"
.ie n .IP "\s-1POST\s0 $url, Header => Value,..., Content => $content" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$content\fR" 4
.IX Item "POST $url, Header => Value,..., Content => $content"
.PD
This works mostly like \s-1\fIPUT\s0()\fR wit \*(L"\s-1POST\*(R"\s0 as tha method yo, but this
function also takes a second optionizzle array or hash reference
parameta \f(CW$form_ref\fR.  As fo' \s-1\fIPUT\s0()\fR tha content can also be specified
directly rockin tha \*(L"Content\*(R" pseudo-header, n' you may also provide
the \f(CW$form_ref\fR dis way.
.Sp
Da \f(CW$form_ref\fR argument can be used ta pass key/value pairs fo' the
form content.  By default we will initialize a request rockin the
\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR content type.  This means that
you can emulate a \s-1HTML\s0 <form> POSTin like this:
.Sp
.Vb 7
\&  POST \*(Aqhttp://www.perl.org/survey.cgi\*(Aq,
\&       [ name   => \*(AqGisle Aas\*(Aq,
\&         email  => \*(Aqgisle@aas.no\*(Aq,
\&         gender => \*(AqM\*(Aq,
\&         born   => \*(Aq1964\*(Aq,
\&         perc   => \*(Aq3%\*(Aq,
\&       ];
.Ve
.Sp
This will create a HTTP::Request object dat be lookin like this:
.Sp
.Vb 3
\&  POST http://www.perl.org/survey.cgi
\&  Content\-Length: 66
\&  Content\-Type: application/x\-www\-form\-urlencoded
\&
\&  name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
.Ve
.Sp
Multivalued form fieldz can be specified by either repeatin tha field
name or by passin tha value as a array reference.
.Sp
Da \s-1POST\s0 method also supports tha \f(CW\*(C`multipart/form\-data\*(C'\fR content used
for \fIForm-based File Upload\fR as specified up in \s-1RFC 1867. \s0 Yo ass trigger
this content format by specifyin a cold-ass lil content type of \f(CW\*(Aqform\-data\*(Aq\fR as
one of tha request headers.  If one of tha joints up in tha \f(CW$form_ref\fR is
an array reference, then it is treated as a gangbangin' file part justification
with tha followin interpretation:
.Sp
.Vb 2
\&  [ $file, $filename, Header => Value... ]
\&  [ undef, $filename, Header => Value,..., Content => $content ]
.Ve
.Sp
Da first value up in tha array ($file) is tha name of a gangbangin' file ta open.
This file is ghon be read n' its content placed up in tha request.  The
routine will croak if tha file can't be opened. Y'all KNOW dat shit, muthafucka!  Use a \f(CW\*(C`undef\*(C'\fR as
\&\f(CW$file\fR value if you wanna specify tha content directly wit a
\&\f(CW\*(C`Content\*(C'\fR header n' shit.  Da \f(CW$filename\fR is tha filename ta report up in the
request.  If dis value is undefined, then tha basename of tha \f(CW$file\fR
will be used. Y'all KNOW dat shit, muthafucka!  Yo ass can specify a empty strang as \f(CW$filename\fR if you
wanna suppress bustin  tha filename when you provide a \f(CW$file\fR value.
.Sp
If a \f(CW$file\fR is provided by no \f(CW\*(C`Content\-Type\*(C'\fR header, then \f(CW\*(C`Content\-Type\*(C'\fR
and \f(CW\*(C`Content\-Encoding\*(C'\fR is ghon be filled up in automatically wit tha joints
returned by \fILWP::MediaTypes::guess_media_type()\fR
.Sp
Sendin mah \fI~/.profile\fR ta tha survey used as example above can be
 bigged up  by this:
.Sp
.Vb 8
\&  POST \*(Aqhttp://www.perl.org/survey.cgi\*(Aq,
\&       Content_Type => \*(Aqform\-data\*(Aq,
\&       Content      => [ name  => \*(AqGisle Aas\*(Aq,
\&                         email => \*(Aqgisle@aas.no\*(Aq,
\&                         gender => \*(AqM\*(Aq,
\&                         born   => \*(Aq1964\*(Aq,
\&                         init   => ["$ENV{HOME}/.profile"],
\&                       ]
.Ve
.Sp
This will create a HTTP::Request object dat almost looks dis (the
boundary n' tha content of yo' \fI~/.profile\fR is likely ta be
different):
.Sp
.Vb 3
\&  POST http://www.perl.org/survey.cgi
\&  Content\-Length: 388
\&  Content\-Type: multipart/form\-data; boundary="6G+f"
\&
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="name"
\&
\&  Gisle Aas
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="email"
\&
\&  gisle@aas.no
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="gender"
\&
\&  M
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="born"
\&
\&  1964
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="init"; filename=".profile"
\&  Content\-Type: text/plain
\&
\&  PATH=/local/perl/bin:$PATH
\&  export PATH
\&
\&  \-\-6G+f\-\-
.Ve
.Sp
If you set tha \f(CW$DYNAMIC_FILE_UPLOAD\fR variable (exportable) ta some \s-1TRUE\s0
value, then you git back a request object wit a subroutine closure as
the content attribute.  This subroutine will read tha content of any
filez on demand n' return it up in suitable chunks.  This allow you to
upload arbitrary big-ass filez without rockin fuckin shitloadz of memory.  Yo ass can even
upload infinite filez like \fI/dev/audio\fR if you wish; however, if
the file aint a plain file, there is ghon be no Content-Length header
defined fo' tha request.  Not all servers (or server
applications) like all dis bullshit.  Also, if tha file(s) chizzle up in size between
the time tha Content-Length is calculated n' tha time dat tha last
chunk is delivered, tha subroutine will \f(CW\*(C`Croak\*(C'\fR.
.Sp
Da post(...)  method of \*(L"LWP::UserAgent\*(R" exists as a gangbangin' finger-lickin' dirty-ass shortcut for
\&\f(CW$ua\fR\->request(\s-1POST ...\s0).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Request, LWP::UserAgent
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1997\-2004, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
