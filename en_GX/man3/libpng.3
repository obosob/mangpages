.TH LIBPNG 3 "September 16, 2013"
.SH NAME
libpng \- Portable Network Graphics (PNG) Reference Library 1.6.6
.SH SYNOPSIS
\fB
#include <png.h>\fP

\fBpng_uint_32 png_access_version_number \fI(void\fP\fB);\fP

\fBvoid png_benign_error (png_structp \fP\fIpng_ptr\fP\fB, png_const_charp \fIerror\fP\fB);\fP

\fBvoid png_build_grayscale_palette (int \fP\fIbit_depth\fP\fB, png_colorp \fIpalette\fP\fB);\fP

\fBpng_voidp png_calloc (png_structp \fP\fIpng_ptr\fP\fB, png_alloc_size_t \fIsize\fP\fB);\fP

\fBvoid png_chunk_benign_error (png_structp \fP\fIpng_ptr\fP\fB, png_const_charp \fIerror\fP\fB);\fP

\fBvoid png_chunk_error (png_structp \fP\fIpng_ptr\fP\fB, png_const_charp \fIerror\fP\fB);\fP

\fBvoid png_chunk_warnin (png_structp \fP\fIpng_ptr\fP\fB, png_const_charp \fImessage\fP\fB);\fP

\fBvoid png_convert_from_struct_tm (png_timep \fP\fIptime\fP\fB, struct tm FAR * \fIttime\fP\fB);\fP

\fBvoid png_convert_from_time_t (png_timep \fP\fIptime\fP\fB, time_t \fIttime\fP\fB);\fP

\fBpng_charp png_convert_to_rfc1123 (png_structp \fP\fIpng_ptr\fP\fB, png_timep \fIptime\fP\fB);\fP

\fBpng_infop png_create_info_struct (png_structp \fIpng_ptr\fP\fB);\fP

\fBpng_structp png_create_read_struct (png_const_charp \fP\fIuser_png_ver\fP\fB, png_voidp \fP\fIerror_ptr\fP\fB, png_error_ptr \fP\fIerror_fn\fP\fB, png_error_ptr \fIwarn_fn\fP\fB);\fP

\fBpng_structp png_create_read_struct_2 (png_const_charp \fP\fIuser_png_ver\fP\fB, png_voidp \fP\fIerror_ptr\fP\fB, png_error_ptr \fP\fIerror_fn\fP\fB, png_error_ptr \fP\fIwarn_fn\fP\fB, png_voidp \fP\fImem_ptr\fP\fB, png_malloc_ptr \fP\fImalloc_fn\fP\fB, png_free_ptr \fIfree_fn\fP\fB);\fP

\fBpng_structp png_create_write_struct (png_const_charp \fP\fIuser_png_ver\fP\fB, png_voidp \fP\fIerror_ptr\fP\fB, png_error_ptr \fP\fIerror_fn\fP\fB, png_error_ptr \fIwarn_fn\fP\fB);\fP

\fBpng_structp png_create_write_struct_2 (png_const_charp \fP\fIuser_png_ver\fP\fB, png_voidp \fP\fIerror_ptr\fP\fB, png_error_ptr \fP\fIerror_fn\fP\fB, png_error_ptr \fP\fIwarn_fn\fP\fB, png_voidp \fP\fImem_ptr\fP\fB, png_malloc_ptr \fP\fImalloc_fn\fP\fB, png_free_ptr \fIfree_fn\fP\fB);\fP

\fBvoid png_data_freer (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fIfreer\fP\fB, png_uint_32 \fImask)\fP\fB);\fP

\fBvoid png_destroy_info_struct (png_structp \fP\fIpng_ptr\fP\fB, png_infopp \fIinfo_ptr_ptr\fP\fB);\fP

\fBvoid png_destroy_read_struct (png_structpp \fP\fIpng_ptr_ptr\fP\fB, png_infopp \fP\fIinfo_ptr_ptr\fP\fB, png_infopp \fIend_info_ptr_ptr\fP\fB);\fP

\fBvoid png_destroy_write_struct (png_structpp \fP\fIpng_ptr_ptr\fP\fB, png_infopp \fIinfo_ptr_ptr\fP\fB);\fP

\fBvoid png_err (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_error (png_structp \fP\fIpng_ptr\fP\fB, png_const_charp \fIerror\fP\fB);\fP

\fBvoid png_free (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fIptr\fP\fB);\fP

\fBvoid png_free_chunk_list (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_free_default (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fIptr\fP\fB);\fP

\fBvoid png_free_data (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fInum\fP\fB);\fP

\fBpng_byte png_get_bit_depth (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_bKGD (png_const_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_color_16p \fI*background\fP\fB);\fP

\fBpng_byte png_get_channels (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_cHRM (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, double \fP\fI*white_x\fP\fB, double \fP\fI*white_y\fP\fB, double \fP\fI*red_x\fP\fB, double \fP\fI*red_y\fP\fB, double \fP\fI*green_x\fP\fB, double \fP\fI*green_y\fP\fB, double \fP\fI*blue_x\fP\fB, double \fI*blue_y\fP\fB);\fP

\fBpng_uint_32 png_get_cHRM_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*white_x\fP\fB, png_uint_32 \fP\fI*white_y\fP\fB, png_uint_32 \fP\fI*red_x\fP\fB, png_uint_32 \fP\fI*red_y\fP\fB, png_uint_32 \fP\fI*green_x\fP\fB, png_uint_32 \fP\fI*green_y\fP\fB, png_uint_32 \fP\fI*blue_x\fP\fB, png_uint_32 \fI*blue_y\fP\fB);\fP

\fBpng_uint_32 png_get_cHRM_XYZ (png_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, double \fP\fI*red_X\fP\fB, double \fP\fI*red_Y\fP\fB, double \fP\fI*red_Z\fP\fB, double \fP\fI*green_X\fP\fB, double \fP\fI*green_Y\fP\fB, double \fP\fI*green_Z\fP\fB, double \fP\fI*blue_X\fP\fB, double \fP\fI*blue_Y\fP\fB, double \fI*blue_Z\fP\fB);\fP

\fBpng_uint_32 png_get_cHRM_XYZ_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_fixed_point \fP\fI*int_red_X\fP\fB, png_fixed_point \fP\fI*int_red_Y\fP\fB, png_fixed_point \fP\fI*int_red_Z\fP\fB, png_fixed_point \fP\fI*int_green_X\fP\fB, png_fixed_point \fP\fI*int_green_Y\fP\fB, png_fixed_point \fP\fI*int_green_Z\fP\fB, png_fixed_point \fP\fI*int_blue_X\fP\fB, png_fixed_point \fP\fI*int_blue_Y\fP\fB, png_fixed_point \fI*int_blue_Z\fP\fB);\fP

\fBpng_uint_32 png_get_chunk_cache_max (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_alloc_size_t png_get_chunk_malloc_max (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_byte png_get_color_type (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_compression_buffer_size (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_byte png_get_compression_type (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_byte png_get_copyright (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_current_row_number \fI(png_const_structp\fP\fB);\fP

\fBpng_byte png_get_current_pass_number \fI(png_const_structp\fP\fB);\fP

\fBpng_voidp png_get_error_ptr (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_byte png_get_filter_type (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_gAMA (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, double \fI*file_gamma\fP\fB);\fP

\fBpng_uint_32 png_get_gAMA_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fI*int_file_gamma\fP\fB);\fP

\fBpng_byte png_get_header_ver (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_byte png_get_header_version (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_hIST (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_16p \fI*hist\fP\fB);\fP

\fBpng_uint_32 png_get_iCCP (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_charpp \fP\fIname\fP\fB, int \fP\fI*compression_type\fP\fB, png_bytepp \fP\fIprofile\fP\fB, png_uint_32 \fI*proflen\fP\fB);\fP

\fBpng_uint_32 png_get_IHDR (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*width\fP\fB, png_uint_32 \fP\fI*height\fP\fB, int \fP\fI*bit_depth\fP\fB, int \fP\fI*color_type\fP\fB, int \fP\fI*interlace_type\fP\fB, int \fP\fI*compression_type\fP\fB, int \fI*filter_type\fP\fB);\fP

\fBpng_uint_32 png_get_image_height (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_image_width (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_int_32 png_get_int_32 (png_bytep \fIbuf\fP\fB);\fP

\fBpng_byte png_get_interlace_type (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_io_chunk_type (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_voidp png_get_io_ptr (png_structp \fIpng_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_io_state (png_structp \fIpng_ptr\fP\fB);\fP

\fBpng_byte png_get_libpng_ver (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_voidp png_get_mem_ptr (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_oFFs (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*offset_x\fP\fB, png_uint_32 \fP\fI*offset_y\fP\fB, int \fI*unit_type\fP\fB);\fP

\fBpng_uint_32 png_get_pCAL (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_charp \fP\fI*purpose\fP\fB, png_int_32 \fP\fI*X0\fP\fB, png_int_32 \fP\fI*X1\fP\fB, int \fP\fI*type\fP\fB, int \fP\fI*nparams\fP\fB, png_charp \fP\fI*units\fP\fB, png_charpp \fI*params\fP\fB);\fP

\fBpng_uint_32 png_get_pHYs (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*res_x\fP\fB, png_uint_32 \fP\fI*res_y\fP\fB, int \fI*unit_type\fP\fB);\fP

\fBfloat png_get_pixel_aspect_ratio (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_pHYs_dpi (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*res_x\fP\fB, png_uint_32 \fP\fI*res_y\fP\fB, int \fI*unit_type\fP\fB);\fP

\fBpng_fixed_point png_get_pixel_aspect_ratio_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_pixels_per_inch (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_pixels_per_meta (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_voidp png_get_progressive_ptr (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_PLTE (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_colorp \fP\fI*palette\fP\fB, int \fI*num_palette\fP\fB);\fP

\fBpng_byte png_get_rgb_to_gray_status (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_rowbytes (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_bytepp png_get_rows (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_sBIT (png_const_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_color_8p \fI*sig_bit\fP\fB);\fP

\fBvoid png_get_sCAL (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, int* \fP\fIunit\fP\fB, double* \fP\fIwidth\fP\fB, double* \fIheight\fP\fB);\fP

\fBvoid png_get_sCAL_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, int* \fP\fIunit\fP\fB, png_fixed_pointp \fP\fIwidth\fP\fB, png_fixed_pointp \fIheight\fP\fB);\fP

\fBvoid png_get_sCAL_s (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, int* \fP\fIunit\fP\fB, png_charpp \fP\fIwidth\fP\fB, png_charpp \fIheight\fP\fB);\fP

\fBpng_bytep png_get_signature (png_const_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_sPLT (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_spalette_p \fI*splt_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_sRGB (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, int \fI*file_srgb_intent\fP\fB);\fP

\fBpng_uint_32 png_get_text (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_textp \fP\fI*text_ptr\fP\fB, int \fI*num_text\fP\fB);\fP

\fBpng_uint_32 png_get_tIME (png_const_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_timep \fI*mod_time\fP\fB);\fP

\fBpng_uint_32 png_get_tRNS (png_const_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_bytep \fP\fI*trans_alpha\fP\fB, int \fP\fI*num_trans\fP\fB, png_color_16p \fI*trans_color\fP\fB);\fP

\fB/* This function is straight-up a inline macro. \fI*/

\fBpng_uint_16 png_get_uint_16 (png_bytep \fIbuf\fP\fB);\fP

\fBpng_uint_32 png_get_uint_31 (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fIbuf\fP\fB);\fP

\fB/* This function is straight-up a inline macro. \fI*/

\fBpng_uint_32 png_get_uint_32 (png_bytep \fIbuf\fP\fB);\fP

\fBpng_uint_32 png_get_unknown_chunks (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_unknown_chunkpp \fIunknowns\fP\fB);\fP

\fBpng_voidp png_get_user_chunk_ptr (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_user_height_max (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_voidp png_get_user_transform_ptr (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_user_width_max (png_const_structp \fIpng_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_valid (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fIflag\fP\fB);\fP

\fBfloat png_get_x_offset_inches (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_fixed_point png_get_x_offset_inches_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_int_32 png_get_x_offset_microns (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_int_32 png_get_x_offset_pixels (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_x_pixels_per_inch (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_x_pixels_per_meta (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBfloat png_get_y_offset_inches (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_fixed_point png_get_y_offset_inches_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_int_32 png_get_y_offset_microns (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_int_32 png_get_y_offset_pixels (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_y_pixels_per_inch (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBpng_uint_32 png_get_y_pixels_per_meta (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP

\fBint png_handle_as_unknown (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fIchunk_name\fP\fB);\fP

\fBint png_image_begin_read_from_file (png_imagep \fP\fIimage\fP\fB, const char \fI*file_name\fP\fB);\fP

\fBint png_image_begin_read_from_stdio (png_imagep \fP\fIimage\fP\fB, FILE* \fIfile\fP\fB);\fP

\fBint, png_image_begin_read_from_memory (png_imagep \fP\fIimage\fP\fB, png_const_voidp \fP\fImemory\fP\fB, png_size_t \fIsize\fP\fB);\fP

\fBint png_image_finish_read (png_imagep \fP\fIimage\fP\fB, png_colorp \fP\fIbackground\fP\fB, void \fP\fI*buffer\fP\fB, png_int_32 \fP\fIrow_stride\fP\fB, void \fI*colormap\fP\fB);\fP

\fBvoid png_image_free (png_imagep \fIimage\fP\fB);\fP

\fBint png_image_write_to_file (png_imagep \fP\fIimage\fP\fB, const char \fP\fI*file\fP\fB, int \fP\fIconvert_to_8bit\fP\fB, const void \fP\fI*buffer\fP\fB, png_int_32 \fP\fIrow_stride\fP\fB, void \fI*colormap\fP\fB);\fP

\fBint png_image_write_to_stdio (png_imagep \fP\fIimage\fP\fB, FILE \fP\fI*file\fP\fB, int \fP\fIconvert_to_8_bit\fP\fB, const void \fP\fI*buffer\fP\fB, png_int_32 \fP\fIrow_stride\fP\fB, void \fI*colormap)\fP\fB);\fP

\fBvoid png_info_init_3 (png_infopp \fP\fIinfo_ptr\fP\fB, png_size_t \fIpng_info_struct_size\fP\fB);\fP

\fBvoid png_init_io (png_structp \fP\fIpng_ptr\fP\fB, FILE \fI*fp\fP\fB);\fP

\fBvoid png_longjmp (png_structp \fP\fIpng_ptr\fP\fB, int \fIval\fP\fB);\fP

\fBpng_voidp png_malloc (png_structp \fP\fIpng_ptr\fP\fB, png_alloc_size_t \fIsize\fP\fB);\fP

\fBpng_voidp png_malloc_default (png_structp \fP\fIpng_ptr\fP\fB, png_alloc_size_t \fIsize\fP\fB);\fP

\fBpng_voidp png_malloc_warn (png_structp \fP\fIpng_ptr\fP\fB, png_alloc_size_t \fIsize\fP\fB);\fP

\fBpng_uint_32 png_permit_mng_features (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fImng_features_permitted\fP\fB);\fP

\fBvoid png_process_data (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_bytep \fP\fIbuffer\fP\fB, png_size_t \fIbuffer_size\fP\fB);\fP

\fBpng_size_t png_process_data_pause \fP\fI(png_structp\fP\fB, int \fIsave\fP\fB);\fP

\fBpng_uint_32 png_process_data_skip \fI(png_structp\fP\fB);\fP

\fBvoid png_progressive_combine_row (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fP\fIold_row\fP\fB, png_bytep \fInew_row\fP\fB);\fP

\fBvoid png_read_end (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP

\fBvoid png_read_image (png_structp \fP\fIpng_ptr\fP\fB, png_bytepp \fIimage\fP\fB);\fP

\fBvoid png_read_info (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP

\fBvoid png_read_png (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fItransforms\fP\fB, png_voidp \fIparams\fP\fB);\fP

\fBvoid png_read_row (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fP\fIrow\fP\fB, png_bytep \fIdisplay_row\fP\fB);\fP

\fBvoid png_read_rows (png_structp \fP\fIpng_ptr\fP\fB, png_bytepp \fP\fIrow\fP\fB, png_bytepp \fP\fIdisplay_row\fP\fB, png_uint_32 \fInum_rows\fP\fB);\fP

\fBvoid png_read_update_info (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP

\fBint png_reset_zstream (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_save_int_32 (png_bytep \fP\fIbuf\fP\fB, png_int_32 \fIi\fP\fB);\fP

\fBvoid png_save_uint_16 (png_bytep \fP\fIbuf\fP\fB, unsigned int \fIi\fP\fB);\fP

\fBvoid png_save_uint_32 (png_bytep \fP\fIbuf\fP\fB, png_uint_32 \fIi\fP\fB);\fP

\fBvoid png_set_add_alpha (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fP\fIfiller\fP\fB, int \fIflags\fP\fB);\fP

\fBvoid png_set_alpha_mode (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fImode\fP\fB, double \fIoutput_gamma\fP\fB);\fP

\fBvoid png_set_alpha_mode_fixed (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fImode\fP\fB, png_fixed_point \fIoutput_gamma\fP\fB);\fP

\fBvoid png_set_background (png_structp \fP\fIpng_ptr\fP\fB, png_color_16p \fP\fIbackground_color\fP\fB, int \fP\fIbackground_gamma_code\fP\fB, int \fP\fIneed_expand\fP\fB, double \fIbackground_gamma\fP\fB);\fP

\fBvoid png_set_background_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_color_16p \fP\fIbackground_color\fP\fB, int \fP\fIbackground_gamma_code\fP\fB, int \fP\fIneed_expand\fP\fB, png_uint_32 \fIbackground_gamma\fP\fB);\fP

\fBvoid png_set_benign_errors (png_structp \fP\fIpng_ptr\fP\fB, int \fIallowed\fP\fB);\fP

\fBvoid png_set_bgr (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_bKGD (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_color_16p \fIbackground\fP\fB);\fP

\fBvoid png_set_check_for_invalid_index(png_structrp \fP\fIpng_ptr\fP\fB, int \fIallowed\fP\fB);\fP

\fBvoid png_set_cHRM (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, double \fP\fIwhite_x\fP\fB, double \fP\fIwhite_y\fP\fB, double \fP\fIred_x\fP\fB, double \fP\fIred_y\fP\fB, double \fP\fIgreen_x\fP\fB, double \fP\fIgreen_y\fP\fB, double \fP\fIblue_x\fP\fB, double \fIblue_y\fP\fB);\fP

\fBvoid png_set_cHRM_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIwhite_x\fP\fB, png_uint_32 \fP\fIwhite_y\fP\fB, png_uint_32 \fP\fIred_x\fP\fB, png_uint_32 \fP\fIred_y\fP\fB, png_uint_32 \fP\fIgreen_x\fP\fB, png_uint_32 \fP\fIgreen_y\fP\fB, png_uint_32 \fP\fIblue_x\fP\fB, png_uint_32 \fIblue_y\fP\fB);\fP

\fBvoid png_set_cHRM_XYZ (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, double \fP\fIred_X\fP\fB, double \fP\fIred_Y\fP\fB, double \fP\fIred_Z\fP\fB, double \fP\fIgreen_X\fP\fB, double \fP\fIgreen_Y\fP\fB, double \fP\fIgreen_Z\fP\fB, double \fP\fIblue_X\fP\fB, double \fP\fIblue_Y\fP\fB, double \fIblue_Z\fP\fB);\fP

\fBvoid png_set_cHRM_XYZ_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_fixed_point \fP\fIint_red_X\fP\fB, png_fixed_point \fP\fIint_red_Y\fP\fB, png_fixed_point \fP\fIint_red_Z\fP\fB, png_fixed_point \fP\fIint_green_X\fP\fB, png_fixed_point \fP\fIint_green_Y\fP\fB, png_fixed_point \fP\fIint_green_Z\fP\fB, png_fixed_point \fP\fIint_blue_X\fP\fB, png_fixed_point \fP\fIint_blue_Y\fP\fB, png_fixed_point \fIint_blue_Z\fP\fB);\fP

\fBvoid png_set_chunk_cache_max (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fIuser_chunk_cache_max\fP\fB);\fP

\fBvoid png_set_compression_level (png_structp \fP\fIpng_ptr\fP\fB, int \fIlevel\fP\fB);\fP

\fBvoid png_set_compression_mem_level (png_structp \fP\fIpng_ptr\fP\fB, int \fImem_level\fP\fB);\fP

\fBvoid png_set_compression_method (png_structp \fP\fIpng_ptr\fP\fB, int \fImethod\fP\fB);\fP

\fBvoid png_set_compression_strategy (png_structp \fP\fIpng_ptr\fP\fB, int \fIstrategy\fP\fB);\fP

\fBvoid png_set_compression_window_bits (png_structp \fP\fIpng_ptr\fP\fB, int \fIwindow_bits\fP\fB);\fP

\fBvoid png_set_crc_action (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fIcrit_action\fP\fB, int \fIancil_action\fP\fB);\fP

\fBvoid png_set_error_fn (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fIerror_ptr\fP\fB, png_error_ptr \fP\fIerror_fn\fP\fB, png_error_ptr \fIwarning_fn\fP\fB);\fP

\fBvoid png_set_expand (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_expand_16 (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_expand_gray_1_2_4_to_8 (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_filla (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fP\fIfiller\fP\fB, int \fIflags\fP\fB);\fP

\fBvoid png_set_filta (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fImethod\fP\fB, int \fIfilters\fP\fB);\fP

\fBvoid png_set_filter_heuristics (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fIheuristic_method\fP\fB, int \fP\fInum_weights\fP\fB, png_doublep \fP\fIfilter_weights\fP\fB, png_doublep \fIfilter_costs\fP\fB);\fP

\fBvoid png_set_filter_heuristics_fixed (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fIheuristic_method\fP\fB, int \fP\fInum_weights\fP\fB, png_fixed_point_p \fP\fIfilter_weights\fP\fB, png_fixed_point_p \fIfilter_costs\fP\fB);\fP

\fBvoid png_set_flush (png_structp \fP\fIpng_ptr\fP\fB, int \fInrows\fP\fB);\fP

\fBvoid png_set_gamma (png_structp \fP\fIpng_ptr\fP\fB, double \fP\fIscreen_gamma\fP\fB, double \fIdefault_file_gamma\fP\fB);\fP

\fBvoid png_set_gamma_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fP\fIscreen_gamma\fP\fB, png_uint_32 \fIdefault_file_gamma\fP\fB);\fP

\fBvoid png_set_gAMA (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, double \fIfile_gamma\fP\fB);\fP

\fBvoid png_set_gAMA_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fIfile_gamma\fP\fB);\fP

\fBvoid png_set_gray_1_2_4_to_8 (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_gray_to_rgb (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_hIST (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_16p \fIhist\fP\fB);\fP

\fBvoid png_set_iCCP (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_const_charp \fP\fIname\fP\fB, int \fP\fIcompression_type\fP\fB, png_const_bytep \fP\fIprofile\fP\fB, png_uint_32 \fIproflen\fP\fB);\fP

\fBint png_set_interlace_handlin (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_invalid (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fImask\fP\fB);\fP

\fBvoid png_set_invert_alpha (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_invert_mono (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_IHDR (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIwidth\fP\fB, png_uint_32 \fP\fIheight\fP\fB, int \fP\fIbit_depth\fP\fB, int \fP\fIcolor_type\fP\fB, int \fP\fIinterlace_type\fP\fB, int \fP\fIcompression_type\fP\fB, int \fIfilter_type\fP\fB);\fP

\fBvoid png_set_keep_unknown_chunks (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fIkeep\fP\fB, png_bytep \fP\fIchunk_list\fP\fB, int \fInum_chunks\fP\fB);\fP

\fBjmp_buf* png_set_longjmp_fn (png_structp \fP\fIpng_ptr\fP\fB, png_longjmp_ptr \fP\fIlongjmp_fn\fP\fB, size_t \fIjmp_buf_size\fP\fB);\fP

\fBvoid png_set_chunk_malloc_max (png_structp \fP\fIpng_ptr\fP\fB, png_alloc_size_t \fIuser_chunk_cache_max\fP\fB);\fP

\fBvoid png_set_compression_buffer_size (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fIsize\fP\fB);\fP

\fBvoid png_set_mem_fn (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fImem_ptr\fP\fB, png_malloc_ptr \fP\fImalloc_fn\fP\fB, png_free_ptr \fIfree_fn\fP\fB);\fP

\fBvoid png_set_oFFs (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIoffset_x\fP\fB, png_uint_32 \fP\fIoffset_y\fP\fB, int \fIunit_type\fP\fB);\fP

\fBvoid png_set_packin (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_packswap (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_palette_to_rgb (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_pCAL (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_charp \fP\fIpurpose\fP\fB, png_int_32 \fP\fIX0\fP\fB, png_int_32 \fP\fIX1\fP\fB, int \fP\fItype\fP\fB, int \fP\fInparams\fP\fB, png_charp \fP\fIunits\fP\fB, png_charpp \fIparams\fP\fB);\fP

\fBvoid png_set_pHYs (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIres_x\fP\fB, png_uint_32 \fP\fIres_y\fP\fB, int \fIunit_type\fP\fB);\fP

\fBvoid png_set_progressive_read_fn (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fIprogressive_ptr\fP\fB, png_progressive_info_ptr \fP\fIinfo_fn\fP\fB, png_progressive_row_ptr \fP\fIrow_fn\fP\fB, png_progressive_end_ptr \fIend_fn\fP\fB);\fP

\fBvoid png_set_PLTE (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_colorp \fP\fIpalette\fP\fB, int \fInum_palette\fP\fB);\fP

\fBvoid png_set_quantize (png_structp \fP\fIpng_ptr\fP\fB, png_colorp \fP\fIpalette\fP\fB, int \fP\fInum_palette\fP\fB, int \fP\fImaximum_colors\fP\fB, png_uint_16p \fP\fIhistogram\fP\fB, int \fIfull_quantize\fP\fB);\fP

\fBvoid png_set_read_fn (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fIio_ptr\fP\fB, png_rw_ptr \fIread_data_fn\fP\fB);\fP

\fBvoid png_set_read_status_fn (png_structp \fP\fIpng_ptr\fP\fB, png_read_status_ptr \fIread_row_fn\fP\fB);\fP

\fBvoid png_set_read_user_chunk_fn (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fIuser_chunk_ptr\fP\fB, png_user_chunk_ptr \fIread_user_chunk_fn\fP\fB);\fP

\fBvoid png_set_read_user_transform_fn (png_structp \fP\fIpng_ptr\fP\fB, png_user_transform_ptr \fIread_user_transform_fn\fP\fB);\fP

\fBvoid png_set_rgb_to_gray (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fIerror_action\fP\fB, double \fP\fIred\fP\fB, double \fIgreen\fP\fB);\fP

\fBvoid png_set_rgb_to_gray_fixed (png_structp \fP\fIpng_ptr\fP\fB, int error_action png_uint_32 \fP\fIred\fP\fB, png_uint_32 \fIgreen\fP\fB);\fP

\fBvoid png_set_rows (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_bytepp \fIrow_pointers\fP\fB);\fP

\fBvoid png_set_sBIT (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_color_8p \fIsig_bit\fP\fB);\fP

\fBvoid png_set_sCAL (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fIunit\fP\fB, double \fP\fIwidth\fP\fB, double \fIheight\fP\fB);\fP

\fBvoid png_set_sCAL_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fIunit\fP\fB, png_fixed_point \fP\fIwidth\fP\fB, png_fixed_point \fIheight\fP\fB);\fP

\fBvoid png_set_sCAL_s (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fIunit\fP\fB, png_charp \fP\fIwidth\fP\fB, png_charp \fIheight\fP\fB);\fP

\fBvoid png_set_scale_16 (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_shift (png_structp \fP\fIpng_ptr\fP\fB, png_color_8p \fItrue_bits\fP\fB);\fP

\fBvoid png_set_sig_bytes (png_structp \fP\fIpng_ptr\fP\fB, int \fInum_bytes\fP\fB);\fP

\fBvoid png_set_sPLT (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_spalette_p \fP\fIsplt_ptr\fP\fB, int \fInum_spalettes\fP\fB);\fP

\fBvoid png_set_sRGB (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fIsrgb_intent\fP\fB);\fP

\fBvoid png_set_sRGB_gAMA_and_cHRM (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fIsrgb_intent\fP\fB);\fP

\fBvoid png_set_strip_16 (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_strip_alpha (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_strip_error_numbers (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fIstrip_mode\fP\fB);\fP

\fBvoid png_set_swap (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_swap_alpha (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_set_text (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_textp \fP\fItext_ptr\fP\fB, int \fInum_text\fP\fB);\fP

\fBvoid png_set_text_compression_level (png_structp \fP\fIpng_ptr\fP\fB, int \fIlevel\fP\fB);\fP

\fBvoid png_set_text_compression_mem_level (png_structp \fP\fIpng_ptr\fP\fB, int \fImem_level\fP\fB);\fP

\fBvoid png_set_text_compression_strategy (png_structp \fP\fIpng_ptr\fP\fB, int \fIstrategy\fP\fB);\fP

\fBvoid png_set_text_compression_window_bits (png_structp \fP\fIpng_ptr\fP\fB, int \fIwindow_bits\fP\fB);\fP

\fBvoid \fP\fIpng_set_text_compression_method\fP\fB, (png_structp \fP\fIpng_ptr\fP\fB, int \fImethod)\fP\fB);\fP

\fBvoid png_set_tIME (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_timep \fImod_time\fP\fB);\fP

\fBvoid png_set_tRNS (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_bytep \fP\fItrans_alpha\fP\fB, int \fP\fInum_trans\fP\fB, png_color_16p \fItrans_color\fP\fB);\fP

\fBvoid png_set_tRNS_to_alpha (png_structp \fIpng_ptr\fP\fB);\fP

\fBpng_uint_32 png_set_unknown_chunks (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_unknown_chunkp \fP\fIunknowns\fP\fB, int \fP\fInum\fP\fB, int \fIlocation\fP\fB);\fP

\fBvoid png_set_unknown_chunk_location (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fIchunk\fP\fB, int \fIlocation\fP\fB);\fP

\fBvoid png_set_user_limits (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fP\fIuser_width_max\fP\fB, png_uint_32 \fIuser_height_max\fP\fB);\fP

\fBvoid png_set_user_transform_info (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fIuser_transform_ptr\fP\fB, int \fP\fIuser_transform_depth\fP\fB, int \fIuser_transform_channels\fP\fB);\fP

\fBvoid png_set_write_fn (png_structp \fP\fIpng_ptr\fP\fB, png_voidp \fP\fIio_ptr\fP\fB, png_rw_ptr \fP\fIwrite_data_fn\fP\fB, png_flush_ptr \fIoutput_flush_fn\fP\fB);\fP

\fBvoid png_set_write_status_fn (png_structp \fP\fIpng_ptr\fP\fB, png_write_status_ptr \fIwrite_row_fn\fP\fB);\fP

\fBvoid png_set_write_user_transform_fn (png_structp \fP\fIpng_ptr\fP\fB, png_user_transform_ptr \fIwrite_user_transform_fn\fP\fB);\fP

\fBint png_sig_cmp (png_bytep \fP\fIsig\fP\fB, png_size_t \fP\fIstart\fP\fB, png_size_t \fInum_to_check\fP\fB);\fP

\fBvoid png_start_read_image (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_warnin (png_structp \fP\fIpng_ptr\fP\fB, png_const_charp \fImessage\fP\fB);\fP

\fBvoid png_write_chunk (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fP\fIchunk_name\fP\fB, png_bytep \fP\fIdata\fP\fB, png_size_t \fIlength\fP\fB);\fP

\fBvoid png_write_chunk_data (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fP\fIdata\fP\fB, png_size_t \fIlength\fP\fB);\fP

\fBvoid png_write_chunk_end (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_write_chunk_start (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fP\fIchunk_name\fP\fB, png_uint_32 \fIlength\fP\fB);\fP

\fBvoid png_write_end (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP

\fBvoid png_write_flush (png_structp \fIpng_ptr\fP\fB);\fP

\fBvoid png_write_image (png_structp \fP\fIpng_ptr\fP\fB, png_bytepp \fIimage\fP\fB);\fP

\fBvoid png_write_info (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP

\fBvoid png_write_info_before_PLTE (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fIinfo_ptr\fP\fB);\fP

\fBvoid png_write_png (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fItransforms\fP\fB, png_voidp \fIparams\fP\fB);\fP

\fBvoid png_write_row (png_structp \fP\fIpng_ptr\fP\fB, png_bytep \fIrow\fP\fB);\fP

\fBvoid png_write_rows (png_structp \fP\fIpng_ptr\fP\fB, png_bytepp \fP\fIrow\fP\fB, png_uint_32 \fInum_rows\fP\fB);\fP

\fBvoid png_write_sig (png_structp \fIpng_ptr\fP\fB);\fP

.SH DESCRIPTION
The
.I libpng
library supports encoding, decoding, n' various manipulations of
the Portable Network Graphics (PNG) format image files.  It uses the
.IR zlib(3)
compression library.
Peepin be a cold-ass lil copy of tha libpng-manual.txt file dat accompanies libpng.
.SH LIBPNG.TXT
libpng-manual.txt - A description on how tha fuck ta use n' modify libpng

 libpng version 1.6.6 - September 16, 2013
 Updated n' distributed by Glenn Randers-Pehrson
 <glennrp at users.sourceforge.net>
 Copyright (c) 1998-2013 Glenn Randers-Pehrson

 This document is busted out under tha libpng license.
 For conditionz of distribution n' use, peep tha disclaimer
 n' license up in png.h

 Based on:

 libpng versions 0.97, January 1998, all up in 1.6.6 - September 16, 2013
 Updated n' distributed by Glenn Randers-Pehrson
 Copyright (c) 1998-2013 Glenn Randers-Pehrson

 libpng 1.0 beta 6  version 0.96 May 28, 1997
 Updated n' distributed by Andreas Dilger
 Copyright (c) 1996, 1997 Andreas Dilger

 libpng 1.0 beta 2 - version 0.88  January 26, 1996
 For conditionz of distribution n' use, peep copyright
 notice up in png.h. Copyright (c) 1995, 1996 Guy Eric
 Schalnat, Group 42, Inc.

 Updated/rewritten per request up in tha libpng FAQUIZZY
 Copyright (c) 1995, 1996 Frank J. T. Wojcik
 December 18, 1995 & January 20, 1996

 TABLE OF CONTENTS

    I. Introduction
   Pt II. Right back up in yo muthafuckin ass. Structures
  Pt III. Reading
   IV. Writing
    V. Right back up in yo muthafuckin ass. Simplified API
   VI. Modifying/Customizin libpng
  VII. MNG support
 VIII. Chizzlez ta Libpng from version 0.88
   IX. Chizzlez ta Libpng from version 1.0.x ta 1.2.x
    X. Chizzlez ta Libpng from version 1.0.x/1.2.x ta 1.4.x
   XI. Chizzlez ta Libpng from version 1.4.x ta 1.5.x
  XII. Chizzlez ta Libpng from version 1.5.x ta 1.6.x
 XIII. Detectin libpng
  XIV. Right back up in yo muthafuckin ass. Source code repository
   XV. Codin style
  XVI. Y2K Compliizzle up in libpng

.SH I. Introduction

This file raps bout how tha fuck ta use n' modify tha PNG reference library
(known as libpng) fo' yo' own use.  In addizzle ta this
file, example.c be a phat startin point fo' rockin tha library, as
it is heavily commented n' should include every last muthafuckin thang most people
will need. Y'all KNOW dat shit, muthafucka!  We assume dat libpng be already installed; peep the
INSTALL file fo' instructions on how tha fuck ta install libpng.

For examplez of libpng usage, peep tha filez "example.c", "pngtest.c",
and tha filez up in tha "contrib" directory, all of which is included in
the libpng distribution.

Libpng was freestyled as a cold-ass lil companion ta tha PNG justification, as a way
of reducin tha amount of time n' effort it takes ta support tha PNG
file format up in application programs.

Da PNG justification (second edition), November 2003, be available as
a W3C Recommendation n' as a ISO Standard (ISO/IEC 15948:2004 (E)) at
<http://www.w3.org/TR/2003/REC-PNG-20031110/
Da W3C n' ISO documents have identical technical content.

Da PNG-1.2 justification be available at
<http://www.libpng.org/pub/png/documents/>.  It be technologically equivalent
to tha PNG justification (second edition) but has some additionizzle material.

Da PNG-1.0 justification be available
as RFC 2083 <http://www.libpng.org/pub/png/documents/> n' as a
W3C Recommendation <http://www.w3.org/TR/REC.png.html>.

Some additionizzle chunks is busted lyrics bout up in tha special-purpose hood chunks
documents at <http://www.libpng.org/pub/png/documents/>.

Other shiznit
about PNG, n' tha sickest fuckin version of libpng, can be found all up in tha PNG home
page, <http://www.libpng.org/pub/png/>.

Most playas aint gonna gotta modify tha library significantly; advanced
users may wanna modify it mo' n' mo' n' mo'.  All attempts was made ta make it as
complete as possible, while keepin tha code easy as fuck  ta understand.
Currently, dis library only supports C.  Support fo' other languages
is bein considered.

Libpng has been designed ta handle multiple sessions at one time,
to be easily modifiable, ta be portable ta tha vast majoritizzle of
machines (ANSI, K&R, 16-, 32-, n' 64-bit) available, n' ta be easy as fuck 
to use.  Da illest goal of libpng is ta promote tha acceptizzle of
the PNG file format up in whatever way possible.  While there is still
work ta be done (see tha TODO file), libpng should cover the
majoritizzle of tha needz of its users.

Libpng uses zlib fo' its compression n' decompression of PNG files.
Further shiznit bout zlib, n' tha sickest fuckin version of zlib, can
be found all up in tha zlib home page, <http://www.info-zip.org/pub/infozip/zlib/>.
Da zlib compression utilitizzle be a general purpose utilitizzle dat is
useful fo' mo' than PNG files, n' can be used without libpng.
See tha documentation served up wit zlib fo' mo' details.
Yo ass can probably find tha source filez fo' tha zlib utilitizzle wherever you
find tha libpng source files.

Libpng is thread safe, provided tha threadz is rockin different
instancez of tha structures.  Each thread should have its own
png_struct n' png_info instances, n' thus its own image.
Libpng do not protect itself against two threadz rockin the
same instizzle of a structure.

.SH Pt II. Right back up in yo muthafuckin ass. Structures

There is two main structures dat is blingin ta libpng, png_struct
and png_info.  Both is internal structures dat is no longer exposed
in tha libpng intercourse (az of libpng 1.5.0).

Da png_info structure is designed ta provide shiznit bout the
PNG file.  At one time, tha fieldz of png_info was intended ta be
directly accessible ta tha user n' shit.  But fuck dat shiznit yo, tha word on tha street is dat dis tended ta cause problems
with applications rockin dynamically loaded libraries, n' as a result
a set of intercourse functions fo' png_info (the png_get_*() n' png_set_*()
functions) was pimped, n' direct access ta tha png_info fieldz was
deprecated..

Da png_struct structure is tha object used by tha library ta decode a
single image.  Az of 1.5.0 dis structure be also not exposed.

Almost all libpng APIs require a pointa ta a png_struct as tha straight-up original gangsta argument.
Many (in particular tha png_set n' png_get APIs) also require a pointer
to png_info as tha second argument.  Some application visible macros
defined up in png.h designed fo' basic data access (readin n' writing
integers up in tha PNG format) don't take a png_info pointer yo, but itz almost
always safe ta assume dat a (png_struct*) has ta be passed ta booty-call a API
function.

Yo ass can have mo' than one png_info structure associated wit a image,
as illustrated up in pngtest.c, one fo' shiznit valid prior ta the
IDAT chunks n' another (called "end_info" below) fo' thangs afta em.

Da png.h header file be a invaluable reference fo' programmin wit libpng.
And while I be on tha topic, make shizzle you include tha libpng header file:

#include <png.h>

and also (az of libpng-1.5.0) tha zlib header file, if you need it:

#include <zlib.h>

.SS Types

Da png.h header file defines a fuckin shitload of integral types used by the
APIs.  Most of these is fairly obvious; fo' example types corresponding
to integerz of particular sizes n' types fo' passin color joints.

One exception is how tha fuck non-integral numbers is handled. Y'all KNOW dat shit, muthafucka!  For application
convenience most APIs dat take such numbers have C (double) arguments;
however, internally PNG, n' libpng, use 32 bit signed integers n' encode
the value by multiplyin by 100,000.  Az of libpng 1.5.0 a cold-ass lil convenience
macro PNG_FP_1 is defined up in png.h along wit a type (png_fixed_point)
which is simply (png_int_32).

All APIs dat take (double) arguments also gotz a matchin API that
takes tha correspondin fixed point integer arguments, n' you can put dat on yo' toast.  Da fixed point
API has tha same ol' dirty name as tha floatin point one wit "_fixed" appended.
Da actual range of joints permitted up in tha APIs is frequently less than
the full range of (png_fixed_point) (\-21474 ta +21474).  When APIs require
a non-negatizzle argument tha type is recorded as png_uint_32 above.  Consult
the header file n' tha text below fo' mo' shiznit.

Special care must be take wit sCAL chunk handlin cuz tha chunk itself
uses non-integral joints encoded as strings containin decimal floatin point
numbers.  See tha comments up in tha header file.

.SS Configuration

Da main header file function declarations is frequently protected by C
preprocessin directivez of tha form:

    #ifdef PNG_feature_SUPPORTED
    declare-function
    #endif
    ...
    #ifdef PNG_feature_SUPPORTED
    use-function
    #endif

Da library can be built without support fo' these APIs, although a
standard build gonna git all implemented APIs.  Application programs
should check tha feature macros before rockin a API fo' maximum
portability.  From libpng 1.5.0 tha feature macros set durin tha build
of libpng is recorded up in tha header file "pnglibconf.h" n' dis file
is always included by png.h.

If you don't need ta chizzle tha library configuration from tha default, skip to
the next section ("Reading").

Notice dat a shitload of tha makefilez up in tha 'scripts' directory n' (in 1.5.0) all
of tha build project filez up in tha 'projects' directory simply copy
scripts/pnglibconf.h.prebuilt ta pnglibconf.h.  This means dat these build
systems do not permit easy as fuck  auto-configuration of tha library - they only
support tha default configuration.

Da easiest way ta make minor chizzlez ta tha libpng configuration when
auto-configuration is supported is ta add definitions ta tha command line
usin (typically) CPPFLAGS.  For example:

CPPFLAGS=\-DPNG_NO_FLOATING_ARITHMETIC

will chizzle tha internal libpng math implementation fo' gamma erection and
other arithmetic calculations ta fixed point, avoidin tha need fo' fast
floatin point support.  Da result can be peeped up in tha generated pnglibconf.h -
make shizzle it gotz nuff tha chizzled feature macro setting.

If you need ta make mo' extensive configuration chizzlez - mo' than one or two
feature macro settings - you can either add \-DPNG_USER_CONFIG ta tha build
command line n' put a list of feature macro settings up in pngusr.h or you can set
DFA_XTRA (a makefile variable) ta a gangbangin' file containin tha same shiznit up in the
form of 'option' settings.

A. Changin pnglibconf.h

A variety of methodz exist ta build libpng.  Not all of these support
reconfiguration of pnglibconf.h.  To reconfigure pnglibconf.h it must either be
rebuilt from scripts/pnglibconf.dfa rockin awk or it must be edited by hand.

Hand editin be  bigged up  by copyin scripts/pnglibconf.h.prebuilt to
pnglibconf.h n' changin tha lines definin tha supported features, paying
very close attention ta tha 'option' shiznit up in scripts/pnglibconf.dfa
that raps bout dem features n' they requirements, n' you can put dat on yo' toast.  This is easy as fuck  ta get
wrong.

B. Configuration rockin DFA_XTRA

Rebuildin from pnglibconf.dfa is easy as fuck  if a gangbangin' functionin 'awk', or a later
variant like fuckin 'nawk' or 'gawk', be available.  Da configure build will
automatically find a appropriate awk n' build pnglibconf.h.
Da scripts/pnglibconf.mak file gotz nuff a set of make rulez fo' bustin the
same thang if configure aint used, n' nuff of tha makefilez up in tha scripts
directory use dis approach.

When rebuildin simply write a freshly smoked up file containin chizzled options n' set
DFA_XTRA ta tha name of dis file.  This causes tha build ta append tha freshly smoked up file
to tha end of scripts/pnglibconf.dfa.  Da pngusr.dfa file should contain lines
of tha followin forms:

everythang = off

This turns all optionizzle features off.  Include it all up in tha start of pngusr.dfa to
make it easier ta build a minimal configuration. I aint talkin' bout chicken n' gravy biatch.  Yo ass will need ta turn at least
some features on afterward ta enable either readin or freestylin code, or both.

option feature on
option feature off

Enable or disable a single feature.  This will automatically enable other
features required by a gangbangin' feature dat is turned on or disable other features that
require a gangbangin' feature which is turned off.  Conflictin settings will cause a error
message ta be emitted by awk.

settin feature default value

Changes tha default value of settin 'feature' ta 'value'.  There is a small
number of settings listed all up in tha top of pnglibconf.h, they is documented up in the
source code.  Most of these joints have performizzle implications fo' tha library
but most of dem have no visible effect on tha API.  Some can also be overridden
from tha API.

This method of buildin a cold-ass lil customized pnglibconf.h is illustrated in
contrib/pngminim/*.  See tha "$(PNGCONF):" target up in tha makefile and
pngusr.dfa up in these directories.

C. Configuration rockin PNG_USR_CONFIG

If \-DPNG_USR_CONFIG be added ta tha CFLAGS when pnglibconf.h is built tha file
pngusr.h will automatically be included before tha options in
scripts/pnglibconf.dfa is processed. Y'all KNOW dat shit, muthafucka!  Yo crazy-ass pngusr.h file should contain only
macro definitions turnin features on or off or settin settings.

Apart from tha global settin "everythang = off" all tha options listed above
can be set rockin macros up in pngusr.h:

#define PNG_feature_SUPPORTED

is equivalent to:

option feature on

#define PNG_NO_feature

is equivalent to:

option feature off

#define PNG_feature value

is equivalent to:

settin feature default value

Notice dat up in both cases, pngusr.dfa n' pngusr.h, tha contentz of the
pngusr file you supply override tha contentz of scripts/pnglibconf.dfa

If confusin or incomprehensible behavior thangs up in dis biatch it is possible to
examine tha intermediate file pnglibconf.dfn ta find tha full set of
dependency shiznit fo' each settin n' option. I aint talkin' bout chicken n' gravy biatch.  Simply locate the
feature up in tha file n' read tha C comments dat precede dat shit.

This method be also illustrated up in tha contrib/pngminim/* makefilez and
pngusr.h.

.SH Pt III. Reading

We bout ta now strutt you all up in tha possible functions ta booty-call when reading
in a PNG file sequentially, briefly explainin tha syntax n' purpose
of each one.  See example.c n' png.h fo' mo' detail.  While
progressive readin is covered up in tha next section, yo big-ass booty is ghon still
need a shitload of tha functions discussed up in dis section ta read a PNG
file.

.SS Setup

Yo ass will wanna do tha I/O initialization(*) before you git tha fuck into libpng,
so if it don't work, you aint gots much ta undo.  Of course, you
will also wanna insure dat yo ass is, up in fact, dealin wit a PNG
file.  Libpng serves up a simple check ta peep if a gangbangin' file be a PNG file.
To use it, pass up in tha straight-up original gangsta 1 ta 8 bytez of tha file ta tha function
png_sig_cmp(), n' it will return 0 (false) if tha bytes match the
correspondin bytez of tha PNG signature, or nonzero (true) otherwise.
Of course, tha mo' bytes you pass in, tha pimped outa tha accuracy of the
prediction.

If yo ass is intendin ta keep tha file pointa open fo' use up in libpng,
you must ensure you don't read mo' than 8 bytes from tha beginning
of tha file, n' you also gotta cook up a cold-ass lil call ta png_set_sig_bytes_read()
with tha number of bytes you read from tha beginning.  Libpng will
then only check tha bytes (if any) dat yo' program didn't read.

(*): If yo ass is not rockin tha standard I/O functions, yo big-ass booty is ghon need
to replace dem wit custom functions.  See tha rap under
Customizin libpng.


    FILE *fp = fopen(file_name, "rb");
    if (!fp)
    {
       return (ERROR);
    }

    fread(header, 1, number, fp);
    is_png = !png_sig_cmp(header, 0, number);

    if (!is_png)
    {
       return (NOT_PNG);
    }


Next, png_struct n' png_info need ta be allocated n' initialized. Y'all KNOW dat shit, muthafucka!  In
order ta ensure dat tha size of these structures is erect even wit a
dynamically linked libpng, there be functions ta initialize and
allocate tha structures.  We also pass tha library version, optional
pointas ta error handlin functions, n' a pointa ta a thugged-out data struct for
use by tha error functions, if necessary (the pointa n' functions can
be NULL if tha default error handlezs is ta be used).  See tha section
on Chizzlez ta Libpng below regardin tha oldschool initialization functions.
Da structure allocation functions on tha fuckin' down-lowly return NULL if they fail to
create tha structure, so yo' application should check fo' dis shit.

    png_structp png_ptr = png_create_read_struct
        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
        user_error_fn, user_warning_fn);

    if (!png_ptr)
       return (ERROR);

    png_infop info_ptr = png_create_info_struct(png_ptr);

    if (!info_ptr)
    {
       png_destroy_read_struct(&png_ptr,
           (png_infopp)NULL, (png_infopp)NULL);
       return (ERROR);
    }

If you wanna use yo' own memory allocation routines,
use a libpng dat was built wit PNG_USER_MEM_SUPPORTED defined, n' use
png_create_read_struct_2() instead of png_create_read_struct():

    png_structp png_ptr = png_create_read_struct_2
        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
        user_error_fn, user_warning_fn, (png_voidp)
        user_mem_ptr, user_malloc_fn, user_free_fn);

Da error handlin routines passed ta png_create_read_struct()
and tha memory alloc/free routines passed ta png_create_struct_2()
are only necessary if yo ass is not rockin tha libpng supplied error
handlin n' memory alloc/free functions.

When libpng encountas a error, it expects ta longjmp back
to yo' routine.  Therefore, yo big-ass booty is ghon need ta booty-call setjmp n' pass
your png_jmpbuf(png_ptr).  If you read tha file from different
routines, yo big-ass booty is ghon need ta update tha longjmp buffer every last muthafuckin time you enter
a freshly smoked up routine dat will call a png_*() function.

See yo' documentation of setjmp/longjmp fo' yo' compila fo' more
information on setjmp/longjmp.  See tha rap on libpng error
handlin up in tha Customizin Libpng section below fo' mo' shiznit
on tha libpng error handling.  If a error occurs, n' libpng longjmp's
back ta yo' setjmp, yo big-ass booty is ghon wanna call png_destroy_read_struct() to
free any memory.

    if (setjmp(png_jmpbuf(png_ptr)))
    {
       png_destroy_read_struct(&png_ptr, &info_ptr,
           &end_info);
       fclose(fp);
       return (ERROR);
    }

Pass (png_infopp)NULL instead of &end_info if you didn't create
an end_info structure.

If you would rather avoid tha complexitizzle of setjmp/longjmp issues,
you can compile libpng wit PNG_NO_SETJMP, up in which case
errors will result up in a cold-ass lil call ta PNG_ABORT() which defaults ta abort().

Yo ass can #define PNG_ABORT() ta a gangbangin' function dat do something
more useful than abort(), as long as yo' function do not
return.

Now you need ta set up tha input code.  Da default fo' libpng is to
use tha C function fread().  If you use this, yo big-ass booty is ghon need ta pass a
valid FILE * up in tha function png_init_io().  Be shizzle dat tha file is
opened up in binary mode.  If you wish ta handle readin data up in another
way, you need not call tha png_init_io() function yo, but you must then
implement tha libpng I/O methodz discussed up in tha Customizin Libpng
section below.

    png_init_io(png_ptr, fp);

If you had previously opened tha file n' read any of tha signature from
the beginnin up in order ta peep if dis was a PNG file, you need ta let
libpng know dat there be some bytes missin from tha start of tha file.

    png_set_sig_bytes(png_ptr, number);

Yo ass can chizzle tha zlib compression buffer size ta be used while
readin compressed data with

    png_set_compression_buffer_size(png_ptr, buffer_size);

where tha default size is 8192 bytes.  Note dat tha buffer size
is chizzled immediately n' tha buffer is reallocated immediately,
instead of settin a gangbangin' flag ta be acted upon later.

If you want CRC errors ta be handled up in a gangbangin' finger-lickin' different manner than
the default, use

    png_set_crc_action(png_ptr, crit_action, ancil_action);

Da joints fo' png_set_crc_action() say how tha fuck libpng is ta handle CRC errors in
ancillary n' critical chunks, n' whether ta use tha data contained
therein. I aint talkin' bout chicken n' gravy biatch.  Note dat it is impossible ta "discard" data up in a cold-ass lil critical
chunk.

Choices fo' (int) crit_action are
   PNG_CRC_DEFAULT      0  error/quit
   PNG_CRC_ERROR_QUIT   1  error/quit
   PNG_CRC_WARN_USE     3  warn/use data
   PNG_CRC_QUIET_USE    4  on tha fuckin' down-low/use data
   PNG_CRC_NO_CHANGE    5  use tha current value

Choices fo' (int) ancil_action are
   PNG_CRC_DEFAULT      0  error/quit
   PNG_CRC_ERROR_QUIT   1  error/quit
   PNG_CRC_WARN_DISCARD 2  warn/discard data
   PNG_CRC_WARN_USE     3  warn/use data
   PNG_CRC_QUIET_USE    4  on tha fuckin' down-low/use data
   PNG_CRC_NO_CHANGE    5  use tha current value

.SS Settin up callback code

Yo ass can set up a cold-ass lil callback function ta handle any unknown chunks up in the
input stream. Yo ass must supply tha function

    read_chunk_callback(png_structp png_ptr,
         png_unknown_chunkp chunk);
    {
       /* Da unknown chunk structure gotz nuff your
          chunk data, along wit similar data fo' any other
          unknown chunks: */

           png_byte name[5];
           png_byte *data;
           png_size_t size;

       /* Note dat libpng has already taken care of
          tha CRC handlin */

       /* put yo' code here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Search fo' yo' chunk up in the
          unknown chunk structure, process it, n' return one
          of tha following: */

       return (\-n); /* chunk had a error */
       return (0); /* did not recognize */
       return (n); /* success */
    }

(Yo ass can give yo' function another name dat you like instead of
"read_chunk_callback")

To inform libpng bout yo' function, use

    png_set_read_user_chunk_fn(png_ptr, user_chunk_ptr,
        read_chunk_callback);

This names not only tha callback function yo, but also a user pointa that
you can retrieve with

    png_get_user_chunk_ptr(png_ptr);

If you call tha png_set_read_user_chunk_fn() function, then all unknown
chunks which tha callback do not handle is ghon be saved when read. Y'all KNOW dat shit, muthafucka!  Yo ass can
cause dem ta be discarded by returnin '1' ("handled") instead of '0'.  This
behavior will chizzle up in libpng 1.7 n' tha default handlin set by the
png_set_keep_unknown_chunks() function, busted lyrics bout below, is ghon be used when the
callback returns 0.  If you want tha existin behavior you should set tha global
default ta PNG_HANDLE_CHUNK_IF_SAFE now; dis is compatible wit all current
versionz of libpng n' wit 1.7.  Libpng 1.6 thangs a warnin if you keep the
default, or PNG_HANDLE_CHUNK_NEVER, n' tha callback returns 0.

At dis point, you can set up a cold-ass lil callback function dat will be
called afta each row has been read, which you can use ta control
a progress meta or tha like.  It aint nuthin but demonstrated up in pngtest.c.
Yo ass must supply a gangbangin' function

    void read_row_callback(png_structp png_ptr,
       png_uint_32 row, int pass);
    {
      /* put yo' code here */
    }

(Yo ass can give it another name dat you like instead of "read_row_callback")

To inform libpng bout yo' function, use

    png_set_read_status_fn(png_ptr, read_row_callback);

When dis function is called tha row has already been straight-up processed and
the 'row' n' 'pass' refer ta tha next row ta be handled. Y'all KNOW dat shit, muthafucka!  For the
non-interlaced case tha row dat was just handled is simply one less than the
passed up in row number, n' pass will always be 0.  For tha interlaced case the
same applies unless tha row value is 0, up in which case tha row just handled was
the last one from one of tha precedin passes.  Because interlacin may skip a
pass you cannot be shizzle dat tha precedin pass is just 'pass\-1', if you straight-up
need ta know what tha fuck tha last pass is record (row,pass) from tha callback n' use
the last recorded value each time.

As wit tha user transform you can find tha output row rockin the
PNG_ROW_FROM_PASS_ROW macro.

.SS Unknown-chunk handling

Now you git ta set tha way tha library processes unknown chunks up in the
input PNG stream. Both known n' unknown chunks is ghon be read. Y'all KNOW dat shit, muthafucka!  Normal
behavior is dat known chunks is ghon be parsed tha fuck into shiznit in
various info_ptr thugz while unknown chunks is ghon be discarded. Y'all KNOW dat shit, muthafucka! This
behavior can be wasteful if yo' application aint NEVER gonna use some known
chunk types. To chizzle this, you can call:

    png_set_keep_unknown_chunks(png_ptr, keep,
        chunk_list, num_chunks);

    keep       - 0: default unknown chunk handling
                 1: ignore; do not keep
                 2: keep only if safe-to-copy
                 3: keep even if unsafe-to-copy

               Yo ass can use these definitions:
                 PNG_HANDLE_CHUNK_AS_DEFAULT   0
                 PNG_HANDLE_CHUNK_NEVER        1
                 PNG_HANDLE_CHUNK_IF_SAFE      2
                 PNG_HANDLE_CHUNK_ALWAYS       3

    chunk_list - list of chunks affected (a byte string,
                 five bytes per chunk, NULL or '\0' if
                 num_chunks is positive; ignored if
                 numchunks <= 0).

    num_chunks - number of chunks affected; if 0, all
                 unknown chunks is affected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If positive,
                 only tha chunks up in tha list is affected,
                 n' if wack all unknown chunks and
                 all known chunks except fo' tha IHDR,
                 PLTE, tRNS, IDAT, n' IEND chunks are
                 affected.

Unknown chunks declared up in dis way is ghon be saved as raw data onto a
list of png_unknown_chunk structures.  If a cold-ass lil chunk dat is normally
known ta libpng is named up in tha list, it is ghon be handled as unknown,
accordin ta tha "keep" directive.  If a cold-ass lil chunk is named up in successive
instancez of png_set_keep_unknown_chunks(), tha final instizzle will
take precedence.  Da IHDR n' IEND chunks should not be named in
chunk_list; if they are, libpng will process dem normally anyway.
If you know dat yo' application aint NEVER gonna make use of some particular
chunks, use PNG_HANDLE_CHUNK_NEVER (or 1) as demonstrated below.

Here be a example of tha usage of png_set_keep_unknown_chunks(),
where tha private "vpAg" chunk will lata be processed by a user chunk
callback function:

    png_byte vpAg[5]={118, 112,  65, 103, (png_byte) '\0'};

    #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
      png_byte unused_chunks[]=
      {
        104,  73,  83,  84, (png_byte) '\0',   /* hIST */
        105,  84,  88, 116, (png_byte) '\0',   /* iTXt */
        112,  67,  65,  76, (png_byte) '\0',   /* pCAL */
        115,  67,  65,  76, (png_byte) '\0',   /* sCAL */
        115,  80,  76,  84, (png_byte) '\0',   /* sPLT */
        116,  73,  77,  69, (png_byte) '\0',   /* tIME */
      };
    #endif

    ...

    #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
      /* ignore all unknown chunks
       * (use global settin "2" fo' libpng16 n' earlier):
       */
      png_set_keep_unknown_chunks(read_ptr, 2, NULL, 0);

      /* except fo' vpAg: */
      png_set_keep_unknown_chunks(read_ptr, 2, vpAg, 1);

      /* also ignore unused known chunks: */
      png_set_keep_unknown_chunks(read_ptr, 1, unused_chunks,
         (int)(sizeof unused_chunks)/5);
    #endif

.SS User limits

Da PNG justification allows tha width n' height of a image ta be as
pimpin' as 2^(31\-1 (0x7fffffff), or bout 2.147 bazillion rows n' columns.
Since straight-up few applications straight-up need ta process such big-ass images,
we have imposed a arbitrary 1-mazillion limit on rows n' columns.
Larger images is ghon be rejected immediately wit a png_error() call. If
you wish ta chizzle dis limit, you can use

   png_set_user_limits(png_ptr, width_max, height_max);

to set yo' own limits, or use width_max = height_max = 0x7fffffffL
to allow all valid dimensions (libpng may reject some straight-up big-ass images
anyway cuz of potential buffer overflow conditions).

Yo ass should put dis statement afta you create tha PNG structure and
before callin png_read_info(), png_read_png(), or png_process_data().

When freestylin a PNG datastream, put dis statement before calling
png_write_info() or png_write_png().

If you need ta retrieve tha limits dat is bein applied, use

   width_max = png_get_user_width_max(png_ptr);
   height_max = png_get_user_height_max(png_ptr);

Da PNG justification sets no limit on tha number of ancillary chunks
allowed up in a PNG datastream.  Yo ass can impose a limit on tha total number
of sPLT, tEXt, iTXt, zTXt, n' unknown chunks dat is ghon be stored, with

   png_set_chunk_cache_max(png_ptr, user_chunk_cache_max);

where 0x7fffffffL means unlimited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Yo ass can retrieve dis limit with

   chunk_cache_max = png_get_chunk_cache_max(png_ptr);

Yo ass can also set a limit on tha amount of memory dat a cold-ass lil compressed chunk
other than IDAT can occupy, with

   png_set_chunk_malloc_max(png_ptr, user_chunk_malloc_max);

and you can retrieve tha limit with

   chunk_malloc_max = png_get_chunk_malloc_max(png_ptr);

Any chunks dat would cause either of these limits ta be exceeded will
be ignored.

.SS Hype bout yo' system

If you intend ta display tha PNG or ta incorporate it up in other image data you
need ta tell libpng shiznit bout yo' display or drawin surface so that
libpng can convert tha joints up in tha image ta match tha display.

From libpng-1.5.4 dis shiznit can be set before readin tha PNG file
header n' shit.  In earlier versions png_set_gamma() existed but behaved incorrectly if
called before tha PNG file header had been read n' png_set_alpha_mode() did not
exist.

If you need ta support versions prior ta libpng-1.5.4 test tha version number
as illustrated below rockin "PNG_LIBPNG_VER >= 10504" n' follow tha procedures
busted lyrics bout up in tha appropriate manual page.

Yo ass give libpng tha encodin expected by yo' system expressed as a 'gamma'
value.  Yo ass can also specify a thugged-out default encodin fo' tha PNG file in
case tha required shiznit is missin from tha file.  By default libpng
assumes dat tha PNG data matches yo' system, ta keep dis default call:

   png_set_gamma(png_ptr, screen_gamma, 1/screen_gamma/*file gamma*/);

or you can use tha fixed point equivalent:

   png_set_gamma_fixed(png_ptr, PNG_FP_1*screen_gamma,
      PNG_FP_1/screen_gamma);

If you don't give a fuck tha gamma fo' yo' system it is probably 2.2 - a good
approximation ta tha IEC standard fo' display systems (sRGB).  If images are
too contrasty or washed up you gots tha value wack - check yo' system
documentation!

Many systems permit tha system gamma ta be chizzled via a lookup table up in the
display driver, all dem systems, includin olda Macs, chizzle tha response by
default.  Az of 1.5.4 three special joints is available ta handle common
situations:

   PNG_DEFAULT_sRGB: Indicates dat tha system conforms ta the
                     IEC 61966-2-1 standard. Y'all KNOW dat shit, muthafucka!  This matches almost
                     all systems.
   PNG_GAMMA_MAC_18: Indicates dat tha system be a older
                     (pre Mac OS 10.6) Applez Macintosh system with
                     tha default settings.
   PNG_GAMMA_LINEAR: Just tha fixed point value fo' 1.0 - indicates
                     dat tha system expects data wit no gamma
                     encoding.

Yo ass would use tha linear (unencoded) value if you need ta process tha pixel
values further cuz dis avoidz tha need ta decode n' re-encode each
component value whenever arithmetic is performed. Y'all KNOW dat shit, muthafucka!  All dem graphics software
uses linear joints fo' dis reason, often wit higher precision component joints
to preserve overall accuracy.

Da second thang you may need ta tell libpng bout is how tha fuck yo' system handles
alpha channel shiznit. I aint talkin' bout chicken n' gravy biatch.  Some yo, but not all, PNG filez contain a alpha
channel.  To display these filez erectly you need ta compose tha data onto a
suitable background, as busted lyrics bout up in tha PNG justification.

Libpng only supports composin onto a single color (usin png_set_background;
see below).  Otherwise you must do tha composizzle yo ass and, up in dis case,
you may need ta booty-call png_set_alpha_mode:

   #if PNG_LIBPNG_VER >= 10504
      png_set_alpha_mode(png_ptr, mode, screen_gamma);
   #else
      png_set_gamma(png_ptr, screen_gamma, 1.0/screen_gamma);
   #endif

Da screen_gamma value is tha same ol' dirty as tha argument ta png_set_gamma; however,
how it affects tha output dependz on tha mode.  png_set_alpha_mode() sets the
file gamma default ta 1/screen_gamma, so normally you don't need ta call
png_set_gamma.  If you need different defaults call png_set_gamma() before
png_set_alpha_mode() - if you call it afta it will override tha settings made
by png_set_alpha_mode().

Da mode be as bigs up:

    PNG_ALPHA_PNG: Da data is encoded accordin ta tha PNG justification. I aint talkin' bout chicken n' gravy biatch.  Red,
chronic n' blue, or gray, components is gamma encoded color
values n' is not premultiplied by tha alpha value.  The
alpha value be a linear measure of tha contribution of the
pixel ta tha correspondin final output pixel.

Yo ass should normally use dis format if you intend ta perform
color erection on tha color joints; most, maybe all, color
correction software has no handlin fo' tha alpha channel and,
anyway, tha math ta handle pre-multiplied component joints is
unnecessarily complex.

Before you do any arithmetic on tha component joints you need
to remove tha gamma encodin n' multiply up tha alpha
channel.  See tha PNG justification fo' mo' detail.  It is
important ta note dat when a image wit a alpha channel is
scaled, linear encoded, pre-multiplied component joints must
be used!

Da remainin modes assume you don't need ta do any further color erection or
that if you do, yo' color erection software knows all bout alpha (it
probably don't!)

    PNG_ALPHA_STANDARD:  Da data libpng produces
is encoded up in tha standard way
assumed by most erectly freestyled graphics software.
Da gamma encodin is ghon be removed by libpng n' the
linear component joints is ghon be pre-multiplied by the
alpha channel.

With dis format tha final image must be re-encoded to
match tha display gamma before tha image is displayed.
If yo' system don't do that, yet still seems to
perform arithmetic on tha pixels without decodin them,
it is fucked up - check up tha modes below.

With PNG_ALPHA_STANDARD libpng always produces linear
component joints, whatever screen_gamma you supply.  The
screen_gamma value is, however, used as a thugged-out default for
the file gamma if tha PNG file has no gamma shiznit.

If you call png_set_gamma() afta png_set_alpha_mode() you
will override tha linear encoding.  Instead the
pre-multiplied pixel joints is ghon be gamma encoded but
the alpha channel will still be linear. Shiiit, dis aint no joke.  This may
actually match tha requirementz of some fucked up software,
but it is unlikely.

While linear 8-bit data is often used it has
insufficient precision fo' any image wit a reasonable
dynamic range.  To avoid problems, n' if yo' software
supports it, use png_set_expand_16() ta force all
components ta 16 bits.

    PNG_ALPHA_OPTIMIZED: This mode is tha same
as PNG_ALPHA_STANDARD except that
completely opaque pixels is gamma encoded accordin to
the screen_gamma value.  Pixels wit alpha less than 1.0
will still have linear components.

Use dis format if you have control over your
compositin software n' so don't do other arithmetic
(like fuckin scaling) on tha data you git from libpng.  Your
compositin software can simply copy opaque pixels to
the output but still has linear joints fo' the
non-opaque pixels.

In aiiight compositing, where tha alpha channel encodes
partial pixel coverage (as opposed ta broad area
translucency), tha inaccuraciez of tha 8-bit
representation of non-opaque pixels is irrelevant.

Yo ass can also try dis format if yo' software is broken;
it might look better.

    PNG_ALPHA_BROKEN: This is PNG_ALPHA_STANDARD;
however, all component joints,
includin tha alpha channel is gamma encoded. Y'all KNOW dat shit, muthafucka!  This is
an appropriate format ta try if yo' software, or more
likely hardware, is straight-up broken, i.e., if it performs
linear arithmetic directly on gamma encoded joints.

In most casez of fucked up software or hardware tha bug up in tha final display
manifests as a subtle halo round composited partz of tha image.  Yo ass may not
even perceive dis as a halo; tha composited part of tha image may simply appear
separate from tha background, as though it had been cut outta paper n' pasted
on afterward.

If you don't gotta deal wit bugs up in software or hardware, or if you can fix
them, there be three recommended wayz of rockin png_set_alpha_mode():

   png_set_alpha_mode(png_ptr, PNG_ALPHA_PNG,
       screen_gamma);

Yo ass can do color erection on tha result (libpng do not currently
support color erection internally).  When you handle tha alpha channel
you need ta undo tha gamma encodin n' multiply up tha alpha.

   png_set_alpha_mode(png_ptr, PNG_ALPHA_STANDARD,
       screen_gamma);
   png_set_expand_16(png_ptr);

If yo ass is rockin tha high level intercourse, don't call png_set_expand_16();
instead pass PNG_TRANSFORM_EXPAND_16 ta tha intercourse.

With dis mode you can't do color erection yo, but you can do arithmetic,
includin composizzle n' scaling, on tha data without further processing.

   png_set_alpha_mode(png_ptr, PNG_ALPHA_OPTIMIZED,
       screen_gamma);

Yo ass can avoid tha expansion ta 16-bit components wit dis mode yo, but you
lose tha mobilitizzle ta scale tha image or big-ass up other linear arithmetic.
All you can do is compose tha result onto a matchin output.  Since this
mode is libpng-specific you also need ta write yo' own composition
software.

If you don't need, or can't handle, tha alpha channel you can call
png_set_background() ta remove it by compositin against a gangbangin' fixed color. Shiiit, dis aint no joke.  Don't
call png_set_strip_alpha() ta do dis - it will leave spurious pixel joints in
transparent partz of dis image.

   png_set_background(png_ptr, &background_color,
       PNG_BACKGROUND_GAMMA_SCREEN, 0, 1);

Da background_color be a RGB or grayscale value accordin ta tha data format
libpng will produce fo' yo thugged-out ass.  Because you don't yet know tha format of tha PNG
file, if you call png_set_background at dis point you must arrange fo' the
format produced by libpng ta always have 8-bit or 16-bit components n' then
store tha color as a 8-bit or 16-bit color as appropriate.  Da color gotz nuff
separate gray n' RGB component joints, so you can let libpng produce gray or
RGB output accordin ta tha input format yo, but low bit depth grayscale images
must always be converted ta at least 8-bit format.  (Even though low bit depth
grayscale images can't have a alpha channel they can gotz a transparent
color!)

Yo ass set tha transforms you need later, either as flags ta tha high level
interface or libpng API calls fo' tha low level intercourse.  For reference the
settings n' API calls required are:

8-bit joints:
   PNG_TRANSFORM_SCALE_16 | PNG_EXPAND
   png_set_expand(png_ptr); png_set_scale_16(png_ptr);

   If you must git exactly tha same inaccurate thangs up in dis biatch
   produced by default up in versions prior ta libpng-1.5.4,
   use PNG_TRANSFORM_STRIP_16 n' png_set_strip_16(png_ptr)
   instead.

16-bit joints:
   PNG_TRANSFORM_EXPAND_16
   png_set_expand_16(png_ptr);

In either case palette image data is ghon be expanded ta RGB.  If you just want
color data you can add PNG_TRANSFORM_GRAY_TO_RGB or png_set_gray_to_rgb(png_ptr)
to tha list.

Callin png_set_background before tha PNG file header is read aint gonna work
prior ta libpng-1.5.4.  Because tha failure may result up in unexpected warnings or
errors it is therefore much less thuggy ta booty-call png_set_background afta tha head has
been read. Y'all KNOW dat shit, muthafucka!  Unfortunately dis means dat prior ta libpng-1.5.4 it cannot be
used wit tha high level intercourse.

.SS Da high-level read intercourse

At dis point there be two ways ta proceed; all up in tha high-level
read intercourse, or all up in a sequence of low-level read operations.
Yo ass can use tha high-level intercourse if (a) yo ass is willin ta read
the entire image tha fuck into memory, n' (b) tha input transformations
you wanna do is limited ta tha followin set:

    PNG_TRANSFORM_IDENTITY      No transformation
    PNG_TRANSFORM_SCALE_16      Strip 16-bit samplez to
                                8-bit accurately
    PNG_TRANSFORM_STRIP_16      Chop 16-bit samplez to
                                8-bit less accurately
    PNG_TRANSFORM_STRIP_ALPHA   Discard tha alpha channel
    PNG_TRANSFORM_PACKING       Expand 1, 2 n' 4-bit
                                samplez ta bytes
    PNG_TRANSFORM_PACKSWAP      Chizzle order of packed
                                pixels ta LSB first
    PNG_TRANSFORM_EXPAND        Perform set_expand()
    PNG_TRANSFORM_INVERT_MONO   Invert monochrome images
    PNG_TRANSFORM_SHIFT         Normalize pixels ta the
                                sBIT depth
    PNG_TRANSFORM_BGR           Flip RGB ta BGR, RGBA
                                ta BGRA
    PNG_TRANSFORM_SWAP_ALPHA    Flip RGBA ta ARGB or GA
                                ta AG
    PNG_TRANSFORM_INVERT_ALPHA  Chizzle alpha from opacity
                                ta transparency
    PNG_TRANSFORM_SWAP_ENDIAN   Byte-swap 16-bit samples
    PNG_TRANSFORM_GRAY_TO_RGB   Expand grayscale samples
                                ta RGB (or GA ta RGBA)
    PNG_TRANSFORM_EXPAND_16     Expand samplez ta 16 bits

(This excludes settin a funky-ass background color, bustin gamma transformation,
quantizing, n' settin filler.)  If dis is tha case, simply do this:

    png_read_png(png_ptr, info_ptr, png_transforms, NULL)

where png_transforms be a integer containin tha bitwise OR of some
set of transformation flags.  This call is equivalent ta png_read_info(),
followed tha set of transformations indicated by tha transform mask,
then png_read_image(), n' finally png_read_end().

(Da final parameta of dis call aint yet used. Y'all KNOW dat shit, muthafucka!  Somedizzle it might point
to transformation parametas required by some future input transform.)

Yo ass must use png_transforms n' not call any png_set_transform() functions
when you use png_read_png().

Afta you have called png_read_png(), you can retrieve tha image data
with

   row_pointas = png_get_rows(png_ptr, info_ptr);

where row_pointas be a array of pointas ta tha pixel data fo' each row:

   png_bytep row_pointers[height];

If you know yo' image size n' pixel size ahead of time, you can allocate
row_pointas prior ta callin png_read_png() with

   if (height > PNG_UINT_32_MAX/(sizeof (png_byte)))
      png_error (png_ptr,
          "Image is too tall ta process up in memory");

   if (width > PNG_UINT_32_MAX/pixel_size)
      png_error (png_ptr,
          "Image is too wide ta process up in memory");

   row_pointas = png_malloc(png_ptr,
       height*(sizeof (png_bytep)));

   fo' (int i=0; i<height, i++)
      row_pointers[i]=NULL;  /* securitizzle precaution */

   fo' (int i=0; i<height, i++)
      row_pointers[i]=png_malloc(png_ptr,
          width*pixel_size);

   png_set_rows(png_ptr, info_ptr, &row_pointers);

Alternatively you could allocate yo' image up in one big-ass block n' define
row_pointers[i] ta point tha fuck into tha proper places up in yo' block.

If you use png_set_rows(), tha application is responsible fo' freeing
row_pointas (and row_pointers[i], if they was separately allocated).

If you don't allocate row_pointas ahead of time, png_read_png() will
do it, n' it'll be free'ed by libpng when you call png_destroy_*().

.SS Da low-level read intercourse

If yo ass is goin tha low-level route, yo ass is now locked n loaded ta read all
the file shiznit up ta tha actual image data.  Yo ass do dis wit a
call ta png_read_info().

    png_read_info(png_ptr, info_ptr);

This will process all chunks up ta but not includin tha image data.

This also copies a shitload of tha data from tha PNG file tha fuck into tha decode structure
for use up in lata transformations.  Important shiznit copied up in is:

1) Da PNG file gamma from tha gAMA chunk.  This overwrites tha default value
provided by a earlier call ta png_set_gamma or png_set_alpha_mode.

2) Prior ta libpng-1.5.4 tha background color from a funky-ass bKGd chunk.  This
damages tha shiznit provided by a earlier call ta png_set_background
resultin up in unexpected behavior. Shiiit, dis aint no joke.  Libpng-1.5.4 no longer do all dis bullshit.

3) Da number of dope bits up in each component value.  Libpng uses dis to
optimize gamma handlin by reducin tha internal lookup table sizes.

4) Da transparent color shiznit from a tRNS chunk.  This can be modified by
a lata call ta png_set_tRNS.

.SS Queryin tha info structure

Functions is used ta git tha shiznit from tha info_ptr once it
has been read. Y'all KNOW dat shit, muthafucka!  Note dat these fieldz may not be straight-up filled
in until png_read_end() has read tha chunk data followin tha image.

    png_get_IHDR(png_ptr, info_ptr, &width, &height,
       &bit_depth, &color_type, &interlace_type,
       &compression_type, &filter_method);

    width          - holdz tha width of tha image
                     up in pixels (up ta 2^31).

    height         - holdz tha height of tha image
                     up in pixels (up ta 2^31).

    bit_depth      - holdz tha bit depth of one of the
                     image channels.  (valid joints are
                     1, 2, 4, 8, 16 n' depend also on
                     tha color_type.  See also
                     dope bits (sBIT) below).

    color_type     - raps bout which color/alpha channels
                         is present.
                     PNG_COLOR_TYPE_GRAY
                        (bit depths 1, 2, 4, 8, 16)
                     PNG_COLOR_TYPE_GRAY_ALPHA
                        (bit depths 8, 16)
                     PNG_COLOR_TYPE_PALETTE
                        (bit depths 1, 2, 4, 8)
                     PNG_COLOR_TYPE_RGB
                        (bit_depths 8, 16)
                     PNG_COLOR_TYPE_RGB_ALPHA
                        (bit_depths 8, 16)

                     PNG_COLOR_MASK_PALETTE
                     PNG_COLOR_MASK_COLOR
                     PNG_COLOR_MASK_ALPHA

    interlace_type - (PNG_INTERLACE_NONE or
                     PNG_INTERLACE_ADAM7)

    compression_type - (must be PNG_COMPRESSION_TYPE_BASE
                     fo' PNG 1.0)

    filter_method  - (must be PNG_FILTER_TYPE_BASE
                     fo' PNG 1.0, n' can also be
                     PNG_INTRAPIXEL_DIFFERENCING if
                     tha PNG datastream is embedded in
                     a MNG-1.0 datastream)

    Any or all of interlace_type, compression_type, or
    filter_method can be NULL if yo ass is
    not horny bout they joints.

    Note dat png_get_IHDR() returns 32-bit data into
    tha applicationz width n' height variables.
    This be a unsafe thang if these is 16-bit
    variables.  In such thangs, the
    png_get_image_width() n' png_get_image_height()
    functions busted lyrics bout below is safer.

    width            = png_get_image_width(png_ptr,
                         info_ptr);

    height           = png_get_image_height(png_ptr,
                         info_ptr);

    bit_depth        = png_get_bit_depth(png_ptr,
                         info_ptr);

    color_type       = png_get_color_type(png_ptr,
                         info_ptr);

    interlace_type   = png_get_interlace_type(png_ptr,
                         info_ptr);

    compression_type = png_get_compression_type(png_ptr,
                         info_ptr);

    filter_method    = png_get_filter_type(png_ptr,
                         info_ptr);

    channels = png_get_channels(png_ptr, info_ptr);

    channels       - number of channelz of info fo' the
                     color type (valid joints is 1 (GRAY,
                     PALETTE), 2 (GRAY_ALPHA), 3 (RGB),
                     4 (RGB_ALPHA or RGB + filla byte))

    rowbytes = png_get_rowbytes(png_ptr, info_ptr);

    rowbytes       - number of bytes needed ta hold a row

    signature = png_get_signature(png_ptr, info_ptr);

    signature      - holdz tha signature read from the
                     file (if any).  Da data is kept in
                     tha same offset it would be if the
                     whole signature was read (i.e. if an
                     application had already read up in 4
                     bytez of signature before starting
                     libpng, tha remainin 4 bytes would
                     be up in signature[4] all up in signature[7]
                     (see png_set_sig_bytes())).

These is also blingin yo, but they validitizzle dependz on whether tha chunk
has been read. Y'all KNOW dat shit, muthafucka!  Da png_get_valid(png_ptr, info_ptr, PNG_INFO_<chunk>) and
png_get_<chunk>(png_ptr, info_ptr, ...) functions return non-zero if the
data has been read, or zero if it is missing.  Da parametas ta the
png_get_<chunk> is set directly if they is simple data types, or a
pointa tha fuck into tha info_ptr is returned fo' any complex types.

Da colorspace data from gAMA, cHRM, sRGB, iCCP, n' sBIT chunks
is simply moonwalked back ta give tha application shiznit bout how tha fuck the
image was encoded. Y'all KNOW dat shit, muthafucka!  Libpng itself only do transformations rockin tha file
gamma when combinin semitransparent pixels wit tha background color, and,
since libpng-1.6.0, when convertin between 8-bit sRGB n' 16-bit linear pixels
within tha simplified API.  Libpng also uses tha file gamma when converting
RGB ta gray, beginnin wit libpng-1.0.5, if tha application calls
png_set_rgb_to_gray()).

    png_get_PLTE(png_ptr, info_ptr, &palette,
                     &num_palette);

    palette        - tha palette fo' tha file
                     (array of png_color)

    num_palette    - number of entries up in tha palette

    png_get_gAMA(png_ptr, info_ptr, &file_gamma);
    png_get_gAMA_fixed(png_ptr, info_ptr, &int_file_gamma);

    file_gamma     - tha gamma at which tha file is
                     freestyled (PNG_INFO_gAMA)

    int_file_gamma - 100,000 times tha gamma at which the
                     file is written

    png_get_cHRM(png_ptr, info_ptr,  &white_x, &white_y, &red_x,
                     &red_y, &green_x, &green_y, &blue_x, &blue_y)
    png_get_cHRM_XYZ(png_ptr, info_ptr, &red_X, &red_Y, &red_Z,
                     &green_X, &green_Y, &green_Z, &blue_X, &blue_Y,
                     &blue_Z)
    png_get_cHRM_fixed(png_ptr, info_ptr, &int_white_x,
                     &int_white_y, &int_red_x, &int_red_y,
                     &int_green_x, &int_green_y, &int_blue_x,
                     &int_blue_y)
    png_get_cHRM_XYZ_fixed(png_ptr, info_ptr, &int_red_X, &int_red_Y,
                     &int_red_Z, &int_green_X, &int_green_Y,
                     &int_green_Z, &int_blue_X, &int_blue_Y,
                     &int_blue_Z)

    {white,red,green,blue}_{x,y}
                     A color space encodin specified rockin the
                     chromaticitizzlez of tha end points n' the
                     white point. (PNG_INFO_cHRM)

    {red,green,blue}_{X,Y,Z}
                     A color space encodin specified rockin the
                     encodin end points - tha CIE tristimulus
                     justification of tha intended color of tha red,
                     chronic n' blue channels up in tha PNG RGB data.
                     Da white point is simply tha sum of tha three
                     end points, n' you can put dat on yo' toast. (PNG_INFO_cHRM)

    png_get_sRGB(png_ptr, info_ptr, &srgb_intent);

    file_srgb_intent - tha renderin intent (PNG_INFO_sRGB)
                     Da presence of tha sRGB chunk
                     means dat tha pixel data is up in the
                     sRGB color space.  This chunk also
                     implies specific jointz of gAMA and
                     cHRM.

    png_get_iCCP(png_ptr, info_ptr, &name,
       &compression_type, &profile, &proflen);

    name             - Da flava name.

    compression_type - Da compression type; always
                       PNG_COMPRESSION_TYPE_BASE fo' PNG 1.0.
                       Yo ass may give NULL ta dis argument to
                       ignore dat shit.

    flava          - Internationistic Color Consortium color
                       flava data. May contain NULs.

    proflen          - length of flava data up in bytes.

    png_get_sBIT(png_ptr, info_ptr, &sig_bit);

    sig_bit        - tha number of dope bits for
                     (PNG_INFO_sBIT) each of tha gray,
                     red, green, n' blue channels,
                     whichever is appropriate fo' the
                     given color type (png_color_16)

    png_get_tRNS(png_ptr, info_ptr, &trans_alpha,
                     &num_trans, &trans_color);

    trans_alpha    - array of alpha (transparency)
                     entries fo' palette (PNG_INFO_tRNS)

    num_trans      - number of transparent entries
                     (PNG_INFO_tRNS)

    trans_color    - graylevel or color sample joints of
                     tha single transparent color for
                     non-paletted images (PNG_INFO_tRNS)

    png_get_hIST(png_ptr, info_ptr, &hist);
                     (PNG_INFO_hIST)

    hist           - histogram of palette (array of
                     png_uint_16)

    png_get_tIME(png_ptr, info_ptr, &mod_time);

    mod_time       - time image was last modified
                    (PNG_VALID_tIME)

    png_get_bKGD(png_ptr, info_ptr, &background);

    background     - background color (of type
                     png_color_16p) (PNG_VALID_bKGD)
                     valid 16-bit red, chronic n' blue
                     joints, regardless of color_type

    num_comments   = png_get_text(png_ptr, info_ptr,
                     &text_ptr, &num_text);

    num_comments   - number of comments

    text_ptr       - array of png_text holdin image
                     comments

    text_ptr[i].compression - type of compression used
                 on "text" PNG_TEXT_COMPRESSION_NONE
                           PNG_TEXT_COMPRESSION_zTXt
                           PNG_ITXT_COMPRESSION_NONE
                           PNG_ITXT_COMPRESSION_zTXt

    text_ptr[i].key   - keyword fo' comment.  Must contain
                         1-79 characters.

    text_ptr[i].text  - text comments fo' current
                         keyword. Y'all KNOW dat shit, muthafucka!  Can be empty.

    text_ptr[i].text_length - length of text string,
                 afta decompression, 0 fo' iTXt

    text_ptr[i].itxt_length - length of itxt string,
                 afta decompression, 0 fo' tEXt/zTXt

    text_ptr[i].lang  - language of comment (empty
                         strang fo' unknown).

    text_ptr[i].lang_key  - keyword up in UTF-8
                         (empty strang fo' unknown).

    Note dat tha itxt_length, lang, n' lang_key
    thugz of tha text_ptr structure only exist when the
    library is built wit iTXt chunk support.  Prior to
    libpng-1.4.0 tha library was built by default without
    iTXt support fo' realz. Also note dat when iTXt is supported,
    they contain NULL pointas when tha "compression"
    field gotz nuff PNG_TEXT_COMPRESSION_NONE or
    PNG_TEXT_COMPRESSION_zTXt.

    num_text       - number of comments (same as
                     num_comments; you can put NULL here
                     ta avoid tha duplication)

    Note while png_set_text() will accept text, language,
    n' translated keywordz dat can be NULL pointers, the
    structure returned by png_get_text will always contain
    regular zero-terminated C strings.  They might be
    empty strings but they aint NEVER gonna be NULL pointers.

    num_spalettes = png_get_sPLT(png_ptr, info_ptr,
       &palette_ptr);

    num_spalettes  - number of sPLT chunks read.

    palette_ptr    - array of palette structures holding
                     contentz of one or mo' sPLT chunks
                     read.

    png_get_oFFs(png_ptr, info_ptr, &offset_x, &offset_y,
       &unit_type);

    offset_x       - positizzle offset from tha left edge
                     of tha screen (can be negative)

    offset_y       - positizzle offset from tha top edge
                     of tha screen (can be negative)

    unit_type      - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER

    png_get_pHYs(png_ptr, info_ptr, &res_x, &res_y,
       &unit_type);

    res_x          - pixels/unit physical resolution in
                     x direction

    res_y          - pixels/unit physical resolution in
                     x direction

    unit_type      - PNG_RESOLUTION_UNKNOWN,
                     PNG_RESOLUTION_METER

    png_get_sCAL(png_ptr, info_ptr, &unit, &width,
       &height)

    unit        - physical scale units (an integer)

    width       - width of a pixel up in physical scale units

    height      - height of a pixel up in physical scale units
                 (width n' height is doubles)

    png_get_sCAL_s(png_ptr, info_ptr, &unit, &width,
       &height)

    unit        - physical scale units (an integer)

    width       - width of a pixel up in physical scale units
                  (expressed as a string)

    height      - height of a pixel up in physical scale units
                 (width n' height is strings like "2.54")

    num_unknown_chunks = png_get_unknown_chunks(png_ptr,
       info_ptr, &unknowns)

    unknowns          - array of png_unknown_chunk
                        structures holdin unknown chunks

    unknowns[i].name  - name of unknown chunk

    unknowns[i].data  - data of unknown chunk

    unknowns[i].size  - size of unknown chunkz data

    unknowns[i].location - posizzle of chunk up in file

    Da value of "i" correspondz ta tha order up in which the
    chunks was read from tha PNG file or banged wit the
    png_set_unknown_chunks() function.

    Da value of "location" be a funky-ass bitwise "or" of

         PNG_HAVE_IHDR  (0x01)
         PNG_HAVE_PLTE  (0x02)
         PNG_AFTER_IDAT (0x08)

Da data from tha pHYs chunk can be retrieved up in nuff muthafuckin convenient
forms:

    res_x = png_get_x_pixels_per_meter(png_ptr,
       info_ptr)

    res_y = png_get_y_pixels_per_meter(png_ptr,
       info_ptr)

    res_x_and_y = png_get_pixels_per_meter(png_ptr,
       info_ptr)

    res_x = png_get_x_pixels_per_inch(png_ptr,
       info_ptr)

    res_y = png_get_y_pixels_per_inch(png_ptr,
       info_ptr)

    res_x_and_y = png_get_pixels_per_inch(png_ptr,
       info_ptr)

    aspect_ratio = png_get_pixel_aspect_ratio(png_ptr,
       info_ptr)

    Each of these returns 0 [signifyin "unknown"] if
       tha data aint present or if res_x is 0;
       res_x_and_y is 0 if res_x != res_y

    Note dat cuz of tha way tha resolutions are
       stored internally, tha inch conversions won't
       come up ta exactly even number n' shit.  For example,
       72 dpi is stored as 0.28346 pixels/meter, and
       when dis is retrieved it is 71.9988 dpi, so
       be shizzle ta round tha returned value appropriately
       if you wanna display a reasonable-lookin result.

Da data from tha oFFs chunk can be retrieved up in nuff muthafuckin convenient
forms:

    x_offset = png_get_x_offset_microns(png_ptr, info_ptr);

    y_offset = png_get_y_offset_microns(png_ptr, info_ptr);

    x_offset = png_get_x_offset_inches(png_ptr, info_ptr);

    y_offset = png_get_y_offset_inches(png_ptr, info_ptr);

    Each of these returns 0 [signifyin "unknown" if both
       x n' y is 0] if tha data aint present or if the
       chunk is present but tha unit is tha pixel.  The
       remark bout inexact inch conversions applies here
       as well, cuz a value up in inches can't always be
       converted ta microns n' back without some loss
       of precision.

For mo' shiznit, peep the
PNG justification fo' chunk contents, n' you can put dat on yo' toast.  Be careful wit trusting
rowbytes, as a shitload of tha transformations could increase tha space
needed ta hold a row (expand, filler, gray_to_rgb, etc.).
See png_read_update_info(), below.

A quick word bout text_ptr n' num_text.  PNG stores comments in
keyword/text pairs, one pair per chunk, wit no limit on tha number
of text chunks, n' a 2^31 byte limit on they size.  While there are
suggested keywords, there is no requirement ta restrict tha use ta these
strings.  It be straight fuckin suggested dat keywordz n' text be sensible
to humans (thatz tha point), so don't use abbreviations.  Non-printing
symbols is not allowed. Y'all KNOW dat shit, muthafucka!  See tha PNG justification fo' mo' details.
There be also no requirement ta have text afta tha keyword.

Keywordz should be limited ta 79 Latin-1 charactas without leadin or
trailin spaces yo, but non-consecutizzle spaces is allowed within the
keyword. Y'all KNOW dat shit, muthafucka!  It be possible ta have tha same keyword any number of times.
Da text_ptr be a array of png_text structures, each holdin a
pointa ta a language string, a pointa ta a keyword n' a pointa to
a text string.  Da text string, language code, n' translated
keyword may be empty or NULL pointers.  Da keyword/text
pairs is put tha fuck into tha array up in tha order dat they is received.
But fuck dat shiznit yo, tha word on tha street is dat some or all of tha text chunks may be afta tha image, so, to
make shizzle you have read all tha text chunks, don't mess wit these
until afta you read tha shiznit afta tha image.  This will be
mentioned again n' again n' again below up in tha rap dat goes wit png_read_end().

.SS Input transformations

Afta you've read tha header shiznit, you can set up tha library
to handle any special transformationz of tha image data.  Da various
ways ta transform tha data is ghon be busted lyrics bout up in tha order dat they
should occur. Shiiit, dis aint no joke.  This is blingin, as a shitload of these chizzle tha color
type and/or bit depth of tha data, n' some others only work on
certain color types n' bit depths.

Transformations you request is ignored if they aint gots any meanin fo' a
particular input data format.  However some transformations can have a effect
as a result of a previous transformation. I aint talkin' bout chicken n' gravy biatch.  If you specify a cold-ass lil contradictory set of
transformations, fo' example both addin n' removin tha alpha channel, you
cannot predict tha final result.

Da color used fo' tha transparency joints should be supplied up in tha same
format/depth as tha current image data.  It be stored up in tha same format/depth
as tha image data up in a tRNS chunk, so dis is what tha fuck libpng expects fo' dis data.

Da color used fo' tha background value dependz on tha need_expand argument as
busted lyrics bout below.

Data is ghon be decoded tha fuck into tha supplied row buffers packed tha fuck into bytes
unless tha library has been holla'd at ta transform it tha fuck into another format.
For example, 4 bit/pixel paletted or grayscale data is ghon be returned
2 pixels/byte wit tha leftmost pixel up in tha high-order bitz of the
byte, unless png_set_packing() is called. Y'all KNOW dat shit, muthafucka!  8-bit RGB data is ghon be stored
in RGB RGB RGB format unless png_set_filler() or png_set_add_alpha()
is called ta bang filla bytes, either before or afta each RGB triplet.
16-bit RGB data is ghon be returned RRGGBB RRGGBB, wit da most thugged-out significant
byte of tha color value first, unless png_set_scale_16() is called to
transform it ta regular RGB RGB triplets, or png_set_filler() or
png_set_add alpha() is called ta bang filla bytes, either before or
afta each RRGGBB triplet.  Similarly, 8-bit or 16-bit grayscale data can
be modified wit png_set_filler(), png_set_add_alpha(), png_set_strip_16(),
or png_set_scale_16().

Da followin code transforms grayscale imagez of less than 8 ta 8 bits,
changes paletted images ta RGB, n' addz a gangbangin' full alpha channel if there is
transparency shiznit up in a tRNS chunk.  This is most useful on
grayscale images wit bit depthz of 2 or 4 or if there be a multiple-image
viewin application dat wishes ta treat all images up in tha same way.

    if (color_type == PNG_COLOR_TYPE_PALETTE)
        png_set_palette_to_rgb(png_ptr);

    if (png_get_valid(png_ptr, info_ptr,
        PNG_INFO_tRNS)) png_set_tRNS_to_alpha(png_ptr);

    if (color_type == PNG_COLOR_TYPE_GRAY &&
        bit_depth < 8) png_set_expand_gray_1_2_4_to_8(png_ptr);

Da first two functions is straight-up aliases fo' png_set_expand(), added
in libpng version 1.0.4, wit tha function names expanded ta improve code
readability.  In some future version they may straight-up do different
things.

Az of libpng version 1.2.9, png_set_expand_gray_1_2_4_to_8() was
added. Y'all KNOW dat shit, muthafucka!  It expandz tha sample depth without changin tRNS ta alpha.

Az of libpng version 1.5.2, png_set_expand_16() was added. Y'all KNOW dat shit, muthafucka!  It behaves as
png_set_expand(); however, tha resultant channels have 16 bits rather than 8.
Use dis when tha output color or gray channels is made linear ta avoid fairly
severe accuracy loss.

   if (bit_depth < 16)
      png_set_expand_16(png_ptr);

PNG can have filez wit 16 bits per channel.  If you only can handle
8 bits per channel, dis will strip tha pixels down ta 8-bit.

    if (bit_depth == 16)
#if PNG_LIBPNG_VER >= 10504
       png_set_scale_16(png_ptr);
#else
       png_set_strip_16(png_ptr);
#endif

(Da mo' accurate "png_set_scale_16()" API became available up in libpng version
1.5.4).

If you need ta process tha alpha channel on tha image separately from tha image
data (for example if you convert it ta a funky-ass bitmap mask) it is possible ta have
libpng strip tha channel leavin just RGB or gray data:

    if (color_type & PNG_COLOR_MASK_ALPHA)
       png_set_strip_alpha(png_ptr);

If you strip tha alpha channel you need ta find some other way of dealin with
the shiznit. I aint talkin' bout chicken n' gravy biatch.  If, instead, you wanna convert tha image ta a opaque
version wit no alpha channel use png_set_background; peep below.

Az of libpng version 1.5.2, almost all useful expansions is supported, the
major ommissions is conversion of grayscale ta indexed images (which can be
done trivially up in tha application) n' conversion of indexed ta grayscale (which
can be done by a trivial manipulation of tha palette.)

In tha followin table, tha 01 means grayscale wit depth<8, 31 means
indexed wit depth<8, other numerals represent tha color type, "T" means
the tRNS chunk is present, A means a alpha channel is present, n' O
means tRNS or alpha is present but all pixels up in tha image is opaque.

  FROM  01  31   0  0T  0O   2  2T  2O   3  3T  3O  4A  4O  6A  6O
   TO
   01    -  [G]  -   -   -   -   -   -   -   -   -   -   -   -   -
   31   [Q]  Q  [Q] [Q] [Q]  Q   Q   Q   Q   Q   Q  [Q] [Q]  Q   Q
    0    1   G   +   .   .   G   G   G   G   G   G   B   B  GB  GB
   0T    lt  Gt  t   +   .   Gt  G   G   Gt  G   G   Bt  Bt GBt GBt
   0O    lt  Gt  t   .   +   Gt  Gt  G   Gt  Gt  G   Bt  Bt GBt GBt
    2    C   P   C   C   C   +   .   .   C   -   -  CB  CB   B   B
   2T    Ct  -   Ct  C   C   t   +   t   -   -   -  CBt CBt  Bt  Bt
   2O    Ct  -   Ct  C   C   t   t   +   -   -   -  CBt CBt  Bt  Bt
    3   [Q]  p  [Q] [Q] [Q]  Q   Q   Q   +   .   .  [Q] [Q]  Q   Q
   3T   [Qt] p  [Qt][Q] [Q]  Qt  Qt  Qt  t   +   t  [Qt][Qt] Qt  Qt
   3O   [Qt] p  [Qt][Q] [Q]  Qt  Qt  Qt  t   t   +  [Qt][Qt] Qt  Qt
   4A    lA  G   A   T   T   GA  GT  GT  GA  GT  GT  +   BA  G  GBA
   4O    lA GBA  A   T   T   GA  GT  GT  GA  GT  GT  BA  +  GBA  G
   6A    CA  PA  CA  C   C   A   T  tT   PA  P   P   C  CBA  +   BA
   6O    CA PBA  CA  C   C   A  tT   T   PA  P   P  CBA  C   BA  +

Within tha matrix,
     "+" identifies entries where 'from' n' 'to' is tha same.
     "-" means tha transformation aint supported.
     "." means not a god damn thang is necessary (a tRNS chunk can just be ignored).
     "t" means tha transformation is obtained by png_set_tRNS.
     "A" means tha transformation is obtained by png_set_add_alpha().
     "X" means tha transformation is obtained by png_set_expand().
     "1" means tha transformation is obtained by
         png_set_expand_gray_1_2_4_to_8() (and by png_set_expand()
         if there is no transparency up in tha original gangsta or tha final
         format).
     "C" means tha transformation is obtained by png_set_gray_to_rgb().
     "G" means tha transformation is obtained by png_set_rgb_to_gray().
     "P" means tha transformation is obtained by
         png_set_expand_palette_to_rgb().
     "p" means tha transformation is obtained by png_set_packing().
     "Q" means tha transformation is obtained by png_set_quantize().
     "T" means tha transformation is obtained by
         png_set_tRNS_to_alpha().
     "B" means tha transformation is obtained by
         png_set_background(), or png_strip_alpha().

When a entry has multiple transforms listed all is required ta cause the
right overall transformation. I aint talkin' bout chicken n' gravy biatch.  When two transforms is separated by a cold-ass lil comma
either will do tha thang.  When transforms is enclosed up in [] tha transform should
do tha thang but dis is currently unimplemented - a gangbangin' finger-lickin' different format will result
if tha suggested transformations is used.

In PNG files, tha alpha channel up in a image
is tha level of opacity.  If you need tha alpha channel up in a image to
be tha level of transparency instead of opacity, you can invert the
alpha channel (or tha tRNS chunk data) afta itz read, so dat 0 is
fully opaque n' 255 (in 8-bit or paletted images) or 65535 (in 16-bit
images) is straight-up transparent, with

    png_set_invert_alpha(png_ptr);

PNG filez pack pixelz of bit depths 1, 2, n' 4 tha fuck into bytes as lil' small-ass as
they can, resultin in, fo' example, 8 pixels per byte fo' 1 bit
files.  This code expandz ta 1 pixel per byte without changin the
valuez of tha pixels:

    if (bit_depth < 8)
       png_set_packing(png_ptr);

PNG filez have possible bit depthz of 1, 2, 4, 8, n' 16.  All pixels
stored up in a PNG image done been "scaled" or "shifted" up ta tha next
higher possible bit depth (e.g. from 5 bits/sample up in tha range [0,31]
to 8 bits/sample up in tha range [0, 255]).  But fuck dat shiznit yo, tha word on tha street is dat it be also possible
to convert tha PNG pixel data back ta tha original gangsta bit depth of the
image.  This call reduces tha pixels back down ta tha original gangsta bit depth:

    png_color_8p sig_bit;

    if (png_get_sBIT(png_ptr, info_ptr, &sig_bit))
       png_set_shift(png_ptr, sig_bit);

PNG filez store 3-color pixels up in red, green, blue order n' shit.  This code
changes tha storage of tha pixels ta blue, green, red:

    if (color_type == PNG_COLOR_TYPE_RGB ||
        color_type == PNG_COLOR_TYPE_RGB_ALPHA)
       png_set_bgr(png_ptr);

PNG filez store RGB pixels packed tha fuck into 3 or 6 bytes. This code expandz them
into 4 or 8 bytes fo' windowin systems dat need dem up in dis format:

    if (color_type == PNG_COLOR_TYPE_RGB)
       png_set_filler(png_ptr, filler, PNG_FILLER_BEFORE);

where "filler" is tha 8 or 16-bit number ta fill with, n' tha location is
either PNG_FILLER_BEFORE or PNG_FILLER_AFTER, dependin upon whether
you want tha filla before tha RGB or afta n' shit.  This transformation
does not affect images dat already have full alpha channels.  To add an
opaque alpha channel, use filler=0xff or 0xffff n' PNG_FILLER_AFTER which
will generate RGBA pixels.

Note dat png_set_filler() do not chizzle tha color type.  If you want
to do that, you can add a legit alpha channel with

    if (color_type == PNG_COLOR_TYPE_RGB ||
       color_type == PNG_COLOR_TYPE_GRAY)
       png_set_add_alpha(png_ptr, filler, PNG_FILLER_AFTER);

where "filler" gotz nuff tha alpha value ta assign ta each pixel.
This function was added up in libpng-1.2.7.

If yo ass is readin a image wit a alpha channel, n' you need the
data as ARGB instead of tha aiiight PNG format RGBA:

    if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)
       png_set_swap_alpha(png_ptr);

For some uses, you may want a grayscale image ta be represented as
RGB.  This code will do dat conversion:

    if (color_type == PNG_COLOR_TYPE_GRAY ||
        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
       png_set_gray_to_rgb(png_ptr);

Conversely, you can convert a RGB or RGBA image ta grayscale or grayscale
with alpha.

    if (color_type == PNG_COLOR_TYPE_RGB ||
        color_type == PNG_COLOR_TYPE_RGB_ALPHA)
       png_set_rgb_to_gray(png_ptr, error_action,
          double red_weight, double green_weight);

    error_action = 1: silently do tha conversion

    error_action = 2: issue a warnin if tha original
                      image has any pixel where
                      red != chronic or red != blue

    error_action = 3: issue a error n' abort the
                      conversion if tha original
                      image has any pixel where
                      red != chronic or red != blue

    red_weight:       weight of red component

    green_weight:     weight of chronic component
                      If either weight is negative, default
                      weights is used.

In tha correspondin fixed point API tha red_weight n' green_weight joints are
simply scaled by 100,000:

    png_set_rgb_to_gray(png_ptr, error_action,
       png_fixed_point red_weight,
       png_fixed_point green_weight);

If you have set error_action = 1 or 2, you can
lata check whether tha image straight-up was gray, afta processing
the image rows, wit tha png_get_rgb_to_gray_status(png_ptr) function.
It will return a png_byte dat is zero if tha image was gray or
1 if there was any non-gray pixels.  Background n' sBIT data
will be silently converted ta grayscale, rockin tha chronic channel
data fo' sBIT, regardless of tha error_action setting.

Da default joints come from tha PNG file cHRM chunk if present; otherwise, the
defaults correspond ta tha ITU-R recommendation 709, n' also tha sRGB color
space, as recommended up in tha Charlez Poyntonz Colour FAQUIZZY,
<http://www.poynton.com/>, up in section 9:

   <http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html#RTFToC9>

    Y = 0.2126 * R + 0.7152 * G + 0.0722 * B

Previous versionz of dis document, 1998 all up in 2002, recommended a slightly
different formula:

    Y = 0.212671 * R + 0.715160 * G + 0.072169 * B

Libpng uses a integer approximation:

    Y = (6968 * R + 23434 * G + 2366 * B)/32768

Da calculation is done up in a linear colorspace, if tha image gamma
can be determined.

Da png_set_background() function has been busted lyrics bout already; it  drops some lyrics ta libpng to
composite images wit alpha or simple transparency against tha supplied
background color. Shiiit, dis aint no joke.  For compatibilitizzle wit versionz of libpng earlier than
libpng-1.5.4 it is recommended dat you call tha function afta readin tha file
header, even if you don't wanna use tha color up in a funky-ass bKGD chunk, if one exists.

If tha PNG file gotz nuff a funky-ass bKGD chunk (PNG_INFO_bKGD valid),
you may use dis color, or supply another color mo' suitable for
the current display (e.g., tha background color from a wizzy page).  You
need ta tell libpng how tha fuck tha color is represented, both tha format of the
component joints up in tha color (the number of bits) n' tha gamma encodin of the
color. Shiiit, dis aint no joke.  Da function takes two arguments, background_gamma_mode n' need_expand
to convey dis shiznit; however, only two combinations is likely ta be
useful:

    png_color_16 my_background;
    png_color_16p image_background;

    if (png_get_bKGD(png_ptr, info_ptr, &image_background))
       png_set_background(png_ptr, image_background,
           PNG_BACKGROUND_GAMMA_FILE, 1/*needz ta be expanded*/, 1);
    else
       png_set_background(png_ptr, &my_background,
           PNG_BACKGROUND_GAMMA_SCREEN, 0/*do not expand*/, 1);

Da second call was busted lyrics bout above - my_background is up in tha format of the
final, display, output produced by libpng.  Because you now know tha format of
the PNG it is possible ta avoid tha need ta chizzle either 8-bit or 16-bit
output n' ta retain palette images (the palette flavas is ghon be modified
appropriately n' tha tRNS chunk removed.)  But fuck dat shiznit yo, tha word on tha street is dat if yo ass is bustin this,
take pimped out care not ta ask fo' transformations without checkin first that
they apply!

In tha straight-up original gangsta call tha background color has tha original gangsta bit depth n' color type
of tha PNG file.  So, fo' palette images tha color is supplied as a palette
index n' fo' low bit greyscale images tha color be a reduced bit value in
image_background->gray.

If you didn't call png_set_gamma() before readin tha file header, fo' example
if you need yo' code ta remain compatible wit olda versionz of libpng prior
to libpng-1.5.4, dis is tha place ta booty-call dat shit.

Do not call it if you called png_set_alpha_mode(); bustin so will damage the
settings put up in place by png_set_alpha_mode().  (If png_set_alpha_mode() is
supported then you can certainly do png_set_gamma() before readin tha PNG
header.)

This API unconditionally sets tha screen n' file gamma joints, so it will
override tha value up in tha PNG file unless it is called before tha PNG file
readin starts, n' you can put dat on yo' toast.  For dis reason you must always call it wit tha PNG file
value when you call it up in dis position:

   if (png_get_gAMA(png_ptr, info_ptr, &file_gamma))
      png_set_gamma(png_ptr, screen_gamma, file_gamma);

   else
      png_set_gamma(png_ptr, screen_gamma, 0.45455);

If you need ta reduce a RGB file ta a paletted file, or if a paletted
file has mo' entries then will fit on yo' screen, png_set_quantize()
will do dis shit.  Note dat dis be a simple match quantization dat merely
findz tha closest color available.  This should work fairly well with
optimized palettes yo, but fairly badly wit linear color cubes.  If you
pass a palette dat is larger than maximum_colors, tha file will
reduce tha number of flavas up in tha palette so it will fit into
maximum_colors.  If there be a histogram, libpng will use it ta make
more intelligent chizzlez when reducin tha palette.  If there is no
histogram, it may not do as phat a thang.

   if (color_type & PNG_COLOR_MASK_COLOR)
   {
      if (png_get_valid(png_ptr, info_ptr,
          PNG_INFO_PLTE))
      {
         png_uint_16p histogram = NULL;

         png_get_hIST(png_ptr, info_ptr,
             &histogram);
         png_set_quantize(png_ptr, palette, num_palette,
            max_screen_colors, histogram, 1);
      }

      else
      {
         png_color std_color_cube[MAX_SCREEN_COLORS] =
            { ... flavas ... };

         png_set_quantize(png_ptr, std_color_cube,
            MAX_SCREEN_COLORS, MAX_SCREEN_COLORS,
            NULL,0);
      }
   }

PNG filez describe monochrome as black bein zero n' white bein one.
Da followin code will reverse dis (make black be one n' white be
zero):

   if (bit_depth == 1 && color_type == PNG_COLOR_TYPE_GRAY)
      png_set_invert_mono(png_ptr);

This function can also be used ta invert grayscale n' gray-alpha images:

   if (color_type == PNG_COLOR_TYPE_GRAY ||
       color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      png_set_invert_mono(png_ptr);

PNG filez store 16-bit pixels up in network byte order (big-endian,
ie. most dope bits first).  This code chizzlez tha storage ta the
other way (lil-endian, i.e. least dope bits first, the
way PCs store them):

    if (bit_depth == 16)
       png_set_swap(png_ptr);

If yo ass is rockin packed-pixel images (1, 2, or 4 bits/pixel), n' you
need ta chizzle tha order tha pixels is packed tha fuck into bytes, you can use:

    if (bit_depth < 8)
       png_set_packswap(png_ptr);

Finally, you can write yo' own transformation function if none of
the existin ones meets yo' needs.  This is done by settin a cold-ass lil callback
with

    png_set_read_user_transform_fn(png_ptr,
        read_transform_fn);

Yo ass must supply tha function

    void read_transform_fn(png_structp png_ptr, png_row_infop
        row_info, png_bytep data)

See pngtest.c fo' a hustlin example.  Yo crazy-ass function is ghon be called
afta all of tha other transformations done been processed. Y'all KNOW dat shit, muthafucka!  Take care with
interlaced images if you do tha interlace yo ass - tha width of tha row is the
width up in 'row_info', not tha overall image width.

If supported, libpng serves up two shiznit routines dat you can use ta find
where yo ass is up in processin tha image:

   png_get_current_pass_number(png_structp png_ptr);
   png_get_current_row_number(png_structp png_ptr);

Don't try rockin these outside a transform callback - firstly they is only
supported if user transforms is supported, secondly they may well return
unexpected thangs up in dis biatch unless tha row is straight-up bein processed all up in tha moment they
are called.

With interlaced
images tha value returned is tha row up in tha input sub-image image.  Use
PNG_ROW_FROM_PASS_ROW(row, pass) n' PNG_COL_FROM_PASS_COL(col, pass) to
find tha output pixel (x,y) given a interlaced sub-image pixel (row,col,pass).

Da rap of interlace handlin above gotz nuff mo' shiznit on how tha fuck to
use these joints.

Yo ass can also set up a pointa ta a user structure fo' use by your
callback function, n' you can inform libpng dat yo' transform
function will chizzle tha number of channels or bit depth wit the
function

    png_set_user_transform_info(png_ptr, user_ptr,
        user_depth, user_channels);

Da userz application, not libpng, is responsible fo' allocatin and
freein any memory required fo' tha user structure.

Yo ass can retrieve tha pointa via tha function
png_get_user_transform_ptr().  For example:

    voidp read_user_transform_ptr =
        png_get_user_transform_ptr(png_ptr);

Da last thang ta handle is interlacing; dis is covered up in detail below,
but you must call tha function here if you want libpng ta handle expansion
of tha interlaced image.

    number_of_passes = png_set_interlace_handling(png_ptr);

Afta settin tha transformations, libpng can update yo' png_info
structure ta reflect any transformations you've axed wit this
call.

    png_read_update_info(png_ptr, info_ptr);

This is most useful ta update tha info structurez rowbytes
field so you can use it ta allocate yo' image memory.  This function
will also update yo' palette wit tha erect screen_gamma and
background if these done been given wit tha calls above.  Yo ass may
only call png_read_update_info() once wit a particular info_ptr.

Afta you call png_read_update_info(), you can allocate any
memory you need ta hold tha image.  Da row data is simply
raw byte data fo' all formz of images.  As tha actual allocation
varies among applications, no example is ghon be given. I aint talkin' bout chicken n' gravy biatch.  If you
are allocatin one big-ass chunk, yo big-ass booty is ghon need ta build an
array of pointas ta each row, as it is ghon be needed fo' some
of tha functions below.

Remember: Before you call png_read_update_info(), tha png_get_*()
functions return tha joints correspondin ta tha original gangsta PNG image.
Afta you call png_read_update_info tha joints refer ta tha image
that libpng will output.  Consequently you must call all tha png_set_
functions before you call png_read_update_info().  This is particularly
important fo' png_set_interlace_handling() - if yo ass is goin ta call
png_read_update_info() you must call png_set_interlace_handling() before
it unless you wanna receive interlaced output.

.SS Readin image data

Afta you've allocated memory, you can read tha image data.
Da simplest way ta do dis is up in one function call.  If yo ass is
allocatin enough memory ta hold tha whole image, you can just
call png_read_image() n' libpng will read up in all tha image data
and put it up in tha memory area supplied. Y'all KNOW dat shit, muthafucka!  Yo ass will need ta pass in
an array of pointas ta each row.

This function automatically handlez interlacing, so you don't
need ta booty-call png_set_interlace_handling() (unless you call
png_read_update_info()) or call dis function multiple times, or any
of dat other shiznit necessary wit png_read_rows().

   png_read_image(png_ptr, row_pointers);

where row_pointas is:

   png_bytep row_pointers[height];

Yo ass can point ta void or char or whatever you use fo' pixels.

If you don't wanna read up in tha whole image at once, you can
use png_read_rows() instead. Y'all KNOW dat shit, muthafucka!  If there is no interlacin (check
interlace_type == PNG_INTERLACE_NONE), dis is simple:

    png_read_rows(png_ptr, row_pointers, NULL,
        number_of_rows);

where row_pointas is tha same ol' dirty as up in tha png_read_image() call.

If yo ass is bustin dis just one row at a time, you can do dis with
a single row_pointa instead of a array of row_pointers:

    png_bytep row_pointa = row;
    png_read_row(png_ptr, row_pointer, NULL);

If tha file is interlaced (interlace_type != 0 up in tha IHDR chunk), thangs
get somewhat harder n' shit.  Da only current (PNG Justification version 1.2)
interlacin type fo' PNG is (interlace_type == PNG_INTERLACE_ADAM7);
a somewhat fucked up 2D interlace scheme, known as Adam7, that
breaks down a image tha fuck into seven smalla imagez of varyin size, based
on a 8x8 grid. Y'all KNOW dat shit, muthafucka!  This number is defined (from libpng 1.5) as
PNG_INTERLACE_ADAM7_PASSES up in png.h

libpng can fill up dem images or it can give dem ta you "as is".
It be almost always betta ta have libpng handle tha interlacin fo' yo thugged-out ass.
If you want tha images filled out, there be two ways ta do dis shit.  Da one
mentioned up in tha PNG justification is ta expand each pixel ta cover
those pixels dat aint been read yet (the "rectangle" method).
This thangs up in dis biatch up in a funky-ass blocky image fo' tha straight-up original gangsta pass, which gradually
smooths up as mo' pixels is read. Y'all KNOW dat shit, muthafucka!  Da other method is tha "sparkle"
method, where pixels is drawn only up in they final locations, wit the
rest of tha image remainin whatever flavas they was initialized to
before tha start of tha read. Y'all KNOW dat shit, muthafucka!  Da first method probably looks better,
but tendz ta be slower, as there be mo' pixels ta put up in tha rows.

If, as is likely, you want libpng ta expand tha images, call dis before
callin png_start_read_image() or png_read_update_info():

    if (interlace_type == PNG_INTERLACE_ADAM7)
       number_of_passes
           = png_set_interlace_handling(png_ptr);

This will return tha number of passes needed. Y'all KNOW dat shit, muthafucka!  Currently, dis is seven,
but may chizzle if another interlace type be added. Y'all KNOW dat shit, muthafucka!  This function can be
called even if tha file aint interlaced, where it will return one pass.
Yo ass then need ta read tha whole image 'number_of_passes' times.  Each time
will distribute tha pixels from tha current pass ta tha erect place in
the output image, so you need ta supply tha same rows ta png_read_rows in
each pass.

If yo ass is not goin ta display tha image afta each pass yo, but are
goin ta wait until tha entire image is read in, use tha sparkle
effect.  This effect is fasta n' tha end result of either method
is exactly tha same.  If yo ass is plannin on displayin tha image
afta each pass, tha "rectangle" effect is generally considered the
betta lookin one.

If you only want tha "sparkle" effect, just call png_read_rows() as
normal, wit tha third parameta NULL.  Make shizzle you make pass over
the image number_of_passes times, n' you don't chizzle tha data up in the
rows between calls.  Yo ass can chizzle tha locationz of tha data, just
not tha data.  Each pass only writes tha pixels appropriate fo' that
pass, n' assumes tha data from previous passes is still valid.

    png_read_rows(png_ptr, row_pointers, NULL,
        number_of_rows);

If you only want tha straight-up original gangsta effect (the rectangles), do tha same as
before except pass tha row buffer up in tha third parameter, n' leave
the second parameta NULL.

    png_read_rows(png_ptr, NULL, row_pointers,
        number_of_rows);

If you don't want libpng ta handle tha interlacin details, just call
png_read_rows() PNG_INTERLACE_ADAM7_PASSES times ta read up in all tha images.
Each of tha images be a valid image by itself; however, yo big-ass booty is ghon almost
certainly need ta distribute tha pixels from each sub-image ta the
correct place.  This is where every last muthafuckin thang gets straight-up tricky.

If you wanna retrieve tha separate images you must pass tha erect
number of rows ta each successive call of png_read_rows().  Da calculation
gets pretty fucked up fo' lil' small-ass images, where some sub-images may
not even exist cuz either they width or height endz up zero.
libpng serves up two macros ta help you up in 1.5 n' lata versions:

   png_uint_32 width = PNG_PASS_COLS(image_width, pass_number);
   png_uint_32 height = PNG_PASS_ROWS(image_height, pass_number);

Respectively these rap  tha width n' height of tha sub-image
correspondin ta tha numbered pass.  'pass' is up in in tha range 0 ta 6 -
this can be confusin cuz tha justification refers ta tha same passes
as 1 ta 7!  Be careful, you must check both tha width n' height before
callin png_read_rows() n' not call it fo' dat pass if either is zero.

Yo ass can, of course, read each sub-image row by row.  If you want to
produce optimal code ta cook up a pixel-by-pixel transformation of an
interlaced image dis is tha dopest approach; read each row of each pass,
transform it, n' write it up ta a freshly smoked up interlaced image.

If you wanna de-interlace tha image yo ass libpng serves up further
macros ta help dat rap  where ta place tha pixels up in tha output image.
Because tha interlacin scheme is rectangular - sub-image pixels is always
arranged on a rectangular grid - all you need ta know fo' each pass is the
startin column n' row up in tha output image of tha straight-up original gangsta pixel plus the
spacin between each pixel.  Az of libpng 1.5 there be four macros to
retrieve dis shiznit:

   png_uint_32 x = PNG_PASS_START_COL(pass);
   png_uint_32 y = PNG_PASS_START_ROW(pass);
   png_uint_32 xStep = 1U << PNG_PASS_COL_SHIFT(pass);
   png_uint_32 yStep = 1U << PNG_PASS_ROW_SHIFT(pass);

These allow you ta write tha obvious loop:

   png_uint_32 input_y = 0;
   png_uint_32 output_y = PNG_PASS_START_ROW(pass);

   while (output_y < output_image_height)
   {
      png_uint_32 input_x = 0;
      png_uint_32 output_x = PNG_PASS_START_COL(pass);

      while (output_x < output_image_width)
      {
         image[output_y][output_x] =
             subimage[pass][input_y][input_x++];

         output_x += xStep;
      }

      ++input_y;
      output_y += yStep;
   }

Notice dat tha steps between successive output rows n' columns are
returned as shifts, n' you can put dat on yo' toast.  This is possible cuz tha pixels up in tha subimages
are always a juice of 2 apart - 1, 2, 4 or 8 pixels - up in tha original
image.  In practice you may need ta directly calculate tha output coordinate
given a input coordinate.  libpng serves up two further macros fo' this
purpose:

   png_uint_32 output_x = PNG_COL_FROM_PASS_COL(input_x, pass);
   png_uint_32 output_y = PNG_ROW_FROM_PASS_ROW(input_y, pass);

Finally a pair of macros is provided ta rap  if a particular image
row or column appears up in a given pass:

   int col_in_pass = PNG_COL_IN_INTERLACE_PASS(output_x, pass);
   int row_in_pass = PNG_ROW_IN_INTERLACE_PASS(output_y, pass);

Bear up in mind dat yo big-ass booty is ghon probably also need ta check tha width n' height
of tha pass up in addizzle ta tha above ta be shizzle tha pass even exists!

With any luck yo ass is convinced by now dat you don't wanna do yo' own
interlace handling.  In realitizzle normally tha only phat reason fo' bustin this
is if yo ass is processin PNG filez on a pixel-by-pixel basis n' don't want
to load tha whole file tha fuck into memory when it is interlaced.

libpng includes a test program, pngvalid, dat illustrates readin and
writin of interlaced images.  If you can't git interlacin ta work up in your
code n' don't wanna leave it ta libpng (the recommended approach), see
how pngvalid.c do dat shit.

.SS Finishin a sequential read

Afta yo ass is finished readin tha image all up in the
low-level intercourse, you can finish readin tha file.  If yo ass is
horny bout comments or time, which may be stored either before or
afta tha image data, you should pass tha separate png_info struct if
you wanna keep tha comments from before n' afta tha image
separate.

    png_infop end_info = png_create_info_struct(png_ptr);

    if (!end_info)
    {
       png_destroy_read_struct(&png_ptr, &info_ptr,
           (png_infopp)NULL);
       return (ERROR);
    }

   png_read_end(png_ptr, end_info);

If yo ass is not interested, you should still call png_read_end()
but you can pass NULL, avoidin tha need ta create a end_info structure.

   png_read_end(png_ptr, (png_infop)NULL);

If you don't call png_read_end(), then yo' file pointa will be
left pointin ta tha straight-up original gangsta chunk afta tha last IDAT, which is probably
not what tha fuck you want if you expect ta read suttin' beyond tha end of
the PNG datastream.

When yo ass is done, you can free all memory allocated by libpng like this:

   png_destroy_read_struct(&png_ptr, &info_ptr,
       &end_info);

or, if you didn't create a end_info structure,

   png_destroy_read_struct(&png_ptr, &info_ptr,
       (png_infopp)NULL);

It be also possible ta individually free tha info_ptr thugz that
point ta libpng-allocated storage wit tha followin function:

    png_free_data(png_ptr, info_ptr, mask, seq)

    mask - identifies data ta be freed, a mask
           containin tha bitwise OR of one or
           mo' of
             PNG_FREE_PLTE, PNG_FREE_TRNS,
             PNG_FREE_HIST, PNG_FREE_ICCP,
             PNG_FREE_PCAL, PNG_FREE_ROWS,
             PNG_FREE_SCAL, PNG_FREE_SPLT,
             PNG_FREE_TEXT, PNG_FREE_UNKN,
           or simply PNG_FREE_ALL

    seq  - sequence number of item ta be freed
           (\-1 fo' all items)

This function may be safely called when tha relevant storage has
already been freed, or has not yet been allocated, or was allocated
by tha user n' not by libpng,  n' will up in dem cases do nothing.
Da "seq" parameta is ignored if only one item of tha selected data
type, like fuckin PLTE, be allowed. Y'all KNOW dat shit, muthafucka!  If "seq" aint \-1, n' multiple items
are allowed fo' tha data type identified up in tha mask, like fuckin text or
sPLT, only tha n'th item up in tha structure is freed, where n is "seq".

Da default behavior is only ta free data dat was allocated internally
by libpng.  This can be chizzled, so dat libpng aint gonna free tha data,
or so dat it will free data dat was allocated by tha user wit png_malloc()
or png_calloc() n' passed up in via a png_set_*() function, with

    png_data_freer(png_ptr, info_ptr, freer, mask)

    freer  - one of
               PNG_DESTROY_WILL_FREE_DATA
               PNG_SET_WILL_FREE_DATA
               PNG_USER_WILL_FREE_DATA

    mask   - which data elements is affected
             same chizzlez as up in png_free_data()

This function only affects data dat has already been allocated.
Yo ass can call dis function afta readin tha PNG data but before calling
any png_set_*() functions, ta control whether tha user or tha png_set_*()
function is responsible fo' freein any existin data dat might be present,
and again n' again n' again afta tha png_set_*() functions ta control whether tha user
or png_destroy_*() is supposed ta free tha data.  When tha user assumes
responsibilitizzle fo' libpng-allocated data, tha application must use
png_free() ta free it, n' when tha user transfers responsibilitizzle ta libpng
for data dat tha user has allocated, tha user must have used png_malloc()
or png_calloc() ta allocate dat shit.

If you allocated yo' row_pointas up in a single block, as suggested above in
the description of tha high level read intercourse, you must not transfer
responsibilitizzle fo' freein it ta tha png_set_rows or png_read_destroy function,
because they would also try ta free tha individual row_pointers[i].

If you allocated text_ptr.text, text_ptr.lang, n' text_ptr.translated_keyword
separately, do not transfer responsibilitizzle fo' freein text_ptr ta libpng,
because when libpng fills a png_text structure it combines these thugz with
the key member, n' png_free_data() will free only text_ptr.key.  Similarly,
if you transfer responsibilitizzle fo' free'in text_ptr from libpng ta your
application, yo' application must not separately free dem members.

Da png_free_data() function will turn off tha "valid" flag fo' anything
it frees.  If you need ta turn tha flag off fo' a cold-ass lil chunk dat was freed by
your application instead of by libpng, you can use

    png_set_invalid(png_ptr, info_ptr, mask);

    mask - identifies tha chunks ta be made invalid,
           containin tha bitwise OR of one or
           mo' of
             PNG_INFO_gAMA, PNG_INFO_sBIT,
             PNG_INFO_cHRM, PNG_INFO_PLTE,
             PNG_INFO_tRNS, PNG_INFO_bKGD,
             PNG_INFO_hIST, PNG_INFO_pHYs,
             PNG_INFO_oFFs, PNG_INFO_tIME,
             PNG_INFO_pCAL, PNG_INFO_sRGB,
             PNG_INFO_iCCP, PNG_INFO_sPLT,
             PNG_INFO_sCAL, PNG_INFO_IDAT

For a mo' compact example of readin a PNG image, peep tha file example.c.

.SS Readin PNG filez progressively

Da progressive reader is slightly different from tha non-progressive
reader n' shit.  Instead of callin png_read_info(), png_read_rows(), and
png_read_end(), you make one call ta png_process_data(), which calls
callbacks when it has tha info, a row, or tha end of tha image.  You
set up these callbacks wit png_set_progressive_read_fn().  Yo ass don't
have ta worry bout tha input/output functionz of libpng, as yo ass is
givin tha library tha data directly up in png_process_data().  I will
assume dat you have read tha section on readin PNG filez above,
so I'ma only highlight tha differences (although I'ma show
all of tha code).

png_structp png_ptr;
png_infop info_ptr;

 /*  An example code fragment of how tha fuck you would
     initialize tha progressive reader up in your
     application. I aint talkin' bout chicken n' gravy biatch. */
 int
 initialize_png_reader()
 {
    png_ptr = png_create_read_struct
        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
         user_error_fn, user_warning_fn);

    if (!png_ptr)
        return (ERROR);

    info_ptr = png_create_info_struct(png_ptr);

    if (!info_ptr)
    {
       png_destroy_read_struct(&png_ptr,
          (png_infopp)NULL, (png_infopp)NULL);
       return (ERROR);
    }

    if (setjmp(png_jmpbuf(png_ptr)))
    {
       png_destroy_read_struct(&png_ptr, &info_ptr,
          (png_infopp)NULL);
       return (ERROR);
    }

    /* This onez new.  Yo ass can provide functions
       ta be called when tha header info is valid,
       when each row is completed, n' when tha image
       is finished. Y'all KNOW dat shit, muthafucka!  If yo ass aint rockin all functions,
       you can specify NULL parameters.  Even when all
       three functions is NULL, you need ta call
       png_set_progressive_read_fn().  Yo ass can use
       any struct as tha user_ptr (cast ta a void pointer
       fo' tha function call), n' retrieve tha pointer
       from inside tha callbacks rockin tha function

          png_get_progressive_ptr(png_ptr);

       which will return a void pointer, which you have
       ta cast appropriately.
     */
    png_set_progressive_read_fn(png_ptr, (void *)user_ptr,
        info_callback, row_callback, end_callback);

    return 0;
 }

 /* A code fragment dat you call as you receive blocks
   of data */
 int
 process_data(png_bytep buffer, png_uint_32 length)
 {
    if (setjmp(png_jmpbuf(png_ptr)))
    {
       png_destroy_read_struct(&png_ptr, &info_ptr,
           (png_infopp)NULL);
       return (ERROR);
    }

    /* This onez freshly smoked up also.  Simply give it a cold-ass lil chunk
       of data from tha file stream (in order, of
       course).  On machines wit segmented memory
       models machines, don't give it any mo' than
       64K.  Da library seems ta run fine wit sizes
       of 4K fo' realz. Although you can give it much less if
       necessary (I assume you can give it chunks of
       1 byte, I aint tried less then 256 bytes
       yet).  When dis function returns, you may
       wanna display any rows dat was generated
       up in tha row callback if you don't already do
       so there.
     */
    png_process_data(png_ptr, info_ptr, buffer, length);

    /* At dis point you can call png_process_data_skip if
       you wanna handle data tha library will skip yo ass;
       it simply returns tha number of bytes ta skip (and stops
       libpng skippin dat number of bytes on tha next
       png_process_data call).
    return 0;
 }

 /* This function is called (as set by
    png_set_progressive_read_fn() above) when enough data
    has been supplied so all of tha header has been
    read.
 */
 void
 info_callback(png_structp png_ptr, png_infop info)
 {
    /* Do any setup here, includin settin any of
       tha transformations mentioned up in tha Reading
       PNG filez section. I aint talkin' bout chicken n' gravy biatch.  For now, you _must_ call
       either png_start_read_image() or
       png_read_update_info() afta all the
       transformations is set (even if you don't set
       any).  Yo ass may start gettin rows before
       png_process_data() returns, so dis is your
       last chizzle ta prepare fo' dis shit.

       This is where you turn on interlace handling,
       assumin you don't wanna do it yo ass.

       If you need ta you can stop tha processin of
       yo' original gangsta input data at dis point by calling
       png_process_data_pause.  This returns tha number
       of unprocessed bytes from tha last png_process_data
       call - it is up ta you ta ensure dat tha next call
       sees these bytes again. I aint talkin' bout chicken n' gravy biatch.  If you don't wanna bother
       wit dis you can git libpng ta cache tha unread
       bytes by settin tha 'save' parameta (see png.h) but
       then libpng will gotta copy tha data internally.
     */
 }

 /* This function is called when each row of image
    data is complete */
 void
 row_callback(png_structp png_ptr, png_bytep new_row,
    png_uint_32 row_num, int pass)
 {
    /* If tha image is interlaced, n' you turned
       on tha interlace handlez, dis function will
       be called fo' every last muthafuckin row up in every last muthafuckin pass.  Some
       of these rows aint gonna be chizzled from the
       previous pass.  When tha row aint chizzled,
       tha new_row variable is ghon be NULL.  Da rows
       n' passes is called up in order, so you don't
       straight-up need tha row_num n' pass yo, but I'm
       supplyin dem cuz it may make yo' game
       easier.

       If you did not turn on interlace handlin then
       tha callback is called fo' each row of each
       sub-image when tha image is interlaced. Y'all KNOW dat shit, muthafucka!  In this
       case 'row_num' is tha row up in tha sub-image, not
       tha row up in tha output image as it is up in all other
       cases.

       For tha non-NULL rowz of interlaced images when
       you have switched on libpng interlace handling,
       you must call png_progressive_combine_row()
       passin up in tha row n' tha oldschool row.  Yo ass can
       call dis function fo' NULL rows (it will just
       return) n' fo' non-interlaced images (it just
       do tha memcpy fo' you) if it will make the
       code easier n' shit.  Thus, you can just do dis for
       all cases if you switch on interlace handling;
     */

        png_progressive_combine_row(png_ptr, old_row,
          new_row);

    /* where old_row is what tha fuck was displayed for
       previously fo' tha row.  Note dat tha first
       pass (pass == 0, straight-up) will straight-up cover
       tha oldschool row, so tha rows do not gotta be
       initialized. Y'all KNOW dat shit, muthafucka!  Afta tha straight-up original gangsta pass (and only
       fo' interlaced images), yo big-ass booty is ghon gotta pass
       tha current row, n' tha function will combine
       tha oldschool row n' tha freshly smoked up row.

       Yo ass can also call png_process_data_pause up in this
       callback - peep above.
    */
 }

 void
 end_callback(png_structp png_ptr, png_infop info)
 {
    /* This function is called afta tha whole image
       has been read, includin any chunks afta the
       image (up ta n' includin tha IEND).  You
       will probably have tha same info chunk as you
       had up in tha header, although some data may have
       been added ta tha comments n' time fields.

       Most playas won't do much here, like setting
       a gangbangin' flag dat marks tha image as finished.
     */
 }



.SH IV. Writing

Much of dis is straight-up similar ta reading.  But fuck dat shiznit yo, tha word on tha street is dat every last muthafuckin thang of
importizzle is repeated here, so you won't gotta constantly look
back up in tha readin section ta KNOW writing.

.SS Setup

Yo ass will wanna do tha I/O initialization before you git tha fuck into libpng,
so if it don't work, you aint gots anythang ta undo. If yo ass is not
usin tha standard I/O functions, yo big-ass booty is ghon need ta replace dem with
custom freestylin functions.  See tha rap under Customizin libpng.

    FILE *fp = fopen(file_name, "wb");

    if (!fp)
       return (ERROR);

Next, png_struct n' png_info need ta be allocated n' initialized.
As these can be both relatively large, you may not wanna store these
on tha stack, unless you have stack space ta spare.  Of course, you
will wanna check if they return NULL.  If yo ass be also reading,
you won't wanna name yo' read structure n' yo' write structure
both "png_ptr"; you can call dem anythang you like, such as
"read_ptr" n' "write_ptr".  Look at pngtest.c, fo' example.

    png_structp png_ptr = png_create_write_struct
       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
        user_error_fn, user_warning_fn);

    if (!png_ptr)
       return (ERROR);

    png_infop info_ptr = png_create_info_struct(png_ptr);
    if (!info_ptr)
    {
       png_destroy_write_struct(&png_ptr,
           (png_infopp)NULL);
       return (ERROR);
    }

If you wanna use yo' own memory allocation routines,
define PNG_USER_MEM_SUPPORTED n' use
png_create_write_struct_2() instead of png_create_write_struct():

    png_structp png_ptr = png_create_write_struct_2
       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
        user_error_fn, user_warning_fn, (png_voidp)
        user_mem_ptr, user_malloc_fn, user_free_fn);

Afta you have these structures, yo big-ass booty is ghon need ta set up the
error handling.  When libpng encountas a error, it expects to
longjmp() back ta yo' routine.  Therefore, yo big-ass booty is ghon need ta call
setjmp() n' pass tha png_jmpbuf(png_ptr).  If you
write tha file from different routines, yo big-ass booty is ghon need ta update
the png_jmpbuf(png_ptr) every last muthafuckin time you enta a freshly smoked up routine dat will
call a png_*() function. I aint talkin' bout chicken n' gravy biatch.  See yo' documentation of setjmp/longjmp
for yo' compila fo' mo' shiznit on setjmp/longjmp.  See
the rap on libpng error handlin up in tha Customizin Libpng
section below fo' mo' shiznit on tha libpng error handling.

    if (setjmp(png_jmpbuf(png_ptr)))
    {
    png_destroy_write_struct(&png_ptr, &info_ptr);
       fclose(fp);
       return (ERROR);
    }
    ...
    return;

If you would rather avoid tha complexitizzle of setjmp/longjmp issues,
you can compile libpng wit PNG_NO_SETJMP, up in which case
errors will result up in a cold-ass lil call ta PNG_ABORT() which defaults ta abort().

Yo ass can #define PNG_ABORT() ta a gangbangin' function dat do something
more useful than abort(), as long as yo' function do not
return.

Checkin fo' invalid palette index on write was added at libpng
1.5.10.  If a pixel gotz nuff a invalid (out-of-range) index libpng issues
a benign error. Shiiit, dis aint no joke.  This is enabled by default cuz dis condizzle be an
error accordin ta tha PNG justification, Clause 11.3.2 yo, but tha error can
be ignored up in each png_ptr with

   png_set_check_for_invalid_index(png_ptr, 0);

If tha error is ignored, or if png_benign_error() treats it as a warning,
any invalid pixels is freestyled as-is by tha encoder, resultin up in an
invalid PNG datastream as output.  In dis case tha application is
responsible fo' ensurin dat tha pixel indexes is up in range when it writes
a PLTE chunk wit fewer entries than tha bit depth would allow.

Now you need ta set up tha output code.  Da default fo' libpng is to
use tha C function fwrite().  If you use this, yo big-ass booty is ghon need ta pass a
valid FILE * up in tha function png_init_io().  Be shizzle dat tha file is
opened up in binary mode.  Again, if you wish ta handle freestylin data in
another way, peep tha rap on libpng I/O handlin up in tha Customizing
Libpng section below.

    png_init_io(png_ptr, fp);

If yo ass is embeddin yo' PNG tha fuck into a thugged-out datastream like fuckin MNG, n' don't
want libpng ta write tha 8-byte signature, or if you have already
written tha signature up in yo' application, use

    png_set_sig_bytes(png_ptr, 8);

to inform libpng dat it should not write a signature.

.SS Write callbacks

At dis point, you can set up a cold-ass lil callback function dat will be
called afta each row has been written, which you can use ta control
a progress meta or tha like.  It aint nuthin but demonstrated up in pngtest.c.
Yo ass must supply a gangbangin' function

    void write_row_callback(png_structp png_ptr, png_uint_32 row,
       int pass);
    {
      /* put yo' code here */
    }

(Yo ass can give it another name dat you like instead of "write_row_callback")

To inform libpng bout yo' function, use

    png_set_write_status_fn(png_ptr, write_row_callback);

When dis function is called tha row has already been straight-up processed and
it has also been freestyled out.  Da 'row' n' 'pass' refer ta tha next row ta be
handled. Y'all KNOW dat shit, muthafucka!  For the
non-interlaced case tha row dat was just handled is simply one less than the
passed up in row number, n' pass will always be 0.  For tha interlaced case the
same applies unless tha row value is 0, up in which case tha row just handled was
the last one from one of tha precedin passes.  Because interlacin may skip a
pass you cannot be shizzle dat tha precedin pass is just 'pass\-1', if you straight-up
need ta know what tha fuck tha last pass is record (row,pass) from tha callback n' use
the last recorded value each time.

As wit tha user transform you can find tha output row rockin the
PNG_ROW_FROM_PASS_ROW macro.

Yo ass now have tha option of modifyin how tha fuck tha compression library will
run. I aint talkin' bout chicken n' gravy biatch.  Da followin functions is mainly fo' testin yo, but may be useful
in some cases, like if you need ta write PNG filez mad fast and
are willin ta give up some compression, or if you wanna git the
maximum possible compression all up in tha expense of slower writing.  If you
have no special needz up in dis area, let tha library do what tha fuck it wants by
not callin dis function at all, as it has been tuned ta serve up a good
speed/compression ratio. Da second parameta ta png_set_filter() is
the filta method, fo' which tha only valid joints is 0 (az of the
July 1999 PNG justification, version 1.2) or 64 (if yo ass is writing
a PNG datastream dat is ta be embedded up in a MNG datastream).  Da third
parameta be a gangbangin' flag dat indicates which filta type(s) is ta be tested
for each scanline.  See tha PNG justification fo' details on tha specific
filta types.


    /* turn on or off filtering, and/or chizzle
       specific filters.  Yo ass can use either a single
       PNG_FILTER_VALUE_NAME or tha bitwise OR of one
       or mo' PNG_FILTER_NAME masks.
     */
    png_set_filter(png_ptr, 0,
       PNG_FILTER_NONE  | PNG_FILTER_VALUE_NONE |
       PNG_FILTER_SUB   | PNG_FILTER_VALUE_SUB  |
       PNG_FILTER_UP    | PNG_FILTER_VALUE_UP   |
       PNG_FILTER_AVG   | PNG_FILTER_VALUE_AVG  |
       PNG_FILTER_PAETH | PNG_FILTER_VALUE_PAETH|
       PNG_ALL_FILTERS);

If a application wants ta start n' stop rockin particular filtas during
compression, it should start up wit all of tha filtas (to ensure that
the previous row of pixels is ghon be stored up in case itz needed later),
and then add n' remove dem afta tha start of compression.

If yo ass is freestylin a PNG datastream dat is ta be embedded up in a MNG
datastream, tha second parameta can be either 0 or 64.

Da png_set_compression_*() functions intercourse ta tha zlib compression
library, n' should mostly be ignored unless you straight-up know what tha fuck yo ass is
doing.  Da only generally useful call is png_set_compression_level()
which chizzlez how tha fuck much time zlib spendz on tryin ta compress tha image
data.  See tha Compression Library (zlib.h n' algorithm.txt, distributed
with zlib) fo' details on tha compression levels.

    #include zlib.h

    /* Set tha zlib compression level */
    png_set_compression_level(png_ptr,
        Z_BEST_COMPRESSION);

    /* Set other zlib parametas fo' compressin IDAT */
    png_set_compression_mem_level(png_ptr, 8);
    png_set_compression_strategy(png_ptr,
        Z_DEFAULT_STRATEGY);
    png_set_compression_window_bits(png_ptr, 15);
    png_set_compression_method(png_ptr, 8);
    png_set_compression_buffer_size(png_ptr, 8192)

    /* Set zlib parametas fo' text compression
     * If you don't call these, tha parameters
     * fall back on dem defined fo' IDAT chunks
     */
    png_set_text_compression_mem_level(png_ptr, 8);
    png_set_text_compression_strategy(png_ptr,
        Z_DEFAULT_STRATEGY);
    png_set_text_compression_window_bits(png_ptr, 15);
    png_set_text_compression_method(png_ptr, 8);

.SS Settin tha contentz of info fo' output

Yo ass now need ta fill up in tha png_info structure wit all tha data you
wish ta write before tha actual image.  Note dat tha only thang you
are allowed ta write afta tha image is tha text chunks n' tha time
chunk (az of PNG Justification 1.2, anyway).  See png_write_end() and
the sickest fuckin PNG justification fo' mo' shiznit on dis shit.  If you
wish ta write dem before tha image, fill dem up in now, n' flag that
data as bein valid. Y'all KNOW dat shit, muthafucka!  If you wanna wait until afta tha data, don't
fill dem until png_write_end().  For all tha fieldz up in png_info and
their data types, peep png.h.  For explanationz of what tha fuck tha fields
contain, peep tha PNG justification.

Some of tha mo' blingin partz of tha png_info are:

    png_set_IHDR(png_ptr, info_ptr, width, height,
       bit_depth, color_type, interlace_type,
       compression_type, filter_method)

    width          - holdz tha width of tha image
                     up in pixels (up ta 2^31).

    height         - holdz tha height of tha image
                     up in pixels (up ta 2^31).

    bit_depth      - holdz tha bit depth of one of the
                     image channels.
                     (valid joints is 1, 2, 4, 8, 16
                     n' depend also on the
                     color_type.  See also significant
                     bits (sBIT) below).

    color_type     - raps bout which color/alpha
                     channels is present.
                     PNG_COLOR_TYPE_GRAY
                        (bit depths 1, 2, 4, 8, 16)
                     PNG_COLOR_TYPE_GRAY_ALPHA
                        (bit depths 8, 16)
                     PNG_COLOR_TYPE_PALETTE
                        (bit depths 1, 2, 4, 8)
                     PNG_COLOR_TYPE_RGB
                        (bit_depths 8, 16)
                     PNG_COLOR_TYPE_RGB_ALPHA
                        (bit_depths 8, 16)

                     PNG_COLOR_MASK_PALETTE
                     PNG_COLOR_MASK_COLOR
                     PNG_COLOR_MASK_ALPHA

    interlace_type - PNG_INTERLACE_NONE or
                     PNG_INTERLACE_ADAM7

    compression_type - (must be
                     PNG_COMPRESSION_TYPE_DEFAULT)

    filter_method  - (must be PNG_FILTER_TYPE_DEFAULT
                     or, if yo ass is freestylin a PNG to
                     be embedded up in a MNG datastream,
                     can also be
                     PNG_INTRAPIXEL_DIFFERENCING)

If you call png_set_IHDR(), tha call must step tha fuck up before any of the
other png_set_*() functions, cuz they might require access ta some of
the IHDR settings.  Da remainin png_set_*() functions can be called
in any order.

If you wish, you can reset tha compression_type, interlace_type, or
filter_method lata by callin png_set_IHDR() again; if you do this, the
width, height, bit_depth, n' color_type must be tha same up in each call.

    png_set_PLTE(png_ptr, info_ptr, palette,
       num_palette);

    palette        - tha palette fo' tha file
                     (array of png_color)
    num_palette    - number of entries up in tha palette

    png_set_gAMA(png_ptr, info_ptr, file_gamma);
    png_set_gAMA_fixed(png_ptr, info_ptr, int_file_gamma);

    file_gamma     - tha gamma at which tha image was
                     pimped (PNG_INFO_gAMA)

    int_file_gamma - 100,000 times tha gamma at which
                     tha image was pimped

    png_set_cHRM(png_ptr, info_ptr,  white_x, white_y, red_x, red_y,
                     green_x, green_y, blue_x, blue_y)
    png_set_cHRM_XYZ(png_ptr, info_ptr, red_X, red_Y, red_Z, green_X,
                     green_Y, green_Z, blue_X, blue_Y, blue_Z)
    png_set_cHRM_fixed(png_ptr, info_ptr, int_white_x, int_white_y,
                     int_red_x, int_red_y, int_green_x, int_green_y,
                     int_blue_x, int_blue_y)
    png_set_cHRM_XYZ_fixed(png_ptr, info_ptr, int_red_X, int_red_Y,
                     int_red_Z, int_green_X, int_green_Y, int_green_Z,
                     int_blue_X, int_blue_Y, int_blue_Z)

    {white,red,green,blue}_{x,y}
                     A color space encodin specified rockin tha chromaticities
                     of tha end points n' tha white point.

    {red,green,blue}_{X,Y,Z}
                     A color space encodin specified rockin tha encodin end
                     points - tha CIE tristimulus justification of tha intended
                     color of tha red, chronic n' blue channels up in tha PNG RGB
                     data.  Da white point is simply tha sum of tha three end
                     points.

    png_set_sRGB(png_ptr, info_ptr, srgb_intent);

    srgb_intent    - tha renderin intent
                     (PNG_INFO_sRGB) Da presence of
                     tha sRGB chunk means dat tha pixel
                     data is up in tha sRGB color space.
                     This chunk also implies specific
                     jointz of gAMA n' cHRM.  Rendering
                     intent is tha CSS-1 property that
                     has been defined by tha International
                     Color Consortium
                     (http://www.color.org).
                     It can be one of
                     PNG_sRGB_INTENT_SATURATION,
                     PNG_sRGB_INTENT_PERCEPTUAL,
                     PNG_sRGB_INTENT_ABSOLUTE, or
                     PNG_sRGB_INTENT_RELATIVE.


    png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr,
       srgb_intent);

    srgb_intent    - tha renderin intent
                     (PNG_INFO_sRGB) Da presence of the
                     sRGB chunk means dat tha pixel
                     data is up in tha sRGB color space.
                     This function also causes gAMA and
                     cHRM chunks wit tha specific joints
                     dat is consistent wit sRGB ta be
                     written.

    png_set_iCCP(png_ptr, info_ptr, name, compression_type,
                       profile, proflen);

    name             - Da flava name.

    compression_type - Da compression type; always
                       PNG_COMPRESSION_TYPE_BASE fo' PNG 1.0.
                       Yo ass may give NULL ta dis argument to
                       ignore dat shit.

    flava          - Internationistic Color Consortium color
                       flava data. May contain NULs.

    proflen          - length of flava data up in bytes.

    png_set_sBIT(png_ptr, info_ptr, sig_bit);

    sig_bit        - tha number of dope bits for
                     (PNG_INFO_sBIT) each of tha gray, red,
                     green, n' blue channels, whichever are
                     appropriate fo' tha given color type
                     (png_color_16)

    png_set_tRNS(png_ptr, info_ptr, trans_alpha,
       num_trans, trans_color);

    trans_alpha    - array of alpha (transparency)
                     entries fo' palette (PNG_INFO_tRNS)

    num_trans      - number of transparent entries
                     (PNG_INFO_tRNS)

    trans_color    - graylevel or color sample joints
                     (in order red, green, blue) of the
                     single transparent color for
                     non-paletted images (PNG_INFO_tRNS)

    png_set_hIST(png_ptr, info_ptr, hist);

    hist           - histogram of palette (array of
                     png_uint_16) (PNG_INFO_hIST)

    png_set_tIME(png_ptr, info_ptr, mod_time);

    mod_time       - time image was last modified
                     (PNG_VALID_tIME)

    png_set_bKGD(png_ptr, info_ptr, background);

    background     - background color (of type
                     png_color_16p) (PNG_VALID_bKGD)

    png_set_text(png_ptr, info_ptr, text_ptr, num_text);

    text_ptr       - array of png_text holdin image
                     comments

    text_ptr[i].compression - type of compression used
                 on "text" PNG_TEXT_COMPRESSION_NONE
                           PNG_TEXT_COMPRESSION_zTXt
                           PNG_ITXT_COMPRESSION_NONE
                           PNG_ITXT_COMPRESSION_zTXt
    text_ptr[i].key   - keyword fo' comment.  Must contain
                 1-79 characters.
    text_ptr[i].text  - text comments fo' current
                         keyword. Y'all KNOW dat shit, muthafucka!  Can be NULL or empty.
    text_ptr[i].text_length - length of text string,
                 afta decompression, 0 fo' iTXt
    text_ptr[i].itxt_length - length of itxt string,
                 afta decompression, 0 fo' tEXt/zTXt
    text_ptr[i].lang  - language of comment (NULL or
                         empty fo' unknown).
    text_ptr[i].translated_keyword  - keyword up in UTF-8 (NULL
                         or empty fo' unknown).

    Note dat tha itxt_length, lang, n' lang_key
    thugz of tha text_ptr structure only exist when the
    library is built wit iTXt chunk support.  Prior to
    libpng-1.4.0 tha library was built by default without
    iTXt support fo' realz. Also note dat when iTXt is supported,
    they contain NULL pointas when tha "compression"
    field gotz nuff PNG_TEXT_COMPRESSION_NONE or
    PNG_TEXT_COMPRESSION_zTXt.

    num_text       - number of comments

    png_set_sPLT(png_ptr, info_ptr, &palette_ptr,
       num_spalettes);

    palette_ptr    - array of png_sPLT_struct structures
                     ta be added ta tha list of palettes
                     up in tha info structure.
    num_spalettes  - number of palette structures ta be
                     added.

    png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y,
        unit_type);

    offset_x  - positizzle offset from tha left
                     edge of tha screen

    offset_y  - positizzle offset from tha top
                     edge of tha screen

    unit_type - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER

    png_set_pHYs(png_ptr, info_ptr, res_x, res_y,
        unit_type);

    res_x       - pixels/unit physical resolution
                  up in x direction

    res_y       - pixels/unit physical resolution
                  up in y direction

    unit_type   - PNG_RESOLUTION_UNKNOWN,
                  PNG_RESOLUTION_METER

    png_set_sCAL(png_ptr, info_ptr, unit, width, height)

    unit        - physical scale units (an integer)

    width       - width of a pixel up in physical scale units

    height      - height of a pixel up in physical scale units
                  (width n' height is doubles)

    png_set_sCAL_s(png_ptr, info_ptr, unit, width, height)

    unit        - physical scale units (an integer)

    width       - width of a pixel up in physical scale units
                  expressed as a string

    height      - height of a pixel up in physical scale units
                 (width n' height is strings like "2.54")

    png_set_unknown_chunks(png_ptr, info_ptr, &unknowns,
       num_unknowns)

    unknowns          - array of png_unknown_chunk
                        structures holdin unknown chunks
    unknowns[i].name  - name of unknown chunk
    unknowns[i].data  - data of unknown chunk
    unknowns[i].size  - size of unknown chunkz data
    unknowns[i].location - posizzle ta write chunk up in file
                           0: do not write chunk
                           PNG_HAVE_IHDR: before PLTE
                           PNG_HAVE_PLTE: before IDAT
                           PNG_AFTER_IDAT: afta IDAT

Da "location" member is set automatically accordin to
what part of tha output file has already been written.
Yo ass can chizzle its value afta callin png_set_unknown_chunks()
as demonstrated up in pngtest.c.  Within each of tha "locations",
the chunks is sequenced accordin ta they posizzle up in the
structure (that is, tha value of "i", which is tha order up in which
the chunk was either read from tha input file or defined with
png_set_unknown_chunks).

A quick word bout text n' num_text.  text be a array of png_text
structures.  num_text is tha number of valid structures up in tha array.
Each png_text structure holdz a language code, a keyword, a text value,
and a cold-ass lil compression type.

Da compression types have tha same valid numbers as tha compression
typez of tha image data.  Currently, tha only valid number is zero.
But fuck dat shiznit yo, tha word on tha street is dat you can store text either compressed or uncompressed, unlike
images, which always gotta be compressed. Y'all KNOW dat shit, muthafucka!  So if you don't want the
text compressed, set tha compression type ta PNG_TEXT_COMPRESSION_NONE.
Because tEXt n' zTXt chunks aint gots a language field, if you
specify PNG_TEXT_COMPRESSION_NONE or PNG_TEXT_COMPRESSION_zTXt
any language code or translated keyword aint gonna be freestyled out.

Until text gets round all dem hundred bytes, it aint worth compressin dat shit.
Afta tha text has been freestyled up ta tha file, tha compression type
is set ta PNG_TEXT_COMPRESSION_NONE_WR or PNG_TEXT_COMPRESSION_zTXt_WR,
so dat it aint freestyled up again n' again n' again all up in tha end (in case yo ass is calling
png_write_end() wit tha same struct).

Da keywordz dat is given up in tha PNG Justification are:

    Title            Short (one line) title or
                     caption fo' image

    Lyricist           Name of imagez creator

    Description      Description of image (possibly long)

    Copyright        Copyright notice

    Creation Time    Time of original gangsta image creation
                     (usually RFC 1123 format, peep below)

    Software         Software used ta create tha image

    Disclaimer       Legal disclaimer

    Warnin          Warnin of nature of content

    Source           Device used ta create tha image

    Comment          Miscellaneous comment; conversion
                     from other image format

Da keyword-text pairs work like all dis bullshit.  Keywordz should be short
simple descriptionz of what tha fuck tha comment be about.  Some typical
keywordz is found up in tha PNG justification, as is some recommendations
on keywords.  Yo ass can repeat keywordz up in a gangbangin' file.  Yo ass can even write
some text before tha image n' some afta n' shit.  For example, you may want
to put a thugged-out description of tha image before tha image yo, but leave the
disclaimer until after, so viewers hustlin over modem connections
don't gotta wait fo' tha disclaimer ta go over tha modem before
they start seein tha image.  Finally, keywordz should be full
words, not abbreviations.  Keywordz n' text is up in tha ISO 8859-1
(Latin-1) characta set (a superset of regular ASCII) n' can not
contain NUL characters, n' should not contain control or other
unprintable characters.  To make tha comments widely readable, stick
with basic ASCII, n' avoid machine specific characta set extensions
like tha IBM-PC characta set.  Da keyword must be present yo, but
you can leave off tha text strang on non-compressed pairs.
Compressed pairs must gotz a text string, as only tha text string
is compressed anyway, so tha compression would be meaningless.

PNG supports modification time via tha png_time structure.  Two
conversion routines is provided, png_convert_from_time_t() for
time_t n' png_convert_from_struct_tm() fo' struct tm.  The
time_t routine uses gmtime().  Yo ass don't gotta use either of
these yo, but if you wish ta fill up in tha png_time structure directly,
you should provide tha time up in universal time (GMT) if possible
instead of yo' local time.  Note dat tha year number is tha full
year (e.g. 1998, rather than 98 - PNG is year 2000 compliant!), and
that months start wit 1.

If you wanna store tha time of tha original gangsta image creation, you should
use a plain tEXt chunk wit tha "Creation Time" keyword. Y'all KNOW dat shit, muthafucka!  This is
necessary cuz tha "creation time" of a PNG image is somewhat vague,
dependin on whether you mean tha PNG file, tha time tha image was
created up in a non-PNG format, a still photo from which tha image was
scanned, or possibly tha subject matta itself.  In order ta facilitate
machine-readable dates, it is recommended dat tha "Creation Time"
tEXt chunk use RFC 1123 format dates (e.g. "22 May 1997 18:07:10 GMT"),
although dis aint a requirement.  Unlike tha tIME chunk, the
"Creation Time" tEXt chunk aint sposed ta fuckin be automatically chizzled
by tha software.  To facilitate tha use of RFC 1123 dates, a gangbangin' function
png_convert_to_rfc1123_buffer(png_ptr, buffer, png_timep) is provided to
convert from PNG time ta a RFC 1123 format string.  Da calla must provide
a writeable buffer of at least 29 bytes.

.SS Freestylin unknown chunks

Yo ass can use tha png_set_unknown_chunks function ta queue up private chunks
for writing.  Yo ass give it a cold-ass lil chunk name, location, raw data, n' a size.  You
also must use png_set_keep_unknown_chunks() ta ensure dat libpng will
handle em.  Thatz all there is ta dat shit.  Da chunks is ghon be freestyled by the
next followin png_write_info_before_PLTE, png_write_info, or png_write_end
function, dependin upon tha specified location. I aint talkin' bout chicken n' gravy biatch.  Any chunks previously
read tha fuck into tha info structurez unknown-chunk list will also be freestyled out
in a sequence dat satisfies tha PNG justificationz orderin rules.

Here be a example of freestylin two private chunks, prVt n' miNE:

    #ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
    /* Set unknown chunk data */
    png_unknown_chunk unk_chunk[2];
    strcpy((char *) unk_chunk[0].name, "prVt";
    unk_chunk[0].data = (unsigned char *) "PRIVATE DATA";
    unk_chunk[0].size = strlen(unk_chunk[0].data)+1;
    unk_chunk[0].location = PNG_HAVE_IHDR;
    strcpy((char *) unk_chunk[1].name, "miNE";
    unk_chunk[1].data = (unsigned char *) "MY CHUNK DATA";
    unk_chunk[1].size = strlen(unk_chunk[0].data)+1;
    unk_chunk[1].location = PNG_AFTER_IDAT;
    png_set_unknown_chunks(write_ptr, write_info_ptr,
        unk_chunk, 2);
    /* Needed cuz miNE aint safe-to-copy */
    png_set_keep_unknown_chunks(png, PNG_HANDLE_CHUNK_ALWAYS,
       (png_bytep) "miNE", 1);
    # if PNG_LIBPNG_VER < 10600
      /* Deal wit unknown chunk location bug up in 1.5.x n' earlier */
      png_set_unknown_chunk_location(png, info, 0, PNG_HAVE_IHDR);
      png_set_unknown_chunk_location(png, info, 1, PNG_AFTER_IDAT);
    # endif
    # if PNG_LIBPNG_VER < 10500
      /* PNG_AFTER_IDAT writes two copiez of tha chunk prior ta libpng-1.5.0,
       * one before IDAT n' another afta IDAT, so don't use it; only use
       * PNG_HAVE_IHDR location. I aint talkin' bout chicken n' gravy biatch.  This call resets tha location previously
       * set by assignment n' png_set_unknown_chunk_location() fo' chunk 1.
       */
      png_set_unknown_chunk_location(png, info, 1, PNG_HAVE_IHDR);
    # endif
    #endif

.SS Da high-level write intercourse

At dis point there be two ways ta proceed; all up in tha high-level
write intercourse, or all up in a sequence of low-level write operations.
Yo ass can use tha high-level intercourse if yo' image data is present
in tha info structure.  All defined output
transformations is permitted, enabled by tha followin masks.

    PNG_TRANSFORM_IDENTITY      No transformation
    PNG_TRANSFORM_PACKING       Pack 1, 2 n' 4-bit samples
    PNG_TRANSFORM_PACKSWAP      Chizzle order of packed
                                pixels ta LSB first
    PNG_TRANSFORM_INVERT_MONO   Invert monochrome images
    PNG_TRANSFORM_SHIFT         Normalize pixels ta the
                                sBIT depth
    PNG_TRANSFORM_BGR           Flip RGB ta BGR, RGBA
                                ta BGRA
    PNG_TRANSFORM_SWAP_ALPHA    Flip RGBA ta ARGB or GA
                                ta AG
    PNG_TRANSFORM_INVERT_ALPHA  Chizzle alpha from opacity
                                ta transparency
    PNG_TRANSFORM_SWAP_ENDIAN   Byte-swap 16-bit samples
    PNG_TRANSFORM_STRIP_FILLER        Strip up filler
                                      bytes (deprecated).
    PNG_TRANSFORM_STRIP_FILLER_BEFORE Strip up leading
                                      filla bytes
    PNG_TRANSFORM_STRIP_FILLER_AFTER  Strip up trailing
                                      filla bytes

If you have valid image data up in tha info structure (you can use
png_set_rows() ta put image data up in tha info structure), simply do this:

    png_write_png(png_ptr, info_ptr, png_transforms, NULL)

where png_transforms be a integer containin tha bitwise OR of some set of
transformation flags.  This call is equivalent ta png_write_info(),
followed tha set of transformations indicated by tha transform mask,
then png_write_image(), n' finally png_write_end().

(Da final parameta of dis call aint yet used. Y'all KNOW dat shit, muthafucka!  Somedizzle it might point
to transformation parametas required by some future output transform.)

Yo ass must use png_transforms n' not call any png_set_transform() functions
when you use png_write_png().

.SS Da low-level write intercourse

If yo ass is goin tha low-level route instead, yo ass is now locked n loaded to
write all tha file shiznit up ta tha actual image data.  Yo ass do
this wit a cold-ass lil call ta png_write_info().

    png_write_info(png_ptr, info_ptr);

Note dat there is one transformation you may need ta do before
png_write_info().  In PNG files, tha alpha channel up in a image is the
level of opacity.  If yo' data is supplied as a level of transparency,
you can invert tha alpha channel before you write it, so dat 0 is
fully transparent n' 255 (in 8-bit or paletted images) or 65535
(in 16-bit images) is straight-up opaque, with

    png_set_invert_alpha(png_ptr);

This must step tha fuck up before png_write_info() instead of lata wit the
other transformations cuz up in tha case of paletted images tha tRNS
chunk data has ta be inverted before tha tRNS chunk is written. I aint talkin' bout chicken n' gravy biatch.  If
your image aint a paletted image, tha tRNS data (which up in such cases
represents a single color ta be rendered as transparent) won't need to
be chizzled, n' you can safely do dis transformation afta your
png_write_info() call.

If you need ta write a private chunk dat you wanna step tha fuck up before
the PLTE chunk when PLTE is present, you can write tha PNG info in
two steps, n' bang code ta write yo' own chunk between them:

    png_write_info_before_PLTE(png_ptr, info_ptr);
    png_set_unknown_chunks(png_ptr, info_ptr, ...);
    png_write_info(png_ptr, info_ptr);

Afta you've freestyled tha file shiznit, you can set up tha library
to handle any special transformationz of tha image data.  Da various
ways ta transform tha data is ghon be busted lyrics bout up in tha order dat they
should occur. Shiiit, dis aint no joke.  This is blingin, as a shitload of these chizzle tha color
type and/or bit depth of tha data, n' some others only work on
certain color types n' bit depths.  Even though each transformation
checks ta peep if it has data dat it can do suttin' with, you should
make shizzle ta only enable a transformation if it is ghon be valid fo' the
data.  For example, don't swap red n' blue on grayscale data.

PNG filez store RGB pixels packed tha fuck into 3 or 6 bytes.  This code tells
the library ta strip input data dat has 4 or 8 bytes per pixel down
to 3 or 6 bytes (or strip 2 or 4-byte grayscale+filla data ta 1 or 2
bytes per pixel).

    png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);

where tha 0 is unused, n' tha location is either PNG_FILLER_BEFORE or
PNG_FILLER_AFTER, dependin upon whether tha filla byte up in tha pixel
is stored XRGB or RGBX.

PNG filez pack pixelz of bit depths 1, 2, n' 4 tha fuck into bytes as lil' small-ass as
they can, resultin in, fo' example, 8 pixels per byte fo' 1 bit files.
If tha data is supplied at 1 pixel per byte, use dis code, which will
correctly pack tha pixels tha fuck into a single byte:

    png_set_packing(png_ptr);

PNG filez reduce possible bit depths ta 1, 2, 4, 8, n' 16.  If your
data iz of another bit depth, you can write a sBIT chunk tha fuck into the
file so dat decodaz can recover tha original gangsta data if desired.

    /* Set tha legit bit depth of tha image data */
    if (color_type & PNG_COLOR_MASK_COLOR)
    {
       sig_bit.red = true_bit_depth;
       sig_bit.chronic = true_bit_depth;
       sig_bit.blue = true_bit_depth;
    }

    else
    {
       sig_bit.gray = true_bit_depth;
    }

    if (color_type & PNG_COLOR_MASK_ALPHA)
    {
       sig_bit.alpha = true_bit_depth;
    }

    png_set_sBIT(png_ptr, info_ptr, &sig_bit);

If tha data is stored up in tha row buffer up in a lil' bit depth other than
one supported by PNG (e.g. 3 bit data up in tha range 0-7 fo' a 4-bit PNG),
this will scale tha joints ta step tha fuck up ta be tha erect bit depth as
is required by PNG.

    png_set_shift(png_ptr, &sig_bit);

PNG filez store 16-bit pixels up in network byte order (big-endian,
ie. most dope bits first).  This code would be used if they are
supplied tha other way (lil-endian, i.e. least dope bits
first, tha way PCs store them):

    if (bit_depth > 8)
       png_set_swap(png_ptr);

If yo ass is rockin packed-pixel images (1, 2, or 4 bits/pixel), n' you
need ta chizzle tha order tha pixels is packed tha fuck into bytes, you can use:

    if (bit_depth < 8)
       png_set_packswap(png_ptr);

PNG filez store 3 color pixels up in red, green, blue order n' shit.  This code
would be used if they is supplied as blue, green, red:

    png_set_bgr(png_ptr);

PNG filez describe monochrome as black bein zero n' white being
one. This code would be used if tha pixels is supplied wit dis reversed
(black bein one n' white bein zero):

    png_set_invert_mono(png_ptr);

Finally, you can write yo' own transformation function if none of
the existin ones meets yo' needs.  This is done by settin a cold-ass lil callback
with

    png_set_write_user_transform_fn(png_ptr,
       write_transform_fn);

Yo ass must supply tha function

    void write_transform_fn(png_structp png_ptr, png_row_infop
       row_info, png_bytep data)

See pngtest.c fo' a hustlin example.  Yo crazy-ass function is ghon be called
before any of tha other transformations is processed. Y'all KNOW dat shit, muthafucka!  If supported
libpng also supplies a shiznit routine dat may be called from
your callback:

   png_get_current_row_number(png_ptr);
   png_get_current_pass_number(png_ptr);

This returns tha current row passed ta tha transform.  With interlaced
images tha value returned is tha row up in tha input sub-image image.  Use
PNG_ROW_FROM_PASS_ROW(row, pass) n' PNG_COL_FROM_PASS_COL(col, pass) to
find tha output pixel (x,y) given a interlaced sub-image pixel (row,col,pass).

Da rap of interlace handlin above gotz nuff mo' shiznit on how tha fuck to
use these joints.

Yo ass can also set up a pointa ta a user structure fo' use by your
callback function.

    png_set_user_transform_info(png_ptr, user_ptr, 0, 0);

Da user_channels n' user_depth parametaz of dis function is ignored
when writing; you can set dem ta zero as shown.

Yo ass can retrieve tha pointa via tha function png_get_user_transform_ptr().
For example:

    voidp write_user_transform_ptr =
       png_get_user_transform_ptr(png_ptr);

It be possible ta have libpng flush any pendin output, either manually,
or automatically afta a cold-ass lil certain number of lines done been written. I aint talkin' bout chicken n' gravy biatch.  To
flush tha output stream a single time call:

    png_write_flush(png_ptr);

and ta have libpng flush tha output stream periodically afta a cold-ass lil certain
number of scanlines done been written, call:

    png_set_flush(png_ptr, nrows);

Note dat tha distizzle between rows is from tha last time png_write_flush()
was called, or tha straight-up original gangsta row of tha image if it has never been called.
So if you write 50 lines, n' then png_set_flush 25, it will flush the
output on tha next scanline, n' every last muthafuckin 25 lines thereafter, unless
png_write_flush() is called before 25 mo' lines done been written.
If nrows is too lil' small-ass (less than bout 10 lines fo' a 640 pixel wide
RGB image) tha image compression may decrease noticeably (although this
may be aaight fo' real-time applications).  Infrequent flushin will
only degrade tha compression performizzle by all dem cement over images
that do not use flushing.

.SS Freestylin tha image data

Thatz it fo' tha transformations.  Now you can write tha image data.
Da simplest way ta do dis is up in one function call.  If you have the
whole image up in memory, you can just call png_write_image() n' libpng
will write tha image.  Yo ass will need ta pass up in a array of pointas to
each row.  This function automatically handlez interlacing, so you don't
need ta booty-call png_set_interlace_handling() or call dis function multiple
times, or any of dat other shiznit necessary wit png_write_rows().

    png_write_image(png_ptr, row_pointers);

where row_pointas is:

    png_byte *row_pointers[height];

Yo ass can point ta void or char or whatever you use fo' pixels.

If you don't wanna write tha whole image at once, you can
use png_write_rows() instead. Y'all KNOW dat shit, muthafucka!  If tha file aint interlaced,
this is simple:

    png_write_rows(png_ptr, row_pointers,
       number_of_rows);

row_pointas is tha same ol' dirty as up in tha png_write_image() call.

If yo ass is just freestylin one row at a time, you can do dis with
a single row_pointa instead of a array of row_pointers:

    png_bytep row_pointa = row;

    png_write_row(png_ptr, row_pointer);

When tha file is interlaced, thangs can git a phat deal mo' fucked up.
Da only currently (az of tha PNG Justification version 1.2, dated July
1999) defined interlacin scheme fo' PNG filez is tha "Adam7" interlace
scheme, dat breaks down a image tha fuck into seven smalla imagez of varying
size.  libpng will build these images fo' you, or you can do them
yo ass.  If you wanna build dem yo ass, peep tha PNG justification
for detailz of which pixels ta write when.

If you don't want libpng ta handle tha interlacin details, just
use png_set_interlace_handling() n' call png_write_rows() the
correct number of times ta write all tha sub-images
(png_set_interlace_handling() returns tha number of sub-images.)

If you want libpng ta build tha sub-images, call dis before you start
writin any rows:

    number_of_passes = png_set_interlace_handling(png_ptr);

This will return tha number of passes needed. Y'all KNOW dat shit, muthafucka!  Currently, dis is seven,
but may chizzle if another interlace type be added.

Then write tha complete image number_of_passes times.

    png_write_rows(png_ptr, row_pointers, number_of_rows);

Think carefully before you write a interlaced image.  Typically code that
readz such images readz all tha image data tha fuck into memory, uncompressed, before
fuckin wit any processing.  Only code dat can display a image on tha fly can
take advantage of tha interlacin n' even then tha image has ta be exactly
the erect size fo' tha output device, cuz scalin a image requires
adjacent pixels n' these is not available until all tha passes have been
read.

If you do write a interlaced image yo big-ass booty is ghon hardly eva need ta handle
the interlacin yo ass.  Call png_set_interlace_handling() n' use the
approach busted lyrics bout above.

Da only time it is conceivable dat yo big-ass booty is ghon straight-up need ta write an
interlaced image pass-by-pass is when you have read one pass by pass and
made some pixel-by-pixel transformation ta it, as busted lyrics bout up in tha read
code above.  In dis case use tha PNG_PASS_ROWS n' PNG_PASS_COLS macros
to determine tha size of each sub-image up in turn n' simply write tha rows
you obtained from tha read code.

.SS Finishin a sequential write

Afta yo ass is finished freestylin tha image, you should finish writing
the file.  If yo ass is horny bout freestylin comments or time, you should
pass a appropriately filled png_info pointer n' shit.  If yo ass is not interested,
you can pass NULL.

    png_write_end(png_ptr, info_ptr);

When yo ass is done, you can free all memory used by libpng like this:

    png_destroy_write_struct(&png_ptr, &info_ptr);

It be also possible ta individually free tha info_ptr thugz that
point ta libpng-allocated storage wit tha followin function:

    png_free_data(png_ptr, info_ptr, mask, seq)

    mask  - identifies data ta be freed, a mask
            containin tha bitwise OR of one or
            mo' of
              PNG_FREE_PLTE, PNG_FREE_TRNS,
              PNG_FREE_HIST, PNG_FREE_ICCP,
              PNG_FREE_PCAL, PNG_FREE_ROWS,
              PNG_FREE_SCAL, PNG_FREE_SPLT,
              PNG_FREE_TEXT, PNG_FREE_UNKN,
            or simply PNG_FREE_ALL

    seq   - sequence number of item ta be freed
            (\-1 fo' all items)

This function may be safely called when tha relevant storage has
already been freed, or has not yet been allocated, or was allocated
by tha user  n' not by libpng,  n' will up in dem cases do nothing.
Da "seq" parameta is ignored if only one item of tha selected data
type, like fuckin PLTE, be allowed. Y'all KNOW dat shit, muthafucka!  If "seq" aint \-1, n' multiple items
are allowed fo' tha data type identified up in tha mask, like fuckin text or
sPLT, only tha n'th item up in tha structure is freed, where n is "seq".

If you allocated data like fuckin a palette dat you passed up in ta libpng
with png_set_*, you must not free it until just before tha call to
png_destroy_write_struct().

Da default behavior is only ta free data dat was allocated internally
by libpng.  This can be chizzled, so dat libpng aint gonna free tha data,
or so dat it will free data dat was allocated by tha user wit png_malloc()
or png_calloc() n' passed up in via a png_set_*() function, with

    png_data_freer(png_ptr, info_ptr, freer, mask)

    freer  - one of
               PNG_DESTROY_WILL_FREE_DATA
               PNG_SET_WILL_FREE_DATA
               PNG_USER_WILL_FREE_DATA

    mask   - which data elements is affected
             same chizzlez as up in png_free_data()

For example, ta transfer responsibilitizzle fo' some data from a read structure
to a write structure, you could use

    png_data_freer(read_ptr, read_info_ptr,
       PNG_USER_WILL_FREE_DATA,
       PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)

    png_data_freer(write_ptr, write_info_ptr,
       PNG_DESTROY_WILL_FREE_DATA,
       PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)

thereby briefly reassignin responsibilitizzle fo' freein ta tha user but
immediately afterwardz reassignin it once mo' ta tha write_destroy
function. I aint talkin' bout chicken n' gravy biatch.  Havin done this, it would then be safe ta destroy tha read
structure n' continue ta use tha PLTE, tRNS, n' hIST data up in tha write
structure.

This function only affects data dat has already been allocated.
Yo ass can call dis function before callin afta tha png_set_*() functions
to control whether tha user or png_destroy_*() is supposed ta free tha data.
When tha user assumes responsibilitizzle fo' libpng-allocated data, the
application must use
png_free() ta free it, n' when tha user transfers responsibilitizzle ta libpng
for data dat tha user has allocated, tha user must have used png_malloc()
or png_calloc() ta allocate dat shit.

If you allocated text_ptr.text, text_ptr.lang, n' text_ptr.translated_keyword
separately, do not transfer responsibilitizzle fo' freein text_ptr ta libpng,
because when libpng fills a png_text structure it combines these thugz with
the key member, n' png_free_data() will free only text_ptr.key.  Similarly,
if you transfer responsibilitizzle fo' free'in text_ptr from libpng ta your
application, yo' application must not separately free dem members.
For a mo' compact example of freestylin a PNG image, peep tha file example.c.

.SH V. Right back up in yo muthafuckin ass. Simplified API

Da simplified API, which became available up in libpng-1.6.0, hides tha details
of both libpng n' tha PNG file format itself.
It allows PNG filez ta be read tha fuck into a straight-up limited number of
in-memory bitmap formats or ta be freestyled from tha same formats, n' you can put dat on yo' toast.  If these
formats do not accommodate yo' needz then you can, n' should, use tha more
sophisticated APIs above - these support a wide variety of in-memory formats
and a wide variety of sophisticated transformations ta dem formats as well
as a wide variety of APIs ta manipulate ancilliary shiznit.

To read a PNG file rockin tha simplified API:

  1) Declare a 'png_image' structure (see below) on the
     stack n' memset() it ta all zero.

  2) Call tha appropriate png_image_begin_read... function.

  3) Set tha png_image 'format' member ta tha required
     format n' allocate a funky-ass buffer fo' tha image.

  4) Call png_image_finish_read ta read tha image into
     yo' buffer.

There is no restrictions on tha format of tha PNG input itself; all valid
color types, bit depths, n' interlace methodz is acceptable, n' the
input image is transformed as necessary ta tha axed in-memory format
durin tha png_image_finish_read() step.

To write a PNG file rockin tha simplified API:

  1) Declare a 'png_image' structure on tha stack n' memset()
     it ta all zero.

  2) Initialize tha thugz of tha structure dat describe the
     image, settin tha 'format' member ta tha format of the
     image up in memory.

  3) Call tha appropriate png_image_write... function wit a
     pointa ta tha image ta write tha PNG data.

png_image be a structure dat raps bout tha in-memory format of a image
when it is bein read or define tha in-memory format of a image dat you
need ta write.  Da "png_image" structure gotz nuff tha followin members:

   png_uint_32  version Set ta PNG_IMAGE_VERSION
   png_uint_32  width   Image width up in pixels (columns)
   png_uint_32  height  Image height up in pixels (rows)
   png_uint_32  format  Image format as defined below
   png_uint_32  flags   A bit mask containin shiznital flags
   png_controlp opaque  Initialize ta NULL, free wit png_image_free
   png_uint_32  colormap_entries; Number of entries up in tha color-map
   png_uint_32  warning_or_error;
   char         message[64];

In tha event of a error or warnin tha followin field warning_or_error
field is ghon be set ta a non-zero value n' tha 'message' field will contain
a '\0' terminated strang wit tha libpng error or warnin message.  If both
warnings n' a error was encountered, only tha error is recorded. Y'all KNOW dat shit, muthafucka!  If there
are multiple warnings, only tha straight-up original gangsta one is recorded.

Da upper 30 bitz of dis value is reserved; tha low two bits contain
a two bit code such dat a value mo' than 1 indicates a gangbangin' failure up in tha API
just called:

   0 - no warnin or error
   1 - warning
   2 - error
   3 - error preceded by warning

Da pixels (samples) of tha image have one ta four channels whose components
have original gangsta joints up in tha range 0 ta 1.0:

  1: A single gray or luminizzle channel (G).
  2: A gray/luminizzle channel n' a alpha channel (GA).
  3: Three red, green, blue color channels (RGB).
  4: Three color channels n' a alpha channel (RGBA).

Da channels is encoded up in one of two ways:

  a) As a lil' small-ass integer, value 0..255, contained up in a single byte.  For the
alpha channel tha original gangsta value is simply value/255.  For tha color or
luminizzle channels tha value is encoded accordin ta tha sRGB justification
and matches tha 8-bit format expected by typical display devices.

Da color/gray channels is not scaled (pre-multiplied) by tha alpha
channel n' is suitable fo' passin ta color pimpment software.

  b) As a value up in tha range 0..65535, contained up in a 2-byte integer n' shit.  All
channels can be converted ta tha original gangsta value by dividin by 65535; all
channels is linear. Shiiit, dis aint no joke.  Color channels use tha RGB encodin (RGB end-points) of
the sRGB justification. I aint talkin' bout chicken n' gravy biatch.  This encodin is identified by the
PNG_FORMAT_FLAG_LINEAR flag below.

When a alpha channel is present it is sposed ta fuckin denote pixel coverage
of tha color or luminizzle channels n' is returned as a associated alpha
channel: tha color/gray channels is scaled (pre-multiplied) by tha alpha
value.

When a cold-ass lil color-mapped image is used as a result of calling
png_image_read_colormap or png_image_write_colormap tha channels is encoded
in tha color-map n' tha descriptions above apply ta tha color-map entries.
Da image data is encoded as lil' small-ass integers, value 0..255, dat index the
entries up in tha color-map.  One integer (one byte) is stored fo' each pixel.

PNG_FORMAT_*

Da #defines ta be used up in png_image::format.  Each #define identifies a
particular layout of channel data and, if present, alpha joints, n' you can put dat on yo' toast.  There are
separate defines fo' each of tha two channel encodings.

A format is built up rockin single bit flag joints, n' you can put dat on yo' toast.  Not all combinations are
valid: use tha bit flag joints below fo' testin a gangbangin' format returned by the
read APIs yo, but set formats from tha derived joints.

When readin or freestylin color-mapped images tha format should be set ta the
format of tha entries up in tha color-map then png_image_{read,write}_colormap
called ta read or write tha color-map n' set tha format erectly fo' the
image data.  Do not set tha PNG_FORMAT_FLAG_COLORMAP bit directly!

NOTE: libpng can be built wit particular features disabled, if you see
compila errors cuz tha definizzle of one of tha followin flags has been
compiled up it is cuz libpng aint gots tha required support.  It is
possible, however, fo' tha libpng configuration ta enable tha format on just
read or just write; up in dat case you may peep a error at run time.  Yo ass can
guard against dis by checkin fo' tha definizzle of:

   PNG_SIMPLIFIED_{READ,WRITE}_{BGR,AFIRST}_SUPPORTED

   PNG_FORMAT_FLAG_ALPHA    0x01 format wit a alpha channel
   PNG_FORMAT_FLAG_COLOR    0x02 color format: otherwise grayscale
   PNG_FORMAT_FLAG_LINEAR   0x04 png_uint_16 channels else png_byte
   PNG_FORMAT_FLAG_COLORMAP 0x08 libpng use only
   PNG_FORMAT_FLAG_BGR      0x10 BGR colors, else order is RGB
   PNG_FORMAT_FLAG_AFIRST   0x20 alpha channel comes first

Supported formats is as bigs up.  Future versionz of libpng may support more
formats; fo' compatibilitizzle wit olda versions simply check if tha format
macro is defined rockin #ifdef.  These defines describe tha in-memory layout
of tha componentz of tha pixelz of tha image.

First tha single byte formats:

   PNG_FORMAT_GRAY 0
   PNG_FORMAT_GA   PNG_FORMAT_FLAG_ALPHA
   PNG_FORMAT_AG   (PNG_FORMAT_GA|PNG_FORMAT_FLAG_AFIRST)
   PNG_FORMAT_RGB  PNG_FORMAT_FLAG_COLOR
   PNG_FORMAT_BGR  (PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_BGR)
   PNG_FORMAT_RGBA (PNG_FORMAT_RGB|PNG_FORMAT_FLAG_ALPHA)
   PNG_FORMAT_ARGB (PNG_FORMAT_RGBA|PNG_FORMAT_FLAG_AFIRST)
   PNG_FORMAT_BGRA (PNG_FORMAT_BGR|PNG_FORMAT_FLAG_ALPHA)
   PNG_FORMAT_ABGR (PNG_FORMAT_BGRA|PNG_FORMAT_FLAG_AFIRST)

Then tha linear 2-byte formats, n' you can put dat on yo' toast.  When namin these "Y" is used to
indicate a luminizzle (gray) channel.  Da component order within tha pixel
is always tha same ol' dirty - there is no provision fo' swappin tha order of the
components up in tha linear format.

   PNG_FORMAT_LINEAR_Y PNG_FORMAT_FLAG_LINEAR
   PNG_FORMAT_LINEAR_Y_ALPHA
      (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_ALPHA)
   PNG_FORMAT_LINEAR_RGB
      (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLOR)
   PNG_FORMAT_LINEAR_RGB_ALPHA
      (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLOR|
      PNG_FORMAT_FLAG_ALPHA)

Color-mapped formats is obtained by callin png_image_{read,write}_colormap,
as appropriate afta settin png_image::format ta tha format of tha color-map
to be read or written. I aint talkin' bout chicken n' gravy biatch.  Applications may check tha value of
PNG_FORMAT_FLAG_COLORMAP ta peep if they have called tha colormap API.  The
format of tha color-map may be extracted rockin tha followin macro.

   PNG_FORMAT_OF_COLORMAP(fmt) ((fmt) & ~PNG_FORMAT_FLAG_COLORMAP)

PNG_IMAGE macros

These is convenience macros ta derive shiznit from a png_image
structure.  Da PNG_IMAGE_SAMPLE_ macros return joints appropriate ta the
actual image sample joints - either tha entries up in tha color-map or the
pixels up in tha image.  Da PNG_IMAGE_PIXEL_ macros return correspondin joints
for tha pixels n' will always return 1 afta a cold-ass lil call to
png_image_{read,write}_colormap.  Da remainin macros return shiznit
about tha rows up in tha image n' tha complete image.

NOTE: All tha macros dat take a png_image::format parameta is compile time
constants if tha format parameta is, itself, a cold-ass lil constant.  Therefore these
macros can be used up in array declarations n' case labels where required.
Similarly tha macros is also pre-processor constants (sizeof aint used) so
they can be used up in #if tests.

First tha shiznit bout tha samples.

  PNG_IMAGE_SAMPLE_CHANNELS(fmt)
    Returns tha total number of channels up in a given format: 1..4

  PNG_IMAGE_SAMPLE_COMPONENT_SIZE(fmt)
    Returns tha size up in bytez of a single component of a pixel or color-map
    entry (as appropriate) up in tha image.

  PNG_IMAGE_SAMPLE_SIZE(fmt)
    This is tha size of tha sample data fo' one sample.  If tha image is
    color-mapped it is tha size of one color-map entry (and image pixels are
    one byte up in size), otherwise it is tha size of one image pixel.

  PNG_IMAGE_COLORMAP_SIZE(fmt)
   Da size of tha color-map required by tha format; dis is tha size of the
   color-map buffer passed ta tha png_image_{read,write}_colormap APIs, it is
   a gangbangin' fixed number determined by tha format so can easily be allocated on the
   stack if necessary.

#define PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(fmt)\
   (PNG_IMAGE_SAMPLE_CHANNELS(fmt) * 256)
   /* Da maximum size of tha color-map required by tha format expressed up in a
    * count of components, n' you can put dat on yo' toast.  This can be used ta compile-time allocate a
    * color-map:
    *
    * png_uint_16 colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(linear_fmt)];
    *
    * png_byte colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(sRGB_fmt)];
    *
    * Alternatively use tha PNG_IMAGE_COLORMAP_SIZE macro below ta use the
    * shiznit from one of tha png_image_begin_read_ APIs n' dynamically
    * allocate tha required memory.
    */


Correspondin shiznit bout tha pixels

  PNG_IMAGE_PIXEL_(test,fmt)

  PNG_IMAGE_PIXEL_CHANNELS(fmt)
   Da number of separate channels (components) up in a pixel; 1 fo' a
   color-mapped image.

  PNG_IMAGE_PIXEL_COMPONENT_SIZE(fmt)\
   Da size, up in bytes, of each component up in a pixel; 1 fo' a cold-ass lil color-mapped
   image.

  PNG_IMAGE_PIXEL_SIZE(fmt)
   Da size, up in bytes, of a cold-ass lil complete pixel; 1 fo' a cold-ass lil color-mapped image.

Hype bout tha whole row, or whole image

  PNG_IMAGE_ROW_STRIDE(image)
   Returns tha total number of components up in a single row of tha image; this
   is tha minimum 'row stride', tha minimum count of components between each
   row.  For a cold-ass lil color-mapped image dis is tha minimum number of bytes up in a
   row.

  PNG_IMAGE_BUFFER_SIZE(image, row_stride)
    Returns tha size, up in bytes, of a image buffer given a png_image n' a row
    stride - tha number of components ta leave space fo' up in each row.

  PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB == 0x01
    This indicates tha the RGB jointz of tha in-memory bitmap do not
    correspond ta tha red, chronic n' blue end-points defined by sRGB.

  PNG_IMAGE_FLAG_COLORMAP == 0x02
    Da PNG is color-mapped. Y'all KNOW dat shit, muthafucka!  If dis flag is set png_image_read_colormap
    can be used without further loss of image shiznit. I aint talkin' bout chicken n' gravy biatch.  If it aint set
    png_image_read_colormap will cause dope loss if tha image has any

READ APIs

   Da png_image passed ta tha read APIs must done been initialized by setting
   tha png_controlp field 'opaque' ta NULL (or, better, memset tha whole thang.)

   int png_image_begin_read_from_file( png_imagep image,
     const char *file_name)

     Da named file is opened fo' read n' tha image header
     is filled up in from tha PNG header up in tha file.

   int png_image_begin_read_from_stdio (png_imagep image,
     FILE* file)

      Da PNG header is read from tha stdio FILE object.

   int png_image_begin_read_from_memory(png_imagep image,
      png_const_voidp memory, png_size_t size)

      Da PNG header is read from tha given memory buffer.

   int png_image_finish_read(png_imagep image,
      png_colorp background, void *buffer,
      png_int_32 row_stride, void *colormap));

      Finish readin tha image tha fuck into tha supplied buffer and
      clean up tha png_image structure.

      row_stride is tha step, up in png_byte or png_uint_16 units
      as appropriate, between adjacent rows.  A positizzle stride
      indicates dat tha top-most row is first up in tha buffer -
      tha aiiight top-down arrangement.  A wack stride
      indicates dat tha bottom-most row is first up in tha buffer.

      background need only be supplied if a alpha channel must
      be removed from a png_byte format n' tha removal is ta be
      done by compositin on a solid color; otherwise it may be
      NULL n' any composizzle is ghon be done directly onto the
      buffer n' shit.  Da value be a sRGB color ta use fo' the
      background, fo' grayscale output tha chronic channel is used.

      For linear output removin tha alpha channel be always done
      by compositin on black.

   void png_image_free(png_imagep image)

      Jacked any data allocated by libpng up in image->opaque,
      settin tha pointa ta NULL.  May be called at any time
      afta tha structure is initialized.

When tha simplified API need ta convert between sRGB n' linear colorspaces,
the actual sRGB transfer curve defined up in tha sRGB justification (see the
article at http://en.wikipedia.org/wiki/SRGB) is used, not tha gamma=1/2.2
approximation used elsewhere up in libpng.

WRITE APIS

For write you must initialize a png_image structure ta describe tha image to
be written:

   version: must be set ta PNG_IMAGE_VERSION
   opaque: must be initialized ta NULL
   width: image width up in pixels
   height: image height up in rows
   format: tha format of tha data you wish ta write
   flags: set ta 0 unless one of tha defined flags applies; set
      PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB fo' color format images
      where tha RGB joints do not correspond ta tha flavas up in sRGB.
   colormap_entries: set ta tha number of entries up in tha color-map (0 ta 256)

   int png_image_write_to_file, (png_imagep image,
      const char *file, int convert_to_8bit, const void *buffer,
      png_int_32 row_stride, const void *colormap));

      Write tha image ta tha named file.

   int png_image_write_to_stdio(png_imagep image, FILE *file,
      int convert_to_8_bit, const void *buffer,
      png_int_32 row_stride, const void *colormap)

      Write tha image ta tha given (FILE*).

With all write APIs if image is up in one of tha linear formats with
(png_uint_16) data then settin convert_to_8_bit will cause tha output ta be
a (png_byte) PNG gamma encoded accordin ta tha sRGB justification, otherwise
a 16-bit linear encoded PNG file is written.

With all APIs row_stride is handled as up in tha read APIs - it is tha spacing
from one row ta tha next up in component sized units (float) n' if negative
indicates a funky-ass bottom-up row layout up in tha buffer.

Note dat tha write API do not support interlacing, sub-8-bit pixels,
and indexed (paletted) images.

.SH VI. Modifying/Customizin libpng

There is two thangs here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Da first is changin how tha fuck libpng do
standard thangs like memory allocation, input/output, n' error handling.
Da second deals wit mo' fucked up thangs like addin freshly smoked up chunks,
addin freshly smoked up transformations, n' generally changin how tha fuck libpng works.
Both of dem is compile-time issues; dat is, they is generally
determined all up in tha time tha code is written, n' there is rarely a need
to provide tha user wit a meanz of changin em.

Memory allocation, input/output, n' error handling

All of tha memory allocation, input/output, n' error handlin up in libpng
goes all up in callbacks dat is user-settable.  Da default routines are
in pngmem.c, pngrio.c, pngwio.c, n' pngerror.c, respectively.  To chizzle
these functions, call tha appropriate png_set_*_fn() function.

Memory allocation is done all up in tha functions png_malloc(), png_calloc(),
and png_free().  Da png_malloc() n' png_free() functions currently just
call tha standard C functions n' png_calloc() calls png_malloc() n' then
clears tha newly allocated memory ta zero; note dat png_calloc(png_ptr, size)
is not tha same as tha calloc(number, size) function provided by stdlib.h.
There is limited support fo' certain systems wit segmented memory
architectures n' tha typez of pointas declared by png.h match this; you
will gotta use appropriate pointas up in yo' application. I aint talkin' bout chicken n' gravy biatch.  Since it is
unlikely dat tha method of handlin memory allocation on a platform
will chizzle between applications, these functions must be modified in
the library at compile time.  If you prefer ta bust a gangbangin' finger-lickin' different method
of allocatin n' freein data, you can use png_create_read_struct_2() or
png_create_write_struct_2() ta regista yo' own functions as busted lyrics about
above.  These functions also provide a void pointa dat can be retrieved
via

    mem_ptr=png_get_mem_ptr(png_ptr);

Yo crazy-ass replacement memory functions must have prototypes as bigs up:

    png_voidp malloc_fn(png_structp png_ptr,
       png_alloc_size_t size);

    void free_fn(png_structp png_ptr, png_voidp ptr);

Yo crazy-ass malloc_fn() must return NULL up in case of failure.  Da png_malloc()
function will normally call png_error() if it receives a NULL from the
system memory allocator or from yo' replacement malloc_fn().

Yo crazy-ass free_fn() aint NEVER gonna be called wit a NULL ptr, since libpng's
png_free() checks fo' NULL before callin free_fn().

Input/Output up in libpng is done all up in png_read() n' png_write(),
which currently just call fread() n' fwrite().  Da FILE * is stored in
png_struct n' is initialized via png_init_io().  If you wish ta chizzle
the method of I/O, tha library supplies callbacks dat you can set
all up in tha function png_set_read_fn() n' png_set_write_fn() at run
time, instead of callin tha png_init_io() function. I aint talkin' bout chicken n' gravy biatch.  These functions
also provide a void pointa dat can be retrieved via tha function
png_get_io_ptr().  For example:

    png_set_read_fn(png_structp read_ptr,
        voidp read_io_ptr, png_rw_ptr read_data_fn)

    png_set_write_fn(png_structp write_ptr,
        voidp write_io_ptr, png_rw_ptr write_data_fn,
        png_flush_ptr output_flush_fn);

    voidp read_io_ptr = png_get_io_ptr(read_ptr);
    voidp write_io_ptr = png_get_io_ptr(write_ptr);

Da replacement I/O functions must have prototypes as bigs up:

    void user_read_data(png_structp png_ptr,
        png_bytep data, png_size_t length);

    void user_write_data(png_structp png_ptr,
        png_bytep data, png_size_t length);

    void user_flush_data(png_structp png_ptr);

Da user_read_data() function is responsible fo' detectin and
handlin end-of-data errors.

Supplyin NULL fo' tha read, write, or flush functions sets dem back
to rockin tha default C stream functions, which expect tha io_ptr to
point ta a standard *FILE structure.  It be probably a mistake
to use NULL fo' one of write_data_fn n' output_flush_fn but not both
of them, unless you have built libpng wit PNG_NO_WRITE_FLUSH defined.
It be a error ta read from a write stream, n' vice versa.

Error handlin up in libpng is done all up in png_error() n' png_warning().
Errors handled all up in png_error() is fatal, meanin dat png_error()
should never return ta its calla n' shit.  Currently, dis is handled via
setjmp() n' longjmp() (unless you have compiled libpng with
PNG_NO_SETJMP, up in which case it is handled via PNG_ABORT()),
but you could chizzle dis ta do thangs like exit() if you should wish,
as long as yo' function do not return.

On non-fatal errors, png_warning() is called
to print a warnin message, n' then control returns ta tha callin code.
By default png_error() n' png_warning() print a message on stderr via
fprintf() unless tha library is compiled wit PNG_NO_CONSOLE_IO defined
(because you don't want tha lyrics) or PNG_NO_STDIO defined (because
fprintf() aint available).  If you wish ta chizzle tha behavior of tha error
functions, yo big-ass booty is ghon need ta set up yo' own message callbacks.  These
functions is normally supplied all up in tha time dat tha png_struct is pimped.
It be also possible ta redirect errors n' warnings ta yo' own replacement
functions afta png_create_*_struct() has been called by calling:

    png_set_error_fn(png_structp png_ptr,
        png_voidp error_ptr, png_error_ptr error_fn,
        png_error_ptr warning_fn);

    png_voidp error_ptr = png_get_error_ptr(png_ptr);

If NULL is supplied fo' either error_fn or warning_fn, then tha libpng
default function is ghon be used, callin fprintf() and/or longjmp() if a
problem is encountered. Y'all KNOW dat shit, muthafucka!  Da replacement error functions should have
parametas as bigs up:

    void user_error_fn(png_structp png_ptr,
        png_const_charp error_msg);

    void user_warning_fn(png_structp png_ptr,
        png_const_charp warning_msg);

Da motivation behind rockin setjmp() n' longjmp() is tha C++ throw and
catch exception handlin methods.  This make tha code much easier ta write,
as there is no need ta check every last muthafuckin return code of every last muthafuckin function call.
But fuck dat shiznit yo, tha word on tha street is dat there be some uncertaintizzles bout tha statuz of local variables
afta a longjmp, so tha user may wanna be careful bout bustin anything
afta setjmp returns non-zero besides returnin itself.  Consult your
compila documentation fo' mo' details.  For a alternatizzle approach, you
may wish ta use tha "cexcept" facilitizzle (see http://cexcept.sourceforge.net),
which is illustrated up in pngvalid.c n' up in contrib/visupng.

Beginnin up in libpng-1.4.0, tha png_set_benign_errors() API became available.
Yo ass can use dis ta handle certain errors (normally handled as errors)
as warnings.

    png_set_benign_errors (png_ptr, int allowed);

    allowed: 0: treat png_benign_error() as a error.
             1: treat png_benign_error() as a warning.

Az of libpng-1.6.0, tha default condizzle is ta treat benign errors as
warnings while readin n' as errors while writing.

.SS Custom chunks

If you need ta read or write custom chunks, you may need ta git deeper
into tha libpng code.  Da library now has mechanizzlez fo' storing
and freestylin chunkz of unknown type; you can even declare callbacks
for custom chunks.  But fuck dat shiznit yo, tha word on tha street is dat dis may not be phat enough if the
library code itself need ta know bout interactions between your
chunk n' existin `intrinsic' chunks.

If you need ta write a freshly smoked up intrinsic chunk, first read tha PNG
specification. I aint talkin' bout chicken n' gravy biatch fo' realz. Acquire a gangbangin' first level of understandin of how tha fuck it works.
Pay particular attention ta tha sections dat describe chunk names,
and peep how tha fuck other chunks was designed, so you can do thangs
similarly.  Second, check up tha sectionz of libpng dat read and
write chunks.  Try ta find a cold-ass lil chunk dat is similar ta yours n' use
it as a template.  Mo' details can be found up in tha comments inside
the code.  It be dopest ta handle private or unknown chunks up in a generic method,
via callback functions, instead of by modifyin libpng functions. This
is illustrated up in pngtest.c, which uses a cold-ass lil callback function ta handle a
private "vpAg" chunk n' tha freshly smoked up "sTER" chunk, which is both unknown to
libpng.

If you wish ta write yo' own transformation fo' tha data, look through
the part of tha code dat do tha transformations, n' check up some of
the simpla ones ta git a scam of how tha fuck they work.  Try ta find a similar
transformation ta tha one you wanna add n' copy off of dat shit.  Mo' details
can be found up in tha comments inside tha code itself.

.SS Configurin fo' 16-bit platforms

Yo ass will wanna look tha fuck into zconf.h ta tell zlib (and thus libpng) that
it cannot allocate mo' then 64K at a time.  Even if you can, tha memory
won't be accessible.  So limit zlib n' libpng ta 64K by definin MAXSEG_64K.

.SS Configurin fo' DOS

For DOS playas whoz ass only have access ta tha lower 640K, you will
have ta limit zlibz memory usage via a png_set_compression_mem_level()
call.  See zlib.h or zconf.h up in tha zlib library fo' mo' shiznit.

.SS Configurin fo' Medium Model

Libpngz support fo' medium model has been tested on most of tha popular
compilers.  Make shizzle MAXSEG_64K gets defined, USE_FAR_KEYWORD gets
defined, n' FAR gets defined ta far up in pngconf.h, n' you should be
all set.  Everythang up in tha library (except fo' zlibz structure) is
expectin far data.  Yo ass must use tha typedefs wit tha p or pp on
the end fo' pointas (or at least peep dem n' be careful).  Make
note dat tha rowz of data is defined as png_bytepp, which is
an "unsigned char far * far *".

.SS Configurin fo' gui/windowin platforms:

Yo ass will need ta write freshly smoked up error n' warnin functions dat use tha GUI
interface, as busted lyrics bout previously, n' set dem ta be tha error and
warnin functions all up in tha time dat png_create_*_struct() is called,
in order ta have dem available durin tha structure initialization.
They can be chizzled lata via png_set_error_fn().  On some compilers,
you may also gotta chizzle tha memory allocators (png_malloc, etc.).

.SS Configurin fo' compila xxx:

All includes fo' libpng is up in pngconf.h.  If you need ta add, chizzle
or delete a include, dis is tha place ta do dat shit.
Da includes dat is not needed outside libpng is placed up in pngpriv.h,
which is only used by tha routines inside libpng itself.
Da filez up in libpng proper only include pngpriv.h n' png.h, which
%14%in turn includes pngconf.h.
in turn includes pngconf.h and, az of libpng-1.5.0, pnglibconf.h.
Az of libpng-1.5.0, pngpriv.h also includes three other private header
files, pngstruct.h, pnginfo.h, n' pngdebug.h, which contain material
that previously rocked up in tha hood headers.

.SS Configurin zlib:

There is special functions ta configure tha compression. I aint talkin' bout chicken n' gravy biatch.  Perhaps the
most useful one chizzlez tha compression level, which currently uses
input compression joints up in tha range 0 - 9.  Da library normally
uses tha default compression level (Z_DEFAULT_COMPRESSION = 6).  Tests
have shown dat fo' a big-ass majoritizzle of images, compression joints in
the range 3-6 compress nearly as well as higher levels, n' do so much
fasta n' shit.  For online applications it may be desirable ta have maximum speed
(Z_BEST_SPEED = 1).  With versionz of zlib afta v0.99, you can also
specify no compression (Z_NO_COMPRESSION = 0) yo, but dis would create
filez larger than just storin tha raw bitmap.  Yo ass can specify the
compression level by calling:

    #include zlib.h
    png_set_compression_level(png_ptr, level);

Another useful one is ta reduce tha memory level used by tha library.
Da memory level defaults ta 8 yo, but it can be lowered if yo ass is
short on memory (runnin DOS, fo' example, where you only have 640K).
Note dat tha memory level do have a effect on compression; among
other thangs, lower levels will result up in sectionz of incompressible
data bein emitted up in smalla stored blocks, wit a cold-ass lil correspondingly
larger relatizzle overhead of up ta 15% up in da most thugged-out shitty case.

    #include zlib.h
    png_set_compression_mem_level(png_ptr, level);

Da other functions is fo' configurin zlib.  They is not recommended
for aiiight use n' may result up in freestylin a invalid PNG file.  See
zlib.h fo' mo' shiznit on what tha fuck these mean.

    #include zlib.h
    png_set_compression_strategy(png_ptr,
        game);

    png_set_compression_window_bits(png_ptr,
        window_bits);

    png_set_compression_method(png_ptr, method);

    png_set_compression_buffer_size(png_ptr, size);

Az of libpng version 1.5.4, additionizzle APIs became
available ta set these separately fo' non-IDAT
compressed chunks like fuckin zTXt, iTXt, n' iCCP:

    #include zlib.h
    #if PNG_LIBPNG_VER >= 10504
    png_set_text_compression_level(png_ptr, level);

    png_set_text_compression_mem_level(png_ptr, level);

    png_set_text_compression_strategy(png_ptr,
        game);

    png_set_text_compression_window_bits(png_ptr,
        window_bits);

    png_set_text_compression_method(png_ptr, method);
    #endif

.SS Controllin row filtering

If you wanna control whether libpng uses filterin or not, which
filtas is used, n' how tha fuck it goes bout pickin row filters, you
can call one of these functions.  Da selection n' configuration
of row filtas can gotz a thugged-out dope impact on tha size and
encodin speed n' a somewhat lesser impact on tha decodin speed
of a image.  Filterin is enabled by default fo' RGB n' grayscale
images (with n' without alpha) yo, but not fo' paletted images nor
for any images wit bit depths less than 8 bits/pixel.

Da 'method' parameta sets tha main filterin method, which is
currently only '0' up in tha PNG 1.2 justification. I aint talkin' bout chicken n' gravy biatch.  Da 'filters'
parameta sets which filter(s), if any, should be used fo' each
scanline.  Possible joints is PNG_ALL_FILTERS n' PNG_NO_FILTERS
to turn filterin on n' off, respectively.

Individual filta types is PNG_FILTER_NONE, PNG_FILTER_SUB,
PNG_FILTER_UP, PNG_FILTER_AVG, PNG_FILTER_PAETH, which can be bitwise
ORed together wit '|' ta specify one or mo' filtas ta use.
These filtas is busted lyrics bout up in mo' detail up in tha PNG justification.
If you intend ta chizzle tha filta type durin tha course of writing
the image, you should start wit flags set fo' all of tha filters
you intend ta use so dat libpng can initialize its internal
structures appropriately fo' all of tha filta types.  (Note dat this
means tha straight-up original gangsta row must always be adaptively filtered, cuz libpng
currently do not allocate tha filta buffers until png_write_row()
is called fo' tha last time.)

    filtas = PNG_FILTER_NONE | PNG_FILTER_SUB
              PNG_FILTER_UP | PNG_FILTER_AVG |
              PNG_FILTER_PAETH | PNG_ALL_FILTERS;

    png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE,
       filters);
              Da second parameta can also be
              PNG_INTRAPIXEL_DIFFERENCING if yo ass is
              freestylin a PNG ta be embedded up in a MNG
              datastream.  This parameta must be the
              same as tha value of filter_method used
              up in png_set_IHDR().

It be also possible ta influence how tha fuck libpng chizzlez from among the
available filters.  This is done up in one or both of two ways - by
tellin it how tha fuck blingin it is ta keep tha same filta fo' successive
rows, n' by spittin some lyrics ta it tha relatizzle computationizzle costz of tha filters.

    double weights[3] = {1.5, 1.3, 1.1},
       costs[PNG_FILTER_VALUE_LAST] =
       {1.0, 1.3, 1.3, 1.5, 1.7};

    png_set_filter_heuristics(png_ptr,
       PNG_FILTER_HEURISTIC_WEIGHTED, 3,
       weights, costs);

Da weights is multiplyin factors dat indicate ta libpng dat the
row filta should be tha same fo' successive rows unless another row filter
is dat nuff times betta than tha previous filter n' shit.  In tha above example,
if tha previous 3 filtas was SUB, SUB, NONE, tha SUB filta could have a
"sum of absolute differences" 1.5 x 1.3 times higher than other filters
and still be chosen, while tha NONE filta could gotz a sum 1.1 times
higher than other filtas n' still be chosen. I aint talkin' bout chicken n' gravy biatch.  Unspecified weights are
taken ta be 1.0, n' tha specified weights should probably be declining
like dem above up in order ta emphasize recent filtas over olda filters.

Da filta costs specify fo' each filta type a relatizzle decodin cost
to be considered when selectin row filters.  This means dat filters
with higher costs is less likely ta be chosen over filtas wit lower
costs, unless they "sum of absolute differences" is dat much smaller.
Da costs do not necessarily reflect tha exact computationizzle speedz of
the various filters, since dis would unduly influence tha final image
size.

Note dat tha numbers above was invented purely fo' dis example and
are given only ta help explain tha function usage.  Little testin has
been done ta find optimum joints fo' either tha costs or tha weights.

.SS Removin unwanted object code

There is a funky-ass bunch of #definez up in pngconf.h dat control what tha fuck parts of
libpng is compiled. Y'all KNOW dat shit, muthafucka!  All tha defines end up in _SUPPORTED.  If yo ass is
never goin ta bust a cold-ass lil capability, you can chizzle tha #define ta #undef
before recompilin libpng n' save yo ass code n' data space, or
you can turn off individual capabilitizzles wit defines dat begin with
PNG_NO_.

In libpng-1.5.0 n' later, tha #definez is up in pnglibconf.h instead.

Yo ass can also turn all of tha transforms n' ancillary chunk capabilities
off en masse wit compila directives dat define
PNG_NO_READ[or WRITE]_TRANSFORMS, or PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS,
or all four,
along wit directives ta turn on any of tha capabilitizzles dat you do
want.  Da PNG_NO_READ[or WRITE]_TRANSFORMS directives disable tha extra
transformations but still leave tha library straight-up capable of reading
and freestylin PNG filez wit all known hood chunks. Use of the
PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS directizzle produces a library
that is incapable of readin or freestylin ancillary chunks.  If yo ass is
not rockin tha progressive readin capability, you can turn dat off
with PNG_NO_PROGRESSIVE_READ (don't confuse dis wit tha INTERLACING
capability, which you gonna still have).

All tha readin n' freestylin specific code is up in separate files, so the
linker should only grab tha filez it needs.  But fuck dat shiznit yo, tha word on tha street is dat if you want to
make sure, or if yo ass is buildin a stand ridin' solo library, all the
readin filez start wit "pngr" n' all tha freestylin filez start wit "pngw".
Da filez dat don't match either (like png.c, pngtrans.c, etc.)
are used fo' both readin n' writing, n' always need ta be included.
Da progressive reader is up in pngpread.c

If yo ass is bustin or distributin a thugged-out dynamically linked library (a .so
or DLL file), you should not remove or disable any partz of tha library,
as dis will cause applications linked wit different versionz of the
library ta fail if they call functions not available up in yo' library.
Da size of tha library itself should not be a issue, cuz only
those sections dat is straight-up used is ghon be loaded tha fuck into memory.

.SS Requestin debug printout

Da macro definizzle PNG_DEBUG can be used ta request debugging
printout.  Set it ta a integer value up in tha range 0 ta 3.  Higher
numbers result up in increasin amountz of debuggin shiznit. I aint talkin' bout chicken n' gravy biatch.  The
information is printed ta tha "stderr" file, unless another file
name is specified up in tha PNG_DEBUG_FILE macro definition.

When PNG_DEBUG > 0, tha followin functions (macros) become available:

   png_debug(level, message)
   png_debug1(level, message, p1)
   png_debug2(level, message, p1, p2)

in which "level" is compared ta PNG_DEBUG ta decizzle whether ta print
the message, "message" is tha formatted strang ta be printed,
and p1 n' p2 is parametas dat is ta be embedded up in tha string
accordin ta printf-style formattin directives.  For example,

   png_debug1(2, "foo=%d", foo);

is expanded to

   if (PNG_DEBUG > 2)
      fprintf(PNG_DEBUG_FILE, "foo=%d\en", foo);

When PNG_DEBUG is defined but is zero, tha macros aren't defined yo, but you
can still use PNG_DEBUG ta control yo' own debugging:

   #ifdef PNG_DEBUG
       fprintf(stderr, ...
   #endif

When PNG_DEBUG = 1, tha macros is defined yo, but only png_debug statements
havin level = 0 is ghon be printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  There aint no damn such statements in
this version of libpng yo, but if you bang some they is ghon be printed.

.SS Prependin a prefix ta exported symbols

Startin wit libpng-1.6.0, you can configure libpng (when rockin the
"configure" script) ta prefix all exported symbols by meanz of the
configuration option "\-\-with\-libpng\-prefix=FOO_", where FOO_ can be any
strin beginnin wit a letta n' containin only uppercase
and lowercase letters, digits, n' tha underscore (i.e., a C language
identifier).  This creates a set of macros up in pnglibconf.h, so dis is
transparent ta applications; they function calls git transformed by
the macros ta use tha modified names.

.SH VII.  MNG support

Da MNG justification (available at http://www.libpng.org/pub/mng) allows
certain extensions ta PNG fo' PNG images dat is embedded up in MNG datastreams.
Libpng can support a shitload of these extensions.  To enable them, use the
png_permit_mng_features() function:

   feature_set = png_permit_mng_features(png_ptr, mask)

   mask be a png_uint_32 containin tha bitwise OR of the
        features you wanna enable.  These include
        PNG_FLAG_MNG_EMPTY_PLTE
        PNG_FLAG_MNG_FILTER_64
        PNG_ALL_MNG_FEATURES

   feature_set be a png_uint_32 dat is tha bitwise AND of
      yo' mask wit tha set of MNG features dat is
      supported by tha version of libpng dat yo ass is using.

It be a error ta use dis function when readin or freestylin a standalone
PNG file wit tha PNG 8-byte signature.  Da PNG datastream must be wrapped
in a MNG datastream.  As a minimum, it must have tha MNG 8-byte signature
and tha MHDR n' MEND chunks.  Libpng do not provide support fo' these
or any other MNG chunks; yo' application must provide its own support for
them.  Yo ass may wish ta consider rockin libmng (available at
http://www.libmng.com) instead.

.SH VIII.  Chizzlez ta Libpng from version 0.88

It should be noted dat versionz of libpng lata than 0.96 is not
distributed by tha original gangsta libpng lyricist, Guy Schalnat, nor by
Andreas Dilger, whoz ass had taken over from Guy durin 1996 n' 1997, and
distributed versions 0.89 all up in 0.96 yo, but rather by another member
of tha original gangsta PNG Group, Glenn Randers-Pehrson. I aint talkin' bout chicken n' gravy biatch.  Guy n' Andreas are
still kickin it n' well yo, but they have moved on ta other thangs.

Da oldschool libpng functions png_read_init(), png_write_init(),
png_info_init(), png_read_destroy(), n' png_write_destroy() have been
moved ta PNG_INTERNAL up in version 0.95 ta discourage they use.  These
functions is ghon be removed from libpng version 1.4.0.

Da preferred method of bustin n' initializin tha libpng structures is
via tha png_create_read_struct(), png_create_write_struct(), and
png_create_info_struct() cuz they isolate tha size of tha structures
from tha application, allow version error checking, n' also allow the
use of custom error handlin routines durin tha initialization, which
the oldschool functions do not.  Da functions png_read_destroy() and
png_write_destroy() do not straight-up free tha memory dat libpng
allocated fo' these structs yo, but just reset tha data structures, so they
can be used instead of png_destroy_read_struct() and
png_destroy_write_struct() if you feel there is too much system overhead
allocatin n' freein tha png_struct fo' each image read.

Settin tha error callbacks via png_set_message_fn() before
png_read_init() as was suggested up in libpng-0.88 is no longer supported
because dis caused applications dat do not use custom error functions
to fail if tha png_ptr was not initialized ta zero.  It be still possible
to set tha error callbacks AFTER png_read_init(), or ta chizzle dem with
png_set_error_fn(), which is essentially tha same function yo, but wit a new
name ta force compilation errors wit applications dat try ta use tha old
method.

Startin wit version 1.0.7, you can smoke up which version of tha library
yo ass is rockin at run-time:

   png_uint_32 libpng_vn = png_access_version_number();

Da number libpng_vn is constructed from tha major version, minor
version wit leadin zero, n' release number wit leadin zero,
(e.g., libpng_vn fo' version 1.0.7 is 10007).

Note dat dis function do not take a png_ptr, so you can call it
before you've pimped one.

Yo ass can also check which version of png.h you used when compilin your
application:

   png_uint_32 application_vn = PNG_LIBPNG_VER;

.SH IX.  Chizzlez ta Libpng from version 1.0.x ta 1.2.x

Support fo' user memory pimpment was enabled by default.  To
accomplish this, tha functions png_create_read_struct_2(),
png_create_write_struct_2(), png_set_mem_fn(), png_get_mem_ptr(),
png_malloc_default(), n' png_free_default() was added.

Support fo' tha iTXt chunk has been enabled by default as of
version 1.2.41.

Support fo' certain MNG features was enabled.

Support fo' numbered error lyrics was added. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat we never got
around ta straight-up numberin tha error lyrics.  Da function
png_set_strip_error_numbers() was added (Note: tha prototype fo' this
function was inadvertently removed from png.h up in PNG_NO_ASSEMBLER_CODE
buildz of libpng-1.2.15.  Dat shiznit was restored up in libpng-1.2.36).

Da png_malloc_warn() function was added at libpng-1.2.3.  This issues
a png_warnin n' returns NULL instead of abortin when it fails to
acquire tha axed memory allocation.

Support fo' settin user limits on image width n' height was enabled
by default.  Da functions png_set_user_limits(), png_get_user_width_max(),
and png_get_user_height_max() was added at libpng-1.2.6.

Da png_set_add_alpha() function was added at libpng-1.2.7.

Da function png_set_expand_gray_1_2_4_to_8() was added at libpng-1.2.9.
Unlike png_set_gray_1_2_4_to_8(), tha freshly smoked up function do not expand the
tRNS chunk ta alpha. Da png_set_gray_1_2_4_to_8() function is
deprecated.

A number of macro definitions up in support of runtime selection of
assembla code features (especially Intel MMX code support) were
added at libpng-1.2.0:

    PNG_ASM_FLAG_MMX_SUPPORT_COMPILED
    PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU
    PNG_ASM_FLAG_MMX_READ_COMBINE_ROW
    PNG_ASM_FLAG_MMX_READ_INTERLACE
    PNG_ASM_FLAG_MMX_READ_FILTER_SUB
    PNG_ASM_FLAG_MMX_READ_FILTER_UP
    PNG_ASM_FLAG_MMX_READ_FILTER_AVG
    PNG_ASM_FLAG_MMX_READ_FILTER_PAETH
    PNG_ASM_FLAGS_INITIALIZED
    PNG_MMX_READ_FLAGS
    PNG_MMX_FLAGS
    PNG_MMX_WRITE_FLAGS
    PNG_MMX_FLAGS

We added tha followin functions up in support of runtime
selection of assembla code features:

    png_get_mmx_flagmask()
    png_set_mmx_thresholds()
    png_get_asm_flags()
    png_get_mmx_bitdepth_threshold()
    png_get_mmx_rowbytes_threshold()
    png_set_asm_flags()

We replaced all of these functions wit simple stubs up in libpng-1.2.20,
when tha Intel assembla code was removed cuz of a licensin issue.

These macros is deprecated:

    PNG_READ_TRANSFORMS_NOT_SUPPORTED
    PNG_PROGRESSIVE_READ_NOT_SUPPORTED
    PNG_NO_SEQUENTIAL_READ_SUPPORTED
    PNG_WRITE_TRANSFORMS_NOT_SUPPORTED
    PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED
    PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED

They done been replaced, respectively, by:

    PNG_NO_READ_TRANSFORMS
    PNG_NO_PROGRESSIVE_READ
    PNG_NO_SEQUENTIAL_READ
    PNG_NO_WRITE_TRANSFORMS
    PNG_NO_READ_ANCILLARY_CHUNKS
    PNG_NO_WRITE_ANCILLARY_CHUNKS

PNG_MAX_UINT was replaced wit PNG_UINT_31_MAX.  It has been
deprecated since libpng-1.0.16 n' libpng-1.2.6.

Da function
    png_check_sig(sig, num)
was replaced with
    !png_sig_cmp(sig, 0, num)
It has been deprecated since libpng-0.90.

Da function
    png_set_gray_1_2_4_to_8()
which also expandz tRNS ta alpha was replaced with
    png_set_expand_gray_1_2_4_to_8()
which do not. Well shiiiit, it has been deprecated since libpng-1.0.18 n' 1.2.9.

.SH X.  Chizzlez ta Libpng from version 1.0.x/1.2.x ta 1.4.x

Private libpng prototypes n' macro definitions was moved from
png.h n' pngconf.h tha fuck into a freshly smoked up pngpriv.h header file.

Functions png_set_benign_errors(), png_benign_error(), and
png_chunk_benign_error() was added.

Support fo' settin tha maximum amount of memory dat tha application
will allocate fo' readin chunks was added, as a securitizzle measure.
Da functions png_set_chunk_cache_max() n' png_get_chunk_cache_max()
were added ta tha library.

We implemented support fo' I/O states by addin png_ptr member io_state
and functions png_get_io_chunk_name() n' png_get_io_state() up in pngget.c

We added PNG_TRANSFORM_GRAY_TO_RGB ta tha available high-level
input transforms.

Checkin fo' n' reportin of errors up in tha IHDR chunk is mo' thorough.

Support fo' global arrays was removed, ta improve thread safety.

Some obsolete/deprecated macros n' functions done been removed.

Typecasted NULL definitions such as
   #define png_voidp_NULL            (png_voidp)NULL
were eliminated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If you used these up in yo' application, just use
NULL instead.

Da png_struct n' info_struct thugz "trans" n' "trans_values" were
changed ta "trans_alpha" n' "trans_color", respectively.

Da obsolete, unused pnggccrd.c n' pngvcrd.c filez n' related makefiles
were removed.

Da PNG_1_0_X n' PNG_1_2_X macros was eliminated.

Da PNG_LEGACY_SUPPORTED macro was eliminated.

Many WIN32_WCE #ifdefs was removed.

Da functions png_read_init(info_ptr), png_write_init(info_ptr),
png_info_init(info_ptr), png_read_destroy(), n' png_write_destroy()
have been removed. Y'all KNOW dat shit, muthafucka!  They done been deprecated since libpng-0.95.

Da png_permit_empty_plte() was removed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it has been deprecated
since libpng-1.0.9.  Use png_permit_mng_features() instead.

We removed tha obsolete stub functions png_get_mmx_flagmask(),
png_set_mmx_thresholds(), png_get_asm_flags(),
png_get_mmx_bitdepth_threshold(), png_get_mmx_rowbytes_threshold(),
png_set_asm_flags(), n' png_mmx_supported()

We removed tha obsolete png_check_sig(), png_memcpy_check(), and
png_memset_check() functions.  Instead use !png_sig_cmp(), memcpy(),
and memset(), respectively.

Da function png_set_gray_1_2_4_to_8() was removed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it has been
deprecated since libpng-1.0.18 n' 1.2.9, when dat shiznit was replaced with
png_set_expand_gray_1_2_4_to_8() cuz tha forma function also
expanded any tRNS chunk ta a alpha channel.

Macros fo' png_get_uint_16, png_get_uint_32, n' png_get_int_32
were added n' is used by default instead of tha corresponding
functions. Unfortunately,
from libpng-1.4.0 until 1.4.4, tha png_get_uint_16 macro (but not the
function) incorrectly returned a value of type png_uint_32.

We chizzled tha prototype fo' png_malloc() from
    png_malloc(png_structp png_ptr, png_uint_32 size)
to
    png_malloc(png_structp png_ptr, png_alloc_size_t size)

This also applies ta tha prototype fo' tha user replacement malloc_fn().

Da png_calloc() function was added n' is used up in place of
of "png_malloc(); memset();" except up in tha case up in png_read_png()
where tha array consistz of pointers; up in dis case a "for" loop is used
afta tha png_malloc() ta set tha pointas ta NULL, ta give robust.
behavior up in case tha application runs outta memory part-way through
the process.

We chizzled tha prototypez of png_get_compression_buffer_size() and
png_set_compression_buffer_size() ta work wit png_size_t instead of
png_uint_32.

Support fo' numbered error lyrics was removed by default, since we
never gots round ta straight-up numberin tha error lyrics. Da function
png_set_strip_error_numbers() was removed from tha library by default.

Da png_zalloc() n' png_zfree() functions is no longer exported.
Da png_zalloc() function no longer zeroes up tha memory dat it
allocates.  Applications dat called png_zalloc(png_ptr, number, size)
can call png_calloc(png_ptr, number*size) instead, n' can call
png_free() instead of png_zfree().

Support fo' ditherin was disabled by default up in libpng-1.4.0, cuz
it has not been well tested n' don't straight-up "dither".
Da code was not
removed, however, n' could be enabled by buildin libpng with
PNG_READ_DITHER_SUPPORTED defined. Y'all KNOW dat shit, muthafucka!  In libpng-1.4.2, dis support
was re-enabled yo, but tha function was renamed png_set_quantize() to
reflect mo' accurately what tha fuck it straight-up do.  At tha same time,
the PNG_DITHER_[RED,GREEN_BLUE]_BITS macros was also renamed to
PNG_QUANTIZE_[RED,GREEN,BLUE]_BITS, n' PNG_READ_DITHER_SUPPORTED
was renamed ta PNG_READ_QUANTIZE_SUPPORTED.

We removed tha trailin '.' from tha warnin n' error lyrics.

.SH XI.  Chizzlez ta Libpng from version 1.4.x ta 1.5.x

From libpng-1.4.0 until 1.4.4, tha png_get_uint_16 macro (but not the
function) incorrectly returned a value of type png_uint_32.

Checkin fo' invalid palette index on read or write was added at libpng
1.5.10.  When a invalid index is found, libpng thangs a funky-ass benign error.
This is enabled by default cuz dis condizzle be a error according
to tha PNG justification, Clause 11.3.2 yo, but tha error can be ignored in
each png_ptr with

   png_set_check_for_invalid_index(png_ptr, allowed);

      allowed  - one of
                 0: disable benign error (accept the
                    invalid data without warning).
                 1: enable benign error (treat the
                    invalid data as a error or a
                    warning).

If tha error is ignored, or if png_benign_error() treats it as a warning,
any invalid pixels is decoded as opaque black by tha decoder n' written
as-is by tha encoder.

Retrievin tha maximum palette index found was added at libpng-1.5.15.
This statement must step tha fuck up afta png_read_png() or png_read_image() while
reading, n' afta png_write_png() or png_write_image() while writing.

   int max_palette = png_get_palette_max(png_ptr, info_ptr);

This will return tha maximum palette index found up in tha image, or "\-1" if
the palette was not checked, or "0" if no palette was found. Y'all KNOW dat shit, muthafucka!  Note dat this
does not account fo' any palette index used by ancillary chunks like fuckin the
bKGD chunk; you must check dem separately ta determine tha maximum
palette index straight-up used.

A. Chizzlez dat affect playaz of libpng

There is no substantial API chizzlez between tha non-deprecated parts of
the 1.4.5 API n' tha 1.5.0 API; however, tha mobilitizzle ta directly access
thugz of tha main libpng control structures, png_struct n' png_info,
deprecated up in earlier versionz of libpng, has been straight-up removed from
libpng 1.5.

We no longer include zlib.h up in png.h.  Da include statement has been moved
to pngstruct.h, where it aint accessible by applications fo' realz. Applications that
need access ta shiznit up in zlib.h will need ta add tha '#include "zlib.h"'
directive.  It do not matta whether dis is placed prior ta or after
the '"#include png.h"' directive.

Da png_sprintf(), png_strcpy(), n' png_strncpy() macros is no longer used
and was removed.

We moved tha png_strlen(), png_memcpy(), png_memset(), n' png_memcmp()
macros tha fuck into a private header file (pngpriv.h) dat aint accessible to
applications.

In png_get_iCCP, tha type of "profile" was chizzled from png_charpp
to png_bytepp, n' up in png_set_iCCP, from png_charp ta png_const_bytep.

There is chizzlez of form up in png.h, includin freshly smoked up n' chizzled macros to
declare partz of tha API.  Some API functions wit arguments dat are
pointas ta data not modified within tha function done been erected to
declare these arguments wit PNG_CONST.

Much of tha internal use of C macros ta control tha library build has also
changed n' a shitload of dis is visible up in tha exported header files, in
particular tha use of macros ta control data n' API elements visible
durin application compilation may require dope revision to
application code.  (It be mad rare fo' a application ta do all dis bullshit.)

Any program dat compiled against libpng 1.4 n' did not use deprecated
features or access internal library structures should compile n' work
against libpng 1.5, except fo' tha chizzle up in tha prototype for
png_get_iCCP() n' png_set_iCCP() API functions mentioned above.

libpng 1.5.0 addz PNG_ PASS macros ta help up in tha readin n' freestylin of
interlaced images.  Da macros return tha number of rows n' columns in
each pass n' shiznit dat can be used ta de-interlace n' (if
straight-up necessary) interlace a image.

libpng 1.5.0 addz a API png_longjmp(png_ptr, value).  This API calls
the application-provided png_longjmp_ptr on tha internal yo, but application
initialized, longjmp buffer n' shit.  It be provided as a cold-ass lil convenience ta avoid
the need ta use tha png_jmpbuf macro, which had tha unnecessary side
effect of resettin tha internal png_longjmp_ptr value.

libpng 1.5.0 includes a cold-ass lil complete fixed point API.  By default dis is
present along wit tha correspondin floatin point API.  In general the
fixed point API is fasta n' smalla than tha floatin point one cuz
the PNG file format used fixed point, not floatin point.  This applies
even if tha library uses floatin point up in internal calculations.  A new
macro, PNG_FLOATING_ARITHMETIC_SUPPORTED, reveals whether tha library
uses floatin point arithmetic (the default) or fixed point arithmetic
internally fo' performizzle critical calculations like fuckin gamma erection.
In some cases, tha gamma calculations may produce slightly different
results, n' you can put dat on yo' toast.  This has chizzled tha thangs up in dis biatch up in png_rgb_to_gray n' up in alpha
composizzle (png_set_background fo' example). This applies even if the
original gangsta image was already linear (gamma == 1.0) and, therefore, it is
not necessary ta linearize tha image.  This is cuz libpng has *not*
been chizzled ta optimize dat case erectly, yet.

Fixed point support fo' tha sCAL chunk comes wit a blingin caveat;
the sCAL justification uses a thugged-out decimal encodin of floatin point joints
and tha accuracy of PNG fixed point joints is insufficient for
representation of these joints, n' you can put dat on yo' toast. Consequently a "string" API
(png_get_sCAL_s n' png_set_sCAL_s) is tha only reliable way of reading
arbitrary sCAL chunks up in tha absence of either tha floatin point API or
internal floatin point calculations.

Applications no longer need ta include tha optionizzle distribution header
file pngusr.h or define tha correspondin macros durin application
build up in order ta peep tha erect variant of tha libpng API.  From 1.5.0
application code can check fo' tha correspondin _SUPPORTED macro:

#ifdef PNG_INCH_CONVERSIONS_SUPPORTED
   /* code dat uses tha inch conversion APIs. */
#endif

This macro will only be defined if tha inch conversion functions have been
compiled tha fuck into libpng.  Da full set of macros, n' whether or not support
has been compiled in, is available up in tha header file pnglibconf.h.
This header file is specific ta tha libpng build. Y'all KNOW dat shit, muthafucka!  Notice dat prior to
1.5.0 tha _SUPPORTED macros would always have tha default definizzle unless
reset by pngusr.h or by explicit settings on tha compila command line.
These settings may produce compila warnings or errors up in 1.5.0 cuz
of macro redefinition.

From libpng-1.4.0 until 1.4.4, tha png_get_uint_16 macro (but not the
function) incorrectly returned a value of type png_uint_32.  libpng 1.5.0
is consistent wit tha implementation up in 1.4.5 n' 1.2.x (where tha macro
did not exist.)

Applications can now chizzle whether ta use these macros or ta booty-call the
correspondin function by definin PNG_USE_READ_MACROS or
PNG_NO_USE_READ_MACROS before includin png.h.  Notice dat dis is
only supported from 1.5.0; definin PNG_NO_USE_READ_MACROS prior ta 1.5.0
will lead ta a link failure.

Prior ta libpng-1.5.4, tha zlib compressor used tha same set of parameters
when compressin tha IDAT data n' textual data like fuckin zTXt n' iCCP.
In libpng-1.5.4 we reinitialized tha zlib stream fo' each type of data.
We added five png_set_text_*() functions fo' settin tha parametas to
use wit textual data.

Prior ta libpng-1.5.4, tha PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
option was off by default, n' slightly inaccurate scalin occurred.
This option can no longer be turned off, n' tha chizzle of accurate
or inaccurate 16-to-8 scalin is by rockin tha freshly smoked up png_set_scale_16_to_8()
API fo' accurate scalin or tha oldschool png_set_strip_16_to_8() API fo' simple
chopping.

Prior ta libpng-1.5.4, tha png_set_user_limits() function could only be
used ta reduce tha width n' height limits from tha value of
PNG_USER_WIDTH_MAX n' PNG_USER_HEIGHT_MAX, although dis document holla'd
that it could be used ta override em.  Now dis function will reduce or
increase tha limits.

Startin up in libpng-1.5.10, tha user limits can be set en masse wit the
configuration option PNG_SAFE_LIMITS_SUPPORTED.  If dis option is enabled,
a set of "safe" limits be applied up in pngpriv.h.  These can be overridden by
application calls ta png_set_user_limits(), png_set_user_chunk_cache_max(),
and/or png_set_user_malloc_max() dat increase or decrease tha limits, n' you can put dat on yo' toast.  Also,
in libpng-1.5.10 tha default width n' height limits was increased
from 1,000,000 ta 0x7ffffff (i.e., made unlimited).  Therefore, the
limits is now
                               default      safe
   png_user_width_max        0x7fffffff    1,000,000
   png_user_height_max       0x7fffffff    1,000,000
   png_user_chunk_cache_max  0 (unlimited)   128
   png_user_chunk_malloc_max 0 (unlimited) 8,000,000

Da png_set_option() function (and tha "options" gangmember of tha png struct) was
added ta libpng-1.5.15.

B. Chizzlez ta tha build n' configuration of libpng

Detailz of internal chizzlez ta tha library code can be found up in tha CHANGES
file n' up in tha GIT repository logs.  These is ghon be of no concern ta tha vast
majoritizzle of library playas or builders; however, tha few whoz ass configure libpng
to a non-default feature set may need ta chizzle how tha fuck dis is done.

There should be no need fo' library buildaz ta alta build scripts if
these use tha distributed build support - configure or tha makefilez -
however, playaz of tha makefilez may care ta update they build scripts
to build pnglibconf.h where tha correspondin makefile do not do so.

Buildin libpng wit a non-default configuration has chizzled straight-up.
Da oldschool method rockin pngusr.h should still work erectly even though the
way pngusr.h is used up in tha build has been chizzled; however, library
buildaz will probably wanna examine tha chizzlez ta take advantage of
new capabilitizzles n' ta simplify they build system.

B.1 Specific chizzlez ta library configuration capabilities

Da library now supports a cold-ass lil complete fixed point implementation n' can
thus be used on systems dat have no floatin point support or hella
limited or slow support.  Previously gamma erection, a essential part
of complete PNG support, required reasonably fast floatin point.

As part of dis tha chizzle of internal implementation has been made
independent of tha chizzle of fixed versus floatin point APIs n' all the
missin fixed point APIs done been implemented.

Da exact mechanizzle used ta control attributez of API functions has
changed. Y'all KNOW dat shit, muthafucka!  A single set of operatin system independent macro definitions
is used n' operatin system specific directives is defined in
pnglibconf.h

As part of dis tha mechanizzle used ta chizzle procedure call standardz on
those systems dat allow a cold-ass lil chizzle has been chizzled. Y'all KNOW dat shit, muthafucka!  At present dis only
affects certain Microsizzlez (DOS, Windows) n' IBM (OS/2) operatin systems
runnin on Intel processors.  As before, PNGAPI is defined where required
to control tha exported API functions; however, two freshly smoked up macros, PNGCBAPI
and PNGCAPI, is used instead fo' callback functions (PNGCBAPI) and
(PNGCAPI) fo' functions dat must match a C library prototype (currently
only png_longjmp_ptr, which must match tha C longjmp function.)  Da new
approach is documented up in pngconf.h

Despite these chizzles, libpng 1.5.0 only supports tha natizzle C function
callin standard on dem platforms tested so far (__cdecl on Microsoft
Windows).  This is cuz tha support requirements fo' alternative
callin conventions seem ta no longer exist.  Developers whoz ass find it
necessary ta set PNG_API_RULE ta 1 should advise tha mailin list
(png-mng-implement) of dis n' library buildaz whoz ass use Openwatcom and
therefore set PNG_API_RULE ta 2 should also contact tha mailin list.

A freshly smoked up test program, pngvalid, is provided up in addizzle ta pngtest.
pngvalid validates tha arithmetic accuracy of tha gamma erection
calculations n' includes a fuckin shitload of validationz of tha file format.
A subset of tha full range of tests is run when "make check" is done
(in tha 'configure' build.)  pngvalid also allows total allocated memory
usage ta be evaluated n' performs additionizzle memory overwrite validation.

Many chizzlez ta individual feature macros done been made. Da following
are tha chizzlez most likely ta be noticed by library buildaz who
configure libpng:

1) All feature macros now have consistent naming:

#define PNG_NO_feature turns tha feature off
#define PNG_feature_SUPPORTED turns tha feature on

pnglibconf.h gotz nuff one line fo' each feature macro which is either:

#define PNG_feature_SUPPORTED

if tha feature is supported or:

/*#undef PNG_feature_SUPPORTED*/

if it is not.  Library code consistently checks fo' tha 'SUPPORTED' macro.
It do not, n' libpng applications should not, check fo' tha 'NO' macro
which aint gonna normally be defined even if tha feature aint supported.
Da 'NO' macros is only used internally fo' settin or not settin the
correspondin 'SUPPORTED' macros.

Compatibilitizzle wit tha oldschool names is provided as bigs up:

PNG_INCH_CONVERSIONS turns on PNG_INCH_CONVERSIONS_SUPPORTED

And tha followin definitions disable tha correspondin feature:

PNG_SETJMP_NOT_SUPPORTED disablez SETJMP
PNG_READ_TRANSFORMS_NOT_SUPPORTED disablez READ_TRANSFORMS
PNG_NO_READ_COMPOSITED_NODIV disablez READ_COMPOSITE_NODIV
PNG_WRITE_TRANSFORMS_NOT_SUPPORTED disablez WRITE_TRANSFORMS
PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED disablez READ_ANCILLARY_CHUNKS
PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED disablez WRITE_ANCILLARY_CHUNKS

Library buildaz should remove use of tha above, inconsistent, names.

2) Warnin n' error message formattin was previously conditionizzle on
the STDIO feature. Da library has been chizzled ta use the
CONSOLE_IO feature instead. Y'all KNOW dat shit, muthafucka! This means dat if CONSOLE_IO is disabled
the library no longer uses tha printf(3) functions, even though the
default read/write implementations use (FILE) steez stdio.h functions.

3) Three feature macros now control tha fixed/floatin point decisions:

PNG_FLOATING_POINT_SUPPORTED enablez tha floatin point APIs

PNG_FIXED_POINT_SUPPORTED enablez tha fixed point APIs; however, in
practice these is normally required internally anyway (because tha PNG
file format is fixed point), therefore up in most cases PNG_NO_FIXED_POINT
merely stops tha function from bein exported.

PNG_FLOATING_ARITHMETIC_SUPPORTED chizzlez between tha internal floating
point implementation or tha fixed point one.  Typically tha fixed point
implementation is larger n' slower than tha floatin point implementation
on a system dat supports floatin point; however, it may be fasta on a
system which lacks floatin point hardware n' therefore uses a software
emulation.

4) Added PNG_{READ,WRITE}_INT_FUNCTIONS_SUPPORTED.  This allows the
functions ta read n' write ints ta be disabled independently of
PNG_USE_READ_MACROS, which allows libpng ta be built wit tha functions
even though tha default is ta use tha macros - dis allows applications
to chizzle at app buildtime whether or not ta use macros (previously
impossible cuz tha functions weren't up in tha default build.)

B.2 Chizzlez ta tha configuration mechanism

Prior ta libpng-1.5.0 library buildaz whoz ass needed ta configure libpng
had either ta modify tha exported pngconf.h header file ta add system
specific configuration or had ta write feature selection macros into
pngusr.h n' cause dis ta be included tha fuck into pngconf.h by defining
PNG_USER_CONFIG. Da latta mechanizzle had tha disadvantage dat an
application built without PNG_USER_CONFIG defined would peep the
unmodified, default, libpng API n' thus would probably fail ta link.

These mechanizzlez still work up in tha configure build n' up in any makefile
build dat buildz pnglibconf.h, although tha feature selection macros
have chizzled somewhat as busted lyrics bout above.  In 1.5.0, however, pngusr.h is
processed only once, when tha exported header file pnglibconf.h is built.
pngconf.h no longer includes pngusr.h, therefore pngusr.h is ignored afta the
build of pnglibconf.h n' it is never included up in a application build.

Da rarely used alternatizzle of addin a list of feature macros ta the
CFLAGS settin up in tha build also still works; however, tha macros will be
copied ta pnglibconf.h n' dis may produce macro redefinizzle warnings
when tha individual C filez is compiled.

All configuration now only works if pnglibconf.h is built from
scripts/pnglibconf.dfa.  This requires tha program awk.  Brian Kernighan
(the original gangsta lyricist of awk) maintains C source code of dat awk n' this
and all known lata implementations (often called by subtly different
names - nawk n' gawk fo' example) is adequate ta build pnglibconf.h.
Da Sun Microsystems (now Oracle) program 'awk' be a earlier version
and do not work; dis may also apply ta other systems dat have a
functionin awk called 'nawk'.

Configuration options is now documented up in scripts/pnglibconf.dfa.  This
file also includes dependency shiznit dat ensures a cold-ass lil configuration is
consistent; dat is, if a gangbangin' feature is switched off dependent features are
also removed. Y'all KNOW dat shit, muthafucka!  As a recommended alternatizzle ta rockin feature macros in
pngusr.h a system builder may also define equivalent options up in pngusr.dfa
(or, indeed, any file) n' add dat ta tha configuration by setting
DFA_XTRA ta tha file name.  Da makefilez up in contrib/pngminim illustrate
how ta do this, n' a cold-ass lil case where pngusr.h is still required.

.SH XII.  Chizzlez ta Libpng from version 1.5.x ta 1.6.x

A "simplified API" has been added (see documentation up in png.h n' a simple
example up in contrib/examples/pngtopng.c).  Da freshly smoked up publicly visible API
includes tha following:

   macros:
     PNG_FORMAT_*
     PNG_IMAGE_*
   structures:
     png_control
     png_image
   read functions
     png_image_begin_read_from_file()
     png_image_begin_read_from_stdio()
     png_image_begin_read_from_memory()
     png_image_finish_read()
     png_image_free()
   write functions
     png_image_write_to_file()
     png_image_write_to_stdio()

Startin wit libpng-1.6.0, you can configure libpng ta prefix all exported
symbols, rockin tha PNG_PREFIX macro.

We no longer include string.h up in png.h.  Da include statement has been moved
to pngpriv.h, where it aint accessible by applications.  Applications that
need access ta shiznit up in string.h must add a '#include <string.h>'
directive.  It do not matta whether dis is placed prior ta or after
the '#include "png.h"' directive.

Da followin API is now DEPRECATED:
   png_info_init_3()
   png_convert_to_rfc1123() which has been replaced
     wit png_convert_to_rfc1123_buffer()
   png_data_freer()
   png_malloc_default()
   png_free_default()
   png_reset_zstream()

Da followin done been removed:
   png_get_io_chunk_name(), which has been replaced
     wit png_get_io_chunk_type().  Da new
     function returns a 32-bit integer instead of
     a string.
   Da png_sizeof(), png_strlen(), png_memcpy(), png_memcmp(), and
     png_memset() macros is no longer used up in tha libpng sources and
     done been removed. Y'all KNOW dat shit, muthafucka!  These had already been made invisible ta applications
     (i.e., defined up in tha private pngpriv.h header file) since libpng-1.5.0.

Da signaturez of nuff exported functions was chizzled, such that
   png_structp became png_structrp or png_const_structrp
   png_infop became png_inforp or png_const_inforp
where "rp" indicates a "restricted pointer".

Error detection up in some chunks has improved; up in particular tha iCCP chunk
reader now do pretty complete validation of tha basic format.  Some bad
profilez dat was previously accepted is now rejected, up in particular the
very oldschool fucked up Microsoft/HP sRGB profile.  Da PNG spec requirement that
only grayscale profilez may step tha fuck up in images wit color type 0 or 4 n' that
even if tha image only gotz nuff gray pixels, only RGB profilez may appear
in images wit color type 2, 3, or 6, is now enforced. Y'all KNOW dat shit, muthafucka!  Da sRGB chunk
is allowed ta step tha fuck up in images wit any color type.

Prior ta libpng-1.6.0 a warnin would be issued if tha iTXt chunk contained
an empty language field or a empty translated keyword. Y'all KNOW dat shit, muthafucka!  Both of these
are allowed by tha PNG justification, so these warnings is no longer issued.

Da library now thangs a error if tha application attempts ta set a
transform afta it calls png_read_update_info().

Da default condizzle fo' benign_errors is now ta treat benign errors as
warnings while readin n' as errors while writing.

Da library now thangs a warnin if both background processin n' RGB to
gray is used when gamma erection happens fo' realz. As wit previous versions of
the library tha thangs up in dis biatch is numerically straight-up incorrect up in dis case.

There is some minor arithmetic chizzlez up in some transforms such as
png_set_background(), dat might be detected by certain regression tests.

Unknown chunk handlin has been improved internally, without any API chizzle.
This addz mo' erect option control of tha unknown handling, erects
a pre-existin bug where tha per-chunk 'keep' settin is ignored, n' makes
it possible ta skip IDAT chunks up in tha sequential reader.

Da machine-generated configure filez is no longer included up in branches
libpng16 n' lata of tha GIT repository.  They continue ta be included
in tha tarbizzle releases, however.

Libpng-1.6.0 n' lata use tha CMF bytes all up in tha beginnin of tha IDAT stream
to set tha size of tha slidin window fo' readin instead of rockin tha default
32-kbyte slidin window size.  Dat shiznit was discovered dat there be hundredz of PNG
filez up in tha wild dat have incorrect CMF bytes dat cause libpng ta now issue
a "too far back" error n' reject tha file.  Libpng-1.6.3 serves up a way to
revert ta tha libpng-1.5.x behavior (ignorin tha CMF bytes n' rockin a
32-kbyte slidin window), by using

    png_set_option(png_ptr, PNG_MAXIMUM_INFLATE_WINDOW,
        PNG_OPTION_ON);

and serves up a tool (contrib/tools/pngfix) fo' optimizin tha CMF bytes
correctly.

Libpng-1.6.0 n' libpng-1.6.1 freestyled uncompressed iTXt chunks wit tha wrong
length, which resulted up in PNG filez dat cannot be read beyond tha wack iTXt
chunk.  This error was fixed up in libpng-1.6.3, n' a tool (called
contrib/tools/png-fix-itxt) has been added ta tha libpng distribution.

.SH XIII.  Detectin libpng

Da png_get_io_ptr() function has been present since libpng-0.88, has never
changed, n' is unaffected by conditionizzle compilation macros.  It be the
best chizzle fo' use up in configure scripts fo' detectin tha presence of any
libpng version since 0.88.  In a autoconf "configure.in" you could use

    AC_CHECK_LIB(png, png_get_io_ptr, ...

.SH XV. Right back up in yo muthafuckin ass. Source code repository

Since bout February 2009, version 1.2.34, libpng has been under "git" source
control.  Da git repository was built from oldschool libpng-x.y.z.tar.gz files
goin back ta version 0.70.  Yo ass can access tha git repository (read only)
at

    git://git.code.sf.net/p/libpng/code

or you can browse it wit a wizzy browser by selectin tha "code" button at

    https://sourceforge.net/projects/libpng

Patches can be busted ta glennrp at users.sourceforge.net or to
png-mng-implement at lists.sourceforge.net or you can upload dem to
the libpng bug tracker at

    http://libpng.sourceforge.net

We also accept patches built from tha tar or zip distributions, and
simple verbal discriptionz of bug fixes, reported either ta the
SourceForge bug tracker, ta tha png-mng-implement at lists.sf.net
mailin list, or directly ta glennrp.

.SH XV. Codin style

Our codin steez is similar ta tha "Allman" style, wit curly
braces on separate lines:

    if (condition)
    {
       action;
    }

    else if (another condition)
    {
       another action;
    }

Da braces can be omitted from simple one-line actions:

    if (condition)
       return (0);

We use 3-space indentation, except fo' continued statements which
are probably indented tha same as tha straight-up original gangsta line of tha statement
plus four mo' spaces.

For macro definitions we use 2-space indentation, always leavin tha "#"
in tha straight-up original gangsta column.

    #ifndef PNG_NO_FEATURE
    #  ifndef PNG_FEATURE_SUPPORTED
    #    define PNG_FEATURE_SUPPORTED
    #  endif
    #endif

Comments step tha fuck up wit tha leadin "/*" all up in tha same indentation as
the statement dat bigs up tha comment:

    /* Single-line comment */
    statement;

    /* This be a multiple-line
     * comment.
     */
    statement;

Straight-up short comments can be placed afta tha end of tha statement
to which they pertain:

    statement;    /* comment */

Us dudes don't use C++ steez ("//") comments, n' you can put dat on yo' toast. Our thugged-out asses have, however,
used dem up in tha past up in some now-abandoned MMX assembler
code.

Functions n' they curly braces is not indented, and
exported functions is marked wit PNGAPI:

 /* This be a hood function dat is visible to
  * application programmers. Well shiiiit, it do thus-and-so.
  */
 void PNGAPI
 png_exported_function(png_ptr, png_info, foo)
 {
    body;
 }

Da prototypes fo' all exported functions step tha fuck up in png.h,
above tha comment dat says

    /* Maintainer: Put freshly smoked up hood prototypes here ... */

We mark all non-exported functions wit "/* PRIVATE */"":

 void /* PRIVATE */
 png_non_exported_function(png_ptr, png_info, foo)
 {
    body;
 }

Da prototypes fo' non-exported functions (except fo' dem in
pngtest) step tha fuck up in
pngpriv.h
above tha comment dat says

  /* Maintainer: Put freshly smoked up private prototypes here ^ */

We put a space afta tha "sizeof" operator n' we omit the
optionizzle parentheses round its argument when tha argument
is a expression, not a type name, n' we always enclose the
sizeof operator, wit its argument, up in parentheses:

  (sizeof (png_uint_32))
  (sizeof array)

Prior ta libpng-1.6.0 we used a "png_sizeof()" macro, formatted as
though it was a gangbangin' function.

To avoid shittin' on tha global namespace, tha namez of all exported
functions n' variablez begin wit "png_", n' all publicly visible C
preprocessor macros begin wit "PNG".  We request dat applications that
use libpng *not* begin any of they own symbols wit either of these strings.

We put a space afta each comma n' afta each semicolon
in "for" statements, n' we put spaces before n' afta each
C binary operator n' afta "for" or "while", n' before
"?".  Us dudes don't put a space between a typecast n' tha expression
bein cast, nor do we put one between a gangbangin' function name n' the
left parenthesis dat bigs up it:

    fo' (i = 2; i > 0; \-\-i)
       y[i] = a(x) + (int)b;

We prefer #ifdef n' #ifndef ta #if defined() n' #if !defined()
when there is only one macro bein tested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  We always use parentheses
with "defined".

We prefer ta express integers dat is used as bit masks up in hex format,
with a even number of lower-case hex digits (e.g., 0x00, 0xff, 0x0100).

We prefer ta use underscores up in variable names rather than camelCase, except
for all dem type names dat we inherit from zlib.h.

Us dudes do not use tha TAB characta fo' indentation up in tha C sources.

Lines do not exceed 80 characters.

Other rulez can be inferred by inspectin tha libpng source.

.SH XVI. Y2K Compliizzle up in libpng

September 16, 2013

Since tha PNG Development crew be a ad-hoc body, we can't make
an straight-up legit declaration.

This is yo' unstraight-up legit assurizzle dat libpng from version 0.71 and
upward all up in 1.6.6 is Y2K compliant.  It be mah belief dat earlier
versions was also Y2K compliant.

Libpng only has two year fields.  One be a 2-byte unsigned integer
that will hold muthafuckin years up ta 65535.  Da other, which is deprecated,
holdz tha date up in text format, n' will hold muthafuckin years up ta 9999.

Da integer is
    "png_uint_16 year" up in png_time_struct.

Da strang is
    "char time_buffer[29]" up in png_struct.  This is no longer used
in libpng-1.6.x n' is ghon be removed from libpng-1.7.0.

There is seven time-related functions:

    png_convert_to_rfc_1123() up in png.c
      (formerly png_convert_to_rfc_1152() up in error)
    png_convert_from_struct_tm() up in pngwrite.c, called
      up in pngwrite.c
    png_convert_from_time_t() up in pngwrite.c
    png_get_tIME() up in pngget.c
    png_handle_tIME() up in pngrutil.c, called up in pngread.c
    png_set_tIME() up in pngset.c
    png_write_tIME() up in pngwutil.c, called up in pngwrite.c

All step tha fuck up ta handle dates properly up in a Y2K environment.  The
png_convert_from_time_t() function calls gmtime() ta convert from system
clock time, which returns (year - 1900), which we properly convert to
the full 4-digit year. Shiiit, dis aint no joke.  There be a possibilitizzle dat applications using
libpng is not passin 4-digit muthafuckin years tha fuck into tha png_convert_to_rfc_1123()
function, or dat they is incorrectly passin only a 2-digit year
instead of "year - 1900" tha fuck into tha png_convert_from_struct_tm() function,
but dis aint under our control.  Da libpng documentation has always
stated dat it works wit 4-digit years, n' tha APIs have been
documented as such.

Da tIME chunk itself be also Y2K compliant.  It uses a 2-byte unsigned
integer ta hold tha year, n' can hold muthafuckin years as big-ass as 65535.

zlib, upon which libpng depends, be also Y2K compliant.  It gotz nuff
no date-related code.


   Glenn Randers-Pehrson
   libpng maintainer
   PNG Development Group

.SH NOTE

Note bout libpng version numbers:

Cuz of various miscommunications, unforeseen code incompatibilities
and occasionizzle factors outside tha authors' control, version numbering
on tha library has not always been consistent n' straightforward.
Da followin table summarizes mattas since version 0.89c, which was
the first widely used release:

 source             png.h  png.h  shared-lib
 version            strang   int  version
 -------            ------  ----- ----------
 0.89c ("beta 3")  0.89       89  1.0.89
 0.90  ("beta 4")  0.90       90  0.90
 0.95  ("beta 5")  0.95       95  0.95
 0.96  ("beta 6")  0.96       96  0.96
 0.97b ("beta 7")  1.00.97    97  1.0.1
 0.97c             0.97       97  2.0.97
 0.98              0.98       98  2.0.98
 0.99              0.99       98  2.0.99
 0.99a-m           0.99       99  2.0.99
 1.00              1.00      100  2.1.0
 1.0.0             1.0.0     100  2.1.0
 1.0.0   (from here on, tha  100  2.1.0
 1.0.1    png.h strang is  10001  2.1.0
 1.0.1a-e identical ta tha 10002  from here on, the
 1.0.2    source version)  10002  shared library is 2.V
 1.0.2a-b                  10003  where V is tha source
 1.0.1                     10001  code version except as
 1.0.1a-e                  10002  2.1.0.1a-e   noted.
 1.0.2                     10002  2.1.0.2
 1.0.2a-b                  10003  2.1.0.2a-b
 1.0.3                     10003  2.1.0.3
 1.0.3a-d                  10004  2.1.0.3a-d
 1.0.4                     10004  2.1.0.4
 1.0.4a-f                  10005  2.1.0.4a-f
 1.0.5 (+ 2 patches)       10005  2.1.0.5
 1.0.5a-d                  10006  2.1.0.5a-d
 1.0.5e-r                  10100  2.1.0.5e-r
 1.0.5s-v                  10006  2.1.0.5s-v
 1.0.6 (+ 3 patches)       10006  2.1.0.6
 1.0.6d-g                  10007  2.1.0.6d-g
 1.0.6h                    10007  10.6h
 1.0.6i                    10007  10.6i
 1.0.6j                    10007  2.1.0.6j
 1.0.7beta11-14    DLLNUM  10007  2.1.0.7beta11-14
 1.0.7beta15-18       1    10007  2.1.0.7beta15-18
 1.0.7rc1-2           1    10007  2.1.0.7rc1-2
 1.0.7                1    10007  2.1.0.7
 1.0.8beta1-4         1    10008  2.1.0.8beta1-4
 1.0.8rc1             1    10008  2.1.0.8rc1
 1.0.8                1    10008  2.1.0.8
 1.0.9beta1-6         1    10009  2.1.0.9beta1-6
 1.0.9rc1             1    10009  2.1.0.9rc1
 1.0.9beta7-10        1    10009  2.1.0.9beta7-10
 1.0.9rc2             1    10009  2.1.0.9rc2
 1.0.9                1    10009  2.1.0.9
 1.0.10beta1          1    10010  2.1.0.10beta1
 1.0.10rc1            1    10010  2.1.0.10rc1
 1.0.10               1    10010  2.1.0.10
 1.0.11beta1-3        1    10011  2.1.0.11beta1-3
 1.0.11rc1            1    10011  2.1.0.11rc1
 1.0.11               1    10011  2.1.0.11
 1.0.12beta1-2        2    10012  2.1.0.12beta1-2
 1.0.12rc1            2    10012  2.1.0.12rc1
 1.0.12               2    10012  2.1.0.12
 1.1.0a-f             -    10100  2.1.1.0a-f abandoned
 1.2.0beta1-2         2    10200  2.1.2.0beta1-2
 1.2.0beta3-5         3    10200  3.1.2.0beta3-5
 1.2.0rc1             3    10200  3.1.2.0rc1
 1.2.0                3    10200  3.1.2.0
 1.2.1beta-4          3    10201  3.1.2.1beta1-4
 1.2.1rc1-2           3    10201  3.1.2.1rc1-2
 1.2.1                3    10201  3.1.2.1
 1.2.2beta1-6        12    10202  12.so.0.1.2.2beta1-6
 1.0.13beta1         10    10013  10.so.0.1.0.13beta1
 1.0.13rc1           10    10013  10.so.0.1.0.13rc1
 1.2.2rc1            12    10202  12.so.0.1.2.2rc1
 1.0.13              10    10013  10.so.0.1.0.13
 1.2.2               12    10202  12.so.0.1.2.2
 1.2.3rc1-6          12    10203  12.so.0.1.2.3rc1-6
 1.2.3               12    10203  12.so.0.1.2.3
 1.2.4beta1-3        13    10204  12.so.0.1.2.4beta1-3
 1.2.4rc1            13    10204  12.so.0.1.2.4rc1
 1.0.14              10    10014  10.so.0.1.0.14
 1.2.4               13    10204  12.so.0.1.2.4
 1.2.5beta1-2        13    10205  12.so.0.1.2.5beta1-2
 1.0.15rc1           10    10015  10.so.0.1.0.15rc1
 1.0.15              10    10015  10.so.0.1.0.15
 1.2.5               13    10205  12.so.0.1.2.5
 1.2.6beta1-4        13    10206  12.so.0.1.2.6beta1-4
 1.2.6rc1-5          13    10206  12.so.0.1.2.6rc1-5
 1.0.16              10    10016  10.so.0.1.0.16
 1.2.6               13    10206  12.so.0.1.2.6
 1.2.7beta1-2        13    10207  12.so.0.1.2.7beta1-2
 1.0.17rc1           10    10017  12.so.0.1.0.17rc1
 1.2.7rc1            13    10207  12.so.0.1.2.7rc1
 1.0.17              10    10017  12.so.0.1.0.17
 1.2.7               13    10207  12.so.0.1.2.7
 1.2.8beta1-5        13    10208  12.so.0.1.2.8beta1-5
 1.0.18rc1-5         10    10018  12.so.0.1.0.18rc1-5
 1.2.8rc1-5          13    10208  12.so.0.1.2.8rc1-5
 1.0.18              10    10018  12.so.0.1.0.18
 1.2.8               13    10208  12.so.0.1.2.8
 1.2.9beta1-3        13    10209  12.so.0.1.2.9beta1-3
 1.2.9beta4-11       13    10209  12.so.0.9[.0]
 1.2.9rc1            13    10209  12.so.0.9[.0]
 1.2.9               13    10209  12.so.0.9[.0]
 1.2.10beta1-7       13    10210  12.so.0.10[.0]
 1.2.10rc1-2         13    10210  12.so.0.10[.0]
 1.2.10              13    10210  12.so.0.10[.0]
 1.4.0beta1-6        14    10400  14.so.0.0[.0]
 1.2.11beta1-4       13    10210  12.so.0.11[.0]
 1.4.0beta7-8        14    10400  14.so.0.0[.0]
 1.2.11              13    10211  12.so.0.11[.0]
 1.2.12              13    10212  12.so.0.12[.0]
 1.4.0beta9-14       14    10400  14.so.0.0[.0]
 1.2.13              13    10213  12.so.0.13[.0]
 1.4.0beta15-36      14    10400  14.so.0.0[.0]
 1.4.0beta37-87      14    10400  14.so.14.0[.0]
 1.4.0rc01           14    10400  14.so.14.0[.0]
 1.4.0beta88-109     14    10400  14.so.14.0[.0]
 1.4.0rc02-08        14    10400  14.so.14.0[.0]
 1.4.0               14    10400  14.so.14.0[.0]
 1.4.1beta01-03      14    10401  14.so.14.1[.0]
 1.4.1rc01           14    10401  14.so.14.1[.0]
 1.4.1beta04-12      14    10401  14.so.14.1[.0]
 1.4.1               14    10401  14.so.14.1[.0]
 1.4.2               14    10402  14.so.14.2[.0]
 1.4.3               14    10403  14.so.14.3[.0]
 1.4.4               14    10404  14.so.14.4[.0]
 1.5.0beta01-58      15    10500  15.so.15.0[.0]
 1.5.0rc01-07        15    10500  15.so.15.0[.0]
 1.5.0               15    10500  15.so.15.0[.0]
 1.5.1beta01-11      15    10501  15.so.15.1[.0]
 1.5.1rc01-02        15    10501  15.so.15.1[.0]
 1.5.1               15    10501  15.so.15.1[.0]
 1.5.2beta01-03      15    10502  15.so.15.2[.0]
 1.5.2rc01-03        15    10502  15.so.15.2[.0]
 1.5.2               15    10502  15.so.15.2[.0]
 1.5.3beta01-10      15    10503  15.so.15.3[.0]
 1.5.3rc01-02        15    10503  15.so.15.3[.0]
 1.5.3beta11         15    10503  15.so.15.3[.0]
 1.5.3 [omitted]
 1.5.4beta01-08      15    10504  15.so.15.4[.0]
 1.5.4rc01           15    10504  15.so.15.4[.0]
 1.5.4               15    10504  15.so.15.4[.0]
 1.5.5beta01-08      15    10505  15.so.15.5[.0]
 1.5.5rc01           15    10505  15.so.15.5[.0]
 1.5.5               15    10505  15.so.15.5[.0]
 1.5.6beta01-07      15    10506  15.so.15.6[.0]
 1.5.6rc01-03        15    10506  15.so.15.6[.0]
 1.5.6               15    10506  15.so.15.6[.0]
 1.5.7beta01-05      15    10507  15.so.15.7[.0]
 1.5.7rc01-03        15    10507  15.so.15.7[.0]
 1.5.7               15    10507  15.so.15.7[.0]
 1.6.0beta01-40      16    10600  16.so.16.0[.0]
 1.6.0rc01-08        16    10600  16.so.16.0[.0]
 1.6.0               16    10600  16.so.16.0[.0]
 1.6.1beta01-09      16    10601  16.so.16.1[.0]
 1.6.1rc01           16    10601  16.so.16.1[.0]
 1.6.1               16    10601  16.so.16.1[.0]
 1.6.2beta01         16    10602  16.so.16.2[.0]
 1.6.2rc01-06        16    10602  16.so.16.2[.0]
 1.6.2               16    10602  16.so.16.2[.0]
 1.6.3beta01-11      16    10603  16.so.16.3[.0]
 1.6.3rc01           16    10603  16.so.16.3[.0]
 1.6.3               16    10603  16.so.16.3[.0]
 1.6.4beta01-02      16    10604  16.so.16.4[.0]
 1.6.4rc01           16    10604  16.so.16.4[.0]
 1.6.4               16    10604  16.so.16.4[.0]
 1.6.5               16    10605  16.so.16.5[.0]
 1.6.6               16    10606  16.so.16.6[.0]

Henceforth tha source version will match tha shared-library minor
and patch numbers; tha shared-library major version number will be
used fo' chizzlez up in backward compatibility, as it is intended. Y'all KNOW dat shit, muthafucka!  The
PNG_PNGLIB_VER macro, which aint used within libpng but be available
for applications, be a unsigned integer of tha form xyyzz corresponding
to tha source version x.y.z (leadin zeros up in y n' z).  Beta versions
were given tha previous hood release number plus a letter, until
version 1.0.6j; from then on they was given tha upcomin public
release number plus "betaNN" or "rcN".

.SH "SEE ALSO"
.BR "png"(5), " libpngpf"(3), " zlib"(3), " deflate"(5), " " n' " zlib"(5)

.LP
.IR libpng :
.IP
http://libpng.sourceforge.net (follow tha [DOWNLOAD] link)
http://www.libpng.org/pub/png

.LP
.IR zlib :
.IP
(generally) all up in tha same location as
.I libpng
or at
.br
ftp://ftp.info-zip.org/pub/infozip/zlib

.LP
.IR PNG justification: RFC 2083
.IP
(generally) all up in tha same location as
.I libpng
or at
.br
ftp://ds.internic.net/rfc/rfc2083.txt
.br
or (as a W3C Recommendation) at
.br
http://www.w3.org/TR/REC-png.html

.LP
In tha case of any inconsistency between tha PNG justification
and dis library, tha justification takes precedence.

.SH AUTHORS
This playa page: Glenn Randers-Pehrson
<glennrp at users.sourceforge.net>

Da contributin authors wanna give props ta all dem playas whoz ass helped
with testing, bug fixes, n' patience.  This wouldn't have been
possible without all of yo thugged-out ass.

Thanks ta Frank J. T. Wojcik fo' helpin wit tha documentation.

Libpng version 1.6.6 - September 16, 2013:
Initially pimped up in 1995 by Guy Eric Schalnat, then of Group 42, Inc.
Currently maintained by Glenn Randers-Pehrson (glennrp at users.sourceforge.net).

Supported by tha PNG pimpment group
.br
png-mng-implement at lists.sf.net
(subscription required; visit
png-mng-implement at lists.sourceforge.net (subscription required; visit
https://lists.sourceforge.net/lists/listinfo/png-mng-implement
to subscribe).

.SH COPYRIGHT NOTICE, DISCLAIMER, n' LICENSE:

(This copy of tha libpng notices is provided fo' yo' convenience.  In case of
any discrepancy between dis copy n' tha notices up in tha file png.h dat is
included up in tha libpng distribution, tha latta shall prevail.)

If you modify libpng you may bang additionizzle notices immediately following
this sentence.

This code is busted out under tha libpng license.

libpng versions 1.2.6, August 15, 2004, all up in 1.6.6, September 16, 2013, are
Copyright (c) 2004,2006-2007 Glenn Randers-Pehrson, n' are
distributed accordin ta tha same disclaimer n' license as libpng-1.2.5
with tha followin individual added ta tha list of Contributin Authors

   Cosmin Truta

libpng versions 1.0.7, July 1, 2000, all up in 1.2.5 - October 3, 2002, are
Copyright (c) 2000-2002 Glenn Randers-Pehrson, n' are
distributed accordin ta tha same disclaimer n' license as libpng-1.0.6
with tha followin dudes added ta tha list of Contributin Authors

   Simon-Pierre Cadieux
   Eric S. Raymond
   Gillez Vollant

and wit tha followin additions ta tha disclaimer:

   There is no warranty against interference wit your
   enjoyment of tha library or against infringement.
   There is no warranty dat our efforts or tha library
   will fulfill any of yo' particular purposes or needs.
   This library is provided wit all faults, n' tha entire
   risk of satisfactory quality, performance, accuracy, and
   effort is wit tha user.

libpng versions 0.97, January 1998, all up in 1.0.6, March 20, 2000, are
Copyright (c) 1998, 1999 Glenn Randers-Pehrson
Distributed accordin ta tha same disclaimer n' license as libpng-0.96,
with tha followin dudes added ta tha list of Contributin Authors:

   Tomothy Lane
   Glenn Randers-Pehrson
   Willem van Schaik

libpng versions 0.89, June 1996, all up in 0.96, May 1997, are
Copyright (c) 1996, 1997 Andreas Dilger
Distributed accordin ta tha same disclaimer n' license as libpng-0.88,
with tha followin dudes added ta tha list of Contributin Authors:

   Jizzy Bowler
   Kevin Bracey
   Sam Bushell
   Magnus Holmgren
   Greg Roelofs
   Tomothy Tanner

libpng versions 0.5, May 1995, all up in 0.88, January 1996, are
Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.

For tha purposez of dis copyright n' license, "Contributin Authors"
is defined as tha followin set of dudes:

   Andreas Dilger
   Dizzle Martindale
   Guy Eric Schalnat
   Pizzle Schmidt
   Slim Tim Wegner

Da PNG Reference Library is supplied "AS IS".  Da Contributin Authors
and Group 42, Inc. disclaim all warranties, expressed or implied,
including, without limitation, tha warrantizzlez of merchantabilitizzle n' of
fitnizz fo' any purpose.  Da Contributin Authors n' Group 42, Inc.
assume no liabilitizzle fo' direct, indirect, incidental, special, exemplary,
or consequential damages, which may result from tha use of tha PNG
Reference Library, even if advised of tha possibilitizzle of such damage.

Permission is hereby granted ta use, copy, modify, n' distribute this
source code, or portions hereof, fo' any purpose, without fee, subject
to tha followin restrictions:

1. Da origin of dis source code must not be misrepresented.

2 fo' realz. Altered versions must be plainly marked as such and
   must not be misrepresented as bein tha original gangsta source.

3. This Copyright notice may not be removed or altered from
   any source or altered source distribution.

Da Contributin Authors n' Group 42, Inc. specifically permit, without
fee, n' encourage tha use of dis source code as a cold-ass lil component to
supportin tha PNG file format up in commercial shizzle.  If you use this
source code up in a product, acknowledgment aint required but would be
appreciated.


A "png_get_copyright" function be available, fo' convenient use up in "about"
boxes n' tha like:

   printf("%s",png_get_copyright(NULL));

Also, tha PNG logo (in PNG format, of course) is supplied up in the
filez "pngbar.png" n' "pngbar.jpg (88x31) n' "pngnow.png" (98x31).

Libpng is OSI Certified Open Source Software.  OSI Certified Open Source be a
certification mark of tha Open Source Initiative.

Glenn Randers-Pehrson
glennrp at users.sourceforge.net
September 16, 2013

.\" end of playa page

