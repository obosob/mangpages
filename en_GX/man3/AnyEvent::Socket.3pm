.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Socket 3"
.TH AnyEvent::Socket 3 "2013-07-31" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Socket \- useful IPv4 n' IPv6 stuff. also unix domain sockets, n' you can put dat on yo' toast. n' stuff.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent::Socket;
\&   
\&   tcp_connect "gameserver.deliantra.net", 13327, sub {
\&      mah ($fh) = @_
\&         or take a thugged-out dirtnap "gameserver.deliantra.net connect failed: $!";
\&   
\&      # trip off yo' filehandle
\&   };
\&   
\&   # a simple tcp server
\&   tcp_server undef, 8888, sub {
\&      mah ($fh, $host, $port) = @_;
\&   
\&      syswrite $fh, "Da internizzle is full, $host:$port. Go away!\e015\e012";
\&   };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements various utilitizzle functions fo' handlin internet
protocol addresses n' sockets, up in a as transparent n' simple way as
possible.
.PP
All functions documented without \f(CW\*(C`AnyEvent::Socket::\*(C'\fR prefix is exported
by default.
.ie n .IP "$ipn = parse_ipv4 $dotted_quad" 4
.el .IP "\f(CW$ipn\fR = parse_ipv4 \f(CW$dotted_quad\fR" 4
.IX Item "$ipn = parse_ipv4 $dotted_quad"
Tries ta parse tha given dotted quad IPv4 address n' return it in
octet form (or undef when it aint up in a parsable format). Right back up in yo muthafuckin ass. Supports all
forms specified by \s-1POSIX \s0(e.g. \f(CW10.0.0.1\fR, \f(CW10.1\fR, \f(CW\*(C`10.0x020304\*(C'\fR,
\&\f(CW0x12345678\fR or \f(CW0377.0377.0377.0377\fR).
.ie n .IP "$ipn = parse_ipv6 $textual_ipv6_address" 4
.el .IP "\f(CW$ipn\fR = parse_ipv6 \f(CW$textual_ipv6_address\fR" 4
.IX Item "$ipn = parse_ipv6 $textual_ipv6_address"
Tries ta parse tha given IPv6 address n' return it in
octet form (or undef when it aint up in a parsable format).
.Sp
Should support all forms specified by \s-1RFC 2373 \s0(and additionally all IPv4
forms supported by parse_ipv4). Note dat scope-idz is not supported
(and aint gonna parse).
.Sp
This function works similarly ta \f(CW\*(C`inet_pton AF_INET6, ...\*(C'\fR.
.Sp
Example:
.Sp
.Vb 2
\&   print unpack "H*", parse_ipv6 "2002:5345::10.0.0.1";
\&   # => 2002534500000000000000000a000001
.Ve
.ie n .IP "$token = parse_unix $hostname" 4
.el .IP "\f(CW$token\fR = parse_unix \f(CW$hostname\fR" 4
.IX Item "$token = parse_unix $hostname"
This fucntion exists mainly fo' symmetry ta tha other \f(CW\*(C`parse_protocol\*(C'\fR
functions \- it takes a hostname and, if it is \f(CW\*(C`unix/\*(C'\fR, it returns a
special address token, otherwise \f(CW\*(C`undef\*(C'\fR.
.Sp
Da only use fo' dis function is probably ta detect whether a hostname
matches whatever AnyEvent uses fo' unix domain sockets.
.ie n .IP "$ipn = parse_address $ip" 4
.el .IP "\f(CW$ipn\fR = parse_address \f(CW$ip\fR" 4
.IX Item "$ipn = parse_address $ip"
Combines \f(CW\*(C`parse_ipv4\*(C'\fR n' \f(CW\*(C`parse_ipv6\*(C'\fR up in one function. I aint talkin' bout chicken n' gravy biatch. Da address
here refers ta tha host address (not socket address) up in network form
(binary).
.Sp
If tha \f(CW$text\fR is \f(CW\*(C`unix/\*(C'\fR, then dis function returns a special token
recognised by tha other functions up in dis module ta mean \*(L"\s-1UNIX\s0 domain
socket\*(R".
.Sp
If tha \f(CW$text\fR ta parse be a mapped IPv4 up in IPv6 address (:ffff::<ipv4>),
then it is ghon be treated as a IPv4 address. If you don't want that, you
have ta booty-call \f(CW\*(C`parse_ipv4\*(C'\fR and/or \f(CW\*(C`parse_ipv6\*(C'\fR manually.
.Sp
Example:
.Sp
.Vb 2
\&   print unpack "H*", parse_address "10.1.2.3";
\&   # => 0a010203
.Ve
.ie n .IP "$ipn = AnyEvent::Socket::aton $ip" 4
.el .IP "\f(CW$ipn\fR = AnyEvent::Socket::aton \f(CW$ip\fR" 4
.IX Item "$ipn = AnyEvent::Socket::aton $ip"
Same as \f(CW\*(C`parse_address\*(C'\fR yo, but not exported (think \f(CW\*(C`Socket::inet_aton\*(C'\fR but
\&\fIwithout\fR name resolution).
.ie n .IP "($name, $aliases, $proto) = getprotobyname $name" 4
.el .IP "($name, \f(CW$aliases\fR, \f(CW$proto\fR) = getprotobyname \f(CW$name\fR" 4
.IX Item "($name, $aliases, $proto) = getprotobyname $name"
Works like tha builtin function of tha same name, except it tries hard to
work even on fucked up platforms (well, thatz windows), where getprotobyname
is traditionally straight-up unreliable.
.Sp
Example: git tha protocol number fo' \s-1TCP \s0(usually 6)
.Sp
.Vb 1
\&   mah $proto = getprotobyname "tcp";
.Ve
.ie n .IP "($host, $service) = parse_hostport $string[, $default_service]" 4
.el .IP "($host, \f(CW$service\fR) = parse_hostport \f(CW$string\fR[, \f(CW$default_service\fR]" 4
.IX Item "($host, $service) = parse_hostport $string[, $default_service]"
Splittin a strang of tha form \f(CW\*(C`hostname:port\*(C'\fR be a cold-ass lil common
problem. Unfortunately, just splittin on tha colon make it hard to
specify IPv6 addresses n' don't support tha less common but well
standardised \f(CW\*(C`[ip literal]\*(C'\fR syntax.
.Sp
This function tries ta do dis thang up in a funky-ass betta way, it supports (at
least) tha followin formats, where \f(CW\*(C`port\*(C'\fR can be a numerical port
number of a steez name, or a \f(CW\*(C`name=port\*(C'\fR string, n' tha \f(CW\*(C` port\*(C'\fR and
\&\f(CW\*(C`:port\*(C'\fR parts is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack fo' realz. Also, everywhere where a \s-1IP\s0 address is
supported a hostname or unix domain socket address be also supported (see
\&\f(CW\*(C`parse_unix\*(C'\fR), n' strings startin wit \f(CW\*(C`/\*(C'\fR will also be interpreted as
unix domain sockets.
.Sp
.Vb 8
\&   hostname:port    e.g. "www.linux.org", "www.x.de:443", "www.x.de:https=443",
\&   ipv4:port        e.g. "198.182.196.56", "127.1:22"
\&   ipv6             e.g. "::1", "affe::1"
\&   [ipv4or6]:port   e.g. "[::1]", "[10.0.1]:80"
\&   [ipv4or6] port   e.g. "[127.0.0.1]", "[www.x.org] 17"
\&   ipv4or6 port     e.g. "::1 443", "10.0.0.1 smtp"
\&   unix/:path       e.g. "unix/:/path/to/socket"
\&   /path            e.g. "/path/to/socket"
.Ve
.Sp
It also supports defaultin tha steez name up in a simple way by using
\&\f(CW$default_service\fR if no steez was detected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If neither a steez was
detected nor a thugged-out default was specified, then dis function returns the
empty list. Da same happens when a parse error was detected, like fuckin a
hostname wit a cold-ass lil colon up in it (the function is rather conservative, though).
.Sp
Example:
.Sp
.Vb 2
\&  print join ",", parse_hostport "localhost:443";
\&  # => "localhost,443"
\&
\&  print join ",", parse_hostport "localhost", "https";
\&  # => "localhost,https"
\&
\&  print join ",", parse_hostport "[::1]";
\&  # => "," (empty list)
\&
\&  print join ",", parse_host_port "/tmp/debug.sock";
\&  # => "unix/", "/tmp/debug.sock"
.Ve
.ie n .IP "$strin = format_hostport $host, $port" 4
.el .IP "\f(CW$string\fR = format_hostport \f(CW$host\fR, \f(CW$port\fR" 4
.IX Item "$strin = format_hostport $host, $port"
Takes a host (in textual form) n' a port n' formats up in unambigiously in
a way dat \f(CW\*(C`parse_hostport\*(C'\fR can parse it again. I aint talkin' bout chicken n' gravy biatch. \f(CW$port\fR can be \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "$sa_family = address_family $ipn" 4
.el .IP "\f(CW$sa_family\fR = address_family \f(CW$ipn\fR" 4
.IX Item "$sa_family = address_family $ipn"
Returns tha address crew/protocol\-family (AF_xxx/PF_xxx, up in one value :)
of tha given host address up in network format.
.ie n .IP "$text = format_ipv4 $ipn" 4
.el .IP "\f(CW$text\fR = format_ipv4 \f(CW$ipn\fR" 4
.IX Item "$text = format_ipv4 $ipn"
Expects a gangbangin' four octet strang representin a funky-ass binary IPv4 address n' returns
its textual format. Rarely used, peep \f(CW\*(C`format_address\*(C'\fR fo' a sickr
interface.
.ie n .IP "$text = format_ipv6 $ipn" 4
.el .IP "\f(CW$text\fR = format_ipv6 \f(CW$ipn\fR" 4
.IX Item "$text = format_ipv6 $ipn"
Expects a sixteen octet strang representin a funky-ass binary IPv6 address and
returns its textual format. Rarely used, peep \f(CW\*(C`format_address\*(C'\fR fo' a
nicer intercourse.
.ie n .IP "$text = format_address $ipn" 4
.el .IP "\f(CW$text\fR = format_address \f(CW$ipn\fR" 4
.IX Item "$text = format_address $ipn"
Covnvert a host address up in network format (e.g. 4 octets fo' IPv4 or 16
octets fo' IPv6) n' convert it tha fuck into textual form.
.Sp
Returns \f(CW\*(C`unix/\*(C'\fR fo' \s-1UNIX\s0 domain sockets.
.Sp
This function works similarly ta \f(CW\*(C`inet_ntop AF_INET || AF_INET6, ...\*(C'\fR,
except it automatically detects tha address type.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR if it cannot detect tha type.
.Sp
If tha \f(CW$ipn\fR be a mapped IPv4 up in IPv6 address (:ffff::<ipv4>), then just
the contained IPv4 address is ghon be returned. Y'all KNOW dat shit, muthafucka! If you do not want that, you
have ta booty-call \f(CW\*(C`format_ipv6\*(C'\fR manually.
.Sp
Example:
.Sp
.Vb 2
\&   print format_address "\ex01\ex02\ex03\ex05";
\&   => 1.2.3.5
.Ve
.ie n .IP "$text = AnyEvent::Socket::ntoa $ipn" 4
.el .IP "\f(CW$text\fR = AnyEvent::Socket::ntoa \f(CW$ipn\fR" 4
.IX Item "$text = AnyEvent::Socket::ntoa $ipn"
Same as format_address yo, but not exported (think \f(CW\*(C`inet_ntoa\*(C'\fR).
.ie n .IP "inet_aton $name_or_address, $cb\->(@addresses)" 4
.el .IP "inet_aton \f(CW$name_or_address\fR, \f(CW$cb\fR\->(@addresses)" 4
.IX Item "inet_aton $name_or_address, $cb->(@addresses)"
Works similarly ta its Socket counterpart, except dat it uses a
callback. Use tha length ta distinguish between ipv4 n' ipv6 (4 octets
for IPv4, 16 fo' IPv6), or use \f(CW\*(C`format_address\*(C'\fR ta convert it ta a more
readable format.
.Sp
Note dat \f(CW\*(C`resolve_sockaddr\*(C'\fR, while initially a mo' complex intercourse,
resolves host addresses, IDNs, steez names n' \s-1SRV\s0 recordz n' gives you
an ordered list of socket addresses ta try n' should be preferred over
\&\f(CW\*(C`inet_aton\*(C'\fR.
.Sp
Example.
.Sp
.Vb 5
\&   inet_aton "www.google.com", mah $cv = AE::cv;
\&   say unpack "H*", $_
\&      fo' $cv\->recv;
\&   # => d155e363
\&   # => d155e367 etc.
\&
\&   inet_aton "ipv6.google.com", mah $cv = AE::cv;
\&   say unpack "H*", $_
\&      fo' $cv\->recv;
\&   # => 20014860a00300000000000000000068
.Ve
.ie n .IP "$sa = AnyEvent::Socket::pack_sockaddr $service, $host" 4
.el .IP "\f(CW$sa\fR = AnyEvent::Socket::pack_sockaddr \f(CW$service\fR, \f(CW$host\fR" 4
.IX Item "$sa = AnyEvent::Socket::pack_sockaddr $service, $host"
Pack tha given port/host combination tha fuck into a funky-ass binary sockaddr
structure yo. Handlez both IPv4 n' IPv6 host addresses, as well as \s-1UNIX\s0
domain sockets (\f(CW$host\fR == \f(CW\*(C`unix/\*(C'\fR n' \f(CW$service\fR == absolute
pathname).
.Sp
Example:
.Sp
.Vb 3
\&   mah $bind = AnyEvent::Socket::pack_sockaddr 43, v195.234.53.120;
\&   bind $socket, $bind
\&      or take a thugged-out dirtnap "bind: $!";
.Ve
.ie n .IP "($service, $host) = AnyEvent::Socket::unpack_sockaddr $sa" 4
.el .IP "($service, \f(CW$host\fR) = AnyEvent::Socket::unpack_sockaddr \f(CW$sa\fR" 4
.IX Item "($service, $host) = AnyEvent::Socket::unpack_sockaddr $sa"
Unpack tha given binary sockaddr structure (as used by bind, getpeername
etc.) tha fuck into a \f(CW\*(C`$service, $host\*(C'\fR combination.
.Sp
For IPv4 n' IPv6, \f(CW$service\fR is tha port number n' \f(CW$host\fR tha host
address up in network format (binary).
.Sp
For \s-1UNIX\s0 domain sockets, \f(CW$service\fR is tha absolute pathname n' \f(CW$host\fR
is a special token dat is understood by tha other functions up in this
module (\f(CW\*(C`format_address\*(C'\fR converts it ta \f(CW\*(C`unix/\*(C'\fR).
.ie n .IP "resolve_sockaddr $node, $service, $proto, $family, $type, $cb\->([$family, $type, $proto, $sockaddr], ...)" 4
.el .IP "resolve_sockaddr \f(CW$node\fR, \f(CW$service\fR, \f(CW$proto\fR, \f(CW$family\fR, \f(CW$type\fR, \f(CW$cb\fR\->([$family, \f(CW$type\fR, \f(CW$proto\fR, \f(CW$sockaddr\fR], ...)" 4
.IX Item "resolve_sockaddr $node, $service, $proto, $family, $type, $cb->([$family, $type, $proto, $sockaddr], ...)"
Tries ta resolve tha given nodename n' steez name tha fuck into protocol crews
and sockaddr structures usable ta connect ta dis node n' steez up in a
protocol-independent way. Well shiiiit, it works remotely similar ta tha getaddrinfo
posix function.
.Sp
For internizzle addresses, \f(CW$node\fR is either a IPv4 or IPv6 address, an
internizzle hostname (\s-1DNS\s0 domain name or \s-1IDN\s0), n' \f(CW$service\fR is either
a steez name (port name from \fI/etc/skillz\fR) or a numerical port
number n' shit. If both \f(CW$node\fR n' \f(CW$service\fR is names, then \s-1SRV\s0 records
will be consulted ta find tha real service, otherwise they will be
used as-is. If you know dat tha steez name aint up in yo' skillz
database, then you can specify tha steez up in tha format \f(CW\*(C`name=port\*(C'\fR
(e.g. \f(CW\*(C`http=80\*(C'\fR).
.Sp
If a host cannot be found via \s-1DNS,\s0 then it is ghon be looked up in
\&\fI/etc/hosts\fR (or tha file specified via \f(CW$ENV{PERL_ANYEVENT_HOSTS}\fR). If they is found, tha addresses there is ghon be used. Y'all KNOW dat shit, muthafucka! Da effect be as
if entries from \fI/etc/hosts\fR would yield \f(CW\*(C`A\*(C'\fR n' \f(CW\*(C`AAAA\*(C'\fR recordz fo' the
host name unless \s-1DNS\s0 already had recordz fo' em.
.Sp
For \s-1UNIX\s0 domain sockets, \f(CW$node\fR must be tha strang \f(CW\*(C`unix/\*(C'\fR and
\&\f(CW$service\fR must be tha absolute pathname of tha socket. In dis case,
\&\f(CW$proto\fR is ghon be ignored.
.Sp
\&\f(CW$proto\fR must be a protocol name, currently \f(CW\*(C`tcp\*(C'\fR, \f(CW\*(C`udp\*(C'\fR or
\&\f(CW\*(C`sctp\*(C'\fR. Da default is currently \f(CW\*(C`tcp\*(C'\fR yo, but up in tha future, dis function
might try ta use other protocols like fuckin \f(CW\*(C`sctp\*(C'\fR, dependin on tha socket
type n' any \s-1SRV\s0 recordz it might find.
.Sp
\&\f(CW$family\fR must be either \f(CW0\fR (meanin any protocol is \s-1OK\s0), \f(CW4\fR (use
only IPv4) or \f(CW6\fR (use only IPv6). Da default is hyped up by
\&\f(CW$ENV{PERL_ANYEVENT_PROTOCOLS}\fR.
.Sp
\&\f(CW$type\fR must be \f(CW\*(C`SOCK_STREAM\*(C'\fR, \f(CW\*(C`SOCK_DGRAM\*(C'\fR or \f(CW\*(C`SOCK_SEQPACKET\*(C'\fR (or
\&\f(CW\*(C`undef\*(C'\fR up in which case it gets automatically chosen ta be \f(CW\*(C`SOCK_STREAM\*(C'\fR
unless \f(CW$proto\fR is \f(CW\*(C`udp\*(C'\fR).
.Sp
Da callback will receive zero or mo' array references dat contain
\&\f(CW\*(C`$family, $type, $proto\*(C'\fR fo' use up in \f(CW\*(C`socket\*(C'\fR n' a funky-ass binary
\&\f(CW$sockaddr\fR fo' use up in \f(CW\*(C`connect\*(C'\fR (or \f(CW\*(C`bind\*(C'\fR).
.Sp
Da application should try these up in tha order given.
.Sp
Example:
.Sp
.Vb 1
\&   resolve_sockaddr "google.com", "http", 0, undef, undef, sub { ... };
.Ve
.ie n .IP "$guard = tcp_connect $host, $service, $connect_cb[, $prepare_cb]" 4
.el .IP "\f(CW$guard\fR = tcp_connect \f(CW$host\fR, \f(CW$service\fR, \f(CW$connect_cb\fR[, \f(CW$prepare_cb\fR]" 4
.IX Item "$guard = tcp_connect $host, $service, $connect_cb[, $prepare_cb]"
This be a cold-ass lil convenience function dat creates a \s-1TCP\s0 socket n' make a
100% non-blockin connect ta tha given \f(CW$host\fR (which can be a \s-1DNS/IDN\s0
hostname or a textual \s-1IP\s0 address, or tha strang \f(CW\*(C`unix/\*(C'\fR fo' \s-1UNIX\s0 domain
sockets) n' \f(CW$service\fR (which can be a numeric port number or a service
name, or a \f(CW\*(C`servicename=portnumber\*(C'\fR string, or tha pathname ta a \s-1UNIX\s0
domain socket).
.Sp
If both \f(CW$host\fR n' \f(CW$port\fR is names, then dis function will use \s-1SRV\s0
recordz ta locate tha real target(s).
.Sp
In either case, it will create a list of target hosts (e.g. fo' multihomed
hosts or hosts wit both IPv4 n' IPv6 addresses) n' try ta connect to
each up in turn.
.Sp
Afta tha connection is established, then tha \f(CW$connect_cb\fR will be
invoked wit tha socket file handle (in non-blockin mode) as first, and
the peer host (as a textual \s-1IP\s0 address) n' peer port as second n' third
arguments, respectively. Da fourth argument be a cold-ass lil code reference dat you
can call if, fo' some reason, you don't like dis connection, which will
cause \f(CW\*(C`tcp_connect\*(C'\fR ta try tha next one (or call yo' callback without
any arguments if there be no mo' connections). In most cases, you can
simply ignore dis argument.
.Sp
.Vb 1
\&   $cb\->($filehandle, $host, $port, $retry)
.Ve
.Sp
If tha connect is unsuccessful, then tha \f(CW$connect_cb\fR is ghon be invoked
without any arguments n' \f(CW$!\fR is ghon be set appropriately (with \f(CW\*(C`ENXIO\*(C'\fR
indicatin a \s-1DNS\s0 resolution failure).
.Sp
Da callback will \fInever\fR be invoked before \f(CW\*(C`tcp_connect\*(C'\fR returns, even
if \f(CW\*(C`tcp_connect\*(C'\fR was able ta connect immediately (e.g. on unix domain
sockets).
.Sp
Da file handle is slick fo' bein plugged tha fuck into AnyEvent::Handle yo, but
can be used as a aiiight perl file handle as well.
.Sp
Unless called up in void context, \f(CW\*(C`tcp_connect\*(C'\fR returns a guard object that
will automatically quit tha connection attempt when it gets destroyed
\&\- up in which case tha callback aint gonna be invoked. Y'all KNOW dat shit, muthafucka! Destroyin it do not
do anythang ta tha socket afta tha connect was successful \- you cannot
\&\*(L"uncall\*(R" a cold-ass lil callback dat has been invoked already.
.Sp
Sometimes you need ta \*(L"prepare\*(R" tha socket before connecting, fo' example,
to \f(CW\*(C`bind\*(C'\fR it ta some port, or you want a specific connect timeout that
is lower than yo' kernelz default timeout. In dis case you can specify
a second callback, \f(CW$prepare_cb\fR. Well shiiiit, it is ghon be called wit tha file handle
in not-yet-connected state as only argument n' must return tha connection
timeout value (or \f(CW0\fR, \f(CW\*(C`undef\*(C'\fR or tha empty list ta indicate tha default
timeout is ta be used).
.Sp
Note dat tha socket could be either a IPv4 \s-1TCP\s0 socket or a IPv6 \s-1TCP\s0
socket (although only IPv4 is currently supported by dis module).
.Sp
Note ta tha skanky Microsizzlez Windows users: Windows (of course) don't
correctly signal connection errors, so unless yo' event library works
around this, failed connections will simply hang. Da only event libraries
that handle dis condizzle erectly is \s-1EV\s0 n' Glib fo' realz. Additionally,
AnyEvent works round dis bug wit Event n' up in its pure-perl
backend yo, but it ain't no stoppin cause I be still poppin' fo' realz. All other libraries cannot erectly handle dis condition. I aint talkin' bout chicken n' gravy biatch. To
lessen tha impact of dis windows bug, a thugged-out default timeout of 30 seconds
will be imposed on windows. Cygwin aint affected.
.Sp
Simple Example: connect ta localhost on port 22.
.Sp
.Vb 5
\&   tcp_connect localhost => 22, sub {
\&      mah $fh = shift
\&         or take a thugged-out dirtnap "unable ta connect: $!";
\&      # do something
\&   };
.Ve
.Sp
Complex Example: connect ta www.google.com on port 80 n' cook up a simple
\&\s-1GET\s0 request without much error handlin fo' realz. Also limit tha connection timeout
to 15 seconds.
.Sp
.Vb 4
\&   tcp_connect "www.google.com", "http",
\&      sub {
\&         mah ($fh) = @_
\&            or take a thugged-out dirtnap "unable ta connect: $!";
\&
\&         mah $handle; # avoid direct assignment so on_eof has it up in scope.
\&         $handle = freshly smoked up AnyEvent::Handle
\&            fh     => $fh,
\&            on_error => sub {
\&               AE::log error => $_[2];
\&               $_[0]\->destroy;
\&            },
\&            on_eof => sub {
\&               $handle\->destroy; # destroy handle
\&               AE::log info => "Done.";
\&            };
\&
\&         $handle\->push_write ("GET / HTTP/1.0\e015\e012\e015\e012");
\&
\&         $handle\->push_read (line => "\e015\e012\e015\e012", sub {
\&            mah ($handle, $line) = @_;
\&
\&            # print response header
\&            print "HEADER\en$line\en\enBODY\en";
\&
\&            $handle\->on_read (sub {
\&               # print response body
\&               print $_[0]\->rbuf;
\&               $_[0]\->rbuf = "";
\&            });
\&         });
\&      }, sub {
\&         mah ($fh) = @_;
\&         # could call $fh\->bind etc. here
\&
\&         15
\&      };
.Ve
.Sp
Example: connect ta a \s-1UNIX\s0 domain socket.
.Sp
.Vb 3
\&   tcp_connect "unix/", "/tmp/.X11\-unix/X0", sub {
\&      ...
\&   }
.Ve
.ie n .IP "$guard = tcp_server $host, $service, $accept_cb[, $prepare_cb]" 4
.el .IP "\f(CW$guard\fR = tcp_server \f(CW$host\fR, \f(CW$service\fR, \f(CW$accept_cb\fR[, \f(CW$prepare_cb\fR]" 4
.IX Item "$guard = tcp_server $host, $service, $accept_cb[, $prepare_cb]"
Smoke n' bind a stream socket ta tha given host address n' port, set
the \s-1SO_REUSEADDR\s0 flag (if applicable) n' call \f(CW\*(C`listen\*(C'\fR. Unlike tha name
implies, dis function can also bind on \s-1UNIX\s0 domain sockets.
.Sp
For internizzle sockets, \f(CW$host\fR must be a IPv4 or IPv6 address (or
\&\f(CW\*(C`undef\*(C'\fR, up in which case it bindz either ta \f(CW0\fR or ta \f(CW\*(C`::\*(C'\fR, depending
on whether IPv4 or IPv6 is tha preferred protocol, n' maybe ta both in
future versions, as applicable).
.Sp
To bind ta tha IPv4 wildcard address, use \f(CW0\fR, ta bind ta tha IPv6
wildcard address, use \f(CW\*(C`::\*(C'\fR.
.Sp
Da port is specified by \f(CW$service\fR, which must be either a steez name
or a numeric port number (or \f(CW0\fR or \f(CW\*(C`undef\*(C'\fR, up in which case a ephemeral
port is ghon be used).
.Sp
For \s-1UNIX\s0 domain sockets, \f(CW$host\fR must be \f(CW\*(C`unix/\*(C'\fR n' \f(CW$service\fR must be
the absolute pathname of tha socket. This function will try ta \f(CW\*(C`unlink\*(C'\fR
the socket before it tries ta bind ta it, n' will try ta unlink it after
it stops rockin dat shit. Right back up in yo muthafuckin ass. See \s-1SECURITY CONSIDERATIONS,\s0 below.
.Sp
For each freshly smoked up connection dat could be \f(CW\*(C`accept\*(C'\fRed, call tha \f(CW\*(C`$accept_cb\->($fh, $host, $port)\*(C'\fR wit tha file handle (in non-blocking
mode) as first, n' tha peer host n' port as second n' third arguments
(see \f(CW\*(C`tcp_connect\*(C'\fR fo' details).
.Sp
Croaks on any errors it can detect before tha listen.
.Sp
If called up in non-void context, then dis function returns a guard object
whose gametime it tied ta tha \s-1TCP\s0 server: If tha object gets destroyed,
the server is ghon be stopped (but existin accepted connections will
not be affected).
.Sp
Regardless, when tha function returns ta tha caller, tha socket is bound
and up in listenin state.
.Sp
If you need mo' control over tha listenin socket, you can provide a
\&\f(CW\*(C`$prepare_cb\->($fh, $host, $port)\*(C'\fR, which is called just before the
\&\f(CW\*(C`listen ()\*(C'\fR call, wit tha listen file handle as first argument, n' \s-1IP\s0
address n' port number of tha local socket endpoint as second n' third
arguments.
.Sp
It should return tha length of tha listen queue (or \f(CW0\fR fo' tha default).
.Sp
Note ta IPv6 users: RFC-compliant behaviour fo' IPv6 sockets listenin on
\&\f(CW\*(C`::\*(C'\fR is ta bind ta both IPv6 n' IPv4 addresses by default on dual-stack
hosts, n' you can put dat on yo' toast. Unfortunately, only GNU/Linux seems ta implement dis properly, so
if you want both IPv4 n' IPv6 listenin sockets you should create the
IPv6 socket first n' then attempt ta bind on tha IPv4 socket yo, but ignore
any \f(CW\*(C`EADDRINUSE\*(C'\fR errors.
.Sp
Example: bind on some \s-1TCP\s0 port on tha local machine n' tell each client
to go away.
.Sp
.Vb 2
\&   tcp_server undef, undef, sub {
\&      mah ($fh, $host, $port) = @_;
\&
\&      syswrite $fh, "Da internizzle is full, $host:$port. Go away!\e015\e012";
\&   }, sub {
\&      mah ($fh, $thishost, $thisport) = @_;
\&      AE::log info => "Bound ta $thishost, port $thisport.";
\&   };
.Ve
.Sp
Example: bind a server on a unix domain socket.
.Sp
.Vb 3
\&   tcp_server "unix/", "/tmp/mydir/mysocket", sub {
\&      mah ($fh) = @_;
\&   };
.Ve
.ie n .IP "tcp_nodelay $fh, $enable" 4
.el .IP "tcp_nodelay \f(CW$fh\fR, \f(CW$enable\fR" 4
.IX Item "tcp_nodelay $fh, $enable"
Enablez (or disables) tha \f(CW\*(C`TCP_NODELAY\*(C'\fR socket option (also known as
Naglez algorithm). Returns false on error, legit otherwise.
.ie n .IP "tcp_congestion $fh, $algorithm" 4
.el .IP "tcp_congestion \f(CW$fh\fR, \f(CW$algorithm\fR" 4
.IX Item "tcp_congestion $fh, $algorithm"
Sets tha tcp congestion avoidizzle algorithm (via tha \f(CW\*(C`TCP_CONGESTION\*(C'\fR
socket option). Da default is OS-specific yo, but is usually
\&\f(CW\*(C`reno\*(C'\fR. Typical other available chizzlez include \f(CW\*(C`cubic\*(C'\fR, \f(CW\*(C`lp\*(C'\fR, \f(CW\*(C`bic\*(C'\fR,
\&\f(CW\*(C`highspeed\*(C'\fR, \f(CW\*(C`htcp\*(C'\fR, \f(CW\*(C`hybla\*(C'\fR, \f(CW\*(C`illinois\*(C'\fR, \f(CW\*(C`scalable\*(C'\fR, \f(CW\*(C`vegas\*(C'\fR,
\&\f(CW\*(C`veno\*(C'\fR, \f(CW\*(C`westwood\*(C'\fR n' \f(CW\*(C`yeah\*(C'\fR.
.SH "SECURITY CONSIDERATIONS"
.IX Header "SECURITY CONSIDERATIONS"
This module is like powerful, wit with juice comes tha mobilitizzle ta abuse
as well: If you accept \*(L"hostnames\*(R" n' ports from untrusted sources,
then note dat dis can be played ta delete filez (host=\f(CW\*(C`unix/\*(C'\fR). This
is not straight-up a problem wit dis module, however, as blindly accepting
any address n' protocol n' tryin ta bind a server or connect ta it is
harmful up in general.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://anyevent.schmorp.de
.Ve
