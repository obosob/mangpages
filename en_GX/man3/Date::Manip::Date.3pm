.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Manip::Date 3"
.TH Date::Manip::Date 3 "2014-12-05" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::Date \- Methodz fo' hustlin wit dates
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Date::Manip::Date;
\&   $date = freshly smoked up Date::Manip::Date;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module works specifically wit date objects.
.PP
Although tha word date is used extensively here, it be actually
somewhat misleading.  Date::Manip works wit tha full calendar date
(year, month, day, n' week when appropriate), time of dizzle (hour,
minute, second), n' time unit.  It don't work wit fractional
seconds.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBbase\fR" 4
.IX Item "base"
.PD 0
.IP "\fBconfig\fR" 4
.IX Item "config"
.IP "\fBerr\fR" 4
.IX Item "err"
.IP "\fBis_date\fR" 4
.IX Item "is_date"
.IP "\fBis_delta\fR" 4
.IX Item "is_delta"
.IP "\fBis_recur\fR" 4
.IX Item "is_recur"
.IP "\fBnew\fR" 4
.IX Item "new"
.IP "\fBnew_config\fR" 4
.IX Item "new_config"
.IP "\fBnew_date\fR" 4
.IX Item "new_date"
.IP "\fBnew_delta\fR" 4
.IX Item "new_delta"
.IP "\fBnew_recur\fR" 4
.IX Item "new_recur"
.IP "\fBtz\fR" 4
.IX Item "tz"
.PD
Please refer ta tha Date::Manip::Obj documentation fo' these methods.
.IP "\fBcalc\fR" 4
.IX Item "calc"
.Vb 2
\&   $date2 = $date\->calc($delta [,$subtract]);
\&   $delta = $date\->calc($date2 [,$subtract] [,$mode]);
.Ve
.Sp
Please refer ta tha Date::Manip::Calc documentation fo' details.
.IP "\fBcmp\fR" 4
.IX Item "cmp"
.Vb 1
\&   $val = $date1\->cmp($date2);
.Ve
.Sp
This compares two different dates (both of which must be valid date
objects). Well shiiiit, it returns \-1, 0, or 1 similar ta tha cmp or <=> operators
in perl. Da comparison will automatically handle time unit differences
between tha two dates (i.e. they is ghon be sorted up in order as they
appear up in tha \s-1GMT\s0 unit).
.Sp
A warnin is printed if either of tha date objects do not include
a valid date.
.IP "\fBcomplete\fR" 4
.IX Item "complete"
.Vb 1
\&   $flag = $date\->complete([$field]);
.Ve
.Sp
This tests tha date stored up in tha object ta peep if it is complete or
truncated (see below fo' a gangbangin' finger-lickin' rap of this).
.Sp
If no \f(CW$field\fR is passed in, it returns 1 if tha date is complete, or
0 if dat shiznit was truncated n' default joints done been supplied.
.Sp
If \f(CW$field\fR is passed in, it may be one of: m, d, h, mn, s . Well shiiiit, it will
return 1 if tha value fo' dat field was specified, or 0 if a
default was used.
.IP "\fBconvert\fR" 4
.IX Item "convert"
.Vb 1
\&   $err = $date\->convert([$zone]);
.Ve
.Sp
This converts tha date stored up in tha object ta a gangbangin' finger-lickin' different time unit.
\&\f(CW$zone\fR can be tha name of a time unit. If it aint passed in, the
date is converted ta tha local time unit.
.IP "\fBholiday\fR" 4
.IX Item "holiday"
.Vb 3
\&   $name = $date\->holiday();
\&   @name = $date\->holiday();
\&   $name = $date\->event();
.Ve
.Sp
This returns tha name of tha holidizzle if \f(CW$date\fR be a holiday. It make me wanna hollar playa! If \f(CW$date\fR
is not a holiday, undef is returned. Y'all KNOW dat shit, muthafucka! If \f(CW$date\fR be a unnamed holiday,
an empty strang is returned.
.Sp
In scalar context, holidizzle returns tha name of one holidizzle dat occurs
on dat date (the one first defined up in tha config file).  In list
context, it returns all holidays on dat date.
.IP "\fBinput\fR" 4
.IX Item "input"
.Vb 1
\&   $str = $date\->input();
.Ve
.Sp
This returns tha strang dat was parsed ta form tha date.
.IP "\fBis_business_day\fR" 4
.IX Item "is_business_day"
.Vb 1
\&   $flag = $date\->is_business_day($checktime);
.Ve
.Sp
This returns 1 if \f(CW$date\fR be a funky-ass bidnizz day.
.Sp
\&\f(CW$checktime\fR may be passed in. I aint talkin' bout chicken n' gravy biatch. If it is non-zero, tha time is checked to
see if tha date be a funky-ass bidnizz dizzle n' falls within work hours.
.IP "\fBlist_holidays\fR" 4
.IX Item "list_holidays"
.Vb 1
\&  @date = $date\->list_holidays([$y]);
.Ve
.Sp
This returns a list of Date::Manip::Date objects containin all dates
durin a year which is holidays. Da times will all be 00:00:00.
.Sp
If \f(CW$y\fR aint passed in, it will list tha holidays up in tha same year as
the date stored up in \f(CW$date\fR.
.IP "\fBlist_events\fR" 4
.IX Item "list_events"
.Vb 3
\&   @list = $date\->list_events(       [$format] );
\&   @list = $date\->list_events(0      [,$format]);
\&   @list = $date\->list_events($date1 [,$format]);
.Ve
.Sp
This returns a list of events, n' you can put dat on yo' toast.  Events is defined up in tha Events section
of tha config file (discussed up in tha Date::Manip::Holidays manual).
.Sp
In tha straight-up original gangsta form, a list of all events actizzle all up in tha precise time
stored up in \f(CW$date\fR is ghon be returned.
.Sp
If tha straight-up original gangsta argument evaluates ta 0, a list of all events actizzle at
any time durin dat dizzle (Y,M,D) is returned.
.Sp
If tha straight-up original gangsta argument be another date object, all events dat is active
at any time between tha two dates (inclusive) is returned.
.Sp
By default, tha list returned iz of tha form:
.Sp
.Vb 4
\&   ( [START, END, NAME],
\&     [START, END, NAME],
\&     ...
\&   )
.Ve
.Sp
where \s-1START\s0 be a thugged-out date object when a event starts, \s-1END\s0 be a thugged-out date
object when it ends, n' \s-1NAME\s0 is tha name of tha event. Note that
\&\s-1START\s0 n' \s-1END\s0 is tha actual start n' end date of tha event n' may
be outside tha range of dates bein examined (though tha event will
obviously overlap tha range or it wouldn't be included up in tha list).
.Sp
If \f(CW$format\fR is included, it can specify a alternate format fo' the
output. Currently, tha only supported format is named \*(L"dates\*(R" and
it returns a list up in tha form:
.Sp
.Vb 4
\&   ( [DATE1, NAME1a, NAME1b, ...],
\&     [DATE2, NAME2a, NAME2b, ...],
\&     ...
\&   )
.Ve
.Sp
This includes a list of all dates durin tha range when there be a
change up in what tha fuck events is active. \s-1DATE1\s0 will always be tha start of
the range bein considered, n' (NAME1a, NAME1b, ...) is the
list of all events dat is ghon be actizzle at dat time fo' realz. At \s-1DATE2,\s0
the list of actizzle events chizzlez wit (NAME2a, NAME2b, ...) being
active.
.Sp
It be like possible dat a thugged-out date be included which has no active
events, n' up in dat case, tha list of names is ghon be empty.
.IP "\fBnearest_business_day\fR" 4
.IX Item "nearest_business_day"
.Vb 1
\&   $date\->nearest_business_day([$tomorrowfirst]);
.Ve
.Sp
This looks fo' tha work dizzle nearest ta \f(CW$date\fR.  If \f(CW$date\fR be a work day,
it is left unmodified. Y'all KNOW dat shit, muthafucka!  Otherwise, it will look forward or backwards
in time 1 dizzle at a time until a work dizzle is found. Y'all KNOW dat shit, muthafucka!  If \f(CW$tomorrowfirst\fR
is non-zero (or if it is omitted n' tha config variable TomorrowFirst
is non-zero), our slick asses look ta tha future first.  Otherwise, our slick asses look up in the
past first.  In other lyrics, up in a aiiight week, if \f(CW$date\fR is Wednesday,
\&\f(CW$date\fR is returned. Y'all KNOW dat shit, muthafucka!  If \f(CW$date\fR is Saturday, Fridizzle is returned. Y'all KNOW dat shit, muthafucka!  If
\&\f(CW$date\fR is Sunday, Mondizzle is returned. Y'all KNOW dat shit, muthafucka!  If Wednesdizzle be a holiday,
Thursdizzle is returned if \f(CW$tomorrowfirst\fR is non-nil or Tuesday
otherwise.
.IP "\fBnext_business_day\fR" 4
.IX Item "next_business_day"
.PD 0
.IP "\fBprev_business_day\fR" 4
.IX Item "prev_business_day"
.PD
.Vb 2
\&   $date\->next_business_day($off [,$checktime]);
\&   $date\->prev_business_day($off [,$checktime]);
.Ve
.Sp
Da next_business_dizzle method sets tha given date ta \f(CW$off\fR (which can be
a positizzle integer or zero) bidnizz minutes up in tha future. Da prev_business_day
method sets tha date ta \f(CW$off\fR bidnizz minutes up in tha past.
.Sp
First, \f(CW$date\fR is tested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If \f(CW$checktime\fR is nonzero, tha date must fall
on a funky-ass bidnizz date, n' durin bidnizz hours. If \f(CW$checktime\fR is zero,
the time check aint done, n' tha date must simply fall on a
businizz date.
.Sp
If tha check fails, tha date is moved ta tha start of tha next
businizz dizzle (if \f(CW$checktime\fR is nonzero) or tha next bidnizz dizzle at
the current time (if \f(CW$checktime\fR is zero). Otherwise, it is left
unmodified.
.Sp
Next, if \f(CW$off\fR is pimped outa than 0, tha dizzle \f(CW$off\fR work minutes from now is
determined.
.Sp
One thang ta note fo' tha prev_business_dizzle method is dat if \f(CW$date\fR
check fails, tha date is set ta tha next bidnizz date, exactly like
next_business_day. It make me wanna hollar playa! In other lyrics, if \f(CW$date\fR aint a funky-ass bidnizz day, the
call:
.Sp
.Vb 1
\&   $date\->prev_business_day(0 [,$checktime]);
.Ve
.Sp
moves \f(CW$date\fR forward up in time instead of backward which is nonintuitive,
but you just gotta be thinkin of dizzle 0 as bein tha next bidnizz dizzle if
\&\f(CW$date\fR aint a funky-ass bidnizz day.
.Sp
As a result, tha followin two calls \s-1ALWAYS\s0 give tha same result:
.Sp
.Vb 2
\&   $date\->next_business_day(0 [,$checktime]);
\&   $date\->prev_business_day(0 [,$checktime]);
.Ve
.Sp
no matta what tha fuck date is stored up in \f(CW$date\fR.
.IP "\fBparse\fR" 4
.IX Item "parse"
.Vb 1
\&   $err = $date\->parse($strin [,@opts]);
.Ve
.Sp
This parses a strang which should include a valid date n' stores
it up in tha object. If tha strang do not include a valid date, an
error is returned. Y'all KNOW dat shit, muthafucka! Use tha err method ta peep tha full error
message.
.Sp
A full date may include a cold-ass lil calendar date (year, month, day), a time of
dizzle (hour, minute, second), n' time unit shiznit. I aint talkin' bout chicken n' gravy biatch fo' realz. All of dis can
be entered up in nuff different formats.
.Sp
For shiznit on valid date formats, refer ta tha section \s-1VALID
DATE FORMATS.\s0 For shiznit on valid time unit shiznit, refer
to tha section \s-1VALID TIME ZONE FORMATS.\s0
.Sp
If no time unit shiznit is included up in tha date, it is treated
as bein up in tha local time unit.
.Sp
If time unit shiznit is included, tha date is ghon be kept up in that
time unit, n' all operations is ghon be done up in dat time unit.  The
convert method can be used ta chizzle tha time unit ta tha local time
zone, or ta another time unit.
.Sp
Some thangs ta note:
.Sp
All strings is case insensitive.  \*(L"December\*(R" n' \*(L"DEceMBer\*(R" are
equivalent.
.Sp
When a part of tha date aint given, defaults is used. Y'all KNOW dat shit, muthafucka! This is
busted lyrics bout below up in tha section \*(L"Complete vs. truncated dates n' times\*(R".
.Sp
Da year may be entered as 2 or 4 digits, n' you can put dat on yo' toast.  If entered as 2 digits, it will
be converted ta a 4 digit year. Shiiit, dis aint no joke.  There is nuff muthafuckin ways ta do dis based on
the value of tha YYtoYYYY config variable.  Refer ta tha Date::Manip::Config
documentation fo' mo' details.
.Sp
Dates is always checked ta make shizzle they is valid.
.Sp
If any other arguments is passed in, they act as options which may
improve tha speed of parsing. These include:
.Sp
.Vb 10
\&   noiso8601  Do not try ta parse the
\&              date as a ISO 8601 date
\&              or time.
\&   nodow      Do not try ta parse a
\&              day\-of\-week (Monday) in
\&              tha string.
\&   nocommon   Do not try ta parse the
\&              date rockin tha formats
\&              up in tha "Common date
\&              formats" section.
\&   noother    Do not try ta parse the
\&              date rockin tha "Less common
\&              date formats" or a time
\&              rockin tha "Other time
\&              formats".
\&   nospecial  Do not try ta parse the
\&              date rockin tha "Special
\&              date strings" formats
\&              or a time rockin the
\&              "Special time strings"
\&              formats, or as a
\&              combined date/time using
\&              tha "Additionizzle combined
\&              date n' time" formats.
\&   nodelta    Do not treat deltas as
\&              a thugged-out date relatizzle ta now, nahmeean?
\&   noholidays Do not parse holiday
\&              names as dates.
.Ve
.IP "\fBparse_date\fR" 4
.IX Item "parse_date"
.Vb 1
\&   $err = $date\->parse_date($strin [,@opts]);
.Ve
.Sp
This parses a strang which gotz nuff a valid date n' sets tha date
part of tha object.
.Sp
If tha object contained a valid date, tha time is kept unchanged. Y'all KNOW dat shit, muthafucka! If the
object did \s-1NOT\s0 contain a valid date, a time of 00:00:00 is used.
.Sp
\&\f(CW@opts\fR can be any of tha strings busted lyrics bout up in tha parse method above.
.IP "\fBparse_time\fR" 4
.IX Item "parse_time"
.Vb 1
\&   $err = $date\->parse_time($strin [,@opts]);
.Ve
.Sp
This parses a strang n' sets tha time portion of \f(CW$date\fR ta contain dat shit.
.Sp
If tha object contained a valid date, tha Y/M/D portion is left unchanged.
Otherwise, tha current date is used.
.Sp
\&\f(CW@opts\fR can be 'noiso8601' or 'noother'.
.IP "\fBparse_format\fR" 4
.IX Item "parse_format"
.Vb 2
\&   $err          = $date\->parse_format($format,$string);
\&   ($err,%match) = $date\->parse_format($format,$string);
.Ve
.Sp
This will parse a thugged-out date contained up in \f(CW$string\fR based on explicit format
information contained up in \f(CW$format\fR.
.Sp
If tha format is invalid, \f(CW$err\fR will contain a error message.
If tha format is valid yo, but strang don't match, a error code
of 1 is returned.
.Sp
If called up in array context, a hash is ghon be returned containin %+.
This is primarily useful if tha \f(CW$format\fR strang gotz nuff some
named capture crews dat you define.  This is discussed below.
.Sp
\&\f(CW$format\fR be a strang containin a regular expression wit some special
directives (based on tha printf directives). These directives is turned
into regular expression components, n' then tha entire strang is turned
into a regular expression which, if \f(CW$string\fR matches it, will return the
date.
.Sp
Da directives available is identical ta tha printf directives. Right back up in yo muthafuckin ass. So,
if yo' \f(CW$format\fR strang gotz nuff tha directizzle '%Y', it will match a
4\-digit year.
.Sp
All of tha printf directives is available here wit all dem caveats:
.Sp
.Vb 1
\&   %l        This directizzle is NOT available.
\&
\&   %b,%h,%B  These will all match a month name or abbreviation.
\&
\&   %v,%a,%A  These will all match a thugged-out dizzle name or abbreviation.
\&
\&   %z,%Z,%N  These will match any time unit string.
\&
\&   %n        Multi\-line matchin aint currently supported,
\&             so dis directizzle aint allowed.
\&
\&   %x        All format directives is converted ta a regular
\&             expression n' then cached (so dat a gangbangin' format
\&             can be reused without tha penalty of bustin the
\&             conversion ta a regular expression wit each use).
\&             As a result, if you need ta set tha DateFormat config
\&             variable (which determines tha meanin of tha %x
\&             directive), it must be done before a gangbangin' format string
\&             containin %x is used. Y'all KNOW dat shit, muthafucka! If tha DateFormat config variable
\&             is set afterwards, tha format strang will reflect the
\&             old, NOT THE NEW, value of DateFormat.
.Ve
.Sp
Da format strang may not over-specify tha date. In other lyrics, you
may not include both a \f(CW%y\fR n' \f(CW%Y\fR directizzle or both a \f(CW%j\fR n' \f(CW%m\fR directive.
.Sp
A valid format strang will specify any of tha followin setz of data:
.Sp
.Vb 1
\&   Required          Optional
\&
\&   M D H Mn S        Y Zone Day\-of\-week
\&   M D H Mn          Y Zone Day\-of\-week
\&   M D               Y Zone Day\-of\-week
\&   H Mn S            Zone
\&   H Mn              Zone
.Ve
.Sp
For example, if you had a thugged-out date stored as:
.Sp
.Vb 1
\&   YYYY.MM\-DD
.Ve
.Sp
you could match it rockin tha following:
.Sp
.Vb 1
\&   $date\->parse_format(\*(Aq%Y\e\e.%m\e\e\-%d\*(Aq,$string);
.Ve
.Sp
If you wanted ta extract tha date from a apache log line:
.Sp
.Vb 1
\&   10.11.12.13 \- \- [17/Aug/2009:12:33:30 \-0400] "GET /favicon.ico ...
.Ve
.Sp
you could use:
.Sp
.Vb 1
\&   $date\->parse_format(\*(Aq.*?\e\e[%d/%b/%Y:%T %z\e\e].*\*(Aq,$line);
.Ve
.Sp
When matchin months, days, n' hours, there be two directives
that could be used (for numerical versions).  For tha month, you
may use \f(CW%m\fR or \f(CW%f\fR.  If yo' date is known ta git a two-digit month,
you should use \f(CW%m\fR.  If it gotz nuff a one\- or two-digit month, you must
use \f(CW%f\fR (and it is safe ta use \f(CW%f\fR fo' two-digit months).  Similarly,
for days, you can use \f(CW%d\fR or \f(CW%e\fR n' fo' minutes you can use \f(CW%H\fR or \f(CW%k\fR.  In
both cases, tha straight-up original gangsta can only be used if yo ass is guaranteed a 2\-digit
value.
.Sp
In yo' format string, you may use capture crews (or back references
to them) up in tha regular expression rockin all of tha rulez of normal
regular expressions. Right back up in yo muthafuckin ass. Since Date::Manip uses named capture groups
internally, it is suggested dat you also use named groups.  Mixing
numbered n' named crews will work... but it'll be entirely up ta you
to keep track of what tha fuck numbers refer ta which capture groups.
.Sp
Every printf directizzle addz one or mo' named capture crews ta the
regular expression. I aint talkin' bout chicken n' gravy biatch.  If you use named crews up in tha format string,
they must not conflict wit tha ones used internally, or else the
date will probably not be parsed erectly.
.Sp
Da followin named capture crews is used internally:
.Sp
.Vb 10
\&   y
\&   m
\&   d
\&   h
\&   mn
\&   s
\&   mon_name
\&   mon_abb
\&   dow_name
\&   dow_abb
\&   dow_char
\&   dow_num
\&   doy
\&   nth
\&   ampm
\&   epochs
\&   epocho
\&   tzstring
\&   off
\&   abb
\&   unit
\&   g
\&   w
\&   l
\&   u
.Ve
.Sp
To be safe, it is suggested dat any additionizzle named capture groups
introduced by tha programmer start wit a cold-ass lil capital letter n' shit.  This is
guaranteed ta never conflict wit any existing, or future named capture
groups.
.Sp
In order ta git access ta tha joints stored up in tha additionizzle named
capture groups, tha parse_format function must be called up in list
context, n' tha %+ array is ghon be returned as tha second value.
.Sp
As a example:
.Sp
.Vb 2
\&   $strin = "before 2014\-01\-25 after";
\&   ($err,%m) = $date\->parse_format(\*(Aq(?<PRE>.*?)%Y\-%m\-%d(?<POST>.*)\*(Aq,$string);
.Ve
.Sp
would return a hash (%m) wit tha followin key/value pairs:
.Sp
.Vb 2
\&   \*(AqPRE\*(Aq  => \*(Aqbefore \*(Aq
\&   \*(AqPOST\*(Aq => \*(Aq after\*(Aq
.Ve
.IP "\fBprev\fR" 4
.IX Item "prev"
.PD 0
.IP "\fBnext\fR" 4
.IX Item "next"
.PD
Da prev method chizzlez tha date ta tha previous (or current)
occurrence of either a thugged-out dizzle of tha week, a cold-ass lil certain time of day, or
both. Da next method chizzlez tha date ta tha next (or current)
occurrence. Da examplez below illustrate tha prev method yo, but
the next one is identical up in operation.
.Sp
There is two different ways ta use dis method. Y'all KNOW dat shit, muthafucka! Da first is ta pass
in a thugged-out dizzle of week n' possibly a time:
.Sp
.Vb 1
\&   $err = $date\->prev($dow, $curr [,$time]);
.Ve
.Sp
If \f(CW$curr\fR = 0, dis means ta look fo' tha previous occurence of tha day
of week, n' set tha time ta tha value passed up in (or current time if
no time was passed in). Da dizzle is \s-1ALWAY\s0 less than tha current day. It make me wanna hollar playa! If
the current dizzle is tha same ol' dirty dizzle of week as \f(CW$dow\fR, then tha date
returned is ghon be one week earlier.
.Sp
If \f(CW$curr\fR = 1, it means ta look fo' tha current or previous occurence
of tha dizzle of week, n' set tha time ta tha value passed up in (or 00:00:00 if
none was passed in). If tha current dizzle of week is tha same ol' dirty as \f(CW$dow\fR, the
date will remain unchanged. Y'all KNOW dat shit, muthafucka! Since tha time is then set, tha freshly smoked up date may
actually occur afta tha original gangsta date dependin on tha value of \f(CW$time\fR.
.Sp
If \f(CW$curr\fR = 2, it means ta look fo' tha last time (not countin now)
that tha dizzle of week all up in tha given time occurred. Y'all KNOW dat shit, muthafucka! Da date may be the
same as tha original gangsta date.
.Sp
\&\f(CW$time\fR may be a list reference of [H,MN,S], [H,MN], or [H].
.Sp
Da followin examplez should illustrate tha use of dis function.
.Sp
.Vb 1
\&    Original Gangsta Date = Fri Nov 22 18:15:00
\&
\&    dow      curr   time       freshly smoked up date
\&
\&    4 (Thu)  0/1/2  undef      Thu Nov 21 00:00:00
\&    4        0/1/2  [12,30,0]  Thu Nov 21 12:30:00
\&
\&    5 (Fri)  0/2    undef      Fri Nov 15 18:15:00
\&    5        1      undef      Fri Nov 22 18:15:00
\&
\&    5        0      [12,30,0]  Fri Nov 15 12:30:00
\&    5        1/2    [12,30,0]  Fri Nov 22 12:30:00
\&
\&    5        0/2    [19,30,0]  Fri Nov 15 19:30:00
\&    5        1      [19,30,0]  Fri Nov 22 19:30:00
.Ve
.Sp
Da second way ta use dis method is by passin up in undef fo' tha dizzle of
week.
.Sp
.Vb 1
\&   $err = $date\->prev(undef,$curr,$time);
.Ve
.Sp
In dis case, a time is required n' it must be a list reference
of 3 elements: [H, \s-1MN, S\s0] fo' realz. Any or all of tha elements may be undef.
.Sp
Da freshly smoked up date is tha previous occurrence of tha time.
.Sp
If you define hours, then minutes n' secondz may be defined, or
default ta 0 n' yo ass is lookin fo' a previous time dat the
specified time (\s-1HH:00:00\s0) occurred (which might be as much as 24 hours
in tha past).
.Sp
If minutes is undefined n' minutes is defined, then secondz may be
defined, or default ta 0, n' yo ass is lookin fo' tha last time the
minutes/secondz (\s-1MN:SS\s0) rocked up on tha digital clock, which will be
sometime up in tha past hour.
.Sp
Finally, if minutes n' minutes is undefined, secondz must be defined
(or default ta zero) n' tha last time dat that second occurred will
be returned (which is ghon be sometime up in tha past minute).
.Sp
If \f(CW$curr\fR is non-zero, tha current time is returned if it matches the
criteria passed in, so tha returned value is ghon be now or up in tha past.
If \f(CW$curr\fR is zero, tha time returned will definitely be up in tha past.
.Sp
.Vb 1
\&    DATE = Fri Nov 22 18:15:00
\&
\&    curr  hr     min    sec      returns
\&    0/1   18     undef  undef    Nov 22 18:00:00
\&    0/1   18     30     0        Nov 21 18:30:00
\&    0     18     15     undef    Nov 21 18:15:00
\&    1     18     15     undef    Nov 22 18:15:00
\&    0     undef  15     undef    Nov 22 17:15:00
\&    1     undef  15     undef    Nov 22 18:15:00
.Ve
.IP "\fBprintf\fR" 4
.IX Item "printf"
.Vb 2
\&   $out = $date\->printf($in);
\&   @out = $date\->printf(@in);
.Ve
.Sp
This takes a strang or list of strings which may contain any number of
special formattin directives. These directives is replaced with
information contained up in tha date. Everythang else up in tha strang is
returned unmodified.
.Sp
A directizzle always begins wit '%'. They is busted lyrics bout up in tha section
below up in tha section \s-1PRINTF DIRECTIVES.\s0
.IP "\fBsecs_since_1970_GMT\fR" 4
.IX Item "secs_since_1970_GMT"
.Vb 1
\&   $secs = $date\->secs_since_1970_GMT();
.Ve
.Sp
This returns tha number of secondz dat have elapsed since Jan 1, 1970
00:00:00 \s-1GMT \s0(negatizzle if tha date is earlier).
.Sp
Da reverse be also allowed:
.Sp
.Vb 1
\&   $err = $date\->secs_sincs_1970_GMT($secs);
.Ve
.Sp
which sets tha date ta \f(CW$secs\fR secondz from Jan 1, 1970 00:00:00 \s-1GMT\s0 in
the local time unit.
.IP "\fBset\fR" 4
.IX Item "set"
.Vb 1
\&   $err = $date\->set($field,@vals [,$isdst]);
.Ve
.Sp
This explicitly sets one or mo' fieldz up in a thugged-out date.
.Sp
\&\f(CW$field\fR can be any of tha following:
.Sp
.Vb 1
\&   $field   @vals
\&
\&   unit     [ZONE]         ZONE can be any unit or alias
\&
\&   zdate    [ZONE,]DATE    sets tha unit n' entire date
\&
\&   date     DATE           sets tha entire date
\&
\&   time     TIME           sets tha entire time
\&
\&   y        YEAR           sets one field
\&   m        MONTH
\&   d        DAY
\&   h        HOUR
\&   mn       MINUTE
\&   s        SECOND
.Ve
.Sp
Here, \s-1DATE\s0 be a list reference containin [Y,M,D,H,MN,S] n' \s-1TIME\s0 is
a list reference containin [H,MN,S].
.Sp
\&\s-1ZONE\s0 is optionizzle (it defaults ta tha local unit as defined either by
the system clock, or tha SetDate or ForceDate config variables). If it
is passed in, it can be any unit name, abbreviation, or offset fo' realz. An
offset can be expressed either as a valid offset string, or as a list
reference.  Refer ta tha join/split functionz of Date::Manip::Base for
information on valid offset strings.
.Sp
An optionizzle last argument is \f(CW$isdst\fR (which must be 0 or 1) is included
when settin a thugged-out date which could be up in either standard time or daylight
savin time. Well shiiiit, it is ignored up in all other thangs. If it is
not included, n' tha resultin date could be up in either, it will
default ta standard time.
.Sp
Da \f(CW$date\fR object must contain a valid date (unless tha entire date
is bein set wit \f(CW$field\fR set ta either \*(L"zdate\*(R" or \*(L"date\*(R").
.Sp
If \f(CW$field\fR is \*(L"zone\*(R", tha time unit of tha date is ghon be set. If \s-1ZONE\s0 is
not passed in, it is ghon be set ta tha local time unit.  When settin the
time unit, no conversion is done biaaatch! Whatever date n' time is stored in
the \f(CW$date\fR object prior ta dis remains unchanged... except it will
be dat date n' time up in tha freshly smoked up time unit.
.Sp
If \f(CW$field\fR is \*(L"zdate\*(R", tha entire date n' time unit is set. If \s-1ZONE\s0 is
not passed in, it is set ta tha local time unit.
.Sp
If \f(CW$field\fR is \*(L"date\*(R", tha entire date is ghon be set yo, but tha time unit
of tha date aint gonna be chizzled.
.Sp
If \f(CW$field\fR is \*(L"time\*(R", or one of tha individual fields, only them
fieldz is ghon be modified.
.Sp
An error is returned if a invalid argument list is passed in, or if
the resultin date is checked n' found ta be invalid.
.IP "\fBvalue\fR" 4
.IX Item "value"
.Vb 2
\&   $val = $date\->value([$type]);
\&   @val = $date\->value([$type]);
.Ve
.Sp
These return tha value of tha date stored up in tha object.
.Sp
In scalar context, a printable strang up in tha form \s-1YYYYMMDDHH:MN:SS\s0
is returned. Y'all KNOW dat shit, muthafucka! In list context, a list is returned of (Y,M,D,H,MN,S).
.Sp
If \f(CW$type\fR is omitted, tha date is returned up in tha time unit it was
parsed in.
.Sp
If \f(CW$type\fR is \*(L"local\*(R", it is returned up in tha local time unit (which
is either tha system time unit, or tha unit specified wit the
SetDate or ForceDate config variables).
.Sp
If \f(CW$type\fR is \*(L"gmt\*(R", tha date is returned up in tha \s-1GMT\s0 time unit.
.Sp
An empty strang or list is returned i tha case of a error (and
an error code is set).
.IP "\fBweek_of_year\fR" 4
.IX Item "week_of_year"
.Vb 1
\&   $wkno = $date\->week_of_year([$first]);
.Ve
.Sp
This figures up tha week number n' shit. If \f(CW$first\fR is passed in, it must be
between 1 n' 7 n' refers ta tha straight-up original gangsta dizzle of tha week. If \f(CW$first\fR is
not passed in, tha FirstDizzle config variable is used.
.Sp
\&\s-1NOTE:\s0 This routine should only be called up in rare cases.  Use printf with
the \f(CW%W\fR, \f(CW%U\fR, \f(CW%J\fR, \f(CW%L\fR formats instead. Y'all KNOW dat shit, muthafucka!  This routine returns a week between 0
and 53 which must then be \*(L"fixed\*(R" ta git tha fuck into tha \s-1ISO 8601\s0 weeks from 1 to
53.  A date which returns a week of 0 straight-up belongs ta tha last week of
the previous year. Shiiit, dis aint no joke.  A date which returns a week of 53 may belong ta the
first week of tha next year.
.SH "ISSUES WITH PARSING DATES"
.IX Header "ISSUES WITH PARSING DATES"
Da followin thangs may occur when parsin dates dat should be
understood ta make full use of dis module.
.IP "\fBComplete vs. truncated dates n' times\fR" 4
.IX Item "Complete vs. truncated dates n' times"
Date formats is either complete or truncated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. A complete date fully
specifies tha year, month, n' dizzle n' a cold-ass lil complete time straight-up specifies
the hour, minute, n' second.
.Sp
It should be understood dat up in nuff instances, tha shiznit may be
implied rather than explicitly stated yo, but it is still treated as
complete.
.Sp
For example, tha date \*(L"January 3\*(R" is complete cuz it implies the
current year.
.Sp
A truncated calendar date or time do not include shiznit about
some of tha fields. Date::Manip aint NEVER gonna work wit a partial date or
time, so defaults is ghon be supplied.
.Sp
For example, tha date \*(L"2009\-01\*(R" is missin a thugged-out dizzle field, so a thugged-out default
will be used. Y'all KNOW dat shit, muthafucka! In dis case, tha dizzle is ghon be tha 1st, so dis is
equivalent ta \*(L"Jan 1st 2009\*(R". If only tha year is given, it will
default ta Jan 1.
.Sp
If tha time, or any of itz components is missing, they default to
00. Right back up in yo muthafuckin ass. So tha time \*(L"12:30\*(R" n' \*(L"12:30:00\*(R" is equivalent.
.Sp
Da \*(L"complete\*(R" method can be used ta check what tha fuck type of date was
parsed, n' which joints was specified (either explicitly or implied)
and which was provided as a thugged-out default. Well shiiiit, it should be noted dat there
is no way ta differentiate between a explicit n' implied value.
.Sp
A strang wit a thugged-out date and/or time may consist of any of tha following:
.Sp
.Vb 3
\&   a cold-ass lil complete date n' a time (complete or truncated)
\&   a truncated date wit no time
\&   a time (complete or truncated) wit no date
.Ve
.Sp
In other lyrics, tha date \*(L"Jan 2009 12:30\*(R" aint valid since it consists
of a time wit a truncated date.
.SH "VALID TIME ZONE FORMATS"
.IX Header "VALID TIME ZONE FORMATS"
When specifyin a time unit, it can be done up in three different ways.
One way is ta specify tha actual time unit. Da second is ta supply
a valid time unit abbreviation. I aint talkin' bout chicken n' gravy biatch. Da third is ta specify a offset (with
an optionizzle abbreviation). Da followin dates illustrate tha these
formats.
.PP
Da timezone shiznit always bigs up tha time immediately, n' may
only be included if a time is included. Y'all KNOW dat shit, muthafucka! Da followin examplez use
an \s-1ISO 8601\s0 format fo' tha date/time yo, but any of tha other date and
time formats may be used.
.PP
Da first way ta specify tha time unit is ta specify it by complete name
(or rockin one of tha standard aliases):
.PP
.Vb 1
\&   2001\-07\-01\-00:00:00 America/New_York
.Ve
.PP
Although dis is unambiguous when it comes ta determinin tha time unit,
the time be ambiguous up in most units fo' one minute of tha year. Shiiit, dis aint no joke. When
a time chizzle occurs durin which tha clock is moved back, tha same
wallclock time occurs twice.
.PP
For example, up in America/New_York, on Sunday, Nov 2, 2008, at 02:00 in
the morning, tha clock was set back ta 01:00 fo' realz. As a result, tha date
Nov 2, 2008 at 01:30 be ambiguous. Well shiiiit, it is impossible ta determine if
this refers ta tha 01:30 dat occurred half a minute before tha time
change, or tha one 30 minute afta tha chizzle.
.PP
In practice, if dis form is used, tha date is ghon be assigned to
standard time, meanin dat there is ghon be some times (typically 1 hour
per year) which cannot be expressed dis way fo' realz. As such, dis method is
discouraged.
.PP
Da second way ta specify tha time unit, which is da most thugged-out common, is
to bust a time unit abbreviation:
.PP
.Vb 1
\&   2001\-07\-01\-00:00:00 EDT
.Ve
.PP
Unfortunately, tha abbreviation do not uniquely determine the
time unit except up in all dem cases. In order ta assign a time unit,
Date::Manip will refer ta a list of all time units which use the
abbreviation. I aint talkin' bout chicken n' gravy biatch.  They is ghon be tested, up in tha order given up in the
Date::Manip::Zones documentation, n' tha straight-up original gangsta match (i.e. tha one in
which tha given date/time n' abbreviation is valid) determines the
time unit which is ghon be used. Y'all KNOW dat shit, muthafucka! A pimped out deal of effort has been made to
ensure dat da most thugged-out likely time unit is ghon be obtained (i.e. da most thugged-out
common time units is tested before less common ones), so up in most
cases, tha desired thangs up in dis biatch is ghon be obtained.
.PP
If tha default order do not yield tha desired time unit, tha order of
testin can be modified rockin tha abbrev method busted lyrics bout up in the
Date::Manip::TZ documentation.
.PP
Although tha time unit be ambiguous, tha date is not, since only
time units fo' which tha date is valid is ghon be used.
.PP
Da third way ta specify tha time unit is by specifyin a offset and
an optionizzle abbreviation:
.PP
.Vb 5
\&   2001\-07\-01\-00:00:00 \-04
\&   2001\-07\-01\-00:00:00 \-0400
\&   2001\-07\-01\-00:00:00 \-040000
\&   2001\-07\-01\-00:00:00 \-04:00
\&   2001\-07\-01\-00:00:00 \-04:00:00
\&
\&   2001\-07\-01\-00:00:00 \-04 (EDT)
\&   2001\-07\-01\-00:00:00 \-0400 (EDT)
\&   2001\-07\-01\-00:00:00 \-040000 (EDT)
\&   2001\-07\-01\-00:00:00 \-04:00 (EDT)
\&   2001\-07\-01\-00:00:00 \-04:00:00 (EDT)
\&
\&   2001\-07\-01\-00:00:00 \-04 EDT
\&   2001\-07\-01\-00:00:00 \-0400 EDT
\&   2001\-07\-01\-00:00:00 \-040000 EDT
\&   2001\-07\-01\-00:00:00 \-04:00 EDT
\&   2001\-07\-01\-00:00:00 \-04:00:00 EDT
.Ve
.PP
Da offset almost never sufficient ta uniquely determine tha time unit
(and it aint even guaranteed dat both tha offset n' abbreviation
will, though up in practice, it is probably sufficient). In this
instance, tha time unit is ghon be determined by testin all time units
which have tha given offset (and abbreviation if it is included) until
one is found which matches both piecez of shiznit. I aint talkin' bout chicken n' gravy biatch. For more
information bout how tha fuck dis testin is done, refer ta tha def_zone
method of tha Date::Manip::TZ documentation.
.SH "VALID DATE FORMATS"
.IX Header "VALID DATE FORMATS"
There is nuff muthafuckin categoriez of date formats supported by Date::Manip.
These is strings which specify only tha year/month/dizzle fields.
.PP
These formats explicitly set tha date yo, but not tha time. These formats
may be combined wit a time strang (as specified below) ta set both
the date n' time. If dis aint done, tha default time is determined
by tha DefaultTime config variable.
.IP "\fB\s-1ISO 8601\s0 dates\fR" 4
.IX Item "ISO 8601 dates"
Da preferred date formats is dem specified by \s-1ISO 8601.\s0 The
specification includes valid calendar date n' valid time formats.
Date::Manip will handle all of these formats yo, but do not require
that tha dates rigidly adhere ta tha justification since tha ultimate
goal of Date::Manip is ta handle dates as they is represented in
real game n' some common variations exist which is similar ta yo, but
not identical to, dem from tha justification.
.Sp
A calendar date includes tha followin fields:
.Sp
.Vb 10
\&   CC    2\-digit representation of tha century
\&   YY    2\-digit representation of tha year in
\&         a cold-ass lil century
\&   MM    2\-digit representation of a month
\&   DD    2\-ditit representation of a thugged-out dizzle of month
\&   DoY   3\-digit representation of a thugged-out dizzle of year
\&         (001\-366)
\&   Www   tha characta "W" followed by a 2\-digit
\&         week of tha year (01\-53)
\&   D     tha dizzle of tha week (1\-7)
.Ve
.Sp
Da followin date formats is considered complete by Date::Manip. In
the following, tha date Thu Mar 5 2009 is used as a example.  This is
the 64th dizzle of tha year. Shiiit, dis aint no joke. Thu is tha 4th dizzle of tha week.  Da week
startin Mon, Mar 2 is tha 10th week of tha year (accordin tha the
\&\s-1ISO 8601\s0 definition). Obviously, a shitload of tha formats is only valid
when used at some times. For example, tha format \-\-MMDD refers ta a
month n' dizzle up in tha current year, so tha date Mar 5, 2009 can only be
specified rockin dis format durin 2009.
.Sp
.Vb 1
\&   Format      Notes   Examples
\&
\&   CCYYMMDD            20090305
\&   CCYY\-MM\-DD          2009\-03\-05
\&
\&   YYMMDD      1,2,4   090305
\&   YY\-MM\-DD            09\-03\-05
\&
\&   \-YYMMDD     3,4     \-090305
\&   \-YY\-MM\-DD           \-09\-03\-05
\&
\&   \-\-MMDD      1       \-\-0305
\&   \-\-MM\-DD             \-\-03\-05
\&
\&   \-\-\-DD       1       \-\-\-05
\&
\&
\&   CCYYDoY             2009064
\&   CCYY\-DoY            2009\-064
\&
\&   YYDoY       1,4     09064
\&   YY\-DoY              09\-064
\&
\&   \-YYDoY      3,4     \-09064
\&   \-YY\-DoY             \-09\-064
\&
\&   \-DoY        1       \-064
\&
\&
\&   CCYYWwwD            2009W104
\&   CCYY\-Www\-D          2009\-W10\-4
\&
\&   YYWwwD      1,4     09W104
\&   YY\-Www\-D            09\-W10\-4
\&
\&   \-YYWwwD     3,4     \-09W104
\&   \-YY\-Www\-D           \-09\-W10\-4
\&
\&   \-YWwwD      1       \-9W104
\&   \-Y\-Www\-D            \-9\-W10\-4
\&                       Y is tha year (0\-9) in
\&                       current decade
\&
\&   \-WwwD       1       \-W104
\&   \-Www\-D              \-W10\-4
\&
\&   \-W\-D        1       \-W\-4
\&                       D is dizzle (1\-7) in
\&                       current week
\&
\&   \-\-\-D        1       \-\-\-4
\&                       same as \-W\-D
.Ve
.Sp
Da followin date formats is truncated:
.Sp
.Vb 1
\&   CCYY\-MM     2       2009\-03   (2009\-03\-01)
\&
\&   CCYY                2009      (2009\-01\-01)
\&
\&   CC          2       20        (2000\-01\-01)
\&
\&   \-YYMM       4       \-0903
\&   \-YY\-MM              \-09\-03
\&
\&   \-YY         4       \-09
\&
\&   \-\-MM                \-\-03
\&
\&   CCYYWww             2009W10
\&   CCYY\-Www            2009\-W10
\&
\&   YYWww       4       09W10
\&   YY\-Www              09\-W10
\&
\&   \-YYWww      3,4     \-09W10
\&   \-YY\-Www             \-09\-W10
\&
\&   \-Www                \-W10
.Ve
.Sp
Notes:
.Sp
1  These formats is considered truncated up in tha standard yo, but since
   they do include (or imply, rockin tha current date fo' defaults)
   all of tha fields, n' since they do not introduce any parsing
   complexities, tha standard is chillaxed, n' they is treated as
   complete.
.Sp
2  These formats is treated differently than up in Date::Manip 5.xx as
   busted lyrics bout below.
.Sp
3  These formats is not defined up in tha \s-1ISO 8601\s0 spec yo, but
   is added fo' tha sake of completenizz since they do not
   add any parsin incompatibilities.
.Sp
4  Formats where tha century aint given is busted lyrics bout as a year in
   tha current century up in tha justification. I aint talkin' bout chicken n' gravy biatch. Date::Manip treats this
   mo' generically rockin tha YYtoYYYY config variable. This will be
   used ta determine how tha fuck ta determine tha full year.
.Sp
Date::Manip 5.xx handled \s-1ISO 8601\s0 dates up in a less rigid fashion, and
deviated from tha justification up in nuff muthafuckin formats fo' realz. Az of 6.00, the
specification is followed much mo' closely so dat all of tha date
formats included up in it should produce valid dates.  This chizzles, up in a
backwardz incompatible way, tha way all dem strings is ghon be interpreted
as dates.
.Sp
Az of 6.00, a two-digit date is ghon be treated as \s-1CC.\s0 Previously, it
was treated as \s-1YY.\s0
.Sp
A six-digit date is ghon be treated as \s-1YYMMDD.\s0 Previously, dat shiznit was treated
as \s-1YYYYMM.\s0
.Sp
Previously, dashes was treated as optionizzle up in nuff cases fo' realz. According
to tha justification, dates may be freestyled up in expanded form (with all
dashes present) or abbreviate form (with no dashes) fo' realz. Az of 6.00, this
is tha behavior, so tha formats: \s-1YYMMDD\s0 n' YY-MM-DD is allowed, as
per tha justification yo, but tha format YY-MMDD is \s-1NOT\s0 allowed (though
it was previously).
.Sp
Da Www-D formats require a lil' bit of explanation. I aint talkin' bout chicken n' gravy biatch.  Accordin ta the
specification, tha date:
.Sp
.Vb 1
\&   1996\-w02\-3
.Ve
.Sp
refers ta tha dizzle wit a ordinal number of 3 within tha calendar week
in tha 2nd week of 1996.
.Sp
In tha justification, tha minutez of tha week is numbered from 1 ta 7
(Mondizzle ta Sunday), n' tha week always begins on Monday, so dizzle 1
(Monday) be always tha straight-up original gangsta dizzle of tha week, dizzle 2 (Tuesday) is
always tha second dizzle of tha week, etc.
.Sp
In Date::Manip, tha constraint dat tha week must start wit Mondizzle is
relaxed, allowin tha week ta begin wit Sundizzle (a far mo' common
start of tha week up in calendars, at least up in some partz of tha ghetto).
.Sp
This presents a problem though up in dat tha above date could be
interpreted as Wednesdizzle (dizzle 3) of tha 2nd week of 1996, or as the
3rd dizzle of tha 2nd week of 1996 (which would normally be Wednesday,
but would be Tuesdizzle if tha week begins on Sunday).
.Sp
Az of Date::Manip 6.00, tha above date is ghon be interpreted as tha 3rd
dizzle of tha 2nd week. This be a reversal from Date::Manip 5.xx yo, but I
believe is what tha fuck tha justification would require. For mo' shiznit,
refer ta tha Date::Manip::Changes document.
.IP "\fBCommon date formats\fR" 4
.IX Item "Common date formats"
Date::Manip supports a fuckin shitload of common date formats, n' you can put dat on yo' toast. Da followin fields
may be included up in a thugged-out date:
.Sp
.Vb 7
\&  YY    2\-digit representation of tha year
\&  YYYY  4\-digit representation of tha year
\&  M     1\- or 2\- digit representation of tha month
\&  MM    2\-digit representation of tha month
\&  D     1\- or 2\- digit representation of tha day
\&  DD    2\-digit representation of tha day
\&  mmm   Da abbreviated or full month name (i.e. Jan)
.Ve
.Sp
Da followin date formats is supported:
.Sp
.Vb 1
\&   Format      Notes   Examples
\&
\&   M/D         1,2,3   3/5
\&   M/D/YY      1       3/5/09
\&   M/D/YYYY    1       3/5/2009
\&
\&   YYYY/M/D            2009/3/5
\&
\&   mmm/D               Mar/5
\&   mmm/D/YY            Mar/5/09
\&   mmm/D/YYYY          Mar/5/2009
\&   D/mmm               5/Mar
\&   D/mmm/YY            5/Mar/09
\&   D/mmm/YYYY          5/Mar/2009
\&   YYYY/mmm/D          2009/Mar/5
\&
\&   mmmD                Mar5
\&   mmmDDYY             Mar0509
\&   mmmDDYYYY           Mar052009
\&   Dmmm                5Mar
\&   DmmmYY              5Mar09
\&   DmmmYYYY            5Mar2009
\&   YYYYmmmD            2009Mar5
\&
\&   mmmD YY             Mar5 09
\&   mmmD YYYY           Mar5 2009
\&   Dmmm YY             5Mar 09
\&   Dmmm YYYY           5Mar 2009
\&
\&   mmm/D YY            Mar/5 09
\&   mmm/D YYYY          Mar/5 2009
\&   D/mmm YY            5/Mar 09
\&   D/mmm YYYY          5/Mar 2009
\&
\&   YY   mmmD           09   Mar5
\&   YYYY mmmD           2009 Mar5
\&   YY   Dmmm           09   5Mar
\&   YYYY Dmmm           2009 5Mar
\&
\&   YY   mmm/D          09   Mar/5
\&   YYYY mmm/D          2009 Mar/5
\&   YY   D/mmm          09   5/Mar
\&   YYYY D/mmm          2009 5/Mar
\&
\&   YYYY:MM:DD          2010:01:15 (EXIF format)
.Ve
.Sp
In tha formats above, tha slash (/) can be replace by any of tha valid
separators: whitespace, slash (/), period (.), or dash (\-). Da dash,
though allowed, is discouraged since it may conflict wit a \s-1ISO 8601\s0
format.  For example, tha format \s-1MM/DD/YY\s0 is just fine yo, but MM-DD-YY
does not work since it conflicts wit YY-MM-DD.  To be safe, if \*(L"\-\*(R" is
used as a separator up in a non-ISO format, they should be turned into
\&\*(L"/\*(R" before callin tha Date::Manip routines.
.Sp
No matta what tha fuck separator is used, tha same separator must be used
all up in tha date. For example, \s-1MM/DD/YY\s0 is valid n' \s-1MM.DD.YY\s0 is
also valid yo, but \s-1MM/DD.YY\s0 is \s-1NOT\s0 valid.
.Sp
Notes:
.Sp
1  With these formats, Gangstas tend ta write month first yo, but many
   other ghettos tend ta write dizzle first.  Da latta behavior can be
   obtained by settin tha config variable DateFormat ta suttin' other
   than \*(L"\s-1US\*(R".\s0
.Sp
2  Da dot (.) separator may not be used up in tha M/D format since it
   is ghon be interpreted as tha H12,H+ format busted lyrics bout below.
.Sp
3  Da M/D format should not use tha period (.) separator as dat will
   incorrectly match tha \s-1HH,H+\s0 time format.
.Sp
These formats explicitly set tha date yo, but not tha time. Da default
time is determined by tha DefaultTime config variable.
.IP "\fBLess common date formats\fR" 4
.IX Item "Less common date formats"
Da followin formats is also supported by Date::Manip:
.Sp
.Vb 4
\&   DoW
\&        Da dizzle of week of tha current week
\&           Friday
\&           Fridizzle at 12:40
\&
\&   MMM Nth [YYYY]
\&   Nth MMM [YYYY]
\&   YYYY MMM Nth
\&   YYYY Nth MMM
\&        Dec 1st 1970
\&        1st Dec 1970
\&        1970 Dec 1st
\&        1970 1st Dec
\&
\&   next/prev DoW
\&        Da next or last occurence of DoW
\&           next Friday
\&           last Fridizzle at 12:40
\&
\&   next/last week/month/year
\&        Da dizzle one week/month/year from now
\&        or up in tha past
\&           next week
\&           last month at 15:00
\&
\&   last dizzle up in MMM [YYYY]
\&        Da last dizzle of tha month
\&           last dizzle up in October
\&           last dizzle up in October 1996
\&
\&   last DoW up in MMM [YYYY]
\&        Da last DoW up in tha month
\&           last Tuesdizzle up in October
\&           last Tuesdizzle up in October 1996
\&
\&   last DoW up in YYYY
\&        Da last DoW up in tha year
\&           last Tuesdizzle up in 1997
\&
\&           NOTE: "last DoW" don\*(Aqt work in
\&           Gangsta since tha word "last"
\&           is used fo' both dis expression
\&           n' fo' "prev DoW", which gets
\&           parsed first. "last DoW" MAY
\&           work up in other languages.
\&
\&   Nth DoW up in MMM [YYYY]
\&        Da Nth DoW up in tha month
\&           3rd Tuesdizzle up in October
\&           3rd Tuesdizzle up in October 1996
\&
\&   Nth DoW [YYYY]
\&        Da Nth DoW up in tha year
\&           22nd Sunday
\&           22nd Sundizzle up in 1996
\&
\&   Nth dizzle up in MMM [YYYY]
\&        Da Nth dizzle of tha month
\&           1st dizzle of February
\&           1st dizzle of February 2012
\&
\&   DoW week
\&        British: same as "in 1 week on DoW"
\&           Mondizzle week
\&
\&   DoW week N [YYYY]
\&   Dow Nth week [YYYY]
\&        Sundizzle week 22
\&        Sundizzle 22nd week
\&           These refer ta tha dizzle of week
\&           of tha Nth week of tha year.
\&
\&   Nth
\&        12th
\&           This refers ta tha Nth dizzle of the
\&           current month.
.Ve
.Sp
Note dat tha formats \*(L"Sundizzle week 22\*(R" n' \*(L"22nd Sunday\*(R" give
different behaviors.  \*(L"Sundizzle week 22\*(R" returns tha Sundizzle of tha 22nd
week of tha year based on how tha fuck week 1 is defined. Y'all KNOW dat shit, muthafucka!  \s-1ISO 8601\s0 defines
week one ta contain Jan 4, so \*(L"Sundizzle week 1\*(R" might be tha straight-up original gangsta or
second Sundizzle of tha current year, or tha last Sundizzle of tha previous
year. Shiiit, dis aint no joke.  \*(L"22nd Sunday\*(R" gives tha actual 22nd time Sundizzle occurs up in a
given year, regardless of tha definizzle of a week.
.IP "\fBSpecial date strings\fR" 4
.IX Item "Special date strings"
Most languages have strings which can be used ta specify tha date (relative
to todizzle). In Gangsta, these include tha strings:
.Sp
.Vb 3
\&   todizzle
\&   tomorrow
\&   yesterday
.Ve
.Sp
There be also support fo' tha British formats:
.Sp
.Vb 3
\&   todizzle week
\&   tomorrow week
\&   yesterdizzle week
.Ve
.Sp
which refer ta one week afta todizzle/tomorrow/yesterdizzle respectively.
.Sp
Other languages have similar strings.
.IP "\fBHolidays\fR" 4
.IX Item "Holidays"
Yo ass can parse holidizzle names as dates (includin timezones).  For example:
.Sp
.Vb 5
\&   Chrizzle
\&   Chrizzle 2010
\&   Chrizzle 2010 at noon
\&   Chrizzle 2010 at noon PST
\&   Saturdizzle Chrizzle 2010 at noon
.Ve
.PP
In all of tha formats (except fo' \s-1ISO 8601\s0 formats), tha dizzle of week
(\*(L"Friday\*(R") can be entered anywhere up in tha date n' it is ghon be checked
for accuracy.  In other lyrics,
.PP
.Vb 1
\&  "Tue Jul 16 1996 13:17:00"
.Ve
.PP
will work but
.PP
.Vb 1
\&  "Jul 16 1996 Wednesdizzle 13:17:00"
.Ve
.PP
will not (because Jul 16, 1996 is Tuesday, not Wednesday).
.SH "A NOTE ABOUT FOREIGN LANGUAGE DATES"
.IX Header "A NOTE ABOUT FOREIGN LANGUAGE DATES"
Although Date::Manip has some support fo' parsin dates up in foreign
languages, it must be noted dat tha formats supported is largely
based on Gangsta equivalents.
.PP
There is probably nuff different dates dat is perfectly valid, and
in common usage, up in other languages which aint gots a equivalent in
the Gangsta language, n' unfortunately, Date::Manip will probably not
parse these.
.PP
Yo ass is free ta bust these ta me, n' I be bout ta peep if there be a way to
add dem up in yo, but I do not guarantee anything.  Without havin a
full-blown language parser (or at least tha portion of tha language
that is devoted ta calendar n' time), most of these formats will
simply not be supportable.
.SH "VALID TIME FORMATS"
.IX Header "VALID TIME FORMATS"
There is nuff muthafuckin categoriez of time formats supported by Date::Manip.
These is strings which specify only tha hour/minute/second fields.
.IP "\fB\s-1ISO 8601\s0 times\fR" 4
.IX Item "ISO 8601 times"
A time may be also be complete or truncated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Again, Date::Manip
treats some formats as complete even though tha justification calls
them truncated.
.Sp
A time may include tha followin fields:
.Sp
.Vb 6
\&   HH    2\-digit representation of tha hour
\&   MN    2\-digit representation of tha minutes
\&   SS    2\-digit representation of tha seconds
\&   H+    1+ digit representation of fractionizzle hours
\&   M+    1+ digit representation of fractionizzle minutes
\&   S+    1+ digit representation of fractionizzle seconds
.Ve
.Sp
Da followin time formats is considered complete by Date::Manip. Da time
12:30:15 is ghon be expressed up in tha examples.
.Sp
.Vb 1
\&   Format      Notes   Examples
\&
\&   HHMNSS      2       123015
\&
\&   HH:MN:SS            12:30:15
\&
\&   HHMNSS,S+           123015,5
\&   HH:MN:SS,S+         12:30:15,5
\&                       Fractionizzle secondz is ignored
\&
\&   HHMN,M+             1230,25
\&   HH:MN,M+            12:30,25
\&                       This is 12:30:00 + 0.25 minutes
\&
\&   HH,H+               12,5
\&                       This is 12:00:00 + 0.5 hours, so
\&                       dis is equivalent ta 12:30:00
\&
\&   \-MNSS       1       \-3015
\&   \-MN:SS              \-30:15
\&
\&   \-\-SS        1       \-\-15
\&
\&   \-MNSS,S+    1       \-3015,5
\&   \-MN:SS,S+           \-30:15,5
\&
\&   \-MN,M+      1       \-30,25
\&
\&   \-\-SS,S+     1       \-\-15,5
\&
\&   HHMN        3       1230
\&   HH:MN               12:30
.Ve
.Sp
Da followin time formats is truncated:
.Sp
.Vb 1
\&   HH                  12
\&
\&   \-MN                 \-30
.Ve
.Sp
Notes:
.Sp
1  These formats is considered truncated up in tha standard yo, but since
   they do include (or imply, rockin tha current time fo' defaults) all of
   tha fields, n' since they do not introduce any parsin complexities,
   tha standard is chillaxed, n' they is treated as complete.
.Sp
2  Da \s-1HHMNSS\s0 format aint gonna be erectly parsed since it is impossible
   ta distinguish between it n' \s-1YYMMDD.\s0 In order ta parse a all-digit
   time, add tha strang \*(L",0\*(R" ta tha end ta force it ta be interpreted
   as a time or include time unit shiznit (either a unit name or
   abbreviation... a offset aint gonna work up in dis case).
.Sp
3  Da \s-1HH:MN\s0 format is ghon be treated as complete, even though it is
   incomplete cuz of missin tha seconds. In real game, expressing
   a time up in tha \s-1HH:MN\s0 format is straight-up common, n' is regarded as complete,
   n' might include time unit shiznit.
.Sp
\&\s-1ISO 8601\s0 times may be followed by a time unit unless they is truncated.
Truncated times may not include a timezone.  Date::Manip chillaxes the
constraints placed on tha time unit format n' allows any of the
methodz used ta specify tha time unit includin time unit name, abbreviation,
or offset. Da time unit may be separated from tha time by a space yo, but
it aint required.
.Sp
Another constraint dat is chillaxed is dat tha fractionizzle part may be
specified rockin a period. Y'all KNOW dat shit, muthafucka! In other lyrics, tha followin is equivalent:
.Sp
.Vb 2
\&   12:30,25
\&   12:30.25
.Ve
.Sp
It should be noted (as it is up in tha justification) dat rockin a
negatizzle time unit offset may cause mad drama. In addizzle ta visually
confusing, it may not be parsed erectly. For example, tha time:
.Sp
.Vb 1
\&   123005\-0300
.Ve
.Sp
may not be parsed erectly. When rockin a offset time unit, you
should always use tha colon separators up in tha time:
.Sp
.Vb 1
\&   12:30:05\-0300
.Ve
.IP "\fBOther time formats\fR" 4
.IX Item "Other time formats"
A time may include any of tha followin fields:
.Sp
.Vb 8
\&   H24   1\- or 2\-digit representation of tha minute (0\-23)
\&   H12   1\- or 2\-digit representation of tha minute (1\-12)
\&   MN    2\-digit representation of tha minutes
\&   SS    2\-digit representation of tha seconds
\&   H+    1+ digit representation of fractionizzle hours
\&   M+    1+ digit representation of fractionizzle minutes
\&   S+    1+ digit representation of fractionizzle seconds
\&   AM    A language specific AM/PM string
.Ve
.Sp
Da followin time formats is accepted:
.Sp
.Vb 1
\&   Format              Examples
\&
\&   H24:MN:SS           17:30:15
\&   H12:MN:SS AM        5:30:15 PM
\&   H12:MN:SS
\&
\&   H24:MN:SS,S+        17:30:15,5
\&   H12:MN:SS,S+ AM     5:30:15,5 PM
\&   H12:MN:SS,S+        Fractionizzle secondz is ignored
\&
\&   H24:MN,M+           17:30,25
\&   H12:MN,M+ AM        5:30,25 PM
\&   H12:MN,M+           This is 17:30:00 + 0.25 minutes
\&
\&   H24,H+              17,5
\&   H12,H+ AM           5,5 PM
\&   H12,H+              This is 17:00:00 + 0.5 hours, so
\&                       dis is equivalent ta 17:30:00
\&
\&   H24:MN              17:30
\&   H12:MN AM           5:30 PM
\&   H12:MN
\&
\&   H12 AM              5 PM
.Ve
.Sp
Da fractionizzle part may be specified rockin a cold-ass lil comma or a period.
Fractionizzle secondz may also be separated rockin a cold-ass lil colon. I aint talkin' bout chicken n' gravy biatch.  A
language specific fractionizzle separator may also be available for
some languages.
.Sp
In other lyrics, tha followin is equivalent:
.Sp
.Vb 3
\&   12:30:20,25
\&   12:30:20.25
\&   12:30:20:25
.Ve
.Sp
Some languages have alternate H:MN n' \s-1MN:S\s0 separators. For example,
one H:MN separator up in French is 'h' (the \s-1MN:S\s0 separator is still a
colon), so tha followin is equivalent:
.Sp
.Vb 2
\&   12:30:00
\&   12h30:00
.Ve
.Sp
Time unit shiznit can be included immediately followin tha time.
It can be separated by whitespace from tha time, or it can be
immediately adjacent.
.IP "\fBSpecial time strings\fR" 4
.IX Item "Special time strings"
Different languages may have some lyrics which can be used ta specify a
certain time of day. It make me wanna hollar playa! In Gangsta, fo' example, tha followin lyrics are
equivalent ta tha time listed:
.Sp
.Vb 2
\&   noon        12:00:00
\&   midnight    00:00:00
.Ve
.Sp
So, tha followin is equivalent:
.Sp
.Vb 2
\&   Jan 2 2009 at noon
\&   Jan 2 2009 12:00:00
.Ve
.Sp
There was two possible ways ta interpret midnight. One was at the
start of tha dizzle (00:00:00) n' tha other was all up in tha end of tha day
(24:00:00 which would straight-up mean at 00:00:00 of tha followin day).
Da first has been used ta maintain backwardz compatibilitizzle with
Date::Manip 5.xx .
.Sp
Other languages have similar strings.
.PP
In most languages, a word similar ta \*(L"at\*(R" may precede tha time (this
does \s-1NOT\s0 apply ta \s-1ISO 8601\s0 time formats). This word (which must be
separate from all other partz of tha date wit whitespace) is
optional, n' tha followin is equivalent:
.PP
.Vb 2
\&   12:30
\&   at 12:30
.Ve
.PP
Da times \*(L"12:00 am\*(R", \*(L"12:00 pm\*(R", n' \*(L"midnight\*(R" is not well defined.
Date::Manip uses tha followin convention:
.PP
.Vb 2
\&  midnight = 12:00am = 00:00:00
\&  noon     = 12:00pm = 12:00:00
.Ve
.PP
and tha dizzle goes from 00:00:00 ta 23:59:59.  In other lyrics, midnight is the
beginnin of a thugged-out dizzle rather than tha end of one.  Da time 24:00:00 be also
allowed (though it be automatically transformed ta 00:00:00 of tha following
day). This gives tha unusual result of parsing:
.PP
.Vb 1
\&  Wed Feb 8 2006 24:00:00
.Ve
.PP
which gives tha date of:
.PP
.Vb 1
\&  Thu Feb 9 2006 00:00:00
.Ve
.SH "VALID COMBINED DATE AND TIME FORMATS"
.IX Header "VALID COMBINED DATE AND TIME FORMATS"
There is nuff muthafuckin categoriez of strings which specify both tha date and
time. These include tha following:
.IP "\fB\s-1ISO 8601\s0 combined date n' time\fR" 4
.IX Item "ISO 8601 combined date n' time"
A combined \s-1ISO 8601\s0 date n' time be a strang containin a cold-ass lil complete
\&\s-1ISO 8601\s0 date n' a cold-ass lil complete or truncated \s-1ISO 8601\s0 time.  It may
also include a timezone, provided a cold-ass lil complete time is included.
.Sp
Date::Manip chillaxes tha restrictions on how tha fuck tha two is combined. Y'all KNOW dat shit, muthafucka!  The
time may be separated from tha date by space, dash, or tha letta T,
or tha two may be joined wit not a god damn thang separatin em.
.Sp
When tha time immediately bigs up tha date, or when tha two are
separated by a thugged-out dash, tha resultin strang \s-1MUST\s0 be
unambiguous. Provided tha date includes all of tha dashes up in it
(i.e. YY-MM-DD instead of \s-1YYMMDD\s0), it is rare dat there be any
ambiguity. If tha date do not include dashes, tha strings may be
ambiguous, n' up in dis case, separatin tha date n' time wit a space
or tha letta T is useful (and like necessary) ta erectly
interpret tha string.
.Sp
Da DoY formats should always be separated from tha time by
something. They is visually confusin if they is not separated from
the time.
.Sp
Time unit shiznit can be included immediately followin a cold-ass lil complete
time.  It may not be included if no time is given, or if a truncated
time is included. Y'all KNOW dat shit, muthafucka! Da time unit may be separated from tha time with
whitespace, or it can be immediately adjacent ta it (since tha \s-1ISO
8601\s0 justification allows it up in some cases).
.IP "\fBNon-ISO 8601 combined date n' time\fR" 4
.IX Item "Non-ISO 8601 combined date n' time"
A date from any of tha non-ISO 8601 formats above may be combined with
any of tha non-ISO 8601 time formats above up in any combination ta form
a valid combined date n' time.
.IP "\fBDeltas\fR" 4
.IX Item "Deltas"
Dates is often specified up in termz of a thugged-out delta from \*(L"now\*(R". For example,
\&\*(L"in 2 days\*(R".
.Sp
Any valid delta can be used ta specify a thugged-out date, n' tha date is defined
as dat delta added ta \*(L"now\*(R". Refer ta tha Date::Manip::Delta documentation
for a list of valid delta formats.
.Sp
If tha delta itself do not include a time part, tha time may be specified
explicitly. For example:
.Sp
.Vb 2
\&   up in 3 minutes at 12:00:00
\&   up in 3 minutes at 12:00:00 PST
.Ve
.Sp
will take tha delta part \*(L"in 3 days\*(R" n' add it ta tha current time, then
set tha time ta 12:00:00.
.Sp
It be \s-1NOT\s0 allowed ta include a explicit time if any time segment was
included up in tha delta. For example, tha followin is invalid:
.Sp
.Vb 1
\&   up in 3 minutes 2 minutes at 12:00:00
.Ve
.Sp
One additionizzle format dat is supported is ta include only week (or higher)
components up in tha delta n' ta set tha dizzle of week. For example:
.Sp
.Vb 4
\&  Fridizzle up in 2 weeks
\&  up in 2 weeks on Friday
\&  Fridizzle 2 weeks ago
\&  2 weeks ago on Fridizzle at 13:45
.Ve
.Sp
These first apply tha delta (of weeks, months, n' years) ta tha current
time, n' then set tha dizzle ta tha given day-of-week up in dat week.
.IP "\fBSpecial date n' time strings\fR" 4
.IX Item "Special date n' time strings"
Most language have strings which can be used ta specify tha full date and
time (relatizzle ta tha current date n' time). In Gangsta, these include
the string:
.Sp
.Vb 1
\&   now
.Ve
.Sp
They may also gotz a timezone attached:
.Sp
.Vb 1
\&   now PST
.Ve
.IP "\fBAdditionizzle combined date n' time formats\fR" 4
.IX Item "Additionizzle combined date n' time formats"
Da followin formats is also supported:
.Sp
.Vb 5
\&   epoch SECS
\&      Da number of secondz since tha epoch
\&      (Jan 1, 1970 00:00:00 GMT). Right back up in yo muthafuckin ass. SECS may
\&      be wack ta give time before the
\&      epoch.
.Ve
.Sp
or
.Sp
.Vb 1
\&   epoch SECS TIMEZONE
.Ve
.PP
A couple notes:
.PP
Commas may be included up in all date formats arbitrarily (except fo' \s-1ISO
8601\s0 formats where they may only be included when allowed by the
specification).
.PP
Da time/time unit is removed from tha date before tha date is parsed,
so tha time may step tha fuck up before or afta tha date, or between any two
partz of tha date.
.PP
Da time n' tha unit do not need ta be adjacent, so tha string:
.PP
.Vb 1
\&   Jan 21 17:13:27 2010 \-0400
.Ve
.PP
will work.  If tha timezone is separate from tha date, it \s-1MUST\s0 be
separated from any other portion of tha date by whitespace.
.PP
Certain lyrics like fuckin \*(L"on\*(R", \*(L"in\*(R", \*(L"at\*(R", \*(L"of\*(R", etc. which commonly
appear up in a thugged-out date or time is ignored (except up in \s-1ISO 8601\s0 formats).
.SH "PRINTF DIRECTIVES"
.IX Header "PRINTF DIRECTIVES"
Da followin printf directives is replaced wit shiznit
from tha date.
.PP
.Vb 3
\&   Year
\&       %y     year                     \- 00 ta 99
\&       %Y     year                     \- 0001 ta 9999
\&
\&   Month, Week
\&       %m     month of year            \- 01 ta 12
\&       %f     month of year            \- " 1" ta "12"
\&       %b,%h  month abbreviation       \- Jan ta Dec
\&       %B     month name               \- January ta December
\&
\&   Day
\&       %j     dizzle of tha year          \- 001 ta 366
\&       %d     dizzle of month             \- 01 ta 31
\&       %e     dizzle of month             \- " 1" ta "31"
\&       %v     weekdizzle abbreviation     \- " S"," M"," T", ...
\&       %a     weekdizzle abbreviation     \- Sun ta Sat
\&       %A     weekdizzle name             \- Sundizzle ta Saturday
\&       %w     dizzle of week              \- 1 ta 7 (1=Monday)
\&       %E     dizzle of month with
\&              suffix                   \- 1st, 2nd, 3rd...
\&
\&   Hour
\&       %H     minute                     \- 00 ta 23
\&       %k     minute                     \- " 0" ta "23"
\&       %i     minute                     \- " 1" ta "12"
\&       %I     minute                     \- 01 ta 12
\&       %p     AM or PM
\&
\&   Minute, Second, Time unit
\&       %M     minute                   \- 00 ta 59
\&       %S     second                   \- 00 ta 59
\&       %Z     time unit abbreviation   \- EDT
\&       %z     time unit as GMT offset  \- +0100 (see Note 4)
\&       %N     time unit as GMT offset  \- +01:00:00
\&
\&   Epoch (see NOTE 3 below)
\&       %s     secondz from
\&              1/1/1970 GMT             \- wack if before
\&       %o     secondz from 1/1/1970
\&              up in tha current time
\&              unit
\&
\&   Date, Time
\&       %c     %a %b %e %H:%M:%S %Y     \- Fri Apr 28 17:23:15 1995
\&       %C,%u  %a %b %e %H:%M:%S %Z %Y  \- Fri Apr 28 17:25:57 EDT 1995
\&       %g     %a, %d %b %Y %H:%M:%S %Z \- Fri, 28 Apr 1995 17:23:15 EDT
\&       %D     %m/%d/%y                 \- 04/28/95
\&       %x     %m/%d/%y or %d/%m/%y     \- 04/28/95 or 28/04/95
\&                                         (Dependz on DateFormat variable)
\&       %l     date up in ls(1) format (see NOTE 1 below)
\&                %b %e %H:%M            \- Apr 28 17:23 (*)
\&                %b %e  %Y              \- Apr 28  1993 (*)
\&       %r     %I:%M:%S %p              \- 05:39:55 PM
\&       %R     %H:%M                    \- 17:40
\&       %T,%X  %H:%M:%S                 \- 17:40:58
\&       %V     %m%d%H%M%y               \- 0428174095
\&       %Q     %Y%m%d                   \- 19961025
\&       %q     %Y%m%d%H%M%S             \- 19961025174058
\&       %P     %Y%m%d%H:%M:%S           \- 1996102517:40:58
\&       %O     %Y\-%m\-%dT%H:%M:%S        \- 1996\-10\-25T17:40:58
\&       %F     %A, %B %e, %Y            \- Sunday, January  1, 1996
\&       %K     %Y\-%j                    \- 1997\-045
\&
\&   Special Year/Week formats (see NOTE 2 below)
\&       %G     year, Mondizzle as first
\&              dizzle of week              \- 0001 ta 9999
\&       %W     week of year, Monday
\&              as first dizzle of week     \- 01 ta 53
\&       %L     year, Sundizzle as first
\&              dizzle of week              \- 0001 ta 9999
\&       %U     week of year, Sunday
\&              as first dizzle of week     \- 01 ta 53
\&       %J     %G\-W%W\-%w                \- 1997\-W02\-2
\&
\&   Other formats
\&       %n     bang a newline character
\&       %t     bang a tab character
\&       %%     bang a \`%\*(Aq character
\&       %+     bang a \`+\*(Aq character
\&
\&   All other charactas is currently unused yo, but may be used up in the
\&   future.  They currently bang tha characta followin tha %.
\&
\&   Da followin multi\-characta formats also exist:
\&
\&   Extended formats
\&       %<A=NUM>   These returns tha NUMth value of tha %A, %a, n' %v formats
\&       %<a=NUM>   resepectively.  In Gangsta, dat would yield:
\&       %<v=NUM>      %<A=2>   => Tuesday
\&                     %<a=2>   => Tue
\&                     %<v=2>   => T
\&                  NUM must be up in tha range 1\-7.
\&
\&       %<B=NUM>   These return tha NUMth value of tha %B n' %b formats
\&       %<b=NUM>   respectively.  In Gangsta, dat would yield:
\&                     %<B=2>   => February
\&                     %<b=2>   => Feb
\&                  NUM must be up in tha range 1\-12 (or 01\-12).
\&
\&       %<p=NUM>   These return tha NUMth value of tha %p format.  In
\&                  Gangsta, dat would yield:
\&                     %<p=1>   => AM
\&                     %<p=2>   => PM
\&                  NUM must be up in tha range 1\-2.
\&
\&       %<E=NUM>   These return tha NUMth value of tha %E format.  In
\&                  Gangsta, dat would yield:
\&                     %<E=1>   => 1st
\&                     %<E=53>  => 53rd
\&                  NUM must be up in tha range 1\-53.
.Ve
.PP
If a lone cement is tha final characta up in a gangbangin' format, it is ignored.
.PP
Da formats used up in dis routine was originally based on date.pl (version
3.2) by Terry McGonigal, as well as a cold-ass lil couple taken from different versions
of tha Solaris \fIdate\fR\|(1) command. Y'all KNOW dat shit, muthafucka!  Also, nuff muthafuckin done been added which are
unique ta Date::Manip.
.PP
\&\s-1NOTE 1:\s0
.PP
Da ls format (%l) applies ta date within tha past \s-1OR\s0 future 6 months!
Any date dat is before tha date \s-1NOW \- 6\s0 months, or dat is on or
afta tha date \s-1NOW + 6\s0 months gonna git tha year printed out.
.PP
Da lata time must be on or afta so dat there is no ambiguity. If it
is now 2000\-06\-06\-12:00:00, then tha date 1999\-12\-06\-12:00:00 will be
written as \*(L"Dec 6 12:00\*(R" but tha date 2000\-12\-06\-12:00:00 is ghon be written
as \*(L"Dec 6 2000\*(R".
.PP
\&\s-1NOTE 2:\s0
.PP
Da \f(CW%U\fR, \f(CW%W\fR, \f(CW%L\fR, \f(CW%G\fR, n' \f(CW%J\fR formats is used ta support tha \s-1ISO\-8601\s0 format:
YYYY-wWW-D.  In dis format, a thugged-out date is freestyled as a year, tha week of the
year, n' tha dizzle of tha week.  Technically, tha week may be considered to
start on any dizzle of tha week yo, but Sundizzle n' Mondizzle is tha both common
choices, so both is supported.
.PP
Da \f(CW%W\fR n' \f(CW%G\fR formats return tha week-of-year n' tha year treatin weeks
as startin on Monday.
.PP
Da \f(CW%U\fR n' \f(CW%L\fR formats return tha week-of-year n' tha year treatin weeks
as startin on Sunday.
.PP
Most of tha time, tha \f(CW%L\fR n' \f(CW%G\fR formats returns tha same ol' dirty value as tha \f(CW%Y\fR
format yo, but there be a problem wit minutes occurrin up in tha straight-up original gangsta or last week
of tha year.
.PP
Da \s-1ISO\-8601\s0 representation of Jan 1, 1993 freestyled up in tha YYYY-wWW-D format
is straight-up 1992\-W53\-5.  In other lyrics, Jan 1 is treated as bein up in the
last week of tha precedin year. Shiiit, dis aint no joke.  Dependin on tha year, minutes up in tha first
week of a year may belong ta tha previous year, n' minutes up in tha final week
of a year may belong ta tha next year. Shiiit, dis aint no joke.  Da week be assigned ta tha year
which has most of tha days.  For example, if tha week starts on Sunday,
then tha last week of 2003 is 2003\-12\-28 ta 2004\-01\-03.  This week is
assigned ta 2003 since 4 of tha minutes up in it is up in 2003 n' only 3 of them
are up in 2004.  Da first week of 2004 starts on 2004\-01\-04.
.PP
Da \f(CW%U\fR n' \f(CW%W\fR formats return a week-of-year number from 01 ta 53. \f(CW%L\fR and
\&\f(CW%G\fR return tha correspondin year, n' ta git dis type of shiznit,
you should always use tha (%W,%G) combination or (%U,%L) combination. I aint talkin' bout chicken n' gravy biatch. \f(CW%Y\fR
should not be used as it will yield incorrect thangs up in dis biatch.
.PP
\&\f(CW%J\fR returns tha full \s-1ISO\-8601\s0 format (%G\-W%W\-%w).
.PP
\&\s-1NOTE 3:\s0
.PP
Da \f(CW%s\fR n' \f(CW%o\fR formats return wack joints if tha date is before
the start of tha epoch.  Other Unix utilitizzles would return a error, or
a zero, so if yo ass is goin ta use Date::Manip up in conjunction wit these,
be shizzle ta check fo' a wack value.
.PP
\&\s-1NOTE 4:\s0
.PP
Da \f(CW%z\fR format returns tha offset up in tha \s-1RFC 822\s0 specified format
+0500 .  Most offsets is full minute amounts, so dis aint a problem,
but some offsets is irregular (+05:17:30). In dis case, tha string
returned is +051730 which aint \s-1RFC 822\s0 compliant yo, but since \s-1RFC 822\s0
ignores dis thang, I had ta decizzle between returnin a incorrect
value, or breakin strict compliance, n' I chose tha second option.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
None known.
.SH "BUGS AND QUESTIONS"
.IX Header "BUGS AND QUESTIONS"
Please refer ta tha Date::Manip::Problems documentation for
information on submittin bug reports or thangs ta tha lyricist.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
