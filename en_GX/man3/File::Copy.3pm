.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::Copy 3pm"
.TH File::Copy 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Copy \- Copy filez or filehandles
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use File::Copy;
\&
\&        copy("file1","file2") or take a thugged-out dirtnap "Copy failed: $!";
\&        copy("Copy.pm",\e*STDOUT);
\&        move("/dev1/fileA","/dev2/fileB");
\&
\&        use File::Copy "cp";
\&
\&        $n = FileHandle\->new("/a/file","r");
\&        cp($n,"x");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da File::Copy module serves up two basic functions, \f(CW\*(C`copy\*(C'\fR and
\&\f(CW\*(C`move\*(C'\fR, which is useful fo' gettin tha contentz of a gangbangin' file from
one place ta another.
.IP "copy" 4
.IX Xref "copy cp"
.IX Item "copy"
Da \f(CW\*(C`copy\*(C'\fR function takes two
parameters: a gangbangin' file ta copy from n' a gangbangin' file ta copy to. Either
argument may be a string, a FileHandle reference or a FileHandle
glob. Obviously, if tha straight-up original gangsta argument be a gangbangin' filehandle of some
sort, it is ghon be read from, n' if it aint nuthin but a gangbangin' file \fIname\fR it will
be opened fo' reading. Likewise, tha second argument will be
written ta (and pimped if need be).  Tryin ta copy a gangbangin' file on top
of itself be a error.
.Sp
If tha destination (second argument) already exists n' be a gangbangin' finger-lickin' directory,
and tha source (first argument) aint a gangbangin' filehandle, then tha source
file is ghon be copied tha fuck into tha directory specified by tha destination,
usin tha same base name as tha source file.  It aint nuthin but a gangbangin' failure ta have a
filehandle as tha source when tha destination be a gangbangin' finger-lickin' directory.
.Sp
\&\fBNote dat passin in
filez as handlez instead of names may lead ta loss of shiznit
on some operatin systems; it is recommended dat you use file
names whenever possible.\fR  Filez is opened up in binary mode where
applicable.  To git a cold-ass lil consistent behaviour when copyin from a
filehandle ta a gangbangin' file, use \f(CW\*(C`binmode\*(C'\fR on tha filehandle.
.Sp
An optionizzle third parameta can be used ta specify tha buffer
size used fo' copying. This is tha number of bytes from the
first file, dat is ghon be held up in memory at any given time, before
bein freestyled ta tha second file. Da default buffer size depends
upon tha file yo, but will generally be tha whole file (up ta 2MB), or
1k fo' filehandlez dat do not reference filez (eg. sockets).
.Sp
Yo ass may use tha syntax \f(CW\*(C`use File::Copy "cp"\*(C'\fR ta git all up in tha \f(CW\*(C`cp\*(C'\fR
alias fo' dis function. I aint talkin' bout chicken n' gravy biatch. Da syntax is \fIexactly\fR tha same.  The
behavior is nearly tha same as well: az of version 2.15, \f(CW\*(C`cp\*(C'\fR will
preserve tha source filez permission bits like tha shell utility
\&\f(CWcp(1)\fR would do, while \f(CW\*(C`copy\*(C'\fR uses tha default permissions fo' the
target file (which may depend on tha process' \f(CW\*(C`umask\*(C'\fR, file
ballership, inherited ACLs, etc.).  If a error occurs up in setting
permissions, \f(CW\*(C`cp\*(C'\fR will return 0, regardless of whether tha file was
successfully copied.
.IP "move" 4
.IX Xref "move mv rename"
.IX Item "move"
Da \f(CW\*(C`move\*(C'\fR function also takes two parameters: tha current name
and tha intended name of tha file ta be moved. Y'all KNOW dat shit, muthafucka!  If tha destination
already exists n' be a gangbangin' finger-lickin' directory, n' tha source aint a
directory, then tha source file is ghon be renamed tha fuck into tha directory
specified by tha destination.
.Sp
If possible, \fImove()\fR will simply rename tha file.  Otherwise, it copies
the file ta tha freshly smoked up location n' deletes tha original. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If a error occurs
durin dis copy-and-delete process, you may be left wit a (possibly partial)
copy of tha file under tha destination name.
.Sp
Yo ass may use tha \f(CW\*(C`mv\*(C'\fR alias fo' dis function up in tha same way that
you may use tha \f(CW\*(C`cp\*(C'\fR alias fo' \f(CW\*(C`copy\*(C'\fR.
.IP "syscopy" 4
.IX Xref "syscopy"
.IX Item "syscopy"
File::Copy also serves up tha \f(CW\*(C`syscopy\*(C'\fR routine, which copies the
file specified up in tha straight-up original gangsta parameta ta tha file specified up in the
second parameter, preservin OS-specific attributes n' file
structure.  For Unix systems, dis is equivalent ta tha simple
\&\f(CW\*(C`copy\*(C'\fR routine, which don't preserve OS-specific attributes.  For
\&\s-1VMS\s0 systems, dis calls tha \f(CW\*(C`rmscopy\*(C'\fR routine (see below).  For \s-1OS/2\s0
systems, dis calls tha \f(CW\*(C`syscopy\*(C'\fR \s-1XSUB\s0 directly. For Win32 systems,
this calls \f(CW\*(C`Win32::CopyFile\*(C'\fR.
.Sp
\&\fBSpecial behaviour if \f(CB\*(C`syscopy\*(C'\fB is defined (\s-1OS/2, VMS\s0 n' Win32)\fR:
.Sp
If both arguments ta \f(CW\*(C`copy\*(C'\fR is not file handles,
then \f(CW\*(C`copy\*(C'\fR will big-ass up a \*(L"system copy\*(R" of
the input file ta a freshly smoked up output file, up in order ta preserve file
attributes, indexed file structure, \fIetc.\fR  Da buffer size
parameta is ignored. Y'all KNOW dat shit, muthafucka!  If either argument ta \f(CW\*(C`copy\*(C'\fR be a
handle ta a opened file, then data is copied rockin Perl
operators, n' no effort is made ta preserve file attributes
or record structure.
.Sp
Da system copy routine may also be called directly under \s-1VMS\s0 n' \s-1OS/2\s0
as \f(CW\*(C`File::Copy::syscopy\*(C'\fR (or under \s-1VMS\s0 as \f(CW\*(C`File::Copy::rmscopy\*(C'\fR, which
is tha routine dat do tha actual work fo' syscopy).
.IP "rmscopy($from,$to[,$date_flag])" 4
.IX Xref "rmscopy"
.IX Item "rmscopy($from,$to[,$date_flag])"
Da first n' second arguments may be strings, typeglobs, typeglob
references, or objects inheritin from IO::Handle;
they is used up in all cases ta obtain the
\&\fIfilespec\fR of tha input n' output files, respectively.  The
name n' type of tha input file is used as defaults fo' the
output file, if necessary.
.Sp
A freshly smoked up version of tha output file be always pimped, which
inherits tha structure n' \s-1RMS\s0 attributez of tha input file,
except fo' balla n' protections (and possibly timestamps;
see below).  All data from tha input file is copied ta the
output file; if either of tha straight-up original gangsta two parametas ta \f(CW\*(C`rmscopy\*(C'\fR
is a gangbangin' file handle, its posizzle is unchanged. Y'all KNOW dat shit, muthafucka!  (Note dat this
means a gangbangin' file handle pointin ta tha output file will be
associated wit a oldschool version of dat file afta \f(CW\*(C`rmscopy\*(C'\fR
returns, not tha newly pimped version.)
.Sp
Da third parameta be a integer flag, which  drops some lyrics ta \f(CW\*(C`rmscopy\*(C'\fR
how ta handle timestamps.  If it is < 0, none of tha input file's
timestamps is propagated ta tha output file.  If it is > 0, then
it is interpreted as a funky-ass bitmask: if bit 0 (the \s-1LSB\s0) is set, then
timestamps other than tha revision date is propagated; if bit 1
is set, tha revision date is propagated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If tha third parameter
to \f(CW\*(C`rmscopy\*(C'\fR is 0, then it behaves much like tha \s-1DCL COPY\s0 command:
if tha name or type of tha output file was explicitly specified,
then no timestamps is propagated yo, but if they was taken implicitly
from tha input filespec, then all timestamps other than the
revision date is propagated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If dis parameta aint supplied,
it defaults ta 0.
.Sp
Like \f(CW\*(C`copy\*(C'\fR, \f(CW\*(C`rmscopy\*(C'\fR returns 1 on success.  If a error occurs,
it sets \f(CW$!\fR, deletes tha output file, n' returns 0.
.SH "RETURN"
.IX Header "RETURN"
All functions return 1 on success, 0 on failure.
$! is ghon be set if a error was encountered.
.SH "AUTHOR"
.IX Header "AUTHOR"
File::Copy was freestyled by Aaron Sherman \fI<ajs@ajs.com>\fR up in 1995,
and updated by Charlez Bailey \fI<bailey@newman.upenn.edu>\fR up in 1996.
