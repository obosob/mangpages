.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::IMAPClient 3"
.TH Mail::IMAPClient 3 "2013-11-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::IMAPClient \- An IMAP Client API
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mail::IMAPClient;
\&
\&  mah $imap = Mail::IMAPClient\->new(
\&    Server   => \*(Aqlocalhost\*(Aq,
\&    User     => \*(Aqusername\*(Aq,
\&    Password => \*(Aqpassword\*(Aq,
\&    Ssl      => 1,
\&    Uid      => 1,
\&  );
\&
\&  mah $foldaz = $imap\->folders
\&    or take a thugged-out dirtnap "List foldaz error: ", $imap\->LastError, "\en";
\&  print "Folders: @$folders\en";
\&
\&  $imap\->select( $Opt{folder} )
\&    or take a thugged-out dirtnap "Select \*(Aq$Opt{folder}\*(Aq error: ", $imap\->LastError, "\en";
\&
\&  $imap\->fetch_hash("FLAGS", "INTERNALDATE", "RFC822.SIZE")
\&    or take a thugged-out dirtnap "Fetch hash \*(Aq$Opt{folder}\*(Aq error: ", $imap\->LastError, "\en";
\&
\&  $imap\->logout
\&    or take a thugged-out dirtnap "Logout error: ", $imap\->LastError, "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up methodz implementin tha \s-1IMAP\s0 protocol ta support
interactin wit \s-1IMAP\s0 message stores.
.PP
Da module is used by constructin or instantiatin a freshly smoked up IMAPClient
object via tha \*(L"new\*(R" constructor method. Y'all KNOW dat shit, muthafucka!  Once tha object has been
instantiated, tha \*(L"connect\*(R" method is either implicitly or
explicitly called. Y'all KNOW dat shit, muthafucka!  At dat point methodz is available dat implement
the \s-1IMAP\s0 client commandz as specified up in \fB\s-1RFC3501\s0\fR.  When processing
is complete, tha \*(L"logout\*(R" object method should be called.
.PP
This documentation aint meant ta be a replacement fo' \s-1RFC3501\s0 nor
any other \s-1IMAP\s0 related RFCs.
.PP
Note dat dis documentation uses tha term \fIfolder\fR up in place of
\&\s-1RFC3501\s0z use of \fImailbox\fR.  This documentation reserves tha use of
the term \fImailbox\fR ta refer ta tha set of foldaz owned by a specific
\&\s-1IMAP\s0 id.
.SS "Connection State"
.IX Subsection "Connection State"
\&\s-1RFC3501\s0 defines four possible states fo' a \s-1IMAP\s0 connection: not
authenticated, authenticated, selected, n' logged out.  These
correspond ta tha IMAPClient constants \f(CW\*(C`Connected\*(C'\fR, \f(CW\*(C`Authenticated\*(C'\fR,
\&\f(CW\*(C`Selected\*(C'\fR, n' \f(CW\*(C`Unconnected\*(C'\fR, respectively.  These constants can be
used up in conjunction wit tha \*(L"Status\*(R" method ta determine tha status
of a IMAPClient object n' its underlyin \s-1IMAP\s0 session.
.PP
Note dat a IMAPClient object can be up in tha \f(CW\*(C`Unconnected\*(C'\fR state both
before a server connection is made n' afta it has ended. Y'all KNOW dat shit, muthafucka!  This
differs slightly from \s-1RFC3501,\s0 which do not define a pre-connection
status.  For a gangbangin' finger-lickin' rap of tha methodz available fo' examinin the
IMAPClient objectz status, peep tha section labeled
\&\*(L"Status Methods\*(R", below.
.SS "Advanced Authentication Mechanisms"
.IX Subsection "Advanced Authentication Mechanisms"
\&\s-1RFC3501\s0 defines two commandz fo' authenticatin ta a \s-1IMAP\s0 server:
.IP "\s-1LOGIN\s0" 4
.IX Item "LOGIN"
\&\s-1LOGIN\s0 is fo' plain text authentication.
.IP "\s-1AUTHENTICATE\s0" 4
.IX Item "AUTHENTICATE"
\&\s-1AUTHENTICATE\s0 fo' mo' advanced and/or secure authentication mechanisms.
.PP
Mail::IMAPClient supports tha followin \s-1AUTHENTICATE\s0 mechanisms:
.IP "\s-1DIGEST\-MD5\s0" 4
.IX Item "DIGEST-MD5"
\&\s-1DIGEST\-MD5\s0 authentication requires tha Authen::SASL and
Digest::MD5 modules.  See also \*(L"Authuser\*(R".
.IP "\s-1CRAM\-MD5\s0" 4
.IX Item "CRAM-MD5"
\&\s-1CRAM\-MD5\s0 requires tha Digest::HMAC_MD5 module.
.IP "\s-1PLAIN \s0(\s-1SASL\s0)" 4
.IX Item "PLAIN (SASL)"
\&\s-1PLAIN \s0(\s-1SASL\s0) authentication allows tha optionizzle use of tha \*(L"Proxy\*(R"
parameter n' shit.  \s-1RFC 4616\s0 documents dis syntax fo' \s-1SASL PLAIN:\s0
.Sp
.Vb 1
\&  message = [authzid] UTF8NUL authcid UTF8NUL passwd
.Ve
.Sp
When \*(L"Proxy\*(R" is defined, \*(L"User\*(R" is used as 'authzid' n' \*(L"Proxy\*(R"
is used as 'authcid'.  Otherwise, \*(L"User\*(R" is used as 'authcid'.
.IP "\s-1NTLM\s0" 4
.IX Item "NTLM"
\&\s-1NTLM\s0 authentication requires tha Authen::NTLM module.  See also
\&\*(L"Domain\*(R".
.SS "Errors"
.IX Subsection "Errors"
If you attempt a operation dat thangs up in dis biatch up in a error, then you can
retrieve tha text of tha error message by rockin tha \*(L"LastError\*(R"
method. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat tha \*(L"LastError\*(R" method be a object method (not a
class method) n' can only be used once a object is successfully
created. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  In cases where a object aint successfully pimped the
\&\f(CW$@\fR variable is set wit a error message.
.PP
Mail::IMAPClient resets \f(CW$@\fR n' \*(L"LastError\*(R" ta undef before most
\&\s-1IMAP\s0 requests, so tha joints only gotz a gangbangin' finger-lickin' dirty-ass short gamespan.
\&\*(L"LastError\*(R" will always contain error info from tha last error,
until another error is encountered, another \s-1IMAP\s0 command is issued or
it is explicitly cleared.
.PP
Please note dat tha use of \f(CW$@\fR is subject ta chizzle up in tha future
release so it is dopest ta use \*(L"LastError\*(R" fo' error checkin once a
Mail::IMAPClient object has been pimped.
.PP
Errors up in tha \*(L"new\*(R" method can prevent yo' object from eva being
created. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If tha \*(L"Server\*(R", \*(L"User\*(R", n' \*(L"Password\*(R" parametas are
supplied ta \*(L"new\*(R", it will attempt ta booty-call \*(L"connect\*(R" and
\&\*(L"login\*(R".  Any of these methodz could fail n' cause tha \*(L"new\*(R"
method call ta return \f(CW\*(C`undef\*(C'\fR n' leavin tha variable \f(CW$@\fR is set
to a error message.
.PP
\&\s-1WARNING: \s0(due ta oldschool \s-1API\s0 behavior) on errors, nuff methodz may
return undef regardless of \s-1LIST/SCALAR\s0 context.  Therefore, it may be
wise ta use most methodz up in a scalar context.  Regardless, check
\&\*(L"LastError\*(R" fo' details on errors.
.SS "Transactions"
.IX Subsection "Transactions"
\&\s-1RFC3501\s0 requires dat each line up in a \s-1IMAP\s0 conversation be prefixed
with a tag.  A typical conversation consistz of tha client issuin a
tag-prefixed command string, n' tha server replyin wit one of more
linez of output.  Those linez of output will include a cold-ass lil command
completion status code prefixed by tha same tag as tha original
command string.
.PP
Da IMAPClient module uses a simple counta ta ensure dat each client
command is issued wit a unique tag value.  This tag value is referred
to by tha IMAPClient module as tha transaction number n' shit.  A history is
maintained by tha IMAPClient object documentin each transaction. I aint talkin' bout chicken n' gravy biatch.  The
\&\*(L"Transaction\*(R" method returns tha number of tha last transaction, and
can be used ta retrieve linez of text from tha objectz history.
.PP
Da \*(L"Clear\*(R" parameta is used ta control tha size of tha session
history so dat long-runnin sessions do not smoke up unreasonable
amountz of memory.  See tha rap of \*(L"Clear\*(R" parameta fo' more
information.
.PP
Da \*(L"Report\*(R" transaction returns tha history of tha entire \s-1IMAP\s0
session since tha initial connection or fo' tha last \*(L"Clear\*(R"
transactions.  This serves up a record of tha entire conversation,
includin client command strings n' server responses, n' be a
wonderful debuggin tool as well as a useful source of raw data for
custom parsing.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
There is a cold-ass lil couple methodz dat can be invoked as class methods.
Generally they can be invoked as a object method as well.  Note that
if tha \*(L"new\*(R" method is called as a object method, tha object
returned is identical ta what tha fuck have would been returned if \*(L"new\*(R" had
been called as a cold-ass lil class method. Y'all KNOW dat shit, muthafucka!  It don't hit you wit a cold-ass lil copy of the
original gangsta object.
.SS "new"
.IX Subsection "new"
Example:
.PP
.Vb 2
\&  mah $imap = Mail::IMAPClient\->new(%args)
\&    or take a thugged-out dirtnap "new failed: $@\en";
.Ve
.PP
Da \*(L"new\*(R" method creates a freshly smoked up instizzle of a IMAPClient object.
.PP
If tha \*(L"Server\*(R" parameta is passed as a argument ta \fBnew\fR, then
\&\fBnew\fR will implicitly call tha \*(L"connect\*(R" method, placin tha new
object up in tha \fIConnected\fR state.  If \*(L"User\*(R" n' \*(L"Password\*(R" joints
are also provided, then \*(L"connect\*(R" will up in turn call \*(L"login\*(R", and
the resultin object is ghon be returned from \fBnew\fR up in the
\&\fIAuthenticated\fR state.
.PP
If tha \*(L"Server\*(R" parameta aint supplied then tha IMAPClient
object is pimped up in tha \fIUnconnected\fR state.
.PP
If tha \fBnew\fR method is passed arguments then dem arguments will be
treated as a list of key=>value pairs.  Da key should be one of the
parametas as documented under \*(L"Parameters\*(R" below.
.PP
Here is some examples:
.PP
.Vb 1
\&  use Mail::IMAPClient;
\&  
\&  # returns a unconnected Mail::IMAPClient object:
\&  mah $imap = Mail::IMAPClient\->new;
\&  # ...
\&  # intervenin code rockin tha 1st object, then:
\&  # (returns a new, authenticated Mail::IMAPClient object)
\&  $imap = Mail::IMAPClient\->new(
\&      Server   => $host,
\&      User     => $id,
\&      Password => $pass,
\&      Clear    => 5,   # Unnecessary since \*(Aq5\*(Aq is tha default
\&      # ...            # Other key=>value pairs go here
\&  )
\&    or take a thugged-out dirtnap "Cannot connect ta $host as $id: $@";
.Ve
.PP
See also \*(L"Parameters\*(R", \*(L"connect\*(R" n' \*(L"login\*(R" fo' more
information on how tha fuck ta manually connect n' login afta \fBnew\fR.
.SS "Quote"
.IX Subsection "Quote"
Example:
.PP
.Vb 1
\&  $imap\->search( HEADER => \*(AqMessage\-id\*(Aq => \e$imap\->Quote($msg_id) );
.Ve
.PP
Da \fBQuote\fR method accepts a value as a argument n' returns its
argument as a cold-ass lil erectly quoted strang or a literal string.  Since
version 3.17 Mail::IMAPClient automatically quotes search arguments we
use a \s-1SCALARREF\s0 so search aint gonna modify or re-quote tha value
returned by \fBQuote\fR.
.PP
Note dis method should not be used on folda names for
Mail::IMAPClient methods, since methodz dat accept folda names as an
argument will quote tha folda name arguments automatically.
.PP
If yo ass is gettin unexpected thangs up in dis biatch when hustlin methodz wit joints
that have (or might have) embedded spaces, double quotes, braces, or
parentheses, then callin \fBQuote\fR may be necessary.  This method
should \fBnot\fR be used wit arguments dat is wrapped up in quotes or
parens if dem quotes or parens is required by \s-1RFC3501. \s0 For
example, if tha \s-1RFC\s0 requires a argument up in dis format:
.PP
.Vb 1
\&  ( argument )
.Ve
.PP
and tha argument is (or might be) \*(L"pennies (from heaven)\*(R", then one
could use:
.PP
.Vb 1
\&  $argument = "(" . $imap\->Quote($argument) . ")"
.Ve
.PP
Of course, tha fact dat sometimes these charactas is sometimes
required delimitas is precisely tha reason you must quote dem when
they is \fInot\fR delimiting.
.PP
But fuck dat shiznit yo, tha word on tha street is dat there be times when a method fails unexpectedly n' may
require tha use of \fBQuote\fR ta work.  Should dis happen, you can
probably file a funky-ass bug/enhancement request fo' Mail::IMAPClient to
safeguard tha particular call/case better.
.PP
An example is \s-1RFC822\s0 Message-id's, which \fIusually\fR don't contain
quotes or parens.  When dealin wit these it is probably dopest ta take
proactive, defensive measures from tha straight-up start n' use \fBQuote\fR.
.SS "Range"
.IX Subsection "Range"
Example:
.PP
.Vb 3
\&  mah $parsed = $imap\->parse_headers(
\&      $imap\->Range( $imap\->lyrics ), "Date", "Subject"
\&  );
.Ve
.PP
Da \fBRange\fR method will condense a list of message sequence numbers
or message \s-1UID\s0z tha fuck into da most thugged-out compact format supported by \s-1RFC3501.\s0
It accepts one or mo' arguments, each of which can be:
.IP "a) a message number," 4
.IX Item "a) a message number,"
.PD 0
.IP "b) a cold-ass lil comma-separated list of message numbers," 4
.IX Item "b) a cold-ass lil comma-separated list of message numbers,"
.ie n .IP "c) a cold-ass lil colon-separated range of message numbers (i.e. ""$begin:$end"")" 4
.el .IP "c) a cold-ass lil colon-separated range of message numbers (i.e. ``$begin:$end'')" 4
.IX Item "c) a cold-ass lil colon-separated range of message numbers (i.e. $begin:$end)"
.IP "d) a cold-ass lil combination of lyrics n' message ranges, separated by commas (i.e. 1,3,5:8,10), or" 4
.IX Item "d) a cold-ass lil combination of lyrics n' message ranges, separated by commas (i.e. 1,3,5:8,10), or"
.IP "e) a reference ta a array whose elements is like \fIa)\fR all up in \fId)\fR." 4
.IX Item "e) a reference ta a array whose elements is like a) all up in d)."
.PD
.PP
Da \fBRange\fR method returns a Mail::IMAPClient::MessageSet object.
Da object uses overload n' if treated as a strang it will act
like a string.  This means you can ignore its objectivitizzle n' just
treat it like a strang whose value is yo' message set expressed in
compact format.
.PP
This method serves up a easy as fuck  way ta add or remove lyrics from a
message set.
.PP
For mo' shiznit peep Mail::IMAPClient::MessageSet.
.SS "Rfc3501_date"
.IX Subsection "Rfc3501_date"
Example:
.PP
.Vb 3
\&  $Rfc3501_date = $imap\->Rfc3501_date($seconds);
\&  # or:
\&  $Rfc3501_date = Mail::IMAPClient\->Rfc3501_date($seconds);
.Ve
.PP
Da \fBRfc3501_date\fR method accepts one input argument, a number of
secondz since tha epoch date.  It returns a \s-1RFC3501\s0 compliant date
strin fo' dat date (as required up in date-related arguments ta \s-1SEARCH,\s0
like fuckin \*(L"since\*(R", \*(L"before\*(R", etc.).
.SS "Rfc3501_datetime"
.IX Subsection "Rfc3501_datetime"
Example:
.PP
.Vb 3
\&  $date = $imap\->Rfc3501_datetime($seconds);
\&  # or:
\&  $date = Mail::IMAPClient\->Rfc3501_datetime($seconds);
.Ve
.PP
Da \fBRfc3501_datetime\fR method accepts one or two arguments: a
obligatory timestamp n' a optionizzle unit.  Da unit shall be
formatted as \f(CW\*(C`[+\-]\ed{4}\*(C'\fR, n' defaults ta \f(CW+0000\fR.  The
timestamp bigs up tha definizzle of tha output of tha platforms
specific \f(CW\*(C`time\*(C'\fR, probably up in secondz since Jan 1st 1970.  But fuck dat shiznit yo, tha word on tha street is dat you
have ta erect tha number yo ass fo' tha unit.
.SS "Rfc822_date"
.IX Subsection "Rfc822_date"
Example:
.PP
.Vb 3
\&  $Rfc822_date = $imap\->Rfc822_date($seconds);
\&  # or:
\&  $Rfc822_date = Mail::IMAPClient\->Rfc822_date($seconds);
.Ve
.PP
Da \fBRfc822_date\fR method accepts one input argument, a number of
secondz since tha epoch date.  It returns a \s-1RFC822\s0 compliant date
strin fo' dat date (without tha 'Date:' prefix).  Useful fo' putting
dates up in message strings before callin \*(L"append\*(R", \*(L"search\*(R", etc.
.SS "Strip_cr"
.IX Subsection "Strip_cr"
Examples:
.PP
.Vb 7
\&  mah $stripped = $imap\->Strip_cr($string);
\&  # or:
\&  mah @list = $imap\->some_imap_method;
\&  @list = $imap\->Strip_cr(@list);
\&  # or:
\&  mah $list = [ $imap\->some_imap_method ];   # returns a array ref
\&  $list = $imap\->Strip_cr($list);
.Ve
.PP
Da \fBStrip_cr\fR method strips carriage returns from input n' returns
the freshly smoked up strang ta tha calla n' shit.  This method accepts one or mo' lines
of text as arguments, n' returns dem lines wit all <\s-1CR\s0><\s-1LF\s0>
sequences chizzled ta <\s-1LF\s0>.  Any input argument wit no carriage
returns is returned unchanged. Y'all KNOW dat shit, muthafucka!  If tha straight-up original gangsta argument (not counting
the class name or object reference) be a array reference, then
thugz of dat array is processed as above n' subsequent arguments
are ignored. Y'all KNOW dat shit, muthafucka!  If tha method is called up in scalar context then a array
reference is returned instead of a array of thangs up in dis biatch.
.PP
\&\s-1NOTE: \s0\fBStrip_cr\fR do not remove freshly smoked up line characters.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
Object methodz must be invoked against objects pimped via tha \*(L"new\*(R"
method n' cannot be invoked as class methods.
.PP
There object methodz typically fall tha fuck into one of two categories. Put ya muthafuckin choppers up if ya feel dis!  There
are mailbox methodz which participate up in tha \s-1IMAP\s0 session's
conversation (i.e. they issue \s-1IMAP\s0 client commands) n' object control
methodz which do not result up in \s-1IMAP\s0 commandz but which may affect
lata commandz or provide detailz of previous ones.
.PP
This object control methodz can be further fucked up  down tha fuck into two
types, Parameta accessor methods, which affect tha behavior of future
mailbox methods, n' \*(L"Status Methods\*(R", which report on tha affects
of previous mailbox methods.
.PP
Methodz dat do not result up in freshly smoked up \s-1IMAP\s0 client commandz bein issued
(like fuckin tha \*(L"Transaction\*(R", \*(L"Status\*(R", n' \*(L"History\*(R" methods) all
begin wit a uppercase letter, ta distinguish dem from methodz that
do correspond ta \s-1IMAP\s0 client commands.  Class methodz n' eponymous
parameta methodz likewise begin wit a uppercase letta cuz they
also do not correspond ta a \s-1IMAP\s0 client command.
.PP
As a general rule, mailbox control methodz return \f(CW\*(C`undef\*(C'\fR on failure
and suttin' besides \f(CW\*(C`undef\*(C'\fR when they succeed. Y'all KNOW dat shit, muthafucka!  This rule is
modified up in tha case of methodz dat return search thangs up in dis biatch.  When
called up in a list context, searches dat do not find matchin thangs up in dis biatch
return a empty list.  When called up in a scalar context, searches with
no hits return 'undef' instead of a array reference.  If you want to
know why you received no hits, you should check \*(L"LastError\*(R" or
\&\f(CW$@\fR, which is ghon be empty if tha search was successful but had no
matchin thangs up in dis biatch but populated wit a error message if tha search
encountered a problem (like fuckin invalid parameters).
.PP
A number of \s-1IMAP\s0 commandz aint gots correspondin Mail::IMAPClient
methods.  Patches is welcome.  In tha pre\-2.99 releasez of this
module, they was automatically pimped (\s-1AUTOLOAD\s0) yo, but dat was hella
error-prone n' stalled tha progress of dis module.
.SH "Mailbox Control Methods"
.IX Header "Mailbox Control Methods"
.SS "append"
.IX Subsection "append"
Example:
.PP
.Vb 2
\&  mah $uid_or_true = $imap\->append( $folder, $msgtext )
\&    or take a thugged-out dirtnap "Could not append: ", $imap\->LastError;
.Ve
.PP
\&\s-1WARNING:\s0 This method may be deprecated up in tha future, consider using
\&\*(L"append_string\*(R" instead of dis method.
.PP
Da \fBappend\fR method addz a message ta tha specified folda n' shit.  See
\&\*(L"append_string\*(R" fo' details as it is effectively a alias fo' that
method.
.PP
\&\s-1DEPRECATED BEHAVIOR:\s0 Additionizzle arguments is added ta tha message
text, separated wit <\s-1CR\s0><\s-1LF\s0>.
.SS "append_string"
.IX Subsection "append_string"
Example:
.PP
.Vb 3
\&   # brackets indicate optionizzle arguments (not array refs):
\&   mah $uidort = $imap\->append_string( $folder, $msgtext [,$flags [,$date ] ] )
\&       or take a thugged-out dirtnap "Could not append_string: ", $imap\->LastError;
.Ve
.PP
Arguments:
.ie n .IP "$folder" 4
.el .IP "\f(CW$folder\fR" 4
.IX Item "$folder"
the name of tha folda ta append tha message to
.ie n .IP "$msgtext" 4
.el .IP "\f(CW$msgtext\fR" 4
.IX Item "$msgtext"
the message text (includin headers) of tha message
.ie n .IP "$flags" 4
.el .IP "\f(CW$flags\fR" 4
.IX Item "$flags"
An optionizzle list of flags ta set.  Da list must be specified as
a space-separated list of flags, includin any backslashes dat may be
necessary n' optionally enclosed by parenthesis.
.ie n .IP "$date" 4
.el .IP "\f(CW$date\fR" 4
.IX Item "$date"
An optionizzle \s-1RFC3501\s0 date argument ta set as tha internal date.  It
should be up in tha format busted lyrics bout fo' \fIdate_time\fR fieldz up in \s-1RFC3501,\s0
i.e. \*(L"dd-Mon-yyyy hh:mm:ss +0000\*(R".
.Sp
If you wanna specify a thugged-out date/time but you don't want any flags then
specify \fIundef\fR as tha third ($flags) argument.
.PP
Returns:
.IP "error: undef" 4
.IX Item "error: undef"
On error, undef can be returned regardless of \s-1LIST/SCALAR\s0 context.
Peep \*(L"LastError\*(R" fo' details.
.ie n .IP "success: \s-1UID\s0 or $imap" 4
.el .IP "success: \s-1UID\s0 or \f(CW$imap\fR" 4
.IX Item "success: UID or $imap"
With \s-1UIDPLUS\s0 tha \s-1UID\s0 of tha freshly smoked up message is returned otherwise a true
value (currently \f(CW$self\fR) is returned.
.PP
To protect against \*(L"bare newlines\*(R", \fBappend\fR will bang a cold-ass lil carriage
return before any newline dat is \*(L"bare\*(R".
.SS "append_file"
.IX Subsection "append_file"
Example:
.PP
.Vb 5
\&  mah $new_msg_uid = $imap\->append_file(
\&      $folder,
\&      $file,
\&      [ undef, $flags, $date ] # optional
\&  ) or take a thugged-out dirtnap "Could not append_file: ", $imap\->LastError;
.Ve
.PP
Da \fBappend_file\fR method addz a message ta tha specified folder.
Note: Da brackets up in tha example indicate optionizzle arguments; they do
not mean dat tha argument should be a array reference.
.PP
Arguments:
.ie n .IP "$folder" 4
.el .IP "\f(CW$folder\fR" 4
.IX Item "$folder"
the name of tha folda ta append tha message to
.ie n .IP "$file" 4
.el .IP "\f(CW$file\fR" 4
.IX Item "$file"
a filename, filehandle or \s-1SCALAR\s0 reference which holdz an
RFC822\-formatted message
.IP "undef" 4
.IX Item "undef"
a deprecated argument used as a place holda fo' backwards
compatibility
.ie n .IP "$flags" 4
.el .IP "\f(CW$flags\fR" 4
.IX Item "$flags"
Da optionizzle argument is handled tha same as append_string.
.ie n .IP "$date" 4
.el .IP "\f(CW$date\fR" 4
.IX Item "$date"
Da optionizzle argument is handled tha same as append_strin (\s-1RFC3501\s0
date), wit tha exception dat if \f(CW$date\fR is \*(L"1\*(R" (one) then the
modification time (mtime) of tha file is ghon be used.
.PP
Returns:
.IP "error: undef" 4
.IX Item "error: undef"
On error, undef can be returned regardless of \s-1LIST/SCALAR\s0 context.
Peep \*(L"LastError\*(R" fo' details.
.ie n .IP "success: \s-1UID\s0 or $imap" 4
.el .IP "success: \s-1UID\s0 or \f(CW$imap\fR" 4
.IX Item "success: UID or $imap"
With \s-1UIDPLUS\s0 tha \s-1UID\s0 of tha freshly smoked up message is returned otherwise a true
value (currently \f(CW$self\fR) is returned.
.PP
To protect against \*(L"bare newlines\*(R", \fBappend_file\fR will bang a
carriage return before any newline dat is \*(L"bare\*(R".
.PP
Da \fBappend_file\fR method serves up a mechanizzle fo' allowin large
lyrics ta be appended without holdin tha whole file up in memory.
.PP
Version note: In 2.x a optionizzle third argument ta use for
\&\f(CW\*(C`input_record_separator\*(C'\fR was allowed, however dis argument is
ignored/not supported az of 3.x.
.SS "authenticate"
.IX Subsection "authenticate"
Example:
.PP
.Vb 2
\&  $imap\->authenticate( $authentication_mechanism, $coderef )
\&    or take a thugged-out dirtnap "Could not authenticate: ", $imap\->LastError;
.Ve
.PP
This method implements tha \s-1AUTHENTICATE IMAP\s0 client command. Y'all KNOW dat shit, muthafucka!  It can
be called directly or may be called by \*(L"login\*(R" if the
\&\*(L"Authmechanism\*(R" parameta is set ta anythang except '\s-1LOGIN\s0'.
.PP
Da \fBauthenticate\fR method accepts two arguments, a authentication
type ta be used (ie \s-1CRAM\-MD5\s0) n' a cold-ass lil code or subroutine reference to
execute ta obtain a response.  Da \fBauthenticate\fR method assumes that
the authentication type specified up in tha straight-up original gangsta argument bigs up a
challenge-response flow.  Da \fBauthenticate\fR method thangs tha \s-1IMAP\s0
Client \s-1AUTHENTICATE\s0 command n' receives a cold-ass lil challenge from tha server.
That challenge (minus any tag prefix or enclosin '+' charactas but
still up in tha original gangsta base64 encoding) is passed as tha only argument
to tha code or subroutine referenced up in tha second argument.  The
return value from tha 2nd argumentz code is freestyled ta tha server as
is, except dat a <\s-1CR\s0><\s-1LF\s0> sequence be appended if necessary.
.PP
If one or both of tha arguments is not specified up in tha call to
\&\fBauthenticate\fR but they correspondin parametas done been set
(\*(L"Authmechanism\*(R" n' \*(L"Authcallback\*(R", respectively) then tha parameter
values is used. Y'all KNOW dat shit, muthafucka! Arguments provided ta tha method call however will
override parameta settings.
.PP
If you do not specify a second argument n' you aint set the
\&\*(L"Authcallback\*(R" parameter, then tha straight-up original gangsta argument must be
one of tha authentication mechanizzlez fo' which Mail::IMAPClient
has built up in support.
.PP
See also tha \*(L"login\*(R" method, which is tha simplest form of
authentication defined by \s-1RFC3501.\s0
.SS "before"
.IX Subsection "before"
Example:
.PP
.Vb 2
\&  mah @msgs = $imap\->before($Rfc3501_date)
\&    or warn "No lyrics found before $Rfc3501_date.\en";
.Ve
.PP
Da \fBbefore\fR method works just like tha \*(L"since\*(R" method, below,
except it returns a list of lyrics whose internal system dates are
before tha date supplied as tha argument ta tha \fBbefore\fR method.
.SS "body_string"
.IX Subsection "body_string"
Example:
.PP
.Vb 2
\&  mah $strin = $imap\->body_string($msgId)
\&    or take a thugged-out dirtnap "Could not body_string: ", $imap\->LastError;
.Ve
.PP
Da \fBbody_string\fR method accepts a message sequence number (or a
message \s-1UID,\s0 if tha \*(L"Uid\*(R" parameta is set ta true) as a argument
and returns tha message body as a string.  Da returned value gotz nuff
the entire message up in one scalar variable, without tha message
headers.
.SS "bodypart_string"
.IX Subsection "bodypart_string"
Example:
.PP
.Vb 3
\&  mah $strin = $imap\->bodypart_string(
\&      $msgid, $part_number, $length, $offset
\&  ) or take a thugged-out dirtnap "Could not git bodypart string: ", $imap\->LastError;
.Ve
.PP
Da \fBbodypart_string\fR method accepts a message sequence number (or a
message \s-1UID,\s0 if tha \*(L"Uid\*(R" parameta is set ta true) n' a funky-ass body part
as arguments n' returns tha message part as a string.  Da returned
value gotz nuff tha entire message part (or, optionally, a portion of
the part) up in one scalar variable.
.PP
If a optionizzle third argument is provided, dat argument is tha number
of bytes ta fetch.  (Da default is tha whole message part.)  If an
optionizzle fourth argument is provided then dat fourth argument is the
offset tha fuck into tha part at which tha fetch should begin. I aint talkin' bout chicken n' gravy biatch.  Da default is
offset zero, or tha beginnin of tha message part.
.PP
If you specify a offset without specifyin a length then tha offset
will be ignored n' tha entire part is ghon be returned.
.PP
\&\fBbodypart_string\fR will return \f(CW\*(C`undef\*(C'\fR if it encountas a error.
.SS "capability"
.IX Subsection "capability"
Example:
.PP
.Vb 2
\&  mah $features = $imap\->capability
\&    or take a thugged-out dirtnap "Could not determine capability: ", $imap\->LastError;
.Ve
.PP
Da \fBcapability\fR method returns a array of capabilitizzles as returned
by tha \s-1CAPABILITY IMAP\s0 Client command, or a reference ta a array of
capabilitizzles if called up in scalar context.  If tha \s-1CAPABILITY IMAP\s0
Client command fails fo' any reason then tha \fBcapability\fR method will
return \f(CW\*(C`undef\*(C'\fR.  Supported capabilitizzles is cached by tha client,
however, dis cache is deleted afta a cold-ass lil connection is set to
\&\fIAuthenticated\fR n' when \*(L"starttls\*(R" is called.
.PP
See also \*(L"has_capability\*(R".
.SS "close"
.IX Subsection "close"
Example:
.PP
.Vb 1
\&  $imap\->close or take a thugged-out dirtnap "Could not close: $@\en";
.Ve
.PP
Da \fBclose\fR method is used ta close tha currently selected folda via
the \s-1CLOSE IMAP\s0 client command. Y'all KNOW dat shit, muthafucka!  Accordin ta \s-1RFC3501,\s0 tha \s-1CLOSE\s0
command performs a implicit \s-1EXPUNGE,\s0 which means dat any lyrics
that is flagged as \fI\eDeleted\fR (i.e. wit tha \*(L"delete_message\*(R"
method) will now be deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If you aint deleted any lyrics then
\&\fBclose\fR can be thought of as a \*(L"unselect\*(R".
.PP
Note: dis closes tha currently selected folder, not tha \s-1IMAP\s0 session.
.PP
See also \*(L"delete_message\*(R", \*(L"expunge\*(R", n' \s-1RFC3501.\s0
.SS "compress"
.IX Subsection "compress"
Example:
.PP
.Vb 1
\&  $imap\->compress or take a thugged-out dirtnap "Could not enable RFC4978 compression: $@\en";
.Ve
.PP
Da \fBcompress\fR method accepts no arguments, n' you can put dat on yo' toast.  This method is used to
instruct tha server ta use tha \s-1DEFLATE \s0(\s-1RFC1951\s0) compression
extension. I aint talkin' bout chicken n' gravy biatch.  See tha \*(L"Compress\*(R" attribute fo' how tha fuck ta specify
arguments fo' use durin tha initialization process.
.PP
Version note: method added up in Mail::IMAPClient 3.30
.SS "connect"
.IX Subsection "connect"
Example:
.PP
.Vb 1
\&  $imap\->connect or take a thugged-out dirtnap "Could not connect: $@\en";
.Ve
.PP
Da \fBconnect\fR method connects a imap object ta tha server n' shit.  It
returns \f(CW\*(C`undef\*(C'\fR if it fails ta connect fo' any reason. I aint talkin' bout chicken n' gravy biatch.  If joints are
available fo' tha \*(L"User\*(R" n' \*(L"Password\*(R" parametas all up in tha time
that \fBconnect\fR is invoked, then \fBconnect\fR will call tha \*(L"login\*(R"
method afta connectin n' return tha result of tha \*(L"login\*(R" method
to \fBconnect\fRz calla n' shit.  If either or both of tha \*(L"User\*(R" and
\&\*(L"Password\*(R" parametas is unavailable but tha connection ta the
server succeedz then \fBconnect\fR returns a pointa ta tha IMAPClient
object.
.PP
Da \*(L"Server\*(R" parameta must be set (either durin \*(L"new\*(R" method
invocation or via tha \*(L"Server\*(R" object method) before invoking
\&\fBconnect\fR.  When tha parameta be a absolute file path, a \s-1UNIX\s0
socket will git opened. Y'all KNOW dat shit, muthafucka!  If tha \*(L"Server\*(R" parameta is supplied to
the \*(L"new\*(R" method then \fBconnect\fR is implicitly called durin object
construction.
.PP
Da \fBconnect\fR method sets tha state of tha object ta \f(CW\*(C`Connected\*(C'\fR if
it successfully connects ta tha server n' shit.  It returns \f(CW\*(C`undef\*(C'\fR on
failure.
.SS "copy"
.IX Subsection "copy"
Example:
.PP
.Vb 3
\&  # Here brackets indicate optionizzle arguments:
\&  mah $uidList = $imap\->copy($folder, $msg_1 [ , ... , $msg_n ])
\&    or take a thugged-out dirtnap "Could not copy: $@\en";
.Ve
.PP
Or:
.PP
.Vb 3
\&  # Now brackets indicate a array ref!
\&  mah $uidList = $imap\->copy($folder, [ $msg_1, ... , $msg_n ])
\&    or take a thugged-out dirtnap "Could not copy: $@\en";
.Ve
.PP
Da \fBcopy\fR method requires a gangbangin' folda name as tha straight-up original gangsta argument, n' a
list of one or mo' lyrics sequence numbers (or lyrics \s-1UID\s0's, if
the \fI\s-1UID\s0\fR parameta is set ta a legit value).  Da message sequence
numbers or \s-1UID\s0z should refer ta lyrics up in tha currently selected
folda n' shit.  Those lyrics is ghon be copied tha fuck into tha folda named up in the
first argument.
.PP
Da \fBcopy\fR method returns \f(CW\*(C`undef\*(C'\fR on failure n' a legit value if
successful naaahhmean, biatch?  If tha server ta which tha current Mail::IMAPClient
object is connected supports tha \s-1UIDPLUS\s0 capabilitizzle then tha true
value returned by \fBcopy\fR is ghon be a cold-ass lil comma separated list of \s-1UID\s0's,
which is tha \s-1UID\s0z of tha newly copied lyrics up in tha target folder.
.SS "create"
.IX Subsection "create"
Example:
.PP
.Vb 2
\&  $imap\->create($new_folder)
\&    or take a thugged-out dirtnap "Could not create $new_folder: $@\en";
.Ve
.PP
Da \fBcreate\fR method accepts one argument, tha name of a gangbangin' folda (or
what \s-1RFC3501\s0 calls a \*(L"mailbox\*(R") ta create.  If you specify additional
arguments ta tha \fBcreate\fR method n' yo' server allows additional
arguments ta tha \s-1CREATE IMAP\s0 client command then tha extra argument(s)
will be passed ta yo' server.
.PP
If you specify additionizzle arguments ta tha \fBcreate\fR method n' your
server do not allow additionizzle arguments ta tha \s-1CREATE IMAP\s0 client
command then tha extra argument(s) will still be passed ta yo' server
and tha create will fail.
.PP
\&\fBcreate\fR returns a legit value on success n' \f(CW\*(C`undef\*(C'\fR on failure.
.SS "date"
.IX Subsection "date"
Example:
.PP
.Vb 1
\&  mah $date = $imap\->date($msg);
.Ve
.PP
Da \fBdate\fR method accepts one argument, a message sequence number (or
a message \s-1UID\s0 if tha \*(L"Uid\*(R" parameta is set ta a legit value).  It
returns tha date of message as specified up in tha messagez \s-1RFC822
\&\s0\*(L"Date: \*(R" header, without tha \*(L"Date: \*(R" prefix.
.PP
Da \fBdate\fR method be a gangbangin' finger-lickin' dirty-ass short-cut for:
.PP
.Vb 1
\&  mah $date = $imap\->get_header($msg,"Date");
.Ve
.SS "delete"
.IX Subsection "delete"
Example:
.PP
.Vb 1
\&  $imap\->delete($folder) or take a thugged-out dirtnap "Could not delete $folder: $@\en";
.Ve
.PP
Da \fBdelete\fR method accepts a single argument, tha name of a gangbangin' folder
to delete.  It returns a legit value on success n' \f(CW\*(C`undef\*(C'\fR on
failure.
.SS "deleteacl"
.IX Subsection "deleteacl"
Example:
.PP
.Vb 2
\&  $imap\->deleteacl( $folder, $userid )
\&    or take a thugged-out dirtnap "Could not delete acl: $@\en";
.Ve
.PP
Da \fBdeleteacl\fR method accepts two input arguments, a gangbangin' folda name, a
user id (or authentication identifier, ta use tha terminologizzle of
\&\s-1RFC2086\s0).  See \s-1RFC2086\s0 fo' mo' shiznit. I aint talkin' bout chicken n' gravy biatch.  (This is somewhat
experimenstrual n' its implementation may chizzle.)
.SS "delete_message"
.IX Subsection "delete_message"
Example:
.PP
.Vb 3
\&  mah @msgs = $imap\->seen;
\&  scalar(@msgs) n' $imap\->delete_message(\e@msgs)
\&    or take a thugged-out dirtnap "Could not delete_message: $@\en";
.Ve
.PP
Da above could also be rewritten like this:
.PP
.Vb 2
\&  # scalar context returns array ref
\&  mah $msgs = scalar($imap\->seen);
\&
\&  scalar(@$msgs) n' $imap\->delete_message($msgs)
\&    or take a thugged-out dirtnap "Could not delete_message: $@\en";
.Ve
.PP
Or, as a one-liner:
.PP
.Vb 4
\&  $imap\->delete_message( scalar($imap\->seen) )
\&    or warn "Could not delete_message: $@\en";
\&  # just give warnin up in case failure is
\&  # cuz of havin no \*(Aqseen\*(Aq msgs up in tha 1st place!
.Ve
.PP
Da \fBdelete_message\fR method accepts a list of arguments, n' you can put dat on yo' toast.  If the
\&\*(L"Uid\*(R" parameta aint set ta a legit value, then each item up in the
list should be either:
.IP "\(bu" 4
a message sequence number,
.IP "\(bu" 4
a comma-separated list of message sequence numbers,
.IP "\(bu" 4
a reference ta a array of message sequence numbers, or
.PP
If tha \*(L"Uid\*(R" parameta is set ta a legit value, then each item up in the
list should be either:
.IP "\(bu" 4
a message \s-1UID,\s0
.IP "\(bu" 4
a comma-separated list of \s-1UID\s0's, or
.IP "\(bu" 4
a reference ta a array of message \s-1UID\s0's.
.PP
Da lyrics identified by tha sequence numbers or \s-1UID\s0z will be
deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If successful, \fBdelete_message\fR returns tha number of
lyrics dat shiznit was holla'd at ta delete.  But fuck dat shiznit yo, tha word on tha street is dat since tha delete is done by
issuin tha \fI+FLAGS.SILENT\fR option of tha \s-1STORE IMAP\s0 client command,
there is no guarantee dat tha delete was successful fo' every
message.  In dis manner tha \fBdelete_message\fR method sacrifices
accuracy fo' speed. Y'all KNOW dat shit, muthafucka!  Generally, though, if a single message up in a list
of lyrics fails ta be deleted itz cuz dat shiznit was already deleted,
which is what tha fuck you wanted anyway so why worry bout it, biatch? If there be a
more severe error, i.e. tha server replies \*(L"\s-1NO\*(R", \*(L"BAD\*(R",\s0 or, banish the
thought, \*(L"\s-1BYE\*(R",\s0 then \fBdelete_message\fR will return \f(CW\*(C`undef\*(C'\fR.
.PP
If you must have guaranteed thangs up in dis biatch then use tha \s-1IMAP STORE\s0 client
command (via tha default method) n' use tha +FLAGS (\eDeleted) option,
and then parse yo' thangs up in dis biatch manually.
.PP
Eg:
.PP
.Vb 3
\&  $imap\->store( $msg_id, \*(Aq+FLAGS (\eDeleted)\*(Aq );
\&  mah @results = $imap\->History( $imap\->Transaction );
\&    ...           # code ta parse output goes here
.Ve
.PP
(Frankly I peep no reason ta bother wit any of that; if a message
doesn't git deleted itz almost always cuz itz already not there,
which is what tha fuck you want anyway.  But 'your mileage may vary' n' all
that.)
.PP
Da IMAPClient object must be up in \f(CW\*(C`Selected\*(C'\fR status ta use the
\&\fBdelete_message\fR method.
.PP
\&\fB\s-1NOTE\s0\fR: All tha lyrics identified up in tha input argument(s) must be in
the currently selected folda n' shit.  Failure ta comply wit this
requirement will almost certainly result up in tha wack message(s) being
deleted.
.PP
\&\fB\s-1ADDITIONAL NOTE\s0\fR: In tha grand tradizzle of tha \s-1IMAP\s0 protocol,
deletin a message don't straight-up delete tha message.  Really.  If
you wanna make shizzle tha message has been deleted, you need to
expunge tha folda (via tha \*(L"expunge\*(R" method, which is implemented
via tha default method).  Or at least \*(L"close\*(R" dat shit.  This is generally
considered a gangbangin' feature, since afta deletin a message, you can chizzle
your mind n' undelete it at any time before yo' \*(L"expunge\*(R" or
\&\*(L"close\*(R".
.PP
See also: tha \*(L"delete\*(R" method, ta delete a gangbangin' folder, tha \*(L"expunge\*(R"
method, ta expunge a gangbangin' folder, tha \*(L"restore_message\*(R" method to
undelete a message, n' tha \*(L"close\*(R" method (implemented here via the
default method) ta close a gangbangin' folda n' shit.  Oh, n' don't forget bout \s-1RFC3501.\s0
.SS "deny_seeing"
.IX Subsection "deny_seeing"
Example:
.PP
.Vb 4
\&  # Reset all read msgs ta unread
\&  # (produces error if there be no peeped msgs):
\&  $imap\->deny_seeing( scalar($imap\->seen) )
\&    or take a thugged-out dirtnap "Could not deny_seeing: $@\en";
.Ve
.PP
Da \fBdeny_seeing\fR method accepts a list of one or mo' message
sequence numbers, or a single reference ta a array of one or more
message sequence numbers, as its argument(s).  It then unsets the
\&\*(L"\eSeen\*(R" flag fo' dem lyrics (so dat you can \*(L"deny\*(R" dat you ever
saw them).  Of course, if tha \*(L"Uid\*(R" parameta is set ta a legit value
then dem message sequence numbers should be unique message id's.
.PP
Note dat specifyin \f(CW\*(C`$imap\->deny_seeing(@msgs)\*(C'\fR is just a
shortcut fo' specifyin \f(CW\*(C`$imap\->unset_flag("Seen",@msgs)\*(C'\fR.
.SS "disconnect"
.IX Subsection "disconnect"
Example:
.PP
.Vb 1
\&  $imap\->disconnect or warn "Could not logout: $@\en";
.Ve
.PP
This method calls \*(L"logout\*(R", peep \*(L"logout\*(R" fo' details.
.SS "done"
.IX Subsection "done"
Example:
.PP
.Vb 5
\&  mah $tag = $imap\->idle or warn "idle failed: $@\en";
\&  doSomethingA();
\&  mah $idlemsgs = $imap\->idle_data() or warn "idle_data error: $@\en";
\&  doSomethingB();
\&  mah $results = $imap\->done($tag) or warn "Error from done: $@\en";
.Ve
.PP
Da \fBdone\fR method  drops some lyrics ta tha \s-1IMAP\s0 server ta terminizzle tha \s-1IDLE\s0
command. Y'all KNOW dat shit, muthafucka!  Da only argument is tha \fItag\fR (identifier) received from
the previous call ta \*(L"idle\*(R".  If \fItag\fR aint specified a thugged-out default
\&\fItag\fR based on tha \fBCount\fR attribute be assumed ta be tha \fItag\fR to
look fo' up in tha response from tha server.
.PP
If a invalid \fItag\fR is specified, or tha default \fItag\fR is wrong,
then \fBdone\fR will hang indefinitely or until a timeout occurs.
.PP
If \fBdone\fR is called when a \*(L"idle\*(R" command aint actizzle then the
server will likely respond wit a error like \fI* \s-1BAD\s0 Invalid tag\fR.
.PP
On failure <undef> is returned n' \*(L"LastError\*(R" is set.
.PP
See also \*(L"idle\*(R", \*(L"idle_data\*(R" n' \*(L"Results\*(R".
.SS "examine"
.IX Subsection "examine"
Example:
.PP
.Vb 1
\&  $imap\->examine($folder) or take a thugged-out dirtnap "Could not examine: $@\en";
.Ve
.PP
Da \fBexamine\fR method selects a gangbangin' folda up in read-only mode n' chizzles
the objectz state ta \*(L"Selected\*(R".  Da folda selected via the
\&\fBexamine\fR method can be examined but no chizzlez can be made unless it
is first selected via tha \*(L"select\*(R" method.
.PP
Da \fBexamine\fR method accepts one argument, which is tha name of the
folda ta select.
.SS "exists"
.IX Subsection "exists"
Example:
.PP
.Vb 1
\&  $imap\->exists($folder) or warn "$folda not found: $@\en";
.Ve
.PP
Accepts one argument, a gangbangin' folda name.  Returns legit if tha folder
exists or false if it do not exist.
.SS "expunge"
.IX Subsection "expunge"
Example:
.PP
.Vb 1
\&  $imap\->expunge($folder) or take a thugged-out dirtnap "Could not expunge: $@\en";
.Ve
.PP
Da \fBexpunge\fR method accepts one optionizzle argument, a gangbangin' folda name.
It expunges tha folda specified as tha argument, or tha currently
selected folda (if any) when no argument is supplied.
.PP
Although \s-1RFC3501\s0 do not permit optionizzle arguments (like a gangbangin' folder
name) ta tha \s-1EXPUNGE\s0 client command, tha \*(L"expunge\*(R" method do.
Note: expungin a gangbangin' folda deletes tha lyrics dat have tha \eDeleted
flag set (i.e. lyrics flagged via \*(L"delete_message\*(R").
.PP
See also tha \*(L"close\*(R" method, which \*(L"deselects\*(R" as well as expunges.
.SS "fetch"
.IX Subsection "fetch"
Usage:
.PP
.Vb 1
\&  $imap\->fetch( [$seq_set|ALL], @msg_data_items )
.Ve
.PP
Example:
.PP
.Vb 1
\&  mah $output = $imap\->fetch(@args) or take a thugged-out dirtnap "Could not fetch: $@\en";
.Ve
.PP
Da \fBfetch\fR method implements tha \s-1FETCH IMAP\s0 client command. Y'all KNOW dat shit, muthafucka!  It
accepts a list of arguments, which is ghon be converted tha fuck into a
space-delimited list of arguments ta tha \s-1FETCH IMAP\s0 client command.
If no arguments is supplied then \fBfetch\fR do a \s-1FETCH ALL. \s0 If the
\&\*(L"Uid\*(R" parameta is set ta a legit value then tha straight-up original gangsta argument will
be treated as a \s-1UID\s0 or list of \s-1UID\s0's, which means dat tha \s-1UID FETCH
IMAP\s0 client command is ghon be run instead of \s-1FETCH.  \s0(It would straight-up be
a phat scam at dis point ta review \s-1RFC3501.\s0)
.PP
If called up in array context, \fBfetch\fR will return a array of output
lines.  Da output lines is ghon be returned just as they was received
from tha server, so yo' script will gotta be prepared ta parse out
the bits you want.  Da only exception ta dis is literal strings,
which is ghon be banged tha fuck into tha output line all up in tha point at which they
were encountered (without tha {nnn} literal field indicator).  See
\&\s-1RFC3501\s0 fo' a thugged-out description of literal fields.
.PP
If \fBfetch\fR is called up in a scalar context, then a reference ta a array
(as busted lyrics bout above) is returned instead of tha entire array.
.PP
\&\fBfetch\fR returns \f(CW\*(C`undef\*(C'\fR on failure.  Inspect \*(L"LastError\*(R" or \f(CW$@\fR
for a explanation of yo' error.
.SS "fetch_hash"
.IX Subsection "fetch_hash"
Usage:
.PP
.Vb 1
\&  $imap\->fetch_hash( [$seq_set|ALL], @msg_data_items, [\e%msg_by_ids] )
.Ve
.PP
Example:
.PP
.Vb 3
\&  mah $hashref = {};
\&  $imap\->fetch_hash( "RFC822.SIZE", $hashref );
\&  print "Msg #$m is $hashref\->{$m} bytes\en" foreach mah $m (keys %$hashref);
.Ve
.PP
Da \fBfetch_hash\fR method accepts a list of message attributes ta be
fetched (as busted lyrics bout up in \s-1RFC3501\s0).  It returns a hash whose keys are
all tha lyrics up in tha currently selected folda n' whose joints are
key-value pairz of fetch keywordz n' tha messagez value fo' that
keyword (see sample output below).
.PP
If \fBfetch_hash\fR is called up in scalar context, it returns a reference
to tha hash instead of tha hash itself.  If tha last argument be a hash
reference, then dat hash reference is ghon be used as tha place where
results is stored (and dat reference is ghon be returned upon
successful completion).  If tha last argument aint a reference then
it is ghon be treated as one of tha \s-1FETCH\s0 attributes n' a freshly smoked up hash will
be pimped n' returned (either by value or by reference, dependin on
the context up in which \fBfetch_hash\fR was called).
.PP
For example, if you gotz a gangbangin' folda wit 3 lyrics n' want tha size
and internal date fo' each of them, you could do tha following:
.PP
.Vb 10
\&  use Mail::IMAPClient;
\&  use Data::Dumper;
\&  # ... other code goes here
\&  $imap\->select($folder);
\&  mah $hash = $imap\->fetch_hash("RFC822.SIZE","INTERNALDATE");
\&  # (Same as:
\&  #  mah $hash = $imap\->fetch_hash("RFC822.SIZE");
\&  #  $imap\->fetch_hash("INTERNALDATE",$hash);
\&  # ).
\&  print Data::Dumper\->Dumpxs([$hash],[\*(Aq$hash\*(Aq]);
.Ve
.PP
This would result up in Data::Dumper output similar ta tha following:
.PP
.Vb 10
\&   $hash = {
\&       \*(Aq1\*(Aq => {
\&                  \*(AqINTERNALDATE\*(Aq => \*(Aq21\-Sep\-2002 18:21:56 +0000\*(Aq,
\&                  \*(AqRFC822.SIZE\*(Aq => \*(Aq1586\*(Aq,
\&              },
\&       \*(Aq2\*(Aq => {
\&                  \*(AqINTERNALDATE\*(Aq => \*(Aq22\-Sep\-2002 11:29:42 +0000\*(Aq,
\&                  \*(AqRFC822.SIZE\*(Aq => \*(Aq1945\*(Aq,
\&              },
\&       \*(Aq3\*(Aq => {
\&                  \*(AqINTERNALDATE\*(Aq => \*(Aq23\-Sep\-2002 09:16:51 +0000\*(Aq,
\&                  \*(AqRFC822.SIZE\*(Aq => \*(Aq134314\*(Aq,
\&              }
\&     };
.Ve
.PP
By itself dis method may be useful fo' tasks like obtainin tha size
of every last muthafuckin message up in a gangbangin' folda n' shit.  It thangs one command n' receives one
(possibly long!) response from tha server.
.PP
If tha fetch request causes tha server ta return data up in a
parenthesized list, tha data within tha parenthesized list may be
escaped via tha \fIEscape()\fR method. Y'all KNOW dat shit, muthafucka! Use tha \fIUnescape()\fR method ta git the
raw joints back up in dis case.
.SS "flags"
.IX Subsection "flags"
Example:
.PP
.Vb 2
\&  mah @flags = $imap\->flags($msgid)
\&    or take a thugged-out dirtnap "Could not flags: $@\en";
.Ve
.PP
Da \fBflags\fR method implements tha \s-1FETCH IMAP\s0 client command ta list a
single messagez flags.  It accepts one argument, a message sequence
number (or a message \s-1UID,\s0 if tha \*(L"Uid\*(R" parameta is true), and
returns a array (or a reference ta a array, if called up in scalar
context) listin tha flags dat done been set.  Flag names are
provided wit leadin backslashes.
.PP
Az of version 1.11, you can supply either a list of message idz or a
reference ta a array of message idz (which means either sequence
number, if tha Uid parameta is false, or message \s-1UID\s0's, if tha Uid
parameta is true) instead of supplyin a single message sequence
number or \s-1UID. \s0 If you do, then tha return value aint gonna be a array
or array reference; instead, it is ghon be a hash reference, wit each
key bein a message sequence number (or \s-1UID\s0) n' each value bein a
reference ta a array of flags set fo' dat message.
.PP
For example, if you wanna display tha flags fo' every last muthafuckin message up in the
folda where you store e\-mail related ta yo' plans fo' ghetto
domination, you could do suttin' like this:
.PP
.Vb 7
\&  use Mail::IMAPClient;
\&  mah $imap = Mail::IMAPClient\->new(
\&      Server   => $imaphost,
\&      User     => $login,
\&      Password => $pass,
\&      Uid      => 1,        # optional
\&  );
\&
\&  $imap\->select("Ghetto Domination");
\&  # git tha flags fo' every last muthafuckin message up in mah \*(AqGhetto Domination\*(Aq folder
\&  $flaghash = $imap\->flags( scalar( $imap\->search("ALL") ) );
\&
\&  # pump all up in sorted hash keys ta print thangs up in dis biatch:
\&  fo' mah $k (sort { $flaghash\->{$a} <=> $flaghash\->{$b} } keys %$flaghash) {
\&      # print: Message 1: \eFlag1, \eFlag2, \eFlag3
\&      print "Message $k:\et",join(", ",@{$flaghash\->{$k}}),"\en";
\&  }
.Ve
.SS "folders"
.IX Subsection "folders"
Example:
.PP
.Vb 1
\&  $imap\->foldaz or take a thugged-out dirtnap "Could not list folders: $@\en";
.Ve
.PP
Da \fBfolders\fR method returns a array listin tha available folders.
It will only be successful if tha object is up in tha \fIAuthenticated\fR or
\&\fISelected\fR states.
.PP
Da \fBfolders\fR method accepts one optionizzle argument, which be a
prefix.  If a prefix is supplied ta tha \fBfolders\fR method, then only
foldaz beginnin wit tha prefix is ghon be returned.
.PP
For example:
.PP
.Vb 9
\&  print join(", ",$imap\->folders),".\en";
\&  # Prints:
\&  # INBOX, Sent, Projects, Projects/Completed, Projects/Ongoing, Projects Software.
\&  print join(", ",$imap\->folders("Projects"),".\en";
\&  # Prints:
\&  # Projects, Projects/Completed, Projects/Ongoing, Projects Software.
\&  print join(", ",$imap\->folders("Projects" . $imap\->separator),".\en";
\&  # Prints:
\&  # Projects/Completed, Projects/Ongoing
.Ve
.PP
Please note dat documentation previously suggested dat if you just
wanna list a gangbangin' folderz subfoldaz (and not tha folda itself), then
you need ta include tha hierarchy separator characta (as returned by
the \*(L"separator\*(R" method). But fuck dat shiznit yo, tha word on tha street is dat dis do not match tha behavior
of tha existin implementation, so yo big-ass booty is ghon need ta manually exclude
the parent folda from tha thangs up in dis biatch.
.SS "folders_hash"
.IX Subsection "folders_hash"
.Vb 2
\&  mah @fhashes = $imap\->folders_hash
\&    or take a thugged-out dirtnap "Could not git list of folda hashes.\en";
.Ve
.PP
Da \fBfolders_hash\fR method accepts one optionizzle argument, which be a
prefix.  If a prefix is supplied ta tha \fBfolders_hash\fR method, then
only foldaz beginnin wit tha prefix is ghon be returned.
.PP
An array(ref) of hashes is returned dat contain shiznit bout the
axed folders.  Each hash gotz nuff three keys (name, attrs, delim)
and be lookin like tha following:
.PP
.Vb 5
\&  {
\&    name  => \*(AqMail/Box/Name\*(Aq,
\&    attrs => \*(Aq\eMarked \eHasNoChildren\*(Aq,
\&    delim => \*(Aq/\*(Aq,
\&  }
.Ve
.PP
\&\s-1IMAP\s0 servers implementin \s-1RFC6154\s0 return attributes ta be used to
identify special-use mailboxes (folders).
.PP
.Vb 5
\&  mah $sattr_re = /\eb\e\e(?:All|Archive|Drafts|Flagged|Junk|Sent|Trash)\eb/;
\&  foreach mah $fhash (@fhashes) {
\&      next unless ( $fhash\->{attrs} =~ $sattr_re );
\&      print("special: $fhash\->{name} : $fhash\->{attrs}\en");
\&  }
.Ve
.PP
Version note: method added up in Mail::IMAPClient 3.34
.SS "xlist_foldaz (\s-1DEPRECATED\s0)"
.IX Subsection "xlist_foldaz (DEPRECATED)"
This method is deprecated az of version 3.34.  Please use folders_hash
instead. Y'all KNOW dat shit, muthafucka!  See \s-1RFC6154\s0 fo' attributes ta be used ta identify
special-use mailboxes (folders).
.PP
Example:
.PP
.Vb 2
\&  mah $xlist = $imap\->xlist_folders
\&    or take a thugged-out dirtnap "Could not git xlist folders.\en";
.Ve
.PP
\&\s-1IMAP\s0 servers implementin tha \s-1XLIST\s0 extension (like fuckin Gmail)
designate particular foldaz ta be used fo' particular functions.
This is useful up in tha case where you wanna know which folda should
be used fo' Trash when tha actual folda name can't be predicted
(e.g. up in tha case of Gmail, tha folda names chizzle dependin on the
userz locale settings).
.PP
Da \fBxlist_folders\fR method returns a hash listin any \*(L"xlist\*(R" folder
names, wit tha joints listin tha actual foldaz dat should be used
for dem names.  For example, rockin dis method wit a Gmail user
usin tha Gangsta (\s-1US\s0) locale might give dis output from
Data::Dumper:
.PP
.Vb 9
\&  $VAR1 = {
\&      \*(AqInbox\*(Aq   => \*(AqInbox\*(Aq,
\&      \*(AqAllMail\*(Aq => \*(Aq[Gmail]/All Mail\*(Aq,
\&      \*(AqTrash\*(Aq   => \*(Aq[Gmail]/Trash\*(Aq,
\&      \*(AqDrafts\*(Aq  => \*(Aq[Gmail]/Drafts\*(Aq,
\&      \*(AqSent\*(Aq    => \*(Aq[Gmail]/Sent Mail\*(Aq,
\&      \*(AqSpam\*(Aq    => \*(Aq[Gmail]/Spam\*(Aq,
\&      \*(AqStarred\*(Aq => \*(Aq[Gmail]/Starred\*(Aq
\&  };
.Ve
.PP
Da same list fo' a user rockin tha French locale might be lookin like this:
.PP
.Vb 9
\&  $VAR1 = {
\&      \*(AqInbox\*(Aq   => \*(AqBo&AO4\-te de r&AOk\-ception\*(Aq,
\&      \*(AqAllMail\*(Aq => \*(Aq[Gmail]/Tous lez lyrics\*(Aq,
\&      \*(AqTrash\*(Aq   => \*(Aq[Gmail]/Corbeille\*(Aq,
\&      \*(AqDrafts\*(Aq  => \*(Aq[Gmail]/Brouillons\*(Aq,
\&      \*(AqSent\*(Aq    => \*(Aq[Gmail]/Lyrics envoy&AOk\-s\*(Aq,
\&      \*(AqSpam\*(Aq    => \*(Aq[Gmail]/Spam\*(Aq,
\&      \*(AqStarred\*(Aq => \*(Aq[Gmail]/Suivis\*(Aq
\&  };
.Ve
.PP
Mail::IMAPClient recognizes tha followin \*(L"xlist\*(R" folda names:
.IP "Inbox" 4
.IX Item "Inbox"
.PD 0
.IP "AllMail" 4
.IX Item "AllMail"
.IP "Trash" 4
.IX Item "Trash"
.IP "Drafts" 4
.IX Item "Drafts"
.IP "Sent" 4
.IX Item "Sent"
.IP "Spam" 4
.IX Item "Spam"
.IP "Starred" 4
.IX Item "Starred"
.PD
.PP
These is currently tha only ones supported by Gmail.  Da \s-1XLIST\s0
extension aint documented, n' there be no other known
implementations other than Gmail, so dis list is based on what tha fuck Gmail
provides.
.PP
If tha server do not support tha \s-1XLIST\s0 extension, dis method
returns undef.
.PP
Version note: method added up in Mail::IMAPClient 3.21
.SS "has_capability"
.IX Subsection "has_capability"
Example:
.PP
.Vb 2
\&  mah $has_feature = $imap\->has_capability($feature)
\&    or take a thugged-out dirtnap "Could not do has_capability($feature): $@\en";
.Ve
.PP
Returns legit if tha \s-1IMAP\s0 server ta which tha IMAPClient object is
connected has tha capabilitizzle specified as a argument to
\&\fBhas_capability\fR.  If tha server aint gots tha capabilitizzle then
the empty strang "" is returned, if tha underlyin \*(L"capability\*(R"
calls fails then undef is returned.
.SS "idle"
.IX Subsection "idle"
Example:
.PP
.Vb 5
\&  mah $tag = $imap\->idle or warn "idle failed: $@\en";
\&  doSomethingA();
\&  mah $idlemsgs = $imap\->idle_data() or warn "idle_data error: $@\en";
\&  doSomethingB();
\&  mah $results = $imap\->done($tag) or warn "Error from done: $@\en";
.Ve
.PP
Da \fBidle\fR method  drops some lyrics ta tha \s-1IMAP\s0 server tha client is locked n loaded ta accept
unsolicited mailbox update lyrics.  This method is only valid on
servers dat support tha \s-1IMAP IDLE\s0 extension, peep \s-1RFC2177\s0 fo' details.
.PP
Da \fBidle\fR method accepts no arguments n' returns tha \fItag\fR
(identifier) dat was busted by tha client fo' dis command. Y'all KNOW dat shit, muthafucka!  This tag
should be supplied as tha argument ta \*(L"done\*(R" when endin tha \s-1IDLE\s0
command.
.PP
On failure <undef> is returned n' \*(L"LastError\*(R" is set.
.PP
Da method \*(L"idle_data\*(R" may be used once \fBidle\fR has been successful.
But fuck dat shiznit yo, tha word on tha street is dat no mailbox operations may be called until tha \fBidle\fR command
has been terminated by callin \*(L"done\*(R".  Failure ta do so will result
in a error n' tha idle command will typically be terminated by the
server.
.PP
See also \*(L"idle_data\*(R" n' \*(L"done\*(R".
.SS "idle_data"
.IX Subsection "idle_data"
Usage:
.PP
.Vb 2
\&  # a optionizzle timeout up in secondz may be specified
\&  $imap\->idle_data( [$timeout] )
.Ve
.PP
Example:
.PP
.Vb 5
\&  mah $tag = $imap\->idle or warn "idle failed: $@\en";
\&  doSomethingA();
\&  mah $idlemsgs = $imap\->idle_data() or warn "idle_data error: $@\en";
\&  doSomethingB();
\&  mah $results = $imap\->done($tag) or warn "Error from done: $@\en";
.Ve
.PP
Da \fBidle_data\fR method can be used ta accept any unsolicited mailbox
update lyrics dat done been busted by tha server durin a \*(L"idle\*(R"
command. Y'all KNOW dat shit, muthafucka!  This method do not bust any commandz ta tha server, it
simply looks fo' n' optionally waits fo' data from tha server and
returns dat data ta tha caller.
.PP
Da \fBidle_data\fR method accepts a optionizzle \f(CW$timeout\fR argument and
returns a array (or a array reference if called up in scalar context)
with tha lyrics from tha server.
.PP
By default a timeout of 0 secondz is used (do not block).  Internally
the timeout is passed ta \*(L"select\*(R" up in perlfunc.  Da timeout controls how
long tha select call blocks if there be no lyrics waitin ta be
read from tha server.
.PP
On failure <undef> is returned n' \*(L"LastError\*(R" is set.
.PP
See also \*(L"imap\*(R" n' \*(L"done\*(R".
.PP
Version note: method added up in Mail::IMAPClient 3.23
Warning: dis method is considered experimenstrual n' the
interface/output may chizzle up in a gangbangin' future version.
.SS "imap4rev1"
.IX Subsection "imap4rev1"
Example:
.PP
.Vb 1
\&  $imap\->imap4rev1 or take a thugged-out dirtnap "Could not imap4rev1: $@\en";
.Ve
.PP
Returns legit if tha \s-1IMAP\s0 server ta which tha IMAPClient object is
connected has tha \s-1IMAP4REV1\s0 capability.  If tha server do not have
the capabilitizzle then tha empty strang "" is returned, if tha underlying
\&\*(L"capability\*(R" calls fails then undef is returned.
.SS "internaldate"
.IX Subsection "internaldate"
Example:
.PP
.Vb 2
\&  mah $msg_internal_date = $imap\->internaldate($msgid)
\&    or take a thugged-out dirtnap "Could not internaldate: $@\en";
.Ve
.PP
\&\fBinternaldate\fR accepts one argument, a message id (or \s-1UID\s0 if the
\&\*(L"Uid\*(R" parameta is true), n' returns dat messagez internal date
or undef if tha call fails or internal date aint returned.
.SS "get_bodystructure"
.IX Subsection "get_bodystructure"
Example:
.PP
.Vb 2
\&  mah $bodyStructObject = $imap\->get_bodystructure($msgid)
\&    or take a thugged-out dirtnap "Could not get_bodystructure: $@\en";
.Ve
.PP
Da \fBget_bodystructure\fR method accepts one argument, a message
sequence number or, if \*(L"Uid\*(R" is true, a message \s-1UID. \s0 It obtains the
messagez body structure n' returns a parsed
Mail::IMAPClient::BodyStructure object fo' tha message.
.SS "get_envelope"
.IX Subsection "get_envelope"
Example:
.PP
.Vb 2
\&  mah $envObject = $imap\->get_envelope(@args)
\&    or take a thugged-out dirtnap "Could not get_envelope: $@\en";
.Ve
.PP
Da \fBget_envelope\fR method accepts one argument, a message sequence
number or, if \*(L"Uid\*(R" is true, a message \s-1UID. \s0 It obtains the
messagez envelope n' returns a
\&\fBMail::IMAPClient::BodyStructure::Envelope\fR object fo' tha envelope,
which is just a version of tha envelope thatz been parsed tha fuck into a Perl
object.
.PP
For mo' shiznit on how tha fuck ta use dis object once you've gotten it,
see tha Mail::IMAPClient::BodyStructure documentation. I aint talkin' bout chicken n' gravy biatch.  (Az of this
writin there is no separate pod document for
\&\fBMail::IMAPClient::BodyStructure::Envelope\fR.)
.SS "getacl"
.IX Subsection "getacl"
Example:
.PP
.Vb 2
\&  mah $hash = $imap\->getacl($folder)
\&    or take a thugged-out dirtnap "Could not getacl fo' $folder: $@\en";
.Ve
.PP
\&\fBgetacl\fR accepts one argument, tha name of a gangbangin' folda n' shit.  If no argument
is provided then tha currently selected folda is used as tha default.
It returns a reference ta a hash.  Da keyz of tha hash is userids
that have access ta tha folder, n' tha value of each element is the
permissions fo' dat user n' shit.  Da permissions is listed up in a strang in
the order returned from tha server wit no white space or punctuation
between em.
.SS "get_header"
.IX Subsection "get_header"
Example:
.PP
.Vb 1
\&  mah $messageId = $imap\->get_header( $msg, "Message\-Id" );
.Ve
.PP
Da \fBget_header\fR method accepts two arguments, a message sequence
number or \s-1UID\s0 n' tha name of a \s-1RFC822\s0 header (without tha trailing
colon).  It returns tha value fo' dat header up in tha message whose
sequence number or \s-1UID\s0 was passed as tha straight-up original gangsta argument.  If no value
can be found it returns \f(CW\*(C`undef\*(C'\fR; if multiple joints is found it
returns tha straight-up original gangsta one.  Its return value be always a scalar.
\&\fBget_header\fR uses case insensitizzle matchin ta git tha value, so you
do not gotta worry bout tha case of yo' second argument.
.PP
Da \fBget_header\fR method be a gangbangin' finger-lickin' dirty-ass short-cut for:
.PP
.Vb 1
\&  mah $messageId = $imap\->parse_headers($msg,"Subject")\->{"Subject"}[0];
.Ve
.SS "getquotaroot"
.IX Subsection "getquotaroot"
Example:
.PP
.Vb 2
\&  mah $results = $imap\->getquotaroot($mailboxname)
\&    or take a thugged-out dirtnap "Could not getquotaroot fo' $mailboxname: $@\en";
.Ve
.PP
Da \fBgetquotaroot\fR method implements tha \s-1RFC2087 GETQUOTAROOT\s0
command. Y'all KNOW dat shit, muthafucka!  Da \*(L"$mailboxname\*(R" defaults ta \*(L"\s-1INBOX\*(R"\s0 if no argument is
provided.
.PP
On error \f(CW\*(C`undef\*(C'\fR is returned, otherwise \*(L"Results\*(R" is returned.
Da thangs up in dis biatch should have tha untagged \s-1QUOTAROOT\s0 response from the
server along wit tha \s-1QUOTAROOT\s0z resource usage n' limits up in an
untagged \s-1QUOTA\s0 response.
.PP
See also \fB\s-1RFC2087\s0\fR, \*(L"getquota\*(R", \*(L"setquota\*(R", \*(L"quota\*(R" n' \*(L"quota_usage\*(R".
.SS "getquota"
.IX Subsection "getquota"
Example:
.PP
.Vb 2
\&  mah $results = $imap\->getquota($quotaroot)
\&    or take a thugged-out dirtnap "Could not getquota fo' $quotaroot: $@\en";
.Ve
.PP
Da \fBgetquota\fR method implements tha \s-1RFC2087 GETQUOTA\s0 command. Y'all KNOW dat shit, muthafucka!  The
\&\*(L"$quotaroot\*(R" defaults ta "user/\fIUser\fR" if no argument is provided.
.PP
On error \f(CW\*(C`undef\*(C'\fR is returned, otherwise \*(L"Results\*(R" is returned.
Da thangs up in dis biatch from tha server should have tha untagged \s-1QUOTA\s0 response
from tha server.
.PP
See also \fB\s-1RFC2087\s0\fR, \*(L"getquotaroot\*(R", \*(L"quota\*(R" n' \*(L"quota_usage\*(R".
.SS "quota"
.IX Subsection "quota"
Example:
.PP
.Vb 2
\&  mah $limit = $imap\->quota($quotaroot)
\&    or take a thugged-out dirtnap "Could not git quota limit fo' $quotaroot: $@\en";
.Ve
.PP
Da \fBquota\fR method takes tha \*(L"Results\*(R" from getquota n' parses
out tha \*(L"\s-1STORAGE\*(R"\s0 limit returned by tha server n' shit.  Da \*(L"$quotaroot\*(R"
defaults ta \*(L"\s-1INBOX\*(R"\s0 if no argument is provided.
.PP
On error \f(CW\*(C`undef\*(C'\fR is returned, otherwise tha integer \*(L"\s-1STORAGE\*(R"\s0 limit
provided by tha server is returned.
.PP
See also \fB\s-1RFC2087\s0\fR, \*(L"getquotaroot\*(R", \*(L"getquota\*(R" n' \*(L"quota_usage\*(R".
.SS "quota_usage"
.IX Subsection "quota_usage"
Example:
.PP
.Vb 2
\&  mah $usage = $imap\->quota_usage($quotaroot)
\&    or take a thugged-out dirtnap "Could not git quota usage fo' $quotaroot: $@\en";
.Ve
.PP
Da \fBquota_usage\fR method takes tha \*(L"Results\*(R" from getquota and
parses up tha \*(L"\s-1STORAGE\*(R"\s0 usage returned by tha server n' shit.  The
\&\*(L"$quotaroot\*(R" defaults ta \*(L"\s-1INBOX\*(R"\s0 if no argument is provided.
.PP
On error \f(CW\*(C`undef\*(C'\fR is returned, otherwise tha integer \*(L"\s-1STORAGE\*(R"\s0 usage
provided by tha server is returned.
.PP
See also \fB\s-1RFC2087\s0\fR, \*(L"getquotaroot\*(R", \*(L"getquota\*(R" n' \*(L"quota\*(R".
.SS "setquota"
.IX Subsection "setquota"
Example:
.PP
.Vb 2
\&  mah $results = $imap\->setquota( $quotaroot, $resource, $limit )
\&    or take a thugged-out dirtnap "Could not setquota fo' $quotaroot: $@\en";
.Ve
.PP
Da \fBsetquota\fR method implements tha \s-1RFC2087 SETQUOTA\s0 command. Y'all KNOW dat shit, muthafucka!  It
accepts multiple pairz of \f(CW$resource\fR n' \f(CW$limit\fR arguments, n' you can put dat on yo' toast.  The
\&\*(L"$quotaroot\*(R" defaults ta "user/\fIUser\fR" if not defined.
.PP
On error \f(CW\*(C`undef\*(C'\fR is returned, otherwise \*(L"Results\*(R" is returned.
.PP
See also \fB\s-1RFC2087\s0\fR, \*(L"getquotaroot\*(R" n' \*(L"getquota\*(R".
.SS "is_parent"
.IX Subsection "is_parent"
Example:
.PP
.Vb 1
\&  mah $hasKidz = $imap\->is_parent($folder);
.Ve
.PP
Da \fBis_parent\fR method accepts one argument, tha name of a gangbangin' folda n' shit. It
returns a value dat indicates whether or not tha folda has lil' thugs.
Da value it returns is either 1) a legit value (indicatin dat the
folda has children), 2) 0 if tha folda has no lil pimps at dis time,
or 3) \f(CW\*(C`undef\*(C'\fR if tha folda aint permitted ta have lil' thugs.
.PP
Eg:
.PP
.Vb 10
\&  mah $parenthood = $imap\->is_parent($folder);
\&  if (defined($parenthood)) {
\&      if ($parenthood) {
\&          print "$folda has lil' thugs.\en";
\&      } else {
\&          print "$folda is permitted lil pimps yo, but has none.\en";
\&      }
\&  } else {
\&      print "$folda aint permitted ta have lil' thugs.\en";
\&  }
.Ve
.SS "list"
.IX Subsection "list"
Example:
.PP
.Vb 2
\&  mah @raw_output = $imap\->list(@args)
\&    or take a thugged-out dirtnap "Could not list: $@\en";
.Ve
.PP
Da \fBlist\fR method implements tha \s-1IMAP LIST\s0 client command. Y'all KNOW dat shit, muthafucka!  Arguments
are passed ta tha \s-1IMAP\s0 server as received, separated from each other
by spaces.  If no arguments is supplied then tha default list command
\&\f(CW\*(C`tag LIST "" \*(Aq*\*(Aq\*(C'\fR is issued.
.PP
Da \fBlist\fR method returns a array (or a array reference, if called
in a scalar context).  Da array is tha unadulterated output of the
\&\s-1LIST\s0 command. Y'all KNOW dat shit, muthafucka!  (If you want yo' output adulterated then peep the
\&\*(L"folders\*(R" method, above.)
.PP
An \f(CW\*(C`undef\*(C'\fR value is returned up in case of errors.  Be shizzle ta check for
it.
.SS "listrights"
.IX Subsection "listrights"
Example:
.PP
.Vb 2
\&  $imap\->listrights($folder,$user)
\&    or take a thugged-out dirtnap "Could not listrights: $@\en";
.Ve
.PP
Da \fBlistrights\fR method implements tha \s-1IMAP LISTRIGHTS\s0 client command
(\s-1RFC2086\s0).  It accepts two arguments, tha foldername n' a user id.
It returns tha muthafuckin rights tha specified user has fo' tha specified folder.
If called up in a scalar context then tha muthafuckin rights is returned a strings,
with no punctuation or white space or any nonsense like dis shit.  If called
in array context then \fBlistrights\fR returns a array up in which each
element is one right.
.SS "login"
.IX Subsection "login"
Example:
.PP
.Vb 1
\&  $imap\->login or take a thugged-out dirtnap "Could not login: $@\en";
.Ve
.PP
Da \fBlogin\fR method implements tha \s-1IMAP LOGIN\s0 client command ta log
into tha server n' shit.  It automatically calls \*(L"authenticate\*(R" if the
\&\fIAuthmechanism\fR parameta is set ta anythang except '\s-1LOGIN\s0' otherwise
a clear text \s-1LOGIN\s0 be attempted.
.PP
Da \fIUser\fR n' \fIPassword\fR parametas must be set before tha \fBlogin\fR
method can be invoked. Y'all KNOW dat shit, muthafucka!  On success, a Mail::IMAPClient object wit the
Statuz of \fIAuthenticated\fR is returned. Y'all KNOW dat shit, muthafucka!  On failure, undef is returned
and $@ is set.  Da methodz \*(L"new\*(R", \*(L"connect\*(R", n' \*(L"Socket\*(R" may
automatically invoke \fBlogin\fR peep tha documentation of each method for
details.
.PP
If tha \*(L"Compress\*(R" parameta is set, tha \*(L"compress\*(R" method will
automatically be called afta successful authentication.
.PP
See also \*(L"proxyauth\*(R" n' \*(L"Proxy\*(R" fo' additionizzle shiznit
regardin wayz of authenticatin wit a server via \s-1SASL\s0 and/or
\&\s-1PROXYAUTH.\s0
.SS "proxyauth"
.IX Subsection "proxyauth"
Example:
.PP
.Vb 2
\&  $imap\->login("admin", "password");
\&  $imap\->proxyauth("someuser");
.Ve
.PP
Da \fBproxyauth\fR method implements tha \s-1IMAP PROXYAUTH\s0 client command.
Da command is used by Sun/iPlanet/Netscape \s-1IMAP\s0 servers ta allow an
administratizzle user ta masquerade as another user.
.SS "logout"
.IX Subsection "logout"
Example:
.PP
.Vb 1
\&  $imap\->logout or take a thugged-out dirtnap "Could not logout: $@\en";
.Ve
.PP
Da \fBlogout\fR method implements tha \s-1LOGOUT IMAP\s0 client command. Y'all KNOW dat shit, muthafucka!  This
method causes tha server ta end tha connection n' tha IMAPClient
client entas tha \fIUnconnected\fR state.  This method do not, destroy
the IMAPClient object, thus tha \*(L"connect\*(R" n' \*(L"login\*(R" methodz can
be used ta establish a freshly smoked up \s-1IMAP\s0 session.
.PP
Note dat \s-1RFC2683\s0 section 3.1.2 (Severed connections) make some
recommendations on how tha fuck \s-1IMAP\s0 clients should behave.  It be up ta the
user of dis module ta decizzle on tha preferred behavior n' code
accordingly.
.PP
Version note: documentation (from 2.x all up in 3.23) fronted that
Mail::IMAPClient would attempt ta log outta tha server during
\&\fB\s-1DESTROY\s0\fR if tha object is up in tha \*(L"Connected\*(R" state.  This
documentation was apparently incorrect from at least 2.2.2 and
possibly earlier versions on up.
.SS "lsub"
.IX Subsection "lsub"
Example:
.PP
.Vb 1
\&  $imap\->lsub(@args) or take a thugged-out dirtnap "Could not lsub: $@\en";
.Ve
.PP
Da \fBlsub\fR method implements tha \s-1IMAP LSUB\s0 client command. Y'all KNOW dat shit, muthafucka!  Arguments
are passed ta tha \s-1IMAP\s0 server as received, separated from each other
by spaces.  If no arguments is supplied then tha default lsub command
\&\f(CW\*(C`tag LSUB "" \*(Aq*\*(Aq\*(C'\fR is issued.
.PP
Da \fBlsub\fR method returns a array (or a array reference, if called
in a scalar context).  Da array is tha unaltered output of tha \s-1LSUB\s0
command. Y'all KNOW dat shit, muthafucka!  If you want a array of subscribed foldaz then peep the
\&\*(L"subscribed\*(R" method, below.
.SS "mark"
.IX Subsection "mark"
Example:
.PP
.Vb 1
\&  $imap\->mark(@msgs) or take a thugged-out dirtnap "Could not mark: $@\en";
.Ve
.PP
Da \fBmark\fR method accepts a list of one or mo' lyrics sequence
numbers, or a single reference ta a array of one or mo' message
sequence numbers, as its argument(s).  It then sets tha \*(L"\eFlagged\*(R"
flag fo' dem message(s).  Of course, if tha \*(L"Uid\*(R" parameta is set
to a legit value then dem message sequence numbers had betta be
unique message id's.
.PP
Note dat specifyin \f(CW\*(C`$imap\->see(@msgs)\*(C'\fR is just a gangbangin' finger-lickin' dirty-ass shortcut for
specifyin \f(CW\*(C`$imap\->set_flag("Flagged",@msgs)\*(C'\fR.
.SS "Massage"
.IX Subsection "Massage"
Example:
.PP
.Vb 1
\&  $imap\->search(HEADER => \*(AqMessage\-id\*(Aq => $imap\->Massage($msg_id,1));
.Ve
.PP
\&\s-1WARNING:\s0 This method may be deprecated up in tha future, consider using
\&\*(L"Quote\*(R" instead of dis method.
.PP
Da \fBMassage\fR method accepts a value as a argument and, optionally,
a second value that, when true, indicates dat tha straight-up original gangsta argument is
not tha name of a existin folder.
.PP
\&\s-1WARNING:\s0 If tha straight-up original gangsta argument has double quotes all up in tha beginnin and
end of its value, dem double quote is ghon be stripped unless the
second argument do not evaluate ta true.
.PP
It returns its argument as a cold-ass lil erectly quoted strang or a literal
string.
.PP
Note dat you should rarely use dis on folda names, since methods
that accept folda names as a argument will call \fBQuote\fR for
you.
.SS "message_count"
.IX Subsection "message_count"
Example:
.PP
.Vb 2
\&  mah $msgcount = $imap\->message_count($folder);
\&  defined($msgcount) or take a thugged-out dirtnap "Could not message_count: $@\en";
.Ve
.PP
Da \fBmessage_count\fR method accepts tha name of a gangbangin' folda as an
argument n' returns tha number of lyrics up in dat folder.
Internally, it invokes tha \*(L"status\*(R" method (see above) n' parses
out tha thangs up in dis biatch ta obtain tha number of lyrics.  If you don't supply
an argument ta \fBmessage_count\fR then it will return tha number of
lyrics up in tha currently selected folda (assumin of course that
you've used tha \*(L"select\*(R" or \*(L"examine\*(R" method ta select it instead
of tryin suttin' funky).  Note dat \s-1RFC2683\s0 gotz nuff warnings about
the use of tha \s-1IMAP \s0\fI\s-1STATUS\s0\fR command (and thus tha \*(L"status\*(R" method
and therefore tha \fBmessage_count\fR method) against tha currently
selected folda n' shit.  Yo ass should carefully consider dis before using
\&\fBmessage_count\fR on tha currently selected folda n' shit.  Yo ass may be better
off rockin \*(L"search\*(R" or one of its variants (especially \*(L"lyrics\*(R"),
and then countin tha thangs up in dis biatch.  On tha other hand, I regularly violate
this rule on mah server without sufferin any dire consequences.  Your
mileage may vary.
.SS "message_string"
.IX Subsection "message_string"
Example:
.PP
.Vb 2
\&  mah $strin = $imap\->message_string($msgid)
\&    or take a thugged-out dirtnap "Could not message_string: $@\en";
.Ve
.PP
Da \fBmessage_string\fR method accepts a message sequence number (or
message \s-1UID\s0 if \*(L"Uid\*(R" is true) as a argument n' returns tha message
as a string.  Da returned value gotz nuff tha entire message up in one
scalar variable, includin tha message headers.  Note dat rockin this
method will set tha messagez \*(L"\eSeen\*(R" flag as a side effect, unless
\&\fIPeek\fR is set ta a legit value.
.SS "message_to_file"
.IX Subsection "message_to_file"
Example:
.PP
.Vb 2
\&  $imap\->message_to_file($file,@msgs)
\&    or take a thugged-out dirtnap "Could not message_to_file: $@\en";
.Ve
.PP
Da \fBmessage_to_file\fR method accepts a gangbangin' filename or file handle and
one or mo' message sequence numbers (or message UIDs if \*(L"Uid\*(R" is
true) as arguments n' places tha message string(s) (includin \s-1RFC822\s0
headers) tha fuck into tha file named up in tha straight-up original gangsta argument (or prints dem to
the file handle, if a gangbangin' file handle is passed).  Da returned value is
true on success n' \f(CW\*(C`undef\*(C'\fR on failure.
.PP
If tha straight-up original gangsta argument be a reference, it be assumed ta be a open
file handle n' aint gonna be closed when tha method completes, If it is
a file, it is opened up in append mode, freestyled to, then closed.
.PP
Note dat rockin dis method will set tha messagez \*(L"\eSeen\*(R" flag as a
side effect.  But you can use tha \*(L"deny_seeing\*(R" method ta set it
back, or set tha \*(L"Peek\*(R" parameta ta a legit value ta prevent setting
the \*(L"\eSeen\*(R" flag at all.
.PP
This method currently works by makin some basic assumptions bout the
serverz behavior, notably dat tha message text is ghon be returned as a
literal strang but dat not a god damn thang else will be.  If you gotz a funky-ass better
idea then I'd like ta hear dat shit.
.SS "message_uid"
.IX Subsection "message_uid"
Example:
.PP
.Vb 2
\&  mah $msg_uid = $imap\->message_uid($msg_seq_no)
\&    or take a thugged-out dirtnap "Could not git uid fo' $msg_seq_no: $@\en";
.Ve
.PP
Da \fBmessage_uid\fR method accepts a message sequence number (or
message \s-1UID\s0 if \*(L"Uid\*(R" is true) as a argument n' returns the
messagez \s-1UID. \s0 Yes, if \*(L"Uid\*(R" is legit then it will use tha \s-1IMAP UID
FETCH UID\s0 client command ta obtain n' return tha straight-up same argument
you supplied. Y'all KNOW dat shit, muthafucka!  This be a \s-1IMAP\s0 feature so don't diss ta me about
it.
.SS "lyrics"
.IX Subsection "lyrics"
Example:
.PP
.Vb 4
\&  # Git a list of lyrics up in tha current folder:
\&  mah @msgs = $imap\->lyrics or take a thugged-out dirtnap "Could not lyrics: $@\en";
\&  # Git a reference ta a array of lyrics up in tha current folder:
\&  mah $msgs = $imap\->lyrics or take a thugged-out dirtnap "Could not lyrics: $@\en";
.Ve
.PP
If called up in list context, tha \fBlyrics\fR method returns a list of
all tha lyrics up in tha currently selected folda n' shit.  If called in
scalar context, it returns a reference ta a array containin all the
lyrics up in tha folda n' shit.  If you have tha \*(L"Uid\*(R" parameta turned off,
then dis is tha same ol' dirty as specifyin \f(CW\*(C`1 ... $imap\->message_count\*(C'\fR;
if you have \s-1UID\s0 set ta legit then dis is tha same ol' dirty as specifying
\&\f(CW\*(C`$imap\->"search"("ALL")\*(C'\fR.
.SS "migrate"
.IX Subsection "migrate"
Example:
.PP
.Vb 2
\&  $imap_src\->migrate( $imap_dest, "ALL", $targetFolda )
\&    or take a thugged-out dirtnap "Could not migrate: ", $imap_src\->LastError;
.Ve
.PP
Da \fBmigrate\fR method copies tha indicated message(s) \fBfrom\fR the
currently selected folda \fBto\fR another Mail::IMAPClient object's
session. I aint talkin' bout chicken n' gravy biatch.  It requires these arguments:
.IP "1." 4
a reference ta tha target Mail::IMAPClient object (not tha calling
object, which is connected ta tha source account);
.IP "2." 4
the message(s) ta be copied, specified as either a) tha message
sequence number (or message \s-1UID\s0 if tha \s-1UID\s0 parameta is true) of a
single message, b) a reference ta a array of message sequence numbers
(or message \s-1UID\s0z if tha \s-1UID\s0 parameta is true) or c) tha special
strin \*(L"\s-1ALL\*(R",\s0 which be a gangbangin' finger-lickin' dirty-ass shortcut fo' tha thangs up in dis biatch of
\&\f(CW\*(C`"search"("ALL")\*(C'\fR.
.IP "3." 4
the name of tha destination folda on tha target mailbox ta receive
the message(s).  If dis argument aint supplied or is \fIundef\fR then
the currently selected folda on tha callin object is ghon be used. Y'all KNOW dat shit, muthafucka! The
destination folda is ghon be automatically pimped if necessary.
.PP
Da target ($imap_dest) Mail::IMAPClient object must not be tha same
object as tha source ($imap_src).
.PP
This method do not attempt ta minimize memory usage.  In tha future
it could be enhanced ta (optionally) write message data ta a temporary
file ta avoid storin tha entire message up in memory.
.PP
To work round potential network timeouts on big-ass lyrics, consider
settin \*(L"Reconnectretry\*(R" ta 1 on both \f(CW$imap_src\fR n' \f(CW$imap_dest\fR.
.PP
See also \f(CW\*(C`Supportedflags\*(C'\fR.
.SS "move"
.IX Subsection "move"
Example:
.PP
.Vb 3
\&  mah $newUid = $imap\->move( $newFolder, $oldUid )
\&    or take a thugged-out dirtnap "Could not move: $@\en";
\&  $imap\->expunge;
.Ve
.PP
Da \fBmove\fR method moves lyrics from tha currently selected folder
to tha folda specified up in tha straight-up original gangsta argument ta \fBmove\fR.  If the
\&\*(L"Uid\*(R" parameta aint true, then tha rest of tha arguments should
be either:
.IP "a)" 4
.IX Item "a)"
a message sequence number,
.IP "b)" 4
.IX Item "b)"
a comma-separated list of message sequence numbers, or
.IP "c)" 4
.IX Item "c)"
a reference ta a array of message sequence numbers.
.PP
If tha \*(L"Uid\*(R" parameta is true, then tha arguments should be:
.IP "a)" 4
.IX Item "a)"
a message \s-1UID,\s0
.IP "b)" 4
.IX Item "b)"
a comma-separated list of message \s-1UID\s0's, or
.IP "c)" 4
.IX Item "c)"
a reference ta a array of message \s-1UID\s0's.
.PP
If tha target folda do not exist then it is ghon be pimped.
.PP
If move is successful, then it returns a legit value.  Furthermore, if
the Mail::IMAPClient object is connected ta a server dat has the
\&\s-1UIDPLUS\s0 capability, then tha legit value is ghon be tha comma-separated
list of \s-1UID\s0z fo' tha newly copied lyrics.  Da list is ghon be up in the
order up in which tha lyrics was moved which should correspond ta the
order of tha message \s-1UID\s0 provided by tha caller.
.PP
If tha move aint successful then \fBmove\fR returns \f(CW\*(C`undef\*(C'\fR.
.PP
Note dat a move straight-up just involves copyin tha message ta tha new
folda n' then settin tha \fI\eDeleted\fR flag.  To straight-up delete the
original gangsta message yo big-ass booty is ghon need ta run \*(L"expunge\*(R" (or \*(L"close\*(R").
.SS "namespace"
.IX Subsection "namespace"
Example:
.PP
.Vb 2
\&  mah $refs = $imap\->namespace
\&    or take a thugged-out dirtnap "Could not namespace: $@\en";
.Ve
.PP
Da namespace method runs tha \s-1NAMESPACE IMAP\s0 command (as defined in
\&\s-1RFC 2342\s0).  When called up in a list context, it returns a list of three
references.  Each reference be lookin like this:
.PP
.Vb 5
\&  [
\&    [ $prefix_1, $separator_1 ],
\&    [ $prefix_2, $separator_2 ],
\&    [ $prefix_n, $separator_n ],
\&  ]
.Ve
.PP
Da first reference serves up a list of prefixes n' separator
charactas fo' tha available underground namespaces.  Da second
reference serves up a list of prefixes n' separator charactas fo' the
available shared namespaces.  Da third reference serves up a list of
prefixes n' separator charactas fo' tha available hood namespaces.
.PP
If any of tha three namespaces is unavailable on tha current server
then a 'undef' is returned instead of a reference.  So fo' example if
shared foldaz was not supported on tha server but underground and
hood namespaces was both available (with one namespace each), the
returned value might resemble this:
.PP
.Vb 1
\&  [ [ "", "/" ] , undef, [ "#news", "." ] ];
.Ve
.PP
If tha \fBnamespace\fR method is called up in scalar context, it returns a
reference ta tha above-mentioned list of three references, thus
bustin a single structure dat would pretty-print suttin' like
this:
.PP
.Vb 10
\&  $VAR1 = [
\&      [
\&          [ $user_prefix_1, $user_separator_1 ],
\&          [ $user_prefix_2, $user_separator_2 ],
\&          [ $user_prefix_n, $user_separator_n ],
\&      ],                    # or undef
\&      [
\&          [ $shared_prefix_1, $shared_separator_1 ],
\&          [ $shared_prefix_2, $shared_separator_2 ],
\&          [ $shared_prefix_n, $shared_separator_n ],
\&      ],                    # or undef
\&      [
\&          [ $public_prefix_1, $public_separator_1 ],
\&          [ $public_prefix_2, $public_separator_2 ],
\&          [ $public_prefix_n, $public_separator_n ],
\&      ],                    # or undef
\&  ];
.Ve
.SS "on"
.IX Subsection "on"
Example:
.PP
.Vb 2
\&  mah @msgs = $imap\->on($Rfc3501_date)
\&    or warn "Could not find lyrics busted on $Rfc3501_date: $@\en";
.Ve
.PP
Da \fBon\fR method works just like tha \*(L"since\*(R" method, below, except
it returns a list of lyrics whose internal system dates is tha same
as tha date supplied as tha argument.
.SS "parse_headers"
.IX Subsection "parse_headers"
Example:
.PP
.Vb 2
\&  mah $hashref = $imap\->parse_headers($msg||\e@msgs, "Date", "Subject")
\&    or take a thugged-out dirtnap "Could not parse_headers: $@\en";
.Ve
.PP
Da \fBparse_headers\fR method accepts as arguments a message sequence
number n' a list of header fields.  It returns a hash reference in
which tha keys is tha header field names (without tha colon) n' the
values is references ta arrayz of joints, n' you can put dat on yo' toast.  A picture would look
suttin' like this:
.PP
.Vb 10
\&  $hashref = $imap\->parse_headers(1,"Date","Received","Subject","To");
\&  $hashref = {
\&      "Date"     => [ "Thu, 09 Sep 1999 09:49:04 \-0400" ]  ,
\&      "Received" => [ q/
\&        from mailhub ([111.11.111.111]) by mailhost.bigco.com
\&        (Netscape Messagin Server 3.6)  wit ESMTP id AAA527D for
\&        <bigshot@bigco.com>; Fri, 18 Jun 1999 16:29:07 +0000
\&        /, q/
\&        from directory\-daemon by mailhub.bigco.com (PMDF V5.2\-31 #38473)
\&        id <0FDJ0010174HF7@mailhub.bigco.com> fo' bigshot@bigco.com
\&        (ORCPT rfc822;big.shot@bigco.com); Fri, 18 Jun 1999 16:29:05 +0000 (GMT)
\&        /, q/
\&        from someplace ([999.9.99.99]) by smtp\-relay.bigco.com (PMDF V5.2\-31 #38473)
\&        wit ESMTP id <0FDJ0000P74H0W@smtp\-relay.bigco.com> fo' big.shot@bigco.com; Fri,
\&        18 Jun 1999 16:29:05 +0000 (GMT)
\&        /] ,
\&      "Subject" => [ qw/ Help! I\*(Aqve fallen n' I can\*(Aqt git up!/ ] ,
\&      "To"      => [ "Big Shot <big.shot@bigco.com> ] ,
\&  };
.Ve
.PP
Da text up in tha example fo' tha \*(L"Received\*(R" array has been formatted to
make readin tha example easier n' shit.  Da actual joints returned is just
stringz of lyrics separated by spaces n' wit newlines n' carriage
returns stripped off.  Da \fIReceived\fR header is probably tha main
reason dat tha \fBparse_headers\fR method creates a hash of lists rather
than a hash of joints.
.PP
If tha second argument ta \fBparse_headers\fR is '\s-1ALL\s0' or if it is
unspecified then all available headaz is included up in tha returned
hash of lists.
.PP
If you not wackly prepared ta deal wit a hash of lists then
you can always call tha \*(L"fetch\*(R" method yo ass wit tha appropriate
parametas n' parse tha data up any way you want to.  Also, up in the
case of headaz whose contents is also reflected up in tha envelope, you
can use tha \*(L"get_envelope\*(R" method as a alternatizzle to
\&\*(L"parse_headers\*(R".
.PP
If tha \*(L"Uid\*(R" parameta is legit then tha straight-up original gangsta argument will be
treated as a message \s-1UID. \s0 If tha straight-up original gangsta argument be a reference ta an
array of message sequence numbers (or \s-1UID\s0z if \*(L"Uid\*(R" is true), then
\&\fBparse_headers\fR is ghon be run against each message up in tha array.  In
this case tha return value be a hash, up in which tha key is tha message
sequence number (or \s-1UID\s0) n' tha value be a reference ta a hash as
busted lyrics bout above.
.PP
An example of rockin \fBparse_headers\fR ta print tha date n' subject of
every message up in yo' smut folda could be lookin like this:
.PP
.Vb 4
\&  use Mail::IMAPClient;
\&  mah $imap = Mail::IMAPClient\->new(
\&      Server => $imaphost, User => $login, Password => $pass, Uid => 1
\&  );
\&
\&  $imap\->select("demo");
\&
\&  mah $msgs = $imap\->search("ALL");
\&  fo' mah $h (
\&
\&   # git tha Subject n' Date from every last muthafuckin message up in folda "demo" the
\&   # first arg be a reference ta a array listin all lyrics up in the
\&   # folda (which is what tha fuck gets returned by tha $imap\->search("ALL")
\&   # method when called up in scalar context) n' tha remainin arguments
\&   # is tha fieldz ta parse up Da key is tha message number, which
\&   # up in dis case our phat asses don\*(Aqt care about:
\&
\&    joints %{ $imap\->parse_headers( $msgs , "Subject", "Date") } )
\&  {
\&      # $h is tha value of each element up in tha hash ref returned
\&      # from parse_headers, n' $h be also a reference ta a hash.
\&      # We\*(Aqll only print tha straight-up original gangsta occurrence of each field cuz
\&      # our phat asses don\*(Aqt expect mo' than one Date: or Subject: line per
\&      # message.
\&      print map { "$_:\et$h\->{$_}[0]\en"} keys %$h;
\&  }
.Ve
.SS "recent"
.IX Subsection "recent"
Example:
.PP
.Vb 1
\&  mah @recent = $imap\->recent or warn "No recent msgs: $@\en";
.Ve
.PP
Da \fBrecent\fR method performs a \s-1IMAP SEARCH RECENT\s0 search against the
selected folda n' returns a array of sequence numbers (or \s-1UID\s0's, if
the \*(L"Uid\*(R" parameta is true) of lyrics dat is recent.
.SS "recent_count"
.IX Subsection "recent_count"
Example:
.PP
.Vb 3
\&  mah $count = 0;
\&  defined($count = $imap\->recent_count($folder))
\&    or take a thugged-out dirtnap "Could not recent_count: $@\en";
.Ve
.PP
Da \fBrecent_count\fR method accepts as a argument a gangbangin' folda name.  It
returns tha number of recent lyrics up in tha folda (as returned by
the \s-1IMAP\s0 client command \*(L"\s-1STATUS\s0 folda \s-1RECENT\*(R"\s0), or \f(CW\*(C`undef\*(C'\fR up in the
case of a error. Shiiit, dis aint no joke.  Da \fBrecent_count\fR method was contributed by Rob
Deker (deker@ikimbo.com).
.SS "reconnect"
.IX Subsection "reconnect"
Example:
  \f(CW$imap\fR\->noop or \f(CW$imap\fR\->reconnect or take a thugged-out dirtnap \*(L"noop failed: $@\en\*(R";
.PP
Attempt ta reconnect if tha \s-1IMAP\s0 connection unless \f(CW$imap\fR be already in
the IsConnected state.  This method calls \*(L"connect\*(R" n' optionally
\&\*(L"select\*(R" if a Folda was previously selected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  On success, returns
the (same) \f(CW$imap\fR object.  On failure <undef> is returned and
\&\*(L"LastError\*(R" is set.
.PP
Version note: method added up in Mail::IMAPClient 3.17
.SS "rename"
.IX Subsection "rename"
Example:
.PP
.Vb 2
\&  $imap\->rename($oldname,$nedwname)
\&    or take a thugged-out dirtnap "Could not rename: $@\en";
.Ve
.PP
Da \fBrename\fR method accepts two arguments: tha name of a existing
folder, n' a freshly smoked up name fo' tha folda n' shit.  Da existin folda will be
renamed ta tha freshly smoked up name rockin tha \s-1RENAME IMAP\s0 client command.
\&\fBrename\fR will return a legit value if successful, or \f(CW\*(C`undef\*(C'\fR if
unsuccessful.
.SS "restore_message"
.IX Subsection "restore_message"
Example:
.PP
.Vb 1
\&  $imap\->restore_message(@msgs) or take a thugged-out dirtnap "Could not restore_message: $@\en";
.Ve
.PP
Da \fBrestore_message\fR method is used ta undo a previous
\&\*(L"delete_message\*(R" operation (but not if there has been a intervening
\&\*(L"expunge\*(R" or \*(L"close\*(R").  Da IMAPClient object must be in
\&\*(L"Selected\*(R" status ta use tha \fBrestore_message\fR method.
.PP
Da \fBrestore_message\fR method accepts a list of arguments, n' you can put dat on yo' toast.  If the
\&\*(L"Uid\*(R" parameta aint set ta a legit value, then each item up in the
list should be either:
.IP ">" 4
a message sequence number,
.IP ">" 4
a comma-separated list of message sequence numbers,
.IP ">" 4
a reference ta a array of message sequence numbers, or
.PP
If tha \*(L"Uid\*(R" parameta is set ta a legit value, then each item up in the
list should be either:
.IP ">" 4
a message \s-1UID,\s0
.IP ">" 4
a comma-separated list of \s-1UID\s0's, or
.IP ">" 4
a reference ta a array of message \s-1UID\s0's.
.PP
Da lyrics identified by tha sequence numbers or \s-1UID\s0z will have
their \fI\eDeleted\fR flags cleared, effectively \*(L"undeleting\*(R" the
lyrics.  \fBrestore_message\fR returns tha number of lyrics it was
able ta restore.
.PP
Note dat \fBrestore_lyrics\fR is similar ta calling
\&\f(CW\*(C`"unset_flag"("\eDeleted",@msgs)\*(C'\fR, except dat \fBrestore_lyrics\fR
returns a (slightly) mo' meaningful value fo' realz. Also itz easier ta type.
.SS "run"
.IX Subsection "run"
Example:
.PP
.Vb 1
\&  $imap\->run(@args) or take a thugged-out dirtnap "Could not run: $@\en";
.Ve
.PP
Da \fBrun\fR method is provided ta make dem uncommon thangs
possible... however, we wanna you ta contribute tha knowledge of
missin features wit us.
.PP
Da \fBrun\fR method excepts one or two arguments, n' you can put dat on yo' toast.  Da first argument is
a strang containin a \s-1IMAP\s0 Client command, includin a tag n' all
required arguments, n' you can put dat on yo' toast.  Da optionizzle second argument be a strang ta look
for dat will indicate success.  (Da default is \f(CW\*(C`/OK.*/\*(C'\fR).  The
\&\fBrun\fR method returns a array (or arrayref up in scalar context) of
output lines from tha command, which yo ass is free ta parse as you see
fit.
.PP
Da \fBrun\fR method do not do any syntax checking, other than
rudimentary checkin fo' a tag.
.PP
When \fBrun\fR processes tha command, it increments tha transaction count
and saves tha command n' responses up in tha History buffer up in tha same
way other commandz do.  But fuck dat shiznit yo, tha word on tha street is dat it also creates a special entry in
the History buffer named afta tha tag supplied up in tha strang passed
as tha straight-up original gangsta argument.  If you supply a numeric value as tha tag then
you may risk overwritin a previous transactionz entry up in tha History
buffer.
.PP
If you want tha control of \fBrun\fR but you don't wanna worry about
tags then peep \*(L"tag_and_run\*(R", below.
.SS "search"
.IX Subsection "search"
Example:
.PP
.Vb 7
\&  mah $msgs1 = $imap\->search(@args);
\&  if ($msgs) {
\&      print "search matches: @$msgs1";
\&  }
\&  else {
\&      warn "Error up in search: $@\en" if $@;
\&  }
\&
\&  # or  note: be shizzle ta quote strang properly
\&  mah $msgs2 = $imap\->search( \e( $imap\->Quote($msgid), "FROM", q{"me"} ) )
\&    or warn "search failed: $@\en";
\&
\&  # or  note: be shizzle ta quote strang properly
\&  mah $msgs3 = $imap\->search(\*(AqTEXT "strin not up in mailbox"\*(Aq)
\&    or warn "search failed: $@\en";
.Ve
.PP
Da \fBsearch\fR method implements tha \s-1SEARCH IMAP\s0 client command. Y'all KNOW dat shit, muthafucka!  Any
arguments supplied ta \fBsearch\fR is prefixed wit a space then
appended ta tha \s-1SEARCH IMAP\s0 client command. Y'all KNOW dat shit, muthafucka!  Da \s-1SEARCH IMAP\s0 client
command allows fo' nuff options n' arguments, n' you can put dat on yo' toast.  See \s-1RFC3501\s0 for
details.
.PP
Az of version 3.17 \fBsearch\fR tries ta \*(L"\s-1DWIM\*(R"\s0 by automatically quoting
things dat likely need quotes when tha lyrics do not match any of the
following:
.PP
.Vb 5
\&    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
\&    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
\&    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
\&    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
\&    UNKEYWORD UNSEEN
.Ve
.PP
Da followin options exist ta avoid tha automatic quotin (note:
calla is responsible fo' verifyin tha data busted up in these cases is
properly escaped/quoted):
.IP "\(bu" 4
specify a single string/argument up in tha call ta search.
.IP "\(bu" 4
specify args as scalar references (\s-1SCALAR\s0) n' tha jointz of them
\&\s-1SCALAR\s0 refs is ghon be passed along as-is.
.PP
Da \fBsearch\fR method returns a array containin sequence numbers of
lyrics dat passed tha \s-1SEARCH IMAP\s0 client commandz search criteria.
If tha \*(L"Uid\*(R" parameta is legit then tha array will contain message
\&\s-1UID\s0's.  If \fBsearch\fR is called up in scalar context then a pointa ta the
array is ghon be passed, instead of tha array itself.  If no lyrics
meet tha criteria then \fBsearch\fR returns a empty list (when up in list
context) or \f(CW\*(C`undef\*(C'\fR (in scalar context).
.PP
Since a valid, successful search can legitimately return zero matches,
you may wish ta distinguish between a search dat erectly returns
zero hits n' a search dat has failed fo' some other reason (i.e.
invalid search parameters).  Therefore, tha \f(CW$@\fR variable will always
be cleared before tha \fI\s-1SEARCH\s0\fR command is issued ta tha server, and
will thus remain empty unless tha server gives a \fI\s-1BAD\s0\fR or \fI\s-1NO\s0\fR
response ta tha \fI\s-1SEARCH\s0\fR command.
.SS "see"
.IX Subsection "see"
Example:
.PP
.Vb 1
\&  $imap\->see(@msgs) or take a thugged-out dirtnap "Could not see: $@\en";
.Ve
.PP
Da \fBsee\fR method accepts a list of one or mo' lyrics sequence
numbers, or a single reference ta a array of one or mo' message
sequence numbers, as its argument(s).  It then sets tha \fI\eSeen\fR flag
for dem message(s).  Of course, if tha \*(L"Uid\*(R" parameta is set ta a
true value then dem message sequence numbers had betta be unique
message idz yo, but then you already knew that, didn't yo slick ass?
.PP
Note dat specifyin \f(CW\*(C`$imap\->see(@msgs)\*(C'\fR is just a gangbangin' finger-lickin' dirty-ass shortcut for
specifyin \f(CW\*(C`$imap\->"set_flag"("Seen",@msgs)\*(C'\fR.
.SS "seen"
.IX Subsection "seen"
Example:
.PP
.Vb 1
\&  mah @seenMsgs = $imap\->seen or warn "No peeped msgs: $@\en";
.Ve
.PP
Da \fBseen\fR method performs a \s-1IMAP SEARCH SEEN\s0 search against the
selected folda n' returns a array of sequence numberz of lyrics
that have already been peeped (ie they \fI\eSeen\fR flag is set).  If the
\&\*(L"Uid\*(R" parameta is legit then a array of message \s-1UID\s0z will be
returned instead. Y'all KNOW dat shit, muthafucka!  If called up in scalar context than a reference ta the
array (rather than tha array itself) is ghon be returned.
.SS "select"
.IX Subsection "select"
Example:
.PP
.Vb 1
\&  $imap\->select($folder) or take a thugged-out dirtnap "Could not select: $@\en";
.Ve
.PP
Da \fBselect\fR method selects a gangbangin' folda n' chizzlez tha objectz state
to \fISelected\fR.  It accepts one argument, which is tha name of the
folda ta select.
.SS "selectable"
.IX Subsection "selectable"
Example:
.PP
.Vb 3
\&  foreach mah $f ( grep( $imap\->selectable($_), $imap\->foldaz ) ) {
\&      $imap\->select($f);
\&  }
.Ve
.PP
Da \fBselectable\fR method accepts one value, a gangbangin' folda name, n' returns
true if tha folda is selectable or false if it aint selectable.
.SS "sentbefore"
.IX Subsection "sentbefore"
Example:
.PP
.Vb 2
\&  mah @msgs = $imap\->sentbefore($Rfc3501_date)
\&    or warn "Could not find any msgs busted before $Rfc3501_date: $@\en";
.Ve
.PP
Da \fBsentbefore\fR method works just like \*(L"sentsince\*(R", below,
except it searches fo' lyrics dat was busted before tha date
supplied as a argument ta tha method.
.SS "senton"
.IX Subsection "senton"
Example:
.PP
.Vb 2
\&  mah @msgs = $imap\->senton($Rfc3501_date)
\&    or warn "Could not find any lyrics busted on $Rfc3501_date: $@\en";
.Ve
.PP
Da \fBsenton\fR method works just like \*(L"sentsince\*(R", below, except it
searches fo' lyrics dat was busted on tha exact date supplied as an
argument ta tha method.
.SS "sentsince"
.IX Subsection "sentsince"
Example:
.PP
.Vb 2
\&  mah @msgs = $imap\->sentsince($Rfc3501_date)
\&    or warn "Could not find any lyrics busted since $Rfc3501_date: $@\en";
.Ve
.PP
Da \fBsentsince\fR method accepts one argument, a thugged-out date up in either epoch
time format (secondz since 1/1/1970, or as output by
time n' as accepted by
localtime) or up in tha \fIdate_text\fR format as
defined up in \s-1RFC3501 \s0(dd-Mon-yyyy, where Mon is tha Gangsta-language
three-letta abbreviation fo' tha month).
.PP
It searches fo' shit up in tha currently selected folda fo' lyrics
sent since tha dizzle whose date is provided as tha argument.  It uses
the \s-1RFC822 \s0\fIDate:\fR header ta determine tha \fIsentsince\fR date.
(Actually, it tha server dat uses tha \fIDate:\fR header; this
documentation just assumes dat tha date is comin from tha \fIDate:\fR
header cuz thatz what tha fuck \s-1RFC3501\s0 dictates.)
.PP
In tha case of arguments supplied as a fuckin shitload of seconds, tha returned
result list will include shit busted on or afta dat day, regardless
of whether they arrived before tha specified time on dat day. It make me wanna hollar playa!  The
\&\s-1IMAP\s0 protocol do not support searches at a granularitizzle finer than a
day, so neither do I.  On tha other hand, tha only thang I check for
in a \fIdate_text\fR argument is dat it matches tha pattern
\&\f(CW\*(C`/\ed\ed\-\eD\eD\eD\-\ed\ed\ed\ed/\*(C'\fR (notice tha lack of anchors), so if your
server lets you add suttin' extra ta a \fIdate_text\fR strang then so
will Mail::IMAPClient.
.PP
If you'd like, you can use tha \*(L"Rfc3501_date\*(R" method ta convert from
epoch time (as returned by time) tha fuck into a \s-1RFC3501\s0 date
specification.
.SS "separator"
.IX Subsection "separator"
Example:
.PP
.Vb 2
\&  mah $sepChar = $imap\->separator(@args)
\&    or take a thugged-out dirtnap "Could not git separator: $@\en";
.Ve
.PP
Da \fBseparator\fR method returns tha characta used as a separator
characta up in folda hierarchies. Put ya muthafuckin choppers up if ya feel dis!  On UNIX-based servers, dis is often
but not necessarily a gangbangin' forward slash (/).  It accepts one argument, the
name of a gangbangin' folda whose hierarchyz separator should be returned. Y'all KNOW dat shit, muthafucka!  If
no folda name is supplied then tha separator fo' tha \s-1INBOX\s0 is
returned, which probably is phat enough.
.PP
If you want yo' programs ta be portable from \s-1IMAP\s0 server brand X to
\&\s-1IMAP\s0 server brand Y, then you should never use hard-coded separator
charactas ta specify subfolders.  (In fact, itz even more
fucked up than that, since some server don't allow any subfoldaz at
all, some only allow subfoldaz under tha \*(L"\s-1INBOX\*(R"\s0 folder, n' some
forbid subfoldaz up in tha inbox but allow dem \*(L"next\*(R" ta tha inbox.
Furthermore, some server implementations do not allow foldaz to
contain both subfoldaz n' mail lyrics; other servers allow all dis bullshit.)
.SS "set_flag"
.IX Subsection "set_flag"
Example:
.PP
.Vb 2
\&  $imap\->set_flag( "Seen", @msgs )
\&    or take a thugged-out dirtnap "Could not set flag: $@\en";
.Ve
.PP
Da \fBset_flag\fR method accepts tha name of a gangbangin' flag as its first
argument n' a list of one or mo' lyrics sequence numbers, or a
single reference ta a array of one or mo' message sequence numbers,
as its next argument(s).  It then sets tha flag specified fo' them
message(s).  Of course, if tha \*(L"Uid\*(R" parameta is set ta a true
value then dem message sequence numbers had betta be unique message
id's, just as you'd expect.
.PP
Note dat when specifyin tha flag up in question, tha preceding
backslash (\e) is entirely optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  (For you, dat is.
Mail::IMAPClient still has remember ta stick it up in there before
passin tha command ta tha server if tha flag is one of tha reserved
flags specified up in \s-1RFC3501. \s0 This is up in fact so blingin dat the
method checks its argument n' addz tha backslash when necessary,
which is why you don't gotta worry bout it overly much.)
.SS "setacl"
.IX Subsection "setacl"
Example:
.PP
.Vb 2
\&  $imap\->setacl( $folder, $userid, $aclstrin )
\&    or take a thugged-out dirtnap "Could not set acl: $@\en";
.Ve
.PP
Da \fBsetacl\fR method accepts three input arguments, a gangbangin' folda name, a
user id (or authentication identifier, ta use tha terminologizzle of
\&\s-1RFC2086\s0), n' a access muthafuckin rights modification string.  See \s-1RFC2086\s0 for
more shiznit. I aint talkin' bout chicken n' gravy biatch.  (This is somewhat experimenstrual n' its
implementation may chizzle.)
.SS "since"
.IX Subsection "since"
Example:
.PP
.Vb 2
\&  mah @msgs = $imap\->since($date)
\&    or warn "Could not find any lyrics since $date: $@\en";
.Ve
.PP
Da \fBsince\fR method accepts a thugged-out date up in either epoch format (seconds
since 1/1/1970, or as output by \*(L"time\*(R" up in perlfunc n' as accepted by
\&\*(L"localtime\*(R" up in perlfunc) or up in tha \fIdate_text\fR format as defined in
\&\s-1RFC3501 \s0(dd-Mon-yyyy, where Mon is tha Gangsta-language three-letter
abbreviation fo' tha month).  It searches fo' shit up in tha currently
selected folda fo' lyrics whose internal dates is on or afta the
dizzle whose date is provided as tha argument.  It uses tha internal
system date fo' a message ta determine if dat message was busted since
the given date.
.PP
In tha case of arguments supplied as a fuckin shitload of seconds, tha returned
result list will include shit whose internal date is on or afta that
day, regardless of whether they arrived before tha specified time on
that day.
.PP
If \fBsince\fR is called up in a list context then it will return a list of
lyrics meetin tha \fI\s-1SEARCH SINCE\s0\fR criterion, or a empty list if no
lyrics hook up tha criterion.
.PP
If \fBsince\fR is called up in a scalar context then it will return a
reference ta a array of lyrics meetin tha \fI\s-1SEARCH SINCE\s0\fR
criterion, or \f(CW\*(C`undef\*(C'\fR if no lyrics hook up tha criterion.
.PP
Since \fBsince\fR be a gangbangin' front-end ta \*(L"search\*(R", a shitload of tha same rules
apply.  For example, tha \f(CW$@\fR variable will always be cleared before
the \fI\s-1SEARCH\s0\fR command is issued ta tha server, n' will thus remain
empty unless tha server gives a \fI\s-1BAD\s0\fR or \fI\s-1NO\s0\fR response ta the
\&\fI\s-1SEARCH\s0\fR command.
.SS "size"
.IX Subsection "size"
Example:
.PP
.Vb 2
\&  mah $size = $imap\->size($msgId)
\&    or take a thugged-out dirtnap "Could not find size of message $msgId: $@\en";
.Ve
.PP
Da \fBsize\fR method accepts one input argument, a sequence number (or
message \s-1UID\s0 if tha \*(L"Uid\*(R" parameta is true).  It returns tha size of
the message up in tha currently selected folda wit tha supplied
sequence number (or \s-1UID\s0).  Da IMAPClient object must be up in a
\&\fISelected\fR state up in order ta use dis method.
.SS "sort"
.IX Subsection "sort"
Example:
.PP
.Vb 2
\&  mah @msgs = $imap\->sort(@args);
\&  warn "Error up in sort: $@\en" if $@;
.Ve
.PP
Da \fBsort\fR method is just like tha \*(L"search\*(R" method, only different.
It implements tha \s-1SORT\s0 extension as busted lyrics bout in
\&\fIhttp://search.ietf.org/internet\-drafts/draft\-ietf\-imapext\-sort\-10.txt\fR.
It would be wise ta use tha \*(L"has_capability\*(R" method ta verify that
the \s-1SORT\s0 capabilitizzle be available on yo' server before tryin ta use
the \fBsort\fR method. Y'all KNOW dat shit, muthafucka!  If you forget ta check n' you connectin ta a
server dat aint gots tha \s-1SORT\s0 capabilitizzle then \fBsort\fR will return
undef.  \*(L"LastError\*(R" will then say yo ass is \*(L"\s-1BAD\*(R". \s0 If yo' server
doesn't support tha \s-1SORT\s0 capabilitizzle then you gonna gotta use \*(L"search\*(R"
and then sort tha thangs up in dis biatch yo ass.
.PP
Da first argument ta \fBsort\fR be a space-delimited list of sorting
criteria.  Da Internizzle Draft dat raps bout \s-1SORT\s0 requires dat this
list be wrapped up in parentheses, even if there is only one sort
criterion. I aint talkin' bout chicken n' gravy biatch.  If you forget tha parentheses then tha \fBsort\fR method will
add em.  But you gotta forget both of them, or none.  This aint
\&\s-1CMS\s0 hustlin under \s-1VM\s0!
.PP
Da second argument be a cold-ass lil characta set ta use fo' sorting.  Different
characta sets use different sortin orders, so dis argument is
important.  Since all servers must support \s-1UTF\-8\s0 n' US-ASCII if they
support tha \s-1SORT\s0 capabilitizzle at all, you can use one of dem if you
don't have some other preferred characta set up in mind.
.PP
Da rest of tha arguments is searchin criteria, just as you would
supply ta tha \*(L"search\*(R" method. Y'all KNOW dat shit, muthafucka!  These is all documented up in \s-1RFC3501.\s0
If you just want all of tha lyrics up in tha currently selected folder
returned ta you up in sorted order, use \fI\s-1ALL\s0\fR as yo' only search
criterion.
.PP
Da \fBsort\fR method returns a array containin sequence numbers of
lyrics dat passed tha \s-1SORT IMAP\s0 client commandz search criteria.
If tha \*(L"Uid\*(R" parameta is legit then tha array will contain message
\&\s-1UID\s0's.  If \fBsort\fR is called up in scalar context then a pointa ta the
array is ghon be passed, instead of tha array itself.  Da message
sequence numbers or unique identifiers is ordered accordin ta the
sort criteria specified. Y'all KNOW dat shit, muthafucka!  Da sort criteria is nested up in tha order
specified; dat is, shit is sorted first by tha straight-up original gangsta criterion, and
within tha straight-up original gangsta criterion they is sorted by tha second criterion,
and so on.
.PP
Da sort method will clear \f(CW$@\fR before attemptin tha \fI\s-1SORT\s0\fR
operation just as tha \*(L"search\*(R" method do.
.SS "starttls"
.IX Subsection "starttls"
Example:
.PP
.Vb 1
\&  $imap\->starttls() or take a thugged-out dirtnap "starttls failed: $@\en";
.Ve
.PP
Da \fBstarttls\fR method accepts no arguments, n' you can put dat on yo' toast.  This method is used to
upgrade a exitin connection which aint authenticated ta a \s-1TLS/SSL\s0
connection by rockin tha \s-1IMAP STARTTLS\s0 command followed by rockin the
\&\fBstart_SSL\fR class method from IO::Socket::SSL ta do tha necessary
\&\s-1TLS\s0 negotiation. I aint talkin' bout chicken n' gravy biatch.  Da negotiation is done up in a funky-ass blockin fashizzle wit a
default \fBTimeout\fR of 30 seconds.  Da arguments used up in tha call to
\&\fBstart_SSL\fR can be controlled by settin tha Mail::IMAPClient
\&\*(L"Starttls\*(R" attribute ta a \s-1ARRAY\s0 reference containin tha desired
arguments.
.PP
Version note: method added up in Mail::IMAPClient 3.22
.SS "status"
.IX Subsection "status"
Example:
.PP
.Vb 2
\&  mah @rawdata = $imap\->status( $folder, qw/(Lyrics)/ )
\&    or take a thugged-out dirtnap "Error obtainin status: $@\en";
.Ve
.PP
Da \fBstatus\fR method accepts one argument, tha name of a gangbangin' folda (or
mailbox, ta use \s-1RFC3501\s0z terminology), n' returns a array
containin tha thangs up in dis biatch of hustlin tha \s-1IMAP STATUS\s0 client command
against dat folda n' shit.  If additionizzle arguments is supplied then they
are appended ta tha \s-1IMAP STATUS\s0 client command string, separated from
the rest of tha strang n' each other wit spaces.
.PP
If \fBstatus\fR aint called up in a array context then it returns a
reference ta a array rather than tha array itself.
.PP
Da \fBstatus\fR method should not be trippin wit tha \fBStatus\fR method
(with a uppercase 'S'), which returns shiznit bout the
IMAPClient object.  (See tha section labeled \*(L"Status Methods\*(R",
below).
.SS "store"
.IX Subsection "store"
Example:
.PP
.Vb 1
\&  $imap\->store(@args) or take a thugged-out dirtnap "Could not store: $@\en";
.Ve
.PP
Da \fBstore\fR method accepts a message sequence number or
comma-separated list of message sequence numbers as a gangbangin' first argument,
a message data item name, n' a value fo' tha message data item.
Currently, data shit is tha word \*(L"\s-1FLAGS\*(R"\s0 followed by a space n' a
list of flags (in parens).  Da word \*(L"\s-1FLAGS\*(R"\s0 can be modified by
prefixin it wit either a \*(L"+\*(R" or a \*(L"\-\*(R" (to indicate \*(L"add these flags\*(R"
or \*(L"remove these flags\*(R") n' by suffixin it wit \*(L".SILENT\*(R" (which
reduces tha amount of output from tha server; straight-up useful wit large
message sets).  Normally you won't need ta booty-call \fBstore\fR cuz there
are oodlez of methodz dat will invoke store fo' you wit tha erect
arguments, n' you can put dat on yo' toast.  Furthermore, these methodz is playalier n' more
flexible wit regardz ta how tha fuck you specify yo' arguments, n' you can put dat on yo' toast.  See for
example \*(L"see\*(R", \*(L"deny_seeing\*(R", \*(L"delete_message\*(R", and
\&\*(L"restore_message\*(R".  Or \*(L"mark\*(R", \*(L"unmark\*(R", \*(L"set_flag\*(R", and
\&\*(L"unset_flag\*(R".
.SS "subject"
.IX Subsection "subject"
Example:
.PP
.Vb 1
\&  mah $subject = $imap\->subject($msg);
.Ve
.PP
Da \fBsubject\fR method accepts one argument, a message sequence number
(or a message \s-1UID,\s0 if tha \fIUid\fR parameta is true).  Da text up in the
\&\*(L"Subject\*(R" header of dat message is returned (without tha \*(L"Subject: \*(R"
prefix).  This method be a gangbangin' finger-lickin' dirty-ass short-cut for:
.PP
.Vb 1
\&  mah $subject = $imap\->get_header($msg, "Subject");
.Ve
.SS "subscribed"
.IX Subsection "subscribed"
Example:
.PP
.Vb 2
\&  mah @subscribedFoldaz = $imap\->subscribed
\&    or warn "Could not find subscribed folders: $@\en";
.Ve
.PP
Da \fBsubscribed\fR method works like tha \fBfolders\fR method, above,
except dat tha returned list (or array reference, if called up in scalar
context) gotz nuff only tha subscribed folders.
.PP
Like \*(L"folders\*(R", you can optionally provide a prefix argument ta the
\&\fBsubscribed\fR method.
.SS "tag_and_run"
.IX Subsection "tag_and_run"
Example:
.PP
.Vb 2
\&  mah $output = $imap\->tag_and_run(@args)
\&    or take a thugged-out dirtnap "Could not tag_and_run: $@\en";
.Ve
.PP
Da \fBtag_and_run\fR method accepts one or two arguments, n' you can put dat on yo' toast.  Da first
argument be a strang containin a \s-1IMAP\s0 Client command, without a tag
but wit all required arguments, n' you can put dat on yo' toast.  Da optionizzle second argument be a
strin ta look fo' dat will indicate success (without pattern
delimiters).  Da default is \f(CW\*(C`OK.*\*(C'\fR.
.PP
Da \fBtag_and_run\fR method will prefix yo' strang (from tha first
argument) wit tha next transaction number n' run tha command. Y'all KNOW dat shit, muthafucka!  It
returns a array of output lines from tha command, which yo ass is free
to parse as you peep fit.  Usin dis method instead of \fBrun\fR (above)
will free you from havin ta worry bout handlin tha tags (and from
worryin bout tha side affectz of namin yo' own tags).
.SS "uidexpunge"
.IX Subsection "uidexpunge"
Example:
.PP
.Vb 1
\&  $imap\->uidexpunge(@uids) or take a thugged-out dirtnap "Could not uidexpunge: $@\en";
.Ve
.PP
Da \fBuidexpunge\fR method implements tha \s-1UID EXPUNGE IMAP \s0(\s-1RFC4315
UIDPLUS\s0 ext) client command ta permanently remove all lyrics that
have tha \eDeleted flag set n' gotz a \s-1UID\s0 dat is included up in tha list
of UIDs.
.PP
\&\fBuidexpunge\fR returns a array or arrayref (scalar context) of output
lines returned from tha \s-1UID EXPUNGE\s0 command.
.PP
\&\fBuidexpunge\fR returns undef on failure.
.PP
If tha server do not support tha \s-1UIDPLUS\s0 extension, dis method
returns undef.
.SS "uidnext"
.IX Subsection "uidnext"
Example:
.PP
.Vb 1
\&  mah $nextUid = $imap\->uidnext($folder) or take a thugged-out dirtnap "Could not uidnext: $@\en";
.Ve
.PP
Da \fBuidnext\fR method accepts one argument, tha name of a gangbangin' folder, and
returns tha numeric strang dat is tha next available message \s-1UID\s0 for
that folder.
.SS "thread"
.IX Subsection "thread"
Example:
.PP
.Vb 1
\&  mah $thread = $imap\->thread($algorithm, $charset, @search_args );
.Ve
.PP
Da \fBthread\fR method accepts zero ta three arguments, n' you can put dat on yo' toast.  Da first
argument is tha threadin algorithm ta use, generally either
\&\fI\s-1ORDEREDSUBJECT\s0\fR or \fI\s-1REFERENCES\s0\fR.  Da second argument is the
characta set ta use, n' tha third argument is tha set of search
arguments ta use.
.PP
If tha algorithm aint supplied, it defaults ta \fI\s-1REFERENCES\s0\fR if
available, or \fI\s-1ORDEREDSUBJECT\s0\fR if available.  If neither of these is
available then tha \fBthread\fR method returns undef.
.PP
If tha characta set aint specified it will default ta \fI\s-1UTF\-8\s0\fR.
.PP
If tha search arguments is not specified, tha default is \fI\s-1ALL\s0\fR.
.PP
If \fBthread\fR is called fo' a object connected ta a server dat do
not support tha \s-1THREADS\s0 extension then tha \fBthread\fR method will
return \f(CW\*(C`undef\*(C'\fR.
.PP
Da \fBthreads\fR method will issue tha \fI\s-1THREAD\s0\fR command as defined in
\&\fIhttp://www.ietf.org/internet\-drafts/draft\-ietf\-imapext\-thread\-11.txt\fR.
It returns a array of threads.  Each element up in tha array is either a
message id or a reference ta another array of (sub)threads.
.PP
If tha \*(L"Uid\*(R" parameta is set ta a legit value then tha message id's
returned up in tha thread structure is ghon be message \s-1UID\s0's.  Otherwise
they is ghon be message sequence numbers.
.SS "uidvalidity"
.IX Subsection "uidvalidity"
Example:
.PP
.Vb 2
\&  mah $validitizzle = $imap\->uidvalidity($folder)
\&    or take a thugged-out dirtnap "Could not uidvalidity: $@\en";
.Ve
.PP
Da \fBuidvalidity\fR method accepts one argument, tha name of a gangbangin' folder,
and returns tha numeric strang dat is tha unique identifier validity
value fo' tha folder.
.SS "unmark"
.IX Subsection "unmark"
Example:
.PP
.Vb 1
\&  $imap\->unmark(@msgs) or take a thugged-out dirtnap "Could not unmark: $@\en";
.Ve
.PP
Da \fBunmark\fR method accepts a list of one or mo' lyrics sequence
numbers, or a single reference ta a array of one or mo' message
sequence numbers, as its argument(s).  It then unsets tha \fI\eFlagged\fR
flag fo' dem message(s).  Of course, if tha \*(L"Uid\*(R" parameta is set
to a legit value then dem message sequence numbers should straight-up be
unique message id's.
.PP
Note dat specifyin \f(CW\*(C`$imap\->unmark(@msgs)\*(C'\fR is just a gangbangin' finger-lickin' dirty-ass shortcut
for specifyin \f(CW\*(C`$imap\->unset_flag("Flagged",@msgs)\*(C'\fR.
.PP
Note also dat tha \fI\eFlagged\fR flag is just one of nuff possible
flags.  This be a lil confusin yo, but you gonna gotta git used ta the
idea dat among tha reserved flags specified up in \s-1RFC3501\s0 is one name
\&\fI\eFlagged\fR.  There is no specific meanin fo' dis flag; it means
whatever tha mailbox balla (or delegate) wants it ta mean when it is
turned on.
.SS "unseen"
.IX Subsection "unseen"
Example:
.PP
.Vb 1
\&  mah @unread = $imap\->unseen or warn "Could not find unseen msgs: $@\en";
.Ve
.PP
Da \fBunseen\fR method performs a \s-1IMAP SEARCH UNSEEN\s0 search against the
selected folda n' returns a array of sequence numberz of lyrics
that aint yet been peeped (ie they \fI\eSeen\fR flag aint set).  If
the \*(L"Uid\*(R" parameta is legit then a array of message \s-1UID\s0z will be
returned instead. Y'all KNOW dat shit, muthafucka!  If called up in scalar context than a pointa ta the
array (rather than tha array itself) is ghon be returned.
.PP
Note dat when specifyin tha flag up in question, tha preceding
backslash (\e) is entirely optional.
.SS "unseen_count"
.IX Subsection "unseen_count"
Example:
.PP
.Vb 4
\&  foreach mah $f ($imap\->folders) {
\&      print "Da $f folda has ",
\&        $imap\->unseen_count($f)||0, " unseen lyrics.\en";
\&  }
.Ve
.PP
Da \fBunseen_count\fR method accepts tha name of a gangbangin' folda as a argument
and returns tha number of unseen lyrics up in dat folda n' shit.  If no
folda argument is provided then it returns tha number of unseen
lyrics up in tha currently selected Folder.
.SS "unset_flag"
.IX Subsection "unset_flag"
Example:
.PP
.Vb 2
\&  $imap\->unset_flag( "\eSeen", @msgs )
\&    or take a thugged-out dirtnap "Could not unset_flag: $@\en";
.Ve
.PP
Da \fBunset_flag\fR method accepts tha name of a gangbangin' flag as its first
argument n' a list of one or mo' lyrics sequence numbers, or a
single reference ta a array of one or mo' message sequence numbers,
as its next argument(s).  It then unsets tha flag specified fo' them
message(s).  Of course, if tha \*(L"Uid\*(R" parameta is set ta a true
value then dem message sequence numbers had betta be unique message
id's, just as you'd expect.
.SH "Other IMAP Client Commands"
.IX Header "Other IMAP Client Commands"
Until release \f(CW2.99\fR, when you called a method which did not exist,
they where automatically translated tha fuck into a \s-1IMAP\s0 call wit tha same
name via a \s-1AUTOLOAD\s0 hack.  This \*(L"feature\*(R" was removed fo' various
reasons: playas made typos up in tha capitalization of method names, and
the program still seemed ta work erectly.  Besides, it blocked
further pimpment of dis module, cuz playas did not contribute
their private extensions ta tha protocol implementation.
.ie n .SS "copy($msg, $folder)"
.el .SS "copy($msg, \f(CW$folder\fP)"
.IX Subsection "copy($msg, $folder)"
Copy a message from tha currently selected folda up in tha folda whose
name is up in \f(CW$folder\fR
.SS "subscribe($folder)"
.IX Subsection "subscribe($folder)"
Subscribe ta a gangbangin' folder
.PP
\&\fB\s-1CAUTION:\s0\fR Once again, remember ta quote yo' quotes (or use the
\&\*(L"Quote\*(R" method) if you want quotes ta be part of tha \s-1IMAP\s0 command
string.
.PP
Yo ass can also use tha default method ta override tha behavior of
implemented \s-1IMAP\s0 methodz by changin tha case of tha method name,
preferably ta all-uppercase so as not ta conflict wit tha Class
method n' accessor method namespace.  For example, if you don't want
the \*(L"search\*(R" methodz behavior (which returns a list of message
numbers) but would rather have a array of raw data returned from your
\&\*(L"search\*(R" operation, you can issue tha followin snippet:
.PP
.Vb 1
\&  mah @raw = $imap\->SEARCH("SUBJECT","Whatever...");
.Ve
.PP
which is slightly mo' efficient than tha equivalent:
.PP
.Vb 2
\&  $imap\->search("SUBJECT","Whatever...");
\&  mah @raw = $imap\->Results;
.Ve
.PP
Of course you probably want tha search thangs up in dis biatch tucked sickly tha fuck into a
list fo' you anyway, up in which case you might as well use the
\&\*(L"search\*(R" method.
.SH "Parameters"
.IX Header "Parameters"
There is nuff muthafuckin parametas dat influence tha behavior of an
IMAPClient object.  Each is set by specifyin a named value pair
durin freshly smoked up method invocation as bigs up:
.PP
.Vb 4
\&  mah $imap = Mail::IMAPClient\->new ( parameta  => "value",
\&      parameter2 => "value",
\&      ...
\&  );
.Ve
.PP
Parametas can also be set afta a object has been instantiated by
usin tha parameterz eponymous accessor method like this:
.PP
.Vb 3
\&  mah $imap = Mail::IMAPClient\->new;
\&     $imap\->parameter( "value");
\&     $imap\->parameter2("value");
.Ve
.PP
Da eponymous accessor methodz can also be used without arguments to
obtain tha current value of tha parameta as bigs up:
.PP
.Vb 3
\&  mah $imap = Mail::IMAPClient\->new;
\&     $imap\->parameter( "value");
\&     $imap\->parameter2("value");
\&
\&    ...    # A whole bunch of phat Perl code, omitted fo' brevity
\&
\&  mah $forgot  = $imap\->parameter;
\&  mah $forgot2 = $imap\->parameter2;
.Ve
.PP
Note dat up in these examplez I be rockin 'parameter' n' 'parameter2' as
generic parameta names.  Da IMAPClient object don't straight-up have
parametas named 'parameter' n' 'parameter2'.  On tha contrary, the
available parametas are:
.SS "Authmechanism"
.IX Subsection "Authmechanism"
Example:
.PP
.Vb 3
\&  $imap\->Authmechanism("CRAM\-MD5");
\&  # or
\&  mah $authmech = $imap\->Authmechanism();
.Ve
.PP
If specified, tha \fIAuthmechanism\fR causes tha specified authentication
mechanizzle ta be used whenever Mail::IMAPClient would otherwise invoke
\&\fBlogin\fR.  If tha value specified fo' tha \fIAuthmechanism\fR parameter
is not a valid authentication mechanizzle fo' yo' server then you will
never eva be able ta log up in again n' again n' again fo' tha rest of yo' Perl script,
probably.  So you might wanna check, like this:
.PP
.Vb 2
\&  mah $authmech = "CRAM\-MD5";
\&  $imap\->has_capability($authmech) n' $imap\->Authmechanism($authmech);
.Ve
.PP
Of course if you know yo' server supports yo' straight-up authentication
mechanizzle then you know, so you can then include yo' \fIAuthmechanism\fR
with yo' \fBnew\fR call, as in:
.PP
.Vb 7
\&  mah $imap = Mail::IMAPClient\->new(
\&      User    => $user,
\&      Passord => $passord,
\&      Server  => $server,
\&      Authmechanizzle  => $authmech,
\&      %etc
\&  );
.Ve
.PP
If \fIAuthmechanism\fR is supplied but \fIAuthcallback\fR aint then you
had betta be supportin one of tha authentication mechanizzlez that
Mail::IMAPClient supports \*(L"out of tha box\*(R" (like fuckin \s-1CRAM\-MD5\s0).
.SS "Authcallback"
.IX Subsection "Authcallback"
Example:
.PP
.Vb 1
\&  $imap\->Authcallback( \e&callback );
.Ve
.PP
This specifies a thugged-out default callback ta tha default authentication
mechanizzle (see \*(L"Authmechanism\*(R", above).  Together, these two methods
replace automatic calls ta login wit automatic calls dat look like
this (sort of):
.PP
.Vb 1
\&  $imap\->authenticate($imap\->Authmechanism,$imap\->Authcallback);
.Ve
.PP
If \fIAuthmechanism\fR is supplied but \fIAuthcallback\fR aint then you
had betta be supportin one of tha authentication mechanizzlez that
Mail::IMAPClient supports \*(L"out of tha box\*(R" (like fuckin \s-1CRAM\-MD5\s0).
.SS "Authuser"
.IX Subsection "Authuser"
Da \fIAuthuser\fR parameta is used by tha \s-1DIGEST\-MD5 \s0\*(L"Authmechanism\*(R".
.PP
Typically when you authenticate tha username specified up in tha User
parameta is used. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat when rockin tha \s-1DIGEST\-MD5
\&\s0\fIAuthmechanism\fR tha \fIAuthuser\fR can be used ta specify a gangbangin' finger-lickin' different
username fo' tha login.
.PP
This can be useful ta mark lyrics as peeped fo' tha \fIAuthuser\fR if you
don't give a fuck tha password of tha user as tha peeped state is often a
per-user state.
.SS "Buffer"
.IX Subsection "Buffer"
Example:
.PP
.Vb 3
\&  $Buffer = $imap\->Buffer();
\&  # or:
\&  $imap\->Buffer($new_value);
.Ve
.PP
Da \fIBuffer\fR parameta sets tha size of a funky-ass block of I/O.  It is
ignored unless \*(L"Fast_io\*(R", below, is set ta a legit value (the
default), or unless yo ass is rockin tha \*(L"migrate\*(R" method. Y'all KNOW dat shit, muthafucka!  It aint nuthin but value
should be tha number of bytes ta attempt ta read up in one I/O operation.
Da default value is 4096.
.PP
When rockin tha \*(L"migrate\*(R" method, you can often big up dramatic
improvements up in throughput by adjustin dis number upward. Y'all KNOW dat shit, muthafucka!  However,
fuckin wit so also entails a memory cost, so if set too high you risk
losin all tha benefitz of tha \*(L"migrate\*(R" methodz chunking
algorithm.  Yo crazy-ass program can thus terminizzle wit a \*(L"out of memory\*(R"
error n' you gonna have no one but yo ass ta blame.
.PP
Note that, as hinted above, tha \fIBuffer\fR parameta affects the
behavior of tha \*(L"migrate\*(R" method regardless of whether you have
\&\*(L"Fast_io\*(R" turned on. I aint talkin' bout chicken n' gravy biatch.  Believe me, you don't wanna go around
migratin tonz of mail without rockin buffered I/O!
.SS "Clear"
.IX Subsection "Clear"
Example:
.PP
.Vb 3
\&  $Clear = $imap\->Clear();
\&  # or:
\&  $imap\->Clear($integer);
.Ve
.PP
Da name of dis parameter, fo' oldschool reasons, is somewhat
misleading.  It should be named \fIWrap\fR, cuz it specifies how tha fuck many
transactions is stored up in tha wrapped history buffer n' shit.  But it didn't
always work dat way; tha buffer used ta straight-up git cleared. Y'all KNOW dat shit, muthafucka!  The
name though remains tha same ol' dirty up in tha interestz of backwards
compatibility.
.PP
\&\fIClear\fR specifies dat tha objectz history buffer should be wrapped
afta every last muthafuckin \fIn\fR transactions, where \fIn\fR is tha value specified for
the \fIClear\fR parameter n' shit.  Callin tha eponymous \fBClear\fR method without
an argument will return tha current value of tha \fIClear\fR parameter
but aint gonna cause clear tha history buffer ta wrap.
.PP
Settin \fIClear\fR ta 0 turns off automatic history buffer wrapping, and
settin it ta 1 turns off tha history buffer facilitizzle (except fo' the
last transaction, which cannot be disabled without breakin the
IMAPClient module).  Settin \fIClear\fR ta 0 aint gonna cause a immediate
clearin of tha history buffer; settin it ta 1 (or any other number)
will (except of course fo' dat inevitable last transaction).
.PP
Da default \fIClear\fR value is set ta five (5) up in order ta conserve
memory.
.SS "Compress"
.IX Subsection "Compress"
If set, Mail::IMAPClient attempts ta enable use of tha \s-1RFC4978
COMPRESS DEFLATE\s0 extension. I aint talkin' bout chicken n' gravy biatch.  This requires dat tha server supports
this \s-1CAPABILITY. \s0 This attribute can be set ta a legit value ta enable
or a \s-1ARRAYREF\s0 ta control tha arguments used up in tha call to
\&\fICompress::Zlib::deflateInit()\fR.
.PP
Mail::IMAPClient will automatically use Compress::Zlib to
deflate/inflate tha data to/from tha server n' shit.  This attribute is used
in tha \*(L"login\*(R" method.
.PP
See also \*(L"compress\*(R" n' \*(L"capability\*(R".
.PP
Version note: attribute added up in Mail::IMAPClient 3.30
.SS "Debug"
.IX Subsection "Debug"
Example:
.PP
.Vb 3
\&  $Debug = $imap\->Debug();
\&  # or:
\&  $imap\->Debug($true_or_false);
.Ve
.PP
Sets tha debuggin flag ta either a legit or false value.  Can be
supplied wit tha \*(L"new\*(R" method call or separately by callin the
\&\fBDebug\fR object method. Y'all KNOW dat shit, muthafucka!  Use of dis parameta is straight fuckin recommended
when debuggin scripts n' required when reportin bugs.
.SS "Debug_fh"
.IX Subsection "Debug_fh"
Example:
.PP
.Vb 3
\&  $Debug_fh = $imap\->Debug_fh();
\&  # or:
\&  $imap\->Debug_fh($fileHandle);
.Ve
.PP
Specifies tha file handle ta which debuggin shiznit should be
printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  It can either a gangbangin' file handle object reference or a gangbangin' file handle
glob.  Da default is ta print debuggin info ta \s-1STDERR.\s0
.PP
For example, you can:
.PP
.Vb 8
\&  use Mail::IMAPClient;
\&  use IO::File;
\&  # set $user, $pass, n' $server here
\&  mah $dh = IO::File\->new(">debugging.output")
\&    or take a thugged-out dirtnap "Can\*(Aqt open debugging.output: $!\en";
\&  mah $imap = Mail::IMAPClient\->new(
\&      User=>$user, Password=>$pass, Server=>$server, Debug=>1, Debug_fh => $dh
\&  );
.Ve
.PP
which is tha same ol' dirty as:
.PP
.Vb 11
\&  use Mail::IMAPClient;
\&  use IO::File;
\&  # set $user, $pass, n' $server here
\&  mah $imap = Mail::IMAPClient\->new(
\&      User     => $user,
\&      Password => $pass,
\&      Server   => $server,
\&      Debug    => "yes, please",
\&      Debug_fh => IO::File\->new(">debugging.output")
\&        || take a thugged-out dirtnap "Can\*(Aqt open debugging.output: $!\en"
\&  );
.Ve
.PP
Yo ass can also:
.PP
.Vb 7
\&  use Mail::IMAPClient;
\&  # set $user, $pass, n' $server here
\&  open(DBG,">debugging.output")
\&    or take a thugged-out dirtnap "Can\*(Aqt open debugging.output: $!\en";
\&  mah $imap = Mail::IMAPClient\->new(
\&    User=>$user, Password=>$pass, Server=>$server, Debug=> 1, Debug_fh => *DBG
\&  );
.Ve
.PP
Specifyin dis parameta aint straight-up useful unless \*(L"Debug\*(R" is set
to a legit value.
.SS "Domain"
.IX Subsection "Domain"
Da \fIDomain\fR parameta is used by tha \s-1NTLM \s0\*(L"Authmechanism\*(R".  The
domain be a optionizzle parameta fo' \s-1NTLM\s0 authentication.
.SS "EnableServerResponseInLiteral"
.IX Subsection "EnableServerResponseInLiteral"
Removed up in 2.99_01 (now autodetect)
.SS "Fast_io"
.IX Subsection "Fast_io"
Example:
.PP
.Vb 3
\&  $Fast_io = $imap\->Fast_io();
\&  # or:
\&  $imap\->Fast_io($true_or_false);
.Ve
.PP
Da \fIFast_io\fR parameta controls whether or not tha Mail::IMAPClient
object will attempt ta use non-blockin I/O on tha \s-1IMAP\s0 socket.  It is
turned on by default (unless tha calla serves up tha socket ta be
used).
.PP
See also \*(L"Buffer\*(R".
.SS "Folder"
.IX Subsection "Folder"
Example:
.PP
.Vb 3
\&  $Folda = $imap\->Folder();
\&  # or:
\&  $imap\->Folder($new_value);
.Ve
.PP
Da \fIFolder\fR parameta returns tha name of tha currently-selected
folda (in case you forgot).  It can also be used ta set tha name of
the currently selected folder, which is straight-up unnecessary if you
used tha \*(L"select\*(R" method (or \*(L"select\*(R"z read-only equivalent, the
\&\*(L"examine\*(R" method) ta select dat shit.
.PP
Note dat settin tha \fIFolder\fR parameta do not automatically
select a freshly smoked up folder; you use tha \*(L"select\*(R" or \*(L"examine\*(R" object
methodz fo' dis shit.  Generally, tha \fIFolder\fR parameta should only be
queried (by rockin tha no-argument form of tha \fBFolder\fR method).  You
will only need ta set tha \fIFolder\fR parameta if you use some
mysterious technique of yo' own fo' selectin a gangbangin' folder, which you
probably won't do.
.SS "Ignoresizeerrors"
.IX Subsection "Ignoresizeerrors"
Certain (caching) servers, like Exchange 2007, often report tha wrong
message size.  Instead of choppin tha message tha fuck into a size dat it
fits tha specified size, tha reported size is ghon be simply ignored when
this parameta is set ta \f(CW1\fR.
.SS "Keepkickin it"
.IX Subsection "Keepkickin it"
Some firewalls n' network gear like ta timeout connections
prematurely if tha connection sits idle.  Da \fBKeepkickin it\fR parameter,
when set ta a legit value, affects tha behavior of \*(L"new\*(R" and
\&\*(L"Socket\*(R" by enablin \s-1SO_KEEPALIVE\s0 on tha socket.
.PP
Version note: attribute added up in Mail::IMAPClient 3.17
.SS "Maxcommandlength"
.IX Subsection "Maxcommandlength"
Da \fBMaxcommandlength\fR attribute is used by \fIfetch()\fR ta limit length
of commandz busted ta a server n' shit.  Da default is 1000 chars, following
the recommendation of \s-1RFC2683\s0 section 3.2.1.5.
.PP
\&\fBNote\fR: dis attribute should also be used fo' nuff muthafuckin other methods
but dis has not yet been implemented please feel free ta file bugs
for methodz where you run tha fuck into problems wit all dis bullshit.
.PP
This attribute should remove tha need fo' utilitizzles like imapsync to
create they own \fIsplit()\fR functions n' instead allows Mail::IMAPClient
to \s-1DWIM.\s0
.PP
In practice, dis parameta has proven ta be useful ta overcome a
limit of 8000 octets fo' UW-IMAPD n' 16384 octets fo' Courier/Cyrus
\&\s-1IMAP\s0 servers.
.PP
Version note: attribute added up in Mail::IMAPClient 3.17
.SS "Maxtemperrors"
.IX Subsection "Maxtemperrors"
Example:
.PP
.Vb 3
\&  $Maxtemperrors = $imap\->Maxtemperrors();
\&  # or:
\&  $imap\->Maxtemperrors($number);
.Ve
.PP
Da \fIMaxtemperrors\fR parameta specifies tha number of times a read or
write operation be allowed ta fail on a \*(L"Resource Temporarily
Available\*(R" (e.g. \s-1EAGAIN\s0) error. Shiiit, dis aint no joke.  Da default settin is \fIundef\fR which
means there is no limit.
.PP
Settin dis parameta ta tha strang \*(L"unlimited\*(R" (instead of undef) to
ignore \*(L"Resource Temporarily Unavailable\*(R" errors is deprecated.
.PP
\&\fBNote\fR: This settin should be used wit caution n' may be removed
in a gangbangin' future release.  Settin dis can cause methodz ta return ta the
calla before data is received (and then handled) properly thereby
possibly then leavin tha module up in a wack state.  In tha future, this
behavior may be chizzled up in a attempt ta avoid dis thang.
.SS "Password"
.IX Subsection "Password"
Example:
.PP
.Vb 3
\&  $Password = $imap\->Password();
\&  # or:
\&  $imap\->Password($new_value);
.Ve
.PP
Specifies tha password ta use when loggin tha fuck into tha \s-1IMAP\s0 steez on
the host specified up in tha \fIServer\fR parameta as tha user specified in
the \fIUser\fR parameter n' shit.  Can be supplied wit tha \fBnew\fR method call or
separately by callin tha \fBPassword\fR object method.
.PP
If \fIServer\fR, \fIUser\fR, n' \fIPassword\fR is all provided ta tha \*(L"new\*(R"
method, then tha newly instantiated object is ghon be connected ta the
host specified up in \fIServer\fR (at either tha port specified up in \fIPort\fR
or tha default port 143) n' then logged on as tha user specified in
the \fIUser\fR parameta (usin tha password provided up in tha \fIPassword\fR
parameter).  See tha rap of tha \*(L"new\*(R" method, below.
.SS "Peek"
.IX Subsection "Peek"
Example:
.PP
.Vb 3
\&  $Peek = $imap\->Peek();
\&  # or:
\&  $imap\->Peek($true_or_false);
.Ve
.PP
Settin \fIPeek\fR ta a legit value will prevent tha \*(L"body_string\*(R",
\&\*(L"message_string\*(R" n' \*(L"message_to_file\*(R" methodz from automatically
settin tha \fI\eSeen\fR flag.  Settin \*(L"Peek\*(R" ta 0 (zero) will force
\&\*(L"body_string\*(R", \*(L"message_string\*(R", \*(L"message_to_file\*(R", and
\&\*(L"parse_headers\*(R" ta always set tha \fI\eSeen\fR flag.
.PP
Da default is ta set tha peeped flag whenever you fetch tha body of a
message but not when you just fetch tha headers.  Passin \fIundef\fR to
the eponymous \fBPeek\fR method will reset tha \fIPeek\fR parameta ta its
pristine, default state.
.SS "Port"
.IX Subsection "Port"
Example:
.PP
.Vb 3
\&  $Port = $imap\->Port();
\&  # or:
\&  $imap\->Port($new_value);
.Ve
.PP
Specifies tha port on which tha \s-1IMAP\s0 server is listening.  A default
value of 993 (if \*(L"Ssl\*(R" is true) or 143 is set durin a cold-ass lil call to
\&\*(L"connect\*(R" if no value is provided by tha calla n' shit.  This argument can
be supplied wit tha \*(L"new\*(R" method call or separately by callin the
\&\*(L"Port\*(R" object method.
.SS "Prewritemethod"
.IX Subsection "Prewritemethod"
\&\fIPrewritemethod\fR parameta should contain a reference ta a subroutine
that will do \*(L"special thangs\*(R" ta data before it is busted ta tha \s-1IMAP\s0
server (like fuckin encryption or signing).
.PP
This method is ghon be called immediately prior ta bustin  a \s-1IMAP\s0 client
command ta tha server n' shit.  Its first argument be a reference ta the
\&\fIMail::IMAPClient\fR object n' tha second argument be a string
containin tha command dat is ghon be busted ta tha server n' shit.  Your
\&\fIPrewritemethod\fR should return a strang dat has been signed or
encrypted or whatever; dis returned strang is what tha fuck will straight-up be
sent ta tha server.
.PP
Yo crazy-ass \fIPrewritemethod\fR will probably need ta know mo' than dis ta do
whatever it do.  It be recommended dat you tuck all other pertinent
information tha fuck into a hash, n' store a reference ta dis hash somewhere
where yo' method can git ta it, possibly up in tha \fIMail::IMAPClient\fR
object itself.
.PP
Note dat dis method should not straight-up bust anythang over the
socket connection ta tha server; it merely converts data prior to
sending.
.PP
See also \*(L"Readmethod\*(R".
.SS "Ranges"
.IX Subsection "Ranges"
Example:
.PP
.Vb 8
\&  $imap\->Ranges(1);
\&  # or:
\&  mah $search = $imap\->search(@search_args);
\&  if ( $imap\->Ranges) { # $search be a MessageSet object
\&      print "This is mah condensed search result: $search\en";
\&      print "This is every last muthafuckin message up in tha search result: ",
\&        join(",",@$search),"\en;
\&  }
.Ve
.PP
If set ta a legit value, then tha \*(L"search\*(R" method will return a
Mail::IMAPClient::MessageSet object if called up in a scalar context,
instead of tha array reference dat \fBfetch\fR normally returns when
called up in a scalar context.  If set ta zero or if undefined, then
\&\fBsearch\fR will continue ta return a array reference when called in
scalar context.
.PP
This parameta has no affect on tha \fBsearch\fR method when \fBsearch\fR
is called up in a list context.
.SS "RawSocket"
.IX Subsection "RawSocket"
Example:
        \f(CW$socket\fR = \f(CW$imap\fR\->RawSocket;
        # or:
        \f(CW$imap\fR\->RawSocket($socketh);
.PP
Da \fIRawSocket\fR method can be used ta obtain tha socket handle of the
current connection (say, ta do I/O on tha connection dat is not
otherwise supported by Mail::IMAPClient) or ta replace tha current
socket wit a freshly smoked up handle (for instizzle a \s-1SSL\s0 handle, see
IO::Socket::SSL yo, but be shizzle ta peep tha \*(L"Socket\*(R" method as well).
.PP
If you supply a socket handle yo ass, either by bustin suttin' like:
.PP
.Vb 1
\&        $imap=Mail::IMAPClient\->new(RawSocket => $sock, User => ... );
.Ve
.PP
or by bustin suttin' like:
.PP
.Vb 4
\&        $imap = Mail::IMAPClient\->new(User => $user,
\&                    Password => $pass, Server => $host);
\&        # blah blah blah
\&        $imap\->RawSocket($ssl);
.Ve
.PP
then it is ghon be up ta you ta establish tha connection \s-1AND\s0 to
authenticate, either via tha \*(L"login\*(R" method, or tha fancier
\&\*(L"authenticate\*(R", or, since you know so much anyway, by just bustin raw
I/O against tha socket until you logged in. I aint talkin' bout chicken n' gravy biatch.  If you do any of this
then you should also set tha \*(L"State\*(R" parameta yo ass ta reflect
the current state of tha object (i.e. Connected, Authenticated, etc).
.PP
Note dat no operation is ghon be attempted on tha socket when this
method is called. Y'all KNOW dat shit, muthafucka!  In particular, afta tha \s-1TCP\s0 connections towards
the \s-1IMAP\s0 server is established, tha protocol mandates tha server to
send a initial greetin message, n' yo big-ass booty is ghon gotta explicitly cope
with dis message before bustin any other operation, e.g. tryin to
call \*(L"login\*(R". Caveat emptor.
.PP
For a mo' \s-1DWIM\s0 approach ta settin tha socket peep \*(L"Socket\*(R".
.SS "Readmethod"
.IX Subsection "Readmethod"
Example:
.PP
.Vb 7
\&  $imap\->Readmethod(   # IMAP, HANDLE, BUFFER, LENGTH, OFFSET
\&      sub {
\&          mah ( $self, $handle, $buffer, $count, $offset ) = @_;
\&          mah $rc = sysread( $handle, $$buffer, $count, $offset );
\&          # do suttin' useful here...
\&      }
\&  );
.Ve
.PP
\&\fBReadmethod\fR should contain a reference ta a subroutine dat will
replace sysread. Y'all KNOW dat shit, muthafucka!  Da subroutine is ghon be passed tha following
arguments: first tha used Mail::IMAPClient object.  Second, a
reference ta a socket.  Third, a reference ta a scalar variable into
which data is read (\s-1BUFFER\s0). Da data placed here should be \*(L"finished
data\*(R", so if yo ass is decryptin or removin signatures then be shizzle to
do dat before you place data tha fuck into dis buffer n' shit.  Fourth, tha number of
bytes axed ta be read; tha \s-1LENGTH\s0 of tha request.  Lastly, the
\&\s-1OFFSET\s0 tha fuck into tha \s-1BUFFER\s0 where tha data should be read. Y'all KNOW dat shit, muthafucka!  If not supplied
it should default ta zero.
.PP
Note dat dis method straight-up replaces readz from tha connection
to tha server, so if you define one of these then yo' subroutine will
have ta straight-up do tha read. Y'all KNOW dat shit, muthafucka!  It be fo' thangs like dis dat our crazy asses have
the \*(L"Socket\*(R" parameta n' eponymous accessor method.
.PP
Yo crazy-ass \fIReadmethod\fR will probably need ta know mo' than dis ta do
whatever it do.  It be recommended dat you tuck all other pertinent
information tha fuck into a hash, n' store a reference ta dis hash somewhere
where yo' method can git ta it, possibly up in tha \fIMail::IMAPClient\fR
object itself.
.PP
See also \*(L"Prewritemethod\*(R".
.SS "Readmoremethod"
.IX Subsection "Readmoremethod"
\&\fBReadmoremethod\fR should contain a reference ta a subroutine dat will
replace/enhizzle tha behavior of tha internal \fI_read_more()\fR method. Y'all KNOW dat shit, muthafucka!  The
subroutine is ghon be passed tha followin arguments: first tha used
Mail::IMAPClient object.  Second, a reference ta a socket.  Third, a
timeout value which is used as tha timeout value fo' \fICORE::select()\fR by
default.  Dependin upon chizzles/features introduced by Readmethod
changes may be required here.
.PP
Version note: attribute added up in Mail::IMAPClient 3.30
.SS "Reconnectretry"
.IX Subsection "Reconnectretry"
If a \s-1IMAP\s0 connection sits idle too long, tha connection may be closed
by tha server or firewall, etc.  Da \fBReconnectretry\fR parameter, when
given a positizzle integer value, will cause Mail::IMAPClient to
retryin \s-1IMAP\s0 commandz up ta X times when a \s-1EPIPE\s0 or \s-1ECONNRESET\s0 error
occurs.  This is disabled (0) by default.
.PP
See also \*(L"Keepkickin it\*(R"
.PP
Version note: attribute added up in Mail::IMAPClient 3.17
.SS "Server"
.IX Subsection "Server"
Example:
.PP
.Vb 3
\&  $Server = $imap\->Server();
\&  # or:
\&  $imap\->Server($hostname);
.Ve
.PP
Specifies tha hostname or \s-1IP\s0 address of tha host hustlin tha \s-1IMAP\s0
server n' shit.  If provided as part of tha \*(L"new\*(R" method call, then tha new
\&\s-1IMAP\s0 object will automatically be connected all up in tha time of
instantiation. I aint talkin' bout chicken n' gravy biatch.  (See tha \*(L"new\*(R" method, below.) Can be supplied with
the \*(L"new\*(R" method call or separately by callin tha \fBServer\fR object
method.
.SS "Showcredentials"
.IX Subsection "Showcredentials"
Normally debuggin output will mask tha login credentials when the
plain text login mechanizzle is used. Y'all KNOW dat shit, muthafucka!  Settin \fIShowcredentials\fR ta a
true value will suppress this, so dat you can peep tha strang being
passed back n' forth durin plain text login. I aint talkin' bout chicken n' gravy biatch.  Only set dis ta true
when yo ass is debuggin problems wit tha \s-1IMAP LOGIN\s0 command, n' then
turn it off right away when you finished hustlin on dat problem.
.PP
Example:
.PP
.Vb 3
\&  print "This is straight-up risky!\en" if $imap\->Showcredentials();
\&  # or:
\&  $imap\->Showcredentials(0);    # mask credentials again
.Ve
.SS "Socket"
.IX Subsection "Socket"
\&\fB\s-1PLEASE NOTE\s0\fR Da semantics of dis method has chizzled az of version
2.99_04 of dis module.  If you need tha oldschool semantics use
\&\*(L"RawSocket\*(R".
.PP
Example:
.PP
.Vb 3
\&  $Socket = $imap\->Socket();
\&  # or:
\&  $imap\->Socket($socket_fh);
.Ve
.PP
Da \fISocket\fR method can be used ta obtain tha socket handle of the
current connection. I aint talkin' bout chicken n' gravy biatch.  This may be necessary ta do I/O on tha connection
that aint otherwise supported by Mail::IMAPClient) or ta replace the
current socket wit a freshly smoked up handle (for instizzle a \s-1SSL\s0 handle, see
IO::Socket::SSL).
.PP
If you supply a socket handle yo ass, either by bustin suttin' like:
.PP
.Vb 1
\&  $imap = Mail::IMAPClient\->new( Socket => $sock, User => ... );
.Ve
.PP
or by bustin suttin' like:
.PP
.Vb 4
\&  $imap = Mail::IMAPClient\->new(
\&    User => $user, Password => $pass, Server => $host
\&  );
\&  $imap\->Socket($ssl);
.Ve
.PP
then yo ass is responsible fo' establishin tha connection, i.e. make
sure dat \f(CW$ssl\fR up in tha example be a valid n' connected socket.
.PP
This method is primarily used ta provide a thugged-out drop-in replacement for
IO::Socket::INET, used by \*(L"connect\*(R" by default.  In fact, this
method is called by \*(L"connect\*(R" itself afta havin established a
suitable IO::Socket::INET socket connection towardz tha target
server; fo' dis reason, dis method also carries tha normal
operations associated wit \*(L"connect\*(R", namely:
.IP "\(bu" 4
read tha initial greetin message from tha server;
.IP "\(bu" 4
call \*(L"login\*(R" if tha conditions apply (see \*(L"connect\*(R" fo' details);
.IP "\(bu" 4
leave tha \fIMail::IMAPClient\fR object up in a suitable state.
.PP
For these reasons, tha followin example will work \*(L"out of tha box\*(R":
.PP
.Vb 10
\&   use IO::Socket::SSL;
\&   mah $imap = Mail::IMAPClient\->new
\&    ( User     => \*(Aqyour\-username\*(Aq,
\&      Password => \*(Aqyour\-password\*(Aq,
\&      Socket   => IO::Socket::SSL\->new
\&      (  Proto    => \*(Aqtcp\*(Aq,
\&         PeerAddr => \*(Aqsome.imap.server\*(Aq,
\&         PeerPort => 993, # IMAP over SSL standard port
\&      ),
\&   );
.Ve
.PP
If you need mo' control over tha socket, e.g. you gotta implement a
fancier authentication method, peep \*(L"RawSocket\*(R".
.SS "Starttls"
.IX Subsection "Starttls"
If a \s-1IMAP\s0 connection must start \s-1TLS/SSL\s0 afta connectin ta a server
then set dis attribute.  If tha value is set ta a arrayref then they
will be used as arguments ta IO::Socket::SSL\->start_SSL.  By default
this connection is set ta blockin while establishin tha connection
with a timeout of 30 seconds.  Da socket is ghon be reset ta the
original gangsta blocking/non\-blockin value afta a successful \s-1TLS\s0
negotiation has occurred. Y'all KNOW dat shit, muthafucka!  Da arguments used up in tha call ta start_SSL
can be controlled by settin dis attribute ta a \s-1ARRAY\s0 reference
containin tha desired arguments.
.PP
Version note: attribute added up in Mail::IMAPClient 3.22
.SS "Socketargs"
.IX Subsection "Socketargs"
Da arguments used up in tha call ta IO::Socket::{UNIX|INET|SSL}\->new can
be controlled by settin dis attribute ta a \s-1ARRAY\s0 reference
containin tha desired arguments.
.PP
For example, ta always pass MultiHomed => 1 ta IO::Socket::...\->new
the followin can be used:
.PP
.Vb 3
\&  $imap = Mail::IMAPClient\->new(
\&    ..., Socketargs => [ MultiHomed => 1 ], ...
\&  );
.Ve
.PP
See also \*(L"Ssl\*(R" fo' specific control of tha args ta IO::Socket::SSL.
.PP
Version note: attribute added up in Mail::IMAPClient 3.34
.SS "Ssl"
.IX Subsection "Ssl"
If a \s-1IMAP\s0 connection requires \s-1SSL\s0 you can set tha Ssl attribute to
\&'1' n' Mail::IMAPClient will automatically use IO::Socket::SSL
instead of IO::Socket::INET ta connect ta tha server n' shit.  This
attribute is used up in tha \*(L"connect\*(R" method. Y'all KNOW dat shit, muthafucka!  Da arguments used in
the call ta IO::Socket::SSL\->new can be controlled by settin this
attribute ta a \s-1ARRAY\s0 reference containin tha desired arguments.
.PP
See also \*(L"connect\*(R" fo' details on connection initiation and
\&\*(L"Socket\*(R" n' \*(L"Rawsocket\*(R" if you need ta take mo' control of
connection pimpment.
.PP
Version note: attribute added up in Mail::IMAPClient 3.18
.SS "Supportedflags"
.IX Subsection "Supportedflags"
Especially when \f(CW\*(C`migrate()\*(C'\fR is used, tha receivin peer may need to
be configured explicitly wit tha list of supported flags; dat may
be different from tha source \s-1IMAP\s0 server.
.PP
Da names is ta be specified as a \s-1ARRAY. \s0 Black-slashes n' casing
will be ignored.
.PP
Yo ass may also specify a \s-1CODE\s0 reference, which is ghon be called fo' each
of tha flags separately.  In dis case, tha flags is not (yet)
normalized. Y'all KNOW dat shit, muthafucka!  Da returned listz of tha \s-1CODE\s0 calls is shape the
resultin flag list.
.SS "Timeout"
.IX Subsection "Timeout"
Example:
.PP
.Vb 3
\&  $Timeout = $imap\->Timeout();
\&  # or:
\&  $imap\->Timeout($seconds);
.Ve
.PP
Specifies tha timeout value up in secondz fo' readz (default is 600).
Specifyin a \fITimeout\fR will prevent Mail::IMAPClient from blocking
in a read.
.PP
Since timeouts is implemented via tha Perl select
operator, tha \fITimeout\fR parameta may be set ta a gangbangin' fractionizzle number
of seconds.  Settin \fITimeout\fR ta 0 (zero) disablez tha timeout
feature.
.SS "Uid"
.IX Subsection "Uid"
Example:
.PP
.Vb 3
\&  $Uid = $imap\->Uid();
\&  # or:
\&  $imap\->Uid($true_or_false);
.Ve
.PP
If \*(L"Uid\*(R" is set ta a legit value (i.e. 1) then tha behavior of the
\&\*(L"fetch\*(R", \*(L"search\*(R", \*(L"copy\*(R", n' \*(L"store\*(R" methodz (and their
derivatives) is chizzled so dat arguments dat would otherwise be
message sequence numbers is treated as message \s-1UID\s0z n' so that
return joints (in tha case of tha \*(L"search\*(R" method n' its
derivatives) dat would normally be message sequence numbers are
instead message \s-1UID\s0's.
.PP
Internally dis is implemented as a switch that, if turned on, causes
methodz dat would otherwise issue a \s-1IMAP FETCH, STORE, SEARCH,\s0 or
\&\s-1COPY\s0 client command ta instead issue \s-1UID FETCH, UID STORE, UID SEARCH,\s0
or \s-1UID COPY,\s0 respectively.  Da main difference between message
sequence numbers n' message \s-1UID\s0z is that, accordin ta \s-1RFC3501,
UID\s0z must not chizzle durin a session n' should not chizzle between
sessions, n' must never be reused. Y'all KNOW dat shit, muthafucka!  Sequence numbers aint gots that
same guarantee n' up in fact may be reused right away.
.PP
Since folda names also gotz a unique identifier (\s-1UIDVALIDITY\s0), which
is provided when tha folda is \*(L"select\*(R"ed or \*(L"examine\*(R"d or by
fuckin wit suttin' like \*(L"$imap\->status($folder,\*(R"\s-1UIDVALIDITY"\s0), it is
possible ta uniquely identify every last muthafuckin message on tha server, although
normally you won't need ta bother.
.PP
Da methodz currently affected by turnin on tha \*(L"Uid\*(R" flag are:
.PP
.Vb 6
\&  copy            fetch
\&  search          store
\&  message_strin  message_uid
\&  body_strin     flags
\&  move            size
\&  parse_headaz   thread
.Ve
.PP
Note dat if fo' some reason you only want tha \*(L"Uid\*(R" parameta turned
on fo' one command, then you can chizzle between tha followin two
snippets, which is equivalent:
.PP
Example 1:
.PP
.Vb 3
\&  $imap\->Uid(1);
\&  mah @uidz = $imap\->search(\*(AqSUBJECT\*(Aq,"Just a wack-ass test"); #
\&  $imap\->Uid(0);
.Ve
.PP
Example 2:
.PP
.Vb 7
\&  mah @uids;
\&  foreach $r ($imap\->UID("SEARCH","SUBJECT","Just a wack-ass test") {
\&      chomp $r;
\&      $r =~ s/\er$//;
\&      $r =~ s/^\e*\es+SEARCH\es+// or next;
\&      push @uids, grep(/\ed/,(split(/\es+/,$r)));
\&  }
.Ve
.PP
In tha second example, we used tha default method ta issue tha \s-1UID
IMAP\s0 Client command, bein careful ta use a all-uppercase method name
so as not ta inadvertently call tha \*(L"Uid\*(R" accessor method. Y'all KNOW dat shit, muthafucka!  Then we
parsed up tha message UIDs manually, since our phat asses aint gots tha benefit
of tha built-in \*(L"search\*(R" method bustin it fo' us.
.PP
Please be straight-up careful when turnin tha \*(L"Uid\*(R" parameta on n' off
all up in a script.  If you loose track of whether you've gots the
\&\*(L"Uid\*(R" parameta turned on you might do suttin' sad, like deleting
the wack message.  Remember, like all eponymous accessor methods, the
\&\fBUid\fR method without arguments will return tha current value fo' the
\&\*(L"Uid\*(R" parameter, so do yo ass a gangbangin' favor n' check.  Da safest
approach is probably ta turn it on all up in tha beginnin (or just let it
default ta bein on) n' then leave it on. I aint talkin' bout chicken n' gravy biatch.  (Remember dat leavin it
turned off can lead ta problems if chizzlez ta a gangbangin' folderz contents
cause resequencing.)
.PP
By default, tha \*(L"Uid\*(R" parameta is turned on.
.SS "User"
.IX Subsection "User"
Example:
.PP
.Vb 3
\&  $User = $imap\->User();
\&  # or:
\&  $imap\->User($userid);
.Ve
.PP
Specifies tha userid ta use when loggin tha fuck into tha \s-1IMAP\s0 service.  Can
be supplied wit tha \*(L"new\*(R" method call or separately by callin the
\&\fBUser\fR object method.
.PP
Parametas can be set durin \*(L"new\*(R" method invocation by passin named
parameter/value pairs ta tha method, or lata by callin the
parameterz eponymous object method.
.SH "Status Methods"
.IX Header "Status Methods"
There is nuff muthafuckin object methodz dat return tha statuz of tha object.
They can be used at any time ta check tha statuz of a IMAPClient
object yo, but is particularly useful fo' determinin tha cause of
failure when a cold-ass lil connection n' login is attempted as part of a single
\&\*(L"new\*(R" method invocation. I aint talkin' bout chicken n' gravy biatch.  Da status methodz are:
.SS "Escaped_history"
.IX Subsection "Escaped_history"
Example:
.PP
.Vb 1
\&  mah @history = $imap\->Escaped_history;
.Ve
.PP
Da \fBEscaped_history\fR method be almost identical ta tha \fBHistory\fR
method. Y'all KNOW dat shit, muthafucka!  Unlike tha \fBHistory\fR method, however, server output
transmitted literally is ghon be wrapped up in double quotes, wit all
double quotes, backslashes escaped. Y'all KNOW dat shit, muthafucka!  If called up in a scalar context,
\&\fBEscaped_history\fR returns a array reference rather than a array.
.PP
\&\fBEscaped_history\fR is useful if yo ass is retrievin output and
processin it manually, n' yo ass is dependin on tha above special
charactas ta delimit tha data.  It aint useful when retrieving
message contents; use \fBmessage_string\fR or \fBbody_string\fR fo' dis shit.
.SS "Escaped_results"
.IX Subsection "Escaped_results"
Example:
.PP
.Vb 1
\&  mah @results = $imap\->Escaped_results;
.Ve
.PP
Da \fBEscaped_results\fR method be almost identical ta tha \fBResults\fR
method. Y'all KNOW dat shit, muthafucka!  Unlike tha \fBResults\fR method, however, server output
transmitted literally is ghon be wrapped up in double quotes, wit all
double quotes, backslashes escaped. Y'all KNOW dat shit, muthafucka!  If called up in a scalar context,
\&\fBEscaped_results\fR returns a array reference rather than a array.
.PP
\&\fBEscaped_results\fR is useful if yo ass is retrievin output and
processin it manually, n' yo ass is dependin on tha above special
charactas ta delimit tha data.  It aint useful when retrieving
message contents; use \fBmessage_string\fR or \fBbody_string\fR fo' dis shit.
.SS "History"
.IX Subsection "History"
Example:
.PP
.Vb 1
\&  mah @history = $imap\->History;
.Ve
.PP
Da \fBHistory\fR method be almost identical ta tha \*(L"Results\*(R" method.
Unlike tha \*(L"Results\*(R" method, however, tha \s-1IMAP\s0 command dat was
issued ta create tha thangs up in dis biatch bein returned aint included up in the
returned thangs up in dis biatch.  If called up in a scalar context, \fBHistory\fR returns
an array reference rather than a array.
.SS "IsUnconnected"
.IX Subsection "IsUnconnected"
returns a legit value if tha object is currently up in a \*(L"Unconnected\*(R"
state.
.SS "IsConnected"
.IX Subsection "IsConnected"
returns a legit value if tha object is currently up in either a
\&\*(L"Connected\*(R", \*(L"Authenticated\*(R", or \*(L"Selected\*(R" state.
.SS "IsAuthenticated"
.IX Subsection "IsAuthenticated"
returns a legit value if tha object is currently up in either an
\&\*(L"Authenticated\*(R" or \*(L"Selected\*(R" state.
.SS "IsSelected"
.IX Subsection "IsSelected"
returns a legit value if tha object is currently up in a \*(L"Selected\*(R"
state.
.SS "LastError"
.IX Subsection "LastError"
Internally \fBLastError\fR is implemented just like a parameta (as
busted lyrics bout up in \*(L"Parameters\*(R", above).  There be a \fILastError\fR
attribute n' a eponymous accessor method which returns the
\&\fILastError\fR text strang describin tha last error condition
encountered by tha server.
.PP
Note dat some errors is mo' straight-up than others, so \fILastError\fR's
value is only meaningful if you encounta a error condizzle dat you
don't like.  For example, if you use tha \*(L"exists\*(R" method ta peep if a
folda exists n' tha folda do not exist, then a error message
will be recorded up in \fILastError\fR even though dis aint a
particularly straight-up error. Shiiit, dis aint no joke.  On tha other hand, if you didn't use
\&\*(L"exists\*(R" n' just tried ta \*(L"select\*(R" a non-existin folder, then
\&\*(L"select\*(R" would return \f(CW\*(C`undef\*(C'\fR afta settin \fILastError\fR to
suttin' like \f(CW\*(C`NO SELECT failed: Can\*(Aqt open mailbox "mailbox": no
such mailbox\*(C'\fR.  At dis point it would be useful ta print up the
contentz of \fILastError\fR as you take a thugged-out dirt nap.
.SS "LastIMAPCommand"
.IX Subsection "LastIMAPCommand"
New up in version 2.0.4, \fBLastIMAPCommand\fR returns tha exact \s-1IMAP\s0
command strang ta be busted ta tha server n' shit.  Useful mainly in
constructin error lyrics when \*(L"LastError\*(R" just aint enough.
.SS "Report"
.IX Subsection "Report"
Da \fBReport\fR method returns a array containin a history of tha \s-1IMAP\s0
session up ta tha point dat \fBReport\fR was called. Y'all KNOW dat shit, muthafucka!  It be primarily
meant ta assist up in debuggin but can also be used ta retrieve raw
output fo' manual parsing.  Da value of tha \*(L"Clear\*(R" parameter
controls how tha fuck nuff transactions is up in tha report.
.SS "Results"
.IX Subsection "Results"
Da \fBResults\fR method returns a array containin tha thangs up in dis biatch of one
\&\s-1IMAP\s0 client command. Y'all KNOW dat shit, muthafucka!  It accepts one argument, tha transaction number
of tha command whose thangs up in dis biatch is ta be returned. Y'all KNOW dat shit, muthafucka!  If transaction
number is unspecified then \fBResults\fR returns tha thangs up in dis biatch of tha last
\&\s-1IMAP\s0 client command issued. Y'all KNOW dat shit, muthafucka!  If called up in a scalar context, \fBResults\fR
returns a array reference rather than a array.
.SS "State"
.IX Subsection "State"
Da \fBState\fR method returns a numerical value dat indicates the
current statuz of tha IMAPClient object.  If invoked wit a argument,
it will set tha objectz state ta dat value.  If invoked without an
argument, it behaves just like \*(L"Status\*(R", below.
.PP
Normally yo big-ass booty is ghon not gotta invoke dis function. I aint talkin' bout chicken n' gravy biatch.  An exception is
if yo ass is bypassin tha Mail::IMAPClient modulez \*(L"connect\*(R" and/or
\&\*(L"login\*(R" modulez ta set up yo' own connection (say, fo' example,
over a secure socket), up in which case you must manually do what tha fuck the
\&\*(L"connect\*(R" n' \*(L"login\*(R" methodz would otherwise do fo' yo thugged-out ass.
.SS "Status"
.IX Subsection "Status"
Da \fBStatus\fR method returns a numerical value dat indicates the
current statuz of tha IMAPClient object.  (Not ta be trippin wit the
\&\*(L"status\*(R" method, all lower-case, which is tha implementation of the
\&\fI\s-1STATUS\s0\fR \s-1IMAP\s0 client command.)
.SS "Transaction"
.IX Subsection "Transaction"
Da \fBTransaction\fR method returns tha tag value (or transaction
number) of tha last \s-1IMAP\s0 client command.
.SH "Custom Authentication Mechanisms"
.IX Header "Custom Authentication Mechanisms"
If you just wanna use plain text authentication or any of the
supported \*(L"Advanced Authentication Mechanisms\*(R" then there is no
need ta read dis section.
.PP
There is a fuckin shitload of methodz n' parametas dat you can use ta build
your own authentication mechanism.  All of tha methodz n' parameters
discussed up in dis section is busted lyrics bout up in mo' detail elsewhere in
this document.  This section serves up a startin point fo' building
your own authentication mechanism.
.PP
There is \fImany\fR authentication mechanizzlez up there, if your
preferred mechanizzle aint currently supported but you manage ta get
it hustlin please consider donatin dem ta dis module.  Patches and
suggestions is always welcome.
.PP
Support fo' add-on authentication mechanizzlez up in Mail::IMAPClient is
pretty straight forward. Y'all KNOW dat shit, muthafucka!  Yo ass create a cold-ass lil callback ta be used ta provide
the response ta tha serverz challenge.  Da \*(L"Authcallback\*(R" parameter
gotz nuff a reference ta tha callback, which can be a anonymous
subroutine or a named subroutine.  Then, you identify your
authentication mechanism, either via tha \*(L"Authmechanism\*(R" parameta or
as a argument ta \*(L"authenticate\*(R".
.PP
Yo ass may also need ta provide a subroutine ta encrypt (or whatever)
data before it is busted ta tha server n' shit.  Da \*(L"Prewritemethod\*(R" parameter
must contain a reference ta dis subroutine.  And, yo big-ass booty is ghon need to
decrypt data from tha server; a reference ta tha subroutine dat do
this must be stored up in tha \*(L"Readmethod\*(R" parameter.
.PP
This framework is based on tha assumptions dat a) tha mechanizzle you
are rockin requires a cold-ass lil challenge-response exchange, n' b) tha mechanism
does not fundamentally alta tha exchange between client n' server
but merely wraps tha exchange up in a layer of encryption. I aint talkin' bout chicken n' gravy biatch.  It also
assumes dat tha line-oriented nature of tha \s-1IMAP\s0 conversation is
preserved; authentication mechanizzlez dat break up lyrics into
blockz of a predetermined size may still be possible but will
certainly be mo' hard as fuck ta implement.
.PP
Alternatively, if you have access ta \fBimtest\fR, a utilitizzle included in
the Cyrus \s-1IMAP\s0 distribution, you can use dat utilitizzle ta broker your
communications wit tha \s-1IMAP\s0 server n' shit.  This is like easy as fuck  ta implement.
An example, \fIexamples/imtestExample.pl\fR, can be found up in the
\&\f(CW\*(C`examples\*(C'\fR subdirectory of tha source distribution.
.PP
Da followin list summarizes tha methodz n' parametas dat you may
find useful up in implementin advanced authentication:
.IP "Da authenticate method" 4
.IX Item "Da authenticate method"
Da \*(L"authenticate\*(R" method uses tha \*(L"Authmechanism\*(R" parameta to
determine how tha fuck ta authenticate wit tha server peep tha method
documentation fo' details.
.IP "Socket n' RawSocket" 4
.IX Item "Socket n' RawSocket"
Da \*(L"Socket\*(R" n' \*(L"RawSocket\*(R" methodz provide access ta tha socket
connection. I aint talkin' bout chicken n' gravy biatch.  Da socket is typically automatically pimped by the
\&\*(L"connect\*(R" method yo, but if yo ass is implementin a advanced
authentication technique you may chizzle ta set up yo' own socket
connection n' then set dis parameta manually, bypassin the
\&\fBconnect\fR method straight-up.  This be also useful if you wanna use
IO::Socket::INET alternatives like IO::Socket::SSL n' need full
control.
.Sp
\&\*(L"RawSocket\*(R" simply gets/sets tha socket without attemptin any
interaction on dat shit.  In dis case, you gotta be shizzle ta handle all
the preliminary operations n' manually set tha Mail::IMAPClient
object up in sync wit its actual status wit respect ta dis socket (see
below fo' additionizzle parametas regardin this, especially the
\&\*(L"State\*(R" parameter).
.Sp
Unlike \*(L"RawSocket\*(R", \*(L"Socket\*(R" attempts ta carry on preliminary
connection phases if tha conditions apply.  If both parametas are
present, dis takes tha precedence over \*(L"RawSocket\*(R".  If
\&\*(L"Starttls\*(R" is set, then tha \*(L"starttls\*(R" method is ghon be called by
\&\*(L"Socket\*(R".
.Sp
\&\fB\s-1PLEASE NOTE\s0\fR Az of version 2.99_04 of dis module, semantics for
\&\*(L"Socket\*(R" have chizzled ta make it mo' \*(L"\s-1DWIM\*(R".  \s0\*(L"RawSocket\*(R" was
introduced as a replacement fo' tha \*(L"Socket\*(R" parameta up in older
version.
.IP "State, Server, User, Password, Proxy n' Domain Parameters" 4
.IX Item "State, Server, User, Password, Proxy n' Domain Parameters"
If you need ta make yo' own connection ta tha server n' big-ass up your
authentication manually, then you can set these parametas ta keep
your Mail::IMAPClient object up in sync wit its actual status.  Of
these, only tha \*(L"State\*(R" parameta be always necessary.  Da others
need ta be set only if you be thinkin yo' program will need dem later.
.IP "Authmechanism" 4
.IX Item "Authmechanism"
Set dis ta tha value dat \s-1AUTHENTICATE\s0 should bust ta tha server as
the authentication mechanism.  If yo ass is brokerin yo' own
authentication then dis parameta may be less useful naaahhmean, biatch?  It exists
primarily so dat you can set it when you call \*(L"new\*(R" ta instantiate
your object.  Da \*(L"new\*(R" method will call \*(L"connect\*(R", which will
call \*(L"login\*(R".  If \*(L"login\*(R" sees dat you have set an
\&\fBAuthmechanism\fR then it will call \fBauthenticate\fR, rockin your
\&\fBAuthmechanism\fR n' \fBAuthcallback\fR parametas as arguments.
.IP "Authcallback" 4
.IX Item "Authcallback"
Da \*(L"Authcallback\*(R", if set, holdz a pointa ta a subroutine
(\s-1CODEREF\s0).  Da \*(L"login\*(R" method will use dis as tha callback
argument ta tha \fBauthenticate\fR method if tha \fBAuthmechanism\fR and
\&\fBAuthcallback\fR parametas is both set.  If you set \fBAuthmechanism\fR
but not \fBAuthcallback\fR then tha default callback fo' yo' mechanism
will be used. Y'all KNOW dat shit, muthafucka!  All supported authentication mechanizzlez gotz a thugged-out default
callback; up in every last muthafuckin other case not supplyin tha callback thangs up in dis biatch up in an
error.
.Sp
Most advanced authentication mechanizzlez require a cold-ass lil challenge-response
exchange.  Afta tha \*(L"authenticate\*(R" method sendz \*(L"<tag> \s-1AUTHENTICATE\s0
<Authmechanism>\e015\e012\*(R" ta tha \s-1IMAP\s0 server, tha server replies wit a
challenge.  Da \*(L"authenticate\*(R" method then invokes tha code whose
reference is stored up in tha \fBAuthcallback\fR parameta as bigs up:
.Sp
.Vb 1
\&  $Authcallback\->( $challenge, $imap )
.Ve
.Sp
where \f(CW$Authcallback\fR is tha code reference stored up in the
\&\fBAuthcallback\fR parameter, \f(CW$challenge\fR is tha challenge received
from tha \s-1IMAP\s0 server, n' \f(CW$imap\fR be a pointa ta the
Mail::IMAPClient object.  Da return value from tha \fBAuthcallback\fR
routine should be tha response ta tha challenge, n' dat return value
will be busted by tha \*(L"authenticate\*(R" method ta tha server.
.IP "Prewritemethod/Readmethod" 4
.IX Item "Prewritemethod/Readmethod"
Da \fBPrewritemethod\fR can hold a subroutine dat will do whatever
encryption is necessary n' then return tha result ta tha calla so it
in turn can be busted ta tha server.
.Sp
Da \fBReadmethod\fR can hold a subroutine ta be used ta replace
\&\fBsysread\fR probably performed by Mail::IMAPClient.
.Sp
See \*(L"Prewritemethod\*(R" n' \*(L"Readmethod\*(R" fo' details.
.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
Please bust bug reports ta \f(CW\*(C`bug\-Mail\-IMAPClient@rt.cpan.org\*(C'\fR or
http://rt.cpan.org/Public/Dist/Display.html?Name=Mail\-IMAPClient
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 4
\&  Copyright (C) 1999\-2003 Da Kernen Group, Inc.
\&  Copyright (C) 2007\-2009 Mark Overmeer
\&  Copyright (C) 2010\-2013 Phil Pearl (Lobbes)
\&  All muthafuckin rights reserved.
.Ve
.PP
This library is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself, either Perl version 5.8.0 or,
at yo' option, any lata version of Perl 5 you may have available.
.PP
This program is distributed up in tha hope dat it is ghon be useful yo, but
\&\s-1WITHOUT ANY WARRANTY\s0; without even tha implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See either the
\&\s-1GNU\s0 General Public License or tha Artistic License fo' mo' details.
