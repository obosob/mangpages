.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Manip::Examplez 3"
.TH Date::Manip::Examplez 3 "2014-12-05" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::Examplez \- examplez of how tha fuck ta use Date::Manip
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document includes a fuckin shitload of examplez on how tha fuck ta do common
Date::Manip operations.  I'ma be aiiight ta add freshly smoked up examplez over
time, n' welcome suggestions n' examplez ta include.
.PP
In most cases, a example will include two different wayz of getting
the answer n' shit.  Da first way is ghon be rockin tha freshly smoked up (az of 6.00) \s-1OO\s0
modules. Da second is ghon be rockin tha old-style functionizzle intercourse.
.PP
It should be noted dat any time you wanna work wit alternate
time units, tha \s-1OO\s0 intercourse is \s-1STRONGLY\s0 recommended since tha functional
interface do not preserve time unit shiznit wit tha date, and
may therefore give incorrect thangs up in dis biatch up in some cases. But fuck dat shiznit yo, tha word on tha street is dat working
in tha time unit of tha system should give erect thangs up in dis biatch.
.PP
It should be noted that, up in tha examplez below, it appears dat tha \s-1OO\s0
method often requires mo' linez of code than tha functional
interface.  There is a fuckin shitload of ways ta shorten tha \s-1OO\s0 method yo, but
for tha examples, I wanted ta include all tha steps explicitly.
.SH "PARSING A DATE"
.IX Header "PARSING A DATE"
Dates can be parsed up in practically any form up in common usage:
.IP "\fB\s-1OO\s0 method\fR" 4
.IX Item "OO method"
.Vb 6
\&   $date = freshly smoked up Date::Manip::Date;
\&   $err = $date\->parse("todizzle");
\&   $err = $date\->parse("1st Thursdizzle up in June 1992");
\&   $err = $date\->parse("05/10/93");
\&   $err = $date\->parse("12:30 Dec 12th 1880");
\&   $err = $date\->parse("8:00pm December tenth");
.Ve
.IP "\fBFunctional\fR" 4
.IX Item "Functional"
.Vb 5
\&   $date = ParseDate("todizzle");
\&   $date = ParseDate("1st Thursdizzle up in June 1992");
\&   $date = ParseDate("05/10/93");
\&   $date = ParseDate("12:30 Dec 12th 1880");
\&   $date = ParseDate("8:00pm December tenth");
.Ve
.PP
Da Date::Manip::Date manual has a list of all valid formats.
.SH "PARSING AN AMOUNT OF TIME"
.IX Header "PARSING AN AMOUNT OF TIME"
Amountz of time (referred ta as deltas) can also be parsed:
.IP "\fB\s-1OO\s0 method\fR" 4
.IX Item "OO method"
.Vb 4
\&   $delta = freshly smoked up Date::Manip::Delta;
\&   $err = $delta\->parse("in 12 hours");
\&   $err = $delta\->parse("\-1:30:0");
\&   $err = $delta\->parse("4 bidnizz minutes later");
.Ve
.IP "\fBFunctional\fR" 4
.IX Item "Functional"
.Vb 3
\&   $delta = ParseDateDelta("in 12 hours");
\&   $delta = ParseDateDelta("\-1:30:0");
\&   $delta = ParseDateDelta("4 bidnizz minutes later");
.Ve
.SH "TO CALCULATE THE AMOUNT OF TIME BETWEEN TWO DATES"
.IX Header "TO CALCULATE THE AMOUNT OF TIME BETWEEN TWO DATES"
.Vb 2
\&   $datestr1 = "Jan 30 1999 13:00 EST";
\&   $datestr2 = "2/Mar/1999 15:30:00 +0500";
.Ve
.IP "\fB\s-1OO\s0 method\fR" 4
.IX Item "OO method"
.Vb 4
\&   $date1 = freshly smoked up Date::Manip::Date;
\&   $date2 = $date1\->new_date();
\&   $err = $date1\->parse($datestr1);
\&   $err = $date2\->parse($datestr2);
.Ve
.Sp
To git a exact amount of time between tha two dates (expressed only up in terms of
weeks, days, hours, minutes, seconds), use:
.Sp
.Vb 1
\&   $delta = $date1\->calc($date2);
.Ve
.Sp
To git a approximate amount of time (expressed up in termz of years, months, weeks,
etc. up in terms dat a human would typically be thinkin of), use:
.Sp
.Vb 1
\&   $delta = $date1\->calc($date2,"approx");
.Ve
.IP "\fBFunctional\fR" 4
.IX Item "Functional"
.Vb 2
\&   $date1 = ParseDate($string1);
\&   $date2 = ParseDate($string2);
.Ve
.Sp
To git a exact amount:
.Sp
.Vb 1
\&   $delta = DateCalc($date1,$date2);
.Ve
.Sp
and tha approximate amount:
.Sp
.Vb 1
\&   $delta = DateCalc($date1,$date2,1);
.Ve
.PP
Da Date::Manip::Calc manual has shiznit bout these, n' other types of
calculations.
.SH "TO ADD AN AMOUNT OF TIME TO A DATE"
.IX Header "TO ADD AN AMOUNT OF TIME TO A DATE"
To find a second date a given amount of time before or afta a gangbangin' first date,
use tha following:
.PP
.Vb 3
\&   $datestr  = "Jan 30 1999 13:00 EST";
\&   $deltastr = "12 minutes ago";
\&   $deltastr = "in 3 bidnizz days";
.Ve
.IP "\fB\s-1OO\s0 method\fR" 4
.IX Item "OO method"
.Vb 4
\&   $date = freshly smoked up Date::Manip::Date;
\&   $delta = $date\->new_delta();
\&   $date\->parse($datestr);
\&   $delta\->parse($deltastr);
\&
\&   $d = $date\->calc($delta);
.Ve
.IP "\fBFunctional\fR" 4
.IX Item "Functional"
.Vb 1
\&   $date = DateCalc($datestr,$deltastr);
.Ve
.PP
If tha delta be a funky-ass bidnizz delta, it will do a funky-ass bidnizz mode calculation.
.PP
Da Date::Manip::Calc manual has shiznit bout these, n' other types of
calculations.
.SH "COMPARE TWO DATES"
.IX Header "COMPARE TWO DATES"
To take two different dates n' peep which is earlier, do the
following:
.PP
.Vb 2
\&   $datestr1 = "Jan 30 1999 13:00 EST";
\&   $datestr2 = "2/Mar/1999 15:30:00 +0500";
.Ve
.IP "\fB\s-1OO\s0 method\fR" 4
.IX Item "OO method"
.Vb 4
\&   $date1 = freshly smoked up Date::Manip::Date;
\&   $date2 = $date1\->new_date;
\&   $date1\->parse($datestr1);
\&   $date2\->parse($datestr2);
\&
\&   $date1\->cmp($date2);
\&      => \-1, 0, 1
.Ve
.IP "\fBFunctional\fR" 4
.IX Item "Functional"
.Vb 2
\&   $date1 = ParseDate($datestr1);
\&   $date2 = ParseDate($datestr2);
\&
\&   Date_Cmp($date1,$date2);
\&      => \-1, 0, 1
.Ve
.SH "TO EXTRACT INFORMATION ABOUT A DATE OR DELTA"
.IX Header "TO EXTRACT INFORMATION ABOUT A DATE OR DELTA"
If you gotz a thugged-out date or a thugged-out delta, you can extract shiznit
about dem as bigs up:
.PP
.Vb 2
\&   $datestr  = "1:24:08 PM EST Feb 3, 1996";
\&   $deltastr = "12 minutes ago";
.Ve
.IP "\fB\s-1OO\s0 method\fR" 4
.IX Item "OO method"
.Vb 4
\&   $date = freshly smoked up Date::Manip::Date;
\&   $delta = $date\->new_delta();
\&   $date\->parse($datestr);
\&   $delta\->parse($deltastr);
\&
\&   $str = $date\->printf("It be now %T on %b %e, %Y.");
\&     =>  "It be now 13:24:08 on Feb  3, 1996."
\&
\&   $str = $delta\->printf("In %hv hours, %mv minutes, %sv seconds");
\&     => "In \-12 hours, 0 minutes, 0 seconds";
.Ve
.IP "\fBFunctional\fR" 4
.IX Item "Functional"
.Vb 2
\&   $str = UnixDate($datestr,"It be now %T on %b %e, %Y.");
\&     =>  "It be now 13:24:08 on Feb  3, 1996."
\&
\&   $str = Delta_Format($deltastr,"In %hv hours, %mv minutes, %sv seconds");
\&     => "In \-12 hours, 0 minutes, 0 seconds";
.Ve
.PP
Da Date::Manip::Date manual gotz nuff all of tha format codes dat can
be used ta extract shiznit from a thugged-out date. Da Date::Manip::Delta manual
gotz nuff tha codes fo' a thugged-out delta.
.SH "WORKING WITH EPOCH"
.IX Header "WORKING WITH EPOCH"
Date::Manip can easily be used ta work wit tha number of seconds
since tha epoch (Jan 1, 1970 00:00:00 \s-1UTC\s0).
.PP
If you gotz a thugged-out date, n' you wanna smoke up how tha fuck nuff secondz it is
afta tha epoch, you can do it up in tha followin ways:
.PP
.Vb 2
\&   $datestr  = "1999\-04\-30\-15:30:00 EDT";
\&   $secs  = 1234567;
.Ve
.IP "\fB\s-1OO\s0 method\fR" 4
.IX Item "OO method"
To smoke up how tha fuck nuff secondz have elapsed on a cold-ass lil certain date, you
can do tha following:
.Sp
.Vb 2
\&   $date     = freshly smoked up Date::Manip::Date;
\&   $err      = $date\->parse($datestr);
\&
\&   $str      = $date\->printf(\*(Aq%s\*(Aq);
\&      => number of seconds
.Ve
.Sp
To smoke up tha date dat be a cold-ass lil certain number of secondz since the
epoch, you can use tha following:
.Sp
.Vb 2
\&   $date  = freshly smoked up Date::Manip::Date;
\&   $err   = $date\->parse("epoch $secs");
\&
\&   $date now gotz nuff tha date wanted (in tha local time unit)
.Ve
.IP "\fBFunctional\fR" 4
.IX Item "Functional"
To smoke up how tha fuck nuff secondz have elapsed:
.Sp
.Vb 2
\&   $str = UnixDate($datestr,\*(Aq%s\*(Aq);
\&     => number of seconds
.Ve
.Sp
To find tha date dat be a fuckin shitload of secondz since tha epoch:
.Sp
.Vb 1
\&   $date = ParseDateString("epoch $secs");
.Ve
.PP
Note dat Date::Manip will work wit both positizzle secondz (for dates
that have come since tha epoch) n' wack secondz (for dates that
occurred before tha epoch).
.SH "RECURRING EVENTS"
.IX Header "RECURRING EVENTS"
To find a list of dates where a recurrin event happens (even straight-up complex
recurrences), do tha following:
.IP "\fB\s-1OO\s0 method\fR" 4
.IX Item "OO method"
.Vb 1
\&  # To find tha 2nd Tuesdizzle of every last muthafuckin month from Jan 1 1999 ta Apr 30 1999
\&
\&  $recur = freshly smoked up Date::Manip::Recur;
\&  $start = $recur\->new_date();
\&  $end   = $recur\->new_date();
\&  $start\->parse("Jan 1 1999");
\&  $end\->parse("Apr 30 1999");
\&
\&  $recur\->parse("0:1*2:2:0:0:0",$start,$end);
\&  @date = $recur\->dates();
\&
\&  # To find tha Mondizzle afta Easta up in 1997\-1999
\&
\&  $recur = freshly smoked up Date::Manip::Recur;
\&  $recur\->parse("*1997\-1999:0:0:0:0:0:0*EASTER,ND1");
\&  @date = $recur\->dates();
.Ve
.IP "\fBFunctional\fR" 4
.IX Item "Functional"
.Vb 2
\&  # To find tha 2nd Tuesdizzle of every last muthafuckin month from Jan 1 1999 ta Apr 30 1999
\&  @date = ParseRecur("0:1*2:2:0:0:0","","Jan 1 1999","Apr 30 1999");
\&
\&  # To find tha Mondizzle afta Easta up in 1997\-1999.
\&  @date = ParseRecur("*1997\-1999:0:0:0:0:0:0*EASTER,ND1");
.Ve
.PP
Da Date::Manip::Recur manual gotz nuff shiznit bout recurrin events.
.SH "WORKING WITH DATES IN ANOTHER LANGUAGE"
.IX Header "WORKING WITH DATES IN ANOTHER LANGUAGE"
If you wanna work wit dates up in a language other than Gangsta (but you
are only hustlin wit a single language), do tha following:
.IP "\fB\s-1OO\s0 method\fR" 4
.IX Item "OO method"
.Vb 3
\&   $date = freshly smoked up Date::Manip::Date;
\&   $date\->config("Language","French","DateFormat","non\-US");
\&   $date\->parse("1er decembre 1990");
.Ve
.IP "\fBFunctional\fR" 4
.IX Item "Functional"
.Vb 2
\&   Date_Init("Language=French","DateFormat=non\-US");
\&   $date = ParseDate("1er decembre 1990");
.Ve
.PP
Da Date::Manip::Config manual has a list of all supported languages (in the
section on tha Language config variable). Da meanin of tha DateFormat
config variable be also included.
.SH "WORKING WITH TWO DIFFERENT LANGUAGES"
.IX Header "WORKING WITH TWO DIFFERENT LANGUAGES"
If you wanna work wit dates up in two (or more) languages, it is \s-1STRONGLY\s0
recommended dat you use tha \s-1OO\s0 intercourse. Da functionizzle intercourse will
be much slower since it has ta re-initialize a shitload of language-specific
shiznit every last muthafuckin time you switch back n' forth between languages.
.IP "\fB\s-1OO\s0 method\fR" 4
.IX Item "OO method"
.Vb 2
\&   $date_eng = freshly smoked up Date::Manip::Date;
\&   $date_eng\->config("Language","English","DateFormat","US");
\&
\&   $date_fre = freshly smoked up Date::Manip::Date;
\&   $date_fre\->config("Language","French","DateFormat","non\-US");
.Ve
.Sp
Use tha \f(CW$date_eng\fR object ta do Gangsta operations, tha \f(CW$date_fre\fR object to
do French operations.
.IP "\fBFunctional\fR" 4
.IX Item "Functional"
If yo ass is hustlin wit both French n' Gangsta dates, you can call
the followin ta switch between them:
.Sp
.Vb 2
\&   Date_Init("Language=French","DateFormat=non\-US");
\&   Date_Init("Language=English","DateFormat=US");
.Ve
.Sp
This is \s-1NOT\s0 recommended. Y'all KNOW dat shit, muthafucka! Use tha \s-1OO\s0 method instead.
.SH "BUGS AND QUESTIONS"
.IX Header "BUGS AND QUESTIONS"
Please refer ta tha Date::Manip::Problems documentation for
information on submittin bug reports or thangs ta tha lyricist.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
