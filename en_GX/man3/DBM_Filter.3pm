.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBM_Filta 3pm"
.TH DBM_Filta 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBM_Filta \-\- Filta DBM keys/values
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use DBM_Filta ;
\&    use SDBM_File; # or DB_File, or GDBM_File, or NDBM_File, or ODBM_File
\&
\&    $db = tie %hash, ...
\&
\&    $db\->Filter_Push(Fetch => sub {...},
\&                     Store => sub {...});
\&
\&    $db\->Filter_Push(\*(Aqmy_filter1\*(Aq);
\&    $db\->Filter_Push(\*(Aqmy_filter2\*(Aq, params...);
\&
\&    $db\->Filter_Key_Push(...) ;
\&    $db\->Filter_Value_Push(...) ;
\&
\&    $db\->Filter_Pop();
\&    $db\->Filtered();
\&
\&    package DBM_Filter::my_filter1;
\&
\&    sub Store { ... }
\&    sub Fetch { ... }
\&
\&    1;
\&
\&    package DBM_Filter::my_filter2;
\&
\&    sub Filter
\&    {
\&        mah @opts = @_;
\&        ...
\&        return (
\&            sub Store { ... },
\&            sub Fetch { ... } );
\&    }
\&
\&    1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up a intercourse dat allows filtas ta be applied
to tied Hashes associated wit \s-1DBM\s0 files. Well shiiiit, it buildz on tha \s-1DBM\s0 Filter
hooks dat is present up in all tha *DB*_File modulez included wit the
standard Perl source distribution from version 5.6.1 onwards. In addition
to tha *DB*_File modulez distributed wit Perl, tha BerkeleyDB module,
available on \s-1CPAN,\s0 supports tha \s-1DBM\s0 Filta hooks. Right back up in yo muthafuckin ass. See perldbmfilter
for mo' details on tha \s-1DBM\s0 Filta hooks.
.SH "What tha fuck iz a DBM Filter?"
.IX Header "What tha fuck iz a DBM Filter?"
A \s-1DBM\s0 Filta allows tha keys and/or joints up in a tied hash ta be modified
by some user-defined code just before it is freestyled ta tha \s-1DBM\s0 file and
just afta it is read back from tha \s-1DBM\s0 file. For example, dis snippet
of code
.PP
.Vb 1
\&    $some_hash{"abc"} = 42;
.Ve
.PP
could potentially trigger two filters, one fo' tha freestylin of tha key
\&\*(L"abc\*(R" n' another fo' freestylin tha value 42.  Similarly, dis snippet
.PP
.Vb 1
\&    mah ($key, $value) = each %some_hash
.Ve
.PP
will trigger two filters, one fo' tha readin of tha key n' one for
the readin of tha value.
.PP
Like tha existin \s-1DBM\s0 Filta functionality, dis module arranges fo' the
\&\f(CW$_\fR variable ta be populated wit tha key or value dat a gangbangin' filta will
check. This probably means dat most \s-1DBM\s0 filtas tend ta be straight-up short.
.SS "So whatz new?"
.IX Subsection "So whatz new?"
Da main enhancements over tha standard \s-1DBM\s0 Filta hooks are:
.IP "\(bu" 4
A cleaner intercourse.
.IP "\(bu" 4
Da mobilitizzle ta easily apply multiple filtas ta a single \s-1DBM\s0 file.
.IP "\(bu" 4
Da mobilitizzle ta create \*(L"canned\*(R" filters. These allow commonly used filters
to be packaged tha fuck into a stand-alone module.
.SH "METHODS"
.IX Header "METHODS"
This module will arrange fo' tha followin methodz ta be available via
the object returned from tha \f(CW\*(C`tie\*(C'\fR call.
.ie n .SS "$db\->\fIFilter_Push()\fP / $db\->\fIFilter_Key_Push()\fP / $db\->\fIFilter_Value_Push()\fP"
.el .SS "\f(CW$db\fP\->\fIFilter_Push()\fP / \f(CW$db\fP\->\fIFilter_Key_Push()\fP / \f(CW$db\fP\->\fIFilter_Value_Push()\fP"
.IX Subsection "$db->Filter_Push() / $db->Filter_Key_Push() / $db->Filter_Value_Push()"
Add a gangbangin' filta ta filta stack fo' tha database, \f(CW$db\fR. Da three formats
vary only up in whether they apply ta tha \s-1DBM\s0 key, tha \s-1DBM\s0 value or both.
.IP "Filter_Push" 5
.IX Item "Filter_Push"
Da filta be applied ta \fIboth\fR keys n' joints.
.IP "Filter_Key_Push" 5
.IX Item "Filter_Key_Push"
Da filta be applied ta tha key \fIonly\fR.
.IP "Filter_Value_Push" 5
.IX Item "Filter_Value_Push"
Da filta be applied ta tha value \fIonly\fR.
.ie n .SS "$db\->\fIFilter_Pop()\fP"
.el .SS "\f(CW$db\fP\->\fIFilter_Pop()\fP"
.IX Subsection "$db->Filter_Pop()"
Removes tha last filta dat was applied ta tha \s-1DBM\s0 file associated with
\&\f(CW$db\fR, if present.
.ie n .SS "$db\->\fIFiltered()\fP"
.el .SS "\f(CW$db\fP\->\fIFiltered()\fP"
.IX Subsection "$db->Filtered()"
Returns \s-1TRUE\s0 if there be any filtas applied ta tha \s-1DBM\s0 associated
with \f(CW$db\fR.  Otherwise returns \s-1FALSE.\s0
.SH "Freestylin a Filter"
.IX Header "Freestylin a Filter"
Filtas can be pimped up in two main ways
.SS "Immediate Filters"
.IX Subsection "Immediate Filters"
An immediate filta allows you ta specify tha filta code ta be used
at tha point where tha filta be applied ta a thugged-out dbm. In dis mode the
Filter_*_Push methodz expects ta receive exactly two parameters.
.PP
.Vb 3
\&    mah $db = tie %hash, \*(AqSDBM_File\*(Aq, ...
\&    $db\->Filter_Push( Store => sub { },
\&                      Fetch => sub { });
.Ve
.PP
Da code reference associated wit \f(CW\*(C`Store\*(C'\fR is ghon be called before any
key/value is freestyled ta tha database n' tha code reference associated
with \f(CW\*(C`Fetch\*(C'\fR is ghon be called afta any key/value is read from the
database.
.PP
For example, here be a sample filta dat addz a trailin \s-1NULL\s0 character
to all strings before they is freestyled ta tha \s-1DBM\s0 file, n' removes the
trailin \s-1NULL\s0 when they is read from tha \s-1DBM\s0 file
.PP
.Vb 3
\&    mah $db = tie %hash, \*(AqSDBM_File\*(Aq, ...
\&    $db\->Filter_Push( Store => sub { $_ .= "\ex00" ; },
\&                      Fetch => sub { s/\ex00$// ;    });
.Ve
.PP
Points ta note:
.IP "1." 5
Both tha Store n' Fetch filtas manipulate \f(CW$_\fR.
.SS "Canned Filters"
.IX Subsection "Canned Filters"
Immediate filtas is useful fo' one-off thangs. For mo' generic
problems it can be useful ta package tha filta up in its own module.
.PP
Da usage is fo' a cold-ass lil canned filta is:
.PP
.Vb 1
\&    $db\->Filter_Push("name", params)
.Ve
.PP
where
.ie n .IP """name""" 5
.el .IP "``name''" 5
.IX Item "name"
is tha name of tha module ta load. Y'all KNOW dat shit, muthafucka! If tha strang specified do not
contain tha package separator charactas \*(L"::\*(R", it be assumed ta refer to
the full module name \*(L"DBM_Filter::name\*(R". This means dat tha full names
for canned filters, \*(L"null\*(R" n' \*(L"utf8\*(R", included wit dis module are:
.Sp
.Vb 2
\&    DBM_Filter::null
\&    DBM_Filter::utf8
.Ve
.IP "params" 5
.IX Item "params"
any optionizzle parametas dat need ta be busted ta tha filter n' shit. Right back up in yo muthafuckin ass. See the
encode filta fo' a example of a module dat uses parameters.
.PP
Da module dat implements tha canned filta can take one of two
forms yo. Here be a template fo' tha first
.PP
.Vb 1
\&    package DBM_Filter::null ;
\&
\&    use strict;
\&    use warnings;
\&
\&    sub Store 
\&    {
\&        # store code here    
\&    }
\&
\&    sub Fetch
\&    {
\&        # fetch code here
\&    }
\&
\&    1;
.Ve
.PP
Notes:
.IP "1." 5
Da package name uses tha \f(CW\*(C`DBM_Filter::\*(C'\fR prefix.
.IP "2." 5
Da module \fImust\fR have both a Store n' a Fetch method. Y'all KNOW dat shit, muthafucka! If only one is
present, or neither is present, a gangbangin' fatal error is ghon be thrown.
.PP
Da second form allows tha filta ta hold state shiznit rockin a
closure, thus:
.PP
.Vb 1
\&    package DBM_Filter::encodin ;
\&
\&    use strict;
\&    use warnings;
\&
\&    sub Filter
\&    {
\&        mah @params = @_ ;
\&
\&        ...
\&        return {
\&            Store   => sub { $_ = $encoding\->encode($_) },
\&            Fetch   => sub { $_ = $encoding\->decode($_) }
\&            } ;
\&    }
\&
\&    1;
.Ve
.PP
In dis instizzle tha \*(L"Store\*(R" n' \*(L"Fetch\*(R" methodz is encapsulated inside a
\&\*(L"Filter\*(R" method.
.SH "Filtas Included"
.IX Header "Filtas Included"
A number of canned filaz is provided wit dis module. They cover a
number of tha main areas dat filtas is needed when interfacin with
\&\s-1DBM\s0 files. They also act as templates fo' yo' own filters.
.PP
Da filta included are:
.IP "\(bu" 5
utf8
.Sp
This module will ensure dat all data freestyled ta tha \s-1DBM\s0 is ghon be encoded
in \s-1UTF\-8.\s0
.Sp
This module needz tha Encode module.
.IP "\(bu" 5
encode
.Sp
Allows you ta chizzle tha characta encodin is ghon be store up in tha \s-1DBM\s0 file.
.IP "\(bu" 5
compress
.Sp
This filta will compress all data before it is freestyled ta tha database
and uncompressed it on reading.
.Sp
This module needz Compress::Zlib.
.IP "\(bu" 5
int32
.Sp
This module is used when interoperatin wit a C/\*(C+ application that
uses a C int as either tha key and/or value up in tha \s-1DBM\s0 file.
.IP "\(bu" 5
null
.Sp
This module ensures dat all data freestyled ta tha \s-1DBM\s0 file is null
terminated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This is useful when you gotz a perl script dat needs
to interoperate wit a \s-1DBM\s0 file dat a C program also uses fo' realz. A fairly
common issue is fo' tha C application ta include tha terminatin null
in a strang when it writes ta tha \s-1DBM\s0 file. This filta will ensure that
all data freestyled ta tha \s-1DBM\s0 file can be read by tha C application.
.SH "NOTES"
.IX Header "NOTES"
.SS "Maintain Round Trip Integrity"
.IX Subsection "Maintain Round Trip Integrity"
When freestylin a \s-1DBM\s0 filta it is \fIvery\fR blingin ta ensure dat it is
possible ta retrieve all data dat you have freestyled when tha \s-1DBM\s0 filter
is up in place. In practice, dis means dat whatever transformation is
applied ta tha data up in tha Store method, tha \fIexact\fR inverse operation
should be applied up in tha Fetch method.
.PP
If you don't provide a exact inverse transformation, yo big-ass booty is ghon find that
code like dis aint gonna behave as you expect.
.PP
.Vb 4
\&     while (my ($k, $v) = each %hash)
\&     {
\&         ...
\&     }
.Ve
.PP
Dependin on tha transformation, yo big-ass booty is ghon find dat one or mo' of the
followin will happen
.IP "1." 5
Da loop aint NEVER gonna terminate.
.IP "2." 5
Too few recordz is ghon be retrieved.
.IP "3." 5
Too nuff is ghon be retrieved.
.IP "4." 5
Da loop will do tha right thang fo' a while yo, but it will unexpectedly fail.
.SS "Don't mix filtered & non-filtered data up in tha same database file."
.IX Subsection "Don't mix filtered & non-filtered data up in tha same database file."
This is just a restatement of tha previous section. I aint talkin' bout chicken n' gravy biatch. Unless yo ass is
completely certain you know what tha fuck yo ass is bustin, avoid mixin filtered &
non-filtered data.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Say you need ta interoperate wit a legacy C application dat stores
keys as C ints n' tha joints n' null terminated \s-1UTF\-8\s0 strings yo. Here
is how tha fuck you would set dat up
.PP
.Vb 1
\&    mah $db = tie %hash, \*(AqSDBM_File\*(Aq, ...
\&
\&    $db\->Filter_Key_Push(\*(Aqint32\*(Aq) ;
\&
\&    $db\->Filter_Value_Push(\*(Aqutf8\*(Aq);
\&    $db\->Filter_Value_Push(\*(Aqnull\*(Aq);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<DB_File>,  GDBM_File, NDBM_File, ODBM_File, SDBM_File, perldbmfilter
.SH "AUTHOR"
.IX Header "AUTHOR"
Pizzle Marquess <pmqs@cpan.org>
