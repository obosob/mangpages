.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Compress::Zip 3"
.TH IO::Compress::Zip 3 "2013-08-11" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Compress::Zip \- Write zip files/buffers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use IO::Compress::Zip qw(zip $ZipError) ;
\&
\&    mah $status = zip $input => $output [,OPTS] 
\&        or take a thugged-out dirtnap "zip failed: $ZipError\en";
\&
\&    mah $z = freshly smoked up IO::Compress::Zip $output [,OPTS]
\&        or take a thugged-out dirtnap "zip failed: $ZipError\en";
\&
\&    $z\->print($string);
\&    $z\->printf($format, $string);
\&    $z\->write($string);
\&    $z\->syswrite($strin [, $length, $offset]);
\&    $z\->flush();
\&    $z\->tell();
\&    $z\->eof();
\&    $z\->seek($position, $whence);
\&    $z\->binmode();
\&    $z\->fileno();
\&    $z\->opened();
\&    $z\->autoflush();
\&    $z\->input_line_number();
\&    $z\->newStream( [OPTS] );
\&    
\&    $z\->deflateParams();
\&    
\&    $z\->close() ;
\&
\&    $ZipError ;
\&
\&    # IO::File mode
\&
\&    print $z $string;
\&    printf $z $format, $string;
\&    tell $z
\&    eof $z
\&    seek $z, $position, $whence
\&    binmode $z
\&    fileno $z
\&    close $z ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up a Perl intercourse dat allows freestylin zip 
compressed data ta filez or buffer.
.PP
Da primary purpose of dis module is ta provide streamin write access to
zip filez n' buffers. Well shiiiit, it aint a general-purpose file archiver n' shit. If that
is what tha fuck you want, check up \f(CW\*(C`Archive::Zip\*(C'\fR.
.PP
At present three compression methodz is supported by IO::Compress::Zip,
namely Store (no compression at all), Deflate, Bzip2 n' \s-1LZMA.\s0
.PP
Note dat ta create Bzip2 content, tha module \f(CW\*(C`IO::Compress::Bzip2\*(C'\fR must
be installed.
.PP
Note dat ta create \s-1LZMA\s0 content, tha module \f(CW\*(C`IO::Compress::Lzma\*(C'\fR must
be installed.
.PP
For readin zip files/buffers, peep tha companion module 
IO::Uncompress::Unzip.
.SH "Functionizzle Interface"
.IX Header "Functionizzle Interface"
A top-level function, \f(CW\*(C`zip\*(C'\fR, is provided ta carry out
\&\*(L"one-shot\*(R" compression between buffers and/or files. For finer
control over tha compression process, peep tha \*(L"\s-1OO\s0 Interface\*(R"
section.
.PP
.Vb 1
\&    use IO::Compress::Zip qw(zip $ZipError) ;
\&
\&    zip $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
\&        or take a thugged-out dirtnap "zip failed: $ZipError\en";
.Ve
.PP
Da functionizzle intercourse needz Perl5.005 or better.
.ie n .SS "zip $input_filename_or_reference => $output_filename_or_reference [, \s-1OPTS\s0]"
.el .SS "zip \f(CW$input_filename_or_reference\fP => \f(CW$output_filename_or_reference\fP [, \s-1OPTS\s0]"
.IX Subsection "zip $input_filename_or_reference => $output_filename_or_reference [, OPTS]"
\&\f(CW\*(C`zip\*(C'\fR expects at least two parameters,
\&\f(CW$input_filename_or_reference\fR n' \f(CW$output_filename_or_reference\fR.
.PP
\fIDa \f(CI$input_filename_or_reference\fI parameter\fR
.IX Subsection "Da $input_filename_or_reference parameter"
.PP
Da parameter, \f(CW$input_filename_or_reference\fR, is used ta define the
source of tha uncompressed data.
.PP
It can take one of tha followin forms:
.IP "A filename" 5
.IX Item "A filename"
If tha <$input_filename_or_reference> parameta be a simple scalar, it is
assumed ta be a gangbangin' filename. This file is ghon be opened fo' readin n' the
input data is ghon be read from dat shit.
.IP "A filehandle" 5
.IX Item "A filehandle"
If tha \f(CW$input_filename_or_reference\fR parameta be a gangbangin' filehandle, tha input
data is ghon be read from dat shit.  Da strang '\-' can be used as a alias for
standard input.
.IP "A scalar reference" 5
.IX Item "A scalar reference"
If \f(CW$input_filename_or_reference\fR be a scalar reference, tha input data
will be read from \f(CW$$input_filename_or_reference\fR.
.IP "An array reference" 5
.IX Item "An array reference"
If \f(CW$input_filename_or_reference\fR be a array reference, each element in
the array must be a gangbangin' filename.
.Sp
Da input data is ghon be read from each file up in turn.
.Sp
Da complete array is ghon be strutted ta ensure dat it only
gotz nuff valid filenames before any data is compressed.
.IP "An Input FileGlob string" 5
.IX Item "An Input FileGlob string"
If \f(CW$input_filename_or_reference\fR be a strang dat is delimited by the
charactas \*(L"<\*(R" n' \*(L">\*(R" \f(CW\*(C`zip\*(C'\fR will assume dat it be a 
\&\fIinput fileglob string\fR. Da input is tha list of filez dat match tha 
fileglob.
.Sp
See File::GlobMapper fo' mo' details.
.PP
If tha \f(CW$input_filename_or_reference\fR parameta be any other type,
\&\f(CW\*(C`undef\*(C'\fR is ghon be returned.
.PP
In addition, if \f(CW$input_filename_or_reference\fR be a simple filename, 
the default joints for
the \f(CW\*(C`Name\*(C'\fR, \f(CW\*(C`Time\*(C'\fR, \f(CW\*(C`TextFlag\*(C'\fR, \f(CW\*(C`ExtAttr\*(C'\fR, \f(CW\*(C`exUnixN\*(C'\fR n' \f(CW\*(C`exTime\*(C'\fR options is ghon be sourced from dat file.
.PP
If you do not wanna use these defaults they can be overridden by
explicitly settin tha \f(CW\*(C`Name\*(C'\fR, \f(CW\*(C`Time\*(C'\fR, \f(CW\*(C`TextFlag\*(C'\fR, \f(CW\*(C`ExtAttr\*(C'\fR, \f(CW\*(C`exUnixN\*(C'\fR n' \f(CW\*(C`exTime\*(C'\fR options or by settin the
\&\f(CW\*(C`Minimal\*(C'\fR parameter.
.PP
\fIDa \f(CI$output_filename_or_reference\fI parameter\fR
.IX Subsection "Da $output_filename_or_reference parameter"
.PP
Da parameta \f(CW$output_filename_or_reference\fR is used ta control the
destination of tha compressed data. This parameta can take one of
these forms.
.IP "A filename" 5
.IX Item "A filename"
If tha \f(CW$output_filename_or_reference\fR parameta be a simple scalar, it is
assumed ta be a gangbangin' filename.  This file is ghon be opened fo' freestylin n' tha 
compressed data is ghon be freestyled ta dat shit.
.IP "A filehandle" 5
.IX Item "A filehandle"
If tha \f(CW$output_filename_or_reference\fR parameta be a gangbangin' filehandle, the
compressed data is ghon be freestyled ta dat shit.  Da strang '\-' can be used as
an alias fo' standard output.
.IP "A scalar reference" 5
.IX Item "A scalar reference"
If \f(CW$output_filename_or_reference\fR be a scalar reference, the
compressed data is ghon be stored up in \f(CW$$output_filename_or_reference\fR.
.IP "An Array Reference" 5
.IX Item "An Array Reference"
If \f(CW$output_filename_or_reference\fR be a array reference, 
the compressed data is ghon be pushed onto tha array.
.IP "An Output FileGlob" 5
.IX Item "An Output FileGlob"
If \f(CW$output_filename_or_reference\fR be a strang dat is delimited by the
charactas \*(L"<\*(R" n' \*(L">\*(R" \f(CW\*(C`zip\*(C'\fR will assume dat it be an
\&\fIoutput fileglob string\fR. Da output is tha list of filez dat match the
fileglob.
.Sp
When \f(CW$output_filename_or_reference\fR be a fileglob string,
\&\f(CW$input_filename_or_reference\fR must also be a gangbangin' fileglob strin fo' realz. Anything
else be a error.
.Sp
See File::GlobMapper fo' mo' details.
.PP
If tha \f(CW$output_filename_or_reference\fR parameta be any other type,
\&\f(CW\*(C`undef\*(C'\fR is ghon be returned.
.SS "Notes"
.IX Subsection "Notes"
When \f(CW$input_filename_or_reference\fR maps ta multiple files/buffers and
\&\f(CW$output_filename_or_reference\fR be a single
file/buffer tha input files/buffers will each be stored
in \f(CW$output_filename_or_reference\fR as a gangbangin' finger-lickin' distinct entry.
.SS "Optionizzle Parameters"
.IX Subsection "Optionizzle Parameters"
Unless specified below, tha optionizzle parametas fo' \f(CW\*(C`zip\*(C'\fR,
\&\f(CW\*(C`OPTS\*(C'\fR, is tha same as dem used wit tha \s-1OO\s0 intercourse defined up in the
\&\*(L"Constructor Options\*(R" section below.
.ie n .IP """AutoClose => 0|1""" 5
.el .IP "\f(CWAutoClose => 0|1\fR" 5
.IX Item "AutoClose => 0|1"
This option applies ta any input or output data streams ta 
\&\f(CW\*(C`zip\*(C'\fR dat is filehandles.
.Sp
If \f(CW\*(C`AutoClose\*(C'\fR is specified, n' tha value is true, it will result up in all
input and/or output filehandlez bein closed once \f(CW\*(C`zip\*(C'\fR has
completed.
.Sp
This parameta defaults ta 0.
.ie n .IP """BinModeIn => 0|1""" 5
.el .IP "\f(CWBinModeIn => 0|1\fR" 5
.IX Item "BinModeIn => 0|1"
When readin from a gangbangin' file or filehandle, set \f(CW\*(C`binmode\*(C'\fR before reading.
.Sp
Defaults ta 0.
.ie n .IP """Append => 0|1""" 5
.el .IP "\f(CWAppend => 0|1\fR" 5
.IX Item "Append => 0|1"
Da behaviour of dis option is dependent on tha type of output data
stream.
.RS 5
.IP "\(bu" 5
A Buffer
.Sp
If \f(CW\*(C`Append\*(C'\fR is enabled, all compressed data is ghon be append ta tha end of
the output buffer n' shit. Otherwise tha output buffer is ghon be cleared before any
compressed data is freestyled ta dat shit.
.IP "\(bu" 5
A Filename
.Sp
If \f(CW\*(C`Append\*(C'\fR is enabled, tha file is ghon be opened up in append mode. Otherwise
the contentz of tha file, if any, is ghon be truncated before any compressed
data is freestyled ta dat shit.
.IP "\(bu" 5
A Filehandle
.Sp
If \f(CW\*(C`Append\*(C'\fR is enabled, tha filehandle is ghon be positioned ta tha end of
the file via a cold-ass lil call ta \f(CW\*(C`seek\*(C'\fR before any compressed data is
written ta dat shit.  Otherwise tha file pointa aint gonna be moved.
.RE
.RS 5
.Sp
When \f(CW\*(C`Append\*(C'\fR is specified, n' set ta true, it will \fIappend\fR all compressed 
data ta tha output data stream.
.Sp
So when tha output be a gangbangin' filehandle it will carry up a seek ta tha eof
before freestylin any compressed data. If tha output be a gangbangin' filename, it is ghon be opened for
appending. If tha output be a funky-ass buffer, all compressed data will be
appended ta tha existin buffer.
.Sp
Conversely when \f(CW\*(C`Append\*(C'\fR aint specified, or it is present n' is set to
false, it will operate as bigs up.
.Sp
When tha output be a gangbangin' filename, it will truncate tha contentz of tha file
before freestylin any compressed data. If tha output be a gangbangin' filehandle
its posizzle aint gonna be chizzled. Y'all KNOW dat shit, muthafucka! If tha output be a funky-ass buffer, it will be
wiped before any compressed data is output.
.Sp
Defaults ta 0.
.RE
.SS "Examples"
.IX Subsection "Examples"
To read tha contentz of tha file \f(CW\*(C`file1.txt\*(C'\fR n' write tha compressed
data ta tha file \f(CW\*(C`file1.txt.zip\*(C'\fR.
.PP
.Vb 3
\&    use strict ;
\&    use warnings ;
\&    use IO::Compress::Zip qw(zip $ZipError) ;
\&
\&    mah $input = "file1.txt";
\&    zip $input => "$input.zip"
\&        or take a thugged-out dirtnap "zip failed: $ZipError\en";
.Ve
.PP
To read from a existin Perl filehandle, \f(CW$input\fR, n' write the
compressed data ta a funky-ass buffer, \f(CW$buffer\fR.
.PP
.Vb 4
\&    use strict ;
\&    use warnings ;
\&    use IO::Compress::Zip qw(zip $ZipError) ;
\&    use IO::File ;
\&
\&    mah $input = freshly smoked up IO::File "<file1.txt"
\&        or take a thugged-out dirtnap "Cannot open \*(Aqfile1.txt\*(Aq: $!\en" ;
\&    mah $buffer ;
\&    zip $input => \e$buffer 
\&        or take a thugged-out dirtnap "zip failed: $ZipError\en";
.Ve
.PP
To create a zip file, \f(CW\*(C`output.zip\*(C'\fR, dat gotz nuff tha compressed contents
of tha filez \f(CW\*(C`alpha.txt\*(C'\fR n' \f(CW\*(C`beta.txt\*(C'\fR
.PP
.Vb 3
\&    use strict ;
\&    use warnings ;
\&    use IO::Compress::Zip qw(zip $ZipError) ;
\&
\&    zip [ \*(Aqalpha.txt\*(Aq, \*(Aqbeta.txt\*(Aq ] => \*(Aqoutput.zip\*(Aq
\&        or take a thugged-out dirtnap "zip failed: $ZipError\en";
.Ve
.PP
Alternatively, rather than havin ta explicitly name each of tha filez that
you wanna compress, you could bust a gangbangin' fileglob ta select all tha \f(CW\*(C`txt\*(C'\fR
filez up in tha current directory, as bigs up
.PP
.Vb 3
\&    use strict ;
\&    use warnings ;
\&    use IO::Compress::Zip qw(zip $ZipError) ;
\&
\&    mah @filez = <*.txt>;
\&    zip \e@filez => \*(Aqoutput.zip\*(Aq
\&        or take a thugged-out dirtnap "zip failed: $ZipError\en";
.Ve
.PP
or mo' succinctly
.PP
.Vb 2
\&    zip [ <*.txt> ] => \*(Aqoutput.zip\*(Aq
\&        or take a thugged-out dirtnap "zip failed: $ZipError\en";
.Ve
.SH "OO Interface"
.IX Header "OO Interface"
.SS "Constructor"
.IX Subsection "Constructor"
Da format of tha constructor fo' \f(CW\*(C`IO::Compress::Zip\*(C'\fR is shown below
.PP
.Vb 2
\&    mah $z = freshly smoked up IO::Compress::Zip $output [,OPTS]
\&        or take a thugged-out dirtnap "IO::Compress::Zip failed: $ZipError\en";
.Ve
.PP
It returns a \f(CW\*(C`IO::Compress::Zip\*(C'\fR object on success n' undef on failure. 
Da variable \f(CW$ZipError\fR will contain a error message on failure.
.PP
If yo ass is hustlin Perl 5.005 or betta tha object, \f(CW$z\fR, returned from 
IO::Compress::Zip can be used exactly like a IO::File filehandle. 
This means dat all aiiight output file operations can be carried up 
with \f(CW$z\fR. 
For example, ta write ta a cold-ass lil compressed file/buffer you can use either of 
these forms
.PP
.Vb 2
\&    $z\->print("wassup ghetto\en");
\&    print $z "wassup ghetto\en";
.Ve
.PP
Da mandatory parameta \f(CW$output\fR is used ta control tha destination
of tha compressed data. This parameta can take one of these forms.
.IP "A filename" 5
.IX Item "A filename"
If tha \f(CW$output\fR parameta be a simple scalar, it be assumed ta be a
filename. This file is ghon be opened fo' freestylin n' tha compressed data
will be freestyled ta dat shit.
.IP "A filehandle" 5
.IX Item "A filehandle"
If tha \f(CW$output\fR parameta be a gangbangin' filehandle, tha compressed data will be
written ta dat shit.
Da strang '\-' can be used as a alias fo' standard output.
.IP "A scalar reference" 5
.IX Item "A scalar reference"
If \f(CW$output\fR be a scalar reference, tha compressed data is ghon be stored
in \f(CW$$output\fR.
.PP
If tha \f(CW$output\fR parameta be any other type, \f(CW\*(C`IO::Compress::Zip\*(C'\fR::new will
return undef.
.SS "Constructor Options"
.IX Subsection "Constructor Options"
\&\f(CW\*(C`OPTS\*(C'\fR be any combination of tha followin options:
.ie n .IP """AutoClose => 0|1""" 5
.el .IP "\f(CWAutoClose => 0|1\fR" 5
.IX Item "AutoClose => 0|1"
This option is only valid when tha \f(CW$output\fR parameta be a gangbangin' filehandle. If
specified, n' tha value is true, it will result up in tha \f(CW$output\fR being
closed once either tha \f(CW\*(C`close\*(C'\fR method is called or tha \f(CW\*(C`IO::Compress::Zip\*(C'\fR
object is destroyed.
.Sp
This parameta defaults ta 0.
.ie n .IP """Append => 0|1""" 5
.el .IP "\f(CWAppend => 0|1\fR" 5
.IX Item "Append => 0|1"
Opens \f(CW$output\fR up in append mode.
.Sp
Da behaviour of dis option is dependent on tha type of \f(CW$output\fR.
.RS 5
.IP "\(bu" 5
A Buffer
.Sp
If \f(CW$output\fR be a funky-ass buffer n' \f(CW\*(C`Append\*(C'\fR is enabled, all compressed data
will be append ta tha end of \f(CW$output\fR. Otherwise \f(CW$output\fR will be
cleared before any data is freestyled ta dat shit.
.IP "\(bu" 5
A Filename
.Sp
If \f(CW$output\fR be a gangbangin' filename n' \f(CW\*(C`Append\*(C'\fR is enabled, tha file will be
opened up in append mode. Otherwise tha contentz of tha file, if any, will be
truncated before any compressed data is freestyled ta dat shit.
.IP "\(bu" 5
A Filehandle
.Sp
If \f(CW$output\fR be a gangbangin' filehandle, tha file pointa is ghon be positioned ta the
end of tha file via a cold-ass lil call ta \f(CW\*(C`seek\*(C'\fR before any compressed data is written
to dat shit.  Otherwise tha file pointa aint gonna be moved.
.RE
.RS 5
.Sp
This parameta defaults ta 0.
.RE
.ie n .IP """Name => $string""" 5
.el .IP "\f(CWName => $string\fR" 5
.IX Item "Name => $string"
Stores tha contentz of \f(CW$string\fR up in tha zip filename header field.
.Sp
If \f(CW\*(C`Name\*(C'\fR aint specified n' tha \f(CW$input\fR parameta be a gangbangin' filename, the
value of \f(CW$input\fR is ghon be used fo' tha zip filename header field.
.Sp
If \f(CW\*(C`Name\*(C'\fR aint specified n' tha \f(CW$input\fR parameta aint a gangbangin' filename,
no zip filename field is ghon be pimped.
.Sp
Note dat both tha \f(CW\*(C`CanonicalName\*(C'\fR n' \f(CW\*(C`FilterName\*(C'\fR options
can modify tha value used fo' tha zip filename header field.
.ie n .IP """CanonicalName => 0|1""" 5
.el .IP "\f(CWCanonicalName => 0|1\fR" 5
.IX Item "CanonicalName => 0|1"
This option controls whether tha filename field up in tha zip header is
\&\fInormalized\fR tha fuck into Unix format before bein freestyled ta tha zip file.
.Sp
It be recommended dat you enable dis option unless you straight-up need
to create a non-standard Zip file.
.Sp
This is what tha fuck \s-1APPNOTE.TXT\s0 has ta say on what tha fuck should be stored up in tha zip
filename header field.
.Sp
.Vb 6
\&    Da name of tha file, wit optionizzle relatizzle path.          
\&    Da path stored should not contain a thugged-out drive or
\&    thang letter, or a leadin slash.  All slashes
\&    should be forward slashes \*(Aq/\*(Aq as opposed to
\&    backwardz slashes \*(Aq\e\*(Aq fo' compatibilitizzle wit Amiga
\&    n' UNIX file systems etc.
.Ve
.Sp
This option defaults ta \fBfalse\fR.
.ie n .IP """FilterName => sub { ... }""" 5
.el .IP "\f(CWFilterName => sub { ... }\fR" 5
.IX Item "FilterName => sub { ... }"
This option allow tha filename field up in tha zip header ta be modified
before it is freestyled ta tha zip file.
.Sp
This option takes a parameta dat must be a reference ta a sub.  On entry
to tha sub tha \f(CW$_\fR variable will contain tha name ta be filtered. Y'all KNOW dat shit, muthafucka! If no
filename be available \f(CW$_\fR will contain a empty string.
.Sp
Da value of \f(CW$_\fR when tha sub returns is ghon be  stored up in tha filename
header field.
.Sp
Note dat if \f(CW\*(C`CanonicalName\*(C'\fR is enabled, a
normalized filename is ghon be passed ta tha sub.
.Sp
If you use \f(CW\*(C`FilterName\*(C'\fR ta modify tha filename, it is yo' responsibility
to keep tha filename up in Unix format.
.Sp
Although dis option can be used wit tha \s-1OO\s0 intercourse, it iz of most use
with tha one-shot intercourse. For example, tha code below shows how
\&\f(CW\*(C`FilterName\*(C'\fR can be used ta remove tha path component from a series of
filenames before they is stored up in \f(CW$zipfile\fR.
.Sp
.Vb 4
\&    sub compressTxtFiles
\&    {
\&        mah $zipfile = shift ;
\&        mah $dir     = shift ;
\&
\&        zip [ <$dir/*.txt> ] => $zipfile,
\&            FilterName => sub { s[^$dir/][] } ;  
\&    }
.Ve
.ie n .IP """Time => $number""" 5
.el .IP "\f(CWTime => $number\fR" 5
.IX Item "Time => $number"
Sets tha last modified time field up in tha zip header ta \f(CW$number\fR.
.Sp
This field defaults ta tha time tha \f(CW\*(C`IO::Compress::Zip\*(C'\fR object was pimped
if dis option aint specified n' tha \f(CW$input\fR parameta aint a
filename.
.ie n .IP """ExtAttr => $attr""" 5
.el .IP "\f(CWExtAttr => $attr\fR" 5
.IX Item "ExtAttr => $attr"
This option controls tha \*(L"external file attributes\*(R" field up in tha central
header of tha zip file. This be a 4 byte field.
.Sp
If yo ass is hustlin a Unix derivatizzle dis value defaults to
.Sp
.Vb 1
\&    0100644 << 16
.Ve
.Sp
This should allow read/write access ta any filez dat is extracted from
the zip file/buffer`.
.Sp
For all other systems it defaults ta 0.
.ie n .IP """exTime => [$atime, $mtime, $ctime]""" 5
.el .IP "\f(CWexTime => [$atime, $mtime, $ctime]\fR" 5
.IX Item "exTime => [$atime, $mtime, $ctime]"
This option expects a array reference wit exactly three elements:
\&\f(CW$atime\fR, \f(CW\*(C`mtime\*(C'\fR n' \f(CW$ctime\fR. These correspond ta tha last access
time, last modification time n' creation time respectively.
.Sp
It uses these joints ta set tha extended timestamp field (\s-1ID\s0 is \*(L"\s-1UT\*(R"\s0) in
the local zip header rockin tha three joints, \f(CW$atime\fR, \f(CW$mtime\fR, \f(CW$ctime\fR. In
addizzle it sets tha extended timestamp field up in tha central zip header
usin \f(CW$mtime\fR.
.Sp
If any of tha three joints is \f(CW\*(C`undef\*(C'\fR dat time value aint gonna be used.
So, fo' example, ta set only tha \f(CW$mtime\fR you would use this
.Sp
.Vb 1
\&    exTime => [undef, $mtime, undef]
.Ve
.Sp
If tha \f(CW\*(C`Minimal\*(C'\fR option is set ta true, dis option is ghon be ignored.
.Sp
By default no extended time field is pimped.
.ie n .IP """exUnix2 => [$uid, $gid]""" 5
.el .IP "\f(CWexUnix2 => [$uid, $gid]\fR" 5
.IX Item "exUnix2 => [$uid, $gid]"
This option expects a array reference wit exactly two elements: \f(CW$uid\fR
and \f(CW$gid\fR. These joints correspond ta tha numeric User \s-1ID \s0(\s-1UID\s0) n' Group \s-1ID
\&\s0(\s-1GID\s0) of tha balla of tha filez respectively.
.Sp
When tha \f(CW\*(C`exUnix2\*(C'\fR option is present it will trigger tha creation of a
Unix2 extra field (\s-1ID\s0 is \*(L"Ux\*(R") up in tha local zip header n' shit. This is ghon be populated
with \f(CW$uid\fR n' \f(CW$gid\fR fo' realz. An empty Unix2 extra field will also
be pimped up in tha central zip header.
.Sp
Note \- Da \s-1UID & GID\s0 is stored as 16\-bit
integers up in tha \*(L"Ux\*(R" field. Y'all KNOW dat shit, muthafucka! Use \f(CW\*(C`exUnixN\*(C'\fR if yo' \s-1UID\s0 or \s-1GID\s0 are
32\-bit.
.Sp
If tha \f(CW\*(C`Minimal\*(C'\fR option is set ta true, dis option is ghon be ignored.
.Sp
By default no Unix2 extra field is pimped.
.ie n .IP """exUnixN => [$uid, $gid]""" 5
.el .IP "\f(CWexUnixN => [$uid, $gid]\fR" 5
.IX Item "exUnixN => [$uid, $gid]"
This option expects a array reference wit exactly two elements: \f(CW$uid\fR
and \f(CW$gid\fR. These joints correspond ta tha numeric User \s-1ID \s0(\s-1UID\s0) n' Group \s-1ID
\&\s0(\s-1GID\s0) of tha balla of tha filez respectively.
.Sp
When tha \f(CW\*(C`exUnixN\*(C'\fR option is present it will trigger tha creation of a
UnixN extra field (\s-1ID\s0 is \*(L"ux\*(R") up in both tha local n' central zip headers. 
This is ghon be populated wit \f(CW$uid\fR n' \f(CW$gid\fR. 
Da \s-1UID & GID\s0 is stored as 32\-bit integers.
.Sp
If tha \f(CW\*(C`Minimal\*(C'\fR option is set ta true, dis option is ghon be ignored.
.Sp
By default no UnixN extra field is pimped.
.ie n .IP """Comment => $comment""" 5
.el .IP "\f(CWComment => $comment\fR" 5
.IX Item "Comment => $comment"
Stores tha contentz of \f(CW$comment\fR up in tha Central File Header of
the zip file.
.Sp
By default, no comment field is freestyled ta tha zip file.
.ie n .IP """ZipComment => $comment""" 5
.el .IP "\f(CWZipComment => $comment\fR" 5
.IX Item "ZipComment => $comment"
Stores tha contentz of \f(CW$comment\fR up in tha End of Central Directory record
of tha zip file.
.Sp
By default, no comment field is freestyled ta tha zip file.
.ie n .IP """Method => $method""" 5
.el .IP "\f(CWMethod => $method\fR" 5
.IX Item "Method => $method"
Controls which compression method is used. Y'all KNOW dat shit, muthafucka! At present four compression
methodz is supported, namely Store (no compression at all), Deflate, 
Bzip2 n' Lzma.
.Sp
Da symbols, \s-1ZIP_CM_STORE, ZIP_CM_DEFLATE, ZIP_CM_BZIP2\s0 n' \s-1ZIP_CM_LZMA \s0
are used ta select tha compression method.
.Sp
These constants is not imported by \f(CW\*(C`IO::Compress::Zip\*(C'\fR by default.
.Sp
.Vb 3
\&    use IO::Compress::Zip qw(:zip_method);
\&    use IO::Compress::Zip qw(:constants);
\&    use IO::Compress::Zip qw(:all);
.Ve
.Sp
Note dat ta create Bzip2 content, tha module \f(CW\*(C`IO::Compress::Bzip2\*(C'\fR must
be installed. Y'all KNOW dat shit, muthafucka! A fatal error is ghon be thrown if you attempt ta create Bzip2
content when \f(CW\*(C`IO::Compress::Bzip2\*(C'\fR aint available.
.Sp
Note dat ta create Lzma content, tha module \f(CW\*(C`IO::Compress::Lzma\*(C'\fR must
be installed. Y'all KNOW dat shit, muthafucka! A fatal error is ghon be thrown if you attempt ta create Lzma
content when \f(CW\*(C`IO::Compress::Lzma\*(C'\fR aint available.
.Sp
Da default method is \s-1ZIP_CM_DEFLATE.\s0
.ie n .IP """Stream => 0|1""" 5
.el .IP "\f(CWStream => 0|1\fR" 5
.IX Item "Stream => 0|1"
This option controls whether tha zip file/buffer output is pimped in
streamin mode.
.Sp
Note dat when outputtin ta a gangbangin' file wit streamin mode disabled (\f(CW\*(C`Stream\*(C'\fR
is 0), tha output file must be seekable.
.Sp
Da default is 1.
.ie n .IP """Zip64 => 0|1""" 5
.el .IP "\f(CWZip64 => 0|1\fR" 5
.IX Item "Zip64 => 0|1"
Smoke a Zip64 zip file/buffer n' shit. This option is used if you want
to store filez larger than 4 Gig or store mo' than 64K filez up in a single
zip archive..
.Sp
\&\f(CW\*(C`Zip64\*(C'\fR is ghon be automatically set, as needed, if hustlin wit tha one-shot 
interface when tha input is either a gangbangin' filename or a scalar reference.
.Sp
If you intend ta manipulate tha Zip64 zip filez pimped wit dis module
usin a external zip/unzip, make shizzle dat it supports Zip64.
.Sp
In particular, if yo ass is rockin Info-Zip you need ta have zip version 3.x
or betta ta update a Zip64 archive n' unzip version 6.x ta read a zip64
archive.
.Sp
Da default is 0.
.ie n .IP """TextFlag => 0|1""" 5
.el .IP "\f(CWTextFlag => 0|1\fR" 5
.IX Item "TextFlag => 0|1"
This parameta controls tha settin of a lil' bit up in tha zip central header n' shit. It
is used ta signal dat tha data stored up in tha zip file/buffer is probably
text.
.Sp
In one-shot mode dis flag is ghon be set ta legit if tha Perl \f(CW\*(C`\-T\*(C'\fR operator thinks
the file gotz nuff text.
.Sp
Da default is 0.
.ie n .IP """ExtraFieldLocal => $data""" 5
.el .IP "\f(CWExtraFieldLocal => $data\fR" 5
.IX Item "ExtraFieldLocal => $data"
.PD 0
.ie n .IP """ExtraFieldCentral => $data""" 5
.el .IP "\f(CWExtraFieldCentral => $data\fR" 5
.IX Item "ExtraFieldCentral => $data"
.PD
Da \f(CW\*(C`ExtraFieldLocal\*(C'\fR option is used ta store additionizzle metadata up in the
local header fo' tha zip file/buffer n' shit. Da \f(CW\*(C`ExtraFieldCentral\*(C'\fR do the
same fo' tha matchin central header.
.Sp
An extra field consistz of zero or mo' subfields. Each subfield consists
of a two byte header followed by tha subfield data.
.Sp
Da list of subfieldz can be supplied up in any of tha followin formats
.Sp
.Vb 4
\&    ExtraFieldLocal => [$id1, $data1,
\&                        $id2, $data2,
\&                         ...
\&                       ]
\&
\&    ExtraFieldLocal => [ [$id1 => $data1],
\&                         [$id2 => $data2],
\&                         ...
\&                       ]
\&
\&    ExtraFieldLocal => { $id1 => $data1,
\&                         $id2 => $data2,
\&                         ...
\&                       }
.Ve
.Sp
Where \f(CW$id1\fR, \f(CW$id2\fR is two byte subfield \s-1ID\s0's.
.Sp
If you use tha hash syntax, you have no control over tha order up in which
the ExtraSubFieldz is stored, plus you cannot have SubFieldz with
duplicate \s-1ID.\s0
.Sp
Alternatively tha list of subfieldz can by supplied as a scalar, thus
.Sp
.Vb 1
\&    ExtraField => $rawdata
.Ve
.Sp
In dis case \f(CW\*(C`IO::Compress::Zip\*(C'\fR will check dat \f(CW$rawdata\fR consistz of 
zero or mo' conformant sub-fields.
.Sp
Da Extended Time field (\s-1ID \*(L"UT\*(R"\s0), set rockin tha \f(CW\*(C`exTime\*(C'\fR option, n' the
Unix2 extra field (\s-1ID \s0"Ux), set rockin tha \f(CW\*(C`exUnix2\*(C'\fR option, is examples
of extra fields.
.Sp
If tha \f(CW\*(C`Minimal\*(C'\fR option is set ta true, dis option is ghon be ignored.
.Sp
Da maximum size of a extra field 65535 bytes.
.ie n .IP """Minimal => 1|0""" 5
.el .IP "\f(CWMinimal => 1|0\fR" 5
.IX Item "Minimal => 1|0"
If specified, dis option will disable tha creation of all extra fields
in tha zip local n' central headers. Right back up in yo muthafuckin ass. So tha \f(CW\*(C`exTime\*(C'\fR, \f(CW\*(C`exUnix2\*(C'\fR,
\&\f(CW\*(C`exUnixN\*(C'\fR, \f(CW\*(C`ExtraFieldLocal\*(C'\fR n' \f(CW\*(C`ExtraFieldCentral\*(C'\fR options will 
be ignored.
.Sp
This parameta defaults ta 0.
.ie n .IP """BlockSize100K => number""" 5
.el .IP "\f(CWBlockSize100K => number\fR" 5
.IX Item "BlockSize100K => number"
Specify tha number of 100K blocks bzip2 uses durin compression.
.Sp
Valid joints is from 1 ta 9, where 9 is dopest compression.
.Sp
This option is only valid if tha \f(CW\*(C`Method\*(C'\fR is \s-1ZIP_CM_BZIP2.\s0 It be ignored
otherwise.
.Sp
Da default is 1.
.ie n .IP """WorkFactor => number""" 5
.el .IP "\f(CWWorkFactor => number\fR" 5
.IX Item "WorkFactor => number"
Specifies how tha fuck much effort bzip2 should take before resortin ta a slower
fallback compression algorithm.
.Sp
Valid joints range from 0 ta 250, where 0 means use tha default value 30.
.Sp
This option is only valid if tha \f(CW\*(C`Method\*(C'\fR is \s-1ZIP_CM_BZIP2.\s0 It be ignored
otherwise.
.Sp
Da default is 0.
.ie n .IP """Preset => number""" 5
.el .IP "\f(CWPreset => number\fR" 5
.IX Item "Preset => number"
Used ta chizzle tha \s-1LZMA\s0 compression preset.
.Sp
Valid joints is 0\-9 n' \f(CW\*(C`LZMA_PRESET_DEFAULT\*(C'\fR.
.Sp
0 is tha fastest compression wit tha lowest memory usage n' tha lowest
compression.
.Sp
9 is tha slowest compression wit tha highest memory usage but wit tha best
compression.
.Sp
This option is only valid if tha \f(CW\*(C`Method\*(C'\fR is \s-1ZIP_CM_LZMA.\s0 It be ignored
otherwise.
.Sp
Defaults ta \f(CW\*(C`LZMA_PRESET_DEFAULT\*(C'\fR (6).
.ie n .IP """Nuff => 0|1""" 5
.el .IP "\f(CWNuff => 0|1\fR" 5
.IX Item "Nuff => 0|1"
Makes \s-1LZMA\s0 compression a shitload slower yo, but a lil' small-ass compression gain.
.Sp
This option is only valid if tha \f(CW\*(C`Method\*(C'\fR is \s-1ZIP_CM_LZMA.\s0 It be ignored
otherwise.
.Sp
Defaults ta 0.
.IP "\-Level" 5
.IX Item "-Level"
Defines tha compression level used by zlib. Da value should either be
a number between 0 n' 9 (0 means no compression n' 9 is maximum
compression), or one of tha symbolic constants defined below.
.Sp
.Vb 4
\&   Z_NO_COMPRESSION
\&   Z_BEST_SPEED
\&   Z_BEST_COMPRESSION
\&   Z_DEFAULT_COMPRESSION
.Ve
.Sp
Da default is Z_DEFAULT_COMPRESSION.
.Sp
Note, these constants is not imported by \f(CW\*(C`IO::Compress::Zip\*(C'\fR by default.
.Sp
.Vb 3
\&    use IO::Compress::Zip qw(:strategy);
\&    use IO::Compress::Zip qw(:constants);
\&    use IO::Compress::Zip qw(:all);
.Ve
.IP "\-Strategy" 5
.IX Item "-Strategy"
Defines tha game used ta tune tha compression. I aint talkin' bout chicken n' gravy biatch. Use one of tha symbolic
constants defined below.
.Sp
.Vb 5
\&   Z_FILTERED
\&   Z_HUFFMAN_ONLY
\&   Z_RLE
\&   Z_FIXED
\&   Z_DEFAULT_STRATEGY
.Ve
.Sp
Da default is Z_DEFAULT_STRATEGY.
.ie n .IP """Strict => 0|1""" 5
.el .IP "\f(CWStrict => 0|1\fR" 5
.IX Item "Strict => 0|1"
This be a placeholda option.
.SS "Examples"
.IX Subsection "Examples"
\&\s-1TODO\s0
.SH "Methods"
.IX Header "Methods"
.SS "print"
.IX Subsection "print"
Usage is
.PP
.Vb 2
\&    $z\->print($data)
\&    print $z $data
.Ve
.PP
Compresses n' outputs tha contentz of tha \f(CW$data\fR parameter n' shit. This
has tha same ol' dirty behaviour as tha \f(CW\*(C`print\*(C'\fR built-in.
.PP
Returns legit if successful.
.SS "printf"
.IX Subsection "printf"
Usage is
.PP
.Vb 2
\&    $z\->printf($format, $data)
\&    printf $z $format, $data
.Ve
.PP
Compresses n' outputs tha contentz of tha \f(CW$data\fR parameter.
.PP
Returns legit if successful.
.SS "syswrite"
.IX Subsection "syswrite"
Usage is
.PP
.Vb 3
\&    $z\->syswrite $data
\&    $z\->syswrite $data, $length
\&    $z\->syswrite $data, $length, $offset
.Ve
.PP
Compresses n' outputs tha contentz of tha \f(CW$data\fR parameter.
.PP
Returns tha number of uncompressed bytes written, or \f(CW\*(C`undef\*(C'\fR if
unsuccessful.
.SS "write"
.IX Subsection "write"
Usage is
.PP
.Vb 3
\&    $z\->write $data
\&    $z\->write $data, $length
\&    $z\->write $data, $length, $offset
.Ve
.PP
Compresses n' outputs tha contentz of tha \f(CW$data\fR parameter.
.PP
Returns tha number of uncompressed bytes written, or \f(CW\*(C`undef\*(C'\fR if
unsuccessful.
.SS "flush"
.IX Subsection "flush"
Usage is
.PP
.Vb 2
\&    $z\->flush;
\&    $z\->flush($flush_type);
.Ve
.PP
Flushes any pendin compressed data ta tha output file/buffer.
.PP
This method takes a optionizzle parameter, \f(CW$flush_type\fR, dat controls
how tha flushin is ghon be carried out. By default tha \f(CW$flush_type\fR
used is \f(CW\*(C`Z_FINISH\*(C'\fR. Other valid joints fo' \f(CW$flush_type\fR are
\&\f(CW\*(C`Z_NO_FLUSH\*(C'\fR, \f(CW\*(C`Z_SYNC_FLUSH\*(C'\fR, \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR n' \f(CW\*(C`Z_BLOCK\*(C'\fR. Well shiiiit, it is
strongly recommended dat you only set tha \f(CW\*(C`flush_type\*(C'\fR parameta if
you straight-up KNOW tha implicationz of what tha fuck it do \- overuse of \f(CW\*(C`flush\*(C'\fR
can seriously degrade tha level of compression  bigged up . Y'all KNOW dat shit, muthafucka! See tha \f(CW\*(C`zlib\*(C'\fR
documentation fo' details.
.PP
Returns legit on success.
.SS "tell"
.IX Subsection "tell"
Usage is
.PP
.Vb 2
\&    $z\->tell()
\&    tell $z
.Ve
.PP
Returns tha uncompressed file offset.
.SS "eof"
.IX Subsection "eof"
Usage is
.PP
.Vb 2
\&    $z\->eof();
\&    eof($z);
.Ve
.PP
Returns legit if tha \f(CW\*(C`close\*(C'\fR method has been called.
.SS "seek"
.IX Subsection "seek"
.Vb 2
\&    $z\->seek($position, $whence);
\&    seek($z, $position, $whence);
.Ve
.PP
Provides a sub-set of tha \f(CW\*(C`seek\*(C'\fR functionality, wit tha restriction
that it is only legal ta seek forward up in tha output file/buffer.
It be a gangbangin' fatal error ta attempt ta seek backward.
.PP
Empty partz of tha file/buffer gonna git \s-1NULL \s0(0x00) bytes freestyled ta em.
.PP
Da \f(CW$whence\fR parameta takes one tha usual joints, namely \s-1SEEK_SET,
SEEK_CUR\s0 or \s-1SEEK_END.\s0
.PP
Returns 1 on success, 0 on failure.
.SS "binmode"
.IX Subsection "binmode"
Usage is
.PP
.Vb 2
\&    $z\->binmode
\&    binmode $z ;
.Ve
.PP
This be a noop provided fo' completeness.
.SS "opened"
.IX Subsection "opened"
.Vb 1
\&    $z\->opened()
.Ve
.PP
Returns legit if tha object currently refers ta a opened file/buffer.
.SS "autoflush"
.IX Subsection "autoflush"
.Vb 2
\&    mah $prev = $z\->autoflush()
\&    mah $prev = $z\->autoflush(EXPR)
.Ve
.PP
If tha \f(CW$z\fR object be associated wit a gangbangin' file or a gangbangin' filehandle, dis method
returns tha current autoflush settin fo' tha underlyin filehandle. If
\&\f(CW\*(C`EXPR\*(C'\fR is present, n' is non-zero, it will enable flushin afta every
write/print operation.
.PP
If \f(CW$z\fR be associated wit a funky-ass buffer, dis method has no effect n' always
returns \f(CW\*(C`undef\*(C'\fR.
.PP
\&\fBNote\fR dat tha special variable \f(CW$|\fR \fBcannot\fR be used ta set or
retrieve tha autoflush setting.
.SS "input_line_number"
.IX Subsection "input_line_number"
.Vb 2
\&    $z\->input_line_number()
\&    $z\->input_line_number(EXPR)
.Ve
.PP
This method always returns \f(CW\*(C`undef\*(C'\fR when compressing.
.SS "fileno"
.IX Subsection "fileno"
.Vb 2
\&    $z\->fileno()
\&    fileno($z)
.Ve
.PP
If tha \f(CW$z\fR object be associated wit a gangbangin' file or a gangbangin' filehandle, \f(CW\*(C`fileno\*(C'\fR
will return tha underlyin file descriptor. Shiiit, dis aint no joke. Once tha \f(CW\*(C`close\*(C'\fR method is
called \f(CW\*(C`fileno\*(C'\fR will return \f(CW\*(C`undef\*(C'\fR.
.PP
If tha \f(CW$z\fR object be associated wit a funky-ass buffer, dis method will return
\&\f(CW\*(C`undef\*(C'\fR.
.SS "close"
.IX Subsection "close"
.Vb 2
\&    $z\->close() ;
\&    close $z ;
.Ve
.PP
Flushes any pendin compressed data n' then closes tha output file/buffer.
.PP
For most versionz of Perl dis method is ghon be automatically invoked if
the IO::Compress::Zip object is destroyed (either explicitly or by the
variable wit tha reference ta tha object goin outta scope). The
exceptions is Perl versions 5.005 all up in 5.00504 n' 5.8.0. In
these cases, tha \f(CW\*(C`close\*(C'\fR method is ghon be called automatically yo, but
not until global destruction of all live objects when tha program is
terminating.
.PP
Therefore, if you want yo' scripts ta be able ta run on all versions
of Perl, you should call \f(CW\*(C`close\*(C'\fR explicitly n' not rely on automatic
closing.
.PP
Returns legit on success, otherwise 0.
.PP
If tha \f(CW\*(C`AutoClose\*(C'\fR option has been enabled when tha IO::Compress::Zip
object was pimped, n' tha object be associated wit a gangbangin' file, the
underlyin file will also be closed.
.SS "newStream([\s-1OPTS\s0])"
.IX Subsection "newStream([OPTS])"
Usage is
.PP
.Vb 1
\&    $z\->newStream( [OPTS] )
.Ve
.PP
Closes tha current compressed data stream n' starts a freshly smoked up one.
.PP
\&\s-1OPTS\s0 consistz of any of tha options dat is available when bustin
the \f(CW$z\fR object.
.PP
See tha \*(L"Constructor Options\*(R" section fo' mo' details.
.SS "deflateParams"
.IX Subsection "deflateParams"
Usage is
.PP
.Vb 1
\&    $z\->deflateParams
.Ve
.PP
\&\s-1TODO\s0
.SH "Importing"
.IX Header "Importing"
A number of symbolic constants is required by some methodz up in 
\&\f(CW\*(C`IO::Compress::Zip\*(C'\fR. None is imported by default.
.IP ":all" 5
.IX Item ":all"
Imports \f(CW\*(C`zip\*(C'\fR, \f(CW$ZipError\fR n' all symbolic
constants dat can be used by \f(CW\*(C`IO::Compress::Zip\*(C'\fR. Right back up in yo muthafuckin ass. Same as bustin this
.Sp
.Vb 1
\&    use IO::Compress::Zip qw(zip $ZipError :constants) ;
.Ve
.IP ":constants" 5
.IX Item ":constants"
Import all symbolic constants, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Same as bustin this
.Sp
.Vb 1
\&    use IO::Compress::Zip qw(:flush :level :strategy :zip_method) ;
.Ve
.IP ":flush" 5
.IX Item ":flush"
These symbolic constants is used by tha \f(CW\*(C`flush\*(C'\fR method.
.Sp
.Vb 6
\&    Z_NO_FLUSH
\&    Z_PARTIAL_FLUSH
\&    Z_SYNC_FLUSH
\&    Z_FULL_FLUSH
\&    Z_FINISH
\&    Z_BLOCK
.Ve
.IP ":level" 5
.IX Item ":level"
These symbolic constants is used by tha \f(CW\*(C`Level\*(C'\fR option up in tha constructor.
.Sp
.Vb 4
\&    Z_NO_COMPRESSION
\&    Z_BEST_SPEED
\&    Z_BEST_COMPRESSION
\&    Z_DEFAULT_COMPRESSION
.Ve
.IP ":strategy" 5
.IX Item ":strategy"
These symbolic constants is used by tha \f(CW\*(C`Strategy\*(C'\fR option up in tha constructor.
.Sp
.Vb 5
\&    Z_FILTERED
\&    Z_HUFFMAN_ONLY
\&    Z_RLE
\&    Z_FIXED
\&    Z_DEFAULT_STRATEGY
.Ve
.IP ":zip_method" 5
.IX Item ":zip_method"
These symbolic constants is used by tha \f(CW\*(C`Method\*(C'\fR option up in the
constructor.
.Sp
.Vb 3
\&    ZIP_CM_STORE
\&    ZIP_CM_DEFLATE
\&    ZIP_CM_BZIP2
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Apache::GZip Revisited"
.IX Subsection "Apache::GZip Revisited"
See IO::Compress::FAQ
.SS "Workin wit Net::FTP"
.IX Subsection "Workin wit Net::FTP"
See IO::Compress::FAQ
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Compress::Zlib, IO::Compress::Gzip, IO::Uncompress::Gunzip, IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate, IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress
.PP
IO::Compress::FAQ
.PP
File::GlobMapper, Archive::Zip,
Archive::Tar,
IO::Zlib
.PP
For \s-1RFC 1950, 1951\s0 n' 1952 peep 
\&\fIhttp://www.faqs.org/rfcs/rfc1950.html\fR,
\&\fIhttp://www.faqs.org/rfcs/rfc1951.html\fR and
\&\fIhttp://www.faqs.org/rfcs/rfc1952.html\fR
.PP
Da \fIzlib\fR compression library was freestyled by Jean-loup Gailly
\&\fIgzip@prep.ai.mit.edu\fR n' Mark Adla \fImadler@alumni.caltech.edu\fR.
.PP
Da primary joint fo' tha \fIzlib\fR compression library is
\&\fIhttp://www.zlib.org\fR.
.PP
Da primary joint fo' gzip is \fIhttp://www.gzip.org\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module was freestyled by Pizzle Marquess, \fIpmqs@cpan.org\fR.
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
See tha Chizzlez file.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2005\-2013 Pizzle Marquess fo' realz. All muthafuckin rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
