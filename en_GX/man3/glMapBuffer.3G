'\" t
.\"     Title: glMapBuffer
.\"    Author: opengl.org
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 08/03/2013
.\"    Manual: OpenGL Manual
.\"    Source: opengl.org
.\"  Language: Gangsta
.\"
.TH "GLMAPBUFFER" "3G" "08/03/2013" "opengl.org" "OpenGL Manual"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
glMapBuffer \- map a funky-ass buffer object\*(Aqs data store
.SH "C SPECIFICATION"
.HP \w'void\ *\ glMapBuffer('u
.BI "void * glMapBuffer(GLenum\ " "target" ", GLenum\ " "access" ");"
.SH "PARAMETERS"
.PP
\fItarget\fR
.RS 4
Specifies tha target buffer object bein mapped\&. Da symbolic constant must be
\fBGL_ARRAY_BUFFER\fR,
\fBGL_ATOMIC_COUNTER_BUFFER\fR,
\fBGL_COPY_READ_BUFFER\fR,
\fBGL_COPY_WRITE_BUFFER\fR,
\fBGL_DRAW_INDIRECT_BUFFER\fR,
\fBGL_DISPATCH_INDIRECT_BUFFER\fR,
\fBGL_ELEMENT_ARRAY_BUFFER\fR,
\fBGL_PIXEL_PACK_BUFFER\fR,
\fBGL_PIXEL_UNPACK_BUFFER\fR,
\fBGL_SHADER_STORAGE_BUFFER\fR,
\fBGL_TEXTURE_BUFFER\fR,
\fBGL_TRANSFORM_FEEDBACK_BUFFER\fR
or
\fBGL_UNIFORM_BUFFER\fR\&.
.RE
.PP
\fIaccess\fR
.RS 4
Specifies tha access policy, indicatin whether it is ghon be possible ta read from, write to, or both read from n' write ta tha buffer object\*(Aqs mapped data store\&. Da symbolic constant must be
\fBGL_READ_ONLY\fR,
\fBGL_WRITE_ONLY\fR, or
\fBGL_READ_WRITE\fR\&.
.RE
.SH "C SPECIFICATION"
.HP \w'GLboolean\ glUnmapBuffer('u
.BI "GLboolean glUnmapBuffer(GLenum\ " "target" ");"
.SH "PARAMETERS"
.PP
\fItarget\fR
.RS 4
Specifies tha target buffer object bein unmapped\&. Da symbolic constant must be
\fBGL_ARRAY_BUFFER\fR,
\fBGL_ATOMIC_COUNTER_BUFFER\fR,
\fBGL_COPY_READ_BUFFER\fR,
\fBGL_COPY_WRITE_BUFFER\fR,
\fBGL_DRAW_INDIRECT_BUFFER\fR,
\fBGL_DISPATCH_INDIRECT_BUFFER\fR,
\fBGL_ELEMENT_ARRAY_BUFFER\fR,
\fBGL_PIXEL_PACK_BUFFER\fR,
\fBGL_PIXEL_UNPACK_BUFFER\fR,
\fBGL_SHADER_STORAGE_BUFFER\fR,
\fBGL_TEXTURE_BUFFER\fR,
\fBGL_TRANSFORM_FEEDBACK_BUFFER\fR
or
\fBGL_UNIFORM_BUFFER\fR\&.
.RE
.SH "DESCRIPTION"
.PP
\fBglMapBuffer\fR
maps ta tha client\*(Aqs address space tha entire data store of tha buffer object currently bound to
\fItarget\fR\&. Da data can then be directly read and/or freestyled relatizzle ta tha returned pointer, dependin on tha specified
\fIaccess\fR
policy\&. If tha GL is unable ta map tha buffer object\*(Aqs data store,
\fBglMapBuffer\fR
generates a error n' returns
\fBNULL\fR\&. This may occur fo' system\-specific reasons, like fuckin low virtual memory availability\&. If no error occurs, tha returned pointa gonna git a alignment of at least
\fBGL_MIN_MAP_BUFFER_ALIGNMENT\fR
basic machine units\&. Da value of
\fBGL_MIN_MAP_BUFFER_ALIGNMENT\fR
can be retrieved by calling
\fBglGet\fR()
with
\fIpname\fR
set to
\fBGL_MIN_MAP_BUFFER_ALIGNMENT\fR
and must be a juice of two dat be at least 64\&.
.PP
If a mapped data store be accessed up in a way inconsistent wit tha specified
\fIaccess\fR
policy, no error is generated yo, but performizzle may be negatively impacted n' system errors, includin program termination, may result\&. Unlike the
\fIusage\fR
parameta of
\fBglBufferData\fR,
\fIaccess\fR
is not a hint, n' do up in fact constrain tha usage of tha mapped data store on some GL implementations\&. In order ta big up tha highest performizzle available, a funky-ass buffer object\*(Aqs data store should be used up in ways consistent wit both its specified
\fIusage\fR
and
\fIaccess\fR
parameters\&.
.PP
A mapped data store must be unmapped with
\fBglUnmapBuffer\fR
before its buffer object is used\&. Otherwise a error is ghon be generated by any GL command dat attempts ta dereference tha buffer object\*(Aqs data store\&. When a thugged-out data store is unmapped, tha pointa ta its data store becomes invalid\&.
\fBglUnmapBuffer\fR
returns
\fBGL_TRUE\fR
unless tha data store contents have become corrupt durin tha time tha data store was mapped\&. This can occur fo' system\-specific reasons dat affect tha availabilitizzle of graphics memory, like fuckin screen mode chizzles\&. In such thangs,
\fBGL_FALSE\fR
is returned n' tha data store contents is undefined\& fo' realz. An application must detect dis rare condizzle n' reinitialize tha data store\&.
.PP
A buffer object\*(Aqs mapped data store be automatically unmapped when tha buffer object is deleted or its data store is recreated with
\fBglBufferData\fR\&.
.SH "NOTES"
.PP
If a error is generated,
\fBglMapBuffer\fR
returns
\fBNULL\fR, and
\fBglUnmapBuffer\fR
returns
\fBGL_FALSE\fR\&.
.PP
Parameta joints passed ta GL commandz may not be sourced from tha returned pointer\&. No error is ghon be generated yo, but thangs up in dis biatch is ghon be undefined n' will likely vary across GL implementations\&.
.PP
Alignment of tha returned pointa is guaranteed only if tha version of tha GL version is 4\&.2 or pimped outer\& fo' realz. Also, the
\fBGL_ATOMIC_COUNTER_BUFFER\fR
target be accepted only if tha GL version is 4\&.2 or pimped outer\&.
.PP
The
\fBGL_DISPATCH_INDIRECT_BUFFER\fR
and
\fBGL_SHADER_STORAGE_BUFFER\fR
targets is available only if tha GL version is 4\&.3 or pimped outer\&.
.SH "ERRORS"
.PP
\fBGL_INVALID_ENUM\fR
is generated if
\fItarget\fR
is not one of tha accepted targets\&.
.PP
\fBGL_INVALID_ENUM\fR
is generated if
\fIaccess\fR
is not
\fBGL_READ_ONLY\fR,
\fBGL_WRITE_ONLY\fR, or
\fBGL_READ_WRITE\fR\&.
.PP
\fBGL_OUT_OF_MEMORY\fR
is generated when
\fBglMapBuffer\fR
is executed if tha GL is unable ta map tha buffer object\*(Aqs data store\&. This may occur fo' a variety of system\-specific reasons, like fuckin tha absence of sufficient remainin virtual memory\&.
.PP
\fBGL_INVALID_OPERATION\fR
is generated if tha reserved buffer object name 0 is bound to
\fItarget\fR\&.
.PP
\fBGL_INVALID_OPERATION\fR
is generated if
\fBglMapBuffer\fR
is executed fo' a funky-ass buffer object whose data store be already mapped\&.
.PP
\fBGL_INVALID_OPERATION\fR
is generated if
\fBglUnmapBuffer\fR
is executed fo' a funky-ass buffer object whose data store aint currently mapped\&.
.SH "ASSOCIATED GETS"
.PP
\fBglGetBufferPointerv\fR()
with argument
\fBGL_BUFFER_MAP_POINTER\fR
.PP
\fBglGetBufferParameter\fR()
with argument
\fBGL_BUFFER_MAPPED\fR,
\fBGL_BUFFER_ACCESS\fR, or
\fBGL_BUFFER_USAGE\fR
.SH "SEE ALSO"
.PP
\fBglBindBuffer\fR(),
\fBglBindBufferBase\fR(),
\fBglBindBufferRange\fR(),
\fBglBufferData\fR(),
\fBglBufferSubData\fR(),
\fBglDeleteBuffers\fR()
.SH "COPYRIGHT"
.PP
Copyright
\(co
2005 Addison\-Wesley\&. Copyright
\(co
2010\-2011 Khronos Group\&. This material may be distributed subject ta tha terms n' conditions set forth up in tha Open Publication License, v 1\&.0, 8 June 1999\&.
\m[blue]\fBhttp://opencontent\&.org/openpub/\fR\m[]\&.
.SH "AUTHORS"
.PP
\fBopengl\&.org\fR
