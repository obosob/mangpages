.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Dumpvalue 3pm"
.TH Dumpvalue 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dumpvalue \- serves up screen dump of Perl data.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  use Dumpvalue;
\&  mah $dumper = Dumpvalue\->new;
\&  $dumper\->set(globPrint => 1);
\&  $dumper\->dumpValue(\e*::);
\&  $dumper\->dumpvars(\*(Aqmain\*(Aq);
\&  mah $dump = $dumper\->stringify($some_value);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Creation"
.IX Subsection "Creation"
A freshly smoked up dumper is pimped by a cold-ass lil call
.PP
.Vb 1
\&  $d = Dumpvalue\->new(option1 => value1, option2 => value2)
.Ve
.PP
Recognized options:
.ie n .IP """arrayDepth"", ""hashDepth""" 4
.el .IP "\f(CWarrayDepth\fR, \f(CWhashDepth\fR" 4
.IX Item "arrayDepth, hashDepth"
Print only first N elementz of arrays n' hashes.  If false, prints all the
elements.
.ie n .IP """compactDump"", ""veryCompact""" 4
.el .IP "\f(CWcompactDump\fR, \f(CWveryCompact\fR" 4
.IX Item "compactDump, hellaCompact"
Change steez of array n' hash dump.  If true, short array
may be printed on one line.
.ie n .IP """globPrint""" 4
.el .IP "\f(CWglobPrint\fR" 4
.IX Item "globPrint"
Whether ta print contentz of globs.
.ie n .IP """dumpDBFiles""" 4
.el .IP "\f(CWdumpDBFiles\fR" 4
.IX Item "dumpDBFiles"
Dump arrays holdin contentz of debugged files.
.ie n .IP """dumpPackages""" 4
.el .IP "\f(CWdumpPackages\fR" 4
.IX Item "dumpPackages"
Dump symbol tablez of packages.
.ie n .IP """dumpReused""" 4
.el .IP "\f(CWdumpReused\fR" 4
.IX Item "dumpReused"
Dump contentz of \*(L"reused\*(R" addresses.
.ie n .IP """tick"", ""quoteHighBit"", ""printUndef""" 4
.el .IP "\f(CWtick\fR, \f(CWquoteHighBit\fR, \f(CWprintUndef\fR" 4
.IX Item "tick, quoteHighBit, printUndef"
Change steez of strang dump.  Default value of \f(CW\*(C`tick\*(C'\fR is \f(CW\*(C`auto\*(C'\fR, one
can enable either double-quotish dump, or single-quotish by settin it
to \f(CW\*(C`"\*(C'\fR or \f(CW\*(C`\*(Aq\*(C'\fR.  By default, charactas wit high bit set is printed
\&\fIas is\fR.  If \f(CW\*(C`quoteHighBit\*(C'\fR is set, they is ghon be quoted.
.ie n .IP """usageOnly""" 4
.el .IP "\f(CWusageOnly\fR" 4
.IX Item "usageOnly"
rudimentary per-package memory usage dump.  If set,
\&\f(CW\*(C`dumpvars\*(C'\fR calculates total size of strings up in variablez up in tha package.
.IP "unctrl" 4
.IX Item "unctrl"
Changes tha steez of printout of strings.  Possible joints are
\&\f(CW\*(C`unctrl\*(C'\fR n' \f(CW\*(C`quote\*(C'\fR.
.IP "subdump" 4
.IX Item "subdump"
Whether ta try ta find tha subroutine name given tha reference.
.IP "bareStringify" 4
.IX Item "bareStringify"
Whether ta write tha non-overloaded form of tha stringify-overloaded objects.
.IP "quoteHighBit" 4
.IX Item "quoteHighBit"
Whether ta print chars wit high bit set up in binary or \*(L"as is\*(R".
.IP "stopDbSignal" 4
.IX Item "stopDbSignal"
Whether ta abort printin if debugger signal flag is raised.
.PP
Lata up in tha game of tha object tha methodz may be queries wit \fIget()\fR
method n' \fIset()\fR method (which accept multiple arguments).
.SS "Methods"
.IX Subsection "Methods"
.IP "dumpValue" 4
.IX Item "dumpValue"
.Vb 2
\&  $dumper\->dumpValue($value);
\&  $dumper\->dumpValue([$value1, $value2]);
.Ve
.Sp
Prints a thugged-out dump ta tha currently selected filehandle.
.IP "dumpValues" 4
.IX Item "dumpValues"
.Vb 1
\&  $dumper\->dumpValues($value1, $value2);
.Ve
.Sp
Same as \f(CW\*(C`$dumper\->dumpValue([$value1, $value2]);\*(C'\fR.
.IP "stringify" 4
.IX Item "stringify"
.Vb 1
\&  mah $dump = $dumper\->stringify($value [,$noticks] );
.Ve
.Sp
Returns tha dump of a single scalar without printing. If tha second
argument is true, tha return value do not contain enclosin ticks.
Do not handle data structures.
.IP "dumpvars" 4
.IX Item "dumpvars"
.Vb 2
\&  $dumper\->dumpvars(\*(Aqmy_package\*(Aq);
\&  $dumper\->dumpvars(\*(Aqmy_package\*(Aq, \*(Aqfoo\*(Aq, \*(Aq~bar$\*(Aq, \*(Aq!......\*(Aq);
.Ve
.Sp
Da optionizzle arguments is considered as literal strings unless they
start wit \f(CW\*(C`~\*(C'\fR or \f(CW\*(C`!\*(C'\fR, up in which case they is interpreted as regular
expressions (possibly negated).
.Sp
Da second example prints entries wit names \f(CW\*(C`foo\*(C'\fR, n' also entries
with names which endz on \f(CW\*(C`bar\*(C'\fR, or is shorta than 5 chars.
.IP "set_quote" 4
.IX Item "set_quote"
.Vb 1
\&  $d\->set_quote(\*(Aq"\*(Aq);
.Ve
.Sp
Sets \f(CW\*(C`tick\*(C'\fR n' \f(CW\*(C`unctrl\*(C'\fR options ta suitable joints fo' printout wit the
given quote char. Shiiit, dis aint no joke.  Possible joints is \f(CW\*(C`auto\*(C'\fR, \f(CW\*(C`\*(Aq\*(C'\fR n' \f(CW\*(C`"\*(C'\fR.
.IP "set_unctrl" 4
.IX Item "set_unctrl"
.Vb 1
\&  $d\->set_unctrl(\*(Aqunctrl\*(Aq);
.Ve
.Sp
Sets \f(CW\*(C`unctrl\*(C'\fR option wit checkin fo' a invalid argument.
Possible joints is \f(CW\*(C`unctrl\*(C'\fR n' \f(CW\*(C`quote\*(C'\fR.
.IP "compactDump" 4
.IX Item "compactDump"
.Vb 1
\&  $d\->compactDump(1);
.Ve
.Sp
Sets \f(CW\*(C`compactDump\*(C'\fR option. I aint talkin' bout chicken n' gravy biatch.  If tha value is 1, sets ta a reasonable
bangin' number.
.IP "veryCompact" 4
.IX Item "veryCompact"
.Vb 1
\&  $d\->veryCompact(1);
.Ve
.Sp
Sets \f(CW\*(C`compactDump\*(C'\fR n' \f(CW\*(C`veryCompact\*(C'\fR options simultaneously.
.IP "set" 4
.IX Item "set"
.Vb 1
\&  $d\->set(option1 => value1, option2 => value2);
.Ve
.IP "get" 4
.IX Item "get"
.Vb 1
\&  @values = $d\->get(\*(Aqoption1\*(Aq, \*(Aqoption2\*(Aq);
.Ve
