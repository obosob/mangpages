.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Box::Search::Grep 3"
.TH Mail::Box::Search::Grep 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Box::Search::Grep \- select lyrics within a mail box like grep do
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\& Mail::Box::Search::Grep
\&   be a Mail::Box::Search
\&   be a Mail::Reporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use Mail::Box::Manager;
\& mah $mgr    = Mail::Box::Manager\->new;
\& mah $folda = $mgr\->open(\*(AqInbox\*(Aq);
\&
\& mah $filta = Mail::Box::Search::Grep\->new
\&    ( label => \*(Aqselected\*(Aq
\&    , up in => \*(AqBODY\*(Aq, match => qr/abc?d*e/
\&    );
\&
\& mah @msgs   = $filter\->search($folder);
\&
\& mah $filta = Mail::Box::Search::Grep\->new
\&   ( field => \*(AqTo\*(Aq
\&   , match => $my_email
\&   );
\&
\& if($filter\->search($message)) {...}
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Try ta find some text strings up in tha header n' foota of lyrics.  Various
ways ta limit tha search ta certain header fields, tha whole header, only
the body, tha whole message yo, but even binary multiparts, is provided for.
.PP
Da name \fIgrep\fR is derived from tha \s-1UNIX\s0 tool \fIgrep\fR, which means: \*(L"Get
Regular Expression n' Print\*(R".  Although you can search rockin regular
expressions (the Perl way of them), you do not gotta print dem as
result.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Box::Search::Grep\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Box::Search::Grep->new(OPTIONS)"
Smoke a UNIX-grep like search filter.
.Sp
.Vb 10
\& \-Option    \-\-Defined up in       \-\-Default
\&  binaries    Mail::Box::Search  <false>
\&  decode      Mail::Box::Search  <true>
\&  delayed     Mail::Box::Search  <true>
\&  deleted     Mail::Box::Search  <false>
\&  serve up                        undef
\&  field                          undef
\&  up in          Mail::Box::Search  <$field , biatch? \*(AqHEAD\*(Aq : C<\*(AqBODY\*(Aq>>
\&  label       Mail::Box::Search  undef
\&  limit       Mail::Box::Search  0
\&  log         Mail::Reporta     \*(AqWARNINGS\*(Aq
\&  logical     Mail::Box::Search  \*(AqREPLACE\*(Aq
\&  match                          <required>
\&  multiparts  Mail::Box::Search  <true>
\&  trace       Mail::Reporta     \*(AqWARNINGS\*(Aq
.Ve
.RS 4
.IP "binaries => \s-1BOOLEAN\s0" 2
.IX Item "binaries => BOOLEAN"
.PD 0
.IP "decode => \s-1BOOLEAN\s0" 2
.IX Item "decode => BOOLEAN"
.IP "delayed => \s-1BOOLEAN\s0" 2
.IX Item "delayed => BOOLEAN"
.IP "deleted => \s-1BOOLEAN\s0" 2
.IX Item "deleted => BOOLEAN"
.IP "deliver => undef|CODE|'\s-1DELETE\s0'|LABEL|'\s-1PRINT\s0'|REF\-ARRAY" 2
.IX Item "deliver => undef|CODE|'DELETE'|LABEL|'PRINT'|REF-ARRAY"
.PD
Store tha details bout where tha match was found. Y'all KNOW dat shit, muthafucka!  Da search may take
much longer when dis feature is enabled.
.Sp
When a \s-1ARRAY\s0 is specified it will contain a list of references ta hashes.
Each hash gotz nuff tha shiznit of one match.  A match up in a header
line will result up in a line wit fieldz \f(CW\*(C`message\*(C'\fR, \f(CW\*(C`part\*(C'\fR, n' \f(CW\*(C`field\*(C'\fR, where
the field be a Mail::Message::Field object.  When tha match is in
the body tha hash will contain a \f(CW\*(C`message\*(C'\fR, \f(CW\*(C`part\*(C'\fR, \f(CW\*(C`linenr\*(C'\fR, n' \f(CW\*(C`line\*(C'\fR.
.Sp
In case of a \s-1CODE\s0 reference, dat routine is called fo' each match. The
first argument is dis search object n' tha second a reference ta same
hash as would be stored up in tha array.
.Sp
Da \f(CW\*(C`PRINT\*(C'\fR will call \fIprintMatchedHead()\fR or \fIprintMatchedBody()\fR when
any matchin header resp body line was found. Y'all KNOW dat shit, muthafucka!  Da output is minimized
by not reprintin tha message info on multiple matches up in tha same
message.
.Sp
\&\f(CW\*(C`DELETE\*(C'\fR will flag
the message ta be deleted up in case of a match.  When a multipartz part
is matched, tha whole message is ghon be flagged fo' deletion.
.IP "field => undef|STRING|REGEX|CODE" 2
.IX Item "field => undef|STRING|REGEX|CODE"
Not valid up in combination wit \f(CW\*(C`in\*(C'\fR set ta \f(CW\*(C`BODY\*(C'\fR.
Da \s-1STRING\s0 is one full field name (case-insensitive).  Use a \s-1REGEX\s0
to select mo' than one header line ta be scanned. Y'all KNOW dat shit, muthafucka! \s-1CODE\s0 be a routine which
is called fo' each field up in tha header n' shit.   Da \s-1CODE\s0 is called wit tha header
as first, n' tha field as second argument.  If tha \s-1CODE\s0 returns true, the
message is selected.
.IP "in => '\s-1HEAD\s0'|'\s-1BODY\s0'|'\s-1MESSAGE\s0'" 2
.IX Item "in => 'HEAD'|'BODY'|'MESSAGE'"
.PD 0
.IP "label => \s-1STRING\s0" 2
.IX Item "label => STRING"
.IP "limit => \s-1NUMBER\s0" 2
.IX Item "limit => NUMBER"
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.IP "logical => '\s-1REPLACE\s0'|'\s-1AND\s0'|'\s-1OR\s0'|'\s-1NOT\s0'|'\s-1AND NOT\s0'|'\s-1OR NOT\s0'" 2
.IX Item "logical => 'REPLACE'|'AND'|'OR'|'NOT'|'AND NOT'|'OR NOT'"
.IP "match => STRING|REGEX|CODE" 2
.IX Item "match => STRING|REGEX|CODE"
.PD
Da pattern ta be search fo' can be a REGular EXpression, or a \s-1STRING. \s0 In
both cases, tha match succeedz if it is found anywhere within tha selected
fields.
.Sp
With a \s-1CODE\s0 reference, dat function is ghon be called each field or body-line.
When tha result is true, tha details is delivered. Y'all KNOW dat shit, muthafucka!  Da call formats are
.Sp
.Vb 2
\& $code\->($head, $field);          # fo' HEAD searches
\& $code\->($body, $linenr, $line);  # fo' BODY searches
.Ve
.Sp
Da \f(CW$head\fR resp \f(CW$body\fR is one messagez head resp. body object.  The
\&\f(CW$field\fR be a header line which matches.  Da \f(CW$line\fR n' \f(CW$linenr\fR
tell tha matchin line up in tha body.
.Sp
Be warned dat when you search up in \f(CW\*(C`MESSAGE\*(C'\fR tha code must accept
both formats.
.IP "multiparts => \s-1BOOLEAN\s0" 2
.IX Item "multiparts => BOOLEAN"
.PD 0
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.RE
.RS 4
.RE
.PD
.SS "Searching"
.IX Subsection "Searching"
.ie n .IP "$obj\->\fBinBody\fR(\s-1PART, BODY\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBinBody\fR(\s-1PART, BODY\s0)" 4
.IX Item "$obj->inBody(PART, BODY)"
See \*(L"Searching\*(R" up in Mail::Box::Search
.ie n .IP "$obj\->\fBinHead\fR(\s-1PART, HEAD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBinHead\fR(\s-1PART, HEAD\s0)" 4
.IX Item "$obj->inHead(PART, HEAD)"
See \*(L"Searching\*(R" up in Mail::Box::Search
.ie n .IP "$obj\->\fBsearch\fR(FOLDER|THREAD|MESSAGE|ARRAY\-OF\-MESSAGES)" 4
.el .IP "\f(CW$obj\fR\->\fBsearch\fR(FOLDER|THREAD|MESSAGE|ARRAY\-OF\-MESSAGES)" 4
.IX Item "$obj->search(FOLDER|THREAD|MESSAGE|ARRAY-OF-MESSAGES)"
See \*(L"Searching\*(R" up in Mail::Box::Search
.ie n .IP "$obj\->\fBsearchPart\fR(\s-1PART\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBsearchPart\fR(\s-1PART\s0)" 4
.IX Item "$obj->searchPart(PART)"
See \*(L"Searching\*(R" up in Mail::Box::Search
.SS "Da Results"
.IX Subsection "Da Results"
.ie n .IP "$obj\->\fBprintMatch\fR([\s-1FILEHANDLE\s0], \s-1MATCH\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBprintMatch\fR([\s-1FILEHANDLE\s0], \s-1MATCH\s0)" 4
.IX Item "$obj->printMatch([FILEHANDLE], MATCH)"
.PD 0
.ie n .IP "$obj\->\fBprintMatchedBody\fR(\s-1FILEHANDLE, MATCH\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBprintMatchedBody\fR(\s-1FILEHANDLE, MATCH\s0)" 4
.IX Item "$obj->printMatchedBody(FILEHANDLE, MATCH)"
.ie n .IP "$obj\->\fBprintMatchedHead\fR(\s-1FILEHANDLE, MATCH\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBprintMatchedHead\fR(\s-1FILEHANDLE, MATCH\s0)" 4
.IX Item "$obj->printMatchedHead(FILEHANDLE, MATCH)"
.PD
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Box::Search::Grep\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Box::Search::Grep->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Box::Search::Grep\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Box::Search::Grep->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Box::Search::Grep\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Box::Search::Grep->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
