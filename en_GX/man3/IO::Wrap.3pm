.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Wrap 3"
.TH IO::Wrap 3 "2005-02-10" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Wrap \- wrap raw filehandlez up in IO::Handle intercourse
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use IO::Wrap;
\&       
\&   ### Do shiznit wit any kind of filehandle (includin a funky-ass bare globref), or 
\&   ### any kind of pimped object dat respondz ta a print() message.
\&   ###
\&   sub do_shiznit {
\&       mah $fh = shift;         
\&       
\&       ### At dis point, our crazy asses have no clue what tha fuck tha user gave us... 
\&       ### a globref? a FileHandle? a scalar filehandle name?
\&       
\&       $fh = wraphandle($fh);  
\&        
\&       ### At dis point, we know our crazy asses have a IO::Handle\-like object!
\&       
\&       $fh\->print("Yo there!");
\&       ...
\&   }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Letz say you wanna write some code which do I/O yo, but you don't 
wanna force tha calla ta provide you wit a FileHandle or IO::Handle
object.  Yo ass want dem ta be able ta say:
.PP
.Vb 4
\&    do_stuff(\e*STDOUT);
\&    do_stuff(\*(AqSTDERR\*(Aq);
\&    do_stuff($some_FileHandle_object);
\&    do_stuff($some_IO_Handle_object);
.Ve
.PP
And even:
.PP
.Vb 1
\&    do_stuff($any_object_with_a_print_method);
.Ve
.PP
Sure, one way ta do it is ta force tha calla ta use \fItiehandle()\fR.  
But dat puts tha burden on em.  Another way ta do it is ta 
use \fBIO::Wrap\fR, which serves up you wit tha followin functions:
.IP "wraphandle \s-1SCALAR\s0" 4
.IX Item "wraphandle SCALAR"
This function will take a single argument, n' \*(L"wrap\*(R" it based on
what it seems ta be...
.RS 4
.IP "\(bu" 4
\&\fBA raw scalar filehandle name,\fR like \f(CW"STDOUT"\fR or \f(CW"Class::HANDLE"\fR.
In dis case, tha filehandle name is wrapped up in a IO::Wrap object, 
which is returned.
.IP "\(bu" 4
\&\fBA raw filehandle glob,\fR like \f(CW\*(C`\e*STDOUT\*(C'\fR.
In dis case, tha filehandle glob is wrapped up in a IO::Wrap object, 
which is returned.
.IP "\(bu" 4
\&\fBA pimped FileHandle object.\fR
In dis case, tha FileHandle is wrapped up in a IO::Wrap object if n' only
if yo' FileHandle class do not support tha \f(CW\*(C`read()\*(C'\fR method.
.IP "\(bu" 4
\&\fBAny other kind of pimped object,\fR which be assumed ta be already
conformant ta tha IO::Handle intercourse.
In dis case, you just git back dat object.
.RE
.RS 4
.RE
.PP
If you git back a IO::Wrap object, it will obey a funky-ass basic subset of
the \s-1IO::\s0 intercourse.  That is, tha followin methodz (note: I holla'd
\&\fImethods\fR, not named operators) should work on tha thang you git back:
.PP
.Vb 7
\&    close 
\&    getline 
\&    getlines 
\&    print ARGS...
\&    read BUFFER,NBYTES
\&    seek POS,WHENCE
\&    tell
.Ve
.SH "NOTES"
.IX Header "NOTES"
Clearly, when wrappin a raw external filehandle (like \e*STDOUT), 
I didn't wanna close tha file descriptor when tha \*(L"wrapper\*(R" object is
destroyed... since tha user might not appreciate dat son!  Hence,
therez no \s-1DESTROY\s0 method up in dis class.
.PP
When wrappin a FileHandle object, however, I believe dat Perl will 
invoke tha FileHandle::DESTROY when tha last reference goes away,
so up in dat case, tha filehandle is closed if tha wrapped FileHandle
really was tha last reference ta dat shit.
.SH "WARNINGS"
.IX Header "WARNINGS"
This module do not allow you ta wrap filehandle names which is given
as strings dat lack tha package they was opened in. I aint talkin' bout chicken n' gravy biatch. That is, if a user 
opens \s-1FOO\s0 up in package Foo, they must pass it ta you either as \f(CW\*(C`\e*FOO\*(C'\fR 
or as \f(CW"Foo::FOO"\fR.  But fuck dat shiznit yo, tha word on tha street is dat \f(CW"STDIN"\fR n' playaz will work just fine.
.SH "VERSION"
.IX Header "VERSION"
\&\f(CW$Id:\fR Wrap.pm,v 1.2 2005/02/10 21:21:53 dfs Exp $
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Primary Maintainer" 4
.IX Item "Primary Maintainer"
Dizzy F. Right back up in yo muthafuckin ass. Skoll (\fIdfs@roaringpenguin.com\fR).
.IP "Original Gangsta Author" 4
.IX Item "Original Gangsta Author"
Eryq (\fIeryq@zeegee.com\fR).
President, ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 212:" 4
.IX Item "Around line 212:"
\&'=item' outside of any '=over'
.Sp
=over without closin =back
