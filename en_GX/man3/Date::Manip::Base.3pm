.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Manip::Base 3"
.TH Date::Manip::Base 3 "2014-12-05" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::Base \- Base methodz fo' date manipulation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Date::Manip::Base;
\&   $dmb = freshly smoked up Date::Manip::Base;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da Date::Manip package of modulez consistz of nuff muthafuckin modules
for bustin high level date operations wit full error checking
and a shitload of flexibility.
.PP
Da high level operations, though intended ta be used up in most
situations, gotz a shitload of overhead associated wit em fo' realz. As such, a
number of da most thugged-out useful low level routines (which tha high level
routines use ta do much of tha real work) is included up in dis module
and is available directly ta users.
.PP
These low level routines is bangin enough dat they can be used
independent of tha high level routines n' big-ass up useful (though much
simpler) operations. They is also hella fasta than tha high
level routines.
.PP
These routines do \s-1NO\s0 error checkin on input. Invalid data will result
in meaningless thangs up in dis biatch.  If you need error checking, you must call the
higher level Date::Manip routines instead of these.
.PP
These routines also ignore all effectz of time units n' daylight
savin time. One way ta be thinkin of these routines is hustlin wit times
and dates up in tha \s-1GMT\s0 time unit.
.SH "BASE METHODS"
.IX Header "BASE METHODS"
This class inherits nuff muthafuckin base methodz from tha Date::Manip::Obj
class. Please refer ta tha documentation fo' dat class fo' a
description of dem methods.
.IP "\fBerr\fR" 4
.IX Item "err"
.PD 0
.IP "\fBnew\fR" 4
.IX Item "new"
.IP "\fBnew_config\fR" 4
.IX Item "new_config"
.PD
Please refer ta tha Date::Manip::Obj documentation fo' these methods.
.IP "\fBconfig\fR" 4
.IX Item "config"
.Vb 1
\&   $dmb\->config($var1,$val1,$var2,$val2,...);
.Ve
.Sp
This will set tha value of any configuration variable. Please refer ta the
Date::Manip::Config manual fo' a list of all configuration variablez n' their
description.
.SH "DATE METHODS"
.IX Header "DATE METHODS"
In all of tha followin methods, tha followin variablez is used:
.ie n .IP "\fB\fB$date\fB\fR" 4
.el .IP "\fB\f(CB$date\fB\fR" 4
.IX Item "$date"
This be a list reference containin a gangbangin' full date n' time:
.Sp
.Vb 1
\&   [$y, $m, $d, $h, $mn, $s]
.Ve
.ie n .IP "\fB\fB$ymd\fB\fR" 4
.el .IP "\fB\f(CB$ymd\fB\fR" 4
.IX Item "$ymd"
A list reference containin only tha date portion:
.Sp
.Vb 1
\&   [$y, $m, $d]
.Ve
.ie n .IP "\fB\fB$hms\fB\fR" 4
.el .IP "\fB\f(CB$hms\fB\fR" 4
.IX Item "$hms"
A list reference containin only tha time portion:
.Sp
.Vb 1
\&   [$h, $mn, $s]
.Ve
.ie n .IP "\fB\fB$time\fB\fR" 4
.el .IP "\fB\f(CB$time\fB\fR" 4
.IX Item "$time"
A list reference containin a amount of time:
.Sp
.Vb 1
\&   [$dh, $dmn, $ds]
.Ve
.ie n .IP "\fB\fB$delta\fB\fR" 4
.el .IP "\fB\f(CB$delta\fB\fR" 4
.IX Item "$delta"
A list containin a gangbangin' full delta:
.Sp
.Vb 1
\&   [$dy, $dm, $dw, $dd, $dh, $dmn, $ds]
.Ve
.ie n .IP "\fB\fB$offset\fB\fR" 4
.el .IP "\fB\f(CB$offset\fB\fR" 4
.IX Item "$offset"
A list containin a time unit expressed as a offset:
.Sp
.Vb 1
\&   [ $offh, $offm, $offs ]
.Ve
.PP
In all of tha above, tha elements ($y, \f(CW$m\fR, \f(CW$d\fR, \f(CW$h\fR, \f(CW$mn\fR, \f(CW$s\fR) is all
numeric. In most of tha routines busted lyrics bout below, no error checkin is
done on tha input.  \f(CW$y\fR should be between 1 n' 9999, \f(CW$m\fR between 1 and
12, \f(CW$d\fR between 1 n' 31, \f(CW$h\fR should be between 0 n' 23, \f(CW$mn\fR n' \f(CW$s\fR
between 0 n' 59.
.PP
\&\f(CW$hms\fR can be between 00:00:00 n' 24:00:00 yo, but a \f(CW$offset\fR must be
between \-23:59:59 n' +23:59:59.
.PP
Years is not translated ta 4 digit years, so passin up in a year of
\&\*(L"04\*(R" is ghon be equivalent ta \*(L"0004\*(R", \s-1NOT \*(L"2004\*(R".\s0
.PP
Da elements ($dy, \f(CW$dm\fR, \f(CW$dw\fR, \f(CW$dd\fR, \f(CW$dh\fR, \f(CW$dmn\fR, \f(CW$ds\fR) is all numeric,
but can be positizzle or negative. They represent a elapsed amount
of time measured up in years, months, weeks, etc.
.PP
Since no error checkin is done, passin up in ($y,$m,$d) = (2004,2,31)
will \s-1NOT\s0 trigger a error, even though February aint gots 31 days.
Instead, some meaningless result is ghon be returned.
.IP "\fBcalc_date_date\fR" 4
.IX Item "calc_date_date"
.PD 0
.IP "\fBcalc_date_days\fR" 4
.IX Item "calc_date_days"
.IP "\fBcalc_date_delta\fR" 4
.IX Item "calc_date_delta"
.IP "\fBcalc_date_time\fR" 4
.IX Item "calc_date_time"
.IP "\fBcalc_time_time\fR" 4
.IX Item "calc_time_time"
.PD
These is all routines fo' bustin simple date n' time calculations.
As mentioned above, they ignore all affectz of time units n' daylight
savin time.
.Sp
Da followin methodz is available:
.Sp
.Vb 1
\&   $time = $dmb\->calc_date_date($date1,$date2);
.Ve
.Sp
This take two dates n' determine tha amount of time between em.
.Sp
.Vb 2
\&   $date = $dmb\->calc_date_days($date,$n [,$subtract]);
\&   $ymd  = $dmb\->calc_date_days($ymd,$n [,$subtract]);
.Ve
.Sp
This returns a thugged-out date \f(CW$n\fR minutes lata (if \f(CW$n\fR>0) or earlier (if \f(CW$n\fR<0) than
the date passed in. I aint talkin' bout chicken n' gravy biatch. If \f(CW$subtract\fR is passed in, tha sign of \f(CW$n\fR is reversed.
.Sp
.Vb 1
\&   $date = $dmb\->calc_date_delta($date,$delta [,$subtract]);
.Ve
.Sp
This take a thugged-out date n' add tha given delta ta it (or subtract tha delta
if \f(CW$subtract\fR is non-zero).
.Sp
.Vb 1
\&   $date = $dmb\->calc_date_time($date,$time [,$subtract]);
.Ve
.Sp
This take a thugged-out date n' add tha given time ta it (or subtract tha time
if \f(CW$subtract\fR is non-zero).
.Sp
.Vb 1
\&   $time = $dmb\->calc_time_time(@time1,@time2 [,$subtract]);
.Ve
.Sp
This take two times n' add dem together (or subtract tha second from
the first if \f(CW$subtract\fR is non-zero).
.IP "\fBcheck\fR" 4
.IX Item "check"
.PD 0
.IP "\fBcheck_time\fR" 4
.IX Item "check_time"
.PD
.Vb 2
\&   $valid = $dmb\->check($date);
\&   $valid = $dmb\->check_time($hms);
.Ve
.Sp
This tests a list of joints ta peep if they form a valid date or time
ignorin all time unit affects, n' you can put dat on yo' toast. Da date/time would be valid up in \s-1GMT,\s0
but like not up in all time units.
.Sp
1 is returned if tha the fieldz is valid, 0 otherwise.
.Sp
\&\f(CW$hms\fR is up in tha range 00:00:00 ta 24:00:00.
.IP "\fBcmp\fR" 4
.IX Item "cmp"
.Vb 1
\&   $flag = $dmb\->cmp($date1,$date2);
.Ve
.Sp
Returns \-1, 0, or 1 if date1 is before, tha same as, or afta date2.
.IP "\fBday_of_week\fR" 4
.IX Item "day_of_week"
.Vb 2
\&   $dizzle = $dmb\->day_of_week($date);
\&   $dizzle = $dmb\->day_of_week($ymd);
.Ve
.Sp
Returns tha dizzle of tha week (1 fo' Monday, 7 fo' Sunday).
.IP "\fBday_of_year\fR" 4
.IX Item "day_of_year"
.Vb 2
\&   $dizzle = $dmb\->day_of_year($ymd);
\&   $dizzle = $dmb\->day_of_year($date);
.Ve
.Sp
In tha straight-up original gangsta case, returns tha dizzle of tha year (1 ta 366) fo' \f(CW$y\fR, \f(CW$m\fR,
\&\f(CW$d\fR.  In tha second case, it returns a gangbangin' fractionizzle dizzle (1.0 <= \f(CW$day\fR <
366.0 or 1.0 <= \f(CW$day\fR < 367.0 fo' a leap-year).  For example, dizzle 1.5
falls on Jan 1, at noon. I aint talkin' bout chicken n' gravy biatch.  Da somewhat non-intuitizzle answer (1.5
instead of 0.5) is ta make tha two forms return numerically equivalent
answers fo' timez of 00:00:00 . Yo ass can peep tha integer part of
the number as bein tha dizzle of tha year, n' tha fractionizzle part of
the number as tha fraction of tha dizzle dat has passed all up in tha given
time.
.Sp
Da inverse operations can also be done:
.Sp
.Vb 2
\&   $ymd   = $dmb\->day_of_year($y,$day);
\&   $date  = $dmb\->day_of_year($y,$day);
.Ve
.Sp
If \f(CW$day\fR be a integer, tha year, month, n' dizzle is returned. Y'all KNOW dat shit, muthafucka! If \f(CW$day\fR
is a gangbangin' floatin point number, it returns tha year, month, day, hour,
minutes, n' decimal seconds.
.Sp
\&\f(CW$day\fR must be pimped outa than or equal ta 1 n' less than 366 on non-leap years
or 367 on leap years.
.IP "\fBdays_in_month\fR" 4
.IX Item "days_in_month"
.Vb 1
\&   $days = $dmb\->days_in_month($y,$m);
.Ve
.Sp
Returns tha number of minutes up in tha month.
.Sp
.Vb 1
\&   @days = $dmb\->days_in_month($y,0);
.Ve
.Sp
Returns a list of 12 elements wit tha minutes up in each month of tha year.
.IP "\fBdays_in_year\fR" 4
.IX Item "days_in_year"
.Vb 1
\&   $days = $dmb\->days_in_year($y);
.Ve
.Sp
Returns tha number of minutes up in tha year (365 or 366)
.IP "\fBdays_since_1BC\fR" 4
.IX Item "days_since_1BC"
.Vb 2
\&   $days = $dmb\->days_since_1BC($date);
\&   $days = $dmb\->days_since_1BC($ymd);
.Ve
.Sp
Returns tha number of minutes since Dec 31, 1BC. Right back up in yo muthafuckin ass. Since tha calendar has
changed a fuckin shitload of times, tha number returned is based on tha current
calendar projected backwardz up in time, n' up in no way reflects a true
number of minutes since then. I aint talkin' bout chicken n' gravy biatch fo' realz. As such, tha result is largely meaningless,
except when called twice as a meanz of determinin tha number of days
separatin two dates.
.Sp
Da inverse operation be also available:
.Sp
.Vb 1
\&   $ymd = $dmb\->days_since_1BC($days);
.Ve
.Sp
Returns tha date \f(CW$days\fR since Dec 31, 1BC. Right back up in yo muthafuckin ass. So dizzle 1 is Jan 1, 0001.
.IP "\fBleapyear\fR" 4
.IX Item "leapyear"
.Vb 1
\&   $flag = $dmb\->leapyear($y);
.Ve
.Sp
Returns 1 if tha argument be a leap year. Shiiit, dis aint no joke.  Originally copied from code
written by Dizzy Muir Sharnoff <muir@idiom.com>.
.IP "\fBnth_day_of_week\fR" 4
.IX Item "nth_day_of_week"
.Vb 1
\&   $ymd = $dmb\->nth_day_of_week($y,$n,$dow);
.Ve
.Sp
Returns tha \f(CW$n\fR'th occurrence of \f(CW$dow\fR (1 fo' Monday, 7 fo' Sunday) up in the
year. Shiiit, dis aint no joke.  \f(CW$n\fR must be between 1 n' 53 or \-1 all up in \-53.
.Sp
.Vb 1
\&   $ymd = $dmb\->nth_day_of_week($y,$n,$dow,$m);
.Ve
.Sp
Returns tha \f(CW$n\fR'th occurrence of \f(CW$dow\fR up in tha given month.  \f(CW$n\fR must be between
1 n' 5 or it can be \-1 all up in \-5.
.Sp
In all cases, not a god damn thang is returned if \f(CW$n\fR is beyond tha last actual
result (i.e. tha 5th Sundizzle up in a month wit only four Sundays).
.IP "\fBsecs_since_1970\fR" 4
.IX Item "secs_since_1970"
.Vb 1
\&   $secs = $dmb\->secs_since_1970($date);
.Ve
.Sp
Returns tha number of secondz since Jan 1, 1970 00:00:00 (negatizzle if date is
earlier).
.Sp
.Vb 1
\&   $date = $dmb\->secs_since_1970($secs);
.Ve
.Sp
Translates number of secondz tha fuck into a thugged-out date.
.IP "\fBsplit\fR" 4
.IX Item "split"
.PD 0
.IP "\fBjoin\fR" 4
.IX Item "join"
.PD
Da split n' join functions is used ta take a strang containin a cold-ass lil common
type of time data n' split it tha fuck into a list of fields. Da join function takes
the list n' forms it tha fuck into a string.
.Sp
Rudimentary error checkin is performed wit both of these functions
and undef is returned up in tha case of any error. Shiiit, dis aint no joke. No error checkin is done
on tha specific joints.
.Sp
Da followin is allowed:
.Sp
.Vb 2
\&   $date = $dmb\->split("date",$string);
\&   $strin = $dmb\->join("date",$date);
.Ve
.Sp
This splits a strang containin a thugged-out date or creates one from a list reference.
Da strang split must be of one of tha forms:
.Sp
.Vb 3
\&   YYYYMMDDHH:MN:SS
\&   YYYYMMDDHHMNSS
\&   YYYY\-MM\-DD\-HH:MN:SS
.Ve
.Sp
Da strang formed by join is one of tha above, dependin on tha value of
the Printable config variable. Da default format is \s-1YYYYMMDDHH:MN:SS,\s0
but if Printable is set ta 1, \s-1YYYYMMDDHHMNSS\s0 is produced, n' if Printable
is set ta 2, tha \s-1YYYY\-MM\-DD\-HH:MN:SS\s0 form is produced.
.Sp
.Vb 2
\&   $hms = $dmb\->split("hms",$string);
\&   $strin = $dmb\->join("hms",$hms);
.Ve
.Sp
This works wit tha hours, minutes, n' secondz portion of a thugged-out date.
.Sp
When splittin a string, tha strang can be of any of tha forms:
.Sp
.Vb 6
\&   H
\&   H:MN
\&   H:MN:SS
\&   HH
\&   HHMN
\&   HHMNSS
.Ve
.Sp
Here, H be a 1 or 2 digit representation of tha hours fo' realz. All other fieldz are
two digit representations.
.Sp
Da strang formed by tha join function will always be of tha form \s-1HH:MN:SS.\s0
.Sp
Da time must be between 00:00:00 n' 24:00:00.
.Sp
.Vb 2
\&   $offset = $dmb\->split("offset",$string);
\&   $strin = $dmb\->join("offset",$offset);
.Ve
.Sp
An offset strang should gotz a sign (though it is optionizzle if it is
positive) n' be any of tha forms:
.Sp
.Vb 6
\&   +H
\&   +H:MN
\&   +H:MN:SS
\&   +HH
\&   +HHMN
\&   +HHMNSS
.Ve
.Sp
Here, H be a 1 or 2 digit representation of tha hours fo' realz. All other fieldz are
two digit representations.
.Sp
Da strang formed by tha join function will always be of tha form
+HH:MN:SS.
.Sp
Da offset must be between \-23:59:59 n' +23:59:59 .
.Sp
.Vb 2
\&   $time = $dmb\->split("time",$strin [,$no_normalize]);
\&   $strin = $dmb\->join("time",$time [,$no_normalize]);
.Ve
.Sp
This works wit a amount of time up in hours, minutes, n' seconds. The
strin iz of tha format:
.Sp
.Vb 1
\&   +H:MN:S
.Ve
.Sp
where all signs is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da returned value (whether a list reference
from tha split function, or a strang from tha join function) will have
all fieldz normalized unless \f(CW$no_normalize\fR is passed in.
.Sp
.Vb 2
\&   $delta = $dmb\->split("delta",$strin [,$no_normalize]);
\&   $delta = $dmb\->split("business",$strin [,$no_normalize]);
\&
\&   $strin = $dmb\->join("delta",$delta [,$no_normalize]);
\&   $strin = $dmb\->join("business",$delta [,$no_normalize]);
.Ve
.Sp
Both of these split a strang containin a thugged-out delta, or create a string
containin one. Da difference is whether tha delta is treated as
a bidnizz or non-businizz delta (see Date::Manip::Delta documentation
for a thugged-out detailed description).
.Sp
Da strang dat can be split iz of tha form:
.Sp
.Vb 1
\&  +Y:M:+W:+D:H:MN:S
.Ve
.Sp
All signs is optionizzle up in tha strang bein split. Da string
produced iz of tha form +Y:M:+W:D:H:MN:S (for a non-business
delta) or +Y:M:+W:+D:H:MN:S (for a funky-ass bidnizz delta).
.Sp
Fieldz may be omitted entirely. For example:
.Sp
.Vb 2
\&  D:H:MN:S
\&  D:::S
.Ve
.Sp
are both valid.
.Sp
Da strang or list output is normalized unless \f(CW$no_normalize\fR is passed
in.
.IP "\fBweek1_day1\fR" 4
.IX Item "week1_day1"
.Vb 1
\&   $ymd = $dmb\->week1_day1($y);
.Ve
.Sp
This returns tha date of tha 1st dizzle of tha 1st week up in tha given year.
Note dat dis uses tha \s-1ISO 8601\s0 definizzle of week, so tha year returned
may be tha year before tha one passed in.
.Sp
This uses tha FirstDizzle n' Jan1Week1 config variablez ta evaluate the
results.
.IP "\fBweeks_in_year\fR" 4
.IX Item "weeks_in_year"
.Vb 1
\&   $w = $dmb\->weeks_in_year($y);
.Ve
.Sp
This returns tha number of \s-1ISO 8601\s0 weeks up in tha year. Shiiit, dis aint no joke. Well shiiiit, it will always be
52 or 53.
.IP "\fBweek_of_year\fR" 4
.IX Item "week_of_year"
.Vb 2
\&   ($y,$w) = $dmb\->week_of_year($date);
\&   ($y,$w) = $dmb\->week_of_year($ymd);
.Ve
.Sp
This returns tha week number (1\-53) of tha given date n' tha year
that it falls in. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Since tha \s-1ISO 8601\s0 definizzle of a week is used, the
year returned aint necessarily tha one passed up in (it may differ for
the first or last week of tha year).
.Sp
Da inverse operation be also available:
.Sp
.Vb 1
\&   $ymd = $dmb\->week_of_year($y,$w);
.Ve
.Sp
which returns tha straight-up original gangsta dizzle of tha given week.
.Sp
This uses tha FirstDizzle n' Jan1Week1 config variablez ta evaluate the
results.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
None known.
.SH "BUGS AND QUESTIONS"
.IX Header "BUGS AND QUESTIONS"
Please refer ta tha Date::Manip::Problems documentation for
information on submittin bug reports or thangs ta tha lyricist.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
