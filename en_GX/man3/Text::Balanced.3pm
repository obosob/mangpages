.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Balanced 3pm"
.TH Text::Balanced 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Balanced \- Extract delimited text sequences from strings.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\& use Text::Balanced qw (
\&                        extract_delimited
\&                        extract_bracketed
\&                        extract_quotelike
\&                        extract_codeblock
\&                        extract_variable
\&                        extract_tagged
\&                        extract_multiple
\&                        gen_delimited_pat
\&                        gen_extract_tagged
\&                       );
\&
\& # Extract tha initial substrin of $text dat is delimited by
\& # two (unescaped) instancez of tha straight-up original gangsta characta up in $delim.
\&
\&        ($extracted, $remainder) = extract_delimited($text,$delim);
\&
\&
\& # Extract tha initial substrin of $text dat is bracketed
\& # wit a thugged-out delimiter(s) specified by $delim (where tha string
\& # up in $delim gotz nuff one or mo' of \*(Aq(){}[]<>\*(Aq).
\&
\&        ($extracted, $remainder) = extract_bracketed($text,$delim);
\&
\&
\& # Extract tha initial substrin of $text dat is bounded by
\& # a XML tag.
\&
\&        ($extracted, $remainder) = extract_tagged($text);
\&
\&
\& # Extract tha initial substrin of $text dat is bounded by
\& # a C<BEGIN>...C<END> pair. Shiiit, dis aint no joke. Don\*(Aqt allow nested C<BEGIN> tags
\&
\&        ($extracted, $remainder) =
\&                extract_tagged($text,"BEGIN","END",undef,{bad=>["BEGIN"]});
\&
\&
\& # Extract tha initial substrin of $text dat represents a
\& # Perl "quote or quote\-like operation"
\&
\&        ($extracted, $remainder) = extract_quotelike($text);
\&
\&
\& # Extract tha initial substrin of $text dat represents a funky-ass block
\& # of Perl code, bracketed by any of character(s) specified by $delim
\& # (where tha strang $delim gotz nuff one or mo' of \*(Aq(){}[]<>\*(Aq).
\&
\&        ($extracted, $remainder) = extract_codeblock($text,$delim);
\&
\&
\& # Extract tha initial substringz of $text dat would be extracted by
\& # one or mo' sequential applicationz of tha specified functions
\& # or regular expressions
\&
\&        @extracted = extract_multiple($text,
\&                                      [ \e&extract_bracketed,
\&                                        \e&extract_quotelike,
\&                                        \e&some_other_extractor_sub,
\&                                        qr/[xyz]*/,
\&                                        \*(Aqliteral\*(Aq,
\&                                      ]);
.Ve
.PP
# Smoke a strang representin a optimized pattern (a la Friedl)
# dat matches a substrin delimited by any of tha specified characters
# (in dis case: any type of quote or a slash)
.PP
.Vb 1
\&        $patstrin = gen_delimited_pat(q{\*(Aq"\`/});
.Ve
.PP
# Generate a reference ta a anonymous sub dat is just like extract_tagged
# but pre-compiled n' optimized fo' a specific pair of tags, n' consequently
# much fasta (i.e. 3 times faster). Well shiiiit, it uses qr// fo' betta performizzle on
# repeated calls, so it only works under Perl 5.005 or later.
.PP
.Vb 1
\&        $extract_head = gen_extract_tagged(\*(Aq<HEAD>\*(Aq,\*(Aq</HEAD>\*(Aq);
\&
\&        ($extracted, $remainder) = $extract_head\->($text);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da various \f(CW\*(C`extract_...\*(C'\fR subroutines may be used to
extract a thugged-out delimited substring, possibly afta skippin a
specified prefix string. By default, dat prefix is
optionizzle whitespace (\f(CW\*(C`/\es*/\*(C'\fR) yo, but you can chizzle it ta whatever
you wish (see below).
.PP
Da substrin ta be extracted must step tha fuck up at the
current \f(CW\*(C`pos\*(C'\fR location of tha stringz variable
(or at index zero, if no \f(CW\*(C`pos\*(C'\fR posizzle is defined).
In other lyrics, tha \f(CW\*(C`extract_...\*(C'\fR subroutines \fIdon't\fR
extract tha straight-up original gangsta occurrence of a substrin anywhere
in a strang (like a unanchored regex would). Rather,
they extract a occurrence of tha substrin appearing
immediately all up in tha current matchin posizzle up in the
strin (like a \f(CW\*(C`\eG\*(C'\fR\-anchored regex would).
.SS "General behaviour up in list contexts"
.IX Subsection "General behaviour up in list contexts"
In a list context, all tha subroutines return a list, tha straight-up original gangsta three
elementz of which is always:
.IP "[0]" 4
.IX Item "[0]"
Da extracted string, includin tha specified delimiters.
If tha extraction fails \f(CW\*(C`undef\*(C'\fR is returned.
.IP "[1]" 4
.IX Item "[1]"
Da remainder of tha input strang (i.e. tha charactas afta the
extracted string). On failure, tha entire strang is returned.
.IP "[2]" 4
.IX Item "[2]"
Da skipped prefix (i.e. tha charactas before tha extracted string).
On failure, \f(CW\*(C`undef\*(C'\fR is returned.
.PP
Note dat up in a list context, tha contentz of tha original gangsta input text (the first
argument) is not modified up in any way.
.PP
But fuck dat shiznit yo, tha word on tha street is dat if tha input text was passed up in a variable, dat variable's
\&\f(CW\*(C`pos\*(C'\fR value is updated ta point all up in tha straight-up original gangsta characta afta the
extracted text. That means dat up in a list context tha various
subroutines can be used much like regular expressions. For example:
.PP
.Vb 4
\&        while ( $next = (extract_quotelike($text))[0] )
\&        {
\&                # process next quote\-like (in $next)
\&        }
.Ve
.SS "General behaviour up in scalar n' void contexts"
.IX Subsection "General behaviour up in scalar n' void contexts"
In a scalar context, tha extracted strang is returned, havin first been
removed from tha input text. Thus, tha followin code also processes
each quote-like operation yo, but straight-up removes dem from \f(CW$text:\fR
.PP
.Vb 4
\&        while ( $next = extract_quotelike($text) )
\&        {
\&                # process next quote\-like (in $next)
\&        }
.Ve
.PP
Note dat if tha input text be a read-only strang (i.e. a literal),
no attempt is made ta remove tha extracted text.
.PP
In a void context tha behaviour of tha extraction subroutines is
exactly tha same as up in a scalar context, except (of course) dat the
extracted substrin aint returned.
.SS "A note bout prefixes"
.IX Subsection "A note bout prefixes"
Prefix patterns is matched without any trailin modifiers (\f(CW\*(C`/gimsox\*(C'\fR etc.)
This can bite you if you expectin a prefix justification like
\&'.*?(?=<H1>)' ta skip every last muthafuckin thang up ta tha straight-up original gangsta <H1> tag. Right back up in yo muthafuckin ass. Such a prefix
pattern will only succeed if tha <H1> tag is on tha current line, since
\&. normally don't match newlines.
.PP
To overcome dis limitation, you need ta turn on /s matchin within
the prefix pattern, rockin tha \f(CW\*(C`(?s)\*(C'\fR directive: '(?s).*?(?=<H1>)'
.ie n .SS """extract_delimited"""
.el .SS "\f(CWextract_delimited\fP"
.IX Subsection "extract_delimited"
Da \f(CW\*(C`extract_delimited\*(C'\fR function formalizes tha common idiom
of extractin a single-character-delimited substrin from tha start of
a string. For example, ta extract a single-quote delimited string, the
followin code is typically used:
.PP
.Vb 2
\&        ($remainder = $text) =~ s/\eA(\*(Aq(\e\e.|[^\*(Aq])*\*(Aq)//s;
\&        $extracted = $1;
.Ve
.PP
but wit \f(CW\*(C`extract_delimited\*(C'\fR it can be simplified to:
.PP
.Vb 1
\&        ($extracted,$remainder) = extract_delimited($text, "\*(Aq");
.Ve
.PP
\&\f(CW\*(C`extract_delimited\*(C'\fR takes up ta four scalars (the input text, the
delimiters, a prefix pattern ta be skipped, n' any escape characters)
and extracts tha initial substrin of tha text that
is appropriately delimited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha delimita strang has multiple
characters, tha straight-up original gangsta one encountered up in tha text is taken ta delimit
the substring.
Da third argument specifies a prefix pattern dat is ta be skipped
(but must be present!) before tha substrin is extracted.
Da final argument specifies tha escape characta ta be used fo' each
delimiter.
.PP
All arguments is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If tha escape charactas is not specified,
every delimita is escaped wit a funky-ass backslash (\f(CW\*(C`\e\*(C'\fR).
If tha prefix aint specified, the
pattern \f(CW\*(Aq\es*\*(Aq\fR \- optionizzle whitespace \- is used. Y'all KNOW dat shit, muthafucka! If tha delimita set
is also not specified, tha set \f(CW\*(C`/["\*(Aq\`]/\*(C'\fR is used. Y'all KNOW dat shit, muthafucka! If tha text ta be processed
is not specified either, \f(CW$_\fR is used.
.PP
In list context, \f(CW\*(C`extract_delimited\*(C'\fR returns a array of three
elements, tha extracted substrin (\fIincludin tha surrounding
delimiters\fR), tha remainder of tha text, n' tha skipped prefix (if
any). If a suitable delimited substrin aint found, tha first
element of tha array is tha empty string, tha second is tha complete
original gangsta text, n' tha prefix returned up in tha third element be an
empty string.
.PP
In a scalar context, just tha extracted substrin is returned. Y'all KNOW dat shit, muthafucka! In
a void context, tha extracted substrin (and any prefix) is simply
removed from tha beginnin of tha straight-up original gangsta argument.
.PP
Examples:
.PP
.Vb 1
\&        # Remove a single\-quoted substrin from tha straight-up beginnin of $text:
\&
\&                $substrin = extract_delimited($text, "\*(Aq", \*(Aq\*(Aq);
\&
\&        # Remove a single\-quoted Pascalish substrin (i.e. one up in which
\&        # doublin tha quote characta escapes it) from tha hella
\&        # beginnin of $text:
\&
\&                $substrin = extract_delimited($text, "\*(Aq", \*(Aq\*(Aq, "\*(Aq");
\&
\&        # Extract a single\- or double\- quoted substrin from the
\&        # beginnin of $text, optionally afta some whitespace
\&        # (note tha list context ta protect $text from modification):
\&
\&                ($substring) = extract_delimited $text, q{"\*(Aq};
\&
\&        # Delete tha substrin delimited by tha straight-up original gangsta \*(Aq/\*(Aq up in $text:
\&
\&                $text = join \*(Aq\*(Aq, (extract_delimited($text,\*(Aq/\*(Aq,\*(Aq[^/]*\*(Aq)[2,1];
.Ve
.PP
Note dat dis last example is \fInot\fR tha same as deletin tha first
quote-like pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. For instance, if \f(CW$text\fR contained tha string:
.PP
.Vb 1
\&        "if (\*(Aq./cmd\*(Aq =~ m/$UNIXCMD/s) { $cmd = $1; }"
.Ve
.PP
then afta tha deletion it would contain:
.PP
.Vb 1
\&        "if (\*(Aq.$UNIXCMD/s) { $cmd = $1; }"
.Ve
.PP
not:
.PP
.Vb 1
\&        "if (\*(Aq./cmd\*(Aq =~ ms) { $cmd = $1; }"
.Ve
.PP
See \*(L"extract_quotelike\*(R" fo' a (partial) solution ta dis problem.
.ie n .SS """extract_bracketed"""
.el .SS "\f(CWextract_bracketed\fP"
.IX Subsection "extract_bracketed"
Like \f(CW"extract_delimited"\fR, tha \f(CW\*(C`extract_bracketed\*(C'\fR function takes
up ta three optionizzle scalar arguments: a strang ta extract from, a thugged-out delimiter
specifier, n' a prefix pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch fo' realz. As before, a missin prefix defaults to
optionizzle whitespace n' a missin text defaults ta \f(CW$_\fR. But fuck dat shiznit yo, tha word on tha street is dat a missing
delimita specifier defaults ta \f(CW\*(Aq{}()[]<>\*(Aq\fR (see below).
.PP
\&\f(CW\*(C`extract_bracketed\*(C'\fR extracts a funky-ass balanced-bracket-delimited
substrin (usin any one (or more) of tha user-specified delimiter
brackets: '(..)', '{..}', '[..]', or '<..>'). Optionally it will also
respect quoted unbalanced brackets (see below).
.PP
A \*(L"delimita bracket\*(R" be a funky-ass bracket up in list of delimitas passed as
\&\f(CW\*(C`extract_bracketed\*(C'\fRz second argument. Delimita brackets are
specified by givin either tha left or right (or both!) versions
of tha required bracket(s). Note dat tha order up in which
two or mo' delimita brackets is specified aint significant.
.PP
A \*(L"balanced-bracket-delimited substring\*(R" be a substrin bounded by
matched brackets, such dat any other (left or right) delimiter
bracket \fIwithin\fR tha substrin be also matched by a opposite
(right or left) delimita bracket \fIat tha same level of nesting\fR fo' realz. Any
type of bracket not up in tha delimita list is treated as a ordinary
character.
.PP
In other lyrics, each type of bracket specified as a thugged-out delimita must be
balanced n' erectly nested within tha substring, n' any other kind of
(\*(L"non-delimiter\*(R") bracket up in tha substrin is ignored.
.PP
For example, given tha string:
.PP
.Vb 1
\&        $text = "{ a \*(Aq[irregularly :\-(] {} parenthesized >:\-)\*(Aq strang }";
.Ve
.PP
then a cold-ass lil call ta \f(CW\*(C`extract_bracketed\*(C'\fR up in a list context:
.PP
.Vb 1
\&        @result = extract_bracketed( $text, \*(Aq{}\*(Aq );
.Ve
.PP
would return:
.PP
.Vb 1
\&        ( "{ a \*(Aq[irregularly :\-(] {} parenthesized >:\-)\*(Aq strang }" , "" , "" )
.Ve
.PP
since both setz of \f(CW\*(Aq{..}\*(Aq\fR brackets is properly nested n' evenly balanced.
(In a scalar context just tha straight-up original gangsta element of tha array would be returned. Y'all KNOW dat shit, muthafucka! In
a void context, \f(CW$text\fR would be replaced by a empty string.)
.PP
Likewise tha call in:
.PP
.Vb 1
\&        @result = extract_bracketed( $text, \*(Aq{[\*(Aq );
.Ve
.PP
would return tha same result, since all setz of both typez of specified
delimita brackets is erectly nested n' balanced.
.PP
But fuck dat shiznit yo, tha word on tha street is dat tha call in:
.PP
.Vb 1
\&        @result = extract_bracketed( $text, \*(Aq{([<\*(Aq );
.Ve
.PP
would fail, returning:
.PP
.Vb 1
\&        ( undef , "{ a \*(Aq[irregularly :\-(] {} parenthesized >:\-)\*(Aq strang }"  );
.Ve
.PP
because tha embedded pairz of \f(CW\*(Aq(..)\*(Aq\fRs n' \f(CW\*(Aq[..]\*(Aq\fRs is \*(L"cross-nested\*(R" and
the embedded \f(CW\*(Aq>\*(Aq\fR is unbalanced. Y'all KNOW dat shit, muthafucka! (In a scalar context, dis call would
return a empty string. In a void context, \f(CW$text\fR would be unchanged.)
.PP
Note dat tha embedded single-quotes up in tha strang don't help up in this
case, since they aint been specified as aaight delimitas n' are
therefore treated as non-delimita charactas (and ignored).
.PP
But fuck dat shiznit yo, tha word on tha street is dat if a particular speciez of quote characta is included up in the
delimita justification, then dat type of quote is ghon be erectly handled.
for example, if \f(CW$text\fR is:
.PP
.Vb 1
\&        $text = \*(Aq<A HREF=">>>>">link</A>\*(Aq;
.Ve
.PP
then
.PP
.Vb 1
\&        @result = extract_bracketed( $text, \*(Aq<">\*(Aq );
.Ve
.PP
returns:
.PP
.Vb 1
\&        ( \*(Aq<A HREF=">>>>">\*(Aq, \*(Aqlink</A>\*(Aq, "" )
.Ve
.PP
as expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Without tha justification of \f(CW\*(C`"\*(C'\fR as a embedded quoter:
.PP
.Vb 1
\&        @result = extract_bracketed( $text, \*(Aq<>\*(Aq );
.Ve
.PP
the result would be:
.PP
.Vb 1
\&        ( \*(Aq<A HREF=">\*(Aq, \*(Aq>>>">link</A>\*(Aq, "" )
.Ve
.PP
In addizzle ta tha quote delimitas \f(CW\*(C`\*(Aq\*(C'\fR, \f(CW\*(C`"\*(C'\fR, n' \f(CW\*(C`\`\*(C'\fR, full Perl quote-like
quotin (i.e. q{string}, qq{string}, etc) can be specified by includin the
letta 'q' as a thugged-out delimiter n' shiznit yo. Hence:
.PP
.Vb 1
\&        @result = extract_bracketed( $text, \*(Aq<q>\*(Aq );
.Ve
.PP
would erectly match suttin' like this:
.PP
.Vb 1
\&        $text = \*(Aq<leftop: conj /and/ conj>\*(Aq;
.Ve
.PP
See also: \f(CW"extract_quotelike"\fR n' \f(CW"extract_codeblock"\fR.
.ie n .SS """extract_variable"""
.el .SS "\f(CWextract_variable\fP"
.IX Subsection "extract_variable"
\&\f(CW\*(C`extract_variable\*(C'\fR extracts any valid Perl variable or
variable-involved expression, includin scalars, arrays, hashes, array
accesses, hash look-ups, method calls all up in objects, subroutine calls
all up in subroutine references, etc.
.PP
Da subroutine takes up ta two optionizzle arguments:
.IP "1." 4
A strang ta be processed (\f(CW$_\fR if tha strang is omitted or \f(CW\*(C`undef\*(C'\fR)
.IP "2." 4
A strang specifyin a pattern ta be matched as a prefix (which is ta be
skipped). If omitted, optionizzle whitespace is skipped.
.PP
On success up in a list context, a array of 3 elements is returned. Y'all KNOW dat shit, muthafucka! The
elements are:
.IP "[0]" 4
.IX Item "[0]"
the extracted variable, or variablish expression
.IP "[1]" 4
.IX Item "[1]"
the remainder of tha input text,
.IP "[2]" 4
.IX Item "[2]"
the prefix substrin (if any),
.PP
On failure, all of these joints (except tha remainin text) is \f(CW\*(C`undef\*(C'\fR.
.PP
In a scalar context, \f(CW\*(C`extract_variable\*(C'\fR returns just tha complete
substrin dat matched a variablish expression. I aint talkin' bout chicken n' gravy biatch. \f(CW\*(C`undef\*(C'\fR is returned on
failure. In addition, tha original gangsta input text has tha returned substring
(and any prefix) removed from dat shit.
.PP
In a void context, tha input text just has tha matched substrin (and
any specified prefix) removed.
.ie n .SS """extract_tagged"""
.el .SS "\f(CWextract_tagged\fP"
.IX Subsection "extract_tagged"
\&\f(CW\*(C`extract_tagged\*(C'\fR extracts n' segments text between (balanced)
specified tags.
.PP
Da subroutine takes up ta five optionizzle arguments:
.IP "1." 4
A strang ta be processed (\f(CW$_\fR if tha strang is omitted or \f(CW\*(C`undef\*(C'\fR)
.IP "2." 4
A strang specifyin a pattern ta be matched as tha openin tag.
If tha pattern strang is omitted (or \f(CW\*(C`undef\*(C'\fR) then a pattern
that matches any standard \s-1XML\s0 tag is used.
.IP "3." 4
A strang specifyin a pattern ta be matched all up in tha closin tag. 
If tha pattern strang is omitted (or \f(CW\*(C`undef\*(C'\fR) then tha closing
tag is constructed by insertin a \f(CW\*(C`/\*(C'\fR afta any leadin bracket
charactas up in tha actual openin tag dat was matched (\fInot\fR tha pattern
that matched tha tag). For example, if tha openin tag pattern
is specified as \f(CW\*(Aq{{\ew+}}\*(Aq\fR n' straight-up matched tha openin tag 
\&\f(CW"{{DATA}}"\fR, then tha constructed closin tag would be \f(CW"{{/DATA}}"\fR.
.IP "4." 4
A strang specifyin a pattern ta be matched as a prefix (which is ta be
skipped). If omitted, optionizzle whitespace is skipped.
.IP "5." 4
A hash reference containin various parsin options (see below)
.PP
Da various options dat can be specified are:
.ie n .IP """reject => $listref""" 4
.el .IP "\f(CWreject => $listref\fR" 4
.IX Item "reject => $listref"
Da list reference gotz nuff one or mo' strings specifyin patterns
that must \fInot\fR step tha fuck up within tha tagged text.
.Sp
For example, ta extract
an \s-1HTML\s0 link (which should not contain nested links) use:
.Sp
.Vb 1
\&        extract_tagged($text, \*(Aq<A>\*(Aq, \*(Aq</A>\*(Aq, undef, {reject => [\*(Aq<A>\*(Aq]} );
.Ve
.ie n .IP """ignore => $listref""" 4
.el .IP "\f(CWignore => $listref\fR" 4
.IX Item "ignore => $listref"
Da list reference gotz nuff one or mo' strings specifyin patterns
that is \fInot\fR be be treated as nested tags within tha tagged text
(even if they would match tha start tag pattern).
.Sp
For example, ta extract a arbitrary \s-1XML\s0 tag yo, but ignore \*(L"empty\*(R" elements:
.Sp
.Vb 1
\&        extract_tagged($text, undef, undef, undef, {ignore => [\*(Aq<[^>]*/>\*(Aq]} );
.Ve
.Sp
(also peep \*(L"gen_delimited_pat\*(R" below).
.ie n .IP """fail => $str""" 4
.el .IP "\f(CWfail => $str\fR" 4
.IX Item "fail => $str"
Da \f(CW\*(C`fail\*(C'\fR option indicates tha action ta be taken if a matchin end
tag aint encountered (i.e. before tha end of tha strang or some
\&\f(CW\*(C`reject\*(C'\fR pattern matches). By default, a gangbangin' failure ta match a cold-ass lil closing
tag causes \f(CW\*(C`extract_tagged\*(C'\fR ta immediately fail.
.Sp
But fuck dat shiznit yo, tha word on tha street is dat if tha strang value associated wit <reject> is \*(L"\s-1MAX\*(R",\s0 then
\&\f(CW\*(C`extract_tagged\*(C'\fR returns tha complete text up ta tha deal wit failure.
If tha strang is \*(L"\s-1PARA\*(R", \s0\f(CW\*(C`extract_tagged\*(C'\fR returns only tha straight-up original gangsta paragraph
afta tha tag (up ta tha straight-up original gangsta line dat is either empty or gotz nuff
only whitespace characters).
If tha strang is "", tha the default behaviour (i.e. failure) is reinstated.
.Sp
For example, suppose tha start tag \*(L"/para\*(R" introduces a paragraph, which then
continues until tha next \*(L"/endpara\*(R" tag or until another \*(L"/para\*(R" tag is
encountered:
.Sp
.Vb 1
\&        $text = "/para line 1\en\enline 3\en/para line 4";
\&
\&        extract_tagged($text, \*(Aq/para\*(Aq, \*(Aq/endpara\*(Aq, undef,
\&                                {reject => \*(Aq/para\*(Aq, fail => MAX );
\&
\&        # EXTRACTED: "/para line 1\en\enline 3\en"
.Ve
.Sp
Suppose instead, dat if no matchin \*(L"/endpara\*(R" tag is found, tha \*(L"/para\*(R"
tag refers only ta tha immediately followin paragraph:
.Sp
.Vb 1
\&        $text = "/para line 1\en\enline 3\en/para line 4";
\&
\&        extract_tagged($text, \*(Aq/para\*(Aq, \*(Aq/endpara\*(Aq, undef,
\&                        {reject => \*(Aq/para\*(Aq, fail => MAX );
\&
\&        # EXTRACTED: "/para line 1\en"
.Ve
.Sp
Note dat tha specified \f(CW\*(C`fail\*(C'\fR behaviour applies ta nested tags as well.
.PP
On success up in a list context, a array of 6 elements is returned. Y'all KNOW dat shit, muthafucka! Da elements are:
.IP "[0]" 4
.IX Item "[0]"
the extracted tagged substrin (includin tha outermost tags),
.IP "[1]" 4
.IX Item "[1]"
the remainder of tha input text,
.IP "[2]" 4
.IX Item "[2]"
the prefix substrin (if any),
.IP "[3]" 4
.IX Item "[3]"
the openin tag
.IP "[4]" 4
.IX Item "[4]"
the text between tha openin n' closin tags
.IP "[5]" 4
.IX Item "[5]"
the closin tag (or "" if no closin tag was found)
.PP
On failure, all of these joints (except tha remainin text) is \f(CW\*(C`undef\*(C'\fR.
.PP
In a scalar context, \f(CW\*(C`extract_tagged\*(C'\fR returns just tha complete
substrin dat matched a tagged text (includin tha start n' end
tags). \f(CW\*(C`undef\*(C'\fR is returned on failure. In addition, tha original gangsta input
text has tha returned substrin (and any prefix) removed from dat shit.
.PP
In a void context, tha input text just has tha matched substrin (and
any specified prefix) removed.
.ie n .SS """gen_extract_tagged"""
.el .SS "\f(CWgen_extract_tagged\fP"
.IX Subsection "gen_extract_tagged"
(Note: This subroutine is only available under Perl5.005)
.PP
\&\f(CW\*(C`gen_extract_tagged\*(C'\fR generates a freshly smoked up anonymous subroutine which
extracts text between (balanced) specified tags. In other lyrics,
it generates a gangbangin' function identical up in function ta \f(CW\*(C`extract_tagged\*(C'\fR.
.PP
Da difference between \f(CW\*(C`extract_tagged\*(C'\fR n' tha anonymous
subroutines generated by
\&\f(CW\*(C`gen_extract_tagged\*(C'\fR, is dat dem generated subroutines:
.IP "\(bu" 4
do not gotta reparse tag justification or parsin options every last muthafuckin time
they is called (whereas \f(CW\*(C`extract_tagged\*(C'\fR has ta effectively rebuild
its tag parser on every last muthafuckin call);
.IP "\(bu" 4
make use of tha freshly smoked up qr// construct ta pre-compile tha regexes they use
(whereas \f(CW\*(C`extract_tagged\*(C'\fR uses standard strang variable interpolation 
to create tag-matchin patterns).
.PP
Da subroutine takes up ta four optionizzle arguments (the same set as
\&\f(CW\*(C`extract_tagged\*(C'\fR except fo' tha strang ta be processed). Well shiiiit, it returns
a reference ta a subroutine which up in turn takes a single argument (the text to
be extracted from).
.PP
In other lyrics, tha implementation of \f(CW\*(C`extract_tagged\*(C'\fR is exactly
equivalent to:
.PP
.Vb 6
\&        sub extract_tagged
\&        {
\&                mah $text = shift;
\&                $extractor = gen_extract_tagged(@_);
\&                return $extractor\->($text);
\&        }
.Ve
.PP
(although \f(CW\*(C`extract_tagged\*(C'\fR aint currently implemented dat way, up in order
to preserve pre\-5.005 compatibility).
.PP
Usin \f(CW\*(C`gen_extract_tagged\*(C'\fR ta create extraction functions fo' specific tags 
is a phat scam if dem functions is goin ta be called mo' than once, since
their performizzle is typically twice as phat as tha mo' general-purpose
\&\f(CW\*(C`extract_tagged\*(C'\fR.
.ie n .SS """extract_quotelike"""
.el .SS "\f(CWextract_quotelike\fP"
.IX Subsection "extract_quotelike"
\&\f(CW\*(C`extract_quotelike\*(C'\fR attempts ta recognize, extract, n' segment any
one of tha various Perl quotes n' quotelike operators (see
\&\fIperlop\fR\|(3)) Nested backslashed delimiters, embedded balanced bracket
delimitas (for tha quotelike operators), n' trailin modifiers are
all caught. For example, in:
.PP
.Vb 1
\&        extract_quotelike \*(Aqq # a octothorpe: \e# (not tha end of tha q!) #\*(Aq
\&        
\&        extract_quotelike \*(Aq  "Yo ass holla'd, \e"Use sed\e"."  \*(Aq
\&
\&        extract_quotelike \*(Aq s{([A\-Z]{1,8}\e.[A\-Z]{3})} /\eL$1\eE/; \*(Aq
\&
\&        extract_quotelike \*(Aq tr/\e\e\e/\e\e\e\e/\e\e\e//ds; \*(Aq
.Ve
.PP
the full Perl quotelike operations is all extracted erectly.
.PP
Note too that, when rockin tha /x modifier on a regex, any comment
containin tha current pattern delimita will cause tha regex ta be
immediately terminated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In other lyrics:
.PP
.Vb 5
\&        \*(Aqm /
\&                (?i)            # CASE INSENSITIVE
\&                [a\-z_]          # LEADING ALPHABETIC/UNDERSCORE
\&                [a\-z0\-9]*       # FOLLOWED BY ANY NUMBER OF ALPHANUMERICS
\&           /x\*(Aq
.Ve
.PP
will be extracted as if it were:
.PP
.Vb 3
\&        \*(Aqm /
\&                (?i)            # CASE INSENSITIVE
\&                [a\-z_]          # LEADING ALPHABETIC/\*(Aq
.Ve
.PP
This behaviour is identical ta dat of tha actual compiler.
.PP
\&\f(CW\*(C`extract_quotelike\*(C'\fR takes two arguments: tha text ta be processed and
a prefix ta be matched all up in tha straight-up beginnin of tha text. If no prefix 
is specified, optionizzle whitespace is tha default. If no text is given,
\&\f(CW$_\fR is used.
.PP
In a list context, a array of 11 elements is returned. Y'all KNOW dat shit, muthafucka! Da elements are:
.IP "[0]" 4
.IX Item "[0]"
the extracted quotelike substrin (includin trailin modifiers),
.IP "[1]" 4
.IX Item "[1]"
the remainder of tha input text,
.IP "[2]" 4
.IX Item "[2]"
the prefix substrin (if any),
.IP "[3]" 4
.IX Item "[3]"
the name of tha quotelike operator (if any),
.IP "[4]" 4
.IX Item "[4]"
the left delimita of tha straight-up original gangsta block of tha operation,
.IP "[5]" 4
.IX Item "[5]"
the text of tha straight-up original gangsta block of tha operation
(that is, tha contents of
a quote, tha regex of a match or substitution or tha target list of a
translation),
.IP "[6]" 4
.IX Item "[6]"
the right delimita of tha straight-up original gangsta block of tha operation,
.IP "[7]" 4
.IX Item "[7]"
the left delimita of tha second block of tha operation
(that is, if it aint nuthin but a \f(CW\*(C`s\*(C'\fR, \f(CW\*(C`tr\*(C'\fR, or \f(CW\*(C`y\*(C'\fR),
.IP "[8]" 4
.IX Item "[8]"
the text of tha second block of tha operation 
(that is, tha replacement of a substitution or tha translation list
of a translation),
.IP "[9]" 4
.IX Item "[9]"
the right delimita of tha second block of tha operation (if any),
.IP "[10]" 4
.IX Item "[10]"
the trailin modifiers on tha operation (if any).
.PP
For each of tha fieldz marked \*(L"(if any)\*(R" tha default value on success is
an empty string.
On failure, all of these joints (except tha remainin text) is \f(CW\*(C`undef\*(C'\fR.
.PP
In a scalar context, \f(CW\*(C`extract_quotelike\*(C'\fR returns just tha complete substring
that matched a quotelike operation (or \f(CW\*(C`undef\*(C'\fR on failure). In a scalar or
void context, tha input text has tha same ol' dirty substrin (and any specified
prefix) removed.
.PP
Examples:
.PP
.Vb 1
\&        # Remove tha straight-up original gangsta quotelike literal dat appears up in text
\&
\&                $quotelike = extract_quotelike($text,\*(Aq.*?\*(Aq);
\&
\&        # Replace one or mo' leadin whitespace\-separated quotelike
\&        # literals up in $_ wit "<QLL>"
\&
\&                do { $_ = join \*(Aq<QLL>\*(Aq, (extract_quotelike)[2,1] } until $@;
\&
\&
\&        # Isolate tha search pattern up in a quotelike operation from $text
\&
\&                ($op,$pat) = (extract_quotelike $text)[3,5];
\&                if ($op =~ /[ms]/)
\&                {
\&                        print "search pattern: $pat\en";
\&                }
\&                else
\&                {
\&                        print "$op aint a pattern matchin operation\en";
\&                }
.Ve
.ie n .SS """extract_quotelike"" n' ""here documents"""
.el .SS "\f(CWextract_quotelike\fP n' ``here documents''"
.IX Subsection "extract_quotelike n' here documents"
\&\f(CW\*(C`extract_quotelike\*(C'\fR can successfully extract \*(L"here documents\*(R" from a input
strin yo, but wit a blingin caveat up in list contexts.
.PP
Unlike other typez of quote-like literals, a here document is rarely
a contiguous substring. For example, a typical piece of code using
here document might be lookin like this:
.PP
.Vb 4
\&        <<\*(AqEOMSG\*(Aq || die;
\&        This is tha message.
\&        EOMSG
\&        exit;
.Ve
.PP
Given dis as a input strang up in a scalar context, \f(CW\*(C`extract_quotelike\*(C'\fR
would erectly return tha strang \*(L"<<'\s-1EOMSG\s0'\enThis is tha message.\enEOMSG\*(R",
leavin tha strang \*(L" || die;\enexit;\*(R" up in tha original gangsta variable. In other lyrics,
the two separate piecez of tha here document is successfully extracted and
concatenated.
.PP
In a list context, \f(CW\*(C`extract_quotelike\*(C'\fR would return tha list
.IP "[0]" 4
.IX Item "[0]"
\&\*(L"<<'\s-1EOMSG\s0'\enThis is tha message.\enEOMSG\en\*(R" (i.e. tha full extracted here document,
includin fore n' aft delimiters),
.IP "[1]" 4
.IX Item "[1]"
\&\*(L" || die;\enexit;\*(R" (i.e. tha remainder of tha input text, concatenated),
.IP "[2]" 4
.IX Item "[2]"
"" (i.e. tha prefix substrin \*(-- trivial up in dis case),
.IP "[3]" 4
.IX Item "[3]"
\&\*(L"<<\*(R" (i.e. tha \*(L"name\*(R" of tha quotelike operator)
.IP "[4]" 4
.IX Item "[4]"
\&\*(L"'\s-1EOMSG\s0'\*(R" (i.e. tha left delimita of tha here document, includin any quotes),
.IP "[5]" 4
.IX Item "[5]"
\&\*(L"This is tha message.\en\*(R" (i.e. tha text of tha here document),
.IP "[6]" 4
.IX Item "[6]"
\&\*(L"\s-1EOMSG\*(R" \s0(i.e. tha right delimita of tha here document),
.IP "[7..10]" 4
.IX Item "[7..10]"
"" (a here document has no second left delimiter, second text, second right
delimiter, or trailin modifiers).
.PP
But fuck dat shiznit yo, tha word on tha street is dat tha matchin posizzle of tha input variable would be set to
\&\*(L"exit;\*(R" (i.e. \fIafter\fR tha closin delimita of tha here document),
which would cause tha earlier \*(L" || die;\enexit;\*(R" ta be skipped up in any
sequence of code fragment extractions.
.PP
To avoid dis problem, when it encountas a here document whilst
extractin from a modifiable string, \f(CW\*(C`extract_quotelike\*(C'\fR silently
rearranges tha strang ta a equivalent piece of Perl:
.PP
.Vb 5
\&        <<\*(AqEOMSG\*(Aq
\&        This is tha message.
\&        EOMSG
\&        || die;
\&        exit;
.Ve
.PP
in which tha here document \fIis\fR contiguous. Well shiiiit, it still leaves the
matchin posizzle afta tha here document yo, but now tha rest of tha line
on which tha here document starts aint skipped.
.PP
To prevent <extract_quotelike> from muckin bout wit tha input up in dis way
(this is tha only case where a list-context \f(CW\*(C`extract_quotelike\*(C'\fR do so),
you can pass tha input variable as a interpolated literal:
.PP
.Vb 1
\&        $quotelike = extract_quotelike("$var");
.Ve
.ie n .SS """extract_codeblock"""
.el .SS "\f(CWextract_codeblock\fP"
.IX Subsection "extract_codeblock"
\&\f(CW\*(C`extract_codeblock\*(C'\fR attempts ta recognize n' extract a funky-ass balanced
bracket delimited substrin dat may contain unbalanced brackets
inside Perl quotes or quotelike operations. That is, \f(CW\*(C`extract_codeblock\*(C'\fR
is like a cold-ass lil combination of \f(CW"extract_bracketed"\fR and
\&\f(CW"extract_quotelike"\fR.
.PP
\&\f(CW\*(C`extract_codeblock\*(C'\fR takes tha same ol' dirty initial three parametas as \f(CW\*(C`extract_bracketed\*(C'\fR:
a text ta process, a set of delimita brackets ta look for, n' a prefix to
match first. Well shiiiit, it also takes a optionizzle fourth parameter, which allows the
outermost delimita brackets ta be specified separately (see below).
.PP
Omittin tha straight-up original gangsta argument (input text) means process \f(CW$_\fR instead.
Omittin tha second argument (delimita brackets) indicates dat only \f(CW\*(Aq{\*(Aq\fR is ta be used.
Omittin tha third argument (prefix argument) implies optionizzle whitespace all up in tha start.
Omittin tha fourth argument (outermost delimita brackets) indicates dat the
value of tha second argument is ta be used fo' tha outermost delimiters.
.PP
Once tha prefix a dthe outermost openin delimita bracket have been
recognized, code blocks is extracted by steppin all up in tha input text and
tryin tha followin alternatives up in sequence:
.IP "1." 4
Try n' match a cold-ass lil closin delimita bracket. If tha bracket was tha same
species as tha last openin bracket, return tha substrin ta that
point. If tha bracket was mismatched, return a error.
.IP "2." 4
Try ta match a quote or quotelike operator. Shiiit, dis aint no joke. If found, call
\&\f(CW\*(C`extract_quotelike\*(C'\fR ta smoke dat shit. If \f(CW\*(C`extract_quotelike\*(C'\fR fails, return
the error it returned. Y'all KNOW dat shit, muthafucka! Otherwise go back ta step 1.
.IP "3." 4
Try ta match a openin delimita bracket. If found, call
\&\f(CW\*(C`extract_codeblock\*(C'\fR recursively ta smoke tha embedded block. If the
recursive call fails, return a error. Shiiit, dis aint no joke. Otherwise, go back ta step 1.
.IP "4." 4
Unconditionally match a funky-ass bareword or any other single character, and
then go back ta step 1.
.PP
Examples:
.PP
.Vb 1
\&        # Find a while loop up in tha text
\&
\&                if ($text =~ s/.*?while\es*\e{/{/)
\&                {
\&                        $loop = "while " . extract_codeblock($text);
\&                }
\&
\&        # Remove tha straight-up original gangsta round\-bracketed list (which may include
\&        # round\- or curly\-bracketed code blocks or quotelike operators)
\&
\&                extract_codeblock $text, "(){}", \*(Aq[^(]*\*(Aq;
.Ve
.PP
Da mobilitizzle ta specify a gangbangin' finger-lickin' different outermost delimita bracket is useful
in some circumstances. For example, up in tha Parse::RecDescent module,
parser actions which is ta be performed only on a successful parse
are specified rockin a \f(CW\*(C`<defer:...>\*(C'\fR directive. For example:
.PP
.Vb 2
\&        sentence: subject verb object
\&                        <defer: {$::theVerb = $item{verb}} >
.Ve
.PP
Parse::RecDescent uses \f(CW\*(C`extract_codeblock($text, \*(Aq{}<>\*(Aq)\*(C'\fR ta extract tha code
within tha \f(CW\*(C`<defer:...>\*(C'\fR directizzle yo, but there be a a problem.
.PP
A deferred action like this:
.PP
.Vb 1
\&                        <defer: {if ($count>10) {$count\-\-}} >
.Ve
.PP
will be incorrectly parsed as:
.PP
.Vb 1
\&                        <defer: {if ($count>
.Ve
.PP
because tha \*(L"less than\*(R" operator is interpreted as a cold-ass lil closin delimiter.
.PP
But, by extractin tha directizzle using
\&\f(CW\*(C`extract_codeblock($text,\ \*(Aq{}\*(Aq,\ undef,\ \*(Aq<>\*(Aq)\*(C'\fR
the '>' characta is only treated as a thugged-out delimited all up in tha outermost
level of tha code block, so tha directizzle is parsed erectly.
.ie n .SS """extract_multiple"""
.el .SS "\f(CWextract_multiple\fP"
.IX Subsection "extract_multiple"
Da \f(CW\*(C`extract_multiple\*(C'\fR subroutine takes a strang ta be processed n' a 
list of extractors (subroutines or regular expressions) ta apply ta dat string.
.PP
In a array context \f(CW\*(C`extract_multiple\*(C'\fR returns a array of substrings
of tha original gangsta string, as extracted by tha specified extractors.
In a scalar context, \f(CW\*(C`extract_multiple\*(C'\fR returns tha first
substrin successfully extracted from tha original gangsta string. In both
scalar n' void contexts tha original gangsta strang has tha straight-up original gangsta successfully
extracted substrin removed from dat shit. In all contexts
\&\f(CW\*(C`extract_multiple\*(C'\fR starts all up in tha current \f(CW\*(C`pos\*(C'\fR of tha string, and
sets dat \f(CW\*(C`pos\*(C'\fR appropriately afta it matches.
.PP
Hence, tha aim of a cold-ass lil call ta \f(CW\*(C`extract_multiple\*(C'\fR up in a list context
is ta split tha processed strang tha fuck into as nuff non-overlappin fieldz as
possible, by repeatedly applyin each of tha specified extractors
to tha remainder of tha string. Thus \f(CW\*(C`extract_multiple\*(C'\fR is
a generalized form of Perlz \f(CW\*(C`split\*(C'\fR subroutine.
.PP
Da subroutine takes up ta four optionizzle arguments:
.IP "1." 4
A strang ta be processed (\f(CW$_\fR if tha strang is omitted or \f(CW\*(C`undef\*(C'\fR)
.IP "2." 4
A reference ta a list of subroutine references and/or qr// objects and/or
literal strings and/or hash references, specifyin tha extractors
to be used ta split tha string. If dis argument is omitted (or
\&\f(CW\*(C`undef\*(C'\fR) tha list:
.Sp
.Vb 5
\&        [
\&                sub { extract_variable($_[0], \*(Aq\*(Aq) },
\&                sub { extract_quotelike($_[0],\*(Aq\*(Aq) },
\&                sub { extract_codeblock($_[0],\*(Aq{}\*(Aq,\*(Aq\*(Aq) },
\&        ]
.Ve
.Sp
is used.
.IP "3." 4
An number specifyin tha maximum number of fieldz ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. If this
argument is omitted (or \f(CW\*(C`undef\*(C'\fR), split continues as long as possible.
.Sp
If tha third argument is \fIN\fR, then extraction continues until \fIN\fR fields
have been successfully extracted, or until tha strang has been straight-up 
processed.
.Sp
Note dat up in scalar n' void contexts tha value of dis argument is 
automatically reset ta 1 (under \f(CW\*(C`\-w\*(C'\fR, a warnin is issued if tha argument 
has ta be reset).
.IP "4." 4
A value indicatin whether unmatched substrings (see below) within the
text should be skipped or returned as fields. If tha value is true,
such substrings is skipped. Y'all KNOW dat shit, muthafucka! Otherwise, they is returned.
.PP
Da extraction process works by applyin each extractor in
sequence ta tha text string.
.PP
If tha extractor be a subroutine it is called up in a list context n' is
sposed ta fuckin return a list of a single element, namely tha extracted
text. Well shiiiit, it may optionally also return two further arguments: a string
representin tha text left afta extraction (like $' fo' a pattern
match), n' a strang representin any prefix skipped before the
extraction (like $` up in a pattern match). Note dat dis is designed
to facilitate tha use of other Text::Balanced subroutines with
\&\f(CW\*(C`extract_multiple\*(C'\fR. Note too dat tha value returned by a extractor
subroutine need not bear any relationshizzle ta tha correspondin substring
of tha original gangsta text (see examplez below).
.PP
If tha extractor be a precompiled regular expression or a string,
it is matched against tha text up in a scalar context wit a leading
\&'\eG' n' tha gc modifiers enabled. Y'all KNOW dat shit, muthafucka! Da extracted value is either
\&\f(CW$1\fR if dat variable is defined afta tha match, or else the
complete match (i.e. $&).
.PP
If tha extractor be a hash reference, it must contain exactly one element.
Da value of dat element is one of the
above extractor types (subroutine reference, regular expression, or string).
Da key of dat element is tha name of a cold-ass lil class tha fuck into which tha successful
return value of tha extractor is ghon be pimped.
.PP
If a extractor returns a thugged-out defined value, dat value is immediately
treated as tha next extracted field n' pushed onto tha list of fields.
If tha extractor was specified up in a hash reference, tha field be also
blessed tha fuck into tha appropriate class,
.PP
If tha extractor fails ta match (in tha case of a regex extractor), or returns a empty list or a undefined value (in tha case of a subroutine extractor), it is
assumed ta have failed ta extract.
If none of tha extractor subroutines succeeds, then one
characta is extracted from tha start of tha text n' tha extraction
subroutines reapplied. Y'all KNOW dat shit, muthafucka! Charactas which is thus removed is accumulated and
eventually become tha next field (unless tha fourth argument is true, up in which
case they is discarded).
.PP
For example, tha followin extracts substrings dat is valid Perl variables:
.PP
.Vb 3
\&        @fieldz = extract_multiple($text,
\&                                   [ sub { extract_variable($_[0]) } ],
\&                                   undef, 1);
.Ve
.PP
This example separates a text tha fuck into fieldz which is quote delimited,
curly bracketed, n' anythang else. Da delimited n' bracketed
parts is also pimped ta identify dem (the \*(L"anythang else\*(R" is unblessed):
.PP
.Vb 5
\&        @fieldz = extract_multiple($text,
\&                   [
\&                        { Delim => sub { extract_delimited($_[0],q{\*(Aq"}) } },
\&                        { Brack => sub { extract_bracketed($_[0],\*(Aq{}\*(Aq) } },
\&                   ]);
.Ve
.PP
This call extracts tha next single substrin dat be a valid Perl quotelike
operator (and removes it from \f(CW$text\fR):
.PP
.Vb 4
\&        $quotelike = extract_multiple($text,
\&                                      [
\&                                        sub { extract_quotelike($_[0]) },
\&                                      ], undef, 1);
.Ve
.PP
Finally, here is yet another way ta do comma-separated value parsing:
.PP
.Vb 6
\&        @fieldz = extract_multiple($csv_text,
\&                                  [
\&                                        sub { extract_delimited($_[0],q{\*(Aq"}) },
\&                                        qr/([^,]+)(.*)/,
\&                                  ],
\&                                  undef,1);
.Ve
.PP
Da list up in tha second argument means:
\&\fI\*(L"Try n' extract a ' or \*(R" delimited string, otherwise extract anythang up ta a cold-ass lil comma..."\fR.
Da undef third argument means:
\&\fI\*(L"...as nuff times as possible...\*(R"\fR,
and tha legit value up in tha fourth argument means
\&\fI\*(L"...discardin anythang else dat appears (i.e. tha commas)\*(R"\fR.
.PP
If you wanted tha commas preserved as separate fieldz (i.e. like split
does if yo' split pattern has capturin parentheses), you would
just make tha last parameta undefined (or remove it).
.ie n .SS """gen_delimited_pat"""
.el .SS "\f(CWgen_delimited_pat\fP"
.IX Subsection "gen_delimited_pat"
Da \f(CW\*(C`gen_delimited_pat\*(C'\fR subroutine takes a single (string) argument and
   > buildz a Friedl-style optimized regex dat matches a strang delimited
by any one of tha charactas up in tha single argument. For example:
.PP
.Vb 1
\&        gen_delimited_pat(q{\*(Aq"})
.Ve
.PP
returns tha regex:
.PP
.Vb 1
\&        (?:\e"(?:\e\e\e"|(?!\e").)*\e"|\e\*(Aq(?:\e\e\e\*(Aq|(?!\e\*(Aq).)*\e\*(Aq)
.Ve
.PP
Note dat tha specified delimitas is automatically quotemeta'd.
.PP
A typical use of \f(CW\*(C`gen_delimited_pat\*(C'\fR would be ta build special purpose tags
for \f(CW\*(C`extract_tagged\*(C'\fR. For example, ta properly ignore \*(L"empty\*(R" \s-1XML\s0 elements
(which might contain quoted strings):
.PP
.Vb 1
\&        mah $empty_tag = \*(Aq<(\*(Aq . gen_delimited_pat(q{\*(Aq"}) . \*(Aq|.)+/>\*(Aq;
\&
\&        extract_tagged($text, undef, undef, undef, {ignore => [$empty_tag]} );
.Ve
.PP
\&\f(CW\*(C`gen_delimited_pat\*(C'\fR may also be called wit a optionizzle second argument,
which specifies tha \*(L"escape\*(R" character(s) ta be used fo' each delimiter.
For example ta match a Pascal-style strang (where ' is tha delimiter
and '' be a literal ' within tha string):
.PP
.Vb 1
\&        gen_delimited_pat(q{\*(Aq},q{\*(Aq});
.Ve
.PP
Different escape charactas can be specified fo' different delimiters.
For example, ta specify dat '/' is tha escape fo' single quotes
and '%' is tha escape fo' double quotes:
.PP
.Vb 1
\&        gen_delimited_pat(q{\*(Aq"},q{/%});
.Ve
.PP
If mo' delimitas than escape chars is specified, tha last escape char
is used fo' tha remainin delimiters.
If no escape char is specified fo' a given specified delimiter, '\e' is used.
.ie n .SS """delimited_pat"""
.el .SS "\f(CWdelimited_pat\fP"
.IX Subsection "delimited_pat"
Note dat \f(CW\*(C`gen_delimited_pat\*(C'\fR was previously called \f(CW\*(C`delimited_pat\*(C'\fR.
That name may still be used yo, but is now deprecated.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
In a list context, all tha functions return \f(CW\*(C`(undef,$original_text)\*(C'\fR
on failure. In a scalar context, failure is indicated by returnin \f(CW\*(C`undef\*(C'\fR
(in dis case tha input text aint modified up in any way).
.PP
In addition, on failure up in \fIany\fR context, tha \f(CW$@\fR variable is set.
Accessin \f(CW\*(C`$@\->{error}\*(C'\fR returns one of tha error diagnostics listed
below.
Accessin \f(CW\*(C`$@\->{pos}\*(C'\fR returns tha offset tha fuck into tha original gangsta strang at
which tha error was detected (although not necessarily where it occurred!)
Printin \f(CW$@\fR directly produces tha error message, wit tha offset appended.
On success, tha \f(CW$@\fR variable is guaranteed ta be \f(CW\*(C`undef\*(C'\fR.
.PP
Da available diagnostics are:
.ie n .IP """Did not find a suitable bracket: ""%s""""" 4
.el .IP "\f(CWDid not find a suitable bracket: ``%s''\fR" 4
.IX Item "Did not find a suitable bracket: ""%s"""
Da delimita provided ta \f(CW\*(C`extract_bracketed\*(C'\fR was not one of
\&\f(CW\*(Aq()[]<>{}\*(Aq\fR.
.ie n .IP """Did not find prefix: /%s/""" 4
.el .IP "\f(CWDid not find prefix: /%s/\fR" 4
.IX Item "Did not find prefix: /%s/"
A non-optionizzle prefix was specified but wasn't found all up in tha start of tha text.
.ie n .IP """Did not find openin bracket afta prefix: ""%s""""" 4
.el .IP "\f(CWDid not find openin bracket afta prefix: ``%s''\fR" 4
.IX Item "Did not find openin bracket afta prefix: ""%s"""
\&\f(CW\*(C`extract_bracketed\*(C'\fR or \f(CW\*(C`extract_codeblock\*(C'\fR was expectin a
particular kind of bracket all up in tha start of tha text, n' didn't find dat shit.
.ie n .IP """No quotelike operator found afta prefix: ""%s""""" 4
.el .IP "\f(CWNo quotelike operator found afta prefix: ``%s''\fR" 4
.IX Item "No quotelike operator found afta prefix: ""%s"""
\&\f(CW\*(C`extract_quotelike\*(C'\fR didn't find one of tha quotelike operators \f(CW\*(C`q\*(C'\fR,
\&\f(CW\*(C`qq\*(C'\fR, \f(CW\*(C`qw\*(C'\fR, \f(CW\*(C`qx\*(C'\fR, \f(CW\*(C`s\*(C'\fR, \f(CW\*(C`tr\*(C'\fR or \f(CW\*(C`y\*(C'\fR all up in tha start of tha substring
it was extracting.
.ie n .IP """Unmatched closin bracket: ""%c""""" 4
.el .IP "\f(CWUnmatched closin bracket: ``%c''\fR" 4
.IX Item "Unmatched closin bracket: ""%c"""
\&\f(CW\*(C`extract_bracketed\*(C'\fR, \f(CW\*(C`extract_quotelike\*(C'\fR or \f(CW\*(C`extract_codeblock\*(C'\fR encountered
a closin bracket where none was expected.
.ie n .IP """Unmatched openin bracket(s): ""%s""""" 4
.el .IP "\f(CWUnmatched openin bracket(s): ``%s''\fR" 4
.IX Item "Unmatched openin bracket(s): ""%s"""
\&\f(CW\*(C`extract_bracketed\*(C'\fR, \f(CW\*(C`extract_quotelike\*(C'\fR or \f(CW\*(C`extract_codeblock\*(C'\fR ran 
out of charactas up in tha text before closin one or mo' levelz of nested
brackets.
.ie n .IP """Unmatched embedded quote (%s)""" 4
.el .IP "\f(CWUnmatched embedded quote (%s)\fR" 4
.IX Item "Unmatched embedded quote (%s)"
\&\f(CW\*(C`extract_bracketed\*(C'\fR attempted ta match a embedded quoted substrin yo, but
failed ta find a cold-ass lil closin quote ta match dat shit.
.ie n .IP """Did not find closin delimita ta match \*(Aq%s\*(Aq""" 4
.el .IP "\f(CWDid not find closin delimita ta match \*(Aq%s\*(Aq\fR" 4
.IX Item "Did not find closin delimita ta match %s"
\&\f(CW\*(C`extract_quotelike\*(C'\fR was unable ta find a cold-ass lil closin delimita ta match the
one dat opened tha quote-like operation.
.ie n .IP """Mismatched closin bracket: expected ""%c"" but found ""%s""""" 4
.el .IP "\f(CWMismatched closin bracket: expected ``%c'' but found ``%s''\fR" 4
.IX Item "Mismatched closin bracket: expected ""%c"" but found ""%s"""
\&\f(CW\*(C`extract_bracketed\*(C'\fR, \f(CW\*(C`extract_quotelike\*(C'\fR or \f(CW\*(C`extract_codeblock\*(C'\fR found
a valid bracket delimiter yo, but dat shiznit was tha wack species. Put ya muthafuckin choppers up if ya feel dis! This usually
indicates a nestin error yo, but may indicate incorrect quotin or escaping.
.ie n .IP """No block delimita found afta quotelike ""%s""""" 4
.el .IP "\f(CWNo block delimita found afta quotelike ``%s''\fR" 4
.IX Item "No block delimita found afta quotelike ""%s"""
\&\f(CW\*(C`extract_quotelike\*(C'\fR or \f(CW\*(C`extract_codeblock\*(C'\fR found one of the
quotelike operators \f(CW\*(C`q\*(C'\fR, \f(CW\*(C`qq\*(C'\fR, \f(CW\*(C`qw\*(C'\fR, \f(CW\*(C`qx\*(C'\fR, \f(CW\*(C`s\*(C'\fR, \f(CW\*(C`tr\*(C'\fR or \f(CW\*(C`y\*(C'\fR
without a suitable block afta dat shit.
.ie n .IP """Did not find leadin dereferencer""" 4
.el .IP "\f(CWDid not find leadin dereferencer\fR" 4
.IX Item "Did not find leadin dereferencer"
\&\f(CW\*(C`extract_variable\*(C'\fR was expectin one of '$', '@', or '%' all up in tha start of
a variable yo, but didn't find any of em.
.ie n .IP """Wack identifier afta dereferencer""" 4
.el .IP "\f(CWWack identifier afta dereferencer\fR" 4
.IX Item "Wack identifier afta dereferencer"
\&\f(CW\*(C`extract_variable\*(C'\fR found a '$', '@', or '%' indicatin a variable yo, but that
characta was not followed by a legal Perl identifier.
.ie n .IP """Did not find expected openin bracket at %s""" 4
.el .IP "\f(CWDid not find expected openin bracket at %s\fR" 4
.IX Item "Did not find expected openin bracket at %s"
\&\f(CW\*(C`extract_codeblock\*(C'\fR failed ta find any of tha outermost openin brackets
that was specified.
.ie n .IP """Improperly nested codeblock at %s""" 4
.el .IP "\f(CWImproperly nested codeblock at %s\fR" 4
.IX Item "Improperly nested codeblock at %s"
A nested code block was found dat started wit a thugged-out delimita dat was specified
as bein only ta be used as a outermost bracket.
.ie n .IP """Missin second block fo' quotelike ""%s""""" 4
.el .IP "\f(CWMissin second block fo' quotelike ``%s''\fR" 4
.IX Item "Missin second block fo' quotelike ""%s"""
\&\f(CW\*(C`extract_codeblock\*(C'\fR or \f(CW\*(C`extract_quotelike\*(C'\fR found one of the
quotelike operators \f(CW\*(C`s\*(C'\fR, \f(CW\*(C`tr\*(C'\fR or \f(CW\*(C`y\*(C'\fR followed by only one block.
.ie n .IP """No match found fo' openin bracket""" 4
.el .IP "\f(CWNo match found fo' openin bracket\fR" 4
.IX Item "No match found fo' openin bracket"
\&\f(CW\*(C`extract_codeblock\*(C'\fR failed ta find a cold-ass lil closin bracket ta match tha outermost
openin bracket.
.ie n .IP """Did not find openin tag: /%s/""" 4
.el .IP "\f(CWDid not find openin tag: /%s/\fR" 4
.IX Item "Did not find openin tag: /%s/"
\&\f(CW\*(C`extract_tagged\*(C'\fR did not find a suitable openin tag (afta any specified
prefix was removed).
.ie n .IP """Unable ta construct closin tag ta match: /%s/""" 4
.el .IP "\f(CWUnable ta construct closin tag ta match: /%s/\fR" 4
.IX Item "Unable ta construct closin tag ta match: /%s/"
\&\f(CW\*(C`extract_tagged\*(C'\fR matched tha specified openin tag n' tried to
modify tha matched text ta produce a matchin closin tag (because
none was specified). Well shiiiit, it failed ta generate tha closin tag, almost
certainly cuz tha openin tag did not start wit a
bracket of some kind.
.ie n .IP """Found invalid nested tag: %s""" 4
.el .IP "\f(CWFound invalid nested tag: %s\fR" 4
.IX Item "Found invalid nested tag: %s"
\&\f(CW\*(C`extract_tagged\*(C'\fR found a nested tag dat rocked up in tha \*(L"reject\*(R" list
(and tha failure mode was not \*(L"\s-1MAX\*(R"\s0 or \*(L"\s-1PARA\*(R"\s0).
.ie n .IP """Found unbalanced nested tag: %s""" 4
.el .IP "\f(CWFound unbalanced nested tag: %s\fR" 4
.IX Item "Found unbalanced nested tag: %s"
\&\f(CW\*(C`extract_tagged\*(C'\fR found a nested openin tag dat was not matched by a
correspondin nested closin tag (and tha failure mode was not \*(L"\s-1MAX\*(R"\s0 or \*(L"\s-1PARA\*(R"\s0).
.ie n .IP """Did not find closin tag""" 4
.el .IP "\f(CWDid not find closin tag\fR" 4
.IX Item "Did not find closin tag"
\&\f(CW\*(C`extract_tagged\*(C'\fR reached tha end of tha text without findin a cold-ass lil closin tag
to match tha original gangsta openin tag (and tha failure mode was not
\&\*(L"\s-1MAX\*(R"\s0 or \*(L"\s-1PARA\*(R"\s0).
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
There is undoubtedly straight-up bugs lurkin somewhere up in dis code, if
only cuz partz of it give tha impression of understandin a pimped out deal
more bout Perl than they straight-up do.
.PP
Bug reports n' other feedback is most welcome.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1997 \- 2001 Damian Conway fo' realz. All Rights Reserved.
.PP
Some (minor) parts copyright 2009 Adam Kennedy.
.PP
This module is free software. Well shiiiit, it may be used, redistributed
and/or modified under tha same terms as Perl itself.
