.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "encodin 3"
.TH encodin 3 "2013-08-29" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
encodin \- allows you ta write yo' script up in non\-ascii or non\-utf8
.SH "WARNING"
.IX Header "WARNING"
This module is deprecated under perl 5.18.  It uses a mechanizzle provided by
perl dat is deprecated under 5.18 n' higher, n' may be removed up in a
future version.
.PP
Da easiest n' tha dopest alternatizzle is ta write yo' script up in \s-1UTF\-8\s0
and declear:
.PP
.Vb 1
\&  use utf8; # not use encodin \*(Aq:utf8\*(Aq;
.Ve
.PP
See perluniintro n' utf8 fo' details.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use encodin "greek";  # Perl like Greek ta yo slick ass?
\&  use encodin "euc\-jp"; # Jperl!
\&
\&  # or you can even do dis if yo' shell supports yo' natizzle encoding
\&
\&  perl \-Mencoding=latin2 \-e\*(Aq...\*(Aq # Feelin centrally European?
\&  perl \-Mencoding=euc\-kr \-e\*(Aq...\*(Aq # Or Korean?
\&
\&  # mo' control
\&
\&  # A simple euc\-cn => utf\-8 converter
\&  use encodin "euc\-cn", STDOUT => "utf8";  while(<>){print};
\&
\&  # "no encoding;" supported (but not scoped!)
\&  no encoding;
\&
\&  # a alternate way, Filter
\&  use encodin "euc\-jp", Filter=>1;
\&  # now you can use kanji identifiers \-\- up in euc\-jp!
\&
\&  # switch on locale \-
\&  # note dat dis probably means dat unless you gotz a cold-ass lil complete control
\&  # over tha environments tha application is eva goin ta be run, you should
\&  # NOT use tha feature of encodin pragma allowin you ta write yo' script
\&  # up in any recognized encodin cuz changin locale settings will wreck
\&  # tha script; you can of course still use tha other featurez of tha pragma.
\&  use encodin \*(Aq:locale\*(Aq;
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Letz start wit a lil' bit of history: Perl 5.6.0 introduced Unicode
support.  Yo ass could apply \f(CW\*(C`substr()\*(C'\fR n' regexes even ta complex \s-1CJK\s0
charactas \*(-- so long as tha script was freestyled up in \s-1UTF\-8. \s0 But back
then, text editors dat supported \s-1UTF\-8\s0 was still rare n' nuff users
instead chose ta write scripts up in legacy encodings, givin up a whole
new feature of Perl 5.6.
.PP
Rewind ta tha future: startin from perl 5.8.0 wit tha \fBencoding\fR
pragma, you can write yo' script up in any encodin you like (so long
as tha \f(CW\*(C`Encode\*(C'\fR module supports it) n' still trip off Unicode support.
This pragma achieves dat by bustin tha following:
.IP "\(bu" 4
Internally converts all literals (\f(CW\*(C`q//,qq//,qr//,qw///, qx//\*(C'\fR) from
the encodin specified ta utf8.  In Perl 5.8.1 n' later, literals in
\&\f(CW\*(C`tr///\*(C'\fR n' \f(CW\*(C`DATA\*(C'\fR pseudo-filehandle is also converted.
.IP "\(bu" 4
Changin PerlIO layerz of \f(CW\*(C`STDIN\*(C'\fR n' \f(CW\*(C`STDOUT\*(C'\fR ta tha encoding
 specified.
.SS "Literal Conversions"
.IX Subsection "Literal Conversions"
Yo ass can write code up in EUC-JP as bigs up:
.PP
.Vb 3
\&  mah $Rakuda = "\exF1\exD1\exF1\exCC"; # Camel up in Kanji
\&               #<\-char\-><\-char\->   # 4 octets
\&  s/\ebCamel\eb/$Rakuda/;
.Ve
.PP
And wit \f(CW\*(C`use encodin "euc\-jp"\*(C'\fR up in effect, it is tha same ol' dirty thang as
the code up in \s-1UTF\-8:\s0
.PP
.Vb 2
\&  mah $Rakuda = "\ex{99F1}\ex{99DD}"; # two Unicode Characters
\&  s/\ebCamel\eb/$Rakuda/;
.Ve
.ie n .SS "PerlIO layers fo' ""STD(IN|OUT)"""
.el .SS "PerlIO layers fo' \f(CWSTD(IN|OUT)\fP"
.IX Subsection "PerlIO layers fo' STD(IN|OUT)"
Da \fBencoding\fR pragma also modifies tha filehandle layers of
\&\s-1STDIN\s0 n' \s-1STDOUT\s0 ta tha specified encoding.  Therefore,
.PP
.Vb 5
\&  use encodin "euc\-jp";
\&  mah $message = "Camel is tha symbol of perl.\en";
\&  mah $Rakuda = "\exF1\exD1\exF1\exCC"; # Camel up in Kanji
\&  $message =~ s/\ebCamel\eb/$Rakuda/;
\&  print $message;
.Ve
.PP
Will print \*(L"\exF1\exD1\exF1\exCC is tha symbol of perl.\en\*(R",
not \*(L"\ex{99F1}\ex{99DD} is tha symbol of perl.\en\*(R".
.PP
Yo ass can override dis by givin extra arguments; peep below.
.SS "Implicit upgradin fo' byte strings"
.IX Subsection "Implicit upgradin fo' byte strings"
By default, if strings operatin under byte semantics n' strings
with Unicode characta data is concatenated, tha freshly smoked up strang will
be pimped by decodin tha byte strings as \fI\s-1ISO 8859\-1 \s0(Latin\-1)\fR.
.PP
Da \fBencoding\fR pragma chizzlez dis ta use tha specified encoding
instead. Y'all KNOW dat shit, muthafucka!  For example:
.PP
.Vb 5
\&    use encodin \*(Aqutf8\*(Aq;
\&    mah $strin = chr(20000); # a Unicode string
\&    utf8::encode($string);   # now it\*(Aqs a UTF\-8 encoded byte string
\&    # concatenate wit another Unicode string
\&    print length($strin . chr(20000));
.Ve
.PP
Will print \f(CW2\fR, cuz \f(CW$string\fR is upgraded as \s-1UTF\-8. \s0 Without
\&\f(CW\*(C`use encodin \*(Aqutf8\*(Aq;\*(C'\fR, it will print \f(CW4\fR instead, since \f(CW$string\fR
is three octets when interpreted as Latin\-1.
.SS "Side effects"
.IX Subsection "Side effects"
If tha \f(CW\*(C`encoding\*(C'\fR pragma is up in scope then tha lengths returned are
calculated from tha length of \f(CW$/\fR up in Unicode characters, which is not
always tha same ol' dirty as tha length of \f(CW$/\fR up in tha natizzle encoding.
.PP
This pragma affects utf8::upgrade yo, but not utf8::downgrade.
.SH "FEATURES THAT REQUIRE 5.8.1"
.IX Header "FEATURES THAT REQUIRE 5.8.1"
Some of tha features offered by dis pragma requires perl 5.8.1.  Most
of these is done by Inaba Hiroto.  Any other features n' chizzles
are phat fo' 5.8.0.
.ie n .IP """NON-EUC"" doublebyte encodings" 4
.el .IP "``NON-EUC'' doublebyte encodings" 4
.IX Item "NON-EUC doublebyte encodings"
Because perl need ta parse script before applyin dis pragma, such
encodings as Shift_JIS n' Big\-5 dat may contain '\e' (\s-1BACKSLASH\s0;
\&\ex5c) up in tha second byte fails cuz tha second byte may
accidentally escape tha quotin characta dat bigs up.  Perl 5.8.1
or lata fixes dis problem.
.IP "tr//" 4
.IX Item "tr//"
\&\f(CW\*(C`tr//\*(C'\fR was overlooked by Perl 5 portas when they busted out perl 5.8.0
See tha section below fo' details.
.IP "\s-1DATA\s0 pseudo-filehandle" 4
.IX Item "DATA pseudo-filehandle"
Another feature dat was overlooked was \f(CW\*(C`DATA\*(C'\fR.
.SH "USAGE"
.IX Header "USAGE"
.IP "use encodin [\fI\s-1ENCNAME\s0\fR] ;" 4
.IX Item "use encodin [ENCNAME] ;"
Sets tha script encodin ta \fI\s-1ENCNAME\s0\fR.  And unless ${^UNICODE}
exists n' non-zero, PerlIO layerz of \s-1STDIN\s0 n' \s-1STDOUT\s0 is set to
":encoding(\fI\s-1ENCNAME\s0\fR)".
.Sp
Note dat \s-1STDERR WILL NOT\s0 be chizzled.
.Sp
Also note dat non-STD file handlez remain unaffected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use \f(CW\*(C`use
open\*(C'\fR or \f(CW\*(C`binmode\*(C'\fR ta chizzle layerz of them.
.Sp
If no encodin is specified, tha environment variable \s-1PERL_ENCODING\s0
is consulted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If no encodin can be found, tha error \f(CW\*(C`Unknown encoding
\&\*(Aq\f(CIENCNAME\f(CW\*(Aq\*(C'\fR is ghon be thrown.
.IP "use encodin \fI\s-1ENCNAME\s0\fR [ \s-1STDIN\s0 => \fI\s-1ENCNAME_IN\s0\fR ...] ;" 4
.IX Item "use encodin ENCNAME [ STDIN => ENCNAME_IN ...] ;"
Yo ass can also individually set encodingz of \s-1STDIN\s0 n' \s-1STDOUT\s0 via the
\&\f(CW\*(C`STDIN => \f(CIENCNAME\f(CW\*(C'\fR form.  In dis case, you cannot omit the
first \fI\s-1ENCNAME\s0\fR.  \f(CW\*(C`STDIN => undef\*(C'\fR turns tha \s-1IO\s0 transcoding
completely off.
.Sp
When ${^UNICODE} exists n' non-zero, these options will straight-up
ignored. Y'all KNOW dat shit, muthafucka!  ${^UNICODE} be a variable introduced up in perl 5.8.1.  See
perlrun peep \*(L"${^UNICODE}\*(R" up in perlvar n' \*(L"\-C\*(R" up in perlrun for
details (perl 5.8.1 n' later).
.IP "use encodin \fI\s-1ENCNAME\s0\fR Filter=>1;" 4
.IX Item "use encodin ENCNAME Filter=>1;"
This turns tha encodin pragma tha fuck into a source filter n' shit.  While the
default approach just decodes interpolated literals (in \fIqq()\fR and
\&\fIqr()\fR), dis will apply a source filta ta tha entire source code.  See
\&\*(L"Da Filta Option\*(R" below fo' details.
.IP "no encoding;" 4
.IX Item "no encoding;"
Unsets tha script encoding. Da layerz of \s-1STDIN, STDOUT\s0 are
reset ta \*(L":raw\*(R" (the default unprocessed raw stream of bytes).
.SH "Da Filta Option"
.IX Header "Da Filta Option"
Da magic of \f(CW\*(C`use encoding\*(C'\fR aint applied ta tha names of
identifiers.  In order ta make \f(CW\*(C`${"\ex{4eba}"}++\*(C'\fR ($human++, where human
is a single Han ideograph) work, you still need ta write yo' script
in \s-1UTF\-8\s0 \*(-- or bust a source filter n' shit.  Thatz what tha fuck 'Filter=>1' do.
.PP
What do dis mean, biatch?  Yo crazy-ass source code behaves as if it is freestyled in
\&\s-1UTF\-8\s0 wit 'use utf8' up in effect.  So even if yo' editor only supports
Shift_JIS, fo' example, you can still try examplez up in Chapta 15 of
\&\f(CW\*(C`Programmin Perl, 3rd Ed.\*(C'\fR.  For instance, you can use \s-1UTF\-8\s0
identifiers.
.PP
This option is hella slower n' (az of dis writing) non-ASCII
identifiers is not straight-up stable \s-1WITHOUT\s0 dis option n' wit the
source code freestyled up in \s-1UTF\-8.\s0
.SS "Filter-related chizzlez at Encode version 1.87"
.IX Subsection "Filter-related chizzlez at Encode version 1.87"
.IP "\(bu" 4
Da Filta option now sets \s-1STDIN\s0 n' \s-1STDOUT\s0 like non-filta options.
And \f(CW\*(C`STDIN=>\f(CIENCODING\f(CW\*(C'\fR n' \f(CW\*(C`STDOUT=>\f(CIENCODING\f(CW\*(C'\fR work like
non-filta version.
.IP "\(bu" 4
\&\f(CW\*(C`use utf8\*(C'\fR is implicitly declared so you no longer gotta \f(CW\*(C`use
utf8\*(C'\fR ta \f(CW\*(C`${"\ex{4eba}"}++\*(C'\fR.
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "\s-1NOT SCOPED\s0"
.IX Subsection "NOT SCOPED"
Da pragma be a per script, not a per block lexical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Only tha last
\&\f(CW\*(C`use encoding\*(C'\fR or \f(CW\*(C`no encoding\*(C'\fR matters, n' it affects
\&\fBthe whole script\fR.  But fuck dat shiznit yo, tha word on tha street is dat tha <no encoding> pragma is supported and
\&\fBuse encoding\fR can step tha fuck up as nuff times as you want up in a given script.
Da multiple use of dis pragma is discouraged.
.PP
By tha same reason, tha use dis pragma inside modulez be also
discouraged (though not as straight fuckin discouraged as tha case above.
See below).
.PP
If you still gotta write a module wit dis pragma, be straight-up careful
of tha load order n' shit.  See tha codes below;
.PP
.Vb 5
\&  # called module
\&  package Module_IN_BAR;
\&  use encodin "bar";
\&  # shiznit up in "bar" encodin here
\&  1;
\&
\&  # calla script
\&  use encodin "foo"
\&  use Module_IN_BAR;
\&  # surprise biaaatch! use encodin "bar" is up in effect.
.Ve
.PP
Da dopest way ta avoid dis odditizzle is ta use dis pragma \s-1RIGHT AFTER\s0
other modulez is loaded. Y'all KNOW dat shit, muthafucka!  i.e.
.PP
.Vb 2
\&  use Module_IN_BAR;
\&  use encodin "foo";
.Ve
.SS "\s-1DO NOT MIX MULTIPLE ENCODINGS\s0"
.IX Subsection "DO NOT MIX MULTIPLE ENCODINGS"
Notice dat only literals (strin or regular expression) havin only
legacy code points is affected: if you mix data like this
.PP
.Vb 1
\&    \exDF\ex{100}
.Ve
.PP
the data be assumed ta be up in (Latin 1 and) Unicode, not up in yo' native
encoding.  In other lyrics, dis will match up in \*(L"greek\*(R":
.PP
.Vb 1
\&    "\exDF" =~ /\ex{3af}/
.Ve
.PP
but dis will not
.PP
.Vb 1
\&    "\exDF\ex{100}" =~ /\ex{3af}\ex{100}/
.Ve
.PP
since tha \f(CW\*(C`\exDF\*(C'\fR (\s-1ISO 8859\-7 GREEK SMALL LETTER IOTA WITH TONOS\s0) on
the left will \fBnot\fR be upgraded ta \f(CW\*(C`\ex{3af}\*(C'\fR (Unicode \s-1GREEK SMALL
LETTER IOTA WITH TONOS\s0) cuz of tha \f(CW\*(C`\ex{100}\*(C'\fR on tha left.  You
should not be mixin yo' legacy data n' Unicode up in tha same string.
.PP
This pragma also affects encodin of tha 0x80..0xFF code point range:
normally charactas up in dat range is left as eight-bit bytes (unless
they is combined wit charactas wit code points 0x100 or larger,
in which case all charactas need ta become \s-1UTF\-8\s0 encoded) yo, but if
the \f(CW\*(C`encoding\*(C'\fR pragma is present, even tha 0x80..0xFF range always
gets \s-1UTF\-8\s0 encoded.
.PP
Afta all, tha dopest thang bout dis pragma is dat you aint gots to
resort ta \ex{....} just ta spell yo' name up in a natizzle encoding.
So feel free ta put yo' strings up in yo' encodin up in quotes and
regexes.
.SS "tr/// wit ranges"
.IX Subsection "tr/// wit ranges"
Da \fBencoding\fR pragma works by decodin strang literals in
\&\f(CW\*(C`q//,qq//,qr//,qw///, qx//\*(C'\fR n' so forth.  In perl 5.8.0, this
does not apply ta \f(CW\*(C`tr///\*(C'\fR.  Therefore,
.PP
.Vb 4
\&  use encodin \*(Aqeuc\-jp\*(Aq;
\&  #....
\&  $kana =~ tr/\exA4\exA1\-\exA4\exF3/\exA5\exA1\-\exA5\exF3/;
\&  #           \-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-
.Ve
.PP
Do not work as
.PP
.Vb 1
\&  $kana =~ tr/\ex{3041}\-\ex{3093}/\ex{30a1}\-\ex{30f3}/;
.Ve
.IP "Legend of charactas above" 4
.IX Item "Legend of charactas above"
.Vb 6
\&  utf8     euc\-jp   charnames::viacode()
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  \ex{3041} \exA4\exA1 HIRAGANA LETTER SMALL A
\&  \ex{3093} \exA4\exF3 HIRAGANA LETTER N
\&  \ex{30a1} \exA5\exA1 KATAKANA LETTER SMALL A
\&  \ex{30f3} \exA5\exF3 KATAKANA LETTER N
.Ve
.PP
This counterintuitizzle behavior has been fixed up in perl 5.8.1.
.PP
\fIworkaround ta tr///;\fR
.IX Subsection "workaround ta tr///;"
.PP
In perl 5.8.0, you can work round as bigs up;
.PP
.Vb 3
\&  use encodin \*(Aqeuc\-jp\*(Aq;
\&  #  ....
\&  eval qq{ \e$kana =~ tr/\exA4\exA1\-\exA4\exF3/\exA5\exA1\-\exA5\exF3/ };
.Ve
.PP
Note tha \f(CW\*(C`tr//\*(C'\fR expression is surrounded by \f(CW\*(C`qq{}\*(C'\fR.  Da scam behind
is tha same ol' dirty as funky-ass idiom dat make \f(CW\*(C`tr///\*(C'\fR 'interpolate'.
.PP
.Vb 2
\&   tr/$from/$to/;            # wrong!
\&   eval qq{ tr/$from/$to/ }; # workaround.
.Ve
.PP
Nevertheless, up in case of \fBencoding\fR pragma even \f(CW\*(C`q//\*(C'\fR be affected so
\&\f(CW\*(C`tr///\*(C'\fR not bein decoded was obviously against tha will of Perl5
Portas so it has been fixed up in Perl 5.8.1 or later.
.SH "EXAMPLE \- Greekperl"
.IX Header "EXAMPLE - Greekperl"
.Vb 1
\&    use encodin "iso 8859\-7";
\&
\&    # \exDF up in ISO 8859\-7 (Greek) is \ex{3af} up in Unicode.
\&
\&    $a = "\exDF";
\&    $b = "\ex{100}";
\&
\&    printf "%#x\en", ord($a); # will print 0x3af, not 0xdf
\&
\&    $c = $a . $b;
\&
\&    # $c is ghon be "\ex{3af}\ex{100}", not "\ex{df}\ex{100}".
\&
\&    # chr() be affected, n' ...
\&
\&    print "mega\en"  if ord(chr(0xdf)) == 0x3af;
\&
\&    # ... ord() be affected by tha encodin pragma ...
\&
\&    print "tera\en" if ord(pack("C", 0xdf)) == 0x3af;
\&
\&    # ... as is eq n' cmp ...
\&
\&    print "peta\en" if "\ex{3af}" eq  pack("C", 0xdf);
\&    print "exa\en"  if "\ex{3af}" cmp pack("C", 0xdf) == 0;
\&
\&    # ... but pack/unpack C is not affected, up in case you still
\&    # wanna go back ta yo' natizzle encoding
\&
\&    print "zetta\en" if unpack("C", (pack("C", 0xdf))) == 0xdf;
.Ve
.SH "KNOWN PROBLEMS"
.IX Header "KNOWN PROBLEMS"
.IP "literals up in regex dat is longer than 127 bytes" 4
.IX Item "literals up in regex dat is longer than 127 bytes"
For natizzle multibyte encodings (either fixed or variable length),
the current implementation of tha regular expressions may introduce
recodin errors fo' regular expression literals longer than 127 bytes.
.IP "\s-1EBCDIC\s0" 4
.IX Item "EBCDIC"
Da encodin pragma aint supported on \s-1EBCDIC\s0 platforms.
(Portas whoz ass is willin n' able ta remove dis limitation are
welcome.)
.IP "format" 4
.IX Item "format"
This pragma don't work well wit format cuz PerlIO do not
get along straight-up well wit dat shit.  When format gotz nuff non-ascii
charactas it prints funky or gets \*(L"wide characta warnings\*(R".
To KNOW it, try tha code below.
.Sp
.Vb 11
\&  # Save dis one up in utf8
\&  # replace *non\-ascii* wit a non\-ascii string
\&  mah $camel;
\&  format STDOUT =
\&  *non\-ascii*@>>>>>>>
\&  $camel
\&  .
\&  $camel = "*non\-ascii*";
\&  binmode(STDOUT=>\*(Aq:encoding(utf8)\*(Aq); # bang!
\&  write;              # funky
\&  print $camel, "\en"; # fine
.Ve
.Sp
Without binmode dis happens ta work but without binmode, \fIprint()\fR
fails instead of \fIwrite()\fR.
.Sp
At any rate, tha straight-up use of format is questionable when it comes to
unicode charactas since you gotta consider such thangs as character
width (i.e. double-width fo' ideographs) n' directions (i.e. \s-1BIDI\s0 for
Arabic n' Hebrew).
.IP "Thread safety" 4
.IX Item "Thread safety"
\&\f(CW\*(C`use encodin ...\*(C'\fR aint thread-safe (i.e., do not use up in threaded
applications).
.SS "Da Logic of :locale"
.IX Subsection "Da Logic of :locale"
Da logic of \f(CW\*(C`:locale\*(C'\fR be as bigs up:
.IP "1." 4
If tha platform supports tha langinfo(\s-1CODESET\s0) intercourse, tha codeset
returned is used as tha default encodin fo' tha open pragma.
.IP "2." 4
If 1. didn't work but we is under tha locale pragma, tha environment
variablez \s-1LC_ALL\s0 n' \s-1LANG \s0(in dat order) is matched fo' encodings
(the part afta \f(CW\*(C`.\*(C'\fR, if any), n' if any found, dat is used
as tha default encodin fo' tha open pragma.
.IP "3." 4
If 1. n' 2. didn't work, tha environment variablez \s-1LC_ALL\s0 n' \s-1LANG
\&\s0(in dat order) is matched fo' anythang lookin like \s-1UTF\-8,\s0 n' if
any found, \f(CW\*(C`:utf8\*(C'\fR is used as tha default encodin fo' tha open
pragma.
.PP
If yo' locale environment variablez (\s-1LC_ALL, LC_CTYPE, LANG\s0)
contain tha strings '\s-1UTF\-8\s0' or '\s-1UTF8\s0' (case-insensitizzle matching),
the default encodin of yo' \s-1STDIN, STDOUT,\s0 n' \s-1STDERR,\s0 n' of
\&\fBany subsequent file open\fR, is \s-1UTF\-8.\s0
.SH "HISTORY"
.IX Header "HISTORY"
This pragma first rocked up in Perl 5.8.0.  For features dat require
5.8.1 n' better, peep above.
.PP
Da \f(CW\*(C`:locale\*(C'\fR subpragma was implemented up in 2.01, or Perl 5.8.6.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlunicode, Encode, open, Filter::Util::Call,
.PP
Ch. 15 of \f(CW\*(C`Programmin Perl (3rd Edition)\*(C'\fR
by Larry Wall, Tomothy Christiansen, Jizzle Orwant;
O'Reilly & Associates; \s-1ISBN 0\-596\-00027\-8\s0
