.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Encode::Guess 3"
.TH Encode::Guess 3 "2013-08-29" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Encode::Guess \-\- Guesses encodin from data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # if yo ass is shizzle $data won\*(Aqt contain anythang bogus
\&
\&  use Encode;
\&  use Encode::Guess qw/euc\-jp shiftjis 7bit\-jis/;
\&  mah $utf8 = decode("Guess", $data);
\&  mah $data = encode("Guess", $utf8);   # dis don\*(Aqt work!
\&
\&  # mo' elaborate way
\&  use Encode::Guess;
\&  mah $enc = guess_encoding($data, qw/euc\-jp shiftjis 7bit\-jis/);
\&  ref($enc) or take a thugged-out dirtnap "Can\*(Aqt guess: $enc"; # trap error dis way
\&  $utf8 = $enc\->decode($data);
\&  # or
\&  $utf8 = decode($enc\->name, $data)
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Encode::Guess enablez you ta guess up in what tha fuck encodin a given data is
encoded, or at least tries to.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
By default, it checks only ascii, utf8 n' \s-1UTF\-16/32\s0 wit \s-1BOM.\s0
.PP
.Vb 1
\&  use Encode::Guess; # ascii/utf8/BOMed UTF
.Ve
.PP
To use it mo' practically, you gotta give tha namez of encodings to
check (\fIsuspects\fR as bigs up).  Da name of suspects can either be
canonical names or aliases.
.PP
\&\s-1CAVEAT:\s0 Unlike \s-1UTF\-\s0(16|32), \s-1BOM\s0 up in utf8 is \s-1NOT AUTOMATICALLY STRIPPED.\s0
.PP
.Vb 2
\& # tries all major Japanese Encodings as well
\&  use Encode::Guess qw/euc\-jp shiftjis 7bit\-jis/;
.Ve
.PP
If tha \f(CW$Encode::Guess::NoUTFAutoGuess\fR variable is set ta a true
value, no heuristics is ghon be applied ta \s-1UTF8/16/32,\s0 n' tha result
will be limited ta tha suspects n' \f(CW\*(C`ascii\*(C'\fR.
.IP "Encode::Guess\->set_suspects" 4
.IX Item "Encode::Guess->set_suspects"
Yo ass can also chizzle tha internal suspects list via \f(CW\*(C`set_suspects\*(C'\fR
method.
.Sp
.Vb 2
\&  use Encode::Guess;
\&  Encode::Guess\->set_suspects(qw/euc\-jp shiftjis 7bit\-jis/);
.Ve
.IP "Encode::Guess\->add_suspects" 4
.IX Item "Encode::Guess->add_suspects"
Or you can use \f(CW\*(C`add_suspects\*(C'\fR method. Y'all KNOW dat shit, muthafucka!  Da difference is that
\&\f(CW\*(C`set_suspects\*(C'\fR flushes tha current suspects list while
\&\f(CW\*(C`add_suspects\*(C'\fR adds.
.Sp
.Vb 5
\&  use Encode::Guess;
\&  Encode::Guess\->add_suspects(qw/euc\-jp shiftjis 7bit\-jis/);
\&  # now tha suspects is euc\-jp,shiftjis,7bit\-jis, AND
\&  # euc\-kr,euc\-cn, n' big5\-eten
\&  Encode::Guess\->add_suspects(qw/euc\-kr euc\-cn big5\-eten/);
.Ve
.ie n .IP "Encode::decode(""Guess"" ...)" 4
.el .IP "Encode::decode(``Guess'' ...)" 4
.IX Item "Encode::decode(Guess ...)"
When yo ass is content wit suspects list, you can now
.Sp
.Vb 1
\&  mah $utf8 = Encode::decode("Guess", $data);
.Ve
.IP "Encode::Guess\->guess($data)" 4
.IX Item "Encode::Guess->guess($data)"
But it will croak if:
.RS 4
.IP "\(bu" 4
Two or mo' suspects remain
.IP "\(bu" 4
No suspects left
.RE
.RS 4
.Sp
So you should instead try this;
.Sp
.Vb 1
\&  mah $decoder = Encode::Guess\->guess($data);
.Ve
.Sp
On success, \f(CW$decoder\fR be a object dat is documented in
Encode::Encoding.  So you can now do this;
.Sp
.Vb 1
\&  mah $utf8 = $decoder\->decode($data);
.Ve
.Sp
On failure, \f(CW$decoder\fR now gotz nuff a error message so tha whole thang
would be as bigs up;
.Sp
.Vb 3
\&  mah $decoder = Encode::Guess\->guess($data);
\&  take a thugged-out dirtnap $decoder unless ref($decoder);
\&  mah $utf8 = $decoder\->decode($data);
.Ve
.RE
.IP "guess_encoding($data, [, \fIlist of suspects\fR])" 4
.IX Item "guess_encoding($data, [, list of suspects])"
Yo ass can also try \f(CW\*(C`guess_encoding\*(C'\fR function which is exported by
default.  It takes \f(CW$data\fR ta check n' it also takes tha list of
suspects by option. I aint talkin' bout chicken n' gravy biatch.  Da optionizzle suspect list is \fInot reflected\fR to
the internal suspects list.
.Sp
.Vb 5
\&  mah $decoder = guess_encoding($data, qw/euc\-jp euc\-kr euc\-cn/);
\&  take a thugged-out dirtnap $decoder unless ref($decoder);
\&  mah $utf8 = $decoder\->decode($data);
\&  # check only ascii, utf8 n' UTF\-(16|32) wit BOM
\&  mah $decoder = guess_encoding($data);
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
Because of tha algorithm used, \s-1ISO\-8859\s0 series n' other single-byte
encodings do not work well unless either one of \s-1ISO\-8859\s0 is tha only
one suspect (besides ascii n' utf8).
.Sp
.Vb 5
\&  use Encode::Guess;
\&  # like ok
\&  mah $decoder = guess_encoding($data, \*(Aqlatin1\*(Aq);
\&  # definitely NOT ok
\&  mah $decoder = guess_encoding($data, qw/latin1 greek/);
.Ve
.Sp
Da reason is dat Encode::Guess guesses encodin by trial n' error.
It first splits \f(CW$data\fR tha fuck into lines n' tries ta decode tha line fo' each
suspect.  It keeps it goin until all but one encodin is eliminated
out of suspects list.  \s-1ISO\-8859\s0 series is just too successful fo' most
cases (because it fills almost all code points up in \ex00\-\exff).
.IP "\(bu" 4
Do not mix nationistic standard encodings n' tha correspondin vendor
encodings.
.Sp
.Vb 3
\&  # a straight-up wack idea
\&  mah $decoder
\&     = guess_encoding($data, qw/shiftjis MacJapanese cp932/);
.Ve
.Sp
Da reason is dat vendor encodin is probably a superset of national
standard so it becomes too ambiguous fo' most cases.
.IP "\(bu" 4
On tha other hand, mixin various nationistic standard encodings
automagically works unless \f(CW$data\fR is too short ta allow fo' guessing.
.Sp
.Vb 6
\& # This be aiiight if $data is long enough
\& mah $decoder =  
\&  guess_encoding($data, qw/euc\-cn
\&                           euc\-jp shiftjis 7bit\-jis
\&                           euc\-kr
\&                           big5\-eten/);
.Ve
.IP "\(bu" 4
\&\s-1DO NOT PUT TOO MANY SUSPECTS\s0!  Don't you try suttin' like this!
.Sp
.Vb 2
\&  mah $decoder = guess_encoding($data, 
\&                               Encode\->encodings(":all"));
.Ve
.PP
It is, afta all, just a guess.  Yo ass should alway be explicit when it
comes ta encodings.  But there be some, especially Japanese,
environment dat guess-codin be a must.  Use dis module wit care.
.SH "TO DO"
.IX Header "TO DO"
Encode::Guess do not work on \s-1EBCDIC\s0 platforms.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode, Encode::Encoding
