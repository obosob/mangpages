.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BIO_s_connect 3"
.TH BIO_s_connect 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
BIO_s_connect, BIO_set_conn_hostname, BIO_set_conn_port,
BIO_set_conn_ip, BIO_set_conn_int_port, BIO_get_conn_hostname,
BIO_get_conn_port, BIO_get_conn_ip, BIO_get_conn_int_port,
BIO_set_nbio, BIO_do_connect \- connect BIO
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bio.h>
\&
\& BIO_METHOD * BIO_s_connect(void);
\&
\& BIO *BIO_new_connect(char *name);
\&
\& long BIO_set_conn_hostname(BIO *b, char *name);
\& long BIO_set_conn_port(BIO *b, char *port);
\& long BIO_set_conn_ip(BIO *b, char *ip);
\& long BIO_set_conn_int_port(BIO *b, char *port);
\& char *BIO_get_conn_hostname(BIO *b);
\& char *BIO_get_conn_port(BIO *b);
\& char *BIO_get_conn_ip(BIO *b, dummy);
\& long BIO_get_conn_int_port(BIO *b, int port);
\&
\& long BIO_set_nbio(BIO *b, long n);
\&
\& int BIO_do_connect(BIO *b);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIBIO_s_connect()\fR returns tha connect \s-1BIO\s0 method. Y'all KNOW dat shit, muthafucka! This be a wrapper
round tha platformz \s-1TCP/IP\s0 socket connection routines.
.PP
Usin connect BIOs, \s-1TCP/IP\s0 connections can be made n' data
transferred rockin only \s-1BIO\s0 routines. In dis way any platform
specific operations is hidden by tha \s-1BIO\s0 abstraction.
.PP
Read n' write operations on a cold-ass lil connect \s-1BIO\s0 will big-ass up I/O
on tha underlyin connection. I aint talkin' bout chicken n' gravy biatch. If no connection is established
and tha port n' hostname (see below) is set up properly then
a connection is established first.
.PP
Connect BIOs support \fIBIO_puts()\fR but not \fIBIO_gets()\fR.
.PP
If tha close flag is set on a cold-ass lil connect \s-1BIO\s0 then any active
connection is shutdown n' tha socket closed when tha \s-1BIO\s0
is freed.
.PP
Callin \fIBIO_reset()\fR on a cold-ass lil connect \s-1BIO\s0 will close any active
connection n' reset tha \s-1BIO\s0 tha fuck into a state where it can connect
to tha same host again.
.PP
\&\fIBIO_get_fd()\fR places tha underlyin socket up in \fBc\fR if it aint \s-1NULL,\s0
it also returns tha socket . If \fBc\fR aint \s-1NULL\s0 it should be of
type (int *).
.PP
\&\fIBIO_set_conn_hostname()\fR uses tha strang \fBname\fR ta set tha hostname.
Da hostname can be a \s-1IP\s0 address. Da hostname can also include the
port up in tha form hostname:port . Well shiiiit, it be also aaight ta use the
form \*(L"hostname/any/other/path\*(R" or \*(L"hostname:port/any/other/path\*(R".
.PP
\&\fIBIO_set_conn_port()\fR sets tha port ta \fBport\fR. \fBport\fR can be the
numerical form or a strang like fuckin \*(L"http\*(R" fo' realz. A strang is ghon be looked
up first rockin \fIgetservbyname()\fR on tha host platform but if that
fails a standard table of port names is ghon be used. Y'all KNOW dat shit, muthafucka! Currently the
list is http, telnet, socks, https, ssl, ftp, gopher n' wais.
.PP
\&\fIBIO_set_conn_ip()\fR sets tha \s-1IP\s0 address ta \fBip\fR rockin binary form,
that is four bytes specifyin tha \s-1IP\s0 address up in big-endian form.
.PP
\&\fIBIO_set_conn_int_port()\fR sets tha port rockin \fBport\fR. \fBport\fR should
be of type (int *).
.PP
\&\fIBIO_get_conn_hostname()\fR returns tha hostname of tha connect \s-1BIO\s0 or
\&\s-1NULL\s0 if tha \s-1BIO\s0 is initialized but no hostname is set.
This return value be a internal pointa which should not be modified.
.PP
\&\fIBIO_get_conn_port()\fR returns tha port as a string.
.PP
\&\fIBIO_get_conn_ip()\fR returns tha \s-1IP\s0 address up in binary form.
.PP
\&\fIBIO_get_conn_int_port()\fR returns tha port as a int.
.PP
\&\fIBIO_set_nbio()\fR sets tha non blockin I/O flag ta \fBn\fR. If \fBn\fR is
zero then blockin I/O is set. If \fBn\fR is 1 then non blockin I/O
is set. Blockin I/O is tha default. Da call ta \fIBIO_set_nbio()\fR
should be made before tha connection is established cuz 
non blockin I/O is set durin tha connect process.
.PP
\&\fIBIO_new_connect()\fR combines \fIBIO_new()\fR n' \fIBIO_set_conn_hostname()\fR into
a single call: dat is it creates a freshly smoked up connect \s-1BIO\s0 wit \fBname\fR.
.PP
\&\fIBIO_do_connect()\fR attempts ta connect tha supplied \s-1BIO.\s0 It returns 1
if tha connection was established successfully fo' realz. A zero or negative
value is returned if tha connection could not be established, the
call \fIBIO_should_retry()\fR should be used fo' non blockin connect BIOs
to determine if tha call should be retried.
.SH "NOTES"
.IX Header "NOTES"
If blockin I/O is set then a non positizzle return value from any
I/O call is caused by a error condition, although a zero return
will normally mean dat tha connection was closed.
.PP
If tha port name is supplied as part of tha host name then dis will
override any value set wit \fIBIO_set_conn_port()\fR. This may be undesirable
if tha application do not wish ta allow connection ta arbitrary
ports, n' you can put dat on yo' toast. This can be avoided by checkin fo' tha presence of tha ':'
characta up in tha passed hostname n' either indicatin a error or
truncatin tha strang at dat point.
.PP
Da joints returned by \fIBIO_get_conn_hostname()\fR, \fIBIO_get_conn_port()\fR,
\&\fIBIO_get_conn_ip()\fR n' \fIBIO_get_conn_int_port()\fR is updated when a
connection attempt is made. Before any connection attempt tha joints
returned is dem set by tha application itself.
.PP
Applications do not gotta call \fIBIO_do_connect()\fR but may wish ta do
so ta separate tha connection process from other I/O processing.
.PP
If non blockin I/O is set then retries is ghon be axed as appropriate.
.PP
It addizzle ta \fIBIO_should_read()\fR n' \fIBIO_should_write()\fR it be also
possible fo' \fIBIO_should_io_special()\fR ta be legit durin tha initial
connection process wit tha reason \s-1BIO_RR_CONNECT.\s0 If dis is returned
then dis be a indication dat a cold-ass lil connection attempt would block,
the application should then take appropriate action ta wait until
the underlyin socket has connected n' retry tha call.
.PP
\&\fIBIO_set_conn_hostname()\fR, \fIBIO_set_conn_port()\fR, \fIBIO_set_conn_ip()\fR,
\&\fIBIO_set_conn_int_port()\fR, \fIBIO_get_conn_hostname()\fR, \fIBIO_get_conn_port()\fR,
\&\fIBIO_get_conn_ip()\fR, \fIBIO_get_conn_int_port()\fR, \fIBIO_set_nbio()\fR and
\&\fIBIO_do_connect()\fR is macros.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIBIO_s_connect()\fR returns tha connect \s-1BIO\s0 method.
.PP
\&\fIBIO_get_fd()\fR returns tha socket or \-1 if tha \s-1BIO\s0 has not
been initialized.
.PP
\&\fIBIO_set_conn_hostname()\fR, \fIBIO_set_conn_port()\fR, \fIBIO_set_conn_ip()\fR and
\&\fIBIO_set_conn_int_port()\fR always return 1.
.PP
\&\fIBIO_get_conn_hostname()\fR returns tha connected hostname or \s-1NULL\s0 is
none was set.
.PP
\&\fIBIO_get_conn_port()\fR returns a strang representin tha connected
port or \s-1NULL\s0 if not set.
.PP
\&\fIBIO_get_conn_ip()\fR returns a pointa ta tha connected \s-1IP\s0 address in
binary form or all zeros if not set.
.PP
\&\fIBIO_get_conn_int_port()\fR returns tha connected port or 0 if none was
set.
.PP
\&\fIBIO_set_nbio()\fR always returns 1.
.PP
\&\fIBIO_do_connect()\fR returns 1 if tha connection was successfully
established n' 0 or \-1 if tha connection failed.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
This is example connects ta a webserver on tha local host n' attempts
to retrieve a page n' copy tha result ta standard output.
.PP
.Vb 10
\& BIO *cbio, *out;
\& int len;
\& char tmpbuf[1024];
\& ERR_load_crypto_strings();
\& cbio = BIO_new_connect("localhost:http");
\& up = BIO_new_fp(stdout, BIO_NOCLOSE);
\& if(BIO_do_connect(cbio) <= 0) {
\&        fprintf(stderr, "Error connectin ta server\en");
\&        ERR_print_errors_fp(stderr);
\&        /* whatever ... */
\&        }
\& BIO_puts(cbio, "GET / HTTP/1.0\en\en");
\& for(;;) {      
\&        len = BIO_read(cbio, tmpbuf, 1024);
\&        if(len <= 0) break;
\&        BIO_write(out, tmpbuf, len);
\& }
\& BIO_free(cbio);
\& BIO_free(out);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1TBA\s0
