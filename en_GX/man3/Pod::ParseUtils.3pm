.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::ParseUtils 3"
.TH Pod::ParseUtils 3 "2013-06-01" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::ParseUtils \- helpers fo' POD parsin n' conversion
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Pod::ParseUtils;
\&
\&  mah $list = freshly smoked up Pod::List;
\&  mah $link = Pod::Hyperlink\->new(\*(AqPod::Parser\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBPod::ParseUtils\fR gotz nuff all dem object-oriented helper packages for
\&\s-1POD\s0 parsin n' processin (i.e. up in \s-1POD\s0 formattas n' translators).
.SS "Pod::List"
.IX Subsection "Pod::List"
\&\fBPod::List\fR can be used ta hold shiznit bout \s-1POD\s0 lists
(written as =over ... =item ... =back) fo' further processing.
Da followin methodz is available:
.IP "Pod::List\->\fInew()\fR" 4
.IX Item "Pod::List->new()"
Smoke a freshly smoked up list object. Propertizzles may be specified all up in a hash
reference like this:
.Sp
.Vb 1
\&  mah $list = Pod::List\->new({ \-start => $., \-indent => 4 });
.Ve
.Sp
See tha individual methods/propertizzles fo' details.
.ie n .IP "$list\->\fIfile()\fR" 4
.el .IP "\f(CW$list\fR\->\fIfile()\fR" 4
.IX Item "$list->file()"
Without argument, retrieves tha file name tha list is in. I aint talkin' bout chicken n' gravy biatch. This must
have been set before by either specifyin \fB\-file\fR up in tha \fB\f(BInew()\fB\fR
method or by callin tha \fB\f(BIfile()\fB\fR method wit a scalar argument.
.ie n .IP "$list\->\fIstart()\fR" 4
.el .IP "\f(CW$list\fR\->\fIstart()\fR" 4
.IX Item "$list->start()"
Without argument, retrieves tha line number where tha list started.
This must done been set before by either specifyin \fB\-start\fR up in the
\&\fB\f(BInew()\fB\fR method or by callin tha \fB\f(BIstart()\fB\fR method wit a scalar
argument.
.ie n .IP "$list\->\fIindent()\fR" 4
.el .IP "\f(CW$list\fR\->\fIindent()\fR" 4
.IX Item "$list->indent()"
Without argument, retrieves tha indent level of tha list as specified
in \f(CW\*(C`=over n\*(C'\fR. This must done been set before by either specifying
\&\fB\-indent\fR up in tha \fB\f(BInew()\fB\fR method or by callin tha \fB\f(BIindent()\fB\fR method
with a scalar argument.
.ie n .IP "$list\->\fItype()\fR" 4
.el .IP "\f(CW$list\fR\->\fItype()\fR" 4
.IX Item "$list->type()"
Without argument, retrieves tha list type, which can be a arbitrary value,
e.g. \f(CW\*(C`OL\*(C'\fR, \f(CW\*(C`UL\*(C'\fR, ... when thankin tha \s-1HTML\s0 way.
This must done been set before by either specifying
\&\fB\-type\fR up in tha \fB\f(BInew()\fB\fR method or by callin tha \fB\f(BItype()\fB\fR method
with a scalar argument.
.ie n .IP "$list\->\fIrx()\fR" 4
.el .IP "\f(CW$list\fR\->\fIrx()\fR" 4
.IX Item "$list->rx()"
Without argument, retrieves a regular expression fo' simplifyin tha 
individual item strings once tha list type has been determined. Y'all KNOW dat shit, muthafucka! Usage:
E.g. when convertin ta \s-1HTML,\s0 one might strip tha leadin number in
an ordered list as \f(CW\*(C`<OL>\*(C'\fR already prints numbers itself.
This must done been set before by either specifying
\&\fB\-rx\fR up in tha \fB\f(BInew()\fB\fR method or by callin tha \fB\f(BIrx()\fB\fR method
with a scalar argument.
.ie n .IP "$list\->\fIitem()\fR" 4
.el .IP "\f(CW$list\fR\->\fIitem()\fR" 4
.IX Item "$list->item()"
Without argument, retrieves tha array of tha shit up in dis list.
Da shit may be represented by any scalar.
If a argument has been given, it is pushed on tha list of items.
.ie n .IP "$list\->\fIparent()\fR" 4
.el .IP "\f(CW$list\fR\->\fIparent()\fR" 4
.IX Item "$list->parent()"
Without argument, retrieves shiznit bout tha parent holdin this
list, which is represented as a arbitrary scalar.
This must done been set before by either specifying
\&\fB\-parent\fR up in tha \fB\f(BInew()\fB\fR method or by callin tha \fB\f(BIparent()\fB\fR method
with a scalar argument.
.ie n .IP "$list\->\fItag()\fR" 4
.el .IP "\f(CW$list\fR\->\fItag()\fR" 4
.IX Item "$list->tag()"
Without argument, retrieves shiznit bout tha list tag, which can be
any scalar.
This must done been set before by either specifying
\&\fB\-tag\fR up in tha \fB\f(BInew()\fB\fR method or by callin tha \fB\f(BItag()\fB\fR method
with a scalar argument.
.SS "Pod::Hyperlink"
.IX Subsection "Pod::Hyperlink"
\&\fBPod::Hyperlink\fR be a cold-ass lil class fo' manipulation of \s-1POD\s0 hyperlinks. Usage:
.PP
.Vb 1
\&  mah $link = Pod::Hyperlink\->new(\*(Aqalternatizzle text|page/"section up in page"\*(Aq);
.Ve
.PP
Da \fBPod::Hyperlink\fR class is mainly designed ta parse tha contentz of the
\&\f(CW\*(C`L<...>\*(C'\fR sequence, providin a simple intercourse fo' accessin the
different partz of a \s-1POD\s0 hyperlink fo' further processing. Well shiiiit, it can also be
used ta construct hyperlinks.
.IP "Pod::Hyperlink\->\fInew()\fR" 4
.IX Item "Pod::Hyperlink->new()"
Da \fB\f(BInew()\fB\fR method can either be passed a set of key/value pairs or a single
scalar value, namely tha contentz of a \f(CW\*(C`L<...>\*(C'\fR sequence fo' realz. An object
of tha class \f(CW\*(C`Pod::Hyperlink\*(C'\fR is returned. Y'all KNOW dat shit, muthafucka! Da value \f(CW\*(C`undef\*(C'\fR indicates a
failure, tha error message is stored up in \f(CW$@\fR.
.ie n .IP "$link\->parse($string)" 4
.el .IP "\f(CW$link\fR\->parse($string)" 4
.IX Item "$link->parse($string)"
This method can be used ta (re)parse a (new) hyperlink, i.e. tha contents
of a \f(CW\*(C`L<...>\*(C'\fR sequence. Da result is stored up in tha current object.
Warnings is stored up in tha \fBwarnings\fR property.
E.g. sections like \f(CW\*(C`L<open(2)>\*(C'\fR is deprecated, as they do not point
to Perl documents, n' you can put dat on yo' toast. \f(CW\*(C`L<DBI::foo(3p)>\*(C'\fR is wack as well, tha manpage
section can simply be dropped.
.ie n .IP "$link\->markup($string)" 4
.el .IP "\f(CW$link\fR\->markup($string)" 4
.IX Item "$link->markup($string)"
Set/retrieve tha textual value of tha link. This strang gotz nuff special
markers \f(CW\*(C`P<>\*(C'\fR n' \f(CW\*(C`Q<>\*(C'\fR dat should be expanded by the
translatorz interior sequence expansion engine ta the
formatter-specific code ta highlight/activate tha hyperlink. Da details
have ta be implemented up in tha translator.
.ie n .IP "$link\->\fItext()\fR" 4
.el .IP "\f(CW$link\fR\->\fItext()\fR" 4
.IX Item "$link->text()"
This method returns tha textual representation of tha hyperlink as above,
but without markers (read only). Dependin on tha link type dis is one of
the followin alternatives (the + n' * denote tha portionz of tha text
that is marked up):
.Sp
.Vb 4
\&  +perl+                    L<perl>
\&  *$|* up in +perlvar+         L<perlvar/$|>
\&  *OPTIONS* up in +perldoc+    L<perldoc/"OPTIONS">
\&  *DESCRIPTION*             L<"DESCRIPTION">
.Ve
.ie n .IP "$link\->\fIwarning()\fR" 4
.el .IP "\f(CW$link\fR\->\fIwarning()\fR" 4
.IX Item "$link->warning()"
Afta parsing, dis method returns any warnings encountered durin the
parsin process.
.ie n .IP "$link\->\fIfile()\fR" 4
.el .IP "\f(CW$link\fR\->\fIfile()\fR" 4
.IX Item "$link->file()"
.PD 0
.ie n .IP "$link\->\fIline()\fR" 4
.el .IP "\f(CW$link\fR\->\fIline()\fR" 4
.IX Item "$link->line()"
.PD
Just simple slots fo' storin shiznit bout tha line n' tha file
the link was encountered in. I aint talkin' bout chicken n' gravy biatch yo. Has ta be filled up in manually.
.ie n .IP "$link\->\fIpage()\fR" 4
.el .IP "\f(CW$link\fR\->\fIpage()\fR" 4
.IX Item "$link->page()"
This method sets or returns tha \s-1POD\s0 page dis link points to.
.ie n .IP "$link\->\fInode()\fR" 4
.el .IP "\f(CW$link\fR\->\fInode()\fR" 4
.IX Item "$link->node()"
As above yo, but tha destination node text of tha link.
.ie n .IP "$link\->\fIalttext()\fR" 4
.el .IP "\f(CW$link\fR\->\fIalttext()\fR" 4
.IX Item "$link->alttext()"
Sets or returns a alternatizzle text specified up in tha link.
.ie n .IP "$link\->\fItype()\fR" 4
.el .IP "\f(CW$link\fR\->\fItype()\fR" 4
.IX Item "$link->type()"
Da node type, either \f(CW\*(C`section\*(C'\fR or \f(CW\*(C`item\*(C'\fR fo' realz. As a unstraight-up legit type,
there be also \f(CW\*(C`hyperlink\*(C'\fR, derived from e.g. \f(CW\*(C`L<http://perl.com>\*(C'\fR
.ie n .IP "$link\->\fIlink()\fR" 4
.el .IP "\f(CW$link\fR\->\fIlink()\fR" 4
.IX Item "$link->link()"
Returns tha link as contentz of \f(CW\*(C`L<>\*(C'\fR. Reciprocal ta \fB\f(BIparse()\fB\fR.
.SS "Pod::Cache"
.IX Subsection "Pod::Cache"
\&\fBPod::Cache\fR holdz shiznit on some set of \s-1POD\s0 documents,
especially tha nodes fo' hyperlinks.
Da followin methodz is available:
.IP "Pod::Cache\->\fInew()\fR" 4
.IX Item "Pod::Cache->new()"
Smoke a freshly smoked up cache object. This object can hold a arbitrary number of
\&\s-1POD\s0 documentz of class Pod::Cache::Item.
.ie n .IP "$cache\->\fIitem()\fR" 4
.el .IP "\f(CW$cache\fR\->\fIitem()\fR" 4
.IX Item "$cache->item()"
Add a freshly smoked up item ta tha cache. Without arguments, dis method returns a
list of all cache elements.
.ie n .IP "$cache\->find_page($name)" 4
.el .IP "\f(CW$cache\fR\->find_page($name)" 4
.IX Item "$cache->find_page($name)"
Look fo' a \s-1POD\s0 document named \f(CW$name\fR up in tha cache. Returns the
reference ta tha correspondin Pod::Cache::Item object or undef if
not found.
.SS "Pod::Cache::Item"
.IX Subsection "Pod::Cache::Item"
\&\fBPod::Cache::Item\fR holdz shiznit bout individual \s-1POD\s0 documents,
that can be grouped up in a Pod::Cache object.
It be intended ta hold shiznit bout tha hyperlink nodez of \s-1POD\s0
documents.
Da followin methodz is available:
.IP "Pod::Cache::Item\->\fInew()\fR" 4
.IX Item "Pod::Cache::Item->new()"
Smoke a freshly smoked up object.
.ie n .IP "$cacheitem\->\fIpage()\fR" 4
.el .IP "\f(CW$cacheitem\fR\->\fIpage()\fR" 4
.IX Item "$cacheitem->page()"
Set/retrieve tha \s-1POD\s0 document name (e.g. \*(L"Pod::Parser\*(R").
.ie n .IP "$cacheitem\->\fIdescription()\fR" 4
.el .IP "\f(CW$cacheitem\fR\->\fIdescription()\fR" 4
.IX Item "$cacheitem->description()"
Set/retrieve tha \s-1POD\s0 short description as found up in tha \f(CW\*(C`=head1 NAME\*(C'\fR
section.
.ie n .IP "$cacheitem\->\fIpath()\fR" 4
.el .IP "\f(CW$cacheitem\fR\->\fIpath()\fR" 4
.IX Item "$cacheitem->path()"
Set/retrieve tha \s-1POD\s0 file storage path.
.ie n .IP "$cacheitem\->\fIfile()\fR" 4
.el .IP "\f(CW$cacheitem\fR\->\fIfile()\fR" 4
.IX Item "$cacheitem->file()"
Set/retrieve tha \s-1POD\s0 file name.
.ie n .IP "$cacheitem\->\fInodes()\fR" 4
.el .IP "\f(CW$cacheitem\fR\->\fInodes()\fR" 4
.IX Item "$cacheitem->nodes()"
Add a node (or a list of nodes) ta tha documentz node list. Note that
the order is kept, i.e. start wit tha straight-up original gangsta node n' end wit tha last.
If no argument is given, tha current list of nodes is returned up in the
same order tha nodes done been added.
A node can be any scalar yo, but probably be a pair of node strang and
unique id fo' tha \f(CW\*(C`find_node\*(C'\fR method ta work erectly.
.ie n .IP "$cacheitem\->find_node($name)" 4
.el .IP "\f(CW$cacheitem\fR\->find_node($name)" 4
.IX Item "$cacheitem->find_node($name)"
Look fo' a node or index entry named \f(CW$name\fR up in tha object.
Returns tha unique id of tha node (i.e. tha second element of tha array
stored up in tha node array) or undef if not found.
.ie n .IP "$cacheitem\->\fIidx()\fR" 4
.el .IP "\f(CW$cacheitem\fR\->\fIidx()\fR" 4
.IX Item "$cacheitem->idx()"
Add a index entry (or a list of them) ta tha documentz index list. Note that
the order is kept, i.e. start wit tha straight-up original gangsta node n' end wit tha last.
If no argument is given, tha current list of index entries is returned up in the
same order tha entries done been added.
An index entry can be any scalar yo, but probably be a pair of strang and
unique id.
.SH "AUTHOR"
.IX Header "AUTHOR"
Please report bugs rockin <http://rt.cpan.org>.
.PP
Marek Rouchal <marekr@cpan.org>, borrowing
a shitload of thangs from pod2man n' pod2roff as well as other \s-1POD\s0
processin tools by Tomothy Christiansen, Brad Appleton n' Russ Allbery.
.PP
\&\fBPod::ParseUtils\fR is part of tha Pod::Parser distribution.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
pod2man, pod2roff, Pod::Parser, Pod::Checker,
pod2html
