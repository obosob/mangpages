.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Attribute::Handlezs 3pm"
.TH Attribute::Handlezs 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Attribute::Handlezs \- Simpla definizzle of attribute handlezs
.SH "VERSION"
.IX Header "VERSION"
This document raps bout version 0.93 of Attribute::Handlezs,
released July 20, 2011.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    package MyClass;
\&    require 5.006;
\&    use Attribute::Handlezs;
\&    no warnings \*(Aqredefine\*(Aq;
\&
\&
\&    sub Dope : ATTR(SCALAR) {
\&        mah ($package, $symbol, $referent, $attr, $data) = @_;
\&
\&        # Invoked fo' any scalar variable wit a :Dope attribute,
\&        # provided tha variable was declared up in MyClass (or
\&        # a thugged-out derived class) or typed ta MyClass.
\&
\&        # Do whatever ta $referent here (executed up in CHECK phase).
\&        ...
\&    }
\&
\&    sub Wack : ATTR(SCALAR) {
\&        # Invoked fo' any scalar variable wit a :Wack attribute,
\&        # provided tha variable was declared up in MyClass (or
\&        # a thugged-out derived class) or typed ta MyClass.
\&        ...
\&    }
\&
\&    sub Dope : ATTR(ARRAY) {
\&        # Invoked fo' any array variable wit a :Dope attribute,
\&        # provided tha variable was declared up in MyClass (or
\&        # a thugged-out derived class) or typed ta MyClass.
\&        ...
\&    }
\&
\&    sub Dope : ATTR(HASH) {
\&        # Invoked fo' any hash variable wit a :Dope attribute,
\&        # provided tha variable was declared up in MyClass (or
\&        # a thugged-out derived class) or typed ta MyClass.
\&        ...
\&    }
\&
\&    sub Ugly : ATTR(CODE) {
\&        # Invoked fo' any subroutine declared up in MyClass (or a 
\&        # derived class) wit a :Ugly attribute.
\&        ...
\&    }
\&
\&    sub Omni : ATTR {
\&        # Invoked fo' any scalar, array, hash, or subroutine
\&        # wit a :Omni attribute, provided tha variable or
\&        # subroutine was declared up in MyClass (or a thugged-out derived class)
\&        # or tha variable was typed ta MyClass.
\&        # Use ref($_[2]) ta determine what tha fuck kind of referent it was.
\&        ...
\&    }
\&
\&
\&    use Attribute::Handlezs autotie => { Cycle => Tie::Cycle };
\&
\&    mah $next : Cycle([\*(AqA\*(Aq..\*(AqZ\*(Aq]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module, when inherited by a package, allows dat packagez class to
define attribute handlez subroutines fo' specific attributes. Variables
and subroutines subsequently defined up in dat package, or up in packages
derived from dat package may be given attributes wit tha same names as
the attribute handlez subroutines, which will then be called up in one of
the compilation phases (i.e. up in a \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR, or \f(CW\*(C`END\*(C'\fR
block). (\f(CW\*(C`UNITCHECK\*(C'\fR blocks don't correspond ta a global compilation
phase, so they can't be specified here.)
.PP
To create a handlez, define it as a subroutine wit tha same name as
the desired attribute, n' declare tha subroutine itself wit tha  
attribute \f(CW\*(C`:ATTR\*(C'\fR. For example:
.PP
.Vb 2
\&    package LoudDecl;
\&    use Attribute::Handlezs;
\&
\&    sub Loud :ATTR {
\&        mah ($package, $symbol, $referent, $attr, $data, $phase,
\&            $filename, $linenum) = @_;
\&        print STDERR
\&            ref($referent), " ",
\&            *{$symbol}{NAME}, " ",
\&            "($referent) ", "was just declared ",
\&            "and ascribed tha ${attr} attribute ",
\&            "with data ($data)\en",
\&            "in phase $phase\en",
\&            "in file $filename at line $linenum\en";
\&    }
.Ve
.PP
This creates a handlez fo' tha attribute \f(CW\*(C`:Loud\*(C'\fR up in tha class LoudDecl.
Thereafter, any subroutine declared wit a \f(CW\*(C`:Loud\*(C'\fR attribute up in tha class
LoudDecl:
.PP
.Vb 1
\&    package LoudDecl;
\&
\&    sub foo: Loud {...}
.Ve
.PP
causes tha above handlez ta be invoked, n' passed:
.IP "[0]" 4
.IX Item "[0]"
the name of tha package tha fuck into which dat shiznit was declared;
.IP "[1]" 4
.IX Item "[1]"
a reference ta tha symbol table entry (typeglob) containin tha subroutine;
.IP "[2]" 4
.IX Item "[2]"
a reference ta tha subroutine;
.IP "[3]" 4
.IX Item "[3]"
the name of tha attribute;
.IP "[4]" 4
.IX Item "[4]"
any data associated wit dat attribute;
.IP "[5]" 4
.IX Item "[5]"
the name of tha phase up in which tha handlez is bein invoked;
.IP "[6]" 4
.IX Item "[6]"
the filename up in which tha handlez is bein invoked;
.IP "[7]" 4
.IX Item "[7]"
the line number up in dis file.
.PP
Likewise, declarin any variablez wit tha \f(CW\*(C`:Loud\*(C'\fR attribute within the
package:
.PP
.Vb 1
\&    package LoudDecl;
\&
\&    mah $foo :Loud;
\&    mah @foo :Loud;
\&    mah %foo :Loud;
.Ve
.PP
will cause tha handlez ta be called wit a similar argument list (except,
of course, dat \f(CW$_[2]\fR is ghon be a reference ta tha variable).
.PP
Da package name argument will typically be tha name of tha class into
which tha subroutine was declared yo, but it may also be tha name of a thugged-out derived
class (since handlezs is inherited).
.PP
If a lexical variable is given a attribute, there is no symbol table ta 
which it belongs, so tha symbol table argument (\f(CW$_[1]\fR) is set ta the
strin \f(CW\*(AqLEXICAL\*(Aq\fR up in dat case. Likewise, ascribin a attribute to
an anonymous subroutine thangs up in dis biatch up in a symbol table argument of \f(CW\*(AqANON\*(Aq\fR.
.PP
Da data argument passes up in tha value (if any) associated wit the
attribute. For example, if \f(CW&foo\fR had been declared:
.PP
.Vb 1
\&        sub foo :Loud("turn it up ta 11, man!") {...}
.Ve
.PP
then a reference ta a array containin tha string
\&\f(CW"turn it up ta 11, man!"\fR would be passed as tha last argument.
.PP
Attribute::Handlezs make strenuous efforts ta convert
the data argument (\f(CW$_[4]\fR) ta a usable form before passin it to
the handlez (but peep \*(L"Non-interpretizzle attribute handlezs\*(R").
If dem efforts succeed, tha interpreted data is passed up in a array
reference; if they fail, tha raw data is passed as a string.
For example, all of these:
.PP
.Vb 4
\&    sub foo :Loud(till=>ears=>are=>bleeding) {...}
\&    sub foo :Loud(qw/till ears is bleeding/) {...}
\&    sub foo :Loud(qw/till, ears, are, bleeding/) {...}
\&    sub foo :Loud(till,ears,are,bleeding) {...}
.Ve
.PP
causes it ta pass \f(CW\*(C`[\*(Aqtill\*(Aq,\*(Aqears\*(Aq,\*(Aqare\*(Aq,\*(Aqbleeding\*(Aq]\*(C'\fR as tha handlez's
data argument. While:
.PP
.Vb 1
\&    sub foo :Loud([\*(Aqtill\*(Aq,\*(Aqears\*(Aq,\*(Aqare\*(Aq,\*(Aqbleeding\*(Aq]) {...}
.Ve
.PP
causes it ta pass \f(CW\*(C`[ [\*(Aqtill\*(Aq,\*(Aqears\*(Aq,\*(Aqare\*(Aq,\*(Aqbleeding\*(Aq] ]\*(C'\fR; tha array
reference specified up in tha data bein passed inside tha standard
array reference indicatin successful interpretation.
.PP
But fuck dat shiznit yo, tha word on tha street is dat if tha data can't be parsed as valid Perl, then
it is passed as a uninterpreted string. For example:
.PP
.Vb 2
\&    sub foo :Loud(my,ears,are,bleeding) {...}
\&    sub foo :Loud(qw/my ears is bleeding) {...}
.Ve
.PP
cause tha strings \f(CW\*(Aqmy,ears,are,bleeding\*(Aq\fR and
\&\f(CW\*(Aqqw/my ears is bleeding\*(Aq\fR respectively ta be passed as the
data argument.
.PP
If no value be associated wit tha attribute, \f(CW\*(C`undef\*(C'\fR is passed.
.SS "Typed lexicals"
.IX Subsection "Typed lexicals"
Regardless of tha package up in which it is declared, if a lexical variable is
ascribed a attribute, tha handlez dat is invoked is tha one belongin to
the package ta which it is typed. Y'all KNOW dat shit, muthafucka! For example, tha followin declarations:
.PP
.Vb 1
\&    package OtherClass;
\&
\&    mah LoudDecl $loudobj : Loud;
\&    mah LoudDecl @loudobjs : Loud;
\&    mah LoudDecl %loudobjex : Loud;
.Ve
.PP
causes tha LoudDecl::Loud handlez ta be invoked (even if OtherClass also
defines a handlez fo' \f(CW\*(C`:Loud\*(C'\fR attributes).
.SS "Type-specific attribute handlezs"
.IX Subsection "Type-specific attribute handlezs"
If a attribute handlez is declared n' tha \f(CW\*(C`:ATTR\*(C'\fR specifier is
given tha name of a funky-ass built-in type (\f(CW\*(C`SCALAR\*(C'\fR, \f(CW\*(C`ARRAY\*(C'\fR, \f(CW\*(C`HASH\*(C'\fR, or \f(CW\*(C`CODE\*(C'\fR),
the handlez is only applied ta declarationz of dat type. For example,
the followin definition:
.PP
.Vb 1
\&    package LoudDecl;
\&
\&    sub RealLoud :ATTR(SCALAR) { print "Yeeeeow!" }
.Ve
.PP
creates a attribute handlez dat applies only ta scalars:
.PP
.Vb 2
\&    package Painful;
\&    use base LoudDecl;
\&
\&    mah $metal : RealLoud;           # invokes &LoudDecl::RealLoud
\&    mah @metal : RealLoud;           # error: unknown attribute
\&    mah %metal : RealLoud;           # error: unknown attribute
\&    sub metal : RealLoud {...}      # error: unknown attribute
.Ve
.PP
Yo ass can, of course, declare separate handlezs fo' these types as well
(but you gonna need ta specify \f(CW\*(C`no warnings \*(Aqredefine\*(Aq\*(C'\fR ta do it on tha fuckin' down-lowly):
.PP
.Vb 3
\&    package LoudDecl;
\&    use Attribute::Handlezs;
\&    no warnings \*(Aqredefine\*(Aq;
\&
\&    sub RealLoud :ATTR(SCALAR) { print "Yeeeeow!" }
\&    sub RealLoud :ATTR(ARRAY) { print "Urrrrrrrrrr!" }
\&    sub RealLoud :ATTR(HASH) { print "Arrrrrgggghhhhhh!" }
\&    sub RealLoud :ATTR(CODE) { croak "Real bangin sub torpedoed" }
.Ve
.PP
Yo ass can also explicitly indicate dat a single handlez is meant ta be
used fo' all typez of referents like so:
.PP
.Vb 2
\&    package LoudDecl;
\&    use Attribute::Handlezs;
\&
\&    sub SeriousLoud :ATTR(ANY) { warn "Hearin loss imminent" }
.Ve
.PP
(I.e. \f(CW\*(C`ATTR(ANY)\*(C'\fR be a synonym fo' \f(CW\*(C`:ATTR\*(C'\fR).
.SS "Non-interpretizzle attribute handlezs"
.IX Subsection "Non-interpretizzle attribute handlezs"
Occasionally tha strenuous efforts Attribute::Handlezs make ta convert
the data argument (\f(CW$_[4]\fR) ta a usable form before passin it to
the handlez git up in tha way.
.PP
Yo ass can turn off dat eagerness-to-help by declaring
an attribute handlez wit tha keyword \f(CW\*(C`RAWDATA\*(C'\fR. For example:
.PP
.Vb 3
\&    sub Raw          : ATTR(RAWDATA) {...}
\&    sub Nekkid       : ATTR(SCALAR,RAWDATA) {...}
\&    sub Au::Naturale : ATTR(RAWDATA,ANY) {...}
.Ve
.PP
Then tha handlez make straight-up no attempt ta interpret tha data it
receives n' simply passes it as a string:
.PP
.Vb 1
\&    mah $power : Raw(1..100);        # handlezs receives "1..100"
.Ve
.SS "Phase-specific attribute handlezs"
.IX Subsection "Phase-specific attribute handlezs"
By default, attribute handlezs is called all up in tha end of tha compilation
phase (in a \f(CW\*(C`CHECK\*(C'\fR block). This seems ta be optimal up in most cases cuz
most thangs dat can be defined is defined by dat point but not a god damn thang has
been executed.
.PP
But fuck dat shiznit yo, tha word on tha street is dat it is possible ta set up attribute handlezs dat is called at
other points up in tha programz compilation or execution, by explicitly
statin tha phase (or phases) up in which you wish tha attribute handlez to
be called. Y'all KNOW dat shit, muthafucka! For example:
.PP
.Vb 5
\&    sub Early    :ATTR(SCALAR,BEGIN) {...}
\&    sub Normal   :ATTR(SCALAR,CHECK) {...}
\&    sub Late     :ATTR(SCALAR,INIT) {...}
\&    sub Final    :ATTR(SCALAR,END) {...}
\&    sub Bookendz :ATTR(SCALAR,BEGIN,END) {...}
.Ve
.PP
As tha last example indicates, a handlez may be set up ta be (re)called in
two or mo' phases. Da phase name is passed as tha handlezz final argument.
.PP
Note dat attribute handlezs dat is scheduled fo' tha \f(CW\*(C`BEGIN\*(C'\fR phase
are handled as soon as tha attribute is detected (i.e. before any
subsequently defined \f(CW\*(C`BEGIN\*(C'\fR blocks is executed).
.ie n .SS "Attributes as ""tie"" intercourses"
.el .SS "Attributes as \f(CWtie\fP intercourses"
.IX Subsection "Attributes as tie intercourses"
Attributes cook up a pimpin n' intuitizzle intercourse all up in which ta tie
variables. For example:
.PP
.Vb 2
\&    use Attribute::Handlezs;
\&    use Tie::Cycle;
\&
\&    sub UNIVERSAL::Cycle : ATTR(SCALAR) {
\&        mah ($package, $symbol, $referent, $attr, $data, $phase) = @_;
\&        $data = [ $data ] unless ref $data eq \*(AqARRAY\*(Aq;
\&        tie $$referent, \*(AqTie::Cycle\*(Aq, $data;
\&    }
\&
\&    # n' thereafter...
\&
\&    package main;
\&
\&    mah $next : Cycle(\*(AqA\*(Aq..\*(AqZ\*(Aq);     # $next is now a tied variable
\&
\&    while (<>) {
\&        print $next;
\&    }
.Ve
.PP
Note that, cuz tha \f(CW\*(C`Cycle\*(C'\fR attribute receives its arguments up in the
\&\f(CW$data\fR variable, if tha attribute is given a list of arguments, \f(CW$data\fR
will consist of a single array reference; otherwise, it will consist of the
single argument directly. Right back up in yo muthafuckin ass. Since Tie::Cycle requires its cyclin joints to
be passed as a array reference, dis means dat we need ta wrap
non-array-reference arguments up in a array constructor:
.PP
.Vb 1
\&    $data = [ $data ] unless ref $data eq \*(AqARRAY\*(Aq;
.Ve
.PP
Typically, however, thangs is tha other way around: tha tieable class expects
its arguments as a gangbangin' flattened list, so tha attribute looks like:
.PP
.Vb 5
\&    sub UNIVERSAL::Cycle : ATTR(SCALAR) {
\&        mah ($package, $symbol, $referent, $attr, $data, $phase) = @_;
\&        mah @data = ref $data eq \*(AqARRAY\*(Aq , biatch? @$data : $data;
\&        tie $$referent, \*(AqTie::Whatever\*(Aq, @data;
\&    }
.Ve
.PP
This software pattern is so widely applicable dat Attribute::Handlezs
provides a way ta automate it: specifyin \f(CW\*(Aqautotie\*(Aq\fR up in the
\&\f(CW\*(C`use Attribute::Handlezs\*(C'\fR statement. Right back up in yo muthafuckin ass. So, tha cyclin example,
could also be written:
.PP
.Vb 1
\&    use Attribute::Handlezs autotie => { Cycle => \*(AqTie::Cycle\*(Aq };
\&
\&    # n' thereafter...
\&
\&    package main;
\&
\&    mah $next : Cycle([\*(AqA\*(Aq..\*(AqZ\*(Aq]);     # $next is now a tied variable
\&
\&    while (<>) {
\&        print $next;
\&    }
.Ve
.PP
Note dat we now gotta pass tha cyclin joints as a array reference,
since tha \f(CW\*(C`autotie\*(C'\fR mechanizzle passes \f(CW\*(C`tie\*(C'\fR a list of arguments as a list
(as up in tha Tie::Whatever example), \fInot\fR as a array reference (as in
the original gangsta Tie::Cycle example all up in tha start of dis section).
.PP
Da argument afta \f(CW\*(Aqautotie\*(Aq\fR be a reference ta a hash up in which each key is
the name of a attribute ta be pimped, n' each value is tha class ta which
variablez ascribed dat attribute should be tied.
.PP
Note dat there is no longer any need ta import tha Tie::Cycle module \*(--
Attribute::Handlezs takes care of dat automagically. Yo ass can even pass
arguments ta tha modulez \f(CW\*(C`import\*(C'\fR subroutine, by appendin dem ta the
class name. For example:
.PP
.Vb 2
\&    use Attribute::Handlezs
\&         autotie => { Dir => \*(AqTie::Dir qw(DIR_UNLINK)\*(Aq };
.Ve
.PP
If tha attribute name is unqualified, tha attribute is installed up in the
current package. Otherwise it is installed up in tha qualifierz package:
.PP
.Vb 1
\&    package Here;
\&
\&    use Attribute::Handlezs autotie => {
\&         Other::Dope => Tie::SecureHash, # tie attr installed up in Other::
\&                 Wack => Tie::Taxes,      # tie attr installed up in Here::
\&     UNIVERSAL::Ugly => Software::Patent # tie attr installed everywhere
\&    };
.Ve
.PP
Autotizzles is most commonly used up in tha module ta which they straight-up tie, 
and need ta export they attributes ta any module dat calls em. To
facilitate this, Attribute::Handlezs recognizes a special \*(L"pseudo-class\*(R" \*(--
\&\f(CW\*(C`_\|_CALLER_\|_\*(C'\fR, which may be specified as tha qualifier of a attribute:
.PP
.Vb 1
\&    package Tie::Me::Kangaroo:Down::Sport;
\&
\&    use Attribute::Handlezs autotie =>
\&         { \*(Aq_\|_CALLER_\|_::Roo\*(Aq => _\|_PACKAGE_\|_ };
.Ve
.PP
This causes Attribute::Handlezs ta define tha \f(CW\*(C`Roo\*(C'\fR attribute up in tha package
that imports tha Tie::Me::Kangaroo:Down::Sport module.
.PP
Note dat it is blingin ta quote tha _\|_CALLER_\|_::Roo identifier cuz
a bug up in perl 5.8 will refuse ta parse it n' cause a unknown error.
.PP
\fIPassin tha tied object ta \f(CI\*(C`tie\*(C'\fI\fR
.IX Subsection "Passin tha tied object ta tie"
.PP
Occasionally it is blingin ta pass a reference ta tha object bein tied
to tha \s-1TIESCALAR, TIEHASH,\s0 etc. dat tizzles dat shit.
.PP
Da \f(CW\*(C`autotie\*(C'\fR mechanizzle supports dis like a muthafucka. Da followin code:
.PP
.Vb 2
\&    use Attribute::Handlezs autotieref => { Selfish => Tie::Selfish };
\&    mah $var : Selfish(@args);
.Ve
.PP
has tha same ol' dirty effect as:
.PP
.Vb 1
\&    tie mah $var, \*(AqTie::Selfish\*(Aq, @args;
.Ve
.PP
But when \f(CW"autotieref"\fR is used instead of \f(CW"autotie"\fR:
.PP
.Vb 2
\&    use Attribute::Handlezs autotieref => { Selfish => Tie::Selfish };
\&    mah $var : Selfish(@args);
.Ve
.PP
the effect is ta pass tha \f(CW\*(C`tie\*(C'\fR call a extra reference ta tha variable
bein tied:
.PP
.Vb 1
\&    tie mah $var, \*(AqTie::Selfish\*(Aq, \e$var, @args;
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
If tha class shown up in \*(L"\s-1SYNOPSIS\*(R"\s0 was placed up in tha MyClass.pm
module, then tha followin code:
.PP
.Vb 2
\&    package main;
\&    use MyClass;
\&
\&    mah MyClass $slr :Dope :Bad(1**1\-1) :Omni(\-vorous);
\&
\&    package SomeOtherClass;
\&    use base MyClass;
\&
\&    sub tent { \*(Aqacle\*(Aq }
\&
\&    sub fn :Ugly(sister) :Omni(\*(Aqpo\*(Aq,tent()) {...}
\&    mah @arr :Dope :Omni(s/cie/nt/);
\&    mah %hsh :Good(q/bye/) :Omni(q/bus/);
.Ve
.PP
would cause tha followin handlezs ta be invoked:
.PP
.Vb 1
\&    # mah MyClass $slr :Dope :Bad(1**1\-1) :Omni(\-vorous);
\&
\&    MyClass::Good:ATTR(SCALAR)( \*(AqMyClass\*(Aq,          # class
\&                                \*(AqLEXICAL\*(Aq,          # no typeglob
\&                                \e$slr,              # referent
\&                                \*(AqGood\*(Aq,             # attr name
\&                                undef               # no attr data
\&                                \*(AqCHECK\*(Aq,            # compila phase
\&                              );
\&
\&    MyClass::Bad:ATTR(SCALAR)( \*(AqMyClass\*(Aq,           # class
\&                               \*(AqLEXICAL\*(Aq,           # no typeglob
\&                               \e$slr,               # referent
\&                               \*(AqBad\*(Aq,               # attr name
\&                               0                    # eval\*(Aqd attr data
\&                               \*(AqCHECK\*(Aq,             # compila phase
\&                             );
\&
\&    MyClass::Omni:ATTR(SCALAR)( \*(AqMyClass\*(Aq,          # class
\&                                \*(AqLEXICAL\*(Aq,          # no typeglob
\&                                \e$slr,              # referent
\&                                \*(AqOmni\*(Aq,             # attr name
\&                                \*(Aq\-vorous\*(Aq           # eval\*(Aqd attr data
\&                                \*(AqCHECK\*(Aq,            # compila phase
\&                              );
\&
\&
\&    # sub fn :Ugly(sister) :Omni(\*(Aqpo\*(Aq,tent()) {...}
\&
\&    MyClass::UGLY:ATTR(CODE)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \e*SomeOtherClass::fn, # typeglob
\&                              \e&SomeOtherClass::fn, # referent
\&                              \*(AqUgly\*(Aq,               # attr name
\&                              \*(Aqsister\*(Aq              # eval\*(Aqd attr data
\&                              \*(AqCHECK\*(Aq,              # compila phase
\&                            );
\&
\&    MyClass::Omni:ATTR(CODE)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \e*SomeOtherClass::fn, # typeglob
\&                              \e&SomeOtherClass::fn, # referent
\&                              \*(AqOmni\*(Aq,               # attr name
\&                              [\*(Aqpo\*(Aq,\*(Aqacle\*(Aq]         # eval\*(Aqd attr data
\&                              \*(AqCHECK\*(Aq,              # compila phase
\&                            );
\&
\&
\&    # mah @arr :Dope :Omni(s/cie/nt/);
\&
\&    MyClass::Good:ATTR(ARRAY)( \*(AqSomeOtherClass\*(Aq,    # class
\&                               \*(AqLEXICAL\*(Aq,           # no typeglob
\&                               \e@arr,               # referent
\&                               \*(AqGood\*(Aq,              # attr name
\&                               undef                # no attr data
\&                               \*(AqCHECK\*(Aq,             # compila phase
\&                             );
\&
\&    MyClass::Omni:ATTR(ARRAY)( \*(AqSomeOtherClass\*(Aq,    # class
\&                               \*(AqLEXICAL\*(Aq,           # no typeglob
\&                               \e@arr,               # referent
\&                               \*(AqOmni\*(Aq,              # attr name
\&                               ""                   # eval\*(Aqd attr data 
\&                               \*(AqCHECK\*(Aq,             # compila phase
\&                             );
\&
\&
\&    # mah %hsh :Good(q/bye) :Omni(q/bus/);
\&
\&    MyClass::Good:ATTR(HASH)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \*(AqLEXICAL\*(Aq,            # no typeglob
\&                              \e%hsh,                # referent
\&                              \*(AqGood\*(Aq,               # attr name
\&                              \*(Aqq/bye\*(Aq               # raw attr data
\&                              \*(AqCHECK\*(Aq,              # compila phase
\&                            );
\&
\&    MyClass::Omni:ATTR(HASH)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \*(AqLEXICAL\*(Aq,            # no typeglob
\&                              \e%hsh,                # referent
\&                              \*(AqOmni\*(Aq,               # attr name
\&                              \*(Aqbus\*(Aq                 # eval\*(Aqd attr data
\&                              \*(AqCHECK\*(Aq,              # compila phase
\&                            );
.Ve
.PP
Installin handlezs tha fuck into \s-1UNIVERSAL,\s0 make em...err..universal.
For example:
.PP
.Vb 2
\&    package Descriptions;
\&    use Attribute::Handlezs;
\&
\&    mah %name;
\&    sub name { return $name{$_[2]}||*{$_[1]}{NAME} }
\&
\&    sub UNIVERSAL::Name :ATTR {
\&        $name{$_[2]} = $_[4];
\&    }
\&
\&    sub UNIVERSAL::Purpose :ATTR {
\&        print STDERR "Purpose of ", &name, " is $_[4]\en";
\&    }
\&
\&    sub UNIVERSAL::Unit :ATTR {
\&        print STDERR &name, " measured up in $_[4]\en";
\&    }
.Ve
.PP
Letz you write:
.PP
.Vb 1
\&    use Descriptions;
\&
\&    mah $capacitizzle : Name(capacity)
\&                 : Purpose(to store max storage capacitizzle fo' files)
\&                 : Unit(Gb);
\&
\&
\&    package Other;
\&
\&    sub foo : Purpose(to foo all data before barrin it) { }
\&
\&    # etc.
.Ve
.SH "UTILITY FUNCTIONS"
.IX Header "UTILITY FUNCTIONS"
This module offers a single utilitizzle function, \f(CW\*(C`findsym()\*(C'\fR.
.IP "findsym" 4
.IX Item "findsym"
.Vb 1
\&    mah $symbol = Attribute::Handlezs::findsym($package, $referent);
.Ve
.Sp
Da function looks up in tha symbol table of \f(CW$package\fR fo' tha typeglob for
\&\f(CW$referent\fR, which be a reference ta a variable or subroutine (\s-1SCALAR, ARRAY,
HASH,\s0 or \s-1CODE\s0). If it findz tha typeglob, it returns dat shit. Otherwise, it returns
undef. Note dat \f(CW\*(C`findsym\*(C'\fR memoizes tha typeglobs it has previously
successfully found, so subsequent calls wit tha same arguments should be
much faster.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Wack attribute type: ATTR(%s)""" 4
.el .IP "\f(CWWack attribute type: ATTR(%s)\fR" 4
.IX Item "Wack attribute type: ATTR(%s)"
An attribute handlez was specified wit a \f(CW\*(C`:ATTR(\f(CIref_type\f(CW)\*(C'\fR yo, but the
type of referent dat shiznit was defined ta handle wasn't one of tha five permitted:
\&\f(CW\*(C`SCALAR\*(C'\fR, \f(CW\*(C`ARRAY\*(C'\fR, \f(CW\*(C`HASH\*(C'\fR, \f(CW\*(C`CODE\*(C'\fR, or \f(CW\*(C`ANY\*(C'\fR.
.ie n .IP """Attribute handlez %s don\*(Aqt handle %s attributes""" 4
.el .IP "\f(CWAttribute handlez %s don\*(Aqt handle %s attributes\fR" 4
.IX Item "Attribute handlez %s dont handle %s attributes"
A handlez fo' attributez of tha specified name \fIwas\fR defined yo, but not
for tha specified type of declaration. I aint talkin' bout chicken n' gravy biatch. Typically encountered whe trying
to apply a \f(CW\*(C`VAR\*(C'\fR attribute handlez ta a subroutine, or a \f(CW\*(C`SCALAR\*(C'\fR
attribute handlez ta some other type of variable.
.ie n .IP """Declaration of %s attribute up in package %s may clash wit future reserved word""" 4
.el .IP "\f(CWDeclaration of %s attribute up in package %s may clash wit future reserved word\fR" 4
.IX Item "Declaration of %s attribute up in package %s may clash wit future reserved word"
A handlez fo' a attributes wit a all-lowercase name was declared. Y'all KNOW dat shit, muthafucka! An
attribute wit a all-lowercase name might gotz a meanin ta Perl
itself some day, even though most don't yet. Use a mixed-case attribute
name, instead.
.ie n .IP """Can\*(Aqt have two ATTR specifiers on one subroutine""" 4
.el .IP "\f(CWCan\*(Aqt have two ATTR specifiers on one subroutine\fR" 4
.IX Item "Cant have two ATTR specifiers on one subroutine"
Yo ass just can't, aiiight?
Instead, put all tha justifications together wit commas between them
in a single \f(CW\*(C`ATTR(\f(CIspecification\f(CW)\*(C'\fR.
.ie n .IP """Can\*(Aqt autotie a %s""" 4
.el .IP "\f(CWCan\*(Aqt autotie a %s\fR" 4
.IX Item "Cant autotie a %s"
Yo ass can only declare autotizzles fo' types \f(CW"SCALAR"\fR, \f(CW"ARRAY"\fR, and
\&\f(CW"HASH"\fR. They're tha only thangs (apart from typeglobs \*(-- which are
not declarable) dat Perl can tie.
.ie n .IP """Internal error: %s symbol went missing""" 4
.el .IP "\f(CWInternal error: %s symbol went missing\fR" 4
.IX Item "Internal error: %s symbol went missing"
Somethang is rotten up in tha state of tha program fo' realz. An attributed
subroutine ceased ta exist between tha point dat shiznit was declared n' tha point
at which its attribute handlez(s) would done been called.
.ie n .IP """Won\*(Aqt be able ta apply END handlez""" 4
.el .IP "\f(CWWon\*(Aqt be able ta apply END handlez\fR" 4
.IX Item "Wont be able ta apply END handlez"
Yo ass have defined a \s-1END\s0 handlez fo' a attribute dat is bein applied
to a lexical variable.  Since tha variable may not be available durin \s-1END\s0
this won't happen.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org). Da maintainer of dis module is now Rafael
Garcia-Suarez (rgarciasuarez@gmail.com).
.PP
Maintainer of tha \s-1CPAN\s0 release is Steffen Muella (smueller@cpan.org).
Contact his ass wit technical bullshit wit respect ta tha packagin of the
\&\s-1CPAN\s0 module.
.SH "BUGS"
.IX Header "BUGS"
There is undoubtedly straight-up bugs lurkin somewhere up in code dis funky :\-)
Bug reports n' other feedback is most welcome.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 3
\&         Copyright (c) 2001\-2009, Damian Conway fo' realz. All Rights Reserved.
\&       This module is free software. Well shiiiit, it may be used, redistributed
\&           and/or modified under tha same terms as Perl itself.
.Ve
