.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MIME::Entitizzle 3"
.TH MIME::Entitizzle 3 "2013-11-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME::Entitizzle \- class fo' parsed\-and\-decoded MIME message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Before readin further, you should peep MIME::Tools ta make shizzle that
you KNOW where dis module fits tha fuck into tha grand scheme of thangs.
Go on, do it now, nahmeean, biatch?  I be bout ta wait.
.PP
Ready, biatch?  Ok...
.PP
.Vb 5
\&    ### Smoke a entity:
\&    $top = MIME::Entity\->build(From    => \*(Aqme@myhost.com\*(Aq,
\&                               To      => \*(Aqyou@yourhost.com\*(Aq,
\&                               Subject => "Yo muthafucka, nurse!",
\&                               Data    => \e@my_message);
\&
\&    ### Attach shiznit ta it:
\&    $top\->attach(Path     => $gif_path,
\&                 Type     => "image/gif",
\&                 Encodin => "base64");
\&
\&    ### Sign it:
\&    $top\->sign;
\&
\&    ### Output it:
\&    $top\->print(\e*STDOUT);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A subclass of \fBMail::Internet\fR.
.PP
This package serves up a cold-ass lil class fo' representin \s-1MIME\s0 message entities,
as specified up in RFCs 2045, 2046, 2047, 2048 n' 2049.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Construction examples"
.IX Subsection "Construction examples"
Smoke a thugged-out document fo' a ordinary 7\-bit \s-1ASCII\s0 text file (lots of
shiznit is defaulted fo' us):
.PP
.Vb 1
\&    $ent = MIME::Entity\->build(Path=>"english\-msg.txt");
.Ve
.PP
Smoke a thugged-out document fo' a text file wit 8\-bit (Latin\-1) characters:
.PP
.Vb 4
\&    $ent = MIME::Entity\->build(Path     =>"french\-msg.txt",
\&                               Encodin =>"quoted\-printable",
\&                               From     =>\*(Aqjean.luc@inria.fr\*(Aq,
\&                               Subject  =>"C\*(Aqest bon!");
.Ve
.PP
Smoke a thugged-out document fo' a \s-1GIF\s0 file (the description is straight-up optional;
note dat we gotta specify content-type n' encodin since they're
not tha default joints):
.PP
.Vb 4
\&    $ent = MIME::Entity\->build(Description => "A pretty picture",
\&                               Path        => "./docs/mime\-sm.gif",
\&                               Type        => "image/gif",
\&                               Encodin    => "base64");
.Ve
.PP
Smoke a thugged-out document dat you already have tha text for, rockin \*(L"Data\*(R":
.PP
.Vb 5
\&    $ent = MIME::Entity\->build(Type        => "text/plain",
\&                               Encodin    => "quoted\-printable",
\&                               Data        => ["First line.\en",
\&                                              "Second line.\en",
\&                                              "Last line.\en"]);
.Ve
.PP
Smoke a multipart message, wit tha entire structure given
explicitly:
.PP
.Vb 5
\&    ### Smoke tha top\-level, n' set up tha mail headers:
\&    $top = MIME::Entity\->build(Type     => "multipart/mixed",
\&                               From     => \*(Aqme@myhost.com\*(Aq,
\&                               To       => \*(Aqyou@yourhost.com\*(Aq,
\&                               Subject  => "Yo muthafucka, nurse!");
\&
\&    ### Attachment #1: a simple text document:
\&    $top\->attach(Path=>"./testin/short.txt");
\&
\&    ### Attachment #2: a GIF file:
\&    $top\->attach(Path        => "./docs/mime\-sm.gif",
\&                 Type        => "image/gif",
\&                 Encodin    => "base64");
\&
\&    ### Attachment #3: text we\*(Aqll create wit text our crazy asses have on\-hand:
\&    $top\->attach(Data => $contents);
.Ve
.PP
Suppose you don't give a fuck ahead of time dat you gonna have attachments?
No problem: you can \*(L"attach\*(R" ta singleparts as well:
.PP
.Vb 8
\&    $top = MIME::Entity\->build(From    => \*(Aqme@myhost.com\*(Aq,
\&                               To      => \*(Aqyou@yourhost.com\*(Aq,
\&                               Subject => "Yo muthafucka, nurse!",
\&                               Data    => \e@my_message);
\&    if ($GIF_path) {
\&        $top\->attach(Path     => $GIF_path,
\&                     Type     => \*(Aqimage/gif\*(Aq);
\&    }
.Ve
.PP
Copy a entitizzle (headers, parts... every last muthafuckin thang but external body data):
.PP
.Vb 1
\&    mah $deepcopy = $top\->dup;
.Ve
.SS "Access examples"
.IX Subsection "Access examples"
.Vb 2
\&    ### Git tha head, a MIME::Head:
\&    $head = $ent\->head;
\&
\&    ### Git tha body, as a MIME::Body;
\&    $bodyh = $ent\->bodyhandle;
\&
\&    ### Git tha intended MIME type (as declared up in tha header):
\&    $type = $ent\->mime_type;
\&
\&    ### Git tha effectizzle MIME type (in case decodin failed):
\&    $eff_type = $ent\->effective_type;
\&
\&    ### Git preamble, parts, n' epilogue:
\&    $preamble   = $ent\->preamble;          ### ref ta array of lines
\&    $num_parts  = $ent\->parts;
\&    $first_part = $ent\->parts(0);          ### a entity
\&    $epilogue   = $ent\->epilogue;          ### ref ta array of lines
.Ve
.SS "Manipulation examples"
.IX Subsection "Manipulation examples"
Muck bout wit tha body data:
.PP
.Vb 5
\&    ### Read tha (unencoded) body data:
\&    if ($io = $ent\->open("r")) {
\&        while (defined($_ = $io\->getline)) { print $_ }
\&        $io\->close;
\&    }
\&
\&    ### Write tha (unencoded) body data:
\&    if ($io = $ent\->open("w")) {
\&        foreach (@lines) { $io\->print($_) }
\&        $io\->close;
\&    }
\&
\&    ### Delete tha filez fo' any external (on\-disk) data:
\&    $ent\->purge;
.Ve
.PP
Muck bout wit tha signature:
.PP
.Vb 2
\&    ### Sign it (automatically removes any existin signature):
\&    $top\->sign(File=>"$ENV{HOME}/.signature");
\&
\&    ### Remove any signature within 15 linez of tha end:
\&    $top\->remove_sig(15);
.Ve
.PP
Muck bout wit tha headers:
.PP
.Vb 3
\&    ### Compute content\-lengths fo' singleparts based on bodies:
\&    ###   (Do dis right before you print!)
\&    $entity\->sync_headers(Length=>\*(AqCOMPUTE\*(Aq);
.Ve
.PP
Muck bout wit tha structure:
.PP
.Vb 2
\&    ### If a 0\- or 1\-part multipart, collapse ta a singlepart:
\&    $top\->make_singlepart;
\&
\&    ### If a singlepart, inflate ta a multipart wit 1 part:
\&    $top\->make_multipart;
.Ve
.PP
Delete parts:
.PP
.Vb 3
\&    ### Delete some partz of a multipart message:
\&    mah @keep = grep { keep_part($_) } $msg\->parts;
\&    $msg\->parts(\e@keep);
.Ve
.SS "Output examples"
.IX Subsection "Output examples"
Print ta filehandles:
.PP
.Vb 2
\&    ### Print tha entire message:
\&    $top\->print(\e*STDOUT);
\&
\&    ### Print just tha header:
\&    $top\->print_header(\e*STDOUT);
\&
\&    ### Print just tha (encoded) body... includes parts as well!
\&    $top\->print_body(\e*STDOUT);
.Ve
.PP
Stringify... note dat \f(CW\*(C`stringify_xx\*(C'\fR can also be freestyled \f(CW\*(C`xx_as_string\*(C'\fR;
the methodz is synonymous, n' neither form is ghon be deprecated:
.PP
.Vb 2
\&    ### Stringify tha entire message:
\&    print $top\->stringify;              ### or $top\->as_string
\&
\&    ### Stringify just tha header:
\&    print $top\->stringify_header;       ### or $top\->header_as_string
\&
\&    ### Stringify just tha (encoded) body... includes parts as well!
\&    print $top\->stringify_body;         ### or $top\->body_as_string
.Ve
.PP
Debug:
.PP
.Vb 2
\&    ### Output debuggin info:
\&    $entity\->dump_skeleton(\e*STDERR);
.Ve
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
.SS "Construction"
.IX Subsection "Construction"
.IP "new [\s-1SOURCE\s0]" 4
.IX Item "new [SOURCE]"
\&\fIClass method.\fR
Smoke a new, empty \s-1MIME\s0 entity.
Basically, dis uses tha Mail::Internizzle constructor...
.Sp
If \s-1SOURCE\s0 be a \s-1ARRAYREF,\s0 it be assumed ta be a array of lines
that is ghon be used ta create both tha header n' a in-core body.
.Sp
Else, if \s-1SOURCE\s0 is defined, it be assumed ta be a gangbangin' filehandle
from which tha header n' in-core body is ta be read.
.Sp
\&\fBNote:\fR up in either case, tha body aint gonna be \fIparsed:\fR merely read!
.IP "add_part \s-1ENTITY,\s0 [\s-1OFFSET\s0]" 4
.IX Item "add_part ENTITY, [OFFSET]"
\&\fIInstizzle method.\fR
Assumin we is a multipart message, add a funky-ass body part (a MIME::Entity)
to tha array of body parts, n' you can put dat on yo' toast.  Returns tha part dat was just added.
.Sp
If \s-1OFFSET\s0 is positive, tha freshly smoked up part be added at dat offset from the
beginnin of tha array of parts, n' you can put dat on yo' toast.  If it is negative, it counts from
the end of tha array.  (An \s-1INDEX\s0 of \-1 will place tha freshly smoked up part at the
very end of tha array, \-2 will place it as tha penillest item up in the
array, etc.)  If \s-1OFFSET\s0 aint given, tha freshly smoked up part be added ta tha end
of tha array.
\&\fIThanks ta Jizzo L Tibbitts \s-1III\s0 fo' providin support fo' \s-1OFFSET.\s0\fR
.Sp
\&\fBWarning:\fR up in general, you only wanna attach parts ta entities
with a cold-ass lil content-type of \f(CW\*(C`multipart/*\*(C'\fR).
.IP "attach \s-1PARAMHASH\s0" 4
.IX Item "attach PARAMHASH"
\&\fIInstizzle method.\fR
Da real quick-and-easy way ta create multipart lyrics.
Da \s-1PARAMHASH\s0 is used ta \f(CW\*(C`build\*(C'\fR a freshly smoked up entity; dis method is
basically equivalent to:
.Sp
.Vb 1
\&    $entity\->add_part(ref($entity)\->build(PARAMHASH, Top=>0));
.Ve
.Sp
\&\fBNote:\fR normally, you attach ta multipart entities; however, if you
attach suttin' ta a singlepart (like attachin a \s-1GIF\s0 ta a text
message), tha singlepart is ghon be coerced tha fuck into a multipart automatically.
.IP "build \s-1PARAMHASH\s0" 4
.IX Item "build PARAMHASH"
\&\fIClass/instizzle method.\fR
A quick-and-easy catch-all way ta create a entity.  Use it like this
to build a \*(L"normal\*(R" single-part entity:
.Sp
.Vb 5
\&   $ent = MIME::Entity\->build(Type     => "image/gif",
\&                              Encodin => "base64",
\&                              Path     => "/path/to/xyz12345.gif",
\&                              Filename => "saveme.gif",
\&                              Disposizzle => "attachment");
.Ve
.Sp
And like dis ta build a \*(L"multipart\*(R" entity:
.Sp
.Vb 2
\&   $ent = MIME::Entity\->build(Type     => "multipart/mixed",
\&                              Boundary => "\-\-\-1234567");
.Ve
.Sp
A minimal \s-1MIME\s0 header is ghon be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If you wanna add or modify
any header fieldz afterwards, you can of course do so via tha underlying
head object... but hey, there be a now a prettier syntax!
.Sp
.Vb 6
\&   $ent = MIME::Entity\->build(Type          =>"multipart/mixed",
\&                              From          => $myaddr,
\&                              Subject       => "Hi!",
\&                              \*(AqX\-Certified\*(Aq => [\*(AqSINED\*(Aq,
\&                                                \*(AqSEELED\*(Aq,
\&                                                \*(AqDELIVERED\*(Aq]);
.Ve
.Sp
Normally, a \f(CW\*(C`X\-Mailer\*(C'\fR header field is output which gotz nuff this
toolkitz name n' version (plus dis modulez \s-1RCS\s0 version).
This will allow any wack \s-1MIME\s0 we generate ta be traced back ta us.
Yo ass can of course overwrite dat header wit yo' own:
.Sp
.Vb 2
\&   $ent = MIME::Entity\->build(Type        => "multipart/mixed",
\&                              \*(AqX\-Mailer\*(Aq  => "myprog 1.1");
.Ve
.Sp
Or remove it entirely:
.Sp
.Vb 2
\&   $ent = MIME::Entity\->build(Type       => "multipart/mixed",
\&                              \*(AqX\-Mailer\*(Aq => undef);
.Ve
.Sp
\&\s-1OK,\s0 enough hype.  Da parametas are:
.RS 4
.IP "(\s-1FIELDNAME\s0)" 4
.IX Item "(FIELDNAME)"
Any field you want placed up in tha message header, taken from the
standard list of header fieldz (you don't need ta worry bout case):
.Sp
.Vb 6
\&    Bcc           Encrypted     Received      Sender
\&    Cc            From          References    Subject
\&    Comments      Keywordz      Reply\-To      To
\&    Content\-*     Message\-ID    Resent\-*      X\-*
\&    Date          MIME\-Version  Return\-Path
\&                  Organization
.Ve
.Sp
To give experienced playas some veto power, these fieldz is ghon be set
\&\fIafter\fR tha ones I set... so be careful: \fIdon't set any \s-1MIME\s0 fields\fR
(like \f(CW\*(C`Content\-type\*(C'\fR) unless you know what tha fuck you bustin!
.Sp
To specify a gangbangin' fieldname thatz \fInot\fR up in tha above list, even one that's
identical ta a option below, just give it wit a trailin \f(CW":"\fR,
like \f(CW"My\-field:"\fR.  When up in doubt, dat \fIalways\fR signals a mail
field (and it sort of be lookin like one too).
.IP "Boundary" 4
.IX Item "Boundary"
\&\fIMultipart entitizzles only. Optional.\fR
Da boundary string.  As per \s-1RFC\-2046,\s0 it must consist only
of tha charactas \f(CW\*(C`[0\-9a\-zA\-Z\*(Aq()+_,\-./:=?]\*(C'\fR n' space (yo dirty ass is gonna be
warned, n' yo' boundary is ghon be ignored, if dis aint tha case).
If you omit this, a random strang is ghon be chosen... which is probably
safer.
.IP "Charset" 4
.IX Item "Charset"
\&\fIOptional.\fR
Da characta set.
.IP "Data" 4
.IX Item "Data"
\&\fISingle-part entitizzles only. Optional.\fR
An alternatizzle ta Path (q.v.): tha actual data, either as a scalar
or a array reference (whose elements is joined together ta make
the actual scalar).  Da body is opened on tha data using
MIME::Body::InCore.
.IP "Description" 4
.IX Item "Description"
\&\fIOptional.\fR
Da text of tha content-description.
If you don't specify it, tha field aint put up in tha header.
.IP "Disposition" 4
.IX Item "Disposition"
\&\fIOptional.\fR
Da basic content-disposizzle (\f(CW"attachment"\fR or \f(CW"inline"\fR).
If you don't specify it, it defaults ta \*(L"inline\*(R" fo' backwards
compatibility.  \fIThanks ta Kurt Freytag fo' suggestin dis feature.\fR
.IP "Encoding" 4
.IX Item "Encoding"
\&\fIOptional.\fR
Da content-transfer-encoding.
If you don't specify it, a reasonable default is put in.
Yo ass can also give tha special value '\-SUGGEST', ta have it chosen for
you up in a heavy-duty fashizzle which scans tha data itself.
.IP "Filename" 4
.IX Item "Filename"
\&\fISingle-part entitizzles only. Optional.\fR
Da recommended filename.  Overrides any name extracted from \f(CW\*(C`Path\*(C'\fR.
Da shiznit is stored both tha deprecated (content-type) and
preferred (content-disposition) locations.  If you explicitly want to
\&\fIavoid\fR a recommended filename (even when Path is used), supply this
as empty or undef.
.IP "Id" 4
.IX Item "Id"
\&\fIOptional.\fR
Set tha content-id.
.IP "Path" 4
.IX Item "Path"
\&\fISingle-part entitizzles only. Optional.\fR
Da path ta tha file ta attach.  Da body is opened on dat file
usin MIME::Body::File.
.IP "Top" 4
.IX Item "Top"
\&\fIOptional.\fR
Is dis a top-level entity, biatch?  If so, it must shiznit a MIME-Version.
Da default is true.  (\s-1NB:\s0 peep how tha fuck \f(CW\*(C`attach()\*(C'\fR uses dat shit.)
.IP "Type" 4
.IX Item "Type"
\&\fIOptional.\fR
Da basic content-type (\f(CW"text/plain"\fR, etc.).
If you don't specify it, it defaults ta \f(CW"text/plain"\fR
as per \s-1RFC 2045.  \s0\fIDo yo ass a gangbangin' favor: put it in.\fR
.RE
.RS 4
.RE
.IP "dup" 4
.IX Item "dup"
\&\fIInstizzle method.\fR
Duplicate tha entity.  Do a thugged-out deep, recursive copy, \fIbut beware:\fR
external data up in bodyhandlez is \fInot\fR copied ta freshly smoked up files!
Changin tha data up in one entityz data file, or purgin dat entity,
\&\fIwill\fR affect its duplicate.  Entitizzles wit in-core data probably need
not worry.
.SS "Access"
.IX Subsection "Access"
.IP "body [\s-1VALUE\s0]" 4
.IX Item "body [VALUE]"
\&\fIInstizzle method.\fR
Git tha \fIencoded\fR (transport-ready) body, as a array of lines.
Returns a array reference.  Each array entry be a newline-terminated
line.
.Sp
This be a read-only data structure: changin its contents will have
no effect.  Its contents is identical ta what tha fuck is printed by
\&\fIprint_body()\fR.
.Sp
Provided fo' compatibilitizzle wit Mail::Internet, so dat methods
like \f(CW\*(C`smtpsend()\*(C'\fR will work.  Note however dat if \s-1VALUE\s0 is given,
a fatal exception is thrown, since you cannot use dis method to
\&\fIset\fR tha linez of tha encoded message.
.Sp
If you want tha raw (unencoded) body data, use tha \fIbodyhandle()\fR
method ta git n' bust a MIME::Body.  Da content-type of tha entity
will rap  whether dat body is dopest read as text (via \fIgetline()\fR)
or raw data (via \fIread()\fR).
.IP "bodyhandle [\s-1VALUE\s0]" 4
.IX Item "bodyhandle [VALUE]"
\&\fIInstizzle method.\fR
Git or set a abstract object representin tha body of tha message.
Da body holdz tha decoded message data.
.Sp
\&\fBNote dat not all entitizzles have bodies!\fR
An entitizzle gonna git either a funky-ass body or parts: not both.
This method will \fIonly\fR return a object if dis entitizzle can
have a funky-ass body; otherwise, it will return undefined.
Whether-or-not a given entitizzle can gotz a funky-ass body is determined by
(1) its content type, n' (2) whether-or-not tha parser was holla'd at to
extract nested lyrics:
.Sp
.Vb 6
\&    Type:        | Extract nested, biatch? | bodyhandle() | parts()
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    multipart/*  | \-               | undef        | 0 or mo' MIME::Entity
\&    message/*    | legit            | undef        | 0 or 1 MIME::Entity
\&    message/*    | false           | MIME::Body   | empty list
\&    (other)      | \-               | MIME::Body   | empty list
.Ve
.Sp
If \f(CW\*(C`VALUE\*(C'\fR \fIis not\fR given, tha current bodyhandle is returned,
or undef if tha entitizzle cannot gotz a funky-ass body.
.Sp
If \f(CW\*(C`VALUE\*(C'\fR \fIis\fR given, tha bodyhandle is set ta tha freshly smoked up value,
and tha previous value is returned.
.Sp
See \*(L"parts\*(R" fo' mo' info.
.IP "effective_type [\s-1MIMETYPE\s0]" 4
.IX Item "effective_type [MIMETYPE]"
\&\fIInstizzle method.\fR
Set/get tha \fIeffective\fR \s-1MIME\s0 type of dis entity.  This is \fIusually\fR
identical ta tha actual (or defaulted) \s-1MIME\s0 type yo, but up in some cases
it differs.  For example, from \s-1RFC\-2045:\s0
.Sp
.Vb 3
\&   Any entitizzle wit a unrecognized Content\-Transfer\-Encodin must be
\&   treated as if it has a Content\-Type of "application/octet\-stream",
\&   regardless of what tha fuck tha Content\-Type header field straight-up say.
.Ve
.Sp
Why, biatch? cuz if we can't decode tha message, then we gotta take
the bytes as-is, up in they (unrecognized) encoded form.  So the
message ceases ta be a \*(L"text/foobar\*(R" n' becomes a funky-ass bunch of undecipherable
bytes \*(-- up in other lyrics, a \*(L"application/octet\-stream\*(R".
.Sp
Such a entity, if parsed, would have its \fIeffective_type()\fR set to
\&\f(CW"application/octet_stream"\fR, although tha \fImime_type()\fR n' tha contents
of tha header would remain tha same.
.Sp
If there is no effectizzle type, tha method just returns what
\&\fImime_type()\fR would.
.Sp
\&\fBWarning:\fR tha effectizzle type is \*(L"sticky\*(R"; once set, dat \fIeffective_type()\fR
will always be returned even if tha conditions dat necessitated setting
the effectizzle type become no longer true.
.IP "epilogue [\s-1LINES\s0]" 4
.IX Item "epilogue [LINES]"
\&\fIInstizzle method.\fR
Get/set tha text of tha epilogue, as a array of newline-terminated \s-1LINES.\s0
Returns a reference ta tha array of lines, or undef if no epilogue exists.
.Sp
If there be a epilogue, it is output when printin dis entity; otherwise,
a default epilogue is used. Y'all KNOW dat shit, muthafucka!  Settin tha epilogue ta undef (not []!) causes
it ta fallback ta tha default.
.IP "head [\s-1VALUE\s0]" 4
.IX Item "head [VALUE]"
\&\fIInstizzle method.\fR
Get/set tha head.
.Sp
If there is no \s-1VALUE\s0 given, returns tha current head. Y'all KNOW dat shit, muthafucka!  If none
exists, a empty instizzle of MIME::Head is pimped, set, n' returned.
.Sp
\&\fBNote:\fR This be a patch over a problem up in Mail::Internet, which don't
provide a method fo' settin tha head ta some given object.
.IP "is_multipart" 4
.IX Item "is_multipart"
\&\fIInstizzle method.\fR
Do dis entityz effectizzle \s-1MIME\s0 type indicate dat itz a multipart entity?
Returns undef (false) if tha answer couldn't be determined, 0 (false)
if dat shiznit was determined ta be false, n' legit otherwise.
Note dat dis say not a god damn thang bout whether or not parts was extracted.
.Sp
\&\s-1NOTE:\s0 we switched ta effective_type so dat multiparts with
bad or missin boundaries could be coerced ta a effectizzle type
of \f(CW\*(C`application/x\-unparseable\-multipart\*(C'\fR.
.IP "mime_type" 4
.IX Item "mime_type"
\&\fIInstizzle method.\fR
A purely-for-convenience method. Y'all KNOW dat shit, muthafucka!  This simply relays tha request ta the
associated MIME::Head object.
If there is no head, returns undef up in a scalar context and
the empty array up in a list context.
.Sp
\&\fBBefore you use this,\fR consider rockin \fIeffective_type()\fR instead,
especially if you obtained tha entitizzle from a MIME::Parser.
.IP "open \s-1READWRITE\s0" 4
.IX Item "open READWRITE"
\&\fIInstizzle method.\fR
A purely-for-convenience method. Y'all KNOW dat shit, muthafucka!  This simply relays tha request ta the
associated MIME::Body object (see \fIMIME::Body::open()\fR).
\&\s-1READWRITE\s0 is either 'r' (open fo' read) or 'w' (open fo' write).
.Sp
If there is no body, returns false.
.IP "parts" 4
.IX Item "parts"
.PD 0
.IP "parts \s-1INDEX\s0" 4
.IX Item "parts INDEX"
.IP "parts \s-1ARRAYREF\s0" 4
.IX Item "parts ARRAYREF"
.PD
\&\fIInstizzle method.\fR
Return tha MIME::Entitizzle objects which is tha sub partz of this
entitizzle (if any).
.Sp
\&\fIIf no argument is given,\fR returns tha array of all sub parts,
returnin tha empty array if there be none (e.g., if dis be a single
part message, or a thugged-out degenerate multipart).  In a scalar context, this
returns you tha number of parts.
.Sp
\&\fIIf a integer \s-1INDEX\s0 is given,\fR return tha INDEXed part,
or undef if it don't exist.
.Sp
\&\fIIf a \s-1ARRAYREF\s0 ta a array of parts is given,\fR then dis method \fIsets\fR
the parts ta a cold-ass lil copy of dat array, n' returns tha parts, n' you can put dat on yo' toast.  This can
be used ta delete parts, as bigs up:
.Sp
.Vb 2
\&    ### Delete some partz of a multipart message:
\&    $msg\->parts([ grep { keep_part($_) } $msg\->parts ]);
.Ve
.Sp
\&\fBNote:\fR fo' multipart lyrics, tha preamble n' epilogue is \fInot\fR
considered parts, n' you can put dat on yo' toast.  If you need them, use tha \f(CW\*(C`preamble()\*(C'\fR n' \f(CW\*(C`epilogue()\*(C'\fR
methods.
.Sp
\&\fBNote:\fR there be wayz of parsin wit a MIME::Parser which cause
certain message parts (like fuckin dem of type \f(CW\*(C`message/rfc822\*(C'\fR)
to be \*(L"reparsed\*(R" tha fuck into pseudo-multipart entities. Put ya muthafuckin choppers up if ya feel dis!  Yo ass should read the
documentation fo' dem options carefully: it \fIis\fR possible for
a diddled entitizzle ta not be multipart yo, but still have parts attached ta dat shiznit son!
.Sp
See \*(L"bodyhandle\*(R" fo' a gangbangin' finger-lickin' rap of parts vs. bodies.
.IP "parts_DFS" 4
.IX Item "parts_DFS"
\&\fIInstizzle method.\fR
Return tha list of all MIME::Entitizzle objects included up in tha entity,
startin wit tha entitizzle itself, up in depth-first-search order.
If tha entitizzle has no parts, it ridin' solo is ghon be returned.
.Sp
\&\fIThanks ta Xavier Armengou fo' suggestin dis method.\fR
.IP "preamble [\s-1LINES\s0]" 4
.IX Item "preamble [LINES]"
\&\fIInstizzle method.\fR
Get/set tha text of tha preamble, as a array of newline-terminated \s-1LINES.\s0
Returns a reference ta tha array of lines, or undef if no preamble exists
(e.g., if dis be a single-part entity).
.Sp
If there be a preamble, it is output when printin dis entity; otherwise,
a default preamble is used. Y'all KNOW dat shit, muthafucka!  Settin tha preamble ta undef (not []!) causes
it ta fallback ta tha default.
.SS "Manipulation"
.IX Subsection "Manipulation"
.IP "make_multipart [\s-1SUBTYPE\s0], \s-1OPTSHASH...\s0" 4
.IX Item "make_multipart [SUBTYPE], OPTSHASH..."
\&\fIInstizzle method.\fR
Force tha entitizzle ta be a multipart, if it aint already.
Us dudes do dis by replacin tha original gangsta [singlepart] entitizzle wit a new
multipart dat has tha same ol' dirty non-MIME headaz (\*(L"From\*(R", \*(L"Subject\*(R", etc.),
but all-new \s-1MIME\s0 headaz (\*(L"Content-type\*(R", etc.).  We then create
a copy of tha original gangsta singlepart, \fIstrip out\fR tha non-MIME headers
from that, n' make it a part of tha freshly smoked up multipart.  So this:
.Sp
.Vb 4
\&    From: me
\&    To: you
\&    Content\-type: text/plain
\&    Content\-length: 12
\&
\&    Wuz crackalackin' there!
.Ve
.Sp
Becomes suttin' like this:
.Sp
.Vb 3
\&    From: me
\&    To: you
\&    Content\-type: multipart/mixed; boundary="\-\-\-\-abc\-\-\-\-"
\&
\&    \-\-\-\-\-\-abc\-\-\-\-
\&    Content\-type: text/plain
\&    Content\-length: 12
\&
\&    Wuz crackalackin' there!
\&    \-\-\-\-\-\-abc\-\-\-\-\-\-
.Ve
.Sp
Da actual type of tha freshly smoked up top-level multipart is ghon be \*(L"multipart/SUBTYPE\*(R"
(default \s-1SUBTYPE\s0 is \*(L"mixed\*(R").
.Sp
Returns '\s-1DONE\s0'    if we straight-up did inflate a singlepart ta a multipart.
Returns '\s-1ALREADY\s0' (and do nothing) if entitizzle is \fIalready\fR multipart
and Force was not chosen.
.Sp
If \s-1OPTSHASH\s0 gotz nuff Force=>1, then we \fIalways\fR bump tha top-level's
content n' content-headaz down ta a subpart of dis entity, even if
this entitizzle be already a multipart.  This be apparently of use to
people whoz ass is tweakin lyrics afta parsin em.
.IP "make_singlepart" 4
.IX Item "make_singlepart"
\&\fIInstizzle method.\fR
If tha entitizzle be a multipart message wit one part, dis tries hard to
rewrite it as a singlepart, by replacin tha content (and content headers)
of tha top level wit dem of tha part.  Also crunches 0\-part multiparts
into singleparts.
.Sp
Returns '\s-1DONE\s0'    if we straight-up did collapse a multipart ta a singlepart.
Returns '\s-1ALREADY\s0' (and do nothing) if entitizzle be already a singlepart.
Returns '0'       (and do nothing) if it can't be made tha fuck into a singlepart.
.IP "purge" 4
.IX Item "purge"
\&\fIInstizzle method.\fR
Recursively purge (e.g., unlink) all external (e.g., on-disk) body parts
in dis message.  See \fIMIME::Body::purge()\fR fo' details.
.Sp
\&\fBNote:\fR dis do \fInot\fR delete tha directories dat dem body parts
are contained in; only tha actual message data filez is deleted.
This is cuz some parsers may be customized ta create intermediate
directories while others is not, n' itz impossible fo' dis class
to know what tha fuck directories is safe ta remove.  Only yo' application
program truly knows dis shit.
.Sp
\&\fBIf you straight-up wanna \*(L"clean every last muthafuckin thang up\*(R",\fR one phat way is to
use \f(CW\*(C`MIME::Parser::file_under()\*(C'\fR, n' then do dis before parsing
your next message:
.Sp
.Vb 1
\&    $parser\->filer\->purge();
.Ve
.Sp
I wouldn't attempt ta read dem body filez afta you do this, for
obvious reasons.  Az of MIME-tools 4.x, each bodyz path \fIis\fR undefined
afta dis operation. I aint talkin' bout chicken n' gravy biatch.  I warned you I might do this; truly I done did.
.Sp
\&\fIThanks ta Jizzo L. Tibbitts \s-1III\s0 fo' suggestin dis method.\fR
.IP "remove_sig [\s-1NLINES\s0]" 4
.IX Item "remove_sig [NLINES]"
\&\fIInstizzle method, override.\fR
Attempts ta remove a userz signature from tha body of a message.
.Sp
It do dis by lookin fo' a line matchin \f(CW\*(C`/^\-\- $/\*(C'\fR within tha last
\&\f(CW\*(C`NLINES\*(C'\fR of tha message.  If found then dat line n' all lines after
it is ghon be removed. Y'all KNOW dat shit, muthafucka! If \f(CW\*(C`NLINES\*(C'\fR aint given, a thugged-out default value of 10
will be used. Y'all KNOW dat shit, muthafucka!  This would be of most use up in auto-reply scripts.
.Sp
For \s-1MIME\s0 entity, dis method is reasonably cautious: it will only
attempt ta un-sign a message wit a cold-ass lil content-type of \f(CW\*(C`text/*\*(C'\fR.
.Sp
If you bust \fIremove_sig()\fR ta a multipart entity, it will relay it to
the first part (the others probably bein tha \*(L"attachments\*(R").
.Sp
\&\fBWarning:\fR currently slurps tha whole message-part tha fuck into core as an
array of lines, so you probably don't wanna use dis on mad
long lyrics.
.Sp
Returns truth on success, false on error.
.IP "sign \s-1PARAMHASH\s0" 4
.IX Item "sign PARAMHASH"
\&\fIInstizzle method, override.\fR
Append a signature ta tha message.  Da params are:
.RS 4
.IP "Attach" 4
.IX Item "Attach"
Instead of appendin tha text, add it ta tha message as a attachment.
Da disposizzle is ghon be \f(CW\*(C`inline\*(C'\fR, n' tha description will indicate
that it aint nuthin but a signature.  Da default behavior is ta append tha signature
to tha text of tha message (or tha text of its first part if multipart).
\&\fIMIME-specific; freshly smoked up in dis subclass.\fR
.IP "File" 4
.IX Item "File"
Use tha contentz of dis file as tha signature.
Fatal error if it can't be read.
\&\fIAs per superclass method.\fR
.IP "Force" 4
.IX Item "Force"
Sign it even if tha content-type aint \f(CW\*(C`text/*\*(C'\fR.  Useful for
non-standard types like \f(CW\*(C`x\-foobar\*(C'\fR yo, but be careful!
\&\fIMIME-specific; freshly smoked up in dis subclass.\fR
.IP "Remove" 4
.IX Item "Remove"
Normally, we attempt ta strip up any existin signature.
If true, dis gives our asses tha \s-1NLINES\s0 parameta of tha remove_sig call.
If zero but defined,  drops some lyrics ta our asses \fInot\fR ta remove any existin signature.
If undefined, removal is done wit tha default of 10 lines.
\&\fINew up in dis subclass.\fR
.IP "Signature" 4
.IX Item "Signature"
Use dis text as tha signature.  Yo ass can supply it as either
a scalar, or as a ref ta a array of newline-terminated scalars.
\&\fIAs per superclass method.\fR
.RE
.RS 4
.Sp
For \s-1MIME\s0 lyrics, dis method is reasonably cautious: it will only
attempt ta sign a message wit a cold-ass lil content-type of \f(CW\*(C`text/*\*(C'\fR, unless
\&\f(CW\*(C`Force\*(C'\fR is specified.
.Sp
If you bust dis message ta a multipart entity, it will relay it to
the first part (the others probably bein tha \*(L"attachments\*(R").
.Sp
\&\fBWarning:\fR currently slurps tha whole message-part tha fuck into core as an
array of lines, so you probably don't wanna use dis on mad
long lyrics.
.Sp
Returns legit on success, false otherwise.
.RE
.IP "suggest_encoding" 4
.IX Item "suggest_encoding"
\&\fIInstizzle method.\fR
Based on tha effectizzle content type, return a phat suggested encoding.
.Sp
\&\f(CW\*(C`text\*(C'\fR n' \f(CW\*(C`message\*(C'\fR types have they bodies scanned line-by-line
for 8\-bit charactas n' long lines; lack of either means dat the
message is 7bit\-ok.  Other types is chosen independent of they body:
.Sp
.Vb 8
\&    Major type:      7bit ok, biatch?    Suggested encoding:
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    text             yeaaaa         7bit
\&    text             no          quoted\-printable
\&    message          yeaaaa         7bit
\&    message          no          binary
\&    multipart        *           binary (in case some parts is bad)
\&    image, etc...    *           base64
.Ve
.IP "sync_headaz \s-1OPTIONS\s0" 4
.IX Item "sync_headaz OPTIONS"
\&\fIInstizzle method.\fR
This method do a variety of activitizzles which ensure that
the \s-1MIME\s0 headaz of a entitizzle \*(L"tree\*(R" is in-synch wit tha body parts
they describe.  It can be as high-rollin' a operation as printing
if it involves pre-encodin tha body parts; however, tha aim is to
produce fairly clean \s-1MIME.  \s0\fBYo ass will probably only need ta invoke
this if processin n' re-sendin \s-1MIME\s0 from a outside source.\fR
.Sp
Da \s-1OPTIONS\s0 be a hash, which raps bout what tha fuck is ta be done.
.RS 4
.IP "Length" 4
.IX Item "Length"
One of tha \*(L"straight-up legit unofficial\*(R" \s-1MIME\s0 fieldz is \*(L"Content-Length\*(R".
Normally, one don't care a whit bout dis field; however, if
yo ass is preparin output destined fo' \s-1HTTP,\s0 you may.  Da value of
this option dictates what tha fuck is ghon be done:
.Sp
\&\fB\s-1COMPUTE\s0\fR means ta set a \f(CW\*(C`Content\-Length\*(C'\fR field fo' every last muthafuckin non-multipart
part up in tha entity, n' ta blank dat field up fo' every last muthafuckin multipart
part up in tha entity.
.Sp
\&\fB\s-1ERASE\s0\fR means dat \f(CW\*(C`Content\-Length\*(C'\fR fieldz will all
be blanked out.  This is fast, painless, n' safe.
.Sp
\&\fBAny false value\fR (the default) means ta take no action.
.IP "Nonstandard" 4
.IX Item "Nonstandard"
Any header field beginnin wit \*(L"Content\-\*(R" is, accordin ta tha \s-1RFC,\s0
a \s-1MIME\s0 field. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat some is non-standard, n' may cause problems
with certain \s-1MIME\s0 readaz which interpret dem up in different ways.
.Sp
\&\fB\s-1ERASE\s0\fR means dat all such fieldz is ghon be blanked out.  This is
done \fIbefore\fR tha \fBLength\fR option (q.v.) is examined n' acted upon.
.Sp
\&\fBAny false value\fR (the default) means ta take no action.
.RE
.RS 4
.Sp
Returns a legit value if every last muthafuckin thang went aiiight, a gangbangin' false value otherwise.
.RE
.IP "tidy_body" 4
.IX Item "tidy_body"
\&\fIInstizzle method, override.\fR
Currently unimplemented fo' \s-1MIME\s0 lyrics.  Do nothing, returns false.
.SS "Output"
.IX Subsection "Output"
.IP "dump_skeleton [\s-1FILEHANDLE\s0]" 4
.IX Item "dump_skeleton [FILEHANDLE]"
\&\fIInstizzle method.\fR
Dump tha skeleton of tha entitizzle ta tha given \s-1FILEHANDLE,\s0 or
to tha currently-selected one if none given.
.Sp
Each entitizzle is output wit a appropriate indentation level,
the followin selection of attributes:
.Sp
.Vb 5
\&    Content\-type: multipart/mixed
\&    Effective\-type: multipart/mixed
\&    Body\-file: NONE
\&    Subject: Yo there!
\&    Num\-parts: 2
.Ve
.Sp
This is straight-up just useful fo' debuggin purposes; I make no guarantees
about tha consistency of tha output format over time.
.IP "print [\s-1OUTSTREAM\s0]" 4
.IX Item "print [OUTSTREAM]"
\&\fIInstizzle method, override.\fR
Print tha entitizzle ta tha given \s-1OUTSTREAM,\s0 or ta tha currently-selected
filehandle if none given. I aint talkin' bout chicken n' gravy biatch.  \s-1OUTSTREAM\s0 can be a gangbangin' filehandle, or any object
that respondz ta a \fIprint()\fR message.
.Sp
Da entitizzle is output as a valid \s-1MIME\s0 stream!  This means dat the
header be always output first, n' tha body data (if any) will be
encoded if tha header say dat it should be.
For example, yo' output may be lookin like this:
.Sp
.Vb 2
\&    Subject: Greetings
\&    Content\-transfer\-encoding: base64
\&
\&    SGkgdGhlcmUhCkJ5ZSB0aGVyZSEK
.Ve
.Sp
\&\fIIf dis entitizzle has \s-1MIME\s0 type \*(L"multipart/*\*(R",\fR
the preamble, parts, n' epilogue is all output wit appropriate
boundaries separatin each.
Any bodyhandle is ignored:
.Sp
.Vb 2
\&    Content\-type: multipart/mixed; boundary="*\-\-\-\-*"
\&    Content\-transfer\-encoding: 7bit
\&
\&    [Preamble]
\&    \-\-*\-\-\-\-*
\&    [Entity: Part 0]
\&    \-\-*\-\-\-\-*
\&    [Entity: Part 1]
\&    \-\-*\-\-\-\-*\-\-
\&    [Epilogue]
.Ve
.Sp
\&\fIIf dis entitizzle has a single-part \s-1MIME\s0 type wit no attached parts,\fR
then our slick asses lookin at a aiiight singlepart entity: tha body is output
accordin ta tha encodin specified by tha header.
If no body exists, a warnin is output n' tha body is treated as empty:
.Sp
.Vb 2
\&    Content\-type: image/gif
\&    Content\-transfer\-encoding: base64
\&
\&    [Encoded body]
.Ve
.Sp
\&\fIIf dis entitizzle has a single-part \s-1MIME\s0 type but it also has parts,\fR
then we probably lookin at a \*(L"re-parsed\*(R" singlepart, probably one
of type \f(CW\*(C`message/*\*(C'\fR (you can git entitizzles like dis if you set the
\&\f(CW\*(C`parse_nested_lyrics(NEST)\*(C'\fR option on tha parser ta true).
In dis case, tha parts is output wit single blank lines separatin each,
and any bodyhandle is ignored:
.Sp
.Vb 2
\&    Content\-type: message/rfc822
\&    Content\-transfer\-encoding: 7bit
\&
\&    [Entity: Part 0]
\&
\&    [Entity: Part 1]
.Ve
.Sp
In all cases, when outputtin a \*(L"part\*(R" of tha entity, dis method
is invoked recursively.
.Sp
\&\fBNote:\fR tha output is straight-up likely \fInot\fR goin ta be identical
to any input you parsed ta git dis entity.  If you building
some sort of email handlez, itz up ta you ta save dis shiznit.
.IP "print_body [\s-1OUTSTREAM\s0]" 4
.IX Item "print_body [OUTSTREAM]"
\&\fIInstizzle method, override.\fR
Print tha body of tha entitizzle ta tha given \s-1OUTSTREAM,\s0 or ta the
currently-selected filehandle if none given. I aint talkin' bout chicken n' gravy biatch.  \s-1OUTSTREAM\s0 can be a
filehandle, or any object dat respondz ta a \fIprint()\fR message.
.Sp
Da body is output fo' inclusion up in a valid \s-1MIME\s0 stream; dis means
that tha body data is ghon be encoded if tha header say dat it should be.
.Sp
\&\fBNote:\fR by \*(L"body\*(R", we mean \*(L"the shiznit followin tha header\*(R".
A printed multipart body includes tha printed representationz of its subparts.
.Sp
\&\fBNote:\fR Da body is \fIstored\fR up in a un-encoded form; however, tha scam is that
the transfer encodin is used ta determine how tha fuck it should be \fIoutput.\fR
This means dat tha \f(CW\*(C`print()\*(C'\fR method be always guaranteed ta git you
a sendmail-ready stream whose body is consistent wit its head.
If you want tha \fIraw body data\fR ta be output, you can either read it from
the bodyhandle yo ass, or use:
.Sp
.Vb 1
\&    $ent\->bodyhandle\->print($outstream);
.Ve
.Sp
which uses \fIread()\fR calls ta extract tha shiznit, n' thus will
work wit both text n' binary bodies.
.Sp
\&\fBWarning:\fR Please supply a \s-1OUTSTREAM. \s0 This override method differs
from Mail::Internetz behavior, which outputs ta tha \s-1STDOUT\s0 if no
filehandle is given: dis may lead ta mad drama.
.IP "print_header [\s-1OUTSTREAM\s0]" 4
.IX Item "print_header [OUTSTREAM]"
\&\fIInstizzle method, inherited.\fR
Output tha header ta tha given \s-1OUTSTREAM. \s0 Yo ass straight-up should supply
the \s-1OUTSTREAM.\s0
.IP "stringify" 4
.IX Item "stringify"
\&\fIInstizzle method.\fR
Return tha entitizzle as a string, exactly as \f(CW\*(C`print\*(C'\fR would print dat shit.
Da body is ghon be encoded as necessary, n' will contain any subparts.
Yo ass can also use \f(CW\*(C`as_string()\*(C'\fR.
.IP "stringify_body" 4
.IX Item "stringify_body"
\&\fIInstizzle method.\fR
Return tha \fIencoded\fR message body as a string, exactly as \f(CW\*(C`print_body\*(C'\fR
would print dat shit.  Yo ass can also use \f(CW\*(C`body_as_string()\*(C'\fR.
.Sp
If you want tha \fIunencoded\fR body, n' yo ass is dealin wit a
singlepart message (like a \*(L"text/plain\*(R"), use \f(CW\*(C`bodyhandle()\*(C'\fR instead:
.Sp
.Vb 6
\&    if ($ent\->bodyhandle) {
\&        $unencoded_data = $ent\->bodyhandle\->as_string;
\&    }
\&    else {
\&        ### dis message has no body data (but it might have parts!)
\&    }
.Ve
.IP "stringify_header" 4
.IX Item "stringify_header"
\&\fIInstizzle method.\fR
Return tha header as a string, exactly as \f(CW\*(C`print_header\*(C'\fR would print dat shit.
Yo ass can also use \f(CW\*(C`header_as_string()\*(C'\fR.
.SH "NOTES"
.IX Header "NOTES"
.SS "Under tha hood"
.IX Subsection "Under tha hood"
A \fBMIME::Entity\fR is composed of tha followin elements:
.IP "\(bu" 4
A \fIhead\fR, which be a reference ta a MIME::Head object
containin tha header shiznit.
.IP "\(bu" 4
A \fIbodyhandle\fR, which be a reference ta a MIME::Body object
containin tha decoded body data.  This is only defined if
the message be a \*(L"singlepart\*(R" type:
.Sp
.Vb 5
\&    application/*
\&    audio/*
\&    image/*
\&    text/*
\&    vizzle/*
.Ve
.IP "\(bu" 4
An array of \fIparts\fR, where each part be a MIME::Entitizzle object.
Da number of parts will only be nonzero if tha content-type
is \fInot\fR one of tha \*(L"singlepart\*(R" types:
.Sp
.Vb 2
\&    message/*        (should have exactly one part)
\&    multipart/*      (should have one or mo' parts)
.Ve
.ie n .SS "Da ""two-body problem"""
.el .SS "Da ``two-body problem''"
.IX Subsection "Da two-body problem"
MIME::Entitizzle n' Mail::Internizzle peep message bodies differently,
and dis can cause mad drama n' some inconvenience.  Sadly, I can't
change tha behavior of MIME::Entitizzle without breakin fuckin shitloadz of code already
out there, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  But letz open up tha floor fo' all dem thangs...
.ie n .IP "What tha fuck iz tha difference between a ""message"" n' a ""entity""?" 4
.el .IP "What tha fuck iz tha difference between a ``message'' n' a ``entity''?" 4
.IX Item "What tha fuck iz tha difference between a message n' a entity?"
A \fBmessage\fR is tha actual data bein busted or received; usually
this means a stream of newline-terminated lines.
An \fBentity\fR is tha representation of a message as a object.
.Sp
This means dat you git a \*(L"message\*(R" when you print a \*(L"entity\*(R"
\&\fIto\fR a gangbangin' filehandle, n' you git a \*(L"entity\*(R" when you parse a message
\&\fIfrom\fR a gangbangin' filehandle.
.IP "What tha fuck iz a message body?" 4
.IX Item "What tha fuck iz a message body?"
\&\fBMail::Internet:\fR
Da portion of tha printed message afta tha header.
.Sp
\&\fBMIME::Entity:\fR
Da portion of tha printed message afta tha header.
.IP "How tha fuck be a message body stored up in a entity?" 4
.IX Item "How tha fuck be a message body stored up in a entity?"
\&\fBMail::Internet:\fR
As a array of lines.
.Sp
\&\fBMIME::Entity:\fR
It dependz on tha content-type of tha message.
For \*(L"container\*(R" types (\f(CW\*(C`multipart/*\*(C'\fR, \f(CW\*(C`message/*\*(C'\fR), we store the
contained entitizzles as a array of \*(L"parts\*(R", accessed via tha \f(CW\*(C`parts()\*(C'\fR
method, where each part be a cold-ass lil complete MIME::Entity.
For \*(L"singlepart\*(R" types (\f(CW\*(C`text/*\*(C'\fR, \f(CW\*(C`image/*\*(C'\fR, etc.), tha unencoded
body data is referenced via a MIME::Body object, accessed via
the \f(CW\*(C`bodyhandle()\*(C'\fR method:
.Sp
.Vb 11
\&                      bodyhandle()   parts()
\&    Content\-type:     returns:       returns:
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    application/*     MIME::Body     empty
\&    audio/*           MIME::Body     empty
\&    image/*           MIME::Body     empty
\&    message/*         undef          MIME::Entitizzle list (usually 1)
\&    multipart/*       undef          MIME::Entitizzle list (usually >0)
\&    text/*            MIME::Body     empty
\&    vizzle/*           MIME::Body     empty
\&    x\-*/*             MIME::Body     empty
.Ve
.Sp
As a special case, \f(CW\*(C`message/*\*(C'\fR is currently ambiguous: depending
on tha parser, a \f(CW\*(C`message/*\*(C'\fR might be treated as a singlepart,
with a MIME::Body n' no parts, n' you can put dat on yo' toast.  Use \fIbodyhandle()\fR as tha final
arbiter.
.IP "What do tha \fIbody()\fR method return?" 4
.IX Item "What do tha body() method return?"
\&\fBMail::Internet:\fR
As a array of lines, locked n loaded fo' sending.
.Sp
\&\fBMIME::Entity:\fR
As a array of lines, locked n loaded fo' sending.
.IP "Whatz tha dopest way ta git all up in tha body data?" 4
.IX Item "Whatz tha dopest way ta git all up in tha body data?"
\&\fBMail::Internet:\fR
Use tha \fIbody()\fR method.
.Sp
\&\fBMIME::Entity:\fR
Dependz on what tha fuck you want... tha \fIencoded\fR data (as it is
transported), or tha \fIunencoded\fR data, biatch?  Keep reading...
.ie n .IP "How tha fuck do I git tha ""encoded"" body data?" 4
.el .IP "How tha fuck do I git tha ``encoded'' body data?" 4
.IX Item "How tha fuck do I git tha encoded body data?"
\&\fBMail::Internet:\fR
Use tha \fIbody()\fR method.
.Sp
\&\fBMIME::Entity:\fR
Use tha \fIbody()\fR method. Y'all KNOW dat shit, muthafucka!  Yo ass can also use:
.Sp
.Vb 2
\&    $entity\->print_body()
\&    $entity\->stringify_body()   ### a.k.a. $entity\->body_as_string()
.Ve
.ie n .IP "How tha fuck do I git tha ""unencoded"" body data?" 4
.el .IP "How tha fuck do I git tha ``unencoded'' body data?" 4
.IX Item "How tha fuck do I git tha unencoded body data?"
\&\fBMail::Internet:\fR
Use tha \fIbody()\fR method.
.Sp
\&\fBMIME::Entity:\fR
Use tha \fI\fIbodyhandle()\fI\fR method!
If \fIbodyhandle()\fR method returns true, then dat value be a
MIME::Body which can be used ta access tha data via
its \fIopen()\fR method. Y'all KNOW dat shit, muthafucka!  If \fIbodyhandle()\fR method returns a undefined value,
then tha entitizzle is probably a \*(L"container\*(R" dat has no real body data of
its own (e.g., a \*(L"multipart\*(R" message): up in dis case, you should access
the components via tha \fIparts()\fR method. Y'all KNOW dat shit, muthafucka!  Like this:
.Sp
.Vb 10
\&    if ($bh = $entity\->bodyhandle) {
\&        $io = $bh\->open;
\&        ...access unencoded data via $io\->getline or $io\->read...
\&        $io\->close;
\&    }
\&    else {
\&        foreach mah $part (@parts) {
\&            ...do suttin' wit tha part...
\&        }
\&    }
.Ve
.Sp
Yo ass can also use:
.Sp
.Vb 6
\&    if ($bh = $entity\->bodyhandle) {
\&        $unencoded_data = $bh\->as_string;
\&    }
\&    else {
\&        ...do shiznit wit tha parts...
\&    }
.Ve
.IP "What do tha \fIbody()\fR method return?" 4
.IX Item "What do tha body() method return?"
\&\fBMail::Internet:\fR
Da transport-encoded message body, as a array of lines.
.Sp
\&\fBMIME::Entity:\fR
Da transport-encoded message body, as a array of lines.
.IP "What do \fIprint_body()\fR print?" 4
.IX Item "What do print_body() print?"
\&\fBMail::Internet:\fR
Exactly what tha fuck \fIbody()\fR would return ta yo thugged-out ass.
.Sp
\&\fBMIME::Entity:\fR
Exactly what tha fuck \fIbody()\fR would return ta yo thugged-out ass.
.ie n .IP "Say I have a entitizzle which might be either singlepart or multipart yo. How tha fuck do I print up just ""the shiznit afta tha header""?" 4
.el .IP "Say I have a entitizzle which might be either singlepart or multipart yo. How tha fuck do I print up just ``the shiznit afta tha header''?" 4
.IX Item "Say I have a entitizzle which might be either singlepart or multipart yo. How tha fuck do I print up just tha shiznit afta tha header?"
\&\fBMail::Internet:\fR
Use \fIprint_body()\fR.
.Sp
\&\fBMIME::Entity:\fR
Use \fIprint_body()\fR.
.IP "Why is MIME::Entitizzle so different from Mail::Internet?" 4
.IX Item "Why is MIME::Entitizzle so different from Mail::Internet?"
Because \s-1MIME\s0 streams is sposed ta fuckin have non-textual data...
possibly, like a shitload of it, like fuckin a tar file.
.Sp
Because \s-1MIME\s0 lyrics can consist of multiple parts, which is most-easily
manipulated as MIME::Entitizzle objects theyselves.
.Sp
Because up in tha simpla ghetto of Mail::Internet, tha data of a message
and its printed representation is \fIidentical\fR... n' up in tha \s-1MIME\s0
world, they not.
.Sp
Because parsin multipart bodies on-the-fly, or formattin multipart
bodies fo' output, be a non-trivial task.
.IP "This is confusing.  Can tha two classes be made mo' compatible?" 4
.IX Item "This is confusing. Can tha two classes be made mo' compatible?"
Not easily; they implementations is necessarily like different.
Mail::Internizzle be a simple, efficient way of dealin wit a \*(L"black box\*(R"
mail message... one whose internal data you couldn't give a fuckin shiznit much about.
MIME::Entity, up in contrast, cares \fIvery much\fR bout tha message contents:
thatz its thang!
.SS "Design issues"
.IX Subsection "Design issues"
.IP "Some thangs just can't be ignored" 4
.IX Item "Some thangs just can't be ignored"
In multipart lyrics, tha \fI\*(L"preamble\*(R"\fR is tha portion dat precedes
the first encapsulation boundary, n' tha \fI\*(L"epilogue\*(R"\fR is tha portion
that bigs up tha last encapsulation boundary.
.Sp
Accordin ta \s-1RFC 2046:\s0
.Sp
.Vb 5
\&    There appears ta be room fo' additionizzle shiznit prior
\&    ta tha straight-up original gangsta encapsulation boundary n' followin tha final
\&    boundary.  These areas should generally be left blank, and
\&    implementations must ignore anythang dat appears before the
\&    first boundary or afta tha last one.
\&
\&    NOTE: These "preamble" n' "epilogue" areas is generally
\&    not used cuz of tha lack of proper typin of these parts
\&    n' tha lack of clear semantics fo' handlin these areas at
\&    gateways, particularly X.400 gateways.  But fuck dat shiznit yo, tha word on tha street is dat rather than
\&    leavin tha preamble area blank, nuff MIME implementations
\&    have found dis ta be a cold-ass lil convenient place ta bang an
\&    explanatory note fo' recipients whoz ass read tha message with
\&    pre\-MIME software, since such notes is ghon be ignored by
\&    MIME\-compliant software.
.Ve
.Sp
In tha ghetto of standards-and-practices, thatz tha standard.
Now fo' tha practice:
.Sp
\&\fISome \*(L"\s-1MIME\*(R"\s0 mailaz may incorrectly put a \*(L"part\*(R" up in tha preamble\fR.
Since we gotta parse over tha shiznit \fIanyway\fR, up in tha future I
\&\fImay\fR allow tha parser option of bustin special MIME::Entitizzle objects
for tha preamble n' epilogue, wit bogus MIME::Head objects.
.Sp
For now, though, we MIME-compliant, so I probably won't chizzle
how we work.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MIME::Tools, MIME::Head, MIME::Body, MIME::Decoder, Mail::Internet
.SH "AUTHOR"
.IX Header "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
Dizzy F. Right back up in yo muthafuckin ass. Skoll (dfs@roaringpenguin.com) http://www.roaringpenguin.com
.PP
All muthafuckin rights reserved. Y'all KNOW dat shit, muthafucka!  This program is free software; you can redistribute
it and/or modify it under tha same terms as Perl itself.
