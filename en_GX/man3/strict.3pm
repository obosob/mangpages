.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "strict 3pm"
.TH strict 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
strict \- Perl pragma ta restrict unsafe constructs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use strict;
\&
\&    use strict "vars";
\&    use strict "refs";
\&    use strict "subs";
\&
\&    use strict;
\&    no strict "vars";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
If no import list is supplied, all possible restrictions is assumed.
(This is tha safest mode ta operate up in yo, but is sometimes too strict for
casual programming.)  Currently, there be three possible thangs ta be
strict about:  \*(L"subs\*(R", \*(L"vars\*(R", n' \*(L"refs\*(R".
.ie n .IP """strict refs""" 6
.el .IP "\f(CWstrict refs\fR" 6
.IX Item "strict refs"
This generates a runtime error if you 
use symbolic references (see perlref).
.Sp
.Vb 7
\&    use strict \*(Aqrefs\*(Aq;
\&    $ref = \e$foo;
\&    print $$ref;        # ok
\&    $ref = "foo";
\&    print $$ref;        # runtime error; normally ok
\&    $file = "STDOUT";
\&    print $file "Hi!";  # error; note: no comma afta $file
.Ve
.Sp
There is one exception ta dis rule:
.Sp
.Vb 2
\&    $bar = \e&{\*(Aqfoo\*(Aq};
\&    &$bar;
.Ve
.Sp
is allowed so dat \f(CW\*(C`goto &$AUTOLOAD\*(C'\fR would not break under stricture.
.ie n .IP """strict vars""" 6
.el .IP "\f(CWstrict vars\fR" 6
.IX Item "strict vars"
This generates a cold-ass lil compile-time error if you access a variable dat was
neither explicitly declared (usin any of \f(CW\*(C`my\*(C'\fR, \f(CW\*(C`our\*(C'\fR, \f(CW\*(C`state\*(C'\fR, or \f(CW\*(C`use
vars\*(C'\fR) nor straight-up qualified. Y'all KNOW dat shit, muthafucka!  (Because dis is ta avoid variable suicide
problems n' subtle dynamic scopin issues, a merely \f(CW\*(C`local\*(C'\fR variable aint
phat enough.)  See \*(L"my\*(R" up in perlfunc, \*(L"our\*(R" up in perlfunc, \*(L"state\*(R" up in perlfunc,
\&\*(L"local\*(R" up in perlfunc, n' vars.
.Sp
.Vb 4
\&    use strict \*(Aqvars\*(Aq;
\&    $X::foo = 1;         # ok, straight-up qualified
\&    mah $foo = 10;        # ok, my() var
\&    local $baz = 9;      # blows up, $baz not declared before
\&
\&    package Cinna;
\&    our $bar;                   # Declares $bar up in current package
\&    $bar = \*(AqHgS\*(Aq;               # ok, global declared via pragma
.Ve
.Sp
Da \fIlocal()\fR generated a cold-ass lil compile-time error cuz you just touched a global
name without straight-up qualifyin dat shit.
.Sp
Because of they special use by \fIsort()\fR, tha variablez \f(CW$a\fR n' \f(CW$b\fR are
exempted from dis check.
.ie n .IP """strict subs""" 6
.el .IP "\f(CWstrict subs\fR" 6
.IX Item "strict subs"
This disablez tha poetry optimization, generatin a cold-ass lil compile-time error if
you try ta bust a funky-ass bareword identifier thatz not a subroutine, unless it
is a simple identifier (no colons) n' dat it appears up in curly braces or
on tha left hand side of tha \f(CW\*(C`=>\*(C'\fR symbol.
.Sp
.Vb 4
\&    use strict \*(Aqsubs\*(Aq;
\&    $SIG{PIPE} = Plumber;       # blows up
\&    $SIG{PIPE} = "Plumber";     # just fine: quoted strang be always ok
\&    $SIG{PIPE} = \e&Plumber;     # preferred form
.Ve
.PP
See \*(L"Pragmatic Modules\*(R" up in perlmodlib.
.SH "HISTORY"
.IX Header "HISTORY"
\&\f(CW\*(C`strict \*(Aqsubs\*(Aq\*(C'\fR, wit Perl 5.6.1, erroneously permitted ta use a unquoted
compound identifier (e.g. \f(CW\*(C`Foo::Bar\*(C'\fR) as a hash key (before \f(CW\*(C`=>\*(C'\fR or
inside curlies) yo, but without forcin it always ta a literal string.
.PP
Startin wit Perl 5.8.1 strict is strict bout its restrictions:
if unknown restrictions is used, tha strict pragma will abort with
.PP
.Vb 1
\&    Unknown \*(Aqstrict\*(Aq tag(s) \*(Aq...\*(Aq
.Ve
.PP
Az of version 1.04 (Perl 5.10), strict verifies dat it is used as
\&\*(L"strict\*(R" ta avoid tha dreaded Strict trap on case insensitizzle file
systems.
