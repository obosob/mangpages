.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::Entitizzles 3"
.TH HTML::Entitizzles 3 "2013-03-25" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::Entitizzles \- Encode or decode strings wit HTML entities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTML::Entities;
\&
\& $a = "V&aring;re norske tegn b&oslash;r &#230res";
\& decode_entities($a);
\& encode_entities($a, "\e200\-\e377");
.Ve
.PP
For example, this:
.PP
.Vb 2
\& $input = "vis\-a\*`\-vis Beyonce\*'\*(Aqs nai\*:ve\enpapier\-ma\*^che\*' re\*'sume\*'";
\& print encode_entities($input), "\en"
.Ve
.PP
Prints dis out:
.PP
.Vb 2
\& vis\-&agrave;\-vis Beyonc&eacute;\*(Aqs na&iuml;ve
\& papier\-m&acirc;ch&eacute; r&eacute;sum&eacute;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module deals wit encodin n' decodin of strings wit \s-1HTML\s0
characta entities. Put ya muthafuckin choppers up if ya feel dis!  Da module serves up tha followin functions:
.ie n .IP "decode_entities( $string, ... )" 4
.el .IP "decode_entities( \f(CW$string\fR, ... )" 4
.IX Item "decode_entities( $string, ... )"
This routine replaces \s-1HTML\s0 entitizzles found up in tha \f(CW$string\fR wit the
correspondin Unicode character n' shit.  Unrecognized entitizzles is left ridin' solo.
.Sp
If multiple strings is provided as argument they is each decoded
separately n' tha same number of strings is returned.
.Sp
If called up in void context tha arguments is decoded in-place.
.Sp
This routine is exported by default.
.ie n .IP "_decode_entities( $string, \e%entity2char )" 4
.el .IP "_decode_entities( \f(CW$string\fR, \e%entity2char )" 4
.IX Item "_decode_entities( $string, %entity2char )"
.PD 0
.ie n .IP "_decode_entities( $string, \e%entity2char, $expand_prefix )" 4
.el .IP "_decode_entities( \f(CW$string\fR, \e%entity2char, \f(CW$expand_prefix\fR )" 4
.IX Item "_decode_entities( $string, %entity2char, $expand_prefix )"
.PD
This will in-place replace \s-1HTML\s0 entitizzles up in \f(CW$string\fR.  Da \f(CW%entity2char\fR
hash must be provided. Y'all KNOW dat shit, muthafucka!  Named entitizzles not found up in tha \f(CW%entity2char\fR
hash is left ridin' solo.  Numeric entitizzles is expanded unless they value
overflow.
.Sp
Da keys up in \f(CW%entity2char\fR is tha entitizzle names ta be expanded n' their
values is what tha fuck they should expand into.  Da joints do not gotta be
single characta strings.  If a key has \*(L";\*(R" as suffix,
then occurrences up in \f(CW$string\fR is only expanded if properly terminated
with \*(L";\*(R".  Entitizzles without \*(L";\*(R" is ghon be expanded regardless of how
they is terminated fo' compatibilitizzle wit how tha fuck common browsers treat
entitizzles up in tha Latin\-1 range.
.Sp
If \f(CW$expand_prefix\fR is \s-1TRUE\s0 then entitizzles without trailin \*(L";\*(R" in
\&\f(CW%entity2char\fR will even be expanded as a prefix of a longer
unrecognized name.  Da longest matchin name up in \f(CW%entity2char\fR will be
used. Y'all KNOW dat shit, muthafucka! This is mainly present fo' compatibilitizzle wit a \s-1MSIE\s0
misfeature.
.Sp
.Vb 3
\&   $strin = "foo&nbspbar";
\&   _decode_entities($string, { nb => "@", nbsp => "\exA0" }, 1);
\&   print $string;  # will print "foo\ bar"
.Ve
.Sp
This routine is exported by default.
.ie n .IP "encode_entities( $strin )" 4
.el .IP "encode_entities( \f(CW$string\fR )" 4
.IX Item "encode_entities( $strin )"
.PD 0
.ie n .IP "encode_entities( $string, $unsafe_chars )" 4
.el .IP "encode_entities( \f(CW$string\fR, \f(CW$unsafe_chars\fR )" 4
.IX Item "encode_entities( $string, $unsafe_chars )"
.PD
This routine replaces unsafe charactas up in \f(CW$string\fR wit they entity
representation. I aint talkin' bout chicken n' gravy biatch fo' realz. A second argument can be given ta specify which charactas to
consider unsafe.  Da unsafe charactas is specified rockin tha regular
expression characta class syntax (what you find within brackets up in regular
expressions).
.Sp
Da default set of charactas ta encode is control chars, high-bit chars, and
the \f(CW\*(C`<\*(C'\fR, \f(CW\*(C`&\*(C'\fR, \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`\*(Aq\*(C'\fR n' \f(CW\*(C`"\*(C'\fR characters.  But this,
for example, would encode \fIjust\fR tha \f(CW\*(C`<\*(C'\fR, \f(CW\*(C`&\*(C'\fR, \f(CW\*(C`>\*(C'\fR, n' \f(CW\*(C`"\*(C'\fR characters:
.Sp
.Vb 1
\&  $encoded = encode_entities($input, \*(Aq<>&"\*(Aq);
.Ve
.Sp
and dis would only encode non-plain ascii:
.Sp
.Vb 1
\&  $encoded = encode_entities($input, \*(Aq^\en\ex20\-\ex25\ex27\-\ex7e\*(Aq);
.Ve
.Sp
This routine is exported by default.
.ie n .IP "encode_entities_numeric( $strin )" 4
.el .IP "encode_entities_numeric( \f(CW$string\fR )" 4
.IX Item "encode_entities_numeric( $strin )"
.PD 0
.ie n .IP "encode_entities_numeric( $string, $unsafe_chars )" 4
.el .IP "encode_entities_numeric( \f(CW$string\fR, \f(CW$unsafe_chars\fR )" 4
.IX Item "encode_entities_numeric( $string, $unsafe_chars )"
.PD
This routine works just like encode_entities, except dat tha replacement
entitizzles is always \f(CW\*(C`&#x\f(CIhexnum\f(CW;\*(C'\fR n' never \f(CW\*(C`&\f(CIentname\f(CW;\*(C'\fR.  For
example, \f(CW\*(C`encode_entities("r\exF4le")\*(C'\fR returns \*(L"r&ocirc;le\*(R" yo, but
\&\f(CW\*(C`encode_entities_numeric("r\exF4le")\*(C'\fR returns \*(L"r&#xF4;le\*(R".
.Sp
This routine is \fInot\fR exported by default.  But you can always
export it wit \f(CW\*(C`use HTML::Entitizzles qw(encode_entities_numeric);\*(C'\fR
or even \f(CW\*(C`use HTML::Entitizzles qw(:DEFAULT encode_entities_numeric);\*(C'\fR
.PP
All these routines modify tha strang passed as tha straight-up original gangsta argument, if
called up in a void context.  In scalar n' array contexts, tha encoded or
decoded strang is returned (without changin tha input string).
.PP
If you prefer not ta import these routines tha fuck into yo' namespace, you can
call dem as:
.PP
.Vb 4
\&  use HTML::Entitizzles ();
\&  $decoded = HTML::Entities::decode($a);
\&  $encoded = HTML::Entities::encode($a);
\&  $encoded = HTML::Entities::encode_numeric($a);
.Ve
.PP
Da module can also export tha \f(CW%char2entity\fR n' tha \f(CW%entity2char\fR
hashes, which contain tha mappin from all charactas ta the
correspondin entitizzles (and vice versa, respectively).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2006 Gisle Aas fo' realz. All muthafuckin rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
