.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser 3"
.TH TAP::Parser 3 "2013-05-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser \- Parse TAP output
.SH "VERSION"
.IX Header "VERSION"
Version 3.28
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser;
\&
\&    mah $parser = TAP::Parser\->new( { source => $source } );
\&
\&    while ( mah $result = $parser\->next ) {
\&        print $result\->as_string;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser\*(C'\fR is designed ta produce a proper parse of \s-1TAP\s0 output. For
an example of how tha fuck ta run tests all up in dis module, peep tha simple
harnesses \f(CW\*(C`examples/\*(C'\fR.
.PP
Therez a wiki all bout tha Test Anythang Protocol:
.PP
<http://testanything.org>
.PP
It includes tha TAP::Parser Cookbook:
.PP
<http://testanything.org/wiki/index.php/TAP::Parser_Cookbook>
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\& mah $parser = TAP::Parser\->new(\e%args);
.Ve
.PP
Returns a freshly smoked up \f(CW\*(C`TAP::Parser\*(C'\fR object.
.PP
Da arguments should be a hashref wit \fIone\fR of tha followin keys:
.IP "\(bu" 4
\&\f(CW\*(C`source\*(C'\fR
.Sp
\&\fI\s-1CHANGED\s0 up in 3.18\fR
.Sp
This is tha preferred method of passin input ta tha constructor.
.Sp
Da \f(CW\*(C`source\*(C'\fR is used ta create a TAP::Parser::Source dat is passed ta the
\&\*(L"iterator_factory_class\*(R" which up in turn figures up how tha fuck ta handle tha source and
creates a <TAP::Parser::Iterator> fo' dat shit.  Da iterator is used by tha parser to
read up in tha \s-1TAP\s0 stream.
.Sp
To configure tha \fIIteratorFactory\fR use tha \f(CW\*(C`sources\*(C'\fR parameta below.
.Sp
Note dat \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR n' \f(CW\*(C`exec\*(C'\fR is \fImutually exclusive\fR.
.IP "\(bu" 4
\&\f(CW\*(C`tap\*(C'\fR
.Sp
\&\fI\s-1CHANGED\s0 up in 3.18\fR
.Sp
Da value should be tha complete \s-1TAP\s0 output.
.Sp
Da \fItap\fR is used ta create a TAP::Parser::Source dat is passed ta the
\&\*(L"iterator_factory_class\*(R" which up in turn figures up how tha fuck ta handle tha source and
creates a <TAP::Parser::Iterator> fo' dat shit.  Da iterator is used by tha parser to
read up in tha \s-1TAP\s0 stream.
.Sp
To configure tha \fIIteratorFactory\fR use tha \f(CW\*(C`sources\*(C'\fR parameta below.
.Sp
Note dat \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR n' \f(CW\*(C`exec\*(C'\fR is \fImutually exclusive\fR.
.IP "\(bu" 4
\&\f(CW\*(C`exec\*(C'\fR
.Sp
Must be passed a array reference.
.Sp
Da \fIexec\fR array ref is used ta create a TAP::Parser::Source dat is passed
to tha \*(L"iterator_factory_class\*(R" which up in turn figures up how tha fuck ta handle the
source n' creates a <TAP::Parser::Iterator> fo' dat shit.  Da iterator is used by
the parser ta read up in tha \s-1TAP\s0 stream.
.Sp
By default tha TAP::Parser::SourceHandlez::Executable class will create a
TAP::Parser::Iterator::Process object ta handle tha source.  This passes the
array reference strings as command arguments ta IPC::Open3::open3:
.Sp
.Vb 1
\& exec => [ \*(Aq/usr/bin/ruby\*(Aq, \*(Aqt/my_test.rb\*(Aq ]
.Ve
.Sp
If any \f(CW\*(C`test_args\*(C'\fR is given they is ghon be appended ta tha end of tha command
argument list.
.Sp
To configure tha \fIIteratorFactory\fR use tha \f(CW\*(C`sources\*(C'\fR parameta below.
.Sp
Note dat \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR n' \f(CW\*(C`exec\*(C'\fR is \fImutually exclusive\fR.
.PP
Da followin keys is optional.
.IP "\(bu" 4
\&\f(CW\*(C`sources\*(C'\fR
.Sp
\&\fI\s-1NEW\s0 ta 3.18\fR.
.Sp
If set, \f(CW\*(C`sources\*(C'\fR must be a hashref containin tha namez of the
TAP::Parser::SourceHandlezs ta load and/or configure.  Da joints is a
hash of configuration dat is ghon be accessible ta ta tha source handlezs via
\&\*(L"config_for\*(R" up in TAP::Parser::Source.
.Sp
For example:
.Sp
.Vb 5
\&  sources => {
\&    Perl => { exec => \*(Aq/path/to/custom/perl\*(Aq },
\&    File => { extensions => [ \*(Aq.tap\*(Aq, \*(Aq.txt\*(Aq ] },
\&    MyCustom => { some => \*(Aqconfig\*(Aq },
\&  }
.Ve
.Sp
This will cause \f(CW\*(C`TAP::Parser\*(C'\fR ta pass custom configuration ta two of tha built\-
in source handlezs \- TAP::Parser::SourceHandlez::Perl,
TAP::Parser::SourceHandlez::File \- n' attempt ta load tha \f(CW\*(C`MyCustom\*(C'\fR
class.  See \*(L"load_handlezs\*(R" up in TAP::Parser::IteratorFactory fo' mo' detail.
.Sp
Da \f(CW\*(C`sources\*(C'\fR parameta affects how tha fuck \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`tap\*(C'\fR n' \f(CW\*(C`exec\*(C'\fR parameters
are handled.
.Sp
See TAP::Parser::IteratorFactory, TAP::Parser::SourceHandlez n' subclasses for
more details.
.IP "\(bu" 4
\&\f(CW\*(C`callback\*(C'\fR
.Sp
If present, each callback correspondin ta a given result type is ghon be called
with tha result as tha argument if tha \f(CW\*(C`run\*(C'\fR method is used:
.Sp
.Vb 7
\& mah %callbacks = (
\&     test    => \e&test_callback,
\&     plan    => \e&plan_callback,
\&     comment => \e&comment_callback,
\&     bailout => \e&bailout_callback,
\&     unknown => \e&unknown_callback,
\& );
\&
\& mah $aggregator = TAP::Parser::Aggregator\->new;
\& fo' mah $file ( @test_filez ) {
\&     mah $parser = TAP::Parser\->new(
\&         {
\&             source    => $file,
\&             callbacks => \e%callbacks,
\&         }
\&     );
\&     $parser\->run;
\&     $aggregator\->add( $file, $parser );
\& }
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`switches\*(C'\fR
.Sp
If rockin a Perl file as a source, optionizzle switches may be passed which will
be used when invokin tha perl executable.
.Sp
.Vb 4
\& mah $parser = TAP::Parser\->new( {
\&     source   => $test_file,
\&     switches => [ \*(Aq\-Ilib\*(Aq ],
\& } );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`test_args\*(C'\fR
.Sp
Used up in conjunction wit tha \f(CW\*(C`source\*(C'\fR n' \f(CW\*(C`exec\*(C'\fR option ta supply a reference
to a \f(CW@ARGV\fR steez array of arguments ta pass ta tha test program.
.IP "\(bu" 4
\&\f(CW\*(C`spool\*(C'\fR
.Sp
If passed a gangbangin' filehandle will write a cold-ass lil copy of all parsed \s-1TAP\s0 ta dat handle.
.IP "\(bu" 4
\&\f(CW\*(C`merge\*(C'\fR
.Sp
If false, \s-1STDERR\s0 aint captured (though it is 'relayed' ta keep it
somewhat synchronized wit \s-1STDOUT.\s0)
.Sp
If true, \s-1STDERR\s0 n' \s-1STDOUT\s0 is tha same filehandle.  This may cause
breakage if \s-1STDERR\s0 gotz nuff anythang resemblin \s-1TAP\s0 format yo, but do
allow exact synchronization.
.Sp
Subtletizzlez of dis behavior may be platform-dependent n' may chizzle in
the future.
.IP "\(bu" 4
\&\f(CW\*(C`grammar_class\*(C'\fR
.Sp
This option was introduced ta let you easily customize which \fIgrammar\fR class
the parser should use.  It defaults ta TAP::Parser::Grammar.
.Sp
See also \*(L"make_grammar\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`result_factory_class\*(C'\fR
.Sp
This option was introduced ta let you easily customize which \fIresult\fR
factory class tha parser should use.  It defaults to
TAP::Parser::ResultFactory.
.Sp
See also \*(L"make_result\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`iterator_factory_class\*(C'\fR
.Sp
\&\fI\s-1CHANGED\s0 up in 3.18\fR
.Sp
This option was introduced ta let you easily customize which \fIiterator\fR
factory class tha parser should use.  It defaults to
TAP::Parser::IteratorFactory.
.SS "Instizzle Methods"
.IX Subsection "Instizzle Methods"
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
.Vb 4
\&  mah $parser = TAP::Parser\->new( { source => $file } );
\&  while ( mah $result = $parser\->next ) {
\&      print $result\->as_string, "\en";
\&  }
.Ve
.PP
This method returns tha thangs up in dis biatch of tha parsing, one result at a time.  Note
that it is destructive.  Yo ass can't rewind n' examine previous thangs up in dis biatch.
.PP
If callbacks is used, they is ghon be issued before dis call returns.
.PP
Each result returned be a subclass of TAP::Parser::Result.  See that
module n' related classes fo' mo' shiznit on how tha fuck ta use em.
.PP
\fI\f(CI\*(C`run\*(C'\fI\fR
.IX Subsection "run"
.PP
.Vb 1
\&  $parser\->run;
.Ve
.PP
This method merely runs tha parser n' parses all of tha \s-1TAP.\s0
.PP
\fI\f(CI\*(C`make_grammar\*(C'\fI\fR
.IX Subsection "make_grammar"
.PP
Make a freshly smoked up TAP::Parser::Grammar object n' return dat shit.  Passes all up in any
arguments given.
.PP
Da \f(CW\*(C`grammar_class\*(C'\fR can be customized, as busted lyrics bout up in \*(L"new\*(R".
.PP
\fI\f(CI\*(C`make_result\*(C'\fI\fR
.IX Subsection "make_result"
.PP
Make a freshly smoked up TAP::Parser::Result object rockin tha parser's
TAP::Parser::ResultFactory, n' return dat shit.  Passes all up in any arguments
given.
.PP
Da \f(CW\*(C`result_factory_class\*(C'\fR can be customized, as busted lyrics bout up in \*(L"new\*(R".
.PP
\fI\f(CI\*(C`make_iterator_factory\*(C'\fI\fR
.IX Subsection "make_iterator_factory"
.PP
\&\fI\s-1NEW\s0 ta 3.18\fR.
.PP
Make a freshly smoked up TAP::Parser::IteratorFactory object n' return dat shit.  Passes through
any arguments given.
.PP
\&\f(CW\*(C`iterator_factory_class\*(C'\fR can be customized, as busted lyrics bout up in \*(L"new\*(R".
.SH "INDIVIDUAL RESULTS"
.IX Header "INDIVIDUAL RESULTS"
If you've read dis far up in tha docs, you've peeped this:
.PP
.Vb 3
\&    while ( mah $result = $parser\->next ) {
\&        print $result\->as_string;
\&    }
.Ve
.PP
Each result returned be a TAP::Parser::Result subclass, referred ta as
\&\fIresult types\fR.
.SS "Result types"
.IX Subsection "Result types"
Basically, you fetch individual thangs up in dis biatch from tha \s-1TAP. \s0 Da six types, with
examplez of each, is as bigs up:
.IP "\(bu" 4
Version
.Sp
.Vb 1
\& TAP version 12
.Ve
.IP "\(bu" 4
Plan
.Sp
.Vb 1
\& 1..42
.Ve
.IP "\(bu" 4
Pragma
.Sp
.Vb 1
\& pragma +strict
.Ve
.IP "\(bu" 4
Test
.Sp
.Vb 1
\& aiiight 3 \- We should start wit some foobar!
.Ve
.IP "\(bu" 4
Comment
.Sp
.Vb 1
\& # Hope our phat asses don\*(Aqt use up tha foobar.
.Ve
.IP "\(bu" 4
Bailout
.Sp
.Vb 1
\& Bail up son!  We ran outta foobar!
.Ve
.IP "\(bu" 4
Unknown
.Sp
.Vb 1
\& ... yo, dis ain\*(Aqt TAP! ...
.Ve
.PP
Each result fetched be a result object of a gangbangin' finger-lickin' different type.  There is common
methodz ta each result object n' different types may have methodz unique to
their type.  Sometimes a type method may be overridden up in a subclass yo, but its
use is guaranteed ta be identical.
.SS "Common type methods"
.IX Subsection "Common type methods"
\fI\f(CI\*(C`type\*(C'\fI\fR
.IX Subsection "type"
.PP
Returns tha type of result, like fuckin \f(CW\*(C`comment\*(C'\fR or \f(CW\*(C`test\*(C'\fR.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
Prints a strang representation of tha token. I aint talkin' bout chicken n' gravy biatch.  This might not be tha exact
output, however n' shit.  Tests gonna git test numbers added if not present, \s-1TODO\s0 and
\&\s-1SKIP\s0 directives is ghon be capitalized and, up in general, thangs is ghon be cleaned
up.  If you need tha original gangsta text fo' tha token, peep tha \f(CW\*(C`raw\*(C'\fR method.
.PP
\fI\f(CI\*(C`raw\*(C'\fI\fR
.IX Subsection "raw"
.PP
Returns tha original gangsta line of text which was parsed.
.PP
\fI\f(CI\*(C`is_plan\*(C'\fI\fR
.IX Subsection "is_plan"
.PP
Indicates whether or not dis is tha test plan line.
.PP
\fI\f(CI\*(C`is_test\*(C'\fI\fR
.IX Subsection "is_test"
.PP
Indicates whether or not dis be a test line.
.PP
\fI\f(CI\*(C`is_comment\*(C'\fI\fR
.IX Subsection "is_comment"
.PP
Indicates whether or not dis be a cold-ass lil comment. Comments will generally only
appear up in tha \s-1TAP\s0 stream if \s-1STDERR\s0 is merged ta \s-1STDOUT.\s0 See the
\&\f(CW\*(C`merge\*(C'\fR option.
.PP
\fI\f(CI\*(C`is_bailout\*(C'\fI\fR
.IX Subsection "is_bailout"
.PP
Indicates whether or not dis is bailout line.
.PP
\fI\f(CI\*(C`is_yaml\*(C'\fI\fR
.IX Subsection "is_yaml"
.PP
Indicates whether or not tha current item be a \s-1YAML\s0 block.
.PP
\fI\f(CI\*(C`is_unknown\*(C'\fI\fR
.IX Subsection "is_unknown"
.PP
Indicates whether or not tha current line could be parsed.
.PP
\fI\f(CI\*(C`is_ok\*(C'\fI\fR
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result\->is_ok ) { ... }
.Ve
.PP
Reports whether or not a given result has passed. Y'all KNOW dat shit, muthafucka!  Anythang which is \fBnot\fR a
test result returns true.  This is merely provided as a cold-ass lil convenient shortcut
which allows you ta do this:
.PP
.Vb 5
\& mah $parser = TAP::Parser\->new( { source => $source } );
\& while ( mah $result = $parser\->next ) {
\&     # only print failin thangs up in dis biatch
\&     print $result\->as_strin unless $result\->is_ok;
\& }
.Ve
.ie n .SS """plan"" methods"
.el .SS "\f(CWplan\fP methods"
.IX Subsection "plan methods"
.Vb 1
\& if ( $result\->is_plan ) { ... }
.Ve
.PP
If tha above evaluates as true, tha followin methodz is ghon be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`plan\*(C'\fI\fR
.IX Subsection "plan"
.PP
.Vb 3
\&  if ( $result\->is_plan ) {
\&     print $result\->plan;
\&  }
.Ve
.PP
This is merely a synonym fo' \f(CW\*(C`as_string\*(C'\fR.
.PP
\fI\f(CI\*(C`directive\*(C'\fI\fR
.IX Subsection "directive"
.PP
.Vb 1
\& mah $directizzle = $result\->directive;
.Ve
.PP
If a \s-1SKIP\s0 directizzle is included wit tha plan, dis method will return dat shit.
.PP
.Vb 1
\& 1..0 # SKIP: why bother?
.Ve
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 1
\& mah $explanation = $result\->explanation;
.Ve
.PP
If a \s-1SKIP\s0 directizzle was included wit tha plan, dis method will return the
explanation, if any.
.ie n .SS """pragma"" methods"
.el .SS "\f(CWpragma\fP methods"
.IX Subsection "pragma methods"
.Vb 1
\& if ( $result\->is_pragma ) { ... }
.Ve
.PP
If tha above evaluates as true, tha followin methodz is ghon be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`pragmas\*(C'\fI\fR
.IX Subsection "pragmas"
.PP
Returns a list of pragmas each of which be a + or \- followed by the
pragma name.
.ie n .SS """comment"" methods"
.el .SS "\f(CWcomment\fP methods"
.IX Subsection "comment methods"
.Vb 1
\& if ( $result\->is_comment ) { ... }
.Ve
.PP
If tha above evaluates as true, tha followin methodz is ghon be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`comment\*(C'\fI\fR
.IX Subsection "comment"
.PP
.Vb 4
\&  if ( $result\->is_comment ) {
\&      mah $comment = $result\->comment;
\&      print "I have suttin' ta say:  $comment";
\&  }
.Ve
.ie n .SS """bailout"" methods"
.el .SS "\f(CWbailout\fP methods"
.IX Subsection "bailout methods"
.Vb 1
\& if ( $result\->is_bailout ) { ... }
.Ve
.PP
If tha above evaluates as true, tha followin methodz is ghon be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 4
\&  if ( $result\->is_bailout ) {
\&      mah $explanation = $result\->explanation;
\&      print "We bailed up cuz ($explanation)";
\&  }
.Ve
.PP
If, n' only if, a token be a funky-ass bailout token, you can git a \*(L"explanation\*(R" via
this method. Y'all KNOW dat shit, muthafucka!  Da explanation is tha text afta tha mystical \*(L"Bail out!\*(R" lyrics
which step tha fuck up in tha tap output.
.ie n .SS """unknown"" methods"
.el .SS "\f(CWunknown\fP methods"
.IX Subsection "unknown methods"
.Vb 1
\& if ( $result\->is_unknown ) { ... }
.Ve
.PP
There is no unique methodz fo' unknown thangs up in dis biatch.
.ie n .SS """test"" methods"
.el .SS "\f(CWtest\fP methods"
.IX Subsection "test methods"
.Vb 1
\& if ( $result\->is_test ) { ... }
.Ve
.PP
If tha above evaluates as true, tha followin methodz is ghon be available on the
\&\f(CW$result\fR object.
.PP
\fI\f(CI\*(C`ok\*(C'\fI\fR
.IX Subsection "ok"
.PP
.Vb 1
\&  mah $ok = $result\->ok;
.Ve
.PP
Returns tha literal text of tha \f(CW\*(C`ok\*(C'\fR or \f(CW\*(C`not ok\*(C'\fR status.
.PP
\fI\f(CI\*(C`number\*(C'\fI\fR
.IX Subsection "number"
.PP
.Vb 1
\&  mah $test_number = $result\->number;
.Ve
.PP
Returns tha number of tha test, even if tha original gangsta \s-1TAP\s0 output did not supply
that number.
.PP
\fI\f(CI\*(C`description\*(C'\fI\fR
.IX Subsection "description"
.PP
.Vb 1
\&  mah $description = $result\->description;
.Ve
.PP
Returns tha description of tha test, if any.  This is tha portion afta the
test number but before tha directive.
.PP
\fI\f(CI\*(C`directive\*(C'\fI\fR
.IX Subsection "directive"
.PP
.Vb 1
\&  mah $directizzle = $result\->directive;
.Ve
.PP
Returns either \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR if either directizzle was present fo' a test
line.
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 1
\&  mah $explanation = $result\->explanation;
.Ve
.PP
If a test had either a \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR directive, dis method will return
the accompanyin explanation, if present.
.PP
.Vb 1
\&  not aiiight 17 \- \*(AqPigs can fly\*(Aq # TODO not enough acid
.Ve
.PP
For tha above line, tha explanation is \fInot enough acid\fR.
.PP
\fI\f(CI\*(C`is_ok\*(C'\fI\fR
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result\->is_ok ) { ... }
.Ve
.PP
Returns a funky-ass boolean value indicatin whether or not tha test passed. Y'all KNOW dat shit, muthafucka!  Remember
that fo' \s-1TODO\s0 tests, tha test always passes.
.PP
\&\fBNote:\fR  dis was formerly \f(CW\*(C`passed\*(C'\fR.  Da latta method is deprecated and
will issue a warning.
.PP
\fI\f(CI\*(C`is_actual_ok\*(C'\fI\fR
.IX Subsection "is_actual_ok"
.PP
.Vb 1
\&  if ( $result\->is_actual_ok ) { ... }
.Ve
.PP
Returns a funky-ass boolean value indicatin whether or not tha test passed, regardless
of its \s-1TODO\s0 status.
.PP
\&\fBNote:\fR  dis was formerly \f(CW\*(C`actual_passed\*(C'\fR.  Da latta method is deprecated
and will issue a warning.
.PP
\fI\f(CI\*(C`is_unplanned\*(C'\fI\fR
.IX Subsection "is_unplanned"
.PP
.Vb 1
\&  if ( $test\->is_unplanned ) { ... }
.Ve
.PP
If a test number is pimped outa than tha number of planned tests, dis method will
return true.  Unplanned tests will \fIalways\fR return false fo' \f(CW\*(C`is_ok\*(C'\fR,
regardless of whether or not tha test \f(CW\*(C`has_todo\*(C'\fR (see
TAP::Parser::Result::Test fo' mo' shiznit bout this).
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 1
\&  if ( $result\->has_skip ) { ... }
.Ve
.PP
Returns a funky-ass boolean value indicatin whether or not dis test had a \s-1SKIP\s0
directive.
.PP
\fI\f(CI\*(C`has_todo\*(C'\fI\fR
.IX Subsection "has_todo"
.PP
.Vb 1
\&  if ( $result\->has_todo ) { ... }
.Ve
.PP
Returns a funky-ass boolean value indicatin whether or not dis test had a \s-1TODO\s0
directive.
.PP
Note dat \s-1TODO\s0 tests \fIalways\fR pass.  If you need ta know whether or not
they straight-up passed, check tha \f(CW\*(C`is_actual_ok\*(C'\fR method.
.PP
\fI\f(CI\*(C`in_todo\*(C'\fI\fR
.IX Subsection "in_todo"
.PP
.Vb 1
\&  if ( $parser\->in_todo ) { ... }
.Ve
.PP
True while da most thugged-out recent result was a \s-1TODO.\s0 Becomes legit before the
\&\s-1TODO\s0 result is returned n' stays legit until just before tha next non\-
\&\s-1TODO\s0 test is returned.
.SH "TOTAL RESULTS"
.IX Header "TOTAL RESULTS"
Afta parsin tha \s-1TAP,\s0 there be nuff methodz available ta let you dig through
the thangs up in dis biatch n' determine what tha fuck is meaningful ta yo thugged-out ass.
.SS "Individual Results"
.IX Subsection "Individual Results"
These thangs up in dis biatch refer ta individual tests which is run.
.PP
\fI\f(CI\*(C`passed\*(C'\fI\fR
.IX Subsection "passed"
.PP
.Vb 2
\& mah @passed = $parser\->passed; # tha test numbers which passed
\& mah $passed = $parser\->passed; # tha number of tests which passed
.Ve
.PP
This method lets you know which (or how tha fuck many) tests passed. Y'all KNOW dat shit, muthafucka!  If a test failed
but had a \s-1TODO\s0 directive, it is ghon be counted as a passed test.
.PP
\fI\f(CI\*(C`failed\*(C'\fI\fR
.IX Subsection "failed"
.PP
.Vb 2
\& mah @failed = $parser\->failed; # tha test numbers which failed
\& mah $failed = $parser\->failed; # tha number of tests which failed
.Ve
.PP
This method lets you know which (or how tha fuck many) tests failed. Y'all KNOW dat shit, muthafucka!  If a test passed
but had a \s-1TODO\s0 directive, it will \fB\s-1NOT\s0\fR be counted as a gangbangin' failed test.
.PP
\fI\f(CI\*(C`actual_passed\*(C'\fI\fR
.IX Subsection "actual_passed"
.PP
.Vb 2
\& # tha test numbers which straight-up passed
\& mah @actual_passed = $parser\->actual_passed;
\&
\& # tha number of tests which straight-up passed
\& mah $actual_passed = $parser\->actual_passed;
.Ve
.PP
This method lets you know which (or how tha fuck many) tests straight-up passed,
regardless of whether or not a \s-1TODO\s0 directizzle was found.
.PP
\fI\f(CI\*(C`actual_ok\*(C'\fI\fR
.IX Subsection "actual_ok"
.PP
This method be a synonym fo' \f(CW\*(C`actual_passed\*(C'\fR.
.PP
\fI\f(CI\*(C`actual_failed\*(C'\fI\fR
.IX Subsection "actual_failed"
.PP
.Vb 2
\& # tha test numbers which straight-up failed
\& mah @actual_failed = $parser\->actual_failed;
\&
\& # tha number of tests which straight-up failed
\& mah $actual_failed = $parser\->actual_failed;
.Ve
.PP
This method lets you know which (or how tha fuck many) tests straight-up failed,
regardless of whether or not a \s-1TODO\s0 directizzle was found.
.PP
\fI\f(CI\*(C`todo\*(C'\fI\fR
.IX Subsection "todo"
.PP
.Vb 2
\& mah @todo = $parser\->todo; # tha test numbers wit todo directives
\& mah $todo = $parser\->todo; # tha number of tests wit todo directives
.Ve
.PP
This method lets you know which (or how tha fuck many) tests had \s-1TODO\s0 directives.
.PP
\fI\f(CI\*(C`todo_passed\*(C'\fI\fR
.IX Subsection "todo_passed"
.PP
.Vb 2
\& # tha test numbers which unexpectedly succeeded
\& mah @todo_passed = $parser\->todo_passed;
\&
\& # tha number of tests which unexpectedly succeeded
\& mah $todo_passed = $parser\->todo_passed;
.Ve
.PP
This method lets you know which (or how tha fuck many) tests straight-up passed but were
declared as \*(L"\s-1TODO\*(R"\s0 tests.
.PP
\fI\f(CI\*(C`todo_failed\*(C'\fI\fR
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated up in favor of \*(Aqtodo_passed\*(Aq.  This method was horribly misnamed.
.Ve
.PP
This was a funky-ass badly misnamed method. Y'all KNOW dat shit, muthafucka!  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded. Y'all KNOW dat shit, muthafucka!  Will now issue a warnin n' call \f(CW\*(C`todo_passed\*(C'\fR.
.PP
\fI\f(CI\*(C`skipped\*(C'\fI\fR
.IX Subsection "skipped"
.PP
.Vb 2
\& mah @skipped = $parser\->skipped; # tha test numbers wit SKIP directives
\& mah $skipped = $parser\->skipped; # tha number of tests wit SKIP directives
.Ve
.PP
This method lets you know which (or how tha fuck many) tests had \s-1SKIP\s0 directives.
.SS "Pragmas"
.IX Subsection "Pragmas"
\fI\f(CI\*(C`pragma\*(C'\fI\fR
.IX Subsection "pragma"
.PP
Git or set a pragma. To git tha state of a pragma:
.PP
.Vb 3
\&  if ( $p\->pragma(\*(Aqstrict\*(Aq) ) {
\&      # be strict
\&  }
.Ve
.PP
To set tha state of a pragma:
.PP
.Vb 1
\&  $p\->pragma(\*(Aqstrict\*(Aq, 1); # enable strict mode
.Ve
.PP
\fI\f(CI\*(C`pragmas\*(C'\fI\fR
.IX Subsection "pragmas"
.PP
Git a list of all tha currently enabled pragmas:
.PP
.Vb 1
\&  mah @pragmas_enabled = $p\->pragmas;
.Ve
.SS "Summary Results"
.IX Subsection "Summary Results"
These thangs up in dis biatch is \*(L"meta\*(R" shiznit bout tha total thangs up in dis biatch of a individual
test program.
.PP
\fI\f(CI\*(C`plan\*(C'\fI\fR
.IX Subsection "plan"
.PP
.Vb 1
\& mah $plan = $parser\->plan;
.Ve
.PP
Returns tha test plan, if found.
.PP
\fI\f(CI\*(C`good_plan\*(C'\fI\fR
.IX Subsection "good_plan"
.PP
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use \f(CW\*(C`is_good_plan\*(C'\fR instead.
.PP
\fI\f(CI\*(C`is_good_plan\*(C'\fI\fR
.IX Subsection "is_good_plan"
.PP
.Vb 1
\&  if ( $parser\->is_good_plan ) { ... }
.Ve
.PP
Returns a funky-ass boolean value indicatin whether or not tha number of tests planned
matches tha number of tests run.
.PP
\&\fBNote:\fR  dis was formerly \f(CW\*(C`good_plan\*(C'\fR.  Da latta method is deprecated and
will issue a warning.
.PP
And since we on dat subject ...
.PP
\fI\f(CI\*(C`tests_planned\*(C'\fI\fR
.IX Subsection "tests_planned"
.PP
.Vb 1
\&  print $parser\->tests_planned;
.Ve
.PP
Returns tha number of tests planned, accordin ta tha plan. I aint talkin' bout chicken n' gravy biatch.  For example, a
plan of '1..17' will mean dat 17 tests was planned.
.PP
\fI\f(CI\*(C`tests_run\*(C'\fI\fR
.IX Subsection "tests_run"
.PP
.Vb 1
\&  print $parser\->tests_run;
.Ve
.PP
Returns tha number of tests which straight-up was run. I aint talkin' bout chicken n' gravy biatch.  Hopefully dis will
match tha number of \f(CW\*(C`$parser\->tests_planned\*(C'\fR.
.PP
\fI\f(CI\*(C`skip_all\*(C'\fI\fR
.IX Subsection "skip_all"
.PP
Returns a legit value (actually tha reason fo' skipping) if all tests
were skipped.
.PP
\fI\f(CI\*(C`start_time\*(C'\fI\fR
.IX Subsection "start_time"
.PP
Returns tha time when tha Parser was pimped.
.PP
\fI\f(CI\*(C`end_time\*(C'\fI\fR
.IX Subsection "end_time"
.PP
Returns tha time when tha end of \s-1TAP\s0 input was seen.
.PP
\fI\f(CI\*(C`has_problems\*(C'\fI\fR
.IX Subsection "has_problems"
.PP
.Vb 3
\&  if ( $parser\->has_problems ) {
\&      ...
\&  }
.Ve
.PP
This be a 'catch\-all' method which returns legit if any tests have currently
failed, any \s-1TODO\s0 tests unexpectedly succeeded, or any parse errors occurred.
.PP
\fI\f(CI\*(C`version\*(C'\fI\fR
.IX Subsection "version"
.PP
.Vb 1
\&  $parser\->version;
.Ve
.PP
Once tha parser is done, dis will return tha version number fo' the
parsed \s-1TAP.\s0 Version numbers was introduced wit \s-1TAP\s0 version 13 so if no
version number is found version 12 be assumed.
.PP
\fI\f(CI\*(C`exit\*(C'\fI\fR
.IX Subsection "exit"
.PP
.Vb 1
\&  $parser\->exit;
.Ve
.PP
Once tha parser is done, dis will return tha exit status.  If tha parser ran
an executable, it returns tha exit statuz of tha executable.
.PP
\fI\f(CI\*(C`wait\*(C'\fI\fR
.IX Subsection "wait"
.PP
.Vb 1
\&  $parser\->wait;
.Ve
.PP
Once tha parser is done, dis will return tha wait status.  If tha parser ran
an executable, it returns tha wait statuz of tha executable.  Otherwise, this
merely returns tha \f(CW\*(C`exit\*(C'\fR status.
.ie n .SS """ignore_exit"""
.el .SS "\f(CWignore_exit\fP"
.IX Subsection "ignore_exit"
.Vb 1
\&  $parser\->ignore_exit(1);
.Ve
.PP
Tell tha parser ta ignore tha exit status from tha test when determining
whether tha test passed. Y'all KNOW dat shit, muthafucka! Normally tests wit non-zero exit status are
considered ta have failed even if all individual tests passed. Y'all KNOW dat shit, muthafucka! In cases
where it aint possible ta control tha exit value of tha test script
use dis option ta ignore dat shit.
.PP
\fI\f(CI\*(C`parse_errors\*(C'\fI\fR
.IX Subsection "parse_errors"
.PP
.Vb 2
\& mah @errors = $parser\->parse_errors; # tha parser errors
\& mah $errors = $parser\->parse_errors; # tha number of parser_errors
.Ve
.PP
Fortunately, all \s-1TAP\s0 output is perfect.  In tha event dat it is not, this
method will return parser errors.  Note dat a junk line which tha parser do
not recognize is \f(CW\*(C`not\*(C'\fR a error. Shiiit, dis aint no joke.  This allows dis parser ta handle future
versionz of \s-1TAP. \s0 Da followin is all \s-1TAP\s0 errors reported by tha parser:
.IP "\(bu" 4
Misplaced plan
.Sp
Da plan (for example, '1..5'), must only come all up in tha beginnin or end of the
\&\s-1TAP\s0 output.
.IP "\(bu" 4
No plan
.Sp
Gotta gotz a plan!
.IP "\(bu" 4
Mo' than one plan
.Sp
.Vb 5
\& 1..3
\& aiiight 1 \- input file opened
\& not aiiight 2 \- first line of tha input valid # todo some data
\& aiiight 3 read tha rest of tha file
\& 1..3
.Ve
.Sp
Right.  Straight-up funky.  Don't do dis shit.
.IP "\(bu" 4
Test numbers outta sequence
.Sp
.Vb 4
\& 1..3
\& aiiight 1 \- input file opened
\& not aiiight 2 \- first line of tha input valid # todo some data
\& aiiight 2 read tha rest of tha file
.Ve
.Sp
That last test line above should have tha number '3' instead of '2'.
.Sp
Note dat itz perfectly aaight fo' some lines ta have test numbers and
others ta not have em.  But fuck dat shiznit yo, tha word on tha street is dat when a test number is found, it must be in
sequence.  Da followin be also a error:
.Sp
.Vb 4
\& 1..3
\& aiiight 1 \- input file opened
\& not aiiight \- first line of tha input valid # todo some data
\& aiiight 2 read tha rest of tha file
.Ve
.Sp
But dis is not:
.Sp
.Vb 4
\& 1..3
\& aiiight  \- input file opened
\& not aiiight \- first line of tha input valid # todo some data
\& aiiight 3 read tha rest of tha file
.Ve
.PP
\fI\f(CI\*(C`get_select_handles\*(C'\fI\fR
.IX Subsection "get_select_handles"
.PP
Git a a list of file handlez which can be passed ta \f(CW\*(C`select\*(C'\fR to
determine tha readinizz of dis parser.
.PP
\fI\f(CI\*(C`delete_spool\*(C'\fI\fR
.IX Subsection "delete_spool"
.PP
Delete n' return tha spool.
.PP
.Vb 1
\&  mah $fh = $parser\->delete_spool;
.Ve
.SH "CALLBACKS"
.IX Header "CALLBACKS"
As mentioned earlier, a \*(L"callback\*(R" key may be added ta the
\&\f(CW\*(C`TAP::Parser\*(C'\fR constructor. Shiiit, dis aint no joke. If present, each callback correspondin ta a
given result type is ghon be called wit tha result as tha argument if the
\&\f(CW\*(C`run\*(C'\fR method is used. Y'all KNOW dat shit, muthafucka! Da callback is sposed ta fuckin be a subroutine
reference (or anonymous subroutine) which is invoked wit tha parser
result as its argument.
.PP
.Vb 7
\& mah %callbacks = (
\&     test    => \e&test_callback,
\&     plan    => \e&plan_callback,
\&     comment => \e&comment_callback,
\&     bailout => \e&bailout_callback,
\&     unknown => \e&unknown_callback,
\& );
\&
\& mah $aggregator = TAP::Parser::Aggregator\->new;
\& fo' mah $file ( @test_filez ) {
\&     mah $parser = TAP::Parser\->new(
\&         {
\&             source    => $file,
\&             callbacks => \e%callbacks,
\&         }
\&     );
\&     $parser\->run;
\&     $aggregator\->add( $file, $parser );
\& }
.Ve
.PP
Callbacks may also be added like this:
.PP
.Vb 2
\& $parser\->callback( test => \e&test_callback );
\& $parser\->callback( plan => \e&plan_callback );
.Ve
.PP
Da followin keys allowed fo' callbacks. These keys is case-sensitive.
.IP "\(bu" 4
\&\f(CW\*(C`test\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_test\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`version\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_version\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`plan\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_plan\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`comment\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_comment\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`bailout\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_unknown\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`yaml\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_yaml\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`unknown\*(C'\fR
.Sp
Invoked if \f(CW\*(C`$result\->is_unknown\*(C'\fR returns true.
.IP "\(bu" 4
\&\f(CW\*(C`ELSE\*(C'\fR
.Sp
If a result aint gots a cold-ass lil callback defined fo' it, dis callback will
be invoked. Y'all KNOW dat shit, muthafucka! Thus, if all of tha previous result types is specified as
callbacks, dis callback will \fInever\fR be invoked.
.IP "\(bu" 4
\&\f(CW\*(C`ALL\*(C'\fR
.Sp
This callback will always be invoked n' dis will happen fo' each
result afta one of tha above callbacks is invoked. Y'all KNOW dat shit, muthafucka!  For example, if
Term::ANSIColor is loaded, you could use tha followin ta color your
test output:
.Sp
.Vb 12
\& mah %callbacks = (
\&     test => sub {
\&         mah $test = shift;
\&         if ( $test\->is_ok && not $test\->directizzle ) {
\&             # aiiight passin test
\&             print color \*(Aqgreen\*(Aq;
\&         }
\&         elsif ( !$test\->is_ok ) {    # even if it\*(Aqs TODO
\&             print color \*(Aqwhite on_red\*(Aq;
\&         }
\&         elsif ( $test\->has_skip ) {
\&             print color \*(Aqwhite on_blue\*(Aq;
\&
\&         }
\&         elsif ( $test\->has_todo ) {
\&             print color \*(Aqwhite\*(Aq;
\&         }
\&     },
\&     ELSE => sub {
\&         # plan, comment, n' so on (anythang which isn\*(Aqt a test line)
\&         print color \*(Aqblack on_white\*(Aq;
\&     },
\&     ALL => sub {
\&         # now print them
\&         print shift\->as_string;
\&         print color \*(Aqreset\*(Aq;
\&         print "\en";
\&     },
\& );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`EOF\*(C'\fR
.Sp
Invoked when there be no mo' lines ta be parsed. Y'all KNOW dat shit, muthafucka! Since there is no
accompanyin TAP::Parser::Result object tha \f(CW\*(C`TAP::Parser\*(C'\fR object is
passed instead.
.SH "TAP GRAMMAR"
.IX Header "TAP GRAMMAR"
If you lookin fo' a \s-1EBNF\s0 grammar, peep TAP::Parser::Grammar.
.SH "BACKWARDS COMPATIBILITY"
.IX Header "BACKWARDS COMPATIBILITY"
Da Perl-QA list attempted ta ensure backwardz compatibilitizzle with
Test::Harness.  But fuck dat shiznit yo, tha word on tha street is dat there be some minor differences.
.SS "Differences"
.IX Subsection "Differences"
.IP "\(bu" 4
\&\s-1TODO\s0 plans
.Sp
A lil-known feature of Test::Harnizz is dat it supported \s-1TODO\s0
lists up in tha plan:
.Sp
.Vb 3
\& 1..2 todo 2
\& aiiight 1 \- Our thugged-out asses have liftoff
\& not aiiight 2 \- Anti\-gravitizzle thang activated
.Ve
.Sp
Under Test::Harness, test number 2 would \fIpass\fR cuz it was
listed as a \s-1TODO\s0 test on tha plan line. But fuck dat shiznit yo, tha word on tha street is dat we is not aware of
mah playas straight-up rockin dis feature n' hard-codin test numbers is
discouraged cuz itz straight-up easy as fuck  ta add a test n' break tha test
number sequence. This make test suites straight-up fragile. Instead, the
followin should be used:
.Sp
.Vb 3
\& 1..2
\& aiiight 1 \- Our thugged-out asses have liftoff
\& not aiiight 2 \- Anti\-gravitizzle thang activated # TODO
.Ve
.IP "\(bu" 4
\&'Missing' tests
.Sp
It rarely happens yo, but sometimes a harnizz might encounter
\&'missin tests:
.Sp
.Vb 5
\& aiiight 1
\& aiiight 2
\& aiiight 15
\& aiiight 16
\& aiiight 17
.Ve
.Sp
Test::Harnizz would report tests 3\-14 as havin failed. Y'all KNOW dat shit, muthafucka! For the
\&\f(CW\*(C`TAP::Parser\*(C'\fR, these tests is not considered failed cuz they've
never run. I aint talkin' bout chicken n' gravy biatch. They're reported as parse failures (tests outta sequence).
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
If you find you need ta provide custom functionalitizzle (as you would have using
Test::Harness::Straps), you up in luck: \f(CW\*(C`TAP::Parser\*(C'\fR n' playaz are
designed ta be easily plugged-into and/or subclassed.
.PP
Before you start, itz blingin ta know all dem thangs:
.IP "1." 2
All \f(CW\*(C`TAP::*\*(C'\fR objects inherit from TAP::Object.
.IP "2." 2
Many \f(CW\*(C`TAP::*\*(C'\fR classes gotz a \fI\s-1SUBCLASSING\s0\fR section ta guide yo thugged-out ass.
.IP "3." 2
Note dat \f(CW\*(C`TAP::Parser\*(C'\fR is designed ta be tha central \*(L"maker\*(R" \- ie: it is
responsible fo' bustin most freshly smoked up objects up in tha \f(CW\*(C`TAP::Parser::*\*(C'\fR namespace.
.Sp
This make it possible fo' you ta git a single point of configurin what
subclasses should be used, which means dat up in nuff cases you gonna find
you only need ta sub-class one of tha parserz components.
.Sp
Da exception ta dis rule is \fISourceHandlezs\fR & \fIIterators\fR yo, but dem are
both pimped wit customizable \fIIteratorFactory\fR.
.IP "4." 2
By subclassing, you may end up overridin undocumented methods.  Thatz not
a wack thang per se yo, but be forewarned dat undocumented methodz may chizzle
without warnin from one release ta tha next \- we cannot guarantee backwards
compatibility.  If any \fIdocumented\fR method needz changing, it will be
deprecated first, n' chizzled up in a lata release.
.SS "Parser Components"
.IX Subsection "Parser Components"
\fISources\fR
.IX Subsection "Sources"
.PP
A \s-1TAP\s0 parser consumes input from a single \fIraw source\fR of \s-1TAP,\s0 which could come
from anywhere (a file, a executable, a thugged-out database, a \s-1IO\s0 handle, a \s-1URI,\s0 etc..).
Da source gets bundled up in a TAP::Parser::Source object which gathers some
meta data bout dat shit.  Da parser then uses a TAP::Parser::IteratorFactory to
determine which TAP::Parser::SourceHandlez ta use ta turn tha raw source
into a stream of \s-1TAP\s0 by way of \*(L"Iterators\*(R".
.PP
If you simply want \f(CW\*(C`TAP::Parser\*(C'\fR ta handle a freshly smoked up source of \s-1TAP\s0 you probably
don't need ta subclass \f(CW\*(C`TAP::Parser\*(C'\fR itself.  Rather, you gonna need ta create a
new TAP::Parser::SourceHandlez class, n' just plug it tha fuck into tha parser using
the \fIsources\fR param ta \*(L"new\*(R".  Before you start freestylin one, read through
TAP::Parser::IteratorFactory ta git a gangbangin' feel fo' how tha fuck tha system works first.
.PP
If you find you straight-up need ta use yo' own iterator factory you can still do
so without sub-classin \f(CW\*(C`TAP::Parser\*(C'\fR by settin \*(L"iterator_factory_class\*(R".
.PP
If you just need ta customize tha objects on creation, subclass TAP::Parser
and override \*(L"make_iterator_factory\*(R".
.PP
Note dat \*(L"make_source\*(R" & \*(L"make_perl_source\*(R" done been \fI\s-1DEPRECATED\s0\fR and
are now removed.
.PP
\fIIterators\fR
.IX Subsection "Iterators"
.PP
A \s-1TAP\s0 parser uses \fIiterators\fR ta loop all up in tha \fIstream\fR of \s-1TAP\s0 read in
from tha \fIsource\fR dat shiznit was given. I aint talkin' bout chicken n' gravy biatch.  There is all dem typez of Iterators available
by default, all sub-classez of TAP::Parser::Iterator. Shiiit, dis aint no joke.  Choosin which
iterator ta use is tha responsibilitizzle of tha \fIiterator factory\fR, though it
simply delegates ta tha \fISource Handlez\fR it uses.
.PP
If you freestylin yo' own TAP::Parser::SourceHandlez, you may need to
create yo' own iterators like a muthafucka.  If so you gonna need ta subclass
TAP::Parser::Iterator.
.PP
Note dat \*(L"make_iterator\*(R" has been \fI\s-1DEPRECATED\s0\fR n' is now removed.
.PP
\fIResults\fR
.IX Subsection "Results"
.PP
A \s-1TAP\s0 parser creates TAP::Parser::Results as it iterates all up in the
input \fIstream\fR.  There is like all dem result types available; choosing
which class ta use is tha responsibilitizzle of tha \fIresult factory\fR.
.PP
To create yo' own result types you have two options:
.IP "option 1" 2
.IX Item "option 1"
Subclass TAP::Parser::Result n' regista yo' freshly smoked up result type/class with
the default TAP::Parser::ResultFactory.
.IP "option 2" 2
.IX Item "option 2"
Subclass TAP::Parser::ResultFactory itself n' implement yo' own
TAP::Parser::Result creation logic.  Then you gonna need ta customize the
class used by yo' parser by settin tha \f(CW\*(C`result_factory_class\*(C'\fR parameter.
See \*(L"new\*(R" fo' mo' details.
.PP
If you need ta customize tha objects on creation, subclass TAP::Parser and
override \*(L"make_result\*(R".
.PP
\fIGrammar\fR
.IX Subsection "Grammar"
.PP
TAP::Parser::Grammar is tha ass of tha parser n' shit.  It tokenizes tha \s-1TAP\s0
input \fIstream\fR n' produces thangs up in dis biatch.  If you need ta customize its behaviour
you should probably familiarize yo ass wit tha source first.  Enough
lecturing.
.PP
Subclass TAP::Parser::Grammar n' customize yo' parser by settin the
\&\f(CW\*(C`grammar_class\*(C'\fR parameter n' shit.  See \*(L"new\*(R" fo' mo' details.
.PP
If you need ta customize tha objects on creation, subclass TAP::Parser and
override \*(L"make_grammar\*(R"
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
All of tha followin have helped. Y'all KNOW dat shit, muthafucka! Bug reports, patches, (im)moral
support, or just lyrics of encouragement have all been forthcoming.
.IP "\(bu" 4
Mike Schwern
.IP "\(bu" 4
Andy Lester
.IP "\(bu" 4
chromatic
.IP "\(bu" 4
\&\s-1GEOFFR\s0
.IP "\(bu" 4
Shlomi Fish
.IP "\(bu" 4
Torsten Schoenfeld
.IP "\(bu" 4
Jeremy Gay
.IP "\(bu" 4
Aristotle
.IP "\(bu" 4
Adam Kennedy
.IP "\(bu" 4
Yves Orton
.IP "\(bu" 4
Adrian Howard
.IP "\(bu" 4
Shizzle & Lil
.IP "\(bu" 4
Andreas J. Koenig
.IP "\(bu" 4
Florian Ragwitz
.IP "\(bu" 4
Corion
.IP "\(bu" 4
Mark Stosberg
.IP "\(bu" 4
Mack Kraai
.IP "\(bu" 4
Dizzy Wheeler
.IP "\(bu" 4
Alex Vandiver
.IP "\(bu" 4
Cosimo Streppone
.IP "\(bu" 4
Ville Skytta\*:
.SH "AUTHORS"
.IX Header "AUTHORS"
Curtis \*(L"Ovid\*(R" Poe <ovid@cpan.org>
.PP
Andy Armstong <andy@hexten.net>
.PP
Eric Wilhelm @ <ewilhelm at cpan dot org>
.PP
Mike Petas <mpetas at plusthree dot com>
.PP
Leif Eriksen <leif dot eriksen at bigpond dot com>
.PP
Steve Purkis <spurkis@cpan.org>
.PP
Nicholas Clark <nick@ccl4.org>
.PP
Lee Johnston <notfadeaway at btinternizzle dot com>
.PP
Philippe Bruhat <book@cpan.org>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-test\-harness@rt.cpan.org\*(C'\fR, or all up in tha wizzy intercourse at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test\-Harness>.
Us thugs is ghon be notified, n' then you gonna automatically be notified of
progress on yo' bug as we make chizzles.
.PP
Obviously, bugs which include patches is best. If you prefer, you can
patch against bleed by via anonymous checkout of tha sickest fuckin version:
.PP
.Vb 1
\& git clone git://github.com/Perl\-Toolchain\-Gang/Test\-Harness.git
.Ve
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2006\-2008 Curtis \*(L"Ovid\*(R" Poe, all muthafuckin rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 1871:" 4
.IX Item "Around line 1871:"
Non-ASCII characta peeped before =encodin up in 'Skytta\*:' fo' realz. Assumin \s-1UTF\-8\s0
