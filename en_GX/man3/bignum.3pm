.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bignum 3pm"
.TH bignum 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
bignum \- Transparent BigNumber support fo' Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use bignum;
\&
\&  $x = 2 + 4.5,"\en";                    # BigFloat 6.5
\&  print 2 ** 512 * 0.1,"\en";            # straight-up is what tha fuck you be thinkin it is
\&  print inf * inf,"\en";                 # prints inf
\&  print NaN * 3,"\en";                   # prints NaN
\&
\&  {
\&    no bignum;
\&    print 2 ** 256,"\en";                # a aiiight Perl scalar now
\&  }
\&
\&  # fo' olda Perls, import tha fuck into current package:
\&  use bignum qw/hex oct/;
\&  print hex("0x1234567890123490"),"\en";
\&  print oct("01234567890123490"),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (includin basic math operations) is overloaded. Y'all KNOW dat shit, muthafucka! Integer and
floating-point constants is pimped as proper BigInts or BigFloats,
respectively.
.PP
If you do
.PP
.Vb 1
\&        use bignum;
.Ve
.PP
at tha top of yo' script, Math::BigFloat n' Math::BigInt is ghon be loaded
and any constant number is ghon be converted ta a object (Math::BigFloat for
floats like 3.1415 n' Math::BigInt fo' integers like 1234).
.PP
So, tha followin line:
.PP
.Vb 1
\&        $x = 1234;
.Ve
.PP
creates straight-up a Math::BigInt n' stores a reference ta up in \f(CW$x\fR.
This happens transparently n' behind yo' back, so ta speak.
.PP
Yo ass can peep dis wit tha following:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint ref(1234)\*(Aq
.Ve
.PP
Don't worry if it say Math::BigInt::Lite, bignum n' playaz will use Lite
if it is installed since it is fasta fo' some operations. Well shiiiit, it will be
automatically upgraded ta BigInt whenever necessary:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint ref(2**255)\*(Aq
.Ve
.PP
This also means it aint nuthin but a wack scam ta check fo' some specific package, since
the actual contentz of \f(CW$x\fR might be suttin' unexpected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Cuz of the
transparent way of bignum \f(CW\*(C`ref()\*(C'\fR should not be necessary, anyway.
.PP
Since Math::BigInt n' BigFloat also overload tha aiiight math operations,
the followin line will still work:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint ref(1234+1234)\*(Aq
.Ve
.PP
Since numbers is straight-up objects, you can call all tha usual methodz from
BigInt/BigFloat on em. This even works ta some extent on expressions:
.PP
.Vb 4
\&        perl \-Mbignum \-le \*(Aq$x = 1234; print $x\->bdec()\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 1234\->copy()\->binc();\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 1234\->copy()\->binc\->badd(6);\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint +(1234)\->copy()\->binc()\*(Aq
.Ve
.PP
(Note dat print don't do what tha fuck you expect if tha expression starts with
\&'(' hence tha \f(CW\*(C`+\*(C'\fR)
.PP
Yo ass can even chain tha operations together as usual:
.PP
.Vb 2
\&        perl \-Mbignum \-le \*(Aqprint 1234\->copy()\->binc\->badd(6);\*(Aq
\&        1241
.Ve
.PP
Under bignum (or bigint or bigrat), Perl will \*(L"upgrade\*(R" tha numbers
appropriately. This means that:
.PP
.Vb 2
\&        perl \-Mbignum \-le \*(Aqprint 1234+4.5\*(Aq
\&        1238.5
.Ve
.PP
will work erectly. These mixed cases don't do always work when using
Math::BigInt or Math::BigFloat alone, or at least not up in tha way aiiight Perl
scalars work.
.PP
If you do wanna work wit big-ass integers like under \f(CW\*(C`use integer;\*(C'\fR, try
\&\f(CW\*(C`use bigint;\*(C'\fR:
.PP
.Vb 2
\&        perl \-Mbigint \-le \*(Aqprint 1234.5+4.5\*(Aq
\&        1238
.Ve
.PP
There be also \f(CW\*(C`use bigrat;\*(C'\fR which gives you big-ass rationals:
.PP
.Vb 2
\&        perl \-Mbigrat \-le \*(Aqprint 1234+4.1\*(Aq
\&        12381/10
.Ve
.PP
Da entire upgrading/downgradin is still experimenstrual n' might not work
as you expect or may even have bugs. Yo ass might git errors like this:
.PP
.Vb 2
\&        Can\*(Aqt use a undefined value as a ARRAY reference at
\&        /usr/local/lib/perl5/5.8.0/Math/BigInt/Calc.pm line 864
.Ve
.PP
This means somewhere a routine gots a BigFloat/Lite but expected a BigInt (or
vice versa) n' tha upgrade/downgrad path was missing. This be a funky-ass bug, please
report it so dat we can fix dat shit.
.PP
Yo ass might consider rockin just Math::BigInt or Math::BigFloat, since they
allow you finer control over what tha fuck getz done up in which module/space. For
instance, simple loop countas is ghon be Math::BigInts under \f(CW\*(C`use bignum;\*(C'\fR and
this is slower than keepin dem as Perl scalars:
.PP
.Vb 1
\&    perl \-Mbignum \-le \*(Aqfor ($i = 0; $i < 10; $i++) { print ref($i); }\*(Aq
.Ve
.PP
Please note tha followin do not work as expected (prints nothing), since
overloadin of '..' aint yet possible up in Perl (az of v5.8.0):
.PP
.Vb 1
\&    perl \-Mbignum \-le \*(Aqfor (1..2) { print ref($_); }\*(Aq
.Ve
.SS "Options"
.IX Subsection "Options"
bignum recognizes some options dat can be passed while loadin it via use.
Da options can (currently) be either a single letta form, or tha long form.
Da followin options exist:
.IP "a or accuracy" 2
.IX Item "a or accuracy"
This sets tha accuracy fo' all math operations. Da argument must be pimped outer
than or equal ta zero. Right back up in yo muthafuckin ass. See Math::BigIntz \fIbround()\fR function fo' details.
.Sp
.Vb 1
\&        perl \-Mbignum=a,50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note dat settin precision n' accuracy all up in tha same time aint possible.
.IP "p or precision" 2
.IX Item "p or precision"
This sets tha precision fo' all math operations. Da argument can be any
integer n' shit. Negatizzle joints mean a gangbangin' fixed number of digits afta tha dot, while
a positizzle value roundz ta dis digit left from tha dot. 0 or 1 mean round to
integer n' shit. Right back up in yo muthafuckin ass. See Math::BigIntz \fIbfround()\fR function fo' details.
.Sp
.Vb 1
\&        perl \-Mbignum=p,\-50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note dat settin precision n' accuracy all up in tha same time aint possible.
.IP "t or trace" 2
.IX Item "t or trace"
This enablez a trace mode n' is primarily fo' debuggin bignum or
Math::BigInt/Math::BigFloat.
.IP "l or lib" 2
.IX Item "l or lib"
Load a gangbangin' finger-lickin' different math lib, peep \*(L"Math Library\*(R".
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
Currently there is no way ta specify mo' than one library on tha command
line. This means tha followin do not work:
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP,Pari \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
This is ghon be hopefully fixed soon ;)
.IP "hex" 2
.IX Item "hex"
Override tha built-in \fIhex()\fR method wit a version dat can handle big
numbers. This overrides it by exportin it ta tha current package. Under
Perl v5.10.0 n' higher, dis aint so necessary, as \fIhex()\fR is lexically
overridden up in tha current scope whenever tha bignum pragma be active.
.IP "oct" 2
.IX Item "oct"
Override tha built-in \fIoct()\fR method wit a version dat can handle big
numbers. This overrides it by exportin it ta tha current package. Under
Perl v5.10.0 n' higher, dis aint so necessary, as \fIoct()\fR is lexically
overridden up in tha current scope whenever tha bigint pragma be active.
.IP "v or version" 2
.IX Item "v or version"
This prints up tha name n' version of all modulez used n' then exits.
.Sp
.Vb 1
\&        perl \-Mbignum=v
.Ve
.SS "Methods"
.IX Subsection "Methods"
Beside \fIimport()\fR n' \s-1\fIAUTOLOAD\s0()\fR there be only all dem other methods.
.PP
Since all numbers is now objects, you can use all functions dat is part of
the BigInt or BigFloat \s-1API.\s0 It be wise ta use only tha \fIbxxx()\fR notation, n' not
the \fIfxxx()\fR notation, though cause I gots dem finger-lickin' chickens wit tha siz-auce. This make it possible dat tha underlyin object
might morph tha fuck into a gangbangin' finger-lickin' different class than BigFloat.
.SS "Caveats"
.IX Subsection "Caveats"
But a warnin is up in order n' shit. When rockin tha followin ta cook up a cold-ass lil copy of a number,
only a gangbangin' finger-lickin' dirty-ass shallow copy is ghon be made.
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $x = $y = 7;
.Ve
.PP
If you wanna cook up a real copy, use tha following:
.PP
.Vb 1
\&        $y = $x\->copy();
.Ve
.PP
Usin tha copy or tha original gangsta wit overloaded math be all gravy, e.g. the
followin work:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x + 1, " ", $y,"\en";     # prints 10 9
.Ve
.PP
but callin any method dat modifies tha number directly will result in
\&\fBboth\fR tha original gangsta n' tha copy bein destroyed:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x\->badd(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->binc(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->bmul(2), " ", $y,"\en";        # prints 18 18
.Ve
.PP
Usin methodz dat do not modify yo, but test tha contents works:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $z = 9 if $x\->is_zero();                # works fine
.Ve
.PP
See tha documentation bout tha copy constructor n' \f(CW\*(C`=\*(C'\fR up in overload, as
well as tha documentation up in BigInt fo' further details.
.IP "\fIinf()\fR" 2
.IX Item "inf()"
A shortcut ta return Math::BigInt\->\fIbinf()\fR. Useful cuz Perl do not always
handle bareword \f(CW\*(C`inf\*(C'\fR properly.
.IP "\fINaN()\fR" 2
.IX Item "NaN()"
A shortcut ta return Math::BigInt\->\fIbnan()\fR. Useful cuz Perl do not always
handle bareword \f(CW\*(C`NaN\*(C'\fR properly.
.IP "e" 2
.IX Item "e"
.Vb 1
\&        # perl \-Mbignum=e \-wle \*(Aqprint e\*(Aq
.Ve
.Sp
Returns Eulerz number \f(CW\*(C`e\*(C'\fR, aka \fIexp\fR\|(1).
.IP "\s-1\fIPI\s0()\fR" 2
.IX Item "PI()"
.Vb 1
\&        # perl \-Mbignum=PI \-wle \*(Aqprint PI\*(Aq
.Ve
.Sp
Returns \s-1PI.\s0
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.Vb 1
\&        bexp($power,$accuracy);
.Ve
.Sp
Returns Eulerz number \f(CW\*(C`e\*(C'\fR raised ta tha appropriate power, to
the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbignum=bexp \-wle \*(Aqprint bexp(1,80)\*(Aq
.Ve
.IP "\fIbpi()\fR" 2
.IX Item "bpi()"
.Vb 1
\&        bpi($accuracy);
.Ve
.Sp
Returns \s-1PI\s0 ta tha wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbignum=bpi \-wle \*(Aqprint bpi(80)\*(Aq
.Ve
.IP "\fIupgrade()\fR" 2
.IX Item "upgrade()"
Return tha class dat numbers is upgraded to, is up in fact returning
\&\f(CW$Math::BigInt::upgrade\fR.
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
.Vb 1
\&        use bignum;
\&
\&        print "in effect\en" if bignum::in_effect;       # true
\&        {
\&          no bignum;
\&          print "in effect\en" if bignum::in_effect;     # false
\&        }
.Ve
.Sp
Returns legit or false if \f(CW\*(C`bignum\*(C'\fR is up in effect up in tha current scope.
.Sp
This method only works on Perl v5.9.4 or later.
.SS "Math Library"
.IX Subsection "Math Library"
Math wit tha numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent ta saying:
.PP
.Vb 1
\&        use bignum lib => \*(AqCalc\*(Aq;
.Ve
.PP
Yo ass can chizzle dis by using:
.PP
.Vb 1
\&        use bignum lib => \*(AqGMP\*(Aq;
.Ve
.PP
Da followin would first try ta find Math::BigInt::Foo, then
Math::BigInt::Bar, n' when dis also fails, revert ta Math::BigInt::Calc:
.PP
.Vb 1
\&        use bignum lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
Please peep respectizzle module documentation fo' further details.
.PP
Usin \f(CW\*(C`lib\*(C'\fR warns if none of tha specified libraries can be found and
Math::BigInt did fall back ta one of tha default libraries.
To suppress dis warning, use \f(CW\*(C`try\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum try => \*(AqGMP\*(Aq;
.Ve
.PP
If you want tha code ta take a thugged-out dirtnap instead of fallin back, use \f(CW\*(C`only\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum only => \*(AqGMP\*(Aq;
.Ve
.SS "\s-1INTERNAL FORMAT\s0"
.IX Subsection "INTERNAL FORMAT"
Da numbers is stored as objects, n' they internals might chizzle at anytime,
especially between math operations. Da objects also might belong ta different
classes, like Math::BigInt, or Math::BigFLoat. Mixin dem together, even
with aiiight scalars aint extraordinary yo, but aiiight n' expected.
.PP
Yo ass should not depend on tha internal format, all accesses must go through
accessor methods. E.g. lookin at \f(CW$x\fR\->{sign} aint a funky-ass bright scam since there
is no guaranty dat tha object up in question has such a hashkey, nor be a hash
underneath at all.
.SS "\s-1SIGN\s0"
.IX Subsection "SIGN"
Da sign is either '+', '\-', 'NaN', '+inf' or '\-inf' n' stored separately.
Yo ass can access it wit tha \fIsign()\fR method.
.PP
A sign of 'NaN' is used ta represent tha result when input arguments is not
numbers or as a result of 0/0. '+inf' n' '\-inf' represent plus respectively
minus infinity. Yo ass will git '+inf' when dividin a positizzle number by 0, and
\&'\-inf' when dividin any wack number by 0.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
This method only works on Perl v5.9.4 or later.
.IP "\fIhex()\fR/\fIoct()\fR" 2
.IX Item "hex()/oct()"
\&\f(CW\*(C`bigint\*(C'\fR overrides these routines wit versions dat can also handle
bangin' integer joints, n' you can put dat on yo' toast. Under Perl prior ta version v5.9.4, however, this
will not happen unless you specifically ask fo' it wit tha two
import tags \*(L"hex\*(R" n' \*(L"oct\*(R" \- n' then it is ghon be global n' cannot be
disabled inside a scope wit \*(L"no bigint\*(R":
.Sp
.Vb 1
\&        use bigint qw/hex oct/;
\&
\&        print hex("0x1234567890123456");
\&        {
\&                no bigint;
\&                print hex("0x1234567890123456");
\&        }
.Ve
.Sp
Da second call ta \fIhex()\fR will warn on some non-portable constant.
.Sp
Compare dis to:
.Sp
.Vb 1
\&        use bigint;
\&
\&        # will warn only under olda than v5.9.4
\&        print hex("0x1234567890123456");
.Ve
.SH "MODULES USED"
.IX Header "MODULES USED"
\&\f(CW\*(C`bignum\*(C'\fR is just a thin wrapper round various modulez of tha Math::BigInt
family. Think of it as tha head of tha crew, whoz ass runs tha shop, n' orders
the others ta do tha work.
.PP
Da followin modulez is currently used by bignum:
.PP
.Vb 3
\&        Math::BigInt::Lite      (for speed, n' only if it is loadable)
\&        Math::BigInt
\&        Math::BigFloat
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Some def command line examplez ta impress tha Python crowd ;)
.PP
.Vb 10
\&        perl \-Mbignum \-le \*(Aqprint sqrt(33)\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 2*255\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 4.5+2*255\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 3/7 + 5/7 + 8/3\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 123\->is_odd()\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint log(2)\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint exp(1)\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 2 ** 0.5\*(Aq
\&        perl \-Mbignum=a,65 \-le \*(Aqprint 2 ** 0.2\*(Aq
\&        perl \-Mbignum=a,65,l,GMP \-le \*(Aqprint 7 ** 7777\*(Aq
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Especially bigrat as up in \f(CW\*(C`perl \-Mbigrat \-le \*(Aqprint 1/3+1/4\*(Aq\*(C'\fR.
.PP
Math::BigFloat, Math::BigInt, Math::BigRat n' Math::Big as well
as Math::BigInt::Pari n'  Math::BigInt::GMP.
.SH "AUTHORS"
.IX Header "AUTHORS"
(C) by Tels <http://bloodgate.com/> up in early 2002 \- 2007.
