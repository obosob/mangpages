.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "EVP_PKEY_CTX_ctrl 3"
.TH EVP_PKEY_CTX_ctrl 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
EVP_PKEY_ctrl, EVP_PKEY_ctrl_str \- algorithm specific control operations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/evp.h>
\&
\& int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
\&                                int cmd, int p1, void *p2);
\& int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,
\&                                                const char *value);
\&
\& int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);
\&
\& #include <openssl/rsa.h>
\&
\& int EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);
\&
\& int EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *ctx, int pad);
\& int EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int len);
\& int EVP_PKEY_CTX_set_rsa_rsa_keygen_bits(EVP_PKEY_CTX *ctx, int mbits);
\& int EVP_PKEY_CTX_set_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx, BIGNUM *pubexp);
\&
\& #include <openssl/dsa.h>
\& int EVP_PKEY_CTX_set_dsa_paramgen_bits(EVP_PKEY_CTX *ctx, int nbits);
\&
\& #include <openssl/dh.h>
\& int EVP_PKEY_CTX_set_dh_paramgen_prime_len(EVP_PKEY_CTX *ctx, int len);
\& int EVP_PKEY_CTX_set_dh_paramgen_generator(EVP_PKEY_CTX *ctx, int gen);
\&
\& #include <openssl/ec.h>
\& int EVP_PKEY_CTX_set_ec_paramgen_curve_nid(EVP_PKEY_CTX *ctx, int nid);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da function \fIEVP_PKEY_CTX_ctrl()\fR sendz a cold-ass lil control operation ta tha context
\&\fBctx\fR. Da key type used must match \fBkeytype\fR if it aint \-1. Da parameter
\&\fBoptype\fR be a mask indicatin which operations tha control can be applied to.
Da control command is indicated up in \fBcmd\fR n' any additionizzle arguments in
\&\fBp1\fR n' \fBp2\fR.
.PP
Applications aint gonna normally call \fIEVP_PKEY_CTX_ctrl()\fR directly but will
instead call one of tha algorithm specific macros below.
.PP
Da function \fIEVP_PKEY_ctrl_str()\fR allows a application ta bust a algorithm
specific control operation ta a cold-ass lil context \fBctx\fR up in strang form. This is
intended ta be used fo' options specified on tha command line or up in text
files. Da commandz supported is documented up in tha openssl utility
command line pages fo' tha option \fB\-pkeyopt\fR which is supported by the
\&\fBpkeyutl\fR, \fBgenpkey\fR n' \fBreq\fR commands.
.PP
All tha remainin \*(L"functions\*(R" is implemented as macros.
.PP
Da \fIEVP_PKEY_CTX_set_signature_md()\fR macro sets tha message digest type used
in a signature. Well shiiiit, it can be used wit any hood key algorithm supporting
signature operations.
.PP
Da macro \fIEVP_PKEY_CTX_set_rsa_padding()\fR sets tha \s-1RSA\s0 paddin mode fo' \fBctx\fR.
Da \fBpad\fR parameta can take tha value \s-1RSA_PKCS1_PADDING\s0 fo' PKCS#1 padding,
\&\s-1RSA_SSLV23_PADDING\s0 fo' SSLv23 padding, \s-1RSA_NO_PADDING\s0 fo' no padding,
\&\s-1RSA_PKCS1_OAEP_PADDING\s0 fo' \s-1OAEP\s0 paddin (encrypt n' decrypt only),
\&\s-1RSA_X931_PADDING\s0 fo' X9.31 paddin (signature operations only) n' 
\&\s-1RSA_PKCS1_PSS_PADDING \s0(sign n' verify only).
.PP
Two \s-1RSA\s0 paddin modes behave differently if \fIEVP_PKEY_CTX_set_signature_md()\fR
is used. Y'all KNOW dat shit, muthafucka! If dis macro is called fo' PKCS#1 paddin tha plaintext buffer is
an actual digest value n' is encapsulated up in a DigestInfo structure according
to PKCS#1 when signin n' dis structure is expected (and stripped off) when
verifying. If dis control aint used wit \s-1RSA\s0 n' PKCS#1 paddin then the
supplied data is used directly n' not encapsulated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In tha case of X9.31
paddin fo' \s-1RSA\s0 tha algorithm identifier byte be added or checked n' removed
if dis control is called. Y'all KNOW dat shit, muthafucka! If it aint called then tha straight-up original gangsta byte of tha plaintext buffer is sposed ta fuckin be tha algorithm identifier byte.
.PP
Da \fIEVP_PKEY_CTX_set_rsa_pss_saltlen()\fR macro sets tha \s-1RSA PSS\s0 salt length to
\&\fBlen\fR as its name implies it is only supported fo' \s-1PSS\s0 padding.  Two special
values is supported: \-1 sets tha salt length ta tha digest length. When
signin \-2 sets tha salt length ta tha maximum permissible value. When
verifyin \-2 causes tha salt length ta be automatically determined based on the
\&\fB\s-1PSS\s0\fR block structure. If dis macro aint called a salt length value of \-2
is used by default.
.PP
Da \fIEVP_PKEY_CTX_set_rsa_rsa_keygen_bits()\fR macro sets tha \s-1RSA\s0 key length for
\&\s-1RSA\s0 key genration ta \fBbits\fR. If not specified 1024 bits is used.
.PP
Da \fIEVP_PKEY_CTX_set_rsa_keygen_pubexp()\fR macro sets tha hood exponent value
for \s-1RSA\s0 key generation ta \fBpubexp\fR currently it should be a odd integer n' shit. The
\&\fBpubexp\fR pointa is used internally by dis function so it should not be 
modified or free afta tha call. If dis macro aint called then 65537 is used.
.PP
Da macro \fIEVP_PKEY_CTX_set_dsa_paramgen_bits()\fR sets tha number of bits used
for \s-1DSA\s0 parameta generation ta \fBbits\fR. If not specified 1024 is used.
.PP
Da macro \fIEVP_PKEY_CTX_set_dh_paramgen_prime_len()\fR sets tha length of tha \s-1DH\s0
prime parameta \fBp\fR fo' \s-1DH\s0 parameta generation. I aint talkin' bout chicken n' gravy biatch. If dis macro aint called
then 1024 is used.
.PP
Da \fIEVP_PKEY_CTX_set_dh_paramgen_generator()\fR macro sets \s-1DH\s0 generator ta \fBgen\fR
for \s-1DH\s0 parameta generation. I aint talkin' bout chicken n' gravy biatch. If not specified 2 is used.
.PP
Da \fIEVP_PKEY_CTX_set_ec_paramgen_curve_nid()\fR sets tha \s-1EC\s0 curve fo' \s-1EC\s0 parameter
generation ta \fBnid\fR. For \s-1EC\s0 parameta generation dis macro must be called
or a error occurs cuz there is no default curve.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIEVP_PKEY_CTX_ctrl()\fR n' its macros return a positizzle value fo' success n' 0
or a wack value fo' failure. In particular a return value of \-2
indicates tha operation aint supported by tha hood key algorithm.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIEVP_PKEY_CTX_new\fR\|(3),
\&\fIEVP_PKEY_encrypt\fR\|(3),
\&\fIEVP_PKEY_decrypt\fR\|(3),
\&\fIEVP_PKEY_sign\fR\|(3),
\&\fIEVP_PKEY_verify\fR\|(3),
\&\fIEVP_PKEY_verify_recover\fR\|(3),
\&\fIEVP_PKEY_derive\fR\|(3) 
\&\fIEVP_PKEY_keygen\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
These functions was first added ta OpenSSL 1.0.0.
