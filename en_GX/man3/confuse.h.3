.TH "confuse.h" 3 "21 Feb 2010" "Version 2.7" "confuse" \" -*- nroff -*-
.ad l
.nh
.SH NAME
confuse.h \- A configuration file parser library.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <stdio.h>\fP
.br
\fC#include <stdarg.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBcfg_t\fP"
.br
.RI "\fIData structure holdin shiznit on some 'section'. \fP"
.ti -1c
.RI "union \fBcfg_value_t\fP"
.br
.RI "\fIData structure holdin tha value of a gangbangin' fundamenstrual option value. \fP"
.ti -1c
.RI "struct \fBcfg_defvalue_t\fP"
.br
.RI "\fIData structure holdin tha default value given by tha initialization macros. \fP"
.ti -1c
.RI "struct \fBcfg_opt_t\fP"
.br
.RI "\fIData structure holdin shiznit bout a option. I aint talkin' bout chicken n' gravy biatch. \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBCFGF_NONE\fP   0"
.br
.RI "\fIFlags. \fP"
.ti -1c
.RI "#define \fBCFGF_MULTI\fP   1"
.br
.RI "\fIoption may be specified multiple times (only applies ta sections) \fP"
.ti -1c
.RI "#define \fBCFGF_LIST\fP   2"
.br
.RI "\fIoption be a list \fP"
.ti -1c
.RI "#define \fBCFGF_NOCASE\fP   4"
.br
.RI "\fIconfiguration file is case insensitizzle \fP"
.ti -1c
.RI "#define \fBCFGF_TITLE\fP   8"
.br
.RI "\fIoption has a title (only applies ta sections) \fP"
.ti -1c
.RI "#define \fBCFGF_NODEFAULT\fP   16"
.br
.RI "\fIoption has no default value \fP"
.ti -1c
.RI "#define \fBCFGF_NO_TITLE_DUPES\fP   32"
.br
.RI "\fImultiple section titlez must be unique (duplicates raises a error, only applies ta sections) \fP"
.ti -1c
.RI "#define \fBCFG_SUCCESS\fP   0"
.br
.RI "\fIReturn codes from \fBcfg_parse()\fP. \fP"
.ti -1c
.RI "#define \fBCFG_STR\fP(name, def, flags)   __CFG_STR(name, def, flags, 0, 0)"
.br
.RI "\fIInitialize a strang option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "#define \fBCFG_STR_LIST\fP(name, def, flags)   __CFG_STR_LIST(name, def, flags, 0, 0)"
.br
.RI "\fIInitialize a strang list option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "#define \fBCFG_STR_CB\fP(name, def, flags, cb)   __CFG_STR(name, def, flags, 0, cb)"
.br
.RI "\fIInitialize a strang option wit a value parsin callback. \fP"
.ti -1c
.RI "#define \fBCFG_STR_LIST_CB\fP(name, def, flags, cb)   __CFG_STR_LIST(name, def, flags, 0, cb)"
.br
.RI "\fIInitialize a strang list option wit a value parsin callback. \fP"
.ti -1c
.RI "#define \fBCFG_SIMPLE_STR\fP(name, svalue)   __CFG_STR(name, 0, CFGF_NONE, svalue, 0)"
.br
.RI "\fIInitialize a 'simple' strang option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "#define \fBCFG_INT\fP(name, def, flags)   __CFG_INT(name, def, flags, 0, 0)"
.br
.RI "\fIInitialize a integer option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "#define \fBCFG_INT_LIST\fP(name, def, flags)   __CFG_INT_LIST(name, def, flags, 0, 0)"
.br
.RI "\fIInitialize a integer list option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "#define \fBCFG_INT_CB\fP(name, def, flags, cb)   __CFG_INT(name, def, flags, 0, cb)"
.br
.RI "\fIInitialize a integer option wit a value parsin callback. \fP"
.ti -1c
.RI "#define \fBCFG_INT_LIST_CB\fP(name, def, flags, cb)   __CFG_INT_LIST(name, def, flags, 0, cb)"
.br
.RI "\fIInitialize a integer list option wit a value parsin callback. \fP"
.ti -1c
.RI "#define \fBCFG_SIMPLE_INT\fP(name, svalue)   __CFG_INT(name, 0, CFGF_NONE, svalue, 0)"
.br
.RI "\fIInitialize a 'simple' integer option (see documentation fo' CFG_SIMPLE_STR fo' mo' shiznit). \fP"
.ti -1c
.RI "#define \fBCFG_FLOAT\fP(name, def, flags)   __CFG_FLOAT(name, def, flags, 0, 0)"
.br
.RI "\fIInitialize a gangbangin' floatin point option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "#define \fBCFG_FLOAT_LIST\fP(name, def, flags)   __CFG_FLOAT_LIST(name, def, flags, 0, 0)"
.br
.RI "\fIInitialize a gangbangin' floatin point list option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "#define \fBCFG_FLOAT_CB\fP(name, def, flags, cb)   __CFG_FLOAT(name, def, flags, 0, cb)"
.br
.RI "\fIInitialize a gangbangin' floatin point option wit a value parsin callback. \fP"
.ti -1c
.RI "#define \fBCFG_FLOAT_LIST_CB\fP(name, def, flags, cb)   __CFG_FLOAT_LIST(name, def, flags, 0, cb)"
.br
.RI "\fIInitialize a gangbangin' floatin point list option wit a value parsin callback. \fP"
.ti -1c
.RI "#define \fBCFG_SIMPLE_FLOAT\fP(name, svalue)   __CFG_FLOAT(name, 0, CFGF_NONE, svalue, 0)"
.br
.RI "\fIInitialize a 'simple' floatin point option (see documentation fo' CFG_SIMPLE_STR fo' mo' shiznit). \fP"
.ti -1c
.RI "#define \fBCFG_BOOL\fP(name, def, flags)   __CFG_BOOL(name, def, flags, 0, 0)"
.br
.RI "\fIInitialize a funky-ass boolean option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "#define \fBCFG_BOOL_LIST\fP(name, def, flags)   __CFG_BOOL_LIST(name, def, flags, 0, 0)"
.br
.RI "\fIInitialize a funky-ass boolean list option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "#define \fBCFG_BOOL_CB\fP(name, def, flags, cb)   __CFG_BOOL(name, def, flags, 0, cb)"
.br
.RI "\fIInitialize a funky-ass boolean option wit a value parsin callback. \fP"
.ti -1c
.RI "#define \fBCFG_BOOL_LIST_CB\fP(name, def, flags, cb)   __CFG_BOOL_LIST(name, def, flags, 0, cb)"
.br
.RI "\fIInitialize a funky-ass boolean list option wit a value parsin callback. \fP"
.ti -1c
.RI "#define \fBCFG_SIMPLE_BOOL\fP(name, svalue)   __CFG_BOOL(name, cfg_false, CFGF_NONE, svalue, 0)"
.br
.RI "\fIInitialize a 'simple' boolean option (see documentation fo' CFG_SIMPLE_STR fo' mo' shiznit). \fP"
.ti -1c
.RI "#define \fBCFG_SEC\fP(name, opts, flags)   {name,CFGT_SEC,0,0,flags,opts,{0,0,cfg_false,0,0},0,0,0,0,0,0}"
.br
.RI "\fIInitialize a section. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "#define \fBCFG_FUNC\fP(name, func)   {name,CFGT_FUNC,0,0,CFGF_NONE,0,{0,0,cfg_false,0,0},func,0,0,0,0,0}"
.br
.RI "\fIInitialize a gangbangin' function. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "#define \fBCFG_PTR_CB\fP(name, def, flags, parsecb, freecb)   __CFG_PTR(name, def, flags, 0, parsecb, freecb)"
.br
.RI "\fIInitialize a user-defined option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "#define \fBCFG_PTR_LIST_CB\fP(name, def, flags, parsecb, freecb)   __CFG_PTR(name, def, flags | CFGF_LIST, 0, parsecb, freecb)"
.br
.RI "\fIInitialize a list of user-defined options. \fP"
.ti -1c
.RI "#define \fBCFG_END\fP()   {0,CFGT_NONE,0,0,CFGF_NONE,0,{0,0,cfg_false,0,0},0,0,0,0,0,0}"
.br
.RI "\fITerminizzle list of options. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int(* \fBcfg_func_t\fP )(\fBcfg_t\fP *cfg, \fBcfg_opt_t\fP *opt, int argc, const char **argv)"
.br
.RI "\fIFunction prototype used by CFGT_FUNC options. \fP"
.ti -1c
.RI "typedef void(* \fBcfg_print_func_t\fP )(\fBcfg_opt_t\fP *opt, unsigned int index, FILE *fp)"
.br
.RI "\fIFunction prototype used by tha cfg_print_ functions. \fP"
.ti -1c
.RI "typedef int(* \fBcfg_callback_t\fP )(\fBcfg_t\fP *cfg, \fBcfg_opt_t\fP *opt, const char *value, void *result)"
.br
.RI "\fIValue parsin callback prototype. \fP"
.ti -1c
.RI "typedef int(* \fBcfg_validate_callback_t\fP )(\fBcfg_t\fP *cfg, \fBcfg_opt_t\fP *opt)"
.br
.RI "\fIValipimpin callback prototype. \fP"
.ti -1c
.RI "typedef void(* \fBcfg_free_func_t\fP )(void *value)"
.br
.RI "\fIUser-defined memory release function fo' CFG_PTR joints, n' you can put dat on yo' toast. \fP"
.ti -1c
.RI "typedef void(* \fBcfg_errfunc_t\fP )(\fBcfg_t\fP *cfg, const char *fmt, va_list ap)"
.br
.RI "\fIError reportin function. I aint talkin' bout chicken n' gravy biatch. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBcfg_type_t\fP { , \fBCFGT_INT\fP, \fBCFGT_FLOAT\fP, \fBCFGT_STR\fP, \fBCFGT_BOOL\fP, \fBCFGT_SEC\fP, \fBCFGT_FUNC\fP, \fBCFGT_PTR\fP }"
.br
.RI "\fIFundamenstrual option types. \fP"
.ti -1c
.RI "enum \fBcfg_bool_t\fP "
.br
.RI "\fIBoolean joints, n' you can put dat on yo' toast. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "DLLIMPORT \fBcfg_t\fP *__export \fBcfg_init\fP (\fBcfg_opt_t\fP *opts, cfg_flag_t flags)"
.br
.RI "\fISmoke n' initialize a \fBcfg_t\fP structure. \fP"
.ti -1c
.RI "DLLIMPORT int __export \fBcfg_parse\fP (\fBcfg_t\fP *cfg, const char *filename)"
.br
.RI "\fIParse a cold-ass lil configuration file. \fP"
.ti -1c
.RI "DLLIMPORT int __export \fBcfg_parse_fp\fP (\fBcfg_t\fP *cfg, FILE *fp)"
.br
.RI "\fISame as \fBcfg_parse()\fP above yo, but takes a already opened file as argument. \fP"
.ti -1c
.RI "DLLIMPORT int __export \fBcfg_parse_buf\fP (\fBcfg_t\fP *cfg, const char *buf)"
.br
.RI "\fISame as \fBcfg_parse()\fP above yo, but takes a cold-ass lil characta buffer as argument. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_free_value\fP (\fBcfg_opt_t\fP *opt)"
.br
.RI "\fIJacked tha memory allocated fo' tha jointz of a given option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_free\fP (\fBcfg_t\fP *cfg)"
.br
.RI "\fIJacked a \fBcfg_t\fP context. \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_errfunc_t\fP __export \fBcfg_set_error_function\fP (\fBcfg_t\fP *cfg, \fBcfg_errfunc_t\fP errfunc)"
.br
.RI "\fIInstall a user-defined error reportin function. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_error\fP (\fBcfg_t\fP *cfg, const char *fmt,...)"
.br
.RI "\fIShow a parser error. Shiiit, dis aint no joke. \fP"
.ti -1c
.RI "DLLIMPORT signed long __export \fBcfg_opt_getnint\fP (\fBcfg_opt_t\fP *opt, unsigned int index)"
.br
.RI "\fIReturns tha value of a integer option, given a \fBcfg_opt_t\fP pointer n' shit. \fP"
.ti -1c
.RI "DLLIMPORT long int __export \fBcfg_getnint\fP (\fBcfg_t\fP *cfg, const char *name, unsigned int index)"
.br
.RI "\fIIndexed version of \fBcfg_getint()\fP, used fo' lists, n' you can put dat on yo' toast. \fP"
.ti -1c
.RI "DLLIMPORT long int __export \fBcfg_getint\fP (\fBcfg_t\fP *cfg, const char *name)"
.br
.RI "\fIReturns tha value of a integer option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT double __export \fBcfg_opt_getnfloat\fP (\fBcfg_opt_t\fP *opt, unsigned int index)"
.br
.RI "\fIReturns tha value of a gangbangin' floatin point option, given a \fBcfg_opt_t\fP pointer n' shit. \fP"
.ti -1c
.RI "DLLIMPORT double __export \fBcfg_getnfloat\fP (\fBcfg_t\fP *cfg, const char *name, unsigned int index)"
.br
.RI "\fIIndexed version of \fBcfg_getfloat()\fP, used fo' lists, n' you can put dat on yo' toast. \fP"
.ti -1c
.RI "DLLIMPORT double __export \fBcfg_getfloat\fP (\fBcfg_t\fP *cfg, const char *name)"
.br
.RI "\fIReturns tha value of a gangbangin' floatin point option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT char *__export \fBcfg_opt_getnstr\fP (\fBcfg_opt_t\fP *opt, unsigned int index)"
.br
.RI "\fIReturns tha value of a strang option, given a \fBcfg_opt_t\fP pointer n' shit. \fP"
.ti -1c
.RI "DLLIMPORT char *__export \fBcfg_getnstr\fP (\fBcfg_t\fP *cfg, const char *name, unsigned int index)"
.br
.RI "\fIIndexed version of \fBcfg_getstr()\fP, used fo' lists, n' you can put dat on yo' toast. \fP"
.ti -1c
.RI "DLLIMPORT char *__export \fBcfg_getstr\fP (\fBcfg_t\fP *cfg, const char *name)"
.br
.RI "\fIReturns tha value of a strang option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_bool_t\fP __export \fBcfg_opt_getnbool\fP (\fBcfg_opt_t\fP *opt, unsigned int index)"
.br
.RI "\fIReturns tha value of a funky-ass boolean option, given a \fBcfg_opt_t\fP pointer n' shit. \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_bool_t\fP __export \fBcfg_getnbool\fP (\fBcfg_t\fP *cfg, const char *name, unsigned int index)"
.br
.RI "\fIIndexed version of \fBcfg_getbool()\fP, used fo' lists, n' you can put dat on yo' toast. \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_bool_t\fP __export \fBcfg_getbool\fP (\fBcfg_t\fP *cfg, const char *name)"
.br
.RI "\fIReturns tha value of a funky-ass boolean option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT void *__export \fBcfg_getptr\fP (\fBcfg_t\fP *cfg, const char *name)"
.br
.RI "\fIReturns tha value of a user-defined option (void pointer). \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_t\fP *__export \fBcfg_opt_getnsec\fP (\fBcfg_opt_t\fP *opt, unsigned int index)"
.br
.RI "\fIReturns tha value of a section option, given a \fBcfg_opt_t\fP pointer n' shit. \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_t\fP *__export \fBcfg_getnsec\fP (\fBcfg_t\fP *cfg, const char *name, unsigned int index)"
.br
.RI "\fIIndexed version of \fBcfg_getsec()\fP, used fo' sections wit tha CFGF_MULTI flag set. \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_t\fP *__export \fBcfg_opt_gettsec\fP (\fBcfg_opt_t\fP *opt, const char *title)"
.br
.RI "\fIReturns tha value of a section option, given a \fBcfg_opt_t\fP pointa n' tha title. \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_t\fP *__export \fBcfg_gettsec\fP (\fBcfg_t\fP *cfg, const char *name, const char *title)"
.br
.RI "\fIReturn a section given tha title, used fo' section wit tha CFGF_TITLE flag set. \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_t\fP *__export \fBcfg_getsec\fP (\fBcfg_t\fP *cfg, const char *name)"
.br
.RI "\fIReturns tha value of a section option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT unsigned int __export \fBcfg_opt_size\fP (\fBcfg_opt_t\fP *opt)"
.br
.RI "\fIReturn tha number of joints dis option has. \fP"
.ti -1c
.RI "DLLIMPORT unsigned int __export \fBcfg_size\fP (\fBcfg_t\fP *cfg, const char *name)"
.br
.RI "\fIReturn tha number of joints dis option has. \fP"
.ti -1c
.RI "DLLIMPORT const char *__export \fBcfg_title\fP (\fBcfg_t\fP *cfg)"
.br
.RI "\fIReturn tha title of a section. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT const char *__export \fBcfg_name\fP (\fBcfg_t\fP *cfg)"
.br
.RI "\fIReturn tha name of a section. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT const char *__export \fBcfg_opt_name\fP (\fBcfg_opt_t\fP *opt)"
.br
.RI "\fIReturn tha name of a option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT int __export \fBcfg_include\fP (\fBcfg_t\fP *cfg, \fBcfg_opt_t\fP *opt, int argc, const char **argv)"
.br
.RI "\fIPredefined include-function. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT char *__export \fBcfg_tilde_expand\fP (const char *filename)"
.br
.RI "\fIDo tilde expansion (~ -> $HOME) on tha filename. \fP"
.ti -1c
.RI "DLLIMPORT int __export \fBcfg_parse_boolean\fP (const char *s)"
.br
.RI "\fIParse a funky-ass boolean option string. \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_opt_t\fP *__export \fBcfg_getopt\fP (\fBcfg_t\fP *cfg, const char *name)"
.br
.RI "\fIReturn a option given itz name. \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_value_t\fP * \fBcfg_setopt\fP (\fBcfg_t\fP *cfg, \fBcfg_opt_t\fP *opt, char *value)"
.br
.RI "\fISet a option (create a instizzle of a option). \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_opt_setnint\fP (\fBcfg_opt_t\fP *opt, long int value, unsigned int index)"
.br
.RI "\fISet a value of a integer option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_setint\fP (\fBcfg_t\fP *cfg, const char *name, long int value)"
.br
.RI "\fISet tha value of a integer option given its name. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_setnint\fP (\fBcfg_t\fP *cfg, const char *name, long int value, unsigned int index)"
.br
.RI "\fISet a value of a integer option given its name n' index. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_opt_setnfloat\fP (\fBcfg_opt_t\fP *opt, double value, unsigned int index)"
.br
.RI "\fISet a value of a gangbangin' floatin point option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_setfloat\fP (\fBcfg_t\fP *cfg, const char *name, double value)"
.br
.RI "\fISet tha value of a gangbangin' floatin point option given its name. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_setnfloat\fP (\fBcfg_t\fP *cfg, const char *name, double value, unsigned int index)"
.br
.RI "\fISet a value of a gangbangin' floatin point option given its name n' index. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_opt_setnbool\fP (\fBcfg_opt_t\fP *opt, \fBcfg_bool_t\fP value, unsigned int index)"
.br
.RI "\fISet a value of a funky-ass boolean option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_setbool\fP (\fBcfg_t\fP *cfg, const char *name, \fBcfg_bool_t\fP value)"
.br
.RI "\fISet tha value of a funky-ass boolean option given its name. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_setnbool\fP (\fBcfg_t\fP *cfg, const char *name, \fBcfg_bool_t\fP value, unsigned int index)"
.br
.RI "\fISet a value of a funky-ass boolean option given its name n' index. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_opt_setnstr\fP (\fBcfg_opt_t\fP *opt, const char *value, unsigned int index)"
.br
.RI "\fISet a value of a strang option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_setstr\fP (\fBcfg_t\fP *cfg, const char *name, const char *value)"
.br
.RI "\fISet tha value of a strang option given its name. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_setnstr\fP (\fBcfg_t\fP *cfg, const char *name, const char *value, unsigned int index)"
.br
.RI "\fISet a value of a funky-ass boolean option given its name n' index. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_setlist\fP (\fBcfg_t\fP *cfg, const char *name, unsigned int nvalues,...)"
.br
.RI "\fISet joints fo' a list option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_addlist\fP (\fBcfg_t\fP *cfg, const char *name, unsigned int nvalues,...)"
.br
.RI "\fIAdd joints fo' a list option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_opt_nprint_var\fP (\fBcfg_opt_t\fP *opt, unsigned int index, FILE *fp)"
.br
.RI "\fIDefault value print function. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_opt_print_indent\fP (\fBcfg_opt_t\fP *opt, FILE *fp, int indent)"
.br
.RI "\fIPrint a option n' its value ta a gangbangin' file. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_opt_print\fP (\fBcfg_opt_t\fP *opt, FILE *fp)"
.br
.RI "\fIPrint a option n' its value ta a gangbangin' file. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_print_indent\fP (\fBcfg_t\fP *cfg, FILE *fp, int indent)"
.br
.RI "\fIPrint tha options n' joints ta a gangbangin' file. \fP"
.ti -1c
.RI "DLLIMPORT void __export \fBcfg_print\fP (\fBcfg_t\fP *cfg, FILE *fp)"
.br
.RI "\fIPrint tha options n' joints ta a gangbangin' file. \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_print_func_t\fP __export \fBcfg_opt_set_print_func\fP (\fBcfg_opt_t\fP *opt, \fBcfg_print_func_t\fP pf)"
.br
.RI "\fISet a print callback function fo' a option. I aint talkin' bout chicken n' gravy biatch. \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_print_func_t\fP __export \fBcfg_set_print_func\fP (\fBcfg_t\fP *cfg, const char *name, \fBcfg_print_func_t\fP pf)"
.br
.RI "\fISet a print callback function fo' a option given its name. \fP"
.ti -1c
.RI "DLLIMPORT \fBcfg_validate_callback_t\fP __export \fBcfg_set_validate_func\fP (\fBcfg_t\fP *cfg, const char *name, \fBcfg_validate_callback_t\fP vf)"
.br
.RI "\fIRegista a valipimpin callback function fo' a option. I aint talkin' bout chicken n' gravy biatch. \fP"
.in -1c
.SH "Detailed Description"
.PP 
A configuration file parser library. 


.SH "Define Documentation"
.PP 
.SS "#define CFG_END()   {0,CFGT_NONE,0,0,CFGF_NONE,0,{0,0,cfg_false,0,0},0,0,0,0,0,0}"
.PP
Terminizzle list of options. 
.PP
This must be tha last initializer up in tha option list. 
.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP, \fBreread.c\fP, n' \fBsimple.c\fP.
.SS "#define CFG_FUNC(name, func)   {name,CFGT_FUNC,0,0,CFGF_NONE,0,{0,0,cfg_false,0,0},func,0,0,0,0,0}"
.PP
Initialize a gangbangin' function. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP Da name of tha option 
.br
\fIfunc\fP Da callback function.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_func_t\fP 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP.
.SS "#define CFG_PTR_CB(name, def, flags, parsecb, freecb)   __CFG_PTR(name, def, flags, 0, parsecb, freecb)"
.PP
Initialize a user-defined option. I aint talkin' bout chicken n' gravy biatch. 
.PP
CFG_PTR options can only be used together wit a value parsin callback.
.PP
\fBParameters:\fP
.RS 4
\fIname\fP Da name of tha option 
.br
\fIdef\fP Default value 
.br
\fIflags\fP Flags 
.br
\fIparsecb\fP Value parsin callback 
.br
\fIfreecb\fP Memory release function
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_callback_t\fP, \fBcfg_free_func_t\fP 
.RE
.PP

.SS "#define CFG_SEC(name, opts, flags)   {name,CFGT_SEC,0,0,flags,opts,{0,0,cfg_false,0,0},0,0,0,0,0,0}"
.PP
Initialize a section. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP Da name of tha option 
.br
\fIopts\fP Array of options dat is valid within dis section
.br
\fIflags\fP Flags, specify CFGF_MULTI if it should be possible ta have multiplez of tha same section, n' CFGF_TITLE if tha section(s) must gotz a title (which can be used up in tha \fBcfg_gettsec()\fP function) 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP, n' \fBreread.c\fP.
.SS "#define CFG_SIMPLE_STR(name, svalue)   __CFG_STR(name, 0, CFGF_NONE, svalue, 0)"
.PP
Initialize a 'simple' strang option. I aint talkin' bout chicken n' gravy biatch. 
.PP
'Simple' options (in lack of a funky-ass betta expression) do not support listz of joints or multiple sections. LibConfuse will store tha value of a simple option up in tha user-defined location specified by tha value parameta up in tha initializer n' shit. Right back up in yo muthafuckin ass. Simple options is not stored up in tha \fBcfg_t\fP context, only a pointer n' shit. Right back up in yo muthafuckin ass. Sections can not be initialized as a 'simple' option.
.PP
Az of version 2.2, libConfuse can now return tha jointz of simple options wit tha cfg_get functions. This allows rockin tha freshly smoked up cfg_print function wit simple options.
.PP
libConfuse don't support handlin default joints fo' 'simple' options. They is assumed ta be set by tha callin application before cfg_parse is called.
.PP
\fBParameters:\fP
.RS 4
\fIname\fP name of tha option 
.br
\fIsvalue\fP pointa ta a cold-ass lil characta pointa (a char **). This value must be initalized either ta NULL or ta a malloc()'ed string. Yo ass can't use 
.PP
.nf

 char *user = 'joe';
 ...
 \fBcfg_opt_t\fP opts[] = {
     CFG_SIMPLE_STR('user', &user),
 ...
 
.fi
.PP
 since libConfuse will try ta free tha static strang 'joe' (which be a error) when a 'user' option is found. Y'all KNOW dat shit, muthafucka! Rather, use tha followin code snippet: 
.PP
.nf

 char *user = strdup('joe');
 ...
 \fBcfg_opt_t\fP opts[] = {
      CFG_SIMPLE_STR('user', &user),
 ...
 
.fi
.PP
 Alternatively, tha default value can be set afta tha opts struct is defined, as in: 
.PP
.nf

 char *user = 0;
 ...
 \fBcfg_opt_t\fP opts[] = {
      CFG_SIMPLE_STR('user', &user),
 ...
 user = strdup('joe');
 cfg = cfg_init(opts, 0);
 cfg_parse(cfg, filename);
 
.fi
.PP
 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBsimple.c\fP.
.SS "#define CFG_SUCCESS   0"
.PP
Return codes from \fBcfg_parse()\fP. 
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP.
.PP
Referenced by cfg_parse_buf(), n' cfg_parse_fp().
.SS "#define CFGF_NONE   0"
.PP
Flags. 
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP, n' \fBreread.c\fP.
.SH "Typedef Documentation"
.PP 
.SS "typedef int(* \fBcfg_callback_t\fP)(\fBcfg_t\fP *cfg, \fBcfg_opt_t\fP *opt, const char *value, void *result)"
.PP
Value parsin callback prototype. 
.PP
This be a cold-ass lil callback function (different from tha one registered wit tha CFG_FUNC initializer) used ta parse a value. This can be used ta override tha internal parsin of a value.
.PP
Suppose you want a integer option dat only can have certain joints, fo' example 1, 2 n' 3, n' these should be freestyled up in tha configuration file as 'yes', 'no' n' 'maybe'. Da callback function would be called wit tha found value ('yes', 'no' or 'maybe') as a string, n' tha result should be stored up in tha result parameter.
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIopt\fP Da option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIvalue\fP Da value found up in tha configuration file. 
.br
\fIresult\fP Pointa ta storage fo' tha result, cast ta a void pointer.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 should be returned. Y'all KNOW dat shit, muthafucka! All other joints indicates a error, n' tha parsin be aborted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da callback function should notify tha error itself, fo' example by callin \fBcfg_error()\fP. 
.RE
.PP

.SS "typedef void(* \fBcfg_errfunc_t\fP)(\fBcfg_t\fP *cfg, const char *fmt, va_list ap)"
.PP
Error reportin function. I aint talkin' bout chicken n' gravy biatch. 
.PP

.SS "typedef void(* \fBcfg_free_func_t\fP)(void *value)"
.PP
User-defined memory release function fo' CFG_PTR joints, n' you can put dat on yo' toast. 
.PP
This callback is used ta free memory allocated up in a value parsin callback function. I aint talkin' bout chicken n' gravy biatch. Especially useful fo' CFG_PTR options, since libConfuse aint gonna itself release such joints, n' you can put dat on yo' toast. If tha joints is simply allocated wit a malloc(3), one can use tha standard free(3) function here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. 
.SS "typedef int(* \fBcfg_func_t\fP)(\fBcfg_t\fP *cfg, \fBcfg_opt_t\fP *opt, int argc, const char **argv)"
.PP
Function prototype used by CFGT_FUNC options. 
.PP
This be a cold-ass lil callback function, registered wit tha CFG_FUNC initializer n' shit. Each time libConfuse findz a gangbangin' function, tha registered callback function is called (parametas is passed as strings, any conversion ta other types should be made up in tha callback function). libConfuse do not support any storage of tha data found; these is passed as parametas ta tha callback, n' itz tha responsibilitizzle of tha callback function ta do whatever it should do wit tha data.
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIopt\fP Da option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIargc\fP Number of arguments passed. Y'all KNOW dat shit, muthafucka! Da callback function is responsible fo' checkin dat tha erect number of arguments is passed. Y'all KNOW dat shit, muthafucka! 
.br
\fIargv\fP Arguments as a array of characta strings.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 should be returned. Y'all KNOW dat shit, muthafucka! All other joints indicates a error, n' tha parsin be aborted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da callback function should notify tha error itself, fo' example by callin \fBcfg_error()\fP.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBCFG_FUNC\fP 
.RE
.PP

.SS "typedef void(* \fBcfg_print_func_t\fP)(\fBcfg_opt_t\fP *opt, unsigned int index, FILE *fp)"
.PP
Function prototype used by tha cfg_print_ functions. 
.PP
This callback function is used ta print option joints, n' you can put dat on yo' toast. For options wit a value parsin callback, dis is often required, especially if a strang is mapped ta a integer by tha callback. This print callback must then map tha integer back ta tha appropriate string.
.PP
Except fo' functions, tha print callback function should only print tha value of tha option, not tha name n' tha equal sign (that is handled by tha cfg_opt_print function). For function options however, tha name n' tha parenthesis must be printed by dis function. I aint talkin' bout chicken n' gravy biatch. Da value ta print can be accessed wit tha cfg_opt_get functions.
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fIindex\fP Index of tha value ta get. Zero based. Y'all KNOW dat shit, muthafucka! 
.br
\fIfp\fP File stream ta print to, use stdout ta print ta tha screen.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_print\fP, \fBcfg_set_print_func\fP 
.RE
.PP

.SS "typedef int(* \fBcfg_validate_callback_t\fP)(\fBcfg_t\fP *cfg, \fBcfg_opt_t\fP *opt)"
.PP
Valipimpin callback prototype. 
.PP
This callback function is called afta a option has been parsed n' set. Da function is called fo' both fundamenstrual joints (strings, integers etc) as well as lists n' sections. This can fo' example be used ta validate dat all required options up in a section has been set ta sane joints.
.PP
\fBReturns:\fP
.RS 4
On success, 0 should be returned. Y'all KNOW dat shit, muthafucka! All other joints indicates a error, n' tha parsin be aborted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da callback function should notify tha error itself, fo' example by callin \fBcfg_error()\fP.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_set_validate_func\fP 
.RE
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBcfg_bool_t\fP"
.PP
Boolean joints, n' you can put dat on yo' toast. 
.PP

.SS "enum \fBcfg_type_t\fP"
.PP
Fundamenstrual option types. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICFGT_INT \fP\fP
integer 
.TP
\fB\fICFGT_FLOAT \fP\fP
floatin point number 
.TP
\fB\fICFGT_STR \fP\fP
strin 
.TP
\fB\fICFGT_BOOL \fP\fP
boolean value 
.TP
\fB\fICFGT_SEC \fP\fP
section 
.TP
\fB\fICFGT_FUNC \fP\fP
function 
.TP
\fB\fICFGT_PTR \fP\fP
pointa ta user-defined value 
.SH "Function Documentation"
.PP 
.SS "DLLIMPORT void __export cfg_addlist (\fBcfg_t\fP * cfg, const char * name, unsigned int nvalues,  ...)"
.PP
Add joints fo' a list option. I aint talkin' bout chicken n' gravy biatch. 
.PP
Da freshly smoked up joints is appended ta any current joints up in tha list.
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fInvalues\fP Number of joints ta add. Y'all KNOW dat shit, muthafucka! 
.br
\fI...\fP Da joints ta add, tha type must match tha type of tha option n' tha number of joints must be equal ta tha nvalues parameter n' shit. 
.RE
.PP

.PP
References CFGF_LIST, n' cfg_opt_t::flags.
.SS "DLLIMPORT void __export cfg_error (\fBcfg_t\fP * cfg, const char * fmt,  ...)"
.PP
Show a parser error. Shiiit, dis aint no joke. 
.PP
Any user-defined error reportin function is called. Y'all KNOW dat shit, muthafucka! 
.PP
\fBSee also:\fP
.RS 4
\fBcfg_set_error_function\fP 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP.
.PP
References cfg_t::errfunc, cfg_t::filename, n' cfg_t::line.
.SS "DLLIMPORT void __export cfg_free (\fBcfg_t\fP * cfg)"
.PP
Jacked a \fBcfg_t\fP context. 
.PP
All memory allocated by tha \fBcfg_t\fP context structure is freed, n' can't be used up in any further cfg_* calls. 
.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP, \fBreread.c\fP, n' \fBsimple.c\fP.
.PP
References cfg_t::filename, cfg_t::name, cfg_opt_t::name, cfg_t::opts, n' cfg_t::title.
.SS "DLLIMPORT void __export cfg_free_value (\fBcfg_opt_t\fP * opt)"
.PP
Jacked tha memory allocated fo' tha jointz of a given option. I aint talkin' bout chicken n' gravy biatch. 
.PP
Only tha joints is freed, not tha option itself (it is freed by \fBcfg_free()\fP).
.PP
\fBSee also:\fP
.RS 4
\fBcfg_free()\fP 
.RE
.PP

.PP
References CFGT_PTR, CFGT_SEC, CFGT_STR, cfg_opt_t::freecb, cfg_opt_t::nvalues, cfg_value_t::ptr, cfg_value_t::section, cfg_value_t::string, cfg_opt_t::type, n' cfg_opt_t::values.
.SS "DLLIMPORT \fBcfg_bool_t\fP __export cfg_getbool (\fBcfg_t\fP * cfg, const char * name)"
.PP
Returns tha value of a funky-ass boolean option. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da axed value is returned. Y'all KNOW dat shit, muthafucka! If tha option was not set up in tha configuration file, tha default value given up in tha correspondin \fBcfg_opt_t\fP structure is returned. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a error ta try ta git a option dat aint declared. Y'all KNOW dat shit, muthafucka! 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP.
.SS "DLLIMPORT double __export cfg_getfloat (\fBcfg_t\fP * cfg, const char * name)"
.PP
Returns tha value of a gangbangin' floatin point option. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da axed value is returned. Y'all KNOW dat shit, muthafucka! If tha option was not set up in tha configuration file, tha default value given up in tha correspondin \fBcfg_opt_t\fP structure is returned. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a error ta try ta git a option dat aint declared. Y'all KNOW dat shit, muthafucka! 
.RE
.PP

.SS "DLLIMPORT long int __export cfg_getint (\fBcfg_t\fP * cfg, const char * name)"
.PP
Returns tha value of a integer option. I aint talkin' bout chicken n' gravy biatch. 
.PP
This is tha same ol' dirty as callin cfg_getnint wit index 0. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da axed value is returned. Y'all KNOW dat shit, muthafucka! If tha option was not set up in tha configuration file, tha default value given up in tha correspondin \fBcfg_opt_t\fP structure is returned. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a error ta try ta git a option dat aint declared. Y'all KNOW dat shit, muthafucka! 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP, n' \fBreread.c\fP.
.SS "DLLIMPORT \fBcfg_bool_t\fP __export cfg_getnbool (\fBcfg_t\fP * cfg, const char * name, unsigned int index)"
.PP
Indexed version of \fBcfg_getbool()\fP, used fo' lists, n' you can put dat on yo' toast. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIindex\fP Index of tha value ta get. Zero based. Y'all KNOW dat shit, muthafucka! 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_getbool\fP 
.RE
.PP

.SS "DLLIMPORT double __export cfg_getnfloat (\fBcfg_t\fP * cfg, const char * name, unsigned int index)"
.PP
Indexed version of \fBcfg_getfloat()\fP, used fo' lists, n' you can put dat on yo' toast. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIindex\fP Index of tha value ta get. Zero based. Y'all KNOW dat shit, muthafucka! 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_getfloat\fP 
.RE
.PP

.SS "DLLIMPORT long int __export cfg_getnint (\fBcfg_t\fP * cfg, const char * name, unsigned int index)"
.PP
Indexed version of \fBcfg_getint()\fP, used fo' lists, n' you can put dat on yo' toast. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIindex\fP Index of tha value ta get. Zero based. Y'all KNOW dat shit, muthafucka! 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_getint\fP 
.RE
.PP

.SS "DLLIMPORT \fBcfg_t\fP* __export cfg_getnsec (\fBcfg_t\fP * cfg, const char * name, unsigned int index)"
.PP
Indexed version of \fBcfg_getsec()\fP, used fo' sections wit tha CFGF_MULTI flag set. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIindex\fP Index of tha section ta get. Zero based. Y'all KNOW dat shit, muthafucka! 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_getsec\fP 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP, n' \fBreread.c\fP.
.SS "DLLIMPORT char* __export cfg_getnstr (\fBcfg_t\fP * cfg, const char * name, unsigned int index)"
.PP
Indexed version of \fBcfg_getstr()\fP, used fo' lists, n' you can put dat on yo' toast. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIindex\fP Index of tha value ta get. Zero based. Y'all KNOW dat shit, muthafucka! 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_getstr\fP 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP.
.SS "DLLIMPORT \fBcfg_opt_t\fP* __export cfg_getopt (\fBcfg_t\fP * cfg, const char * name)"
.PP
Return a option given itz name. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a pointa ta tha option. I aint talkin' bout chicken n' gravy biatch. If tha option aint declared, libConfuse will print a error message n' return 0. 
.RE
.PP

.PP
References CFGF_NOCASE, cfg_t::flags, cfg_opt_t::name, cfg_t::name, n' cfg_t::opts.
.SS "DLLIMPORT void* __export cfg_getptr (\fBcfg_t\fP * cfg, const char * name)"
.PP
Returns tha value of a user-defined option (void pointer). 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da axed value is returned. Y'all KNOW dat shit, muthafucka! If tha option was not set up in tha configuration file, tha default value given up in tha correspondin \fBcfg_opt_t\fP structure is returned. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a error ta try ta git a option dat aint declared. Y'all KNOW dat shit, muthafucka! 
.RE
.PP

.SS "DLLIMPORT \fBcfg_t\fP* __export cfg_getsec (\fBcfg_t\fP * cfg, const char * name)"
.PP
Returns tha value of a section option. I aint talkin' bout chicken n' gravy biatch. 
.PP
Da returned value be another \fBcfg_t\fP structure dat can be used up in followin calls ta cfg_getint, cfg_getstr or other get-functions. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da axed section is returned. Y'all KNOW dat shit, muthafucka! If no section is found wit dat name, 0 is returned. Y'all KNOW dat shit, muthafucka! There can only be default joints fo' section without tha CFGF_MULTI flag set. Well shiiiit, it be a error ta try ta git a section dat aint declared. Y'all KNOW dat shit, muthafucka! 
.RE
.PP

.SS "DLLIMPORT char* __export cfg_getstr (\fBcfg_t\fP * cfg, const char * name)"
.PP
Returns tha value of a strang option. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da axed value is returned. Y'all KNOW dat shit, muthafucka! If tha option was not set up in tha configuration file, tha default value given up in tha correspondin \fBcfg_opt_t\fP structure is returned. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a error ta try ta git a option dat aint declared. Y'all KNOW dat shit, muthafucka! 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP, n' \fBreread.c\fP.
.SS "DLLIMPORT \fBcfg_t\fP* __export cfg_gettsec (\fBcfg_t\fP * cfg, const char * name, const char * title)"
.PP
Return a section given tha title, used fo' section wit tha CFGF_TITLE flag set. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fItitle\fP Da title of dis section. I aint talkin' bout chicken n' gravy biatch. Da CFGF_TITLE flag must done been set fo' dis option. I aint talkin' bout chicken n' gravy biatch. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_getsec\fP 
.RE
.PP

.SS "DLLIMPORT int __export cfg_include (\fBcfg_t\fP * cfg, \fBcfg_opt_t\fP * opt, int argc, const char ** argv)"
.PP
Predefined include-function. I aint talkin' bout chicken n' gravy biatch. 
.PP
This function can be used up in tha options passed ta \fBcfg_init()\fP ta specify a gangbangin' function fo' includin other configuration filez up in tha parsing. For example: CFG_FUNC('include', &cfg_include) 
.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP.
.SS "DLLIMPORT \fBcfg_t\fP* __export cfg_init (\fBcfg_opt_t\fP * opts, cfg_flag_t flags)"
.PP
Smoke n' initialize a \fBcfg_t\fP structure. 
.PP
This should be tha straight-up original gangsta function called when settin up tha parsin of a cold-ass lil configuration file. Da options passed up in tha straight-up original gangsta parameta is initialized rockin tha CFG_* initializers. Da last option up in tha option array must be \fBCFG_END()\fP, unless you like segmentation faults.
.PP
Da options must no longer be defined up in tha same scope as where tha cfg_xxx functions is used (since version 2.3).
.PP
\fBParameters:\fP
.RS 4
\fIopts\fP An arrary of options 
.br
\fIflags\fP One or mo' flags (bitwise or'ed together). Currently only CFGF_NOCASE be available. Use 0 if no flags is needed.
.RE
.PP
\fBReturns:\fP
.RS 4
A configuration context structure. This pointa is passed ta almost all other functions as tha straight-up original gangsta parameter n' shit. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP, \fBreread.c\fP, n' \fBsimple.c\fP.
.PP
References cfg_t::errfunc, cfg_t::filename, cfg_t::flags, cfg_t::line, cfg_t::name, n' cfg_t::opts.
.SS "DLLIMPORT const char* __export cfg_name (\fBcfg_t\fP * cfg)"
.PP
Return tha name of a section. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns tha title, or 0 if there is no title. This strang should not be modified. Y'all KNOW dat shit, muthafucka! 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP.
.PP
References cfg_t::name.
.SS "DLLIMPORT \fBcfg_bool_t\fP __export cfg_opt_getnbool (\fBcfg_opt_t\fP * opt, unsigned int index)"
.PP
Returns tha value of a funky-ass boolean option, given a \fBcfg_opt_t\fP pointer n' shit. 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fIindex\fP Index of tha value ta get. Zero based. Y'all KNOW dat shit, muthafucka! 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_getnbool\fP 
.RE
.PP

.PP
References cfg_value_t::boolean, CFGT_BOOL, cfg_opt_t::simple_value, cfg_opt_t::type, n' cfg_opt_t::values.
.SS "DLLIMPORT double __export cfg_opt_getnfloat (\fBcfg_opt_t\fP * opt, unsigned int index)"
.PP
Returns tha value of a gangbangin' floatin point option, given a \fBcfg_opt_t\fP pointer n' shit. 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fIindex\fP Index of tha value ta get. Zero based. Y'all KNOW dat shit, muthafucka! 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_getnfloat\fP 
.RE
.PP

.PP
References CFGT_FLOAT, cfg_value_t::fpnumber, cfg_opt_t::simple_value, cfg_opt_t::type, n' cfg_opt_t::values.
.SS "DLLIMPORT signed long __export cfg_opt_getnint (\fBcfg_opt_t\fP * opt, unsigned int index)"
.PP
Returns tha value of a integer option, given a \fBcfg_opt_t\fP pointer n' shit. 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fIindex\fP Index of tha value ta get. Zero based. Y'all KNOW dat shit, muthafucka! 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_getnint\fP 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP.
.PP
References CFGT_INT, cfg_value_t::number, cfg_opt_t::simple_value, cfg_opt_t::type, n' cfg_opt_t::values.
.SS "DLLIMPORT \fBcfg_t\fP* __export cfg_opt_getnsec (\fBcfg_opt_t\fP * opt, unsigned int index)"
.PP
Returns tha value of a section option, given a \fBcfg_opt_t\fP pointer n' shit. 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fIindex\fP Index of tha value ta get. Zero based. Y'all KNOW dat shit, muthafucka! 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_getnsec\fP 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP.
.PP
References CFGT_SEC, cfg_value_t::section, cfg_opt_t::type, n' cfg_opt_t::values.
.SS "DLLIMPORT char* __export cfg_opt_getnstr (\fBcfg_opt_t\fP * opt, unsigned int index)"
.PP
Returns tha value of a strang option, given a \fBcfg_opt_t\fP pointer n' shit. 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fIindex\fP Index of tha value ta get. Zero based. Y'all KNOW dat shit, muthafucka! 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_getnstr\fP 
.RE
.PP

.PP
References CFGT_STR, cfg_opt_t::simple_value, cfg_value_t::string, cfg_opt_t::type, n' cfg_opt_t::values.
.SS "DLLIMPORT \fBcfg_t\fP* __export cfg_opt_gettsec (\fBcfg_opt_t\fP * opt, const char * title)"
.PP
Returns tha value of a section option, given a \fBcfg_opt_t\fP pointa n' tha title. 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fItitle\fP Da title of dis section. I aint talkin' bout chicken n' gravy biatch. Da CFGF_TITLE flag must done been set fo' dis option. I aint talkin' bout chicken n' gravy biatch. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_gettsec\fP 
.RE
.PP

.PP
References CFGF_NOCASE, CFGF_TITLE, cfg_opt_t::flags, n' cfg_t::title.
.SS "DLLIMPORT const char* __export cfg_opt_name (\fBcfg_opt_t\fP * opt)"
.PP
Return tha name of a option. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns tha title, or 0 if there is no title. This strang should not be modified. Y'all KNOW dat shit, muthafucka! 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP.
.PP
References cfg_opt_t::name.
.SS "DLLIMPORT void __export cfg_opt_nprint_var (\fBcfg_opt_t\fP * opt, unsigned int index, FILE * fp)"
.PP
Default value print function. I aint talkin' bout chicken n' gravy biatch. 
.PP
Print only tha value of a given option. I aint talkin' bout chicken n' gravy biatch. Do not handle sections or functions. Use cfg_opt_print ta print tha whole assignment ('option = value'), or cfg_print ta print tha whole config file.
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fIindex\fP Da index up in tha option value array dat should be printed 
.br
\fIfp\fP File stream ta print to.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_print\fP, \fBcfg_opt_print\fP 
.RE
.PP

.PP
References CFGT_BOOL, CFGT_FLOAT, CFGT_FUNC, CFGT_INT, CFGT_PTR, CFGT_SEC, CFGT_STR, n' cfg_opt_t::type.
.SS "DLLIMPORT void __export cfg_opt_print (\fBcfg_opt_t\fP * opt, FILE * fp)"
.PP
Print a option n' its value ta a gangbangin' file. 
.PP
If a print callback function is specified fo' tha option, it is used instead of cfg_opt_nprint_var.
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fIfp\fP File stream ta print to.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_print_func_t\fP 
.RE
.PP

.SS "DLLIMPORT void __export cfg_opt_print_indent (\fBcfg_opt_t\fP * opt, FILE * fp, int indent)"
.PP
Print a option n' its value ta a gangbangin' file. 
.PP
Same as cfg_opt_print yo, but wit tha indentation level specified. Y'all KNOW dat shit, muthafucka! 
.PP
\fBSee also:\fP
.RS 4
\fBcfg_opt_print\fP 
.RE
.PP

.PP
References CFGF_LIST, CFGF_TITLE, CFGT_FUNC, CFGT_SEC, CFGT_STR, cfg_opt_t::flags, cfg_opt_t::name, cfg_opt_t::nvalues, cfg_opt_t::pf, cfg_opt_t::simple_value, cfg_value_t::string, cfg_opt_t::type, n' cfg_opt_t::values.
.SS "DLLIMPORT \fBcfg_print_func_t\fP __export cfg_opt_set_print_func (\fBcfg_opt_t\fP * opt, \fBcfg_print_func_t\fP pf)"
.PP
Set a print callback function fo' a option. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fIpf\fP Da print function callback.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_print_func_t\fP 
.RE
.PP

.PP
References cfg_opt_t::pf.
.SS "DLLIMPORT void __export cfg_opt_setnbool (\fBcfg_opt_t\fP * opt, \fBcfg_bool_t\fP value, unsigned int index)"
.PP
Set a value of a funky-ass boolean option. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fIvalue\fP Da value ta set. 
.br
\fIindex\fP Da index up in tha option value array dat should be modified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a error ta set joints wit indices larger than 0 fo' options without tha CFGF_LIST flag set. 
.RE
.PP

.PP
References cfg_value_t::boolean, CFGT_BOOL, n' cfg_opt_t::type.
.SS "DLLIMPORT void __export cfg_opt_setnfloat (\fBcfg_opt_t\fP * opt, double value, unsigned int index)"
.PP
Set a value of a gangbangin' floatin point option. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fIvalue\fP Da value ta set. 
.br
\fIindex\fP Da index up in tha option value array dat should be modified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a error ta set joints wit indices larger than 0 fo' options without tha CFGF_LIST flag set. 
.RE
.PP

.PP
References CFGT_FLOAT, cfg_value_t::fpnumber, n' cfg_opt_t::type.
.SS "DLLIMPORT void __export cfg_opt_setnint (\fBcfg_opt_t\fP * opt, long int value, unsigned int index)"
.PP
Set a value of a integer option. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fIvalue\fP Da value ta set. 
.br
\fIindex\fP Da index up in tha option value array dat should be modified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a error ta set joints wit indices larger than 0 fo' options without tha CFGF_LIST flag set. 
.RE
.PP

.PP
References CFGT_INT, cfg_value_t::number, n' cfg_opt_t::type.
.SS "DLLIMPORT void __export cfg_opt_setnstr (\fBcfg_opt_t\fP * opt, const char * value, unsigned int index)"
.PP
Set a value of a strang option. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.br
\fIvalue\fP Da value ta set. Memory fo' tha strang be allocated n' tha value is copied. Y'all KNOW dat shit, muthafucka! Any previous strang value is freed. Y'all KNOW dat shit, muthafucka! 
.br
\fIindex\fP Da index up in tha option value array dat should be modified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a error ta set joints wit indices larger than 0 fo' options without tha CFGF_LIST flag set. 
.RE
.PP

.PP
References CFGT_STR, cfg_value_t::string, n' cfg_opt_t::type.
.SS "DLLIMPORT unsigned int __export cfg_opt_size (\fBcfg_opt_t\fP * opt)"
.PP
Return tha number of joints dis option has. 
.PP
If no default value is given fo' tha option n' no value was found up in tha config file, 0 is ghon be returned (ie, tha option value aint set at all). 
.PP
\fBParameters:\fP
.RS 4
\fIopt\fP Da option structure (eg, as returned from \fBcfg_getopt()\fP) 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP.
.PP
References cfg_opt_t::nvalues.
.SS "DLLIMPORT int __export cfg_parse (\fBcfg_t\fP * cfg, const char * filename)"
.PP
Parse a cold-ass lil configuration file. 
.PP
Tilde expansion is performed on tha filename before it is opened. Y'all KNOW dat shit, muthafucka! Afta a cold-ass lil configuration file has been initialized (with \fBcfg_init()\fP) n' parsed (with \fBcfg_parse()\fP), tha joints can be read wit tha cfg_getXXX functions.
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context as returned from \fBcfg_init()\fP. 
.br
\fIfilename\fP Da name of tha file ta parse.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, CFG_SUCCESS is returned. Y'all KNOW dat shit, muthafucka! If tha file couldn't be opened fo' reading, CFG_FILE_ERROR is returned. Y'all KNOW dat shit, muthafucka! On all other errors, CFG_PARSE_ERROR is returned n' \fBcfg_error()\fP was called wit a thugged-out descriptizzle error message. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP, \fBreread.c\fP, n' \fBsimple.c\fP.
.PP
References cfg_t::filename.
.SS "DLLIMPORT int __export cfg_parse_boolean (const char * s)"
.PP
Parse a funky-ass boolean option string. 
.PP
Accepted 'true' joints is 'true', 'on' n' 'yes', n' accepted 'false' joints is 'false', 'off' n' 'no'.
.PP
\fBReturns:\fP
.RS 4
Returns 1 or 0 (true/false) if tha strang was parsed erectly, or -1 if a error occurred. Y'all KNOW dat shit, muthafucka! 
.RE
.PP

.SS "DLLIMPORT int __export cfg_parse_buf (\fBcfg_t\fP * cfg, const char * buf)"
.PP
Same as \fBcfg_parse()\fP above yo, but takes a cold-ass lil characta buffer as argument. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context as returned from \fBcfg_init()\fP. 
.br
\fIbuf\fP A zero-terminated strang wit configuration directives.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_parse()\fP 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBreread.c\fP.
.PP
References CFG_SUCCESS, cfg_t::filename, n' cfg_t::line.
.SS "DLLIMPORT int __export cfg_parse_fp (\fBcfg_t\fP * cfg, FILE * fp)"
.PP
Same as \fBcfg_parse()\fP above yo, but takes a already opened file as argument. 
.PP
Readin begins all up in tha current position. I aint talkin' bout chicken n' gravy biatch fo' realz. Afta parsing, tha posizzle aint reset. Da calla is responsible fo' closin tha file.
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context as returned from \fBcfg_init()\fP. 
.br
\fIfp\fP An open file stream.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_parse()\fP 
.RE
.PP

.PP
References CFG_SUCCESS, cfg_t::filename, n' cfg_t::line.
.SS "DLLIMPORT void __export cfg_print (\fBcfg_t\fP * cfg, FILE * fp)"
.PP
Print tha options n' joints ta a gangbangin' file. 
.PP
Note dat options up in any included file is expanded n' printed directly ta tha file. Option joints given wit environment variablez up in tha parsed input is also printed expanded. Y'all KNOW dat shit, muthafucka! This means dat if you parse a cold-ass lil configuration file you can't expect dat tha output from dis function is identical ta tha initial file.
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIfp\fP File stream ta print to, use stdout ta print ta tha screen.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_print_func_t\fP, \fBcfg_set_print_func\fP 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBsimple.c\fP.
.SS "DLLIMPORT void __export cfg_print_indent (\fBcfg_t\fP * cfg, FILE * fp, int indent)"
.PP
Print tha options n' joints ta a gangbangin' file. 
.PP
Same as cfg_print yo, but wit tha indentation level specified. Y'all KNOW dat shit, muthafucka! 
.PP
\fBSee also:\fP
.RS 4
\fBcfg_print\fP 
.RE
.PP

.PP
References cfg_opt_t::name, n' cfg_t::opts.
.SS "DLLIMPORT \fBcfg_errfunc_t\fP __export cfg_set_error_function (\fBcfg_t\fP * cfg, \fBcfg_errfunc_t\fP errfunc)"
.PP
Install a user-defined error reportin function. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBReturns:\fP
.RS 4
Da oldschool error reportin function is returned. Y'all KNOW dat shit, muthafucka! 
.RE
.PP

.PP
References cfg_t::errfunc.
.SS "DLLIMPORT \fBcfg_print_func_t\fP __export cfg_set_print_func (\fBcfg_t\fP * cfg, const char * name, \fBcfg_print_func_t\fP pf)"
.PP
Set a print callback function fo' a option given its name. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIpf\fP Da print callback function.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_print_func_t\fP 
.RE
.PP

.SS "DLLIMPORT \fBcfg_validate_callback_t\fP __export cfg_set_validate_func (\fBcfg_t\fP * cfg, const char * name, \fBcfg_validate_callback_t\fP vf)"
.PP
Regista a valipimpin callback function fo' a option. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIvf\fP Da valipimpin callback function.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcfg_validate_callback_t\fP 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP.
.PP
References cfg_t::flags, cfg_t::opts, n' cfg_opt_t::validcb.
.SS "DLLIMPORT void __export cfg_setbool (\fBcfg_t\fP * cfg, const char * name, \fBcfg_bool_t\fP value)"
.PP
Set tha value of a funky-ass boolean option given its name. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIvalue\fP Da value ta set. If tha option be a list (the CFGF_LIST flag is set), only tha straight-up original gangsta value (with index 0) is set. 
.RE
.PP

.SS "DLLIMPORT void __export cfg_setfloat (\fBcfg_t\fP * cfg, const char * name, double value)"
.PP
Set tha value of a gangbangin' floatin point option given its name. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIvalue\fP Da value ta set. If tha option be a list (the CFGF_LIST flag is set), only tha straight-up original gangsta value (with index 0) is set. 
.RE
.PP

.SS "DLLIMPORT void __export cfg_setint (\fBcfg_t\fP * cfg, const char * name, long int value)"
.PP
Set tha value of a integer option given its name. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIvalue\fP Da value ta set. If tha option be a list (the CFGF_LIST flag is set), only tha straight-up original gangsta value (with index 0) is set. 
.RE
.PP

.SS "DLLIMPORT void __export cfg_setlist (\fBcfg_t\fP * cfg, const char * name, unsigned int nvalues,  ...)"
.PP
Set joints fo' a list option. I aint talkin' bout chicken n' gravy biatch. 
.PP
All existin joints is replaced wit tha freshly smoked up ones.
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fInvalues\fP Number of joints ta set. 
.br
\fI...\fP Da joints ta set, tha type must match tha type of tha option n' tha number of joints must be equal ta tha nvalues parameter n' shit. 
.RE
.PP

.PP
References CFGF_LIST, n' cfg_opt_t::flags.
.SS "DLLIMPORT void __export cfg_setnbool (\fBcfg_t\fP * cfg, const char * name, \fBcfg_bool_t\fP value, unsigned int index)"
.PP
Set a value of a funky-ass boolean option given its name n' index. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIvalue\fP Da value ta set. 
.br
\fIindex\fP Da index up in tha option value array dat should be modified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a error ta set joints wit indices larger than 0 fo' options without tha CFGF_LIST flag set. 
.RE
.PP

.SS "DLLIMPORT void __export cfg_setnfloat (\fBcfg_t\fP * cfg, const char * name, double value, unsigned int index)"
.PP
Set a value of a gangbangin' floatin point option given its name n' index. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIvalue\fP Da value ta set. 
.br
\fIindex\fP Da index up in tha option value array dat should be modified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a error ta set joints wit indices larger than 0 fo' options without tha CFGF_LIST flag set. 
.RE
.PP

.SS "DLLIMPORT void __export cfg_setnint (\fBcfg_t\fP * cfg, const char * name, long int value, unsigned int index)"
.PP
Set a value of a integer option given its name n' index. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIvalue\fP Da value ta set. 
.br
\fIindex\fP Da index up in tha option value array dat should be modified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a error ta set joints wit indices larger than 0 fo' options without tha CFGF_LIST flag set. 
.RE
.PP

.SS "DLLIMPORT void __export cfg_setnstr (\fBcfg_t\fP * cfg, const char * name, const char * value, unsigned int index)"
.PP
Set a value of a funky-ass boolean option given its name n' index. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIvalue\fP Da value ta set. Memory fo' tha strang be allocated n' tha value is copied. Y'all KNOW dat shit, muthafucka! Any privious strang value is freed. Y'all KNOW dat shit, muthafucka! 
.br
\fIindex\fP Da index up in tha option value array dat should be modified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a error ta set joints wit indices larger than 0 fo' options without tha CFGF_LIST flag set. 
.RE
.PP

.SS "DLLIMPORT \fBcfg_value_t\fP* cfg_setopt (\fBcfg_t\fP * cfg, \fBcfg_opt_t\fP * opt, char * value)"
.PP
Set a option (create a instizzle of a option). 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIopt\fP Da option definition. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIvalue\fP Da initial value fo' tha option.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a pointa ta tha value object. 
.RE
.PP

.PP
References cfg_value_t::boolean, CFGF_LIST, CFGF_MULTI, CFGF_NO_TITLE_DUPES, CFGF_NOCASE, CFGF_TITLE, CFGT_BOOL, CFGT_FLOAT, CFGT_INT, CFGT_PTR, CFGT_SEC, CFGT_STR, cfg_t::errfunc, cfg_t::filename, cfg_t::flags, cfg_opt_t::flags, cfg_value_t::fpnumber, cfg_t::line, cfg_t::name, cfg_opt_t::name, cfg_value_t::number, cfg_opt_t::nvalues, cfg_t::opts, cfg_opt_t::parsecb, cfg_value_t::ptr, cfg_value_t::section, cfg_opt_t::simple_value, cfg_value_t::string, cfg_opt_t::subopts, cfg_t::title, cfg_opt_t::type, n' cfg_opt_t::values.
.SS "DLLIMPORT void __export cfg_setstr (\fBcfg_t\fP * cfg, const char * name, const char * value)"
.PP
Set tha value of a strang option given its name. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.br
\fIvalue\fP Da value ta set. Memory fo' tha strang be allocated n' tha value is copied. Y'all KNOW dat shit, muthafucka! Any previous strang value is freed. Y'all KNOW dat shit, muthafucka! If tha option be a list (the CFGF_LIST flag is set), only tha straight-up original gangsta value (with index 0) is set. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBsimple.c\fP.
.SS "DLLIMPORT unsigned int __export cfg_size (\fBcfg_t\fP * cfg, const char * name)"
.PP
Return tha number of joints dis option has. 
.PP
If no default value is given fo' tha option n' no value was found up in tha config file, 0 is ghon be returned (ie, tha option value aint set at all).
.PP
Note dat there is no way ta *not* specify a thugged-out default value fo' integers, floats n' booleans. Ie, they always have default joints (since 0 or NULL be a valid integer/float/boolean value). Only strings n' lists may have no default value.
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.br
\fIname\fP Da name of tha option. I aint talkin' bout chicken n' gravy biatch. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBftpconf.c\fP, n' \fBreread.c\fP.
.SS "DLLIMPORT char* __export cfg_tilde_expand (const char * filename)"
.PP
Do tilde expansion (~ -> $HOME) on tha filename. 
.PP
\fBReturns:\fP
.RS 4
Da expanded filename is returned. Y'all KNOW dat shit, muthafucka! If a ~user was not found, tha original gangsta filename is returned. Y'all KNOW dat shit, muthafucka! In any case, a thugged-out dynamically allocated strang is returned, which should be free()'d by tha calla n' shit. 
.RE
.PP

.SS "DLLIMPORT const char* __export cfg_title (\fBcfg_t\fP * cfg)"
.PP
Return tha title of a section. I aint talkin' bout chicken n' gravy biatch. 
.PP
\fBParameters:\fP
.RS 4
\fIcfg\fP Da configuration file context. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns tha title, or 0 if there is no title. This strang should not be modified. Y'all KNOW dat shit, muthafucka! 
.RE
.PP

.PP
References cfg_t::title.
.SH "Author"
.PP 
Generated automatically by Doxygen fo' confuse from tha source code.
