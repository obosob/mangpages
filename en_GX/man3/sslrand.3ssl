.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "rand 3"
.TH rand 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
rand \- pseudo\-random number generator
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rand.h>
\&
\& int  RAND_set_rand_engine(ENGINE *engine);
\&
\& int  RAND_bytes(unsigned char *buf, int num);
\& int  RAND_pseudo_bytes(unsigned char *buf, int num);
\&
\& void RAND_seed(const void *buf, int num);
\& void RAND_add(const void *buf, int num, int entropy);
\& int  RAND_status(void);
\&
\& int  RAND_load_file(const char *file, long max_bytes);
\& int  RAND_write_file(const char *file);
\& const char *RAND_file_name(char *file, size_t num);
\&
\& int  RAND_egd(const char *path);
\&
\& void RAND_set_rand_method(const RAND_METHOD *meth);
\& const RAND_METHOD *RAND_get_rand_method(void);
\& RAND_METHOD *RAND_SSLeay(void);
\&
\& void RAND_cleanup(void);
\&
\& /* For Win32 only */
\& void RAND_screen(void);
\& int RAND_event(UINT, WPARAM, LPARAM);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Since tha introduction of tha \s-1ENGINE API,\s0 tha recommended way of controlling
default implementations is by rockin tha \s-1ENGINE API\s0 functions. Da default
\&\fB\s-1RAND_METHOD\s0\fR, as set by \fIRAND_set_rand_method()\fR n' returned by
\&\fIRAND_get_rand_method()\fR, is only used if no \s-1ENGINE\s0 has been set as tha default
\&\*(L"rand\*(R" implementation. I aint talkin' bout chicken n' gravy biatch yo. Hence, these two functions is no longer tha recommened
way ta control defaults.
.PP
If a alternatizzle \fB\s-1RAND_METHOD\s0\fR implementation is bein used (either set
directly or as provided by a \s-1ENGINE\s0 module), then it is entirely responsible
for tha generation n' pimpment of a cold-ass lil cryptographically secure \s-1PRNG\s0 stream. The
mechanizzlez busted lyrics bout below relate solely ta tha software \s-1PRNG\s0 implementation
built up in ta OpenSSL n' used by default.
.PP
These functions implement a cold-ass lil cryptographically secure pseudo-random
number generator (\s-1PRNG\s0). Well shiiiit, it is used by other library functions for
example ta generate random keys, n' applications can use it when they
need randomness.
.PP
A cryptographic \s-1PRNG\s0 must be seeded wit unpredictable data such as
mouse movements or keys pressed at random by tha user n' shit. This is
busted lyrics bout up in \fIRAND_add\fR\|(3). Its state can be saved up in a seed file
(see \fIRAND_load_file\fR\|(3)) ta avoid havin ta go all up in the
seedin process whenever tha application is started.
.PP
\&\fIRAND_bytes\fR\|(3) raps bout how tha fuck ta obtain random data from the
\&\s-1PRNG. \s0
.SH "INTERNALS"
.IX Header "INTERNALS"
Da \fIRAND_SSLeay()\fR method implements a \s-1PRNG\s0 based on a cold-ass lil cryptographic
hash function.
.PP
Da followin description of its design is based on tha SSLeay
documentation:
.PP
First up I'ma state tha thangs I believe I need fo' a phat \s-1RNG.\s0
.IP "1." 4
A phat hashin algorithm ta mix thangs up n' ta convert tha \s-1RNG \s0'state'
to random numbers.
.IP "2." 4
An initial source of random 'state'.
.IP "3." 4
Da state should be straight-up large.  If tha \s-1RNG\s0 is bein used ta generate
4096 bit \s-1RSA\s0 keys, 2 2048 bit random strings is required (at a minimum).
If yo' \s-1RNG\s0 state only has 128 bits, yo ass is obviously limitin the
search space ta 128 bits, not 2048.  I be probably gettin a lil
carried away on dis last point but it do indicate dat it may not be
a wack scam ta keep like a shitload of \s-1RNG\s0 state.  It should be easier to
break a cold-ass lil cipher than guess tha \s-1RNG\s0 seed data.
.IP "4." 4
Any \s-1RNG\s0 seed data should influence all subsequent random numbers
generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This implies dat any random seed data entered will have
an influence on all subsequent random numbers generated.
.IP "5." 4
When rockin data ta seed tha \s-1RNG\s0 state, tha data used should not be
extractable from tha \s-1RNG\s0 state.  I believe dis should be a
requirement cuz one possible source of 'secret' semi random
data would be a private key or a password. Y'all KNOW dat shit, muthafucka!  This data must
not be disclosed by either subsequent random numbers or a
\&'core' dump left by a program crash.
.IP "6." 4
Given tha same initial 'state', 2 systems should deviate up in they \s-1RNG\s0 state
(and hence tha random numbers generated) over time if at all possible.
.IP "7." 4
Given tha random number output stream, it should not be possible ta determine
the \s-1RNG\s0 state or tha next random number.
.PP
Da algorithm be as bigs up.
.PP
There is global state made up of a 1023 byte buffer (the 'state'), a
workin hash value ('md'), n' a cold-ass lil counta ('count').
.PP
Whenever seed data be added, it is banged tha fuck into tha 'state' as
bigs up.
.PP
Da input is chopped up tha fuck into unitz of 20 bytes (or less for
the last block).  Each of these blocks is run all up in tha hash
function as bigs up:  Da data passed ta tha hash function
is tha current 'md', tha same number of bytes from tha 'state'
(the location determined by up in incremented loopin index) as
the current 'block', tha freshly smoked up key data 'block', n' 'count'
(which is incremented afta each use).
Da result of dis is kept up in 'md' n' also xored tha fuck into the
\&'state' all up in tha same locations dat was used as input tha fuck into the
hash function. I aint talkin' bout chicken n' gravy biatch. I
believe dis system addresses points 1 (hash function; currently
\&\s-1SHA\-1\s0), 3 (the 'state'), 4 (via tha 'md'), 5 (by tha use of a hash
function n' xor).
.PP
When bytes is extracted from tha \s-1RNG,\s0 tha followin process is used.
For each crew of 10 bytes (or less), our phat asses do tha following:
.PP
Input tha fuck into tha hash function tha local 'md' (which is initialized from
the global 'md' before any bytes is generated), tha bytes dat is to
be overwritten by tha random bytes, n' bytes from tha 'state'
(incrementin loopin index). From dis digest output (which is kept
in 'md'), tha top (up to) 10 bytes is moonwalked back ta tha calla n' the
bottom 10 bytes is xored tha fuck into tha 'state'.
.PP
Finally, afta our crazy asses have finished 'num' random bytes fo' tha caller,
\&'count' (which is incremented) n' tha local n' global 'md' is fed
into tha hash function n' tha thangs up in dis biatch is kept up in tha global 'md'.
.PP
I believe tha above addressed points 1 (use of \s-1SHA\-1\s0), 6 (by hashing
into tha 'state' tha 'old' data from tha calla dat be bout ta be
overwritten) n' 7 (by not rockin tha 10 bytes given ta tha calla to
update tha 'state' yo, but they is used ta update 'md').
.PP
So of tha points raised, only 2 aint addressed (but see
\&\fIRAND_add\fR\|(3)).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBN_rand\fR\|(3), \fIRAND_add\fR\|(3),
\&\fIRAND_load_file\fR\|(3), \fIRAND_egd\fR\|(3),
\&\fIRAND_bytes\fR\|(3),
\&\fIRAND_set_rand_method\fR\|(3),
\&\fIRAND_cleanup\fR\|(3)
