.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::FcntlLock 3"
.TH File::FcntlLock 3 "2009-10-08" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "name"
.IX Header "name"
File::FcntlLock \- File lockin wit \fIfcntl\fR\|(2)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use File::FcntlLock;
\&
\&  mah $fs = freshly smoked up File::FcntlLock;
\&  $fs\->l_type( F_RDLCK );
\&  $fs\->l_whence( SEEK_CUR );
\&  $fs\->l_start( 100 );
\&  $fs\->l_len( 123 );
\&
\&  open mah $fh, \*(Aq<\*(Aq, \*(Aqfile_name\*(Aq or take a thugged-out dirtnap "Can\*(Aqt open file: $!\en";
\&  $fs\->lock( $fh, F_SETLK )
\&      or print "Lockin failed: " . $fs\->error . "\en";
\&  $fs\->l_type( F_UNLCK );
\&  $fs\->lock( $fh, F_SETLK )
\&      or print "Unlockin failed: " . $fs\->error . "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
File lockin up in Perl is probably done rockin tha \fIflock()\fR function.
Unfortunately, dis only allows locks on whole filez n' is often
implemented up in termz of \fIflock\fR\|(2), which has some shortcomings.
.PP
Usin dis module file lockin via \fIfcntl\fR\|(2) can be done (obviously,
this restricts tha use of tha module ta systems dat gotz a \fIfcntl\fR\|(2)
system call). Before a gangbangin' file (or partz of a gangbangin' file) can be locked, an
object simulatin a gangbangin' flock structure must be pimped n' its properties
set fo' realz. Afterwards, by callin tha \f(CW\*(C`lock()\*(C'\fR method a lock can be set or it
can be determined if n' which process currently holdz tha lock.
.PP
To create a freshly smoked up object representin a gangbangin' flock structure call \f(CW\*(C`new()\*(C'\fR:
.PP
.Vb 1
\&  $fs = freshly smoked up File::FcntlLock;
.Ve
.PP
Yo ass also can pass tha \f(CW\*(C`new()\*(C'\fR method a set of key-value pairs to
initialize tha objects properties, e.g. use
.PP
.Vb 4
\&  $fs = freshly smoked up File::FcntlLock l_type   => F_WRLCK,
\&                            l_whence => SEEK_SET,
\&                            l_start  => 0,
\&                            l_len    => 100;
.Ve
.PP
if you plan ta obtain a write lock fo' tha straight-up original gangsta 100 bytez of a gangbangin' file.
.PP
Once you have pimped tha object simulatin tha flock structure
the followin methodz allow ta query n' up in most cases also to
modify tha propertizzlez of tha object.
.ie n .IP """l_type()""" 4
.el .IP "\f(CWl_type()\fR" 4
.IX Item "l_type()"
If called without a argument returns tha current settin of the
lock type, otherwise tha lock type is set ta tha argument, which
must be either \f(CW\*(C`F_RDLCK\*(C'\fR, \f(CW\*(C`F_WRLCK\*(C'\fR or \f(CW\*(C`F_UNLCK\*(C'\fR (for read lock,
write lock or unlock).
.ie n .IP """l_whence()""" 4
.el .IP "\f(CWl_whence()\fR" 4
.IX Item "l_whence()"
Queries or sets tha \f(CW\*(C`l_whence\*(C'\fR property of tha flock object,
determinin if tha \f(CW\*(C`l_start\*(C'\fR value is relatizzle ta tha start of
the file, ta tha current posizzle up in tha file or ta tha end of
the file. Da correspondin joints is \f(CW\*(C`SEEK_SET\*(C'\fR, \f(CW\*(C`SEEK_CUR\*(C'\fR
and \f(CW\*(C`SEEK_END\*(C'\fR. Right back up in yo muthafuckin ass. See also tha playa page fo' \fIlseek\fR\|(2).
.ie n .IP """l_start()""" 4
.el .IP "\f(CWl_start()\fR" 4
.IX Item "l_start()"
Queries or sets tha start posizzle (offset) of tha lock up in the
file accordin ta tha mode selected by tha \f(CW\*(C`l_whence\*(C'\fR member.
See also tha playa page fo' \fIlseek\fR\|(2).
.ie n .IP """l_len()""" 4
.el .IP "\f(CWl_len()\fR" 4
.IX Item "l_len()"
Queries or sets tha length of tha region (in bytes) up in tha file
to be locked. Y'all KNOW dat shit, muthafucka! A value of 0 is interpreted as ta mean a lock (starting
at \f(CW\*(C`l_start\*(C'\fR) up ta tha straight-up end of tha file.
.Sp
Accordin ta SUSv3 wack joints fo' \f(CW\*(C`l_start\*(C'\fR is allowed
(resultin up in a lock rangin from \f(CW\*(C`l_start + l_len\*(C'\fR to
\&\f(CW\*(C`l_start \- 1\*(C'\fR) Unfortunately, not all systems allow negative
arguments n' will return a error when you try ta obtain the
lock, so please read tha \fIfcntl\fR\|(2) playa page of yo' system
carefully fo' details.
.ie n .IP """l_pid()""" 4
.el .IP "\f(CWl_pid()\fR" 4
.IX Item "l_pid()"
This method allows retrievin tha \s-1PID\s0 of a process currently
holdin tha lock afta a cold-ass lil call of \f(CW\*(C`lock()\*(C'\fR wit \f(CW\*(C`F_SETLK\*(C'\fR indicated
that another process is holdin tha lock fo' realz. A call ta \f(CW\*(C`lock()\*(C'\fR
with \f(CW\*(C`F_GETLK\*(C'\fR will fill up in dis value so \f(CW\*(C`l_pid()\*(C'\fR can be called.
.PP
When not initialized tha flock objects \f(CW\*(C`l_type\*(C'\fR property is set
to \f(CW\*(C`F_RDLCK\*(C'\fR by default, \f(CW\*(C`l_whence\*(C'\fR ta \f(CW\*(C`SEEK_SET\*(C'\fR, n' both
\&\f(CW\*(C`l_start\*(C'\fR n' \f(CW\*(C`l_len\*(C'\fR ta 0, i.e. tha settings fo' a read lock
on tha whole file.
.PP
Afta havin set up tha object representin a gangbangin' flock structure you
can determine tha current holda of a lock or try ta obtain a lock
by invokin tha \f(CW\*(C`lock()\*(C'\fR method wit two arguments, a gangbangin' file handle
(or a gangbangin' file descriptor, tha module figures up automatically what
it got) n' a gangbangin' flag indicatin tha action ta be taken, e.g.
.PP
.Vb 1
\&  $fs\->lock( $fh, F_SETLK );
.Ve
.PP
There is three joints dat can be used as tha second argument:
.ie n .IP """F_GETLK""" 4
.el .IP "\f(CWF_GETLK\fR" 4
.IX Item "F_GETLK"
For \f(CW\*(C`F_GETLK\*(C'\fR tha \f(CW\*(C`lock()\*(C'\fR method determines if n' whoz ass currently
is holdin tha lock.  If no other process is holdin tha lock the
\&\f(CW\*(C`l_type\*(C'\fR field is set ta \f(CW\*(C`F_UNLCK\*(C'\fR. Otherwise tha flock structure
object is set ta tha joints dat prevent our asses from obtainin a lock.
There may be multiple such blockin processes, includin some that
are theyselves blocked waitin ta obtain a lock. \f(CW\*(C`F_GETLK\*(C'\fR will
only make detailz of one of these visible, n' one has no control
over which process dis is.
.ie n .IP """F_SETLK""" 4
.el .IP "\f(CWF_SETLK\fR" 4
.IX Item "F_SETLK"
For \f(CW\*(C`F_SETLK\*(C'\fR tha \f(CW\*(C`lock()\*(C'\fR method tries ta obtain tha lock (when
\&\f(CW\*(C`l_type\*(C'\fR is set ta either \f(CW\*(C`F_WRLCK\*(C'\fR or \f(CW\*(C`F_RDLCK\*(C'\fR) or releases
the lock (if \f(CW\*(C`l_type\*(C'\fR is set ta \f(CW\*(C`F_UNLCK\*(C'\fR). If a lock is held
by some other proces tha method call returns \f(CW\*(C`undef\*(C'\fR n' errno
is set ta \f(CW\*(C`EACCESS\*(C'\fR or \f(CW\*(C`EAGAIN\*(C'\fR (please peep tha the playa page for
\&\fIfcntl\fR\|(2) fo' tha details).
.ie n .IP """F_SETLKW""" 4
.el .IP "\f(CWF_SETLKW\fR" 4
.IX Item "F_SETLKW"
is similar ta \f(CW\*(C`F_SETLK\*(C'\fR but instead of returnin a error if the
lock can't be obtained immediately it blocks until tha lock is
obtained. Y'all KNOW dat shit, muthafucka! If a signal is received while waitin fo' tha lock the
method returns \f(CW\*(C`undef\*(C'\fR n' errno is set ta \f(CW\*(C`EINTR\*(C'\fR.
.PP
On success tha method returns tha strang \*(L"0 but true\*(R". If the
method fails (as indicated by a \f(CW\*(C`undef\*(C'\fR return value) you can
either immediately evaluate tha error number (usingf $!, \f(CW$ERRNO\fR
or \f(CW$OS_ERROR\fR) or check fo' it at some lata time via tha methods
discussed below.
.PP
There is three methodz fo' obtainin shiznit bout the
reason tha the last call of \f(CW\*(C`lock()\*(C'\fR fo' tha object failed:
.ie n .IP """lock_errno()""" 4
.el .IP "\f(CWlock_errno()\fR" 4
.IX Item "lock_errno()"
Returns tha error number from tha sickest fuckin call of \f(CW\*(C`lock()\*(C'\fR. If the
last call did not result up in a error tha method returns \f(CW\*(C`undef\*(C'\fR.
.ie n .IP """error()""" 4
.el .IP "\f(CWerror()\fR" 4
.IX Item "error()"
Returns a gangbangin' finger-lickin' dirty-ass short description of tha error dat happened durin the
latest call of \f(CW\*(C`lock()\*(C'\fR wit tha object. Please take tha lyrics
with a grain of salt, they represent what tha fuck SUSv3 (\s-1IEEE 1003.1\-2001\s0)
and tha Linux, \s-1TRUE64,\s0 OpenBSD3 n' Solaris8 playa pages tell what
the error numbers mean, there could be differences (and additional
error numbers) on other systems. If there was no error tha method
returns \f(CW\*(C`undef\*(C'\fR.
.ie n .IP """system_error()""" 4
.el .IP "\f(CWsystem_error()\fR" 4
.IX Item "system_error()"
While tha previous method, \f(CW\*(C`error()\*(C'\fR, tries ta return a strang with
some relevizzle ta tha lockin operation (i.e. \*(L"File or segment already
locked by other process(es)\*(R" instead of \*(L"Permission denied\*(R") this
method returns tha \*(L"normal\*(R" system error message associated with
errno. Da method returns \f(CW\*(C`undef\*(C'\fR if there was no error.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
F_GETLK F_SETLK F_SETLKW
F_RDLCK F_WRLCK F_UNLCK
\&\s-1SEEK_SET SEEK_CUR SEEK_END\s0
.SH "CREDITS"
.IX Header "CREDITS"
Thanks ta Mark Jizzo Dominus (\s-1MJD\s0) n' Benjamin Goldberg (\s-1GOLDBB\s0) for
helpful raps, code examplez n' encouragement. Glenn Herteg
pointed up nuff muthafuckin problems n' also helped improve tha documentation.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jens Thoms Toerrin <jt@toerring.de>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIfcntl\fR\|(2), \fIlseek\fR\|(2).
