.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Getopt::Long 3"
.TH Getopt::Long 3 "2013-10-01" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Getopt::Long \- Extended processin of command line options
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  use Getopt::Long;
\&  mah $data   = "file.dat";
\&  mah $length = 24;
\&  mah $verbose;
\&  GetOptions ("length=i" => \e$length,    # numeric
\&              "file=s"   => \e$data,      # string
\&              "verbose"  => \e$verbose)   # flag
\&  or die("Error up in command line arguments\en");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da Getopt::Long module implements a extended getopt function called
\&\fIGetOptions()\fR. Well shiiiit, it parses tha command line from \f(CW@ARGV\fR, recognizing
and removin specified options n' they possible joints.
.PP
This function adheres ta tha \s-1POSIX\s0 syntax fo' command
line options, wit \s-1GNU\s0 extensions. In general, dis means dat options
have long names instead of single letters, n' is introduced wit a
double dash \*(L"\-\-\*(R". Right back up in yo muthafuckin ass. Support fo' bundlin of command line options, as was
the case wit tha mo' traditionizzle single-letta approach, is provided
but not enabled by default.
.SH "Command Line Options, a Introduction"
.IX Header "Command Line Options, a Introduction"
Command line operated programs traditionally take they arguments from
the command line, fo' example filenames or other shiznit dat the
program need ta know. Besides arguments, these programs often take
command line \fIoptions\fR as well. Options is not necessary fo' the
program ta work, hence tha name 'option' yo, but is used ta modify its
default behaviour. Shiiit, dis aint no joke. For example, a program could do its thang on tha fuckin' down-lowly,
but wit a suitable option it could provide verbose shiznit about
what it done did.
.PP
Command line options come up in nuff muthafuckin flavours yo. Historically, they are
preceded by a single dash \f(CW\*(C`\-\*(C'\fR, n' consist of a single letter.
.PP
.Vb 1
\&    \-l \-a \-c
.Ve
.PP
Usually, these single-characta options can be bundled:
.PP
.Vb 1
\&    \-lac
.Ve
.PP
Options can have joints, tha value is placed afta tha option
character n' shit. Right back up in yo muthafuckin ass. Sometimes wit whitespace up in between, sometimes not:
.PP
.Vb 1
\&    \-s 24 \-s24
.Ve
.PP
Cuz of tha straight-up cryptic nature of these options, another steez was
developed dat used long names. Right back up in yo muthafuckin ass. So instead of a cold-ass lil cryptic \f(CW\*(C`\-l\*(C'\fR one
could use tha mo' descriptizzle \f(CW\*(C`\-\-long\*(C'\fR. To distinguish between a
bundle of single-characta options n' a long-ass one, two dashes is used
to precede tha option name. Early implementationz of long options used
a plus \f(CW\*(C`+\*(C'\fR instead. Y'all KNOW dat shit, muthafucka! Also, option joints could be specified either
like
.PP
.Vb 1
\&    \-\-size=24
.Ve
.PP
or
.PP
.Vb 1
\&    \-\-size 24
.Ve
.PP
Da \f(CW\*(C`+\*(C'\fR form is now obsolete n' straight fuckin deprecated.
.SH "Gettin Started wit Getopt::Long"
.IX Header "Gettin Started wit Getopt::Long"
Getopt::Long is tha Perl5 successor of \f(CW\*(C`newgetopt.pl\*(C'\fR. This was the
first Perl module dat provided support fo' handlin tha freshly smoked up steez of
command line options, up in particular long option names, hence tha Perl5
name Getopt::Long. This module also supports single-characta options
and bundling.
.PP
To use Getopt::Long from a Perl program, you must include the
followin line up in yo' Perl program:
.PP
.Vb 1
\&    use Getopt::Long;
.Ve
.PP
This will load tha core of tha Getopt::Long module n' prepare your
program fo' rockin dat shit. Most of tha actual Getopt::Long code is not
loaded until you straight-up call one of its functions.
.PP
In tha default configuration, options names may be abbreviated to
uniqueness, case do not matter, n' a single dash is sufficient,
even fo' long option names fo' realz. Also, options may be placed between
non-option arguments, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See \*(L"Configurin Getopt::Long\*(R" fo' more
details on how tha fuck ta configure Getopt::Long.
.SS "Simple options"
.IX Subsection "Simple options"
Da most simple options is tha ones dat take no joints, n' you can put dat on yo' toast. Their mere
presence on tha command line enablez tha option. I aint talkin' bout chicken n' gravy biatch. Ghettofab examplez are:
.PP
.Vb 1
\&    \-\-all \-\-verbose \-\-quiet \-\-debug
.Ve
.PP
Handlin simple options is straightforward:
.PP
.Vb 3
\&    mah $verbose = \*(Aq\*(Aq;   # option variable wit default value (false)
\&    mah $all = \*(Aq\*(Aq;       # option variable wit default value (false)
\&    GetOptions (\*(Aqverbose\*(Aq => \e$verbose, \*(Aqall\*(Aq => \e$all);
.Ve
.PP
Da call ta \fIGetOptions()\fR parses tha command line arguments dat are
present up in \f(CW@ARGV\fR n' sets tha option variable ta tha value \f(CW1\fR if
the option did occur on tha command line. Otherwise, tha option
variable aint touched. Y'all KNOW dat shit, muthafucka! Settin tha option value ta legit is often
called \fIenabling\fR tha option.
.PP
Da option name as specified ta tha \fIGetOptions()\fR function is called
the option \fIspecification\fR. Lata we'll peep dat dis justification
can contain mo' than just tha option name. Da reference ta the
variable is called tha option \fIdestination\fR.
.PP
\&\fIGetOptions()\fR will return a legit value if tha command line could be
processed successfully. Otherwise, it will write error lyrics using
\&\fIdie()\fR n' \fIwarn()\fR, n' return a gangbangin' false result.
.SS "A lil bit less simple options"
.IX Subsection "A lil bit less simple options"
Getopt::Long supports two useful variantz of simple options:
\&\fInegatable\fR options n' \fIincremental\fR options.
.PP
A negatable option is specified wit a exclamation mark \f(CW\*(C`!\*(C'\fR afta the
option name:
.PP
.Vb 2
\&    mah $verbose = \*(Aq\*(Aq;   # option variable wit default value (false)
\&    GetOptions (\*(Aqverbose!\*(Aq => \e$verbose);
.Ve
.PP
Now, rockin \f(CW\*(C`\-\-verbose\*(C'\fR on tha command line will enable \f(CW$verbose\fR,
as expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. But it be also allowed ta use \f(CW\*(C`\-\-noverbose\*(C'\fR, which will
disable \f(CW$verbose\fR by settin its value ta \f(CW0\fR. Usin a suitable
default value, tha program can smoke up whether \f(CW$verbose\fR is false
by default, or disabled by rockin \f(CW\*(C`\-\-noverbose\*(C'\fR.
.PP
An incremenstrual option is specified wit a plus \f(CW\*(C`+\*(C'\fR afta the
option name:
.PP
.Vb 2
\&    mah $verbose = \*(Aq\*(Aq;   # option variable wit default value (false)
\&    GetOptions (\*(Aqverbose+\*(Aq => \e$verbose);
.Ve
.PP
Usin \f(CW\*(C`\-\-verbose\*(C'\fR on tha command line will increment tha value of
\&\f(CW$verbose\fR. This way tha program can keep track of how tha fuck nuff times the
option occurred on tha command line. For example, each occurrence of
\&\f(CW\*(C`\-\-verbose\*(C'\fR could increase tha verbositizzle level of tha program.
.SS "Mixin command line option wit other arguments"
.IX Subsection "Mixin command line option wit other arguments"
Usually programs take command line options as well as other arguments,
for example, file names. Well shiiiit, it is phat practice ta always specify the
options first, n' tha other arguments last. Getopt::Long will,
however, allow tha options n' arguments ta be mixed n' 'filta out'
all tha options before passin tha rest of tha arguments ta the
program. To stop Getopt::Long from processin further arguments,
insert a thugged-out double dash \f(CW\*(C`\-\-\*(C'\fR on tha command line:
.PP
.Vb 1
\&    \-\-size 24 \-\- \-\-all
.Ve
.PP
In dis example, \f(CW\*(C`\-\-all\*(C'\fR will \fInot\fR be treated as a option yo, but
passed ta tha program unharmed, up in \f(CW@ARGV\fR.
.SS "Options wit joints"
.IX Subsection "Options wit joints"
For options dat take joints it must be specified whether tha option
value is required or not, n' what tha fuck kind of value tha option expects.
.PP
Three kindz of joints is supported: integer numbers, floatin point
numbers, n' strings.
.PP
If tha option value is required, Getopt::Long will take the
command line argument dat bigs up tha option n' assign dis ta the
option variable. If, however, tha option value is specified as
optional, dis will only be done if dat value do not be lookin like a
valid command line option itself.
.PP
.Vb 2
\&    mah $tag = \*(Aq\*(Aq;       # option variable wit default value
\&    GetOptions (\*(Aqtag=s\*(Aq => \e$tag);
.Ve
.PP
In tha option justification, tha option name is followed by a equals
sign \f(CW\*(C`=\*(C'\fR n' tha letta \f(CW\*(C`s\*(C'\fR. Da equals sign indicates dat this
option requires a value. Da letta \f(CW\*(C`s\*(C'\fR indicates dat dis value is
an arbitrary string. Other possible value types is \f(CW\*(C`i\*(C'\fR fo' integer
values, n' \f(CW\*(C`f\*(C'\fR fo' floatin point joints, n' you can put dat on yo' toast. Usin a cold-ass lil colon \f(CW\*(C`:\*(C'\fR instead
of tha equals sign indicates dat tha option value is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. In
this case, if no suitable value is supplied, strang valued options get
an empty strang \f(CW\*(Aq\*(Aq\fR assigned, while numeric options is set ta \f(CW0\fR.
.SS "Options wit multiple joints"
.IX Subsection "Options wit multiple joints"
Options sometimes take nuff muthafuckin joints, n' you can put dat on yo' toast. For example, a program could
use multiple directories ta search fo' library files:
.PP
.Vb 1
\&    \-\-library lib/stdlib \-\-library lib/extlib
.Ve
.PP
To accomplish dis behaviour, simply specify a array reference as the
destination fo' tha option:
.PP
.Vb 1
\&    GetOptions ("library=s" => \e@libfiles);
.Ve
.PP
Alternatively, you can specify dat tha option can have multiple
values by addin a \*(L"@\*(R", n' pass a scalar reference as the
destination:
.PP
.Vb 1
\&    GetOptions ("library=s@" => \e$libfiles);
.Ve
.PP
Used wit tha example above, \f(CW@libfiles\fR (or \f(CW@$libfiles\fR) would
contain two strings upon completion: \f(CW"lib/stdlib"\fR and
\&\f(CW"lib/extlib"\fR, up in dat order n' shit. Well shiiiit, it be also possible ta specify that
only integer or floatin point numbers is aaight joints.
.PP
Often it is useful ta allow comma-separated listz of joints as well as
multiple occurrencez of tha options. This is easy as fuck  rockin Perlz \fIsplit()\fR
and \fIjoin()\fR operators:
.PP
.Vb 2
\&    GetOptions ("library=s" => \e@libfiles);
\&    @libfilez = split(/,/,join(\*(Aq,\*(Aq,@libfiles));
.Ve
.PP
Of course, it is blingin ta chizzle tha right separator strang for
each purpose.
.PP
Warning: What bigs up be a experimenstrual feature.
.PP
Options can take multiple joints at once, fo' example
.PP
.Vb 1
\&    \-\-coordinates 52.2 16.4 \-\-rgbcolor 255 255 149
.Ve
.PP
This can be accomplished by addin a repeat specifier ta tha option
specification. I aint talkin' bout chicken n' gravy biatch. Repeat specifiers is straight-up similar ta tha \f(CW\*(C`{...}\*(C'\fR
repeat specifiers dat can be used wit regular expression patterns.
For example, tha above command line would be handled as bigs up:
.PP
.Vb 1
\&    GetOptions(\*(Aqcoordinates=f{2}\*(Aq => \e@coor, \*(Aqrgbcolor=i{3}\*(Aq => \e@color);
.Ve
.PP
Da destination fo' tha option must be a array or array reference.
.PP
It be also possible ta specify tha minimal n' maximal number of
arguments a option takes. \f(CW\*(C`foo=s{2,4}\*(C'\fR indicates a option that
takes at least two n' at most 4 arguments, n' you can put dat on yo' toast. \f(CW\*(C`foo=s{1,}\*(C'\fR indicates one
or mo' joints; \f(CW\*(C`foo:s{,}\*(C'\fR indicates zero or mo' option joints.
.SS "Options wit hash joints"
.IX Subsection "Options wit hash joints"
If tha option destination be a reference ta a hash, tha option will
take, as value, stringz of tha form \fIkey\fR\f(CW\*(C`=\*(C'\fR\fIvalue\fR. Da value will
be stored wit tha specified key up in tha hash.
.PP
.Vb 1
\&    GetOptions ("define=s" => \e%defines);
.Ve
.PP
Alternatively you can use:
.PP
.Vb 1
\&    GetOptions ("define=s%" => \e$defines);
.Ve
.PP
When used wit command line options:
.PP
.Vb 1
\&    \-\-define os=linux \-\-define vendor=redhat
.Ve
.PP
the hash \f(CW%defines\fR (or \f(CW%$defines\fR) will contain two keys, \f(CW"os"\fR
with value \f(CW"linux"\fR n' \f(CW"vendor"\fR wit value \f(CW"redhat"\fR. Well shiiiit, it is
also possible ta specify dat only integer or floatin point numbers
are aaight joints, n' you can put dat on yo' toast. Da keys is always taken ta be strings.
.SS "User-defined subroutines ta handle options"
.IX Subsection "User-defined subroutines ta handle options"
Illest control over what tha fuck should be done when (actually: each time)
an option is encountered on tha command line can be  bigged up  by
designatin a reference ta a subroutine (or a anonymous subroutine)
as tha option destination. I aint talkin' bout chicken n' gravy biatch. When \fIGetOptions()\fR encountas tha option, it
will call tha subroutine wit two or three arguments, n' you can put dat on yo' toast. Da first
argument is tha name of tha option. I aint talkin' bout chicken n' gravy biatch. (Actually, it be a object that
stringifies ta tha name of tha option.) For a scalar or array destination,
the second argument is tha value ta be stored. Y'all KNOW dat shit, muthafucka! For a hash destination,
the second argument is tha key ta tha hash, n' tha third argument
the value ta be stored. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is up ta tha subroutine ta store tha value,
or do whatever it be thinkin be appropriate.
.PP
A trivial application of dis mechanizzle is ta implement options that
are related ta each other n' shit. For example:
.PP
.Vb 3
\&    mah $verbose = \*(Aq\*(Aq;   # option variable wit default value (false)
\&    GetOptions (\*(Aqverbose\*(Aq => \e$verbose,
\&                \*(Aqquiet\*(Aq   => sub { $verbose = 0 });
.Ve
.PP
Here \f(CW\*(C`\-\-verbose\*(C'\fR n' \f(CW\*(C`\-\-quiet\*(C'\fR control tha same variable
\&\f(CW$verbose\fR yo, but wit opposite joints.
.PP
If tha subroutine need ta signal a error, it should call \fIdie()\fR with
the desired error message as its argument. \fIGetOptions()\fR will catch the
\&\fIdie()\fR, issue tha error message, n' record dat a error result must
be returned upon completion.
.PP
If tha text of tha error message starts wit a exclamation mark \f(CW\*(C`!\*(C'\fR
it is interpreted specially by \fIGetOptions()\fR. There is currently one
special command implemented: \f(CW\*(C`die("!FINISH")\*(C'\fR will cause \fIGetOptions()\fR
to stop processin options, as if it encountered a thugged-out double dash \f(CW\*(C`\-\-\*(C'\fR.
.PP
In version 2.37 tha straight-up original gangsta argument ta tha callback function was
changed from strang ta object. This was done ta make room for
extensions n' mo' detailed control. Da object stringifies ta the
option name so dis chizzle should not introduce compatibility
problems.
.PP
Here be a example of how tha fuck ta access tha option name n' value from within
a subroutine:
.PP
.Vb 5
\&    GetOptions (\*(Aqopt=i\*(Aq => \e&handlez);
\&    sub handlez {
\&        mah ($opt_name, $opt_value) = @_;
\&        print("Option name is $opt_name n' value is $opt_value\en");
\&    }
.Ve
.SS "Options wit multiple names"
.IX Subsection "Options wit multiple names"
Often it is user thugged-out ta supply alternate mnemonic names for
options. For example \f(CW\*(C`\-\-height\*(C'\fR could be a alternate name for
\&\f(CW\*(C`\-\-length\*(C'\fR fo' realz. Alternate names can be included up in tha option
specification, separated by vertical bar \f(CW\*(C`|\*(C'\fR characters. To implement
the above example:
.PP
.Vb 1
\&    GetOptions (\*(Aqlength|height=f\*(Aq => \e$length);
.Ve
.PP
Da first name is called tha \fIprimary\fR name, tha other names are
called \fIaliases\fR. When rockin a hash ta store options, tha key will
always be tha primary name.
.PP
Multiple alternate names is possible.
.SS "Case n' abbreviations"
.IX Subsection "Case n' abbreviations"
Without additionizzle configuration, \fIGetOptions()\fR will ignore tha case of
option names, n' allow tha options ta be abbreviated ta uniqueness.
.PP
.Vb 1
\&    GetOptions (\*(Aqlength|height=f\*(Aq => \e$length, "head" => \e$head);
.Ve
.PP
This call will allow \f(CW\*(C`\-\-l\*(C'\fR n' \f(CW\*(C`\-\-L\*(C'\fR fo' tha length option yo, but
requires a least \f(CW\*(C`\-\-hea\*(C'\fR n' \f(CW\*(C`\-\-hei\*(C'\fR fo' tha head n' height options.
.SS "Summary of Option Justifications"
.IX Subsection "Summary of Option Justifications"
Each option specifier consistz of two parts: tha name justification
and tha argument justification.
.PP
Da name justification gotz nuff tha name of tha option, optionally
followed by a list of alternatizzle names separated by vertical bar
characters.
.PP
.Vb 2
\&    length            option name is "length"
\&    length|size|l     name is "length", aliases is "size" n' "l"
.Ve
.PP
Da argument justification is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If omitted, tha option is
considered boolean, a value of 1 is ghon be assigned when tha option is
used on tha command line.
.PP
Da argument justification can be
.IP "!" 4
Da option do not take a argument n' may be negated by prefixing
it wit \*(L"no\*(R" or \*(L"no\-\*(R". E.g. \f(CW"foo!"\fR will allow \f(CW\*(C`\-\-foo\*(C'\fR (a value of
1 is ghon be assigned) as well as \f(CW\*(C`\-\-nofoo\*(C'\fR n' \f(CW\*(C`\-\-no\-foo\*(C'\fR (a value of
0 is ghon be assigned). If tha option has aliases, dis applies ta the
aliases as well.
.Sp
Usin negation on a single letta option when bundlin is up in effect is
pointless n' will result up in a warning.
.IP "+" 4
Da option do not take a argument n' is ghon be incremented by 1
every time it appears on tha command line. E.g. \f(CW"more+"\fR, when used
with \f(CW\*(C`\-\-more \-\-more \-\-more\*(C'\fR, will increment tha value three times,
resultin up in a value of 3 (provided dat shiznit was 0 or undefined at first).
.Sp
Da \f(CW\*(C`+\*(C'\fR specifier is ignored if tha option destination aint a scalar.
.IP "= \fItype\fR [ \fIdesttype\fR ] [ \fIrepeat\fR ]" 4
.IX Item "= type [ desttype ] [ repeat ]"
Da option requires a argument of tha given type. Right back up in yo muthafuckin ass. Supported types
are:
.RS 4
.IP "s" 4
.IX Item "s"
Strin fo' realz. An arbitrary sequence of characters. Well shiiiit, it is valid fo' the
argument ta start wit \f(CW\*(C`\-\*(C'\fR or \f(CW\*(C`\-\-\*(C'\fR.
.IP "i" 4
.IX Item "i"
Integer n' shiznit fo' realz. An optionizzle leadin plus or minus sign, followed by a
sequence of digits.
.IP "o" 4
.IX Item "o"
Extended integer, Perl style. This can be either a optionizzle leading
plus or minus sign, followed by a sequence of digits, or a octal
strin (a zero, optionally followed by '0', '1', .. '7'), or a
hexadecimal strang (\f(CW\*(C`0x\*(C'\fR followed by '0' .. '9', 'a' .. 'f', case
insensitive), or a funky-ass binary strang (\f(CW\*(C`0b\*(C'\fR followed by a seriez of '0'
and '1').
.IP "f" 4
.IX Item "f"
Real number n' shit. For example \f(CW3.14\fR, \f(CW\*(C`\-6.23E24\*(C'\fR n' so on.
.RE
.RS 4
.Sp
Da \fIdesttype\fR can be \f(CW\*(C`@\*(C'\fR or \f(CW\*(C`%\*(C'\fR ta specify dat tha option is
list or a hash valued. Y'all KNOW dat shit, muthafucka! This is only needed when tha destination for
the option value aint otherwise specified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it should be omitted when
not needed.
.Sp
Da \fIrepeat\fR specifies tha number of joints dis option takes per
occurrence on tha command line. Well shiiiit, it has tha format \f(CW\*(C`{\*(C'\fR [ \fImin\fR ] [ \f(CW\*(C`,\*(C'\fR [ \fImax\fR ] ] \f(CW\*(C`}\*(C'\fR.
.Sp
\&\fImin\fR denotes tha minimal number of arguments, n' you can put dat on yo' toast. Well shiiiit, it defaults ta 1 for
options wit \f(CW\*(C`=\*(C'\fR n' ta 0 fo' options wit \f(CW\*(C`:\*(C'\fR, peep below. Note that
\&\fImin\fR overrulez tha \f(CW\*(C`=\*(C'\fR / \f(CW\*(C`:\*(C'\fR semantics.
.Sp
\&\fImax\fR denotes tha maximum number of arguments, n' you can put dat on yo' toast. Well shiiiit, it must be at least
\&\fImin\fR. If \fImax\fR is omitted, \fIbut tha comma is not\fR, there is no
upper bound ta tha number of argument joints taken.
.RE
.IP ": \fItype\fR [ \fIdesttype\fR ]" 4
.IX Item ": type [ desttype ]"
Like \f(CW\*(C`=\*(C'\fR yo, but designates tha argument as optional.
If omitted, a empty strang is ghon be assigned ta strang joints options,
and tha value zero ta numeric options.
.Sp
Note dat if a strang argument starts wit \f(CW\*(C`\-\*(C'\fR or \f(CW\*(C`\-\-\*(C'\fR, it will be
considered a option on itself.
.IP ": \fInumber\fR [ \fIdesttype\fR ]" 4
.IX Item ": number [ desttype ]"
Like \f(CW\*(C`:i\*(C'\fR yo, but if tha value is omitted, tha \fInumber\fR is ghon be assigned.
.IP ": + [ \fIdesttype\fR ]" 4
.IX Item ": + [ desttype ]"
Like \f(CW\*(C`:i\*(C'\fR yo, but if tha value is omitted, tha current value fo' the
option is ghon be incremented.
.SH "Advanced Possibilities"
.IX Header "Advanced Possibilities"
.SS "Object oriented intercourse"
.IX Subsection "Object oriented intercourse"
Getopt::Long can be used up in a object oriented way as well:
.PP
.Vb 5
\&    use Getopt::Long;
\&    $p = Getopt::Long::Parser\->new;
\&    $p\->configure(...configuration options...);
\&    if ($p\->getoptions(...options descriptions...)) ...
\&    if ($p\->getoptionsfromarray( \e@array, ...options descriptions...)) ...
.Ve
.PP
Configuration options can be passed ta tha constructor:
.PP
.Vb 2
\&    $p = freshly smoked up Getopt::Long::Parser
\&             config => [...configuration options...];
.Ve
.SS "Thread Safety"
.IX Subsection "Thread Safety"
Getopt::Long is thread safe when rockin ithreadz az of Perl 5.8.  It is
\&\fInot\fR thread safe when rockin tha olda (experimenstrual n' now
obsolete) threadz implementation dat was added ta Perl 5.005.
.SS "Documentation n' help texts"
.IX Subsection "Documentation n' help texts"
Getopt::Long encourages tha use of Pod::Usage ta produce help
lyrics. For example:
.PP
.Vb 2
\&    use Getopt::Long;
\&    use Pod::Usage;
\&
\&    mah $man = 0;
\&    mah $help = 0;
\&
\&    GetOptions(\*(Aqhelp|?\*(Aq => \e$help, playa => \e$man) or pod2usage(2);
\&    pod2usage(1) if $help;
\&    pod2usage(\-exitval => 0, \-verbose => 2) if $man;
\&
\&    _\|_END_\|_
\&
\&    =head1 NAME
\&
\&    sample \- Usin Getopt::Long n' Pod::Usage
\&
\&    =head1 SYNOPSIS
\&
\&    sample [options] [file ...]
\&
\&     Options:
\&       \-help            brief help message
\&       \-man             full documentation
\&
\&    =head1 OPTIONS
\&
\&    =over 8
\&
\&    =item B<\-help>
\&
\&    Print a funky-ass brief help message n' exits.
\&
\&    =item B<\-man>
\&
\&    Prints tha manual page n' exits.
\&
\&    =back
\&
\&    =head1 DESCRIPTION
\&
\&    B<This program> will read tha given input file(s) n' do something
\&    useful wit tha contents thereof.
\&
\&    =cut
.Ve
.PP
See Pod::Usage fo' details.
.SS "Parsin options from a arbitrary array"
.IX Subsection "Parsin options from a arbitrary array"
By default, GetOptions parses tha options dat is present up in the
global array \f(CW@ARGV\fR fo' realz. A special entry \f(CW\*(C`GetOptionsFromArray\*(C'\fR can be
used ta parse options from a arbitrary array.
.PP
.Vb 2
\&    use Getopt::Long qw(GetOptionsFromArray);
\&    $ret = GetOptionsFromArray(\e@myopts, ...);
.Ve
.PP
When used like this, options n' they possible joints is removed
from \f(CW@myopts\fR, tha global \f(CW@ARGV\fR aint touched at all.
.PP
Da followin two calls behave identically:
.PP
.Vb 2
\&    $ret = GetOptions( ... );
\&    $ret = GetOptionsFromArray(\e@ARGV, ... );
.Ve
.PP
This also means dat a gangbangin' first argument hash reference now becomes the
second argument:
.PP
.Vb 2
\&    $ret = GetOptions(\e%opts, ... );
\&    $ret = GetOptionsFromArray(\e@ARGV, \e%opts, ... );
.Ve
.SS "Parsin options from a arbitrary string"
.IX Subsection "Parsin options from a arbitrary string"
A special entry \f(CW\*(C`GetOptionsFromString\*(C'\fR can be used ta parse options
from a arbitrary string.
.PP
.Vb 2
\&    use Getopt::Long qw(GetOptionsFromString);
\&    $ret = GetOptionsFromString($string, ...);
.Ve
.PP
Da contentz of tha strang is split tha fuck into arguments rockin a cold-ass lil call to
\&\f(CW\*(C`Text::ParseWords::shellwords\*(C'\fR fo' realz. As wit \f(CW\*(C`GetOptionsFromArray\*(C'\fR, the
global \f(CW@ARGV\fR aint touched.
.PP
It be possible that, upon completion, not all arguments up in tha string
have been processed. Y'all KNOW dat shit, muthafucka! \f(CW\*(C`GetOptionsFromString\*(C'\fR will, when called up in list
context, return both tha return status n' a array reference ta any
remainin arguments:
.PP
.Vb 1
\&    ($ret, $args) = GetOptionsFromString($string, ... );
.Ve
.PP
If any arguments remain, n' \f(CW\*(C`GetOptionsFromString\*(C'\fR was not called in
list context, a message is ghon be given n' \f(CW\*(C`GetOptionsFromString\*(C'\fR will
return failure.
.PP
As wit GetOptionsFromArray, a gangbangin' first argument hash reference now
becomes tha second argument.
.SS "Storin options joints up in a hash"
.IX Subsection "Storin options joints up in a hash"
Sometimes, fo' example when there be a shitload of options, havin a
separate variable fo' each of dem can be cumbersome. \fIGetOptions()\fR
supports, as a alternatizzle mechanism, storin options joints up in a
hash.
.PP
To obtain this, a reference ta a hash must be passed \fIas tha first
argument\fR ta \fIGetOptions()\fR. For each option dat is specified on the
command line, tha option value is ghon be stored up in tha hash wit the
option name as key. Options dat is not straight-up used on tha command
line aint gonna be put up in tha hash, on other lyrics,
\&\f(CW\*(C`exists($h{option})\*(C'\fR (or \fIdefined()\fR) can be used ta test if a option
was used. Y'all KNOW dat shit, muthafucka! Da drawback is dat warnings is ghon be issued if tha program
runs under \f(CW\*(C`use strict\*(C'\fR n' uses \f(CW$h{option}\fR without testin with
\&\fIexists()\fR or \fIdefined()\fR first.
.PP
.Vb 2
\&    mah %h = ();
\&    GetOptions (\e%h, \*(Aqlength=i\*(Aq);       # will store up in $h{length}
.Ve
.PP
For options dat take list or hash joints, it is necessary ta indicate
this by appendin a \f(CW\*(C`@\*(C'\fR or \f(CW\*(C`%\*(C'\fR sign afta tha type:
.PP
.Vb 1
\&    GetOptions (\e%h, \*(Aqcolours=s@\*(Aq);     # will push ta @{$h{colours}}
.Ve
.PP
To make thangs mo' fucked up, tha hash may contain references to
the actual destinations, fo' example:
.PP
.Vb 3
\&    mah $len = 0;
\&    mah %h = (\*(Aqlength\*(Aq => \e$len);
\&    GetOptions (\e%h, \*(Aqlength=i\*(Aq);       # will store up in $len
.Ve
.PP
This example is straight-up equivalent with:
.PP
.Vb 2
\&    mah $len = 0;
\&    GetOptions (\*(Aqlength=i\*(Aq => \e$len);   # will store up in $len
.Ve
.PP
Any mixture is possible. For example, da most thugged-out frequently used options
could be stored up in variablez while all other options git stored up in the
hash:
.PP
.Vb 6
\&    mah $verbose = 0;                    # frequently referred
\&    mah $debug = 0;                      # frequently referred
\&    mah %h = (\*(Aqverbose\*(Aq => \e$verbose, \*(Aqdebug\*(Aq => \e$debug);
\&    GetOptions (\e%h, \*(Aqverbose\*(Aq, \*(Aqdebug\*(Aq, \*(Aqfilter\*(Aq, \*(Aqsize=i\*(Aq);
\&    if ( $verbose ) { ... }
\&    if ( exists $h{filter} ) { ... option \*(Aqfilter\*(Aq was specified ... }
.Ve
.SS "Bundling"
.IX Subsection "Bundling"
With bundlin it is possible ta set nuff muthafuckin single-characta options
at once. For example if \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`v\*(C'\fR n' \f(CW\*(C`x\*(C'\fR is all valid options,
.PP
.Vb 1
\&    \-vax
.Ve
.PP
would set all three.
.PP
Getopt::Long supports two levelz of bundling. To enable bundling, a
call ta Getopt::Long::Configure is required.
.PP
Da first level of bundlin can be enabled with:
.PP
.Vb 1
\&    Getopt::Long::Configure ("bundling");
.Ve
.PP
Configured dis way, single-characta options can be bundled but long
options \fBmust\fR always start wit a thugged-out double dash \f(CW\*(C`\-\-\*(C'\fR ta avoid
ambiguity. For example, when \f(CW\*(C`vax\*(C'\fR, \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`v\*(C'\fR n' \f(CW\*(C`x\*(C'\fR is all valid
options,
.PP
.Vb 1
\&    \-vax
.Ve
.PP
would set \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`v\*(C'\fR n' \f(CW\*(C`x\*(C'\fR yo, but
.PP
.Vb 1
\&    \-\-vax
.Ve
.PP
would set \f(CW\*(C`vax\*(C'\fR.
.PP
Da second level of bundlin lifts dis restriction. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it can be enabled
with:
.PP
.Vb 1
\&    Getopt::Long::Configure ("bundling_override");
.Ve
.PP
Now, \f(CW\*(C`\-vax\*(C'\fR would set tha option \f(CW\*(C`vax\*(C'\fR.
.PP
When any level of bundlin is enabled, option joints may be inserted
in tha bundle. For example:
.PP
.Vb 1
\&    \-h24w80
.Ve
.PP
is equivalent to
.PP
.Vb 1
\&    \-h 24 \-w 80
.Ve
.PP
When configured fo' bundling, single-characta options is matched
case sensitizzle while long options is matched case insensitive. To
have tha single-characta options matched case insensitizzle as well,
use:
.PP
.Vb 1
\&    Getopt::Long::Configure ("bundling", "ignorecase_always");
.Ve
.PP
It goes without sayin dat bundlin can be like confusing.
.SS "Da lonesome dash"
.IX Subsection "Da lonesome dash"
Normally, a lone dash \f(CW\*(C`\-\*(C'\fR on tha command line aint gonna be considered
an option. I aint talkin' bout chicken n' gravy biatch. Option processin will terminizzle (unless \*(L"permute\*(R" is
configured) n' tha dash is ghon be left up in \f(CW@ARGV\fR.
.PP
It be possible ta git special treatment fo' a lone dash. This can be
 bigged up  by addin a option justification wit a empty name, for
example:
.PP
.Vb 1
\&    GetOptions (\*(Aq\*(Aq => \e$stdio);
.Ve
.PP
A lone dash on tha command line will now be a legal option, n' using
it will set variable \f(CW$stdio\fR.
.SS "Argument callback"
.IX Subsection "Argument callback"
A special option 'name' \f(CW\*(C`<>\*(C'\fR can be used ta designate a subroutine
to handle non-option arguments, n' you can put dat on yo' toast. When \fIGetOptions()\fR encountas an
argument dat do not be lookin like a option, it will immediately call this
subroutine n' passes it one parameter: tha argument name. Well, actually
it be a object dat stringifies ta tha argument name.
.PP
For example:
.PP
.Vb 3
\&    mah $width = 80;
\&    sub process { ... }
\&    GetOptions (\*(Aqwidth=i\*(Aq => \e$width, \*(Aq<>\*(Aq => \e&process);
.Ve
.PP
When applied ta tha followin command line:
.PP
.Vb 1
\&    arg1 \-\-width=72 arg2 \-\-width=60 arg3
.Ve
.PP
This will call
\&\f(CW\*(C`process("arg1")\*(C'\fR while \f(CW$width\fR is \f(CW80\fR,
\&\f(CW\*(C`process("arg2")\*(C'\fR while \f(CW$width\fR is \f(CW72\fR, and
\&\f(CW\*(C`process("arg3")\*(C'\fR while \f(CW$width\fR is \f(CW60\fR.
.PP
This feature requires configuration option \fBpermute\fR, peep section
\&\*(L"Configurin Getopt::Long\*(R".
.SH "Configurin Getopt::Long"
.IX Header "Configurin Getopt::Long"
Getopt::Long can be configured by callin subroutine
\&\fIGetopt::Long::Configure()\fR. This subroutine takes a list of quoted
strings, each specifyin a cold-ass lil configuration option ta be enabled, e.g.
\&\f(CW\*(C`ignore_case\*(C'\fR, or disabled, e.g. \f(CW\*(C`no_ignore_case\*(C'\fR. Case do not
matter n' shit. Multiple calls ta \fIConfigure()\fR is possible.
.PP
Alternatively, az of version 2.24, tha configuration options may be
passed together wit tha \f(CW\*(C`use\*(C'\fR statement:
.PP
.Vb 1
\&    use Getopt::Long qw(:config no_ignore_case bundling);
.Ve
.PP
Da followin options is available:
.IP "default" 12
.IX Item "default"
This option causes all configuration options ta be reset ta their
default joints.
.IP "posix_default" 12
.IX Item "posix_default"
This option causes all configuration options ta be reset ta their
default joints as if tha environment variable \s-1POSIXLY_CORRECT\s0 had
been set.
.IP "auto_abbrev" 12
.IX Item "auto_abbrev"
Allow option names ta be abbreviated ta uniqueness.
Default is enabled unless environment variable
\&\s-1POSIXLY_CORRECT\s0 has been set, up in which case \f(CW\*(C`auto_abbrev\*(C'\fR is disabled.
.IP "getopt_compat" 12
.IX Item "getopt_compat"
Allow \f(CW\*(C`+\*(C'\fR ta start options.
Default is enabled unless environment variable
\&\s-1POSIXLY_CORRECT\s0 has been set, up in which case \f(CW\*(C`getopt_compat\*(C'\fR is disabled.
.IP "gnu_compat" 12
.IX Item "gnu_compat"
\&\f(CW\*(C`gnu_compat\*(C'\fR controls whether \f(CW\*(C`\-\-opt=\*(C'\fR be allowed, n' what tha fuck it should
do. Without \f(CW\*(C`gnu_compat\*(C'\fR, \f(CW\*(C`\-\-opt=\*(C'\fR gives a error. Shiiit, dis aint no joke. With \f(CW\*(C`gnu_compat\*(C'\fR,
\&\f(CW\*(C`\-\-opt=\*(C'\fR will give option \f(CW\*(C`opt\*(C'\fR n' empty value.
This is tha way \s-1GNU\s0 \fIgetopt_long()\fR do dat shit.
.IP "gnu_getopt" 12
.IX Item "gnu_getopt"
This be a gangbangin' finger-lickin' dirty-ass short way of settin \f(CW\*(C`gnu_compat\*(C'\fR \f(CW\*(C`bundling\*(C'\fR \f(CW\*(C`permute\*(C'\fR
\&\f(CW\*(C`no_getopt_compat\*(C'\fR. With \f(CW\*(C`gnu_getopt\*(C'\fR, command line handlin should be
fully compatible wit \s-1GNU\s0 \fIgetopt_long()\fR.
.IP "require_order" 12
.IX Item "require_order"
Whether command line arguments is allowed ta be mixed wit options.
Default is disabled unless environment variable
\&\s-1POSIXLY_CORRECT\s0 has been set, up in which case \f(CW\*(C`require_order\*(C'\fR is enabled.
.Sp
See also \f(CW\*(C`permute\*(C'\fR, which is tha opposite of \f(CW\*(C`require_order\*(C'\fR.
.IP "permute" 12
.IX Item "permute"
Whether command line arguments is allowed ta be mixed wit options.
Default is enabled unless environment variable
\&\s-1POSIXLY_CORRECT\s0 has been set, up in which case \f(CW\*(C`permute\*(C'\fR is disabled.
Note dat \f(CW\*(C`permute\*(C'\fR is tha opposite of \f(CW\*(C`require_order\*(C'\fR.
.Sp
If \f(CW\*(C`permute\*(C'\fR is enabled, dis means that
.Sp
.Vb 1
\&    \-\-foo arg1 \-\-bar arg2 arg3
.Ve
.Sp
is equivalent to
.Sp
.Vb 1
\&    \-\-foo \-\-bar arg1 arg2 arg3
.Ve
.Sp
If a argument callback routine is specified, \f(CW@ARGV\fR will always be
empty upon successful return of \fIGetOptions()\fR since all options have been
processed. Y'all KNOW dat shit, muthafucka! Da only exception is when \f(CW\*(C`\-\-\*(C'\fR is used:
.Sp
.Vb 1
\&    \-\-foo arg1 \-\-bar arg2 \-\- arg3
.Ve
.Sp
This will call tha callback routine fo' arg1 n' arg2, n' then
terminizzle \fIGetOptions()\fR leavin \f(CW"arg3"\fR up in \f(CW@ARGV\fR.
.Sp
If \f(CW\*(C`require_order\*(C'\fR is enabled, options processing
terminates when tha straight-up original gangsta non-option is encountered.
.Sp
.Vb 1
\&    \-\-foo arg1 \-\-bar arg2 arg3
.Ve
.Sp
is equivalent to
.Sp
.Vb 1
\&    \-\-foo \-\- arg1 \-\-bar arg2 arg3
.Ve
.Sp
If \f(CW\*(C`pass_through\*(C'\fR be also enabled, options processin will terminate
at tha straight-up original gangsta unrecognized option, or non-option, whichever comes
first.
.IP "bundlin (default: disabled)" 12
.IX Item "bundlin (default: disabled)"
Enablin dis option will allow single-characta options ta be
bundled. Y'all KNOW dat shit, muthafucka! To distinguish bundlez from long option names, long options
\&\fImust\fR be introduced wit \f(CW\*(C`\-\-\*(C'\fR n' bundlez wit \f(CW\*(C`\-\*(C'\fR.
.Sp
Note that, if you have options \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`l\*(C'\fR n' \f(CW\*(C`all\*(C'\fR, and
auto_abbrev enabled, possible arguments n' option settings are:
.Sp
.Vb 6
\&    rockin argument               sets option(s)
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    \-a, \-\-a                      a
\&    \-l, \-\-l                      l
\&    \-al, \-la, \-ala, \-all,...     a, l
\&    \-\-al, \-\-all                  all
.Ve
.Sp
Da surprisin part is dat \f(CW\*(C`\-\-a\*(C'\fR sets option \f(CW\*(C`a\*(C'\fR (due ta auto
completion), not \f(CW\*(C`all\*(C'\fR.
.Sp
Note: disablin \f(CW\*(C`bundling\*(C'\fR also disablez \f(CW\*(C`bundling_override\*(C'\fR.
.IP "bundling_override (default: disabled)" 12
.IX Item "bundling_override (default: disabled)"
If \f(CW\*(C`bundling_override\*(C'\fR is enabled, bundlin is enabled as with
\&\f(CW\*(C`bundling\*(C'\fR but now long option names override option bundles.
.Sp
Note: disablin \f(CW\*(C`bundling_override\*(C'\fR also disablez \f(CW\*(C`bundling\*(C'\fR.
.Sp
\&\fBNote:\fR Usin option bundlin can easily lead ta unexpected thangs up in dis biatch,
especially when mixin long options n' bundles. Caveat emptor.
.IP "ignore_case  (default: enabled)" 12
.IX Item "ignore_case (default: enabled)"
If enabled, case is ignored when matchin option names. If, however,
bundlin is enabled as well, single characta options is ghon be treated
case-sensitive.
.Sp
With \f(CW\*(C`ignore_case\*(C'\fR, option justifications fo' options dat only
differ up in case, e.g., \f(CW"foo"\fR n' \f(CW"Foo"\fR, is ghon be flagged as
duplicates.
.Sp
Note: disablin \f(CW\*(C`ignore_case\*(C'\fR also disablez \f(CW\*(C`ignore_case_always\*(C'\fR.
.IP "ignore_case_always (default: disabled)" 12
.IX Item "ignore_case_always (default: disabled)"
When bundlin is up in effect, case is ignored on single-character
options also.
.Sp
Note: disablin \f(CW\*(C`ignore_case_always\*(C'\fR also disablez \f(CW\*(C`ignore_case\*(C'\fR.
.IP "auto_version (default:disabled)" 12
.IX Item "auto_version (default:disabled)"
Automatically provide support fo' tha \fB\-\-version\fR option if
the application did not specify a handlez fo' dis option itself.
.Sp
Getopt::Long will provide a standard version message dat includes the
program name, its version (if \f(CW$main::VERSION\fR is defined), n' the
versionz of Getopt::Long n' Perl. Da message is ghon be freestyled to
standard output n' processin will terminate.
.Sp
\&\f(CW\*(C`auto_version\*(C'\fR is ghon be enabled if tha callin program explicitly
specified a version number higher than 2.32 up in tha \f(CW\*(C`use\*(C'\fR or
\&\f(CW\*(C`require\*(C'\fR statement.
.IP "auto_help (default:disabled)" 12
.IX Item "auto_help (default:disabled)"
Automatically provide support fo' tha \fB\-\-help\fR n' \fB\-?\fR options if
the application did not specify a handlez fo' dis option itself.
.Sp
Getopt::Long will provide a help message rockin module Pod::Usage. The
message, derived from tha \s-1SYNOPSIS POD\s0 section, is ghon be freestyled to
standard output n' processin will terminate.
.Sp
\&\f(CW\*(C`auto_help\*(C'\fR is ghon be enabled if tha callin program explicitly
specified a version number higher than 2.32 up in tha \f(CW\*(C`use\*(C'\fR or
\&\f(CW\*(C`require\*(C'\fR statement.
.IP "pass_all up in (default: disabled)" 12
.IX Item "pass_all up in (default: disabled)"
Options dat is unknown, ambiguous or supplied wit a invalid option
value is passed all up in in \f(CW@ARGV\fR instead of bein flagged as
errors. This make it possible ta write wrapper scripts dat process
only part of tha user supplied command line arguments, n' pass the
remainin options ta some other program.
.Sp
If \f(CW\*(C`require_order\*(C'\fR is enabled, options processin will terminizzle at
the first unrecognized option, or non-option, whichever comes first.
But fuck dat shiznit yo, tha word on tha street is dat if \f(CW\*(C`permute\*(C'\fR is enabled instead, thangs up in dis biatch can become confusing.
.Sp
Note dat tha options terminator (default \f(CW\*(C`\-\-\*(C'\fR), if present, will
also be passed all up in in \f(CW@ARGV\fR.
.IP "prefix" 12
.IX Item "prefix"
Da strang dat starts options. If a cold-ass lil constant strang is not
sufficient, peep \f(CW\*(C`prefix_pattern\*(C'\fR.
.IP "prefix_pattern" 12
.IX Item "prefix_pattern"
A Perl pattern dat identifies tha strings dat introduce options.
Default is \f(CW\*(C`\-\-|\-|\e+\*(C'\fR unless environment variable
\&\s-1POSIXLY_CORRECT\s0 has been set, up in which case it is \f(CW\*(C`\-\-|\-\*(C'\fR.
.IP "long_prefix_pattern" 12
.IX Item "long_prefix_pattern"
A Perl pattern dat allows tha disambiguation of long n' short
prefixes. Default is \f(CW\*(C`\-\-\*(C'\fR.
.Sp
Typically you only need ta set dis if yo ass is rockin nonstandard
prefixes n' want some or all of dem ta have tha same semantics as
\&'\-\-' do under aiiight circumstances.
.Sp
For example, settin prefix_pattern ta \f(CW\*(C`\-\-|\-|\e+|\e/\*(C'\fR and
long_prefix_pattern ta \f(CW\*(C`\-\-|\e/\*(C'\fR would add Win32 steez argument
handling.
.IP "debug (default: disabled)" 12
.IX Item "debug (default: disabled)"
Enable debuggin output.
.SH "Exportable Methods"
.IX Header "Exportable Methods"
.IP "VersionMessage" 4
.IX Item "VersionMessage"
This subroutine serves up a standard version message. Its argument can be:
.RS 4
.IP "\(bu" 4
A strang containin tha text of a message ta print \fIbefore\fR printing
the standard message.
.IP "\(bu" 4
A numeric value correspondin ta tha desired exit status.
.IP "\(bu" 4
A reference ta a hash.
.RE
.RS 4
.Sp
If mo' than one argument is given then tha entire argument list is
assumed ta be a hash.  If a hash is supplied (either as a reference or
as a list) it should contain one or mo' elements wit tha following
keys:
.ie n .IP """\-message""" 4
.el .IP "\f(CW\-message\fR" 4
.IX Item "-message"
.PD 0
.ie n .IP """\-msg""" 4
.el .IP "\f(CW\-msg\fR" 4
.IX Item "-msg"
.PD
Da text of a message ta print immediately prior ta printin the
programz usage message.
.ie n .IP """\-exitval""" 4
.el .IP "\f(CW\-exitval\fR" 4
.IX Item "-exitval"
Da desired exit status ta pass ta tha \fB\f(BIexit()\fB\fR function.
This should be a integer, or else tha strang \*(L"\s-1NOEXIT\*(R"\s0 to
indicate dat control should simply be returned without
terminatin tha invokin process.
.ie n .IP """\-output""" 4
.el .IP "\f(CW\-output\fR" 4
.IX Item "-output"
A reference ta a gangbangin' filehandle, or tha pathname of a gangbangin' file ta which the
usage message should be written. I aint talkin' bout chicken n' gravy biatch. Da default is \f(CW\*(C`\e*STDERR\*(C'\fR unless the
exit value is less than 2 (in which case tha default is \f(CW\*(C`\e*STDOUT\*(C'\fR).
.RE
.RS 4
.Sp
Yo ass cannot tie dis routine directly ta a option, e.g.:
.Sp
.Vb 1
\&    GetOptions("version" => \e&VersionMessage);
.Ve
.Sp
Use dis instead:
.Sp
.Vb 1
\&    GetOptions("version" => sub { VersionMessage() });
.Ve
.RE
.IP "HelpMessage" 4
.IX Item "HelpMessage"
This subroutine produces a standard help message, derived from the
programz \s-1POD\s0 section \s-1SYNOPSIS\s0 rockin Pod::Usage. Well shiiiit, it takes tha same
arguments as \fIVersionMessage()\fR. In particular, you cannot tie it
directly ta a option, e.g.:
.Sp
.Vb 1
\&    GetOptions("help" => \e&HelpMessage);
.Ve
.Sp
Use dis instead:
.Sp
.Vb 1
\&    GetOptions("help" => sub { HelpMessage() });
.Ve
.SH "Return joints n' Errors"
.IX Header "Return joints n' Errors"
Configuration errors n' errors up in tha option definitions are
signalled rockin \fIdie()\fR n' will terminizzle tha callin program unless
the call ta \fIGetopt::Long::GetOptions()\fR was embedded up in \f(CW\*(C`eval { ...
}\*(C'\fR, or \fIdie()\fR was trapped rockin \f(CW$SIG{_\|_DIE_\|_}\fR.
.PP
GetOptions returns legit ta indicate success.
It returns false when tha function detected one or mo' errors during
option parsing. These errors is signalled rockin \fIwarn()\fR n' can be
trapped wit \f(CW$SIG{_\|_WARN_\|_}\fR.
.SH "Legacy"
.IX Header "Legacy"
Da earliest pimpment of \f(CW\*(C`newgetopt.pl\*(C'\fR started up in 1990, wit Perl
version 4 fo' realz. As a result, its pimpment, n' tha pimpment of
Getopt::Long, has gone all up in nuff muthafuckin stages. Right back up in yo muthafuckin ass. Since backward
compatibilitizzle has always been mad blingin, tha current version
of Getopt::Long still supports a shitload of constructs dat nowadays are
no longer necessary or otherwise unwanted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This section raps about
briefly a shitload of these 'features'.
.SS "Default destinations"
.IX Subsection "Default destinations"
When no destination is specified fo' a option, GetOptions will store
the resultant value up in a global variable named \f(CW\*(C`opt_\*(C'\fR\fI\s-1XXX\s0\fR, where
\&\fI\s-1XXX\s0\fR is tha primary name of dis option. I aint talkin' bout chicken n' gravy biatch. When a program executes
under \f(CW\*(C`use strict\*(C'\fR (recommended), these variablez must be
pre-declared wit \fIour()\fR or \f(CW\*(C`use vars\*(C'\fR.
.PP
.Vb 2
\&    our $opt_length = 0;
\&    GetOptions (\*(Aqlength=i\*(Aq);    # will store up in $opt_length
.Ve
.PP
To yield a usable Perl variable, charactas dat is not part of the
syntax fo' variablez is translated ta underscores. For example,
\&\f(CW\*(C`\-\-fpp\-struct\-return\*(C'\fR will set tha variable
\&\f(CW$opt_fpp_struct_return\fR. Note dat dis variable resides up in the
namespace of tha callin program, not necessarily \f(CW\*(C`main\*(C'\fR. For
example:
.PP
.Vb 1
\&    GetOptions ("size=i", "sizes=i@");
.Ve
.PP
with command line \*(L"\-size 10 \-sizes 24 \-sizes 48\*(R" will big-ass up the
equivalent of tha assignments
.PP
.Vb 2
\&    $opt_size = 10;
\&    @opt_sizes = (24, 48);
.Ve
.SS "Alternatizzle option starters"
.IX Subsection "Alternatizzle option starters"
A strang of alternatizzle option starta charactas may be passed as the
first argument (or tha straight-up original gangsta argument afta a leadin hash reference
argument).
.PP
.Vb 2
\&    mah $len = 0;
\&    GetOptions (\*(Aq/\*(Aq, \*(Aqlength=i\*(Aq => $len);
.Ve
.PP
Now tha command line may look like:
.PP
.Vb 1
\&    /length 24 \-\- arg
.Ve
.PP
Note dat ta terminizzle options processin still requires a thugged-out double dash
\&\f(CW\*(C`\-\-\*(C'\fR.
.PP
\&\fIGetOptions()\fR aint gonna interpret a leadin \f(CW"<>"\fR as option starters
if tha next argument be a reference. To force \f(CW"<"\fR n' \f(CW">"\fR as
option starters, use \f(CW"><"\fR. Confusing, biatch? Well, \fBusin a starter
argument is straight fuckin deprecated\fR anyway.
.SS "Configuration variables"
.IX Subsection "Configuration variables"
Previous versionz of Getopt::Long used variablez fo' tha purpose of
configurin fo' realz. Although manipulatin these variablez still work, it is
strongly encouraged ta use tha \f(CW\*(C`Configure\*(C'\fR routine dat was introduced
in version 2.17. Besides, it is much easier.
.SH "Tips n' Techniques"
.IX Header "Tips n' Techniques"
.SS "Pushin multiple joints up in a hash option"
.IX Subsection "Pushin multiple joints up in a hash option"
Sometimes you wanna combine tha dopest of hashes n' arrays. For
example, tha command line:
.PP
.Vb 1
\&  \-\-list add=first \-\-list add=second \-\-list add=third
.Ve
.PP
where each successive 'list add' option will push tha value of add
into array ref \f(CW$list\fR\->{'add'}. Da result would be like
.PP
.Vb 1
\&  $list\->{add} = [qw(first second third)];
.Ve
.PP
This can be accomplished wit a thugged-out destination routine:
.PP
.Vb 2
\&  GetOptions(\*(Aqlist=s%\*(Aq =>
\&               sub { push(@{$list{$_[1]}}, $_[2]) });
.Ve
.SH "Troubleshooting"
.IX Header "Troubleshooting"
.SS "GetOptions do not return a gangbangin' false result when a option aint supplied"
.IX Subsection "GetOptions do not return a gangbangin' false result when a option aint supplied"
Thatz why they called 'options'.
.SS "GetOptions do not split tha command line erectly"
.IX Subsection "GetOptions do not split tha command line erectly"
Da command line aint split by GetOptions yo, but by tha command line
interpreta (\s-1CLI\s0). On Unix, dis is tha shell. On Windows, it is
\&\s-1COMMAND.COM\s0 or \s-1CMD.EXE.\s0 Other operatin systems have other CLIs.
.PP
It be blingin ta know dat these CLIs may behave different when the
command line gotz nuff special characters, up in particular quotes or
backslashes. For example, wit Unix shells you can use single quotes
(\f(CW\*(C`\*(Aq\*(C'\fR) n' double quotes (\f(CW\*(C`"\*(C'\fR) ta crew lyrics together n' shit. Da following
alternatives is equivalent on Unix:
.PP
.Vb 3
\&    "two lyrics"
\&    \*(Aqtwo lyrics\*(Aq
\&    two\e lyrics
.Ve
.PP
In case of doubt, bang tha followin statement up in front of yo' Perl
program:
.PP
.Vb 1
\&    print STDERR (join("|",@ARGV),"\en");
.Ve
.PP
to verify how tha fuck yo' \s-1CLI\s0 passes tha arguments ta tha program.
.SS "Undefined subroutine &main::GetOptions called"
.IX Subsection "Undefined subroutine &main::GetOptions called"
Is you hustlin Windows, n' did you write
.PP
.Vb 1
\&    use GetOpt::Long;
.Ve
.PP
(note tha capital 'O')?
.ie n .SS "How tha fuck do I put a ""\-?"" option tha fuck into a Getopt::Long?"
.el .SS "How tha fuck do I put a ``\-?'' option tha fuck into a Getopt::Long?"
.IX Subsection "How tha fuck do I put a -, biatch? option tha fuck into a Getopt::Long?"
Yo ass can only obtain dis rockin a alias, n' Getopt::Long of at least
version 2.13.
.PP
.Vb 2
\&    use Getopt::Long;
\&    GetOptions ("help|?");    # \-help n' \-, biatch? will both set $opt_help
.Ve
.PP
Other charactas dat can't step tha fuck up in Perl identifiers is also supported
as aliases wit Getopt::Long of at least version 2.39.
.PP
Az of version 2.32 Getopt::Long serves up auto-help, a quick n' easy as fuck  way
to add tha options \-\-help n' \-, biatch? ta yo' program, n' handle em.
.PP
See \f(CW\*(C`auto_help\*(C'\fR up in section \*(L"Configurin Getopt::Long\*(R".
.SH "AUTHOR"
.IX Header "AUTHOR"
Johan Vromans <jvromans@squirrel.nl>
.SH "COPYRIGHT AND DISCLAIMER"
.IX Header "COPYRIGHT AND DISCLAIMER"
This program is Copyright 1990,2013 by Johan Vromans.
This program is free software; you can redistribute it and/or
modify it under tha termz of tha Perl Artistic License or the
\&\s-1GNU\s0 General Public License as published by tha Jacked Software
Foundation; either version 2 of tha License, or (at yo' option) any
lata version.
.PP
This program is distributed up in tha hope dat it is ghon be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even tha implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See the
\&\s-1GNU\s0 General Public License fo' mo' details.
.PP
If you aint gots a cold-ass lil copy of tha \s-1GNU\s0 General Public License write to
the Jacked Software Foundation, Inc., 675 Mass Ave, Cambridge,
\&\s-1MA 02139, USA.\s0
