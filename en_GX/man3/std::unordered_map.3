" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits std::__allow_copy_cons< bool >\&.
.SS "Public Types"

.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "typedef _Hashtable::key_type \fBkey_type\fP"
.br
.ti -1c
.RI "typedef _Hashtable::value_type \fBvalue_type\fP"
.br
.ti -1c
.RI "typedef _Hashtable::mapped_type \fBmapped_type\fP"
.br
.ti -1c
.RI "typedef _Hashtable::hasher \fBhasher\fP"
.br
.ti -1c
.RI "typedef _Hashtable::key_equal \fBkey_equal\fP"
.br
.ti -1c
.RI "typedef _Hashtable::allocator_type \fBallocator_type\fP"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "typedef allocator_type::pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef 
.br
allocator_type::const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef allocator_type::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef 
.br
allocator_type::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef _Hashtable::iterator \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Hashtable::const_iterator \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef _Hashtable::local_iterator \fBlocal_iterator\fP"
.br
.ti -1c
.RI "typedef 
.br
_Hashtable::const_local_iterator \fBconst_local_iterator\fP"
.br
.ti -1c
.RI "typedef _Hashtable::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Hashtable::difference_type \fBdifference_type\fP"
.br
.in -1c
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBunordered_map\fP (\fBsize_type\fP __n=10, const \fBhasher\fP &__hf=\fBhasher\fP(), const \fBkey_equal\fP &__eql=\fBkey_equal\fP(), const \fBallocator_type\fP &__a=\fBallocator_type\fP())"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBunordered_map\fP (_InputIterator __f, _InputIterator __l, \fBsize_type\fP __n=0, const \fBhasher\fP &__hf=\fBhasher\fP(), const \fBkey_equal\fP &__eql=\fBkey_equal\fP(), const \fBallocator_type\fP &__a=\fBallocator_type\fP())"
.br
.ti -1c
.RI "\fBunordered_map\fP (const \fBunordered_map\fP &)=default"
.br
.ti -1c
.RI "\fBunordered_map\fP (\fBunordered_map\fP &&)=default"
.br
.ti -1c
.RI "\fBunordered_map\fP (\fBinitializer_list\fP< \fBvalue_type\fP > __l, \fBsize_type\fP __n=0, const \fBhasher\fP &__hf=\fBhasher\fP(), const \fBkey_equal\fP &__eql=\fBkey_equal\fP(), const \fBallocator_type\fP &__a=\fBallocator_type\fP())"
.br
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBlocal_iterator\fP \fBbegin\fP (\fBsize_type\fP __n)"
.br
.ti -1c
.RI "\fBsize_type\fP \fBbucket\fP (const \fBkey_type\fP &__key) const "
.br
.ti -1c
.RI "\fBsize_type\fP \fBbucket_count\fP () const noexcept"
.br
.ti -1c
.RI "\fBsize_type\fP \fBbucket_size\fP (\fBsize_type\fP __n) const "
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "\fBsize_type\fP \fBcount\fP (const \fBkey_type\fP &__x) const "
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBstd::pair\fP< \fBiterator\fP, bool > \fBemplace\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBiterator\fP \fBemplace_hint\fP (\fBconst_iterator\fP __pos, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP () noexcept"
.br
.ti -1c
.RI "\fBlocal_iterator\fP \fBend\fP (\fBsize_type\fP __n)"
.br
.ti -1c
.RI "\fBsize_type\fP \fBerase\fP (const \fBkey_type\fP &__x)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBconst_iterator\fP __first, \fBconst_iterator\fP __last)"
.br
.ti -1c
.RI "\fBallocator_type\fP \fBget_allocator\fP () const noexcept"
.br
.ti -1c
.RI "\fBhasher\fP \fBhash_function\fP () const "
.br
.ti -1c
.RI "template<typename _InputIterator > void \fBinsert\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBinitializer_list\fP< \fBvalue_type\fP > __l)"
.br
.ti -1c
.RI "\fBkey_equal\fP \fBkey_eq\fP () const "
.br
.ti -1c
.RI "float \fBload_factor\fP () const noexcept"
.br
.ti -1c
.RI "\fBsize_type\fP \fBmax_bucket_count\fP () const noexcept"
.br
.ti -1c
.RI "float \fBmax_load_factor\fP () const noexcept"
.br
.ti -1c
.RI "void \fBmax_load_factor\fP (float __z)"
.br
.ti -1c
.RI "\fBsize_type\fP \fBmax_size\fP () const noexcept"
.br
.ti -1c
.RI "\fBunordered_map\fP & \fBoperator=\fP (const \fBunordered_map\fP &)=default"
.br
.ti -1c
.RI "\fBunordered_map\fP & \fBoperator=\fP (\fBunordered_map\fP &&)=default"
.br
.ti -1c
.RI "\fBunordered_map\fP & \fBoperator=\fP (\fBinitializer_list\fP< \fBvalue_type\fP > __l)"
.br
.ti -1c
.RI "void \fBrehash\fP (\fBsize_type\fP __n)"
.br
.ti -1c
.RI "void \fBreserve\fP (\fBsize_type\fP __n)"
.br
.ti -1c
.RI "\fBsize_type\fP \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "void \fBswap\fP (\fBunordered_map\fP &__x)"
.br
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const noexcept"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const noexcept"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBstd::pair\fP< \fBiterator\fP, bool > \fBinsert\fP (const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "template<typename _Pair , typename  = typename std::enable_if<std::is_constructible<value_type,						    _Pair&&>::value>::type> \fBstd::pair\fP< \fBiterator\fP, bool > \fBinsert\fP (_Pair &&__x)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP __hint, const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "template<typename _Pair , typename  = typename std::enable_if<std::is_constructible<value_type,						    _Pair&&>::value>::type> \fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP __hint, _Pair &&__x)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBconst_iterator\fP __position)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __it)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBiterator\fP \fBfind\fP (const \fBkey_type\fP &__x)"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBfind\fP (const \fBkey_type\fP &__x) const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBstd::pair\fP< \fBiterator\fP, \fBiterator\fP > \fBequal_range\fP (const \fBkey_type\fP &__x)"
.br
.ti -1c
.RI "\fBstd::pair\fP< \fBconst_iterator\fP, 
.br
\fBconst_iterator\fP > \fBequal_range\fP (const \fBkey_type\fP &__x) const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBmapped_type\fP & \fBoperator[]\fP (const \fBkey_type\fP &__k)"
.br
.ti -1c
.RI "\fBmapped_type\fP & \fBoperator[]\fP (\fBkey_type\fP &&__k)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBmapped_type\fP & \fBat\fP (const \fBkey_type\fP &__k)"
.br
.ti -1c
.RI "const \fBmapped_type\fP & \fBat\fP (const \fBkey_type\fP &__k) const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBconst_local_iterator\fP \fBbegin\fP (\fBsize_type\fP __n) const "
.br
.ti -1c
.RI "\fBconst_local_iterator\fP \fBcbegin\fP (\fBsize_type\fP __n) const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBconst_local_iterator\fP \fBend\fP (\fBsize_type\fP __n) const "
.br
.ti -1c
.RI "\fBconst_local_iterator\fP \fBcend\fP (\fBsize_type\fP __n) const "
.br
.in -1c
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<typename _Key1 , typename _Tp1 , typename _Hash1 , typename _Pred1 , typename _Alloc1 > bool \fBoperator==\fP (const \fBunordered_map\fP< _Key1, _Tp1, _Hash1, _Pred1, _Alloc1 > &, const \fBunordered_map\fP< _Key1, _Tp1, _Hash1, _Pred1, _Alloc1 > &)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >>class std::unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc >"
A standard container composed of unique keys (containin at most one of each key value) dat associates jointz of another type wit tha keys\&. 


.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Key\fP Type of key objects\&. 
.br
\fI_Tp\fP Type of mapped objects\&. 
.br
\fI_Hash\fP Hashin function object type, defaults ta hash<_Value>\&. 
.br
\fI_Pred\fP Predicate function object type, defaults ta equal_to<_Value>\&. 
.br
\fI_Alloc\fP Allocator type, defaults ta allocator<_Key>\&.
.RE
.PP
Meets tha requirementz of a \fCcontainer\fP, n' \fCunordered associatizzle container\fP
.PP
Da resultin value type of tha container is std::pair<const _Key, _Tp>\&.
.PP
Base is _Hashtable, dispatched at compile time via template alias __umap_hashtable\&. 
.PP
Definizzle at line 97 of file unordered_map\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef _Hashtable::allocator_type \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBallocator_type\fP"

.PP
Public typedefs\&. 
.PP
Definizzle at line 111 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef _Hashtable::const_iterator \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBconst_iterator\fP"

.PP
Iterator-related typedefs\&. 
.PP
Definizzle at line 121 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef _Hashtable::const_local_iterator \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBconst_local_iterator\fP"

.PP
Iterator-related typedefs\&. 
.PP
Definizzle at line 123 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef allocator_type::const_pointa \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBconst_pointer\fP"

.PP
Iterator-related typedefs\&. 
.PP
Definizzle at line 117 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef allocator_type::const_reference \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBconst_reference\fP"

.PP
Iterator-related typedefs\&. 
.PP
Definizzle at line 119 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef _Hashtable::difference_type \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBdifference_type\fP"

.PP
Iterator-related typedefs\&. 
.PP
Definizzle at line 125 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef _Hashtable::hasher \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBhasher\fP"

.PP
Public typedefs\&. 
.PP
Definizzle at line 109 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef _Hashtable::iterator \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBiterator\fP"

.PP
Iterator-related typedefs\&. 
.PP
Definizzle at line 120 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef _Hashtable::key_equal \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBkey_equal\fP"

.PP
Public typedefs\&. 
.PP
Definizzle at line 110 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef _Hashtable::key_type \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBkey_type\fP"

.PP
Public typedefs\&. 
.PP
Definizzle at line 106 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef _Hashtable::local_iterator \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBlocal_iterator\fP"

.PP
Iterator-related typedefs\&. 
.PP
Definizzle at line 122 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef _Hashtable::mapped_type \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBmapped_type\fP"

.PP
Public typedefs\&. 
.PP
Definizzle at line 108 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef allocator_type::pointa \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBpointer\fP"

.PP
Iterator-related typedefs\&. 
.PP
Definizzle at line 116 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef allocator_type::reference \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBreference\fP"

.PP
Iterator-related typedefs\&. 
.PP
Definizzle at line 118 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef _Hashtable::size_type \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBsize_type\fP"

.PP
Iterator-related typedefs\&. 
.PP
Definizzle at line 124 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> typedef _Hashtable::value_type \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBvalue_type\fP"

.PP
Public typedefs\&. 
.PP
Definizzle at line 107 of file unordered_map\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBunordered_map\fP (\fBsize_type\fP__n = \fC10\fP, const \fBhasher\fP &__hf = \fC\fBhasher\fP()\fP, const \fBkey_equal\fP &__eql = \fC\fBkey_equal\fP()\fP, const \fBallocator_type\fP &__a = \fC\fBallocator_type\fP()\fP)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Default constructor creates no elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Initial number of buckets\&. 
.br
\fI__hf\fP A hash functor\&. 
.br
\fI__eql\fP A key equalitizzle functor\&. 
.br
\fI__a\fP An allocator object\&. 
.RE
.PP

.PP
Definizzle at line 138 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename _InputIterator > \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBunordered_map\fP (_InputIterator__f, _InputIterator__l, \fBsize_type\fP__n = \fC0\fP, const \fBhasher\fP &__hf = \fC\fBhasher\fP()\fP, const \fBkey_equal\fP &__eql = \fC\fBkey_equal\fP()\fP, const \fBallocator_type\fP &__a = \fC\fBallocator_type\fP()\fP)\fC [inline]\fP"

.PP
Buildz a unordered_map from a range\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&. 
.br
\fI__n\fP Minimal initial number of buckets\&. 
.br
\fI__hf\fP A hash functor\&. 
.br
\fI__eql\fP A key equalitizzle functor\&. 
.br
\fI__a\fP An allocator object\&.
.RE
.PP
Smoke a unordered_map consistin of copiez of tha elements from [__first,__last)\&. This is linear up in N (where N is distance(__first,__last))\&. 
.PP
Definizzle at line 159 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBunordered_map\fP (const \fBunordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &)\fC [default]\fP"

.PP
Copy constructor\&. 
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBunordered_map\fP (\fBunordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &&)\fC [default]\fP"

.PP
Move constructor\&. 
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::\fBunordered_map\fP (\fBinitializer_list\fP< \fBvalue_type\fP >__l, \fBsize_type\fP__n = \fC0\fP, const \fBhasher\fP &__hf = \fC\fBhasher\fP()\fP, const \fBkey_equal\fP &__eql = \fC\fBkey_equal\fP()\fP, const \fBallocator_type\fP &__a = \fC\fBallocator_type\fP()\fP)\fC [inline]\fP"

.PP
Buildz a unordered_map from a initializer_list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list\&. 
.br
\fI__n\fP Minimal initial number of buckets\&. 
.br
\fI__hf\fP A hash functor\&. 
.br
\fI__eql\fP A key equalitizzle functor\&. 
.br
\fI__a\fP An allocator object\&.
.RE
.PP
Smoke a unordered_map consistin of copiez of tha elements up in tha list\&. This is linear up in N (where N is \fI__l\&.size()\fP)\&. 
.PP
Definizzle at line 184 of file unordered_map\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBmapped_type\fP& \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::at (const \fBkey_type\fP &__k)\fC [inline]\fP"

.PP
Access ta unordered_map data\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__k\fP Da key fo' which data should be retrieved\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A reference ta tha data whose key is equal ta \fI__k\fP, if such a thugged-out data is present up in tha unordered_map\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If no such data is present\&. 
.RE
.PP

.PP
Definizzle at line 612 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const \fBmapped_type\fP& \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::at (const \fBkey_type\fP &__k) const\fC [inline]\fP"

.PP
Access ta unordered_map data\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__k\fP Da key fo' which data should be retrieved\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A reference ta tha data whose key is equal ta \fI__k\fP, if such a thugged-out data is present up in tha unordered_map\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If no such data is present\&. 
.RE
.PP

.PP
Definizzle at line 616 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBiterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::begin ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write iterator dat points ta tha straight-up original gangsta element up in tha unordered_map\&. 
.PP
Definizzle at line 248 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_iterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::begin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points ta tha straight-up original gangsta element up in tha unordered_map\&. 
.PP
Definizzle at line 257 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBlocal_iterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::begin (\fBsize_type\fP__n)\fC [inline]\fP"

.PP
Returns a read/write iterator pointin ta tha straight-up original gangsta bucket element\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da bucket index\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A read/write local iterator\&. 
.RE
.PP

.PP
Definizzle at line 657 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_local_iterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::begin (\fBsize_type\fP__n) const\fC [inline]\fP"

.PP
Returns a read-only (constant) iterator pointin ta tha straight-up original gangsta bucket element\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da bucket index\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A read-only local iterator\&. 
.RE
.PP

.PP
Definizzle at line 668 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBsize_type\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::bucket_count () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns tha number of bucketz of tha unordered_map\&. 
.PP
Definizzle at line 624 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_iterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::cbegin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points ta tha straight-up original gangsta element up in tha unordered_map\&. 
.PP
Definizzle at line 261 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_local_iterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::cbegin (\fBsize_type\fP__n) const\fC [inline]\fP"

.PP
Returns a read-only (constant) iterator pointin ta tha straight-up original gangsta bucket element\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da bucket index\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A read-only local iterator\&. 
.RE
.PP

.PP
Definizzle at line 672 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_iterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::cend () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points one past tha last element up in tha unordered_map\&. 
.PP
Definizzle at line 283 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_local_iterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::cend (\fBsize_type\fP__n) const\fC [inline]\fP"

.PP
Returns a read-only (constant) iterator pointin ta one past tha last bucket elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da bucket index\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A read-only local iterator\&. 
.RE
.PP

.PP
Definizzle at line 698 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> void \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::clear ()\fC [inline]\fP, \fC [noexcept]\fP"
Erases all elements up in a unordered_map\&. Note dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 497 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBsize_type\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::count (const \fBkey_type\fP &__x) const\fC [inline]\fP"

.PP
Findz tha number of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key ta count\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of elements wit specified key\&.
.RE
.PP
This function only make sense fo' unordered_multimap; fo' unordered_map tha result will either be 0 (not present) or 1 (present)\&. 
.PP
Definizzle at line 560 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename\&.\&.\&. _Args> \fBstd::pair\fP<\fBiterator\fP, bool> \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::emplace (_Args &&\&.\&.\&.__args)\fC [inline]\fP"

.PP
Attempts ta build n' bang a std::pair tha fuck into tha unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__args\fP Arguments used ta generate a freshly smoked up pair instizzle (see std::piecewise_contruct fo' passin arguments ta each part of tha pair constructor)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A pair, of which tha straight-up original gangsta element be a iterator dat points ta tha possibly banged pair, n' tha second be a funky-ass bool dat is legit if tha pair was straight-up inserted\&.
.RE
.PP
This function attempts ta build n' bang a (key, value) pair tha fuck into tha unordered_map\& fo' realz. An unordered_map relies on unique keys n' thus a pair is only banged if its first element (the key) aint already present up in tha unordered_map\&.
.PP
Insertion requires amortized constant time\&. 
.PP
Definizzle at line 310 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename\&.\&.\&. _Args> \fBiterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::emplace_hint (\fBconst_iterator\fP__pos, _Args &&\&.\&.\&.__args)\fC [inline]\fP"

.PP
Attempts ta build n' bang a std::pair tha fuck into tha unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos\fP An iterator dat serves as a hint as ta where tha pair should be inserted\&. 
.br
\fI__args\fP Arguments used ta generate a freshly smoked up pair instizzle (see std::piecewise_contruct fo' passin arguments ta each part of tha pair constructor)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha element wit key of tha std::pair built from \fI__args\fP (may or may not be dat std::pair)\&.
.RE
.PP
This function aint concerned bout whether tha insertion took place, n' thus do not return a funky-ass boolean like tha single-argument emplace() do\&. Note dat tha straight-up original gangsta parameta is only a hint n' can potentially improve tha performizzle of tha insertion process\& fo' realz. A wack hint would cause no gains up in efficiency\&.
.PP
See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html fo' mo' on \fIhinting\fP\&.
.PP
Insertion requires amortized constant time\&. 
.PP
Definizzle at line 340 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> bool \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::empty () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns legit if tha unordered_map is empty\&. 
.PP
Definizzle at line 228 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBiterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::end ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write iterator dat points one past tha last element up in tha unordered_map\&. 
.PP
Definizzle at line 270 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_iterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::end () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points one past tha last element up in tha unordered_map\&. 
.PP
Definizzle at line 279 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBlocal_iterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::end (\fBsize_type\fP__n)\fC [inline]\fP"

.PP
Returns a read/write iterator pointin ta one past tha last bucket elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da bucket index\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A read/write local iterator\&. 
.RE
.PP

.PP
Definizzle at line 683 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_local_iterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::end (\fBsize_type\fP__n) const\fC [inline]\fP"

.PP
Returns a read-only (constant) iterator pointin ta one past tha last bucket elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da bucket index\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A read-only local iterator\&. 
.RE
.PP

.PP
Definizzle at line 694 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::pair\fP<\fBiterator\fP, \fBiterator\fP> \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::equal_range (const \fBkey_type\fP &__x)\fC [inline]\fP"

.PP
Findz a subsequence matchin given key\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key ta be located\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pair of iterators dat possibly points ta tha subsequence matchin given key\&.
.RE
.PP
This function probably only make sense fo' unordered_multimap\&. 
.PP
Definizzle at line 573 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::pair\fP<\fBconst_iterator\fP, \fBconst_iterator\fP> \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::equal_range (const \fBkey_type\fP &__x) const\fC [inline]\fP"

.PP
Findz a subsequence matchin given key\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key ta be located\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pair of iterators dat possibly points ta tha subsequence matchin given key\&.
.RE
.PP
This function probably only make sense fo' unordered_multimap\&. 
.PP
Definizzle at line 577 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBiterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::erase (\fBconst_iterator\fP__position)\fC [inline]\fP"

.PP
Erases a element from a unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator pointin ta tha element ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator pointin ta tha element immediately followin \fI__position\fP prior ta tha element bein erased\&. If no such element exists, end() is returned\&.
.RE
.PP
This function erases a element, pointed ta by tha given iterator, from a unordered_map\&. Note dat dis function only erases tha element, n' dat if tha element is itself a pointer, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 447 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBiterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::erase (\fBiterator\fP__it)\fC [inline]\fP"

.PP
Erases a element from a unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator pointin ta tha element ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator pointin ta tha element immediately followin \fI__position\fP prior ta tha element bein erased\&. If no such element exists, end() is returned\&.
.RE
.PP
This function erases a element, pointed ta by tha given iterator, from a unordered_map\&. Note dat dis function only erases tha element, n' dat if tha element is itself a pointer, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 452 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBsize_type\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::erase (const \fBkey_type\fP &__x)\fC [inline]\fP"

.PP
Erases elements accordin ta tha provided key\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key of element ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da number of elements erased\&.
.RE
.PP
This function erases all tha elements located by tha given key from a unordered_map\&. For a unordered_map tha result of dis function can only be 0 (not present) or 1 (present)\&. Note dat dis function only erases tha element, n' dat if tha element is itself a pointer, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 469 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBiterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::erase (\fBconst_iterator\fP__first, \fBconst_iterator\fP__last)\fC [inline]\fP"

.PP
Erases a [__first,__last) range of elements from a unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP Iterator pointin ta tha start of tha range ta be erased\&. 
.br
\fI__last\fP Iterator pointin ta tha end of tha range ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da iterator \fI__last\fP\&.
.RE
.PP
This function erases a sequence of elements from a unordered_map\&. Note dat dis function only erases tha elements, n' dat if tha element is itself a pointer, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 487 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBiterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::find (const \fBkey_type\fP &__x)\fC [inline]\fP"

.PP
Tries ta locate a element up in a unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key ta be located\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator pointin ta sought-afta element, or end() if not found\&.
.RE
.PP
This function takes a key n' tries ta locate tha element wit which tha key matches\&. If successful tha function returns a iterator pointin ta tha sought afta element\&. If unsuccessful it returns tha past-the-end ( \fCend()\fP ) iterator\&. 
.PP
Definizzle at line 542 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_iterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::find (const \fBkey_type\fP &__x) const\fC [inline]\fP"

.PP
Tries ta locate a element up in a unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key ta be located\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator pointin ta sought-afta element, or end() if not found\&.
.RE
.PP
This function takes a key n' tries ta locate tha element wit which tha key matches\&. If successful tha function returns a iterator pointin ta tha sought afta element\&. If unsuccessful it returns tha past-the-end ( \fCend()\fP ) iterator\&. 
.PP
Definizzle at line 546 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBallocator_type\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::get_allocator () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns tha allocator object wit which tha unordered_map was constructed\&. 
.PP
Definizzle at line 221 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBhasher\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::hash_function () const\fC [inline]\fP"

.PP
Returns tha hash functor object wit which tha unordered_map was constructed\&. 
.PP
Definizzle at line 518 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::pair\fP<\fBiterator\fP, bool> \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::insert (const \fBvalue_type\fP &__x)\fC [inline]\fP"

.PP
Attempts ta bang a std::pair tha fuck into tha unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Pair ta be banged (see std::make_pair fo' easy as fuck  creation of pairs)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A pair, of which tha straight-up original gangsta element be a iterator dat points ta tha possibly banged pair, n' tha second be a funky-ass bool dat is legit if tha pair was straight-up inserted\&.
.RE
.PP
This function attempts ta bang a (key, value) pair tha fuck into tha unordered_map\& fo' realz. An unordered_map relies on unique keys n' thus a pair is only banged if its first element (the key) aint already present up in tha unordered_map\&.
.PP
Insertion requires amortized constant time\&. 
.PP
Definizzle at line 362 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename _Pair , typename  = typename std::enable_if<std::is_constructible<value_type,						    _Pair&&>::value>::type> \fBstd::pair\fP<\fBiterator\fP, bool> \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::insert (_Pair &&__x)\fC [inline]\fP"

.PP
Attempts ta bang a std::pair tha fuck into tha unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Pair ta be banged (see std::make_pair fo' easy as fuck  creation of pairs)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A pair, of which tha straight-up original gangsta element be a iterator dat points ta tha possibly banged pair, n' tha second be a funky-ass bool dat is legit if tha pair was straight-up inserted\&.
.RE
.PP
This function attempts ta bang a (key, value) pair tha fuck into tha unordered_map\& fo' realz. An unordered_map relies on unique keys n' thus a pair is only banged if its first element (the key) aint already present up in tha unordered_map\&.
.PP
Insertion requires amortized constant time\&. 
.PP
Definizzle at line 369 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBiterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::insert (\fBconst_iterator\fP__hint, const \fBvalue_type\fP &__x)\fC [inline]\fP"

.PP
Attempts ta bang a std::pair tha fuck into tha unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__hint\fP An iterator dat serves as a hint as ta where tha pair should be inserted\&. 
.br
\fI__x\fP Pair ta be banged (see std::make_pair fo' easy as fuck  creation of pairs)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha element wit key of \fI__x\fP (may or may not be tha pair passed in)\&.
.RE
.PP
This function aint concerned bout whether tha insertion took place, n' thus do not return a funky-ass boolean like tha single-argument insert() do\&. Note dat tha straight-up original gangsta parameta is only a hint n' can potentially improve tha performizzle of tha insertion process\& fo' realz. A wack hint would cause no gains up in efficiency\&.
.PP
See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html fo' mo' on \fIhinting\fP\&.
.PP
Insertion requires amortized constant time\&. 
.PP
Definizzle at line 396 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename _Pair , typename  = typename std::enable_if<std::is_constructible<value_type,						    _Pair&&>::value>::type> \fBiterator\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::insert (\fBconst_iterator\fP__hint, _Pair &&__x)\fC [inline]\fP"

.PP
Attempts ta bang a std::pair tha fuck into tha unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__hint\fP An iterator dat serves as a hint as ta where tha pair should be inserted\&. 
.br
\fI__x\fP Pair ta be banged (see std::make_pair fo' easy as fuck  creation of pairs)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha element wit key of \fI__x\fP (may or may not be tha pair passed in)\&.
.RE
.PP
This function aint concerned bout whether tha insertion took place, n' thus do not return a funky-ass boolean like tha single-argument insert() do\&. Note dat tha straight-up original gangsta parameta is only a hint n' can potentially improve tha performizzle of tha insertion process\& fo' realz. A wack hint would cause no gains up in efficiency\&.
.PP
See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html fo' mo' on \fIhinting\fP\&.
.PP
Insertion requires amortized constant time\&. 
.PP
Definizzle at line 403 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename _InputIterator > void \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::insert (_InputIterator__first, _InputIterator__last)\fC [inline]\fP"

.PP
A template function dat attempts ta bang a range of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP Iterator pointin ta tha start of tha range ta be inserted\&. 
.br
\fI__last\fP Iterator pointin ta tha end of tha range\&.
.RE
.PP
Complexitizzle similar ta dat of tha range constructor\&. 
.PP
Definizzle at line 418 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> void \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::insert (\fBinitializer_list\fP< \fBvalue_type\fP >__l)\fC [inline]\fP"

.PP
Attempts ta bang a list of elements tha fuck into tha unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP A std::initializer_list<value_type> of elements ta be inserted\&.
.RE
.PP
Complexitizzle similar ta dat of tha range constructor\&. 
.PP
Definizzle at line 429 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBkey_equal\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::key_eq () const\fC [inline]\fP"

.PP
Returns tha key comparison object wit which tha unordered_map was constructed\&. 
.PP
Definizzle at line 524 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> float \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::load_factor () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns tha average number of elements per bucket\&. 
.PP
Definizzle at line 706 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBsize_type\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::max_bucket_count () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns tha maximum number of bucketz of tha unordered_map\&. 
.PP
Definizzle at line 629 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> float \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::max_load_factor () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns a positizzle number dat tha unordered_map tries ta keep tha load factor less than or equal to\&. 
.PP
Definizzle at line 712 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> void \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::max_load_factor (float__z)\fC [inline]\fP"

.PP
Change tha unordered_map maximum load factor\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__z\fP Da freshly smoked up maximum load factor\&. 
.RE
.PP

.PP
Definizzle at line 720 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBsize_type\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::max_size () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns tha maximum size of tha unordered_map\&. 
.PP
Definizzle at line 238 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBunordered_map\fP& \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::operator= (const \fBunordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &)\fC [default]\fP"

.PP
Copy assignment operator\&. 
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBunordered_map\fP& \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::operator= (\fBunordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &&)\fC [default]\fP"

.PP
Move assignment operator\&. 
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBunordered_map\fP& \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::operator= (\fBinitializer_list\fP< \fBvalue_type\fP >__l)\fC [inline]\fP"

.PP
Unordered_map list assignment operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list\&.
.RE
.PP
This function fills a unordered_map wit copiez of tha elements up in tha initializer list \fI__l\fP\&.
.PP
Note dat tha assignment straight-up chizzlez tha unordered_map n' dat tha resultin unordered_mapz size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 212 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBmapped_type\fP& \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::operator[] (const \fBkey_type\fP &__k)\fC [inline]\fP"

.PP
Subscript ( \fC\fP[] ) access ta unordered_map data\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__k\fP Da key fo' which data should be retrieved\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A reference ta tha data of tha (key,data) pair\&.
.RE
.PP
Allows fo' easy as fuck  lookup wit tha subscript ( \fC\fP[] )operator\&. Returns data associated wit tha key specified up in subscript\&. If tha key do not exist, a pair wit dat key is pimped rockin default joints, which is then returned\&.
.PP
Lookup requires constant time\&. 
.PP
Definizzle at line 595 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBmapped_type\fP& \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::operator[] (\fBkey_type\fP &&__k)\fC [inline]\fP"

.PP
Subscript ( \fC\fP[] ) access ta unordered_map data\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__k\fP Da key fo' which data should be retrieved\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A reference ta tha data of tha (key,data) pair\&.
.RE
.PP
Allows fo' easy as fuck  lookup wit tha subscript ( \fC\fP[] )operator\&. Returns data associated wit tha key specified up in subscript\&. If tha key do not exist, a pair wit dat key is pimped rockin default joints, which is then returned\&.
.PP
Lookup requires constant time\&. 
.PP
Definizzle at line 599 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> void \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::rehash (\fBsize_type\fP__n)\fC [inline]\fP"

.PP
May rehash tha unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da freshly smoked up number of buckets\&.
.RE
.PP
Rehash will occur only if tha freshly smoked up number of buckets respect tha unordered_map maximum load factor\&. 
.PP
Definizzle at line 731 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> void \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::reserve (\fBsize_type\fP__n)\fC [inline]\fP"

.PP
Prepare tha unordered_map fo' a specified number of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Number of elements required\&.
.RE
.PP
Same as rehash(ceil(n / max_load_factor()))\&. 
.PP
Definizzle at line 742 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBsize_type\fP \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::size () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns tha size of tha unordered_map\&. 
.PP
Definizzle at line 233 of file unordered_map\&.h\&.
.SS "template<class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = std::equal_to<_Key>, class _Alloc = std::allocator<std::pair<const _Key, _Tp> >> void \fBstd::unordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc >::swap (\fBunordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &__x)\fC [inline]\fP"

.PP
Swaps data wit another unordered_map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP An unordered_map of tha same element n' allocator types\&.
.RE
.PP
This exchanges tha elements between two unordered_map up in constant time\&. Note dat tha global std::swap() function is specialized such dat std::swap(m1,m2) will feed ta dis function\&. 
.PP
Definizzle at line 510 of file unordered_map\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
