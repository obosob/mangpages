.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message::Field::Full 3"
.TH Mail::Message::Field::Full 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Field::Full \- construct one smart-ass line up in a message header
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\& Mail::Message::Field::Full
\&   be a Mail::Message::Field
\&   be a Mail::Reporter
\&
\& Mail::Message::Field::Full is extended by
\&   Mail::Message::Field::Structured
\&   Mail::Message::Field::Unstructured
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& !! UNDER CONSTRUCTION
\& !! Da detailz of dis module is NOT FINISHED yet
\& !! Most parts is already usable, however n' shit.  With care!
\&
\& # Gettin ta KNOW tha complexitizzle of a header field ...
\&
\& mah $fast = $msg\->head\->get(\*(Aqsubject\*(Aq);
\& mah $full = Mail::Message::Field::Full\->from($fast);
\&
\& mah $full = $msg\->head\->get(\*(Aqsubject\*(Aq)\->study;  # same
\& mah $full = $msg\->head\->study(\*(Aqsubject\*(Aq);       # same
\& mah $full = $msg\->get(\*(Aqsubject\*(Aq);               # same
\&
\& # ... or build a cold-ass lil complex header field yo ass
\&
\& mah $f = Mail::Message::Field::Full\->new(\*(AqTo\*(Aq);
\& mah $f = Mail::Message::Field::Full\->new(\*(AqSubject: hi!\*(Aq);
\& mah $f = Mail::Message::Field::Full\->new(Subject => \*(Aqhi!\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is tha \fIfull\fR implementation of a header field: it has \fIfull\fR
understandin of all predefined header fields.  These objects will be
quite slow, cuz header fieldz can be straight-up complex.  Of course, this
class delivers tha optimal result yo, but fo' a like big-ass penalty in
performizzle n' memory consumption. I aint talkin' bout chicken n' gravy biatch.  Is you willin ta accept?
.PP
This class supports tha common header description from \s-1RFC2822 \s0(formerly
\&\s-1RFC822\s0), tha extensions wit respect ta characta set encodings as specified
in \s-1RFC2047,\s0 n' tha extensions on language justification n' long parameter
wrappin from \s-1RFC2231. \s0 If you do not need tha latta two, then the
Mail::Message::Field::Fast n' Mail::Message::Field::Flex
are enough fo' yo' application.
.SH "OVERLOADED"
.IX Header "OVERLOADED"
.ie n .IP "overload: \fB""""\fR()" 4
.el .IP "overload: \fB``''\fR()" 4
.IX Item "overload: """"()"
See \*(L"\s-1OVERLOADED\*(R"\s0 up in Mail::Message::Field
.IP "overload: \fB0+\fR()" 4
.IX Item "overload: 0+()"
See \*(L"\s-1OVERLOADED\*(R"\s0 up in Mail::Message::Field
.IP "overload: \fB<=\fR>()" 4
.IX Item "overload: <=>()"
See \*(L"\s-1OVERLOADED\*(R"\s0 up in Mail::Message::Field
.IP "overload: \fBbool\fR()" 4
.IX Item "overload: bool()"
See \*(L"\s-1OVERLOADED\*(R"\s0 up in Mail::Message::Field
.IP "overload: \fBcmp\fR()" 4
.IX Item "overload: cmp()"
See \*(L"\s-1OVERLOADED\*(R"\s0 up in Mail::Message::Field
.IP "overload: \fBstringification\fR()" 4
.IX Item "overload: stringification()"
In strang context, tha decoded body is returned, as if \fIdecodedBody()\fR
would done been called.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBclone\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBclone\fR()" 4
.IX Item "$obj->clone()"
See \*(L"Constructors\*(R" up in Mail::Message::Field
.IP "Mail::Message::Field::Full\->\fBfrom\fR(\s-1FIELD, OPTIONS\s0)" 4
.IX Item "Mail::Message::Field::Full->from(FIELD, OPTIONS)"
Convert any \s-1FIELD \s0(a Mail::Message::Field object) tha fuck into a new
Mail::Message::Field::Full object.  This conversion is done tha hard
way: tha strang which is produced by tha original gangsta object is parsed
again. I aint talkin' bout chicken n' gravy biatch.  Usually, tha strang which is parsed is exactly tha line (or lines)
as found up in tha original gangsta input source, which be a phat thang cuz Full
fieldz is much mo' carefull wit tha actual content.
.Sp
\&\s-1OPTIONS\s0 is passed ta tha constructor (see \fInew()\fR).  In any case, some
extensionz of dis Full field class is returned. Y'all KNOW dat shit, muthafucka!  It dependz on which
field is pimped what tha fuck kind of class we get.
.Sp
example:
.Sp
.Vb 2
\& mah $fast = $msg\->head\->get(\*(Aqsubject\*(Aq);
\& mah $full = Mail::Message::Field::Full\->from($fast);
\&
\& mah $full = $msg\->head\->get(\*(Aqsubject\*(Aq)\->study;  # same
\& mah $full = $msg\->head\->study(\*(Aqsubject\*(Aq);       # same
\& mah $full = $msg\->get(\*(Aqsubject\*(Aq);               # same
.Ve
.IP "Mail::Message::Field::Full\->\fBnew\fR(\s-1DATA\s0)" 4
.IX Item "Mail::Message::Field::Full->new(DATA)"
Creatin a freshly smoked up field object tha erect way be a shitload of work, cuz
there is so much freedom up in tha RFCs yo, but all up in tha same time so many
restrictions.  Most fieldz is implemented yo, but if you have yo' own
field (and do no wanna contribute it ta MailBox), then simply call
new on yo' own package.
.Sp
Yo ass have tha chizzle ta instantiate tha object as strang or up in prepared
parts:
.RS 4
.IP "\(bu" 4
\&\fBnew\fR \s-1LINE, OPTIONS\s0
.Sp
Pass a \s-1LINE\s0 as it could be found up in a gangbangin' file: a (possibly folded) line
which is terminated by a new-line.
.IP "\(bu" 4
\&\fBnew\fR \s-1NAME,\s0 [\s-1BODY\s0], \s-1OPTIONS\s0
.Sp
A set of joints which shape tha line.
.RE
.RS 4
.Sp
Da \s-1NAME\s0 be a wellformed header name (you may use \fIwellformedName()\fR) to
be shizzle bout tha casing.  Da \s-1BODY\s0 be a string, one object, or an
ref-array of objects, n' you can put dat on yo' toast.  In case of objects, they must fit ta the
constructor of tha field: tha types which is accepted may differ.
Da optionizzle \s-1ATTRIBUTE\s0 list gotz nuff Mail::Message::Field::Attribute
objects, n' you can put dat on yo' toast.  Finally, there be some \s-1OPTIONS.\s0
.Sp
.Vb 7
\& \-Option  \-\-Defined up in     \-\-Default
\&  charset                    undef
\&  encodin                   \*(Aqq\*(Aq
\&  force                      false
\&  language                   undef
\&  log       Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  trace     Mail::Reporta   \*(AqWARNINGS\*(Aq
.Ve
.IP "charset => \s-1STRING\s0" 2
.IX Item "charset => STRING"
Da body is specified up in utf8, n' must become 7\-bits ascii ta be
transmited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Specify a cold-ass lil charset ta which tha multi-byte utf8 is converted
before it gets encoded. Y'all KNOW dat shit, muthafucka!  See \fIencode()\fR, which do tha thang.
.IP "encodin => 'q'|'Q'|'b'|'B'" 2
.IX Item "encodin => 'q'|'Q'|'b'|'B'"
Non-ascii charactas is encoded rockin Quoted-Printable ('q' or 'Q') or
Base64 ('b' or 'B') encoding.
.IP "force => \s-1BOOLEAN\s0" 2
.IX Item "force => BOOLEAN"
Enforce encodin up in tha specified charset, even when it aint needed
because tha body do not contain any non-ascii characters.
.IP "language => \s-1STRING\s0" 2
.IX Item "language => STRING"
Da language used can be specified, however is rarely used mah mail clients.
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.RE
.RS 4
.PD
.Sp
example:
.Sp
.Vb 2
\& mah $s = Mail::Message::Field::Full\->new(\*(AqSubject: Wuz crackalackin' World\*(Aq);
\& mah $s = Mail::Message::Field::Full\->new(\*(AqSubject\*(Aq, \*(AqWuz crackalackin' World\*(Aq);
\&
\& mah @attrs   = (Mail::Message::Field::Attribute\->new(...), ...);
\& mah @options = (extra => \*(Aqthe color blue\*(Aq);
\& mah $t = Mail::Message::Field::Full\->new(To => \e@addrs, @attrs, @options);
.Ve
.RE
.SS "Da field"
.IX Subsection "Da field"
.ie n .IP "$obj\->\fBisStructured\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisStructured\fR()" 4
.IX Item "$obj->isStructured()"
.PD 0
.IP "Mail::Message::Field::Full\->\fBisStructured\fR()" 4
.IX Item "Mail::Message::Field::Full->isStructured()"
.PD
See \*(L"Da field\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBlength\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlength\fR()" 4
.IX Item "$obj->length()"
See \*(L"Da field\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBnrLines\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnrLines\fR()" 4
.IX Item "$obj->nrLines()"
See \*(L"Da field\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
See \*(L"Da field\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBsize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsize\fR()" 4
.IX Item "$obj->size()"
See \*(L"Da field\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBstring\fR([\s-1WRAP\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBstring\fR([\s-1WRAP\s0])" 4
.IX Item "$obj->string([WRAP])"
See \*(L"Da field\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBtoDisclose\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtoDisclose\fR()" 4
.IX Item "$obj->toDisclose()"
See \*(L"Da field\*(R" up in Mail::Message::Field
.SS "Access ta tha name"
.IX Subsection "Access ta tha name"
.ie n .IP "$obj\->\fBName\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBName\fR()" 4
.IX Item "$obj->Name()"
See \*(L"Access ta tha name\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBname\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBname\fR()" 4
.IX Item "$obj->name()"
See \*(L"Access ta tha name\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBwellformedName\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBwellformedName\fR([\s-1STRING\s0])" 4
.IX Item "$obj->wellformedName([STRING])"
See \*(L"Access ta tha name\*(R" up in Mail::Message::Field
.SS "Access ta tha body"
.IX Subsection "Access ta tha body"
.ie n .IP "$obj\->\fBbody\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBbody\fR()" 4
.IX Item "$obj->body()"
See \*(L"Access ta tha body\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBdecodedBody\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdecodedBody\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->decodedBody(OPTIONS)"
Returns tha unfolded body of tha field, where encodings is resolved. Y'all KNOW dat shit, muthafucka!  The
returned line will still contain comments n' such.  Da \s-1OPTIONS\s0 is passed
to tha decoder, peep \fIdecode()\fR.
.Sp
\&\s-1BE WARNED:\s0 if tha field be a structured field, tha content may chizzle syntax,
because of encapsulated special characters.  By default, tha body is decoded
as text, which thangs up in dis biatch up in a lil' small-ass difference within comments as well
(read tha \s-1RFC\s0).
.ie n .IP "$obj\->\fBfolded\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfolded\fR()" 4
.IX Item "$obj->folded()"
See \*(L"Access ta tha body\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBfoldedBody\fR([\s-1BODY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfoldedBody\fR([\s-1BODY\s0])" 4
.IX Item "$obj->foldedBody([BODY])"
See \*(L"Access ta tha body\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBstripCFWS\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBstripCFWS\fR([\s-1STRING\s0])" 4
.IX Item "$obj->stripCFWS([STRING])"
.PD 0
.IP "Mail::Message::Field::Full\->\fBstripCFWS\fR([\s-1STRING\s0])" 4
.IX Item "Mail::Message::Field::Full->stripCFWS([STRING])"
.PD
See \*(L"Access ta tha body\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBunfoldedBody\fR([\s-1BODY,\s0 [\s-1WRAP\s0]])" 4
.el .IP "\f(CW$obj\fR\->\fBunfoldedBody\fR([\s-1BODY,\s0 [\s-1WRAP\s0]])" 4
.IX Item "$obj->unfoldedBody([BODY, [WRAP]])"
See \*(L"Access ta tha body\*(R" up in Mail::Message::Field
.SS "Access ta tha content"
.IX Subsection "Access ta tha content"
.ie n .IP "$obj\->\fBaddresses\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddresses\fR()" 4
.IX Item "$obj->addresses()"
See \*(L"Access ta tha content\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBattribute\fR(\s-1NAME\s0 [, \s-1VALUE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBattribute\fR(\s-1NAME\s0 [, \s-1VALUE\s0])" 4
.IX Item "$obj->attribute(NAME [, VALUE])"
See \*(L"Access ta tha content\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBattributes\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBattributes\fR()" 4
.IX Item "$obj->attributes()"
See \*(L"Access ta tha content\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBbeautify\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBbeautify\fR()" 4
.IX Item "$obj->beautify()"
For structured header fields, dis removes tha original gangsta encodin of the
fieldz body (the format as dat shiznit was offered ta \fIparse()\fR), therefore the
next request fo' tha field will gotta re-produce tha read data clean
and sick.  For unstructured bodies, dis method don't do a thang.
.ie n .IP "$obj\->\fBcomment\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBcomment\fR([\s-1STRING\s0])" 4
.IX Item "$obj->comment([STRING])"
See \*(L"Access ta tha content\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBcreateComment\fR(\s-1STRING, OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreateComment\fR(\s-1STRING, OPTIONS\s0)" 4
.IX Item "$obj->createComment(STRING, OPTIONS)"
.PD 0
.IP "Mail::Message::Field::Full\->\fBcreateComment\fR(\s-1STRING, OPTIONS\s0)" 4
.IX Item "Mail::Message::Field::Full->createComment(STRING, OPTIONS)"
.PD
Smoke a cold-ass lil comment ta become part up in a gangbangin' field. Y'all KNOW dat shit, muthafucka!  Comments is automatically
included within parenthesis.  Matchin pairz of parenthesis are
permitted within tha \s-1STRING. \s0 When a non-matchin parenthesis is used,
it is only permitted wit a escape (a backslash) up in front of em.
These backslashes is ghon be added automatically if needed (quit freakin' tha fuck out!).
Backslashes will stay, except all up in tha end, where it is ghon be doubled.
.Sp
Da \s-1OPTIONS\s0 is \f(CW\*(C`charset\*(C'\fR, \f(CW\*(C`language\*(C'\fR, n' \f(CW\*(C`encoding\*(C'\fR as always.
Da pimped comment is returned.
.ie n .IP "$obj\->\fBcreatePhrase\fR(\s-1STRING, OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreatePhrase\fR(\s-1STRING, OPTIONS\s0)" 4
.IX Item "$obj->createPhrase(STRING, OPTIONS)"
.PD 0
.IP "Mail::Message::Field::Full\->\fBcreatePhrase\fR(\s-1STRING, OPTIONS\s0)" 4
.IX Item "Mail::Message::Field::Full->createPhrase(STRING, OPTIONS)"
.PD
A phrase be a text which skits a well defined role.  This is tha main
difference wit comments, which have do specified meaning.  Some special
charactas up in tha phrase will cause it ta be surrounded wit double
quotes: do not specify dem yo ass.
.Sp
Da \s-1OPTIONS\s0 is \f(CW\*(C`charset\*(C'\fR, \f(CW\*(C`language\*(C'\fR, n' \f(CW\*(C`encoding\*(C'\fR, as always.
.ie n .IP "$obj\->\fBstudy\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstudy\fR()" 4
.IX Item "$obj->study()"
See \*(L"Access ta tha content\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBtoDate\fR([\s-1TIME\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtoDate\fR([\s-1TIME\s0])" 4
.IX Item "$obj->toDate([TIME])"
.PD 0
.IP "Mail::Message::Field::Full\->\fBtoDate\fR([\s-1TIME\s0])" 4
.IX Item "Mail::Message::Field::Full->toDate([TIME])"
.PD
See \*(L"Access ta tha content\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBtoInt\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtoInt\fR()" 4
.IX Item "$obj->toInt()"
See \*(L"Access ta tha content\*(R" up in Mail::Message::Field
.SS "Other methods"
.IX Subsection "Other methods"
.ie n .IP "$obj\->\fBdateToTimestamp\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdateToTimestamp\fR(\s-1STRING\s0)" 4
.IX Item "$obj->dateToTimestamp(STRING)"
.PD 0
.IP "Mail::Message::Field::Full\->\fBdateToTimestamp\fR(\s-1STRING\s0)" 4
.IX Item "Mail::Message::Field::Full->dateToTimestamp(STRING)"
.PD
See \*(L"Other methods\*(R" up in Mail::Message::Field
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBconsume\fR(\s-1LINE\s0 | (\s-1NAME\s0,BODY|OBJECTS))" 4
.el .IP "\f(CW$obj\fR\->\fBconsume\fR(\s-1LINE\s0 | (\s-1NAME\s0,BODY|OBJECTS))" 4
.IX Item "$obj->consume(LINE | (NAME,BODY|OBJECTS))"
See \*(L"Internals\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBdecode\fR(\s-1STRING, OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdecode\fR(\s-1STRING, OPTIONS\s0)" 4
.IX Item "$obj->decode(STRING, OPTIONS)"
.PD 0
.IP "Mail::Message::Field::Full\->\fBdecode\fR(\s-1STRING, OPTIONS\s0)" 4
.IX Item "Mail::Message::Field::Full->decode(STRING, OPTIONS)"
.PD
Decode field encoded \s-1STRING\s0 ta a utf8 string.  Da input \s-1STRING\s0 is part of
a header field, n' as such, may contain encoded lyrics up in \f(CW\*(C`=?...?.?...?=\*(C'\fR
format defined by \s-1RFC2047. \s0 Da \s-1STRING\s0 may contain multiple encoded parts,
maybe rockin different characta sets.
.Sp
Be warned:  you \s-1MUST\s0 first interpret tha field tha fuck into parts, like phrases and
comments, n' then decode each part separately, otherwise tha decoded text
may interfere wit yo' markup characters.
.Sp
Be warned: language shiznit, which is defined up in \s-1RFC2231,\s0 is ignored.
.Sp
Encodings wit unknown charsets is left untouched [requires v2.085,
otherwise croaked].  Unknown charactas within a charset is replaced by
a '?'.
.Sp
.Vb 2
\& \-Option \-\-Default
\&  is_text  1
.Ve
.RS 4
.IP "is_text => \s-1BOOLEAN\s0" 2
.IX Item "is_text => BOOLEAN"
Encodin on text is slightly mo' fucked up than encodin structured data,
because it gotz nuff blanks.  Visible blanks gotta be ignored between two
encoded lyrics up in tha text yo, but not when a encoded word bigs up or preceeds
an unencoded word. Y'all KNOW dat shit, muthafucka!  Phrases n' comments is texts.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 2
\& print Mail::Message::Field::Full\->decode(\*(Aq=?iso\-8859\-1?Q?J=F8rgen?=\*(Aq);
\&    # prints   JE<0slash>rgen
.Ve
.RE
.ie n .IP "$obj\->\fBdefaultWrapLength\fR([\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultWrapLength\fR([\s-1LENGTH\s0])" 4
.IX Item "$obj->defaultWrapLength([LENGTH])"
See \*(L"Internals\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBencode\fR(\s-1STRING, OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBencode\fR(\s-1STRING, OPTIONS\s0)" 4
.IX Item "$obj->encode(STRING, OPTIONS)"
Encode tha (possibly utf8 encoded) \s-1STRING\s0 ta a strang which be acceptable
to tha \s-1RFC2047\s0 definizzle of a header: only containin us-ascii characters.
.Sp
.Vb 5
\& \-Option  \-\-Default
\&  charset   \*(Aqus\-ascii\*(Aq
\&  encodin  \*(Aqq\*(Aq
\&  force     <flase>
\&  language  undef
.Ve
.RS 4
.IP "charset => \s-1STRING\s0" 2
.IX Item "charset => STRING"
\&\s-1STRING\s0 be a utf8 strang which has ta be translated tha fuck into any byte-wise
characta set fo' transport, cuz MIME-headaz can only contain ascii
characters.
.IP "encodin => 'q'|'Q'|'b'|'B'" 2
.IX Item "encodin => 'q'|'Q'|'b'|'B'"
Da characta encodin ta be used. Y'all KNOW dat shit, muthafucka!  With \f(CW\*(C`q\*(C'\fR or \f(CW\*(C`Q\*(C'\fR, quoted-printable
encodin is ghon be used. Y'all KNOW dat shit, muthafucka!  With \f(CW\*(C`b \*(C'\fR or \f(CW\*(C`B \*(C'\fR, base64 encodin is ghon be taken.
.IP "force => \s-1BOOLEAN\s0" 2
.IX Item "force => BOOLEAN"
Encode tha string, even when it only gotz nuff us-ascii characters.  By
default, dis is off cuz it decreases readibilitizzle of tha produced
header fields.
.IP "language => \s-1STRING\s0" 2
.IX Item "language => STRING"
\&\s-1RFC2231\s0 defines how tha fuck ta specify language encodings up in encoded lyrics.  The
\&\s-1STRING\s0 be a strandard iso language name.
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBfold\fR(\s-1NAME, BODY,\s0 [\s-1MAXCHARS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold\fR(\s-1NAME, BODY,\s0 [\s-1MAXCHARS\s0])" 4
.IX Item "$obj->fold(NAME, BODY, [MAXCHARS])"
.PD 0
.IP "Mail::Message::Field::Full\->\fBfold\fR(\s-1NAME, BODY,\s0 [\s-1MAXCHARS\s0])" 4
.IX Item "Mail::Message::Field::Full->fold(NAME, BODY, [MAXCHARS])"
.PD
See \*(L"Internals\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBsetWrapLength\fR([\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBsetWrapLength\fR([\s-1LENGTH\s0])" 4
.IX Item "$obj->setWrapLength([LENGTH])"
See \*(L"Internals\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBstringifyData\fR(STRING|ARRAY|OBJECTS)" 4
.el .IP "\f(CW$obj\fR\->\fBstringifyData\fR(STRING|ARRAY|OBJECTS)" 4
.IX Item "$obj->stringifyData(STRING|ARRAY|OBJECTS)"
See \*(L"Internals\*(R" up in Mail::Message::Field
.ie n .IP "$obj\->\fBunfold\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBunfold\fR(\s-1STRING\s0)" 4
.IX Item "$obj->unfold(STRING)"
See \*(L"Internals\*(R" up in Mail::Message::Field
.SS "Parsing"
.IX Subsection "Parsing"
.ie n .IP "$obj\->\fBconsumeComment\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBconsumeComment\fR(\s-1STRING\s0)" 4
.IX Item "$obj->consumeComment(STRING)"
.PD 0
.IP "Mail::Message::Field::Full\->\fBconsumeComment\fR(\s-1STRING\s0)" 4
.IX Item "Mail::Message::Field::Full->consumeComment(STRING)"
.PD
Try ta read a cold-ass lil comment from tha \s-1STRING. \s0 When successful, tha comment
without encapsulation parenthesis is returned, together wit tha rest
of tha string.
.ie n .IP "$obj\->\fBconsumeDotAtom\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBconsumeDotAtom\fR(\s-1STRING\s0)" 4
.IX Item "$obj->consumeDotAtom(STRING)"
Returns three elemens: tha atom-text, tha rest string, n' the
concatenated comments, n' you can put dat on yo' toast.  Both atom n' comments can be undef.
.ie n .IP "$obj\->\fBconsumePhrase\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBconsumePhrase\fR(\s-1STRING\s0)" 4
.IX Item "$obj->consumePhrase(STRING)"
.PD 0
.IP "Mail::Message::Field::Full\->\fBconsumePhrase\fR(\s-1STRING\s0)" 4
.IX Item "Mail::Message::Field::Full->consumePhrase(STRING)"
.PD
Take tha \s-1STRING,\s0 n' try ta strip-off a valid phrase.  In tha obsolete
phrase syntax, any sequence of lyrics be accepted as phrase (as long as
certain special charactas is not used).  \s-1RFC2882\s0 is stricter: only
one word or a quoted strang be allowed. Y'all KNOW dat shit, muthafucka!  As always, tha obsolete
syntax be accepted, n' tha freshly smoked up syntax is produced.
.Sp
This method returns two elements: tha phrase (or undef) followed
by tha resultin string.  Da phrase is ghon be removed from tha optional
quotes.  Be warned dat \f(CW""\fR will return a empty, valid phrase.
.Sp
example:
.Sp
.Vb 1
\& mah ($phrase, $rest) = $field\->consumePhrase( q["hi!" <sales@example.com>] );
.Ve
.ie n .IP "$obj\->\fBparse\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR(\s-1STRING\s0)" 4
.IX Item "$obj->parse(STRING)"
Git tha detailed shiznit from tha \s-1STRING,\s0 n' store tha data found
in tha field object.  Da accepted input is straight-up field type dependent.
Unstructured fieldz do no parsin whatsoever.
.ie n .IP "$obj\->\fBproduceBody\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBproduceBody\fR()" 4
.IX Item "$obj->produceBody()"
Produce tha text fo' tha field, based on tha shiznit stored within the
field object.
.Sp
Usually, you wish tha exact same line as was found up in tha input source
of a message.  But when you have pimped a gangbangin' field yo ass, it should get
formatted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Yo ass may call \fIbeautify()\fR on a preformatted field ta enforce
a call ta dis method when tha field is needed later.
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Message::Field::Full\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Message::Field::Full->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Message::Field::Full\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Message::Field::Full->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Message::Field::Full\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Message::Field::Full->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Warning: Field content aint numerical: $content" 4
.el .IP "Warning: Field content aint numerical: \f(CW$content\fR" 4
.IX Item "Warning: Field content aint numerical: $content"
Da numeric value of a gangbangin' field be axed (for instizzle tha \f(CW\*(C`Lines\*(C'\fR or
\&\f(CW\*(C`Content\-Length\*(C'\fR fieldz should be numerical), however tha data gotz nuff
weird characters.
.IP "Warning: Illegal characta up in charset '$charset'" 4
.IX Item "Warning: Illegal characta up in charset '$charset'"
Da field is pimped wit a utf8 strang which only gotz nuff data from the
specified characta set.  But fuck dat shiznit yo, tha word on tha street is dat that characta set can never be a valid
name cuz it gotz nuff charactas which is not permitted.
.ie n .IP "Warning: Illegal characta up in field name $name" 4
.el .IP "Warning: Illegal characta up in field name \f(CW$name\fR" 4
.IX Item "Warning: Illegal characta up in field name $name"
A freshly smoked up field is bein pimped which do contain charactas not permitted
by tha RFCs.  Usin dis field up in lyrics may break other e\-mail clients
or transfer agents, n' therefore mutulate or extinguish yo' message.
.IP "Warning: Illegal characta up in language '$lang'" 4
.IX Item "Warning: Illegal characta up in language '$lang'"
Da field is pimped wit data which is specified ta be up in a cold-ass lil certain language,
however, tha name of tha language cannot be valid: it gotz nuff characters
which is not permitted by tha RFCs.
.IP "Warning: Illegal encodin '$encoding', used 'q'" 4
.IX Item "Warning: Illegal encodin '$encoding', used 'q'"
Da RFCs only permit base64 (\f(CW\*(C`b \*(C'\fR or \f(CW\*(C`B \*(C'\fR) or quoted-printable
(\f(CW\*(C`q\*(C'\fR or \f(CW\*(C`Q\*(C'\fR) encoding.  Other than these four options is illegal.
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
