" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::ctype< _CharT > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBstd::__ctype_abstract_base< _CharT >\fP\&.
.PP
Inherited by \fBstd::ctype_byname< _CharT >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef const int * \fB__to_type\fP"
.br
.ti -1c
.RI "typedef _CharT \fBchar_type\fP"
.br
.ti -1c
.RI "typedef \fB__ctype_abstract_base\fP
.br
< _CharT >::mask \fBmask\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBctype\fP (size_t __refs=0)"
.br
.ti -1c
.RI "bool \fBis\fP (mask __m, \fBchar_type\fP __c) const "
.br
.ti -1c
.RI "const \fBchar_type\fP * \fBis\fP (const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi, mask *__vec) const "
.br
.ti -1c
.RI "char \fBnarrow\fP (\fBchar_type\fP __c, char __dfault) const "
.br
.ti -1c
.RI "const \fBchar_type\fP * \fBnarrow\fP (const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi, char __dfault, char *__to) const "
.br
.ti -1c
.RI "const \fBchar_type\fP * \fBscan_is\fP (mask __m, const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const "
.br
.ti -1c
.RI "const \fBchar_type\fP * \fBscan_not\fP (mask __m, const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const "
.br
.ti -1c
.RI "\fBchar_type\fP \fBtolower\fP (\fBchar_type\fP __c) const "
.br
.ti -1c
.RI "const \fBchar_type\fP * \fBtolower\fP (\fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const "
.br
.ti -1c
.RI "\fBchar_type\fP \fBtoupper\fP (\fBchar_type\fP __c) const "
.br
.ti -1c
.RI "const \fBchar_type\fP * \fBtoupper\fP (\fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const "
.br
.ti -1c
.RI "\fBchar_type\fP \fBwiden\fP (char __c) const "
.br
.ti -1c
.RI "const char * \fBwiden\fP (const char *__lo, const char *__hi, \fBchar_type\fP *__to) const "
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const mask \fBalnum\fP"
.br
.ti -1c
.RI "static const mask \fBalpha\fP"
.br
.ti -1c
.RI "static const mask \fBcntrl\fP"
.br
.ti -1c
.RI "static const mask \fBdigit\fP"
.br
.ti -1c
.RI "static const mask \fBgraph\fP"
.br
.ti -1c
.RI "static \fBlocale::id\fP \fBid\fP"
.br
.ti -1c
.RI "static const mask \fBlower\fP"
.br
.ti -1c
.RI "static const mask \fBprint\fP"
.br
.ti -1c
.RI "static const mask \fBpunct\fP"
.br
.ti -1c
.RI "static const mask \fBspace\fP"
.br
.ti -1c
.RI "static const mask \fBupper\fP"
.br
.ti -1c
.RI "static const mask \fBxdigit\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual bool \fBdo_is\fP (mask __m, \fBchar_type\fP __c) const "
.br
.ti -1c
.RI "virtual const \fBchar_type\fP * \fBdo_is\fP (const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi, mask *__vec) const "
.br
.ti -1c
.RI "virtual char \fBdo_narrow\fP (\fBchar_type\fP, char __dfault) const "
.br
.ti -1c
.RI "virtual const \fBchar_type\fP * \fBdo_narrow\fP (const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi, char __dfault, char *__to) const "
.br
.ti -1c
.RI "virtual const \fBchar_type\fP * \fBdo_scan_is\fP (mask __m, const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const "
.br
.ti -1c
.RI "virtual const \fBchar_type\fP * \fBdo_scan_not\fP (mask __m, const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const "
.br
.ti -1c
.RI "virtual \fBchar_type\fP \fBdo_tolower\fP (\fBchar_type\fP __c) const "
.br
.ti -1c
.RI "virtual const \fBchar_type\fP * \fBdo_tolower\fP (\fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const "
.br
.ti -1c
.RI "virtual \fBchar_type\fP \fBdo_toupper\fP (\fBchar_type\fP __c) const "
.br
.ti -1c
.RI "virtual const \fBchar_type\fP * \fBdo_toupper\fP (\fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const "
.br
.ti -1c
.RI "virtual \fBchar_type\fP \fBdo_widen\fP (char __c) const "
.br
.ti -1c
.RI "virtual const char * \fBdo_widen\fP (const char *__lo, const char *__hi, \fBchar_type\fP *__dest) const "
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static __c_locale \fB_S_clone_c_locale\fP (__c_locale &__cloc)  throw ()"
.br
.ti -1c
.RI "static void \fB_S_create_c_locale\fP (__c_locale &__cloc, const char *__s, __c_locale __old=0)"
.br
.ti -1c
.RI "static void \fB_S_destroy_c_locale\fP (__c_locale &__cloc)"
.br
.ti -1c
.RI "static __c_locale \fB_S_get_c_locale\fP ()"
.br
.ti -1c
.RI "static const char * \fB_S_get_c_name\fP ()  throw ()"
.br
.ti -1c
.RI "static __c_locale \fB_S_lc_ctype_c_locale\fP (__c_locale __cloc, const char *__s)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _CharT>class std::ctype< _CharT >"
Primary class template ctype facet\&.
.PP
This template class defines classification n' conversion functions fo' characta sets\&. Well shiiiit, it wraps cctype functionality\&. Ctype gets used by streams fo' nuff I/O operations\&. 

This template serves up tha protected virtual functions tha pimper will gotta replace up in a thugged-out derived class or specialization ta cook up a hustlin facet\&. Da hood functions dat access dem is defined up in __ctype_abstract_base, ta allow fo' implementation flexibility\&. Right back up in yo muthafuckin ass. See ctype<wchar_t> fo' a example\&. Da functions is documented up in __ctype_abstract_base\&.
.PP
Note: implementations is provided fo' all tha protected virtual functions yo, but will likely not be useful\&. 
.PP
Definizzle at line 605 of file locale_facets\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _CharT> virtual bool \fBstd::ctype\fP< _CharT >::do_is (mask__m, \fBchar_type\fP__c) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Test char_type classification\&. This function findz a mask M fo' \fIc\fP n' compares it ta mask \fIm\fP\&.
.PP
do_is() be a hook fo' a thugged-out derived facet ta chizzle tha behavior of classifying\&. do_is() must always return tha same result fo' tha same input\&.
.PP
\fBParameters:\fP
.RS 4
\fI__c\fP Da char_type ta find tha mask of\&. 
.br
\fI__m\fP Da mask ta compare against\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
(M & __m) != 0\&. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP\&.
.SS "template<typename _CharT> virtual const \fBchar_type\fP* \fBstd::ctype\fP< _CharT >::do_is (const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi, mask *__vec) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Return a mask array\&. This function findz tha mask fo' each char_type up in tha range [lo,hi) n' successively writes it ta vec\&. vec must have as nuff elements as tha input\&.
.PP
do_is() be a hook fo' a thugged-out derived facet ta chizzle tha behavior of classifying\&. do_is() must always return tha same result fo' tha same input\&.
.PP
\fBParameters:\fP
.RS 4
\fI__lo\fP Pointa ta start of range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.br
\fI__vec\fP Pointa ta a array of mask storage\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fI__hi\fP\&. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP\&.
.SS "template<typename _CharT> virtual char \fBstd::ctype\fP< _CharT >::do_narrow (\fBchar_type\fP__c, char__dfault) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Narrow char_type ta char\&. This virtual function converts tha argument ta char rockin tha simplest reasonable transformation\&. If tha conversion fails, dfault is returned instead\&.
.PP
do_narrow() be a hook fo' a thugged-out derived facet ta chizzle tha behavior of narrowing\&. do_narrow() must always return tha same result fo' tha same input\&.
.PP
Note: dis aint what tha fuck you want fo' codepage conversions\&. Right back up in yo muthafuckin ass. See codecvt fo' that\&.
.PP
\fBParameters:\fP
.RS 4
\fI__c\fP Da char_type ta convert\&. 
.br
\fI__dfault\fP Char ta return if conversion fails\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da converted char\&. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP\&.
.PP
Referenced by std::ctype< char >::narrow()\&.
.SS "template<typename _CharT> virtual const \fBchar_type\fP* \fBstd::ctype\fP< _CharT >::do_narrow (const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi, char__dfault, char *__to) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Narrow char_type array ta char\&. This virtual function converts each char_type up in tha range [__lo,__hi) ta char rockin tha simplest reasonable transformation n' writes tha thangs up in dis biatch ta tha destination array\&. For any element up in tha input dat cannot be converted, \fI__dfault\fP is used instead\&.
.PP
do_narrow() be a hook fo' a thugged-out derived facet ta chizzle tha behavior of narrowing\&. do_narrow() must always return tha same result fo' tha same input\&.
.PP
Note: dis aint what tha fuck you want fo' codepage conversions\&. Right back up in yo muthafuckin ass. See codecvt fo' that\&.
.PP
\fBParameters:\fP
.RS 4
\fI__lo\fP Pointa ta start of range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.br
\fI__dfault\fP Char ta use if conversion fails\&. 
.br
\fI__to\fP Pointa ta tha destination array\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fI__hi\fP\&. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP\&.
.SS "template<typename _CharT> virtual const \fBchar_type\fP* \fBstd::ctype\fP< _CharT >::do_scan_is (mask__m, const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Find char_type matchin mask\&. This function searches fo' n' returns tha straight-up original gangsta char_type c up in [__lo,__hi) fo' which is(__m,c) is true\&.
.PP
do_scan_is() be a hook fo' a thugged-out derived facet ta chizzle tha behavior of match searching\&. do_is() must always return tha same result fo' tha same input\&.
.PP
\fBParameters:\fP
.RS 4
\fI__m\fP Da mask ta compare against\&. 
.br
\fI__lo\fP Pointa ta start of range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointa ta a matchin char_type if found, else \fI__hi\fP\&. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP\&.
.SS "template<typename _CharT> virtual const \fBchar_type\fP* \fBstd::ctype\fP< _CharT >::do_scan_not (mask__m, const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Find char_type not matchin mask\&. This function searches fo' n' returns a pointa ta tha straight-up original gangsta char_type c of [lo,hi) fo' which is(m,c) is false\&.
.PP
do_scan_is() be a hook fo' a thugged-out derived facet ta chizzle tha behavior of match searching\&. do_is() must always return tha same result fo' tha same input\&.
.PP
\fBParameters:\fP
.RS 4
\fI__m\fP Da mask ta compare against\&. 
.br
\fI__lo\fP Pointa ta start of range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointa ta a non-matchin char_type if found, else \fI__hi\fP\&. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP\&.
.SS "template<typename _CharT> virtual \fBchar_type\fP \fBstd::ctype\fP< _CharT >::do_tolower (\fBchar_type\fP__c) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Convert ta lowercase\&. This virtual function converts tha argument ta lowercase if possible\&. If not possible (for example, '2'), returns tha argument\&.
.PP
do_tolower() be a hook fo' a thugged-out derived facet ta chizzle tha behavior of lowercasing\&. do_tolower() must always return tha same result fo' tha same input\&.
.PP
\fBParameters:\fP
.RS 4
\fI__c\fP Da char_type ta convert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da lowercase char_type if convertible, else \fI__c\fP\&. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP\&.
.PP
Referenced by std::ctype< char >::tolower()\&.
.SS "template<typename _CharT> virtual const \fBchar_type\fP* \fBstd::ctype\fP< _CharT >::do_tolower (\fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Convert array ta lowercase\&. This virtual function converts each char_type up in tha range [__lo,__hi) ta lowercase if possible\&. Other elements remain untouched\&.
.PP
do_tolower() be a hook fo' a thugged-out derived facet ta chizzle tha behavior of lowercasing\&. do_tolower() must always return tha same result fo' tha same input\&.
.PP
\fBParameters:\fP
.RS 4
\fI__lo\fP Pointa ta start of range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fI__hi\fP\&. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP\&.
.SS "template<typename _CharT> virtual \fBchar_type\fP \fBstd::ctype\fP< _CharT >::do_toupper (\fBchar_type\fP__c) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Convert ta uppercase\&. This virtual function converts tha char_type argument ta uppercase if possible\&. If not possible (for example, '2'), returns tha argument\&.
.PP
do_toupper() be a hook fo' a thugged-out derived facet ta chizzle tha behavior of uppercasing\&. do_toupper() must always return tha same result fo' tha same input\&.
.PP
\fBParameters:\fP
.RS 4
\fI__c\fP Da char_type ta convert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da uppercase char_type if convertible, else \fI__c\fP\&. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP\&.
.PP
Referenced by std::ctype< char >::toupper()\&.
.SS "template<typename _CharT> virtual const \fBchar_type\fP* \fBstd::ctype\fP< _CharT >::do_toupper (\fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Convert array ta uppercase\&. This virtual function converts each char_type up in tha range [__lo,__hi) ta uppercase if possible\&. Other elements remain untouched\&.
.PP
do_toupper() be a hook fo' a thugged-out derived facet ta chizzle tha behavior of uppercasing\&. do_toupper() must always return tha same result fo' tha same input\&.
.PP
\fBParameters:\fP
.RS 4
\fI__lo\fP Pointa ta start of range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fI__hi\fP\&. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP\&.
.SS "template<typename _CharT> virtual \fBchar_type\fP \fBstd::ctype\fP< _CharT >::do_widen (char__c) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Widen char\&. This virtual function converts tha char ta char_type rockin tha simplest reasonable transformation\&.
.PP
do_widen() be a hook fo' a thugged-out derived facet ta chizzle tha behavior of widening\&. do_widen() must always return tha same result fo' tha same input\&.
.PP
Note: dis aint what tha fuck you want fo' codepage conversions\&. Right back up in yo muthafuckin ass. See codecvt fo' that\&.
.PP
\fBParameters:\fP
.RS 4
\fI__c\fP Da char ta convert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da converted char_type 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP\&.
.PP
Referenced by std::ctype< char >::widen()\&.
.SS "template<typename _CharT> virtual const char* \fBstd::ctype\fP< _CharT >::do_widen (const char *__lo, const char *__hi, \fBchar_type\fP *__to) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Widen char array\&. This function converts each char up in tha input ta char_type rockin tha simplest reasonable transformation\&.
.PP
do_widen() be a hook fo' a thugged-out derived facet ta chizzle tha behavior of widening\&. do_widen() must always return tha same result fo' tha same input\&.
.PP
Note: dis aint what tha fuck you want fo' codepage conversions\&. Right back up in yo muthafuckin ass. See codecvt fo' that\&.
.PP
\fBParameters:\fP
.RS 4
\fI__lo\fP Pointa ta start range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.br
\fI__to\fP Pointa ta tha destination array\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fI__hi\fP\&. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP\&.
.SS "template<typename _CharT> bool \fBstd::__ctype_abstract_base\fP< _CharT >::is (mask__m, \fBchar_type\fP__c) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Test char_type classification\&. This function findz a mask M fo' \fI__c\fP n' compares it ta mask \fI__m\fP\&. Well shiiiit, it do so by returnin tha value of ctype<char_type>::do_is()\&.
.PP
\fBParameters:\fP
.RS 4
\fI__c\fP Da char_type ta compare tha mask of\&. 
.br
\fI__m\fP Da mask ta compare against\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
(M & __m) != 0\&. 
.RE
.PP

.PP
Definizzle at line 162 of file locale_facets\&.h\&.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::sentry::sentry()\&.
.SS "template<typename _CharT> const \fBchar_type\fP* \fBstd::__ctype_abstract_base\fP< _CharT >::is (const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi, mask *__vec) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Return a mask array\&. This function findz tha mask fo' each char_type up in tha range [lo,hi) n' successively writes it ta vec\&. vec must have as nuff elements as tha char array\&. Well shiiiit, it do so by returnin tha value of ctype<char_type>::do_is()\&.
.PP
\fBParameters:\fP
.RS 4
\fI__lo\fP Pointa ta start of range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.br
\fI__vec\fP Pointa ta a array of mask storage\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fI__hi\fP\&. 
.RE
.PP

.PP
Definizzle at line 179 of file locale_facets\&.h\&.
.SS "template<typename _CharT> char \fBstd::__ctype_abstract_base\fP< _CharT >::narrow (\fBchar_type\fP__c, char__dfault) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Narrow char_type ta char\&. This function converts tha char_type ta char rockin tha simplest reasonable transformation\&. If tha conversion fails, dfault is returned instead\&. Well shiiiit, it do so by returnin ctype<char_type>::do_narrow(__c)\&.
.PP
Note: dis aint what tha fuck you want fo' codepage conversions\&. Right back up in yo muthafuckin ass. See codecvt fo' that\&.
.PP
\fBParameters:\fP
.RS 4
\fI__c\fP Da char_type ta convert\&. 
.br
\fI__dfault\fP Char ta return if conversion fails\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da converted char\&. 
.RE
.PP

.PP
Definizzle at line 324 of file locale_facets\&.h\&.
.PP
Referenced by std::time_put< _CharT, _OutIta >::put()\&.
.SS "template<typename _CharT> const \fBchar_type\fP* \fBstd::__ctype_abstract_base\fP< _CharT >::narrow (const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi, char__dfault, char *__to) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Narrow array ta char array\&. This function converts each char_type up in tha input ta char rockin tha simplest reasonable transformation n' writes tha thangs up in dis biatch ta tha destination array\&. For any char_type up in tha input dat cannot be converted, \fIdfault\fP is used instead\&. Well shiiiit, it do so by returnin ctype<char_type>::do_narrow(__lo, __hi, __dfault, __to)\&.
.PP
Note: dis aint what tha fuck you want fo' codepage conversions\&. Right back up in yo muthafuckin ass. See codecvt fo' that\&.
.PP
\fBParameters:\fP
.RS 4
\fI__lo\fP Pointa ta start of range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.br
\fI__dfault\fP Char ta use if conversion fails\&. 
.br
\fI__to\fP Pointa ta tha destination array\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fI__hi\fP\&. 
.RE
.PP

.PP
Definizzle at line 346 of file locale_facets\&.h\&.
.SS "template<typename _CharT> const \fBchar_type\fP* \fBstd::__ctype_abstract_base\fP< _CharT >::scan_is (mask__m, const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Find char_type matchin a mask\&. This function searches fo' n' returns tha straight-up original gangsta char_type c up in [lo,hi) fo' which is(m,c) is true\&. Well shiiiit, it do so by returnin ctype<char_type>::do_scan_is()\&.
.PP
\fBParameters:\fP
.RS 4
\fI__m\fP Da mask ta compare against\&. 
.br
\fI__lo\fP Pointa ta start of range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointa ta matchin char_type if found, else \fI__hi\fP\&. 
.RE
.PP

.PP
Definizzle at line 195 of file locale_facets\&.h\&.
.SS "template<typename _CharT> const \fBchar_type\fP* \fBstd::__ctype_abstract_base\fP< _CharT >::scan_not (mask__m, const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Find char_type not matchin a mask\&. This function searches fo' n' returns tha straight-up original gangsta char_type c up in [lo,hi) fo' which is(m,c) is false\&. Well shiiiit, it do so by returnin ctype<char_type>::do_scan_not()\&.
.PP
\fBParameters:\fP
.RS 4
\fI__m\fP Da mask ta compare against\&. 
.br
\fI__lo\fP Pointa ta first char up in range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointa ta non-matchin char if found, else \fI__hi\fP\&. 
.RE
.PP

.PP
Definizzle at line 211 of file locale_facets\&.h\&.
.SS "template<typename _CharT> \fBchar_type\fP \fBstd::__ctype_abstract_base\fP< _CharT >::tolower (\fBchar_type\fP__c) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Convert ta lowercase\&. This function converts tha argument ta lowercase if possible\&. If not possible (for example, '2'), returns tha argument\&. Well shiiiit, it do so by returnin ctype<char_type>::do_tolower(c)\&.
.PP
\fBParameters:\fP
.RS 4
\fI__c\fP Da char_type ta convert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da lowercase char_type if convertible, else \fI__c\fP\&. 
.RE
.PP

.PP
Definizzle at line 254 of file locale_facets\&.h\&.
.SS "template<typename _CharT> const \fBchar_type\fP* \fBstd::__ctype_abstract_base\fP< _CharT >::tolower (\fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Convert array ta lowercase\&. This function converts each char_type up in tha range [__lo,__hi) ta lowercase if possible\&. Other elements remain untouched\&. Well shiiiit, it do so by returnin ctype<char_type>:: do_tolower(__lo, __hi)\&.
.PP
\fBParameters:\fP
.RS 4
\fI__lo\fP Pointa ta start of range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fI__hi\fP\&. 
.RE
.PP

.PP
Definizzle at line 269 of file locale_facets\&.h\&.
.SS "template<typename _CharT> \fBchar_type\fP \fBstd::__ctype_abstract_base\fP< _CharT >::toupper (\fBchar_type\fP__c) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Convert ta uppercase\&. This function converts tha argument ta uppercase if possible\&. If not possible (for example, '2'), returns tha argument\&. Well shiiiit, it do so by returnin ctype<char_type>::do_toupper()\&.
.PP
\fBParameters:\fP
.RS 4
\fI__c\fP Da char_type ta convert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da uppercase char_type if convertible, else \fI__c\fP\&. 
.RE
.PP

.PP
Definizzle at line 225 of file locale_facets\&.h\&.
.SS "template<typename _CharT> const \fBchar_type\fP* \fBstd::__ctype_abstract_base\fP< _CharT >::toupper (\fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Convert array ta uppercase\&. This function converts each char_type up in tha range [lo,hi) ta uppercase if possible\&. Other elements remain untouched\&. Well shiiiit, it do so by returnin ctype<char_type>:: do_toupper(lo, hi)\&.
.PP
\fBParameters:\fP
.RS 4
\fI__lo\fP Pointa ta start of range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fI__hi\fP\&. 
.RE
.PP

.PP
Definizzle at line 240 of file locale_facets\&.h\&.
.SS "template<typename _CharT> \fBchar_type\fP \fBstd::__ctype_abstract_base\fP< _CharT >::widen (char__c) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Widen char ta char_type\&. This function converts tha char argument ta char_type rockin tha simplest reasonable transformation\&. Well shiiiit, it do so by returnin ctype<char_type>::do_widen(c)\&.
.PP
Note: dis aint what tha fuck you want fo' codepage conversions\&. Right back up in yo muthafuckin ass. See codecvt fo' that\&.
.PP
\fBParameters:\fP
.RS 4
\fI__c\fP Da char ta convert\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da converted char_type\&. 
.RE
.PP

.PP
Definizzle at line 286 of file locale_facets\&.h\&.
.PP
Referenced by std::money_get< _CharT, _InIta >::do_get(), std::time_put< _CharT, _OutIta >::do_put(), std::money_put< _CharT, _OutIta >::do_put(), std::tr2::operator<<(), n' std::operator<<()\&.
.SS "template<typename _CharT> const char* \fBstd::__ctype_abstract_base\fP< _CharT >::widen (const char *__lo, const char *__hi, \fBchar_type\fP *__to) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Widen array ta char_type\&. This function converts each char up in tha input ta char_type rockin tha simplest reasonable transformation\&. Well shiiiit, it do so by returnin ctype<char_type>::do_widen(c)\&.
.PP
Note: dis aint what tha fuck you want fo' codepage conversions\&. Right back up in yo muthafuckin ass. See codecvt fo' that\&.
.PP
\fBParameters:\fP
.RS 4
\fI__lo\fP Pointa ta start of range\&. 
.br
\fI__hi\fP Pointa ta end of range\&. 
.br
\fI__to\fP Pointa ta tha destination array\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fI__hi\fP\&. 
.RE
.PP

.PP
Definizzle at line 305 of file locale_facets\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "template<typename _CharT> \fBlocale::id\fP \fBstd::ctype\fP< _CharT >::id\fC [static]\fP"

.PP
Da facet id fo' ctype<char_type> 
.PP
Definizzle at line 613 of file locale_facets\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
