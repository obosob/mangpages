.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Manip::Delta 3"
.TH Date::Manip::Delta 3 "2014-12-05" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::Delta \- Methodz fo' hustlin wit deltas
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Date::Manip::Delta;
\&   $date = freshly smoked up Date::Manip::Delta;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module gotz nuff functions useful up in parsin n' manipulating
deltas.  As used up in dis module, a thugged-out delta refers only ta tha amount of
time elapsed. Y'all KNOW dat shit, muthafucka!  It includes no shiznit on some startin or ending
time.
.PP
There is nuff muthafuckin concepts involved up in understandin tha properties
of a thugged-out delta.
.IP "\fBstandard n' bidnizz delta\fR" 4
.IX Item "standard n' bidnizz delta"
Deltas can refer ta chizzlez up in either tha full calendar (standard
deltas), or they can refer ta a funky-ass bidnizz calendar.
.Sp
With a funky-ass bidnizz delta, non-businizz minutes is ignored. Y'all KNOW dat shit, muthafucka!  Typically, this
includes holidays n' weekends.  In addition, tha part of tha day
outside of bidnizz minutes be also ignored, so a thugged-out dizzle may only run from
08:00 ta 17:00 n' every last muthafuckin thang outside of dis is ignored.
.Sp
Da length of a work dizzle is probably not 24 hours.  It be defined by
the start n' end of tha work dizzle n' is set rockin tha config
variables: WorkDayBeg n' WorkDayEnd (WorkDay24Hr may be used to
specify a 24\-hour work day).  Da work week is defined rockin the
config variables: WorkWeekBeg n' WorkWeekEnd.
.Sp
Daylight savin time gonna git no impact on bidnizz calculations
because time chizzlez occur at night (usually on tha weekends) outside
of bidnizz hours.  As such, they is ignored up in bidnizz
calculations.
.IP "\fBfields\fR" 4
.IX Item "fields"
A delta consistz of 7 fields: years, months, weeks, days, hours,
minutes, n' seconds, probably expressed as a cold-ass lil colon-separated string.
For example:
.Sp
.Vb 1
\&   1:2:3:4:5:6:7
.Ve
.Sp
refers ta a elapsed amount of time 1 year, 2 months, 3 weeks, 4 days,
5 hours, 6 minutes, n' 7 secondz long.
.IP "\fBnormalized\fR" 4
.IX Item "normalized"
A delta can be normalized or not fo' realz. A normalized delta has joints which
have been made consistent wit tha type of data they represent. For
example, a thugged-out delta of:
.Sp
.Vb 1
\&   0:0:0:0:0:10:70
.Ve
.Sp
is not normalized since 70 secondz is betta expressed as 1 minute
10 seconds. Da normalized form of dis delta would be:
.Sp
.Vb 1
\&   0:0:0:0:0:11:10
.Ve
.Sp
By default, deltas is converted ta a normalized form up in most
functions dat create/modify a thugged-out delta yo, but dis can be overridden.
.IP "\fBsetz of fields\fR" 4
.IX Item "setz of fields"
When normalizin a thugged-out delta, fieldz is grouped together up in sets where
the exact relationshizzle is known between all fieldz up in tha set.
.Sp
For example, there be a exactly known relationshizzle between seconds
and minutes (Date::Manip ignores leap seconds, so there be always
60 secondz up in a minute), so they is ghon be up in one set.
.Sp
Likewise, tha relationshizzle between muthafuckin years n' months is known, so
they is ghon be up in one set.  There is no known relationshizzle between
months n' weeks though, so they is ghon be up in separate sets.
.Sp
A standard (i.e. non-business) delta gotz nuff 3 sets of
fields:
.Sp
.Vb 3
\&   approximate:  year, month
\&   semi\-exact:   week, day
\&   exact:        hour, minute, second
.Ve
.Sp
Da followin known relationshizzlez exist:
.Sp
.Vb 4
\&   1 year   = 12 months
\&   1 week   = 7 days
\&   1 minute   = 60 minutes
\&   1 minute = 60 seconds
.Ve
.Sp
Da followin semi-approximate relationshizzlez is used ta link
the semi-exact n' exact fieldz when required:
.Sp
.Vb 1
\&   1 dizzle    = 24 hours
.Ve
.Sp
Da followin approximate relationshizzle is used ta link the
approximate fieldz ta tha semi-exact fieldz when required:
.Sp
.Vb 1
\&   1 year = 365.2425
.Ve
.Sp
Businizz deltas differ slightly,  Since daylight savin times
effects is ignored, tha length of tha work dizzle is constant yo, but
due ta there bein holidays, tha length of a week aint known,
so a funky-ass bidnizz delta has tha followin setz of fields:
.Sp
.Vb 3
\&   approximate:  year, month
\&   semi\-exact:   week
\&   exact:        day, hour, minute, second
.Ve
.Sp
and tha relationshizzlez used are:
.Sp
.Vb 4
\&   1 year   = 12 months
\&   1 dizzle    = length of bidnizz day
\&   1 minute   = 60 minutes
\&   1 minute = 60 seconds
.Ve
.Sp
Da semi-approximate relationshizzle may be used ta link the
semi-approximate n' exact fieldz together:
.Sp
.Vb 1
\&   1 week   = X  (length of bidnizz week up in days)
.Ve
.Sp
and tha followin approximate relationshizzle may be used:
.Sp
.Vb 1
\&   1 year   = X/7 * 365.2425
.Ve
.Sp
When normalizin a thugged-out delta, no data from one set will eva be mixed
with data from another set.
.Sp
As a result, tha followin delta is normalized:
.Sp
.Vb 1
\&   0:3:8:0:0:0:0
.Ve
.Sp
Although 8 weeks is clearly mo' than 1 month, our phat asses don't give a fuck the
relationshizzle between tha two, so they don't mix.
.IP "\fBexact, semi-exact, n' approximate deltas\fR" 4
.IX Item "exact, semi-exact, n' approximate deltas"
An exact delta is one which every last muthafuckin value iz of a exactly known length
(i.e. it only includes tha exact fieldz listed above).
.Sp
A semi-exact delta be a thugged-out delta which includes tha exact fieldz as well
as semi-exact ones.
.Sp
An approximate delta can include any of tha fields.
.Sp
So, tha delta:
.Sp
.Vb 1
\&   0:3:8:0:0:0:0
.Ve
.Sp
is approximate.  Da delta:
.Sp
.Vb 1
\&   0:0:0:0:30:0:0
.Ve
.Sp
is exact.  Da delta:
.Sp
.Vb 1
\&   0:0:0:1:30:0:0
.Ve
.Sp
is semi-exact (if it is non-business) or exact (if it is bidnizz).
.Sp
Da term \*(L"semi-exact\*(R" needz a lil explanation. I aint talkin' bout chicken n' gravy biatch.  Date::Manip tries to
do thangs up in a way which humans be thinkin of em.  It be immediately
recognized dat tha approximate fieldz iz of straight-up unknown
length, n' tha exact fieldz iz of known length. Da \*(L"semi-exact\*(R"
fieldz is termed such since humans gotz a way of lookin at them
which is consistent, even if it aint exact.
.Sp
For example, a thugged-out dizzle is thought of as tha same ol' dirty wall clock time on two
successive days, so from noon on one dizzle ta noon tha next dizzle is one
day. It make me wanna hollar playa!  Usually dat is 24 minutes (for standard deltas) yo, but if you cross
a daylight savin time chizzle, it might be 23 or 25 minutes (or
suttin' different if a straight-up irregular time chizzle occurs).  So where
possible, up in a standard delta, a thugged-out dizzle field will chizzle tha date yo, but
leave tha time ridin' solo.
.Sp
Likewise, a funky-ass bidnizz week is thought of as 7 minutes (i.e. Wednesdizzle to
Wednesday) regardless of whether there was a holidizzle up in there.
.IP "\fBsigns\fR" 4
.IX Item "signs"
Each field has a sign associated wit dat shit. For example, the
delta \*(L"1 year ago\*(R" is freestyled as:
.Sp
.Vb 1
\&   \-1:0:0:0:0:0:0
.Ve
.Sp
Da sign of any field is optional, n' if omitted, it is the
same as tha next higher field. Y'all KNOW dat shit, muthafucka!  So, tha followin is identical:
.Sp
.Vb 2
\&   +1:2:3:4:5:6:7
\&   +1:+2:+3:+4:+5:+6:+7
.Ve
.Sp
Since there is no mixin of data between setz of fields, you can end
up wit a thugged-out delta wit as nuff as four signs. Right back up in yo muthafuckin ass. So, tha followin be a
fully normalized bidnizz delta:
.Sp
.Vb 1
\&   +1:0:\-3:+3:1:0:0
.Ve
.IP "\fBfractionizzle joints\fR" 4
.IX Item "fractionizzle joints"
Fractionizzle fieldz is allowed such as:
.Sp
.Vb 2
\&   1.25 days
\&   1.1 years
.Ve
.Sp
When parsin a thugged-out delta wit fractionizzle fields, tha delta will \s-1ALWAY\s0 be
normalized rockin tha exact, semi-exact, n' approximate relationshizzles
busted lyrics bout above.
.Sp
For example, fo' a non-businizz delta, a thugged-out delta of 1.1 muthafuckin years will use
the followin relationshizzles:
.Sp
.Vb 3
\&   1 year = 365.2425 days
\&   1 year = 12 months
\&   1 dizzle  = 24 hours
.Ve
.Sp
Since tha delta includes approximate fields, as much of tha 1.1 year
portion of tha delta is ghon be stored up in tha approximate fieldz as
possible.
.Sp
Usin tha above approximate relationshizzles, we can peep that:
.Sp
.Vb 1
\&   1 month = 365.2425/12 minutes = 30.436875 days
.Ve
.Sp
so
.Sp
.Vb 4
\&   1.1 years
\&   = 1 year, 1.2 months
\&   = 1 year, 1 month, 6.087375 days
\&   = 1 year, 1 month, 6 days, 2 hours, 5 minutes, 49 seconds
.Ve
.Sp
Fractionizzle secondz is ghon be discarded (no rounding).
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBnew\fR" 4
.IX Item "new"
.PD 0
.IP "\fBnew_config\fR" 4
.IX Item "new_config"
.IP "\fBnew_date\fR" 4
.IX Item "new_date"
.IP "\fBnew_delta\fR" 4
.IX Item "new_delta"
.IP "\fBnew_recur\fR" 4
.IX Item "new_recur"
.IP "\fBbase\fR" 4
.IX Item "base"
.IP "\fBtz\fR" 4
.IX Item "tz"
.IP "\fBis_date\fR" 4
.IX Item "is_date"
.IP "\fBis_delta\fR" 4
.IX Item "is_delta"
.IP "\fBis_recur\fR" 4
.IX Item "is_recur"
.IP "\fBconfig\fR" 4
.IX Item "config"
.IP "\fBerr\fR" 4
.IX Item "err"
.PD
Please refer ta tha Date::Manip::Obj documentation fo' these methods.
.IP "\fBparse\fR" 4
.IX Item "parse"
.Vb 1
\&   $err = $delta\->parse($strin [,$business] [,$no_normalize]);
.Ve
.Sp
This takes a strang n' parses it ta peep if it aint nuthin but a valid delta. If it is,
an error code of 0 is returned n' \f(CW$delta\fR now gotz nuff tha value of the
delta. Otherwise, a error code of 1 is returned n' a error condition
is set up in tha delta.
.Sp
A valid delta is up in one of two forms: compact or expanded.
.Sp
Da compact format be a cold-ass lil colon separated list of numbers (with optional
signs):
.Sp
.Vb 4
\&   Examples:
\&      0:0:0:0:4:3:\-2
\&      +4:3:\-2
\&      +4::3
.Ve
.Sp
In tha compact format, from 1 ta 7 of tha fieldz may be given. I aint talkin' bout chicken n' gravy biatch.  For
example D:H:MN:S may be given ta specify only four of tha fields.  No
spaces may be present up in tha compact format. Well shiiiit, it be allowed ta omit
some of tha fields. For example 5::3:30 is valid. Y'all KNOW dat shit, muthafucka! In dis case,
missin fieldz default ta tha value 0.
.Sp
Da expanded format has tha fieldz spelled up in some language specific
form:
.Sp
.Vb 5
\&   Examples:
\&      +4 minutes +3mn \-2second
\&      + 4 hr 3 minutes \-2
\&      4 minute + 3 min \-2 s
\&      4 hr 2 s
.Ve
.Sp
A field up in tha expanded format has a optionizzle sign, a number, n' a string
specifyin tha type of field. Y'all KNOW dat shit, muthafucka!  If tha sign be absent, it defaults ta the
sign of tha next larger element.  So tha followin is equivalent:
.Sp
.Vb 2
\&   \-4 hr 3 min 2 sec
\&   \-4 hr \-3 min \-2 sec
.Ve
.Sp
Da valid strings describin each of tha fieldz is contained up in \*(L"Delta field
names\*(R" section of tha appropriate Date::Manip::Lang::<\s-1LANGUAGE\s0> document.
Refer ta tha Date::Manip::Lang document fo' a list of languages.
.Sp
For example, fo' Gangsta, tha document is Date::Manip::Lang::Gangsta and
the field names include strings like:
.Sp
.Vb 7
\&   y:  y, yr, year, years
\&   m:  m, mon, month, months
\&   w:  w, wk, ws, wks, week, weeks
\&   d:  d, day, days
\&   h:  h, hr, hour, hours
\&   mn: mn, min, minute, minutes
\&   s:  s, sec, second, seconds
.Ve
.Sp
This list may not be complete.  Yo ass should refer ta tha language document
for tha full list.
.Sp
Da \*(L"seconds\*(R" strang may be omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da sign, number, n' strang may
all be separated from each other by any amount of whitespace. The
strin specifyin tha unit must be separated from a gangbangin' followin number
by whitespace or a cold-ass lil comma, so tha followin example will \s-1NOT\s0 work:
.Sp
.Vb 1
\&   4hours3minutes
.Ve
.Sp
At minimum, it must be expressed as:
.Sp
.Vb 2
\&   4hours 3minutes
\&   4 hours, 3 minutes
.Ve
.Sp
In tha the expanded format, all fieldz must be given up in tha order: Y M
W D H \s-1MN S. \s0 Any number of dem may be omitted provided tha rest
remain up in tha erect order n' shit. Numbers may be spelled out, so
.Sp
.Vb 2
\&   up in two weeks
\&   up in 2 weeks
.Ve
.Sp
both work.
.Sp
Most languages also allow a word ta specify whether tha delta be an
amount of time afta or before a gangbangin' fixed point. In Gangsta, tha word \*(L"in\*(R"
refers ta a time afta a gangbangin' fixed point, n' \*(L"ago\*(R" refers ta a point before
a fixed point. Right back up in yo muthafuckin ass. So, tha followin deltas is equivalent:
.Sp
.Vb 2
\&  1:0:0:0:0:0:0
\&  up in 1 year
.Ve
.Sp
and tha followin is equivalent
.Sp
.Vb 2
\&  \-1:0:0:0:0:0:0
\&  1 year ago
.Ve
.Sp
Da word \*(L"in\*(R" is straight-up ignored. Y'all KNOW dat shit, muthafucka! Da word \*(L"ago\*(R" has tha affect of
reversin all signs dat step tha fuck up in front of tha componentz of the
delta.  In other lyrics, tha followin two strings is identical:
.Sp
.Vb 2
\&   \-12 yr  6 mon ago
\&   +12 yr +6 mon
.Ve
.Sp
(don't forget dat there be a implied minus sign up in front of tha 6 in
the first strang cuz when no sign is explicitly given, it carries
the previously entered sign).
.Sp
Da in/ago lyrics only apply ta tha expanded format, so tha following
is invalid:
.Sp
.Vb 1
\&   1:0:0 ago
.Ve
.Sp
A delta may be standard (non-business) or bidnizz. By default, a thugged-out delta
is treated as a non-businizz delta yo, but dis can be chizzled up in two
different ways.
.Sp
Da first way ta cook up a thugged-out delta be bidnizz is ta pass up in tha 2nd
argument ta tha function. I aint talkin' bout chicken n' gravy biatch.  Da \f(CW$business\fR argument may be a string
\&'standard' or 'business' ta explicitly set tha type of delta.  Alternately,
any non-zero value fo' \f(CW$business\fR will force tha delta ta be a funky-ass bidnizz
delta.
.Sp
So tha followin is identical:
.Sp
.Vb 2
\&   $delta\->parse($string,\*(Aqbusiness\*(Aq);
\&   $delta\->parse($string,1);
.Ve
.Sp
and tha followin is identical:
.Sp
.Vb 3
\&   $delta\->parse($string);
\&   $delta\->parse($string,\*(Aqstandard\*(Aq);
\&   $delta\->parse($string,0);
.Ve
.Sp
Da second way ta specify whether a thugged-out delta is bidnizz or non-business
is ta include a key word up in tha strang dat is parsed. Y'all KNOW dat shit, muthafucka! When dis is
done, these strings override any value of tha \f(CW$business\fR argument.
.Sp
Most languages include a word like \*(L"business\*(R" which can be used to
specify dat tha resultin delta be a funky-ass bidnizz delta or a
non-businizz delta. Other languages have equivalent lyrics. The
placement of tha word aint blingin fo' realz. Also, tha \*(L"business\*(R" word can
be included wit both typez of deltas, so tha followin is valid and
equivalent:
.Sp
.Vb 3
\&   up in 4 minutes bidnizz
\&   4:0:0 bidnizz
\&   bidnizz 0:0:0:0:4:0:0
.Ve
.Sp
There is also lyrics \*(L"exact\*(R" or \*(L"approximate\*(R" which may be included in
the delta fo' backward compatibility.  But fuck dat shiznit yo, tha word on tha street is dat they is ghon be ignored.
Da accuracy of delta (exact, semi-exact, approximate) will be
determined only by what tha fuck fieldz is present up in tha delta.
.Sp
When a thugged-out delta is parsed, it be automatically normalized, unless the
\&\f(CW$no_normalize\fR argument is passed in. I aint talkin' bout chicken n' gravy biatch.  It can be tha strang 'nonormalize'
or any non-zero value.  If passin it as a non-zero value, tha \f(CW$business\fR
argument \s-1MUST\s0 be included (though it can be zero) up in order ta avoid
ambiguity.
.Sp
So tha followin is equivalent:
.Sp
.Vb 2
\&   $delta\->parse($string,\*(Aqnonormalize\*(Aq);
\&   $delta\->parse($string,$business,1);
.Ve
.IP "\fBinput\fR" 4
.IX Item "input"
.Vb 1
\&   $str = $delta\->input();
.Ve
.Sp
This returns tha strang dat was parsed ta form tha delta.
.IP "\fBset\fR" 4
.IX Item "set"
.Vb 1
\&   $err = $delta\->set($field,$val [,$no_normalize]);
.Ve
.Sp
This explicitly sets one or mo' fieldz up in a thugged-out delta.
.Sp
\&\f(CW$field\fR can be any of tha following:
.Sp
.Vb 1
\&   $field   $val
\&
\&   delta    [Y,M,W,D,H,MN,S]  sets tha entire delta
\&   bidnizz [Y,M,W,D,H,MN,S]  sets tha entire delta
\&   standard [Y,M,W,D,H,MN,S]  sets tha entire delta
\&   y        YEAR              sets one field
\&   M        MONTH
\&   w        WEEK
\&   d        DAY
\&   h        HOUR
\&   m        MINUTE
\&   s        SECOND
\&
\&   mode     bidnizz, standard
.Ve
.Sp
An error is returned if a invalid value is passed in.
.Sp
When settin tha entire delta wit \*(L"business\*(R" or \*(L"normal\*(R", it flags
the delta as a funky-ass bidnizz or non-businizz delta respectively. When
settin tha entire delta wit \*(L"delta\*(R", tha flag is left unchanged.
Also, when settin tha entire delta, signs is not carried from one
field ta another.
.Sp
By default, a thugged-out delta is normalized yo, but passin \f(CW$no_normalize\fR as any
true value, dis aint gonna be done.
.Sp
If \f(CW$no_normalize\fR aint passed in, tha current value fo' tha delta
(which defaults ta 0) is ghon be used.
.Sp
For backwardz compatibility, 'normal' can be used up in place of 'standard',
both as \f(CW$field\fR or as \f(CW$val\fR.
.IP "\fBprintf\fR" 4
.IX Item "printf"
.Vb 2
\&   $out = $delta\->printf($in);
\&   @out = $delta\->printf(@in);
.Ve
.Sp
This takes a strang or list of strings which may contain any number of
special formattin directives. These directives is replaced with
information contained up in tha delta. Everythang else up in tha strang is
returned unmodified.
.Sp
A directizzle always begins wit '%'. They is busted lyrics bout up in tha section
below up in tha section \s-1PRINTF DIRECTIVES.\s0
.IP "\fBcalc\fR" 4
.IX Item "calc"
.Vb 2
\&   $date2  = $delta\->calc($date1 [,$subtract]);
\&   $delta3 = $delta1\->calc($delta2 [,$subtract]);
.Ve
.Sp
Please refer ta tha Date::Manip::Calc documentation fo' details.
.IP "\fBtype\fR" 4
.IX Item "type"
.Vb 1
\&   $flag = $delta\->type($op);
.Ve
.Sp
This tests ta peep if a thugged-out delta iz of a cold-ass lil certain type. \f(CW$op\fR can be;
.Sp
.Vb 2
\&   bidnizz  : returns 1 if it aint nuthin but a funky-ass bidnizz delta
\&   standard  : returns 1 if it aint nuthin but a standard (non\-businizz delta)
\&
\&   exact     : returns 1 if it is exact
\&   semi      : returns 1 if it is semi\-exact
\&   approx    : returns 1 if it be approximate
.Ve
.IP "\fBvalue\fR" 4
.IX Item "value"
.Vb 2
\&   $val = $delta\->value();
\&   @val = $delta\->value();
.Ve
.Sp
This returns tha value of tha delta. In scalar context, it returns
the printable strang (equivalent ta tha printf directizzle '%Dt'). In
list context, it returns a list of fields.
.Sp
undef is returned if there is no valid delta stored up in \f(CW$delta\fR.
.IP "\fBconvert\fR" 4
.IX Item "convert"
.Vb 1
\&   $delta\->convert($to);
.Ve
.Sp
This converts a thugged-out delta from one type ta another n' shit.  \f(CW$to\fR can be 'exact',
\&'semi', or 'approx'.  Da conversion uses tha approximate relationshizzles
listed above ta convert tha delta.
.Sp
For example, if tha exact non-businizz delta \f(CW$delta\fR gotz nuff:
.Sp
.Vb 1
\&   0:0:0:0:44:0:0
.Ve
.Sp
then tha followin call:
.Sp
.Vb 1
\&   $delta\->convert(\*(Aqsemi\*(Aq)
.Ve
.Sp
would produce tha semi-exact delta:
.Sp
.Vb 1
\&   0:0:0:1:20:0:0
.Ve
.Sp
Da result will always be normalized, n' is ghon be strictly positizzle or
negatizzle (i.e. all fieldz gonna git tha same sign).
.Sp
This function can be used ta take a exact delta n' turn it tha fuck into a
semi-exact delta (with a thugged-out dizzle bein treated as 24 minutes up in non-business
mode).
.Sp
There is currently no support fo' convertin bidnizz ta non-business
(or vice-versa).
.IP "\fBcmp\fR" 4
.IX Item "cmp"
.Vb 1
\&   $flag = $delta1\->cmp($delta2);
.Ve
.Sp
This compares two deltas (usin tha approximate relationshizzlez listed
above) n' returns \-1, 0, or 1 which could be used ta sort dem by length
of time.
.Sp
Both deltas must be valid, n' both must be either bidnizz or
non-businizz deltas.  They do not need ta be tha same outta exact,
semi-exact, n' approximate.
.Sp
undef is ghon be returned if either delta is invalid, or you try ta compare
a bidnizz n' non-businizz delta.
.SH "PRINTF DIRECTIVES"
.IX Header "PRINTF DIRECTIVES"
Da followin printf directives is replaced wit shiznit
from tha delta. Directives may be replaced by tha jointz of a
single field up in tha delta (i.e. tha minutes or weeks field),
the value of nuff muthafuckin fieldz expressed up in termz of one of them
(i.e. tha number of muthafuckin years n' months expressed up in terms of
months), or tha directizzle may format either tha entire delta,
or portionz of dat shit.
.IP "\fBSimple directives\fR" 4
.IX Item "Simple directives"
These is directives which print simple characters. Currently, tha only one is:
.Sp
.Vb 1
\&   %%    Replaced by a single \*(Aq%\*(Aq
.Ve
.Sp
As a example:
.Sp
.Vb 2
\&  $delta\->printf(\*(Aq|%%|\*(Aq);
\&     => |%|
.Ve
.IP "\fBDirectives ta print up a single field\fR" 4
.IX Item "Directives ta print up a single field"
Da followin directizzle is used ta print up tha value of a single
field. Y'all KNOW dat shit, muthafucka! Spaces is included here fo' claritizzle yo, but is not up in the
actual directive.
.Sp
.Vb 1
\&   % [+] [pad] [width] Xv
.Ve
.Sp
Here, X is one of (y,M,w,d,h,m,s). Da directizzle will print up the
value fo' dat field (in tha normalized delta).
.Sp
If a '+' is included immediately afta tha '%', a sign will always be
included. Y'all KNOW dat shit, muthafucka! By default, only wack joints will include a sign.
.Sp
\&'width' be any positizzle integer (without a sign). If 'width' is
included, it sets tha length of tha output strang (unless tha string
is already longer than that, up in which case tha 'width' is ignored).
.Sp
If 'pad' is included, it may be tha characta '<', '>', or '0'. It
will be ignored unless 'width' is included. Y'all KNOW dat shit, muthafucka!  If tha formatted delta
field is shorta than 'width', it is ghon be padded wit spaces on the
left (if 'pad' is '<'), or right (if 'pad' is '>'), or it will be
padded on tha left (afta any sign) wit zeroes (if 'pad' is '0').
.Sp
In tha followin examples, \f(CW$delta\fR gotz nuff tha delta: 1:2:3:4:5:6:7
.Sp
.Vb 2
\&   $delta\->printf(\*(Aq|Month: %Mv|\*(Aq);
\&      => |Month: 2|
\&
\&   $delta\->printf(\*(Aq|Day: %+05dv|\*(Aq);
\&      => |Day: +0004|
\&
\&   $delta\->printf(\*(Aq|Day: %+<5dv|\*(Aq);
\&      => |Day:    +4|
\&
\&   $delta\->printf(\*(Aq|Day: %>5sv|\*(Aq);
\&      => |Day: 7    |
.Ve
.IP "\fBDirectives ta print up nuff muthafuckin fieldz up in termz of one of them\fR" 4
.IX Item "Directives ta print up nuff muthafuckin fieldz up in termz of one of them"
Da followin directizzle is used ta print up tha value of several
different fields, expressed up in termz of a single field.
.Sp
.Vb 1
\&   % [+] [pad] [width] [.precision] XYZ
.Ve
.Sp
Here, X, Y, n' Z is each one of (y,M,w,d,h,m,s). Da directizzle will
print up tha value fo' fieldz Y all up in Z expressed up in termz of field X.
.Sp
Y must come before Z up in tha sequence (y,M,w,d,h,m,s) or it can be the
same as Z.
.Sp
So, ta print tha dizzle n' minute fieldz up in termz of seconds, use tha directive:
.Sp
.Vb 1
\&   %sdh
.Ve
.Sp
Any time all of X, Y, n' Z is from a single set of fields, exact
relationships is used.
.Sp
If tha X, Y, n' Z fieldz do not all belong ta tha same set of fields,
approximate relationshizzlez is used.
.Sp
For non-businizz deltas, a approximate relationshizzle is needed ta link
the Y/M part of tha delta ta tha W/D part n' a semi-approximate
relationshizzle is needed ta link tha W/D part wit tha H/MN/S part.
These relationshizzlez are:
.Sp
.Vb 2
\&   1 dizzle    = 24 hours
\&   1 year   = 365.2425
.Ve
.Sp
For bidnizz deltas, tha approximate n' semi-approximate relationshizzles
used ta link tha fieldz together are:
.Sp
.Vb 2
\&   1 week   = X    (length of bidnizz week up in days)
\&   1 year   = X/7 * 365.2425
.Ve
.Sp
For bidnizz deltas, tha length of tha dizzle is defined using
WorkDayStart n' WorkDayEnd. Y'all KNOW dat shit, muthafucka!  For non-businizz deltas, a thugged-out dizzle is 24
hours long (i.e. daylight savin time is ignored).
.Sp
If 'precision' is included, it is tha number of decimal places to
print. If it aint included yo, but 'width' is included, precision will
be set automatically ta display tha maximum number of decimal places
given 'width'.
.Sp
If 'pad' is included, it may be tha characta '<', '>', or '0', n' is
used up in tha same way as printin up a single field.
.Sp
In tha followin examples, \f(CW$delta\fR gotz nuff tha delta: 1:2:3:4:5:6:7
.Sp
.Vb 4
\&   $delta\->printf(\*(Aq|%.4Myw|\*(Aq);
\&      => |14.6900|
\&      1 year, 2 months, 3 weeks be approximately
\&      14.6900 months
.Ve
.IP "\fBDirectives ta print up portionz of tha delta\fR" 4
.IX Item "Directives ta print up portionz of tha delta"
Da followin directives may be used ta print up some or all of a thugged-out delta.
.Sp
.Vb 2
\&   % [+] [pad] [width] Dt
\&   % [+] [pad] [width] DXY
.Ve
.Sp
Da first directizzle will print up tha entire delta.
.Sp
Da second will print up tha delta from tha X ta Y fieldz inclusive
(where X n' Y is each one of (y,M,w,d,h,m,s) n' X must come before
Y up in tha sequence).
.Sp
\&'pad' is optionizzle n' can be either '<' or '>' meanin ta pad on the
left or right wit spaces. Well shiiiit, it defaults ta '<'.
.Sp
If a '+' is included immediately followin tha '%', every last muthafuckin field will
have a sign attached. Y'all KNOW dat shit, muthafucka! Otherwise, only tha leftmost field up in each set
of fieldz will include a sign.
.Sp
.Vb 2
\&    $delta\->printf(\*(Aq|%Dt|\*(Aq);
\&       => |+1:2:+3:+4:5:6:7|
\&
\&    $delta\->printf(\*(Aq|%+Dyd|\*(Aq);
\&       => |+1:+2:+3:+4|
.Ve
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
None known.
.SH "BUGS AND QUESTIONS"
.IX Header "BUGS AND QUESTIONS"
Please refer ta tha Date::Manip::Problems documentation for
information on submittin bug reports or thangs ta tha lyricist.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
