.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Parser 3"
.TH Pod::Parser 3 "2013-06-01" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Parser \- base class fo' bustin POD filtas n' translators
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Pod::Parser;
\&
\&    package MyParser;
\&    @ISA = qw(Pod::Parser);
\&
\&    sub command { 
\&        mah ($parser, $command, $paragraph, $line_num) = @_;
\&        ## Interpret tha command n' its text; sample actions might be:
\&        if ($command eq \*(Aqhead1\*(Aq) { ... }
\&        elsif ($command eq \*(Aqhead2\*(Aq) { ... }
\&        ## ... other commandz n' they actions
\&        mah $out_fh = $parser\->output_handle();
\&        mah $expansion = $parser\->interpolate($paragraph, $line_num);
\&        print $out_fh $expansion;
\&    }
\&
\&    sub verbatim { 
\&        mah ($parser, $paragraph, $line_num) = @_;
\&        ## Format verbatim paragraph; sample actions might be:
\&        mah $out_fh = $parser\->output_handle();
\&        print $out_fh $paragraph;
\&    }
\&
\&    sub textblock { 
\&        mah ($parser, $paragraph, $line_num) = @_;
\&        ## Translate/Format dis block of text; sample actions might be:
\&        mah $out_fh = $parser\->output_handle();
\&        mah $expansion = $parser\->interpolate($paragraph, $line_num);
\&        print $out_fh $expansion;
\&    }
\&
\&    sub interior_sequence { 
\&        mah ($parser, $seq_command, $seq_argument) = @_;
\&        ## Expand a interior sequence; sample actions might be:
\&        return "*$seq_argument*"     if ($seq_command eq \*(AqB\*(Aq);
\&        return "\`$seq_argument\*(Aq"     if ($seq_command eq \*(AqC\*(Aq);
\&        return "_${seq_argument}_\*(Aq"  if ($seq_command eq \*(AqI\*(Aq);
\&        ## ... other sequence commandz n' they resultin text
\&    }
\&
\&    package main;
\&
\&    ## Smoke a parser object n' have it parse file whose name was
\&    ## given on tha command\-line (use STDIN if no filez was given).
\&    $parser = freshly smoked up MyParser();
\&    $parser\->parse_from_filehandle(\e*STDIN)  if (@ARGV == 0);
\&    fo' (@ARGV) { $parser\->parse_from_file($_); }
.Ve
.SH "REQUIRES"
.IX Header "REQUIRES"
perl5.005, Pod::InputObjects, Exporter, Symbol, Carp
.SH "EXPORTS"
.IX Header "EXPORTS"
Nothing.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBPod::Parser\fR be a funky-ass base class fo' bustin \s-1POD\s0 filtas n' translators.
It handlez most of tha effort involved wit parsin tha \s-1POD\s0 sections
from a input stream, leavin subclasses free ta be concerned only with
performin tha actual translation of text.
.PP
\&\fBPod::Parser\fR parses PODs, n' make method calls ta handle tha various
componentz of tha \s-1POD.\s0 Subclassez of \fBPod::Parser\fR override these methods
to translate tha \s-1POD\s0 tha fuck into whatever output format they desire.
.PP
Note: This module is considered as legacy; modern Perl releases (5.18 and
higher) is goin ta remove Pod::Parser from core n' use Pod::Simple
for all thangs \s-1POD.\s0
.SH "QUICK OVERVIEW"
.IX Header "QUICK OVERVIEW"
To create a \s-1POD\s0 filta fo' translatin \s-1POD\s0 documentation tha fuck into some other
format, you create a subclass of \fBPod::Parser\fR which typically overrides
just tha base class implementation fo' tha followin methods:
.IP "\(bu" 2
\&\fB\f(BIcommand()\fB\fR
.IP "\(bu" 2
\&\fB\f(BIverbatim()\fB\fR
.IP "\(bu" 2
\&\fB\f(BItextblock()\fB\fR
.IP "\(bu" 2
\&\fB\f(BIinterior_sequence()\fB\fR
.PP
Yo ass may also wanna override tha \fB\f(BIbegin_input()\fB\fR n' \fB\f(BIend_input()\fB\fR
methodz fo' yo' subclass (to big-ass up any needed per-file and/or
per-document initialization or cleanup).
.PP
If you need ta big-ass up any preprocessin of input before it is parsed
you may wanna override one or mo' of \fB\f(BIpreprocess_line()\fB\fR and/or
\&\fB\f(BIpreprocess_paragraph()\fB\fR.
.PP
Sometimes it may be necessary ta make mo' than one pass over tha input
files. If dis is tha case you have nuff muthafuckin options. Yo ass can make the
first pass rockin \fBPod::Parser\fR n' override yo' methodz ta store the
intermediate thangs up in dis biatch up in memory somewhere fo' tha \fB\f(BIend_pod()\fB\fR method to
process. Yo ass could use \fBPod::Parser\fR fo' nuff muthafuckin passes wit an
appropriate state variable ta control tha operation fo' each pass. If
your input source can't be reset ta start all up in tha beginning, you can
store it up in some other structure as a strang or a array n' have that
structure implement a \fB\f(BIgetline()\fB\fR method (which be all that
\&\fB\f(BIparse_from_filehandle()\fB\fR uses ta read input).
.PP
Feel free ta add any member data fieldz you need ta keep track of thangs
like current font, indentation, horizontal or vertical position, or
whatever else you like. Be shizzle ta read \*(L"\s-1PRIVATE METHODS AND DATA\*(R"\s0
to avoid name collisions.
.PP
For da most thugged-out part, tha \fBPod::Parser\fR base class should be able to
do most of tha input parsin fo' you n' leave you free ta worry about
how ta interpret tha commandz n' translate tha result.
.PP
Note dat all our crazy asses have busted lyrics bout here up in dis quick overview is the
simplest most straightforward use of \fBPod::Parser\fR ta do stream-based
parsing. Well shiiiit, it be also possible ta use tha \fBPod::Parser::parse_text\fR function
to do mo' sophisticated tree-based parsing. Right back up in yo muthafuckin ass. See \*(L"TREE-BASED \s-1PARSING\*(R"\s0.
.SH "PARSING OPTIONS"
.IX Header "PARSING OPTIONS"
A \fIparse-option\fR is simply a named option of \fBPod::Parser\fR wit a
value dat correspondz ta a cold-ass lil certain specified behavior. Shiiit, dis aint no joke. These various
behaviorz of \fBPod::Parser\fR may be enabled/disabled by setting
or unsettin one or mo' \fIparse-options\fR rockin tha \fB\f(BIparseopts()\fB\fR method.
Da set of currently accepted parse-options be as bigs up:
.IP "\fB\-want_nonPODs\fR (default: unset)" 3
.IX Item "-want_nonPODs (default: unset)"
Normally (by default) \fBPod::Parser\fR will only provide access to
the \s-1POD\s0 sectionz of tha input. Input paragraphs dat is not part
of tha POD-format documentation is not made available ta tha caller
(not even rockin \fB\f(BIpreprocess_paragraph()\fB\fR). Right back up in yo muthafuckin ass. Settin dis option ta a
non-empty, non-zero value will allow \fB\f(BIpreprocess_paragraph()\fB\fR ta see
non-POD sectionz of tha input as well as \s-1POD\s0 sections. Da \fB\f(BIcutting()\fB\fR
method can be used ta determine if tha correspondin paragraph be a \s-1POD\s0
paragraph, or some other input paragraph.
.IP "\fB\-process_cut_cmd\fR (default: unset)" 3
.IX Item "-process_cut_cmd (default: unset)"
Normally (by default) \fBPod::Parser\fR handlez tha \f(CW\*(C`=cut\*(C'\fR \s-1POD\s0 directive
by itself n' do not pass it on ta tha calla fo' processing. Right back up in yo muthafuckin ass. Setting
this option ta a non-empty, non-zero value will cause \fBPod::Parser\fR to
pass tha \f(CW\*(C`=cut\*(C'\fR directizzle ta tha calla just like any other \s-1POD\s0 command
(and hence it may be processed by tha \fB\f(BIcommand()\fB\fR method).
.Sp
\&\fBPod::Parser\fR will still interpret tha \f(CW\*(C`=cut\*(C'\fR directizzle ta mean that
\&\*(L"cuttin mode\*(R" has been (re)entered yo, but tha calla will git a cold-ass lil chance
to capture tha actual \f(CW\*(C`=cut\*(C'\fR paragraph itself fo' whatever purpose
it desires.
.IP "\fB\-warnings\fR (default: unset)" 3
.IX Item "-warnings (default: unset)"
Normally (by default) \fBPod::Parser\fR recognizes a funky-ass bare minimum of
pod syntax errors n' warnings n' thangs diagnostic lyrics
for errors yo, but not fo' warnings. (Use \fBPod::Checker\fR ta do more
thorough checkin of \s-1POD\s0 syntax.) Settin dis option ta a non-empty,
non-zero value will cause \fBPod::Parser\fR ta issue diagnostics for
the few warnings it recognizes as well as tha errors.
.PP
Please peep \*(L"\fIparseopts()\fR\*(R" fo' a cold-ass lil complete description of tha intercourse
for tha settin n' unsettin of parse-options.
.SH "RECOMMENDED SUBROUTINE/METHOD OVERRIDES"
.IX Header "RECOMMENDED SUBROUTINE/METHOD OVERRIDES"
\&\fBPod::Parser\fR serves up nuff muthafuckin methodz which most subclasses will probably
wanna override. These methodz is as bigs up:
.SH "\fB\fP\f(BIcommand()\fP\fB\fP"
.IX Header "command()"
.Vb 1
\&            $parser\->command($cmd,$text,$line_num,$pod_para);
.Ve
.PP
This method should be overridden by subclasses ta take tha appropriate
action when a \s-1POD\s0 command paragraph (denoted by a line beginnin with
\&\*(L"=\*(R") is encountered. Y'all KNOW dat shit, muthafucka! When such a \s-1POD\s0 directizzle is peeped up in tha input,
this method is called n' is passed:
.ie n .IP "$cmd" 3
.el .IP "\f(CW$cmd\fR" 3
.IX Item "$cmd"
the name of tha command fo' dis \s-1POD\s0 paragraph
.ie n .IP "$text" 3
.el .IP "\f(CW$text\fR" 3
.IX Item "$text"
the paragraph text fo' tha given \s-1POD\s0 paragraph command.
.ie n .IP "$line_num" 3
.el .IP "\f(CW$line_num\fR" 3
.IX Item "$line_num"
the line-number of tha beginnin of tha paragraph
.ie n .IP "$pod_para" 3
.el .IP "\f(CW$pod_para\fR" 3
.IX Item "$pod_para"
a reference ta a \f(CW\*(C`Pod::Paragraph\*(C'\fR object which gotz nuff further
information bout tha paragraph command (see Pod::InputObjects
for details).
.PP
\&\fBNote\fR dat dis method \fIis\fR called fo' \f(CW\*(C`=pod\*(C'\fR paragraphs.
.PP
Da base class implementation of dis method simply treats tha raw \s-1POD\s0
command as aiiight block of paragraph text (invokin tha \fB\f(BItextblock()\fB\fR
method wit tha command paragraph).
.SH "\fB\fP\f(BIverbatim()\fP\fB\fP"
.IX Header "verbatim()"
.Vb 1
\&            $parser\->verbatim($text,$line_num,$pod_para);
.Ve
.PP
This method may be overridden by subclasses ta take tha appropriate
action when a funky-ass block of verbatim text is encountered. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is passed the
followin parameters:
.ie n .IP "$text" 3
.el .IP "\f(CW$text\fR" 3
.IX Item "$text"
the block of text fo' tha verbatim paragraph
.ie n .IP "$line_num" 3
.el .IP "\f(CW$line_num\fR" 3
.IX Item "$line_num"
the line-number of tha beginnin of tha paragraph
.ie n .IP "$pod_para" 3
.el .IP "\f(CW$pod_para\fR" 3
.IX Item "$pod_para"
a reference ta a \f(CW\*(C`Pod::Paragraph\*(C'\fR object which gotz nuff further
information bout tha paragraph (see Pod::InputObjects
for details).
.PP
Da base class implementation of dis method simply prints tha textblock
(unmodified) ta tha output filehandle.
.SH "\fB\fP\f(BItextblock()\fP\fB\fP"
.IX Header "textblock()"
.Vb 1
\&            $parser\->textblock($text,$line_num,$pod_para);
.Ve
.PP
This method may be overridden by subclasses ta take tha appropriate
action when a aiiight block of \s-1POD\s0 text is encountered (although tha base
class method will probably do what tha fuck you want). Well shiiiit, it is passed tha following
parameters:
.ie n .IP "$text" 3
.el .IP "\f(CW$text\fR" 3
.IX Item "$text"
the block of text fo' tha a \s-1POD\s0 paragraph
.ie n .IP "$line_num" 3
.el .IP "\f(CW$line_num\fR" 3
.IX Item "$line_num"
the line-number of tha beginnin of tha paragraph
.ie n .IP "$pod_para" 3
.el .IP "\f(CW$pod_para\fR" 3
.IX Item "$pod_para"
a reference ta a \f(CW\*(C`Pod::Paragraph\*(C'\fR object which gotz nuff further
information bout tha paragraph (see Pod::InputObjects
for details).
.PP
In order ta process interior sequences, subclasses implementations of
this method will probably wanna invoke either \fB\f(BIinterpolate()\fB\fR or
\&\fB\f(BIparse_text()\fB\fR, passin it tha text block \f(CW$text\fR, n' tha corresponding
line number up in \f(CW$line_num\fR, n' then big-ass up any desired processin upon
the returned result.
.PP
Da base class implementation of dis method simply prints tha text block
as it occurred up in tha input stream).
.SH "\fB\fP\f(BIinterior_sequence()\fP\fB\fP"
.IX Header "interior_sequence()"
.Vb 1
\&            $parser\->interior_sequence($seq_cmd,$seq_arg,$pod_seq);
.Ve
.PP
This method should be overridden by subclasses ta take tha appropriate
action when a interior sequence is encountered. Y'all KNOW dat shit, muthafucka! An interior sequence is
an embedded command within a funky-ass block of text which appears as a cold-ass lil command
name (usually a single uppercase character) followed immediately by a
strin of text which is enclosed up in angle brackets, n' you can put dat on yo' toast. This method is
passed tha sequence command \f(CW$seq_cmd\fR n' tha correspondin text
\&\f(CW$seq_arg\fR. Well shiiiit, it is invoked by tha \fB\f(BIinterpolate()\fB\fR method fo' each interior
sequence dat occurs up in tha strang dat it is passed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it should return
the desired text strang ta be used up in place of tha interior sequence.
Da \f(CW$pod_seq\fR argument be a reference ta a \f(CW\*(C`Pod::InteriorSequence\*(C'\fR
object which gotz nuff further shiznit bout tha interior sequence.
Please peep Pod::InputObjects fo' details if you need ta access this
additionizzle shiznit.
.PP
Subclass implementationz of dis method may wish ta invoke tha 
\&\fB\f(BInested()\fB\fR method of \f(CW$pod_seq\fR ta peep if it is nested inside
some other interior-sequence (and if so, which kind).
.PP
Da base class implementation of tha \fB\f(BIinterior_sequence()\fB\fR method
simply returns tha raw text of tha interior sequence (as it occurred
in tha input) ta tha caller.
.SH "OPTIONAL SUBROUTINE/METHOD OVERRIDES"
.IX Header "OPTIONAL SUBROUTINE/METHOD OVERRIDES"
\&\fBPod::Parser\fR serves up nuff muthafuckin methodz which subclasses may wanna override
to big-ass up any special pre/post\-processing. These methodz do \fInot\fR have to
be overridden yo, but it may be useful fo' subclasses ta take advantage of em.
.SH "\fB\fP\f(BInew()\fP\fB\fP"
.IX Header "new()"
.Vb 1
\&            mah $parser = Pod::Parser\->new();
.Ve
.PP
This is tha constructor fo' \fBPod::Parser\fR n' its subclasses. You
\&\fIdo not\fR need ta override dis method hommie! It be capable of constructing
subclass objects as well as base class objects, provided you use
any of tha followin constructor invocation styles:
.PP
.Vb 3
\&    mah $parser1 = MyParser\->new();
\&    mah $parser2 = freshly smoked up MyParser();
\&    mah $parser3 = $parser2\->new();
.Ve
.PP
where \f(CW\*(C`MyParser\*(C'\fR is some subclass of \fBPod::Parser\fR.
.PP
Usin tha syntax \f(CW\*(C`MyParser::new()\*(C'\fR ta invoke tha constructor is \fInot\fR
recommended yo, but if you insist on bein able ta do this, then the
subclass \fIwill\fR need ta override tha \fB\f(BInew()\fB\fR constructor method. Y'all KNOW dat shit, muthafucka! If
you do override tha constructor, you \fImust\fR be shizzle ta invoke the
\&\fB\f(BIinitialize()\fB\fR method of tha newly pimped object.
.PP
Usin any of tha above invocations, tha straight-up original gangsta argument ta the
constructor be always tha correspondin package name (or object
reference). No other arguments is required yo, but if desired, an
associatizzle array (or hash-table) mah be passed ta tha \fB\f(BInew()\fB\fR
constructor, as in:
.PP
.Vb 2
\&    mah $parser1 = MyParser\->new( MYDATA => $value1, MOREDATA => $value2 );
\&    mah $parser2 = freshly smoked up MyParser( \-myflag => 1 );
.Ve
.PP
All arguments passed ta tha \fB\f(BInew()\fB\fR constructor is ghon be treated as
key/value pairs up in a hash-table. Da newly constructed object will be
initialized by copyin tha contentz of tha given hash-table (which may
have been empty). Da \fB\f(BInew()\fB\fR constructor fo' dis class n' all of its
subclasses returns a pimped reference ta tha initialized object (hash-table).
.SH "\fB\fP\f(BIinitialize()\fP\fB\fP"
.IX Header "initialize()"
.Vb 1
\&            $parser\->initialize();
.Ve
.PP
This method performs any necessary object initialization. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it takes no
arguments (other than tha object instizzle of course, which is typically
copied ta a local variable named \f(CW$self\fR). If subclasses override this
method then they \fImust\fR be shizzle ta invoke \f(CW\*(C`$self\->SUPER::initialize()\*(C'\fR.
.SH "\fB\fP\f(BIbegin_pod()\fP\fB\fP"
.IX Header "begin_pod()"
.Vb 1
\&            $parser\->begin_pod();
.Ve
.PP
This method is invoked all up in tha beginnin of processin fo' each \s-1POD\s0
document dat is encountered up in tha input. Right back up in yo muthafuckin ass. Subclasses should override
this method ta big-ass up any per-document initialization.
.SH "\fB\fP\f(BIbegin_input()\fP\fB\fP"
.IX Header "begin_input()"
.Vb 1
\&            $parser\->begin_input();
.Ve
.PP
This method is invoked by \fB\f(BIparse_from_filehandle()\fB\fR immediately \fIbefore\fR
processin input from a gangbangin' filehandle. Da base class implementation do
nothing, however, subclasses may override it ta big-ass up any per-file
initializations.
.PP
Note dat if multiple filez is parsed fo' a single \s-1POD\s0 document
(like tha result of some future \f(CW\*(C`=include\*(C'\fR directive) dis method
is invoked fo' every last muthafuckin file dat is parsed. Y'all KNOW dat shit, muthafucka! If you wish ta big-ass up certain
initializations once per document, then you should use \fB\f(BIbegin_pod()\fB\fR.
.SH "\fB\fP\f(BIend_input()\fP\fB\fP"
.IX Header "end_input()"
.Vb 1
\&            $parser\->end_input();
.Ve
.PP
This method is invoked by \fB\f(BIparse_from_filehandle()\fB\fR immediately \fIafter\fR
processin input from a gangbangin' filehandle. Da base class implementation do
nothing, however, subclasses may override it ta big-ass up any per-file
cleanup actions.
.PP
Please note dat if multiple filez is parsed fo' a single \s-1POD\s0 document
(like tha result of some kind of \f(CW\*(C`=include\*(C'\fR directive) dis method
is invoked fo' every last muthafuckin file dat is parsed. Y'all KNOW dat shit, muthafucka! If you wish ta big-ass up certain
cleanup actions once per document, then you should use \fB\f(BIend_pod()\fB\fR.
.SH "\fB\fP\f(BIend_pod()\fP\fB\fP"
.IX Header "end_pod()"
.Vb 1
\&            $parser\->end_pod();
.Ve
.PP
This method is invoked all up in tha end of processin fo' each \s-1POD\s0 document
that is encountered up in tha input. Right back up in yo muthafuckin ass. Subclasses should override dis method
to big-ass up any per-document finalization.
.SH "\fB\fP\f(BIpreprocess_line()\fP\fB\fP"
.IX Header "preprocess_line()"
.Vb 1
\&          $textline = $parser\->preprocess_line($text, $line_num);
.Ve
.PP
This method should be overridden by subclasses dat wish ta perform
any kind of preprocessin fo' each \fIline\fR of input (\fIbefore\fR it has
been determined whether or not it is part of a \s-1POD\s0 paragraph). The
parameta \f(CW$text\fR is tha input line; n' tha parameta \f(CW$line_num\fR is
the line number of tha correspondin text line.
.PP
Da value returned should correspond ta tha freshly smoked up text ta use up in its
place.  If tha empty strang or a undefined value is returned then no
further processin is ghon be performed fo' dis line.
.PP
Please note dat tha \fB\f(BIpreprocess_line()\fB\fR method is invoked \fIbefore\fR
the \fB\f(BIpreprocess_paragraph()\fB\fR method. Y'all KNOW dat shit, muthafucka! Afta all (possibly preprocessed)
lines up in a paragraph done been assembled together n' it has been
determined dat tha paragraph is part of tha \s-1POD\s0 documentation from one
of tha selected sections, then \fB\f(BIpreprocess_paragraph()\fB\fR is invoked.
.PP
Da base class implementation of dis method returns tha given text.
.SH "\fB\fP\f(BIpreprocess_paragraph()\fP\fB\fP"
.IX Header "preprocess_paragraph()"
.Vb 1
\&            $textblock = $parser\->preprocess_paragraph($text, $line_num);
.Ve
.PP
This method should be overridden by subclasses dat wish ta big-ass up any
kind of preprocessin fo' each block (paragraph) of \s-1POD\s0 documentation
that appears up in tha input stream. Da parameta \f(CW$text\fR is tha \s-1POD\s0
paragraph from tha input file; n' tha parameta \f(CW$line_num\fR is the
line number fo' tha beginnin of tha correspondin paragraph.
.PP
Da value returned should correspond ta tha freshly smoked up text ta use up in its
place If tha empty strang is returned or a undefined value is
returned, then tha given \f(CW$text\fR is ignored (not processed).
.PP
This method is invoked afta gatherin up all tha lines up in a paragraph
and afta determinin tha cuttin state of tha paragraph,
but before tryin ta further parse or interpret em fo' realz. After
\&\fB\f(BIpreprocess_paragraph()\fB\fR returns, tha current cuttin state (which
is returned by \f(CW\*(C`$self\->cutting()\*(C'\fR) is examined. Y'all KNOW dat shit, muthafucka! If it evaluates
to legit then input text (includin tha given \f(CW$text\fR) is cut (not
processed) until tha next \s-1POD\s0 directizzle is encountered.
.PP
Please note dat tha \fB\f(BIpreprocess_line()\fB\fR method is invoked \fIbefore\fR
the \fB\f(BIpreprocess_paragraph()\fB\fR method. Y'all KNOW dat shit, muthafucka! Afta all (possibly preprocessed)
lines up in a paragraph done been assembled together n' either it has been
determined dat tha paragraph is part of tha \s-1POD\s0 documentation from one
of tha selected sections or tha \f(CW\*(C`\-want_nonPODs\*(C'\fR option is true,
then \fB\f(BIpreprocess_paragraph()\fB\fR is invoked.
.PP
Da base class implementation of dis method returns tha given text.
.SH "METHODS FOR PARSING AND PROCESSING"
.IX Header "METHODS FOR PARSING AND PROCESSING"
\&\fBPod::Parser\fR serves up nuff muthafuckin methodz ta process input text. These
methodz typically won't need ta be overridden (and up in some cases they
can't be overridden) yo, but subclasses may wanna invoke dem ta exploit
their functionality.
.SH "\fB\fP\f(BIparse_text()\fP\fB\fP"
.IX Header "parse_text()"
.Vb 3
\&            $ptree1 = $parser\->parse_text($text, $line_num);
\&            $ptree2 = $parser\->parse_text({%opts}, $text, $line_num);
\&            $ptree3 = $parser\->parse_text(\e%opts, $text, $line_num);
.Ve
.PP
This method is useful if you need ta big-ass up yo' own interpolation 
of interior sequences n' can't rely upon \fBinterpolate\fR ta expand
them up in simple bottom-up order.
.PP
Da parameta \f(CW$text\fR be a strang or block of text ta be parsed
for interior sequences; n' tha parameta \f(CW$line_num\fR is the
line number correspondin ta tha beginnin of \f(CW$text\fR.
.PP
\&\fB\f(BIparse_text()\fB\fR will parse tha given text tha fuck into a parse-tree of \*(L"nodes.\*(R"
and interior-sequences.  Each \*(L"node\*(R" up in tha parse tree is either a
text-string, or a \fBPod::InteriorSequence\fR.  Da result returned be a
parse-tree of type \fBPod::ParseTree\fR. Please peep Pod::InputObjects
for mo' shiznit bout \fBPod::InteriorSequence\fR n' \fBPod::ParseTree\fR.
.PP
If desired, a optionizzle hash-ref may be specified as tha straight-up original gangsta argument
to customize certain aspectz of tha parse-tree dat is pimped and
returned. Y'all KNOW dat shit, muthafucka! Da set of recognized option keywordz are:
.IP "\fB\-expand_seq\fR => \fIcode-ref\fR|\fImethod-name\fR" 3
.IX Item "-expand_seq => code-ref|method-name"
Normally, tha parse-tree returned by \fB\f(BIparse_text()\fB\fR will contain an
unexpanded \f(CW\*(C`Pod::InteriorSequence\*(C'\fR object fo' each interior-sequence
encountered. Y'all KNOW dat shit, muthafucka! Specifyin \fB\-expand_seq\fR  drops some lyrics ta \fB\f(BIparse_text()\fB\fR ta \*(L"expand\*(R"
every interior-sequence it sees by invokin tha referenced function
(or named method of tha parser object) n' rockin tha return value as the
expanded result.
.Sp
If a subroutine reference was given, it is invoked as:
.Sp
.Vb 1
\&  &$code_ref( $parser, $sequence )
.Ve
.Sp
and if a method-name was given, it is invoked as:
.Sp
.Vb 1
\&  $parser\->method_name( $sequence )
.Ve
.Sp
where \f(CW$parser\fR be a reference ta tha parser object, n' \f(CW$sequence\fR
is a reference ta tha interior-sequence object.
[\fI\s-1NOTE\s0\fR: If tha \fB\f(BIinterior_sequence()\fB\fR method is specified, then it is
invoked accordin ta tha intercourse specified up in \*(L"\fIinterior_sequence()\fR\*(R"].
.IP "\fB\-expand_text\fR => \fIcode-ref\fR|\fImethod-name\fR" 3
.IX Item "-expand_text => code-ref|method-name"
Normally, tha parse-tree returned by \fB\f(BIparse_text()\fB\fR will contain a
text-strin fo' each contiguous sequence of charactas outside of an
interior-sequence. Right back up in yo muthafuckin ass. Specifyin \fB\-expand_text\fR  drops some lyrics ta \fB\f(BIparse_text()\fB\fR to
\&\*(L"preprocess\*(R" every last muthafuckin such text-strin it sees by invokin tha referenced
function (or named method of tha parser object) n' rockin tha return value
as tha preprocessed (or \*(L"expanded\*(R") result. [Note dat if tha result is
an interior-sequence, then it will \fInot\fR be expanded as specified by the
\&\fB\-expand_seq\fR option; Any such recursive expansion need ta be handled by
the specified callback routine.]
.Sp
If a subroutine reference was given, it is invoked as:
.Sp
.Vb 1
\&  &$code_ref( $parser, $text, $ptree_node )
.Ve
.Sp
and if a method-name was given, it is invoked as:
.Sp
.Vb 1
\&  $parser\->method_name( $text, $ptree_node )
.Ve
.Sp
where \f(CW$parser\fR be a reference ta tha parser object, \f(CW$text\fR is the
text-strin encountered, n' \f(CW$ptree_node\fR be a reference ta tha current
node up in tha parse-tree (usually a interior-sequence object or else the
top-level node of tha parse-tree).
.IP "\fB\-expand_ptree\fR => \fIcode-ref\fR|\fImethod-name\fR" 3
.IX Item "-expand_ptree => code-ref|method-name"
Rather than returnin a \f(CW\*(C`Pod::ParseTree\*(C'\fR, pass tha parse-tree as an
argument ta tha referenced subroutine (or named method of tha parser
object) n' return tha result instead of tha parse-tree object.
.Sp
If a subroutine reference was given, it is invoked as:
.Sp
.Vb 1
\&  &$code_ref( $parser, $ptree )
.Ve
.Sp
and if a method-name was given, it is invoked as:
.Sp
.Vb 1
\&  $parser\->method_name( $ptree )
.Ve
.Sp
where \f(CW$parser\fR be a reference ta tha parser object, n' \f(CW$ptree\fR
is a reference ta tha parse-tree object.
.SH "\fB\fP\f(BIinterpolate()\fP\fB\fP"
.IX Header "interpolate()"
.Vb 1
\&            $textblock = $parser\->interpolate($text, $line_num);
.Ve
.PP
This method translates all text (includin any embedded interior sequences)
in tha given text strang \f(CW$text\fR n' returns tha interpolated result. The
parameta \f(CW$line_num\fR is tha line number correspondin ta tha beginning
of \f(CW$text\fR.
.PP
\&\fB\f(BIinterpolate()\fB\fR merely invokes a private method ta recursively expand
nested interior sequences up in bottom-up order (innermost sequences are
expanded first). If there be a need ta expand nested sequences in
some alternate order, use \fBparse_text\fR instead.
.SH "\fB\fP\f(BIparse_from_filehandle()\fP\fB\fP"
.IX Header "parse_from_filehandle()"
.Vb 1
\&            $parser\->parse_from_filehandle($in_fh,$out_fh);
.Ve
.PP
This method takes a input filehandle (which be assumed ta already be
opened fo' reading) n' readz tha entire input stream lookin fo' blocks
(paragraphs) of \s-1POD\s0 documentation ta be processed. Y'all KNOW dat shit, muthafucka! If no first argument
is given tha default input filehandle \f(CW\*(C`STDIN\*(C'\fR is used.
.PP
Da \f(CW$in_fh\fR parameta may be any object dat serves up a \fB\f(BIgetline()\fB\fR
method ta retrieve a single line of input text (hence, a appropriate
wrapper object could be used ta parse PODs from a single strang or an
array of strings).
.PP
Usin \f(CW\*(C`$in_fh\->getline()\*(C'\fR, input is read line-by-line n' assembled
into paragraphs or \*(L"blocks\*(R" (which is separated by lines containing
nothang but whitespace). For each block of \s-1POD\s0 documentation
encountered it will invoke a method ta parse tha given paragraph.
.PP
If a second argument is given then it should correspond ta a gangbangin' filehandle where
output should be busted (otherwise tha default output filehandle is
\&\f(CW\*(C`STDOUT\*(C'\fR if no output filehandle is currently up in use).
.PP
\&\fB\s-1NOTE:\s0\fR For performizzle reasons, dis method caches tha input stream at
the top of tha stack up in a local variable fo' realz. Any attempts by clients to
change tha stack contents durin processin when up in tha midst executing
of dis method \fIwill not affect\fR tha input stream used by tha current
invocation of dis method.
.PP
This method do \fInot\fR probably need ta be overridden by subclasses.
.SH "\fB\fP\f(BIparse_from_file()\fP\fB\fP"
.IX Header "parse_from_file()"
.Vb 1
\&            $parser\->parse_from_file($filename,$outfile);
.Ve
.PP
This method takes a gangbangin' filename n' do tha following:
.IP "\(bu" 2
opens tha input n' output filez fo' reading
(bustin tha appropriate filehandles)
.IP "\(bu" 2
invokes tha \fB\f(BIparse_from_filehandle()\fB\fR method passin it the
correspondin input n' output filehandles.
.IP "\(bu" 2
closes tha input n' output files.
.PP
If tha special input filename \*(L"\-\*(R" or \*(L"<&STDIN\*(R" is given then tha \s-1STDIN\s0
filehandle is used fo' input (and no open or close is performed). If no
input filename is specified then \*(L"\-\*(R" is implied. Y'all KNOW dat shit, muthafucka! Filehandle references,
or objects dat support tha regular \s-1IO\s0 operations (like \f(CW\*(C`<$fh>\*(C'\fR
or \f(CW\*(C`$fh\-<Egt\*(C'\fRgetline>) is also accepted; tha handlez must already be 
opened.
.PP
If a second argument is given then it should be tha name of tha desired
output file. If tha special output filename \*(L"\-\*(R" or \*(L">&STDOUT\*(R" is given
then tha \s-1STDOUT\s0 filehandle is used fo' output (and no open or close is
performed). If tha special output filename \*(L">&STDERR\*(R" is given then the
\&\s-1STDERR\s0 filehandle is used fo' output (and no open or close is
performed). If no output filehandle is currently up in use n' no output
filename is specified, then \*(L"\-\*(R" is implied.
Alternatively, filehandle references or objects dat support tha regular
\&\s-1IO\s0 operations (like \f(CW\*(C`print\*(C'\fR, e.g. IO::String) is also accepted;
the object must already be opened.
.PP
This method do \fInot\fR probably need ta be overridden by subclasses.
.SH "ACCESSOR METHODS"
.IX Header "ACCESSOR METHODS"
Clientz of \fBPod::Parser\fR should use tha followin methodz ta access
instizzle data fields:
.SH "\fB\fP\f(BIerrorsub()\fP\fB\fP"
.IX Header "errorsub()"
.Vb 3
\&            $parser\->errorsub("method_name");
\&            $parser\->errorsub(\e&warn_user);
\&            $parser\->errorsub(sub { print STDERR, @_ });
.Ve
.PP
Specifies tha method or subroutine ta use when printin error lyrics
about \s-1POD\s0 syntax. Da supplied method/subroutine \fImust\fR return \s-1TRUE\s0 upon
successful printin of tha message. If \f(CW\*(C`undef\*(C'\fR is given, then tha \fBcarp\fR
builtin is used ta issue error lyrics (this is tha default behavior).
.PP
.Vb 5
\&            mah $errorsub = $parser\->errorsub()
\&            mah $errmsg = "This be a error message!\en"
\&            (ref $errorsub) n' &{$errorsub}($errmsg)
\&                or (defined $errorsub) n' $parser\->$errorsub($errmsg)
\&                    or  carp($errmsg);
.Ve
.PP
Returns a method name, or else a reference ta tha user-supplied subroutine
used ta print error lyrics. Returns \f(CW\*(C`undef\*(C'\fR if tha \fBcarp\fR builtin
is used ta issue error lyrics (this is tha default behavior).
.SH "\fB\fP\f(BIcutting()\fP\fB\fP"
.IX Header "cutting()"
.Vb 1
\&            $boolean = $parser\->cutting();
.Ve
.PP
Returns tha current \f(CW\*(C`cutting\*(C'\fR state: a funky-ass boolean-valued scalar which
evaluates ta legit if text from tha input file is currently bein \*(L"cut\*(R"
(meanin it is \fInot\fR considered part of tha \s-1POD\s0 document).
.PP
.Vb 1
\&            $parser\->cutting($boolean);
.Ve
.PP
Sets tha current \f(CW\*(C`cutting\*(C'\fR state ta tha given value n' returns the
result.
.SH "\fB\fP\f(BIparseopts()\fP\fB\fP"
.IX Header "parseopts()"
When invoked wit no additionizzle arguments, \fBparseopts\fR returns a hashtable
of all tha current parsin options.
.PP
.Vb 3
\&            ## See if we is parsin non\-POD sections as well as POD ones
\&            mah %opts = $parser\->parseopts();
\&            $opts{\*(Aq\-want_nonPODs}\*(Aq n' print "\-want_nonPODs\en";
.Ve
.PP
When invoked rockin a single string, \fBparseopts\fR treats tha strang as the
name of a parse-option n' returns its correspondin value if it exists
(returns \f(CW\*(C`undef\*(C'\fR if it don't).
.PP
.Vb 3
\&            ## Did we ask ta peep \*(Aq=cut\*(Aq paragraphs?
\&            mah $want_cut = $parser\->parseopts(\*(Aq\-process_cut_cmd\*(Aq);
\&            $want_cut n' print "\-process_cut_cmd\en";
.Ve
.PP
When invoked wit multiple arguments, \fBparseopts\fR treats dem as
key/value pairs n' tha specified parse-option names is set ta the
given joints fo' realz. Any unspecified parse-options is unaffected.
.PP
.Vb 2
\&            ## Set dem back ta tha default
\&            $parser\->parseopts(\-warnings => 0);
.Ve
.PP
When passed a single hash-ref, \fBparseopts\fR uses dat hash ta straight-up
reset tha existin parse-options, all previous parse-option joints
are lost.
.PP
.Vb 2
\&            ## Reset all options ta default 
\&            $parser\->parseopts( { } );
.Ve
.PP
See \*(L"\s-1PARSING OPTIONS\*(R"\s0 fo' mo' shiznit on tha name n' meanin of each
parse-option currently recognized.
.SH "\fB\fP\f(BIoutput_file()\fP\fB\fP"
.IX Header "output_file()"
.Vb 1
\&            $fname = $parser\->output_file();
.Ve
.PP
Returns tha name of tha output file bein written.
.SH "\fB\fP\f(BIoutput_handle()\fP\fB\fP"
.IX Header "output_handle()"
.Vb 1
\&            $fhandle = $parser\->output_handle();
.Ve
.PP
Returns tha output filehandle object.
.SH "\fB\fP\f(BIinput_file()\fP\fB\fP"
.IX Header "input_file()"
.Vb 1
\&            $fname = $parser\->input_file();
.Ve
.PP
Returns tha name of tha input file bein read.
.SH "\fB\fP\f(BIinput_handle()\fP\fB\fP"
.IX Header "input_handle()"
.Vb 1
\&            $fhandle = $parser\->input_handle();
.Ve
.PP
Returns tha current input filehandle object.
.SH "PRIVATE METHODS AND DATA"
.IX Header "PRIVATE METHODS AND DATA"
\&\fBPod::Parser\fR make use of nuff muthafuckin internal methodz n' data fields
which clients should not need ta peep or use. For tha sake of avoiding
name collisions fo' client data n' methods, these methodz n' fields
are briefly discussed here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Determined hackers may obtain further
information bout dem by readin tha \fBPod::Parser\fR source code.
.PP
Private data fieldz is stored up in tha hash-object whose reference is
returned by tha \fB\f(BInew()\fB\fR constructor fo' dis class. Da namez of all
private methodz n' data-fieldz used by \fBPod::Parser\fR begin wit a
prefix of \*(L"_\*(R" n' match tha regular expression \f(CW\*(C`/^_\ew+$/\*(C'\fR.
.SH "TREE-BASED PARSING"
.IX Header "TREE-BASED PARSING"
If straightforward stream-based parsin aint gonna hook up yo' needz (as is
likely tha case fo' tasks like fuckin translatin PODs tha fuck into structured
markup languages like \s-1HTML\s0 n' \s-1XML\s0) then you may need ta take the
tree-based approach. Rather than bustin every last muthafuckin thang up in one pass and
callin tha \fB\f(BIinterpolate()\fB\fR method ta expand sequences tha fuck into text, it
may be desirable ta instead create a parse-tree rockin tha \fB\f(BIparse_text()\fB\fR
method ta return a tree-like structure which may contain a ordered
list of lil pimps (each of which may be a text-string, or a similar
tree-like structure).
.PP
Pay special attention ta \*(L"\s-1METHODS FOR PARSING AND PROCESSING\*(R"\s0 and
to tha objects busted lyrics bout up in Pod::InputObjects, n' you can put dat on yo' toast. Da forma raps about
the gory details n' parametas fo' how tha fuck ta customize n' extend the
parsin behavior of \fBPod::Parser\fR. \fBPod::InputObjects\fR provides
several objects dat may all be used interchangeably as parse-trees. The
most obvious one is tha \fBPod::ParseTree\fR object. Well shiiiit, it defines tha basic
interface n' functionalitizzle dat all thangs tryin ta be a \s-1POD\s0 parse-tree
should do fo' realz. A \fBPod::ParseTree\fR is defined such dat each \*(L"node\*(R" may be a
text-string, or a reference ta another parse-tree.  Each \fBPod::Paragraph\fR
object n' each \fBPod::InteriorSequence\fR object also supports tha basic
parse-tree intercourse.
.PP
Da \fB\f(BIparse_text()\fB\fR method takes a given paragraph of text, and
returns a parse-tree dat gotz nuff one or mo' children, each of which
may be a text-string, or a InteriorSequence object. There is also
callback-options dat may be passed ta \fB\f(BIparse_text()\fB\fR ta customize
the way it expandz or transforms interior-sequences, as well as the
returned result. These callbacks can be used ta create a parse-tree
with custom-made objects (which may or may not support tha parse-tree
interface, dependin on how tha fuck you chizzle ta do it).
.PP
If you wish ta turn a entire \s-1POD\s0 document tha fuck into a parse-tree, dat process
is fairly straightforward. Y'all KNOW dat shit, muthafucka! Da \fB\f(BIparse_text()\fB\fR method is tha key ta bustin
this successfully. Every paragraph-callback (i.e. tha polymorphic methods
for \fB\f(BIcommand()\fB\fR, \fB\f(BIverbatim()\fB\fR, n' \fB\f(BItextblock()\fB\fR paragraphs) takes
a \fBPod::Paragraph\fR object as a argument. Each paragraph object has a
\&\fB\f(BIparse_tree()\fB\fR method dat can be used ta git or set a cold-ass lil corresponding
parse-tree. Right back up in yo muthafuckin ass. So fo' each of dem paragraph-callback methods, simply call
\&\fB\f(BIparse_text()\fB\fR wit tha options you desire, n' then use tha returned
parse-tree ta assign ta tha given paragraph object.
.PP
That gives you a parse-tree fo' each paragraph \- so now all you need is
an ordered list of paragraphs. Yo ass can maintain dat yo ass as a thugged-out data
element up in tha object/hash. Da most straightforward way would be simply
to use a array-ref, wit tha desired set of custom \*(L"options\*(R" fo' each
invocation of \fBparse_text\fR. Letz assume tha desired option-set is
given by tha hash \f(CW%options\fR. Then we might do suttin' like the
following:
.PP
.Vb 1
\&    package MyPodParserTree;
\&
\&    @ISA = qw( Pod::Parser );
\&
\&    ...
\&
\&    sub begin_pod {
\&        mah $self = shift;
\&        $self\->{\*(Aq\-paragraphs\*(Aq} = [];  ## initialize paragraph list
\&    }
\&
\&    sub command { 
\&        mah ($parser, $command, $paragraph, $line_num, $pod_para) = @_;
\&        mah $ptree = $parser\->parse_text({%options}, $paragraph, ...);
\&        $pod_para\->parse_tree( $ptree );
\&        push @{ $self\->{\*(Aq\-paragraphs\*(Aq} }, $pod_para;
\&    }
\&
\&    sub verbatim { 
\&        mah ($parser, $paragraph, $line_num, $pod_para) = @_;
\&        push @{ $self\->{\*(Aq\-paragraphs\*(Aq} }, $pod_para;
\&    }
\&
\&    sub textblock { 
\&        mah ($parser, $paragraph, $line_num, $pod_para) = @_;
\&        mah $ptree = $parser\->parse_text({%options}, $paragraph, ...);
\&        $pod_para\->parse_tree( $ptree );
\&        push @{ $self\->{\*(Aq\-paragraphs\*(Aq} }, $pod_para;
\&    }
\&
\&    ...
\&
\&    package main;
\&    ...
\&    mah $parser = freshly smoked up MyPodParserTree(...);
\&    $parser\->parse_from_file(...);
\&    mah $paragraphs_ref = $parser\->{\*(Aq\-paragraphs\*(Aq};
.Ve
.PP
Of course, up in dis module-authorz humble opinion, I'd be mo' inclined to
use tha existin \fBPod::ParseTree\fR object than a simple array. That way
everythang up in it, paragraphs n' sequences, all respond ta tha same core
interface fo' all parse-tree nodes. Da result would look suttin' like:
.PP
.Vb 1
\&    package MyPodParserTree2;
\&
\&    ...
\&
\&    sub begin_pod {
\&        mah $self = shift;
\&        $self\->{\*(Aq\-ptree\*(Aq} = freshly smoked up Pod::ParseTree;  ## initialize parse\-tree
\&    }
\&
\&    sub parse_tree {
\&        ## convenience method ta get/set tha parse\-tree fo' tha entire POD
\&        (@_ > 1)  n'  $_[0]\->{\*(Aq\-ptree\*(Aq} = $_[1];
\&        return $_[0]\->{\*(Aq\-ptree\*(Aq};
\&    }
\&
\&    sub command { 
\&        mah ($parser, $command, $paragraph, $line_num, $pod_para) = @_;
\&        mah $ptree = $parser\->parse_text({<<options>>}, $paragraph, ...);
\&        $pod_para\->parse_tree( $ptree );
\&        $parser\->parse_tree()\->append( $pod_para );
\&    }
\&
\&    sub verbatim { 
\&        mah ($parser, $paragraph, $line_num, $pod_para) = @_;
\&        $parser\->parse_tree()\->append( $pod_para );
\&    }
\&
\&    sub textblock { 
\&        mah ($parser, $paragraph, $line_num, $pod_para) = @_;
\&        mah $ptree = $parser\->parse_text({<<options>>}, $paragraph, ...);
\&        $pod_para\->parse_tree( $ptree );
\&        $parser\->parse_tree()\->append( $pod_para );
\&    }
\&
\&    ...
\&
\&    package main;
\&    ...
\&    mah $parser = freshly smoked up MyPodParserTree2(...);
\&    $parser\->parse_from_file(...);
\&    mah $ptree = $parser\->parse_tree;
\&    ...
.Ve
.PP
Now you have tha entire \s-1POD\s0 document as one pimped out big-ass parse-tree. You
can even use tha \fB\-expand_seq\fR option ta \fBparse_text\fR ta insert
whole different kindz of objects, n' you can put dat on yo' toast. Just don't expect \fBPod::Parser\fR
to know what tha fuck ta do wit dem afta dis shit. That will need ta be up in your
code. Or, alternatively, you can bang any object you like so long as
it conforms ta tha \fBPod::ParseTree\fR intercourse.
.PP
One could use dis ta create subclassez of \fBPod::Paragraphs\fR and
\&\fBPod::InteriorSequences\fR fo' specific commandz (or ta create yo' own
custom node-types up in tha parse-tree) n' add some kind of \fB\f(BIemit()\fB\fR
method ta each custom node/subclass object up in tha tree. Then all you'd
need ta do is recursively strutt tha tree up in tha desired order, processing
the lil pimps (most likely from left ta right) by formattin dem if
they is text-strings, or by callin they \fB\f(BIemit()\fB\fR method if they
are objects/references.
.SH "CAVEATS"
.IX Header "CAVEATS"
Please note dat \s-1POD\s0 has tha notion of \*(L"paragraphs\*(R": dis is something
startin \fIafter\fR a funky-ass blank (read: empty) line, wit tha single exception
of tha file start, which be also startin a paragraph. That means that
especially a cold-ass lil command (e.g. \f(CW\*(C`=head1\*(C'\fR) \fImust\fR be preceded wit a funky-ass blank
line; \f(CW\*(C`_\|_END_\|_\*(C'\fR is \fInot\fR a funky-ass blank line.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::InputObjects, Pod::Select
.PP
\&\fBPod::InputObjects\fR defines \s-1POD\s0 input objects correspondin to
command paragraphs, parse-trees, n' interior-sequences.
.PP
\&\fBPod::Select\fR be a subclass of \fBPod::Parser\fR which serves up tha ability
to selectively include and/or exclude sectionz of a \s-1POD\s0 document from being
translated based upon tha current heading, subheading, subsubheading, etc.
.SH "AUTHOR"
.IX Header "AUTHOR"
Please report bugs rockin <http://rt.cpan.org>.
.PP
Brad Appleton <bradapp@enteract.com>
.PP
Based on code fo' \fBPod::Text\fR freestyled by
Tomothy Christiansen <tchrist@mox.perl.com>
.SH "LICENSE"
.IX Header "LICENSE"
Pod-Parser is free software; you can redistribute it and/or modify it
under tha termz of tha Artistic License distributed wit Perl version
5.000 or (at yo' option) any lata version. I aint talkin' bout chicken n' gravy biatch. Please refer ta the
Artistic License dat came wit yo' Perl distribution fo' more
details. If yo' version of Perl was not distributed under the
termz of tha Artistic License, than you may distribute PodParser
under tha same terms as Perl itself.
