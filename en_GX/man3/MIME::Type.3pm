.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MIME::Type 3"
.TH MIME::Type 3 "2013-09-12" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME::Type \- description of one MIME type
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use MIME::Types;
\& mah $mimetypes = MIME::Types\->new;
\& mah MIME::Type $plaintext = $mimetypes\->type(\*(Aqtext/plain\*(Aq);
\& print $plaintext\->mediaType;   # text
\& print $plaintext\->subType;     # plain
\&
\& mah @ext = $plaintext\->extensions;
\& print "@ext"                   # txt asc c cc h hh cpp
\&
\& print $plaintext\->encodin     # 8bit
\& if($plaintext\->isBinary)       # false
\& if($plaintext\->isAscii)        # true
\& if($plaintext\->equals(\*(Aqtext/plain\*(Aq) {...}
\& if($plaintext eq \*(Aqtext/plain\*(Aq) # same
\&
\& print MIME::Type\->simplified(\*(Aqx\-appl/x\-zip\*(Aq) #  \*(Aqappl/zip\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1MIME\s0 types is used up in \s-1MIME\s0 entities, fo' instizzle as part of e\-mail
and \s-1HTTP\s0 traffic.  Sometimes real knowledge on some mime-type is need.
Objectz of \f(CW\*(C`MIME::Type\*(C'\fR store tha shiznit on one such type.
.SH "OVERLOADED"
.IX Header "OVERLOADED"
.IP "overload: \fBstrin comparison\fR()" 4
.IX Item "overload: strang comparison()"
When a MIME::Type object is compared ta either a strang or another
MIME::TYpe, tha \fIequals()\fR method is called. Y'all KNOW dat shit, muthafucka!  Comparison is smart,
which means dat it extendz common strang comparison wit some
features which is defined up in tha related RFCs.
.IP "overload: \fBstringification\fR()" 4
.IX Item "overload: stringification()"
Da stringification (use of tha object up in a place where a string
is required) will result up in tha type name, tha same as \fItype()\fR
returns.
.Sp
example: use of stringification
.Sp
.Vb 3
\& mah $mime = MIME::Type\->new(\*(Aqtext/html\*(Aq);
\& print "$mime\en";   # explicit stringification
\& print $mime;       # implicit stringification
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "Initiation"
.IX Subsection "Initiation"
.IP "MIME::Type\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "MIME::Type->new(OPTIONS)"
Smoke (\fIinstantiate\fR) a freshly smoked up MIME::Type object which manages one
mime type.
.Sp
.Vb 6
\& \-Option    \-\-Default
\&  encodin    <dependz on type>
\&  extensions  []
\&  simplified  <derived from type>
\&  system      undef
\&  type        <required>
.Ve
.RS 4
.IP "encodin => '7bit'|'8bit'|'base64'|'quoted\-printable'" 2
.IX Item "encodin => '7bit'|'8bit'|'base64'|'quoted-printable'"
How tha fuck must dis data be encoded ta be transported safely.  Da default
dependz on tha type: mimes wit as main type \f(CW\*(C`text/\*(C'\fR will default
to \f(CW\*(C`quoted\-printable\*(C'\fR n' all other ta \f(CW\*(C`base64\*(C'\fR.
.IP "extensions => REF-ARRAY" 2
.IX Item "extensions => REF-ARRAY"
An array of extensions which is rockin dis mime.
.IP "simplified => \s-1STRING\s0" 2
.IX Item "simplified => STRING"
Da mime types main\- n' sub-label can both start wit \f(CW\*(C`x\-\*(C'\fR, ta indicate
that be a non-registered name.  Of course, afta registration dis flag
can disappear which addz ta tha mad drama.  Da simplified strang has the
\&\f(CW\*(C`x\-\*(C'\fR thangies removed n' is translated ta lower-case.
.IP "system => \s-1REGEX\s0" 2
.IX Item "system => REGEX"
Regular expression which defines fo' which systems dis rule is valid. Y'all KNOW dat shit, muthafucka!  The
\&\s-1REGEX\s0 is matched on \f(CW$^O\fR.
.IP "type => \s-1STRING\s0" 2
.IX Item "type => STRING"
Da type which is defined here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  It consistz of a \fItype\fR n' a \fIsub-type\fR,
both case-insensitive.  This module will return lower-case yo, but accept
upper-case.
.RE
.RS 4
.RE
.SS "Attributes"
.IX Subsection "Attributes"
.ie n .IP "$obj\->\fBencoding\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBencoding\fR()" 4
.IX Item "$obj->encoding()"
Returns tha type of encodin which is required ta transhiznit data of this
type safely.
.ie n .IP "$obj\->\fBextensions\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBextensions\fR()" 4
.IX Item "$obj->extensions()"
Returns a list of extensions which is known ta be used fo' this
mime type.
.ie n .IP "$obj\->\fBsimplified\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBsimplified\fR([\s-1STRING\s0])" 4
.IX Item "$obj->simplified([STRING])"
.PD 0
.IP "MIME::Type\->\fBsimplified\fR([\s-1STRING\s0])" 4
.IX Item "MIME::Type->simplified([STRING])"
.PD
Returns tha simplified mime type fo' dis object or tha specified \s-1STRING.\s0
Mime type names can git officially registered. Y'all KNOW dat shit, muthafucka!  Until then, they have to
carry a \f(CW\*(C`x\-\*(C'\fR preamble ta indicate dis shit.  Of course, afta recognition,
the \f(CW\*(C`x\-\*(C'\fR can disappear. Shiiit, dis aint no joke.  In nuff cases, we prefer tha simplified version
of tha type.
.Sp
example: thangs up in dis biatch of \fIsimplified()\fR
.Sp
.Vb 4
\& mah $mime = MIME::Type\->new(type => \*(Aqx\-appl/x\-zip\*(Aq);
\& print $mime\->simplified;                     # \*(Aqappl/zip\*(Aq
\& print $mime\->simplified(\*(Aqtext/plain\*(Aq);       # \*(Aqtext/plain\*(Aq
\& print MIME::Type\->simplified(\*(Aqx\-xyz/x\-abc\*(Aq); # \*(Aqxyz/abc\*(Aq
.Ve
.ie n .IP "$obj\->\fBsystem\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsystem\fR()" 4
.IX Item "$obj->system()"
Returns tha regular expression which can be used ta determine whether this
type be actizzle on tha system where yo ass is hustlin on.
.ie n .IP "$obj\->\fBtype\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtype\fR()" 4
.IX Item "$obj->type()"
Returns tha long type of dis object, fo' instizzle \f(CW\*(Aqtext/plain\*(Aq\fR
.SS "Knowledge"
.IX Subsection "Knowledge"
.ie n .IP "$obj\->\fBequals\fR(STRING|MIME)" 4
.el .IP "\f(CW$obj\fR\->\fBequals\fR(STRING|MIME)" 4
.IX Item "$obj->equals(STRING|MIME)"
Compare dis mime-type object wit a \s-1STRING\s0 or other object.  In case of
a \s-1STRING,\s0 simplification will take place.
.ie n .IP "$obj\->\fBisAscii\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisAscii\fR()" 4
.IX Item "$obj->isAscii()"
Returns false when tha encodin is base64, n' legit otherwise.  All encodings
except base64 is text encodings.
.ie n .IP "$obj\->\fBisBinary\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisBinary\fR()" 4
.IX Item "$obj->isBinary()"
Returns legit when tha encodin is base64.
.ie n .IP "$obj\->\fBisExperimental\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisExperimental\fR()" 4
.IX Item "$obj->isExperimental()"
[2.00] Return \f(CW\*(C`true\*(C'\fR when tha type is defined fo' experimental
use; tha subtype starts wit \f(CW\*(C`x.\*(C'\fR
.ie n .IP "$obj\->\fBisPersonal\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisPersonal\fR()" 4
.IX Item "$obj->isPersonal()"
[2.00] Return \f(CW\*(C`true\*(C'\fR when tha type is defined by a thug for
private use; tha subtype starts wit \f(CW\*(C`prs.\*(C'\fR
.ie n .IP "$obj\->\fBisRegistered\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisRegistered\fR()" 4
.IX Item "$obj->isRegistered()"
Mime-types which is not registered by \s-1IANA\s0 nor defined up in RFCs shall
start wit a \f(CW\*(C`x\-\*(C'\fR.  This counts fo' as well tha media-type as the
sub-type.  In case either one of tha types starts wit \f(CW\*(C`x\-\*(C'\fR this
method will return false.
.ie n .IP "$obj\->\fBisSignature\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisSignature\fR()" 4
.IX Item "$obj->isSignature()"
Returns legit when tha type is up in tha list of known signatures.
.ie n .IP "$obj\->\fBisVendor\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisVendor\fR()" 4
.IX Item "$obj->isVendor()"
[2.00] Return \f(CW\*(C`true\*(C'\fR when tha type is defined by a vendor; tha subtype
starts wit \f(CW\*(C`vnd.\*(C'\fR
.ie n .IP "$obj\->\fBmediaType\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmediaType\fR()" 4
.IX Item "$obj->mediaType()"
Da media type of tha simplified mime.
For \f(CW\*(Aqtext/plain\*(Aq\fR it will return \f(CW\*(Aqtext\*(Aq\fR.
.Sp
For oldschool reasons, tha \f(CW\*(AqmainType\*(Aq\fR method still can be used
to retrieve tha same value.  But fuck dat shiznit yo, tha word on tha street is dat that method is deprecated.
.ie n .IP "$obj\->\fBsubType\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsubType\fR()" 4
.IX Item "$obj->subType()"
Da sub type of tha simplified mime.
For \f(CW\*(Aqtext/plain\*(Aq\fR it will return \f(CW\*(Aqplain\*(Aq\fR.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Type parameta is obligatory." 4
.IX Item "Error: Type parameta is obligatory."
When a MIME::Type object is pimped, tha type itself must be
specified wit tha \f(CW\*(C`type\*(C'\fR option flag.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of MIME-Types distribution version 2.04,
built on September 12, 2013. Website: \fIhttp://perl.overmeer.net/mimetypes/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1999,2001\-2013 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
