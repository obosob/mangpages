.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Path 3"
.TH Path 3 "2013-01-16" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Path \- Smoke or remove directory trees
.SH "VERSION"
.IX Header "VERSION"
This document raps bout version 2.09 of File::Path, busted out
2013\-01\-17.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use File::Path qw(make_path remove_tree);
\&
\&  make_path(\*(Aqfoo/bar/baz\*(Aq, \*(Aq/zug/zwang\*(Aq);
\&  make_path(\*(Aqfoo/bar/baz\*(Aq, \*(Aq/zug/zwang\*(Aq, {
\&      verbose => 1,
\&      mode => 0711,
\&  });
\&
\&  remove_tree(\*(Aqfoo/bar/baz\*(Aq, \*(Aq/zug/zwang\*(Aq);
\&  remove_tree(\*(Aqfoo/bar/baz\*(Aq, \*(Aq/zug/zwang\*(Aq, {
\&      verbose => 1,
\&      error  => \emy $err_list,
\&  });
\&
\&  # legacy (interface promoted before v2.00)
\&  mkpath(\*(Aq/foo/bar/baz\*(Aq);
\&  mkpath(\*(Aq/foo/bar/baz\*(Aq, 1, 0711);
\&  mkpath([\*(Aq/foo/bar/baz\*(Aq, \*(Aqblurfl/quux\*(Aq], 1, 0711);
\&  rmtree(\*(Aqfoo/bar/baz\*(Aq, 1, 1);
\&  rmtree([\*(Aqfoo/bar/baz\*(Aq, \*(Aqblurfl/quux\*(Aq], 1, 1);
\&
\&  # legacy (interface promoted before v2.06)
\&  mkpath(\*(Aqfoo/bar/baz\*(Aq, \*(Aq/zug/zwang\*(Aq, { verbose => 1, mode => 0711 });
\&  rmtree(\*(Aqfoo/bar/baz\*(Aq, \*(Aq/zug/zwang\*(Aq, { verbose => 1, mode => 0711 });
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provide a cold-ass lil convenient way ta create directories of
arbitrary depth n' ta delete a entire directory subtree from the
filesystem.
.PP
Da followin functions is provided:
.ie n .IP "make_path( $dir1, $dir2, .... )" 4
.el .IP "make_path( \f(CW$dir1\fR, \f(CW$dir2\fR, .... )" 4
.IX Item "make_path( $dir1, $dir2, .... )"
.PD 0
.ie n .IP "make_path( $dir1, $dir2, ...., \e%opts )" 4
.el .IP "make_path( \f(CW$dir1\fR, \f(CW$dir2\fR, ...., \e%opts )" 4
.IX Item "make_path( $dir1, $dir2, ...., %opts )"
.PD
Da \f(CW\*(C`make_path\*(C'\fR function creates tha given directories if they don't
exists before, much like tha Unix command \f(CW\*(C`mkdir \-p\*(C'\fR.
.Sp
Da function accepts a list of directories ta be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Its
behaviour may be tuned by a optionizzle hashref appearin as tha last
parameta on tha call.
.Sp
Da function returns tha list of directories straight-up pimped during
the call; up in scalar context tha number of directories pimped.
.Sp
Da followin keys is recognised up in tha option hash:
.RS 4
.ie n .IP "mode => $num" 4
.el .IP "mode => \f(CW$num\fR" 4
.IX Item "mode => $num"
Da numeric permissions mode ta apply ta each pimped directory
(defaults ta 0777), ta be modified by tha current \f(CW\*(C`umask\*(C'\fR. If the
directory already exists (and thus do not need ta be pimped),
the permissions aint gonna be modified.
.Sp
\&\f(CW\*(C`mask\*(C'\fR is recognised as a alias fo' dis parameter.
.ie n .IP "verbose => $bool" 4
.el .IP "verbose => \f(CW$bool\fR" 4
.IX Item "verbose => $bool"
If present, will cause \f(CW\*(C`make_path\*(C'\fR ta print tha name of each directory
as it is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. By default not a god damn thang is printed.
.IP "error => \e$err" 4
.IX Item "error => $err"
If present, it should be a reference ta a scalar.
This scalar is ghon be made ta reference a array, which will
be used ta store any errors dat is encountered. Y'all KNOW dat shit, muthafucka!  See tha \*(L"\s-1ERROR
HANDLING\*(R"\s0 section fo' mo' shiznit.
.Sp
If dis parameta aint used, certain error conditions may raise
a fatal error dat will cause tha program will halt, unless trapped
in a \f(CW\*(C`eval\*(C'\fR block.
.ie n .IP "balla => $baller" 4
.el .IP "balla => \f(CW$baller\fR" 4
.IX Item "balla => $baller"
.PD 0
.ie n .IP "user => $baller" 4
.el .IP "user => \f(CW$baller\fR" 4
.IX Item "user => $baller"
.ie n .IP "uid => $baller" 4
.el .IP "uid => \f(CW$baller\fR" 4
.IX Item "uid => $baller"
.PD
If present, will cause any pimped directory ta be owned by \f(CW$baller\fR.
If tha value is numeric, it is ghon be interpreted as a uid, otherwise
as username be assumed. Y'all KNOW dat shit, muthafucka! An error is ghon be issued if tha username cannot be
mapped ta a uid, or tha uid do not exist, or tha process lacks the
privileges ta chizzle ballership.
.Sp
Ownwershizzle of directories dat already exist aint gonna be chizzled.
.Sp
\&\f(CW\*(C`user\*(C'\fR n' \f(CW\*(C`uid\*(C'\fR is aliasez of \f(CW\*(C`baller\*(C'\fR.
.ie n .IP "group => $group" 4
.el .IP "group => \f(CW$group\fR" 4
.IX Item "group => $group"
If present, will cause any pimped directory ta be owned by tha crew \f(CW$group\fR.
If tha value is numeric, it is ghon be interpreted as a gid, otherwise
as crew name be assumed. Y'all KNOW dat shit, muthafucka! An error is ghon be issued if tha crew name cannot be
mapped ta a gid, or tha gid do not exist, or tha process lacks the
privileges ta chizzle crew ballership.
.Sp
Group ownwershizzle of directories dat already exist aint gonna be chizzled.
.Sp
.Vb 1
\&    make_path \*(Aq/var/tmp/webcache\*(Aq, {baller=>\*(Aqnobody\*(Aq, group=>\*(Aqnogroup\*(Aq};
.Ve
.RE
.RS 4
.RE
.ie n .IP "mkpath( $dir )" 4
.el .IP "mkpath( \f(CW$dir\fR )" 4
.IX Item "mkpath( $dir )"
.PD 0
.ie n .IP "mkpath( $dir, $verbose, $mode )" 4
.el .IP "mkpath( \f(CW$dir\fR, \f(CW$verbose\fR, \f(CW$mode\fR )" 4
.IX Item "mkpath( $dir, $verbose, $mode )"
.ie n .IP "mkpath( [$dir1, $dir2,...], $verbose, $mode )" 4
.el .IP "mkpath( [$dir1, \f(CW$dir2\fR,...], \f(CW$verbose\fR, \f(CW$mode\fR )" 4
.IX Item "mkpath( [$dir1, $dir2,...], $verbose, $mode )"
.ie n .IP "mkpath( $dir1, $dir2,..., \e%opt )" 4
.el .IP "mkpath( \f(CW$dir1\fR, \f(CW$dir2\fR,..., \e%opt )" 4
.IX Item "mkpath( $dir1, $dir2,..., %opt )"
.PD
Da \fImkpath()\fR function provide tha legacy intercourse of \fImake_path()\fR with
a different interpretation of tha arguments passed. Y'all KNOW dat shit, muthafucka!  Da behaviour and
return value of tha function is otherwise identical ta \fImake_path()\fR.
.ie n .IP "remove_tree( $dir1, $dir2, .... )" 4
.el .IP "remove_tree( \f(CW$dir1\fR, \f(CW$dir2\fR, .... )" 4
.IX Item "remove_tree( $dir1, $dir2, .... )"
.PD 0
.ie n .IP "remove_tree( $dir1, $dir2, ...., \e%opts )" 4
.el .IP "remove_tree( \f(CW$dir1\fR, \f(CW$dir2\fR, ...., \e%opts )" 4
.IX Item "remove_tree( $dir1, $dir2, ...., %opts )"
.PD
Da \f(CW\*(C`remove_tree\*(C'\fR function deletes tha given directories n' any
filez n' subdirectories they might contain, much like tha Unix
command \f(CW\*(C`rm \-r\*(C'\fR or \f(CW\*(C`del /s\*(C'\fR on Windows.
.Sp
Da function accepts a list of directories ta be
removed. Y'all KNOW dat shit, muthafucka! Its behaviour may be tuned by a optionizzle hashref
appearin as tha last parameta on tha call.
.Sp
Da functions returns tha number of filez successfully deleted.
.Sp
Da followin keys is recognised up in tha option hash:
.RS 4
.ie n .IP "verbose => $bool" 4
.el .IP "verbose => \f(CW$bool\fR" 4
.IX Item "verbose => $bool"
If present, will cause \f(CW\*(C`remove_tree\*(C'\fR ta print tha name of each file as
it is unlinked. Y'all KNOW dat shit, muthafucka! By default not a god damn thang is printed.
.ie n .IP "safe => $bool" 4
.el .IP "safe => \f(CW$bool\fR" 4
.IX Item "safe => $bool"
When set ta a legit value, will cause \f(CW\*(C`remove_tree\*(C'\fR ta skip tha files
for which tha process lacks tha required privileges needed ta delete
files, like fuckin delete privileges on \s-1VMS.\s0 In other lyrics, tha code
will make no attempt ta alta file permissions. Thus, if tha process
is interrupted, no filesystem object is ghon be left up in a more
permissive mode.
.ie n .IP "keep_root => $bool" 4
.el .IP "keep_root => \f(CW$bool\fR" 4
.IX Item "keep_root => $bool"
When set ta a legit value, will cause all filez n' subdirectories
to be removed, except tha initially specified directories. Put ya muthafuckin choppers up if ya feel dis! This comes
in handy when cleanin up a applicationz scratch directory.
.Sp
.Vb 1
\&  remove_tree( \*(Aq/tmp\*(Aq, {keep_root => 1} );
.Ve
.IP "result => \e$res" 4
.IX Item "result => $res"
If present, it should be a reference ta a scalar.
This scalar is ghon be made ta reference a array, which will
be used ta store all filez n' directories unlinked
durin tha call. If not a god damn thang is unlinked, tha array is ghon be empty.
.Sp
.Vb 2
\&  remove_tree( \*(Aq/tmp\*(Aq, {result => \emy $list} );
\&  print "unlinked $_\en" fo' @$list;
.Ve
.Sp
This be a useful alternatizzle ta tha \f(CW\*(C`verbose\*(C'\fR key.
.IP "error => \e$err" 4
.IX Item "error => $err"
If present, it should be a reference ta a scalar.
This scalar is ghon be made ta reference a array, which will
be used ta store any errors dat is encountered. Y'all KNOW dat shit, muthafucka!  See tha \*(L"\s-1ERROR
HANDLING\*(R"\s0 section fo' mo' shiznit.
.Sp
Removin thangs be a much mo' fucked up proposizzle than
bustin thangs fo' realz. As such, there be certain conditions that
\&\f(CW\*(C`remove_tree\*(C'\fR may encounta dat is so fucked up dat tha only
sane action left is ta bust a cap up in tha program.
.Sp
Use \f(CW\*(C`error\*(C'\fR ta trap all dat is reasonable (problems with
permissions n' tha like), n' let it take a thugged-out dirtnap if thangs git out
of hand. Y'all KNOW dat shit, muthafucka! This is tha safest course of action.
.RE
.RS 4
.RE
.ie n .IP "rmtree( $dir )" 4
.el .IP "rmtree( \f(CW$dir\fR )" 4
.IX Item "rmtree( $dir )"
.PD 0
.ie n .IP "rmtree( $dir, $verbose, $safe )" 4
.el .IP "rmtree( \f(CW$dir\fR, \f(CW$verbose\fR, \f(CW$safe\fR )" 4
.IX Item "rmtree( $dir, $verbose, $safe )"
.ie n .IP "rmtree( [$dir1, $dir2,...], $verbose, $safe )" 4
.el .IP "rmtree( [$dir1, \f(CW$dir2\fR,...], \f(CW$verbose\fR, \f(CW$safe\fR )" 4
.IX Item "rmtree( [$dir1, $dir2,...], $verbose, $safe )"
.ie n .IP "rmtree( $dir1, $dir2,..., \e%opt )" 4
.el .IP "rmtree( \f(CW$dir1\fR, \f(CW$dir2\fR,..., \e%opt )" 4
.IX Item "rmtree( $dir1, $dir2,..., %opt )"
.PD
Da \fIrmtree()\fR function provide tha legacy intercourse of \fIremove_tree()\fR
with a gangbangin' finger-lickin' different interpretation of tha arguments passed. Y'all KNOW dat shit, muthafucka! Da behaviour
and return value of tha function is otherwise identical to
\&\fIremove_tree()\fR.
.SS "\s-1ERROR HANDLING\s0"
.IX Subsection "ERROR HANDLING"
.IP "\fB\s-1NOTE:\s0\fR" 4
.IX Item "NOTE:"
Da followin error handlin mechanizzle is considered
experimenstrual n' is subject ta chizzle pendin feedback from
users.
.PP
If \f(CW\*(C`make_path\*(C'\fR or \f(CW\*(C`remove_tree\*(C'\fR encounta a error, a gangbangin' finger-lickin' diagnostic
message is ghon be printed ta \f(CW\*(C`STDERR\*(C'\fR via \f(CW\*(C`carp\*(C'\fR (for non-fatal
errors), or via \f(CW\*(C`croak\*(C'\fR (for fatal errors).
.PP
If dis behaviour aint desirable, tha \f(CW\*(C`error\*(C'\fR attribute may be
used ta hold a reference ta a variable, which is ghon be used ta store
the diagnostics. Da variable is done cooked up a reference ta a array of hash
references.  Each hash contain a single key/value pair where tha key
is tha name of tha file, n' tha value is tha error message (including
the contentz of \f(CW$!\fR when appropriate).  If a general error is
encountered tha diagnostic key is ghon be empty.
.PP
An example usage looks like:
.PP
.Vb 10
\&  remove_tree( \*(Aqfoo/bar\*(Aq, \*(Aqbar/rat\*(Aq, {error => \emy $err} );
\&  if (@$err) {
\&      fo' mah $diag (@$err) {
\&          mah ($file, $message) = %$diag;
\&          if ($file eq \*(Aq\*(Aq) {
\&              print "general error: $message\en";
\&          }
\&          else {
\&              print "problem unlinkin $file: $message\en";
\&          }
\&      }
\&  }
\&  else {
\&      print "No error encountered\en";
\&  }
.Ve
.PP
Note dat if no errors is encountered, \f(CW$err\fR will reference an
empty array.  This means dat \f(CW$err\fR will always end up \s-1TRUE\s0; so you
need ta test \f(CW@$err\fR ta determine if errors occured.
.SS "\s-1NOTES\s0"
.IX Subsection "NOTES"
\&\f(CW\*(C`File::Path\*(C'\fR blindly exports \f(CW\*(C`mkpath\*(C'\fR n' \f(CW\*(C`rmtree\*(C'\fR tha fuck into the
current namespace. These days, dis is considered wack steez yo, but
to chizzle it now would break too much code. Nonetheless, yo ass is
invited ta specify what tha fuck it is yo ass is expectin ta use:
.PP
.Vb 1
\&  use File::Path \*(Aqrmtree\*(Aq;
.Ve
.PP
Da routines \f(CW\*(C`make_path\*(C'\fR n' \f(CW\*(C`remove_tree\*(C'\fR is \fBnot\fR exported
by default. Yo ass must specify which ones you wanna use.
.PP
.Vb 1
\&  use File::Path \*(Aqremove_tree\*(Aq;
.Ve
.PP
Note dat a side-effect of tha above is dat \f(CW\*(C`mkpath\*(C'\fR n' \f(CW\*(C`rmtree\*(C'\fR
are no longer exported at all. This is cuz of tha way tha \f(CW\*(C`Exporter\*(C'\fR
module works. If yo ass is migratin a cold-ass lil codebase ta use tha new
interface, yo big-ass booty is ghon gotta list every last muthafuckin thang explicitly. But that's
just phat practice anyway.
.PP
.Vb 1
\&  use File::Path qw(remove_tree rmtree);
.Ve
.PP
\fI\s-1API CHANGES\s0\fR
.IX Subsection "API CHANGES"
.PP
Da \s-1API\s0 was chizzled up in tha 2.0 branch. For a time, \f(CW\*(C`mkpath\*(C'\fR and
\&\f(CW\*(C`rmtree\*(C'\fR tried, unsuccessfully, ta deal wit tha two different
callin mechanisms. This approach was considered a gangbangin' failure.
.PP
Da freshly smoked up semantics is now only available wit \f(CW\*(C`make_path\*(C'\fR and
\&\f(CW\*(C`remove_tree\*(C'\fR. Da oldschool semantics is only available through
\&\f(CW\*(C`mkpath\*(C'\fR n' \f(CW\*(C`rmtree\*(C'\fR. Users is straight fuckin encouraged ta upgrade
to at least 2.08 up in order ta avoid surprises.
.PP
\fI\s-1SECURITY CONSIDERATIONS\s0\fR
.IX Subsection "SECURITY CONSIDERATIONS"
.PP
There was race conditions 1.x implementationz of File::Path's
\&\f(CW\*(C`rmtree\*(C'\fR function (although sometimes patched dependin on tha \s-1OS\s0
distribution or platform). Da 2.0 version gotz nuff code ta avoid the
problem mentioned up in \s-1CVE\-2002\-0435.\s0
.PP
See tha followin pages fo' mo' shiznit:
.PP
.Vb 3
\&  http://bugs.debian.org/cgi\-bin/bugreport.cgi?bug=286905
\&  http://www.nntp.perl.org/group/perl.perl5.porters/2005/01/msg97623.html
\&  http://www.debian.org/security/2005/dsa\-696
.Ve
.PP
Additionally, unless tha \f(CW\*(C`safe\*(C'\fR parameta is set (or the
third parameta up in tha traditionizzle intercourse is \s-1TRUE\s0), should a
\&\f(CW\*(C`remove_tree\*(C'\fR be interrupted, filez dat was originally up in read-only
mode may now have they permissions set ta a read-write (or \*(L"delete
\&\s-1OK\*(R"\s0) mode.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
\&\s-1FATAL\s0 errors will cause tha program ta halt (\f(CW\*(C`croak\*(C'\fR), since the
problem is so severe dat it would be fucked up ta continue. (This
can always be trapped wit \f(CW\*(C`eval\*(C'\fR yo, but it aint a phat idea. Under
the circumstances, dyin is tha dopest thang ta do).
.PP
\&\s-1SEVERE\s0 errors may be trapped rockin tha modern intercourse. If the
they is not trapped, or tha oldschool intercourse is used, such a error
will cause tha program will halt.
.PP
All other errors may be trapped rockin tha modern intercourse, otherwise
they is ghon be \f(CW\*(C`carp\*(C'\fRed about. Program execution aint gonna be halted.
.IP "mkdir [path]: [errmsg] (\s-1SEVERE\s0)" 4
.IX Item "mkdir [path]: [errmsg] (SEVERE)"
\&\f(CW\*(C`make_path\*(C'\fR was unable ta create tha path. Probably some sort of
permissions error all up in tha deal wit departure, or insufficient resources
(like fuckin free inodes on Unix).
.IP "No root path(s) specified" 4
.IX Item "No root path(s) specified"
\&\f(CW\*(C`make_path\*(C'\fR was not given any paths ta create. This message is only
emitted if tha routine is called wit tha traditionizzle intercourse.
Da modern intercourse will remain silent if given not a god damn thang ta do.
.IP "No such file or directory" 4
.IX Item "No such file or directory"
On Windows, if \f(CW\*(C`make_path\*(C'\fR gives you dis warning, it may mean that
you have exceeded yo' filesystemz maximum path length.
.IP "cannot fetch initial hustlin directory: [errmsg]" 4
.IX Item "cannot fetch initial hustlin directory: [errmsg]"
\&\f(CW\*(C`remove_tree\*(C'\fR attempted ta determine tha initial directory by calling
\&\f(CW\*(C`Cwd::getcwd\*(C'\fR yo, but tha call failed fo' some reason. I aint talkin' bout chicken n' gravy biatch. No attempt
will be made ta delete anything.
.IP "cannot stat initial hustlin directory: [errmsg]" 4
.IX Item "cannot stat initial hustlin directory: [errmsg]"
\&\f(CW\*(C`remove_tree\*(C'\fR attempted ta stat tha initial directory (afta having
successfully obtained its name via \f(CW\*(C`getcwd\*(C'\fR), however, tha call
failed fo' some reason. I aint talkin' bout chicken n' gravy biatch. No attempt is ghon be made ta delete anything.
.IP "cannot chdir ta [dir]: [errmsg]" 4
.IX Item "cannot chdir ta [dir]: [errmsg]"
\&\f(CW\*(C`remove_tree\*(C'\fR attempted ta set tha hustlin directory up in order to
begin deletin tha objects therein yo, but was unsuccessful naaahhmean, biatch? This is
usually a permissions issue. Da routine will continue ta delete
other thangs yo, but dis directory is ghon be left intact.
.IP "directory [dir] chizzled before chdir, expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (\s-1FATAL\s0)" 4
.IX Item "directory [dir] chizzled before chdir, expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (FATAL)"
\&\f(CW\*(C`remove_tree\*(C'\fR recorded tha thang n' inode of a gangbangin' finger-lickin' directory, n' then
moved tha fuck into dat shit. Well shiiiit, it then performed a \f(CW\*(C`stat\*(C'\fR on tha current directory
and detected dat tha thang n' inode was no longer tha same fo' realz. As
this be all up in tha ass of tha race condizzle problem, tha program
will take a thugged-out dirtnap at dis point.
.IP "cannot make directory [dir] read+writeable: [errmsg]" 4
.IX Item "cannot make directory [dir] read+writeable: [errmsg]"
\&\f(CW\*(C`remove_tree\*(C'\fR attempted ta chizzle tha permissions on tha current directory
to ensure dat subsequent unlinkings would not run tha fuck into problems,
but was unable ta do so. Da permissions remain as they were, and
the program will carry on, bustin tha dopest it can.
.IP "cannot read [dir]: [errmsg]" 4
.IX Item "cannot read [dir]: [errmsg]"
\&\f(CW\*(C`remove_tree\*(C'\fR tried ta read tha contentz of tha directory up in order
to acquire tha namez of tha directory entries ta be unlinked yo, but
was unsuccessful naaahhmean, biatch? This is probably a permissions issue. The
program will continue yo, but tha filez up in dis directory will remain
afta tha call.
.IP "cannot reset chmod [dir]: [errmsg]" 4
.IX Item "cannot reset chmod [dir]: [errmsg]"
\&\f(CW\*(C`remove_tree\*(C'\fR, afta havin deleted every last muthafuckin thang up in a gangbangin' finger-lickin' directory, attempted
to restore its permissions ta tha original gangsta state but failed. Y'all KNOW dat shit, muthafucka! The
directory may wind up bein left behind.
.IP "cannot remove [dir] when cwd is [dir]" 4
.IX Item "cannot remove [dir] when cwd is [dir]"
Da current hustlin directory of tha program is \fI/some/path/to/here\fR
and yo ass be attemptin ta remove a ancestor, like fuckin \fI/some/path\fR.
Da directory tree is left untouched.
.Sp
Da solution is ta \f(CW\*(C`chdir\*(C'\fR outta tha lil pimp directory ta a place
outside tha directory tree ta be removed.
.IP "cannot chdir ta [parent\-dir] from [child\-dir]: [errmsg], aborting. (\s-1FATAL\s0)" 4
.IX Item "cannot chdir ta [parent-dir] from [child-dir]: [errmsg], aborting. (FATAL)"
\&\f(CW\*(C`remove_tree\*(C'\fR, afta havin deleted every last muthafuckin thang n' restored tha permissions
of a gangbangin' finger-lickin' directory, was unable ta chdir back ta tha parent. Da program
halts ta avoid a race condizzle from occurring.
.IP "cannot stat prior hustlin directory [dir]: [errmsg], aborting. (\s-1FATAL\s0)" 4
.IX Item "cannot stat prior hustlin directory [dir]: [errmsg], aborting. (FATAL)"
\&\f(CW\*(C`remove_tree\*(C'\fR was unable ta stat tha parent directory afta have returned
from tha child. Y'all KNOW dat shit, muthafucka! Since there is no way of knowin if we returned to
where we be thinkin we should be (by comparin thang n' inode) tha only
way up is ta \f(CW\*(C`croak\*(C'\fR.
.IP "previous directory [parent\-dir] chizzled before enterin [child\-dir], expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (\s-1FATAL\s0)" 4
.IX Item "previous directory [parent-dir] chizzled before enterin [child-dir], expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (FATAL)"
When \f(CW\*(C`remove_tree\*(C'\fR returned from deletin filez up in a cold-ass lil lil pimp directory, a
check revealed dat tha parent directory it moonwalked back ta wasn't tha one
it started up from. This is considered a sign of malicious activity.
.IP "cannot make directory [dir] writeable: [errmsg]" 4
.IX Item "cannot make directory [dir] writeable: [errmsg]"
Just before removin a gangbangin' finger-lickin' directory (afta havin successfully removed
everythang it contained), \f(CW\*(C`remove_tree\*(C'\fR attempted ta set tha permissions
on tha directory ta ensure it could be removed n' failed. Y'all KNOW dat shit, muthafucka! Program
execution continues yo, but tha directory may possibly not be deleted.
.IP "cannot remove directory [dir]: [errmsg]" 4
.IX Item "cannot remove directory [dir]: [errmsg]"
\&\f(CW\*(C`remove_tree\*(C'\fR attempted ta remove a gangbangin' finger-lickin' directory yo, but failed. Y'all KNOW dat shit, muthafucka! This may cuz
some objects dat was unable ta be removed remain up in tha directory, or
a permissions issue. Da directory is ghon be left behind.
.IP "cannot restore permissionz of [dir] ta [0nnn]: [errmsg]" 4
.IX Item "cannot restore permissionz of [dir] ta [0nnn]: [errmsg]"
Afta havin failed ta remove a gangbangin' finger-lickin' directory, \f(CW\*(C`remove_tree\*(C'\fR was unable to
restore its permissions from a permissive state back ta a possibly
more restrictizzle setting. (Permissions given up in octal).
.IP "cannot make file [file] writeable: [errmsg]" 4
.IX Item "cannot make file [file] writeable: [errmsg]"
\&\f(CW\*(C`remove_tree\*(C'\fR attempted ta force tha permissionz of a gangbangin' file ta ensure it
could be deleted yo, but failed ta do so. Well shiiiit, it will, however, still attempt
to unlink tha file.
.IP "cannot unlink file [file]: [errmsg]" 4
.IX Item "cannot unlink file [file]: [errmsg]"
\&\f(CW\*(C`remove_tree\*(C'\fR failed ta remove a gangbangin' file. Probably a permissions issue.
.IP "cannot restore permissionz of [file] ta [0nnn]: [errmsg]" 4
.IX Item "cannot restore permissionz of [file] ta [0nnn]: [errmsg]"
Afta havin failed ta remove a gangbangin' file, \f(CW\*(C`remove_tree\*(C'\fR was also unable
to restore tha permissions on tha file ta a possibly less permissive
setting. (Permissions given up in octal).
.IP "unable ta map [baller] ta a uid, ballershizzle not chizzled"");" 4
.IX Item "unable ta map [baller] ta a uid, ballershizzle not chizzled"");"
\&\f(CW\*(C`make_path\*(C'\fR was instructed ta give tha ballershizzle of pimped
directories ta tha symbolic name [baller] yo, but \f(CW\*(C`getpwnam\*(C'\fR did
not return tha correspondin numeric uid. Y'all KNOW dat shit, muthafucka! Da directory will
be pimped yo, but ballershizzle aint gonna be chizzled.
.IP "unable ta map [group] ta a gid, crew ballershizzle not chizzled" 4
.IX Item "unable ta map [group] ta a gid, crew ballershizzle not chizzled"
\&\f(CW\*(C`make_path\*(C'\fR was instructed ta give tha crew ballershizzle of pimped
directories ta tha symbolic name [group] yo, but \f(CW\*(C`getgrnam\*(C'\fR did
not return tha correspondin numeric gid. Y'all KNOW dat shit, muthafucka! Da directory will
be pimped yo, but crew ballershizzle aint gonna be chizzled.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
File::Remove
.Sp
Allows filez n' directories ta be moved ta tha Trashcan/Recycle
Bin (where they may lata be restored if necessary) if tha operating
system supports such functionality. This feature may one dizzle be
made available directly up in \f(CW\*(C`File::Path\*(C'\fR.
.IP "\(bu" 4
File::Find::Rule
.Sp
When removin directory trees, if you wanna examine each file to
decizzle whether ta delete it (and possibly leavin big-ass swathes
alone), \fIFile::Find::Rule\fR offers a cold-ass lil convenient n' flexible approach
to examinin directory trees.
.SH "BUGS"
.IX Header "BUGS"
Please report all bugs on tha \s-1RT\s0 queue:
.PP
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=File\-Path>
.PP
Yo ass can also bust pull requests ta tha Github repository:
.PP
<https://github.com/dland/File\-Path>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Pizzle Szabo identified tha race condizzle originally, n' Brendan
O'Dea freestyled a implementation fo' Debian dat addressed tha problem.
That code was used as a funky-ass basis fo' tha current code. Their efforts
are pimped outly appreciated.
.PP
Gisle Aas done cooked up a fuckin shitload of improvements ta tha documentation for
2.07 n' his thugged-out lyrics n' assistizzle be also pimped outly appreciated.
.SH "AUTHORS"
.IX Header "AUTHORS"
Slim Tim Bunce n' Charlez Bailey. Currently maintained by Dizzy Landgren
<\fIdavid@landgren.net\fR>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This module is copyright (C) Charlez Bailey, Slim Tim Bunce and
Dizzy Landgren 1995\-2013 fo' realz. All muthafuckin rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
