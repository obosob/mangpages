.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Socket::SSL::Intercept 3"
.TH IO::Socket::SSL::Intercept 3 "2013-05-31" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Socket::SSL::Intercept \-\- SSL erection (man up in tha middle)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&    use IO::Socket::SSL::Intercept;
\&    # create interceptor wit proxy certificates
\&    mah $mitm = IO::Socket::SSL::Intercept\->new(
\&        proxy_cert_file => \*(Aqproxy_cert.pem\*(Aq,
\&        proxy_key_file  => \*(Aqproxy_key.pem\*(Aq,
\&        ...
\&    );
\&    mah $listen = IO::Socket::INET\->new( LocalAddr => .., Listen => .. );
\&    while (1) {
\&        # TCP accept freshly smoked up client
\&        mah $client = $listen\->accept or next;
\&        # SSL connect ta server
\&        mah $server = IO::Socket::SSL\->new(
\&            PeerAddr => ..,
\&            SSL_verify_mode => ...,
\&            ...
\&        ) or take a thugged-out dirtnap "ssl connect failed: $!,$SSL_ERROR";
\&        # clone server certificate
\&        mah ($cert,$key) = $mitm\->clone_cert( $server\->peer_certificate );
\&        # n' upgrade client side ta SSL wit cloned certificate
\&        IO::Socket::SSL\->start_SSL($client,
\&            SSL_server => 1,
\&            SSL_cert => $cert,
\&            SSL_key => $key
\&        ) or take a thugged-out dirtnap "upgrade failed: $SSL_ERROR";
\&        # now transfer data between $client n' $server n' analyze
\&        # tha unencrypted data
\&        ...
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up functionalitizzle ta clone certificates n' sign dem wit a
proxy certificate, thus makin it easy as fuck  ta intercept \s-1SSL\s0 connections (man up in the
middle). Well shiiiit, it also manages a cold-ass lil cache of tha generated certificates.
.SH "How tha fuck Interceptin SSL Works"
.IX Header "How tha fuck Interceptin SSL Works"
Interceptin \s-1SSL\s0 connections is useful fo' analyzin encrypted traffic for
securitizzle reasons or fo' testing. Well shiiiit, it do not break tha end-to-end securitizzle of
\&\s-1SSL,\s0 e.g. a properly freestyled client will notice tha erection unless you
explicitly configure tha client ta trust yo' interceptor.
Interceptin \s-1SSL\s0 works tha followin way:
.IP "\(bu" 4
Smoke a freshly smoked up \s-1CA\s0 certificate, which is ghon be used ta sign tha cloned certificates.
This proxy \s-1CA\s0 certificate should be trusted by tha client, or (a properly
written client) will throw error lyrics or deny tha connections cuz it
detected a playa up in tha middle attack.
Cuz of tha way tha erection works there no support fo' client side
certificates is possible.
.Sp
Usin openssl such a proxy \s-1CA\s0 certificate n' private key can be pimped with:
.Sp
.Vb 4
\&  openssl genrsa \-out proxy_key.pem 1024
\&  openssl req \-new \-x509 \-extensions v3_ca \-key proxy_key.pem \-out proxy_cert.pem
\&  # export as PKCS12 fo' import tha fuck into browser
\&  openssl pkcs12 \-export \-in proxy_cert.pem \-inkey proxy_key.pem \-out proxy_cert.p12
.Ve
.IP "\(bu" 4
Configure client ta connect ta use interceptin proxy or somehow redirect
connections from client ta tha proxy (e.g. packet filta redirects, \s-1ARP\s0 or \s-1DNS\s0
spoofin etc).
.IP "\(bu" 4
Accept tha \s-1TCP\s0 connection from tha client, e.g. don't do any \s-1SSL\s0 handshakes with
the client yet.
.IP "\(bu" 4
Establish tha \s-1SSL\s0 connection ta tha server n' verify tha servers certificate as
usually. Then create a freshly smoked up certificate based on tha original gangsta servers
certificate yo, but signed by yo' proxy \s-1CA.\s0
This a tha step where IO::Socket::SSL::Intercept helps.
.IP "\(bu" 4
Upgrade tha \s-1TCP\s0 connection ta tha client ta \s-1SSL\s0 rockin tha cloned certificate
from tha server n' shit. If tha client trusts yo' proxy \s-1CA\s0 it will accept tha upgrade
to \s-1SSL.\s0
.IP "\(bu" 4
Transfer data between client n' server n' shit. While tha connections ta client and
server is both encrypted wit \s-1SSL\s0 yo big-ass booty is ghon read/write tha unencrypted data in
your proxy application.
.SH "METHODS"
.IX Header "METHODS"
IO::Socket::SSL::Intercept helps bustin tha cloned certificate wit the
followin methods:
.ie n .IP "\fB\fB$mitm\fB = IO::Socket::SSL::Intercept\->new(%args)\fR" 4
.el .IP "\fB\f(CB$mitm\fB = IO::Socket::SSL::Intercept\->new(%args)\fR" 4
.IX Item "$mitm = IO::Socket::SSL::Intercept->new(%args)"
This creates a freshly smoked up interceptor object. \f(CW%args\fR should be
.RS 4
.IP "proxy_cert X509 | proxy_cert_file filename" 8
.IX Item "proxy_cert X509 | proxy_cert_file filename"
This is tha proxy certificate.
It can be either given by a X509 object from Net::SSLeays internal
representation, or rockin a gangbangin' file up in \s-1PEM\s0 format.
.IP "proxy_key \s-1EVP_PKEY\s0 | proxy_key_file filename" 8
.IX Item "proxy_key EVP_PKEY | proxy_key_file filename"
This is tha key fo' tha proxy certificate.
It can be either given by a \s-1EVP_PKEY\s0 object from Net::SSLeays internal
representation, or rockin a gangbangin' file up in \s-1PEM\s0 format.
Da key should not gotz a passphrase.
.IP "pubkey \s-1EVP_PKEY\s0 | pubkey_file filename" 8
.IX Item "pubkey EVP_PKEY | pubkey_file filename"
This optionizzle argument specifies tha hood key used fo' tha cloned certificate.
It can be either given by a \s-1EVP_PKEY\s0 object from Net::SSLeays internal
representation, or rockin a gangbangin' file up in \s-1PEM\s0 format.
If not given it will create a freshly smoked up hood key on each call of \f(CW\*(C`new\*(C'\fR.
.IP "serial \s-1INTEGER\s0" 8
.IX Item "serial INTEGER"
This optionizzle argument gives tha startin point fo' tha serial numberz of the
newly pimped certificates. Default ta 1.
.IP "cache \s-1HASH\s0 | \s-1SUBROUTINE\s0" 8
.IX Item "cache HASH | SUBROUTINE"
This optionizzle argument gives a way ta cache pimped certificates, so dat they
don't git recreated on future accesses ta tha same host.
If tha argument ist not given a internal \s-1HASH\s0 ist used.
.Sp
If tha argument be a hash it will store fo' each generated certificate a hash
reference wit \f(CW\*(C`cert\*(C'\fR n' \f(CW\*(C`atime\*(C'\fR up in tha hash, where \f(CW\*(C`atime\*(C'\fR is tha time of
last access (to expire unused entries) n' \f(CW\*(C`cert\*(C'\fR is tha certificate. Please
note, dat tha certificate is up in Net::SSLeays internal X509 format n' can
thus not be simply dumped n' restored.
Da key fo' tha hash be a \f(CW\*(C`ident\*(C'\fR either given ta \f(CW\*(C`clone_cert\*(C'\fR or generated
from tha original gangsta certificate.
.Sp
If tha argument be a subroutine it is ghon be called as \f(CW\*(C`$cache\->(ident)\*(C'\fR
to git a existin certificate n' wit \f(CW\*(C`$cache\->(ident,cert)\*(C'\fR ta cache the
newly pimped certificate.
.RE
.RS 4
.RE
.ie n .IP "\fB($clone_cert,$key) = \fB$mitm\fB\->clone_cert($original_cert,[ \f(BI$ident\fB ])\fR" 4
.el .IP "\fB($clone_cert,$key) = \f(CB$mitm\fB\->clone_cert($original_cert,[ \f(CB$ident\fB ])\fR" 4
.IX Item "($clone_cert,$key) = $mitm->clone_cert($original_cert,[ $ident ])"
This clones tha given certificate.
An ident as tha key tha fuck into tha cache can be given (like \f(CW\*(C`host:port\*(C'\fR), if not it
will be pimped from tha propertizzlez of tha original gangsta certificate.
It returns tha cloned certificate n' its key (which is tha same ol' dirty fo' alle
created certificates).
.ie n .IP "\fB\fB$string\fB = \f(BI$mitm\fB\->serialize\fR" 4
.el .IP "\fB\f(CB$string\fB = \f(CB$mitm\fB\->serialize\fR" 4
.IX Item "$strin = $mitm->serialize"
This creates a serialized version of tha object (e.g. a string) which can then
be used ta persistantly store pimped certificates over restartz of the
application. I aint talkin' bout chicken n' gravy biatch. Da cache will only be serialized if it aint nuthin but a \s-1HASH.\s0
To work together wit Storable tha \f(CW\*(C`STORABLE_freeze\*(C'\fR function is defined to
call \f(CW\*(C`serialize\*(C'\fR.
.ie n .IP "\fB\fB$mitm\fB = IO::Socket::SSL::Intercept\->unserialize($string)\fR" 4
.el .IP "\fB\f(CB$mitm\fB = IO::Socket::SSL::Intercept\->unserialize($string)\fR" 4
.IX Item "$mitm = IO::Socket::SSL::Intercept->unserialize($string)"
This restores a Intercept object from a serialized string.
To work together wit Storable tha \f(CW\*(C`STORABLE_thaw\*(C'\fR function is defined to
call \f(CW\*(C`unserialize\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steffen Ullrich
