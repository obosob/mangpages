.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LWP 3"
.TH LWP 3 "2013-03-11" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
LWP \- Da World\-Wide Web library fo' Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use LWP;
\&  print "This is libwww\-perl\-$LWP::VERSION\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da libwww-perl collection be a set of Perl modulez which serves up a
simple n' consistent application programmin intercourse (\s-1API\s0) ta the
World-Wide Web.  Da main focuz of tha library is ta provide classes
and functions dat allow you ta write \s-1WWW\s0 clients, n' you can put dat on yo' toast. Da library also
contain modulez dat iz of mo' general use n' even classes that
help you implement simple \s-1HTTP\s0 servers.
.PP
Most modulez up in dis library provide a object oriented \s-1API. \s0 Da user
agent, requests busted n' responses received from tha \s-1WWW\s0 server are
all represented by objects, n' you can put dat on yo' toast.  This cook up a simple n' powerful
interface ta these skillz.  Da intercourse is easy as fuck  ta extend
and customize fo' yo' own needs.
.PP
Da main featurez of tha library are:
.IP "\(bu" 3
Gotz Nuff various reusable components (modules) dat can be
used separately or together.
.IP "\(bu" 3
Provides a object oriented model of HTTP-style communication. I aint talkin' bout chicken n' gravy biatch.  Within
this framework we currently support access ta http, https, gopher, ftp, hype,
file, n' mailto resources.
.IP "\(bu" 3
Provides a gangbangin' full object oriented intercourse or
a straight-up simple procedural intercourse.
.IP "\(bu" 3
Supports tha basic n' digest authorization schemes.
.IP "\(bu" 3
Supports transparent redirect handling.
.IP "\(bu" 3
Supports access all up in proxy servers.
.IP "\(bu" 3
Provides parser fo' \fIrobots.txt\fR filez n' a gangbangin' framework fo' constructin robots.
.IP "\(bu" 3
Supports parsin of \s-1HTML\s0 forms.
.IP "\(bu" 3
Implements \s-1HTTP\s0 content negotiation algorithm dat can
be used both up in protocol modulez n' up in server scripts (like \s-1CGI\s0
scripts).
.IP "\(bu" 3
Supports \s-1HTTP\s0 cookies.
.IP "\(bu" 3
Some simple command line clients, fo' instizzle \f(CW\*(C`lwp\-request\*(C'\fR n' \f(CW\*(C`lwp\-download\*(C'\fR.
.SH "HTTP STYLE COMMUNICATION"
.IX Header "HTTP STYLE COMMUNICATION"
Da libwww-perl library is based on \s-1HTTP\s0 steez communication. I aint talkin' bout chicken n' gravy biatch. This
section tries ta describe what tha fuck dat means.
.PP
Let our asses start wit dis quote from tha \s-1HTTP\s0 justification document
<URL:http://www.w3.org/Protocols/>:
.IP "\(bu" 3
Da \s-1HTTP\s0 protocol is based on a request/response paradigm fo' realz. A client
establishes a cold-ass lil connection wit a server n' sendz a request ta the
server up in tha form of a request method, \s-1URI,\s0 n' protocol version,
followed by a MIME-like message containin request modifiers, client
information, n' possible body content. Da server respondz wit a
status line, includin tha messagez protocol version n' a success or
error code, followed by a MIME-like message containin server
information, entitizzle meta-information, n' possible body content.
.PP
What dis means ta libwww-perl is dat communication always take place
all up in these steps: First a \fIrequest\fR object is pimped and
configured. Y'all KNOW dat shit, muthafucka! This object is then passed ta a server n' we git a
\&\fIresponse\fR object up in return dat we can examine fo' realz. A request be always
independent of any previous requests, i.e. tha steez is stateless.
Da same simple model is used fo' any kind of steez we want to
access.
.PP
For example, if we wanna fetch a thugged-out document from a remote file server,
then we bust it a request dat gotz nuff a name fo' dat document and
the response will contain tha document itself.  If we access a search
engine, then tha content of tha request will contain tha query
parametas n' tha response will contain tha query result.  If we want
to bust a mail message ta some muthafucka then we bust a request object which
gotz nuff our message ta tha mail server n' tha response object will
contain a acknowledgment dat  drops some lyrics ta our asses dat tha message has been
accepted n' is ghon be forwarded ta tha recipient(s).
.PP
It be as simple as that!
.SS "Da Request Object"
.IX Subsection "Da Request Object"
Da libwww-perl request object has tha class name \f(CW\*(C`HTTP::Request\*(C'\fR.
Da fact dat tha class name uses \f(CW\*(C`HTTP::\*(C'\fR as a
prefix only implies dat we use tha \s-1HTTP\s0 model of communication. I aint talkin' bout chicken n' gravy biatch.  It
does not limit tha kind of skillz we can try ta pass dis \fIrequest\fR
to.  For instance, we will bust \f(CW\*(C`HTTP::Request\*(C'\fRs both ta ftp and
gopher servers, as well as ta tha local file system.
.PP
Da main attributez of tha request objects are:
.IP "\(bu" 3
\&\fBmethod\fR be a gangbangin' finger-lickin' dirty-ass short strang dat  drops some lyrics ta what tha fuck kind of
request dis is.  Da most common methodz is \fB\s-1GET\s0\fR, \fB\s-1PUT\s0\fR,
\&\fB\s-1POST\s0\fR n' \fB\s-1HEAD\s0\fR.
.IP "\(bu" 3
\&\fBuri\fR be a strang denotin tha protocol, server and
the name of tha \*(L"document\*(R" we wanna access.  Da \fBuri\fR might
also encode various other parameters.
.IP "\(bu" 3
\&\fBheaders\fR gotz nuff additionizzle shiznit bout the
request n' can also used ta describe tha content.  Da headers
are a set of keyword/value pairs.
.IP "\(bu" 3
\&\fBcontent\fR be a arbitrary amount of data.
.SS "Da Response Object"
.IX Subsection "Da Response Object"
Da libwww-perl response object has tha class name \f(CW\*(C`HTTP::Response\*(C'\fR.
Da main attributez of objectz of dis class are:
.IP "\(bu" 3
\&\fBcode\fR be a numerical value dat indicates tha overall
outcome of tha request.
.IP "\(bu" 3
\&\fBmessage\fR be a gangbangin' finger-lickin' dirty-ass short, human readable strang that
correspondz ta tha \fIcode\fR.
.IP "\(bu" 3
\&\fBheaders\fR gotz nuff additionizzle shiznit bout the
response n' describe tha content.
.IP "\(bu" 3
\&\fBcontent\fR be a arbitrary amount of data.
.PP
Since our phat asses don't wanna handle all possible \fIcode\fR joints directly in
our programs, a libwww-perl response object has methodz dat can be
used ta query what tha fuck kind of response dis is.  Da most commonly used
response classification methodz are:
.IP "\fIis_success()\fR" 3
.IX Item "is_success()"
Da request was successfully received, understood or accepted.
.IP "\fIis_error()\fR" 3
.IX Item "is_error()"
Da request failed. Y'all KNOW dat shit, muthafucka!  Da server or tha resource might not be
available, access ta tha resource might be denied or other thangs might
have failed fo' some reason.
.SS "Da User Agent"
.IX Subsection "Da User Agent"
Let our asses assume dat our crazy asses have pimped a \fIrequest\fR object. What do we
actually do wit it up in order ta receive a \fIresponse\fR?
.PP
Da answer is dat you pass it ta a \fIuser agent\fR object n' this
object takes care of all tha thangs dat need ta be done
(like low-level communication n' error handling) n' returns
a \fIresponse\fR object. Da user agent represents your
application on tha network n' serves up you wit a intercourse that
can accept \fIrequests\fR n' return \fIresponses\fR.
.PP
Da user agent be a intercourse layer between
your application code n' tha network.  Through dis intercourse yo ass is
able ta access tha various servers on tha network.
.PP
Da class name fo' tha user agent is \f(CW\*(C`LWP::UserAgent\*(C'\fR.  Every
libwww-perl application dat wants ta rap should create at
least one object of dis class. Da main method provided by this
object is \fIrequest()\fR. This method takes a \f(CW\*(C`HTTP::Request\*(C'\fR object as
argument n' (eventually) returns a \f(CW\*(C`HTTP::Response\*(C'\fR object.
.PP
Da user agent has nuff other attributes dat let you
configure how tha fuck it will interact wit tha network n' wit your
application.
.IP "\(bu" 3
\&\fBtimeout\fR specifies how tha fuck much time we give remote servers to
respond before tha library disconnects n' creates an
internal \fItimeout\fR response.
.IP "\(bu" 3
\&\fBagent\fR specifies tha name dat yo' application uses when it
presents itself on tha network.
.IP "\(bu" 3
\&\fBfrom\fR can be set ta tha e\-mail address of tha person
responsible fo' hustlin tha application. I aint talkin' bout chicken n' gravy biatch.  If dis is set, then the
address is ghon be busted ta tha servers wit every last muthafuckin request.
.IP "\(bu" 3
\&\fBparse_head\fR specifies whether we should initialize response
headaz from tha <head> section of \s-1HTML\s0 documents.
.IP "\(bu" 3
\&\fBproxy\fR n' \fBno_proxy\fR specify if n' when ta go through
a proxy server n' shit. <URL:http://www.w3.org/History/1994/WWW/Proxies/>
.IP "\(bu" 3
\&\fBcredentials\fR serves up a way ta set up user names and
passwordz needed ta access certain skillz.
.PP
Many applications want even mo' control over how tha fuck they interact
with tha network n' they git dis by sub-classing
\&\f(CW\*(C`LWP::UserAgent\*(C'\fR.  Da library includes a
sub-class, \f(CW\*(C`LWP::RobotUA\*(C'\fR, fo' robot applications.
.SS "An Example"
.IX Subsection "An Example"
This example shows how tha fuck tha user agent, a request n' a response are
represented up in actual perl code:
.PP
.Vb 4
\&  # Smoke a user agent object
\&  use LWP::UserAgent;
\&  mah $ua = LWP::UserAgent\->new;
\&  $ua\->agent("MyApp/0.1 ");
\&
\&  # Smoke a request
\&  mah $req = HTTP::Request\->new(POST => \*(Aqhttp://search.cpan.org/search\*(Aq);
\&  $req\->content_type(\*(Aqapplication/x\-www\-form\-urlencoded\*(Aq);
\&  $req\->content(\*(Aqquery=libwww\-perl&mode=dist\*(Aq);
\&
\&  # Pass request ta tha user agent n' git a response back
\&  mah $res = $ua\->request($req);
\&
\&  # Peep tha outcome of tha response
\&  if ($res\->is_success) {
\&      print $res\->content;
\&  }
\&  else {
\&      print $res\->status_line, "\en";
\&  }
.Ve
.PP
Da \f(CW$ua\fR is pimped once when tha application starts up.  New request
objects should normally pimped fo' each request sent.
.SH "NETWORK SUPPORT"
.IX Header "NETWORK SUPPORT"
This section discusses tha various protocol schemes and
the \s-1HTTP\s0 steez methodz dat headaz may be used fo' each.
.PP
For all requests, a \*(L"User-Agent\*(R" header be added n' initialized from
the \f(CW$ua\fR\->agent attribute before tha request is handed ta tha network
layer n' shit.  In tha same way, a \*(L"From\*(R" header is initialized from the
\&\f(CW$ua\fR\->from attribute.
.PP
For all responses, tha library addz a header called \*(L"Client-Date\*(R".
This header holdz tha time when tha response was received by
your application. I aint talkin' bout chicken n' gravy biatch.  Da format n' semantics of tha header is the
same as tha server pimped \*(L"Date\*(R" header n' shit.  Yo ass may also encounta other
\&\*(L"Client-XXX\*(R" headers.  They is all generated by tha library
internally n' is not received from tha servers.
.SS "\s-1HTTP\s0 Requests"
.IX Subsection "HTTP Requests"
\&\s-1HTTP\s0 requests is just handed off ta a \s-1HTTP\s0 server n' it
decides what tha fuck happens.  Few servers implement methodz beside tha usual
\&\*(L"\s-1GET\*(R", \*(L"HEAD\*(R", \*(L"POST\*(R"\s0 n' \*(L"\s-1PUT\*(R",\s0 but CGI-scripts may implement
any method they like.
.PP
If tha server aint available then tha library will generate an
internal error response.
.PP
Da library automatically addz a \*(L"Host\*(R" n' a \*(L"Content-Length\*(R" header
to tha \s-1HTTP\s0 request before it is busted over tha network.
.PP
For a \s-1GET\s0 request you might wanna add a \*(L"If-Modified-Since\*(R" or
\&\*(L"If-None-Match\*(R" header ta make tha request conditional.
.PP
For a \s-1POST\s0 request you should add tha \*(L"Content-Type\*(R" header n' shit.  When you
try ta emulate \s-1HTML\s0 <\s-1FORM\s0> handlin you should probably let tha value
of tha \*(L"Content-Type\*(R" header be \*(L"application/x\-www\-form\-urlencoded\*(R".
See lwpcook fo' examplez of all dis bullshit.
.PP
Da libwww-perl \s-1HTTP\s0 implementation currently support tha \s-1HTTP/1.1\s0
and \s-1HTTP/1.0\s0 protocol.
.PP
Da library allows you ta access proxy server all up in \s-1HTTP. \s0 This
means dat you can set up tha library ta forward all typez of request
all up in tha \s-1HTTP\s0 protocol module.  See LWP::UserAgent for
documentation of all dis bullshit.
.SS "\s-1HTTPS\s0 Requests"
.IX Subsection "HTTPS Requests"
\&\s-1HTTPS\s0 requests is \s-1HTTP\s0 requests over a encrypted network connection
usin tha \s-1SSL\s0 protocol pimped by Netscape.  Everythang bout \s-1HTTP\s0
requests above also apply ta \s-1HTTPS\s0 requests, n' you can put dat on yo' toast.  In addizzle tha library
will add tha headaz \*(L"Client-SSL-Cipher\*(R", \*(L"Client-SSL-Cert-Subject\*(R" and
\&\*(L"Client-SSL-Cert-Issuer\*(R" ta tha response.  These headaz denote the
encryption method used n' tha name of tha server baller.
.PP
Da request can contain tha header \*(L"If-SSL-Cert-Subject\*(R" up in order to
make tha request conditionizzle on tha content of tha server certificate.
If tha certificate subject do not match, no request is busted ta the
server n' a internally generated error response is returned. Y'all KNOW dat shit, muthafucka!  The
value of tha \*(L"If-SSL-Cert-Subject\*(R" header is interpreted as a Perl
regular expression.
.SS "\s-1FTP\s0 Requests"
.IX Subsection "FTP Requests"
Da library currently supports \s-1GET, HEAD\s0 n' \s-1PUT\s0 requests, n' you can put dat on yo' toast.  \s-1GET\s0
retrieves a gangbangin' file or a gangbangin' finger-lickin' directory listin from a \s-1FTP\s0 server n' shit.  \s-1PUT\s0
stores a gangbangin' file on a gangbangin' ftp server.
.PP
Yo ass can specify a gangbangin' ftp account fo' servers dat want dis up in addition
to user name n' password. Y'all KNOW dat shit, muthafucka!  This is specified by includin a \*(L"Account\*(R"
header up in tha request.
.PP
User name/password can be specified rockin basic authorization or be
encoded up in tha \s-1URL. \s0 Failed logins return a \s-1UNAUTHORIZED\s0 response with
\&\*(L"WWW-Authenticate: Basic\*(R" n' can be treated like basic authorization
for \s-1HTTP.\s0
.PP
Da library supports ftp \s-1ASCII\s0 transfer mode by specifyin tha \*(L"type=a\*(R"
parameta up in tha \s-1URL.\s0 It also supports transfer of ranges fo' \s-1FTP\s0 transfers
usin tha \*(L"Range\*(R" header.
.PP
Directory listings is by default returned unprocessed (as returned
from tha ftp server) wit tha content media type reported ta be
\&\*(L"text/ftp\-dir\-listing\*(R". Da \f(CW\*(C`File::Listing\*(C'\fR module serves up methods
for parsin of these directory listing.
.PP
Da ftp module be also able ta convert directory listings ta \s-1HTML\s0 and
this can be axed via tha standard \s-1HTTP\s0 content negotiation
mechanizzlez (add a \*(L"Accept: text/html\*(R" header up in tha request if you
want this).
.PP
For aiiight file retrievals, tha \*(L"Content-Type\*(R" is guessed based on the
file name suffix. Right back up in yo muthafuckin ass. See LWP::MediaTypes.
.PP
Da \*(L"If-Modified-Since\*(R" request header works fo' servers dat implement
the \s-1MDTM\s0 command. Y'all KNOW dat shit, muthafucka!  It will probably not work fo' directory listings though.
.PP
Example:
.PP
.Vb 2
\&  $req = HTTP::Request\->new(GET => \*(Aqftp://me:passwd@ftp.some.where.com/\*(Aq);
\&  $req\->header(Accept => "text/html, */*;q=0.1");
.Ve
.SS "Shit Requests"
.IX Subsection "Shit Requests"
Access ta tha \s-1USENET\s0 Shit system is implemented all up in tha \s-1NNTP\s0
protocol.  Da name of tha shizzle server is obtained from the
\&\s-1NNTP_SERVER\s0 environment variable n' defaults ta \*(L"news\*(R".  It be not
possible ta specify tha hostname of tha \s-1NNTP\s0 server up in news: URLs.
.PP
Da library supports \s-1GET\s0 n' \s-1HEAD\s0 ta retrieve shizzle articlez all up in the
\&\s-1NNTP\s0 protocol.  Yo ass can also post articlez ta newsgroups by using
(surprise!) tha \s-1POST\s0 method.
.PP
\&\s-1GET\s0 on newsgroups aint implemented yet.
.PP
Examples:
.PP
.Vb 1
\&  $req = HTTP::Request\->new(GET => \*(Aqnews:abc1234@a.sn.no\*(Aq);
\&
\&  $req = HTTP::Request\->new(POST => \*(Aqnews:comp.lang.perl.test\*(Aq);
\&  $req\->header(Subject => \*(AqThis be a test\*(Aq,
\&               From    => \*(Aqme@some.where.org\*(Aq);
\&  $req\->content(<<EOT);
\&  This is tha content of tha message dat we is bustin  to
\&  tha ghetto. Right back up in yo muthafuckin ass.
\&  EOT
.Ve
.SS "Gopher Request"
.IX Subsection "Gopher Request"
Da library supports tha \s-1GET\s0 n' \s-1HEAD\s0 methodz fo' gopher requests, n' you can put dat on yo' toast.  All
request header joints is ignored. Y'all KNOW dat shit, muthafucka!  \s-1HEAD\s0 cheats n' returns a
response without even rappin' ta server.
.PP
Gopher menus is always converted ta \s-1HTML.\s0
.PP
Da response \*(L"Content-Type\*(R" is generated from tha document type
encoded (as tha straight-up original gangsta letter) up in tha request \s-1URL\s0 path itself.
.PP
Example:
.PP
.Vb 1
\&  $req = HTTP::Request\->new(GET => \*(Aqgopher://gopher.sn.no/\*(Aq);
.Ve
.SS "File Request"
.IX Subsection "File Request"
Da library supports \s-1GET\s0 n' \s-1HEAD\s0 methodz fo' file requests, n' you can put dat on yo' toast.  The
\&\*(L"If-Modified-Since\*(R" header is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  All other headaz are
ignored. Y'all KNOW dat shit, muthafucka!  Da \fIhost\fR component of tha file \s-1URL\s0 must be empty or set
to \*(L"localhost\*(R".  Any other \fIhost\fR value is ghon be treated as a error.
.PP
Directories is always converted ta a \s-1HTML\s0 document.  For normal
files, tha \*(L"Content-Type\*(R" n' \*(L"Content-Encoding\*(R" up in tha response are
guessed based on tha file suffix.
.PP
Example:
.PP
.Vb 1
\&  $req = HTTP::Request\->new(GET => \*(Aqfile:/etc/passwd\*(Aq);
.Ve
.SS "Mailto Request"
.IX Subsection "Mailto Request"
Yo ass can bust (aka \*(L"\s-1POST\*(R"\s0) mail lyrics rockin tha library.  All
headaz specified fo' tha request is passed on ta tha mail system.
Da \*(L"To\*(R" header is initialized from tha mail address up in tha \s-1URL.\s0
.PP
Example:
.PP
.Vb 3
\&  $req = HTTP::Request\->new(POST => \*(Aqmailto:libwww@perl.org\*(Aq);
\&  $req\->header(Subject => "subscribe");
\&  $req\->content("Please subscribe me ta tha libwww\-perl mailin list!\en");
.Ve
.SS "\s-1CPAN\s0 Requests"
.IX Subsection "CPAN Requests"
URLs wit scheme \f(CW\*(C`cpan:\*(C'\fR is repimped up ta tha a suitable \s-1CPAN\s0
mirror. Shiiit, dis aint no joke.  If you have yo' own local mirror of \s-1CPAN\s0 you might tell \s-1LWP\s0
to use it fo' \f(CW\*(C`cpan:\*(C'\fR URLs by a assignment like this:
.PP
.Vb 1
\&  $LWP::Protocol::cpan::CPAN = "file:/local/CPAN/";
.Ve
.PP
Suitable \s-1CPAN\s0 mirrors is also picked up from tha configuration for
the \s-1CPAN\s0.pm, so if you have used dat module a suitable mirror should
be picked automatically.  If neither of these apply, then a redirect
to tha generic \s-1CPAN\s0 http location is issued.
.PP
Example request ta downlizzle tha newest perl:
.PP
.Vb 1
\&  $req = HTTP::Request\->new(GET => "cpan:src/latest.tar.gz");
.Ve
.SH "OVERVIEW OF CLASSES AND PACKAGES"
.IX Header "OVERVIEW OF CLASSES AND PACKAGES"
This table should hit you wit a quick overview of tha classes provided by the
library. Indentation shows class inheritance.
.PP
.Vb 8
\& LWP::MemberMixin   \-\- Access ta member variablez of Perl5 classes
\&   LWP::UserAgent   \-\- WWW user agent class
\&     LWP::RobotUA   \-\- When pimpin a robot applications
\&   LWP::Protocol          \-\- Interface ta various protocol schemes
\&     LWP::Protocol::http  \-\- http:// access
\&     LWP::Protocol::file  \-\- file:// access
\&     LWP::Protocol::ftp   \-\- ftp:// access
\&     ...
\&
\& LWP::Authen::Basic \-\- Handle 401 n' 407 responses
\& LWP::Authen::Digest
\&
\& HTTP::Headaz      \-\- MIME/RFC822 steez header (used by HTTP::Message)
\& HTTP::Message      \-\- HTTP steez message
\&   HTTP::Request    \-\- HTTP request
\&   HTTP::Response   \-\- HTTP response
\& HTTP::Daemon       \-\- A HTTP server class
\&
\& WWW::RobotRulez    \-\- Parse robots.txt files
\&   WWW::RobotRules::AnyDBM_File \-\- Persistent RobotRules
\&
\& Net::HTTP          \-\- Low level HTTP client
.Ve
.PP
Da followin modulez provide various functions n' definitions.
.PP
.Vb 8
\& LWP                \-\- This file.  Library version number n' documentation.
\& LWP::MediaTypes    \-\- MIME types configuration (text/html etc.)
\& LWP::Simple        \-\- Simplified procedural intercourse fo' common functions
\& HTTP::Status       \-\- HTTP status code (200 OK etc)
\& HTTP::Date         \-\- Date parsin module fo' HTTP date formats
\& HTTP::Negotiate    \-\- HTTP content negotiation calculation
\& File::Listin      \-\- Parse directory listings
\& HTML::Form         \-\- Processin fo' <form>s up in HTML documents
.Ve
.SH "MORE DOCUMENTATION"
.IX Header "MORE DOCUMENTATION"
All modulez contain detailed shiznit on tha intercourses they
provide.  Da lwpcook manpage is tha libwww-perl cookbook dat contain
examplez of typical usage of tha library.  Yo ass might wanna take a
peep how tha fuck tha scripts lwp-request, lwp-download, lwp-dump
and lwp-mirror is implemented.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
Da followin environment variablez is used by \s-1LWP:\s0
.IP "\s-1HOME\s0" 4
.IX Item "HOME"
Da \f(CW\*(C`LWP::MediaTypes\*(C'\fR functions will look fo' tha \fI.media.types\fR and
\&\fI.mime.types\fR filez relatizzle ta you home directory.
.IP "http_proxy" 4
.IX Item "http_proxy"
.PD 0
.IP "ftp_proxy" 4
.IX Item "ftp_proxy"
.IP "xxx_proxy" 4
.IX Item "xxx_proxy"
.IP "no_proxy" 4
.IX Item "no_proxy"
.PD
These environment variablez can be set ta enable communication through
a proxy server n' shit.  See tha description of tha \f(CW\*(C`env_proxy\*(C'\fR method in
LWP::UserAgent.
.IP "\s-1PERL_LWP_ENV_PROXY\s0" 4
.IX Item "PERL_LWP_ENV_PROXY"
If set ta a \s-1TRUE\s0 value, then tha \f(CW\*(C`LWP::UserAgent\*(C'\fR will by default call
\&\f(CW\*(C`env_proxy\*(C'\fR durin initialization. I aint talkin' bout chicken n' gravy biatch.  This make \s-1LWP\s0 honor tha proxy variables
busted lyrics bout above.
.IP "\s-1PERL_LWP_SSL_VERIFY_HOSTNAME\s0" 4
.IX Item "PERL_LWP_SSL_VERIFY_HOSTNAME"
Da default \f(CW\*(C`verify_hostname\*(C'\fR settin fo' \f(CW\*(C`LWP::UserAgent\*(C'\fR.  If
not set tha default is ghon be 1.  Set it as 0 ta disable hostname
verification (the default prior ta libwww-perl 5.840.
.IP "\s-1PERL_LWP_SSL_CA_FILE\s0" 4
.IX Item "PERL_LWP_SSL_CA_FILE"
.PD 0
.IP "\s-1PERL_LWP_SSL_CA_PATH\s0" 4
.IX Item "PERL_LWP_SSL_CA_PATH"
.PD
Da file and/or directory
where tha trusted Certificate Authoritizzle certificates
is located. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See LWP::UserAgent fo' details.
.IP "\s-1PERL_HTTP_URI_CLASS\s0" 4
.IX Item "PERL_HTTP_URI_CLASS"
Used ta decizzle what tha fuck \s-1URI\s0 objects ta instantiate.  Da default is \f(CW\*(C`URI\*(C'\fR.
Yo ass might wanna set it ta \f(CW\*(C`URI::URL\*(C'\fR fo' compatibilitizzle wit oldschool times.
.SH "AUTHORS"
.IX Header "AUTHORS"
\&\s-1LWP\s0 was made possible by contributions from Adam Newby, Albert
Dvornik, Alexandre Duret-Lutz, Andreas Gustafsson, Andreas Ko\*:nig,
Andrew Pimlott, Andy Lester, Lil' Bow Wow Coleman, Benjamin Low, Lil' Bow Wow Low, Ben
Tilly, Blair Zajac, Bob Dalgleish, BooK, Brad Hughes, Brian
J. Murrell, Brian McCauley, Charlez C. Fu, Charlez Lane, Chris Nandor,
Christian Gilmore, Chris W. Unger, Craig Macdonald, Dizzy Couch, Dan
Kubb, Dizzle Dunkin, Dizzle W. Right back up in yo muthafuckin ass. Smizzle, Dizzy Coppit, Dizzy Dick, David
D. Kilzer, Doug MacEachern, Edward Avis, erik, Gary Shea, Gisle Aas,
Graham Barr, Gurusamy Sarathy, Hans de Graaff, Harald Joerg, Harry
Bochner, Hugo, Ilya Zakharevich, \s-1INOUE\s0 Yoshinari, Ivan Panchenko, Jack
Shirazi, Jizzy Tillman, Jan Dubois, Jared Rhine, Jim Stern, Joao
Lopes, Jizzy Klar, Jizzy Lee, Josh Kronengold, Josh Rai, Joshua
Chamas, Joshua Hoblitt, Kartik Subbarao, Keiichiro Nagano, Ken
Williams, \s-1KONISHI\s0 Katsuhiro, Lee T Lindley, Liam Quinn, Marc Hedlund,
Marc Langheinrich, Mark D fo' realz. Anderson, Marko Asplund, Mark Stosberg,
Markus B Kru\*:ger, Markus Laker, Martijn Koster, Martin Thurn, Matthew
Eldridge, Matthew.van.Eerde, Mack Sergeant, Mike A. Chase, Michael
Quaranta, Mike Thompson, Mike Schilli, Moshe Kaminsky, Nathan
Torkington, Nicolai Langfeldt, Norton Allen, Olly Betts, Paul
J. Right back up in yo muthafuckin ass. Schinder, peterm, Philip GuentherDaniel Buenzli, Pon Hwa Lin,
Radoslaw Zielinski, Radu Greab, Randal L. Right back up in yo muthafuckin ass. Schwartz, Slick Rick Chen,
Robin Barker, Roy Fielding, Sander van Zoest, Shizzle M. Burke,
shildreth, Slaven Rezic, Steve A Fink, Steve Hay, Steven Butler,
Steve_Kilbane, Takanori Ugai, Thomas Lotterer, Slim Tim Bunce, Tomothy Hughes,
Tony Finch, Ville Skytta\*:, Ward Vandewege, Lil' Willy York, Yale Huang,
and Yitzchak Scott-Thoennes.
.PP
\&\s-1LWP\s0 owes a shitload up in motivation, design, n' code, ta tha libwww-perl
library fo' Perl4 by Roy Fielding, which included work from Alberto
Accomazzi, Jizzy Casey, Brooks Cutter, Martijn Koster, Oscar
Nierstrasz, Mel Melchner, Gertjan van Oosten, Jared Rhine, Jack
Shirazi, Gene Spafford, Marc VanHeyningen, Steven E. Brenner, Marion
Hakanson, Waldemar Kebsch, Tony Sanders, n' Larry Wall; peep the
libwww\-perl\-0.40 library fo' details.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 2
\&  Copyright 1995\-2009, Gisle Aas
\&  Copyright 1995, Martijn Koster
.Ve
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
Da sickest fuckin version of dis library is likely ta be available from \s-1CPAN\s0
as well as:
.PP
.Vb 1
\&  http://github.com/libwww\-perl/libwww\-perl
.Ve
.PP
Da dopest place ta say shit bout dis code is on tha <libwww@perl.org>
mailin list.
