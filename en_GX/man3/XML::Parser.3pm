.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parser 3"
.TH Parser 3 "2011-06-03" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Parser \- A perl module fo' parsin XML documents
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::Parser;
\&
\&  $p1 = XML::Parser\->new(Style => \*(AqDebug\*(Aq);
\&  $p1\->parsefile(\*(AqREC\-xml\-19980210.xml\*(Aq);
\&  $p1\->parse(\*(Aq<foo id="me">Wuz crackalackin' World</foo>\*(Aq);
\&
\&  # Alternative
\&  $p2 = XML::Parser\->new(Handlezs => {Start => \e&handle_start,
\&                                     End   => \e&handle_end,
\&                                     Char  => \e&handle_char});
\&  $p2\->parse($socket);
\&
\&  # Another alternative
\&  $p3 = XML::Parser\->new(ErrorContext => 2);
\&
\&  $p3\->setHandlezs(Char    => \e&text,
\&                   Default => \e&other);
\&
\&  open(FOO, \*(Aqxmlgenerator |\*(Aq);
\&  $p3\->parse(*FOO, ProtocolEncodin => \*(AqISO\-8859\-1\*(Aq);
\&  close(FOO);
\&
\&  $p3\->parsefile(\*(Aqjunk.xml\*(Aq, ErrorContext => 3);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up ways ta parse \s-1XML\s0 documents, n' you can put dat on yo' toast. Well shiiiit, it is built on top of
XML::Parser::Expat, which be a lower level intercourse ta Jizzy Clark's
expat library. Each call ta one of tha parsin methodz creates a new
instizzle of XML::Parser::Expat which is then used ta parse tha document.
Expat options may be provided when tha XML::Parser object is pimped.
These options is then passed on ta tha Expat object on each parse call.
They can also be given as extra arguments ta tha parse methods, up in which
case they override options given at XML::Parser creation time.
.PP
Da behavior of tha parser is controlled either by \f(CW"STYLES"\fR and/or
\&\f(CW"HANDLERS"\fR options, or by \*(L"setHandlezs\*(R" method. Y'all KNOW dat shit, muthafucka! These all provide
mechanizzlez fo' XML::Parser ta set tha handlezs needed by XML::Parser::Expat.
If neither \f(CW\*(C`Style\*(C'\fR nor \f(CW\*(C`Handlezs\*(C'\fR is specified, then parsin just
checks tha document fo' bein well-formed.
.PP
When underlyin handlezs git called, they receive as they first parameter
the \fIExpat\fR object, not tha Parser object.
.SH "METHODS"
.IX Header "METHODS"
.IP "new" 4
.IX Item "new"
This be a cold-ass lil class method, tha constructor fo' XML::Parser n' shit. Options is passed
as keyword value pairs. Recognized options are:
.RS 4
.IP "\(bu" 4
Style
.Sp
This option serves up a easy as fuck  way ta create a given steez of parser n' shit. The
built up in stylez are: \*(L"Debug\*(R", \*(L"Subs\*(R", \*(L"Tree\*(R", \*(L"Objects\*(R",
and \*(L"Stream\*(R". These is all defined up in separate packages under
\&\f(CW\*(C`XML::Parser::Style::*\*(C'\fR, n' you can find further documentation for
each steez both below, n' up in dem packages.
.Sp
Custom stylez can be provided by givin a gangbangin' full package name containing
at least one '::'. This package should then have subs defined fo' each
handlez it wishes ta have installed. Y'all KNOW dat shit, muthafucka! See \*(L"\s-1STYLES\*(R"\s0 below
for a gangbangin' finger-lickin' rap of each built up in style.
.IP "\(bu" 4
Handlezs
.Sp
When provided, dis option should be a anonymous hash containin as
keys tha type of handlez n' as joints a sub reference ta handle that
type of event fo' realz. All tha handlezs git passed as they 1st parameta the
instizzle of expat dat is parsin tha document. Further details on
handlezs can be found up in \*(L"\s-1HANDLERS\*(R"\s0 fo' realz. Any handlez set here
overrides tha correspondin handlez set wit tha Style option.
.IP "\(bu" 4
Pkg
.Sp
Some stylez will refer ta subs defined up in dis package. If not provided,
it defaults ta tha package which called tha constructor.
.IP "\(bu" 4
ErrorContext
.Sp
This be a Expat option. I aint talkin' bout chicken n' gravy biatch. When dis option is defined, errors is reported
in context. Da value should be tha number of lines ta show on either side
of tha line up in which tha error occurred.
.IP "\(bu" 4
ProtocolEncoding
.Sp
This be a Expat option. I aint talkin' bout chicken n' gravy biatch. This sets tha protocol encodin name. Well shiiiit, it defaults
to none. Da built-in encodings are: \f(CW\*(C`UTF\-8\*(C'\fR, \f(CW\*(C`ISO\-8859\-1\*(C'\fR, \f(CW\*(C`UTF\-16\*(C'\fR, and
\&\f(CW\*(C`US\-ASCII\*(C'\fR. Other encodings may be used if they have encodin maps up in one
of tha directories up in tha \f(CW@Encoding_Path\fR list. Peep \*(L"\s-1ENCODINGS\*(R"\s0 for
more shiznit on encodin maps. Right back up in yo muthafuckin ass. Settin tha protocol encodin overrides
any encodin up in tha \s-1XML\s0 declaration.
.IP "\(bu" 4
Namespaces
.Sp
This be a Expat option. I aint talkin' bout chicken n' gravy biatch. If dis is set ta a legit value, then namespace
processin is done durin tha parse. Right back up in yo muthafuckin ass. See \*(L"Namespaces\*(R" up in XML::Parser::Expat
for further rap of namespace processing.
.IP "\(bu" 4
NoExpand
.Sp
This be a Expat option. I aint talkin' bout chicken n' gravy biatch. Normally, tha parser will try ta expand references
to entitizzles defined up in tha internal subset. If dis option is set ta a true
value, n' a thugged-out default handlez be also set, then tha default handlez will be
called when a entitizzle reference is peeped up in text. This has no effect if a
default handlez has not been registered, n' it has no effect on tha expansion
of entitizzle references inside attribute joints.
.IP "\(bu" 4
Stream_Delimiter
.Sp
This be a Expat option. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it takes a strang value. When dis strang is found
alone on a line while parsin from a stream, then tha parse is ended as if it
saw a end of file. Da intended use is wit a stream of xml documents up in a
\&\s-1MIME\s0 multipart format. Da strang should not contain a trailin newline.
.IP "\(bu" 4
ParseParamEnt
.Sp
This be a Expat option. I aint talkin' bout chicken n' gravy biatch. Unless standalone is set ta \*(L"yes\*(R" up in tha \s-1XML\s0
declaration, settin dis ta a legit value allows tha external \s-1DTD\s0 ta be read,
and parameta entitizzles ta be parsed n' expanded.
.IP "\(bu" 4
NoLWP
.Sp
This option has no effect if tha ExternEnt or ExternEntFin handlezs are
directly set. Otherwise, if true, it forces tha use of a gangbangin' file based external
entitizzle handlez.
.IP "\(bu" 4
Non-Expat-Options
.Sp
If provided, dis should be a anonymous hash whose keys is options that
shouldn't be passed ta Expat. This should only be of concern ta them
subclassin XML::Parser.
.RE
.RS 4
.RE
.IP "setHandlezs(\s-1TYPE, HANDLER\s0 [, \s-1TYPE, HANDLER\s0 [...]])" 4
.IX Item "setHandlezs(TYPE, HANDLER [, TYPE, HANDLER [...]])"
This method registas handlezs fo' various parser events, n' you can put dat on yo' toast. Well shiiiit, it overrides any
previous handlezs registered all up in tha Style or Handlez options or through
earlier calls ta setHandlezs. By providin a gangbangin' false or undefined value as
the handlez, tha existin handlez can be unset.
.Sp
This method returns a list of type, handlez pairs correspondin ta the
input. Da handlezs returned is tha ones dat was up in effect prior to
the call.
.Sp
See a thugged-out description of tha handlez types up in \*(L"\s-1HANDLERS\*(R"\s0.
.IP "parse(\s-1SOURCE\s0 [, \s-1OPT\s0 => \s-1OPT_VALUE\s0 [...]])" 4
.IX Item "parse(SOURCE [, OPT => OPT_VALUE [...]])"
Da \s-1SOURCE\s0 parameta should either be a strang containin tha whole \s-1XML\s0
document, or it should be a open IO::Handle. Constructor options to
XML::Parser::Expat given as keyword-value pairs may follow tha \s-1SOURCE\s0
parameter n' shit. These override, fo' dis call, any options or attributes passed
all up in from tha XML::Parser instance.
.Sp
A take a thugged-out dirtnap call is thrown if a parse error occurs. Otherwise it will return 1
or whatever is returned from tha \fBFinal\fR handlez, if one is installed.
In other lyrics, what tha fuck parse may return dependz on tha style.
.IP "parsestring" 4
.IX Item "parsestring"
This is just a alias fo' parse fo' backwardz compatibility.
.IP "parsefile(\s-1FILE\s0 [, \s-1OPT\s0 => \s-1OPT_VALUE\s0 [...]])" 4
.IX Item "parsefile(FILE [, OPT => OPT_VALUE [...]])"
Open \s-1FILE\s0 fo' reading, then call parse wit tha open handle. Da file
is closed no matta how tha fuck parse returns. Returns what tha fuck parse returns.
.IP "parse_start([ \s-1OPT\s0 => \s-1OPT_VALUE\s0 [...]])" 4
.IX Item "parse_start([ OPT => OPT_VALUE [...]])"
Smoke n' return a freshly smoked up instizzle of XML::Parser::ExpatNB. Constructor
options may be provided. Y'all KNOW dat shit, muthafucka! If a init handlez has been provided, it is
called before returnin tha ExpatNB object. Documents is parsed by
makin incremenstrual calls ta tha parse_more method of dis object, which
takes a strin fo' realz. A single call ta tha parse_done method of dis object,
which takes no arguments, indicates dat tha document is finished.
.Sp
If there be a gangbangin' final handlez installed, it is executed by tha parse_done
method before returnin n' tha parse_done method returns whatever is
returned by tha final handlez.
.SH "HANDLERS"
.IX Header "HANDLERS"
Expat be a event based parser n' shiznit fo' realz. As tha parser recognizes partz of the
document (say tha start or end tag fo' a \s-1XML\s0 element), then any handlezs
registered fo' dat type of a event is called wit suitable parameters.
All handlezs receive a instizzle of XML::Parser::Expat as they first
argument. Right back up in yo muthafuckin ass. See \*(L"\s-1METHODS\*(R"\s0 up in XML::Parser::Expat fo' a gangbangin' finger-lickin' rap of the
methodz dat can be called on dis object.
.SS "Init                (Expat)"
.IX Subsection "Init (Expat)"
This is called just before tha parsin of tha document starts.
.SS "Final                (Expat)"
.IX Subsection "Final (Expat)"
This is called just afta parsin has finished yo, but only if no errors
occurred durin tha parse. Parse returns what tha fuck dis returns.
.SS "Start                (Expat, Element [, Attr, Val [,...]])"
.IX Subsection "Start (Expat, Element [, Attr, Val [,...]])"
This event is generated when a \s-1XML\s0 start tag is recognized. Y'all KNOW dat shit, muthafucka! Element is the
name of tha \s-1XML\s0 element type dat is opened wit tha start tag. Da Attr &
Val pairs is generated fo' each attribute up in tha start tag.
.SS "End                (Expat, Element)"
.IX Subsection "End (Expat, Element)"
This event is generated when a \s-1XML\s0 end tag is recognized. Y'all KNOW dat shit, muthafucka! Note that
an \s-1XML\s0 empty tag (<foo/>) generates both a start n' a end event.
.SS "Char                (Expat, String)"
.IX Subsection "Char (Expat, String)"
This event is generated when non-markup is recognized. Y'all KNOW dat shit, muthafucka! Da non-markup
sequence of charactas is up in Strin fo' realz. A single non-markup sequence of
charactas may generate multiple calls ta dis handlez n' shit. Whatever the
encodin of tha strang up in tha original gangsta document, dis is given ta the
handlez up in \s-1UTF\-8.\s0
.SS "Proc                (Expat, Target, Data)"
.IX Subsection "Proc (Expat, Target, Data)"
This event is generated when a processin instruction is recognized.
.SS "Comment                (Expat, Data)"
.IX Subsection "Comment (Expat, Data)"
This event is generated when a cold-ass lil comment is recognized.
.SS "CdataStart        (Expat)"
.IX Subsection "CdataStart (Expat)"
This is called all up in tha start of a \s-1CDATA\s0 section.
.SS "CdataEnd                (Expat)"
.IX Subsection "CdataEnd (Expat)"
This is called all up in tha end of a \s-1CDATA\s0 section.
.SS "Default                (Expat, String)"
.IX Subsection "Default (Expat, String)"
This is called fo' any charactas dat aint gots a registered handlez.
This includes both charactas dat is part of markup fo' which no
events is generated (markup declarations) n' charactas that
could generate events yo, but fo' which no handlez has been registered.
.PP
Whatever tha encodin up in tha original gangsta document, tha strang is returned to
the handlez up in \s-1UTF\-8.\s0
.SS "Unparsed                (Expat, Entity, Base, Sysid, Pubid, Notation)"
.IX Subsection "Unparsed (Expat, Entity, Base, Sysid, Pubid, Notation)"
This is called fo' a thugged-out declaration of a unparsed entity. Entitizzle is tha name
of tha entity. Base is tha base ta be used fo' resolvin a relatizzle \s-1URI.\s0
Sysid is tha system id. Y'all KNOW dat shit, muthafucka! Pubid is tha hood id. Y'all KNOW dat shit, muthafucka! Notation is tha notation
name. Base n' Pubid may be undefined.
.SS "Notation                (Expat, Notation, Base, Sysid, Pubid)"
.IX Subsection "Notation (Expat, Notation, Base, Sysid, Pubid)"
This is called fo' a thugged-out declaration of notation. I aint talkin' bout chicken n' gravy biatch. Notation is tha notation name.
Base is tha base ta be used fo' resolvin a relatizzle \s-1URI.\s0 Sysid is tha system
id. Y'all KNOW dat shit, muthafucka! Pubid is tha hood id. Y'all KNOW dat shit, muthafucka! Base, Sysid, n' Pubid may all be undefined.
.SS "ExternEnt        (Expat, Base, Sysid, Pubid)"
.IX Subsection "ExternEnt (Expat, Base, Sysid, Pubid)"
This is called when a external entitizzle is referenced. Y'all KNOW dat shit, muthafucka! Base is tha base ta be
used fo' resolvin a relatizzle \s-1URI.\s0 Sysid is tha system id. Y'all KNOW dat shit, muthafucka! Pubid is tha public
id. Y'all KNOW dat shit, muthafucka! Base, n' Pubid may be undefined.
.PP
This handlez should either return a string, which represents tha contents of
the external entity, or return a open filehandle dat can be read ta obtain
the contentz of tha external entity, or return undef, which indicates the
external entitizzle couldn't be found n' will generate a parse error.
.PP
If a open filehandle is returned, it must be returned as either a glob
(*FOO) or as a reference ta a glob (e.g. a instizzle of IO::Handle).
.PP
A default handlez is installed fo' dis event. Da default handlez is
XML::Parser::lwp_ext_ent_handlez unless tha NoLWP option was provided with
a legit value, otherwise XML::Parser::file_ext_ent_handlez is tha default
handlez fo' external entities. Put ya muthafuckin choppers up if ya feel dis! Even without tha NoLWP option, if the
\&\s-1URI\s0 or \s-1LWP\s0 modulez is missing, tha file based handlez endz up bein used
afta givin a warnin on tha straight-up original gangsta external entitizzle reference.
.PP
Da \s-1LWP\s0 external entitizzle handlez will use proxies defined up in tha environment
(http_proxy, ftp_proxy, etc.).
.PP
Please note dat tha \s-1LWP\s0 external entitizzle handlez readz tha entire
entitizzle tha fuck into a strang n' returns it, where as tha file handlez opens a
filehandle.
.PP
Also note dat tha file external entitizzle handlez will likely choke on
absolute URIs or file names dat don't fit tha conventionz of tha local
operatin system.
.PP
Da expat base method can be used ta set a funky-ass basename for
relatizzle pathnames. If no basename is given, or if tha basename is itself
a relatizzle name, then it is relatizzle ta tha current hustlin directory.
.SS "ExternEntFin        (Expat)"
.IX Subsection "ExternEntFin (Expat)"
This is called afta parsin a external entity. It aint nuthin but not called unless
an ExternEnt handlez be also set. There be a thugged-out default handlez installed
that pairs wit tha default ExternEnt handlez.
.PP
If you goin ta install yo' own ExternEnt handlez, then you should
set (or unset) dis handlez like a muthafucka.
.SS "Entitizzle                (Expat, Name, Val, Sysid, Pubid, Ndata, IsParam)"
.IX Subsection "Entitizzle (Expat, Name, Val, Sysid, Pubid, Ndata, IsParam)"
This is called when a entitizzle is declared. Y'all KNOW dat shit, muthafucka! For internal entities, tha Val
parameta will contain tha value n' tha remainin three parametas will be
undefined. Y'all KNOW dat shit, muthafucka! For external entities, tha Val parameta is ghon be undefined, the
Sysid parameta gonna git tha system id, tha Pubid parameta gonna git the
hood id if dat shiznit was provided (it is ghon be undefined otherwise), tha Ndata
parameta will contain tha notation fo' unparsed entities. Put ya muthafuckin choppers up if ya feel dis! If dis be a
parameta entitizzle declaration, then tha IsParam parameta is true.
.PP
Note dat dis handlez n' tha Unparsed handlez above overlap. If both are
set, then dis handlez aint gonna be called fo' unparsed entities.
.SS "Element                (Expat, Name, Model)"
.IX Subsection "Element (Expat, Name, Model)"
Da element handlez is called when a element declaration is found. Y'all KNOW dat shit, muthafucka! Name
is tha element name, n' Model is tha content model as a XML::Parser::Content
object. Right back up in yo muthafuckin ass. See \*(L"XML::Parser::ContentModel Methods\*(R" up in XML::Parser::Expat
for methodz available fo' dis class.
.SS "Attlist                (Expat, Elname, Attname, Type, Default, Fixed)"
.IX Subsection "Attlist (Expat, Elname, Attname, Type, Default, Fixed)"
This handlez is called fo' each attribute up in a \s-1ATTLIST\s0 declaration.
So a \s-1ATTLIST\s0 declaration dat has multiple attributes will generate multiple
calls ta dis handlez n' shit. Da Elname parameta is tha name of tha element with
which tha attribute is bein associated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da Attname parameta is tha name
of tha attribute. Type is tha attribute type, given as a string. Default is
the default value, which will either be \*(L"#REQUIRED\*(R", \*(L"#IMPLIED\*(R" or a quoted
strin (i.e. tha returned strang will begin n' end wit a quote character).
If Fixed is true, then dis be a gangbangin' fixed attribute.
.SS "Doctype                (Expat, Name, Sysid, Pubid, Internal)"
.IX Subsection "Doctype (Expat, Name, Sysid, Pubid, Internal)"
This handlez is called fo' \s-1DOCTYPE\s0 declarations. Name is tha document type
name. Right back up in yo muthafuckin ass. Sysid is tha system id of tha document type, if dat shiznit was provided,
otherwise itz undefined. Y'all KNOW dat shit, muthafucka! Pubid is tha hood id of tha document type,
which is ghon be undefined if no hood id was given. I aint talkin' bout chicken n' gravy biatch. Internal is tha internal
subset, given as a string. If there was no internal subset, it will be
undefined. Y'all KNOW dat shit, muthafucka! Internal will contain all whitespace, comments, processing
instructions, n' declarations peeped up in tha internal subset. Da declarations
will be there whether or not they done been processed by another handlez
(except fo' unparsed entitizzles processed by tha Unparsed handlez) yo. However,
comments n' processin instructions aint gonna step tha fuck up if they've been processed
by they respectizzle handlezs.
.SS "* DoctypeFin                (Parser)"
.IX Subsection "* DoctypeFin (Parser)"
This handlez is called afta parsin of tha \s-1DOCTYPE\s0 declaration has finished,
includin any internal or external \s-1DTD\s0 declarations.
.SS "XMLDecl                (Expat, Version, Encoding, Standalone)"
.IX Subsection "XMLDecl (Expat, Version, Encoding, Standalone)"
This handlez is called fo' xml declarations. Version be a strang containg
the version. I aint talkin' bout chicken n' gravy biatch. Encodin is either undefined or gotz nuff a encodin string.
Standalone is ghon be either true, false, or undefined if tha standalone attribute
is fo'sho, no, or not made respectively.
.SH "STYLES"
.IX Header "STYLES"
.SS "Debug"
.IX Subsection "Debug"
This just prints up tha document up in outline form. Nothang special is
returned by parse.
.SS "Subs"
.IX Subsection "Subs"
Each time a element starts, a sub by dat name up in tha package specified
by tha Pkg option is called wit tha same parametas dat tha Start
handlez gets called with.
.PP
Each time a element ends, a sub wit dat name appended wit a underscore
(\*(L"_\*(R"), is called wit tha same parametas dat tha End handlez gets called
with.
.PP
Nothang special is returned by parse.
.SS "Tree"
.IX Subsection "Tree"
Parse will return a parse tree fo' tha document. Each node up in tha tree
takes tha form of a tag, content pair. Shiiit, dis aint no joke. Text nodes is represented with
a pseudo-tag of \*(L"0\*(R" n' tha strang dat is they content. For elements,
the content be a array reference. Da first item up in tha array be a
(possibly empty) hash reference containin attributes. Da remainder of
the array be a sequence of tag-content pairs representin tha content
of tha element.
.PP
So fo' example tha result of parsing:
.PP
.Vb 1
\&  <foo><head id="a">Wuz crackalackin' <em>there</em></head><bar>Howdy<ref/></bar>do</foo>
.Ve
.PP
would be:
.PP
.Vb 7
\&             Tag   Content
\&  ==================================================================
\&  [foo, [{}, head, [{id => "a"}, 0, "Wuz crackalackin' ",  em, [{}, 0, "there"]],
\&              bar, [         {}, 0, "Howdy",  ref, [{}]],
\&                0, "do"
\&        ]
\&  ]
.Ve
.PP
Da root document \*(L"foo\*(R", has 3 children: a \*(L"head\*(R" element, a \*(L"bar\*(R"
element n' tha text \*(L"do\*(R" fo' realz. Afta tha empty attribute hash, these are
represented up in itz contents by 3 tag-content pairs.
.SS "Objects"
.IX Subsection "Objects"
This is similar ta tha Tree style, except dat a hash object is pimped for
each element. Da correspondin object is ghon be up in tha class whose name
is pimped by appendin \*(L"::\*(R" n' tha element name ta tha package set with
the Pkg option. I aint talkin' bout chicken n' gravy biatch. Non-markup text is ghon be up in tha ::Charactas class. The
contentz of tha correspondin object is ghon be up in a anonymous array that
is tha value of tha Kidz property fo' dat object.
.SS "Stream"
.IX Subsection "Stream"
This steez also uses tha Pkg package. If none of tha subs dat this
style looks fo' is there, then tha effect of parsin wit dis steez is
to print a cold-ass lil canonical copy of tha document without comments or declarations.
All tha subs receive as they 1st parameta tha Expat instizzle fo' the
document they parsing.
.PP
It looks fo' tha followin routines:
.IP "\(bu" 4
StartDocument
.Sp
Called all up in tha start of tha parse .
.IP "\(bu" 4
StartTag
.Sp
Called fo' every last muthafuckin start tag wit a second parameta of tha element type. Da \f(CW$_\fR
variable will contain a cold-ass lil copy of tha tag n' tha \f(CW%_\fR variable will contain
attribute joints supplied fo' dat element.
.IP "\(bu" 4
EndTag
.Sp
Called fo' every last muthafuckin end tag wit a second parameta of tha element type. Da \f(CW$_\fR
variable will contain a cold-ass lil copy of tha end tag.
.IP "\(bu" 4
Text
.Sp
Called just before start or end tags wit accumulated non-markup text in
the \f(CW$_\fR variable.
.IP "\(bu" 4
\&\s-1PI\s0
.Sp
Called fo' processin instructions. Da \f(CW$_\fR variable will contain a cold-ass lil copy of
the \s-1PI\s0 n' tha target n' data is busted as 2nd n' 3rd parameters
respectively.
.IP "\(bu" 4
EndDocument
.Sp
Called at conclusion of tha parse.
.SH "ENCODINGS"
.IX Header "ENCODINGS"
\&\s-1XML\s0 documents may be encoded up in characta sets other than Unicode as
long as they may be mapped tha fuck into tha Unicode characta set. Expat has
further restrictions on encodings. Read tha xmlparse.h header file in
the expat distribution ta peep details on these restrictions.
.PP
Expat has built-in encodings for: \f(CW\*(C`UTF\-8\*(C'\fR, \f(CW\*(C`ISO\-8859\-1\*(C'\fR, \f(CW\*(C`UTF\-16\*(C'\fR, and
\&\f(CW\*(C`US\-ASCII\*(C'\fR. Encodings is set either all up in tha \s-1XML\s0 declaration
encodin attribute or all up in tha ProtocolEncodin option ta XML::Parser
or XML::Parser::Expat.
.PP
For encodings other than tha built-ins, expat calls tha function
load_encodin up in tha Expat package wit tha encodin name. This function
looks fo' a gangbangin' file up in tha path list \f(CW@XML::Parser::Expat::Encoding_Path\fR, that
matches tha lower-cased name wit a '.enc' extension. I aint talkin' bout chicken n' gravy biatch. Da first one it
finds, it loads.
.PP
If you wish ta build yo' own encodin maps, check up tha XML::Encoding
module from \s-1CPAN.\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
Larry Wall <\fIlarry@wall.org\fR> freestyled version 1.0.
.PP
Clark Cooper <\fIcoopercc@netheaven.com\fR> picked up support, chizzled tha \s-1API\s0
for dis version (2.x), provided documentation,
and added some standard package features.
.PP
Mack Sergeant <\fImatt@sergeant.org\fR> is now maintainin XML::Parser
