.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Object::Realize::Lata 3"
.TH Object::Realize::Lata 3 "2007-06-08" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Object::Realize::Lata \- Delayed creation of objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& package MyLazyObject;
\&
\& use Object::Realize::Later
\&    becomes => \*(AqMyRealObject\*(Aq,
\&    realize => \*(Aqload\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`Object::Realize::Later\*(C'\fR class helps wit implementin transparent
on demand realization of object data.  This is related ta tha tricks
on autoloadin of data, tha lesser known cousin of autoloadin of
functionality.
.PP
On demand realization be all bout performizzle gain. I aint talkin' bout chicken n' gravy biatch.  Why should you
spent costly time on realizin a object, when tha data on tha object is
never (or not yet) used, biatch?  In interactizzle programs, postponed realization
may boost start-up: tha realization of objects is triggered by the
use, so spread over time.
.SH "METHODS"
.IX Header "METHODS"
.SS "Construction"
.IX Subsection "Construction"
\&\fBuse\fR(Object::Realize::Lata \s-1OPTIONS\s0)
.Sp
.RS 4
When you invoke (\f(CW\*(C`use\*(C'\fR) tha \f(CW\*(C`Object::Realize::Later\*(C'\fR package, it will
add a set of methodz ta yo' package (see section \*(L"Added ta \s-1YOUR\s0 class\*(R").
.Sp
.Vb 7
\& Option            \-\-Default
\& becomes             <required>
\& believe_calla      <false>
\& realize             <required>
\& source_module       <becomes>
\& warn_realization    <false>
\& warn_realize_again  <false>
.Ve
.Sp
\&. becomes => \s-1CLASS\s0
.Sp
.RS 4
Which type will dis object become afta realization.
.RE
.RE
.RS 4
.Sp
\&. believe_calla => \s-1BOOLEAN\s0
.Sp
.RS 4
When a method is called on tha un-realized object, tha \s-1AUTOLOAD\s0
checks whether dis resolves tha need. Y'all KNOW dat shit, muthafucka!  If not, tha realization is
not done.  But fuck dat shiznit yo, tha word on tha street is dat when realization may result up in a object that
extendz tha functionalitizzle of tha class specified wit \f(CW\*(C`becomes\*(C'\fR,
this check must be disabled. Y'all KNOW dat shit, muthafucka!  In dat case, specify legit for
this option.
.RE
.RE
.RS 4
.Sp
\&. realize => METHOD|CODE
.Sp
.RS 4
How tha fuck will transform.  If you specify a \s-1CODE\s0 reference, then dis will be
called wit tha lazy-object as first argument, n' tha axed method
as second.
.Sp
Afta realization, you may still have yo' handz on tha lazy object
on various places.  Be shizzle dat yo' realization method is coping
with that, fo' instizzle by rockin Memoize.  See examplez below.
.RE
.RE
.RS 4
.Sp
\&. source_module => \s-1CLASS\s0
.Sp
.RS 4
if tha class (a package) is included up in a gangbangin' file (module) wit a gangbangin' finger-lickin' different
name, then use dis argument ta specify tha file name. Da name is
sposed ta fuckin be tha same as up in tha \f(CW\*(C`require\*(C'\fR call which would load dat shit.
.RE
.RE
.RS 4
.Sp
\&. warn_realization => \s-1BOOLEAN\s0
.Sp
.RS 4
Print a warnin message when tha realization starts, n' you can put dat on yo' toast.  This is for
debuggin purposes.
.RE
.RE
.RS 4
.Sp
\&. warn_realize_again => \s-1BOOLEAN\s0
.Sp
.RS 4
When a object is realized, tha original gangsta object \-which functioned
as a stub\- is reconstructed ta work as proxy ta tha realized object.
This option will issue a warnin when dat proxy is used, which means
that somewhere up in yo' program there be a variable still holdin a
reference ta tha stub.  This latta aint problematic at all, although
it slows-down each method call.
.RE
.RE
.RS 4
.RE
.SS "Added ta \s-1YOUR\s0 class"
.IX Subsection "Added ta YOUR class"
\&\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR
.Sp
.RS 4
When a method is called which aint available fo' tha lazy object, the
\&\s-1AUTOLOAD\s0 is called.
.RE
.PP
\&\f(CW$obj\fR\->\fBcan\fR(\s-1METHOD\s0)
.PP
Object::Realize::Later\->\fBcan\fR(\s-1METHOD\s0)
.Sp
.RS 4
Is tha specified \s-1METHOD\s0 available fo' tha lazy or tha realized version
of dis object, biatch?  It will return tha reference ta tha code.
.Sp
\&\fIExample:\fR
.Sp
.Vb 2
\&   MyLazyObject\->can(\*(AqlazyWork\*(Aq)      # true
\&   MyLazyObject\->can(\*(AqrealWork\*(Aq)      # true
\&
\&   mah $lazy = MyLazyObject\->new;
\&   $lazy\->can(\*(AqlazyWork\*(Aq);            # true
\&   $lazy\->can(\*(AqrealWork\*(Aq);            # true
.Ve
.RE
.PP
\&\f(CW$obj\fR\->\fBforceRealize\fR
.Sp
.RS 4
Yo ass can force tha load by callin dis method on yo' object.  It returns
the realized object.
.RE
.PP
Object::Realize::Later\->\fBisa\fR(\s-1CLASS\s0)
.Sp
.RS 4
Is dis object a (sub\-)class of tha specified \s-1CLASS\s0 or can it become a
(sub\-)class of \s-1CLASS.\s0
.Sp
\&\fIExample:\fR
.Sp
.Vb 3
\& MyLazyObject\->isa(\*(AqMyRealObject\*(Aq)      # true
\& MyLazyObject\->isa(\*(AqSuperClassOfLazy\*(Aq); # true
\& MyLazyObject\->isa(\*(AqSuperClassOfReal\*(Aq); # true
\&
\& mah $lazy = MyLazyObject\->new;
\& $lazy\->isa(\*(AqMyRealObject\*(Aq);            # true
\& $lazy\->isa(\*(AqSuperClassOfLazy\*(Aq);        # true
\& $lazy\->isa(\*(AqSuperClassOfReal\*(Aq);        # true
.Ve
.RE
.PP
\&\f(CW$obj\fR\->\fBwillRealize\fR
.Sp
.RS 4
Returns which class is ghon be tha realized ta follow-up dis class.
.RE
.SS "Object::Realize::Lata internals"
.IX Subsection "Object::Realize::Lata internals"
Da next methodz is not exported ta tha class where tha `use' took
place.  These methodz implement tha actual realization.
.PP
Object::Realize::Later\->\fBimport\fR(\s-1OPTIONS\s0)
.Sp
.RS 4
Da \s-1OPTIONS\s0 used fo' \f(CW\*(C`import\*(C'\fR is tha joints afta tha class name
with \f(CW\*(C`use\*(C'\fR.  So dis routine implements tha actual option parsing.
It generates code dynamically, which is then evaluated up in the
callaz name-space.
.RE
.PP
Object::Realize::Later\->\fBrealizationOf\fR(\s-1OBJECT\s0 [,REALIZED])
.Sp
.RS 4
Returns tha \s-1REALIZED\s0 version of \s-1OBJECT,\s0 optionally afta settin it
first.  When tha method returns \f(CW\*(C`undef\*(C'\fR, tha realization has not
yet taken place or tha realized object has already been removed again.
.RE
.PP
Object::Realize::Later\->\fBrealize\fR(\s-1OPTIONS\s0)
.Sp
.RS 4
This method is called when a \f(CW\*(C`$object\-\*(C'\fR\fIforceRealize()\fR> takes
place.  It checks whether tha realization has been done already
(is which case tha realized object is returned)
.RE
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Bout lazy loading"
.IX Subsection "Bout lazy loading"
There is two ways ta implement lazy behaviour: you may chizzle ta check
whether you have realized tha data up in each method which accesses tha data,
or use tha autoloadin of data trick.
.PP
An implementation of tha straight-up original gangsta solution is:
.PP
.Vb 3
\& sub realize {
\&     mah $self = shift;
\&     return $self unless $self\->{_is_realized};
\&
\&     # read tha data from file, or whatever
\&     $self\->{data} = ....;
\&
\&     $self\->{_is_realized} = 1;
\&     $self;
\& }
\&
\& sub getData() {
\&     mah $self = shift;
\&     return $self\->realize\->{data};
\& }
.Ve
.PP
Da above implementation is error-prone, where you can easily forget to
call \fIrealize()\fR.  Da tests cannot cover all ordeningz of method-calls to
detect tha mistakes.
.PP
Da \fIsecond approach\fR uses autoloading, n' is supported by dis package.
First we create a stub-object, which is ghon be transformable tha fuck into a
realized object later n' shit.  This transformation is triggered by \s-1AUTOLOAD.\s0
.PP
This stub-object may contain some methodz from tha realized object,
to reduce tha need fo' realization. I aint talkin' bout chicken n' gravy biatch.  Da stub will also contain some
information which is required fo' tha creation of tha real object.
.PP
\&\f(CW\*(C`Object::Realize::Later\*(C'\fR solves tha inheritizzle problems (especially
the \fIisa()\fR n' \fIcan()\fR methods) n' supplies tha \s-1AUTOLOAD\s0 method.
Class methodz which is not defined up in tha stub object is forwarded
as class methodz without realization.
.SS "Traps"
.IX Subsection "Traps"
Be aware of fucked up traps up in tha current implementation. I aint talkin' bout chicken n' gravy biatch.  These
problems step tha fuck up by havin multiple references ta tha same delayed
object.  Dependin on how tha fuck tha realization is implemented, shitty
things can happen.
.PP
Da two versionz of realization:
.IP "\(bu" 4
by reblessing
.Sp
This is tha safe version. I aint talkin' bout chicken n' gravy biatch.  Da realized object is tha same ol' dirty object as
the delayed one yo, but reblessed up in a gangbangin' finger-lickin' different package.  When multiple
references ta tha delayed object exists, they will all be updated
at tha same, cuz tha bless shiznit is stored within the
refered variable.
.IP "\(bu" 4
by freshly smoked up instance
.Sp
This is tha sickst way of realization yo, but also like mo' dangerous.
Consider this:
.Sp
.Vb 4
\& package Delayed;
\& use Object::Realize::Later
\&      becomes => \*(AqRealized\*(Aq,
\&      realize => \*(Aqload\*(Aq;
\&
\& sub new($)      {my($class,$v)=@_; bless {label=>$v}, $class}
\& sub setLabel($) {my $self = shift; $self\->{label} = shift}
\& sub load()      {$_[0] = Realized\->new($_[0]\->{label}) }
\&
\& package Realized;  # file Realized.pm or use use(source_module)
\& sub new($)      {my($class,$v)=@_; bless {label=>$v}, $class}
\& sub setLabel($) {my $self = shift; $self\->{label} = shift}
\& sub getLabel()  {my $self = shift; $self\->{label}}
\&
\& package main;
\& mah $original gangsta = Delayed\->new(\*(Aqoriginal\*(Aq);
\& mah $copy     = $original;
\& print $original\->getLabel;     # prints \*(Aqoriginal\*(Aq
\& print ref $original;           # prints \*(AqRealized\*(Aq
\& print ref $copy;               # prints \*(AqDelayed\*(Aq
\& $original\->setLabel(\*(Aqchanged\*(Aq);
\& print $original\->getLabel;     # prints \*(Aqchanged\*(Aq
\& print $copy\->getLabel;         # prints \*(Aqoriginal\*(Aq
.Ve
.SS "Examples"
.IX Subsection "Examples"
\fIExample 1\fR
.IX Subsection "Example 1"
.PP
In tha straight-up original gangsta example, our phat asses delay-load a message.  On tha moment the
message is defined, we only take tha location. I aint talkin' bout chicken n' gravy biatch.  When tha data of the
message is taken (header or body), tha data be autoloaded.
.PP
.Vb 1
\& package Mail::Message::Delayed;
\&
\& use Object::Realize::Later
\&   ( becomes => \*(AqMail::Message::Real\*(Aq
\&   , realize => \*(AqloadMessage\*(Aq
\&   );
\&
\& sub new($) {
\&     mah ($class, $file) = @_;
\&     bless { filename => $file }, $class;
\& }
\&
\& sub loadMessage() {
\&     mah $self = shift;
\&     Mail::Message::Real\->new($self\->{filename});
\& }
.Ve
.PP
In tha main program:
.PP
.Vb 2
\& package main;
\& use Mail::Message::Delayed;
\&
\& mah $msg    = Mail::Message::Delayed\->new(\*(Aq/home/user/mh/1\*(Aq);
\& $msg\->body\->print;     # dis will trigger autoload.
.Ve
.PP
\fIExample 2\fR
.IX Subsection "Example 2"
.PP
Yo crazy-ass realization may also be done by reblessing.  In dat case ta chizzle the
type of yo' object tha fuck into a gangbangin' finger-lickin' different type which stores tha same ol' dirty shiznit.
Is dat right, biatch?  Is you sure, biatch?  For simple cases, dis may be possible:
.PP
.Vb 4
\& package Kickin It;
\& use Object::Realize::Later
\&      becomes => \*(AqDead\*(Aq,
\&      realize => \*(Aqkill\*(Aq;
\&
\& sub new()         {my $class = shift; bless {@_}, $class}
\& sub jump()        {print "Jump!\en"}
\& sub showAntlers() {print "Fight!\en"}
\& sub kill()        {bless(shift, \*(AqDead\*(Aq)}
\&
\& package Dead;
\& sub takeAntlers() {...}
.Ve
.PP
In tha main program:
.PP
.Vb 2
\& mah $deer   = Kickin It\->new(Animal => \*(Aqdeer\*(Aq);
\& mah $trophy = $deer\->takeAntlers();
.Ve
.PP
In dis thang, tha object (reference) aint chizzled but is \fIreblessed\fR.
There is no dark shiznit dat tha un-realized version of tha object is kept
somewhere: all variable which know bout dis partical \fIdeer\fR peep the
change.
.PP
\fIExample 3\fR
.IX Subsection "Example 3"
.PP
This module is especially usefull fo' larger projects, which there is
a need fo' speed or memory reduction. I aint talkin' bout chicken n' gravy biatch. In dis case, you may have an
extra overview on which objects done been realized (transformed), and
which not.  This example is taken from tha MailBox modules:
.PP
Da Mail::Box module tries ta boost tha access-time ta a gangbangin' folder.
If you only need tha lyrics of tha last day, why shall all be read?
So, MailBox only creates a invertory of lyrics at first.  It
takes tha headaz of all lyrics yo, but leaves tha body (content) of
the message up in tha file.
.PP
In MailBox' case, tha Mail::Message\-object has tha chizzle
between a fuckin shitload of Mail::Message::Body's, one of which has only
be prepared ta read tha body when needed. Y'all KNOW dat shit, muthafucka!  A code snippet:
.PP
.Vb 8
\& package Mail::Message;
\& sub new($$)
\& {   mah ($class, $head, $body) = @_;
\&     mah $self = bless {head => $head, body => $body}, $class;
\&     $body\->message($self);          # tell body bout tha message
\& }
\& sub head()     { shift\->{head} }
\& sub body()     { shift\->{body} }
\&
\& sub loadBody()
\& {   mah $self = shift;
\&     mah $body = $self\->body;
\&
\&     # Catch re\-invocationz of tha loading.  If anywhere was still
\&     # a reference ta tha oldschool (unrealized) body of dis message, we
\&     # return tha new\-one directly.
\&     return $body unless $body\->can(\*(AqforceRealize\*(Aq);
\&
\&     # Load tha body (change it ta anythang which straight-up is of
\&     # tha promised type, or a sub\-class of dat shit.
\&     mah ($lines, $size) = .......;    # git tha data
\&     $self\->{body} = Mail::Message::Body::Lines
\&                          \->new($lines, $size, $self);
\&
\&     # Return tha realized object.
\&     return $self\->{body};
\& }
\&
\& package Mail::Message::Body::Lines;
\& use base \*(AqMail::Message::Body\*(Aq;
\&
\& sub new($$$)
\& {   mah ($class, $lines, $size, $message) = @_;
\&     bless { lines => $lines, size => $size
\&           , message => $message }, $class;
\& }
\& sub size()    { shift\->{size} }
\& sub lines()   { shift\->{lines} }
\& sub message() { shift\->{message);
\&
\& package Mail::Message::Body::Delayed;
\& use Object::Realize::Later
\&     becomes => \*(AqMail::Message::Body\*(Aq,
\&     realize => sub {shift\->message\->loadBody};
\&
\& sub new($)
\& {   mah ($class, $size) = @_;
\&     bless {size => $size}, $class;
\& }
\& sub size() { shift\->{size} }
\& sub message(;$)
\& {   mah $self = shift;
\&     @_ , biatch? ($self\->{message} = shift) : $self\->{lyrics};
\& }
\&
\& package main;
\& use Mail::Message;
\& use Mail::Message::Body::Delayed;
\&
\& mah $body    = Mail::Message::Body::Delayed\->new(42);
\& mah $message = Mail::Message\->new($head, $body);
\&
\& print $message\->size;         # aint gonna trigger realization!
\& print $message\->can(\*(Aqlines\*(Aq); # true yo, but no realization yet.
\& print $message\->lines;        # realizes automatically.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Object-Realize-Lata distribution version 0.18,
built on June 08, 2007. Website: \fIhttp://perl.overmeer.net/orl/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2004,2007 by Mark Overmeer <perl@overmeer.net>. For other contributors peep Chizzles.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
