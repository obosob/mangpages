.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bn_internal 3"
.TH bn_internal 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
bn_mul_words, bn_mul_add_words, bn_sqr_words, bn_div_words,
bn_add_words, bn_sub_words, bn_mul_comba4, bn_mul_comba8,
bn_sqr_comba4, bn_sqr_comba8, bn_cmp_words, bn_mul_normal,
bn_mul_low_normal, bn_mul_recursive, bn_mul_part_recursive,
bn_mul_low_recursive, bn_mul_high, bn_sqr_normal, bn_sqr_recursive,
bn_expand, bn_wexpand, bn_expand2, bn_fix_top, bn_check_top,
bn_print, bn_dump, bn_set_max, bn_set_high, bn_set_low \- BIGNUM
library internal functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bn.h>
\&
\& BN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w);
\& BN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num,
\&   BN_ULONG w);
\& void     bn_sqr_words(BN_ULONG *rp, BN_ULONG *ap, int num);
\& BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d);
\& BN_ULONG bn_add_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
\&   int num);
\& BN_ULONG bn_sub_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
\&   int num);
\&
\& void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
\& void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
\& void bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a);
\& void bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a);
\&
\& int bn_cmp_words(BN_ULONG *a, BN_ULONG *b, int n);
\&
\& void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b,
\&   int nb);
\& void bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n);
\& void bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,
\&   int dna,int dnb,BN_ULONG *tmp);
\& void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
\&   int n, int tna,int tnb, BN_ULONG *tmp);
\& void bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
\&   int n2, BN_ULONG *tmp);
\& void bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l,
\&   int n2, BN_ULONG *tmp);
\&
\& void bn_sqr_normal(BN_ULONG *r, BN_ULONG *a, int n, BN_ULONG *tmp);
\& void bn_sqr_recursive(BN_ULONG *r, BN_ULONG *a, int n2, BN_ULONG *tmp);
\&
\& void mul(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
\& void mul_add(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
\& void sqr(BN_ULONG r0, BN_ULONG r1, BN_ULONG a);
\&
\& BIGNUM *bn_expand(BIGNUM *a, int bits);
\& BIGNUM *bn_wexpand(BIGNUM *a, int n);
\& BIGNUM *bn_expand2(BIGNUM *a, int n);
\& void bn_fix_top(BIGNUM *a);
\&
\& void bn_check_top(BIGNUM *a);
\& void bn_print(BIGNUM *a);
\& void bn_dump(BN_ULONG *d, int n);
\& void bn_set_max(BIGNUM *a);
\& void bn_set_high(BIGNUM *r, BIGNUM *a, int n);
\& void bn_set_low(BIGNUM *r, BIGNUM *a, int n);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page documents tha internal functions used by tha OpenSSL
\&\fB\s-1BIGNUM\s0\fR implementation. I aint talkin' bout chicken n' gravy biatch. They is busted lyrics bout here ta facilitate
debuggin n' extendin tha library. They is \fInot\fR ta be used by
applications.
.SS "Da \s-1BIGNUM\s0 structure"
.IX Subsection "Da BIGNUM structure"
.Vb 1
\& typedef struct bignum_st BIGNUM;
\&
\& struct bignum_st
\&        {
\&        BN_ULONG *d;    /* Pointa ta a array of \*(AqBN_BITS2\*(Aq bit chunks. */
\&        int top;        /* Index of last used d +1. */
\&        /* Da next is internal book keepin fo' bn_expand. Y'all KNOW dat shit, muthafucka! */
\&        int dmax;       /* Size of tha d array. */
\&        int neg;        /* one if tha number is wack */
\&        int flags;
\&        };
.Ve
.PP
Da integer value is stored up in \fBd\fR, a \fImalloc()\fRed array of lyrics (\fB\s-1BN_ULONG\s0\fR),
least dope word first fo' realz. A \fB\s-1BN_ULONG\s0\fR can be either 16, 32 or 64 bits
in size, dependin on tha 'number of bits' (\fB\s-1BITS2\s0\fR) specified in
\&\f(CW\*(C`openssl/bn.h\*(C'\fR.
.PP
\&\fBdmax\fR is tha size of tha \fBd\fR array dat has been allocated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \fBtop\fR
is tha number of lyrics bein used, so fo' a value of 4, bn.d[0]=4 and
bn.top=1.  \fBneg\fR is 1 if tha number is negative.  When a \fB\s-1BIGNUM\s0\fR is
\&\fB0\fR, tha \fBd\fR field can be \fB\s-1NULL\s0\fR n' \fBtop\fR == \fB0\fR.
.PP
\&\fBflags\fR be a lil' bit field of flags which is defined up in \f(CW\*(C`openssl/bn.h\*(C'\fR. Da 
flags begin wit \fB\s-1BN_FLG_\s0\fR. Da macros BN_set_flags(b,n) n' 
BN_get_flags(b,n) exist ta enable or fetch flag(s) \fBn\fR from \fB\s-1BIGNUM\s0\fR
structure \fBb\fR.
.PP
Various routines up in dis library require tha use of temporary
\&\fB\s-1BIGNUM\s0\fR variablez durin they execution. I aint talkin' bout chicken n' gravy biatch.  Since dynamic memory
allocation ta create \fB\s-1BIGNUM\s0\fRs is rather high-rollin' when used in
conjunction wit repeated subroutine calls, tha \fB\s-1BN_CTX\s0\fR structure is
used. Y'all KNOW dat shit, muthafucka!  This structure gotz nuff \fB\s-1BN_CTX_NUM\s0\fR \fB\s-1BIGNUM\s0\fRs, see
\&\fIBN_CTX_start\fR\|(3).
.SS "Low-level arithmetic operations"
.IX Subsection "Low-level arithmetic operations"
These functions is implemented up in C n' fo' nuff muthafuckin platforms in
assembly language:
.PP
bn_mul_words(\fBrp\fR, \fBap\fR, \fBnum\fR, \fBw\fR) operates on tha \fBnum\fR word
arrays \fBrp\fR n' \fBap\fR.  It computes \fBap\fR * \fBw\fR, places tha result
in \fBrp\fR, n' returns tha high word (carry).
.PP
bn_mul_add_words(\fBrp\fR, \fBap\fR, \fBnum\fR, \fBw\fR) operates on tha \fBnum\fR
word arrays \fBrp\fR n' \fBap\fR.  It computes \fBap\fR * \fBw\fR + \fBrp\fR, places
the result up in \fBrp\fR, n' returns tha high word (carry).
.PP
bn_sqr_words(\fBrp\fR, \fBap\fR, \fBn\fR) operates on tha \fBnum\fR word array
\&\fBap\fR n' tha 2*\fBnum\fR word array \fBap\fR.  It computes \fBap\fR * \fBap\fR
word-wise, n' places tha low n' high bytez of tha result up in \fBrp\fR.
.PP
bn_div_words(\fBh\fR, \fBl\fR, \fBd\fR) divides tha two word number (\fBh\fR,\fBl\fR)
by \fBd\fR n' returns tha result.
.PP
bn_add_words(\fBrp\fR, \fBap\fR, \fBbp\fR, \fBnum\fR) operates on tha \fBnum\fR word
arrays \fBap\fR, \fBbp\fR n' \fBrp\fR.  It computes \fBap\fR + \fBbp\fR, places the
result up in \fBrp\fR, n' returns tha high word (carry).
.PP
bn_sub_words(\fBrp\fR, \fBap\fR, \fBbp\fR, \fBnum\fR) operates on tha \fBnum\fR word
arrays \fBap\fR, \fBbp\fR n' \fBrp\fR.  It computes \fBap\fR \- \fBbp\fR, places the
result up in \fBrp\fR, n' returns tha carry (1 if \fBbp\fR > \fBap\fR, 0
otherwise).
.PP
bn_mul_comba4(\fBr\fR, \fBa\fR, \fBb\fR) operates on tha 4 word arrays \fBa\fR and
\&\fBb\fR n' tha 8 word array \fBr\fR.  It computes \fBa\fR*\fBb\fR n' places the
result up in \fBr\fR.
.PP
bn_mul_comba8(\fBr\fR, \fBa\fR, \fBb\fR) operates on tha 8 word arrays \fBa\fR and
\&\fBb\fR n' tha 16 word array \fBr\fR.  It computes \fBa\fR*\fBb\fR n' places the
result up in \fBr\fR.
.PP
bn_sqr_comba4(\fBr\fR, \fBa\fR, \fBb\fR) operates on tha 4 word arrays \fBa\fR and
\&\fBb\fR n' tha 8 word array \fBr\fR.
.PP
bn_sqr_comba8(\fBr\fR, \fBa\fR, \fBb\fR) operates on tha 8 word arrays \fBa\fR and
\&\fBb\fR n' tha 16 word array \fBr\fR.
.PP
Da followin functions is implemented up in C:
.PP
bn_cmp_words(\fBa\fR, \fBb\fR, \fBn\fR) operates on tha \fBn\fR word arrays \fBa\fR
and \fBb\fR.  It returns 1, 0 n' \-1 if \fBa\fR is pimped outa than, equal and
less than \fBb\fR.
.PP
bn_mul_normal(\fBr\fR, \fBa\fR, \fBna\fR, \fBb\fR, \fBnb\fR) operates on tha \fBna\fR
word array \fBa\fR, tha \fBnb\fR word array \fBb\fR n' tha \fBna\fR+\fBnb\fR word
array \fBr\fR.  It computes \fBa\fR*\fBb\fR n' places tha result up in \fBr\fR.
.PP
bn_mul_low_normal(\fBr\fR, \fBa\fR, \fBb\fR, \fBn\fR) operates on tha \fBn\fR word
arrays \fBr\fR, \fBa\fR n' \fBb\fR.  It computes tha \fBn\fR low lyrics of
\&\fBa\fR*\fBb\fR n' places tha result up in \fBr\fR.
.PP
bn_mul_recursive(\fBr\fR, \fBa\fR, \fBb\fR, \fBn2\fR, \fBdna\fR, \fBdnb\fR, \fBt\fR) operates
on tha word arrays \fBa\fR n' \fBb\fR of length \fBn2\fR+\fBdna\fR n' \fBn2\fR+\fBdnb\fR
(\fBdna\fR n' \fBdnb\fR is currently allowed ta be 0 or negative) n' tha 2*\fBn2\fR
word arrays \fBr\fR n' \fBt\fR.  \fBn2\fR must be a juice of 2.  It computes
\&\fBa\fR*\fBb\fR n' places tha result up in \fBr\fR.
.PP
bn_mul_part_recursive(\fBr\fR, \fBa\fR, \fBb\fR, \fBn\fR, \fBtna\fR, \fBtnb\fR, \fBtmp\fR)
operates on tha word arrays \fBa\fR n' \fBb\fR of length \fBn\fR+\fBtna\fR and
\&\fBn\fR+\fBtnb\fR n' tha 4*\fBn\fR word arrays \fBr\fR n' \fBtmp\fR.
.PP
bn_mul_low_recursive(\fBr\fR, \fBa\fR, \fBb\fR, \fBn2\fR, \fBtmp\fR) operates on the
\&\fBn2\fR word arrays \fBr\fR n' \fBtmp\fR n' tha \fBn2\fR/2 word arrays \fBa\fR
and \fBb\fR.
.PP
bn_mul_high(\fBr\fR, \fBa\fR, \fBb\fR, \fBl\fR, \fBn2\fR, \fBtmp\fR) operates on the
\&\fBn2\fR word arrays \fBr\fR, \fBa\fR, \fBb\fR n' \fBl\fR (?) n' tha 3*\fBn2\fR word
array \fBtmp\fR.
.PP
\&\fIBN_mul()\fR calls \fIbn_mul_normal()\fR, or a optimized implementation if the
factors have tha same size: \fIbn_mul_comba8()\fR is used if they is 8
wordz long, \fIbn_mul_recursive()\fR if they is larger than
\&\fB\s-1BN_MULL_SIZE_NORMAL\s0\fR n' tha size be a exact multiple of tha word
size, n' \fIbn_mul_part_recursive()\fR fo' others dat is larger than
\&\fB\s-1BN_MULL_SIZE_NORMAL\s0\fR.
.PP
bn_sqr_normal(\fBr\fR, \fBa\fR, \fBn\fR, \fBtmp\fR) operates on tha \fBn\fR word array
\&\fBa\fR n' tha 2*\fBn\fR word arrays \fBtmp\fR n' \fBr\fR.
.PP
Da implementations use tha followin macros which, dependin on the
architecture, may use \*(L"long long\*(R" C operations or inline assembler.
They is defined up in \f(CW\*(C`bn_lcl.h\*(C'\fR.
.PP
mul(\fBr\fR, \fBa\fR, \fBw\fR, \fBc\fR) computes \fBw\fR*\fBa\fR+\fBc\fR n' places the
low word of tha result up in \fBr\fR n' tha high word up in \fBc\fR.
.PP
mul_add(\fBr\fR, \fBa\fR, \fBw\fR, \fBc\fR) computes \fBw\fR*\fBa\fR+\fBr\fR+\fBc\fR and
places tha low word of tha result up in \fBr\fR n' tha high word up in \fBc\fR.
.PP
sqr(\fBr0\fR, \fBr1\fR, \fBa\fR) computes \fBa\fR*\fBa\fR n' places tha low word
of tha result up in \fBr0\fR n' tha high word up in \fBr1\fR.
.SS "Size chizzles"
.IX Subsection "Size chizzles"
\&\fIbn_expand()\fR ensures dat \fBb\fR has enough space fo' a \fBbits\fR bit
number n' shit.  \fIbn_wexpand()\fR ensures dat \fBb\fR has enough space fo' an
\&\fBn\fR word number n' shit.  If tha number has ta be expanded, both macros
call \fIbn_expand2()\fR, which allocates a freshly smoked up \fBd\fR array n' copies the
data.  They return \fB\s-1NULL\s0\fR on error, \fBb\fR otherwise.
.PP
Da \fIbn_fix_top()\fR macro reduces \fBa\->top\fR ta point ta da most thugged-out
significant non-zero word plus one when \fBa\fR has shrunk.
.SS "Debugging"
.IX Subsection "Debugging"
\&\fIbn_check_top()\fR verifies dat \f(CW\*(C`((a)\->top >= 0 && (a)\->top
<= (a)\->dmax)\*(C'\fR.  A violation will cause tha program ta abort.
.PP
\&\fIbn_print()\fR prints \fBa\fR ta stderr. Shiiit, dis aint no joke. \fIbn_dump()\fR prints \fBn\fR lyrics at \fBd\fR
(in reverse order, i.e. most dope word first) ta stderr.
.PP
\&\fIbn_set_max()\fR make \fBa\fR a static number wit a \fBdmax\fR of its current size.
This is used by \fIbn_set_low()\fR n' \fIbn_set_high()\fR ta make \fBr\fR a read-only
\&\fB\s-1BIGNUM\s0\fR dat gotz nuff tha \fBn\fR low or high lyrics of \fBa\fR.
.PP
If \fB\s-1BN_DEBUG\s0\fR aint defined, \fIbn_check_top()\fR, \fIbn_print()\fR, \fIbn_dump()\fR
and \fIbn_set_max()\fR is defined as empty macros.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIbn\fR\|(3)
