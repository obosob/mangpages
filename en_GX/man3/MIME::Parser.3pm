.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MIME::Parser 3"
.TH MIME::Parser 3 "2013-11-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME::Parser \- experimenstrual class fo' parsin MIME streams
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Before readin further, you should peep MIME::Tools ta make shizzle that
you KNOW where dis module fits tha fuck into tha grand scheme of thangs.
Go on, do it now, nahmeean?  I be bout ta wait.
.PP
Ready?  Ok...
.SS "Basic usage examples"
.IX Subsection "Basic usage examples"
.Vb 2
\&    ### Smoke a freshly smoked up parser object:
\&    mah $parser = freshly smoked up MIME::Parser;
\&
\&    ### Tell it where ta put thangs:
\&    $parser\->output_under("/tmp");
\&
\&    ### Parse a input filehandle:
\&    $entitizzle = $parser\->parse(\e*STDIN);
\&
\&    ### Congratulations: you now gotz a (possibly multipart) MIME entity!
\&    $entity\->dump_skeleton;          # fo' debugging
.Ve
.SS "Examplez of input"
.IX Subsection "Examplez of input"
.Vb 3
\&    ### Parse from filehandles:
\&    $entitizzle = $parser\->parse(\e*STDIN);
\&    $entitizzle = $parser\->parse(IO::File\->new("some command|");
\&
\&    ### Parse from any object dat supports getline() n' read():
\&    $entitizzle = $parser\->parse($myHandle);
\&
\&    ### Parse a in\-core MIME message:
\&    $entitizzle = $parser\->parse_data($message);
\&
\&    ### Parse a MIME message up in a gangbangin' file:
\&    $entitizzle = $parser\->parse_open("/some/file.msg");
\&
\&    ### Parse a MIME message outta a pipeline:
\&    $entitizzle = $parser\->parse_open("gunzip \- < file.msg.gz |");
\&
\&    ### Parse already\-split input (as "deliver" would give it ta you):
\&    $entitizzle = $parser\->parse_two("msg.head", "msg.body");
.Ve
.SS "Examplez of output control"
.IX Subsection "Examplez of output control"
.Vb 2
\&    ### Keep parsed message bodies up in core (default outputs ta disk):
\&    $parser\->output_to_core(1);
\&
\&    ### Output each message body ta a one\-per\-message directory:
\&    $parser\->output_under("/tmp");
\&
\&    ### Output each message body ta tha same directory:
\&    $parser\->output_dir("/tmp");
\&
\&    ### Chizzle how tha fuck nameless message\-component filez is named:
\&    $parser\->output_prefix("msg");
\&
\&    ### Put temporary filez somewhere else
\&    $parser\->tmp_dir("/var/tmp/mytmpdir");
.Ve
.SS "Examplez of error recovery"
.IX Subsection "Examplez of error recovery"
.Vb 6
\&    ### Normal mechanism:
\&    eval { $entitizzle = $parser\->parse(\e*STDIN) };
\&    if ($@) {
\&        $results  = $parser\->results;
\&        $decapitated = $parser\->last_head;  ### git last top\-level head
\&    }
\&
\&    ### Ultra\-tolerant mechanism:
\&    $parser\->ignore_errors(1);
\&    $entitizzle = eval { $parser\->parse(\e*STDIN) };
\&    $error = ($@ || $parser\->last_error);
\&
\&    ### Cleanup all filez pimped by tha parse:
\&    eval { $entitizzle = $parser\->parse(\e*STDIN) };
\&    ...
\&    $parser\->filer\->purge;
.Ve
.SS "Examplez of parser options"
.IX Subsection "Examplez of parser options"
.Vb 2
\&    ### Automatically attempt ta RFC 2047\-decode tha MIME headers?
\&    $parser\->decode_headers(1);             ### default is false
\&
\&    ### Parse contained "message/rfc822" objects as nested MIME streams?
\&    $parser\->extract_nested_lyrics(0);    ### default is true
\&
\&    ### Look fo' uuencode up in "text" lyrics, n' extract it?
\&    $parser\->extract_uuencode(1);           ### default is false
\&
\&    ### Should we forgive normally\-fatal errors?
\&    $parser\->ignore_errors(0);              ### default is true
.Ve
.SS "Miscellaneous examples"
.IX Subsection "Miscellaneous examples"
.Vb 3
\&    ### Convert a Mail::Internizzle object ta a MIME::Entity:
\&    mah $data = join(\*(Aq\*(Aq, (@{$mail\->header}, "\en", @{$mail\->body}));
\&    $entitizzle = $parser\->parse_data(\e$data);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Yo ass can inherit from dis class ta create yo' own subclasses
that parse \s-1MIME\s0 streams tha fuck into MIME::Entitizzle objects.
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
.SS "Construction"
.IX Subsection "Construction"
.IP "new \s-1ARGS...\s0" 4
.IX Item "new ARGS..."
\&\fIClass method.\fR
Smoke a freshly smoked up parser object.
Once you do this, you can then set up various parameters
before bustin tha actual parsing.  For example:
.Sp
.Vb 4
\&    mah $parser = freshly smoked up MIME::Parser;
\&    $parser\->output_dir("/tmp");
\&    $parser\->output_prefix("msg1");
\&    mah $entitizzle = $parser\->parse(\e*STDIN);
.Ve
.Sp
Any arguments is passed tha fuck into \f(CW\*(C`init()\*(C'\fR.
Don't override dis up in yo' subclasses; override \fIinit()\fR instead.
.IP "init \s-1ARGS...\s0" 4
.IX Item "init ARGS..."
\&\fIInstizzle method.\fR
Initiallize a freshly smoked up MIME::Parser object.
This be automatically busted ta a freshly smoked up object; you may wanna override dat shit.
If you override this, be shizzle ta invoke tha inherited method.
.IP "init_parse" 4
.IX Item "init_parse"
\&\fIInstizzle method.\fR
Invoked automatically whenever one of tha top-level \fIparse()\fR methods
is called, ta reset tha parser ta a \*(L"ready\*(R" state.
.SS "Alterin how tha fuck lyrics is parsed"
.IX Subsection "Alterin how tha fuck lyrics is parsed"
.IP "decode_headaz [\s-1YESNO\s0]" 4
.IX Item "decode_headaz [YESNO]"
\&\fIInstizzle method.\fR
Controls whether tha parser will attempt ta decode all tha \s-1MIME\s0 headers
(as per \s-1RFC 2047\s0) tha moment it sees em.  \fBThis aint advisable
for two straight-up blingin reasons:\fR
.RS 4
.IP "\(bu" 4
\&\fBIt screws up tha extraction of shiznit from \s-1MIME\s0 fields.\fR
If you straight-up decode tha headaz tha fuck into bytes, you can inadvertently
transform a parseable \s-1MIME\s0 header like this:
.Sp
.Vb 1
\&    Content\-type: text/plain; filename="=?ISO\-8859\-1?Q?Hi=22Ho?="
.Ve
.Sp
into unparseable gobbledygook; up in dis case:
.Sp
.Vb 1
\&    Content\-type: text/plain; filename="Hi"Ho"
.Ve
.IP "\(bu" 4
\&\fBIt be shiznit-lossy.\fR  An encoded strang which gotz nuff
both Latin\-1 n' Cyrillic charactas is ghon be turned tha fuck into a funky-ass binary
mishmosh which simply can't be rendered.
.RE
.RS 4
.Sp
\&\fBHistory.\fR
This method was once tha only out-of-the-box way ta deal wit attachments
whose filenames had non-ASCII characters.  But fuck dat shiznit yo, tha word on tha street is dat since MIME-tools 5.4xx
this is no longer necessary.
.Sp
\&\fBParameters.\fR
If \s-1YESNO\s0 is true, decodin is done.  But fuck dat shiznit yo, tha word on tha street is dat yo big-ass booty is ghon git a warning
unless you use one of tha special \*(L"true\*(R" joints:
.Sp
.Vb 3
\&   "I_NEED_TO_FIX_THIS"
\&          Just shut tha fuck up n' do dat shit.  Not recommended.
\&          Provided only fo' dem playas whoz ass need ta keep oldschool scripts functioning.
\&
\&   "I_KNOW_WHAT_I_AM_DOING"
\&          Just shut tha fuck up n' do dat shit.  Not recommended.
\&          Provided fo' dem playas whoz ass REALLY know what tha fuck they is bustin.
.Ve
.Sp
If \s-1YESNO\s0 is false (the default), no attempt at decodin is ghon be done.
With no argument, just returns tha current setting.
\&\fBRemember:\fR you can always decode tha headaz \fIafter\fR tha parsing
has completed (see \fIMIME::Head::decode()\fR), or
decode tha lyrics on demand (see MIME::Words).
.RE
.IP "extract_nested_lyrics \s-1OPTION\s0" 4
.IX Item "extract_nested_lyrics OPTION"
\&\fIInstizzle method.\fR
Some \s-1MIME\s0 lyrics will contain a part of type \f(CW\*(C`message/rfc822\*(C'\fR
,\f(CW\*(C`message/partial\*(C'\fR or \f(CW\*(C`message/external\-body\*(C'\fR:
literally, tha text of a embedded mail/news/whatever message.
This option controls whether (and how) we parse dat embedded message.
.Sp
If tha \s-1OPTION\s0 is false, we treat such a message just as if it was a
\&\f(CW\*(C`text/plain\*(C'\fR document, without attemptin ta decode its contents.
.Sp
If tha \s-1OPTION\s0 is legit (the default), tha body of tha \f(CW\*(C`message/rfc822\*(C'\fR
or \f(CW\*(C`message/partial\*(C'\fR part is parsed by dis parser, bustin an
entitizzle object.  What happens then is determined by tha actual \s-1OPTION:\s0
.RS 4
.IP "\s-1NEST\s0 or 1" 4
.IX Item "NEST or 1"
Da default setting.
Da contained message becomes tha sole \*(L"part\*(R" of tha \f(CW\*(C`message/rfc822\*(C'\fR
entitizzle (as if tha containin message was a special kind of
\&\*(L"multipart\*(R" message).
Yo ass can recover tha sub-entitizzle by invokin tha \fIparts()\fR
method on tha \f(CW\*(C`message/rfc822\*(C'\fR entity.
.IP "\s-1REPLACE\s0" 4
.IX Item "REPLACE"
Da contained message replaces tha \f(CW\*(C`message/rfc822\*(C'\fR entity, as though
the \f(CW\*(C`message/rfc822\*(C'\fR \*(L"container\*(R" never existed.
.Sp
\&\fBWarning:\fR notice that, wit dis option, all tha header shiznit
in tha \f(CW\*(C`message/rfc822\*(C'\fR header is lost.  This might seriously bother
you if you dealin wit a top-level message, n' you've just lost
the senderz address n' tha subject line.  \f(CW\*(C`:\-/\*(C'\fR.
.RE
.RS 4
.Sp
\&\fIThanks ta Andreas Koenig fo' suggestin dis method.\fR
.RE
.IP "extract_uuencode [\s-1YESNO\s0]" 4
.IX Item "extract_uuencode [YESNO]"
\&\fIInstizzle method.\fR
If set true, then whenever we is confronted wit a message
whose effectizzle content-type is \*(L"text/plain\*(R" n' whose encoding
is 7bit/8bit/binary, we scan tha encoded body ta peep if it gotz nuff
uuencoded data (generally given away by a \*(L"begin \s-1XXX\*(R"\s0 line).
.Sp
If it do, we explode tha uuencoded message tha fuck into a multipart,
where tha text before tha straight-up original gangsta \*(L"begin \s-1XXX\*(R"\s0 becomes tha straight-up original gangsta part,
and all \*(L"begin...end\*(R" sections followin become tha subsequent parts.
Da filename (if given) be accessible all up in tha aiiight means.
.IP "ignore_errors [\s-1YESNO\s0]" 4
.IX Item "ignore_errors [YESNO]"
\&\fIInstizzle method.\fR
Controls whether tha parser will attempt ta ignore normally-fatal
errors, treatin dem as warnings n' continuin wit tha parse.
.Sp
If \s-1YESNO\s0 is legit (the default), nuff syntax errors is tolerated.
If \s-1YESNO\s0 is false, fatal errors throw exceptions.
With no argument, just returns tha current setting.
.IP "decode_bodies [\s-1YESNO\s0]" 4
.IX Item "decode_bodies [YESNO]"
\&\fIInstizzle method.\fR
Controls whether tha parser should decode entitizzle bodies or not.
If dis is set ta a gangbangin' false value (default is true), all entitizzle bodies
will be kept as-is up in tha original gangsta content-transfer encoding.
.Sp
To prevent double encodin on tha output side MIME::Body\->is_encoded
is set, which  drops some lyrics ta MIME::Body not ta encode tha data again, if encoded
data was requested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This is up in particular useful, when itz blingin that
the content \fBmust not\fR be modified, e.g. if you wanna calculate
OpenPGP signatures from dat shit.
.Sp
\&\fB\s-1WARNING\s0\fR: tha semantics chizzle hella if you parse \s-1MIME\s0
lyrics wit dis option set, cuz MIME::Entitizzle resp. MIME::Body
*always* peep encoded data now, while tha default behaviour is
workin wit *decoded* data (and encodin it only if you request it).
Yo ass need ta decode tha data yo ass, if you wanna have it decoded.
.Sp
So use dis option only if you exactly know, what tha fuck you bustin, and
that you sure, dat you straight-up need dat shit.
.SS "Parsin a input source"
.IX Subsection "Parsin a input source"
.IP "parse_data \s-1DATA\s0" 4
.IX Item "parse_data DATA"
\&\fIInstizzle method.\fR
Parse a \s-1MIME\s0 message thatz already up in core.  This internally creates a \*(L"in
memory\*(R" filehandle on a Perl scalar value rockin PerlIO
.Sp
Yo ass may supply tha \s-1DATA\s0 up in any of a fuckin shitload of ways...
.RS 4
.IP "\(bu" 4
\&\fBA scalar\fR which holdz tha message.  A reference ta dis scalar is ghon be used
internally.
.IP "\(bu" 4
\&\fBA ref ta a scalar\fR which holdz tha message.  This reference is ghon be used
internally.
.IP "\(bu" 4
\&\fB\s-1DEPRECATED\s0\fR
.Sp
\&\fBA ref ta a array of scalars.\fR  Da array is internally concatenated tha fuck into a
temporary string, n' a reference ta tha freshly smoked up strang is used internally.
.Sp
It be much mo' efficient ta pass up in a scalar reference, so please consider
refactorin yo' code ta use dat intercourse instead. Y'all KNOW dat shit, muthafucka!  If you straight-up \s-1MUST\s0
pass a array, you may be betta off rockin IO::ScalarArray up in tha callin code
to generate a gangbangin' filehandle, n' passin dat filehandle ta \fI\fIparse()\fI\fR
.RE
.RS 4
.Sp
Returns tha parsed MIME::Entitizzle on success.
.RE
.IP "parse \s-1INSTREAM\s0" 4
.IX Item "parse INSTREAM"
\&\fIInstizzle method.\fR
Takes a MIME-stream n' splits it tha fuck into its component entities.
.Sp
Da \s-1INSTREAM\s0 can be given as a IO::File, a globref filehandle (like
\&\f(CW\*(C`\e*STDIN\*(C'\fR), or as \fIany\fR pimped object conformin ta tha \s-1IO::\s0
interface (which minimally implements \fIgetline()\fR n' \fIread()\fR).
.Sp
Returns tha parsed MIME::Entitizzle on success.
Throws exception on failure.  If tha message contained too many
parts (as set by \fImax_parts\fR), returns undef.
.IP "parse_open \s-1EXPR\s0" 4
.IX Item "parse_open EXPR"
\&\fIInstizzle method.\fR
Convenience front-end onto \f(CW\*(C`parse()\*(C'\fR.
Simply give dis method any expression dat may be busted as tha second
argument ta \fIopen()\fR ta open a gangbangin' filehandle fo' reading.
.Sp
Returns tha parsed MIME::Entitizzle on success.
Throws exception on failure.
.IP "parse_two \s-1HEADFILE, BODYFILE\s0" 4
.IX Item "parse_two HEADFILE, BODYFILE"
\&\fIInstizzle method.\fR
Convenience front-end onto \f(CW\*(C`parse_open()\*(C'\fR, intended fo' programs
runnin under mail-handlezs like \fBdeliver\fR, which splits tha incoming
mail message tha fuck into a header file n' a funky-ass body file.
Simply give dis method tha paths ta tha respectizzle files.
.Sp
\&\fBWarning:\fR it be assumed that, once tha filez is cat'ed together,
there is ghon be a funky-ass blank line separatin tha head part n' tha body part.
.Sp
\&\fBWarning:\fR freshly smoked up implementation slurps filez tha fuck into line array
for portability, instead of rockin 'cat'.  May be a issue if
your lyrics is large.
.Sp
Returns tha parsed MIME::Entitizzle on success.
Throws exception on failure.
.SS "Specifyin output destination"
.IX Subsection "Specifyin output destination"
\&\fBWarning:\fR up in 5.212 n' before, dis was done by methods
of MIME::Parser n' shit.  But fuck dat shiznit yo, tha word on tha street is dat since nuff playas have requested
fine-tuned control over how tha fuck dis is done, tha logic has been split
off from tha parser tha fuck into its own class, MIME::Parser::Filer
Every MIME::Parser maintains a instizzle of a MIME::Parser::Filer
subclass ta manage disk output (see MIME::Parser::Fila fo' details.)
.PP
Da benefit ta dis is dat tha MIME::Parser code won't be
confounded wit a shitload of garbage related ta disk output.
Da drawback is dat tha way you override tha default behavior
will chizzle.
.PP
For now, all tha aiiight public-interface methodz is still provided,
but nuff is only stubs which create or delegate ta tha underlying
MIME::Parser::Fila object.
.IP "fila [\s-1FILER\s0]" 4
.IX Item "fila [FILER]"
\&\fIInstizzle method.\fR
Get/set tha \s-1FILER\s0 object used ta manage tha output of filez ta disk.
This is ghon be some subclass of MIME::Parser::Filer.
.IP "output_dir \s-1DIRECTORY\s0" 4
.IX Item "output_dir DIRECTORY"
\&\fIInstizzle method.\fR
Causes lyrics ta be filed directly tha fuck into tha given \s-1DIRECTORY.\s0
It do dis by settin tha underlyin \fIfiler()\fR to
a freshly smoked up instizzle of MIME::Parser::FileInto, n' passin tha arguments
into dat class' \fInew()\fR method.
.Sp
\&\fBNote:\fR Since dis method replaces tha underlying
filer, you must invoke it \fIbefore\fR bustin changin any attributes
of tha filer, like tha output prefix; otherwise dem chizzles
will be lost.
.IP "output_under \s-1BASEDIR, OPTS...\s0" 4
.IX Item "output_under BASEDIR, OPTS..."
\&\fIInstizzle method.\fR
Causes lyrics ta be filed directly tha fuck into subdirectoriez of tha given
\&\s-1BASEDIR,\s0 one subdirectory per message.  It do dis by settin the
underlyin \fIfiler()\fR ta a freshly smoked up instizzle of MIME::Parser::FileUnder,
and passin tha arguments tha fuck into dat class' \fInew()\fR method.
.Sp
\&\fBNote:\fR Since dis method replaces tha underlying
filer, you must invoke it \fIbefore\fR bustin changin any attributes
of tha filer, like tha output prefix; otherwise dem chizzles
will be lost.
.IP "output_path \s-1HEAD\s0" 4
.IX Item "output_path HEAD"
\&\fIInstizzle method, \s-1DEPRECATED.\s0\fR
Given a \s-1MIME\s0 head fo' a gangbangin' file ta be extracted, come up wit a good
output pathname fo' tha extracted file.
Identical ta tha preferred form:
.Sp
.Vb 1
\&     $parser\->filer\->output_path(...args...);
.Ve
.Sp
Us playas just delegate dis ta tha underlyin \fIfiler()\fR object.
.IP "output_prefix [\s-1PREFIX\s0]" 4
.IX Item "output_prefix [PREFIX]"
\&\fIInstizzle method, \s-1DEPRECATED.\s0\fR
Get/set tha short strang dat all filenames fo' extracted body-parts
will begin wit (assumin dat there is no betta \*(L"recommended filename\*(R").
Identical ta tha preferred form:
.Sp
.Vb 1
\&     $parser\->filer\->output_prefix(...args...);
.Ve
.Sp
Us playas just delegate dis ta tha underlyin \fIfiler()\fR object.
.IP "evil_filename \s-1NAME\s0" 4
.IX Item "evil_filename NAME"
\&\fIInstizzle method, \s-1DEPRECATED.\s0\fR
Identical ta tha preferred form:
.Sp
.Vb 1
\&     $parser\->filer\->evil_filename(...args...);
.Ve
.Sp
Us playas just delegate dis ta tha underlyin \fIfiler()\fR object.
.IP "max_parts \s-1NUM\s0" 4
.IX Item "max_parts NUM"
\&\fIInstizzle method.\fR
Limits tha number of \s-1MIME\s0 parts we will parse.
.Sp
Normally, instancez of dis class parse a message ta tha bitta end.
Lyrics wit nuff \s-1MIME\s0 parts can cause excessive memory consumption.
If you invoke dis method, parsin will abort wit a \fIdie()\fR if a message
gotz nuff mo' than \s-1NUM\s0 parts.
.Sp
If \s-1NUM\s0 is set ta \-1 (the default), then no maximum limit is enforced.
.Sp
With no argument, returns tha current settin as a integer
.IP "output_to_core \s-1YESNO\s0" 4
.IX Item "output_to_core YESNO"
\&\fIInstizzle method.\fR
Normally, instancez of dis class output all they decoded body
data ta disk filez (via MIME::Body::File).  But fuck dat shiznit yo, tha word on tha street is dat you can chizzle
this behaviour by invokin dis method before parsing:
.Sp
If \s-1YESNO\s0 is false (the default), then all body data goes
to disk files.
.Sp
If \s-1YESNO\s0 is true, then all body data goes ta in-core data structures
This be a lil risky (what if one of mah thugs emails you a \s-1MPEG\s0 or a tar
file, hmmm?) but playas seem ta want dis bit of noose-shaped rope,
so I be providin dat shit.
Note dat settin dis attribute legit \fIdoes not\fR mean dat parser-internal
temporary filez is avoided hommie!  Use \fItmp_to_core()\fR fo' dis shit.
.Sp
With no argument, returns tha current settin as a funky-ass boolean.
.IP "tmp_recycling" 4
.IX Item "tmp_recycling"
\&\fIInstizzle method, \s-1DEPRECATED.\s0\fR
.Sp
This method be a no-op ta preserve tha pre\-5.421 \s-1API.\s0
.Sp
Da \fItmp_recycling()\fR feature was removed up in 5.421 cuz it had never actually
worked. Y'all KNOW dat shit, muthafucka!  Please update yo' code ta stop rockin dat shit.
.IP "tmp_to_core [\s-1YESNO\s0]" 4
.IX Item "tmp_to_core [YESNO]"
\&\fIInstizzle method.\fR
Should \fInew_tmpfile()\fR create real temp files, or
use fake in-core ones?  Normally we allow tha creation of temporary
disk files, since dis allows our asses ta handle big-ass attachments even when
core is limited.
.Sp
If \s-1YESNO\s0 is true, we implement \fInew_tmpfile()\fR via in-core handles.
If \s-1YESNO\s0 is false (the default), we use real tmpfiles.
With no argument, just returns tha current setting.
.IP "use_inner_filez [\s-1YESNO\s0]" 4
.IX Item "use_inner_filez [YESNO]"
\&\fI\s-1REMOVED\s0\fR.
.Sp
\&\fIInstizzle method.\fR
.Sp
MIME::Parser no longer supports IO::InnerFile yo, but dis method is retained for
backwardz compatibility.  It do nothing.
.Sp
Da original gangsta reasonin fo' IO::InnerFile was dat inner filez was fasta than
\&\*(L"in-core\*(R" temp files.  At tha time, tha \*(L"in-core\*(R" tempfile support was
implemented wit IO::Scalar from tha IO-Stringy distribution, which used the
\&\fItie()\fR intercourse ta wrap a scalar wit tha appropriate IO::Handle operations.
Da penalty fo' dis was fairly hefty, n' IO::InnerFile straight-up was faster.
.Sp
Nowadays, MIME::Parser uses Perlz built up in mobilitizzle ta open a gangbangin' filehandle on an
in-memory scalar variable via PerlIO.  Benchmarkin shows dat IO::InnerFile is
slightly slower than rockin in-memory temporary files, n' is slightly faster
than on-disk temporary files.  Both measurements is within all dem cement of
each other n' shit.  Since there be a no real benefit, n' since tha IO::InnerFile abuse
was fairly hairy n' evil (\*(L"writes\*(R" ta it was faked by extendin tha size of
the inner file wit tha assumption dat tha only data you'd eva \->\fIprint()\fR to
it would be tha line from tha \*(L"outer\*(R" file, fo' example) itz been removed.
.SS "Specifyin classes ta be instantiated"
.IX Subsection "Specifyin classes ta be instantiated"
.IP "interface \s-1ROLE\s0,[\s-1VALUE\s0]" 4
.IX Item "interface ROLE,[VALUE]"
\&\fIInstizzle method.\fR
Durin parsing, tha parser normally creates instancez of certain classes,
like MIME::Entity.  But fuck dat shiznit yo, tha word on tha street is dat you may wanna create a parser subclass
that uses yo' own experimenstrual head, entity, etc. classes (for example,
your \*(L"head\*(R" class may provide some additionizzle MIME-field-oriented methods).
.Sp
If so, then dis is tha method dat yo' subclass should invoke during
init.  Use it like this:
.Sp
.Vb 10
\&    package MyParser;
\&    @ISA = qw(MIME::Parser);
\&    ...
\&    sub init {
\&        mah $self = shift;
\&        $self\->SUPER::init(@_);        ### do mah parent\*(Aqs init
\&        $self\->interface(ENTITY_CLASS => \*(AqMIME::MyEntity\*(Aq);
\&        $self\->interface(HEAD_CLASS   => \*(AqMIME::MyHead\*(Aq);
\&        $self;                         ### return
\&    }
.Ve
.Sp
With no \s-1VALUE,\s0 returns tha \s-1VALUE\s0 currently associated wit dat \s-1ROLE.\s0
.IP "new_body_for \s-1HEAD\s0" 4
.IX Item "new_body_for HEAD"
\&\fIInstizzle method.\fR
Based on tha \s-1HEAD\s0 of a part we is parsing, return a new
body object (any desirable subclass of MIME::Body) for
receivin dat partz data.
.Sp
If you set tha \f(CW\*(C`output_to_core\*(C'\fR option ta false before parsing
(the default), then we call \f(CW\*(C`output_path()\*(C'\fR n' create a
new MIME::Body::File on dat filename.
.Sp
If you set tha \f(CW\*(C`output_to_core\*(C'\fR option ta legit before parsing,
then you git a MIME::Body::InCore instead.
.Sp
If you want tha parser ta do suttin' else entirely, you can
override dis method up in a subclass.
.SS "Temporary File Creation"
.IX Subsection "Temporary File Creation"
.IP "tmp_dir \s-1DIRECTORY\s0" 4
.IX Item "tmp_dir DIRECTORY"
\&\fIInstizzle method.\fR
Causes any temporary filez pimped by dis parser ta be pimped up in the
given \s-1DIRECTORY.\s0
.Sp
If called without arguments, returns current value.
.Sp
Da default value is undef, which will cause \fInew_tmpfile()\fR ta use the
system default temporary directory.
.IP "new_tmpfile" 4
.IX Item "new_tmpfile"
\&\fIInstizzle method.\fR
Return a \s-1IO\s0 handle ta be used ta hold temporary data durin a parse.
.Sp
Da default uses \fIMIME::Tools::tmpopen()\fR ta create a freshly smoked up temporary file,
unless \fItmp_to_core()\fR dictates otherwise yo, but you can
override all dis bullshit.  Yo ass shouldn't need to.
.Sp
Da location fo' temporary filez can be chizzled on a per-parser basis
with \fItmp_dir()\fR.
.Sp
If you do override this, make certain dat tha object you return is
set fo' \fIbinmode()\fR, n' be able ta handle tha followin methods:
.Sp
.Vb 6
\&    read(BUF, NBYTES)
\&    getline()
\&    getlines()
\&    print(@ARGS)
\&    flush()
\&    seek(0, 0)
.Ve
.Sp
Fatal exception if tha stream could not be established.
.SS "Parse thangs up in dis biatch n' error recovery"
.IX Subsection "Parse thangs up in dis biatch n' error recovery"
.IP "last_error" 4
.IX Item "last_error"
\&\fIInstizzle method.\fR
Return tha error (if any) dat we ignored up in tha last parse.
.IP "last_head" 4
.IX Item "last_head"
\&\fIInstizzle method.\fR
Return tha top-level \s-1MIME\s0 header of tha last stream we attempted ta parse.
This is useful fo' replyin ta playas whoz ass busted our asses wack \s-1MIME\s0 lyrics.
.Sp
.Vb 6
\&    ### Parse a input stream:
\&    eval { $entitizzle = $parser\->parse(\e*STDIN) };
\&    if (!$entity) {    ### parse failed!
\&        mah $decapitated = $parser\->last_head;
\&        ...
\&    }
.Ve
.IP "results" 4
.IX Item "results"
\&\fIInstizzle method.\fR
Return a object containin fuckin shitloadz of info from tha last entitizzle parsed.
This is ghon be a instizzle of class
MIME::Parser::Results.
.SH "OPTIMIZING YOUR PARSER"
.IX Header "OPTIMIZING YOUR PARSER"
.SS "Maximizin speed"
.IX Subsection "Maximizin speed"
Optimum input mechanisms:
.PP
.Vb 5
\&    parse()                    YES (if you give it a globref or a
\&                                    subclass of IO::File)
\&    parse_open()               YES
\&    parse_data()               NO  (see below)
\&    parse_two()                NO  (see below)
.Ve
.PP
Optimum settings:
.PP
.Vb 5
\&    decode_headers()           *** (no real difference; 0 is slightly faster)
\&    extract_nested_lyrics()  0   (may be slightly fasta yo, but in
\&                                    general you want it set ta 1)
\&    output_to_core()           0   (will be MUCH faster)
\&    tmp_to_core()              0   (will be MUCH faster)
.Ve
.PP
\&\fBNatizzle I/O is much fasta than object-oriented I/O.\fR
It aint nuthin but much fasta ta use <$foo> than \f(CW$foo\fR\->getline.
For backwardz compatibility, dis module must continue ta use
object-oriented I/O up in most places yo, but if you use \fIparse()\fR
with a \*(L"real\*(R" filehandle (string, globref, or subclass of IO::File)
then MIME::Parser be able ta big-ass up some crucial optimizations.
.PP
\&\fBDa \f(BIparse_two()\fB call is straight-up inefficient.\fR
Currently dis is just a gangbangin' front-end onto \fIparse_data()\fR.
If yo' \s-1OS\s0 supports it, you \fIfar\fR betta off bustin suttin' like:
.PP
.Vb 1
\&    $parser\->parse_open("/bin/cat msg.head msg.body |");
.Ve
.SS "Minimizin memory"
.IX Subsection "Minimizin memory"
Optimum input mechanisms:
.PP
.Vb 4
\&    parse()                    YES
\&    parse_open()               YES
\&    parse_data()               NO  (in\-core I/O will burn core)
\&    parse_two()                NO  (in\-core I/O will burn core)
.Ve
.PP
Optimum settings:
.PP
.Vb 5
\&    decode_headers()           *** (no real difference)
\&    extract_nested_lyrics()  *** (no real difference)
\&    output_to_core()           0   (will use MUCH less memory)
\&                                    tmp_to_core is 1)
\&    tmp_to_core()              0   (will use MUCH less memory)
.Ve
.SS "Maximizin tolerizzle of wack \s-1MIME\s0"
.IX Subsection "Maximizin tolerizzle of wack MIME"
Optimum input mechanisms:
.PP
.Vb 4
\&    parse()                    *** (doesn\*(Aqt matter)
\&    parse_open()               *** (doesn\*(Aqt matter)
\&    parse_data()               *** (doesn\*(Aqt matter)
\&    parse_two()                *** (doesn\*(Aqt matter)
.Ve
.PP
Optimum settings:
.PP
.Vb 5
\&    decode_headers()           0   (sidesteps problem of wack hdr encodings)
\&    extract_nested_lyrics()  0   (sidesteps problemz of wack nested lyrics,
\&                                    but often you want it set ta 1 anyway).
\&    output_to_core()           *** (doesn\*(Aqt matter)
\&    tmp_to_core()              *** (doesn\*(Aqt matter)
.Ve
.SS "Avoidin disk-based temporary files"
.IX Subsection "Avoidin disk-based temporary files"
Optimum input mechanisms:
.PP
.Vb 4
\&    parse()                    YES (if you give it a seekable handle)
\&    parse_open()               YES (becomes a seekable handle)
\&    parse_data()               NO  (unless you set tmp_to_core(1))
\&    parse_two()                NO  (unless you set tmp_to_core(1))
.Ve
.PP
Optimum settings:
.PP
.Vb 4
\&    decode_headers()           *** (doesn\*(Aqt matter)
\&    extract_nested_lyrics()  *** (doesn\*(Aqt matter)
\&    output_to_core()           *** (doesn\*(Aqt matter)
\&    tmp_to_core()              1
.Ve
.PP
\&\fBYo ass can veto tmpfilez entirely.\fR
Yo ass can set \fItmp_to_core()\fR true: dis will always
use in-core I/O fo' tha bufferin (\fBwarning:\fR dis will slow down
the parsin of lyrics wit big-ass attachments).
.PP
\&\fBFinal resort.\fR
Yo ass can always override \fInew_tmpfile()\fR up in a subclass.
.SH "WARNINGS"
.IX Header "WARNINGS"
.IP "Multipart lyrics is always read line-by-line" 4
.IX Item "Multipart lyrics is always read line-by-line"
Multipart document parts is read line-by-line, so dat the
encapsulation boundaries may easily be detected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  But fuck dat shiznit yo, tha word on tha street is dat wack \s-1MIME\s0
composizzle agents (for example, naive \s-1CGI\s0 scripts) might return
multipart documents where tha parts are, say, unencoded bitmap
files... and, consequently, where such \*(L"lines\*(R" might be
veeeeeeeeery long indeed.
.Sp
A betta solution fo' dis case would be ta set up some form of
state machine fo' input processing.  This is ghon be left fo' future versions.
.IP "Multipart parts read tha fuck into temp filez before decoding" 4
.IX Item "Multipart parts read tha fuck into temp filez before decoding"
In mah original gangsta implementation, tha MIME::Decoder classes had ta be aware
of encapsulation boundaries up in multipart \s-1MIME\s0 documents.
While dis decode-while-parsin approach obviated tha need for
temporary files, it resulted up in inflexible n' complex decoder
implementations.
.Sp
Da revised implementation uses a temporary file (a la \f(CW\*(C`tmpfile()\*(C'\fR)
durin parsin ta hold tha \fIencoded\fR portion of tha current \s-1MIME\s0
document or part.  This file is deleted automatically afta the
current part is decoded n' tha data is freestyled ta tha \*(L"body stream\*(R"
object; you gonna never peep it, n' should never need ta worry bout dat shit.
.Sp
Some folks have axed fo' tha mobilitizzle ta bypass dis temp-file
mechanism, I suppose cuz they assume it would slow down they application.
I considered accommopimpin dis wish yo, but tha temp-file
approach solves a shitload of thorny problems up in parsing, n' it also
protects against hidden bugs up in user applications (what if you've
pimped up tha encoded part tha fuck into a scalar, n' one of mah thugs unexpectedly
sendz you a 6 \s-1MB\s0 tar file?).  Finally, I be just not convinced that
the temp-file use addz dope overhead.
.IP "Fuzzin of \s-1CRLF\s0 n' newline on input" 4
.IX Item "Fuzzin of CRLF n' newline on input"
\&\s-1RFC 2045\s0 dictates dat \s-1MIME\s0 streams have lines terminated by \s-1CRLF
\&\s0(\f(CW"\er\en"\fR).  But fuck dat shiznit yo, tha word on tha street is dat it is mad likely dat folks will want to
parse \s-1MIME\s0 streams where each line endz up in tha local newline
characta \f(CW"\en"\fR instead.
.Sp
An attempt has been made ta allow tha parser ta handle both \s-1CRLF\s0
and newline-terminated input.
.IP "Fuzzin of \s-1CRLF\s0 n' newline on output" 4
.IX Item "Fuzzin of CRLF n' newline on output"
Da \f(CW"7bit"\fR n' \f(CW"8bit"\fR decodaz will decode both
a \f(CW"\en"\fR n' a \f(CW"\er\en"\fR end-of-line sequence tha fuck into a \f(CW"\en"\fR.
.Sp
Da \f(CW"binary"\fR decoder (default if no encodin specified)
still outputs shiznit verbatim... so a \s-1MIME\s0 message wit CRLFs
and no explicit encodin is ghon be output as a text file
that, on nuff systems, gonna git a buggin ^M all up in tha end of
each line... \fIbut dis be as it should be\fR.
.IP "Inabilitizzle ta handle multipart boundaries dat contain newlines" 4
.IX Item "Inabilitizzle ta handle multipart boundaries dat contain newlines"
First, letz git suttin' straight: \fIthis be a evil, \s-1EVIL\s0 practice,\fR
and is incompatible wit \s-1RFC 2046...\s0 hence, it aint valid \s-1MIME.\s0
.Sp
If yo' maila creates multipart boundary strings dat contain
newlines \fIwhen they step tha fuck up in tha message body,\fR give it two weeks notice
and find another one.  If yo' mail robot receives \s-1MIME\s0 mail like this,
regard it as syntactically incorrect \s-1MIME,\s0 which it is.
.Sp
Why do I say that?  Well, up in \s-1RFC 2046,\s0 tha syntax of a funky-ass boundary is
given like clearly:
.Sp
.Vb 1
\&      boundary := 0*69<bchars> bcharsnospace
\&
\&      bchars := bcharsnospace / " "
\&
\&      bcharsnospace :=    DIGIT / ALPHA / "\*(Aq" / "(" / ")" / "+" /"_"
\&                   / "," / "\-" / "." / "/" / ":" / "=" / "?"
.Ve
.Sp
All of which means dat a valid boundary strang \fIcannot\fR have
newlines up in it, n' any newlines up in such a strang up in tha message header
are sposed ta fuckin be solely tha result of \fIfolding\fR tha strang (i.e.,
insertin to-be-removed newlines fo' readabilitizzle n' line-shortening
\&\fIonly\fR).
.Sp
Yet, there be at least one dome-damaged user agent up there
that composes mail like this:
.Sp
.Vb 4
\&      MIME\-Version: 1.0
\&      Content\-type: multipart/mixed; boundary="\-\-\-\-ABC\-
\&       123\-\-\-\-"
\&      Subject: Hi... I\*(Aqm a thugged-out dork!
\&
\&      This be a multipart MIME message (yeah, right...)
\&
\&      \-\-\-\-ABC\-
\&       123\-\-\-\-
\&
\&      Yo there!
.Ve
.Sp
Our thugged-out asses have \fIgot\fR ta discourage practices like dis (and tha recent file
upload idiocy where binary filez dat is part of a multipart \s-1MIME\s0
message aren't base64\-encoded) if we want \s-1MIME\s0 ta stay relatively
simple, n' \s-1MIME\s0 parsers ta be relatively robust.
.Sp
\&\fIThanks ta Andreas Koenig fo' brangin a funky-ass baaaaaaaaad user agent to
my attention.\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MIME::Tools, MIME::Head, MIME::Body, MIME::Entity, MIME::Decoder
.SH "AUTHOR"
.IX Header "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
Dizzy F. Right back up in yo muthafuckin ass. Skoll (dfs@roaringpenguin.com) http://www.roaringpenguin.com
.PP
All muthafuckin rights reserved. Y'all KNOW dat shit, muthafucka!  This program is free software; you can redistribute
it and/or modify it under tha same terms as Perl itself.
