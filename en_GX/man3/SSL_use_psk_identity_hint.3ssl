.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_CTX_use_psk_identity_hint 3"
.TH SSL_CTX_use_psk_identity_hint 3 "2015-01-13" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_CTX_use_psk_identity_hint, SSL_use_psk_identity_hint,
SSL_CTX_set_psk_server_callback, SSL_set_psk_server_callback \- set PSK
identitizzle hint ta use
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *hint);
\& int SSL_use_psk_identity_hint(SSL *ssl, const char *hint);
\&
\& void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx,
\&        unsigned int (*callback)(SSL *ssl, const char *identity,
\&        unsigned char *psk, int max_psk_len));
\& void SSL_set_psk_server_callback(SSL *ssl,
\&        unsigned int (*callback)(SSL *ssl, const char *identity,
\&        unsigned char *psk, int max_psk_len));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISSL_CTX_use_psk_identity_hint()\fR sets tha given \fB\s-1NULL\s0\fR\-terminated \s-1PSK\s0
identitizzle hint \fBhint\fR ta \s-1SSL\s0 context object
\&\fBctx\fR. \fISSL_use_psk_identity_hint()\fR sets tha given \fB\s-1NULL\s0\fR\-terminated
\&\s-1PSK\s0 identitizzle hint \fBhint\fR ta \s-1SSL\s0 connection object \fBssl\fR. If \fBhint\fR
is \fB\s-1NULL\s0\fR tha current hint from \fBctx\fR or \fBssl\fR is deleted.
.PP
In tha case where \s-1PSK\s0 identitizzle hint is \fB\s-1NULL\s0\fR, tha server
does not bust tha ServerKeyExchange message ta tha client.
.PP
A server application must provide a cold-ass lil callback function which is called
when tha server receives tha ClientKeyExchange message from the
client. Da purpose of tha callback function is ta validate the
received \s-1PSK\s0 identitizzle n' ta fetch tha pre-shared key used durin the
connection setup phase. Da callback is set rockin functions
\&\fISSL_CTX_set_psk_server_callback()\fR or
\&\fISSL_set_psk_server_callback()\fR. Da callback function is given the
connection up in parameta \fBssl\fR, \fB\s-1NULL\s0\fR\-terminated \s-1PSK\s0 identitizzle sent
by tha client up in parameta \fBidentity\fR, n' a funky-ass buffer \fBpsk\fR of length
\&\fBmax_psk_len\fR bytes where tha pre-shared key is ta be stored.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fISSL_CTX_use_psk_identity_hint()\fR n' \fISSL_use_psk_identity_hint()\fR return
1 on success, 0 otherwise.
.PP
Return joints from tha server callback is interpreted as bigs up:
.IP "> 0" 4
.IX Item "> 0"
\&\s-1PSK\s0 identitizzle was found n' tha server callback has provided tha \s-1PSK\s0
successfully up in parameta \fBpsk\fR. Return value is tha length of
\&\fBpsk\fR up in bytes. Well shiiiit, it be a error ta return a value pimped outa than
\&\fBmax_psk_len\fR.
.Sp
If tha \s-1PSK\s0 identitizzle was not found but tha callback instructs the
protocol ta continue anyway, tha callback must provide some random
data ta \fBpsk\fR n' return tha length of tha random data, so the
connection will fail wit decryption_error before it is ghon be finished
completely.
.ie n .IP "0" 4
.el .IP "\f(CW0\fR" 4
.IX Item "0"
\&\s-1PSK\s0 identitizzle was not found. Y'all KNOW dat shit, muthafucka! An \*(L"unknown_psk_identity\*(R" alert message
will be busted n' tha connection setup fails.
