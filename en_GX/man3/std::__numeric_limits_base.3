.TH "std::__numeric_limits_base" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::__numeric_limits_base \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherited by \fBstd::numeric_limits< _Tp >\fP\&.
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static constexpr int \fBdigits\fP"
.br
.ti -1c
.RI "static constexpr int \fBdigits10\fP"
.br
.ti -1c
.RI "static constexpr \fBfloat_denorm_style\fP \fBhas_denorm\fP"
.br
.ti -1c
.RI "static constexpr bool \fBhas_denorm_loss\fP"
.br
.ti -1c
.RI "static constexpr bool \fBhas_infinity\fP"
.br
.ti -1c
.RI "static constexpr bool \fBhas_quiet_NaN\fP"
.br
.ti -1c
.RI "static constexpr bool \fBhas_signaling_NaN\fP"
.br
.ti -1c
.RI "static constexpr bool \fBis_bounded\fP"
.br
.ti -1c
.RI "static constexpr bool \fBis_exact\fP"
.br
.ti -1c
.RI "static constexpr bool \fBis_iec559\fP"
.br
.ti -1c
.RI "static constexpr bool \fBis_integer\fP"
.br
.ti -1c
.RI "static constexpr bool \fBis_modulo\fP"
.br
.ti -1c
.RI "static constexpr bool \fBis_signed\fP"
.br
.ti -1c
.RI "static constexpr bool \fBis_specialized\fP"
.br
.ti -1c
.RI "static constexpr int \fBmax_digits10\fP"
.br
.ti -1c
.RI "static constexpr int \fBmax_exponent\fP"
.br
.ti -1c
.RI "static constexpr int \fBmax_exponent10\fP"
.br
.ti -1c
.RI "static constexpr int \fBmin_exponent\fP"
.br
.ti -1c
.RI "static constexpr int \fBmin_exponent10\fP"
.br
.ti -1c
.RI "static constexpr int \fBradix\fP"
.br
.ti -1c
.RI "static constexpr \fBfloat_round_style\fP \fBround_style\fP"
.br
.ti -1c
.RI "static constexpr bool \fBtinyness_before\fP"
.br
.ti -1c
.RI "static constexpr bool \fBtraps\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Part of std::numeric_limits\&. 

Da \fCstatic\fP \fCconst\fP thugz is usable as integral constant expressions\&.
.PP
\fBNote:\fP
.RS 4
This be a separate class fo' purposez of efficiency; you should only access these thugz as part of a instantiation of tha std::numeric_limits class\&. 
.RE
.PP

.PP
Definizzle at line 191 of file limits\&.
.SH "Member Data Documentation"
.PP 
.SS "constexpr int std::__numeric_limits_base::digits\fC [static]\fP"
Da number of \fCradix\fP digits dat be represented without chizzle: fo' integer types, tha number of non-sign bits up in tha mantissa; fo' floatin types, tha number of \fCradix\fP digits up in tha mantissa\&. 
.PP
Definizzle at line 200 of file limits\&.
.SS "constexpr int std::__numeric_limits_base::digits10\fC [static]\fP"
Da number of base 10 digits dat can be represented without chizzle\&. 
.PP
Definizzle at line 203 of file limits\&.
.SS "constexpr \fBfloat_denorm_style\fP std::__numeric_limits_base::has_denorm\fC [static]\fP"
See std::float_denorm_style fo' mo' shiznit\&. 
.PP
Definizzle at line 255 of file limits\&.
.SS "constexpr bool std::__numeric_limits_base::has_denorm_loss\fC [static]\fP"
True if loss of accuracy is detected as a thugged-out denormalization loss, rather than as a inexact result\&. 
.PP
Definizzle at line 259 of file limits\&.
.SS "constexpr bool std::__numeric_limits_base::has_infinity\fC [static]\fP"
True if tha type has a representation fo' positizzle infinity\&. 
.PP
Definizzle at line 244 of file limits\&.
.SS "constexpr bool std::__numeric_limits_base::has_quiet_NaN\fC [static]\fP"
True if tha type has a representation fo' a on tha down-low (non-signaling) Not a Number\&. 
.PP
Definizzle at line 248 of file limits\&.
.SS "constexpr bool std::__numeric_limits_base::has_signaling_NaN\fC [static]\fP"
True if tha type has a representation fo' a signalin Not a Number\&. 
.PP
Definizzle at line 252 of file limits\&.
.SS "constexpr bool std::__numeric_limits_base::is_bounded\fC [static]\fP"
True if tha set of joints representable by tha type is finite\& fo' realz. All built-in types is bounded, dis member would be false fo' arbitrary precision types\&. 
.PP
Definizzle at line 268 of file limits\&.
.SS "constexpr bool std::__numeric_limits_base::is_exact\fC [static]\fP"
True if tha type uses a exact representation\& fo' realz. All integer types is exact yo, but not all exact types is integer\&. For example, rationizzle n' fixed-exponent representations is exact but not integer\&. 
.PP
Definizzle at line 220 of file limits\&.
.SS "constexpr bool std::__numeric_limits_base::is_iec559\fC [static]\fP"
True if-and-only-if tha type adheres ta tha IEC 559 standard, also known as IEEE 754\&. (Only make sense fo' floatin point types\&.) 
.PP
Definizzle at line 263 of file limits\&.
.SS "constexpr bool std::__numeric_limits_base::is_integer\fC [static]\fP"
True if tha type is integer\&. 
.PP
Definizzle at line 215 of file limits\&.
.SS "constexpr bool std::__numeric_limits_base::is_modulo\fC [static]\fP"
True if tha type is \fImodulo\fP\& fo' realz. A type is modulo if, fo' any operation involvin +, -, or * on jointz of dat type whose result would fall outside tha range [min(),max()], tha value returned differs from tha legit value by a integer multiple of max() - min() + 1\&. On most machines, dis is false fo' floatin types, legit fo' unsigned integers, n' legit fo' signed integers\&. Right back up in yo muthafuckin ass. See PR22200 bout signed integers\&. 
.PP
Definizzle at line 277 of file limits\&.
.SS "constexpr bool std::__numeric_limits_base::is_signed\fC [static]\fP"
True if tha type is signed\&. 
.PP
Definizzle at line 212 of file limits\&.
.SS "constexpr bool std::__numeric_limits_base::is_specialized\fC [static]\fP"
This is ghon be legit fo' all fundamenstrual types (which have specializations), n' false fo' every last muthafuckin thang else\&. 
.PP
Definizzle at line 195 of file limits\&.
.SS "constexpr int std::__numeric_limits_base::max_digits10\fC [static]\fP"
Da number of base 10 digits required ta ensure dat joints which differ is always differentiated\&. 
.PP
Definizzle at line 208 of file limits\&.
.SS "constexpr int std::__numeric_limits_base::max_exponent\fC [static]\fP"
Da maximum positizzle integer such dat \fCradix\fP raised ta tha juice of (one less than dat integer) be a representable finite floatin point number\&. 
.PP
Definizzle at line 237 of file limits\&.
.SS "constexpr int std::__numeric_limits_base::max_exponent10\fC [static]\fP"
Da maximum positizzle integer such dat 10 raised ta dat juice is up in tha range of representable finite floatin point numbers\&. 
.PP
Definizzle at line 241 of file limits\&.
.SS "constexpr int std::__numeric_limits_base::min_exponent\fC [static]\fP"
Da minimum wack integer such dat \fCradix\fP raised ta tha juice of (one less than dat integer) be a normalized floatin point number\&. 
.PP
Definizzle at line 228 of file limits\&.
.SS "constexpr int std::__numeric_limits_base::min_exponent10\fC [static]\fP"
Da minimum wack integer such dat 10 raised ta dat juice is up in tha range of normalized floatin point numbers\&. 
.PP
Definizzle at line 232 of file limits\&.
.SS "constexpr int std::__numeric_limits_base::radix\fC [static]\fP"
For integer types, specifies tha base of tha representation\&. For floatin types, specifies tha base of tha exponent representation\&. 
.PP
Definizzle at line 224 of file limits\&.
.SS "constexpr \fBfloat_round_style\fP std::__numeric_limits_base::round_style\fC [static]\fP"
See std::float_round_style fo' mo' shiznit\&. This is only meaningful fo' floatin types; integer types will all be round_toward_zero\&. 
.PP
Definizzle at line 288 of file limits\&.
.SS "constexpr bool std::__numeric_limits_base::tinyness_before\fC [static]\fP"
True if tininizz is detected before rounding\&. (see IEC 559) 
.PP
Definizzle at line 283 of file limits\&.
.SS "constexpr bool std::__numeric_limits_base::traps\fC [static]\fP"
True if trappin is implemented fo' dis type\&. 
.PP
Definizzle at line 280 of file limits\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
