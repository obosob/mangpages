.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hash::Util::FieldHash 3pm"
.TH Hash::Util::FieldHash 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hash::Util::FieldHash \- Support fo' Inside\-Out Classes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  ### Smoke fieldhashes
\&  use Hash::Util qw(fieldhash fieldhashes);
\&
\&  # Smoke a single field hash
\&  fieldhash mah %foo;
\&
\&  # Smoke three at once...
\&  fieldhashes \e my(%foo, %bar, %baz);
\&  # ...or any number
\&  fieldhashes @hashrefs;
\&
\&  ### Smoke a idhash n' regista it fo' garbage collection
\&  use Hash::Util::FieldHash qw(idhash register);
\&  idhash mah %name;
\&  mah $object = \e do { mah $o };
\&  # regista tha idhash fo' garbage collection wit $object
\&  register($object, \e %name);
\&  # tha followin entry is ghon be deleted when $object goes outta scope
\&  $name{$object} = \*(AqJizzy Doe\*(Aq;
\&
\&  ### Regista a ordinary hash fo' garbage collection
\&  use Hash::Util::FieldHash qw(id register);
\&  mah %name;
\&  mah $object = \e do { mah $o };
\&  # regista tha hash %name fo' garbage collection of $object\*(Aqs id
\&  regista $object, \e %name;
\&  # tha followin entry is ghon be deleted when $object goes outta scope
\&  $name{id $object} = \*(AqJizzy Doe\*(Aq;
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
\&\f(CW\*(C`Hash::Util::FieldHash\*(C'\fR offers a fuckin shitload of functions up in support of
\&\*(L"Da Inside-out Technique\*(R" of class construction.
.IP "id" 4
.IX Item "id"
.Vb 1
\&    id($obj)
.Ve
.Sp
Returns tha reference address of a reference \f(CW$obj\fR.  If \f(CW$obj\fR is
not a reference, returns \f(CW$obj\fR.
.Sp
This function be a stand-in replacement for
Scalar::Util::refaddr, dat is, it returns
the reference address of its argument as a numeric value.  Da only
difference is dat \f(CW\*(C`refaddr()\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR when given a
non-reference while \f(CW\*(C`id()\*(C'\fR returns its argument unchanged.
.Sp
\&\f(CW\*(C`id()\*(C'\fR also uses a cold-ass lil cachin technique dat make it fasta when
the id of a object be axed often yo, but slower if it is needed
only once or twice.
.IP "id_2obj" 4
.IX Item "id_2obj"
.Vb 1
\&    $obj = id_2obj($id)
.Ve
.Sp
If \f(CW$id\fR is tha id of a registered object (see \*(L"register\*(R"), returns
the object, otherwise a undefined value.  For registered objects this
is tha inverse function of \f(CW\*(C`id()\*(C'\fR.
.IP "register" 4
.IX Item "register"
.Vb 2
\&    register($obj)
\&    register($obj, @hashrefs)
.Ve
.Sp
In tha straight-up original gangsta form, registas a object ta work wit fo' tha function
\&\f(CW\*(C`id_2obj()\*(C'\fR.  In tha second form, it additionally marks tha given
hashrefs down fo' garbage collection. I aint talkin' bout chicken n' gravy biatch.  This means dat when tha object
goes outta scope, any entries up in tha given hashes under tha key of
\&\f(CW\*(C`id($obj)\*(C'\fR is ghon be deleted from tha hashes.
.Sp
It be a gangbangin' fatal error ta regista a non-reference \f(CW$obj\fR.  Any non-hashrefs
among tha followin arguments is silently ignored.
.Sp
It be \fInot\fR a error ta regista tha same object multiple times with
varyin setz of hashrefs.  Any hashrefs dat is not registered yet
will be added, others ignored.
.Sp
Registry also implies thread support.  When a freshly smoked up thread is pimped,
all references is replaced wit freshly smoked up ones, includin all objects.
If a hash uses tha reference address of a object as a key, that
connection would be broken. I aint talkin' bout chicken n' gravy biatch.  With a registered object, its id will
be updated up in all hashes registered wit dat shit.
.IP "idhash" 4
.IX Item "idhash"
.Vb 1
\&    idhash mah %hash
.Ve
.Sp
Makes a idhash from tha argument, which must be a hash.
.Sp
An \fIidhash\fR works like a aiiight hash, except dat it stringifies a
\&\fIreference used as a key\fR differently.  A reference is stringified
as if tha \f(CW\*(C`id()\*(C'\fR function had been invoked on it, dat is, its
reference address up in decimal is used as tha key.
.IP "idhashes" 4
.IX Item "idhashes"
.Vb 2
\&    idhashes \e my(%hash, %gnash, %trash)
\&    idhashes \e @hashrefs
.Ve
.Sp
Creates nuff idhashes from its hashref arguments, n' you can put dat on yo' toast.  Returns them
arguments dat could be converted or they number up in scalar context.
.IP "fieldhash" 4
.IX Item "fieldhash"
.Vb 1
\&    fieldhash %hash;
.Ve
.Sp
Creates a single fieldhash.  Da argument must be a hash.  Returns
a reference ta tha given hash if successful, otherwise nothing.
.Sp
A \fIfieldhash\fR is, up in short, a idhash wit auto-registry.  When an
object (or, indeed, any reference) is used as a gangbangin' fieldhash key, the
fieldhash be automatically registered fo' garbage collection with
the object, as if \f(CW\*(C`regista $obj, \e %fieldhash\*(C'\fR had been called.
.IP "fieldhashes" 4
.IX Item "fieldhashes"
.Vb 1
\&    fieldhashes @hashrefs;
.Ve
.Sp
Creates any number of field hashes.  Arguments must be hash references.
Returns tha converted hashrefs up in list context, they number up in scalar
context.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A word on terminology:  I shall use tha term \fIfield\fR fo' a scalar
piece of data dat a cold-ass lil class associates wit a object.  Other terms that
have been used fo' dis concept is \*(L"object variable\*(R", \*(L"(object) property\*(R",
\&\*(L"(object) attribute\*(R" n' mo' n' mo' n' mo'.  Especially \*(L"attribute\*(R" has some currency
among Perl programmer yo, but dat clashes wit tha \f(CW\*(C`attributes\*(C'\fR pragma.  The
term \*(L"field\*(R" also has some currency up in dis sense n' don't seem
to conflict wit other Perl terminology.
.PP
In Perl, a object be a pimped reference.  Da standard way of associating
data wit a object is ta store tha data inside tha objectz body, dat is,
the piece of data pointed ta by tha reference.
.PP
In consequence, if two or mo' classes wanna access a object they
\&\fImust\fR smoke on tha type of reference n' also on tha organization of
data within tha object body.  Failure ta smoke on tha type thangs up in dis biatch in
immediate dirtnap when tha wack method tries ta access a object.  Failure
to smoke on data organization may lead ta one class tramplin over the
data of another.
.PP
This object model leadz ta a tight couplin between subclasses.
If one class wants ta inherit from another (and both classes access
object data), tha classes must smoke bout implementation details.
Inheritizzle can only be used among classes dat is maintained together,
in a single source or not.
.PP
In particular, it aint possible ta write general-purpose classes
in dis technique, classes dat can advertise theyselves as \*(L"Put me
on yo' \f(CW@ISA\fR list n' use mah methods\*(R".  If tha other class has different
ideas bout how tha fuck tha object body is used, there is shit.
.PP
For reference \f(CW\*(C`Name_hash\*(C'\fR up in \*(L"Example 1\*(R" shows tha standard implementation of
a simple class \f(CW\*(C`Name\*(C'\fR up in tha well-known hash based way.  It also demonstrates
the predictable failure ta construct a cold-ass lil common subclass \f(CW\*(C`NamedFile\*(C'\fR
of \f(CW\*(C`Name\*(C'\fR n' tha class \f(CW\*(C`IO::File\*(C'\fR (whose objects \fImust\fR be globrefs).
.PP
Thus, steez iz of interest dat store object data \fInot\fR in
the object body but some other place.
.SS "Da Inside-out Technique"
.IX Subsection "Da Inside-out Technique"
With \fIinside-out\fR classes, each class declares a (typically lexical)
hash fo' each field it wants ta use.  Da reference address of an
object is used as tha hash key.  By definition, tha reference address
is unique ta each object so dis guarantees a place fo' each field that
is private ta tha class n' unique ta each object.  See \f(CW\*(C`Name_id\*(C'\fR
in \*(L"Example 1\*(R" fo' a simple example.
.PP
In comparison ta tha standard implementation where tha object be a
hash n' tha fieldz correspond ta hash keys, here tha fieldz correspond
to hashes, n' tha object determines tha hash key.  Thus tha hashes
appear ta be turned \fIinside out\fR.
.PP
Da body of a object is never examined by a inside-out class, only
its reference address is used. Y'all KNOW dat shit, muthafucka!  This allows fo' tha body of a actual
object ta be \fIanythang at all\fR while tha object methodz of tha class
still work as designed. Y'all KNOW dat shit, muthafucka!  This be a key feature of inside-out classes.
.SS "Problemz of Inside-out"
.IX Subsection "Problemz of Inside-out"
Inside-out classes give our asses freedom of inheritizzle yo, but as usual there
is a price.
.PP
Most obviously, there is tha necessitizzle of retrievin tha reference
address of a object fo' each data access.  It aint nuthin but a minor inconvenience,
but it do clutta tha code.
.PP
Mo' blingin (and less obvious) is tha necessitizzle of garbage
collection. I aint talkin' bout chicken n' gravy biatch.  When a aiiight object dies, anythang stored up in the
object body is garbage-collected by perl.  With inside-out objects,
Perl knows not a god damn thang bout tha data stored up in field hashes by a cold-ass lil class,
but these must be deleted when tha object goes outta scope.  Thus
the class must provide a \f(CW\*(C`DESTROY\*(C'\fR method ta take care of dis shit.
.PP
In tha presence of multiple classes it can be non-trivial
to make shizzle dat every last muthafuckin relevant destructor is called for
every object.  Perl calls tha straight-up original gangsta one it findz on the
inheritizzle tree (if any) n' thatz dat shit.
.PP
A related issue is thread-safety.  When a freshly smoked up thread is pimped,
the Perl interpreta is cloned, which implies dat all reference
addresses up in use is ghon be replaced wit freshly smoked up ones.  Thus, if a cold-ass lil class
tries ta access a gangbangin' field of a cold-ass lil cloned object its (cloned) data will
still be stored under tha now invalid reference address of the
original gangsta up in tha parent thread. Y'all KNOW dat shit, muthafucka!  A general \f(CW\*(C`CLONE\*(C'\fR method must
be provided ta re-establish tha association.
.SS "Solutions"
.IX Subsection "Solutions"
\&\f(CW\*(C`Hash::Util::FieldHash\*(C'\fR addresses these thangs on several
levels.
.PP
Da \f(CW\*(C`id()\*(C'\fR function is provided up in addizzle ta the
existin \f(CW\*(C`Scalar::Util::refaddr()\*(C'\fR.  Besides its short name
it can be a lil fasta under some circumstances (and a
bit slower under others).  Benchmark if it matters.  The
workin of \f(CW\*(C`id()\*(C'\fR also allows tha use of tha class name
as a \fIgeneric object\fR as busted lyrics bout further down.
.PP
Da \f(CW\*(C`id()\*(C'\fR function is incorporated up in \fIid hashes\fR up in tha sense
that it is called automatically on every last muthafuckin key dat is used with
the hash.  No explicit call is necessary.
.PP
Da problemz of garbage collection n' thread safety is both
addressed by tha function \f(CW\*(C`register()\*(C'\fR.  It registas a object
together wit any number of hashes.  Registry means dat when the
object dies, a entry up in any of tha hashes under tha reference
address of dis object is ghon be deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This guarantees garbage
collection up in these hashes.  It also means dat on thread
clonin tha objectz entries up in registered hashes will be
replaced wit updated entries whose key is tha cloned object's
reference address.  Thus tha object-data association becomes
thread-safe.
.PP
Object registry is dopest done when tha object is initialized
for use wit a cold-ass lil class.  That way, garbage collection n' thread
safety is established fo' every last muthafuckin object n' every last muthafuckin field dat is
initialized.
.PP
Finally, \fIfield hashes\fR incorporate all these functions up in one
package.  Besides automatically callin tha \f(CW\*(C`id()\*(C'\fR function
on every last muthafuckin object used as a key, tha object is registered with
the field hash on first use.  Classes based on field hashes
are straight-up garbage-collected n' thread safe without further
measures.
.SS "Mo' Problems"
.IX Subsection "Mo' Problems"
Another problem dat occurs wit inside-out classes is serialization.
Since tha object data aint up in its usual place, standard routines
like \f(CW\*(C`Storable::freeze()\*(C'\fR, \f(CW\*(C`Storable::thaw()\*(C'\fR n' 
\&\f(CW\*(C`Data::Dumper::Dumper()\*(C'\fR can't deal wit it on they own. I aint talkin' bout chicken n' gravy biatch.  Both
\&\f(CW\*(C`Data::Dumper\*(C'\fR n' \f(CW\*(C`Storable\*(C'\fR provide tha necessary hooks to
make thangs work yo, but tha functions or methodz used by tha hooks
must be provided by each inside-out class.
.PP
A general solution ta tha serialization problem would require another
level of registry, one dat that associates \fIclasses\fR n' fields.
So far, tha functionz of \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR is unaware of
any classes, which I consider a gangbangin' feature.  Therefore \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR
doesn't address tha serialization problems.
.SS "Da Generic Object"
.IX Subsection "Da Generic Object"
Classes based on tha \f(CW\*(C`id()\*(C'\fR function (and hence classes based on
\&\f(CW\*(C`idhash()\*(C'\fR n' \f(CW\*(C`fieldhash()\*(C'\fR) show a peculiar behavior up in that
the class name can be used like a object.  Specifically, methods
that set or read data associated wit a object continue ta work as
class methods, just as if tha class name was a object, distinct from
all other objects, wit its own data.  This object may be called
the \fIgeneric object\fR of tha class.
.PP
This works cuz field hashes respond ta keys dat is not references
like a aiiight hash would n' use tha strang offered as tha hash key.
Thus, if a method is called as a cold-ass lil class method, tha field hash is presented
with tha class name instead of a object n' blithely uses it as a key.
Since tha keyz of real objects is decimal numbers, there is no
conflict n' tha slot up in tha field hash can be used like any other.
Da \f(CW\*(C`id()\*(C'\fR function behaves correspondingly wit respect ta non-reference
arguments.
.PP
Two possible uses (besides ignorin tha property) come ta mind.
A singleton class could be implemented dis rockin tha generic object.
If necessary, a \f(CW\*(C`init()\*(C'\fR method could take a thugged-out dirtnap or ignore calls with
actual objects (references), so only tha generic object will eva exist.
.PP
Another use of tha generic object would be as a template.  It is
a convenient place ta store class-specific defaults fo' various
fieldz ta be used up in actual object initialization.
.PP
Usually, tha feature can be entirely ignored. Y'all KNOW dat shit, muthafucka!  Callin \fIobject
methods\fR as \fIclass methods\fR normally leadz ta a error n' aint used
routinely anywhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  It may be a problem dat dis error aint
indicated by a cold-ass lil class wit a generic object.
.SS "How tha fuck ta use Field Hashes"
.IX Subsection "How tha fuck ta use Field Hashes"
Traditionally, tha definizzle of a inside-out class gotz nuff a funky-ass bare
block inside which a fuckin shitload of lexical hashes is declared n' the
basic accessor methodz defined, probably all up in \f(CW\*(C`Scalar::Util::refaddr\*(C'\fR.
Further methodz may be defined outside dis block.  There has ta be
a \s-1DESTROY\s0 method and, fo' thread support, a \s-1CLONE\s0 method.
.PP
When field hashes is used, tha basic structure remains tha same.
Each lexical hash is ghon be done cooked up a gangbangin' field hash.  Da call ta \f(CW\*(C`refaddr\*(C'\fR
can be omitted from tha accessor methods.  \s-1DESTROY\s0 n' \s-1CLONE\s0 methods
are not necessary.
.PP
If you have a existin inside-out class, simply makin all hashes
field hashes wit no other chizzle should make no difference.  Through
the calls ta \f(CW\*(C`refaddr\*(C'\fR or equivalent, tha field hashes never git to
see a reference n' work like aiiight hashes.  Yo crazy-ass \s-1DESTROY \s0(and
\&\s-1CLONE\s0) methodz is still needed.
.PP
To make tha field hashes kick in, it is easiest ta redefine \f(CW\*(C`refaddr\*(C'\fR
as
.PP
.Vb 1
\&    sub refaddr { shift }
.Ve
.PP
instead of importin it from \f(CW\*(C`Scalar::Util\*(C'\fR.  It should now be possible
to disable \s-1DESTROY\s0 n' \s-1CLONE. \s0 Note dat while it aint disabled,
\&\s-1DESTROY\s0 is ghon be called before tha garbage collection of field hashes,
so it is ghon be invoked wit a gangbangin' functionizzle object n' will continue to
function.
.PP
It aint desirable ta import tha functions \f(CW\*(C`fieldhash\*(C'\fR and/or
\&\f(CW\*(C`fieldhashes\*(C'\fR tha fuck into every last muthafuckin class dat is goin ta use em.  They
are only used once ta set up tha class.  When tha class is up n' hustlin,
these functions serve no mo' purpose.
.PP
If there be only all dem field hashes ta declare, it is simplest to
.PP
.Vb 1
\&    use Hash::Util::FieldHash;
.Ve
.PP
early n' call tha functions qualified:
.PP
.Vb 1
\&    Hash::Util::FieldHash::fieldhash mah %foo;
.Ve
.PP
Otherwise, import tha functions tha fuck into a cold-ass lil convenient package like
\&\f(CW\*(C`HUF\*(C'\fR or, mo' general, \f(CW\*(C`Aux\*(C'\fR
.PP
.Vb 4
\&    {
\&        package Aux;
\&        use Hash::Util::FieldHash \*(Aq:all\*(Aq;
\&    }
.Ve
.PP
and call
.PP
.Vb 1
\&    Aux::fieldhash mah %foo;
.Ve
.PP
as needed.
.SS "Garbage-Collected Hashes"
.IX Subsection "Garbage-Collected Hashes"
Garbage collection up in a gangbangin' field hash means dat entries will \*(L"spontaneously\*(R"
disappear when tha object dat pimped dem disappears.  That must be
borne up in mind, especially when loopin over a gangbangin' field hash.  If anything
you do inside tha loop could cause a object ta go outta scope, a
random key may be deleted from tha hash yo ass is loopin over n' shit.  That
can throw tha loop iterator, so itz dopest ta cache a cold-ass lil consistent snapshot
of tha keys and/or joints n' loop over dis shit.  Yo ass will still have to
check dat a cold-ass lil cached entry still exists when you git ta dat shit.
.PP
Garbage collection can be confusin when keys is pimped up in a gangbangin' field hash
from aiiight scalars as well as references.  Once a reference is \fIused\fR with
a field hash, tha entry is ghon be collected, even if dat shiznit was lata overwritten
with a plain scalar key (every positizzle integer be a cold-ass lil muthafucka).  This
is legit even if tha original gangsta entry was deleted up in tha meantime.  In fact,
deletion from a gangbangin' field hash, n' also a test fo' existence constitute
\&\fIuse\fR up in dis sense n' create a liabilitizzle ta delete tha entry when
the reference goes outta scope.  If you happen ta create a entry
with a identical key from a strang or integer, dat is ghon be collected
instead. Y'all KNOW dat shit, muthafucka!  Thus, mixed use of references n' plain scalars as field hash
keys aint entirely supported.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Da examplez show a straight-up simple class dat implements a \fIname\fR, consisting
of a gangbangin' first n' last name (no middle initial).  Da name class has four
methods:
.IP "\(bu" 4
\&\f(CW\*(C`init()\*(C'\fR
.Sp
An object method dat initializes tha straight-up original gangsta n' last name ta its
two arguments, n' you can put dat on yo' toast. If called as a cold-ass lil class method, \f(CW\*(C`init()\*(C'\fR creates an
object up in tha given class n' initializes dis shit.
.IP "\(bu" 4
\&\f(CW\*(C`first()\*(C'\fR
.Sp
Retrieve tha straight-up original gangsta name
.IP "\(bu" 4
\&\f(CW\*(C`last()\*(C'\fR
.Sp
Retrieve tha last name
.IP "\(bu" 4
\&\f(CW\*(C`name()\*(C'\fR
.Sp
Retrieve tha full name, tha straight-up original gangsta n' last name joined by a funky-ass blank.
.PP
Da examplez show dis class implemented wit different levels of
support by \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR.  All supported combinations
are shown. I aint talkin' bout chicken n' gravy biatch.  Da difference between implementations is often quite
small.  Da implementations are:
.IP "\(bu" 4
\&\f(CW\*(C`Name_hash\*(C'\fR
.Sp
A conventionizzle (not inside-out) implementation where a object is
a hash dat stores tha field joints, without support by
\&\f(CW\*(C`Hash::Util::FieldHash\*(C'\fR.  This implementation don't allow
arbitrary inheritance.
.IP "\(bu" 4
\&\f(CW\*(C`Name_id\*(C'\fR
.Sp
Inside-out implementation based on tha \f(CW\*(C`id()\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  It needs
a \f(CW\*(C`DESTROY\*(C'\fR method. Y'all KNOW dat shit, muthafucka!  For thread support a \f(CW\*(C`CLONE\*(C'\fR method (not shown)
would also be needed. Y'all KNOW dat shit, muthafucka!  Instead of \f(CW\*(C`Hash::Util::FieldHash::id()\*(C'\fR the
function \f(CW\*(C`Scalar::Util::refaddr\*(C'\fR could be used wit straight-up lil
functionizzle difference.  This is tha basic pattern of a inside-out
class.
.IP "\(bu" 4
\&\f(CW\*(C`Name_idhash\*(C'\fR
.Sp
Idhash-based inside-out implementation. I aint talkin' bout chicken n' gravy biatch.  Like \f(CW\*(C`Name_id\*(C'\fR it needs
a \f(CW\*(C`DESTROY\*(C'\fR method n' would need \f(CW\*(C`CLONE\*(C'\fR fo' thread support.
.IP "\(bu" 4
\&\f(CW\*(C`Name_id_reg\*(C'\fR
.Sp
Inside-out implementation based on tha \f(CW\*(C`id()\*(C'\fR function wit explicit
object registry.  No destructor is needed n' objects is thread safe.
.IP "\(bu" 4
\&\f(CW\*(C`Name_idhash_reg\*(C'\fR
.Sp
Idhash-based inside-out implementation wit explicit object registry.
No destructor is needed n' objects is thread safe.
.IP "\(bu" 4
\&\f(CW\*(C`Name_fieldhash\*(C'\fR
.Sp
FieldHash-based inside-out implementation. I aint talkin' bout chicken n' gravy biatch.  Object registry happens
automatically.  No destructor is needed n' objects is thread safe.
.PP
These examplez is realized up in tha code below, which could be copied
to a gangbangin' file \fIExample.pm\fR.
.SS "Example 1"
.IX Subsection "Example 1"
.Vb 1
\&    use strict; use warnings;
\&
\&    {
\&        package Name_hash; # standard implementation: tha object be a hash
\&
\&        sub init {
\&            mah $obj = shift;
\&            mah ($first, $last) = @_;
\&            # create a object if called as class method
\&            $obj = bless {}, $obj unless ref $obj;
\&            $obj\->{ first} = $first;
\&            $obj\->{ last} = $last;
\&            $obj;
\&        }
\&
\&        sub first { shift()\->{ first} }
\&        sub last { shift()\->{ last} }
\&
\&        sub name {
\&            mah $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&
\&    }
\&
\&    {
\&        package Name_id;
\&        use Hash::Util::FieldHash qw(id);
\&
\&        mah (%first, %last);
\&
\&        sub init {
\&            mah $obj = shift;
\&            mah ($first, $last) = @_;
\&            # create a object if called as class method
\&            $obj = bless \e mah $o, $obj unless ref $obj;
\&            $first{ id $obj} = $first;
\&            $last{ id $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ id shift()} }
\&        sub last { $last{ id shift()} }
\&
\&        sub name {
\&            mah $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&
\&        sub DESTROY {
\&            mah $id = id shift;
\&            delete $first{ $id};
\&            delete $last{ $id};
\&        }
\&
\&    }
\&
\&    {
\&        package Name_idhash;
\&        use Hash::Util::FieldHash;
\&
\&        Hash::Util::FieldHash::idhashes( \e mah (%first, %last) );
\&
\&        sub init {
\&            mah $obj = shift;
\&            mah ($first, $last) = @_;
\&            # create a object if called as class method
\&            $obj = bless \e mah $o, $obj unless ref $obj;
\&            $first{ $obj} = $first;
\&            $last{ $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ shift()} }
\&        sub last { $last{ shift()} }
\&
\&        sub name {
\&            mah $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&
\&        sub DESTROY {
\&            mah $n = shift;
\&            delete $first{ $n};
\&            delete $last{ $n};
\&        }
\&
\&    }
\&
\&    {
\&        package Name_id_reg;
\&        use Hash::Util::FieldHash qw(id register);
\&
\&        mah (%first, %last);
\&
\&        sub init {
\&            mah $obj = shift;
\&            mah ($first, $last) = @_;
\&            # create a object if called as class method
\&            $obj = bless \e mah $o, $obj unless ref $obj;
\&            register( $obj, \e (%first, %last) );
\&            $first{ id $obj} = $first;
\&            $last{ id $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ id shift()} }
\&        sub last { $last{ id shift()} }
\&
\&        sub name {
\&            mah $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&    }
\&
\&    {
\&        package Name_idhash_reg;
\&        use Hash::Util::FieldHash qw(register);
\&
\&        Hash::Util::FieldHash::idhashes \e mah (%first, %last);
\&
\&        sub init {
\&            mah $obj = shift;
\&            mah ($first, $last) = @_;
\&            # create a object if called as class method
\&            $obj = bless \e mah $o, $obj unless ref $obj;
\&            register( $obj, \e (%first, %last) );
\&            $first{ $obj} = $first;
\&            $last{ $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ shift()} }
\&        sub last { $last{ shift()} }
\&
\&        sub name {
\&            mah $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&    }
\&
\&    {
\&        package Name_fieldhash;
\&        use Hash::Util::FieldHash;
\&
\&        Hash::Util::FieldHash::fieldhashes \e mah (%first, %last);
\&
\&        sub init {
\&            mah $obj = shift;
\&            mah ($first, $last) = @_;
\&            # create a object if called as class method
\&            $obj = bless \e mah $o, $obj unless ref $obj;
\&            $first{ $obj} = $first;
\&            $last{ $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ shift()} }
\&        sub last { $last{ shift()} }
\&
\&        sub name {
\&            mah $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&    }
\&
\&    1;
.Ve
.PP
To exercise tha various implementations tha script below can
be used.
.PP
It sets up a cold-ass lil class \f(CW\*(C`Name\*(C'\fR dat be a mirror of one of tha implementation
classes \f(CW\*(C`Name_hash\*(C'\fR, \f(CW\*(C`Name_id\*(C'\fR, ..., \f(CW\*(C`Name_fieldhash\*(C'\fR.  That determines
which implementation is run.
.PP
Da script first verifies tha function of tha \f(CW\*(C`Name\*(C'\fR class.
.PP
In tha second step, tha free inheritabilitizzle of tha implementation
(or lack thereof) is demonstrated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For dis purpose it constructs
a class called \f(CW\*(C`NamedFile\*(C'\fR which be a cold-ass lil common subclass of \f(CW\*(C`Name\*(C'\fR and
the standard class \f(CW\*(C`IO::File\*(C'\fR.  This puts inheritabilitizzle ta tha test
because objectz of \f(CW\*(C`IO::File\*(C'\fR \fImust\fR be globrefs.  Objectz of \f(CW\*(C`NamedFile\*(C'\fR
should behave like a gangbangin' file opened fo' readin n' also support tha \f(CW\*(C`name()\*(C'\fR
method. Y'all KNOW dat shit, muthafucka!  This class juncture works wit exception of tha \f(CW\*(C`Name_hash\*(C'\fR
implementation, where object initialization fails cuz of the
incompatibilitizzle of object bodies.
.SS "Example 2"
.IX Subsection "Example 2"
.Vb 1
\&    use strict; use warnings; $| = 1;
\&
\&    use Example;
\&
\&    {
\&        package Name;
\&        use base \*(AqName_id\*(Aq;      # define here which implementation ta run
\&    }
\&
\&
\&    # Verify dat tha base package works
\&    mah $n = Name\->init(qw(Albert Einstein));
\&    print $n\->name, "\en";
\&    print "\en";
\&
\&    # Smoke a named file handle (See definizzle below)
\&    mah $nf = NamedFile\->init(qw(/tmp/x Filomena File));
\&    # use as a gangbangin' file handle...
\&    fo' ( 1 .. 3 ) {
\&        mah $l = <$nf>;
\&        print "line $_: $l";
\&    }
\&    # ...and as a Name object
\&    print "...brought ta you by ", $nf\->name, "\en";
\&    exit;
\&
\&
\&    # Definizzle of NamedFile
\&    package NamedFile;
\&    use base \*(AqName\*(Aq;
\&    use base \*(AqIO::File\*(Aq;
\&
\&    sub init {
\&        mah $obj = shift;
\&        mah ($file, $first, $last) = @_;
\&        $obj = $obj\->IO::File::new() unless ref $obj;
\&        $obj\->open($file) or take a thugged-out dirtnap "Can\*(Aqt read \*(Aq$file\*(Aq: $!";
\&        $obj\->Name::init($first, $last);
\&    }
\&    _\|_END_\|_
.Ve
.SH "GUTS"
.IX Header "GUTS"
To make \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR work, there was two chizzlez to
\&\fIperl\fR itself.  \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR was made available fo' hashes,
and weak references now call uvar \f(CW\*(C`get\*(C'\fR magic afta a weakref has been
cleared. Y'all KNOW dat shit, muthafucka!  Da first feature is used ta make field hashes intercept
their keys upon access.  Da second one triggers garbage collection.
.ie n .SS "Da ""PERL_MAGIC_uvar"" intercourse fo' hashes"
.el .SS "Da \f(CWPERL_MAGIC_uvar\fP intercourse fo' hashes"
.IX Subsection "Da PERL_MAGIC_uvar intercourse fo' hashes"
\&\f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR \fIget\fR magic is called from \f(CW\*(C`hv_fetch_common\*(C'\fR and
\&\f(CW\*(C`hv_delete_common\*(C'\fR all up in tha function \f(CW\*(C`hv_magic_uvar_xkey\*(C'\fR, which
defines tha intercourse.  Da call happens fo' hashes wit \*(L"uvar\*(R" magic
if tha \f(CW\*(C`ufuncs\*(C'\fR structure has equal joints up in tha \f(CW\*(C`uf_val\*(C'\fR n' \f(CW\*(C`uf_set\*(C'\fR
fields.  Hashes is unaffected if (and as long as) these fields
hold different joints.
.PP
Upon tha call, tha \f(CW\*(C`mg_obj\*(C'\fR field will hold tha hash key ta be accessed.
Upon return, tha \f(CW\*(C`SV*\*(C'\fR value up in \f(CW\*(C`mg_obj\*(C'\fR is ghon be used up in place of the
original gangsta key up in tha hash access.  Da integer index value up in tha first
parameta is ghon be tha \f(CW\*(C`action\*(C'\fR value from \f(CW\*(C`hv_fetch_common\*(C'\fR, or \-1
if tha call is from \f(CW\*(C`hv_delete_common\*(C'\fR.
.PP
This be a template fo' a gangbangin' function suitable fo' tha \f(CW\*(C`uf_val\*(C'\fR field in
a \f(CW\*(C`ufuncs\*(C'\fR structure fo' dis call.  Da \f(CW\*(C`uf_set\*(C'\fR n' \f(CW\*(C`uf_index\*(C'\fR
fieldz is irrelevant.
.PP
.Vb 10
\&    IV watch_key(pTHX_ IV action, SV* field) {
\&        MAGIC* mg = mg_find(field, PERL_MAGIC_uvar);
\&        SV* keysv = mg\->mg_obj;
\&        /* Do whatever you need to.  If you decizzle to
\&           supply a gangbangin' finger-lickin' different key newkey, return it like this
\&        */
\&        sv_2mortal(newkey);
\&        mg\->mg_obj = newkey;
\&        return 0;
\&    }
.Ve
.SS "Weakrefs call uvar magic"
.IX Subsection "Weakrefs call uvar magic"
When a weak reference is stored up in a \f(CW\*(C`SV\*(C'\fR dat has \*(L"uvar\*(R" magic, \f(CW\*(C`set\*(C'\fR
magic is called afta tha reference has gone stale.  This hook can be
used ta trigger further garbage-collection activitizzles associated with
the referenced object.
.SS "How tha fuck field hashes work"
.IX Subsection "How tha fuck field hashes work"
Da three featurez of key hashes, \fIkey replacement\fR, \fIthread support\fR,
and \fIgarbage collection\fR is supported by a thugged-out data structure called
the \fIobject registry\fR.  This be a private hash where every last muthafuckin object
is stored. Y'all KNOW dat shit, muthafucka!  An \*(L"object\*(R" up in dis sense be any reference (blessed or
unblessed) dat has been used as a gangbangin' field hash key.
.PP
Da object registry keeps track of references dat done been used as
field hash keys.  Da keys is generated from tha reference address
like up in a gangbangin' field hash (though tha registry aint a gangbangin' field hash).  Each
value be a weak copy of tha original gangsta reference, stored up in a \f(CW\*(C`SV\*(C'\fR that
is itself magical (\f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR again).  Da magical structure
holdz a list (another hash, straight-up) of field hashes dat tha reference
has been used with.  When tha weakref becomes stale, tha magic is
activated n' uses tha list ta delete tha reference from all field
hashes it has been used with.  Afta that, tha entry is removed from
the object registry itself.  Implicitly, dat frees tha magic structure
and tha storage it has been using.
.PP
Whenever a reference is used as a gangbangin' field hash key, tha object registry
is checked n' a freshly smoked up entry is made if necessary.  Da field hash is
then added ta tha list of fieldz dis reference has used.
.PP
Da object registry be also used ta repair a gangbangin' field hash afta thread
cloning.  Here, tha entire object registry is processed. Y'all KNOW dat shit, muthafucka!  For every
reference found there, tha field hashes it has used is hit up and
the entry is updated.
.SS "Internal function Hash::Util::FieldHash::_fieldhash"
.IX Subsection "Internal function Hash::Util::FieldHash::_fieldhash"
.Vb 2
\&    # test if %hash be a gangbangin' field hash
\&    mah $result = _fieldhash \e %hash, 0;
\&
\&    # make %hash a gangbangin' field hash
\&    mah $result = _fieldhash \e %hash, 1;
.Ve
.PP
\&\f(CW\*(C`_fieldhash\*(C'\fR is tha internal function used ta create field hashes.
It takes two arguments, a hashref n' a mode.  If tha mode is boolean
false, tha hash aint chizzled but tested if it aint nuthin but a gangbangin' field hash.  If
the hash aint a gangbangin' field hash tha return value is boolean false.  If it
is, tha return value indicates tha mode of field hash.  When called with
a boolean legit mode, it turns tha given hash tha fuck into a gangbangin' field hash of this
mode, returnin tha mode of tha pimped field hash.  \f(CW\*(C`_fieldhash\*(C'\fR
does not erase tha given hash.
.PP
Currently there is only one type of field hash, n' only tha boolean
value of tha mode cook up a gangbangin' finger-lickin' difference yo, but dat may chizzle.
.SH "AUTHOR"
.IX Header "AUTHOR"
Anno Siegel (\s-1ANNO\s0) freestyled tha xs code n' tha chizzlez up in perl proper
Jeremy Hedden (\s-1JDHEDDEN\s0) juiced it up faster
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by (Anno Siegel)
.PP
This library is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself, either Perl version 5.8.7 or,
at yo' option, any lata version of Perl 5 you may have available.
