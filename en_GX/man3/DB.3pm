.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DB 3pm"
.TH DB 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
DB \- programmatic intercourse ta tha Perl debuggin API
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package CLIENT;
\&    use DB;
\&    @ISA = qw(DB);
\&
\&    # these (inherited) methodz can be called by tha client
\&
\&    CLIENT\->register()      # regista a cold-ass lil client package name
\&    CLIENT\->done()          # de\-regista from tha debuggin API
\&    CLIENT\->skippkg(\*(Aqhide::hide\*(Aq)  # ask DB not ta stop up in dis package
\&    CLIENT\->cont([WHERE])       # run some mo' (until BREAK or another breakpt)
\&    CLIENT\->step()              # single step
\&    CLIENT\->next()              # step over
\&    CLIENT\->ret()               # return from current subroutine
\&    CLIENT\->backtrace()         # return tha call stack description
\&    CLIENT\->ready()             # call when client setup is done
\&    CLIENT\->trace_toggle()      # toggle subroutine call trace mode
\&    CLIENT\->subs([SUBS])        # return subroutine shiznit
\&    CLIENT\->files()             # return list of all filez known ta DB
\&    CLIENT\->lines()             # return lines up in currently loaded file
\&    CLIENT\->loadfile(FILE,LINE) # load a gangbangin' file n' let other clients know
\&    CLIENT\->lineevents()        # return info on lines wit actions
\&    CLIENT\->set_break([WHERE],[COND])
\&    CLIENT\->set_tbreak([WHERE])
\&    CLIENT\->clr_breaks([LIST])
\&    CLIENT\->set_action(WHERE,ACTION)
\&    CLIENT\->clr_actions([LIST])
\&    CLIENT\->evalcode(STRING)  # eval STRING up in executin code\*(Aqs context
\&    CLIENT\->prestop([STRING]) # execute up in code context before stopping
\&    CLIENT\->poststop([STRING])# execute up in code context before resuming
\&
\&    # These methodz is ghon be called all up in tha appropriate times.
\&    # Stub versions provided do nothing.
\&    # None of these can block.
\&
\&    CLIENT\->init()          # called when debug API inits itself
\&    CLIENT\->stop(FILE,LINE) # when execution stops
\&    CLIENT\->idle()          # while stopped (can be a cold-ass lil client event loop)
\&    CLIENT\->cleanup()       # just before exit
\&    CLIENT\->output(LIST)    # called ta print any output dat API must show
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl debug shiznit is frequently required not just by debuggers,
but also by modulez dat need some \*(L"special\*(R" shiznit ta do their
job properly, like profilers.
.PP
This module abstracts n' serves up all of tha hooks tha fuck into Perl internal
debuggin functionality, so dat various implementationz of Perl debuggers
(or packages dat wanna simply git all up in tha \*(L"privileged\*(R" debuggin data)
can all benefit from tha pimpment of dis common code.  Currently used
by Swat, tha perl/Tk \s-1GUI\s0 debugger.
.PP
Note dat multiple \*(L"front-ends\*(R" can latch tha fuck into dis debuggin \s-1API\s0
simultaneously.  This is intended ta facilitate thangs like
debuggin wit a cold-ass lil command line n' \s-1GUI\s0 all up in tha same time, debuggin 
debuggers etc.  [Soundz sick yo, but dis needz some straight-up support \*(-- \s-1GSAR\s0]
.PP
In particular, dis \s-1API\s0 do \fBnot\fR provide tha followin functions:
.IP "\(bu" 4
data display
.IP "\(bu" 4
command processing
.IP "\(bu" 4
command alias pimpment
.IP "\(bu" 4
user intercourse (tty or graphical)
.PP
These is intended ta be skillz performed by tha clientz of dis \s-1API.\s0
.PP
This module attempts ta be squeaky clean w.r.t \f(CW\*(C`use strict;\*(C'\fR n' when
warnings is enabled.
.SS "Global Variables"
.IX Subsection "Global Variables"
Da followin \*(L"public\*(R" global names can be read by clientz of dis \s-1API.\s0
Beware dat these should be considered \*(L"readonly\*(R".
.ie n .IP "$DB::sub" 8
.el .IP "\f(CW$DB::sub\fR" 8
.IX Item "$DB::sub"
Name of current executin subroutine.
.ie n .IP "%DB::sub" 8
.el .IP "\f(CW%DB::sub\fR" 8
.IX Item "%DB::sub"
Da keyz of dis hash is tha namez of all tha known subroutines.  Each value
is a encoded strang dat has tha \fIsprintf\fR\|(3) format 
\&\f(CW\*(C`("%s:%d\-%d", filename, fromline, toline)\*(C'\fR.
.ie n .IP "$DB::single" 8
.el .IP "\f(CW$DB::single\fR" 8
.IX Item "$DB::single"
Single-step flag.  Will be legit if tha \s-1API\s0 will stop all up in tha next statement.
.ie n .IP "$DB::signal" 8
.el .IP "\f(CW$DB::signal\fR" 8
.IX Item "$DB::signal"
Signal flag. Will be set ta a legit value if a signal was caught.  Clients may
check fo' dis flag ta abort time-consumin operations.
.ie n .IP "$DB::trace" 8
.el .IP "\f(CW$DB::trace\fR" 8
.IX Item "$DB::trace"
This flag is set ta legit if tha \s-1API\s0 is tracin all up in subroutine calls.
.ie n .IP "@DB::args" 8
.el .IP "\f(CW@DB::args\fR" 8
.IX Item "@DB::args"
Gotz Nuff tha argumentz of current subroutine, or tha \f(CW@ARGV\fR array if up in tha 
toplevel context.
.ie n .IP "@DB::dbline" 8
.el .IP "\f(CW@DB::dbline\fR" 8
.IX Item "@DB::dbline"
List of lines up in currently loaded file.
.ie n .IP "%DB::dbline" 8
.el .IP "\f(CW%DB::dbline\fR" 8
.IX Item "%DB::dbline"
Actions up in current file (keys is line numbers).  Da joints is strings that
have tha \fIsprintf\fR\|(3) format \f(CW\*(C`("%s\e000%s", breakcondition, actioncode)\*(C'\fR.
.ie n .IP "$DB::package" 8
.el .IP "\f(CW$DB::package\fR" 8
.IX Item "$DB::package"
Package namespace of currently executin code.
.ie n .IP "$DB::filename" 8
.el .IP "\f(CW$DB::filename\fR" 8
.IX Item "$DB::filename"
Currently loaded filename.
.ie n .IP "$DB::subname" 8
.el .IP "\f(CW$DB::subname\fR" 8
.IX Item "$DB::subname"
Fully qualified name of currently executin subroutine.
.ie n .IP "$DB::lineno" 8
.el .IP "\f(CW$DB::lineno\fR" 8
.IX Item "$DB::lineno"
Line number dat is ghon be executed next.
.SS "\s-1API\s0 Methods"
.IX Subsection "API Methods"
Da followin is methodz up in tha \s-1DB\s0 base class.  A client must
access these methodz by inheritizzle (*not* by callin dem directly),
since tha \s-1API\s0 keeps track of clients all up in tha inheritance
mechanism.
.IP "\s-1CLIENT\-\s0>\fIregister()\fR" 8
.IX Item "CLIENT->register()"
regista a cold-ass lil client object/package
.IP "\s-1CLIENT\-\s0>evalcode(\s-1STRING\s0)" 8
.IX Item "CLIENT->evalcode(STRING)"
eval \s-1STRING\s0 up in executin code context
.IP "\s-1CLIENT\-\s0>skippkg('D::hide')" 8
.IX Item "CLIENT->skippkg('D::hide')"
ask \s-1DB\s0 not ta stop up in these packages
.IP "\s-1CLIENT\-\s0>\fIrun()\fR" 8
.IX Item "CLIENT->run()"
run some mo' (until a funky-ass breakpt is reached)
.IP "\s-1CLIENT\-\s0>\fIstep()\fR" 8
.IX Item "CLIENT->step()"
single step
.IP "\s-1CLIENT\-\s0>\fInext()\fR" 8
.IX Item "CLIENT->next()"
step over
.IP "\s-1CLIENT\-\s0>\fIdone()\fR" 8
.IX Item "CLIENT->done()"
de-regista from tha debuggin \s-1API\s0
.SS "Client Callback Methods"
.IX Subsection "Client Callback Methods"
Da followin \*(L"virtual\*(R" methodz can be defined by tha client.  They will
be called by tha \s-1API\s0 at appropriate points, n' you can put dat on yo' toast.  Note dat unless specified
otherwise, tha debug \s-1API\s0 only defines empty, non-functionizzle default versions
of these methods.
.IP "\s-1CLIENT\-\s0>\fIinit()\fR" 8
.IX Item "CLIENT->init()"
Called afta debug \s-1API\s0 inits itself.
.IP "\s-1CLIENT\-\s0>prestop([\s-1STRING\s0])" 8
.IX Item "CLIENT->prestop([STRING])"
Usually inherited from \s-1DB\s0 package.  If no arguments is passed,
returns tha prestop action string.
.IP "\s-1CLIENT\-\s0>\fIstop()\fR" 8
.IX Item "CLIENT->stop()"
Called when execution stops (w/ args file, line).
.IP "\s-1CLIENT\-\s0>\fIidle()\fR" 8
.IX Item "CLIENT->idle()"
Called while stopped (can be a cold-ass lil client event loop).
.IP "\s-1CLIENT\-\s0>poststop([\s-1STRING\s0])" 8
.IX Item "CLIENT->poststop([STRING])"
Usually inherited from \s-1DB\s0 package.  If no arguments is passed,
returns tha poststop action string.
.IP "\s-1CLIENT\-\s0>evalcode(\s-1STRING\s0)" 8
.IX Item "CLIENT->evalcode(STRING)"
Usually inherited from \s-1DB\s0 package.  Ask fo' a \s-1STRING\s0 ta be \f(CW\*(C`eval\*(C'\fR\-ed
in executin code context.
.IP "\s-1CLIENT\-\s0>\fIcleanup()\fR" 8
.IX Item "CLIENT->cleanup()"
Called just before exit.
.IP "\s-1CLIENT\-\s0>output(\s-1LIST\s0)" 8
.IX Item "CLIENT->output(LIST)"
Called when \s-1API\s0 must show a message (warnings, errors etc.).
.SH "BUGS"
.IX Header "BUGS"
Da intercourse defined by dis module is missin a shitload of tha lata additions
to perlz debuggin functionality.  As such, dis intercourse should be considered
highly experimenstrual n' subject ta chizzle.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gurusamy Sarathy	gsar@activestate.com
.PP
This code heavily adapted from a early version of perl5db.pl attributable
to Larry Wall n' tha Perl Porters.
