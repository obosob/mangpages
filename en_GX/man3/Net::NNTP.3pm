.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::NNTP 3pm"
.TH Net::NNTP 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::NNTP \- NNTP Client class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::NNTP;
\&
\&    $nntp = Net::NNTP\->new("some.host.name");
\&    $nntp\->quit;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Net::NNTP\*(C'\fR be a cold-ass lil class implementin a simple \s-1NNTP\s0 client up in Perl as busted lyrics about
in \s-1RFC977. \s0\f(CW\*(C`Net::NNTP\*(C'\fR inherits its communication methodz from \f(CW\*(C`Net::Cmd\*(C'\fR
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "new ( [ \s-1HOST \s0] [, \s-1OPTIONS \s0])" 4
.IX Item "new ( [ HOST ] [, OPTIONS ])"
This is tha constructor fo' a freshly smoked up Net::NNTP object. \f(CW\*(C`HOST\*(C'\fR is the
name of tha remote host ta which a \s-1NNTP\s0 connection is required. Y'all KNOW dat shit, muthafucka! If not
given then it may be passed as tha \f(CW\*(C`Host\*(C'\fR option busted lyrics bout below. If no host is passed
then two environment variablez is checked, first \f(CW\*(C`NNTPSERVER\*(C'\fR then
\&\f(CW\*(C`NEWSHOST\*(C'\fR, then \f(CW\*(C`Net::Config\*(C'\fR is checked, n' if a host aint found
then \f(CW\*(C`news\*(C'\fR is used.
.Sp
\&\f(CW\*(C`OPTIONS\*(C'\fR is passed up in a hash like fashion, rockin key n' value pairs.
Possible options are:
.Sp
\&\fBHost\fR \- \s-1NNTP\s0 host ta connect to. Well shiiiit, it may be a single scalar, as defined for
the \f(CW\*(C`PeerAddr\*(C'\fR option up in IO::Socket::INET, or a reference to
an array wit hosts ta try up in turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da \*(L"host\*(R" method will return tha value
which was used ta connect ta tha host.
.Sp
\&\fBTimeout\fR \- Maximum time, up in seconds, ta wait fo' a response from the
\&\s-1NNTP\s0 server, a value of zero will cause all \s-1IO\s0 operations ta block.
(default: 120)
.Sp
\&\fBDebug\fR \- Enable tha printin of debuggin shiznit ta \s-1STDERR\s0
.Sp
\&\fBReader\fR \- If tha remote server is \s-1INN\s0 then initially tha connection
will be ta nnrpd, by default \f(CW\*(C`Net::NNTP\*(C'\fR will issue a \f(CW\*(C`MODE READER\*(C'\fR command
so dat tha remote server becomes innd. Y'all KNOW dat shit, muthafucka! If tha \f(CW\*(C`Reader\*(C'\fR option is given
with a value of zero, then dis command aint gonna be busted n' the
connection is ghon be left rappin' ta nnrpd.
.SH "METHODS"
.IX Header "METHODS"
Unless otherwise stated all methodz return either a \fItrue\fR or \fIfalse\fR
value, wit \fItrue\fR meanin dat tha operation was a success. When a method
states dat it returns a value, failure is ghon be returned as \fIundef\fR or an
empty list.
.IP "article ( [ MSGID|MSGNUM ], [\s-1FH\s0] )" 4
.IX Item "article ( [ MSGID|MSGNUM ], [FH] )"
Retrieve tha header, a funky-ass blank line, then tha body (text) of the
specified article.
.Sp
If \f(CW\*(C`FH\*(C'\fR is specified then it is sposed ta fuckin be a valid filehandle
and tha result is ghon be printed ta it, on success a legit value will be
returned. Y'all KNOW dat shit, muthafucka! If \f(CW\*(C`FH\*(C'\fR aint specified then tha return value, on success,
will be a reference ta a array containin tha article requested, each
entry up in tha array will contain one line of tha article.
.Sp
If no arguments is passed then tha current article up in tha currently
selected newsgroup is fetched.
.Sp
\&\f(CW\*(C`MSGNUM\*(C'\fR be a numeric id of a article up in tha current newsgroup, and
will chizzle tha current article pointer n' shit.  \f(CW\*(C`MSGID\*(C'\fR is tha message id of
an article as shown up in dat articlez header n' shit.  It be anticipated dat the
client will obtain tha \f(CW\*(C`MSGID\*(C'\fR from a list provided by tha \f(CW\*(C`newnews\*(C'\fR
command, from references contained within another article, or from the
message-id provided up in tha response ta some other commands.
.Sp
If there be a error then \f(CW\*(C`undef\*(C'\fR is ghon be returned.
.IP "body ( [ MSGID|MSGNUM ], [\s-1FH\s0] )" 4
.IX Item "body ( [ MSGID|MSGNUM ], [FH] )"
Like \f(CW\*(C`article\*(C'\fR but only fetches tha body of tha article.
.IP "head ( [ MSGID|MSGNUM ], [\s-1FH\s0] )" 4
.IX Item "head ( [ MSGID|MSGNUM ], [FH] )"
Like \f(CW\*(C`article\*(C'\fR but only fetches tha headaz fo' tha article.
.IP "articlefh ( [ MSGID|MSGNUM ] )" 4
.IX Item "articlefh ( [ MSGID|MSGNUM ] )"
.PD 0
.IP "bodyfh ( [ MSGID|MSGNUM ] )" 4
.IX Item "bodyfh ( [ MSGID|MSGNUM ] )"
.IP "headfh ( [ MSGID|MSGNUM ] )" 4
.IX Item "headfh ( [ MSGID|MSGNUM ] )"
.PD
These is similar ta \fIarticle()\fR, \fIbody()\fR n' \fIhead()\fR yo, but rather than
returnin tha axed data directly, they return a tied filehandle
from which ta read tha article.
.IP "nntpstat ( [ MSGID|MSGNUM ] )" 4
.IX Item "nntpstat ( [ MSGID|MSGNUM ] )"
Da \f(CW\*(C`nntpstat\*(C'\fR command is similar ta tha \f(CW\*(C`article\*(C'\fR command except dat no
text is returned. Y'all KNOW dat shit, muthafucka!  When selectin by message number within a group,
the \f(CW\*(C`nntpstat\*(C'\fR command serves ta set tha \*(L"current article pointer\*(R" without
sendin text.
.Sp
Usin tha \f(CW\*(C`nntpstat\*(C'\fR command to
select by message-id is valid but of questionable value, since a
selection by message-id do \fBnot\fR alta tha \*(L"current article pointer\*(R".
.Sp
Returns tha message-id of tha \*(L"current article\*(R".
.IP "group ( [ \s-1GROUP \s0] )" 4
.IX Item "group ( [ GROUP ] )"
Set and/or git tha current group. If \f(CW\*(C`GROUP\*(C'\fR aint given then shiznit
is returned on tha current group.
.Sp
In a scalar context it returns tha crew name.
.Sp
In a array context tha return value be a list containing, tha number
of articlez up in tha group, tha number of tha straight-up original gangsta article, tha number
of tha last article n' tha crew name.
.IP "ihave ( \s-1MSGID\s0 [, \s-1MESSAGE \s0])" 4
.IX Item "ihave ( MSGID [, MESSAGE ])"
Da \f(CW\*(C`ihave\*(C'\fR command informs tha server dat tha client has a article
whose id is \f(CW\*(C`MSGID\*(C'\fR.  If tha server desires a cold-ass lil copy of that
article, n' \f(CW\*(C`MESSAGE\*(C'\fR has been given tha it is ghon be sent.
.Sp
Returns \fItrue\fR if tha server desires tha article n' \f(CW\*(C`MESSAGE\*(C'\fR was
successfully sent,if specified.
.Sp
If \f(CW\*(C`MESSAGE\*(C'\fR aint specified then tha message must be busted rockin the
\&\f(CW\*(C`datasend\*(C'\fR n' \f(CW\*(C`dataend\*(C'\fR methodz from Net::Cmd
.Sp
\&\f(CW\*(C`MESSAGE\*(C'\fR can be either a array of lines or a reference ta a array.
.IP "last ()" 4
.IX Item "last ()"
Set tha \*(L"current article pointer\*(R" ta tha previous article up in tha current
newsgroup.
.Sp
Returns tha message-id of tha article.
.IP "date ()" 4
.IX Item "date ()"
Returns tha date on tha remote server n' shit. This date is ghon be up in a \s-1UNIX\s0 time
format (secondz since 1970)
.IP "postok ()" 4
.IX Item "postok ()"
\&\f(CW\*(C`postok\*(C'\fR will return \fItrue\fR if tha servers initial response indicated
that it will allow posting.
.IP "authinfo ( \s-1USER, PASS \s0)" 4
.IX Item "authinfo ( USER, PASS )"
Authenticates ta tha server (usin \s-1AUTHINFO USER / AUTHINFO PASS\s0)
usin tha supplied username n' password. Y'all KNOW dat shit, muthafucka!  Please note dat the
password is busted up in clear text ta tha server n' shit.  This command should not
be used wit valuable passwordz unless tha connection ta tha server is
somehow protected.
.IP "list ()" 4
.IX Item "list ()"
Obtain shiznit bout all tha actizzle newsgroups. Da thangs up in dis biatch be a reference
to a hash where tha key be a crew name n' each value be a reference ta an
array. Da elements up in dis array are:\- tha last article number up in tha group,
the first article number up in tha crew n' any shiznit flags bout tha group.
.IP "newgroups ( \s-1SINCE\s0 [, \s-1DISTRIBUTIONS \s0])" 4
.IX Item "newgroups ( SINCE [, DISTRIBUTIONS ])"
\&\f(CW\*(C`SINCE\*(C'\fR be a time value n' \f(CW\*(C`DISTRIBUTIONS\*(C'\fR is either a gangbangin' finger-lickin' distribution
pattern or a reference ta a list of distribution patterns.
Da result is tha same ol' dirty as \f(CW\*(C`list\*(C'\fR yo, but the
groups return is ghon be limited ta dem pimped afta \f(CW\*(C`SINCE\*(C'\fR and, if
specified, up in one of tha distribution areas up in \f(CW\*(C`DISTRIBUTIONS\*(C'\fR.
.IP "newshizzle ( \s-1SINCE\s0 [, \s-1GROUPS\s0 [, \s-1DISTRIBUTIONS \s0]])" 4
.IX Item "newshizzle ( SINCE [, GROUPS [, DISTRIBUTIONS ]])"
\&\f(CW\*(C`SINCE\*(C'\fR be a time value. \f(CW\*(C`GROUPS\*(C'\fR is either a crew pattern or a reference
to a list of crew patterns. \f(CW\*(C`DISTRIBUTIONS\*(C'\fR is either a gangbangin' finger-lickin' distribution
pattern or a reference ta a list of distribution patterns.
.Sp
Returns a reference ta a list which gotz nuff tha message-idz of all shizzle posted
afta \f(CW\*(C`SINCE\*(C'\fR, dat is up in a crews which matched \f(CW\*(C`GROUPS\*(C'\fR n' a
distribution which matches \f(CW\*(C`DISTRIBUTIONS\*(C'\fR.
.IP "next ()" 4
.IX Item "next ()"
Set tha \*(L"current article pointer\*(R" ta tha next article up in tha current
newsgroup.
.Sp
Returns tha message-id of tha article.
.IP "post ( [ \s-1MESSAGE \s0] )" 4
.IX Item "post ( [ MESSAGE ] )"
Post a freshly smoked up article ta tha shizzle server n' shit. If \f(CW\*(C`MESSAGE\*(C'\fR is specified n' posting
is allowed then tha message is ghon be sent.
.Sp
If \f(CW\*(C`MESSAGE\*(C'\fR aint specified then tha message must be busted rockin the
\&\f(CW\*(C`datasend\*(C'\fR n' \f(CW\*(C`dataend\*(C'\fR methodz from Net::Cmd
.Sp
\&\f(CW\*(C`MESSAGE\*(C'\fR can be either a array of lines or a reference ta a array.
.Sp
Da message, either busted via \f(CW\*(C`datasend\*(C'\fR or as tha \f(CW\*(C`MESSAGE\*(C'\fR
parameter, must be up in tha format as busted lyrics bout by \s-1RFC822\s0 n' must
contain From:, Shitgroups: n' Subject: headers.
.IP "postfh ()" 4
.IX Item "postfh ()"
Post a freshly smoked up article ta tha shizzle server rockin a tied filehandle.  If
postin be allowed, dis method will return a tied filehandle dat you
can \fIprint()\fR tha contentz of tha article ta be posted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Yo ass must
explicitly \fIclose()\fR tha filehandle when yo ass is finished postin the
article, n' tha return value from tha \fIclose()\fR call will indicate
whether tha message was successfully posted.
.IP "slave ()" 4
.IX Item "slave ()"
Tell tha remote server dat I aint a user client yo, but probably another
shizzle server.
.IP "quit ()" 4
.IX Item "quit ()"
Quit tha remote server n' close tha socket connection.
.SS "Extension methods"
.IX Subsection "Extension methods"
These methodz use commandz dat is not part of tha \s-1RFC977\s0 documentation. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Some
servers may not support all of em.
.IP "newsgroups ( [ \s-1PATTERN \s0] )" 4
.IX Item "newsgroups ( [ PATTERN ] )"
Returns a reference ta a hash where tha keys is all tha crew names which
match \f(CW\*(C`PATTERN\*(C'\fR, or all of tha crews if no pattern is specified, and
each value gotz nuff tha description text fo' tha group.
.IP "distributions ()" 4
.IX Item "distributions ()"
Returns a reference ta a hash where tha keys is all tha possible
distribution names n' tha joints is tha distribution descriptions.
.IP "subscriptions ()" 4
.IX Item "subscriptions ()"
Returns a reference ta a list which gotz nuff a list of crews which
are recommended fo' a freshly smoked up user ta subscribe to.
.IP "overview_fmt ()" 4
.IX Item "overview_fmt ()"
Returns a reference ta a array which contain tha namez of tha fieldz returned
by \f(CW\*(C`xover\*(C'\fR.
.IP "active_times ()" 4
.IX Item "active_times ()"
Returns a reference ta a hash where tha keys is tha crew names n' each
value be a reference ta a array containin tha time tha crews was pimped
and a identifier, possibly a Email address, of tha creator.
.IP "actizzle ( [ \s-1PATTERN \s0] )" 4
.IX Item "actizzle ( [ PATTERN ] )"
Similar ta \f(CW\*(C`list\*(C'\fR but only actizzle crews dat match tha pattern is returned.
\&\f(CW\*(C`PATTERN\*(C'\fR can be a crew pattern.
.IP "xgtitle ( \s-1PATTERN \s0)" 4
.IX Item "xgtitle ( PATTERN )"
Returns a reference ta a hash where tha keys is all tha crew names which
match \f(CW\*(C`PATTERN\*(C'\fR n' each value is tha description text fo' tha group.
.IP "xhdr ( \s-1HEADER,\s0 MESSAGE-SPEC )" 4
.IX Item "xhdr ( HEADER, MESSAGE-SPEC )"
Obtain tha header field \f(CW\*(C`HEADER\*(C'\fR fo' all tha lyrics specified.
.Sp
Da return value is ghon be a reference
to a hash where tha keys is tha message numbers n' each value gotz nuff
the text of tha axed header fo' dat message.
.IP "xover ( MESSAGE-SPEC )" 4
.IX Item "xover ( MESSAGE-SPEC )"
Da return value is ghon be a reference
to a hash where tha keys is tha message numbers n' each value gotz nuff
a reference ta a array which gotz nuff tha overview fieldz fo' that
message.
.Sp
Da namez of tha fieldz can be obtained by callin \f(CW\*(C`overview_fmt\*(C'\fR.
.IP "xpath ( MESSAGE-ID )" 4
.IX Item "xpath ( MESSAGE-ID )"
Returns tha path name ta tha file on tha server which gotz nuff tha specified
message.
.IP "xpat ( \s-1HEADER, PATTERN,\s0 MESSAGE-SPEC)" 4
.IX Item "xpat ( HEADER, PATTERN, MESSAGE-SPEC)"
Da result is tha same ol' dirty as \f(CW\*(C`xhdr\*(C'\fR except tha is is ghon be restricted to
headaz where tha text of tha header matches \f(CW\*(C`PATTERN\*(C'\fR
.IP "xrover" 4
.IX Item "xrover"
Da \s-1XROVER\s0 command returns reference shiznit fo' tha article(s)
specified.
.Sp
Returns a reference ta a \s-1HASH\s0 where tha keys is tha message numbers n' the
values is tha References: lines from tha articles
.IP "listgroup ( [ \s-1GROUP \s0] )" 4
.IX Item "listgroup ( [ GROUP ] )"
Returns a reference ta a list of all tha actizzle lyrics up in \f(CW\*(C`GROUP\*(C'\fR, or
the current crew if \f(CW\*(C`GROUP\*(C'\fR aint specified.
.IP "reader" 4
.IX Item "reader"
Tell tha server dat yo ass be a reader n' not another server.
.Sp
This is required by some servers. For example if yo ass is connectin to
an \s-1INN\s0 server n' you have transfer permission yo' connection will
be connected ta tha transfer daemon, not tha \s-1NNTP\s0 daemon. I aint talkin' bout chicken n' gravy biatch. Issuing
this command will cause tha transfer daemon ta hand over control
to tha \s-1NNTP\s0 daemon.
.Sp
Some servers do not KNOW dis command yo, but issuin it n' ignoring
the response is harmless.
.SH "UNSUPPORTED"
.IX Header "UNSUPPORTED"
Da followin \s-1NNTP\s0 command is unsupported by tha package, n' there are
no plans ta do so.
.PP
.Vb 4
\&    AUTHINFO GENERIC
\&    XTHREAD
\&    XSEARCH
\&    XINDEX
.Ve
.SH "DEFINITIONS"
.IX Header "DEFINITIONS"
.IP "MESSAGE-SPEC" 4
.IX Item "MESSAGE-SPEC"
\&\f(CW\*(C`MESSAGE\-SPEC\*(C'\fR is either a single message-id, a single message number, or
a reference ta a list of two message numbers.
.Sp
If \f(CW\*(C`MESSAGE\-SPEC\*(C'\fR be a reference ta a list of two message numbers n' the
second number up in a range is less than or equal ta tha straight-up original gangsta then tha range
represents all lyrics up in tha crew afta tha straight-up original gangsta message number.
.Sp
\&\fB\s-1NOTE\s0\fR For compatibilitizzle reasons only wit earlier versionz of Net::NNTP
a message spec can be passed as a list of two numbers, dis is deprecated
and a reference ta tha list should now be passed
.IP "\s-1PATTERN\s0" 4
.IX Item "PATTERN"
Da \f(CW\*(C`NNTP\*(C'\fR protocol uses tha \f(CW\*(C`WILDMAT\*(C'\fR format fo' patterns.
Da \s-1WILDMAT\s0 format was first pimped by Rich Salz based on
the format used up in tha \s-1UNIX \s0\*(L"find\*(R" command ta articulate
file names. Dat shiznit was pimped ta provide a uniform mechanism
for matchin patterns up in tha same manner dat tha \s-1UNIX\s0 shell
matches filenames.
.Sp
Patterns is implicitly anchored at the
beginnin n' end of each strang when testin fo' a match.
.Sp
There is five pattern matchin operations other than a strict
one-to-one match between tha pattern n' tha source ta be
checked fo' a match.
.Sp
Da first be a asterisk \f(CW\*(C`*\*(C'\fR ta match any sequence of zero or more
characters.
.Sp
Da second be a question mark \f(CW\*(C`?\*(C'\fR ta match any single character n' shit. The
third specifies a specific set of characters.
.Sp
Da set is specified as a list of characters, or as a range of characters
where tha beginnin n' end of tha range is separated by a minus (or dash)
character, or as any combination of lists n' ranges. Da dash can
also be included up in tha set as a cold-ass lil characta it if is tha beginning
or end of tha set. This set is enclosed up in square brackets, n' you can put dat on yo' toast. The
close square bracket \f(CW\*(C`]\*(C'\fR may be used up in a set if it is tha first
characta up in tha set.
.Sp
Da fourth operation is tha same ol' dirty as the
logical not of tha third operation n' is specified tha same
way as tha third wit tha addizzle of a cold-ass lil caret characta \f(CW\*(C`^\*(C'\fR at
the beginnin of tha test strang just inside tha open square
bracket.
.Sp
Da final operation uses tha backslash characta to
invalidate tha special meanin of a open square bracket \f(CW\*(C`[\*(C'\fR,
the asterisk, backslash or tha question mark. Two backslashes in
sequence will result up in tha evaluation of tha backslash as a
characta wit no special meaning.
.RS 4
.IP "Examples" 4
.IX Item "Examples"
.PD 0
.ie n .IP """[^]\-]""" 4
.el .IP "\f(CW[^]\-]\fR" 4
.IX Item "[^]-]"
.PD
matches any single characta other than a cold-ass lil close square
bracket or a minus sign/dash.
.ie n .IP "*bdc" 4
.el .IP "\f(CW*bdc\fR" 4
.IX Item "*bdc"
matches any strang dat endz wit tha strang \*(L"bdc\*(R"
includin tha strang \*(L"bdc\*(R" (without quotes).
.ie n .IP """[0\-9a\-zA\-Z]""" 4
.el .IP "\f(CW[0\-9a\-zA\-Z]\fR" 4
.IX Item "[0-9a-zA-Z]"
matches any single printable alphanumeric \s-1ASCII\s0 character.
.ie n .IP """a??d""" 4
.el .IP "\f(CWa??d\fR" 4
.IX Item "a??d"
matches any four characta strang which begins
with a n' endz wit d.
.RE
.RS 4
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::Cmd
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@pobox.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1995\-1997 Graham Barr fo' realz. All muthafuckin rights reserved.
This program is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
