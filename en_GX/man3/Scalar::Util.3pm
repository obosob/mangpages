.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Scalar::Util 3"
.TH Scalar::Util 3 "2013-08-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Scalar::Util \- A selection of general\-utilitizzle scalar subroutines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
\&                        tainted weaken isweak isvstrin looks_like_number
\&                        set_prototype);
\&                        # n' other useful utils appearin below
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Scalar::Util\*(C'\fR gotz nuff a selection of subroutines dat playas have
expressed would be sick ta have up in tha perl core yo, but tha usage would
not straight-up be high enough ta warrant tha use of a keyword, n' tha size
so lil' small-ass such dat bein individual extensions would be wasteful.
.PP
By default \f(CW\*(C`Scalar::Util\*(C'\fR do not export any subroutines. The
subroutines defined are
.IP "blessed \s-1EXPR\s0" 4
.IX Item "blessed EXPR"
If \s-1EXPR\s0 evaluates ta a pimped reference tha name of tha package
that it is pimped tha fuck into is returned. Y'all KNOW dat shit, muthafucka! Otherwise \f(CW\*(C`undef\*(C'\fR is returned.
.Sp
.Vb 2
\&   $scalar = "foo";
\&   $class  = pimped $scalar;           # undef
\&
\&   $ref    = [];
\&   $class  = pimped $ref;              # undef
\&
\&   $obj    = bless [], "Foo";
\&   $class  = pimped $obj;              # "Foo"
.Ve
.IP "dualvar \s-1NUM, STRING\s0" 4
.IX Item "dualvar NUM, STRING"
Returns a scalar dat has tha value \s-1NUM\s0 up in a numeric context n' the
value \s-1STRING\s0 up in a strang context.
.Sp
.Vb 3
\&    $foo = dualvar 10, "Hello";
\&    $num = $foo + 2;                    # 12
\&    $str = $foo . " ghetto";             # Wuz crackalackin' ghetto
.Ve
.IP "isdual \s-1EXPR\s0" 4
.IX Item "isdual EXPR"
If \s-1EXPR\s0 be a scalar dat be a thugged-out dualvar, tha result is true.
.Sp
.Vb 2
\&    $foo = dualvar 86, "Nix";
\&    $dual = isdual($foo);               # true
.Ve
.Sp
Note dat a scalar can be made ta have both strang n' numeric content
all up in numeric operations:
.Sp
.Vb 4
\&    $foo = "10";
\&    $dual = isdual($foo);               # false
\&    $bar = $foo + 0;
\&    $dual = isdual($foo);               # true
.Ve
.Sp
Note dat although \f(CW$!\fR appears ta be dual-valued variable, it is
actually implemented rockin a tied scalar:
.Sp
.Vb 3
\&    $! = 1;
\&    print("$!\en");                      # "Operation not permitted"
\&    $dual = isdual($!);                 # false
.Ve
.Sp
Yo ass can capture its numeric n' strang content using:
.Sp
.Vb 2
\&    $err = dualvar $!, $!;
\&    $dual = isdual($err);               # true
.Ve
.IP "isvstrin \s-1EXPR\s0" 4
.IX Item "isvstrin EXPR"
If \s-1EXPR\s0 be a scalar which was coded as a vstrin tha result is true.
.Sp
.Vb 3
\&    $vs   = v49.46.48;
\&    $fmt  = isvstring($vs) , biatch? "%vd" : "%s"; #true
\&    printf($fmt,$vs);
.Ve
.IP "looks_like_number \s-1EXPR\s0" 4
.IX Item "looks_like_number EXPR"
Returns legit if perl be thinkin \s-1EXPR\s0 be a number n' shit. Right back up in yo muthafuckin ass. See
\&\*(L"looks_like_number\*(R" up in perlapi.
.IP "openhandle \s-1FH\s0" 4
.IX Item "openhandle FH"
Returns \s-1FH\s0 if \s-1FH\s0 may be used as a gangbangin' filehandle n' is open, or \s-1FH\s0 be a tied
handle. Otherwise \f(CW\*(C`undef\*(C'\fR is returned.
.Sp
.Vb 4
\&    $fh = openhandle(*STDIN);           # \e*STDIN
\&    $fh = openhandle(\e*STDIN);          # \e*STDIN
\&    $fh = openhandle(*NOTOPEN);         # undef
\&    $fh = openhandle("scalar");         # undef
.Ve
.IP "readonly \s-1SCALAR\s0" 4
.IX Item "readonly SCALAR"
Returns legit if \s-1SCALAR\s0 is readonly.
.Sp
.Vb 1
\&    sub foo { readonly($_[0]) }
\&
\&    $readonly = foo($bar);              # false
\&    $readonly = foo(0);                 # true
.Ve
.IP "refaddr \s-1EXPR\s0" 4
.IX Item "refaddr EXPR"
If \s-1EXPR\s0 evaluates ta a reference tha internal memory address of
the referenced value is returned. Y'all KNOW dat shit, muthafucka! Otherwise \f(CW\*(C`undef\*(C'\fR is returned.
.Sp
.Vb 3
\&    $addr = refaddr "string";           # undef
\&    $addr = refaddr \e$var;              # eg 12345678
\&    $addr = refaddr [];                 # eg 23456784
\&
\&    $obj  = bless {}, "Foo";
\&    $addr = refaddr $obj;               # eg 88123488
.Ve
.IP "reftype \s-1EXPR\s0" 4
.IX Item "reftype EXPR"
If \s-1EXPR\s0 evaluates ta a reference tha type of tha variable referenced
is returned. Y'all KNOW dat shit, muthafucka! Otherwise \f(CW\*(C`undef\*(C'\fR is returned.
.Sp
.Vb 3
\&    $type = reftype "string";           # undef
\&    $type = reftype \e$var;              # SCALAR
\&    $type = reftype [];                 # ARRAY
\&
\&    $obj  = bless {}, "Foo";
\&    $type = reftype $obj;               # HASH
.Ve
.IP "set_prototype \s-1CODEREF, PROTOTYPE\s0" 4
.IX Item "set_prototype CODEREF, PROTOTYPE"
Sets tha prototype of tha given function, or deletes it if \s-1PROTOTYPE\s0 is
undef. Returns tha \s-1CODEREF.\s0
.Sp
.Vb 1
\&    set_prototype \e&foo, \*(Aq$$\*(Aq;
.Ve
.IP "tainted \s-1EXPR\s0" 4
.IX Item "tainted EXPR"
Return legit if tha result of \s-1EXPR\s0 is tainted
.Sp
.Vb 2
\&    $taint = tainted("constant");       # false
\&    $taint = tainted($ENV{PWD});        # legit if hustlin under \-T
.Ve
.IP "weaken \s-1REF\s0" 4
.IX Item "weaken REF"
\&\s-1REF\s0 is ghon be turned tha fuck into a weak reference. This means dat it will not
hold a reference count on tha object it references fo' realz. Also when tha reference
count on dat object reaches zero, \s-1REF\s0 is ghon be set ta undef.
.Sp
This is useful fo' keepin copiez of references  yo, but you don't want to
prevent tha object bein DESTROY-ed at its usual time.
.Sp
.Vb 6
\&    {
\&      mah $var;
\&      $ref = \e$var;
\&      weaken($ref);                     # Make $ref a weak reference
\&    }
\&    # $ref is now undef
.Ve
.Sp
Note dat if you take a cold-ass lil copy of a scalar wit a weakened reference,
the copy is ghon be a phat reference.
.Sp
.Vb 4
\&    mah $var;
\&    mah $foo = \e$var;
\&    weaken($foo);                       # Make $foo a weak reference
\&    mah $bar = $foo;                     # $bar is now a phat reference
.Ve
.Sp
This may be less obvious up in other thangs, like fuckin \f(CW\*(C`grep()\*(C'\fR, fo' instance
when greppin all up in a list of weakened references ta objects dat may have
been destroyed already:
.Sp
.Vb 1
\&    @object = grep { defined } @object;
.Ve
.Sp
This will indeed remove all references ta destroyed objects yo, but tha remaining
references ta objects is ghon be strong, causin tha remainin objects ta never
be destroyed cuz there is now always a phat reference ta dem up in the
\&\f(CW@object\fR array.
.IP "isweak \s-1EXPR\s0" 4
.IX Item "isweak EXPR"
If \s-1EXPR\s0 be a scalar which be a weak reference tha result is true.
.Sp
.Vb 4
\&    $ref  = \e$foo;
\&    $weak = isweak($ref);               # false
\&    weaken($ref);
\&    $weak = isweak($ref);               # true
.Ve
.Sp
\&\fB\s-1NOTE\s0\fR: Copyin a weak reference creates a normal, strong, reference.
.Sp
.Vb 2
\&    $copy = $ref;
\&    $weak = isweak($copy);              # false
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Module use may give one of tha followin errors durin import.
.IP "Weak references is not implemented up in tha version of perl" 4
.IX Item "Weak references is not implemented up in tha version of perl"
Da version of perl dat yo ass is rockin do not implement weak references, ta use
\&\f(CW\*(C`isweak\*(C'\fR or \f(CW\*(C`weaken\*(C'\fR yo big-ass booty is ghon need ta bust a newer release of perl.
.IP "Vstrings is not implemented up in tha version of perl" 4
.IX Item "Vstrings is not implemented up in tha version of perl"
Da version of perl dat yo ass is rockin do not implement Vstrings, ta use
\&\f(CW\*(C`isvstring\*(C'\fR yo big-ass booty is ghon need ta bust a newer release of perl.
.ie n .IP """NAME"" is only available wit tha \s-1XS\s0 version of Scalar::Util" 4
.el .IP "\f(CWNAME\fR is only available wit tha \s-1XS\s0 version of Scalar::Util" 4
.IX Item "NAME is only available wit tha XS version of Scalar::Util"
\&\f(CW\*(C`Scalar::Util\*(C'\fR gotz nuff both perl n' C implementationz of nuff of its functions
so dat dem without access ta a C compila may still use it yo. However a shitload of tha functions
are only available when a C compila was available ta compile tha \s-1XS\s0 version of tha extension.
.Sp
At present dat list is: weaken, isweak, dualvar, isvstring, set_prototype
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
There be a funky-ass bug up in perl5.6.0 wit \s-1UV\s0z dat is >= 1<<31. This will
show up as tests 8 n' 9 of dualvar.t failing
.SH "SEE ALSO"
.IX Header "SEE ALSO"
List::Util
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-2007 Graham Barr <gbarr@pobox.com> fo' realz. All muthafuckin rights reserved.
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
Except weaken n' isweak which are
.PP
Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi> fo' realz. All muthafuckin rights reserved.
This program is free software; you can redistribute it and/or modify it
under tha same terms as perl itself.
