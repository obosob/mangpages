.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MIME::Decoder 3"
.TH MIME::Decoder 3 "2013-11-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME::Decoder \- a object fo' decodin tha body part of a MIME stream
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Before readin further, you should peep MIME::Tools ta make shizzle that
you KNOW where dis module fits tha fuck into tha grand scheme of thangs.
Go on, do it now, nahmeean, biatch?  I be bout ta wait.
.PP
Ready, biatch?  Ok...
.SS "Decodin a thugged-out data stream"
.IX Subsection "Decodin a thugged-out data stream"
Herez a simple filta program ta read quoted-printable data from \s-1STDIN
\&\s0(until \s-1EOF\s0) n' write tha decoded data ta \s-1STDOUT:\s0
.PP
.Vb 1
\&    use MIME::Decoder;
\&
\&    $decoder = freshly smoked up MIME::Decoder \*(Aqquoted\-printable\*(Aq or take a thugged-out dirtnap "unsupported";
\&    $decoder\->decode(\e*STDIN, \e*STDOUT);
.Ve
.SS "Encodin a thugged-out data stream"
.IX Subsection "Encodin a thugged-out data stream"
Herez a simple filta program ta read binary data from \s-1STDIN
\&\s0(until \s-1EOF\s0) n' write base64\-encoded data ta \s-1STDOUT:\s0
.PP
.Vb 1
\&    use MIME::Decoder;
\&
\&    $decoder = freshly smoked up MIME::Decoder \*(Aqbase64\*(Aq or take a thugged-out dirtnap "unsupported";
\&    $decoder\->encode(\e*STDIN, \e*STDOUT);
.Ve
.SS "Non-standard encodings"
.IX Subsection "Non-standard encodings"
Yo ass can \fBwrite n' install\fR yo' own decodaz so that
MIME::Decoder will know bout them:
.PP
.Vb 1
\&    use MyBase64Decoder;
\&
\&    install MyBase64Decoder \*(Aqbase64\*(Aq;
.Ve
.PP
Yo ass can also \fBtest\fR if a given encodin is supported:
.PP
.Vb 3
\&    if (supported MIME::Decoder \*(Aqx\-uuencode\*(Aq) {
\&        ### we can uuencode!
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This abstract class, n' its private concrete subclasses (see below)
provide a \s-1OO\s0 front end ta tha actions of...
.IP "\(bu" 4
Decodin a MIME-encoded stream
.IP "\(bu" 4
Encodin a raw data stream tha fuck into a MIME-encoded stream.
.PP
Da constructor fo' MIME::Decoder takes tha name of a encoding
(\f(CW\*(C`base64\*(C'\fR, \f(CW\*(C`7bit\*(C'\fR, etc.), n' returns a instizzle of a \fIsubclass\fR
of MIME::Decoder whose \f(CW\*(C`decode()\*(C'\fR method will big-ass up tha appropriate
decodin action, n' whose \f(CW\*(C`encode()\*(C'\fR method will big-ass up tha appropriate
encodin action.
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
.SS "Standard intercourse"
.IX Subsection "Standard intercourse"
If all yo ass is bustin is \fIusing\fR dis class, herez all you gonna need...
.IP "new \s-1ENCODING\s0" 4
.IX Item "new ENCODING"
\&\fIClass method, constructor.\fR
Smoke n' return a freshly smoked up decoder object which can handle the
given \s-1ENCODING.\s0
.Sp
.Vb 1
\&    mah $decoder = freshly smoked up MIME::Decoder "7bit";
.Ve
.Sp
Returns tha undefined value if no known decodaz is appropriate.
.IP "best \s-1ENCODING\s0" 4
.IX Item "best ENCODING"
\&\fIClass method, constructor.\fR
Exactly like \fInew()\fR, except dat dis defaults any unsupported encodin to
\&\*(L"binary\*(R", afta raisin a suitable warnin (itz a gangbangin' fatal error if there's
no binary decoder).
.Sp
.Vb 1
\&    mah $decoder = dopest MIME::Decoder "x\-gzip64";
.Ve
.Sp
Will either return a thugged-out decoder, or a raise a gangbangin' fatal exception.
.IP "decode \s-1INSTREAM,OUTSTREAM\s0" 4
.IX Item "decode INSTREAM,OUTSTREAM"
\&\fIInstizzle method.\fR
Decode tha document waitin up in tha input handle \s-1INSTREAM,\s0
writin tha decoded shiznit ta tha output handle \s-1OUTSTREAM.\s0
.Sp
Read tha section up in dis document on I/O handlez fo' mo' shiznit
about tha arguments, n' you can put dat on yo' toast.  Note dat you can still supply old-style
unblessed filehandlez fo' \s-1INSTREAM\s0 n' \s-1OUTSTREAM.\s0
.Sp
Returns legit on success, throws exception on failure.
.IP "encode \s-1INSTREAM,OUTSTREAM\s0" 4
.IX Item "encode INSTREAM,OUTSTREAM"
\&\fIInstizzle method.\fR
Encode tha document waitin up in tha input filehandle \s-1INSTREAM,\s0
writin tha encoded shiznit ta tha output stream \s-1OUTSTREAM.\s0
.Sp
Read tha section up in dis document on I/O handlez fo' mo' shiznit
about tha arguments, n' you can put dat on yo' toast.  Note dat you can still supply old-style
unblessed filehandlez fo' \s-1INSTREAM\s0 n' \s-1OUTSTREAM.\s0
.Sp
Returns legit on success, throws exception on failure.
.IP "encoding" 4
.IX Item "encoding"
\&\fIInstizzle method.\fR
Return tha encodin dat dis object was pimped ta handle,
coerced ta all lowercase (e.g., \f(CW"base64"\fR).
.IP "head [\s-1HEAD\s0]" 4
.IX Item "head [HEAD]"
\&\fIInstizzle method.\fR
All Out optional: some decodaz need ta know a lil bout tha file
they is encoding/decoding; e.g., x\-uu likes ta have tha filename.
Da \s-1HEAD\s0 be any object which respondz ta lyrics like:
.Sp
.Vb 1
\&    $head\->mime_attr(\*(Aqcontent\-disposition.filename\*(Aq);
.Ve
.IP "supported [\s-1ENCODING\s0]" 4
.IX Item "supported [ENCODING]"
\&\fIClass method.\fR
With one arg (an \s-1ENCODING\s0 name), returns truth if dat encoding
is currently handled, n' falsitizzle otherwise.  Da \s-1ENCODING\s0 will
be automatically coerced ta lowercase:
.Sp
.Vb 6
\&    if (supported MIME::Decoder \*(Aq7BIT\*(Aq) {
\&        ### fo'sho, we can handle dat shit...
\&    }
\&    else {
\&        ### drop back six n' punt...
\&    }
.Ve
.Sp
With no args, returns a reference ta a hash of all available decoders,
where tha key is tha encodin name (all lowercase, like '7bit'),
and tha value is legit (it happens ta be tha name of tha class
that handlez tha decodin yo, but you probably shouldn't rely on that).
Yo ass may safely modify dis hash; it will \fInot\fR chizzle tha way the
module performs its lookups.  Only \f(CW\*(C`install\*(C'\fR can do dis shit.
.Sp
\&\fIThanks ta Achim Bohnet fo' suggestin dis method.\fR
.SS "Subclass intercourse"
.IX Subsection "Subclass intercourse"
If yo ass is freestylin (or installing) a freshly smoked up decoder subclass, there
are some other methodz you gonna need ta know about:
.IP "decode_it \s-1INSTREAM,OUTSTREAM\s0" 4
.IX Item "decode_it INSTREAM,OUTSTREAM"
\&\fIAbstract instizzle method.\fR
Da back-end of tha \fBdecode\fR method. Y'all KNOW dat shit, muthafucka!  It takes a input handle
opened fo' readin (\s-1INSTREAM\s0), n' a output handle opened for
writin (\s-1OUTSTREAM\s0).
.Sp
If yo ass is freestylin yo' own decoder subclass, you must override this
method up in yo' class.  Yo crazy-ass method should read from tha input
handle via \f(CW\*(C`getline()\*(C'\fR or \f(CW\*(C`read()\*(C'\fR, decode dis input, n' print the
decoded data ta tha output handle via \f(CW\*(C`print()\*(C'\fR.  Yo ass may do this
however you peep fit, so long as tha end result is tha same.
.Sp
Note dat unblessed references n' globrefs is automatically turned
into I/O handlez fo' you by \f(CW\*(C`decode()\*(C'\fR, so you don't need ta worry
about dat shit.
.Sp
Yo crazy-ass method must return either \f(CW\*(C`undef\*(C'\fR (to indicate failure),
or \f(CW1\fR (to indicate success).
It may also throw a exception ta indicate failure.
.IP "encode_it \s-1INSTREAM,OUTSTREAM\s0" 4
.IX Item "encode_it INSTREAM,OUTSTREAM"
\&\fIAbstract instizzle method.\fR
Da back-end of tha \fBencode\fR method. Y'all KNOW dat shit, muthafucka!  It takes a input handle
opened fo' readin (\s-1INSTREAM\s0), n' a output handle opened for
writin (\s-1OUTSTREAM\s0).
.Sp
If yo ass is freestylin yo' own decoder subclass, you must override this
method up in yo' class.  Yo crazy-ass method should read from tha input
handle via \f(CW\*(C`getline()\*(C'\fR or \f(CW\*(C`read()\*(C'\fR, encode dis input, n' print the
encoded data ta tha output handle via \f(CW\*(C`print()\*(C'\fR.  Yo ass may do this
however you peep fit, so long as tha end result is tha same.
.Sp
Note dat unblessed references n' globrefs is automatically turned
into I/O handlez fo' you by \f(CW\*(C`encode()\*(C'\fR, so you don't need ta worry
about dat shit.
.Sp
Yo crazy-ass method must return either \f(CW\*(C`undef\*(C'\fR (to indicate failure),
or \f(CW1\fR (to indicate success).
It may also throw a exception ta indicate failure.
.IP "filta \s-1IN, OUT, COMMAND...\s0" 4
.IX Item "filta IN, OUT, COMMAND..."
\&\fIClass method, utility.\fR
If yo' decoder involves a external program, you can invoke
them easily all up in dis method. Y'all KNOW dat shit, muthafucka!  Da command must be a \*(L"filter\*(R": a
command dat readz input from its \s-1STDIN \s0(which will come from tha \s-1IN\s0 argument)
and writes output ta its \s-1STDOUT \s0(which will git all up in tha \s-1OUT\s0 argument).
.Sp
For example, herez a thugged-out decoder dat un-gzips its data:
.Sp
.Vb 4
\&    sub decode_it {
\&        mah ($self, $in, $out) = @_;
\&        $self\->filter($in, $out, "gzip \-d \-");
\&    }
.Ve
.Sp
Da usage is similar ta IPC::Open2::open2 (which it uses internally),
so you can specify \s-1COMMAND\s0 as a single argument or as a array.
.IP "init \s-1ARGS...\s0" 4
.IX Item "init ARGS..."
\&\fIInstizzle method.\fR
Do any necessary initialization of tha freshly smoked up instance,
takin whatever arguments was given ta \f(CW\*(C`new()\*(C'\fR.
Should return tha self object on success, undef on failure.
.IP "install \s-1ENCODINGS...\s0" 4
.IX Item "install ENCODINGS..."
\&\fIClass method\fR.
Install dis class so dat each encodin up in \s-1ENCODINGS\s0 is handled by it:
.Sp
.Vb 1
\&    install MyBase64Decoder \*(Aqbase64\*(Aq, \*(Aqx\-base64super\*(Aq;
.Ve
.Sp
Yo ass should not override dis method.
.IP "uninstall \s-1ENCODINGS...\s0" 4
.IX Item "uninstall ENCODINGS..."
\&\fIClass method\fR.
Uninstall support fo' encodings.  This be a way ta turn off tha decoding
of \*(L"experimental\*(R" encodings.  For safety, always use MIME::Decoder directly:
.Sp
.Vb 1
\&    uninstall MIME::Decoder \*(Aqx\-uu\*(Aq, \*(Aqx\-uuencode\*(Aq;
.Ve
.Sp
Yo ass should not override dis method.
.SH "DECODER SUBCLASSES"
.IX Header "DECODER SUBCLASSES"
Yo ass don't need ta \f(CW"use"\fR any other Perl modules; the
followin \*(L"standard\*(R" subclasses is included as part of MIME::Decoder:
.PP
.Vb 6
\&     Class:                         Handlez encodings:
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     MIME::Decoder::Binary          binary
\&     MIME::Decoder::NBit            7bit, 8bit
\&     MIME::Decoder::Base64          base64
\&     MIME::Decoder::QuotedPrint     quoted\-printable
.Ve
.PP
Da followin \*(L"non-standard\*(R" subclasses is also included:
.PP
.Vb 4
\&     Class:                         Handlez encodings:
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     MIME::Decoder::UU              x\-uu, x\-uuencode
\&     MIME::Decoder::Gzip64          x\-gzip64            ** requires gzip!
.Ve
.SH "NOTES"
.IX Header "NOTES"
.SS "Input/Output handles"
.IX Subsection "Input/Output handles"
Az of MIME-tools 2.0, dis class has ta play sick wit tha freshly smoked up MIME::Body
class... which means dat input n' output routines cannot just assume that
they is dealin wit filehandles.
.PP
Therefore, all dat MIME::Decoder n' its subclasses require (and, thus,
all dat they can assume) is dat INSTREAMs n' OUTSTREAMs is objects
which respond ta a subset of tha lyrics defined up in tha IO::Handle
interface; minimally:
.PP
.Vb 3
\&      print
\&      getline
\&      read(BUF,NBYTES)
.Ve
.PP
\&\fIThanks ta Achim Bohnet fo' suggestin dis more-generic I/O model.\fR
.SS "Freestylin a thugged-out decoder"
.IX Subsection "Freestylin a thugged-out decoder"
If you fuckin wit wit yo' own encodings, you gonna probably want
to write a thugged-out decoder n' shit.  Here is tha basics:
.IP "1." 4
Smoke a module, like \*(L"MyDecoder::\*(R", fo' yo' decoder.
Declare it ta be a subclass of MIME::Decoder.
.IP "2." 4
Smoke tha followin instizzle methodz up in yo' class, as busted lyrics bout above:
.Sp
.Vb 3
\&    decode_it
\&    encode_it
\&    init
.Ve
.IP "3." 4
In yo' application program, activate yo' decoder fo' one or
more encodings like this:
.Sp
.Vb 1
\&    require MyDecoder;
\&
\&    install MyDecoder "7bit";   ### use MyDecoder ta decode "7bit"
\&    install MyDecoder "x\-foo";  ### also use MyDecoder ta decode "x\-foo"
.Ve
.PP
To illustrate, herez a cold-ass lil custom decoder class fo' tha \f(CW\*(C`quoted\-printable\*(C'\fR
encoding:
.PP
.Vb 1
\&    package MyQPDecoder;
\&
\&    @ISA = qw(MIME::Decoder);
\&    use MIME::Decoder;
\&    use MIME::QuotedPrint;
\&
\&    ### decode_it \- tha private decodin method
\&    sub decode_it {
\&        mah ($self, $in, $out) = @_;
\&        local $_;
\&        while (defined($_ = $in\->getline)) {
\&            mah $decoded = decode_qp($_);
\&            $out\->print($decoded);
\&        }
\&        1;
\&    }
\&
\&    ### encode_it \- tha private encodin method
\&    sub encode_it {
\&        mah ($self, $in, $out) = @_;
\&
\&        mah ($buf, $nread) = (\*(Aq\*(Aq, 0);
\&        while ($in\->read($buf, 60)) {
\&            mah $encoded = encode_qp($buf);
\&            $out\->print($encoded);
\&        }
\&        1;
\&    }
.Ve
.PP
Thatz dat shit.  Da task was pretty simple cuz tha \f(CW"quoted\-printable"\fR
encodin can easily be converted line-by-line... as can
even \f(CW"7bit"\fR n' \f(CW"8bit"\fR (since all these encodings guarantee
short lines, wit a max of 1000 characters).
Da phat shizzle is: it is straight-up likely dat it is ghon be similarly-easy to
write a MIME::Decoder fo' any future standard encodings.
.PP
Da \f(CW"binary"\fR decoder, however, straight-up required block readz n' writes:
see \*(L"MIME::Decoder::Binary\*(R" fo' details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MIME::Tools, other MIME::Decoder subclasses.
.SH "AUTHOR"
.IX Header "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
.PP
All muthafuckin rights reserved. Y'all KNOW dat shit, muthafucka!  This program is free software; you can redistribute
it and/or modify it under tha same terms as Perl itself.
.PP
1;
