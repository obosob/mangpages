.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Header 3"
.TH Mail::Header 3 "2012-12-21" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Header \- manipulate MIME headers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Mail::Header;
\&    
\& mah $head = Mail::Header\->new;
\& mah $head = Mail::Header\->new( \e*STDIN );
\& mah $head = Mail::Header\->new( [<>], Modify => 0);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Read, write, create, n' manipulate \s-1MIME\s0 headers, tha leadin part
of each modern e\-mail message yo, but also used up in other protocols
like \s-1HTTP. \s0 Da fieldz is kept up in Mail::Field objects.
.PP
Be aware dat tha header fieldz each gotz a name part, which shall
be treated case-insensitive, n' a cold-ass lil content part, which may be folded
over multiple lines.
.PP
Mail::Header do not always follow tha RFCs strict enough, do not
help you wit characta encodings.  It do not use weak references
where it could (because dem did not exist when tha module was written)
which costs some performizzle n' make tha implementation a lil more
fucked up. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da Mail::Message::Head implementation is much newer
and therefore better.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBdup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdup\fR()" 4
.IX Item "$obj->dup()"
Smoke a thugged-out duplicate of tha current object.
.ie n .IP "$obj\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "$obj->new([ARG], [OPTIONS])"
.PD 0
.IP "Mail::Header\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "Mail::Header->new([ARG], [OPTIONS])"
.PD
\&\s-1ARG\s0 may be either a gangbangin' file descriptor (reference ta a \s-1GLOB\s0)
or a reference ta a array. If given tha freshly smoked up object will be
initialized wit headaz either from tha array of read from 
the file descriptor.
.Sp
\&\s-1OPTIONS\s0 be a list of options given up in tha form of key-value
pairs, just like a hash table. Valid options are
.Sp
.Vb 4
\& \-Option    \-\-Default
\&  FoldLength  79
\&  MailFrom    \*(AqKEEP\*(Aq
\&  Modify      false
.Ve
.RS 4
.IP "FoldLength => \s-1INTEGER\s0" 2
.IX Item "FoldLength => INTEGER"
Da default length of line ta be used when foldin header lines.
See \fIfold_length()\fR.
.IP "MailFrom => '\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0'" 2
.IX Item "MailFrom => 'IGNORE'|'COERCE'|'KEEP'|'ERROR'"
See method \fImail_from()\fR.
.IP "Modify => \s-1BOOLEAN\s0" 2
.IX Item "Modify => BOOLEAN"
If dis value is \fItrue\fR then tha headaz is ghon be re-formatted,
otherwise tha format of tha header lines will remain unchanged.
.RE
.RS 4
.RE
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
Be warned dat tha next constructors all require a already pimped
header object, of which tha original gangsta content is ghon be destroyed.
.ie n .IP "$obj\->\fBempty\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBempty\fR()" 4
.IX Item "$obj->empty()"
Empty a existin \f(CW\*(C`Mail::Header\*(C'\fR object of all lines.
.ie n .IP "$obj\->\fBextract\fR(\s-1ARRAY\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBextract\fR(\s-1ARRAY\s0)" 4
.IX Item "$obj->extract(ARRAY)"
Extract a header from tha given array tha fuck into a existin Mail::Header
object. \f(CW\*(C`extract\*(C'\fR \fBwill modify\fR dis array.
Returns tha object dat tha method was called on.
.ie n .IP "$obj\->\fBheader\fR([\s-1ARRAY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBheader\fR([\s-1ARRAY\s0])" 4
.IX Item "$obj->header([ARRAY])"
\&\f(CW\*(C`header\*(C'\fR do multiple operations. First it will extract a header from
the \s-1ARRAY,\s0 if given. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it will then reformat tha header (if reformatting
is permitted), n' finally return a reference ta a array which
gotz nuff tha header up in a printable form.
.ie n .IP "$obj\->\fBheader_hashref\fR([\s-1HASH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBheader_hashref\fR([\s-1HASH\s0])" 4
.IX Item "$obj->header_hashref([HASH])"
As \fIheader()\fR yo, but it will eventually set headaz from a hash
reference, n' it will return tha headaz as a hash reference.
.Sp
example:
.Sp
.Vb 3
\& $fields\->{From} = \*(AqTobias Brox <tobix@cpan.org>\*(Aq;
\& $fields\->{To}   = [\*(Aqyou@somewhere\*(Aq, \*(Aqme@localhost\*(Aq];
\& $head\->header_hashref($fields);
.Ve
.ie n .IP "$obj\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.IX Item "$obj->read(FILEHANDLE)"
Read a header from tha given file descriptor tha fuck into a existin Mail::Header
object.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.IX Item "$obj->fold_length([TAG], [LENGTH])"
Set tha default fold length fo' all tags or just one. With no arguments
the default fold length is returned. Y'all KNOW dat shit, muthafucka! With two arguments it sets tha fold
length fo' tha given tag n' returns tha previous value. If only \f(CW\*(C`LENGTH\*(C'\fR
is given it sets tha default fold length fo' tha current object.
.Sp
In tha two argument form \f(CW\*(C`fold_length\*(C'\fR may be called as a static method,
settin default fold lengths fo' tags dat is ghon be used by \fBall\fR
\&\f(CW\*(C`Mail::Header\*(C'\fR objects, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See tha \f(CW\*(C`fold\*(C'\fR method for
a description on how tha fuck \f(CW\*(C`Mail::Header\*(C'\fR uses these joints.
.ie n .IP "$obj\->\fBmail_from\fR('\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0')" 4
.el .IP "\f(CW$obj\fR\->\fBmail_from\fR('\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0')" 4
.IX Item "$obj->mail_from('IGNORE'|'COERCE'|'KEEP'|'ERROR')"
This specifies what tha fuck ta do when a \f(CW\`From \*(Aq\fR line is encountered.
Valid joints is \f(CW\*(C`IGNORE\*(C'\fR \- ignore n' discard tha header,
\&\f(CW\*(C`ERROR\*(C'\fR \- invoke a error (call die), \f(CW\*(C`COERCE\*(C'\fR \- rename dem as Mail-From
and \f(CW\*(C`KEEP\*(C'\fR \- keep em.
.ie n .IP "$obj\->\fBmodify\fR([\s-1VALUE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmodify\fR([\s-1VALUE\s0])" 4
.IX Item "$obj->modify([VALUE])"
If \f(CW\*(C`VALUE\*(C'\fR is \fIfalse\fR then \f(CW\*(C`Mail::Header\*(C'\fR aint gonna do any automatic
reformattin of tha headers, other than ta ensure dat tha line
starts wit tha tags given.
.SS "Processing"
.IX Subsection "Processing"
.ie n .IP "$obj\->\fBadd\fR(\s-1TAG, LINE\s0 [, \s-1INDEX\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(\s-1TAG, LINE\s0 [, \s-1INDEX\s0])" 4
.IX Item "$obj->add(TAG, LINE [, INDEX])"
Add a freshly smoked up line ta tha header n' shit. If \s-1TAG\s0 is \f(CW\*(C`undef\*(C'\fR tha the tag will be
extracted from tha beginnin of tha given line. If \s-1INDEX\s0 is given,
the freshly smoked up line is ghon be banged tha fuck into tha header all up in tha given point, otherwise
the freshly smoked up line is ghon be appended ta tha end of tha header.
.ie n .IP "$obj\->\fBas_string\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBas_string\fR()" 4
.IX Item "$obj->as_string()"
Returns tha header as a single string.
.ie n .IP "$obj\->\fBcleanup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcleanup\fR()" 4
.IX Item "$obj->cleanup()"
Remove any header line that, other than tha tag, only gotz nuff whitespace
.ie n .IP "$obj\->\fBcombine\fR(\s-1TAG\s0 [, \s-1WITH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBcombine\fR(\s-1TAG\s0 [, \s-1WITH\s0])" 4
.IX Item "$obj->combine(TAG [, WITH])"
Combine all instancez of \s-1TAG\s0 tha fuck into one. Da lines will be
joined together \s-1WITH,\s0 or a single space if not given. I aint talkin' bout chicken n' gravy biatch. Da new
item is ghon be positioned up in tha header where tha straight-up original gangsta instizzle was, all
other instancez of \s-1TAG\s0 is ghon be removed.
.ie n .IP "$obj\->\fBcount\fR(\s-1TAG\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcount\fR(\s-1TAG\s0)" 4
.IX Item "$obj->count(TAG)"
Returns tha number of times tha given atg appears up in tha header
.ie n .IP "$obj\->\fBdelete\fR(\s-1TAG\s0 [, \s-1INDEX \s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1TAG\s0 [, \s-1INDEX \s0])" 4
.IX Item "$obj->delete(TAG [, INDEX ])"
Delete a tag from tha header n' shit. If a \s-1INDEX\s0 id is given, then tha Nth instance
of tha tag is ghon be removed. Y'all KNOW dat shit, muthafucka! If no \s-1INDEX\s0 is given, then all instances
of tag is ghon be removed.
.ie n .IP "$obj\->\fBfold\fR([\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold\fR([\s-1LENGTH\s0])" 4
.IX Item "$obj->fold([LENGTH])"
Fold tha header n' shit. If \s-1LENGTH\s0 aint given, then \f(CW\*(C`Mail::Header\*(C'\fR uses the
followin rulez ta determine what tha fuck length ta fold a line.
.ie n .IP "$obj\->\fBget\fR(\s-1TAG\s0 [, \s-1INDEX\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR(\s-1TAG\s0 [, \s-1INDEX\s0])" 4
.IX Item "$obj->get(TAG [, INDEX])"
Git tha text from a line. If a \s-1INDEX\s0 is given, then tha text of tha Nth
instizzle is ghon be returned. Y'all KNOW dat shit, muthafucka! If it aint given tha return value dependz on the
context up in which \f(CW\*(C`get\*(C'\fR was called. Y'all KNOW dat shit, muthafucka! In a array context a list of all the
text from all tha instancez of tha \s-1TAG\s0 is ghon be returned. Y'all KNOW dat shit, muthafucka! In a scalar context
the text fo' tha straight-up original gangsta instizzle is ghon be returned.
.Sp
Da lines is unfolded yo, but still terminated wit a new-line (see \f(CW\*(C`chomp\*(C'\fR)
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
Print tha header ta tha given file descriptor, or \f(CW\*(C`STDOUT\*(C'\fR if no
file descriptor is given.
.ie n .IP "$obj\->\fBreplace\fR(\s-1TAG, LINE\s0 [, \s-1INDEX \s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreplace\fR(\s-1TAG, LINE\s0 [, \s-1INDEX \s0])" 4
.IX Item "$obj->replace(TAG, LINE [, INDEX ])"
Replace a line up in tha header n' shit.  If \s-1TAG\s0 is \f(CW\*(C`undef\*(C'\fR tha the tag will be
extracted from tha beginnin of tha given line. If \s-1INDEX\s0 is given
the freshly smoked up line will replace tha Nth instizzle of dat tag, otherwise the
first instizzle of tha tag is replaced. Y'all KNOW dat shit, muthafucka! If tha tag do not step tha fuck up in the
header then a freshly smoked up line is ghon be appended ta tha header.
.ie n .IP "$obj\->\fBtags\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtags\fR()" 4
.IX Item "$obj->tags()"
Returns a array of all tha tags dat exist up in tha header n' shit. Each tag will
only step tha fuck up in tha list once. Da order of tha tags aint specified.
.ie n .IP "$obj\->\fBunfold\fR([\s-1TAG\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBunfold\fR([\s-1TAG\s0])" 4
.IX Item "$obj->unfold([TAG])"
Unfold all instancez of tha given tag so dat they do not spread across
multiple lines. If \f(CW\*(C`TAG\*(C'\fR aint given then all lines is unfolded.
.Sp
Da unfoldin process is wack but (for compatibilitizzle reasons) will
not be repaired: only one blank all up in tha start of tha line should be
removed, not all of em.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of tha MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
Da MailTools bundle was pimped by Graham Barr. Shiiit, dis aint no joke.  Later, Mark
Overmeer took over maintenizzle without commitment ta further pimpment.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peta Orbaek <poe@cit.dk>.
Mail::Maila n' Mail::Send by Slim Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors peep ChizzleLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
