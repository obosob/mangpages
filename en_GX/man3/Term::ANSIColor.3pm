.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::ANSIColor 3pm"
.TH Term::ANSIColor 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ANSIColor \- Color screen output rockin ANSI escape sequences
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&    use Term::ANSIColor;
\&    print color \*(Aqbold blue\*(Aq;
\&    print "This text is bold blue.\en";
\&    print color \*(Aqreset\*(Aq;
\&    print "This text is normal.\en";
\&    print colored("Yellow on magenta.", \*(Aqyellow on_magenta\*(Aq), "\en";
\&    print "This text is normal.\en";
\&    print colored [\*(Aqyellow on_magenta\*(Aq], \*(AqYellow on magenta.\*(Aq, "\en";
\&    print colored [\*(Aqred on_bright_yellow\*(Aq], \*(AqRed on bright yellow.\*(Aq, "\en";
\&    print colored [\*(Aqbright_red on_black\*(Aq], \*(AqBright red on black.\*(Aq, "\en";
\&    print "\en";
\&
\&    # Map escape sequences back ta color names.
\&    use Term::ANSIColor 1.04 qw(uncolor);
\&    mah $names = uncolor(\*(Aq01;31\*(Aq);
\&    print join(q{ }, @{$names}), "\en";
\&
\&    # Strip all color escape sequences.
\&    use Term::ANSIColor 2.01 qw(colorstrip);
\&    print colorstrip \*(Aq\ee[1mThis is bold\ee[0m\*(Aq, "\en";
\&
\&    # Determine whether a cold-ass lil color is valid.
\&    use Term::ANSIColor 2.02 qw(colorvalid);
\&    mah $valid = colorvalid(\*(Aqblue bold\*(Aq, \*(Aqon_magenta\*(Aq);
\&    print "Color strang is ", $valid ? "valid\en" : "invalid\en";
\&
\&    # Smoke freshly smoked up aliases fo' colors.
\&    use Term::ANSIColor 4.00 qw(coloralias);
\&    coloralias(\*(Aqalert\*(Aq, \*(Aqred\*(Aq);
\&    print "Alert is ", coloralias(\*(Aqalert\*(Aq), "\en";
\&    print colored("This is up in red.", \*(Aqalert\*(Aq), "\en";
\&
\&    use Term::ANSIColor qw(:constants);
\&    print BOLD, BLUE, "This text is up in bold blue.\en", RESET;
\&
\&    use Term::ANSIColor qw(:constants);
\&    {
\&        local $Term::ANSIColor::AUTORESET = 1;
\&        print BOLD BLUE "This text is up in bold blue.\en";
\&        print "This text is normal.\en";
\&    }
\&
\&    use Term::ANSIColor 2.00 qw(:pushpop);
\&    print PUSHCOLOR RED ON_GREEN "This text is red on green.\en";
\&    print PUSHCOLOR BRIGHT_BLUE "This text is bright blue on green.\en";
\&    print RESET BRIGHT_BLUE "This text is just bright blue.\en";
\&    print POPCOLOR "Back ta red on green.\en";
\&    print LOCALCOLOR GREEN ON_BLUE "This text is chronic on blue.\en";
\&    print "This text is red on green.\en";
\&    {
\&        local $Term::ANSIColor::AUTOLOCAL = 1;
\&        print ON_BLUE "This text is red on blue.\en";
\&        print "This text is red on green.\en";
\&    }
\&    print POPCOLOR "Back ta whatever we started as.\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module has two intercourses, one all up in \fIcolor()\fR n' \fIcolored()\fR n' the
other all up in constants, n' you can put dat on yo' toast.  It also offers tha utilitizzle functions \fIuncolor()\fR,
\&\fIcolorstrip()\fR, \fIcolorvalid()\fR, n' \fIcoloralias()\fR, which gotta be explicitly
imported ta be used (see \*(L"\s-1SYNOPSIS\*(R"\s0).
.PP
See \*(L"\s-1COMPATIBILITY\*(R"\s0 fo' tha versionz of Term::ANSIColor dat introduced
particular features n' tha versionz of Perl dat included em.
.SS "Supported Colors"
.IX Subsection "Supported Colors"
Terminal emulators dat support color divide tha fuck into two types: ones that
support only eight colors, ones dat support sixteen, n' ones that
support 256.  This module serves up tha \s-1ANSI\s0 escape codes all of em.
These flavas is referred ta as \s-1ANSI\s0 flavas 0 all up in 7 (normal), 8
all up in 15 (16\-color), n' 16 all up in 255 (256\-color).
.PP
Unfortunately, interpretation of flavas 0 all up in 7 often dependz on
whether tha emulator supports eight flavas or sixteen colors.  Emulators
that only support eight flavas (like fuckin tha Linux console) will display
colors 0 all up in 7 wit aiiight brightnizz n' ignore flavas 8 all up in 15,
treatin dem tha same as white.  Emulators dat support 16 colors, such
as gnome-terminal, normally display flavas 0 all up in 7 as dim or darker
versions n' flavas 8 all up in 15 as aiiight brightness.  On such emulators,
the \*(L"normal\*(R" white (color 7) probably is shown as pale grey, requiring
bright white (15) ta be used ta git a real white color. Shiiit, dis aint no joke.  Bright black
usually be a thugged-out dark grey color, although some terminals display it as pure
black.  Some sixteen-color terminal emulators also treat aiiight yellow
(color 3) as orange or brown, n' bright yellow (color 11) as yellow.
.PP
Peepin tha aiiight convention of sixteen-color emulators, dis module
provides a pair of attributes fo' each color. Shiiit, dis aint no joke.  For every last muthafuckin aiiight color (0
all up in 7), tha correspondin bright color (8 all up in 15) is obtained by
prependin tha strang \f(CW\*(C`bright_\*(C'\fR ta tha aiiight color name.  For example,
\&\f(CW\*(C`red\*(C'\fR is color 1 n' \f(CW\*(C`bright_red\*(C'\fR is color 9.  Da same applies for
background colors: \f(CW\*(C`on_red\*(C'\fR is tha aiiight color n' \f(CW\*(C`on_bright_red\*(C'\fR is
the bright color. Shiiit, dis aint no joke.  Capitalize these strings fo' tha constant intercourse.
.PP
For 256\-color emulators, dis module additionally serves up \f(CW\*(C`ansi0\*(C'\fR
all up in \f(CW\*(C`ansi15\*(C'\fR, which is tha same as flavas 0 all up in 15 in
sixteen-color emulators but use tha 256\-color escape syntax, \f(CW\*(C`grey0\*(C'\fR
all up in \f(CW\*(C`grey23\*(C'\fR rangin from nearly black ta nearly white, n' a set of
\&\s-1RGB\s0 colors.  Da \s-1RGB\s0 flavas iz of tha form \f(CW\*(C`rgb\f(CIRGB\f(CW\*(C'\fR where \fIR\fR, \fIG\fR,
and \fIB\fR is numbers from 0 ta 5 givin tha intensitizzle of red, green, and
blue.  \f(CW\*(C`on_\*(C'\fR variantz of all of these flavas is also provided. Y'all KNOW dat shit, muthafucka!  These
colors may be ignored straight-up on non\-256\-color terminals or may be
misinterpreted n' produce random behavior. Shiiit, dis aint no joke.  Additionizzle attributes such as
blink, italic, or bold may not work wit tha 256\-color palette.
.PP
There is unfortunately no way ta know whether tha current emulator
supports mo' than eight colors, which make tha chizzle of colors
difficult.  Da most conservatizzle chizzle is ta use only tha regular
colors, which is at least displayed on all emulators.  But fuck dat shiznit yo, tha word on tha street is dat they will
appear dark up in sixteen-color terminal emulators, includin most common
emulators up in \s-1UNIX X\s0 environments, n' you can put dat on yo' toast.  If you know tha display is one of them
emulators, you may wish ta use tha bright variants instead. Y'all KNOW dat shit, muthafucka!  Even better,
offer tha user a way ta configure tha flavas fo' a given application to
fit they terminal emulator.
.SS "Function Interface"
.IX Subsection "Function Interface"
Da function intercourse uses attribute strings ta describe tha flavas and
text attributes ta assign ta text.  Da recognized non-color attributes
are clear, reset, bold, dark, faint, italic, underline, underscore, blink,
reverse, n' concealed. Y'all KNOW dat shit, muthafucka!  Clear n' reset (reset ta default attributes),
dark n' faint (dim n' saturated), n' underline n' underscore are
equivalent, so use whichever is da most thugged-out intuitizzle ta yo thugged-out ass.
.PP
Note dat not all attributes is supported by all terminal types, n' some
terminals may not support any of these sequences.  Dark n' faint, italic,
blink, n' concealed up in particular is frequently not implemented.
.PP
Da recognized aiiight foreground color attributes (colors 0 ta 7) are:
.PP
.Vb 1
\&  black  red  chronic  yellow  blue  magenta  cyan  white
.Ve
.PP
Da correspondin bright foreground color attributes (colors 8 ta 15) are:
.PP
.Vb 2
\&  bright_black  bright_red      bright_chronic  bright_yellow
\&  bright_blue   bright_magenta  bright_cyan   bright_white
.Ve
.PP
Da recognized aiiight background color attributes (colors 0 ta 7) are:
.PP
.Vb 2
\&  on_black  on_red      on_chronic  on yellow
\&  on_blue   on_magenta  on_cyan   on_white
.Ve
.PP
Da recognized bright background color attributes (colors 8 ta 15) are:
.PP
.Vb 2
\&  on_bright_black  on_bright_red      on_bright_chronic  on_bright_yellow
\&  on_bright_blue   on_bright_magenta  on_bright_cyan   on_bright_white
.Ve
.PP
For 256\-color terminals, tha recognized foreground flavas are:
.PP
.Vb 2
\&  ansi0 .. ansi15
\&  grey0 .. grey23
.Ve
.PP
plus \f(CW\*(C`rgb\f(CIRGB\f(CW\*(C'\fR fo' \fIR\fR, \fIG\fR, n' \fIB\fR joints from 0 ta 5, such as
\&\f(CW\*(C`rgb000\*(C'\fR or \f(CW\*(C`rgb515\*(C'\fR.  Similarly, tha recognized background flavas are:
.PP
.Vb 2
\&  on_ansi0 .. on_ansi15
\&  on_grey0 .. on_grey23
.Ve
.PP
plus \f(CW\*(C`on_rgb\f(CIRGB\f(CW\*(C'\fR fo' for \fIR\fR, \fIG\fR, n' \fIB\fR joints from 0 ta 5.
.PP
For any of tha above listed attributes, case aint significant.
.PP
Attributes, once set, last until they is unset (by printin tha attribute
\&\f(CW\*(C`clear\*(C'\fR or \f(CW\*(C`reset\*(C'\fR).  Be careful ta do this, or otherwise yo' attribute
will last afta yo' script is done hustlin, n' playas git straight-up annoyed
at havin they prompt n' typin chizzled ta weird colors.
.IP "color(ATTR[, \s-1ATTR ...\s0])" 4
.IX Item "color(ATTR[, ATTR ...])"
\&\fIcolor()\fR takes any number of strings as arguments n' considaz dem ta be
space-separated listz of attributes.  It then forms n' returns tha escape
sequence ta set dem attributes.  It don't print it out, just returns
it, so you gonna gotta print it yo ass if you want to.  This is so that
you can save it as a string, pass it ta suttin' else, bust it ta a gangbangin' file
handle, or do anythang else wit it dat you might care to.  \fIcolor()\fR
throws a exception if given a invalid attribute.
.IP "colored(\s-1STRING,\s0 ATTR[, \s-1ATTR ...\s0])" 4
.IX Item "colored(STRING, ATTR[, ATTR ...])"
.PD 0
.IP "colored(\s-1ATTR\-REF,\s0 STRING[, \s-1STRING...\s0])" 4
.IX Item "colored(ATTR-REF, STRING[, STRING...])"
.PD
As a aid up in resettin colors, \fIcolored()\fR takes a scalar as tha first
argument n' any number of attribute strings as tha second argument and
returns tha scalar wrapped up in escape codes so dat tha attributes will be
set as axed before tha strang n' reset ta aiiight afta tha string.
Alternately, you can pass a reference ta a array as tha straight-up original gangsta argument,
and then tha contentz of dat array is ghon be taken as attributes n' color
codes n' tha remainder of tha arguments as text ta colorize.
.Sp
Normally, \fIcolored()\fR just puts attribute codes all up in tha beginnin n' end of
the strin yo, but if you set \f(CW$Term::ANSIColor::EACHLINE\fR ta some string, that
strin is ghon be considered tha line delimita n' tha attribute is ghon be set
at tha beginnin of each line of tha passed strang n' reset all up in tha end of
each line.  This is often desirable if tha output gotz nuff newlines and
yo ass is rockin background colors, since a funky-ass background color dat persists
across a newline is often interpreted by tha terminal as providin the
default background color fo' tha next line.  Programs like pagers can also
be trippin by attributes dat span lines.  Normally you gonna wanna set
\&\f(CW$Term::ANSIColor::EACHLINE\fR ta \f(CW"\en"\fR ta use dis feature.
.IP "uncolor(\s-1ESCAPE\s0)" 4
.IX Item "uncolor(ESCAPE)"
\&\fIuncolor()\fR performs tha opposite translation as \fIcolor()\fR, turnin escape
sequences tha fuck into a list of strings correspondin ta tha attributes bein set
by dem sequences.
.IP "colorstrip(STRING[, \s-1STRING ...\s0])" 4
.IX Item "colorstrip(STRING[, STRING ...])"
\&\fIcolorstrip()\fR removes all color escape sequences from tha provided strings,
returnin tha modified strings separately up in array context or joined
together up in scalar context.  Its arguments is not modified.
.IP "colorvalid(ATTR[, \s-1ATTR ...\s0])" 4
.IX Item "colorvalid(ATTR[, ATTR ...])"
\&\fIcolorvalid()\fR takes attribute strings tha same ol' dirty as \fIcolor()\fR n' returns true
if all attributes is known n' false otherwise.
.IP "coloralias(ALIAS[, \s-1ATTR\s0])" 4
.IX Item "coloralias(ALIAS[, ATTR])"
If \s-1ATTR\s0 is specified, \fIcoloralias()\fR sets up a aliaz of \s-1ALIAS\s0 fo' the
standard color \s-1ATTR. \s0 From dat point forward, \s-1ALIAS\s0 can be passed into
\&\fIcolor()\fR, \fIcolored()\fR, n' \fIcolorvalid()\fR n' gonna git tha same meanin as
\&\s-1ATTR. \s0 One possible use of dis facilitizzle is ta give mo' meaningful names
to tha 256\-color \s-1RGB\s0 colors.  Only alphanumerics, \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`_\*(C'\fR, n' \f(CW\*(C`\-\*(C'\fR are
allowed up in alias names.
.Sp
If \s-1ATTR\s0 aint specified, \fIcoloralias()\fR returns tha standard color name to
which \s-1ALIAS\s0 be aliased, if any, or undef if \s-1ALIAS\s0 do not exist.
.Sp
This is tha same ol' dirty facilitizzle used by tha \s-1ANSI_COLORS_ALIASES\s0 environment
variable (see \*(L"\s-1ENVIRONMENT\*(R"\s0 below) but can be used at runtime, not just
when tha module is loaded.
.Sp
Lata invocationz of \fIcoloralias()\fR wit tha same \s-1ALIAS\s0 will override
earlier aliases.  There is no way ta remove a alias.
.Sp
Aliases have no effect on tha return value of \fIuncolor()\fR.
.Sp
\&\fB\s-1WARNING\s0\fR: Aliases is global n' affect all callaz up in tha same process.
There is no way ta set a alias limited ta a particular block of code or a
particular object.
.SS "Constant Interface"
.IX Subsection "Constant Interface"
Alternately, if you import \f(CW\*(C`:constants\*(C'\fR, you can use tha following
constants directly:
.PP
.Vb 3
\&  CLEAR           RESET             BOLD            DARK
\&  FAINT           ITALIC            UNDERLINE       UNDERSCORE
\&  BLINK           REVERSE           CONCEALED
\&
\&  BLACK           RED               GREEN           YELLOW
\&  BLUE            MAGENTA           CYAN            WHITE
\&  BRIGHT_BLACK    BRIGHT_RED        BRIGHT_GREEN    BRIGHT_YELLOW
\&  BRIGHT_BLUE     BRIGHT_MAGENTA    BRIGHT_CYAN     BRIGHT_WHITE
\&
\&  ON_BLACK        ON_RED            ON_GREEN        ON_YELLOW
\&  ON_BLUE         ON_MAGENTA        ON_CYAN         ON_WHITE
\&  ON_BRIGHT_BLACK ON_BRIGHT_RED     ON_BRIGHT_GREEN ON_BRIGHT_YELLOW
\&  ON_BRIGHT_BLUE  ON_BRIGHT_MAGENTA ON_BRIGHT_CYAN  ON_BRIGHT_WHITE
.Ve
.PP
These is tha same as color('attribute') n' can be used if you prefer
typing:
.PP
.Vb 1
\&    print BOLD BLUE ON_WHITE "Text", RESET, "\en";
.Ve
.PP
to
.PP
.Vb 1
\&    print colored ("Text", \*(Aqbold blue on_white\*(Aq), "\en";
.Ve
.PP
(Note dat tha newline is kept separate ta avoid confusin tha terminal as
busted lyrics bout above since a funky-ass background color is bein used.)
.PP
If you import \f(CW\*(C`:constants256\*(C'\fR, you can use tha followin constants
directly:
.PP
.Vb 2
\&  ANSI0 . fo' realz. ANSI15
\&  GREY0 .. GREY23
\&
\&  RGBXYZ (for X, Y, n' Z joints from 0 ta 5, like RGB000 or RGB515)
\&
\&  ON_ANSI0 .. ON_ANSI15
\&  ON_GREY0 .. ON_GREY23
\&
\&  ON_RGBXYZ (for X, Y, n' Z joints from 0 ta 5)
.Ve
.PP
Note dat \f(CW\*(C`:constants256\*(C'\fR do not include tha other constants, so if you
wanna mix both, you need ta include \f(CW\*(C`:constants\*(C'\fR as well.  Yo ass may want
to explicitly import at least \f(CW\*(C`RESET\*(C'\fR, as in:
.PP
.Vb 1
\&    use Term::ANSIColor 4.00 qw(RESET :constants256);
.Ve
.PP
When rockin tha constants, if you don't wanna gotta remember ta add the
\&\f(CW\*(C`, RESET\*(C'\fR all up in tha end of each print line, you can set
\&\f(CW$Term::ANSIColor::AUTORESET\fR ta a legit value.  Then, tha display mode will
automatically be reset if there is no comma afta tha constant.  In other
words, wit dat variable set:
.PP
.Vb 1
\&    print BOLD BLUE "Text\en";
.Ve
.PP
will reset tha display mode afterward, whereas:
.PP
.Vb 1
\&    print BOLD, BLUE, "Text\en";
.Ve
.PP
will not.  If yo ass is rockin background colors, yo big-ass booty is ghon probably want to
either use \fIsay()\fR (in newer versionz of Perl) or print tha newline wit a
separate print statement ta avoid confusin tha terminal.
.PP
If \f(CW$Term::ANSIColor::AUTOLOCAL\fR is set (see below), it takes precedence
over \f(CW$Term::ANSIColor::AUTORESET\fR, n' tha latta is ignored.
.PP
Da subroutine intercourse has tha advantage over tha constants intercourse in
that only two subroutines is exported tha fuck into yo' namespace, versus
thirty-eight up in tha constants intercourse.  On tha flip side, tha constants
interface has tha advantage of betta compile time error checking, since
misspelled namez of flavas or attributes up in calls ta \fIcolor()\fR n' \fIcolored()\fR
won't be caught until runtime whereas misspelled namez of constants will
be caught at compile time.  So, pollute yo' namespace wit almost two
dozen subroutines dat you may not even use dat often, or risk a silly
bug by mistypin a attribute.  Yo crazy-ass chizzle, \s-1TMTOWTDI\s0 afta all.
.SS "Da Color Stack"
.IX Subsection "Da Color Stack"
Yo ass can import \f(CW\*(C`:pushpop\*(C'\fR n' maintain a stack of flavas rockin \s-1PUSHCOLOR,
POPCOLOR,\s0 n' \s-1LOCALCOLOR.  PUSHCOLOR\s0 takes tha attribute strang that
starts its argument n' pushes it onto a stack of attributes.  \s-1POPCOLOR\s0
removes tha top of tha stack n' restores tha previous attributes set by
the argument of a prior \s-1PUSHCOLOR.  LOCALCOLOR\s0 surroundz its argument up in a
\&\s-1PUSHCOLOR\s0 n' \s-1POPCOLOR\s0 so dat tha color resets afterward.
.PP
If \f(CW$Term::ANSIColor::AUTOLOCAL\fR is set, each sequence of color constants
will be implicitly preceded by \s-1LOCALCOLOR. \s0 In other lyrics, tha following:
.PP
.Vb 4
\&    {
\&        local $Term::ANSIColor::AUTOLOCAL = 1;
\&        print BLUE "Text\en";
\&    }
.Ve
.PP
is equivalent to:
.PP
.Vb 1
\&    print LOCALCOLOR BLUE "Text\en";
.Ve
.PP
If \f(CW$Term::ANSIColor::AUTOLOCAL\fR is set, it takes precedence over
\&\f(CW$Term::ANSIColor::AUTORESET\fR, n' tha latta is ignored.
.PP
When rockin \s-1PUSHCOLOR, POPCOLOR,\s0 n' \s-1LOCALCOLOR,\s0 itz particularly
important ta not put commas between tha constants.
.PP
.Vb 1
\&    print PUSHCOLOR BLUE "Text\en";
.Ve
.PP
will erectly push \s-1BLUE\s0 onto tha top of tha stack.
.PP
.Vb 1
\&    print PUSHCOLOR, BLUE, "Text\en";    # wrong!
.Ve
.PP
will not, n' a subsequent pop won't restore tha erect attributes.
\&\s-1PUSHCOLOR\s0 pushes tha attributes set by its argument, which is normally a
strin of color constants, n' you can put dat on yo' toast.  It can't ask tha terminal what tha fuck tha current
attributes are.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Wack color mappin %s" 4
.el .IP "Wack color mappin \f(CW%s\fR" 4
.IX Item "Wack color mappin %s"
(W) Da specified color mappin from \s-1ANSI_COLORS_ALIASES\s0 aint valid and
could not be parsed. Y'all KNOW dat shit, muthafucka!  Dat shiznit was ignored.
.ie n .IP "Wack escape sequence %s" 4
.el .IP "Wack escape sequence \f(CW%s\fR" 4
.IX Item "Wack escape sequence %s"
(F) Yo ass passed a invalid \s-1ANSI\s0 escape sequence ta \fIuncolor()\fR.
.ie n .IP "Bareword ""%s"" not allowed while ""strict subs"" up in use" 4
.el .IP "Bareword ``%s'' not allowed while ``strict subs'' up in use" 4
.IX Item "Bareword %s not allowed while strict subs up in use"
(F) Yo ass probably mistyped a cold-ass lil constant color name such as:
.Sp
.Vb 1
\&    $Foobar = FOOBAR . "This line should be blue\en";
.Ve
.Sp
or:
.Sp
.Vb 1
\&    @Foobar = FOOBAR, "This line should be blue\en";
.Ve
.Sp
This will only show up under use strict (another phat reason ta run under
use strict).
.ie n .IP "Cannot alias standard color %s" 4
.el .IP "Cannot alias standard color \f(CW%s\fR" 4
.IX Item "Cannot alias standard color %s"
(F) Da alias name passed ta \fIcoloralias()\fR matches a standard color name.
Standard color names cannot be aliased.
.ie n .IP "Cannot alias standard color %s up in %s" 4
.el .IP "Cannot alias standard color \f(CW%s\fR up in \f(CW%s\fR" 4
.IX Item "Cannot alias standard color %s up in %s"
(W) Da same yo, but up in \s-1ANSI_COLORS_ALIASES. \s0 Da color mappin was ignored.
.ie n .IP "Invalid alias name %s" 4
.el .IP "Invalid alias name \f(CW%s\fR" 4
.IX Item "Invalid alias name %s"
(F) Yo ass passed a invalid alias name ta \fIcoloralias()\fR.  Alias names must
consist only of alphanumerics, \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, n' \f(CW\*(C`_\*(C'\fR.
.ie n .IP "Invalid alias name %s up in %s" 4
.el .IP "Invalid alias name \f(CW%s\fR up in \f(CW%s\fR" 4
.IX Item "Invalid alias name %s up in %s"
(W) Yo ass specified a invalid alias name on tha left hand of tha equal sign
in a cold-ass lil color mappin up in \s-1ANSI_COLORS_ALIASES. \s0 Da color mappin was ignored.
.ie n .IP "Invalid attribute name %s" 4
.el .IP "Invalid attribute name \f(CW%s\fR" 4
.IX Item "Invalid attribute name %s"
(F) Yo ass passed a invalid attribute name ta \fIcolor()\fR, \fIcolored()\fR, or
\&\fIcoloralias()\fR.
.ie n .IP "Invalid attribute name %s up in %s" 4
.el .IP "Invalid attribute name \f(CW%s\fR up in \f(CW%s\fR" 4
.IX Item "Invalid attribute name %s up in %s"
(W) Yo ass specified a invalid attribute name on tha right hand of tha equal
sign up in a cold-ass lil color mappin up in \s-1ANSI_COLORS_ALIASES. \s0 Da color mappin was
ignored.
.ie n .IP "Name ""%s"" used only once: possible typo" 4
.el .IP "Name ``%s'' used only once: possible typo" 4
.IX Item "Name %s used only once: possible typo"
(W) Yo ass probably mistyped a cold-ass lil constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR "This text is color FOOBAR\en";
.Ve
.Sp
It aint nuthin but probably betta ta always use commas afta constant names up in order to
force tha next error.
.IP "No comma allowed afta filehandle" 4
.IX Item "No comma allowed afta filehandle"
(F) Yo ass probably mistyped a cold-ass lil constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR, "This text is color FOOBAR\en";
.Ve
.Sp
Generatin dis fatal compile error is one of tha main advantagez of using
the constants intercourse, since you gonna immediately know if you mistype a
color name.
.ie n .IP "No name fo' escape sequence %s" 4
.el .IP "No name fo' escape sequence \f(CW%s\fR" 4
.IX Item "No name fo' escape sequence %s"
(F) Da \s-1ANSI\s0 escape sequence passed ta \fIuncolor()\fR gotz nuff escapes which
aren't recognized n' can't be translated ta names.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.IP "\s-1ANSI_COLORS_ALIASES\s0" 4
.IX Item "ANSI_COLORS_ALIASES"
This environment variable allows tha user ta specify custom color aliases
that is ghon be understood by \fIcolor()\fR, \fIcolored()\fR, n' \fIcolorvalid()\fR.  None of
the other functions is ghon be affected, n' no freshly smoked up color constants will be
created. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da custom flavas is aliases fo' existin color names; no new
escape sequences can be introduced. Y'all KNOW dat shit, muthafucka!  Only alphanumerics, \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`_\*(C'\fR, and
\&\f(CW\*(C`\-\*(C'\fR is allowed up in alias names.
.Sp
Da format is:
.Sp
.Vb 1
\&    ANSI_COLORS_ALIASES=\*(Aqnewcolor1=oldcolor1,newcolor2=oldcolor2\*(Aq
.Ve
.Sp
Whitespace is ignored.
.Sp
For example tha Solarized <http://ethanschoonover.com/solarized> colors
can be mapped with:
.Sp
.Vb 11
\&    ANSI_COLORS_ALIASES=\*(Aq\e
\&        base00=bright_yellow, on_base00=on_bright_yellow,\e
\&        base01=bright_green,  on_base01=on_bright_green, \e
\&        base02=black,         on_base02=on_black,        \e
\&        base03=bright_black,  on_base03=on_bright_black, \e
\&        base0=bright_blue,    on_base0=on_bright_blue,   \e
\&        base1=bright_cyan,    on_base1=on_bright_cyan,   \e
\&        base2=white,          on_base2=on_white,         \e
\&        base3=bright_white,   on_base3=on_bright_white,  \e
\&        orange=bright_red,    on_orange=on_bright_red,   \e
\&        violet=bright_magenta,on_violet=on_bright_magenta\*(Aq
.Ve
.Sp
This environment variable is read n' applied when tha Term::ANSIColor
module is loaded n' is then subsequently ignored. Y'all KNOW dat shit, muthafucka!  Chizzlez to
\&\s-1ANSI_COLORS_ALIASES\s0 afta tha module is loaded gonna git no effect.  See
\&\fIcoloralias()\fR fo' a equivalent facilitizzle dat can be used at runtime.
.IP "\s-1ANSI_COLORS_DISABLED\s0" 4
.IX Item "ANSI_COLORS_DISABLED"
If dis environment variable is set ta a legit value, all of tha functions
defined by dis module (\fIcolor()\fR, \fIcolored()\fR, n' all of tha constants not
previously used up in tha program) aint gonna output any escape sequences and
instead will just return tha empty strang or pass all up in tha original
text as appropriate.  This is intended ta support easy as fuck  use of scripts
usin dis module on platforms dat don't support \s-1ANSI\s0 escape sequences.
.SH "COMPATIBILITY"
.IX Header "COMPATIBILITY"
Term::ANSIColor was first included wit Perl up in Perl 5.6.0.
.PP
Da \fIuncolor()\fR function n' support fo' \s-1ANSI_COLORS_DISABLED\s0 was added in
Term::ANSIColor 1.04, included up in Perl 5.8.0.
.PP
Support fo' dark was added up in Term::ANSIColor 1.08, included up in Perl
5.8.4.
.PP
Da color stack, includin tha \f(CW\*(C`:pushpop\*(C'\fR import tag, \s-1PUSHCOLOR,
POPCOLOR, LOCALCOLOR,\s0 n' tha \f(CW$Term::ANSIColor::AUTOLOCAL\fR variable, was
added up in Term::ANSIColor 2.00, included up in Perl 5.10.1.
.PP
\&\fIcolorstrip()\fR was added up in Term::ANSIColor 2.01 n' \fIcolorvalid()\fR was added
in Term::ANSIColor 2.02, both included up in Perl 5.11.0.
.PP
Support fo' flavas 8 all up in 15 (the \f(CW\*(C`bright_\*(C'\fR variants) was added in
Term::ANSIColor 3.00, included up in Perl 5.13.3.
.PP
Support fo' italic was added up in Term::ANSIColor 3.02, included up in Perl
5.17.1.
.PP
Support fo' flavas 16 all up in 256 (the \f(CW\*(C`ansi\*(C'\fR, \f(CW\*(C`rgb\*(C'\fR, n' \f(CW\*(C`grey\*(C'\fR
colors), tha \f(CW\*(C`:constants256\*(C'\fR import tag, tha \fIcoloralias()\fR function, and
support fo' tha \s-1ANSI_COLORS_ALIASES\s0 environment variable was added in
Term::ANSIColor 4.00.
.PP
\&\f(CW$Term::ANSIColor::AUTOLOCAL\fR was chizzled ta take precedence over
\&\f(CW$Term::ANSIColor::AUTORESET\fR, rather than tha other way around, in
Term::ANSIColor 4.00.
.SH "RESTRICTIONS"
.IX Header "RESTRICTIONS"
It would be sick if one could leave off tha commas round tha constants
entirely n' just say:
.PP
.Vb 1
\&    print BOLD BLUE ON_WHITE "Text\en" RESET;
.Ve
.PP
but tha syntax of Perl don't allow all dis bullshit.  Yo ass need a cold-ass lil comma afta the
string.  (Of course, you may consider it a funky-ass bug dat commas between all the
constants aren't required, up in which case you may feel free ta insert
commas unless you rockin \f(CW$Term::ANSIColor::AUTORESET\fR or
\&\s-1PUSHCOLOR/POPCOLOR.\s0)
.PP
For easier debugging, you may prefer ta always use tha commas when not
settin \f(CW$Term::ANSIColor::AUTORESET\fR or \s-1PUSHCOLOR/POPCOLOR\s0 so dat you'll
get a gangbangin' fatal compile error rather than a warning.
.PP
It aint nuthin but not possible ta use dis module ta embed formattin n' color
attributes rockin Perl formats, n' you can put dat on yo' toast.  They replace tha escape characta wit a
space (as documented up in \fIperlform\fR\|(1)), resultin up in garbled output from
the unrecognized attribute.  Even if there was a way round dat problem,
the format don't give a fuck dat tha non-printin escape sequence is
zero-length n' would incorrectly format tha output.  For formatted output
usin color or other attributes, either use \fIsprintf()\fR instead or use
\&\fIformline()\fR n' then add tha color or other attributes afta formattin and
before output.
.SH "NOTES"
.IX Header "NOTES"
Da codes generated by dis module is standard terminal control codes,
complyin wit \s-1ECMA\-048\s0 n' \s-1ISO 6429 \s0(generally referred ta as \*(L"\s-1ANSI\s0
color\*(R" fo' tha color codes).  Da non-color control codes (bold, dark,
italic, underline, n' reverse) is part of tha earlier \s-1ANSI X3.64\s0
standard fo' control sequences fo' vizzle terminals n' peripherals.
.PP
Note dat not all displays is \s-1ISO\s0 6429\-compliant, or even X3.64\-compliant
(or is even attemptin ta be so).  This module aint gonna work as expected
on displays dat do not honor these escape sequences, like fuckin cmd.exe,
4nt.exe, n' command.com under either Windows \s-1NT\s0 or Windows 2000.  They
may just be ignored, or they may display as a \s-1ESC\s0 characta followed by
some apparent garbage.
.PP
Jean Delvare provided tha followin table of different common terminal
emulators n' they support fo' tha various attributes n' others have
helped mah crazy ass flesh it out:
.PP
.Vb 12
\&              clear    bold     faint   under    blink   reverse  conceal
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& xterm         yeaaaa      yeaaaa      no      yeaaaa      yeaaaa      yeaaaa      yes
\& linux         yeaaaa      yeaaaa      yeaaaa    bold      yeaaaa      yeaaaa      no
\& rxvt          yeaaaa      yeaaaa      no      yeaaaa  bold/black   yeaaaa      no
\& dtterm        yeaaaa      yeaaaa      yeaaaa     yeaaaa    reverse    yeaaaa      yes
\& teraterm      yeaaaa    reverse    no      yeaaaa    rev/red    yeaaaa      no
\& aixterm      kinda   aiiight     no      yeaaaa      no       yeaaaa      yes
\& PuTTY         yeaaaa     color     no      yeaaaa      no       yeaaaa      no
\& Windows       yeaaaa      no       no      no       no       yeaaaa      no
\& Cygwin SSH    yeaaaa      yeaaaa      no     color    color    color     yes
\& Terminal.app  yeaaaa      yeaaaa      no      yeaaaa      yeaaaa      yeaaaa      yes
.Ve
.PP
Windows is Windows telnet, Cygwin \s-1SSH\s0 is tha OpenSSH implementation under
Cygwin on Windows \s-1NT,\s0 n' Mac Terminal is tha Terminal application up in Mac
\&\s-1OS X. \s0 Where tha entry is other than yeaaaa or no, dat emulator displays the
given attribute as suttin' else instead. Y'all KNOW dat shit, muthafucka!  Note dat on a aixterm, clear
doesn't reset colors; you gotta explicitly set tha flavas back ta what
you want.  Mo' entries up in dis table is welcome.
.PP
Support fo' code 3 (italic) is rare n' therefore not mentioned up in that
table.  It aint believed ta be straight-up supported by any of tha terminals
listed, although itz displayed as chronic up in tha Linux console yo, but it is
reportedly supported by urxvt.
.PP
Note dat codes 6 (rapid blink) n' 9 (strike-through) is specified in
\&\s-1ANSI X3.64\s0 n' \s-1ECMA\-048\s0 but is not commonly supported by most displays
and emulators n' therefore aren't supported by dis module all up in tha present
time.  \s-1ECMA\-048\s0 also specifies a big-ass number of other attributes,
includin a sequence of attributes fo' font chizzles, Fraktur characters,
double-underlining, framing, circling, n' overlining.  As none of these
attributes is widely supported or useful, they also aren't currently
supported by dis module.
.PP
Most modern X terminal emulators support 256 colors.  Known ta not support
those flavas is aterm, rxvt, Terminal.app, n' \s-1TTY/VC.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1ECMA\-048\s0 be available on-line (at least all up in tha time of dis writing) at
<http://www.ecma\-international.org/publications/standards/Ecma\-048.htm>.
.PP
\&\s-1ISO 6429\s0 be available from \s-1ISO\s0 fo' a cold-ass lil charge; tha lyricist of dis module
does not own a cold-ass lil copy of dat shit.  Since tha source material fo' \s-1ISO 6429\s0 was
\&\s-1ECMA\-048\s0 n' tha latta be available fo' free, there seems lil reason
to obtain tha \s-1ISO\s0 standard.
.PP
Da 256\-color control sequences is documented at
<http://www.xfree86.org/current/ctlseqs.html> (search fo' 256\-color).
.PP
Da \s-1CPAN\s0 module Term::ExtendedColor serves up a gangbangin' finger-lickin' different n' more
comprehensive intercourse fo' 256\-color emulators dat may be more
convenient.
.PP
Da current version of dis module be always available from its wizzy crib
at <http://www.eyrie.org/~eagle/software/ansicolor/>.  It be also part of
the Perl core distribution az of 5.6.0.
.SH "AUTHORS"
.IX Header "AUTHORS"
Original Gangsta scam (usin constants) by Zenin, reimplemented rockin subs by Russ
Allbery <rra@stanford.edu>, n' then combined wit tha original gangsta scam by
Russ wit input from Zenin. I aint talkin' bout chicken n' gravy biatch.  256\-color support is based on work by Kurt
Starsinic.  Russ Allbery now maintains dis module.
.PP
\&\s-1PUSHCOLOR, POPCOLOR,\s0 n' \s-1LOCALCOLOR\s0 was contributed by openmethods.com
voice solutions.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1996 Zenin. I aint talkin' bout chicken n' gravy biatch.  Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005,
2006, 2008, 2009, 2010, 2011, 2012 Russ Allbery <rra@stanford.edu>.
Copyright 2012 Kurt Starsinic <kstarsinic@gmail.com>.  This program is
free software; you may redistribute it and/or modify it under tha same
terms as Perl itself.
