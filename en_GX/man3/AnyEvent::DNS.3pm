.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::DNS 3"
.TH AnyEvent::DNS 3 "2012-11-15" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::DNS \- straight-up asynchronous DNS resolution
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent::DNS;
\&   
\&   mah $cv = AnyEvent\->condvar;
\&   AnyEvent::DNS::a "www.google.de", $cv;
\&   # ... later
\&   mah @addrs = $cv\->recv;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module offers both a fuckin shitload of \s-1DNS\s0 convenience functions as well
as a gangbangin' straight-up asynchronous n' high-performizzle pure-perl stub resolver.
.PP
Da stub resolver supports \s-1DNS\s0 over IPv4 n' IPv6, \s-1UDP\s0 n' \s-1TCP,\s0 optional
\&\s-1EDNS0\s0 support fo' up ta 4kiB datagrams n' automatically falls back to
virtual circuit mode fo' big-ass responses.
.SS "\s-1CONVENIENCE FUNCTIONS\s0"
.IX Subsection "CONVENIENCE FUNCTIONS"
.ie n .IP "AnyEvent::DNS::a $domain, $cb\->(@addrs)" 4
.el .IP "AnyEvent::DNS::a \f(CW$domain\fR, \f(CW$cb\fR\->(@addrs)" 4
.IX Item "AnyEvent::DNS::a $domain, $cb->(@addrs)"
Tries ta resolve tha given domain ta IPv4 address(es).
.ie n .IP "AnyEvent::DNS::aaaa $domain, $cb\->(@addrs)" 4
.el .IP "AnyEvent::DNS::aaaa \f(CW$domain\fR, \f(CW$cb\fR\->(@addrs)" 4
.IX Item "AnyEvent::DNS::aaaa $domain, $cb->(@addrs)"
Tries ta resolve tha given domain ta IPv6 address(es).
.ie n .IP "AnyEvent::DNS::mx $domain, $cb\->(@hostnames)" 4
.el .IP "AnyEvent::DNS::mx \f(CW$domain\fR, \f(CW$cb\fR\->(@hostnames)" 4
.IX Item "AnyEvent::DNS::mx $domain, $cb->(@hostnames)"
Tries ta resolve tha given domain tha fuck into a sorted (lower preference value
first) list of domain names.
.ie n .IP "AnyEvent::DNS::ns $domain, $cb\->(@hostnames)" 4
.el .IP "AnyEvent::DNS::ns \f(CW$domain\fR, \f(CW$cb\fR\->(@hostnames)" 4
.IX Item "AnyEvent::DNS::ns $domain, $cb->(@hostnames)"
Tries ta resolve tha given domain name tha fuck into a list of name servers.
.ie n .IP "AnyEvent::DNS::txt $domain, $cb\->(@hostnames)" 4
.el .IP "AnyEvent::DNS::txt \f(CW$domain\fR, \f(CW$cb\fR\->(@hostnames)" 4
.IX Item "AnyEvent::DNS::txt $domain, $cb->(@hostnames)"
Tries ta resolve tha given domain name tha fuck into a list of text records. Only
the first text strang per record is ghon be returned. Y'all KNOW dat shit, muthafucka! If you want all
strings, you need ta booty-call tha resolver manually:
.Sp
.Vb 6
\&   resolver\->resolve ($domain => "txt", sub {
\&      fo' mah $record (@_) {
\&         mah (undef, undef, undef, @txt) = @$record;
\&         # strings now up in @txt
\&      }
\&   });
.Ve
.ie n .IP "AnyEvent::DNS::srv $service, $proto, $domain, $cb\->(@srv_rr)" 4
.el .IP "AnyEvent::DNS::srv \f(CW$service\fR, \f(CW$proto\fR, \f(CW$domain\fR, \f(CW$cb\fR\->(@srv_rr)" 4
.IX Item "AnyEvent::DNS::srv $service, $proto, $domain, $cb->(@srv_rr)"
Tries ta resolve tha given service, protocol n' domain name tha fuck into a list
of steez records.
.Sp
Each \f(CW$srv_rr\fR be a array reference wit tha followin contents: 
\&\f(CW\*(C`[$priority, $weight, $transport, $target]\*(C'\fR.
.Sp
They is ghon be sorted wit lowest prioritizzle first, then randomly
distributed by weight as per \s-1RFC 2782.\s0
.Sp
Example:
.Sp
.Vb 2
\&   AnyEvent::DNS::srv "sip", "udp", "schmorp.de", sub { ...
\&   # @_ = ( [10, 10, 5060, "sip1.schmorp.de" ] )
.Ve
.ie n .IP "AnyEvent::DNS::any $domain, $cb\->(@rrs)" 4
.el .IP "AnyEvent::DNS::any \f(CW$domain\fR, \f(CW$cb\fR\->(@rrs)" 4
.IX Item "AnyEvent::DNS::any $domain, $cb->(@rrs)"
Tries ta resolve tha given domain n' passes all resource recordz found to
the callback.
.ie n .IP "AnyEvent::DNS::ptr $domain, $cb\->(@hostnames)" 4
.el .IP "AnyEvent::DNS::ptr \f(CW$domain\fR, \f(CW$cb\fR\->(@hostnames)" 4
.IX Item "AnyEvent::DNS::ptr $domain, $cb->(@hostnames)"
Tries ta cook up a \s-1PTR\s0 lookup on tha given domain. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See \f(CW\*(C`reverse_lookup\*(C'\fR
and \f(CW\*(C`reverse_verify\*(C'\fR if you wanna resolve a \s-1IP\s0 address ta a hostname
instead.
.ie n .IP "AnyEvent::DNS::reverse_lookup $ipv4_or_6, $cb\->(@hostnames)" 4
.el .IP "AnyEvent::DNS::reverse_lookup \f(CW$ipv4_or_6\fR, \f(CW$cb\fR\->(@hostnames)" 4
.IX Item "AnyEvent::DNS::reverse_lookup $ipv4_or_6, $cb->(@hostnames)"
Tries ta reverse-resolve tha given IPv4 or IPv6 address (in textual form)
into its hostname(s) yo. Handlez V4MAPPED n' V4COMPAT IPv6 addresses
transparently.
.ie n .IP "AnyEvent::DNS::reverse_verify $ipv4_or_6, $cb\->(@hostnames)" 4
.el .IP "AnyEvent::DNS::reverse_verify \f(CW$ipv4_or_6\fR, \f(CW$cb\fR\->(@hostnames)" 4
.IX Item "AnyEvent::DNS::reverse_verify $ipv4_or_6, $cb->(@hostnames)"
Da same as \f(CW\*(C`reverse_lookup\*(C'\fR yo, but do forward-lookups ta verify that
the resolved hostnames indeed point ta tha address, which make spoofing
harder.
.Sp
If you wanna resolve a address tha fuck into a hostname, dis is tha preferred
method: Da \s-1DNS\s0 recordz could still chizzle yo, but at least dis function
verified dat tha hostname, at one point up in tha past, pointed all up in tha \s-1IP\s0
address you originally resolved.
.Sp
Example:
.Sp
.Vb 2
\&   AnyEvent::DNS::reverse_verify "2001:500:2f::f", sub { print shift };
\&   # => f.root\-servers.net
.Ve
.SS "LOW-LEVEL \s-1DNS EN\-/DECODING FUNCTIONS\s0"
.IX Subsection "LOW-LEVEL DNS EN-/DECODING FUNCTIONS"
.ie n .IP "$AnyEvent::DNS::EDNS0" 4
.el .IP "\f(CW$AnyEvent::DNS::EDNS0\fR" 4
.IX Item "$AnyEvent::DNS::EDNS0"
This variable decides whether dns_pack automatically enablez \s-1EDNS0\s0
support. By default, dis is disabled (\f(CW0\fR), unless overridden by
\&\f(CW$ENV{PERL_ANYEVENT_EDNS0}\fR yo, but when set ta \f(CW1\fR, AnyEvent::DNS will use
\&\s-1EDNS0\s0 up in all requests.
.ie n .IP "$pkt = AnyEvent::DNS::dns_pack $dns" 4
.el .IP "\f(CW$pkt\fR = AnyEvent::DNS::dns_pack \f(CW$dns\fR" 4
.IX Item "$pkt = AnyEvent::DNS::dns_pack $dns"
Packs a perl data structure tha fuck into a \s-1DNS\s0 packet. Readin \s-1RFC 1035\s0 is strongly
recommended, then every last muthafuckin thang is ghon be straight-up clear. Shiiit, dis aint no joke. Or maybe not.
.Sp
Resource recordz is not yet encodable.
.Sp
Examples:
.Sp
.Vb 2
\&   # straight-up simple request, rockin fuckin shitloadz of default joints:
\&   { rd => 1, qd => [ [ "host.domain", "a"] ] }
\&  
\&   # mo' complex example, showin how tha fuck flags etc. is named:
\&  
\&   {
\&      id => 10000,
\&      op => "query",
\&      rc => "nxdomain",
\&  
\&      # flags
\&      qr => 1,
\&      aa => 0,
\&      tc => 0,
\&      rd => 0,
\&      ra => 0,
\&      ad => 0,
\&      cd => 0,
\&  
\&      qd => [@rr], # query section
\&      a => [@rr], # answer section
\&      ns => [@rr], # authoritizzle section
\&      ar => [@rr], # additionizzle recordz section
\&   }
.Ve
.ie n .IP "$dns = AnyEvent::DNS::dns_unpack $pkt" 4
.el .IP "\f(CW$dns\fR = AnyEvent::DNS::dns_unpack \f(CW$pkt\fR" 4
.IX Item "$dns = AnyEvent::DNS::dns_unpack $pkt"
Unpacks a \s-1DNS\s0 packet tha fuck into a perl data structure.
.Sp
Examples:
.Sp
.Vb 10
\&   # a unsuccessful reply
\&   {
\&     \*(Aqqd\*(Aq => [
\&               [ \*(Aqruth.plan9.de.mach.uni\-karlsruhe.de\*(Aq, \*(Aq*\*(Aq, \*(Aqin\*(Aq ]
\&             ],
\&     \*(Aqrc\*(Aq => \*(Aqnxdomain\*(Aq,
\&     \*(Aqar\*(Aq => [],
\&     \*(Aqns\*(Aq => [
\&               [
\&                 \*(Aquni\-karlsruhe.de\*(Aq,
\&                 \*(Aqsoa\*(Aq,
\&                 \*(Aqin\*(Aq,
\&                 600,
\&                 \*(Aqnetserv.rz.uni\-karlsruhe.de\*(Aq,
\&                 \*(Aqhostmaster.rz.uni\-karlsruhe.de\*(Aq,
\&                 2008052201, 10800, 1800, 2592000, 86400
\&               ]
\&             ],
\&     \*(Aqtc\*(Aq => \*(Aq\*(Aq,
\&     \*(Aqra\*(Aq => 1,
\&     \*(Aqqr\*(Aq => 1,
\&     \*(Aqid\*(Aq => 45915,
\&     \*(Aqaa\*(Aq => \*(Aq\*(Aq,
\&     \*(Aqan\*(Aq => [],
\&     \*(Aqrd\*(Aq => 1,
\&     \*(Aqop\*(Aq => \*(Aqquery\*(Aq
\&   }
\&   
\&   # a successful reply
\&   
\&   {
\&     \*(Aqqd\*(Aq => [ [ \*(Aqwww.google.de\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq ] ],
\&     \*(Aqrc\*(Aq => 0,
\&     \*(Aqar\*(Aq => [
\&               [ \*(Aqa.l.google.com\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aq209.85.139.9\*(Aq ],
\&               [ \*(Aqb.l.google.com\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aq64.233.179.9\*(Aq ],
\&               [ \*(Aqc.l.google.com\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aq64.233.161.9\*(Aq ],
\&             ],
\&     \*(Aqns\*(Aq => [
\&               [ \*(Aql.google.com\*(Aq, \*(Aqns\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aqa.l.google.com\*(Aq ],
\&               [ \*(Aql.google.com\*(Aq, \*(Aqns\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aqb.l.google.com\*(Aq ],
\&             ],
\&     \*(Aqtc\*(Aq => \*(Aq\*(Aq,
\&     \*(Aqra\*(Aq => 1,
\&     \*(Aqqr\*(Aq => 1,
\&     \*(Aqid\*(Aq => 64265,
\&     \*(Aqaa\*(Aq => \*(Aq\*(Aq,
\&     \*(Aqan\*(Aq => [
\&               [ \*(Aqwww.google.de\*(Aq, \*(Aqcname\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aqwww.google.com\*(Aq ],
\&               [ \*(Aqwww.google.com\*(Aq, \*(Aqcname\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aqwww.l.google.com\*(Aq ],
\&               [ \*(Aqwww.l.google.com\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aq66.249.93.104\*(Aq ],
\&               [ \*(Aqwww.l.google.com\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aq66.249.93.147\*(Aq ],
\&             ],
\&     \*(Aqrd\*(Aq => 1,
\&     \*(Aqop\*(Aq => 0
\&   }
.Ve
.SS "\s-1THE\s0 AnyEvent::DNS \s-1RESOLVER CLASS\s0"
.IX Subsection "THE AnyEvent::DNS RESOLVER CLASS"
This is tha class which do tha actual protocol work.
.IP "AnyEvent::DNS::resolver" 4
.IX Item "AnyEvent::DNS::resolver"
This function creates n' returns a resolver dat is locked n loaded ta use and
should mimic tha default resolver fo' yo' system as phat as possible. It
is used by AnyEvent itself as well.
.Sp
It only eva creates one resolver n' returns dis one on subsequent calls
\&\- peep \f(CW$AnyEvent::DNS::RESOLVER\fR, below, fo' details.
.Sp
Unless you have special needs, prefer dis function over bustin yo' own
resolver object.
.Sp
Da resolver is pimped wit tha followin parameters:
.Sp
.Vb 2
\&   untaint          enabled
\&   max_outstandin  $ENV{PERL_ANYEVENT_MAX_OUTSTANDING_DNS}
.Ve
.Sp
\&\f(CW\*(C`os_config\*(C'\fR is ghon be used fo' OS-specific configuration, unless
\&\f(CW$ENV{PERL_ANYEVENT_RESOLV_CONF}\fR is specified, up in which case dat file
gets parsed.
.ie n .IP "$AnyEvent::DNS::RESOLVER" 4
.el .IP "\f(CW$AnyEvent::DNS::RESOLVER\fR" 4
.IX Item "$AnyEvent::DNS::RESOLVER"
This variable stores tha default resolver returned by
\&\f(CW\*(C`AnyEvent::DNS::resolver\*(C'\fR, or \f(CW\*(C`undef\*(C'\fR when tha default resolver aint
been instantiated yet.
.Sp
One can provide a cold-ass lil custom resolver (e.g. one wit cachin functionality)
by storin it up in dis variable, causin all subsequent resolves done via
\&\f(CW\*(C`AnyEvent::DNS::resolver\*(C'\fR ta be done via tha custom one.
.ie n .IP "$resolver = freshly smoked up AnyEvent::DNS key => value..." 4
.el .IP "\f(CW$resolver\fR = freshly smoked up AnyEvent::DNS key => value..." 4
.IX Item "$resolver = freshly smoked up AnyEvent::DNS key => value..."
Creates n' returns a freshly smoked up resolver.
.Sp
Da followin options is supported:
.RS 4
.IP "server => [...]" 4
.IX Item "server => [...]"
A list of server addresses (default: \f(CW\*(C`v127.0.0.1\*(C'\fR or \f(CW\*(C`::1\*(C'\fR) up in network
format (i.e. as returned by \f(CW\*(C`AnyEvent::Socket::parse_address\*(C'\fR \- both IPv4
and IPv6 is supported).
.IP "timeout => [...]" 4
.IX Item "timeout => [...]"
A list of timeouts ta use (also determines tha number of retries). To make
three retries wit individual time-outz of 2, 5 n' 5 seconds, use \f(CW\*(C`[2,
5, 5]\*(C'\fR, which be also tha default.
.IP "search => [...]" 4
.IX Item "search => [...]"
Da default search list of suffixes ta append ta a thugged-out domain name (default: none).
.ie n .IP "ndots => $integer" 4
.el .IP "ndots => \f(CW$integer\fR" 4
.IX Item "ndots => $integer"
Da number of dots (default: \f(CW1\fR) dat a name must have so dat tha resolver
tries ta resolve tha name without any suffixes first.
.ie n .IP "max_outstandin => $integer" 4
.el .IP "max_outstandin => \f(CW$integer\fR" 4
.IX Item "max_outstandin => $integer"
Most name servers do not handle nuff parallel requests straight-up well. This
option limits tha number of outstandin requests ta \f(CW$integer\fR
(default: \f(CW10\fR), dat means if you request mo' than dis nuff requests,
then tha additionizzle requests is ghon be queued until some other requests have
been resolved.
.ie n .IP "reuse => $seconds" 4
.el .IP "reuse => \f(CW$seconds\fR" 4
.IX Item "reuse => $seconds"
Da number of secondz (default: \f(CW300\fR) dat a query id cannot be re-used
afta a timeout. If there was no time-out then query idz can be reused
immediately.
.ie n .IP "untaint => $boolean" 4
.el .IP "untaint => \f(CW$boolean\fR" 4
.IX Item "untaint => $boolean"
When true, then tha resolver will automatically untaint thangs up in dis biatch, n' might
also ignore certain environment variables.
.RE
.RS 4
.RE
.ie n .IP "$resolver\->parse_resolv_conf ($string)" 4
.el .IP "\f(CW$resolver\fR\->parse_resolv_conf ($string)" 4
.IX Item "$resolver->parse_resolv_conf ($string)"
Parses tha given strang as if it was a \fIresolv.conf\fR file. Da following
directives is supported (but not necessarily implemented).
.Sp
\&\f(CW\*(C`#\*(C'\fR\- n' \f(CW\*(C`;\*(C'\fR\-style comments, \f(CW\*(C`nameserver\*(C'\fR, \f(CW\*(C`domain\*(C'\fR, \f(CW\*(C`search\*(C'\fR, \f(CW\*(C`sortlist\*(C'\fR,
\&\f(CW\*(C`options\*(C'\fR (\f(CW\*(C`timeout\*(C'\fR, \f(CW\*(C`attempts\*(C'\fR, \f(CW\*(C`ndots\*(C'\fR).
.Sp
Everythang else is silently ignored.
.ie n .IP "$resolver\->os_config" 4
.el .IP "\f(CW$resolver\fR\->os_config" 4
.IX Item "$resolver->os_config"
Tries so load n' parse \fI/etc/resolv.conf\fR on portable operating
systems. Tries various egregious hacks on windows ta force tha \s-1DNS\s0 servers
and searchlist outta tha system.
.Sp
This method must be called at most once before tryin ta resolve anything.
.ie n .IP "$resolver\->timeout ($timeout, ...)" 4
.el .IP "\f(CW$resolver\fR\->timeout ($timeout, ...)" 4
.IX Item "$resolver->timeout ($timeout, ...)"
Sets tha timeout joints, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See tha \f(CW\*(C`timeout\*(C'\fR constructor argument (and
note dat dis method expects tha timeout joints theyselves, not an
array-reference).
.ie n .IP "$resolver\->max_outstandin ($nrequests)" 4
.el .IP "\f(CW$resolver\fR\->max_outstandin ($nrequests)" 4
.IX Item "$resolver->max_outstandin ($nrequests)"
Sets tha maximum number of outstandin requests ta \f(CW$nrequests\fR. Right back up in yo muthafuckin ass. See the
\&\f(CW\*(C`max_outstanding\*(C'\fR constructor argument.
.ie n .IP "$resolver\->request ($req, $cb\->($res))" 4
.el .IP "\f(CW$resolver\fR\->request ($req, \f(CW$cb\fR\->($res))" 4
.IX Item "$resolver->request ($req, $cb->($res))"
This is tha main low-level workhorse fo' bustin  \s-1DNS\s0 requests.
.Sp
This function sendz a single request (a hash-ref formated as specified
for \f(CW\*(C`dns_pack\*(C'\fR) ta tha configured nameservers up in turn until it gets a
response. Well shiiiit, it handlez timeouts, retries n' automatically falls back to
virtual circuit mode (\s-1TCP\s0) when it receives a truncated reply. Well shiiiit, it do not
handle anythang else, like fuckin tha domain searchlist or relatizzle names \-
use \f(CW\*(C`\->resolve\*(C'\fR fo' dis shit.
.Sp
Calls tha callback wit tha decoded response packet if a reply was
received, or no arguments up in case none of tha servers answered.
.ie n .IP "$resolver\->resolve ($qname, $qtype, %options, $cb\->(@rr))" 4
.el .IP "\f(CW$resolver\fR\->resolve ($qname, \f(CW$qtype\fR, \f(CW%options\fR, \f(CW$cb\fR\->(@rr))" 4
.IX Item "$resolver->resolve ($qname, $qtype, %options, $cb->(@rr))"
Queries tha \s-1DNS\s0 fo' tha given domain name \f(CW$qname\fR of type \f(CW$qtype\fR.
.Sp
A \f(CW$qtype\fR is either a numerical query type (e.g. \f(CW1\fR fo' A records) or
a lowercase name (you gotta peep tha source ta peep which aliases are
supported yo, but all types from \s-1RFC 1035, \s0\f(CW\*(C`aaaa\*(C'\fR, \f(CW\*(C`srv\*(C'\fR, \f(CW\*(C`spf\*(C'\fR n' a gangbangin' few
more is known ta dis module) fo' realz. A \f(CW$qtype\fR of \*(L"*\*(R" is supported n' means
\&\*(L"any\*(R" record type.
.Sp
Da callback is ghon be invoked wit a list of matchin result recordz or
none on any error or if tha name could not be found.
.Sp
\&\s-1CNAME\s0 chains (although illegal) is followed up ta a length of 10.
.Sp
Da callback is ghon be invoked wit arraryefz of tha form \f(CW\*(C`[$name,
$type, $class, $ttl, @data\*(C'\fR], where \f(CW$name\fR is tha domain name,
\&\f(CW$type\fR a type strang or number, \f(CW$class\fR a cold-ass lil class name, \f(CW$ttl\fR is the
remainin time-to-live n' \f(CW@data\fR is resource-record-dependent data, in
seconds. For \f(CW\*(C`a\*(C'\fR records, dis is ghon be tha textual IPv4 addresses, for
\&\f(CW\*(C`ns\*(C'\fR or \f(CW\*(C`cname\*(C'\fR recordz dis is ghon be a thugged-out domain name, fo' \f(CW\*(C`txt\*(C'\fR records
these is all tha strings n' so on.
.Sp
All types mentioned up in \s-1RFC 1035, \s0\f(CW\*(C`aaaa\*(C'\fR, \f(CW\*(C`srv\*(C'\fR, \f(CW\*(C`naptr\*(C'\fR n' \f(CW\*(C`spf\*(C'\fR are
decoded. Y'all KNOW dat shit, muthafucka! All resource recordz not known ta dis module gonna git tha raw
\&\f(CW\*(C`rdata\*(C'\fR field as fifth array element.
.Sp
Note dat dis resolver is just a stub resolver: it requires a name server
supportin recursive queries, aint gonna do any recursive queries itself and
is not secure when used against a untrusted name server.
.Sp
Da followin options is supported:
.RS 4
.IP "search => [$suffix...]" 4
.IX Item "search => [$suffix...]"
Use tha given search list (which might be empty), by appendin each one
in turn ta tha \f(CW$qname\fR. If dis option is missin then tha configured
\&\f(CW\*(C`ndots\*(C'\fR n' \f(CW\*(C`search\*(C'\fR joints define its value (dependin on \f(CW\*(C`ndots\*(C'\fR, the
empty suffix is ghon be prepended or appended ta dat \f(CW\*(C`search\*(C'\fR value). If
the \f(CW$qname\fR endz up in a thugged-out dot, then tha searchlist is ghon be ignored.
.IP "accept => [$type...]" 4
.IX Item "accept => [$type...]"
Lists tha aaight result types: only result types up in dis set will be
accepted n' returned. Y'all KNOW dat shit, muthafucka! Da default includes tha \f(CW$qtype\fR n' nothing
else. If dis list includes \f(CW\*(C`cname\*(C'\fR, then CNAME-chains aint gonna be
followed (because you axed fo' tha \s-1CNAME\s0 record).
.ie n .IP "class => ""class""" 4
.el .IP "class => ``class''" 4
.IX Item "class => class"
Specify tha query class (\*(L"in\*(R" fo' internet, \*(L"ch\*(R" fo' chaosnet n' \*(L"hs\*(R" for
hesiod is tha only ones makin sense). Da default is \*(L"in\*(R", of course.
.RE
.RS 4
.Sp
Examples:
.Sp
.Vb 6
\&   # full example, you can paste dis tha fuck into perl:
\&   use Data::Dumper;
\&   use AnyEvent::DNS;
\&   AnyEvent::DNS::resolver\->resolve (
\&      "google.com", "*", mah $cv = AnyEvent\->condvar);
\&   warn Dumper [$cv\->recv];
\&
\&   # shortened result:
\&   # [
\&   #   [ \*(Aqgoogle.com\*(Aq, \*(Aqsoa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aqns1.google.com\*(Aq, \*(Aqdns\-admin.google.com\*(Aq,
\&   #     2008052701, 7200, 1800, 1209600, 300 ],
\&   #   [
\&   #     \*(Aqgoogle.com\*(Aq, \*(Aqtxt\*(Aq, \*(Aqin\*(Aq, 3600,
\&   #     \*(Aqv=spf1 include:_netblocks.google.com ~all\*(Aq
\&   #   ],
\&   #   [ \*(Aqgoogle.com\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aq64.233.187.99\*(Aq ],
\&   #   [ \*(Aqgoogle.com\*(Aq, \*(Aqmx\*(Aq, \*(Aqin\*(Aq, 3600, 10, \*(Aqsmtp2.google.com\*(Aq ],
\&   #   [ \*(Aqgoogle.com\*(Aq, \*(Aqns\*(Aq, \*(Aqin\*(Aq, 3600, \*(Aqns2.google.com\*(Aq ],
\&   # ]
\&
\&   # resolve a records:
\&   $res\->resolve ("ruth.plan9.de", "a", sub { warn Dumper [@_] });
\&
\&   # result:
\&   # [
\&   #   [ \*(Aqruth.schmorp.de\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 86400, \*(Aq129.13.162.95\*(Aq ]
\&   # ]
\&
\&   # resolve any recordz yo, but return only a n' aaaa records:
\&   $res\->resolve ("test1.laendle", "*",
\&      accept => ["a", "aaaa"],
\&      sub {
\&         warn Dumper [@_];
\&      }
\&   );
\&
\&   # result:
\&   # [
\&   #   [ \*(Aqtest1.laendle\*(Aq, \*(Aqa\*(Aq, \*(Aqin\*(Aq, 86400, \*(Aq10.0.0.255\*(Aq ],
\&   #   [ \*(Aqtest1.laendle\*(Aq, \*(Aqaaaa\*(Aq, \*(Aqin\*(Aq, 60, \*(Aq3ffe:1900:4545:0002:0240:0000:0000:f7e1\*(Aq ]
\&   # ]
.Ve
.RE
.ie n .IP "$resolver\->wait_for_slot ($cb\->($resolver))" 4
.el .IP "\f(CW$resolver\fR\->wait_for_slot ($cb\->($resolver))" 4
.IX Item "$resolver->wait_for_slot ($cb->($resolver))"
Wait until a gangbangin' free request slot be available n' call tha callback wit the
resolver object.
.Sp
A request slot is used each time a request is straight-up busted ta the
nameservers: There is never mo' than \f(CW\*(C`max_outstanding\*(C'\fR of em.
.Sp
Although you can submit mo' requests (they will simply be queued until
a request slot becomes available), sometimes, probably fo' rate-limiting
purposes, it is useful ta instead wait fo' a slot before generatin the
request (or simply ta know when tha request load is low enough so one can
submit requests again).
.Sp
This is what tha fuck dis method do: Da callback is ghon be called when submitting
a \s-1DNS\s0 request aint gonna result up in dat request bein queued. Y'all KNOW dat shit, muthafucka! Da callback
may or may not generate any requests up in response.
.Sp
Note dat tha callback will only be invoked when tha request queue is
empty, so dis do not play well if some muthafucka else keeps tha request queue
full at all times.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\&   Marc Lehmann <schmorp@schmorp.de>
\&   http://anyevent.schmorp.de
.Ve
