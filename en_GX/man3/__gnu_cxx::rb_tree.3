" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_cxx::rb_tree< _Key, _Value, _KeyOfValue, _Compare, _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits std::_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc >\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Rb_tree< _Key, _Value, 
.br
_KeyOfValue, _Compare, _Alloc > \fB_Base\fP"
.br
.ti -1c
.RI "typedef const _Rb_tree_node
.br
< _Val > * \fB_Const_Link_type\fP"
.br
.ti -1c
.RI "typedef _Rb_tree_node< _Val > * \fB_Link_type\fP"
.br
.ti -1c
.RI "typedef _Base::allocator_type \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef 
.br
_Rb_tree_const_iterator
.br
< value_type > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef const value_type * \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef const value_type & \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< const_iterator > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef _Rb_tree_iterator
.br
< value_type > \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Key \fBkey_type\fP"
.br
.ti -1c
.RI "typedef value_type * \fBpointer\fP"
.br
.ti -1c
.RI "typedef value_type & \fBreference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< iterator > \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Val \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBrb_tree\fP (const _Compare &__comp=_Compare(), const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "bool \fB__rb_verify\fP () const "
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> iterator \fB_M_emplace_equal\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> _Rb_tree< _Key, _Val, 
.br
_KeyOfValue, _Compare, _Alloc >
.br
::iterator \fB_M_emplace_equal\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> iterator \fB_M_emplace_hint_equal\fP (const_iterator __pos, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> _Rb_tree< _Key, _Val, 
.br
_KeyOfValue, _Compare, _Alloc >
.br
::iterator \fB_M_emplace_hint_equal\fP (const_iterator __pos, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> iterator \fB_M_emplace_hint_unique\fP (const_iterator __pos, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> _Rb_tree< _Key, _Val, 
.br
_KeyOfValue, _Compare, _Alloc >
.br
::iterator \fB_M_emplace_hint_unique\fP (const_iterator __pos, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBpair\fP< iterator, bool > \fB_M_emplace_unique\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBpair\fP< typename _Rb_tree< _Key, 
.br
_Val, _KeyOfValue, _Compare, 
.br
_Alloc >::iterator, bool > \fB_M_emplace_unique\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "_Node_allocator & \fB_M_get_Node_allocator\fP () noexcept"
.br
.ti -1c
.RI "const _Node_allocator & \fB_M_get_Node_allocator\fP () const noexcept"
.br
.ti -1c
.RI "template<typename _Arg > _Rb_tree< _Key, _Val, 
.br
_KeyOfValue, _Compare, _Alloc >
.br
::iterator \fB_M_insert_\fP (_Base_ptr __x, _Base_ptr __p, _Arg &&__v)"
.br
.ti -1c
.RI "template<typename _Arg > iterator \fB_M_insert_equal\fP (_Arg &&__x)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_insert_equal\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "template<typename _Arg > _Rb_tree< _Key, _Val, 
.br
_KeyOfValue, _Compare, _Alloc >
.br
::iterator \fB_M_insert_equal\fP (_Arg &&__v)"
.br
.ti -1c
.RI "template<class _II > void \fB_M_insert_equal\fP (_II __first, _II __last)"
.br
.ti -1c
.RI "template<typename _Arg > iterator \fB_M_insert_equal_\fP (const_iterator __position, _Arg &&__x)"
.br
.ti -1c
.RI "template<typename _Arg > _Rb_tree< _Key, _Val, 
.br
_KeyOfValue, _Compare, _Alloc >
.br
::iterator \fB_M_insert_equal_\fP (const_iterator __position, _Arg &&__v)"
.br
.ti -1c
.RI "template<typename _Arg > _Rb_tree< _Key, _Val, 
.br
_KeyOfValue, _Compare, _Alloc >
.br
::iterator \fB_M_insert_equal_lower\fP (_Arg &&__v)"
.br
.ti -1c
.RI "template<typename _Arg > _Rb_tree< _Key, _Val, 
.br
_KeyOfValue, _Compare, _Alloc >
.br
::iterator \fB_M_insert_lower\fP (_Base_ptr __p, _Arg &&__v)"
.br
.ti -1c
.RI "template<typename _Arg > \fBpair\fP< iterator, bool > \fB_M_insert_unique\fP (_Arg &&__x)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_insert_unique\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "template<typename _Arg > \fBpair\fP< typename _Rb_tree< _Key, 
.br
_Val, _KeyOfValue, _Compare, 
.br
_Alloc >::iterator, bool > \fB_M_insert_unique\fP (_Arg &&__v)"
.br
.ti -1c
.RI "template<class _II > void \fB_M_insert_unique\fP (_II __first, _II __last)"
.br
.ti -1c
.RI "template<typename _Arg > iterator \fB_M_insert_unique_\fP (const_iterator __position, _Arg &&__x)"
.br
.ti -1c
.RI "template<typename _Arg > _Rb_tree< _Key, _Val, 
.br
_KeyOfValue, _Compare, _Alloc >
.br
::iterator \fB_M_insert_unique_\fP (const_iterator __position, _Arg &&__v)"
.br
.ti -1c
.RI "iterator \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "const_iterator \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "size_type \fBcount\fP (const key_type &__k) const "
.br
.ti -1c
.RI "bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "iterator \fBend\fP () noexcept"
.br
.ti -1c
.RI "const_iterator \fBend\fP () const noexcept"
.br
.ti -1c
.RI "\fBpair\fP< iterator, iterator > \fBequal_range\fP (const key_type &__k)"
.br
.ti -1c
.RI "\fBpair\fP< const_iterator, 
.br
const_iterator > \fBequal_range\fP (const key_type &__k) const "
.br
.ti -1c
.RI "_GLIBCXX_ABI_TAG_CXX11 iterator \fBerase\fP (const_iterator __position)"
.br
.ti -1c
.RI "_GLIBCXX_ABI_TAG_CXX11 iterator \fBerase\fP (iterator __position)"
.br
.ti -1c
.RI "size_type \fBerase\fP (const key_type &__x)"
.br
.ti -1c
.RI "_GLIBCXX_ABI_TAG_CXX11 iterator \fBerase\fP (const_iterator __first, const_iterator __last)"
.br
.ti -1c
.RI "void \fBerase\fP (const key_type *__first, const key_type *__last)"
.br
.ti -1c
.RI "iterator \fBfind\fP (const key_type &__k)"
.br
.ti -1c
.RI "const_iterator \fBfind\fP (const key_type &__k) const "
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const noexcept"
.br
.ti -1c
.RI "_Compare \fBkey_comp\fP () const "
.br
.ti -1c
.RI "iterator \fBlower_bound\fP (const key_type &__k)"
.br
.ti -1c
.RI "const_iterator \fBlower_bound\fP (const key_type &__k) const "
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const noexcept"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const noexcept"
.br
.ti -1c
.RI "size_type \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "void \fBswap\fP (_Rb_tree &__t)"
.br
.ti -1c
.RI "iterator \fBupper_bound\fP (const key_type &__k)"
.br
.ti -1c
.RI "const_iterator \fBupper_bound\fP (const key_type &__k) const "
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef _Rb_tree_node_base * \fB_Base_ptr\fP"
.br
.ti -1c
.RI "typedef const _Rb_tree_node_base * \fB_Const_Base_ptr\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "_Link_type \fB_M_begin\fP ()"
.br
.ti -1c
.RI "_Const_Link_type \fB_M_begin\fP () const "
.br
.ti -1c
.RI "_Link_type \fB_M_clone_node\fP (_Const_Link_type __x)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> _Link_type \fB_M_create_node\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "void \fB_M_destroy_node\fP (_Link_type __p)"
.br
.ti -1c
.RI "_Link_type \fB_M_end\fP ()"
.br
.ti -1c
.RI "_Const_Link_type \fB_M_end\fP () const "
.br
.ti -1c
.RI "_Link_type \fB_M_get_node\fP ()"
.br
.ti -1c
.RI "_Base_ptr & \fB_M_leftmost\fP ()"
.br
.ti -1c
.RI "_Const_Base_ptr \fB_M_leftmost\fP () const "
.br
.ti -1c
.RI "void \fB_M_put_node\fP (_Link_type __p)"
.br
.ti -1c
.RI "_Base_ptr & \fB_M_rightmost\fP ()"
.br
.ti -1c
.RI "_Const_Base_ptr \fB_M_rightmost\fP () const "
.br
.ti -1c
.RI "_Base_ptr & \fB_M_root\fP ()"
.br
.ti -1c
.RI "_Const_Base_ptr \fB_M_root\fP () const "
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const _Key & \fB_S_key\fP (_Const_Link_type __x)"
.br
.ti -1c
.RI "static const _Key & \fB_S_key\fP (_Const_Base_ptr __x)"
.br
.ti -1c
.RI "static _Link_type \fB_S_left\fP (_Base_ptr __x)"
.br
.ti -1c
.RI "static _Const_Link_type \fB_S_left\fP (_Const_Base_ptr __x)"
.br
.ti -1c
.RI "static _Base_ptr \fB_S_maximum\fP (_Base_ptr __x)"
.br
.ti -1c
.RI "static _Const_Base_ptr \fB_S_maximum\fP (_Const_Base_ptr __x)"
.br
.ti -1c
.RI "static _Base_ptr \fB_S_minimum\fP (_Base_ptr __x)"
.br
.ti -1c
.RI "static _Const_Base_ptr \fB_S_minimum\fP (_Const_Base_ptr __x)"
.br
.ti -1c
.RI "static _Link_type \fB_S_right\fP (_Base_ptr __x)"
.br
.ti -1c
.RI "static _Const_Link_type \fB_S_right\fP (_Const_Base_ptr __x)"
.br
.ti -1c
.RI "static const_reference \fB_S_value\fP (_Const_Link_type __x)"
.br
.ti -1c
.RI "static const_reference \fB_S_value\fP (_Const_Base_ptr __x)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_Rb_tree_impl< _Compare > \fB_M_impl\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class _Key, class _Value, class _KeyOfValue, class _Compare, class _Alloc = allocator<_Value>>struct __gnu_cxx::rb_tree< _Key, _Value, _KeyOfValue, _Compare, _Alloc >"
This be a SGI extension\&.
.PP
\fBTodo\fP
.RS 4
Needz documentation! See http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html 
.RE
.PP

.PP
Definizzle at line 80 of file rb_tree\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
