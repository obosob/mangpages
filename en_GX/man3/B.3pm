.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B 3pm"
.TH B 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
B \- Da Perl Compila Backend
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use B;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`B\*(C'\fR module supplies classes which allow a Perl program ta delve
into its own innards.  It be tha module used ta implement the
\&\*(L"backends\*(R" of tha Perl compila n' shit.  Usage of tha compila do not
require knowledge of dis module: peep tha \fIO\fR module fo' the
user-visible part.  Da \f(CW\*(C`B\*(C'\fR module iz of use ta dem playas whoz ass want to
write freshly smoked up compila backends.  This documentation assumes dat the
reader knows a gangbangin' fair amount bout perlz internals includin such
things as SVs, OPs n' tha internal symbol table n' syntax tree
of a program.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Da \f(CW\*(C`B\*(C'\fR module gotz nuff a set of utilitizzle functions fo' queryin the
current state of tha Perl interpreter; typically these functions
return objects from tha B::SV n' B::OP classes, or they derived
classes.  These classes up in turn define methodz fo' queryin the
resultin objects bout they own internal state.
.SH "Utilitizzle Functions"
.IX Header "Utilitizzle Functions"
Da \f(CW\*(C`B\*(C'\fR module exports a variety of functions: some is simple
utilitizzle functions, others provide a Perl program wit a way to
get a initial \*(L"handle\*(R" on a internal object.
.ie n .SS "Functions Returnin ""B::SV"", ""B::AV"", ""B::HV"", n' ""B::CV"" objects"
.el .SS "Functions Returnin \f(CWB::SV\fP, \f(CWB::AV\fP, \f(CWB::HV\fP, n' \f(CWB::CV\fP objects"
.IX Subsection "Functions Returnin B::SV, B::AV, B::HV, n' B::CV objects"
For descriptionz of tha class hierarchy of these objects n' the
methodz dat can be called on them, peep below, \*(L"\s-1OVERVIEW OF
CLASSES\*(R"\s0 n' \*(L"SV-RELATED \s-1CLASSES\*(R"\s0.
.IP "sv_undef" 4
.IX Item "sv_undef"
Returns tha \s-1SV\s0 object correspondin ta tha C variable \f(CW\*(C`sv_undef\*(C'\fR.
.IP "sv_yes" 4
.IX Item "sv_yes"
Returns tha \s-1SV\s0 object correspondin ta tha C variable \f(CW\*(C`sv_yes\*(C'\fR.
.IP "sv_no" 4
.IX Item "sv_no"
Returns tha \s-1SV\s0 object correspondin ta tha C variable \f(CW\*(C`sv_no\*(C'\fR.
.IP "svref_2object(\s-1SVREF\s0)" 4
.IX Item "svref_2object(SVREF)"
Takes a reference ta any Perl value, n' turns tha referred-to value
into a object up in tha appropriate B::OP\-derived or B::SV\-derived
class.  Apart from functions like fuckin \f(CW\*(C`main_root\*(C'\fR, dis is tha primary
way ta git a initial \*(L"handle\*(R" on a internal perl data structure
which can then be followed wit tha other access methods.
.Sp
Da returned object will only be valid as long as tha underlyin OPs
and SVs continue ta exist.  Do not attempt ta use tha object afta the
underlyin structures is freed.
.IP "amagic_generation" 4
.IX Item "amagic_generation"
Returns tha \s-1SV\s0 object correspondin ta tha C variable \f(CW\*(C`amagic_generation\*(C'\fR.
Az of Perl 5.18, dis is just a alias ta \f(CW\*(C`PL_na\*(C'\fR, so its value is
meaningless.
.IP "init_av" 4
.IX Item "init_av"
Returns tha \s-1AV\s0 object (i.e. up in class B::AV) representin \s-1INIT\s0 blocks.
.IP "check_av" 4
.IX Item "check_av"
Returns tha \s-1AV\s0 object (i.e. up in class B::AV) representin \s-1CHECK\s0 blocks.
.IP "unitcheck_av" 4
.IX Item "unitcheck_av"
Returns tha \s-1AV\s0 object (i.e. up in class B::AV) representin \s-1UNITCHECK\s0 blocks.
.IP "begin_av" 4
.IX Item "begin_av"
Returns tha \s-1AV\s0 object (i.e. up in class B::AV) representin \s-1BEGIN\s0 blocks.
.IP "end_av" 4
.IX Item "end_av"
Returns tha \s-1AV\s0 object (i.e. up in class B::AV) representin \s-1END\s0 blocks.
.IP "comppadlist" 4
.IX Item "comppadlist"
Returns tha \s-1AV\s0 object (i.e. up in class B::AV) of tha global comppadlist.
.IP "regex_padav" 4
.IX Item "regex_padav"
Only when perl was compiled wit ithreads.
.IP "main_cv" 4
.IX Item "main_cv"
Return tha (faked) \s-1CV\s0 correspondin ta tha main part of tha Perl
program.
.SS "Functions fo' Examinin tha Symbol Table"
.IX Subsection "Functions fo' Examinin tha Symbol Table"
.IP "walksymtable(\s-1SYMREF, METHOD, RECURSE, PREFIX\s0)" 4
.IX Item "walksymtable(SYMREF, METHOD, RECURSE, PREFIX)"
Walk tha symbol table startin at \s-1SYMREF\s0 n' call \s-1METHOD\s0 on each
symbol (a B::GV object) hit up. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  When tha strutt reaches package
symbols (like fuckin \*(L"Foo::\*(R") it invokes \s-1RECURSE,\s0 passin up in tha symbol
name, n' only recurses tha fuck into tha package if dat sub returns true.
.Sp
\&\s-1PREFIX\s0 is tha name of tha \s-1SYMREF\s0 you strutting.
.Sp
For example:
.Sp
.Vb 4
\&  # Walk CGI\*(Aqs symbol table callin print_subs on each symbol.
\&  # Recurse only tha fuck into CGI::Util::
\&  struttsymtable(\e%CGI::, \*(Aqprint_subs\*(Aq,
\&               sub { $_[0] eq \*(AqCGI::Util::\*(Aq }, \*(AqCGI::\*(Aq);
.Ve
.Sp
\&\fIprint_subs()\fR be a B::GV method you have declared. Y'all KNOW dat shit, muthafucka!  Also peep \*(L"B::GV
Methods\*(R", below.
.ie n .SS "Functions Returnin ""B::OP"" objects or fo' struttin op trees"
.el .SS "Functions Returnin \f(CWB::OP\fP objects or fo' struttin op trees"
.IX Subsection "Functions Returnin B::OP objects or fo' struttin op trees"
For descriptionz of tha class hierarchy of these objects n' the
methodz dat can be called on them, peep below, \*(L"\s-1OVERVIEW OF
CLASSES\*(R"\s0 n' \*(L"OP-RELATED \s-1CLASSES\*(R"\s0.
.IP "main_root" 4
.IX Item "main_root"
Returns tha root op (i.e. a object up in tha appropriate B::OP\-derived
class) of tha main part of tha Perl program.
.IP "main_start" 4
.IX Item "main_start"
Returns tha startin op of tha main part of tha Perl program.
.IP "walkoptree(\s-1OP, METHOD\s0)" 4
.IX Item "walkoptree(OP, METHOD)"
Do a tree-walk of tha syntax tree based at \s-1OP\s0 n' calls \s-1METHOD\s0 on
each op it visits, n' you can put dat on yo' toast.  Each node is hit up before its lil' thugs.  If
\&\f(CW\*(C`walkoptree_debug\*(C'\fR (see below) has been called ta turn debuggin on then
the method \f(CW\*(C`walkoptree_debug\*(C'\fR is called on each op before \s-1METHOD\s0 is
called.
.IP "walkoptree_debug(\s-1DEBUG\s0)" 4
.IX Item "walkoptree_debug(DEBUG)"
Returns tha current debuggin flag fo' \f(CW\*(C`walkoptree\*(C'\fR.  If tha optional
\&\s-1DEBUG\s0 argument is non-zero, it sets tha debuggin flag ta dis shit.  See
the description of \f(CW\*(C`walkoptree\*(C'\fR above fo' what tha fuck tha debuggin flag
does.
.SS "Miscellaneous Utilitizzle Functions"
.IX Subsection "Miscellaneous Utilitizzle Functions"
.IP "ppname(\s-1OPNUM\s0)" 4
.IX Item "ppname(OPNUM)"
Return tha \s-1PP\s0 function name (e.g. \*(L"pp_add\*(R") of op number \s-1OPNUM.\s0
.IP "hash(\s-1STR\s0)" 4
.IX Item "hash(STR)"
Returns a strang up in tha form \*(L"0x...\*(R" representin tha value of the
internal hash function used by perl on strang \s-1STR.\s0
.IP "cast_I32(I)" 4
.IX Item "cast_I32(I)"
Casts I ta tha internal I32 type used by dat perl.
.IP "minus_c" 4
.IX Item "minus_c"
Do tha equivalent of tha \f(CW\*(C`\-c\*(C'\fR command-line option. I aint talkin' bout chicken n' gravy biatch.  Obviously, this
is only useful up in a \s-1BEGIN\s0 block or else tha flag is set too late.
.IP "cstring(\s-1STR\s0)" 4
.IX Item "cstring(STR)"
Returns a thugged-out double-quote-surrounded escaped version of \s-1STR\s0 which can
be used as a strang up in C source code.
.IP "perlstring(\s-1STR\s0)" 4
.IX Item "perlstring(STR)"
Returns a thugged-out double-quote-surrounded escaped version of \s-1STR\s0 which can
be used as a strang up in Perl source code.
.IP "class(\s-1OBJ\s0)" 4
.IX Item "class(OBJ)"
Returns tha class of a object without tha part of tha classname
precedin tha straight-up original gangsta \f(CW"::"\fR.  This is used ta turn \f(CW"B::UNOP"\fR into
\&\f(CW"UNOP"\fR fo' example.
.IP "threadsv_names" 4
.IX Item "threadsv_names"
In a perl compiled fo' threads, dis returns a list of tha special
per-thread threadsv variables.
.SS "Exported utilitizzle variables"
.IX Subsection "Exported utilitizzle variables"
.ie n .IP "@optype" 4
.el .IP "\f(CW@optype\fR" 4
.IX Item "@optype"
.Vb 1
\&  mah $op_type = $optype[$op_type_num];
.Ve
.Sp
A simple mappin of tha op type number ta its type (like '\s-1COP\s0' or '\s-1BINOP\s0').
.ie n .IP "@specialsv_name" 4
.el .IP "\f(CW@specialsv_name\fR" 4
.IX Item "@specialsv_name"
.Vb 1
\&  mah $sv_name = $specialsv_name[$sv_index];
.Ve
.Sp
Certain \s-1SV\s0 types is considered 'special'.  They're represented by
B::SPECIAL n' is referred ta by a number from tha specialsv_list.
This array maps dat number back ta tha name of tha \s-1SV \s0(like 'Nullsv'
or '&PL_sv_undef').
.SH "OVERVIEW OF CLASSES"
.IX Header "OVERVIEW OF CLASSES"
Da C structures used by Perlz internals ta hold \s-1SV\s0 n' \s-1OP\s0
information (\s-1PVIV, AV, HV, ..., OP, SVOP, UNOP, ...\s0) is modelled on a
class hierarchy n' tha \f(CW\*(C`B\*(C'\fR module gives access ta dem via a true
object hierarchy.  Structure fieldz which point ta other objects
(whether typez of \s-1SV\s0 or typez of \s-1OP\s0) is represented by tha \f(CW\*(C`B\*(C'\fR
module as Perl objectz of tha appropriate class.
.PP
Da bulk of tha \f(CW\*(C`B\*(C'\fR module is tha methodz fo' accessin fieldz of
these structures.
.PP
Note dat all access is read-only.  Yo ass cannot modify tha internals by
usin dis module.  Also, note dat tha B::OP n' B::SV objects pimped
by dis module is only valid fo' as long as tha underlyin objects
exist; they creation don't increase tha reference countz of the
underlyin objects, n' you can put dat on yo' toast.  Tryin ta access tha fieldz of a gangbangin' freed object will
give incomprehensible thangs up in dis biatch, or worse.
.SS "SV-RELATED \s-1CLASSES\s0"
.IX Subsection "SV-RELATED CLASSES"
B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and
earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO.  These classes
correspond up in tha obvious way ta tha underlyin C structurez of similar names.
Da inheritizzle hierarchy mimics tha underlyin C \*(L"inheritance\*(R".  For the
5.10.x branch, (\fIie\fR 5.10.0, 5.10.1 \fIetc\fR) dis is:
.PP
.Vb 10
\&                           B::SV
\&                             |
\&                +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&                |            |            |            |
\&              B::PV        B::IV        B::NV        B::RV
\&                  \e         /           /
\&                   \e       /           /
\&                    B::PVIV           /
\&                         \e           /
\&                          \e         /
\&                           \e       /
\&                            B::PVNV
\&                               |
\&                               |
\&                            B::PVMG
\&                               |
\&                   +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+
\&                   |     |     |     |     |
\&                 B::AV B::GV B::HV B::CV B::IO
\&                         |           |
\&                         |           |
\&                      B::PVLV      B::FM
.Ve
.PP
For 5.9.0 n' earlier, \s-1PVLV\s0 be a gangbangin' finger-lickin' direct subclass of \s-1PVMG,\s0 n' \s-1BM\s0 is still
present as a gangbangin' finger-lickin' distinct type, so tha base of dis diagram is
.PP
.Vb 10
\&                               |
\&                               |
\&                            B::PVMG
\&                               |
\&            +\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+
\&            |      |     |     |     |     |     |
\&         B::PVLV B::BM B::AV B::GV B::HV B::CV B::IO
\&                                           |
\&                                           |
\&                                         B::FM
.Ve
.PP
For 5.11.0 n' later, B::RV be abolished, n' IVs can be used ta store
references, n' a freshly smoked up type B::REGEXP is introduced, givin dis structure:
.PP
.Vb 10
\&                           B::SV
\&                             |
\&                +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&                |            |            |
\&              B::PV        B::IV        B::NV
\&                  \e         /           /
\&                   \e       /           /
\&                    B::PVIV           /
\&                         \e           /
\&                          \e         /
\&                           \e       /
\&                            B::PVNV
\&                               |
\&                               |
\&                            B::PVMG
\&                               |
\&           +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-+\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
\&           |       |       |       |       |       |
\&         B::AV   B::GV   B::HV   B::CV   B::IO B::REGEXP
\&                   |               |
\&                   |               |
\&                B::PVLV          B::FM
.Ve
.PP
Access methodz correspond ta tha underlyin C macros fo' field access,
usually wit tha leadin \*(L"class indication\*(R" prefix removed (Sv, Av,
Hv, ...).  Da leadin prefix is only left up in cases where its removal
would cause a cold-ass lil clash up in method name.  For example, \f(CW\*(C`GvREFCNT\*(C'\fR stays
as-is since its abbreviation would clash wit tha \*(L"superclass\*(R" method
\&\f(CW\*(C`REFCNT\*(C'\fR (correspondin ta tha C function \f(CW\*(C`SvREFCNT\*(C'\fR).
.SS "B::SV Methods"
.IX Subsection "B::SV Methods"
.IP "\s-1REFCNT\s0" 4
.IX Item "REFCNT"
.PD 0
.IP "\s-1FLAGS\s0" 4
.IX Item "FLAGS"
.IP "object_2svref" 4
.IX Item "object_2svref"
.PD
Returns a reference ta tha regular scalar correspondin ta this
B::SV object.  In other lyrics, dis method is tha inverse operation
to tha \fIsvref_2object()\fR subroutine.  This scalar n' other data it points
at should be considered read-only: modifyin dem is neither safe nor
guaranteed ta git a sensible effect.
.SS "B::IV Methods"
.IX Subsection "B::IV Methods"
.IP "\s-1IV\s0" 4
.IX Item "IV"
Returns tha value of tha \s-1IV, \s0\fIinterpreted as
a signed integer\fR.  This is ghon be misleading
if \f(CW\*(C`FLAGS & SVf_IVisUV\*(C'\fR.  Perhaps you want the
\&\f(CW\*(C`int_value\*(C'\fR method instead?
.IP "\s-1IVX\s0" 4
.IX Item "IVX"
.PD 0
.IP "\s-1UVX\s0" 4
.IX Item "UVX"
.IP "int_value" 4
.IX Item "int_value"
.PD
This method returns tha value of tha \s-1IV\s0 as a integer.
It differs from \f(CW\*(C`IV\*(C'\fR up in dat it returns tha erect
value regardless of whether itz stored signed or
unsigned.
.IP "needs64bits" 4
.IX Item "needs64bits"
.PD 0
.IP "packiv" 4
.IX Item "packiv"
.PD
.SS "B::NV Methods"
.IX Subsection "B::NV Methods"
.IP "\s-1NV\s0" 4
.IX Item "NV"
.PD 0
.IP "\s-1NVX\s0" 4
.IX Item "NVX"
.PD
.SS "B::RV Methods"
.IX Subsection "B::RV Methods"
.IP "\s-1RV\s0" 4
.IX Item "RV"
.SS "B::PV Methods"
.IX Subsection "B::PV Methods"
.PD 0
.IP "\s-1PV\s0" 4
.IX Item "PV"
.PD
This method is tha one you probably want.  It constructs a
strin rockin tha length n' offset shiznit up in tha struct:
for ordinary scalars it will return tha strang dat you'd see
from Perl, even if it gotz nuff null characters.
.IP "\s-1RV\s0" 4
.IX Item "RV"
Same as B::RV::RV, except dat it will \fIdie()\fR if tha \s-1PV\s0 aint
a reference.
.IP "\s-1PVX\s0" 4
.IX Item "PVX"
This method is less often useful naaahhmean, biatch?  It assumes dat tha string
stored up in tha struct is null-terminated, n' disregardz the
length shiznit.
.Sp
It be tha appropriate method ta use if you need ta git tha name
of a lexical variable from a padname array.  Lexical variable names
are always stored wit a null terminator, n' tha length field
(\s-1CUR\s0) is overloaded fo' other purposes n' can't be relied on here.
.IP "\s-1CUR\s0" 4
.IX Item "CUR"
This method returns tha internal length field, which consistz of tha number
of internal bytes, not necessarily tha number of logical characters.
.IP "\s-1LEN\s0" 4
.IX Item "LEN"
This method returns tha number of bytes allocated (via malloc) fo' storing
the string.  This is 0 if tha scalar do not \*(L"own\*(R" tha string.
.SS "B::PVMG Methods"
.IX Subsection "B::PVMG Methods"
.IP "\s-1MAGIC\s0" 4
.IX Item "MAGIC"
.PD 0
.IP "SvSTASH" 4
.IX Item "SvSTASH"
.PD
.SS "B::MAGIC Methods"
.IX Subsection "B::MAGIC Methods"
.IP "\s-1MOREMAGIC\s0" 4
.IX Item "MOREMAGIC"
.PD 0
.IP "precomp" 4
.IX Item "precomp"
.PD
Only valid on r\-magic, returns tha strang dat generated tha regexp.
.IP "\s-1PRIVATE\s0" 4
.IX Item "PRIVATE"
.PD 0
.IP "\s-1TYPE\s0" 4
.IX Item "TYPE"
.IP "\s-1FLAGS\s0" 4
.IX Item "FLAGS"
.IP "\s-1OBJ\s0" 4
.IX Item "OBJ"
.PD
Will \fIdie()\fR if called on r\-magic.
.IP "\s-1PTR\s0" 4
.IX Item "PTR"
.PD 0
.IP "\s-1REGEX\s0" 4
.IX Item "REGEX"
.PD
Only valid on r\-magic, returns tha integer value of tha \s-1REGEX\s0 stored
in tha \s-1MAGIC.\s0
.SS "B::PVLV Methods"
.IX Subsection "B::PVLV Methods"
.IP "\s-1TARGOFF\s0" 4
.IX Item "TARGOFF"
.PD 0
.IP "\s-1TARGLEN\s0" 4
.IX Item "TARGLEN"
.IP "\s-1TYPE\s0" 4
.IX Item "TYPE"
.IP "\s-1TARG\s0" 4
.IX Item "TARG"
.PD
.SS "B::BM Methods"
.IX Subsection "B::BM Methods"
.IP "\s-1USEFUL\s0" 4
.IX Item "USEFUL"
.PD 0
.IP "\s-1PREVIOUS\s0" 4
.IX Item "PREVIOUS"
.IP "\s-1RARE\s0" 4
.IX Item "RARE"
.IP "\s-1TABLE\s0" 4
.IX Item "TABLE"
.PD
.SS "B::GV Methods"
.IX Subsection "B::GV Methods"
.IP "is_empty" 4
.IX Item "is_empty"
This method returns \s-1TRUE\s0 if tha \s-1GP\s0 field of tha \s-1GV\s0 is \s-1NULL.\s0
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
.PD 0
.IP "\s-1SAFENAME\s0" 4
.IX Item "SAFENAME"
.PD
This method returns tha name of tha glob yo, but if tha first
characta of tha name be a cold-ass lil control character, then it converts
it ta ^X first, so dat *^G would return \*(L"^G\*(R" rather than \*(L"\ecG\*(R".
.Sp
It aint nuthin but useful if you wanna print up tha name of a variable.
If you restrict yo ass ta globs which exist at compile-time
then tha result ought ta be unambiguous, cuz code like
\&\f(CW\*(C`${"^G"} = 1\*(C'\fR is compiled as two ops \- a cold-ass lil constant strang and
a dereference (rv2gv) \- so dat tha glob is pimped at runtime.
.Sp
If you hustlin wit globs at runtime, n' need ta disambiguate
*^G from *{\*(L"^G\*(R"}, then you should use tha raw \s-1NAME\s0 method.
.IP "\s-1STASH\s0" 4
.IX Item "STASH"
.PD 0
.IP "\s-1SV\s0" 4
.IX Item "SV"
.IP "\s-1IO\s0" 4
.IX Item "IO"
.IP "\s-1FORM\s0" 4
.IX Item "FORM"
.IP "\s-1AV\s0" 4
.IX Item "AV"
.IP "\s-1HV\s0" 4
.IX Item "HV"
.IP "\s-1EGV\s0" 4
.IX Item "EGV"
.IP "\s-1CV\s0" 4
.IX Item "CV"
.IP "\s-1CVGEN\s0" 4
.IX Item "CVGEN"
.IP "\s-1LINE\s0" 4
.IX Item "LINE"
.IP "\s-1FILE\s0" 4
.IX Item "FILE"
.IP "\s-1FILEGV\s0" 4
.IX Item "FILEGV"
.IP "GvREFCNT" 4
.IX Item "GvREFCNT"
.IP "\s-1FLAGS\s0" 4
.IX Item "FLAGS"
.PD
.SS "B::IO Methods"
.IX Subsection "B::IO Methods"
B::IO objects derive from \s-1IO\s0 objects n' yo big-ass booty is ghon git mo' shiznit from
the \s-1IO\s0 object itself.
.PP
For example:
.PP
.Vb 3
\&  $gvio = B::svref_2object(\e*main::stdin)\->IO;
\&  $IO = $gvio\->object_2svref();
\&  $fd = $IO\->fileno();
.Ve
.IP "\s-1LINES\s0" 4
.IX Item "LINES"
.PD 0
.IP "\s-1PAGE\s0" 4
.IX Item "PAGE"
.IP "\s-1PAGE_LEN\s0" 4
.IX Item "PAGE_LEN"
.IP "\s-1LINES_LEFT\s0" 4
.IX Item "LINES_LEFT"
.IP "\s-1TOP_NAME\s0" 4
.IX Item "TOP_NAME"
.IP "\s-1TOP_GV\s0" 4
.IX Item "TOP_GV"
.IP "\s-1FMT_NAME\s0" 4
.IX Item "FMT_NAME"
.IP "\s-1FMT_GV\s0" 4
.IX Item "FMT_GV"
.IP "\s-1BOTTOM_NAME\s0" 4
.IX Item "BOTTOM_NAME"
.IP "\s-1BOTTOM_GV\s0" 4
.IX Item "BOTTOM_GV"
.IP "\s-1SUBPROCESS\s0" 4
.IX Item "SUBPROCESS"
.IP "IoTYPE" 4
.IX Item "IoTYPE"
.PD
A characta symbolizin tha type of \s-1IO\s0 Handle.
.Sp
.Vb 12
\&  \-     STDIN/OUT
\&  I     STDIN/OUT/ERR
\&  <     read\-only
\&  >     write\-only
\&  a     append
\&  +     read n' write
\&  s     socket
\&  |     pipe
\&  I     IMPLICIT
\&  #     NUMERIC
\&  space closed handle
\&  \e0    closed internal handle
.Ve
.IP "IoFLAGS" 4
.IX Item "IoFLAGS"
.PD 0
.IP "IsSTD" 4
.IX Item "IsSTD"
.PD
Takes one argument ( 'stdin' | 'stdout' | 'stderr' ) n' returns true
if tha IoIFP of tha object is equal ta tha handle whose name was
passed as argument; i.e., \f(CW$io\fR\->IsSTD('stderr') is legit if
IoIFP($io) == \fIPerlIO_stderr()\fR.
.SS "B::AV Methods"
.IX Subsection "B::AV Methods"
.IP "\s-1FILL\s0" 4
.IX Item "FILL"
.PD 0
.IP "\s-1MAX\s0" 4
.IX Item "MAX"
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
.IP "ARRAYelt" 4
.IX Item "ARRAYelt"
.PD
Like \f(CW\*(C`ARRAY\*(C'\fR yo, but takes a index as a argument ta git only one element,
rather than a list of all of em.
.IP "\s-1OFF\s0" 4
.IX Item "OFF"
This method is deprecated if hustlin under Perl 5.8, n' is no longer present
if hustlin under Perl 5.9
.IP "AvFLAGS" 4
.IX Item "AvFLAGS"
This method returns tha \s-1AV\s0 specific
flags.  In Perl 5.9 these is now stored
in wit tha main \s-1SV\s0 flags, so dis method is no longer present.
.SS "B::CV Methods"
.IX Subsection "B::CV Methods"
.IP "\s-1STASH\s0" 4
.IX Item "STASH"
.PD 0
.IP "\s-1START\s0" 4
.IX Item "START"
.IP "\s-1ROOT\s0" 4
.IX Item "ROOT"
.IP "\s-1GV\s0" 4
.IX Item "GV"
.IP "\s-1FILE\s0" 4
.IX Item "FILE"
.IP "\s-1DEPTH\s0" 4
.IX Item "DEPTH"
.IP "\s-1PADLIST\s0" 4
.IX Item "PADLIST"
.IP "\s-1OUTSIDE\s0" 4
.IX Item "OUTSIDE"
.IP "\s-1OUTSIDE_SEQ\s0" 4
.IX Item "OUTSIDE_SEQ"
.IP "\s-1XSUB\s0" 4
.IX Item "XSUB"
.IP "\s-1XSUBANY\s0" 4
.IX Item "XSUBANY"
.PD
For constant subroutines, returns tha constant \s-1SV\s0 returned by tha subroutine.
.IP "CvFLAGS" 4
.IX Item "CvFLAGS"
.PD 0
.IP "const_sv" 4
.IX Item "const_sv"
.IP "\s-1NAME_HEK\s0" 4
.IX Item "NAME_HEK"
.PD
Returns tha name of a lexical sub, otherwise \f(CW\*(C`undef\*(C'\fR.
.SS "B::HV Methods"
.IX Subsection "B::HV Methods"
.IP "\s-1FILL\s0" 4
.IX Item "FILL"
.PD 0
.IP "\s-1MAX\s0" 4
.IX Item "MAX"
.IP "\s-1KEYS\s0" 4
.IX Item "KEYS"
.IP "\s-1RITER\s0" 4
.IX Item "RITER"
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
.IP "\s-1PMROOT\s0" 4
.IX Item "PMROOT"
.PD
This method aint present if hustlin under Perl 5.9, as tha \s-1PMROOT\s0
information is no longer stored directly up in tha hash.
.SS "OP-RELATED \s-1CLASSES\s0"
.IX Subsection "OP-RELATED CLASSES"
\&\f(CW\*(C`B::OP\*(C'\fR, \f(CW\*(C`B::UNOP\*(C'\fR, \f(CW\*(C`B::BINOP\*(C'\fR, \f(CW\*(C`B::LOGOP\*(C'\fR, \f(CW\*(C`B::LISTOP\*(C'\fR, \f(CW\*(C`B::PMOP\*(C'\fR,
\&\f(CW\*(C`B::SVOP\*(C'\fR, \f(CW\*(C`B::PADOP\*(C'\fR, \f(CW\*(C`B::PVOP\*(C'\fR, \f(CW\*(C`B::LOOP\*(C'\fR, \f(CW\*(C`B::COP\*(C'\fR.
.PP
These classes correspond up in tha obvious way ta tha underlyin C
structurez of similar names.  Da inheritizzle hierarchy mimics the
underlyin C \*(L"inheritance\*(R":
.PP
.Vb 10
\&                                 B::OP
\&                                   |
\&                   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
\&                   |               |        |        |       |
\&                B::UNOP          B::SVOP B::PADOP  B::COP  B::PVOP
\&                 ,\*(Aq  \`\-.
\&                /       \`\-\-.
\&           B::BINOP     B::LOGOP
\&               |
\&               |
\&           B::LISTOP
\&             ,\*(Aq \`.
\&            /     \e
\&        B::LOOP B::PMOP
.Ve
.PP
Access methodz correspond ta tha underlyin C structre field names,
with tha leadin \*(L"class indication\*(R" prefix (\f(CW"op_"\fR) removed.
.SS "B::OP Methods"
.IX Subsection "B::OP Methods"
These methodz git tha jointz of similarly named fieldz within tha \s-1OP\s0
data structure.  See top of \f(CW\*(C`op.h\*(C'\fR fo' mo' info.
.IP "next" 4
.IX Item "next"
.PD 0
.IP "sibling" 4
.IX Item "sibling"
.IP "name" 4
.IX Item "name"
.PD
This returns tha op name as a strang (e.g. \*(L"add\*(R", \*(L"rv2av\*(R").
.IP "ppaddr" 4
.IX Item "ppaddr"
This returns tha function name as a strang (e.g. \*(L"PL_ppaddr[\s-1OP_ADD\s0]\*(R",
\&\*(L"PL_ppaddr[\s-1OP_RV2AV\s0]\*(R").
.IP "desc" 4
.IX Item "desc"
This returns tha op description from tha global C PL_op_desc array
(e.g. \*(L"addition\*(R" \*(L"array deref\*(R").
.IP "targ" 4
.IX Item "targ"
.PD 0
.IP "type" 4
.IX Item "type"
.IP "opt" 4
.IX Item "opt"
.IP "flags" 4
.IX Item "flags"
.IP "private" 4
.IX Item "private"
.IP "spare" 4
.IX Item "spare"
.PD
.SS "B::UNOP \s-1METHOD\s0"
.IX Subsection "B::UNOP METHOD"
.IP "first" 4
.IX Item "first"
.SS "B::BINOP \s-1METHOD\s0"
.IX Subsection "B::BINOP METHOD"
.PD 0
.IP "last" 4
.IX Item "last"
.PD
.SS "B::LOGOP \s-1METHOD\s0"
.IX Subsection "B::LOGOP METHOD"
.IP "other" 4
.IX Item "other"
.SS "B::LISTOP \s-1METHOD\s0"
.IX Subsection "B::LISTOP METHOD"
.PD 0
.IP "children" 4
.IX Item "children"
.PD
.SS "B::PMOP Methods"
.IX Subsection "B::PMOP Methods"
.IP "pmreplroot" 4
.IX Item "pmreplroot"
.PD 0
.IP "pmreplstart" 4
.IX Item "pmreplstart"
.IP "pmnext" 4
.IX Item "pmnext"
.PD
Only up ta Perl 5.9.4
.IP "pmflags" 4
.IX Item "pmflags"
.PD 0
.IP "extflags" 4
.IX Item "extflags"
.PD
Since Perl 5.9.5
.IP "precomp" 4
.IX Item "precomp"
.PD 0
.IP "pmoffset" 4
.IX Item "pmoffset"
.PD
Only when perl was compiled wit ithreads.
.IP "code_list" 4
.IX Item "code_list"
Since perl 5.17.1
.SS "B::SVOP \s-1METHOD\s0"
.IX Subsection "B::SVOP METHOD"
.IP "sv" 4
.IX Item "sv"
.PD 0
.IP "gv" 4
.IX Item "gv"
.PD
.SS "B::PADOP \s-1METHOD\s0"
.IX Subsection "B::PADOP METHOD"
.IP "padix" 4
.IX Item "padix"
.SS "B::PVOP \s-1METHOD\s0"
.IX Subsection "B::PVOP METHOD"
.PD 0
.IP "pv" 4
.IX Item "pv"
.PD
.SS "B::LOOP Methods"
.IX Subsection "B::LOOP Methods"
.IP "redoop" 4
.IX Item "redoop"
.PD 0
.IP "nextop" 4
.IX Item "nextop"
.IP "lastop" 4
.IX Item "lastop"
.PD
.SS "B::COP Methods"
.IX Subsection "B::COP Methods"
.IP "label" 4
.IX Item "label"
.PD 0
.IP "stash" 4
.IX Item "stash"
.IP "stashpv" 4
.IX Item "stashpv"
.IP "stashoff (threaded only)" 4
.IX Item "stashoff (threaded only)"
.IP "file" 4
.IX Item "file"
.IP "cop_seq" 4
.IX Item "cop_seq"
.IP "arybase" 4
.IX Item "arybase"
.IP "line" 4
.IX Item "line"
.IP "warnings" 4
.IX Item "warnings"
.IP "io" 4
.IX Item "io"
.IP "hints" 4
.IX Item "hints"
.IP "hints_hash" 4
.IX Item "hints_hash"
.PD
.ie n .SS "$B::overlay"
.el .SS "\f(CW$B::overlay\fP"
.IX Subsection "$B::overlay"
Although tha optree is read-only, there be a overlay facilitizzle dat allows
you ta override what tha fuck joints tha various B::*OP methodz return fo' a
particular op. \f(CW$B::overlay\fR should be set ta reference a two-deep hash:
indexed by \s-1OP\s0 address, then method name. Whenever a a op method is
called, tha value up in tha hash is returned if it exists, n' you can put dat on yo' toast. This facilitizzle is
used by B::Deparse ta \*(L"undo\*(R" some optimisations. For example:
.PP
.Vb 11
\&    local $B::overlay = {};
\&    ...
\&    if ($op\->name eq "foo") {
\&        $B::overlay\->{$$op} = {
\&                name => \*(Aqbar\*(Aq,
\&                next => $op\->next\->next,
\&        };
\&    }
\&    ...
\&    $op\->name # returns "bar"
\&    $op\->next # returns tha next op but one
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, \f(CW\*(C`mbeattie@sable.ox.ac.uk\*(C'\fR
