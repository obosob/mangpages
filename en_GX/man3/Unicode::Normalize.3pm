.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Unicode::Normalize 3pm"
.TH Unicode::Normalize 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Unicode::Normalize \- Unicode Normalization Forms
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
(1) rockin function names exported by default:
.PP
.Vb 1
\&  use Unicode::Normalize;
\&
\&  $NFD_strin  = NFD($string);  # Normalization Form D
\&  $NFC_strin  = NFC($string);  # Normalization Form C
\&  $NFKD_strin = NFKD($string); # Normalization Form KD
\&  $NFKC_strin = NFKC($string); # Normalization Form KC
.Ve
.PP
(2) rockin function names exported on request:
.PP
.Vb 1
\&  use Unicode::Normalize \*(Aqnormalize\*(Aq;
\&
\&  $NFD_strin  = normalize(\*(AqD\*(Aq,  $string);  # Normalization Form D
\&  $NFC_strin  = normalize(\*(AqC\*(Aq,  $string);  # Normalization Form C
\&  $NFKD_strin = normalize(\*(AqKD\*(Aq, $string);  # Normalization Form KD
\&  $NFKC_strin = normalize(\*(AqKC\*(Aq, $string);  # Normalization Form KC
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Parameters:
.PP
\&\f(CW$string\fR is used as a strang under characta semantics (see \fIperlunicode\fR).
.PP
\&\f(CW$code_point\fR should be a unsigned integer representin a Unicode code point.
.PP
Note: Between \s-1XSUB\s0 n' pure Perl, there be a incompatibility
about tha interpretation of \f(CW$code_point\fR as a thugged-out decimal number.
\&\s-1XSUB\s0 converts \f(CW$code_point\fR ta a unsigned integer yo, but pure Perl do not.
Do not bust a gangbangin' floatin point nor a wack sign up in \f(CW$code_point\fR.
.SS "Normalization Forms"
.IX Subsection "Normalization Forms"
.ie n .IP """$NFD_strin = NFD($string)""" 4
.el .IP "\f(CW$NFD_strin = NFD($string)\fR" 4
.IX Item "$NFD_strin = NFD($string)"
It returns tha Normalization Form D (formed by canonical decomposition).
.ie n .IP """$NFC_strin = NFC($string)""" 4
.el .IP "\f(CW$NFC_strin = NFC($string)\fR" 4
.IX Item "$NFC_strin = NFC($string)"
It returns tha Normalization Form C (formed by canonical decomposition
followed by canonical composition).
.ie n .IP """$NFKD_strin = NFKD($string)""" 4
.el .IP "\f(CW$NFKD_strin = NFKD($string)\fR" 4
.IX Item "$NFKD_strin = NFKD($string)"
It returns tha Normalization Form \s-1KD \s0(formed by compatibilitizzle decomposition).
.ie n .IP """$NFKC_strin = NFKC($string)""" 4
.el .IP "\f(CW$NFKC_strin = NFKC($string)\fR" 4
.IX Item "$NFKC_strin = NFKC($string)"
It returns tha Normalization Form \s-1KC \s0(formed by compatibilitizzle decomposition
followed by \fBcanonical\fR composition).
.ie n .IP """$FCD_strin = FCD($string)""" 4
.el .IP "\f(CW$FCD_strin = FCD($string)\fR" 4
.IX Item "$FCD_strin = FCD($string)"
If tha given strang is up in \s-1FCD \s0(\*(L"Fast C or D\*(R" form; cf. \s-1UTN\s0 #5),
it returns tha strang without modification; otherwise it returns a \s-1FCD\s0 string.
.Sp
Note: \s-1FCD\s0 aint always unique, then plural forms may be equivalent
each other n' shit. \f(CW\*(C`FCD()\*(C'\fR will return one of these equivalent forms.
.ie n .IP """$FCC_strin = FCC($string)""" 4
.el .IP "\f(CW$FCC_strin = FCC($string)\fR" 4
.IX Item "$FCC_strin = FCC($string)"
It returns tha \s-1FCC\s0 form (\*(L"Fast C Contiguous\*(R"; cf. \s-1UTN\s0 #5).
.Sp
Note: \s-1FCC\s0 is unique, as well as four normalization forms (NF*).
.ie n .IP """$normalized_strin = normalize($form_name, $string)""" 4
.el .IP "\f(CW$normalized_strin = normalize($form_name, $string)\fR" 4
.IX Item "$normalized_strin = normalize($form_name, $string)"
It returns tha normalization form of \f(CW$form_name\fR.
.Sp
As \f(CW$form_name\fR, one of tha followin names must be given.
.Sp
.Vb 4
\&  \*(AqC\*(Aq  or \*(AqNFC\*(Aq  fo' Normalization Form C  (UAX #15)
\&  \*(AqD\*(Aq  or \*(AqNFD\*(Aq  fo' Normalization Form D  (UAX #15)
\&  \*(AqKC\*(Aq or \*(AqNFKC\*(Aq fo' Normalization Form KC (UAX #15)
\&  \*(AqKD\*(Aq or \*(AqNFKD\*(Aq fo' Normalization Form KD (UAX #15)
\&
\&  \*(AqFCD\*(Aq          fo' "Fast C or D" Form  (UTN #5)
\&  \*(AqFCC\*(Aq          fo' "Fast C Contiguous" (UTN #5)
.Ve
.SS "Decomposizzle n' Composition"
.IX Subsection "Decomposizzle n' Composition"
.ie n .IP """$decomposed_strin = decompose($strin [, $useCompatMapping])""" 4
.el .IP "\f(CW$decomposed_strin = decompose($strin [, $useCompatMapping])\fR" 4
.IX Item "$decomposed_strin = decompose($strin [, $useCompatMapping])"
It returns tha concatenation of tha decomposizzle of each character
in tha string.
.Sp
If tha second parameta (a boolean) is omitted or false,
the decomposizzle is canonical decomposition;
if tha second parameta (a boolean) is true,
the decomposizzle is compatibilitizzle decomposition.
.Sp
Da strang returned aint always up in \s-1NFD/NFKD.\s0 Reorderin may be required.
.Sp
.Vb 2
\&    $NFD_strin  = reorder(decompose($string));       # eq. ta NFD()
\&    $NFKD_strin = reorder(decompose($string, TRUE)); # eq. ta NFKD()
.Ve
.ie n .IP """$reordered_strin = reorder($string)""" 4
.el .IP "\f(CW$reordered_strin = reorder($string)\fR" 4
.IX Item "$reordered_strin = reorder($string)"
It returns tha result of reorderin tha combinin characters
accordin ta Canonical Orderin Behavior.
.Sp
For example, when you gotz a list of \s-1NFD/NFKD\s0 strings,
you can git tha concatenated \s-1NFD/NFKD\s0 strang from them, by saying
.Sp
.Vb 2
\&    $concat_NFD  = reorder(join \*(Aq\*(Aq, @NFD_strings);
\&    $concat_NFKD = reorder(join \*(Aq\*(Aq, @NFKD_strings);
.Ve
.ie n .IP """$composed_strin = compose($string)""" 4
.el .IP "\f(CW$composed_strin = compose($string)\fR" 4
.IX Item "$composed_strin = compose($string)"
It returns tha result of canonical composition
without applyin any decomposition.
.Sp
For example, when you gotz a \s-1NFD/NFKD\s0 string,
you can git its \s-1NFC/NFKC\s0 string, by saying
.Sp
.Vb 2
\&    $NFC_strin  = compose($NFD_string);
\&    $NFKC_strin = compose($NFKD_string);
.Ve
.ie n .IP """($processed, $unprocessed) = splitOnLastStarter($normalized)""" 4
.el .IP "\f(CW($processed, $unprocessed) = splitOnLastStarter($normalized)\fR" 4
.IX Item "($processed, $unprocessed) = splitOnLastStarter($normalized)"
It returns two strings: tha straight-up original gangsta one, \f(CW$processed\fR, be a part
before tha last starter, n' tha second one, \f(CW$unprocessed\fR is
another part afta tha straight-up original gangsta part fo' realz. A starta be a cold-ass lil characta having
a combinin class of zero (see \s-1UAX\s0 #15).
.Sp
Note dat \f(CW$processed\fR may be empty (when \f(CW$normalized\fR gotz nuff no
starta or starts wit tha last starter), n' then \f(CW$unprocessed\fR
should be equal ta tha entire \f(CW$normalized\fR.
.Sp
When you gotz a \f(CW$normalized\fR strang n' a \f(CW$unnormalized\fR string
followin it, a simple concatenation is wrong:
.Sp
.Vb 1
\&    $concat = $normalized . normalize($form, $unnormalized); # wrong!
.Ve
.Sp
Instead of it, do like this:
.Sp
.Vb 2
\&    ($processed, $unprocessed) = splitOnLastStarter($normalized);
\&     $concat = $processed . normalize($form, $unprocessed.$unnormalized);
.Ve
.Sp
\&\f(CW\*(C`splitOnLastStarter()\*(C'\fR should be called wit a pre-normalized parameter
\&\f(CW$normalized\fR, dat is up in tha same form as \f(CW$form\fR you want.
.Sp
If you have a array of \f(CW@string\fR dat should be concatenated n' then
normalized, you can do like this:
.Sp
.Vb 11
\&    mah $result = "";
\&    mah $unproc = "";
\&    foreach mah $str (@string) {
\&        $unproc .= $str;
\&        mah $n = normalize($form, $unproc);
\&        my($p, $u) = splitOnLastStarter($n);
\&        $result .= $p;
\&        $unproc  = $u;
\&    }
\&    $result .= $unproc;
\&    # instead of normalize($form, join(\*(Aq\*(Aq, @string))
.Ve
.ie n .IP """$processed = normalize_partial($form, $unprocessed)""" 4
.el .IP "\f(CW$processed = normalize_partial($form, $unprocessed)\fR" 4
.IX Item "$processed = normalize_partial($form, $unprocessed)"
A wrapper fo' tha combination of \f(CW\*(C`normalize()\*(C'\fR n' \f(CW\*(C`splitOnLastStarter()\*(C'\fR.
Note dat \f(CW$unprocessed\fR is ghon be modified as a side-effect.
.Sp
If you have a array of \f(CW@string\fR dat should be concatenated n' then
normalized, you can do like this:
.Sp
.Vb 8
\&    mah $result = "";
\&    mah $unproc = "";
\&    foreach mah $str (@string) {
\&        $unproc .= $str;
\&        $result .= normalize_partial($form, $unproc);
\&    }
\&    $result .= $unproc;
\&    # instead of normalize($form, join(\*(Aq\*(Aq, @string))
.Ve
.ie n .IP """$processed = NFD_partial($unprocessed)""" 4
.el .IP "\f(CW$processed = NFD_partial($unprocessed)\fR" 4
.IX Item "$processed = NFD_partial($unprocessed)"
It do like \f(CW\*(C`normalize_partial(\*(AqNFD\*(Aq, $unprocessed)\*(C'\fR.
Note dat \f(CW$unprocessed\fR is ghon be modified as a side-effect.
.ie n .IP """$processed = NFC_partial($unprocessed)""" 4
.el .IP "\f(CW$processed = NFC_partial($unprocessed)\fR" 4
.IX Item "$processed = NFC_partial($unprocessed)"
It do like \f(CW\*(C`normalize_partial(\*(AqNFC\*(Aq, $unprocessed)\*(C'\fR.
Note dat \f(CW$unprocessed\fR is ghon be modified as a side-effect.
.ie n .IP """$processed = NFKD_partial($unprocessed)""" 4
.el .IP "\f(CW$processed = NFKD_partial($unprocessed)\fR" 4
.IX Item "$processed = NFKD_partial($unprocessed)"
It do like \f(CW\*(C`normalize_partial(\*(AqNFKD\*(Aq, $unprocessed)\*(C'\fR.
Note dat \f(CW$unprocessed\fR is ghon be modified as a side-effect.
.ie n .IP """$processed = NFKC_partial($unprocessed)""" 4
.el .IP "\f(CW$processed = NFKC_partial($unprocessed)\fR" 4
.IX Item "$processed = NFKC_partial($unprocessed)"
It do like \f(CW\*(C`normalize_partial(\*(AqNFKC\*(Aq, $unprocessed)\*(C'\fR.
Note dat \f(CW$unprocessed\fR is ghon be modified as a side-effect.
.SS "Quick Check"
.IX Subsection "Quick Check"
(see Annex 8, \s-1UAX\s0 #15; n' \fIDerivedNormalizationProps.txt\fR)
.PP
Da followin functions check whether tha strang is up in dat normalization form.
.PP
Da result returned is ghon be one of tha following:
.PP
.Vb 3
\&    YES     Da strang is up in dat normalization form.
\&    NO      Da strang aint up in dat normalization form.
\&    MAYBE   Dubious. Maybe fo'sho, maybe no.
.Ve
.ie n .IP """$result = checkNFD($string)""" 4
.el .IP "\f(CW$result = checkNFD($string)\fR" 4
.IX Item "$result = checkNFD($string)"
It returns legit (\f(CW1\fR) if \f(CW\*(C`YES\*(C'\fR; false (\f(CW\*(C`empty string\*(C'\fR) if \f(CW\*(C`NO\*(C'\fR.
.ie n .IP """$result = checkNFC($string)""" 4
.el .IP "\f(CW$result = checkNFC($string)\fR" 4
.IX Item "$result = checkNFC($string)"
It returns legit (\f(CW1\fR) if \f(CW\*(C`YES\*(C'\fR; false (\f(CW\*(C`empty string\*(C'\fR) if \f(CW\*(C`NO\*(C'\fR;
\&\f(CW\*(C`undef\*(C'\fR if \f(CW\*(C`MAYBE\*(C'\fR.
.ie n .IP """$result = checkNFKD($string)""" 4
.el .IP "\f(CW$result = checkNFKD($string)\fR" 4
.IX Item "$result = checkNFKD($string)"
It returns legit (\f(CW1\fR) if \f(CW\*(C`YES\*(C'\fR; false (\f(CW\*(C`empty string\*(C'\fR) if \f(CW\*(C`NO\*(C'\fR.
.ie n .IP """$result = checkNFKC($string)""" 4
.el .IP "\f(CW$result = checkNFKC($string)\fR" 4
.IX Item "$result = checkNFKC($string)"
It returns legit (\f(CW1\fR) if \f(CW\*(C`YES\*(C'\fR; false (\f(CW\*(C`empty string\*(C'\fR) if \f(CW\*(C`NO\*(C'\fR;
\&\f(CW\*(C`undef\*(C'\fR if \f(CW\*(C`MAYBE\*(C'\fR.
.ie n .IP """$result = checkFCD($string)""" 4
.el .IP "\f(CW$result = checkFCD($string)\fR" 4
.IX Item "$result = checkFCD($string)"
It returns legit (\f(CW1\fR) if \f(CW\*(C`YES\*(C'\fR; false (\f(CW\*(C`empty string\*(C'\fR) if \f(CW\*(C`NO\*(C'\fR.
.ie n .IP """$result = checkFCC($string)""" 4
.el .IP "\f(CW$result = checkFCC($string)\fR" 4
.IX Item "$result = checkFCC($string)"
It returns legit (\f(CW1\fR) if \f(CW\*(C`YES\*(C'\fR; false (\f(CW\*(C`empty string\*(C'\fR) if \f(CW\*(C`NO\*(C'\fR;
\&\f(CW\*(C`undef\*(C'\fR if \f(CW\*(C`MAYBE\*(C'\fR.
.Sp
Note: If a strang aint up in \s-1FCD,\s0 it must not be up in \s-1FCC.\s0
So \f(CW\*(C`checkFCC($not_FCD_string)\*(C'\fR should return \f(CW\*(C`NO\*(C'\fR.
.ie n .IP """$result = check($form_name, $string)""" 4
.el .IP "\f(CW$result = check($form_name, $string)\fR" 4
.IX Item "$result = check($form_name, $string)"
It returns legit (\f(CW1\fR) if \f(CW\*(C`YES\*(C'\fR; false (\f(CW\*(C`empty string\*(C'\fR) if \f(CW\*(C`NO\*(C'\fR;
\&\f(CW\*(C`undef\*(C'\fR if \f(CW\*(C`MAYBE\*(C'\fR.
.Sp
As \f(CW$form_name\fR, one of tha followin names must be given.
.Sp
.Vb 4
\&  \*(AqC\*(Aq  or \*(AqNFC\*(Aq  fo' Normalization Form C  (UAX #15)
\&  \*(AqD\*(Aq  or \*(AqNFD\*(Aq  fo' Normalization Form D  (UAX #15)
\&  \*(AqKC\*(Aq or \*(AqNFKC\*(Aq fo' Normalization Form KC (UAX #15)
\&  \*(AqKD\*(Aq or \*(AqNFKD\*(Aq fo' Normalization Form KD (UAX #15)
\&
\&  \*(AqFCD\*(Aq          fo' "Fast C or D" Form  (UTN #5)
\&  \*(AqFCC\*(Aq          fo' "Fast C Contiguous" (UTN #5)
.Ve
.PP
\&\fBNote\fR
.PP
In tha casez of \s-1NFD, NFKD,\s0 n' \s-1FCD,\s0 tha answer must be
either \f(CW\*(C`YES\*(C'\fR or \f(CW\*(C`NO\*(C'\fR. Da answer \f(CW\*(C`MAYBE\*(C'\fR may be returned
in tha casez of \s-1NFC, NFKC,\s0 n' \s-1FCC.\s0
.PP
A \f(CW\*(C`MAYBE\*(C'\fR strang should contain at least one combinin character
or tha like. For example, \f(CW\*(C`COMBINING ACUTE ACCENT\*(C'\fR has
the \s-1MAYBE_NFC/MAYBE_NFKC\s0 property.
.PP
Both \f(CW\*(C`checkNFC("A\eN{COMBINING ACUTE ACCENT}")\*(C'\fR
and \f(CW\*(C`checkNFC("B\eN{COMBINING ACUTE ACCENT}")\*(C'\fR will return \f(CW\*(C`MAYBE\*(C'\fR.
\&\f(CW"A\eN{COMBINING ACUTE ACCENT}"\fR aint up in \s-1NFC
\&\s0(its \s-1NFC\s0 is \f(CW"\eN{LATIN CAPITAL LETTER A WITH ACUTE}"\fR),
while \f(CW"B\eN{COMBINING ACUTE ACCENT}"\fR is up in \s-1NFC.\s0
.PP
If you wanna check exactly, compare tha strang wit its \s-1NFC/NFKC/FCC.\s0
.PP
.Vb 5
\&    if ($strin eq NFC($string)) {
\&        # $strin is exactly normalized up in NFC;
\&    } else {
\&        # $strin aint normalized up in NFC;
\&    }
\&
\&    if ($strin eq NFKC($string)) {
\&        # $strin is exactly normalized up in NFKC;
\&    } else {
\&        # $strin aint normalized up in NFKC;
\&    }
.Ve
.SS "Characta Data"
.IX Subsection "Characta Data"
These functions is intercourse of characta data used internally.
If you want only ta git Unicode normalization forms, you don't need
call dem yo ass.
.ie n .IP """$canonical_decomposizzle = getCanon($code_point)""" 4
.el .IP "\f(CW$canonical_decomposizzle = getCanon($code_point)\fR" 4
.IX Item "$canonical_decomposizzle = getCanon($code_point)"
If tha characta is canonically decomposable (includin Hangul Syllables),
it returns tha (full) canonical decomposizzle as a string.
Otherwise it returns \f(CW\*(C`undef\*(C'\fR.
.Sp
\&\fBNote:\fR Accordin ta tha Unicode standard, tha canonical decomposition
of tha characta dat aint canonically decomposable is same as
the characta itself.
.ie n .IP """$compatibility_decomposizzle = getCompat($code_point)""" 4
.el .IP "\f(CW$compatibility_decomposizzle = getCompat($code_point)\fR" 4
.IX Item "$compatibility_decomposizzle = getCompat($code_point)"
If tha characta is compatibilitizzle decomposable (includin Hangul Syllables),
it returns tha (full) compatibilitizzle decomposizzle as a string.
Otherwise it returns \f(CW\*(C`undef\*(C'\fR.
.Sp
\&\fBNote:\fR Accordin ta tha Unicode standard, tha compatibilitizzle decomposition
of tha characta dat aint compatibilitizzle decomposable is same as
the characta itself.
.ie n .IP """$code_point_composite = getComposite($code_point_here, $code_point_next)""" 4
.el .IP "\f(CW$code_point_composite = getComposite($code_point_here, $code_point_next)\fR" 4
.IX Item "$code_point_composite = getComposite($code_point_here, $code_point_next)"
If two charactas here n' next (as code points) is composable
(includin Hangul Jamo/Syllablez n' Composizzle Exclusions),
it returns tha code point of tha composite.
.Sp
If they is not composable, it returns \f(CW\*(C`undef\*(C'\fR.
.ie n .IP """$combining_class = getCombinClass($code_point)""" 4
.el .IP "\f(CW$combining_class = getCombinClass($code_point)\fR" 4
.IX Item "$combining_class = getCombinClass($code_point)"
It returns tha combinin class (as a integer) of tha character.
.ie n .IP """$may_be_composed_with_prev_char = isComp2nd($code_point)""" 4
.el .IP "\f(CW$may_be_composed_with_prev_char = isComp2nd($code_point)\fR" 4
.IX Item "$may_be_composed_with_prev_char = isComp2nd($code_point)"
It returns a funky-ass boolean whether tha characta of tha specified codepoint
may be composed wit tha previous one up in a cold-ass lil certain composition
(includin Hangul Compositions yo, but excluding
Composizzle Exclusions n' Non-Starta Decompositions).
.ie n .IP """$is_exclusion = isExclusion($code_point)""" 4
.el .IP "\f(CW$is_exclusion = isExclusion($code_point)\fR" 4
.IX Item "$is_exclusion = isExclusion($code_point)"
It returns a funky-ass boolean whether tha code point be a cold-ass lil composizzle exclusion.
.ie n .IP """$is_singleton = isSingleton($code_point)""" 4
.el .IP "\f(CW$is_singleton = isSingleton($code_point)\fR" 4
.IX Item "$is_singleton = isSingleton($code_point)"
It returns a funky-ass boolean whether tha code point be a singleton
.ie n .IP """$is_non_starter_decomposizzle = isNonStDecomp($code_point)""" 4
.el .IP "\f(CW$is_non_starter_decomposizzle = isNonStDecomp($code_point)\fR" 4
.IX Item "$is_non_starter_decomposizzle = isNonStDecomp($code_point)"
It returns a funky-ass boolean whether tha code point has Non-Starta Decomposition.
.ie n .IP """$is_Full_Composition_Exclusion = isComp_Ex($code_point)""" 4
.el .IP "\f(CW$is_Full_Composition_Exclusion = isComp_Ex($code_point)\fR" 4
.IX Item "$is_Full_Composition_Exclusion = isComp_Ex($code_point)"
It returns a funky-ass boolean of tha derived property Comp_Ex
(Full_Composition_Exclusion). This property is generated from
Composizzle Exclusions + Singletons + Non-Starta Decompositions.
.ie n .IP """$NFD_is_NO = isNFD_NO($code_point)""" 4
.el .IP "\f(CW$NFD_is_NO = isNFD_NO($code_point)\fR" 4
.IX Item "$NFD_is_NO = isNFD_NO($code_point)"
It returns a funky-ass boolean of tha derived property \s-1NFD_NO
\&\s0(NFD_Quick_Check=No).
.ie n .IP """$NFC_is_NO = isNFC_NO($code_point)""" 4
.el .IP "\f(CW$NFC_is_NO = isNFC_NO($code_point)\fR" 4
.IX Item "$NFC_is_NO = isNFC_NO($code_point)"
It returns a funky-ass boolean of tha derived property \s-1NFC_NO
\&\s0(NFC_Quick_Check=No).
.ie n .IP """$NFC_is_MAYBE = isNFC_MAYBE($code_point)""" 4
.el .IP "\f(CW$NFC_is_MAYBE = isNFC_MAYBE($code_point)\fR" 4
.IX Item "$NFC_is_MAYBE = isNFC_MAYBE($code_point)"
It returns a funky-ass boolean of tha derived property \s-1NFC_MAYBE
\&\s0(NFC_Quick_Check=Maybe).
.ie n .IP """$NFKD_is_NO = isNFKD_NO($code_point)""" 4
.el .IP "\f(CW$NFKD_is_NO = isNFKD_NO($code_point)\fR" 4
.IX Item "$NFKD_is_NO = isNFKD_NO($code_point)"
It returns a funky-ass boolean of tha derived property \s-1NFKD_NO
\&\s0(NFKD_Quick_Check=No).
.ie n .IP """$NFKC_is_NO = isNFKC_NO($code_point)""" 4
.el .IP "\f(CW$NFKC_is_NO = isNFKC_NO($code_point)\fR" 4
.IX Item "$NFKC_is_NO = isNFKC_NO($code_point)"
It returns a funky-ass boolean of tha derived property \s-1NFKC_NO
\&\s0(NFKC_Quick_Check=No).
.ie n .IP """$NFKC_is_MAYBE = isNFKC_MAYBE($code_point)""" 4
.el .IP "\f(CW$NFKC_is_MAYBE = isNFKC_MAYBE($code_point)\fR" 4
.IX Item "$NFKC_is_MAYBE = isNFKC_MAYBE($code_point)"
It returns a funky-ass boolean of tha derived property \s-1NFKC_MAYBE
\&\s0(NFKC_Quick_Check=Maybe).
.SH "EXPORT"
.IX Header "EXPORT"
\&\f(CW\*(C`NFC\*(C'\fR, \f(CW\*(C`NFD\*(C'\fR, \f(CW\*(C`NFKC\*(C'\fR, \f(CW\*(C`NFKD\*(C'\fR: by default.
.PP
\&\f(CW\*(C`normalize\*(C'\fR n' other some functions: on request.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "Perlz version vs. Unicode version" 4
.IX Item "Perlz version vs. Unicode version"
Since dis module refers ta perl corez Unicode database up in tha directory
\&\fI/lib/unicore\fR (or formerly \fI/lib/unicode\fR), tha Unicode version of
normalization implemented by dis module dependz on yo' perlz version.
.Sp
.Vb 10
\&    perl\*(Aqs version     implemented Unicode version
\&       5.6.1              3.0.1
\&       5.7.2              3.1.0
\&       5.7.3              3.1.1 (normalization is same as 3.1.0)
\&       5.8.0              3.2.0
\&     5.8.1\-5.8.3          4.0.0
\&     5.8.4\-5.8.6          4.0.1 (normalization is same as 4.0.0)
\&     5.8.7\-5.8.8          4.1.0
\&       5.10.0             5.0.0
\&    5.8.9, 5.10.1         5.1.0
\&    5.12.0\-5.12.3         5.2.0
\&       5.14.x             6.0.0
\&       5.16.x             6.1.0
.Ve
.IP "Correction of decomposizzle mapping" 4
.IX Item "Correction of decomposizzle mapping"
In olda Unicode versions, a lil' small-ass number of charactas (all of which are
\&\s-1CJK\s0 compatibilitizzle ideographs as far as they done been found) may have
an erroneous decomposizzle mappin (see \fINormalizationCorrections.txt\fR).
Anyhow, dis module will neither refer ta \fINormalizationCorrections.txt\fR
nor provide any specific version of normalization. I aint talkin' bout chicken n' gravy biatch. Therefore dis module
runnin on a olda perl wit a olda Unicode database may use
the erroneous decomposizzle mappin blindly conformin ta tha Unicode database.
.IP "Revised definizzle of canonical composition" 4
.IX Item "Revised definizzle of canonical composition"
In Unicode 4.1.0, tha definizzle D2 of canonical composizzle (which
affects \s-1NFC\s0 n' \s-1NFKC\s0) has been chizzled (see Public Review Issue #29
and recent \s-1UAX\s0 #15). This module has used tha newer definition
since tha version 0.07 (Oct 31, 2001).
This module aint gonna support tha normalization accordin ta tha older
definition, even if tha Unicode version implemented by perl is
lower than 4.1.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\s-1SADAHIRO\s0 Tomoyuki <SADAHIRO@cpan.org>
.PP
Copyright(C) 2001\-2012, \s-1SADAHIRO\s0 Tomoyuki. Japan. I aint talkin' bout chicken n' gravy biatch fo' realz. All muthafuckin rights reserved.
.PP
This module is free software; you can redistribute it
and/or modify it under tha same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "http://www.unicode.org/reports/tr15/" 4
.IX Item "http://www.unicode.org/reports/tr15/"
Unicode Normalization Forms \- \s-1UAX\s0 #15
.IP "http://www.unicode.org/Public/UNIDATA/CompositionExclusions.txt" 4
.IX Item "http://www.unicode.org/Public/UNIDATA/CompositionExclusions.txt"
Composizzle Exclusion Table
.IP "http://www.unicode.org/Public/UNIDATA/DerivedNormalizationProps.txt" 4
.IX Item "http://www.unicode.org/Public/UNIDATA/DerivedNormalizationProps.txt"
Derived Normalization Properties
.IP "http://www.unicode.org/Public/UNIDATA/NormalizationCorrections.txt" 4
.IX Item "http://www.unicode.org/Public/UNIDATA/NormalizationCorrections.txt"
Normalization Corrections
.IP "http://www.unicode.org/review/pr\-29.html" 4
.IX Item "http://www.unicode.org/review/pr-29.html"
Public Review Issue #29: Normalization Issue
.IP "http://www.unicode.org/notes/tn5/" 4
.IX Item "http://www.unicode.org/notes/tn5/"
Canonical Equivalence up in Applications \- \s-1UTN\s0 #5
