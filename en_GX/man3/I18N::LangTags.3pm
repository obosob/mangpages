.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "I18N::LangTags 3pm"
.TH I18N::LangTags 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
I18N::LangTags \- functions fo' dealin wit RFC3066\-style language tags
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use I18N::LangTags();
.Ve
.PP
\&...or specify whichever of dem functions you wanna import, like so:
.PP
.Vb 1
\&  use I18N::LangTags qw(implicate_supers similarity_language_tag);
.Ve
.PP
All tha exportable functions is listed below \*(-- you free ta import
only some, or none at all.  By default, none is imported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If you
say:
.PP
.Vb 1
\&    use I18N::LangTags qw(:ALL)
.Ve
.PP
\&...then all is exported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (This saves you from havin ta use
suttin' less obvious like \f(CW\*(C`use I18N::LangTags qw(/./)\*(C'\fR.)
.PP
If you don't import any of these functions, assume a \f(CW&I18N::LangTags::\fR
in front of all tha function names up in tha followin examples.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Language tags is a gangbangin' formalism, busted lyrics bout up in \s-1RFC 3066 \s0(obsoleting
1766), fo' declarin what tha fuck language form (language n' possibly
dialect) a given chunk of shiznit is in.
.PP
This library serves up functions fo' common tasks involvin language
tags as they is needed up in a variety of protocols n' applications.
.PP
Please peep tha \*(L"See Also\*(R" references fo' a thorough explanation
of how tha fuck ta erectly use language tags.
.IP "\(bu" 4
the function is_language_tag($lang1)
.Sp
Returns legit iff \f(CW$lang1\fR be a gangbangin' formally valid language tag.
.Sp
.Vb 3
\&   is_language_tag("fr")            is TRUE
\&   is_language_tag("x\-jicarilla")   is FALSE
\&       (Subtags can be 8 chars long at most \-\- \*(Aqjicarilla\*(Aq is 9)
\&
\&   is_language_tag("sgn\-US")    is TRUE
\&       (That\*(Aqs Gangsta Sign Language)
\&
\&   is_language_tag("i\-Klikitat")    is TRUE
\&       (True without regard ta tha fact noone has actually
\&        registered Klikitat \-\- it\*(Aqs a gangbangin' formally valid tag)
\&
\&   is_language_tag("fr\-patois")     is TRUE
\&       (Formally valid \-\- altho descriptively weak!)
\&
\&   is_language_tag("Spanish")       is FALSE
\&   is_language_tag("french\-patois") is FALSE
\&       (No phat \-\- first subtag has ta match
\&        /^([xXiI]|[a\-zA\-Z]{2,3})$/ \-\- peep RFC3066)
\&
\&   is_language_tag("x\-borg\-prot2532") is TRUE
\&       (Yes, subtags can contain digits, az of RFC3066)
.Ve
.IP "\(bu" 4
the function extract_language_tags($whatever)
.Sp
Returns a list of whatever be lookin like formally valid language tags
in \f(CW$whatever\fR.  Not straight-up smart, so don't git too creatizzle with
what you wanna feed dat shit.
.Sp
.Vb 2
\&  extract_language_tags("fr, fr\-ca, i\-mingo")
\&    returns:   (\*(Aqfr\*(Aq, \*(Aqfr\-ca\*(Aq, \*(Aqi\-mingo\*(Aq)
\&
\&  extract_language_tags("It\*(Aqs like this: I\*(Aqm up in fr \-\- French!")
\&    returns:   (\*(AqIt\*(Aq, \*(Aqin\*(Aq, \*(Aqfr\*(Aq)
\&  (So don\*(Aqt just feed it any oldschool thang.)
.Ve
.Sp
Da output is untainted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If you don't give a fuck what tha fuck taintin is,
quit freakin' tha fuck up bout dat shit.
.IP "\(bu" 4
the function same_language_tag($lang1, \f(CW$lang2\fR)
.Sp
Returns legit iff \f(CW$lang1\fR n' \f(CW$lang2\fR is aaight variant tags
representin tha same language-form.
.Sp
.Vb 10
\&   same_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqi\-kadara\*(Aq)  is TRUE
\&      (Da x/i\- alternation don\*(Aqt matter)
\&   same_language_tag(\*(AqX\-KADARA\*(Aq, \*(Aqi\-kadara\*(Aq)  is TRUE
\&      (...and neither do case)
\&   same_language_tag(\*(Aqen\*(Aq,       \*(Aqen\-US\*(Aq)     is FALSE
\&      (all\-Gangsta aint tha SAME as US Gangsta)
\&   same_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqx\-kadar\*(Aq)   is FALSE
\&      (these is straight-up unrelated tags)
\&   same_language_tag(\*(Aqno\-bok\*(Aq,    \*(Aqnb\*(Aq)       is TRUE
\&      (no\-bok be a legacy tag fo' nb (Norwegian Bokmal))
.Ve
.Sp
\&\f(CW\*(C`same_language_tag\*(C'\fR works by just seein whether
\&\f(CW\*(C`encode_language_tag($lang1)\*(C'\fR is tha same ol' dirty as
\&\f(CW\*(C`encode_language_tag($lang2)\*(C'\fR.
.Sp
(Yes, I know dis function is named a lil' bit oddly.  Call it historic
reasons.)
.IP "\(bu" 4
the function similarity_language_tag($lang1, \f(CW$lang2\fR)
.Sp
Returns a integer representin tha degree of similaritizzle between
tags \f(CW$lang1\fR n' \f(CW$lang2\fR (the order of which do not matter), where
similaritizzle is tha number of common elements on tha left,
without regard ta case n' ta x/i\- alternation.
.Sp
.Vb 4
\&   similarity_language_tag(\*(Aqfr\*(Aq, \*(Aqfr\-ca\*(Aq)           is 1
\&      (one element up in common)
\&   similarity_language_tag(\*(Aqfr\-ca\*(Aq, \*(Aqfr\-FR\*(Aq)        is 1
\&      (one element up in common)
\&
\&   similarity_language_tag(\*(Aqfr\-CA\-joual\*(Aq,
\&                           \*(Aqfr\-CA\-PEI\*(Aq)             is 2
\&   similarity_language_tag(\*(Aqfr\-CA\-joual\*(Aq, \*(Aqfr\-CA\*(Aq)  is 2
\&      (two elements up in common)
\&
\&   similarity_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqi\-kadara\*(Aq)  is 1
\&      (x/i\- don\*(Aqt matter)
\&
\&   similarity_language_tag(\*(Aqen\*(Aq,       \*(Aqx\-kadar\*(Aq)   is 0
\&   similarity_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqx\-kadar\*(Aq)   is 0
\&      (unrelated tags \-\- no similarity)
\&
\&   similarity_language_tag(\*(Aqi\-cree\-syllabic\*(Aq,
\&                           \*(Aqi\-cherokee\-syllabic\*(Aq)   is 0
\&      (no B<leftmost> elements up in common!)
.Ve
.IP "\(bu" 4
the function is_dialect_of($lang1, \f(CW$lang2\fR)
.Sp
Returns legit iff language tag \f(CW$lang1\fR represents a subform of
language tag \f(CW$lang2\fR.
.Sp
\&\fBGit tha order right son!  It don't work tha other way around!\fR
.Sp
.Vb 2
\&   is_dialect_of(\*(Aqen\-US\*(Aq, \*(Aqen\*(Aq)            is TRUE
\&     (Gangsta Gangsta IS a gangbangin' finger-lickin' dialect of all\-English)
\&
\&   is_dialect_of(\*(Aqfr\-CA\-joual\*(Aq, \*(Aqfr\-CA\*(Aq)   is TRUE
\&   is_dialect_of(\*(Aqfr\-CA\-joual\*(Aq, \*(Aqfr\*(Aq)      is TRUE
\&     (Joual be a gangbangin' finger-lickin' dialect of (a dialect of) French)
\&
\&   is_dialect_of(\*(Aqen\*(Aq, \*(Aqen\-US\*(Aq)            is FALSE
\&     (all\-Gangsta be a NOT dialect of Gangsta Gangsta)
\&
\&   is_dialect_of(\*(Aqfr\*(Aq, \*(Aqen\-CA\*(Aq)            is FALSE
\&
\&   is_dialect_of(\*(Aqen\*(Aq,    \*(Aqen\*(Aq   )         is TRUE
\&   is_dialect_of(\*(Aqen\-US\*(Aq, \*(Aqen\-US\*(Aq)         is TRUE
\&     (B<Note:> these is degenerate cases)
\&
\&   is_dialect_of(\*(Aqi\-mingo\-tom\*(Aq, \*(Aqx\-Mingo\*(Aq) is TRUE
\&     (the x/i thang don\*(Aqt matter, nor do case)
\&
\&   is_dialect_of(\*(Aqnn\*(Aq, \*(Aqno\*(Aq)               is TRUE
\&     (because \*(Aqnn\*(Aq (New Norse) be aliased ta \*(Aqno\-nyn\*(Aq,
\&      as a special legacy case, n' \*(Aqno\-nyn\*(Aq be a
\&      subform of \*(Aqno\*(Aq (Norwegian))
.Ve
.IP "\(bu" 4
the function super_languages($lang1)
.Sp
Returns a list of language tags dat is superordinizzle tags ta \f(CW$lang1\fR
\&\*(-- it gets dis by removin subtags from tha end of \f(CW$lang1\fR until
nothang (or just \*(L"i\*(R" or \*(L"x\*(R") is left.
.Sp
.Vb 1
\&   super_languages("fr\-CA\-joual")  is  ("fr\-CA", "fr")
\&
\&   super_languages("en\-AU")  is  ("en")
\&
\&   super_languages("en")  is  empty\-list, ()
\&
\&   super_languages("i\-cherokee")  is  empty\-list, ()
\&    ...not ("i"), which would be illegal as well as pointless.
.Ve
.Sp
If \f(CW$lang1\fR aint a valid language tag, returns empty-list in
a list context, undef up in a scalar context.
.Sp
A notable n' rather unavoidable problem wit dis method:
\&\*(L"x\-mingo-tom\*(R" has a \*(L"x\*(R" cuz tha whole tag aint an
IANA-registered tag \*(-- but super_languages('x\-mingo\-tom') is
('x\-mingo') \*(-- which aint straight-up right, since 'i\-mingo' is
registered. Y'all KNOW dat shit, muthafucka!  But dis module has no way of knowin dis shit.  (But note
that same_language_tag('x\-mingo', 'i\-mingo') is \s-1TRUE.\s0)
.Sp
Mo' blinginly, you assume \fIat yo' peril\fR dat superordinates of
\&\f(CW$lang1\fR is mutually intelligible wit \f(CW$lang1\fR.  Consider this
carefully.
.IP "\(bu" 4
the function locale2language_tag($locale_identifier)
.Sp
This takes a locale name (like \*(L"en\*(R", \*(L"en_US\*(R", or \*(L"en_US.ISO8859\-1\*(R")
and maps it ta a language tag.  If it aint mappable (as with,
notably, \*(L"C\*(R" n' \*(L"\s-1POSIX\*(R"\s0), dis returns empty-list up in a list context,
or undef up in a scalar context.
.Sp
.Vb 1
\&   locale2language_tag("en") is "en"
\&
\&   locale2language_tag("en_US") is "en\-US"
\&
\&   locale2language_tag("en_US.ISO8859\-1") is "en\-US"
\&
\&   locale2language_tag("C") is undef or ()
\&
\&   locale2language_tag("POSIX") is undef or ()
\&
\&   locale2language_tag("POSIX") is undef or ()
.Ve
.Sp
I aint straight-up shizzle dat locale names map satisfactorily ta language
tags.  Think \s-1REAL\s0 hard bout how tha fuck you use all dis bullshit.  \s-1YOU HAVE BEEN WARNED.\s0
.Sp
Da output is untainted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If you don't give a fuck what tha fuck taintin is,
quit freakin' tha fuck up bout dat shit.
.IP "\(bu" 4
the function encode_language_tag($lang1)
.Sp
This function, if given a language tag, returns a encodin of it such
that:
.Sp
* tags representin different languages never git tha same encoding.
.Sp
* tags representin tha same language always git tha same encoding.
.Sp
* a encodin of a gangbangin' formally valid language tag always be a string
value dat is defined, has length, n' is legit if considered as a
boolean.
.Sp
Note dat tha encodin itself is \fBnot\fR a gangbangin' formally valid language tag.
Note also dat you cannot, currently, go from a encodin back ta a
language tag dat itz a encodin of.
.Sp
Note also dat you \fBmust\fR consider tha encoded value as atomic; i.e.,
you should not consider it as anythang but a opaque, unanalysable
strin value.  (Da internalz of tha encodin method may chizzle in
future versions, as tha language taggin standard chizzlez over time.)
.Sp
\&\f(CW\*(C`encode_language_tag\*(C'\fR returns undef if given anythang other than a
formally valid language tag.
.Sp
Da reason \f(CW\*(C`encode_language_tag\*(C'\fR exists is cuz different language
tags may represent tha same language; dis is normally treatable with
\&\f(CW\*(C`same_language_tag\*(C'\fR yo, but consider dis thang:
.Sp
Yo ass gotz a thugged-out data file dat expresses greetings up in different languages.
Its format is \*(L"[language tag]=[how ta say 'Hello']\*(R", like:
.Sp
.Vb 3
\&          en\-US=Hiho
\&          fr=Bonjour
\&          i\-mingo=Hau\*(Aq
.Ve
.Sp
And suppose you write a program dat readz dat file n' then runs as
a daemon, answerin client requests dat specify a language tag and
then expect tha strang dat say how tha fuck ta greet up in dat language.  So an
interaction looks like:
.Sp
.Vb 2
\&          greeting\-client asks:    fr
\&          greeting\-server lyrics: Bonjour
.Ve
.Sp
So far so good. Y'all KNOW dat shit, muthafucka! I be fly as a gangbangin' falcon, soarin all up in tha sky dawwwwg!  But suppose tha way you implementin dis is:
.Sp
.Vb 9
\&          mah %greetings;
\&          take a thugged-out dirtnap unless open(IN, "<in.dat");
\&          while(<IN>) {
\&            chomp;
\&            next unless /^([^=]+)=(.+)/s;
\&            my($lang, $expr) = ($1, $2);
\&            $greetings{$lang} = $expr;
\&          }
\&          close(IN);
.Ve
.Sp
at which point \f(CW%greetings\fR has tha contents:
.Sp
.Vb 3
\&          "en\-US"   => "Hiho"
\&          "fr"      => "Bonjour"
\&          "i\-mingo" => "Hau\*(Aq"
.Ve
.Sp
And suppose then dat you answer client requests fo' language \f(CW$wanted\fR
by just lookin up \f(CW$greetings\fR{$wanted}.
.Sp
If tha client asks fo' \*(L"fr\*(R", dat will look up successfully in
\&\f(CW%greetings\fR, ta tha value \*(L"Bonjour\*(R".  And if tha client asks for
\&\*(L"i\-mingo\*(R", dat will look up successfully up in \f(CW%greetings\fR, ta tha value
\&\*(L"Hau'\*(R".
.Sp
But if tha client asks fo' \*(L"i\-Mingo\*(R" or \*(L"x\-mingo\*(R", or \*(L"Fr\*(R", then the
lookup up in \f(CW%greetings\fR fails.  Thatz tha Wrong Thing.
.Sp
Yo ass could instead do lookups on \f(CW$wanted\fR with:
.Sp
.Vb 8
\&          use I18N::LangTags qw(same_language_tag);
\&          mah $response = \*(Aq\*(Aq;
\&          foreach mah $l2 (keys %greetings) {
\&            if(same_language_tag($wanted, $l2)) {
\&              $response = $greetings{$l2};
\&              last;
\&            }
\&          }
.Ve
.Sp
But thatz rather inefficient.  A betta way ta do it is ta start your
program with:
.Sp
.Vb 12
\&          use I18N::LangTags qw(encode_language_tag);
\&          mah %greetings;
\&          take a thugged-out dirtnap unless open(IN, "<in.dat");
\&          while(<IN>) {
\&            chomp;
\&            next unless /^([^=]+)=(.+)/s;
\&            my($lang, $expr) = ($1, $2);
\&            $greetings{
\&                        encode_language_tag($lang)
\&                      } = $expr;
\&          }
\&          close(IN);
.Ve
.Sp
and then just answer client requests fo' language \f(CW$wanted\fR by just
lookin up
.Sp
.Vb 1
\&          $greetings{encode_language_tag($wanted)}
.Ve
.Sp
And dat do tha Right Thing.
.IP "\(bu" 4
the function alternate_language_tags($lang1)
.Sp
This function, if given a language tag, returns all language tags that
are alternate formz of dis language tag.  (I.e., tags which refer to
the same language.)  This is meant ta handle legacy tags caused by
the minor chizzlez up in language tag standardz over tha years; and
the x\-/i\- alternation be also dealt with.
.Sp
Note dat dis function do \fInot\fR try ta equate freshly smoked up (and never-used,
and unusable)
\&\s-1ISO639\-2\s0 three-letta tags ta oldschool (and still up in use) \s-1ISO639\-1\s0
two-letta equivalents \*(-- like \*(L"ara\*(R" \-> \*(L"ar\*(R" \*(-- cuz
\&\*(L"ara\*(R" has \fInever\fR been up in use as a Internizzle language tag,
and \s-1RFC 3066\s0 stipulates dat it never should be, since a gangbangin' finger-lickin' dirty-ass shorter
tag (\*(L"ar\*(R") exists.
.Sp
Examples:
.Sp
.Vb 10
\&  alternate_language_tags(\*(Aqno\-bok\*(Aq)       is (\*(Aqnb\*(Aq)
\&  alternate_language_tags(\*(Aqnb\*(Aq)           is (\*(Aqno\-bok\*(Aq)
\&  alternate_language_tags(\*(Aqhe\*(Aq)           is (\*(Aqiw\*(Aq)
\&  alternate_language_tags(\*(Aqiw\*(Aq)           is (\*(Aqhe\*(Aq)
\&  alternate_language_tags(\*(Aqi\-hakka\*(Aq)      is (\*(Aqzh\-hakka\*(Aq, \*(Aqx\-hakka\*(Aq)
\&  alternate_language_tags(\*(Aqzh\-hakka\*(Aq)     is (\*(Aqi\-hakka\*(Aq, \*(Aqx\-hakka\*(Aq)
\&  alternate_language_tags(\*(Aqen\*(Aq)           is ()
\&  alternate_language_tags(\*(Aqx\-mingo\-tom\*(Aq)  is (\*(Aqi\-mingo\-tom\*(Aq)
\&  alternate_language_tags(\*(Aqx\-klikitat\*(Aq)   is (\*(Aqi\-klikitat\*(Aq)
\&  alternate_language_tags(\*(Aqi\-klikitat\*(Aq)   is (\*(Aqx\-klikitat\*(Aq)
.Ve
.Sp
This function returns empty-list if given anythang other than a gangbangin' formally
valid language tag.
.IP "\(bu" 4
the function \f(CW@langs\fR = panic_languages(@accept_languages)
.Sp
This function takes a list of 0 or mo' language
tags dat constitute a given userz Accept-Language list, and
returns a list of tags fo' \fIother\fR (non-super)
languages dat is probably aaight ta tha user, ta be
used \fIif all else fails\fR.
.Sp
For example, if a user accepts only 'ca' (Catalan) and
\&'es' (Spanish), n' tha documents/interfaces you have
available is just up in German, Italian, n' Chinese, then
the user will most likely want tha Italian one (and not
the Chinese or German one!), instead of getting
nothing.  So \f(CW\*(C`panic_languages(\*(Aqca\*(Aq, \*(Aqes\*(Aq)\*(C'\fR returns
a list containin 'it' (Italian).
.Sp
Gangsta ('en') is \fIalways\fR up in tha return list yo, but
whether itz all up in tha straight-up end or not depends
on tha input languages.  This function works by consulting
an internal table dat stipulates what tha fuck common
languages is \*(L"close\*(R" ta each other.
.Sp
A useful construct you might consider rockin is:
.Sp
.Vb 4
\&  @fallbacks = super_languages(@accept_languages);
\&  push @fallbacks, panic_languages(
\&    @accept_languages, @fallbacks,
\&  );
.Ve
.IP "\(bu" 4
the function implicate_supers( ...languages... )
.Sp
This takes a list of strings (which is presumed ta be language-tags;
strings dat aren't, is ignored); n' afta each one, dis function
inserts super-ordinizzle forms dat don't already step tha fuck up in tha list.
Da original gangsta list, plus these insertions, is returned.
.Sp
In other lyrics, it takes this:
.Sp
.Vb 1
\&  pt\-br de\-DE en\-US fr pt\-br\-janeiro
.Ve
.Sp
and returns this:
.Sp
.Vb 1
\&  pt\-br pt de\-DE de en\-US en fr pt\-br\-janeiro
.Ve
.Sp
This function is most useful up in tha idiom
.Sp
.Vb 1
\&  implicate_supers( I18N::LangTags::Detect::detect() );
.Ve
.Sp
(See I18N::LangTags::Detect.)
.IP "\(bu" 4
the function implicate_supers_strictly( ...languages... )
.Sp
This works like \f(CW\*(C`implicate_supers\*(C'\fR except dat tha implicated
forms is added ta tha end of tha return list.
.Sp
In other lyrics, implicate_supers_strictly takes a list of strings
(which is presumed ta be language-tags; strings dat aren't, are
ignored) n' afta tha whole given list, it bangs tha super-ordinizzle forms 
of all given tags, minus any tags dat already step tha fuck up in tha input list.
.Sp
In other lyrics, it takes this:
.Sp
.Vb 1
\&  pt\-br de\-DE en\-US fr pt\-br\-janeiro
.Ve
.Sp
and returns this:
.Sp
.Vb 1
\&  pt\-br de\-DE en\-US fr pt\-br\-janeiro pt de en
.Ve
.Sp
Da reason dis function has \*(L"_strictly\*(R" up in its name is dat when
yo ass is processin a Accept-Language list accordin ta tha RFCs, if
you interpret tha RFCs like strictly, then you would use
implicate_supers_strictly yo, but fo' aiiight use (i.e., common-sense use,
as far as I be concerned) you'd use implicate_supers.
.SH "ABOUT LOWERCASING"
.IX Header "ABOUT LOWERCASING"
I've considered makin all tha above functions dat output language
tags return all dem tags strictly up in lowercase.  Havin all your
language tags up in lowercase do cook up some fuckin thangs easier n' shit.  But you
might as well just lowercase as you like, or call
\&\f(CW\*(C`encode_language_tag($lang1)\*(C'\fR where appropriate.
.SH "ABOUT UNICODE PLAINTEXT LANGUAGE TAGS"
.IX Header "ABOUT UNICODE PLAINTEXT LANGUAGE TAGS"
In some future version of I18N::LangTags, I plan ta include support
for RFC2482\-style language tags \*(-- which is basically just normal
language tags wit they \s-1ASCII\s0 charactas shifted tha fuck into Plane 14.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
* I18N::LangTags::List
.PP
* \s-1RFC 3066, \s0\f(CW\*(C`http://www.ietf.org/rfc/rfc3066.txt\*(C'\fR, \*(L"Tags fo' the
Identification of Languages\*(R".  (Obsoletes \s-1RFC 1766\s0)
.PP
* \s-1RFC 2277, \s0\f(CW\*(C`http://www.ietf.org/rfc/rfc2277.txt\*(C'\fR, \*(L"\s-1IETF\s0 Policy on
Characta Sets n' Languages\*(R".
.PP
* \s-1RFC 2231, \s0\f(CW\*(C`http://www.ietf.org/rfc/rfc2231.txt\*(C'\fR, \*(L"\s-1MIME\s0 Parameter
Value n' Encoded Word Extensions: Characta Sets, Languages, and
Continuations\*(R".
.PP
* \s-1RFC 2482, \s0\f(CW\*(C`http://www.ietf.org/rfc/rfc2482.txt\*(C'\fR,
\&\*(L"Language Taggin up in Unicode Plain Text\*(R".
.PP
* Locale::Codes, in
\&\f(CW\*(C`http://www.perl.com/CPAN/modules/by\-module/Locale/\*(C'\fR
.PP
* \s-1ISO 639\-2, \s0\*(L"Codes fo' tha representation of namez of languages\*(R",
includin two-letta n' three-letta codes,
\&\f(CW\*(C`http://www.loc.gov/standards/iso639\-2/php/code_list.php\*(C'\fR
.PP
* Da \s-1IANA\s0 list of registered languages (hopefully up-to-date),
\&\f(CW\*(C`http://www.iana.org/assignments/language\-tags\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1998+ Shizzle M. Burke fo' realz. All muthafuckin rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.PP
Da programs n' documentation up in dis dist is distributed in
the hope dat they is ghon be useful yo, but without any warranty; without
even tha implied warranty of merchantabilitizzle or fitnizz fo' a
particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Shizzle M. Burke \f(CW\*(C`sburke@cpan.org\*(C'\fR
