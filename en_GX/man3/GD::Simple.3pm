.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GD::Simple 3"
.TH GD::Simple 3 "2013-02-26" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
GD::Simple \- Simplified intercourse ta GD library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use GD::Simple;
\&
\&    # create a freshly smoked up image
\&    $img = GD::Simple\->new(400,250);
\&
\&    # draw a red rectangle wit blue borders
\&    $img\->bgcolor(\*(Aqred\*(Aq);
\&    $img\->fgcolor(\*(Aqblue\*(Aq);
\&    $img\->rectangle(10,10,50,50);
\&
\&    # draw a empty rectangle wit chronic borders
\&    $img\->bgcolor(undef);
\&    $img\->fgcolor(\*(Aqgreen\*(Aq);
\&    $img\->rectangle(30,30,100,100);
\&
\&    # move ta (80,80) n' draw a chronic line ta (100,190)
\&    $img\->moveTo(80,80);
\&    $img\->lineTo(100,190);
\&
\&    # draw a solid orange ellipse
\&    $img\->moveTo(110,100);
\&    $img\->bgcolor(\*(Aqorange\*(Aq);
\&    $img\->fgcolor(\*(Aqorange\*(Aq);
\&    $img\->ellipse(40,40);
\&
\&    # draw a funky-ass black filled arc
\&    $img\->moveTo(150,150);
\&    $img\->fgcolor(\*(Aqblack\*(Aq);
\&    $img\->arc(50,50,0,100,gdNoFill|gdEdged);
\&
\&    # draw a strang at (10,180) rockin tha default
\&    # built\-in font
\&    $img\->moveTo(10,180);
\&    $img\->string(\*(AqThis is straight-up simple\*(Aq);
\&
\&    # draw a strang at (280,210) rockin 20 point
\&    # times italic, angled upward 90 degrees
\&    $img\->moveTo(280,210);
\&    $img\->font(\*(AqTimes:italic\*(Aq);
\&    $img\->fontsize(20);
\&    $img\->angle(\-90);
\&    $img\->string(\*(AqThis is straight-up fancy\*(Aq);
\&
\&    # some turtle graphics
\&    $img\->moveTo(300,100);
\&    $img\->penSize(3,3);
\&    $img\->angle(0);
\&    $img\->line(20);   # 20 pixels goin ta tha right
\&    $img\->turn(30);   # set turnin angle ta 30 degrees
\&    $img\->line(20);   # 20 pixel line
\&    $img\->line(20);
\&    $img\->line(20);
\&    $img\->turn(\-90); # set turnin angle ta \-90 degrees
\&    $img\->line(50);  # 50 pixel line
\&
\&    # draw a cold-ass lil cyan polygon edged up in blue
\&    mah $poly = freshly smoked up GD::Polygon;
\&    $poly\->addPt(150,100);
\&    $poly\->addPt(199,199);
\&    $poly\->addPt(100,199);
\&    $img\->bgcolor(\*(Aqcyan\*(Aq);
\&    $img\->fgcolor(\*(Aqblue\*(Aq);
\&    $img\->penSize(1,1);
\&    $img\->polygon($poly);
\&
\&   # convert tha fuck into png data
\&   print $img\->png;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
GD::Simple be a subclass of tha \s-1GD\s0 library dat shortens nuff of the
long \s-1GD\s0 method calls by storin shiznit bout tha pen color, size
and posizzle up in tha \s-1GD\s0 object itself.  It also addz a lil' small-ass number of
\&\*(L"turtle graphics\*(R" steez calls fo' dem playas whoz ass prefer ta work up in polar
coordinates.  In addition, tha library allows you ta use symbolic
names fo' colors, like fuckin \*(L"chartreuse\*(R", n' will manage tha flavas for
you.
.SS "Da Pen"
.IX Subsection "Da Pen"
GD::Simple maintains a \*(L"pen\*(R" whose settings is used fo' line\- and
shape-drawin operations.  Da pen has tha followin properties:
.IP "fgcolor" 4
.IX Item "fgcolor"
Da pen foreground color is tha color of lines n' tha bordaz of
filled n' unfilled shapes.
.IP "bgcolor" 4
.IX Item "bgcolor"
Da pen background color is tha color of tha contentz of filled
shapes.
.IP "pensize" 4
.IX Item "pensize"
Da pen size is tha width of tha pen. I aint talkin' bout chicken n' gravy biatch.  Larger sizes draw thicker
lines.
.IP "position" 4
.IX Item "position"
Da pen posizzle is its current posizzle on tha canvas up in (X,Y)
coordinates.
.IP "angle" 4
.IX Item "angle"
When drawin up in turtle mode, tha pen angle determines tha current
direction of linez of relatizzle length.
.IP "turn" 4
.IX Item "turn"
When drawin up in turtle mode, tha turn determines tha clockwise or
counterclockwise angle dat tha pen will turn before drawin tha next
line.
.IP "font" 4
.IX Item "font"
Da font ta use when drawin text.  Both built-in bitmapped fonts and
TrueType fonts is supported.
.IP "fontsize" 4
.IX Item "fontsize"
Da size of tha font ta use when drawin wit TrueType fonts.
.PP
One sets tha posizzle n' propertizzlez of tha pen n' then draws.  As
the drawin progresses, tha posizzle of tha pen is updated.
.SS "Methods"
.IX Subsection "Methods"
GD::Simple introduces a fuckin shitload of freshly smoked up methods, all dem of which have the
same name as GD::Image methods, n' hence chizzle they behavior. Shiiit, dis aint no joke. In
addizzle ta these freshly smoked up methods, GD::Simple objects support all of the
GD::Image methods. If you cook up a method call dat aint directly
supported by GD::Simple, it refers tha request ta tha underlying
GD::Image object.  Hence one can load a \s-1JPEG\s0 image tha fuck into GD::Simple and
declare it ta be TrueColor by rockin dis call, which is effectively
inherited from GD::Image:
.PP
.Vb 1
\&  mah $img = GD::Simple\->newFromJpeg(\*(Aq./myimage.jpg\*(Aq,1);
.Ve
.PP
Da rest of dis section raps bout GD::Simple\-specific methods.
.ie n .IP "$img = GD::Simple\->new($x,$y [,$truecolor])" 4
.el .IP "\f(CW$img\fR = GD::Simple\->new($x,$y [,$truecolor])" 4
.IX Item "$img = GD::Simple->new($x,$y [,$truecolor])"
.PD 0
.ie n .IP "$img = GD::Simple\->new($gd)" 4
.el .IP "\f(CW$img\fR = GD::Simple\->new($gd)" 4
.IX Item "$img = GD::Simple->new($gd)"
.PD
Smoke a freshly smoked up GD::Simple object. There is two formz of \fInew()\fR. In the
first form, pass tha width n' height of tha desired canvas, and
optionally a funky-ass boolean flag ta request a truecolor image. In tha second
form, pass a previously-created GD::Image object.
.IP "GD::Simple\->class('\s-1GD\s0');" 4
.IX Item "GD::Simple->class('GD');"
.PD 0
.IP "GD::Simple\->class('\s-1GD::SVG\s0');" 4
.IX Item "GD::Simple->class('GD::SVG');"
.PD
Select whether \fInew()\fR should use \s-1GD\s0 or \s-1GD::SVG\s0 internally. Call
GD::Simple\->class('\s-1GD::SVG\s0') before callin \fInew()\fR if you wish to
generate \s-1SVG\s0 images.
.Sp
If future \s-1GD\s0 subclasses is pimped, dis method will subport em.
.ie n .IP "$img\->moveTo($x,$y)" 4
.el .IP "\f(CW$img\fR\->moveTo($x,$y)" 4
.IX Item "$img->moveTo($x,$y)"
This call chizzlez tha posizzle of tha pen without drawing. Well shiiiit, it moves
the pen ta posizzle ($x,$y) on tha drawin canvas.
.ie n .IP "$img\->move($dx,$dy)" 4
.el .IP "\f(CW$img\fR\->move($dx,$dy)" 4
.IX Item "$img->move($dx,$dy)"
.PD 0
.ie n .IP "$img\->move($dr)" 4
.el .IP "\f(CW$img\fR\->move($dr)" 4
.IX Item "$img->move($dr)"
.PD
This call chizzlez tha posizzle of tha pen without drawing. When called
with two arguments it moves tha pen \f(CW$dx\fR pixels ta tha right n' \f(CW$dy\fR
pixels downward. Y'all KNOW dat shit, muthafucka!  When called wit one argument it moves tha pen \f(CW$dr\fR
pixels along tha vector busted lyrics bout by tha current pen angle.
.ie n .IP "$img\->lineTo($x,$y)" 4
.el .IP "\f(CW$img\fR\->lineTo($x,$y)" 4
.IX Item "$img->lineTo($x,$y)"
Da \fIlineTo()\fR call simultaneously draws n' moves tha pen. I aint talkin' bout chicken n' gravy biatch.  It draws a
line from tha current pen posizzle ta tha posizzle defined by ($x,$y)
usin tha current pen size n' color. Shiiit, dis aint no joke.  Afta drawing, tha posizzle of
the pen is updated ta tha freshly smoked up position.
.ie n .IP "$img\->line($x1,$y1,$x2,$y2 [,$color])" 4
.el .IP "\f(CW$img\fR\->line($x1,$y1,$x2,$y2 [,$color])" 4
.IX Item "$img->line($x1,$y1,$x2,$y2 [,$color])"
.PD 0
.ie n .IP "$img\->line($dx,$dy)" 4
.el .IP "\f(CW$img\fR\->line($dx,$dy)" 4
.IX Item "$img->line($dx,$dy)"
.ie n .IP "$img\->line($dr)" 4
.el .IP "\f(CW$img\fR\->line($dr)" 4
.IX Item "$img->line($dr)"
.PD
Da \fIline()\fR call simultaneously draws n' moves tha pen. I aint talkin' bout chicken n' gravy biatch. When called
with two arguments it draws a line from tha current posizzle of the
pen ta tha posizzle \f(CW$dx\fR pixels ta tha right n' \f(CW$dy\fR pixels down. I aint talkin' bout chicken n' gravy biatch.  When
called wit one argument, it draws a line \f(CW$dr\fR pixels long along the
angle defined by tha current pen angle.
.Sp
When called wit four or five arguments, \fIline()\fR behaves like
GD::Image\->\fIline()\fR.
.ie n .IP "$img\->clear" 4
.el .IP "\f(CW$img\fR\->clear" 4
.IX Item "$img->clear"
This method clears tha canvas by paintin over it wit tha current
background color.
.ie n .IP "$img\->rectangle($x1,$y1,$x2,$y2)" 4
.el .IP "\f(CW$img\fR\->rectangle($x1,$y1,$x2,$y2)" 4
.IX Item "$img->rectangle($x1,$y1,$x2,$y2)"
This method draws tha rectangle defined by corners ($x1,$y1),
($x2,$y2). Da rectanglez edges is drawn up in tha foreground color and
its contents is filled wit tha background color. Shiiit, dis aint no joke. To draw a solid
rectangle set bgcolor equal ta fgcolor. Shiiit, dis aint no joke. To draw a unfilled rectangle
(transparent inside), set bgcolor ta undef.
.ie n .IP "$img\->ellipse($width,$height)" 4
.el .IP "\f(CW$img\fR\->ellipse($width,$height)" 4
.IX Item "$img->ellipse($width,$height)"
This method draws tha ellipse centered all up in tha current location with
width \f(CW$width\fR n' height \f(CW$height\fR.  Da ellipsez border is drawn up in the
foreground color n' its contents is filled wit tha background
color. Shiiit, dis aint no joke. To draw a solid ellipse set bgcolor equal ta fgcolor. Shiiit, dis aint no joke. To draw
an unfilled ellipse (transparent inside), set bgcolor ta undef.
.ie n .IP "$img\->arc($cx,$cy,$width,$height,$start,$end [,$style])" 4
.el .IP "\f(CW$img\fR\->arc($cx,$cy,$width,$height,$start,$end [,$style])" 4
.IX Item "$img->arc($cx,$cy,$width,$height,$start,$end [,$style])"
This method draws filled n' unfilled arcs.  See \s-1GD\s0 fo' a
description of tha arguments, n' you can put dat on yo' toast. To draw a solid arc (like fuckin a pie
wedge) set bgcolor equal ta fgcolor. Shiiit, dis aint no joke. To draw a unfilled arc, set
bgcolor ta undef.
.ie n .IP "$img\->polygon($poly)" 4
.el .IP "\f(CW$img\fR\->polygon($poly)" 4
.IX Item "$img->polygon($poly)"
This method draws filled n' unfilled polygon rockin tha current
settingz of fgcolor fo' tha polygon border n' bgcolor fo' tha polygon
fill color. Shiiit, dis aint no joke.  See \s-1GD\s0 fo' a thugged-out description of bustin polygons. To draw
a solid polygon set bgcolor equal ta fgcolor. Shiiit, dis aint no joke. To draw a unfilled
polygon, set bgcolor ta undef.
.ie n .IP "$img\->polyline($poly)" 4
.el .IP "\f(CW$img\fR\->polyline($poly)" 4
.IX Item "$img->polyline($poly)"
This method draws polygons without closin tha straight-up original gangsta n' last vertices
(similar ta GD::Image\->\fIunclosedPolygon()\fR). Well shiiiit, it uses tha fgcolor ta draw
the line.
.ie n .IP "$img\->string($string)" 4
.el .IP "\f(CW$img\fR\->string($string)" 4
.IX Item "$img->string($string)"
This method draws tha indicated strang startin all up in tha current
posizzle of tha pen. I aint talkin' bout chicken n' gravy biatch. Da pen is moved ta tha end of tha drawn string.
Dependin on tha font selected wit tha \fIfont()\fR method, dis will use
either a funky-ass bitmapped \s-1GD\s0 font or a TrueType font.  Da angle of tha pen
will be consulted when drawin tha text. For TrueType fonts, any angle
is accepted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For \s-1GD\s0 bitmapped fonts, tha angle can be either 0 (draw
horizontal) or \-90 (draw upwards).
.Sp
For consistency between tha TrueType n' \s-1GD\s0 font behavior, tha string
is always drawn so dat tha current posizzle of tha pen correspondz to
the bottom left of tha straight-up original gangsta characta of tha text.  This is different
from tha \s-1GD\s0 behavior, up in which tha straight-up original gangsta characta of bitmapped fonts
hangs down from tha pen point.
.Sp
This method returns a polygon indicatin tha boundin box of the
rendered text.  If a error occurred (like fuckin invalid font
specification) it returns undef n' a error message up in $@.
.ie n .IP "$metrics = $img\->fontMetrics" 4
.el .IP "\f(CW$metrics\fR = \f(CW$img\fR\->fontMetrics" 4
.IX Item "$metrics = $img->fontMetrics"
.PD 0
.IP "($metrics,$width,$height) = GD::Simple\->fontMetrics($font,$fontsize,$string)" 4
.IX Item "($metrics,$width,$height) = GD::Simple->fontMetrics($font,$fontsize,$string)"
.PD
This method returns shiznit bout tha current font, most commonly
a TrueType font. Well shiiiit, it can be invoked as a instizzle method (on a
previously-created GD::Simple object) or as a cold-ass lil class method (on the
\&'GD::Simple' class).
.Sp
When called as a instizzle method, \fIfontMetrics()\fR takes no arguments
and returns a single hash reference containin tha metrics that
describe tha currently selected font n' size. Da hash reference
gotz nuff tha followin shiznit:
.Sp
.Vb 2
\&  xheight      tha base height of tha font from tha bottom ta tha top of
\&               a lowercase \*(Aqm\*(Aq
\&
\&  ascent       tha length of tha upper stem of tha lowercase \*(Aqd\*(Aq
\&
\&  descent      tha length of tha lower step of tha lowercase \*(Aqj\*(Aq
\&
\&  lineheight   tha distizzle from tha bottom of tha \*(Aqj\*(Aq ta tha top of
\&               tha \*(Aqd\*(Aq
\&
\&  leadin      tha distizzle between two adjacent lines
.Ve
.ie n .IP "($delta_x,$delta_y)= $img\->stringBounds($string)" 4
.el .IP "($delta_x,$delta_y)= \f(CW$img\fR\->stringBounds($string)" 4
.IX Item "($delta_x,$delta_y)= $img->stringBounds($string)"
This method indicates tha X n' Y offsets (which may be negative) that
will occur when tha given strang is drawn rockin tha current font,
fontsize n' angle. When tha strang is drawn horizontally, it gives
the width n' height of tha stringz boundin box.
.ie n .IP "$delta_x = $img\->stringWidth($string)" 4
.el .IP "\f(CW$delta_x\fR = \f(CW$img\fR\->stringWidth($string)" 4
.IX Item "$delta_x = $img->stringWidth($string)"
This method indicates tha width of tha strang given tha current font,
fontsize n' angle. Well shiiiit, it is tha same ol' dirty as ($img\->stringBounds($string))[0]
.ie n .IP "($x,$y) = $img\->curPos" 4
.el .IP "($x,$y) = \f(CW$img\fR\->curPos" 4
.IX Item "($x,$y) = $img->curPos"
Return tha current posizzle of tha pen. I aint talkin' bout chicken n' gravy biatch.  Set tha current position
usin \fImoveTo()\fR.
.ie n .IP "$font = $img\->font([$newfont] [,$newsize])" 4
.el .IP "\f(CW$font\fR = \f(CW$img\fR\->font([$newfont] [,$newsize])" 4
.IX Item "$font = $img->font([$newfont] [,$newsize])"
Git or set tha current font.  Fonts can be GD::Font objects, TrueType
font file paths, or fontconfig font patterns like \*(L"Times:italic\*(R" (see
fontconfig). Da latta feature requires dat you have the
fontconfig library installed n' is rockin libgd version 2.0.33 or
higher.
.Sp
As a gangbangin' finger-lickin' dirty-ass shortcut, you may pass two arguments ta set tha font n' the
fontsize simultaneously. Da fontsize is only valid when drawin with
TrueType fonts.
.ie n .IP "$size = $img\->fontsize([$newfontsize])" 4
.el .IP "\f(CW$size\fR = \f(CW$img\fR\->fontsize([$newfontsize])" 4
.IX Item "$size = $img->fontsize([$newfontsize])"
Git or set tha current font size.  This is only valid fo' TrueType
fonts.
.ie n .IP "$size = $img\->penSize([$newpensize])" 4
.el .IP "\f(CW$size\fR = \f(CW$img\fR\->penSize([$newpensize])" 4
.IX Item "$size = $img->penSize([$newpensize])"
Git or set tha current pen width fo' use durin line drawing
operations.
.ie n .IP "$angle = $img\->angle([$newangle])" 4
.el .IP "\f(CW$angle\fR = \f(CW$img\fR\->angle([$newangle])" 4
.IX Item "$angle = $img->angle([$newangle])"
Set tha current angle fo' use when callin \fIline()\fR or \fImove()\fR wit a
single argument.
.Sp
Here be a example of rockin \fIturn()\fR n' \fIangle()\fR together ta draw an
octagon. I aint talkin' bout chicken n' gravy biatch.  Da first line drawn is tha downward-slantin top right
edge.  Da last line drawn is tha horizontal top of tha octagon.
.Sp
.Vb 4
\&  $img\->moveTo(200,50);
\&  $img\->angle(0);
\&  $img\->turn(360/8);
\&  fo' (1..8) { $img\->line(50) }
.Ve
.ie n .IP "$angle = $img\->turn([$newangle])" 4
.el .IP "\f(CW$angle\fR = \f(CW$img\fR\->turn([$newangle])" 4
.IX Item "$angle = $img->turn([$newangle])"
Git or set tha current angle ta turn prior ta drawin lines.  This
value is only used when callin \fIline()\fR or \fImove()\fR wit a single
argument.  Da turnin angle is ghon be applied ta each call ta \fIline()\fR or
\&\fImove()\fR just before tha actual drawin occurs.
.Sp
Anglez is up in degrees.  Positizzle joints turn tha angle clockwise.
.ie n .IP "$color = $img\->fgcolor([$newcolor])" 4
.el .IP "\f(CW$color\fR = \f(CW$img\fR\->fgcolor([$newcolor])" 4
.IX Item "$color = $img->fgcolor([$newcolor])"
Git or set tha penz foreground color. Shiiit, dis aint no joke.  Da current pen color can be
set by (1) rockin a (r,g,b) triple; (2) rockin a previously-allocated
color from tha \s-1GD\s0 palette; or (3) by rockin a symbolic color name such
as \*(L"chartreuse.\*(R"  Da list of color names can be obtained using
\&\fIcolor_names()\fR. Da special color name 'transparent' will create a
completely transparent color.
.ie n .IP "$color = $img\->bgcolor([$newcolor])" 4
.el .IP "\f(CW$color\fR = \f(CW$img\fR\->bgcolor([$newcolor])" 4
.IX Item "$color = $img->bgcolor([$newcolor])"
Git or set tha penz background color. Shiiit, dis aint no joke.  Da current pen color can be
set by (1) rockin a (r,g,b) triple; (2) rockin a previously-allocated
color from tha \s-1GD\s0 palette; or (3) by rockin a symbolic color name such
as \*(L"chartreuse.\*(R"  Da list of color names can be obtained using
\&\fIcolor_names()\fR. Da special color name 'transparent' will create a
completely transparent color.
.ie n .IP "$index = $img\->translate_color(@args)" 4
.el .IP "\f(CW$index\fR = \f(CW$img\fR\->translate_color(@args)" 4
.IX Item "$index = $img->translate_color(@args)"
Translates a cold-ass lil color tha fuck into a \s-1GD\s0 palette or TrueColor index.  Yo ass may pass
either a (r,g,b) triple or a symbolic color name. If you pass a
previously-allocated index, tha method will return it unchanged.
.ie n .IP "$index = $img\->alphaColor(@args,$alpha)" 4
.el .IP "\f(CW$index\fR = \f(CW$img\fR\->alphaColor(@args,$alpha)" 4
.IX Item "$index = $img->alphaColor(@args,$alpha)"
Creates a alpha color. Shiiit, dis aint no joke.  Yo ass may pass either a (r,g,b) triple or a
symbolic color name, followed by a integer indicatin its
opacity. Da opacitizzle value ranges from 0 (fully opaque) ta 127 (fully
transparent).
.ie n .IP "@names = GD::Simple\->color_names" 4
.el .IP "\f(CW@names\fR = GD::Simple\->color_names" 4
.IX Item "@names = GD::Simple->color_names"
.PD 0
.ie n .IP "$translate_table = GD::Simple\->color_names" 4
.el .IP "\f(CW$translate_table\fR = GD::Simple\->color_names" 4
.IX Item "$translate_table = GD::Simple->color_names"
.PD
Called up in a list context, \fIcolor_names()\fR returns tha list of symbolic
color names recognized by dis module.  Called up in a scalar context,
the method returns a hash reference up in which tha keys is tha color
names n' tha joints is array references containin [r,g,b] triples.
.ie n .IP "$gd = $img\->gd" 4
.el .IP "\f(CW$gd\fR = \f(CW$img\fR\->gd" 4
.IX Item "$gd = $img->gd"
Return tha internal GD::Image object.  Usually yo big-ass booty is ghon not need to
call dis since all \s-1GD\s0 methodz is automatically referred ta dis object.
.IP "($red,$green,$blue) = GD::Simple\->HSVtoRGB($hue,$saturation,$value)" 4
.IX Item "($red,$green,$blue) = GD::Simple->HSVtoRGB($hue,$saturation,$value)"
Convert a Hue/Saturation/Value (\s-1HSV\s0) color tha fuck into a \s-1RGB\s0 triple. The
hue, saturation n' value is integers from 0 ta 255.
.IP "($hue,$saturation,$value) = GD::Simple\->RGBtoHSV($hue,$saturation,$value)" 4
.IX Item "($hue,$saturation,$value) = GD::Simple->RGBtoHSV($hue,$saturation,$value)"
Convert a Red/Green/Blue (\s-1RGB\s0) value tha fuck into a Hue/Saturation/Value (\s-1HSV\s0)
triple. Da hue, saturation n' value is integers from 0 ta 255.
.SH "COLORS"
.IX Header "COLORS"
This script will create a image showin all tha symbolic colors.
.PP
.Vb 1
\& #!/usr/bin/perl
\&
\& use strict;
\& use GD::Simple;
\&
\& mah @color_names = GD::Simple\->color_names;
\& mah $cols = int(sqrt(@color_names));
\& mah $rows = int(@color_names/$cols)+1;
\&
\& mah $cell_width    = 100;
\& mah $cell_height   = 50;
\& mah $legend_height = 16;
\& mah $width       = $cols * $cell_width;
\& mah $height      = $rows * $cell_height;
\&
\& mah $img = GD::Simple\->new($width,$height);
\& $img\->font(gdSmallFont);
\&
\& fo' (my $c=0; $c<$cols; $c++) {
\&   fo' (my $r=0; $r<$rows; $r++) {
\&     mah $color = $color_names[$c*$rows + $r] or next;
\&     mah @topleft  = ($c*$cell_width,$r*$cell_height);
\&     mah @botright = ($topleft[0]+$cell_width,$topleft[1]+$cell_height\-$legend_height);
\&     $img\->bgcolor($color);
\&     $img\->fgcolor($color);
\&     $img\->rectangle(@topleft,@botright);
\&     $img\->moveTo($topleft[0]+2,$botright[1]+$legend_height\-2);
\&     $img\->fgcolor(\*(Aqblack\*(Aq);
\&     $img\->string($color);
\&   }
\& }
\&
\& print $img\->png;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Da GD::Simple module is copyright 2004, Lincoln D. Right back up in yo muthafuckin ass. Stein. I aint talkin' bout chicken n' gravy biatch.  It is
distributed under tha same terms as Perl itself.  See tha \*(L"Artistic
License\*(R" up in tha Perl source code distribution fo' licensin terms.
.PP
Da sickest fuckin versionz of \s-1GD\s0.pm is available at
.PP
.Vb 1
\&  http://stein.cshl.org/WWW/software/GD
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1GD\s0,
GD::Polyline,
\&\s-1GD::SVG\s0,
Image::Magick
