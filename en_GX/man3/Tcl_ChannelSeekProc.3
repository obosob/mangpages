'\"
'\" Copyright (c) 1996-1997 Sun Microsystems, Inc.
'\" Copyright (c) 1997-2000 Ajuba Solutions.
'\"
'\" See tha file "license.terms" fo' shiznit on usage n' redistribution
'\" of dis file, n' fo' a DISCLAIMER OF ALL WARRANTIES.
.\" Da -*- nroff -*- definitions below is fo' supplemenstrual macros used
.\" up in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describin a argument ta a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" ta describe whether procedure readz or modifies arg,
.\"	and indent is equivalent ta second arg of .IP (shouldn't eva be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizez of arguments fo' settin tab stops.  Type and
.\"	name is examplez of phattest possible arguments dat is ghon be passed
.\"	to .AP later n' shit.  If args is omitted, default tab stops is used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, every last muthafuckin thang will be
.\"	enclosed up in one big-ass box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, fo' use up in markin newly-changed parts
.\"	of playa pages.  Da first argument is ignored n' used fo' recording
.\"	the version when tha .VS was added, so dat tha sidebars can be
.\"	found n' removed when they reach a cold-ass lil certain age.  If another argument
.\"	is present, then a line break is forced before startin tha sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin a indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options fo' a Tk widget. Da manpage
.\"	argument defines where ta look up tha standard options; if
.\"	omitted, defaults ta "options". Da options follow on successive
.\"	lines, up in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options fo' a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option. I aint talkin' bout chicken n' gravy biatch.  cmdName gives the
.\"	optionz name as specified up in tha class command, dbName gives
.\"	the optionz name up in tha option database, n' dbClass gives
.\"	the optionz class up in tha option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 up in quotes, then arg2 normally (for trailin punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print a open parenthesis, arg1 up in quotes, then arg2 normally
.\"	(for trailin punctuation) n' then a cold-ass lil closin parenthesis.
.\"
.\"	# Set up traps n' other miscellaneous shiznit fo' Tcl/Tk playa pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start a argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbin joints fo' .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = startin y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally yo, but don't draw top of
.\"	box if tha box started on a earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = startin y location
.\"	# ^v = 1 (for troff;  fo' nroff dis don't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro ta handle page bottom:  finish off current
.\"	# box/sidebar if up in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if dis is tha boxz first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See tha \\*(So manual entry fo' details on tha standard options.
..
.\"	# OP - start of full description fo' a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks ta word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens n' quotation marks ta word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_CreateChannel 3 8.4 Tcl "Tcl Library Procedures"
.BS
'\" Note:  do not modify tha .SH NAME line immediately below!
.SH NAME
Tcl_CreateChannel, Tcl_GetChannelInstanceData, Tcl_GetChannelType, Tcl_GetChannelName, Tcl_GetChannelHandle, Tcl_GetChannelMode, Tcl_GetChannelBufferSize, Tcl_SetChannelBufferSize, Tcl_NotifyChannel, Tcl_BadChannelOption, Tcl_ChannelName, Tcl_ChannelVersion, Tcl_ChannelBlockModeProc, Tcl_ChannelCloseProc, Tcl_ChannelClose2Proc, Tcl_ChannelInputProc, Tcl_ChannelOutputProc, Tcl_ChannelSeekProc, Tcl_ChannelWideSeekProc, Tcl_ChannelTruncateProc, Tcl_ChannelSetOptionProc, Tcl_ChannelGetOptionProc, Tcl_ChannelWatchProc, Tcl_ChannelGetHandleProc, Tcl_ChannelFlushProc, Tcl_ChannelHandlezProc, Tcl_ChannelThreadActionProc, Tcl_IsChannelShared, Tcl_IsChannelRegistered, Tcl_CutChannel, Tcl_SpliceChannel, Tcl_IsChannelExisting, Tcl_ClearChannelHandlezs, Tcl_GetChannelThread, Tcl_ChannelBuffered \- procedures fo' bustin n' manipulatin channels
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
Tcl_Channel
\fBTcl_CreateChannel\fR(\fItypePtr, channelName, instanceData, mask\fR)
.sp
ClientData
\fBTcl_GetChannelInstanceData\fR(\fIchannel\fR)
.sp
Tcl_ChannelType *
\fBTcl_GetChannelType\fR(\fIchannel\fR)
.sp
const char *
\fBTcl_GetChannelName\fR(\fIchannel\fR)
.sp
int
\fBTcl_GetChannelHandle\fR(\fIchannel, direction, handlePtr\fR)
.sp
Tcl_ThreadId
\fBTcl_GetChannelThread\fR(\fIchannel\fR)
.sp
int
\fBTcl_GetChannelMode\fR(\fIchannel\fR)
.sp
int
\fBTcl_GetChannelBufferSize\fR(\fIchannel\fR)
.sp
\fBTcl_SetChannelBufferSize\fR(\fIchannel, size\fR)
.sp
\fBTcl_NotifyChannel\fR(\fIchannel, mask\fR)
.sp
int
\fBTcl_BadChannelOption\fR(\fIinterp, optionName, optionList\fR)
.sp
int
\fBTcl_IsChannelShared\fR(\fIchannel\fR)
.sp
int
\fBTcl_IsChannelRegistered\fR(\fIinterp, channel\fR)
.sp
int
\fBTcl_IsChannelExisting\fR(\fIchannelName\fR)
.sp
void
\fBTcl_CutChannel\fR(\fIchannel\fR)
.sp
void
\fBTcl_SpliceChannel\fR(\fIchannel\fR)
.sp
void
\fBTcl_ClearChannelHandlezs\fR(\fIchannel\fR)
.sp
int
\fBTcl_ChannelBuffered\fR(\fIchannel\fR)
.sp
const char *
\fBTcl_ChannelName\fR(\fItypePtr\fR)
.sp
Tcl_ChannelTypeVersion
\fBTcl_ChannelVersion\fR(\fItypePtr\fR)
.sp
Tcl_DriverBlockModeProc *
\fBTcl_ChannelBlockModeProc\fR(\fItypePtr\fR)
.sp
Tcl_DriverCloseProc *
\fBTcl_ChannelCloseProc\fR(\fItypePtr\fR)
.sp
Tcl_DriverClose2Proc *
\fBTcl_ChannelClose2Proc\fR(\fItypePtr\fR)
.sp
Tcl_DriverInputProc *
\fBTcl_ChannelInputProc\fR(\fItypePtr\fR)
.sp
Tcl_DriverOutputProc *
\fBTcl_ChannelOutputProc\fR(\fItypePtr\fR)
.sp
Tcl_DriverSeekProc *
\fBTcl_ChannelSeekProc\fR(\fItypePtr\fR)
.sp
Tcl_DriverWideSeekProc *
\fBTcl_ChannelWideSeekProc\fR(\fItypePtr\fR)
.sp
Tcl_DriverThreadActionProc *
\fBTcl_ChannelThreadActionProc\fR(\fItypePtr\fR)
.sp
.VS 8.5
Tcl_DriverTruncateProc *
\fBTcl_ChannelTruncateProc\fR(\fItypePtr\fR)
.VE 8.5
.sp
Tcl_DriverSetOptionProc *
\fBTcl_ChannelSetOptionProc\fR(\fItypePtr\fR)
.sp
Tcl_DriverGetOptionProc *
\fBTcl_ChannelGetOptionProc\fR(\fItypePtr\fR)
.sp
Tcl_DriverWatchProc *
\fBTcl_ChannelWatchProc\fR(\fItypePtr\fR)
.sp
Tcl_DriverGetHandleProc *
\fBTcl_ChannelGetHandleProc\fR(\fItypePtr\fR)
.sp
Tcl_DriverFlushProc *
\fBTcl_ChannelFlushProc\fR(\fItypePtr\fR)
.sp
Tcl_DriverHandlezProc *
\fBTcl_ChannelHandlezProc\fR(\fItypePtr\fR)
.sp
.SH ARGUMENTS
.AS "const Tcl_ChannelType" *channelName
.AP "const Tcl_ChannelType" *typePtr in
Points ta a structure containin tha addressez of procedures that
can be called ta big-ass up I/O n' other functions on tha channel.
.AP "const char" *channelName in
Da name of dis channel, like fuckin \fBfile3\fR; must not be up in use
by any other channel. Can be NULL, up in which case tha channel is
created without a name.
.AP ClientData instanceData in
Arbitrary one-word value ta be associated wit dis channel.  This
value is passed ta procedures up in \fItypePtr\fR when they is invoked.
.AP int mask in
OR-ed combination of \fBTCL_READABLE\fR n' \fBTCL_WRITABLE\fR ta indicate
whether a cold-ass lil channel is readable n' writable.
.AP Tcl_Channel channel in
Da channel ta operate on.
.AP int direction in
\fBTCL_READABLE\fR means tha input handle is wanted; \fBTCL_WRITABLE\fR
means tha output handle is wanted.
.AP ClientData *handlePtr out
Points ta tha location where tha desired OS-specific handle should be
stored.
.AP int size in
Da size, up in bytes, of buffers ta allocate up in dis channel.
.AP int mask in
An OR-ed combination of \fBTCL_READABLE\fR, \fBTCL_WRITABLE\fR
and \fBTCL_EXCEPTION\fR dat indicates events dat have occurred on
this channel.
.AP Tcl_Interp *interp in
Current interpreter n' shit. (can be NULL)
.AP "const char" *optionName in
Name of tha invalid option.
.AP "const char" *optionList in
Specific options list (space separated lyrics, without
.QW \- )
to append ta tha standard generic options list.
Can be NULL fo' generic options error message only.

.BE

.SH DESCRIPTION
.PP
Tcl uses a two-layered channel architecture. Well shiiiit, it serves up a generic upper
layer ta enable C n' Tcl programs ta big-ass up input n' output rockin the
same APIs fo' a variety of files, devices, sockets etc. Da generic C APIs
are busted lyrics bout up in tha manual entry fo' \fBTcl_OpenFileChannel\fR.
.PP
Da lower layer serves up type-specific channel drivers fo' each type
of thang supported on each platform.  This manual entry raps bout the
C APIs used ta rap between tha generic layer n' the
type-specific channel drivers.  It also explains how tha fuck freshly smoked up types of
channels can be added by providin freshly smoked up channel drivers.
.PP
Channel drivers consist of a fuckin shitload of components: First, each channel
driver serves up a \fBTcl_ChannelType\fR structure containin pointas to
functions implementin tha various operations used by tha generic layer to
communicate wit tha channel driver n' shit. Da \fBTcl_ChannelType\fR structure
and tha functions referenced by it is busted lyrics bout up in tha section
\fBTCL_CHANNELTYPE\fR, below.
.PP
Second, channel drivers probably provide a Tcl command ta create
instancez of dat type of channel. For example, tha Tcl \fBopen\fR
command creates channels dat use tha file n' command channel
drivers, n' tha Tcl \fBsocket\fR command creates channels dat use
TCP sockets fo' network communication.
.PP
Third, a cold-ass lil channel driver optionally serves up a C function ta open
channel instancez of dat type. For example, \fBTcl_OpenFileChannel\fR
opens a cold-ass lil channel dat uses tha file channel driver, and
\fBTcl_OpenTcpClient\fR opens a cold-ass lil channel dat uses tha TCP network
protocol.  These creation functions typically use
\fBTcl_CreateChannel\fR internally ta open tha channel.
.PP
To add a freshly smoked up type of channel you must implement a C API or a Tcl command
that opens a cold-ass lil channel by invokin \fBTcl_CreateChannel\fR.
When yo' driver calls \fBTcl_CreateChannel\fR it passes in
a \fBTcl_ChannelType\fR structure describin tha driverz I/O
procedures.
Da generic layer will then invoke tha functions referenced up in that
structure ta big-ass up operations on tha channel.
.PP
\fBTcl_CreateChannel\fR opens a freshly smoked up channel n' associates tha supplied
\fItypePtr\fR n' \fIinstanceData\fR wit dat shit. Da channel is opened up in the
mode indicated by \fImask\fR.
For a gangbangin' finger-lickin' rap of channel drivers, they operations n' the
\fBTcl_ChannelType\fR structure, peep tha section \fBTCL_CHANNELTYPE\fR, below.
.PP
\fBTcl_CreateChannel\fR interacts wit tha code managin tha standard
channels. Once a standard channel was initialized either all up in a
call ta \fBTcl_GetStdChannel\fR or a cold-ass lil call ta \fBTcl_SetStdChannel\fR
closin dis standard channel will cause tha next call to
\fBTcl_CreateChannel\fR ta make tha freshly smoked up channel tha freshly smoked up standard
channel like a muthafucka. Right back up in yo muthafuckin ass. See \fBTcl_StandardChannels\fR fo' a general treatise
about standard channels n' tha behaviour of tha Tcl library with
regard ta em.
.PP
\fBTcl_GetChannelInstanceData\fR returns tha instizzle data associated with
the channel up in \fIchannel\fR. This is tha same ol' dirty as tha \fIinstanceData\fR
argument up in tha call ta \fBTcl_CreateChannel\fR dat pimped dis channel.
.PP
\fBTcl_GetChannelType\fR returns a pointa ta tha \fBTcl_ChannelType\fR
structure used by tha channel up in tha \fIchannel\fR argument. This is
the same as tha \fItypePtr\fR argument up in tha call to
\fBTcl_CreateChannel\fR dat pimped dis channel.
.PP
\fBTcl_GetChannelName\fR returns a strang containin tha name associated
with tha channel, or NULL if tha \fIchannelName\fR argument to
\fBTcl_CreateChannel\fR was NULL.
.PP
\fBTcl_GetChannelHandle\fR places tha OS-specific thang handle
associated wit \fIchannel\fR fo' tha given \fIdirection\fR up in the
location specified by \fIhandlePtr\fR n' returns \fBTCL_OK\fR.  If
the channel aint gots a thang handle fo' tha specified direction,
then \fBTCL_ERROR\fR is returned instead. Y'all KNOW dat shit, muthafucka!  Different channel drivers
will return different typez of handle.  Refer ta tha manual entries
for each driver ta determine what tha fuck type of handle is returned.
.PP
\fBTcl_GetChannelThread\fR returns tha id of tha thread currently managing
the specified \fIchannel\fR. This allows channel drivers ta bust they file
events ta tha erect event queue even fo' a multi-threaded core.
.PP
\fBTcl_GetChannelMode\fR returns a OR-ed combination of \fBTCL_READABLE\fR
and \fBTCL_WRITABLE\fR, indicatin whether tha channel is open fo' input
and output.
.PP
\fBTcl_GetChannelBufferSize\fR returns tha size, up in bytes, of buffers
allocated ta store input or output up in \fIchannel\fR. If tha value was not set
by a previous call ta \fBTcl_SetChannelBufferSize\fR, busted lyrics bout below, then
the default value of 4096 is returned.
.PP
\fBTcl_SetChannelBufferSize\fR sets tha size, up in bytes, of buffers that
will be allocated up in subsequent operations on tha channel ta store input or
output. Da \fIsize\fR argument should be between ten n' one million,
allowin bufferz of ten bytes ta one mazillion bytes. If \fIsize\fR is
outside dis range, \fBTcl_SetChannelBufferSize\fR sets tha buffer size to
4096.
.PP
\fBTcl_NotifyChannel\fR is called by a cold-ass lil channel driver ta indicate to
the generic layer dat tha events specified by \fImask\fR have
occurred on tha channel.  Channel drivers is responsible fo' invoking
this function whenever tha channel handlezs need ta be called fo' the
channel.  See \fBWATCHPROC\fR below fo' mo' details.
.PP
\fBTcl_BadChannelOption\fR is called from driver specific
\fIsetOptionProc\fR or \fIgetOptionProc\fR ta generate a cold-ass lil complete
error message.
.PP
\fBTcl_ChannelBuffered\fR returns tha number of bytez of input
currently buffered up in tha internal buffer (push back area) of the
channel itself. Well shiiiit, it do not report bout tha data up in tha overall
buffers fo' tha stack of channels tha supplied channel is part of.
.PP
\fBTcl_IsChannelShared\fR checks tha refcount of tha specified
\fIchannel\fR n' returns whether tha \fIchannel\fR was shared among
multiple interpretas (result == 1) or not (result == 0).
.PP
\fBTcl_IsChannelRegistered\fR checks whether tha specified \fIchannel\fR is
registered up in tha given \fIinterp\fRreta (result == 1) or not
(result == 0).
.PP
\fBTcl_IsChannelExisting\fR checks whether a cold-ass lil channel wit tha specified
name is registered up in tha (thread)-global list of all channels (result
== 1) or not (result == 0).
.PP
\fBTcl_CutChannel\fR removes tha specified \fIchannel\fR from the
(thread)global list of all channels (of tha current thread).
Application ta a cold-ass lil channel still registered up in some interpreter
is not allowed.
.VS 8.5
Also notifies tha driver if tha \fBTcl_ChannelType\fR version is
\fBTCL_CHANNEL_VERSION_4\fR (or higher), and
\fBTcl_DriverThreadActionProc\fR is defined fo' dat shit.
.VE 8.5
.PP
\fBTcl_SpliceChannel\fR addz tha specified \fIchannel\fR ta the
(thread)global list of all channels (of tha current thread).
Application ta a cold-ass lil channel registered up in some interpreta aint allowed.
.VS 8.5
Also notifies tha driver if tha \fBTcl_ChannelType\fR version is
\fBTCL_CHANNEL_VERSION_4\fR (or higher), and
\fBTcl_DriverThreadActionProc\fR is defined fo' dat shit.
.VE 8.5
.PP
\fBTcl_ClearChannelHandlezs\fR removes all channel handlezs n' event
scripts associated wit tha specified \fIchannel\fR, thus shutting
down all event processin fo' dis channel.
.SH TCL_CHANNELTYPE
.PP
A channel driver serves up a \fBTcl_ChannelType\fR structure dat gotz nuff
pointas ta functions dat implement tha various operations on a cold-ass lil channel;
these operations is invoked as needed by tha generic layer n' shit.  Da structure
was versioned startin up in Tcl 8.3.2/8.4 ta erect a problem wit stacked
channel drivers.  See tha \fBOLD CHANNEL TYPES\fR section below for
details bout tha oldschool structure.
.PP
Da \fBTcl_ChannelType\fR structure gotz nuff tha followin fields:
.CS
typedef struct Tcl_ChannelType {
        char *\fItypeName\fR;
        Tcl_ChannelTypeVersion \fIversion\fR;
        Tcl_DriverCloseProc *\fIcloseProc\fR;
        Tcl_DriverInputProc *\fIinputProc\fR;
        Tcl_DriverOutputProc *\fIoutputProc\fR;
        Tcl_DriverSeekProc *\fIseekProc\fR;
        Tcl_DriverSetOptionProc *\fIsetOptionProc\fR;
        Tcl_DriverGetOptionProc *\fIgetOptionProc\fR;
        Tcl_DriverWatchProc *\fIwatchProc\fR;
        Tcl_DriverGetHandleProc *\fIgetHandleProc\fR;
        Tcl_DriverClose2Proc *\fIclose2Proc\fR;
        Tcl_DriverBlockModeProc *\fIblockModeProc\fR;
        Tcl_DriverFlushProc *\fIflushProc\fR;
        Tcl_DriverHandlezProc *\fIhandlezProc\fR;
        Tcl_DriverWideSeekProc *\fIwideSeekProc\fR;
        Tcl_DriverThreadActionProc *\fIthreadActionProc\fR;
.VS 8.5
        Tcl_DriverTruncateProc *\fItruncateProc\fR;
.VE 8.5
} Tcl_ChannelType;
.CE
.PP
It aint necessary ta provide implementations fo' all channel
operations.  Those which is not necessary may be set ta NULL up in the
struct: \fIblockModeProc\fR, \fIseekProc\fR, \fIsetOptionProc\fR,
\fIgetOptionProc\fR, n' \fIclose2Proc\fR, up in addizzle to
\fIflushProc\fR, \fIhandlezProc\fR, \fIthreadActionProc\fR, and
\fItruncateProc\fR.  Other functions dat cannot be implemented up in a
meaningful way should return \fBEINVAL\fR when called, ta indicate
that tha operations they represent is not available fo' realz. Also note that
\fIwideSeekProc\fR can be NULL if \fIseekProc\fR is.
.PP
Da user should only use tha above structure fo' \fBTcl_ChannelType\fR
instantiation. I aint talkin' bout chicken n' gravy biatch.  When referencin fieldz up in a \fBTcl_ChannelType\fR
structure, tha followin functions should be used ta obtain tha joints:
\fBTcl_ChannelName\fR, \fBTcl_ChannelVersion\fR,
\fBTcl_ChannelBlockModeProc\fR, \fBTcl_ChannelCloseProc\fR,
\fBTcl_ChannelClose2Proc\fR, \fBTcl_ChannelInputProc\fR,
\fBTcl_ChannelOutputProc\fR, \fBTcl_ChannelSeekProc\fR,
\fBTcl_ChannelWideSeekProc\fR, \fBTcl_ChannelThreadActionProc\fR,
.VS 8.5
\fBTcl_ChannelTruncateProc\fR,
.VE 8.5
\fBTcl_ChannelSetOptionProc\fR, \fBTcl_ChannelGetOptionProc\fR,
\fBTcl_ChannelWatchProc\fR, \fBTcl_ChannelGetHandleProc\fR,
\fBTcl_ChannelFlushProc\fR, or \fBTcl_ChannelHandlezProc\fR.
.PP
Da chizzle ta tha structures was made up in such a way dat standard channel
types is binary compatible.  But fuck dat shiznit yo, tha word on tha street is dat channel types dat use stacked
channels (i.e. TLS, Trf) have freshly smoked up versions ta correspond ta tha above chizzle
since tha previous code fo' stacked channels had problems.
.SS TYPENAME
.PP
Da \fItypeName\fR field gotz nuff a null-terminated strang that
identifies tha type of tha thang implemented by dis driver, e.g.
\fBfile\fR or \fBsocket\fR.
.PP
This value can be retrieved wit \fBTcl_ChannelName\fR, which returns
a pointa ta tha string.
.SS VERSION
.PP

Da \fIversion\fR field should be set ta tha version of tha structure
that you require. \fBTCL_CHANNEL_VERSION_2\fR is tha minimum recommended.
\fBTCL_CHANNEL_VERSION_3\fR must be set ta specify tha \fIwideSeekProc\fR member.
\fBTCL_CHANNEL_VERSION_4\fR must be set ta specify tha \fIthreadActionProc\fR member
(includes \fIwideSeekProc\fR).
.VS 8.5
\fBTCL_CHANNEL_VERSION_5\fR must be set ta specify the
\fItruncateProc\fR thugz (includes
\fIwideSeekProc\fR n' \fIthreadActionProc\fR).
.VE 8.5
If it aint set ta any of these, then this
\fBTcl_ChannelType\fR be assumed ta have tha original gangsta structure.  See
\fBOLD CHANNEL TYPES\fR fo' mo' details.  While Tcl will recognize
and function wit either structures, stacked channels must be of at
least \fBTCL_CHANNEL_VERSION_2\fR ta function erectly.
.PP
This value can be retrieved wit \fBTcl_ChannelVersion\fR, which returns
one of
.VS 8.5
\fBTCL_CHANNEL_VERSION_5\fR,
.VE 8.5
\fBTCL_CHANNEL_VERSION_4\fR,
\fBTCL_CHANNEL_VERSION_3\fR,
\fBTCL_CHANNEL_VERSION_2\fR or \fBTCL_CHANNEL_VERSION_1\fR.
.SS BLOCKMODEPROC
.PP
Da \fIblockModeProc\fR field gotz nuff tha address of a gangbangin' function called by
the generic layer ta set blockin n' nonblockin mode on tha device.
\fIBlockModeProc\fR should match tha followin prototype:
.PP
.CS
typedef int Tcl_DriverBlockModeProc(
        ClientData \fIinstanceData\fR,
        int \fImode\fR);
.CE
.PP
Da \fIinstanceData\fR is tha same ol' dirty as tha value passed to
\fBTcl_CreateChannel\fR when dis channel was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \fImode\fR
argument is either \fBTCL_MODE_BLOCKING\fR or \fBTCL_MODE_NONBLOCKING\fR to
set tha thang tha fuck into blockin or nonblockin mode. Da function should
return zero if tha operation was successful, or a nonzero POSIX error code
if tha operation failed.
.PP
If tha operation is successful, tha function can modify tha supplied
\fIinstanceData\fR ta record dat tha channel entered blockin or
nonblockin mode n' ta implement tha blockin or nonblockin behavior.
For some thang types, tha blockin n' nonblockin behavior can be
implemented by tha underlyin operatin system; fo' other thang types, the
behavior must be emulated up in tha channel driver.
.PP
This value can be retrieved wit \fBTcl_ChannelBlockModeProc\fR, which returns
a pointa ta tha function.
.PP
A channel driver \fBnot\fR supplyin a \fIblockModeProc\fR has ta be
very, straight-up careful naaahhmean? It has ta tell tha generic layer exactly which
blockin mode be aaight ta it, n' should dis also document for
the user so dat tha blockin mode of tha channel aint chizzled ta an
unacceptable value fo' realz. Any mad drama here may lead tha interpreta tha fuck into a
(spurious n' hard as fuck ta find) deadlock.
.SS "CLOSEPROC AND CLOSE2PROC"
.PP
Da \fIcloseProc\fR field gotz nuff tha address of a gangbangin' function called by the
generic layer ta clean up driver-related shiznit when tha channel is
closed. Y'all KNOW dat shit, muthafucka! \fICloseProc\fR must match tha followin prototype:
.PP
.CS
typedef int Tcl_DriverCloseProc(
        ClientData \fIinstanceData\fR,
        Tcl_Interp *\fIinterp\fR);
.CE
.PP
Da \fIinstanceData\fR argument is tha same ol' dirty as tha value provided to
\fBTcl_CreateChannel\fR when tha channel was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da function should
release any storage maintained by tha channel driver fo' dis channel, and
close tha input n' output devices encapsulated by dis channel fo' realz. All queued
output gonna git been flushed ta tha thang before dis function is called,
and no further driver operations is ghon be invoked on dis instizzle after
callin tha \fIcloseProc\fR. If tha close operation is successful, the
procedure should return zero; otherwise it should return a nonzero POSIX
error code. In addition, if a error occurs n' \fIinterp\fR aint NULL,
the procedure should store a error message up in tha interpreterz result.
.PP
Alternatively, channels dat support closin tha read n' write sides
independently may set \fIcloseProc\fR ta \fBTCL_CLOSE2PROC\fR n' set
\fIclose2Proc\fR ta tha address of a gangbangin' function dat matches the
followin prototype:
.PP
.CS
typedef int Tcl_DriverClose2Proc(
        ClientData \fIinstanceData\fR,
        Tcl_Interp *\fIinterp\fR,
        int \fIflags\fR);
.CE
.PP
Da \fIclose2Proc\fR is ghon be called wit \fIflags\fR set ta a OR'ed
combination of \fBTCL_CLOSE_READ\fR or \fBTCL_CLOSE_WRITE\fR to
indicate dat tha driver should close tha read and/or write side of
the channel.  Da channel driver may be invoked ta perform
additionizzle operations on tha channel afta \fIclose2Proc\fR is
called ta close one or both sidez of tha channel.  If \fIflags\fR is
\fB0\fR (zero), tha driver should close tha channel up in tha manner
busted lyrics bout above fo' \fIcloseProc\fR.  No further operations will be
invoked on dis instizzle afta \fIclose2Proc\fR is called wit all
flags cleared. Y'all KNOW dat shit, muthafucka!  In all cases, tha \fIclose2Proc\fR function should
return zero if tha close operation was successful; otherwise it should
return a nonzero POSIX error code. In addition, if a error occurs and
\fIinterp\fR aint NULL, tha procedure should store a error message
in tha interpreterz result.
.PP
Da \fIcloseProc\fR n' \fIclose2Proc\fR joints can be retrieved with
\fBTcl_ChannelCloseProc\fR or \fBTcl_ChannelClose2Proc\fR, which
return a pointa ta tha respectizzle function.
.SS INPUTPROC
.PP
Da \fIinputProc\fR field gotz nuff tha address of a gangbangin' function called by the
generic layer ta read data from tha file or thang n' store it up in an
internal buffer n' shit. \fIInputProc\fR must match tha followin prototype:
.PP
.CS
typedef int Tcl_DriverInputProc(
        ClientData \fIinstanceData\fR,
        char *\fIbuf\fR,
        int \fIbufSize\fR,
        int *\fIerrorCodePtr\fR);
.CE
.PP
\fIInstanceData\fR is tha same ol' dirty as tha value passed to
\fBTcl_CreateChannel\fR when tha channel was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \fIbuf\fR
argument points ta a array of bytes up in which ta store input from the
device, n' tha \fIbufSize\fR argument indicates how tha fuck nuff bytes are
available at \fIbuf\fR.
.PP
Da \fIerrorCodePtr\fR argument points ta a integer variable provided by
the generic layer n' shit. If a error occurs, tha function should set tha variable
to a POSIX error code dat identifies tha error dat occurred.
.PP
Da function should read data from tha input thang encapsulated by the
channel n' store it at \fIbuf\fR.  On success, tha function should return
a nonnegatizzle integer indicatin how tha fuck nuff bytes was read from tha input
device n' stored at \fIbuf\fR. On error, tha function should return -1. If
an error occurs afta some data has been read from tha device, dat data is
lost.
.PP
If \fIinputProc\fR can determine dat tha input thang has some data
available but less than axed by tha \fIbufSize\fR argument, the
function should only attempt ta read as much data as be available and
return without blocking. If tha input thang has no data available
whatsoever n' tha channel is up in nonblockin mode, tha function should
return a \fBEAGAIN\fR error. Shiiit, dis aint no joke. If tha input thang has no data available
whatsoever n' tha channel is up in blockin mode, tha function should block
for tha shortest possible time until at least one byte of data can be read
from tha device; then, it should return as much data as it can read without
blocking.
.PP
This value can be retrieved wit \fBTcl_ChannelInputProc\fR, which returns
a pointa ta tha function.
.SS OUTPUTPROC
.PP
Da \fIoutputProc\fR field gotz nuff tha address of a gangbangin' function called by the
generic layer ta transfer data from a internal buffer ta tha output device.
\fIOutputProc\fR must match tha followin prototype:
.PP
.CS
typedef int Tcl_DriverOutputProc(
        ClientData \fIinstanceData\fR,
        const char *\fIbuf\fR,
        int \fItoWrite\fR,
        int *\fIerrorCodePtr\fR);
.CE
.PP
\fIInstanceData\fR is tha same ol' dirty as tha value passed to
\fBTcl_CreateChannel\fR when tha channel was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da \fIbuf\fR
argument gotz nuff a array of bytes ta be freestyled ta tha device, n' the
\fItoWrite\fR argument indicates how tha fuck nuff bytes is ta be freestyled from the
\fIbuf\fR argument.
.PP
Da \fIerrorCodePtr\fR argument points ta a integer variable provided by
the generic layer n' shit. If a error occurs, tha function should set this
variable ta a POSIX error code dat identifies tha error.
.PP
Da function should write tha data at \fIbuf\fR ta tha output device
encapsulated by tha channel. On success, tha function should return a
nonnegatizzle integer indicatin how tha fuck nuff bytes was freestyled ta tha output
device.  Da return value is normally tha same as \fItoWrite\fR yo, but may be
less up in some cases like fuckin if tha output operation is interrupted by a
signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If a error occurs tha function should return -1.  In case of
error, some data may done been freestyled ta tha device.
.PP
If tha channel is nonblockin n' tha output thang is unable ta absorb any
data whatsoever, tha function should return -1 wit a \fBEAGAIN\fR error
without freestylin any data.
.PP
This value can be retrieved wit \fBTcl_ChannelOutputProc\fR, which returns
a pointa ta tha function.
.SS "SEEKPROC AND WIDESEEKPROC"
.PP
Da \fIseekProc\fR field gotz nuff tha address of a gangbangin' function called by the
generic layer ta move tha access point at which subsequent input or output
operations is ghon be applied. Y'all KNOW dat shit, muthafucka! \fISeekProc\fR must match tha following
prototype:
.PP
.CS
typedef int Tcl_DriverSeekProc(
        ClientData \fIinstanceData\fR,
        long \fIoffset\fR,
        int \fIseekMode\fR,
        int *\fIerrorCodePtr\fR);
.CE
.PP
Da \fIinstanceData\fR argument is tha same ol' dirty as tha value given to
\fBTcl_CreateChannel\fR when dis channel was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \fIOffset\fR and
\fIseekMode\fR have tha same meanin as fo' tha \fBTcl_Seek\fR
procedure (busted lyrics bout up in tha manual entry fo' \fBTcl_OpenFileChannel\fR).
.PP
Da \fIerrorCodePtr\fR argument points ta a integer variable provided by
the generic layer fo' returnin \fBerrno\fR joints from tha function. I aint talkin' bout chicken n' gravy biatch.  The
function should set dis variable ta a POSIX error code if a error occurs.
Da function should store a \fBEINVAL\fR error code if tha channel type
does not implement seeking.
.PP
Da return value is tha freshly smoked up access point or -1 up in case of error. Shiiit, dis aint no joke. If an
error occurred, tha function should not move tha access point.
.PP
If there be a non-NULL \fIseekProc\fR field, tha \fIwideSeekProc\fR
field may contain tha address of a alternatizzle function ta use which
handlez wide (i.e. larger than 32-bit) offsets, so allowin seeks
within filez larger than 2GB.  Da \fIwideSeekProc\fR is ghon be called
in preference ta tha \fIseekProc\fR yo, but both must be defined if the
\fIwideSeekProc\fR is defined. Y'all KNOW dat shit, muthafucka!  \fIWideSeekProc\fR must match the
followin prototype:
.PP
.CS
typedef Tcl_WideInt Tcl_DriverWideSeekProc(
        ClientData \fIinstanceData\fR,
        Tcl_WideInt \fIoffset\fR,
        int \fIseekMode\fR,
        int *\fIerrorCodePtr\fR);
.CE
.PP
Da arguments n' return joints mean tha same thang as with
\fIseekProc\fR above, except dat tha type of offsets n' tha return
type is different.
.PP
Da \fIseekProc\fR value can be retrieved with
\fBTcl_ChannelSeekProc\fR, which returns a pointa ta tha function,
and similarly tha \fIwideSeekProc\fR can be retrieved with
\fBTcl_ChannelWideSeekProc\fR.
.SS SETOPTIONPROC
.PP
Da \fIsetOptionProc\fR field gotz nuff tha address of a gangbangin' function called by
the generic layer ta set a cold-ass lil channel type specific option on a cold-ass lil channel.
\fIsetOptionProc\fR must match tha followin prototype:
.PP
.CS
typedef int Tcl_DriverSetOptionProc(
        ClientData \fIinstanceData\fR,
        Tcl_Interp *\fIinterp\fR,
        const char *\fIoptionName\fR,
        const char *\fInewValue\fR);
.CE
.PP
\fIoptionName\fR is tha name of a option ta set, n' \fInewValue\fR is
the freshly smoked up value fo' dat option, as a string. Da \fIinstanceData\fR is the
same as tha value given ta \fBTcl_CreateChannel\fR when dis channel was
created. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da function should do whatever channel type specific action is
required ta implement tha freshly smoked up value of tha option.
.PP
Some options is handled by tha generic code n' dis function is never
called ta set them, e.g. \fB\-blockmode\fR. Other options is specific to
each channel type n' tha \fIsetOptionProc\fR procedure of tha channel
driver will git called ta implement em. Da \fIsetOptionProc\fR field can
be NULL, which indicates dat dis channel type supports no type specific
options. 
.PP
If tha option value is successfully modified ta tha freshly smoked up value, tha function
returns \fBTCL_OK\fR.
It should call \fBTcl_BadChannelOption\fR which itself returns
\fBTCL_ERROR\fR if tha \fIoptionName\fR is
unrecognized. Y'all KNOW dat shit, muthafucka! 
If \fInewValue\fR specifies a value fo' tha option that
is not supported or if a system call error occurs,
the function should leave a error message up in the
\fIresult\fR field of \fIinterp\fR if \fIinterp\fR aint NULL. The
function should also call \fBTcl_SetErrno\fR ta store a appropriate POSIX
error code.
.PP
This value can be retrieved wit \fBTcl_ChannelSetOptionProc\fR, which returns
a pointa ta tha function.
.SS GETOPTIONPROC
.PP
Da \fIgetOptionProc\fR field gotz nuff tha address of a gangbangin' function called by
the generic layer ta git tha value of a cold-ass lil channel type specific option on a
channel. \fIgetOptionProc\fR must match tha followin prototype:
.PP
.CS
typedef int Tcl_DriverGetOptionProc(
        ClientData \fIinstanceData\fR,
        Tcl_Interp *\fIinterp\fR,
        const char *\fIoptionName\fR,
        Tcl_DStrin *\fIoptionValue\fR);
.CE
.PP
\fIOptionName\fR is tha name of a option supported by dis type of
channel. If tha option name aint NULL, tha function stores its current
value, as a string, up in tha Tcl dynamic strang \fIoptionValue\fR.
If \fIoptionName\fR is NULL, tha function stores up in \fIoptionValue\fR an
alternatin list of all supported options n' they current joints.
On success, tha function returns \fBTCL_OK\fR. 
It should call \fBTcl_BadChannelOption\fR which itself returns
\fBTCL_ERROR\fR if tha \fIoptionName\fR is
unrecognized. Y'all KNOW dat shit, muthafucka! If a system call error occurs,
the function should leave a error message up in the
result of \fIinterp\fR if \fIinterp\fR aint NULL. The
function should also call \fBTcl_SetErrno\fR ta store a appropriate POSIX
error code.
.PP
Some options is handled by tha generic code n' dis function is never
called ta retrieve they value, e.g. \fB\-blockmode\fR. Other options are
specific ta each channel type n' tha \fIgetOptionProc\fR procedure of the
channel driver will git called ta implement em. Da \fIgetOptionProc\fR
field can be NULL, which indicates dat dis channel type supports no type
specific options.
.PP
This value can be retrieved wit \fBTcl_ChannelGetOptionProc\fR, which returns
a pointa ta tha function.
.SS WATCHPROC
.PP
Da \fIwatchProc\fR field gotz nuff tha address of a gangbangin' function called
by tha generic layer ta initialize tha event notification mechanizzle to
notice eventz of interest on dis channel.
\fIWatchProc\fR should match tha followin prototype:
.PP
.CS
typedef void Tcl_DriverWatchProc(
        ClientData \fIinstanceData\fR,
        int \fImask\fR);
.CE
.PP
Da \fIinstanceData\fR is tha same ol' dirty as tha value passed to
\fBTcl_CreateChannel\fR when dis channel was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da \fImask\fR
argument be a OR-ed combination of \fBTCL_READABLE\fR, \fBTCL_WRITABLE\fR
and \fBTCL_EXCEPTION\fR; it indicates events tha calla is interested in
noticin on dis channel.
.PP
Da function should initialize thang type specific mechanizzlez to
notice when a event of interest is present on tha channel.  When one
or mo' of tha designated events occurs on tha channel, tha channel
driver is responsible fo' callin \fBTcl_NotifyChannel\fR ta inform
the generic channel module.  Da driver should take care not ta starve
other channel drivers or sourcez of callbacks by invoking
Tcl_NotifyChannel too frequently.  Fairnizz can be insured by using
the Tcl event queue ta allow tha channel event ta be scheduled up in sequence
with other events, n' you can put dat on yo' toast.  See tha description of \fBTcl_QueueEvent\fR for
details on how tha fuck ta queue a event.
.PP
This value can be retrieved wit \fBTcl_ChannelWatchProc\fR, which returns
a pointa ta tha function.
.SS GETHANDLEPROC
.PP
Da \fIgetHandleProc\fR field gotz nuff tha address of a gangbangin' function called by
the generic layer ta retrieve a thugged-out device-specific handle from tha channel.
\fIGetHandleProc\fR should match tha followin prototype:
.PP
.CS
typedef int Tcl_DriverGetHandleProc(
        ClientData \fIinstanceData\fR,
        int \fIdirection\fR,
        ClientData *\fIhandlePtr\fR);
.CE
.PP
\fIInstanceData\fR is tha same ol' dirty as tha value passed to
\fBTcl_CreateChannel\fR when dis channel was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da \fIdirection\fR
argument is either \fBTCL_READABLE\fR ta retrieve tha handle used
for input, or \fBTCL_WRITABLE\fR ta retrieve tha handle used for
output.
.PP
If tha channel implementation has device-specific handles, the
function should retrieve tha appropriate handle associated wit the
channel, accordin tha \fIdirection\fR argument.  Da handle should be
stored up in tha location referred ta by \fIhandlePtr\fR, and
\fBTCL_OK\fR should be returned. Y'all KNOW dat shit, muthafucka!  If tha channel aint open fo' the
specified direction, or if tha channel implementation do not use
device handles, tha function should return \fBTCL_ERROR\fR.
.PP
This value can be retrieved wit \fBTcl_ChannelGetHandleProc\fR, which returns
a pointa ta tha function.
.SS FLUSHPROC
.PP
Da \fIflushProc\fR field is currently reserved fo' future use.
It should be set ta NULL.
\fIFlushProc\fR should match tha followin prototype:
.PP
.CS
typedef int Tcl_DriverFlushProc(
        ClientData \fIinstanceData\fR);
.CE
.PP
This value can be retrieved wit \fBTcl_ChannelFlushProc\fR, which returns
a pointa ta tha function.
.SS HANDLERPROC
.PP
Da \fIhandlezProc\fR field gotz nuff tha address of a gangbangin' function called by
the generic layer ta notify tha channel dat a event occurred. Y'all KNOW dat shit, muthafucka!  It should
be defined fo' stacked channel drivers dat wish ta be notified of events
that occur on tha underlyin (stacked) channel.
\fIHandlezProc\fR should match tha followin prototype:
.PP
.CS
typedef int Tcl_DriverHandlezProc(
        ClientData \fIinstanceData\fR,
        int \fIinterestMask\fR);
.CE
.PP
\fIInstanceData\fR is tha same ol' dirty as tha value passed ta \fBTcl_CreateChannel\fR
when dis channel was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \fIinterestMask\fR be a OR-ed
combination of \fBTCL_READABLE\fR or \fBTCL_WRITABLE\fR; it indicates what
type of event occurred on dis channel.
.PP
This value can be retrieved wit \fBTcl_ChannelHandlezProc\fR, which returns
a pointa ta tha function.

.SS "THREADACTIONPROC"
.PP
Da \fIthreadActionProc\fR field gotz nuff tha address of tha function
called by tha generic layer when a cold-ass lil channel is pimped, closed, or
goin ta move ta a gangbangin' finger-lickin' different thread, i.e. whenever thread-specific
driver state might gotta initialized or updated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Well shiiiit, it can be NULL.
Da action \fITCL_CHANNEL_THREAD_REMOVE\fR is used ta notify the
driver dat it should update or remove any thread-specific data it
might be maintainin fo' tha channel.
.PP
Da action \fITCL_CHANNEL_THREAD_INSERT\fR is used ta notify the
driver dat it should update or initialize any thread-specific data it
might be maintainin rockin tha callin thread as tha associate. Right back up in yo muthafuckin ass. See
\fBTcl_CutChannel\fR n' \fBTcl_SpliceChannel\fR fo' mo' detail.
.PP
.CS
typedef void Tcl_DriverThreadActionProc(
        ClientData \fIinstanceData\fR,
        int        \fIaction\fR);
.CE
.PP
\fIInstanceData\fR is tha same ol' dirty as tha value passed to
\fBTcl_CreateChannel\fR when dis channel was pimped.
.PP
These joints can be retrieved wit \fBTcl_ChannelThreadActionProc\fR,
which returns a pointa ta tha function.
.SS "TRUNCATEPROC"
.PP
Da \fItruncateProc\fR field gotz nuff tha address of tha function
called by tha generic layer when a cold-ass lil channel is truncated ta some
length. Well shiiiit, it can be NULL.
.PP
.CS
typedef int Tcl_DriverTruncateProc(
        ClientData \fIinstanceData\fR,
        Tcl_WideInt \fIlength\fR);
.CE
.PP
\fIInstanceData\fR is tha same ol' dirty as tha value passed to
\fBTcl_CreateChannel\fR when dis channel was pimped, and
\fIlength\fR is tha freshly smoked up length of tha underlyin file, which should
not be negative. Da result should be 0 on success or a errno code
(suitable fo' use wit \fBTcl_SetErrno\fR) on failure.
.PP
These joints can be retrieved wit \fBTcl_ChannelTruncateProc\fR,
which returns a pointa ta tha function.
.SH TCL_BADCHANNELOPTION
.PP
This procedure generates a
.QW "bad option"
error message up in an
(optional) interpreter n' shit.  It be used by channel drivers when 
an invalid Set/Git option is requested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Its purpose is ta concatenate
the generic options list ta tha specific ones n' factorize
the generic options error message string.
.PP
It always returns \fBTCL_ERROR\fR
.PP
An error message is generated up in \fIinterp\fRz result object to
indicate dat a cold-ass lil command was invoked wit a wack option.
Da message has tha form
.CS
    wack option "blah": should be one of 
    <...generic options...>+<...specific options...>
.CE
so you git fo' instance:
.CS
    wack option "-blah": should be one of -blocking,
    -buffering, -buffersize, -eofchar, -translation,
    -peername, or -sockname
.CE
when called wit \fIoptionList\fR equal to
.QW "peername sockname"
.PP
.QW blah
is tha \fIoptionName\fR argument and
.QW "<specific options>"
is a space separated list of specific option lyrics.
Da function takes phat care of insertin minus signs before
each option, commas after, n' an
.QW or
before tha last option.
.SH "OLD CHANNEL TYPES"
Da original gangsta (8.3.1 n' below) \fBTcl_ChannelType\fR structure gotz nuff
the followin fields:
.PP
.CS
typedef struct Tcl_ChannelType {
        char *\fItypeName\fR;
        Tcl_DriverBlockModeProc *\fIblockModeProc\fR;
        Tcl_DriverCloseProc *\fIcloseProc\fR;
        Tcl_DriverInputProc *\fIinputProc\fR;
        Tcl_DriverOutputProc *\fIoutputProc\fR;
        Tcl_DriverSeekProc *\fIseekProc\fR;
        Tcl_DriverSetOptionProc *\fIsetOptionProc\fR;
        Tcl_DriverGetOptionProc *\fIgetOptionProc\fR;
        Tcl_DriverWatchProc *\fIwatchProc\fR;
        Tcl_DriverGetHandleProc *\fIgetHandleProc\fR;
        Tcl_DriverClose2Proc *\fIclose2Proc\fR;
} Tcl_ChannelType;
.CE
.PP
It be still possible ta create channel wit tha above structure.  The
internal channel code will determine tha version. I aint talkin' bout chicken n' gravy biatch.  It be imperatizzle ta use
the freshly smoked up \fBTcl_ChannelType\fR structure if yo ass is bustin a stacked
channel driver, cuz of problems wit tha earlier stacked channel
implementation (in 8.2.0 ta 8.3.1).
.PP
Prior ta 8.4.0 (i.e. durin tha lata releasez of 8.3 n' early part
of tha 8.4 pimpment cycle) tha \fBTcl_ChannelType\fR structure
contained tha followin fields:
.PP
.CS
typedef struct Tcl_ChannelType {
        char *\fItypeName\fR;
        Tcl_ChannelTypeVersion \fIversion\fR;
        Tcl_DriverCloseProc *\fIcloseProc\fR;
        Tcl_DriverInputProc *\fIinputProc\fR;
        Tcl_DriverOutputProc *\fIoutputProc\fR;
        Tcl_DriverSeekProc *\fIseekProc\fR;
        Tcl_DriverSetOptionProc *\fIsetOptionProc\fR;
        Tcl_DriverGetOptionProc *\fIgetOptionProc\fR;
        Tcl_DriverWatchProc *\fIwatchProc\fR;
        Tcl_DriverGetHandleProc *\fIgetHandleProc\fR;
        Tcl_DriverClose2Proc *\fIclose2Proc\fR;
        Tcl_DriverBlockModeProc *\fIblockModeProc\fR;
        Tcl_DriverFlushProc *\fIflushProc\fR;
        Tcl_DriverHandlezProc *\fIhandlezProc\fR;
        Tcl_DriverTruncateProc *\fItruncateProc\fR;
} Tcl_ChannelType;
.CE
.PP
When tha above structure is registered as a cold-ass lil channel type, the
\fIversion\fR field should always be \fBTCL_CHANNEL_VERSION_2\fR.

.SH "SEE ALSO"
Tcl_Close(3), Tcl_OpenFileChannel(3), Tcl_SetErrno(3), Tcl_QueueEvent(3), Tcl_StackChannel(3), Tcl_GetStdChannel(3)

.SH KEYWORDS
blocking, channel driver, channel registration, channel type, nonblocking
