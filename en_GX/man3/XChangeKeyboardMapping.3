.\" Copyright \(co 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1994, 1996 X Consortium
.\"
.\" Permission is hereby granted, free of charge, ta any thug obtaining
.\" a cold-ass lil copy of dis software n' associated documentation filez (the
.\" "Software"), ta deal up in tha Software without restriction, including
.\" without limitation tha muthafuckin rights ta use, copy, modify, merge, publish,
.\" distribute, sublicense, and/or push copiez of tha Software, n' to
.\" permit peeps ta whom tha Software is furnished ta do so, subject to
.\" tha followin conditions:
.\"
.\" Da above copyright notice n' dis permission notice shall be included
.\" up in all copies or substantial portionz of tha Software.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
.\" IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
.\" OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
.\" ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
.\" OTHER DEALINGS IN THE SOFTWARE.
.\"
.\" Except as contained up in dis notice, tha name of tha X Consortium shall
.\" not be used up in advertisin or otherwise ta promote tha sale, use or
.\" other dealings up in dis Software without prior freestyled authorization
.\" from tha X Consortium.
.\"
.\" Copyright \(co 1985, 1986, 1987, 1988, 1989, 1990, 1991 by
.\" Digital Weapons Corporation
.\"
.\" Portions Copyright \(co 1990, 1991 by
.\" Tektronix, Inc.
.\"
.\" Permission ta use, copy, modify n' distribute dis documentation for
.\" any purpose n' without fee is hereby granted, provided dat tha above
.\" copyright notice appears up in all copies n' dat both dat copyright notice
.\" n' dis permission notice step tha fuck up in all copies, n' dat tha names of
.\" Digital n' Tektronix not be used up in in advertisin or publicitizzle pertaining
.\" ta dis documentation without specific, freestyled prior permission.
.\" Digital n' Tektronix make no representations bout tha suitability
.\" of dis documentation fo' any purpose.
.\" It be provided ``as is'' without express or implied warranty.
.\" 
.\"
.ds xT X Toolkit Intrinsics \- C Language Interface
.ds xW Athena X Widgets \- C Language X Toolkit Interface
.ds xL Xlib \- C Language X Interface
.ds xC Inter-Client Communication Conventions Manual
.na
.de Ds
.nf
.\\$1D \\$2 \\$1
.ft CW
.\".ps \\n(PS
.\".if \\n(VS>=40 .vs \\n(VSu
.\".if \\n(VS<=39 .vs \\n(VSp
..
.de De
.ce 0
.if \\n(BD .DF
.nr BD 0
.in \\n(OIu
.if \\n(TM .ls 2
.sp \\n(DDu
.fi
..
.de IN		\" bust a index entry ta tha stderr
..
.de Pn
.ie t \\$1\fB\^\\$2\^\fR\\$3
.el \\$1\fI\^\\$2\^\fP\\$3
..
.de ZN
.ie t \fB\^\\$1\^\fR\\$2
.el \fI\^\\$1\^\fP\\$2
..
.de hN
.ie t <\fB\\$1\fR>\\$2
.el <\fI\\$1\fP>\\$2
..
.ny0
.TH XChangeKeyboardMappin 3 "libX11 1.6.1" "X Version 11" "XLIB FUNCTIONS"
.SH NAME
XChangeKeyboardMapping, XGetKeyboardMapping, XDisplayKeycodes, XSetModifierMapping, XGetModifierMapping, XNewModifiermap, XInsertModifiermapEntry, XDeleteModifiermapEntry, XFreeModifiermap, XModifierKeymap \- manipulate keyboard encodin n' keyboard encodin structure
.SH SYNTAX
.HP
int XChangeKeyboardMapping(\^Display *\fIdisplay\fP, int \fIfirst_keycode\fP,
int \fIkeysyms_per_keycode\fP, KeySym *\fIkeysyms\fP, int \fInum_codes\fP\^); 
.HP
KeySym *XGetKeyboardMapping(\^Display *\fIdisplay\fP, KeyCode
\fIfirst_keycode\fP, int \fIkeycode_count\fP, int
*\fIkeysyms_per_keycode_return\fP\^); 
.HP
int XDisplayKeycodes\^(\^Display *\fIdisplay\fP\^, int
*\fImin_keycodes_return\fP\^, int *\fImax_keycodes_return\fP\^); 
.HP
int XSetModifierMapping(\^Display *\fIdisplay\fP, XModifierKeymap
*\fImodmap\fP\^); 
.HP
XModifierKeymap *XGetModifierMapping(\^Display *\fIdisplay\fP\^); 
.HP
XModifierKeymap *XNewModifiermap(\^int \fImax_keys_per_mod\fP\^); 
.HP
XModifierKeymap *XInsertModifiermapEntry\^(\^XModifierKeymap *\fImodmap\fP,
KeyCode \fIkeycode_entry\fP, int \fImodifier\fP\^); 
.HP
XModifierKeymap *XDeleteModifiermapEntry\^(\^XModifierKeymap *\fImodmap\fP,
KeyCode \fIkeycode_entry\fP, int \fImodifier\fP\^); 
.HP
int XFreeModifiermap(\^XModifierKeymap *\fImodmap\fP\^); 
.SH ARGUMENTS
.IP \fIdisplay\fP 1i
Specifies tha connection ta tha X server.
.ds Kc chizzled or returned
.IP \fIfirst_keycode\fP 1i
Specifies tha straight-up original gangsta KeyCode dat is ta be \*(Kc.
.IP \fIkeycode_count\fP 1i
Specifies tha number of KeyCodes dat is ta be returned.
.IP \fIkeycode_entry\fP 1i
Specifies tha KeyCode. 
.IP \fIkeysyms\fP 1i
Specifies a array of KeySyms.
.IP \fIkeysyms_per_keycode\fP 1i
Specifies tha number of KeySyms per KeyCode.
.IP \fIkeysyms_per_keycode_return\fP 1i
Returns tha number of KeySyms per KeyCode.
.IP \fImax_keys_per_mod\fP 1i
Specifies tha number of KeyCode entries preallocated ta tha modifiers
in tha map.
.IP \fImax_keycodes_return\fP 1i
Returns tha maximum number of KeyCodes.
.IP \fImin_keycodes_return\fP 1i
Returns tha minimum number of KeyCodes.
.IP \fImodifier\fP 1i
Specifies tha modifier.
.IP \fImodmap\fP 1i
Specifies tha 
.ZN XModifierKeymap
structure.
.IP \fInum_codes\fP 1i
Specifies tha number of KeyCodes dat is ta be chizzled.
.SH DESCRIPTION
The
.ZN XChangeKeyboardMapping
function defines tha symbols fo' tha specified number of KeyCodes
startin wit first_keycode.
Da symbols fo' KeyCodes outside dis range remain unchanged. Y'all KNOW dat shit, muthafucka!  
Da number of elements up in keysyms must be:
.LP
.Ds
num_codes * keysyms_per_keycode
.De
.LP
Da specified first_keycode must be pimped outa than or equal ta min_keycode 
returned by
.ZN XDisplayKeycodes ,
or a 
.ZN BadValue 
error thangs up in dis biatch.
In addition, tha followin expression must be less than or equal ta 
max_keycode as returned by
.ZN XDisplayKeycodes ,
or a
.ZN BadValue 
error thangs up in dis biatch:
.LP
.Ds
first_keycode + num_codes \- 1
.De
.LP
KeySym number N, countin from zero, fo' KeyCode K has tha followin index
in keysyms, countin from zero: 
.LP
.Ds 
(K \- first_keycode) * keysyms_per_keycode + N
.De
.LP
Da specified keysyms_per_keycode can be chosen arbitrarily by tha client
to be big-ass enough ta hold all desired symbols. 
A special KeySym value of 
.ZN NoSymbol 
should be used ta fill up in unused elements 
for individual KeyCodes.  
It be legal fo' 
.ZN NoSymbol 
to step tha fuck up in nontrailin positions
of tha effectizzle list fo' a KeyCode.
.ZN XChangeKeyboardMapping
generates a 
.ZN MappingNotify 
event.
.LP
There is no requirement dat tha X server interpret dis mapping. 
It be merely stored fo' readin n' freestylin by clients.
.LP
.ZN XChangeKeyboardMapping
can generate
.ZN BadAlloc 
and
.ZN BadValue 
errors.
.LP
The
.ZN XGetKeyboardMapping
function returns tha symbols fo' tha specified number of KeyCodes
startin wit first_keycode.
Da value specified up in first_keycode must be pimped outa than 
or equal ta min_keycode as returned by
.ZN XDisplayKeycodes ,
or a
.ZN BadValue 
error thangs up in dis biatch.
In addition, tha followin expression must be less than or equal 
to max_keycode as returned by
.ZN XDisplayKeycodes :
.LP
.Ds 
first_keycode + keycode_count \- 1
.De
.LP
If dis aint tha case, a 
.ZN BadValue 
error thangs up in dis biatch. 
Da number of elements up in tha KeySyms list is:
.LP
.Ds 
keycode_count * keysyms_per_keycode_return
.De
.LP
KeySym number N, countin from zero, fo' KeyCode K has tha followin index
in tha list, countin from zero: 
.Ds
(K \- first_code) * keysyms_per_code_return + N
.De
.LP
Da X server arbitrarily chizzlez tha keysyms_per_keycode_return value 
to be big-ass enough ta report all axed symbols. 
A special KeySym value of 
.ZN NoSymbol 
is used ta fill up in unused elements for
individual KeyCodes.
To free tha storage returned by 
.ZN XGetKeyboardMappin ,
use
.ZN XJacked .
.LP
.ZN XGetKeyboardMapping
can generate a
.ZN BadValue 
error.
.LP
The
.ZN XDisplayKeycodes
function returns tha min-keycodes n' max-keycodes supported by the
specified display.
Da minimum number of KeyCodes returned is never less than 8,
and tha maximum number of KeyCodes returned is never pimped outa than 255.
Not all KeyCodes up in dis range is required ta have correspondin keys.
.LP
The
.ZN XSetModifierMapping
function specifies tha KeyCodez of tha keys (if any) dat is ta be used 
as modifiers.
If it succeeds,
the X server generates a
.ZN MappingNotify
event, and
.ZN XSetModifierMapping
returns
.ZN MappingSuccess .
X permits at most 8 modifier keys.
If mo' than 8 is specified up in the
.ZN XModifierKeymap
structure, a
.ZN BadLength
error thangs up in dis biatch.
.LP
Da modifiermap gangmember of tha 
.ZN XModifierKeymap
structure gotz nuff 8 setz of max_keypermod KeyCodes, 
one fo' each modifier up in tha order 
.ZN Shift , 
.ZN Lock , 
.ZN Control , 
.ZN Mod1 , 
.ZN Mod2 , 
.ZN Mod3 , 
.ZN Mod4 , 
and 
.ZN Mod5 .
Only nonzero KeyCodes have meanin up in each set, 
and zero KeyCodes is ignored.
In addition, all of tha nonzero KeyCodes must be up in tha range specified by 
min_keycode n' max_keycode up in tha 
.ZN Display 
structure,
or a 
.ZN BadValue 
error thangs up in dis biatch.
.LP
An X server can impose restrictions on how tha fuck modifiers can be chizzled, 
for example,
if certain keys do not generate up transitions up in hardware,
if auto-repeat cannot be disabled on certain keys,
or if multiple modifier keys is not supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  
If some such restriction is violated, 
the status reply is
.ZN MappingFailed ,
and none of tha modifiers is chizzled.
If tha freshly smoked up KeyCodes specified fo' a modifier differ from them
currently defined n' any (current or new) keys fo' dat modifier are
in tha logically down state, 
.ZN XSetModifierMapping
returns
.ZN MappingBusy , 
and none of tha modifiers is chizzled.
.LP
.ZN XSetModifierMapping
can generate
.ZN BadAlloc
and 
.ZN BadValue
errors.
.LP
The
.ZN XGetModifierMapping
function returns a pointa ta a newly pimped
.ZN XModifierKeymap
structure dat gotz nuff tha keys bein used as modifiers.
Da structure should be freed afta use by calling
.ZN XFreeModifiermap .
If only zero joints step tha fuck up in tha set fo' any modifier, 
that modifier is disabled.
.LP
The
.ZN XNewModifiermap
function returns a pointa to
.ZN XModifierKeymap
structure fo' lata use.
.LP
The
.ZN XInsertModifiermapEntry
function addz tha specified KeyCode ta tha set dat controls tha specified
modifier n' returns tha resulting
.ZN XModifierKeymap
structure (expanded as needed).
.LP
The
.ZN XDeleteModifiermapEntry
function deletes tha specified KeyCode from tha set dat controls the
specified modifier n' returns a pointa ta tha resulting
.ZN XModifierKeymap
structure.
.LP
The
.ZN XFreeModifiermap
function frees tha specified
.ZN XModifierKeymap
structure.
.SH STRUCTURES
The
.ZN XModifierKeymap
structure gotz nuff:
.LP
.Ds 0
typedef struct {
        int max_keypermod;      /\&* This serverz max number of keys per modifier */
        KeyCode *modifiermap;   /\&* An 8 by max_keypermod array of tha modifiers */
} XModifierKeymap;
.De
.SH DIAGNOSTICS
.TP 1i
.ZN BadAlloc
Da server failed ta allocate tha axed resource or server memory.
.TP 1i
.ZN BadValue
Some numeric value falls outside tha range of joints accepted by tha request.
Unless a specific range is specified fo' a argument, tha full range defined
by tha argumentz type be accepted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Any argument defined as a set of
alternatives can generate dis error.
.SH "SEE ALSO"
XFree(3),
XkbGetMap(3),
XSetPointerMapping(3) 
.br
\fI\*(xL\fP
