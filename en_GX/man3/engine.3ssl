.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "engine 3"
.TH engine 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
engine \- ENGINE cryptographic module support
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/engine.h>
\&
\& ENGINE *ENGINE_get_first(void);
\& ENGINE *ENGINE_get_last(void);
\& ENGINE *ENGINE_get_next(ENGINE *e);
\& ENGINE *ENGINE_get_prev(ENGINE *e);
\&
\& int ENGINE_add(ENGINE *e);
\& int ENGINE_remove(ENGINE *e);
\&
\& ENGINE *ENGINE_by_id(const char *id);
\&
\& int ENGINE_init(ENGINE *e);
\& int ENGINE_finish(ENGINE *e);
\&
\& void ENGINE_load_openssl(void);
\& void ENGINE_load_dynamic(void);
\& #ifndef OPENSSL_NO_STATIC_ENGINE
\& void ENGINE_load_4758cca(void);
\& void ENGINE_load_aep(void);
\& void ENGINE_load_atalla(void);
\& void ENGINE_load_chil(void);
\& void ENGINE_load_cswift(void);
\& void ENGINE_load_gmp(void);
\& void ENGINE_load_nuron(void);
\& void ENGINE_load_sureware(void);
\& void ENGINE_load_ubsec(void);
\& #endif
\& void ENGINE_load_cryptodev(void);
\& void ENGINE_load_builtin_engines(void);
\&
\& void ENGINE_cleanup(void);
\&
\& ENGINE *ENGINE_get_default_RSA(void);
\& ENGINE *ENGINE_get_default_DSA(void);
\& ENGINE *ENGINE_get_default_ECDH(void);
\& ENGINE *ENGINE_get_default_ECDSA(void);
\& ENGINE *ENGINE_get_default_DH(void);
\& ENGINE *ENGINE_get_default_RAND(void);
\& ENGINE *ENGINE_get_cipher_engine(int nid);
\& ENGINE *ENGINE_get_digest_engine(int nid);
\&
\& int ENGINE_set_default_RSA(ENGINE *e);
\& int ENGINE_set_default_DSA(ENGINE *e);
\& int ENGINE_set_default_ECDH(ENGINE *e);
\& int ENGINE_set_default_ECDSA(ENGINE *e);
\& int ENGINE_set_default_DH(ENGINE *e);
\& int ENGINE_set_default_RAND(ENGINE *e);
\& int ENGINE_set_default_ciphers(ENGINE *e);
\& int ENGINE_set_default_digests(ENGINE *e);
\& int ENGINE_set_default_string(ENGINE *e, const char *list);
\&
\& int ENGINE_set_default(ENGINE *e, unsigned int flags);
\&
\& unsigned int ENGINE_get_table_flags(void);
\& void ENGINE_set_table_flags(unsigned int flags);
\&
\& int ENGINE_register_RSA(ENGINE *e);
\& void ENGINE_unregister_RSA(ENGINE *e);
\& void ENGINE_register_all_RSA(void);
\& int ENGINE_register_DSA(ENGINE *e);
\& void ENGINE_unregister_DSA(ENGINE *e);
\& void ENGINE_register_all_DSA(void);
\& int ENGINE_register_ECDH(ENGINE *e);
\& void ENGINE_unregister_ECDH(ENGINE *e);
\& void ENGINE_register_all_ECDH(void);
\& int ENGINE_register_ECDSA(ENGINE *e);
\& void ENGINE_unregister_ECDSA(ENGINE *e);
\& void ENGINE_register_all_ECDSA(void);
\& int ENGINE_register_DH(ENGINE *e);
\& void ENGINE_unregister_DH(ENGINE *e);
\& void ENGINE_register_all_DH(void);
\& int ENGINE_register_RAND(ENGINE *e);
\& void ENGINE_unregister_RAND(ENGINE *e);
\& void ENGINE_register_all_RAND(void);
\& int ENGINE_register_STORE(ENGINE *e);
\& void ENGINE_unregister_STORE(ENGINE *e);
\& void ENGINE_register_all_STORE(void);
\& int ENGINE_register_ciphers(ENGINE *e);
\& void ENGINE_unregister_ciphers(ENGINE *e);
\& void ENGINE_register_all_ciphers(void);
\& int ENGINE_register_digests(ENGINE *e);
\& void ENGINE_unregister_digests(ENGINE *e);
\& void ENGINE_register_all_digests(void);
\& int ENGINE_register_complete(ENGINE *e);
\& int ENGINE_register_all_complete(void);
\&
\& int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void));
\& int ENGINE_cmd_is_executable(ENGINE *e, int cmd);
\& int ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name,
\&         long i, void *p, void (*f)(void), int cmd_optional);
\& int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,
\&         int cmd_optional);
\&
\& int ENGINE_set_ex_data(ENGINE *e, int idx, void *arg);
\& void *ENGINE_get_ex_data(const ENGINE *e, int idx);
\&
\& int ENGINE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
\&         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
\&
\& ENGINE *ENGINE_new(void);
\& int ENGINE_free(ENGINE *e);
\& int ENGINE_up_ref(ENGINE *e);
\&
\& int ENGINE_set_id(ENGINE *e, const char *id);
\& int ENGINE_set_name(ENGINE *e, const char *name);
\& int ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth);
\& int ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth);
\& int ENGINE_set_ECDH(ENGINE *e, const ECDH_METHOD *dh_meth);
\& int ENGINE_set_ECDSA(ENGINE *e, const ECDSA_METHOD *dh_meth);
\& int ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth);
\& int ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth);
\& int ENGINE_set_STORE(ENGINE *e, const STORE_METHOD *rand_meth);
\& int ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR destroy_f);
\& int ENGINE_set_init_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR init_f);
\& int ENGINE_set_finish_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR finish_f);
\& int ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR ctrl_f);
\& int ENGINE_set_load_privkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpriv_f);
\& int ENGINE_set_load_pubkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpub_f);
\& int ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f);
\& int ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f);
\& int ENGINE_set_flags(ENGINE *e, int flags);
\& int ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns);
\&
\& const char *ENGINE_get_id(const ENGINE *e);
\& const char *ENGINE_get_name(const ENGINE *e);
\& const RSA_METHOD *ENGINE_get_RSA(const ENGINE *e);
\& const DSA_METHOD *ENGINE_get_DSA(const ENGINE *e);
\& const ECDH_METHOD *ENGINE_get_ECDH(const ENGINE *e);
\& const ECDSA_METHOD *ENGINE_get_ECDSA(const ENGINE *e);
\& const DH_METHOD *ENGINE_get_DH(const ENGINE *e);
\& const RAND_METHOD *ENGINE_get_RAND(const ENGINE *e);
\& const STORE_METHOD *ENGINE_get_STORE(const ENGINE *e);
\& ENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e);
\& ENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e);
\& ENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e);
\& ENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e);
\& ENGINE_LOAD_KEY_PTR ENGINE_get_load_privkey_function(const ENGINE *e);
\& ENGINE_LOAD_KEY_PTR ENGINE_get_load_pubkey_function(const ENGINE *e);
\& ENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e);
\& ENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e);
\& const EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid);
\& const EVP_MD *ENGINE_get_digest(ENGINE *e, int nid);
\& int ENGINE_get_flags(const ENGINE *e);
\& const ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e);
\&
\& EVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char *key_id,
\&     UI_METHOD *ui_method, void *callback_data);
\& EVP_PKEY *ENGINE_load_public_key(ENGINE *e, const char *key_id,
\&     UI_METHOD *ui_method, void *callback_data);
\&
\& void ENGINE_add_conf_module(void);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These functions create, manipulate, n' use cryptographic modulez up in the
form of \fB\s-1ENGINE\s0\fR objects, n' you can put dat on yo' toast. These objects act as containers for
implementationz of cryptographic algorithms, n' support a
reference-counted mechanizzle ta allow dem ta be dynamically loaded up in and
out of tha hustlin application.
.PP
Da cryptographic functionalitizzle dat can be provided by a \fB\s-1ENGINE\s0\fR
implementation includes tha followin abstractions;
.PP
.Vb 6
\& RSA_METHOD \- fo' providin alternatizzle RSA implementations
\& DSA_METHOD, DH_METHOD, RAND_METHOD, ECDH_METHOD, ECDSA_METHOD,
\&       STORE_METHOD \- similarly fo' other OpenSSL APIs
\& EVP_CIPHER \- potentially multiple cipher algorithms (indexed by \*(Aqnid\*(Aq)
\& EVP_DIGEST \- potentially multiple hash algorithms (indexed by \*(Aqnid\*(Aq)
\& key\-loadin \- loadin hood and/or private EVP_PKEY keys
.Ve
.SS "Reference countin n' handles"
.IX Subsection "Reference countin n' handles"
Cuz of tha modular nature of tha \s-1ENGINE API,\s0 pointas ta ENGINEs need ta be
treated as handlez \- ie. not only as pointas yo, but also as references to
the underlyin \s-1ENGINE\s0 object. Ie. one should obtain a freshly smoked up reference when
makin copiez of a \s-1ENGINE\s0 pointa if tha copies is ghon be used (and
released) independently.
.PP
\&\s-1ENGINE\s0 objects have two levelz of reference-countin ta match tha way in
which tha objects is used. Y'all KNOW dat shit, muthafucka! At da most thugged-out basic level, each \s-1ENGINE\s0 pointa is
inherently a \fBstructural\fR reference \- a structural reference is required
to use tha pointa value at all, as dis kind of reference be a guarantee
that tha structure can not be deallocated until tha reference is busted out.
.PP
But fuck dat shiznit yo, tha word on tha street is dat a structural reference serves up no guarantee dat tha \s-1ENGINE\s0 is
initiliased n' able ta use any of its cryptographic
implementations. Git tha fuck outta mah grill wit dat bullshit itz like possible dat most ENGINEs will not
initialise at all up in typical environments, as ENGINEs is typically used to
support specialised hardware. To use a \s-1ENGINE\s0z functionality, you need a
\&\fBfunctional\fR reference. This kind of reference can be considered a
specialised form of structural reference, cuz each functionizzle reference
implicitly gotz nuff a structural reference as well \- however ta avoid
difficult-to-find programmin bugs, it is recommended ta treat tha two
kindz of reference independently. If you gotz a gangbangin' functionizzle reference ta an
\&\s-1ENGINE,\s0 you gotz a guarantee dat tha \s-1ENGINE\s0 has been initialised locked n loaded to
perform cryptographic operations n' will remain uninitialised
until afta you have busted out yo' reference.
.PP
\&\fIStructural references\fR
.PP
This basic type of reference is used fo' instantiatin freshly smoked up ENGINEs,
iteratin across OpenSSLz internal linked-list of loaded
ENGINEs, readin shiznit bout a \s-1ENGINE,\s0 etc. Essentially a structural
reference is sufficient if you only need ta query or manipulate tha data of
an \s-1ENGINE\s0 implementation rather than use its functionality.
.PP
Da \fIENGINE_new()\fR function returns a structural reference ta a freshly smoked up (empty)
\&\s-1ENGINE\s0 object. There is other \s-1ENGINE API\s0 functions dat return structural
references such as; \fIENGINE_by_id()\fR, \fIENGINE_get_first()\fR, \fIENGINE_get_last()\fR,
\&\fIENGINE_get_next()\fR, \fIENGINE_get_prev()\fR fo' realz. All structural references should be
released by a cold-ass lil correspondin ta booty-call ta tha \fIENGINE_free()\fR function \- the
\&\s-1ENGINE\s0 object itself will only straight-up be cleaned up n' deallocated when
the last structural reference is busted out.
.PP
It should also be noted dat nuff \s-1ENGINE API\s0 function calls dat accept a
structural reference will internally obtain another reference \- typically
this happens whenever tha supplied \s-1ENGINE\s0 is ghon be needed by OpenSSL after
the function has returned. Y'all KNOW dat shit, muthafucka! Eg. tha function ta add a freshly smoked up \s-1ENGINE\s0 to
OpenSSLz internal list is \fIENGINE_add()\fR \- if dis function returns success,
then OpenSSL gonna git stored a freshly smoked up structural reference internally so the
calla is still responsible fo' freein they own reference with
\&\fIENGINE_free()\fR when they is finished wit dat shit. In a similar way, some
functions will automatically release tha structural reference passed ta it
if part of tha functionz thang is ta do so. Eg. tha \fIENGINE_get_next()\fR and
\&\fIENGINE_get_prev()\fR functions is used fo' iteratin across tha internal
\&\s-1ENGINE\s0 list \- they will return a freshly smoked up structural reference ta tha next (or
previous) \s-1ENGINE\s0 up in tha list or \s-1NULL\s0 if all up in tha end (or beginning) of the
list yo, but up in either case tha structural reference passed ta tha function is
released on behalf of tha caller.
.PP
To clarify a particular functionz handlin of references, one should
always consult dat functionz documentation \*(L"man\*(R" page, or failin that
the openssl/engine.h header file includes some hints.
.PP
\&\fIFunctionizzle references\fR
.PP
As mentioned, functionizzle references exist when tha cryptographic
functionalitizzle of a \s-1ENGINE\s0 is required ta be available fo' realz. A functional
reference can be obtained up in one of two ways; from a existin structural
reference ta tha required \s-1ENGINE,\s0 or by askin OpenSSL fo' tha default
operationizzle \s-1ENGINE\s0 fo' a given cryptographic purpose.
.PP
To obtain a gangbangin' functionizzle reference from a existin structural reference,
call tha \fIENGINE_init()\fR function. I aint talkin' bout chicken n' gravy biatch. This returns zero if tha \s-1ENGINE\s0 was not
already operationizzle n' couldn't be successfully initialised (eg. lack of
system drivers, no special hardware attached, etc), otherwise it will
return non-zero ta indicate dat tha \s-1ENGINE\s0 is now operationizzle n' will
have allocated a freshly smoked up \fBfunctional\fR reference ta tha \s-1ENGINE.\s0 All functional
references is busted out by callin \fIENGINE_finish()\fR (which removes the
implicit structural reference as well).
.PP
Da second way ta git a gangbangin' functionizzle reference is by askin OpenSSL fo' a
default implementation fo' a given task, eg. by \fIENGINE_get_default_RSA()\fR,
\&\fIENGINE_get_default_cipher_engine()\fR, etc. These is discussed up in tha next
section, though they is not probably required by application programmers as
they is used automatically when bustin n' rockin tha relevant
algorithm-specific types up in OpenSSL, like fuckin \s-1RSA, DSA, EVP_CIPHER_CTX,\s0 etc.
.SS "Default implementations"
.IX Subsection "Default implementations"
For each supported abstraction, tha \s-1ENGINE\s0 code maintains a internal table
of state ta control which implementations is available fo' a given
abstraction n' which should be used by default. These implementations are
registered up in tha tablez n' indexed by a 'nid' value, cuz
abstractions like \s-1EVP_CIPHER\s0 n' \s-1EVP_DIGEST\s0 support nuff distinct
algorithms n' modes, n' ENGINEs can support arbitrarily nuff of em.
In tha case of other abstractions like \s-1RSA, DSA,\s0 etc, there is only one
\&\*(L"algorithm\*(R" so all implementations implicitly regista rockin tha same 'nid'
index.
.PP
When a thugged-out default \s-1ENGINE\s0 be axed fo' a given abstraction/algorithm/mode, (eg.
when callin RSA_new_method(\s-1NULL\s0)), a \*(L"get_default\*(R" call is ghon be made ta the
\&\s-1ENGINE\s0 subsystem ta process tha correspondin state table n' return a
functionizzle reference ta a initialised \s-1ENGINE\s0 whose implementation should be
used. Y'all KNOW dat shit, muthafucka! If no \s-1ENGINE\s0 should (or can) be used, it will return \s-1NULL\s0 n' tha caller
will operate wit a \s-1NULL ENGINE\s0 handle \- dis probably equates ta rockin the
conventionizzle software implementation. I aint talkin' bout chicken n' gravy biatch. In tha latta case, OpenSSL will from
then on behave tha way it used ta before tha \s-1ENGINE API\s0 existed.
.PP
Each state table has a gangbangin' flag ta note whether it has processed this
\&\*(L"get_default\*(R" query since tha table was last modified, cuz ta process
this question it must iterate across all tha registered ENGINEs up in the
table tryin ta initialise each of dem up in turn, up in case one of dem is
operational. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If it returns a gangbangin' functionizzle reference ta a \s-1ENGINE,\s0 it will
also cache another reference ta speed up processin future queries (without
needin ta iterate across tha table). Likewise, it will cache a \s-1NULL\s0
response if no \s-1ENGINE\s0 was available so dat future queries won't repeat the
same iteration unless tha state table chizzles. This behaviour can also be
changed; if tha \s-1ENGINE_TABLE_FLAG_NOINIT\s0 flag is set (using
\&\fIENGINE_set_table_flags()\fR), no attempted initialisations will take place,
instead tha only way fo' tha state table ta return a non-NULL \s-1ENGINE\s0 ta the
\&\*(L"get_default\*(R" query is ghon be if one is expressly set up in tha table. Eg.
\&\fIENGINE_set_default_RSA()\fR do tha same thang as \fIENGINE_register_RSA()\fR except
that it also sets tha state tablez cached response fo' tha \*(L"get_default\*(R"
query. In tha case of abstractions like \s-1EVP_CIPHER,\s0 where implementations are
indexed by 'nid', these flags n' cached-responses is distinct fo' each 'nid'
value.
.SS "Application requirements"
.IX Subsection "Application requirements"
This section will explain tha basic thangs a application programmer should
support ta make da most thugged-out useful elementz of tha \s-1ENGINE\s0 functionality
available ta tha user n' shit. Da first thang ta consider is whether the
programmer wishes ta make alternatizzle \s-1ENGINE\s0 modulez available ta the
application n' user n' shit. OpenSSL maintains a internal linked list of
\&\*(L"visible\*(R" ENGINEs from which it has ta operate \- at start-up, dis list is
empty n' up in fact if a application do not call any \s-1ENGINE API\s0 calls and
it uses static linkin against openssl, then tha resultin application
binary aint gonna contain any alternatizzle \s-1ENGINE\s0 code at all. Right back up in yo muthafuckin ass. So tha first
consideration is whether any/all available \s-1ENGINE\s0 implementations should be
made visible ta OpenSSL \- dis is controlled by callin tha various \*(L"load\*(R"
functions, eg.
.PP
.Vb 9
\& /* Make tha "dynamic" ENGINE available */
\& void ENGINE_load_dynamic(void);
\& /* Make tha CryptoSwift hardware acceleration support available */
\& void ENGINE_load_cswift(void);
\& /* Make support fo' nCipher\*(Aqs "CHIL" hardware available */
\& void ENGINE_load_chil(void);
\& ...
\& /* Make ALL ENGINE implementations bundled wit OpenSSL available */
\& void ENGINE_load_builtin_engines(void);
.Ve
.PP
Havin called any of these functions, \s-1ENGINE\s0 objects would have been
dynamically allocated n' populated wit these implementations n' linked
into OpenSSLz internal linked list fo' realz. At dis point it is blingin to
mention a blingin \s-1API\s0 function;
.PP
.Vb 1
\& void ENGINE_cleanup(void);
.Ve
.PP
If no \s-1ENGINE API\s0 functions is called at all up in a application, then there
are no inherent memory leaks ta worry bout from tha \s-1ENGINE\s0 functionality,
however if any ENGINEs is loaded, even if they is never registered or
used, it is necessary ta use tha \fIENGINE_cleanup()\fR function to
correspondingly cleanup before program exit, if tha calla wishes ta avoid
memory leaks. This mechanizzle uses a internal callback registration table
so dat any \s-1ENGINE API\s0 functionalitizzle dat knows it requires cleanup can
regista its cleanup details ta be called durin \fIENGINE_cleanup()\fR. This
approach allows \fIENGINE_cleanup()\fR ta clean up afta any \s-1ENGINE\s0 functionality
at all dat yo' program uses, yet don't automatically create linker
dependencies ta all possible \s-1ENGINE\s0 functionalitizzle \- only tha cleanup
callbacks required by tha functionalitizzle you do use is ghon be required by the
linker.
.PP
Da fact dat ENGINEs is made visible ta OpenSSL (and thus is linked into
the program n' loaded tha fuck into memory at run-time) do not mean they are
\&\*(L"registered\*(R" or called tha fuck into use by OpenSSL automatically \- dat behaviour
is suttin' fo' tha application ta control. Right back up in yo muthafuckin ass. Some applications
will wanna allow tha user ta specify exactly which \s-1ENGINE\s0 they want used
if any is ta be used at all. Others may prefer ta load all support n' have
OpenSSL automatically use at run-time any \s-1ENGINE\s0 dat be able to
successfully initialise \- ie. ta assume dat dis correspondz to
acceleration hardware attached ta tha machine or some such thang. There are
probably a shitload of other ways up in which applications may prefer ta handle
things, so we will simply illustrate tha consequences as they apply ta a
couple simple cases n' leave pimpers ta consider these n' the
source code ta opensslz builtin utilitizzles as guides.
.PP
\&\fIUsin a specific \s-1ENGINE\s0 implementation\fR
.PP
Here we'll assume a application has been configured by its user or admin
to wanna use tha \*(L"\s-1ACME\*(R" ENGINE\s0 if it be available up in tha version of
OpenSSL tha application was compiled with. If it be available, it should be
used by default fo' all \s-1RSA, DSA,\s0 n' symmetric cipher operation, otherwise
OpenSSL should use its builtin software as per usual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da followin code
illustrates how tha fuck ta approach this;
.PP
.Vb 10
\& ENGINE *e;
\& const char *engine_id = "ACME";
\& ENGINE_load_builtin_engines();
\& e = ENGINE_by_id(engine_id);
\& if(!e)
\&     /* tha engine isn\*(Aqt available */
\&     return;
\& if(!ENGINE_init(e)) {
\&     /* tha engine couldn\*(Aqt initialise, release \*(Aqe\*(Aq */
\&     ENGINE_free(e);
\&     return;
\& }
\& if(!ENGINE_set_default_RSA(e))
\&     /* This should only happen when \*(Aqe\*(Aq can\*(Aqt initialise yo, but tha previous
\&      * statement suggests it done did. Y'all KNOW dat shit, muthafucka! */
\&     abort();
\& ENGINE_set_default_DSA(e);
\& ENGINE_set_default_ciphers(e);
\& /* Release tha functionizzle reference from ENGINE_init() */
\& ENGINE_finish(e);
\& /* Release tha structural reference from ENGINE_by_id() */
\& ENGINE_free(e);
.Ve
.PP
\&\fIAutomatically rockin builtin \s-1ENGINE\s0 implementations\fR
.PP
Here we'll assume we wanna load n' regista all \s-1ENGINE\s0 implementations
bundled wit OpenSSL, such dat fo' any cryptographic algorithm required by
OpenSSL \- if there be a \s-1ENGINE\s0 dat implements it n' can be initialise,
it should be used. Y'all KNOW dat shit, muthafucka! Da followin code illustrates how tha fuck dis can work;
.PP
.Vb 4
\& /* Load all bundled ENGINEs tha fuck into memory n' make dem visible */
\& ENGINE_load_builtin_engines();
\& /* Regista all of dem fo' every last muthafuckin algorithm they collectively implement */
\& ENGINE_register_all_complete();
.Ve
.PP
Thatz all thatz required. Y'all KNOW dat shit, muthafucka! Eg. tha next time OpenSSL tries ta set up an
\&\s-1RSA\s0 key, any bundled ENGINEs dat implement \s-1RSA_METHOD\s0 is ghon be passed to
\&\fIENGINE_init()\fR n' if any of dem succeed, dat \s-1ENGINE\s0 is ghon be set as the
default fo' \s-1RSA\s0 use from then on.
.SS "Advanced configuration support"
.IX Subsection "Advanced configuration support"
There be a mechanizzle supported by tha \s-1ENGINE\s0 framework dat allows each
\&\s-1ENGINE\s0 implementation ta define a arbitrary set of configuration
\&\*(L"commands\*(R" n' expose dem ta OpenSSL n' any applications based on
OpenSSL. This mechanizzle is entirely based on tha use of name-value pairs
and assumes \s-1ASCII\s0 input (no unicode or \s-1UTF\s0 fo' now!), so it is ideal if
applications wanna provide a transparent way fo' playas ta provide
arbitrary configuration \*(L"directives\*(R" directly ta such ENGINEs. Well shiiiit, it be also
possible fo' tha application ta dynamically invigorate tha loaded \s-1ENGINE\s0
implementations fo' tha names, descriptions, n' input flagz of their
available \*(L"control commands\*(R", providin a mo' flexible configuration
scheme. But fuck dat shiznit yo, tha word on tha street is dat if tha user is sposed ta fuckin know which \s-1ENGINE\s0 thang he/she
is rockin (in tha case of specialised hardware, dis goes without saying)
then applications may not need ta concern theyselves wit discoverin the
supported control commandz n' simply prefer ta pass settings tha fuck into ENGINEs
exactly as they is provided by tha user.
.PP
Before illustratin how tha fuck control commandz work, it is worth mentionin what
they is typically used for. Shiiit, dis aint no joke. Broadly bustin lyrics there be two uses for
control commands; tha straight-up original gangsta is ta provide tha necessary details ta the
implementation (which may know not a god damn thang at all specific ta tha host system)
so dat it can be initialised fo' use. This could include tha path ta any
driver or config filez it need ta load, required network addresses,
smart-card identifiers, passwordz ta initialise protected devices,
loggin shiznit, etc etc. This class of commandz typically need ta be
passed ta a \s-1ENGINE \s0\fBbefore\fR attemptin ta initialise it, ie. before
callin \fIENGINE_init()\fR. Da other class of commandz consist of settings or
operations dat tweak certain behaviour or cause certain operations ta take
place, n' these commandz may work either before or afta \fIENGINE_init()\fR, or
in some cases both. \s-1ENGINE\s0 implementations should provide indications of
this up in tha descriptions attached ta builtin control commandz and/or in
external thang documentation.
.PP
\&\fIIssuin control commandz ta a \s-1ENGINE\s0\fR
.PP
Letz illustrate by example; a gangbangin' function fo' which tha calla supplies the
name of tha \s-1ENGINE\s0 it wishes ta use, a table of string-pairs fo' use before
initialisation, n' another table fo' use afta initialisation. I aint talkin' bout chicken n' gravy biatch. Note that
the string-pairs used fo' control commandz consist of a cold-ass lil command \*(L"name\*(R"
followed by tha command \*(L"parameter\*(R" \- tha parameta could be \s-1NULL\s0 up in some
cases but tha name can not. This function should initialise tha \s-1ENGINE
\&\s0(issuin tha \*(L"pre\*(R" commandz beforehand n' tha \*(L"post\*(R" commandz afterwards)
and set it as tha default fo' every last muthafuckin thang except \s-1RAND\s0 n' then return a
boolean success or failure.
.PP
.Vb 10
\& int generic_load_engine_fn(const char *engine_id,
\&                            const char **pre_cmds, int pre_num,
\&                            const char **post_cmds, int post_num)
\& {
\&     ENGINE *e = ENGINE_by_id(engine_id);
\&     if(!e) return 0;
\&     while(pre_num\-\-) {
\&         if(!ENGINE_ctrl_cmd_string(e, pre_cmds[0], pre_cmds[1], 0)) {
\&             fprintf(stderr, "Failed command (%s \- %s:%s)\en", engine_id,
\&                 pre_cmds[0], pre_cmds[1] , biatch? pre_cmds[1] : "(NULL)");
\&             ENGINE_free(e);
\&             return 0;
\&         }
\&         pre_cmdz += 2;
\&     }
\&     if(!ENGINE_init(e)) {
\&         fprintf(stderr, "Failed initialisation\en");
\&         ENGINE_free(e);
\&         return 0;
\&     }
\&     /* ENGINE_init() returned a gangbangin' functionizzle reference, so free tha structural
\&      * reference from ENGINE_by_id(). */
\&     ENGINE_free(e);
\&     while(post_num\-\-) {
\&         if(!ENGINE_ctrl_cmd_string(e, post_cmds[0], post_cmds[1], 0)) {
\&             fprintf(stderr, "Failed command (%s \- %s:%s)\en", engine_id,
\&                 post_cmds[0], post_cmds[1] , biatch? post_cmds[1] : "(NULL)");
\&             ENGINE_finish(e);
\&             return 0;
\&         }
\&         post_cmdz += 2;
\&     }
\&     ENGINE_set_default(e, ENGINE_METHOD_ALL & ~ENGINE_METHOD_RAND);
\&     /* Success */
\&     return 1;
\& }
.Ve
.PP
Note dat \fIENGINE_ctrl_cmd_string()\fR accepts a funky-ass boolean argument dat can
relax tha semantics of tha function \- if set non-zero it will only return
failure if tha \s-1ENGINE\s0 supported tha given command name but failed while
executin it, if tha \s-1ENGINE\s0 don't support tha command name it will simply
return success without bustin anything. In dis case we assume tha user is
only supplyin commandz specific ta tha given \s-1ENGINE\s0 so we set dis to
\&\s-1FALSE.\s0
.PP
\&\fIDiscoverin supported control commands\fR
.PP
It be possible ta discover at run-time tha names, numerical-ids, descriptions
and input parametaz of tha control commandz supported by a \s-1ENGINE\s0 rockin a
structural reference. Note dat some control commandz is defined by OpenSSL
itself n' it will intercept n' handle these control commandz on behalf of the
\&\s-1ENGINE,\s0 ie. tha \s-1ENGINE\s0z \fIctrl()\fR handlez aint used fo' tha control command.
openssl/engine.h defines a index, \s-1ENGINE_CMD_BASE,\s0 dat all control commands
implemented by ENGINEs should be numbered from fo' realz. Any command value lower than
this symbol is considered a \*(L"generic\*(R" command is handled directly by the
OpenSSL core routines.
.PP
It be rockin these \*(L"core\*(R" control commandz dat one can discover tha the control
commandz implemented by a given \s-1ENGINE,\s0 specifically tha commands;
.PP
.Vb 9
\& #define ENGINE_HAS_CTRL_FUNCTION               10
\& #define ENGINE_CTRL_GET_FIRST_CMD_TYPE         11
\& #define ENGINE_CTRL_GET_NEXT_CMD_TYPE          12
\& #define ENGINE_CTRL_GET_CMD_FROM_NAME          13
\& #define ENGINE_CTRL_GET_NAME_LEN_FROM_CMD      14
\& #define ENGINE_CTRL_GET_NAME_FROM_CMD          15
\& #define ENGINE_CTRL_GET_DESC_LEN_FROM_CMD      16
\& #define ENGINE_CTRL_GET_DESC_FROM_CMD          17
\& #define ENGINE_CTRL_GET_CMD_FLAGS              18
.Ve
.PP
Whilst these commandz is automatically processed by tha OpenSSL framework code,
they use various propertizzles exposed by each \s-1ENGINE\s0 ta process these
queries fo' realz. An \s-1ENGINE\s0 has 3 propertizzles it exposes dat can affect how tha fuck dis behaves;
it can supply a \fIctrl()\fR handlez, it can specify \s-1ENGINE_FLAGS_MANUAL_CMD_CTRL\s0 in
the \s-1ENGINE\s0z flags, n' it can expose a array of control command descriptions.
If a \s-1ENGINE\s0 specifies tha \s-1ENGINE_FLAGS_MANUAL_CMD_CTRL\s0 flag, then it will
simply pass all these \*(L"core\*(R" control commandz directly ta tha \s-1ENGINE\s0z \fIctrl()\fR
handlez (and thus, it must have supplied one), so it is up ta tha \s-1ENGINE\s0 to
reply ta these \*(L"discovery\*(R" commandz itself. If dat flag aint set, then the
OpenSSL framework code will work wit tha followin rules;
.PP
.Vb 9
\& if no ctrl() handlez supplied;
\&     ENGINE_HAS_CTRL_FUNCTION returns FALSE (zero),
\&     all other commandz fail.
\& if a cold-ass lil ctrl() handlez was supplied but no array of control commands;
\&     ENGINE_HAS_CTRL_FUNCTION returns TRUE,
\&     all other commandz fail.
\& if a cold-ass lil ctrl() handlez n' array of control commandz was supplied;
\&     ENGINE_HAS_CTRL_FUNCTION returns TRUE,
\&     all other commandz proceed processin ...
.Ve
.PP
If tha \s-1ENGINE\s0z array of control commandz is empty then all other commandz will
fail, otherwise; \s-1ENGINE_CTRL_GET_FIRST_CMD_TYPE\s0 returns tha identifier of
the first command supported by tha \s-1ENGINE, ENGINE_GET_NEXT_CMD_TYPE\s0 takes the
identifier of a cold-ass lil command supported by tha \s-1ENGINE\s0 n' returns tha next command
identifier or fails if there be no more, \s-1ENGINE_CMD_FROM_NAME\s0 takes a string
name fo' a cold-ass lil command n' returns tha correspondin identifier or fails if no such
command name exists, n' tha remainin commandz take a cold-ass lil command identifier and
return propertizzlez of tha correspondin commandz fo' realz. All except
\&\s-1ENGINE_CTRL_GET_FLAGS\s0 return tha strang length of a cold-ass lil command name or description,
or populate a supplied characta buffer wit a cold-ass lil copy of tha command name or
description. I aint talkin' bout chicken n' gravy biatch. \s-1ENGINE_CTRL_GET_FLAGS\s0 returns a funky-ass bitwise-OR'd mask of tha following
possible joints;
.PP
.Vb 4
\& #define ENGINE_CMD_FLAG_NUMERIC                (unsigned int)0x0001
\& #define ENGINE_CMD_FLAG_STRING                 (unsigned int)0x0002
\& #define ENGINE_CMD_FLAG_NO_INPUT               (unsigned int)0x0004
\& #define ENGINE_CMD_FLAG_INTERNAL               (unsigned int)0x0008
.Ve
.PP
If tha \s-1ENGINE_CMD_FLAG_INTERNAL\s0 flag is set, then any other flags is purely
informationizzle ta tha calla \- dis flag will prevent tha command bein usable
for any higher-level \s-1ENGINE\s0 functions like fuckin \fIENGINE_ctrl_cmd_string()\fR.
\&\*(L"\s-1INTERNAL\*(R"\s0 commandz is not intended ta be exposed ta text-based configuration
by applications, administrations, users, etc. These can support arbitrary
operations via \fIENGINE_ctrl()\fR, includin passin ta and/or from tha control
commandz data of any arbitrary type. These commandz is supported up in the
discovery mechanizzlez simply ta allow applications determinie if a \s-1ENGINE\s0
supports certain specific commandz it might wanna use (eg. application \*(L"foo\*(R"
might query various ENGINEs ta peep if they implement \*(L"\s-1FOO_GET_VENDOR_LOGO_GIF\*(R" \-\s0
and \s-1ENGINE\s0 could therefore decizzle whether or not ta support dis \*(L"foo\*(R"\-specific
extension).
.SS "Future pimpments"
.IX Subsection "Future pimpments"
Da \s-1ENGINE API\s0 n' internal architecture is currently bein reviewed. Y'all KNOW dat shit, muthafucka! Slated for
possible release up in 0.9.8 is support fo' transparent loadin of \*(L"dynamic\*(R"
ENGINEs (built as self-contained shared-libraries). This would allow \s-1ENGINE\s0
implementations ta be provided independently of OpenSSL libraries and/or
OpenSSL-based applications, n' would also remove any requirement for
applications ta explicitly use tha \*(L"dynamic\*(R" \s-1ENGINE\s0 ta bind ta shared-library
implementations.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrsa\fR\|(3), \fIdsa\fR\|(3), \fIdh\fR\|(3), \fIrand\fR\|(3)
