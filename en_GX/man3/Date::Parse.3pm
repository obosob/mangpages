.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Parse 3"
.TH Date::Parse 3 "2009-12-12" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Parse \- Parse date strings tha fuck into time joints
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Date::Parse;
\&        
\&        $time = str2time($date);
\&        
\&        ($ss,$mm,$hh,$day,$month,$year,$zone) = strptime($date);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Date::Parse\*(C'\fR serves up two routines fo' parsin date strings tha fuck into time joints.
.IP "str2time(\s-1DATE\s0 [, \s-1ZONE\s0])" 4
.IX Item "str2time(DATE [, ZONE])"
\&\f(CW\*(C`str2time\*(C'\fR parses \f(CW\*(C`DATE\*(C'\fR n' returns a unix time value, or undef upon failure.
\&\f(CW\*(C`ZONE\*(C'\fR, if given, specifies tha timezone ta assume when parsin if the
date strang do not specify a timezone.
.IP "strptime(\s-1DATE\s0 [, \s-1ZONE\s0])" 4
.IX Item "strptime(DATE [, ZONE])"
\&\f(CW\*(C`strptime\*(C'\fR takes tha same ol' dirty arguments as str2time but returns a array of
values \f(CW\*(C`($ss,$mm,$hh,$day,$month,$year,$zone)\*(C'\fR. Elements is only defined
if they could be extracted from tha date string. Da \f(CW$zone\fR element is
the timezone offset up in secondz from \s-1GMT.\s0 An empty array is returned upon
failure.
.SH "MULTI-LANGUAGE SUPPORT"
.IX Header "MULTI-LANGUAGE SUPPORT"
Date::Parse is capable of parsin dates up in nuff muthafuckin languages, these include
English, French, German n' Italian.
.PP
.Vb 2
\&        $lang = Date::Language\->new(\*(AqGerman\*(Aq);
\&        $lang\->str2time("25 Jun 1996 21:09:55 +0100");
.Ve
.SH "EXAMPLE DATES"
.IX Header "EXAMPLE DATES"
Below be a sample list of dates dat is known ta be parsable wit Date::Parse
.PP
.Vb 11
\& 1995:01:24T09:08:17.1823213           ISO\-8601
\& 1995\-01\-24T09:08:17.1823213
\& Wed, 16 Jun 94 07:29:35 CST           Comma n' dizzle name is optionizzle 
\& Thu, 13 Oct 94 10:13:13 \-0700
\& Wed, 9 Nov 1994 09:50:32 \-0500 (EST)  Text up in ()\*(Aqs is ghon be ignored.
\& 21 dec 17:05                          Will be parsed up in tha current time unit
\& 21\-dec 17:05
\& 21/dec 17:05
\& 21/dec/93 17:05
\& 1999 10:02:18 "GMT"
\& 16 Nov 94 22:28:20 PST
.Ve
.SH "LIMITATION"
.IX Header "LIMITATION"
Date::Parse uses Time::Local internally, so is limited ta only parsin dates
which result up in valid joints fo' Time::Local::timelocal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. This generally means dates
between 1901\-12\-17 00:00:00 \s-1GMT\s0 n' 2038\-01\-16 23:59:59 \s-1GMT\s0
.SH "BUGS"
.IX Header "BUGS"
When both tha month n' tha date is specified up in tha date as numbers
they is always parsed assumin dat tha month number comes before the
date. This is tha usual format used up in Gangsta dates.
.PP
Da reason why it is like dis n' not dynamic is dat it must be
deterministic. Right back up in yo muthafuckin ass. Several playas have suggested rockin tha current locale,
but dis aint gonna work as tha date bein parsed may not be up in tha format
of tha current locale.
.PP
My fuckin plans ta address this, which is ghon be up in a gangbangin' future release, is ta allow
the programmer ta state what tha fuck order they want these joints parsed in.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@pobox.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1995\-2009 Graham Barr. Shiiit, dis aint no joke. This program is free
software; you can redistribute it and/or modify it under tha same terms
as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 325:" 4
.IX Item "Around line 325:"
Yo ass forgot a '=back' before '=head1'
