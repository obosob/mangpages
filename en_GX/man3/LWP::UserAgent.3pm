.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LWP::UserAgent 3"
.TH LWP::UserAgent 3 "2013-03-11" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
LWP::UserAgent \- Web user agent class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& require LWP::UserAgent;
\& 
\& mah $ua = LWP::UserAgent\->new;
\& $ua\->timeout(10);
\& $ua\->env_proxy;
\& 
\& mah $response = $ua\->get(\*(Aqhttp://search.cpan.org/\*(Aq);
\& 
\& if ($response\->is_success) {
\&     print $response\->decoded_content;  # or whatever
\& }
\& else {
\&     take a thugged-out dirtnap $response\->status_line;
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`LWP::UserAgent\*(C'\fR be a cold-ass lil class implementin a wizzy user agent.
\&\f(CW\*(C`LWP::UserAgent\*(C'\fR objects can be used ta dispatch wizzy requests.
.PP
In aiiight use tha application creates a \f(CW\*(C`LWP::UserAgent\*(C'\fR object, and
then configures it wit joints fo' timeouts, proxies, name, etc. It
then creates a instizzle of \f(CW\*(C`HTTP::Request\*(C'\fR fo' tha request that
needz ta be performed. Y'all KNOW dat shit, muthafucka! This request is then passed ta one of the
request method tha UserAgent, which dispatches it rockin tha relevant
protocol, n' returns a \f(CW\*(C`HTTP::Response\*(C'\fR object.  There are
convenience methodz fo' bustin  da most thugged-out common request types: \fIget()\fR,
\&\fIhead()\fR, \fIpost()\fR, \fIput()\fR n' \fIdelete()\fR.  When rockin these methodz then the
creation of tha request object is hidden as shown up in tha synopsis above.
.PP
Da basic approach of tha library is ta use \s-1HTTP\s0 steez communication
for all protocol schemes.  This means dat yo big-ass booty is ghon construct
\&\f(CW\*(C`HTTP::Request\*(C'\fR objects n' receive \f(CW\*(C`HTTP::Response\*(C'\fR objects even
for non-HTTP resources like \fIgopher\fR n' \fIftp\fR.  In order ta achieve
even mo' similaritizzle ta \s-1HTTP\s0 steez communications, gopher menus and
file directories is converted ta \s-1HTML\s0 documents.
.SH "CONSTRUCTOR METHODS"
.IX Header "CONSTRUCTOR METHODS"
Da followin constructor methodz is available:
.ie n .IP "$ua = LWP::UserAgent\->new( %options )" 4
.el .IP "\f(CW$ua\fR = LWP::UserAgent\->new( \f(CW%options\fR )" 4
.IX Item "$ua = LWP::UserAgent->new( %options )"
This method constructs a freshly smoked up \f(CW\*(C`LWP::UserAgent\*(C'\fR object n' returns dat shit.
Key/value pair arguments may be provided ta set up tha initial state.
Da followin options correspond ta attribute methodz busted lyrics bout below:
.Sp
.Vb 10
\&   KEY                     DEFAULT
\&   \-\-\-\-\-\-\-\-\-\-\-             \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   agent                   "libwww\-perl/#.###"
\&   from                    undef
\&   conn_cache              undef
\&   cookie_jar              undef
\&   default_headaz         HTTP::Headers\->new
\&   local_address           undef
\&   ssl_opts                { verify_hostname => 1 }
\&   max_size                undef
\&   max_redirect            7
\&   parse_head              1
\&   protocols_allowed       undef
\&   protocols_forbidden     undef
\&   requests_redirectable   [\*(AqGET\*(Aq, \*(AqHEAD\*(Aq]
\&   timeout                 180
.Ve
.Sp
Da followin additionizzle options is also accepted: If tha \f(CW\*(C`env_proxy\*(C'\fR option
is passed up in wit a \s-1TRUE\s0 value, then proxy settings is read from environment
variablez (see \fIenv_proxy()\fR method below).  If \f(CW\*(C`env_proxy\*(C'\fR aint provided the
\&\f(CW\*(C`PERL_LWP_ENV_PROXY\*(C'\fR environment variable controls if \fIenv_proxy()\fR is called
durin initialization. I aint talkin' bout chicken n' gravy biatch.  If tha \f(CW\*(C`keep_kickin it\*(C'\fR option is passed in, then a
\&\f(CW\*(C`LWP::ConnCache\*(C'\fR is set up (see \fIconn_cache()\fR method below).  Da \f(CW\*(C`keep_kickin it\*(C'\fR
value is passed on as tha \f(CW\*(C`total_capacity\*(C'\fR fo' tha connection cache.
.ie n .IP "$ua\->clone" 4
.el .IP "\f(CW$ua\fR\->clone" 4
.IX Item "$ua->clone"
Returns a cold-ass lil copy of tha LWP::UserAgent object.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Da settingz of tha configuration attributes modify tha behaviour of the
\&\f(CW\*(C`LWP::UserAgent\*(C'\fR when it dispatches requests, n' you can put dat on yo' toast.  Most of these can also
be initialized by options passed ta tha constructor method.
.PP
Da followin attribute methodz is provided. Y'all KNOW dat shit, muthafucka!  Da attribute value is
left unchanged if no argument is given. I aint talkin' bout chicken n' gravy biatch.  Da return value from each
method is tha oldschool attribute value.
.ie n .IP "$ua\->agent" 4
.el .IP "\f(CW$ua\fR\->agent" 4
.IX Item "$ua->agent"
.PD 0
.ie n .IP "$ua\->agent( $product_id )" 4
.el .IP "\f(CW$ua\fR\->agent( \f(CW$product_id\fR )" 4
.IX Item "$ua->agent( $product_id )"
.PD
Get/set tha thang token dat is used ta identify tha user agent on
the network.  Da agent value is busted as tha \*(L"User-Agent\*(R" header in
the requests, n' you can put dat on yo' toast.  Da default is tha strang returned by tha \fI_agent()\fR
method (see below).
.Sp
If tha \f(CW$product_id\fR endz wit space then tha \fI_agent()\fR strang is
appended ta dat shit.
.Sp
Da user agent strang should be one or mo' simple thang identifiers
with a optionizzle version number separated by tha \*(L"/\*(R" character.
Examplez are:
.Sp
.Vb 4
\&  $ua\->agent(\*(AqCheckbot/0.4 \*(Aq . $ua\->_agent);
\&  $ua\->agent(\*(AqCheckbot/0.4 \*(Aq);    # same as above
\&  $ua\->agent(\*(AqMozilla/5.0\*(Aq);
\&  $ua\->agent("");                 # don\*(Aqt identify
.Ve
.ie n .IP "$ua\->_agent" 4
.el .IP "\f(CW$ua\fR\->_agent" 4
.IX Item "$ua->_agent"
Returns tha default agent identifier n' shit.  This be a strang of tha form
\&\*(L"libwww\-perl/#.###\*(R", where \*(L"#.###\*(R" is substituted wit tha version number
of dis library.
.ie n .IP "$ua\->from" 4
.el .IP "\f(CW$ua\fR\->from" 4
.IX Item "$ua->from"
.PD 0
.ie n .IP "$ua\->from( $email_address )" 4
.el .IP "\f(CW$ua\fR\->from( \f(CW$email_address\fR )" 4
.IX Item "$ua->from( $email_address )"
.PD
Get/set tha e\-mail address fo' tha human user whoz ass controls
the requestin user agent.  Da address should be machine-usable, as
defined up in \s-1RFC 822. \s0 Da \f(CW\*(C`from\*(C'\fR value is bust as tha \*(L"From\*(R" header in
the requests, n' you can put dat on yo' toast.  Example:
.Sp
.Vb 1
\&  $ua\->from(\*(Aqgaas@cpan.org\*(Aq);
.Ve
.Sp
Da default is ta not bust a \*(L"From\*(R" header n' shit.  See tha \fIdefault_headers()\fR
method fo' tha mo' general intercourse dat allow any header ta be defaulted.
.ie n .IP "$ua\->cookie_jar" 4
.el .IP "\f(CW$ua\fR\->cookie_jar" 4
.IX Item "$ua->cookie_jar"
.PD 0
.ie n .IP "$ua\->cookie_jar( $cookie_jar_obj )" 4
.el .IP "\f(CW$ua\fR\->cookie_jar( \f(CW$cookie_jar_obj\fR )" 4
.IX Item "$ua->cookie_jar( $cookie_jar_obj )"
.PD
Get/set tha cookie jar object ta use.  Da only requirement is that
the cookie jar object must implement tha extract_cookies($request) and
add_cookie_header($response) methods.  These methodz will then be
invoked by tha user agent as requests is busted n' responses are
received. Y'all KNOW dat shit, muthafucka!  Normally dis is ghon be a \f(CW\*(C`HTTP::Cookies\*(C'\fR object or some
subclass.
.Sp
Da default is ta have no cookie_jar, i.e. never automatically add
\&\*(L"Cookie\*(R" headaz ta tha requests.
.Sp
Shortcut: If a reference ta a plain hash is passed up in as the
\&\f(CW$cookie_jar_object\fR, then it is replaced wit a instizzle of
\&\f(CW\*(C`HTTP::Cookies\*(C'\fR dat is initialized based on tha hash.  This form also
automatically loadz tha \f(CW\*(C`HTTP::Cookies\*(C'\fR module.  It means that:
.Sp
.Vb 1
\&  $ua\->cookie_jar({ file => "$ENV{HOME}/.cookies.txt" });
.Ve
.Sp
is straight-up just a gangbangin' finger-lickin' dirty-ass shortcut for:
.Sp
.Vb 2
\&  require HTTP::Cookies;
\&  $ua\->cookie_jar(HTTP::Cookies\->new(file => "$ENV{HOME}/.cookies.txt"));
.Ve
.ie n .IP "$ua\->default_headers" 4
.el .IP "\f(CW$ua\fR\->default_headers" 4
.IX Item "$ua->default_headers"
.PD 0
.ie n .IP "$ua\->default_headers( $headers_obj )" 4
.el .IP "\f(CW$ua\fR\->default_headers( \f(CW$headers_obj\fR )" 4
.IX Item "$ua->default_headers( $headers_obj )"
.PD
Get/set tha headaz object dat will provide default header joints for
any requests sent.  By default dis is ghon be a empty \f(CW\*(C`HTTP::Headers\*(C'\fR
object.
.ie n .IP "$ua\->default_header( $field )" 4
.el .IP "\f(CW$ua\fR\->default_header( \f(CW$field\fR )" 4
.IX Item "$ua->default_header( $field )"
.PD 0
.ie n .IP "$ua\->default_header( $field => $value )" 4
.el .IP "\f(CW$ua\fR\->default_header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$ua->default_header( $field => $value )"
.PD
This is just a gangbangin' finger-lickin' dirty-ass short-cut fo' \f(CW$ua\fR\->default_headers\->header( \f(CW$field\fR =>
\&\f(CW$value\fR ). Example:
.Sp
.Vb 2
\&  $ua\->default_header(\*(AqAccept\-Encoding\*(Aq => scalar HTTP::Message::decodable());
\&  $ua\->default_header(\*(AqAccept\-Language\*(Aq => "no, en");
.Ve
.ie n .IP "$ua\->conn_cache" 4
.el .IP "\f(CW$ua\fR\->conn_cache" 4
.IX Item "$ua->conn_cache"
.PD 0
.ie n .IP "$ua\->conn_cache( $cache_obj )" 4
.el .IP "\f(CW$ua\fR\->conn_cache( \f(CW$cache_obj\fR )" 4
.IX Item "$ua->conn_cache( $cache_obj )"
.PD
Get/set tha \f(CW\*(C`LWP::ConnCache\*(C'\fR object ta use.  See LWP::ConnCache
for details.
.ie n .IP "$ua\->credentials( $netloc, $realm )" 4
.el .IP "\f(CW$ua\fR\->credentials( \f(CW$netloc\fR, \f(CW$realm\fR )" 4
.IX Item "$ua->credentials( $netloc, $realm )"
.PD 0
.ie n .IP "$ua\->credentials( $netloc, $realm, $uname, $pass )" 4
.el .IP "\f(CW$ua\fR\->credentials( \f(CW$netloc\fR, \f(CW$realm\fR, \f(CW$uname\fR, \f(CW$pass\fR )" 4
.IX Item "$ua->credentials( $netloc, $realm, $uname, $pass )"
.PD
Get/set tha user name n' password ta be used fo' a realm.
.Sp
Da \f(CW$netloc\fR be a strang of tha form \*(L"<host>:<port>\*(R".  Da username and
password will only be passed ta dis server n' shit.  Example:
.Sp
.Vb 1
\&  $ua\->credentials("www.example.com:80", "Some Realm", "foo", "secret");
.Ve
.ie n .IP "$ua\->local_address" 4
.el .IP "\f(CW$ua\fR\->local_address" 4
.IX Item "$ua->local_address"
.PD 0
.ie n .IP "$ua\->local_address( $address )" 4
.el .IP "\f(CW$ua\fR\->local_address( \f(CW$address\fR )" 4
.IX Item "$ua->local_address( $address )"
.PD
Get/set tha local intercourse ta bind ta fo' network connections.  Da intercourse
can be specified as a hostname or a \s-1IP\s0 address.  This value is passed as the
\&\f(CW\*(C`LocalAddr\*(C'\fR argument ta IO::Socket::INET.
.ie n .IP "$ua\->max_size" 4
.el .IP "\f(CW$ua\fR\->max_size" 4
.IX Item "$ua->max_size"
.PD 0
.ie n .IP "$ua\->max_size( $bytes )" 4
.el .IP "\f(CW$ua\fR\->max_size( \f(CW$bytes\fR )" 4
.IX Item "$ua->max_size( $bytes )"
.PD
Get/set tha size limit fo' response content.  Da default is \f(CW\*(C`undef\*(C'\fR,
which means dat there is no limit.  If tha returned response content
is only partial, cuz tha size limit was exceeded, then a
\&\*(L"Client-Aborted\*(R" header is ghon be added ta tha response.  Da content
might end up longer than \f(CW\*(C`max_size\*(C'\fR as we abort once appendin a
chunk of data make tha length exceed tha limit.  Da \*(L"Content-Length\*(R"
header, if present, will indicate tha length of tha full content and
will normally not be tha same as \f(CW\*(C`length($res\->content)\*(C'\fR.
.ie n .IP "$ua\->max_redirect" 4
.el .IP "\f(CW$ua\fR\->max_redirect" 4
.IX Item "$ua->max_redirect"
.PD 0
.ie n .IP "$ua\->max_redirect( $n )" 4
.el .IP "\f(CW$ua\fR\->max_redirect( \f(CW$n\fR )" 4
.IX Item "$ua->max_redirect( $n )"
.PD
This readz or sets tha objectz limit of how tha fuck nuff times it will obey
redirection responses up in a given request cycle.
.Sp
By default, tha value is 7. This means dat if you call \fIrequest()\fR
method n' tha response be a redirect elsewhere which is up in turn a
redirect, n' so on seven times, then \s-1LWP\s0 gives up afta dat seventh
request.
.ie n .IP "$ua\->parse_head" 4
.el .IP "\f(CW$ua\fR\->parse_head" 4
.IX Item "$ua->parse_head"
.PD 0
.ie n .IP "$ua\->parse_head( $boolean )" 4
.el .IP "\f(CW$ua\fR\->parse_head( \f(CW$boolean\fR )" 4
.IX Item "$ua->parse_head( $boolean )"
.PD
Get/set a value indicatin whether we should initialize response
headaz from tha <head> section of \s-1HTML\s0 documents, n' you can put dat on yo' toast. Da default is
\&\s-1TRUE. \s0 Do not turn dis off, unless you know what tha fuck yo ass is bustin.
.ie n .IP "$ua\->protocols_allowed" 4
.el .IP "\f(CW$ua\fR\->protocols_allowed" 4
.IX Item "$ua->protocols_allowed"
.PD 0
.ie n .IP "$ua\->protocols_allowed( \e@protocols )" 4
.el .IP "\f(CW$ua\fR\->protocols_allowed( \e@protocols )" 4
.IX Item "$ua->protocols_allowed( @protocols )"
.PD
This readz (or sets) dis user agentz list of protocols dat the
request methodz will exclusively allow.  Da protocol names is case
insensitive.
.Sp
For example: \f(CW\*(C`$ua\->protocols_allowed( [ \*(Aqhttp\*(Aq, \*(Aqhttps\*(Aq] );\*(C'\fR
means dat dis user agent will \fIallow only\fR dem protocols,
and attempts ta use dis user agent ta access URLs wit any other
schemes (like \*(L"ftp://...\*(R") will result up in a 500 error.
.Sp
To delete tha list, call: \f(CW\*(C`$ua\->protocols_allowed(undef)\*(C'\fR
.Sp
By default, a object has neither a \f(CW\*(C`protocols_allowed\*(C'\fR list, nor a
\&\f(CW\*(C`protocols_forbidden\*(C'\fR list.
.Sp
Note dat havin a \f(CW\*(C`protocols_allowed\*(C'\fR list causes any
\&\f(CW\*(C`protocols_forbidden\*(C'\fR list ta be ignored.
.ie n .IP "$ua\->protocols_forbidden" 4
.el .IP "\f(CW$ua\fR\->protocols_forbidden" 4
.IX Item "$ua->protocols_forbidden"
.PD 0
.ie n .IP "$ua\->protocols_forbidden( \e@protocols )" 4
.el .IP "\f(CW$ua\fR\->protocols_forbidden( \e@protocols )" 4
.IX Item "$ua->protocols_forbidden( @protocols )"
.PD
This readz (or sets) dis user agentz list of protocols dat the
request method will \fInot\fR allow. Da protocol names is case
insensitive.
.Sp
For example: \f(CW\*(C`$ua\->protocols_forbidden( [ \*(Aqfile\*(Aq, \*(Aqmailto\*(Aq] );\*(C'\fR
means dat dis user agent will \fInot\fR allow dem protocols, and
attempts ta use dis user agent ta access URLs wit dem schemes
will result up in a 500 error.
.Sp
To delete tha list, call: \f(CW\*(C`$ua\->protocols_forbidden(undef)\*(C'\fR
.ie n .IP "$ua\->requests_redirectable" 4
.el .IP "\f(CW$ua\fR\->requests_redirectable" 4
.IX Item "$ua->requests_redirectable"
.PD 0
.ie n .IP "$ua\->requests_redirectable( \e@requests )" 4
.el .IP "\f(CW$ua\fR\->requests_redirectable( \e@requests )" 4
.IX Item "$ua->requests_redirectable( @requests )"
.PD
This readz or sets tha objectz list of request names that
\&\f(CW\*(C`$ua\->redirect_ok(...)\*(C'\fR will allow redirection for. Shiiit, dis aint no joke.  By
default, dis is \f(CW\*(C`[\*(AqGET\*(Aq, \*(AqHEAD\*(Aq]\*(C'\fR, as per \s-1RFC 2616. \s0 To
change ta include '\s-1POST\s0', consider:
.Sp
.Vb 1
\&   push @{ $ua\->requests_redirectable }, \*(AqPOST\*(Aq;
.Ve
.ie n .IP "$ua\->show_progress" 4
.el .IP "\f(CW$ua\fR\->show_progress" 4
.IX Item "$ua->show_progress"
.PD 0
.ie n .IP "$ua\->show_progress( $boolean )" 4
.el .IP "\f(CW$ua\fR\->show_progress( \f(CW$boolean\fR )" 4
.IX Item "$ua->show_progress( $boolean )"
.PD
Get/set a value indicatin whether a progress bar should be displayed
on on tha terminal as requests is processed. Y'all KNOW dat shit, muthafucka! Da default is \s-1FALSE.\s0
.ie n .IP "$ua\->timeout" 4
.el .IP "\f(CW$ua\fR\->timeout" 4
.IX Item "$ua->timeout"
.PD 0
.ie n .IP "$ua\->timeout( $secs )" 4
.el .IP "\f(CW$ua\fR\->timeout( \f(CW$secs\fR )" 4
.IX Item "$ua->timeout( $secs )"
.PD
Get/set tha timeout value up in seconds. Da default \fItimeout()\fR value is
180 seconds, i.e. 3 minutes.
.Sp
Da requests be aborted if no activitizzle on tha connection ta tha server
is observed fo' \f(CW\*(C`timeout\*(C'\fR seconds.  This means dat tha time it takes
for tha complete transaction n' tha \fIrequest()\fR method ta actually
return might be longer.
.ie n .IP "$ua\->ssl_opts" 4
.el .IP "\f(CW$ua\fR\->ssl_opts" 4
.IX Item "$ua->ssl_opts"
.PD 0
.ie n .IP "$ua\->ssl_opts( $key )" 4
.el .IP "\f(CW$ua\fR\->ssl_opts( \f(CW$key\fR )" 4
.IX Item "$ua->ssl_opts( $key )"
.ie n .IP "$ua\->ssl_opts( $key => $value )" 4
.el .IP "\f(CW$ua\fR\->ssl_opts( \f(CW$key\fR => \f(CW$value\fR )" 4
.IX Item "$ua->ssl_opts( $key => $value )"
.PD
Get/set tha options fo' \s-1SSL\s0 connections.  Without argument return tha list
of options keys currently set.  With a single argument return tha current
value fo' tha given option. I aint talkin' bout chicken n' gravy biatch.  With 2 arguments set tha option value n' return
the old. Y'all KNOW dat shit, muthafucka!  Settin a option ta tha value \f(CW\*(C`undef\*(C'\fR removes dis option.
.Sp
Da options dat \s-1LWP\s0 relates ta are:
.RS 4
.ie n .IP """verify_hostname"" => $bool" 4
.el .IP "\f(CWverify_hostname\fR => \f(CW$bool\fR" 4
.IX Item "verify_hostname => $bool"
When \s-1TRUE LWP\s0 will fo' secure protocol schemes ensure it connects ta servers
that gotz a valid certificate matchin tha expected hostname.  If \s-1FALSE\s0 no
checks is made n' you can't be shizzle dat you rap wit tha expected peer.
Da no checks behaviour was tha default fo' libwww\-perl\-5.837 n' earlier releases.
.Sp
This option is initialized from tha \s-1PERL_LWP_SSL_VERIFY_HOSTNAME\s0 environment
variable.  If dis environment variable aint set; then \f(CW\*(C`verify_hostname\*(C'\fR
defaults ta 1.
.ie n .IP """SSL_ca_file"" => $path" 4
.el .IP "\f(CWSSL_ca_file\fR => \f(CW$path\fR" 4
.IX Item "SSL_ca_file => $path"
Da path ta a gangbangin' file containin Certificate Authoritizzle certificates.
A default settin fo' dis option is provided by checkin tha environment
variablez \f(CW\*(C`PERL_LWP_SSL_CA_FILE\*(C'\fR n' \f(CW\*(C`HTTPS_CA_FILE\*(C'\fR up in order.
.ie n .IP """SSL_ca_path"" => $path" 4
.el .IP "\f(CWSSL_ca_path\fR => \f(CW$path\fR" 4
.IX Item "SSL_ca_path => $path"
Da path ta a gangbangin' finger-lickin' directory containin filez containin Certificate Authority
certificates.
A default settin fo' dis option is provided by checkin tha environment
variablez \f(CW\*(C`PERL_LWP_SSL_CA_PATH\*(C'\fR n' \f(CW\*(C`HTTPS_CA_DIR\*(C'\fR up in order.
.RE
.RS 4
.Sp
Other options can be set n' is processed directly by tha \s-1SSL\s0 Socket implementation
in use.  See IO::Socket::SSL or Net::SSL fo' details.
.Sp
Da libwww-perl core no longer bundlez protocol plugins fo' \s-1SSL. \s0 Yo ass will need
to install LWP::Protocol::https separately ta enable support fo' processing
https-URLs.
.RE
.SS "Proxy attributes"
.IX Subsection "Proxy attributes"
Da followin methodz set up when requests should be passed via a
proxy server.
.ie n .IP "$ua\->proxy(\e@schemes, $proxy_url)" 4
.el .IP "\f(CW$ua\fR\->proxy(\e@schemes, \f(CW$proxy_url\fR)" 4
.IX Item "$ua->proxy(@schemes, $proxy_url)"
.PD 0
.ie n .IP "$ua\->proxy($scheme, $proxy_url)" 4
.el .IP "\f(CW$ua\fR\->proxy($scheme, \f(CW$proxy_url\fR)" 4
.IX Item "$ua->proxy($scheme, $proxy_url)"
.PD
Set/retrieve proxy \s-1URL\s0 fo' a scheme:
.Sp
.Vb 2
\& $ua\->proxy([\*(Aqhttp\*(Aq, \*(Aqftp\*(Aq], \*(Aqhttp://proxy.sn.no:8001/\*(Aq);
\& $ua\->proxy(\*(Aqgopher\*(Aq, \*(Aqhttp://proxy.sn.no:8001/\*(Aq);
.Ve
.Sp
Da first form specifies dat tha \s-1URL\s0 is ta be used fo' proxyin of
access methodz listed up in tha list up in tha straight-up original gangsta method argument,
i.e. 'http' n' 'ftp'.
.Sp
Da second form shows a gangbangin' finger-lickin' dirty-ass shorthand form fo' specifying
proxy \s-1URL\s0 fo' a single access scheme.
.ie n .IP "$ua\->no_proxy( $domain, ... )" 4
.el .IP "\f(CW$ua\fR\->no_proxy( \f(CW$domain\fR, ... )" 4
.IX Item "$ua->no_proxy( $domain, ... )"
Do not proxy requests ta tha given domains.  Callin no_proxy without
any domains clears tha list of domains. Eg:
.Sp
.Vb 1
\& $ua\->no_proxy(\*(Aqlocalhost\*(Aq, \*(Aqexample.com\*(Aq);
.Ve
.ie n .IP "$ua\->env_proxy" 4
.el .IP "\f(CW$ua\fR\->env_proxy" 4
.IX Item "$ua->env_proxy"
Load proxy settings from *_proxy environment variables.  Yo ass might
specify proxies like dis (sh-syntax):
.Sp
.Vb 4
\&  gopher_proxy=http://proxy.my.place/
\&  wais_proxy=http://proxy.my.place/
\&  no_proxy="localhost,example.com"
\&  export gopher_proxy wais_proxy no_proxy
.Ve
.Sp
csh or tcsh playas should use tha \f(CW\*(C`setenv\*(C'\fR command ta define these
environment variables.
.Sp
On systems wit case insensitizzle environment variablez there exists a
name clash between tha \s-1CGI\s0 environment variablez n' tha \f(CW\*(C`HTTP_PROXY\*(C'\fR
environment variable normally picked up by \fIenv_proxy()\fR.  Because of
this \f(CW\*(C`HTTP_PROXY\*(C'\fR aint honored fo' \s-1CGI\s0 scripts, n' you can put dat on yo' toast.  The
\&\f(CW\*(C`CGI_HTTP_PROXY\*(C'\fR environment variable can be used instead.
.SS "Handlezs"
.IX Subsection "Handlezs"
Handlezs is code dat injected at various phases durin the
processin of requests, n' you can put dat on yo' toast.  Da followin methodz is provided ta manage
the actizzle handlezs:
.ie n .IP "$ua\->add_handlez( $phase => \e&cb, %matchspec )" 4
.el .IP "\f(CW$ua\fR\->add_handlez( \f(CW$phase\fR => \e&cb, \f(CW%matchspec\fR )" 4
.IX Item "$ua->add_handlez( $phase => &cb, %matchspec )"
Add handlez ta be invoked up in tha given processin phase.  For how tha fuck to
specify \f(CW%matchspec\fR peep \*(L"Matching\*(R" up in HTTP::Config.
.Sp
Da possible joints \f(CW$phase\fR n' tha correspondin callback signatures are:
.RS 4
.ie n .IP "request_preprepare => sub { my($request, $ua, $h) = @_; ... }" 4
.el .IP "request_preprepare => sub { my($request, \f(CW$ua\fR, \f(CW$h\fR) = \f(CW@_\fR; ... }" 4
.IX Item "request_preprepare => sub { my($request, $ua, $h) = @_; ... }"
Da handlez is called before tha \f(CW\*(C`request_prepare\*(C'\fR n' other standard
initialization of tha request.  This can be used ta set up headers
and attributes dat tha \f(CW\*(C`request_prepare\*(C'\fR handlez dependz on. I aint talkin' bout chicken n' gravy biatch.  Proxy
initialization should take place here; but up in general don't register
handlezs fo' dis phase.
.ie n .IP "request_prepare => sub { my($request, $ua, $h) = @_; ... }" 4
.el .IP "request_prepare => sub { my($request, \f(CW$ua\fR, \f(CW$h\fR) = \f(CW@_\fR; ... }" 4
.IX Item "request_prepare => sub { my($request, $ua, $h) = @_; ... }"
Da handlez is called before tha request is busted n' can modify the
request any way it peep fit.  This can fo' instizzle be used ta add
certain headaz ta specific requests.
.Sp
Da method can assign a freshly smoked up request object ta \f(CW$_\fR[0] ta replace the
request dat is busted fully.
.Sp
Da return value from tha callback is ignored. Y'all KNOW dat shit, muthafucka!  If a exception is
raised it will abort tha request n' make tha request method return a
\&\*(L"400 Wack request\*(R" response.
.ie n .IP "request_send => sub { my($request, $ua, $h) = @_; ... }" 4
.el .IP "request_send => sub { my($request, \f(CW$ua\fR, \f(CW$h\fR) = \f(CW@_\fR; ... }" 4
.IX Item "request_send => sub { my($request, $ua, $h) = @_; ... }"
This handlez gets a cold-ass lil chizzle of handlin requests before they busted ta the
protocol handlezs.  It should return a HTTP::Response object if it
wishes ta terminizzle tha processing; otherwise it should return nothing.
.Sp
Da \f(CW\*(C`response_header\*(C'\fR n' \f(CW\*(C`response_data\*(C'\fR handlezs aint gonna be
invoked fo' dis response yo, but tha \f(CW\*(C`response_done\*(C'\fR will be.
.ie n .IP "response_header => sub { my($response, $ua, $h) = @_; ... }" 4
.el .IP "response_header => sub { my($response, \f(CW$ua\fR, \f(CW$h\fR) = \f(CW@_\fR; ... }" 4
.IX Item "response_header => sub { my($response, $ua, $h) = @_; ... }"
This handlez is called right afta tha response headaz have been
received yo, but before any content data.  Da handlez might set up
handlezs fo' data n' might croak ta abort tha request.
.Sp
Da handlez might set tha \f(CW$response\fR\->{default_add_content} value to
control if any received data should be added ta tha response object
directly.  This will initially be false if tha \f(CW$ua\fR\->\fIrequest()\fR method
was called wit a \f(CW$content_file\fR or \f(CW$content_cb\fR argument; otherwise true.
.ie n .IP "response_data => sub { my($response, $ua, $h, $data) = @_; ... }" 4
.el .IP "response_data => sub { my($response, \f(CW$ua\fR, \f(CW$h\fR, \f(CW$data\fR) = \f(CW@_\fR; ... }" 4
.IX Item "response_data => sub { my($response, $ua, $h, $data) = @_; ... }"
This handlez is called fo' each chunk of data received fo' the
response.  Da handlez might croak ta abort tha request.
.Sp
This handlez need ta return a \s-1TRUE\s0 value ta be called again n' again n' again for
subsequent chunks fo' tha same request.
.ie n .IP "response_done => sub { my($response, $ua, $h) = @_; ... }" 4
.el .IP "response_done => sub { my($response, \f(CW$ua\fR, \f(CW$h\fR) = \f(CW@_\fR; ... }" 4
.IX Item "response_done => sub { my($response, $ua, $h) = @_; ... }"
Da handlez is called afta tha response has been straight-up received yo, but
before any redirect handlin be attempted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da handlez can be used to
extract shiznit or modify tha response.
.ie n .IP "response_redirect => sub { my($response, $ua, $h) = @_; ... }" 4
.el .IP "response_redirect => sub { my($response, \f(CW$ua\fR, \f(CW$h\fR) = \f(CW@_\fR; ... }" 4
.IX Item "response_redirect => sub { my($response, $ua, $h) = @_; ... }"
Da handlez is called up in \f(CW$ua\fR\->request afta \f(CW\*(C`response_done\*(C'\fR.  If the
handlez returns a HTTP::Request object we'll start over wit processing
this request instead.
.RE
.RS 4
.RE
.ie n .IP "$ua\->remove_handlez( undef, %matchspec )" 4
.el .IP "\f(CW$ua\fR\->remove_handlez( undef, \f(CW%matchspec\fR )" 4
.IX Item "$ua->remove_handlez( undef, %matchspec )"
.PD 0
.ie n .IP "$ua\->remove_handlez( $phase, %matchspec )" 4
.el .IP "\f(CW$ua\fR\->remove_handlez( \f(CW$phase\fR, \f(CW%matchspec\fR )" 4
.IX Item "$ua->remove_handlez( $phase, %matchspec )"
.PD
Remove handlezs dat match tha given \f(CW%matchspec\fR.  If \f(CW$phase\fR is not
provided remove handlezs from all phases.
.Sp
Be careful as callin dis function wit \f(CW%matchspec\fR dat aint not
specific enough can remove handlezs not owned by yo thugged-out ass.  It aint nuthin but probably
betta ta use tha \fIset_my_handlez()\fR method instead.
.Sp
Da removed handlezs is returned.
.ie n .IP "$ua\->set_my_handlez( $phase, $cb, %matchspec )" 4
.el .IP "\f(CW$ua\fR\->set_my_handlez( \f(CW$phase\fR, \f(CW$cb\fR, \f(CW%matchspec\fR )" 4
.IX Item "$ua->set_my_handlez( $phase, $cb, %matchspec )"
Set handlezs private ta tha executin subroutine.  Works by defaulting
an \f(CW\*(C`baller\*(C'\fR field ta tha \f(CW%matchspec\fR dat holdz tha name of tha called
subroutine.  Yo ass might pass a explicit \f(CW\*(C`baller\*(C'\fR ta override all dis bullshit.
.Sp
If \f(CW$cb\fR is passed as \f(CW\*(C`undef\*(C'\fR, remove tha handlez.
.ie n .IP "$ua\->get_my_handlez( $phase, %matchspec )" 4
.el .IP "\f(CW$ua\fR\->get_my_handlez( \f(CW$phase\fR, \f(CW%matchspec\fR )" 4
.IX Item "$ua->get_my_handlez( $phase, %matchspec )"
.PD 0
.ie n .IP "$ua\->get_my_handlez( $phase, %matchspec, $init )" 4
.el .IP "\f(CW$ua\fR\->get_my_handlez( \f(CW$phase\fR, \f(CW%matchspec\fR, \f(CW$init\fR )" 4
.IX Item "$ua->get_my_handlez( $phase, %matchspec, $init )"
.PD
Will retrieve tha matchin handlez as hash ref.
.Sp
If \f(CW$init\fR is passed passed as a \s-1TRUE\s0 value, create n' add the
handlez if it aint found. Y'all KNOW dat shit, muthafucka!  If \f(CW$init\fR be a subroutine reference, then
itz called wit tha pimped handlez hash as argument.  This sub might
populate tha hash wit extra fields; especially tha callback.  If
\&\f(CW$init\fR be a hash reference, merge tha hashes.
.ie n .IP "$ua\->handlezs( $phase, $request )" 4
.el .IP "\f(CW$ua\fR\->handlezs( \f(CW$phase\fR, \f(CW$request\fR )" 4
.IX Item "$ua->handlezs( $phase, $request )"
.PD 0
.ie n .IP "$ua\->handlezs( $phase, $response )" 4
.el .IP "\f(CW$ua\fR\->handlezs( \f(CW$phase\fR, \f(CW$response\fR )" 4
.IX Item "$ua->handlezs( $phase, $response )"
.PD
Returns tha handlezs dat apply ta tha given request or response at
the given processin phase.
.SH "REQUEST METHODS"
.IX Header "REQUEST METHODS"
Da methodz busted lyrics bout up in dis section is used ta dispatch requests
via tha user agent.  Da followin request methodz is provided:
.ie n .IP "$ua\->get( $url )" 4
.el .IP "\f(CW$ua\fR\->get( \f(CW$url\fR )" 4
.IX Item "$ua->get( $url )"
.PD 0
.ie n .IP "$ua\->get( $url , $field_name => $value, ... )" 4
.el .IP "\f(CW$ua\fR\->get( \f(CW$url\fR , \f(CW$field_name\fR => \f(CW$value\fR, ... )" 4
.IX Item "$ua->get( $url , $field_name => $value, ... )"
.PD
This method will dispatch a \f(CW\*(C`GET\*(C'\fR request on tha given \f(CW$url\fR.  Further
arguments can be given ta initialize tha headaz of tha request. These
are given as separate name/value pairs.  Da return value be a
response object.  See HTTP::Response fo' a thugged-out description of the
interface it provides.
.Sp
There will still be a response object returned when \s-1LWP\s0 can't connect ta the
server specified up in tha \s-1URL\s0 or when other failures up in protocol handlezs occur.
These internal responses use tha standard \s-1HTTP\s0 status codes, so tha responses
can't be differentiated by testin tha response status code ridin' solo.  Error
responses dat \s-1LWP\s0 generates internally gonna git tha \*(L"Client-Warning\*(R" header
set ta tha value \*(L"Internal response\*(R".  If you need ta differentiate these
internal responses from responses dat a remote server straight-up generates, you
need ta test dis header value.
.Sp
Fieldz names dat start wit \*(L":\*(R" is special. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  These will not
initialize headaz of tha request but will determine how tha fuck tha response
content is treated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da followin special field names is recognized:
.Sp
.Vb 3
\&    :content_file   => $filename
\&    :content_cb     => \e&callback
\&    :read_size_hint => $bytes
.Ve
.Sp
If a \f(CW$filename\fR is provided wit tha \f(CW\*(C`:content_file\*(C'\fR option, then the
response content is ghon be saved here instead of up in tha response
object.  If a cold-ass lil callback is provided wit tha \f(CW\*(C`:content_cb\*(C'\fR option then
this function is ghon be called fo' each chunk of tha response content as
it is received from tha server n' shit.  If neither of these options are
given, then tha response content will accumulate up in tha response
object itself.  This might not be suitable fo' straight-up big-ass response
bodies. Put ya muthafuckin choppers up if ya feel dis!  Only one of \f(CW\*(C`:content_file\*(C'\fR or \f(CW\*(C`:content_cb\*(C'\fR can be
specified. Y'all KNOW dat shit, muthafucka!  Da content of unsuccessful responses will always
accumulate up in tha response object itself, regardless of the
\&\f(CW\*(C`:content_file\*(C'\fR or \f(CW\*(C`:content_cb\*(C'\fR options passed in.
.Sp
Da \f(CW\*(C`:read_size_hint\*(C'\fR option is passed ta tha protocol module which
will try ta read data from tha server up in chunkz of dis size.  A
smalla value fo' tha \f(CW\*(C`:read_size_hint\*(C'\fR will result up in a higher
number of callback invocations.
.Sp
Da callback function is called wit 3 arguments: a cold-ass lil chunk of data, a
reference ta tha response object, n' a reference ta tha protocol
object.  Da callback can abort tha request by invokin \fIdie()\fR.  The
exception message will show up as tha \*(L"X\-Died\*(R" header field up in the
response returned by tha \fIget()\fR function.
.ie n .IP "$ua\->head( $url )" 4
.el .IP "\f(CW$ua\fR\->head( \f(CW$url\fR )" 4
.IX Item "$ua->head( $url )"
.PD 0
.ie n .IP "$ua\->head( $url , $field_name => $value, ... )" 4
.el .IP "\f(CW$ua\fR\->head( \f(CW$url\fR , \f(CW$field_name\fR => \f(CW$value\fR, ... )" 4
.IX Item "$ua->head( $url , $field_name => $value, ... )"
.PD
This method will dispatch a \f(CW\*(C`HEAD\*(C'\fR request on tha given \f(CW$url\fR.
Otherwise it works like tha \fIget()\fR method busted lyrics bout above.
.ie n .IP "$ua\->post( $url, \e%form )" 4
.el .IP "\f(CW$ua\fR\->post( \f(CW$url\fR, \e%form )" 4
.IX Item "$ua->post( $url, %form )"
.PD 0
.ie n .IP "$ua\->post( $url, \e@form )" 4
.el .IP "\f(CW$ua\fR\->post( \f(CW$url\fR, \e@form )" 4
.IX Item "$ua->post( $url, @form )"
.ie n .IP "$ua\->post( $url, \e%form, $field_name => $value, ... )" 4
.el .IP "\f(CW$ua\fR\->post( \f(CW$url\fR, \e%form, \f(CW$field_name\fR => \f(CW$value\fR, ... )" 4
.IX Item "$ua->post( $url, %form, $field_name => $value, ... )"
.ie n .IP "$ua\->post( $url, $field_name => $value,... Content => \e%form )" 4
.el .IP "\f(CW$ua\fR\->post( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR,... Content => \e%form )" 4
.IX Item "$ua->post( $url, $field_name => $value,... Content => %form )"
.ie n .IP "$ua\->post( $url, $field_name => $value,... Content => \e@form )" 4
.el .IP "\f(CW$ua\fR\->post( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR,... Content => \e@form )" 4
.IX Item "$ua->post( $url, $field_name => $value,... Content => @form )"
.ie n .IP "$ua\->post( $url, $field_name => $value,... Content => $content )" 4
.el .IP "\f(CW$ua\fR\->post( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR,... Content => \f(CW$content\fR )" 4
.IX Item "$ua->post( $url, $field_name => $value,... Content => $content )"
.PD
This method will dispatch a \f(CW\*(C`POST\*(C'\fR request on tha given \f(CW$url\fR, with
\&\f(CW%form\fR or \f(CW@form\fR providin tha key/value pairs fo' tha fill-in form
content fo' realz. Additionizzle headaz n' content options is tha same as for
the \fIget()\fR method.
.Sp
This method will use tha \s-1\fIPOST\s0()\fR function from \f(CW\*(C`HTTP::Request::Common\*(C'\fR
to build tha request.  See HTTP::Request::Common fo' a thugged-out details on
how ta pass form content n' other advanced features.
.ie n .IP "$ua\->put( $url, \e%form )" 4
.el .IP "\f(CW$ua\fR\->put( \f(CW$url\fR, \e%form )" 4
.IX Item "$ua->put( $url, %form )"
.PD 0
.ie n .IP "$ua\->put( $url, \e@form )" 4
.el .IP "\f(CW$ua\fR\->put( \f(CW$url\fR, \e@form )" 4
.IX Item "$ua->put( $url, @form )"
.ie n .IP "$ua\->put( $url, \e%form, $field_name => $value, ... )" 4
.el .IP "\f(CW$ua\fR\->put( \f(CW$url\fR, \e%form, \f(CW$field_name\fR => \f(CW$value\fR, ... )" 4
.IX Item "$ua->put( $url, %form, $field_name => $value, ... )"
.ie n .IP "$ua\->put( $url, $field_name => $value,... Content => \e%form )" 4
.el .IP "\f(CW$ua\fR\->put( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR,... Content => \e%form )" 4
.IX Item "$ua->put( $url, $field_name => $value,... Content => %form )"
.ie n .IP "$ua\->put( $url, $field_name => $value,... Content => \e@form )" 4
.el .IP "\f(CW$ua\fR\->put( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR,... Content => \e@form )" 4
.IX Item "$ua->put( $url, $field_name => $value,... Content => @form )"
.ie n .IP "$ua\->put( $url, $field_name => $value,... Content => $content )" 4
.el .IP "\f(CW$ua\fR\->put( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR,... Content => \f(CW$content\fR )" 4
.IX Item "$ua->put( $url, $field_name => $value,... Content => $content )"
.PD
This method will dispatch a \f(CW\*(C`PUT\*(C'\fR request on tha given \f(CW$url\fR, with
\&\f(CW%form\fR or \f(CW@form\fR providin tha key/value pairs fo' tha fill-in form
content fo' realz. Additionizzle headaz n' content options is tha same as for
the \fIget()\fR method.
.Sp
This method will use tha \s-1\fIPUT\s0()\fR function from \f(CW\*(C`HTTP::Request::Common\*(C'\fR
to build tha request.  See HTTP::Request::Common fo' a thugged-out details on
how ta pass form content n' other advanced features.
.ie n .IP "$ua\->delete( $url )" 4
.el .IP "\f(CW$ua\fR\->delete( \f(CW$url\fR )" 4
.IX Item "$ua->delete( $url )"
.PD 0
.ie n .IP "$ua\->delete( $url, $field_name => $value, ... )" 4
.el .IP "\f(CW$ua\fR\->delete( \f(CW$url\fR, \f(CW$field_name\fR => \f(CW$value\fR, ... )" 4
.IX Item "$ua->delete( $url, $field_name => $value, ... )"
.PD
This method will dispatch a \f(CW\*(C`DELETE\*(C'\fR request on tha given \f(CW$url\fR.  Additional
headaz n' content options is tha same as fo' tha \fIget()\fR method.
.Sp
This method will use tha \s-1\fIDELETE\s0()\fR function from \f(CW\*(C`HTTP::Request::Common\*(C'\fR
to build tha request.  See HTTP::Request::Common fo' a thugged-out details on
how ta pass form content n' other advanced features.
.ie n .IP "$ua\->mirror( $url, $filename )" 4
.el .IP "\f(CW$ua\fR\->mirror( \f(CW$url\fR, \f(CW$filename\fR )" 4
.IX Item "$ua->mirror( $url, $filename )"
This method will git tha document identified by \f(CW$url\fR n' store it in
file called \f(CW$filename\fR.  If tha file already exists, then tha request
will contain a \*(L"If-Modified-Since\*(R" header matchin tha modification
time of tha file.  If tha document on tha server has not chizzled since
this time, then not a god damn thang happens.  If tha document has been updated, it
will be downloaded again. I aint talkin' bout chicken n' gravy biatch.  Da modification time of tha file will be
forced ta match dat of tha server.
.Sp
Da return value is tha the response object.
.ie n .IP "$ua\->request( $request )" 4
.el .IP "\f(CW$ua\fR\->request( \f(CW$request\fR )" 4
.IX Item "$ua->request( $request )"
.PD 0
.ie n .IP "$ua\->request( $request, $content_file )" 4
.el .IP "\f(CW$ua\fR\->request( \f(CW$request\fR, \f(CW$content_file\fR )" 4
.IX Item "$ua->request( $request, $content_file )"
.ie n .IP "$ua\->request( $request, $content_cb )" 4
.el .IP "\f(CW$ua\fR\->request( \f(CW$request\fR, \f(CW$content_cb\fR )" 4
.IX Item "$ua->request( $request, $content_cb )"
.ie n .IP "$ua\->request( $request, $content_cb, $read_size_hint )" 4
.el .IP "\f(CW$ua\fR\->request( \f(CW$request\fR, \f(CW$content_cb\fR, \f(CW$read_size_hint\fR )" 4
.IX Item "$ua->request( $request, $content_cb, $read_size_hint )"
.PD
This method will dispatch tha given \f(CW$request\fR object.  Normally this
will be a instizzle of tha \f(CW\*(C`HTTP::Request\*(C'\fR class yo, but any object with
a similar intercourse will do.  Da return value be a response object.
See HTTP::Request n' HTTP::Response fo' a thugged-out description of the
interface provided by these classes.
.Sp
Da \fIrequest()\fR method will process redirects n' authentication
responses transparently.  This means dat it may straight-up bust several
simple requests via tha \fIsimple_request()\fR method busted lyrics bout below.
.Sp
Da request methodz busted lyrics bout above; \fIget()\fR, \fIhead()\fR, \fIpost()\fR and
\&\fImirror()\fR, will all dispatch tha request they build via dis method.
They is convenience methodz dat simply hides tha creation of the
request object fo' yo thugged-out ass.
.Sp
Da \f(CW$content_file\fR, \f(CW$content_cb\fR n' \f(CW$read_size_hint\fR all correspond to
options busted lyrics bout wit tha \fIget()\fR method above.
.Sp
Yo ass be allowed ta bust a \s-1CODE\s0 reference as \f(CW\*(C`content\*(C'\fR up in tha request
object passed in. I aint talkin' bout chicken n' gravy biatch.  Da \f(CW\*(C`content\*(C'\fR function should return tha content
when called. Y'all KNOW dat shit, muthafucka!  Da content can be returned up in chunks.  Da content
function is ghon be invoked repeatedly until it return a empty strang to
signal dat there is no mo' content.
.ie n .IP "$ua\->simple_request( $request )" 4
.el .IP "\f(CW$ua\fR\->simple_request( \f(CW$request\fR )" 4
.IX Item "$ua->simple_request( $request )"
.PD 0
.ie n .IP "$ua\->simple_request( $request, $content_file )" 4
.el .IP "\f(CW$ua\fR\->simple_request( \f(CW$request\fR, \f(CW$content_file\fR )" 4
.IX Item "$ua->simple_request( $request, $content_file )"
.ie n .IP "$ua\->simple_request( $request, $content_cb )" 4
.el .IP "\f(CW$ua\fR\->simple_request( \f(CW$request\fR, \f(CW$content_cb\fR )" 4
.IX Item "$ua->simple_request( $request, $content_cb )"
.ie n .IP "$ua\->simple_request( $request, $content_cb, $read_size_hint )" 4
.el .IP "\f(CW$ua\fR\->simple_request( \f(CW$request\fR, \f(CW$content_cb\fR, \f(CW$read_size_hint\fR )" 4
.IX Item "$ua->simple_request( $request, $content_cb, $read_size_hint )"
.PD
This method dispatches a single request n' returns tha response
received. Y'all KNOW dat shit, muthafucka!  Arguments is tha same as fo' \fIrequest()\fR busted lyrics bout above.
.Sp
Da difference from \fIrequest()\fR is dat \fIsimple_request()\fR aint gonna try to
handle redirects or authentication responses.  Da \fIrequest()\fR method
will up in fact invoke dis method fo' each simple request it sends.
.ie n .IP "$ua\->is_online" 4
.el .IP "\f(CW$ua\fR\->is_online" 4
.IX Item "$ua->is_online"
Tries ta determine if you have access ta tha Internet.  Returns
\&\s-1TRUE\s0 if tha built-in heuristics determine dat tha user agent is
able ta access tha Internizzle (over \s-1HTTP\s0).  See also LWP::Online.
.ie n .IP "$ua\->is_protocol_supported( $scheme )" 4
.el .IP "\f(CW$ua\fR\->is_protocol_supported( \f(CW$scheme\fR )" 4
.IX Item "$ua->is_protocol_supported( $scheme )"
Yo ass can use dis method ta test whether dis user agent object supports the
specified \f(CW\*(C`scheme\*(C'\fR.  (Da \f(CW\*(C`scheme\*(C'\fR might be a strang (like 'http' or
\&'ftp') or it might be a \s-1URI\s0 object reference.)
.Sp
Whether a scheme is supported, is determined by tha user agent's
\&\f(CW\*(C`protocols_allowed\*(C'\fR or \f(CW\*(C`protocols_forbidden\*(C'\fR lists (if any), n' by
the capabilitizzlez of \s-1LWP.  I\s0.e., dis will return \s-1TRUE\s0 only if \s-1LWP\s0
supports dis protocol \fIand\fR itz permitted fo' dis particular
object.
.SS "Callback methods"
.IX Subsection "Callback methods"
Da followin methodz is ghon be invoked as requests is processed. Y'all KNOW dat shit, muthafucka! These
methodz is documented here cuz subclassez of \f(CW\*(C`LWP::UserAgent\*(C'\fR
might wanna override they behaviour.
.ie n .IP "$ua\->prepare_request( $request )" 4
.el .IP "\f(CW$ua\fR\->prepare_request( \f(CW$request\fR )" 4
.IX Item "$ua->prepare_request( $request )"
This method is invoked by \fIsimple_request()\fR.  Its task is ta modify the
given \f(CW$request\fR object by settin up various headaz based on the
attributez of tha user agent. Da return value should normally be the
\&\f(CW$request\fR object passed in. I aint talkin' bout chicken n' gravy biatch.  If a gangbangin' finger-lickin' different request object is returned
it is ghon be tha one straight-up processed.
.Sp
Da headaz affected by tha base implementation are; \*(L"User-Agent\*(R",
\&\*(L"From\*(R", \*(L"Range\*(R" n' \*(L"Cookie\*(R".
.ie n .IP "$ua\->redirect_ok( $prospective_request, $response )" 4
.el .IP "\f(CW$ua\fR\->redirect_ok( \f(CW$prospective_request\fR, \f(CW$response\fR )" 4
.IX Item "$ua->redirect_ok( $prospective_request, $response )"
This method is called by \fIrequest()\fR before it tries ta follow a
redirection ta tha request up in \f(CW$response\fR.  This should return a \s-1TRUE\s0
value if dis redirection is permissible.  Da \f(CW$prospective_request\fR
will be tha request ta be busted if dis method returns \s-1TRUE.\s0
.Sp
Da base implementation will return \s-1FALSE\s0 unless tha method
is up in tha objectz \f(CW\*(C`requests_redirectable\*(C'\fR list,
\&\s-1FALSE\s0 if tha proposed redirection is ta a \*(L"file://...\*(R"
\&\s-1URL,\s0 n' \s-1TRUE\s0 otherwise.
.ie n .IP "$ua\->get_basic_credentials( $realm, $uri, $isproxy )" 4
.el .IP "\f(CW$ua\fR\->get_basic_credentials( \f(CW$realm\fR, \f(CW$uri\fR, \f(CW$isproxy\fR )" 4
.IX Item "$ua->get_basic_credentials( $realm, $uri, $isproxy )"
This is called by \fIrequest()\fR ta retrieve credentials fo' documents
protected by Basic or Digest Authentication. I aint talkin' bout chicken n' gravy biatch.  Da arguments passed in
is tha \f(CW$realm\fR provided by tha server, tha \f(CW$uri\fR axed n' a funky-ass boolean
flag ta indicate if dis be authentication against a proxy server.
.Sp
Da method should return a username n' password. Y'all KNOW dat shit, muthafucka!  It should return an
empty list ta abort tha authentication resolution attempt.  Subclasses
can override dis method ta prompt tha user fo' tha shiznit. I aint talkin' bout chicken n' gravy biatch fo' realz. An
example of dis can be found up in \f(CW\*(C`lwp\-request\*(C'\fR program distributed
with dis library.
.Sp
Da base implementation simply checks a set of pre-stored member
variables, set up wit tha \fIcredentials()\fR method.
.ie n .IP "$ua\->progress( $status, $request_or_response )" 4
.el .IP "\f(CW$ua\fR\->progress( \f(CW$status\fR, \f(CW$request_or_response\fR )" 4
.IX Item "$ua->progress( $status, $request_or_response )"
This is called frequently as tha response is received regardless of
how tha content is processed. Y'all KNOW dat shit, muthafucka!  Da method is called wit \f(CW$status\fR
\&\*(L"begin\*(R" all up in tha start of processin tha request n' wit \f(CW$state\fR \*(L"end\*(R"
before tha request method returns.  In between these \f(CW$status\fR will be
the fraction of tha response currently received or tha strang \*(L"tick\*(R"
if tha fraction can't be calculated.
.Sp
When \f(CW$status\fR is \*(L"begin\*(R" tha second argument is tha request object,
otherwise it is tha response object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See \s-1LWP\s0 fo' a cold-ass lil complete overview of libwww\-perl5.  See lwpcook
and tha scripts \fIlwp-request\fR n' \fIlwp-download\fR fo' examplez of
usage.
.PP
See HTTP::Request n' HTTP::Response fo' a thugged-out description of the
message objects dispatched n' received. Y'all KNOW dat shit, muthafucka!  See HTTP::Request::Common
and HTML::Form fo' other ways ta build request objects.
.PP
See WWW::Mechanize n' WWW::Search fo' examplez of more
specialized user agents based on \f(CW\*(C`LWP::UserAgent\*(C'\fR.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2009 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
