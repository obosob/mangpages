.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Encode 3"
.TH Encode 3 "2014-10-20" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Encode \- characta encodings up in Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Encode qw(decode encode);
\&    $charactas = decode(\*(AqUTF\-8\*(Aq, $octets,     Encode::FB_CROAK);
\&    $octets     = encode(\*(AqUTF\-8\*(Aq, $characters, Encode::FB_CROAK);
.Ve
.SS "Table of Contents"
.IX Subsection "Table of Contents"
Encode consistz of a cold-ass lil collection of modulez whose details is too extensive
to fit up in one document.  This one itself explains tha top-level APIs
and general topics at a glance.  For other topics n' mo' details,
see tha documentation fo' these modules:
.IP "Encode::Alias \- Alias definitions ta encodings" 2
.IX Item "Encode::Alias - Alias definitions ta encodings"
.PD 0
.IP "Encode::Encodin \- Encode Implementation Base Class" 2
.IX Item "Encode::Encodin - Encode Implementation Base Class"
.IP "Encode::Supported \- List of Supported Encodings" 2
.IX Item "Encode::Supported - List of Supported Encodings"
.IP "Encode::CN \- Simplified Chinese Encodings" 2
.IX Item "Encode::CN - Simplified Chinese Encodings"
.IP "Encode::JP \- Japanese Encodings" 2
.IX Item "Encode::JP - Japanese Encodings"
.IP "Encode::KR \- Korean Encodings" 2
.IX Item "Encode::KR - Korean Encodings"
.IP "Encode::TW \- Traditionizzle Chinese Encodings" 2
.IX Item "Encode::TW - Traditionizzle Chinese Encodings"
.PD
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`Encode\*(C'\fR module serves up tha intercourse between Perl strings
and tha rest of tha system.  Perl strings is sequences of
\&\fIcharacters\fR.
.PP
Da repertoire of charactas dat Perl can represent be a superset of them
defined by tha Unicode Consortium. On most platforms tha ordinal
valuez of a cold-ass lil characta as returned by \f(CW\*(C`ord(\f(CIS\f(CW)\*(C'\fR is tha \fIUnicode
codepoint\fR fo' dat character n' shit. Da exceptions is platforms where
the legacy encodin is some variant of \s-1EBCDIC\s0 rather than a superset
of \s-1ASCII\s0; peep perlebcdic.
.PP
Durin recent history, data is moved round a cold-ass lil computa up in 8\-bit chunks,
often called \*(L"bytes\*(R" but also known as \*(L"octets\*(R" up in standardz documents.
Perl is widely used ta manipulate data of nuff types: not only strings of
charactas representin human or computa languages yo, but also \*(L"binary\*(R"
data, bein tha machinez representation of numbers, pixels up in a image, or
just bout anything.
.PP
When Perl is processin \*(L"binary data\*(R", tha programmer wants Perl to
process \*(L"sequencez of bytes\*(R". This aint a problem fo' Perl: cuz a
byte has 256 possible joints, it easily fits up in Perlz much larger
\&\*(L"logical character\*(R".
.PP
This document mostly explains tha \fIhow\fR. perlunitut n' perlunifaq
explain tha \fIwhy\fR.
.SS "\s-1TERMINOLOGY\s0"
.IX Subsection "TERMINOLOGY"
\fIcharacter\fR
.IX Subsection "character"
.PP
A characta up in tha range 0 .. 2**32\-1 (or more);
what Perlz strings is made of.
.PP
\fIbyte\fR
.IX Subsection "byte"
.PP
A characta up in tha range 0..255;
a special case of a Perl character.
.PP
\fIoctet\fR
.IX Subsection "octet"
.PP
8 bitz of data, wit ordinal joints 0..255;
term fo' bytes passed ta or from a non-Perl context, like fuckin a gangbangin' finger-lickin' disk file,
standard I/O stream, database, command-line argument, environment variable,
socket etc.
.SH "THE PERL ENCODING API"
.IX Header "THE PERL ENCODING API"
.SS "Basic methods"
.IX Subsection "Basic methods"
\fIencode\fR
.IX Subsection "encode"
.PP
.Vb 1
\&  $octets  = encode(ENCODING, STRING[, CHECK])
.Ve
.PP
Encodes tha scalar value \fI\s-1STRING\s0\fR from Perlz internal form into
\&\fI\s-1ENCODING\s0\fR n' returns a sequence of octets, n' you can put dat on yo' toast.  \fI\s-1ENCODING\s0\fR can be either a
canonical name or a alias.  For encodin names n' aliases, see
\&\*(L"Definin Aliases\*(R".  For \s-1CHECK,\s0 peep \*(L"Handlin Malformed Data\*(R".
.PP
For example, ta convert a strang from Perlz internal format into
\&\s-1ISO\-8859\-1,\s0 also known as Latin1:
.PP
.Vb 1
\&  $octets = encode("iso\-8859\-1", $string);
.Ve
.PP
\&\fB\s-1CAVEAT\s0\fR: When you run \f(CW\*(C`$octets = encode("utf8", $string)\*(C'\fR, then
\&\f(CW$octets\fR \fImight not be equal to\fR \f(CW$string\fR.  Though both contain the
same data, tha \s-1UTF8\s0 flag fo' \f(CW$octets\fR is \fIalways\fR off.  When you
encode anything, tha \s-1UTF8\s0 flag on tha result be always off, even when it
gotz nuff a cold-ass lil straight-up valid utf8 string. Right back up in yo muthafuckin ass. See \*(L"Da \s-1UTF8\s0 flag\*(R" below.
.PP
If tha \f(CW$string\fR is \f(CW\*(C`undef\*(C'\fR, then \f(CW\*(C`undef\*(C'\fR is returned.
.PP
\fIdecode\fR
.IX Subsection "decode"
.PP
.Vb 1
\&  $strin = decode(ENCODING, OCTETS[, CHECK])
.Ve
.PP
This function returns tha strang dat thangs up in dis biatch from decodin tha scalar
value \fI\s-1OCTETS\s0\fR, assumed ta be a sequence of octets up in \fI\s-1ENCODING\s0\fR, into
Perlz internal form.  Da returns tha resultin string.  As wit \fIencode()\fR,
\&\fI\s-1ENCODING\s0\fR can be either a cold-ass lil canonical name or a alias. For encodin names
and aliases, peep \*(L"Definin Aliases\*(R"; fo' \fI\s-1CHECK\s0\fR, peep \*(L"Handling
Malformed Data\*(R".
.PP
For example, ta convert \s-1ISO\-8859\-1\s0 data tha fuck into a strang up in Perl's
internal format:
.PP
.Vb 1
\&  $strin = decode("iso\-8859\-1", $octets);
.Ve
.PP
\&\fB\s-1CAVEAT\s0\fR: When you run \f(CW\*(C`$strin = decode("utf8", $octets)\*(C'\fR, then \f(CW$string\fR
\&\fImight not be equal to\fR \f(CW$octets\fR.  Though both contain tha same data, the
\&\s-1UTF8\s0 flag fo' \f(CW$string\fR is on. I aint talkin' bout chicken n' gravy biatch.  See \*(L"Da \s-1UTF8\s0 flag\*(R"
below.
.PP
If tha \f(CW$string\fR is \f(CW\*(C`undef\*(C'\fR, then \f(CW\*(C`undef\*(C'\fR is returned.
.PP
\fIfind_encoding\fR
.IX Subsection "find_encoding"
.PP
.Vb 1
\&  [$obj =] find_encoding(ENCODING)
.Ve
.PP
Returns tha \fIencodin object\fR correspondin ta \fI\s-1ENCODING\s0\fR.  Returns
\&\f(CW\*(C`undef\*(C'\fR if no matchin \fI\s-1ENCODING\s0\fR is find. Y'all KNOW dat shit, muthafucka!  Da returned object is
what do tha actual encodin or decoding.
.PP
.Vb 1
\&  $utf8 = decode($name, $bytes);
.Ve
.PP
is up in fact
.PP
.Vb 5
\&    $utf8 = do {
\&        $obj = find_encoding($name);
\&        croak qq(encodin "$name" not found) unless ref $obj;
\&        $obj\->decode($bytes);
\&    };
.Ve
.PP
with mo' error checking.
.PP
Yo ass can therefore save time by reusin dis object as bigs up;
.PP
.Vb 5
\&    mah $enc = find_encoding("iso\-8859\-1");
\&    while(<>) {
\&        mah $utf8 = $enc\->decode($_);
\&        ... # now do suttin' wit $utf8;
\&    }
.Ve
.PP
Besides \*(L"decode\*(R" n' \*(L"encode\*(R", other methodz are
available as well.  For instance, \f(CW\*(C`name()\*(C'\fR returns tha canonical
name of tha encodin object.
.PP
.Vb 1
\&  find_encoding("latin1")\->name; # iso\-8859\-1
.Ve
.PP
See Encode::Encodin fo' details.
.PP
\fIfrom_to\fR
.IX Subsection "from_to"
.PP
.Vb 1
\&  [$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])
.Ve
.PP
Converts \fIin-place\fR data between two encodings. Da data up in \f(CW$octets\fR
must be encoded as octets n' \fInot\fR as charactas up in Perlz internal
format. For example, ta convert \s-1ISO\-8859\-1\s0 data tha fuck into Microsoftz \s-1CP1250\s0
encoding:
.PP
.Vb 1
\&  from_to($octets, "iso\-8859\-1", "cp1250");
.Ve
.PP
and ta convert it back:
.PP
.Vb 1
\&  from_to($octets, "cp1250", "iso\-8859\-1");
.Ve
.PP
Because tha conversion happens up in place, tha data ta be
converted cannot be a strang constant: it must be a scalar variable.
.PP
\&\f(CW\*(C`from_to()\*(C'\fR returns tha length of tha converted strang up in octets on success,
and \f(CW\*(C`undef\*(C'\fR on error.
.PP
\&\fB\s-1CAVEAT\s0\fR: Da followin operations may look tha same yo, but is not:
.PP
.Vb 2
\&  from_to($data, "iso\-8859\-1", "utf8"); #1
\&  $data = decode("iso\-8859\-1", $data);  #2
.Ve
.PP
Both #1 n' #2 make \f(CW$data\fR consist of a cold-ass lil straight-up valid \s-1UTF\-8\s0 string,
but only #2 turns tha \s-1UTF8\s0 flag on. I aint talkin' bout chicken n' gravy biatch.  #1 is equivalent to:
.PP
.Vb 1
\&  $data = encode("utf8", decode("iso\-8859\-1", $data));
.Ve
.PP
See \*(L"Da \s-1UTF8\s0 flag\*(R" below.
.PP
Also note that:
.PP
.Vb 1
\&  from_to($octets, $from, $to, $check);
.Ve
.PP
is equivalent t:o
.PP
.Vb 1
\&  $octets = encode($to, decode($from, $octets), $check);
.Ve
.PP
Yes, it do \fInot\fR respect tha \f(CW$check\fR durin decoding.  It is
deliberately done dat way.  If you need minute control, use \f(CW\*(C`decode\*(C'\fR
followed by \f(CW\*(C`encode\*(C'\fR as bigs up:
.PP
.Vb 1
\&  $octets = encode($to, decode($from, $octets, $check_from), $check_to);
.Ve
.PP
\fIencode_utf8\fR
.IX Subsection "encode_utf8"
.PP
.Vb 1
\&  $octets = encode_utf8($string);
.Ve
.PP
Equivalent ta \f(CW\*(C`$octets = encode("utf8", $string)\*(C'\fR.  Da charactas in
\&\f(CW$string\fR is encoded up in Perlz internal format, n' tha result is returned
as a sequence of octets, n' you can put dat on yo' toast.  Because all possible charactas up in Perl have a
(loose, not strict) \s-1UTF\-8\s0 representation, dis function cannot fail.
.PP
\fIdecode_utf8\fR
.IX Subsection "decode_utf8"
.PP
.Vb 1
\&  $strin = decode_utf8($octets [, CHECK]);
.Ve
.PP
Equivalent ta \f(CW\*(C`$strin = decode("utf8", $octets [, CHECK])\*(C'\fR.
Da sequence of octets represented by \f(CW$octets\fR is decoded
from \s-1UTF\-8\s0 tha fuck into a sequence of logical characters.
Because not all sequencez of octets is valid \s-1UTF\-8,\s0
it is like possible fo' dis function ta fail.
For \s-1CHECK,\s0 peep \*(L"Handlin Malformed Data\*(R".
.SS "Listin available encodings"
.IX Subsection "Listin available encodings"
.Vb 2
\&  use Encode;
\&  @list = Encode\->encodings();
.Ve
.PP
Returns a list of canonical namez of available encodings dat have already
been loaded. Y'all KNOW dat shit, muthafucka!  To git a list of all available encodings includin dem that
have not yet been loaded, say:
.PP
.Vb 1
\&  @all_encodings = Encode\->encodings(":all");
.Ve
.PP
Or you can give tha name of a specific module:
.PP
.Vb 1
\&  @with_jp = Encode\->encodings("Encode::JP");
.Ve
.PP
When "\f(CW\*(C`::\*(C'\fR\*(L" aint up in tha name, \*(R"\f(CW\*(C`Encode::\*(C'\fR" be assumed.
.PP
.Vb 1
\&  @ebcdic = Encode\->encodings("EBCDIC");
.Ve
.PP
To smoke up in detail which encodings is supported by dis package,
see Encode::Supported.
.SS "Definin Aliases"
.IX Subsection "Definin Aliases"
To add a freshly smoked up alias ta a given encoding, use:
.PP
.Vb 3
\&  use Encode;
\&  use Encode::Alias;
\&  define_alias(NEWNAME => ENCODING);
.Ve
.PP
Afta that, \fI\s-1NEWNAME\s0\fR can be used as a alias fo' \fI\s-1ENCODING\s0\fR.
\&\fI\s-1ENCODING\s0\fR may be either tha name of a encodin or an
\&\fIencodin object\fR.
.PP
Before you do that, first make shizzle tha alias is nonexistent using
\&\f(CW\*(C`resolve_alias()\*(C'\fR, which returns tha canonical name thereof.
For example:
.PP
.Vb 3
\&  Encode::resolve_alias("latin1") eq "iso\-8859\-1" # true
\&  Encode::resolve_alias("iso\-8859\-12")   # false; nonexistent
\&  Encode::resolve_alias($name) eq $name  # legit if $name is canonical
.Ve
.PP
\&\f(CW\*(C`resolve_alias()\*(C'\fR do not need \f(CW\*(C`use Encode::Alias\*(C'\fR; it can be
imported via \f(CW\*(C`use Encode qw(resolve_alias)\*(C'\fR.
.PP
See Encode::Alias fo' details.
.SS "Findin \s-1IANA\s0 Characta Set Registry names"
.IX Subsection "Findin IANA Characta Set Registry names"
Da canonical name of a given encodin do not necessarily smoke with
\&\s-1IANA\s0 Characta Set Registry, commonly peeped as \f(CW\*(C`Content\-Type:
text/plain; charset=\f(CIWHATEVER\f(CW\*(C'\fR.  For most cases, tha canonical name
works yo, but sometimes it do not, most notably wit \*(L"utf\-8\-strict\*(R".
.PP
Az of \f(CW\*(C`Encode\*(C'\fR version 2.21, a freshly smoked up method \f(CW\*(C`mime_name()\*(C'\fR is therefore added.
.PP
.Vb 4
\&  use Encode;
\&  mah $enc = find_encoding("UTF\-8");
\&  warn $enc\->name;      # utf\-8\-strict
\&  warn $enc\->mime_name; # UTF\-8
.Ve
.PP
See also:  Encode::Encoding
.SH "Encodin via PerlIO"
.IX Header "Encodin via PerlIO"
If yo' perl supports \f(CW\*(C`PerlIO\*(C'\fR (which is tha default), you can use a
\&\f(CW\*(C`PerlIO\*(C'\fR layer ta decode n' encode directly via a gangbangin' filehandle.  The
followin two examplez is straight-up identical up in functionality:
.PP
.Vb 10
\&  ### Version 1 via PerlIO
\&    open(INPUT,  "< :encoding(shiftjis)", $infile)
\&        || take a thugged-out dirtnap "Can\*(Aqt open < $infile fo' reading: $!";
\&    open(OUTPUT, "> :encoding(euc\-jp)",  $outfile)
\&        || take a thugged-out dirtnap "Can\*(Aqt open > $output fo' writing: $!";
\&    while (<INPUT>) {   # auto decodes $_
\&        print OUTPUT;   # auto encodes $_
\&    }
\&    close(INPUT)   || take a thugged-out dirtnap "can\*(Aqt close $infile: $!";
\&    close(OUTPUT)  || take a thugged-out dirtnap "can\*(Aqt close $outfile: $!";
\&
\&  ### Version 2 via from_to()
\&    open(INPUT,  "< :raw", $infile)
\&        || take a thugged-out dirtnap "Can\*(Aqt open < $infile fo' reading: $!";
\&    open(OUTPUT, "> :raw",  $outfile)
\&        || take a thugged-out dirtnap "Can\*(Aqt open > $output fo' writing: $!";
\&
\&    while (<INPUT>) {
\&        from_to($_, "shiftjis", "euc\-jp", 1);  # switch encoding
\&        print OUTPUT;   # emit raw (but properly encoded) data
\&    }
\&    close(INPUT)   || take a thugged-out dirtnap "can\*(Aqt close $infile: $!";
\&    close(OUTPUT)  || take a thugged-out dirtnap "can\*(Aqt close $outfile: $!";
.Ve
.PP
In tha straight-up original gangsta version above, you let tha appropriate encodin layer
handle tha conversion. I aint talkin' bout chicken n' gravy biatch.  In tha second, you explicitly translate
from one encodin ta tha other.
.PP
Unfortunately, it may be dat encodings is \f(CW\*(C`PerlIO\*(C'\fR\-savvy.  Yo ass can check
to peep whether yo' encodin is supported by \f(CW\*(C`PerlIO\*(C'\fR by invokin the
\&\f(CW\*(C`perlio_ok\*(C'\fR method on it:
.PP
.Vb 2
\&  Encode::perlio_ok("hz");             # false
\&  find_encoding("euc\-cn")\->perlio_ok;  # legit wherever PerlIO be available
\&
\&  use Encode qw(perlio_ok);            # imported upon request
\&  perlio_ok("euc\-jp")
.Ve
.PP
Fortunately, all encodings dat come wit \f(CW\*(C`Encode\*(C'\fR core is \f(CW\*(C`PerlIO\*(C'\fR\-savvy
except fo' \f(CW\*(C`hz\*(C'\fR n' \f(CW\*(C`ISO\-2022\-kr\*(C'\fR.  For tha gory details, see
Encode::Encodin n' Encode::PerlIO.
.SH "Handlin Malformed Data"
.IX Header "Handlin Malformed Data"
Da optionizzle \fI\s-1CHECK\s0\fR argument  drops some lyrics ta \f(CW\*(C`Encode\*(C'\fR what tha fuck ta do when
encounterin malformed data.  Without \fI\s-1CHECK\s0\fR, \f(CW\*(C`Encode::FB_DEFAULT\*(C'\fR
(== 0) be assumed.
.PP
Az of version 2.12, \f(CW\*(C`Encode\*(C'\fR supports coderef joints fo' \f(CW\*(C`CHECK\*(C'\fR;
see below.
.PP
\&\fB\s-1NOTE:\s0\fR Not all encodings support dis feature.
Some encodings ignore tha \fI\s-1CHECK\s0\fR argument.  For example,
Encode::Unicode ignores \fI\s-1CHECK\s0\fR n' it always croaks on error.
.SS "List of \fI\s-1CHECK\s0\fP joints"
.IX Subsection "List of CHECK joints"
\fI\s-1FB_DEFAULT\s0\fR
.IX Subsection "FB_DEFAULT"
.PP
.Vb 1
\&  I<CHECK> = Encode::FB_DEFAULT ( == 0)
.Ve
.PP
If \fI\s-1CHECK\s0\fR is 0, encodin n' decodin replace any malformed character
with a \fIsubstitution character\fR.  When you encode, \fI\s-1SUBCHAR\s0\fR is used.
When you decode, tha Unicode \s-1REPLACEMENT CHARACTER,\s0 code point U+FFFD, is
used. Y'all KNOW dat shit, muthafucka!  If tha data is supposed ta be \s-1UTF\-8,\s0 a optionizzle lexical warnin of
warnin category \f(CW"utf8"\fR is given.
.PP
\fI\s-1FB_CROAK\s0\fR
.IX Subsection "FB_CROAK"
.PP
.Vb 1
\&  I<CHECK> = Encode::FB_CROAK ( == 1)
.Ve
.PP
If \fI\s-1CHECK\s0\fR is 1, methodz immediately take a thugged-out dirtnap wit a error
message.  Therefore, when \fI\s-1CHECK\s0\fR is 1, you should trap
exceptions wit \f(CW\*(C`eval{}\*(C'\fR, unless you straight-up wanna let it \f(CW\*(C`die\*(C'\fR.
.PP
\fI\s-1FB_QUIET\s0\fR
.IX Subsection "FB_QUIET"
.PP
.Vb 1
\&  I<CHECK> = Encode::FB_QUIET
.Ve
.PP
If \fI\s-1CHECK\s0\fR is set ta \f(CW\*(C`Encode::FB_QUIET\*(C'\fR, encodin n' decodin immediately
return tha portion of tha data dat has been processed so far when an
error occurs. Da data argument is overwritten wit every last muthafuckin thang
afta dat point; dat is, tha unprocessed portion of tha data.  This is
handy when you gotta call \f(CW\*(C`decode\*(C'\fR repeatedly up in tha case where your
source data may contain partial multi-byte characta sequences,
(that is, yo ass is readin wit a gangbangin' fixed-width buffer) yo. Herez some sample
code ta do exactly that:
.PP
.Vb 5
\&    my($buffer, $string) = ("", "");
\&    while (read($fh, $buffer, 256, length($buffer))) {
\&        $strin .= decode($encoding, $buffer, Encode::FB_QUIET);
\&        # $buffer now gotz nuff tha unprocessed partial character
\&    }
.Ve
.PP
\fI\s-1FB_WARN\s0\fR
.IX Subsection "FB_WARN"
.PP
.Vb 1
\&  I<CHECK> = Encode::FB_WARN
.Ve
.PP
This is tha same ol' dirty as \f(CW\*(C`FB_QUIET\*(C'\fR above, except dat instead of bein silent
on errors, it thangs a warning.  This is handy fo' when yo ass is debugging.
.PP
\fI\s-1FB_PERLQQ FB_HTMLCREF FB_XMLCREF\s0\fR
.IX Subsection "FB_PERLQQ FB_HTMLCREF FB_XMLCREF"
.IP "perlqq mode (\fI\s-1CHECK\s0\fR = Encode::FB_PERLQQ)" 2
.IX Item "perlqq mode (CHECK = Encode::FB_PERLQQ)"
.PD 0
.IP "\s-1HTML\s0 charref mode (\fI\s-1CHECK\s0\fR = Encode::FB_HTMLCREF)" 2
.IX Item "HTML charref mode (CHECK = Encode::FB_HTMLCREF)"
.IP "\s-1XML\s0 charref mode (\fI\s-1CHECK\s0\fR = Encode::FB_XMLCREF)" 2
.IX Item "XML charref mode (CHECK = Encode::FB_XMLCREF)"
.PD
.PP
For encodings dat is implemented by tha \f(CW\*(C`Encode::XS\*(C'\fR module, \f(CW\*(C`CHECK\*(C'\fR \f(CW\*(C`==\*(C'\fR
\&\f(CW\*(C`Encode::FB_PERLQQ\*(C'\fR puts \f(CW\*(C`encode\*(C'\fR n' \f(CW\*(C`decode\*(C'\fR tha fuck into \f(CW\*(C`perlqq\*(C'\fR fallback mode.
.PP
When you decode, \f(CW\*(C`\ex\f(CIHH\f(CW\*(C'\fR is banged fo' a malformed character, where
\&\fI\s-1HH\s0\fR is tha hex representation of tha octet dat could not be decoded to
utf8.  When you encode, \f(CW\*(C`\ex{\f(CIHHHH\f(CW}\*(C'\fR is ghon be inserted, where \fI\s-1HHHH\s0\fR is
the Unicode code point (in any number of hex digits) of tha characta that
cannot be found up in tha characta repertoire of tha encoding.
.PP
Da \s-1HTML/XML\s0 characta reference modes is bout tha same. In place of
\&\f(CW\*(C`\ex{\f(CIHHHH\f(CW}\*(C'\fR, \s-1HTML\s0 uses \f(CW\*(C`&#\f(CINNN\f(CW;\*(C'\fR where \fI\s-1NNN\s0\fR be a thugged-out decimal number, and
\&\s-1XML\s0 uses \f(CW\*(C`&#x\f(CIHHHH\f(CW;\*(C'\fR where \fI\s-1HHHH\s0\fR is tha hexadecimal number.
.PP
In \f(CW\*(C`Encode\*(C'\fR 2.10 or later, \f(CW\*(C`LEAVE_SRC\*(C'\fR be also implied.
.PP
\fIDa bitmask\fR
.IX Subsection "Da bitmask"
.PP
These modes is all straight-up set via a funky-ass bitmask.  Here is how tha fuck tha \f(CW\*(C`FB_\f(CIXXX\f(CW\*(C'\fR
constants is laid out.  Yo ass can import tha \f(CW\*(C`FB_\f(CIXXX\f(CW\*(C'\fR constants via
\&\f(CW\*(C`use Encode qw(:fallbacks)\*(C'\fR, n' you can import tha generic bitmask
constants via \f(CW\*(C`use Encode qw(:fallback_all)\*(C'\fR.
.PP
.Vb 8
\&                     FB_DEFAULT FB_CROAK FB_QUIET FB_WARN  FB_PERLQQ
\& DIE_ON_ERR    0x0001             X
\& WARN_ON_ERR   0x0002                               X
\& RETURN_ON_ERR 0x0004                      X        X
\& LEAVE_SRC     0x0008                                        X
\& PERLQQ        0x0100                                        X
\& HTMLCREF      0x0200
\& XMLCREF       0x0400
.Ve
.PP
\fI\s-1LEAVE_SRC\s0\fR
.IX Subsection "LEAVE_SRC"
.PP
.Vb 1
\&  Encode::LEAVE_SRC
.Ve
.PP
If tha \f(CW\*(C`Encode::LEAVE_SRC\*(C'\fR bit is \fInot\fR set but \fI\s-1CHECK\s0\fR is set, then the
source strang ta \fIencode()\fR or \fIdecode()\fR is ghon be overwritten up in place.
If you not horny bout this, then bitwise-OR it wit tha bitmask.
.SS "coderef fo' \s-1CHECK\s0"
.IX Subsection "coderef fo' CHECK"
Az of \f(CW\*(C`Encode\*(C'\fR 2.12, \f(CW\*(C`CHECK\*(C'\fR can also be a cold-ass lil code reference which takes the
ordinal value of tha unmapped characta as a argument n' returns a string
that represents tha fallback character n' shit.  For instance:
.PP
.Vb 1
\&  $ascii = encode("ascii", $utf8, sub{ sprintf "<U+%04X>", shift });
.Ve
.PP
Acts like \f(CW\*(C`FB_PERLQQ\*(C'\fR but U+\fI\s-1XXXX\s0\fR is used instead of \f(CW\*(C`\ex{\f(CIXXXX\f(CW}\*(C'\fR.
.SH "Definin Encodings"
.IX Header "Definin Encodings"
To define a freshly smoked up encoding, use:
.PP
.Vb 2
\&    use Encode qw(define_encoding);
\&    define_encoding($object, CANONICAL_NAME [, alias...]);
.Ve
.PP
\&\fI\s-1CANONICAL_NAME\s0\fR is ghon be associated wit \fI\f(CI$object\fI\fR.  Da object
should provide tha intercourse busted lyrics bout up in Encode::Encoding.
If mo' than two arguments is provided, additional
arguments is considered aliases fo' \fI\f(CI$object\fI\fR.
.PP
See Encode::Encodin fo' details.
.SH "Da UTF8 flag"
.IX Header "Da UTF8 flag"
Before tha introduction of Unicode support up in Perl, Da \f(CW\*(C`eq\*(C'\fR operator
just compared tha strings represented by two scalars. Beginnin with
Perl 5.8, \f(CW\*(C`eq\*(C'\fR compares two strings wit simultaneous consideration of
\&\fIthe \s-1UTF8\s0 flag\fR. To explain why we juiced it up so, I quote from page 402 of
\&\fIProgrammin Perl, 3rd ed.\fR
.IP "Goal #1:" 2
.IX Item "Goal #1:"
Oldskool byte-oriented programs should not spontaneously break on tha old
byte-oriented data they used ta work on.
.IP "Goal #2:" 2
.IX Item "Goal #2:"
Oldskool byte-oriented programs should magically start hustlin on tha new
character-oriented data when appropriate.
.IP "Goal #3:" 2
.IX Item "Goal #3:"
Programs should run just as fast up in tha freshly smoked up character-oriented mode
as up in tha oldschool byte-oriented mode.
.IP "Goal #4:" 2
.IX Item "Goal #4:"
Perl should remain one language, rather than forkin tha fuck into a
byte-oriented Perl n' a cold-ass lil character-oriented Perl.
.PP
When \fIProgrammin Perl, 3rd ed.\fR was written, not even Perl 5.6.0 had been
born yet, nuff features documented up in tha book remained unimplemented fo' a
long time.  Perl 5.8 erected much of this, n' tha introduction of the
\&\s-1UTF8\s0 flag is one of em.  Yo ass can be thinkin of there bein two fundamentally
different kindz of strings n' string-operations up in Perl: one a
byte-oriented mode  fo' when tha internal \s-1UTF8\s0 flag is off, n' tha other a
character-oriented mode fo' when tha internal \s-1UTF8\s0 flag is on.
.PP
Here is how tha fuck \f(CW\*(C`Encode\*(C'\fR handlez tha \s-1UTF8\s0 flag.
.IP "\(bu" 2
When you \fIencode\fR, tha resultin \s-1UTF8\s0 flag be always \fBoff\fR.
.IP "\(bu" 2
When you \fIdecode\fR, tha resultin \s-1UTF8\s0 flag is \fBon\fR\-\-\fIunless\fR you can
unambiguously represent data.  Here is what tha fuck we mean by \*(L"unambiguously\*(R".
Afta \f(CW\*(C`$utf8 = decode("foo", $octet)\*(C'\fR,
.Sp
.Vb 6
\&  When $octet is...   Da UTF8 flag up in $utf8 is
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  In ASCII only (or EBCDIC only)            OFF
\&  In ISO\-8859\-1                              ON
\&  In any other Encodin                      ON
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.Sp
As you see, there is one exception: up in \s-1ASCII. \s0 That way you can assume
Goal #1.  And wit \f(CW\*(C`Encode\*(C'\fR, Goal #2 be assumed but you still gotta be
careful up in tha cases mentioned up in tha \fB\s-1CAVEAT\s0\fR paragraphs above.
.Sp
This \s-1UTF8\s0 flag aint visible up in Perl scripts, exactly fo' tha same reason
you cannot (or rather, you \fIdon't have to\fR) peep whether a scalar gotz nuff
a string, a integer, or a gangbangin' floating-point number n' shit.   But you can still peek
and poke these if you will.  See tha next section.
.SS "Messin wit Perlz Internals"
.IX Subsection "Messin wit Perlz Internals"
Da followin \s-1API\s0 uses partz of Perlz internals up in tha current
implementation. I aint talkin' bout chicken n' gravy biatch.  As such, they is efficient but may chizzle up in a gangbangin' future
release.
.PP
\fIis_utf8\fR
.IX Subsection "is_utf8"
.PP
.Vb 1
\&  is_utf8(STRING [, CHECK])
.Ve
.PP
[\s-1INTERNAL\s0] Tests whether tha \s-1UTF8\s0 flag is turned on up in tha \fI\s-1STRING\s0\fR.
If \fI\s-1CHECK\s0\fR is true, also checks whether \fI\s-1STRING\s0\fR gotz nuff well-formed
\&\s-1UTF\-8. \s0 Returns legit if successful, false otherwise.
.PP
Az of Perl 5.8.1, utf8 also has tha \f(CW\*(C`utf8::is_utf8\*(C'\fR function.
.PP
\fI_utf8_on\fR
.IX Subsection "_utf8_on"
.PP
.Vb 1
\&  _utf8_on(STRING)
.Ve
.PP
[\s-1INTERNAL\s0] Turns tha \fI\s-1STRING\s0\fRz internal \s-1UTF8\s0 flag \fBon\fR.  Da \fI\s-1STRING\s0\fR
is \fInot\fR checked fo' containin only well-formed \s-1UTF\-8. \s0 Do not use this
unless you \fIknow wit absolute certainty\fR dat tha \s-1STRING\s0 holdz only
well-formed \s-1UTF\-8. \s0 Returns tha previous state of tha \s-1UTF8\s0 flag (so please
don't treat tha return value as indicatin success or failure), or \f(CW\*(C`undef\*(C'\fR
if \fI\s-1STRING\s0\fR aint a string.
.PP
\&\fB\s-1NOTE\s0\fR: For securitizzle reasons, dis function do not work on tainted joints.
.PP
\fI_utf8_off\fR
.IX Subsection "_utf8_off"
.PP
.Vb 1
\&  _utf8_off(STRING)
.Ve
.PP
[\s-1INTERNAL\s0] Turns tha \fI\s-1STRING\s0\fRz internal \s-1UTF8\s0 flag \fBoff\fR.  Do not use
frivolously.  Returns tha previous state of tha \s-1UTF8\s0 flag, or \f(CW\*(C`undef\*(C'\fR if
\&\fI\s-1STRING\s0\fR aint a string.  Do not treat tha return value as indicatizzle of
success or failure, cuz dat aint what tha fuck it means: it is only the
previous setting.
.PP
\&\fB\s-1NOTE\s0\fR: For securitizzle reasons, dis function do not work on tainted joints.
.SH "UTF\-8 vs. utf8 vs. UTF8"
.IX Header "UTF-8 vs. utf8 vs. UTF8"
.Vb 3
\&  ....We now view strings not as sequencez of bytes yo, but as sequences
\&  of numbers up in tha range 0 .. 2**32\-1 (or up in tha case of 64\-bit
\&  computers, 0 .. 2**64\-1) \-\- Programmin Perl, 3rd ed.
.Ve
.PP
That has historically been Perlz notion of \s-1UTF\-8,\s0 as dat is how tha fuck \s-1UTF\-8\s0 was
first conceived by Ken Thompson when he invented dat shit. But fuck dat shiznit yo, tha word on tha street is dat props to
lata revisions ta tha applicable standards, straight-up legit \s-1UTF\-8\s0 is now rather
stricta than dis shit. For example, its range is much narrower (0 .. 0x10_FFFF
to cover only 21 bits instead of 32 or 64 bits) n' some sequences
are not allowed, like dem used up in surrogate pairs, tha 31 non-character
code points 0xFDD0 .. 0xFDEF, tha last two code points up in \fIany\fR plane
(0x\fI\s-1XX\s0\fR_FFFE n' 0x\fI\s-1XX\s0\fR_FFFF), all non-shortest encodings, etc.
.PP
Da forma default up in which Perl would always bust a loose interpretation of
\&\s-1UTF\-8\s0 has now been overruled:
.PP
.Vb 5
\&  From: Larry Wall <larry@wall.org>
\&  Date: December 04, 2004 11:51:58 JST
\&  To: perl\-unicode@perl.org
\&  Subject: Re: Make Encode.pm support tha real UTF\-8
\&  Message\-Id: <20041204025158.GA28754@wall.org>
\&
\&  On Fri, Dec 03, 2004 at 10:12:12PM +0000, Slim Tim Bunce wrote:
\&  : I\*(Aqve no problem wit \*(Aqutf8\*(Aq bein perl\*(Aqs unrestricted uft8 encoding,
\&  : but "UTF\-8" is tha name of tha standard n' should give the
\&  : correspondin behaviour.
\&
\&  For what tha fuck it\*(Aqs worth, that\*(Aqs how tha fuck I\*(Aqve always kept dem straight up in my
\&  head.
\&
\&  Also fo' what tha fuck it\*(Aqs worth, Perl 6 will mostly default ta strict but
\&  make it easy as fuck  ta switch back ta lax.
\&
\&  Larry
.Ve
.PP
Got that, biatch?  Az of Perl 5.8.7, \fB\*(L"\s-1UTF\-8\*(R"\s0\fR means \s-1UTF\-8\s0 up in its current
sense, which is conservatizzle n' strict n' security-conscious, whereas
\&\fB\*(L"utf8\*(R"\fR means \s-1UTF\-8\s0 up in its forma sense, which was liberal n' loose and
lax.  \f(CW\*(C`Encode\*(C'\fR version 2.10 or lata thus groks dis subtle but critically
important distinction between \f(CW"UTF\-8"\fR n' \f(CW"utf8"\fR.
.PP
.Vb 2
\&  encode("utf8",  "\ex{FFFF_FFFF}", 1); # aiiight
\&  encode("UTF\-8", "\ex{FFFF_FFFF}", 1); # croaks
.Ve
.PP
In tha \f(CW\*(C`Encode\*(C'\fR module, \f(CW"UTF\-8"\fR is straight-up a cold-ass lil canonical name for
\&\f(CW"utf\-8\-strict"\fR.  That hyphen between tha \f(CW"UTF"\fR n' tha \f(CW"8"\fR is
critical; without it, \f(CW\*(C`Encode\*(C'\fR goes \*(L"liberal\*(R" n' (like overly\-)permissive:
.PP
.Vb 4
\&  find_encoding("UTF\-8")\->name # is \*(Aqutf\-8\-strict\*(Aq
\&  find_encoding("utf\-8")\->name # ditto. names is case insensitive
\&  find_encoding("utf_8")\->name # ditto. "_" is treated as "\-"
\&  find_encoding("UTF8")\->name  # is \*(Aqutf8\*(Aq.
.Ve
.PP
Perlz internal \s-1UTF8\s0 flag is called \*(L"\s-1UTF8\*(R",\s0 without a hyphen. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it indicates
whether a strang is internally encoded as \*(L"utf8\*(R", also without a hyphen.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode::Encoding,
Encode::Supported,
Encode::PerlIO,
encoding,
perlebcdic,
\&\*(L"open\*(R" up in perlfunc,
perlunicode, perluniintro, perlunifaq, perlunitut
utf8,
the Perl Unicode Mailin List <http://lists.perl.org/list/perl\-unicode.html>
.SH "MAINTAINER"
.IX Header "MAINTAINER"
This project was originated by tha late Nick Ing-Simmons n' later
maintained by Don Juan Kogai \fI<dankogai@cpan.org>\fR.  See \s-1AUTHORS\s0
for a gangbangin' full list of playas involved. Y'all KNOW dat shit, muthafucka!  For any thangs, bust mail to
\&\fI<perl\-unicode@perl.org>\fR so dat we can all share.
.PP
While Don Juan Kogai retains tha copyright as a maintainer, credit
should git all up in all dem involved. Y'all KNOW dat shit, muthafucka!  See \s-1AUTHORS\s0 fo' a list of them
who submitted code ta tha project.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2013 Don Juan Kogai \fI<dankogai@cpan.org>\fR.
.PP
This library is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
