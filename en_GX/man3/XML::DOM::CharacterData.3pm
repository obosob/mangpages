.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::DOM::CharacterData 3"
.TH XML::DOM::CharacterData 3 "2000-01-31" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::DOM::CharacterData \- Common intercourse fo' Text, CDATASections n' Comments
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::DOM::CharacterData extendz XML::DOM::Node
.PP
Da CharacterData intercourse extendz Node wit a set of attributes and
methodz fo' accessin characta data up in tha \s-1DOM.\s0 For claritizzle dis set
is defined here rather than on each object dat uses these attributes
and methods. No \s-1DOM\s0 objects correspond directly ta CharacterData,
though Text, Comment n' CDATASection do inherit tha intercourse from dat shit. 
All offsets up in dis intercourse start from 0.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "getData n' setData (data)" 4
.IX Item "getData n' setData (data)"
Da characta data of tha node dat implements this
interface. Da \s-1DOM\s0 implementation may not put arbitrary
limits on tha amount of data dat may be stored up in a
CharacterData node. But fuck dat shiznit yo, tha word on tha street is dat implementation limits may mean
that tha entirety of a nodez data may not fit tha fuck into a single
DOMString. In such cases, tha user may call substringData to
retrieve tha data up in appropriately sized pieces.
.IP "getLength" 4
.IX Item "getLength"
Da number of charactas dat is available all up in data and
the substringData method below. This may have tha value zero,
i.e., CharacterData nodes may be empty.
.IP "substringData (offset, count)" 4
.IX Item "substringData (offset, count)"
Extracts a range of data from tha node.
.Sp
Parameters:
 \fIoffset\fR  Start offset of substrin ta extract.
 \fIcount\fR   Da number of charactas ta extract.
.Sp
Return Value: Da specified substring. If tha sum of offset n' count
exceedz tha length, then all charactas ta tha end of
the data is returned.
.IP "appendData (str)" 4
.IX Item "appendData (str)"
Appendz tha strang ta tha end of tha characta data of the
node. Upon success, data serves up access ta tha concatenation
of data n' tha DOMStrin specified.
.IP "insertData (offset, arg)" 4
.IX Item "insertData (offset, arg)"
Inserts a strang all up in tha specified characta offset.
.Sp
Parameters:
 \fIoffset\fR  Da characta offset at which ta insert.
 \fIarg\fR     Da DOMStrin ta insert.
.IP "deleteData (offset, count)" 4
.IX Item "deleteData (offset, count)"
Removes a range of charactas from tha node. 
Upon success, data n' length reflect tha chizzle.
If tha sum of offset n' count exceedz length then all charactas 
from offset ta tha end of tha data is deleted.
.Sp
Parameters: 
 \fIoffset\fR  Da offset from which ta remove characters. 
 \fIcount\fR   Da number of charactas ta delete.
.IP "replaceData (offset, count, arg)" 4
.IX Item "replaceData (offset, count, arg)"
Replaces tha charactas startin all up in tha specified character
offset wit tha specified string.
.Sp
Parameters:
 \fIoffset\fR  Da offset from which ta start replacing.
 \fIcount\fR   Da number of charactas ta replace. 
 \fIarg\fR     Da DOMStrin wit which tha range must be replaced.
.Sp
If tha sum of offset n' count exceedz length, then all charactas ta tha end of
the data is replaced (i.e., tha effect is tha same ol' dirty as a remove method call wit 
the same range, followed by a append method invocation).
