.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Socket::IP 3"
.TH IO::Socket::IP 3 "2014-07-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
"IO::Socket::IP" \- Family\-neutral IP socket supportin both IPv4 n' IPv6
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use IO::Socket::IP;
\&
\& mah $sock = IO::Socket::IP\->new(
\&    PeerHost => "www.google.com",
\&    PeerPort => "http",
\&    Type     => SOCK_STREAM,
\& ) or take a thugged-out dirtnap "Cannot construct socket \- $@";
\&
\& mah $familyname = ( $sock\->sockdomain == PF_INET6 ) ? "IPv6" :
\&                  ( $sock\->sockdomain == PF_INET  ) ? "IPv4" :
\&                                                      "unknown";
\&
\& printf "Connected ta google via %s\en", $familyname;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up a protocol-independent way ta use IPv4 n' IPv6 sockets,
intended as a replacement fo' IO::Socket::INET. Most constructor arguments
and methodz is provided up in a funky-ass backward-compatible way. For a list of known
differences, peep tha \f(CW\*(C`IO::Socket::INET\*(C'\fR \s-1INCOMPATIBILITES\s0 section below.
.PP
It uses tha \f(CWgetaddrinfo(3)\fR function ta convert hostnames n' steez names
or port numbers tha fuck into setz of possible addresses ta connect ta or listen on.
This allows it ta work fo' IPv6 where tha system supports it, while still
fallin back ta IPv4\-only on systems which don't.
.ie n .SH "REPLACING ""IO::Socket"" DEFAULT BEHAVIOUR"
.el .SH "REPLACING \f(CWIO::Socket\fP DEFAULT BEHAVIOUR"
.IX Header "REPLACING IO::Socket DEFAULT BEHAVIOUR"
By placin \f(CW\*(C`\-register\*(C'\fR up in tha import list, IO::Socket uses
\&\f(CW\*(C`IO::Socket::IP\*(C'\fR rather than \f(CW\*(C`IO::Socket::INET\*(C'\fR as tha class dat handles
\&\f(CW\*(C`PF_INET\*(C'\fR.  \f(CW\*(C`IO::Socket\*(C'\fR will also use \f(CW\*(C`IO::Socket::IP\*(C'\fR rather than
\&\f(CW\*(C`IO::Socket::INET6\*(C'\fR ta handle \f(CW\*(C`PF_INET6\*(C'\fR, provided dat tha \f(CW\*(C`AF_INET6\*(C'\fR
constant be available.
.PP
Changin \f(CW\*(C`IO::Socket\*(C'\fRz default behaviour means dat callin the
\&\f(CW\*(C`IO::Socket\*(C'\fR constructor wit either \f(CW\*(C`PF_INET\*(C'\fR or \f(CW\*(C`PF_INET6\*(C'\fR as the
\&\f(CW\*(C`Domain\*(C'\fR parameta will yield a \f(CW\*(C`IO::Socket::IP\*(C'\fR object.
.PP
.Vb 1
\& use IO::Socket::IP \-register;
\&
\& mah $sock = IO::Socket\->new(
\&    Domain    => PF_INET6,
\&    LocalHost => "::1",
\&    Listen    => 1,
\& ) or take a thugged-out dirtnap "Cannot create socket \- $@\en";
\&
\& print "Created a socket of type " . ref($sock) . "\en";
.Ve
.PP
Note dat \f(CW\*(C`\-register\*(C'\fR be a global settin dat applies ta tha entire program;
it cannot be applied only fo' certain callers, removed, or limited by lexical
scope.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.ie n .SS "$sock = IO::Socket::IP\->new( %args )"
.el .SS "\f(CW$sock\fP = IO::Socket::IP\->new( \f(CW%args\fP )"
.IX Subsection "$sock = IO::Socket::IP->new( %args )"
Creates a freshly smoked up \f(CW\*(C`IO::Socket::IP\*(C'\fR object, containin a newly pimped socket
handle accordin ta tha named arguments passed. Y'all KNOW dat shit, muthafucka! Da recognised arguments are:
.IP "PeerHost => \s-1STRING\s0" 8
.IX Item "PeerHost => STRING"
.PD 0
.IP "PeerService => \s-1STRING\s0" 8
.IX Item "PeerService => STRING"
.PD
Hostname n' steez name fo' tha peer ta \f(CW\*(C`connect()\*(C'\fR to. Da steez name
may be given as a port number, as a thugged-out decimal string.
.IP "PeerAddr => \s-1STRING\s0" 8
.IX Item "PeerAddr => STRING"
.PD 0
.IP "PeerPort => \s-1STRING\s0" 8
.IX Item "PeerPort => STRING"
.PD
For symmetry wit tha accessor methodz n' compatibilitizzle with
\&\f(CW\*(C`IO::Socket::INET\*(C'\fR, these is accepted as synonyms fo' \f(CW\*(C`PeerHost\*(C'\fR and
\&\f(CW\*(C`PeerService\*(C'\fR respectively.
.IP "PeerAddrInfo => \s-1ARRAY\s0" 8
.IX Item "PeerAddrInfo => ARRAY"
Alternate form of specifyin tha peer ta \f(CW\*(C`connect()\*(C'\fR to. This should be an
array of tha form returned by \f(CW\*(C`Socket::getaddrinfo\*(C'\fR.
.Sp
This parameta takes precedence over tha \f(CW\*(C`Peer*\*(C'\fR, \f(CW\*(C`Family\*(C'\fR, \f(CW\*(C`Type\*(C'\fR and
\&\f(CW\*(C`Proto\*(C'\fR arguments.
.IP "LocalHost => \s-1STRING\s0" 8
.IX Item "LocalHost => STRING"
.PD 0
.IP "LocalService => \s-1STRING\s0" 8
.IX Item "LocalService => STRING"
.PD
Hostname n' steez name fo' tha local address ta \f(CW\*(C`bind()\*(C'\fR to.
.IP "LocalAddr => \s-1STRING\s0" 8
.IX Item "LocalAddr => STRING"
.PD 0
.IP "LocalPort => \s-1STRING\s0" 8
.IX Item "LocalPort => STRING"
.PD
For symmetry wit tha accessor methodz n' compatibilitizzle with
\&\f(CW\*(C`IO::Socket::INET\*(C'\fR, these is accepted as synonyms fo' \f(CW\*(C`LocalHost\*(C'\fR and
\&\f(CW\*(C`LocalService\*(C'\fR respectively.
.IP "LocalAddrInfo => \s-1ARRAY\s0" 8
.IX Item "LocalAddrInfo => ARRAY"
Alternate form of specifyin tha local address ta \f(CW\*(C`bind()\*(C'\fR to. This should be
an array of tha form returned by \f(CW\*(C`Socket::getaddrinfo\*(C'\fR.
.Sp
This parameta takes precedence over tha \f(CW\*(C`Local*\*(C'\fR, \f(CW\*(C`Family\*(C'\fR, \f(CW\*(C`Type\*(C'\fR and
\&\f(CW\*(C`Proto\*(C'\fR arguments.
.IP "Family => \s-1INT\s0" 8
.IX Item "Family => INT"
Da address crew ta pass ta \f(CW\*(C`getaddrinfo\*(C'\fR (e.g. \f(CW\*(C`AF_INET\*(C'\fR, \f(CW\*(C`AF_INET6\*(C'\fR).
Normally dis is ghon be left undefined, n' \f(CW\*(C`getaddrinfo\*(C'\fR will search rockin any
address crew supported by tha system.
.IP "Type => \s-1INT\s0" 8
.IX Item "Type => INT"
Da socket type ta pass ta \f(CW\*(C`getaddrinfo\*(C'\fR (e.g. \f(CW\*(C`SOCK_STREAM\*(C'\fR,
\&\f(CW\*(C`SOCK_DGRAM\*(C'\fR). Normally defined by tha caller; if left undefined
\&\f(CW\*(C`getaddrinfo\*(C'\fR may attempt ta infer tha type from tha steez name.
.IP "Proto => \s-1STRING\s0 or \s-1INT\s0" 8
.IX Item "Proto => STRING or INT"
Da \s-1IP\s0 protocol ta use fo' tha socket (e.g. \f(CW\*(Aqtcp\*(Aq\fR, \f(CW\*(C`IPPROTO_TCP\*(C'\fR,
\&\f(CW\*(Aqudp\*(Aq\fR,\f(CW\*(C`IPPROTO_UDP\*(C'\fR). Normally dis is ghon be left undefined, n' either
\&\f(CW\*(C`getaddrinfo\*(C'\fR or tha kernel will chizzle a appropriate value. May be given
either up in strang name or numeric form.
.IP "GetAddrInfoFlags => \s-1INT\s0" 8
.IX Item "GetAddrInfoFlags => INT"
Mo' flags ta pass ta tha \f(CW\*(C`getaddrinfo()\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch. If not supplied, a
default of \f(CW\*(C`AI_ADDRCONFIG\*(C'\fR is ghon be used.
.Sp
These flags is ghon be combined wit \f(CW\*(C`AI_PASSIVE\*(C'\fR if tha \f(CW\*(C`Listen\*(C'\fR argument is
given. I aint talkin' bout chicken n' gravy biatch. For mo' shiznit peep tha documentation bout \f(CW\*(C`getaddrinfo()\*(C'\fR in
the Socket module.
.IP "Listen => \s-1INT\s0" 8
.IX Item "Listen => INT"
If defined, puts tha socket tha fuck into listenin mode where freshly smoked up connections can be
accepted rockin tha \f(CW\*(C`accept\*(C'\fR method. Y'all KNOW dat shit, muthafucka! Da value given is used as the
\&\f(CWlisten(2)\fR queue size.
.IP "ReuseAddr => \s-1BOOL\s0" 8
.IX Item "ReuseAddr => BOOL"
If true, set tha \f(CW\*(C`SO_REUSEADDR\*(C'\fR sockopt
.IP "ReusePort => \s-1BOOL\s0" 8
.IX Item "ReusePort => BOOL"
If true, set tha \f(CW\*(C`SO_REUSEPORT\*(C'\fR sockopt (not all OSes implement dis sockopt)
.IP "Broadcast => \s-1BOOL\s0" 8
.IX Item "Broadcast => BOOL"
If true, set tha \f(CW\*(C`SO_BROADCAST\*(C'\fR sockopt
.IP "V6Only => \s-1BOOL\s0" 8
.IX Item "V6Only => BOOL"
If defined, set tha \f(CW\*(C`IPV6_V6ONLY\*(C'\fR sockopt when bustin \f(CW\*(C`PF_INET6\*(C'\fR sockets
to tha given value. If true, a listening-mode socket will only listen on the
\&\f(CW\*(C`AF_INET6\*(C'\fR addresses; if false it will also accept connections from
\&\f(CW\*(C`AF_INET\*(C'\fR addresses.
.Sp
If not defined, tha socket option aint gonna be chizzled, n' default value set
by tha operatin system will apply. For repeatable behaviour across platforms
it is recommended dis value always be defined fo' listening-mode sockets.
.Sp
Note dat not all platforms support disablin dis option. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Some, at least
OpenBSD n' MirBSD, will fail wit \f(CW\*(C`EINVAL\*(C'\fR if you attempt ta disable dat shit.
To determine whether it is possible ta disable, you may use tha class method
.Sp
.Vb 6
\& if( IO::Socket::IP\->CAN_DISABLE_V6ONLY ) {
\&    ...
\& }
\& else {
\&    ...
\& }
.Ve
.Sp
If yo' platform do not support disablin dis option but you still want to
listen fo' both \f(CW\*(C`AF_INET\*(C'\fR n' \f(CW\*(C`AF_INET6\*(C'\fR connections yo big-ass booty is ghon gotta create
two listenin sockets, one bound ta each protocol.
.IP "MultiHomed" 8
.IX Item "MultiHomed"
This \f(CW\*(C`IO::Socket::INET\*(C'\fR\-style argument is ignored, except if it is defined
but false. Right back up in yo muthafuckin ass. See tha \f(CW\*(C`IO::Socket::INET\*(C'\fR \s-1INCOMPATIBILITES\s0 section below.
.Sp
But fuck dat shiznit yo, tha word on tha street is dat tha behaviour it enablez be always performed by \f(CW\*(C`IO::Socket::IP\*(C'\fR.
.IP "Blockin => \s-1BOOL\s0" 8
.IX Item "Blockin => BOOL"
If defined but false, tha socket is ghon be set ta non-blockin mode. Otherwise
it will default ta blockin mode. Right back up in yo muthafuckin ass. See tha NON-BLOCKING section below fo' more
detail.
.PP
If neither \f(CW\*(C`Type\*(C'\fR nor \f(CW\*(C`Proto\*(C'\fR hints is provided, a thugged-out default of
\&\f(CW\*(C`SOCK_STREAM\*(C'\fR n' \f(CW\*(C`IPPROTO_TCP\*(C'\fR respectively is ghon be set, ta maintain
compatibilitizzle wit \f(CW\*(C`IO::Socket::INET\*(C'\fR. Other named arguments dat is not
recognised is ignored.
.PP
If neither \f(CW\*(C`Family\*(C'\fR nor any hosts or addresses is passed, nor any
\&\f(CW*AddrInfo\fR, then tha constructor has no shiznit on which ta decizzle a
socket crew ta create. In dis case, it performs a \f(CW\*(C`getaddinfo\*(C'\fR call with
the \f(CW\*(C`AI_ADDRCONFIG\*(C'\fR flag, no host name, n' a steez name of \f(CW"0"\fR, and
uses tha crew of tha straight-up original gangsta returned result.
.PP
If tha constructor fails, it will set \f(CW$@\fR ta a appropriate error message;
this may be from \f(CW$!\fR or it may be some other string; not every last muthafuckin failure
necessarily has a associated \f(CW\*(C`errno\*(C'\fR value.
.ie n .SS "$sock = IO::Socket::IP\->new( $peeraddr )"
.el .SS "\f(CW$sock\fP = IO::Socket::IP\->new( \f(CW$peeraddr\fP )"
.IX Subsection "$sock = IO::Socket::IP->new( $peeraddr )"
As a special case, if tha constructor is passed a single argument (as
opposed ta a even-sized list of key/value pairs), it is taken ta be tha value
of tha \f(CW\*(C`PeerAddr\*(C'\fR parameter n' shit. This is parsed up in tha same way, accordin ta the
behaviour given up in tha \f(CW\*(C`PeerHost\*(C'\fR \s-1AND \s0\f(CW\*(C`LocalHost\*(C'\fR \s-1PARSING\s0 section below.
.SH "METHODS"
.IX Header "METHODS"
As well as tha followin methods, dis class inherits all tha methodz in
IO::Socket n' IO::Handle.
.ie n .SS "( $host, $service ) = $sock\->sockhost_service( $numeric )"
.el .SS "( \f(CW$host\fP, \f(CW$service\fP ) = \f(CW$sock\fP\->sockhost_service( \f(CW$numeric\fP )"
.IX Subsection "( $host, $service ) = $sock->sockhost_service( $numeric )"
Returns tha hostname n' steez name of tha local address (that is, the
socket address given by tha \f(CW\*(C`sockname\*(C'\fR method).
.PP
If \f(CW$numeric\fR is true, these is ghon be given up in numeric form rather than being
resolved tha fuck into names.
.PP
Da followin four convenience wrappers may be used ta obtain one of tha two
values returned here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. If both host n' steez names is required, dis method
is preferable ta tha followin wrappers, cuz it will call
\&\f(CWgetnameinfo(3)\fR only once.
.ie n .SS "$addr = $sock\->sockhost"
.el .SS "\f(CW$addr\fP = \f(CW$sock\fP\->sockhost"
.IX Subsection "$addr = $sock->sockhost"
Return tha numeric form of tha local address as a textual representation
.ie n .SS "$port = $sock\->sockport"
.el .SS "\f(CW$port\fP = \f(CW$sock\fP\->sockport"
.IX Subsection "$port = $sock->sockport"
Return tha numeric form of tha local port number
.ie n .SS "$host = $sock\->sockhostname"
.el .SS "\f(CW$host\fP = \f(CW$sock\fP\->sockhostname"
.IX Subsection "$host = $sock->sockhostname"
Return tha resolved name of tha local address
.ie n .SS "$service = $sock\->sockservice"
.el .SS "\f(CW$service\fP = \f(CW$sock\fP\->sockservice"
.IX Subsection "$service = $sock->sockservice"
Return tha resolved name of tha local port number
.ie n .SS "$addr = $sock\->sockaddr"
.el .SS "\f(CW$addr\fP = \f(CW$sock\fP\->sockaddr"
.IX Subsection "$addr = $sock->sockaddr"
Return tha local address as a funky-ass binary octet string
.ie n .SS "( $host, $service ) = $sock\->peerhost_service( $numeric )"
.el .SS "( \f(CW$host\fP, \f(CW$service\fP ) = \f(CW$sock\fP\->peerhost_service( \f(CW$numeric\fP )"
.IX Subsection "( $host, $service ) = $sock->peerhost_service( $numeric )"
Returns tha hostname n' steez name of tha peer address (that is, the
socket address given by tha \f(CW\*(C`peername\*(C'\fR method), similar ta the
\&\f(CW\*(C`sockhost_service\*(C'\fR method.
.PP
Da followin four convenience wrappers may be used ta obtain one of tha two
values returned here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. If both host n' steez names is required, dis method
is preferable ta tha followin wrappers, cuz it will call
\&\f(CWgetnameinfo(3)\fR only once.
.ie n .SS "$addr = $sock\->peerhost"
.el .SS "\f(CW$addr\fP = \f(CW$sock\fP\->peerhost"
.IX Subsection "$addr = $sock->peerhost"
Return tha numeric form of tha peer address as a textual representation
.ie n .SS "$port = $sock\->peerport"
.el .SS "\f(CW$port\fP = \f(CW$sock\fP\->peerport"
.IX Subsection "$port = $sock->peerport"
Return tha numeric form of tha peer port number
.ie n .SS "$host = $sock\->peerhostname"
.el .SS "\f(CW$host\fP = \f(CW$sock\fP\->peerhostname"
.IX Subsection "$host = $sock->peerhostname"
Return tha resolved name of tha peer address
.ie n .SS "$service = $sock\->peerservice"
.el .SS "\f(CW$service\fP = \f(CW$sock\fP\->peerservice"
.IX Subsection "$service = $sock->peerservice"
Return tha resolved name of tha peer port number
.ie n .SS "$addr = $peer\->peeraddr"
.el .SS "\f(CW$addr\fP = \f(CW$peer\fP\->peeraddr"
.IX Subsection "$addr = $peer->peeraddr"
Return tha peer address as a funky-ass binary octet string
.ie n .SS "$inet = $sock\->as_inet"
.el .SS "\f(CW$inet\fP = \f(CW$sock\fP\->as_inet"
.IX Subsection "$inet = $sock->as_inet"
Returns a freshly smoked up IO::Socket::INET instizzle rappin bout da same filehandle. This
may be useful up in cases where it is required, fo' backward-compatibility, to
have a real object of \f(CW\*(C`IO::Socket::INET\*(C'\fR type instead of \f(CW\*(C`IO::Socket::IP\*(C'\fR.
Da freshly smoked up object will wrap tha same underlyin socket filehandle as the
original, so care should be taken not ta continue ta use both objects
concurrently. Ideally tha original gangsta \f(CW$sock\fR should be discarded afta this
method is called.
.PP
This method checks dat tha socket domain is \f(CW\*(C`PF_INET\*(C'\fR n' will throw an
exception if it aint.
.SH "NON-BLOCKING"
.IX Header "NON-BLOCKING"
If tha constructor is passed a thugged-out defined but false value fo' tha \f(CW\*(C`Blocking\*(C'\fR
argument then tha socket is put tha fuck into non-blockin mode. When up in non-blocking
mode, tha socket aint gonna be set up by tha time tha constructor returns,
because tha underlyin \f(CWconnect(2)\fR syscall would otherwise gotta block.
.PP
Da non-blockin behaviour be a extension of tha \f(CW\*(C`IO::Socket::INET\*(C'\fR \s-1API,\s0
unique ta \f(CW\*(C`IO::Socket::IP\*(C'\fR, cuz tha forma do not support multi-homed
non-blockin connect.
.PP
When rockin non-blockin mode, tha calla must repeatedly check for
writeabilitizzle on tha filehandle (for instizzle rockin \f(CW\*(C`select\*(C'\fR or \f(CW\*(C`IO::Poll\*(C'\fR).
Each time tha filehandle is locked n loaded ta write, tha \f(CW\*(C`connect\*(C'\fR method must be
called, wit no arguments, n' you can put dat on yo' toast. Note dat some operatin systems, most notably
\&\f(CW\*(C`MSWin32\*(C'\fR do not report a \f(CW\*(C`connect()\*(C'\fR failure rockin write-ready; so you must
also \f(CW\*(C`select()\*(C'\fR fo' exceptionizzle status.
.PP
While \f(CW\*(C`connect\*(C'\fR returns false, tha value of \f(CW$!\fR indicates whether it should
be tried again n' again n' again (by bein set ta tha value \f(CW\*(C`EINPROGRESS\*(C'\fR, or \f(CW\*(C`EWOULDBLOCK\*(C'\fR on
MSWin32), or whether a permanent error has occurred (e.g. \f(CW\*(C`ECONNREFUSED\*(C'\fR).
.PP
Once tha socket has been connected ta tha peer, \f(CW\*(C`connect\*(C'\fR will return true
and tha socket will now be locked n loaded ta use.
.PP
Note dat calls ta tha platformz underlyin \f(CWgetaddrinfo(3)\fR function may
block. If \f(CW\*(C`IO::Socket::IP\*(C'\fR has ta big-ass up dis lookup, tha constructor will
block even when up in non-blockin mode.
.PP
To avoid dis blockin behaviour, tha calla should pass up in tha result of such
a lookup rockin tha \f(CW\*(C`PeerAddrInfo\*(C'\fR or \f(CW\*(C`LocalAddrInfo\*(C'\fR arguments, n' you can put dat on yo' toast. This can be
 bigged up  by rockin Net::LibAsyncNS, or tha \f(CWgetaddrinfo(3)\fR function can be
called up in a cold-ass lil lil pimp process.
.PP
.Vb 2
\& use IO::Socket::IP;
\& use Errno qw( EINPROGRESS EWOULDBLOCK );
\&
\& mah @peeraddrinfo = ... # Calla must obtain tha getaddinfo result here
\&
\& mah $socket = IO::Socket::IP\->new(
\&    PeerAddrInfo => \e@peeraddrinfo,
\&    Blockin     => 0,
\& ) or take a thugged-out dirtnap "Cannot construct socket \- $@";
\&
\& while( !$socket\->connect n' ( $! == EINPROGRESS || $! == EWOULDBLOCK ) ) {
\&    mah $wvec = \*(Aq\*(Aq;
\&    vec( $wvec, fileno $socket, 1 ) = 1;
\&    mah $evec = \*(Aq\*(Aq;
\&    vec( $evec, fileno $socket, 1 ) = 1;
\&
\&    select( undef, $wvec, $evec, undef ) or take a thugged-out dirtnap "Cannot select \- $!";
\& }
\&
\& take a thugged-out dirtnap "Cannot connect \- $!" if $!;
\&
\& ...
.Ve
.PP
Da example above uses \f(CW\*(C`select()\*(C'\fR yo, but any similar mechanizzle should work
analogously. \f(CW\*(C`IO::Socket::IP\*(C'\fR takes care when bustin freshly smoked up socket filehandles
to preserve tha actual file descriptor number, so such steez as \f(CW\*(C`poll\*(C'\fR
or \f(CW\*(C`epoll\*(C'\fR should be transparent ta its reallocation of a gangbangin' finger-lickin' different socket
underneath, like up in order ta switch protocol crew between \f(CW\*(C`PF_INET\*(C'\fR and
\&\f(CW\*(C`PF_INET6\*(C'\fR.
.PP
For another example rockin \f(CW\*(C`IO::Poll\*(C'\fR n' \f(CW\*(C`Net::LibAsyncNS\*(C'\fR, peep the
\&\fIexamples/nonblocking_libasyncns.pl\fR file up in tha module distribution.
.ie n .SH """PeerHost"" AND ""LocalHost"" PARSING"
.el .SH "\f(CWPeerHost\fP AND \f(CWLocalHost\fP PARSING"
.IX Header "PeerHost AND LocalHost PARSING"
To support tha \f(CW\*(C`IO::Socket::INET\*(C'\fR \s-1API,\s0 tha host n' port shiznit may be
passed up in a single strang rather than as two separate arguments.
.PP
If either \f(CW\*(C`LocalHost\*(C'\fR or \f(CW\*(C`PeerHost\*(C'\fR (or they \f(CW\*(C`...Addr\*(C'\fR synonyms) have any
of tha followin special forms then special parsin be applied.
.PP
Da value of tha \f(CW\*(C`...Host\*(C'\fR argument is ghon be split ta give both tha hostname
and port (or steez name):
.PP
.Vb 3
\& hostname.example.org:http    # Host name
\& 192.0.2.1:80                 # IPv4 address
\& [2001:db8::1]:80             # IPv6 address
.Ve
.PP
In each case, tha port or steez name (e.g. \f(CW80\fR) is passed as the
\&\f(CW\*(C`LocalService\*(C'\fR or \f(CW\*(C`PeerService\*(C'\fR argument.
.PP
Either of \f(CW\*(C`LocalService\*(C'\fR or \f(CW\*(C`PeerService\*(C'\fR (or they \f(CW\*(C`...Port\*(C'\fR synonyms) can
be either a steez name, a thugged-out decimal number, or a strang containin both a
service name n' number, up in a gangbangin' form such as
.PP
.Vb 1
\& http(80)
.Ve
.PP
In dis case, tha name (\f(CW\*(C`http\*(C'\fR) is ghon be tried first yo, but if tha resolver do
not KNOW it then tha port number (\f(CW80\fR) is ghon be used instead.
.PP
If tha \f(CW\*(C`...Host\*(C'\fR argument is up in dis special form n' tha corresponding
\&\f(CW\*(C`...Service\*(C'\fR or \f(CW\*(C`...Port\*(C'\fR argument be also defined, tha one parsed from
the \f(CW\*(C`...Host\*(C'\fR argument will take precedence n' tha other is ghon be ignored.
.ie n .SS "( $host, $port ) = IO::Socket::IP\->split_addr( $addr )"
.el .SS "( \f(CW$host\fP, \f(CW$port\fP ) = IO::Socket::IP\->split_addr( \f(CW$addr\fP )"
.IX Subsection "( $host, $port ) = IO::Socket::IP->split_addr( $addr )"
Utilitizzle method dat serves up tha parsin functionalitizzle busted lyrics bout above.
Returns a 2\-element list, containin either tha split hostname n' port
description if it could be parsed, or tha given address n' \f(CW\*(C`undef\*(C'\fR if it was
not recognised.
.PP
.Vb 2
\& IO::Socket::IP\->split_addr( "hostname:http" )
\&                              # ( "hostname",  "http" )
\&
\& IO::Socket::IP\->split_addr( "192.0.2.1:80" )
\&                              # ( "192.0.2.1", "80"   )
\&
\& IO::Socket::IP\->split_addr( "[2001:db8::1]:80" )
\&                              # ( "2001:db8::1", "80" )
\&
\& IO::Socket::IP\->split_addr( "something.else" )
\&                              # ( "something.else", undef )
.Ve
.ie n .SS "$addr = IO::Socket::IP\->join_addr( $host, $port )"
.el .SS "\f(CW$addr\fP = IO::Socket::IP\->join_addr( \f(CW$host\fP, \f(CW$port\fP )"
.IX Subsection "$addr = IO::Socket::IP->join_addr( $host, $port )"
Utilitizzle method dat performs tha reverse of \f(CW\*(C`split_addr\*(C'\fR, returnin a string
formed by joinin tha specified host address n' port number n' shit. Da host address
will be wrapped up in \f(CW\*(C`[]\*(C'\fR brackets if required (because it aint nuthin but a raw IPv6
numeric address).
.PP
This can be especially useful when combined wit tha \f(CW\*(C`sockhost_service\*(C'\fR or
\&\f(CW\*(C`peerhost_service\*(C'\fR methods.
.PP
.Vb 1
\& say "Connected ta ", IO::Socket::IP\->join_addr( $sock\->peerhost_service );
.Ve
.ie n .SH """IO::Socket::INET"" INCOMPATIBILITES"
.el .SH "\f(CWIO::Socket::INET\fP INCOMPATIBILITES"
.IX Header "IO::Socket::INET INCOMPATIBILITES"
.IP "\(bu" 4
Da behaviour enabled by \f(CW\*(C`MultiHomed\*(C'\fR is up in fact implemented by
\&\f(CW\*(C`IO::Socket::IP\*(C'\fR as it is required ta erectly support searchin fo' a
useable address from tha thangs up in dis biatch of tha \f(CWgetaddrinfo(3)\fR call. The
constructor will ignore tha value of dis argument, except if it is defined
but false fo' realz. An exception is thrown up in dis case, cuz dat would request it
disable tha \f(CWgetaddrinfo(3)\fR search behaviour up in tha straight-up original gangsta place.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Investigate whether \f(CW\*(C`POSIX::dup2\*(C'\fR upsets \s-1BSD\s0z \f(CW\*(C`kqueue\*(C'\fR watchers, n' if so,
consider what tha fuck possible workaroundz might be applied.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pizzle Evans <leonerd@leonerd.org.uk>
