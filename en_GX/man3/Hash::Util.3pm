.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hash::Util 3pm"
.TH Hash::Util 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hash::Util \- A selection of general\-utilitizzle hash subroutines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # Restricted hashes
\&
\&  use Hash::Util qw(
\&                     fieldhash fieldhashes
\&
\&                     all_keys
\&                     lock_keys unlock_keys
\&                     lock_value unlock_value
\&                     lock_hash unlock_hash
\&                     lock_keys_plus
\&                     hash_locked hash_unlocked
\&                     hashref_locked hashref_unlocked
\&                     hidden_keys legal_keys
\&
\&                     lock_ref_keys unlock_ref_keys
\&                     lock_ref_value unlock_ref_value
\&                     lock_hashref unlock_hashref
\&                     lock_ref_keys_plus
\&                     hidden_ref_keys legal_ref_keys
\&
\&                     hash_seed hash_value hv_store
\&                     bucket_stats bucket_info bucket_array
\&                     lock_hash_recurse unlock_hash_recurse
\&
\&                     hash_traversal_mask
\&                   );
\&
\&  %hash = (foo => 42, bar => 23);
\&  # Ways ta restrict a hash
\&  lock_keys(%hash);
\&  lock_keys(%hash, @keyset);
\&  lock_keys_plus(%hash, @additional_keys);
\&
\&  # Ways ta inspect tha propertizzlez of a restricted hash
\&  mah @legal = legal_keys(%hash);
\&  mah @hidden = hidden_keys(%hash);
\&  mah $ref = all_keys(%hash,@keys,@hidden);
\&  mah $is_locked = hash_locked(%hash);
\&
\&  # Remove restrictions on tha hash
\&  unlock_keys(%hash);
\&
\&  # Lock individual joints up in a hash
\&  lock_value  (%hash, \*(Aqfoo\*(Aq);
\&  unlock_value(%hash, \*(Aqfoo\*(Aq);
\&
\&  # Ways ta chizzle tha restrictions on both keys n' joints
\&  lock_hash  (%hash);
\&  unlock_hash(%hash);
\&
\&  mah $hashes_are_randomised = hash_seed() != 0;
\&
\&  mah $int_hash_value = hash_value( \*(Aqstring\*(Aq );
\&
\&  mah $mask= hash_traversal_mask(%hash);
\&
\&  hash_traversal_mask(%hash,1234);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Hash::Util\*(C'\fR n' \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR contain special functions
for manipulatin hashes dat don't straight-up warrant a keyword.
.PP
\&\f(CW\*(C`Hash::Util\*(C'\fR gotz nuff a set of functions dat support
restricted hashes. These is busted lyrics bout in
this document.  \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR gotz nuff a (unrelated)
set of functions dat support tha use of hashes in
\&\fIinside-out classes\fR, busted lyrics bout up in Hash::Util::FieldHash.
.PP
By default \f(CW\*(C`Hash::Util\*(C'\fR do not export anything.
.SS "Restricted hashes"
.IX Subsection "Restricted hashes"
5.8.0 introduces tha mobilitizzle ta restrict a hash ta a cold-ass lil certain set of
keys.  No keys outside of dis set can be added. Y'all KNOW dat shit, muthafucka!  It also introduces
the mobilitizzle ta lock a individual key so it cannot be deleted n' the
abilitizzle ta ensure dat a individual value cannot be chizzled.
.PP
This is intended ta largely replace tha deprecated pseudo-hashes.
.IP "\fBlock_keys\fR" 4
.IX Item "lock_keys"
.PD 0
.IP "\fBunlock_keys\fR" 4
.IX Item "unlock_keys"
.PD
.Vb 2
\&  lock_keys(%hash);
\&  lock_keys(%hash, @keys);
.Ve
.Sp
Restricts tha given \f(CW%hash\fRz set of keys ta \f(CW@keys\fR.  If \f(CW@keys\fR is not
given it restricts it ta its current keyset.  No mo' keys can be
added. Y'all KNOW dat shit, muthafucka! \fIdelete()\fR n' \fIexists()\fR will still work yo, but aint gonna alter
the set of allowed keys. \fBNote\fR: tha current implementation prevents
the hash from bein \fIbless()\fRed while it is up in a locked state fo' realz. Any attempt
to do so will raise a exception. I aint talkin' bout chicken n' gravy biatch. Of course you can still \fIbless()\fR
the hash before you call \fIlock_keys()\fR so dis shouldn't be a problem.
.Sp
.Vb 1
\&  unlock_keys(%hash);
.Ve
.Sp
Removes tha restriction on tha \f(CW%hash\fRz keyset.
.Sp
\&\fBNote\fR dat if any of tha jointz of tha hash done been locked they will not
be unlocked afta dis sub executes.
.Sp
Both routines return a reference ta tha hash operated on.
.IP "\fBlock_keys_plus\fR" 4
.IX Item "lock_keys_plus"
.Vb 1
\&  lock_keys_plus(%hash,@additional_keys)
.Ve
.Sp
Similar ta \f(CW\*(C`lock_keys()\*(C'\fR, wit tha difference bein dat tha optionizzle key list
specifies keys dat may or may not be already up in tha hash. Essentially dis is
an easier way ta say
.Sp
.Vb 1
\&  lock_keys(%hash,@additional_keys,keys %hash);
.Ve
.Sp
Returns a reference ta \f(CW%hash\fR
.IP "\fBlock_value\fR" 4
.IX Item "lock_value"
.PD 0
.IP "\fBunlock_value\fR" 4
.IX Item "unlock_value"
.PD
.Vb 2
\&  lock_value  (%hash, $key);
\&  unlock_value(%hash, $key);
.Ve
.Sp
Locks n' unlocks tha value fo' a individual key of a hash.  Da value of a
locked key cannot be chizzled.
.Sp
Unless \f(CW%hash\fR has already been locked tha key/value could be deleted
regardless of dis setting.
.Sp
Returns a reference ta tha \f(CW%hash\fR.
.IP "\fBlock_hash\fR" 4
.IX Item "lock_hash"
.PD 0
.IP "\fBunlock_hash\fR" 4
.IX Item "unlock_hash"
.PD
.Vb 1
\&    lock_hash(%hash);
.Ve
.Sp
\&\fIlock_hash()\fR locks a entire hash, makin all keys n' joints read-only.
No value can be chizzled, no keys can be added or deleted.
.Sp
.Vb 1
\&    unlock_hash(%hash);
.Ve
.Sp
\&\fIunlock_hash()\fR do tha opposite of \fIlock_hash()\fR.  All keys n' joints
are made writable.  All joints can be chizzled n' keys can be added
and deleted.
.Sp
Returns a reference ta tha \f(CW%hash\fR.
.IP "\fBlock_hash_recurse\fR" 4
.IX Item "lock_hash_recurse"
.PD 0
.IP "\fBunlock_hash_recurse\fR" 4
.IX Item "unlock_hash_recurse"
.PD
.Vb 1
\&    lock_hash_recurse(%hash);
.Ve
.Sp
\&\fIlock_hash()\fR locks a entire hash n' any hashes it references recursively,
makin all keys n' joints read-only. No value can be chizzled, no keys can
be added or deleted.
.Sp
This method \fBonly\fR recurses tha fuck into hashes dat is referenced by another hash.
Thus a Hash of Hashes (HoH) will all be restricted yo, but a Hash of Arrays of
Hashes (HoAoH) will only have tha top hash restricted.
.Sp
.Vb 1
\&    unlock_hash_recurse(%hash);
.Ve
.Sp
\&\fIunlock_hash_recurse()\fR do tha opposite of \fIlock_hash_recurse()\fR.  All keys and
values is made writable.  All joints can be chizzled n' keys can be added
and deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Identical recursion restrictions apply as ta \fIlock_hash_recurse()\fR.
.Sp
Returns a reference ta tha \f(CW%hash\fR.
.IP "\fBhashref_locked\fR" 4
.IX Item "hashref_locked"
.PD 0
.IP "\fBhash_locked\fR" 4
.IX Item "hash_locked"
.PD
.Vb 2
\&  hashref_locked(\e%hash) n' print "Hash is locked!\en";
\&  hash_locked(%hash) n' print "Hash is locked!\en";
.Ve
.Sp
Returns legit if tha hash n' its keys is locked.
.IP "\fBhashref_unlocked\fR" 4
.IX Item "hashref_unlocked"
.PD 0
.IP "\fBhash_unlocked\fR" 4
.IX Item "hash_unlocked"
.PD
.Vb 2
\&  hashref_unlocked(\e%hash) n' print "Hash is unlocked!\en";
\&  hash_unlocked(%hash) n' print "Hash is unlocked!\en";
.Ve
.Sp
Returns legit if tha hash n' its keys is unlocked.
.IP "\fBlegal_keys\fR" 4
.IX Item "legal_keys"
.Vb 1
\&  mah @keys = legal_keys(%hash);
.Ve
.Sp
Returns tha list of tha keys dat is legal up in a restricted hash.
In tha case of a unrestricted hash dis is identical ta calling
keys(%hash).
.IP "\fBhidden_keys\fR" 4
.IX Item "hidden_keys"
.Vb 1
\&  mah @keys = hidden_keys(%hash);
.Ve
.Sp
Returns tha list of tha keys dat is legal up in a restricted hash but
do not gotz a value associated ta em. Thus if 'foo' be a
\&\*(L"hidden\*(R" key of tha \f(CW%hash\fR it will return false fo' both \f(CW\*(C`defined\*(C'\fR
and \f(CW\*(C`exists\*(C'\fR tests.
.Sp
In tha case of a unrestricted hash dis will return a empty list.
.Sp
\&\fB\s-1NOTE\s0\fR dis be a experimenstrual feature dat is heavily dependent
on tha current implementation of restricted hashes. Right back up in yo muthafuckin ass. Should the
implementation chizzle, dis routine may become meaningless, up in which
case it will return a empty list.
.IP "\fBall_keys\fR" 4
.IX Item "all_keys"
.Vb 1
\&  all_keys(%hash,@keys,@hidden);
.Ve
.Sp
Populates tha arrays \f(CW@keys\fR wit tha all tha keys dat would pass
an \f(CW\*(C`exists\*(C'\fR tests, n' populates \f(CW@hidden\fR wit tha remainin legal
keys dat aint been utilized.
.Sp
Returns a reference ta tha hash.
.Sp
In tha case of a unrestricted hash dis is ghon be equivalent to
.Sp
.Vb 5
\&  $ref = do {
\&      @keys = keys %hash;
\&      @hidden = ();
\&      \e%hash
\&  };
.Ve
.Sp
\&\fB\s-1NOTE\s0\fR dis be a experimenstrual feature dat is heavily dependent
on tha current implementation of restricted hashes. Right back up in yo muthafuckin ass. Should the
implementation chizzle dis routine may become meaningless up in which
case it will behave identically ta how tha fuck it would behave on an
unrestricted hash.
.IP "\fBhash_seed\fR" 4
.IX Item "hash_seed"
.Vb 1
\&    mah $hash_seed = hash_seed();
.Ve
.Sp
\&\fIhash_seed()\fR returns tha seed bytes used ta randomise hash ordering.
.Sp
\&\fBNote dat tha hash seed is sensitizzle shiznit\fR: by knowin it one
can craft a thugged-out denial-of-service battle against Perl code, even remotely,
see \*(L"Algorithmic Complexitizzle Attacks\*(R" up in perlsec fo' mo' shiznit.
\&\fBDo not disclose tha hash seed\fR ta playas whoz ass don't need ta know dat shit.
See also \*(L"\s-1PERL_HASH_SEED_DEBUG\*(R"\s0 up in perlrun.
.Sp
Prior ta Perl 5.17.6 dis function returned a \s-1UV,\s0 it now returns a string,
which may be of nearly any size as determined by tha hash function your
Perl has been built with. Possible sizes may be but is not limited to
4 bytes (for most hash algorithms) n' 16 bytes (for siphash).
.IP "\fBhash_value\fR" 4
.IX Item "hash_value"
.Vb 1
\&    mah $hash_value = hash_value($string);
.Ve
.Sp
\&\fIhash_value()\fR returns tha current perlz internal hash value fo' a given
string.
.Sp
Returns a 32 bit integer representin tha hash value of tha strang passed
in. I aint talkin' bout chicken n' gravy biatch. This value is only reliable fo' tha gametime of tha process. Well shiiiit, it may
be different dependin on invocation, environment variables,  perl version,
architectures, n' build options.
.Sp
\&\fBNote dat tha hash value of a given strang is sensitizzle shiznit\fR:
by knowin it one can deduce tha hash seed which up in turn can allow one to
craft a thugged-out denial-of-service battle against Perl code, even remotely,
see \*(L"Algorithmic Complexitizzle Attacks\*(R" up in perlsec fo' mo' shiznit.
\&\fBDo not disclose tha hash value of a string\fR ta playas whoz ass don't need to
know dat shit. Right back up in yo muthafuckin ass. See also \*(L"\s-1PERL_HASH_SEED_DEBUG\*(R"\s0 up in perlrun.
.IP "\fBbucket_info\fR" 4
.IX Item "bucket_info"
Return a set of basic shiznit on some hash.
.Sp
.Vb 1
\&    mah ($keys, $buckets, $used, @length_counts)= bucket_info($hash);
.Ve
.Sp
Fieldz is as bigs up:
.Sp
.Vb 5
\&    0: Number of keys up in tha hash
\&    1: Number of buckets up in tha hash
\&    2: Number of used buckets up in tha hash
\&    rest : list of counts, Kth element is tha number of buckets
\&           wit K keys up in dat shit.
.Ve
.Sp
See also \fIbucket_stats()\fR n' \fIbucket_array()\fR.
.IP "\fBbucket_stats\fR" 4
.IX Item "bucket_stats"
Returns a list of statistics on some hash.
.Sp
.Vb 2
\&    mah ($keys, buckets, $used, $utilization_ratio, $collision_pct,
\&        $mean, $stddev, @length_counts) = bucket_info($hashref);
.Ve
.Sp
Fieldz is as bigs up:
.Sp
.Vb 10
\&    0: Number of keys up in tha hash
\&    1: Number of buckets up in tha hash
\&    2: Number of used buckets up in tha hash
\&    3: Hash Qualitizzle Score
\&    4: Cement of buckets used
\&    5: Cement of keys which is up in collision
\&    6: Average bucket length
\&    7: Standard Deviation of bucket lengths.
\&    rest : list of counts, Kth element is tha number of buckets
\&           wit K keys up in dat shit.
.Ve
.Sp
See also \fIbucket_info()\fR n' \fIbucket_array()\fR.
.Sp
Note dat Hash Qualitizzle Score would be 1 fo' a ideal hash, numbers
close ta n' below 1 indicate phat hashing, n' number significantly
above indicate a skanky score. In practice it should be round 0.95 ta 1.05.
It be defined as:
.Sp
.Vb 4
\& $score= sum( $count[$length] * ($length * ($length + 1) / 2) )
\&            /
\&            ( ( $keys / 2 * $buckets ) *
\&              ( $keys + ( 2 * $buckets ) \- 1 ) )
.Ve
.Sp
Da formula is from tha Red Dragon book (reformulated ta use tha data available)
and is documented at <http://www.strchr.com/hash_functions>
.IP "\fBbucket_array\fR" 4
.IX Item "bucket_array"
.Vb 1
\&    mah $array= bucket_array(\e%hash);
.Ve
.Sp
Returns a packed representation of tha bucket array associated wit a hash. Each element
of tha array is either a integer K, up in which case it represents K empty buckets, or
a reference ta another array which gotz nuff tha keys dat is up in dat bucket.
.Sp
\&\fBNote dat tha shiznit returned by bucket_array is sensitizzle shiznit\fR:
by knowin it one can directly battle perlz hash function which up in turn may allow
one ta craft a thugged-out denial-of-service battle against Perl code, even remotely,
see \*(L"Algorithmic Complexitizzle Attacks\*(R" up in perlsec fo' mo' shiznit.
\&\fBDo not disclose tha output of dis function\fR ta playas whoz ass don't need to
know dat shit. Right back up in yo muthafuckin ass. See also \*(L"\s-1PERL_HASH_SEED_DEBUG\*(R"\s0 up in perlrun. I aint talkin' bout chicken n' gravy biatch. This function is provided strictly
for  debuggin n' diagnostics purposes only, it is hard ta imagine a reason why it
would be used up in thang code.
.IP "\fBhv_store\fR" 4
.IX Item "hv_store"
.Vb 4
\&  mah $sv = 0;
\&  hv_store(%hash,$key,$sv) or take a thugged-out dirtnap "Failed ta alias!";
\&  $hash{$key} = 1;
\&  print $sv; # prints 1
.Ve
.Sp
Stores a alias ta a variable up in a hash instead of copyin tha value.
.IP "\fBhash_traversal_mask\fR" 4
.IX Item "hash_traversal_mask"
Az of Perl 5.18 every last muthafuckin hash has its own hash traversal order, n' dis order
changes every last muthafuckin time a freshly smoked up element is banged tha fuck into tha hash. This functionality
is provided by maintainin a unsigned integer mask (U32) which is xor'ed
with tha actual bucket id durin a traversal of tha hash buckets rockin \fIkeys()\fR,
\&\fIvalues()\fR or \fIeach()\fR.
.Sp
Yo ass can use dis subroutine ta git n' set tha traversal mask fo' a specific
hash. Right back up in yo muthafuckin ass. Settin tha mask ensures dat a given hash will produce tha same key
order n' shit. \fBNote\fR dat dis do \fBnot\fR guarantee dat \fBtwo\fR hashes will produce
the same key order fo' tha same hash seed n' traversal mask, shit that
collide tha fuck into one bucket may have different ordaz regardless of dis setting.
.SS "Operatin on references ta hashes."
.IX Subsection "Operatin on references ta hashes."
Most subroutines documented up in dis module have equivalent versions
that operate on references ta hashes instead of natizzle hashes.
Da followin be a list of these subs. They is identical except
in name n' up in dat instead of takin a \f(CW%hash\fR they take a \f(CW$hashref\fR,
and additionally is not prototyped.
.IP "lock_ref_keys" 4
.IX Item "lock_ref_keys"
.PD 0
.IP "unlock_ref_keys" 4
.IX Item "unlock_ref_keys"
.IP "lock_ref_keys_plus" 4
.IX Item "lock_ref_keys_plus"
.IP "lock_ref_value" 4
.IX Item "lock_ref_value"
.IP "unlock_ref_value" 4
.IX Item "unlock_ref_value"
.IP "lock_hashref" 4
.IX Item "lock_hashref"
.IP "unlock_hashref" 4
.IX Item "unlock_hashref"
.IP "lock_hashref_recurse" 4
.IX Item "lock_hashref_recurse"
.IP "unlock_hashref_recurse" 4
.IX Item "unlock_hashref_recurse"
.IP "hash_ref_unlocked" 4
.IX Item "hash_ref_unlocked"
.IP "legal_ref_keys" 4
.IX Item "legal_ref_keys"
.IP "hidden_ref_keys" 4
.IX Item "hidden_ref_keys"
.PD
.SH "CAVEATS"
.IX Header "CAVEATS"
Note dat tha trappin of tha restricted operations aint atomic:
for example
.PP
.Vb 1
\&    eval { %hash = (illegal_key => 1) }
.Ve
.PP
leaves tha \f(CW%hash\fR empty rather than wit its original gangsta contents.
.SH "BUGS"
.IX Header "BUGS"
Da intercourse exposed by dis module is straight-up close ta tha current
implementation of restricted hashes. Over time it is expected that
this behavior is ghon be extended n' tha intercourse abstracted further.
.SH "AUTHOR"
.IX Header "AUTHOR"
Mike G Schwern <schwern@pobox.com> on top of code by Nick
Ing-Simmons n' Jeffrey Friedl.
.PP
\&\fIhv_store()\fR is from Array::RefElem, Copyright 2000 Gisle Aas.
.PP
Additionizzle code by Yves Orton.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Scalar::Util, List::Util n' \*(L"Algorithmic Complexitizzle Attacks\*(R" up in perlsec.
.PP
Hash::Util::FieldHash.
