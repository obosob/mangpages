.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Memoize 3pm"
.TH Memoize 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Memoize \- Make functions fasta by tradin space fo' time
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&        # This is tha documentation fo' Memoize 1.03
\&        use Memoize;
\&        memoize(\*(Aqslow_function\*(Aq);
\&        slow_function(arguments);    # Is fasta than dat shiznit was before
.Ve
.PP
This is normally all you need ta know.  But fuck dat shiznit yo, tha word on tha street is dat nuff options is available:
.PP
.Vb 1
\&        memoize(function, options...);
.Ve
.PP
Options include:
.PP
.Vb 2
\&        NORMALIZER => function
\&        INSTALL => new_name
\&
\&        SCALAR_CACHE => \*(AqMEMORY\*(Aq
\&        SCALAR_CACHE => [\*(AqHASH\*(Aq, \e%cache_hash ]
\&        SCALAR_CACHE => \*(AqFAULT\*(Aq
\&        SCALAR_CACHE => \*(AqMERGE\*(Aq
\&
\&        LIST_CACHE => \*(AqMEMORY\*(Aq
\&        LIST_CACHE => [\*(AqHASH\*(Aq, \e%cache_hash ]
\&        LIST_CACHE => \*(AqFAULT\*(Aq
\&        LIST_CACHE => \*(AqMERGE\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
`Memoizing' a gangbangin' function make it fasta by tradin space fo' time.  It
does dis by cachin tha return jointz of tha function up in a table.
If you call tha function again n' again n' again wit tha same arguments, \f(CW\*(C`memoize\*(C'\fR
jumps up in n' gives you tha value outta tha table, instead of letting
the function compute tha value all over again.
.PP
Here be a off tha hook example.  Consider tha Fibonacci sequence, defined
by tha followin function:
.PP
.Vb 6
\&        # Compute Fibonacci numbers
\&        sub fib {
\&          mah $n = shift;
\&          return $n if $n < 2;
\&          fib($n\-1) + fib($n\-2);
\&        }
.Ve
.PP
This function is straight-up slow.  Why, biatch?  To compute fib(14), it first wants
to compute fib(13) n' fib(12), n' add tha thangs up in dis biatch.  But ta compute
fib(13), it first has ta compute fib(12) n' fib(11), n' then it
comes back n' computes fib(12) all over again n' again n' again even though tha answer
is tha same.  And both of tha times dat it wants ta compute fib(12),
it has ta compute fib(11) from scratch, n' then it has ta do it
again each time it wants ta compute fib(13).  This function do so
much recomputin of oldschool thangs up in dis biatch dat it takes a straight-up long time to
run\-\-\-fib(14) make 1,200 extra recursive calls ta itself, ta compute
and recompute thangs dat it already computed.
.PP
This function be a phat muthafucka fo' memoization. I aint talkin' bout chicken n' gravy biatch.  If you memoize the
`fib' function above, it will compute fib(14) exactly once, tha first
time it needz to, n' then save tha result up in a table.  Then if you
ask fo' fib(14) again, it gives you tha result outta tha table.
While computin fib(14), instead of computin fib(12) twice, it do
it once; tha second time it needz tha value it gets it from tha table.
It don't compute fib(11) four times; it computes it once, gettin it
from tha table tha next three times.  Instead of makin 1,200
recursive calls ta `fib', it make 15.  This make tha function about
150 times faster.
.PP
Yo ass could do tha memoization yo ass, by rewritin tha function, like
this:
.PP
.Vb 9
\&        # Compute Fibonacci numbers, memoized version
\&        { mah @fib;
\&          sub fib {
\&            mah $n = shift;
\&            return $fib[$n] if defined $fib[$n];
\&            return $fib[$n] = $n if $n < 2;
\&            $fib[$n] = fib($n\-1) + fib($n\-2);
\&          }
\&        }
.Ve
.PP
Or you could use dis module, like this:
.PP
.Vb 2
\&        use Memoize;
\&        memoize(\*(Aqfib\*(Aq);
\&
\&        # Rest of tha fib function just like tha original gangsta version.
.Ve
.PP
This make it easy as fuck  ta turn memoizin on n' off.
.PP
Herez a even simpla example: I freestyled a simple ray tracer; the
program would look up in a cold-ass lil certain direction, figure up what tha fuck it was
lookin at, n' then convert tha `color' value (typically a string
like `red') of dat object ta a red, green, n' blue pixel value, like
this:
.PP
.Vb 6
\&    fo' ($direction = 0; $direction < 300; $direction++) {
\&      # Figure up which object is up in direction $direction
\&      $color = $object\->{color};
\&      ($r, $g, $b) = @{&ColorToRGB($color)};
\&      ...
\&    }
.Ve
.PP
Since there be relatively few objects up in a picture, there be only a
few colors, which git looked up over n' over again. I aint talkin' bout chicken n' gravy biatch.  Memoizing
\&\f(CW\*(C`ColorToRGB\*(C'\fR sped up tha program by nuff muthafuckin cement.
.SH "DETAILS"
.IX Header "DETAILS"
This module exports exactly one function, \f(CW\*(C`memoize\*(C'\fR.  Da rest of the
functions up in dis package is None of Yo crazy-ass Business.
.PP
Yo ass should say
.PP
.Vb 1
\&        memoize(function)
.Ve
.PP
where \f(CW\*(C`function\*(C'\fR is tha name of tha function you wanna memoize, or
a reference ta dat shit.  \f(CW\*(C`memoize\*(C'\fR returns a reference ta tha new,
memoized version of tha function, or \f(CW\*(C`undef\*(C'\fR on a non-fatal error.
At present, there be no non-fatal errors yo, but there might be some in
the future.
.PP
If \f(CW\*(C`function\*(C'\fR was tha name of a gangbangin' function, then \f(CW\*(C`memoize\*(C'\fR hides the
old version n' installs tha freshly smoked up memoized version under tha oldschool name,
so dat \f(CW\*(C`&function(...)\*(C'\fR straight-up invokes tha memoized version.
.SH "OPTIONS"
.IX Header "OPTIONS"
There is some optionizzle options you can pass ta \f(CW\*(C`memoize\*(C'\fR ta chizzle
the way it behaves a lil.  To supply options, invoke \f(CW\*(C`memoize\*(C'\fR
like this:
.PP
.Vb 5
\&        memoize(function, NORMALIZER => function,
\&                          INSTALL => newname,
\&                          SCALAR_CACHE => option,
\&                          LIST_CACHE => option
\&                         );
.Ve
.PP
Each of these options is optional; you can include some, all, or none
of em.
.SS "\s-1INSTALL\s0"
.IX Subsection "INSTALL"
If you supply a gangbangin' function name wit \f(CW\*(C`INSTALL\*(C'\fR, memoize will install
the new, memoized version of tha function under tha name you give.
For example,
.PP
.Vb 1
\&        memoize(\*(Aqfib\*(Aq, INSTALL => \*(Aqfastfib\*(Aq)
.Ve
.PP
installs tha memoized version of \f(CW\*(C`fib\*(C'\fR as \f(CW\*(C`fastfib\*(C'\fR; without the
\&\f(CW\*(C`INSTALL\*(C'\fR option it would have replaced tha oldschool \f(CW\*(C`fib\*(C'\fR wit the
memoized version.
.PP
To prevent \f(CW\*(C`memoize\*(C'\fR from installin tha memoized version anywhere, use
\&\f(CW\*(C`INSTALL => undef\*(C'\fR.
.SS "\s-1NORMALIZER\s0"
.IX Subsection "NORMALIZER"
Suppose yo' function be lookin like this:
.PP
.Vb 6
\&        # Typical call: f(\*(Aqaha!\*(Aq, A => 11, B => 12);
\&        sub f {
\&          mah $a = shift;
\&          mah %hash = @_;
\&          $hash{B} ||= 2;  # B defaults ta 2
\&          $hash{C} ||= 7;  # C defaults ta 7
\&
\&          # Do suttin' wit $a, %hash
\&        }
.Ve
.PP
Now, tha followin calls ta yo' function is all straight-up equivalent:
.PP
.Vb 6
\&        f(OUCH);
\&        f(OUCH, B => 2);
\&        f(OUCH, C => 7);
\&        f(OUCH, B => 2, C => 7);
\&        f(OUCH, C => 7, B => 2);
\&        (etc.)
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat unless you tell \f(CW\*(C`Memoize\*(C'\fR dat these calls is equivalent,
it aint gonna know that, n' it will compute tha joints fo' these
invocationz of yo' function separately, n' store dem separately.
.PP
To prevent this, supply a \f(CW\*(C`NORMALIZER\*(C'\fR function dat turns the
program arguments tha fuck into a strang up in a way dat equivalent arguments
turn tha fuck into tha same string.  A \f(CW\*(C`NORMALIZER\*(C'\fR function fo' \f(CW\*(C`f\*(C'\fR above
might be lookin like this:
.PP
.Vb 5
\&        sub normalize_f {
\&          mah $a = shift;
\&          mah %hash = @_;
\&          $hash{B} ||= 2;
\&          $hash{C} ||= 7;
\&
\&          join(\*(Aq,\*(Aq, $a, map ($_ => $hash{$_}) sort keys %hash);
\&        }
.Ve
.PP
Each of tha argument lists above comes outta tha \f(CW\*(C`normalize_f\*(C'\fR
function lookin exactly tha same, like this:
.PP
.Vb 1
\&        OUCH,B,2,C,7
.Ve
.PP
Yo ass would tell \f(CW\*(C`Memoize\*(C'\fR ta use dis normalizer dis way:
.PP
.Vb 1
\&        memoize(\*(Aqf\*(Aq, NORMALIZER => \*(Aqnormalize_f\*(Aq);
.Ve
.PP
\&\f(CW\*(C`memoize\*(C'\fR knows dat if tha normalized version of tha arguments is
the same fo' two argument lists, then it can safely look up tha value
that it computed fo' one argument list n' return it as tha result of
callin tha function wit tha other argument list, even if the
argument lists look different.
.PP
Da default normalizer just concatenates tha arguments wit character
28 up in between. I aint talkin' bout chicken n' gravy biatch.  (In \s-1ASCII,\s0 dis is called \s-1FS\s0 or control\-\e.)  This
always works erectly fo' functions wit only one strang argument,
and also when tha arguments never contain characta 28.  But fuck dat shiznit yo, tha word on tha street is dat it
can confuse certain argument lists:
.PP
.Vb 3
\&        normalizer("a\e034", "b")
\&        normalizer("a", "\e034b")
\&        normalizer("a\e034\e034b")
.Ve
.PP
for example.
.PP
Since hash keys is strings, tha default normalizer will not
distinguish between \f(CW\*(C`undef\*(C'\fR n' tha empty string.  It also won't work
when tha functionz arguments is references.  For example, consider a
function \f(CW\*(C`g\*(C'\fR which gets two arguments: A number, n' a reference to
an array of numbers:
.PP
.Vb 1
\&        g(13, [1,2,3,4,5,6,7]);
.Ve
.PP
Da default normalizer will turn dis tha fuck into suttin' like
\&\f(CW"13\e034ARRAY(0x436c1f)"\fR.  That would be all right, except dat a
subsequent array of numbers might be stored at a gangbangin' finger-lickin' different location
even though it gotz nuff tha same ol' dirty data.  If dis happens, \f(CW\*(C`Memoize\*(C'\fR
will be thinkin dat tha arguments is different, even though they are
equivalent.  In dis case, a normalizer like dis be appropriate:
.PP
.Vb 1
\&        sub normalize { join \*(Aq \*(Aq, $_[0], @{$_[1]} }
.Ve
.PP
For tha example above, dis produces tha key \*(L"13 1 2 3 4 5 6 7\*(R".
.PP
Another use fo' normalizers is when tha function dependz on data other
than dem up in its arguments, n' you can put dat on yo' toast.  Suppose you gotz a gangbangin' function which
returns a value which dependz on tha current minute of tha day:
.PP
.Vb 10
\&        sub on_duty {
\&          mah ($problem_type) = @_;
\&          mah $hour = (localtime)[2];
\&          open mah $fh, "$DIR/$problem_type" or take a thugged-out dirt nap...;
\&          mah $line;
\&          while ($hour\-\- > 0)
\&            $line = <$fh>;
\&          } 
\&          return $line;
\&        }
.Ve
.PP
At 10:23, dis function generates tha 10th line of a thugged-out data file; at
3:45 \s-1PM\s0 it generates tha 15th line instead. Y'all KNOW dat shit, muthafucka!  By default, \f(CW\*(C`Memoize\*(C'\fR
will only peep tha \f(CW$problem_type\fR argument.  To fix this, include the
current minute up in tha normalizer:
.PP
.Vb 1
\&        sub normalize { join \*(Aq \*(Aq, (localtime)[2], @_ }
.Ve
.PP
Da callin context of tha function (scalar or list context) is
propagated ta tha normalizer n' shit.  This means dat if tha memoized
function will treat its arguments differently up in list context than it
would up in scalar context, you can have tha normalizer function select
its behavior based on tha thangs up in dis biatch of \f(CW\*(C`wantarray\*(C'\fR.  Even if called in
a list context, a normalizer should still return a single string.
.ie n .SS """SCALAR_CACHE"", ""LIST_CACHE"""
.el .SS "\f(CWSCALAR_CACHE\fP, \f(CWLIST_CACHE\fP"
.IX Subsection "SCALAR_CACHE, LIST_CACHE"
Normally, \f(CW\*(C`Memoize\*(C'\fR caches yo' functionz return joints tha fuck into an
ordinary Perl hash variable.  But fuck dat shiznit yo, tha word on tha street is dat you might like ta have the
values cached on tha disk, so dat they persist from one run of your
program ta tha next, or you might like ta associate some other
interestin semantics wit tha cached joints.
.PP
Therez a slight complication under tha hood of \f(CW\*(C`Memoize\*(C'\fR: There are
actually \fItwo\fR caches, one fo' scalar joints n' one fo' list joints.
When yo' function is called up in scalar context, its return value is
cached up in one hash, n' when yo' function is called up in list context,
its value is cached up in tha other hash.  Yo ass can control tha caching
behavior of both contexts independently wit these options.
.PP
Da argument ta \f(CW\*(C`LIST_CACHE\*(C'\fR or \f(CW\*(C`SCALAR_CACHE\*(C'\fR must either be one of
the followin four strings:
.PP
.Vb 4
\&        MEMORY
\&        FAULT
\&        MERGE
\&        HASH
.Ve
.PP
or else it must be a reference ta a array whose first element is one of
these four strings, like fuckin \f(CW\*(C`[HASH, arguments...]\*(C'\fR.
.ie n .IP """MEMORY""" 4
.el .IP "\f(CWMEMORY\fR" 4
.IX Item "MEMORY"
\&\f(CW\*(C`MEMORY\*(C'\fR means dat return joints from tha function is ghon be cached in
an ordinary Perl hash variable.  Da hash variable aint gonna persist
afta tha program exits, n' you can put dat on yo' toast.  This is tha default.
.ie n .IP """HASH""" 4
.el .IP "\f(CWHASH\fR" 4
.IX Item "HASH"
\&\f(CW\*(C`HASH\*(C'\fR allows you ta specify dat a particular hash dat you supply
will be used as tha cache.  Yo ass can tie dis hash beforehand ta give
it any behavior you want.
.Sp
A tied hash can have any semantics at all.  It be typically tied ta an
on-disk database, so dat cached joints is stored up in tha database and
retrieved from it again n' again n' again when needed, n' tha disk file typically
persists afta yo' program has exited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See \f(CW\*(C`perltie\*(C'\fR fo' more
complete details bout \f(CW\*(C`tie\*(C'\fR.
.Sp
A typical example is:
.Sp
.Vb 3
\&        use DB_File;
\&        tie mah %cache => \*(AqDB_File\*(Aq, $filename, O_RDWR|O_CREAT, 0666;
\&        memoize \*(Aqfunction\*(Aq, SCALAR_CACHE => [HASH => \e%cache];
.Ve
.Sp
This has tha effect of storin tha cache up in a \f(CW\*(C`DB_File\*(C'\fR database
whose name is up in \f(CW$filename\fR.  Da cache will persist afta the
program has exited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Next time tha program runs, it will find the
cache already populated from tha previous run of tha program.  Or you
can forcibly populate tha cache by constructin a funky-ass batch program that
runs up in tha background n' populates tha cache file.  Then when you
come ta run yo' real program tha memoized function is ghon be fast
because all its thangs up in dis biatch done been precomputed.
.Sp
Another reason ta use \f(CW\*(C`HASH\*(C'\fR is ta provide yo' own hash variable.
Yo ass can then inspect or modify tha contentz of tha hash ta bust finer
control over tha cache pimpment.
.ie n .IP """TIE""" 4
.el .IP "\f(CWTIE\fR" 4
.IX Item "TIE"
This option is no longer supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  It be still documented only to
aid up in tha debuggin of oldschool programs dat use dat shit.  Oldskool programs should
be converted ta use tha \f(CW\*(C`HASH\*(C'\fR option instead.
.Sp
.Vb 1
\&        memoize ... [\*(AqTIE\*(Aq, PACKAGE, ARGS...]
.Ve
.Sp
is merely a gangbangin' finger-lickin' dirty-ass shortcut for
.Sp
.Vb 4
\&        require PACKAGE;
\&        { tie mah %cache, PACKAGE, ARGS...;
\&          memoize ... [HASH => \e%cache];
\&        }
.Ve
.ie n .IP """FAULT""" 4
.el .IP "\f(CWFAULT\fR" 4
.IX Item "FAULT"
\&\f(CW\*(C`FAULT\*(C'\fR means dat you never expect ta booty-call tha function up in scalar
(or list) context, n' dat if \f(CW\*(C`Memoize\*(C'\fR detects such a cold-ass lil call, it
should abort tha program.  Da error message is one of
.Sp
.Vb 2
\&        \`foo\*(Aq function called up in forbidden list context at line ...
\&        \`foo\*(Aq function called up in forbidden scalar context at line ...
.Ve
.ie n .IP """MERGE""" 4
.el .IP "\f(CWMERGE\fR" 4
.IX Item "MERGE"
\&\f(CW\*(C`MERGE\*(C'\fR normally means dat tha memoized function do not
distinguish between list n' sclar context, n' dat return joints in
both contexts should be stored together n' shit.  Both \f(CW\*(C`LIST_CACHE =>
MERGE\*(C'\fR n' \f(CW\*(C`SCALAR_CACHE => MERGE\*(C'\fR mean tha same thang.
.Sp
Consider dis function:
.Sp
.Vb 4
\&        sub fucked up {
\&          # ... time\-consumin calculation of $result
\&          return $result;
\&        }
.Ve
.Sp
Da \f(CW\*(C`fucked up\*(C'\fR function will return tha same numeric \f(CW$result\fR
regardless of whether it is called up in list or up in scalar context.
.Sp
Normally, tha followin code will result up in two calls ta \f(CW\*(C`fucked up\*(C'\fR, even
if \f(CW\*(C`fucked up\*(C'\fR is memoized:
.Sp
.Vb 3
\&    $x = fucked up(142);
\&    ($y) = fucked up(142);
\&    $z = fucked up(142);
.Ve
.Sp
Da first call will cache tha result, say 37, up in tha scalar cache; the
second will cach tha list \f(CW\*(C`(37)\*(C'\fR up in tha list cache.  Da third call
doesn't call tha real \f(CW\*(C`fucked up\*(C'\fR function; it gets tha value 37
from tha scalar cache.
.Sp
Obviously, tha second call ta \f(CW\*(C`fucked up\*(C'\fR be a waste of time, and
storin its return value be a waste of space.  Specifyin \f(CW\*(C`LIST_CACHE
=> MERGE\*(C'\fR will make \f(CW\*(C`memoize\*(C'\fR use tha same cache fo' scalar and
list context return joints, so dat tha second call uses tha scalar
cache dat was populated by tha straight-up original gangsta call.  \f(CW\*(C`fucked up\*(C'\fR endz up
bein called only once, n' both subsequent calls return \f(CW3\fR from the
cache, regardless of tha callin context.
.PP
\fIList joints up in scalar context\fR
.IX Subsection "List joints up in scalar context"
.PP
Consider dis function:
.PP
.Vb 1
\&    sub iota { return reverse (1..$_[0]) }
.Ve
.PP
This function normally returns a list.  Suppose you memoize it and
merge tha caches:
.PP
.Vb 1
\&    memoize \*(Aqiota\*(Aq, SCALAR_CACHE => \*(AqMERGE\*(Aq;
\&
\&    @i7 = iota(7);
\&    $i7 = iota(7);
.Ve
.PP
Here tha straight-up original gangsta call caches tha list (1,2,3,4,5,6,7).  Da second call
does not straight-up make sense. \f(CW\*(C`Memoize\*(C'\fR cannot guess what tha fuck behavior
\&\f(CW\*(C`iota\*(C'\fR should have up in scalar context without straight-up callin it in
scalar context.  Normally \f(CW\*(C`Memoize\*(C'\fR \fIwould\fR call \f(CW\*(C`iota\*(C'\fR up in scalar
context n' cache tha result yo, but tha \f(CW\*(C`SCALAR_CACHE => \*(AqMERGE\*(Aq\*(C'\fR
option say not ta do dat yo, but ta use tha cache list-context value
instead. Y'all KNOW dat shit, muthafucka! But it cannot return a list of seven elements up in a scalar
context. In dis case \f(CW$i7\fR will receive tha \fBfirst element\fR of the
cached list value, namely 7.
.PP
\fIMerged disk caches\fR
.IX Subsection "Merged disk caches"
.PP
Another use fo' \f(CW\*(C`MERGE\*(C'\fR is when you want both kindz of return joints
stored up in tha same disk file; dis saves you from havin ta deal with
two disk filez instead of one.  Yo ass can bust a normalizer function to
keep tha two setz of return joints separate.  For example:
.PP
.Vb 1
\&        tie mah %cache => \*(AqMLDBM\*(Aq, \*(AqDB_File\*(Aq, $filename, ...;
\&
\&        memoize \*(Aqmyfunc\*(Aq,
\&          NORMALIZER => \*(Aqn\*(Aq,
\&          SCALAR_CACHE => [HASH => \e%cache],
\&          LIST_CACHE => \*(AqMERGE\*(Aq,
\&        ;
\&
\&        sub n {
\&          mah $context = wantarray() , biatch? \*(AqL\*(Aq : \*(AqS\*(Aq;
\&          # ... now compute tha hash key from tha arguments ...
\&          $hashkey = "$context:$hashkey";
\&        }
.Ve
.PP
This normalizer function will store scalar context return joints in
the disk file under keys dat begin wit \f(CW\*(C`S:\*(C'\fR, n' list context
return joints under keys dat begin wit \f(CW\*(C`L:\*(C'\fR.
.SH "OTHER FACILITIES"
.IX Header "OTHER FACILITIES"
.ie n .SS """unmemoize"""
.el .SS "\f(CWunmemoize\fP"
.IX Subsection "unmemoize"
Therez a \f(CW\*(C`unmemoize\*(C'\fR function dat you can import if you want to.
Why would you want to, biatch?  Herez a example: Suppose you have yo' cache
tied ta a \s-1DBM\s0 file, n' you wanna make shizzle dat tha cache is
written up ta disk if one of mah thugs interrupts tha program.  If tha program
exits normally, dis will happen anyway yo, but if one of mah thugs types
control-C or suttin' then tha program will terminizzle immediately
without synchronizin tha database.  So what tha fuck you can do instead is
.PP
.Vb 1
\&    $SIG{INT} = sub { unmemoize \*(Aqfunction\*(Aq };
.Ve
.PP
\&\f(CW\*(C`unmemoize\*(C'\fR accepts a reference to, or tha name of a previously
memoized function, n' undoes whatever it did ta provide tha memoized
version up in tha straight-up original gangsta place, includin makin tha name refer ta the
unmemoized version if appropriate.  It returns a reference ta the
unmemoized version of tha function.
.PP
If you ask it ta unmemoize a gangbangin' function dat was never memoized, it
croaks.
.ie n .SS """flush_cache"""
.el .SS "\f(CWflush_cache\fP"
.IX Subsection "flush_cache"
\&\f(CW\*(C`flush_cache(function)\*(C'\fR will flush up tha caches, discardin \fIall\fR
the cached data.  Da argument may be a gangbangin' function name or a reference
to a gangbangin' function. I aint talkin' bout chicken n' gravy biatch.  For finer control over when data is discarded or
expired, peep tha documentation fo' \f(CW\*(C`Memoize::Expire\*(C'\fR, included in
this package.
.PP
Note dat if tha cache be a tied hash, \f(CW\*(C`flush_cache\*(C'\fR will attempt to
invoke tha \f(CW\*(C`CLEAR\*(C'\fR method on tha hash.  If there is no \f(CW\*(C`CLEAR\*(C'\fR
method, dis will cause a run-time error.
.PP
An alternatizzle approach ta cache flushin is ta use tha \f(CW\*(C`HASH\*(C'\fR option
(see above) ta request dat \f(CW\*(C`Memoize\*(C'\fR bust a particular hash variable
as its cache.  Then you can examine or modify tha hash at any time in
any way you desire.  Yo ass may flush tha cache by rockin \f(CW\*(C`%hash = ()\*(C'\fR.
.SH "CAVEATS"
.IX Header "CAVEATS"
Memoization aint a cold-ass lil cure-all:
.IP "\(bu" 4
Do not memoize a gangbangin' function whose behavior dependz on program
state other than its own arguments, like fuckin global variables, tha time
of day, or file input.  These functions aint gonna produce erect
results when memoized. Y'all KNOW dat shit, muthafucka!  For a particularly easy as fuck  example:
.Sp
.Vb 3
\&        sub f {
\&          time;
\&        }
.Ve
.Sp
This function takes no arguments, n' as far as \f(CW\*(C`Memoize\*(C'\fR is
concerned, it always returns tha same ol' dirty result.  \f(CW\*(C`Memoize\*(C'\fR is wrong, of
course, n' tha memoized version of dis function will call \f(CW\*(C`time\*(C'\fR once
to git tha current time, n' it will return dat same time
every time you call it afta dis shit.
.IP "\(bu" 4
Do not memoize a gangbangin' function wit side effects.
.Sp
.Vb 5
\&        sub f {
\&          mah ($a, $b) = @_;
\&          mah $s = $a + $b;
\&          print "$a + $b = $s.\en";
\&        }
.Ve
.Sp
This function accepts two arguments, addz them, n' prints they sum.
Its return value is tha numuber of charactas it printed yo, but you
probably didn't care bout dis shit.  But \f(CW\*(C`Memoize\*(C'\fR don't understand
dat shit.  If you memoize dis function, yo big-ass booty is ghon git tha result you
expect tha last time you ask it ta print tha sum of 2 n' 3 yo, but
subsequent calls will return 1 (the return value of
\&\f(CW\*(C`print\*(C'\fR) without straight-up printin anything.
.IP "\(bu" 4
Do not memoize a gangbangin' function dat returns a thugged-out data structure dat is
modified by its caller.
.Sp
Consider these functions:  \f(CW\*(C`getusers\*(C'\fR returns a list of playas somehow,
and then \f(CW\*(C`main\*(C'\fR throws away tha straight-up original gangsta user on tha list n' prints the
rest:
.Sp
.Vb 7
\&        sub main {
\&          mah $userlist = getusers();
\&          shift @$userlist;
\&          foreach $u (@$userlist) {
\&            print "User $u\en";
\&          }
\&        }
\&
\&        sub getusers {
\&          mah @users;
\&          # Do suttin' ta git a list of users;
\&          \e@users;  # Return reference ta list.
\&        }
.Ve
.Sp
If you memoize \f(CW\*(C`getusers\*(C'\fR here, it will work right exactly once.  The
reference ta tha playas list is ghon be stored up in tha memo table.  \f(CW\*(C`main\*(C'\fR
will discard tha straight-up original gangsta element from tha referenced list.  Da next
time you invoke \f(CW\*(C`main\*(C'\fR, \f(CW\*(C`Memoize\*(C'\fR aint gonna call \f(CW\*(C`getusers\*(C'\fR; it will
just return tha same reference ta tha same list it gots last time.  But
this time tha list has already had its head removed; \f(CW\*(C`main\*(C'\fR will
erroneously remove another element from dat shit.  Da list will git shorter
and shorta every last muthafuckin time you call \f(CW\*(C`main\*(C'\fR.
.Sp
Similarly, this:
.Sp
.Vb 3
\&        $u1 = getusers();    
\&        $u2 = getusers();    
\&        pop @$u1;
.Ve
.Sp
will modify \f(CW$u2\fR as well as \f(CW$u1\fR, cuz both variablez is references
to tha same array.  Had \f(CW\*(C`getusers\*(C'\fR not been memoized, \f(CW$u1\fR n' \f(CW$u2\fR
would have referred ta different arrays.
.IP "\(bu" 4
Do not memoize a straight-up simple function.
.Sp
Recently one of mah thugs mentioned ta me dat tha Memoize module made his
program run slower instead of fasta n' shit.  It turned up dat da thug was
memoizin tha followin function:
.Sp
.Vb 3
\&    sub square {
\&      $_[0] * $_[0];
\&    }
.Ve
.Sp
I pointed up dat \f(CW\*(C`Memoize\*(C'\fR uses a hash, n' dat lookin up a
number up in tha hash is necessarily goin ta take a shitload longer than a
single multiplication. I aint talkin' bout chicken n' gravy biatch.  There straight-up is no way ta speed up the
\&\f(CW\*(C`square\*(C'\fR function.
.Sp
Memoization aint magical.
.SH "PERSISTENT CACHE SUPPORT"
.IX Header "PERSISTENT CACHE SUPPORT"
Yo ass can tie tha cache tablez ta any sort of tied hash dat you want
to, as long as it supports \f(CW\*(C`TIEHASH\*(C'\fR, \f(CW\*(C`FETCH\*(C'\fR, \f(CW\*(C`STORE\*(C'\fR, and
\&\f(CW\*(C`EXISTS\*(C'\fR.  For example,
.PP
.Vb 2
\&        tie mah %cache => \*(AqGDBM_File\*(Aq, $filename, O_RDWR|O_CREAT, 0666;
\&        memoize \*(Aqfunction\*(Aq, SCALAR_CACHE => [HASH => \e%cache];
.Ve
.PP
works just fine.  For some storage methods, you need a lil glue.
.PP
\&\f(CW\*(C`SDBM_File\*(C'\fR don't supply a \f(CW\*(C`EXISTS\*(C'\fR method, so included up in this
package be a glue module called \f(CW\*(C`Memoize::SDBM_File\*(C'\fR which do
provide one.  Use dis instead of plain \f(CW\*(C`SDBM_File\*(C'\fR ta store your
cache table on disk up in a \f(CW\*(C`SDBM_File\*(C'\fR database:
.PP
.Vb 2
\&        tie mah %cache => \*(AqMemoize::SDBM_File\*(Aq, $filename, O_RDWR|O_CREAT, 0666;
\&        memoize \*(Aqfunction\*(Aq, SCALAR_CACHE => [HASH => \e%cache];
.Ve
.PP
\&\f(CW\*(C`NDBM_File\*(C'\fR has tha same ol' dirty problem n' tha same solution. I aint talkin' bout chicken n' gravy biatch.  (Use
\&\f(CW\*(C`Memoize::NDBM_File instead of plain NDBM_File.\*(C'\fR)
.PP
\&\f(CW\*(C`Storable\*(C'\fR aint a tied hash class at all.  Yo ass can use it ta store a
hash ta disk n' retrieve it again yo, but you can't modify tha hash while
itz on tha disk.  So if you wanna store yo' cache table up in a
\&\f(CW\*(C`Storable\*(C'\fR database, use \f(CW\*(C`Memoize::Storable\*(C'\fR, which puts a hashlike
front-end onto \f(CW\*(C`Storable\*(C'\fR.  Da hash table is straight-up kept in
memory, n' is loaded from yo' \f(CW\*(C`Storable\*(C'\fR file all up in tha time you
memoize tha function, n' stored back all up in tha time you unmemoize the
function (or when yo' program exits):
.PP
.Vb 2
\&        tie mah %cache => \*(AqMemoize::Storable\*(Aq, $filename;
\&        memoize \*(Aqfunction\*(Aq, SCALAR_CACHE => [HASH => \e%cache];
\&
\&        tie mah %cache => \*(AqMemoize::Storable\*(Aq, $filename, \*(Aqnstore\*(Aq;
\&        memoize \*(Aqfunction\*(Aq, SCALAR_CACHE => [HASH => \e%cache];
.Ve
.PP
Include tha `nstore' option ta have tha \f(CW\*(C`Storable\*(C'\fR database written
in `network order'.  (See Storable fo' mo' details bout all dis bullshit.)
.PP
Da \f(CW\*(C`flush_cache()\*(C'\fR function will raise a run-time error unless the
tied package serves up a \f(CW\*(C`CLEAR\*(C'\fR method.
.SH "EXPIRATION SUPPORT"
.IX Header "EXPIRATION SUPPORT"
See Memoize::Expire, which be a plug-in module dat addz expiration
functionalitizzle ta Memoize.  If you don't like tha kindz of policies
that Memoize::Expire implements, it is easy as fuck  ta write yo' own plug-in
module ta implement whatever policy you desire.  Memoize comes with
several examples.  An expiration manager dat implements a \s-1LRU\s0 policy
is available on \s-1CPAN\s0 as Memoize::ExpireLRU.
.SH "BUGS"
.IX Header "BUGS"
Da test suite is much mo' betta yo, but always needz improvement.
.PP
There is some problem wit tha way \f(CW\*(C`goto &f\*(C'\fR works under threaded
Perl, like cuz of tha lexical scopin of \f(CW@_\fR.  This be a funky-ass bug
in Perl, n' until it is resolved, memoized functions will peep a
slightly different \f(CW\*(C`caller()\*(C'\fR n' will big-ass up a lil mo' slowly
on threaded perls than unthreaded perls.
.PP
Some versionz of \f(CW\*(C`DB_File\*(C'\fR won't let you store data under a key of
length 0.  That means dat if you gotz a gangbangin' function \f(CW\*(C`f\*(C'\fR which you
memoized n' tha cache is up in a \f(CW\*(C`DB_File\*(C'\fR database, then tha value of
\&\f(CW\*(C`f()\*(C'\fR (\f(CW\*(C`f\*(C'\fR called wit no arguments) aint gonna be memoized. Y'all KNOW dat shit, muthafucka!  If this
is a funky-ass big-ass problem, you can supply a normalizer function dat prepends
\&\f(CW"x"\fR ta every last muthafuckin key.
.SH "MAILING LIST"
.IX Header "MAILING LIST"
To join a straight-up low-traffic mailin list fo' announcements about
\&\f(CW\*(C`Memoize\*(C'\fR, bust a empty note ta \f(CW\*(C`mjd\-perl\-memoize\-request@plover.com\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark-Jizzo Dominus (\f(CW\*(C`mjd\-perl\-memoize+@plover.com\*(C'\fR), Plover Systems co.
.PP
See tha \f(CW\*(C`Memoize.pm\*(C'\fR Page at http://perl.plover.com/Memoize/
for shizzle n' upgrades.  Near dis page, at
http://perl.plover.com/MiniMemoize/ there be a article about
memoization n' bout tha internalz of Memoize dat rocked up in The
Perl Journal, issue #13.  (This article be also included up in the
Memoize distribution as `article.html'.)
.PP
Da authorz book \fIHigher-Order Perl\fR (2005, \s-1ISBN 1558607013,\s0 published
by Morgan Kaufmann) discusses memoization (and nuff other 
topics) up in tremendous detail. Well shiiiit, it be available on-line fo' free.
For mo' shiznit, visit http://hop.perl.plover.com/ .
.PP
To join a mailin list fo' announcements bout \f(CW\*(C`Memoize\*(C'\fR, bust an
empty message ta \f(CW\*(C`mjd\-perl\-memoize\-request@plover.com\*(C'\fR.  This mailing
list is fo' announcements only n' has mad low traffic\-\-\-fewer than
two lyrics per year.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1998, 1999, 2000, 2001, 2012  by Mark Jizzo Dominus
.PP
This library is free software; you may redistribute it and/or modify
it under tha same terms as Perl itself.
.SH "THANK YOU"
.IX Header "THANK YOU"
Many props ta Florian Ragwitz fo' administration n' packaging
assistance, ta Jizzy Tromp fo' bug reports, ta Jonathan Roy fo' bug reports
and suggestions, ta Mike Schwern fo' other bug reports n' patches,
to Mike Cariaso fo' helpin me ta figure up tha Right Thin ta Do
Bout Expiration, ta Joshua Gerth, Joshua Chamas, Jonathan Roy
(again), Mark D fo' realz. Anderson, n' Andrew Johnston fo' mo' suggestions
about expiration, ta Brent Powers fo' tha Memoize::ExpireLRU module,
to Ariel Scolnicov fo' delightful lyrics bout tha Fibonacci
function, ta Dion Almaer fo' thought-provokin suggestions bout the
default normalizer, ta Walt Mankowski n' Kurt Starsinic fo' much help
investigatin problems under threaded Perl, ta Alex Dudkevich for
reportin tha bug up in prototyped functions n' fo' checkin mah patch,
to Tony Bass fo' nuff helpful suggestions, ta Jonathan Roy (again) for
findin a use fo' \f(CW\*(C`unmemoize()\*(C'\fR, ta Philippe Verdret fo' enlightening
rap of \f(CW\*(C`Hook::PrePostCall\*(C'\fR, ta Nat Torkington fo' lyrics I
ignored, ta Chris Nandor fo' portabilitizzle lyrics, ta Randal Schwartz
for suggestin tha '\f(CW\*(C`flush_cache\*(C'\fR function, n' ta Jenda Krynicky for
bein a light up in tha ghetto. Right back up in yo muthafuckin ass.
.PP
Special props ta Jarkko Hietaniemi, tha 5.8.0 pumpking, fo' including
this module up in tha core n' fo' his thugged-out lil' patient n' helpful guidance
durin tha integration process.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 751:" 4
.IX Item "Around line 751:"
Yo ass forgot a '=back' before '=head3'
.IP "Around line 800:" 4
.IX Item "Around line 800:"
=back without =over
