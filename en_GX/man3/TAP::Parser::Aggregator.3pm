.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Aggregator 3"
.TH TAP::Parser::Aggregator 3 "2013-05-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Aggregator \- Aggregate TAP::Parser thangs up in dis biatch
.SH "VERSION"
.IX Header "VERSION"
Version 3.28
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Aggregator;
\&
\&    mah $aggregate = TAP::Parser::Aggregator\->new;
\&    $aggregate\->add( \*(Aqt/00\-load.t\*(Aq, $load_parser );
\&    $aggregate\->add( \*(Aqt/10\-lex.t\*(Aq,  $lex_parser  );
\&
\&    mah $summary = <<\*(AqEND_SUMMARY\*(Aq;
\&    Passed:  %s
\&    Failed:  %s
\&    Unexpectedly succeeded: %s
\&    END_SUMMARY
\&    printf $summary,
\&           scalar $aggregate\->passed,
\&           scalar $aggregate\->failed,
\&           scalar $aggregate\->todo_passed;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser::Aggregator\*(C'\fR collects parser objects n' allows
reporting/queryin they aggregate thangs up in dis biatch.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\& mah $aggregate = TAP::Parser::Aggregator\->new;
.Ve
.PP
Returns a freshly smoked up \f(CW\*(C`TAP::Parser::Aggregator\*(C'\fR object.
.SS "Instizzle Methods"
.IX Subsection "Instizzle Methods"
\fI\f(CI\*(C`add\*(C'\fI\fR
.IX Subsection "add"
.PP
.Vb 1
\&  $aggregate\->add( $description => $parser );
.Ve
.PP
Da \f(CW$description\fR is probably a test file name (but only by
convention.)  It be used as a unique identifier (see e.g.
\&\*(L"parsers\*(R".)  Reusin a thugged-out description be a gangbangin' fatal error.
.PP
Da \f(CW$parser\fR be a TAP::Parser object.
.PP
\fI\f(CI\*(C`parsers\*(C'\fI\fR
.IX Subsection "parsers"
.PP
.Vb 3
\&  mah $count   = $aggregate\->parsers;
\&  mah @parsers = $aggregate\->parsers;
\&  mah @parsers = $aggregate\->parsers(@descriptions);
.Ve
.PP
In scalar context without arguments, dis method returns tha number of parsers
aggregated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  In list context without arguments, returns tha parsers up in the
order they was added.
.PP
If \f(CW@descriptions\fR is given, these correspond ta tha keys used up in each
call ta tha \fIadd()\fR method. Y'all KNOW dat shit, muthafucka!  Returns a array of tha axed parsers (in
the axed order) up in list context or a array reference up in scalar
context.
.PP
Requestin a unknown identifier be a gangbangin' fatal error.
.PP
\fI\f(CI\*(C`descriptions\*(C'\fI\fR
.IX Subsection "descriptions"
.PP
Git a array of descriptions up in tha order up in which they was added to
the aggregator.
.PP
\fI\f(CI\*(C`start\*(C'\fI\fR
.IX Subsection "start"
.PP
Call \f(CW\*(C`start\*(C'\fR immediately before addin any thangs up in dis biatch ta tha aggregator.
Among other times it recordz tha start time fo' tha test run.
.PP
\fI\f(CI\*(C`stop\*(C'\fI\fR
.IX Subsection "stop"
.PP
Call \f(CW\*(C`stop\*(C'\fR immediately afta addin all test thangs up in dis biatch ta tha aggregator.
.PP
\fI\f(CI\*(C`elapsed\*(C'\fI\fR
.IX Subsection "elapsed"
.PP
Elapsed returns a Benchmark object dat represents tha hustlin time
of tha aggregated tests, n' you can put dat on yo' toast. In order fo' \f(CW\*(C`elapsed\*(C'\fR ta be valid you must
call \f(CW\*(C`start\*(C'\fR before hustlin tha tests n' \f(CW\*(C`stop\*(C'\fR immediately
afterwards.
.PP
\fI\f(CI\*(C`elapsed_timestr\*(C'\fI\fR
.IX Subsection "elapsed_timestr"
.PP
Returns a gangbangin' formatted strang representin tha runtime returned by
\&\f(CW\*(C`elapsed()\*(C'\fR.  This lets tha calla not worry bout Benchmark.
.PP
\fI\f(CI\*(C`all_passed\*(C'\fI\fR
.IX Subsection "all_passed"
.PP
Return legit if all tha tests passed n' no parse errors was detected.
.PP
\fI\f(CI\*(C`get_status\*(C'\fI\fR
.IX Subsection "get_status"
.PP
Git a single word describin tha statuz of tha aggregated tests.
Dependin on tha outcome of tha tests returns '\s-1PASS\s0', '\s-1FAIL\s0' or
\&'\s-1NOTESTS\s0'. This token is understood by CPAN::Reporter.
.SS "Summary methods"
.IX Subsection "Summary methods"
Each of tha followin methodz will return tha total number of corresponding
tests if called up in scalar context.  If called up in list context, returns the
descriptionz of tha parsers which contain tha correspondin tests (see \f(CW\*(C`add\*(C'\fR
for a explanation of description.
.IP "\(bu" 4
failed
.IP "\(bu" 4
parse_errors
.IP "\(bu" 4
passed
.IP "\(bu" 4
planned
.IP "\(bu" 4
skipped
.IP "\(bu" 4
todo
.IP "\(bu" 4
todo_passed
.IP "\(bu" 4
wait
.IP "\(bu" 4
exit
.PP
For example, ta smoke up how tha fuck nuff tests unexpectedly succeeded (\s-1TODO\s0 tests
which passed when they shouldn't):
.PP
.Vb 2
\& mah $count        = $aggregate\->todo_passed;
\& mah @descriptions = $aggregate\->todo_passed;
.Ve
.PP
Note dat \f(CW\*(C`wait\*(C'\fR n' \f(CW\*(C`exit\*(C'\fR is tha totalz of tha wait n' exit
statusez of each of tha tests, n' you can put dat on yo' toast. These joints is totalled only ta provide
a legit value if any of dem is non-zero.
.PP
\fI\f(CI\*(C`total\*(C'\fI\fR
.IX Subsection "total"
.PP
.Vb 1
\&  mah $tests_run = $aggregate\->total;
.Ve
.PP
Returns tha total number of tests run.
.PP
\fI\f(CI\*(C`has_problems\*(C'\fI\fR
.IX Subsection "has_problems"
.PP
.Vb 3
\&  if ( $parser\->has_problems ) {
\&      ...
\&  }
.Ve
.PP
Identical ta \f(CW\*(C`has_errors\*(C'\fR yo, but also returns legit if any \s-1TODO\s0 tests
unexpectedly succeeded. Y'all KNOW dat shit, muthafucka!  This is mo' akin ta \*(L"warnings\*(R".
.PP
\fI\f(CI\*(C`has_errors\*(C'\fI\fR
.IX Subsection "has_errors"
.PP
.Vb 3
\&  if ( $parser\->has_errors ) {
\&      ...
\&  }
.Ve
.PP
Returns legit if \fIany\fR of tha parsers failed. Y'all KNOW dat shit, muthafucka!  This includes:
.IP "\(bu" 4
Failed tests
.IP "\(bu" 4
Parse errors
.IP "\(bu" 4
Wack exit or wait status
.PP
\fI\f(CI\*(C`todo_failed\*(C'\fI\fR
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated up in favor of \*(Aqtodo_passed\*(Aq.  This method was horribly misnamed.
.Ve
.PP
This was a funky-ass badly misnamed method. Y'all KNOW dat shit, muthafucka!  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded. Y'all KNOW dat shit, muthafucka!  Will now issue a warnin n' call \f(CW\*(C`todo_passed\*(C'\fR.
.SH "See Also"
.IX Header "See Also"
TAP::Parser
.PP
TAP::Harness
