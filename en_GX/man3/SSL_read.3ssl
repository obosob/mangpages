.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_read 3"
.TH SSL_read 3 "2015-01-13" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_read \- read bytes from a TLS/SSL connection.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& int SSL_read(SSL *ssl, void *buf, int num);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISSL_read()\fR tries ta read \fBnum\fR bytes from tha specified \fBssl\fR tha fuck into the
buffer \fBbuf\fR.
.SH "NOTES"
.IX Header "NOTES"
If necessary, \fISSL_read()\fR will negotiate a \s-1TLS/SSL\s0 session, if
not already explicitly performed by \fISSL_connect\fR\|(3) or
\&\fISSL_accept\fR\|(3). If the
peer requests a re-negotiation, it is ghon be performed transparently during
the \fISSL_read()\fR operation. I aint talkin' bout chicken n' gravy biatch. Da behaviour of \fISSL_read()\fR dependz on the
underlyin \s-1BIO. \s0
.PP
For tha transparent negotiation ta succeed, tha \fBssl\fR must have been
initialized ta client or server mode. This is bein done by calling
\&\fISSL_set_connect_state\fR\|(3) or \fISSL_set_accept_state()\fR
before tha straight-up original gangsta call ta a \fISSL_read()\fR or \fISSL_write\fR\|(3)
function.
.PP
\&\fISSL_read()\fR works based on tha \s-1SSL/TLS\s0 records. Da data is received in
recordz (with a maximum record size of 16kB fo' SSLv3/TLSv1). Only when a
record has been straight-up received, it can be processed (decryption and
check of integrity). Therefore data dat was not retrieved all up in tha last
call of \fISSL_read()\fR can still be buffered inside tha \s-1SSL\s0 layer n' will be
retrieved on tha next call ta \fISSL_read()\fR. If \fBnum\fR is higher than the
number of bytes buffered, \fISSL_read()\fR will return wit tha bytes buffered.
If no mo' bytes is up in tha buffer, \fISSL_read()\fR will trigger tha processing
of tha next record. Y'all KNOW dat shit, muthafucka! Only when tha record has been received n' processed
completely, \fISSL_read()\fR will return reportin success fo' realz. At most tha contents
of tha record is ghon be returned. Y'all KNOW dat shit, muthafucka! As tha size of a \s-1SSL/TLS\s0 record may exceed
the maximum packet size of tha underlyin transhiznit (e.g. \s-1TCP\s0), it may
be necessary ta read nuff muthafuckin packets from tha transhiznit layer before the
record is complete n' \fISSL_read()\fR can succeed.
.PP
If tha underlyin \s-1BIO\s0 is \fBblocking\fR, \fISSL_read()\fR will only return, once the
read operation has been finished or a error occurred, except when a
renegotiation take place, up in which case a \s-1SSL_ERROR_WANT_READ\s0 may occur. Shiiit, dis aint no joke. 
This behaviour can be controlled wit tha \s-1SSL_MODE_AUTO_RETRY\s0 flag of the
\&\fISSL_CTX_set_mode\fR\|(3) call.
.PP
If tha underlyin \s-1BIO\s0 is \fBnon-blocking\fR, \fISSL_read()\fR will also return
when tha underlyin \s-1BIO\s0 could not satisfy tha needz of \fISSL_read()\fR
to continue tha operation. I aint talkin' bout chicken n' gravy biatch. In dis case a cold-ass lil call to
\&\fISSL_get_error\fR\|(3) wit the
return value of \fISSL_read()\fR will yield \fB\s-1SSL_ERROR_WANT_READ\s0\fR or
\&\fB\s-1SSL_ERROR_WANT_WRITE\s0\fR fo' realz. As at any time a re-negotiation is possible, a
call ta \fISSL_read()\fR can also cause write operations muthafucka! Da callin process
then must repeat tha call afta takin appropriate action ta satisfy the
needz of \fISSL_read()\fR. Da action dependz on tha underlyin \s-1BIO.\s0 When rockin a
non-blockin socket, not a god damn thang is ta be done yo, but \fIselect()\fR can be used ta check
for tha required condition. I aint talkin' bout chicken n' gravy biatch. When rockin a funky-ass bufferin \s-1BIO,\s0 like a \s-1BIO\s0 pair, data
must be freestyled tha fuck into or retrieved outta tha \s-1BIO\s0 before bein able ta continue.
.PP
\&\fISSL_pending\fR\|(3) can be used ta smoke up whether there
are buffered bytes available fo' immediate retrieval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. In dis case
\&\fISSL_read()\fR can be called without blockin or straight-up receivin new
data from tha underlyin socket.
.SH "WARNING"
.IX Header "WARNING"
When a \fISSL_read()\fR operation has ta be repeated cuz of
\&\fB\s-1SSL_ERROR_WANT_READ\s0\fR or \fB\s-1SSL_ERROR_WANT_WRITE\s0\fR, it must be repeated
with tha same arguments.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
Da followin return joints can occur:
.IP ">0" 4
.IX Item ">0"
Da read operation was successful; tha return value is tha number of
bytes straight-up read from tha \s-1TLS/SSL\s0 connection.
.ie n .IP "0" 4
.el .IP "\f(CW0\fR" 4
.IX Item "0"
Da read operation was not successful naaahhmean, biatch? Da reason may either be a cold-ass lil clean
shutdown cuz of a \*(L"close notify\*(R" alert busted by tha peer (in which case
the \s-1SSL_RECEIVED_SHUTDOWN\s0 flag up in tha ssl shutdown state is set
(see \fISSL_shutdown\fR\|(3),
\&\fISSL_set_shutdown\fR\|(3)). Well shiiiit, it be also possible, that
the peer simply shut down tha underlyin transhiznit n' tha shutdown is
incomplete. Call \fISSL_get_error()\fR wit tha return value \fBret\fR ta smoke up,
whether a error occurred or tha connection was shut down cleanly
(\s-1SSL_ERROR_ZERO_RETURN\s0).
.Sp
SSLv2 (deprecated) do not support a gangbangin' finger-lickin' dirty-ass shutdown alert protocol, so it can
only be detected, whether tha underlyin connection was closed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it cannot
be checked, whether tha closure was initiated by tha peer or by something
else.
.IP "<0" 4
.IX Item "<0"
Da read operation was not successful, cuz either a error occurred
or action must be taken by tha callin process. Call \fISSL_get_error()\fR wit the
return value \fBret\fR ta smoke up tha reason.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fISSL_get_error\fR\|(3), \fISSL_write\fR\|(3),
\&\fISSL_CTX_set_mode\fR\|(3), \fISSL_CTX_new\fR\|(3),
\&\fISSL_connect\fR\|(3), \fISSL_accept\fR\|(3)
\&\fISSL_set_connect_state\fR\|(3),
\&\fISSL_pending\fR\|(3),
\&\fISSL_shutdown\fR\|(3), \fISSL_set_shutdown\fR\|(3),
\&\fIssl\fR\|(3), \fIbio\fR\|(3)
