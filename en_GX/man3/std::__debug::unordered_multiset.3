" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::__debug::unordered_multiset< _Value, _Hash, _Pred, _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits unordered_multiset< _Value, _Hash, _Pred, _Alloc >, n' \fB__gnu_debug::_Safe_unordered_container< unordered_multiset< _Value, _Hash, _Pred, _Alloc > >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Base::allocator_type \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef 
.br
\fB__gnu_debug::_Safe_iterator\fP
.br
< _Base_const_iterator, 
.br
\fBunordered_multiset\fP > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef 
.br
\fB__gnu_debug::_Safe_local_iterator\fP
.br
< _Base_const_local_iterator, 
.br
\fBunordered_multiset\fP > \fBconst_local_iterator\fP"
.br
.ti -1c
.RI "typedef _Base::hasher \fBhasher\fP"
.br
.ti -1c
.RI "typedef 
.br
\fB__gnu_debug::_Safe_iterator\fP
.br
< _Base_iterator, 
.br
\fBunordered_multiset\fP > \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Base::key_equal \fBkey_equal\fP"
.br
.ti -1c
.RI "typedef _Base::key_type \fBkey_type\fP"
.br
.ti -1c
.RI "typedef 
.br
\fB__gnu_debug::_Safe_local_iterator\fP
.br
< _Base_local_iterator, 
.br
\fBunordered_multiset\fP > \fBlocal_iterator\fP"
.br
.ti -1c
.RI "typedef _Base::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Base::value_type \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBunordered_multiset\fP (size_type __n=10, const hasher &__hf=hasher(), const key_equal &__eql=key_equal(), const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBunordered_multiset\fP (_InputIterator __first, _InputIterator __last, size_type __n=0, const hasher &__hf=hasher(), const key_equal &__eql=key_equal(), const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBunordered_multiset\fP (const \fBunordered_multiset\fP &__x)=default"
.br
.ti -1c
.RI "\fBunordered_multiset\fP (const \fB_Base\fP &__x)"
.br
.ti -1c
.RI "\fBunordered_multiset\fP (\fBunordered_multiset\fP &&__x)=default"
.br
.ti -1c
.RI "\fBunordered_multiset\fP (\fBinitializer_list\fP< value_type > __l, size_type __n=0, const hasher &__hf=hasher(), const key_equal &__eql=key_equal(), const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "void \fB_M_attach\fP (_Safe_iterator_base *__it, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_local\fP (_Safe_iterator_base *__it, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_local_single\fP (_Safe_iterator_base *__it, bool __constant)  throw ()"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (_Safe_iterator_base *__it, bool __constant)  throw ()"
.br
.ti -1c
.RI "\fB_Base\fP & \fB_M_base\fP () noexcept"
.br
.ti -1c
.RI "const \fB_Base\fP & \fB_M_base\fP () const noexcept"
.br
.ti -1c
.RI "void \fB_M_detach\fP (_Safe_iterator_base *__it)"
.br
.ti -1c
.RI "void \fB_M_detach_local\fP (_Safe_iterator_base *__it)"
.br
.ti -1c
.RI "void \fB_M_detach_local_single\fP (_Safe_iterator_base *__it)  throw ()"
.br
.ti -1c
.RI "void \fB_M_detach_single\fP (_Safe_iterator_base *__it)  throw ()"
.br
.ti -1c
.RI "void \fB_M_invalidate_all\fP () const "
.br
.ti -1c
.RI "void \fB_M_invalidate_if\fP (_Predicate __pred)"
.br
.ti -1c
.RI "void \fB_M_invalidate_local_if\fP (_Predicate __pred)"
.br
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBlocal_iterator\fP \fBbegin\fP (size_type __b)"
.br
.ti -1c
.RI "\fBconst_local_iterator\fP \fBbegin\fP (size_type __b) const "
.br
.ti -1c
.RI "size_type \fBbucket_size\fP (size_type __b) const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_local_iterator\fP \fBcbegin\fP (size_type __b) const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_local_iterator\fP \fBcend\fP (size_type __b) const "
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBiterator\fP \fBemplace\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBiterator\fP \fBemplace_hint\fP (\fBconst_iterator\fP __hint, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const noexcept"
.br
.ti -1c
.RI "\fBlocal_iterator\fP \fBend\fP (size_type __b)"
.br
.ti -1c
.RI "\fBconst_local_iterator\fP \fBend\fP (size_type __b) const "
.br
.ti -1c
.RI "\fBstd::pair\fP< \fBiterator\fP, \fBiterator\fP > \fBequal_range\fP (const key_type &__key)"
.br
.ti -1c
.RI "\fBstd::pair\fP< \fBconst_iterator\fP, 
.br
\fBconst_iterator\fP > \fBequal_range\fP (const key_type &__key) const "
.br
.ti -1c
.RI "size_type \fBerase\fP (const key_type &__key)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBconst_iterator\fP __it)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __it)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBconst_iterator\fP __first, \fBconst_iterator\fP __last)"
.br
.ti -1c
.RI "\fBiterator\fP \fBfind\fP (const key_type &__key)"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBfind\fP (const key_type &__key) const "
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (const value_type &__obj)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP __hint, const value_type &__obj)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (value_type &&__obj)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP __hint, value_type &&__obj)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBstd::initializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fBinsert\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "float \fBmax_load_factor\fP () const noexcept"
.br
.ti -1c
.RI "void \fBmax_load_factor\fP (float __f)"
.br
.ti -1c
.RI "\fBunordered_multiset\fP & \fBoperator=\fP (const \fBunordered_multiset\fP &__x)"
.br
.ti -1c
.RI "\fBunordered_multiset\fP & \fBoperator=\fP (\fBunordered_multiset\fP &&__x)"
.br
.ti -1c
.RI "\fBunordered_multiset\fP & \fBoperator=\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBunordered_multiset\fP &__x)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "_Safe_iterator_base * \fB_M_const_iterators\fP"
.br
.ti -1c
.RI "_Safe_iterator_base * \fB_M_const_local_iterators\fP"
.br
.ti -1c
.RI "_Safe_iterator_base * \fB_M_iterators\fP"
.br
.ti -1c
.RI "_Safe_iterator_base * \fB_M_local_iterators\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_detach_all\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_singular\fP ()"
.br
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()  throw ()"
.br
.ti -1c
.RI "void \fB_M_revalidate_singular\fP ()"
.br
.ti -1c
.RI "void \fB_M_swap\fP (_Safe_unordered_container_base &__x)"
.br
.ti -1c
.RI "void \fB_M_swap\fP (_Safe_sequence_base &__x)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Value, typename _Hash = std::hash<_Value>, typename _Pred = std::equal_to<_Value>, typename _Alloc = std::allocator<_Value>>class std::__debug::unordered_multiset< _Value, _Hash, _Pred, _Alloc >"
Class std::unordered_multiset wit safety/checking/debug instrumentation\&. 
.PP
Definizzle at line 474 of file debug/unordered_set\&.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Attach a iterator ta dis sequence\&. 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_attach_local (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Attach a iterator ta dis container\&. 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_attach_local_single (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach_single (\fB_Safe_iterator_base\fP *__it, bool__constant)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Detach a iterator from dis sequence 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_detach_all ()\fC [protected]\fP, \fC [inherited]\fP"
Detach all iterators, leavin dem singular\&. 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_detach_local (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Detach a iterator from dis container 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_detach_local_single (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_single (\fB_Safe_iterator_base\fP *__it)\fC [inherited]\fP"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Detach all singular iterators\&. 
.PP
\fBPostcondition:\fP
.RS 4
for all iterators i attached ta dis sequence, i->_M_version == _M_version\&. 
.RE
.PP

.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_sequence_base::_M_get_mutex ()\fC [protected]\fP, \fC [inherited]\fP"
For use up in _Safe_sequence\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_invalidate_all () const\fC [inline]\fP, \fC [inherited]\fP"
Invalidates all iterators\&. 
.PP
Definizzle at line 233 of file safe_base\&.h\&.
.PP
References __gnu_debug::_Safe_sequence_base::_M_version\&.
.SS "void \fB__gnu_debug::_Safe_unordered_container\fP< \fBunordered_multiset\fP< _Value, _Hash, _Pred, _Alloc >  >::_M_invalidate_if (_Predicate__pred)\fC [inherited]\fP"
Invalidates all iterators \fCx\fP dat reference dis container, is not singular, n' fo' which \fC__pred(x)\fP returns \fCtrue\fP\&. \fC__pred\fP is ghon be invoked wit tha aiiight iterators nested up in tha safe ones\&. 
.SS "void \fB__gnu_debug::_Safe_unordered_container\fP< \fBunordered_multiset\fP< _Value, _Hash, _Pred, _Alloc >  >::_M_invalidate_local_if (_Predicate__pred)\fC [inherited]\fP"
Invalidates all local iterators \fCx\fP dat reference dis container, is not singular, n' fo' which \fC__pred(x)\fP returns \fCtrue\fP\&. \fC__pred\fP is ghon be invoked wit tha aiiight ilocal iterators nested up in tha safe ones\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_revalidate_singular ()\fC [protected]\fP, \fC [inherited]\fP"
Revalidates all attached singular iterators\&. This method may be used ta validate iterators dat was invalidated before (but fo' some reason, like fuckin a exception, need ta become valid again)\&. 
.SS "void __gnu_debug::_Safe_unordered_container_base::_M_swap (\fB_Safe_unordered_container_base\fP &__x)\fC [protected]\fP, \fC [inherited]\fP"
Swap dis container wit tha given container\&. This operation also swaps ballershizzle of tha iterators, so dat when tha operation is complete all iterators dat originally referenced one container now reference tha other container\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_swap (\fB_Safe_sequence_base\fP &__x)\fC [protected]\fP, \fC [inherited]\fP"
Swap dis sequence wit tha given sequence\&. This operation also swaps ballershizzle of tha iterators, so dat when tha operation is complete all iterators dat originally referenced one container now reference tha other container\&. 
.SH "Member Data Documentation"
.PP 
.SS "_Safe_iterator_base* __gnu_debug::_Safe_sequence_base::_M_const_iterators\fC [inherited]\fP"

.PP
Da list of constant iterators dat reference dis container\&. 
.PP
Definizzle at line 184 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "_Safe_iterator_base* __gnu_debug::_Safe_unordered_container_base::_M_const_local_iterators\fC [inherited]\fP"

.PP
Da list of constant local iterators dat reference dis container\&. 
.PP
Definizzle at line 131 of file safe_unordered_base\&.h\&.
.SS "_Safe_iterator_base* __gnu_debug::_Safe_sequence_base::_M_iterators\fC [inherited]\fP"

.PP
Da list of mutable iterators dat reference dis container\&. 
.PP
Definizzle at line 181 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "_Safe_iterator_base* __gnu_debug::_Safe_unordered_container_base::_M_local_iterators\fC [inherited]\fP"

.PP
Da list of mutable local iterators dat reference dis container\&. 
.PP
Definizzle at line 128 of file safe_unordered_base\&.h\&.
.SS "unsigned int __gnu_debug::_Safe_sequence_base::_M_version\fC [mutable]\fP, \fC [inherited]\fP"

.PP
Da container version number\&. This number may never be 0\&. 
.PP
Definizzle at line 187 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence_base::_M_invalidate_all(), n' __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
