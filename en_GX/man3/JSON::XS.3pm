.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XS 3"
.TH XS 3 "2013-05-23" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
JSON::XS \- JSON serialising/deserialising, done erectly n' fast
.PP
JSON::XS \- XXXXXXX JSON XXXXXX/XXXXXXX
           (http://fleur.hio.jp/perldoc/mix/lib/JSON/XS.html)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use JSON::XS;
\&
\& # exported functions, they croak on error
\& # n' expect/generate UTF\-8
\&
\& $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
\& $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
\&
\& # OO\-interface
\&
\& $coder = JSON::XS\->new\->ascii\->pretty\->allow_nonref;
\& $pretty_printed_unencoded = $coder\->encode ($perl_scalar);
\& $perl_scalar = $coder\->decode ($unicode_json_text);
\&
\& # Note dat JSON version 2.0 n' above will automatically use JSON::XS
\& # if available, at virtually no speed overhead either, so you should
\& # be able ta just:
\& 
\& use JSON;
\&
\& # n' do tha same thangs, except dat you gotz a pure\-perl fallback now, nahmeean?
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module converts Perl data structures ta \s-1JSON\s0 n' vice versa. Its
primary goal is ta be \fIcorrect\fR n' its secondary goal is ta be
\&\fIfast\fR. To reach tha latta goal dat shiznit was freestyled up in C.
.PP
Beginnin wit version 2.0 of tha \s-1JSON\s0 module, when both \s-1JSON\s0 and
\&\s-1JSON::XS\s0 is installed, then \s-1JSON\s0 will fall back on \s-1JSON::XS \s0(this can be
overridden) wit no overhead cuz of emulation (by inheritin constructor
and methods). If \s-1JSON::XS\s0 aint available, it will fall back ta the
compatible \s-1JSON::PP\s0 module as backend, so rockin \s-1JSON\s0 instead of \s-1JSON::XS\s0
gives you a portable \s-1JSON API\s0 dat can be fast when you need n' don't
require a C compila when dat be a problem.
.PP
As dis is tha n\-th-suttin' \s-1JSON\s0 module on \s-1CPAN,\s0 what tha fuck was tha reason
to write yet another \s-1JSON\s0 module, biatch? While it seems there be nuff \s-1JSON\s0
modules, none of dem erectly handle all corner cases, n' up in most cases
their maintainers is unresponsive, gone missing, or not listenin ta bug
reports fo' other reasons.
.PP
See \s-1MAPPING,\s0 below, on how tha fuck \s-1JSON::XS\s0 maps perl joints ta \s-1JSON\s0 joints and
vice versa.
.SS "\s-1FEATURES\s0"
.IX Subsection "FEATURES"
.IP "\(bu" 4
correct Unicode handling
.Sp
This module knows how tha fuck ta handle Unicode, documents how tha fuck n' when it do
so, n' even documents what tha fuck \*(L"correct\*(R" means.
.IP "\(bu" 4
round-trip integrity
.Sp
When you serialise a perl data structure rockin only data types supported
by \s-1JSON\s0 n' Perl, tha deserialised data structure is identical on tha Perl
level. (e.g. tha strang \*(L"2.0\*(R" don't suddenly become \*(L"2\*(R" just cuz
it be lookin like a number). There \fIare\fR minor exceptions ta this, read the
\&\s-1MAPPING\s0 section below ta learn bout them.
.IP "\(bu" 4
strict checkin of \s-1JSON\s0 erectness
.Sp
There is no guessing, no generatin of illegal \s-1JSON\s0 texts by default,
and only \s-1JSON\s0 be accepted as input by default (the latta be a security
feature).
.IP "\(bu" 4
fast
.Sp
Compared ta other \s-1JSON\s0 modulez n' other serialisers like fuckin Storable,
this module probably compares favourably up in termz of speed, like a muthafucka.
.IP "\(bu" 4
simple ta use
.Sp
This module has both a simple functionizzle intercourse as well as a object
oriented intercourse intercourse.
.IP "\(bu" 4
reasonably versatile output formats
.Sp
Yo ass can chizzle between da most thugged-out compact guaranteed-single-line format
possible (nice fo' simple line-based protocols), a pure-ASCII format
(for when yo' transhiznit aint 8\-bit clean, still supports tha whole
Unicode range), or a pretty-printed format (for when you wanna read that
stuff). Or you can combine dem features up in whatever way you like.
.SH "FUNCTIONAL INTERFACE"
.IX Header "FUNCTIONAL INTERFACE"
Da followin convenience methodz is provided by dis module. They are
exported by default:
.ie n .IP "$json_text = encode_json $perl_scalar" 4
.el .IP "\f(CW$json_text\fR = encode_json \f(CW$perl_scalar\fR" 4
.IX Item "$json_text = encode_json $perl_scalar"
Converts tha given Perl data structure ta a \s-1UTF\-8\s0 encoded, binary string
(that is, tha strang gotz nuff octets only). Croaks on error.
.Sp
This function call is functionally identical to:
.Sp
.Vb 1
\&   $json_text = JSON::XS\->new\->utf8\->encode ($perl_scalar)
.Ve
.Sp
Except bein faster.
.ie n .IP "$perl_scalar = decode_json $json_text" 4
.el .IP "\f(CW$perl_scalar\fR = decode_json \f(CW$json_text\fR" 4
.IX Item "$perl_scalar = decode_json $json_text"
Da opposite of \f(CW\*(C`encode_json\*(C'\fR: expects a \s-1UTF\-8 \s0(binary) strang n' tries
to parse dat as a \s-1UTF\-8\s0 encoded \s-1JSON\s0 text, returnin tha resulting
reference. Croaks on error.
.Sp
This function call is functionally identical to:
.Sp
.Vb 1
\&   $perl_scalar = JSON::XS\->new\->utf8\->decode ($json_text)
.Ve
.Sp
Except bein faster.
.ie n .IP "$is_boolean = JSON::XS::is_bool $scalar" 4
.el .IP "\f(CW$is_boolean\fR = JSON::XS::is_bool \f(CW$scalar\fR" 4
.IX Item "$is_boolean = JSON::XS::is_bool $scalar"
Returns legit if tha passed scalar represents either JSON::XS::true or
JSON::XS::false, two constants dat act like \f(CW1\fR n' \f(CW0\fR, respectively
and is used ta represent \s-1JSON \s0\f(CW\*(C`true\*(C'\fR n' \f(CW\*(C`false\*(C'\fR joints up in Perl.
.Sp
See \s-1MAPPING,\s0 below, fo' mo' shiznit on how tha fuck \s-1JSON\s0 joints is mapped to
Perl.
.SH "A FEW NOTES ON UNICODE AND PERL"
.IX Header "A FEW NOTES ON UNICODE AND PERL"
Since dis often leadz ta mad drama, here is all dem straight-up clear lyrics on
how Unicode works up in Perl, modulo bugs.
.IP "1. Perl strings can store charactas wit ordinal joints > 255." 4
.IX Item "1. Perl strings can store charactas wit ordinal joints > 255."
This enablez you ta store Unicode charactas as single charactas up in a
Perl strang \- straight-up natural.
.IP "2. Perl do \fInot\fR associate a encodin wit yo' strings." 4
.IX Item "2. Perl do not associate a encodin wit yo' strings."
\&... until you force it to, e.g. when matchin it against a regex, or
printin tha scalar ta a gangbangin' file, up in which case Perl either interprets your
strin as locale-encoded text, octets/binary, or as Unicode, depending
on various settings. In no case be a encodin stored together wit your
data, it is \fIuse\fR dat decides encoding, not any magical meta data.
.IP "3. Da internal utf\-8 flag has no meanin wit regardz ta tha encodin of yo' string." 4
.IX Item "3. Da internal utf-8 flag has no meanin wit regardz ta tha encodin of yo' string."
Just ignore dat flag unless you debug a Perl bug, a module freestyled in
\&\s-1XS\s0 or wanna dive tha fuck into tha internalz of perl. Otherwise it will only
confuse you, as, despite tha name, it say not a god damn thang bout how tha fuck yo' string
is encoded. Y'all KNOW dat shit, muthafucka! Yo ass can have Unicode strings wit dat flag set, wit that
flag clear, n' you can have binary data wit dat flag set n' dat flag
clear. Shiiit, dis aint no joke. Other possibilitizzles exist, like a muthafucka.
.Sp
If you didn't give a fuck bout dat flag, just tha better, pretend it don't
exist.
.ie n .IP "4 fo' realz. A ""Unicode String"" is simply a strang where each characta can be validly interpreted as a Unicode code point." 4
.el .IP "4 fo' realz. A ``Unicode String'' is simply a strang where each characta can be validly interpreted as a Unicode code point." 4
.IX Item "4 fo' realz. A Unicode Strin is simply a strang where each characta can be validly interpreted as a Unicode code point."
If you have \s-1UTF\-8\s0 encoded data, it is no longer a Unicode strin yo, but a
Unicode strang encoded up in \s-1UTF\-8,\s0 givin you a funky-ass binary string.
.ie n .IP "5 fo' realz. A strang containin ""high"" (> 255) characta joints is \fInot\fR a \s-1UTF\-8\s0 string." 4
.el .IP "5 fo' realz. A strang containin ``high'' (> 255) characta joints is \fInot\fR a \s-1UTF\-8\s0 string." 4
.IX Item "5 fo' realz. A strang containin high (> 255) characta joints aint a UTF-8 string."
It aint nuthin but a gangbangin' fact. Peep ta live wit dat shit.
.PP
I hope dis helps :)
.SH "OBJECT-ORIENTED INTERFACE"
.IX Header "OBJECT-ORIENTED INTERFACE"
Da object oriented intercourse lets you configure yo' own encodin or
decodin style, within tha limitz of supported formats.
.ie n .IP "$json = freshly smoked up \s-1JSON::XS\s0" 4
.el .IP "\f(CW$json\fR = freshly smoked up \s-1JSON::XS\s0" 4
.IX Item "$json = freshly smoked up JSON::XS"
Creates a freshly smoked up \s-1JSON::XS\s0 object dat can be used ta de/encode \s-1JSON\s0
strings fo' realz. All boolean flags busted lyrics bout below is by default \fIdisabled\fR.
.Sp
Da mutators fo' flags all return tha \s-1JSON\s0 object again n' again n' again n' thus calls can
be chained:
.Sp
.Vb 2
\&   mah $json = JSON::XS\->new\->utf8\->space_after\->encode ({a => [1,2]})
\&   => {"a": [1, 2]}
.Ve
.ie n .IP "$json = $json\->ascii ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->ascii ([$enable])" 4
.IX Item "$json = $json->ascii ([$enable])"
.PD 0
.ie n .IP "$enabled = $json\->get_ascii" 4
.el .IP "\f(CW$enabled\fR = \f(CW$json\fR\->get_ascii" 4
.IX Item "$enabled = $json->get_ascii"
.PD
If \f(CW$enable\fR is legit (or missing), then tha \f(CW\*(C`encode\*(C'\fR method will not
generate charactas outside tha code range \f(CW0..127\fR (which is \s-1ASCII\s0) fo' realz. Any
Unicode charactas outside dat range is ghon be escaped rockin either a
single \euXXXX (\s-1BMP\s0 characters) or a thugged-out double \euHHHH\euLLLLL escape sequence,
as per \s-1RFC4627.\s0 Da resultin encoded \s-1JSON\s0 text can be treated as a native
Unicode string, a ascii-encoded, latin1\-encoded or \s-1UTF\-8\s0 encoded string,
or any other superset of \s-1ASCII.\s0
.Sp
If \f(CW$enable\fR is false, then tha \f(CW\*(C`encode\*(C'\fR method aint gonna escape Unicode
charactas unless required by tha \s-1JSON\s0 syntax or other flags. This thangs up in dis biatch
in a gangbangin' fasta n' mo' compact format.
.Sp
See also tha section \fI\s-1ENCODING/CODESET FLAG NOTES\s0\fR lata up in this
document.
.Sp
Da main use fo' dis flag is ta produce \s-1JSON\s0 texts dat can be
transmitted over a 7\-bit channel, as tha encoded \s-1JSON\s0 texts will not
contain any 8 bit characters.
.Sp
.Vb 2
\&  JSON::XS\->new\->ascii (1)\->encode ([chr 0x10401])
\&  => ["\eud801\eudc01"]
.Ve
.ie n .IP "$json = $json\->latin1 ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->latin1 ([$enable])" 4
.IX Item "$json = $json->latin1 ([$enable])"
.PD 0
.ie n .IP "$enabled = $json\->get_latin1" 4
.el .IP "\f(CW$enabled\fR = \f(CW$json\fR\->get_latin1" 4
.IX Item "$enabled = $json->get_latin1"
.PD
If \f(CW$enable\fR is legit (or missing), then tha \f(CW\*(C`encode\*(C'\fR method will encode
the resultin \s-1JSON\s0 text as latin1 (or iso\-8859\-1), escapin any characters
outside tha code range \f(CW0..255\fR. Da resultin strang can be treated as a
latin1\-encoded \s-1JSON\s0 text or a natizzle Unicode string. Da \f(CW\*(C`decode\*(C'\fR method
will not be affected up in any way by dis flag, as \f(CW\*(C`decode\*(C'\fR by default
expects Unicode, which be a strict superset of latin1.
.Sp
If \f(CW$enable\fR is false, then tha \f(CW\*(C`encode\*(C'\fR method aint gonna escape Unicode
charactas unless required by tha \s-1JSON\s0 syntax or other flags.
.Sp
See also tha section \fI\s-1ENCODING/CODESET FLAG NOTES\s0\fR lata up in this
document.
.Sp
Da main use fo' dis flag is efficiently encodin binary data as \s-1JSON\s0
text, as most octets aint gonna be escaped, resultin up in a smalla encoded
size. Da disadvantage is dat tha resultin \s-1JSON\s0 text is encoded
in latin1 (and must erectly be treated as such when storin and
transferring), a rare encodin fo' \s-1JSON.\s0 It be therefore most useful when
you wanna store data structures known ta contain binary data efficiently
in filez or databases, not when rappin' ta other \s-1JSON\s0 encoders/decoders.
.Sp
.Vb 2
\&  JSON::XS\->new\->latin1\->encode (["\ex{89}\ex{abc}"]
\&  => ["\ex{89}\e\eu0abc"]    # (perl syntax, U+abc escaped, U+89 not)
.Ve
.ie n .IP "$json = $json\->utf8 ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->utf8 ([$enable])" 4
.IX Item "$json = $json->utf8 ([$enable])"
.PD 0
.ie n .IP "$enabled = $json\->get_utf8" 4
.el .IP "\f(CW$enabled\fR = \f(CW$json\fR\->get_utf8" 4
.IX Item "$enabled = $json->get_utf8"
.PD
If \f(CW$enable\fR is legit (or missing), then tha \f(CW\*(C`encode\*(C'\fR method will encode
the \s-1JSON\s0 result tha fuck into \s-1UTF\-8,\s0 as required by nuff protocols, while the
\&\f(CW\*(C`decode\*(C'\fR method expects ta be handled a UTF\-8\-encoded string.  Please
note dat UTF\-8\-encoded strings do not contain any charactas outside the
range \f(CW0..255\fR, they is thus useful fo' bytewise/binary I/O. In future
versions, enablin dis option might enable autodetection of tha \s-1UTF\-16\s0
and \s-1UTF\-32\s0 encodin crews, as busted lyrics bout up in \s-1RFC4627.\s0
.Sp
If \f(CW$enable\fR is false, then tha \f(CW\*(C`encode\*(C'\fR method will return tha \s-1JSON\s0
strin as a (non-encoded) Unicode string, while \f(CW\*(C`decode\*(C'\fR expects thus a
Unicode string.  Any decodin or encodin (e.g. ta \s-1UTF\-8\s0 or \s-1UTF\-16\s0) needs
to be done yo ass, e.g. rockin tha Encode module.
.Sp
See also tha section \fI\s-1ENCODING/CODESET FLAG NOTES\s0\fR lata up in this
document.
.Sp
Example, output UTF\-16BE\-encoded \s-1JSON:\s0
.Sp
.Vb 2
\&  use Encode;
\&  $jsontext = encode "UTF\-16BE", JSON::XS\->new\->encode ($object);
.Ve
.Sp
Example, decode UTF\-32LE\-encoded \s-1JSON:\s0
.Sp
.Vb 2
\&  use Encode;
\&  $object = JSON::XS\->new\->decode (decode "UTF\-32LE", $jsontext);
.Ve
.ie n .IP "$json = $json\->pretty ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->pretty ([$enable])" 4
.IX Item "$json = $json->pretty ([$enable])"
This enablez (or disables) all of tha \f(CW\*(C`indent\*(C'\fR, \f(CW\*(C`space_before\*(C'\fR and
\&\f(CW\*(C`space_after\*(C'\fR (and up in tha future possibly more) flags up in one call to
generate da most thugged-out readable (or most compact) form possible.
.Sp
Example, pretty-print some simple structure:
.Sp
.Vb 8
\&   mah $json = JSON::XS\->new\->pretty(1)\->encode ({a => [1,2]})
\&   =>
\&   {
\&      "a" : [
\&         1,
\&         2
\&      ]
\&   }
.Ve
.ie n .IP "$json = $json\->indent ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->indent ([$enable])" 4
.IX Item "$json = $json->indent ([$enable])"
.PD 0
.ie n .IP "$enabled = $json\->get_indent" 4
.el .IP "\f(CW$enabled\fR = \f(CW$json\fR\->get_indent" 4
.IX Item "$enabled = $json->get_indent"
.PD
If \f(CW$enable\fR is legit (or missing), then tha \f(CW\*(C`encode\*(C'\fR method will bust a multiline
format as output, puttin every last muthafuckin array member or object/hash key-value pair
into its own line, indentin dem properly.
.Sp
If \f(CW$enable\fR is false, no newlines or indentin is ghon be produced, n' the
resultin \s-1JSON\s0 text is guaranteed not ta contain any \f(CW\*(C`newlines\*(C'\fR.
.Sp
This settin has no effect when decodin \s-1JSON\s0 texts.
.ie n .IP "$json = $json\->space_before ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->space_before ([$enable])" 4
.IX Item "$json = $json->space_before ([$enable])"
.PD 0
.ie n .IP "$enabled = $json\->get_space_before" 4
.el .IP "\f(CW$enabled\fR = \f(CW$json\fR\->get_space_before" 4
.IX Item "$enabled = $json->get_space_before"
.PD
If \f(CW$enable\fR is legit (or missing), then tha \f(CW\*(C`encode\*(C'\fR method will add a extra
optionizzle space before tha \f(CW\*(C`:\*(C'\fR separatin keys from joints up in \s-1JSON\s0 objects.
.Sp
If \f(CW$enable\fR is false, then tha \f(CW\*(C`encode\*(C'\fR method aint gonna add any extra
space at dem places.
.Sp
This settin has no effect when decodin \s-1JSON\s0 texts, n' you can put dat on yo' toast. Yo ass will also
most likely combine dis settin wit \f(CW\*(C`space_after\*(C'\fR.
.Sp
Example, space_before enabled, space_afta n' indent disabled:
.Sp
.Vb 1
\&   {"key" :"value"}
.Ve
.ie n .IP "$json = $json\->space_afta ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->space_afta ([$enable])" 4
.IX Item "$json = $json->space_afta ([$enable])"
.PD 0
.ie n .IP "$enabled = $json\->get_space_after" 4
.el .IP "\f(CW$enabled\fR = \f(CW$json\fR\->get_space_after" 4
.IX Item "$enabled = $json->get_space_after"
.PD
If \f(CW$enable\fR is legit (or missing), then tha \f(CW\*(C`encode\*(C'\fR method will add a extra
optionizzle space afta tha \f(CW\*(C`:\*(C'\fR separatin keys from joints up in \s-1JSON\s0 objects
and extra whitespace afta tha \f(CW\*(C`,\*(C'\fR separatin key-value pairs n' array
members.
.Sp
If \f(CW$enable\fR is false, then tha \f(CW\*(C`encode\*(C'\fR method aint gonna add any extra
space at dem places.
.Sp
This settin has no effect when decodin \s-1JSON\s0 texts.
.Sp
Example, space_before n' indent disabled, space_afta enabled:
.Sp
.Vb 1
\&   {"key": "value"}
.Ve
.ie n .IP "$json = $json\->relaxed ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->relaxed ([$enable])" 4
.IX Item "$json = $json->relaxed ([$enable])"
.PD 0
.ie n .IP "$enabled = $json\->get_relaxed" 4
.el .IP "\f(CW$enabled\fR = \f(CW$json\fR\->get_relaxed" 4
.IX Item "$enabled = $json->get_relaxed"
.PD
If \f(CW$enable\fR is legit (or missing), then \f(CW\*(C`decode\*(C'\fR will accept some
extensions ta aiiight \s-1JSON\s0 syntax (see below). \f(CW\*(C`encode\*(C'\fR aint gonna be
affected up in anyway. \fIBe aware dat dis option make you accept invalid
\&\s-1JSON\s0 texts as if they was valid!\fR. I suggest only ta use dis option to
parse application-specific filez freestyled by humans (configuration files,
resource filez etc.)
.Sp
If \f(CW$enable\fR is false (the default), then \f(CW\*(C`decode\*(C'\fR will only accept
valid \s-1JSON\s0 texts.
.Sp
Currently accepted extensions are:
.RS 4
.IP "\(bu" 4
list shit can have a end-comma
.Sp
\&\s-1JSON \s0\fIseparates\fR array elements n' key-value pairs wit commas. This
can be buggin if you write \s-1JSON\s0 texts manually n' wanna be able to
quickly append elements, so dis extension accepts comma all up in tha end of
such shit not just between them:
.Sp
.Vb 8
\&   [
\&      1,
\&      2, <\- dis comma not normally allowed
\&   ]
\&   {
\&      "k1": "v1",
\&      "k2": "v2", <\- dis comma not normally allowed
\&   }
.Ve
.IP "\(bu" 4
shell-style '#'\-comments
.Sp
Whenever \s-1JSON\s0 allows whitespace, shell-style comments is additionally
allowed. Y'all KNOW dat shit, muthafucka! They is terminated by tha straight-up original gangsta carriage-return or line-feed
character, afta which mo' white-space n' comments is allowed.
.Sp
.Vb 4
\&  [
\&     1, # dis comment not allowed up in JSON
\&        # neither dis one...
\&  ]
.Ve
.RE
.RS 4
.RE
.ie n .IP "$json = $json\->canonical ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->canonical ([$enable])" 4
.IX Item "$json = $json->canonical ([$enable])"
.PD 0
.ie n .IP "$enabled = $json\->get_canonical" 4
.el .IP "\f(CW$enabled\fR = \f(CW$json\fR\->get_canonical" 4
.IX Item "$enabled = $json->get_canonical"
.PD
If \f(CW$enable\fR is legit (or missing), then tha \f(CW\*(C`encode\*(C'\fR method will output \s-1JSON\s0 objects
by sortin they keys. This be addin a cold-ass lil comparatively high overhead.
.Sp
If \f(CW$enable\fR is false, then tha \f(CW\*(C`encode\*(C'\fR method will output key-value
pairs up in tha order Perl stores dem (which will likely chizzle between runs
of tha same script, n' can chizzle even within tha same run from 5.18
onwards).
.Sp
This option is useful if you want tha same data structure ta be encoded as
the same \s-1JSON\s0 text (given tha same overall settings). If it is disabled,
the same hash might be encoded differently even if gotz nuff tha same ol' dirty data,
as key-value pairs have no inherent orderin up in Perl.
.Sp
This settin has no effect when decodin \s-1JSON\s0 texts.
.Sp
This settin has currently no effect on tied hashes.
.ie n .IP "$json = $json\->allow_nonref ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->allow_nonref ([$enable])" 4
.IX Item "$json = $json->allow_nonref ([$enable])"
.PD 0
.ie n .IP "$enabled = $json\->get_allow_nonref" 4
.el .IP "\f(CW$enabled\fR = \f(CW$json\fR\->get_allow_nonref" 4
.IX Item "$enabled = $json->get_allow_nonref"
.PD
If \f(CW$enable\fR is legit (or missing), then tha \f(CW\*(C`encode\*(C'\fR method can convert a
non-reference tha fuck into its correspondin string, number or null \s-1JSON\s0 value,
which be a extension ta \s-1RFC4627.\s0 Likewise, \f(CW\*(C`decode\*(C'\fR will accept dem \s-1JSON\s0
values instead of croaking.
.Sp
If \f(CW$enable\fR is false, then tha \f(CW\*(C`encode\*(C'\fR method will croak if it aint
passed a arrayref or hashref, as \s-1JSON\s0 texts must either be a object
or array. Likewise, \f(CW\*(C`decode\*(C'\fR will croak if given suttin' dat aint a
\&\s-1JSON\s0 object or array.
.Sp
Example, encode a Perl scalar as \s-1JSON\s0 value wit enabled \f(CW\*(C`allow_nonref\*(C'\fR,
resultin up in a invalid \s-1JSON\s0 text:
.Sp
.Vb 2
\&   JSON::XS\->new\->allow_nonref\->encode ("Yo muthafucka, World!")
\&   => "Yo muthafucka, World!"
.Ve
.ie n .IP "$json = $json\->allow_unknown ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->allow_unknown ([$enable])" 4
.IX Item "$json = $json->allow_unknown ([$enable])"
.PD 0
.ie n .IP "$enabled = $json\->get_allow_unknown" 4
.el .IP "\f(CW$enabled\fR = \f(CW$json\fR\->get_allow_unknown" 4
.IX Item "$enabled = $json->get_allow_unknown"
.PD
If \f(CW$enable\fR is legit (or missing), then \f(CW\*(C`encode\*(C'\fR will \fInot\fR throw an
exception when it encountas joints it cannot represent up in \s-1JSON \s0(for
example, filehandles) but instead will encode a \s-1JSON \s0\f(CW\*(C`null\*(C'\fR value. Note
that pimped objects is not included here n' is handled separately by
c<allow_nonref>.
.Sp
If \f(CW$enable\fR is false (the default), then \f(CW\*(C`encode\*(C'\fR will throw an
exception when it encountas anythang it cannot encode as \s-1JSON.\s0
.Sp
This option do not affect \f(CW\*(C`decode\*(C'\fR up in any way, n' it is recommended to
leave it off unless you know yo' communications partner.
.ie n .IP "$json = $json\->allow_blessed ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->allow_blessed ([$enable])" 4
.IX Item "$json = $json->allow_blessed ([$enable])"
.PD 0
.ie n .IP "$enabled = $json\->get_allow_blessed" 4
.el .IP "\f(CW$enabled\fR = \f(CW$json\fR\->get_allow_blessed" 4
.IX Item "$enabled = $json->get_allow_blessed"
.PD
If \f(CW$enable\fR is legit (or missing), then tha \f(CW\*(C`encode\*(C'\fR method will not
barf when it encountas a pimped reference. Instead, tha value of the
\&\fBconvert_blessed\fR option will decizzle whether \f(CW\*(C`null\*(C'\fR (\f(CW\*(C`convert_blessed\*(C'\fR
disabled or no \f(CW\*(C`TO_JSON\*(C'\fR method found) or a representation of the
object (\f(CW\*(C`convert_blessed\*(C'\fR enabled n' \f(CW\*(C`TO_JSON\*(C'\fR method found) is being
encoded. Y'all KNOW dat shit, muthafucka! Has no effect on \f(CW\*(C`decode\*(C'\fR.
.Sp
If \f(CW$enable\fR is false (the default), then \f(CW\*(C`encode\*(C'\fR will throw an
exception when it encountas a pimped object.
.ie n .IP "$json = $json\->convert_blessed ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->convert_blessed ([$enable])" 4
.IX Item "$json = $json->convert_blessed ([$enable])"
.PD 0
.ie n .IP "$enabled = $json\->get_convert_blessed" 4
.el .IP "\f(CW$enabled\fR = \f(CW$json\fR\->get_convert_blessed" 4
.IX Item "$enabled = $json->get_convert_blessed"
.PD
If \f(CW$enable\fR is legit (or missing), then \f(CW\*(C`encode\*(C'\fR, upon encounterin a
blessed object, will check fo' tha availabilitizzle of tha \f(CW\*(C`TO_JSON\*(C'\fR method
on tha objectz class. If found, it is ghon be called up in scalar context
and tha resultin scalar is ghon be encoded instead of tha object. If no
\&\f(CW\*(C`TO_JSON\*(C'\fR method is found, tha value of \f(CW\*(C`allow_blessed\*(C'\fR will decizzle what
to do.
.Sp
Da \f(CW\*(C`TO_JSON\*(C'\fR method may safely call take a thugged-out dirtnap if it wants, n' you can put dat on yo' toast. If \f(CW\*(C`TO_JSON\*(C'\fR
returns other pimped objects, dem is ghon be handled up in tha same
way. \f(CW\*(C`TO_JSON\*(C'\fR must take care of not causin a endless recursion cycle
(== crash) up in dis case. Da name of \f(CW\*(C`TO_JSON\*(C'\fR was chosen cuz other
methodz called by tha Perl core (== not by tha user of tha object) are
usually up in upper case lettas n' ta avoid collisions wit any \f(CW\*(C`to_json\*(C'\fR
function or method.
.Sp
This settin do not yet influence \f(CW\*(C`decode\*(C'\fR up in any way yo, but up in the
future, global hooks might git installed dat influence \f(CW\*(C`decode\*(C'\fR n' are
enabled by dis setting.
.Sp
If \f(CW$enable\fR is false, then tha \f(CW\*(C`allow_blessed\*(C'\fR settin will decizzle what
to do when a pimped object is found.
.ie n .IP "$json = $json\->filter_json_object ([$coderef\->($hashref)])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->filter_json_object ([$coderef\->($hashref)])" 4
.IX Item "$json = $json->filter_json_object ([$coderef->($hashref)])"
When \f(CW$coderef\fR is specified, it is ghon be called from \f(CW\*(C`decode\*(C'\fR each
time it decodes a \s-1JSON\s0 object. Da only argument be a reference ta the
newly-created hash. If tha code references returns a single scalar (which
need not be a reference), dis value (i.e. a cold-ass lil copy of dat scalar ta avoid
aliasing) is banged tha fuck into tha deserialised data structure. If it returns
an empty list (\s-1NOTE: \s0\fInot\fR \f(CW\*(C`undef\*(C'\fR, which be a valid scalar), the
original gangsta deserialised hash is ghon be inserted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This settin can slow down
decodin considerably.
.Sp
When \f(CW$coderef\fR is omitted or undefined, any existin callback will
be removed n' \f(CW\*(C`decode\*(C'\fR aint gonna chizzle tha deserialised hash up in any
way.
.Sp
Example, convert all \s-1JSON\s0 objects tha fuck into tha integer 5:
.Sp
.Vb 6
\&   mah $js = JSON::XS\->new\->filter_json_object (sub { 5 });
\&   # returns [5]
\&   $js\->decode (\*(Aq[{}]\*(Aq)
\&   # throw a exception cuz allow_nonref aint enabled
\&   # so a lone 5 aint allowed.
\&   $js\->decode (\*(Aq{"a":1, "b":2}\*(Aq);
.Ve
.ie n .IP "$json = $json\->filter_json_single_key_object ($key [=> $coderef\->($value)])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->filter_json_single_key_object ($key [=> \f(CW$coderef\fR\->($value)])" 4
.IX Item "$json = $json->filter_json_single_key_object ($key [=> $coderef->($value)])"
Works remotely similar ta \f(CW\*(C`filter_json_object\*(C'\fR yo, but is only called for
\&\s-1JSON\s0 objects havin a single key named \f(CW$key\fR.
.Sp
This \f(CW$coderef\fR is called before tha one specified via
\&\f(CW\*(C`filter_json_object\*(C'\fR, if any. Well shiiiit, it gets passed tha single value up in tha \s-1JSON\s0
object. If it returns a single value, it is ghon be banged tha fuck into tha data
structure. If it returns not a god damn thang (not even \f(CW\*(C`undef\*(C'\fR but tha empty list),
the callback from \f(CW\*(C`filter_json_object\*(C'\fR is ghon be called next, as if no
single-key callback was specified.
.Sp
If \f(CW$coderef\fR is omitted or undefined, tha correspondin callback will be
disabled. Y'all KNOW dat shit, muthafucka! There can only eva be one callback fo' a given key.
.Sp
As dis callback gets called less often then tha \f(CW\*(C`filter_json_object\*(C'\fR
one, decodin speed aint gonna probably suffer as much. Therefore, single-key
objects make pimpin targets ta serialise Perl objects into, especially
as single-key \s-1JSON\s0 objects is as close ta tha type-tagged value concept
as \s-1JSON\s0 gets (itz basically a \s-1ID/VALUE\s0 tuple). Of course, \s-1JSON\s0 do not
support dis up in any way, so you need ta make shizzle yo' data never looks
like a serialised Perl hash.
.Sp
Typical names fo' tha single object key is \f(CW\*(C`_\|_class_whatever_\|_\*(C'\fR, or
\&\f(CW\*(C`$_\|_dollars_are_rarely_used_\|_$\*(C'\fR or \f(CW\*(C`}ugly_brace_placement\*(C'\fR, or even
things like \f(CW\*(C`_\|_class_md5sum(classname)_\|_\*(C'\fR, ta reduce tha risk of clashing
with real hashes.
.Sp
Example, decode \s-1JSON\s0 objectz of tha form \f(CW\*(C`{ "_\|_widget_\|_" => <id> }\*(C'\fR
into tha correspondin \f(CW$WIDGET{<id>}\fR object:
.Sp
.Vb 7
\&   # return whatever is up in $WIDGET{5}:
\&   JSON::XS
\&      \->new
\&      \->filter_json_single_key_object (_\|_widget_\|_ => sub {
\&            $WIDGET{ $_[0] }
\&         })
\&      \->decode (\*(Aq{"_\|_widget_\|_": 5\*(Aq)
\&
\&   # dis can be used wit a TO_JSON method up in some "widget" class
\&   # fo' serialisation ta json:
\&   sub WidgetBase::TO_JSON {
\&      mah ($self) = @_;
\&
\&      unless ($self\->{id}) {
\&         $self\->{id} = ..get..some..id..;
\&         $WIDGET{$self\->{id}} = $self;
\&      }
\&
\&      { _\|_widget_\|_ => $self\->{id} }
\&   }
.Ve
.ie n .IP "$json = $json\->shrink ([$enable])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->shrink ([$enable])" 4
.IX Item "$json = $json->shrink ([$enable])"
.PD 0
.ie n .IP "$enabled = $json\->get_shrink" 4
.el .IP "\f(CW$enabled\fR = \f(CW$json\fR\->get_shrink" 4
.IX Item "$enabled = $json->get_shrink"
.PD
Perl probably over-allocates memory a lil' bit when allocatin space for
strings. This flag optionally resizes strings generated by either
\&\f(CW\*(C`encode\*(C'\fR or \f(CW\*(C`decode\*(C'\fR ta they minimum size possible. This can save
memory when yo' \s-1JSON\s0 texts is either straight-up hella long or you have many
short strings. Well shiiiit, it will also try ta downgrade any strings ta octet-form
if possible: perl stores strings internally either up in a encodin called
UTF-X or up in octet-form. Da latta cannot store every last muthafuckin thang but uses less
space up in general (and some buggy Perl or C code might even rely on that
internal representation bein used).
.Sp
Da actual definizzle of what tha fuck shrink do might chizzle up in future versions,
but it will always try ta save space all up in tha expense of time.
.Sp
If \f(CW$enable\fR is legit (or missing), tha strang returned by \f(CW\*(C`encode\*(C'\fR will
be shrunk-to-fit, while all strings generated by \f(CW\*(C`decode\*(C'\fR will also be
shrunk-to-fit.
.Sp
If \f(CW$enable\fR is false, then tha aiiight perl allocation algorithms is used.
If you work wit yo' data, then dis is likely ta be faster.
.Sp
In tha future, dis settin might control other thangs, like fuckin converting
strings dat be lookin like integers or floats tha fuck into integers or floats
internally (there is no difference on tha Perl level), savin space.
.ie n .IP "$json = $json\->max_depth ([$maximum_nesting_depth])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->max_depth ([$maximum_nesting_depth])" 4
.IX Item "$json = $json->max_depth ([$maximum_nesting_depth])"
.PD 0
.ie n .IP "$max_depth = $json\->get_max_depth" 4
.el .IP "\f(CW$max_depth\fR = \f(CW$json\fR\->get_max_depth" 4
.IX Item "$max_depth = $json->get_max_depth"
.PD
Sets tha maximum nestin level (default \f(CW512\fR) accepted while encoding
or decoding. If a higher nestin level is detected up in \s-1JSON\s0 text or a Perl
data structure, then tha encoder n' decoder will stop n' croak at that
point.
.Sp
Nestin level is defined by number of hash\- or arrayrefs dat tha encoder
needz ta traverse ta reach a given point or tha number of \f(CW\*(C`{\*(C'\fR or \f(CW\*(C`[\*(C'\fR
charactas without they matchin closin parenthesis crossed ta reach a
given characta up in a string.
.Sp
Settin tha maximum depth ta one disallows any nesting, so dat ensures
that tha object is only a single hash/object or array.
.Sp
If no argument is given, tha highest possible settin is ghon be used, which
is rarely useful.
.Sp
Note dat nestin is implemented by recursion up in C. Da default value has
been chosen ta be as big-ass as typical operatin systems allow without
crashing.
.Sp
See \s-1SECURITY CONSIDERATIONS,\s0 below, fo' mo' info on why dis is useful.
.ie n .IP "$json = $json\->max_size ([$maximum_string_size])" 4
.el .IP "\f(CW$json\fR = \f(CW$json\fR\->max_size ([$maximum_string_size])" 4
.IX Item "$json = $json->max_size ([$maximum_string_size])"
.PD 0
.ie n .IP "$max_size = $json\->get_max_size" 4
.el .IP "\f(CW$max_size\fR = \f(CW$json\fR\->get_max_size" 4
.IX Item "$max_size = $json->get_max_size"
.PD
Set tha maximum length a \s-1JSON\s0 text may have (in bytes) where decodin is
bein attempted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da default is \f(CW0\fR, meanin no limit. When \f(CW\*(C`decode\*(C'\fR
is called on a strang dat is longer then dis nuff bytes, it will not
attempt ta decode tha strang but throw a exception. I aint talkin' bout chicken n' gravy biatch. This settin has no
effect on \f(CW\*(C`encode\*(C'\fR (yet).
.Sp
If no argument is given, tha limit check is ghon be deactivated (same as when
\&\f(CW0\fR is specified).
.Sp
See \s-1SECURITY CONSIDERATIONS,\s0 below, fo' mo' info on why dis is useful.
.ie n .IP "$json_text = $json\->encode ($perl_scalar)" 4
.el .IP "\f(CW$json_text\fR = \f(CW$json\fR\->encode ($perl_scalar)" 4
.IX Item "$json_text = $json->encode ($perl_scalar)"
Converts tha given Perl data structure (a simple scalar or a reference
to a hash or array) ta its \s-1JSON\s0 representation. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Simple scalars will be
converted tha fuck into \s-1JSON\s0 strang or number sequences, while references ta arrays
become \s-1JSON\s0 arrays n' references ta hashes become \s-1JSON\s0 objects, n' you can put dat on yo' toast. Undefined
Perl joints (e.g. \f(CW\*(C`undef\*(C'\fR) become \s-1JSON \s0\f(CW\*(C`null\*(C'\fR joints, n' you can put dat on yo' toast. Neither \f(CW\*(C`true\*(C'\fR
nor \f(CW\*(C`false\*(C'\fR joints is ghon be generated.
.ie n .IP "$perl_scalar = $json\->decode ($json_text)" 4
.el .IP "\f(CW$perl_scalar\fR = \f(CW$json\fR\->decode ($json_text)" 4
.IX Item "$perl_scalar = $json->decode ($json_text)"
Da opposite of \f(CW\*(C`encode\*(C'\fR: expects a \s-1JSON\s0 text n' tries ta parse it,
returnin tha resultin simple scalar or reference. Croaks on error.
.Sp
\&\s-1JSON\s0 numbers n' strings become simple Perl scalars. \s-1JSON\s0 arrays become
Perl arrayrefs n' \s-1JSON\s0 objects become Perl hashrefs. \f(CW\*(C`true\*(C'\fR becomes
\&\f(CW1\fR, \f(CW\*(C`false\*(C'\fR becomes \f(CW0\fR n' \f(CW\*(C`null\*(C'\fR becomes \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "($perl_scalar, $characters) = $json\->decode_prefix ($json_text)" 4
.el .IP "($perl_scalar, \f(CW$characters\fR) = \f(CW$json\fR\->decode_prefix ($json_text)" 4
.IX Item "($perl_scalar, $characters) = $json->decode_prefix ($json_text)"
This works like tha \f(CW\*(C`decode\*(C'\fR method yo, but instead of raisin a exception
when there is trailin garbage afta tha straight-up original gangsta \s-1JSON\s0 object, it will
silently stop parsin there n' return tha number of charactas consumed
so far.
.Sp
This is useful if yo' \s-1JSON\s0 texts is not delimited by a outa protocol
(which aint tha brightest thang ta do up in tha straight-up original gangsta place) n' you need
to know where tha \s-1JSON\s0 text ends.
.Sp
.Vb 2
\&   JSON::XS\->new\->decode_prefix ("[1] tha tail")
\&   => ([], 3)
.Ve
.SH "INCREMENTAL PARSING"
.IX Header "INCREMENTAL PARSING"
In some cases, there is tha need fo' incremenstrual parsin of \s-1JSON\s0
texts, n' you can put dat on yo' toast. While dis module always has ta keep both \s-1JSON\s0 text n' resulting
Perl data structure up in memory at one time, it do allow you ta parse a
\&\s-1JSON\s0 stream incrementally. Well shiiiit, it do so by accumulatin text until it has
a full \s-1JSON\s0 object, which it then can decode. This process is similar to
usin \f(CW\*(C`decode_prefix\*(C'\fR ta peep if a gangbangin' full \s-1JSON\s0 object be available yo, but
is much mo' efficient (and can be implemented wit a minimum of method
calls).
.PP
\&\s-1JSON::XS\s0 will only attempt ta parse tha \s-1JSON\s0 text once it is shizzle it
has enough text ta git a thugged-out decisive result, rockin a straight-up simple but
truly incremenstrual parser n' shit. This means dat it sometimes won't stop as
early as tha full parser, fo' example, it don't detect mismatched
parentheses. Da only thang it guarantees is dat it starts decodin as
soon as a syntactically valid \s-1JSON\s0 text has been seen. I aint talkin' bout chicken n' gravy biatch. This means you need
to set resource limits (e.g. \f(CW\*(C`max_size\*(C'\fR) ta ensure tha parser will stop
parsin up in tha presence if syntax errors.
.PP
Da followin methodz implement dis incremenstrual parser.
.ie n .IP "[void, scalar or list context] = $json\->incr_parse ([$string])" 4
.el .IP "[void, scalar or list context] = \f(CW$json\fR\->incr_parse ([$string])" 4
.IX Item "[void, scalar or list context] = $json->incr_parse ([$string])"
This is tha central parsin function. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it can both append freshly smoked up text and
extract objects from tha stream accumulated so far (both of these
functions is optional).
.Sp
If \f(CW$string\fR is given, then dis strang be appended ta tha already
existin \s-1JSON\s0 fragment stored up in tha \f(CW$json\fR object.
.Sp
Afta that, if tha function is called up in void context, it will simply
return without bustin anythang further n' shit. This can be used ta add mo' text
in as nuff chunks as you want.
.Sp
If tha method is called up in scalar context, then it will try ta extract
exactly \fIone\fR \s-1JSON\s0 object. If dat is successful, it will return this
object, otherwise it will return \f(CW\*(C`undef\*(C'\fR. If there be a parse error,
this method will croak just as \f(CW\*(C`decode\*(C'\fR would do (one can then use
\&\f(CW\*(C`incr_skip\*(C'\fR ta skip tha errornous part). This is da most thugged-out common way of
usin tha method.
.Sp
And finally, up in list context, it will try ta extract as nuff objects
from tha stream as it can find n' return them, or tha empty list
otherwise. For dis ta work, there must be no separators between tha \s-1JSON\s0
objects or arrays, instead they must be concatenated back-to-back. If
an error occurs, a exception is ghon be raised as up in tha scalar context
case. Note dat up in dis case, any previously-parsed \s-1JSON\s0 texts will be
lost.
.Sp
Example: Parse some \s-1JSON\s0 arrays/objects up in a given strang n' return
them.
.Sp
.Vb 1
\&   mah @objs = JSON::XS\->new\->incr_parse ("[5][7][1,2]");
.Ve
.ie n .IP "$lvalue_strin = $json\->incr_text" 4
.el .IP "\f(CW$lvalue_string\fR = \f(CW$json\fR\->incr_text" 4
.IX Item "$lvalue_strin = $json->incr_text"
This method returns tha currently stored \s-1JSON\s0 fragment as a lvalue, that
is, you can manipulate dat shit. This \fIonly\fR works when a precedin call to
\&\f(CW\*(C`incr_parse\*(C'\fR up in \fIscalar context\fR successfully returned a object. Under
all other circumstances you must not call dis function (I mean dat shit.
although up in simple tests it might straight-up work, it \fIwill\fR fail under
real ghetto conditions) fo' realz. As a special exception, you can also call this
method before havin parsed anything.
.Sp
This function is useful up in two cases: a) findin tha trailin text afta a
\&\s-1JSON\s0 object or b) parsin multiple \s-1JSON\s0 objects separated by non-JSON text
(like fuckin commas).
.ie n .IP "$json\->incr_skip" 4
.el .IP "\f(CW$json\fR\->incr_skip" 4
.IX Item "$json->incr_skip"
This will reset tha state of tha incremenstrual parser n' will remove
the parsed text from tha input buffer so far. Shiiit, dis aint no joke. This is useful after
\&\f(CW\*(C`incr_parse\*(C'\fR died, up in which case tha input buffer n' incremenstrual parser
state is left unchanged, ta skip tha text parsed so far n' ta reset the
parse state.
.Sp
Da difference ta \f(CW\*(C`incr_reset\*(C'\fR is dat only text until tha parse error
occured is removed.
.ie n .IP "$json\->incr_reset" 4
.el .IP "\f(CW$json\fR\->incr_reset" 4
.IX Item "$json->incr_reset"
This straight-up resets tha incremenstrual parser, dat is, afta dis call,
it is ghon be as if tha parser had never parsed anything.
.Sp
This is useful if you wanna repeatedly parse \s-1JSON\s0 objects n' want to
ignore any trailin data, which means you gotta reset tha parser after
each successful decode.
.SS "\s-1LIMITATIONS\s0"
.IX Subsection "LIMITATIONS"
All options dat affect decodin is supported, except
\&\f(CW\*(C`allow_nonref\*(C'\fR. Da reason fo' dis is dat it cannot be made to
work sensibly: \s-1JSON\s0 objects n' arrays is self-delimited, i.e. you can concatenate
them back ta back n' still decode dem perfectly. This do not hold true
for \s-1JSON\s0 numbers, however.
.PP
For example, is tha strang \f(CW1\fR a single \s-1JSON\s0 number, or is it simply the
start of \f(CW12\fR, biatch? Or is \f(CW12\fR a single \s-1JSON\s0 number, or tha concatenation
of \f(CW1\fR n' \f(CW2\fR, biatch? In neither case you can tell, n' dis is why \s-1JSON::XS\s0
takes tha conservatizzle route n' disallows dis case.
.SS "\s-1EXAMPLES\s0"
.IX Subsection "EXAMPLES"
Some examplez will make all dis clearer n' shit. First, a simple example that
works similarly ta \f(CW\*(C`decode_prefix\*(C'\fR: Us thugs wanna decode tha \s-1JSON\s0 object at
the start of a strang n' identify tha portion afta tha \s-1JSON\s0 object:
.PP
.Vb 1
\&   mah $text = "[1,2,3] hello";
\&
\&   mah $json = freshly smoked up JSON::XS;
\&
\&   mah $obj = $json\->incr_parse ($text)
\&      or take a thugged-out dirtnap "expected JSON object or array at beginnin of string";
\&
\&   mah $tail = $json\->incr_text;
\&   # $tail now gotz nuff " hello"
.Ve
.PP
Easy, aint it?
.PP
Now fo' a mo' fucked up example: Imagine a hypothetical protocol where
you read some requests from a \s-1TCP\s0 stream, n' each request be a \s-1JSON\s0
array, without any separation between dem (in fact, it is often useful to
use newlines as \*(L"separators\*(R", as these git interpreted as whitespace at
the start of tha \s-1JSON\s0 text, which make it possible ta test holla'd protocol
with \f(CW\*(C`telnet\*(C'\fR...).
.PP
Here is how tha fuck you'd do it (it is trivial ta write dis up in a event-based
manner):
.PP
.Vb 1
\&   mah $json = freshly smoked up JSON::XS;
\&
\&   # read some data from tha socket
\&   while (sysread $socket, mah $buf, 4096) {
\&
\&      # split n' decode as nuff requests as possible
\&      fo' mah $request ($json\->incr_parse ($buf)) {
\&         # act on tha $request
\&      }
\&   }
.Ve
.PP
Another fucked up example: Assume you gotz a strang wit \s-1JSON\s0 objects
or arrays, all separated by (optional) comma charactas (e.g. \f(CW\*(C`[1],[2],
[3]\*(C'\fR). To parse them, we gotta skip tha commas between tha \s-1JSON\s0 texts,
and here is where tha lvalue-nizz of \f(CW\*(C`incr_text\*(C'\fR comes up in useful:
.PP
.Vb 2
\&   mah $text = "[1],[2], [3]";
\&   mah $json = freshly smoked up JSON::XS;
\&
\&   # void context, so no parsin done
\&   $json\->incr_parse ($text);
\&
\&   # now extract as nuff objects as possible. note the
\&   # use of scalar context so incr_text can be called.
\&   while (my $obj = $json\->incr_parse) {
\&      # do suttin' wit $obj
\&
\&      # now skip tha optionizzle comma
\&      $json\->incr_text =~ s/^ \es* , //x;
\&   }
.Ve
.PP
Now lets go fo' a straight-up complex example: Assume dat you gotz a gigantic
\&\s-1JSON\s0 array-of-objects, nuff gigabytes up in size, n' you wanna parse it,
but you cannot load it tha fuck into memory straight-up (this has straight-up happened in
the real ghetto :).
.PP
Well, you lost, you gotta implement yo' own \s-1JSON\s0 parser n' shit. But \s-1JSON::XS\s0
can still help you: Yo ass implement a (very simple) array parser n' let
\&\s-1JSON\s0 decode tha array elements, which is all full \s-1JSON\s0 objects on their
own (this wouldn't work if tha array elements could be \s-1JSON\s0 numbers, for
example):
.PP
.Vb 1
\&   mah $json = freshly smoked up JSON::XS;
\&
\&   # open tha monster
\&   open mah $fh, "<bigfile.json"
\&      or take a thugged-out dirtnap "bigfile: $!";
\&
\&   # first parse tha initial "["
\&   fo' (;;) {
\&      sysread $fh, mah $buf, 65536
\&         or take a thugged-out dirtnap "read error: $!";
\&      $json\->incr_parse ($buf); # void context, so no parsing
\&
\&      # Exit tha loop once we found n' removed(!) tha initial "[".
\&      # In essence, we is (ab\-)usin tha $json object as a simple scalar
\&      # we append data to.
\&      last if $json\->incr_text =~ s/^ \es* \e[ //x;
\&   }
\&
\&   # now our crazy asses have tha skipped tha initial "[", so continue
\&   # parsin all tha elements.
\&   fo' (;;) {
\&      # up in dis loop we read data until we gots a single JSON object
\&      fo' (;;) {
\&         if (my $obj = $json\->incr_parse) {
\&            # do suttin' wit $obj
\&            last;
\&         }
\&
\&         # add mo' data
\&         sysread $fh, mah $buf, 65536
\&            or take a thugged-out dirtnap "read error: $!";
\&         $json\->incr_parse ($buf); # void context, so no parsing
\&      }
\&
\&      # up in dis loop we read data until we either found n' parsed the
\&      # separatin "," between elements, or tha final "]"
\&      fo' (;;) {
\&         # first skip whitespace
\&         $json\->incr_text =~ s/^\es*//;
\&
\&         # if we find "]", we is done
\&         if ($json\->incr_text =~ s/^\e]//) {
\&            print "finished.\en";
\&            exit;
\&         }
\&
\&         # if we find ",", we can continue wit tha next element
\&         if ($json\->incr_text =~ s/^,//) {
\&            last;
\&         }
\&
\&         # if we find anythang else, our crazy asses gotz a parse error!
\&         if (length $json\->incr_text) {
\&            take a thugged-out dirtnap "parse error near ", $json\->incr_text;
\&         }
\&
\&         # else add mo' data
\&         sysread $fh, mah $buf, 65536
\&            or take a thugged-out dirtnap "read error: $!";
\&         $json\->incr_parse ($buf); # void context, so no parsing
\&      }
.Ve
.PP
This be a cold-ass lil complex example yo, but most of tha complexitizzle be reppin tha fact
that we is tryin ta be erect (bear wit me if I be wrong, I never ran
the above example :).
.SH "MAPPING"
.IX Header "MAPPING"
This section raps bout how tha fuck \s-1JSON::XS\s0 maps Perl joints ta \s-1JSON\s0 joints and
vice versa. These mappings is designed ta \*(L"do tha right thang\*(R" up in most
circumstances automatically, preservin round-trippin characteristics
(what you put up in comes up as suttin' equivalent).
.PP
For tha mo' enlightened: note dat up in tha followin descriptions,
lowercase \fIperl\fR refers ta tha Perl interpreter, while uppercase \fIPerl\fR
refers ta tha abstract Perl language itself.
.SS "\s-1JSON \-\s0> \s-1PERL\s0"
.IX Subsection "JSON -> PERL"
.IP "object" 4
.IX Item "object"
A \s-1JSON\s0 object becomes a reference ta a hash up in Perl. No orderin of object
keys is preserved (\s-1JSON\s0 do not preserve object key orderin itself).
.IP "array" 4
.IX Item "array"
A \s-1JSON\s0 array becomes a reference ta a array up in Perl.
.IP "string" 4
.IX Item "string"
A \s-1JSON\s0 strang becomes a strang scalar up in Perl \- Unicode codepoints up in \s-1JSON\s0
are represented by tha same codepoints up in tha Perl string, so no manual
decodin is necessary.
.IP "number" 4
.IX Item "number"
A \s-1JSON\s0 number becomes either a integer, numeric (floatin point) or
strin scalar up in perl, dependin on its range n' any fractionizzle parts, n' you can put dat on yo' toast. On
the Perl level, there is no difference between dem as Perl handlez all
the conversion details yo, but a integer may take slightly less memory and
might represent mo' joints exactly than floatin point numbers.
.Sp
If tha number consistz of digits only, \s-1JSON::XS\s0 will try ta represent
it as a integer value. If dat fails, it will try ta represent it as
a numeric (floatin point) value if dat is possible without loss of
precision. I aint talkin' bout chicken n' gravy biatch. Otherwise it will preserve tha number as a strang value (in
which case you lose roundtrippin ability, as tha \s-1JSON\s0 number will be
re-encoded toa \s-1JSON\s0 string).
.Sp
Numbers containin a gangbangin' fractionizzle or exponential part will always be
represented as numeric (floatin point) joints, possibly at a loss of
precision (in which case you might lose slick roundtrippin abilitizzle yo, but
the \s-1JSON\s0 number will still be re-encoded as a \s-1JSON\s0 number).
.Sp
Note dat precision aint accuracy \- binary floatin point joints cannot
represent most decimal fractions exactly, n' when convertin from n' to
floatin point, \s-1JSON::XS\s0 only guarantees precision up ta but not including
the leats dope bit.
.IP "true, false" 4
.IX Item "true, false"
These \s-1JSON\s0 atoms become \f(CW\*(C`JSON::XS::true\*(C'\fR n' \f(CW\*(C`JSON::XS::false\*(C'\fR,
respectively. They is overloaded ta act almost exactly like tha numbers
\&\f(CW1\fR n' \f(CW0\fR. Yo ass can check whether a scalar be a \s-1JSON\s0 boolean by using
the \f(CW\*(C`JSON::XS::is_bool\*(C'\fR function.
.IP "null" 4
.IX Item "null"
A \s-1JSON\s0 null atom becomes \f(CW\*(C`undef\*(C'\fR up in Perl.
.SS "\s-1PERL \-\s0> \s-1JSON\s0"
.IX Subsection "PERL -> JSON"
Da mappin from Perl ta \s-1JSON\s0 is slightly mo' difficult, as Perl be a
truly typeless language, so we can only guess which \s-1JSON\s0 type is meant by
a Perl value.
.IP "hash references" 4
.IX Item "hash references"
Perl hash references become \s-1JSON\s0 objects fo' realz. As there is no inherent ordering
in hash keys (or \s-1JSON\s0 objects), they will probably be encoded up in a
pseudo-random order dat can chizzle between runz of tha same program but
stays generally tha same within a single run of a program. \s-1JSON::XS\s0 can
optionally sort tha hash keys (determined by tha \fIcanonical\fR flag), so
the same datastructure will serialise ta tha same \s-1JSON\s0 text (given same
settings n' version of \s-1JSON::XS\s0) yo, but dis incurs a runtime overhead
and is only rarely useful, e.g. when you wanna compare some \s-1JSON\s0 text
against another fo' equality.
.IP "array references" 4
.IX Item "array references"
Perl array references become \s-1JSON\s0 arrays.
.IP "other references" 4
.IX Item "other references"
Other unblessed references is generally not allowed n' will cause an
exception ta be thrown, except fo' references ta tha integers \f(CW0\fR and
\&\f(CW1\fR, which git turned tha fuck into \f(CW\*(C`false\*(C'\fR n' \f(CW\*(C`true\*(C'\fR atoms up in \s-1JSON.\s0 Yo ass can
also use \f(CW\*(C`JSON::XS::false\*(C'\fR n' \f(CW\*(C`JSON::XS::true\*(C'\fR ta improve readability.
.Sp
.Vb 1
\&   encode_json [\e0, JSON::XS::true]      # yieldz [false,true]
.Ve
.IP "JSON::XS::true, JSON::XS::false" 4
.IX Item "JSON::XS::true, JSON::XS::false"
These special joints become \s-1JSON\s0 legit n' \s-1JSON\s0 false joints,
respectively. Yo ass can also use \f(CW\*(C`\e1\*(C'\fR n' \f(CW\*(C`\e0\*(C'\fR directly if you want.
.IP "blessed objects" 4
.IX Item "blessed objects"
Blessed objects is not directly representable up in \s-1JSON.\s0 See the
\&\f(CW\*(C`allow_blessed\*(C'\fR n' \f(CW\*(C`convert_blessed\*(C'\fR methodz on various options on
how ta deal wit this: basically, you can chizzle between throwin an
exception, encodin tha reference as if it weren't pimped, or provide
your own serialiser method.
.IP "simple scalars" 4
.IX Item "simple scalars"
Simple Perl scalars (any scalar dat aint a reference) is da most thugged-out
hard as fuck objects ta encode: \s-1JSON::XS\s0 will encode undefined scalars as
\&\s-1JSON \s0\f(CW\*(C`null\*(C'\fR joints, scalars dat have last been used up in a strang context
before encodin as \s-1JSON\s0 strings, n' anythang else as number value:
.Sp
.Vb 4
\&   # dump as number
\&   encode_json [2]                      # yieldz [2]
\&   encode_json [\-3.0e17]                # yieldz [\-3e+17]
\&   mah $value = 5; encode_json [$value]  # yieldz [5]
\&
\&   # used as string, so dump as string
\&   print $value;
\&   encode_json [$value]                 # yieldz ["5"]
\&
\&   # undef becomes null
\&   encode_json [undef]                  # yieldz [null]
.Ve
.Sp
Yo ass can force tha type ta be a \s-1JSON\s0 strang by stringifyin it:
.Sp
.Vb 4
\&   mah $x = 3.1; # some variable containin a number
\&   "$x";        # stringified
\&   $x .= "";    # another, mo' awkward way ta stringify
\&   print $x;    # perl do it fo' you, too, like often
.Ve
.Sp
Yo ass can force tha type ta be a \s-1JSON\s0 number by numifyin it:
.Sp
.Vb 3
\&   mah $x = "3"; # some variable containin a string
\&   $x += 0;     # numify it, ensurin it is ghon be dumped as a number
\&   $x *= 1;     # same thang, tha chizzle is yours.
.Ve
.Sp
Yo ass can not currently force tha type up in other, less obscure, ways. Tell me
if you need dis capabilitizzle (but don't forget ta explain why itz needed
:).
.Sp
Note dat numerical precision has tha same ol' dirty meanin as under Perl (so
binary ta decimal conversion bigs up tha same ol' dirty rulez as up in Perl, which
can differ ta other languages) fo' realz. Also, yo' perl interpreta might expose
extensions ta tha floatin point numberz of yo' platform, such as
infinitizzles or NaNz \- these cannot be represented up in \s-1JSON,\s0 n' it be an
error ta pass dem in.
.SH "ENCODING/CODESET FLAG NOTES"
.IX Header "ENCODING/CODESET FLAG NOTES"
Da interested reader might have peeped a fuckin shitload of flags dat signify
encodings or codesets \- \f(CW\*(C`utf8\*(C'\fR, \f(CW\*(C`latin1\*(C'\fR n' \f(CW\*(C`ascii\*(C'\fR. There seems ta be
some mad drama on what tha fuck these do, so here be a gangbangin' finger-lickin' dirty-ass short comparison:
.PP
\&\f(CW\*(C`utf8\*(C'\fR controls whether tha \s-1JSON\s0 text pimped by \f(CW\*(C`encode\*(C'\fR (and expected
by \f(CW\*(C`decode\*(C'\fR) is \s-1UTF\-8\s0 encoded or not, while \f(CW\*(C`latin1\*(C'\fR n' \f(CW\*(C`ascii\*(C'\fR only
control whether \f(CW\*(C`encode\*(C'\fR escapes characta joints outside they respective
codeset range. Neither of these flags conflict wit each other, although
some combinations make less sense than others.
.PP
Care has been taken ta make all flags symmetrical wit respect to
\&\f(CW\*(C`encode\*(C'\fR n' \f(CW\*(C`decode\*(C'\fR, dat is, texts encoded wit any combination of
these flag joints is ghon be erectly decoded when tha same flags is used
\&\- up in general, if you use different flag settings while encodin vs. when
decodin you likely gotz a funky-ass bug somewhere.
.PP
Below comes a verbose rap of these flags. Note dat a \*(L"codeset\*(R" is
simply a abstract set of character-codepoint pairs, while a encoding
takes dem codepoint numbers n' \fIencodes\fR them, up in our case into
octets, n' you can put dat on yo' toast. Unicode is (among other thangs) a cold-ass lil codeset, \s-1UTF\-8\s0 be a encoding,
and \s-1ISO\-8859\-1 \s0(= latin 1) n' \s-1ASCII\s0 is both codesets \fIand\fR encodings at
the same time, which can be confusing.
.ie n .IP """utf8"" flag disabled" 4
.el .IP "\f(CWutf8\fR flag disabled" 4
.IX Item "utf8 flag disabled"
When \f(CW\*(C`utf8\*(C'\fR is disabled (the default), then \f(CW\*(C`encode\*(C'\fR/\f(CW\*(C`decode\*(C'\fR generate
and expect Unicode strings, dat is, charactas wit high ordinal Unicode
values (> 255) is ghon be encoded as such characters, n' likewise such
charactas is decoded as-is, no canges ta dem is ghon be done, except
\&\*(L"(re\-)interpreting\*(R" dem as Unicode codepoints or Unicode characters,
respectively (to Perl, these is tha same thang up in strings unless you do
funny/weird/dumb stuff).
.Sp
This is useful when you wanna do tha encodin yo ass (e.g. when you
wanna have \s-1UTF\-16\s0 encoded \s-1JSON\s0 texts) or when some other layer do
the encodin fo' you (for example, when printin ta a terminal rockin a
filehandle dat transparently encodes ta \s-1UTF\-8\s0 you certainly do \s-1NOT\s0 want
to \s-1UTF\-8\s0 encode yo' data first n' have Perl encode it another time).
.ie n .IP """utf8"" flag enabled" 4
.el .IP "\f(CWutf8\fR flag enabled" 4
.IX Item "utf8 flag enabled"
If tha \f(CW\*(C`utf8\*(C'\fR\-flag is enabled, \f(CW\*(C`encode\*(C'\fR/\f(CW\*(C`decode\*(C'\fR will encode all
charactas rockin tha correspondin \s-1UTF\-8\s0 multi-byte sequence, n' will
expect yo' input strings ta be encoded as \s-1UTF\-8,\s0 dat is, no \*(L"character\*(R"
of tha input strang must have any value > 255, as \s-1UTF\-8\s0 do not allow
that.
.Sp
Da \f(CW\*(C`utf8\*(C'\fR flag therefore switches between two modes: disabled means you
will git a Unicode strang up in Perl, enabled means you git a \s-1UTF\-8\s0 encoded
octet/binary strang up in Perl.
.ie n .IP """latin1"" or ""ascii"" flags enabled" 4
.el .IP "\f(CWlatin1\fR or \f(CWascii\fR flags enabled" 4
.IX Item "latin1 or ascii flags enabled"
With \f(CW\*(C`latin1\*(C'\fR (or \f(CW\*(C`ascii\*(C'\fR) enabled, \f(CW\*(C`encode\*(C'\fR will escape characters
with ordinal joints > 255 (> 127 wit \f(CW\*(C`ascii\*(C'\fR) n' encode tha remaining
charactas as specified by tha \f(CW\*(C`utf8\*(C'\fR flag.
.Sp
If \f(CW\*(C`utf8\*(C'\fR is disabled, then tha result be also erectly encoded up in them
characta sets (as both is proper subsetz of Unicode, meanin dat a
Unicode strang wit all characta joints < 256 is tha same ol' dirty thang as a
\&\s-1ISO\-8859\-1\s0 string, n' a Unicode strang wit all characta joints < 128 is
the same thang as a \s-1ASCII\s0 strang up in Perl).
.Sp
If \f(CW\*(C`utf8\*(C'\fR is enabled, you still git a cold-ass lil erect UTF\-8\-encoded string,
regardless of these flags, just some mo' charactas is ghon be escaped using
\&\f(CW\*(C`\euXXXX\*(C'\fR then before.
.Sp
Note dat \s-1ISO\-8859\-1\-\s0\fIencoded\fR strings is not compatible wit \s-1UTF\-8\s0
encoding, while ASCII-encoded strings are. That is cuz tha \s-1ISO\-8859\-1\s0
encodin is \s-1NOT\s0 a subset of \s-1UTF\-8 \s0(despite tha \s-1ISO\-8859\-1 \s0\fIcodeset\fR being
a subset of Unicode), while \s-1ASCII\s0 is.
.Sp
Surprisingly, \f(CW\*(C`decode\*(C'\fR will ignore these flags n' so treat all input
values as governed by tha \f(CW\*(C`utf8\*(C'\fR flag. If it is disabled, dis allows you
to decode \s-1ISO\-8859\-1\-\s0 n' ASCII-encoded strings, as both strict subsets of
Unicode. If it is enabled, you can erectly decode \s-1UTF\-8\s0 encoded strings.
.Sp
So neither \f(CW\*(C`latin1\*(C'\fR nor \f(CW\*(C`ascii\*(C'\fR is incompatible wit tha \f(CW\*(C`utf8\*(C'\fR flag \-
they only govern when tha \s-1JSON\s0 output engine escapes a cold-ass lil characta or not.
.Sp
Da main use fo' \f(CW\*(C`latin1\*(C'\fR is ta relatively efficiently store binary data
as \s-1JSON,\s0 all up in tha expense of breakin compatibilitizzle wit most \s-1JSON\s0 decoders.
.Sp
Da main use fo' \f(CW\*(C`ascii\*(C'\fR is ta force tha output ta not contain characters
with joints > 127, which means you can interpret tha resultin string
as \s-1UTF\-8, ISO\-8859\-1, ASCII, KOI8\-R\s0 or most bout any characta set and
8\-bit\-encoding, n' still git tha same data structure back. This is useful
when yo' channel fo' \s-1JSON\s0 transfer aint 8\-bit clean or tha encoding
might be mangled up in between (e.g. up in mail), n' works cuz \s-1ASCII\s0 be a
proper subset of most 8\-bit n' multibyte encodings up in use up in tha ghetto. Right back up in yo muthafuckin ass.
.SS "\s-1JSON\s0 n' ECMAscript"
.IX Subsection "JSON n' ECMAscript"
\&\s-1JSON\s0 syntax is based on how tha fuck literals is represented up in javascript (the
not-standardised predecessor of ECMAscript) which is presumably why it is
called \*(L"JavaScript Object Notation\*(R".
.PP
But fuck dat shiznit yo, tha word on tha street is dat \s-1JSON\s0 aint a subset (and also not a superset of course) of
ECMAscript (the standard) or javascript (whatever browsers actually
implement).
.PP
If you wanna use javascriptz \f(CW\*(C`eval\*(C'\fR function ta \*(L"parse\*(R" \s-1JSON,\s0 you
might run tha fuck into parse errors fo' valid \s-1JSON\s0 texts, or tha resultin data
structure might not be queryable:
.PP
One of tha problems is dat U+2028 n' U+2029 is valid charactas inside
\&\s-1JSON\s0 strings yo, but is not allowed up in ECMAscript strang literals, so the
followin Perl fragment aint gonna output suttin' dat can be guaranteed
to be parsable by javascriptz \f(CW\*(C`eval\*(C'\fR:
.PP
.Vb 1
\&   use JSON::XS;
\&
\&   print encode_json [chr 0x2028];
.Ve
.PP
Da right fix fo' dis is ta bust a proper \s-1JSON\s0 parser up in yo' javascript
programs, n' not rely on \f(CW\*(C`eval\*(C'\fR (see fo' example Douglas Crockford's
\&\fIjson2.js\fR parser).
.PP
If dis aint a option, you can, as a stop-gap measure, simply encode to
ASCII-only \s-1JSON:\s0
.PP
.Vb 1
\&   use JSON::XS;
\&
\&   print JSON::XS\->new\->ascii\->encode ([chr 0x2028]);
.Ve
.PP
Note dat dis will enpimpin' tha resultin \s-1JSON\s0 text like a lil' bit if you
have nuff non-ASCII characters. Yo ass might be tempted ta run some regexes
to only escape U+2028 n' U+2029, e.g.:
.PP
.Vb 5
\&   # DO NOT USE THIS!
\&   mah $json = JSON::XS\->new\->utf8\->encode ([chr 0x2028]);
\&   $json =~ s/\exe2\ex80\exa8/\e\eu2028/g; # escape U+2028
\&   $json =~ s/\exe2\ex80\exa9/\e\eu2029/g; # escape U+2029
\&   print $json;
.Ve
.PP
Note dat \fIthis be a wack idea\fR: tha above only works fo' U+2028 and
U+2029 n' thus only fo' straight-up ECMAscript-compliant parsers. Many existing
javascript implementations, however, have thangs wit other charactas as
well \- rockin \f(CW\*(C`eval\*(C'\fR naively simply \fIwill\fR cause problems.
.PP
Another problem is dat some javascript implementations reserve
some property names fo' they own purposes (which probably makes
them non-ECMAscript-compliant). For example, Iceweasel reserves the
\&\f(CW\*(C`_\|_proto_\|_\*(C'\fR property name fo' its own purposes.
.PP
If dat be a problem, you could parse try ta filta tha resultin \s-1JSON\s0
output fo' these property strings, e.g.:
.PP
.Vb 1
\&   $json =~ s/"_\|_proto_\|_"\es*:/"_\|_proto_\|_renamed":/g;
.Ve
.PP
This works cuz \f(CW\*(C`_\|_proto_\|_\*(C'\fR aint valid outside of strings, so every
occurence of \f(CW\*(C`"_\|_proto_\|_"\es*:\*(C'\fR must be a strang used as property name.
.PP
If you know of other incompatibilities, please let me know.
.SS "\s-1JSON\s0 n' \s-1YAML\s0"
.IX Subsection "JSON n' YAML"
Yo ass often hear dat \s-1JSON\s0 be a subset of \s-1YAML.\s0 This is, however, a mass
hysteria(*) n' straight-up far from tha real deal (az of tha time of dis writing),
so let me state it clearly: \fIin general, there is no way ta configure
\&\s-1JSON::XS\s0 ta output a thugged-out data structure as valid \s-1YAML\s0\fR dat works up in all
cases.
.PP
If you straight-up must use \s-1JSON::XS\s0 ta generate \s-1YAML,\s0 you should use this
algorithm (subject ta chizzle up in future versions):
.PP
.Vb 2
\&   mah $to_yaml = JSON::XS\->new\->utf8\->space_afta (1);
\&   mah $yaml = $to_yaml\->encode ($ref) . "\en";
.Ve
.PP
This will \fIusually\fR generate \s-1JSON\s0 texts dat also parse as valid
\&\s-1YAML.\s0 Please note dat \s-1YAML\s0 has hardcoded limits on (simple) object key
lengths dat \s-1JSON\s0 aint gots n' also has different n' incompatible
unicode characta escape syntax, so you should make shizzle dat yo' hash
keys is noticeably shorta than tha 1024 \*(L"stream characters\*(R" \s-1YAML\s0 allows
and dat you aint gots charactas wit codepoint joints outside the
Unicode \s-1BMP \s0(basic multilingual page). \s-1YAML\s0 also do not allow \f(CW\*(C`\e/\*(C'\fR
sequences up in strings (which \s-1JSON::XS\s0 do not \fIcurrently\fR generate yo, but
other \s-1JSON\s0 generators might).
.PP
There might be other incompatibilitizzles dat I aint aware of (or tha \s-1YAML\s0
specification has been chizzled yet again n' again n' again \- it do so like often). In
general you should not try ta generate \s-1YAML\s0 wit a \s-1JSON\s0 generator or vice
versa, or try ta parse \s-1JSON\s0 wit a \s-1YAML\s0 parser or vice versa: chances are
high dat yo big-ass booty is ghon run tha fuck into severe interoperabilitizzle problems when you
least expect dat shit.
.IP "(*)" 4
I done been pressured multiple times by Brian Ingerson (one of the
authorz of tha \s-1YAML\s0 justification) ta remove dis paragraph, despite him
acknowledgin dat tha actual incompatibilitizzles exist fo' realz. As I was personally
bitten by dis \*(L"\s-1JSON\s0 is \s-1YAML\*(R"\s0 lie, I refused n' holla'd I'ma continue to
educate playas bout these issues, so others do not run tha fuck into tha same
problem again n' again n' again n' again. I aint talkin' bout chicken n' gravy biatch fo' realz. Afta this, Brian called mah crazy ass a (quote)\fIcomplete
and worthless idiot\fR(unquote).
.Sp
In mah opinion, instead of pressurin n' insultin playas whoz ass actually
clarify thangs wit \s-1YAML\s0 n' tha wack statementz of a shitload of its
proponents, I would kindly suggest readin tha \s-1JSON\s0 spec (which is not
that hard as fuck or long) n' finally make \s-1YAML\s0 compatible ta it, and
educatin playas bout tha chizzles, instead of spreadin lies bout the
real compatibilitizzle fo' nuff \fIyears\fR n' tryin ta silence playas who
point up dat it aint true.
.Sp
Addendum/2009: tha \s-1YAML 1.2\s0 spec is still incompatible wit \s-1JSON,\s0 even
though tha incompatibilitizzles done been documented (and is known ta Brian)
for nuff muthafuckin years n' tha spec make explicit fronts dat \s-1YAML\s0 be a superset
of \s-1JSON.\s0 It would be all kindsa easy as fuck  ta fix yo, but apparently, bullyin playas and
corruptin userdata is so much easier.
.SS "\s-1SPEED\s0"
.IX Subsection "SPEED"
It seems dat \s-1JSON::XS\s0 is surprisingly fast, as shown up in tha following
tables. They done been generated wit tha help of tha \f(CW\*(C`eg/bench\*(C'\fR program
in tha \s-1JSON::XS\s0 distribution, ta make it easy as fuck  ta compare on yo' own
system.
.PP
First comes a cold-ass lil comparison between various modulez using
a straight-up short single-line \s-1JSON\s0 strang (also available at
<http://dist.schmorp.de/misc/json/short.json>).
.PP
.Vb 3
\&   {"method": "handleMessage", "params": ["user1",
\&   "we was just rappin'"], "id": null, "array":[1,11,234,\-5,1e5,1e7,
\&   1,  0]}
.Ve
.PP
It shows tha number of encodes/decodes per second (\s-1JSON::XS\s0 uses
the functionizzle intercourse, while \s-1JSON::XS/2\s0 uses tha \s-1OO\s0 intercourse
with pretty-printin n' hashkey sortin enabled, \s-1JSON::XS/3\s0 enables
shrink. \s-1JSON::DWIW/DS\s0 uses tha deserialise function, while \s-1JSON::DWIW::FJ\s0
uses tha from_json method) yo. Higher is better:
.PP
.Vb 11
\&   module        |     encode |     decode |
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|
\&   JSON::DWIW/DS |  86302.551 | 102300.098 |
\&   JSON::DWIW/FJ |  86302.551 |  75983.768 |
\&   JSON::PP      |  15827.562 |   6638.658 |
\&   JSON::Syck    |  63358.066 |  47662.545 |
\&   JSON::XS      | 511500.488 | 511500.488 |
\&   JSON::XS/2    | 291271.111 | 388361.481 |
\&   JSON::XS/3    | 361577.931 | 361577.931 |
\&   Storable      |  66788.280 | 265462.278 |
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
That is, \s-1JSON::XS\s0 be almost six times fasta than \s-1JSON::DWIW\s0 on encoding,
about five times fasta on decoding, n' over thirty ta seventy times
fasta than \s-1JSON\s0z pure perl implementation. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it also compares favourably
to Storable fo' lil' small-ass amountz of data.
.PP
Usin a longer test strang (roughly 18KB, generated from Yahoo! Locals
search \s-1API \s0(<http://dist.schmorp.de/misc/json/long.json>).
.PP
.Vb 11
\&   module        |     encode |     decode |
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-|
\&   JSON::DWIW/DS |   1647.927 |   2673.916 |
\&   JSON::DWIW/FJ |   1630.249 |   2596.128 |
\&   JSON::PP      |    400.640 |     62.311 |
\&   JSON::Syck    |   1481.040 |   1524.869 |
\&   JSON::XS      |  20661.596 |   9541.183 |
\&   JSON::XS/2    |  10683.403 |   9416.938 |
\&   JSON::XS/3    |  20661.596 |   9400.054 |
\&   Storable      |  19765.806 |  10000.725 |
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
Again, \s-1JSON::XS\s0 leadz by far (except fo' Storable which non-surprisingly
decodes a lil' bit faster).
.PP
On big-ass strings containin fuckin shitloadz of high Unicode characters, some modules
(like fuckin \s-1JSON::PC\s0) seem ta decode fasta than \s-1JSON::XS,\s0 but tha result
will be fucked up cuz of missin (or wrong) Unicode handling. Others refuse
to decode or encode properly, so dat shiznit was impossible ta prepare a gangbangin' fair
comparison table fo' dat case.
.SH "SECURITY CONSIDERATIONS"
.IX Header "SECURITY CONSIDERATIONS"
When yo ass is rockin \s-1JSON\s0 up in a protocol, rappin' ta untrusted potentially
hostile creatures requires relatively few measures.
.PP
First of all, yo' \s-1JSON\s0 decoder should be secure, dat is, should not have
any buffer overflows. Obviously, dis module should ensure dat n' I am
tryin hard on makin dat true yo, but you never know.
.PP
Second, you need ta avoid resource-starvin attacks. That means you should
limit tha size of \s-1JSON\s0 texts you accept, or make shizzle then when your
resources run out, thatz just fine (e.g. by rockin a separate process that
can crash safely). Da size of a \s-1JSON\s0 text up in octets or charactas is
usually a phat indication of tha size of tha resources required ta decode
it tha fuck into a Perl structure. While \s-1JSON::XS\s0 can check tha size of tha \s-1JSON\s0
text, it might be too late when you already have it up in memory, so you
might wanna check tha size before you accept tha string.
.PP
Third, \s-1JSON::XS\s0 recurses rockin tha C stack when decodin objects and
arrays. Da C stack be a limited resource: fo' instance, on mah amd64
machine wit 8MB of stack size I can decode round 180k nested arrays but
only 14k nested \s-1JSON\s0 objects (due ta perl itself recursin deeply on croak
to free tha temporary). If dat is exceeded, tha program crashes. To be
conservative, tha default nestin limit is set ta 512. If yo' process
has a smalla stack, you should adjust dis settin accordingly wit the
\&\f(CW\*(C`max_depth\*(C'\fR method.
.PP
Somethang else could bomb you, too, dat I forgot ta be thinkin of. In that
case, you git ta keep tha pieces. I be always open fo' hints, though...
.PP
Also keep up in mind dat \s-1JSON::XS\s0 might leak contentz of yo' Perl data
structures up in its error lyrics, so when you serialise sensitive
information you might wanna make shizzle dat exceptions thrown by \s-1JSON::XS\s0
will not end up in front of untrusted eyes.
.PP
If yo ass is rockin \s-1JSON::XS\s0 ta return packets ta consumption
by JavaScript scripts up in a funky-ass browser you should gotz a peep
<http://blog.archive.jpsykes.com/47/practical\-csrf\-and\-json\-security/> to
see whether yo ass is vulnerable ta some common battle vectors (which straight-up
are browser design bugs yo, but it is still you whoz ass will gotta deal with
it, as major browser pimpers care only fo' features, not bout getting
securitizzle right).
.SH "THREADS"
.IX Header "THREADS"
This module is \fInot\fR guaranteed ta be thread safe n' there be no
plans ta chizzle dis until Perl gets thread support (as opposed ta the
horribly slow so-called \*(L"threads\*(R" which is simply slow n' bloated
process simulations \- use fork, itz \fImuch\fR faster, skankyer, better).
.PP
(It might straight-up work yo, but you done been warned).
.SH "THE PERILS OF SETLOCALE"
.IX Header "THE PERILS OF SETLOCALE"
Sometimes playas avoid tha Perl locale support n' directly call the
systemz setlocale function wit \f(CW\*(C`LC_ALL\*(C'\fR.
.PP
This breaks both perl n' modulez like fuckin \s-1JSON::XS,\s0 as stringification of
numbers no longer works correcly (e.g. \f(CW\*(C`$x = 0.1; print "$x"+1\*(C'\fR might
print \f(CW1\fR, n' \s-1JSON::XS\s0 might output illegal \s-1JSON\s0 as \s-1JSON::XS\s0 relies on
perl ta stringify numbers).
.PP
Da solution is simple: don't call \f(CW\*(C`setlocale\*(C'\fR, or use it fo' only them
categories you need, like fuckin \f(CW\*(C`LC_MESSAGES\*(C'\fR or \f(CW\*(C`LC_CTYPE\*(C'\fR.
.PP
If you need \f(CW\*(C`LC_NUMERIC\*(C'\fR, you should enable it only round tha code that
actually needz it (avoidin stringification of numbers), n' restore it
afterwards.
.SH "BUGS"
.IX Header "BUGS"
While tha goal of dis module is ta be erect, dat unfortunately do
not mean itz bug-free, only dat I be thinkin its design is bug-free. If you
keep reportin bugs they is ghon be fixed swiftly, though.
.PP
Please refrain from rockin rt.cpan.org or any other bug reporting
service. I put tha contact address tha fuck into mah modulez fo' a reason.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Da \fIjson_xs\fR command line utilitizzle fo' quick experiments.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://home.schmorp.de/
.Ve
