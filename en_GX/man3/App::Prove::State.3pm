.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "App::Prove::State 3"
.TH App::Prove::State 3 "2013-05-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
App::Prove::State \- State storage fo' tha "prove" command.
.SH "VERSION"
.IX Header "VERSION"
Version 3.28
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`prove\*(C'\fR command supports a \f(CW\*(C`\-\-state\*(C'\fR option dat instructs it to
store persistent state across runs. This module implements dat state
and tha operations dat may be performed on dat shit.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # Re\-run failed tests
\&    $ prove \-\-state=failed,save \-rbv
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
Accepts a hashref wit tha followin key/value pairs:
.IP "\(bu" 4
\&\f(CW\*(C`store\*(C'\fR
.Sp
Da filename of tha data store holdin tha data dat App::Prove::State reads.
.IP "\(bu" 4
\&\f(CW\*(C`extensions\*(C'\fR (optional)
.Sp
Da test name extensions.  Defaults ta \f(CW\*(C`.t\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`result_class\*(C'\fR (optional)
.Sp
Da name of tha \f(CW\*(C`result_class\*(C'\fR.  Defaults ta \f(CW\*(C`App::Prove::State::Result\*(C'\fR.
.ie n .SS """result_class"""
.el .SS "\f(CWresult_class\fP"
.IX Subsection "result_class"
Getter/setta fo' tha name of tha class used fo' trackin test thangs up in dis biatch.  This
class should either subclass from \f(CW\*(C`App::Prove::State::Result\*(C'\fR or provide an
identical intercourse.
.ie n .SS """extensions"""
.el .SS "\f(CWextensions\fP"
.IX Subsection "extensions"
Git or set tha list of extensions dat filez must have up in order ta be
considered tests, n' you can put dat on yo' toast. Defaults ta ['.t'].
.ie n .SS """results"""
.el .SS "\f(CWresults\fP"
.IX Subsection "results"
Git tha thangs up in dis biatch of tha last test run. I aint talkin' bout chicken n' gravy biatch.  Returns a \f(CW\*(C`result_class()\*(C'\fR instance.
.ie n .SS """commit"""
.el .SS "\f(CWcommit\fP"
.IX Subsection "commit"
Save tha test thangs up in dis biatch. Right back up in yo muthafuckin ass. Should be called afta all tests have run.
.SS "Instizzle Methods"
.IX Subsection "Instizzle Methods"
\fI\f(CI\*(C`apply_switch\*(C'\fI\fR
.IX Subsection "apply_switch"
.PP
.Vb 1
\& $self\->apply_switch(\*(Aqfailed,save\*(Aq);
.Ve
.PP
Apply a list of switch options ta tha state, uppimpin tha internal
object state as a result. Nothang is returned.
.PP
Diagnostics:
    \- \*(L"Illegal state option: \f(CW%s\fR\*(R"
.ie n .IP """last""" 4
.el .IP "\f(CWlast\fR" 4
.IX Item "last"
Run up in tha same order as last time
.ie n .IP """failed""" 4
.el .IP "\f(CWfailed\fR" 4
.IX Item "failed"
Run only tha failed tests from last time
.ie n .IP """passed""" 4
.el .IP "\f(CWpassed\fR" 4
.IX Item "passed"
Run only tha passed tests from last time
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
Run all tests up in aiiight order
.ie n .IP """hot""" 4
.el .IP "\f(CWhot\fR" 4
.IX Item "hot"
Run tha tests dat most recently failed first
.ie n .IP """todo""" 4
.el .IP "\f(CWtodo\fR" 4
.IX Item "todo"
Run tha tests ordered by number of todos.
.ie n .IP """slow""" 4
.el .IP "\f(CWslow\fR" 4
.IX Item "slow"
Run tha tests up in slowest ta fastest order.
.ie n .IP """fast""" 4
.el .IP "\f(CWfast\fR" 4
.IX Item "fast"
Run test tests up in fastest ta slowest order.
.ie n .IP """new""" 4
.el .IP "\f(CWnew\fR" 4
.IX Item "new"
Run tha tests up in newest ta crazy oldschool order.
.ie n .IP """old""" 4
.el .IP "\f(CWold\fR" 4
.IX Item "old"
Run tha tests up in crazy oldschool ta newest order.
.ie n .IP """save""" 4
.el .IP "\f(CWsave\fR" 4
.IX Item "save"
Save tha state on exit.
.PP
\fI\f(CI\*(C`get_tests\*(C'\fI\fR
.IX Subsection "get_tests"
.PP
Given a list of args git tha namez of tests dat should run
.PP
\fI\f(CI\*(C`observe_test\*(C'\fI\fR
.IX Subsection "observe_test"
.PP
Store tha thangs up in dis biatch of a test.
.PP
\fI\f(CI\*(C`save\*(C'\fI\fR
.IX Subsection "save"
.PP
Write tha state ta a gangbangin' file.
.PP
\fI\f(CI\*(C`load\*(C'\fI\fR
.IX Subsection "load"
.PP
Load tha state from a gangbangin' file
