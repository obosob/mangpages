.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::XQL::Tutorial 3"
.TH XML::XQL::Tutorial 3 "2001-06-20" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::XQL::Tutorial \- Describes tha XQL query syntax
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document raps bout basic tha featurez of tha \s-1XML\s0 Query Language (\s-1XQL.\s0)
A proposal fo' tha \s-1XML\s0 Query Language (\s-1XQL\s0) justification was submitted
to tha \s-1XSL\s0 Workin Group up in September 1998. 
Da spec can be found at <http://www.w3.org/TandS/QL/QL98/pp/xql.html>.
Since it is only a proposal at dis point, thangs may chizzle yo, but it is hella
likely dat tha final version is ghon be close ta tha proposal.
Most of dis document was copied straight from tha spec.
.PP
See also tha \s-1XML::XQL\s0 playa page.
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
\&\s-1XQL \s0(\s-1XML\s0 Query Language) serves up a natural extension ta tha \s-1XSL\s0 pattern 
language. Well shiiiit, it buildz upon tha capabilitizzles \s-1XSL\s0 serves up fo' identifyin classes 
of nodes, by addin Boolean logic, filters, indexin tha fuck into collectionz of nodes, 
and more.
.PP
\&\s-1XQL\s0 is designed specifically fo' \s-1XML\s0 documents, n' you can put dat on yo' toast. 
It be a general purpose query language, providin a single syntax
that can be used fo' queries, addressing, n' patterns. 
\&\s-1XQL\s0 is concise, simple, n' powerful.
.PP
\&\s-1XQL\s0 is designed ta be used up in nuff contexts fo' realz. Although it aint nuthin but a superset of \s-1XSL \s0
patterns, it be also applicable ta providin links ta nodes, fo' searchin 
repositories, n' fo' nuff other applications.
.PP
Note dat tha term \s-1XQL\s0 be a hustlin term fo' tha language busted lyrics bout up in dis 
proposal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Well shiiiit, it aint they intent dat dis term be used permanently.
Also, beware dat another query language exists called XML-QL,
which uses a syntax straight-up similar ta \s-1SQL.\s0
.PP
Da \s-1XML::XQL\s0 module has added functionalitizzle ta tha \s-1XQL\s0 spec, called \fI\s-1XQL+\s0\fR.
To allow only \s-1XQL\s0 functionalitizzle as busted lyrics bout up in tha spec, use tha 
XML::XQL::Strict module. Note dat tha \s-1XQL\s0 spec make tha distinction between 
core \s-1XQL\s0 n' \s-1XQL\s0 extensions. This implementation make no distinction and
the Strict module, therefore, implements every last muthafuckin thang busted lyrics bout up in tha \s-1XQL\s0 spec.
See tha \s-1XML::XQL\s0 playa page fo' mo' shiznit bout tha Strict module.
This tutorial will clearly indicate when referrin ta \s-1XQL+.\s0
.SH "XQL Patterns"
.IX Header "XQL Patterns"
This section raps bout tha core \s-1XQL\s0 notation. I aint talkin' bout chicken n' gravy biatch. These features should be part 
of every last muthafuckin \s-1XQL\s0 implementation, n' serve as tha base level of functionalitizzle 
for its use up in different technologies.
.PP
Da basic syntax fo' \s-1XQL\s0 mimics tha \s-1URI\s0 directory mastabation syntax yo, but 
instead of specifyin mastabation all up in a
physical file structure, tha mastabation be all up in elements up in tha \s-1XML\s0 tree.
.PP
For example, tha followin \s-1URI\s0 means find tha foo.jpg file within tha bar 
directory:
.PP
.Vb 1
\&     bar/foo.jpg
.Ve
.PP
Similarly, up in \s-1XQL,\s0 tha followin means find tha collection of fuz elements 
within baz elements:
.PP
.Vb 1
\&     baz/fuz
.Ve
.PP
Throughout dis document yo big-ass booty is ghon find a shitload of samples. They refer ta tha data 
shown up in tha sample file all up in tha end of dis playa page.
.SH "Context"
.IX Header "Context"
A \fIcontext\fR is tha set of nodes against which a query operates.
For tha entire query, which is passed ta tha XML::XQL::Query
constructor all up in tha \fIExpr\fR option, tha context is tha list of input nodes
that is passed ta tha \fIquery()\fR method.
.PP
\&\s-1XQL\s0 allows a query ta select between rockin tha current context as tha input 
context n' rockin tha 'root context' as tha input context. 
Da 'root context' be a cold-ass lil context containin only tha root-most
element of tha document. When rockin \s-1XML::DOM,\s0 dis is tha Document object.
.PP
By default, a query uses tha current context fo' realz. A query prefixed wit '/' 
(forward slash) uses tha root context fo' realz. A query may
optionally explicitly state dat it is rockin tha current context by rockin 
the './' (dot, forward slash) prefix. Both of these
notations is analogous ta tha notations used ta navigate directories up in a gangbangin' file 
system.
.PP
Da './' prefix is only required up in one thang fo' realz. A query may use tha '//' 
operator ta indicate recursive descent. When
this operator appears all up in tha beginnin of tha query, tha initial '/' causes tha 
recursive decent ta big-ass up relatizzle ta the
root of tha document or repository. Da prefix './/' allows a query ta big-ass up 
a recursive descent relatizzle ta tha current context.
.IP "Examples:" 4
.IX Item "Examples:"
Find all lyricist elements within tha current context. Right back up in yo muthafuckin ass. Since tha period is straight-up 
not used alone, dis example forward-references other features:
.Sp
.Vb 1
\&     ./author
.Ve
.Sp
Note dat dis is equivalent to:
.Sp
.Vb 1
\&     author
.Ve
.Sp
Find tha root element (bookstore) of dis document:
.Sp
.Vb 1
\&     /bookstore
.Ve
.Sp
Find all lyricist elements anywhere within tha current document:
.Sp
.Vb 1
\&     //author
.Ve
.Sp
Find all books where tha value of tha steez attribute on tha book is equal ta 
the value of tha specialty attribute of tha bookstore element all up in tha root of 
the document:
.Sp
.Vb 1
\&     book[/bookstore/@specialty = @style]
.Ve
.SH "Query Results"
.IX Header "Query Results"
Da collection returned by a \s-1XQL\s0 expression preserves document order, 
hierarchy, n' identity, ta tha extent dat these is defined. Y'all KNOW dat shit, muthafucka! 
That is, a cold-ass lil collection of elements will always be returned up in document order 
without repeats, n' you can put dat on yo' toast. Note dat tha spec states dat tha order of attributes within
an element is undefined yo, but dat dis implementation do keep attributes
in document order n' shit. Right back up in yo muthafuckin ass. See tha \s-1XML::XQL\s0 playa page fo' mo' details regardin 
\&\fIDocument Order\fR.
.SH "Collections \- 'element' n' '.'"
.IX Header "Collections - 'element' n' '.'"
Da collection of all elements wit a cold-ass lil certain tag name is expressed rockin tha 
tag name itself. This can be qualified by showin dat tha elements is 
selected from tha current context './' yo, but tha current context be assumed n' 
often need not be noted explicitly.
.IP "Examples:" 4
.IX Item "Examples:"
Find all first-name elements, n' you can put dat on yo' toast. These examplez is equivalent:
.Sp
.Vb 1
\&     ./first\-name
\&
\&     first\-name
.Ve
.Sp
Find all unqualified book elements:
.Sp
.Vb 1
\&     book
.Ve
.Sp
Find all first.name elements:
.Sp
.Vb 1
\&     first.name
.Ve
.SH "Selectin lil pimps n' descendants \- '/' n' '//'"
.IX Header "Selectin lil pimps n' descendants - '/' n' '//'"
Da collection of elementz of a cold-ass lil certain type can be determined rockin tha path 
operators ('/' or '//'). These operators take as they arguments a cold-ass lil collection 
(left side) from which ta query elements, n' a cold-ass lil collection indicatin which
elements ta select (right side). Da lil pimp operator ('/')selects from immediate 
lil pimpz of tha left-side collection, while tha descendant operator ('//') 
selects from arbitrary descendantz of tha left-side collection. I aint talkin' bout chicken n' gravy biatch. 
In effect, tha '//' can be thought of as a substitute fo' one or mo' levelz of 
hierarchy. Note dat tha path operators chizzle tha context as the
query is performed. Y'all KNOW dat shit, muthafucka! By stringin dem together playas can 'drill down' tha fuck into tha 
document.
.IP "Examples:" 4
.IX Item "Examples:"
Find all first-name elements within a lyricist element. Note dat tha lyricist 
lil pimpz of tha current context is found, n' then first-name lil pimps is 
found relatizzle ta tha context of tha lyricist elements:
.Sp
.Vb 1
\&     author/first\-name
.Ve
.Sp
Find all title elements, one or mo' levels deep up in tha bookstore 
(arbitrary descendants):
.Sp
.Vb 1
\&     bookstore//title
.Ve
.Sp
Note dat dis is different from tha followin query, which findz all title 
elements dat is grandlil pimpz of bookstore elements:
.Sp
.Vb 1
\&     bookstore/*/title
.Ve
.Sp
Find emph elements anywhere inside book excerpts, anywhere inside tha bookstore:
.Sp
.Vb 1
\&     bookstore//book/excerpt//emph
.Ve
.Sp
Find all titles, one or mo' levels deep up in tha current context. Note dat dis 
situation is essentially tha only one where
the period notation is required:
.Sp
.Vb 1
\&     .//title
.Ve
.SH "Collectin element lil pimps \- '*'"
.IX Header "Collectin element lil pimps - '*'"
An element can be referenced without rockin its name by substitutin tha '*' 
collection. I aint talkin' bout chicken n' gravy biatch. Da '*' collection returns all
elements dat is lil pimpz of tha current context, regardless of they tag name.
.IP "Examples:" 4
.IX Item "Examples:"
Find all element lil pimpz of lyricist elements:
.Sp
.Vb 1
\&     author/*
.Ve
.Sp
Find all last-names dat is grand-lil pimpz of books:
.Sp
.Vb 1
\&     book/*/last\-name
.Ve
.Sp
Find tha grandlil pimps elementz of tha current context:
.Sp
.Vb 1
\&     */*
.Ve
.Sp
Find all elements wit specialty attributes. Note dat dis example uses 
subqueries, which is covered up in Filters, and
attributes, which is discussed up in Findin a attribute:
.Sp
.Vb 1
\&     *[@specialty]
.Ve
.SH "Findin a attribute \- '@'"
.IX Header "Findin a attribute - '@'"
Attribute names is preceded by tha '@' symbol. \s-1XQL\s0 is designed ta treat 
attributes n' sub-elements impartially,
and capabilitizzles is equivalent between tha two types wherever possible.
.PP
Note: attributes cannot contain subelements, n' you can put dat on yo' toast. Thus, attributes cannot have path 
operators applied ta dem up in a query.
Such expressions will result up in a syntax error. Shiiit, dis aint no joke. 
Da \s-1XQL\s0 spec states dat attributes is inherently unordered n' indices 
cannot be applied ta dem yo, but dis implementation allows dat shit.
.IP "Examples:" 4
.IX Item "Examples:"
Find tha steez attribute of tha current element context:
.Sp
.Vb 1
\&     @style
.Ve
.Sp
Find tha exchange attribute on price elements within tha current context:
.Sp
.Vb 1
\&     price/@exchange
.Ve
.Sp
Da followin example aint valid:
.Sp
.Vb 1
\&     price/@exchange/total
.Ve
.Sp
Find all books wit steez attributes. Note dat dis example uses subqueries, 
which is covered up in Filters:
.Sp
.Vb 1
\&     book[@style]
.Ve
.Sp
Find tha steez attribute fo' all book elements:
.Sp
.Vb 1
\&     book/@style
.Ve
.SH "XQL Literals"
.IX Header "XQL Literals"
\&\s-1XQL\s0 query expressions may contain literal joints (i.e. constants.)
Numbers (integers n' floats) is wrapped up in XML::XQL::Number objects and
strings up in XML::XQL::Text objects, n' you can put dat on yo' toast. Booleans (as returned by \fItrue()\fR n' \fIfalse()\fR)
are wrapped up in XML::XQL::Boolean objects.
.PP
Strings must be enclosed up in single or double quotes. Right back up in yo muthafuckin ass. Since \s-1XQL\s0 do not allow
escapin of special characters, itz impossible ta create a strang wit both
a single n' a thugged-out double quote up in dat shit. To remedy this, \s-1XQL+\s0 has added tha q// and
qq// strang delimitas which behave just like they do up in Perl.
.PP
For Numbers, exponential notation aint allowed. Y'all KNOW dat shit, muthafucka! Use tha \s-1XQL+\s0 function \fIeval()\fR
to circumvent dis problem. Right back up in yo muthafuckin ass. See \s-1XML::XQL\s0 playa page fo' details.
.PP
Da empty list or undef is represented by [] (i.e. reference ta empty array)
in dis implementation.
.IP "Example" 4
.IX Item "Example"
Integer Numbers:
.Sp
.Vb 2
\&     234
\&     \-456
.Ve
.Sp
Floatin point Numbers:
.Sp
.Vb 2
\&     1.23
\&     \-0.99
.Ve
.Sp
Strings:
.Sp
.Vb 2
\&     "some text wit \*(Aqsingle\*(Aq quotes"
\&     \*(Aqtext wit "double" quotes\*(Aq
.Ve
.Sp
Not allowed:
.Sp
.Vb 1
\&     1.23E\-4         (use eval("1.23E\-4", "Number") up in XQL+)          
\&
\&     "can\*(Aqt use \e"double \e"quotes"  (use q/can\*(Aqt use "double" quotes/ up in XQL+)
.Ve
.SH "Groupin \- '()'"
.IX Header "Groupin - '()'"
Parentheses can be used ta crew collection operators fo' claritizzle or where tha 
normal precedence is inadequate ta express a operation.
.SH "Filtas \- '[]'"
.IX Header "Filtas - '[]'"
Constraints n' branchin can be applied ta any collection by addin a gangbangin' filta 
clause '[ ]' ta tha collection. I aint talkin' bout chicken n' gravy biatch. Da filta be analogous ta tha \s-1SQL WHERE\s0 clause 
with \s-1ANY\s0 semantics. Da filta gotz nuff a query within it, called the
subquery. Da subquery evaluates ta a Boolean, n' is tested fo' each element 
in tha collection. I aint talkin' bout chicken n' gravy biatch fo' realz. Any elements up in tha collection failin tha subquery test is 
omitted from tha result collection.
.PP
For convenience, if a cold-ass lil collection is placed within tha filter, a Boolean \s-1TRUE \s0
is generated if tha collection gotz nuff any members, n' a \s-1FALSE\s0 is generated 
if tha collection is empty. In essence, a expression like fuckin author/degree
implies a cold-ass lil collection-to-Boolean conversion function like tha followin 
mythical 'there\-exists\-a' method.
.PP
.Vb 1
\&     author[.there\-exists\-a(degree)]
.Ve
.PP
Note dat any number of filtas can step tha fuck up at a given level of a expression. I aint talkin' bout chicken n' gravy biatch. 
Empty filtas is not allowed.
.IP "Examples:" 4
.IX Item "Examples:"
Find all books dat contain at least one excerpt element:
.Sp
.Vb 1
\&     book[excerpt]
.Ve
.Sp
Find all titlez of books dat contain at least one excerpt element:
.Sp
.Vb 1
\&     book[excerpt]/title
.Ve
.Sp
Find all authorz of books where tha book gotz nuff at least one excerpt, n' 
the lyricist has at least one degree:
.Sp
.Vb 1
\&     book[excerpt]/author[degree]
.Ve
.Sp
Find all books dat have authors wit at least one degree:
.Sp
.Vb 1
\&     book[author/degree]
.Ve
.Sp
Find all books dat have a excerpt n' a title:
.Sp
.Vb 1
\&     book[excerpt][title]
.Ve
.SS "Any n' all semantics \- '$any$' n' '$all$'"
.IX Subsection "Any n' all semantics - '$any$' n' '$all$'"
Users can explicitly indicate whether ta use any or all semantics all up in 
the \f(CW$any\fR$ n' \f(CW$all\fR$ keywords.
.PP
\&\f(CW$any\fR$ flags dat a cold-ass lil condizzle will hold legit if any item up in a set meets dat 
condition. I aint talkin' bout chicken n' gravy biatch. \f(CW$all\fR$ means dat all elements up in a
set must hook up tha condizzle fo' tha condizzle ta hold true.
.PP
\&\f(CW$any\fR$ n' \f(CW$all\fR$ is keywordz dat step tha fuck up before a subquery expression within
a filter.
.IP "Examples:" 4
.IX Item "Examples:"
Find all lyricist elements where one of tha last names is Bob:
.Sp
.Vb 1
\&     author[last\-name = \*(AqBob\*(Aq]
\&
\&     author[$any$ last\-name = \*(AqBob\*(Aq]
.Ve
.Sp
Find all lyricist elements where none of tha last-name elements is Bob:
.Sp
.Vb 1
\&     author[$all$ last\-name != \*(AqBob\*(Aq]
.Ve
.Sp
Find all lyricist elements where tha straight-up original gangsta last name is Bob:
.Sp
.Vb 1
\&     author[last\-name[0] = \*(AqBob\*(Aq]
.Ve
.SH "Indexin tha fuck into a cold-ass lil collection \- '[]' n' '$to$'"
.IX Header "Indexin tha fuck into a cold-ass lil collection - '[]' n' '$to$'"
\&\s-1XQL\s0 make it easy as fuck  ta find a specific node within a set of nodes. 
Simply enclose tha index ordinal within square brackets, n' you can put dat on yo' toast. Da ordinal is 0 based.
.PP
A range of elements can be returned. Y'all KNOW dat shit, muthafucka! To do so, specify a expression rather 
than a single value inside of tha subscript operator (square brackets). 
Such expressions can be a cold-ass lil comma separated list of any of tha following:
.PP
.Vb 4
\&  n             Returns tha nth element
\&  \-n            Returns tha element dat is n\-1 units from tha last element. 
\&                E.g., \-1 means tha last element. \-2 is tha next ta last element.
\&  m $to$ n      Returns elements m all up in n, inclusive
.Ve
.IP "Examples:" 4
.IX Item "Examples:"
Find tha straight-up original gangsta lyricist element:
.Sp
.Vb 1
\&     author[0]
.Ve
.Sp
Find tha third lyricist element dat has a gangbangin' first-name:
.Sp
.Vb 1
\&     author[first\-name][2]
.Ve
.Sp
Note dat indices is relatizzle ta tha parent. In other lyrics, consider tha 
followin data:
.Sp
.Vb 8
\&     <x>
\&       <y/>
\&       <y/>
\&     </x>
\&     <x>
\&       <y/>
\&       <y/>
\&     </x>
.Ve
.Sp
Da followin expression will return tha straight-up original gangsta y from each of tha x's:
.Sp
.Vb 1
\&     x/y[0]
.Ve
.Sp
Da followin will return tha straight-up original gangsta y from tha entire set of yz within x's:
.Sp
.Vb 1
\&     (x/y)[0]
.Ve
.Sp
Da followin will return tha straight-up original gangsta y from tha straight-up original gangsta x:
.Sp
.Vb 1
\&     x[0]/y[0]
.Ve
.Sp
Find tha straight-up original gangsta n' fourth lyricist elements:
.Sp
.Vb 1
\&     author[0,3]
.Ve
.Sp
Find tha straight-up original gangsta all up in fourth lyricist elements:
.Sp
.Vb 1
\&     author[0 $to$ 3]
.Ve
.Sp
Find tha first, tha third all up in fifth, n' tha last lyricist elements:
.Sp
.Vb 1
\&     author[0, 2 $to$ 4, \-1]
.Ve
.Sp
Find tha last lyricist element:
.Sp
.Vb 1
\&     author[\-1]
.Ve
.SH "Boolean Expressions"
.IX Header "Boolean Expressions"
Boolean expressions can be used within subqueries. Put ya muthafuckin choppers up if ya feel dis! For example, one could use 
Boolean expressions ta find all nodez of a particular value, or all nodes wit 
nodes up in particular ranges. Boolean expressions iz of tha form
${op}$, where {op} may be any expression of tha form {b|a} \- dat is, tha 
operator takes lvalue n' rvalue arguments n' returns a Boolean result.
.PP
Note dat tha \s-1XQL\s0 Extensions section defines additionizzle Boolean operations.
.SS "Boolean \s-1AND\s0 n' \s-1OR \- \s0'$and$' n' '$or$'"
.IX Subsection "Boolean AND n' OR - '$and$' n' '$or$'"
\&\f(CW$and\fR$ n' \f(CW$or\fR$ is used ta big-ass up Boolean andz n' ors.
.PP
Da Boolean operators, up in conjunction wit groupin parentheses, can be used ta 
build straight-up sophisticated logical expressions.
.PP
Note dat spaces is not dope n' can be omitted, or included fo' 
claritizzle as shown here.
.IP "Examples:" 4
.IX Item "Examples:"
Find all lyricist elements dat contain at least one degree n' one award.
.Sp
.Vb 1
\&     author[degree $and$ award]
.Ve
.Sp
Find all lyricist elements dat contain at least one degree or award n' at 
least one publication.
.Sp
.Vb 1
\&     author[(degree $or$ award) $and$ publication]
.Ve
.SS "Boolean \s-1NOT \- \s0'$not$'"
.IX Subsection "Boolean NOT - '$not$'"
\&\f(CW$not\fR$ be a Boolean operator dat negates tha value of a expression within a 
subquery.
.IP "Examples:" 4
.IX Item "Examples:"
Find all lyricist elements dat contain at least one degree element n' dat 
contain no publication elements.
.Sp
.Vb 1
\&     author[degree $and$ $not$ publication]
.Ve
.Sp
Find all lyricist elements dat contain publications elements but do not contain 
either degree elements or award elements.
.Sp
.Vb 1
\&     author[$not$ (degree $or$ award) $and$ publication]
.Ve
.SH "Union n' intersection \- '$union$', '|' n' '$intersect$'"
.IX Header "Union n' intersection - '$union$', '|' n' '$intersect$'"
Da \f(CW$union\fR$ operator (shortcut is '|') returns tha combined set of joints from 
the query on tha left n' tha query on tha right. Duplicates is filtered out. 
Da resultin list is sorted up in document order.
.PP
Note: cuz dis be a union, tha set returned may include 0 or mo' elements
of each element type up in tha list. To restrict tha returned set ta nodes dat 
contain at least one of each of tha elements up in tha list, bust a gangbangin' filter, as 
discussed up in Filters.
.PP
Da \f(CW$intersect\fR$ operator returns tha set of elements up in common between two sets.
.IP "Examples:" 4
.IX Item "Examples:"
Find all first-names n' last-names:
.Sp
.Vb 1
\&     first\-name $union$ last\-name
.Ve
.Sp
Find all books n' magazines from a funky-ass bookstore:
.Sp
.Vb 1
\&     bookstore/(book | magazine)
.Ve
.Sp
Find all books n' all authors:
.Sp
.Vb 1
\&     book $union$ book/author
.Ve
.Sp
Find tha first-names, last-names, or degrees from authors within either books 
or magazines:
.Sp
.Vb 1
\&     (book $union$ magazine)/author/(first\-name $union$ last\-name $union$ degree)
.Ve
.Sp
Find all books wit author/first\-name equal ta 'Bob' n' all magazines wit 
price less than 10:
.Sp
.Vb 1
\&     book[author/first\-name = \*(AqBob\*(Aq] $union$ magazine[price $lt$ 10]
.Ve
.SH "Equivalence \- '$eq$', '=', '$ne$' n' '!='"
.IX Header "Equivalence - '$eq$', '=', '$ne$' n' '!='"
Da '=' sign is used fo' equality; '!=' fo' inequalitizzle fo' realz. Alternatively, \f(CW$eq\fR$ and
 \f(CW$ne\fR$ can be used fo' equalitizzle n' inequality.
.PP
Single or double quotes can be used fo' strang delimitas up in expressions. 
This make it easier ta construct n' pass \s-1XQL\s0 from within scriptin languages.
.PP
For comparin jointz of elements, tha \fIvalue()\fR method is implied. Y'all KNOW dat shit, muthafucka! That is, 
last-name < 'foo' straight-up means last\-name!\fIvalue()\fR < 'foo'.
.PP
Note dat filtas is always wit respect ta a cold-ass lil context. That is, tha expression 
book[author] means fo' every last muthafuckin book element dat is found, peep if it has a 
lyricist subelement. Likewise, book[lyricist = 'Bob'] means for
every book element dat is found, peep if it has a subelement named lyricist 
whose value is 'Bob'. One can examine tha value of tha context as well, by 
usin tha . (period). For example, book[. = 'Trenton'] means fo' every
book dat is found, peep if its value is 'Trenton'.
.IP "Examples:" 4
.IX Item "Examples:"
Find all lyricist elements whose last name is Bob:
.Sp
.Vb 1
\&     author[last\-name = \*(AqBob\*(Aq]
\&
\&     author[last\-name $eq$ \*(AqBob\*(Aq]
.Ve
.Sp
Find all authors where tha from attribute aint equal ta 'Harvard':
.Sp
.Vb 1
\&     degree[@from != \*(AqHarvard\*(Aq]
\&
\&     degree[@from $ne$ \*(AqHarvard\*(Aq]
.Ve
.Sp
Find all authors where tha last-name is tha same ol' dirty as tha /guest/last\-name element:
.Sp
.Vb 1
\&     author[last\-name = /guest/last\-name]
.Ve
.Sp
Find all authors whose text is 'Matthew Bob':
.Sp
.Vb 1
\&     author[. = \*(AqMatthew Bob\*(Aq]
\&
\&     lyricist = \*(AqMatthew Bob\*(Aq
.Ve
.SS "Comparison \- '<', '<=', '>', '>=', '$lt', '$ilt$' etc."
.IX Subsection "Comparison - '<', '<=', '>', '>=', '$lt', '$ilt$' etc."
A set of binary comparison operators be available fo' comparin numbers n' 
strings n' returnin Boolean thangs up in dis biatch.
\&\f(CW$lt\fR$, \f(CW$le\fR$, \f(CW$gt\fR$, \f(CW$ge\fR$ is used fo' less than, less than or equal, pimped outa 
than, or pimped outa than or equal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. These same
operators is also available up in a cold-ass lil case insensitizzle form: \f(CW$ieq\fR$, \f(CW$ine\fR$, \f(CW$ilt\fR$, 
\&\f(CW$ile\fR$, \f(CW$igt\fR$, \f(CW$ige\fR$.
.PP
<, <=, > n' >= is allowed short cuts fo' \f(CW$lt\fR$, \f(CW$le\fR$, \f(CW$gt\fR$ n' \f(CW$ge\fR$.
.IP "Examples:" 4
.IX Item "Examples:"
Find all lyricist elements whose last name is bob n' whose price is > 50
.Sp
.Vb 1
\&     author[last\-name = \*(AqBob\*(Aq $and$ price $gt$ 50]
.Ve
.Sp
Find all authors where tha from attribute aint equal ta 'Harvard':
.Sp
.Vb 1
\&     degree[@from != \*(AqHarvard\*(Aq]
.Ve
.Sp
Find all authors whose last name begins wit 'M' or pimped outer:
.Sp
.Vb 1
\&     author[last\-name $ge$ \*(AqM\*(Aq]
.Ve
.Sp
Find all authors whose last name begins wit 'M', 'm' or pimped outer:
.Sp
.Vb 1
\&     author[last\-name $ige$ \*(AqM\*(Aq]
.Ve
.Sp
Find tha straight-up original gangsta three books:
.Sp
.Vb 1
\&     book[index() $le$ 2]
.Ve
.Sp
Find all authors whoz ass have mo' than 10 publications:
.Sp
.Vb 1
\&     author[publications!count() $gt$ 10]
.Ve
.SS "\s-1XQL+\s0 Match operators \- '$match$', '$no_match$', '=~' n' '!~'"
.IX Subsection "XQL+ Match operators - '$match$', '$no_match$', '=~' n' '!~'"
\&\s-1XQL+\s0 defines additionizzle operators fo' pattern matching. Da \f(CW$match\fR$ operator
(shortcut is '=~') returns \s-1TRUE\s0 if tha lvalue matches tha pattern busted lyrics bout by
the rvalue. Da \f(CW$no_match\fR$ operator (shortcut is '!~') returns \s-1FALSE\s0 if they
match. Both lvalue n' rvalue is first cast ta strings.
.PP
Da rvalue strang should have tha syntax of a Perl rvalue, dat is tha delimiters
should be included n' modifiers is allowed. Y'all KNOW dat shit, muthafucka! When rockin delimitas other than
slashes '/', tha 'm' should be included. Y'all KNOW dat shit, muthafucka! Da rvalue should be a string, so don't
forget tha quotes muthafucka! (Or use tha q// or qq// delimitas up in \s-1XQL+,\s0 peep \s-1XML::XQL\s0
man page.)
.PP
Note dat you can't use tha Perl substitution operator s/// here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Try rockin the
\&\s-1XQL+\s0 \fIsubst()\fR function instead.
.IP "Examples:" 4
.IX Item "Examples:"
Find all authors whose name gotz nuff bob or Bob:
.Sp
.Vb 1
\&    author[first\-name =~ \*(Aq/[Bb]ob/\*(Aq]
.Ve
.Sp
Find all book titlez dat don't contain 'Trenton' (case-insensitive):
.Sp
.Vb 1
\&    book[title !~ \*(Aqm!trenton!i\*(Aq]
.Ve
.SS "Oher \s-1XQL+\s0 comparison operators \- '$isa', '$can$'"
.IX Subsection "Oher XQL+ comparison operators - '$isa', '$can$'"
See tha \s-1XML::XQL\s0 playa page fo' other operators available up in \s-1XQL+.\s0
.SS "Comparisons n' vectors"
.IX Subsection "Comparisons n' vectors"
Da lvalue of a cold-ass lil comparison can be a vector or a scalar. Shiiit, dis aint no joke. Da rvalue of a 
comparison must be a scalar or a value dat can be cast at runtime ta a scalar.
.PP
If tha lvalue of a cold-ass lil comparison be a set, then any (exists) semantics is used 
for tha comparison operators. That is, tha result of a cold-ass lil comparison is legit if 
any item up in tha set meets tha condition.
.SS "Comparisons n' literals"
.IX Subsection "Comparisons n' literals"
Da spec states dat tha lvalue of a expression cannot be a literal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. 
That is, \fI'1' = a\fR aint allowed. Y'all KNOW dat shit, muthafucka! This implementation allows it yo, but itz not
clear how tha fuck useful dat is.
.SS "Castin of literals durin comparison"
.IX Subsection "Castin of literals durin comparison"
Elements, attributes n' other \s-1XML\s0 node types is casted ta strings (Text)
by applyin tha \fIvalue()\fR method. Y'all KNOW dat shit, muthafucka! Da \fIvalue()\fR method calls tha \fItext()\fR method by 
default yo, but dis behavior can be altered by tha user, so tha \fIvalue()\fR method
may return other \s-1XQL\s0 data types.
.PP
When two joints is compared, they is first casted ta tha same type.
See tha \s-1XML::XQL\s0 playa page fo' details on casting.
.PP
Note dat tha \s-1XQL\s0 spec aint straight-up clear on how tha fuck joints should be casted fo' 
comparison. I aint talkin' bout chicken n' gravy biatch. Raps wit tha authorz of tha \s-1XQL\s0 spec revealed dat there
was some beef n' they implementations differed on dis point.
This implementation is closest ta dat of Joe Lapp from webMethods, Inc.
.SH "Methodz \- '\fImethod()\fP' or 'query!\fImethod()\fP'"
.IX Header "Methodz - 'method()' or 'query!method()'"
\&\s-1XQL\s0 cook up a gangbangin' finger-lickin' distinction between functions n' methods. 
See tha \s-1XML::XQL\s0 playa page fo' details.
.PP
\&\s-1XQL\s0 serves up methodz fo' advanced manipulation of collections. These methodz 
provide specialized collectionz of nodes (see Collection methods), as well as 
information bout sets n' nodes.
.PP
Methodz iz of tha form \fImethod(arglist)\fR
.PP
Consider tha query book[author]. Well shiiiit, it will find all books dat have authors. 
Formally, we call tha book correspondin ta a particular lyricist tha reference 
node fo' dat lyricist. That is, every last muthafuckin lyricist element dat is examined be a author
for one of tha book elements, n' you can put dat on yo' toast. (See tha Annotated \s-1XQL BNF\s0 Appendix fo' a much 
more thorough definizzle of reference node n' other terms. Right back up in yo muthafuckin ass. See also the
\&\s-1XML::XQL\s0 playa page.) Methodz always apply ta tha reference node.
.PP
For example, tha \fItext()\fR method returns tha text contained within a node, 
minus any structure. (That is, it is tha concatenation of all text nodes 
contained wit a element n' its descendants.) Da followin expression will 
return all authors named 'Bob':
.PP
.Vb 1
\&     author[text() = \*(AqBob\*(Aq]
.Ve
.PP
Da followin will return all authors containin a gangbangin' first-name lil pimp whose 
text is 'Bob':
.PP
.Vb 1
\&     author[first\-name!text() = \*(AqBob\*(Aq]
.Ve
.PP
Da followin will return all authors containin a cold-ass lil lil pimp named Bob:
.PP
.Vb 1
\&     author[*!text() = \*(AqBob\*(Aq]
.Ve
.PP
Method names is case sensitive.
See tha \s-1XML::XQL\s0 playa page on how tha fuck ta define yo' own methodz n' functions.
.SS "Hype methods"
.IX Subsection "Hype methods"
Da followin methodz provide shiznit bout nodes up in a cold-ass lil collection. I aint talkin' bout chicken n' gravy biatch. 
These methodz return strings or numbers,
and may be used up in conjunction wit comparison operators within subqueries.
.IP "Method: \fItext()\fR" 4
.IX Item "Method: text()"
Da \fItext()\fR method concatenates text of tha descendentz of a node, 
normalizin white space along tha way. White space is ghon be preserved fo' a node 
if tha node has tha xml:space attribute set ta 'preserve', or if the
nearest ancestor wit tha xml:space attribute has tha attribute set ta 
\&'preserve'. When white space is normalized, it is normalized across tha 
entire string. Right back up in yo muthafuckin ass. Spaces is used ta separate tha text between nodes. 
When entitizzle references is used up in a thugged-out document, spacin aint banged 
around tha entitizzle refs when they is expanded.
.Sp
In dis implementation, tha method may receive a optionizzle parameter
to indicate whether tha \fItext()\fR of Element nodes should include tha \fItext()\fR of
its Element descendants, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See \s-1XML::XQL\s0 playa page fo' details.
.Sp
Examples:
.Sp
Find tha authors whose last name is 'Bob':
.Sp
.Vb 1
\&     author[last\-name!text() = \*(AqBob\*(Aq]
.Ve
.Sp
Note dis is equivalent to:
.Sp
.Vb 1
\&     author[last\-name = \*(AqBob\*(Aq]
.Ve
.Sp
Find tha authors wit value 'Matthew Bob':
.Sp
.Vb 1
\&     author[text() = \*(AqMatthew Bob\*(Aq]
\&
\&     author[. = \*(AqMatthew Bob\*(Aq]
\&
\&     lyricist = \*(AqMatthew Bob\*(Aq
.Ve
.IP "Method: \fIrawText()\fR" 4
.IX Item "Method: rawText()"
Da \fIrawText()\fR method is similar ta tha \fItext()\fR method yo, but it do not
normalize whitespace.
.Sp
In dis implementation, tha method may receive a optionizzle parameter
to indicate whether tha \fIrawText()\fR of Element nodes should include tha 
\&\fIrawText()\fR of its Element descendants, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See \s-1XML::XQL\s0 playa page fo' details.
.IP "Method: \fIvalue()\fR" 4
.IX Item "Method: value()"
Returns a type cast version of tha value of a node. If no data type is
provided, returns tha same ol' dirty as \fItext()\fR.
.RS 4
.IP "Shortcuts" 4
.IX Item "Shortcuts"
For tha purposez of comparison, value( )is implied if omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. 
In other lyrics, when two shit is compared, tha comparison is between 
the value of tha two items. Remember dat up in absence of type shiznit, 
\&\fIvalue()\fR returns \fItext()\fR.
.Sp
Da followin examplez is equivalent:
.Sp
.Vb 1
\&     author[last\-name!value() = \*(AqBob\*(Aq $and$ first\-name!value() = \*(AqJoe\*(Aq]
\&
\&     author[last\-name = \*(AqBob\*(Aq $and$ first\-name = \*(AqJoe\*(Aq]
\&
\&     price[@intl!value() = \*(Aqcanada\*(Aq]
\&
\&     price[@intl = \*(Aqcanada\*(Aq]
.Ve
.RE
.RS 4
.RE
.IP "Method: \fInodeType()\fR" 4
.IX Item "Method: nodeType()"
Returns a number ta indicate tha type of tha node. Da joints was based
on tha node type joints up in tha \s-1DOM:\s0
.Sp
.Vb 9
\&        element         1
\&        attribute       2
\&        text            3
\&        entitizzle          6       (not up in XQL spec)
\&        PI              7
\&        comment         8
\&        document        9
\&        doc. fragment   10      (not up in XQL spec)
\&        notation        11      (not up in XQL spec)
.Ve
.Sp
Note dat up in \s-1XQL,\s0 CDATASection nodes n' EntityReference nodes also return 3,
whereas up in tha \s-1DOM\s0 CDATASection returns 4 n' EntityReference returns 5.
Use tha \s-1XQL+\s0 method \fIDOM_nodeType()\fR ta git \s-1DOM\s0 node type joints.
See tha \s-1XML::DOM\s0 playa page fo' node type jointz of nodes not mentioned here.
.IP "Method: nodeTypeString" 4
.IX Item "Method: nodeTypeString"
Returns tha name of tha node type up in lowercase or a empty string. Da 
followin node types is currently supported 1 (element), 2 (attribute), 
3 (text), 7 (processing_instruction), 8 (comment), 9 (document)
.IP "Method: \fInodeName()\fR" 4
.IX Item "Method: nodeName()"
Returns tha tag name fo' Element nodes n' tha attribute name of attributes.
.SS "Collection index methods"
.IX Subsection "Collection index methods"
.IP "Method: \fIindex()\fR" 4
.IX Item "Method: index()"
Returns tha index of tha value within tha search context (i.e. wit tha input
list of tha subquery.) This aint necessarily tha same as tha index of a 
node within its parent node. Note dat tha \s-1XQL\s0 spec don't explain it well.
.RS 4
.IP "Examples:" 4
.IX Item "Examples:"
Find tha straight-up original gangsta 3 degrees:
.Sp
.Vb 1
\&     degree[index() $lt$ 3]
.Ve
.Sp
Note dat it skips over other nodes dat may exist between tha degree elements.
.Sp
Consider tha followin data:
.Sp
.Vb 8
\&     <x>
\&       <y/>
\&       <y/>
\&     </x>
\&     <x>
\&       <y/>
\&       <y/>
\&     </x>
.Ve
.Sp
Da followin expression will return tha straight-up original gangsta y from each x:
.Sp
.Vb 1
\&     x/y[index() = 0]
.Ve
.Sp
This could also be accomplished by (see Indexin tha fuck into a Collection):
.Sp
.Vb 1
\&     x/y[0]
.Ve
.RE
.RS 4
.RE
.IP "Method: \fIend()\fR" 4
.IX Item "Method: end()"
Da \fIend()\fR method returns legit fo' tha last element up in tha search context. 
Again, tha \s-1XQL\s0 spec do not explain it well.
.RS 4
.IP "Examples:" 4
.IX Item "Examples:"
Find tha last book:
.Sp
.Vb 1
\&     book[end()]
.Ve
.Sp
Find tha last lyricist fo' each book:
.Sp
.Vb 1
\&     book/author[end()]
.Ve
.Sp
Find tha last lyricist from tha entire set of authorz of books:
.Sp
.Vb 1
\&     (book/author)[end()]
.Ve
.RE
.RS 4
.RE
.SS "Aggregate methods"
.IX Subsection "Aggregate methods"
.IP "Method: count( [\s-1QUERY\s0] )" 4
.IX Item "Method: count( [QUERY] )"
Returns tha number of joints inside tha search context. 
In \s-1XQL+,\s0 when tha optionizzle \s-1QUERY\s0 parameta is supplied, it returns tha number of 
values returned by tha \s-1QUERY.\s0
.SS "Namespace methods"
.IX Subsection "Namespace methods"
Da followin methodz can be applied ta a node ta return namespace shiznit.
.IP "Method: \fIbaseName()\fR" 4
.IX Item "Method: baseName()"
Returns tha local name portion of tha node, excludin tha prefix.
Local names is defined only fo' element nodes n' attribute nodes. 
Da local name of a element node is tha local
portion of tha nodez element type name. Da local name of a attribute node is 
the local portion of tha nodez attribute name. If a local name aint defined 
for tha reference node, tha method evaluates ta tha empty set.
.IP "Method: \fInamespace()\fR" 4
.IX Item "Method: namespace()"
Returns tha \s-1URI\s0 fo' tha namespace of tha node.
Namespace URIs is defined only fo' element nodes n' attribute nodes. 
Da namespace \s-1URI\s0 of a element node is tha namespace \s-1URI\s0 associated wit tha 
nodez element type name. Da namespace \s-1URI\s0 of a attribute node is
the namespace \s-1URI\s0 associated wit tha nodez attribute name. If a namespace 
\&\s-1URI\s0 aint defined fo' tha reference node, tha method evaluates ta tha 
empty set.
.IP "Method: \fIprefix()\fR" 4
.IX Item "Method: prefix()"
Returns tha prefix fo' tha node. Namespace prefixes is defined only fo' 
element nodes n' attribute nodes. Da namespace prefix of a element
node is tha shortname fo' tha namespace of tha nodez element type name. 
Da namespace prefix of a attribute
node is tha shortname fo' tha namespace of tha nodez attribute name. 
If a namespace prefix aint defined 
for tha reference node, tha method evaluates ta tha empty set.
.Sp
Da spec states: A nodez namespace prefix may be defined
within tha query expression, within tha document under query, or within both 
the query expression n' tha document under query. If it is defined up in both 
places tha prefixes may not agree. In dis case, tha prefix assigned by
the query expression takes precedence. 
In dis implementation you cannot define tha namespace fo' a query, so this
can never happen.
.RS 4
.IP "Examples:" 4
.IX Item "Examples:"
Find all unqualified book elements, n' you can put dat on yo' toast. Note dat dis do not return my:book 
elements:
.Sp
.Vb 1
\&     book
.Ve
.Sp
Find all book elements wit tha prefix 'my'. Note dat dis query do not 
return unqualified book elements:
.Sp
.Vb 1
\&     my:book
.Ve
.Sp
Find all book elements wit a 'my' prefix dat have a lyricist subelement:
.Sp
.Vb 1
\&     my:book[author]
.Ve
.Sp
Find all book elements wit a 'my' prefix dat have a lyricist subelement wit a 
my prefix:
.Sp
.Vb 1
\&     my:book[my:author]
.Ve
.Sp
Find all elements wit a prefix of 'my':
.Sp
.Vb 1
\&     my:*
.Ve
.Sp
Find all book elements from any namespace:
.Sp
.Vb 1
\&     *:book
.Ve
.Sp
Find any element from any namespace:
.Sp
.Vb 1
\&     *
.Ve
.Sp
Find tha steez attribute wit a 'my' prefix within a funky-ass book element:
.Sp
.Vb 1
\&     book/@my:style
.Ve
.RE
.RS 4
.Sp
All attributez of a element can be returned rockin @*. 
This is potentially useful fo' applications dat treat attributes
as fieldz up in a record.
.IP "Examples:" 4
.IX Item "Examples:"
Find all attributez of tha current element context:
.Sp
.Vb 1
\&     @*
.Ve
.Sp
Find steez attributes from any namespace:
.Sp
.Vb 1
\&     @*:style
.Ve
.Sp
Find all attributes from tha 'my' namespace, includin unqualified attributes on 
elements from tha 'my' namespace:
.Sp
.Vb 1
\&     @my:*
.Ve
.RE
.RS 4
.RE
.SH "Functions"
.IX Header "Functions"
This section defines tha functionz of \s-1XQL.\s0 Da spec states that: 
\&\s-1XQL\s0 defines two kindz of functions: 
collection functions n' pure functions. Collection functions use tha search 
context of tha Invocation instance, while pure functions ignore the
search context, except ta evaluate tha functionz parametas fo' realz. A collection 
function evaluates ta a subset of tha search context, n' a pure function 
evaluates ta either a cold-ass lil constant value or ta a value dat dependz only on the
functionz parameters.
.PP
Don't worry if you don't git dat shit. Just use them!
.SS "Collection functions"
.IX Subsection "Collection functions"
Da collection functions provide access ta tha various typez of nodes up in a 
document fo' realz. Any of these collections can be constrained n' indexed. Y'all KNOW dat shit, muthafucka! 
Da collections return tha set of lil pimpz of tha reference node meetin tha 
particular restriction.
.IP "Function: \fItextNode()\fR" 4
.IX Item "Function: textNode()"
Da collection of text nodes.
.IP "Function: \fIcomment()\fR" 4
.IX Item "Function: comment()"
Da collection of comment nodes.
.IP "Function: \fIpi()\fR" 4
.IX Item "Function: pi()"
Da collection of processin instruction nodes.
.IP "Function: element( [\s-1NAME\s0] )" 4
.IX Item "Function: element( [NAME] )"
Da collection of all element nodes. If tha optionizzle text
parameta is provided, it only returns element children
matchin dat particular name.
.IP "Function: attribute( [\s-1NAME\s0] )" 4
.IX Item "Function: attribute( [NAME] )"
Da collection of all attribute nodes. If tha optionizzle text
parameta is provided, it only returns attributes matchin that
particular name.
.IP "Function: \fInode()\fR" 4
.IX Item "Function: node()"
Da collection of all non-attribute nodes.
.RS 4
.IP "Examples:" 4
.IX Item "Examples:"
Find tha second text node up in each p element up in tha current context:
.Sp
.Vb 1
\&     p/textNode()[1]
.Ve
.Sp
Find tha second comment anywhere up in tha document. Right back up in yo muthafuckin ass. See Context fo' details on 
settin tha context ta tha document root:
.Sp
.Vb 1
\&     //comment()[1]
.Ve
.RE
.RS 4
.RE
.SS "Other \s-1XQL\s0 Functions"
.IX Subsection "Other XQL Functions"
.IP "Function: ancestor(\s-1QUERY\s0)" 4
.IX Item "Function: ancestor(QUERY)"
Findz tha nearest ancestor matchin tha provided query. Well shiiiit, it returns either a 
single element result or a empty set [].
Note dat dis node is never tha reference node itself.
.RS 4
.IP "Examples:" 4
.IX Item "Examples:"
Find tha nearest book ancestor of tha current element:
.Sp
.Vb 1
\&     ancestor(book)
.Ve
.Sp
Find tha nearest ancestor lyricist element dat is contained up in a funky-ass book element:
.Sp
.Vb 1
\&     ancestor(book/author)
.Ve
.RE
.RS 4
.RE
.IP "Function: id(\s-1NAME\s0)" 4
.IX Item "Function: id(NAME)"
Pure function dat evaluates ta a set. Da set gotz nuff a element node dat 
has a 'id' attribute whose value is identical ta tha strang dat tha Text 
parameta quotes. Da element node may step tha fuck up anywhere within the
document under query. If mo' than one element node meets these criteria,
the function evaluates ta a set dat gotz nuff tha straight-up original gangsta node appearin up in a 
document orderin of tha nodes.
.IP "Function: \fItrue()\fR n' \fIfalse()\fR" 4
.IX Item "Function: true() n' false()"
Pure functions dat each evaluate ta a Boolean. I aint talkin' bout chicken n' gravy biatch. \*(L"\fItrue()\fR\*(R" evaluates ta 'true', 
and \*(L"\fIfalse()\fR\*(R" evaluates ta 'false'. These functions is useful up in expressions 
that is constructed rockin entitizzle references or variable substitution, since 
they may replace a expression found up in a instizzle of Subquery without 
violatin tha syntax required by tha instizzle of Subquery. 
They return a object of type XML::XQL::Boolean.
.IP "Function: date(\s-1QUERY\s0)" 4
.IX Item "Function: date(QUERY)"
\&\*(L"date\*(R" be a pure function dat typecasts tha value of its parameta ta a set of 
dates. If tha parameta matches a single string, tha value of tha function be a 
set containin a single date. If tha parameta matches a \s-1QUERY,\s0 tha value of 
the function be a set of dates, where tha set gotz nuff one date fo' each member
of tha set ta which tha parameta evaluates.
.Sp
\&\s-1XQL\s0 do not define tha representation of tha date value, nor do it
define how tha fuck tha function translates parameta joints tha fuck into dates. 
This implementation uses tha Date::Manip module ta parse dates, which accepts
almost any imaginable format. Right back up in yo muthafuckin ass. See \s-1XML::XQL\s0 ta plug up in yo' own
Date implementation.
.Sp
Include tha XML::XQL::Date package ta add tha \s-1XQL\s0 date type n' tha \fIdate()\fR 
function, like this:
.Sp
.Vb 1
\& use XML::XQL::Date;
.Ve
.IP "Perl builtin functions n' other \s-1XQL+\s0 functions" 4
.IX Item "Perl builtin functions n' other XQL+ functions"
\&\s-1XQL+\s0 serves up \s-1XQL\s0 function wrappers fo' most Perl builtin functions.
It also serves up other def functions like \fIsubst()\fR, \fImap()\fR, n' \fIeval()\fR that
allow you ta modify documents n' embed perl code.
If dis is still not enough, you can add yo' own function n' methods.
See \s-1XML::XQL\s0 playa page fo' details.
.SH "Sequence Operators \- ';' n' ';;'"
.IX Header "Sequence Operators - ';' n' ';;'"
Da whitepaper 'Da Design of \s-1XQL\s0' by Jonathan Robie, which can be found
at <http://www.texcel.no/whitepapers/xql\-design.html> raps bout tha sequence
operators ';;' (precedes) n' ';' (immediately precedes.) Although these
operators is not included up in tha \s-1XQL\s0 spec, I thought I'd add dem anyway.
.SS "Immediately Precedes \- ';'"
.IX Subsection "Immediately Precedes - ';'"
.IP "Example:" 4
.IX Item "Example:"
With tha followin input:
.Sp
.Vb 12
\& <TABLE>
\&  <ROWS>
\&   <TR>
\&    <TD>Shady Grove</TD>
\&    <TD>Aeolian</TD>
\&   </TR>
\&   <TR>
\&    <TD>Over tha River, Charlie</TD>
\&    <TD>Dorian</TD>
\&   </TR>
\&  </ROWS>
\& </TABLE>
.Ve
.Sp
Find tha \s-1TD\s0 node dat gotz nuff \*(L"Shady Grove\*(R" n' tha \s-1TD\s0 node dat immediately
bigs up it:
.Sp
.Vb 1
\&        //(TD="Shady Grove" ; TD)
.Ve
.PP
Note dat up in \s-1XML::DOM\s0 there is straight-up a text node wit whitespace between
the two \s-1TD\s0 nodes yo, but dem is ignored by dis operator, unless tha text node
has 'xml:space' set ta 'preserve'. Right back up in yo muthafuckin ass. See ??, biatch? fo' details.
.SS "Precedes \- ';;'"
.IX Subsection "Precedes - ';;'"
.IP "Example:" 4
.IX Item "Example:"
With tha followin input (from Hamlet):
.Sp
.Vb 9
\& <SPEECH>
\&  <SPEAKER>MARCELLUS</SPEAKER>
\&  <LINE>Tis gone biaatch!</LINE>
\&  <STAGEDIR>Exit Ghost</STAGEDIR>
\&  <LINE>Us dudes do it wrong, bein so majestical,</LINE>
\&  <LINE>To offer it tha show of violins;</LINE>
\&  <LINE>For it is, as tha air, invulnerable,</LINE>
\&  <LINE>And our vain blows malicious mockery.</LINE>
\& </SPEECH>
.Ve
.Sp
Return tha \s-1STAGEDIR\s0 n' all tha LINEs dat follow it:
.Sp
.Vb 1
\&        SPEECH//( STAGEDIR ;; LINE )
.Ve
.Sp
Suppose a hustla playin tha pimp wants ta know when ta exit; dat is, he 
wants ta know whoz ass say what tha fuck line just before
he is supposed ta exit. Da line immediately precedes tha stagedir yo, but tha 
speaker may occur at any time before tha line.
In dis query, we will use tha \*(L"precedes\*(R" operator (\*(L";;\*(R") ta identify a speaker 
that precedes tha line somewhere within a
speech. Our pimp can find tha required shiznit wit tha followin query, 
which selects tha speaker, tha line, n' tha stagedir:
.Sp
.Vb 1
\&        SPEECH//( SPEAKER ;; LINE ; STAGEDIR="Exit Ghost")
.Ve
.SH "Operator Precedence"
.IX Header "Operator Precedence"
Da followin table lists operators up in precedence order, highest precedence 
first, where operatorz of a given row have tha same precedence. 
Da table also lists tha associated thangs:
.PP
.Vb 10
\&        Production      Operator(s)
\&        \-\-\-\-\-\-\-\-\-\-      \-\-\-\-\-\-\-\-\-\-\-
\&        Groupin        ( )
\&        Filta          [ ]
\&        Subscript       [ ]
\&        Bang            !
\&        Path            / //
\&        Match           $match$ $no_match$ =~ !~ (XQL+ only)
\&        Comparison      = != < <= > >= $eq$ $ne$ $lt$ $le$ $gt$
\&                        $ge$ $ieq$ $ine$ $ilt$ $ile$ $igt$ $ige$
\&        Intersection    $intersect$
\&        Union           $union$ |
\&        Negation        $not$
\&        Conjunction     $and$
\&        Disjunction     $or$
\&        Sequence        ; ;;
.Ve
.SH "Sample XML Document \- bookstore.xml"
.IX Header "Sample XML Document - bookstore.xml"
This file be also stored up in samples/bookstore.xml dat comes wit the
\&\s-1XML::XQL\s0 distribution.
.PP
.Vb 10
\& <?xml version=\*(Aq1.0\*(Aq?>
\& <!\-\- This file represents a gangbangin' fragment of a funky-ass book store inventory database \-\->
\& <bookstore specialty=\*(Aqnovel\*(Aq>
\&   <book style=\*(Aqautobiography\*(Aq>
\&     <title>Seven Years up in Trenton</title>
\&     <author>
\&       <first\-name>Joe</first\-name>
\&       <last\-name>Bob</last\-name>
\&       <award>Trenton Literary Review Honorable Mention</award>
\&     </author>
\&     <price>12</price>
\&   </book>
\&   <book style=\*(Aqtextbook\*(Aq>
\&     <title>History of Trenton</title>
\&     <author>
\&       <first\-name>Mary</first\-name>
\&       <last\-name>Bob</last\-name>
\&       <publication>
\&         Selected Short Stories of
\&         <first\-name>Mary</first\-name> <last\-name>Bob</last\-name>
\&       </publication>
\&     </author>
\&     <price>55</price>
\&   </book>
\&   <magazine style=\*(Aqglossy\*(Aq frequency=\*(Aqmonthly\*(Aq>
\&     <title>Trackin Trenton</title>
\&     <price>2.50</price>
\&     <subscription price=\*(Aq24\*(Aq per=\*(Aqyear\*(Aq/>
\&   </magazine>
\&   <book style=\*(Aqnovel\*(Aq id=\*(Aqmyfave\*(Aq>
\&     <title>Trenton Today, Trenton Tomorrow</title>
\&     <author>
\&       <first\-name>Toni</first\-name>
\&       <last\-name>Bob</last\-name>
\&       <degree from=\*(AqTrenton U\*(Aq>B.A.</degree>
\&       <degree from=\*(AqHarvard\*(Aq>Ph.D.</degree>
\&       <award>Pulizer</award>
\&       <publication>Still up in Trenton</publication>
\&       <publication>Trenton Forever</publication>
\&     </author>
\&     <price intl=\*(Aqcanada\*(Aq exchange=\*(Aq0.7\*(Aq>6.50</price>
\&     <excerpt>
\&       <p>Dat shiznit was a thugged-out dark n' stormy night.</p>
\&       <p>But then all nights up in Trenton seem dark and
\&       stormy ta one of mah thugs whoz ass has gone all up in what
\&       <emph>I</emph> have.</p>
\&       <definition\-list>
\&         <term>Trenton</term>
\&         <definition>misery</definition>
\&       </definition\-list>
\&     </excerpt>
\&   </book>
\&   <my:book style=\*(Aqleather\*(Aq price=\*(Aq29.50\*(Aq xmlns:my=\*(Aqhttp://www.placeholder\-name\-here.com/schema/\*(Aq>
\&     <my:title>Who\*(Aqs Dum diddy-dum, here I come biaaatch! Who tha fuck up in Trenton</my:title>
\&     <my:author>Robert Bob</my:author>
\&   </my:book>
\& </bookstore>
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Da Japanese version of dis document can be found on-line at
<http://member.nifty.ne.jp/hippo2000/perltips/xml/xql/tutorial.htm>
.PP
\&\s-1XML::XQL\s0, XML::XQL::Date, XML::XQL::Query n' \s-1XML::XQL::DOM\s0
