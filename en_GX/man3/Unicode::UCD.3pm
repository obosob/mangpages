.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Unicode::UCD 3pm"
.TH Unicode::UCD 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Unicode::UCD \- Unicode characta database
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Unicode::UCD \*(Aqcharinfo\*(Aq;
\&    mah $charinfo   = charinfo($codepoint);
\&
\&    use Unicode::UCD \*(Aqcasefold\*(Aq;
\&    mah $casefold = casefold(0xFB00);
\&
\&    use Unicode::UCD \*(Aqall_casefolds\*(Aq;
\&    mah $all_casefolds_ref = all_casefolds();
\&
\&    use Unicode::UCD \*(Aqcasespec\*(Aq;
\&    mah $casespec = casespec(0xFB00);
\&
\&    use Unicode::UCD \*(Aqcharblock\*(Aq;
\&    mah $charblock  = charblock($codepoint);
\&
\&    use Unicode::UCD \*(Aqcharscript\*(Aq;
\&    mah $charscript = charscript($codepoint);
\&
\&    use Unicode::UCD \*(Aqcharblocks\*(Aq;
\&    mah $charblocks = charblocks();
\&
\&    use Unicode::UCD \*(Aqcharscripts\*(Aq;
\&    mah $charscripts = charscripts();
\&
\&    use Unicode::UCD qw(charscript charinrange);
\&    mah $range = charscript($script);
\&    print "looks like $script\en" if charinrange($range, $codepoint);
\&
\&    use Unicode::UCD qw(general_categories bidi_types);
\&    mah $categories = general_categories();
\&    mah $types = bidi_types();
\&
\&    use Unicode::UCD \*(Aqprop_aliases\*(Aq;
\&    mah @space_names = prop_aliases("space");
\&
\&    use Unicode::UCD \*(Aqprop_value_aliases\*(Aq;
\&    mah @gc_punct_names = prop_value_aliases("Gc", "Punct");
\&
\&    use Unicode::UCD \*(Aqprop_invlist\*(Aq;
\&    mah @puncts = prop_invlist("gc=punctuation");
\&
\&    use Unicode::UCD \*(Aqprop_invmap\*(Aq;
\&    mah ($list_ref, $map_ref, $format, $missing)
\&                                      = prop_invmap("General Category");
\&
\&    use Unicode::UCD \*(Aqcompexcl\*(Aq;
\&    mah $compexcl = compexcl($codepoint);
\&
\&    use Unicode::UCD \*(Aqnamedseq\*(Aq;
\&    mah $namedseq = namedseq($named_sequence_name);
\&
\&    mah $unicode_version = Unicode::UCD::UnicodeVersion();
\&
\&    mah $convert_to_numeric =
\&              Unicode::UCD::num("\eN{RUMI DIGIT ONE}\eN{RUMI DIGIT TWO}");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da Unicode::UCD module offers a seriez of functions that
provide a simple intercourse ta tha Unicode
Characta Database.
.SS "code point argument"
.IX Subsection "code point argument"
Some of tha functions is called wit a \fIcode point argument\fR, which is either
a decimal or a hexadecimal scalar designatin a Unicode code point, or \f(CW\*(C`U+\*(C'\fR
followed by hexadecimals designatin a Unicode code point.  In other lyrics, if
you want a cold-ass lil code point ta be interpreted as a hexadecimal number, you must
prefix it wit either \f(CW\*(C`0x\*(C'\fR or \f(CW\*(C`U+\*(C'\fR, cuz a strang like e.g. \f(CW123\fR will be
interpreted as a thugged-out decimal code point.
.PP
Examples:
.PP
.Vb 4
\&    223     # Decimal 223
\&    0223    # Hexadecimal 223 (= 547 decimal)
\&    0xDF    # Hexadecimal DF (= 223 decimal
\&    U+DF    # Hexadecimal DF
.Ve
.PP
Note dat tha phattest code point up in Unicode is U+10FFFF.
.SS "\fB\fP\f(BIcharinfo()\fP\fB\fP"
.IX Subsection "charinfo()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharinfo\*(Aq;
\&
\&    mah $charinfo = charinfo(0x41);
.Ve
.PP
This returns shiznit bout tha input \*(L"code point argument\*(R"
as a reference ta a hash of fieldz as defined by tha Unicode
standard. Y'all KNOW dat shit, muthafucka!  If tha \*(L"code point argument\*(R" aint assigned up in tha standard
(i.e., has tha general category \f(CW\*(C`Cn\*(C'\fR meanin \f(CW\*(C`Unassigned\*(C'\fR)
or be a non-characta (meanin it is guaranteed ta never be assigned in
the standard),
\&\f(CW\*(C`undef\*(C'\fR is returned.
.PP
Fieldz dat aren't applicable ta tha particular code point argument exist up in the
returned hash, n' is empty.
.PP
Da keys up in tha hash wit tha meaningz of they joints are:
.IP "\fBcode\fR" 4
.IX Item "code"
the input \*(L"code point argument\*(R" expressed up in hexadecimal, wit leadin zeros
added if necessary ta make it contain at least four hexdigits
.IP "\fBname\fR" 4
.IX Item "name"
name of \fIcode\fR, all \s-1IN UPPER CASE.\s0
Some control-type code points aint gots names.
This field is ghon be empty fo' \f(CW\*(C`Surrogate\*(C'\fR n' \f(CW\*(C`Private Use\*(C'\fR code points,
and fo' tha others without a name,
it will contain a thugged-out description enclosed up in angle brackets, like
\&\f(CW\*(C`<control>\*(C'\fR.
.IP "\fBcategory\fR" 4
.IX Item "category"
Da short name of tha general category of \fIcode\fR.
This will match one of tha keys up in tha hash returned by \*(L"\fIgeneral_categories()\fR\*(R".
.Sp
Da \*(L"\fIprop_value_aliases()\fR\*(R" function can be used ta git all tha synonyms
of tha category name.
.IP "\fBcombining\fR" 4
.IX Item "combining"
the combinin class number fo' \fIcode\fR used up in tha Canonical Orderin Algorithm.
For Unicode 5.1, dis is busted lyrics bout up in Section 3.11 \f(CW\*(C`Canonical Orderin Behavior\*(C'\fR
available at
<http://www.unicode.org/versions/Unicode5.1.0/>
.Sp
Da \*(L"\fIprop_value_aliases()\fR\*(R" function can be used ta git all tha synonyms
of tha combinin class number.
.IP "\fBbidi\fR" 4
.IX Item "bidi"
bidirectionizzle type of \fIcode\fR.
This will match one of tha keys up in tha hash returned by \*(L"\fIbidi_types()\fR\*(R".
.Sp
Da \*(L"\fIprop_value_aliases()\fR\*(R" function can be used ta git all tha synonyms
of tha bidi type name.
.IP "\fBdecomposition\fR" 4
.IX Item "decomposition"
is empty if \fIcode\fR has no decomposition; or is one or mo' codes
(separated by spaces) that, taken up in order, represent a thugged-out decomposizzle for
\&\fIcode\fR.  Each has at least four hexdigits.
Da codes may be preceded by a word enclosed up in angle brackets then a space,
like \f(CW\*(C`<compat> \*(C'\fR, givin tha type of decomposition
.Sp
This decomposizzle may be a intermediate one whose components is also
decomposable.  Use Unicode::Normalize ta git tha final decomposition.
.IP "\fBdecimal\fR" 4
.IX Item "decimal"
if \fIcode\fR be a thugged-out decimal digit dis is its integer numeric value
.IP "\fBdigit\fR" 4
.IX Item "digit"
if \fIcode\fR represents some other digit-like number, dis is its integer
numeric value
.IP "\fBnumeric\fR" 4
.IX Item "numeric"
if \fIcode\fR represents a whole or rationizzle number, dis is its numeric value.
Rationizzle joints is expressed as a strang like \f(CW\*(C`1/4\*(C'\fR.
.IP "\fBmirrored\fR" 4
.IX Item "mirrored"
\&\f(CW\*(C`Y\*(C'\fR or \f(CW\*(C`N\*(C'\fR designatin if \fIcode\fR is mirrored up in bidirectionizzle text
.IP "\fBunicode10\fR" 4
.IX Item "unicode10"
name of \fIcode\fR up in tha Unicode 1.0 standard if one
existed fo' dis code point n' is different from tha current name
.IP "\fBcomment\fR" 4
.IX Item "comment"
Az of Unicode 6.0, dis be always empty.
.IP "\fBupper\fR" 4
.IX Item "upper"
is empty if there is no single code point uppercase mappin fo' \fIcode\fR
(its uppercase mappin is itself);
otherwise it is dat mappin expressed as at least four hexdigits.
(\*(L"\fIcasespec()\fR\*(R" should be used up in addizzle ta \fB\f(BIcharinfo()\fB\fR
for case mappings when tha callin program can cope wit multiple code point
mappings.)
.IP "\fBlower\fR" 4
.IX Item "lower"
is empty if there is no single code point lowercase mappin fo' \fIcode\fR
(its lowercase mappin is itself);
otherwise it is dat mappin expressed as at least four hexdigits.
(\*(L"\fIcasespec()\fR\*(R" should be used up in addizzle ta \fB\f(BIcharinfo()\fB\fR
for case mappings when tha callin program can cope wit multiple code point
mappings.)
.IP "\fBtitle\fR" 4
.IX Item "title"
is empty if there is no single code point titlecase mappin fo' \fIcode\fR
(its titlecase mappin is itself);
otherwise it is dat mappin expressed as at least four hexdigits.
(\*(L"\fIcasespec()\fR\*(R" should be used up in addizzle ta \fB\f(BIcharinfo()\fB\fR
for case mappings when tha callin program can cope wit multiple code point
mappings.)
.IP "\fBblock\fR" 4
.IX Item "block"
the block \fIcode\fR belongs ta (used up in \f(CW\*(C`\ep{Blk=...}\*(C'\fR).
See \*(L"Blocks versus Scripts\*(R".
.IP "\fBscript\fR" 4
.IX Item "script"
the script \fIcode\fR belongs to.
See \*(L"Blocks versus Scripts\*(R".
.PP
Note dat you cannot do (de)composizzle n' casin based solely on the
\&\fIdecomposition\fR, \fIcombining\fR, \fIlower\fR, \fIupper\fR, n' \fItitle\fR fields;
you will need also tha \*(L"\fIcompexcl()\fR\*(R", n' \*(L"\fIcasespec()\fR\*(R" functions.
.SS "\fB\fP\f(BIcharblock()\fP\fB\fP"
.IX Subsection "charblock()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharblock\*(Aq;
\&
\&    mah $charblock = charblock(0x41);
\&    mah $charblock = charblock(1234);
\&    mah $charblock = charblock(0x263a);
\&    mah $charblock = charblock("U+263a");
\&
\&    mah $range     = charblock(\*(AqArmenian\*(Aq);
.Ve
.PP
With a \*(L"code point argument\*(R" \fIcharblock()\fR returns tha \fIblock\fR tha code point
belongs to, e.g.  \f(CW\*(C`Basic Latin\*(C'\fR.  Da old-style block name is returned (see
\&\*(L"Old-style versus new-style block names\*(R").
If tha code point is unassigned, dis returns tha block it would belong ta if
it was assigned. Y'all KNOW dat shit, muthafucka!  (If tha Unicode version bein used is so early as ta not
have blocks, all code points is considered ta be up in \f(CW\*(C`No_Block\*(C'\fR.)
.PP
See also \*(L"Blocks versus Scripts\*(R".
.PP
If supplied wit a argument dat can't be a cold-ass lil code point, \fIcharblock()\fR tries to
do tha opposite n' interpret tha argument as a old-style block name. The
return value
is a \fIrange set\fR wit one range: a anonymous list wit a single element that
consistz of another anonymous list whose first element is tha straight-up original gangsta code point
in tha block, n' whose second (and final) element is tha final code point in
the block.  (Da extra list consistin of just one element is so dat tha same
program logic can be used ta handle both dis return, n' tha return from
\&\*(L"\fIcharscript()\fR\*(R" which can have multiple ranges.) Yo ass can test whether a cold-ass lil code
point is up in a range rockin tha \*(L"\fIcharinrange()\fR\*(R" function. I aint talkin' bout chicken n' gravy biatch.  If tha argument is
not a known block, \f(CW\*(C`undef\*(C'\fR is returned.
.SS "\fB\fP\f(BIcharscript()\fP\fB\fP"
.IX Subsection "charscript()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharscript\*(Aq;
\&
\&    mah $charscript = charscript(0x41);
\&    mah $charscript = charscript(1234);
\&    mah $charscript = charscript("U+263a");
\&
\&    mah $range      = charscript(\*(AqThai\*(Aq);
.Ve
.PP
With a \*(L"code point argument\*(R" \fIcharscript()\fR returns tha \fIscript\fR the
code point belongs to, e.g.  \f(CW\*(C`Latin\*(C'\fR, \f(CW\*(C`Greek\*(C'\fR, \f(CW\*(C`Han\*(C'\fR.
If tha code point is unassigned or tha Unicode version bein used is so early
that it aint gots scripts, dis function returns \f(CW"Unknown"\fR.
.PP
If supplied wit a argument dat can't be a cold-ass lil code point, \fIcharscript()\fR tries
to do tha opposite n' interpret tha argument as a script name. The
return value be a \fIrange set\fR: a anonymous list of lists dat contain
\&\fIstart-of-range\fR, \fIend-of-range\fR code point pairs. Yo ass can test whether a
code point is up in a range set rockin tha \*(L"\fIcharinrange()\fR\*(R" function. I aint talkin' bout chicken n' gravy biatch. If the
argument aint a known script, \f(CW\*(C`undef\*(C'\fR is returned.
.PP
See also \*(L"Blocks versus Scripts\*(R".
.SS "\fB\fP\f(BIcharblocks()\fP\fB\fP"
.IX Subsection "charblocks()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharblocks\*(Aq;
\&
\&    mah $charblocks = charblocks();
.Ve
.PP
\&\fIcharblocks()\fR returns a reference ta a hash wit tha known block names
as tha keys, n' tha code point ranges (see \*(L"\fIcharblock()\fR\*(R") as tha joints.
.PP
Da names is up in tha old-style (see \*(L"Old-style versus new-style block
names\*(R").
.PP
prop_invmap(\*(L"block\*(R") can be used ta git dis same data up in a
different type of data structure.
.PP
See also \*(L"Blocks versus Scripts\*(R".
.SS "\fB\fP\f(BIcharscripts()\fP\fB\fP"
.IX Subsection "charscripts()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharscripts\*(Aq;
\&
\&    mah $charscripts = charscripts();
.Ve
.PP
\&\fIcharscripts()\fR returns a reference ta a hash wit tha known script
names as tha keys, n' tha code point ranges (see \*(L"\fIcharscript()\fR\*(R") as
the joints.
.PP
prop_invmap(\*(L"script\*(R") can be used ta git dis same data up in a
different type of data structure.
.PP
See also \*(L"Blocks versus Scripts\*(R".
.SS "\fB\fP\f(BIcharinrange()\fP\fB\fP"
.IX Subsection "charinrange()"
In addizzle ta rockin tha \f(CW\*(C`\ep{Blk=...}\*(C'\fR n' \f(CW\*(C`\eP{Blk=...}\*(C'\fR constructs, you
can also test whether a cold-ass lil code point is up in tha \fIrange\fR as returned by
\&\*(L"\fIcharblock()\fR\*(R" n' \*(L"\fIcharscript()\fR\*(R" or as tha jointz of tha hash returned
by \*(L"\fIcharblocks()\fR\*(R" n' \*(L"\fIcharscripts()\fR\*(R" by rockin \fIcharinrange()\fR:
.PP
.Vb 1
\&    use Unicode::UCD qw(charscript charinrange);
\&
\&    $range = charscript(\*(AqHiragana\*(Aq);
\&    print "looks like hiragana\en" if charinrange($range, $codepoint);
.Ve
.SS "\fB\fP\f(BIgeneral_categories()\fP\fB\fP"
.IX Subsection "general_categories()"
.Vb 1
\&    use Unicode::UCD \*(Aqgeneral_categories\*(Aq;
\&
\&    mah $categories = general_categories();
.Ve
.PP
This returns a reference ta a hash which has short
general category names (like fuckin \f(CW\*(C`Lu\*(C'\fR, \f(CW\*(C`Nd\*(C'\fR, \f(CW\*(C`Zs\*(C'\fR, \f(CW\*(C`S\*(C'\fR) as keys n' long
names (like fuckin \f(CW\*(C`UppercaseLetter\*(C'\fR, \f(CW\*(C`DecimalNumber\*(C'\fR, \f(CW\*(C`SpaceSeparator\*(C'\fR,
\&\f(CW\*(C`Symbol\*(C'\fR) as joints, n' you can put dat on yo' toast.  Da hash is reversible up in case you need ta go
from tha long names ta tha short names.  Da general category is the
one returned from
\&\*(L"\fIcharinfo()\fR\*(R" under tha \f(CW\*(C`category\*(C'\fR key.
.PP
Da \*(L"\fIprop_value_aliases()\fR\*(R" function can be used ta git all tha synonyms of
the category name.
.SS "\fB\fP\f(BIbidi_types()\fP\fB\fP"
.IX Subsection "bidi_types()"
.Vb 1
\&    use Unicode::UCD \*(Aqbidi_types\*(Aq;
\&
\&    mah $categories = bidi_types();
.Ve
.PP
This returns a reference ta a hash which has tha short
bidi (bidirectional) type names (like fuckin \f(CW\*(C`L\*(C'\fR, \f(CW\*(C`R\*(C'\fR) as keys n' long
names (like fuckin \f(CW\*(C`Left\-to\-Right\*(C'\fR, \f(CW\*(C`Right\-to\-Left\*(C'\fR) as joints, n' you can put dat on yo' toast.  The
hash is reversible up in case you need ta go from tha long names ta the
short names.  Da bidi type is tha one returned from
\&\*(L"\fIcharinfo()\fR\*(R"
under tha \f(CW\*(C`bidi\*(C'\fR key.  For tha exact meanin of tha various bidi classes
the Unicode \s-1TR9\s0 is recommended reading:
<http://www.unicode.org/reports/tr9/>
(az of Unicode 5.0.0)
.PP
Da \*(L"\fIprop_value_aliases()\fR\*(R" function can be used ta git all tha synonyms of
the bidi type name.
.SS "\fB\fP\f(BIcompexcl()\fP\fB\fP"
.IX Subsection "compexcl()"
.Vb 1
\&    use Unicode::UCD \*(Aqcompexcl\*(Aq;
\&
\&    mah $compexcl = compexcl(0x09dc);
.Ve
.PP
This routine returns \f(CW\*(C`undef\*(C'\fR if tha Unicode version bein used is so early
that it aint gots dis property.  It be included fo' backwards
compatibilitizzle yo, but az of Perl 5.12 n' mo' modern Unicode versions, for
most purposes it is probably mo' convenient ta use one of tha following
instead:
.PP
.Vb 2
\&    mah $compexcl = chr(0x09dc) =~ /\ep{Comp_Ex};
\&    mah $compexcl = chr(0x09dc) =~ /\ep{Full_Composition_Exclusion};
.Ve
.PP
or even
.PP
.Vb 2
\&    mah $compexcl = chr(0x09dc) =~ /\ep{CE};
\&    mah $compexcl = chr(0x09dc) =~ /\ep{Composition_Exclusion};
.Ve
.PP
Da first two forms return \fBtrue\fR if tha \*(L"code point argument\*(R" should not
be produced by composizzle normalization. I aint talkin' bout chicken n' gravy biatch.  For tha final two forms ta return
\&\fBtrue\fR, it be additionally required dat dis fact not otherwise be
determinable from tha Unicode data base.
.PP
This routine behaves identically ta tha final two forms.  That is,
it do not return \fBtrue\fR if tha code point has a thugged-out decomposition
consistin of another single code point, nor if its decomposizzle starts
with a cold-ass lil code point whose combinin class is non-zero.  Code points dat meet
either of these conditions should also not be produced by composition
normalization, which is probably why you should use the
\&\f(CW\*(C`Full_Composition_Exclusion\*(C'\fR property instead, as shown above.
.PP
Da routine returns \fBfalse\fR otherwise.
.SS "\fB\fP\f(BIcasefold()\fP\fB\fP"
.IX Subsection "casefold()"
.Vb 1
\&    use Unicode::UCD \*(Aqcasefold\*(Aq;
\&
\&    mah $casefold = casefold(0xDF);
\&    if (defined $casefold) {
\&        mah @full_fold_hex = split / /, $casefold\->{\*(Aqfull\*(Aq};
\&        mah $full_fold_strin =
\&                    join "", map {chr(hex($_))} @full_fold_hex;
\&        mah @turkic_fold_hex =
\&                        split / /, ($casefold\->{\*(Aqturkic\*(Aq} ne "")
\&                                        ? $casefold\->{\*(Aqturkic\*(Aq}
\&                                        : $casefold\->{\*(Aqfull\*(Aq};
\&        mah $turkic_fold_strin =
\&                        join "", map {chr(hex($_))} @turkic_fold_hex;
\&    }
\&    if (defined $casefold && $casefold\->{\*(Aqsimple\*(Aq} ne "") {
\&        mah $simple_fold_hex = $casefold\->{\*(Aqsimple\*(Aq};
\&        mah $simple_fold_strin = chr(hex($simple_fold_hex));
\&    }
.Ve
.PP
This returns tha (almost) locale-independent case foldin of the
characta specified by tha \*(L"code point argument\*(R".  (Startin up in Perl v5.16,
the core function \f(CW\*(C`fc()\*(C'\fR returns tha \f(CW\*(C`full\*(C'\fR mappin (busted lyrics bout below)
fasta than dis do, n' fo' entire strings.)
.PP
If there is no case foldin fo' tha input code point, \f(CW\*(C`undef\*(C'\fR is returned.
.PP
If there be a cold-ass lil case foldin fo' dat code point, a reference ta a hash
with tha followin fieldz is returned:
.IP "\fBcode\fR" 4
.IX Item "code"
the input \*(L"code point argument\*(R" expressed up in hexadecimal, wit leadin zeros
added if necessary ta make it contain at least four hexdigits
.IP "\fBfull\fR" 4
.IX Item "full"
one or mo' codes (separated by spaces) that, taken up in order, give the
code points fo' tha case foldin fo' \fIcode\fR.
Each has at least four hexdigits.
.IP "\fBsimple\fR" 4
.IX Item "simple"
is empty, or is exactly one code wit at least four hexdigits which can be used
as a alternatizzle case foldin when tha callin program cannot cope wit the
fold bein a sequence of multiple code points, n' you can put dat on yo' toast.  If \fIfull\fR is just one code
point, then \fIsimple\fR equals \fIfull\fR.  If there is no single code point folding
defined fo' \fIcode\fR, then \fIsimple\fR is tha empty string.  Otherwise, it be an
inferior yo, but still better-than-nothang alternatizzle foldin ta \fIfull\fR.
.IP "\fBmapping\fR" 4
.IX Item "mapping"
is tha same ol' dirty as \fIsimple\fR if \fIsimple\fR aint empty, n' it is tha same ol' dirty as \fIfull\fR
otherwise.  It can be considered ta be tha simplest possible foldin for
\&\fIcode\fR.  It be defined primarily fo' backwardz compatibility.
.IP "\fBstatus\fR" 4
.IX Item "status"
is \f(CW\*(C`C\*(C'\fR (for \f(CW\*(C`common\*(C'\fR) if tha dopest possible fold be a single code point
(\fIsimple\fR equals \fIfull\fR equals \fImapping\fR).  It be \f(CW\*(C`S\*(C'\fR if there be distinct
folds, \fIsimple\fR n' \fIfull\fR (\fImapping\fR equals \fIsimple\fR).  And it is \f(CW\*(C`F\*(C'\fR if
there is only a \fIfull\fR fold (\fImapping\fR equals \fIfull\fR; \fIsimple\fR is empty).
Note dat this
raps bout tha contentz of \fImapping\fR.  It be defined primarily fo' backwards
compatibility.
.Sp
For Unicode versions between 3.1 n' 3.1.1 inclusive, \fIstatus\fR can also be
\&\f(CW\*(C`I\*(C'\fR which is tha same ol' dirty as \f(CW\*(C`C\*(C'\fR but be a special case fo' dotted uppercase I and
dotless lowercase i:
.RS 4
.ie n .IP "\fB*\fR If you use dis ""I"" mapping" 4
.el .IP "\fB*\fR If you use dis \f(CWI\fR mapping" 4
.IX Item "* If you use dis I mapping"
the result is case-insensitive,
but dotless n' dotted Iz is not distinguished
.ie n .IP "\fB*\fR If you exclude dis ""I"" mapping" 4
.el .IP "\fB*\fR If you exclude dis \f(CWI\fR mapping" 4
.IX Item "* If you exclude dis I mapping"
the result aint straight-up case-insensitizzle yo, but
dotless n' dotted Iz is distinguished
.RE
.RS 4
.RE
.IP "\fBturkic\fR" 4
.IX Item "turkic"
gotz nuff any special foldin fo' Turkic languages.  For versionz of Unicode
startin wit 3.2, dis field is empty unless \fIcode\fR has a gangbangin' finger-lickin' different folding
in Turkic languages, up in which case it is one or mo' codes (separated by
spaces) that, taken up in order, give tha code points fo' tha case foldin for
\&\fIcode\fR up in dem languages.
Each code has at least four hexdigits.
Note dat dis foldin do not maintain canonical equivalence without
additionizzle processing.
.Sp
For Unicode versions between 3.1 n' 3.1.1 inclusive, dis field is empty unless
there be a
special foldin fo' Turkic languages, up in which case \fIstatus\fR is \f(CW\*(C`I\*(C'\fR, and
\&\fImapping\fR, \fIfull\fR, \fIsimple\fR, n' \fIturkic\fR is all equal.
.PP
Programs dat want complete generalitizzle n' tha dopest foldin thangs up in dis biatch should use
the foldin contained up in tha \fIfull\fR field. Y'all KNOW dat shit, muthafucka!  But note dat tha fold fo' some
code points is ghon be a sequence of multiple code points.
.PP
Programs dat can't cope wit tha fold mappin bein multiple code points can
use tha foldin contained up in tha \fIsimple\fR field, wit tha loss of some
generality.  In Unicode 5.1, bout 7% of tha defined foldings have no single
code point folding.
.PP
Da \fImapping\fR n' \fIstatus\fR fieldz is provided fo' backwardz compatibilitizzle for
existin programs.  They contain tha same joints as up in previous versions of
this function.
.PP
Locale aint straight-up independent.  Da \fIturkic\fR field gotz nuff thangs up in dis biatch to
use when tha locale be a Turkic language.
.PP
For mo' shiznit bout case mappings see
<http://www.unicode.org/unicode/reports/tr21>
.SS "\fB\fP\f(BIall_casefolds()\fP\fB\fP"
.IX Subsection "all_casefolds()"
.Vb 1
\&    use Unicode::UCD \*(Aqall_casefolds\*(Aq;
\&
\&    mah $all_folds_ref = all_casefolds();
\&    foreach mah $char_with_casefold (sort { $a <=> $b }
\&                                    keys %$all_folds_ref)
\&    {
\&        printf "%04X:", $char_with_casefold;
\&        mah $casefold = $all_folds_ref\->{$char_with_casefold};
\&
\&        # Git foldz fo' $char_with_casefold
\&
\&        mah @full_fold_hex = split / /, $casefold\->{\*(Aqfull\*(Aq};
\&        mah $full_fold_strin =
\&                    join "", map {chr(hex($_))} @full_fold_hex;
\&        print " full=", join " ", @full_fold_hex;
\&        mah @turkic_fold_hex =
\&                        split / /, ($casefold\->{\*(Aqturkic\*(Aq} ne "")
\&                                        ? $casefold\->{\*(Aqturkic\*(Aq}
\&                                        : $casefold\->{\*(Aqfull\*(Aq};
\&        mah $turkic_fold_strin =
\&                        join "", map {chr(hex($_))} @turkic_fold_hex;
\&        print "; turkic=", join " ", @turkic_fold_hex;
\&        if (defined $casefold && $casefold\->{\*(Aqsimple\*(Aq} ne "") {
\&            mah $simple_fold_hex = $casefold\->{\*(Aqsimple\*(Aq};
\&            mah $simple_fold_strin = chr(hex($simple_fold_hex));
\&            print "; simple=$simple_fold_hex";
\&        }
\&        print "\en";
\&    }
.Ve
.PP
This returns all tha case foldings up in tha current version of Unicode up in the
form of a reference ta a hash.  Each key ta tha hash is tha decimal
representation of a Unicode characta dat has a cold-ass lil casefold ta other than
itself.  Da casefold of a semi-colon is itself, so it aint up in tha hash;
likewise fo' a lowercase \*(L"a\*(R" yo, but there be a entry fo' a cold-ass lil capital \*(L"A\*(R".  The
hash value fo' each key be another hash, identical ta what tha fuck is returned by
\&\*(L"\fIcasefold()\fR\*(R" if called wit dat code point as its argument.  So tha value
\&\f(CW\*(C`all_casefolds()\->{ord("A")}\*(Aq\*(C'\fR is equivalent ta \f(CW\*(C`casefold(ord("A"))\*(C'\fR;
.SS "\fB\fP\f(BIcasespec()\fP\fB\fP"
.IX Subsection "casespec()"
.Vb 1
\&    use Unicode::UCD \*(Aqcasespec\*(Aq;
\&
\&    mah $casespec = casespec(0xFB00);
.Ve
.PP
This returns tha potentially locale-dependent case mappingz of tha \*(L"code point
argument\*(R".  Da mappings may be longer than a single code point (which tha basic
Unicode case mappings as returned by \*(L"\fIcharinfo()\fR\*(R" never are).
.PP
If there be no case mappings fo' tha \*(L"code point argument\*(R", or if all three
possible mappings (\fIlower\fR, \fItitle\fR n' \fIupper\fR) result up in single code
points n' is locale independent n' unconditional, \f(CW\*(C`undef\*(C'\fR is returned
(which means dat tha case mappings, if any, fo' tha code point is them
returned by \*(L"\fIcharinfo()\fR\*(R").
.PP
Otherwise, a reference ta a hash givin tha mappings (or a reference ta a hash
of such hashes, explained below) is returned wit tha followin keys n' their
meanings:
.PP
Da keys up in tha bottom layer hash wit tha meaningz of they joints are:
.IP "\fBcode\fR" 4
.IX Item "code"
the input \*(L"code point argument\*(R" expressed up in hexadecimal, wit leadin zeros
added if necessary ta make it contain at least four hexdigits
.IP "\fBlower\fR" 4
.IX Item "lower"
one or mo' codes (separated by spaces) that, taken up in order, give the
code points fo' tha lower case of \fIcode\fR.
Each has at least four hexdigits.
.IP "\fBtitle\fR" 4
.IX Item "title"
one or mo' codes (separated by spaces) that, taken up in order, give the
code points fo' tha title case of \fIcode\fR.
Each has at least four hexdigits.
.IP "\fBupper\fR" 4
.IX Item "upper"
one or mo' codes (separated by spaces) that, taken up in order, give the
code points fo' tha upper case of \fIcode\fR.
Each has at least four hexdigits.
.IP "\fBcondition\fR" 4
.IX Item "condition"
the conditions fo' tha mappings ta be valid.
If \f(CW\*(C`undef\*(C'\fR, tha mappings is always valid.
When defined, dis field be a list of conditions,
all of which must be legit fo' tha mappings ta be valid.
Da list consistz of one or more
\&\fIlocales\fR (see below)
and/or \fIcontexts\fR (explained up in tha next paragraph),
separated by spaces.
(Other than as used ta separate elements, spaces is ta be ignored.)
Case distinctions up in tha condizzle list is not significant.
Conditions preceded by \*(L"\s-1NON_\*(R"\s0 represent tha negation of tha condition.
.Sp
A \fIcontext\fR is one of dem defined up in tha Unicode standard.
For Unicode 5.1, they is defined up in Section 3.13 \f(CW\*(C`Default Case Operations\*(C'\fR
available at
<http://www.unicode.org/versions/Unicode5.1.0/>.
These is fo' context-sensitizzle casing.
.PP
Da hash busted lyrics bout above is returned fo' locale-independent casing, where
at least one of tha mappings has length longer than one.  If \f(CW\*(C`undef\*(C'\fR is
returned, tha code point may have mappings yo, but if so, all is length one,
and is returned by \*(L"\fIcharinfo()\fR\*(R".
Note dat when dis function do return a value, it is ghon be fo' tha complete
set of mappings fo' a cold-ass lil code point, even dem whose length is one.
.PP
If there be additionizzle casin rulez dat apply only up in certain locales,
an additionizzle key fo' each is ghon be defined up in tha returned hash.  Each such key
will be its locale name, defined as a 2\-letta \s-1ISO 3166\s0 ghetto code, possibly
followed by a \*(L"_\*(R" n' a 2\-letta \s-1ISO\s0 language code (possibly followed by a \*(L"_\*(R"
and a variant code).  Yo ass can find tha listz of all possible locales, see
Locale::Ghetto n' Locale::Language.
(In Unicode 6.0, tha only localez returned by dis function
are \f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`tr\*(C'\fR, n' \f(CW\*(C`az\*(C'\fR.)
.PP
Each locale key be a reference ta a hash dat has tha form above, n' gives
the casin rulez fo' dat particular locale, which take precedence over the
locale-independent ones when up in dat locale.
.PP
If tha only casin fo' a cold-ass lil code point is locale-dependent, then tha returned
hash aint gonna have any of tha base keys, like \f(CW\*(C`code\*(C'\fR, \f(CW\*(C`upper\*(C'\fR, etc. yo, but
will contain only locale keys.
.PP
For mo' shiznit bout case mappings see
<http://www.unicode.org/unicode/reports/tr21/>
.SS "\fB\fP\f(BInamedseq()\fP\fB\fP"
.IX Subsection "namedseq()"
.Vb 1
\&    use Unicode::UCD \*(Aqnamedseq\*(Aq;
\&
\&    mah $namedseq = namedseq("KATAKANA LETTER AINU P");
\&    mah @namedseq = namedseq("KATAKANA LETTER AINU P");
\&    mah %namedseq = namedseq();
.Ve
.PP
If used wit a single argument up in a scalar context, returns tha string
consistin of tha code pointz of tha named sequence, or \f(CW\*(C`undef\*(C'\fR if no
named sequence by dat name exists, n' you can put dat on yo' toast.  If used wit a single argument in
a list context, it returns tha list of tha ordinalz of tha code points, n' you can put dat on yo' toast.  If used
with no
arguments up in a list context, returns a hash wit tha namez of the
named sequences as tha keys n' tha named sequences as strings as
the joints, n' you can put dat on yo' toast.  Otherwise, it returns \f(CW\*(C`undef\*(C'\fR or a empty list depending
on tha context.
.PP
This function only operates on officially approved (not provisional) named
sequences.
.PP
Note dat az of Perl 5.14, \f(CW\*(C`\eN{KATAKANA LETTER AINU P}\*(C'\fR will bang tha named
sequence tha fuck into double-quoted strings, n' \f(CW\*(C`charnames::string_vianame("KATAKANA
LETTER AINU P")\*(C'\fR will return tha same strang dis function do yo, but will also
operate on characta names dat aren't named sequences, without you havin to
know which is which.  See charnames.
.SS "\fB\fP\f(BInum()\fP\fB\fP"
.IX Subsection "num()"
.Vb 1
\&    use Unicode::UCD \*(Aqnum\*(Aq;
\&
\&    mah $val = num("123");
\&    mah $one_quarta = num("\eN{VULGAR FRACTION 1/4}");
.Ve
.PP
\&\f(CW\*(C`num\*(C'\fR returns tha numeric value of tha input Unicode string; or \f(CW\*(C`undef\*(C'\fR if it
doesn't be thinkin tha entire strang has a cold-ass lil straight-up valid, safe numeric value.
.PP
If tha strang is just one characta up in length, tha Unicode numeric value
is returned if it has one, or \f(CW\*(C`undef\*(C'\fR otherwise.  Note dat dis need
not be a whole number n' shit.  \f(CW\*(C`num("\eN{TIBETAN DIGIT HALF ZERO}")\*(C'\fR, for
example returns \-0.5.
.PP
If tha strang is mo' than one character, \f(CW\*(C`undef\*(C'\fR is returned unless
all its charactas is decimal digits (that is, they would match \f(CW\*(C`\ed+\*(C'\fR),
from tha same script.  For example if you have a \s-1ASCII \s0'0' n' a Bengali
\&'3', mixed together, they aren't considered a valid number, n' \f(CW\*(C`undef\*(C'\fR
is returned. Y'all KNOW dat shit, muthafucka!  A further restriction is dat tha digits all gotta be of
the same form.  A half-width digit mixed wit a gangbangin' full-width one will
return \f(CW\*(C`undef\*(C'\fR.  Da Arabic script has two setz of digits;  \f(CW\*(C`num\*(C'\fR will
return \f(CW\*(C`undef\*(C'\fR unless all tha digits up in tha strang come from tha same
set.
.PP
\&\f(CW\*(C`num\*(C'\fR errs on tha side of safety, n' there may be valid strings of
decimal digits dat it don't recognize.  Note dat Unicode defines
a number of \*(L"digit\*(R" charactas dat aren't \*(L"decimal digit\*(R" characters.
\&\*(L"Decimal digits\*(R" have tha property dat they gotz a positionizzle value, i.e.,
there be a units position, a 10z position, a 100's, etc, \s-1AND\s0 they are
arranged up in Unicode up in blockz of 10 contiguous code points, n' you can put dat on yo' toast.  Da Chinese
digits, fo' example, is not up in such a cold-ass lil contiguous block, n' so Unicode
doesn't view dem as decimal digits yo, but merely digits, n' so \f(CW\*(C`\ed\*(C'\fR will not
match em.  A single-characta strang containin one of these digits will
have its decimal value returned by \f(CW\*(C`num\*(C'\fR yo, but any longer strang containing
only these digits will return \f(CW\*(C`undef\*(C'\fR.
.PP
Stringz of multiple sub\- n' superscripts is not recognized as numbers.  You
can use either of tha compatibilitizzle decompositions up in Unicode::Normalize to
change these tha fuck into digits, n' then call \f(CW\*(C`num\*(C'\fR on tha result.
.SS "\fB\fP\f(BIprop_aliases()\fP\fB\fP"
.IX Subsection "prop_aliases()"
.Vb 1
\&    use Unicode::UCD \*(Aqprop_aliases\*(Aq;
\&
\&    mah ($short_name, $full_name, @other_names) = prop_aliases("space");
\&    mah $same_full_name = prop_aliases("Space");     # Scalar context
\&    mah ($same_short_name) = prop_aliases("Space");  # gets 0th element
\&    print "Da full name is $full_name\en";
\&    print "Da short name is $short_name\en";
\&    print "Da other aliases are: ", join(", ", @other_names), "\en";
\&
\&    prints:
\&    Da full name is White_Space
\&    Da short name is WSpace
\&    Da other aliases are: Space
.Ve
.PP
Most Unicode propertizzles have nuff muthafuckin synonymous names.  Typically, there be at
least a gangbangin' finger-lickin' dirty-ass short name, convenient ta type, n' a long-ass name dat mo' fully
raps bout tha property, n' hence is mo' easily understood.
.PP
If you know one name fo' a Unicode property, you can use \f(CW\*(C`prop_aliases\*(C'\fR ta find
either tha long name (when called up in scalar context), or a list of all of the
names, somewhat ordered so dat tha short name is up in tha 0th element, tha long
name up in tha next element, n' any other synonyms is up in tha remaining
elements, up in no particular order.
.PP
Da long name is returned up in a gangbangin' form sickly capitalized, suitable fo' printing.
.PP
Da input parameta name is loosely matched, which means dat white space,
hyphens, n' underscores is ignored (except fo' tha trailin underscore in
the old_form grandfathered-in \f(CW"L_"\fR, which is betta freestyled as \f(CW"LC"\fR, and
both of which mean \f(CW\*(C`General_Category=Cased Letter\*(C'\fR).
.PP
If tha name is unknown, \f(CW\*(C`undef\*(C'\fR is returned (or a empty list up in list
context).  Note dat Perl typically recognizes property names up in regular
expressions wit a optionizzle \f(CW\*(C`"Is_\*(C'\fR" (with or without tha underscore)
prefixed ta them, like fuckin \f(CW\*(C`\ep{isgc=punct}\*(C'\fR.  This function do not recognize
those up in tha input, returnin \f(CW\*(C`undef\*(C'\fR.  Nor is they included up in tha output
as possible synonyms.
.PP
\&\f(CW\*(C`prop_aliases\*(C'\fR do know bout tha Perl extensions ta Unicode properties,
like fuckin \f(CW\*(C`Any\*(C'\fR n' \f(CW\*(C`XPosixAlpha\*(C'\fR, n' tha single form equivalents ta Unicode
propertizzles like fuckin \f(CW\*(C`XDigit\*(C'\fR, \f(CW\*(C`Greek\*(C'\fR, \f(CW\*(C`In_Greek\*(C'\fR, n' \f(CW\*(C`Is_Greek\*(C'\fR.  The
final example demonstrates dat tha \f(CW"Is_"\fR prefix is recognized fo' these
extensions; it is needed ta resolve ambiguities. Put ya muthafuckin choppers up if ya feel dis!  For example,
\&\f(CW\*(C`prop_aliases(\*(Aqlc\*(Aq)\*(C'\fR returns tha list \f(CW\*(C`(lc, Lowercase_Mapping)\*(C'\fR yo, but
\&\f(CW\*(C`prop_aliases(\*(Aqislc\*(Aq)\*(C'\fR returns \f(CW\*(C`(Is_LC, Cased_Letter)\*(C'\fR.  This is
because \f(CW\*(C`islc\*(C'\fR be a Perl extension which is short for
\&\f(CW\*(C`General_Category=Cased Letter\*(C'\fR.  Da lists returned fo' tha Perl extensions
will not include tha \f(CW"Is_"\fR prefix (whether or not tha input had it) unless
needed ta resolve ambiguities, as shown up in tha \f(CW"islc"\fR example, where the
returned list had one element containin \f(CW"Is_"\fR, n' tha other without.
.PP
It be also possible fo' tha reverse ta happen:  \f(CW\*(C`prop_aliases(\*(Aqisc\*(Aq)\*(C'\fR returns
the list \f(CW\*(C`(isc, ISO_Comment)\*(C'\fR; whereas \f(CW\*(C`prop_aliases(\*(Aqc\*(Aq)\*(C'\fR returns
\&\f(CW\*(C`(C, Other)\*(C'\fR (the latta bein a Perl extension meaning
\&\f(CW\*(C`General_Category=Other\*(C'\fR.
\&\*(L"Propertizzles accessible all up in Unicode::UCD\*(R" up in perluniprops lists tha available
forms, includin which ones is discouraged from use.
.PP
Those discouraged forms is accepted as input ta \f(CW\*(C`prop_aliases\*(C'\fR yo, but is not
returned up in tha lists, n' you can put dat on yo' toast.  \f(CW\*(C`prop_aliases(\*(AqisL&\*(Aq)\*(C'\fR n' \f(CW\*(C`prop_aliases(\*(AqisL_\*(Aq)\*(C'\fR,
which is oldschool synonyms fo' \f(CW"Is_LC"\fR n' should not be used up in freshly smoked up code, are
examplez of all dis bullshit.  These both return \f(CW\*(C`(Is_LC, Cased_Letter)\*(C'\fR.  Thus this
function allows you ta take a gangbangin' finger-lickin' discourarged form, n' find its acceptable
alternatives.  Da same goes wit single-form Block property equivalences.
Only tha forms dat begin wit \f(CW"In_"\fR is not discouraged; if you pass
\&\f(CW\*(C`prop_aliases\*(C'\fR a gangbangin' finger-lickin' discouraged form, yo big-ass booty is ghon git back tha equivalent ones that
begin wit \f(CW"In_"\fR.  It will otherwise be lookin like a new-style block name (see.
\&\*(L"Old-style versus new-style block names\*(R").
.PP
\&\f(CW\*(C`prop_aliases\*(C'\fR do not know bout any user-defined properties, n' will
return \f(CW\*(C`undef\*(C'\fR if called wit one of them.  Likewise fo' Perl internal
properties, wit tha exception of \*(L"Perl_Decimal_Digit\*(R" which it do know
about (and which is documented below up in \*(L"\fIprop_invmap()\fR\*(R").
.SS "\fB\fP\f(BIprop_value_aliases()\fP\fB\fP"
.IX Subsection "prop_value_aliases()"
.Vb 1
\&    use Unicode::UCD \*(Aqprop_value_aliases\*(Aq;
\&
\&    mah ($short_name, $full_name, @other_names)
\&                                   = prop_value_aliases("Gc", "Punct");
\&    mah $same_full_name = prop_value_aliases("Gc", "P");   # Scalar cntxt
\&    mah ($same_short_name) = prop_value_aliases("Gc", "P"); # gets 0th
\&                                                           # element
\&    print "Da full name is $full_name\en";
\&    print "Da short name is $short_name\en";
\&    print "Da other aliases are: ", join(", ", @other_names), "\en";
\&
\&    prints:
\&    Da full name is Punctuation
\&    Da short name is P
\&    Da other aliases are: Punct
.Ve
.PP
Some Unicode propertizzles gotz a restricted set of legal joints, n' you can put dat on yo' toast.  For example,
all binary propertizzles is restricted ta just \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR; n' there
are only all dem dozen possible General Categories.
.PP
For such properties, there be probably nuff muthafuckin synonyms fo' each possible
value.  For example, up in binary properties, \fItruth\fR can be represented by any of
the strings \*(L"Y\*(R", \*(L"Yes\*(R", \*(L"T\*(R", or \*(L"True\*(R"; n' tha General Category
\&\*(L"Punctuation\*(R" by dat string, or \*(L"Punct\*(R", or simply \*(L"P\*(R".
.PP
Like property names, there is typically at least a gangbangin' finger-lickin' dirty-ass short name fo' each such
property-value, n' a long-ass name.  If you know any name of tha property-value,
you can use \f(CW\*(C`prop_value_aliases\*(C'\fR() ta git tha long name (when called in
scalar context), or a list of all tha names, wit tha short name up in tha 0th
element, tha long name up in tha next element, n' any other synonyms up in the
remainin elements, up in no particular order, except dat any all-numeric
synonyms is ghon be last.
.PP
Da long name is returned up in a gangbangin' form sickly capitalized, suitable fo' printing.
.PP
Case, white space, hyphens, n' underscores is ignored up in tha input parameters
(except fo' tha trailin underscore up in tha old-form grandfathered-in general
category property value \f(CW"L_"\fR, which is betta freestyled as \f(CW"LC"\fR).
.PP
If either name is unknown, \f(CW\*(C`undef\*(C'\fR is returned. Y'all KNOW dat shit, muthafucka!  Note dat Perl typically
recognizes property names up in regular expressions wit a optionizzle \f(CW\*(C`"Is_\*(C'\fR"
(with or without tha underscore) prefixed ta them, like fuckin \f(CW\*(C`\ep{isgc=punct}\*(C'\fR.
This function do not recognize dem up in tha property parameter, returning
\&\f(CW\*(C`undef\*(C'\fR.
.PP
If called wit a property dat aint gots synonyms fo' its joints, it
returns tha input value, possibly normalized wit capitalization and
underscores.
.PP
For tha block property, new-style block names is returned (see
\&\*(L"Old-style versus new-style block names\*(R").
.PP
To find tha synonyms fo' single-forms, like fuckin \f(CW\*(C`\ep{Any}\*(C'\fR, use
\&\*(L"\fIprop_aliases()\fR\*(R" instead.
.PP
\&\f(CW\*(C`prop_value_aliases\*(C'\fR do not know bout any user-defined properties, and
will return \f(CW\*(C`undef\*(C'\fR if called wit one of them.
.SS "\fB\fP\f(BIprop_invlist()\fP\fB\fP"
.IX Subsection "prop_invlist()"
\&\f(CW\*(C`prop_invlist\*(C'\fR returns a inversion list (busted lyrics bout below) dat defines all the
code points fo' tha binary Unicode property (or \*(L"property=value\*(R" pair) given
by tha input parameta string:
.PP
.Vb 3
\& use feature \*(Aqsay\*(Aq;
\& use Unicode::UCD \*(Aqprop_invlist\*(Aq;
\& say join ", ", prop_invlist("Any");
\&
\& prints:
\& 0, 1114112
.Ve
.PP
If tha input is unknown \f(CW\*(C`undef\*(C'\fR is returned up in scalar context; a empty-list
in list context.  If tha input is known, tha number of elements in
the list is returned if called up in scalar context.
.PP
perluniprops gives
the list of propertizzles dat dis function accepts, as well as all tha possible
forms fo' dem (includin wit tha optionizzle \*(L"Is_\*(R" prefixes).  (Except this
function don't accept any Perl-internal properties, a shitload of which is listed
there.) This function uses tha same ol' dirty loose or tighta matchin rulez for
resolvin tha input propertyz name as is done fo' regular expressions.  These
are also specified up in perluniprops.  Examplez of rockin tha \*(L"property=value\*(R" form are:
.PP
.Vb 1
\& say join ", ", prop_invlist("Script=Shavian");
\&
\& prints:
\& 66640, 66688
\&
\& say join ", ", prop_invlist("ASCII_Hex_Digit=No");
\&
\& prints:
\& 0, 48, 58, 65, 71, 97, 103
\&
\& say join ", ", prop_invlist("ASCII_Hex_Digit=Yes");
\&
\& prints:
\& 48, 58, 65, 71, 97, 103
.Ve
.PP
Inversion lists is a cold-ass lil compact way of specifyin Unicode property-value
definitions.  Da 0th item up in tha list is tha lowest code point dat has the
property-value.  Da next item (item [1]) is tha lowest code point beyond that
one dat do \s-1NOT\s0 have tha property-value.  And tha next item beyond that
([2]) is tha lowest code point beyond dat one dat do have the
property-value, n' so on. I aint talkin' bout chicken n' gravy biatch.  Put another way, each element up in tha list gives
the beginnin of a range dat has tha property-value (for even numbered
elements), or aint gots tha property-value (for odd numbered elements).
Da name fo' dis data structure stems from tha fact dat each element up in the
list togglez (or inverts) whether tha correspondin range is or aint on the
list.
.PP
In tha final example above, tha straight-up original gangsta \s-1ASCII\s0 Hex digit is code point 48, the
characta \*(L"0\*(R", n' all code points from it all up in 57 (a \*(L"9\*(R") is \s-1ASCII\s0 hex
digits, n' you can put dat on yo' toast.  Code points 58 all up in 64 aren't yo, but 65 (an \*(L"A\*(R") all up in 70 (an \*(L"F\*(R")
are, as is 97 (\*(L"a\*(R") all up in 102 (\*(L"f\*(R").  103 starts a range of code points
that aren't \s-1ASCII\s0 hex digits, n' you can put dat on yo' toast.  That range extendz ta infinity, which on your
computa can be found up in tha variable \f(CW$Unicode::UCD::MAX_CP\fR.  (This
variable be as close ta infinitizzle as Perl can git on yo' platform, n' may be
too high fo' some operations ta work; you may wish ta bust a smalla number for
your purposes.)
.PP
Note dat tha inversion lists returned by dis function can possibly include
non-Unicode code points, dat be anythang above 0x10FFFF.  This is in
contrast ta Perl regular expression matches on dem code points, up in which a
non-Unicode code point always fails ta match.  For example, both of these have
the same result:
.PP
.Vb 2
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=True}      # Fails.
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=False}     # Fails!
.Ve
.PP
And both raise a warnin dat a Unicode property is bein used on a
non-Unicode code point.  It be arguable as ta which is tha erect thang ta do
here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  This function has chosen tha way opposite ta tha Perl regular
expression behavior. Shiiit, dis aint no joke.  This allows you ta easily flip ta ta tha Perl regular
expression way (for you ta go up in tha other direction would be far harder).
Simply add 0x110000 all up in tha end of tha non-empty returned list if it aint
already dat value; n' pop dat value if it is; like:
.PP
.Vb 9
\& mah @list = prop_invlist("foo");
\& if (@list) {
\&     if ($list[\-1] == 0x110000) {
\&         pop @list;  # Defeat tha turnin on fo' above Unicode
\&     }
\&     else {
\&         push @list, 0x110000; # Turn off fo' above Unicode
\&     }
\& }
.Ve
.PP
It be a simple matta ta expand up a inversion list ta a gangbangin' full list of all
code points dat have tha property-value:
.PP
.Vb 10
\& mah @invlist = prop_invlist($property_name);
\& take a thugged-out dirtnap "empty" unless @invlist;
\& mah @full_list;
\& fo' (my $i = 0; $i < @invlist; $i += 2) {
\&    mah $upper = ($i + 1) < @invlist
\&                ? $invlist[$i+1] \- 1      # In range
\&                : $Unicode::UCD::MAX_CP;  # To infinity.  Yo ass may want
\&                                          # ta stop much much earlier;
\&                                          # goin dis high may expose
\&                                          # perl deficiencies wit hella
\&                                          # big-ass numbers.
\&    fo' mah $j ($invlist[$i] .. $upper) {
\&        push @full_list, $j;
\&    }
\& }
.Ve
.PP
\&\f(CW\*(C`prop_invlist\*(C'\fR do not know bout any user-defined nor Perl internal-only
properties, n' will return \f(CW\*(C`undef\*(C'\fR if called wit one of them.
.SS "\fB\fP\f(BIprop_invmap()\fP\fB\fP"
.IX Subsection "prop_invmap()"
.Vb 3
\& use Unicode::UCD \*(Aqprop_invmap\*(Aq;
\& mah ($list_ref, $map_ref, $format, $missing)
\&                                      = prop_invmap("General Category");
.Ve
.PP
\&\f(CW\*(C`prop_invmap\*(C'\fR is used ta git tha complete mappin definizzle fo' a property,
in tha form of a inversion map.  An inversion map consistz of two parallel
arrays.  One be a ordered list of code points dat mark range beginnings, and
the other gives tha value (or mapping) dat all code points up in the
correspondin range have.
.PP
\&\f(CW\*(C`prop_invmap\*(C'\fR is called wit tha name of tha desired property.  Da name is
loosely matched, meanin dat differences up in case, white-space, hyphens, and
underscores is not meaningful (except fo' tha trailin underscore up in the
old-form grandfathered-in property \f(CW"L_"\fR, which is betta freestyled as \f(CW"LC"\fR,
or even better, \f(CW"Gc=LC"\fR).
.PP
Many Unicode propertizzles have mo' than one name (or alias).  \f(CW\*(C`prop_invmap\*(C'\fR
understandz all of these, includin Perl extensions ta em.  Ambiguitizzles are
resolved as busted lyrics bout above fo' \*(L"\fIprop_aliases()\fR\*(R".  Da Perl internal
property "Perl_Decimal_Digit, busted lyrics bout below, be also accepted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \f(CW\*(C`undef\*(C'\fR is
returned if tha property name is unknown.
See \*(L"Propertizzles accessible all up in Unicode::UCD\*(R" up in perluniprops fo' the
propertizzles aaight as inputs ta dis function.
.PP
It be a gangbangin' fatal error ta booty-call dis function except up in list context.
.PP
In addizzle ta tha the two arrays dat form tha inversion map, \f(CW\*(C`prop_invmap\*(C'\fR
returns two other joints; one be a scalar dat gives some details as ta the
format of tha entriez of tha map array; tha other is used fo' specialized
purposes, busted lyrics bout all up in tha end of dis section.
.PP
This means dat \f(CW\*(C`prop_invmap\*(C'\fR returns a 4 element list.  For example,
.PP
.Vb 2
\& mah ($blocks_ranges_ref, $blocks_maps_ref, $format, $default)
\&                                                 = prop_invmap("Block");
.Ve
.PP
In dis call, tha two arrays is ghon be populated as shown below (for Unicode
6.0):
.PP
.Vb 10
\& Index  @blocks_ranges  @blocks_maps
\&   0        0x0000      Basic Latin
\&   1        0x0080      Latin\-1 Supplement
\&   2        0x0100      Latin Extended\-A
\&   3        0x0180      Latin Extended\-B
\&   4        0x0250      IPA Extensions
\&   5        0x02B0      Spacin Modifier Letters
\&   6        0x0300      Combinin Diacritical Marks
\&   7        0x0370      Greek n' Coptic
\&   8        0x0400      Cyrillic
\&  ...
\& 233        0x2B820     No_Block
\& 234        0x2F800     CJK Compatibilitizzle Ideographs Supplement
\& 235        0x2FA20     No_Block
\& 236        0xE0000     Tags
\& 237        0xE0080     No_Block
\& 238        0xE0100     Variation Selectors Supplement
\& 239        0xE01F0     No_Block
\& 240        0xF0000     Supplementary Private Use Area\-A
\& 241        0x100000    Supplementary Private Use Area\-B
\& 242        0x110000    No_Block
.Ve
.PP
Da first line (with Index [0]) means dat tha value fo' code point 0 is \*(L"Basic
Latin\*(R".  Da entry \*(L"0x0080\*(R" up in tha \f(CW@blocks_ranges\fR column up in tha second line
means dat tha value from tha straight-up original gangsta line, \*(L"Basic Latin\*(R", extendz ta all code
points up in tha range from 0 up ta but not includin 0x0080, dat is, through
127.  In other lyrics, tha code points from 0 ta 127 is all up in tha \*(L"Basic
Latin\*(R" block.  Similarly, all code points up in tha range from 0x0080 up ta (but
not including) 0x0100 is up in tha block named \*(L"Latin\-1 Supplement\*(R", etc.
(Notice dat tha return is tha old-style block names; peep \*(L"Old-style versus
new-style block names\*(R").
.PP
Da final line (with Index [242]) means dat tha value fo' all code points above
the legal Unicode maximum code point have tha value \*(L"No_Block\*(R", which is the
term Unicode uses fo' a non-existin block.
.PP
Da arrays straight-up specify tha mappings fo' all possible code points.
Da final element up in a inversion map returned by dis function will always be
for tha range dat consistz of all tha code points dat aren't legal Unicode,
but dat is expressible on tha platform.  (That is, it starts wit code point
0x110000, tha straight-up original gangsta code point above tha legal Unicode maximum, n' extendz to
infinity.) Da value fo' dat range is ghon be tha same dat any typical
unassigned code point has fo' tha specified property.  (Certain unassigned
code points is not \*(L"typical\*(R"; fo' example tha non-characta code points, or
those up in blocks dat is ta be freestyled right-to-left.  Da above-Unicode
rangez value aint based on these atypical code points.)  It could be broke off some disrespec
that, instead of treatin these as unassigned Unicode code points, tha value
for dis range should be \f(CW\*(C`undef\*(C'\fR.  If you wish, you can chizzle tha returned
arrays accordingly.
.PP
Da maps is almost always simple scalars dat should be interpreted as-is.
These joints is dem given up in tha Unicode-supplied data files, which may be
inconsistent as ta capitalization n' as ta which synonym fo' a property-value
is given. I aint talkin' bout chicken n' gravy biatch.  Da thangs up in dis biatch may be normalized by rockin tha \*(L"\fIprop_value_aliases()\fR\*(R"
function.
.PP
There is exceptions ta tha simple scalar maps.  Some propertizzles have some
elements up in they map list dat is theyselves listz of scalars; n' some
special strings is returned dat is not ta be interpreted as-is.  Element
[2] (placed tha fuck into \f(CW$format\fR up in tha example above) of tha returned four element
list  drops some lyrics ta you if tha map has any of these special elements or not, as bigs up:
.ie n .IP "\fB\fB""s""\fB\fR" 4
.el .IP "\fB\f(CBs\fB\fR" 4
.IX Item "s"
means all tha elementz of tha map array is simple scalars, wit no special
elements, n' you can put dat on yo' toast.  Almost all propertizzles is like this, like tha \f(CW\*(C`block\*(C'\fR example
above.
.ie n .IP "\fB\fB""sl""\fB\fR" 4
.el .IP "\fB\f(CBsl\fB\fR" 4
.IX Item "sl"
means dat a shitload of tha map array elements have tha form given by \f(CW"s"\fR, and
the rest is listz of scalars.  For example, here be a portion of tha output
of callin \f(CW\*(C`prop_invmap\*(C'\fR() wit tha \*(L"Script Extensions\*(R" property:
.Sp
.Vb 6
\& @scripts_ranges  @scripts_maps
\&      ...
\&      0x0953      Devanagari
\&      0x0964      [ Bengali, Devanagari, Gurumukhi, Oriya ]
\&      0x0966      Devanagari
\&      0x0970      Common
.Ve
.Sp
Here, tha code points 0x964 n' 0x965 is both used up in Bengali,
Devanagari, Gurmukhi, n' Oriya yo, but no other scripts.
.Sp
Da Name_Alias property be also of dis form.  But each scalar consistz of two
components:  1) tha name, n' 2) tha type of alias dis is.  They are
separated by a cold-ass lil colon n' a space.  In Unicode 6.1, there be nuff muthafuckin alias types:
.RS 4
.ie n .IP """correction""" 4
.el .IP "\f(CWcorrection\fR" 4
.IX Item "correction"
indicates dat tha name be a cold-ass lil erected form fo' the
original gangsta name (which remains valid) fo' tha same code point.
.ie n .IP """control""" 4
.el .IP "\f(CWcontrol\fR" 4
.IX Item "control"
addz a freshly smoked up name fo' a cold-ass lil control character.
.ie n .IP """alternate""" 4
.el .IP "\f(CWalternate\fR" 4
.IX Item "alternate"
is a alternate name fo' a cold-ass lil character
.ie n .IP """figment""" 4
.el .IP "\f(CWfigment\fR" 4
.IX Item "figment"
is a name fo' a cold-ass lil characta dat has been documented but was never up in any
actual standard.
.ie n .IP """abbreviation""" 4
.el .IP "\f(CWabbreviation\fR" 4
.IX Item "abbreviation"
is a cold-ass lil common abbreviation fo' a cold-ass lil character
.RE
.RS 4
.Sp
Da lists is ordered (roughly) so da most thugged-out preferred names come before less
preferred ones.
.Sp
For example,
.Sp
.Vb 10
\& @aliases_ranges        @alias_maps
\&    ...
\&    0x009E        [ \*(AqPRIVACY MESSAGE: control\*(Aq, \*(AqPM: abbreviation\*(Aq ]
\&    0x009F        [ \*(AqAPPLICATION PROGRAM COMMAND: control\*(Aq,
\&                    \*(AqAPC: abbreviation\*(Aq
\&                  ]
\&    0x00A0        \*(AqNBSP: abbreviation\*(Aq
\&    0x00A1        ""
\&    0x00AD        \*(AqSHY: abbreviation\*(Aq
\&    0x00AE        ""
\&    0x01A2        \*(AqLATIN CAPITAL LETTER GHA: erection\*(Aq
\&    0x01A3        \*(AqLATIN SMALL LETTER GHA: erection\*(Aq
\&    0x01A4        ""
\&    ...
.Ve
.Sp
A map ta tha empty strang means dat there is no alias defined fo' tha code
point.
.RE
.ie n .IP "\fB\fB""a""\fB\fR" 4
.el .IP "\fB\f(CBa\fB\fR" 4
.IX Item "a"
is like \f(CW"s"\fR up in dat all tha map array elements is scalars yo, but here they are
restricted ta all bein integers, n' some gotta be adjusted (hence tha name
\&\f(CW"a"\fR) ta git tha erect result.  For example, in:
.Sp
.Vb 2
\& mah ($uppers_ranges_ref, $uppers_maps_ref, $format)
\&                          = prop_invmap("Simple_Uppercase_Mapping");
.Ve
.Sp
the returned arrays be lookin like this:
.Sp
.Vb 7
\& @$uppers_ranges_ref    @$uppers_maps_ref   Note
\&       0                      0
\&      97                     65          \*(Aqa\*(Aq maps ta \*(AqA\*(Aq, b => B ...
\&     123                      0
\&     181                    924          MICRO SIGN => Greek Cap MU
\&     182                      0
\&     ...
.Ve
.Sp
Letz start wit tha second line.  It say dat tha uppercase of code point 97
is 65; or \f(CW\*(C`uc("a")\*(C'\fR == \*(L"A\*(R".  But tha line is fo' tha entire range of code
points 97 all up in 122.  To git tha mappin fo' any code point up in a range, you
take tha offset it has from tha beginnin code point of tha range, n' add
that ta tha mappin fo' dat first code point.  So, tha mappin fo' 122 (\*(L"z\*(R")
is derived by takin tha offset of 122 from 97 (=25) n' addin dat ta 65,
yieldin 90 (\*(L"z\*(R").  Likewise fo' every last muthafuckin thang up in between.
.Sp
Da first line works tha same ol' dirty way.  Da first map up in a range be always the
correct value fo' its code point (because tha adjustment is 0).  Thus the
\&\f(CW\*(C`uc(chr(0))\*(C'\fR is just itself.  Also, \f(CW\*(C`uc(chr(1))\*(C'\fR be also itself, as the
adjustment is 0+1\-0 .. \f(CW\*(C`uc(chr(96))\*(C'\fR is 96.
.Sp
Requirin dis simple adjustment allows tha returned arrays ta be
significantly smalla than otherwise, up ta a gangbangin' factor of 10, speedin up
searchin all up in em.
.ie n .IP "\fB\fB""al""\fB\fR" 4
.el .IP "\fB\f(CBal\fB\fR" 4
.IX Item "al"
means dat a shitload of tha map array elements have tha form given by \f(CW"a"\fR, and
the rest is ordered listz of code points.
For example, in:
.Sp
.Vb 2
\& mah ($uppers_ranges_ref, $uppers_maps_ref, $format)
\&                                 = prop_invmap("Uppercase_Mapping");
.Ve
.Sp
the returned arrays be lookin like this:
.Sp
.Vb 11
\& @$uppers_ranges_ref    @$uppers_maps_ref
\&       0                      0
\&      97                     65
\&     123                      0
\&     181                    924
\&     182                      0
\&     ...
\&    0x0149              [ 0x02BC 0x004E ]
\&    0x014A                    0
\&    0x014B                  330
\&     ...
.Ve
.Sp
This is tha full Uppercase_Mappin property (as opposed ta the
Simple_Uppercase_Mappin given up in tha example fo' format \f(CW"a"\fR).  Da only
difference between tha two up in tha ranges shown is dat tha code point at
0x0149 (\s-1LATIN SMALL LETTER N PRECEDED BY APOSTROPHE\s0) maps ta a strang of two
characters, 0x02BC (\s-1MODIFIER LETTER APOSTROPHE\s0) followed by 0x004E (\s-1LATIN
CAPITAL LETTER N\s0).
.Sp
No adjustments is needed ta entries dat is references ta arrays; each such
entry gonna git exactly one element up in its range, so tha offset be always 0.
.ie n .IP "\fB\fB""ae""\fB\fR" 4
.el .IP "\fB\f(CBae\fB\fR" 4
.IX Item "ae"
This is like \f(CW"a"\fR yo, but some elements is tha empty string, n' should not be
adjusted.
Da one internal Perl property accessible by \f(CW\*(C`prop_invmap\*(C'\fR iz of dis type:
\&\*(L"Perl_Decimal_Digit\*(R" returns a inversion map which gives tha numeric joints
that is represented by tha Unicode decimal digit characters.  Charactas that
don't represent decimal digits map ta tha empty string, like so:
.Sp
.Vb 12
\& @digits    @values
\& 0x0000       ""
\& 0x0030        0
\& 0x003A:      ""
\& 0x0660:       0
\& 0x066A:      ""
\& 0x06F0:       0
\& 0x06FA:      ""
\& 0x07C0:       0
\& 0x07CA:      ""
\& 0x0966:       0
\& ...
.Ve
.Sp
This means dat tha code points from 0 ta 0x2F do not represent decimal digits;
the code point 0x30 (\s-1DIGIT ZERO\s0) represents 0;  code point 0x31, (\s-1DIGIT ONE\s0),
represents 0+1\-0 = 1; ... code point 0x39, (\s-1DIGIT NINE\s0), represents 0+9\-0 = 9;
\&... code points 0x3A all up in 0x65F do not represent decimal digits; 0x660
(ARABIC-INDIC \s-1DIGIT ZERO\s0), represents 0; ... 0x07C1 (\s-1NKO DIGIT ONE\s0),
represents 0+1\-0 = 1 ...
.ie n .IP "\fB\fB""ale""\fB\fR" 4
.el .IP "\fB\f(CBale\fB\fR" 4
.IX Item "ale"
is a cold-ass lil combination of tha \f(CW"al"\fR type n' tha \f(CW"ae"\fR type.  Some of
the map array elements have tha forms given by \f(CW"al"\fR, and
the rest is tha empty string.  Da property \f(CW\*(C`NFKC_Casefold\*(C'\fR has dis form.
An example slice is:
.Sp
.Vb 9
\& @$ranges_ref  @$maps_ref         Note
\&    ...
\&   0x00AA       97                FEMININE ORDINAL INDICATOR => \*(Aqa\*(Aq
\&   0x00AB        0
\&   0x00AD                         SOFT HYPHEN => ""
\&   0x00AE        0
\&   0x00AF     [ 0x0020, 0x0304 ]  MACRON => SPACE . COMBINING MACRON
\&   0x00B0        0
\&   ...
.Ve
.ie n .IP "\fB\fB""ar""\fB\fR" 4
.el .IP "\fB\f(CBar\fB\fR" 4
.IX Item "ar"
means dat all tha elementz of tha map array is either rationizzle numbers or
the strang \f(CW"NaN"\fR, meanin \*(L"Not a Number\*(R".  A rationizzle number is either an
integer, or two integers separated by a solidus (\f(CW"/"\fR).  Da second integer
represents tha denominator of tha division implied by tha solidus, n' is
actually always positive, so it is guaranteed not ta be 0 n' ta not be
signed. Y'all KNOW dat shit, muthafucka!  When tha element be a plain integer (without the
solidus), it may need ta be adjusted ta git tha erect value by addin the
offset, just as other \f(CW"a"\fR properties. Put ya muthafuckin choppers up if ya feel dis!  No adjustment is needed for
fractions, as tha range is guaranteed ta have just a single element, n' so
the offset be always 0.
.Sp
If you wanna convert tha returned map ta entirely scalar numbers, you
can use suttin' like this:
.Sp
.Vb 4
\& mah ($invlist_ref, $invmap_ref, $format) = prop_invmap($property);
\& if ($format && $format eq "ar") {
\&     map { $_ = eval $_ if $_ ne \*(AqNaN\*(Aq } @$map_ref;
\& }
.Ve
.Sp
Herez some entries from tha output of tha property \*(L"Nv\*(R", which has format
\&\f(CW"ar"\fR.
.Sp
.Vb 10
\& @numerics_ranges  @numerics_maps       Note
\&        0x00           "NaN"
\&        0x30             0           DIGIT 0 .. DIGIT 9
\&        0x3A           "NaN"
\&        0xB2             2           SUPERSCRIPTs 2 n' 3
\&        0xB4           "NaN"
\&        0xB9             1           SUPERSCRIPT 1
\&        0xBA           "NaN"
\&        0xBC            1/4          VULGAR FRACTION 1/4
\&        0xBD            1/2          VULGAR FRACTION 1/2
\&        0xBE            3/4          VULGAR FRACTION 3/4
\&        0xBF           "NaN"
\&        0x660            0           ARABIC\-INDIC DIGIT ZERO .. NINE
\&        0x66A          "NaN"
.Ve
.ie n .IP "\fB\fB""n""\fB\fR" 4
.el .IP "\fB\f(CBn\fB\fR" 4
.IX Item "n"
means tha Name property.  All tha elementz of tha map array is simple
scalars yo, but a shitload of dem contain special strings dat require mo' work to
get tha actual name.
.Sp
Entries such as:
.Sp
.Vb 1
\& CJK UNIFIED IDEOGRAPH\-<code point>
.Ve
.Sp
mean dat tha name fo' tha code point is \*(L"\s-1CJK UNIFIED IDEOGRAPH\-\*(R"\s0
with tha code point (expressed up in hexadecimal) appended ta it, like \*(L"\s-1CJK
UNIFIED IDEOGRAPH\-3403\*(R" \s0(similarly fo' \f(CW\*(C`CJK\ COMPATIBILITY\ IDEOGRAPH\-<code\ point>\*(C'\fR).
.Sp
Also, entries like
.Sp
.Vb 1
\& <hangul syllable>
.Ve
.Sp
means dat tha name be algorithmically calculated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This is easily done by
the function \*(L"charnames::viacode(code)\*(R" up in charnames.
.Sp
Note dat fo' control charactas (\f(CW\*(C`Gc=cc\*(C'\fR), Unicodez data filez have the
strin "\f(CW\*(C`<control>\*(C'\fR" yo, but tha real name of each of these charactas is tha empty
string.  This function returns dat real name, tha empty string.  (There are
names fo' these charactas yo, but they is considered aliases, not tha Name
property name, n' is contained up in tha \f(CW\*(C`Name_Alias\*(C'\fR property.)
.ie n .IP "\fB\fB""ad""\fB\fR" 4
.el .IP "\fB\f(CBad\fB\fR" 4
.IX Item "ad"
means tha Decomposition_Mappin property.  This property is like \f(CW"al"\fR
properties, except dat one of tha scalar elements iz of tha form:
.Sp
.Vb 1
\& <hangul syllable>
.Ve
.Sp
This signifies dat dis entry should be replaced by tha decompositions for
all tha code points whose decomposizzle be algorithmically calculated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (All
of dem is currently up in one range n' no others outisde tha range is likely
to eva be added ta Unicode; tha \f(CW"n"\fR format
has dis same entry.)  These can be generated via tha function
\&\fIUnicode::Normalize::NFD()\fR.
.Sp
Note dat tha mappin is tha one dat is specified up in tha Unicode data files,
and ta git tha final decomposition, it may need ta be applied recursively.
.PP
Note dat a gangbangin' format begins wit tha letta \*(L"a\*(R" if n' only tha property it is
for requires adjustments by addin tha offsets up in multi-element ranges.  For
all these properties, a entry should be adjusted only if tha map be a scalar
which be a integer n' shit.  That is, it must match tha regular expression:
.PP
.Vb 1
\&    / ^ \-? \ed+ $ /xa
.Ve
.PP
Further, tha straight-up original gangsta element up in a range never needz adjustment, as the
adjustment would be just addin 0.
.PP
A binary search can be used ta quickly find a cold-ass lil code point up in tha inversion
list, n' hence its correspondin mapping.
.PP
Da final element (index [3], assigned ta \f(CW$default\fR up in tha \*(L"block\*(R" example) in
the four element list returned by dis function may be useful fo' applications
that wish ta convert tha returned inversion map data structure tha fuck into some
other, like fuckin a hash.  It gives tha mappin dat most code points map to
under tha property.  If you establish tha convention dat any code point not
explicitly listed up in yo' data structure maps ta dis value, you can
potentially make yo' data structure much smalla n' shit.  As you construct yo' data
structure from tha one returned by dis function, simply ignore dem ranges
that map ta dis value, generally called tha \*(L"default\*(R" value.  For example, to
convert ta tha data structure searchable by \*(L"\fIcharinrange()\fR\*(R", you can follow
this recipe fo' propertizzles dat don't require adjustments:
.PP
.Vb 2
\& mah ($list_ref, $map_ref, $format, $missing) = prop_invmap($property);
\& mah @range_list;
\&
\& # Look at each element up in tha list yo, but tha \-2 is needed cuz we
\& # peep $i+1 up in tha loop, n' tha final element is guaranteed ta map
\& # ta $missin by prop_invmap(), so we would skip it anyway.
\& fo' mah $i (0 .. @$list_ref \- 2) {
\&    next if $map_ref\->[$i] eq $missing;
\&    push @range_list, [ $list_ref\->[$i],
\&                        $list_ref\->[$i+1],
\&                        $map_ref\->[$i]
\&                      ];
\& }
\&
\& print charinrange(\e@range_list, $code_point), "\en";
.Ve
.PP
With this, \f(CW\*(C`charinrange()\*(C'\fR will return \f(CW\*(C`undef\*(C'\fR if its input code point maps
to \f(CW$missing\fR.  Yo ass can avoid dis by omittin tha \f(CW\*(C`next\*(C'\fR statement, n' adding
a line afta tha loop ta handle tha final element of tha inversion map.
.PP
Similarly, dis recipe can be used fo' propertizzles dat do require adjustments:
.PP
.Vb 2
\& fo' mah $i (0 .. @$list_ref \- 2) {
\&    next if $map_ref\->[$i] eq $missing;
\&
\&    # prop_invmap() guarantees dat if tha mappin is ta a array, the
\&    # range has just one element, so no need ta worry bout adjustments.
\&    if (ref $map_ref\->[$i]) {
\&        push @range_list,
\&                   [ $list_ref\->[$i], $list_ref\->[$i], $map_ref\->[$i] ];
\&    }
\&    else {  # Otherwise each element is straight-up mapped ta a separate
\&            # value, so tha range has ta be split tha fuck into single code point
\&            # ranges.
\&
\&        mah $adjustment = 0;
\&
\&        # For each code point dat gets mapped ta something...
\&        fo' mah $j ($list_ref\->[$i] .. $list_ref\->[$i+1] \-1 ) {
\&
\&            # ... add a range consistin of just it mappin ta the
\&            # original gangsta plus tha adjustment, which is incremented fo' the
\&            # next time all up in tha loop, as tha offset increases by 1
\&            # fo' each element up in tha range
\&            push @range_list,
\&                             [ $j, $j, $map_ref\->[$i] + $adjustment++ ];
\&        }
\&    }
\& }
.Ve
.PP
Note dat tha inversion maps returned fo' tha \f(CW\*(C`Case_Folding\*(C'\fR and
\&\f(CW\*(C`Simple_Case_Folding\*(C'\fR propertizzles do not include tha Turkic-locale mappings.
Use \*(L"\fIcasefold()\fR\*(R" fo' these.
.PP
\&\f(CW\*(C`prop_invmap\*(C'\fR do not know bout any user-defined properties, n' will
return \f(CW\*(C`undef\*(C'\fR if called wit one of them.
.SS "Unicode::UCD::UnicodeVersion"
.IX Subsection "Unicode::UCD::UnicodeVersion"
This returns tha version of tha Unicode Characta Database, up in other lyrics, the
version of tha Unicode standard tha database implements, n' you can put dat on yo' toast.  Da version be a
strin of numbers delimited by dots (\f(CW\*(Aq.\*(Aq\fR).
.SS "\fBBlocks versus Scripts\fP"
.IX Subsection "Blocks versus Scripts"
Da difference between a funky-ass block n' a script is dat scripts is closer
to tha linguistic notion of a set of code points required ta present
languages, while block is mo' of a artifact of tha Unicode code point
numberin n' separation tha fuck into blockz of consecutizzle code points (so far the
size of a funky-ass block is some multiple of 16, like 128 or 256).
.PP
For example tha Latin \fBscript\fR is spread over nuff muthafuckin \fBblocks\fR, such
as \f(CW\*(C`Basic Latin\*(C'\fR, \f(CW\*(C`Latin 1 Supplement\*(C'\fR, \f(CW\*(C`Latin Extended\-A\*(C'\fR, and
\&\f(CW\*(C`Latin Extended\-B\*(C'\fR.  On tha other hand, tha Latin script do not
contain all tha charactaz of tha \f(CW\*(C`Basic Latin\*(C'\fR block (also known as
\&\s-1ASCII\s0): it includes only tha letters, n' not, fo' example, tha digits
or tha punctuation.
.PP
For blocks peep <http://www.unicode.org/Public/UNIDATA/Blocks.txt>
.PP
For scripts peep \s-1UTR\s0 #24: <http://www.unicode.org/unicode/reports/tr24/>
.SS "\fBMatchin Scripts n' Blocks\fP"
.IX Subsection "Matchin Scripts n' Blocks"
Scripts is matched wit tha regular-expression construct
\&\f(CW\*(C`\ep{...}\*(C'\fR (e.g. \f(CW\*(C`\ep{Tibetan}\*(C'\fR matches charactaz of tha Tibetan script),
while \f(CW\*(C`\ep{Blk=...}\*(C'\fR is used fo' blocks (e.g. \f(CW\*(C`\ep{Blk=Tibetan}\*(C'\fR matches
any of tha 256 code points up in tha Tibetan block).
.SS "Old-style versus new-style block names"
.IX Subsection "Old-style versus new-style block names"
Unicode publishes tha namez of blocks up in two different styles, though tha two
are equivalent under Unicodez loose matchin rules.
.PP
Da original gangsta steez uses blanks n' hyphens up in tha block names (except for
\&\f(CW\*(C`No_Block\*(C'\fR), like so:
.PP
.Vb 1
\& Miscellaneous Mathematical Symbols\-B
.Ve
.PP
Da newer steez replaces these wit underscores, like this:
.PP
.Vb 1
\& Miscellaneous_Mathematical_Symbols_B
.Ve
.PP
This newer steez is consistent wit tha jointz of other Unicode properties.
To preserve backward compatibility, all tha functions up in Unicode::UCD that
return block names (except one) return tha old-style ones.  That one function,
\&\*(L"\fIprop_value_aliases()\fR\*(R" can be used ta convert from old-style ta new-style:
.PP
.Vb 1
\& mah $new_style = prop_values_aliases("block", $old_style);
.Ve
.PP
Perl also has single-form extensions dat refer ta blocks, \f(CW\*(C`In_Cyrillic\*(C'\fR,
meanin \f(CW\*(C`Block=Cyrillic\*(C'\fR.  These have always been freestyled up in tha freshly smoked up style.
.PP
To convert from new-style ta old-style, follow dis recipe:
.PP
.Vb 1
\& $old_style = charblock((prop_invlist("block=$new_style"))[0]);
.Ve
.PP
(which findz tha range of code points up in tha block rockin \f(CW\*(C`prop_invlist\*(C'\fR,
gets tha lower end of tha range (0th element) n' then looks up tha oldschool name
for its block rockin \f(CW\*(C`charblock\*(C'\fR).
.PP
Note dat startin up in Unicode 6.1, nuff of tha block names have shorter
synonyms.  These is always given up in tha freshly smoked up style.
.SH "BUGS"
.IX Header "BUGS"
Do not yet support \s-1EBCDIC\s0 platforms.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jarkko Hietaniemi.  Now maintained by perl5 porters.
