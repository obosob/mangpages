.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Handle 3pm"
.TH IO::Handle 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Handle \- supply object methodz fo' I/O handles
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use IO::Handle;
\&
\&    $io = IO::Handle\->new();
\&    if ($io\->fdopen(fileno(STDIN),"r")) {
\&        print $io\->getline;
\&        $io\->close;
\&    }
\&
\&    $io = IO::Handle\->new();
\&    if ($io\->fdopen(fileno(STDOUT),"w")) {
\&        $io\->print("Some text\en");
\&    }
\&
\&    # setvbuf aint available by default on Perls 5.8.0 n' later.
\&    use IO::Handle \*(Aq_IOLBF\*(Aq;
\&    $io\->setvbuf($buffer_var, _IOLBF, 1024);
\&
\&    undef $io;       # automatically closes tha file if it\*(Aqs open
\&
\&    autoflush STDOUT 1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`IO::Handle\*(C'\fR is tha base class fo' all other \s-1IO\s0 handle classes. Well shiiiit, it is
not intended dat objectz of \f(CW\*(C`IO::Handle\*(C'\fR would be pimped directly,
but instead \f(CW\*(C`IO::Handle\*(C'\fR is inherited from by nuff muthafuckin other classes
in tha \s-1IO\s0 hierarchy.
.PP
If yo ass is readin dis documentation, lookin fo' a replacement for
the \f(CW\*(C`FileHandle\*(C'\fR package, then I suggest you read tha documentation
for \f(CW\*(C`IO::File\*(C'\fR like a muthafucka.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "new ()" 4
.IX Item "new ()"
Creates a freshly smoked up \f(CW\*(C`IO::Handle\*(C'\fR object.
.IP "new_from_fd ( \s-1FD, MODE \s0)" 4
.IX Item "new_from_fd ( FD, MODE )"
Creates a \f(CW\*(C`IO::Handle\*(C'\fR like \f(CW\*(C`new\*(C'\fR do.
It requires two parameters, which is passed ta tha method \f(CW\*(C`fdopen\*(C'\fR;
if tha fdopen fails, tha object is destroyed. Y'all KNOW dat shit, muthafucka! Otherwise, it is returned
to tha caller.
.SH "METHODS"
.IX Header "METHODS"
See perlfunc fo' complete descriptionz of each of tha following
supported \f(CW\*(C`IO::Handle\*(C'\fR methods, which is just front endz fo' the
correspondin built-in functions:
.PP
.Vb 10
\&    $io\->close
\&    $io\->eof
\&    $io\->fcntl( FUNCTION, SCALAR )
\&    $io\->fileno
\&    $io\->format_write( [FORMAT_NAME] )
\&    $io\->getc
\&    $io\->ioctl( FUNCTION, SCALAR )
\&    $io\->read ( BUF, LEN, [OFFSET] )
\&    $io\->print ( ARGS )
\&    $io\->printf ( FMT, [ARGS] )
\&    $io\->say ( ARGS )
\&    $io\->stat
\&    $io\->sysread ( BUF, LEN, [OFFSET] )
\&    $io\->syswrite ( BUF, [LEN, [OFFSET]] )
\&    $io\->truncate ( LEN )
.Ve
.PP
See perlvar fo' complete descriptionz of each of tha following
supported \f(CW\*(C`IO::Handle\*(C'\fR methods.  All of dem return tha previous
value of tha attribute n' takes a optionizzle single argument dat when
given will set tha value.  If no argument is given tha previous value
is unchanged (except fo' \f(CW$io\fR\->autoflush will straight-up turn \s-1ON\s0
autoflush by default).
.PP
.Vb 7
\&    $io\->autoflush ( [BOOL] )                         $|
\&    $io\->format_page_number( [NUM] )                  $%
\&    $io\->format_lines_per_page( [NUM] )               $=
\&    $io\->format_lines_left( [NUM] )                   $\-
\&    $io\->format_name( [STR] )                         $~
\&    $io\->format_top_name( [STR] )                     $^
\&    $io\->input_line_number( [NUM])                    $.
.Ve
.PP
Da followin methodz is not supported on a per-filehandle basis.
.PP
.Vb 4
\&    IO::Handle\->format_line_break_characters( [STR] ) $:
\&    IO::Handle\->format_formfeed( [STR])               $^L
\&    IO::Handle\->output_field_separator( [STR] )       $,
\&    IO::Handle\->output_record_separator( [STR] )      $\e
\&
\&    IO::Handle\->input_record_separator( [STR] )       $/
.Ve
.PP
Furthermore, fo' bustin aiiight I/O you might need these:
.ie n .IP "$io\->fdopen ( \s-1FD, MODE \s0)" 4
.el .IP "\f(CW$io\fR\->fdopen ( \s-1FD, MODE \s0)" 4
.IX Item "$io->fdopen ( FD, MODE )"
\&\f(CW\*(C`fdopen\*(C'\fR is like a ordinary \f(CW\*(C`open\*(C'\fR except dat its first parameter
is not a gangbangin' filename but rather a gangbangin' file handle name, a IO::Handle object,
or a gangbangin' file descriptor number n' shit.  (For tha documentation of tha \f(CW\*(C`open\*(C'\fR
method, peep IO::File.)
.ie n .IP "$io\->opened" 4
.el .IP "\f(CW$io\fR\->opened" 4
.IX Item "$io->opened"
Returns legit if tha object is currently a valid file descriptor, false
otherwise.
.ie n .IP "$io\->getline" 4
.el .IP "\f(CW$io\fR\->getline" 4
.IX Item "$io->getline"
This works like <$io> busted lyrics bout up in \*(L"I/O Operators\*(R" up in perlop
except dat itz mo' readable n' can be safely called up in a
list context but still returns just one line.  If used as tha conditional
+within a \f(CW\*(C`while\*(C'\fR or C\-style \f(CW\*(C`for\*(C'\fR loop, however, yo big-ass booty is ghon need to
+emulate tha functionalitizzle of <$io> wit \f(CW\*(C`defined($_ = $io\->getline)\*(C'\fR.
.ie n .IP "$io\->getlines" 4
.el .IP "\f(CW$io\fR\->getlines" 4
.IX Item "$io->getlines"
This works like <$io> when called up in a list context ta read all
the remainin lines up in a gangbangin' file, except dat itz mo' readable.
It will also \fIcroak()\fR if accidentally called up in a scalar context.
.ie n .IP "$io\->ungetc ( \s-1ORD \s0)" 4
.el .IP "\f(CW$io\fR\->ungetc ( \s-1ORD \s0)" 4
.IX Item "$io->ungetc ( ORD )"
Pushes a cold-ass lil characta wit tha given ordinal value back onto tha given
handlez input stream.  Only one characta of pushback per handle is
guaranteed.
.ie n .IP "$io\->write ( \s-1BUF, LEN\s0 [, \s-1OFFSET \s0] )" 4
.el .IP "\f(CW$io\fR\->write ( \s-1BUF, LEN\s0 [, \s-1OFFSET \s0] )" 4
.IX Item "$io->write ( BUF, LEN [, OFFSET ] )"
This \f(CW\*(C`write\*(C'\fR is somewhat like \f(CW\*(C`write\*(C'\fR found up in C, up in dat it is the
opposite of read. Y'all KNOW dat shit, muthafucka! Da wrapper fo' tha perl \f(CW\*(C`write\*(C'\fR function is
called \f(CW\*(C`format_write\*(C'\fR. But fuck dat shiznit yo, tha word on tha street is dat whilst tha C \f(CW\*(C`write\*(C'\fR function returns
the number of bytes written, dis \f(CW\*(C`write\*(C'\fR function simply returns true
if successful (like \f(CW\*(C`print\*(C'\fR) fo' realz. A mo' C\-like \f(CW\*(C`write\*(C'\fR is \f(CW\*(C`syswrite\*(C'\fR
(see above).
.ie n .IP "$io\->error" 4
.el .IP "\f(CW$io\fR\->error" 4
.IX Item "$io->error"
Returns a legit value if tha given handle has experienced any errors
since dat shiznit was opened or since tha last call ta \f(CW\*(C`clearerr\*(C'\fR, or if the
handle is invalid. Y'all KNOW dat shit, muthafucka! Well shiiiit, it only returns false fo' a valid handle wit no
outstandin errors.
.ie n .IP "$io\->clearerr" 4
.el .IP "\f(CW$io\fR\->clearerr" 4
.IX Item "$io->clearerr"
Clear tha given handlez error indicator. Shiiit, dis aint no joke. Returns \-1 if tha handle is
invalid, 0 otherwise.
.ie n .IP "$io\->sync" 4
.el .IP "\f(CW$io\fR\->sync" 4
.IX Item "$io->sync"
\&\f(CW\*(C`sync\*(C'\fR synchronizes a gangbangin' filez in-memory state  wit  dat  on the
physical medium. \f(CW\*(C`sync\*(C'\fR do not operate all up in tha perlio api level yo, but
operates on tha file descriptor (similar ta sysread, sysseek and
systell). This means dat any data held all up in tha perlio api level will not
be synchronized. Y'all KNOW dat shit, muthafucka! To synchronize data dat is buffered all up in tha perlio api
level you must use tha flush method. Y'all KNOW dat shit, muthafucka! \f(CW\*(C`sync\*(C'\fR aint implemented on all
platforms. Returns \*(L"0 but true\*(R" on success, \f(CW\*(C`undef\*(C'\fR on error, \f(CW\*(C`undef\*(C'\fR
for a invalid handle. Right back up in yo muthafuckin ass. See \fIfsync\fR\|(3c).
.ie n .IP "$io\->flush" 4
.el .IP "\f(CW$io\fR\->flush" 4
.IX Item "$io->flush"
\&\f(CW\*(C`flush\*(C'\fR causes perl ta flush any buffered data all up in tha perlio api level.
Any unread data up in tha buffer is ghon be discarded, n' any unwritten data
will be freestyled ta tha underlyin file descriptor. Shiiit, dis aint no joke. Returns \*(L"0 but true\*(R"
on success, \f(CW\*(C`undef\*(C'\fR on error.
.ie n .IP "$io\->printflush ( \s-1ARGS \s0)" 4
.el .IP "\f(CW$io\fR\->printflush ( \s-1ARGS \s0)" 4
.IX Item "$io->printflush ( ARGS )"
Turns on autoflush, print \s-1ARGS\s0 n' then restores tha autoflush statuz of the
\&\f(CW\*(C`IO::Handle\*(C'\fR object. Returns tha return value from print.
.ie n .IP "$io\->blockin ( [ \s-1BOOL \s0] )" 4
.el .IP "\f(CW$io\fR\->blockin ( [ \s-1BOOL \s0] )" 4
.IX Item "$io->blockin ( [ BOOL ] )"
If called wit a argument \f(CW\*(C`blocking\*(C'\fR will turn on non-blockin \s-1IO\s0 if
\&\f(CW\*(C`BOOL\*(C'\fR is false, n' turn it off if \f(CW\*(C`BOOL\*(C'\fR is true.
.Sp
\&\f(CW\*(C`blocking\*(C'\fR will return tha value of tha previous setting, or the
current settin if \f(CW\*(C`BOOL\*(C'\fR aint given.
.Sp
If a error occurs \f(CW\*(C`blocking\*(C'\fR will return undef n' \f(CW$!\fR is ghon be set.
.PP
If tha C functions \fIsetbuf()\fR and/or \fIsetvbuf()\fR is available, then
\&\f(CW\*(C`IO::Handle::setbuf\*(C'\fR n' \f(CW\*(C`IO::Handle::setvbuf\*(C'\fR set tha buffering
policy fo' a IO::Handle.  Da callin sequences fo' tha Perl functions
are tha same as they C counterparts\*(--includin tha constants \f(CW\*(C`_IOFBF\*(C'\fR,
\&\f(CW\*(C`_IOLBF\*(C'\fR, n' \f(CW\*(C`_IONBF\*(C'\fR fo' \fIsetvbuf()\fR\-\-except dat tha buffer parameter
specifies a scalar variable ta use as a funky-ass buffer n' shit. Yo ass should only
change tha buffer before any I/O, or immediately afta callin flush.
.PP
\&\s-1WARNING:\s0 Da \fIIO::Handle::setvbuf()\fR aint available by default on
Perls 5.8.0 n' lata cuz \fIsetvbuf()\fR is rather specific ta using
the stdio library, while Perl prefers tha freshly smoked up perlio subsystem instead.
.PP
\&\s-1WARNING: A\s0 variable used as a funky-ass buffer by \f(CW\*(C`setbuf\*(C'\fR or \f(CW\*(C`setvbuf\*(C'\fR \fBmust not
be modified\fR up in any way until tha IO::Handle is closed or \f(CW\*(C`setbuf\*(C'\fR or
\&\f(CW\*(C`setvbuf\*(C'\fR is called again, or memory corruption may result son! Remember that
the order of global destruction is undefined, so even if yo' buffer
variable remains up in scope until program termination, it may be undefined
before tha file IO::Handle is closed. Y'all KNOW dat shit, muthafucka! Note dat you need ta import the
constants \f(CW\*(C`_IOFBF\*(C'\fR, \f(CW\*(C`_IOLBF\*(C'\fR, n' \f(CW\*(C`_IONBF\*(C'\fR explicitly. Like C, setbuf
returns nothing. setvbuf returns \*(L"0 but true\*(R", on success, \f(CW\*(C`undef\*(C'\fR on
failure.
.PP
Lastly, there be a special method fo' hustlin under \fB\-T\fR n' setuid/gid
scripts:
.ie n .IP "$io\->untaint" 4
.el .IP "\f(CW$io\fR\->untaint" 4
.IX Item "$io->untaint"
Marks tha object as taint-clean, n' as such data read from it will also
be considered taint-clean. I aint talkin' bout chicken n' gravy biatch. Note dat dis be a straight-up trustin action to
take, n' appropriate consideration fo' tha data source n' potential
vulnerabilitizzle should be kept up in mind. Y'all KNOW dat shit, muthafucka! Returns 0 on success, \-1 if setting
the taint-clean flag failed. Y'all KNOW dat shit, muthafucka! (eg invalid handle)
.SH "NOTE"
.IX Header "NOTE"
An \f(CW\*(C`IO::Handle\*(C'\fR object be a reference ta a symbol/GLOB reference (see
the \f(CW\*(C`Symbol\*(C'\fR package).  Some modulez that
inherit from \f(CW\*(C`IO::Handle\*(C'\fR may wanna keep object related variables
in tha hash table part of tha \s-1GLOB.\s0 In a attempt ta prevent modules
tramplin on each other I propose tha dat any such module should prefix
its variablez wit its own name separated by _'s. For example tha IO::Socket
module keeps a \f(CW\*(C`timeout\*(C'\fR variable up in 'io_socket_timeout'.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlfunc, 
\&\*(L"I/O Operators\*(R" up in perlop,
IO::File
.SH "BUGS"
.IX Header "BUGS"
Cuz of backwardz compatibility, all filehandlez resemble objects
of class \f(CW\*(C`IO::Handle\*(C'\fR, or straight-up classes derived from dat class.
They straight-up aren't.  Which means you can't derive yo' own 
class from \f(CW\*(C`IO::Handle\*(C'\fR n' inherit dem methods.
.SH "HISTORY"
.IX Header "HISTORY"
Derived from FileHandle.pm by Graham Barr <\fIgbarr@pobox.com\fR>
