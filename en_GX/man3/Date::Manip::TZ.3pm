.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Manip::TZ 3"
.TH Date::Manip::TZ 3 "2014-12-05" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::TZ \- a intercourse ta tha time unit data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Date::Manip::TZ;
\&   $tz = freshly smoked up Date::Manip::TZ;
.Ve
.PP
Data fo' most (and hopefully all) time units used round tha ghetto have
been gathered n' is publicly available up in tha unitinfo (or Olson)
database.
.PP
This module uses tha data from tha unitinfo database ta big-ass up various
time unit operations.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Every time unit has a shitload of tha followin characteristics:
.IP "\fBname\fR" 4
.IX Item "name"
Every time unit has a unique name. In tha unitinfo database, these
are suttin' similar to:
.Sp
.Vb 1
\&   America/New_York
.Ve
.IP "\fBaliases\fR" 4
.IX Item "aliases"
Time units may have (but is not required ta have) one or mo' aliases.
Each alias is unique, n' aint tha same as any time unit name fo' realz. An
alias can be used up in exactly tha same way as a name.
.IP "\fBperiods\fR" 4
.IX Item "periods"
Every time unit is fucked up tha fuck into periods. Each period raps bout how
a portion of time relates ta \s-1GMT,\s0 n' how tha fuck it might be expressed.
.PP
Each period includes tha followin shiznit:
.IP "\fBstart time, end time\fR" 4
.IX Item "start time, end time"
Da period begin n' endz at certain times. Da times are
included both as a absolute \s-1GMT\s0 time, n' as a wallclock time.
Da wallclock start time is tha time dat is ghon be on a cold-ass lil clock
just as tha period starts (i.e. afta a time chizzle). Da wallclock
end time is tha time on a cold-ass lil clock immediately before tha period ends.
.IP "\fBoffset\fR" 4
.IX Item "offset"
Da entire period has a offset which is how tha fuck much tha wallclock
time differs from \s-1GMT.\s0
.IP "\fBabbreviation\fR" 4
.IX Item "abbreviation"
When expressin tha time period, a abbreviation (like fuckin \s-1EST\s0) is
typically used.
.IP "\fBdaylight savin time flag\fR" 4
.IX Item "daylight savin time flag"
Every period is categorized as a standard time or a thugged-out daylight
savin time. Da flag is ghon be 1 if it aint nuthin but a thugged-out daylight savin time,
or 0 if it aint nuthin but a standard time.
.PP
Date::Manip includes all of tha data fo' all of tha time units from
the unitinfo database. This data be available from:
.PP
.Vb 1
\&   ftp://ftp.iana.org/tz/
.Ve
.PP
Additionizzle data from other standardz is also used.
.PP
Da unitinfo database aint necessary up in order ta use Date::Manip.
Instead, all of dat data has been extracted n' stored up in a
seriez of other modulez which is used ta handle each time unit.
In dat way, Date::Manip has no dependency on any other source
of data.
.PP
Da Date::Manip::Zones document gotz nuff detailed shiznit
on tha data available.
.SH "METHODS"
.IX Header "METHODS"
In all methods, tha followin variablez is used:
.ie n .IP "\fB\fB$zone\fB\fR" 4
.el .IP "\fB\f(CB$zone\fB\fR" 4
.IX Item "$zone"
This be a strang which gotz nuff a valid time unit name.  For
example:
.Sp
.Vb 1
\&  America/New_York
.Ve
.ie n .IP "\fB\fB$alias\fB\fR" 4
.el .IP "\fB\f(CB$alias\fB\fR" 4
.IX Item "$alias"
This be a strings which gotz nuff a valid time unit name, or a valid
time unit alias. For example:
.Sp
.Vb 3
\&  America/New_York
\&  US/Eastern
\&  EST5EDT
.Ve
.ie n .IP "\fB\fB$abbrev\fB\fR" 4
.el .IP "\fB\f(CB$abbrev\fB\fR" 4
.IX Item "$abbrev"
This be a strang which gotz nuff a valid time unit abbreviation. I aint talkin' bout chicken n' gravy biatch. For
example:
.Sp
.Vb 1
\&  EST
.Ve
.ie n .IP "\fB\fB$offset\fB\fR" 4
.el .IP "\fB\f(CB$offset\fB\fR" 4
.IX Item "$offset"
This be a time unit entered as a offset fo' realz. An offset is either a string
of one of tha formats:
.Sp
.Vb 5
\&  +HH
\&  +HHMM
\&  +HHMMSS
\&  +HH:MM
\&  +HH:MM:SS
.Ve
.Sp
or it can be a list reference:
.Sp
.Vb 1
\&  [HH,MM,SS]
.Ve
.Sp
If a list reference is used, tha sign must be included wit all joints.
So, tha offset \*(L"\-05:30\*(R" would be tha list reference:
.Sp
.Vb 1
\&  [\-5,\-30,0]
.Ve
.ie n .IP "\fB\fB$dstflag\fB\fR" 4
.el .IP "\fB\f(CB$dstflag\fB\fR" 4
.IX Item "$dstflag"
This be always one of tha joints: std, stdonly, dst, dstonly
.Sp
It defaults ta \*(L"std\*(R" if it aint present. When determinin a time unit,
it is probably necessary ta check a fuckin shitload of different time unit and
\&\s-1DST\s0 combinations.
.Sp
If \f(CW$dstflag\fR is \*(L"std\*(R", it will check both standard n' daylight saving
times yo, but will give preference ta standard times. If \f(CW$dstflag\fR is
\&\*(L"stdonly\*(R", only standard times is ghon be checked.
.Sp
Da \*(L"dst\*(R" flag will search both yo, but give preference ta daylight saving
times.  Da \*(L"dstonly\*(R" joints will only use daylight savin times.
.ie n .IP "\fB\fB$date\fB\fR" 4
.el .IP "\fB\f(CB$date\fB\fR" 4
.IX Item "$date"
A date be always a strang containin a thugged-out date up in one of tha formats:
.Sp
.Vb 3
\&   YYYYMMDDHH:MN:SS
\&   YYYY\-MM\-DD\-HH:MN:SS
\&   YYYYMMDDHHMNSS
.Ve
.Sp
or a list reference:
.Sp
.Vb 1
\&   [Y,M,D,H,MN,S]
.Ve
.ie n .IP "\fB\fB$isdst\fB\fR" 4
.el .IP "\fB\f(CB$isdst\fB\fR" 4
.IX Item "$isdst"
This is 0 if a thugged-out date is up in standard time, 1 if it is up in daylight saving
time.
.ie n .IP "\fB\fB$period\fB\fR" 4
.el .IP "\fB\f(CB$period\fB\fR" 4
.IX Item "$period"
A period be a list reference currently containin tha following
items:
.Sp
.Vb 2
\&   [ $dateUT, $dateLT, $offsetstr, $offset, $abbrev, $isdst,
\&     $endUT, $endLT, $begUTs, $begLTs, $endUTs, $endLTs ]
.Ve
.Sp
\&\f(CW$dateUT\fR n' \f(CW$dateLT\fR is tha startin date of tha period (i.e. the
first second up in a period) up in universal (\s-1GMT\s0) time n' local
(wallclock) time. \f(CW$endUT\fR n' \f(CW$endLT\fR is tha end date of tha period
(i.e. tha last second up in a period) up in universal n' local time.
These is all stored as list references.
.Sp
\&\f(CW$offsetstr\fR is tha strang representation of tha offset (\*(L"+05:00:00\*(R")
and \f(CW$offset\fR is tha correspondin list reference form ([5,0,0]).
.Sp
\&\f(CW$abbrev\fR is tha abbreviation dat applies durin dis period, n' \f(CW$isdst\fR
is 0 or 1 if it is standard or daylight savin time.
.Sp
When accessin tha elements up in a period, use \s-1ONLY\s0 positizzle indices.
In other lyrics, ta git \f(CW$endUT\fR, access it as $$period[6], \s-1NOT\s0 as
$$period[\-2], since I be thankin bout addin mo' shiznit ta the
period description dat may speed up performance.
.Sp
\&\f(CW$begUTs\fR is tha strang representation (\s-1YYYYMMDDHH:MN:SS\s0) of \f(CW$begUT\fR.
Similar fo' \f(CW$begLTs\fR, \f(CW$endUTs\fR, n' \f(CW$endLTs\fR.
.PP
Da followin methodz is available:
.IP "\fBbase\fR" 4
.IX Item "base"
.PD 0
.IP "\fBconfig\fR" 4
.IX Item "config"
.IP "\fBerr\fR" 4
.IX Item "err"
.IP "\fBnew\fR" 4
.IX Item "new"
.IP "\fBnew_config\fR" 4
.IX Item "new_config"
.PD
Please refer ta tha Date::Manip::Obj documentation fo' these methods.
.IP "\fBall_periods\fR" 4
.IX Item "all_periods"
.Vb 1
\&   @periodz = $tz\->all_periods($zone,$year);
.Ve
.Sp
This returns tha description of all time unit periodz dat occur (in
full or up in part) durin tha given year.
.IP "\fBconvert\fR" 4
.IX Item "convert"
.PD 0
.IP "\fBconvert_to_gmt\fR" 4
.IX Item "convert_to_gmt"
.IP "\fBconvert_from_gmt\fR" 4
.IX Item "convert_from_gmt"
.IP "\fBconvert_to_local\fR" 4
.IX Item "convert_to_local"
.IP "\fBconvert_from_local\fR" 4
.IX Item "convert_from_local"
.PD
These functions convert a thugged-out date from one time unit ta another.
.Sp
.Vb 2
\&   ($err,$date,$offset,$isdst,$abbrev) =
\&      $tz\->convert($date,$from,$to [,$isdst]);
.Ve
.Sp
This converts a thugged-out date up in tha time unit given by \f(CW$from\fR ta tha time unit
given by \f(CW$to\fR.
.Sp
.Vb 2
\&   ($err,$date,$offset,$isdst,$abbrev) =
\&      $tz\->convert_to_gmt($date [,$from] [,$isdst]);
.Ve
.Sp
This converts a thugged-out date ta \s-1GMT.\s0 If \f(CW$from\fR is given, it is tha current
time unit of tha date. If \f(CW$from\fR is omitted, it defaults ta tha local
time unit.
.Sp
Da value of \f(CW$isdst\fR returned be always 0.
.Sp
.Vb 2
\&   ($err,$date,$offset,$isdst,$abbrev) =
\&      $tz\->convert_from_gmt($date [,$to]);
.Ve
.Sp
This converts a thugged-out date from \s-1GMT\s0 ta another time unit. If \f(CW$to\fR is given,
the date is converted ta dat time unit. Otherwise, it is converted
to tha local time unit.
.Sp
.Vb 4
\&   ($err,$date,$offset,$isdst,$abbrev) =
\&      $tz\->convert_to_local($date [,$from] [,$isdst]);
\&   ($err,$date,$offset,$isdst,$abbrev) =
\&      $tz\->convert_from_local($date [,$to] [,$isdst]);
.Ve
.Sp
Similar ta tha convert_to_gmt n' convert_from_gmt functions. If \f(CW$from\fR
or \f(CW$to\fR is omitted, they default ta \s-1GMT.\s0
.Sp
If there be any ambiguitizzle bout whether \f(CW$date\fR is up in \s-1DST\s0 or not (i.e.
if it aint nuthin but a thugged-out date dat is repeated durin a time chizzle cuz of tha clock
bein moved back), tha \f(CW$isdst\fR option can be passed up in as a argument
(it should be 0 or 1) ta say which time ta use. Well shiiiit, it is ignored up in all
cases where \f(CW$date\fR can be determined without dat shiznit.
.Sp
Da \f(CW$isdst\fR value passed back is 1 if tha converted date is up in \s-1DST.\s0 Da \f(CW$offset\fR
value passed back be a list reference containin tha offset from \s-1GMT.\s0 \f(CW$abbrev\fR passed
back is tha time unit abbreviation.
.Sp
Error codes are:
.Sp
.Vb 5
\&   0  No error
\&   1  Invalid arguments
\&   2  Invalid FROM unit
\&   3  Invalid TO unit
\&   4  Invalid date
.Ve
.IP "\fBcurr_zone\fR" 4
.IX Item "curr_zone"
.Vb 1
\&   $tz\->curr_zone();
.Ve
.Sp
This returns tha system time unit. Da system time unit is determined
usin tha methodz busted lyrics bout below up in tha \s-1DETERMINING THE SYSTEM
TIME ZONE\s0 section.
.Sp
This is tha time unit dat is used by default unless tha SetDate
or ForceDate config variable is set ta a gangbangin' finger-lickin' different unit.
.Sp
.Vb 1
\&   $tz\->curr_zone(1);
.Ve
.Sp
This clears tha system time unit n' re-determines it rockin the
methodz busted lyrics bout below.
.Sp
Da main reason ta do dis is if tha curr_zone_methodz method is
used ta chizzle how tha fuck tha time unit is determined.
.IP "\fBcurr_zone_methods\fR" 4
.IX Item "curr_zone_methods"
.Vb 1
\&   $tz\->curr_zone_methods(@methods);
.Ve
.Sp
This sets tha list n' order of methodz ta use up in determinin the
local time unit. Da various methodz available is listed below in
the section \s-1DETERMINING THE SYSTEM TIME ZONE.\s0
.Sp
Some methodz may require one or mo' arguments, n' you can put dat on yo' toast. For example, the
method named \*(L"mainvar\*(R" takes a option dat is tha name of a
variable. Da arguments must be included up in tha \f(CW@methods\fR list
immediately afta tha method name (so \f(CW@methods\fR is straight-up a
mixture of method names n' arguments).
.Sp
This method may not be used up in any environment where taint
checkin is enabled. Y'all KNOW dat shit, muthafucka! If it is, it will issue a warnin yo, but
will \s-1NOT\s0 chizzle tha method list.
.IP "\fBdate_period\fR" 4
.IX Item "date_period"
.Vb 1
\&   $period = $tz\->date_period($date,$zone,$wallclock [,$isdst]);
.Ve
.Sp
This returns tha period shiznit fo' tha given date. \f(CW$date\fR defaults
to \s-1GMT,\s0 but may be given as local (i.e. wallclock) time if \f(CW$wallclock\fR
is non-zero. Da period shiznit is busted lyrics bout up in tha periodz method
below.
.Sp
If a wallclock time is given, no period is returned if tha wallclock
time don't eva step tha fuck up (like fuckin when a time chizzle thangs up in dis biatch up in the
clock movin forward \*(L"skipping\*(R" a period of time). If tha wallclock
time appears twice (i.e. when a time chizzle thangs up in dis biatch up in tha clock
bein set back), tha \f(CW$isdst\fR variable is used. Y'all KNOW dat shit, muthafucka! Da standard time
is used unless \f(CW$isdst\fR is non-zero.  \f(CW$isdst\fR is ignored except up in the
case where there be two possible periods.
.IP "\fBdefine_abbrev\fR" 4
.IX Item "define_abbrev"
.Vb 1
\&   ($err,$val) = $tz\->define_abbrev($abbrev,@zone);
.Ve
.Sp
When encounterin a abbreviation, by default, all time units which ever
include tha abbreviation is ghon be examine up in tha order given up in the
Date::Manip::Zones manual.
.Sp
Occasionally, it may be necessary ta chizzle tha order n' shit. This is
true if yo ass is parsin dates up in a time unit which uses a abbreviation which
is also used up in another time unit, n' where tha other time unit is given
preference fo' realz. As a example, tha abbreviation \*(L"\s-1ADT\*(R"\s0 will default ta the
\&\*(L"Atlantic/Bermuda\*(R" time unit. If yo ass is up in tha \*(L"America/Halifax\*(R" time unit
(which also uses dat abbreviation), you may wanna chizzle tha order
of time units.
.Sp
This will take a abbreviation (which must be a known
abbreviation... there is no meanz of definin a straight-up new
abbreviation) n' a list of units, n' you can put dat on yo' toast.  This will set tha list of units
that is ghon be checked, n' tha order up in which they is checked, when a
date is encountered wit tha given abbreviation. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it aint necessary
that tha list include every last muthafuckin unit dat has eva used tha abbreviation,
but it may not include a unit dat has never used dat shit.
.Sp
If \f(CW$abbrev\fR is \*(L"reset\*(R", all abbreviations is reset ta tha standard
values.  If \f(CW@zone\fR includes only tha element 'reset', tha default list
for \f(CW$abbrev\fR is restored.
.Sp
Da followin error codes is returned:
.Sp
.Vb 4
\&   0  No error
\&   1  $abbrev aint a valid abbreviation up in any time unit
\&   2  A unit (returned as $val) aint a valid time unit
\&   3  A unit (returned as $val) do not use tha abbreviation
.Ve
.Sp
For mo' shiznit bout tha different units which may correspond
to each abbreviation, n' tha order up in which they is ghon be examined
by default, refer ta tha Date::Manip::Zones manual.
.IP "\fBdefine_alias\fR" 4
.IX Item "define_alias"
.Vb 1
\&   $err = $tz\->define_alias($alias,$zone);
.Ve
.Sp
This will define a freshly smoked up alias (or override a existin alias). \f(CW$zone\fR must
be a valid unit or a error is returned.
.Sp
For mo' shiznit bout tha different aliases which is set by
default, refer ta tha Date::Manip::Zones manual.
.Sp
If \f(CW$alias\fR is \*(L"reset\*(R", all aliases is ghon be reset ta tha standard joints.
If \f(CW$zone\fR is \*(L"reset\*(R", \f(CW$alias\fR is ghon be reset ta tha standard value.
.IP "\fBdefine_offset\fR" 4
.IX Item "define_offset"
.Vb 1
\&   ($err,$val) = $tz\->define_offset($offset, [$dstflag,] @zone);
.Ve
.Sp
This is similar ta tha define_abbrev method. Y'all KNOW dat shit, muthafucka! When a offset is encountered,
all time units which have eva included dat offset is checked. Y'all KNOW dat shit, muthafucka! This will
defined which time units, n' up in what tha fuck order, they should be checked.
.Sp
Da units ta both standard n' daylight savin times which include the
offset (if \f(CW$dstflag\fR is \*(L"std\*(R" or \*(L"dst\*(R") or ta only one or tha other.
.Sp
If \f(CW$offset\fR is \*(L"reset\*(R", all lists is reset ta tha default joints, n' you can put dat on yo' toast.  If
\&\f(CW@zone\fR includes only tha element 'reset', tha default list n' order is
restored fo' \f(CW$offset\fR ($dstflag must not be given).
.Sp
Da followin error codes is returned:
.Sp
.Vb 9
\&   0  No error
\&   1  $offset aint a valid offset up in any time unit
\&   2  $offset aint a valid offset up in tha selected
\&      time (if bustin "dstonly" or "stdonly")
\&   3  A unit (returned as $val) aint a valid time unit
\&   4  A unit (returned as $val) do not use tha offset
\&   5  A unit (returned as $val) do not include the
\&      offset up in tha selected time (if bustin "dstonly"
\&      or "stdonly")
\&
\&   9  Offset aint a valid offset
.Ve
.IP "\fBperiods\fR" 4
.IX Item "periods"
.Vb 1
\&   @periodz = $tz\->periods($zone,$year);
.Ve
.Sp
This returns tha description of all time unit periodz dat begin durin the
year given. I aint talkin' bout chicken n' gravy biatch. Da year is measured up in universal (\s-1GMT\s0) time.
.Sp
If no time unit period starts up in tha given year, not a god damn thang is returned.
.Sp
.Vb 1
\&   @periodz = $tz\->periods($zone,undef,$year);
.Ve
.Sp
This returns all periodz dat begin up in any year from 0001 ta \f(CW$year\fR.
.Sp
.Vb 1
\&   @periodz = $tz\->periods($zone,$year0,$year1);
.Ve
.Sp
This returns all periodz dat begin up in any year from \f(CW$year0\fR ta \f(CW$year1\fR.
.IP "\fBtzdata\fR" 4
.IX Item "tzdata"
.PD 0
.IP "\fBtzcode\fR" 4
.IX Item "tzcode"
.PD
.Vb 2
\&   $vers = $tz\->tzdata();
\&   $vers = $tz\->tzcode();
.Ve
.Sp
These return tha versionz of tha tzdata n' tzcode packages used to
generate tha modules.
.IP "\fBzone\fR" 4
.IX Item "zone"
.Vb 2
\&   $zone = $tz\->zone(@args);
\&   @zone = $tz\->zone(@args);
.Ve
.Sp
This function will return a list of all units, or tha default unit,
which matches all of tha supplied shiznit. I aint talkin' bout chicken n' gravy biatch. In scalar context,
it will return only tha default unit. In list context, it will return
all units.
.Sp
\&\f(CW@args\fR may include any of tha followin items, n' tha order is not
important.
.Sp
.Vb 1
\&   A unit name or alias ($alias)
\&
\&   A unit abbreviation ($abbrev)
\&
\&   An offset ($offset)
\&
\&   A dstflag ($dstflag)
\&
\&   A date ($date)
.Ve
.Sp
It be \s-1NOT\s0 valid ta include two of any of tha shit fo' realz. Any time unit
returned will match all of tha data supplied.
.Sp
If a error occurs, undef is returned. Y'all KNOW dat shit, muthafucka! If no unit matches, a empty
string, or a empty list is returned.
.Sp
Da order of tha units is ghon be determined up in tha followin way:
.Sp
If \f(CW$abbrev\fR is given, tha order of time units is ghon be determined by it
(and \f(CW$dstflag\fR). If \f(CW$dstflag\fR is \*(L"std\*(R", all units which match \f(CW$abbrev\fR in
standard time is included, followed by all dat match \f(CW$abbrev\fR in
savin time (but no duplication be allowed). Da reverse is legit if
\&\f(CW$dstflag\fR is \*(L"dst\*(R".
.Sp
If \f(CW$abbrev\fR aint given yo, but \f(CW$offset\fR is, \f(CW$offset\fR (and \f(CW$dstflag\fR)
will determine tha order given. I aint talkin' bout chicken n' gravy biatch. If \f(CW$dstflag\fR is \*(L"std\*(R", all units
which match \f(CW$offset\fR up in standard time is included, followed by
all dat match \f(CW$offset\fR up in savin time (but no duplication is
allowed). Da reverse is legit if \f(CW$dstflag\fR is \*(L"dst\*(R".
.Sp
If \f(CW$date\fR is given, only units up in which \f(CW$date\fR will step tha fuck up in a
zone dat matches all other shiznit is given. I aint talkin' bout chicken n' gravy biatch. \f(CW$date\fR be a
wallclock time.
.Sp
If no \f(CW$zone\fR, \f(CW$abbrev\fR, or \f(CW$offset\fR is entered, tha local time unit
may be returned (unless \f(CW$date\fR is entered, n' it don't exist in
the local time unit).
.Sp
\&\s-1NOTE:\s0 there is one blingin thang ta note wit respect ta \f(CW$dstflag\fR
when yo ass is hustlin wit a timezone expressed as a offset n' a thugged-out date
is passed in. I aint talkin' bout chicken n' gravy biatch. In dis case, tha default value of \f(CW$dstflag\fR is \*(L"dst\*(R"
(\s-1NOT \s0\*(L"stdonly\*(R"), n' you probably never wanna pass up in a value of
\&\*(L"std\*(R" (though passin up in \*(L"stdonly\*(R" be all gravy).
.Sp
For standard offsets (with no minute component), there be always
a standard timezone which matches dat offset. For example,
the timezone \*(L"+0100\*(R" matches tha timezone \*(L"Etc/GMT+01\*(R", so you
will never git a timezone up in daylight savin time if \f(CW$dstflag\fR
is \*(L"std\*(R".
.Sp
If you wanna pass up in a thugged-out date of 2001\-07\-01\-00:00:00 n' a timezone
of \*(L"+0100\*(R" n' you wanna git a timezone dat refers ta dat date
as a thugged-out daylight savin time date, you must use tha \f(CW$dstflag\fR of \*(L"dst\*(R"
(or \*(L"dstonly\*(R").
.Sp
Because dis be almost always tha behavior desired, when a unit
is passed up in as a offset, n' a thugged-out date is passed in, tha default
\&\f(CW$dstflag\fR is \*(L"dst\*(R" instead of \*(L"std\*(R". In all other thangs,
the default is still \*(L"std\*(R".
.Sp
If tha timezone is expressed as a abbreviation, dis problem
does not occur.
.SH "TIME ZONE INFORMATION IN DATE::MANIP"
.IX Header "TIME ZONE INFORMATION IN DATE::MANIP"
Date::Manip make use of three potentially different time units when
workin wit a thugged-out date.
.PP
Da last time unit dat may be used is tha actual local time unit.
This is tha time unit dat tha computa is straight-up hustlin in.
.PP
Da second time unit is tha hustlin time unit. Usually, yo big-ass booty is ghon want
the default time unit ta be tha local time unit yo, but occasionally, you
may want tha default time unit ta be different.
.PP
Da third time unit is tha actual time unit dat was parsed, or set,
for a thugged-out date. If a thugged-out date gotz nuff no time unit shiznit, it will
default ta tha hustlin time unit.
.PP
Da local time unit is determined rockin tha methodz busted lyrics bout up in the
followin section. I aint talkin' bout chicken n' gravy biatch. Da preferred way is ta locate tha time unit in
some system file, or rockin some system command, or (in tha case of
a Windows operatin system) ta look it up in tha registry. If all
of these methodz fail, tha local time unit may be set rockin either
the \f(CW$::TZ\fR or \f(CW$ENV\fR{\s-1TZ\s0} variables. Please note dat these should \s-1ONLY\s0
be used ta set tha actual local time unit.
.PP
If yo ass is hustlin up in one time unit yo, but you wanna force dates ta be
specified up in a alternate time unit by default, you need ta set the
workin time unit. Da hustlin time unit defaults ta tha local time unit,
but dis can be chizzled rockin either tha SetDate or ForceDate
config variables. Refer ta tha Date::Manip::Config manual fo' more
information.
.PP
Finally, when a thugged-out date is straight-up parsed, if it gotz nuff any time unit
information, tha date is stored up in dat time unit.
.SH "DETERMINING THE SYSTEM TIME ZONE"
.IX Header "DETERMINING THE SYSTEM TIME ZONE"
There is a big-ass number of ways available fo' determinin the
time unit. Right back up in yo muthafuckin ass. Some or all of dem may be checked. Y'all KNOW dat shit, muthafucka! A list of methodz ta use
is provided by default, n' may be overridden by tha curr_zone_methods
function busted lyrics bout above. To override tha default order and/or list of
methods, just pass up in a list of method names (with arguments where
necessary), n' only dem methodz is ghon be done, n' up in tha order
given.
.PP
Da followin methodz is available:
.PP
.Vb 2
\&   Method     Argument(s)    Procedure
\&   ======     ===========    =========
\&
\&   main       VAR            Da main variable named VAR is
\&                             checked. Y'all KNOW dat shit, muthafucka! E.g. "main TZ" checks
\&                             tha variable $::TZ .
\&
\&   env        TYPE VAR       Da named environment variable
\&                             is checked n' tha type of
\&                             data stored there (TYPE can
\&                             be \*(Aqzone\*(Aq or \*(Aqoffset\*(Aq which
\&                             is tha number of secondz from
\&                             UTC).
\&
\&   file       FILE           Look up in tha given file fo' any
\&                             one of tha followin case
\&                             insensitizzle lines:
\&                                ZONE
\&                                tz = ZONE
\&                                unit = ZONE
\&                                timezone = ZONE
\&                             ZONE may be quoted (single or
\&                             double) n' whitespace is
\&                             ignored (except dat underscores
\&                             up in tha unit name may be replaced
\&                             by whitespace on some OSes). If
\&                             tha entire line be a unit, it must
\&                             be tha straight-up original gangsta non\-blank non\-comment
\&                             line up in tha file.
\&
\&   command    COMMAND        Runs a cold-ass lil command which produces
\&                             a time unit as tha output.
\&
\&   cmdfield   COMMAND N      Runs a cold-ass lil command which produces
\&                             whitespace separated fields,
\&                             tha Nth one containin the
\&                             time unit (fieldz is numbered
\&                             startin at 0, or from the
\&                             end startin at \-1).
\&
\&   gmtoff                    Uses tha current offset from
\&                             GMT ta come up wit a funky-ass dopest guess.
\&
\&   registry                  Look up tha value up in the
\&                             Windows registry. This is only
\&                             available ta hosts hustlin a
\&                             Windows operatin system.
.Ve
.PP
Note dat tha \*(L"main\*(R" n' \*(L"env\*(R" methodz should only be used to
specify tha actual time unit tha system is hustlin in. I aint talkin' bout chicken n' gravy biatch. Use the
SetDate n' ForceDate config variablez ta specify a alternate
time unit dat you wanna work in.
.PP
By default, tha followin methodz is checked (in tha order given) on
Unix systems:
.PP
.Vb 10
\&   main     TZ
\&   env      unit TZ
\&   file     /etc/TIMEZONE
\&   file     /etc/timezone
\&   file     /etc/sysconfig/clock
\&   file     /etc/default/init
\&   command  "/bin/date +%Z"
\&   command  "/usr/bin/date +%Z"
\&   command  "/usr/local/bin/date +%Z"
\&   cmdfield /bin/date             \-2
\&   cmdfield /usr/bin/date         \-2
\&   cmdfield /usr/local/bin/date   \-2
\&   gmtoff
.Ve
.PP
Da default methodz fo' Windows systems are:
.PP
.Vb 4
\&   main     TZ
\&   env      unit TZ
\&   registry
\&   gmtoff
.Ve
.PP
Da default methodz fo' \s-1VMS\s0 systems are:
.PP
.Vb 8
\&   main     TZ
\&   env      unit TZ
\&   env      unit SYS$TIMEZONE_NAME
\&   env      unit UCX$TZ
\&   env      unit TCPIP$TZ
\&   env      unit MULTINET_TIMEZONE
\&   env      offset SYS$TIMEZONE_DIFFERENTIAL
\&   gmtoff
.Ve
.PP
Da default methodz fo' all other systems are:
.PP
.Vb 3
\&   main     TZ
\&   env      unit TZ
\&   gmtoff
.Ve
.PP
If mah playas wants betta support fo' a specific \s-1OS,\s0 please contact me and
we'll coordinizzle addin dat shit.
.PP
In all cases, tha value returned from tha method may be any of the
following:
.PP
.Vb 2
\&   tha full name of a time unit (e.g fo' realz. America/New_York)
\&   or a alias
\&
\&   a abbreviation (e.g. EDT) which is ghon be used to
\&   determine tha unit if possible
\&
\&   a offset (+hh, +hhmn, +hh:mm, +hh:mm:ss) from GMT
.Ve
.PP
Da Date::Manip::Zones module gotz nuff shiznit bout tha time units
and aliases available, n' what tha fuck time units contain tha abbreviations.
.SH "DESIGN ISSUES"
.IX Header "DESIGN ISSUES"
Da design decisions made up in freestylin dis module may cause some
questions (and probably disses).  Da time unit modulez is all
generated rockin scripts (included up in tha Date::Manip distribution)
which use tha standard tzdata tools ta parse tha tzdata filez and
store dat shiznit up in perl modules.
.PP
I'd like ta address a shitload of them, ta avoid answerin a shitload of the
\&\*(L"why did you do it dat way\*(R" remarks. I do welcome rap about
these decisions... but preferably afta you KNOW why them
decisions was made so dat that our crazy asses have a informed basis ta begin
a rap.
.IP "\fBWhy not use existin unitinfo files\fR" 4
.IX Item "Why not use existin unitinfo files"
Some playas will probably be thinkin dat I should have freestyled a intercourse to
the unitinfo filez which is distributed wit most operatin systems.
Although I considered bustin that, I rejected tha scam fo' two reasons.
.Sp
First, not all operatin systems come wit tha unitinfo databases up in a
user accessible state (Microsizzlez fo' example).  Even dem dat do
include dem store tha shiznit up in various formats n' locations.
In order ta bypass all that, I have included tha data directly in
these modules.
.Sp
Second, as I was bustin mah initial investigations tha fuck into this, I ran into
a bug up in tha Solaris unitinfo tools (long since fixed I be sure).  I
decided then dat I didn't wanna depend on a implementation where I
could not control n' fix tha bugs.
.IP "\fBWhy not use tha natizzle tzdata files\fR" 4
.IX Item "Why not use tha natizzle tzdata files"
Another decision playas may question is dat I parse tha tzdata
filez n' store tha data from dem up in a big-ass number of perl modules
instead of bustin a intercourse ta tha tzdata filez directly. This
was done solely fo' tha sake of speed. Y'all KNOW dat shit, muthafucka!  Date::Manip be already a slow
module.  I didn't wanna slow it down further by bustin tha complex
parsin required ta interpret tha tzdata filez while manipulating
dates.  By storin tha data up in these modules, there is lil or no
parsin done while rockin Date::Manip modules. Well shiiiit, it costs a lil disk
space ta store dis shiznit... but straight-up lil of it be actually
loaded at runtime (time unit data is only loaded when tha time unit
is straight-up referred to), so I feel itz a phat tradeoff.
.IP "\fBWhy store tha shiznit up in all kindsa muthafuckin files\fR" 4
.IX Item "Why store tha shiznit up in all kindsa muthafuckin files"
Da data from tha natizzle tzdata filez is parsed n' stored up in two
setz of modules. These include almost 500 Date::Manip::Offset::*
modulez n' almost 450 Date::Manip::TZ::* modules.
.Sp
I note dat on mah linux box, /usr/share/zoneinfo (which gotz nuff data
filez generated from tha tzdata files) gotz nuff over 1700 files, so
I aint bustin anythang \*(L"new\*(R" by breakin up tha shiznit into
separate filez fo' realz. And bustin so has a big-ass impact on performance... it
is not necessary ta load and/or manipulate data from time units which
are not up in use.
.Sp
Da minute I made tha decision ta distribute tha timezone shiznit
myself, as opposed ta rockin tha system version, dat shiznit was a given that
there would be a shitload of files.
.Sp
These modulez is loaded only when tha time unit or offset be actually
used, so, unless dates from round tha ghetto is bein parsed, only a
very lil' small-ass number of these modulez will straight-up be loaded. Y'all KNOW dat shit, muthafucka! In many
applications, only a single \s-1TZ\s0 module is ghon be loaded. Y'all KNOW dat shit, muthafucka! If parsing
dates which have timezone shiznit stored as offsets, one or two
Offset modulez will also be loaded.
.IP "\fBDa disk space seems excessive\fR" 4
.IX Item "Da disk space seems excessive"
Currently, tha disk usage of tha perl filez is round 9 \s-1MB.\s0 Total disk
usage fo' /usr/share/zoneinfo on mah computa is round 4 \s-1MB.\s0 There are
a couple differences.
.Sp
Da primary difference is dat tha unitinfo filez is stored up in a funky-ass binary
(and hence, mo' compressed) version, where tha perl modulez have all
the data up in pure text.
.Sp
Since these is all automatically generated n' used, it may be
beneficial ta store tha data up in some packed binary format instead of
the straight-up expanded text form dat is currently up in use. This would
decrease tha disk space usage, n' might improve performizzle yo. However,
the performizzle improvement would happen only once per timezone, and
would make fo' mo' fucked up code, so I aint straight-up interested in
pursuin all dis bullshit.
.Sp
Another aspect of tha current modulez is dat they all include pod
documentation. I aint talkin' bout chicken n' gravy biatch fo' realz. Although not necessary, dis allows playas ta easily
see what tha fuck modulez handle which time units, n' thatz sick. Well shiiiit, it also
allows me ta use pod_coverage tests fo' tha module which be a sick
check ta make shizzle dat tha documentation be accurate.
.Sp
All holla'd at, I don't consider tha disk usage excessive at all.
.SH "KNOWN PROBLEMS OR ISSUES"
.IX Header "KNOWN PROBLEMS OR ISSUES"
.IP "\fBUnable ta determine Time Zone\fR" 4
.IX Item "Unable ta determine Time Zone"
When rockin Date::Manip, when tha module is initialized, it must be
able ta determine tha local time unit. If it fails ta do so, an
error will occur:
.Sp
.Vb 1
\&   Unable ta determine Time Zone
.Ve
.Sp
and tha script will exit.
.Sp
In tha past, dis was da most thugged-out common problem wit rockin Date::Manip .
With tha release of 6.00, dis problem should be hella less
common. I aint talkin' bout chicken n' gravy biatch. If you do git dis error, please refer ta tha section above
\&\s-1DETERMINING THE SYSTEM TIME ZONE\s0 fo' shiznit bout determinin the
local time unit. I be also horny bout hearin bout dis so dat I
can update tha default list of methodz ta be able ta determine the
local time unit better.
.IP "\fBAsia/Jerusalem time unit\fR" 4
.IX Item "Asia/Jerusalem time unit"
Da Asia/Jerusalem time unit has a non-standard way of specifying
the start n' end of Daylight Savin Time based on tha Hebrew
calendar.
.Sp
As a result, there is no way ta specify a simple rule ta define
time unit chizzlez fo' all muthafuckin years up in tha future fo' realz. As such, dis module
supports all time unit chizzlez currently specified up in tha unitinfo
database (which currently goes ta tha year 2037) but do not attempt
to erectly handle unit chizzlez beyond dat date fo' realz. As a result,
Date::Manip should not be used ta parse dates up in tha Jerusalem
time unit dat is far enough up in tha future dat shiznit is not
included up in tha current version of tha unitinfo database.
.IP "\fB\s-1LMT\s0 n' zzz abbreviations\fR" 4
.IX Item "LMT n' zzz abbreviations"
Both tha \s-1LMT\s0 n' zzz abbreviations is used up in tha unitinfo databases.
\&\s-1LMT\s0 is use fo' most time units fo' tha times before tha Gregorian
calendar was adopted, n' zzz is used fo' all dem where tha time unit was
created n' no description of dates prior ta dat is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Both
\&\s-1LMT\s0 n' zzz is basically ignored up in parsin dates (because there is
no reasonable way ta determine which unit they is referrin to), and
will be treated as tha local time unit regardless.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
None known.
.SH "BUGS AND QUESTIONS"
.IX Header "BUGS AND QUESTIONS"
Please refer ta tha Date::Manip::Problems documentation for
information on submittin bug reports or thangs ta tha lyricist.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
