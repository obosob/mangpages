.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Thread::Queue 3"
.TH Thread::Queue 3 "2013-02-19" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Thread::Queue \- Thread\-safe queues
.SH "VERSION"
.IX Header "VERSION"
This document raps bout Thread::Queue version 3.02
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use strict;
\&    use warnings;
\&
\&    use threads;
\&    use Thread::Queue;
\&
\&    mah $q = Thread::Queue\->new();    # A freshly smoked up empty queue
\&
\&    # Worker thread
\&    mah $thr = threads\->create(
\&        sub {
\&            # Thread will loop until no mo' work
\&            while (defined(my $item = $q\->dequeue())) {
\&                # Do work on $item
\&                ...
\&            }
\&        }
\&    );
\&
\&    # Send work ta tha thread
\&    $q\->enqueue($item1, ...);
\&    # Signal dat there is no mo' work ta be sent
\&    $q\->end();
\&    # Join up wit tha thread when it finishes
\&    $thr\->join();
\&
\&    ...
\&
\&    # Count of shit up in tha queue
\&    mah $left = $q\->pending();
\&
\&    # Non\-blockin dequeue
\&    if (defined(my $item = $q\->dequeue_nb())) {
\&        # Work on $item
\&    }
\&
\&    # Blockin dequeue wit 5\-second timeout
\&    if (defined(my $item = $q\->dequeue_timed(5))) {
\&        # Work on $item
\&    }
\&
\&    # Git tha second item up in tha queue without dequeuin anything
\&    mah $item = $q\->peek(1);
\&
\&    # Insert two shit tha fuck into tha queue just behind tha head
\&    $q\->insert(1, $item1, $item2);
\&
\&    # Extract tha last two shit on tha queue
\&    mah ($item1, $item2) = $q\->extract(\-2, 2);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up thread-safe \s-1FIFO\s0 queues dat can be accessed safely by
any number of threads.
.PP
Any data types supported by threads::shared can be passed via queues:
.IP "Ordinary scalars" 4
.IX Item "Ordinary scalars"
.PD 0
.IP "Array refs" 4
.IX Item "Array refs"
.IP "Hash refs" 4
.IX Item "Hash refs"
.IP "Scalar refs" 4
.IX Item "Scalar refs"
.IP "Objects based on tha above" 4
.IX Item "Objects based on tha above"
.PD
.PP
Ordinary scalars is added ta queues as they are.
.PP
If not already thread-shared, tha other complex data types is ghon be cloned
(recursively, if needed, n' includin any \f(CW\*(C`bless\*(C'\fRings n' read-only
settings) tha fuck into thread-shared structures before bein placed onto a queue.
.PP
For example, tha followin would cause Thread::Queue ta create a empty,
shared array reference via \f(CW\*(C`&shared([])\*(C'\fR, copy tha elements 'foo', 'bar'
and 'baz' from \f(CW@ary\fR tha fuck into it, n' then place dat shared reference onto
the queue:
.PP
.Vb 2
\&    mah @ary = qw/foo bar baz/;
\&    $q\->enqueue(\e@ary);
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat fo' tha following, tha shit is already shared, so they references
are added directly ta tha queue, n' no clonin takes place:
.PP
.Vb 2
\&    mah @ary :shared = qw/foo bar baz/;
\&    $q\->enqueue(\e@ary);
\&
\&    mah $obj = &shared({});
\&    $$obj{\*(Aqfoo\*(Aq} = \*(Aqbar\*(Aq;
\&    $$obj{\*(Aqqux\*(Aq} = 99;
\&    bless($obj, \*(AqMy::Class\*(Aq);
\&    $q\->enqueue($obj);
.Ve
.PP
See \*(L"\s-1LIMITATIONS\*(R"\s0 fo' caveats related ta passin objects via queues.
.SH "QUEUE CREATION"
.IX Header "QUEUE CREATION"
.IP "\->\fInew()\fR" 4
.IX Item "->new()"
Creates a freshly smoked up empty queue.
.IP "\->new(\s-1LIST\s0)" 4
.IX Item "->new(LIST)"
Creates a freshly smoked up queue pre-populated wit tha provided list of items.
.SH "BASIC METHODS"
.IX Header "BASIC METHODS"
Da followin methodz deal wit queues on a \s-1FIFO\s0 basis.
.IP "\->enqueue(\s-1LIST\s0)" 4
.IX Item "->enqueue(LIST)"
Addz a list of shit onto tha end of tha queue.
.IP "\->\fIdequeue()\fR" 4
.IX Item "->dequeue()"
.PD 0
.IP "\->dequeue(\s-1COUNT\s0)" 4
.IX Item "->dequeue(COUNT)"
.PD
Removes tha axed number of shit (default is 1) from tha head of the
queue, n' returns em.  If tha queue gotz nuff fewer than tha requested
number of items, then tha thread is ghon be blocked until tha requisite number
of shit is available (i.e., until other threadz <enqueue> mo' items).
.IP "\->\fIdequeue_nb()\fR" 4
.IX Item "->dequeue_nb()"
.PD 0
.IP "\->dequeue_nb(\s-1COUNT\s0)" 4
.IX Item "->dequeue_nb(COUNT)"
.PD
Removes tha axed number of shit (default is 1) from tha head of the
queue, n' returns em.  If tha queue gotz nuff fewer than tha requested
number of items, then it immediately (i.e., non-blocking) returns whatever
items there be on tha queue.  If tha queue is empty, then \f(CW\*(C`undef\*(C'\fR is
returned.
.IP "\->dequeue_timed(\s-1TIMEOUT\s0)" 4
.IX Item "->dequeue_timed(TIMEOUT)"
.PD 0
.IP "\->dequeue_timed(\s-1TIMEOUT, COUNT\s0)" 4
.IX Item "->dequeue_timed(TIMEOUT, COUNT)"
.PD
Removes tha axed number of shit (default is 1) from tha head of the
queue, n' returns em.  If tha queue gotz nuff fewer than tha requested
number of items, then tha thread is ghon be blocked until tha requisite number of
items is available, or until tha timeout is reached. Y'all KNOW dat shit, muthafucka!  If tha timeout is
reached, it returns whatever shit there be on tha queue, or \f(CW\*(C`undef\*(C'\fR if the
queue is empty.
.Sp
Da timeout may be a fuckin shitload of secondz relatizzle ta tha current time (e.g., 5
secondz from when tha call is made), or may be a absolute timeout up in \fIepoch\fR
secondz tha same ol' dirty as would be used with
\&\fIcond_timedwait()\fR.
Fractionizzle secondz (e.g., 2.5 seconds) is also supported (to tha extent of
the underlyin implementation).
.Sp
If \f(CW\*(C`TIMEOUT\*(C'\fR is missing, c<undef>, or less than or equal ta 0, then dis call
behaves tha same ol' dirty as \f(CW\*(C`dequeue_nb\*(C'\fR.
.IP "\->\fIpending()\fR" 4
.IX Item "->pending()"
Returns tha number of shit still up in tha queue.  Returns \f(CW\*(C`undef\*(C'\fR if tha queue
has been ended (see below), n' there be no mo' shit up in tha queue.
.IP "\->\fIend()\fR" 4
.IX Item "->end()"
Declares dat no mo' shit is ghon be added ta tha queue.
.Sp
All threadz blockin on \f(CW\*(C`dequeue()\*(C'\fR calls is ghon be unblocked wit any
remainin shit up in tha queue and/or \f(CW\*(C`undef\*(C'\fR bein returned. Y'all KNOW dat shit, muthafucka!  Any subsequent
calls ta \f(CW\*(C`dequeue()\*(C'\fR will behave like \f(CW\*(C`dequeue_nb()\*(C'\fR.
.Sp
Once ended, no mo' shit may be placed up in tha queue.
.SH "ADVANCED METHODS"
.IX Header "ADVANCED METHODS"
Da followin methodz can be used ta manipulate shit anywhere up in a queue.
.PP
To prevent tha contentz of a queue from bein modified by another thread
while it is bein examined and/or chizzled, lock tha queue inside a local block:
.PP
.Vb 8
\&    {
\&        lock($q);   # Keep other threadz from changin tha queue\*(Aqs contents
\&        mah $item = $q\->peek();
\&        if ($item ...) {
\&            ...
\&        }
\&    }
\&    # Queue is now unlocked
.Ve
.IP "\->\fIpeek()\fR" 4
.IX Item "->peek()"
.PD 0
.IP "\->peek(\s-1INDEX\s0)" 4
.IX Item "->peek(INDEX)"
.PD
Returns a item from tha queue without dequeuin anything.  Defaults ta the
the head of queue (at index posizzle 0) if no index is specified. Y'all KNOW dat shit, muthafucka!  Negative
index joints is supported as wit arrays (i.e., \-1
is tha end of tha queue, \-2 is next ta last, n' so on).
.Sp
If no shit exists all up in tha specified index (i.e., tha queue is empty, or the
index is beyond tha number of shit on tha queue), then \f(CW\*(C`undef\*(C'\fR is returned.
.Sp
Remember, tha returned item aint removed from tha queue, so manipulatin a
\&\f(CW\*(C`peek\*(C'\fRed at reference affects tha item on tha queue.
.IP "\->insert(\s-1INDEX, LIST\s0)" 4
.IX Item "->insert(INDEX, LIST)"
Addz tha list of shit ta tha queue all up in tha specified index posizzle (0
is tha head of tha list).  Any existin shit at n' beyond dat posizzle are
pushed back past tha newly added items:
.Sp
.Vb 3
\&    $q\->enqueue(1, 2, 3, 4);
\&    $q\->insert(1, qw/foo bar/);
\&    # Queue now gotz nuff:  1, foo, bar, 2, 3, 4
.Ve
.Sp
Specifyin a index posizzle pimped outa than tha number of shit up in tha queue
just addz tha list ta tha end.
.Sp
Negatizzle index positions is supported:
.Sp
.Vb 3
\&    $q\->enqueue(1, 2, 3, 4);
\&    $q\->insert(\-2, qw/foo bar/);
\&    # Queue now gotz nuff:  1, 2, foo, bar, 3, 4
.Ve
.Sp
Specifyin a wack index posizzle pimped outa than tha number of shit up in the
queue addz tha list ta tha head of tha queue.
.IP "\->\fIextract()\fR" 4
.IX Item "->extract()"
.PD 0
.IP "\->extract(\s-1INDEX\s0)" 4
.IX Item "->extract(INDEX)"
.IP "\->extract(\s-1INDEX, COUNT\s0)" 4
.IX Item "->extract(INDEX, COUNT)"
.PD
Removes n' returns tha specified number of shit (defaults ta 1) from the
specified index posizzle up in tha queue (0 is tha head of tha queue).  When
called wit no arguments, \f(CW\*(C`extract\*(C'\fR operates tha same ol' dirty as \f(CW\*(C`dequeue_nb\*(C'\fR.
.Sp
This method is non-blocking, n' will return only as nuff shit as are
available ta fulfill tha request:
.Sp
.Vb 5
\&    $q\->enqueue(1, 2, 3, 4);
\&    mah $item  = $q\->extract(2)     # Returns 3
\&                                   # Queue now gotz nuff:  1, 2, 4
\&    mah @items = $q\->extract(1, 3)  # Returns (2, 4)
\&                                   # Queue now gotz nuff:  1
.Ve
.Sp
Specifyin a index posizzle pimped outa than tha number of shit up in the
queue thangs up in dis biatch up in \f(CW\*(C`undef\*(C'\fR or a empty list bein returned.
.Sp
.Vb 3
\&    $q\->enqueue(\*(Aqfoo\*(Aq);
\&    mah $nada = $q\->extract(3)      # Returns undef
\&    mah @nada = $q\->extract(1, 3)   # Returns ()
.Ve
.Sp
Negatizzle index positions is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Specifyin a wack index position
greata than tha number of shit up in tha queue may return shit from tha head
of tha queue (similar ta \f(CW\*(C`dequeue_nb\*(C'\fR) if tha count overlaps tha head of the
queue from tha specified posizzle (i.e. if queue size + index + count is
greata than zero):
.Sp
.Vb 5
\&    $q\->enqueue(qw/foo bar baz/);
\&    mah @nada = $q\->extract(\-6, 2);   # Returns ()         \- (3+(\-6)+2) <= 0
\&    mah @some = $q\->extract(\-6, 4);   # Returns (foo)      \- (3+(\-6)+4) > 0
\&                                     # Queue now gotz nuff:  bar, baz
\&    mah @rest = $q\->extract(\-3, 4);   # Returns (bar, baz) \- (2+(\-3)+4) > 0
.Ve
.SH "NOTES"
.IX Header "NOTES"
Queues pimped by Thread::Queue can be used up in both threaded and
non-threaded applications.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
Passin objects on queues may not work if tha objects' classes do not support
sharing.  See \*(L"\s-1BUGS AND LIMITATIONS\*(R"\s0 up in threads::shared fo' more.
.PP
Passin array/hash refs dat contain objects may not work fo' Perl prior to
5.10.0.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Thread::Queue Rap Forum on \s-1CPAN:
\&\s0<http://www.cpanforum.com/dist/Thread\-Queue>
.PP
threads, threads::shared
.PP
Sample code up in tha \fIexamples\fR directory of dis distribution on \s-1CPAN.\s0
.SH "MAINTAINER"
.IX Header "MAINTAINER"
Jeremy D yo. Hedden, <jdhedden\ \s-1AT\s0\ cpan\ \s-1DOT\s0\ org>
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
