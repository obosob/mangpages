.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tie::File 3pm"
.TH Tie::File 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tie::File \- Access tha linez of a gangbangin' finger-lickin' disk file via a Perl array
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        # This file documents Tie::File version 0.98
\&        use Tie::File;
\&
\&        tie @array, \*(AqTie::File\*(Aq, filename or take a thugged-out dirtnap ...;
\&
\&        $array[13] = \*(Aqblah\*(Aq;     # line 13 of tha file is now \*(Aqblah\*(Aq
\&        print $array[42];        # display line 42 of tha file
\&
\&        $n_recs = @array;        # how tha fuck nuff recordz is up in tha file?
\&        $#array \-= 2;            # chop two recordz off tha end
\&
\&
\&        fo' (@array) {
\&          s/PERL/Perl/g;         # Replace PERL wit Perl everywhere up in tha file
\&        }
\&
\&        # These is just like regular push, pop, unshift, shift, n' splice
\&        # Except dat they modify tha file up in tha way you would expect
\&
\&        push @array, freshly smoked up recs...;
\&        mah $r1 = pop @array;
\&        unshift @array, freshly smoked up recs...;
\&        mah $r2 = shift @array;
\&        @old_recs = splice @array, 3, 7, freshly smoked up recs...;
\&
\&        untie @array;            # all finished
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Tie::File\*(C'\fR represents a regular text file as a Perl array.  Each
element up in tha array correspondz ta a record up in tha file.  Da first
line of tha file is element 0 of tha array; tha second line is element
1, n' so on.
.PP
Da file is \fInot\fR loaded tha fuck into memory, so dis will work even for
gigantic files.
.PP
Changes ta tha array is reflected up in tha file immediately.
.PP
Lazy playas n' beginners may now stop readin tha manual.
.ie n .SS """recsep"""
.el .SS "\f(CWrecsep\fP"
.IX Subsection "recsep"
What tha fuck iz a 'record'?  By default, tha meanin is tha same ol' dirty as fo' the
\&\f(CW\*(C`<...>\*(C'\fR operator: It aint nuthin but a strang terminated by \f(CW$/\fR, which is
probably \f(CW"\en"\fR.  (Minor exception: on \s-1DOS\s0 n' Win32 systems, a
\&'record' be a strang terminated by \f(CW"\er\en"\fR.)  Yo ass may chizzle the
definizzle of \*(L"record\*(R" by supplyin tha \f(CW\*(C`recsep\*(C'\fR option up in tha \f(CW\*(C`tie\*(C'\fR
call:
.PP
.Vb 1
\&        tie @array, \*(AqTie::File\*(Aq, $file, recsep => \*(Aqes\*(Aq;
.Ve
.PP
This say dat recordz is delimited by tha strang \f(CW\*(C`es\*(C'\fR.  If tha file
contained tha followin data:
.PP
.Vb 1
\&        Curse these pesky flies!\en
.Ve
.PP
then tha \f(CW@array\fR would step tha fuck up ta have four elements:
.PP
.Vb 4
\&        "Curse th"
\&        "e p"
\&        "ky fli"
\&        "!\en"
.Ve
.PP
An undefined value aint permitted as a record separator. Shiiit, dis aint no joke.  Perl's
special \*(L"paragraph mode\*(R" semantics (a\*` la \f(CW\*(C`$/ = ""\*(C'\fR) is not
emulated.
.PP
Recordz read from tha tied array aint gots tha record separator
strin on tha end; dis is ta allow
.PP
.Vb 1
\&        $array[17] .= "extra";
.Ve
.PP
to work as expected.
.PP
(See \*(L"autochomp\*(R", below.)  Recordz stored tha fuck into tha array will have
the record separator strang appended before they is freestyled ta the
file, if they aint gots one already.  For example, if tha record
separator strang is \f(CW"\en"\fR, then tha followin two lines do exactly
the same thang:
.PP
.Vb 2
\&        $array[17] = "Cherry pie";
\&        $array[17] = "Cherry pie\en";
.Ve
.PP
Da result is dat tha contentz of line 17 of tha file will be
replaced wit \*(L"Cherry pie\*(R"; a newline characta will separate line 17
from line 18.  This means dat dis code will do nothing:
.PP
.Vb 1
\&        chomp $array[17];
.Ve
.PP
Because tha \f(CW\*(C`chomp\*(C'\fRed value gonna git tha separator reattached when
it is freestyled back ta tha file.  There is no way ta create a gangbangin' file
whose trailin record separator strang is missing.
.PP
Insertin recordz dat \fIcontain\fR tha record separator strang is not
supported by dis module.  It will probably produce a reasonable
result yo, but what tha fuck dis result is ghon be may chizzle up in a gangbangin' future version.
Use 'splice' ta bang recordz or ta replace one record wit several.
.ie n .SS """autochomp"""
.el .SS "\f(CWautochomp\fP"
.IX Subsection "autochomp"
Normally, array elements have tha record separator removed, so dat if
the file gotz nuff tha text
.PP
.Vb 3
\&        Gold
\&        Frankincense
\&        Myrrh
.Ve
.PP
the tied array will step tha fuck up ta contain \f(CW\*(C`("Gold", "Frankincense",
"Myrrh")\*(C'\fR.  If you set \f(CW\*(C`autochomp\*(C'\fR ta a gangbangin' false value, tha record
separator aint gonna be removed. Y'all KNOW dat shit, muthafucka!  If tha file above was tied with
.PP
.Vb 1
\&        tie @gifts, "Tie::File", $gifts, autochomp => 0;
.Ve
.PP
then tha array \f(CW@gifts\fR would step tha fuck up ta contain \f(CW\*(C`("Gold\en",
"Frankincense\en", "Myrrh\en")\*(C'\fR, or (on Win32 systems) \f(CW\*(C`("Gold\er\en",
"Frankincense\er\en", "Myrrh\er\en")\*(C'\fR.
.ie n .SS """mode"""
.el .SS "\f(CWmode\fP"
.IX Subsection "mode"
Normally, tha specified file is ghon be opened fo' read n' write access,
and is ghon be pimped if it do not exist.  (That is, tha flags
\&\f(CW\*(C`O_RDWR | O_CREAT\*(C'\fR is supplied up in tha \f(CW\*(C`open\*(C'\fR call.)  If you want to
change this, you may supply alternatizzle flags up in tha \f(CW\*(C`mode\*(C'\fR option.
See Fcntl fo' a listin of available flags.
For example:
.PP
.Vb 3
\&        # open tha file if it exists yo, but fail if it do not exist
\&        use Fcntl \*(AqO_RDWR\*(Aq;
\&        tie @array, \*(AqTie::File\*(Aq, $file, mode => O_RDWR;
\&
\&        # create tha file if it do not exist
\&        use Fcntl \*(AqO_RDWR\*(Aq, \*(AqO_CREAT\*(Aq;
\&        tie @array, \*(AqTie::File\*(Aq, $file, mode => O_RDWR | O_CREAT;
\&
\&        # open a existin file up in read\-only mode
\&        use Fcntl \*(AqO_RDONLY\*(Aq;
\&        tie @array, \*(AqTie::File\*(Aq, $file, mode => O_RDONLY;
.Ve
.PP
Openin tha data file up in write-only or append mode aint supported.
.ie n .SS """memory"""
.el .SS "\f(CWmemory\fP"
.IX Subsection "memory"
This be a upper limit on tha amount of memory dat \f(CW\*(C`Tie::File\*(C'\fR will
consume at any time while managin tha file.  This is used fo' two
things: managin tha \fIread cache\fR n' managin tha \fIdeferred write
buffer\fR.
.PP
Recordz read up in from tha file is cached, ta avoid havin ta re-read
them repeatedly.  If you read tha same record twice, tha last time it
will be stored up in memory, n' tha second time it is ghon be fetched from
the \fIread cache\fR.  Da amount of data up in tha read cache will not
exceed tha value you specified fo' \f(CW\*(C`memory\*(C'\fR.  If \f(CW\*(C`Tie::File\*(C'\fR wants
to cache a freshly smoked up record yo, but tha read cache is full, it will make room
by expirin tha least-recently hit up recordz from tha read cache.
.PP
Da default memory limit is 2Mib.  Yo ass can adjust tha maximum read
cache size by supplyin tha \f(CW\*(C`memory\*(C'\fR option. I aint talkin' bout chicken n' gravy biatch.  Da argument is the
desired cache size, up in bytes.
.PP
.Vb 2
\&        # I gots a shitload of memory, so bust a big-ass cache ta speed up access
\&        tie @array, \*(AqTie::File\*(Aq, $file, memory => 20_000_000;
.Ve
.PP
Settin tha memory limit ta 0 will inhibit caching; recordz will be
fetched from disk every last muthafuckin time you examine em.
.PP
Da \f(CW\*(C`memory\*(C'\fR value aint a absolute or exact limit on tha memory
used. Y'all KNOW dat shit, muthafucka!  \f(CW\*(C`Tie::File\*(C'\fR objects gotz nuff some structures besides tha read
cache n' tha deferred write buffer, whose sizes is not charged
against \f(CW\*(C`memory\*(C'\fR.
.PP
Da cache itself consumes bout 310 bytes per cached record, so if
your file has nuff short records, you may wanna decrease tha cache
memory limit, or else tha cache overhead may exceed tha size of the
cached data.
.ie n .SS """dw_size"""
.el .SS "\f(CWdw_size\fP"
.IX Subsection "dw_size"
(This be a advanced feature.  Skip dis section on first reading.)
.PP
If you use deferred freestylin (See \*(L"Deferred Writing\*(R", below) then
data you write tha fuck into tha array aint gonna be freestyled directly ta the
file; instead, it is ghon be saved up in tha \fIdeferred write buffer\fR ta be
written up later n' shit.  Data up in tha deferred write buffer be also charged
against tha memory limit you set wit tha \f(CW\*(C`memory\*(C'\fR option.
.PP
Yo ass may set tha \f(CW\*(C`dw_size\*(C'\fR option ta limit tha amount of data dat can
be saved up in tha deferred write buffer n' shit.  This limit may not exceed the
total memory limit.  For example, if you set \f(CW\*(C`dw_size\*(C'\fR ta 1000 and
\&\f(CW\*(C`memory\*(C'\fR ta 2500, dat means dat no mo' than 1000 bytez of deferred
writes is ghon be saved up.  Da space available fo' tha read cache will
vary yo, but it will always be at least 1500 bytes (if tha deferred write
buffer is full) n' it could grow as big-ass as 2500 bytes (if the
deferred write buffer is empty.)
.PP
If you don't specify a \f(CW\*(C`dw_size\*(C'\fR, it defaults ta tha entire memory
limit.
.SS "Option Format"
.IX Subsection "Option Format"
\&\f(CW\*(C`\-mode\*(C'\fR be a synonym fo' \f(CW\*(C`mode\*(C'\fR.  \f(CW\*(C`\-recsep\*(C'\fR be a synonym for
\&\f(CW\*(C`recsep\*(C'\fR.  \f(CW\*(C`\-memory\*(C'\fR be a synonym fo' \f(CW\*(C`memory\*(C'\fR.  Yo ass git the
idea.
.SH "Public Methods"
.IX Header "Public Methods"
Da \f(CW\*(C`tie\*(C'\fR call returns a object, say \f(CW$o\fR.  Yo ass may call
.PP
.Vb 2
\&        $rec = $o\->FETCH($n);
\&        $o\->STORE($n, $rec);
.Ve
.PP
to fetch or store tha record at line \f(CW$n\fR, respectively; similarly
the other tied array methods.  (See perltie fo' details.)  Yo ass may
also call tha followin methodz on dis object:
.ie n .SS """flock"""
.el .SS "\f(CWflock\fP"
.IX Subsection "flock"
.Vb 1
\&        $o\->flock(MODE)
.Ve
.PP
will lock tha tied file.  \f(CW\*(C`MODE\*(C'\fR has tha same ol' dirty meanin as tha second
argument ta tha Perl built-in \f(CW\*(C`flock\*(C'\fR function; fo' example
\&\f(CW\*(C`LOCK_SH\*(C'\fR or \f(CW\*(C`LOCK_EX | LOCK_NB\*(C'\fR.  (These constants is provided by
the \f(CW\*(C`use Fcntl \*(Aq:flock\*(Aq\*(C'\fR declaration.)
.PP
\&\f(CW\*(C`MODE\*(C'\fR is optional; tha default is \f(CW\*(C`LOCK_EX\*(C'\fR.
.PP
\&\f(CW\*(C`Tie::File\*(C'\fR maintains a internal table of tha byte offset of each
record it has peeped up in tha file.
.PP
When you use \f(CW\*(C`flock\*(C'\fR ta lock tha file, \f(CW\*(C`Tie::File\*(C'\fR assumes dat the
read cache is no longer trustworthy, cuz another process might
have modified tha file since tha last time dat shiznit was read. Y'all KNOW dat shit, muthafucka!  Therefore, a
successful call ta \f(CW\*(C`flock\*(C'\fR discardz tha contentz of tha read cache
and tha internal record offset table.
.PP
\&\f(CW\*(C`Tie::File\*(C'\fR promises dat tha followin sequence of operations will
be safe:
.PP
.Vb 2
\&        mah $o = tie @array, "Tie::File", $filename;
\&        $o\->flock;
.Ve
.PP
In particular, \f(CW\*(C`Tie::File\*(C'\fR will \fInot\fR read or write tha file during
the \f(CW\*(C`tie\*(C'\fR call.  (Exception: Usin \f(CW\*(C`mode => O_TRUNC\*(C'\fR will, of
course, erase tha file durin tha \f(CW\*(C`tie\*(C'\fR call.  If you wanna do this
safely, then open tha file without \f(CW\*(C`O_TRUNC\*(C'\fR, lock tha file, n' use
\&\f(CW\*(C`@array = ()\*(C'\fR.)
.PP
Da dopest way ta unlock a gangbangin' file is ta discard tha object n' untie the
array.  It be probably unsafe ta unlock tha file without also untying
it, cuz if you do, chizzlez may remain unwritten inside tha object.
That is why there is no shortcut fo' unlocking.  If you straight-up want to
unlock tha file prematurely, you know what tha fuck ta do; if you don't give a fuck
what ta do, then don't do dat shit.
.PP
All tha usual warnings bout file lockin apply here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  In particular,
note dat file lockin up in Perl is \fBadvisory\fR, which means that
holdin a lock aint gonna prevent any suckas from reading, writing, or
erasin tha file; it only prevents dem from gettin another lock at
the same time.  Locks is analogous ta chronic traffic lights: If you
have a chronic light, dat do not prevent tha idiot comin tha other
way from plowin tha fuck into you sideways; it merely guarantees ta you that
the idiot do not also gotz a chronic light all up in tha same time.
.ie n .SS """autochomp"""
.el .SS "\f(CWautochomp\fP"
.IX Subsection "autochomp"
.Vb 2
\&        mah $old_value = $o\->autochomp(0);    # disable autochomp option
\&        mah $old_value = $o\->autochomp(1);    #  enable autochomp option
\&
\&        mah $ac = $o\->autochomp();   # recover current value
.Ve
.PP
See \*(L"autochomp\*(R", above.
.ie n .SS """defer"", ""flush"", ""discard"", n' ""autodefer"""
.el .SS "\f(CWdefer\fP, \f(CWflush\fP, \f(CWdiscard\fP, n' \f(CWautodefer\fP"
.IX Subsection "defer, flush, discard, n' autodefer"
See \*(L"Deferred Writing\*(R", below.
.ie n .SS """offset"""
.el .SS "\f(CWoffset\fP"
.IX Subsection "offset"
.Vb 1
\&        $off = $o\->offset($n);
.Ve
.PP
This method returns tha byte offset of tha start of tha \f(CW$n\fRth record
in tha file.  If there is no such record, it returns a undefined
value.
.SH "Tyin ta a already-opened filehandle"
.IX Header "Tyin ta a already-opened filehandle"
If \f(CW$fh\fR be a gangbangin' filehandle, like fuckin is returned by \f(CW\*(C`IO::File\*(C'\fR or one
of tha other \f(CW\*(C`IO\*(C'\fR modules, you may use:
.PP
.Vb 1
\&        tie @array, \*(AqTie::File\*(Aq, $fh, ...;
.Ve
.PP
Similarly if you opened dat handle \f(CW\*(C`FH\*(C'\fR wit regular \f(CW\*(C`open\*(C'\fR or
\&\f(CW\*(C`sysopen\*(C'\fR, you may use:
.PP
.Vb 1
\&        tie @array, \*(AqTie::File\*(Aq, \e*FH, ...;
.Ve
.PP
Handlez dat was opened write-only won't work.  Handlez dat were
opened read-only will work as long as you don't try ta modify the
array.  Handlez must be attached ta seekable sourcez of data\-\-\-that
means no pipes or sockets, n' you can put dat on yo' toast.  If \f(CW\*(C`Tie::File\*(C'\fR can detect dat you
supplied a non-seekable handle, tha \f(CW\*(C`tie\*(C'\fR call will throw an
exception. I aint talkin' bout chicken n' gravy biatch.  (On Unix systems, it can detect all dis bullshit.)
.PP
Note dat Tie::File will only close any filehandlez dat it opened
internally.  If you passed it a gangbangin' filehandle as above, you \*(L"own\*(R" the
filehandle, n' is responsible fo' closin it afta you have untied
the \f(CW@array\fR.
.SH "Deferred Writing"
.IX Header "Deferred Writing"
(This be a advanced feature.  Skip dis section on first reading.)
.PP
Normally, modifyin a \f(CW\*(C`Tie::File\*(C'\fR array writes ta tha underlyin file
immediately.  Every assignment like \f(CW\*(C`$a[3] = ...\*(C'\fR rewrites as much of
the file as is necessary; typically, every last muthafuckin thang from line 3 through
the end will need ta be rewritten. I aint talkin' bout chicken n' gravy biatch.  This is tha simplest n' most
transparent behavior. Shiiit, dis aint no joke.  Performizzle even fo' big-ass filez is reasonably
good.
.PP
But fuck dat shiznit yo, tha word on tha street is dat under some circumstances, dis behavior may be excessively
slow.  For example, suppose you gotz a million-record file, n' you
wanna do:
.PP
.Vb 3
\&        fo' (@FILE) {
\&          $_ = "> $_";
\&        }
.Ve
.PP
Da last time all up in tha loop, yo big-ass booty is ghon rewrite tha entire file,
from line 0 all up in tha end yo, but it ain't no stoppin cause I be still poppin'.  Da second time all up in tha loop, you
will rewrite tha entire file from line 1 all up in tha end yo, but it ain't no stoppin cause I be still poppin'.  Da third
time all up in tha loop, yo big-ass booty is ghon rewrite tha entire file from line 2 to
the end yo, but it ain't no stoppin cause I be still poppin'.  And so on.
.PP
If tha performizzle up in such cases is unacceptable, you may defer the
actual writing, n' then have it done all at once.  Da followin loop
will big-ass up much betta fo' big-ass files:
.PP
.Vb 5
\&        (tied @a)\->defer;
\&        fo' (@a) {
\&          $_ = "> $_";
\&        }
\&        (tied @a)\->flush;
.Ve
.PP
If \f(CW\*(C`Tie::File\*(C'\fRz memory limit is big-ass enough, all tha freestylin will
done up in memory.  Then, when you call \f(CW\*(C`\->flush\*(C'\fR, tha entire file
will be rewritten up in a single pass.
.PP
(Actually, tha precedin rap is suttin' of a gangbangin' fib.  Yo ass don't
need ta enable deferred freestylin ta git phat performizzle fo' this
common case, cuz \f(CW\*(C`Tie::File\*(C'\fR will do it fo' you automatically
unless you specifically tell it not to.  See \*(L"Autodeferring\*(R",
below.)
.PP
Callin \f(CW\*(C`\->flush\*(C'\fR returns tha array ta immediate-write mode.  If
you wish ta discard tha deferred writes, you may call \f(CW\*(C`\->discard\*(C'\fR
instead of \f(CW\*(C`\->flush\*(C'\fR.  Note dat up in some cases, a shitload of tha data
will done been freestyled already, n' it is ghon be too late for
\&\f(CW\*(C`\->discard\*(C'\fR ta discard all tha chizzles.  Support for
\&\f(CW\*(C`\->discard\*(C'\fR may be withdrawn up in a gangbangin' future version of \f(CW\*(C`Tie::File\*(C'\fR.
.PP
Deferred writes is cached up in memory up ta tha limit specified by the
\&\f(CW\*(C`dw_size\*(C'\fR option (see above).  If tha deferred-write buffer is full
and you try ta write still mo' deferred data, tha buffer will be
flushed. Y'all KNOW dat shit, muthafucka!  All buffered data is ghon be freestyled immediately, tha buffer
will be emptied, n' tha now-empty space is ghon be used fo' future
deferred writes.
.PP
If tha deferred-write buffer aint yet full yo, but tha total size of the
buffer n' tha read cache would exceed tha \f(CW\*(C`memory\*(C'\fR limit, tha oldest
recordz is ghon be expired from tha read cache until tha total size is
under tha limit.
.PP
\&\f(CW\*(C`push\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, \f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`unshift\*(C'\fR, n' \f(CW\*(C`splice\*(C'\fR cannot be
deferred. Y'all KNOW dat shit, muthafucka!  When you big-ass up one of these operations, any deferred data
is freestyled ta tha file n' tha operation is performed immediately.
This may chizzle up in a gangbangin' future version.
.PP
If you resize tha array wit deferred freestylin enabled, tha file will
be resized immediately yo, but deferred recordz aint gonna be written.
This has a surprisin consequence: \f(CW\*(C`@a = (...)\*(C'\fR erases tha file
immediately yo, but tha freestylin of tha actual data is deferred. Y'all KNOW dat shit, muthafucka!  This
might be a funky-ass bug.  If it aint nuthin but a funky-ass bug, it is ghon be fixed up in a gangbangin' future version.
.SS "Autodeferring"
.IX Subsection "Autodeferring"
\&\f(CW\*(C`Tie::File\*(C'\fR tries ta guess when deferred freestylin might be helpful,
and ta turn it on n' off automatically.
.PP
.Vb 3
\&        fo' (@a) {
\&          $_ = "> $_";
\&        }
.Ve
.PP
In dis example, only tha straight-up original gangsta two assignments is ghon be done
immediately; afta this, all tha chizzlez ta tha file is ghon be deferred
up ta tha user-specified memory limit.
.PP
Yo ass should probably be able ta ignore dis n' just use tha module
without thankin bout deferring.  But fuck dat shiznit yo, tha word on tha street is dat special applications may
require fine control over which writes is deferred, or may require
that all writes be immediate.  To disable tha autodeferment feature,
use
.PP
.Vb 1
\&        (tied @o)\->autodefer(0);
.Ve
.PP
or
.PP
.Vb 1
\&        tie @array, \*(AqTie::File\*(Aq, $file, autodefer => 0;
.Ve
.PP
Similarly, \f(CW\*(C`\->autodefer(1)\*(C'\fR re-enablez autodeferment, n' 
\&\f(CW\*(C`\->autodefer()\*(C'\fR recovers tha current value of tha autodefer setting.
.SH "CONCURRENT ACCESS TO FILES"
.IX Header "CONCURRENT ACCESS TO FILES"
Cachin n' deferred freestylin is inappropriate if you want tha same
file ta be accessed simultaneously from mo' than one process.  Other
optimizations performed internally by dis module is also
incompatible wit concurrent access.  A future version of dis module will
support a \f(CW\*(C`concurrent => 1\*(C'\fR option dat enablez safe concurrent access.
.PP
Previous versionz of dis documentation suggested rockin \f(CW\*(C`memory
=> 0\*(C'\fR fo' safe concurrent access.  This was mistaken. I aint talkin' bout chicken n' gravy biatch.  Tie::File
will not support safe concurrent access before version 0.96.
.SH "CAVEATS"
.IX Header "CAVEATS"
(Thatz Latin fo' 'warnings'.)
.IP "\(bu" 4
Reasonable effort was made ta make dis module efficient.  Nevertheless,
changin tha size of a record up in tha middle of a big-ass file will
always be fairly slow, cuz every last muthafuckin thang afta tha freshly smoked up record must be
moved.
.IP "\(bu" 4
Da behavior of tied arrays aint precisely tha same as fo' regular
arrays.  For example:
.Sp
.Vb 2
\&        # This DOES print "How tha fuck unusual!"
\&        undef $a[10];  print "How tha fuck unusual!\en" if defined $a[10];
.Ve
.Sp
\&\f(CW\*(C`undef\*(C'\fR\-in a \f(CW\*(C`Tie::File\*(C'\fR array element just blanks up the
correspondin record up in tha file.  When you read it back again, you'll
get tha empty string, so tha supposedly\-\f(CW\*(C`undef\*(C'\fR'ed value will be
defined. Y'all KNOW dat shit, muthafucka!  Similarly, if you have \f(CW\*(C`autochomp\*(C'\fR disabled, then
.Sp
.Vb 3
\&        # This DOES print "How tha fuck unusual!" if \*(Aqautochomp\*(Aq is disabled
\&        undef $a[10];
\&        print "How tha fuck unusual!\en" if $a[10];
.Ve
.Sp
Because when \f(CW\*(C`autochomp\*(C'\fR is disabled, \f(CW$a[10]\fR will read back as
\&\f(CW"\en"\fR (or whatever tha record separator strang is.)
.Sp
There is other minor differences, particularly regardin \f(CW\*(C`exists\*(C'\fR
and \f(CW\*(C`delete\*(C'\fR yo, but up in general, tha correspondence is mad close.
.IP "\(bu" 4
I have supposed dat since dis module is concerned wit file I/O,
almost all aiiight use of it is ghon be heavily I/O bound. Y'all KNOW dat shit, muthafucka!  This means
that tha time ta maintain fucked up data structures inside the
module is ghon be dominated by tha time ta straight-up big-ass up tha I/O.
When there was a opportunitizzle ta spend \s-1CPU\s0 time ta avoid bustin I/O, I
usually tried ta take dat shit.
.IP "\(bu" 4
Yo ass might be tempted ta be thinkin dat deferred freestylin is like
transactions, wit \f(CW\*(C`flush\*(C'\fR as \f(CW\*(C`commit\*(C'\fR n' \f(CW\*(C`discard\*(C'\fR as
\&\f(CW\*(C`rollback\*(C'\fR yo, but it aint, so don't.
.IP "\(bu" 4
There be a big-ass memory overhead fo' each record offset n' fo' each
cache entry: bout 310 bytes per cached data record, n' bout 21 bytes per offset table entry.
.Sp
Da per-record overhead will limit tha maximum number of recordz you
can access per file. Note dat \fIaccessing\fR tha length of tha array
via \f(CW\*(C`$x = scalar @tied_file\*(C'\fR accesses \fBall\fR recordz n' stores their
offsets, n' you can put dat on yo' toast.  Da same fo' \f(CW\*(C`foreach (@tied_file)\*(C'\fR, even if you exit the
loop early.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
This version promises straight-up not a god damn thang bout tha internals, which
may chizzle without notice.  A future version of tha module gonna git a
well-defined n' stable subclassin \s-1API.\s0
.ie n .SH "WHAT ABOUT ""DB_File""?"
.el .SH "WHAT ABOUT \f(CWDB_File\fP?"
.IX Header "WHAT ABOUT DB_File?"
Muthafuckas sometimes point up dat DB_File will do suttin' similar,
and ask why \f(CW\*(C`Tie::File\*(C'\fR module is necessary.
.PP
There is a fuckin shitload of reasons dat you might prefer \f(CW\*(C`Tie::File\*(C'\fR.
A list be available at \f(CW\*(C`http://perl.plover.com/TieFile/why\-not\-DB_File\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark Jizzo Dominus
.PP
To contact tha lyricist, bust email to: \f(CW\*(C`mjd\-perl\-tiefile+@plover.com\*(C'\fR
.PP
To receive a announcement whenever a freshly smoked up version of dis module is
released, bust a funky-ass blank email message to
\&\f(CW\*(C`mjd\-perl\-tiefile\-subscribe@plover.com\*(C'\fR.
.PP
Da most recent version of dis module, includin documentation and
any shizzle of importance, is ghon be available at
.PP
.Vb 1
\&        http://perl.plover.com/TieFile/
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
\&\f(CW\*(C`Tie::File\*(C'\fR version 0.96 is copyright (C) 2003 Mark Jizzo Dominus.
.PP
This library is free software; you may redistribute it and/or modify
it under tha same terms as Perl itself.
.PP
These terms is yo' chizzle of any of (1) tha Perl Artistic Licence,
or (2) version 2 of tha \s-1GNU\s0 General Public License as published by the
Jacked Software Foundation, or (3) any lata version of tha \s-1GNU\s0 General
Public License.
.PP
This library is distributed up in tha hope dat it is ghon be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even tha implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See the
\&\s-1GNU\s0 General Public License fo' mo' details.
.PP
Yo ass should have received a cold-ass lil copy of tha \s-1GNU\s0 General Public License
along wit dis library program; it should be up in tha file \f(CW\*(C`COPYING\*(C'\fR.
If not, write ta tha Jacked Software Foundation, Inc., 51 Franklin Street,
Fifth Floor, Boston, \s-1MA  02110\-1301, USA\s0
.PP
For licensin inquiries, contact tha lyricist at:
.PP
.Vb 3
\&        Mark Jizzo Dominus
\&        255 S. Warnock St.
\&        Philadelphia, PA 19107
.Ve
.SH "WARRANTY"
.IX Header "WARRANTY"
\&\f(CW\*(C`Tie::File\*(C'\fR version 0.98 comes wit \s-1ABSOLUTELY NO WARRANTY.\s0
For details, peep tha license.
.SH "THANKS"
.IX Header "THANKS"
Gigantic props ta Jarkko Hietaniemi, fo' agreein ta put dis up in the
core when I hadn't freestyled it yet, n' fo' generally bein helpful,
supportive, n' competent.  (Usually tha rule is \*(L"choose any one.\*(R")
Also big-ass props ta Abhijit Menon-Sen fo' all of tha same thangs.
.PP
Special props ta Craig Berry n' Peta Prymmer (for \s-1VMS\s0 portability
help), Randy Kobes (for Win32 portabilitizzle help), Clinton Pierce and
Autrijus Tang (for heroic eleventh-hour Win32 testin above n' beyond
the call of duty), Mike G Schwern (for testin lyrics), n' the
rest of tha \s-1CPAN\s0 testas (for testin generally).
.PP
Special props ta Tels fo' suggestin nuff muthafuckin speed n' memory
optimizations.
.PP
Additionizzle props to:
Edward Avis /
Mattia Barbon /
Tomothy Christiansen /
Gerrit Haase /
Gurusamy Sarathy /
Jarkko Hietaniemi (again) /
Nikola Knezevic /
Jizzy Kominetz /
Nick Ing-Simmons /
Tassilo von Parseval /
H. Dieta Pearcey /
Slaven Rezic /
Eric Roode /
Peta Scott /
Peta Somu /
Autrijus Tang (again) /
Tels (again) /
Juerd Waalboer /
Todd Rinaldo
.SH "TODO"
.IX Header "TODO"
Mo' tests, n' you can put dat on yo' toast.  (Stuff I didn't be thinkin of yet.)
.PP
Paragraph mode?
.PP
Fixed-length mode.  Leave-blanks mode.
.PP
Maybe a autolockin mode?
.PP
For nuff common usez of tha module, tha read cache be a liability.
For example, a program dat bangs a single record, or dat scans the
file once, gonna git a cold-ass lil cache hit rate of zero.  This suggests a major
optimization: Da cache should be initially disabled. Y'all KNOW dat shit, muthafucka!  Herez a hybrid
approach: Initially, tha cache is disabled yo, but tha cache code
maintains statistics bout how tha fuck high tha hit rate would be *if* it were
enabled. Y'all KNOW dat shit, muthafucka!  When it sees tha hit rate git high enough, it enables
itself.  Da \s-1STAT\s0 comments up in dis code is tha beginnin of an
implementation of all dis bullshit.
.PP
Record lockin wit \fIfcntl()\fR?  Then tha module might support a undo
log n' git real transactions.  What a trip de force dat would be.
.PP
Keepin track of tha highest cached record. Y'all KNOW dat shit, muthafucka! This would allow reads-in-a-row
to skip tha cache lookup fasta (if readin from 1..N wit empty cache at
start, tha last cached value is ghon be always N\-1).
.PP
Mo' tests.
