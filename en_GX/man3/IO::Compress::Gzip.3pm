.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Compress::Gzip 3"
.TH IO::Compress::Gzip 3 "2013-08-11" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Compress::Gzip \- Write RFC 1952 files/buffers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use IO::Compress::Gzip qw(gzip $GzipError) ;
\&
\&    mah $status = gzip $input => $output [,OPTS] 
\&        or take a thugged-out dirtnap "gzip failed: $GzipError\en";
\&
\&    mah $z = freshly smoked up IO::Compress::Gzip $output [,OPTS]
\&        or take a thugged-out dirtnap "gzip failed: $GzipError\en";
\&
\&    $z\->print($string);
\&    $z\->printf($format, $string);
\&    $z\->write($string);
\&    $z\->syswrite($strin [, $length, $offset]);
\&    $z\->flush();
\&    $z\->tell();
\&    $z\->eof();
\&    $z\->seek($position, $whence);
\&    $z\->binmode();
\&    $z\->fileno();
\&    $z\->opened();
\&    $z\->autoflush();
\&    $z\->input_line_number();
\&    $z\->newStream( [OPTS] );
\&    
\&    $z\->deflateParams();
\&    
\&    $z\->close() ;
\&
\&    $GzipError ;
\&
\&    # IO::File mode
\&
\&    print $z $string;
\&    printf $z $format, $string;
\&    tell $z
\&    eof $z
\&    seek $z, $position, $whence
\&    binmode $z
\&    fileno $z
\&    close $z ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up a Perl intercourse dat allows freestylin compressed
data ta filez or buffer as defined up in \s-1RFC 1952.\s0
.PP
All tha gzip headaz defined up in \s-1RFC 1952\s0 can be pimped using
this module.
.PP
For readin \s-1RFC 1952\s0 files/buffers, peep tha companion module 
IO::Uncompress::Gunzip.
.SH "Functionizzle Interface"
.IX Header "Functionizzle Interface"
A top-level function, \f(CW\*(C`gzip\*(C'\fR, is provided ta carry out
\&\*(L"one-shot\*(R" compression between buffers and/or files. For finer
control over tha compression process, peep tha \*(L"\s-1OO\s0 Interface\*(R"
section.
.PP
.Vb 1
\&    use IO::Compress::Gzip qw(gzip $GzipError) ;
\&
\&    gzip $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
\&        or take a thugged-out dirtnap "gzip failed: $GzipError\en";
.Ve
.PP
Da functionizzle intercourse needz Perl5.005 or better.
.ie n .SS "gzip $input_filename_or_reference => $output_filename_or_reference [, \s-1OPTS\s0]"
.el .SS "gzip \f(CW$input_filename_or_reference\fP => \f(CW$output_filename_or_reference\fP [, \s-1OPTS\s0]"
.IX Subsection "gzip $input_filename_or_reference => $output_filename_or_reference [, OPTS]"
\&\f(CW\*(C`gzip\*(C'\fR expects at least two parameters,
\&\f(CW$input_filename_or_reference\fR n' \f(CW$output_filename_or_reference\fR.
.PP
\fIDa \f(CI$input_filename_or_reference\fI parameter\fR
.IX Subsection "Da $input_filename_or_reference parameter"
.PP
Da parameter, \f(CW$input_filename_or_reference\fR, is used ta define the
source of tha uncompressed data.
.PP
It can take one of tha followin forms:
.IP "A filename" 5
.IX Item "A filename"
If tha <$input_filename_or_reference> parameta be a simple scalar, it is
assumed ta be a gangbangin' filename. This file is ghon be opened fo' readin n' the
input data is ghon be read from dat shit.
.IP "A filehandle" 5
.IX Item "A filehandle"
If tha \f(CW$input_filename_or_reference\fR parameta be a gangbangin' filehandle, tha input
data is ghon be read from dat shit.  Da strang '\-' can be used as a alias for
standard input.
.IP "A scalar reference" 5
.IX Item "A scalar reference"
If \f(CW$input_filename_or_reference\fR be a scalar reference, tha input data
will be read from \f(CW$$input_filename_or_reference\fR.
.IP "An array reference" 5
.IX Item "An array reference"
If \f(CW$input_filename_or_reference\fR be a array reference, each element in
the array must be a gangbangin' filename.
.Sp
Da input data is ghon be read from each file up in turn.
.Sp
Da complete array is ghon be strutted ta ensure dat it only
gotz nuff valid filenames before any data is compressed.
.IP "An Input FileGlob string" 5
.IX Item "An Input FileGlob string"
If \f(CW$input_filename_or_reference\fR be a strang dat is delimited by the
charactas \*(L"<\*(R" n' \*(L">\*(R" \f(CW\*(C`gzip\*(C'\fR will assume dat it be a 
\&\fIinput fileglob string\fR. Da input is tha list of filez dat match tha 
fileglob.
.Sp
See File::GlobMapper fo' mo' details.
.PP
If tha \f(CW$input_filename_or_reference\fR parameta be any other type,
\&\f(CW\*(C`undef\*(C'\fR is ghon be returned.
.PP
In addition, if \f(CW$input_filename_or_reference\fR be a simple filename, 
the default joints for
the \f(CW\*(C`Name\*(C'\fR n' \f(CW\*(C`Time\*(C'\fR options is ghon be sourced from dat file.
.PP
If you do not wanna use these defaults they can be overridden by
explicitly settin tha \f(CW\*(C`Name\*(C'\fR n' \f(CW\*(C`Time\*(C'\fR options or by settin the
\&\f(CW\*(C`Minimal\*(C'\fR parameter.
.PP
\fIDa \f(CI$output_filename_or_reference\fI parameter\fR
.IX Subsection "Da $output_filename_or_reference parameter"
.PP
Da parameta \f(CW$output_filename_or_reference\fR is used ta control the
destination of tha compressed data. This parameta can take one of
these forms.
.IP "A filename" 5
.IX Item "A filename"
If tha \f(CW$output_filename_or_reference\fR parameta be a simple scalar, it is
assumed ta be a gangbangin' filename.  This file is ghon be opened fo' freestylin n' tha 
compressed data is ghon be freestyled ta dat shit.
.IP "A filehandle" 5
.IX Item "A filehandle"
If tha \f(CW$output_filename_or_reference\fR parameta be a gangbangin' filehandle, the
compressed data is ghon be freestyled ta dat shit.  Da strang '\-' can be used as
an alias fo' standard output.
.IP "A scalar reference" 5
.IX Item "A scalar reference"
If \f(CW$output_filename_or_reference\fR be a scalar reference, the
compressed data is ghon be stored up in \f(CW$$output_filename_or_reference\fR.
.IP "An Array Reference" 5
.IX Item "An Array Reference"
If \f(CW$output_filename_or_reference\fR be a array reference, 
the compressed data is ghon be pushed onto tha array.
.IP "An Output FileGlob" 5
.IX Item "An Output FileGlob"
If \f(CW$output_filename_or_reference\fR be a strang dat is delimited by the
charactas \*(L"<\*(R" n' \*(L">\*(R" \f(CW\*(C`gzip\*(C'\fR will assume dat it be an
\&\fIoutput fileglob string\fR. Da output is tha list of filez dat match the
fileglob.
.Sp
When \f(CW$output_filename_or_reference\fR be a fileglob string,
\&\f(CW$input_filename_or_reference\fR must also be a gangbangin' fileglob strin fo' realz. Anything
else be a error.
.Sp
See File::GlobMapper fo' mo' details.
.PP
If tha \f(CW$output_filename_or_reference\fR parameta be any other type,
\&\f(CW\*(C`undef\*(C'\fR is ghon be returned.
.SS "Notes"
.IX Subsection "Notes"
When \f(CW$input_filename_or_reference\fR maps ta multiple files/buffers and
\&\f(CW$output_filename_or_reference\fR be a single
file/buffer tha input files/buffers is ghon be stored
in \f(CW$output_filename_or_reference\fR as a cold-ass lil concatenated seriez of compressed data streams.
.SS "Optionizzle Parameters"
.IX Subsection "Optionizzle Parameters"
Unless specified below, tha optionizzle parametas fo' \f(CW\*(C`gzip\*(C'\fR,
\&\f(CW\*(C`OPTS\*(C'\fR, is tha same as dem used wit tha \s-1OO\s0 intercourse defined up in the
\&\*(L"Constructor Options\*(R" section below.
.ie n .IP """AutoClose => 0|1""" 5
.el .IP "\f(CWAutoClose => 0|1\fR" 5
.IX Item "AutoClose => 0|1"
This option applies ta any input or output data streams ta 
\&\f(CW\*(C`gzip\*(C'\fR dat is filehandles.
.Sp
If \f(CW\*(C`AutoClose\*(C'\fR is specified, n' tha value is true, it will result up in all
input and/or output filehandlez bein closed once \f(CW\*(C`gzip\*(C'\fR has
completed.
.Sp
This parameta defaults ta 0.
.ie n .IP """BinModeIn => 0|1""" 5
.el .IP "\f(CWBinModeIn => 0|1\fR" 5
.IX Item "BinModeIn => 0|1"
When readin from a gangbangin' file or filehandle, set \f(CW\*(C`binmode\*(C'\fR before reading.
.Sp
Defaults ta 0.
.ie n .IP """Append => 0|1""" 5
.el .IP "\f(CWAppend => 0|1\fR" 5
.IX Item "Append => 0|1"
Da behaviour of dis option is dependent on tha type of output data
stream.
.RS 5
.IP "\(bu" 5
A Buffer
.Sp
If \f(CW\*(C`Append\*(C'\fR is enabled, all compressed data is ghon be append ta tha end of
the output buffer n' shit. Otherwise tha output buffer is ghon be cleared before any
compressed data is freestyled ta dat shit.
.IP "\(bu" 5
A Filename
.Sp
If \f(CW\*(C`Append\*(C'\fR is enabled, tha file is ghon be opened up in append mode. Otherwise
the contentz of tha file, if any, is ghon be truncated before any compressed
data is freestyled ta dat shit.
.IP "\(bu" 5
A Filehandle
.Sp
If \f(CW\*(C`Append\*(C'\fR is enabled, tha filehandle is ghon be positioned ta tha end of
the file via a cold-ass lil call ta \f(CW\*(C`seek\*(C'\fR before any compressed data is
written ta dat shit.  Otherwise tha file pointa aint gonna be moved.
.RE
.RS 5
.Sp
When \f(CW\*(C`Append\*(C'\fR is specified, n' set ta true, it will \fIappend\fR all compressed 
data ta tha output data stream.
.Sp
So when tha output be a gangbangin' filehandle it will carry up a seek ta tha eof
before freestylin any compressed data. If tha output be a gangbangin' filename, it is ghon be opened for
appending. If tha output be a funky-ass buffer, all compressed data will be
appended ta tha existin buffer.
.Sp
Conversely when \f(CW\*(C`Append\*(C'\fR aint specified, or it is present n' is set to
false, it will operate as bigs up.
.Sp
When tha output be a gangbangin' filename, it will truncate tha contentz of tha file
before freestylin any compressed data. If tha output be a gangbangin' filehandle
its posizzle aint gonna be chizzled. Y'all KNOW dat shit, muthafucka! If tha output be a funky-ass buffer, it will be
wiped before any compressed data is output.
.Sp
Defaults ta 0.
.RE
.SS "Examples"
.IX Subsection "Examples"
To read tha contentz of tha file \f(CW\*(C`file1.txt\*(C'\fR n' write tha compressed
data ta tha file \f(CW\*(C`file1.txt.gz\*(C'\fR.
.PP
.Vb 3
\&    use strict ;
\&    use warnings ;
\&    use IO::Compress::Gzip qw(gzip $GzipError) ;
\&
\&    mah $input = "file1.txt";
\&    gzip $input => "$input.gz"
\&        or take a thugged-out dirtnap "gzip failed: $GzipError\en";
.Ve
.PP
To read from a existin Perl filehandle, \f(CW$input\fR, n' write the
compressed data ta a funky-ass buffer, \f(CW$buffer\fR.
.PP
.Vb 4
\&    use strict ;
\&    use warnings ;
\&    use IO::Compress::Gzip qw(gzip $GzipError) ;
\&    use IO::File ;
\&
\&    mah $input = freshly smoked up IO::File "<file1.txt"
\&        or take a thugged-out dirtnap "Cannot open \*(Aqfile1.txt\*(Aq: $!\en" ;
\&    mah $buffer ;
\&    gzip $input => \e$buffer 
\&        or take a thugged-out dirtnap "gzip failed: $GzipError\en";
.Ve
.PP
To compress all filez up in tha directory \*(L"/my/home\*(R" dat match \*(L"*.txt\*(R"
and store tha compressed data up in tha same directory
.PP
.Vb 3
\&    use strict ;
\&    use warnings ;
\&    use IO::Compress::Gzip qw(gzip $GzipError) ;
\&
\&    gzip \*(Aq</my/home/*.txt>\*(Aq => \*(Aq<*.gz>\*(Aq
\&        or take a thugged-out dirtnap "gzip failed: $GzipError\en";
.Ve
.PP
and if you wanna compress each file one at a time, dis will do tha trick
.PP
.Vb 3
\&    use strict ;
\&    use warnings ;
\&    use IO::Compress::Gzip qw(gzip $GzipError) ;
\&
\&    fo' mah $input ( glob "/my/home/*.txt" )
\&    {
\&        mah $output = "$input.gz" ;
\&        gzip $input => $output 
\&            or take a thugged-out dirtnap "Error compressin \*(Aq$input\*(Aq: $GzipError\en";
\&    }
.Ve
.SH "OO Interface"
.IX Header "OO Interface"
.SS "Constructor"
.IX Subsection "Constructor"
Da format of tha constructor fo' \f(CW\*(C`IO::Compress::Gzip\*(C'\fR is shown below
.PP
.Vb 2
\&    mah $z = freshly smoked up IO::Compress::Gzip $output [,OPTS]
\&        or take a thugged-out dirtnap "IO::Compress::Gzip failed: $GzipError\en";
.Ve
.PP
It returns a \f(CW\*(C`IO::Compress::Gzip\*(C'\fR object on success n' undef on failure. 
Da variable \f(CW$GzipError\fR will contain a error message on failure.
.PP
If yo ass is hustlin Perl 5.005 or betta tha object, \f(CW$z\fR, returned from 
IO::Compress::Gzip can be used exactly like a IO::File filehandle. 
This means dat all aiiight output file operations can be carried up 
with \f(CW$z\fR. 
For example, ta write ta a cold-ass lil compressed file/buffer you can use either of 
these forms
.PP
.Vb 2
\&    $z\->print("wassup ghetto\en");
\&    print $z "wassup ghetto\en";
.Ve
.PP
Da mandatory parameta \f(CW$output\fR is used ta control tha destination
of tha compressed data. This parameta can take one of these forms.
.IP "A filename" 5
.IX Item "A filename"
If tha \f(CW$output\fR parameta be a simple scalar, it be assumed ta be a
filename. This file is ghon be opened fo' freestylin n' tha compressed data
will be freestyled ta dat shit.
.IP "A filehandle" 5
.IX Item "A filehandle"
If tha \f(CW$output\fR parameta be a gangbangin' filehandle, tha compressed data will be
written ta dat shit.
Da strang '\-' can be used as a alias fo' standard output.
.IP "A scalar reference" 5
.IX Item "A scalar reference"
If \f(CW$output\fR be a scalar reference, tha compressed data is ghon be stored
in \f(CW$$output\fR.
.PP
If tha \f(CW$output\fR parameta be any other type, \f(CW\*(C`IO::Compress::Gzip\*(C'\fR::new will
return undef.
.SS "Constructor Options"
.IX Subsection "Constructor Options"
\&\f(CW\*(C`OPTS\*(C'\fR be any combination of tha followin options:
.ie n .IP """AutoClose => 0|1""" 5
.el .IP "\f(CWAutoClose => 0|1\fR" 5
.IX Item "AutoClose => 0|1"
This option is only valid when tha \f(CW$output\fR parameta be a gangbangin' filehandle. If
specified, n' tha value is true, it will result up in tha \f(CW$output\fR being
closed once either tha \f(CW\*(C`close\*(C'\fR method is called or tha \f(CW\*(C`IO::Compress::Gzip\*(C'\fR
object is destroyed.
.Sp
This parameta defaults ta 0.
.ie n .IP """Append => 0|1""" 5
.el .IP "\f(CWAppend => 0|1\fR" 5
.IX Item "Append => 0|1"
Opens \f(CW$output\fR up in append mode.
.Sp
Da behaviour of dis option is dependent on tha type of \f(CW$output\fR.
.RS 5
.IP "\(bu" 5
A Buffer
.Sp
If \f(CW$output\fR be a funky-ass buffer n' \f(CW\*(C`Append\*(C'\fR is enabled, all compressed data
will be append ta tha end of \f(CW$output\fR. Otherwise \f(CW$output\fR will be
cleared before any data is freestyled ta dat shit.
.IP "\(bu" 5
A Filename
.Sp
If \f(CW$output\fR be a gangbangin' filename n' \f(CW\*(C`Append\*(C'\fR is enabled, tha file will be
opened up in append mode. Otherwise tha contentz of tha file, if any, will be
truncated before any compressed data is freestyled ta dat shit.
.IP "\(bu" 5
A Filehandle
.Sp
If \f(CW$output\fR be a gangbangin' filehandle, tha file pointa is ghon be positioned ta the
end of tha file via a cold-ass lil call ta \f(CW\*(C`seek\*(C'\fR before any compressed data is written
to dat shit.  Otherwise tha file pointa aint gonna be moved.
.RE
.RS 5
.Sp
This parameta defaults ta 0.
.RE
.ie n .IP """Merge => 0|1""" 5
.el .IP "\f(CWMerge => 0|1\fR" 5
.IX Item "Merge => 0|1"
This option is used ta compress input data n' append it ta a existing
compressed data stream up in \f(CW$output\fR. Da end result be a single compressed
data stream stored up in \f(CW$output\fR.
.Sp
It be a gangbangin' fatal error ta attempt ta use dis option when \f(CW$output\fR aint an
\&\s-1RFC 1952\s0 data stream.
.Sp
There is a fuckin shitload of other limitations wit tha \f(CW\*(C`Merge\*(C'\fR option:
.RS 5
.IP "1." 5
This module need ta done been built wit zlib 1.2.1 or betta ta work fo' realz. A
fatal error is ghon be thrown if \f(CW\*(C`Merge\*(C'\fR is used wit a olda version of
zlib.
.IP "2." 5
If \f(CW$output\fR be a gangbangin' file or a gangbangin' filehandle, it must be seekable.
.RE
.RS 5
.Sp
This parameta defaults ta 0.
.RE
.IP "\-Level" 5
.IX Item "-Level"
Defines tha compression level used by zlib. Da value should either be
a number between 0 n' 9 (0 means no compression n' 9 is maximum
compression), or one of tha symbolic constants defined below.
.Sp
.Vb 4
\&   Z_NO_COMPRESSION
\&   Z_BEST_SPEED
\&   Z_BEST_COMPRESSION
\&   Z_DEFAULT_COMPRESSION
.Ve
.Sp
Da default is Z_DEFAULT_COMPRESSION.
.Sp
Note, these constants is not imported by \f(CW\*(C`IO::Compress::Gzip\*(C'\fR by default.
.Sp
.Vb 3
\&    use IO::Compress::Gzip qw(:strategy);
\&    use IO::Compress::Gzip qw(:constants);
\&    use IO::Compress::Gzip qw(:all);
.Ve
.IP "\-Strategy" 5
.IX Item "-Strategy"
Defines tha game used ta tune tha compression. I aint talkin' bout chicken n' gravy biatch. Use one of tha symbolic
constants defined below.
.Sp
.Vb 5
\&   Z_FILTERED
\&   Z_HUFFMAN_ONLY
\&   Z_RLE
\&   Z_FIXED
\&   Z_DEFAULT_STRATEGY
.Ve
.Sp
Da default is Z_DEFAULT_STRATEGY.
.ie n .IP """Minimal => 0|1""" 5
.el .IP "\f(CWMinimal => 0|1\fR" 5
.IX Item "Minimal => 0|1"
If specified, dis option will force tha creation of tha smallest possible
compliant gzip header (which is exactly 10 bytes long) as defined in
\&\s-1RFC 1952.\s0
.Sp
See tha section titled \*(L"Compliance\*(R" up in \s-1RFC 1952\s0 fo' a thugged-out definizzle 
of tha joints used fo' tha fieldz up in tha gzip header.
.Sp
All other parametas dat control tha content of tha gzip header will
be ignored if dis parameta is set ta 1.
.Sp
This parameta defaults ta 0.
.ie n .IP """Comment => $comment""" 5
.el .IP "\f(CWComment => $comment\fR" 5
.IX Item "Comment => $comment"
Stores tha contentz of \f(CW$comment\fR up in tha \s-1COMMENT\s0 field in
the gzip header.
By default, no comment field is freestyled ta tha gzip file.
.Sp
If tha \f(CW\*(C`\-Strict\*(C'\fR option is enabled, tha comment can only consist of \s-1ISO
8859\-1\s0 charactas plus line feed.
.Sp
If tha \f(CW\*(C`\-Strict\*(C'\fR option is disabled, tha comment field can contain any
characta except \s-1NULL.\s0 If any null charactas is present, tha field
will be truncated all up in tha straight-up original gangsta \s-1NULL.\s0
.ie n .IP """Name => $string""" 5
.el .IP "\f(CWName => $string\fR" 5
.IX Item "Name => $string"
Stores tha contentz of \f(CW$string\fR up in tha gzip \s-1NAME\s0 header field. Y'all KNOW dat shit, muthafucka! If
\&\f(CW\*(C`Name\*(C'\fR aint specified, no gzip \s-1NAME\s0 field is ghon be pimped.
.Sp
If tha \f(CW\*(C`\-Strict\*(C'\fR option is enabled, \f(CW$string\fR can only consist of \s-1ISO
8859\-1\s0 characters.
.Sp
If \f(CW\*(C`\-Strict\*(C'\fR is disabled, then \f(CW$string\fR can contain any character
except \s-1NULL.\s0 If any null charactas is present, tha field will be
truncated all up in tha straight-up original gangsta \s-1NULL.\s0
.ie n .IP """Time => $number""" 5
.el .IP "\f(CWTime => $number\fR" 5
.IX Item "Time => $number"
Sets tha \s-1MTIME\s0 field up in tha gzip header ta \f(CW$number\fR.
.Sp
This field defaults ta tha time tha \f(CW\*(C`IO::Compress::Gzip\*(C'\fR object was pimped
if dis option aint specified.
.ie n .IP """TextFlag => 0|1""" 5
.el .IP "\f(CWTextFlag => 0|1\fR" 5
.IX Item "TextFlag => 0|1"
This parameta controls tha settin of tha \s-1FLG.FTEXT\s0 bit up in tha gzip
header n' shit. Well shiiiit, it is used ta signal dat tha data stored up in tha gzip file/buffer
is probably text.
.Sp
Da default is 0.
.ie n .IP """HeaderCRC => 0|1""" 5
.el .IP "\f(CWHeaderCRC => 0|1\fR" 5
.IX Item "HeaderCRC => 0|1"
When legit dis parameta will set tha \s-1FLG.FHCRC\s0 bit ta 1 up in tha gzip header
and set tha \s-1CRC16\s0 header field ta tha \s-1CRC\s0 of tha complete gzip header
except tha \s-1CRC16\s0 field itself.
.Sp
\&\fBNote\fR dat gzip filez pimped wit tha \f(CW\*(C`HeaderCRC\*(C'\fR flag set ta 1 cannot
be read by most, if not all, of tha standard gunzip utilities, most
notably gzip version 1.2.4. Yo ass should therefore avoid rockin dis option if
you wanna maximize tha portabilitizzle of yo' gzip files.
.Sp
This parameta defaults ta 0.
.ie n .IP """OS_Code => $value""" 5
.el .IP "\f(CWOS_Code => $value\fR" 5
.IX Item "OS_Code => $value"
Stores \f(CW$value\fR up in tha gzip \s-1OS\s0 header field. Y'all KNOW dat shit, muthafucka! A number between 0 n' 255 is
valid.
.Sp
If not specified, dis parameta defaults ta tha \s-1OS\s0 code of tha Operating
System dis module was built on. I aint talkin' bout chicken n' gravy biatch. Da value 3 is used as a cold-ass lil catch-all fo' all
Unix variants n' unknown Operatin Systems.
.ie n .IP """ExtraField => $data""" 5
.el .IP "\f(CWExtraField => $data\fR" 5
.IX Item "ExtraField => $data"
This parameta allows additionizzle metadata ta be stored up in tha ExtraField in
the gzip header n' shiznit fo' realz. An \s-1RFC 1952\s0 compliant ExtraField consistz of zero or more
subfields. Each subfield consistz of a two byte header followed by the
subfield data.
.Sp
Da list of subfieldz can be supplied up in any of tha followin formats
.Sp
.Vb 12
\&    \-ExtraField => [$id1, $data1,
\&                    $id2, $data2,
\&                     ...
\&                   ]
\&    \-ExtraField => [ [$id1 => $data1],
\&                     [$id2 => $data2],
\&                     ...
\&                   ]
\&    \-ExtraField => { $id1 => $data1,
\&                     $id2 => $data2,
\&                     ...
\&                   }
.Ve
.Sp
Where \f(CW$id1\fR, \f(CW$id2\fR is two byte subfield \s-1ID\s0's. Da second byte of
the \s-1ID\s0 cannot be 0, unless tha \f(CW\*(C`Strict\*(C'\fR option has been disabled.
.Sp
If you use tha hash syntax, you have no control over tha order up in which
the ExtraSubFieldz is stored, plus you cannot have SubFieldz with
duplicate \s-1ID.\s0
.Sp
Alternatively tha list of subfieldz can by supplied as a scalar, thus
.Sp
.Vb 1
\&    \-ExtraField => $rawdata
.Ve
.Sp
If you use tha raw format, n' tha \f(CW\*(C`Strict\*(C'\fR option is enabled,
\&\f(CW\*(C`IO::Compress::Gzip\*(C'\fR will check dat \f(CW$rawdata\fR consistz of zero or more
conformant sub-fields. When \f(CW\*(C`Strict\*(C'\fR is disabled, \f(CW$rawdata\fR can
consist of any arbitrary byte stream.
.Sp
Da maximum size of tha Extra Field 65535 bytes.
.ie n .IP """ExtraFlags => $value""" 5
.el .IP "\f(CWExtraFlags => $value\fR" 5
.IX Item "ExtraFlags => $value"
Sets tha \s-1XFL\s0 byte up in tha gzip header ta \f(CW$value\fR.
.Sp
If dis option aint present, tha value stored up in \s-1XFL\s0 field will be
determined by tha settin of tha \f(CW\*(C`Level\*(C'\fR option.
.Sp
If \f(CW\*(C`Level => Z_BEST_SPEED\*(C'\fR has been specified then \s-1XFL\s0 is set ta 2.
If \f(CW\*(C`Level => Z_BEST_COMPRESSION\*(C'\fR has been specified then \s-1XFL\s0 is set ta 4.
Otherwise \s-1XFL\s0 is set ta 0.
.ie n .IP """Strict => 0|1""" 5
.el .IP "\f(CWStrict => 0|1\fR" 5
.IX Item "Strict => 0|1"
\&\f(CW\*(C`Strict\*(C'\fR will optionally five-o tha joints supplied wit other options
to ensure they is compliant wit \s-1RFC1952.\s0
.Sp
This option is enabled by default.
.Sp
If \f(CW\*(C`Strict\*(C'\fR is enabled tha followin behaviour is ghon be policed:
.RS 5
.IP "\(bu" 5
Da value supplied wit tha \f(CW\*(C`Name\*(C'\fR option can only contain \s-1ISO 8859\-1\s0
characters.
.IP "\(bu" 5
Da value supplied wit tha \f(CW\*(C`Comment\*(C'\fR option can only contain \s-1ISO 8859\-1\s0
charactas plus line-feed.
.IP "\(bu" 5
Da joints supplied wit tha \f(CW\*(C`\-Name\*(C'\fR n' \f(CW\*(C`\-Comment\*(C'\fR options cannot
contain multiple embedded nulls.
.IP "\(bu" 5
If a \f(CW\*(C`ExtraField\*(C'\fR option is specified n' it aint nuthin but a simple scalar,
it must conform ta tha sub-field structure as defined up in \s-1RFC 1952.\s0
.IP "\(bu" 5
If a \f(CW\*(C`ExtraField\*(C'\fR option is specified tha second byte of tha \s-1ID\s0 will be
checked up in each subfield ta ensure dat it do not contain tha reserved
value 0x00.
.RE
.RS 5
.Sp
When \f(CW\*(C`Strict\*(C'\fR is disabled tha followin behaviour is ghon be policed:
.IP "\(bu" 5
Da value supplied wit \f(CW\*(C`\-Name\*(C'\fR option can contain
any characta except \s-1NULL.\s0
.IP "\(bu" 5
Da value supplied wit \f(CW\*(C`\-Comment\*(C'\fR option can contain any character
except \s-1NULL.\s0
.IP "\(bu" 5
Da joints supplied wit tha \f(CW\*(C`\-Name\*(C'\fR n' \f(CW\*(C`\-Comment\*(C'\fR options can contain
multiple embedded nulls. Da strang freestyled ta tha gzip header will
consist of tha charactas up ta yo, but not including, tha straight-up original gangsta embedded
\&\s-1NULL.\s0
.IP "\(bu" 5
If a \f(CW\*(C`ExtraField\*(C'\fR option is specified n' it aint nuthin but a simple scalar, the
structure aint gonna be checked. Y'all KNOW dat shit, muthafucka! Da only error is if tha length is too big.
.IP "\(bu" 5
Da \s-1ID\s0 header up in a \f(CW\*(C`ExtraField\*(C'\fR sub-field can consist of any two bytes.
.RE
.RS 5
.RE
.SS "Examples"
.IX Subsection "Examples"
\&\s-1TODO\s0
.SH "Methods"
.IX Header "Methods"
.SS "print"
.IX Subsection "print"
Usage is
.PP
.Vb 2
\&    $z\->print($data)
\&    print $z $data
.Ve
.PP
Compresses n' outputs tha contentz of tha \f(CW$data\fR parameter n' shit. This
has tha same ol' dirty behaviour as tha \f(CW\*(C`print\*(C'\fR built-in.
.PP
Returns legit if successful.
.SS "printf"
.IX Subsection "printf"
Usage is
.PP
.Vb 2
\&    $z\->printf($format, $data)
\&    printf $z $format, $data
.Ve
.PP
Compresses n' outputs tha contentz of tha \f(CW$data\fR parameter.
.PP
Returns legit if successful.
.SS "syswrite"
.IX Subsection "syswrite"
Usage is
.PP
.Vb 3
\&    $z\->syswrite $data
\&    $z\->syswrite $data, $length
\&    $z\->syswrite $data, $length, $offset
.Ve
.PP
Compresses n' outputs tha contentz of tha \f(CW$data\fR parameter.
.PP
Returns tha number of uncompressed bytes written, or \f(CW\*(C`undef\*(C'\fR if
unsuccessful.
.SS "write"
.IX Subsection "write"
Usage is
.PP
.Vb 3
\&    $z\->write $data
\&    $z\->write $data, $length
\&    $z\->write $data, $length, $offset
.Ve
.PP
Compresses n' outputs tha contentz of tha \f(CW$data\fR parameter.
.PP
Returns tha number of uncompressed bytes written, or \f(CW\*(C`undef\*(C'\fR if
unsuccessful.
.SS "flush"
.IX Subsection "flush"
Usage is
.PP
.Vb 2
\&    $z\->flush;
\&    $z\->flush($flush_type);
.Ve
.PP
Flushes any pendin compressed data ta tha output file/buffer.
.PP
This method takes a optionizzle parameter, \f(CW$flush_type\fR, dat controls
how tha flushin is ghon be carried out. By default tha \f(CW$flush_type\fR
used is \f(CW\*(C`Z_FINISH\*(C'\fR. Other valid joints fo' \f(CW$flush_type\fR are
\&\f(CW\*(C`Z_NO_FLUSH\*(C'\fR, \f(CW\*(C`Z_SYNC_FLUSH\*(C'\fR, \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR n' \f(CW\*(C`Z_BLOCK\*(C'\fR. Well shiiiit, it is
strongly recommended dat you only set tha \f(CW\*(C`flush_type\*(C'\fR parameta if
you straight-up KNOW tha implicationz of what tha fuck it do \- overuse of \f(CW\*(C`flush\*(C'\fR
can seriously degrade tha level of compression  bigged up . Y'all KNOW dat shit, muthafucka! See tha \f(CW\*(C`zlib\*(C'\fR
documentation fo' details.
.PP
Returns legit on success.
.SS "tell"
.IX Subsection "tell"
Usage is
.PP
.Vb 2
\&    $z\->tell()
\&    tell $z
.Ve
.PP
Returns tha uncompressed file offset.
.SS "eof"
.IX Subsection "eof"
Usage is
.PP
.Vb 2
\&    $z\->eof();
\&    eof($z);
.Ve
.PP
Returns legit if tha \f(CW\*(C`close\*(C'\fR method has been called.
.SS "seek"
.IX Subsection "seek"
.Vb 2
\&    $z\->seek($position, $whence);
\&    seek($z, $position, $whence);
.Ve
.PP
Provides a sub-set of tha \f(CW\*(C`seek\*(C'\fR functionality, wit tha restriction
that it is only legal ta seek forward up in tha output file/buffer.
It be a gangbangin' fatal error ta attempt ta seek backward.
.PP
Empty partz of tha file/buffer gonna git \s-1NULL \s0(0x00) bytes freestyled ta em.
.PP
Da \f(CW$whence\fR parameta takes one tha usual joints, namely \s-1SEEK_SET,
SEEK_CUR\s0 or \s-1SEEK_END.\s0
.PP
Returns 1 on success, 0 on failure.
.SS "binmode"
.IX Subsection "binmode"
Usage is
.PP
.Vb 2
\&    $z\->binmode
\&    binmode $z ;
.Ve
.PP
This be a noop provided fo' completeness.
.SS "opened"
.IX Subsection "opened"
.Vb 1
\&    $z\->opened()
.Ve
.PP
Returns legit if tha object currently refers ta a opened file/buffer.
.SS "autoflush"
.IX Subsection "autoflush"
.Vb 2
\&    mah $prev = $z\->autoflush()
\&    mah $prev = $z\->autoflush(EXPR)
.Ve
.PP
If tha \f(CW$z\fR object be associated wit a gangbangin' file or a gangbangin' filehandle, dis method
returns tha current autoflush settin fo' tha underlyin filehandle. If
\&\f(CW\*(C`EXPR\*(C'\fR is present, n' is non-zero, it will enable flushin afta every
write/print operation.
.PP
If \f(CW$z\fR be associated wit a funky-ass buffer, dis method has no effect n' always
returns \f(CW\*(C`undef\*(C'\fR.
.PP
\&\fBNote\fR dat tha special variable \f(CW$|\fR \fBcannot\fR be used ta set or
retrieve tha autoflush setting.
.SS "input_line_number"
.IX Subsection "input_line_number"
.Vb 2
\&    $z\->input_line_number()
\&    $z\->input_line_number(EXPR)
.Ve
.PP
This method always returns \f(CW\*(C`undef\*(C'\fR when compressing.
.SS "fileno"
.IX Subsection "fileno"
.Vb 2
\&    $z\->fileno()
\&    fileno($z)
.Ve
.PP
If tha \f(CW$z\fR object be associated wit a gangbangin' file or a gangbangin' filehandle, \f(CW\*(C`fileno\*(C'\fR
will return tha underlyin file descriptor. Shiiit, dis aint no joke. Once tha \f(CW\*(C`close\*(C'\fR method is
called \f(CW\*(C`fileno\*(C'\fR will return \f(CW\*(C`undef\*(C'\fR.
.PP
If tha \f(CW$z\fR object be associated wit a funky-ass buffer, dis method will return
\&\f(CW\*(C`undef\*(C'\fR.
.SS "close"
.IX Subsection "close"
.Vb 2
\&    $z\->close() ;
\&    close $z ;
.Ve
.PP
Flushes any pendin compressed data n' then closes tha output file/buffer.
.PP
For most versionz of Perl dis method is ghon be automatically invoked if
the IO::Compress::Gzip object is destroyed (either explicitly or by the
variable wit tha reference ta tha object goin outta scope). The
exceptions is Perl versions 5.005 all up in 5.00504 n' 5.8.0. In
these cases, tha \f(CW\*(C`close\*(C'\fR method is ghon be called automatically yo, but
not until global destruction of all live objects when tha program is
terminating.
.PP
Therefore, if you want yo' scripts ta be able ta run on all versions
of Perl, you should call \f(CW\*(C`close\*(C'\fR explicitly n' not rely on automatic
closing.
.PP
Returns legit on success, otherwise 0.
.PP
If tha \f(CW\*(C`AutoClose\*(C'\fR option has been enabled when tha IO::Compress::Gzip
object was pimped, n' tha object be associated wit a gangbangin' file, the
underlyin file will also be closed.
.SS "newStream([\s-1OPTS\s0])"
.IX Subsection "newStream([OPTS])"
Usage is
.PP
.Vb 1
\&    $z\->newStream( [OPTS] )
.Ve
.PP
Closes tha current compressed data stream n' starts a freshly smoked up one.
.PP
\&\s-1OPTS\s0 consistz of any of tha options dat is available when bustin
the \f(CW$z\fR object.
.PP
See tha \*(L"Constructor Options\*(R" section fo' mo' details.
.SS "deflateParams"
.IX Subsection "deflateParams"
Usage is
.PP
.Vb 1
\&    $z\->deflateParams
.Ve
.PP
\&\s-1TODO\s0
.SH "Importing"
.IX Header "Importing"
A number of symbolic constants is required by some methodz up in 
\&\f(CW\*(C`IO::Compress::Gzip\*(C'\fR. None is imported by default.
.IP ":all" 5
.IX Item ":all"
Imports \f(CW\*(C`gzip\*(C'\fR, \f(CW$GzipError\fR n' all symbolic
constants dat can be used by \f(CW\*(C`IO::Compress::Gzip\*(C'\fR. Right back up in yo muthafuckin ass. Same as bustin this
.Sp
.Vb 1
\&    use IO::Compress::Gzip qw(gzip $GzipError :constants) ;
.Ve
.IP ":constants" 5
.IX Item ":constants"
Import all symbolic constants, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Same as bustin this
.Sp
.Vb 1
\&    use IO::Compress::Gzip qw(:flush :level :strategy) ;
.Ve
.IP ":flush" 5
.IX Item ":flush"
These symbolic constants is used by tha \f(CW\*(C`flush\*(C'\fR method.
.Sp
.Vb 6
\&    Z_NO_FLUSH
\&    Z_PARTIAL_FLUSH
\&    Z_SYNC_FLUSH
\&    Z_FULL_FLUSH
\&    Z_FINISH
\&    Z_BLOCK
.Ve
.IP ":level" 5
.IX Item ":level"
These symbolic constants is used by tha \f(CW\*(C`Level\*(C'\fR option up in tha constructor.
.Sp
.Vb 4
\&    Z_NO_COMPRESSION
\&    Z_BEST_SPEED
\&    Z_BEST_COMPRESSION
\&    Z_DEFAULT_COMPRESSION
.Ve
.IP ":strategy" 5
.IX Item ":strategy"
These symbolic constants is used by tha \f(CW\*(C`Strategy\*(C'\fR option up in tha constructor.
.Sp
.Vb 5
\&    Z_FILTERED
\&    Z_HUFFMAN_ONLY
\&    Z_RLE
\&    Z_FIXED
\&    Z_DEFAULT_STRATEGY
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Apache::GZip Revisited"
.IX Subsection "Apache::GZip Revisited"
See IO::Compress::FAQ
.SS "Workin wit Net::FTP"
.IX Subsection "Workin wit Net::FTP"
See IO::Compress::FAQ
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Compress::Zlib, IO::Uncompress::Gunzip, IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate, IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress
.PP
IO::Compress::FAQ
.PP
File::GlobMapper, Archive::Zip,
Archive::Tar,
IO::Zlib
.PP
For \s-1RFC 1950, 1951\s0 n' 1952 peep 
\&\fIhttp://www.faqs.org/rfcs/rfc1950.html\fR,
\&\fIhttp://www.faqs.org/rfcs/rfc1951.html\fR and
\&\fIhttp://www.faqs.org/rfcs/rfc1952.html\fR
.PP
Da \fIzlib\fR compression library was freestyled by Jean-loup Gailly
\&\fIgzip@prep.ai.mit.edu\fR n' Mark Adla \fImadler@alumni.caltech.edu\fR.
.PP
Da primary joint fo' tha \fIzlib\fR compression library is
\&\fIhttp://www.zlib.org\fR.
.PP
Da primary joint fo' gzip is \fIhttp://www.gzip.org\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module was freestyled by Pizzle Marquess, \fIpmqs@cpan.org\fR.
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
See tha Chizzlez file.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2005\-2013 Pizzle Marquess fo' realz. All muthafuckin rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
