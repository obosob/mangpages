.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_get_error 3"
.TH SSL_get_error 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_get_error \- obtain result code fo' TLS/SSL I/O operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& int SSL_get_error(const SSL *ssl, int ret);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISSL_get_error()\fR returns a result code (suitable fo' tha C \*(L"switch\*(R"
statement) fo' a precedin call ta \fISSL_connect()\fR, \fISSL_accept()\fR, \fISSL_do_handshake()\fR,
\&\fISSL_read()\fR, \fISSL_peek()\fR, or \fISSL_write()\fR on \fBssl\fR.  Da value returned by
that \s-1TLS/SSL I/O\s0 function must be passed ta \fISSL_get_error()\fR up in parameter
\&\fBret\fR.
.PP
In addizzle ta \fBssl\fR n' \fBret\fR, \fISSL_get_error()\fR inspects the
current threadz OpenSSL error queue.  Thus, \fISSL_get_error()\fR must be
used up in tha same thread dat performed tha \s-1TLS/SSL I/O\s0 operation, n' no
other OpenSSL function calls should step tha fuck up in between. I aint talkin' bout chicken n' gravy biatch.  Da current
threadz error queue must be empty before tha \s-1TLS/SSL I/O\s0 operation is
attempted, or \fISSL_get_error()\fR aint gonna work reliably.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
Da followin return joints can currently occur:
.IP "\s-1SSL_ERROR_NONE\s0" 4
.IX Item "SSL_ERROR_NONE"
Da \s-1TLS/SSL I/O\s0 operation completed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This result code is returned
if n' only if \fBret > 0\fR.
.IP "\s-1SSL_ERROR_ZERO_RETURN\s0" 4
.IX Item "SSL_ERROR_ZERO_RETURN"
Da \s-1TLS/SSL\s0 connection has been closed. Y'all KNOW dat shit, muthafucka!  If tha protocol version is \s-1SSL 3.0\s0
or \s-1TLS 1.0,\s0 dis result code is returned only if a cold-ass lil closure
alert has occurred up in tha protocol, i.e. if tha connection has been
closed cleanly. Note dat up in dis case \fB\s-1SSL_ERROR_ZERO_RETURN\s0\fR
does not necessarily indicate dat tha underlyin transport
has been closed.
.IP "\s-1SSL_ERROR_WANT_READ, SSL_ERROR_WANT_WRITE\s0" 4
.IX Item "SSL_ERROR_WANT_READ, SSL_ERROR_WANT_WRITE"
Da operation did not complete; tha same \s-1TLS/SSL I/O\s0 function should be
called again n' again n' again later n' shit.  If, by then, tha underlyin \fB\s-1BIO\s0\fR has data
available fo' readin (if tha result code is \fB\s-1SSL_ERROR_WANT_READ\s0\fR)
or allows freestylin data (\fB\s-1SSL_ERROR_WANT_WRITE\s0\fR), then some \s-1TLS/SSL\s0
protocol progress will take place, i.e. at least part of a \s-1TLS/SSL\s0
record is ghon be read or written. I aint talkin' bout chicken n' gravy biatch.  Note dat tha retry may again n' again n' again lead to
a \fB\s-1SSL_ERROR_WANT_READ\s0\fR or \fB\s-1SSL_ERROR_WANT_WRITE\s0\fR condition.
There is no fixed upper limit fo' tha number of iterations that
may be necessary until progress becomes visible at application
protocol level.
.Sp
For socket \fB\s-1BIO\s0\fRs (e.g. when \fISSL_set_fd()\fR was used), \fIselect()\fR or
\&\fIpoll()\fR on tha underlyin socket can be used ta smoke up when the
\&\s-1TLS/SSL I/O\s0 function should be retried.
.Sp
Caveat: Any \s-1TLS/SSL I/O\s0 function can lead ta either of
\&\fB\s-1SSL_ERROR_WANT_READ\s0\fR n' \fB\s-1SSL_ERROR_WANT_WRITE\s0\fR.  In particular,
\&\fISSL_read()\fR or \fISSL_peek()\fR may wanna write data n' \fISSL_write()\fR may want
to read data.  This is mainly cuz \s-1TLS/SSL\s0 handshakes may occur at any
time durin tha protocol (initiated by either tha client or tha server);
\&\fISSL_read()\fR, \fISSL_peek()\fR, n' \fISSL_write()\fR will handle any pendin handshakes.
.IP "\s-1SSL_ERROR_WANT_CONNECT, SSL_ERROR_WANT_ACCEPT\s0" 4
.IX Item "SSL_ERROR_WANT_CONNECT, SSL_ERROR_WANT_ACCEPT"
Da operation did not complete; tha same \s-1TLS/SSL I/O\s0 function should be
called again n' again n' again later n' shit. Da underlyin \s-1BIO\s0 was not connected yet ta tha peer
and tha call would block up in \fIconnect()\fR/\fIaccept()\fR. Da \s-1SSL\s0 function should be
called again n' again n' again when tha connection is established. Y'all KNOW dat shit, muthafucka! These lyrics can only
appear wit a \fIBIO_s_connect()\fR or \fIBIO_s_accept()\fR \s-1BIO,\s0 respectively.
In order ta smoke up, when tha connection has been successfully established,
on nuff platforms \fIselect()\fR or \fIpoll()\fR fo' freestylin on tha socket file descriptor
can be used.
.IP "\s-1SSL_ERROR_WANT_X509_LOOKUP\s0" 4
.IX Item "SSL_ERROR_WANT_X509_LOOKUP"
Da operation did not complete cuz a application callback set by
\&\fISSL_CTX_set_client_cert_cb()\fR has axed ta be called again.
Da \s-1TLS/SSL I/O\s0 function should be called again n' again n' again later.
Details depend on tha application.
.IP "\s-1SSL_ERROR_SYSCALL\s0" 4
.IX Item "SSL_ERROR_SYSCALL"
Some I/O error occurred. Y'all KNOW dat shit, muthafucka!  Da OpenSSL error queue may contain more
information on tha error. Shiiit, dis aint no joke.  If tha error queue is empty
(i.e. \fIERR_get_error()\fR returns 0), \fBret\fR can be used ta smoke up more
about tha error: If \fBret == 0\fR, a \s-1EOF\s0 was observed dat violates
the protocol.  If \fBret == \-1\fR, tha underlyin \fB\s-1BIO\s0\fR reported an
I/O error (for socket I/O on Unix systems, consult \fBerrno\fR fo' details).
.IP "\s-1SSL_ERROR_SSL\s0" 4
.IX Item "SSL_ERROR_SSL"
A failure up in tha \s-1SSL\s0 library occurred, probably a protocol error. Shiiit, dis aint no joke.  The
OpenSSL error queue gotz nuff mo' shiznit on tha error.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIssl\fR\|(3), \fIerr\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fISSL_get_error()\fR was added up in SSLeay 0.8.
