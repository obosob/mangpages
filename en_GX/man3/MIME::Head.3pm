.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MIME::Head 3"
.TH MIME::Head 3 "2013-11-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME::Head \- MIME message header (a subclass of Mail::Header)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Before readin further, you should peep MIME::Tools ta make shizzle that
you KNOW where dis module fits tha fuck into tha grand scheme of thangs.
Go on, do it now, nahmeean, biatch?  I be bout ta wait.
.PP
Ready, biatch?  Ok...
.SS "Construction"
.IX Subsection "Construction"
.Vb 4
\&    ### Smoke a new, empty header, n' populate it manually:
\&    $head = MIME::Head\->new;
\&    $head\->replace(\*(Aqcontent\-type\*(Aq, \*(Aqtext/plain; charset=US\-ASCII\*(Aq);
\&    $head\->replace(\*(Aqcontent\-length\*(Aq, $len);
\&
\&    ### Parse a freshly smoked up header from a gangbangin' filehandle:
\&    $head = MIME::Head\->read(\e*STDIN);
\&
\&    ### Parse a freshly smoked up header from a gangbangin' file, or a readable pipe:
\&    $testhead = MIME::Head\->from_file("/tmp/test.hdr");
\&    $a_b_head = MIME::Head\->from_file("cat a.hdr b.hdr |");
.Ve
.SS "Output"
.IX Subsection "Output"
.Vb 2
\&    ### Output ta filehandle:
\&    $head\->print(\e*STDOUT);
\&
\&    ### Output as string:
\&    print STDOUT $head\->as_string;
\&    print STDOUT $head\->stringify;
.Ve
.SS "Gettin field contents"
.IX Subsection "Gettin field contents"
.Vb 2
\&    ### Is dis a reply?
\&    $is_reply = 1 if ($head\->get(\*(AqSubject\*(Aq) =~ /^Re: /);
\&
\&    ### Git receipt shiznit:
\&    print "Last received from: ", $head\->get(\*(AqReceived\*(Aq, 0);
\&    @all_received = $head\->get(\*(AqReceived\*(Aq);
\&
\&    ### Print tha subject, or tha empty strang if none:
\&    print "Subject: ", $head\->get(\*(AqSubject\*(Aq,0);
\&
\&    ### Too nuff hops, biatch?  Count \*(Aqem n' see!
\&    if ($head\->count(\*(AqReceived\*(Aq) > 5) { ...
\&
\&    ### Test whether a given field exists
\&    warn "missin subject!" if (! $head\->count(\*(Aqsubject\*(Aq));
.Ve
.SS "Settin field contents"
.IX Subsection "Settin field contents"
.Vb 2
\&    ### Declare dis ta be a HTML header:
\&    $head\->replace(\*(AqContent\-type\*(Aq, \*(Aqtext/html\*(Aq);
.Ve
.SS "Manipulatin field contents"
.IX Subsection "Manipulatin field contents"
.Vb 2
\&    ### Git rid of internal newlines up in fields:
\&    $head\->unfold;
\&
\&    ### Decode any Q\- or B\-encoded\-text up in fieldz (DEPRECATED):
\&    $head\->decode;
.Ve
.SS "Gettin high-level \s-1MIME\s0 shiznit"
.IX Subsection "Gettin high-level MIME shiznit"
.Vb 4
\&    ### Get/set a given MIME attribute:
\&    unless ($charset = $head\->mime_attr(\*(Aqcontent\-type.charset\*(Aq)) {
\&        $head\->mime_attr("content\-type.charset" => "US\-ASCII");
\&    }
\&
\&    ### Da content type (e.g., "text/html"):
\&    $mime_type     = $head\->mime_type;
\&
\&    ### Da content transfer encodin (e.g., "quoted\-printable"):
\&    $mime_encodin = $head\->mime_encoding;
\&
\&    ### Da recommended name when extracted:
\&    $file_name     = $head\->recommended_filename;
\&
\&    ### Da boundary text, fo' multipart lyrics:
\&    $boundary      = $head\->multipart_boundary;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A class fo' parsin up in n' manipulatin \s-1RFC\-822\s0 message headers, with
some methodz geared towardz standard (and not so standard) \s-1MIME\s0 fields
as specified up in tha various \fIMultipurpose Internizzle Mail Extensions\fR
RFCs (startin wit \s-1RFC 2045\s0)
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
.SS "Creation, input, n' output"
.IX Subsection "Creation, input, n' output"
.IP "new [\s-1ARG\s0],[\s-1OPTIONS\s0]" 4
.IX Item "new [ARG],[OPTIONS]"
\&\fIClass method, inherited.\fR
Creates a freshly smoked up header object.  Arguments is tha same as dem up in the
superclass.
.IP "from_file \s-1EXPR,OPTIONS\s0" 4
.IX Item "from_file EXPR,OPTIONS"
\&\fIClass or instizzle method\fR.
For convenience, you can use dis ta parse a header object up in from \s-1EXPR,\s0
which may straight-up be any expression dat can be busted ta \fIopen()\fR so as to
return a readable filehandle.  Da \*(L"file\*(R" is ghon be opened, read, n' then
closed:
.Sp
.Vb 2
\&    ### Smoke a freshly smoked up header by parsin up in a gangbangin' file:
\&    mah $head = MIME::Head\->from_file("/tmp/test.hdr");
.Ve
.Sp
Since dis method can function as either a cold-ass lil class constructor \fIor\fR
an instizzle initializer, tha above is exactly equivalent to:
.Sp
.Vb 2
\&    ### Smoke a freshly smoked up header by parsin up in a gangbangin' file:
\&    mah $head = MIME::Head\->new\->from_file("/tmp/test.hdr");
.Ve
.Sp
On success, tha object is ghon be returned; on failure, tha undefined value.
.Sp
Da \s-1OPTIONS\s0 is tha same as up in \fInew()\fR, n' is passed tha fuck into \fInew()\fR
if dis is invoked as a cold-ass lil class method.
.Sp
\&\fBNote:\fR This is straight-up just a cold-ass lil convenience front-end onto \f(CW\*(C`read()\*(C'\fR,
provided mostly fo' backwards-compatibilitizzle wit MIME-parser 1.0.
.IP "read \s-1FILEHANDLE\s0" 4
.IX Item "read FILEHANDLE"
\&\fIInstizzle (or class) method.\fR
This initializes a header object by readin it up in from a \s-1FILEHANDLE,\s0
until tha terminatin blank line is encountered.
A syntax error or end-of-stream will also halt processing.
.Sp
Supply dis routine wit a reference ta a gangbangin' filehandle glob; e.g., \f(CW\*(C`\e*STDIN\*(C'\fR:
.Sp
.Vb 2
\&    ### Smoke a freshly smoked up header by parsin up in STDIN:
\&    $head\->read(\e*STDIN);
.Ve
.Sp
On success, tha self object is ghon be returned; on failure, a gangbangin' false value.
.Sp
\&\fBNote:\fR up in tha \s-1MIME\s0 ghetto, it is perfectly legal fo' a header ta be
empty, consistin of not a god damn thang but tha terminatin blank line.  Thus,
we can't just use tha formula dat \*(L"no tags equals error\*(R".
.Sp
\&\fBWarning:\fR az of tha time of dis writing, Mail::Header::read did not flag
either syntax errors or unexpected end-of-file conditions (an \s-1EOF\s0
before tha terminatin blank line).  MIME::ParserBase takes this
into account.
.SS "Getting/settin fields"
.IX Subsection "Getting/settin fields"
Da followin is methodz related ta retrievin n' modifyin tha header
fields.  Some is inherited from Mail::Header yo, but I've kept the
documentation round fo' convenience.
.IP "add \s-1TAG,TEXT\s0,[\s-1INDEX\s0]" 4
.IX Item "add TAG,TEXT,[INDEX]"
\&\fIInstizzle method, inherited.\fR
Add a freshly smoked up occurrence of tha field named \s-1TAG,\s0 given by \s-1TEXT:\s0
.Sp
.Vb 3
\&    ### Add tha trace shiznit:
\&    $head\->add(\*(AqReceived\*(Aq,
\&               \*(Aqfrom eryq.pr.mcs.net by gonzo.net wit smtp\*(Aq);
.Ve
.Sp
Normally, tha freshly smoked up occurrence is ghon be \fIappended\fR ta tha existing
occurrences.  But fuck dat shiznit yo, tha word on tha street is dat if tha optionizzle \s-1INDEX\s0 argument is 0, then the
new occurrence is ghon be \fIprepended\fR.  If you wanna be \fIexplicit\fR
about appending, specify a \s-1INDEX\s0 of \-1.
.Sp
\&\fBWarning\fR: dis method always addz freshly smoked up occurrences; it don't overwrite
any existin occurrences... so if you just wanna \fIchange\fR tha value
of a gangbangin' field (bustin it if necessary), then you probably \fBdon't\fR wanna use
this method: consider rockin \f(CW\*(C`replace()\*(C'\fR instead.
.IP "count \s-1TAG\s0" 4
.IX Item "count TAG"
\&\fIInstizzle method, inherited.\fR
Returns tha number of occurrencez of a gangbangin' field; up in a funky-ass boolean context, this
 drops some lyrics ta you whether a given field exists:
.Sp
.Vb 2
\&    ### Was a "Subject:" field given?
\&    $subject_was_given = $head\->count(\*(Aqsubject\*(Aq);
.Ve
.Sp
Da \s-1TAG\s0 is treated up in a cold-ass lil case-insensitizzle manner.
This method returns some false value if tha field don't exist,
and some legit value if it do.
.IP "decode [\s-1FORCE\s0]" 4
.IX Item "decode [FORCE]"
\&\fIInstizzle method, \s-1DEPRECATED.\s0\fR
Go all up in all tha header fields, lookin fo' \s-1RFC 1522 / RFC 2047\s0 style
\&\*(L"Q\*(R" (quoted-printable, sort of) or \*(L"B\*(R" (base64) encoding, n' decode
them in-place.  Fellow Gangstas, you probably don't give a fuck what tha fuck tha hell
I be rappin' about.  Europeans, Russians, et al, you probably do.
\&\f(CW\*(C`:\-)\*(C'\fR.
.Sp
\&\fBThis method has been deprecated.\fR
See \*(L"decode_headers\*(R" up in MIME::Parser fo' tha full reasons.
If you straight-up must use it n' don't like tha warning, then
provide a \s-1FORCE:\s0
.Sp
.Vb 3
\&   "I_NEED_TO_FIX_THIS"
\&          Just shut tha fuck up n' do dat shit.  Not recommended.
\&          Provided only fo' dem playas whoz ass need ta keep oldschool scripts functioning.
\&
\&   "I_KNOW_WHAT_I_AM_DOING"
\&          Just shut tha fuck up n' do dat shit.  Not recommended.
\&          Provided fo' dem playas whoz ass REALLY know what tha fuck they is bustin.
.Ve
.Sp
\&\fBWhat dis method do.\fR
For a example, letz consider a valid email header you might get:
.Sp
.Vb 6
\&    From: =?US\-ASCII?Q?Keith_Moore?= <moore@cs.utk.edu>
\&    To: =?ISO\-8859\-1?Q?Keld_J=F8rn_Simonsen?= <keld@dkuug.dk>
\&    CC: =?ISO\-8859\-1?Q?Andr=E9_?= Pirard <PIRARD@vm1.ulg.ac.be>
\&    Subject: =?ISO\-8859\-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=
\&     =?ISO\-8859\-2?B?dSB1bmRlcnN0YW5kIHRoZSBleGFtcGxlLg==?=
\&     =?US\-ASCII?Q?.._cool!?=
.Ve
.Sp
That basically decodes ta (sorry, I can only approximate the
Latin charactas wit 7 bit sequences /o n' 'e):
.Sp
.Vb 4
\&    From: Keith Moore <moore@cs.utk.edu>
\&    To: Keld J/orn Simonsen <keld@dkuug.dk>
\&    CC: Andr\*(Aqe  Pirard <PIRARD@vm1.ulg.ac.be>
\&    Subject: If you can read dis you KNOW tha example... cool!
.Ve
.Sp
\&\fBNote:\fR currently, tha decodings is done without regard ta the
characta set: thus, tha Q\-encodin \f(CW\*(C`=F8\*(C'\fR is simply translated ta the
octet (hexadecimal \f(CW\*(C`F8\*(C'\fR), period. Y'all KNOW dat shit, muthafucka!  For piece-by-piece decoding
of a given field, you want tha array context of
\&\f(CW\*(C`MIME::Words::decode_mimewords()\*(C'\fR.
.Sp
\&\fBWarning:\fR tha \s-1CRLF+SPACE\s0 separator dat splits up long encoded lyrics
into shorta sequences (see tha Subject: example above) gets lost
when tha field is unfolded, n' so decodin afta unfoldin causes
a spurious space ta be left up in tha field.
\&\fI\s-1THEREFORE:\s0 if you goin ta decode, do so \s-1BEFORE\s0 unfolding!\fR
.Sp
This method returns tha self object.
.Sp
\&\fIThanks ta Kent Boortz fo' providin tha idea, n' tha baseline
RFC\-1522\-decodin code.\fR
.IP "delete \s-1TAG\s0,[\s-1INDEX\s0]" 4
.IX Item "delete TAG,[INDEX]"
\&\fIInstizzle method, inherited.\fR
Delete all occurrencez of tha field named \s-1TAG.\s0
.Sp
.Vb 3
\&    ### Remove some MIME shiznit:
\&    $head\->delete(\*(AqMIME\-Version\*(Aq);
\&    $head\->delete(\*(AqContent\-type\*(Aq);
.Ve
.IP "get \s-1TAG\s0,[\s-1INDEX\s0]" 4
.IX Item "get TAG,[INDEX]"
\&\fIInstizzle method, inherited.\fR
Git tha contentz of field \s-1TAG.\s0
.Sp
If a \fBnumeric \s-1INDEX\s0\fR is given, returns tha occurrence at dat index,
or undef if not present:
.Sp
.Vb 3
\&    ### Print tha straight-up original gangsta n' last \*(AqReceived:\*(Aq entries (explicitly):
\&    print "First, or most recent: ", $head\->get(\*(Aqreceived\*(Aq, 0);
\&    print "Last, or least recent: ", $head\->get(\*(Aqreceived\*(Aq,\-1);
.Ve
.Sp
If \fBno \s-1INDEX\s0\fR is given yo, but invoked up in a \fBscalar\fR context, then
\&\s-1INDEX\s0 simply defaults ta 0:
.Sp
.Vb 2
\&    ### Git tha straight-up original gangsta \*(AqReceived:\*(Aq entry (implicitly):
\&    mah $most_recent = $head\->get(\*(Aqreceived\*(Aq);
.Ve
.Sp
If \fBno \s-1INDEX\s0\fR is given, n' invoked up in a \fBarray\fR context, then
\&\fIall\fR occurrencez of tha field is returned:
.Sp
.Vb 2
\&    ### Git all \*(AqReceived:\*(Aq entries:
\&    mah @all_received = $head\->get(\*(Aqreceived\*(Aq);
.Ve
.Sp
\&\fB\s-1NOTE\s0\fR: Da header(s) returned may end wit a newline.  If you don't
want this, then \fBchomp\fR tha return value.
.IP "get_all \s-1FIELD\s0" 4
.IX Item "get_all FIELD"
\&\fIInstizzle method.\fR
Returns tha list of \fIall\fR occurrencez of tha field, or the
empty list if tha field aint present:
.Sp
.Vb 2
\&    ### How tha fuck done did it git here?
\&    @history = $head\->get_all(\*(AqReceived\*(Aq);
.Ve
.Sp
\&\fBNote:\fR I had originally experimented wit havin \f(CW\*(C`get()\*(C'\fR return all
occurrences when invoked up in a array context... but dat causes a shitload of
accidents when you git careless n' do shiznit like this:
.Sp
.Vb 1
\&    print "\eu$field: ", $head\->get($field);
.Ve
.Sp
It also made tha intuitizzle behaviour unclear if tha \s-1INDEX\s0 argument
was given up in a array context.  So I opted fo' a explicit approach
to askin fo' all occurrences.
.IP "print [\s-1OUTSTREAM\s0]" 4
.IX Item "print [OUTSTREAM]"
\&\fIInstizzle method, override.\fR
Print tha header up ta tha given \s-1OUTSTREAM,\s0 or tha currently-selected
filehandle if none.  Da \s-1OUTSTREAM\s0 may be a gangbangin' filehandle, or any object
that respondz ta a \fIprint()\fR message.
.Sp
Da override straight-up lets you print ta any object dat respondz to
a \fIprint()\fR method. Y'all KNOW dat shit, muthafucka!  This is vital fo' outputtin \s-1MIME\s0 entitizzles ta scalars.
.Sp
Also, it defaults ta tha \fIcurrently-selected\fR filehandle if none is given
(not \s-1STDOUT\s0!), so \fIplease\fR supply a gangbangin' filehandle ta prevent mad drama.
.IP "stringify" 4
.IX Item "stringify"
\&\fIInstizzle method.\fR
Return tha header as a string.  Yo ass can also invoke it as \f(CW\*(C`as_string\*(C'\fR.
.IP "unfold [\s-1FIELD\s0]" 4
.IX Item "unfold [FIELD]"
\&\fIInstizzle method, inherited.\fR
Unfold (remove newlines in) tha text of all occurrencez of tha given \s-1FIELD.\s0
If tha \s-1FIELD\s0 is omitted, \fIall\fR fieldz is unfolded.
Returns tha \*(L"self\*(R" object.
.SS "MIME-specific methods"
.IX Subsection "MIME-specific methods"
All of tha followin methodz extract shiznit from tha followin fields:
.PP
.Vb 3
\&    Content\-type
\&    Content\-transfer\-encoding
\&    Content\-disposition
.Ve
.PP
Be aware dat they do not just return tha raw contentz of dem fields,
and up in some cases they will fill up in sensible (I hope) default joints.
Use \f(CW\*(C`get()\*(C'\fR or \f(CW\*(C`mime_attr()\*(C'\fR if you need ta grab n' process the
raw field text.
.PP
\&\fBNote:\fR a shitload of these methodz is provided both as a cold-ass lil convenience and
for backwards-compatibilitizzle only, while others (like
\&\fIrecommended_filename()\fR) \fIreally do gotta be up in MIME::Head ta work
properly,\fR since they look fo' they value up in mo' than one field.
But fuck dat shiznit yo, tha word on tha street is dat if you know dat a value is restricted ta a single
field, you should straight-up use tha Mail::Field intercourse ta git dat shit.
.IP "mime_attr \s-1ATTR\s0,[\s-1VALUE\s0]" 4
.IX Item "mime_attr ATTR,[VALUE]"
A quick-and-easy intercourse ta set/get tha attributes up in structured
\&\s-1MIME\s0 fields:
.Sp
.Vb 3
\&    $head\->mime_attr("content\-type"         => "text/html");
\&    $head\->mime_attr("content\-type.charset" => "US\-ASCII");
\&    $head\->mime_attr("content\-type.name"    => "homepage.html");
.Ve
.Sp
This would cause tha final output ta look suttin' like this:
.Sp
.Vb 1
\&    Content\-type: text/html; charset=US\-ASCII; name="homepage.html"
.Ve
.Sp
Note dat tha special empty sub-field tag indicates tha anonymous
first sub-field.
.Sp
\&\fBGivin \s-1VALUE\s0 as undefined\fR will cause tha contentz of tha named subfield
to be deleted:
.Sp
.Vb 1
\&    $head\->mime_attr("content\-type.charset" => undef);
.Ve
.Sp
\&\fBSupplyin no \s-1VALUE\s0 argument\fR just returns tha attributez value,
or undefined if it aint there:
.Sp
.Vb 2
\&    $type = $head\->mime_attr("content\-type");      ### text/html
\&    $name = $head\->mime_attr("content\-type.name"); ### homepage.html
.Ve
.Sp
In all cases, tha new/current value is returned.
.IP "mime_encoding" 4
.IX Item "mime_encoding"
\&\fIInstizzle method.\fR
Try \fIreal hard\fR ta determine tha content transfer encoding
(e.g., \f(CW"base64"\fR, \f(CW"binary"\fR), which is returned up in all-lowercase.
.Sp
If no encodin could be found, tha default of \f(CW"7bit"\fR is returned
I quote from \s-1RFC 2045\s0 section 6.1:
.Sp
.Vb 2
\&    This is tha default value \-\- dat is, "Content\-Transfer\-Encoding: 7BIT"
\&    be assumed if tha Content\-Transfer\-Encodin header field aint present.
.Ve
.Sp
I do one other form of fixup: \*(L"7_bit\*(R", \*(L"7\-bit\*(R", n' \*(L"7 bit\*(R" are
corrected ta \*(L"7bit\*(R"; likewise fo' \*(L"8bit\*(R".
.IP "mime_type [\s-1DEFAULT\s0]" 4
.IX Item "mime_type [DEFAULT]"
\&\fIInstizzle method.\fR
Try \f(CW\*(C`real hard\*(C'\fR ta determine tha content type (e.g., \f(CW"text/plain"\fR,
\&\f(CW"image/gif"\fR, \f(CW"x\-weird\-type"\fR, which is returned up in all-lowercase.
\&\*(L"Real hard\*(R" means dat if no content type could be found, tha default
(usually \f(CW"text/plain"\fR) is returned. Y'all KNOW dat shit, muthafucka!  From \s-1RFC 2045\s0 section 5.2:
.Sp
.Vb 3
\&   Default RFC 822 lyrics without a MIME Content\-Type header are
\&   taken by dis protocol ta be plain text up in tha US\-ASCII character
\&   set, which can be explicitly specified as:
\&
\&      Content\-type: text/plain; charset=us\-ascii
\&
\&   This default be assumed if no Content\-Type header field is specified.
.Ve
.Sp
Unless dis be a part of a \*(L"multipart/digest\*(R", up in which case
\&\*(L"message/rfc822\*(R" is tha default.  Note dat you can also \fIset\fR the
default yo, but you shouldn't: normally only tha \s-1MIME\s0 parser uses this
feature.
.IP "multipart_boundary" 4
.IX Item "multipart_boundary"
\&\fIInstizzle method.\fR
If dis be a header fo' a multipart message, return the
\&\*(L"encapsulation boundary\*(R" used ta separate tha parts, n' you can put dat on yo' toast.  Da boundary
is returned exactly as given up in tha \f(CW\*(C`Content\-type:\*(C'\fR field; that
is, tha leadin double-hyphen (\f(CW\*(C`\-\-\*(C'\fR) is \fInot\fR prepended.
.Sp
Well, \fIalmost\fR exactly... dis passage from \s-1RFC 2046\s0 dictates
that we remove any trailin spaces:
.Sp
.Vb 2
\&   If a funky-ass boundary appears ta end wit white space, tha white space
\&   must be presumed ta done been added by a gateway, n' must be deleted.
.Ve
.Sp
Returns undef (\fBnot\fR tha empty string) if either tha message is not
multipart or if there is no specified boundary.
.IP "recommended_filename" 4
.IX Item "recommended_filename"
\&\fIInstizzle method.\fR
Return tha recommended external filename.  This is used when
extractin tha data from tha \s-1MIME\s0 stream.  Da filename be always
returned as a strang up in Perlz internal format (the \s-1UTF8\s0 flag may be on!)
.Sp
Returns undef if no filename could be suggested.
.SH "NOTES"
.IX Header "NOTES"
.IP "Why have separate objects fo' tha entity, head, n' body?" 4
.IX Item "Why have separate objects fo' tha entity, head, n' body?"
See tha documentation fo' tha MIME-tools distribution
for tha rationale behind dis decision.
.IP "Why assume dat \s-1MIME\s0 headaz is email headers?" 4
.IX Item "Why assume dat MIME headaz is email headers?"
I quote from Achim Bohnet, whoz ass gave feedback on v.1.9 (I think
hez rockin tha word \*(L"header\*(R" where I would use \*(L"field\*(R"; e.g.,
to refer ta \*(L"Subject:\*(R", \*(L"Content-type:\*(R", etc.):
.Sp
.Vb 3
\&    There be also IMHO no requirement [for] MIME::Headz ta look
\&    like [email] headers; so ta speak, tha MIME::Head [simply stores]
\&    tha attributez of a cold-ass lil complex object, e.g.:
\&
\&        freshly smoked up MIME::Head type => "text/plain",
\&                       charset => ...,
\&                       disposizzle => ..., ... ;
.Ve
.Sp
I smoke up in principle yo, but (alas n' dammit) \s-1RFC 2045\s0 say otherwise.
\&\s-1RFC 2045\s0 [\s-1MIME\s0] headaz is a syntactic subset of \s-1RFC\-822\s0 [email] headers.
.Sp
In mah mindz eye, I peep a abstract class, call it MIME::Attrs, which do
what Achim suggests... so you could say:
.Sp
.Vb 3
\&     mah $attrs = freshly smoked up MIME::Attrs type => "text/plain",
\&                                 charset => ...,
\&                                 disposizzle => ..., ... ;
.Ve
.Sp
We could even make it a superclass of MIME::Head: dat way, MIME::Head
would gotta implement its intercourse, \fIand\fR allow itself ta be
initialized from a MIME::Attrs object.
.Sp
But fuck dat shiznit yo, tha word on tha street is dat when you read \s-1RFC 2045,\s0 you begin ta peep how tha fuck much \s-1MIME\s0 shiznit
is organized by its presence up in particular fields.  I imagine dat we'd
begin ta mirror tha structure of \s-1RFC 2045\s0 fieldz n' subfieldz ta such
a degree dat dis might not give our asses a tremendous bust over just
havin MIME::Head.
.ie n .IP "Why all dis ""occurrence"" n' ""index"" jazz, biatch?  Isn't every last muthafuckin field unique?" 4
.el .IP "Why all dis ``occurrence'' n' ``index'' jazz, biatch?  Isn't every last muthafuckin field unique?" 4
.IX Item "Why all dis occurrence n' index jazz, biatch? Isn't every last muthafuckin field unique?"
Aaaaaaaaaahh....no.
.Sp
Lookin at a typical mail message header, it is sooooooo temptin ta just
store tha fieldz as a hash of strings, one strang per hash entry.
Unfortunately, there be a tha lil matta of tha \f(CW\*(C`Received:\*(C'\fR field,
which (unlike \f(CW\*(C`From:\*(C'\fR, \f(CW\*(C`To:\*(C'\fR, etc.) will often have multiple
occurrences; e.g.:
.Sp
.Vb 10
\&    Received: from gsfc.nasa.gov by eryq.pr.mcs.net  wit smtp
\&        (Linux Smail3.1.28.1 #5) id m0tStZ7\-0007X4C;
\&         Thu, 21 Dec 95 16:34 CST
\&    Received: from rhine.gsfc.nasa.gov by gsfc.nasa.gov
\&         (5.65/Ultrix3.0\-C) id AA13596;
\&         Thu, 21 Dec 95 17:20:38 \-0500
\&    Received: (from eryq@localhost) by rhine.gsfc.nasa.gov
\&         (8.6.12/8.6.12) id RAA28069;
\&         Thu, 21 Dec 1995 17:27:54 \-0500
\&    Date: Thu, 21 Dec 1995 17:27:54 \-0500
\&    From: Eryq <eryq@rhine.gsfc.nasa.gov>
\&    Message\-Id: <199512212227.RAA28069@rhine.gsfc.nasa.gov>
\&    To: eryq@eryq.pr.mcs.net
\&    Subject: Stuff n' thangs
.Ve
.Sp
Da \f(CW\*(C`Received:\*(C'\fR field is used fo' tracin message routes, n' although
itz not generally used fo' anythang other than human debugging, I
didn't wanna inconvenience mah playas whoz ass straight-up wanted ta git at that
information.
.Sp
I also didn't wanna make dis a special case; afta all, who
knows what tha fuck other fieldz could have multiple occurrences up in the
future, biatch?  So, clearly, multiple entries had ta somehow be stored
multiple times... n' tha different occurrences had ta be retrievable.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::Header, Mail::Field, MIME::Words, MIME::Tools
.SH "AUTHOR"
.IX Header "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
Dizzy F. Right back up in yo muthafuckin ass. Skoll (dfs@roaringpenguin.com) http://www.roaringpenguin.com
.PP
All muthafuckin rights reserved. Y'all KNOW dat shit, muthafucka!  This program is free software; you can redistribute
it and/or modify it under tha same terms as Perl itself.
.PP
Da more-comprehensive filename extraction is courtesy of
Lee E. Brotzman, Advanced Data Solutions.
