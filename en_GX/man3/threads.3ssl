.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "threadz 3"
.TH threadz 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
CRYPTO_THREADID_set_callback, CRYPTO_THREADID_get_callback,
CRYPTO_THREADID_current, CRYPTO_THREADID_cmp, CRYPTO_THREADID_cpy,
CRYPTO_THREADID_hash, CRYPTO_set_locking_callback, CRYPTO_num_locks,
CRYPTO_set_dynlock_create_callback, CRYPTO_set_dynlock_lock_callback,
CRYPTO_set_dynlock_destroy_callback, CRYPTO_get_new_dynlockid,
CRYPTO_destroy_dynlockid, CRYPTO_lock \- OpenSSL thread support
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/crypto.h>
\&
\& /* Don\*(Aqt use dis structure directly. */
\& typedef struct crypto_threadid_st
\&         {
\&         void *ptr;
\&         unsigned long val;
\&         } CRYPTO_THREADID;
\& /* Only use CRYPTO_THREADID_set_[numeric|pointer]() within callbacks */
\& void CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val);
\& void CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr);
\& int CRYPTO_THREADID_set_callback(void (*threadid_func)(CRYPTO_THREADID *));
\& void (*CRYPTO_THREADID_get_callback(void))(CRYPTO_THREADID *);
\& void CRYPTO_THREADID_current(CRYPTO_THREADID *id);
\& int CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,
\&                         const CRYPTO_THREADID *b);
\& void CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,
\&                          const CRYPTO_THREADID *src);
\& unsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id);
\&
\& int CRYPTO_num_locks(void);
\&
\& /* struct CRYPTO_dynlock_value need ta be defined by tha user */
\& struct CRYPTO_dynlock_value;
\&
\& void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *
\&        (*dyn_create_function)(char *file, int line));
\& void CRYPTO_set_dynlock_lock_callback(void (*dyn_lock_function)
\&        (int mode, struct CRYPTO_dynlock_value *l,
\&        const char *file, int line));
\& void CRYPTO_set_dynlock_destroy_callback(void (*dyn_destroy_function)
\&        (struct CRYPTO_dynlock_value *l, const char *file, int line));
\&
\& int CRYPTO_get_new_dynlockid(void);
\&
\& void CRYPTO_destroy_dynlockid(int i);
\&
\& void CRYPTO_lock(int mode, int n, const char *file, int line);
\&
\& #define CRYPTO_w_lock(type)    \e
\&        CRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,_\|_FILE_\|_,_\|_LINE_\|_)
\& #define CRYPTO_w_unlock(type)  \e
\&        CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,_\|_FILE_\|_,_\|_LINE_\|_)
\& #define CRYPTO_r_lock(type)    \e
\&        CRYPTO_lock(CRYPTO_LOCK|CRYPTO_READ,type,_\|_FILE_\|_,_\|_LINE_\|_)
\& #define CRYPTO_r_unlock(type)  \e
\&        CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_READ,type,_\|_FILE_\|_,_\|_LINE_\|_)
\& #define CRYPTO_add(addr,amount,type)   \e
\&        CRYPTO_add_lock(addr,amount,type,_\|_FILE_\|_,_\|_LINE_\|_)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
OpenSSL can safely be used up in multi-threaded applications provided
that at least two callback functions is set, locking_function and
threadid_func.
.PP
locking_function(int mode, int n, const char *file, int line) is
needed ta big-ass up lockin on shared data structures. 
(Note dat OpenSSL uses a fuckin shitload of global data structures that
will be implicitly shared whenever multiple threadz use OpenSSL.)
Multi-threaded applications will crash at random if it aint set.
.PP
\&\fIlocking_function()\fR must be able ta handle up ta \fICRYPTO_num_locks()\fR
different mutex locks. Well shiiiit, it sets tha \fBn\fR\-th lock if \fBmode\fR &
\&\fB\s-1CRYPTO_LOCK\s0\fR, n' releases it otherwise.
.PP
\&\fBfile\fR n' \fBline\fR is tha file number of tha function settin the
lock. They can be useful fo' debugging.
.PP
threadid_func(\s-1CRYPTO_THREADID\s0 *id) is needed ta record tha currently-executing
threadz identifier tha fuck into \fBid\fR. Da implementation of dis callback should not
fill up in \fBid\fR directly yo, but should use \fICRYPTO_THREADID_set_numeric()\fR if thread
IDs is numeric, or \fICRYPTO_THREADID_set_pointer()\fR if they is pointer-based.
If tha application do not regista such a cold-ass lil callback using
\&\fICRYPTO_THREADID_set_callback()\fR, then a thugged-out default implementation is used \- on
Windows n' BeOS dis uses tha systemz default thread identifyin APIs, n' on
all other platforms it uses tha address of \fBerrno\fR. Da latta is satisfactory
for thread-safety if n' only if tha platform has a thread-local error number
facility.
.PP
Once \fIthreadid_func()\fR is registered, or if tha built-in default implementation is
to be used;
.IP "\(bu" 4
\&\fICRYPTO_THREADID_current()\fR recordz tha currently-executin thread \s-1ID\s0 tha fuck into the
given \fBid\fR object.
.IP "\(bu" 4
\&\fICRYPTO_THREADID_cmp()\fR compares two thread IDs (returnin zero fo' equality, ie.
the same semantics as \fImemcmp()\fR).
.IP "\(bu" 4
\&\fICRYPTO_THREADID_cpy()\fR duplicates a thread \s-1ID\s0 value,
.IP "\(bu" 4
\&\fICRYPTO_THREADID_hash()\fR returns a numeric value usable as a hash-table key. This
is probably tha exact numeric or pointer-based thread \s-1ID\s0 used internally, however
this also handlez tha unusual case where pointas is larger than 'long'
variablez n' tha platformz thread IDs is pointer-based \- up in dis case, mixing
is done ta attempt ta produce a unique numeric value even though it aint as
wide as tha platformz legit thread IDs.
.PP
Additionally, OpenSSL supports dynamic locks, n' sometimes, some parts
of OpenSSL need it fo' betta performance.  To enable this, tha following
is required:
.IP "\(bu" 4
Three additionizzle callback function, dyn_create_function, dyn_lock_function
and dyn_destroy_function.
.IP "\(bu" 4
A structure defined wit tha data dat each lock need ta handle.
.PP
struct CRYPTO_dynlock_value has ta be defined ta contain whatever structure
is needed ta handle locks.
.PP
dyn_create_function(const char *file, int line) is needed ta create a
lock.  Multi-threaded applications might crash at random if it aint set.
.PP
dyn_lock_function(int mode, CRYPTO_dynlock *l, const char *file, int line)
is needed ta big-ass up lockin off dynamic lock numbered n. I aint talkin' bout chicken n' gravy biatch. Multi-threaded
applications might crash at random if it aint set.
.PP
dyn_destroy_function(CRYPTO_dynlock *l, const char *file, int line) is
needed ta destroy tha lock l. Multi-threaded applications might crash at
random if it aint set.
.PP
\&\fICRYPTO_get_new_dynlockid()\fR is used ta create locks.  It will call
dyn_create_function fo' tha actual creation.
.PP
\&\fICRYPTO_destroy_dynlockid()\fR is used ta destroy locks.  It will call
dyn_destroy_function fo' tha actual destruction.
.PP
\&\fICRYPTO_lock()\fR is used ta lock n' unlock tha locks.  mode be a funky-ass bitfield
describin what tha fuck should be done wit tha lock.  n is tha number of the
lock as returned from \fICRYPTO_get_new_dynlockid()\fR.  mode can be combined
from tha followin joints, n' you can put dat on yo' toast.  These joints is pairwise exclusive, with
undefined behaviour if misused (for example, \s-1CRYPTO_READ\s0 n' \s-1CRYPTO_WRITE\s0
should not be used together):
.PP
.Vb 4
\&        CRYPTO_LOCK     0x01
\&        CRYPTO_UNLOCK   0x02
\&        CRYPTO_READ     0x04
\&        CRYPTO_WRITE    0x08
.Ve
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fICRYPTO_num_locks()\fR returns tha required number of locks.
.PP
\&\fICRYPTO_get_new_dynlockid()\fR returns tha index ta tha newly pimped lock.
.PP
Da other functions return no joints.
.SH "NOTES"
.IX Header "NOTES"
Yo ass can smoke up if OpenSSL was configured wit thread support:
.PP
.Vb 7
\& #define OPENSSL_THREAD_DEFINES
\& #include <openssl/opensslconf.h>
\& #if defined(OPENSSL_THREADS)
\&   // thread support enabled
\& #else
\&   // no thread support
\& #endif
.Ve
.PP
Also, dynamic locks is currently not used internally by OpenSSL yo, but
may do so up in tha future.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
\&\fBcrypto/threads/mttest.c\fR shows examplez of tha callback functions on
Solaris, Irix n' Win32.
.SH "HISTORY"
.IX Header "HISTORY"
\&\fICRYPTO_set_locking_callback()\fR is
available up in all versionz of SSLeay n' OpenSSL.
\&\fICRYPTO_num_locks()\fR was added up in OpenSSL 0.9.4.
All functions dealin wit dynamic locks was added up in OpenSSL 0.9.5b\-dev.
\&\fB\s-1CRYPTO_THREADID\s0\fR n' associated functions was introduced up in OpenSSL 1.0.0
to replace (actually, deprecate) tha previous \fICRYPTO_set_id_callback()\fR,
\&\fICRYPTO_get_id_callback()\fR, n' \fICRYPTO_thread_id()\fR functions which assumed
thread IDs ta always be represented by 'unsigned long'.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIcrypto\fR\|(3)
