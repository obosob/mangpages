.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "des 3"
.TH des 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
DES_random_key, DES_set_key, DES_key_sched, DES_set_key_checked,
DES_set_key_unchecked, DES_set_odd_parity, DES_is_weak_key,
DES_ecb_encrypt, DES_ecb2_encrypt, DES_ecb3_encrypt, DES_ncbc_encrypt,
DES_cfb_encrypt, DES_ofb_encrypt, DES_pcbc_encrypt, DES_cfb64_encrypt,
DES_ofb64_encrypt, DES_xcbc_encrypt, DES_ede2_cbc_encrypt,
DES_ede2_cfb64_encrypt, DES_ede2_ofb64_encrypt, DES_ede3_cbc_encrypt,
DES_ede3_cbcm_encrypt, DES_ede3_cfb64_encrypt, DES_ede3_ofb64_encrypt,
DES_cbc_cksum, DES_quad_cksum, DES_string_to_key, DES_string_to_2keys,
DES_fcrypt, DES_crypt, DES_enc_read, DES_enc_write \- DES encryption
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/des.h>
\&
\& void DES_random_key(DES_cblock *ret);
\&
\& int DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule);
\& int DES_key_sched(const_DES_cblock *key, DES_key_schedule *schedule);
\& int DES_set_key_checked(const_DES_cblock *key,
\&        DES_key_schedule *schedule);
\& void DES_set_key_unchecked(const_DES_cblock *key,
\&        DES_key_schedule *schedule);
\&
\& void DES_set_odd_parity(DES_cblock *key);
\& int DES_is_weak_key(const_DES_cblock *key);
\&
\& void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output, 
\&        DES_key_schedule *ks, int enc);
\& void DES_ecb2_encrypt(const_DES_cblock *input, DES_cblock *output, 
\&        DES_key_schedule *ks1, DES_key_schedule *ks2, int enc);
\& void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output, 
\&        DES_key_schedule *ks1, DES_key_schedule *ks2, 
\&        DES_key_schedule *ks3, int enc);
\&
\& void DES_ncbc_encrypt(const unsigned char *input, unsigned char *output, 
\&        long length, DES_key_schedule *schedule, DES_cblock *ivec, 
\&        int enc);
\& void DES_cfb_encrypt(const unsigned char *in, unsigned char *out,
\&        int numbits, long length, DES_key_schedule *schedule,
\&        DES_cblock *ivec, int enc);
\& void DES_ofb_encrypt(const unsigned char *in, unsigned char *out,
\&        int numbits, long length, DES_key_schedule *schedule,
\&        DES_cblock *ivec);
\& void DES_pcbc_encrypt(const unsigned char *input, unsigned char *output, 
\&        long length, DES_key_schedule *schedule, DES_cblock *ivec, 
\&        int enc);
\& void DES_cfb64_encrypt(const unsigned char *in, unsigned char *out,
\&        long length, DES_key_schedule *schedule, DES_cblock *ivec,
\&        int *num, int enc);
\& void DES_ofb64_encrypt(const unsigned char *in, unsigned char *out,
\&        long length, DES_key_schedule *schedule, DES_cblock *ivec,
\&        int *num);
\&
\& void DES_xcbc_encrypt(const unsigned char *input, unsigned char *output, 
\&        long length, DES_key_schedule *schedule, DES_cblock *ivec, 
\&        const_DES_cblock *inw, const_DES_cblock *outw, int enc);
\&
\& void DES_ede2_cbc_encrypt(const unsigned char *input,
\&        unsigned char *output, long length, DES_key_schedule *ks1,
\&        DES_key_schedule *ks2, DES_cblock *ivec, int enc);
\& void DES_ede2_cfb64_encrypt(const unsigned char *in,
\&        unsigned char *out, long length, DES_key_schedule *ks1,
\&        DES_key_schedule *ks2, DES_cblock *ivec, int *num, int enc);
\& void DES_ede2_ofb64_encrypt(const unsigned char *in,
\&        unsigned char *out, long length, DES_key_schedule *ks1,
\&        DES_key_schedule *ks2, DES_cblock *ivec, int *num);
\&
\& void DES_ede3_cbc_encrypt(const unsigned char *input,
\&        unsigned char *output, long length, DES_key_schedule *ks1,
\&        DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec,
\&        int enc);
\& void DES_ede3_cbcm_encrypt(const unsigned char *in, unsigned char *out, 
\&        long length, DES_key_schedule *ks1, DES_key_schedule *ks2, 
\&        DES_key_schedule *ks3, DES_cblock *ivec1, DES_cblock *ivec2, 
\&        int enc);
\& void DES_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out, 
\&        long length, DES_key_schedule *ks1, DES_key_schedule *ks2,
\&        DES_key_schedule *ks3, DES_cblock *ivec, int *num, int enc);
\& void DES_ede3_ofb64_encrypt(const unsigned char *in, unsigned char *out, 
\&        long length, DES_key_schedule *ks1, 
\&        DES_key_schedule *ks2, DES_key_schedule *ks3, 
\&        DES_cblock *ivec, int *num);
\&
\& DES_LONG DES_cbc_cksum(const unsigned char *input, DES_cblock *output, 
\&        long length, DES_key_schedule *schedule, 
\&        const_DES_cblock *ivec);
\& DES_LONG DES_quad_cksum(const unsigned char *input, DES_cblock output[], 
\&        long length, int out_count, DES_cblock *seed);
\& void DES_string_to_key(const char *str, DES_cblock *key);
\& void DES_string_to_2keys(const char *str, DES_cblock *key1,
\&        DES_cblock *key2);
\&
\& char *DES_fcrypt(const char *buf, const char *salt, char *ret);
\& char *DES_crypt(const char *buf, const char *salt);
\&
\& int DES_enc_read(int fd, void *buf, int len, DES_key_schedule *sched,
\&        DES_cblock *iv);
\& int DES_enc_write(int fd, const void *buf, int len,
\&        DES_key_schedule *sched, DES_cblock *iv);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This library gotz nuff a gangbangin' fast implementation of tha \s-1DES\s0 encryption
algorithm.
.PP
There is two phases ta tha use of \s-1DES\s0 encryption. I aint talkin' bout chicken n' gravy biatch.  Da first is the
generation of a \fIDES_key_schedule\fR from a key, tha second is the
actual encryption. I aint talkin' bout chicken n' gravy biatch.  A \s-1DES\s0 key iz of type \fIDES_cblock\fR. This type is
consistz of 8 bytes wit odd parity.  Da least dope bit in
each byte is tha paritizzle bit.  Da key schedule be a expanded form of
the key; it is used ta speed tha encryption process.
.PP
\&\fIDES_random_key()\fR generates a random key.  Da \s-1PRNG\s0 must be seeded
prior ta rockin dis function (see \fIrand\fR\|(3)).  If tha \s-1PRNG\s0
could not generate a secure key, 0 is returned.
.PP
Before a \s-1DES\s0 key can be used, it must be converted tha fuck into the
architecture dependent \fIDES_key_schedule\fR via the
\&\fIDES_set_key_checked()\fR or \fIDES_set_key_unchecked()\fR function.
.PP
\&\fIDES_set_key_checked()\fR will check dat tha key passed iz of odd parity
and aint a week or semi-weak key.  If tha paritizzle is wrong, then \-1
is returned. Y'all KNOW dat shit, muthafucka!  If tha key be a weak key, then \-2 is returned. Y'all KNOW dat shit, muthafucka!  If an
error is returned, tha key schedule aint generated.
.PP
\&\fIDES_set_key()\fR works like
\&\fIDES_set_key_checked()\fR if tha \fIDES_check_key\fR flag is non-zero,
otherwise like \fIDES_set_key_unchecked()\fR.  These functions is available
for compatibility; it is recommended ta bust a gangbangin' function dat do not
depend on a global variable.
.PP
\&\fIDES_set_odd_parity()\fR sets tha paritizzle of tha passed \fIkey\fR ta odd.
.PP
\&\fIDES_is_weak_key()\fR returns 1 is tha passed key be a weak key, 0 if it
is ok.  Da probabilitizzle dat a randomly generated key is weak is
1/2^52, so it aint straight-up worth checkin fo' em.
.PP
Da followin routines mostly operate on a input n' output stream of
\&\fIDES_cblock\fRs.
.PP
\&\fIDES_ecb_encrypt()\fR is tha basic \s-1DES\s0 encryption routine dat encrypts or
decrypts a single 8\-byte \fIDES_cblock\fR up in \fIelectronic code book\fR
(\s-1ECB\s0) mode.  It always transforms tha input data, pointed ta by
\&\fIinput\fR, tha fuck into tha output data, pointed ta by tha \fIoutput\fR argument.
If tha \fIencrypt\fR argument is non-zero (\s-1DES_ENCRYPT\s0), tha \fIinput\fR
(cleartext) is encrypted up in ta tha \fIoutput\fR (ciphertext) rockin the
key_schedule specified by tha \fIschedule\fR argument, previously set via
\&\fIDES_set_key\fR. If \fIencrypt\fR is zero (\s-1DES_DECRYPT\s0), tha \fIinput\fR (now
ciphertext) is decrypted tha fuck into tha \fIoutput\fR (now cleartext).  Input
and output may overlap.  \fIDES_ecb_encrypt()\fR do not return a value.
.PP
\&\fIDES_ecb3_encrypt()\fR encrypts/decrypts tha \fIinput\fR block by using
three-key Triple-DES encryption up in \s-1ECB\s0 mode.  This involves encrypting
the input wit \fIks1\fR, decryptin wit tha key schedule \fIks2\fR, and
then encryptin wit \fIks3\fR.  This routine pimped outly reduces tha chances
of brute force breakin of \s-1DES\s0 n' has tha advantage of if \fIks1\fR,
\&\fIks2\fR n' \fIks3\fR is tha same, it is equivalent ta just encryption
usin \s-1ECB\s0 mode n' \fIks1\fR as tha key.
.PP
Da macro \fIDES_ecb2_encrypt()\fR is provided ta big-ass up two-key Triple-DES
encryption by rockin \fIks1\fR fo' tha final encryption.
.PP
\&\fIDES_ncbc_encrypt()\fR encrypts/decrypts rockin tha \fIcipher-block-chaining\fR
(\s-1CBC\s0) mode of \s-1DES. \s0 If tha \fIencrypt\fR argument is non-zero, the
routine cipher-block-chain encrypts tha cleartext data pointed ta by
the \fIinput\fR argument tha fuck into tha ciphertext pointed ta by tha \fIoutput\fR
argument, rockin tha key schedule provided by tha \fIschedule\fR argument,
and initialization vector provided by tha \fIivec\fR argument.  If the
\&\fIlength\fR argument aint a integral multiple of eight bytes, the
last block is copied ta a temporary area n' zero filled. Y'all KNOW dat shit, muthafucka!  Da output
is always a integral multiple of eight bytes.
.PP
\&\fIDES_xcbc_encrypt()\fR is \s-1RSA\s0z \s-1DESX\s0 mode of \s-1DES. \s0 It uses \fIinw\fR and
\&\fIoutw\fR ta 'whiten' tha encryption. I aint talkin' bout chicken n' gravy biatch.  \fIinw\fR n' \fIoutw\fR is secret
(unlike tha iv) n' is as such, part of tha key.  So tha key is sort
of 24 bytes.  This is much betta than \s-1CBC DES.\s0
.PP
\&\fIDES_ede3_cbc_encrypt()\fR implements outa triple \s-1CBC DES\s0 encryption with
three keys. This means dat each \s-1DES\s0 operation inside tha \s-1CBC\s0 mode is
really a \f(CW\*(C`C=E(ks3,D(ks2,E(ks1,M)))\*(C'\fR.  This mode is used by \s-1SSL.\s0
.PP
Da \fIDES_ede2_cbc_encrypt()\fR macro implements two-key Triple-DES by
reusin \fIks1\fR fo' tha final encryption. I aint talkin' bout chicken n' gravy biatch.  \f(CW\*(C`C=E(ks1,D(ks2,E(ks1,M)))\*(C'\fR.
This form of Triple-DES is used by tha \s-1RSAREF\s0 library.
.PP
\&\fIDES_pcbc_encrypt()\fR encrypt/decrypts rockin tha propagatin cipher block
chainin mode used by Kerberos v4. Its parametas is tha same as
\&\fIDES_ncbc_encrypt()\fR.
.PP
\&\fIDES_cfb_encrypt()\fR encrypt/decrypts rockin cipher feedback mode.  This
method takes a array of charactas as input n' outputs n' array of
characters.  It do not require any paddin ta 8 characta groups.
Note: tha \fIivec\fR variable is chizzled n' tha freshly smoked up chizzled value needz to
be passed ta tha next call ta dis function. I aint talkin' bout chicken n' gravy biatch.  Since dis function runs
a complete \s-1DES ECB\s0 encryption per \fInumbits\fR, dis function is only
suggested fo' use when bustin  lil' small-ass numberz of characters.
.PP
\&\fIDES_cfb64_encrypt()\fR
implements \s-1CFB\s0 mode of \s-1DES\s0 wit 64bit feedback.  Why is this
useful you ask, biatch?  Because dis routine will allow you ta encrypt an
arbitrary number of bytes, no 8 byte padding.  Each call ta this
routine will encrypt tha input bytes ta output n' then update ivec
and num.  num gotz nuff 'how far' we is though ivec.  If dis do
not make much sense, read mo' bout cfb mode of \s-1DES :\-\s0).
.PP
\&\fIDES_ede3_cfb64_encrypt()\fR n' \fIDES_ede2_cfb64_encrypt()\fR is tha same ol' dirty as
\&\fIDES_cfb64_encrypt()\fR except dat Triple-DES is used.
.PP
\&\fIDES_ofb_encrypt()\fR encrypts rockin output feedback mode.  This method
takes a array of charactas as input n' outputs n' array of
characters.  It do not require any paddin ta 8 characta groups.
Note: tha \fIivec\fR variable is chizzled n' tha freshly smoked up chizzled value needz to
be passed ta tha next call ta dis function. I aint talkin' bout chicken n' gravy biatch.  Since dis function runs
a complete \s-1DES ECB\s0 encryption per numbits, dis function is only
suggested fo' use when bustin  lil' small-ass numberz of characters.
.PP
\&\fIDES_ofb64_encrypt()\fR is tha same ol' dirty as \fIDES_cfb64_encrypt()\fR rockin Output
Feed Back mode.
.PP
\&\fIDES_ede3_ofb64_encrypt()\fR n' \fIDES_ede2_ofb64_encrypt()\fR is tha same ol' dirty as
\&\fIDES_ofb64_encrypt()\fR, rockin Triple-DES.
.PP
Da followin functions is included up in tha \s-1DES\s0 library for
compatibilitizzle wit tha \s-1MIT\s0 Kerberos library.
.PP
\&\fIDES_cbc_cksum()\fR produces a 8 byte checksum based on tha input stream
(via \s-1CBC\s0 encryption).  Da last 4 bytez of tha checksum is returned
and tha complete 8 bytes is placed up in \fIoutput\fR. This function is
used by Kerberos v4.  Other applications should use
\&\fIEVP_DigestInit\fR\|(3) etc. instead.
.PP
\&\fIDES_quad_cksum()\fR be a Kerberos v4 function. I aint talkin' bout chicken n' gravy biatch.  It returns a 4 byte
checksum from tha input bytes.  Da algorithm can be iterated over the
input, dependin on \fIout_count\fR, 1, 2, 3 or 4 times.  If \fIoutput\fR is
non-NULL, tha 8 bytes generated by each pass is freestyled into
\&\fIoutput\fR.
.PP
Da followin is DES-based transformations:
.PP
\&\fIDES_fcrypt()\fR be a gangbangin' fast version of tha Unix \fIcrypt\fR\|(3) function. I aint talkin' bout chicken n' gravy biatch.  This
version takes only a lil' small-ass amount of space relatizzle ta other fast
\&\fIcrypt()\fR implementations.  This is different ta tha aiiight crypt in
that tha third parameta is tha buffer dat tha return value is
written into.  It need ta be at least 14 bytes long.  This function
is thread safe, unlike tha aiiight crypt.
.PP
\&\fIDES_crypt()\fR be a gangbangin' fasta replacement fo' tha aiiight system \fIcrypt()\fR.
This function calls \fIDES_fcrypt()\fR wit a static array passed as the
third parameter n' shit.  This emulates tha aiiight non-thread safe semantics
of \fIcrypt\fR\|(3).
.PP
\&\fIDES_enc_write()\fR writes \fIlen\fR bytes ta file descriptor \fIfd\fR from
buffer \fIbuf\fR. Da data is encrypted via \fIpcbc_encrypt\fR (default)
usin \fIsched\fR fo' tha key n' \fIiv\fR as a startin vector. Shiiit, dis aint no joke.  Da actual
data bust down \fIfd\fR consistz of 4 bytes (in network byte order)
containin tha length of tha followin encrypted data.  Da encrypted
data then bigs up, padded wit random data up ta a multiple of 8
bytes.
.PP
\&\fIDES_enc_read()\fR is used ta read \fIlen\fR bytes from file descriptor
\&\fIfd\fR tha fuck into buffer \fIbuf\fR. Da data bein read from \fIfd\fR be assumed to
have come from \fIDES_enc_write()\fR n' is decrypted rockin \fIsched\fR for
the key schedule n' \fIiv\fR fo' tha initial vector.
.PP
\&\fBWarning:\fR Da data format used by \fIDES_enc_write()\fR n' \fIDES_enc_read()\fR
has a cold-ass lil cryptographic weakness: When axed ta write mo' than \s-1MAXWRITE\s0
bytes, \fIDES_enc_write()\fR will split tha data tha fuck into nuff muthafuckin chunks that
are all encrypted rockin tha same \s-1IV. \s0 So don't use these functions
unless yo ass is shizzle you know what tha fuck you do (in which case you might not
wanna use dem anyway).  They cannot handle non-blockin sockets.
\&\fIDES_enc_read()\fR uses a internal state n' thus cannot be used on
multiple files.
.PP
\&\fIDES_rw_mode\fR is used ta specify tha encryption mode ta use with
\&\fIDES_enc_read()\fR n' \fIDES_end_write()\fR.  If set ta \fI\s-1DES_PCBC_MODE\s0\fR (the
default), DES_pcbc_encrypt is used. Y'all KNOW dat shit, muthafucka!  If set ta \fI\s-1DES_CBC_MODE\s0\fR
DES_cbc_encrypt is used.
.SH "NOTES"
.IX Header "NOTES"
Single-key \s-1DES\s0 is insecure cuz of its short key size.  \s-1ECB\s0 mode is
not suitable fo' most applications; peep \fIdes_modes\fR\|(7).
.PP
Da \fIevp\fR\|(3) library serves up higher-level encryption functions.
.SH "BUGS"
.IX Header "BUGS"
\&\fIDES_3cbc_encrypt()\fR is flawed n' must not be used up in applications.
.PP
\&\fIDES_cbc_encrypt()\fR do not modify \fBivec\fR; use \fIDES_ncbc_encrypt()\fR
instead.
.PP
\&\fIDES_cfb_encrypt()\fR n' \fIDES_ofb_encrypt()\fR operates on input of 8 bits.
What dis means is dat if you set numbits ta 12, n' length ta 2, the
first 12 bits will come from tha 1st input byte n' tha low half of
the second input byte.  Da second 12 bits gonna git tha low 8 bits
taken from tha 3rd input byte n' tha top 4 bits taken from tha 4th
input byte.  Da same holdz fo' output.  This function has been
implemented dis way cuz most playas is ghon be rockin a multiple of 8
and cuz once you git tha fuck into pullin bytes input bytes apart thangs
get skanky!
.PP
\&\fIDES_string_to_key()\fR be available fo' backward compatibilitizzle wit the
\&\s-1MIT\s0 library.  New applications should bust a cold-ass lil cryptographic hash function.
Da same applies fo' \fIDES_string_to_2key()\fR.
.SH "CONFORMING TO"
.IX Header "CONFORMING TO"
\&\s-1ANSI X3.106\s0
.PP
Da \fBdes\fR library was freestyled ta be source code compatible with
the \s-1MIT\s0 Kerberos library.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIcrypt\fR\|(3), \fIdes_modes\fR\|(7), \fIevp\fR\|(3), \fIrand\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
In OpenSSL 0.9.7, all des_ functions was renamed ta \s-1DES_\s0 ta avoid
clashes wit olda versionz of libdes.  Compatibilitizzle des_ functions
are provided fo' a gangbangin' finger-lickin' dirty-ass short while, as well as \fIcrypt()\fR.
Declarations fo' these is up in <openssl/des_old.h>. There is no \s-1DES_\s0
variant fo' \fIdes_random_seed()\fR.
This will happen ta other functions
as well if they is deemed redundant (\fIdes_random_seed()\fR just calls
\&\fIRAND_seed()\fR n' is present fo' backward compatibilitizzle only), buggy or
already scheduled fo' removal.
.PP
\&\fIdes_cbc_cksum()\fR, \fIdes_cbc_encrypt()\fR, \fIdes_ecb_encrypt()\fR,
\&\fIdes_is_weak_key()\fR, \fIdes_key_sched()\fR, \fIdes_pcbc_encrypt()\fR,
\&\fIdes_quad_cksum()\fR, \fIdes_random_key()\fR n' \fIdes_string_to_key()\fR
are available up in tha \s-1MIT\s0 Kerberos library;
\&\fIdes_check_key_parity()\fR, \fIdes_fixup_key_parity()\fR n' \fIdes_is_weak_key()\fR
are available up in newer versionz of dat library.
.PP
\&\fIdes_set_key_checked()\fR n' \fIdes_set_key_unchecked()\fR was added in
OpenSSL 0.9.5.
.PP
\&\fIdes_generate_random_block()\fR, \fIdes_init_random_number_generator()\fR,
\&\fIdes_new_random_key()\fR, \fIdes_set_random_generator_seed()\fR and
\&\fIdes_set_sequence_number()\fR n' \fIdes_rand_data()\fR is used up in newer
versionz of Kerberos but is not implemented here.
.PP
\&\fIdes_random_key()\fR generated cryptographically weak random data in
SSLeay n' up in OpenSSL prior version 0.9.5, as well as up in tha original
\&\s-1MIT\s0 library.
.SH "AUTHOR"
.IX Header "AUTHOR"
Eric Young (eay@cryptsoft.com). Modified fo' tha OpenSSL project
(http://www.openssl.org).
