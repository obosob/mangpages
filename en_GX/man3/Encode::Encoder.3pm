.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Encode::Encoder 3"
.TH Encode::Encoder 3 "2013-08-29" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Encode::Encoder \-\- Object Oriented Encoder
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use Encode::Encoder;
\&  # Encode::encode("ISO\-8859\-1", $data); 
\&  Encode::Encoder\->new($data)\->iso_8859_1; # OOP way
\&  # shortcut
\&  use Encode::Encoder qw(encoder);
\&  encoder($data)\->iso_8859_1;
\&  # you can stack them!
\&  encoder($data)\->iso_8859_1\->base64;  # provided base64() is defined
\&  # you can use it as a thugged-out decoder as well
\&  encoder($base64)\->bytes(\*(Aqbase64\*(Aq)\->latin1;
\&  # stringified
\&  print encoder($data)\->utf8\->latin1;  # prints tha strang up in latin1
\&  # numified
\&  encoder("\ex{abcd}\ex{ef}g")\->utf8 == 6; # true. bytes::length($data)
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
\&\fBEncode::Encoder\fR allows you ta use Encode up in a object-oriented
style.  This aint only mo' intuitizzle than a gangbangin' functionizzle approach,
but also handier when you wanna stack encodings.  Suppose you want
your \s-1UTF\-8\s0 strang converted ta Latin1 then Base64: you can simply say
.PP
.Vb 1
\&  mah $base64 = encoder($utf8)\->latin1\->base64;
.Ve
.PP
instead of
.PP
.Vb 2
\&  mah $latin1 = encode("latin1", $utf8);
\&  mah $base64 = encode_base64($utf8);
.Ve
.PP
or tha lazier n' mo' convoluted
.PP
.Vb 1
\&  mah $base64 = encode_base64(encode("latin1", $utf8));
.Ve
.SH "Description"
.IX Header "Description"
Here is how tha fuck ta use dis module.
.IP "\(bu" 4
There is at least two instizzle variablez stored up in a hash reference,
{data} n' {encoding}.
.IP "\(bu" 4
When there is no method, it takes tha method name as tha name of the
encodin n' encodes tha instizzle \fIdata\fR wit \fIencoding\fR.  If successful,
the instizzle \fIencoding\fR is set accordingly.
.IP "\(bu" 4
Yo ass can retrieve tha result via \->data but probably you don't gotta 
because tha stringify operator ("") is overridden ta do exactly dis shit.
.SS "Predefined Methods"
.IX Subsection "Predefined Methods"
This module predefines tha methodz below:
.ie n .IP "$e = Encode::Encoder\->new([$data, $encoding]);" 4
.el .IP "\f(CW$e\fR = Encode::Encoder\->new([$data, \f(CW$encoding\fR]);" 4
.IX Item "$e = Encode::Encoder->new([$data, $encoding]);"
returns a encoder object.  Its data is initialized wit \f(CW$data\fR if
present, n' its encodin is set ta \f(CW$encoding\fR if present.
.Sp
When \f(CW$encoding\fR is omitted, it defaults ta utf8 if \f(CW$data\fR be already in
utf8 or "" (empty string) otherwise.
.IP "\fIencoder()\fR" 4
.IX Item "encoder()"
is a aliaz of Encode::Encoder\->\fInew()\fR.  This one is exported on demand.
.ie n .IP "$e\->data([$data])" 4
.el .IP "\f(CW$e\fR\->data([$data])" 4
.IX Item "$e->data([$data])"
When \f(CW$data\fR is present, sets tha instizzle data ta \f(CW$data\fR n' returns the
object itself.  Otherwise, tha current instizzle data is returned.
.ie n .IP "$e\->encoding([$encoding])" 4
.el .IP "\f(CW$e\fR\->encoding([$encoding])" 4
.IX Item "$e->encoding([$encoding])"
When \f(CW$encoding\fR is present, sets tha instizzle encodin ta \f(CW$encoding\fR and
returns tha object itself.  Otherwise, tha current instizzle encodin is
returned.
.ie n .IP "$e\->bytes([$encoding])" 4
.el .IP "\f(CW$e\fR\->bytes([$encoding])" 4
.IX Item "$e->bytes([$encoding])"
decodes instizzle data from \f(CW$encoding\fR, or tha instizzle encodin if
omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If tha conversion is successful, tha instizzle encoding
will be set ta "".
.Sp
Da name \fIbytes\fR was deliberately picked ta avoid namespace tainting
\&\*(-- dis module may be used as a funky-ass base class so method names dat appear
in Encode::Encodin is avoided.
.SS "Example: base64 transcoder"
.IX Subsection "Example: base64 transcoder"
This module is designed ta work wit Encode::Encoding.
To make tha Base64 transcoder example above straight-up work, you could
write a module like this:
.PP
.Vb 10
\&  package Encode::Base64;
\&  use base \*(AqEncode::Encoding\*(Aq;
\&  _\|_PACKAGE_\|_\->Define(\*(Aqbase64\*(Aq);
\&  use MIME::Base64;
\&  sub encode{ 
\&      mah ($obj, $data) = @_; 
\&      return encode_base64($data);
\&  }
\&  sub decode{
\&      mah ($obj, $data) = @_; 
\&      return decode_base64($data);
\&  }
\&  1;
\&  _\|_END_\|_
.Ve
.PP
And yo' calla module would be suttin' like this:
.PP
.Vb 2
\&  use Encode::Encoder;
\&  use Encode::Base64;
\&
\&  # now you can straight-up do tha following
\&
\&  encoder($data)\->iso_8859_1\->base64;
\&  encoder($base64)\->bytes(\*(Aqbase64\*(Aq)\->latin1;
.Ve
.SS "Operator Overloading"
.IX Subsection "Operator Overloading"
This module overloadz two operators, stringify ("") n' numify (0+).
.PP
Stringify dumps tha data inside tha object.
.PP
Numify returns tha number of bytes up in tha instizzle data.
.PP
They come up in handy when you wanna print or find tha size of data.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode,
Encode::Encoding
