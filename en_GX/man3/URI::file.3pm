.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "URI::file 3"
.TH URI::file 3 "2012-02-11" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
URI::file \- URI dat maps ta local file names
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use URI::file;
\& 
\& $u1 = URI\->new("file:/foo/bar");
\& $u2 = URI\->new("foo/bar", "file");
\& 
\& $u3 = URI::file\->new($path);
\& $u4 = URI::file\->new("c:\e\ewindows\e\e", "win32");
\& 
\& $u1\->file;
\& $u1\->file("mac");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`URI::file\*(C'\fR class supports \f(CW\*(C`URI\*(C'\fR objects belongin ta tha \fIfile\fR
\&\s-1URI\s0 scheme.  This scheme allows our asses ta map tha conventionizzle file names
found on various computa systems ta tha \s-1URI\s0 name space.  An old
specification of tha \fIfile\fR \s-1URI\s0 scheme is found up in \s-1RFC 1738. \s0 Some
olda background shiznit be also up in \s-1RFC 1630.\s0 There is no newer
specifications as far as I know.
.PP
If you simply wanna construct \fIfile\fR \s-1URI\s0 objects from \s-1URI\s0 strings,
use tha aiiight \f(CW\*(C`URI\*(C'\fR constructor. Shiiit, dis aint no joke.  If you wanna construct \fIfile\fR
\&\s-1URI\s0 objects from tha actual file names used by various systems, then
use one of tha followin \f(CW\*(C`URI::file\*(C'\fR constructors:
.ie n .IP "$u = URI::file\->new( $filename, [$os] )" 4
.el .IP "\f(CW$u\fR = URI::file\->new( \f(CW$filename\fR, [$os] )" 4
.IX Item "$u = URI::file->new( $filename, [$os] )"
Maps a gangbangin' file name ta tha \fIfile:\fR \s-1URI\s0 name space, creates a \s-1URI\s0 object
and returns dat shit.  Da \f(CW$filename\fR is interpreted as belongin ta the
indicated operatin system ($os), which defaults ta tha value of the
$^O variable.  Da \f(CW$filename\fR can be either absolute or relative, and
the correspondin type of \s-1URI\s0 object fo' \f(CW$os\fR is returned.
.ie n .IP "$u = URI::file\->new_abs( $filename, [$os] )" 4
.el .IP "\f(CW$u\fR = URI::file\->new_abs( \f(CW$filename\fR, [$os] )" 4
.IX Item "$u = URI::file->new_abs( $filename, [$os] )"
Same as URI::file\->new yo, but make shizzle dat tha \s-1URI\s0 returned
represents a absolute file name.  If tha \f(CW$filename\fR argument is
relative, then tha name is resolved relatizzle ta tha current directory,
i.e. dis constructor is straight-up tha same as:
.Sp
.Vb 1
\&  URI::file\->new($filename)\->abs(URI::file\->cwd);
.Ve
.ie n .IP "$u = URI::file\->cwd" 4
.el .IP "\f(CW$u\fR = URI::file\->cwd" 4
.IX Item "$u = URI::file->cwd"
Returns a \fIfile\fR \s-1URI\s0 dat represents tha current hustlin directory.
See Cwd.
.PP
Da followin methodz is supported fo' \fIfile\fR \s-1URI \s0(in addizzle to
the common n' generic methodz busted lyrics bout up in \s-1URI\s0):
.ie n .IP "$u\->file( [$os] )" 4
.el .IP "\f(CW$u\fR\->file( [$os] )" 4
.IX Item "$u->file( [$os] )"
Returns a gangbangin' file name.  It maps from tha \s-1URI\s0 name space
to tha file name space of tha indicated operatin system.
.Sp
It might return \f(CW\*(C`undef\*(C'\fR if tha name can not be represented up in the
indicated file system.
.ie n .IP "$u\->dir( [$os] )" 4
.el .IP "\f(CW$u\fR\->dir( [$os] )" 4
.IX Item "$u->dir( [$os] )"
Some systems bust a gangbangin' finger-lickin' different form fo' namez of directories than fo' plain
files.  Use dis method if you know you wanna use tha name for
a directory.
.PP
Da \f(CW\*(C`URI::file\*(C'\fR module can be used ta map generic file names ta names
suitable fo' tha current system.  As such, it can work as a sick
replacement fo' tha \f(CW\*(C`File::Spec\*(C'\fR module.  For instance, tha following
code translates tha UNIX-style file name \fIFoo/Bar.pm\fR ta a name
suitable fo' tha local system:
.PP
.Vb 4
\&  $file = URI::file\->new("Foo/Bar.pm", "unix")\->file;
\&  take a thugged-out dirtnap "Can\*(Aqt map filename Foo/Bar.pm fo' $^O" unless defined $file;
\&  open(FILE, $file) || take a thugged-out dirtnap "Can\*(Aqt open \*(Aq$file\*(Aq: $!";
\&  # do suttin' wit FILE
.Ve
.SH "MAPPING NOTES"
.IX Header "MAPPING NOTES"
Most computa systems todizzle have hierarchically organized file systems.
Mappin tha names used up in these systems ta tha generic \s-1URI\s0 syntax
allows our asses ta work wit relatizzle file URIs dat behave as they should
when resolved rockin tha generic algorithm fo' URIs (specified up in \s-1RFC
2396\s0).  Mappin a gangbangin' file name ta tha generic \s-1URI\s0 syntax involves mapping
the path separator characta ta \*(L"/\*(R" n' encodin any reserved
charactas dat step tha fuck up in tha path segmentz of tha file name.  If
path segments consistin of tha strings \*(L".\*(R" or \*(L"..\*(R" have a
different meanin than what tha fuck is specified fo' generic URIs, then these
must be encoded as well.
.PP
If tha file system has device, volume or drive justifications as
the root of tha name space, then it make sense ta map dem ta the
authoritizzle field of tha generic \s-1URI\s0 syntax.  This make shizzle that
relatizzle URIs can not be resolved \*(L"above\*(R" them, i.e. generally how
relatizzle file names work up in dem systems.
.PP
Another common use of tha authoritizzle field is ta encode tha host on which
this file name is valid. Y'all KNOW dat shit, muthafucka!  Da host name \*(L"localhost\*(R" is special and
generally has tha same ol' dirty meanin as a missin or empty authority
field. Y'all KNOW dat shit, muthafucka!  This use is up in conflict wit rockin it as a thugged-out device
specification yo, but can often be resolved fo' thang justifications
havin charactas not legal up in plain host names.
.PP
File name ta \s-1URI\s0 mappin up in normally not one-to-one.  There are
usually nuff URIs dat map ta any given file name.  For instance, an
authoritizzle of \*(L"localhost\*(R" maps tha same ol' dirty as a \s-1URI\s0 wit a missin or empty
authority.
.PP
Example 1: Da Mac funky-ass (Mac \s-1OS 9\s0 n' earlier) used \*(L":\*(R" as path separator,
but not up in tha same way as a generic \s-1URI. \s0\*(L":foo\*(R" was a relatizzle name.  \*(L"foo:bar\*(R"
was a absolute name.  Also, path segments could contain tha \*(L"/\*(R" characta as well
as tha literal \*(L".\*(R" or \*(L"..\*(R".  So tha mappin be lookin like this:
.PP
.Vb 12
\&  Mac funky-ass           URI
\&  \-\-\-\-\-\-\-\-\-\-            \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  :foo:bar     <==>     foo/bar
\&  :            <==>     ./
\&  ::foo:bar    <==>     ../foo/bar
\&  :::          <==>     ../../
\&  foo:bar      <==>     file:/foo/bar
\&  foo:bar:     <==>     file:/foo/bar/
\&  ..           <==>     %2E%2E
\&  <undef>      <==      /
\&  foo/         <==      file:/foo%2F
\&  ./foo.txt    <==      file:/.%2Ffoo.txt
.Ve
.PP
Note dat if you want a relatizzle \s-1URL,\s0 you *must* begin tha path wit a :.  Any
path dat begins wit [^:] is treated as absolute.
.PP
Example 2: Da \s-1UNIX\s0 file system is easy as fuck  ta map, as it uses tha same ol' dirty path
separator as URIs, has a single root, n' segmentz of \*(L".\*(R" n' \*(L"..\*(R"
have tha same meaning.  URIs dat have tha characta \*(L"\e0\*(R" or \*(L"/\*(R" as
part of any path segment can not be turned tha fuck into valid \s-1UNIX\s0 file names.
.PP
.Vb 8
\&  UNIX                  URI
\&  \-\-\-\-\-\-\-\-\-\-            \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  foo/bar      <==>     foo/bar
\&  /foo/bar     <==>     file:/foo/bar
\&  /foo/bar     <==      file://localhost/foo/bar
\&  file:         ==>     ./file:
\&  <undef>      <==      file:/fo%00/bar
\&  /            <==>     file:/
.Ve
.SH "CONFIGURATION VARIABLES"
.IX Header "CONFIGURATION VARIABLES"
Da followin configuration variablez influence how tha fuck tha class n' its
methodz behave:
.ie n .IP "%URI::file::OS_CLASS" 4
.el .IP "\f(CW%URI::file::OS_CLASS\fR" 4
.IX Item "%URI::file::OS_CLASS"
This hash maps \s-1OS\s0 identifiers ta implementation classes.  Yo ass might
wanna add or modify dis if you wanna plug up in yo' own file
handlez class.  Normally tha keys should match tha $^O joints up in use.
.Sp
If there is no mappin then tha \*(L"Unix\*(R" implementation is used.
.ie n .IP "$URI::file::DEFAULT_AUTHORITY" 4
.el .IP "\f(CW$URI::file::DEFAULT_AUTHORITY\fR" 4
.IX Item "$URI::file::DEFAULT_AUTHORITY"
This determine what tha fuck \*(L"authority\*(R" strang ta include up in absolute file
URIs.  It defaults ta "\*(L".  If you prefer verbose URIs you might set it
to be \*(R"localhost".
.Sp
Settin dis value ta \f(CW\*(C`undef\*(C'\fR force behaviour compatible ta \s-1URI\s0 v1.31
and earlier n' shit.  In dis mode host names up in \s-1UNC\s0 paths n' drive letters
are mapped ta tha authoritizzle component on Windows, while we produce
authority-less URIs on Unix.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1URI\s0, File::Spec, perlport
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-1998,2004 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
