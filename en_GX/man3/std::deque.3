" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::deque< _Tp, _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBstd::_Deque_base< _Tp, _Alloc >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef \fB_Base::const_iterator\fP \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef 
.br
_Tp_alloc_type::const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef 
.br
_Tp_alloc_type::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< \fBconst_iterator\fP > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef \fB_Base::iterator\fP \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< \fBiterator\fP > \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Tp \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBdeque\fP ()"
.br
.ti -1c
.RI "\fBdeque\fP (const allocator_type &__a)"
.br
.ti -1c
.RI "\fBdeque\fP (size_type __n)"
.br
.ti -1c
.RI "\fBdeque\fP (size_type __n, const value_type &__value, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBdeque\fP (const \fBdeque\fP &__x)"
.br
.ti -1c
.RI "\fBdeque\fP (\fBdeque\fP &&__x)"
.br
.ti -1c
.RI "\fBdeque\fP (\fBinitializer_list\fP< value_type > __l, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> \fBdeque\fP (_InputIterator __first, _InputIterator __last, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fB~deque\fP () noexcept"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBdeque\fP< _Tp, _Alloc >::\fBiterator\fP \fB_M_insert_aux\fP (\fBiterator\fP __pos, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "void \fBassign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> void \fBassign\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBassign\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "reference \fBat\fP (size_type __n)"
.br
.ti -1c
.RI "const_reference \fBat\fP (size_type __n) const "
.br
.ti -1c
.RI "reference \fBback\fP ()"
.br
.ti -1c
.RI "const_reference \fBback\fP () const "
.br
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const noexcept"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBdeque\fP< _Tp, _Alloc >::\fBiterator\fP \fBemplace\fP (\fBiterator\fP __position, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBiterator\fP \fBemplace\fP (\fBiterator\fP __position, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> void \fBemplace_back\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> void \fBemplace_front\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const noexcept"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __position)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __first, \fBiterator\fP __last)"
.br
.ti -1c
.RI "reference \fBfront\fP ()"
.br
.ti -1c
.RI "const_reference \fBfront\fP () const "
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const noexcept"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBiterator\fP __position, const value_type &__x)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBiterator\fP __position, value_type &&__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __p, \fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __position, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> void \fBinsert\fP (\fBiterator\fP __position, _InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const noexcept"
.br
.ti -1c
.RI "\fBdeque\fP & \fBoperator=\fP (const \fBdeque\fP &__x)"
.br
.ti -1c
.RI "\fBdeque\fP & \fBoperator=\fP (\fBdeque\fP &&__x)"
.br
.ti -1c
.RI "\fBdeque\fP & \fBoperator=\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "reference \fBoperator[]\fP (size_type __n)"
.br
.ti -1c
.RI "const_reference \fBoperator[]\fP (size_type __n) const "
.br
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.ti -1c
.RI "void \fBpop_front\fP ()"
.br
.ti -1c
.RI "void \fBpush_back\fP (const value_type &__x)"
.br
.ti -1c
.RI "void \fBpush_back\fP (value_type &&__x)"
.br
.ti -1c
.RI "void \fBpush_front\fP (const value_type &__x)"
.br
.ti -1c
.RI "void \fBpush_front\fP (value_type &&__x)"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size, const value_type &__x)"
.br
.ti -1c
.RI "void \fBshrink_to_fit\fP ()"
.br
.ti -1c
.RI "size_type \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "void \fBswap\fP (\fBdeque\fP &__x)"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "enum { \fB_S_initial_map_size\fP }"
.br
.ti -1c
.RI "typedef _Alloc::template 
.br
rebind< _Tp * >::other \fB_Map_alloc_type\fP"
.br
.ti -1c
.RI "typedef pointa * \fB_Map_pointer\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "_Tp ** \fB_M_allocate_map\fP (size_t __n)"
.br
.ti -1c
.RI "_Tp * \fB_M_allocate_node\fP ()"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_assign_aux\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_assign_aux\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_assign_dispatch\fP (_Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_assign_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "void \fB_M_create_nodes\fP (_Tp **__nstart, _Tp **__nfinish)"
.br
.ti -1c
.RI "void \fB_M_deallocate_map\fP (_Tp **__p, size_t __n)"
.br
.ti -1c
.RI "void \fB_M_deallocate_node\fP (_Tp *__p)"
.br
.ti -1c
.RI "void \fB_M_default_append\fP (size_type __n)"
.br
.ti -1c
.RI "void \fB_M_default_initialize\fP ()"
.br
.ti -1c
.RI "template<typename _Alloc1 > void \fB_M_destroy_data\fP (\fBiterator\fP __first, \fBiterator\fP __last, const _Alloc1 &)"
.br
.ti -1c
.RI "void \fB_M_destroy_data\fP (\fBiterator\fP __first, \fBiterator\fP __last, const \fBstd::allocator\fP< _Tp > &)"
.br
.ti -1c
.RI "void \fB_M_destroy_data_aux\fP (\fBiterator\fP __first, \fBiterator\fP __last)"
.br
.ti -1c
.RI "void \fB_M_destroy_nodes\fP (_Tp **__nstart, _Tp **__nfinish)"
.br
.ti -1c
.RI "void \fB_M_erase_at_begin\fP (\fBiterator\fP __pos)"
.br
.ti -1c
.RI "void \fB_M_erase_at_end\fP (\fBiterator\fP __pos)"
.br
.ti -1c
.RI "void \fB_M_fill_assign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "void \fB_M_fill_initialize\fP (const value_type &__value)"
.br
.ti -1c
.RI "void \fB_M_fill_insert\fP (\fBiterator\fP __pos, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "_Map_alloc_type \fB_M_get_map_allocator\fP () const noexcept"
.br
.ti -1c
.RI "_Tp_alloc_type & \fB_M_get_Tp_allocator\fP () noexcept"
.br
.ti -1c
.RI "const _Tp_alloc_type & \fB_M_get_Tp_allocator\fP () const noexcept"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_initialize_dispatch\fP (_Integer __n, _Integer __x, __true_type)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_initialize_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "void \fB_M_initialize_map\fP (size_t)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBiterator\fP \fB_M_insert_aux\fP (\fBiterator\fP __pos, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "void \fB_M_insert_aux\fP (\fBiterator\fP __pos, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_insert_aux\fP (\fBiterator\fP __pos, _ForwardIterator __first, _ForwardIterator __last, size_type __n)"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_insert_dispatch\fP (\fBiterator\fP __pos, _Integer __n, _Integer __x, __true_type)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_insert_dispatch\fP (\fBiterator\fP __pos, _InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "void \fB_M_range_check\fP (size_type __n) const "
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_range_insert_aux\fP (\fBiterator\fP __pos, _InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_range_insert_aux\fP (\fBiterator\fP __pos, _ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "bool \fB_M_shrink_to_fit\fP ()"
.br
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_range_initialize\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_range_initialize\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<typename\&.\&.\&. _Args> void \fB_M_push_back_aux\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> void \fB_M_push_front_aux\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "void \fB_M_pop_back_aux\fP ()"
.br
.ti -1c
.RI "void \fB_M_pop_front_aux\fP ()"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBiterator\fP \fB_M_reserve_elements_at_front\fP (size_type __n)"
.br
.ti -1c
.RI "\fBiterator\fP \fB_M_reserve_elements_at_back\fP (size_type __n)"
.br
.ti -1c
.RI "void \fB_M_new_elements_at_front\fP (size_type __new_elements)"
.br
.ti -1c
.RI "void \fB_M_new_elements_at_back\fP (size_type __new_elements)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fB_M_reserve_map_at_back\fP (size_type __nodes_to_add=1)"
.br
.ti -1c
.RI "void \fB_M_reserve_map_at_front\fP (size_type __nodes_to_add=1)"
.br
.ti -1c
.RI "void \fB_M_reallocate_map\fP (size_type __nodes_to_add, bool __add_at_front)"
.br
.in -1c
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static size_t \fB_S_buffer_size\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_Deque_impl \fB_M_impl\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>>class std::deque< _Tp, _Alloc >"
A standard container rockin fixed-size memory allocation n' constant-time manipulation of elements at either end\&. 


.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Tp\fP Type of element\&. 
.br
\fI_Alloc\fP Allocator type, defaults ta allocator<_Tp>\&.
.RE
.PP
Meets tha requirementz of a \fCcontainer\fP, a \fCreversible container\fP, n' a \fCsequence\fP, includin tha \fCoptionizzle sequence requirements\fP\&.
.PP
In previous HP/SGI versionz of deque, there was a extra template parameta so playas could control tha node size\&. This extension turned up ta violate tha C++ standard (it can be detected rockin template template parameters), n' dat shiznit was removed\&.
.PP
Herez how tha fuck a thugged-out deque<Tp> manages memory\&. Each deque has 4 members:
.PP
.IP "\(bu" 2
Tp** _M_map
.IP "\(bu" 2
size_t _M_map_size
.IP "\(bu" 2
iterator _M_start, _M_finish
.PP
.PP
map_size be at least 8\&. map be a array of map_size pointers-to-\fInodes\fP\&. (Da name map has not a god damn thang ta do wit tha std::map class, n' \fBnodes\fP should not be trippin wit std::listz usage of \fInode\fP\&.)
.PP
A \fInode\fP has no specific type name as such yo, but it is referred ta as \fInode\fP up in dis file\&. Well shiiiit, it aint nuthin but a simple array-of-Tp\&. If Tp is straight-up large, there is ghon be one Tp element per node (i\&.e\&., a \fIarray\fP of one)\&. For non-huge Tp's, node size is inversely related ta Tp size: tha larger tha Tp, tha fewer Tpz will fit up in a node\&. Da goal here is ta keep tha total size of a node relatively lil' small-ass n' constant over different Tp's, ta improve allocator efficiency\&.
.PP
Not every last muthafuckin pointa up in tha map array will point ta a node\&. If tha initial number of elements up in tha deque is small, tha /middle/ map pointas is ghon be valid, n' tha ones all up in tha edges is ghon be unused\&. This same thang will arise as tha map grows: available map pointers, if any, is ghon be on tha ends\& fo' realz. As freshly smoked up nodes is pimped, only a subset of tha mapz pointas need ta be copied \fIoutward\fP\&.
.PP
Class invariants:
.IP "\(bu" 2
For any nonsingular iterator i:
.IP "  \(bu" 4
i\&.node points ta a gangmember of tha map array\&. (Yes, you read dat erectly: i\&.node do not straight-up point ta a node\&.) Da gangmember of tha map array is what tha fuck straight-up points ta tha node\&.
.IP "  \(bu" 4
i\&.first == *(i\&.node) (This points ta tha node (first Tp element)\&.)
.IP "  \(bu" 4
i\&.last == i\&.first + node_size
.IP "  \(bu" 4
i\&.cur be a pointa up in tha range [i\&.first, i\&.last)\&. NOTE: tha implication of dis is dat i\&.cur be always a thugged-out dereferenceable pointer, even if i be a past-the-end iterator\&.
.PP

.IP "\(bu" 2
Start n' Finish is always nonsingular iterators\&. NOTE: dis means dat a empty deque must have one node, a thugged-out deque wit <N elements (where N is tha node buffer size) must have one node, a thugged-out deque wit N all up in (2N-1) elements must have two nodes, etc\&.
.IP "\(bu" 2
For every last muthafuckin node other than start\&.node n' finish\&.node, every last muthafuckin element up in tha node be a initialized object\&. If start\&.node == finish\&.node, then [start\&.cur, finish\&.cur) is initialized objects, n' tha elements outside dat range is uninitialized storage\&. Otherwise, [start\&.cur, start\&.last) n' [finish\&.first, finish\&.cur) is initialized objects, n' [start\&.first, start\&.cur) n' [finish\&.cur, finish\&.last) is uninitialized storage\&.
.IP "\(bu" 2
[map, map + map_size) be a valid, non-empty range\&.
.IP "\(bu" 2
[start\&.node, finish\&.node] be a valid range contained within [map, map + map_size)\&.
.IP "\(bu" 2
A pointa up in tha range [map, map + map_size) points ta a allocated node if n' only if tha pointa is up in tha range [start\&.node, finish\&.node]\&.
.PP
Herez tha magic: not a god damn thang up in deque is \fBaware\fP of tha discontiguous storage!
.PP
Da memory setup n' layout occurs up in tha parent, _Base, n' tha iterator class is entirely responsible fo' \fIleaping\fP from one node ta tha next\& fo' realz. All tha implementation routines fo' deque itself work only all up in tha start n' finish iterators\&. This keeps tha routines simple n' sane, n' we can use other standard algorithms as well\&. 
.PP

.PP
Definizzle at line 730 of file stl_deque\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP ()\fC [inline]\fP"

.PP
Default constructor creates no elements\&. 
.PP
Definizzle at line 782 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP (const allocator_type &__a)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Creates a thugged-out deque wit no elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator object\&. 
.RE
.PP

.PP
Definizzle at line 790 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP (size_type__n)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Creates a thugged-out deque wit default constructed elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da number of elements ta initially create\&.
.RE
.PP
This constructor fills tha deque wit \fIn\fP default constructed elements\&. 
.PP
Definizzle at line 802 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP (size_type__n, const value_type &__value, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP"

.PP
Creates a thugged-out deque wit copiez of a exemplar element\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da number of elements ta initially create\&. 
.br
\fI__value\fP An element ta copy\&. 
.br
\fI__a\fP An allocator\&.
.RE
.PP
This constructor fills tha deque wit \fI__n\fP copiez of \fI__value\fP\&. 
.PP
Definizzle at line 814 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::_M_fill_initialize()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP (const \fBdeque\fP< _Tp, _Alloc > &__x)\fC [inline]\fP"

.PP
Deque copy constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A deque of identical element n' allocator types\&.
.RE
.PP
Da newly-created deque uses a cold-ass lil copy of tha allocation object used by \fI__x\fP\&. 
.PP
Definizzle at line 841 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::begin(), n' std::deque< _Tp, _Alloc >::end()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP (\fBdeque\fP< _Tp, _Alloc > &&__x)\fC [inline]\fP"

.PP
Deque move constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A deque of identical element n' allocator types\&.
.RE
.PP
Da newly-created deque gotz nuff tha exact contentz of \fI__x\fP\&. Da contentz of \fI__x\fP is a valid yo, but unspecified deque\&. 
.PP
Definizzle at line 855 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP (\fBinitializer_list\fP< value_type >__l, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP"

.PP
Buildz a thugged-out deque from a initializer list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list\&. 
.br
\fI__a\fP An allocator object\&.
.RE
.PP
Smoke a thugged-out deque consistin of copiez of tha elements up in tha initializer_list \fI__l\fP\&.
.PP
This will call tha element typez copy constructor N times (where N is __l\&.size()) n' do no memory reallocation\&. 
.PP
Definizzle at line 869 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::_M_range_initialize()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP (_InputIterator__first, _InputIterator__last, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP"

.PP
Buildz a thugged-out deque from a range\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&. 
.br
\fI__a\fP An allocator object\&.
.RE
.PP
Smoke a thugged-out deque consistin of copiez of tha elements from [__first, __last)\&.
.PP
If tha iterators is forward, bidirectional, or random-access, then dis will call tha elements' copy constructor N times (where N is distance(__first,__last)) n' do no memory reallocation\&. But if only input iterators is used, then dis will do at most 2N calls ta tha copy constructor, n' logN memory reallocations\&. 
.PP
Definizzle at line 896 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::~\fBdeque\fP ()\fC [inline]\fP, \fC [noexcept]\fP"
Da dtor only erases tha elements, n' note dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 917 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::begin(), n' std::deque< _Tp, _Alloc >::end()\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp , typename _Alloc > void deque::_M_fill_initialize (const value_type &__value)\fC [protected]\fP"

.PP
Fills tha deque wit copiez of value\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__value\fP Initial value\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing\&. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
_M_start n' _M_finish have already been initialized yo, but none of tha dequez elements have yet been constructed\&.
.RE
.PP
This function is called only when tha user serves up a explicit size (with or without a explicit exemplar value)\&. 
.PP
Definizzle at line 351 of file deque\&.tcc\&.
.PP
References std::_Destroy()\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::deque()\&.
.SS "template<typename _Tp , typename _Alloc > void \fBstd::_Deque_base\fP< _Tp, _Alloc >::_M_initialize_map (size_t__num_elements)\fC [protected]\fP, \fC [inherited]\fP"

.PP
Layout storage\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__num_elements\fP Da count of Tz fo' which ta allocate space at first\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing\&.
.RE
.PP
Da initial underlyin memory layout be a lil' bit fucked up\&.\&.\&. 
.PP
Definizzle at line 582 of file stl_deque\&.h\&.
.PP
References std::max()\&.
.SS "template<typename _Tp , typename _Alloc > void deque::_M_new_elements_at_back (size_type__new_elements)\fC [protected]\fP"

.PP
Memory-handlin helpers fo' tha previous internal bang functions\&. 
.PP
Definizzle at line 849 of file deque\&.tcc\&.
.PP
References std::size()\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::_M_reserve_elements_at_back()\&.
.SS "template<typename _Tp , typename _Alloc > void deque::_M_new_elements_at_front (size_type__new_elements)\fC [protected]\fP"

.PP
Memory-handlin helpers fo' tha previous internal bang functions\&. 
.PP
Definizzle at line 824 of file deque\&.tcc\&.
.PP
References std::size()\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::_M_reserve_elements_at_front()\&.
.SS "template<typename _Tp , typename _Alloc > void deque::_M_pop_back_aux ()\fC [protected]\fP"

.PP
Helper functions fo' push_* n' pop_*\&. 
.PP
Definizzle at line 505 of file deque\&.tcc\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::pop_back()\&.
.SS "template<typename _Tp , typename _Alloc > void deque::_M_pop_front_aux ()\fC [protected]\fP"

.PP
Helper functions fo' push_* n' pop_*\&. 
.PP
Definizzle at line 520 of file deque\&.tcc\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::pop_front()\&.
.SS "template<typename _Tp , typename _Alloc > template<typename\&.\&.\&. _Args> void deque::_M_push_back_aux (_Args &&\&.\&.\&.__args)\fC [protected]\fP"

.PP
Helper functions fo' push_* n' pop_*\&. 
.PP
Definizzle at line 439 of file deque\&.tcc\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::push_back()\&.
.SS "template<typename _Tp , typename _Alloc > template<typename\&.\&.\&. _Args> void deque::_M_push_front_aux (_Args &&\&.\&.\&.__args)\fC [protected]\fP"

.PP
Helper functions fo' push_* n' pop_*\&. 
.PP
Definizzle at line 473 of file deque\&.tcc\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::push_front()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::_M_range_check (size_type__n) const\fC [inline]\fP, \fC [protected]\fP"

.PP
Safety check used only from at()\&. 
.PP
Definizzle at line 1265 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::size()\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::at()\&.
.SS "template<typename _Tp , typename _Alloc > template<typename _InputIterator > void deque::_M_range_initialize (_InputIterator__first, _InputIterator__last, \fBstd::input_iterator_tag\fP)\fC [protected]\fP"

.PP
Fills tha deque wit whatever is up in [first,last)\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing\&.
.RE
.PP
If tha iterators is straight-up forward iterators (or better), then tha memory layout can be done all at once\&. Else we move forward rockin push_back on each value from tha iterator\&. 
.PP
Definizzle at line 377 of file deque\&.tcc\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::deque()\&.
.SS "template<typename _Tp , typename _Alloc > template<typename _ForwardIterator > void deque::_M_range_initialize (_ForwardIterator__first, _ForwardIterator__last, \fBstd::forward_iterator_tag\fP)\fC [protected]\fP"

.PP
Fills tha deque wit whatever is up in [first,last)\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing\&.
.RE
.PP
If tha iterators is straight-up forward iterators (or better), then tha memory layout can be done all at once\&. Else we move forward rockin push_back on each value from tha iterator\&. 
.PP
Definizzle at line 401 of file deque\&.tcc\&.
.PP
References std::_Destroy(), std::advance(), n' std::distance()\&.
.SS "template<typename _Tp , typename _Alloc > void deque::_M_reallocate_map (size_type__nodes_to_add, bool__add_at_front)\fC [protected]\fP"

.PP
Memory-handlin helpers fo' tha major map\&. Makes shizzle tha _M_map has space fo' freshly smoked up nodes\&. Do not straight-up add tha nodes\&. Can invalidate _M_map pointers\&. (And consequently, deque iterators\&.) 
.PP
Definizzle at line 874 of file deque\&.tcc\&.
.PP
References std::max()\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::_M_reserve_map_at_back(), n' std::deque< _Tp, _Alloc >::_M_reserve_map_at_front()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::deque\fP< _Tp, _Alloc >::_M_reserve_elements_at_back (size_type__n)\fC [inline]\fP, \fC [protected]\fP"

.PP
Memory-handlin helpers fo' tha previous internal bang functions\&. 
.PP
Definizzle at line 1898 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::_M_new_elements_at_back()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::deque\fP< _Tp, _Alloc >::_M_reserve_elements_at_front (size_type__n)\fC [inline]\fP, \fC [protected]\fP"

.PP
Memory-handlin helpers fo' tha previous internal bang functions\&. 
.PP
Definizzle at line 1888 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::_M_new_elements_at_front()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::_M_reserve_map_at_back (size_type__nodes_to_add = \fC1\fP)\fC [inline]\fP, \fC [protected]\fP"

.PP
Memory-handlin helpers fo' tha major map\&. Makes shizzle tha _M_map has space fo' freshly smoked up nodes\&. Do not straight-up add tha nodes\&. Can invalidate _M_map pointers\&. (And consequently, deque iterators\&.) 
.PP
Definizzle at line 1924 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::_M_reallocate_map()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::_M_reserve_map_at_front (size_type__nodes_to_add = \fC1\fP)\fC [inline]\fP, \fC [protected]\fP"

.PP
Memory-handlin helpers fo' tha major map\&. Makes shizzle tha _M_map has space fo' freshly smoked up nodes\&. Do not straight-up add tha nodes\&. Can invalidate _M_map pointers\&. (And consequently, deque iterators\&.) 
.PP
Definizzle at line 1932 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::_M_reallocate_map()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::assign (size_type__n, const value_type &__val)\fC [inline]\fP"

.PP
Assigns a given value ta a thugged-out deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Number of elements ta be assigned\&. 
.br
\fI__val\fP Value ta be assigned\&.
.RE
.PP
This function fills a thugged-out deque wit \fIn\fP copiez of tha given value\&. Note dat tha assignment straight-up chizzlez tha deque n' dat tha resultin dequez size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 978 of file stl_deque\&.h\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::assign(), n' std::deque< _Tp, _Alloc >::operator=()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> void \fBstd::deque\fP< _Tp, _Alloc >::assign (_InputIterator__first, _InputIterator__last)\fC [inline]\fP"

.PP
Assigns a range ta a thugged-out deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&.
.RE
.PP
This function fills a thugged-out deque wit copiez of tha elements up in tha range [__first,__last)\&.
.PP
Note dat tha assignment straight-up chizzlez tha deque n' dat tha resultin dequez size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 997 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::assign (\fBinitializer_list\fP< value_type >__l)\fC [inline]\fP"

.PP
Assigns a initializer list ta a thugged-out deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list\&.
.RE
.PP
This function fills a thugged-out deque wit copiez of tha elements up in tha initializer_list \fI__l\fP\&.
.PP
Note dat tha assignment straight-up chizzlez tha deque n' dat tha resultin dequez size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 1022 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::assign()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::deque\fP< _Tp, _Alloc >::at (size_type__n)\fC [inline]\fP"

.PP
Provides access ta tha data contained up in tha deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha element fo' which data should be accessed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read/write reference ta data\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fI__n\fP be a invalid index\&.
.RE
.PP
This function serves up fo' less thuggy data access\&. Da parameta is first checked dat it is up in tha range of tha deque\&. Da function throws out_of_range if tha check fails\&. 
.PP
Definizzle at line 1284 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::_M_range_check()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::deque\fP< _Tp, _Alloc >::at (size_type__n) const\fC [inline]\fP"

.PP
Provides access ta tha data contained up in tha deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha element fo' which data should be accessed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) reference ta data\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fI__n\fP be a invalid index\&.
.RE
.PP
This function serves up fo' less thuggy data access\&. Da parameta is first checked dat it is up in tha range of tha deque\&. Da function throws out_of_range if tha check fails\&. 
.PP
Definizzle at line 1302 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::_M_range_check()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::deque\fP< _Tp, _Alloc >::back ()\fC [inline]\fP"
Returns a read/write reference ta tha data all up in tha last element of tha deque\&. 
.PP
Definizzle at line 1329 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::end()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::deque\fP< _Tp, _Alloc >::back () const\fC [inline]\fP"
Returns a read-only (constant) reference ta tha data all up in tha last element of tha deque\&. 
.PP
Definizzle at line 1341 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::end()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::deque\fP< _Tp, _Alloc >::begin ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write iterator dat points ta tha straight-up original gangsta element up in tha deque\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 1037 of file stl_deque\&.h\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::clear(), std::deque< _Tp, _Alloc >::deque(), std::deque< _Tp, _Alloc >::front(), std::deque< _Tp, _Alloc >::operator=(), std::operator==(), n' std::deque< _Tp, _Alloc >::~deque()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::begin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points ta tha straight-up original gangsta element up in tha deque\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 1045 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::cbegin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points ta tha straight-up original gangsta element up in tha deque\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 1108 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::cend () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points one past tha last element up in tha deque\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 1117 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::clear ()\fC [inline]\fP, \fC [noexcept]\fP"
Erases all tha elements\&. Note dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 1616 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::begin()\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::operator=()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::crbegin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta tha last element up in tha deque\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 1126 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::crend () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta one before tha straight-up original gangsta element up in tha deque\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 1135 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename\&.\&.\&. _Args> \fBiterator\fP \fBstd::deque\fP< _Tp, _Alloc >::emplace (\fBiterator\fP__position, _Args &&\&.\&.\&.__args)"

.PP
Inserts a object up in deque before specified iterator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha deque\&. 
.br
\fI__args\fP Arguments\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha banged data\&.
.RE
.PP
This function will bang a object of type T constructed wit T(std::forward<Args>(args)\&.\&.\&.) before tha specified location\&. 
.PP
Referenced by std::deque< _Tp, _Alloc >::insert()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> bool \fBstd::deque\fP< _Tp, _Alloc >::empty () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns legit if tha deque is empty\&. (Thus begin() would equal end()\&.) 
.PP
Definizzle at line 1228 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::deque\fP< _Tp, _Alloc >::end ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write iterator dat points one past tha last element up in tha deque\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 1054 of file stl_deque\&.h\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::back(), std::deque< _Tp, _Alloc >::deque(), std::deque< _Tp, _Alloc >::operator=(), std::operator==(), n' std::deque< _Tp, _Alloc >::~deque()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::end () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points one past tha last element up in tha deque\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 1063 of file stl_deque\&.h\&.
.SS "template<typename _Tp , typename _Alloc > \fBdeque\fP< _Tp, _Alloc >::\fBiterator\fP deque::erase (\fBiterator\fP__position)"

.PP
Remove element at given position\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP Iterator pointin ta element ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator pointin ta tha next element (or end())\&.
.RE
.PP
This function will erase tha element all up in tha given posizzle n' thus shorten tha deque by one\&.
.PP
Da user is cautioned dat dis function only erases tha element, n' dat if tha element is itself a pointer, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 194 of file deque\&.tcc\&.
.PP
References std::begin(), std::end(), n' std::size()\&.
.SS "template<typename _Tp , typename _Alloc > \fBdeque\fP< _Tp, _Alloc >::\fBiterator\fP deque::erase (\fBiterator\fP__first, \fBiterator\fP__last)"

.PP
Remove a range of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP Iterator pointin ta tha straight-up original gangsta element ta be erased\&. 
.br
\fI__last\fP Iterator pointin ta one past tha last element ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator pointin ta tha element pointed ta by \fIlast\fP prior ta erasin (or end())\&.
.RE
.PP
This function will erase tha elements up in tha range [__first,__last) n' shorten tha deque accordingly\&.
.PP
Da user is cautioned dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 217 of file deque\&.tcc\&.
.PP
References std::begin(), std::end(), n' std::size()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::deque\fP< _Tp, _Alloc >::front ()\fC [inline]\fP"
Returns a read/write reference ta tha data all up in tha straight-up original gangsta element of tha deque\&. 
.PP
Definizzle at line 1313 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::begin()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::deque\fP< _Tp, _Alloc >::front () const\fC [inline]\fP"
Returns a read-only (constant) reference ta tha data all up in tha straight-up original gangsta element of tha deque\&. 
.PP
Definizzle at line 1321 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::begin()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> allocator_type \fBstd::deque\fP< _Tp, _Alloc >::get_allocator () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Git a cold-ass lil copy of tha memory allocation object\&. 
.PP
Definizzle at line 1028 of file stl_deque\&.h\&.
.SS "template<typename _Tp , typename _Alloc > \fBdeque\fP< _Tp, _Alloc >::\fBiterator\fP deque::insert (\fBiterator\fP__position, const value_type &__x)"

.PP
Inserts given value tha fuck into deque before specified iterator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha deque\&. 
.br
\fI__x\fP Data ta be inserted\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha banged data\&.
.RE
.PP
This function will bang a cold-ass lil copy of tha given value before tha specified location\&. 
.PP
Definizzle at line 149 of file deque\&.tcc\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::insert(), n' std::deque< _Tp, _Alloc >::resize()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::deque\fP< _Tp, _Alloc >::insert (\fBiterator\fP__position, value_type &&__x)\fC [inline]\fP"

.PP
Inserts given rvalue tha fuck into deque before specified iterator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha deque\&. 
.br
\fI__x\fP Data ta be inserted\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha banged data\&.
.RE
.PP
This function will bang a cold-ass lil copy of tha given rvalue before tha specified location\&. 
.PP
Definizzle at line 1492 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::emplace()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::insert (\fBiterator\fP__p, \fBinitializer_list\fP< value_type >__l)\fC [inline]\fP"

.PP
Inserts a initializer list tha fuck into tha deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__p\fP An iterator tha fuck into tha deque\&. 
.br
\fI__l\fP An initializer_list\&.
.RE
.PP
This function will bang copiez of tha data up in tha initializer_list \fI__l\fP tha fuck into tha deque before tha location specified by \fI__p\fP\&. This is known as \fIlist insert\fP\&. 
.PP
Definizzle at line 1505 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::insert()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::insert (\fBiterator\fP__position, size_type__n, const value_type &__x)\fC [inline]\fP"

.PP
Inserts a fuckin shitload of copiez of given data tha fuck into tha deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha deque\&. 
.br
\fI__n\fP Number of elements ta be inserted\&. 
.br
\fI__x\fP Data ta be inserted\&.
.RE
.PP
This function will bang a specified number of copiez of tha given data before tha location specified by \fI__position\fP\&. 
.PP
Definizzle at line 1519 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator , typename  = std::_RequireInputIter<_InputIterator>> void \fBstd::deque\fP< _Tp, _Alloc >::insert (\fBiterator\fP__position, _InputIterator__first, _InputIterator__last)\fC [inline]\fP"

.PP
Inserts a range tha fuck into tha deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha deque\&. 
.br
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&.
.RE
.PP
This function will bang copiez of tha data up in tha range [__first,__last) tha fuck into tha deque before tha location specified by \fI__position\fP\&. This is known as \fIrange insert\fP\&. 
.PP
Definizzle at line 1536 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::deque\fP< _Tp, _Alloc >::max_size () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns tha size() of tha phattest possible deque\&. 
.PP
Definizzle at line 1147 of file stl_deque\&.h\&.
.SS "template<typename _Tp , typename _Alloc > \fBdeque\fP< _Tp, _Alloc > & deque::operator= (const \fBdeque\fP< _Tp, _Alloc > &__x)"

.PP
Deque assignment operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A deque of identical element n' allocator types\&.
.RE
.PP
All tha elementz of \fIx\fP is copied yo, but unlike tha copy constructor, tha allocator object aint copied\&. 
.PP
Definizzle at line 93 of file deque\&.tcc\&.
.PP
References std::deque< _Tp, _Alloc >::begin(), std::deque< _Tp, _Alloc >::end(), std::deque< _Tp, _Alloc >::size(), n' std::size()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBdeque\fP& \fBstd::deque\fP< _Tp, _Alloc >::operator= (\fBdeque\fP< _Tp, _Alloc > &&__x)\fC [inline]\fP"

.PP
Deque move assignment operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A deque of identical element n' allocator types\&.
.RE
.PP
Da contentz of \fI__x\fP is moved tha fuck into dis deque (without copying)\&. \fI__x\fP be a valid yo, but unspecified deque\&. 
.PP
Definizzle at line 939 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::clear(), n' std::deque< _Tp, _Alloc >::swap()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBdeque\fP& \fBstd::deque\fP< _Tp, _Alloc >::operator= (\fBinitializer_list\fP< value_type >__l)\fC [inline]\fP"

.PP
Assigns a initializer list ta a thugged-out deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list\&.
.RE
.PP
This function fills a thugged-out deque wit copiez of tha elements up in tha initializer_list \fI__l\fP\&.
.PP
Note dat tha assignment straight-up chizzlez tha deque n' dat tha resultin dequez size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 960 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::assign()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::deque\fP< _Tp, _Alloc >::operator[] (size_type__n)\fC [inline]\fP"

.PP
Subscript access ta tha data contained up in tha deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha element fo' which data should be accessed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read/write reference ta data\&.
.RE
.PP
This operator allows fo' easy as fuck , array-style, data access\&. Note dat data access wit dis operator is unchecked n' out_of_range lookups is not defined\&. (For checked lookups peep at()\&.) 
.PP
Definizzle at line 1244 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::deque\fP< _Tp, _Alloc >::operator[] (size_type__n) const\fC [inline]\fP"

.PP
Subscript access ta tha data contained up in tha deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha element fo' which data should be accessed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) reference ta data\&.
.RE
.PP
This operator allows fo' easy as fuck , array-style, data access\&. Note dat data access wit dis operator is unchecked n' out_of_range lookups is not defined\&. (For checked lookups peep at()\&.) 
.PP
Definizzle at line 1259 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::pop_back ()\fC [inline]\fP"

.PP
Removes last element\&. This be a typical stack operation\&. Well shiiiit, it shrinks tha deque by one\&.
.PP
Note dat no data is returned, n' if tha last elementz data is needed, it should be retrieved before pop_back() is called\&. 
.PP
Definizzle at line 1442 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::_M_pop_back_aux()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::pop_front ()\fC [inline]\fP"

.PP
Removes first element\&. This be a typical stack operation\&. Well shiiiit, it shrinks tha deque by one\&.
.PP
Note dat no data is returned, n' if tha straight-up original gangsta elementz data is needed, it should be retrieved before pop_front() is called\&. 
.PP
Definizzle at line 1421 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::_M_pop_front_aux()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::push_back (const value_type &__x)\fC [inline]\fP"

.PP
Add data ta tha end of tha deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Data ta be added\&.
.RE
.PP
This be a typical stack operation\&. Da function creates a element all up in tha end of tha deque n' assigns tha given data ta it\&. Cuz of tha nature of a thugged-out deque dis operation can be done up in constant time\&. 
.PP
Definizzle at line 1390 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::_M_push_back_aux()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::push_front (const value_type &__x)\fC [inline]\fP"

.PP
Add data ta tha front of tha deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Data ta be added\&.
.RE
.PP
This be a typical stack operation\&. Da function creates a element all up in tha front of tha deque n' assigns tha given data ta it\&. Cuz of tha nature of a thugged-out deque dis operation can be done up in constant time\&. 
.PP
Definizzle at line 1359 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::_M_push_front_aux()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBreverse_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::rbegin ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write reverse iterator dat points ta tha last element up in tha deque\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 1072 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::rbegin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta tha last element up in tha deque\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 1081 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBreverse_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::rend ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write reverse iterator dat points ta one before tha straight-up original gangsta element up in tha deque\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 1090 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::rend () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta one before tha straight-up original gangsta element up in tha deque\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 1099 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::resize (size_type__new_size)\fC [inline]\fP"

.PP
Resizes tha deque ta tha specified number of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__new_size\fP Number of elements tha deque should contain\&.
.RE
.PP
This function will resize tha deque ta tha specified number of elements\&. If tha number is smalla than tha dequez current size tha deque is truncated, otherwise default constructed elements is appended\&. 
.PP
Definizzle at line 1161 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::size()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::resize (size_type__new_size, const value_type &__x)\fC [inline]\fP"

.PP
Resizes tha deque ta tha specified number of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__new_size\fP Number of elements tha deque should contain\&. 
.br
\fI__x\fP Data wit which freshly smoked up elements should be populated\&.
.RE
.PP
This function will resize tha deque ta tha specified number of elements\&. If tha number is smalla than tha dequez current size tha deque is truncated, otherwise tha deque is extended n' freshly smoked up elements is populated wit given data\&. 
.PP
Definizzle at line 1183 of file stl_deque\&.h\&.
.PP
References std::deque< _Tp, _Alloc >::insert(), n' std::deque< _Tp, _Alloc >::size()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::shrink_to_fit ()\fC [inline]\fP"
A non-bindin request ta reduce memory use\&. 
.PP
Definizzle at line 1219 of file stl_deque\&.h\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::deque\fP< _Tp, _Alloc >::size () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns tha number of elements up in tha deque\&. 
.PP
Definizzle at line 1142 of file stl_deque\&.h\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::_M_range_check(), std::deque< _Tp, _Alloc >::operator=(), std::operator==(), n' std::deque< _Tp, _Alloc >::resize()\&.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::swap (\fBdeque\fP< _Tp, _Alloc > &__x)\fC [inline]\fP"

.PP
Swaps data wit another deque\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A deque of tha same element n' allocator types\&.
.RE
.PP
This exchanges tha elements between two deques up in constant time\&. (Four pointers, so it should be like fast\&.) Note dat tha global std::swap() function is specialized such dat std::swap(d1,d2) will feed ta dis function\&. 
.PP
Definizzle at line 1596 of file stl_deque\&.h\&.
.PP
Referenced by std::deque< _Tp, _Alloc >::operator=(), n' std::swap()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
