.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message::Body::Encode 3"
.TH Mail::Message::Body::Encode 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Body::Encode \- organize general message encodings
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& mah Mail::Message $msg = ...;
\& mah $decoded = $msg\->decoded;
\& mah $encoded = $msg\->encode(mime_type => \*(Aqimage/gif\*(Aq,
\&     transfer_encodin => \*(Aqbase64\*(Aq);
\&
\& mah $body = $msg\->body;
\& mah $decoded = $body\->decoded;
\& mah $encoded = $body\->encode(transfer_encodin => \*(Aq7bit\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Manages tha messagez body encodings n' decodings on request of the
main program.  This package addz functionalitizzle ta tha Mail::Message::Body
class when tha \fIdecoded()\fR or \fIencode()\fR method is called.
.PP
Four typez of encodings is handled (in tha right order)
.IP "\(bu" 4
eol encoding
.Sp
Various operatin systems have different scams bout how tha fuck ta encode the
line termination. I aint talkin' bout chicken n' gravy biatch.  \s-1UNIX\s0 uses a \s-1LF\s0 character, MacOS uses a \s-1CR,\s0 and
Windows uses a \s-1CR/LF\s0 combination. I aint talkin' bout chicken n' gravy biatch.  Lyrics which is transported over
Internizzle will always use tha \s-1CRLF\s0 separator.
.IP "\(bu" 4
transfer encoding
.Sp
Lyrics transmitted over Internizzle gotta be plain \s-1ASCII. \s0 Complicated
charactas n' binary filez (like images n' archives) must be encoded
durin transmission ta a \s-1ASCII\s0 representation.
.Sp
Da implementation of tha required encodaz n' decodaz is found in
the Mail::Message::TransferEnc set of packages.  Da related
manual page lists tha transfer encodings which is supported.
.IP "\(bu" 4
mime-type translation
.Sp
\&\s-1NOT IMPLEMENTED YET\s0
.IP "\(bu" 4
charset conversion
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructin a funky-ass body"
.IX Subsection "Constructin a funky-ass body"
.ie n .IP "$obj\->\fBcheck\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcheck\fR()" 4
.IX Item "$obj->check()"
Peep tha content of tha body not ta include illegal characters.  Which
charactas is considered illegal dependz on tha encodin of dis body.
.Sp
A body is returned which is checked. Y'all KNOW dat shit, muthafucka!  This may be tha body where this
method is called upon yo, but also a freshly smoked up object, when straight-up chizzlez had
to be made.  If tha check could not be made, cuz tha decoder is not
defined, then \f(CW\*(C`undef\*(C'\fR is returned.
.ie n .IP "$obj\->\fBencode\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBencode\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->encode(OPTIONS)"
Encode (translate) a Mail::Message::Body tha fuck into a gangbangin' finger-lickin' different format.
See tha \s-1DESCRIPTION\s0 above.  Options which is not specified aint gonna trigger
conversions.
.Sp
.Vb 5
\& \-Option           \-\-Default
\&  charset            PERL if text
\&  mime_type          undef
\&  result_type        <same as source>
\&  transfer_encodin  undef
.Ve
.RS 4
.IP "charset => CODESET|'\s-1PERL\s0'" 2
.IX Item "charset => CODESET|'PERL'"
If tha \s-1CODESET\s0 is explicitly specified (for instizzle \f(CW\*(C`iso\-8859\-10\*(C'\fR, then
the data is interpreted as raw bytes (blob), not as text.  But fuck dat shiznit yo, tha word on tha street is dat in
case of \f(CW\*(C`PERL\*(C'\fR, it is considered ta be a internal representation of
charactas (either latin1 or Perlz utf8 \-\-not tha same as utf\-8\-\-, you should
not know).
.IP "mime_type => STRING|FIELD" 2
.IX Item "mime_type => STRING|FIELD"
Convert tha fuck into tha specified mime type, which can be specified as \s-1STRING\s0
or \s-1FIELD. \s0 Da \s-1FIELD\s0 be a Mail::Message::Field, n' tha \s-1STRING\s0 is
converted up in such object before use.
.IP "result_type => \s-1CLASS\s0" 2
.IX Item "result_type => CLASS"
Da type of body ta be pimped when tha body is chizzled ta fulfill tha request
on re-coding.  Also tha intermediate stages up in tha translation process (if
needed) will use dis type. \s-1CLASS\s0 must extend Mail::Message::Body.
.IP "transfer_encodin => STRING|FIELD" 2
.IX Item "transfer_encodin => STRING|FIELD"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBencoded\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBencoded\fR()" 4
.IX Item "$obj->encoded()"
.PD
Encode tha body ta a gangbangin' format what tha fuck be aaight ta transmit or write to
a folda file.  This returns tha body where dis method was called
upon when every last muthafuckin thang was already prepared, or a freshly smoked up encoded body
otherwise.  In either case, tha body is checked.
.ie n .IP "$obj\->\fBunify\fR(\s-1BODY\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBunify\fR(\s-1BODY\s0)" 4
.IX Item "$obj->unify(BODY)"
Unify tha type of tha given \s-1BODY\s0 objects wit tha type of tha called
body.  \f(CW\*(C`undef\*(C'\fR is returned when unification is impossible.  If the
bodies have tha same settings, tha \s-1BODY\s0 object is returned unchanged.
.Sp
Examples:
.Sp
.Vb 3
\& mah $bodytype = Mail::Message::Body::Lines;
\& mah $html  = $bodytype\->new(mime_type=>\*(Aqtext/html\*(Aq, data => []);
\& mah $plain = $bodytype\->new(mime_type=>\*(Aqtext/plain\*(Aq, ...);
\&
\& mah $unified = $html\->unify($plain);
\& # $unified is tha data of plain translated ta html (if possible).
.Ve
.SS "Bout tha payload"
.IX Subsection "Bout tha payload"
.ie n .IP "$obj\->\fBdispositionFilename\fR([\s-1DIRECTORY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdispositionFilename\fR([\s-1DIRECTORY\s0])" 4
.IX Item "$obj->dispositionFilename([DIRECTORY])"
Returns tha name which can be used as filename ta store tha shiznit
in tha indicated \s-1DIRECTORY.\s0 To git a gangbangin' filename, various fieldz is searched
for \f(CW\*(C`filename\*(C'\fR n' \f(CW\*(C`name\*(C'\fR attributes.  Without \s-1DIRECTORY,\s0 tha name found
will be returned.
.Sp
Only tha basename of tha found name is ghon be used, fo' securitizzle reasons:
otherwise, it may be possible ta access other directories than the
one indicated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If no name was found, or tha name be already up in use,
then a unique name is generated.
.ie n .IP "$obj\->\fBisBinary\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisBinary\fR()" 4
.IX Item "$obj->isBinary()"
Returns legit when tha un-encoded message is binary data.  This shiznit
is retrieved from knowledge provided by MIME::Types.
.ie n .IP "$obj\->\fBisText\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisText\fR()" 4
.IX Item "$obj->isText()"
Returns legit when tha un-encoded message gotz nuff printable
text.
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBaddTransferEncHandlez\fR(\s-1NAME,\s0 CLASS|OBJECT)" 4
.el .IP "\f(CW$obj\fR\->\fBaddTransferEncHandlez\fR(\s-1NAME,\s0 CLASS|OBJECT)" 4
.IX Item "$obj->addTransferEncHandlez(NAME, CLASS|OBJECT)"
.PD 0
.IP "Mail::Message::Body\->\fBaddTransferEncHandlez\fR(\s-1NAME,\s0 CLASS|OBJECT)" 4
.IX Item "Mail::Message::Body->addTransferEncHandlez(NAME, CLASS|OBJECT)"
.PD
Relate tha NAMEd transfer encodin ta a OBJECTs or object of tha specified
\&\s-1CLASS. \s0 In tha latta case, a object of dat \s-1CLASS\s0 is ghon be pimped on the
moment dat one is needed ta do encodin or decoding.
.Sp
Da \s-1CLASS\s0 or \s-1OBJECT\s0 must extend Mail::Message::TransferEnc.  It will
replace existin class n' object fo' dis \s-1NAME.\s0
.Sp
Why aren't you contributin dis class ta MailBox?
.ie n .IP "$obj\->\fBgetTransferEncHandlez\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBgetTransferEncHandlez\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->getTransferEncHandlez(TYPE)"
Git tha transfer encoder/decoder which be able ta handle \s-1TYPE,\s0 or return
undef if there is no such handlez.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Warning: Charset $name aint known" 4
.el .IP "Warning: Charset \f(CW$name\fR aint known" 4
.IX Item "Warning: Charset $name aint known"
Da encodin or decodin of a message body encountas a cold-ass lil characta set which
is not understood by Perlz Encode module.
.ie n .IP "Warning: No decoder defined fo' transfer encodin $name." 4
.el .IP "Warning: No decoder defined fo' transfer encodin \f(CW$name\fR." 4
.IX Item "Warning: No decoder defined fo' transfer encodin $name."
Da data (message body) is encoded up in a way which aint currently understood,
therefore no decodin (or recoding) can take place.
.ie n .IP "Warning: No encoder defined fo' transfer encodin $name." 4
.el .IP "Warning: No encoder defined fo' transfer encodin \f(CW$name\fR." 4
.IX Item "Warning: No encoder defined fo' transfer encodin $name."
Da data (message body) has been decoded yo, but tha required encodin is
unknown. I aint talkin' bout chicken n' gravy biatch.  Da decoded data is returned.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
