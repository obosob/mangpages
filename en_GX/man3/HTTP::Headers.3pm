.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Headaz 3"
.TH HTTP::Headaz 3 "2012-10-20" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Headaz \- Class encapsulatin HTTP Message headers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& require HTTP::Headers;
\& $h = HTTP::Headers\->new;
\&
\& $h\->header(\*(AqContent\-Type\*(Aq => \*(Aqtext/plain\*(Aq);  # set
\& $ct = $h\->header(\*(AqContent\-Type\*(Aq);            # get
\& $h\->remove_header(\*(AqContent\-Type\*(Aq);           # delete
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`HTTP::Headers\*(C'\fR class encapsulates HTTP-style message headers.
Da headaz consist of attribute-value pairs also called fields, which
may be repeated, n' which is printed up in a particular order n' shit.  The
field names is cases insensitive.
.PP
Instancez of dis class is probably pimped as member variablez of the
\&\f(CW\*(C`HTTP::Request\*(C'\fR n' \f(CW\*(C`HTTP::Response\*(C'\fR classes, internal ta the
library.
.PP
Da followin methodz is available:
.ie n .IP "$h = HTTP::Headers\->new" 4
.el .IP "\f(CW$h\fR = HTTP::Headers\->new" 4
.IX Item "$h = HTTP::Headers->new"
Constructs a freshly smoked up \f(CW\*(C`HTTP::Headers\*(C'\fR object.  Yo ass might pass some initial
attribute-value pairs as parametas ta tha constructor. Shiiit, dis aint no joke.  \fIE.g.\fR:
.Sp
.Vb 4
\& $h = HTTP::Headers\->new(
\&       Date         => \*(AqThu, 03 Feb 1994 00:00:00 GMT\*(Aq,
\&       Content_Type => \*(Aqtext/html; version=3.2\*(Aq,
\&       Content_Base => \*(Aqhttp://www.perl.org/\*(Aq);
.Ve
.Sp
Da constructor arguments is passed ta tha \f(CW\*(C`header\*(C'\fR method which is
busted lyrics bout below.
.ie n .IP "$h\->clone" 4
.el .IP "\f(CW$h\fR\->clone" 4
.IX Item "$h->clone"
Returns a cold-ass lil copy of dis \f(CW\*(C`HTTP::Headers\*(C'\fR object.
.ie n .IP "$h\->header( $field )" 4
.el .IP "\f(CW$h\fR\->header( \f(CW$field\fR )" 4
.IX Item "$h->header( $field )"
.PD 0
.ie n .IP "$h\->header( $field => $value )" 4
.el .IP "\f(CW$h\fR\->header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$h->header( $field => $value )"
.ie n .IP "$h\->header( $f1 => $v1, $f2 => $v2, ... )" 4
.el .IP "\f(CW$h\fR\->header( \f(CW$f1\fR => \f(CW$v1\fR, \f(CW$f2\fR => \f(CW$v2\fR, ... )" 4
.IX Item "$h->header( $f1 => $v1, $f2 => $v2, ... )"
.PD
Git or set tha value of one or mo' header fields.  Da header field
name ($field) aint case sensitive.  To make tha game easier fo' perl
users whoz ass wants ta avoid quotin before tha => operator, you can use
\&'_' as a replacement fo' '\-' up in header names.
.Sp
Da \fIheader()\fR method accepts multiple ($field => \f(CW$value\fR) pairs, which
means dat you can update nuff muthafuckin fieldz wit a single invocation.
.Sp
Da \f(CW$value\fR argument may be a plain strang or a reference ta a array
of strings fo' a multi-valued field. Y'all KNOW dat shit, muthafucka! If tha \f(CW$value\fR is provided as
\&\f(CW\*(C`undef\*(C'\fR then tha field is removed. Y'all KNOW dat shit, muthafucka!  If tha \f(CW$value\fR aint given, then
that header field will remain unchanged.
.Sp
Da oldschool value (or joints) of tha last of tha header fieldz is returned.
If no such field exists \f(CW\*(C`undef\*(C'\fR is ghon be returned.
.Sp
A multi-valued field is ghon be returned as separate joints up in list
context n' is ghon be concatenated wit \*(L", \*(R" as separator up in scalar
context.  Da \s-1HTTP\s0 spec (\s-1RFC 2616\s0) promise dat joinin multiple
values up in dis way aint gonna chizzle tha semantic of a header field yo, but
in practice there be cases like old-style Netscape dem scooby snacks (see
HTTP::Cookies) where \*(L",\*(R" is used as part of tha syntax of a single
field value.
.Sp
Examples:
.Sp
.Vb 6
\& $header\->header(MIME_Version => \*(Aq1.0\*(Aq,
\&                 User_Agent   => \*(AqMy\-Web\-Client/0.01\*(Aq);
\& $header\->header(Accept => "text/html, text/plain, image/*");
\& $header\->header(Accept => [qw(text/html text/plain image/*)]);
\& @accepts = $header\->header(\*(AqAccept\*(Aq);  # git multiple joints
\& $accepts = $header\->header(\*(AqAccept\*(Aq);  # git joints as a single string
.Ve
.ie n .IP "$h\->push_header( $field => $value )" 4
.el .IP "\f(CW$h\fR\->push_header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$h->push_header( $field => $value )"
.PD 0
.ie n .IP "$h\->push_header( $f1 => $v1, $f2 => $v2, ... )" 4
.el .IP "\f(CW$h\fR\->push_header( \f(CW$f1\fR => \f(CW$v1\fR, \f(CW$f2\fR => \f(CW$v2\fR, ... )" 4
.IX Item "$h->push_header( $f1 => $v1, $f2 => $v2, ... )"
.PD
Add a freshly smoked up field value fo' tha specified header field. Y'all KNOW dat shit, muthafucka!  Previous joints
for tha same field is retained.
.Sp
As fo' tha \fIheader()\fR method, tha field name ($field) aint case
sensitizzle n' '_' can be used as a replacement fo' '\-'.
.Sp
Da \f(CW$value\fR argument may be a scalar or a reference ta a list of
scalars.
.Sp
.Vb 2
\& $header\->push_header(Accept => \*(Aqimage/jpeg\*(Aq);
\& $header\->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
.Ve
.ie n .IP "$h\->init_header( $field => $value )" 4
.el .IP "\f(CW$h\fR\->init_header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$h->init_header( $field => $value )"
Set tha specified header ta tha given value yo, but only if no previous
value fo' dat field is set.
.Sp
Da header field name ($field) aint case sensitizzle n' '_'
can be used as a replacement fo' '\-'.
.Sp
Da \f(CW$value\fR argument may be a scalar or a reference ta a list of
scalars.
.ie n .IP "$h\->remove_header( $field, ... )" 4
.el .IP "\f(CW$h\fR\->remove_header( \f(CW$field\fR, ... )" 4
.IX Item "$h->remove_header( $field, ... )"
This function removes tha header fieldz wit tha specified names.
.Sp
Da header field names ($field) is not case sensitizzle n' '_'
can be used as a replacement fo' '\-'.
.Sp
Da return value is tha jointz of tha fieldz removed. Y'all KNOW dat shit, muthafucka!  In scalar
context tha number of fieldz removed is returned.
.Sp
Note dat if you pass up in multiple field names then it is generally not
possible ta tell which of tha returned joints belonged ta which field.
.ie n .IP "$h\->remove_content_headers" 4
.el .IP "\f(CW$h\fR\->remove_content_headers" 4
.IX Item "$h->remove_content_headers"
This will remove all tha header fieldz used ta describe tha content of
a message.  All header field names prefixed wit \f(CW\*(C`Content\-\*(C'\fR fall
into dis category, as well as \f(CW\*(C`Allow\*(C'\fR, \f(CW\*(C`Expires\*(C'\fR and
\&\f(CW\*(C`Last\-Modified\*(C'\fR.  \s-1RFC 2616\s0 denotes these fieldz as \fIEntitizzle Header
Fields\fR.
.Sp
Da return value be a freshly smoked up \f(CW\*(C`HTTP::Headers\*(C'\fR object dat gotz nuff the
removed headaz only.
.ie n .IP "$h\->clear" 4
.el .IP "\f(CW$h\fR\->clear" 4
.IX Item "$h->clear"
This will remove all header fields.
.ie n .IP "$h\->header_field_names" 4
.el .IP "\f(CW$h\fR\->header_field_names" 4
.IX Item "$h->header_field_names"
Returns tha list of distinct names fo' tha fieldz present up in the
header n' shit.  Da field names have case as suggested by \s-1HTTP\s0 spec, n' the
names is returned up in tha recommended \*(L"Dope Practice\*(R" order.
.Sp
In scalar context return tha number of distinct field names.
.ie n .IP "$h\->scan( \e&process_header_field )" 4
.el .IP "\f(CW$h\fR\->scan( \e&process_header_field )" 4
.IX Item "$h->scan( &process_header_field )"
Apply a subroutine ta each header field up in turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Da callback routine
is called wit two parameters; tha name of tha field n' a single
value (a string).  If a header field is multi-valued, then the
routine is called once fo' each value.  Da field name passed ta the
callback routine has case as suggested by \s-1HTTP\s0 spec, n' tha headers
will be hit up in tha recommended \*(L"Dope Practice\*(R" order.
.Sp
Any return jointz of tha callback routine is ignored. Y'all KNOW dat shit, muthafucka!  Da loop can
be fucked up by raisin a exception (\f(CW\*(C`die\*(C'\fR) yo, but tha calla of \fIscan()\fR
would gotta trap tha exception itself.
.ie n .IP "$h\->as_string" 4
.el .IP "\f(CW$h\fR\->as_string" 4
.IX Item "$h->as_string"
.PD 0
.ie n .IP "$h\->as_string( $eol )" 4
.el .IP "\f(CW$h\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$h->as_string( $eol )"
.PD
Return tha header fieldz as a gangbangin' formatted \s-1MIME\s0 header n' shit.  Since it
internally uses tha \f(CW\*(C`scan\*(C'\fR method ta build tha string, tha result
will use case as suggested by \s-1HTTP\s0 spec, n' it will follow
recommended \*(L"Dope Practice\*(R" of orderin tha header fields.  Long header
values is not folded.
.Sp
Da optionizzle \f(CW$eol\fR parameta specifies tha line endin sequence to
use.  Da default is \*(L"\en\*(R".  Embedded \*(L"\en\*(R" charactas up in header field
values is ghon be substituted wit dis line endin sequence.
.SH "CONVENIENCE METHODS"
.IX Header "CONVENIENCE METHODS"
Da most frequently used headaz can also be accessed all up in the
followin convenience methods.  Most of these methodz can both be used ta read
and ta set tha value of a header n' shit.  Da header value is set if you pass
an argument ta tha method. Y'all KNOW dat shit, muthafucka!  Da oldschool header value be always returned.
If tha given header did not exist then \f(CW\*(C`undef\*(C'\fR is returned.
.PP
Methodz dat deal wit dates/times always convert they value ta system
time (secondz since Jan 1, 1970) n' they also expect dis kind of
value when tha header value is set.
.ie n .IP "$h\->date" 4
.el .IP "\f(CW$h\fR\->date" 4
.IX Item "$h->date"
This header represents tha date n' time at which tha message was
originated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->date(time);  # set current date
.Ve
.ie n .IP "$h\->expires" 4
.el .IP "\f(CW$h\fR\->expires" 4
.IX Item "$h->expires"
This header gives tha date n' time afta which tha entitizzle should be
considered stale.
.ie n .IP "$h\->if_modified_since" 4
.el .IP "\f(CW$h\fR\->if_modified_since" 4
.IX Item "$h->if_modified_since"
.PD 0
.ie n .IP "$h\->if_unmodified_since" 4
.el .IP "\f(CW$h\fR\->if_unmodified_since" 4
.IX Item "$h->if_unmodified_since"
.PD
These header fieldz is used ta cook up a request conditional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If tha requested
resource has (or has not) been modified since tha time specified up in dis field,
then tha server will return a \f(CW\*(C`304 Not Modified\*(C'\fR response instead of
the document itself.
.ie n .IP "$h\->last_modified" 4
.el .IP "\f(CW$h\fR\->last_modified" 4
.IX Item "$h->last_modified"
This header indicates tha date n' time at which tha resource was last
modified. Y'all KNOW dat shit, muthafucka! \fIE.g.\fR:
.Sp
.Vb 6
\&  # check if document is mo' than 1 minute old
\&  if (my $last_mod = $h\->last_modified) {
\&      if ($last_mod < time \- 60*60) {
\&          ...
\&      }
\&  }
.Ve
.ie n .IP "$h\->content_type" 4
.el .IP "\f(CW$h\fR\->content_type" 4
.IX Item "$h->content_type"
Da Content-Type header field indicates tha media type of tha message
content. \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->content_type(\*(Aqtext/html\*(Aq);
.Ve
.Sp
Da value returned is ghon be converted ta lower case, n' potential
parametas is ghon be chopped off n' returned as a separate value if in
an array context.  If there is no such header field, then tha empty
strin is returned. Y'all KNOW dat shit, muthafucka!  This make it safe ta do tha following:
.Sp
.Vb 5
\&  if ($h\->content_type eq \*(Aqtext/html\*(Aq) {
\&     # we enta dis place even if tha real header value happens to
\&     # be \*(AqTEXT/HTML; version=3.0\*(Aq
\&     ...
\&  }
.Ve
.ie n .IP "$h\->content_type_charset" 4
.el .IP "\f(CW$h\fR\->content_type_charset" 4
.IX Item "$h->content_type_charset"
Returns tha upper-cased charset specified up in tha Content-Type header n' shit.  In list
context return tha lower-cased bare content type followed by tha upper-cased
charset.  Both joints is ghon be \f(CW\*(C`undef\*(C'\fR if not specified up in tha header.
.ie n .IP "$h\->content_is_text" 4
.el .IP "\f(CW$h\fR\->content_is_text" 4
.IX Item "$h->content_is_text"
Returns \s-1TRUE\s0 if tha Content-Type header field indicate dat the
content is textual.
.ie n .IP "$h\->content_is_html" 4
.el .IP "\f(CW$h\fR\->content_is_html" 4
.IX Item "$h->content_is_html"
Returns \s-1TRUE\s0 if tha Content-Type header field indicate dat the
content is some kind of \s-1HTML \s0(includin \s-1XHTML\s0).  This method can't be
used ta set Content-Type.
.ie n .IP "$h\->content_is_xhtml" 4
.el .IP "\f(CW$h\fR\->content_is_xhtml" 4
.IX Item "$h->content_is_xhtml"
Returns \s-1TRUE\s0 if tha Content-Type header field indicate dat the
content is \s-1XHTML. \s0 This method can't be used ta set Content-Type.
.ie n .IP "$h\->content_is_xml" 4
.el .IP "\f(CW$h\fR\->content_is_xml" 4
.IX Item "$h->content_is_xml"
Returns \s-1TRUE\s0 if tha Content-Type header field indicate dat the
content is \s-1XML. \s0 This method can't be used ta set Content-Type.
.ie n .IP "$h\->content_encoding" 4
.el .IP "\f(CW$h\fR\->content_encoding" 4
.IX Item "$h->content_encoding"
Da Content-Encodin header field is used as a modifier ta the
media type.  When present, its value indicates what tha fuck additional
encodin mechanizzle has been applied ta tha resource.
.ie n .IP "$h\->content_length" 4
.el .IP "\f(CW$h\fR\->content_length" 4
.IX Item "$h->content_length"
A decimal number indicatin tha size up in bytez of tha message content.
.ie n .IP "$h\->content_language" 4
.el .IP "\f(CW$h\fR\->content_language" 4
.IX Item "$h->content_language"
Da natural language(s) of tha intended crew fo' tha message
content.  Da value is one or mo' language tags as defined by \s-1RFC
1766. \s0 Eg. \*(L"no\*(R" fo' some kind of Norwegian n' \*(L"en-US\*(R" fo' Gangsta the
way it is freestyled up in tha \s-1US.\s0
.ie n .IP "$h\->title" 4
.el .IP "\f(CW$h\fR\->title" 4
.IX Item "$h->title"
Da title of tha document.  In libwww-perl dis header will be
initialized automatically from tha <\s-1TITLE\s0>...</TITLE> element
of \s-1HTML\s0 documents, n' you can put dat on yo' toast.  \fIThis header is no longer part of tha \s-1HTTP\s0
standard.\fR
.ie n .IP "$h\->user_agent" 4
.el .IP "\f(CW$h\fR\->user_agent" 4
.IX Item "$h->user_agent"
This header field is used up in request lyrics n' gotz nuff shiznit
about tha user agent originatin tha request.  \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->user_agent(\*(AqMozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)\*(Aq);
.Ve
.ie n .IP "$h\->server" 4
.el .IP "\f(CW$h\fR\->server" 4
.IX Item "$h->server"
Da server header field gotz nuff shiznit bout tha software being
used by tha originatin server program handlin tha request.
.ie n .IP "$h\->from" 4
.el .IP "\f(CW$h\fR\->from" 4
.IX Item "$h->from"
This header should contain a Internizzle e\-mail address fo' tha human
user whoz ass controls tha requestin user agent.  Da address should be
machine-usable, as defined by \s-1RFC822.  E\s0.g.:
.Sp
.Vb 1
\&  $h\->from(\*(AqMack Kong <king@kong.com>\*(Aq);
.Ve
.Sp
\&\fIThis header is no longer part of tha \s-1HTTP\s0 standard.\fR
.ie n .IP "$h\->referer" 4
.el .IP "\f(CW$h\fR\->referer" 4
.IX Item "$h->referer"
Used ta specify tha address (\s-1URI\s0) of tha document from which the
axed resource address was obtained.
.Sp
Da \*(L"Jacked On-line Doggtionary of Computing\*(R" as dis ta say bout the
word \fIreferer\fR:
.Sp
.Vb 6
\&     <World\-Wide Web> A misspellin of "referrer" which
\&     somehow juiced it up tha fuck into tha {HTTP} standard. Y'all KNOW dat shit, muthafucka!  A given {web
\&     page}\*(Aqs referer (sic) is tha {URL} of whatever wizzy page
\&     gotz nuff tha link dat tha user followed ta tha current
\&     page.  Most browsers pass dis shiznit as part of a
\&     request.
\&
\&     (1998\-10\-19)
.Ve
.Sp
By ghettofab demand \f(CW\*(C`referrer\*(C'\fR exists as a alias fo' dis method so you
can avoid dis misspellin up in yo' programs n' still bust tha right
thang on tha wire.
.Sp
When settin tha referrer, dis method removes tha fragment from the
given \s-1URI\s0 if it is present, as mandated by \s-1RFC2616. \s0 Note that
the removal do \fInot\fR happen automatically if rockin tha \fIheader()\fR,
\&\fIpush_header()\fR or \fIinit_header()\fR methodz ta set tha referrer.
.ie n .IP "$h\->www_authenticate" 4
.el .IP "\f(CW$h\fR\->www_authenticate" 4
.IX Item "$h->www_authenticate"
This header must be included as part of a \f(CW\*(C`401 Unauthorized\*(C'\fR response.
Da field value consist of a cold-ass lil challenge dat indicates the
authentication scheme n' parametas applicable ta tha axed \s-1URI.\s0
.ie n .IP "$h\->proxy_authenticate" 4
.el .IP "\f(CW$h\fR\->proxy_authenticate" 4
.IX Item "$h->proxy_authenticate"
This header must be included up in a \f(CW\*(C`407 Proxy Authentication Required\*(C'\fR
response.
.ie n .IP "$h\->authorization" 4
.el .IP "\f(CW$h\fR\->authorization" 4
.IX Item "$h->authorization"
.PD 0
.ie n .IP "$h\->proxy_authorization" 4
.el .IP "\f(CW$h\fR\->proxy_authorization" 4
.IX Item "$h->proxy_authorization"
.PD
A user agent dat wishes ta authenticate itself wit a server or a
proxy, may do so by includin these headers.
.ie n .IP "$h\->authorization_basic" 4
.el .IP "\f(CW$h\fR\->authorization_basic" 4
.IX Item "$h->authorization_basic"
This method is used ta git or set a authorization header dat use the
\&\*(L"Basic Authentication Scheme\*(R".  In array context it will return two
values; tha user name n' tha password. Y'all KNOW dat shit, muthafucka!  In scalar context it will
return \fI\*(L"uname:password\*(R"\fR as a single strang value.
.Sp
When used ta set tha header value, it expects two arguments, n' you can put dat on yo' toast.  \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->authorization_basic($uname, $password);
.Ve
.Sp
Da method will croak if tha \f(CW$uname\fR gotz nuff a cold-ass lil colon ':'.
.ie n .IP "$h\->proxy_authorization_basic" 4
.el .IP "\f(CW$h\fR\->proxy_authorization_basic" 4
.IX Item "$h->proxy_authorization_basic"
Same as \fIauthorization_basic()\fR but will set tha \*(L"Proxy-Authorization\*(R"
header instead.
.SH "NON-CANONICALIZED FIELD NAMES"
.IX Header "NON-CANONICALIZED FIELD NAMES"
Da header field name spellin is normally canonicalized includin the
\&'_' ta '\-' translation. I aint talkin' bout chicken n' gravy biatch.  There is some application where dis is not
appropriate.  Prefixin field names wit ':' allow you ta force a
specific spelling.  For example if you straight-up want a header field name
to show up as \f(CW\*(C`foo_bar\*(C'\fR instead of \*(L"Foo-Bar\*(R", you might set it like
this:
.PP
.Vb 1
\&  $h\->header(":foo_bar" => 1);
.Ve
.PP
These field names is returned wit tha ':' intact for
\&\f(CW$h\fR\->header_field_names n' tha \f(CW$h\fR\->scan callback yo, but tha colons do
not show up in \f(CW$h\fR\->as_string.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2005 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
