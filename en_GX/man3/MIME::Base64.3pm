.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MIME::Base64 3pm"
.TH MIME::Base64 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME::Base64 \- Encodin n' decodin of base64 strings
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use MIME::Base64;
\&
\& $encoded = encode_base64(\*(AqAladdin:open sesame\*(Aq);
\& $decoded = decode_base64($encoded);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up functions ta encode n' decode strings tha fuck into n' from the
base64 encodin specified up in \s-1RFC 2045 \- \s0\fI\s-1MIME \s0(Multipurpose Internet
Mail Extensions)\fR. Da base64 encodin is designed ta represent
arbitrary sequencez of octets up in a gangbangin' form dat need not be humanly
readable fo' realz. A 65\-characta subset ([A\-Za\-z0\-9+/=]) of US-ASCII is used,
enablin 6 bits ta be represented per printable character.
.PP
Da followin primary functions is provided:
.ie n .IP "encode_base64( $bytes )" 4
.el .IP "encode_base64( \f(CW$bytes\fR )" 4
.IX Item "encode_base64( $bytes )"
.PD 0
.ie n .IP "encode_base64( $bytes, $eol );" 4
.el .IP "encode_base64( \f(CW$bytes\fR, \f(CW$eol\fR );" 4
.IX Item "encode_base64( $bytes, $eol );"
.PD
Encode data by callin tha \fIencode_base64()\fR function. I aint talkin' bout chicken n' gravy biatch.  Da first
argument is tha byte strang ta encode.  Da second argument is the
line-endin sequence ta use.  It be optionizzle n' defaults ta \*(L"\en\*(R".  The
returned encoded strang is fucked up tha fuck into linez of no mo' than 76
charactas each n' it will end wit \f(CW$eol\fR unless it is empty.  Pass an
empty strang as second argument if you do not want tha encoded string
to be fucked up tha fuck into lines.
.Sp
Da function will croak wit \*(L"Wide characta up in subroutine entry\*(R" if \f(CW$bytes\fR
gotz nuff charactas wit code above 255.  Da base64 encodin is only defined
for single-byte characters.  Use tha Encode module ta select tha byte encoding
you want.
.ie n .IP "decode_base64( $str )" 4
.el .IP "decode_base64( \f(CW$str\fR )" 4
.IX Item "decode_base64( $str )"
Decode a funky-ass base64 strang by callin tha \fIdecode_base64()\fR function. I aint talkin' bout chicken n' gravy biatch.  This
function takes a single argument which is tha strang ta decode and
returns tha decoded data.
.Sp
Any characta not part of tha 65\-characta base64 subset is
silently ignored. Y'all KNOW dat shit, muthafucka!  Charactas occurrin afta a '=' paddin character
are never decoded.
.PP
If you prefer not ta import these routines tha fuck into yo' namespace, you can
call dem as:
.PP
.Vb 3
\&    use MIME::Base64 ();
\&    $encoded = MIME::Base64::encode($decoded);
\&    $decoded = MIME::Base64::decode($encoded);
.Ve
.PP
Additionizzle functions not exported by default:
.ie n .IP "encode_base64url( $bytes )" 4
.el .IP "encode_base64url( \f(CW$bytes\fR )" 4
.IX Item "encode_base64url( $bytes )"
.PD 0
.ie n .IP "decode_base64url( $str )" 4
.el .IP "decode_base64url( \f(CW$str\fR )" 4
.IX Item "decode_base64url( $str )"
.PD
Encode n' decode accordin ta tha base64 scheme fo' \*(L"\s-1URL\s0 applications\*(R" [1].
This be a variant of tha base64 encodin which do not use padding, do not
break tha strang tha fuck into multiple lines n' use tha charactas \*(L"\-\*(R" n' \*(L"_\*(R" instead
of \*(L"+\*(R" n' \*(L"/\*(R" ta avoid rockin reserved \s-1URL\s0 characters.
.ie n .IP "encoded_base64_length( $bytes )" 4
.el .IP "encoded_base64_length( \f(CW$bytes\fR )" 4
.IX Item "encoded_base64_length( $bytes )"
.PD 0
.ie n .IP "encoded_base64_length( $bytes, $eol )" 4
.el .IP "encoded_base64_length( \f(CW$bytes\fR, \f(CW$eol\fR )" 4
.IX Item "encoded_base64_length( $bytes, $eol )"
.PD
Returns tha length dat tha encoded strang would have without actually
encodin dat shit.  This will return tha same value as \f(CW\*(C`length(encode_base64($bytes))\*(C'\fR,
but should be mo' efficient.
.ie n .IP "decoded_base64_length( $str )" 4
.el .IP "decoded_base64_length( \f(CW$str\fR )" 4
.IX Item "decoded_base64_length( $str )"
Returns tha length dat tha decoded strang would have without actually
decodin dat shit.  This will return tha same value as \f(CW\*(C`length(decode_base64($str))\*(C'\fR,
but should be mo' efficient.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
If you wanna encode a big-ass file, you should encode it up in chunks
that is a multiple of 57 bytes.  This ensures dat tha base64 lines
line up n' dat you do not end up wit paddin up in tha middle. 57
bytez of data fills one complete base64 line (76 == 57*4/3):
.PP
.Vb 1
\&   use MIME::Base64 qw(encode_base64);
\&
\&   open(FILE, "/var/log/wtmp") or take a thugged-out dirtnap "$!";
\&   while (read(FILE, $buf, 60*57)) {
\&       print encode_base64($buf);
\&   }
.Ve
.PP
or if you know you have enough memory
.PP
.Vb 3
\&   use MIME::Base64 qw(encode_base64);
\&   local($/) = undef;  # slurp
\&   print encode_base64(<STDIN>);
.Ve
.PP
Da same approach as a cold-ass lil command line:
.PP
.Vb 1
\&   perl \-MMIME::Base64 \-0777 \-ne \*(Aqprint encode_base64($_)\*(Aq <file
.Ve
.PP
Decodin do not need slurp mode if every last muthafuckin line gotz nuff a multiple
of four base64 chars:
.PP
.Vb 1
\&   perl \-MMIME::Base64 \-ne \*(Aqprint decode_base64($_)\*(Aq <file
.Ve
.PP
Perl v5.8 n' betta allow extended Unicode charactas up in strings.
Such strings cannot be encoded directly, as tha base64
encodin is only defined fo' single-byte characters.  Da solution is
to use tha Encode module ta select tha byte encodin you want.  For
example:
.PP
.Vb 2
\&    use MIME::Base64 qw(encode_base64);
\&    use Encode qw(encode);
\&
\&    $encoded = encode_base64(encode("UTF\-8", "\ex{FFFF}\en"));
\&    print $encoded;
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-1999, 2001\-2004, 2010 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.PP
Distantly based on LWP::Base64 freestyled by Martijn Koster
<m.koster@nexor.co.uk> n' Joerg Reichelt <j.reichelt@nexor.co.uk> and
code posted ta comp.lang.perl <3pd2lp$6gf@wsinti07.win.tue.nl> by Hans
Mulder <hansm@wsinti07.win.tue.nl>
.PP
Da \s-1XS\s0 implementation uses code from metamail.  Copyright 1991 Bell
Communications Research, Inc. (Bellcore)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MIME::QuotedPrint
.PP
[1] <http://en.wikipedia.org/wiki/Base64#URL_applications>
