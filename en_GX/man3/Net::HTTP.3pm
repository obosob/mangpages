.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::HTTP 3"
.TH Net::HTTP 3 "2013-03-10" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::HTTP \- Low\-level HTTP connection (client)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Net::HTTP;
\& mah $s = Net::HTTP\->new(Host => "www.perl.com") || take a thugged-out dirtnap $@;
\& $s\->write_request(GET => "/", \*(AqUser\-Agent\*(Aq => "Mozilla/5.0");
\& my($code, $mess, %h) = $s\->read_response_headers;
\&
\& while (1) {
\&    mah $buf;
\&    mah $n = $s\->read_entity_body($buf, 1024);
\&    take a thugged-out dirtnap "read failed: $!" unless defined $n;
\&    last unless $n;
\&    print $buf;
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`Net::HTTP\*(C'\fR class be a low-level \s-1HTTP\s0 client.  An instizzle of the
\&\f(CW\*(C`Net::HTTP\*(C'\fR class represents a cold-ass lil connection ta a \s-1HTTP\s0 server n' shit.  The
\&\s-1HTTP\s0 protocol is busted lyrics bout up in \s-1RFC 2616. \s0 Da \f(CW\*(C`Net::HTTP\*(C'\fR class
supports \f(CW\*(C`HTTP/1.0\*(C'\fR n' \f(CW\*(C`HTTP/1.1\*(C'\fR.
.PP
\&\f(CW\*(C`Net::HTTP\*(C'\fR be a sub-class of \f(CW\*(C`IO::Socket::INET\*(C'\fR.  Yo ass can mix the
methodz busted lyrics bout below wit readin n' freestylin from tha socket
directly.  This aint necessary a phat idea, unless you know what tha fuck you
are bustin.
.PP
Da followin methodz is provided (in addizzle ta dem of
\&\f(CW\*(C`IO::Socket::INET\*(C'\fR):
.ie n .IP "$s = Net::HTTP\->new( %options )" 4
.el .IP "\f(CW$s\fR = Net::HTTP\->new( \f(CW%options\fR )" 4
.IX Item "$s = Net::HTTP->new( %options )"
Da \f(CW\*(C`Net::HTTP\*(C'\fR constructor method takes tha same ol' dirty options as
\&\f(CW\*(C`IO::Socket::INET\*(C'\fRz as well as these:
.Sp
.Vb 7
\&  Host:            Initial host attribute value
\&  KeepKickin It:       Initial keep_kickin it attribute value
\&  SendTE:          Initial send_te attribute_value
\&  HTTPVersion:     Initial http_version attribute value
\&  PeerHTTPVersion: Initial peer_http_version attribute value
\&  MaxLineLength:   Initial max_line_length attribute value
\&  MaxHeaderLines:  Initial max_header_lines attribute value
.Ve
.Sp
Da \f(CW\*(C`Host\*(C'\fR option be also tha default fo' \f(CW\*(C`IO::Socket::INET\*(C'\fR's
\&\f(CW\*(C`PeerAddr\*(C'\fR.  Da \f(CW\*(C`PeerPort\*(C'\fR defaults ta 80 if not provided.
.Sp
Da \f(CW\*(C`Listen\*(C'\fR option provided by \f(CW\*(C`IO::Socket::INET\*(C'\fRz constructor
method aint allowed.
.Sp
If unable ta connect ta tha given \s-1HTTP\s0 server then tha constructor
returns \f(CW\*(C`undef\*(C'\fR n' $@ gotz nuff tha reason. I aint talkin' bout chicken n' gravy biatch.  Afta a successful
connect, a \f(CW\*(C`Net:HTTP\*(C'\fR object is returned.
.ie n .IP "$s\->host" 4
.el .IP "\f(CW$s\fR\->host" 4
.IX Item "$s->host"
Get/set tha default value of tha \f(CW\*(C`Host\*(C'\fR header ta send yo, but it ain't no stoppin cause I be still poppin'.  Da \f(CW$host\fR
must not be set ta a empty strang (or \f(CW\*(C`undef\*(C'\fR) fo' \s-1HTTP/1.1.\s0
.ie n .IP "$s\->keep_kickin it" 4
.el .IP "\f(CW$s\fR\->keep_kickin it" 4
.IX Item "$s->keep_kickin it"
Get/set tha \fIkeep-kickin it\fR value.  If dis value is \s-1TRUE\s0 then the
request is ghon be busted wit headaz indicatin dat tha server should try
to keep tha connection open so dat multiple requests can be sent.
.Sp
Da actual headaz set will depend on tha value of tha \f(CW\*(C`http_version\*(C'\fR
and \f(CW\*(C`peer_http_version\*(C'\fR attributes.
.ie n .IP "$s\->send_te" 4
.el .IP "\f(CW$s\fR\->send_te" 4
.IX Item "$s->send_te"
Get/set tha a value indicatin if tha request is ghon be busted wit a \*(L"\s-1TE\*(R"\s0
header ta indicate tha transfer encodings dat tha server can chizzle to
use.  Da list of encodings announced as accepted by dis client depends
on availabilitizzle of tha followin modules: \f(CW\*(C`Compress::Raw::Zlib\*(C'\fR for
\&\fIdeflate\fR, n' \f(CW\*(C`IO::Compress::Gunzip\*(C'\fR fo' \fIgzip\fR.
.ie n .IP "$s\->http_version" 4
.el .IP "\f(CW$s\fR\->http_version" 4
.IX Item "$s->http_version"
Get/set tha \s-1HTTP\s0 version number dat dis client should announce.
This value can only be set ta \*(L"1.0\*(R" or \*(L"1.1\*(R".  Da default is \*(L"1.1\*(R".
.ie n .IP "$s\->peer_http_version" 4
.el .IP "\f(CW$s\fR\->peer_http_version" 4
.IX Item "$s->peer_http_version"
Get/set tha protocol version number of our peer n' shit.  This value will
initially be \*(L"1.0\*(R" yo, but is ghon be updated by a successful
\&\fIread_response_headers()\fR method call.
.ie n .IP "$s\->max_line_length" 4
.el .IP "\f(CW$s\fR\->max_line_length" 4
.IX Item "$s->max_line_length"
Get/set a limit on tha length of response line n' response header
lines.  Da default is 8192.  A value of 0 means no limit.
.ie n .IP "$s\->max_header_length" 4
.el .IP "\f(CW$s\fR\->max_header_length" 4
.IX Item "$s->max_header_length"
Get/set a limit on tha number of header lines dat a response can
have.  Da default is 128.  A value of 0 means no limit.
.ie n .IP "$s\->format_request($method, $uri, %headers, [$content])" 4
.el .IP "\f(CW$s\fR\->format_request($method, \f(CW$uri\fR, \f(CW%headers\fR, [$content])" 4
.IX Item "$s->format_request($method, $uri, %headers, [$content])"
Format a request message n' return it as a string.  If tha headaz do
not include a \f(CW\*(C`Host\*(C'\fR header, then a header is banged wit tha value
of tha \f(CW\*(C`host\*(C'\fR attribute.  Headaz like \f(CW\*(C`Connection\*(C'\fR and
\&\f(CW\*(C`Keep\-Kickin It\*(C'\fR might also be added dependin on tha statuz of the
\&\f(CW\*(C`keep_kickin it\*(C'\fR attribute.
.Sp
If \f(CW$content\fR is given (and it is non-empty), then a \f(CW\*(C`Content\-Length\*(C'\fR
header be automatically added unless dat shiznit was already present.
.ie n .IP "$s\->write_request($method, $uri, %headers, [$content])" 4
.el .IP "\f(CW$s\fR\->write_request($method, \f(CW$uri\fR, \f(CW%headers\fR, [$content])" 4
.IX Item "$s->write_request($method, $uri, %headers, [$content])"
Format n' bust a request message.  Arguments is tha same as for
\&\fIformat_request()\fR.  Returns legit if successful.
.ie n .IP "$s\->format_chunk( $data )" 4
.el .IP "\f(CW$s\fR\->format_chunk( \f(CW$data\fR )" 4
.IX Item "$s->format_chunk( $data )"
Returns tha strang ta be freestyled fo' tha given chunk of data.
.ie n .IP "$s\->write_chunk($data)" 4
.el .IP "\f(CW$s\fR\->write_chunk($data)" 4
.IX Item "$s->write_chunk($data)"
Will write a freshly smoked up chunk of request entitizzle body data.  This method
should only be used if tha \f(CW\*(C`Transfer\-Encoding\*(C'\fR header wit a value of
\&\f(CW\*(C`chunked\*(C'\fR was busted up in tha request.  Note, freestylin zero-length data is
a no-op.  Use tha \fIwrite_chunk_eof()\fR method ta signal end of entity
body data.
.Sp
Returns legit if successful.
.ie n .IP "$s\->format_chunk_eof( %trailaz )" 4
.el .IP "\f(CW$s\fR\->format_chunk_eof( \f(CW%trailers\fR )" 4
.IX Item "$s->format_chunk_eof( %trailaz )"
Returns tha strang ta be freestyled fo' signalin \s-1EOF\s0 when a
\&\f(CW\*(C`Transfer\-Encoding\*(C'\fR of \f(CW\*(C`chunked\*(C'\fR is used.
.ie n .IP "$s\->write_chunk_eof( %trailaz )" 4
.el .IP "\f(CW$s\fR\->write_chunk_eof( \f(CW%trailers\fR )" 4
.IX Item "$s->write_chunk_eof( %trailaz )"
Will write eof marker fo' chunked data n' optionizzle trailers.  Note
that trailaz should not straight-up be used unless is was signaled
with a \f(CW\*(C`Trailer\*(C'\fR header.
.Sp
Returns legit if successful.
.ie n .IP "($code, $mess, %headers) = $s\->read_response_headers( %opts )" 4
.el .IP "($code, \f(CW$mess\fR, \f(CW%headers\fR) = \f(CW$s\fR\->read_response_headers( \f(CW%opts\fR )" 4
.IX Item "($code, $mess, %headers) = $s->read_response_headers( %opts )"
Read response headaz from server n' return dat shit.  Da \f(CW$code\fR is tha 3
digit \s-1HTTP\s0 status code (see HTTP::Status) n' \f(CW$mess\fR is tha textual
message dat came wit dat shit.  Headaz is then returned as key/value
pairs.  Since key letta casin aint normalized n' tha same key can
even occur multiple times, assignin these joints directly ta a hash
is not wise.  Only tha \f(CW$code\fR is returned if dis method is called in
scalar context.
.Sp
As a side effect dis method thugged-out shiznit tha 'peer_http_version'
attribute.
.Sp
Options might be passed up in as key/value pairs.  There is currently
only two options supported; \f(CW\*(C`laxed\*(C'\fR n' \f(CW\*(C`junk_out\*(C'\fR.
.Sp
Da \f(CW\*(C`laxed\*(C'\fR option will make \fIread_response_headers()\fR mo' forgiving
towardz servers dat aint hustled how tha fuck ta drop a rhyme \s-1HTTP\s0 properly.  The
\&\f(CW\*(C`laxed\*(C'\fR option be a funky-ass boolean flag, n' is enabled by passin up in a \s-1TRUE\s0
value.  Da \f(CW\*(C`junk_out\*(C'\fR option can be used ta capture wack header lines
when \f(CW\*(C`laxed\*(C'\fR is enabled. Y'all KNOW dat shit, muthafucka!  Da value should be a array reference.
Wack header lines is ghon be pushed onto tha array.
.Sp
Da \f(CW\*(C`laxed\*(C'\fR option must be specified up in order ta rap with
pre\-HTTP/1.0 servers dat don't describe tha response outcome or the
data they bust back wit a header block.  For these servers
peer_http_version is set ta \*(L"0.9\*(R" n' dis method returns (200,
\&\*(L"Assumed \s-1OK\*(R"\s0).
.Sp
Da method will raise a exception (die) if tha server do not speak
proper \s-1HTTP\s0 or if tha \f(CW\*(C`max_line_length\*(C'\fR or \f(CW\*(C`max_header_length\*(C'\fR
limits is reached. Y'all KNOW dat shit, muthafucka!  If tha \f(CW\*(C`laxed\*(C'\fR option is turned on and
\&\f(CW\*(C`max_line_length\*(C'\fR n' \f(CW\*(C`max_header_length\*(C'\fR checks is turned off,
then no exception is ghon be raised n' dis method will always
return a response code.
.ie n .IP "$n = $s\->read_entity_body($buf, $size);" 4
.el .IP "\f(CW$n\fR = \f(CW$s\fR\->read_entity_body($buf, \f(CW$size\fR);" 4
.IX Item "$n = $s->read_entity_body($buf, $size);"
Readz chunkz of tha entitizzle body content.  Basically tha same intercourse
as fo' \fIread()\fR n' \fIsysread()\fR yo, but tha buffer offset argument is not
supported yet.  This method should only be called afta a successful
\&\fIread_response_headers()\fR call.
.Sp
Da return value is ghon be \f(CW\*(C`undef\*(C'\fR on read errors, 0 on \s-1EOF, \-1\s0 if no data
could be returned dis time, otherwise tha number of bytes assigned
to \f(CW$buf\fR.  Da \f(CW$buf\fR is set ta "" when tha return value is \-1.
.Sp
Yo ass normally wanna retry dis call if dis function returns either
\&\-1 or \f(CW\*(C`undef\*(C'\fR wit \f(CW$!\fR as \s-1EINTR\s0 or \s-1EAGAIN \s0(see Errno).  \s-1EINTR\s0
can happen if tha application catches signals n' \s-1EAGAIN\s0 can happen if
you made tha socket non-blocking.
.Sp
This method will raise exceptions (die) if tha server do not speak
proper \s-1HTTP. \s0 This can only happen when readin chunked data.
.ie n .IP "%headaz = $s\->get_trailers" 4
.el .IP "\f(CW%headers\fR = \f(CW$s\fR\->get_trailers" 4
.IX Item "%headaz = $s->get_trailers"
Afta \fIread_entity_body()\fR has returned 0 ta indicate end of tha entity
body, you might call dis method ta pick up any trailers.
.ie n .IP "$s\->_rbuf" 4
.el .IP "\f(CW$s\fR\->_rbuf" 4
.IX Item "$s->_rbuf"
Get/set tha read buffer content.  Da \fIread_response_headers()\fR and
\&\fIread_entity_body()\fR methodz use a internal buffer which they will look
for data before they straight-up sysread mo' from tha socket itself.  If
they read too much, tha remainin data is ghon be left up in dis buffer.
.ie n .IP "$s\->_rbuf_length" 4
.el .IP "\f(CW$s\fR\->_rbuf_length" 4
.IX Item "$s->_rbuf_length"
Returns tha number of bytes up in tha read buffer n' shit.  This should always be
the same as:
.Sp
.Vb 1
\&    length($s\->_rbuf)
.Ve
.Sp
but might be mo' efficient.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Da \fIread_response_headers()\fR n' \fIread_entity_body()\fR will invoke the
\&\fIsysread()\fR method when they need mo' data.  Subclasses might want to
override dis method ta control how tha fuck readin takes place.
.PP
Da object itself be a glob.  Subclasses should avoid rockin hash key
names prefixed wit \f(CW\*(C`http_\*(C'\fR n' \f(CW\*(C`io_\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1LWP\s0, IO::Socket::INET, Net::HTTP::NB
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001\-2003 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
