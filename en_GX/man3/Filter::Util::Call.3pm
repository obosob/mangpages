.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Call 3"
.TH Call 3 "2014-12-09" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Filter::Util::Call \- Perl Source Filta Utilitizzle Module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Filter::Util::Call ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up you wit tha framework ta write \fISource Filters\fR
in Perl.
.PP
An alternate intercourse ta Filter::Util::Call is now available. Right back up in yo muthafuckin ass. See
Filter::Simple fo' mo' details.
.PP
A \fIPerl Source Filter\fR is implemented as a Perl module. Da structure
of tha module can take one of two broadly similar formats, n' you can put dat on yo' toast. To
distinguish between them, tha straight-up original gangsta is ghon be referred ta as \fImethod
filter\fR n' tha second as \fIclosure filter\fR.
.PP
Here be a skeleton fo' tha \fImethod filter\fR:
.PP
.Vb 1
\&    package MyFilta ;
\&
\&    use Filter::Util::Call ;
\&
\&    sub import
\&    {
\&        my($type, @arguments) = @_ ;
\&        filter_add([]) ;
\&    }
\&
\&    sub filter
\&    {
\&        my($self) = @_ ;
\&        my($status) ;
\&
\&        $status = filter_read() ;
\&        $status ;
\&    }
\&
\&    1 ;
.Ve
.PP
and dis is tha equivalent skeleton fo' tha \fIclosure filter\fR:
.PP
.Vb 1
\&    package MyFilta ;
\&
\&    use Filter::Util::Call ;
\&
\&    sub import
\&    {
\&        my($type, @arguments) = @_ ;
\&
\&        filter_add(
\&            sub 
\&            {
\&                my($status) ;
\&                $status = filter_read() ;
\&                $status ;
\&            } )
\&    }
\&
\&    1 ;
.Ve
.PP
To make use of either of tha two filta modulez above, place tha line
below up in a Perl source file.
.PP
.Vb 1
\&    use MyFilter;
.Ve
.PP
In fact, tha skeleton modulez shown above is straight-up functionizzle \fISource
Filters\fR, albeit fairly useless ones fo' realz. All they do is filta the
source stream without modifyin it at all.
.PP
As you can peep both modulez gotz a funky-ass broadly similar structure. They both
make use of tha \f(CW\*(C`Filter::Util::Call\*(C'\fR module n' both have a \f(CW\*(C`import\*(C'\fR
method. Y'all KNOW dat shit, muthafucka! Da difference between dem is dat tha \fImethod filter\fR
requires a \fIfilter\fR method, whereas tha \fIclosure filter\fR gets the
equivalent of a \fIfilter\fR method wit tha anonymous sub passed to
\&\fIfilter_add\fR.
.PP
To make proper use of tha \fIclosure filter\fR shown above you need to
have a phat understandin of tha concept of a \fIclosure\fR. Right back up in yo muthafuckin ass. See
perlref fo' mo' details on tha mechanics of \fIclosures\fR.
.SS "\fBuse Filter::Util::Call\fP"
.IX Subsection "use Filter::Util::Call"
Da followin functions is exported by \f(CW\*(C`Filter::Util::Call\*(C'\fR:
.PP
.Vb 4
\&    filter_add()
\&    filter_read()
\&    filter_read_exact()
\&    filter_del()
.Ve
.SS "\fB\fP\f(BIimport()\fP\fB\fP"
.IX Subsection "import()"
Da \f(CW\*(C`import\*(C'\fR method is used ta create a instizzle of tha filter n' shit. Well shiiiit, it is
called indirectly by Perl when it encountas tha \f(CW\*(C`use MyFilter\*(C'\fR line
in a source file (See \*(L"import\*(R" up in perlfunc fo' mo' details on
\&\f(CW\*(C`import\*(C'\fR).
.PP
It will always have at least one parameta automatically passed by Perl
\&\- dis correspondz ta tha name of tha package. In tha example above it
will be \f(CW"MyFilter"\fR.
.PP
Apart from tha straight-up original gangsta parameter, import can accept a optionizzle list of
parameters. These can be used ta pass parametas ta tha filter n' shit. For
example:
.PP
.Vb 1
\&    use MyFilta qw(a b c) ;
.Ve
.PP
will result up in tha \f(CW@_\fR array havin tha followin joints:
.PP
.Vb 4
\&    @_ [0] => "MyFilter"
\&    @_ [1] => "a"
\&    @_ [2] => "b"
\&    @_ [3] => "c"
.Ve
.PP
Before terminating, tha \f(CW\*(C`import\*(C'\fR function must explicitly install the
filta by callin \f(CW\*(C`filter_add\*(C'\fR.
.SS "\fB\fP\f(BIfilter_add()\fP\fB\fP"
.IX Subsection "filter_add()"
Da function, \f(CW\*(C`filter_add\*(C'\fR, straight-up installs tha filter n' shit. Well shiiiit, it takes one
parameta which should be a reference. Da kind of reference used will
dictate which of tha two filta types is ghon be used.
.PP
If a \s-1CODE\s0 reference is used then a \fIclosure filter\fR is ghon be assumed.
.PP
If a \s-1CODE\s0 reference aint used, a \fImethod filter\fR is ghon be assumed.
In a \fImethod filter\fR, tha reference can be used ta store context
information. I aint talkin' bout chicken n' gravy biatch. Da reference is ghon be \fIblessed\fR tha fuck into tha package by
\&\f(CW\*(C`filter_add\*(C'\fR, unless tha reference was already pimped.
.PP
See tha filtas all up in tha end of dis documents fo' examplez of using
context shiznit rockin both \fImethod filters\fR n' \fIclosure
filters\fR.
.SS "\fB\fP\f(BIfilter()\fP\fB n' anonymous sub\fP"
.IX Subsection "filter() n' anonymous sub"
Both tha \f(CW\*(C`filter\*(C'\fR method used wit a \fImethod filter\fR n' the
anonymous sub used wit a \fIclosure filter\fR is where tha main
processin fo' tha filta is done.
.PP
Da big-ass difference between tha two typez of filta is dat tha \fImethod
filter\fR uses tha object passed ta tha method ta store any context data,
whereas tha \fIclosure filter\fR uses tha lexical variablez dat are
maintained by tha closure.
.PP
Note dat tha single parameta passed ta tha \fImethod filter\fR,
\&\f(CW$self\fR, is tha same ol' dirty reference dat was passed ta \f(CW\*(C`filter_add\*(C'\fR
blessed tha fuck into tha filterz package. Right back up in yo muthafuckin ass. See tha example filtas lata on for
detailz of rockin \f(CW$self\fR.
.PP
Here be a list of tha common featurez of tha anonymous sub n' the
\&\f(CW\*(C`filter()\*(C'\fR method.
.ie n .IP "\fB\fB$_\fB\fR" 5
.el .IP "\fB\f(CB$_\fB\fR" 5
.IX Item "$_"
Although \f(CW$_\fR don't straight-up step tha fuck up explicitly up in tha sample filters
above, it is implicitly used up in a fuckin shitload of places.
.Sp
Firstly, when either \f(CW\*(C`filter\*(C'\fR or tha anonymous sub is called, a local
copy of \f(CW$_\fR will automatically be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Well shiiiit, it will always contain the
empty strang at dis point.
.Sp
Next, both \f(CW\*(C`filter_read\*(C'\fR n' \f(CW\*(C`filter_read_exact\*(C'\fR will append any
source data dat is read ta tha end of \f(CW$_\fR.
.Sp
Finally, when \f(CW\*(C`filter\*(C'\fR or tha anonymous sub is finished processing,
they is sposed ta fuckin return tha filtered source rockin \f(CW$_\fR.
.Sp
This implicit use of \f(CW$_\fR pimped outly simplifies tha filter.
.ie n .IP "\fB\fB$status\fB\fR" 5
.el .IP "\fB\f(CB$status\fB\fR" 5
.IX Item "$status"
Da status value dat is returned by tha userz \f(CW\*(C`filter\*(C'\fR method or
anonymous sub n' tha \f(CW\*(C`filter_read\*(C'\fR n' \f(CW\*(C`read_exact\*(C'\fR functions take
the same set of joints, namely:
.Sp
.Vb 3
\&    < 0  Error
\&    = 0  EOF
\&    > 0  OK
.Ve
.IP "\fBfilter_read\fR n' \fBfilter_read_exact\fR" 5
.IX Item "filter_read n' filter_read_exact"
These functions is used by tha filta ta obtain either a line or block
from tha next filta up in tha chain or tha actual source file if there
aren't any other filters.
.Sp
Da function \f(CW\*(C`filter_read\*(C'\fR takes two forms:
.Sp
.Vb 2
\&    $status = filter_read() ;
\&    $status = filter_read($size) ;
.Ve
.Sp
Da first form is used ta request a \fIline\fR, tha second requests a
\&\fIblock\fR.
.Sp
In line mode, \f(CW\*(C`filter_read\*(C'\fR will append tha next source line ta the
end of tha \f(CW$_\fR scalar.
.Sp
In block mode, \f(CW\*(C`filter_read\*(C'\fR will append a funky-ass block of data which is <=
\&\f(CW$size\fR ta tha end of tha \f(CW$_\fR scalar. Shiiit, dis aint no joke. Well shiiiit, it is blingin ta emphasise
the dat \f(CW\*(C`filter_read\*(C'\fR aint gonna necessarily read a funky-ass block which is
\&\fIprecisely\fR \f(CW$size\fR bytes.
.Sp
If you need ta be able ta read a funky-ass block which has a exact size, you can
use tha function \f(CW\*(C`filter_read_exact\*(C'\fR. Well shiiiit, it works identically to
\&\f(CW\*(C`filter_read\*(C'\fR up in block mode, except it will try ta read a funky-ass block which
is exactly \f(CW$size\fR bytes up in length. Da only circumstances when it
will not return a funky-ass block which is \f(CW$size\fR bytes long is on \s-1EOF\s0 or
error.
.Sp
It be \fIvery\fR blingin ta check tha value of \f(CW$status\fR afta \fIevery\fR
call ta \f(CW\*(C`filter_read\*(C'\fR or \f(CW\*(C`filter_read_exact\*(C'\fR.
.IP "\fBfilter_del\fR" 5
.IX Item "filter_del"
Da function, \f(CW\*(C`filter_del\*(C'\fR, is used ta disable tha current filter n' shit. It
does not affect tha hustlin of tha filter n' shiznit fo' realz. All it do is tell Perl not
to call filta any more.
.Sp
See \*(L"Example 4: Usin filter_del\*(R" fo' details.
.IP "\fIreal_import\fR" 5
.IX Item "real_import"
Internal function which addz tha filter, based on tha filter_add
argument type.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Here is all dem examplez which illustrate tha key concepts \- as such
most of dem iz of lil practical use.
.PP
Da \f(CW\*(C`examples\*(C'\fR sub-directory has copiez of all these filters
implemented both as \fImethod filters\fR n' as \fIclosure filters\fR.
.SS "Example 1: A simple filter."
.IX Subsection "Example 1: A simple filter."
Below be a \fImethod filter\fR which is hard-wired ta replace all
occurrencez of tha strang \f(CW"Joe"\fR ta \f(CW"Jim"\fR. Not particularly
Useful yo, but it is tha straight-up original gangsta example n' I wanted ta keep it simple.
.PP
.Vb 1
\&    package Joe2Jim ;
\&
\&    use Filter::Util::Call ;
\&
\&    sub import
\&    {
\&        my($type) = @_ ;
\&
\&        filter_add(bless []) ;
\&    }
\&
\&    sub filter
\&    {
\&        my($self) = @_ ;
\&        my($status) ;
\&
\&        s/Joe/Jim/g
\&            if ($status = filter_read()) > 0 ;
\&        $status ;
\&    }
\&
\&    1 ;
.Ve
.PP
Here be a example of rockin tha filter:
.PP
.Vb 2
\&    use Joe2Jim ;
\&    print "Where is Joe?\en" ;
.Ve
.PP
And dis is what tha fuck tha script above will print:
.PP
.Vb 1
\&    Where is Jim?
.Ve
.SS "Example 2: Usin tha context"
.IX Subsection "Example 2: Usin tha context"
Da previous example was not particularly useful naaahhmean, biatch? To make it more
general purpose we will make use of tha context data n' allow any
arbitrary \fIfrom\fR n' \fIto\fR strings ta be used. Y'all KNOW dat shit, muthafucka! This time we will use a
\&\fIclosure filter\fR. To reflect its enhanced role, tha filta is called
\&\f(CW\*(C`Subst\*(C'\fR.
.PP
.Vb 1
\&    package Subst ;
\&
\&    use Filter::Util::Call ;
\&    use Carp ;
\&
\&    sub import
\&    {
\&        croak("usage: use Subst qw(from to)")
\&            unless @_ == 3 ;
\&        mah ($self, $from, $to) = @_ ;
\&        filter_add(
\&            sub 
\&            {
\&                mah ($status) ;
\&                s/$from/$to/
\&                    if ($status = filter_read()) > 0 ;
\&                $status ;
\&            })
\&    }
\&    1 ;
.Ve
.PP
and is used like this:
.PP
.Vb 2
\&    use Subst qw(Joe Jim) ;
\&    print "Where is Joe?\en" ;
.Ve
.SS "Example 3: Usin tha context within tha filter"
.IX Subsection "Example 3: Usin tha context within tha filter"
Here be a gangbangin' filta which a variation of tha \f(CW\*(C`Joe2Jim\*(C'\fR filter n' shiznit fo' realz. As well as
substitutin all occurrencez of \f(CW"Joe"\fR ta \f(CW"Jim"\fR it keeps a cold-ass lil count
of tha number of substitutions made up in tha context object.
.PP
Once \s-1EOF\s0 is detected (\f(CW$status\fR is zero) tha filta will bang an
extra line tha fuck into tha source stream. When dis extra line is executed it
will print a cold-ass lil count of tha number of substitutions straight-up made.
Note dat \f(CW$status\fR is set ta \f(CW1\fR up in dis case.
.PP
.Vb 1
\&    package Count ;
\&
\&    use Filter::Util::Call ;
\&
\&    sub filter
\&    {
\&        mah ($self) = @_ ;
\&        mah ($status) ;
\&
\&        if (($status = filter_read()) > 0 ) {
\&            s/Joe/Jim/g ;
\&            ++ $$self ;
\&        }
\&        elsif ($$self >= 0) { # EOF
\&            $_ = "print q[Made ${$self} substitutions\en]" ;
\&            $status = 1 ;
\&            $$self = \-1 ;
\&        }
\&
\&        $status ;
\&    }
\&
\&    sub import
\&    {
\&        mah ($self) = @_ ;
\&        mah ($count) = 0 ;
\&        filter_add(\e$count) ;
\&    }
\&
\&    1 ;
.Ve
.PP
Here be a script which uses it:
.PP
.Vb 3
\&    use Count ;
\&    print "Wuz crackalackin' Joe\en" ;
\&    print "Where is Joe\en" ;
.Ve
.PP
Outputs:
.PP
.Vb 3
\&    Wuz crackalackin' Jim
\&    Where is Jim
\&    Made 2 substitutions
.Ve
.SS "Example 4: Usin filter_del"
.IX Subsection "Example 4: Usin filter_del"
Another variation on a theme. This time we will modify tha \f(CW\*(C`Subst\*(C'\fR
filta ta allow a startin n' stoppin pattern ta be specified as well
as tha \fIfrom\fR n' \fIto\fR patterns. If you know tha \fIvi\fR editor, it is
the equivalent of dis command:
.PP
.Vb 1
\&    :/start/,/stop/s/from/to/
.Ve
.PP
When used as a gangbangin' filta we wanna invoke it like this:
.PP
.Vb 1
\&    use NewSubst qw(start stop from to) ;
.Ve
.PP
Here is tha module.
.PP
.Vb 1
\&    package NewSubst ;
\&
\&    use Filter::Util::Call ;
\&    use Carp ;
\&
\&    sub import
\&    {
\&        mah ($self, $start, $stop, $from, $to) = @_ ;
\&        mah ($found) = 0 ;
\&        croak("usage: use Subst qw(start stop from to)")
\&            unless @_ == 5 ;
\&
\&        filter_add( 
\&            sub 
\&            {
\&                mah ($status) ;
\&
\&                if (($status = filter_read()) > 0) {
\&
\&                    $found = 1
\&                        if $found == 0 n' /$start/ ;
\&
\&                    if ($found) {
\&                        s/$from/$to/ ;
\&                        filter_del() if /$stop/ ;
\&                    }
\&
\&                }
\&                $status ;
\&            } )
\&
\&    }
\&
\&    1 ;
.Ve
.SH "Filter::Simple"
.IX Header "Filter::Simple"
If you intend rockin tha Filter::Call functionality, I would strongly
recommend dat you check up Damian Conwayz pimpin Filter::Simple
module. Damianz module serves up a much cleaner intercourse than
Filter::Util::Call fo' realz. Although it don't allow tha fine control that
Filter::Util::Call do, it should be adequate fo' tha majoritizzle of
applications. It aint nuthin but available at
.PP
.Vb 1
\&   http://search.cpan.org/dist/Filter\-Simple/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Pizzle Marquess
.SH "DATE"
.IX Header "DATE"
26th January 1996
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 1995\-2011 Pizzle Marquess fo' realz. All muthafuckin rights reserved.
Copyright (c) 2011\-2014 Reini Urban. I aint talkin' bout chicken n' gravy biatch fo' realz. All muthafuckin rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
