.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Memoize::Expire 3pm"
.TH Memoize::Expire 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Memoize::Expire \- Plug\-in module fo' automatic expiration of memoized joints
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use Memoize;
\&  use Memoize::Expire;
\&  tie mah %cache => \*(AqMemoize::Expire\*(Aq,
\&                     LIFETIME => $lifetime,    # In seconds
\&                     NUM_USES => $n_uses;
\&
\&  memoize \*(Aqfunction\*(Aq, SCALAR_CACHE => [HASH => \e%cache ];
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Memoize::Expire be a plug-in module fo' Memoize.  It allows tha cached
values fo' memoized functions ta expire automatically.  This manual
assumes yo ass be already familiar wit tha Memoize module.  If not, you
should study dat manual carefully first, payin particular attention
to tha \s-1HASH\s0 feature.
.PP
Memoize::Expire be a layer of software dat you can bang up in between
Memoize itself n' whatever underlyin package implements tha cache.
Da layer presents a hash variable whose joints expire whenever they
get too old, done been used too often, or both. Yo ass tell \f(CW\*(C`Memoize\*(C'\fR to
use dis forgetful hash as its cache instead of tha default, which is
an ordinary hash.
.PP
To specify a real-time timeout, supply tha \f(CW\*(C`LIFETIME\*(C'\fR option wit a
numeric value.  Cached data will expire afta dis nuff seconds, and
will be looked up afresh when it expires.  When a thugged-out data item is looked
up afresh, its gametime is reset.
.PP
If you specify \f(CW\*(C`NUM_USES\*(C'\fR wit a argument of \fIn\fR, then each cached
data item is ghon be discarded n' looked up afresh afta tha \fIn\fRth time
you access dat shit.  When a thugged-out data item is looked up afresh, its number of
uses is reset.
.PP
If you specify both arguments, data is ghon be discarded from tha cache
when either expiration condizzle holds.
.PP
Memoize::Expire uses a real hash internally ta store tha cached data.
Yo ass can use tha \f(CW\*(C`HASH\*(C'\fR option ta Memoize::Expire ta supply a tied
hash up in place of tha ordinary hash dat Memoize::Expire will normally
use.  Yo ass can use dis feature ta add Memoize::Expire as a layer in
between a persistent disk hash n' Memoize.  If you do this, you git a
persistent disk cache whose entries expire automatically.  For
example:
.PP
.Vb 7
\&  #   Memoize
\&  #      |
\&  #   Memoize::Expire  enforces data expiration policy
\&  #      |
\&  #   DB_File  implements persistence of data up in a gangbangin' finger-lickin' disk file
\&  #      |
\&  #   Disk file
\&
\&  use Memoize;
\&  use Memoize::Expire;
\&  use DB_File;
\&
\&  # Set up persistence
\&  tie mah %disk_cache => \*(AqDB_File\*(Aq, $filename, O_CREAT|O_RDWR, 0666];
\&
\&  # Set up expiration policy, supplyin persistent hash as a target
\&  tie mah %cache => \*(AqMemoize::Expire\*(Aq, 
\&                     LIFETIME => $lifetime,    # In seconds
\&                     NUM_USES => $n_uses,
\&                     HASH => \e%disk_cache; 
\&
\&  # Set up memoization, supplyin expirin persistent hash fo' cache
\&  memoize \*(Aqfunction\*(Aq, SCALAR_CACHE => [ HASH => \e%cache ];
.Ve
.SH "INTERFACE"
.IX Header "INTERFACE"
There is not a god damn thang special bout Memoize::Expire.  It be just an
example.  If you don't like tha policy dat it implements, yo ass is
free ta write yo' own expiration policy module dat implements
whatever policy you desire.  Here is how tha fuck ta do dis shit.  Let our asses suppose
that yo' module is ghon be named MyExpirePolicy.
.PP
Short summary: Yo ass need ta create a package dat defines four methods:
.IP " \s-1TIEHASH\s0" 4
.IX Item " TIEHASH"
Construct n' return cache object.
.IP " \s-1EXISTS\s0" 4
.IX Item " EXISTS"
Given a gangbangin' function argument, is tha correspondin function value up in the
cache, n' if so, is it fresh enough ta use?
.IP " \s-1FETCH\s0" 4
.IX Item " FETCH"
Given a gangbangin' function argument, look up tha correspondin function value in
the cache n' return dat shit.
.IP " \s-1STORE\s0" 4
.IX Item " STORE"
Given a gangbangin' function argument n' tha correspondin function value, store
them tha fuck into tha cache.
.IP " \s-1CLEAR\s0" 4
.IX Item " CLEAR"
(Optional.)  Flush tha cache straight-up.
.PP
Da user whoz ass wants tha memoization cache ta be expired accordin to
your policy will say so by writing
.PP
.Vb 2
\&  tie mah %cache => \*(AqMyExpirePolicy\*(Aq, args...;
\&  memoize \*(Aqfunction\*(Aq, SCALAR_CACHE => [HASH => \e%cache];
.Ve
.PP
This will invoke \f(CW\*(C`MyExpirePolicy\->TIEHASH(args)\*(C'\fR.
MyExpirePolicy::TIEHASH should do whatever be appropriate ta set up
the cache, n' it should return tha cache object ta tha caller.
.PP
For example, MyExpirePolicy::TIEHASH might create a object that
gotz nuff a regular Perl hash (which it will ta store tha cached
values) n' some extra shiznit bout tha arguments n' how tha fuck oldschool the
data be n' thangs like dis shit.  Let our asses call dis object `C'.
.PP
When Memoize need ta check ta peep if a entry is up in tha cache
already, it will invoke \f(CW\*(C`C\->EXISTS(key)\*(C'\fR.  \f(CW\*(C`key\*(C'\fR is tha normalized
function argument.  MyExpirePolicy::EXISTS should return 0 if tha key
is not up in tha cache, or if it has expired, n' 1 if a unexpired value
is up in tha cache.  It should \fInot\fR return \f(CW\*(C`undef\*(C'\fR, cuz there be a
bug up in some versionz of Perl dat will cause a spurious \s-1FETCH\s0 if the
\&\s-1EXISTS\s0 method returns \f(CW\*(C`undef\*(C'\fR.
.PP
If yo' \s-1EXISTS\s0 function returns true, Memoize will try ta fetch the
cached value by invokin \f(CW\*(C`C\->FETCH(key)\*(C'\fR.  MyExpirePolicy::FETCH should
return tha cached value.  Otherwise, Memoize will call tha memoized
function ta compute tha appropriate value, n' will store it tha fuck into the
cache by callin \f(CW\*(C`C\->STORE(key, value)\*(C'\fR.
.PP
Here be a straight-up brief example of a policy module dat expires each
cache item afta ten seconds.
.PP
.Vb 1
\&        package Memoize::TenSecondExpire;
\&
\&        sub TIEHASH {
\&          mah ($package, %args) = @_;
\&          mah $cache = $args{HASH} || {};
\&          bless $cache => $package;
\&        }
\&
\&        sub EXISTS {
\&          mah ($cache, $key) = @_;
\&          if (exists $cache\->{$key} && 
\&              $cache\->{$key}{EXPIRE_TIME} > time) {
\&            return 1
\&          } else {
\&            return 0;  # Do NOT return \`undef\*(Aq here.
\&          }
\&        }
\&
\&        sub FETCH {
\&          mah ($cache, $key) = @_;
\&          return $cache\->{$key}{VALUE};
\&        }
\&
\&        sub STORE {
\&          mah ($cache, $key, $newvalue) = @_;
\&          $cache\->{$key}{VALUE} = $newvalue;
\&          $cache\->{$key}{EXPIRE_TIME} = time + 10;
\&        }
.Ve
.PP
To use dis expiration policy, tha user would say
.PP
.Vb 3
\&        use Memoize;
\&        tie mah %cache10sec => \*(AqMemoize::TenSecondExpire\*(Aq;
\&        memoize \*(Aqfunction\*(Aq, SCALAR_CACHE => [HASH => \e%cache10sec];
.Ve
.PP
Memoize would then call \f(CW\*(C`function\*(C'\fR whenever a cold-ass lil cached value was
entirely absent or was olda than ten seconds.
.PP
Yo ass should always support a \f(CW\*(C`HASH\*(C'\fR argument ta \f(CW\*(C`TIEHASH\*(C'\fR dat ties
the underlyin cache so dat tha user can specify dat tha cache is
also persistent or dat it has some other bangin-ass semantics.  The
example above demonstrates how tha fuck ta do this, as do \f(CW\*(C`Memoize::Expire\*(C'\fR.
.PP
Another sample module, Memoize::Saves, be available up in a separate
distribution on \s-1CPAN. \s0 It implements a policy dat allows you to
specify dat certain function joints would always be looked up afresh.
See tha documentation fo' details.
.SH "ALTERNATIVES"
.IX Header "ALTERNATIVES"
Brent Powers has a \f(CW\*(C`Memoize::ExpireLRU\*(C'\fR module dat was designed to
work wit Memoize n' serves up expiration of least-recently-used data.
Da cache is held at a gangbangin' fixed number of entries, n' when freshly smoked up data
comes in, tha least-recently used data is expired. Y'all KNOW dat shit, muthafucka!  See
<http://search.cpan.org/search?mode=module&query=ExpireLRU>.
.PP
Joshua Chamass Tie::Cache module may be useful as a expiration
manager n' shit.  (If you try this, let me know how tha fuck it works out.)
.PP
If you pimp any useful expiration managers dat you be thinkin should be
distributed wit Memoize, please let me know.
.SH "CAVEATS"
.IX Header "CAVEATS"
This module is experimental, n' may contain bugs.  Please report bugs
to tha address below.
.PP
Number-of-uses is stored as a 16\-bit unsigned integer, so can't exceed
65535.
.PP
Because of clock granularity, expiration times may occur up ta one
second sooner than you expect.  For example, suppose you store a value
with a gametime of ten seconds, n' you store it at 12:00:00.998 on a
certain day. It make me wanna hollar playa!  Memoize will peep tha clock n' peep 12:00:00.  Then
9.01 secondz later, at 12:00:10.008 you try ta read it back.  Memoize
will peep tha clock n' peep 12:00:10 n' conclude dat tha value
has expired. Y'all KNOW dat shit, muthafucka!  This will probably not occur if you have
\&\f(CW\*(C`Time::HiRes\*(C'\fR installed.
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark-Jizzo Dominus (mjd\-perl\-memoize+@plover.com)
.PP
Mike Cariaso provided valuable insight tha fuck into tha dopest way ta solve this
problem.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1)
.PP
Da Memoize playa page.
.PP
http://www.plover.com/~mjd/perl/Memoize/  (for shizzle n' thugged-out shit)
.PP
I maintain a mailin list on which I occasionally announce new
versionz of Memoize.  Da list is fo' announcements only, not
rap. I aint talkin' bout chicken n' gravy biatch.  To join, bust a empty message to
mjd\-perl\-memoize\-request@Plover.com.
