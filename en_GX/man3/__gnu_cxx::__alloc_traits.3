" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_cxx::__alloc_traits< _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBstd::allocator_traits< _Alloc >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBstd::allocator_traits\fP
.br
< _Alloc > \fB_Base_type\fP"
.br
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef \fB_Base_type::const_pointer\fP \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef const \fBvalue_type\fP & \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef __const_void_pointa \fBconst_void_pointer\fP"
.br
.ti -1c
.RI "typedef \fB_Base_type::difference_type\fP \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef \fB_Base_type::pointer\fP \fBpointer\fP"
.br
.ti -1c
.RI "typedef 
.br
__propagate_on_container_copy_assignment \fBpropagate_on_container_copy_assignment\fP"
.br
.ti -1c
.RI "typedef 
.br
__propagate_on_container_move_assignment \fBpropagate_on_container_move_assignment\fP"
.br
.ti -1c
.RI "typedef 
.br
__propagate_on_container_swap \fBpropagate_on_container_swap\fP"
.br
.ti -1c
.RI "template<typename _Tp > rockin \fBrebind_alloc\fP = typename __alloctr_rebind< _Alloc, _Tp >::__type"
.br
.ti -1c
.RI "template<typename _Tp > rockin \fBrebind_traits\fP = allocator_traits< rebind_alloc< _Tp >>"
.br
.ti -1c
.RI "typedef \fBvalue_type\fP & \fBreference\fP"
.br
.ti -1c
.RI "typedef \fB_Base_type::size_type\fP \fBsize_type\fP"
.br
.ti -1c
.RI "typedef \fB_Base_type::value_type\fP \fBvalue_type\fP"
.br
.ti -1c
.RI "typedef __void_pointa \fBvoid_pointer\fP"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static constexpr bool \fB_S_always_equal\fP ()"
.br
.ti -1c
.RI "static constexpr bool \fB_S_nothrow_move\fP ()"
.br
.ti -1c
.RI "static constexpr bool \fB_S_nothrow_swap\fP ()"
.br
.ti -1c
.RI "static void \fB_S_on_swap\fP (_Alloc &__a, _Alloc &__b)"
.br
.ti -1c
.RI "static constexpr bool \fB_S_propagate_on_copy_assign\fP ()"
.br
.ti -1c
.RI "static constexpr bool \fB_S_propagate_on_move_assign\fP ()"
.br
.ti -1c
.RI "static constexpr bool \fB_S_propagate_on_swap\fP ()"
.br
.ti -1c
.RI "static _Alloc \fB_S_select_on_copy\fP (const _Alloc &__a)"
.br
.ti -1c
.RI "static \fBpointer\fP \fBallocate\fP (_Alloc &__a, \fBsize_type\fP __n)"
.br
.ti -1c
.RI "static \fBpointer\fP \fBallocate\fP (_Alloc &__a, \fBsize_type\fP __n, \fBconst_void_pointer\fP __hint)"
.br
.ti -1c
.RI "template<typename _Ptr , typename\&.\&.\&. _Args> static \fBstd::enable_if\fP
.br
< __is_custom_pointer< _Ptr >
.br
::value >::type \fBconstruct\fP (_Alloc &__a, _Ptr __p, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename _Tp , typename\&.\&.\&. _Args> static auto \fBconstruct\fP (_Alloc &__a, _Tp *__p, _Args &&\&.\&.\&.__args) -> decltype(_S_construct(__a, __p, \fBstd::forward\fP< _Args >(__args)\&.\&.\&.))"
.br
.ti -1c
.RI "static void \fBdeallocate\fP (_Alloc &__a, \fBpointer\fP __p, \fBsize_type\fP __n)"
.br
.ti -1c
.RI "template<typename _Ptr > static \fBstd::enable_if\fP
.br
< __is_custom_pointer< _Ptr >
.br
::value >::type \fBdestroy\fP (_Alloc &__a, _Ptr __p)"
.br
.ti -1c
.RI "template<class _Tp > static void \fBdestroy\fP (_Alloc &__a, _Tp *__p)"
.br
.ti -1c
.RI "static \fBsize_type\fP \fBmax_size\fP (const _Alloc &__a)"
.br
.ti -1c
.RI "static _Alloc \fBselect_on_container_copy_construction\fP (const _Alloc &__rhs)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Alloc>struct __gnu_cxx::__alloc_traits< _Alloc >"
Uniform intercourse ta C++98 n' C++0x allocators\&. 
.PP
Definizzle at line 121 of file ext/alloc_traits\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename _Alloc> typedef __const_void_pointa \fBstd::allocator_traits\fP< _Alloc >::\fBconst_void_pointer\fP\fC [inherited]\fP"

.PP
Da allocatorz const void pointa type\&. \fCAlloc::const_void_pointer\fP if dat type exists, otherwise \fC pointer_traits<pointer>::rebind<const void> \fP 
.PP
Definizzle at line 140 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef __propagate_on_container_copy_assignment \fBstd::allocator_traits\fP< _Alloc >::\fBpropagate_on_container_copy_assignment\fP\fC [inherited]\fP"

.PP
How tha fuck tha allocator is propagated on copy assignment\&. \fCAlloc::propagate_on_container_copy_assignment\fP if dat type exists, otherwise \fCfalse_type\fP 
.PP
Definizzle at line 174 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef __propagate_on_container_move_assignment \fBstd::allocator_traits\fP< _Alloc >::\fBpropagate_on_container_move_assignment\fP\fC [inherited]\fP"

.PP
How tha fuck tha allocator is propagated on move assignment\&. \fCAlloc::propagate_on_container_move_assignment\fP if dat type exists, otherwise \fCfalse_type\fP 
.PP
Definizzle at line 186 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef __propagate_on_container_swap \fBstd::allocator_traits\fP< _Alloc >::\fBpropagate_on_container_swap\fP\fC [inherited]\fP"

.PP
How tha fuck tha allocator is propagated on swap\&. \fCAlloc::propagate_on_container_swap\fP if dat type exists, otherwise \fCfalse_type\fP 
.PP
Definizzle at line 197 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> typedef __void_pointa \fBstd::allocator_traits\fP< _Alloc >::\fBvoid_pointer\fP\fC [inherited]\fP"

.PP
Da allocatorz void pointa type\&. \fCAlloc::void_pointer\fP if dat type exists, otherwise \fC pointer_traits<pointer>::rebind<void> \fP 
.PP
Definizzle at line 129 of file bits/alloc_traits\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Alloc> static \fBpointer\fP \fBstd::allocator_traits\fP< _Alloc >::allocate (_Alloc &__a, \fBsize_type\fP__n)\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"

.PP
Allocate memory\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator\&. 
.br
\fI__n\fP Da number of objects ta allocate space for\&.
.RE
.PP
Calls \fCa\&.allocate(n)\fP 
.PP
Definizzle at line 350 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> static \fBpointer\fP \fBstd::allocator_traits\fP< _Alloc >::allocate (_Alloc &__a, \fBsize_type\fP__n, \fBconst_void_pointer\fP__hint)\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"

.PP
Allocate memory\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator\&. 
.br
\fI__n\fP Da number of objects ta allocate space for\&. 
.br
\fI__hint\fP Aid ta locality\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Memory of suitable size n' alignment fo' \fIn\fP objectz of type \fCvalue_type\fP 
.RE
.PP
Returns \fC a\&.allocate(n, hint) \fP if dat expression is well-formed, otherwise returns \fCa\&.allocate(n)\fP 
.PP
Definizzle at line 365 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> template<typename _Tp , typename\&.\&.\&. _Args> static auto \fBstd::allocator_traits\fP< _Alloc >::construct (_Alloc &__a, _Tp *__p, _Args &&\&.\&.\&.__args) -> decltype(_S_construct(__a, __p, \fBstd::forward\fP<_Args>(__args)\&.\&.\&.))
	\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"

.PP
Construct a object of type \fI_Tp\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator\&. 
.br
\fI__p\fP Pointa ta memory of suitable size n' alignment fo' Tp 
.br
\fI__args\fP Constructor arguments\&.
.RE
.PP
Calls \fC __a\&.construct(__p, std::forward<Args>(__args)\&.\&.\&.) \fP if dat expression is well-formed, otherwise uses placement-new ta construct a object of type \fI_Tp\fP at location \fI__p\fP from tha arguments \fI__args\fP\&.\&.\&. 
.PP
Definizzle at line 391 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> static void \fBstd::allocator_traits\fP< _Alloc >::deallocate (_Alloc &__a, \fBpointer\fP__p, \fBsize_type\fP__n)\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"

.PP
Deallocate memory\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator\&. 
.br
\fI__p\fP Pointa ta tha memory ta deallocate\&. 
.br
\fI__n\fP Da number of objects space was allocated for\&.
.RE
.PP
Calls \fC a\&.deallocate(p, n) \fP 
.PP
Definizzle at line 376 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> template<class _Tp > static void \fBstd::allocator_traits\fP< _Alloc >::destroy (_Alloc &__a, _Tp *__p)\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"

.PP
Destroy a object of type \fI_Tp\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator\&. 
.br
\fI__p\fP Pointa ta tha object ta destroy
.RE
.PP
Calls \fC__a\&.destroy(__p)\fP if dat expression is well-formed, otherwise calls \fC__p->~_Tp()\fP 
.PP
Definizzle at line 404 of file bits/alloc_traits\&.h\&.
.SS "template<typename _Alloc> static \fBsize_type\fP \fBstd::allocator_traits\fP< _Alloc >::max_size (const _Alloc &__a)\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"

.PP
Da maximum supported allocation size\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__a\fP An allocator\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fC__a\&.max_size()\fP or \fCnumeric_limits<size_type>::max()\fP 
.RE
.PP
Returns \fC__a\&.max_size()\fP if dat expression is well-formed, otherwise returns \fCnumeric_limits<size_type>::max()\fP 
.PP
Definizzle at line 415 of file bits/alloc_traits\&.h\&.
.PP
Referenced by std::forward_list< _Tp, _Alloc >::max_size()\&.
.SS "template<typename _Alloc> static _Alloc \fBstd::allocator_traits\fP< _Alloc >::select_on_container_copy_construction (const _Alloc &__rhs)\fC [inline]\fP, \fC [static]\fP, \fC [inherited]\fP"

.PP
Obtain a allocator ta use when copyin a cold-ass lil container\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__rhs\fP An allocator\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fC__rhs\&.select_on_container_copy_construction()\fP or \fI__rhs\fP 
.RE
.PP
Returns \fC__rhs\&.select_on_container_copy_construction()\fP if dat expression is well-formed, otherwise returns \fI__rhs\fP 
.PP
Definizzle at line 427 of file bits/alloc_traits\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
