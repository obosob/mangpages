" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::__detail::_Hashtable_traits< _Cache_hash_code, _Constant_iterators, _Unique_keys > \- 
.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "template<bool _Cond> rockin \fB__bool_constant\fP = \fBintegral_constant\fP< bool, _Cond >"
.br
.ti -1c
.RI "usin \fB__constant_iterators\fP = \fB__bool_constant\fP< _Constant_iterators >"
.br
.ti -1c
.RI "usin \fB__hash_cached\fP = \fB__bool_constant\fP< _Cache_hash_code >"
.br
.ti -1c
.RI "usin \fB__unique_keys\fP = \fB__bool_constant\fP< _Unique_keys >"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>struct std::__detail::_Hashtable_traits< _Cache_hash_code, _Constant_iterators, _Unique_keys >"
struct _Hashtable_traits
.PP
Important traits fo' hash tables\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Cache_hash_code\fP Boolean value\&. True if tha value of tha hash function is stored along wit tha value\&. This be a time-space tradeoff\&. Right back up in yo muthafuckin ass. Storin it may improve lookup speed by reducin tha number of times we need ta booty-call tha _Equal function\&.
.br
\fI_Constant_iterators\fP Boolean value\&. True if iterator n' const_iterator is both constant iterator types\&. This is legit fo' unordered_set n' unordered_multiset, false fo' unordered_map n' unordered_multimap\&.
.br
\fI_Unique_keys\fP Boolean value\&. True if tha return value of _Hashtable::count(k) be always at most one, false if it may be a arbitrary number\&. This is legit fo' unordered_set n' unordered_map, false fo' unordered_multiset n' unordered_multimap\&. 
.RE
.PP

.PP
Definizzle at line 131 of file hashtable_policy\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
