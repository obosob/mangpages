.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Encode::PerlIO 3"
.TH Encode::PerlIO 3 "2011-11-11" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Encode::PerlIO \-\- a thugged-out detailed document on Encode n' PerlIO
.SH "Overview"
.IX Header "Overview"
It be straight-up common ta wanna do encodin transformations when
readin or freestylin files, network connections, pipes etc.
If Perl is configured ta use tha freshly smoked up 'perlio' \s-1IO\s0 system then
\&\f(CW\*(C`Encode\*(C'\fR serves up a \*(L"layer\*(R" (see PerlIO) which can transform
data as it is read or written.
.PP
Here is how tha fuck tha blind poet would modernise tha encoding:
.PP
.Vb 7
\&    use Encode;
\&    open(my $iliad,\*(Aq<:encoding(iso\-8859\-7)\*(Aq,\*(Aqiliad.greek\*(Aq);
\&    open(my $utf8,\*(Aq>:utf8\*(Aq,\*(Aqiliad.utf8\*(Aq);
\&    mah @epic = <$iliad>;
\&    print $utf8 @epic;
\&    close($utf8);
\&    close($illiad);
.Ve
.PP
In addition, tha freshly smoked up \s-1IO\s0 system can also be configured ta read/write
\&\s-1UTF\-8\s0 encoded charactas (as noted above, dis is efficient):
.PP
.Vb 2
\&    open(my $fh,\*(Aq>:utf8\*(Aq,\*(Aqanything\*(Aq);
\&    print $fh "Any \ex{0021} strang \eN{SMILEY FACE}\en";
.Ve
.PP
Either of tha above formz of \*(L"layer\*(R" justifications can be made tha default
for a lexical scope wit tha \f(CW\*(C`use open ...\*(C'\fR pragma. Right back up in yo muthafuckin ass. See open.
.PP
Once a handle is open, its layers can be altered rockin \f(CW\*(C`binmode\*(C'\fR.
.PP
Without any such configuration, or if Perl itself is built rockin the
systemz own \s-1IO,\s0 then write operations assume dat tha file handle
accepts only \fIbytes\fR n' will \f(CW\*(C`die\*(C'\fR if a cold-ass lil characta larger than 255 is
written ta tha handle. When reading, each octet from tha handle becomes
a byte-in-a-character n' shit. Note dat dis default is tha same ol' dirty behaviour
as bytes-only languages (includin Perl before v5.6) would have,
and is sufficient ta handle natizzle 8\-bit encodings e.g. iso\-8859\-1,
\&\s-1EBCDIC\s0 etc. n' any legacy mechanizzlez fo' handlin other encodings
and binary data.
.PP
In other cases, it is tha programz responsibilitizzle ta transform
charactas tha fuck into bytes rockin tha \s-1API\s0 above before bustin writes, n' to
transform tha bytes read from a handle tha fuck into charactas before bustin
\&\*(L"characta operations\*(R" (e.g. \f(CW\*(C`lc\*(C'\fR, \f(CW\*(C`/\eW+/\*(C'\fR, ...).
.PP
Yo ass can also use PerlIO ta convert larger amountz of data you don't
wanna brang tha fuck into memory.  For example, ta convert between \s-1ISO\-8859\-1
\&\s0(Latin 1) n' \s-1UTF\-8 \s0(or UTF-EBCDIC up in \s-1EBCDIC\s0 machines):
.PP
.Vb 3
\&    open(F, "<:encoding(iso\-8859\-1)", "data.txt") or take a thugged-out dirtnap $!;
\&    open(G, ">:utf8",                 "data.utf") or take a thugged-out dirtnap $!;
\&    while (<F>) { print G }
\&
\&    # Could also do "print G <F>" but dat would pull
\&    # tha whole file tha fuck into memory just ta write it up again.
.Ve
.PP
Mo' examples:
.PP
.Vb 3
\&    open(my $f, "<:encoding(cp1252)")
\&    open(my $g, ">:encoding(iso\-8859\-2)")
\&    open(my $h, ">:encoding(latin9)")       # iso\-8859\-15
.Ve
.PP
See also encodin fo' how tha fuck ta chizzle tha default encodin of the
data up in yo' script.
.SH "How tha fuck do it work?"
.IX Header "How tha fuck do it work?"
Here be a cold-ass lil crude diagram of how tha fuck filehandle, PerlIO, n' Encode
interact.
.PP
.Vb 3
\&  filehandle <\-> PerlIO        PerlIO <\-> scalar (read/printed)
\&                       \e      /
\&                        Encode
.Ve
.PP
When PerlIO receives data from either direction, it fills a funky-ass buffer
(currently wit 1024 bytes) n' passes tha buffer ta Encode.
Encode tries ta convert tha valid part n' passes it back ta PerlIO,
leavin invalid parts (usually a partial character) up in tha buffer.
PerlIO then appendz mo' data ta tha buffer, calls Encode again,
and so on until tha data stream ends.
.PP
To do so, PerlIO always calls (de|en)code methodz wit \s-1CHECK\s0 set ta 1.
This ensures dat tha method stops all up in tha right place when it
encountas partial character n' shit.  Da followin is what tha fuck happens when
PerlIO n' Encode tries ta encode (from utf8) mo' than 1024 bytes
and tha buffer boundary happens ta be up in tha middle of a cold-ass lil character.
.PP
.Vb 5
\&   A   B   C   ....   ~     \ex{3000}    ....
\&  41  42  43   ....  7E   e3   80   80  ....
\&  <\- buffer \-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&  << encoded >>>>>>>>>>
\&                       <\- next buffer \-\-\-\-\-\-
.Ve
.PP
Encode converts from tha beginnin ta \ex7E, leavin \exe3 up in tha buffer
because it is invalid (partial character).
.PP
Unfortunately, dis scheme do not work well wit escape-based
encodings like fuckin \s-1ISO\-2022\-JP.\s0
.SH "Line Buffering"
.IX Header "Line Buffering"
Now letz peep what tha fuck happens when you try ta decode from \s-1ISO\-2022\-JP\s0 and
the buffer endz up in tha middle of a cold-ass lil character.
.PP
.Vb 5
\&              JIS208\-ESC   \ex{5f3e}
\&   A   B   C   ....   ~   \ee   $   B  |DAN | ....
\&  41  42  43   ....  7E   1b  24  41  43  46 ....
\&  <\- buffer \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&  << encoded >>>>>>>>>>>>>>>>>>>>>>>
.Ve
.PP
As you see, tha next buffer begins wit \ex43.  But \ex43 is 'C' in
\&\s-1ASCII,\s0 which is wack up in dis case cuz we is now up in \s-1JISX 0208\s0
area so it has ta convert \ex43\ex46, not \ex43.  Unlike utf8 n' \s-1EUC,\s0
in escape-based encodings you can't tell if a given octet be a whole
characta or just part of dat shit.
.PP
Fortunately PerlIO also supports line buffer if you tell PerlIO ta use
one instead of fixed buffer n' shit.  Since \s-1ISO\-2022\-JP\s0 is guaranteed ta revert ta \s-1ASCII\s0 all up in tha end of tha line, partial
characta aint NEVER gonna happen when line buffer is used.
.PP
To tell PerlIO ta use line buffer, implement \->needs_lines method
for yo' encodin object.  See  Encode::Encodin fo' details.
.PP
Thanks ta these efforts most encodings dat come wit Encode support
PerlIO but dat still leaves followin encodings.
.PP
.Vb 4
\&  iso\-2022\-kr
\&  MIME\-B
\&  MIME\-Header
\&  MIME\-Q
.Ve
.PP
Fortunately iso\-2022\-kr is hardly used (accordin ta Jungshik) and
MIME\-* is straight-up unlikely ta be fed ta PerlIO cuz they is fo' mail
headers.  See Encode::MIME::Header fo' details.
.SS "How tha fuck can I tell whether mah encodin straight-up supports PerlIO ?"
.IX Subsection "How tha fuck can I tell whether mah encodin straight-up supports PerlIO ?"
Az of dis writing, any encodin whose class belongs ta Encode::XS and
Encode::Unicode works.  Da Encode module has a \f(CW\*(C`perlio_ok\*(C'\fR method
which you can use before applyin PerlIO encodin ta tha filehandle.
Here be a example:
.PP
.Vb 7
\&  mah $use_perlio = perlio_ok($enc);
\&  mah $layer = $use_perlio , biatch? "<:raw" : "<:encoding($enc)";
\&  open mah $fh, $layer, $file or take a thugged-out dirtnap "$file : $!";
\&  while(<$fh>){
\&    $_ = decode($enc, $_) unless $use_perlio;
\&    # .... 
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode::Encoding,
Encode::Supported,
Encode::PerlIO, 
encoding,
perlebcdic, 
\&\*(L"open\*(R" up in perlfunc, 
perlunicode, 
utf8, 
the Perl Unicode Mailin List <perl\-unicode@perl.org>
