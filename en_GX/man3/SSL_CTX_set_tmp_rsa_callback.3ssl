.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_CTX_set_tmp_rsa_callback 3"
.TH SSL_CTX_set_tmp_rsa_callback 3 "2015-01-13" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_CTX_set_tmp_rsa_callback, SSL_CTX_set_tmp_rsa, SSL_CTX_need_tmp_rsa, SSL_set_tmp_rsa_callback, SSL_set_tmp_rsa, SSL_need_tmp_rsa \- handle RSA keys fo' ephemeral key exchange
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& void SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx,
\&            RSA *(*tmp_rsa_callback)(SSL *ssl, int is_export, int keylength));
\& long SSL_CTX_set_tmp_rsa(SSL_CTX *ctx, RSA *rsa);
\& long SSL_CTX_need_tmp_rsa(SSL_CTX *ctx);
\&
\& void SSL_set_tmp_rsa_callback(SSL_CTX *ctx,
\&            RSA *(*tmp_rsa_callback)(SSL *ssl, int is_export, int keylength));
\& long SSL_set_tmp_rsa(SSL *ssl, RSA *rsa)
\& long SSL_need_tmp_rsa(SSL *ssl)
\&
\& RSA *(*tmp_rsa_callback)(SSL *ssl, int is_export, int keylength);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISSL_CTX_set_tmp_rsa_callback()\fR sets tha callback function fo' \fBctx\fR ta be
used when a temporary/ephemeral \s-1RSA\s0 key is required ta \fBtmp_rsa_callback\fR.
Da callback is inherited by all \s-1SSL\s0 objects newly pimped from \fBctx\fR
with <\fISSL_new\fR\|(3)|\fISSL_new\fR\|(3)> fo' realz. Already pimped \s-1SSL\s0 objects is not affected.
.PP
\&\fISSL_CTX_set_tmp_rsa()\fR sets tha temporary/ephemeral \s-1RSA\s0 key ta be used ta be
\&\fBrsa\fR. Da key is inherited by all \s-1SSL\s0 objects newly pimped from \fBctx\fR
with <\fISSL_new\fR\|(3)|\fISSL_new\fR\|(3)> fo' realz. Already pimped \s-1SSL\s0 objects is not affected.
.PP
\&\fISSL_CTX_need_tmp_rsa()\fR returns 1, if a temporary/ephemeral \s-1RSA\s0 key is needed
for RSA-based strength-limited 'exportable' ciphersuites cuz a \s-1RSA\s0 key
with a keysize larger than 512 bits is installed.
.PP
\&\fISSL_set_tmp_rsa_callback()\fR sets tha callback only fo' \fBssl\fR.
.PP
\&\fISSL_set_tmp_rsa()\fR sets tha key only fo' \fBssl\fR.
.PP
\&\fISSL_need_tmp_rsa()\fR returns 1, if a temporary/ephemeral \s-1RSA\s0 key is needed,
for RSA-based strength-limited 'exportable' ciphersuites cuz a \s-1RSA\s0 key
with a keysize larger than 512 bits is installed.
.PP
These functions apply ta \s-1SSL/TLS\s0 servers only.
.SH "NOTES"
.IX Header "NOTES"
When rockin a cold-ass lil cipher wit \s-1RSA\s0 authentication, a ephemeral \s-1RSA\s0 key exchange
can take place. In dis case tha session data is negotiated rockin the
ephemeral/temporary \s-1RSA\s0 key n' tha \s-1RSA\s0 key supplied n' certified
by tha certificate chain is only used fo' signing.
.PP
Under previous export restrictions, ciphers wit \s-1RSA\s0 keys shorta (512 bits)
than tha usual key length of 1024 bits was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. To use these ciphers
with \s-1RSA\s0 keyz of usual length, a ephemeral key exchange must be performed,
as tha aiiight (certified) key cannot be directly used.
.PP
Usin ephemeral \s-1RSA\s0 key exchange yieldz forward secrecy, as tha connection
can only be decrypted, when tha \s-1RSA\s0 key is known. I aint talkin' bout chicken n' gravy biatch. By generatin a temporary
\&\s-1RSA\s0 key inside tha server application dat is lost when tha application
is left, it becomes impossible fo' a attacker ta decrypt past sessions,
even if he gets hold of tha aiiight (certified) \s-1RSA\s0 key, as dis key was
used fo' signin only. Da downside is dat bustin a \s-1RSA\s0 key is
computationally expensive.
.PP
Additionally, tha use of ephemeral \s-1RSA\s0 key exchange is only allowed in
the \s-1TLS\s0 standard, when tha \s-1RSA\s0 key can be used fo' signin only, dat is
for export ciphers. Usin ephemeral \s-1RSA\s0 key exchange fo' other purposes
violates tha standard n' can break interoperabilitizzle wit clients.
It be therefore straight fuckin recommended ta not use ephemeral \s-1RSA\s0 key
exchange n' use \s-1EDH \s0(Ephemeral Diffie-Hellman) key exchange instead
in order ta big up forward secrecy (see
\&\fISSL_CTX_set_tmp_dh_callback\fR\|(3)).
.PP
An application may either directly specify tha key or can supply tha key via a
callback function. I aint talkin' bout chicken n' gravy biatch. Da callback approach has tha advantage, dat tha callback
may generate tha key only up in case it is straight-up needed. Y'all KNOW dat shit, muthafucka! As tha generation of a
\&\s-1RSA\s0 key is however costly, it will lead ta a thugged-out dope delay up in tha handshake
procedure.  Another advantage of tha callback function is dat it can supply
keyz of different size while tha explicit settin of tha key is only useful for
key size of 512 bits ta satisfy tha export restricted ciphers n' do give
away key length if a longer key would be allowed.
.PP
Da \fBtmp_rsa_callback\fR is called wit tha \fBkeylength\fR needed and
the \fBis_export\fR shiznit. I aint talkin' bout chicken n' gravy biatch. Da \fBis_export\fR flag is set, when the
ephemeral \s-1RSA\s0 key exchange is performed wit a export cipher.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Generate temporary \s-1RSA\s0 keys ta prepare ephemeral \s-1RSA\s0 key exchange fo' realz. As the
generation of a \s-1RSA\s0 key costs a shitload of computa time, they saved fo' later
reuse. For demonstration purposes, two keys fo' 512 bits n' 1024 bits
respectively is generated.
.PP
.Vb 4
\& ...
\& /* Set up ephemeral RSA shiznit */
\& RSA *rsa_512 = NULL;
\& RSA *rsa_1024 = NULL;
\&
\& rsa_512 = RSA_generate_key(512,RSA_F4,NULL,NULL);
\& if (rsa_512 == NULL)
\&     evaluate_error_queue();
\&
\& rsa_1024 = RSA_generate_key(1024,RSA_F4,NULL,NULL);
\& if (rsa_1024 == NULL)
\&   evaluate_error_queue();
\&
\& ...
\&
\& RSA *tmp_rsa_callback(SSL *s, int is_export, int keylength)
\& {
\&    RSA *rsa_tmp=NULL;
\&
\&    switch (keylength) {
\&    case 512:
\&      if (rsa_512)
\&        rsa_tmp = rsa_512;
\&      else { /* generate on tha fly, should not happen up in dis example */
\&        rsa_tmp = RSA_generate_key(keylength,RSA_F4,NULL,NULL);
\&        rsa_512 = rsa_tmp; /* Remember fo' lata reuse */
\&      }
\&      break;
\&    case 1024:
\&      if (rsa_1024)
\&        rsa_tmp=rsa_1024;
\&      else
\&        should_not_happen_in_this_example();
\&      break;
\&    default:
\&      /* Generatin a key on tha fly is straight-up costly, so use what tha fuck is there */
\&      if (rsa_1024)
\&        rsa_tmp=rsa_1024;
\&      else
\&        rsa_tmp=rsa_512; /* Use at least a gangbangin' finger-lickin' dirty-ass shorta key */
\&    }
\&    return(rsa_tmp);
\& }
.Ve
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fISSL_CTX_set_tmp_rsa_callback()\fR n' \fISSL_set_tmp_rsa_callback()\fR do not return
diagnostic output.
.PP
\&\fISSL_CTX_set_tmp_rsa()\fR n' \fISSL_set_tmp_rsa()\fR do return 1 on success n' 0
on failure. Peep tha error queue ta smoke up tha reason of failure.
.PP
\&\fISSL_CTX_need_tmp_rsa()\fR n' \fISSL_need_tmp_rsa()\fR return 1 if a temporary
\&\s-1RSA\s0 key is needed n' 0 otherwise.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIssl\fR\|(3), \fISSL_CTX_set_cipher_list\fR\|(3),
\&\fISSL_CTX_set_options\fR\|(3),
\&\fISSL_CTX_set_tmp_dh_callback\fR\|(3),
\&\fISSL_new\fR\|(3), \fIciphers\fR\|(1)
