" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBstd::__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits >\fP, \fBstd::__detail::_Map_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits >\fP, \fBstd::__detail::_Insert< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits >\fP, \fBstd::__detail::_Rehash_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits >\fP, n' \fBstd::__detail::_Equality< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "usin \fBconst_iterator\fP = typename \fB__hashtable_base::const_iterator\fP"
.br
.ti -1c
.RI "usin \fBconst_local_iterator\fP = typename \fB__hashtable_base::const_local_iterator\fP"
.br
.ti -1c
.RI "typedef _Alloc::const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef _Alloc::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "usin \fBdifference_type\fP = typename __hashtable_base::difference_type"
.br
.ti -1c
.RI "usin \fBiterator\fP = typename \fB__hashtable_base::iterator\fP"
.br
.ti -1c
.RI "typedef _Equal \fBkey_equal\fP"
.br
.ti -1c
.RI "typedef _Key \fBkey_type\fP"
.br
.ti -1c
.RI "usin \fBlocal_iterator\fP = typename \fB__hashtable_base::local_iterator\fP"
.br
.ti -1c
.RI "typedef _Alloc::pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Alloc::reference \fBreference\fP"
.br
.ti -1c
.RI "usin \fBsize_type\fP = typename __hashtable_base::size_type"
.br
.ti -1c
.RI "typedef _Value \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB_Hashtable\fP (size_type __bucket_hint, const _H1 &, const _H2 &, const _Hash &, const _Equal &, const _ExtractKey &, const allocator_type &)"
.br
.ti -1c
.RI "template<typename _InputIterator > \fB_Hashtable\fP (_InputIterator __first, _InputIterator __last, size_type __bucket_hint, const _H1 &, const _H2 &, const _Hash &, const _Equal &, const _ExtractKey &, const allocator_type &)"
.br
.ti -1c
.RI "\fB_Hashtable\fP (const \fB_Hashtable\fP &)"
.br
.ti -1c
.RI "\fB_Hashtable\fP (\fB_Hashtable\fP &&)"
.br
.ti -1c
.RI "\fB_Hashtable\fP (size_type __n=10, const _H1 &__hf=_H1(), const key_equal &__eql=key_equal(), const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "template<typename _InputIterator > \fB_Hashtable\fP (_InputIterator __f, _InputIterator __l, size_type __n=0, const _H1 &__hf=_H1(), const key_equal &__eql=key_equal(), const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fB_Hashtable\fP (\fBinitializer_list\fP< value_type > __l, size_type __n=0, const _H1 &__hf=_H1(), const key_equal &__eql=key_equal(), const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "const _RehashPolicy & \fB__rehash_policy\fP () const "
.br
.ti -1c
.RI "void \fB__rehash_policy\fP (const _RehashPolicy &)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fB_Hashtable\fP< _Key, _Value, 
.br
_Alloc, _ExtractKey, _Equal, 
.br
_H1, _H2, _Hash, _RehashPolicy, 
.br
_Traits >::__node_type * \fB_M_allocate_node\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBstd::pair\fP< typename \fB_Hashtable\fP
.br
< _Key, _Value, _Alloc, 
.br
_ExtractKey, _Equal, _H1, _H2, 
.br
_Hash, _RehashPolicy, _Traits >
.br
::iterator, bool > \fB_M_emplace\fP (\fBstd::true_type\fP, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fB_Hashtable\fP< _Key, _Value, 
.br
_Alloc, _ExtractKey, _Equal, 
.br
_H1, _H2, _Hash, _RehashPolicy, 
.br
_Traits >::iterator \fB_M_emplace\fP (\fBstd::false_type\fP, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename _Arg > \fBstd::pair\fP< typename \fB_Hashtable\fP
.br
< _Key, _Value, _Alloc, 
.br
_ExtractKey, _Equal, _H1, _H2, 
.br
_Hash, _RehashPolicy, _Traits >
.br
::iterator, bool > \fB_M_insert\fP (_Arg &&__v, \fBstd::true_type\fP)"
.br
.ti -1c
.RI "template<typename _Arg > \fB_Hashtable\fP< _Key, _Value, 
.br
_Alloc, _ExtractKey, _Equal, 
.br
_H1, _H2, _Hash, _RehashPolicy, 
.br
_Traits >::iterator \fB_M_insert\fP (_Arg &&__v, \fBstd::false_type\fP)"
.br
.ti -1c
.RI "iterator \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "const_iterator \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "local_iterator \fBbegin\fP (size_type __n)"
.br
.ti -1c
.RI "const_local_iterator \fBbegin\fP (size_type __n) const "
.br
.ti -1c
.RI "size_type \fBbucket\fP (const key_type &__k) const "
.br
.ti -1c
.RI "size_type \fBbucket_count\fP () const noexcept"
.br
.ti -1c
.RI "size_type \fBbucket_size\fP (size_type __n) const "
.br
.ti -1c
.RI "const_iterator \fBcbegin\fP () const noexcept"
.br
.ti -1c
.RI "const_local_iterator \fBcbegin\fP (size_type __n) const "
.br
.ti -1c
.RI "const_iterator \fBcend\fP () const noexcept"
.br
.ti -1c
.RI "const_local_iterator \fBcend\fP (size_type __n) const "
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "size_type \fBcount\fP (const key_type &__k) const "
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> __ireturn_type \fBemplace\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> iterator \fBemplace_hint\fP (const_iterator, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "iterator \fBend\fP () noexcept"
.br
.ti -1c
.RI "const_iterator \fBend\fP () const noexcept"
.br
.ti -1c
.RI "local_iterator \fBend\fP (size_type __n)"
.br
.ti -1c
.RI "const_local_iterator \fBend\fP (size_type __n) const "
.br
.ti -1c
.RI "\fBstd::pair\fP< iterator, iterator > \fBequal_range\fP (const key_type &__k)"
.br
.ti -1c
.RI "\fBstd::pair\fP< const_iterator, 
.br
const_iterator > \fBequal_range\fP (const key_type &__k) const "
.br
.ti -1c
.RI "iterator \fBerase\fP (const_iterator)"
.br
.ti -1c
.RI "iterator \fBerase\fP (iterator __it)"
.br
.ti -1c
.RI "size_type \fBerase\fP (const key_type &__k)"
.br
.ti -1c
.RI "iterator \fBerase\fP (const_iterator, const_iterator)"
.br
.ti -1c
.RI "iterator \fBfind\fP (const key_type &__k)"
.br
.ti -1c
.RI "const_iterator \fBfind\fP (const key_type &__k) const "
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const noexcept"
.br
.ti -1c
.RI "key_equal \fBkey_eq\fP () const "
.br
.ti -1c
.RI "float \fBload_factor\fP () const noexcept"
.br
.ti -1c
.RI "size_type \fBmax_bucket_count\fP () const noexcept"
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const noexcept"
.br
.ti -1c
.RI "\fB_Hashtable\fP & \fBoperator=\fP (const \fB_Hashtable\fP &__ht)"
.br
.ti -1c
.RI "\fB_Hashtable\fP & \fBoperator=\fP (\fB_Hashtable\fP &&__ht)"
.br
.ti -1c
.RI "\fB_Hashtable\fP & \fBoperator=\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "void \fBrehash\fP (size_type __n)"
.br
.ti -1c
.RI "size_type \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "void \fBswap\fP (\fB_Hashtable\fP &)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "size_type \fB_M_bucket_index\fP (__node_type *__n) const "
.br
.ti -1c
.RI "size_type \fB_M_bucket_index\fP (const key_type &__k, __hash_code __c) const "
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBstd::pair\fP< iterator, bool > \fB_M_emplace\fP (\fBstd::true_type\fP, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> iterator \fB_M_emplace\fP (\fBstd::false_type\fP, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "const _Equal & \fB_M_eq\fP () const "
.br
.ti -1c
.RI "_Equal & \fB_M_eq\fP ()"
.br
.ti -1c
.RI "bool \fB_M_equals\fP (const _Key &__k, __hash_code __c, __node_type *__n) const "
.br
.ti -1c
.RI "size_type \fB_M_erase\fP (\fBstd::true_type\fP, const key_type &)"
.br
.ti -1c
.RI "size_type \fB_M_erase\fP (\fBstd::false_type\fP, const key_type &)"
.br
.ti -1c
.RI "iterator \fB_M_erase\fP (size_type __bkt, __node_base *__prev_n, __node_type *__n)"
.br
.ti -1c
.RI "__node_base * \fB_M_find_before_node\fP (size_type, const key_type &, __hash_code) const "
.br
.ti -1c
.RI "__node_type * \fB_M_find_node\fP (size_type __bkt, const key_type &__key, __hash_code __c) const "
.br
.ti -1c
.RI "__node_base * \fB_M_get_previous_node\fP (size_type __bkt, __node_base *__n)"
.br
.ti -1c
.RI "template<typename _Arg > \fBstd::pair\fP< iterator, bool > \fB_M_insert\fP (_Arg &&, \fBstd::true_type\fP)"
.br
.ti -1c
.RI "template<typename _Arg > iterator \fB_M_insert\fP (_Arg &&, \fBstd::false_type\fP)"
.br
.ti -1c
.RI "void \fB_M_insert_bucket_begin\fP (size_type, __node_type *)"
.br
.ti -1c
.RI "iterator \fB_M_insert_multi_node\fP (__hash_code __code, __node_type *__n)"
.br
.ti -1c
.RI "iterator \fB_M_insert_unique_node\fP (size_type __bkt, __hash_code __code, __node_type *__n)"
.br
.ti -1c
.RI "void \fB_M_remove_bucket_begin\fP (size_type __bkt, __node_type *__next_n, size_type __next_bkt)"
.br
.ti -1c
.RI "void \fB_M_swap\fP (_Hashtable_base &__x)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<typename _Keya , typename _Valuea , typename _Alloca , typename _ExtractKeya , typename _Equala , typename _H1a , typename _H2a , typename _Hasha , typename _RehashPolicya , typename _Traitsa , bool _Constant_iteratorsa, bool _Unique_keysa> struct \fB__detail::_Insert\fP"
.br
.ti -1c
.RI "template<typename _Keya , typename _Valuea , typename _Alloca , typename _ExtractKeya , typename _Equala , typename _H1a , typename _H2a , typename _Hasha , typename _RehashPolicya , typename _Traitsa > struct \fB__detail::_Insert_base\fP"
.br
.ti -1c
.RI "template<typename _Keya , typename _Valuea , typename _Alloca , typename _ExtractKeya , typename _Equala , typename _H1a , typename _H2a , typename _Hasha , typename _RehashPolicya , typename _Traitsa , bool _Unique_keysa> struct \fB__detail::_Map_base\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Key, typename _Value, typename _Alloc, typename _ExtractKey, typename _Equal, typename _H1, typename _H2, typename _Hash, typename _RehashPolicy, typename _Traits>class std::_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits >"
Primary class template _Hashtable\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Value\fP CopyConstructible type\&.
.br
\fI_Key\fP CopyConstructible type\&.
.br
\fI_Alloc\fP An allocator type ([lib\&.allocator\&.requirements]) whose _Alloc::value_type is _Value\& fo' realz. As a cold-ass lil conformin extension, we allow fo' _Alloc::value_type != _Value\&.
.br
\fI_ExtractKey\fP Function object dat takes a object of type _Value n' returns a value of type _Key\&.
.br
\fI_Equal\fP Function object dat takes two objectz of type k n' returns a funky-ass bool-like value dat is legit if tha two objects is considered equal\&.
.br
\fI_H1\fP Da hash function\& fo' realz. A unary function object wit argument type _Key n' result type size_t\&. Return joints should be distributed over tha entire range [0, numeric_limits<size_t>:max()]\&.
.br
\fI_H2\fP Da range-hashin function (in tha terminologizzle of Tavori n' Dreizin)\& fo' realz. A binary function object whose argument types n' result type is all size_t\&. Given arguments r n' N, tha return value is up in tha range [0, N)\&.
.br
\fI_Hash\fP Da ranged hash function (Tavori n' Dreizin)\& fo' realz. A binary function whose argument types is _Key n' size_t n' whose result type is size_t\&. Given arguments k n' N, tha return value is up in tha range [0, N)\&. Default: hash(k, N) = h2(h1(k), N)\&. If _Hash be anythang other than tha default, _H1 n' _H2 is ignored\&.
.br
\fI_RehashPolicy\fP Policy class wit three members, all of which govern tha bucket count\&. _M_next_bkt(n) returns a funky-ass bucket count no smalla than n\&. _M_bkt_for_elements(n) returns a funky-ass bucket count appropriate fo' a element count of n\&. _M_need_rehash(n_bkt, n_elt, n_ins) determines whether, if tha current bucket count is n_bkt n' tha current element count is n_elt, we need ta increase tha bucket count\&. If so, returns make_pair(true, n), where n is tha freshly smoked up bucket count\&. If not, returns make_pair(false, <anything>)
.br
\fI_Traits\fP Compile-time class wit three boolean std::integral_constant members: __cache_hash_code, __constant_iterators, __unique_keys\&.
.RE
.PP
Each _Hashtable data structure has:
.PP
.IP "\(bu" 2
_Bucket[] _M_buckets
.IP "\(bu" 2
_Hash_node_base _M_bbegin
.IP "\(bu" 2
size_type _M_bucket_count
.IP "\(bu" 2
size_type _M_element_count
.PP
.PP
with _Bucket bein _Hash_node* n' _Hash_node containing:
.PP
.IP "\(bu" 2
_Hash_node* _M_next
.IP "\(bu" 2
Tp _M_value
.IP "\(bu" 2
size_t _M_hash_code if cache_hash_code is true
.PP
.PP
In termz of Standard containers tha hashtable is like tha aggregation of:
.PP
.IP "\(bu" 2
std::forward_list<_Node> containin tha elements
.IP "\(bu" 2
std::vector<std::forward_list<_Node>::iterator> representin tha buckets
.PP
.PP
Da non-empty buckets contain tha node before tha straight-up original gangsta node up in tha bucket\&. This design make it possible ta implement suttin' like a std::forward_list::insert_afta on container insertion n' std::forward_list::erase_afta on container erase calls\&. _M_before_begin is equivalent ta std::forward_list::before_begin\&. Empty buckets contain nullptr\&. Note dat one of tha non-empty buckets gotz nuff &_M_before_begin which aint a thugged-out dereferenceable node so tha node pointa up in a funky-ass bucket shall never be dereferenced, only its next node can be\&.
.PP
Walkin all up in a funky-ass bucketz nodes requires a cold-ass lil check on tha hash code ta peep if each node is still up in tha bucket\&. Right back up in yo muthafuckin ass. Such a thugged-out design assumes a like efficient hash functor n' is one of tha reasons it is highly advisable ta set __cache_hash_code ta true\&.
.PP
Da container iterators is simply built from nodes\&. This way incrementin tha iterator is perfectly efficient independent of how tha fuck nuff empty buckets there be up in tha container\&.
.PP
On bang we compute tha elementz hash code n' use it ta find tha bucket index\&. If tha element must be banged up in a empty bucket we add it all up in tha beginnin of tha singly linked list n' make tha bucket point ta _M_before_begin\&. Da bucket dat used ta point ta _M_before_begin, if any, is updated ta point ta its freshly smoked up before begin node\&.
.PP
On erase, tha simple iterator design requires rockin tha hash functor ta git tha index of tha bucket ta update\&. For dis reason, when __cache_hash_code is set ta false tha hash functor must not throw n' dis is enforced by a static assertion\&.
.PP
Functionalitizzle is implemented by decomposizzle tha fuck into base classes, where tha derived _Hashtable class is used up in _Map_base, _Insert, _Rehash_base, n' _Equalitizzle base classes ta access tha 'this' pointer\&. _Hashtable_base is used up in tha base classes as a non-recursive, fully-completed-type so dat detailed nested type shiznit, like fuckin iterator type n' node type, can be used\&. This is similar ta tha 'Curiously Recurrin Template
Pattern' (CRTP) technique yo, but uses a reconstructed, not explicitly passed, template pattern\&.
.PP
Base class templates are:
.IP "\(bu" 2
__detail::_Hashtable_base
.IP "\(bu" 2
__detail::_Map_base
.IP "\(bu" 2
__detail::_Insert
.IP "\(bu" 2
__detail::_Rehash_base
.IP "\(bu" 2
__detail::_Equalitizzle 
.PP

.PP
Definizzle at line 174 of file bits/hashtable\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
