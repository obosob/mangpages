.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tie::Array 3pm"
.TH Tie::Array 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tie::Array \- base class fo' tied arrays
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package Tie::NewArray;
\&    use Tie::Array;
\&    @ISA = (\*(AqTie::Array\*(Aq);
\&
\&    # mandatory methods
\&    sub TIEARRAY { ... }
\&    sub FETCH { ... }
\&    sub FETCHSIZE { ... }
\&
\&    sub STORE { ... }        # mandatory if elements writeable
\&    sub STORESIZE { ... }    # mandatory if elements can be added/deleted
\&    sub EXISTS { ... }       # mandatory if exists() sposed ta fuckin work
\&    sub DELETE { ... }       # mandatory if delete() sposed ta fuckin work
\&
\&    # optionizzle methodz \- fo' efficiency
\&    sub CLEAR { ... }
\&    sub PUSH { ... }
\&    sub POP { ... }
\&    sub SHIFT { ... }
\&    sub UNSHIFT { ... }
\&    sub SPLICE { ... }
\&    sub EXTEND { ... }
\&    sub DESTROY { ... }
\&
\&    package Tie::NewStdArray;
\&    use Tie::Array;
\&
\&    @ISA = (\*(AqTie::StdArray\*(Aq);
\&
\&    # all methodz provided by default
\&
\&    package main;
\&
\&    $object = tie @somearray,\*(AqTie::NewArray\*(Aq;
\&    $object = tie @somearray,\*(AqTie::StdArray\*(Aq;
\&    $object = tie @somearray,\*(AqTie::NewStdArray\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up methodz fo' array-tyin classes. Right back up in yo muthafuckin ass. See
perltie fo' a list of tha functions required up in order ta tie a array
to a package. Da basic \fBTie::Array\fR package serves up stub \f(CW\*(C`DESTROY\*(C'\fR,
and \f(CW\*(C`EXTEND\*(C'\fR methodz dat do nothing, stub \f(CW\*(C`DELETE\*(C'\fR n' \f(CW\*(C`EXISTS\*(C'\fR
methodz dat \fIcroak()\fR if tha \fIdelete()\fR or \fIexists()\fR builtins is eva called
on tha tied array, n' implementationz of \f(CW\*(C`PUSH\*(C'\fR, \f(CW\*(C`POP\*(C'\fR, \f(CW\*(C`SHIFT\*(C'\fR,
\&\f(CW\*(C`UNSHIFT\*(C'\fR, \f(CW\*(C`SPLICE\*(C'\fR n' \f(CW\*(C`CLEAR\*(C'\fR up in termz of basic \f(CW\*(C`FETCH\*(C'\fR, \f(CW\*(C`STORE\*(C'\fR,
\&\f(CW\*(C`FETCHSIZE\*(C'\fR, \f(CW\*(C`STORESIZE\*(C'\fR.
.PP
Da \fBTie::StdArray\fR package serves up efficient methodz required fo' tied arrays
which is implemented as pimped references ta a \*(L"inner\*(R" perl array.
It inherits from \fBTie::Array\fR, n' should cause tied arrays ta behave exactly
like standard arrays, allowin fo' selectizzle overloadin of methods.
.PP
For pimpers wishin ta write they own tied arrays, tha required methods
are briefly defined below. Right back up in yo muthafuckin ass. See tha perltie section fo' mo' detailed
descriptive, as well as example code:
.IP "\s-1TIEARRAY\s0 classname, \s-1LIST\s0" 4
.IX Item "TIEARRAY classname, LIST"
Da class method is invoked by tha command \f(CW\*(C`tie @array, classname\*(C'\fR fo' realz. Associates
an array instizzle wit tha specified class. \f(CW\*(C`LIST\*(C'\fR would represent
additionizzle arguments (along tha linez of AnyDBM_File n' compatriots) needed
to complete tha association. I aint talkin' bout chicken n' gravy biatch. Da method should return a object of a cold-ass lil class which
provides tha methodz below.
.IP "\s-1STORE\s0 this, index, value" 4
.IX Item "STORE this, index, value"
Store datum \fIvalue\fR tha fuck into \fIindex\fR fo' tha tied array associated with
object \fIthis\fR. If dis make tha array larger then
classs mappin of \f(CW\*(C`undef\*(C'\fR should be returned fo' freshly smoked up positions.
.IP "\s-1FETCH\s0 this, index" 4
.IX Item "FETCH this, index"
Retrieve tha datum up in \fIindex\fR fo' tha tied array associated with
object \fIthis\fR.
.IP "\s-1FETCHSIZE\s0 this" 4
.IX Item "FETCHSIZE this"
Returns tha total number of shit up in tha tied array associated with
object \fIthis\fR. (Equivalent ta \f(CW\*(C`scalar(@array)\*(C'\fR).
.IP "\s-1STORESIZE\s0 this, count" 4
.IX Item "STORESIZE this, count"
Sets tha total number of shit up in tha tied array associated with
object \fIthis\fR ta be \fIcount\fR. If dis make tha array larger then
classs mappin of \f(CW\*(C`undef\*(C'\fR should be returned fo' freshly smoked up positions.
If tha array becomes smalla then entries beyond count should be
deleted.
.IP "\s-1EXTEND\s0 this, count" 4
.IX Item "EXTEND this, count"
Informatizzle call dat array is likely ta grow ta have \fIcount\fR entries.
Can be used ta optimize allocation. I aint talkin' bout chicken n' gravy biatch. This method need do nothing.
.IP "\s-1EXISTS\s0 this, key" 4
.IX Item "EXISTS this, key"
Verify dat tha element at index \fIkey\fR exists up in tha tied array \fIthis\fR.
.Sp
Da \fBTie::Array\fR implementation be a stub dat simply croaks.
.IP "\s-1DELETE\s0 this, key" 4
.IX Item "DELETE this, key"
Delete tha element at index \fIkey\fR from tha tied array \fIthis\fR.
.Sp
Da \fBTie::Array\fR implementation be a stub dat simply croaks.
.IP "\s-1CLEAR\s0 this" 4
.IX Item "CLEAR this"
Clear (remove, delete, ...) all joints from tha tied array associated with
object \fIthis\fR.
.IP "\s-1DESTROY\s0 this" 4
.IX Item "DESTROY this"
Normal object destructor method.
.IP "\s-1PUSH\s0 this, \s-1LIST\s0" 4
.IX Item "PUSH this, LIST"
Append elementz of \s-1LIST\s0 ta tha array.
.IP "\s-1POP\s0 this" 4
.IX Item "POP this"
Remove last element of tha array n' return dat shit.
.IP "\s-1SHIFT\s0 this" 4
.IX Item "SHIFT this"
Remove tha straight-up original gangsta element of tha array (shiftin other elements down)
and return dat shit.
.IP "\s-1UNSHIFT\s0 this, \s-1LIST\s0" 4
.IX Item "UNSHIFT this, LIST"
Insert \s-1LIST\s0 elements all up in tha beginnin of tha array, movin existin elements
up ta make room.
.IP "\s-1SPLICE\s0 this, offset, length, \s-1LIST\s0" 4
.IX Item "SPLICE this, offset, length, LIST"
Perform tha equivalent of \f(CW\*(C`splice\*(C'\fR on tha array.
.Sp
\&\fIoffset\fR is optionizzle n' defaults ta zero, wack joints count back
from tha end of tha array.
.Sp
\&\fIlength\fR is optionizzle n' defaults ta rest of tha array.
.Sp
\&\fI\s-1LIST\s0\fR may be empty.
.Sp
Returns a list of tha original gangsta \fIlength\fR elements at \fIoffset\fR.
.SH "CAVEATS"
.IX Header "CAVEATS"
There is no support at present fo' tied \f(CW@ISA\fR. There be a potential conflict
between magic entries needed ta notice settin of \f(CW@ISA\fR, n' dem needed to
implement 'tie'.
.SH "AUTHOR"
.IX Header "AUTHOR"
Nick Ing-Simmons <nik@tiuk.ti.com>
