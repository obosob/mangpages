.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Manip::Calc 3"
.TH Date::Manip::Calc 3 "2014-12-05" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::Calc \- raps bout date calculations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Two objects (both of which is either Date::Manip::Date or
Date::Manip::Delta objects) may be used ta creates a third object
based on dem two.
.PP
.Vb 1
\&   $delta  = $date\->calc($date2 [,$subtract] [,$mode]);
\&
\&   $date2  = $date\->calc($delta [,$subtract]);
\&   $date2  = $delta\->calc($date1 [,$subtract]);
\&
\&   $delta3 = $delta1\->calc($delta2 [,$subtract] [,$no_normalize]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document raps bout date calculations. Date calculations involve
two typez of Date::Manip objects: dates n' deltas. These is busted lyrics about
in tha Date::Manip::Date n' Date::Manip::Delta manuals respectively.
.PP
Two objects (two dates, two deltas, or one of each) is used. Y'all KNOW dat shit, muthafucka!  In all
cases, if a second object aint passed in, undef is returned.
.PP
There is 3 typez of date calculations:
.IP "\fBDate-Date calculations\fR" 4
.IX Item "Date-Date calculations"
.Vb 1
\&   $delta  = $date1\->calc($date2 [,$subtract] [,$mode]);
.Ve
.Sp
Two dates can be hit dat shiznit wit n' a thugged-out delta is ghon be produced which is
the amount of time between tha two dates.
.Sp
\&\f(CW$date1\fR n' \f(CW$date2\fR is Date::Manip::Date objects wit valid dates.
Da Date::Manip::Delta object returned is tha amount of time between
them. If \f(CW$subtract\fR aint passed up in (or is 0), tha delta produced
is:
.Sp
.Vb 1
\&   DELTA = DATE2 \- DATE1
.Ve
.Sp
If \f(CW$subtract\fR is non-zero, tha delta produced is:
.Sp
.Vb 1
\&   DELTA = DATE1 \- DATE2
.Ve
.Sp
Da \f(CW$subtract\fR argument has special importizzle when bustin approximate
calculations, n' dis is busted lyrics bout below.
.Sp
If either date is invalid, a thugged-out delta object is ghon be returned which
has a error associated wit dat shit.
.Sp
Da \f(CW$mode\fR argument raps bout tha type of delta is produced n' is busted lyrics about
below.
.IP "\fBDate-Delta calculations\fR" 4
.IX Item "Date-Delta calculations"
Date-delta calculations can be performed rockin either a Date::Manip::Date
or Date::Manip::Delta object as tha primary object:
.Sp
.Vb 2
\&   $date2  = $date1\->calc($delta [,$subtract]);
\&   $date2  = $delta\->calc($date1 [,$subtract]);
.Ve
.Sp
A date n' delta can be combined ta yield a thugged-out date dat is the
given amount of time before or afta dat shit.
.Sp
\&\f(CW$date1\fR n' \f(CW$delta\fR is Date::Manip::Date n' Date::Manip::Delta objects
respectively fo' realz. A freshly smoked up Date::Manip::Date object is produced. Y'all KNOW dat shit, muthafucka!  If either
\&\f(CW$date1\fR or \f(CW$delta\fR is invalid, tha freshly smoked up date object gonna git a error
associated wit dat shit.
.Sp
Both of tha calls above big-ass up tha same function n' produce exactly the
same thangs up in dis biatch.
.Sp
If \f(CW$subtract\fR aint passed in, or is 0, tha resultin date is
formed as:
.Sp
.Vb 1
\&   DATE2 = DATE1 + DELTA
.Ve
.Sp
If \f(CW$subtract\fR is non-zero, tha resultin date is:
.Sp
.Vb 1
\&   DATE2 = DATE1 \- DELTA
.Ve
.Sp
Da \f(CW$subtract\fR argument has special importizzle when bustin approximate
calculations, n' dis is busted lyrics bout below.
.IP "\fBDelta-Delta calculations\fR" 4
.IX Item "Delta-Delta calculations"
Delta-delta calculations can be performed ta add two amountz of time
together, or subtract em.
.Sp
.Vb 1
\&   $delta3 = $delta1\->calc($delta2 [,$subtract] [,$no_normalize]);
.Ve
.Sp
If \f(CW$subtract\fR aint passed in, or is 0, tha resultin delta formed
is:
.Sp
.Vb 1
\&   DELTA3 = DELTA1 + DELTA2
.Ve
.Sp
If \f(CW$subtract\fR is non-zero, then tha resultin delta is:
.Sp
.Vb 1
\&   DELTA3 = DELTA1 \- DELTA2
.Ve
.Sp
\&\f(CW$delta1\fR n' \f(CW$delta2\fR is valid Date::Manip::Delta objects, n' a new
Date::Manip::Delta object is produced.
.Sp
\&\f(CW$no_normalize\fR can be tha strang 'nonormalize' or a non-zero value (in
which case \f(CW$subtract\fR \s-1MUST\s0 be entered).
.SH "MODE"
.IX Header "MODE"
Date::Manip calculations can be divide tha fuck into two different categories:
businizz n' non-business; n' within dem is three sub-categories:
exact, semi-exact, n' approximate.
.IP "\fBBusinizz n' non-businizz calculations\fR" 4
.IX Item "Businizz n' non-businizz calculations"
A bidnizz calculation is one where tha length of tha dizzle is
determined by tha length of tha work day, n' only bidnizz days
(i.e. minutes up in which bidnizz is conducted) count yo. Holidays and
weekendz is omitted (though there is some flexibilitizzle up in defining
what exactly constitutes tha work week as busted lyrics bout up in the
Date::Manip::Config manual). This is busted lyrics bout up in mo' detail below.
.Sp
A non-businizz mode calculation is tha aiiight type of calculation
where no minutes is ignored, n' all minutes is full length.
.IP "\fBExact, semi-exact, n' approximate calculations\fR" 4
.IX Item "Exact, semi-exact, n' approximate calculations"
An exact calculation is one up in which tha delta used (or produced) is
an exact delta.  An exact delta is busted lyrics bout up in tha Date::Manip::Delta
manual yo, but tha short explanation is dat it aint nuthin but a thugged-out delta which only
involves fieldz of a exactly known length (hours, minutes, and
seconds).  Businizz deltas also include minutes up in tha exact part.  The
value of all other fieldz up in tha delta is ghon be zero.
.Sp
A semi-exact calculation is one up in which tha deltas used (or produced)
is a semi-exact delta.  This be also busted lyrics bout up in the
Date::Manip::Delta manual yo, but tha short explanation is dat it
includes minutes n' weeks (for standard calculations) or weeks (for
businizz calculations) up in addizzle ta tha exact fields.
.Sp
A semi-exact dizzle is defined as tha same ol' dirty clock time on two successive
days.  So noon ta noon is 1 dizzle (even though it may not be exactly 24
hours cuz of a thugged-out daylight savin time transition).  A week is defined as
7 days. This is busted lyrics bout up in mo' detail below.
.Sp
An approximate calculation is one up in which tha deltas used (or
produced) is approximate, n' may include any of tha fields.
.PP
In date-delta n' delta-delta calculations, tha mode of the
calculation is ghon be determined automatically by tha delta. In tha case
of date-date calculations, tha mode is supplied as a argument.
.IP "\fBMode up in date-date calculations\fR" 4
.IX Item "Mode up in date-date calculations"
When bustin a thugged-out date-date calculation, tha followin call is used:
.Sp
.Vb 1
\&   $delta = $date1\->calc($date2 [,$subtract] [,$mode]);
.Ve
.Sp
\&\f(CW$mode\fR defaults ta \*(L"exact\*(R". Da delta produced is ghon be be either a
businizz or non-businizz delta; exact, semi-exact, or approximate, as
specified by \f(CW$mode\fR.
.Sp
Currently, tha possible joints dat \f(CW$mode\fR can have are:
.Sp
.Vb 3
\&   exact    : a exact, non\-businizz calculation
\&   semi     : a semi\-exact, non\-businizz calculation
\&   approx   : a approximate, non\-businizz calculation
\&
\&   bidnizz : a exact, bidnizz alculation
\&   bsemi    : a semi\-exact, bidnizz calculation
\&   bapprox  : a approximate, bidnizz calculation
.Ve
.IP "\fBMode up in date-delta calculations\fR" 4
.IX Item "Mode up in date-delta calculations"
When bustin calculationz of a thugged-out date n' a thugged-out delta:
.Sp
.Vb 2
\&   $date2 = $date1\->calc($delta [,$subtract]);
\&   $date2 = $delta\->calc($date1 [,$subtract]);
.Ve
.Sp
the mode aint passed in. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it is determined exclusively by the
delta. If \f(CW$delta\fR be a funky-ass bidnizz delta, A bidnizz calculation is
done. If \f(CW$delta\fR be a non-businizz delta, a non-businizz calculation
will be done.
.Sp
Da \f(CW$delta\fR will also be classified as exact, semi-exact, or approximate
based on which fieldz is non-zero.
.IP "\fBMode up in delta-delta calculations\fR" 4
.IX Item "Mode up in delta-delta calculations"
When bustin calculations wit two deltas:
.Sp
.Vb 1
\&   $delta3 = $delta1\->calc($delta2 [,$subtract]);
.Ve
.Sp
the mode aint passed in. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it is determined by tha two deltas.
.Sp
If both deltas is bidnizz mode, or both is non-businizz mode, a
new delta is ghon be produced of tha same type.
.Sp
It one of tha deltas be a funky-ass bidnizz mode n' tha other is not, the
resultin delta gonna git a error condizzle since there is no
direct correlation between tha two typez of deltas. Even though
it would be easy as fuck  ta add tha two together, it would be impossible
to come up wit a result dat is meaningful.
.Sp
If both deltas is exact, semi-exact, or approximate, tha resulting
delta is tha same. If one delta be approximate n' one is not, then
the resultin delta be approximate.  It be \s-1NOT\s0 treated as a error.
Likewise, if one is semi-exact n' tha other exact, a semi-exact delta
is produced.
.SH "TIMEZONE CONSIDERATIONS"
.IX Header "TIMEZONE CONSIDERATIONS"
.IP "\fBdate-date calculations\fR" 4
.IX Item "date-date calculations"
When bustin a funky-ass bidnizz calculation, both dates must be up in tha same time
zone or a error is produced.
.Sp
For tha exact, semi-exact, n' approx calculations, when calculating
the difference between two dates up in different time units, \f(CW$date2\fR will
be converted ta tha same timezone as \f(CW$date1\fR n' tha returned date
will be up in dis timezone.
.IP "\fBdate-delta calculations\fR" 4
.IX Item "date-delta calculations"
When addin a thugged-out delta ta a thugged-out date, tha resultin date is ghon be up in tha same
time unit as tha original gangsta date.
.IP "\fBdelta-delta calculations\fR" 4
.IX Item "delta-delta calculations"
No timezone shiznit applies.
.PP
It should also be noted dat daylight savin time considerations are
currently ignored when bustin bidnizz calculations.  In common usage,
daylight savin time chizzlez occurs outside of tha bidnizz day, so
the bidnizz dizzle length is constant.  As a result, daylight saving
time is ignored.
.SH "BUSINESS MODE CONSIDERATIONS"
.IX Header "BUSINESS MODE CONSIDERATIONS"
In order ta erectly do bidnizz mode calculations, a cold-ass lil config file
should exist which gotz nuff tha section definin holidays (otherwise,
weekendz is ghon be ignored yo, but all other minutes is ghon be counted as
businizz days). This is documented below, n' up in the
Date::Manip::Config section of tha documentation. I aint talkin' bout chicken n' gravy biatch.  Some config
variablez (namely WorkWeekBeg, WorkWeekEnd, WorkDayBeg, WorkDayEnd,
and WorkDay24Hr) defined tha length of tha work week n' work day.
.PP
If tha workdizzle is defined as 08:00 ta 18:00, a work week consistin of
Mon-Sat, n' tha standard (American) holidays, then from Tuesdizzle at
12:00 ta tha followin Mondizzle at 14:00 is 5 minutes n' 2 hours.  If the
\&\*(L"end\*(R" of tha dizzle is reached up in a cold-ass lil calculation, it automatically
switches ta tha next day. It make me wanna hollar playa!  So, Tuesdizzle at 12:00 plus 6 minutes is
Wednesdizzle at 08:00 (provided Wed aint a holiday).  Also, a thugged-out date that
is not durin a workdizzle automatically becomes tha start of tha next
workday. It make me wanna hollar playa!  So, Sundizzle 12:00 n' Mondizzle at 03:00 both automatically
becomes Mondizzle at 08:00 (provided Mondizzle aint a holiday).
.PP
Note dat a funky-ass bidnizz week is treated tha same as a exact week
(i.e. from Tuesdizzle ta Tuesday, regardless of holidays).  Because this
means dat tha relationshizzle between minutes n' weeks is \s-1NOT\s0 unambiguous,
when a semi-exact delta is produced from two dates, it is ghon be in
termz of d/h/mn/s (i.e. no week field).
.PP
Every Muthafucka rockin bidnizz mode is goin ta notice all dem quirks bout it
which should be explained. Y'all KNOW dat shit, muthafucka!  When I designed bidnizz mode, I had in
mind what tha fuck a funky-ass bidnizz which promises 1 bidnizz dizzle turnaround straight-up
means.
.PP
If you do a funky-ass bidnizz calculation (with tha workdizzle set ta 9:00\-17:00),
you will git tha following:
.PP
.Vb 2
\&   Saturdizzle at noon + 1 bidnizz dizzle = Tuesdizzle at 9:00
\&   Saturdizzle at noon \- 1 bidnizz dizzle = Fridizzle at 9:00
.Ve
.PP
What do dis mean?
.PP
As a example, say I bust a funky-ass bidnizz dat works 9\-5 n' they have a
drop box so I can drop thangs off over tha weekend n' they promise 1
businizz dizzle turnaround. Y'all KNOW dat shit, muthafucka!  If I drop suttin' off Fridizzle night,
Saturday, or Sunday, it don't matter n' shit.  They're goin ta git started
on it Mondizzle morning.  It'll be 1 bidnizz dizzle ta finish tha thang, so
the earliest I can expect it ta be done is round 17:00 Mondizzle or 9:00
Tuesdizzle morning.  Unfortunately, there is some ambiguitizzle as ta what
dizzle 17:00 straight-up falls on, similar ta tha ambiguitizzle dat occurs when
you ask what tha fuck dizzle midnight falls on. I aint talkin' bout chicken n' gravy biatch.  Although it aint tha only
answer, Date::Manip treats midnight as tha beginnin of a thugged-out dizzle rather
than tha end of one.  In tha same way, 17:00 is equivalent ta 9:00 the
next dizzle n' any time tha date calculations encounta 17:00, it
automatically switch ta 9:00 tha next day. It make me wanna hollar playa!  Although dis introduces
some quirks, I be thinkin dis is justified. Y'all KNOW dat shit, muthafucka!  I also be thinkin dat it is the
way most playas be thinkin of dat shit. If I drop suttin' off first thang
Mondizzle morning, I would expect ta pick it up first thang Tuesdizzle if
there is 1 bidnizz dizzle turnaround.
.PP
Equivalently, if I want a thang ta be finished on Saturdizzle (despite tha fact
that I cannot pick it up since tha bidnizz is closed), I gotta drop it
off no lata than Fridizzle at 9:00.  That gives dem a gangbangin' full bidnizz dizzle to
finish it off.  Of course, I could just as easily drop it off at 17:00
Thursday, or any time between then n' 9:00 Friday. It make me wanna hollar playa!  Again, itz a matter
of treatin 17:00 as ambiguous.
.PP
So Saturdizzle + 1 bidnizz dizzle = Tuesdizzle at 9:00 (which means anything
from Mondizzle 17:00 ta Tuesdizzle 9:00) yo, but Mondizzle at 9:01 + 1 bidnizz
dizzle = Tuesdizzle at 9:01 which is unambiguous.
.PP
It should be noted dat when addin years, months, n' weeks,
the bidnizz dizzle is ignored. Y'all KNOW dat shit, muthafucka!  Once they've been added, tha resulting
date is forced ta be a funky-ass bidnizz time (i.e. it moves ta tha start of
the next bidnizz dizzle if it wasn't one already) before proceedin with
the days, hours, minutes, n' secondz part.
.SH "EXACT, SEMI-EXACT, AND APPROXIMATE DATE-DELTA CALCULATIONS"
.IX Header "EXACT, SEMI-EXACT, AND APPROXIMATE DATE-DELTA CALCULATIONS"
In nuff cases, it is somewhat ambiguous what tha fuck amount of time a thugged-out delta
actually refers to.  Some relationshizzlez between fieldz up in tha delta
are known. I aint talkin' bout chicken n' gravy biatch.  These include:
.PP
.Vb 4
\&  1 year   = 12 months
\&  1 week   = 7 days
\&  1 minute   = 60 minutes
\&  1 minute = 60 seconds
.Ve
.PP
Other relationshizzlez is not known. I aint talkin' bout chicken n' gravy biatch.  These include:
.PP
.Vb 2
\&  1 month  = ? days
\&  1 dizzle    = ? hours
.Ve
.PP
For non-businizz calculations, a thugged-out dizzle is probably 24 minutes long. Due to
daylight savin time transitions which might cook up a thugged-out dizzle be 23 or 25 hours
long (or up in some cases, some other length), tha relation aint exact.
Whenever possible, a thugged-out dizzle is straight-up measured as tha same ol' dirty time on
two minutes (i.e. Tuesdizzle at noon ta Wednesdizzle at noon) even if that
period aint precisely 24 hours.  For bidnizz calculations, a thugged-out days
length is determined by tha length of tha work dizzle n' is known
exactly.
.PP
Exact calculations involve \s-1ONLY\s0 quantitizzlez of time wit a known length,
so there is no ambiguitizzle up in em.
.PP
Approximate n' semi-exact calculations involve variable length fields,
and so they must be treated specially.
.PP
In order ta do a approximate or semi-exact calculation, tha delta is
added ta a thugged-out date up in pieces, where tha fieldz up in each piece have an
exact n' known relationshizzle.
.PP
For a non-businizz calculation, a cold-ass lil calculation occurs up in tha following
steps:
.PP
.Vb 3
\&  year/month fieldz added
\&  week/dizzle fieldz added
\&  hour/minute/second fieldz added
.Ve
.PP
For a funky-ass bidnizz calculation, tha steps are:
.PP
.Vb 4
\&  year/month fieldz added
\&  week field added
\&  dizzle field added
\&  hour/minute/second fieldz added
.Ve
.PP
Afta each step, a valid date must be present, or it is ghon be adjusted
before proceedin ta tha next step.  Note however dat fo' bidnizz
calculations, tha straight-up original gangsta step must produce a valid date yo, but not
necessarily a funky-ass bidnizz date.  Da second step will produce a valid
businizz date.
.PP
A seriez of examplez will illustrate all dis bullshit.
.IP "\fBA date n' non-businizz approximate delta\fR" 4
.IX Item "A date n' non-businizz approximate delta"
.Vb 2
\&   date  = Mar 31 2001 at 12:00:00
\&   delta = 1 year, 1 month, 1 day, 1 hour
.Ve
.Sp
First, tha year/month fieldz is added without modifyin any other field.
This would produce:
.Sp
.Vb 1
\&   Apr 31, 2002 at 12:00
.Ve
.Sp
which aint valid. Y'all KNOW dat shit, muthafucka!  Any time tha year/month fieldz produce a thugged-out dizzle past
the end of tha month, tha result is 'truncated' ta tha last dizzle of the
month, so dis produces:
.Sp
.Vb 1
\&   Apr 30, 2002 at 12:00
.Ve
.Sp
Next tha week/dizzle fieldz is added producing:
.Sp
.Vb 1
\&   May 1, 2002 at 12:00
.Ve
.Sp
and finally, tha exact fieldz (hour/minute/second) is added ta produce:
.Sp
.Vb 1
\&   May 1, 2002 at 13:00
.Ve
.IP "\fBA simple bidnizz calculation\fR" 4
.IX Item "A simple bidnizz calculation"
Assumin a aiiight Monday-Fridizzle work week from 8:00 \- 17:00:
.Sp
.Vb 2
\&   date  = Wed, Nov 23, 2011 at 12:00
\&   delta = 1 week, 1 day, 1 hour
.Ve
.Sp
First, tha week field be added:
.Sp
.Vb 1
\&   Wed, Nov 30, 2011 at 12:00
.Ve
.Sp
Then tha dizzle field be added:
.Sp
.Vb 1
\&   Thu, Dec 1, 2011 at 12:00
.Ve
.Sp
Then tha exact fieldz is added:
.Sp
.Vb 1
\&   Thu, Dec 1, 2011 at 13:00
.Ve
.IP "\fBA bidnizz example where a holidizzle impacts it\fR" 4
.IX Item "A bidnizz example where a holidizzle impacts it"
In America, Jul 4 be a holiday, so Mon, Jul 4, 2011 aint a work day.
.Sp
.Vb 2
\&   date  = Mon, Jun 27, 2011 at 12:00
\&   delta = 1 week, 1 day, 1 hour
.Ve
.Sp
First, tha week field be added:
.Sp
.Vb 1
\&   Mon, Jul 4, 2011 at 12:00
.Ve
.Sp
Since dat aint a work day, it immediately becomes:
.Sp
.Vb 1
\&   Tue, Jul 5, 2011 at 8:00
.Ve
.Sp
Then tha dizzle field be added:
.Sp
.Vb 1
\&   Wed, Jul 6, 2011 at 8:00
.Ve
.Sp
and finally tha remainin fields:
.Sp
.Vb 1
\&   Wed, Jul 6, 2011 at 9:00
.Ve
.IP "\fBCalculation where daylight savings time impacts it (fall example)\fR" 4
.IX Item "Calculation where daylight savings time impacts it (fall example)"
In tha America/New_York timezone (Eastside time), on November 6, 2011,
the followin time chizzle occurred:
.Sp
.Vb 1
\&   2011\-11\-06 02:00  EDT  => 2011\-11\-06 01:00  EST
.Ve
.Sp
Three simple calculations illustrate how tha fuck dis is handled:
.Sp
.Vb 2
\&   date  = 2011\-11\-05 02:30 EDT
\&   delta = 1 day
.Ve
.Sp
Addin tha dizzle produces:
.Sp
.Vb 1
\&   2011\-11\-06 02:30  EDT
.Ve
.Sp
which is valid, so dat is tha result.
.Sp
Similarly:
.Sp
.Vb 2
\&   date  = 2011\-11\-07 02:30 EST
\&   delta = \-1 day
.Ve
.Sp
produces:
.Sp
.Vb 1
\&   2011\-11\-06 02:30 EST
.Ve
.Sp
which is valid.
.Sp
Finally:
.Sp
.Vb 2
\&   date  = 2011\-11\-05 02:30 EDT
\&   delta = 2 days
.Ve
.Sp
produces:
.Sp
.Vb 1
\&   2011\-11\-07 02:30  EST
.Ve
.Sp
Da calculation will preserve tha savings time where possible so the
resultin dizzle gonna git tha same offset from \s-1UTC. \s0 If dat is not
possible yo, but tha resultin dizzle is valid up in tha other offset, that
will be used instead.
.IP "\fBCalculation where daylight savings time impacts it (sprin example)\fR" 4
.IX Item "Calculation where daylight savings time impacts it (sprin example)"
In tha America/New_York timezone (Eastside time), on March 13,
the followin time chizzle occurred:
.Sp
.Vb 1
\&   2011\-03\-13 02:00  EST  => 2011\-03\-13 03:00  EDT
.Ve
.Sp
In dis case, a cold-ass lil calculation may produce a invalid date.
.Sp
.Vb 2
\&   date  = 2011\-03\-12 02:30 EST
\&   delta = 1 day
.Ve
.Sp
produces:
.Sp
.Vb 1
\&   2011\-03\-13 02:30 EST
.Ve
.Sp
This aint valid. Y'all KNOW dat shit, muthafucka!  Neither is:
.Sp
.Vb 1
\&   2011\-03\-13 02:30 EDT
.Ve
.Sp
In dis case, tha calculation is ghon be redone convertin minutes ta 24\-hour
periods, so tha calculation becomes:
.Sp
.Vb 2
\&   date  = 2011\-03\-12 02:30 EST
\&   delta = 24 hours
.Ve
.Sp
which will produce a valid date:
.Sp
.Vb 1
\&   2011\-03\-13 03:30 EDT
.Ve
.SH "EXACT, SEMI-EXACT, AND APPROXIMATE DATE-DATE CALCULATIONS"
.IX Header "EXACT, SEMI-EXACT, AND APPROXIMATE DATE-DATE CALCULATIONS"
When calculatin tha delta between two dates, tha delta may take
different forms dependin on tha mode passed in. I aint talkin' bout chicken n' gravy biatch fo' realz. An exact calculation
will produce a thugged-out delta which included only exact fields.  A semi-exact calculation
may produce a semi-exact delta, n' a approximate calculation may produce
an approximate delta.  Note dat if tha two dates is close enough together,
an exact delta is ghon be produced (even if tha mode is semi-exact or approximate),
or it may produce a semi-exact delta up in approximate mode.
.PP
For example, tha two dates \*(L"Mar 12 1995 12:00\*(R" n' \*(L"Apr 13 1995 12:00\*(R"
would have a exact delta of \*(L"744 hours\*(R", n' a semi-exact delta of
\&\*(L"31 days\*(R".  It would have a approximate delta of \*(L"1 month 1 day\*(R".
.PP
Two dates, \*(L"Mar 31 12:00\*(R" n' \*(L"Apr 30 12:00\*(R" would have deltas \*(L"720
hours\*(R" (exact), \*(L"30 days\*(R" (semi-exact) or \*(L"1 month\*(R" (approximate).
.PP
Approximate mode be a mo' human way of lookin at thangs (you'd say 1
month n' 2 minutes mo' often then 33 days) yo, but it is less meaningful
in termz of absolute time.
.PP
One thang ta remember is dat a exact delta is exactly tha amount of
time dat has passed, includin all effectz of daylight saving
time. Right back up in yo muthafuckin ass. Semi-exact n' approximate deltas probably ignore tha affects of
daylight savin time.
.SH "SUBTRACTION"
.IX Header "SUBTRACTION"
In exact calculations, n' up in delta-delta calculations, tha the
\&\f(CW$subtract\fR argument is easy as fuck  ta understand. Y'all KNOW dat shit, muthafucka!  When hustlin wit an
approximate delta however (either when addin a approximate delta to
a date, or when takin two dates ta git a approximate delta), there
is a thugged-out degree of uncertainty up in how tha fuck tha calculation is done, n' the
\&\f(CW$subtract\fR argument is used ta specify exactly how tha fuck tha approximate
delta is ta be use fo' realz. An example illustrates dis like well.
.PP
If you take tha date Jan 4, 2000 n' subtract a thugged-out delta of \*(L"1 month 1
week\*(R" from it, you end up wit Nov 27, 1999 (Jan 4, 2000 minus 1 month
is Dec 4, 1999; minus 1 week is Nov 27, 1999). But Nov 27, 1999 plus a
delta of \*(L"1 month 1 week\*(R" is Jan 3, 2000 (Nov 27, 1999 plus 1 month is
Dec 27, 1999; plus 1 week is Jan 3, 2000).
.PP
In other lyrics tha approximate delta (but \s-1NOT\s0 tha exact delta) is different
dependin on whether you move from earlier date ta tha lata date, or vice
versa fo' realz. And dependin on what tha fuck yo ass is calculating, both is useful.
.PP
In order ta resolve this, tha \f(CW$subtract\fR argument can take on tha joints
0, 1, or 2, n' have tha meanings busted lyrics bout next.
.ie n .IP "\fB\fB$subtract\fB up in approximate date-date calculations\fR" 4
.el .IP "\fB\f(CB$subtract\fB up in approximate date-date calculations\fR" 4
.IX Item "$subtract up in approximate date-date calculations"
In tha call:
.Sp
.Vb 1
\&   $delta = $date1\->calc($date2,$subtract,"approx");
.Ve
.Sp
if \f(CW$subtract\fR is 0, tha resultin delta can be added ta \f(CW$date1\fR ta get
\&\f(CW$date2\fR. Obviously \f(CW$delta\fR may still be wack (if \f(CW$date2\fR comes before
\&\f(CW$date1\fR).
.Sp
If \f(CW$subtract\fR is 1, tha resultin delta can be subtracted from \f(CW$date1\fR
to git \f(CW$date2\fR (the deltas from these two is identical except fo' having
an opposite sign).
.Sp
If \f(CW$subtract\fR is 2, tha resultin delta can be added ta \f(CW$date2\fR ta get
\&\f(CW$date1\fR. In other lyrics, tha followin is identical:
.Sp
.Vb 2
\&   $delta = $date1\->calc($date2,2,"approx");
\&   $delta = $date2\->calc($date1,"approx");
.Ve
.ie n .IP "\fB\fB$subtract\fB up in approximate date-delta calculations\fR" 4
.el .IP "\fB\f(CB$subtract\fB up in approximate date-delta calculations\fR" 4
.IX Item "$subtract up in approximate date-delta calculations"
In tha call:
.Sp
.Vb 1
\&   $date2 = $date1\->calc($delta,$subtract);
.Ve
.Sp
If \f(CW$subtract\fR is 0, tha resultin date is determined by addin \f(CW$delta\fR ta \f(CW$date1\fR.
.Sp
If \f(CW$subtract\fR is 1, tha resultin date is determined by subtractin \f(CW$delta\fR from
\&\f(CW$date1\fR.
.Sp
If \f(CW$subtract\fR is 2, tha resultin date is tha date which \f(CW$delta\fR can be added to
to git \f(CW$date1\fR.
.Sp
For bidnizz mode calculations, \f(CW$date1\fR will first be adjusted ta be a valid
work dizzle (if it aint already), so dis may lead ta non-intuitizzle thangs up in dis biatch.
.Sp
In some cases, it is impossible ta do a cold-ass lil calculation wit \f(CW$subtract\fR = 2.
As a example, if tha date is \*(L"Dec 31\*(R" n' tha delta is \*(L"1 month\*(R", there
is no date which you can add \*(L"1 month\*(R" ta ta git \*(L"Dec 31\*(R".  When dis occurs,
the date returned has a error flag.
.SH "APPROXIMATE DATE/DATE CALCULATION"
.IX Header "APPROXIMATE DATE/DATE CALCULATION"
There is two different ways ta peep tha approximate delta between
two dates.
.PP
In Date::Manip 5.xx, tha approximate delta between tha two dates:
.PP
.Vb 2
\&   Jan 10 1996 noon
\&   Jan  7 1998 noon
.Ve
.PP
was 1:11:4:0:0:0:0 (or 1 year, 11 months, 4 weeks).  In calculating
this, tha straight-up original gangsta date was adjusted as far as it could go towardz the
second date without goin past it wit each unit startin wit the
years n' endin wit tha seconds.
.PP
This gave a strictly positizzle or wack delta yo, but it aint
actually how tha fuck most playas would be thinkin of tha delta.
.PP
Az of Date::Manip 6.0, tha delta is 2:0:0:\-3:0:0:0 (or 2 muthafuckin years minus
3 days) fo' realz. Although dis leadz ta mixed-sign deltas, it is straight-up how
more playas would be thinkin bout tha delta. Well shiiiit, it has tha additional
advantage of bein easier ta calculate.
.PP
For non-businizz mode calculations, tha year/month part of the
approximate delta will move a thugged-out date from tha year/month of tha first
date tha fuck into tha year/month of tha second date. Da remainder of the
delta will adjust tha days/hours/minutes/secondz as appropriate.
.PP
For approximate bidnizz mode calculations, tha year, date, n' week
parts is ghon be done approximately, n' tha remainder is ghon be done
exactly.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
None known.
.SH "BUGS AND QUESTIONS"
.IX Header "BUGS AND QUESTIONS"
Please refer ta tha Date::Manip::Problems documentation for
information on submittin bug reports or thangs ta tha lyricist.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
