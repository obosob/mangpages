.TH "std::__detail::_Nfa" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::__detail::_Nfa \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBstd::__detail::_Automaton\fP, n' \fBstd::vector< _State >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef 
.br
\fBregex_constants::syntax_option_type\fP \fB_FlagT\fP"
.br
.ti -1c
.RI "typedef unsigned int \fB_SizeT\fP"
.br
.ti -1c
.RI "typedef \fB_State\fP \fB_StateT\fP"
.br
.ti -1c
.RI "typedef \fBstd::allocator\fP< \fB_State\fP > \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef 
.br
__gnu_cxx::__normal_iterator
.br
< const_pointer, \fBvector\fP > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef 
.br
_Alloc_traits::const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef 
.br
_Alloc_traits::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< const_iterator > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef 
.br
__gnu_cxx::__normal_iterator
.br
< pointer, \fBvector\fP > \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Base::pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Alloc_traits::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP
.br
< iterator > \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef \fB_State\fP \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB_Nfa\fP (_FlagT __f)"
.br
.ti -1c
.RI "const \fB_StateSet\fP & \fB_M_final_states\fP () const "
.br
.ti -1c
.RI "\fB_StateIdT\fP \fB_M_insert_accept\fP ()"
.br
.ti -1c
.RI "\fB_StateIdT\fP \fB_M_insert_alt\fP (\fB_StateIdT\fP __next, \fB_StateIdT\fP __alt)"
.br
.ti -1c
.RI "\fB_StateIdT\fP \fB_M_insert_matcher\fP (\fB_Matcher\fP __m)"
.br
.ti -1c
.RI "\fB_StateIdT\fP \fB_M_insert_subexpr_begin\fP (const \fB_Tagger\fP &__t)"
.br
.ti -1c
.RI "\fB_StateIdT\fP \fB_M_insert_subexpr_end\fP (unsigned int __i, const \fB_Tagger\fP &__t)"
.br
.ti -1c
.RI "_FlagT \fB_M_options\fP () const "
.br
.ti -1c
.RI "\fB_StateIdT\fP \fB_M_start\fP () const "
.br
.ti -1c
.RI "_SizeT \fB_M_sub_count\fP () const "
.br
.ti -1c
.RI "void \fBassign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "void \fBassign\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBassign\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "reference \fBat\fP (size_type __n)"
.br
.ti -1c
.RI "const_reference \fBat\fP (size_type __n) const"
.br
.ti -1c
.RI "reference \fBback\fP ()"
.br
.ti -1c
.RI "const_reference \fBback\fP () const"
.br
.ti -1c
.RI "iterator \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "const_iterator \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "size_type \fBcapacity\fP () const noexcept"
.br
.ti -1c
.RI "const_iterator \fBcbegin\fP () const noexcept"
.br
.ti -1c
.RI "const_iterator \fBcend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const noexcept"
.br
.ti -1c
.RI "\fB_State\fP * \fBdata\fP () noexcept"
.br
.ti -1c
.RI "const \fB_State\fP * \fBdata\fP () const noexcept"
.br
.ti -1c
.RI "iterator \fBemplace\fP (iterator __position, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "void \fBemplace_back\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "iterator \fBend\fP () noexcept"
.br
.ti -1c
.RI "const_iterator \fBend\fP () const noexcept"
.br
.ti -1c
.RI "iterator \fBerase\fP (iterator __position)"
.br
.ti -1c
.RI "iterator \fBerase\fP (iterator __first, iterator __last)"
.br
.ti -1c
.RI "reference \fBfront\fP ()"
.br
.ti -1c
.RI "const_reference \fBfront\fP () const"
.br
.ti -1c
.RI "iterator \fBinsert\fP (iterator __position, const value_type &__x)"
.br
.ti -1c
.RI "iterator \fBinsert\fP (iterator __position, value_type &&__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (iterator __position, \fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "void \fBinsert\fP (iterator __position, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (iterator __position, _InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const noexcept"
.br
.ti -1c
.RI "reference \fBoperator[]\fP (size_type __n)"
.br
.ti -1c
.RI "const_reference \fBoperator[]\fP (size_type __n) const"
.br
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.ti -1c
.RI "void \fBpush_back\fP (const value_type &__x)"
.br
.ti -1c
.RI "void \fBpush_back\fP (value_type &&__x)"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBreserve\fP (size_type __n)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size, const value_type &__x)"
.br
.ti -1c
.RI "void \fBshrink_to_fit\fP ()"
.br
.ti -1c
.RI "size_type \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "void \fBswap\fP (\fBvector\fP &__x) noexcept(_Alloc_traits::_S_nothrow_swap())"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "pointa \fB_M_allocate\fP (size_t __n)"
.br
.ti -1c
.RI "pointa \fB_M_allocate_and_copy\fP (size_type __n, _ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "void \fB_M_assign_aux\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_assign_aux\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_assign_dispatch\fP (_Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "void \fB_M_assign_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "size_type \fB_M_check_len\fP (size_type __n, const char *__s) const"
.br
.ti -1c
.RI "void \fB_M_deallocate\fP (pointa __p, size_t __n)"
.br
.ti -1c
.RI "void \fB_M_default_append\fP (size_type __n)"
.br
.ti -1c
.RI "void \fB_M_default_initialize\fP (size_type __n)"
.br
.ti -1c
.RI "void \fB_M_emplace_back_aux\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "void \fB_M_erase_at_end\fP (pointa __pos)"
.br
.ti -1c
.RI "void \fB_M_fill_assign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "void \fB_M_fill_initialize\fP (size_type __n, const value_type &__value)"
.br
.ti -1c
.RI "void \fB_M_fill_insert\fP (iterator __pos, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "_Tp_alloc_type & \fB_M_get_Tp_allocator\fP () noexcept"
.br
.ti -1c
.RI "const _Tp_alloc_type & \fB_M_get_Tp_allocator\fP () const noexcept"
.br
.ti -1c
.RI "void \fB_M_initialize_dispatch\fP (_Integer __n, _Integer __value, __true_type)"
.br
.ti -1c
.RI "void \fB_M_initialize_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "void \fB_M_insert_aux\fP (iterator __position, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "void \fB_M_insert_dispatch\fP (iterator __pos, _Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "void \fB_M_insert_dispatch\fP (iterator __pos, _InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "void \fB_M_range_check\fP (size_type __n) const"
.br
.ti -1c
.RI "void \fB_M_range_initialize\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_range_initialize\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_range_insert\fP (iterator __pos, _InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_range_insert\fP (iterator __pos, _ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "bool \fB_M_shrink_to_fit\fP ()"
.br
.ti -1c
.RI "\fBallocator_type\fP \fBget_allocator\fP () const noexcept"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_Vector_impl \fB_M_impl\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
struct _Nfa 

A collection of all states makin up a NFA\&.
.PP
An NFA be a 4-tuple M = (K, S, s, F), where K be a gangbangin' finite set of states, S is tha alphabet of tha NFA, s is tha initial state, F be a set of final (accepting) states\&.
.PP
This NFA class is templated on S, a type dat will hold jointz of tha underlyin alphabet (without regard ta semantics of dat alphabet)\&. Da other elementz of tha tuple is generated durin construction of tha NFA n' is available all up in accessor member functions\&. 
.PP
Definizzle at line 269 of file regex_nfa\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "pointa \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::_M_allocate_and_copy (size_type__n, _ForwardIterator__first, _ForwardIterator__last)\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"
Memory expansion handlez\&. Uses tha member allocation function ta obtain \fIn\fP bytez of memory, n' then copies [first,last) tha fuck into it\&. 
.PP
Definizzle at line 1135 of file stl_vector\&.h\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::_M_range_check (size_type__n) const\fC [inline]\fP, \fC [protected]\fP, \fC [inherited]\fP"

.PP
Safety check used only from at()\&. 
.PP
Definizzle at line 791 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::size()\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::assign (size_type__n, const value_type &__val)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Assigns a given value ta a vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Number of elements ta be assigned\&. 
.br
\fI__val\fP Value ta be assigned\&.
.RE
.PP
This function fills a vector wit \fI__n\fP copiez of tha given value\&. Note dat tha assignment straight-up chizzlez tha vector n' dat tha resultin vectorz size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 479 of file stl_vector\&.h\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::assign (_InputIterator__first, _InputIterator__last)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Assigns a range ta a vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&.
.RE
.PP
This function fills a vector wit copiez of tha elements up in tha range [__first,__last)\&.
.PP
Note dat tha assignment straight-up chizzlez tha vector n' dat tha resultin vectorz size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 498 of file stl_vector\&.h\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::assign (\fBinitializer_list\fP< value_type >__l)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Assigns a initializer list ta a vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list\&.
.RE
.PP
This function fills a vector wit copiez of tha elements up in tha initializer list \fI__l\fP\&.
.PP
Note dat tha assignment straight-up chizzlez tha vector n' dat tha resultin vectorz size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 524 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::assign()\&.
.SS "reference \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::at (size_type__n)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Provides access ta tha data contained up in tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha element fo' which data should be accessed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read/write reference ta data\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fI__n\fP be a invalid index\&.
.RE
.PP
This function serves up fo' less thuggy data access\&. Da parameta is first checked dat it is up in tha range of tha vector\&. Da function throws out_of_range if tha check fails\&. 
.PP
Definizzle at line 810 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::_M_range_check()\&.
.SS "const_reference \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::at (size_type__n) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Provides access ta tha data contained up in tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha element fo' which data should be accessed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) reference ta data\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If \fI__n\fP be a invalid index\&.
.RE
.PP
This function serves up fo' less thuggy data access\&. Da parameta is first checked dat it is up in tha range of tha vector\&. Da function throws out_of_range if tha check fails\&. 
.PP
Definizzle at line 828 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::_M_range_check()\&.
.SS "reference \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::back ()\fC [inline]\fP, \fC [inherited]\fP"
Returns a read/write reference ta tha data all up in tha last element of tha vector\&. 
.PP
Definizzle at line 855 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::end()\&.
.SS "const_reference \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::back () const\fC [inline]\fP, \fC [inherited]\fP"
Returns a read-only (constant) reference ta tha data all up in tha last element of tha vector\&. 
.PP
Definizzle at line 863 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::end()\&.
.SS "iterator \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::begin ()\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns a read/write iterator dat points ta tha straight-up original gangsta element up in tha vector\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 538 of file stl_vector\&.h\&.
.SS "const_iterator \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::begin () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns a read-only (constant) iterator dat points ta tha straight-up original gangsta element up in tha vector\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 547 of file stl_vector\&.h\&.
.SS "size_type \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::capacitizzle () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns tha total number of elements dat tha vector can hold before needin ta allocate mo' memory\&. 
.PP
Definizzle at line 725 of file stl_vector\&.h\&.
.SS "const_iterator \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::cbegin () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns a read-only (constant) iterator dat points ta tha straight-up original gangsta element up in tha vector\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 611 of file stl_vector\&.h\&.
.SS "const_iterator \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::cend () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns a read-only (constant) iterator dat points one past tha last element up in tha vector\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 620 of file stl_vector\&.h\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::clear ()\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Erases all tha elements\&. Note dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 1125 of file stl_vector\&.h\&.
.SS "\fBconst_reverse_iterator\fP \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::crbegin () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns a read-only (constant) reverse iterator dat points ta tha last element up in tha vector\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 629 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::end()\&.
.SS "\fBconst_reverse_iterator\fP \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::crend () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns a read-only (constant) reverse iterator dat points ta one before tha straight-up original gangsta element up in tha vector\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 638 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::begin()\&.
.SS "\fB_State\fP * \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::data ()\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns a pointa such dat [data(), data() + size()) be a valid range\&. For a non-empty vector, data() == &front()\&. 
.PP
Definizzle at line 878 of file stl_vector\&.h\&.
.PP
References std::__addressof(), n' std::vector< _Tp, _Alloc >::front()\&.
.SS "iterator \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::emplace (iterator__position, _Args &&\&.\&.\&.__args)\fC [inherited]\fP"

.PP
Inserts a object up in vector before specified iterator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha vector\&. 
.br
\fI__args\fP Arguments\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha banged data\&.
.RE
.PP
This function will bang a object of type T constructed wit T(std::forward<Args>(args)\&.\&.\&.) before tha specified location\&. Note dat dis kind of operation could be high-rollin' fo' a vector n' if it is frequently used tha user should consider rockin std::list\&. 
.SS "bool \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::empty () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns legit if tha vector is empty\&. (Thus begin() would equal end()\&.) 
.PP
Definizzle at line 734 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::begin(), n' std::vector< _Tp, _Alloc >::end()\&.
.SS "iterator \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::end ()\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns a read/write iterator dat points one past tha last element up in tha vector\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 556 of file stl_vector\&.h\&.
.SS "const_iterator \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::end () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns a read-only (constant) iterator dat points one past tha last element up in tha vector\&. Iteration is done up in ordinary element order\&. 
.PP
Definizzle at line 565 of file stl_vector\&.h\&.
.SS "iterator \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::erase (iterator__position)\fC [inherited]\fP"

.PP
Remove element at given position\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP Iterator pointin ta element ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator pointin ta tha next element (or end())\&.
.RE
.PP
This function will erase tha element all up in tha given posizzle n' thus shorten tha vector by one\&.
.PP
Note This operation could be high-rollin' n' if it is frequently used tha user should consider rockin std::list\&. Da user be also cautioned dat dis function only erases tha element, n' dat if tha element is itself a pointer, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.SS "iterator \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::erase (iterator__first, iterator__last)\fC [inherited]\fP"

.PP
Remove a range of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP Iterator pointin ta tha straight-up original gangsta element ta be erased\&. 
.br
\fI__last\fP Iterator pointin ta one past tha last element ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator pointin ta tha element pointed ta by \fI__last\fP prior ta erasin (or end())\&.
.RE
.PP
This function will erase tha elements up in tha range [__first,__last) n' shorten tha vector accordingly\&.
.PP
Note This operation could be high-rollin' n' if it is frequently used tha user should consider rockin std::list\&. Da user be also cautioned dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.SS "reference \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::front ()\fC [inline]\fP, \fC [inherited]\fP"
Returns a read/write reference ta tha data all up in tha straight-up original gangsta element of tha vector\&. 
.PP
Definizzle at line 839 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::begin()\&.
.SS "const_reference \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::front () const\fC [inline]\fP, \fC [inherited]\fP"
Returns a read-only (constant) reference ta tha data all up in tha straight-up original gangsta element of tha vector\&. 
.PP
Definizzle at line 847 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::begin()\&.
.SS "iterator \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::insert (iterator__position, const value_type &__x)\fC [inherited]\fP"

.PP
Inserts given value tha fuck into vector before specified iterator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha vector\&. 
.br
\fI__x\fP Data ta be inserted\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha banged data\&.
.RE
.PP
This function will bang a cold-ass lil copy of tha given value before tha specified location\&. Note dat dis kind of operation could be high-rollin' fo' a vector n' if it is frequently used tha user should consider rockin std::list\&. 
.SS "iterator \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::insert (iterator__position, value_type &&__x)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Inserts given rvalue tha fuck into vector before specified iterator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha vector\&. 
.br
\fI__x\fP Data ta be inserted\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha banged data\&.
.RE
.PP
This function will bang a cold-ass lil copy of tha given rvalue before tha specified location\&. Note dat dis kind of operation could be high-rollin' fo' a vector n' if it is frequently used tha user should consider rockin std::list\&. 
.PP
Definizzle at line 988 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::emplace()\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::insert (iterator__position, \fBinitializer_list\fP< value_type >__l)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Inserts a initializer_list tha fuck into tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha vector\&. 
.br
\fI__l\fP An initializer_list\&.
.RE
.PP
This function will bang copiez of tha data up in tha initializer_list \fIl\fP tha fuck into tha vector before tha location specified by \fIposition\fP\&.
.PP
Note dat dis kind of operation could be high-rollin' fo' a vector n' if it is frequently used tha user should consider rockin std::list\&. 
.PP
Definizzle at line 1005 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::insert()\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::insert (iterator__position, size_type__n, const value_type &__x)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Inserts a fuckin shitload of copiez of given data tha fuck into tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha vector\&. 
.br
\fI__n\fP Number of elements ta be inserted\&. 
.br
\fI__x\fP Data ta be inserted\&.
.RE
.PP
This function will bang a specified number of copiez of tha given data before tha location specified by \fIposition\fP\&.
.PP
Note dat dis kind of operation could be high-rollin' fo' a vector n' if it is frequently used tha user should consider rockin std::list\&. 
.PP
Definizzle at line 1023 of file stl_vector\&.h\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::insert (iterator__position, _InputIterator__first, _InputIterator__last)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Inserts a range tha fuck into tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator tha fuck into tha vector\&. 
.br
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&.
.RE
.PP
This function will bang copiez of tha data up in tha range [__first,__last) tha fuck into tha vector before tha location specified by \fIpos\fP\&.
.PP
Note dat dis kind of operation could be high-rollin' fo' a vector n' if it is frequently used tha user should consider rockin std::list\&. 
.PP
Definizzle at line 1044 of file stl_vector\&.h\&.
.SS "size_type \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::max_size () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns tha size() of tha phattest possible vector\&. 
.PP
Definizzle at line 650 of file stl_vector\&.h\&.
.PP
References std::allocator_traits< _Tp_alloc_type >::max_size()\&.
.SS "reference \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::operator[] (size_type__n)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Subscript access ta tha data contained up in tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha element fo' which data should be accessed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read/write reference ta data\&.
.RE
.PP
This operator allows fo' easy as fuck , array-style, data access\&. Note dat data access wit dis operator is unchecked n' out_of_range lookups is not defined\&. (For checked lookups peep at()\&.) 
.PP
Definizzle at line 770 of file stl_vector\&.h\&.
.SS "const_reference \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::operator[] (size_type__n) const\fC [inline]\fP, \fC [inherited]\fP"

.PP
Subscript access ta tha data contained up in tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Da index of tha element fo' which data should be accessed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) reference ta data\&.
.RE
.PP
This operator allows fo' easy as fuck , array-style, data access\&. Note dat data access wit dis operator is unchecked n' out_of_range lookups is not defined\&. (For checked lookups peep at()\&.) 
.PP
Definizzle at line 785 of file stl_vector\&.h\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::pop_back ()\fC [inline]\fP, \fC [inherited]\fP"

.PP
Removes last element\&. This be a typical stack operation\&. Well shiiiit, it shrinks tha vector by one\&.
.PP
Note dat no data is returned, n' if tha last elementz data is needed, it should be retrieved before pop_back() is called\&. 
.PP
Definizzle at line 937 of file stl_vector\&.h\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::push_back (const value_type &__x)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Add data ta tha end of tha vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Data ta be added\&.
.RE
.PP
This be a typical stack operation\&. Da function creates a element all up in tha end of tha vector n' assigns tha given data ta it\&. Cuz of tha nature of a vector dis operation can be done up in constant time if tha vector has preallocated space available\&. 
.PP
Definizzle at line 901 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::end()\&.
.SS "\fBreverse_iterator\fP \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::rbegin ()\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns a read/write reverse iterator dat points ta tha last element up in tha vector\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 574 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::end()\&.
.SS "\fBconst_reverse_iterator\fP \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::rbegin () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns a read-only (constant) reverse iterator dat points ta tha last element up in tha vector\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 583 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::end()\&.
.SS "\fBreverse_iterator\fP \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::rend ()\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns a read/write reverse iterator dat points ta one before tha straight-up original gangsta element up in tha vector\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 592 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::begin()\&.
.SS "\fBconst_reverse_iterator\fP \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::rend () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns a read-only (constant) reverse iterator dat points ta one before tha straight-up original gangsta element up in tha vector\&. Iteration is done up in reverse element order\&. 
.PP
Definizzle at line 601 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::begin()\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::reserve (size_type__n)\fC [inherited]\fP"

.PP
Attempt ta preallocate enough memory fo' specified number of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__n\fP Number of elements required\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::length_error\fP If \fIn\fP exceedz \fCmax_size()\fP\&.
.RE
.PP
This function attempts ta reserve enough memory fo' tha vector ta hold tha specified number of elements\&. If tha number axed is mo' than max_size(), length_error is thrown\&.
.PP
Da advantage of dis function is dat if optimal code be a necessitizzle n' tha user can determine tha number of elements dat is ghon be required, tha user can reserve tha memory up in advance, n' thus prevent a possible reallocation of memory n' copyin of vector data\&. 
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::resize (size_type__new_size)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Resizes tha vector ta tha specified number of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__new_size\fP Number of elements tha vector should contain\&.
.RE
.PP
This function will resize tha vector ta tha specified number of elements\&. If tha number is smalla than tha vectorz current size tha vector is truncated, otherwise default constructed elements is appended\&. 
.PP
Definizzle at line 664 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::size()\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::resize (size_type__new_size, const value_type &__x)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Resizes tha vector ta tha specified number of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__new_size\fP Number of elements tha vector should contain\&. 
.br
\fI__x\fP Data wit which freshly smoked up elements should be populated\&.
.RE
.PP
This function will resize tha vector ta tha specified number of elements\&. If tha number is smalla than tha vectorz current size tha vector is truncated, otherwise tha vector is extended n' freshly smoked up elements is populated wit given data\&. 
.PP
Definizzle at line 684 of file stl_vector\&.h\&.
.PP
References std::vector< _Tp, _Alloc >::end(), std::vector< _Tp, _Alloc >::insert(), n' std::vector< _Tp, _Alloc >::size()\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::shrink_to_fit ()\fC [inline]\fP, \fC [inherited]\fP"
A non-bindin request ta reduce capacity() ta size()\&. 
.PP
Definizzle at line 716 of file stl_vector\&.h\&.
.SS "size_type \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::size () const\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"
Returns tha number of elements up in tha vector\&. 
.PP
Definizzle at line 645 of file stl_vector\&.h\&.
.SS "void \fBstd::vector\fP< \fB_State\fP , \fBstd::allocator\fP<\fB_State\fP >  >::swap (\fBvector\fP< _State > &__x)\fC [inline]\fP, \fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Swaps data wit another vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A vector of tha same element n' allocator types\&.
.RE
.PP
This exchanges tha elements between two vectors up in constant time\&. (Three pointers, so it should be like fast\&.) Note dat tha global std::swap() function is specialized such dat std::swap(v1,v2) will feed ta dis function\&. 
.PP
Definizzle at line 1108 of file stl_vector\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
