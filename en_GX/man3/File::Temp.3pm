.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::Temp 3"
.TH File::Temp 3 "2013-04-11" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Temp \- return name n' handle of a temporary file safely
.SH "VERSION"
.IX Header "VERSION"
version 0.2301
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use File::Temp qw/ tempfile tempdir /;
\&
\&  $fh = tempfile();
\&  ($fh, $filename) = tempfile();
\&
\&  ($fh, $filename) = tempfile( $template, DIR => $dir);
\&  ($fh, $filename) = tempfile( $template, SUFFIX => \*(Aq.dat\*(Aq);
\&  ($fh, $filename) = tempfile( $template, TMPDIR => 1 );
\&
\&  binmode( $fh, ":utf8" );
\&
\&  $dir = tempdir( CLEANUP => 1 );
\&  ($fh, $filename) = tempfile( DIR => $dir );
.Ve
.PP
Object intercourse:
.PP
.Vb 3
\&  require File::Temp;
\&  use File::Temp ();
\&  use File::Temp qw/ :seekable /;
\&
\&  $fh = File::Temp\->new();
\&  $fname = $fh\->filename;
\&
\&  $fh = File::Temp\->new(TEMPLATE => $template);
\&  $fname = $fh\->filename;
\&
\&  $tmp = File::Temp\->new( UNLINK => 0, SUFFIX => \*(Aq.dat\*(Aq );
\&  print $tmp "Some data\en";
\&  print "Filename is $tmp\en";
\&  $tmp\->seek( 0, SEEK_END );
.Ve
.PP
Da followin intercourses is provided fo' compatibilitizzle with
existin APIs. They should not be used up in freshly smoked up code.
.PP
MkTemp crew:
.PP
.Vb 1
\&  use File::Temp qw/ :mktemp  /;
\&
\&  ($fh, $file) = mkstemp( "tmpfileXXXXX" );
\&  ($fh, $file) = mkstemps( "tmpfileXXXXXX", $suffix);
\&
\&  $tmpdir = mkdtemp( $template );
\&
\&  $unopened_file = mktemp( $template );
.Ve
.PP
\&\s-1POSIX\s0 functions:
.PP
.Vb 1
\&  use File::Temp qw/ :POSIX /;
\&
\&  $file = tmpnam();
\&  $fh = tmpfile();
\&
\&  ($fh, $file) = tmpnam();
.Ve
.PP
Compatibilitizzle functions:
.PP
.Vb 1
\&  $unopened_file = File::Temp::tempnam( $dir, $pfx );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`File::Temp\*(C'\fR can be used ta create n' open temporary filez up in a safe
way.  There is both a gangbangin' function intercourse n' a object-oriented
interface.  Da File::Temp constructor or tha \fItempfile()\fR function can
be used ta return tha name n' tha open filehandle of a temporary
file.  Da \fItempdir()\fR function can be used ta create a temporary
directory.
.PP
Da securitizzle aspect of temporary file creation is emphasized such that
a filehandle n' filename is returned together n' shit.  This helps guarantee
that a race condizzle can not occur where tha temporary file is
created by another process between checkin fo' tha existence of the
file n' its opening.  Additionizzle securitizzle levels is provided to
check, fo' example, dat tha sticky bit is set on ghetto writable
directories. Put ya muthafuckin choppers up if ya feel dis!  See \*(L"safe_level\*(R" fo' mo' shiznit.
.PP
For compatibilitizzle wit ghettofab C library functions, Perl implementations of
the \fImkstemp()\fR crew of functions is provided. Y'all KNOW dat shit, muthafucka! These are, \fImkstemp()\fR,
\&\fImkstemps()\fR, \fImkdtemp()\fR n' \fImktemp()\fR.
.PP
Additionally, implementationz of tha standard \s-1POSIX\s0
\&\fItmpnam()\fR n' \fItmpfile()\fR functions is provided if required.
.PP
Implementationz of \fImktemp()\fR, \fItmpnam()\fR, n' \fItempnam()\fR is provided,
but should be used wit caution since they return only a gangbangin' filename
that was valid when function was called, so cannot guarantee
that tha file aint gonna exist by tha time tha calla opens tha filename.
.PP
Filehandlez returned by these functions support tha seekable methods.
.SH "OBJECT-ORIENTED INTERFACE"
.IX Header "OBJECT-ORIENTED INTERFACE"
This is tha primary intercourse fo' interactin with
\&\f(CW\*(C`File::Temp\*(C'\fR. Usin tha \s-1OO\s0 intercourse a temporary file can be pimped
when tha object is constructed n' tha file can be removed when the
object is no longer required.
.PP
Note dat there is no method ta obtain tha filehandle from the
\&\f(CW\*(C`File::Temp\*(C'\fR object. Da object itself acts as a gangbangin' filehandle.  Da object
isa \f(CW\*(C`IO::Handle\*(C'\fR n' isa \f(CW\*(C`IO::Seekable\*(C'\fR so all dem methodz are
available.
.PP
Also, tha object is configured such dat it stringifies ta tha name of the
temporary file n' so can be compared ta a gangbangin' filename directly.  It numifies
to tha \f(CW\*(C`refaddr\*(C'\fR tha same as other handlez n' so can be compared ta other
handlez wit \f(CW\*(C`==\*(C'\fR.
.PP
.Vb 2
\&    $fh eq $filename       # as a string
\&    $fh != \e*STDOUT        # as a number
.Ve
.IP "\fBnew\fR" 4
.IX Item "new"
Smoke a temporary file object.
.Sp
.Vb 1
\&  mah $tmp = File::Temp\->new();
.Ve
.Sp
by default tha object is constructed as if \f(CW\*(C`tempfile\*(C'\fR
was called without options yo, but wit tha additionizzle behaviour
that tha temporary file is removed by tha object destructor
if \s-1UNLINK\s0 is set ta legit (the default).
.Sp
Supported arguments is tha same as fo' \f(CW\*(C`tempfile\*(C'\fR: \s-1UNLINK
\&\s0(defaultin ta true), \s-1DIR, EXLOCK\s0 n' \s-1SUFFIX.\s0 Additionally, tha filename
template is specified rockin tha \s-1TEMPLATE\s0 option. I aint talkin' bout chicken n' gravy biatch. Da \s-1OPEN\s0 option
is not supported (the file be always opened).
.Sp
.Vb 3
\& $tmp = File::Temp\->new( TEMPLATE => \*(AqtempXXXXX\*(Aq,
\&                        DIR => \*(Aqmydir\*(Aq,
\&                        SUFFIX => \*(Aq.dat\*(Aq);
.Ve
.Sp
Arguments is case insensitive.
.Sp
Can call \fIcroak()\fR if a error occurs.
.IP "\fBnewdir\fR" 4
.IX Item "newdir"
Smoke a temporary directory rockin a object oriented intercourse.
.Sp
.Vb 1
\&  $dir = File::Temp\->newdir();
.Ve
.Sp
By default tha directory is deleted when tha object goes outta scope.
.Sp
Supports tha same ol' dirty options as tha \f(CW\*(C`tempdir\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch. Note dat directories
created wit dis method default ta \s-1CLEANUP\s0 => 1.
.Sp
.Vb 1
\&  $dir = File::Temp\->newdir( $template, %options );
.Ve
.Sp
A template may be specified either wit a leadin template or
with a \s-1TEMPLATE\s0 argument.
.IP "\fBfilename\fR" 4
.IX Item "filename"
Return tha name of tha temporary file associated wit dis object
(if tha object was pimped rockin tha \*(L"new\*(R" constructor).
.Sp
.Vb 1
\&  $filename = $tmp\->filename;
.Ve
.Sp
This method is called automatically when tha object is used as
a string.
.IP "\fBdirname\fR" 4
.IX Item "dirname"
Return tha name of tha temporary directory associated wit this
object (if tha object was pimped rockin tha \*(L"newdir\*(R" constructor).
.Sp
.Vb 1
\&  $dirname = $tmpdir\->dirname;
.Ve
.Sp
This method is called automatically when tha object is used up in strang context.
.IP "\fBunlink_on_destroy\fR" 4
.IX Item "unlink_on_destroy"
Control whether tha file is unlinked when tha object goes outta scope.
Da file is removed if dis value is legit n' \f(CW$KEEP_ALL\fR is not.
.Sp
.Vb 1
\& $fh\->unlink_on_destroy( 1 );
.Ve
.Sp
Default is fo' tha file ta be removed.
.IP "\fB\s-1DESTROY\s0\fR" 4
.IX Item "DESTROY"
When tha object goes outta scope, tha destructor is called. Y'all KNOW dat shit, muthafucka! This
destructor will attempt ta unlink tha file (usin unlink1)
if tha constructor was called wit \s-1UNLINK\s0 set ta 1 (the default state
if \s-1UNLINK\s0 aint specified).
.Sp
No error is given if tha unlink fails.
.Sp
If tha object has been passed ta a cold-ass lil lil pimp process durin a gangbangin' fork, the
file is ghon be deleted when tha object goes outta scope up in tha parent.
.Sp
For a temporary directory object tha directory is ghon be removed unless
the \s-1CLEANUP\s0 argument was used up in tha constructor (and set ta false) or
\&\f(CW\*(C`unlink_on_destroy\*(C'\fR was modified afta creation. I aint talkin' bout chicken n' gravy biatch.  Note dat if a temp
directory is yo' current directory, it cannot be removed \- a warning
will be given up in dis case.  \f(CW\*(C`chdir()\*(C'\fR outta tha directory before
lettin tha object go outta scope.
.Sp
If tha global variable \f(CW$KEEP_ALL\fR is true, tha file or directory
will not be removed.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
This section raps bout tha recommended intercourse fo' generating
temporary filez n' directories.
.IP "\fBtempfile\fR" 4
.IX Item "tempfile"
This is tha basic function ta generate temporary files.
Da behaviour of tha file can be chizzled rockin various options:
.Sp
.Vb 2
\&  $fh = tempfile();
\&  ($fh, $filename) = tempfile();
.Ve
.Sp
Smoke a temporary file up in  tha directory specified fo' temporary
files, as specified by tha \fItmpdir()\fR function up in File::Spec.
.Sp
.Vb 1
\&  ($fh, $filename) = tempfile($template);
.Ve
.Sp
Smoke a temporary file up in tha current directory rockin tha supplied
template.  Trailin `X' charactas is replaced wit random lettas to
generate tha filename.  At least four `X' charactas must be present
at tha end of tha template.
.Sp
.Vb 1
\&  ($fh, $filename) = tempfile($template, SUFFIX => $suffix)
.Ve
.Sp
Same as previously, except dat a suffix be added ta tha template
afta tha `X' translation. I aint talkin' bout chicken n' gravy biatch.  Useful fo' ensurin dat a temporary
filename has a particular extension when needed by other applications.
But peep tha \s-1WARNING\s0 all up in tha end.
.Sp
.Vb 1
\&  ($fh, $filename) = tempfile($template, DIR => $dir);
.Ve
.Sp
Translates tha template as before except dat a gangbangin' finger-lickin' directory name
is specified.
.Sp
.Vb 1
\&  ($fh, $filename) = tempfile($template, TMPDIR => 1);
.Ve
.Sp
Equivalent ta specifyin a \s-1DIR\s0 of \*(L"File::Spec\->tmpdir\*(R", freestylin tha file
into tha same temporary directory as would be used if no template was
specified at all.
.Sp
.Vb 1
\&  ($fh, $filename) = tempfile($template, UNLINK => 1);
.Ve
.Sp
Return tha filename n' filehandle as before except dat tha file is
automatically removed when tha program exits (dependent on
\&\f(CW$KEEP_ALL\fR). Default is fo' tha file ta be removed if a gangbangin' file handle is
axed n' ta be kept if tha filename is requested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In a scalar
context (where no filename is returned) tha file be always deleted
either (dependin on tha operatin system) on exit or when it is
closed (unless \f(CW$KEEP_ALL\fR is legit when tha temp file is pimped).
.Sp
Use tha object-oriented intercourse if fine-grained control of when
a file is removed is required.
.Sp
If tha template aint specified, a template be always
automatically generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This temporary file is placed up in \fItmpdir()\fR
(File::Spec) unless a gangbangin' finger-lickin' directory is specified explicitly wit the
\&\s-1DIR\s0 option.
.Sp
.Vb 1
\&  $fh = tempfile( DIR => $dir );
.Ve
.Sp
If called up in scalar context, only tha filehandle is returned n' the
file will automatically be deleted when closed on operatin systems
that support dis (see tha description of \fItmpfile()\fR elsewhere up in this
document).  This is tha preferred mode of operation, as if you only
have a gangbangin' filehandle, you can never create a race condizzle by fumbling
with tha filename. On systems dat can not unlink a open file or can
not mark a gangbangin' file as temporary when it is opened (for example, Windows
\&\s-1NT\s0 uses tha \f(CW\*(C`O_TEMPORARY\*(C'\fR flag) tha file is marked fo' deletion when
the program endz (equivalent ta settin \s-1UNLINK\s0 ta 1). Da \f(CW\*(C`UNLINK\*(C'\fR
flag is ignored if present.
.Sp
.Vb 1
\&  (undef, $filename) = tempfile($template, OPEN => 0);
.Ve
.Sp
This will return tha filename based on tha template but
will not open dis file.  Cannot be used up in conjunction with
\&\s-1UNLINK\s0 set ta true. Default is ta always open tha file
to protect from possible race conditions fo' realz. A warnin is issued
if warnings is turned on. I aint talkin' bout chicken n' gravy biatch. Consider rockin tha \fItmpnam()\fR
and \fImktemp()\fR functions busted lyrics bout elsewhere up in dis document
if openin tha file aint required.
.Sp
If tha operatin system supports it (for example \s-1BSD\s0 derived systems), tha 
filehandle is ghon be opened wit O_EXLOCK (open wit exclusive file lock). 
This can sometimes cause problems if tha intention is ta pass tha filename 
to another system dat expects ta take a exclusive lock itself (like fuckin 
DBD::SQLite) whilst ensurin dat tha tempfile aint reused. Y'all KNOW dat shit, muthafucka! In dis 
situation tha \*(L"\s-1EXLOCK\*(R"\s0 option can be passed ta tempfile. By default \s-1EXLOCK \s0
will be legit (this retains compatibilitizzle wit earlier releases).
.Sp
.Vb 1
\&  ($fh, $filename) = tempfile($template, EXLOCK => 0);
.Ve
.Sp
Options can be combined as required.
.Sp
Will \fIcroak()\fR if there be a error.
.IP "\fBtempdir\fR" 4
.IX Item "tempdir"
This is tha recommended intercourse fo' creation of temporary
directories. Put ya muthafuckin choppers up if ya feel dis!  By default tha directory aint gonna be removed on exit
(that is, it won't be temporary; dis behaviour can not be chizzled
because of thangs wit backwardz compatibility). To enable removal
either use tha \s-1CLEANUP\s0 option which will trigger removal on program
exit, or consider rockin tha \*(L"newdir\*(R" method up in tha object intercourse which
will allow tha directory ta be cleaned up when tha object goes up of
scope.
.Sp
Da behaviour of tha function dependz on tha arguments:
.Sp
.Vb 1
\&  $tempdir = tempdir();
.Ve
.Sp
Smoke a gangbangin' finger-lickin' directory up in \fItmpdir()\fR (see File::Spec).
.Sp
.Vb 1
\&  $tempdir = tempdir( $template );
.Ve
.Sp
Smoke a gangbangin' finger-lickin' directory from tha supplied template. This template is
similar ta dat busted lyrics bout fo' \fItempfile()\fR. `X' charactas all up in tha end
of tha template is replaced wit random lettas ta construct the
directory name fo' realz. At least four `X' charactas must be up in tha template.
.Sp
.Vb 1
\&  $tempdir = tempdir ( DIR => $dir );
.Ve
.Sp
Specifies tha directory ta use fo' tha temporary directory.
Da temporary directory name is derived from a internal template.
.Sp
.Vb 1
\&  $tempdir = tempdir ( $template, DIR => $dir );
.Ve
.Sp
Prepend tha supplied directory name ta tha template. Da template
should not include parent directory justifications itself fo' realz. Any parent
directory justifications is removed from tha template before
prependin tha supplied directory.
.Sp
.Vb 1
\&  $tempdir = tempdir ( $template, TMPDIR => 1 );
.Ve
.Sp
Usin tha supplied template, create tha temporary directory in
a standard location fo' temporary files. Equivalent ta bustin
.Sp
.Vb 1
\&  $tempdir = tempdir ( $template, DIR => File::Spec\->tmpdir);
.Ve
.Sp
but shorter n' shit. Parent directory justifications is stripped from the
template itself. Da \f(CW\*(C`TMPDIR\*(C'\fR option is ignored if \f(CW\*(C`DIR\*(C'\fR is set
explicitly.  Additionally, \f(CW\*(C`TMPDIR\*(C'\fR is implied if neither a template
nor a gangbangin' finger-lickin' directory is supplied.
.Sp
.Vb 1
\&  $tempdir = tempdir( $template, CLEANUP => 1);
.Ve
.Sp
Smoke a temporary directory rockin tha supplied template yo, but
attempt ta remove it (and all filez inside it) when tha program
exits, n' you can put dat on yo' toast. Note dat a attempt is ghon be made ta remove all filez from
the directory even if they was not pimped by dis module (otherwise
why ask ta clean it up?). Da directory removal is made with
the \fIrmtree()\fR function from tha File::Path module.
Of course, if tha template aint specified, tha temporary directory
will be pimped up in \fItmpdir()\fR n' will also be removed at program exit.
.Sp
Will \fIcroak()\fR if there be a error.
.SH "MKTEMP FUNCTIONS"
.IX Header "MKTEMP FUNCTIONS"
Da followin functions is Perl implementationz of the
\&\fImktemp()\fR crew of temp file generation system calls.
.IP "\fBmkstemp\fR" 4
.IX Item "mkstemp"
Given a template, returns a gangbangin' filehandle ta tha temporary file n' tha name
of tha file.
.Sp
.Vb 1
\&  ($fh, $name) = mkstemp( $template );
.Ve
.Sp
In scalar context, just tha filehandle is returned.
.Sp
Da template may be any filename wit some number of Xz appended
to it, fo' example \fI/tmp/temp.XXXX\fR. Da trailin Xz is replaced
with unique alphanumeric combinations.
.Sp
Will \fIcroak()\fR if there be a error.
.IP "\fBmkstemps\fR" 4
.IX Item "mkstemps"
Similar ta \fImkstemp()\fR, except dat a extra argument can be supplied
with a suffix ta be appended ta tha template.
.Sp
.Vb 1
\&  ($fh, $name) = mkstemps( $template, $suffix );
.Ve
.Sp
For example a template of \f(CW\*(C`testXXXXXX\*(C'\fR n' suffix of \f(CW\*(C`.dat\*(C'\fR
would generate a gangbangin' file similar ta \fItesthGji_w.dat\fR.
.Sp
Returns just tha filehandle ridin' solo when called up in scalar context.
.Sp
Will \fIcroak()\fR if there be a error.
.IP "\fBmkdtemp\fR" 4
.IX Item "mkdtemp"
Smoke a gangbangin' finger-lickin' directory from a template. Da template must end in
Xz dat is replaced by tha routine.
.Sp
.Vb 1
\&  $tmpdir_name = mkdtemp($template);
.Ve
.Sp
Returns tha name of tha temporary directory pimped.
.Sp
Directory must be removed by tha caller.
.Sp
Will \fIcroak()\fR if there be a error.
.IP "\fBmktemp\fR" 4
.IX Item "mktemp"
Returns a valid temporary filename but do not guarantee
that tha file aint gonna be opened by one of mah thugs.
.Sp
.Vb 1
\&  $unopened_file = mktemp($template);
.Ve
.Sp
Template is tha same ol' dirty as dat required by \fImkstemp()\fR.
.Sp
Will \fIcroak()\fR if there be a error.
.SH "POSIX FUNCTIONS"
.IX Header "POSIX FUNCTIONS"
This section raps bout tha re-implementation of tha \fItmpnam()\fR
and \fItmpfile()\fR functions busted lyrics bout up in \s-1POSIX\s0
usin tha \fImkstemp()\fR from dis module.
.PP
Unlike tha \s-1POSIX\s0 implementations, tha directory used
for tha temporary file aint specified up in a system include
file (\f(CW\*(C`P_tmpdir\*(C'\fR) but simply dependz on tha chizzle of \fItmpdir()\fR
returned by File::Spec. On some implementations this
location can be set rockin tha \f(CW\*(C`TMPDIR\*(C'\fR environment variable, which
may not be secure.
If dis be a problem, simply use \fImkstemp()\fR n' specify a template.
.IP "\fBtmpnam\fR" 4
.IX Item "tmpnam"
When called up in scalar context, returns tha full name (includin path)
of a temporary file (uses \fImktemp()\fR). Da only check is dat tha file do
not already exist yo, but there is no guarantee dat that condizzle will
continue ta apply.
.Sp
.Vb 1
\&  $file = tmpnam();
.Ve
.Sp
When called up in list context, a gangbangin' filehandle ta tha open file and
a filename is returned. Y'all KNOW dat shit, muthafucka! This be  bigged up  by callin \fImkstemp()\fR
afta constructin a suitable template.
.Sp
.Vb 1
\&  ($fh, $file) = tmpnam();
.Ve
.Sp
If possible, dis form should be used ta prevent possible
race conditions.
.Sp
See \*(L"tmpdir\*(R" up in File::Spec fo' shiznit on tha chizzle of temporary
directory fo' a particular operatin system.
.Sp
Will \fIcroak()\fR if there be a error.
.IP "\fBtmpfile\fR" 4
.IX Item "tmpfile"
Returns tha filehandle of a temporary file.
.Sp
.Vb 1
\&  $fh = tmpfile();
.Ve
.Sp
Da file is removed when tha filehandle is closed or when tha program
exits, n' you can put dat on yo' toast. No access ta tha filename is provided.
.Sp
If tha temporary file can not be pimped undef is returned.
Currently dis command will probably not work when tha temporary
directory is on a \s-1NFS\s0 file system.
.Sp
Will \fIcroak()\fR if there be a error.
.SH "ADDITIONAL FUNCTIONS"
.IX Header "ADDITIONAL FUNCTIONS"
These functions is provided fo' backwardz compatibility
with common tempfile generation C library functions.
.PP
They is not exported n' must be addressed rockin tha full package
name.
.IP "\fBtempnam\fR" 4
.IX Item "tempnam"
Return tha name of a temporary file up in tha specified directory
usin a prefix. Da file is guaranteed not ta exist all up in tha time
the function was called yo, but such guarantees is phat fo' one
clock tick only.  Always use tha proper form of \f(CW\*(C`sysopen\*(C'\fR
with \f(CW\*(C`O_CREAT | O_EXCL\*(C'\fR if you must open such a gangbangin' filename.
.Sp
.Vb 1
\&  $filename = File::Temp::tempnam( $dir, $prefix );
.Ve
.Sp
Equivalent ta hustlin \fImktemp()\fR wit \f(CW$dir\fR/$prefixXXXXXXXX
(usin unix file convention as a example)
.Sp
Because dis function uses \fImktemp()\fR, it can suffer from race conditions.
.Sp
Will \fIcroak()\fR if there be a error.
.SH "UTILITY FUNCTIONS"
.IX Header "UTILITY FUNCTIONS"
Useful functions fo' dealin wit tha filehandle n' filename.
.IP "\fBunlink0\fR" 4
.IX Item "unlink0"
Given a open filehandle n' tha associated filename, cook up a safe
unlink. This be  bigged up  by first checkin dat tha filename and
filehandle initially point ta tha same file n' dat tha number of
links ta tha file is 1 (all fieldz returned by \fIstat()\fR is compared).
Then tha filename is unlinked n' tha filehandle checked once again n' again n' again to
verify dat tha number of links on dat file is now 0.  This is the
closest you can come ta makin shizzle dat tha filename unlinked was the
same as tha file whose descriptor you hold.
.Sp
.Vb 2
\&  unlink0($fh, $path)
\&     or take a thugged-out dirtnap "Error unlinkin file $path safely";
.Ve
.Sp
Returns false on error but \fIcroaks()\fR if there be a security
anomaly. Da filehandle aint closed since on some occasions dis is
not required.
.Sp
On some platforms, fo' example Windows \s-1NT,\s0 it aint possible to
unlink a open file (the file must be closed first). On them
platforms, tha actual unlinkin is deferred until tha program endz and
phat status is returned. Y'all KNOW dat shit, muthafucka! A check is still performed ta make shizzle that
the filehandle n' filename is pointin ta tha same thang (but not at
the time tha end block is executed since tha deferred removal may not
have access ta tha filehandle).
.Sp
Additionally, on Windows \s-1NT\s0 not all tha fieldz returned by \fIstat()\fR can
be compared. Y'all KNOW dat shit, muthafucka! For example, tha \f(CW\*(C`dev\*(C'\fR n' \f(CW\*(C`rdev\*(C'\fR fieldz seem ta be
different.  Also, it seems dat tha size of tha file returned by \fIstat()\fR
does not always agree, wit \f(CW\*(C`stat(FH)\*(C'\fR bein mo' accurate than
\&\f(CW\*(C`stat(filename)\*(C'\fR, presumably cuz of cachin thangs even when
usin autoflush (this is probably overcome by waitin a while after
writin ta tha tempfile before attemptin ta \f(CW\*(C`unlink0\*(C'\fR it).
.Sp
Finally, on \s-1NFS\s0 file systems tha link count of tha file handle do
not always git all up in zero immediately afta unlinking. Currently, this
command is sposed ta fuckin fail on \s-1NFS\s0 disks.
.Sp
This function is disabled if tha global variable \f(CW$KEEP_ALL\fR is true
and a unlink on open file is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha unlink is ta be deferred
to tha \s-1END\s0 block, tha file is still registered fo' removal.
.Sp
This function should not be called if yo ass is rockin tha object oriented
interface since tha it will interfere wit tha object destructor deleting
the file.
.IP "\fBcmpstat\fR" 4
.IX Item "cmpstat"
Compare \f(CW\*(C`stat\*(C'\fR of filehandle wit \f(CW\*(C`stat\*(C'\fR of provided filename.  This
can be used ta check dat tha filename n' filehandle initially point
to tha same file n' dat tha number of links ta tha file is 1 (all
fieldz returned by \fIstat()\fR is compared).
.Sp
.Vb 2
\&  cmpstat($fh, $path)
\&     or take a thugged-out dirtnap "Error comparin handle wit file";
.Ve
.Sp
Returns false if tha stat shiznit differs or if tha link count is
greata than 1. Calls croak if there be a securitizzle anomaly.
.Sp
On certain platforms, fo' example Windows, not all tha fieldz returned by \fIstat()\fR
can be compared. Y'all KNOW dat shit, muthafucka! For example, tha \f(CW\*(C`dev\*(C'\fR n' \f(CW\*(C`rdev\*(C'\fR fieldz seem ta be
different up in Windows.  Also, it seems dat tha size of tha file
returned by \fIstat()\fR do not always agree, wit \f(CW\*(C`stat(FH)\*(C'\fR bein more
accurate than \f(CW\*(C`stat(filename)\*(C'\fR, presumably cuz of cachin issues
even when rockin autoflush (this is probably overcome by waitin a while
afta freestylin ta tha tempfile before attemptin ta \f(CW\*(C`unlink0\*(C'\fR it).
.Sp
Not exported by default.
.IP "\fBunlink1\fR" 4
.IX Item "unlink1"
Similar ta \f(CW\*(C`unlink0\*(C'\fR except afta file comparison rockin cmpstat, the
filehandle is closed prior ta attemptin ta unlink tha file. This
allows tha file ta be removed without rockin a \s-1END\s0 block yo, but do
mean dat tha post-unlink comparison of tha filehandle state provided
by \f(CW\*(C`unlink0\*(C'\fR aint available.
.Sp
.Vb 2
\&  unlink1($fh, $path)
\&     or take a thugged-out dirtnap "Error closin n' unlinkin file";
.Ve
.Sp
Usually called from tha object destructor when rockin tha \s-1OO\s0 intercourse.
.Sp
Not exported by default.
.Sp
This function is disabled if tha global variable \f(CW$KEEP_ALL\fR is true.
.Sp
Can call \fIcroak()\fR if there be a securitizzle anomaly durin tha \fIstat()\fR
comparison.
.IP "\fBcleanup\fR" 4
.IX Item "cleanup"
Callin dis function will cause any temp filez or temp directories
that is registered fo' removal ta be removed. Y'all KNOW dat shit, muthafucka! This happens automatically
when tha process exits but can be triggered manually if tha calla is sure
that none of tha temp filez is required. Y'all KNOW dat shit, muthafucka! This method can be registered as
an Apache callback.
.Sp
Note dat if a temp directory is yo' current directory, it cannot be
removed. Y'all KNOW dat shit, muthafucka!  \f(CW\*(C`chdir()\*(C'\fR outta tha directory first before calling
\&\f(CW\*(C`cleanup()\*(C'\fR. (For tha cleanup at program exit when tha \s-1CLEANUP\s0 flag
is set, dis happens automatically.)
.Sp
On OSes where temp filez is automatically removed when tha temp file
is closed, callin dis function gonna git no effect other than ta remove
temporary directories (which may include temporary files).
.Sp
.Vb 1
\&  File::Temp::cleanup();
.Ve
.Sp
Not exported by default.
.SH "PACKAGE VARIABLES"
.IX Header "PACKAGE VARIABLES"
These functions control tha global state of tha package.
.IP "\fBsafe_level\fR" 4
.IX Item "safe_level"
Controls tha lengths ta which tha module will git all up in check tha safety of the
temporary file or directory before proceeding.
Options are:
.RS 4
.IP "\s-1STANDARD\s0" 8
.IX Item "STANDARD"
Do tha basic securitizzle measures ta ensure tha directory exists n' is
writable, dat temporary filez is opened only if they do not already
exist, n' dat possible race conditions is avoided. Y'all KNOW dat shit, muthafucka!  Finally the
unlink0 function is used ta remove filez safely.
.IP "\s-1MEDIUM\s0" 8
.IX Item "MEDIUM"
In addizzle ta tha \s-1STANDARD\s0 security, tha output directory is checked
to make shizzle dat it is owned either by root or tha user hustlin the
program. If tha directory is writable by crew or by other, it is then
checked ta make shizzle dat tha sticky bit is set.
.Sp
Will not work on platforms dat do not support tha \f(CW\*(C`\-k\*(C'\fR test
for sticky bit.
.IP "\s-1HIGH\s0" 8
.IX Item "HIGH"
In addizzle ta tha \s-1MEDIUM\s0 securitizzle checks, also check fo' the
possibilitizzle of ``\fIchown()\fR giveaway'' rockin tha \s-1POSIX\s0
\&\fIsysconf()\fR function. I aint talkin' bout chicken n' gravy biatch. If dis be a possibility, each directory up in the
path is checked up in turn fo' safeness, recursively struttin back ta the
root directory.
.Sp
For platforms dat do not support tha \s-1POSIX\s0
\&\f(CW\*(C`_PC_CHOWN_RESTRICTED\*(C'\fR symbol (for example, Windows \s-1NT\s0) it is
assumed dat ``\fIchown()\fR giveaway'' is possible n' tha recursive test
is performed.
.RE
.RS 4
.Sp
Da level can be chizzled as bigs up:
.Sp
.Vb 1
\&  File::Temp\->safe_level( File::Temp::HIGH );
.Ve
.Sp
Da level constants is not exported by tha module.
.Sp
Currently, you must be hustlin at least perl v5.6.0 up in order to
run wit \s-1MEDIUM\s0 or \s-1HIGH\s0 security. This is simply cuz the
safety tests use functions from Fcntl dat is not
available up in olda versionz of perl. Da problem is dat tha version
number fo' Fcntl is tha same ol' dirty up in perl 5.6.0 n' up in 5.005_03 even though
they is different versions.
.Sp
On systems dat do not support tha \s-1HIGH\s0 or \s-1MEDIUM\s0 safety levels
(for example Win \s-1NT\s0 or \s-1OS/2\s0) any attempt ta chizzle tha level will
be ignored. Y'all KNOW dat shit, muthafucka! Da decision ta ignore rather than raise a exception
allows portable programs ta be freestyled wit high securitizzle up in mind
for tha systems dat can support dis without dem programs failing
on systems where tha extra tests is irrelevant.
.Sp
If you straight-up need ta peep whether tha chizzle has been accepted
simply examine tha return value of \f(CW\*(C`safe_level\*(C'\fR.
.Sp
.Vb 3
\&  $newlevel = File::Temp\->safe_level( File::Temp::HIGH );
\&  take a thugged-out dirtnap "Could not chizzle ta high security"
\&      if $newlevel != File::Temp::HIGH;
.Ve
.RE
.IP "TopSystemUID" 4
.IX Item "TopSystemUID"
This is tha highest \s-1UID\s0 on tha current system dat refers ta a root
\&\s-1UID.\s0 This is used ta make shizzle dat tha temporary directory is
owned by a system \s-1UID \s0(\f(CW\*(C`root\*(C'\fR, \f(CW\*(C`bin\*(C'\fR, \f(CW\*(C`sys\*(C'\fR etc) rather than
simply by root.
.Sp
This is required since on nuff unix systems \f(CW\*(C`/tmp\*(C'\fR aint owned
by root.
.Sp
Default is ta assume dat any \s-1UID\s0 less than or equal ta 10 be a root
\&\s-1UID.\s0
.Sp
.Vb 2
\&  File::Temp\->top_system_uid(10);
\&  mah $topid = File::Temp\->top_system_uid;
.Ve
.Sp
This value can be adjusted ta reduce securitizzle checkin if required.
Da value is only relevant when \f(CW\*(C`safe_level\*(C'\fR is set ta \s-1MEDIUM\s0 or higher.
.ie n .IP "\fB\fB$KEEP_ALL\fB\fR" 4
.el .IP "\fB\f(CB$KEEP_ALL\fB\fR" 4
.IX Item "$KEEP_ALL"
Controls whether temporary filez n' directories should be retained
regardless of any instructions up in tha program ta remove them
automatically.  This is useful fo' debuggin but should not be used in
thang code.
.Sp
.Vb 1
\&  $File::Temp::KEEP_ALL = 1;
.Ve
.Sp
Default is fo' filez ta be removed as axed by tha caller.
.Sp
In some cases, filez will only be retained if dis variable is true
when tha file is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This means dat you can not create a temporary
file, set dis variable n' expect tha temp file ta still be around
when tha program exits.
.ie n .IP "\fB\fB$DEBUG\fB\fR" 4
.el .IP "\fB\f(CB$DEBUG\fB\fR" 4
.IX Item "$DEBUG"
Controls whether debuggin lyrics should be enabled.
.Sp
.Vb 1
\&  $File::Temp::DEBUG = 1;
.Ve
.Sp
Default is fo' debuggin mode ta be disabled.
.SH "WARNING"
.IX Header "WARNING"
For maximum security, endeavour always ta avoid eva lookin at,
touching, or even imputin tha existence of tha filename.  Yo ass do not
know dat that filename is connected ta tha same file as tha handle
you have, n' attempts ta check dis can only trigger mo' race
conditions.  It aint nuthin but far mo' secure ta use tha filehandle ridin' solo and
dispense wit tha filename altogether.
.PP
If you need ta pass tha handle ta suttin' dat expects a gangbangin' filename
then on a unix system you can use \f(CW\*(C`"/dev/fd/" . fileno($fh)\*(C'\fR for
arbitrary programs. Perl code dat uses tha 2\-argument version of
\&\f(CW\*(C`open\*(C'\fR can be passed \f(CW\*(C`"+<=&" . fileno($fh)\*(C'\fR. Otherwise you
will need ta pass tha filename. Yo ass will gotta clear the
close-on-exec bit on dat file descriptor before passin it ta another
process.
.PP
.Vb 3
\&    use Fcntl qw/F_SETFD F_GETFD/;
\&    fcntl($tmpfh, F_SETFD, 0)
\&        or take a thugged-out dirtnap "Can\*(Aqt clear close\-on\-exec flag on temp fh: $!\en";
.Ve
.SS "Temporary filez n' \s-1NFS\s0"
.IX Subsection "Temporary filez n' NFS"
Some problems is associated wit rockin temporary filez dat reside
on \s-1NFS\s0 file systems n' it is recommended dat a local filesystem
is used whenever possible. Right back up in yo muthafuckin ass. Some of tha securitizzle tests will most probably
fail when tha temp file aint local. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack fo' realz. Additionally, be aware that
the performizzle of I/O operations over \s-1NFS\s0 aint gonna be as phat as for
a local disk.
.SS "Forking"
.IX Subsection "Forking"
In some cases filez pimped by File::Temp is removed from within an
\&\s-1END\s0 block. Right back up in yo muthafuckin ass. Since \s-1END\s0 blocks is triggered when a cold-ass lil lil pimp process exits
(unless \f(CW\*(C`POSIX::_exit()\*(C'\fR is used by tha child) File::Temp takes care
to only remove dem temp filez pimped by a particular process \s-1ID.\s0 This
means dat a cold-ass lil lil pimp aint gonna attempt ta remove temp filez pimped by the
parent process.
.PP
If yo ass is forkin nuff processes up in parallel dat is all bustin
temporary files, you may need ta reset tha random number seed using
srand(\s-1EXPR\s0) up in each lil pimp else all tha lil pimps will attempt ta strutt
all up in tha same set of random file names n' may well cause
themselves ta give up if they exceed tha number of retry attempts.
.SS "Directory removal"
.IX Subsection "Directory removal"
Note dat if you have chdir'ed tha fuck into tha temporary directory n' it is
subsequently cleaned up (either up in tha \s-1END\s0 block or as part of object
destruction), then yo big-ass booty is ghon git a warnin from \fIFile::Path::rmtree()\fR.
.SS "Taint mode"
.IX Subsection "Taint mode"
If you need ta run code under taint mode, uppimpin ta tha sickest fuckin
File::Spec is highly recommended.
.SS "\s-1BINMODE\s0"
.IX Subsection "BINMODE"
Da file returned by File::Temp gonna git been opened up in binary mode
if such a mode be available. If dat aint erect, use tha \f(CW\*(C`binmode()\*(C'\fR
function ta chizzle tha mode of tha filehandle.
.PP
Note dat you can modify tha encodin of a gangbangin' file opened by File::Temp
also by rockin \f(CW\*(C`binmode()\*(C'\fR.
.SH "HISTORY"
.IX Header "HISTORY"
Originally fuckin started game up in May 1999 as a \s-1XS\s0 intercourse ta tha system
\&\fImkstemp()\fR function. I aint talkin' bout chicken n' gravy biatch. In March 2000, tha OpenBSD \fImkstemp()\fR code was
translated ta Perl fo' total control of tha code's
securitizzle checking, ta ensure tha presence of tha function regardless of
operatin system n' ta help wit portability. Da module was shipped
as a standard part of perl from v5.6.1.
.PP
Thanks ta Tomothy Christiansen fo' suggestin dat dis module
should be freestyled n' providin scams fo' code improvements and
securitizzle enhancements.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"tmpnam\*(R" up in \s-1POSIX\s0, \*(L"tmpfile\*(R" up in \s-1POSIX\s0, File::Spec, File::Path
.PP
See IO::File n' File::MkTemp, Apache::TempFile for
different implementationz of temporary file handling.
.PP
See File::Tempdir fo' a alternatizzle object-oriented wrapper for
the \f(CW\*(C`tempdir\*(C'\fR function.
.PP
# vim: ts=2 sts=2 sw=2 et:
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests all up in tha issue tracker
at <https://rt.cpan.org/Public/Dist/Display.html?Name=File\-Temp>.
Yo ass is ghon be notified automatically of any progress on yo' issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  Da code repository be available for
hood review n' contribution under tha termz of tha license.
.PP
<http://github.com/Perl\-Toolchain\-Gang/File\-Temp>
.PP
.Vb 1
\&  git clone git://github.com/Perl\-Toolchain\-Gang/File\-Temp.git
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Slim Tim Jennizz <tjenness@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Lil' Bow Wow Tilly <btilly@gmail.com>
.IP "\(bu" 4
Dizzy Golden <dagolden@cpan.org>
.IP "\(bu" 4
Ed Avis <eda@linux01.wcl.local>
.IP "\(bu" 4
Jizzy E. Keenan <jkeen@verizon.net>
.IP "\(bu" 4
Kevin Ryde <user42@zip.com.au>
.IP "\(bu" 4
Peta Jizzy Acklam <pjacklam@online.no>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2013 by Slim Tim Jennizz n' tha \s-1UK\s0 Particle Physics n' Astronomizzle Research Council.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as tha Perl 5 programmin language system itself.
