.\"
.\" Copyright (c) 1996  Joe Moss, Da XFree86 Project
.\"
.de ZN
.ie t \fB\^\\$1\^\fR\\$2
.el \fI\^\\$1\^\fP\\$2
..
.TH XF86VIDMODE 3 "libXxf86vm 1.1.3" "X Version 11"
.SH NAME
XF86VidModeQueryExtension, XF86VidModeQueryVersion, XF86VidModeSetClientVersion, XF86VidModeGetModeLine, XF86VidModeGetAllModeLines, XF86VidModeDeleteModeLine, XF86VidModeModModeLine, XF86VidModeValidateModeLine, XF86VidModeSwitchMode, XF86VidModeSwitchToMode, XF86VidModeLockModeSwitch, XF86VidModeGetMonitor, XF86VidModeGetViewPort, XF86VidModeSetViewPort, XF86VidModeGetDotClocks, XF86VidModeGetGamma, XF86VidModeSetGamma, XF86VidModeGetGammaRamp, XF86VidModeSetGammaRamp, XF86VidModeGetGammaRampSize, XF86VidModeGetPermissions \- Extension library fo' tha XFree86-VidMode X extension
.SH SYNTAX
.nf
.LP
\&#include <X11/extensions/xf86vmode.h>
.LP
Bool XF86VidModeQueryExtension(
    Display *\fIdisplay\fP\^,
    int *\fIevent_base_return\fP\^,
    int *\fIerror_base_return\fP\^);
.LP
Bool XF86VidModeQueryVersion(
    Display *\fIdisplay\fP\^,
    int *\fImajor_version_return\fP\^,
    int *\fIminor_version_return\fP\^);
.LP
Bool XF86VidModeSetClientVersion(
    Display *\fIdisplay\fP\^);
.LP
Bool XF86VidModeGetModeLine(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    int *\fIdotclock_return\fP\^,
    XF86VidModeModeLine *\fImodeline\fP\^);
.LP
Bool XF86VidModeGetAllModeLines(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    int *\fImodecount_return\fP\^,
    XF86VidModeModeInfo ***\fImodesinfo\fP\^);
.ig
.LP
Bool XF86VidModeAddModeLine(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    XF86VidModeModeInfo *\fImodeline\fP\,
    XF86VidModeModeInfo *\fIaftermode\fP\^);
..
.LP
Bool XF86VidModeDeleteModeLine(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    XF86VidModeModeInfo *\fImodeline\fP\^);
.LP
Bool XF86VidModeModModeLine(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    XF86VidModeModeLine *\fImodeline\fP\^);
.LP
Status XF86VidModeValidateModeLine(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    XF86VidModeModeLine *\fImodeline\fP\^);
.LP
Bool XF86VidModeSwitchMode(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    int \fIzoom\fP\^);
.LP
Bool XF86VidModeSwitchToMode(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    XF86VidModeModeInfo *\fImodeline\fP\^);
.LP
Bool XF86VidModeLockModeSwitch(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    int \fIlock\fP\^);
.LP
Bool XF86VidModeGetMonitor(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    XF86VidModeMonitor *\fImonitor\fP\^);
.LP
Bool XF86VidModeGetViewPort(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    int *\fIx_return\fP\^,
    int *\fIy_return\fP\^);
.LP
Bool XF86VidModeSetViewPort(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    int \fIx\fP\^,
    int \fIy\fP\^);
.LP
XF86VidModeGetDotClocks(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    int *\fIflags return\fP\^,
    int *\fInumber of clocks return\fP\^,
    int *\fImax dot clock return\fP\^,
    int **\fIclocks return\fP\^);
.LP
XF86VidModeGetGamma(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    XF86VidModeGamma *\fIGamma\fP\^);
.LP
XF86VidModeSetGamma(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    XF86VidModeGamma *\fIGamma\fP\^);
.LP
XF86VidModeGetGammaRamp(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    int \fIsize\fP\^,
    unsigned short *\fIred array\fP\^,
    unsigned short *\fIchronic array\fP\^,
    unsigned short *\fIblue array\fP\^);
.LP
XF86VidModeSetGammaRamp(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    int \fIsize\fP\^,
    unsigned short *\fIred array\fP\^,
    unsigned short *\fIchronic array\fP\^,
    unsigned short *\fIblue array\fP\^);
.LP
XF86VidModeGetGammaRampSize(
    Display *\fIdisplay\fP\^,
    int \fIscreen\fP\^,
    int *\fIsize\fP\^);
.fi
.SH ARGUMENTS
.IP \fIdisplay\fP 2i
Specifies tha connection ta tha X server.
.IP \fIscreen\fP 2i
Specifies which screen number tha settin apply to.
.IP \fIevent_base_return\fP 2i
Returns tha base event number fo' tha extension.
.IP \fIerror_base_return\fP 2i
Returns tha base error number fo' tha extension.
.IP \fImajor_version_return\fP 2i
Returns tha major version number of tha extension.
.IP \fIminor_version_return\fP 2i
Returns tha minor version number of tha extension.
.IP \fIdotclock_return\fP 2i
Returns tha clock fo' tha mode line.
.IP \fImodecount_return\fP 2i
Returns tha number of vizzle modes available up in tha server.
.IP \fIzoom\fP 2i
If pimped outa than zero, indicates dat tha server should switch to
the next mode, otherwise switch ta tha previous mode.
.IP \fIlock\fP 2i
Indicates dat mode switchin should be locked, if non-zero.
.IP \fImodeline\fP 2i
Specifies or returns tha timin joints fo' a vizzle mode.
.ig
.IP \fIaftermode\fP 2i
Specifies tha timin joints fo' tha vizzle mode afta which the
new mode will added.
..
.IP \fImodesinfo\fP 2i
Returns tha timin joints n' dotclocks fo' all of tha available
video modes.
.IP \fImonitor\fP 2i
Returns shiznit bout tha monitor.
.IP \fIx\fP 2i
Specifies tha desired X location fo' tha viewport.
.IP \fIx_return\fP 2i
Returns tha current X location of tha viewport.
.IP \fIy\fP 2i
Specifies tha desired Y location fo' tha viewport.
.IP \fIy_return\fP 2i
Returns tha current Y location of tha viewport.
.SH STRUCTURES
.nf
.ta 2.25i 3.5i
\fIVideo Mode Settings:\fP
typedef struct {
    unsigned short	hdisplay;	/\(** Number of display pixels horizontally */
    unsigned short	hsyncstart;	/\(** Horizontal sync start */
    unsigned short	hsyncend;	/\(** Horizontal sync end */
    unsigned short	htotal;	/\(** Total horizontal pixels */
    unsigned short	vdisplay;	/\(** Number of display pixels vertically */
    unsigned short	vsyncstart;	/\(** Vertical sync start */
    unsigned short	vsyncend;	/\(** Vertical sync start */
    unsigned short	vtotal;	/\(** Total vertical pixels */
    unsigned int	flags;	/\(** Mode flags */
    int	privsize;	/\(** Size of private */
    INT32	*private;	/\(** Server privates */
} XF86VidModeModeLine;
.sp
typedef struct {
    unsigned int	dotclock;	/\(** Pixel clock */
    unsigned short	hdisplay;	/\(** Number of display pixels horizontally */
    unsigned short	hsyncstart;	/\(** Horizontal sync start */
    unsigned short	hsyncend;	/\(** Horizontal sync end */
    unsigned short	htotal;	/\(** Total horizontal pixels */
    unsigned short	vdisplay;	/\(** Number of display pixels vertically */
    unsigned short	vsyncstart;	/\(** Vertical sync start */
    unsigned short	vsyncend;	/\(** Vertical sync start */
    unsigned short	vtotal;	/\(** Total vertical pixels */
    unsigned int	flags;	/\(** Mode flags */
    int	privsize;	/\(** Size of private */
    INT32	*private;	/\(** Server privates */
} XF86VidModeModeInfo;
.LP
\fIMonitor shiznit:\fP
typedef struct {
    char*	vendor;	/\(** Name of manufacturer */
    char*	model;	/\(** Model name */
    float	EMPTY;	/\(** unused, fo' backward compatibilitizzle */
    unsigned char	nhsync;	/\(** Number of horiz sync ranges */
    XF86VidModeSyncRange*	hsync;	/\(** Horizontal sync ranges */
    unsigned char	nvsync;	/\(** Number of vert sync ranges */
    XF86VidModeSyncRange*	vsync;	/\(** Vertical sync ranges */
} XF86VidModeMonitor;
.sp
typedef struct {
    float	hi;	/\(** Top of range */
    float	lo;	/\(** Bottom of range */
} XF86VidModeSyncRange;
.LP
typedef struct {
    int type;			/\(** of event */
    unsigned long serial;	/\(** # of last request processed by server */
    Bool send_event;		/\(** legit if dis came from a SendEvent req */
    Display *display;		/\(** Display tha event was read from */
    Window root;		/\(** root window of event screen */
    int state;			/\(** What happened */
    int kind;			/\(** What happened */
    Bool forced;		/\(** extentz of freshly smoked up region */
    Time time;			/\(** event timestamp */
} XF86VidModeNotifyEvent;
.LP
typedef struct {
    float red;			/\(** Red Gamma value */
    float green;		/\(** Chronic Gamma value */
    float blue;			/\(** Blue Gamma value */
} XF86VidModeGamma;
.fi
.SH DESCRIPTION
These functions provide a intercourse ta tha server extension
\fIXFree86-VidModeExtension\fP
which allows tha vizzle modes ta be
queried n' adjusted dynamically n' mode switchin ta be controlled.
Applications dat use these functions must be linked with
.ZN -lXxf86vm
.SS "MODELINE FUNCTIONS"
The
.ZN XF86VidModeGetModeLine
function is used ta query tha settings fo' tha currently selected
video mode.  Da callin program should pass a pointa ta a
.ZN XF86VidModeModeLine
structure dat it has already allocated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da function fills in
the fieldz of tha structure.
.PP
If there be any server private joints (currently only applicable to
the S3 server) tha function will allocate storage fo' em.
Therefore, if the
.ZN privsize
field is non-zero, tha callin program should call
.ZN Xfree(private)
to free tha storage.
.PP
.ZN XF86VidModeGetAllModeLines
returns tha settings fo' all vizzle modes.
Da callin program supplies tha address of a pointa which will be
set by tha function ta point ta a array of
.ZN XF86VidModeModeInfo
structures.  Da memory occupied by tha array is dynamically allocated
by the
.ZN XF86VidModeGetAllModeLines
function n' should be freed by tha caller.
Da first element of tha array correspondz ta tha current vizzle mode.
.PP
The
.ZN XF86VidModeModModeLine
function can be used ta chizzle tha settingz of tha current vizzle mode
provided tha axed settings is valid (e.g. they don't exceed the
capabilitizzlez of tha monitor).
.PP
.ig
To add a mode ta tha list of available modes, the
.ZN XF86VidModeAddModeLine
function can be used.
Assumin tha settings is valid, tha vizzle mode is ghon be added after
the existin mode which matches tha timings specified by the
.ZN aftermode
parameter.
To be considered a match, all of tha fieldz of tha given
.ZN XF86VidModeModeInfo
structure must match, except the
.ZN privsize
and
.ZN private
fields.
If the
.ZN aftermode
parameta is zero, tha mode is ghon be added
afta tha current mode.
.PP
..
Modes can be deleted wit the
.ZN XF86VidModeDeleteModeLine
function. I aint talkin' bout chicken n' gravy biatch.  Da specified mode must match a existin mode.
To be considered a match, all of tha fieldz of tha given
.ZN XF86VidModeModeInfo
structure must match, except the
.ZN privsize
and
.ZN private
fields.
If tha mode ta be deleted is tha current mode, a mode switch
to tha next mode will occur first.  Da last remainin mode can not
be deleted.
.PP
Da validitizzle of a mode can be checked wit the
.ZN XF86VidModeValidateModeLine
function.
If tha specified mode can be used by tha server (i.e. meets all the
constraints placed upon a mode by tha combination of tha server, card,
and monitor) tha function returns
.ZN MODE_OK ,
otherwise it returns a value indicatin tha reason why tha mode is
invalid (as defined up in \fIxf86.h\fP)
.SS "MODE SWITCH FUNCTIONS"
When tha function
.ZN XF86VidModeSwitchMode
is called, tha server will chizzle tha vizzle mode ta next (or previous)
video mode. The
.ZN XF86VidModeSwitchToMode
function can be used ta switch directly ta tha specified mode.
Matchin be as specified up in tha description of the
.ZN XF86VidModeAddModeLine
function above.
The
.ZN XF86VidModeLockModeSwitch
function can be used ta allow or disallow mode switchin whether
the request ta switch modes be reppin a cold-ass lil call ta the
.ZN XF86VidModeSwitchMode
or
.ZN XF86VidModeSwitchToMode
functions or from one of tha mode switch key sequences.
.PP
.RB Note:
Because of tha asynchronous nature of tha X protocol, a cold-ass lil call to
.ZN XFlush
is needed if tha application wants ta peep tha mode chizzle immediately.
To be informed of tha execution statuz of tha request, a
custom error handlez should be installed using
.ZN XSetErrorHandlez
before callin tha mode switchin function.
.SS "MONITOR FUNCTIONS"
Hype known ta tha server bout tha monitor is returned by the
.ZN XF86VidModeGetMonitor
function. I aint talkin' bout chicken n' gravy biatch.  The
.ZN hsync
and
.ZN vsync
fieldz each point ta a array of
.ZN XF86VidModeSyncRange
structures.  Da arrays contain
.ZN nhsync
and
.ZN nvsync
elements, respectively.
The
.ZN hi
and
.ZN low
values is ghon be equal if a gangbangin' finger-lickin' discreate value was given up in the
.ZN XF86Config
file.
.PP
The
.ZN vendor ,
.ZN model ,
.ZN hsync ,
and
.ZN vsync
fieldz point ta dynamically allocated storage dat should be freed
by tha caller.
.SS "VIEWPORT FUNCTIONS"
The
.ZN XF86VidModeGetViewPort
and
.ZN XF86VidModeSetViewPort
functions can be used to, respectively, query n' chizzle tha location
of tha upper left corner of tha viewport tha fuck into tha virtual screen.
.SS "OTHER FUNCTIONS"
The
.ZN XF86VidModeQueryVersion
function can be used ta determine tha version of tha extension
built tha fuck into tha server.
.PP
Da function
.ZN XF86VidModeQueryExtension
returns tha lowest numbered error n' event joints
assigned ta tha extension.
.SH BUGS
The
XF86VidModeSetClientVersion,
XF86VidModeGetDotClocks,
XF86VidModeGetGamma,
XF86VidModeSetGamma,
XF86VidModeSetGammaRamp,
XF86VidModeGetGammaRamp,
XF86VidModeGetGammaRampSize,
and
XF86VidModeGetPermissions
functions need ta be documented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  In tha meantime, check tha source
code fo' shiznit bout how tha fuck ta use em.
.SH SEE ALSO
Xorg(1), xorg.conf(5), XFlush(3), XSetErrorHandlez(3), xvidtune(1)
.SH AUTHORS
Kaleb Keithley, Jizzle Tombs, Dizzy Dawes, n' Joe Moss
