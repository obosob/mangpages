.TH PCREAPI 3 "12 May 2013" "PCRE 8.33"
.SH NAME
PCRE - Perl-compatible regular expressions
.sp
.B #include <pcre.h>
.
.
.SH "PCRE NATIVE API BASIC FUNCTIONS"
.rs
.sp
.SM
.B pcre *pcre_compile(const char *\fIpattern\fP, int \fIoptions\fP,
.ti +5n
.B const char **\fIerrptr\fP, int *\fIerroffset\fP,
.ti +5n
.B const unsigned char *\fItableptr\fP);
.PP
.B pcre *pcre_compile2(const char *\fIpattern\fP, int \fIoptions\fP,
.ti +5n
.B int *\fIerrorcodeptr\fP,
.ti +5n
.B const char **\fIerrptr\fP, int *\fIerroffset\fP,
.ti +5n
.B const unsigned char *\fItableptr\fP);
.PP
.B pcre_extra *pcre_study(const pcre *\fIcode\fP, int \fIoptions\fP,
.ti +5n
.B const char **\fIerrptr\fP);
.PP
.B void pcre_free_study(pcre_extra *\fIextra\fP);
.PP
.B int pcre_exec(const pcre *\fIcode\fP, "const pcre_extra *\fIextra\fP,"
.ti +5n
.B "const char *\fIsubject\fP," int \fIlength\fP, int \fIstartoffset\fP,
.ti +5n
.B int \fIoptions\fP, int *\fIovector\fP, int \fIovecsize\fP);
.PP
.B int pcre_dfa_exec(const pcre *\fIcode\fP, "const pcre_extra *\fIextra\fP,"
.ti +5n
.B "const char *\fIsubject\fP," int \fIlength\fP, int \fIstartoffset\fP,
.ti +5n
.B int \fIoptions\fP, int *\fIovector\fP, int \fIovecsize\fP,
.ti +5n
.B int *\fIworkspace\fP, int \fIwscount\fP);
.
.
.SH "PCRE NATIVE API STRING EXTRACTION FUNCTIONS"
.rs
.sp
.B int pcre_copy_named_substring(const pcre *\fIcode\fP,
.ti +5n
.B const char *\fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, const char *\fIstringname\fP,
.ti +5n
.B char *\fIbuffer\fP, int \fIbuffersize\fP);
.PP
.B int pcre_copy_substring(const char *\fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, int \fIstringnumber\fP, char *\fIbuffer\fP,
.ti +5n
.B int \fIbuffersize\fP);
.PP
.B int pcre_get_named_substring(const pcre *\fIcode\fP,
.ti +5n
.B const char *\fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, const char *\fIstringname\fP,
.ti +5n
.B const char **\fIstringptr\fP);
.PP
.B int pcre_get_stringnumber(const pcre *\fIcode\fP,
.ti +5n
.B const char *\fIname\fP);
.PP
.B int pcre_get_stringtable_entries(const pcre *\fIcode\fP,
.ti +5n
.B const char *\fIname\fP, char **\fIfirst\fP, char **\fIlast\fP);
.PP
.B int pcre_get_substring(const char *\fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, int \fIstringnumber\fP,
.ti +5n
.B const char **\fIstringptr\fP);
.PP
.B int pcre_get_substring_list(const char *\fIsubject\fP,
.ti +5n
.B int *\fIovector\fP, int \fIstringcount\fP, "const char ***\fIlistptr\fP);"
.PP
.B void pcre_free_substring(const char *\fIstringptr\fP);
.PP
.B void pcre_free_substring_list(const char **\fIstringptr\fP);
.
.
.SH "PCRE NATIVE API AUXILIARY FUNCTIONS"
.rs
.sp
.B int pcre_jit_exec(const pcre *\fIcode\fP, "const pcre_extra *\fIextra\fP,"
.ti +5n
.B "const char *\fIsubject\fP," int \fIlength\fP, int \fIstartoffset\fP,
.ti +5n
.B int \fIoptions\fP, int *\fIovector\fP, int \fIovecsize\fP,
.ti +5n
.B pcre_jit_stack *\fIjstack\fP);
.PP
.B pcre_jit_stack *pcre_jit_stack_alloc(int \fIstartsize\fP, int \fImaxsize\fP);
.PP
.B void pcre_jit_stack_free(pcre_jit_stack *\fIstack\fP);
.PP
.B void pcre_assign_jit_stack(pcre_extra *\fIextra\fP,
.ti +5n
.B pcre_jit_callback \fIcallback\fP, void *\fIdata\fP);
.PP
.B const unsigned char *pcre_maketables(void);
.PP
.B int pcre_fullinfo(const pcre *\fIcode\fP, "const pcre_extra *\fIextra\fP,"
.ti +5n
.B int \fIwhat\fP, void *\fIwhere\fP);
.PP
.B int pcre_refcount(pcre *\fIcode\fP, int \fIadjust\fP);
.PP
.B int pcre_config(int \fIwhat\fP, void *\fIwhere\fP);
.PP
.B const char *pcre_version(void);
.PP
.B int pcre_pattern_to_host_byte_order(pcre *\fIcode\fP,
.ti +5n
.B pcre_extra *\fIextra\fP, const unsigned char *\fItables\fP);
.
.
.SH "PCRE NATIVE API INDIRECTED FUNCTIONS"
.rs
.sp
.B void *(*pcre_malloc)(size_t);
.PP
.B void (*pcre_free)(void *);
.PP
.B void *(*pcre_stack_malloc)(size_t);
.PP
.B void (*pcre_stack_free)(void *);
.PP
.B int (*pcre_callout)(pcre_callout_block *);
.
.
.SH "PCRE 8-BIT, 16-BIT, AND 32-BIT LIBRARIES"
.rs
.sp
As well as support fo' 8-bit characta strings, PCRE also supports 16-bit
strings (from release 8.30) n' 32-bit strings (from release 8.32), by means of
two additionizzle libraries. Put ya muthafuckin choppers up if ya feel dis! They can be built as well as, or instead of, the
8-bit library. To avoid too much complication, dis document raps bout the
8-bit versionz of tha functions, wit only occasionizzle references ta tha 16-bit
and 32-bit libraries.
.P
Da 16-bit n' 32-bit functions operate up in tha same way as they 8-bit
counterparts; they just use different data types fo' they arguments and
results, n' they names start wit \fBpcre16_\fP or \fBpcre32_\fP instead of
\fBpcre_\fP. For every last muthafuckin option dat has UTF8 up in its name (for example,
PCRE_UTF8), there be correspondin 16-bit n' 32-bit names wit UTF8 replaced
by UTF16 or UTF32, respectively. This facilitizzle is up in fact just cosmetic; the
16-bit n' 32-bit option names define tha same bit joints.
.P
References ta bytes n' UTF-8 up in dis document should be read as references to
16-bit data units n' UTF-16 when rockin tha 16-bit library, or 32-bit data
units n' UTF-32 when rockin tha 32-bit library, unless specified otherwise.
Mo' detailz of tha specific differences fo' tha 16-bit n' 32-bit libraries
are given up in the
.\" HREF
\fBpcre16\fP
.\"
and
.\" HREF
\fBpcre32\fP
.\"
pages.
.
.
.SH "PCRE API OVERVIEW"
.rs
.sp
PCRE has its own natizzle API, which is busted lyrics bout up in dis document. There are
also some wrapper functions (for tha 8-bit library only) dat correspond ta the
POSIX regular expression API yo, but they do not give access ta all the
functionality. They is busted lyrics bout up in the
.\" HREF
\fBpcreposix\fP
.\"
documentation. I aint talkin' bout chicken n' gravy biatch. Both of these APIs define a set of C function calls fo' realz. A C++
wrapper (again fo' tha 8-bit library only) be also distributed wit PCRE. Well shiiiit, it is
documented up in the
.\" HREF
\fBpcrecpp\fP
.\"
page.
.P
Da natizzle API C function prototypes is defined up in tha header file
\fBpcre.h\fP, n' on Unix-like systems tha (8-bit) library itself is called
\fBlibpcre\fP. Well shiiiit, it can normally be accessed by addin \fB-lpcre\fP ta the
command fo' linkin a application dat uses PCRE. Da header file defines the
macros PCRE_MAJOR n' PCRE_MINOR ta contain tha major n' minor release numbers
for tha library fo' realz. Applications can use these ta include support fo' different
releasez of PCRE.
.P
In a Windows environment, if you wanna statically link a application program
against a non-dll \fBpcre.a\fP file, you must define PCRE_STATIC before
includin \fBpcre.h\fP or \fBpcrecpp.h\fP, cuz otherwise the
\fBpcre_malloc()\fP n' \fBpcre_free()\fP exported functions is ghon be declared
\fB__declspec(dllimport)\fP, wit unwanted thangs up in dis biatch.
.P
Da functions \fBpcre_compile()\fP, \fBpcre_compile2()\fP, \fBpcre_study()\fP,
and \fBpcre_exec()\fP is used fo' compilin n' matchin regular expressions
in a Perl-compatible manner n' shiznit fo' realz. A sample program dat demonstrates tha simplest
way of rockin dem is provided up in tha file called \fIpcredemo.c\fP up in tha PCRE
source distribution. I aint talkin' bout chicken n' gravy biatch fo' realz. A listin of dis program is given up in the
.\" HREF
\fBpcredemo\fP
.\"
documentation, n' the
.\" HREF
\fBpcresample\fP
.\"
documentation raps bout how tha fuck ta compile n' run dat shit.
.P
Just-in-time compila support be a optionizzle feature of PCRE dat can be built
in appropriate hardware environments, n' you can put dat on yo' toast. Well shiiiit, it pimped outly speedz up tha matching
performizzle of nuff patterns. Right back up in yo muthafuckin ass. Simple programs can easily request dat it be
used if available, by settin a option dat is ignored when it is not
relevant. Mo' fucked up programs might need ta make use of tha functions
\fBpcre_jit_stack_alloc()\fP, \fBpcre_jit_stack_free()\fP, and
\fBpcre_assign_jit_stack()\fP up in order ta control tha JIT codez memory usage.
.P
From release 8.32 there be also a gangbangin' finger-lickin' direct intercourse fo' JIT execution, which
gives improved performance. Da JIT-specific functions is discussed up in the
.\" HREF
\fBpcrejit\fP
.\"
documentation.
.P
A second matchin function, \fBpcre_dfa_exec()\fP, which is not
Perl-compatible, be also provided. Y'all KNOW dat shit, muthafucka! This uses a gangbangin' finger-lickin' different algorithm fo' the
matching. Da alternatizzle algorithm findz all possible matches (at a given
point up in tha subject), n' scans tha subject just once (unless there are
lookbehind assertions). But fuck dat shiznit yo, tha word on tha street is dat dis algorithm do not return captured
substrings fo' realz. A description of tha two matchin algorithms n' they advantages
and disadvantages is given up in the
.\" HREF
\fBpcrematching\fP
.\"
documentation.
.P
In addizzle ta tha main compilin n' matchin functions, there be convenience
functions fo' extractin captured substrings from a subject strang dat is
matched by \fBpcre_exec()\fP. They are:
.sp
  \fBpcre_copy_substring()\fP
  \fBpcre_copy_named_substring()\fP
  \fBpcre_get_substring()\fP
  \fBpcre_get_named_substring()\fP
  \fBpcre_get_substring_list()\fP
  \fBpcre_get_stringnumber()\fP
  \fBpcre_get_stringtable_entries()\fP
.sp
\fBpcre_free_substring()\fP n' \fBpcre_free_substring_list()\fP is also
provided, ta free tha memory used fo' extracted strings.
.P
Da function \fBpcre_maketables()\fP is used ta build a set of characta tables
in tha current locale fo' passin ta \fBpcre_compile()\fP, \fBpcre_exec()\fP,
or \fBpcre_dfa_exec()\fP. This be a optionizzle facilitizzle dat is provided for
specialist use. Most commonly, no special tablez is passed, up in which case
internal tablez dat is generated when PCRE is built is used.
.P
Da function \fBpcre_fullinfo()\fP is used ta smoke up shiznit bout a
compiled pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da function \fBpcre_version()\fP returns a pointa ta a
strin containin tha version of PCRE n' its date of release.
.P
Da function \fBpcre_refcount()\fP maintains a reference count up in a thugged-out data block
containin a cold-ass lil compiled pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. This is provided fo' tha benefit of
object-oriented applications.
.P
Da global variablez \fBpcre_malloc\fP n' \fBpcre_free\fP initially contain
the entry pointz of tha standard \fBmalloc()\fP n' \fBfree()\fP functions,
respectively. PCRE calls tha memory pimpment functions via these variables,
so a cold-ass lil callin program can replace dem if it wishes ta intercept tha calls. This
should be done before callin any PCRE functions.
.P
Da global variablez \fBpcre_stack_malloc\fP n' \fBpcre_stack_free\fP is also
indirections ta memory pimpment functions. These special functions is used
only when PCRE is compiled ta use tha heap fo' rememberin data, instead of
recursive function calls, when hustlin tha \fBpcre_exec()\fP function. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See the
.\" HREF
\fBpcrebuild\fP
.\"
documentation fo' detailz of how tha fuck ta do all dis bullshit. Well shiiiit, it aint nuthin but a non-standard way of
buildin PCRE, fo' use up in environments dat have limited stacks. Because of the
greata use of memory pimpment, it runs mo' slowly. Right back up in yo muthafuckin ass. Separate functions are
provided so dat special-purpose external code can be used fo' dis case. When
used, these functions is always called up in a stack-like manner (last obtained,
first freed), n' always fo' memory blockz of tha same size. There be a
rap bout PCREz stack usage up in the
.\" HREF
\fBpcrestack\fP
.\"
documentation.
.P
Da global variable \fBpcre_callout\fP initially gotz nuff NULL. Well shiiiit, it can be set
by tha calla ta a "callout" function, which PCRE will then call at specified
points durin a matchin operation. I aint talkin' bout chicken n' gravy biatch. Details is given up in the
.\" HREF
\fBpcrecallout\fP
.\"
documentation.
.
.
.\" HTML <a name="newlines"></a>
.SH NEWLINES
.rs
.sp
PCRE supports five different conventions fo' indicatin line breaks in
strings: a single CR (carriage return) character, a single LF (linefeed)
character, tha two-characta sequence CRLF, any of tha three preceding, or any
Unicode newline sequence. Da Unicode newline sequences is tha three just
mentioned, plus tha single charactas VT (vertical tab, U+000B), FF (form feed,
U+000C), NEL (next line, U+0085), LS (line separator, U+2028), n' PS
(paragraph separator, U+2029).
.P
Each of tha straight-up original gangsta three conventions is used by at least one operatin system as
its standard newline sequence. When PCRE is built, a thugged-out default can be specified.
Da default default is LF, which is tha Unix standard. Y'all KNOW dat shit, muthafucka! When PCRE is run, the
default can be overridden, either when a pattern is compiled, or when it is
matched.
.P
At compile time, tha newline convention can be specified by tha \fIoptions\fP
argument of \fBpcre_compile()\fP, or it can be specified by special text at the
start of tha pattern itself; dis overrides any other settings. Right back up in yo muthafuckin ass. See the
.\" HREF
\fBpcrepattern\fP
.\"
page fo' detailz of tha special characta sequences.
.P
In tha PCRE documentation tha word "newline" is used ta mean "the characta or
pair of charactas dat indicate a line break". Da chizzle of newline
convention affects tha handlin of tha dot, circumflex, n' dollar
metacharacters, tha handlin of #-comments up in /x mode, and, when CRLF be a
recognized line endin sequence, tha match posizzle advancement fo' a
non-anchored pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. There is mo' detail bout dis up in the
.\" HTML <a href="#execoptions">
.\" </a>
section on \fBpcre_exec()\fP options
.\"
below.
.P
Da chizzle of newline convention do not affect tha interpretation of
the \en or \er escape sequences, nor do it affect what tha fuck \eR matches, which is
controlled up in a similar way yo, but by separate options.
.
.
.SH MULTITHREADING
.rs
.sp
Da PCRE functions can be used up in multi-threadin applications, wit the
proviso dat tha memory pimpment functions pointed ta by \fBpcre_malloc\fP,
\fBpcre_free\fP, \fBpcre_stack_malloc\fP, n' \fBpcre_stack_free\fP, n' the
callout function pointed ta by \fBpcre_callout\fP, is shared by all threads.
.P
Da compiled form of a regular expression aint altered durin matching, so
the same compiled pattern can safely be used by nuff muthafuckin threadz at once.
.P
If tha just-in-time optimization feature is bein used, it needz separate
memory stack areas fo' each thread. Y'all KNOW dat shit, muthafucka! See the
.\" HREF
\fBpcrejit\fP
.\"
documentation fo' mo' details.
.
.
.SH "SAVING PRECOMPILED PATTERNS FOR LATER USE"
.rs
.sp
Da compiled form of a regular expression can be saved n' re-used at a later
time, possibly by a gangbangin' finger-lickin' different program, n' even on a host other than tha one on
which dat shiznit was compiled. Y'all KNOW dat shit, muthafucka! Details is given up in the
.\" HREF
\fBpcreprecompile\fP
.\"
documentation, which includes a thugged-out description of the
\fBpcre_pattern_to_host_byte_order()\fP function. I aint talkin' bout chicken n' gravy biatch. But fuck dat shiznit yo, tha word on tha street is dat compilin a regular
expression wit one version of PCRE fo' use wit a gangbangin' finger-lickin' different version is not
guaranteed ta work n' may cause crashes.
.
.
.SH "CHECKING BUILD-TIME OPTIONS"
.rs
.sp
.B int pcre_config(int \fIwhat\fP, void *\fIwhere\fP);
.PP
Da function \fBpcre_config()\fP make it possible fo' a PCRE client to
discover which optionizzle features done been compiled tha fuck into tha PCRE library. The
.\" HREF
\fBpcrebuild\fP
.\"
documentation has mo' details bout these optionizzle features.
.P
Da first argument fo' \fBpcre_config()\fP be a integer, specifyin which
information is required; tha second argument be a pointa ta a variable into
which tha shiznit is placed. Y'all KNOW dat shit, muthafucka! Da returned value is zero on success, or the
negatizzle error code PCRE_ERROR_BADOPTION if tha value up in tha straight-up original gangsta argument is
not recognized. Y'all KNOW dat shit, muthafucka! Da followin shiznit be available:
.sp
  PCRE_CONFIG_UTF8
.sp
Da output be a integer dat is set ta one if UTF-8 support be available;
otherwise it is set ta zero. This value should normally be given ta tha 8-bit
version of dis function, \fBpcre_config()\fP. If it is given ta tha 16-bit
or 32-bit version of dis function, tha result is PCRE_ERROR_BADOPTION.
.sp
  PCRE_CONFIG_UTF16
.sp
Da output be a integer dat is set ta one if UTF-16 support be available;
otherwise it is set ta zero. This value should normally be given ta tha 16-bit
version of dis function, \fBpcre16_config()\fP. If it is given ta tha 8-bit
or 32-bit version of dis function, tha result is PCRE_ERROR_BADOPTION.
.sp
  PCRE_CONFIG_UTF32
.sp
Da output be a integer dat is set ta one if UTF-32 support be available;
otherwise it is set ta zero. This value should normally be given ta tha 32-bit
version of dis function, \fBpcre32_config()\fP. If it is given ta tha 8-bit
or 16-bit version of dis function, tha result is PCRE_ERROR_BADOPTION.
.sp
  PCRE_CONFIG_UNICODE_PROPERTIES
.sp
Da output be a integer dat is set ta one if support fo' Unicode character
propertizzles be available; otherwise it is set ta zero.
.sp
  PCRE_CONFIG_JIT
.sp
Da output be a integer dat is set ta one if support fo' just-in-time
compilin be available; otherwise it is set ta zero.
.sp
  PCRE_CONFIG_JITTARGET
.sp
Da output be a pointa ta a zero-terminated "const char *" string. If JIT
support be available, tha strang gotz nuff tha name of tha architecture for
which tha JIT compila is configured, fo' example "x86 32bit (lil endian +
unaligned)". If JIT support aint available, tha result is NULL.
.sp
  PCRE_CONFIG_NEWLINE
.sp
Da output be a integer whose value specifies tha default characta sequence
that is recognized as meanin "newline". Da joints dat is supported in
ASCII/Unicode environments are: 10 fo' LF, 13 fo' CR, 3338 fo' CRLF, -2 for
ANYCRLF, n' -1 fo' ANY. In EBCDIC environments, CR, ANYCRLF, n' ANY yield the
same joints, n' you can put dat on yo' toast. But fuck dat shiznit yo, tha word on tha street is dat tha value fo' LF is normally 21, though some EBCDIC
environments use 37. Da correspondin joints fo' CRLF is 3349 n' 3365. The
default should normally correspond ta tha standard sequence fo' yo' operating
system.
.sp
  PCRE_CONFIG_BSR
.sp
Da output be a integer whose value indicates what tha fuck characta sequences tha \eR
escape sequence matches by default fo' realz. A value of 0 means dat \eR matches any
Unicode line endin sequence; a value of 1 means dat \eR matches only CR, LF,
or CRLF. Da default can be overridden when a pattern is compiled or matched.
.sp
  PCRE_CONFIG_LINK_SIZE
.sp
Da output be a integer dat gotz nuff tha number of bytes used fo' internal
linkage up in compiled regular expressions. For tha 8-bit library, tha value can
be 2, 3, or 4. For tha 16-bit library, tha value is either 2 or 4 n' is still
a number of bytes. For tha 32-bit library, tha value is either 2 or 4 n' is
still a fuckin shitload of bytes. Da default value of 2 is sufficient fo' all but the
most massive patterns, since it allows tha compiled pattern ta be up ta 64K in
size. Larger joints allow larger regular expressions ta be compiled, at the
expense of slower matching.
.sp
  PCRE_CONFIG_POSIX_MALLOC_THRESHOLD
.sp
Da output be a integer dat gotz nuff tha threshold above which tha POSIX
interface uses \fBmalloc()\fP fo' output vectors. Further details is given in
the
.\" HREF
\fBpcreposix\fP
.\"
documentation.
.sp
  PCRE_CONFIG_MATCH_LIMIT
.sp
Da output be a long-ass integer dat gives tha default limit fo' tha number of
internal matchin function calls up in a \fBpcre_exec()\fP execution. I aint talkin' bout chicken n' gravy biatch. Further
details is given wit \fBpcre_exec()\fP below.
.sp
  PCRE_CONFIG_MATCH_LIMIT_RECURSION
.sp
Da output be a long-ass integer dat gives tha default limit fo' tha depth of
recursion when callin tha internal matchin function up in a \fBpcre_exec()\fP
execution. I aint talkin' bout chicken n' gravy biatch. Further details is given wit \fBpcre_exec()\fP below.
.sp
  PCRE_CONFIG_STACKRECURSE
.sp
Da output be a integer dat is set ta one if internal recursion when hustlin
\fBpcre_exec()\fP is implemented by recursive function calls dat use tha stack
to remember they state. This is tha usual way dat PCRE is compiled. Y'all KNOW dat shit, muthafucka! The
output is zero if PCRE was compiled ta use blockz of data on tha heap instead
of recursive function calls. In dis case, \fBpcre_stack_malloc\fP and
\fBpcre_stack_free\fP is called ta manage memory blocks on tha heap, thus
avoidin tha use of tha stack.
.
.
.SH "COMPILING A PATTERN"
.rs
.sp
.B pcre *pcre_compile(const char *\fIpattern\fP, int \fIoptions\fP,
.ti +5n
.B const char **\fIerrptr\fP, int *\fIerroffset\fP,
.ti +5n
.B const unsigned char *\fItableptr\fP);
.sp
.B pcre *pcre_compile2(const char *\fIpattern\fP, int \fIoptions\fP,
.ti +5n
.B int *\fIerrorcodeptr\fP,
.ti +5n
.B const char **\fIerrptr\fP, int *\fIerroffset\fP,
.ti +5n
.B const unsigned char *\fItableptr\fP);
.P
Either of tha functions \fBpcre_compile()\fP or \fBpcre_compile2()\fP can be
called ta compile a pattern tha fuck into a internal form. Da only difference between
the two intercourses is dat \fBpcre_compile2()\fP has a additionizzle argument,
\fIerrorcodeptr\fP, via which a numerical error code can be returned. Y'all KNOW dat shit, muthafucka! To avoid
too much repetition, we refer just ta \fBpcre_compile()\fP below yo, but the
information applies equally ta \fBpcre_compile2()\fP.
.P
Da pattern be a C strang terminated by a funky-ass binary zero, n' is passed up in the
\fIpattern\fP argument fo' realz. A pointa ta a single block of memory dat is obtained
via \fBpcre_malloc\fP is returned. Y'all KNOW dat shit, muthafucka! This gotz nuff tha compiled code n' related
data. Da \fBpcre\fP type is defined fo' tha returned block; dis be a typedef
for a structure whose contents is not externally defined. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is up ta the
calla ta free tha memory (via \fBpcre_free\fP) when it is no longer required.
.P
Although tha compiled code of a PCRE regex is relocatable, dat is, it do not
depend on memory location, tha complete \fBpcre\fP data block is not
fully relocatable, cuz it may contain a cold-ass lil copy of tha \fItableptr\fP
argument, which be a address (see below).
.P
Da \fIoptions\fP argument gotz nuff various bit settings dat affect the
compilation. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it should be zero if no options is required. Y'all KNOW dat shit, muthafucka! Da available
options is busted lyrics bout below. Right back up in yo muthafuckin ass. Some of dem (in particular, dem dat are
compatible wit Perl yo, but some others as well) can also be set n' unset from
within tha pattern (see tha detailed description up in the
.\" HREF
\fBpcrepattern\fP
.\"
documentation). For dem options dat can be different up in different parts of
the pattern, tha contentz of tha \fIoptions\fP argument specifies their
settings all up in tha start of compilation n' execution. I aint talkin' bout chicken n' gravy biatch. Da PCRE_ANCHORED,
PCRE_BSR_\fIxxx\fP, PCRE_NEWLINE_\fIxxx\fP, PCRE_NO_UTF8_CHECK, and
PCRE_NO_START_OPTIMIZE options can be set all up in tha time of matchin as well as at
compile time.
.P
If \fIerrptr\fP is NULL, \fBpcre_compile()\fP returns NULL immediately.
Otherwise, if compilation of a pattern fails, \fBpcre_compile()\fP returns
NULL, n' sets tha variable pointed ta by \fIerrptr\fP ta point ta a textual
error message. This be a static strang dat is part of tha library. Yo ass must
not try ta free dat shit. Normally, tha offset from tha start of tha pattern ta the
data unit dat was bein processed when tha error was discovered is placed in
the variable pointed ta by \fIerroffset\fP, which must not be NULL (if it is,
an immediate error is given). But fuck dat shiznit yo, tha word on tha street is dat fo' a invalid UTF-8 or UTF-16 string,
the offset is dat of tha straight-up original gangsta data unit of tha failin character.
.P
Some errors is not detected until tha whole pattern has been scanned; up in these
cases, tha offset passed back is tha length of tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Note dat the
offset is up in data units, not characters, even up in a UTF mode. Well shiiiit, it may sometimes
point tha fuck into tha middle of a UTF-8 or UTF-16 character.
.P
If \fBpcre_compile2()\fP is used instead of \fBpcre_compile()\fP, n' the
\fIerrorcodeptr\fP argument aint NULL, a non-zero error code number is
returned via dis argument up in tha event of a error. Shiiit, dis aint no joke. This is up in addizzle ta the
textual error message. Error codes n' lyrics is listed below.
.P
If tha final argument, \fItableptr\fP, is NULL, PCRE uses a thugged-out default set of
characta tablez dat is built when PCRE is compiled, rockin tha default C
locale. Otherwise, \fItableptr\fP must be a address dat is tha result of a
call ta \fBpcre_maketables()\fP. This value is stored wit tha compiled
pattern, n' used again n' again n' again by \fBpcre_exec()\fP, unless another table pointa is
passed ta dat shit. For mo' rap, peep tha section on locale support below.
.P
This code fragment shows a typical straightforward call ta \fBpcre_compile()\fP:
.sp
  pcre *re;
  const char *error;
  int erroffset;
  re = pcre_compile(
    "^A.*Z",          /* tha pattern */
    0,                /* default options */
    &error,           /* fo' error message */
    &erroffset,       /* fo' error offset */
    NULL);            /* use default characta tablez */
.sp
Da followin names fo' option bits is defined up in tha \fBpcre.h\fP header
file:
.sp
  PCRE_ANCHORED
.sp
If dis bit is set, tha pattern is forced ta be "anchored", dat is, it is
constrained ta match only all up in tha straight-up original gangsta matchin point up in tha strang dat is
bein searched (the "subject string"). This effect can also be  bigged up  by
appropriate constructs up in tha pattern itself, which is tha only way ta do it in
Perl.
.sp
  PCRE_AUTO_CALLOUT
.sp
If dis bit is set, \fBpcre_compile()\fP automatically bangs callout items,
all wit number 255, before each pattern item. For rap of tha callout
facility, peep the
.\" HREF
\fBpcrecallout\fP
.\"
documentation.
.sp
  PCRE_BSR_ANYCRLF
  PCRE_BSR_UNICODE
.sp
These options (which is mutually exclusive) control what tha fuck tha \eR escape
sequence matches. Da chizzle is either ta match only CR, LF, or CRLF, or to
match any Unicode newline sequence. Da default is specified when PCRE is
built. Well shiiiit, it can be overridden from within tha pattern, or by settin a option
when a cold-ass lil compiled pattern is matched.
.sp
  PCRE_CASELESS
.sp
If dis bit is set, lettas up in tha pattern match both upper n' lower case
letters. Well shiiiit, it is equivalent ta Perlz /i option, n' it can be chizzled within a
pattern by a (?i) option setting. In UTF-8 mode, PCRE always understandz the
concept of case fo' charactas whose joints is less than 128, so caseless
matchin be always possible. For charactas wit higher joints, tha concept of
case is supported if PCRE is compiled wit Unicode property support yo, but not
otherwise. If you wanna use caseless matchin fo' charactas 128 n' above,
you must ensure dat PCRE is compiled wit Unicode property support as well as
with UTF-8 support.
.sp
  PCRE_DOLLAR_ENDONLY
.sp
If dis bit is set, a thugged-out dollar metacharacta up in tha pattern matches only at the
end of tha subject string. Without dis option, a thugged-out dollar also matches
immediately before a newline all up in tha end of tha strang (but not before any other
newlines). Da PCRE_DOLLAR_ENDONLY option is ignored if PCRE_MULTILINE is set.
There is no equivalent ta dis option up in Perl, n' no way ta set it within a
pattern.
.sp
  PCRE_DOTALL
.sp
If dis bit is set, a thugged-out dot metacharacta up in tha pattern matches a cold-ass lil characta of
any value, includin one dat indicates a newline. But fuck dat shiznit yo, tha word on tha street is dat it only ever
matches one character, even if newlines is coded as CRLF. Without dis option,
a dot do not match when tha current posizzle be at a newline. This option is
equivalent ta Perlz /s option, n' it can be chizzled within a pattern by a
(?s) option settin fo' realz. A wack class like fuckin [^a] always matches newline
characters, independent of tha settin of dis option.
.sp
  PCRE_DUPNAMES
.sp
If dis bit is set, names used ta identify capturin subpatterns need not be
unique. This can be helpful fo' certain typez of pattern when it is known that
only one instizzle of tha named subpattern can eva be matched. Y'all KNOW dat shit, muthafucka! There is more
detailz of named subpatterns below; peep also the
.\" HREF
\fBpcrepattern\fP
.\"
documentation.
.sp
  PCRE_EXTENDED
.sp
If dis bit is set, white space data charactas up in tha pattern is straight-up
ignored except when escaped or inside a cold-ass lil characta class. White space do not
include tha VT characta (code 11). In addition, charactas between an
unescaped # outside a cold-ass lil characta class n' tha next newline, inclusive, is also
ignored. Y'all KNOW dat shit, muthafucka! This is equivalent ta Perlz /x option, n' it can be chizzled within a
pattern by a (?x) option setting.
.P
Which charactas is interpreted as newlines is controlled by tha options
passed ta \fBpcre_compile()\fP or by a special sequence all up in tha start of the
pattern, as busted lyrics bout up in tha section entitled
.\" HTML <a href="pcrepattern.html#newlines">
.\" </a>
"Newline conventions"
.\"
in tha \fBpcrepattern\fP documentation. I aint talkin' bout chicken n' gravy biatch. Note dat tha end of dis type of
comment be a literal newline sequence up in tha pattern; escape sequences that
happen ta represent a newline do not count.
.P
This option make it possible ta include comments inside fucked up patterns.
Note, however, dat dis applies only ta data characters. White space characters
may never step tha fuck up within special characta sequences up in a pattern, fo' example
within tha sequence (?( dat introduces a cold-ass lil conditionizzle subpattern.
.sp
  PCRE_EXTRA
.sp
This option was invented up in order ta turn on additionizzle functionalitizzle of PCRE
that is incompatible wit Perl yo, but it is currently of straight-up lil use. When
set, any backslash up in a pattern dat is followed by a letta dat has no
special meanin causes a error, thus reservin these combinations fo' future
expansion. I aint talkin' bout chicken n' gravy biatch. By default, as up in Perl, a funky-ass backslash followed by a letta wit no
special meanin is treated as a literal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. (Perl can, however, be persuaded to
give a error fo' this, by hustlin it wit tha -w option.) There is at present
no other features controlled by dis option. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it can also be set by a (?X)
option settin within a pattern.
.sp
  PCRE_FIRSTLINE
.sp
If dis option is set, a unanchored pattern is required ta match before or at
the first newline up in tha subject string, though tha matched text may continue
over tha newline.
.sp
  PCRE_JAVASCRIPT_COMPAT
.sp
If dis option is set, PCREz behaviour is chizzled up in some ways so dat it is
compatible wit JavaScript rather than Perl. Da chizzlez is as bigs up:
.P
(1) A lone closin square bracket up in a pattern causes a cold-ass lil compile-time error,
because dis is illegal up in JavaScript (by default it is treated as a thugged-out data
character). Thus, tha pattern AB]CD becomes illegal when dis option is set.
.P
(2) At run time, a funky-ass back reference ta a unset subpattern crew matches a empty
strin (by default dis causes tha current matchin alternatizzle ta fail) fo' realz. A
pattern like fuckin (\e1)(a) succeedz when dis option is set (assumin it can find
an "a" up in tha subject), whereas it fails by default, fo' Perl compatibility.
.P
(3) \eU matches a upper case "U" character; by default \eU causes a cold-ass lil compile
time error (Perl uses \eU ta upper case subsequent characters).
.P
(4) \eu matches a lower case "u" characta unless it is followed by four
hexadecimal digits, up in which case tha hexadecimal number defines tha code point
to match. By default, \eu causes a cold-ass lil compile time error (Perl uses it ta upper
case tha followin character).
.P
(5) \ex matches a lower case "x" characta unless it is followed by two
hexadecimal digits, up in which case tha hexadecimal number defines tha code point
to match. By default, as up in Perl, a hexadecimal number be always expected after
\ex yo, but it may have zero, one, or two digits (so, fo' example, \exz matches a
binary zero characta followed by z).
.sp
  PCRE_MULTILINE
.sp
By default, fo' tha purposez of matchin "start of line" n' "end of line",
PCRE treats tha subject strang as consistin of a single line of characters,
even if it straight-up gotz nuff newlines. Da "start of line" metacharacta (^)
matches only all up in tha start of tha string, n' tha "end of line" metacharacter
($) matches only all up in tha end of tha string, or before a terminatin newline
(except when PCRE_DOLLAR_ENDONLY is set). Note, however, dat unless
PCRE_DOTALL is set, tha "any character" metacharacta (.) do not match at a
newline. This behaviour (for ^, $, n' dot) is tha same ol' dirty as Perl.
.P
When PCRE_MULTILINE it is set, tha "start of line" n' "end of line" constructs
match immediately followin or immediately before internal newlines up in the
subject string, respectively, as well as all up in tha straight-up start n' end yo, but it ain't no stoppin cause I be still poppin'. This is
equivalent ta Perlz /m option, n' it can be chizzled within a pattern by a
(?m) option setting. If there be no newlines up in a subject string, or no
occurrencez of ^ or $ up in a pattern, settin PCRE_MULTILINE has no effect.
.sp
  PCRE_NEVER_UTF
.sp
This option locks up interpretation of tha pattern as UTF-8 (or UTF-16 or
UTF-32 up in tha 16-bit n' 32-bit libraries). In particular, it prevents the
creator of tha pattern from switchin ta UTF interpretation by startin the
pattern wit (*UTF). This may be useful up in applications dat process patterns
from external sources. Da combination of PCRE_UTF8 n' PCRE_NEVER_UTF also
causes a error.
.sp
  PCRE_NEWLINE_CR
  PCRE_NEWLINE_LF
  PCRE_NEWLINE_CRLF
  PCRE_NEWLINE_ANYCRLF
  PCRE_NEWLINE_ANY
.sp
These options override tha default newline definizzle dat was chosen when PCRE
was built. Right back up in yo muthafuckin ass. Settin tha straight-up original gangsta or tha second specifies dat a newline is
indicated by a single characta (CR or LF, respectively). Right back up in yo muthafuckin ass. Setting
PCRE_NEWLINE_CRLF specifies dat a newline is indicated by tha two-character
CRLF sequence. Right back up in yo muthafuckin ass. Settin PCRE_NEWLINE_ANYCRLF specifies dat any of tha three
precedin sequences should be recognized. Y'all KNOW dat shit, muthafucka! Settin PCRE_NEWLINE_ANY specifies
that any Unicode newline sequence should be recognized.
.P
In a ASCII/Unicode environment, tha Unicode newline sequences is tha three
just mentioned, plus tha single charactas VT (vertical tab, U+000B), FF (form
feed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), n' PS
(paragraph separator, U+2029). For tha 8-bit library, tha last two are
recognized only up in UTF-8 mode.
.P
When PCRE is compiled ta run up in a EBCDIC (mainframe) environment, tha code for
CR is 0x0d, tha same as ASCII. But fuck dat shiznit yo, tha word on tha street is dat tha characta code fo' LF is normally
0x15, though up in some EBCDIC environments 0x25 is used. Y'all KNOW dat shit, muthafucka! Whichever of these is
not LF is made ta correspond ta Unicodez NEL character n' shit. EBCDIC codes is all
less than 256. For mo' details, peep the
.\" HREF
\fBpcrebuild\fP
.\"
documentation.
.P
Da newline settin up in tha options word uses three bits dat is treated
as a number, givin eight possibilities. Put ya muthafuckin choppers up if ya feel dis! Currently only six is used (default
plus tha five joints above). This means dat if you set mo' than one newline
option, tha combination may or may not be sensible. For example,
PCRE_NEWLINE_CR wit PCRE_NEWLINE_LF is equivalent ta PCRE_NEWLINE_CRLF yo, but
other combinations may yield unused numbers n' cause a error.
.P
Da only time dat a line break up in a pattern is specially recognized when
compilin is when PCRE_EXTENDED is set. CR n' LF is white space characters,
and so is ignored up in dis mode fo' realz. Also, a unescaped # outside a cold-ass lil characta class
indicates a cold-ass lil comment dat lasts until afta tha next line break sequence. In
other circumstances, line break sequences up in patterns is treated as literal
data.
.P
Da newline option dat is set at compile time becomes tha default dat is used
for \fBpcre_exec()\fP n' \fBpcre_dfa_exec()\fP yo, but it can be overridden.
.sp
  PCRE_NO_AUTO_CAPTURE
.sp
If dis option is set, it disablez tha use of numbered capturin parentheses in
the pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch fo' realz. Any openin parenthesis dat aint followed by ? behaves as if it
were followed by ?: but named parentheses can still be used fo' capturin (and
they acquire numbers up in tha usual way). There is no equivalent of dis option
in Perl.
.sp
  PCRE_NO_START_OPTIMIZE
.sp
This be a option dat acts at matchin time; dat is, it is straight-up a option
for \fBpcre_exec()\fP or \fBpcre_dfa_exec()\fP. If it is set at compile time,
it is remembered wit tha compiled pattern n' assumed at matchin time. This
is necessary if you wanna use JIT execution, cuz tha JIT compila needs
to know whether or not dis option is set. For details peep tha rap of
PCRE_NO_START_OPTIMIZE
.\" HTML <a href="#execoptions">
.\" </a>
below.
.\"
.sp
  PCRE_UCP
.sp
This option chizzlez tha way PCRE processes \eB, \eb, \eD, \ed, \eS, \es, \eW,
\ew, n' a shitload of tha POSIX characta classes. By default, only ASCII characters
are recognized yo, but if PCRE_UCP is set, Unicode propertizzles is used instead to
classify characters. Mo' details is given up in tha section on
.\" HTML <a href="pcre.html#genericchartypes">
.\" </a>
generic characta types
.\"
in the
.\" HREF
\fBpcrepattern\fP
.\"
page. If you set PCRE_UCP, matchin one of tha shit it affects takes much
longer n' shit. Da option be available only if PCRE has been compiled wit Unicode
property support.
.sp
  PCRE_UNGREEDY
.sp
This option inverts tha "greediness" of tha quantifiers so dat they is not
greedy by default yo, but become greedy if followed by "?". Well shiiiit, it aint compatible
with Perl. Well shiiiit, it can also be set by a (?U) option settin within tha pattern.
.sp
  PCRE_UTF8
.sp
This option causes PCRE ta regard both tha pattern n' tha subject as strings
of UTF-8 charactas instead of single-byte strings. But fuck dat shiznit yo, tha word on tha street is dat it be available
only when PCRE is built ta include UTF support. If not, tha use of dis option
provokes a error. Shiiit, dis aint no joke. Detailz of how tha fuck dis option chizzlez tha behaviour of PCRE are
given up in the
.\" HREF
\fBpcreunicode\fP
.\"
page.
.sp
  PCRE_NO_UTF8_CHECK
.sp
When PCRE_UTF8 is set, tha validitizzle of tha pattern as a UTF-8 strang is
automatically checked. Y'all KNOW dat shit, muthafucka! There be a gangbangin' finger-lickin' rap bout the
.\" HTML <a href="pcreunicode.html#utf8strings">
.\" </a>
validitizzle of UTF-8 strings
.\"
in the
.\" HREF
\fBpcreunicode\fP
.\"
page. If a invalid UTF-8 sequence is found, \fBpcre_compile()\fP returns an
error. Shiiit, dis aint no joke. If you already know dat yo' pattern is valid, n' you wanna skip
this check fo' performizzle reasons, you can set tha PCRE_NO_UTF8_CHECK option.
When it is set, tha effect of passin a invalid UTF-8 strang as a pattern is
undefined. Y'all KNOW dat shit, muthafucka! Well shiiiit, it may cause yo' program ta crash. Note dat dis option can also
be passed ta \fBpcre_exec()\fP n' \fBpcre_dfa_exec()\fP, ta suppress the
validitizzle checkin of subject strings only. If tha same strang is bein matched
many times, tha option can be safely set fo' tha second n' subsequent
matchings ta improve performance.
.
.
.SH "COMPILATION ERROR CODES"
.rs
.sp
Da followin table lists tha error codes than may be returned by
\fBpcre_compile2()\fP, along wit tha error lyrics dat may be returned by
both compilin functions. Note dat error lyrics is always 8-bit ASCII
strings, even up in 16-bit or 32-bit mode fo' realz. As PCRE has pimped, some error codes
have fallen outta use. To avoid mad drama, they aint been re-used.
.sp
   0  no error
   1  \e at end of pattern
   2  \ec at end of pattern
   3  unrecognized characta bigs up \e
   4  numbers outta order up in {} quantifier
   5  number too big-ass up in {} quantifier
   6  missin terminatin ] fo' characta class
   7  invalid escape sequence up in characta class
   8  range outta order up in characta class
   9  not a god damn thang ta repeat
  10  [this code aint up in use]
  11  internal error: unexpected repeat
  12  unrecognized characta afta (? or (?-
  13  POSIX named classes is supported only within a cold-ass lil class
  14  missin )
  15  reference ta non-existent subpattern
  16  erroffset passed as NULL
  17  unknown option bit(s) set
  18  missin ) afta comment
  19  [this code aint up in use]
  20  regular expression is too large
  21  failed ta git memory
  22  unmatched parentheses
  23  internal error: code overflow
  24  unrecognized characta afta (?<
  25  lookbehind assertion aint fixed length
  26  malformed number or name afta (?(
  27  conditionizzle crew gotz nuff mo' than two branches
  28  assertion expected afta (?(
  29  (?R or (?[+-]digits must be followed by )
  30  unknown POSIX class name
  31  POSIX collatin elements is not supported
  32  dis version of PCRE is compiled without UTF support
  33  [this code aint up in use]
  34  characta value up in \ex{...} sequence is too large
  35  invalid condizzle (?(0)
  36  \eC not allowed up in lookbehind assertion
  37  PCRE do not support \eL, \el, \eN{name}, \eU, or \eu
  38  number afta (?C is > 255
  39  closin ) fo' (?C expected
  40  recursive call could loop indefinitely
  41  unrecognized characta afta (?P
  42  syntax error up in subpattern name (missin terminator)
  43  two named subpatterns have tha same name
  44  invalid UTF-8 strang (specifically UTF-8)
  45  support fo' \eP, \ep, n' \eX has not been compiled
  46  malformed \eP or \ep sequence
  47  unknown property name afta \eP or \ep
  48  subpattern name is too long (maximum 32 characters)
  49  too nuff named subpatterns (maximum 10000)
  50  [this code aint up in use]
  51  octal value is pimped outa than \e377 up in 8-bit non-UTF-8 mode
  52  internal error: overran compilin workspace
  53  internal error: previously-checked referenced subpattern
        not found
  54  DEFINE crew gotz nuff mo' than one branch
  55  repeatin a DEFINE crew aint allowed
  56  inconsistent NEWLINE options
  57  \eg aint followed by a funky-ass braced, angle-bracketed, or quoted
        name/number or by a plain number
  58  a numbered reference must not be zero
  59  a argument aint allowed fo' (*ACCEPT), (*FAIL), or (*COMMIT)
  60  (*VERB) not recognized or malformed
  61  number is too big
  62  subpattern name expected
  63  digit expected afta (?+
  64  ] be a invalid data characta up in JavaScript compatibilitizzle mode
  65  different names fo' subpatternz of tha same number are
        not allowed
  66  (*MARK) must have a argument
  67  dis version of PCRE aint compiled wit Unicode property
        support
  68  \ec must be followed by a ASCII character
  69  \ek aint followed by a funky-ass braced, angle-bracketed, or quoted name
  70  internal error: unknown opcode up in find_fixedlength()
  71  \eN aint supported up in a cold-ass lil class
  72  too nuff forward references
  73  disallowed Unicode code point (>= 0xd800 && <= 0xdfff)
  74  invalid UTF-16 strang (specifically UTF-16)
  75  name is too long up in (*MARK), (*PRUNE), (*SKIP), or (*THEN)
  76  characta value up in \eu.... sequence is too large
  77  invalid UTF-32 strang (specifically UTF-32)
.sp
Da numbers 32 n' 10000 up in errors 48 n' 49 is defaults; different joints may
be used if tha limits was chizzled when PCRE was built.
.
.
.\" HTML <a name="studyingapattern"></a>
.SH "STUDYING A PATTERN"
.rs
.sp
.B pcre_extra *pcre_study(const pcre *\fIcode\fP, int \fIoptions\fP
.ti +5n
.B const char **\fIerrptr\fP);
.PP
If a cold-ass lil compiled pattern is goin ta be used nuff muthafuckin times, it is worth spending
more time analyzin it up in order ta speed up tha time taken fo' matching. The
function \fBpcre_study()\fP takes a pointa ta a cold-ass lil compiled pattern as its first
argument. If studyin tha pattern produces additionizzle shiznit dat will
help speed up matching, \fBpcre_study()\fP returns a pointa ta a
\fBpcre_extra\fP block, up in which tha \fIstudy_data\fP field points ta the
resultz of tha study.
.P
Da returned value from \fBpcre_study()\fP can be passed directly to
\fBpcre_exec()\fP or \fBpcre_dfa_exec()\fP. But fuck dat shiznit yo, tha word on tha street is dat a \fBpcre_extra\fP block
also gotz nuff other fieldz dat can be set by tha calla before tha block is
passed; these is busted lyrics about
.\" HTML <a href="#extradata">
.\" </a>
below
.\"
in tha section on matchin a pattern.
.P
If studyin tha pattern do not produce any useful shiznit,
\fBpcre_study()\fP returns NULL by default. In dat circumstance, if the
callin program wants ta pass any of tha other fieldz ta \fBpcre_exec()\fP or
\fBpcre_dfa_exec()\fP, it must set up its own \fBpcre_extra\fP block yo. However,
if \fBpcre_study()\fP is called wit tha PCRE_STUDY_EXTRA_NEEDED option, it
returns a \fBpcre_extra\fP block even if studyin did not find any additional
information. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it may still return NULL, however, if a error occurs in
\fBpcre_study()\fP.
.P
Da second argument of \fBpcre_study()\fP gotz nuff option bits, n' you can put dat on yo' toast. There is three
further options up in addizzle ta PCRE_STUDY_EXTRA_NEEDED:
.sp
  PCRE_STUDY_JIT_COMPILE
  PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE
  PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE
.sp
If any of these is set, n' tha just-in-time compila be available, the
pattern is further compiled tha fuck into machine code dat executes much fasta than
the \fBpcre_exec()\fP interpretizzle matchin function. I aint talkin' bout chicken n' gravy biatch. If tha just-in-time
compila aint available, these options is ignored. Y'all KNOW dat shit, muthafucka! All undefined bits up in the
\fIoptions\fP argument must be zero.
.P
JIT compilation be a heavyweight optimization. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it can take some time for
patterns ta be analyzed, n' fo' one-off matches n' simple patterns the
benefit of fasta execution might be offset by a much slower study time.
Not all patterns can be optimized by tha JIT compila n' shit. For dem dat cannot be
handled, matchin automatically falls back ta tha \fBpcre_exec()\fP
interpreter n' shit. For mo' details, peep the
.\" HREF
\fBpcrejit\fP
.\"
documentation.
.P
Da third argument fo' \fBpcre_study()\fP be a pointa fo' a error message. If
studyin succeedz (even if no data is returned), tha variable it points ta is
set ta NULL. Otherwise it is set ta point ta a textual error message. This be a
static strang dat is part of tha library. Yo ass must not try ta free dat shit. You
should test tha error pointa fo' NULL afta callin \fBpcre_study()\fP, ta be
sure dat it has run successfully.
.P
When yo ass is finished wit a pattern, you can free tha memory used fo' the
study data by callin \fBpcre_free_study()\fP. This function was added ta the
API fo' release 8.20. For earlier versions, tha memory could be freed with
\fBpcre_free()\fP, just like tha pattern itself. This will still work up in cases
where JIT optimization aint used yo, but it be advisable ta chizzle ta tha new
function when convenient.
.P
This be a typical way up in which \fBpcre_study\fP() is used (except dat up in a
real application there should be tests fo' errors):
.sp
  int rc;
  pcre *re;
  pcre_extra *sd;
  re = pcre_compile("pattern", 0, &error, &erroroffset, NULL);
  sd = pcre_study(
    re,             /* result of pcre_compile() */
    0,              /* no options */
    &error);        /* set ta NULL or points ta a message */
  rc = pcre_exec(   /* peep below fo' detailz of pcre_exec() options */
    re, sd, "subject", 7, 0, 0, ovector, 30);
  ...
  pcre_free_study(sd);
  pcre_free(re);
.sp
Studyin a pattern do two thangs: first, a lower bound fo' tha length of
subject strang dat is needed ta match tha pattern is computed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This do not
mean dat there be any stringz of dat length dat match yo, but it do
guarantee dat no shorta strings match. Da value is used ta avoid wasting
time by tryin ta match strings dat is shorta than tha lower bound. Y'all KNOW dat shit, muthafucka! Yo ass can
smoke up tha value up in a cold-ass lil callin program via tha \fBpcre_fullinfo()\fP function.
.P
Studyin a pattern be also useful fo' non-anchored patterns dat aint gots a
single fixed startin character n' shiznit fo' realz. A bitmap of possible startin bytes is
created. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This speedz up findin a posizzle up in tha subject at which ta start
matching. (In 16-bit mode, tha bitmap is used fo' 16-bit joints less than 256.
In 32-bit mode, tha bitmap is used fo' 32-bit joints less than 256.)
.P
These two optimizations apply ta both \fBpcre_exec()\fP and
\fBpcre_dfa_exec()\fP, n' tha shiznit be also used by tha JIT compiler.
Da optimizations can be disabled by settin tha PCRE_NO_START_OPTIMIZE option.
Yo ass might wanna do dis if yo' pattern gotz nuff callouts or (*MARK) n' you
wanna make use of these facilitizzles up in cases where matchin fails.
.P
PCRE_NO_START_OPTIMIZE can be specified at either compile time or execution
time. But fuck dat shiznit yo, tha word on tha street is dat if PCRE_NO_START_OPTIMIZE is passed ta \fBpcre_exec()\fP, (that
is, afta any JIT compilation has happened) JIT execution is disabled. Y'all KNOW dat shit, muthafucka! For JIT
execution ta work wit PCRE_NO_START_OPTIMIZE, tha option must be set at
compile time.
.P
There be a longer rap of PCRE_NO_START_OPTIMIZE
.\" HTML <a href="#execoptions">
.\" </a>
below.
.\"
.
.
.\" HTML <a name="localesupport"></a>
.SH "LOCALE SUPPORT"
.rs
.sp
PCRE handlez caseless matching, n' determines whether charactas is letters,
digits, or whatever, by reference ta a set of tables, indexed by character
value. When hustlin up in UTF-8 mode, dis applies only ta characters
with codes less than 128. By default, higher-valued codes never match escapes
like fuckin \ew or \ed yo, but they can be tested wit \ep if PCRE is built with
Unicode characta property support fo' realz. Alternatively, tha PCRE_UCP option can be
set at compile time; dis causes \ew n' playaz ta use Unicode property
support instead of built-in tables. Da use of localez wit Unicode is
discouraged. Y'all KNOW dat shit, muthafucka! If yo ass is handlin charactas wit codes pimped outa than 128, you
should either use UTF-8 n' Unicode, or use localez yo, but not try ta mix the
two.
.P
PCRE gotz nuff a internal set of tablez dat is used when tha final argument
of \fBpcre_compile()\fP is NULL. These is sufficient fo' nuff applications.
Normally, tha internal tablez recognize only ASCII characters. But fuck dat shiznit yo, tha word on tha street is dat when
PCRE is built, it is possible ta cause tha internal tablez ta be rebuilt up in the
default "C" locale of tha local system, which may cause dem ta be different.
.P
Da internal tablez can always be overridden by tablez supplied by the
application dat calls PCRE. These may be pimped up in a gangbangin' finger-lickin' different locale from
the default fo' realz. As mo' n' mo' applications chizzle ta rockin Unicode, tha need
for dis locale support is sposed ta fuckin take a thugged-out dirtnap away.
.P
External tablez is built by callin tha \fBpcre_maketables()\fP function,
which has no arguments, up in tha relevant locale. Da result can then be passed
to \fBpcre_compile()\fP or \fBpcre_exec()\fP as often as necessary. For
example, ta build n' use tablez dat is appropriate fo' tha French locale
(where accented charactas wit joints pimped outa than 128 is treated as letters),
the followin code could be used:
.sp
  setlocale(LC_CTYPE, "fr_FR");
  tablez = pcre_maketables();
  re = pcre_compile(..., tables);
.sp
Da locale name "fr_FR" is used on Linux n' other Unix-like systems; if you
are rockin Windows, tha name fo' tha French locale is "french".
.P
When \fBpcre_maketables()\fP runs, tha tablez is built up in memory dat is
obtained via \fBpcre_malloc\fP. Well shiiiit, it is tha callerz responsibilitizzle ta ensure
that tha memory containin tha tablez remains available fo' as long as it is
needed.
.P
Da pointa dat is passed ta \fBpcre_compile()\fP is saved wit tha compiled
pattern, n' tha same tablez is used via dis pointa by \fBpcre_study()\fP
and normally also by \fBpcre_exec()\fP. Thus, by default, fo' any single
pattern, compilation, studyin n' matchin all happen up in tha same locale yo, but
different patterns can be compiled up in different locales.
.P
It be possible ta pass a table pointa or NULL (indicatin tha use of the
internal tables) ta \fBpcre_exec()\fP fo' realz. Although not intended fo' dis purpose,
this facilitizzle could be used ta match a pattern up in a gangbangin' finger-lickin' different locale from the
one up in which dat shiznit was compiled. Y'all KNOW dat shit, muthafucka! Passin table pointas at run time is discussed
below up in tha section on matchin a pattern.
.
.
.\" HTML <a name="infoaboutpattern"></a>
.SH "INFORMATION ABOUT A PATTERN"
.rs
.sp
.B int pcre_fullinfo(const pcre *\fIcode\fP, "const pcre_extra *\fIextra\fP,"
.ti +5n
.B int \fIwhat\fP, void *\fIwhere\fP);
.PP
Da \fBpcre_fullinfo()\fP function returns shiznit on some cold-ass lil compiled
pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it replaces tha \fBpcre_info()\fP function, which was removed from the
library at version 8.30, afta mo' than 10 muthafuckin yearz of obsolescence.
.P
Da first argument fo' \fBpcre_fullinfo()\fP be a pointa ta tha compiled
pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da second argument is tha result of \fBpcre_study()\fP, or NULL if
the pattern was not studied. Y'all KNOW dat shit, muthafucka! Da third argument specifies which piece of
information is required, n' tha fourth argument be a pointa ta a variable
to receive tha data. Da yield of tha function is zero fo' success, or one of
the followin wack numbers:
.sp
  PCRE_ERROR_NULL           tha argument \fIcode\fP was NULL
                            tha argument \fIwhere\fP was NULL
  PCRE_ERROR_BADMAGIC       tha "magic number" was not found
  PCRE_ERROR_BADENDIANNESS  tha pattern was compiled wit different
                            endianness
  PCRE_ERROR_BADOPTION      tha value of \fIwhat\fP was invalid
  PCRE_ERROR_UNSET          tha axed field aint set
.sp
Da "magic number" is placed all up in tha start of each compiled pattern as a simple
check against passin a arbitrary memory pointer n' shit. Da endiannizz error can
occur if a cold-ass lil compiled pattern is saved n' reloaded on a gangbangin' finger-lickin' different host yo. Here is
a typical call of \fBpcre_fullinfo()\fP, ta obtain tha length of tha compiled
pattern:
.sp
  int rc;
  size_t length;
  rc = pcre_fullinfo(
    re,               /* result of pcre_compile() */
    sd,               /* result of pcre_study(), or NULL */
    PCRE_INFO_SIZE,   /* what tha fuck is required */
    &length);         /* where ta put tha data */
.sp
Da possible joints fo' tha third argument is defined up in \fBpcre.h\fP, n' are
as bigs up:
.sp
  PCRE_INFO_BACKREFMAX
.sp
Return tha number of tha highest back reference up in tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da fourth
argument should point ta a \fBint\fP variable. Zero is returned if there are
no back references.
.sp
  PCRE_INFO_CAPTURECOUNT
.sp
Return tha number of capturin subpatterns up in tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da fourth argument
should point ta a \fBint\fP variable.
.sp
  PCRE_INFO_DEFAULT_TABLES
.sp
Return a pointa ta tha internal default characta tablez within PCRE. The
fourth argument should point ta a \fBunsigned char *\fP variable. This
information call is provided fo' internal use by tha \fBpcre_study()\fP
function. I aint talkin' bout chicken n' gravy biatch. External callaz can cause PCRE ta use its internal tablez by passing
a NULL table pointer.
.sp
  PCRE_INFO_FIRSTBYTE
.sp
Return shiznit bout tha straight-up original gangsta data unit of any matched string, fo' a
non-anchored pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. (Da name of dis option refers ta tha 8-bit library,
where data units is bytes.) Da fourth argument should point ta a \fBint\fP
variable.
.P
If there be a gangbangin' fixed first value, fo' example, tha letta "c" from a pattern
like fuckin (cat|cow|coyote), its value is returned. Y'all KNOW dat shit, muthafucka! In tha 8-bit library, the
value be always less than 256. In tha 16-bit library tha value can be up to
0xffff. In tha 32-bit library tha value can be up ta 0x10ffff.
.P
If there is no fixed first value, n' if either
.sp
(a) tha pattern was compiled wit tha PCRE_MULTILINE option, n' every last muthafuckin branch
starts wit "^", or
.sp
(b) every last muthafuckin branch of tha pattern starts wit ".*" n' PCRE_DOTALL aint set
(if it was set, tha pattern would be anchored),
.sp
-1 is returned, indicatin dat tha pattern matches only all up in tha start of a
subject strang or afta any newline within tha string. Otherwise -2 is
returned. Y'all KNOW dat shit, muthafucka! For anchored patterns, -2 is returned.
.P
Since fo' tha 32-bit library rockin tha non-UTF-32 mode, dis function is unable
to return tha full 32-bit range of tha character, dis value is deprecated;
instead tha PCRE_INFO_FIRSTCHARACTERFLAGS n' PCRE_INFO_FIRSTCHARACTER joints
should be used.
.sp
  PCRE_INFO_FIRSTTABLE
.sp
If tha pattern was studied, n' dis resulted up in tha construction of a 256-bit
table indicatin a gangbangin' fixed set of joints fo' tha straight-up original gangsta data unit up in any matching
string, a pointa ta tha table is returned. Y'all KNOW dat shit, muthafucka! Otherwise NULL is returned. Y'all KNOW dat shit, muthafucka! The
fourth argument should point ta a \fBunsigned char *\fP variable.
.sp
  PCRE_INFO_HASCRORLF
.sp
Return 1 if tha pattern gotz nuff any explicit matches fo' CR or LF characters,
otherwise 0. Da fourth argument should point ta a \fBint\fP variable fo' realz. An
explicit match is either a literal CR or LF character, or \er or \en.
.sp
  PCRE_INFO_JCHANGED
.sp
Return 1 if tha (?J) or (?-J) option settin is used up in tha pattern, otherwise
0. Da fourth argument should point ta a \fBint\fP variable. (?J) and
(?-J) set n' unset tha local PCRE_DUPNAMES option, respectively.
.sp
  PCRE_INFO_JIT
.sp
Return 1 if tha pattern was studied wit one of tha JIT options, and
just-in-time compilin was successful naaahhmean? Da fourth argument should point ta an
\fBint\fP variable fo' realz. A return value of 0 means dat JIT support aint available
in dis version of PCRE, or dat tha pattern was not studied wit a JIT option,
or dat tha JIT compila could not handle dis particular pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See the
.\" HREF
\fBpcrejit\fP
.\"
documentation fo' detailz of what tha fuck can n' cannot be handled.
.sp
  PCRE_INFO_JITSIZE
.sp
If tha pattern was successfully studied wit a JIT option, return tha size of
the JIT compiled code, otherwise return zero. Da fourth argument should point
to a \fBsize_t\fP variable.
.sp
  PCRE_INFO_LASTLITERAL
.sp
Return tha value of tha rightmost literal data unit dat must exist up in any
matched string, other than at its start, if such a value has been recorded. Y'all KNOW dat shit, muthafucka! The
fourth argument should point ta a \fBint\fP variable. If there is no such
value, -1 is returned. Y'all KNOW dat shit, muthafucka! For anchored patterns, a last literal value is recorded
only if it bigs up suttin' of variable length. For example, fo' tha pattern
/^a\ed+z\ed+/ tha returned value is "z" yo, but fo' /^a\edz\ed/ tha returned value
is -1.
.P
Since fo' tha 32-bit library rockin tha non-UTF-32 mode, dis function is unable
to return tha full 32-bit range of tha character, dis value is deprecated;
instead tha PCRE_INFO_REQUIREDCHARFLAGS n' PCRE_INFO_REQUIREDCHAR joints should
be used.
.sp
  PCRE_INFO_MATCHLIMIT
.sp
If tha pattern set a match limit by includin a item of tha form
(*LIMIT_MATCH=nnnn) all up in tha start, tha value is returned. Y'all KNOW dat shit, muthafucka! Da fourth argument
should point ta a unsigned 32-bit integer n' shit. If no such value has been set, the
call ta \fBpcre_fullinfo()\fP returns tha error PCRE_ERROR_UNSET.
.sp
  PCRE_INFO_MAXLOOKBEHIND
.sp
Return tha number of charactas (NB not data units) up in tha longest lookbehind
assertion up in tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. This shiznit is useful when bustin multi-segment
matchin rockin tha partial matchin facilities. Put ya muthafuckin choppers up if ya feel dis! Note dat tha simple assertions
\eb n' \eB require a one-characta lookbehind. Y'all KNOW dat shit, muthafucka! \eA also registas a
one-characta lookbehind, though it do not straight-up inspect tha previous
character n' shit. This is ta ensure dat at least one characta from tha oldschool segment
is retained when a freshly smoked up segment is processed. Y'all KNOW dat shit, muthafucka! Otherwise, if there be no
lookbehindz up in tha pattern, \eA might match incorrectly all up in tha start of a new
segment.
.sp
  PCRE_INFO_MINLENGTH
.sp
If tha pattern was studied n' a minimum length fo' matchin subject strings
was computed, its value is returned. Y'all KNOW dat shit, muthafucka! Otherwise tha returned value is -1. The
value be a fuckin shitload of characters, which up in UTF mode may be different from the
number of data units, n' you can put dat on yo' toast. Da fourth argument should point ta a \fBint\fP
variable fo' realz. A non-negatizzle value be a lower bound ta tha length of any matching
string. There may not be any stringz of dat length dat do straight-up match yo, but
every strang dat do match be at least dat long.
.sp
  PCRE_INFO_NAMECOUNT
  PCRE_INFO_NAMEENTRYSIZE
  PCRE_INFO_NAMETABLE
.sp
PCRE supports tha use of named as well as numbered capturin parentheses. The
names is just a additionizzle way of identifyin tha parentheses, which still
acquire numbers. Right back up in yo muthafuckin ass. Several convenience functions such as
\fBpcre_get_named_substring()\fP is provided fo' extractin captured
substrings by name. Well shiiiit, it be also possible ta extract tha data directly, by first
convertin tha name ta a number up in order ta access tha erect pointas up in the
output vector (busted lyrics bout wit \fBpcre_exec()\fP below). To do tha conversion,
you need ta use tha name-to-number map, which is busted lyrics bout by these three
values.
.P
Da map consistz of a fuckin shitload of fixed-size entries. Put ya muthafuckin choppers up if ya feel dis! PCRE_INFO_NAMECOUNT gives
the number of entries, n' PCRE_INFO_NAMEENTRYSIZE gives tha size of each
entry; both of these return a \fBint\fP value. Da entry size dependz on the
length of tha longest name. PCRE_INFO_NAMETABLE returns a pointa ta tha first
entry of tha table. This be a pointa ta \fBchar\fP up in tha 8-bit library, where
the first two bytez of each entry is tha number of tha capturin parenthesis,
most dope byte first. In tha 16-bit library, tha pointa points to
16-bit data units, tha straight-up original gangsta of which gotz nuff tha parenthesis number n' shit. In the
32-bit library, tha pointa points ta 32-bit data units, tha straight-up original gangsta of which
gotz nuff tha parenthesis number n' shit. Da rest of tha entry is tha corresponding
name, zero terminated.
.P
Da names is up in alphabetical order n' shit. Duplicate names may step tha fuck up if (?| is used
to create multiple crews wit tha same number, as busted lyrics bout up in the
.\" HTML <a href="pcrepattern.html#dupsubpatternnumber">
.\" </a>
section on duplicate subpattern numbers
.\"
in the
.\" HREF
\fBpcrepattern\fP
.\"
page. Duplicate names fo' subpatterns wit different numbers is permitted only
if PCRE_DUPNAMES is set. In all casez of duplicate names, they step tha fuck up in the
table up in tha order up in which they was found up in tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. In tha absence of
(?| dis is tha order of increasin number; when (?| is used dis is not
necessarily tha case cuz lata subpatterns may have lower numbers.
.P
As a simple example of tha name/number table, consider tha followin pattern
afta compilation by tha 8-bit library (assume PCRE_EXTENDED is set, so white
space - includin newlines - is ignored):
.sp
.\" JOIN
  (?<date> (?<year>(\ed\ed)?\ed\ed) -
  (?<month>\ed\ed) - (?<day>\ed\ed) )
.sp
There is four named subpatterns, so tha table has four entries, n' each entry
in tha table is eight bytes long. Da table be as bigs up, wit non-printing
bytes shows up in hexadecimal, n' undefined bytes shown as ??:
.sp
  00 01 d  a  t  e  00 ??
  00 05 d  a  y  00 ?? ??
  00 04 m  o  n  t  h  00
  00 02 y  e  a  r  00 ??
.sp
When freestylin code ta extract data from named subpatterns rockin the
name-to-number map, remember dat tha length of tha entries is likely ta be
different fo' each compiled pattern.
.sp
  PCRE_INFO_OKPARTIAL
.sp
Return 1 if tha pattern can be used fo' partial matchin with
\fBpcre_exec()\fP, otherwise 0. Da fourth argument should point ta an
\fBint\fP variable. From release 8.00, dis always returns 1, cuz the
restrictions dat previously applied ta partial matchin done been lifted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. The
.\" HREF
\fBpcrepartial\fP
.\"
documentation gives detailz of partial matching.
.sp
  PCRE_INFO_OPTIONS
.sp
Return a cold-ass lil copy of tha options wit which tha pattern was compiled. Y'all KNOW dat shit, muthafucka! Da fourth
argument should point ta a \fBunsigned long int\fP variable. These option bits
are dem specified up in tha call ta \fBpcre_compile()\fP, modified by any
top-level option settings all up in tha start of tha pattern itself. In other lyrics,
they is tha options dat is ghon be up in force when matchin starts, n' you can put dat on yo' toast. For example,
if tha pattern /(?im)abc(?-i)d/ is compiled wit tha PCRE_EXTENDED option, the
result is PCRE_CASELESS, PCRE_MULTILINE, n' PCRE_EXTENDED.
.P
A pattern be automatically anchored by PCRE if all of its top-level
alternatives begin wit one of tha following:
.sp
  ^     unless PCRE_MULTILINE is set
  \eA    always
  \eG    always
.\" JOIN
  .*    if PCRE_DOTALL is set n' there be no back
          references ta tha subpattern up in which .* appears
.sp
For such patterns, tha PCRE_ANCHORED bit is set up in tha options returned by
\fBpcre_fullinfo()\fP.
.sp
  PCRE_INFO_RECURSIONLIMIT
.sp
If tha pattern set a recursion limit by includin a item of tha form
(*LIMIT_RECURSION=nnnn) all up in tha start, tha value is returned. Y'all KNOW dat shit, muthafucka! Da fourth
argument should point ta a unsigned 32-bit integer n' shit. If no such value has been
set, tha call ta \fBpcre_fullinfo()\fP returns tha error PCRE_ERROR_UNSET.
.sp
  PCRE_INFO_SIZE
.sp
Return tha size of tha compiled pattern up in bytes (for all three libraries). The
fourth argument should point ta a \fBsize_t\fP variable. This value do not
include tha size of tha \fBpcre\fP structure dat is returned by
\fBpcre_compile()\fP. Da value dat is passed as tha argument to
\fBpcre_malloc()\fP when \fBpcre_compile()\fP is gettin memory up in which to
place tha compiled data is tha value returned by dis option plus tha size of
the \fBpcre\fP structure. Right back up in yo muthafuckin ass. Studyin a cold-ass lil compiled pattern, wit or without JIT,
does not alta tha value returned by dis option.
.sp
  PCRE_INFO_STUDYSIZE
.sp
Return tha size up in bytes (for all three libraries) of tha data block pointed to
by tha \fIstudy_data\fP field up in a \fBpcre_extra\fP block. If \fBpcre_extra\fP
is NULL, or there is no study data, zero is returned. Y'all KNOW dat shit, muthafucka! Da fourth argument
should point ta a \fBsize_t\fP variable. Da \fIstudy_data\fP field is set by
\fBpcre_study()\fP ta record shiznit dat will speed up matchin (see the
section entitled
.\" HTML <a href="#studyingapattern">
.\" </a>
"Studyin a pattern"
.\"
above). Da format of tha \fIstudy_data\fP block is private yo, but its length
is made available via dis option so dat it can be saved n' restored (see the
.\" HREF
\fBpcreprecompile\fP
.\"
documentation fo' details).
.sp
  PCRE_INFO_FIRSTCHARACTERFLAGS
.sp
Return shiznit bout tha straight-up original gangsta data unit of any matched string, fo' a
non-anchored pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da fourth argument should point ta a \fBint\fP
variable.
.P
If there be a gangbangin' fixed first value, fo' example, tha letta "c" from a pattern
like fuckin (cat|cow|coyote), 1 is returned, n' tha characta value can be
retrieved rockin PCRE_INFO_FIRSTCHARACTER.
.P
If there is no fixed first value, n' if either
.sp
(a) tha pattern was compiled wit tha PCRE_MULTILINE option, n' every last muthafuckin branch
starts wit "^", or
.sp
(b) every last muthafuckin branch of tha pattern starts wit ".*" n' PCRE_DOTALL aint set
(if it was set, tha pattern would be anchored),
.sp
2 is returned, indicatin dat tha pattern matches only all up in tha start of a
subject strang or afta any newline within tha string. Otherwise 0 is
returned. Y'all KNOW dat shit, muthafucka! For anchored patterns, 0 is returned.
.sp
  PCRE_INFO_FIRSTCHARACTER
.sp
Return tha fixed first characta value, if PCRE_INFO_FIRSTCHARACTERFLAGS
returned 1; otherwise returns 0. Da fourth argument should point ta an
\fBuint_t\fP variable.
.P
In tha 8-bit library, tha value be always less than 256. In tha 16-bit library
the value can be up ta 0xffff. In tha 32-bit library up in UTF-32 mode tha value
can be up ta 0x10ffff, n' up ta 0xffffffff when not rockin UTF-32 mode.
.P
If there is no fixed first value, n' if either
.sp
(a) tha pattern was compiled wit tha PCRE_MULTILINE option, n' every last muthafuckin branch
starts wit "^", or
.sp
(b) every last muthafuckin branch of tha pattern starts wit ".*" n' PCRE_DOTALL aint set
(if it was set, tha pattern would be anchored),
.sp
-1 is returned, indicatin dat tha pattern matches only all up in tha start of a
subject strang or afta any newline within tha string. Otherwise -2 is
returned. Y'all KNOW dat shit, muthafucka! For anchored patterns, -2 is returned.
.sp
  PCRE_INFO_REQUIREDCHARFLAGS
.sp
Returns 1 if there be a rightmost literal data unit dat must exist up in any
matched string, other than at its start. Da fourth argument should  point to
an \fBint\fP variable. If there is no such value, 0 is returned. Y'all KNOW dat shit, muthafucka! If returning
1, tha characta value itself can be retrieved rockin PCRE_INFO_REQUIREDCHAR.
.P
For anchored patterns, a last literal value is recorded only if it bigs up
suttin' of variable length. For example, fo' tha pattern /^a\ed+z\ed+/ the
returned value 1 (with "z" returned from PCRE_INFO_REQUIREDCHAR) yo, but for
/^a\edz\ed/ tha returned value is 0.
.sp
  PCRE_INFO_REQUIREDCHAR
.sp
Return tha value of tha rightmost literal data unit dat must exist up in any
matched string, other than at its start, if such a value has been recorded. Y'all KNOW dat shit, muthafucka! The
fourth argument should point ta a \fBuint32_t\fP variable. If there is no such
value, 0 is returned.
.
.
.SH "REFERENCE COUNTS"
.rs
.sp
.B int pcre_refcount(pcre *\fIcode\fP, int \fIadjust\fP);
.PP
Da \fBpcre_refcount()\fP function is used ta maintain a reference count up in the
data block dat gotz nuff a cold-ass lil compiled pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it is provided fo' tha benefit of
applications dat operate up in a object-oriented manner, where different parts
of tha application may be rockin tha same compiled pattern yo, but you wanna free
the block when they is all done.
.P
When a pattern is compiled, tha reference count field is initialized ta zero.
It be chizzled only by callin dis function, whose action is ta add the
\fIadjust\fP value (which may be positizzle or negative) ta dat shit. Da yield of the
function is tha freshly smoked up value. But fuck dat shiznit yo, tha word on tha street is dat tha value of tha count is constrained to
lie between 0 n' 65535, inclusive. If tha freshly smoked up value is outside these limits,
it is forced ta tha appropriate limit value.
.P
Except when it is zero, tha reference count aint erectly preserved if a
pattern is compiled on one host n' then transferred ta a host whose byte-order
is different. (This seems a highly unlikely scenario.)
.
.
.SH "MATCHING A PATTERN: THE TRADITIONAL FUNCTION"
.rs
.sp
.B int pcre_exec(const pcre *\fIcode\fP, "const pcre_extra *\fIextra\fP,"
.ti +5n
.B "const char *\fIsubject\fP," int \fIlength\fP, int \fIstartoffset\fP,
.ti +5n
.B int \fIoptions\fP, int *\fIovector\fP, int \fIovecsize\fP);
.P
Da function \fBpcre_exec()\fP is called ta match a subject strang against a
compiled pattern, which is passed up in tha \fIcode\fP argument. If the
pattern was studied, tha result of tha study should be passed up in the
\fIextra\fP argument. Yo ass can call \fBpcre_exec()\fP wit tha same \fIcode\fP
and \fIextra\fP arguments as nuff times as you like, up in order ta match
different subject strings wit tha same pattern.
.P
This function is tha main matchin facilitizzle of tha library, n' it operates in
a Perl-like manner n' shit. For specialist use there be also a alternatizzle matching
function, which is busted lyrics about
.\" HTML <a href="#dfamatch">
.\" </a>
below
.\"
in tha section bout tha \fBpcre_dfa_exec()\fP function.
.P
In most applications, tha pattern gonna git been compiled (and optionally
studied) up in tha same process dat calls \fBpcre_exec()\fP. But fuck dat shiznit yo, tha word on tha street is dat it is
possible ta save compiled patterns n' study data, n' then use dem later
in different processes, possibly even on different hosts, n' you can put dat on yo' toast. For a gangbangin' finger-lickin' rap
about this, peep the
.\" HREF
\fBpcreprecompile\fP
.\"
documentation.
.P
Here be a example of a simple call ta \fBpcre_exec()\fP:
.sp
  int rc;
  int ovector[30];
  rc = pcre_exec(
    re,             /* result of pcre_compile() */
    NULL,           /* our phat asses didn't study tha pattern */
    "some string",  /* tha subject strang */
    11,             /* tha length of tha subject strang */
    0,              /* start at offset 0 up in tha subject */
    0,              /* default options */
    ovector,        /* vector of integers fo' substrin shiznit */
    30);            /* number of elements (NOT size up in bytes) */
.
.
.\" HTML <a name="extradata"></a>
.SS "Extra data fo' \fBpcre_exec()\fR"
.rs
.sp
If tha \fIextra\fP argument aint NULL, it must point ta a \fBpcre_extra\fP
data block. Da \fBpcre_study()\fP function returns such a funky-ass block (when it
doesn't return NULL) yo, but you can also create one fo' yo ass, n' pass
additionizzle shiznit up in dat shit. Da \fBpcre_extra\fP block gotz nuff tha following
fieldz (not necessarily up in dis order):
.sp
  unsigned long int \fIflags\fP;
  void *\fIstudy_data\fP;
  void *\fIexecutable_jit\fP;
  unsigned long int \fImatch_limit\fP;
  unsigned long int \fImatch_limit_recursion\fP;
  void *\fIcallout_data\fP;
  const unsigned char *\fItables\fP;
  unsigned char **\fImark\fP;
.sp
In tha 16-bit version of dis structure, tha \fImark\fP field has type
"PCRE_UCHAR16 **".
.sp
In tha 32-bit version of dis structure, tha \fImark\fP field has type
"PCRE_UCHAR32 **".
.P
Da \fIflags\fP field is used ta specify which of tha other fieldz is set. The
flag bits are:
.sp
  PCRE_EXTRA_CALLOUT_DATA
  PCRE_EXTRA_EXECUTABLE_JIT
  PCRE_EXTRA_MARK
  PCRE_EXTRA_MATCH_LIMIT
  PCRE_EXTRA_MATCH_LIMIT_RECURSION
  PCRE_EXTRA_STUDY_DATA
  PCRE_EXTRA_TABLES
.sp
Other flag bits should be set ta zero. Da \fIstudy_data\fP field n' sometimes
the \fIexecutable_jit\fP field is set up in tha \fBpcre_extra\fP block dat is
returned by \fBpcre_study()\fP, together wit tha appropriate flag bits, n' you can put dat on yo' toast. You
should not set these yo ass yo, but you may add ta tha block by settin other
fieldz n' they correspondin flag bits.
.P
Da \fImatch_limit\fP field serves up a meanz of preventin PCRE from rockin up a
vast amount of resources when hustlin patterns dat is not goin ta match,
but which gotz a straight-up big-ass number of possibilitizzles up in they search trees. The
funky-ass example be a pattern dat uses nested unlimited repeats.
.P
Internally, \fBpcre_exec()\fP uses a gangbangin' function called \fBmatch()\fP, which it
calls repeatedly (sometimes recursively). Da limit set by \fImatch_limit\fP is
imposed on tha number of times dis function is called durin a match, which
has tha effect of limitin tha amount of backtrackin dat can take place. For
patterns dat is not anchored, tha count restarts from zero fo' each position
in tha subject string.
.P
When \fBpcre_exec()\fP is called wit a pattern dat was successfully studied
with a JIT option, tha way dat tha matchin is executed is entirely different.
But fuck dat shiznit yo, tha word on tha street is dat there is still tha possibilitizzle of runaway matchin dat goes on fo' a
very long time, n' so tha \fImatch_limit\fP value be also used up in dis case
(but up in a gangbangin' finger-lickin' different way) ta limit how tha fuck long tha matchin can continue.
.P
Da default value fo' tha limit can be set when PCRE is built; tha default
default is 10 million, which handlez all but da most thugged-out off tha hook cases. Yo ass can
override tha default by supplin \fBpcre_exec()\fP wit a \fBpcre_extra\fP
block up in which \fImatch_limit\fP is set, n' PCRE_EXTRA_MATCH_LIMIT is set in
the \fIflags\fP field. Y'all KNOW dat shit, muthafucka! If tha limit is exceeded, \fBpcre_exec()\fP returns
PCRE_ERROR_MATCHLIMIT.
.P
A value fo' tha match limit may also be supplied by a item all up in tha start of a
pattern of tha form
.sp
  (*LIMIT_MATCH=d)
.sp
where d be a thugged-out decimal number n' shit. But fuck dat shiznit yo, tha word on tha street is dat such a settin is ignored unless d is
less than tha limit set by tha calla of \fBpcre_exec()\fP or, if no such limit
is set, less than tha default.
.P
Da \fImatch_limit_recursion\fP field is similar ta \fImatch_limit\fP yo, but
instead of limitin tha total number of times dat \fBmatch()\fP is called, it
limits tha depth of recursion. I aint talkin' bout chicken n' gravy biatch. Da recursion depth be a smalla number than the
total number of calls, cuz not all calls ta \fBmatch()\fP is recursive.
This limit iz of use only if it is set smalla than \fImatch_limit\fP.
.P
Limitin tha recursion depth limits tha amount of machine stack dat can be
used, or, when PCRE has been compiled ta use memory on tha heap instead of the
stack, tha amount of heap memory dat can be used. Y'all KNOW dat shit, muthafucka! This limit aint relevant,
and is ignored, when matchin is done rockin JIT compiled code.
.P
Da default value fo' \fImatch_limit_recursion\fP can be set when PCRE is
built; tha default default is tha same ol' dirty value as tha default for
\fImatch_limit\fP. Yo ass can override tha default by supplin \fBpcre_exec()\fP
with a \fBpcre_extra\fP block up in which \fImatch_limit_recursion\fP is set, and
PCRE_EXTRA_MATCH_LIMIT_RECURSION is set up in tha \fIflags\fP field. Y'all KNOW dat shit, muthafucka! If tha limit
is exceeded, \fBpcre_exec()\fP returns PCRE_ERROR_RECURSIONLIMIT.
.P
A value fo' tha recursion limit may also be supplied by a item all up in tha start of
a pattern of tha form
.sp
  (*LIMIT_RECURSION=d)
.sp
where d be a thugged-out decimal number n' shit. But fuck dat shiznit yo, tha word on tha street is dat such a settin is ignored unless d is
less than tha limit set by tha calla of \fBpcre_exec()\fP or, if no such limit
is set, less than tha default.
.P
Da \fIcallout_data\fP field is used up in conjunction wit tha "callout" feature,
and is busted lyrics bout up in the
.\" HREF
\fBpcrecallout\fP
.\"
documentation.
.P
Da \fItables\fP field is used ta pass a cold-ass lil characta tablez pointa to
\fBpcre_exec()\fP; dis overrides tha value dat is stored wit tha compiled
pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch fo' realz. A non-NULL value is stored wit tha compiled pattern only if custom
tablez was supplied ta \fBpcre_compile()\fP via its \fItableptr\fP argument.
If NULL is passed ta \fBpcre_exec()\fP rockin dis mechanism, it forces PCRE's
internal tablez ta be used. Y'all KNOW dat shit, muthafucka! This facilitizzle is helpful when re-usin patterns
that done been saved afta compilin wit a external set of tables, cuz
the external tablez might be at a gangbangin' finger-lickin' different address when \fBpcre_exec()\fP is
called. Y'all KNOW dat shit, muthafucka! See the
.\" HREF
\fBpcreprecompile\fP
.\"
documentation fo' a gangbangin' finger-lickin' rap of savin compiled patterns fo' lata use.
.P
If PCRE_EXTRA_MARK is set up in tha \fIflags\fP field, tha \fImark\fP field must
be set ta point ta a suitable variable. If tha pattern gotz nuff any
backtrackin control verbs like fuckin (*MARK:NAME), n' tha execution endz up with
a name ta pass back, a pointa ta tha name strang (zero terminated) is placed
in tha variable pointed ta by tha \fImark\fP field. Y'all KNOW dat shit, muthafucka! Da names is within the
compiled pattern; if you wish ta retain such a name you must copy it before
freein tha memory of a cold-ass lil compiled pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. If there is no name ta pass back, the
variable pointed ta by tha \fImark\fP field is set ta NULL. For detailz of the
backtrackin control verbs, peep tha section entitled
.\" HTML <a href="pcrepattern#backtrackcontrol">
.\" </a>
"Backtrackin control"
.\"
in the
.\" HREF
\fBpcrepattern\fP
.\"
documentation.
.
.
.\" HTML <a name="execoptions"></a>
.SS "Option bits fo' \fBpcre_exec()\fP"
.rs
.sp
Da unused bitz of tha \fIoptions\fP argument fo' \fBpcre_exec()\fP must be
zero. Da only bits dat may be set is PCRE_ANCHORED, PCRE_NEWLINE_\fIxxx\fP,
PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY, PCRE_NOTEMPTY_ATSTART,
PCRE_NO_START_OPTIMIZE, PCRE_NO_UTF8_CHECK, PCRE_PARTIAL_HARD, and
PCRE_PARTIAL_SOFT.
.P
If tha pattern was successfully studied wit one of tha just-in-time (JIT)
compile options, tha only supported options fo' JIT execution are
PCRE_NO_UTF8_CHECK, PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY,
PCRE_NOTEMPTY_ATSTART, PCRE_PARTIAL_HARD, n' PCRE_PARTIAL_SOFT. If an
unsupported option is used, JIT execution is disabled n' tha normal
interpretizzle code up in \fBpcre_exec()\fP is run.
.sp
  PCRE_ANCHORED
.sp
Da PCRE_ANCHORED option limits \fBpcre_exec()\fP ta matchin all up in tha first
matchin position. I aint talkin' bout chicken n' gravy biatch. If a pattern was compiled wit PCRE_ANCHORED, or turned out
to be anchored by virtue of its contents, it cannot be made unachored at
matchin time.
.sp
  PCRE_BSR_ANYCRLF
  PCRE_BSR_UNICODE
.sp
These options (which is mutually exclusive) control what tha fuck tha \eR escape
sequence matches. Da chizzle is either ta match only CR, LF, or CRLF, or to
match any Unicode newline sequence. These options override tha chizzle dat was
made or defaulted when tha pattern was compiled.
.sp
  PCRE_NEWLINE_CR
  PCRE_NEWLINE_LF
  PCRE_NEWLINE_CRLF
  PCRE_NEWLINE_ANYCRLF
  PCRE_NEWLINE_ANY
.sp
These options override tha newline definizzle dat was chosen or defaulted when
the pattern was compiled. Y'all KNOW dat shit, muthafucka! For details, peep tha description of
\fBpcre_compile()\fP above. Durin matching, tha newline chizzle affects the
behaviour of tha dot, circumflex, n' dollar metacharacters. Well shiiiit, it may also alter
the way tha match posizzle be advanced afta a match failure fo' a unanchored
pattern.
.P
When PCRE_NEWLINE_CRLF, PCRE_NEWLINE_ANYCRLF, or PCRE_NEWLINE_ANY is set, n' a
match attempt fo' a unanchored pattern fails when tha current posizzle be at a
CRLF sequence, n' tha pattern gotz nuff no explicit matches fo' CR or LF
characters, tha match posizzle be advanced by two charactas instead of one, in
other lyrics, ta afta tha CRLF.
.P
Da above rule be a cold-ass lil compromise dat make da most thugged-out common cases work as
expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. For example, if tha pattern is .+A (and tha PCRE_DOTALL option is not
set), it do not match tha strang "\er\enA" cuz, afta failin at the
start, it skips both tha CR n' tha LF before retrying. But fuck dat shiznit yo, tha word on tha street is dat tha pattern
[\er\en]A do match dat string, cuz it gotz nuff a explicit CR or LF
reference, n' so advances only by one characta afta tha straight-up original gangsta failure.
.P
An explicit match fo' CR of LF is either a literal appearizzle of one of them
characters, or one of tha \er or \en escape sequences. Implicit matches such as
[^X] do not count, nor do \es (which includes CR n' LF up in tha characters
that it matches).
.P
Notwithstandin tha above, anomalous effects may still occur when CRLF be a
valid newline sequence n' explicit \er or \en escapes step tha fuck up in tha pattern.
.sp
  PCRE_NOTBOL
.sp
This option specifies dat first characta of tha subject strang aint the
beginnin of a line, so tha circumflex metacharacta should not match before
it. Right back up in yo muthafuckin ass. Settin dis without PCRE_MULTILINE (at compile time) causes circumflex
never ta match. This option affects only tha behaviour of tha circumflex
metacharacter n' shit. Well shiiiit, it do not affect \eA.
.sp
  PCRE_NOTEOL
.sp
This option specifies dat tha end of tha subject strang aint tha end of a
line, so tha dollar metacharacta should not match it nor (except up in multiline
mode) a newline immediately before dat shit. Right back up in yo muthafuckin ass. Settin dis without PCRE_MULTILINE (at
compile time) causes dollar never ta match. This option affects only the
behaviour of tha dollar metacharacter n' shit. Well shiiiit, it do not affect \eZ or \ez.
.sp
  PCRE_NOTEMPTY
.sp
An empty strang aint considered ta be a valid match if dis option is set. If
there is alternatives up in tha pattern, they is tried. Y'all KNOW dat shit, muthafucka! If all tha alternatives
match tha empty string, tha entire match fails. For example, if tha pattern
.sp
  a?b?
.sp
is applied ta a strang not beginnin wit "a" or "b", it matches a empty
strin all up in tha start of tha subject. With PCRE_NOTEMPTY set, dis match is not
valid, so PCRE searches further tha fuck into tha strang fo' occurrencez of "a" or "b".
.sp
  PCRE_NOTEMPTY_ATSTART
.sp
This is like PCRE_NOTEMPTY, except dat a empty strang match dat aint at
the start of tha subject is permitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha pattern be anchored, such a match
can occur only if tha pattern gotz nuff \eK.
.P
Perl has no direct equivalent of PCRE_NOTEMPTY or PCRE_NOTEMPTY_ATSTART yo, but it
does cook up a special case of a pattern match of tha empty strang within its
\fBsplit()\fP function, n' when rockin tha /g modifier n' shit. Well shiiiit, it is possible to
emulate Perlz behaviour afta matchin a null strang by first tryin tha match
again all up in tha same offset wit PCRE_NOTEMPTY_ATSTART n' PCRE_ANCHORED, n' then
if dat fails, by advancin tha startin offset (see below) n' tryin an
ordinary match again. I aint talkin' bout chicken n' gravy biatch. There is some code dat demonstrates how tha fuck ta do dis in
the
.\" HREF
\fBpcredemo\fP
.\"
sample program. In da most thugged-out general case, you gotta check ta peep if the
newline convention recognizes CRLF as a newline, n' if so, n' tha current
characta is CR followed by LF, advizzle tha startin offset by two characters
instead of one.
.sp
  PCRE_NO_START_OPTIMIZE
.sp
There is a fuckin shitload of optimizations dat \fBpcre_exec()\fP uses all up in tha start of
a match, up in order ta speed up tha process. For example, if it is known dat an
unanchored match must start wit a specific character, it searches tha subject
for dat character, n' fails immediately if it cannot find it, without
actually hustlin tha main matchin function. I aint talkin' bout chicken n' gravy biatch. This means dat a special item
like fuckin (*COMMIT) all up in tha start of a pattern aint considered until afta a
suitable startin point fo' tha match has been found. Y'all KNOW dat shit, muthafucka! Also, when callouts or
(*MARK) shit is up in use, these "start-up" optimizations can cause dem ta be
skipped if tha pattern is never straight-up used. Y'all KNOW dat shit, muthafucka! Da start-up optimizations are
in effect a pre-scan of tha subject dat takes place before tha pattern is run.
.P
Da PCRE_NO_START_OPTIMIZE option disablez tha start-up optimizations, possibly
causin performizzle ta suffer yo, but ensurin dat up in cases where tha result is
"no match", tha callouts do occur, n' dat shit like fuckin (*COMMIT) n' (*MARK)
are considered at every last muthafuckin possible startin posizzle up in tha subject string. If
PCRE_NO_START_OPTIMIZE is set at compile time, it cannot be unset at matching
time. Da use of PCRE_NO_START_OPTIMIZE at matchin time (that is, passin it
to \fBpcre_exec()\fP) disablez JIT execution; up in dis thang, matchin is
always done rockin interpretively.
.P
Settin PCRE_NO_START_OPTIMIZE can chizzle tha outcome of a matchin operation.
Consider tha pattern
.sp
  (*COMMIT)ABC
.sp
When dis is compiled, PCRE recordz tha fact dat a match must start wit the
characta "A". Right back up in yo muthafuckin ass. Suppose tha subject strang is "DEFABC". Da start-up
optimization scans along tha subject, findz "A" n' runs tha straight-up original gangsta match
attempt from there, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Da (*COMMIT) item means dat tha pattern must match the
current startin position, which up in dis case, it do. But fuck dat shiznit yo, tha word on tha street is dat if tha same
match is run wit PCRE_NO_START_OPTIMIZE set, tha initial scan along the
subject strang do not happen. I aint talkin' bout chicken n' gravy biatch. Da first match attempt is run startin from
"D" n' when dis fails, (*COMMIT) prevents any further matches bein tried, so
the overall result is "no match". If tha pattern is studied, mo' start-up
optimizations may be used. Y'all KNOW dat shit, muthafucka! For example, a minimum length fo' tha subject may be
recorded. Y'all KNOW dat shit, muthafucka! Consider tha pattern
.sp
  (*MARK:A)(X|Y)
.sp
Da minimum length fo' a match is one character n' shit. If tha subject is "ABC", there
will be attempts ta match "ABC", "BC", "C", n' then finally a empty string.
If tha pattern is studied, tha final attempt do not take place, cuz PCRE
knows dat tha subject is too short, n' so tha (*MARK) is never encountered.
In dis case, studyin tha pattern do not affect tha overall match result,
which is still "no match" yo, but it do affect tha auxiliary shiznit dat is
returned.
.sp
  PCRE_NO_UTF8_CHECK
.sp
When PCRE_UTF8 is set at compile time, tha validitizzle of tha subject as a UTF-8
strin be automatically checked when \fBpcre_exec()\fP is subsequently called.
Da entire strang is checked before any other processin takes place. Da value
of \fIstartoffset\fP be also checked ta ensure dat it points ta tha start of a
UTF-8 character n' shit. There be a gangbangin' finger-lickin' rap bout the
.\" HTML <a href="pcreunicode.html#utf8strings">
.\" </a>
validitizzle of UTF-8 strings
.\"
in the
.\" HREF
\fBpcreunicode\fP
.\"
page. If a invalid sequence of bytes is found, \fBpcre_exec()\fP returns the
error PCRE_ERROR_BADUTF8 or, if PCRE_PARTIAL_HARD is set n' tha problem be a
truncated characta all up in tha end of tha subject, PCRE_ERROR_SHORTUTF8. In both
cases, shiznit bout tha precise nature of tha error may also be returned
(see tha descriptionz of these errors up in tha section entitled \fIError return
values from\fP \fBpcre_exec()\fP
.\" HTML <a href="#errorlist">
.\" </a>
below).
.\"
If \fIstartoffset\fP gotz nuff a value dat do not point ta tha start of a
UTF-8 characta (or ta tha end of tha subject), PCRE_ERROR_BADUTF8_OFFSET is
returned.
.P
If you already know dat yo' subject is valid, n' you wanna skip these
checks fo' performizzle reasons, you can set tha PCRE_NO_UTF8_CHECK option when
callin \fBpcre_exec()\fP. Yo ass might wanna do dis fo' tha second and
subsequent calls ta \fBpcre_exec()\fP if yo ass is makin repeated calls ta find
all tha matches up in a single subject string. But fuck dat shiznit yo, tha word on tha street is dat you should be shizzle that
the value of \fIstartoffset\fP points ta tha start of a cold-ass lil characta (or tha end
of tha subject). When PCRE_NO_UTF8_CHECK is set, tha effect of passin an
invalid strang as a subject or a invalid value of \fIstartoffset\fP is
undefined. Y'all KNOW dat shit, muthafucka! Yo crazy-ass program may crash.
.sp
  PCRE_PARTIAL_HARD
  PCRE_PARTIAL_SOFT
.sp
These options turn on tha partial matchin feature. For backwards
compatibility, PCRE_PARTIAL be a synonym fo' PCRE_PARTIAL_SOFT fo' realz. A partial match
occurs if tha end of tha subject strang is reached successfully yo, but there are
not enough subject charactas ta complete tha match. If dis happens when
PCRE_PARTIAL_SOFT (but not PCRE_PARTIAL_HARD) is set, matchin continues by
testin any remainin alternatives. Only if no complete match can be found is
PCRE_ERROR_PARTIAL returned instead of PCRE_ERROR_NOMATCH. In other lyrics,
PCRE_PARTIAL_SOFT say dat tha calla is prepared ta handle a partial match,
but only if no complete match can be found.
.P
If PCRE_PARTIAL_HARD is set, it overrides PCRE_PARTIAL_SOFT. In dis case, if a
partial match is found, \fBpcre_exec()\fP immediately returns
PCRE_ERROR_PARTIAL, without thankin bout any other alternatives. In other lyrics,
when PCRE_PARTIAL_HARD is set, a partial match is considered ta be more
important dat a alternatizzle complete match.
.P
In both cases, tha portion of tha strang dat was inspected when tha partial
match was found is set as tha straight-up original gangsta matchin string. There be a mo' detailed
rap of partial n' multi-segment matching, wit examples, up in the
.\" HREF
\fBpcrepartial\fP
.\"
documentation.
.
.
.SS "Da strang ta be matched by \fBpcre_exec()\fP"
.rs
.sp
Da subject strang is passed ta \fBpcre_exec()\fP as a pointa in
\fIsubject\fP, a length up in \fIlength\fP, n' a startin offset in
\fIstartoffset\fP. Da units fo' \fIlength\fP n' \fIstartoffset\fP is bytes
for tha 8-bit library, 16-bit data shit fo' tha 16-bit library, n' 32-bit
data shit fo' tha 32-bit library.
.P
If \fIstartoffset\fP is wack or pimped outa than tha length of tha subject,
\fBpcre_exec()\fP returns PCRE_ERROR_BADOFFSET. When tha startin offset is
zero, tha search fo' a match starts all up in tha beginnin of tha subject, n' this
is by far da most thugged-out common case. In UTF-8 or UTF-16 mode, tha offset must point
to tha start of a cold-ass lil character, or tha end of tha subject (in UTF-32 mode, one
data unit equals one character, so all offsets is valid). Unlike tha pattern
string, tha subject may contain binary zeroes.
.P
A non-zero startin offset is useful when searchin fo' another match up in the
same subject by callin \fBpcre_exec()\fP again n' again n' again afta a previous success.
Settin \fIstartoffset\fP differs from just passin over a gangbangin' finger-lickin' dirty-ass shortened strang and
settin PCRE_NOTBOL up in tha case of a pattern dat begins wit any kind of
lookbehind. Y'all KNOW dat shit, muthafucka! For example, consider tha pattern
.sp
  \eBiss\eB
.sp
which findz occurrencez of "iss" up in tha middle of lyrics. (\eB matches only if
the current posizzle up in tha subject aint a word boundary.) When applied to
the strang "Mississipi" tha straight-up original gangsta call ta \fBpcre_exec()\fP findz tha first
occurrence. If \fBpcre_exec()\fP is called again n' again n' again wit just tha remainder of the
subject, namely "issipi", it do not match, cuz \eB be always false at the
start of tha subject, which is deemed ta be a word boundary. But fuck dat shiznit yo, tha word on tha street is dat if
\fBpcre_exec()\fP is passed tha entire strang again yo, but wit \fIstartoffset\fP
set ta 4, it findz tha second occurrence of "iss" cuz it be able ta look
behind tha startin point ta discover dat it is preceded by a letter.
.P
Findin all tha matches up in a subject is tricky when tha pattern can match an
empty string. Well shiiiit, it is possible ta emulate Perlz /g behaviour by first tryin the
match again n' again n' again all up in tha same offset, wit tha PCRE_NOTEMPTY_ATSTART and
PCRE_ANCHORED options, n' then if dat fails, advancin tha startin offset
and tryin a ordinary match again. I aint talkin' bout chicken n' gravy biatch. There is some code dat demonstrates how tha fuck to
do dis up in the
.\" HREF
\fBpcredemo\fP
.\"
sample program. In da most thugged-out general case, you gotta check ta peep if the
newline convention recognizes CRLF as a newline, n' if so, n' tha current
characta is CR followed by LF, advizzle tha startin offset by two characters
instead of one.
.P
If a non-zero startin offset is passed when tha pattern be anchored, one
attempt ta match all up in tha given offset is made. This can only succeed if the
pattern do not require tha match ta be all up in tha start of tha subject.
.
.
.SS "How tha fuck \fBpcre_exec()\fP returns captured substrings"
.rs
.sp
In general, a pattern matches a cold-ass lil certain portion of tha subject, n' in
addition, further substrings from tha subject may be picked up by partz of the
pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Peepin tha usage up in Jeffrey Friedlz book, dis is called
"capturing" up in what tha fuck bigs up, n' tha phrase "capturin subpattern" is used for
a fragment of a pattern dat picks up a substring. PCRE supports nuff muthafuckin other
kindz of parenthesized subpattern dat do not cause substrings ta be captured.
.P
Captured substrings is moonwalked back ta tha calla via a vector of integers whose
address is passed up in \fIovector\fP. Da number of elements up in tha vector is
passed up in \fIovecsize\fP, which must be a non-negatizzle number n' shit. \fBNote\fP: this
argument is NOT tha size of \fIovector\fP up in bytes.
.P
Da first two-thirdz of tha vector is used ta pass back captured substrings,
each substrin rockin a pair of integers. Da remainin third of tha vector is
used as workspace by \fBpcre_exec()\fP while matchin capturin subpatterns,
and aint available fo' passin back shiznit. I aint talkin' bout chicken n' gravy biatch. Da number passed in
\fIovecsize\fP should always be a multiple of three. If it is not, it is
rounded down.
.P
When a match is successful, shiznit bout captured substrings is returned
in pairz of integers, startin all up in tha beginnin of \fIovector\fP, and
continuin up ta two-thirdz of its length at da most thugged-out. Da first element of
each pair is set ta tha offset of tha straight-up original gangsta characta up in a substring, n' the
second is set ta tha offset of tha straight-up original gangsta characta afta tha end of a
substring. These joints is always data unit offsets, even up in UTF mode. They
are byte offsets up in tha 8-bit library, 16-bit data item offsets up in tha 16-bit
library, n' 32-bit data item offsets up in tha 32-bit library. \fBNote\fP: they
are not characta counts.
.P
Da first pair of integers, \fIovector[0]\fP n' \fIovector[1]\fP, identify the
portion of tha subject strang matched by tha entire pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da next pair is
used fo' tha straight-up original gangsta capturin subpattern, n' so on. I aint talkin' bout chicken n' gravy biatch. Da value returned by
\fBpcre_exec()\fP is one mo' than tha highest numbered pair dat has been set.
For example, if two substrings done been captured, tha returned value is 3. If
there is no capturin subpatterns, tha return value from a successful match is
1, indicatin dat just tha straight-up original gangsta pair of offsets has been set.
.P
If a cold-ass lil capturin subpattern is matched repeatedly, it is tha last portion of the
strin dat it matched dat is returned.
.P
If tha vector is too lil' small-ass ta hold all tha captured substrin offsets, it is
used as far as possible (up ta two-thirdz of its length), n' tha function
returns a value of zero. If neither tha actual strang matched nor any captured
substrings iz of interest, \fBpcre_exec()\fP may be called wit \fIovector\fP
passed as NULL n' \fIovecsize\fP as zero. But fuck dat shiznit yo, tha word on tha street is dat if tha pattern gotz nuff
back references n' tha \fIovector\fP aint big-ass enough ta remember tha related
substrings, PCRE has ta git additionizzle memory fo' use durin matching. Thus it
is probably advisable ta supply a \fIovector\fP of reasonable size.
.P
There is some cases where zero is returned (indicatin vector overflow) when
in fact tha vector is exactly tha right size fo' tha final match. For example,
consider tha pattern
.sp
  (a)(?:(b)c|bd)
.sp
If a vector of 6 elements (allowin fo' only 1 captured substring) is given
with subject strang "abd", \fBpcre_exec()\fP will try ta set tha second
captured string, thereby recordin a vector overflow, before failin ta match
"c" n' backin up ta try tha second alternative. Da zero return, however,
does erectly indicate dat tha maximum number of slots (namely 2) have been
filled. Y'all KNOW dat shit, muthafucka! In similar cases where there is temporary overflow yo, but tha final
number of used slots is straight-up less than tha maximum, a non-zero value is
returned.
.P
Da \fBpcre_fullinfo()\fP function can be used ta smoke up how tha fuck nuff capturing
subpatterns there be up in a cold-ass lil compiled pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da smallest size for
\fIovector\fP dat will allow fo' \fIn\fP captured substrings, up in addizzle to
the offsetz of tha substrin matched by tha whole pattern, is (\fIn\fP+1)*3.
.P
It be possible fo' capturin subpattern number \fIn+1\fP ta match some part of
the subject when subpattern \fIn\fP has not been used at all. For example, if
the strang "abc" is matched against tha pattern (a|(z))(bc) tha return from the
function is 4, n' subpatterns 1 n' 3 is matched yo, but 2 is not. When this
happens, both joints up in tha offset pairs correspondin ta unused subpatterns
are set ta -1.
.P
Offset joints dat correspond ta unused subpatterns all up in tha end of the
expression is also set ta -1. For example, if tha strang "abc" is matched
against tha pattern (abc)(x(yz)?)? subpatterns 2 n' 3 is not matched. Y'all KNOW dat shit, muthafucka! The
return from tha function is 2, cuz tha highest used capturin subpattern
number is 1, n' tha offsets fo' for tha second n' third capturin subpatterns
(assumin tha vector is big-ass enough, of course) is set ta -1.
.P
\fBNote\fP: Elements up in tha straight-up original gangsta two-thirdz of \fIovector\fP dat do not
correspond ta capturin parentheses up in tha pattern is never chizzled. Y'all KNOW dat shit, muthafucka! That is,
if a pattern gotz nuff \fIn\fP capturin parentheses, no mo' than
\fIovector[0]\fP ta \fIovector[2n+1]\fP is set by \fBpcre_exec()\fP. Da other
elements (in tha straight-up original gangsta two-thirds) retain whatever joints they previously had.
.P
Some convenience functions is provided fo' extractin tha captured substrings
as separate strings. These is busted lyrics bout below.
.
.
.\" HTML <a name="errorlist"></a>
.SS "Error return joints from \fBpcre_exec()\fP"
.rs
.sp
If \fBpcre_exec()\fP fails, it returns a wack number n' shit. Da followin are
defined up in tha header file:
.sp
  PCRE_ERROR_NOMATCH        (-1)
.sp
Da subject strang did not match tha pattern.
.sp
  PCRE_ERROR_NULL           (-2)
.sp
Either \fIcode\fP or \fIsubject\fP was passed as NULL, or \fIovector\fP was
NULL n' \fIovecsize\fP was not zero.
.sp
  PCRE_ERROR_BADOPTION      (-3)
.sp
An unrecognized bit was set up in tha \fIoptions\fP argument.
.sp
  PCRE_ERROR_BADMAGIC       (-4)
.sp
PCRE stores a 4-byte "magic number" all up in tha start of tha compiled code, ta catch
the case when it is passed a junk pointa n' ta detect when a pattern dat was
compiled up in a environment of one endiannizz is run up in a environment wit the
other endianness. This is tha error dat PCRE gives when tha magic number is
not present.
.sp
  PCRE_ERROR_UNKNOWN_OPCODE (-5)
.sp
While hustlin tha pattern match, a unknown item was encountered up in the
compiled pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. This error could be caused by a funky-ass bug up in PCRE or by overwriting
of tha compiled pattern.
.sp
  PCRE_ERROR_NOMEMORY       (-6)
.sp
If a pattern gotz nuff back references yo, but tha \fIovector\fP dat is passed to
\fBpcre_exec()\fP aint big-ass enough ta remember tha referenced substrings, PCRE
gets a funky-ass block of memory all up in tha start of matchin ta use fo' dis purpose. If the
call via \fBpcre_malloc()\fP fails, dis error is given. I aint talkin' bout chicken n' gravy biatch. Da memory is
automatically freed all up in tha end of matching.
.P
This error be also given if \fBpcre_stack_malloc()\fP fails in
\fBpcre_exec()\fP. This can happen only when PCRE has been compiled with
\fB--disable-stack-for-recursion\fP.
.sp
  PCRE_ERROR_NOSUBSTRING    (-7)
.sp
This error is used by tha \fBpcre_copy_substring()\fP,
\fBpcre_get_substring()\fP, n' \fBpcre_get_substring_list()\fP functions (see
below). Well shiiiit, it is never returned by \fBpcre_exec()\fP.
.sp
  PCRE_ERROR_MATCHLIMIT     (-8)
.sp
Da backtrackin limit, as specified by tha \fImatch_limit\fP field up in a
\fBpcre_extra\fP structure (or defaulted) was reached. Y'all KNOW dat shit, muthafucka! See tha description
above.
.sp
  PCRE_ERROR_CALLOUT        (-9)
.sp
This error is never generated by \fBpcre_exec()\fP itself. Well shiiiit, it is provided for
use by callout functions dat wanna yield a gangbangin' finger-lickin' distinctizzle error code. Right back up in yo muthafuckin ass. See the
.\" HREF
\fBpcrecallout\fP
.\"
documentation fo' details.
.sp
  PCRE_ERROR_BADUTF8        (-10)
.sp
A strang dat gotz nuff a invalid UTF-8 byte sequence was passed as a subject,
and tha PCRE_NO_UTF8_CHECK option was not set. If tha size of tha output vector
(\fIovecsize\fP) be at least 2, tha byte offset ta tha start of tha the invalid
UTF-8 characta is placed up in tha straight-up original gangsta element, n' a reason code is placed in
the second element. Da reason codes is listed up in the
.\" HTML <a href="#badutf8reasons">
.\" </a>
followin section.
.\"
For backward compatibility, if PCRE_PARTIAL_HARD is set n' tha problem be a
truncated UTF-8 characta all up in tha end of tha subject (reason codes 1 ta 5),
PCRE_ERROR_SHORTUTF8 is returned instead of PCRE_ERROR_BADUTF8.
.sp
  PCRE_ERROR_BADUTF8_OFFSET (-11)
.sp
Da UTF-8 byte sequence dat was passed as a subject was checked n' found to
be valid (the PCRE_NO_UTF8_CHECK option was not set) yo, but tha value of
\fIstartoffset\fP did not point ta tha beginnin of a UTF-8 characta or the
end of tha subject.
.sp
  PCRE_ERROR_PARTIAL        (-12)
.sp
Da subject strang did not match yo, but it did match partially. Right back up in yo muthafuckin ass. See the
.\" HREF
\fBpcrepartial\fP
.\"
documentation fo' detailz of partial matching.
.sp
  PCRE_ERROR_BADPARTIAL     (-13)
.sp
This code is no longer up in use. Dat shiznit was formerly returned when tha PCRE_PARTIAL
option was used wit a cold-ass lil compiled pattern containin shit dat was not
supported fo' partial matching. From release 8.00 onwards, there be no
restrictions on partial matching.
.sp
  PCRE_ERROR_INTERNAL       (-14)
.sp
An unexpected internal error has occurred. Y'all KNOW dat shit, muthafucka! This error could be caused by a funky-ass bug
in PCRE or by overwritin of tha compiled pattern.
.sp
  PCRE_ERROR_BADCOUNT       (-15)
.sp
This error is given if tha value of tha \fIovecsize\fP argument is negative.
.sp
  PCRE_ERROR_RECURSIONLIMIT (-21)
.sp
Da internal recursion limit, as specified by tha \fImatch_limit_recursion\fP
field up in a \fBpcre_extra\fP structure (or defaulted) was reached. Y'all KNOW dat shit, muthafucka! See the
description above.
.sp
  PCRE_ERROR_BADNEWLINE     (-23)
.sp
An invalid combination of PCRE_NEWLINE_\fIxxx\fP options was given.
.sp
  PCRE_ERROR_BADOFFSET      (-24)
.sp
Da value of \fIstartoffset\fP was wack or pimped outa than tha length of the
subject, dat is, tha value up in \fIlength\fP.
.sp
  PCRE_ERROR_SHORTUTF8      (-25)
.sp
This error is returned instead of PCRE_ERROR_BADUTF8 when tha subject string
endz wit a truncated UTF-8 characta n' tha PCRE_PARTIAL_HARD option is set.
Hype bout tha failure is returned as fo' PCRE_ERROR_BADUTF8. Well shiiiit, it is in
fact sufficient ta detect dis case yo, but dis special error code for
PCRE_PARTIAL_HARD precedes tha implementation of returned shiznit; it is
retained fo' backwardz compatibility.
.sp
  PCRE_ERROR_RECURSELOOP    (-26)
.sp
This error is returned when \fBpcre_exec()\fP detects a recursion loop within
the pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Specifically, it means dat either tha whole pattern or a
subpattern has been called recursively fo' tha second time all up in tha same position
in tha subject string. Right back up in yo muthafuckin ass. Some simple patterns dat might do dis is detected and
faulted at compile time yo, but mo' fucked up cases, up in particular mutual
recursions between two different subpatterns, cannot be detected until run
time.
.sp
  PCRE_ERROR_JIT_STACKLIMIT (-27)
.sp
This error is returned when a pattern dat was successfully studied rockin a
JIT compile option is bein matched yo, but tha memory available fo' the
just-in-time processin stack aint big-ass enough cause I gots dem finger-lickin' chickens wit tha siz-auce. Right back up in yo muthafuckin ass. See the
.\" HREF
\fBpcrejit\fP
.\"
documentation fo' mo' details.
.sp
  PCRE_ERROR_BADMODE        (-28)
.sp
This error is given if a pattern dat was compiled by tha 8-bit library is
passed ta a 16-bit or 32-bit library function, or vice versa.
.sp
  PCRE_ERROR_BADENDIANNESS  (-29)
.sp
This error is given if a pattern dat was compiled n' saved is reloaded on a
host wit different endianness. Da utilitizzle function
\fBpcre_pattern_to_host_byte_order()\fP can be used ta convert such a pattern
so dat it runs on tha freshly smoked up host.
.sp
  PCRE_ERROR_JIT_BADOPTION
.sp
This error is returned when a pattern dat was successfully studied rockin a JIT
compile option is bein matched yo, but tha matchin mode (partial or complete
match) do not correspond ta any JIT compilation mode. When tha JIT fast path
function is used, dis error may be also given fo' invalid options. Right back up in yo muthafuckin ass. See the
.\" HREF
\fBpcrejit\fP
.\"
documentation fo' mo' details.
.sp
  PCRE_ERROR_BADLENGTH      (-32)
.sp
This error is given if \fBpcre_exec()\fP is called wit a wack value for
the \fIlength\fP argument.
.P
Error numbers -16 ta -20, -22, n' 30 is not used by \fBpcre_exec()\fP.
.
.
.\" HTML <a name="badutf8reasons"></a>
.SS "Reason codes fo' invalid UTF-8 strings"
.rs
.sp
This section applies only ta tha 8-bit library. Da correspondin shiznit
for tha 16-bit n' 32-bit libraries is given up in the
.\" HREF
\fBpcre16\fP
.\"
and
.\" HREF
\fBpcre32\fP
.\"
pages.
.P
When \fBpcre_exec()\fP returns either PCRE_ERROR_BADUTF8 or
PCRE_ERROR_SHORTUTF8, n' tha size of tha output vector (\fIovecsize\fP) be at
least 2, tha offset of tha start of tha invalid UTF-8 characta is placed in
the first output vector element (\fIovector[0]\fP) n' a reason code is placed
in tha second element (\fIovector[1]\fP). Da reason codes is given names in
the \fBpcre.h\fP header file:
.sp
  PCRE_UTF8_ERR1
  PCRE_UTF8_ERR2
  PCRE_UTF8_ERR3
  PCRE_UTF8_ERR4
  PCRE_UTF8_ERR5
.sp
Da strang endz wit a truncated UTF-8 character; tha code specifies how tha fuck many
bytes is missin (1 ta 5) fo' realz. Although RFC 3629 restricts UTF-8 charactas ta be
no longer than 4 bytes, tha encodin scheme (originally defined by RFC 2279)
allows fo' up ta 6 bytes, n' dis is checked first; hence tha possibilitizzle of
4 or 5 missin bytes.
.sp
  PCRE_UTF8_ERR6
  PCRE_UTF8_ERR7
  PCRE_UTF8_ERR8
  PCRE_UTF8_ERR9
  PCRE_UTF8_ERR10
.sp
Da two most dope bitz of tha 2nd, 3rd, 4th, 5th, or 6th byte of the
characta aint gots tha binary value 0b10 (that is, either da most thugged-out
significant bit is 0, or tha next bit is 1).
.sp
  PCRE_UTF8_ERR11
  PCRE_UTF8_ERR12
.sp
A characta dat is valid by tha RFC 2279 rulez is either 5 or 6 bytes long;
these code points is excluded by RFC 3629.
.sp
  PCRE_UTF8_ERR13
.sp
A 4-byte characta has a value pimped outa than 0x10fff; these code points are
excluded by RFC 3629.
.sp
  PCRE_UTF8_ERR14
.sp
A 3-byte characta has a value up in tha range 0xd800 ta 0xdfff; dis range of
code points is reserved by RFC 3629 fo' use wit UTF-16, n' so is excluded
from UTF-8.
.sp
  PCRE_UTF8_ERR15
  PCRE_UTF8_ERR16
  PCRE_UTF8_ERR17
  PCRE_UTF8_ERR18
  PCRE_UTF8_ERR19
.sp
A 2-, 3-, 4-, 5-, or 6-byte characta is "overlong", dat is, it codes fo' a
value dat can be represented by fewer bytes, which is invalid. Y'all KNOW dat shit, muthafucka! For example,
the two bytes 0xc0, 0xae give tha value 0x2e, whose erect codin uses just
one byte.
.sp
  PCRE_UTF8_ERR20
.sp
Da two most dope bitz of tha straight-up original gangsta byte of a cold-ass lil characta have tha binary
value 0b10 (that is, da most thugged-out dope bit is 1 n' tha second is 0). Right back up in yo muthafuckin ass. Such a
byte can only validly occur as tha second or subsequent byte of a multi-byte
character.
.sp
  PCRE_UTF8_ERR21
.sp
Da first byte of a cold-ass lil characta has tha value 0xfe or 0xff. These joints can
never occur up in a valid UTF-8 string.
.sp
  PCRE_UTF8_ERR22
.sp
This error code was formerly used when tha presence of a so-called
"non-character" caused a error. Shiiit, dis aint no joke. Unicode corrigendum #9 make it clear that
such charactas should not cause a strang ta be rejected, n' so dis code is
no longer up in use n' is never returned.
.
.
.SH "EXTRACTING CAPTURED SUBSTRINGS BY NUMBER"
.rs
.sp
.B int pcre_copy_substring(const char *\fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, int \fIstringnumber\fP, char *\fIbuffer\fP,
.ti +5n
.B int \fIbuffersize\fP);
.PP
.B int pcre_get_substring(const char *\fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, int \fIstringnumber\fP,
.ti +5n
.B const char **\fIstringptr\fP);
.PP
.B int pcre_get_substring_list(const char *\fIsubject\fP,
.ti +5n
.B int *\fIovector\fP, int \fIstringcount\fP, "const char ***\fIlistptr\fP);"
.PP
Captured substrings can be accessed directly by rockin tha offsets returned by
\fBpcre_exec()\fP up in \fIovector\fP. For convenience, tha functions
\fBpcre_copy_substring()\fP, \fBpcre_get_substring()\fP, and
\fBpcre_get_substring_list()\fP is provided fo' extractin captured substrings
as new, separate, zero-terminated strings. These functions identify substrings
by number n' shit. Da next section raps bout functions fo' extractin named
substrings.
.P
A substrin dat gotz nuff a funky-ass binary zero is erectly extracted n' has a
further zero added on tha end yo, but tha result is not, of course, a C string.
But fuck dat shiznit yo, tha word on tha street is dat you can process such a strang by referrin ta tha length dat is
returned by \fBpcre_copy_substring()\fP n' \fBpcre_get_substring()\fP.
Unfortunately, tha intercourse ta \fBpcre_get_substring_list()\fP aint adequate
for handlin strings containin binary zeros, cuz tha end of tha final
strin aint independently indicated.
.P
Da first three arguments is tha same fo' all three of these functions:
\fIsubject\fP is tha subject strang dat has just been successfully matched,
\fIovector\fP be a pointa ta tha vector of integer offsets dat was passed to
\fBpcre_exec()\fP, n' \fIstringcount\fP is tha number of substrings dat were
captured by tha match, includin tha substrin dat matched tha entire regular
expression. I aint talkin' bout chicken n' gravy biatch. This is tha value returned by \fBpcre_exec()\fP if it is pimped outer
than zero. If \fBpcre_exec()\fP returned zero, indicatin dat it ran up of
space up in \fIovector\fP, tha value passed as \fIstringcount\fP should be the
number of elements up in tha vector divided by three.
.P
Da functions \fBpcre_copy_substring()\fP n' \fBpcre_get_substring()\fP
extract a single substring, whose number is given as \fIstringnumber\fP fo' realz. A
value of zero extracts tha substrin dat matched tha entire pattern, whereas
higher joints extract tha captured substrings. For \fBpcre_copy_substring()\fP,
the strang is placed up in \fIbuffer\fP, whose length is given by
\fIbuffersize\fP, while fo' \fBpcre_get_substring()\fP a freshly smoked up block of memory is
obtained via \fBpcre_malloc\fP, n' its address is returned via
\fIstringptr\fP. Da yield of tha function is tha length of tha string, not
includin tha terminatin zero, or one of these error codes:
.sp
  PCRE_ERROR_NOMEMORY       (-6)
.sp
Da buffer was too lil' small-ass fo' \fBpcre_copy_substring()\fP, or tha attempt ta get
memory failed fo' \fBpcre_get_substring()\fP.
.sp
  PCRE_ERROR_NOSUBSTRING    (-7)
.sp
There is no substrin whose number is \fIstringnumber\fP.
.P
Da \fBpcre_get_substring_list()\fP function extracts all available substrings
and buildz a list of pointas ta em fo' realz. All dis is done up in a single block of
memory dat is obtained via \fBpcre_malloc\fP. Da address of tha memory block
is returned via \fIlistptr\fP, which be also tha start of tha list of string
pointers. Da end of tha list is marked by a NULL pointer n' shit. Da yield of the
function is zero if all went well, or tha error code
.sp
  PCRE_ERROR_NOMEMORY       (-6)
.sp
if tha attempt ta git tha memory block failed.
.P
When any of these functions encounta a substrin dat is unset, which can
happen when capturin subpattern number \fIn+1\fP matches some part of the
subject yo, but subpattern \fIn\fP has not been used at all, they return a empty
string. This can be distinguished from a genuine zero-length substrin by
inspectin tha appropriate offset up in \fIovector\fP, which is wack fo' unset
substrings.
.P
Da two convenience functions \fBpcre_free_substring()\fP and
\fBpcre_free_substring_list()\fP can be used ta free tha memory returned by
a previous call of \fBpcre_get_substring()\fP or
\fBpcre_get_substring_list()\fP, respectively. They do not a god damn thang mo' than call
the function pointed ta by \fBpcre_free\fP, which of course could be called
directly from a C program. But fuck dat shiznit yo, tha word on tha street is dat PCRE is used up in some thangs where it is
linked via a special intercourse ta another programmin language dat cannot use
\fBpcre_free\fP directly; it is fo' these cases dat tha functions are
provided.
.
.
.SH "EXTRACTING CAPTURED SUBSTRINGS BY NAME"
.rs
.sp
.B int pcre_get_stringnumber(const pcre *\fIcode\fP,
.ti +5n
.B const char *\fIname\fP);
.PP
.B int pcre_copy_named_substring(const pcre *\fIcode\fP,
.ti +5n
.B const char *\fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, const char *\fIstringname\fP,
.ti +5n
.B char *\fIbuffer\fP, int \fIbuffersize\fP);
.PP
.B int pcre_get_named_substring(const pcre *\fIcode\fP,
.ti +5n
.B const char *\fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, const char *\fIstringname\fP,
.ti +5n
.B const char **\fIstringptr\fP);
.PP
To extract a substrin by name, you first gotta find associated number.
For example, fo' dis pattern
.sp
  (a+)b(?<xxx>\ed+)...
.sp
the number of tha subpattern called "xxx" is 2. If tha name is known ta be
unique (PCRE_DUPNAMES was not set), you can find tha number from tha name by
callin \fBpcre_get_stringnumber()\fP. Da first argument is tha compiled
pattern, n' tha second is tha name. Da yield of tha function is the
subpattern number, or PCRE_ERROR_NOSUBSTRING (-7) if there is no subpattern of
that name.
.P
Given tha number, you can extract tha substrin directly, or use one of the
functions busted lyrics bout up in tha previous section. I aint talkin' bout chicken n' gravy biatch. For convenience, there be also
two functions dat do tha whole thang.
.P
Most of tha argumentz of \fBpcre_copy_named_substring()\fP and
\fBpcre_get_named_substring()\fP is tha same as dem fo' tha similarly named
functions dat extract by number n' shiznit fo' realz. As these is busted lyrics bout up in tha previous
section, they is not re-busted lyrics bout here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. There is just two differences:
.P
First, instead of a substrin number, a substrin name is given. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Second, there
is a extra argument, given all up in tha start, which be a pointa ta tha compiled
pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. This is needed up in order ta bust access ta tha name-to-number
translation table.
.P
These functions call \fBpcre_get_stringnumber()\fP, n' if it succeeds, they
then call \fBpcre_copy_substring()\fP or \fBpcre_get_substring()\fP, as
appropriate. \fBNOTE:\fP If PCRE_DUPNAMES is set n' there be duplicate names,
the behaviour may not be what tha fuck you want (see tha next section).
.P
\fBWarning:\fP If tha pattern uses tha (?| feature ta set up multiple
subpatterns wit tha same number, as busted lyrics bout up in the
.\" HTML <a href="pcrepattern.html#dupsubpatternnumber">
.\" </a>
section on duplicate subpattern numbers
.\"
in the
.\" HREF
\fBpcrepattern\fP
.\"
page, you cannot use names ta distinguish tha different subpatterns, cuz
names is not included up in tha compiled code. Da matchin process uses only
numbers. For dis reason, tha use of different names fo' subpatternz of the
same number causes a error at compile time.
.
.
.SH "DUPLICATE SUBPATTERN NAMES"
.rs
.sp
.B int pcre_get_stringtable_entries(const pcre *\fIcode\fP,
.ti +5n
.B const char *\fIname\fP, char **\fIfirst\fP, char **\fIlast\fP);
.PP
When a pattern is compiled wit tha PCRE_DUPNAMES option, names fo' subpatterns
are not required ta be unique. (Duplicate names is always allowed for
subpatterns wit tha same number, pimped by rockin tha (?| feature. Git tha fuck outta mah grill wit dat bullshit, if
such subpatterns is named, they is required ta use tha same names.)
.P
Normally, patterns wit duplicate names is such dat up in any one match, only
one of tha named subpatterns participates fo' realz. An example is shown up in the
.\" HREF
\fBpcrepattern\fP
.\"
documentation.
.P
When duplicates is present, \fBpcre_copy_named_substring()\fP and
\fBpcre_get_named_substring()\fP return tha straight-up original gangsta substrin correspondin to
the given name dat is set. If none is set, PCRE_ERROR_NOSUBSTRING (-7) is
returned; no data is returned. Y'all KNOW dat shit, muthafucka! Da \fBpcre_get_stringnumber()\fP function
returns one of tha numbers dat is associated wit tha name yo, but it is not
defined which it is.
.P
If you wanna git full detailz of all captured substrings fo' a given name,
you must use tha \fBpcre_get_stringtable_entries()\fP function. I aint talkin' bout chicken n' gravy biatch. Da first
argument is tha compiled pattern, n' tha second is tha name. Da third and
fourth is pointas ta variablez which is updated by tha function. I aint talkin' bout chicken n' gravy biatch fo' realz. Afta it
has run, they point ta tha straight-up original gangsta n' last entries up in tha name-to-number table
for tha given name. Da function itself returns tha length of each entry, or
PCRE_ERROR_NOSUBSTRING (-7) if there be none. Da format of tha table is
busted lyrics bout above up in tha section entitled \fIHype on some pattern\fP
.\" HTML <a href="#infoaboutpattern">
.\" </a>
above.
.\"
Given all tha relevant entries fo' tha name, you can extract each of their
numbers, n' hence tha captured data, if any.
.
.
.SH "FINDING ALL POSSIBLE MATCHES"
.rs
.sp
Da traditionizzle matchin function uses a similar algorithm ta Perl, which stops
when it findz tha straight-up original gangsta match, startin at a given point up in tha subject. If you
wanna find all possible matches, or tha longest possible match, consider
usin tha alternatizzle matchin function (see below) instead. Y'all KNOW dat shit, muthafucka! If you cannot use
the alternatizzle function yo, but still need ta find all possible matches, you
can kludge it up by makin use of tha callout facility, which is busted lyrics bout in
the
.\" HREF
\fBpcrecallout\fP
.\"
documentation.
.P
What you gotta do is ta bang a cold-ass lil callout right all up in tha end of tha pattern.
When yo' callout function is called, extract n' save tha current matched
substring. Then return 1, which forces \fBpcre_exec()\fP ta backtrack n' try
other alternatives. Ultimately, when it runs outta matches, \fBpcre_exec()\fP
will yield PCRE_ERROR_NOMATCH.
.
.
.SH "OBTAINING AN ESTIMATE OF STACK USAGE"
.rs
.sp
Matchin certain patterns rockin \fBpcre_exec()\fP can bust a shitload of process
stack, which up in certain environments can be rather limited up in size. Right back up in yo muthafuckin ass. Some users
find it helpful ta have a estimate of tha amount of stack dat is used by
\fBpcre_exec()\fP, ta help dem set recursion limits, as busted lyrics bout up in the
.\" HREF
\fBpcrestack\fP
.\"
documentation. I aint talkin' bout chicken n' gravy biatch. Da estimate dat is output by \fBpcretest\fP when called with
the \fB-m\fP n' \fB-C\fP options is obtained by callin \fBpcre_exec\fP with
the joints NULL, NULL, NULL, -999, n' -999 fo' its first five arguments.
.P
Normally, if its first argument is NULL, \fBpcre_exec()\fP immediately returns
the wack error code PCRE_ERROR_NULL yo, but wit dis special combination of
arguments, it returns instead a wack number whose absolute value is the
approximate stack frame size up in bytes. (A wack number is used so dat it is
clear dat no match has happened.) Da value be approximate cuz up in some
cases, recursive calls ta \fBpcre_exec()\fP occur when there be one or two
additionizzle variablez on tha stack.
.P
If PCRE has been compiled ta use tha heap instead of tha stack fo' recursion,
the value returned is tha size of each block dat is obtained from tha heap.
.
.
.\" HTML <a name="dfamatch"></a>
.SH "MATCHING A PATTERN: THE ALTERNATIVE FUNCTION"
.rs
.sp
.B int pcre_dfa_exec(const pcre *\fIcode\fP, "const pcre_extra *\fIextra\fP,"
.ti +5n
.B "const char *\fIsubject\fP," int \fIlength\fP, int \fIstartoffset\fP,
.ti +5n
.B int \fIoptions\fP, int *\fIovector\fP, int \fIovecsize\fP,
.ti +5n
.B int *\fIworkspace\fP, int \fIwscount\fP);
.P
Da function \fBpcre_dfa_exec()\fP is called ta match a subject strang against
a compiled pattern, rockin a matchin algorithm dat scans tha subject string
just once, n' do not backtrack. This has different characteristics ta the
normal algorithm, n' aint compatible wit Perl. Right back up in yo muthafuckin ass. Some of tha featurez of PCRE
patterns is not supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Nevertheless, there be times when dis kind of
matchin can be useful naaahhmean? For a gangbangin' finger-lickin' rap of tha two matchin algorithms, n' a
list of features dat \fBpcre_dfa_exec()\fP do not support, peep the
.\" HREF
\fBpcrematching\fP
.\"
documentation.
.P
Da arguments fo' tha \fBpcre_dfa_exec()\fP function is tha same as for
\fBpcre_exec()\fP, plus two extras. Da \fIovector\fP argument is used up in a
different way, n' dis is busted lyrics bout below. Da other common arguments is used
in tha same way as fo' \fBpcre_exec()\fP, so they description aint repeated
here.
.P
Da two additionizzle arguments provide workspace fo' tha function. I aint talkin' bout chicken n' gravy biatch. Da workspace
vector should contain at least 20 elements, n' you can put dat on yo' toast. Well shiiiit, it is used fo' keepin track of
multiple paths all up in tha pattern tree. Mo' workspace is ghon be needed for
patterns n' subjects where there be a shitload of potential matches.
.P
Here be a example of a simple call ta \fBpcre_dfa_exec()\fP:
.sp
  int rc;
  int ovector[10];
  int wspace[20];
  rc = pcre_dfa_exec(
    re,             /* result of pcre_compile() */
    NULL,           /* our phat asses didn't study tha pattern */
    "some string",  /* tha subject strang */
    11,             /* tha length of tha subject strang */
    0,              /* start at offset 0 up in tha subject */
    0,              /* default options */
    ovector,        /* vector of integers fo' substrin shiznit */
    10,             /* number of elements (NOT size up in bytes) */
    wspace,         /* hustlin space vector */
    20);            /* number of elements (NOT size up in bytes) */
.
.SS "Option bits fo' \fBpcre_dfa_exec()\fP"
.rs
.sp
Da unused bitz of tha \fIoptions\fP argument fo' \fBpcre_dfa_exec()\fP must be
zero. Da only bits dat may be set is PCRE_ANCHORED, PCRE_NEWLINE_\fIxxx\fP,
PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY, PCRE_NOTEMPTY_ATSTART,
PCRE_NO_UTF8_CHECK, PCRE_BSR_ANYCRLF, PCRE_BSR_UNICODE, PCRE_NO_START_OPTIMIZE,
PCRE_PARTIAL_HARD, PCRE_PARTIAL_SOFT, PCRE_DFA_SHORTEST, n' PCRE_DFA_RESTART.
All but tha last four of these is exactly tha same as fo' \fBpcre_exec()\fP,
so they description aint repeated here.
.sp
  PCRE_PARTIAL_HARD
  PCRE_PARTIAL_SOFT
.sp
These have tha same general effect as they do fo' \fBpcre_exec()\fP yo, but the
details is slightly different. When PCRE_PARTIAL_HARD is set for
\fBpcre_dfa_exec()\fP, it returns PCRE_ERROR_PARTIAL if tha end of tha subject
is reached n' there is still at least one matchin possibilitizzle dat requires
additionizzle characters. This happens even if some complete matches have also
been found. Y'all KNOW dat shit, muthafucka! When PCRE_PARTIAL_SOFT is set, tha return code PCRE_ERROR_NOMATCH
is converted tha fuck into PCRE_ERROR_PARTIAL if tha end of tha subject is reached,
there done been no complete matches yo, but there is still at least one matching
possibility. Da portion of tha strang dat was inspected when tha longest
partial match was found is set as tha straight-up original gangsta matchin strang up in both cases.
There be a mo' detailed rap of partial n' multi-segment matching, with
examples, up in the
.\" HREF
\fBpcrepartial\fP
.\"
documentation.
.sp
  PCRE_DFA_SHORTEST
.sp
Settin tha PCRE_DFA_SHORTEST option causes tha matchin algorithm ta stop as
soon as it has found one match. Because of tha way tha alternatizzle algorithm
works, dis is necessarily tha shortest possible match all up in tha straight-up original gangsta possible
matchin point up in tha subject string.
.sp
  PCRE_DFA_RESTART
.sp
When \fBpcre_dfa_exec()\fP returns a partial match, it is possible ta booty-call it
again, wit additionizzle subject characters, n' have it continue wit tha same
match. Da PCRE_DFA_RESTART option requests dis action; when it is set, the
\fIworkspace\fP n' \fIwscount\fP options must reference tha same vector as
before cuz data bout tha match so far is left up in dem afta a partial
match. There is mo' rap of dis facilitizzle up in the
.\" HREF
\fBpcrepartial\fP
.\"
documentation.
.
.
.SS "Successful returns from \fBpcre_dfa_exec()\fP"
.rs
.sp
When \fBpcre_dfa_exec()\fP succeeds, it may have matched mo' than one
substrin up in tha subject. Note, however, dat all tha matches from one run of
the function start all up in tha same point up in tha subject. Da shorta matches are
all initial substringz of tha longer matches. For example, if tha pattern
.sp
  <.*>
.sp
is matched against tha string
.sp
  This is <something> <suttin' else> <suttin' further> no more
.sp
the three matched strings are
.sp
  <something>
  <something> <suttin' else>
  <something> <suttin' else> <suttin' further>
.sp
On success, tha yield of tha function be a number pimped outa than zero, which is
the number of matched substrings. Da substrings theyselves is returned in
\fIovector\fP. Each strang uses two elements; tha straight-up original gangsta is tha offset ta the
start, n' tha second is tha offset ta tha end yo, but it ain't no stoppin cause I be still poppin'. In fact, all tha strings have
the same start offset. (Space could done been saved by givin dis only once,
but dat shiznit was decided ta retain some compatibilitizzle wit tha way \fBpcre_exec()\fP
returns data, even though tha meanin of tha strings is different.)
.P
Da strings is returned up in reverse order of length; dat is, tha longest
matchin strang is given first. If there was too nuff matches ta fit into
\fIovector\fP, tha yield of tha function is zero, n' tha vector is filled with
the longest matches. Unlike \fBpcre_exec()\fP, \fBpcre_dfa_exec()\fP can use
the entire \fIovector\fP fo' returnin matched strings.
.
.
.SS "Error returns from \fBpcre_dfa_exec()\fP"
.rs
.sp
Da \fBpcre_dfa_exec()\fP function returns a wack number when it fails.
Many of tha errors is tha same as fo' \fBpcre_exec()\fP, n' these are
busted lyrics about
.\" HTML <a href="#errorlist">
.\" </a>
above.
.\"
There is up in addizzle tha followin errors dat is specific to
\fBpcre_dfa_exec()\fP:
.sp
  PCRE_ERROR_DFA_UITEM      (-16)
.sp
This return is given if \fBpcre_dfa_exec()\fP encountas a item up in tha pattern
that it do not support, fo' instance, tha use of \eC or a funky-ass back reference.
.sp
  PCRE_ERROR_DFA_UCOND      (-17)
.sp
This return is given if \fBpcre_dfa_exec()\fP encountas a cold-ass lil condizzle item that
uses a funky-ass back reference fo' tha condition, or a test fo' recursion up in a specific
group. These is not supported.
.sp
  PCRE_ERROR_DFA_UMLIMIT    (-18)
.sp
This return is given if \fBpcre_dfa_exec()\fP is called wit a \fIextra\fP
block dat gotz nuff a settin of tha \fImatch_limit\fP or
\fImatch_limit_recursion\fP fields. This aint supported (these fieldz are
meaningless fo' DFA matching).
.sp
  PCRE_ERROR_DFA_WSSIZE     (-19)
.sp
This return is given if \fBpcre_dfa_exec()\fP runs outta space up in the
\fIworkspace\fP vector.
.sp
  PCRE_ERROR_DFA_RECURSE    (-20)
.sp
When a recursive subpattern is processed, tha matchin function calls itself
recursively, rockin private vectors fo' \fIovector\fP n' \fIworkspace\fP. This
error is given if tha output vector aint big-ass enough cause I gots dem finger-lickin' chickens wit tha siz-auce. This should be
extremely rare, as a vector of size 1000 is used.
.sp
  PCRE_ERROR_DFA_BADRESTART (-30)
.sp
When \fBpcre_dfa_exec()\fP is called wit tha \fBPCRE_DFA_RESTART\fP option,
some plausibilitizzle checks is made on tha contentz of tha workspace, which
should contain data bout tha previous partial match. If any of these checks
fail, dis error is given.
.
.
.SH "SEE ALSO"
.rs
.sp
\fBpcre16\fP(3), \fBpcre32\fP(3), \fBpcrebuild\fP(3), \fBpcrecallout\fP(3),
\fBpcrecpp(3)\fP(3), \fBpcrematching\fP(3), \fBpcrepartial\fP(3),
\fBpcreposix\fP(3), \fBpcreprecompile\fP(3), \fBpcresample\fP(3),
\fBpcrestack\fP(3).
.
.
.SH AUTHOR
.rs
.sp
.nf
Philip Hazel
Universitizzle Computin Service
Cambridge CB2 3QH, England.
.fi
.
.
.SH REVISION
.rs
.sp
.nf
Last updated: 12 May 2013
Copyright (c) 1997-2013 Universitizzle of Cambridge.
.fi
