" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_cxx::__rc_string_base< _CharT, _Traits, _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits __gnu_cxx::__vstring_utility< _CharT, _Traits, _Alloc >\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef 
.br
_Util_Base::_CharT_alloc_type \fB_CharT_alloc_type\fP"
.br
.ti -1c
.RI "typedef __vstring_utility
.br
< _CharT, _Traits, _Alloc > \fB_Util_Base\fP"
.br
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef 
.br
_CharT_alloc_type::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Traits \fBtraits_type\fP"
.br
.ti -1c
.RI "typedef _Traits::char_type \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB__rc_string_base\fP (const _Alloc &__a)"
.br
.ti -1c
.RI "\fB__rc_string_base\fP (const \fB__rc_string_base\fP &__rcs)"
.br
.ti -1c
.RI "\fB__rc_string_base\fP (\fB__rc_string_base\fP &&__rcs)"
.br
.ti -1c
.RI "\fB__rc_string_base\fP (size_type __n, _CharT __c, const _Alloc &__a)"
.br
.ti -1c
.RI "template<typename _InputIterator > \fB__rc_string_base\fP (_InputIterator __beg, _InputIterator __end, const _Alloc &__a)"
.br
.ti -1c
.RI "void \fB_M_assign\fP (const \fB__rc_string_base\fP &__rcs)"
.br
.ti -1c
.RI "size_type \fB_M_capacity\fP () const "
.br
.ti -1c
.RI "void \fB_M_clear\fP ()"
.br
.ti -1c
.RI "bool \fB_M_compare\fP (const \fB__rc_string_base\fP &) const "
.br
.ti -1c
.RI "template<> bool \fB_M_compare\fP (const \fB__rc_string_base\fP &__rcs) const"
.br
.ti -1c
.RI "template<> bool \fB_M_compare\fP (const \fB__rc_string_base\fP &__rcs) const"
.br
.ti -1c
.RI "_CharT * \fB_M_data\fP () const "
.br
.ti -1c
.RI "void \fB_M_erase\fP (size_type __pos, size_type __n)"
.br
.ti -1c
.RI "allocator_type & \fB_M_get_allocator\fP ()"
.br
.ti -1c
.RI "const allocator_type & \fB_M_get_allocator\fP () const "
.br
.ti -1c
.RI "bool \fB_M_is_shared\fP () const "
.br
.ti -1c
.RI "void \fB_M_leak\fP ()"
.br
.ti -1c
.RI "size_type \fB_M_length\fP () const "
.br
.ti -1c
.RI "size_type \fB_M_max_size\fP () const "
.br
.ti -1c
.RI "void \fB_M_mutate\fP (size_type __pos, size_type __len1, const _CharT *__s, size_type __len2)"
.br
.ti -1c
.RI "void \fB_M_reserve\fP (size_type __res)"
.br
.ti -1c
.RI "void \fB_M_set_leaked\fP ()"
.br
.ti -1c
.RI "void \fB_M_set_length\fP (size_type __n)"
.br
.ti -1c
.RI "void \fB_M_swap\fP (\fB__rc_string_base\fP &__rcs)"
.br
.ti -1c
.RI "template<typename _InIterator > _CharT * \fB_S_construct\fP (_InIterator __beg, _InIterator __end, const _Alloc &__a, \fBstd::forward_iterator_tag\fP)"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef 
.br
__gnu_cxx::__normal_iterator
.br
< const_pointer, 
.br
\fB__gnu_cxx::__versa_string\fP
.br
< _CharT, _Traits, _Alloc, 
.br
\fB__rc_string_base\fP > > \fB__const_rc_iterator\fP"
.br
.ti -1c
.RI "typedef 
.br
__gnu_cxx::__normal_iterator
.br
< const_pointer, 
.br
\fB__gnu_cxx::__versa_string\fP
.br
< _CharT, _Traits, _Alloc, 
.br
__sso_string_base > > \fB__const_sso_iterator\fP"
.br
.ti -1c
.RI "typedef 
.br
__gnu_cxx::__normal_iterator
.br
< pointer, 
.br
\fB__gnu_cxx::__versa_string\fP
.br
< _CharT, _Traits, _Alloc, 
.br
\fB__rc_string_base\fP > > \fB__rc_iterator\fP"
.br
.ti -1c
.RI "typedef 
.br
__gnu_cxx::__normal_iterator
.br
< pointer, 
.br
\fB__gnu_cxx::__versa_string\fP
.br
< _CharT, _Traits, _Alloc, 
.br
__sso_string_base > > \fB__sso_iterator\fP"
.br
.ti -1c
.RI "typedef 
.br
_CharT_alloc_type::const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef 
.br
_CharT_alloc_type::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef _CharT_alloc_type::pointa \fBpointer\fP"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static void \fB_S_assign\fP (_CharT *__d, size_type __n, _CharT __c)"
.br
.ti -1c
.RI "static int \fB_S_compare\fP (size_type __n1, size_type __n2)"
.br
.ti -1c
.RI "static void \fB_S_copy\fP (_CharT *__d, const _CharT *__s, size_type __n)"
.br
.ti -1c
.RI "template<typename _Iterator > static void \fB_S_copy_chars\fP (_CharT *__p, _Iterator __k1, _Iterator __k2)"
.br
.ti -1c
.RI "static void \fB_S_copy_chars\fP (_CharT *__p, __sso_iterator __k1, __sso_iterator __k2)"
.br
.ti -1c
.RI "static void \fB_S_copy_chars\fP (_CharT *__p, __const_sso_iterator __k1, __const_sso_iterator __k2)"
.br
.ti -1c
.RI "static void \fB_S_copy_chars\fP (_CharT *__p, __rc_iterator __k1, __rc_iterator __k2)"
.br
.ti -1c
.RI "static void \fB_S_copy_chars\fP (_CharT *__p, __const_rc_iterator __k1, __const_rc_iterator __k2)"
.br
.ti -1c
.RI "static void \fB_S_copy_chars\fP (_CharT *__p, _CharT *__k1, _CharT *__k2)"
.br
.ti -1c
.RI "static void \fB_S_copy_chars\fP (_CharT *__p, const _CharT *__k1, const _CharT *__k2)"
.br
.ti -1c
.RI "static void \fB_S_move\fP (_CharT *__d, const _CharT *__s, size_type __n)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _CharT, typename _Traits, typename _Alloc>class __gnu_cxx::__rc_string_base< _CharT, _Traits, _Alloc >"
Documentation? Whatz that? Nathan Myers ncm@cantrip.org\&.
.PP
A strang be lookin like this:
.PP
.PP
.nf
                                     [_Rep]
                                     _M_length
[__rc_string_base<char_type>]        _M_capacity
_M_dataplus                          _M_refcount
_M_p ---------------->               unnamed array of char_type
.fi
.PP
.PP
Where tha _M_p points ta tha straight-up original gangsta characta up in tha string, n' you cast it ta a pointer-to-_Rep n' subtract 1 ta git a pointa ta tha header\&.
.PP
This approach has tha enormous advantage dat a strang object requires only one allocation\& fo' realz. All tha uglinizz is confined within a single pair of inline functions, which each compile ta a single \fIadd\fP instruction: _Rep::_M_refdata(), n' __rc_string_base::_M_rep(); n' tha allocation function which gets a funky-ass block of raw bytes n' wit room enough n' constructs a _Rep object all up in tha front\&.
.PP
Da reason you want _M_data pointin ta tha characta array n' not tha _Rep is so dat tha debugger can peep tha strang contents\&. (Probably we should add a non-inline member ta git tha _Rep fo' tha debugger ta use, so playas can check tha actual strang length\&.)
.PP
Note dat tha _Rep object be a POD so dat you can gotz a static \fIempty string\fP _Rep object already \fIconstructed\fP before static constructors have run\&. Da reference-count encodin is chosen so dat a 0 indicates one reference, so you never try ta destroy tha empty-strin _Rep object\&.
.PP
All but tha last paragraph is considered pretty conventionizzle fo' a C++ strang implementation\&. 
.PP
Definizzle at line 82 of file rc_string_base\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
