.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Thread 3pm"
.TH Thread 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Thread \- Manipulate threadz up in Perl (for oldschool code only)
.SH "DEPRECATED"
.IX Header "DEPRECATED"
Da \f(CW\*(C`Thread\*(C'\fR module served as tha frontend ta tha old-style thread model,
called \fI5005threads\fR, dat was introduced up in release 5.005.  That model was
deprecated, n' has been removed up in version 5.10.
.PP
For oldschool code n' interim backwardz compatibility, tha \f(CW\*(C`Thread\*(C'\fR module has
been reworked ta function as a gangbangin' frontend fo' tha freshly smoked up interpreta threads
(\fIithreads\fR) model.  But fuck dat shiznit yo, tha word on tha street is dat some previous functionalitizzle aint available.
Further, tha data pluggin models between tha two thread models is straight-up
different, n' anythang ta do wit data pluggin has ta be thought differently.
With \fIithreads\fR, you must explicitly \f(CW\*(C`share()\*(C'\fR variablez between the
threads.
.PP
Yo ass is straight fuckin encouraged ta migrate any existin threaded code ta tha new
model (i.e., use tha \f(CW\*(C`threads\*(C'\fR n' \f(CW\*(C`threads::shared\*(C'\fR modules) as soon as
possible.
.SH "HISTORY"
.IX Header "HISTORY"
In Perl 5.005, tha thread model was dat all data is implicitly shared, and
shared access ta data has ta be explicitly synchronized. Y'all KNOW dat shit, muthafucka!  This model is called
\&\fI5005threads\fR.
.PP
In Perl 5.6, a freshly smoked up model was introduced up in which all is was thread local and
shared access ta data has ta be explicitly declared. Y'all KNOW dat shit, muthafucka!  This model is called
\&\fIithreads\fR, fo' \*(L"interpreta threads\*(R".
.PP
In Perl 5.6, tha \fIithreads\fR model was not available as a hood \s-1API\s0; only as
an internal \s-1API\s0 dat was available fo' extension writers, n' ta implement
\&\fIfork()\fR emulation on Win32 platforms.
.PP
In Perl 5.8, tha \fIithreads\fR model became available all up in tha \f(CW\*(C`threads\*(C'\fR
module, n' tha \fI5005threads\fR model was deprecated.
.PP
In Perl 5.10, tha \fI5005threads\fR model was removed from tha Perl interpreter.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Thread qw(:DEFAULT async yield);
\&
\&    mah $t = Thread\->new(\e&start_sub, @start_args);
\&
\&    $result = $t\->join;
\&    $t\->detach;
\&
\&    if ($t\->done) {
\&        $t\->join;
\&    }
\&
\&    if($t\->equal($another_thread)) {
\&        # ...
\&    }
\&
\&    yield();
\&
\&    mah $tid = Thread\->self\->tid;
\&
\&    lock($scalar);
\&    lock(@array);
\&    lock(%hash);
\&
\&    mah @list = Thread\->list;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`Thread\*(C'\fR module serves up multithreadin support fo' Perl.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP "$thread = Thread\->new(\e&start_sub)" 8
.el .IP "\f(CW$thread\fR = Thread\->new(\e&start_sub)" 8
.IX Item "$thread = Thread->new(&start_sub)"
.PD 0
.ie n .IP "$thread = Thread\->new(\e&start_sub, \s-1LIST\s0)" 8
.el .IP "\f(CW$thread\fR = Thread\->new(\e&start_sub, \s-1LIST\s0)" 8
.IX Item "$thread = Thread->new(&start_sub, LIST)"
.PD
\&\f(CW\*(C`new\*(C'\fR starts a freshly smoked up thread of execution up in tha referenced subroutine. The
optionizzle list is passed as parametas ta tha subroutine. Execution
continues up in both tha subroutine n' tha code afta tha \f(CW\*(C`new\*(C'\fR call.
.Sp
\&\f(CW\*(C`Thread\-&gt;new\*(C'\fR returns a thread object representin tha newly pimped
thread.
.IP "lock \s-1VARIABLE\s0" 8
.IX Item "lock VARIABLE"
\&\f(CW\*(C`lock\*(C'\fR places a lock on a variable until tha lock goes outta scope.
.Sp
If tha variable is locked by another thread, tha \f(CW\*(C`lock\*(C'\fR call will
block until itz available.  \f(CW\*(C`lock\*(C'\fR is recursive, so multiple calls
to \f(CW\*(C`lock\*(C'\fR is safe\*(--the variable will remain locked until the
outermost lock on tha variable goes outta scope.
.Sp
Locks on variablez only affect \f(CW\*(C`lock\*(C'\fR calls\*(--they do \fInot\fR affect normal
access ta a variable. (Locks on subs is different, n' covered up in a funky-ass bit.)
If you straight-up, \fIreally\fR want locks ta block access, then go ahead n' tie
them ta suttin' n' manage dis yo ass.  This is done on purpose.
While managin access ta variablez be a phat thang, Perl don't force
you outta its livin room...
.Sp
If a cold-ass lil container object, like fuckin a hash or array, is locked, all the
elementz of dat container is not locked. Y'all KNOW dat shit, muthafucka! For example, if a thread
does a \f(CW\*(C`lock @a\*(C'\fR, any other thread bustin a \f(CW\*(C`lock($a[12])\*(C'\fR won't
block.
.Sp
Finally, \f(CW\*(C`lock\*(C'\fR will traverse up references exactly \fIone\fR level.
\&\f(CW\*(C`lock(\e$a)\*(C'\fR is equivalent ta \f(CW\*(C`lock($a)\*(C'\fR, while \f(CW\*(C`lock(\e\e$a)\*(C'\fR is not.
.IP "async \s-1BLOCK\s0;" 8
.IX Item "async BLOCK;"
\&\f(CW\*(C`async\*(C'\fR creates a thread ta execute tha block immediately following
it.  This block is treated as a anonymous sub, n' so must have a
semi-colon afta tha closin brace. Like \f(CW\*(C`Thread\-&gt;new\*(C'\fR, \f(CW\*(C`async\*(C'\fR
returns a thread object.
.IP "Thread\->self" 8
.IX Item "Thread->self"
Da \f(CW\*(C`Thread\->self\*(C'\fR function returns a thread object dat represents
the thread makin tha \f(CW\*(C`Thread\->self\*(C'\fR call.
.IP "Thread\->list" 8
.IX Item "Thread->list"
Returns a list of all non-joined, non-detached Thread objects.
.IP "cond_wait \s-1VARIABLE\s0" 8
.IX Item "cond_wait VARIABLE"
Da \f(CW\*(C`cond_wait\*(C'\fR function takes a \fBlocked\fR variable as
a parameter, unlocks tha variable, n' blocks until another thread
does a \f(CW\*(C`cond_signal\*(C'\fR or \f(CW\*(C`cond_broadcast\*(C'\fR fo' dat same locked
variable. Da variable dat \f(CW\*(C`cond_wait\*(C'\fR blocked on is relocked
afta tha \f(CW\*(C`cond_wait\*(C'\fR is satisfied. Y'all KNOW dat shit, muthafucka!  If there be multiple threads
\&\f(CW\*(C`cond_wait\*(C'\fRin on tha same variable, all but one will reblock waiting
to reaquire tha lock on tha variable.  (So if you only using
\&\f(CW\*(C`cond_wait\*(C'\fR fo' synchronization, give up tha lock as soon as
possible.)
.IP "cond_signal \s-1VARIABLE\s0" 8
.IX Item "cond_signal VARIABLE"
Da \f(CW\*(C`cond_signal\*(C'\fR function takes a locked variable as a parameta and
unblocks one thread thatz \f(CW\*(C`cond_wait\*(C'\fRin on dat variable. If mo' than
one thread is blocked up in a \f(CW\*(C`cond_wait\*(C'\fR on dat variable, only one (and
which one is indeterminate) is ghon be unblocked.
.Sp
If there be no threadz blocked up in a \f(CW\*(C`cond_wait\*(C'\fR on tha variable,
the signal is discarded.
.IP "cond_broadcast \s-1VARIABLE\s0" 8
.IX Item "cond_broadcast VARIABLE"
Da \f(CW\*(C`cond_broadcast\*(C'\fR function works similarly ta \f(CW\*(C`cond_signal\*(C'\fR.
\&\f(CW\*(C`cond_broadcast\*(C'\fR, though, will unblock \fBall\fR tha threadz dat are
blocked up in a \f(CW\*(C`cond_wait\*(C'\fR on tha locked variable, rather than only
one.
.IP "yield" 8
.IX Item "yield"
Da \f(CW\*(C`yield\*(C'\fR function allows another thread ta take control of the
\&\s-1CPU.\s0 Da exact thangs up in dis biatch is implementation-dependent.
.SH "METHODS"
.IX Header "METHODS"
.IP "join" 8
.IX Item "join"
\&\f(CW\*(C`join\*(C'\fR waits fo' a thread ta end n' returns any joints tha thread
exited with.  \f(CW\*(C`join\*(C'\fR will block until tha thread has ended, though
it won't block if tha thread has already terminated.
.Sp
If tha thread bein \f(CW\*(C`join\*(C'\fRed \f(CW\*(C`die\*(C'\fRd, tha error it took a dirt nap wit will
be returned at dis time. If you don't want tha thread struttin
the \f(CW\*(C`join\*(C'\fR ta take a thugged-out dirtnap as well, you should either wrap tha \f(CW\*(C`join\*(C'\fR in
an \f(CW\*(C`eval\*(C'\fR or use tha \f(CW\*(C`eval\*(C'\fR thread method instead of \f(CW\*(C`join\*(C'\fR.
.IP "detach" 8
.IX Item "detach"
\&\f(CW\*(C`detach\*(C'\fR  drops some lyrics ta a thread dat it is never goin ta be joined i.e.
that all tracez of its existence can be removed once it stops hustlin.
Errors up in detached threadz aint gonna be visible anywhere \- if you want
to catch them, you should use \f(CW$SIG\fR{_\|_DIE_\|_} or suttin' like dis shit.
.IP "equal" 8
.IX Item "equal"
\&\f(CW\*(C`equal\*(C'\fR tests whether two thread objects represent tha same thread and
returns legit if they do.
.IP "tid" 8
.IX Item "tid"
Da \f(CW\*(C`tid\*(C'\fR method returns tha tid of a thread. Y'all KNOW dat shit, muthafucka! Da tid is
a monotonically increasin integer assigned when a thread is
created. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da main thread of a program gonna git a tid of zero,
while subsequent threadz gonna git tidz assigned startin wit one.
.IP "done" 8
.IX Item "done"
Da \f(CW\*(C`done\*(C'\fR method returns legit if tha thread you checkin has
finished, n' false otherwise.
.SH "DEFUNCT"
.IX Header "DEFUNCT"
Da followin was implemented wit \fI5005threads\fR yo, but is no longer
available wit \fIithreads\fR.
.IP "lock(\e&sub)" 8
.IX Item "lock(&sub)"
With 5005threads, you could also \f(CW\*(C`lock\*(C'\fR a sub such dat any calls ta dat sub
from another thread would block until tha lock was busted out.
.Sp
Also, subroutines could be declared wit tha \f(CW\*(C`:locked\*(C'\fR attribute which would
serialize access ta tha subroutine yo, but allowed different threads
non-simultaneous access.
.IP "eval" 8
.IX Item "eval"
Da \f(CW\*(C`eval\*(C'\fR method wrapped a \f(CW\*(C`eval\*(C'\fR round a \f(CW\*(C`join\*(C'\fR, n' so waited fo' a
thread ta exit, passin along any joints tha thread might have returned and
placin any errors tha fuck into \f(CW$@\fR.
.IP "flags" 8
.IX Item "flags"
Da \f(CW\*(C`flags\*(C'\fR method returned tha flags fo' tha thread \- a integer value
correspondin ta tha internal flags fo' tha thread.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
threads, threads::shared, Thread::Queue, Thread::Semaphore
