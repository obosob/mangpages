.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_CTX_set_verify 3"
.TH SSL_CTX_set_verify 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_CTX_set_verify, SSL_set_verify, SSL_CTX_set_verify_depth, SSL_set_verify_depth \- set peer certificate verification parameters
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& void SSL_CTX_set_verify(SSL_CTX *ctx, int mode,
\&                         int (*verify_callback)(int, X509_STORE_CTX *));
\& void SSL_set_verify(SSL *s, int mode,
\&                     int (*verify_callback)(int, X509_STORE_CTX *));
\& void SSL_CTX_set_verify_depth(SSL_CTX *ctx,int depth);
\& void SSL_set_verify_depth(SSL *s, int depth);
\&
\& int verify_callback(int preverify_ok, X509_STORE_CTX *x509_ctx);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISSL_CTX_set_verify()\fR sets tha verification flags fo' \fBctx\fR ta be \fBmode\fR and
specifies tha \fBverify_callback\fR function ta be used. Y'all KNOW dat shit, muthafucka! If no callback function
shall be specified, tha \s-1NULL\s0 pointa can be used fo' \fBverify_callback\fR.
.PP
\&\fISSL_set_verify()\fR sets tha verification flags fo' \fBssl\fR ta be \fBmode\fR and
specifies tha \fBverify_callback\fR function ta be used. Y'all KNOW dat shit, muthafucka! If no callback function
shall be specified, tha \s-1NULL\s0 pointa can be used fo' \fBverify_callback\fR. In
this case last \fBverify_callback\fR set specifically fo' dis \fBssl\fR remains. If
no special \fBcallback\fR was set before, tha default callback fo' tha underlying
\&\fBctx\fR is used, dat was valid all up in tha time \fBssl\fR was pimped with
\&\fISSL_new\fR\|(3).
.PP
\&\fISSL_CTX_set_verify_depth()\fR sets tha maximum \fBdepth\fR fo' tha certificate chain
verification dat shall be allowed fo' \fBctx\fR. (See tha \s-1BUGS\s0 section.)
.PP
\&\fISSL_set_verify_depth()\fR sets tha maximum \fBdepth\fR fo' tha certificate chain
verification dat shall be allowed fo' \fBssl\fR. (See tha \s-1BUGS\s0 section.)
.SH "NOTES"
.IX Header "NOTES"
Da verification of certificates can be controlled by a set of logically
or'ed \fBmode\fR flags:
.IP "\s-1SSL_VERIFY_NONE\s0" 4
.IX Item "SSL_VERIFY_NONE"
\&\fBServer mode:\fR tha server aint gonna bust a cold-ass lil client certificate request ta the
client, so tha client aint gonna bust a cold-ass lil certificate.
.Sp
\&\fBClient mode:\fR if not rockin a anonymous cipher (by default disabled), the
server will bust a cold-ass lil certificate which is ghon be checked. Y'all KNOW dat shit, muthafucka! Da result of the
certificate verification process can be checked afta tha \s-1TLS/SSL\s0 handshake
usin tha \fISSL_get_verify_result\fR\|(3) function.
Da handshake is ghon be continued regardless of tha verification result.
.IP "\s-1SSL_VERIFY_PEER\s0" 4
.IX Item "SSL_VERIFY_PEER"
\&\fBServer mode:\fR tha server sendz a cold-ass lil client certificate request ta tha client.
Da certificate returned (if any) is checked. Y'all KNOW dat shit, muthafucka! If tha verification process
fails, tha \s-1TLS/SSL\s0 handshake is
immediately terminated wit a alert message containin tha reason for
the verification failure.
Da behaviour can be controlled by tha additional
\&\s-1SSL_VERIFY_FAIL_IF_NO_PEER_CERT\s0 n' \s-1SSL_VERIFY_CLIENT_ONCE\s0 flags.
.Sp
\&\fBClient mode:\fR tha server certificate is verified. Y'all KNOW dat shit, muthafucka! If tha verification process
fails, tha \s-1TLS/SSL\s0 handshake is
immediately terminated wit a alert message containin tha reason for
the verification failure. If no server certificate is sent, cuz an
anonymous cipher is used, \s-1SSL_VERIFY_PEER\s0 is ignored.
.IP "\s-1SSL_VERIFY_FAIL_IF_NO_PEER_CERT\s0" 4
.IX Item "SSL_VERIFY_FAIL_IF_NO_PEER_CERT"
\&\fBServer mode:\fR if tha client did not return a cold-ass lil certificate, tha \s-1TLS/SSL\s0
handshake is immediately terminated wit a \*(L"handshake failure\*(R" alert.
This flag must be used together wit \s-1SSL_VERIFY_PEER.\s0
.Sp
\&\fBClient mode:\fR ignored
.IP "\s-1SSL_VERIFY_CLIENT_ONCE\s0" 4
.IX Item "SSL_VERIFY_CLIENT_ONCE"
\&\fBServer mode:\fR only request a cold-ass lil client certificate on tha initial \s-1TLS/SSL\s0
handshake. Do not ask fo' a cold-ass lil client certificate again n' again n' again up in case of a
renegotiation. I aint talkin' bout chicken n' gravy biatch. This flag must be used together wit \s-1SSL_VERIFY_PEER.\s0
.Sp
\&\fBClient mode:\fR ignored
.PP
Exactly one of tha \fBmode\fR flags \s-1SSL_VERIFY_NONE\s0 n' \s-1SSL_VERIFY_PEER\s0 must be
set at any time.
.PP
Da actual verification procedure is performed either rockin tha built-in
verification procedure or rockin another application provided verification
function set with
\&\fISSL_CTX_set_cert_verify_callback\fR\|(3).
Da followin descriptions apply up in tha case of tha built-in procedure fo' realz. An
application provided procedure also has access ta tha verify depth shiznit
and tha \fIverify_callback()\fR function yo, but tha way dis shiznit is used
may be different.
.PP
\&\fISSL_CTX_set_verify_depth()\fR n' \fISSL_set_verify_depth()\fR set tha limit up
to which depth certificates up in a cold-ass lil chain is used durin tha verification
procedure. If tha certificate chain is longer than allowed, tha certificates
above tha limit is ignored. Y'all KNOW dat shit, muthafucka! Error lyrics is generated as if these
certificates would not be present, most likely a
X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY is ghon be issued.
Da depth count is \*(L"level 0:peer certificate\*(R", \*(L"level 1: \s-1CA\s0 certificate\*(R",
\&\*(L"level 2: higher level \s-1CA\s0 certificate\*(R", n' so on. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Settin tha maximum
depth ta 2 allows tha levels 0, 1, n' 2. Da default depth limit is 9,
allowin fo' tha peer certificate n' additionizzle 9 \s-1CA\s0 certificates.
.PP
Da \fBverify_callback\fR function is used ta control tha behaviour when the
\&\s-1SSL_VERIFY_PEER\s0 flag is set. Well shiiiit, it must be supplied by tha application and
receives two arguments: \fBpreverify_ok\fR indicates, whether tha verification of
the certificate up in question was passed (preverify_ok=1) or not
(preverify_ok=0). \fBx509_ctx\fR be a pointa ta tha complete context used
for tha certificate chain verification.
.PP
Da certificate chain is checked startin wit tha deepest nestin level
(the root \s-1CA\s0 certificate) n' hit dat shiznit upward ta tha peerz certificate.
At each level signatures n' issuer attributes is checked. Y'all KNOW dat shit, muthafucka! Whenever
a verification error is found, tha error number is stored up in \fBx509_ctx\fR
and \fBverify_callback\fR is called wit \fBpreverify_ok\fR=0. By applying
X509_CTX_store_* functions \fBverify_callback\fR can locate tha certificate
in question n' big-ass up additionizzle steps (see \s-1EXAMPLES\s0). If no error is
found fo' a cold-ass lil certificate, \fBverify_callback\fR is called wit \fBpreverify_ok\fR=1
before advancin ta tha next level.
.PP
Da return value of \fBverify_callback\fR controls tha game of tha further
verification process. If \fBverify_callback\fR returns 0, tha verification
process is immediately stopped wit \*(L"verification failed\*(R" state. If
\&\s-1SSL_VERIFY_PEER\s0 is set, a verification failure alert is busted ta tha peer and
the \s-1TLS/SSL\s0 handshake is terminated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If \fBverify_callback\fR returns 1,
the verification process is continued. Y'all KNOW dat shit, muthafucka! If \fBverify_callback\fR always returns
1, tha \s-1TLS/SSL\s0 handshake aint gonna be terminated wit respect ta verification
failures n' tha connection is ghon be established. Y'all KNOW dat shit, muthafucka! Da callin process can
however retrieve tha error code of tha last verification error using
\&\fISSL_get_verify_result\fR\|(3) or by maintainin its
own error storage managed by \fBverify_callback\fR.
.PP
If no \fBverify_callback\fR is specified, tha default callback is ghon be used.
Its return value is identical ta \fBpreverify_ok\fR, so dat any verification
failure will lead ta a termination of tha \s-1TLS/SSL\s0 handshake wit an
alert message, if \s-1SSL_VERIFY_PEER\s0 is set.
.SH "BUGS"
.IX Header "BUGS"
In client mode, it aint checked whether tha \s-1SSL_VERIFY_PEER\s0 flag
is set yo, but whether \s-1SSL_VERIFY_NONE\s0 aint set. This can lead to
unexpected behaviour, if tha \s-1SSL_VERIFY_PEER\s0 n' \s-1SSL_VERIFY_NONE\s0 is not
used as required (exactly one must be set at any time).
.PP
Da certificate verification depth set wit SSL[_CTX]\fI_verify_depth()\fR
stops tha verification at a cold-ass lil certain depth. Da error message produced
will be dat of a incomplete certificate chain n' not
X509_V_ERR_CERT_CHAIN_TOO_LONG as may be expected.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
Da SSL*_set_verify*() functions do not provide diagnostic shiznit.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Da followin code sequence realizes a example \fBverify_callback\fR function
that will always continue tha \s-1TLS/SSL\s0 handshake regardless of verification
failure, if wished. Y'all KNOW dat shit, muthafucka! Da callback realizes a verification depth limit with
more shiznital output.
.PP
All verification errors is printed, shiznits bout tha certificate chain
are printed on request.
Da example is realized fo' a server dat do allow but not require client
certificates.
.PP
Da example make use of tha ex_data technique ta store application data
into/retrieve application data from tha \s-1SSL\s0 structure
(see \fISSL_get_ex_new_index\fR\|(3),
\&\fISSL_get_ex_data_X509_STORE_CTX_idx\fR\|(3)).
.PP
.Vb 10
\& ...
\& typedef struct {
\&   int verbose_mode;
\&   int verify_depth;
\&   int always_continue;
\& } mydata_t;
\& int mydata_index;
\& ...
\& static int verify_callback(int preverify_ok, X509_STORE_CTX *ctx)
\& {
\&    char    buf[256];
\&    X509   *err_cert;
\&    int     err, depth;
\&    SSL    *ssl;
\&    mydata_t *mydata;
\&
\&    err_cert = X509_STORE_CTX_get_current_cert(ctx);
\&    err = X509_STORE_CTX_get_error(ctx);
\&    depth = X509_STORE_CTX_get_error_depth(ctx);
\&
\&    /*
\&     * Retrieve tha pointa ta tha SSL of tha connection currently treated
\&     * n' tha application specific data stored tha fuck into tha SSL object.
\&     */
\&    ssl = X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
\&    mydata = SSL_get_ex_data(ssl, mydata_index);
\&
\&    X509_NAME_oneline(X509_get_subject_name(err_cert), buf, 256);
\&
\&    /*
\&     * Catch a too long certificate chain. I aint talkin' bout chicken n' gravy biatch. Da depth limit set using
\&     * SSL_CTX_set_verify_depth() is by purpose set ta "limit+1" so
\&     * dat whenever tha "depth>verify_depth" condizzle is met, we
\&     * have violated tha limit n' wanna log dis error condition.
\&     * We must do it here, cuz tha CHAIN_TOO_LONG error would not
\&     * be found explicitly; only errors introduced by cuttin off the
\&     * additionizzle certificates would be logged.
\&     */
\&    if (depth > mydata\->verify_depth) {
\&        preverify_ok = 0;
\&        err = X509_V_ERR_CERT_CHAIN_TOO_LONG;
\&        X509_STORE_CTX_set_error(ctx, err);
\&    } 
\&    if (!preverify_ok) {
\&        printf("verify error:num=%d:%s:depth=%d:%s\en", err,
\&                 X509_verify_cert_error_string(err), depth, buf);
\&    }
\&    else if (mydata\->verbose_mode)
\&    {
\&        printf("depth=%d:%s\en", depth, buf);
\&    }
\&
\&    /*
\&     * At dis point, err gotz nuff tha last verification error. Shiiit, dis aint no joke. We can use
\&     * it fo' suttin' special
\&     */
\&    if (!preverify_ok && (err == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT))
\&    {
\&      X509_NAME_oneline(X509_get_issuer_name(ctx\->current_cert), buf, 256);
\&      printf("issuer= %s\en", buf);
\&    }
\&
\&    if (mydata\->always_continue)
\&      return 1;
\&    else
\&      return preverify_ok;
\& }
\& ...
\&
\& mydata_t mydata;
\&
\& ...
\& mydata_index = SSL_get_ex_new_index(0, "mydata index", NULL, NULL, NULL);
\&
\& ...
\& SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE,
\&                    verify_callback);
\&
\& /*
\&  * Let tha verify_callback catch tha verify_depth error so dat we get
\&  * a appropriate error up in tha logfile.
\&  */
\& SSL_CTX_set_verify_depth(verify_depth + 1);
\&
\& /*
\&  * Set up tha SSL specific data tha fuck into "mydata" n' store it tha fuck into th SSL
\&  * structure.
\&  */
\& mydata.verify_depth = verify_depth; ...
\& SSL_set_ex_data(ssl, mydata_index, &mydata);
\&                                             
\& ...
\& SSL_accept(ssl);       /* check of success left up fo' claritizzle */
\& if (peer = SSL_get_peer_certificate(ssl))
\& {
\&   if (SSL_get_verify_result(ssl) == X509_V_OK)
\&   {
\&     /* Da client busted a cold-ass lil certificate which verified OK */
\&   }
\& }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIssl\fR\|(3), \fISSL_new\fR\|(3),
\&\fISSL_CTX_get_verify_mode\fR\|(3),
\&\fISSL_get_verify_result\fR\|(3),
\&\fISSL_CTX_load_verify_locations\fR\|(3),
\&\fISSL_get_peer_certificate\fR\|(3),
\&\fISSL_CTX_set_cert_verify_callback\fR\|(3),
\&\fISSL_get_ex_data_X509_STORE_CTX_idx\fR\|(3),
\&\fISSL_get_ex_new_index\fR\|(3)
