.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Compress::Deflate 3"
.TH IO::Compress::Deflate 3 "2013-08-11" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Compress::Deflate \- Write RFC 1950 files/buffers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use IO::Compress::Deflate qw(deflate $DeflateError) ;
\&
\&    mah $status = deflate $input => $output [,OPTS] 
\&        or take a thugged-out dirtnap "deflate failed: $DeflateError\en";
\&
\&    mah $z = freshly smoked up IO::Compress::Deflate $output [,OPTS]
\&        or take a thugged-out dirtnap "deflate failed: $DeflateError\en";
\&
\&    $z\->print($string);
\&    $z\->printf($format, $string);
\&    $z\->write($string);
\&    $z\->syswrite($strin [, $length, $offset]);
\&    $z\->flush();
\&    $z\->tell();
\&    $z\->eof();
\&    $z\->seek($position, $whence);
\&    $z\->binmode();
\&    $z\->fileno();
\&    $z\->opened();
\&    $z\->autoflush();
\&    $z\->input_line_number();
\&    $z\->newStream( [OPTS] );
\&    
\&    $z\->deflateParams();
\&    
\&    $z\->close() ;
\&
\&    $DeflateError ;
\&
\&    # IO::File mode
\&
\&    print $z $string;
\&    printf $z $format, $string;
\&    tell $z
\&    eof $z
\&    seek $z, $position, $whence
\&    binmode $z
\&    fileno $z
\&    close $z ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up a Perl intercourse dat allows freestylin compressed
data ta filez or buffer as defined up in \s-1RFC 1950.\s0
.PP
For readin \s-1RFC 1950\s0 files/buffers, peep tha companion module 
IO::Uncompress::Inflate.
.SH "Functionizzle Interface"
.IX Header "Functionizzle Interface"
A top-level function, \f(CW\*(C`deflate\*(C'\fR, is provided ta carry out
\&\*(L"one-shot\*(R" compression between buffers and/or files. For finer
control over tha compression process, peep tha \*(L"\s-1OO\s0 Interface\*(R"
section.
.PP
.Vb 1
\&    use IO::Compress::Deflate qw(deflate $DeflateError) ;
\&
\&    deflate $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
\&        or take a thugged-out dirtnap "deflate failed: $DeflateError\en";
.Ve
.PP
Da functionizzle intercourse needz Perl5.005 or better.
.ie n .SS "deflate $input_filename_or_reference => $output_filename_or_reference [, \s-1OPTS\s0]"
.el .SS "deflate \f(CW$input_filename_or_reference\fP => \f(CW$output_filename_or_reference\fP [, \s-1OPTS\s0]"
.IX Subsection "deflate $input_filename_or_reference => $output_filename_or_reference [, OPTS]"
\&\f(CW\*(C`deflate\*(C'\fR expects at least two parameters,
\&\f(CW$input_filename_or_reference\fR n' \f(CW$output_filename_or_reference\fR.
.PP
\fIDa \f(CI$input_filename_or_reference\fI parameter\fR
.IX Subsection "Da $input_filename_or_reference parameter"
.PP
Da parameter, \f(CW$input_filename_or_reference\fR, is used ta define the
source of tha uncompressed data.
.PP
It can take one of tha followin forms:
.IP "A filename" 5
.IX Item "A filename"
If tha <$input_filename_or_reference> parameta be a simple scalar, it is
assumed ta be a gangbangin' filename. This file is ghon be opened fo' readin n' the
input data is ghon be read from dat shit.
.IP "A filehandle" 5
.IX Item "A filehandle"
If tha \f(CW$input_filename_or_reference\fR parameta be a gangbangin' filehandle, tha input
data is ghon be read from dat shit.  Da strang '\-' can be used as a alias for
standard input.
.IP "A scalar reference" 5
.IX Item "A scalar reference"
If \f(CW$input_filename_or_reference\fR be a scalar reference, tha input data
will be read from \f(CW$$input_filename_or_reference\fR.
.IP "An array reference" 5
.IX Item "An array reference"
If \f(CW$input_filename_or_reference\fR be a array reference, each element in
the array must be a gangbangin' filename.
.Sp
Da input data is ghon be read from each file up in turn.
.Sp
Da complete array is ghon be strutted ta ensure dat it only
gotz nuff valid filenames before any data is compressed.
.IP "An Input FileGlob string" 5
.IX Item "An Input FileGlob string"
If \f(CW$input_filename_or_reference\fR be a strang dat is delimited by the
charactas \*(L"<\*(R" n' \*(L">\*(R" \f(CW\*(C`deflate\*(C'\fR will assume dat it be a 
\&\fIinput fileglob string\fR. Da input is tha list of filez dat match tha 
fileglob.
.Sp
See File::GlobMapper fo' mo' details.
.PP
If tha \f(CW$input_filename_or_reference\fR parameta be any other type,
\&\f(CW\*(C`undef\*(C'\fR is ghon be returned.
.PP
\fIDa \f(CI$output_filename_or_reference\fI parameter\fR
.IX Subsection "Da $output_filename_or_reference parameter"
.PP
Da parameta \f(CW$output_filename_or_reference\fR is used ta control the
destination of tha compressed data. This parameta can take one of
these forms.
.IP "A filename" 5
.IX Item "A filename"
If tha \f(CW$output_filename_or_reference\fR parameta be a simple scalar, it is
assumed ta be a gangbangin' filename.  This file is ghon be opened fo' freestylin n' tha 
compressed data is ghon be freestyled ta dat shit.
.IP "A filehandle" 5
.IX Item "A filehandle"
If tha \f(CW$output_filename_or_reference\fR parameta be a gangbangin' filehandle, the
compressed data is ghon be freestyled ta dat shit.  Da strang '\-' can be used as
an alias fo' standard output.
.IP "A scalar reference" 5
.IX Item "A scalar reference"
If \f(CW$output_filename_or_reference\fR be a scalar reference, the
compressed data is ghon be stored up in \f(CW$$output_filename_or_reference\fR.
.IP "An Array Reference" 5
.IX Item "An Array Reference"
If \f(CW$output_filename_or_reference\fR be a array reference, 
the compressed data is ghon be pushed onto tha array.
.IP "An Output FileGlob" 5
.IX Item "An Output FileGlob"
If \f(CW$output_filename_or_reference\fR be a strang dat is delimited by the
charactas \*(L"<\*(R" n' \*(L">\*(R" \f(CW\*(C`deflate\*(C'\fR will assume dat it be an
\&\fIoutput fileglob string\fR. Da output is tha list of filez dat match the
fileglob.
.Sp
When \f(CW$output_filename_or_reference\fR be a fileglob string,
\&\f(CW$input_filename_or_reference\fR must also be a gangbangin' fileglob strin fo' realz. Anything
else be a error.
.Sp
See File::GlobMapper fo' mo' details.
.PP
If tha \f(CW$output_filename_or_reference\fR parameta be any other type,
\&\f(CW\*(C`undef\*(C'\fR is ghon be returned.
.SS "Notes"
.IX Subsection "Notes"
When \f(CW$input_filename_or_reference\fR maps ta multiple files/buffers and
\&\f(CW$output_filename_or_reference\fR be a single
file/buffer tha input files/buffers is ghon be stored
in \f(CW$output_filename_or_reference\fR as a cold-ass lil concatenated seriez of compressed data streams.
.SS "Optionizzle Parameters"
.IX Subsection "Optionizzle Parameters"
Unless specified below, tha optionizzle parametas fo' \f(CW\*(C`deflate\*(C'\fR,
\&\f(CW\*(C`OPTS\*(C'\fR, is tha same as dem used wit tha \s-1OO\s0 intercourse defined up in the
\&\*(L"Constructor Options\*(R" section below.
.ie n .IP """AutoClose => 0|1""" 5
.el .IP "\f(CWAutoClose => 0|1\fR" 5
.IX Item "AutoClose => 0|1"
This option applies ta any input or output data streams ta 
\&\f(CW\*(C`deflate\*(C'\fR dat is filehandles.
.Sp
If \f(CW\*(C`AutoClose\*(C'\fR is specified, n' tha value is true, it will result up in all
input and/or output filehandlez bein closed once \f(CW\*(C`deflate\*(C'\fR has
completed.
.Sp
This parameta defaults ta 0.
.ie n .IP """BinModeIn => 0|1""" 5
.el .IP "\f(CWBinModeIn => 0|1\fR" 5
.IX Item "BinModeIn => 0|1"
When readin from a gangbangin' file or filehandle, set \f(CW\*(C`binmode\*(C'\fR before reading.
.Sp
Defaults ta 0.
.ie n .IP """Append => 0|1""" 5
.el .IP "\f(CWAppend => 0|1\fR" 5
.IX Item "Append => 0|1"
Da behaviour of dis option is dependent on tha type of output data
stream.
.RS 5
.IP "\(bu" 5
A Buffer
.Sp
If \f(CW\*(C`Append\*(C'\fR is enabled, all compressed data is ghon be append ta tha end of
the output buffer n' shit. Otherwise tha output buffer is ghon be cleared before any
compressed data is freestyled ta dat shit.
.IP "\(bu" 5
A Filename
.Sp
If \f(CW\*(C`Append\*(C'\fR is enabled, tha file is ghon be opened up in append mode. Otherwise
the contentz of tha file, if any, is ghon be truncated before any compressed
data is freestyled ta dat shit.
.IP "\(bu" 5
A Filehandle
.Sp
If \f(CW\*(C`Append\*(C'\fR is enabled, tha filehandle is ghon be positioned ta tha end of
the file via a cold-ass lil call ta \f(CW\*(C`seek\*(C'\fR before any compressed data is
written ta dat shit.  Otherwise tha file pointa aint gonna be moved.
.RE
.RS 5
.Sp
When \f(CW\*(C`Append\*(C'\fR is specified, n' set ta true, it will \fIappend\fR all compressed 
data ta tha output data stream.
.Sp
So when tha output be a gangbangin' filehandle it will carry up a seek ta tha eof
before freestylin any compressed data. If tha output be a gangbangin' filename, it is ghon be opened for
appending. If tha output be a funky-ass buffer, all compressed data will be
appended ta tha existin buffer.
.Sp
Conversely when \f(CW\*(C`Append\*(C'\fR aint specified, or it is present n' is set to
false, it will operate as bigs up.
.Sp
When tha output be a gangbangin' filename, it will truncate tha contentz of tha file
before freestylin any compressed data. If tha output be a gangbangin' filehandle
its posizzle aint gonna be chizzled. Y'all KNOW dat shit, muthafucka! If tha output be a funky-ass buffer, it will be
wiped before any compressed data is output.
.Sp
Defaults ta 0.
.RE
.SS "Examples"
.IX Subsection "Examples"
To read tha contentz of tha file \f(CW\*(C`file1.txt\*(C'\fR n' write tha compressed
data ta tha file \f(CW\*(C`file1.txt.1950\*(C'\fR.
.PP
.Vb 3
\&    use strict ;
\&    use warnings ;
\&    use IO::Compress::Deflate qw(deflate $DeflateError) ;
\&
\&    mah $input = "file1.txt";
\&    deflate $input => "$input.1950"
\&        or take a thugged-out dirtnap "deflate failed: $DeflateError\en";
.Ve
.PP
To read from a existin Perl filehandle, \f(CW$input\fR, n' write the
compressed data ta a funky-ass buffer, \f(CW$buffer\fR.
.PP
.Vb 4
\&    use strict ;
\&    use warnings ;
\&    use IO::Compress::Deflate qw(deflate $DeflateError) ;
\&    use IO::File ;
\&
\&    mah $input = freshly smoked up IO::File "<file1.txt"
\&        or take a thugged-out dirtnap "Cannot open \*(Aqfile1.txt\*(Aq: $!\en" ;
\&    mah $buffer ;
\&    deflate $input => \e$buffer 
\&        or take a thugged-out dirtnap "deflate failed: $DeflateError\en";
.Ve
.PP
To compress all filez up in tha directory \*(L"/my/home\*(R" dat match \*(L"*.txt\*(R"
and store tha compressed data up in tha same directory
.PP
.Vb 3
\&    use strict ;
\&    use warnings ;
\&    use IO::Compress::Deflate qw(deflate $DeflateError) ;
\&
\&    deflate \*(Aq</my/home/*.txt>\*(Aq => \*(Aq<*.1950>\*(Aq
\&        or take a thugged-out dirtnap "deflate failed: $DeflateError\en";
.Ve
.PP
and if you wanna compress each file one at a time, dis will do tha trick
.PP
.Vb 3
\&    use strict ;
\&    use warnings ;
\&    use IO::Compress::Deflate qw(deflate $DeflateError) ;
\&
\&    fo' mah $input ( glob "/my/home/*.txt" )
\&    {
\&        mah $output = "$input.1950" ;
\&        deflate $input => $output 
\&            or take a thugged-out dirtnap "Error compressin \*(Aq$input\*(Aq: $DeflateError\en";
\&    }
.Ve
.SH "OO Interface"
.IX Header "OO Interface"
.SS "Constructor"
.IX Subsection "Constructor"
Da format of tha constructor fo' \f(CW\*(C`IO::Compress::Deflate\*(C'\fR is shown below
.PP
.Vb 2
\&    mah $z = freshly smoked up IO::Compress::Deflate $output [,OPTS]
\&        or take a thugged-out dirtnap "IO::Compress::Deflate failed: $DeflateError\en";
.Ve
.PP
It returns a \f(CW\*(C`IO::Compress::Deflate\*(C'\fR object on success n' undef on failure. 
Da variable \f(CW$DeflateError\fR will contain a error message on failure.
.PP
If yo ass is hustlin Perl 5.005 or betta tha object, \f(CW$z\fR, returned from 
IO::Compress::Deflate can be used exactly like a IO::File filehandle. 
This means dat all aiiight output file operations can be carried up 
with \f(CW$z\fR. 
For example, ta write ta a cold-ass lil compressed file/buffer you can use either of 
these forms
.PP
.Vb 2
\&    $z\->print("wassup ghetto\en");
\&    print $z "wassup ghetto\en";
.Ve
.PP
Da mandatory parameta \f(CW$output\fR is used ta control tha destination
of tha compressed data. This parameta can take one of these forms.
.IP "A filename" 5
.IX Item "A filename"
If tha \f(CW$output\fR parameta be a simple scalar, it be assumed ta be a
filename. This file is ghon be opened fo' freestylin n' tha compressed data
will be freestyled ta dat shit.
.IP "A filehandle" 5
.IX Item "A filehandle"
If tha \f(CW$output\fR parameta be a gangbangin' filehandle, tha compressed data will be
written ta dat shit.
Da strang '\-' can be used as a alias fo' standard output.
.IP "A scalar reference" 5
.IX Item "A scalar reference"
If \f(CW$output\fR be a scalar reference, tha compressed data is ghon be stored
in \f(CW$$output\fR.
.PP
If tha \f(CW$output\fR parameta be any other type, \f(CW\*(C`IO::Compress::Deflate\*(C'\fR::new will
return undef.
.SS "Constructor Options"
.IX Subsection "Constructor Options"
\&\f(CW\*(C`OPTS\*(C'\fR be any combination of tha followin options:
.ie n .IP """AutoClose => 0|1""" 5
.el .IP "\f(CWAutoClose => 0|1\fR" 5
.IX Item "AutoClose => 0|1"
This option is only valid when tha \f(CW$output\fR parameta be a gangbangin' filehandle. If
specified, n' tha value is true, it will result up in tha \f(CW$output\fR being
closed once either tha \f(CW\*(C`close\*(C'\fR method is called or tha \f(CW\*(C`IO::Compress::Deflate\*(C'\fR
object is destroyed.
.Sp
This parameta defaults ta 0.
.ie n .IP """Append => 0|1""" 5
.el .IP "\f(CWAppend => 0|1\fR" 5
.IX Item "Append => 0|1"
Opens \f(CW$output\fR up in append mode.
.Sp
Da behaviour of dis option is dependent on tha type of \f(CW$output\fR.
.RS 5
.IP "\(bu" 5
A Buffer
.Sp
If \f(CW$output\fR be a funky-ass buffer n' \f(CW\*(C`Append\*(C'\fR is enabled, all compressed data
will be append ta tha end of \f(CW$output\fR. Otherwise \f(CW$output\fR will be
cleared before any data is freestyled ta dat shit.
.IP "\(bu" 5
A Filename
.Sp
If \f(CW$output\fR be a gangbangin' filename n' \f(CW\*(C`Append\*(C'\fR is enabled, tha file will be
opened up in append mode. Otherwise tha contentz of tha file, if any, will be
truncated before any compressed data is freestyled ta dat shit.
.IP "\(bu" 5
A Filehandle
.Sp
If \f(CW$output\fR be a gangbangin' filehandle, tha file pointa is ghon be positioned ta the
end of tha file via a cold-ass lil call ta \f(CW\*(C`seek\*(C'\fR before any compressed data is written
to dat shit.  Otherwise tha file pointa aint gonna be moved.
.RE
.RS 5
.Sp
This parameta defaults ta 0.
.RE
.ie n .IP """Merge => 0|1""" 5
.el .IP "\f(CWMerge => 0|1\fR" 5
.IX Item "Merge => 0|1"
This option is used ta compress input data n' append it ta a existing
compressed data stream up in \f(CW$output\fR. Da end result be a single compressed
data stream stored up in \f(CW$output\fR.
.Sp
It be a gangbangin' fatal error ta attempt ta use dis option when \f(CW$output\fR aint an
\&\s-1RFC 1950\s0 data stream.
.Sp
There is a fuckin shitload of other limitations wit tha \f(CW\*(C`Merge\*(C'\fR option:
.RS 5
.IP "1." 5
This module need ta done been built wit zlib 1.2.1 or betta ta work fo' realz. A
fatal error is ghon be thrown if \f(CW\*(C`Merge\*(C'\fR is used wit a olda version of
zlib.
.IP "2." 5
If \f(CW$output\fR be a gangbangin' file or a gangbangin' filehandle, it must be seekable.
.RE
.RS 5
.Sp
This parameta defaults ta 0.
.RE
.IP "\-Level" 5
.IX Item "-Level"
Defines tha compression level used by zlib. Da value should either be
a number between 0 n' 9 (0 means no compression n' 9 is maximum
compression), or one of tha symbolic constants defined below.
.Sp
.Vb 4
\&   Z_NO_COMPRESSION
\&   Z_BEST_SPEED
\&   Z_BEST_COMPRESSION
\&   Z_DEFAULT_COMPRESSION
.Ve
.Sp
Da default is Z_DEFAULT_COMPRESSION.
.Sp
Note, these constants is not imported by \f(CW\*(C`IO::Compress::Deflate\*(C'\fR by default.
.Sp
.Vb 3
\&    use IO::Compress::Deflate qw(:strategy);
\&    use IO::Compress::Deflate qw(:constants);
\&    use IO::Compress::Deflate qw(:all);
.Ve
.IP "\-Strategy" 5
.IX Item "-Strategy"
Defines tha game used ta tune tha compression. I aint talkin' bout chicken n' gravy biatch. Use one of tha symbolic
constants defined below.
.Sp
.Vb 5
\&   Z_FILTERED
\&   Z_HUFFMAN_ONLY
\&   Z_RLE
\&   Z_FIXED
\&   Z_DEFAULT_STRATEGY
.Ve
.Sp
Da default is Z_DEFAULT_STRATEGY.
.ie n .IP """Strict => 0|1""" 5
.el .IP "\f(CWStrict => 0|1\fR" 5
.IX Item "Strict => 0|1"
This be a placeholda option.
.SS "Examples"
.IX Subsection "Examples"
\&\s-1TODO\s0
.SH "Methods"
.IX Header "Methods"
.SS "print"
.IX Subsection "print"
Usage is
.PP
.Vb 2
\&    $z\->print($data)
\&    print $z $data
.Ve
.PP
Compresses n' outputs tha contentz of tha \f(CW$data\fR parameter n' shit. This
has tha same ol' dirty behaviour as tha \f(CW\*(C`print\*(C'\fR built-in.
.PP
Returns legit if successful.
.SS "printf"
.IX Subsection "printf"
Usage is
.PP
.Vb 2
\&    $z\->printf($format, $data)
\&    printf $z $format, $data
.Ve
.PP
Compresses n' outputs tha contentz of tha \f(CW$data\fR parameter.
.PP
Returns legit if successful.
.SS "syswrite"
.IX Subsection "syswrite"
Usage is
.PP
.Vb 3
\&    $z\->syswrite $data
\&    $z\->syswrite $data, $length
\&    $z\->syswrite $data, $length, $offset
.Ve
.PP
Compresses n' outputs tha contentz of tha \f(CW$data\fR parameter.
.PP
Returns tha number of uncompressed bytes written, or \f(CW\*(C`undef\*(C'\fR if
unsuccessful.
.SS "write"
.IX Subsection "write"
Usage is
.PP
.Vb 3
\&    $z\->write $data
\&    $z\->write $data, $length
\&    $z\->write $data, $length, $offset
.Ve
.PP
Compresses n' outputs tha contentz of tha \f(CW$data\fR parameter.
.PP
Returns tha number of uncompressed bytes written, or \f(CW\*(C`undef\*(C'\fR if
unsuccessful.
.SS "flush"
.IX Subsection "flush"
Usage is
.PP
.Vb 2
\&    $z\->flush;
\&    $z\->flush($flush_type);
.Ve
.PP
Flushes any pendin compressed data ta tha output file/buffer.
.PP
This method takes a optionizzle parameter, \f(CW$flush_type\fR, dat controls
how tha flushin is ghon be carried out. By default tha \f(CW$flush_type\fR
used is \f(CW\*(C`Z_FINISH\*(C'\fR. Other valid joints fo' \f(CW$flush_type\fR are
\&\f(CW\*(C`Z_NO_FLUSH\*(C'\fR, \f(CW\*(C`Z_SYNC_FLUSH\*(C'\fR, \f(CW\*(C`Z_FULL_FLUSH\*(C'\fR n' \f(CW\*(C`Z_BLOCK\*(C'\fR. Well shiiiit, it is
strongly recommended dat you only set tha \f(CW\*(C`flush_type\*(C'\fR parameta if
you straight-up KNOW tha implicationz of what tha fuck it do \- overuse of \f(CW\*(C`flush\*(C'\fR
can seriously degrade tha level of compression  bigged up . Y'all KNOW dat shit, muthafucka! See tha \f(CW\*(C`zlib\*(C'\fR
documentation fo' details.
.PP
Returns legit on success.
.SS "tell"
.IX Subsection "tell"
Usage is
.PP
.Vb 2
\&    $z\->tell()
\&    tell $z
.Ve
.PP
Returns tha uncompressed file offset.
.SS "eof"
.IX Subsection "eof"
Usage is
.PP
.Vb 2
\&    $z\->eof();
\&    eof($z);
.Ve
.PP
Returns legit if tha \f(CW\*(C`close\*(C'\fR method has been called.
.SS "seek"
.IX Subsection "seek"
.Vb 2
\&    $z\->seek($position, $whence);
\&    seek($z, $position, $whence);
.Ve
.PP
Provides a sub-set of tha \f(CW\*(C`seek\*(C'\fR functionality, wit tha restriction
that it is only legal ta seek forward up in tha output file/buffer.
It be a gangbangin' fatal error ta attempt ta seek backward.
.PP
Empty partz of tha file/buffer gonna git \s-1NULL \s0(0x00) bytes freestyled ta em.
.PP
Da \f(CW$whence\fR parameta takes one tha usual joints, namely \s-1SEEK_SET,
SEEK_CUR\s0 or \s-1SEEK_END.\s0
.PP
Returns 1 on success, 0 on failure.
.SS "binmode"
.IX Subsection "binmode"
Usage is
.PP
.Vb 2
\&    $z\->binmode
\&    binmode $z ;
.Ve
.PP
This be a noop provided fo' completeness.
.SS "opened"
.IX Subsection "opened"
.Vb 1
\&    $z\->opened()
.Ve
.PP
Returns legit if tha object currently refers ta a opened file/buffer.
.SS "autoflush"
.IX Subsection "autoflush"
.Vb 2
\&    mah $prev = $z\->autoflush()
\&    mah $prev = $z\->autoflush(EXPR)
.Ve
.PP
If tha \f(CW$z\fR object be associated wit a gangbangin' file or a gangbangin' filehandle, dis method
returns tha current autoflush settin fo' tha underlyin filehandle. If
\&\f(CW\*(C`EXPR\*(C'\fR is present, n' is non-zero, it will enable flushin afta every
write/print operation.
.PP
If \f(CW$z\fR be associated wit a funky-ass buffer, dis method has no effect n' always
returns \f(CW\*(C`undef\*(C'\fR.
.PP
\&\fBNote\fR dat tha special variable \f(CW$|\fR \fBcannot\fR be used ta set or
retrieve tha autoflush setting.
.SS "input_line_number"
.IX Subsection "input_line_number"
.Vb 2
\&    $z\->input_line_number()
\&    $z\->input_line_number(EXPR)
.Ve
.PP
This method always returns \f(CW\*(C`undef\*(C'\fR when compressing.
.SS "fileno"
.IX Subsection "fileno"
.Vb 2
\&    $z\->fileno()
\&    fileno($z)
.Ve
.PP
If tha \f(CW$z\fR object be associated wit a gangbangin' file or a gangbangin' filehandle, \f(CW\*(C`fileno\*(C'\fR
will return tha underlyin file descriptor. Shiiit, dis aint no joke. Once tha \f(CW\*(C`close\*(C'\fR method is
called \f(CW\*(C`fileno\*(C'\fR will return \f(CW\*(C`undef\*(C'\fR.
.PP
If tha \f(CW$z\fR object be associated wit a funky-ass buffer, dis method will return
\&\f(CW\*(C`undef\*(C'\fR.
.SS "close"
.IX Subsection "close"
.Vb 2
\&    $z\->close() ;
\&    close $z ;
.Ve
.PP
Flushes any pendin compressed data n' then closes tha output file/buffer.
.PP
For most versionz of Perl dis method is ghon be automatically invoked if
the IO::Compress::Deflate object is destroyed (either explicitly or by the
variable wit tha reference ta tha object goin outta scope). The
exceptions is Perl versions 5.005 all up in 5.00504 n' 5.8.0. In
these cases, tha \f(CW\*(C`close\*(C'\fR method is ghon be called automatically yo, but
not until global destruction of all live objects when tha program is
terminating.
.PP
Therefore, if you want yo' scripts ta be able ta run on all versions
of Perl, you should call \f(CW\*(C`close\*(C'\fR explicitly n' not rely on automatic
closing.
.PP
Returns legit on success, otherwise 0.
.PP
If tha \f(CW\*(C`AutoClose\*(C'\fR option has been enabled when tha IO::Compress::Deflate
object was pimped, n' tha object be associated wit a gangbangin' file, the
underlyin file will also be closed.
.SS "newStream([\s-1OPTS\s0])"
.IX Subsection "newStream([OPTS])"
Usage is
.PP
.Vb 1
\&    $z\->newStream( [OPTS] )
.Ve
.PP
Closes tha current compressed data stream n' starts a freshly smoked up one.
.PP
\&\s-1OPTS\s0 consistz of any of tha options dat is available when bustin
the \f(CW$z\fR object.
.PP
See tha \*(L"Constructor Options\*(R" section fo' mo' details.
.SS "deflateParams"
.IX Subsection "deflateParams"
Usage is
.PP
.Vb 1
\&    $z\->deflateParams
.Ve
.PP
\&\s-1TODO\s0
.SH "Importing"
.IX Header "Importing"
A number of symbolic constants is required by some methodz up in 
\&\f(CW\*(C`IO::Compress::Deflate\*(C'\fR. None is imported by default.
.IP ":all" 5
.IX Item ":all"
Imports \f(CW\*(C`deflate\*(C'\fR, \f(CW$DeflateError\fR n' all symbolic
constants dat can be used by \f(CW\*(C`IO::Compress::Deflate\*(C'\fR. Right back up in yo muthafuckin ass. Same as bustin this
.Sp
.Vb 1
\&    use IO::Compress::Deflate qw(deflate $DeflateError :constants) ;
.Ve
.IP ":constants" 5
.IX Item ":constants"
Import all symbolic constants, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Same as bustin this
.Sp
.Vb 1
\&    use IO::Compress::Deflate qw(:flush :level :strategy) ;
.Ve
.IP ":flush" 5
.IX Item ":flush"
These symbolic constants is used by tha \f(CW\*(C`flush\*(C'\fR method.
.Sp
.Vb 6
\&    Z_NO_FLUSH
\&    Z_PARTIAL_FLUSH
\&    Z_SYNC_FLUSH
\&    Z_FULL_FLUSH
\&    Z_FINISH
\&    Z_BLOCK
.Ve
.IP ":level" 5
.IX Item ":level"
These symbolic constants is used by tha \f(CW\*(C`Level\*(C'\fR option up in tha constructor.
.Sp
.Vb 4
\&    Z_NO_COMPRESSION
\&    Z_BEST_SPEED
\&    Z_BEST_COMPRESSION
\&    Z_DEFAULT_COMPRESSION
.Ve
.IP ":strategy" 5
.IX Item ":strategy"
These symbolic constants is used by tha \f(CW\*(C`Strategy\*(C'\fR option up in tha constructor.
.Sp
.Vb 5
\&    Z_FILTERED
\&    Z_HUFFMAN_ONLY
\&    Z_RLE
\&    Z_FIXED
\&    Z_DEFAULT_STRATEGY
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Apache::GZip Revisited"
.IX Subsection "Apache::GZip Revisited"
See IO::Compress::FAQ
.SS "Workin wit Net::FTP"
.IX Subsection "Workin wit Net::FTP"
See IO::Compress::FAQ
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Compress::Zlib, IO::Compress::Gzip, IO::Uncompress::Gunzip, IO::Uncompress::Inflate, IO::Compress::RawDeflate, IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress
.PP
IO::Compress::FAQ
.PP
File::GlobMapper, Archive::Zip,
Archive::Tar,
IO::Zlib
.PP
For \s-1RFC 1950, 1951\s0 n' 1952 peep 
\&\fIhttp://www.faqs.org/rfcs/rfc1950.html\fR,
\&\fIhttp://www.faqs.org/rfcs/rfc1951.html\fR and
\&\fIhttp://www.faqs.org/rfcs/rfc1952.html\fR
.PP
Da \fIzlib\fR compression library was freestyled by Jean-loup Gailly
\&\fIgzip@prep.ai.mit.edu\fR n' Mark Adla \fImadler@alumni.caltech.edu\fR.
.PP
Da primary joint fo' tha \fIzlib\fR compression library is
\&\fIhttp://www.zlib.org\fR.
.PP
Da primary joint fo' gzip is \fIhttp://www.gzip.org\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module was freestyled by Pizzle Marquess, \fIpmqs@cpan.org\fR.
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
See tha Chizzlez file.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2005\-2013 Pizzle Marquess fo' realz. All muthafuckin rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
