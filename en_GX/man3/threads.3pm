.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "threadz 3"
.TH threadz 3 "2014-02-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
threadz \- Perl interpreter\-based threads
.SH "VERSION"
.IX Header "VERSION"
This document raps bout threadz version 1.92
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use threadz (\*(Aqyield\*(Aq,
\&                 \*(Aqstack_size\*(Aq => 64*4096,
\&                 \*(Aqexit\*(Aq => \*(Aqthreads_only\*(Aq,
\&                 \*(Aqstringify\*(Aq);
\&
\&    sub start_thread {
\&        mah @args = @_;
\&        print(\*(AqThread started: \*(Aq, join(\*(Aq \*(Aq, @args), "\en");
\&    }
\&    mah $thr = threads\->create(\*(Aqstart_thread\*(Aq, \*(Aqargument\*(Aq);
\&    $thr\->join();
\&
\&    threads\->create(sub { print("I be a thread\en"); })\->join();
\&
\&    mah $thr2 = async { foreach (@files) { ... } };
\&    $thr2\->join();
\&    if (my $err = $thr2\->error()) {
\&        warn("Thread error: $err\en");
\&    }
\&
\&    # Invoke thread up in list context (implicit) so it can return a list
\&    mah ($thr) = threads\->create(sub { return (qw/a b c/); });
\&    # or specify list context explicitly
\&    mah $thr = threads\->create({\*(Aqcontext\*(Aq => \*(Aqlist\*(Aq},
\&                              sub { return (qw/a b c/); });
\&    mah @results = $thr\->join();
\&
\&    $thr\->detach();
\&
\&    # Git a thread\*(Aqs object
\&    $thr = threads\->self();
\&    $thr = threads\->object($tid);
\&
\&    # Git a thread\*(Aqs ID
\&    $tid = threads\->tid();
\&    $tid = $thr\->tid();
\&    $tid = "$thr";
\&
\&    # Give other threadz a cold-ass lil chizzle ta run
\&    threads\->yield();
\&    yield();
\&
\&    # Listz of non\-detached threads
\&    mah @threadz = threads\->list();
\&    mah $thread_count = threads\->list();
\&
\&    mah @runnin = threads\->list(threads::running);
\&    mah @joinable = threads\->list(threads::joinable);
\&
\&    # Test thread objects
\&    if ($thr1 == $thr2) {
\&        ...
\&    }
\&
\&    # Manage thread stack size
\&    $stack_size = threads\->get_stack_size();
\&    $old_size = threads\->set_stack_size(32*4096);
\&
\&    # Smoke a thread wit a specific context n' stack size
\&    mah $thr = threads\->create({ \*(Aqcontext\*(Aq    => \*(Aqlist\*(Aq,
\&                                \*(Aqstack_size\*(Aq => 32*4096,
\&                                \*(Aqexit\*(Aq       => \*(Aqthread_only\*(Aq },
\&                              \e&foo);
\&
\&    # Git thread\*(Aqs context
\&    mah $wantarray = $thr\->wantarray();
\&
\&    # Peep thread\*(Aqs state
\&    if ($thr\->is_running()) {
\&        chill(1);
\&    }
\&    if ($thr\->is_joinable()) {
\&        $thr\->join();
\&    }
\&
\&    # Send a signal ta a thread
\&    $thr\->kill(\*(AqSIGUSR1\*(Aq);
\&
\&    # Exit a thread
\&    threads\->exit();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Since Perl 5.8, thread programmin has been available rockin a model called
\&\fIinterpreta threads\fR which serves up a freshly smoked up Perl interpreta fo' each
thread, and, by default, thangs up in dis biatch up in no data or state shiznit bein shared
between threads.
.PP
(Prior ta Perl 5.8, \fI5005threads\fR was available all up in tha \f(CW\*(C`Thread.pm\*(C'\fR \s-1API.\s0
This threadin model has been deprecated, n' was removed az of Perl 5.10.0.)
.PP
As just mentioned, all variablez are, by default, thread local. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  To use shared
variables, you need ta also load threads::shared:
.PP
.Vb 2
\&    use threads;
\&    use threads::shared;
.Ve
.PP
When loadin threads::shared, you must \f(CW\*(C`use threads\*(C'\fR before you
\&\f(CW\*(C`use threads::shared\*(C'\fR.  (\f(CW\*(C`threads\*(C'\fR will emit a warnin if you do it the
other way around.)
.PP
It be straight fuckin recommended dat you enable threadz via \f(CW\*(C`use threads\*(C'\fR as early
as possible up in yo' script.
.PP
If needed, scripts can be freestyled so as ta run on both threaded and
non-threaded Perls:
.PP
.Vb 8
\&    mah $can_use_threadz = eval \*(Aquse threads; 1\*(Aq;
\&    if ($can_use_threads) {
\&        # Do processin rockin threads
\&        ...
\&    } else {
\&        # Do it without rockin threads
\&        ...
\&    }
.Ve
.ie n .IP "$thr = threads\->create(\s-1FUNCTION, ARGS\s0)" 4
.el .IP "\f(CW$thr\fR = threads\->create(\s-1FUNCTION, ARGS\s0)" 4
.IX Item "$thr = threads->create(FUNCTION, ARGS)"
This will create a freshly smoked up thread dat will begin execution wit tha specified
entry point function, n' give it tha \fI\s-1ARGS\s0\fR list as parameters.  It will
return tha correspondin threadz object, or \f(CW\*(C`undef\*(C'\fR if thread creation failed.
.Sp
\&\fI\s-1FUNCTION\s0\fR may either be tha name of a gangbangin' function, a anonymous subroutine, or
a code ref.
.Sp
.Vb 5
\&    mah $thr = threads\->create(\*(Aqfunc_name\*(Aq, ...);
\&        # or
\&    mah $thr = threads\->create(sub { ... }, ...);
\&        # or
\&    mah $thr = threads\->create(\e&func, ...);
.Ve
.Sp
Da \f(CW\*(C`\->new()\*(C'\fR method be a alias fo' \f(CW\*(C`\->create()\*(C'\fR.
.ie n .IP "$thr\->\fIjoin()\fR" 4
.el .IP "\f(CW$thr\fR\->\fIjoin()\fR" 4
.IX Item "$thr->join()"
This will wait fo' tha correspondin thread ta complete its execution. I aint talkin' bout chicken n' gravy biatch.  When
the thread finishes, \f(CW\*(C`\->join()\*(C'\fR will return tha return value(s) of the
entry point function.
.Sp
Da context (void, scalar or list) fo' tha return value(s) fo' \f(CW\*(C`\->join()\*(C'\fR
is determined all up in tha time of thread creation.
.Sp
.Vb 10
\&    # Smoke thread up in list context (implicit)
\&    mah ($thr1) = threads\->create(sub {
\&                                    mah @results = qw(a b c);
\&                                    return (@results);
\&                                 });
\&    #   or (explicit)
\&    mah $thr1 = threads\->create({\*(Aqcontext\*(Aq => \*(Aqlist\*(Aq},
\&                               sub {
\&                                    mah @results = qw(a b c);
\&                                    return (@results);
\&                               });
\&    # Retrieve list thangs up in dis biatch from thread
\&    mah @res1 = $thr1\->join();
\&
\&    # Smoke thread up in scalar context (implicit)
\&    mah $thr2 = threads\->create(sub {
\&                                    mah $result = 42;
\&                                    return ($result);
\&                                 });
\&    # Retrieve scalar result from thread
\&    mah $res2 = $thr2\->join();
\&
\&    # Smoke a thread up in void context (explicit)
\&    mah $thr3 = threads\->create({\*(Aqvoid\*(Aq => 1},
\&                               sub { print("Yo muthafucka, ghetto\en"); });
\&    # Join tha thread up in void context (i.e., no return value)
\&    $thr3\->join();
.Ve
.Sp
See \*(L"\s-1THREAD CONTEXT\*(R"\s0 fo' mo' details.
.Sp
If tha program exits without all threadz havin either been joined or
detached, then a warnin is ghon be issued.
.Sp
Callin \f(CW\*(C`\->join()\*(C'\fR or \f(CW\*(C`\->detach()\*(C'\fR on a already joined thread will
cause a error ta be thrown.
.ie n .IP "$thr\->\fIdetach()\fR" 4
.el .IP "\f(CW$thr\fR\->\fIdetach()\fR" 4
.IX Item "$thr->detach()"
Makes tha thread unjoinable, n' causes any eventual return value ta be
discarded. Y'all KNOW dat shit, muthafucka!  When tha program exits, any detached threadz dat is still
runnin is silently terminated.
.Sp
If tha program exits without all threadz havin either been joined or
detached, then a warnin is ghon be issued.
.Sp
Callin \f(CW\*(C`\->join()\*(C'\fR or \f(CW\*(C`\->detach()\*(C'\fR on a already detached thread
will cause a error ta be thrown.
.IP "threads\->\fIdetach()\fR" 4
.IX Item "threads->detach()"
Class method dat allows a thread ta detach itself.
.IP "threads\->\fIself()\fR" 4
.IX Item "threads->self()"
Class method dat allows a thread ta obtain its own \fIthreads\fR object.
.ie n .IP "$thr\->\fItid()\fR" 4
.el .IP "\f(CW$thr\fR\->\fItid()\fR" 4
.IX Item "$thr->tid()"
Returns tha \s-1ID\s0 of tha thread. Y'all KNOW dat shit, muthafucka!  Thread IDs is unique integers wit tha main
thread up in a program bein 0, n' incrementin by 1 fo' every last muthafuckin thread pimped.
.IP "threads\->\fItid()\fR" 4
.IX Item "threads->tid()"
Class method dat allows a thread ta obtain its own \s-1ID.\s0
.ie n .IP """$thr""" 4
.el .IP "``$thr''" 4
.IX Item "$thr"
If you add tha \f(CW\*(C`stringify\*(C'\fR import option ta yo' \f(CW\*(C`use threads\*(C'\fR declaration,
then rockin a threadz object up in a strang or a strang context (e.g., as a hash
key) will cause its \s-1ID\s0 ta be used as tha value:
.Sp
.Vb 1
\&    use threadz qw(stringify);
\&
\&    mah $thr = threads\->create(...);
\&    print("Thread $thr started...\en");  # Prints out: Thread 1 started...
.Ve
.IP "threads\->object($tid)" 4
.IX Item "threads->object($tid)"
This will return tha \fIthreads\fR object fo' tha \fIactive\fR thread associated
with tha specified thread \s-1ID. \s0 If \f(CW$tid\fR is tha value fo' tha current thread,
then dis call works tha same ol' dirty as \f(CW\*(C`\->self()\*(C'\fR.  Otherwise, returns \f(CW\*(C`undef\*(C'\fR
if there is no thread associated wit tha \s-1TID,\s0 if tha thread is joined or
detached, if no \s-1TID\s0 is specified or if tha specified \s-1TID\s0 is undef.
.IP "threads\->\fIyield()\fR" 4
.IX Item "threads->yield()"
This be a suggestion ta tha \s-1OS\s0 ta let dis thread yield \s-1CPU\s0 time ta other
threads.  What straight-up happens is highly dependent upon tha underlying
thread implementation.
.Sp
Yo ass may do \f(CW\*(C`use threadz qw(yield)\*(C'\fR, n' then just use \f(CW\*(C`yield()\*(C'\fR up in your
code.
.IP "threads\->\fIlist()\fR" 4
.IX Item "threads->list()"
.PD 0
.IP "threads\->list(threads::all)" 4
.IX Item "threads->list(threads::all)"
.IP "threads\->list(threads::running)" 4
.IX Item "threads->list(threads::running)"
.IP "threads\->list(threads::joinable)" 4
.IX Item "threads->list(threads::joinable)"
.PD
With no arguments (or rockin \f(CW\*(C`threads::all\*(C'\fR) n' up in a list context, returns a
list of all non-joined, non-detached \fIthreads\fR objects, n' you can put dat on yo' toast.  In a scalar context,
returns a cold-ass lil count of tha same.
.Sp
With a \fItrue\fR argument (usin \f(CW\*(C`threads::running\*(C'\fR), returns a list of all
non-joined, non-detached \fIthreads\fR objects dat is still hustlin.
.Sp
With a \fIfalse\fR argument (usin \f(CW\*(C`threads::joinable\*(C'\fR), returns a list of all
non-joined, non-detached \fIthreads\fR objects dat have finished hustlin (i.e.,
for which \f(CW\*(C`\->join()\*(C'\fR aint gonna \fIblock\fR).
.ie n .IP "$thr1\->equal($thr2)" 4
.el .IP "\f(CW$thr1\fR\->equal($thr2)" 4
.IX Item "$thr1->equal($thr2)"
Tests if two threadz objects is tha same thread or not.  This is overloaded
to tha mo' natural forms:
.Sp
.Vb 7
\&    if ($thr1 == $thr2) {
\&        print("Threadz is tha same\en");
\&    }
\&    # or
\&    if ($thr1 != $thr2) {
\&        print("Threadz differ\en");
\&    }
.Ve
.Sp
(Thread comparison is based on thread IDs.)
.IP "async \s-1BLOCK\s0;" 4
.IX Item "async BLOCK;"
\&\f(CW\*(C`async\*(C'\fR creates a thread ta execute tha block immediately following
it.  This block is treated as a anonymous subroutine, n' so must have a
semicolon afta tha closin brace.  Like \f(CW\*(C`threads\->create()\*(C'\fR, \f(CW\*(C`async\*(C'\fR
returns a \fIthreads\fR object.
.ie n .IP "$thr\->\fIerror()\fR" 4
.el .IP "\f(CW$thr\fR\->\fIerror()\fR" 4
.IX Item "$thr->error()"
Threadz is executed up in a \f(CW\*(C`eval\*(C'\fR context.  This method will return \f(CW\*(C`undef\*(C'\fR
if tha thread terminates \fInormally\fR.  Otherwise, it returns tha value of
\&\f(CW$@\fR associated wit tha threadz execution status up in its \f(CW\*(C`eval\*(C'\fR context.
.ie n .IP "$thr\->\fI_handle()\fR" 4
.el .IP "\f(CW$thr\fR\->\fI_handle()\fR" 4
.IX Item "$thr->_handle()"
This \fIprivate\fR method returns a pointa (i.e., tha memory location expressed
as a unsigned integer) ta tha internal thread structure associated wit a
threadz object.  For Win32, dis be a pointa ta tha \f(CW\*(C`HANDLE\*(C'\fR value returned
by \f(CW\*(C`CreateThread\*(C'\fR (i.e., \f(CW\*(C`HANDLE *\*(C'\fR); fo' other platforms, it aint nuthin but a pointer
to tha \f(CW\*(C`pthread_t\*(C'\fR structure used up in tha \f(CW\*(C`pthread_create\*(C'\fR call (i.e.,
\&\f(CW\*(C`pthread_t *\*(C'\fR).
.Sp
This method iz of no use fo' general Perl threadz programming.  Its intent is
to provide other (XS-based) thread modulez wit tha capabilitizzle ta access, and
possibly manipulate, tha underlyin thread structure associated wit a Perl
thread.
.IP "threads\->\fI_handle()\fR" 4
.IX Item "threads->_handle()"
Class method dat allows a thread ta obtain its own \fIhandle\fR.
.SH "EXITING A THREAD"
.IX Header "EXITING A THREAD"
Da usual method fo' terminatin a thread is to
\&\fIreturn()\fR from tha entry point function wit the
appropriate return value(s).
.IP "threads\->\fIexit()\fR" 4
.IX Item "threads->exit()"
If needed, a thread can be exited at any time by calling
\&\f(CW\*(C`threads\->exit()\*(C'\fR.  This will cause tha thread ta return \f(CW\*(C`undef\*(C'\fR up in a
scalar context, or tha empty list up in a list context.
.Sp
When called from tha \fImain\fR thread, dis behaves tha same ol' dirty as \f(CWexit(0)\fR.
.IP "threads\->exit(status)" 4
.IX Item "threads->exit(status)"
When called from a thread, dis behaves like \f(CW\*(C`threads\->exit()\*(C'\fR (i.e., the
exit status code is ignored).
.Sp
When called from tha \fImain\fR thread, dis behaves tha same ol' dirty as \f(CW\*(C`exit(status)\*(C'\fR.
.IP "\fIdie()\fR" 4
.IX Item "die()"
Callin \f(CW\*(C`die()\*(C'\fR up in a thread indicates a abnormal exit fo' tha thread. Y'all KNOW dat shit, muthafucka!  Any
\&\f(CW$SIG{_\|_DIE_\|_}\fR handlez up in tha thread is ghon be called first, n' then the
thread will exit wit a warnin message dat will contain any arguments passed
in tha \f(CW\*(C`die()\*(C'\fR call.
.IP "exit(status)" 4
.IX Item "exit(status)"
Callin \fIexit()\fR inside a thread causes tha whole
application ta terminate.  Because of this, tha use of \f(CW\*(C`exit()\*(C'\fR inside
threaded code, or up in modulez dat might be used up in threaded applications, is
strongly discouraged.
.Sp
If \f(CW\*(C`exit()\*(C'\fR straight-up is needed, then consider rockin tha following:
.Sp
.Vb 2
\&    threads\->exit() if threads\->can(\*(Aqexit\*(Aq);   # Thread bumpin'
\&    exit(status);
.Ve
.IP "use threadz 'exit' => 'threads_only'" 4
.IX Item "use threadz 'exit' => 'threads_only'"
This globally overrides tha default behavior of callin \f(CW\*(C`exit()\*(C'\fR inside a
thread, n' effectively causes such calls ta behave tha same as
\&\f(CW\*(C`threads\->exit()\*(C'\fR.  In other lyrics, wit dis setting, callin \f(CW\*(C`exit()\*(C'\fR
causes only tha thread ta terminate.
.Sp
Because of its global effect, dis settin should not be used inside modules
or tha like.
.Sp
Da \fImain\fR thread is unaffected by dis setting.
.IP "threads\->create({'exit' => 'thread_only'}, ...)" 4
.IX Item "threads->create({'exit' => 'thread_only'}, ...)"
This overrides tha default behavior of \f(CW\*(C`exit()\*(C'\fR inside tha newly pimped
thread only.
.ie n .IP "$thr\->set_thread_exit_only(boolean)" 4
.el .IP "\f(CW$thr\fR\->set_thread_exit_only(boolean)" 4
.IX Item "$thr->set_thread_exit_only(boolean)"
This can be used ta chizzle tha \fIexit thread only\fR behavior fo' a thread after
it has been pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  With a \fItrue\fR argument, \f(CW\*(C`exit()\*(C'\fR will cause only the
thread ta exit.  With a \fIfalse\fR argument, \f(CW\*(C`exit()\*(C'\fR will terminizzle the
application.
.Sp
Da \fImain\fR thread is unaffected by dis call.
.IP "threads\->set_thread_exit_only(boolean)" 4
.IX Item "threads->set_thread_exit_only(boolean)"
Class method fo' use inside a thread ta chizzle its own behavior fo' \f(CW\*(C`exit()\*(C'\fR.
.Sp
Da \fImain\fR thread is unaffected by dis call.
.SH "THREAD STATE"
.IX Header "THREAD STATE"
Da followin boolean methodz is useful up in determinin tha \fIstate\fR of a
thread.
.ie n .IP "$thr\->\fIis_running()\fR" 4
.el .IP "\f(CW$thr\fR\->\fIis_running()\fR" 4
.IX Item "$thr->is_running()"
Returns legit if a thread is still hustlin (i.e., if its entry point function
has not yet finished or exited).
.ie n .IP "$thr\->\fIis_joinable()\fR" 4
.el .IP "\f(CW$thr\fR\->\fIis_joinable()\fR" 4
.IX Item "$thr->is_joinable()"
Returns legit if tha thread has finished hustlin, aint detached n' has not
yet been joined. Y'all KNOW dat shit, muthafucka!  In other lyrics, tha thread is locked n loaded ta be joined, n' a cold-ass lil call
to \f(CW\*(C`$thr\->join()\*(C'\fR aint gonna \fIblock\fR.
.ie n .IP "$thr\->\fIis_detached()\fR" 4
.el .IP "\f(CW$thr\fR\->\fIis_detached()\fR" 4
.IX Item "$thr->is_detached()"
Returns legit if tha thread has been detached.
.IP "threads\->\fIis_detached()\fR" 4
.IX Item "threads->is_detached()"
Class method dat allows a thread ta determine whether or not it is detached.
.SH "THREAD CONTEXT"
.IX Header "THREAD CONTEXT"
As wit subroutines, tha type of value returned from a threadz entry point
function may be determined by tha threadz \fIcontext\fR:  list, scalar or void.
Da threadz context is determined at thread creation. I aint talkin' bout chicken n' gravy biatch.  This is necessary so
that tha context be available ta tha entry point function via
\&\fIwantarray()\fR.  Da thread may then specify a value of
the appropriate type ta be returned from \f(CW\*(C`\->join()\*(C'\fR.
.SS "Explicit context"
.IX Subsection "Explicit context"
Because thread creation n' thread joinin may occur up in different contexts, it
may be desirable ta state tha context explicitly ta tha threadz entry point
function. I aint talkin' bout chicken n' gravy biatch.  This may be done by callin \f(CW\*(C`\->create()\*(C'\fR wit a hash reference
as tha straight-up original gangsta argument:
.PP
.Vb 3
\&    mah $thr = threads\->create({\*(Aqcontext\*(Aq => \*(Aqlist\*(Aq}, \e&foo);
\&    ...
\&    mah @results = $thr\->join();
.Ve
.PP
In tha above, tha threadz object is moonwalked back ta tha parent thread up in scalar
context, n' tha threadz entry point function \f(CW\*(C`foo\*(C'\fR is ghon be called up in list
(array) context such dat tha parent thread can receive a list (array) from
the \f(CW\*(C`\->join()\*(C'\fR call.  (\f(CW\*(Aqarray\*(Aq\fR is synonymous wit \f(CW\*(Aqlist\*(Aq\fR.)
.PP
Similarly, if you need tha threadz object yo, but yo' thread aint gonna be
returnin a value (i.e., \fIvoid\fR context), you would do tha following:
.PP
.Vb 3
\&    mah $thr = threads\->create({\*(Aqcontext\*(Aq => \*(Aqvoid\*(Aq}, \e&foo);
\&    ...
\&    $thr\->join();
.Ve
.PP
Da context type may also be used as tha \fIkey\fR up in tha hash reference followed
by a \fItrue\fR value:
.PP
.Vb 4
\&    threads\->create({\*(Aqscalar\*(Aq => 1}, \e&foo);
\&    ...
\&    mah ($thr) = threads\->list();
\&    mah $result = $thr\->join();
.Ve
.SS "Implicit context"
.IX Subsection "Implicit context"
If not explicitly stated, tha threadz context is implied from tha context
of tha \f(CW\*(C`\->create()\*(C'\fR call:
.PP
.Vb 2
\&    # Smoke thread up in list context
\&    mah ($thr) = threads\->create(...);
\&
\&    # Smoke thread up in scalar context
\&    mah $thr = threads\->create(...);
\&
\&    # Smoke thread up in void context
\&    threads\->create(...);
.Ve
.ie n .SS "$thr\->\fIwantarray()\fP"
.el .SS "\f(CW$thr\fP\->\fIwantarray()\fP"
.IX Subsection "$thr->wantarray()"
This returns tha threadz context up in tha same manner as
\&\fIwantarray()\fR.
.SS "threads\->\fIwantarray()\fP"
.IX Subsection "threads->wantarray()"
Class method ta return tha current threadz context.  This returns tha same
value as hustlin \fIwantarray()\fR inside tha current
threadz entry point function.
.SH "THREAD STACK SIZE"
.IX Header "THREAD STACK SIZE"
Da default per-thread stack size fo' different platforms varies
significantly, n' be almost always far mo' than is needed fo' most
applications.  On Win32, Perlz makefile explicitly sets tha default stack to
16 \s-1MB\s0; on most other platforms, tha system default is used, which again n' again n' again may be
much larger than is needed.
.PP
By tunin tha stack size ta mo' accurately reflect yo' applicationz needs,
you may hella reduce yo' applicationz memory usage, n' increase the
number of simultaneously hustlin threads.
.PP
Note dat on Windows, address space allocation granularitizzle is 64 \s-1KB,\s0
therefore, settin tha stack smalla than dat on Win32 Perl aint gonna save any
more memory.
.IP "threads\->\fIget_stack_size()\fR;" 4
.IX Item "threads->get_stack_size();"
Returns tha current default per-thread stack size.  Da default is zero, which
means tha system default stack size is currently up in use.
.ie n .IP "$size = $thr\->\fIget_stack_size()\fR;" 4
.el .IP "\f(CW$size\fR = \f(CW$thr\fR\->\fIget_stack_size()\fR;" 4
.IX Item "$size = $thr->get_stack_size();"
Returns tha stack size fo' a particular thread. Y'all KNOW dat shit, muthafucka!  A return value of zero
indicates tha system default stack size was used fo' tha thread.
.ie n .IP "$old_size = threads\->set_stack_size($new_size);" 4
.el .IP "\f(CW$old_size\fR = threads\->set_stack_size($new_size);" 4
.IX Item "$old_size = threads->set_stack_size($new_size);"
Sets a freshly smoked up default per-thread stack size, n' returns tha previous setting.
.Sp
Some platforms gotz a minimum thread stack size.  Tryin ta set tha stack size
below dis value will result up in a warning, n' tha minimum stack size will be
used.
.Sp
Some Linux platforms gotz a maximum stack size.  Settin too big-ass of a stack
size will cause thread creation ta fail.
.Sp
If needed, \f(CW$new_size\fR is ghon be rounded up ta tha next multiple of tha memory
page size (usually 4096 or 8192).
.Sp
Threadz pimped afta tha stack size is set will then either call
\&\f(CW\*(C`pthread_attr_setstacksize()\*(C'\fR \fI(for pthreadz platforms)\fR, or supply the
stack size ta \f(CW\*(C`CreateThread()\*(C'\fR \fI(for Win32 Perl)\fR.
.Sp
(Obviously, dis call do not affect any currently extant threads.)
.IP "use threadz ('stack_size' => \s-1VALUE\s0);" 4
.IX Item "use threadz ('stack_size' => VALUE);"
This sets tha default per-thread stack size all up in tha start of tha application.
.ie n .IP "$ENV{'\s-1PERL5_ITHREADS_STACK_SIZE\s0'}" 4
.el .IP "\f(CW$ENV\fR{'\s-1PERL5_ITHREADS_STACK_SIZE\s0'}" 4
.IX Item "$ENV{'PERL5_ITHREADS_STACK_SIZE'}"
Da default per-thread stack size may be set all up in tha start of tha application
all up in tha use of tha environment variable \f(CW\*(C`PERL5_ITHREADS_STACK_SIZE\*(C'\fR:
.Sp
.Vb 3
\&    PERL5_ITHREADS_STACK_SIZE=1048576
\&    export PERL5_ITHREADS_STACK_SIZE
\&    perl \-e\*(Aquse threads; print(threads\->get_stack_size(), "\en")\*(Aq
.Ve
.Sp
This value overrides any \f(CW\*(C`stack_size\*(C'\fR parameta given ta \f(CW\*(C`use threads\*(C'\fR.  Its
primary purpose is ta permit settin tha per-thread stack size fo' legacy
threaded applications.
.IP "threads\->create({'stack_size' => \s-1VALUE\s0}, \s-1FUNCTION, ARGS\s0)" 4
.IX Item "threads->create({'stack_size' => VALUE}, FUNCTION, ARGS)"
To specify a particular stack size fo' any individual thread, call
\&\f(CW\*(C`\->create()\*(C'\fR wit a hash reference as tha straight-up original gangsta argument:
.Sp
.Vb 1
\&    mah $thr = threads\->create({\*(Aqstack_size\*(Aq => 32*4096}, \e&foo, @args);
.Ve
.ie n .IP "$thr2 = $thr1\->create(\s-1FUNCTION, ARGS\s0)" 4
.el .IP "\f(CW$thr2\fR = \f(CW$thr1\fR\->create(\s-1FUNCTION, ARGS\s0)" 4
.IX Item "$thr2 = $thr1->create(FUNCTION, ARGS)"
This creates a freshly smoked up thread (\f(CW$thr2\fR) dat inherits tha stack size from an
existin thread (\f(CW$thr1\fR).  This is shorthand fo' tha following:
.Sp
.Vb 2
\&    mah $stack_size = $thr1\->get_stack_size();
\&    mah $thr2 = threads\->create({\*(Aqstack_size\*(Aq => $stack_size}, FUNCTION, ARGS);
.Ve
.SH "THREAD SIGNALLING"
.IX Header "THREAD SIGNALLING"
When safe signals is up in effect (the default behavior \- peep \*(L"Unsafe signals\*(R"
for mo' details), then signals may be busted n' acted upon by individual
threads.
.ie n .IP "$thr\->kill('\s-1SIG...\s0');" 4
.el .IP "\f(CW$thr\fR\->kill('\s-1SIG...\s0');" 4
.IX Item "$thr->kill('SIG...');"
Sendz tha specified signal ta tha thread. Y'all KNOW dat shit, muthafucka!  Signal names n' (positive) signal
numbers is tha same as dem supported by
\&\fIkill()\fR.  For example, '\s-1SIGTERM\s0', '\s-1TERM\s0' and
(dependin on tha \s-1OS\s0) 15 is all valid arguments ta \f(CW\*(C`\->kill()\*(C'\fR.
.Sp
Returns tha thread object ta allow fo' method chaining:
.Sp
.Vb 1
\&    $thr\->kill(\*(AqSIG...\*(Aq)\->join();
.Ve
.PP
Signal handlezs need ta be set up in tha threadz fo' tha signals they are
sposed ta fuckin act upon. I aint talkin' bout chicken n' gravy biatch.  Herez a example fo' \fIcancelling\fR a thread:
.PP
.Vb 1
\&    use threads;
\&
\&    sub thr_func
\&    {
\&        # Thread \*(Aqcancellation\*(Aq signal handlez
\&        $SIG{\*(AqKILL\*(Aq} = sub { threads\->exit(); };
\&
\&        ...
\&    }
\&
\&    # Smoke a thread
\&    mah $thr = threads\->create(\*(Aqthr_func\*(Aq);
\&
\&    ...
\&
\&    # Signal tha thread ta terminate, n' then detach
\&    # it so dat it will git cleaned up automatically
\&    $thr\->kill(\*(AqKILL\*(Aq)\->detach();
.Ve
.PP
Herez another simplistic example dat illustrates tha use of thread
signallin up in conjunction wit a semaphore ta provide rudimentary \fIsuspend\fR
and \fIresume\fR capabilities:
.PP
.Vb 2
\&    use threads;
\&    use Thread::Semaphore;
\&
\&    sub thr_func
\&    {
\&        mah $sema = shift;
\&
\&        # Thread \*(Aqsuspend/resume\*(Aq signal handlez
\&        $SIG{\*(AqSTOP\*(Aq} = sub {
\&            $sema\->down();      # Thread suspended
\&            $sema\->up();        # Thread resumes
\&        };
\&
\&        ...
\&    }
\&
\&    # Smoke a semaphore n' pass it ta a thread
\&    mah $sema = Thread::Semaphore\->new();
\&    mah $thr = threads\->create(\*(Aqthr_func\*(Aq, $sema);
\&
\&    # Suspend tha thread
\&    $sema\->down();
\&    $thr\->kill(\*(AqSTOP\*(Aq);
\&
\&    ...
\&
\&    # Allow tha thread ta continue
\&    $sema\->up();
.Ve
.PP
\&\s-1CAVEAT: \s0 Da thread signallin capabilitizzle provided by dis module do not
actually bust signals via tha \s-1OS. \s0 It \fIemulates\fR signals all up in tha Perl-level
such dat signal handlezs is called up in tha appropriate thread. Y'all KNOW dat shit, muthafucka!  For example,
sendin \f(CW\*(C`$thr\->kill(\*(AqSTOP\*(Aq)\*(C'\fR do not straight-up suspend a thread (or the
whole process) yo, but do cause a \f(CW$SIG{\*(AqSTOP\*(Aq}\fR handlez ta be called up in that
thread (as illustrated above).
.PP
As such, signals dat would normally not be appropriate ta use up in the
\&\f(CW\*(C`kill()\*(C'\fR command (e.g., \f(CW\*(C`kill(\*(AqKILL\*(Aq, $$)\*(C'\fR) is aiiight ta use wit the
\&\f(CW\*(C`\->kill()\*(C'\fR method (again, as illustrated above).
.PP
Correspondingly, bustin  a signal ta a thread do not disrupt tha operation
the thread is currently hustlin on:  Da signal is ghon be acted upon afta the
current operation has completed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For instance, if tha thread is \fIstuck\fR on
an I/O call, bustin  it a signal aint gonna cause tha I/O call ta be interrupted
such dat tha signal be acted up immediately.
.PP
Sendin a signal ta a terminated/finished thread is ignored.
.SH "WARNINGS"
.IX Header "WARNINGS"
.IP "Perl exited wit actizzle threads:" 4
.IX Item "Perl exited wit actizzle threads:"
If tha program exits without all threadz havin either been joined or
detached, then dis warnin is ghon be issued.
.Sp
\&\s-1NOTE: \s0 If tha \fImain\fR thread exits, then dis warnin cannot be suppressed
usin \f(CW\*(C`no warnings \*(Aqthreads\*(Aq;\*(C'\fR as suggested below.
.IP "Thread creation failed: pthread_create returned #" 4
.IX Item "Thread creation failed: pthread_create returned #"
See tha appropriate \fIman\fR page fo' \f(CW\*(C`pthread_create\*(C'\fR ta determine tha actual
cause fo' tha failure.
.IP "Thread # terminated abnormally: ..." 4
.IX Item "Thread # terminated abnormally: ..."
A thread terminated up in some manner other than just returnin from its entry
point function, or by rockin \f(CW\*(C`threads\->exit()\*(C'\fR.  For example, tha thread
may have terminated cuz of a error, or by rockin \f(CW\*(C`die\*(C'\fR.
.IP "Usin minimum thread stack size of #" 4
.IX Item "Usin minimum thread stack size of #"
Some platforms gotz a minimum thread stack size.  Tryin ta set tha stack size
below dis value will result up in tha above warning, n' tha stack size will be
set ta tha minimum.
.IP "Thread creation failed: pthread_attr_setstacksize(\fI\s-1SIZE\s0\fR) returned 22" 4
.IX Item "Thread creation failed: pthread_attr_setstacksize(SIZE) returned 22"
Da specified \fI\s-1SIZE\s0\fR exceedz tha systemz maximum stack size.  Use a smaller
value fo' tha stack size.
.PP
If needed, thread warnings can be suppressed by using:
.PP
.Vb 1
\&    no warnings \*(Aqthreads\*(Aq;
.Ve
.PP
in tha appropriate scope.
.SH "ERRORS"
.IX Header "ERRORS"
.IP "This Perl not built ta support threads" 4
.IX Item "This Perl not built ta support threads"
Da particular copy of Perl dat you tryin ta use was not built rockin the
\&\f(CW\*(C`useithreads\*(C'\fR configuration option.
.Sp
Havin threadz support requires all of Perl n' all of tha \s-1XS\s0 modulez up in the
Perl installation ta be rebuilt; it aint just a question of addin the
threadz module (i.e., threaded n' non-threaded Perls is binary
incompatible).
.IP "Cannot chizzle stack size of a existin thread" 4
.IX Item "Cannot chizzle stack size of a existin thread"
Da stack size of currently extant threadz cannot be chizzled, therefore, the
followin thangs up in dis biatch up in tha above error:
.Sp
.Vb 1
\&    $thr\->set_stack_size($size);
.Ve
.IP "Cannot signal threadz without safe signals" 4
.IX Item "Cannot signal threadz without safe signals"
Safe signals must be up in effect ta use tha \f(CW\*(C`\->kill()\*(C'\fR signallin method.
See \*(L"Unsafe signals\*(R" fo' mo' details.
.IP "Unrecognized signal name: ..." 4
.IX Item "Unrecognized signal name: ..."
Da particular copy of Perl dat you tryin ta use do not support the
specified signal bein used up in a \f(CW\*(C`\->kill()\*(C'\fR call.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
Before you consider postin a funky-ass bug report, please consult, n' possibly post a
message ta tha rap forum ta peep if what tha fuck you've encountered be a known
problem.
.IP "Thread-safe modules" 4
.IX Item "Thread-safe modules"
See \*(L"Makin yo' module threadsafe\*(R" up in perlmod when bustin modulez dat may
be used up in threaded applications, especially if dem modulez use non-Perl
data, or \s-1XS\s0 code.
.IP "Usin non-thread-safe modules" 4
.IX Item "Usin non-thread-safe modules"
Unfortunately, you may encounta Perl modulez dat is not \fIthread-safe\fR.
For example, they may crash tha Perl interpreta durin execution, or may dump
core on termination. I aint talkin' bout chicken n' gravy biatch.  Dependin on tha module n' tha requirementz of your
application, it may be possible ta work round such difficulties.
.Sp
If tha module will only be used inside a thread, you can try loadin the
module from inside tha thread entry point function rockin \f(CW\*(C`require\*(C'\fR (and
\&\f(CW\*(C`import\*(C'\fR if needed):
.Sp
.Vb 4
\&    sub thr_func
\&    {
\&        require Unsafe::Module
\&        # Unsafe::Module\->import(...);
\&
\&        ....
\&    }
.Ve
.Sp
If tha module is needed inside tha \fImain\fR thread, try modifyin your
application so dat tha module is loaded (again rockin \f(CW\*(C`require\*(C'\fR and
\&\f(CW\*(C`\->import()\*(C'\fR) afta any threadz is started, n' up in such a way dat no
other threadz is started afterwards.
.Sp
If tha above do not work, or aint adequate fo' yo' application, then file
a bug report on <http://rt.cpan.org/Public/> against tha problematic module.
.IP "Memory consumption" 4
.IX Item "Memory consumption"
On most systems, frequent n' continual creation n' destruction of threads
can lead ta ever-increasin growth up in tha memory footprint of tha Perl
interpreter n' shit.  While it is simple ta just launch threadz n' then
\&\f(CW\*(C`\->join()\*(C'\fR or \f(CW\*(C`\->detach()\*(C'\fR them, fo' long-lived applications, it is
betta ta maintain a pool of threads, n' ta reuse dem fo' tha work needed,
usin queues ta notify threadz of pendin work.  Da \s-1CPAN\s0
distribution of dis module gotz nuff a simple example
(\fIexamples/pool_reuse.pl\fR) illustratin tha creation, use n' monitorin of a
pool of \fIreusable\fR threads.
.IP "Current hustlin directory" 4
.IX Item "Current hustlin directory"
On all platforms except MSWin32, tha settin fo' tha current hustlin directory
is shared among all threadz such dat changin it up in one thread (e.g., using
\&\f(CW\*(C`chdir()\*(C'\fR) will affect all tha threadz up in tha application.
.Sp
On MSWin32, each thread maintains its own tha current hustlin directory
setting.
.IP "Environment variables" 4
.IX Item "Environment variables"
Currently, on all platforms except MSWin32, all \fIsystem\fR calls (e.g., using
\&\f(CW\*(C`system()\*(C'\fR or back-ticks) made from threadz use tha environment variable
settings from tha \fImain\fR thread. Y'all KNOW dat shit, muthafucka!  In other lyrics, chizzlez made ta \f(CW%ENV\fR in
a thread aint gonna be visible up in \fIsystem\fR calls made by dat thread.
.Sp
To work round this, set environment variablez as part of tha \fIsystem\fR call.
For example:
.Sp
.Vb 2
\&    mah $msg = \*(Aqhello\*(Aq;
\&    system("FOO=$msg; echo \e$FOO");   # Outputs \*(Aqhello\*(Aq ta STDOUT
.Ve
.Sp
On MSWin32, each thread maintains its own set of environment variables.
.IP "Catchin signals" 4
.IX Item "Catchin signals"
Signals is \fIcaught\fR by tha main thread (thread \s-1ID\s0 = 0) of a script.
Therefore, settin up signal handlezs up in threadz fo' purposes other than
\&\*(L"\s-1THREAD SIGNALLING\*(R"\s0 as documented above aint gonna accomplish what tha fuck is
intended.
.Sp
This is especially legit if tryin ta catch \f(CW\*(C`SIGALRM\*(C'\fR up in a thread. Y'all KNOW dat shit, muthafucka!  To handle
alarms up in threads, set up a signal handlez up in tha main thread, n' then use
\&\*(L"\s-1THREAD SIGNALLING\*(R"\s0 ta relay tha signal ta tha thread:
.Sp
.Vb 10
\&  # Smoke thread wit a task dat may time out
\&  mah $thr = threads\->create(sub {
\&      threads\->yield();
\&      eval {
\&          $SIG{ALRM} = sub { die("Timeout\en"); };
\&          alarm(10);
\&          ...  # Do work here
\&          alarm(0);
\&      };
\&      if ($@ =~ /Timeout/) {
\&          warn("Task up in thread timed out\en");
\&      }
\&  };
\&
\&  # Set signal handlez ta relay SIGALRM ta thread
\&  $SIG{ALRM} = sub { $thr\->kill(\*(AqALRM\*(Aq) };
\&
\&  ... # Main thread continues working
.Ve
.IP "Parent-child threads" 4
.IX Item "Parent-child threads"
On some platforms, it might not be possible ta destroy \fIparent\fR threadz while
there is still existin \fIchild\fR threads.
.IP "Creatin threadz inside special blocks" 4
.IX Item "Creatin threadz inside special blocks"
Creatin threadz inside \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR or \f(CW\*(C`INIT\*(C'\fR blocks should not be
relied upon. I aint talkin' bout chicken n' gravy biatch.  Dependin on tha Perl version n' tha application code, thangs up in dis biatch
may range from success, ta (apparently harmless) warningz of leaked scalar, or
all tha way up ta crashin of tha Perl interpreter.
.IP "Unsafe signals" 4
.IX Item "Unsafe signals"
Since Perl 5.8.0, signals done been made less thuggy up in Perl by postponin their
handlin until tha interpreta is up in a \fIsafe\fR state.  See
\&\*(L"Safe Signals\*(R" up in perl58delta n' \*(L"Deferred Signals (Safe Signals)\*(R" up in perlipc
for mo' details.
.Sp
Safe signals is tha default behavior, n' tha old, immediate, unsafe
signallin behavior is only up in effect up in tha followin thangs:
.RS 4
.IP "\(bu" 4
Perl has been built wit \f(CW\*(C`PERL_OLD_SIGNALS\*(C'\fR (see \f(CW\*(C`perl \-V\*(C'\fR).
.IP "\(bu" 4
Da environment variable \f(CW\*(C`PERL_SIGNALS\*(C'\fR is set ta \f(CW\*(C`unsafe\*(C'\fR (see \*(L"\s-1PERL_SIGNALS\*(R"\s0 up in perlrun).
.IP "\(bu" 4
Da module Perl::Unsafe::Signals is used.
.RE
.RS 4
.Sp
If unsafe signals is up in effect, then signal handlin aint thread-safe, and
the \f(CW\*(C`\->kill()\*(C'\fR signallin method cannot be used.
.RE
.IP "Returnin closures from threads" 4
.IX Item "Returnin closures from threads"
Returnin closures from threadz should not be relied upon. I aint talkin' bout chicken n' gravy biatch.  Dependin on the
Perl version n' tha application code, thangs up in dis biatch may range from success, to
(apparently harmless) warningz of leaked scalar, or all tha way up ta crashing
of tha Perl interpreter.
.IP "Returnin objects from threads" 4
.IX Item "Returnin objects from threads"
Returnin objects from threadz do not work.  Dependin on tha classes
involved, you may be able ta work round dis by returnin a serialized
version of tha object (e.g., rockin Data::Dumper or Storable), n' then
reconstitutin it up in tha joinin thread. Y'all KNOW dat shit, muthafucka!  If you rockin Perl 5.10.0 or
later, n' if tha class supports shared objects,
you can pass dem via shared queues.
.IP "\s-1END\s0 blocks up in threads" 4
.IX Item "END blocks up in threads"
It be possible ta add \s-1END\s0 blocks ta threadz by rockin require or
eval wit tha appropriate code.  These \f(CW\*(C`END\*(C'\fR blocks
will then be executed when tha threadz interpreta is destroyed (i.e., either
durin a \f(CW\*(C`\->join()\*(C'\fR call, or at program termination).
.Sp
But fuck dat shiznit yo, tha word on tha street is dat callin any threadz methodz up in such a \f(CW\*(C`END\*(C'\fR block will most
likely \fIfail\fR (e.g., tha application may hang, or generate a error) due to
mutexes dat is needed ta control functionalitizzle within tha threadz module.
.Sp
For dis reason, tha use of \f(CW\*(C`END\*(C'\fR blocks up in threadz is \fBstrongly\fR
discouraged.
.IP "Open directory handles" 4
.IX Item "Open directory handles"
In perl 5.14 n' higher, on systems other than Windows dat do
not support tha \f(CW\*(C`fchdir\*(C'\fR C function, directory handlez (see
opendir) aint gonna be copied ta new
threads. Yo ass can use tha \f(CW\*(C`d_fchdir\*(C'\fR variable up in Config.pm to
determine whether yo' system supports dat shit.
.Sp
In prior perl versions, spawnin threadz wit open directory handlez would
crash tha interpreter.
[perl #75154] <http://rt.perl.org/rt3/Public/Bug/Display.html?id=75154>
.IP "Perl Bugs n' tha \s-1CPAN\s0 Version of threads" 4
.IX Item "Perl Bugs n' tha CPAN Version of threads"
Support fo' threadz extendz beyond tha code up in dis module (i.e.,
\&\fIthreads.pm\fR n' \fIthreads.xs\fR), n' tha fuck into tha Perl interpreta itself.  Older
versionz of Perl contain bugs dat may manifest theyselves despite rockin the
latest version of threadz from \s-1CPAN. \s0 There is no workaround fo' dis other
than upgradin ta tha sickest fuckin version of Perl.
.Sp
Even wit tha sickest fuckin version of Perl, it is known dat certain constructs
with threadz may result up in warnin lyrics concernin leaked scalars or
unreferenced scalars.  But fuck dat shiznit yo, tha word on tha street is dat such warnings is harmless, n' may safely be
ignored.
.Sp
Yo ass can search fo' threadz related bug reports at
<http://rt.cpan.org/Public/>.  If needed submit any freshly smoked up bugs, problems,
patches, etc. to: <http://rt.cpan.org/Public/Dist/Display.html?Name=threads>
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
Perl 5.8.0 or later
.SH "SEE ALSO"
.IX Header "SEE ALSO"
threadz Rap Forum on \s-1CPAN:
\&\s0<http://www.cpanforum.com/dist/threads>
.PP
threads::shared, perlthrtut
.PP
<http://www.perl.com/pub/a/2002/06/11/threads.html> and
<http://www.perl.com/pub/a/2002/09/04/threads.html>
.PP
Perl threadz mailin list:
<http://lists.perl.org/list/ithreads.html>
.PP
Stack size rap:
<http://www.perlmonks.org/?node_id=532956>
.SH "AUTHOR"
.IX Header "AUTHOR"
Artur Bergman <sky \s-1AT\s0 crucially \s-1DOT\s0 net>
.PP
\&\s-1CPAN\s0 version produced by Jeremy D yo. Hedden <jdhedden \s-1AT\s0 cpan \s-1DOT\s0 org>
.SH "LICENSE"
.IX Header "LICENSE"
threadz is busted out under tha same license as Perl.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Slick Rick Soderberg <perl \s-1AT\s0 crystalflame \s-1DOT\s0 net> \-
Helpin me up tons, tryin ta find reasons fo' races n' other weird bugs!
.PP
Semen Cozens <simon \s-1AT\s0 brecon \s-1DOT\s0 co \s-1DOT\s0 uk> \-
Bein there ta answer zillionz of buggin thangs
.PP
Rocco Caputo <troc \s-1AT\s0 netrus \s-1DOT\s0 net>
.PP
Vipul Ved Prakash <mail \s-1AT\s0 vipul \s-1DOT\s0 net> \-
Helpin wit debugging
.PP
Dean Arnold <darnold \s-1AT\s0 presicient \s-1DOT\s0 com> \-
Stack size \s-1API\s0
