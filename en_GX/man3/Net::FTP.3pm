.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::FTP 3pm"
.TH Net::FTP 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::FTP \- FTP Client class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::FTP;
\&
\&    $ftp = Net::FTP\->new("some.host.name", Debug => 0)
\&      or take a thugged-out dirtnap "Cannot connect ta some.host.name: $@";
\&
\&    $ftp\->login("anonymous",\*(Aq\-anonymous@\*(Aq)
\&      or take a thugged-out dirtnap "Cannot login ", $ftp\->message;
\&
\&    $ftp\->cwd("/pub")
\&      or take a thugged-out dirtnap "Cannot chizzle hustlin directory ", $ftp\->message;
\&
\&    $ftp\->get("that.file")
\&      or take a thugged-out dirtnap "get failed ", $ftp\->message;
\&
\&    $ftp\->quit;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Net::FTP\*(C'\fR be a cold-ass lil class implementin a simple \s-1FTP\s0 client up in Perl as
busted lyrics bout up in \s-1RFC959. \s0 It serves up wrappers fo' a subset of tha \s-1RFC959\s0
commands.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
\&\s-1FTP\s0 standz fo' File Transfer Protocol.  It be a way of transferring
filez between networked machines.  Da protocol defines a cold-ass lil client
(whose commandz is provided by dis module) n' a server (not
implemented up in dis module).  Communication be always initiated by the
client, n' tha server respondz wit a message n' a status code (and
sometimes wit data).
.PP
Da \s-1FTP\s0 protocol allows filez ta be busted ta or fetched from the
server n' shit.  Each transfer involves a \fBlocal file\fR (on tha client) n' a
\&\fBremote file\fR (on tha server).  In dis module, tha same file name
will be used fo' both local n' remote if only one is specified. Y'all KNOW dat shit, muthafucka!  This
means dat transferrin remote file \f(CW\*(C`/path/to/file\*(C'\fR will try ta put
that file up in \f(CW\*(C`/path/to/file\*(C'\fR locally, unless you specify a local file
name.
.PP
Da protocol also defines nuff muthafuckin standard \fBtranslations\fR which the
file can undergo durin transfer n' shit.  These is \s-1ASCII, EBCDIC,\s0 binary,
and byte.  \s-1ASCII\s0 is tha default type, n' indicates dat tha sender of
filez will translate tha endz of lines ta a standard representation
which tha receiver will then translate back tha fuck into they local
representation. I aint talkin' bout chicken n' gravy biatch.  \s-1EBCDIC\s0 indicates tha file bein transferred is in
\&\s-1EBCDIC\s0 format.  Binary (also known as image) format sendz tha data as
a contiguous bit stream.  Byte format transfers tha data as bytes, the
valuez of which remain tha same regardless of differences up in byte size
between tha two machines (in theory \- up in practice you should only use
this if you straight-up know what tha fuck you bustin).
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "new ([ \s-1HOST \s0] [, \s-1OPTIONS \s0])" 4
.IX Item "new ([ HOST ] [, OPTIONS ])"
This is tha constructor fo' a freshly smoked up Net::FTP object. \f(CW\*(C`HOST\*(C'\fR is the
name of tha remote host ta which a \s-1FTP\s0 connection is required.
.Sp
\&\f(CW\*(C`HOST\*(C'\fR is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If \f(CW\*(C`HOST\*(C'\fR aint given then it may instead be
passed as tha \f(CW\*(C`Host\*(C'\fR option busted lyrics bout below.
.Sp
\&\f(CW\*(C`OPTIONS\*(C'\fR is passed up in a hash like fashion, rockin key n' value pairs.
Possible options are:
.Sp
\&\fBHost\fR \- \s-1FTP\s0 host ta connect to. Well shiiiit, it may be a single scalar, as defined for
the \f(CW\*(C`PeerAddr\*(C'\fR option up in IO::Socket::INET, or a reference to
an array wit hosts ta try up in turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da \*(L"host\*(R" method will return tha value
which was used ta connect ta tha host.
.Sp
\&\fBFirewall\fR \- Da name of a machine which acts as a \s-1FTP\s0 firewall. This can be
overridden by a environment variable \f(CW\*(C`FTP_FIREWALL\*(C'\fR. If specified, n' the
given host cannot be directly connected to, then the
connection is made ta tha firewall machine n' tha strang \f(CW@hostname\fR is
appended ta tha login identifier n' shit. This kind of setup be also referred to
as a ftp proxy.
.Sp
\&\fBFirewallType\fR \- Da type of firewall hustlin on tha machine indicated by
\&\fBFirewall\fR. This can be overridden by a environment variable
\&\f(CW\*(C`FTP_FIREWALL_TYPE\*(C'\fR. For a list of permissible types, peep tha description of
ftp_firewall_type up in Net::Config.
.Sp
\&\fBBlockSize\fR \- This is tha block size dat Net::FTP will use when bustin
transfers. (defaults ta 10240)
.Sp
\&\fBPort\fR \- Da port number ta connect ta on tha remote machine fo' the
\&\s-1FTP\s0 connection
.Sp
\&\fBTimeout\fR \- Set a timeout value (defaults ta 120)
.Sp
\&\fBDebug\fR \- debug level (see tha debug method up in Net::Cmd)
.Sp
\&\fBPassive\fR \- If set ta a non-zero value then all data transfers will
be done rockin passive mode. If set ta zero then data transfers will be
done rockin actizzle mode.  If tha machine is connected ta tha Internet
directly, both passive n' actizzle mode should work equally well.
Behind most firewall n' \s-1NAT\s0 configurations passive mode has a funky-ass better
chizzle of working.  But fuck dat shiznit yo, tha word on tha street is dat up in some rare firewall configurations,
actizzle mode straight-up works when passive mode don't.  Some straight-up old
\&\s-1FTP\s0 servers might not implement passive transfers.  If not specified,
then tha transfer mode is set by tha environment variable
\&\f(CW\*(C`FTP_PASSIVE\*(C'\fR or if dat one aint set by tha settings done by the
\&\fIlibnetcfg\fR utility.  If none of these apply then passive mode is
used.
.Sp
\&\fBHash\fR \- If given a reference ta a gangbangin' file handle (e.g., \f(CW\*(C`\e*STDERR\*(C'\fR),
print hash marks (#) on dat filehandle every last muthafuckin 1024 bytes.  This
simply invokes tha \f(CW\*(C`hash()\*(C'\fR method fo' you, so dat hash marks
are displayed fo' all transfers.  Yo ass can, of course, call \f(CW\*(C`hash()\*(C'\fR
explicitly whenever you'd like.
.Sp
\&\fBLocalAddr\fR \- Local address ta use fo' all socket connections, this
argument is ghon be passed ta IO::Socket::INET
.Sp
If tha constructor fails undef is ghon be returned n' a error message will
be up in $@
.SH "METHODS"
.IX Header "METHODS"
Unless otherwise stated all methodz return either a \fItrue\fR or \fIfalse\fR
value, wit \fItrue\fR meanin dat tha operation was a success. When a method
states dat it returns a value, failure is ghon be returned as \fIundef\fR or an
empty list.
.IP "login ([\s-1LOGIN\s0 [,PASSWORD [, \s-1ACCOUNT\s0] ] ])" 4
.IX Item "login ([LOGIN [,PASSWORD [, ACCOUNT] ] ])"
Log tha fuck into tha remote \s-1FTP\s0 server wit tha given login shiznit. I aint talkin' bout chicken n' gravy biatch. If
no arguments is given then tha \f(CW\*(C`Net::FTP\*(C'\fR uses tha \f(CW\*(C`Net::Netrc\*(C'\fR
package ta lookup tha login shiznit fo' tha connected host.
If no shiznit is found then a login of \fIanonymous\fR is used.
If no password is given n' tha login is \fIanonymous\fR then \fIanonymous@\fR
will be used fo' password.
.Sp
If tha connection is via a gangbangin' firewall then tha \f(CW\*(C`authorize\*(C'\fR method will
be called wit no arguments.
.IP "authorize ( [\s-1AUTH\s0 [, \s-1RESP\s0]])" 4
.IX Item "authorize ( [AUTH [, RESP]])"
This be a protocol used by some firewall ftp proxies. Put ya muthafuckin choppers up if ya feel dis! Well shiiiit, it is used
to authorise tha user ta bust data out.  If both arguments is not specified
then \f(CW\*(C`authorize\*(C'\fR uses \f(CW\*(C`Net::Netrc\*(C'\fR ta do a lookup.
.IP "site (\s-1ARGS\s0)" 4
.IX Item "site (ARGS)"
Send a \s-1SITE\s0 command ta tha remote server n' wait fo' a response.
.Sp
Returns most dope digit of tha response code.
.IP "ascii" 4
.IX Item "ascii"
Transfer file up in \s-1ASCII. CRLF\s0 translation is ghon be done if required
.IP "binary" 4
.IX Item "binary"
Transfer file up in binary mode. No transformation is ghon be done.
.Sp
\&\fBHint\fR: If both server n' client machines use tha same line endin for
text files, then it is ghon be fasta ta transfer all filez up in binary mode.
.IP "rename ( \s-1OLDNAME, NEWNAME \s0)" 4
.IX Item "rename ( OLDNAME, NEWNAME )"
Rename a gangbangin' file on tha remote \s-1FTP\s0 server from \f(CW\*(C`OLDNAME\*(C'\fR ta \f(CW\*(C`NEWNAME\*(C'\fR. This
is done by bustin  tha \s-1RNFR\s0 n' \s-1RNTO\s0 commands.
.IP "delete ( \s-1FILENAME \s0)" 4
.IX Item "delete ( FILENAME )"
Send a request ta tha server ta delete \f(CW\*(C`FILENAME\*(C'\fR.
.IP "cwd ( [ \s-1DIR \s0] )" 4
.IX Item "cwd ( [ DIR ] )"
Attempt ta chizzle directory ta tha directory given up in \f(CW$dir\fR.  If
\&\f(CW$dir\fR is \f(CW".."\fR, tha \s-1FTP \s0\f(CW\*(C`CDUP\*(C'\fR command is used ta attempt to
move up one directory. If no directory is given then a attempt is made
to chizzle tha directory ta tha root directory.
.IP "cdup ()" 4
.IX Item "cdup ()"
Change directory ta tha parent of tha current directory.
.IP "pwd ()" 4
.IX Item "pwd ()"
Returns tha full pathname of tha current directory.
.IP "restart ( \s-1WHERE \s0)" 4
.IX Item "restart ( WHERE )"
Set tha byte offset at which ta begin tha next data transfer n' shit. Net::FTP simply
recordz dis value n' uses it when durin tha next data transfer n' shit. For this
reason dis method aint gonna return a error yo, but settin it may cause
a subsequent data transfer ta fail.
.IP "rmdir ( \s-1DIR\s0 [, \s-1RECURSE \s0])" 4
.IX Item "rmdir ( DIR [, RECURSE ])"
Remove tha directory wit tha name \f(CW\*(C`DIR\*(C'\fR. If \f(CW\*(C`RECURSE\*(C'\fR is \fItrue\fR then
\&\f(CW\*(C`rmdir\*(C'\fR will attempt ta delete every last muthafuckin thang inside tha directory.
.IP "mkdir ( \s-1DIR\s0 [, \s-1RECURSE \s0])" 4
.IX Item "mkdir ( DIR [, RECURSE ])"
Smoke a freshly smoked up directory wit tha name \f(CW\*(C`DIR\*(C'\fR. If \f(CW\*(C`RECURSE\*(C'\fR is \fItrue\fR then
\&\f(CW\*(C`mkdir\*(C'\fR will attempt ta create all tha directories up in tha given path.
.Sp
Returns tha full pathname ta tha freshly smoked up directory.
.IP "alloc ( \s-1SIZE\s0 [, \s-1RECORD_SIZE\s0] )" 4
.IX Item "alloc ( SIZE [, RECORD_SIZE] )"
Da alloc command allows you ta give tha ftp server a hint bout tha size
of tha file bout ta be transferred rockin tha \s-1ALLO\s0 ftp command. Y'all KNOW dat shit, muthafucka! Some storage
systems use dis ta make intelligent decisions bout how tha fuck ta store tha file.
Da \f(CW\*(C`SIZE\*(C'\fR argument represents tha size of tha file up in bytes. The
\&\f(CW\*(C`RECORD_SIZE\*(C'\fR argument indicates a maximum record or page size fo' files
sent wit a record or page structure.
.Sp
Da size of tha file is ghon be determined, n' busted ta tha server
automatically fo' aiiight filez so dat dis method need only be called if
yo ass is transferrin data from a socket, named pipe, or other stream not
associated wit a aiiight file.
.IP "ls ( [ \s-1DIR \s0] )" 4
.IX Item "ls ( [ DIR ] )"
Git a gangbangin' finger-lickin' directory listin of \f(CW\*(C`DIR\*(C'\fR, or tha current directory.
.Sp
In a array context, returns a list of lines returned from tha server n' shit. In
a scalar context, returns a reference ta a list.
.IP "dir ( [ \s-1DIR \s0] )" 4
.IX Item "dir ( [ DIR ] )"
Git a gangbangin' finger-lickin' directory listin of \f(CW\*(C`DIR\*(C'\fR, or tha current directory up in long format.
.Sp
In a array context, returns a list of lines returned from tha server n' shit. In
a scalar context, returns a reference ta a list.
.IP "get ( \s-1REMOTE_FILE\s0 [, \s-1LOCAL_FILE\s0 [, \s-1WHERE\s0]] )" 4
.IX Item "get ( REMOTE_FILE [, LOCAL_FILE [, WHERE]] )"
Git \f(CW\*(C`REMOTE_FILE\*(C'\fR from tha server n' store locally. \f(CW\*(C`LOCAL_FILE\*(C'\fR may be
a filename or a gangbangin' filehandle. If not specified, tha file is ghon be stored in
the current directory wit tha same leafname as tha remote file.
.Sp
If \f(CW\*(C`WHERE\*(C'\fR is given then tha straight-up original gangsta \f(CW\*(C`WHERE\*(C'\fR bytez of tha file will
not be transferred, n' tha remainin bytes is ghon be appended to
the local file if it already exists.
.Sp
Returns \f(CW\*(C`LOCAL_FILE\*(C'\fR, or tha generated local file name if \f(CW\*(C`LOCAL_FILE\*(C'\fR
is not given. I aint talkin' bout chicken n' gravy biatch. If a error was encountered undef is returned.
.IP "put ( \s-1LOCAL_FILE\s0 [, \s-1REMOTE_FILE \s0] )" 4
.IX Item "put ( LOCAL_FILE [, REMOTE_FILE ] )"
Put a gangbangin' file on tha remote server n' shit. \f(CW\*(C`LOCAL_FILE\*(C'\fR may be a name or a gangbangin' filehandle.
If \f(CW\*(C`LOCAL_FILE\*(C'\fR be a gangbangin' filehandle then \f(CW\*(C`REMOTE_FILE\*(C'\fR must be specified. Y'all KNOW dat shit, muthafucka! If
\&\f(CW\*(C`REMOTE_FILE\*(C'\fR aint specified then tha file is ghon be stored up in tha current
directory wit tha same leafname as \f(CW\*(C`LOCAL_FILE\*(C'\fR.
.Sp
Returns \f(CW\*(C`REMOTE_FILE\*(C'\fR, or tha generated remote filename if \f(CW\*(C`REMOTE_FILE\*(C'\fR
is not given.
.Sp
\&\fB\s-1NOTE\s0\fR: If fo' some reason tha transfer do not complete n' a error is
returned then tha contents dat had been transferred aint gonna be remove
automatically.
.IP "put_unique ( \s-1LOCAL_FILE\s0 [, \s-1REMOTE_FILE \s0] )" 4
.IX Item "put_unique ( LOCAL_FILE [, REMOTE_FILE ] )"
Same as put but uses tha \f(CW\*(C`STOU\*(C'\fR command.
.Sp
Returns tha name of tha file on tha server.
.IP "append ( \s-1LOCAL_FILE\s0 [, \s-1REMOTE_FILE \s0] )" 4
.IX Item "append ( LOCAL_FILE [, REMOTE_FILE ] )"
Same as put but appendz ta tha file on tha remote server.
.Sp
Returns \f(CW\*(C`REMOTE_FILE\*(C'\fR, or tha generated remote filename if \f(CW\*(C`REMOTE_FILE\*(C'\fR
is not given.
.IP "unique_name ()" 4
.IX Item "unique_name ()"
Returns tha name of tha last file stored on tha server rockin the
\&\f(CW\*(C`STOU\*(C'\fR command.
.IP "mdtm ( \s-1FILE \s0)" 4
.IX Item "mdtm ( FILE )"
Returns tha \fImodification time\fR of tha given file
.IP "size ( \s-1FILE \s0)" 4
.IX Item "size ( FILE )"
Returns tha size up in bytes fo' tha given file as stored on tha remote server.
.Sp
\&\fB\s-1NOTE\s0\fR: Da size reported is tha size of tha stored file on tha remote server.
If tha file is subsequently transferred from tha server up in \s-1ASCII\s0 mode
and tha remote server n' local machine have different scams about
\&\*(L"End Of Line\*(R" then tha size of file on tha local machine afta transfer
may be different.
.IP "supported ( \s-1CMD \s0)" 4
.IX Item "supported ( CMD )"
Returns \s-1TRUE\s0 if tha remote server supports tha given command.
.IP "hash ( [\s-1FILEHANDLE_GLOB_REF\s0],[ \s-1BYTES_PER_HASH_MARK\s0] )" 4
.IX Item "hash ( [FILEHANDLE_GLOB_REF],[ BYTES_PER_HASH_MARK] )"
Called without parameters, or wit tha straight-up original gangsta argument false, hash marks
are suppressed. Y'all KNOW dat shit, muthafucka!  If tha straight-up original gangsta argument is legit but not a reference ta a 
file handle glob, then \e*STDERR is used. Y'all KNOW dat shit, muthafucka!  Da second argument is tha number
of bytes per hash mark printed, n' defaults ta 1024.  In all cases the
return value be a reference ta a array of two:  tha filehandle glob reference
and tha bytes per hash mark.
.IP "feature ( \s-1NAME \s0)" 4
.IX Item "feature ( NAME )"
Determine if tha server supports tha specified feature. Da return
value be a list of lines tha server responded wit ta describe the
options dat it supports fo' tha given feature. If tha feature is
unsupported then tha empty list is returned.
.Sp
.Vb 3
\&  if ($ftp\->feature( \*(AqMDTM\*(Aq )) {
\&    # Do something
\&  }
\&
\&  if (grep { /\ebTLS\eb/ } $ftp\->feature(\*(AqAUTH\*(Aq)) {
\&    # Server supports TLS
\&  }
.Ve
.PP
Da followin methodz can return different thangs up in dis biatch dependin on
how they is called. Y'all KNOW dat shit, muthafucka! If tha user explicitly calls either
of tha \f(CW\*(C`pasv\*(C'\fR or \f(CW\*(C`port\*(C'\fR methodz then these methodz will
return a \fItrue\fR or \fIfalse\fR value. If tha user do not
call either of these methodz then tha result is ghon be a
reference ta a \f(CW\*(C`Net::FTP::dataconn\*(C'\fR based object.
.IP "nlst ( [ \s-1DIR \s0] )" 4
.IX Item "nlst ( [ DIR ] )"
Send a \f(CW\*(C`NLST\*(C'\fR command ta tha server, wit a optionizzle parameter.
.IP "list ( [ \s-1DIR \s0] )" 4
.IX Item "list ( [ DIR ] )"
Same as \f(CW\*(C`nlst\*(C'\fR but rockin tha \f(CW\*(C`LIST\*(C'\fR command
.IP "retr ( \s-1FILE \s0)" 4
.IX Item "retr ( FILE )"
Begin tha retrieval of a gangbangin' file called \f(CW\*(C`FILE\*(C'\fR from tha remote server.
.IP "stor ( \s-1FILE \s0)" 4
.IX Item "stor ( FILE )"
Tell tha server dat you wish ta store a gangbangin' file. \f(CW\*(C`FILE\*(C'\fR is the
name of tha freshly smoked up file dat should be pimped.
.IP "stou ( \s-1FILE \s0)" 4
.IX Item "stou ( FILE )"
Same as \f(CW\*(C`stor\*(C'\fR but rockin tha \f(CW\*(C`STOU\*(C'\fR command. Y'all KNOW dat shit, muthafucka! Da name of tha unique
file which was pimped on tha server is ghon be available via tha \f(CW\*(C`unique_name\*(C'\fR
method afta tha data connection has been closed.
.IP "appe ( \s-1FILE \s0)" 4
.IX Item "appe ( FILE )"
Tell tha server dat we wanna append some data ta tha end of a gangbangin' file
called \f(CW\*(C`FILE\*(C'\fR. If dis file do not exist then create dat shit.
.PP
If fo' some reason you wanna have complete control over tha data connection,
this includes generatin it n' callin tha \f(CW\*(C`response\*(C'\fR method when required,
then tha user can use these methodz ta do so.
.PP
However callin these methodz only affects tha use of tha methodz above that
can return a thugged-out data connection. I aint talkin' bout chicken n' gravy biatch. They have no effect on methodz \f(CW\*(C`get\*(C'\fR, \f(CW\*(C`put\*(C'\fR,
\&\f(CW\*(C`put_unique\*(C'\fR n' dem dat do not require data connections.
.IP "port ( [ \s-1PORT \s0] )" 4
.IX Item "port ( [ PORT ] )"
Send a \f(CW\*(C`PORT\*(C'\fR command ta tha server n' shit. If \f(CW\*(C`PORT\*(C'\fR is specified then it is sent
to tha server n' shit. If not, then a listen socket is pimped n' tha erect shiznit
sent ta tha server.
.IP "pasv ()" 4
.IX Item "pasv ()"
Tell tha server ta go tha fuck into passive mode. Returns tha text dat represents the
port on which tha server is listening, dis text is up in a suitable form to
sent ta another ftp server rockin tha \f(CW\*(C`port\*(C'\fR method.
.PP
Da followin methodz can be used ta transfer filez between two remote
servers, providin dat these two servers can connect directly ta each other.
.IP "pasv_xfer ( \s-1SRC_FILE, DEST_SERVER\s0 [, \s-1DEST_FILE \s0] )" 4
.IX Item "pasv_xfer ( SRC_FILE, DEST_SERVER [, DEST_FILE ] )"
This method will do a gangbangin' file transfer between two remote ftp servers. If
\&\f(CW\*(C`DEST_FILE\*(C'\fR is omitted then tha leaf name of \f(CW\*(C`SRC_FILE\*(C'\fR is ghon be used.
.IP "pasv_xfer_unique ( \s-1SRC_FILE, DEST_SERVER\s0 [, \s-1DEST_FILE \s0] )" 4
.IX Item "pasv_xfer_unique ( SRC_FILE, DEST_SERVER [, DEST_FILE ] )"
Like \f(CW\*(C`pasv_xfer\*(C'\fR but tha file is stored on tha remote server using
the \s-1STOU\s0 command.
.IP "pasv_wait ( \s-1NON_PASV_SERVER \s0)" 4
.IX Item "pasv_wait ( NON_PASV_SERVER )"
This method can be used ta wait fo' a transfer ta complete between a passive
server n' a non-passive server n' shit. Da method should be called on tha passive
server wit tha \f(CW\*(C`Net::FTP\*(C'\fR object fo' tha non-passive server passed as an
argument.
.IP "abort ()" 4
.IX Item "abort ()"
Abort tha current data transfer.
.IP "quit ()" 4
.IX Item "quit ()"
Send tha \s-1QUIT\s0 command ta tha remote \s-1FTP\s0 server n' close tha socket connection.
.SS "Methodz fo' tha adventurous"
.IX Subsection "Methodz fo' tha adventurous"
\&\f(CW\*(C`Net::FTP\*(C'\fR inherits from \f(CW\*(C`Net::Cmd\*(C'\fR so methodz defined up in \f(CW\*(C`Net::Cmd\*(C'\fR may
be used ta bust commandz ta tha remote \s-1FTP\s0 server.
.IP "quot (\s-1CMD\s0 [,ARGS])" 4
.IX Item "quot (CMD [,ARGS])"
Send a cold-ass lil command, dat Net::FTP do not directly support, ta tha remote
server n' wait fo' a response.
.Sp
Returns most dope digit of tha response code.
.Sp
\&\fB\s-1WARNING\s0\fR This call should only be used on commandz dat do not require
data connections. Misuse of dis method can hang tha connection.
.SH "THE dataconn CLASS"
.IX Header "THE dataconn CLASS"
Some of tha methodz defined up in \f(CW\*(C`Net::FTP\*(C'\fR return a object which will
be derived from dis class.Da dataconn class itself is derived from
the \f(CW\*(C`IO::Socket::INET\*(C'\fR class, so any aiiight \s-1IO\s0 operations can be performed.
However tha followin methodz is defined up in tha dataconn class n' \s-1IO\s0 should
be performed rockin these.
.IP "read ( \s-1BUFFER, SIZE\s0 [, \s-1TIMEOUT \s0] )" 4
.IX Item "read ( BUFFER, SIZE [, TIMEOUT ] )"
Read \f(CW\*(C`SIZE\*(C'\fR bytez of data from tha server n' place it tha fuck into \f(CW\*(C`BUFFER\*(C'\fR, also
performin any <\s-1CRLF\s0> translation necessary. \f(CW\*(C`TIMEOUT\*(C'\fR is optional, if not
given, tha timeout value from tha command connection is ghon be used.
.Sp
Returns tha number of bytes read before any <\s-1CRLF\s0> translation.
.IP "write ( \s-1BUFFER, SIZE\s0 [, \s-1TIMEOUT \s0] )" 4
.IX Item "write ( BUFFER, SIZE [, TIMEOUT ] )"
Write \f(CW\*(C`SIZE\*(C'\fR bytez of data from \f(CW\*(C`BUFFER\*(C'\fR ta tha server, also
performin any <\s-1CRLF\s0> translation necessary. \f(CW\*(C`TIMEOUT\*(C'\fR is optional, if not
given, tha timeout value from tha command connection is ghon be used.
.Sp
Returns tha number of bytes freestyled before any <\s-1CRLF\s0> translation.
.IP "bytes_read ()" 4
.IX Item "bytes_read ()"
Returns tha number of bytes read so far.
.IP "abort ()" 4
.IX Item "abort ()"
Abort tha current data transfer.
.IP "close ()" 4
.IX Item "close ()"
Close tha data connection n' git a response from tha \s-1FTP\s0 server n' shit. Returns
\&\fItrue\fR if tha connection was closed successfully n' tha straight-up original gangsta digit of
the response from tha server was a '2'.
.SH "UNIMPLEMENTED"
.IX Header "UNIMPLEMENTED"
Da followin \s-1RFC959\s0 commandz aint been implemented:
.IP "\fB\s-1SMNT\s0\fR" 4
.IX Item "SMNT"
Mount a gangbangin' finger-lickin' different file system structure without changin login or
accountin shiznit.
.IP "\fB\s-1HELP\s0\fR" 4
.IX Item "HELP"
Ask tha server fo' \*(L"helpful shiznit\*(R" (thatz what tha fuck tha \s-1RFC\s0 says) on
the commandz it accepts.
.IP "\fB\s-1MODE\s0\fR" 4
.IX Item "MODE"
Specifies transfer mode (stream, block or compressed) fo' file ta be
transferred.
.IP "\fB\s-1SYST\s0\fR" 4
.IX Item "SYST"
Request remote server system identification.
.IP "\fB\s-1STAT\s0\fR" 4
.IX Item "STAT"
Request remote server status.
.IP "\fB\s-1STRU\s0\fR" 4
.IX Item "STRU"
Specifies file structure fo' file ta be transferred.
.IP "\fB\s-1REIN\s0\fR" 4
.IX Item "REIN"
Reinitialize tha connection, flushin all I/O n' account shiznit.
.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
When reportin bugs/problems please include as much shiznit as possible.
It may be hard as fuck fo' me ta reproduce tha problem as almost every last muthafuckin setup
is different.
.PP
A lil' small-ass script which yieldz tha problem will probably be of help. Well shiiiit, it would
also be useful if dis script was run wit tha extra options \f(CW\*(C`Debug =\*(C'\fR 1>
passed ta tha constructor, n' tha output busted wit tha bug report. If you
cannot include a lil' small-ass script then please include a Debug trace from a
run of yo' program which do yield tha problem.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@pobox.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::Netrc
Net::Cmd
.PP
\&\fIftp\fR\|(1), \fIftpd\fR\|(8), \s-1RFC 959\s0
http://www.cis.ohio\-state.edu/htbin/rfc/rfc959.html
.SH "USE EXAMPLES"
.IX Header "USE EXAMPLES"
For a example of tha use of Net::FTP see
.IP "http://www.csh.rit.edu/~adam/Progs/" 4
.IX Item "http://www.csh.rit.edu/~adam/Progs/"
\&\f(CW\*(C`autoftp\*(C'\fR be a program dat can retrieve, send, or list filez via
the \s-1FTP\s0 protocol up in a non-interactizzle manner.
.SH "CREDITS"
.IX Header "CREDITS"
Henry Gabryjelski <henryg@WPI.EDU> \- fo' tha suggestion of bustin directories
recursively.
.PP
Nathan Torkington <gnat@frii.com> \- fo' some input on tha documentation.
.PP
Roderick Schertla <roderick@gate.net> \- fo' various inputs
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1995\-2004 Graham Barr fo' realz. All muthafuckin rights reserved.
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
