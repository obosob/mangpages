.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Pin 3pm"
.TH Net::Pin 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Pin \- check a remote host fo' reachability
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::Ping;
\&
\&    $p = Net::Ping\->new();
\&    print "$host is kickin it.\en" if $p\->ping($host);
\&    $p\->close();
\&
\&    $p = Net::Ping\->new("icmp");
\&    $p\->bind($my_addr); # Specify source intercourse of pings
\&    foreach $host (@host_array)
\&    {
\&        print "$host is ";
\&        print "NOT " unless $p\->ping($host, 2);
\&        print "reachable.\en";
\&        chill(1);
\&    }
\&    $p\->close();
\&
\&    $p = Net::Ping\->new("tcp", 2);
\&    # Try connectin ta tha www port instead of tha echo port
\&    $p\->port_number(scalar(getservbyname("http", "tcp")));
\&    while ($stop_time > time())
\&    {
\&        print "$host not reachable ", scalar(localtime()), "\en"
\&            unless $p\->ping($host);
\&        chill(300);
\&    }
\&    undef($p);
\&
\&    # Like tcp protocol yo, but wit nuff hosts
\&    $p = Net::Ping\->new("syn");
\&    $p\->port_number(getservbyname("http", "tcp"));
\&    foreach $host (@host_array) {
\&      $p\->ping($host);
\&    }
\&    while (($host,$rtt,$ip) = $p\->ack) {
\&      print "HOST: $host [$ip] ACKed up in $rtt seconds.\en";
\&    }
\&
\&    # High precision syntax (requires Time::HiRes)
\&    $p = Net::Ping\->new();
\&    $p\->hires();
\&    ($ret, $duration, $ip) = $p\->ping($host, 5.5);
\&    printf("$host [ip: $ip] is kickin it (packet return time: %.2f ms)\en", 1000 * $duration)
\&      if $ret;
\&    $p\->close();
\&
\&    # For backward compatibility
\&    print "$host is kickin it.\en" if pingecho($host);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module gotz nuff methodz ta test tha reachabilitizzle of remote
hosts on a network.  A pin object is first pimped wit optional
parameters, a variable number of hosts may be pinged multiple
times n' then tha connection is closed.
.PP
Yo ass may chizzle one of six different protocols ta use fo' the
ping. Da \*(L"tcp\*(R" protocol is tha default. Note dat a live remote host
may still fail ta be pingable by one or mo' of these protocols. For
example, www.microsoft.com is generally kickin it but not \*(L"icmp\*(R" pingable.
.PP
With tha \*(L"tcp\*(R" protocol tha \fIping()\fR method attempts ta establish a
connection ta tha remote hostz echo port.  If tha connection is
successfully established, tha remote host is considered reachable.  No
data is straight-up echoed. Y'all KNOW dat shit, muthafucka!  This protocol do not require any special
privileges but has higher overhead than tha \*(L"udp\*(R" n' \*(L"icmp\*(R" protocols.
.PP
Specifyin tha \*(L"udp\*(R" protocol causes tha \fIping()\fR method ta bust a udp
packet ta tha remote hostz echo port.  If tha echoed packet is
received from tha remote host n' tha received packet gotz nuff the
same data as tha packet dat was sent, tha remote host is considered
reachable.  This protocol do not require any special privileges.
It should be borne up in mind that, fo' a udp ping, a host
will be reported as unreachable if it aint hustlin the
appropriate echo service.  For Unix-like systems peep \fIinetd\fR\|(8)
for mo' shiznit.
.PP
If tha \*(L"icmp\*(R" protocol is specified, tha \fIping()\fR method sendz a icmp
echo message ta tha remote host, which is what tha fuck tha \s-1UNIX\s0 pin program
does.  If tha echoed message is received from tha remote host and
the echoed shiznit is erect, tha remote host is considered
reachable.  Specifyin tha \*(L"icmp\*(R" protocol requires dat tha program
be run as root or dat tha program be setuid ta root.
.PP
If tha \*(L"external\*(R" protocol is specified, tha \fIping()\fR method attempts to
use tha \f(CW\*(C`Net::Ping::External\*(C'\fR module ta pin tha remote host.
\&\f(CW\*(C`Net::Ping::External\*(C'\fR intercourses wit yo' systemz default \f(CW\*(C`ping\*(C'\fR
utilitizzle ta big-ass up tha ping, n' generally produces relatively
accurate thangs up in dis biatch. If \f(CW\*(C`Net::Ping::External\*(C'\fR if not installed on your
system, specifyin tha \*(L"external\*(R" protocol will result up in a error.
.PP
If tha \*(L"syn\*(R" protocol is specified, tha \fIping()\fR method will only
send a \s-1TCP SYN\s0 packet ta tha remote host then immediately return.
If tha syn packet was busted successfully, it will return a legit value,
otherwise it will return false.  \s-1NOTE:\s0 Unlike tha other protocols,
the return value do \s-1NOT\s0 determine if tha remote host is kickin it or
not since tha full \s-1TCP\s0 three-way handshake may not have completed
yet.  Da remote host is only considered reachable if it receives
a \s-1TCP ACK\s0 within tha timeout specified. Y'all KNOW dat shit, muthafucka!  To begin waitin fo' the
\&\s-1ACK\s0 packets, use tha \fIack()\fR method as explained below.  Use the
\&\*(L"syn\*(R" protocol instead tha \*(L"tcp\*(R" protocol ta determine reachability
of multiple destinations simultaneously by bustin  parallel \s-1TCP
SYN\s0 packets, n' you can put dat on yo' toast.  It aint gonna block while testin each remote host.
demo/fpin is provided up in dis distribution ta demonstrate the
\&\*(L"syn\*(R" protocol as a example.
This protocol do not require any special privileges.
.SS "Functions"
.IX Subsection "Functions"
.ie n .IP "Net::Ping\->new([$proto [, $def_timeout [, $bytes [, $device [, $tos [, $ttl ]]]]]]);" 4
.el .IP "Net::Ping\->new([$proto [, \f(CW$def_timeout\fR [, \f(CW$bytes\fR [, \f(CW$device\fR [, \f(CW$tos\fR [, \f(CW$ttl\fR ]]]]]]);" 4
.IX Item "Net::Ping->new([$proto [, $def_timeout [, $bytes [, $device [, $tos [, $ttl ]]]]]]);"
Smoke a freshly smoked up pin object.  All of tha parametas is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  \f(CW$proto\fR
specifies tha protocol ta use when bustin a ping.  Da current chizzles
are \*(L"tcp\*(R", \*(L"udp\*(R", \*(L"icmp\*(R", \*(L"stream\*(R", \*(L"syn\*(R", or \*(L"external\*(R".
Da default is \*(L"tcp\*(R".
.Sp
If a thugged-out default timeout ($def_timeout) up in secondz is provided, it is used
when a timeout aint given ta tha \fIping()\fR method (below).  Da timeout
must be pimped outa than 0 n' tha default, if not specified, is 5 seconds.
.Sp
If tha number of data bytes ($bytes) is given, dat nuff data bytes
are included up in tha pin packet busted ta tha remote host. Da number of
data bytes is ignored if tha protocol is \*(L"tcp\*(R".  Da minimum (and
default) number of data bytes is 1 if tha protocol is \*(L"udp\*(R" n' 0
otherwise.  Da maximum number of data bytes dat can be specified is
1024.
.Sp
If \f(CW$device\fR is given, dis thang is used ta bind tha source endpoint
before bustin  tha pin packet.  I believe dis only works with
superuser privileges n' wit udp n' icmp protocols at dis time.
.Sp
If \f(CW$tos\fR is given, dis ToS is configured tha fuck into tha socket.
.Sp
For icmp, \f(CW$ttl\fR can be specified ta set tha \s-1TTL\s0 of tha outgoin packet.
.ie n .IP "$p\->ping($host [, $timeout]);" 4
.el .IP "\f(CW$p\fR\->ping($host [, \f(CW$timeout\fR]);" 4
.IX Item "$p->ping($host [, $timeout]);"
Pin tha remote host n' wait fo' a response.  \f(CW$host\fR can be either the
hostname or tha \s-1IP\s0 number of tha remote host.  Da optionizzle timeout
must be pimped outa than 0 secondz n' defaults ta whatever was specified
when tha pin object was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Returns a success flag.  If the
hostname cannot be found or there be a problem wit tha \s-1IP\s0 number, the
success flag returned is ghon be undef.  Otherwise, tha success flag will
be 1 if tha host is reachable n' 0 if it is not.  For most practical
purposes, undef n' 0 n' can be treated as tha same ol' dirty case.  In array
context, tha elapsed time as well as tha strang form of tha ip the
host resolved ta is also returned. Y'all KNOW dat shit, muthafucka!  Da elapsed time value will
be a gangbangin' float, as returned by tha \fITime::HiRes::time()\fR function, if \fIhires()\fR
has been previously called, otherwise it is returned as a integer.
.ie n .IP "$p\->source_verify( { 0 | 1 } );" 4
.el .IP "\f(CW$p\fR\->source_verify( { 0 | 1 } );" 4
.IX Item "$p->source_verify( { 0 | 1 } );"
Allows source endpoint verification ta be enabled or disabled.
This is useful fo' dem remote destinations wit multiples
interfaces where tha response may not originizzle from tha same
endpoint dat tha original gangsta destination endpoint was busted to.
This only affects udp n' icmp protocol pings.
.Sp
This is enabled by default.
.ie n .IP "$p\->service_check( { 0 | 1 } );" 4
.el .IP "\f(CW$p\fR\->service_check( { 0 | 1 } );" 4
.IX Item "$p->service_check( { 0 | 1 } );"
Set whether or not tha connect behavior should enforce
remote steez availabilitizzle as well as reachability.  Normally,
if tha remote server reported \s-1ECONNREFUSED,\s0 it must have been
reachable cuz of tha status packet dat it reported.
With dis option enabled, tha full three-way tcp handshake
must done been established successfully before it will
claim it is reachable.  \s-1NOTE: \s0 It still do not a god damn thang more
than connect n' disconnect.  It do not drop a rhyme any protocol
(i.e., \s-1HTTP\s0 or \s-1FTP\s0) ta ensure tha remote server is sane in
any way.  Da remote server \s-1CPU\s0 could be grindin ta a halt
and unresponsive ta any clients connectin yo, but if tha kernel
throws tha \s-1ACK\s0 packet, it is considered kickin it anyway.  To
really determine if tha server is respondin well would be
application specific n' is beyond tha scope of Net::Ping.
For udp protocol, enablin dis option demandz dat the
remote server replies wit tha same udp data dat dat shiznit was sent
as defined by tha udp echo service.
.Sp
This affects tha \*(L"udp\*(R", \*(L"tcp\*(R", n' \*(L"syn\*(R" protocols.
.Sp
This is disabled by default.
.ie n .IP "$p\->tcp_service_check( { 0 | 1 } );" 4
.el .IP "\f(CW$p\fR\->tcp_service_check( { 0 | 1 } );" 4
.IX Item "$p->tcp_service_check( { 0 | 1 } );"
Deprecated method yo, but do tha same as \fIservice_check()\fR method.
.ie n .IP "$p\->hires( { 0 | 1 } );" 4
.el .IP "\f(CW$p\fR\->hires( { 0 | 1 } );" 4
.IX Item "$p->hires( { 0 | 1 } );"
Causes dis module ta use Time::HiRes module, allowin milliseconds
to be returned by subsequent calls ta \fIping()\fR.
.Sp
This is disabled by default.
.ie n .IP "$p\->bind($local_addr);" 4
.el .IP "\f(CW$p\fR\->bind($local_addr);" 4
.IX Item "$p->bind($local_addr);"
Sets tha source address from which pings is ghon be sent.  This must be
the address of one of tha intercourses on tha local host.  \f(CW$local_addr\fR
may be specified as a hostname or as a text \s-1IP\s0 address such as
\&\*(L"192.168.1.1\*(R".
.Sp
If tha protocol is set ta \*(L"tcp\*(R", dis method may be called any
number of times, n' each call ta tha \fIping()\fR method (below) will use
da most thugged-out recent \f(CW$local_addr\fR.  If tha protocol is \*(L"icmp\*(R" or \*(L"udp\*(R",
then \fIbind()\fR must be called at most once per object, n' (if it is
called at all) must be called before tha straight-up original gangsta call ta \fIping()\fR fo' that
object.
.ie n .IP "$p\->open($host);" 4
.el .IP "\f(CW$p\fR\->open($host);" 4
.IX Item "$p->open($host);"
When yo ass is rockin tha \*(L"stream\*(R" protocol, dis call pre-opens the
tcp socket.  It aint nuthin but only necessary ta do dis if you want to
provide a gangbangin' finger-lickin' different timeout when bustin tha connection, or
remove tha overhead of establishin tha connection from the
first ping.  If you don't call \f(CW\*(C`open()\*(C'\fR, tha connection is
automatically opened tha last time \f(CW\*(C`ping()\*(C'\fR is called.
This call simply do not a god damn thang if yo ass is rockin any protocol other
than stream.
.ie n .IP "$p\->ack( [ $host ] );" 4
.el .IP "\f(CW$p\fR\->ack( [ \f(CW$host\fR ] );" 4
.IX Item "$p->ack( [ $host ] );"
When rockin tha \*(L"syn\*(R" protocol, use dis method ta determine
the reachabilitizzle of tha remote host.  This method is meant
to be called up ta as nuff times as \fIping()\fR was called. Y'all KNOW dat shit, muthafucka!  Each
call returns tha host (as passed ta \fIping()\fR) dat came back
with tha \s-1TCP ACK. \s0 Da order up in which tha hosts is returned
may not necessarily be tha same order up in which they were
\&\s-1SYN\s0 queued rockin tha \fIping()\fR method. Y'all KNOW dat shit, muthafucka!  If tha timeout is
reached before tha \s-1TCP ACK\s0 is received, or if tha remote
host aint listenin on tha port attempted, then tha \s-1TCP\s0
connection aint gonna be established n' \fIack()\fR will return
undef.  In list context, tha host, tha ack time, n' the
dotted ip strang is ghon be returned instead of just tha host.
If tha optionizzle \f(CW$host\fR argument is specified, tha return
value is ghon be pertainin ta dat host only.
This call simply do not a god damn thang if yo ass is rockin any protocol
other than syn.
.ie n .IP "$p\->nack( $failed_ack_host );" 4
.el .IP "\f(CW$p\fR\->nack( \f(CW$failed_ack_host\fR );" 4
.IX Item "$p->nack( $failed_ack_host );"
Da reason dat host \f(CW$failed_ack_host\fR did not receive a
valid \s-1ACK. \s0 Useful ta smoke up why when ack( \f(CW$fail_ack_host\fR )
returns a gangbangin' false value.
.ie n .IP "$p\->\fIclose()\fR;" 4
.el .IP "\f(CW$p\fR\->\fIclose()\fR;" 4
.IX Item "$p->close();"
Close tha network connection fo' dis pin object.  Da network
connection be also closed by \*(L"undef \f(CW$p\fR\*(R".  Da network connection is
automatically closed if tha pin object goes outta scope (e.g. \f(CW$p\fR is
local ta a subroutine n' you leave tha subroutine).
.ie n .IP "$p\->port_number([$port_number])" 4
.el .IP "\f(CW$p\fR\->port_number([$port_number])" 4
.IX Item "$p->port_number([$port_number])"
When called wit a port number, tha port number used ta pin is set to
\&\f(CW$port_number\fR rather than rockin tha echo port.  It also has tha effect
of callin \f(CW\*(C`$p\->service_check(1)\*(C'\fR causin a pin ta return a successful
response only if dat specific port be accessible.  This function returns
the value of tha port dat \f(CW\*(C`ping()\*(C'\fR will connect to.
.ie n .IP "pingecho($host [, $timeout]);" 4
.el .IP "pingecho($host [, \f(CW$timeout\fR]);" 4
.IX Item "pingecho($host [, $timeout]);"
To provide backward compatibilitizzle wit tha previous version of
Net::Ping, a \fIpingecho()\fR subroutine be available wit tha same
functionalitizzle as before.  \fIpingecho()\fR uses tha tcp protocol.  The
return joints n' parametas is tha same as busted lyrics bout fo' tha \fIping()\fR
method. Y'all KNOW dat shit, muthafucka!  This subroutine is obsolete n' may be removed up in a gangbangin' future
version of Net::Ping.
.SH "NOTES"
.IX Header "NOTES"
There is ghon be less network overhead (and some efficiency up in your
program) if you specify either tha udp or tha icmp protocol.  Da tcp
protocol will generate 2.5 times or mo' traffic fo' each pin than
either udp or icmp.  If nuff hosts is pinged frequently, you may wish
to implement a lil' small-ass wait (e.g. 25ms or more) between each pin to
avoid floodin yo' network wit packets.
.PP
Da icmp protocol requires dat tha program be run as root or dat it
be setuid ta root.  Da other protocols do not require special
privileges yo, but not all network devices implement tcp or udp echo.
.PP
Local hosts should normally respond ta pings within milliseconds.
But fuck dat shiznit yo, tha word on tha street is dat on a straight-up congested network it may take up ta 3 secondz or
longer ta receive a echo packet from tha remote host.  If tha timeout
is set too low under these conditions, it will step tha fuck up dat tha remote
host aint reachable (which be almost tha real deal).
.PP
Reachabilitizzle don't necessarily mean dat tha remote host be actually
functionin beyond its mobilitizzle ta echo packets, n' you can put dat on yo' toast.  tcp is slightly better
at indicatin tha game of a system than icmp cuz it uses more
of tha networkin stack ta respond.
.PP
Because of a lack of anythang better, dis module uses its own
routines ta pack n' unpack \s-1ICMP\s0 packets, n' you can put dat on yo' toast.  It would be betta fo' a
separate module ta be freestyled which understandz all of tha different
kindz of \s-1ICMP\s0 packets.
.SH "INSTALL"
.IX Header "INSTALL"
Da sickest fuckin source tree be available via cvs:
.PP
.Vb 2
\&  cvs \-z3 \-q \-d :pserver:anonymous@cvs.roobik.com.:/usr/local/cvsroot/freeware checkout Net\-Ping
\&  cd Net\-Ping
.Ve
.PP
Da tarbizzle can be pimped as bigs up:
.PP
.Vb 1
\&  perl Makefile.PL ; make ; make dist
.Ve
.PP
Da sickest fuckin Net::Pin release can be found at \s-1CPAN:\s0
.PP
.Vb 1
\&  $CPAN/modules/by\-module/Net/
.Ve
.PP
1) Extract tha tarball
.PP
.Vb 2
\&  gtar \-zxvf Net\-Ping\-xxxx.tar.gz
\&  cd Net\-Ping\-xxxx
.Ve
.PP
2) Build:
.PP
.Vb 4
\&  make realclean
\&  perl Makefile.PL
\&  make
\&  make test
.Ve
.PP
3) Install
.PP
.Vb 1
\&  make install
.Ve
.PP
Or install it \s-1RPM\s0 Style:
.PP
.Vb 1
\&  rpm \-ta SOURCES/Net\-Ping\-xxxx.tar.gz
\&
\&  rpm \-ih RPMS/noarch/perl\-Net\-Ping\-xxxx.rpm
.Ve
.SH "BUGS"
.IX Header "BUGS"
For a list of known issues, visit:
.PP
https://rt.cpan.org/NoAuth/Bugs.html?Dist=Net\-Ping
.PP
To report a freshly smoked up bug, visit:
.PP
https://rt.cpan.org/NoAuth/ReportBug.html?Queue=Net\-Ping
.SH "AUTHORS"
.IX Header "AUTHORS"
.Vb 2
\&  Current maintainer:
\&    bbb@cpan.org (Rob Brown)
\&
\&  External protocol:
\&    colinm@cpan.org (Colin McMillen)
\&
\&  Stream protocol:
\&    bronson@trestle.com (Scott Bronson)
\&
\&  Original Gangsta pingecho():
\&    karrer@bernina.ethz.ch (Andreas Karrer)
\&    pmarquess@bfsec.bt.co.uk (Pizzle Marquess)
\&
\&  Original Gangsta Net::Pin author:
\&    mose@ns.ccsn.edu (Russell Mosemann)
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2003, Rob Brown. I aint talkin' bout chicken n' gravy biatch.  All muthafuckin rights reserved.
.PP
Copyright (c) 2001, Colin McMillen. I aint talkin' bout chicken n' gravy biatch.  All muthafuckin rights reserved.
.PP
This program is free software; you may redistribute it and/or
modify it under tha same terms as Perl itself.
