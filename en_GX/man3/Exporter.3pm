.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Exporta 3"
.TH Exporta 3 "2014-04-14" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Exporta \- Implements default import method fo' modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
In module \fIYourModule.pm\fR:
.PP
.Vb 4
\&  package YourModule;
\&  require Exporter;
\&  @ISA = qw(Exporter);
\&  @EXPORT_OK = qw(munge frobnicate);  # symbols ta export on request
.Ve
.PP
or
.PP
.Vb 3
\&  package YourModule;
\&  use Exporta \*(Aqimport\*(Aq; # gives you Exporter\*(Aqs import() method directly
\&  @EXPORT_OK = qw(munge frobnicate);  # symbols ta export on request
.Ve
.PP
In other filez which wish ta use \f(CW\*(C`YourModule\*(C'\fR:
.PP
.Vb 2
\&  use YourModule qw(frobnicate);      # import listed symbols
\&  frobnicate ($left, $right)          # calls YourModule::frobnicate
.Ve
.PP
Take a peep \*(L"Dope Practices\*(R" fo' some variants
you will like ta use up in modern Perl code.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da Exporta module implements a \f(CW\*(C`import\*(C'\fR method which allows a module
to export functions n' variablez ta its users' namespaces.  Many modules
use Exporta rather than implementin they own \f(CW\*(C`import\*(C'\fR method cuz
Exporta serves up a highly flexible intercourse, wit a implementation optimised
for tha common case.
.PP
Perl automatically calls tha \f(CW\*(C`import\*(C'\fR method when processin a
\&\f(CW\*(C`use\*(C'\fR statement fo' a module.  Modulez n' \f(CW\*(C`use\*(C'\fR is documented
in perlfunc n' perlmod. Y'all KNOW dat shit, muthafucka!  Understandin tha concept of
modulez n' how tha fuck tha \f(CW\*(C`use\*(C'\fR statement operates is blingin to
understandin tha Exporter.
.SS "How tha fuck ta Export"
.IX Subsection "How tha fuck ta Export"
Da arrays \f(CW@EXPORT\fR n' \f(CW@EXPORT_OK\fR up in a module hold lists of
symbols dat is goin ta be exported tha fuck into tha playas name space by
default, or which they can request ta be exported, respectively.  The
symbols can represent functions, scalars, arrays, hashes, or typeglobs.
Da symbols must be given by full name wit tha exception dat the
ampersand up in front of a gangbangin' function is optional, e.g.
.PP
.Vb 2
\&    @EXPORT    = qw(afunc $scalar @array);   # afunc be a gangbangin' function
\&    @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc
.Ve
.PP
If yo ass is only exportin function names it is recommended ta omit the
ampersand, as tha implementation is fasta dis way.
.SS "Selectin What ta Export"
.IX Subsection "Selectin What ta Export"
Do \fBnot\fR export method names!
.PP
Do \fBnot\fR export anythang else by default without a phat reason!
.PP
Exports pollute tha namespace of tha module user n' shit.  If you must export
try ta use \f(CW@EXPORT_OK\fR up in preference ta \f(CW@EXPORT\fR n' avoid short or
common symbol names ta reduce tha risk of name clashes.
.PP
Generally anythang not exported is still accessible from outside the
module rockin tha \f(CW\*(C`YourModule::item_name\*(C'\fR (or \f(CW\*(C`$blessed_ref\->method\*(C'\fR)
syntax.  By convention you can bust a leadin underscore on names to
informally indicate dat they is 'internal' n' not fo' hood use.
.PP
(It be straight-up possible ta git private functions by saying:
.PP
.Vb 3
\&  mah $subref = sub { ... };
\&  $subref\->(@args);            # Call it as a gangbangin' function
\&  $obj\->$subref(@args);        # Use it as a method
.Ve
.PP
However if you use dem fo' methodz it is up ta you ta figure out
how ta make inheritizzle work.)
.PP
As a general rule, if tha module is tryin ta be object oriented
then export nothing.  If itz just a cold-ass lil collection of functions then
\&\f(CW@EXPORT_OK\fR anythang but use \f(CW@EXPORT\fR wit caution. I aint talkin' bout chicken n' gravy biatch.  For function and
method names use barewordz up in preference ta names prefixed with
ampersandz fo' tha export lists.
.PP
Other module design guidelines can be found up in perlmod.
.SS "How tha fuck ta Import"
.IX Subsection "How tha fuck ta Import"
In other filez which wish ta use yo' module there be three basic ways for
them ta load yo' module n' import its symbols:
.ie n .IP """use YourModule;""" 4
.el .IP "\f(CWuse YourModule;\fR" 4
.IX Item "use YourModule;"
This imports all tha symbols from YourModulez \f(CW@EXPORT\fR tha fuck into tha namespace
of tha \f(CW\*(C`use\*(C'\fR statement.
.ie n .IP """use YourModule ();""" 4
.el .IP "\f(CWuse YourModule ();\fR" 4
.IX Item "use YourModule ();"
This causes perl ta load yo' module but do not import any symbols.
.ie n .IP """use YourModule qw(...);""" 4
.el .IP "\f(CWuse YourModule qw(...);\fR" 4
.IX Item "use YourModule qw(...);"
This imports only tha symbols listed by tha calla tha fuck into they namespace.
All listed symbols must be up in yo' \f(CW@EXPORT\fR or \f(CW@EXPORT_OK\fR, else a error
occurs.  Da advanced export featurez of Exporta is accessed like this,
but wit list entries dat is syntactically distinct from symbol names.
.PP
Unless you wanna use its advanced features, dis is probably all you
need ta know ta use Exporter.
.SH "Advanced Features"
.IX Header "Advanced Features"
.SS "Specialised Import Lists"
.IX Subsection "Specialised Import Lists"
If any of tha entries up in a import list begins wit !, : or / then
the list is treated as a seriez of justifications which either add to
or delete from tha list of names ta import.  They is processed left to
right. Justifications is up in tha form:
.PP
.Vb 4
\&    [!]name         This name only
\&    [!]:DEFAULT     All names up in @EXPORT
\&    [!]:tag         All names up in $EXPORT_TAGS{tag} anonymous list
\&    [!]/pattern/    All names up in @EXPORT n' @EXPORT_OK which match
.Ve
.PP
A leadin ! indicates dat matchin names should be deleted from the
list of names ta import.  If tha straight-up original gangsta justification be a thugged-out deletion it
is treated as though preceded by WHAT!EFAULT.  If you just wanna import
extra names up in addizzle ta tha default set yo big-ass booty is ghon still need to
include WHAT!EFAULT explicitly.
.PP
e.g., \fIModule.pm\fR defines:
.PP
.Vb 3
\&    @EXPORT      = qw(A1 A2 A3 A4 A5);
\&    @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
\&    %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);
.Ve
.PP
Note dat you cannot use tags up in \f(CW@EXPORT\fR or \f(CW@EXPORT_OK\fR.
.PP
Names up in \s-1EXPORT_TAGS\s0 must also step tha fuck up in \f(CW@EXPORT\fR or \f(CW@EXPORT_OK\fR.
.PP
An application rockin Module can say suttin' like:
.PP
.Vb 1
\&    use Module qw(:DEFAULT :T2 !B3 A3);
.Ve
.PP
Other examplez include:
.PP
.Vb 2
\&    use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
\&    use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
.Ve
.PP
Remember dat most patterns (usin //) will need ta be anchored
with a leadin ^, e.g., \f(CW\*(C`/^EXIT/\*(C'\fR rather than \f(CW\*(C`/EXIT/\*(C'\fR.
.PP
Yo ass can say \f(CW\*(C`BEGIN { $Exporter::Verbose=1 }\*(C'\fR ta peep how tha fuck the
specifications is bein processed n' what tha fuck is straight-up bein imported
into modules.
.SS "Exportin Without Usin Exporterz import Method"
.IX Subsection "Exportin Without Usin Exporterz import Method"
Exporta has a special method, 'export_to_level' which is used up in thangs
where you can't directly call Exporter's
import method. Y'all KNOW dat shit, muthafucka!  Da export_to_level
method looks like:
.PP
.Vb 3
\&    MyPackage\->export_to_level(
\&        $where_to_export, $package, @what_to_export
\&    );
.Ve
.PP
where \f(CW$where_to_export\fR be a integer spittin some lyrics ta how tha fuck far up tha callin stack
to export yo' symbols, n' \f(CW@what_to_export\fR be a array spittin some lyrics ta what
symbols *to* export (usually dis is \f(CW@_\fR).  Da \f(CW$package\fR argument is
currently unused.
.PP
For example, suppose dat you gotz a module, A, which already has an
import function:
.PP
.Vb 1
\&    package A;
\&
\&    @ISA = qw(Exporter);
\&    @EXPORT_OK = qw($b);
\&
\&    sub import
\&    {
\&        $A::b = 1;     # not a straight-up useful import method
\&    }
.Ve
.PP
and you wanna Export symbol \f(CW$A::b\fR back ta tha module dat called 
package A.  Since Exporta relies on tha import method ta work, via 
inheritance, as it standz \fIExporter::import()\fR aint NEVER gonna git called. Y'all KNOW dat shit, muthafucka! 
Instead, say tha following:
.PP
.Vb 3
\&    package A;
\&    @ISA = qw(Exporter);
\&    @EXPORT_OK = qw($b);
\&
\&    sub import
\&    {
\&        $A::b = 1;
\&        A\->export_to_level(1, @_);
\&    }
.Ve
.PP
This will export tha symbols one level 'above' tha current package \- ie: ta 
the program or module dat used package A.
.PP
Note: Be careful not ta modify \f(CW@_\fR at all before you call export_to_level
\&\- or playas rockin yo' package will git straight-up unexplained thangs up in dis biatch!
.SS "Exportin Without Inheritin from Exporter"
.IX Subsection "Exportin Without Inheritin from Exporter"
By includin Exporta up in yo' \f(CW@ISA\fR you inherit a Exporterz \fIimport()\fR method
but you also inherit nuff muthafuckin other helper methodz which you probably don't
want.  To avoid dis you can do:
.PP
.Vb 2
\&  package YourModule;
\&  use Exporta qw(import);
.Ve
.PP
which will export Exporterz own \fIimport()\fR method tha fuck into YourModule.
Everythang will work as before but you won't need ta include Exporta in
\&\f(CW@YourModule::ISA\fR.
.PP
Note: This feature was introduced up in version 5.57
of Exporter, busted out wit perl 5.8.3.
.SS "Module Version Checking"
.IX Subsection "Module Version Checking"
Da Exporta module will convert a attempt ta import a number from a
module tha fuck into a cold-ass lil call ta \f(CW\*(C`$module_name\->VERSION($value)\*(C'\fR.  This can
be used ta validate dat tha version of tha module bein used is
greata than or equal ta tha required version.
.PP
For oldschool reasons, Exporta supplies a \f(CW\*(C`require_version\*(C'\fR method that
simply delegates ta \f(CW\*(C`VERSION\*(C'\fR.  Originally, before \f(CW\*(C`UNIVERSAL::VERSION\*(C'\fR
existed, Exporta would call \f(CW\*(C`require_version\*(C'\fR.
.PP
Since tha \f(CW\*(C`UNIVERSAL::VERSION\*(C'\fR method treats tha \f(CW$VERSION\fR number as
a simple numeric value it will regard version 1.10 as lower than
1.9.  For dis reason it is straight fuckin recommended dat you use numbers
with at least two decimal places, e.g., 1.09.
.SS "Managin Unknown Symbols"
.IX Subsection "Managin Unknown Symbols"
In some thangs you may wanna prevent certain symbols from being
exported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Typically dis applies ta extensions which have functions
or constants dat may not exist on some systems.
.PP
Da namez of any symbols dat cannot be exported should be listed
in tha \f(CW@EXPORT_FAIL\fR array.
.PP
If a module attempts ta import any of these symbols tha Exporter
will give tha module a opportunitizzle ta handle tha thang before
generatin a error. Shiiit, dis aint no joke.  Da Exporta will call a export_fail method
with a list of tha failed symbols:
.PP
.Vb 1
\&  @failed_symbols = $module_name\->export_fail(@failed_symbols);
.Ve
.PP
If tha \f(CW\*(C`export_fail\*(C'\fR method returns a empty list then no error is
recorded n' all tha axed symbols is exported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If tha returned
list aint empty then a error is generated fo' each symbol n' the
export fails.  Da Exporta serves up a thugged-out default \f(CW\*(C`export_fail\*(C'\fR method which
simply returns tha list unchanged.
.PP
Uses fo' tha \f(CW\*(C`export_fail\*(C'\fR method include givin betta error lyrics
for some symbols n' struttin lazy architectural checks (put more
symbols tha fuck into \f(CW@EXPORT_FAIL\fR by default n' then take dem up if one of mah thugs
actually tries ta use dem n' a high-rollin' check shows dat they are
usable on dat platform).
.SS "Tag Handlin Utilitizzle Functions"
.IX Subsection "Tag Handlin Utilitizzle Functions"
Since tha symbols listed within \f(CW%EXPORT_TAGS\fR must also step tha fuck up in either
\&\f(CW@EXPORT\fR or \f(CW@EXPORT_OK\fR, two utilitizzle functions is provided which allow
you ta easily add tagged setz of symbols ta \f(CW@EXPORT\fR or \f(CW@EXPORT_OK\fR:
.PP
.Vb 1
\&  %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
\&
\&  Exporter::export_tags(\*(Aqfoo\*(Aq);     # add aa, bb n' cc ta @EXPORT
\&  Exporter::export_ok_tags(\*(Aqbar\*(Aq);  # add aa, cc n' dd ta @EXPORT_OK
.Ve
.PP
Any names which is not tags is added ta \f(CW@EXPORT\fR or \f(CW@EXPORT_OK\fR
unchanged but will trigger a warnin (with \f(CW\*(C`\-w\*(C'\fR) ta avoid misspelt tags
names bein silently added ta \f(CW@EXPORT\fR or \f(CW@EXPORT_OK\fR.  Future versions
may make dis a gangbangin' fatal error.
.SS "Generatin Combined Tags"
.IX Subsection "Generatin Combined Tags"
If nuff muthafuckin symbol categories exist up in \f(CW%EXPORT_TAGS\fR, itz usually
useful ta create tha utilitizzle \*(L":all\*(R" ta simplify \*(L"use\*(R" statements.
.PP
Da simplest way ta do dis is:
.PP
.Vb 1
\&  %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
\&
\&  # add all tha other ":class" tags ta tha ":all" class,
\&  # deletin duplicates
\&  {
\&    mah %seen;
\&
\&    push @{$EXPORT_TAGS{all}},
\&      grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
\&  }
.Ve
.PP
\&\fI\s-1CGI\s0.pm\fR creates a \*(L":all\*(R" tag which gotz nuff some (but not straight-up
all) of its categories. Put ya muthafuckin choppers up if ya feel dis!  That could be done wit one small
change:
.PP
.Vb 4
\&  # add a shitload of tha other ":class" tags ta tha ":all" class,
\&  # deletin duplicates
\&  {
\&    mah %seen;
\&
\&    push @{$EXPORT_TAGS{all}},
\&      grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
\&        foreach qw/html2 html3 netscape form cgi internal/;
\&  }
.Ve
.PP
Note dat tha tag names up in \f(CW%EXPORT_TAGS\fR aint gots tha leadin ':'.
.ie n .SS """AUTOLOAD""ed Constants"
.el .SS "\f(CWAUTOLOAD\fPed Constants"
.IX Subsection "AUTOLOADed Constants"
Many modulez make use of \f(CW\*(C`AUTOLOAD\*(C'\fRin fo' constant subroutines to
avoid havin ta compile n' waste memory on rarely used joints (see
perlsub fo' details on constant subroutines).  Calls ta such
constant subroutines is not optimized away at compile time cuz
they can't be checked at compile time fo' constancy.
.PP
Even if a prototype be available at compile time, tha body of the
subroutine aint (it aint been \f(CW\*(C`AUTOLOAD\*(C'\fRed yet).  perl needz to
examine both tha \f(CW\*(C`()\*(C'\fR prototype n' tha body of a subroutine at
compile time ta detect dat it can safely replace calls ta that
subroutine wit tha constant value.
.PP
A workaround fo' dis is ta booty-call tha constants once up in a \f(CW\*(C`BEGIN\*(C'\fR block:
.PP
.Vb 1
\&   package My fuckin ;
\&
\&   use Socket ;
\&
\&   foo( SO_LINGER );  ## SO_LINGER NOT optimized away; called at runtime
\&   BEGIN { SO_LINGER }
\&   foo( SO_LINGER );  ## SO_LINGER optimized away at compile time.
.Ve
.PP
This forces tha \f(CW\*(C`AUTOLOAD\*(C'\fR fo' \f(CW\*(C`SO_LINGER\*(C'\fR ta take place before
\&\s-1SO_LINGER\s0 is encountered lata up in \f(CW\*(C`My\*(C'\fR package.
.PP
If yo ass is freestylin a package dat \f(CW\*(C`AUTOLOAD\*(C'\fRs, consider forcing
an \f(CW\*(C`AUTOLOAD\*(C'\fR fo' any constants explicitly imported by other packages
or which is probably used when yo' package is \f(CW\*(C`use\*(C'\fRd.
.SH "Dope Practices"
.IX Header "Dope Practices"
.ie n .SS "Declarin @EXPORT_OK n' Friends"
.el .SS "Declarin \f(CW@EXPORT_OK\fP n' Friends"
.IX Subsection "Declarin @EXPORT_OK n' Friends"
When rockin \f(CW\*(C`Exporter\*(C'\fR wit tha standard \f(CW\*(C`strict\*(C'\fR n' \f(CW\*(C`warnings\*(C'\fR
pragmas, tha \f(CW\*(C`our\*(C'\fR keyword is needed ta declare tha package
variablez \f(CW@EXPORT_OK\fR, \f(CW@EXPORT\fR, \f(CW@ISA\fR, etc.
.PP
.Vb 2
\&  our @ISA = qw(Exporter);
\&  our @EXPORT_OK = qw(munge frobnicate);
.Ve
.PP
If backward compatibilitizzle fo' Perls under 5.6 is blingin,
one must write instead a \f(CW\*(C`use vars\*(C'\fR statement.
.PP
.Vb 3
\&  use vars qw(@ISA @EXPORT_OK);
\&  @ISA = qw(Exporter);
\&  @EXPORT_OK = qw(munge frobnicate);
.Ve
.SS "Playin Safe"
.IX Subsection "Playin Safe"
There is some caveats wit tha use of runtime statements
like \f(CW\*(C`require Exporter\*(C'\fR n' tha assignment ta package
variables, which can be straight-up subtle fo' tha unaware programmer.
This may happen fo' instizzle wit mutually recursive
modules, which is affected by tha time tha relevant
constructions is executed.
.PP
Da ideal (but a lil' bit skanky) way ta never gotta think
about dat is ta use \f(CW\*(C`BEGIN\*(C'\fR blocks.  So tha straight-up original gangsta part
of tha \*(L"\s-1SYNOPSIS\*(R"\s0 code could be rewritten as:
.PP
.Vb 1
\&  package YourModule;
\&
\&  use strict;
\&  use warnings;
\&
\&  our (@ISA, @EXPORT_OK);
\&  BEGIN {
\&     require Exporter;
\&     @ISA = qw(Exporter);
\&     @EXPORT_OK = qw(munge frobnicate);  # symbols ta export on request
\&  }
.Ve
.PP
Da \f(CW\*(C`BEGIN\*(C'\fR will assure dat tha loadin of \fIExporter.pm\fR
and tha assignments ta \f(CW@ISA\fR n' \f(CW@EXPORT_OK\fR happen
immediately, leavin no room fo' suttin' ta git awry
or just plain wrong.
.PP
With respect ta loadin \f(CW\*(C`Exporter\*(C'\fR n' inheriting, there
are alternatives wit tha use of modulez like \f(CW\*(C`base\*(C'\fR n' \f(CW\*(C`parent\*(C'\fR.
.PP
.Vb 3
\&  use base qw(Exporter);
\&  # or
\&  use parent qw(Exporter);
.Ve
.PP
Any of these statements is sick replacements for
\&\f(CW\*(C`BEGIN { require Exporter; @ISA = qw(Exporter); }\*(C'\fR
with tha same compile-time effect.  Da basic difference
is dat \f(CW\*(C`base\*(C'\fR code interacts wit declared \f(CW\*(C`fields\*(C'\fR
while \f(CW\*(C`parent\*(C'\fR be a streamlined version of tha older
\&\f(CW\*(C`base\*(C'\fR code ta just establish tha IS-A relationshizzle.
.PP
For mo' details, peep tha documentation n' code of
base n' parent.
.PP
Another thorough remedy ta dat runtime
vs. compile-time trap is ta use Exporter::Easy,
which be a wrapper of Exporta dat allows all
boilerplate code at a single gulp up in the
use statement.
.PP
.Vb 5
\&   use Exporter::Easy (
\&       OK => [ qw(munge frobnicate) ],
\&   );
\&   # @ISA setup be automatic
\&   # all assignments happen at compile time
.Ve
.SS "What Not ta Export"
.IX Subsection "What Not ta Export"
Yo ass done been warned already up in \*(L"Selectin What ta Export\*(R"
to not export:
.IP "\(bu" 4
method names (because you don't need to
and thatz likely ta not do what tha fuck you want),
.IP "\(bu" 4
anythang by default (because you don't wanna surprise yo' users...
badly)
.IP "\(bu" 4
anythang you don't need ta (because less is more)
.PP
Therez one mo' item ta add ta dis list.  Do \fBnot\fR
export variable names.  Just cuz \f(CW\*(C`Exporter\*(C'\fR lets you
do that, it do not mean you should.
.PP
.Vb 1
\&  @EXPORT_OK = qw($svar @avar %hvar); # DON\*(AqT!
.Ve
.PP
Exportin variablez aint a phat idea.  They can
change under tha hood, provokin horrible
effects at-a-distizzle dat is too hard ta track
and ta fix.  Trust me: they is not worth dat shit.
.PP
To provide tha capabilitizzle ta set/get class-wide
settings, it is dopest instead ta provide accessors
as subroutines or class methodz instead.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\f(CW\*(C`Exporter\*(C'\fR is definitely not tha only module with
symbol exporta capabilities. Put ya muthafuckin choppers up if ya feel dis!  At \s-1CPAN,\s0 you may find
a bunch of em.  Some is lighter n' shit.  Some
provide improved APIs n' features.  Pick tha one
that fits yo' needs.  Da followin is
a sample list of such modules.
.PP
.Vb 6
\&    Exporter::Easy
\&    Exporter::Lite
\&    Exporter::Renaming
\&    Exporter::Tidy
\&    Sub::Exporta / Sub::Installer
\&    Perl6::Export / Perl6::Export::Attrs
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software.  Yo ass can redistribute it
and/or modify it under tha same terms as Perl itself.
