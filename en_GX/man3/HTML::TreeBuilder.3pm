.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::TreeBuilder 3"
.TH HTML::TreeBuilder 3 "2013-08-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::TreeBuilder \- Parser dat buildz a HTML syntax tree
.SH "VERSION"
.IX Header "VERSION"
This document raps bout version 5.03 of
HTML::TreeBuilder, busted out September 22, 2012
as part of HTML-Tree.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use HTML::TreeBuilder 5 \-weak; # Ensure weak references up in use
\&
\&  foreach mah $file_name (@ARGV) {
\&    mah $tree = HTML::TreeBuilder\->new; # empty tree
\&    $tree\->parse_file($file_name);
\&    print "Yo, here\*(Aqs a thugged-out dump of tha parse tree of $file_name:\en";
\&    $tree\->dump; # a method we inherit from HTML::Element
\&    print "And here it is, bizarrely rerendered as HTML:\en",
\&      $tree\->as_HTML, "\en";
\&
\&    # Now dat we\*(Aqre done wit it, we must destroy dat shit.
\&    # $tree = $tree\->delete; # Not required wit weak references
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
(This class is part of tha HTML::Tree dist.)
.PP
This class is fo' \s-1HTML\s0 syntax trees dat git built outta \s-1HTML\s0
source.  Da way ta use it is to:
.PP
1. start a freshly smoked up (empty) HTML::TreeBuilder object,
.PP
2. then use one of tha methodz from HTML::Parser (presumably with
\&\f(CW\*(C`$tree\->parse_file($filename)\*(C'\fR fo' files, or with
\&\f(CW\*(C`$tree\->parse($document_content)\*(C'\fR n' \f(CW\*(C`$tree\->eof\*(C'\fR if you've got
the content up in a string) ta parse tha \s-1HTML\s0
document tha fuck into tha tree \f(CW$tree\fR.
.PP
(Yo ass can combine steps 1 n' 2 wit tha \*(L"new_from_file\*(R" or
\&\*(L"new_from_content\*(R" methods.)
.PP
2b. call \f(CW\*(C`$root\->elementify()\*(C'\fR if you want.
.PP
3. do whatever you need ta do wit tha syntax tree, presumably
involvin traversin it lookin fo' some bit of shiznit up in it,
.PP
4. previous versionz of HTML::TreeBuilder required you ta call
\&\f(CW\*(C`$tree\->delete()\*(C'\fR ta erase tha contentz of tha tree from memory
when you done wit tha tree.  This aint normally required no mo'.
See \*(L"Weak References\*(R" up in HTML::Element fo' details.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Most of tha followin attributes natizzle ta HTML::TreeBuilder control how
parsin takes place; they should be set \fIbefore\fR you try parsin into
the given object.  Yo ass can set tha attributes by passin a \s-1TRUE\s0 or
\&\s-1FALSE\s0 value as argument.  E.g., \f(CW\*(C`$root\->implicit_tags\*(C'\fR returns
the current settin fo' tha \f(CW\*(C`implicit_tags\*(C'\fR option,
\&\f(CW\*(C`$root\->implicit_tags(1)\*(C'\fR turns dat option on,
and \f(CW\*(C`$root\->implicit_tags(0)\*(C'\fR turns it off.
.SS "implicit_tags"
.IX Subsection "implicit_tags"
Settin dis attribute ta legit will instruct tha parser ta try to
deduce implicit elements n' implicit end tags.  If it is false you
get a parse tree dat just reflects tha text as it stands, which is
unlikely ta be useful fo' anythang but quick n' dirty parsing.
(In fact, I'd be curious ta hear from mah playas whoz ass findz it useful to
have \f(CW\*(C`implicit_tags\*(C'\fR set ta false.)
Default is true.
.PP
Implicit elements have tha \*(L"implicit\*(R" up in HTML::Element attribute set.
.SS "implicit_body_p_tag"
.IX Subsection "implicit_body_p_tag"
This controls a aspect of implicit element behavior, if \f(CW\*(C`implicit_tags\*(C'\fR
is on:  If a text element (\s-1PCDATA\s0) or a phrasal element (such as
\&\f(CW\*(C`<em>\*(C'\fR) is ta be banged under \f(CW\*(C`<body>\*(C'\fR, two thangs
can happen: if \f(CW\*(C`implicit_body_p_tag\*(C'\fR is true, itz placed under a new,
implicit \f(CW\*(C`<p>\*(C'\fR tag.  (Past DTDs suggested dis was tha only
correct behavior, n' dis is how tha fuck past versionz of dis module
behaved.)  But if \f(CW\*(C`implicit_body_p_tag\*(C'\fR is false, not a god damn thang is implicated
\&\*(-- tha \s-1PCDATA\s0 or phrasal element is simply placed under
\&\f(CW\*(C`<body>\*(C'\fR.  Default is false.
.SS "no_expand_entities"
.IX Subsection "no_expand_entities"
This attribute controls whether entitizzles is decoded durin tha initial
parse of tha source. Enable dis if you don't want entitizzles decoded to
their characta value. e.g. '&amp;' is decoded ta '&' by default yo, but
will be unchanged if dis is enabled.
Default is false (entitizzles is ghon be decoded.)
.SS "ignore_unknown"
.IX Subsection "ignore_unknown"
This attribute controls whether unknown tags should be represented as
elements up in tha parse tree, or whether they should be ignored.
Default is legit (to ignore unknown tags.)
.SS "ignore_text"
.IX Subsection "ignore_text"
Do not represent tha text content of elements, n' you can put dat on yo' toast.  This saves space if
all you want is ta examine tha structure of tha document.  Default is
false.
.SS "ignore_ignorable_whitespace"
.IX Subsection "ignore_ignorable_whitespace"
If set ta true, TreeBuilder will try ta avoid
bustin ignorable whitespace text nodes up in tha tree.  Default is
true.  (In fact, I'd be horny bout hearin if there be a eva a cold-ass lil case
where you need dis off, or where leavin it on leadz ta incorrect
behavior.)
.SS "no_space_compacting"
.IX Subsection "no_space_compacting"
This determines whether TreeBuilder compacts all whitespace strings
in tha document (well, outside of \s-1PRE\s0 or \s-1TEXTAREA\s0 elements), or
leaves dem ridin' solo.  Normally (default, value of 0), each strang of
contiguous whitespace up in tha document is turned tha fuck into a single space.
But thatz not done if \f(CW\*(C`no_space_compacting\*(C'\fR is set ta 1.
.PP
Settin \f(CW\*(C`no_space_compacting\*(C'\fR ta 1 might be useful if you want
to read up in a tree just ta cook up some fuckin minor chizzlez ta it before
writin it back out.
.PP
This method is experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If you use it, be shizzle ta report
any problems you might have wit dat shit.
.SS "p_strict"
.IX Subsection "p_strict"
If set ta legit (and it defaults ta false), TreeBuilder will take a
narrower than aiiight view of what tha fuck can be under a \f(CW\*(C`<p>\*(C'\fR element; if it sees
a non-phrasal element bout ta be banged under a \f(CW\*(C`<p>\*(C'\fR, it will
close dat \f(CW\*(C`<p>\*(C'\fR.  Otherwise it will close \f(CW\*(C`<p>\*(C'\fR elements only for
other \f(CW\*(C`<p>\*(C'\fR's, headings, n' \f(CW\*(C`<form>\*(C'\fR (although tha latta may be
removed up in future versions).
.PP
For example, when goin thru dis snippet of code,
.PP
.Vb 2
\&  <p>stuff
\&  <ul>
.Ve
.PP
TreeBuilder will normally (with \f(CW\*(C`p_strict\*(C'\fR false) put tha \f(CW\*(C`<ul>\*(C'\fR element
under tha \f(CW\*(C`<p>\*(C'\fR element.  But fuck dat shiznit yo, tha word on tha street is dat wit \f(CW\*(C`p_strict\*(C'\fR set ta true, it will
close tha \f(CW\*(C`<p>\*(C'\fR first.
.PP
In theory, there should be strictnizz options like dis fo' other/all
elements besides just \f(CW\*(C`<p>\*(C'\fR; but I treat dis as a special case simply
because of tha fact dat \f(CW\*(C`<p>\*(C'\fR occurs so frequently n' its end-tag is
omitted so often; n' also cuz application of strictnizz rules
at parse-time across all elements often make tiny errors up in \s-1HTML\s0
codin produce drastically wack parse-trees, up in mah experience.
.PP
If you find dat you wish you had a option like dis ta enforce
content-models on all elements, then I suggest dat what tha fuck you want is
content-model checkin as a stage afta TreeBuilder has finished
parsing.
.SS "store_comments"
.IX Subsection "store_comments"
This determines whether TreeBuilder will normally store comments found
while parsin content tha fuck into \f(CW$root\fR.  Currently, dis is off by default.
.SS "store_declarations"
.IX Subsection "store_declarations"
This determines whether TreeBuilder will normally store markup
declarations found while parsin content tha fuck into \f(CW$root\fR.  This is on
by default.
.SS "store_pis"
.IX Subsection "store_pis"
This determines whether TreeBuilder will normally store processing
instructions found while parsin content tha fuck into \f(CW$root\fR \*(-- assumin a
recent version of HTML::Parser (old versions won't parse PIs
correctly).  Currently, dis is off (false) by default.
.PP
It be somewhat of a known bug (to be fixed one of these days, if
mah playas needz it?) dat PIs up in tha preamble (before tha \f(CW\*(C`<html>\*(C'\fR
start-tag) end up straight-up \fIunder\fR tha \f(CW\*(C`<html>\*(C'\fR element.
.SS "warn"
.IX Subsection "warn"
This determines whether syntax errors durin parsin should generate
warnings, emitted via Perlz \f(CW\*(C`warn\*(C'\fR function.
.PP
This is off (false) by default.
.SH "METHODS"
.IX Header "METHODS"
Objectz of dis class inherit tha methodz of both HTML::Parser and
HTML::Element.  Da methodz inherited from HTML::Parser is used for
buildin tha \s-1HTML\s0 tree, n' tha methodz inherited from HTML::Element
are what tha fuck you use ta scrutinize tha tree.  Besides this
(HTML::TreeBuilder) documentation, you must also carefully read the
HTML::Element documentation, n' also skim tha HTML::Parser
documentation \*(-- probably only its parse n' parse_file methodz is of
interest.
.SS "new_from_file"
.IX Subsection "new_from_file"
.Vb 1
\&  $root = HTML::TreeBuilder\->new_from_file($filename_or_filehandle);
.Ve
.PP
This \*(L"shortcut\*(R" constructor merely combines constructin a freshly smoked up object
(with tha \*(L"new\*(R" method, below), n' callin \f(CW\*(C`$new\->parse_file(...)\*(C'\fR on
it.  Returns tha freshly smoked up object.  Note dat dis serves up no way of
settin any parse options like \f(CW\*(C`store_comments\*(C'\fR (for that, call \f(CW\*(C`new\*(C'\fR, and
then set options, before callin \f(CW\*(C`parse_file\*(C'\fR).  See tha notes (below)
on parametas ta \*(L"parse_file\*(R".
.PP
If HTML::TreeBuilder is unable ta read tha file, then \f(CW\*(C`new_from_file\*(C'\fR
dies. Put ya muthafuckin choppers up if ya feel dis!  Da error can also be found up in \f(CW$!\fR.  (This behavior is freshly smoked up in
HTML-Tree 5. Previous versions returned a tree wit only implicit elements.)
.SS "new_from_content"
.IX Subsection "new_from_content"
.Vb 1
\&  $root = HTML::TreeBuilder\->new_from_content(...);
.Ve
.PP
This \*(L"shortcut\*(R" constructor merely combines constructin a freshly smoked up object
(with tha \*(L"new\*(R" method, below), n' callin \f(CW\*(C`for(...){$new\->parse($_)}\*(C'\fR
and \f(CW\*(C`$new\->eof\*(C'\fR on dat shit.  Returns tha freshly smoked up object.  Note dat dis provides
no way of settin any parse options like \f(CW\*(C`store_comments\*(C'\fR (for that,
call \f(CW\*(C`new\*(C'\fR, n' then set options, before callin \f(CW\*(C`parse\*(C'\fR).  Example
usages: \f(CW\*(C`HTML::TreeBuilder\->new_from_content(@lines)\*(C'\fR, or
\&\f(CW\*(C`HTML::TreeBuilder\->new_from_content($content)\*(C'\fR.
.SS "new_from_url"
.IX Subsection "new_from_url"
.Vb 1
\&  $root = HTML::TreeBuilder\->new_from_url($url)
.Ve
.PP
This \*(L"shortcut\*(R" constructor combines constructin a freshly smoked up object (with
the \*(L"new\*(R" method, below), loadin LWP::UserAgent, fetchin the
specified \s-1URL,\s0 n' callin \f(CW\*(C`$new\->parse( $response\->decoded_content)\*(C'\fR
and \f(CW\*(C`$new\->eof\*(C'\fR on dat shit.
Returns tha freshly smoked up object.  Note dat dis serves up no way of settin any
parse options like \f(CW\*(C`store_comments\*(C'\fR.
.PP
If \s-1LWP\s0 is unable ta fetch tha \s-1URL,\s0 or tha response aint \s-1HTML \s0(as
determined by \*(L"content_is_html\*(R" up in HTTP::Headers), then \f(CW\*(C`new_from_url\*(C'\fR
dies, n' tha HTTP::Response object is found in
\&\f(CW$HTML::TreeBuilder::lwp_response\fR.
.PP
Yo ass must have installed LWP::UserAgent fo' dis method ta work.  \s-1LWP\s0
is not installed automatically, cuz itz a big-ass set of modules
and you might not need dat shit.
.SS "new"
.IX Subsection "new"
.Vb 1
\&  $root = HTML::TreeBuilder\->new();
.Ve
.PP
This creates a freshly smoked up HTML::TreeBuilder object.  This method takes no
attributes.
.SS "parse_file"
.IX Subsection "parse_file"
.Vb 1
\& $root\->parse_file(...)
.Ve
.PP
[An blingin method inherited from HTML::Parser, which
see.  Current versionz of HTML::Parser can take a gangbangin' filespec, or a
filehandle object, like *FOO, or some object from class IO::Handle,
IO::File, IO::Socket) or tha like.
I be thinkin you should check dat a given file exists \fIbefore\fR calling
\&\f(CW\*(C`$root\->parse_file($filespec)\*(C'\fR.]
.PP
When you pass a gangbangin' filename ta \f(CW\*(C`parse_file\*(C'\fR, HTML::Parser opens it in
binary mode, which means itz interpreted as Latin\-1 (\s-1ISO\-8859\-1\s0).  If
the file is up in another encoding, like \s-1UTF\-8\s0 or \s-1UTF\-16,\s0 dis will not
do tha right thang.
.PP
One solution is ta open tha file yo ass rockin tha proper
\&\f(CW\*(C`:encoding\*(C'\fR layer, n' pass tha filehandle ta \f(CW\*(C`parse_file\*(C'\fR.  Yo ass can
automate dis process by rockin \*(L"html_file\*(R" up in \s-1IO::HTML\s0, which will use
the \s-1HTML5\s0 encodin sniffin algorithm ta automatically determine the
proper \f(CW\*(C`:encoding\*(C'\fR layer n' apply dat shit.
.PP
In tha next major release of HTML-Tree, I plan ta have it use \s-1IO::HTML\s0
automatically.  If you straight-up want yo' file opened up in binary mode,
you should open it yo ass n' pass tha filehandle ta \f(CW\*(C`parse_file\*(C'\fR.
.PP
Da return value is \f(CW\*(C`undef\*(C'\fR if there be a a error openin tha file.  In
that case, tha error is ghon be up in \f(CW$!\fR.
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&  $root\->parse(...)
.Ve
.PP
[A blingin method inherited from HTML::Parser, which
see.  See tha note below fo' \f(CW\*(C`$root\->eof()\*(C'\fR.]
.SS "eof"
.IX Subsection "eof"
.Vb 1
\&  $root\->eof();
.Ve
.PP
This signals dat you finished parsin content tha fuck into dis tree; this
runs various kindz of crucial cleanup on tha tree.  This is called
\&\fIfor you\fR when you call \f(CW\*(C`$root\->parse_file(...)\*(C'\fR yo, but not when
you call \f(CW\*(C`$root\->parse(...)\*(C'\fR.  So if you call
\&\f(CW\*(C`$root\->parse(...)\*(C'\fR, then you \fImust\fR call \f(CW\*(C`$root\->eof()\*(C'\fR
once you've finished feedin all tha chunks ta \f(CW\*(C`parse(...)\*(C'\fR, and
before you straight-up start bustin anythang else wit tha tree up in \f(CW$root\fR.
.SS "parse_content"
.IX Subsection "parse_content"
.Vb 1
\&  $root\->parse_content(...);
.Ve
.PP
Basically a handy alias fo' \f(CW\*(C`$root\->parse(...); $root\->eof\*(C'\fR.
Takes tha exact same arguments as \f(CW\*(C`$root\->parse()\*(C'\fR.
.SS "delete"
.IX Subsection "delete"
.Vb 1
\&  $root\->delete();
.Ve
.PP
[A previously blingin method inherited from HTML::Element,
which see.]
.SS "elementify"
.IX Subsection "elementify"
.Vb 1
\&  $root\->elementify();
.Ve
.PP
This chizzlez tha class of tha object up in \f(CW$root\fR from
HTML::TreeBuilder ta tha class used fo' all tha rest of tha elements
in dat tree (generally HTML::Element).  Returns \f(CW$root\fR.
.PP
For most purposes, dis is unnecessary yo, but if you call dis after
(after!!)
you've finished buildin a tree, then it keeps you from accidentally
tryin ta booty-call anythang but HTML::Element methodz on dat shit.  (I.e., if
you accidentally call \f(CW\*(C`$root\->parse_file(...)\*(C'\fR on the
already-complete n' elementified tree, then instead of chargin ahead
and \fIwreakin havoc\fR, it'll throw a gangbangin' fatal error \*(-- since \f(CW$root\fR is
now a object just of class HTML::Element which has no \f(CW\*(C`parse_file\*(C'\fR
method.
.PP
Note dat \f(CW\*(C`elementify\*(C'\fR currently deletes all tha private attributes of
\&\f(CW$root\fR except fo' \*(L"_tag\*(R", \*(L"_parent\*(R", \*(L"_content\*(R", \*(L"_pos\*(R", and
\&\*(L"_implicit\*(R".  If mah playas requests dat I chizzle dis ta leave up in yet
more private attributes, I might do so, up in future versions.
.SS "guts"
.IX Subsection "guts"
.Vb 2
\& @nodes = $root\->guts();
\& $parent_for_nodes = $root\->guts();
.Ve
.PP
In list context (as up in tha straight-up original gangsta case), dis method returns tha topmost
non-implicit nodes up in a tree.  This is useful when you parsin \s-1HTML\s0
code dat you know don't expect a \s-1HTML\s0 document yo, but instead just
a fragment of a \s-1HTML\s0 document.  For example, if you wanted tha parse
tree fo' a gangbangin' file consistin of just this:
.PP
.Vb 1
\&  <li>I wanna bust a nut on pie!
.Ve
.PP
Then you would git dat wit \f(CW\*(C`@nodes = $root\->guts();\*(C'\fR.
It so happens dat up in dis case, \f(CW@nodes\fR will contain just one
element object, representin tha \f(CW\*(C`<li>\*(C'\fR node (with \*(L"I wanna bust a nut on pie!\*(R" being
its text lil pimp node).  But fuck dat shiznit yo, tha word on tha street is dat consider if you was parsin this:
.PP
.Vb 1
\&  <hr>Hooboy hommie!<hr>
.Ve
.PP
In dat case, \f(CW\*(C`$root\->guts()\*(C'\fR would return three items:
an element object fo' tha straight-up original gangsta \f(CW\*(C`<hr>\*(C'\fR, a text strang \*(L"Hooboy!\*(R", and
another \f(CW\*(C`<hr>\*(C'\fR element object.
.PP
For cases where you want definitely one element (so you can treat it as
a \*(L"document fragment\*(R", roughly bustin lyrics), call \f(CW\*(C`guts()\*(C'\fR up in scalar
context, as up in \f(CW\*(C`$parent_for_nodes = $root\->guts()\*(C'\fR. That works like
\&\f(CW\*(C`guts()\*(C'\fR up in list context; up in fact, \f(CW\*(C`guts()\*(C'\fR up in list context would
have returned exactly one value, n' if it would done been a object (as
opposed ta a text string), then thatz what tha fuck \f(CW\*(C`guts\*(C'\fR up in scalar context
will return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Otherwise, if \f(CW\*(C`guts()\*(C'\fR up in list context would have returned
no joints at all, then \f(CW\*(C`guts()\*(C'\fR up in scalar context returns undef.  In
all other cases, \f(CW\*(C`guts()\*(C'\fR up in scalar context returns a implicit \f(CW\*(C`<div>\*(C'\fR
element node, wit lil pimps consistin of whatever nodes \f(CW\*(C`guts()\*(C'\fR
in list context would have returned. Y'all KNOW dat shit, muthafucka!  Note dat that may detach them
nodes from \f(CW$root\fRz tree.
.SS "disembowel"
.IX Subsection "disembowel"
.Vb 2
\&  @nodes = $root\->disembowel();
\&  $parent_for_nodes = $root\->disembowel();
.Ve
.PP
Da \f(CW\*(C`disembowel()\*(C'\fR method works just like tha \f(CW\*(C`guts()\*(C'\fR method, except
that disembowel definitively destroys tha tree above tha nodes that
are returned. Y'all KNOW dat shit, muthafucka!  Usually when you want tha guts from a tree, you just
goin ta toss up tha rest of tha tree anyway, so dis saves you the
bother n' shit.  (Remember, \*(L"disembowel\*(R" means \*(L"remove tha guts from\*(R".)
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
Yo ass should not need ta booty-call any of tha followin methodz directly.
.SS "element_class"
.IX Subsection "element_class"
.Vb 1
\&  $classname = $h\->element_class;
.Ve
.PP
This method returns tha class which is ghon be used fo' freshly smoked up elements, n' you can put dat on yo' toast.  It
defaults ta HTML::Element yo, but can be overridden by subclassin or esoteric
means dopest left ta dem will will read tha source n' then not diss when
those esoteric means chizzle.  (Just subclass.)
.SS "comment"
.IX Subsection "comment"
Accept a \*(L"herez a cold-ass lil comment\*(R" signal from HTML::Parser.
.SS "declaration"
.IX Subsection "declaration"
Accept a \*(L"herez a markup declaration\*(R" signal from HTML::Parser.
.SS "done"
.IX Subsection "done"
\&\s-1TODO:\s0 document
.SS "end"
.IX Subsection "end"
Either: Acccept a end-tag signal from HTML::Parser
Or: Method fo' closin currently open elements up in some fairly complex
way, as used by other methodz up in dis class.
.PP
\&\s-1TODO:\s0 Why is dis hidden?
.SS "process"
.IX Subsection "process"
Accept a \*(L"herez a \s-1PI\*(R"\s0 signal from HTML::Parser.
.SS "start"
.IX Subsection "start"
Accept a signal from HTML::Parser fo' start-tags.
.PP
\&\s-1TODO:\s0 Why is dis hidden?
.SS "stunt"
.IX Subsection "stunt"
\&\s-1TODO:\s0 document
.SS "stunted"
.IX Subsection "stunted"
\&\s-1TODO:\s0 document
.SS "text"
.IX Subsection "text"
Accept a \*(L"herez a text token\*(R" signal from HTML::Parser.
.PP
\&\s-1TODO:\s0 Why is dis hidden?
.SS "tighten_up"
.IX Subsection "tighten_up"
Legacy
.PP
Redirects ta \*(L"delete_ignorable_whitespace\*(R" up in HTML::Element.
.SS "warning"
.IX Subsection "warning"
Wrapper fo' CORE::warn
.PP
\&\s-1TODO:\s0 why not just use carp?
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.SS "\s-1DEBUG\s0"
.IX Subsection "DEBUG"
Is we up in Debug mode?  This be a cold-ass lil constant subroutine, ta allow
compile-time optimizations.  To control debug mode, set
\&\f(CW$HTML::TreeBuilder::DEBUG\fR \fIbefore\fR loadin HTML::TreeBuilder.
.SH "HTML AND ITS DISCONTENTS"
.IX Header "HTML AND ITS DISCONTENTS"
\&\s-1HTML\s0 is rather harder ta parse than playas whoz ass write it generally
suspect.
.PP
Herez tha problem: \s-1HTML\s0 be a kind of \s-1SGML\s0 dat permits \*(L"minimization\*(R"
and \*(L"implication\*(R".  In short, dis means dat you don't gotta close
every tag you open (because tha openin of a subsequent tag may
implicitly close it), n' if you bust a tag dat can't occur up in the
context you seem ta rockin it in, under certain conditions tha parser
will be able ta realize you mean ta leave tha current context and
enta tha freshly smoked up one, dat bein tha only one dat yo' code could
correctly be interpreted in.
.PP
Now, dis would all work flawlessly n' unproblematically if: 1) all
the rulez dat both prescribe n' describe \s-1HTML\s0 was (and had been)
clearly set out, n' 2) mah playas was aware of these rulez n' wrote
their code up in compliizzle ta em.
.PP
But fuck dat shiznit yo, tha word on tha street is dat it didn't happen dat way, n' so most \s-1HTML\s0 pages are
hard as fuck if not impossible ta erectly parse wit nearly any set of
straightforward \s-1SGML\s0 rules.  Thatz why tha internals of
HTML::TreeBuilder consist of fuckin shitloadz n' fuckin shitloadz of special cases \*(-- instead
of bein just a generic \s-1SGML\s0 parser wit \s-1HTML DTD\s0 rulez plugged in.
.SH "TRANSLATIONS?"
.IX Header "TRANSLATIONS?"
Da steez dat HTML::TreeBuilder uses ta big-ass up what tha fuck I consider
very robust parses on everydizzle code is not thangs dat can work only
in Perl.  To date, tha algorithms all up in tha centa of HTML::TreeBuilder
have been implemented only up in Perl, as far as I know; n' I don't
foresee gettin round ta implementin dem up in any other language any
time soon.
.PP
If, however, mah playas is lookin fo' a semesta project fo' a applied
programmin class (or if they merely trip off \fIextra-curricular\fR
masochism), they might do well ta peep bout choosin as a topic the
implementation/adaptation of these routines ta any other interesting
programmin language dat you feel currently suffers from a lack of
robust HTML-parsing.  I welcome correspondence on dis subject, and
point up dat one can learn a pimped out deal bout languages by tryin to
translate between them, n' then comparin tha result.
.PP
Da HTML::TreeBuilder source may seem long n' complex yo, but it is
rather well commented, n' symbol names is generally
self-explanatory.  (Yo ass is encouraged ta read tha Mo'jizzle \s-1HTML\s0 parser
source fo' comparison.)  Some of tha complexitizzle be reppin lil-used
features, n' a shitload of it be reppin havin tha \s-1HTML\s0 tokenizer
(HTML::Parser) bein a separate module, requirin somewhat of a
different intercourse than you'd find up in a cold-ass lil combined tokenizer and
tree-builder n' shit.  But most of tha length of tha source be reppin tha fact
that itz essentially a long-ass list of special cases, wit fuckin shitloadz n' lots
of sanity-checking, n' sanity-recovery \*(-- cuz, as Roseanne
Rosannadanna once holla'd, "itz always \fIsomething\fR".
.PP
Users lookin ta compare nuff muthafuckin \s-1HTML\s0 parsers should peep the
source fo' Raggettz Tidy
(\f(CW\*(C`<http://www.w3.org/People/Raggett/tidy/>\*(C'\fR),
Mozilla
(\f(CW\*(C`<http://www.mozilla.org/>\*(C'\fR),
and possibly root round tha browsers section of Yahoo
to find tha various open-source ones
(\f(CW\*(C`<http://dir.yahoo.com/Computers_and_Internet/Software/Internet/World_Wide_Web/Browsers/>\*(C'\fR).
.SH "BUGS"
.IX Header "BUGS"
* Framesets seem ta work erectly now, nahmeean?  Email me if you git a strange
parse from a thugged-out document wit framesets.
.PP
* Straight-Up wack \s-1HTML\s0 code will, often as not, make fo' a somewhat
objectionable parse tree.  Regrettable yo, but unavoidably true.
.PP
* If you hustlin wit \f(CW\*(C`implicit_tags\*(C'\fR off (Dogg help you, nahmean biiiatch?), consider
that \f(CW\*(C`$tree\->content_list\*(C'\fR probably gotz nuff tha tree or grove from the
parse, n' not \f(CW$tree\fR itself (which will, oddly enough, be a implicit
\&\f(CW\*(C`<html>\*(C'\fR element).  This seems counter-intuitizzle n' problematic; but
seein as how tha fuck almost no \s-1HTML\s0 eva parses erectly wit \f(CW\*(C`implicit_tags\*(C'\fR
off, dis intercourse odditizzle seems tha least of yo' problems.
.SH "BUG REPORTS"
.IX Header "BUG REPORTS"
When a thugged-out document parses up in a way different from how tha fuck you be thinkin it
should, I ask dat you report dis ta me as a funky-ass bug.  Da first thang
you should do is copy tha document, trim up as much of it as you can
while still producin tha bug up in question, n' \fIthen\fR email me that
mini-document \fIand\fR tha code you rockin ta parse it, ta tha HTML::Tree
bug queue at \f(CW\*(C`<bug\-html\-tree\ at\ rt.cpan.org>\*(C'\fR.
.PP
Include a note as ta how tha fuck it
parses (presumably includin its \f(CW\*(C`$tree\->dump\*(C'\fR output), n' then a
\&\fIcareful n' clear\fR explanation of where you be thinkin tha parser is
goin astray, n' how tha fuck you would prefer dat it work instead.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For mo' shiznit bout tha HTML-Tree distribution: HTML::Tree.
.PP
Modulez used by HTML::TreeBuilder:
HTML::Parser, HTML::Element, HTML::Tagset.
.PP
For convertin between XML::DOM::Node, HTML::Element, and
XML::Element trees: HTML::DOMbo.
.PP
For openin a \s-1HTML\s0 file wit automatic charset detection: \s-1IO::HTML\s0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Current maintainers:
.IP "\(bu" 4
Christopher J. Madsen \f(CW\*(C`<perl\ AT\ cjmweb.net>\*(C'\fR
.IP "\(bu" 4
Jeff Fearn \f(CW\*(C`<jfearn\ AT\ cpan.org>\*(C'\fR
.PP
Original Gangsta HTML-Tree author:
.IP "\(bu" 4
Gisle Aas
.PP
Forma maintainers:
.IP "\(bu" 4
Shizzle M. Burke
.IP "\(bu" 4
Andy Lester
.IP "\(bu" 4
Pete Krawczyk \f(CW\*(C`<petek\ AT\ cpan.org>\*(C'\fR
.PP
Yo ass can follow or contribute ta HTML-Treez pimpment at
<http://github.com/madsen/HTML\-Tree>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1995\-1998 Gisle Aas, 1999\-2004 Shizzle M. Burke,
2005 Andy Lester, 2006 Pete Krawczyk, 2010 Jeff Fearn,
2012 Christopher J. Madsen.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.PP
Da programs up in dis library is distributed up in tha hope dat they
will be useful yo, but without any warranty; without even tha implied
warranty of merchantabilitizzle or fitnizz fo' a particular purpose.
