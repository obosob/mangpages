.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::Spec 3"
.TH File::Spec 3 "2013-01-16" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Spec \- portably big-ass up operations on file names
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use File::Spec;
\&
\&        $x=File::Spec\->catfile(\*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq);
.Ve
.PP
which returns 'a/b/c' under Unix. Or:
.PP
.Vb 1
\&        use File::Spec::Functions;
\&
\&        $x = catfile(\*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is designed ta support operations commonly performed on file
specifications (usually called \*(L"file names\*(R" yo, but not ta be trippin wit the
contentz of a gangbangin' file, or Perlz file handles), like fuckin concatenatin several
directory n' file names tha fuck into a single path, or determinin whether a path
is rooted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Well shiiiit, it is based on code directly taken from MakeMaker 5.17, code
written by Andreas Ko\*:nig, Andy Dougherty, Charlez Bailey, Ilya
Zakharevich, Pizzle Schinder, n' others.
.PP
Since these functions is different fo' most operatin systems, each set of
\&\s-1OS\s0 specific routines be available up in a separate module, including:
.PP
.Vb 5
\&        File::Spec::Unix
\&        File::Spec::Mac
\&        File::Spec::OS2
\&        File::Spec::Win32
\&        File::Spec::VMS
.Ve
.PP
Da module appropriate fo' tha current \s-1OS\s0 be automatically loaded by
File::Spec. Right back up in yo muthafuckin ass. Since some modulez (like \s-1VMS\s0) make use of facilitizzles available
only under dat \s-1OS,\s0 it may not be possible ta load all modulez under all
operatin systems.
.PP
Since File::Spec is object oriented, subroutines should not be called directly,
as in:
.PP
.Vb 1
\&        File::Spec::catfile(\*(Aqa\*(Aq,\*(Aqb\*(Aq);
.Ve
.PP
but rather as class methods:
.PP
.Vb 1
\&        File::Spec\->catfile(\*(Aqa\*(Aq,\*(Aqb\*(Aq);
.Ve
.PP
For simple uses, File::Spec::Functions serves up convenient functional
formz of these methods.
.SH "METHODS"
.IX Header "METHODS"
.IP "canonpath" 2
.IX Xref "canonpath"
.IX Item "canonpath"
No physical check on tha filesystem yo, but a logical cleanup of a
path.
.Sp
.Vb 1
\&    $cpath = File::Spec\->canonpath( $path ) ;
.Ve
.Sp
Note dat dis do *not* collapse \fIx/../y\fR sections tha fuck into \fIy\fR.  This
is by design. I aint talkin' bout chicken n' gravy biatch.  If \fI/foo\fR on yo' system be a symlink ta \fI/bar/baz\fR,
then \fI/foo/../quux\fR is straight-up \fI/bar/quux\fR, not \fI/quux\fR as a naive
\&\fI../\fR\-removal would give yo thugged-out ass.  If you wanna do dis kind of
processing, you probably want \f(CW\*(C`Cwd\*(C'\fRz \f(CW\*(C`realpath()\*(C'\fR function to
actually traverse tha filesystem cleanin up paths like all dis bullshit.
.IP "catdir" 2
.IX Xref "catdir"
.IX Item "catdir"
Concatenate two or mo' directory names ta form a cold-ass lil complete path ending
with a gangbangin' finger-lickin' directory. But remove tha trailin slash from tha resulting
string, cuz it don't look good, aint necessary n' confuses
\&\s-1OS/2.\s0 Of course, if dis is tha root directory, don't cut off the
trailin slash :\-)
.Sp
.Vb 1
\&    $path = File::Spec\->catdir( @directories );
.Ve
.IP "catfile" 2
.IX Xref "catfile"
.IX Item "catfile"
Concatenate one or mo' directory names n' a gangbangin' filename ta form a
complete path endin wit a gangbangin' filename
.Sp
.Vb 1
\&    $path = File::Spec\->catfile( @directories, $filename );
.Ve
.IP "curdir" 2
.IX Xref "curdir"
.IX Item "curdir"
Returns a strang representation of tha current directory.
.Sp
.Vb 1
\&    $curdir = File::Spec\->curdir();
.Ve
.IP "devnull" 2
.IX Xref "devnull"
.IX Item "devnull"
Returns a strang representation of tha null device.
.Sp
.Vb 1
\&    $devnull = File::Spec\->devnull();
.Ve
.IP "rootdir" 2
.IX Xref "rootdir"
.IX Item "rootdir"
Returns a strang representation of tha root directory.
.Sp
.Vb 1
\&    $rootdir = File::Spec\->rootdir();
.Ve
.IP "tmpdir" 2
.IX Xref "tmpdir"
.IX Item "tmpdir"
Returns a strang representation of tha straight-up original gangsta writable directory from a
list of possible temporary directories. Put ya muthafuckin choppers up if ya feel dis!  Returns tha current directory
if no writable temporary directories is found. Y'all KNOW dat shit, muthafucka!  Da list of directories
checked dependz on tha platform; e.g. File::Spec::Unix checks \f(CW$ENV{TMPDIR}\fR
(unless taint is on) n' \fI/tmp\fR.
.Sp
.Vb 1
\&    $tmpdir = File::Spec\->tmpdir();
.Ve
.IP "updir" 2
.IX Xref "updir"
.IX Item "updir"
Returns a strang representation of tha parent directory.
.Sp
.Vb 1
\&    $updir = File::Spec\->updir();
.Ve
.IP "no_upwards" 2
.IX Item "no_upwards"
Given a list of file names, strip up dem dat refer ta a parent
directory. (Do not strip symlinks, only '.', '..', n' equivalents.)
.Sp
.Vb 1
\&    @paths = File::Spec\->no_upwards( @paths );
.Ve
.IP "case_tolerant" 2
.IX Item "case_tolerant"
Returns a legit or false value indicating, respectively, dat alphabetic
case aint or is dope when comparin file justifications.
Cygwin n' Win32 accept a optionizzle drive argument.
.Sp
.Vb 1
\&    $is_case_tolerant = File::Spec\->case_tolerant();
.Ve
.IP "file_name_is_absolute" 2
.IX Item "file_name_is_absolute"
Takes as its argument a path, n' returns legit if it be a absolute path.
.Sp
.Vb 1
\&    $is_absolute = File::Spec\->file_name_is_absolute( $path );
.Ve
.Sp
This do not consult tha local filesystem on Unix, Win32, \s-1OS/2,\s0 or
Mac \s-1OS \s0(Classic).  It do consult tha hustlin environment fo' \s-1VMS
\&\s0(see \*(L"file_name_is_absolute\*(R" up in File::Spec::VMS).
.IP "path" 2
.IX Xref "path"
.IX Item "path"
Takes no argument.  Returns tha environment variable \f(CW\*(C`PATH\*(C'\fR (or tha local
platformz equivalent) as a list.
.Sp
.Vb 1
\&    @PATH = File::Spec\->path();
.Ve
.IP "join" 2
.IX Xref "join, path"
.IX Item "join"
join is tha same ol' dirty as catfile.
.IP "splitpath" 2
.IX Xref "splitpath split, path"
.IX Item "splitpath"
Splits a path up in ta volume, directory, n' filename portions. On systems
with no concept of volume, returns '' fo' volume.
.Sp
.Vb 4
\&    ($volume,$directories,$file) =
\&                       File::Spec\->splitpath( $path );
\&    ($volume,$directories,$file) =
\&                       File::Spec\->splitpath( $path, $no_file );
.Ve
.Sp
For systems wit no syntax differentiatin filenames from directories, 
assumes dat tha last file be a path unless \f(CW$no_file\fR is legit or a
trailin separator or \fI/.\fR or \fI/..\fR is present. On Unix, dis means dat \f(CW$no_file\fR
true make dis return ( '', \f(CW$path\fR, '' ).
.Sp
Da directory portion may or may not be returned wit a trailin '/'.
.Sp
Da thangs up in dis biatch can be passed ta \*(L"\fIcatpath()\fR\*(R" ta git back a path equivalent to
(usually identical to) tha original gangsta path.
.IP "splitdir" 2
.IX Xref "splitdir split, dir"
.IX Item "splitdir"
Da opposite of \*(L"catdir\*(R".
.Sp
.Vb 1
\&    @dirs = File::Spec\->splitdir( $directories );
.Ve
.Sp
\&\f(CW$directories\fR must be only tha directory portion of tha path on systems 
that have tha concept of a volume or dat have path syntax dat differentiates
filez from directories.
.Sp
Unlike just splittin tha directories on tha separator, empty
directory names (\f(CW\*(Aq\*(Aq\fR) can be returned, cuz these is significant
on some OSes.
.IP "\fIcatpath()\fR" 2
.IX Item "catpath()"
Takes volume, directory n' file portions n' returns a entire path. Under
Unix, \f(CW$volume\fR is ignored, n' directory n' file is concatenated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  A '/' is
inserted if need be.  On other OSes, \f(CW$volume\fR is significant.
.Sp
.Vb 1
\&    $full_path = File::Spec\->catpath( $volume, $directory, $file );
.Ve
.IP "abs2rel" 2
.IX Xref "abs2rel absolute, path relative, path"
.IX Item "abs2rel"
Takes a thugged-out destination path n' a optionizzle base path returns a relatizzle path
from tha base path ta tha destination path:
.Sp
.Vb 2
\&    $rel_path = File::Spec\->abs2rel( $path ) ;
\&    $rel_path = File::Spec\->abs2rel( $path, $base ) ;
.Ve
.Sp
If \f(CW$base\fR aint present or '', then \fICwd::cwd()\fR is used. Y'all KNOW dat shit, muthafucka! If \f(CW$base\fR is
relative, then it is converted ta absolute form using
\&\*(L"\fIrel2abs()\fR\*(R". This means dat it is taken ta be relatizzle to
\&\fICwd::cwd()\fR.
.Sp
On systems wit tha concept of volume, if \f(CW$path\fR n' \f(CW$base\fR step tha fuck up ta be
on two different volumes, we aint gonna attempt ta resolve tha two
paths, n' we will instead simply return \f(CW$path\fR.  Note dat previous
versionz of dis module ignored tha volume of \f(CW$base\fR, which resulted in
garbage thangs up in dis biatch part of tha time.
.Sp
On systems dat gotz a grammar dat indicates filenames, dis ignores tha 
\&\f(CW$base\fR filename as well. Otherwise all path components is assumed ta be
directories.
.Sp
If \f(CW$path\fR is relative, it is converted ta absolute form rockin \*(L"\fIrel2abs()\fR\*(R".
This means dat it is taken ta be relatizzle ta \fICwd::cwd()\fR.
.Sp
No checks against tha filesystem is made.  On \s-1VMS,\s0 there is
interaction wit tha hustlin environment, as logicals and
macros is expanded.
.Sp
Based on code freestyled by Shigio Yamaguchi.
.IP "\fIrel2abs()\fR" 2
.IX Xref "rel2abs absolute, path relative, path"
.IX Item "rel2abs()"
Converts a relatizzle path ta a absolute path.
.Sp
.Vb 2
\&    $abs_path = File::Spec\->rel2abs( $path ) ;
\&    $abs_path = File::Spec\->rel2abs( $path, $base ) ;
.Ve
.Sp
If \f(CW$base\fR aint present or '', then \fICwd::cwd()\fR is used. Y'all KNOW dat shit, muthafucka! If \f(CW$base\fR is relative,
then it is converted ta absolute form rockin \*(L"\fIrel2abs()\fR\*(R". This means dat it
is taken ta be relatizzle ta \fICwd::cwd()\fR.
.Sp
On systems wit tha concept of volume, if \f(CW$path\fR n' \f(CW$base\fR step tha fuck up ta be
on two different volumes, we aint gonna attempt ta resolve tha two
paths, n' we will instead simply return \f(CW$path\fR.  Note dat previous
versionz of dis module ignored tha volume of \f(CW$base\fR, which resulted in
garbage thangs up in dis biatch part of tha time.
.Sp
On systems dat gotz a grammar dat indicates filenames, dis ignores tha 
\&\f(CW$base\fR filename as well. Otherwise all path components is assumed ta be
directories.
.Sp
If \f(CW$path\fR be absolute, it is cleaned up n' returned rockin \*(L"canonpath\*(R".
.Sp
No checks against tha filesystem is made.  On \s-1VMS,\s0 there is
interaction wit tha hustlin environment, as logicals and
macros is expanded.
.Sp
Based on code freestyled by Shigio Yamaguchi.
.PP
For further shiznit, please peep File::Spec::Unix,
File::Spec::Mac, File::Spec::OS2, File::Spec::Win32, or
File::Spec::VMS.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
File::Spec::Win32, File::Spec::VMS, File::Spec::Functions,
ExtUtils::MakeMaker
.SH "AUTHOR"
.IX Header "AUTHOR"
Currently maintained by Ken Williams \f(CW\*(C`<KWILLIAMS@cpan.org>\*(C'\fR.
.PP
Da vast majoritizzle of tha code was freestyled by
Kenneth Albanowski \f(CW\*(C`<kjahds@kjahds.com>\*(C'\fR,
Andy Dougherty \f(CW\*(C`<doughera@lafayette.edu>\*(C'\fR,
Andreas Ko\*:nig \f(CW\*(C`<A.Koenig@franz.ww.TU\-Berlin.DE>\*(C'\fR,
Slim Tim Bunce \f(CW\*(C`<Tim.Bunce@ig.co.uk>\*(C'\fR.
\&\s-1VMS\s0 support by Charlez Bailey \f(CW\*(C`<bailey@newman.upenn.edu>\*(C'\fR.
\&\s-1OS/2\s0 support by Ilya Zakharevich \f(CW\*(C`<ilya@math.ohio\-state.edu>\*(C'\fR.
Mac support by Pizzle Schinder \f(CW\*(C`<schinder@pobox.com>\*(C'\fR, and
Thomas Wegner \f(CW\*(C`<wegner_thomas@yahoo.com>\*(C'\fR.
\&\fIabs2rel()\fR n' \fIrel2abs()\fR freestyled by Shigio Yamaguchi \f(CW\*(C`<shigio@tamacom.com>\*(C'\fR,
modified by Barrie Slaymaker \f(CW\*(C`<barries@slaysys.com>\*(C'\fR.
\&\fIsplitpath()\fR, \fIsplitdir()\fR, \fIcatpath()\fR n' \fIcatdir()\fR by Barrie Slaymaker.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004\-2013 by tha Perl 5 Porters.  All muthafuckin rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
