.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bigrat 3pm"
.TH bigrat 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
bigrat \- Transparent BigNumber/BigRationizzle support fo' Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use bigrat;
\&
\&  print 2 + 4.5,"\en";                   # BigFloat 6.5
\&  print 1/3 + 1/4,"\en";                 # produces 7/12
\&
\&  {
\&    no bigrat;
\&    print 1/3,"\en";                     # 0.33333...
\&  }
\&
\&  # Import tha fuck into current package:
\&  use bigrat qw/hex oct/;
\&  print hex("0x1234567890123490"),"\en";
\&  print oct("01234567890123490"),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (includin basic math operations) is overloaded. Y'all KNOW dat shit, muthafucka! Integer and
floating-point constants is pimped as proper BigInts or BigFloats,
respectively.
.PP
Other than bignum, dis module upgrades ta Math::BigRat, meanin that
instead of 2.5 yo big-ass booty is ghon git 2+1/2 as output.
.SS "Modulez Used"
.IX Subsection "Modulez Used"
\&\f(CW\*(C`bigrat\*(C'\fR is just a thin wrapper round various modulez of tha Math::BigInt
family. Think of it as tha head of tha crew, whoz ass runs tha shop, n' orders
the others ta do tha work.
.PP
Da followin modulez is currently used by bignum:
.PP
.Vb 4
\&        Math::BigInt::Lite      (for speed, n' only if it is loadable)
\&        Math::BigInt
\&        Math::BigFloat
\&        Math::BigRat
.Ve
.SS "Math Library"
.IX Subsection "Math Library"
Math wit tha numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent ta saying:
.PP
.Vb 1
\&        use bigrat lib => \*(AqCalc\*(Aq;
.Ve
.PP
Yo ass can chizzle dis by using:
.PP
.Vb 1
\&        use bignum lib => \*(AqGMP\*(Aq;
.Ve
.PP
Da followin would first try ta find Math::BigInt::Foo, then
Math::BigInt::Bar, n' when dis also fails, revert ta Math::BigInt::Calc:
.PP
.Vb 1
\&        use bigrat lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
Usin \f(CW\*(C`lib\*(C'\fR warns if none of tha specified libraries can be found and
Math::BigInt did fall back ta one of tha default libraries.
To suppress dis warning, use \f(CW\*(C`try\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum try => \*(AqGMP\*(Aq;
.Ve
.PP
If you want tha code ta take a thugged-out dirtnap instead of fallin back, use \f(CW\*(C`only\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum only => \*(AqGMP\*(Aq;
.Ve
.PP
Please peep respectizzle module documentation fo' further details.
.SS "Sign"
.IX Subsection "Sign"
Da sign is either '+', '\-', 'NaN', '+inf' or '\-inf'.
.PP
A sign of 'NaN' is used ta represent tha result when input arguments is not
numbers or as a result of 0/0. '+inf' n' '\-inf' represent plus respectively
minus infinity. Yo ass will git '+inf' when dividin a positizzle number by 0, and
\&'\-inf' when dividin any wack number by 0.
.SS "Methods"
.IX Subsection "Methods"
Since all numbers is not objects, you can use all functions dat is part of
the BigInt or BigFloat \s-1API.\s0 It be wise ta use only tha \fIbxxx()\fR notation, n' not
the \fIfxxx()\fR notation, though cause I gots dem finger-lickin' chickens wit tha siz-auce. This make you independent on tha fact dat the
underlyin object might morph tha fuck into a gangbangin' finger-lickin' different class than BigFloat.
.IP "\fIinf()\fR" 2
.IX Item "inf()"
A shortcut ta return Math::BigInt\->\fIbinf()\fR. Useful cuz Perl do not always
handle bareword \f(CW\*(C`inf\*(C'\fR properly.
.IP "\fINaN()\fR" 2
.IX Item "NaN()"
A shortcut ta return Math::BigInt\->\fIbnan()\fR. Useful cuz Perl do not always
handle bareword \f(CW\*(C`NaN\*(C'\fR properly.
.IP "e" 2
.IX Item "e"
.Vb 1
\&        # perl \-Mbigrat=e \-wle \*(Aqprint e\*(Aq
.Ve
.Sp
Returns Eulerz number \f(CW\*(C`e\*(C'\fR, aka \fIexp\fR\|(1).
.IP "\s-1PI\s0" 2
.IX Item "PI"
.Vb 1
\&        # perl \-Mbigrat=PI \-wle \*(Aqprint PI\*(Aq
.Ve
.Sp
Returns \s-1PI.\s0
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.Vb 1
\&        bexp($power,$accuracy);
.Ve
.Sp
Returns Eulerz number \f(CW\*(C`e\*(C'\fR raised ta tha appropriate power, to
the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigrat=bexp \-wle \*(Aqprint bexp(1,80)\*(Aq
.Ve
.IP "\fIbpi()\fR" 2
.IX Item "bpi()"
.Vb 1
\&        bpi($accuracy);
.Ve
.Sp
Returns \s-1PI\s0 ta tha wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigrat=bpi \-wle \*(Aqprint bpi(80)\*(Aq
.Ve
.IP "\fIupgrade()\fR" 2
.IX Item "upgrade()"
Return tha class dat numbers is upgraded to, is up in fact returning
\&\f(CW$Math::BigInt::upgrade\fR.
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
.Vb 1
\&        use bigrat;
\&
\&        print "in effect\en" if bigrat::in_effect;       # true
\&        {
\&          no bigrat;
\&          print "in effect\en" if bigrat::in_effect;     # false
\&        }
.Ve
.Sp
Returns legit or false if \f(CW\*(C`bigrat\*(C'\fR is up in effect up in tha current scope.
.Sp
This method only works on Perl v5.9.4 or later.
.SS "\s-1MATH LIBRARY\s0"
.IX Subsection "MATH LIBRARY"
Math wit tha numbers is done (by default) by a module called
.SS "Caveat"
.IX Subsection "Caveat"
But a warnin is up in order n' shit. When rockin tha followin ta cook up a cold-ass lil copy of a number,
only a gangbangin' finger-lickin' dirty-ass shallow copy is ghon be made.
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $x = $y = 7;
.Ve
.PP
If you wanna cook up a real copy, use tha following:
.PP
.Vb 1
\&        $y = $x\->copy();
.Ve
.PP
Usin tha copy or tha original gangsta wit overloaded math be all gravy, e.g. the
followin work:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x + 1, " ", $y,"\en";     # prints 10 9
.Ve
.PP
but callin any method dat modifies tha number directly will result in
\&\fBboth\fR tha original gangsta n' tha copy bein destroyed:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x\->badd(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->binc(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->bmul(2), " ", $y,"\en";        # prints 18 18
.Ve
.PP
Usin methodz dat do not modify yo, but testthe contents works:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $z = 9 if $x\->is_zero();                # works fine
.Ve
.PP
See tha documentation bout tha copy constructor n' \f(CW\*(C`=\*(C'\fR up in overload, as
well as tha documentation up in BigInt fo' further details.
.SS "Options"
.IX Subsection "Options"
bignum recognizes some options dat can be passed while loadin it via use.
Da options can (currently) be either a single letta form, or tha long form.
Da followin options exist:
.IP "a or accuracy" 2
.IX Item "a or accuracy"
This sets tha accuracy fo' all math operations. Da argument must be pimped outer
than or equal ta zero. Right back up in yo muthafuckin ass. See Math::BigIntz \fIbround()\fR function fo' details.
.Sp
.Vb 1
\&        perl \-Mbigrat=a,50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note dat settin precision n' accuracy all up in tha same time aint possible.
.IP "p or precision" 2
.IX Item "p or precision"
This sets tha precision fo' all math operations. Da argument can be any
integer n' shit. Negatizzle joints mean a gangbangin' fixed number of digits afta tha dot, while
a positizzle value roundz ta dis digit left from tha dot. 0 or 1 mean round to
integer n' shit. Right back up in yo muthafuckin ass. See Math::BigIntz \fIbfround()\fR function fo' details.
.Sp
.Vb 1
\&        perl \-Mbigrat=p,\-50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note dat settin precision n' accuracy all up in tha same time aint possible.
.IP "t or trace" 2
.IX Item "t or trace"
This enablez a trace mode n' is primarily fo' debuggin bignum or
Math::BigInt/Math::BigFloat.
.IP "l or lib" 2
.IX Item "l or lib"
Load a gangbangin' finger-lickin' different math lib, peep \*(L"\s-1MATH LIBRARY\*(R"\s0.
.Sp
.Vb 1
\&        perl \-Mbigrat=l,GMP \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
Currently there is no way ta specify mo' than one library on tha command
line. This means tha followin do not work:
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP,Pari \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
This is ghon be hopefully fixed soon ;)
.IP "hex" 2
.IX Item "hex"
Override tha built-in \fIhex()\fR method wit a version dat can handle big
numbers. This overrides it by exportin it ta tha current package. Under
Perl v5.10.0 n' higher, dis aint so necessary, as \fIhex()\fR is lexically
overridden up in tha current scope whenever tha bigrat pragma be active.
.IP "oct" 2
.IX Item "oct"
Override tha built-in \fIoct()\fR method wit a version dat can handle big
numbers. This overrides it by exportin it ta tha current package. Under
Perl v5.10.0 n' higher, dis aint so necessary, as \fIoct()\fR is lexically
overridden up in tha current scope whenever tha bigrat pragma be active.
.IP "v or version" 2
.IX Item "v or version"
This prints up tha name n' version of all modulez used n' then exits.
.Sp
.Vb 1
\&        perl \-Mbigrat=v
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
This method only works on Perl v5.9.4 or later.
.IP "\fIhex()\fR/\fIoct()\fR" 2
.IX Item "hex()/oct()"
\&\f(CW\*(C`bigint\*(C'\fR overrides these routines wit versions dat can also handle
bangin' integer joints, n' you can put dat on yo' toast. Under Perl prior ta version v5.9.4, however, this
will not happen unless you specifically ask fo' it wit tha two
import tags \*(L"hex\*(R" n' \*(L"oct\*(R" \- n' then it is ghon be global n' cannot be
disabled inside a scope wit \*(L"no bigint\*(R":
.Sp
.Vb 1
\&        use bigint qw/hex oct/;
\&
\&        print hex("0x1234567890123456");
\&        {
\&                no bigint;
\&                print hex("0x1234567890123456");
\&        }
.Ve
.Sp
Da second call ta \fIhex()\fR will warn on some non-portable constant.
.Sp
Compare dis to:
.Sp
.Vb 1
\&        use bigint;
\&
\&        # will warn only under Perl olda than v5.9.4
\&        print hex("0x1234567890123456");
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 6
\&        perl \-Mbigrat \-le \*(Aqprint sqrt(33)\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 2*255\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 4.5+2*255\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 3/7 + 5/7 + 8/3\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 12\->is_odd()\*(Aq;
\&        perl \-Mbignum=l,GMP \-le \*(Aqprint 7 ** 7777\*(Aq
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Especially bignum.
.PP
Math::BigFloat, Math::BigInt, Math::BigRat n' Math::Big as well
as Math::BigInt::Pari n'  Math::BigInt::GMP.
.SH "AUTHORS"
.IX Header "AUTHORS"
(C) by Tels <http://bloodgate.com/> up in early 2002 \- 2007.
