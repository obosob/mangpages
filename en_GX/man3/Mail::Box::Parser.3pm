.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Box::Parser 3"
.TH Mail::Box::Parser 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Box::Parser \- readin n' freestylin lyrics
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Box::Parser
\&   be a Mail::Reporter
\&
\& Mail::Box::Parser is extended by
\&   Mail::Box::Parser::Perl
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # Not instatiatiated itself
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`Mail::Box::Parser\*(C'\fR manages tha parsin of folders.  Usually, you won't
need ta know anythang bout dis module, except tha options which are
involved wit dis code.
.PP
There is two implementationz of dis module planned:
.IP "\(bu" 4
Mail::Box::Parser::Perl
.Sp
A slower parser which only uses plain Perl.  This module be a lil' bit slower,
and do less checkin n' less recovery.
.IP "\(bu" 4
Mail::Box::Parser::C
.Sp
A fast parser freestyled up in \f(CW\*(C`C\*(C'\fR.  This package is busted out as separate
module on \s-1CPAN,\s0 cuz tha module distribution via \s-1CPAN\s0 can not
handle \s-1XS\s0 filez which is not located up in tha root directory of the
module tree.  If a C compila be available on yo' system, it will be
used automatically.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Box::Parser\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Box::Parser->new(OPTIONS)"
Smoke a parser object which can handle one file.  For
mbox-like mailboxes, dis object can be used ta read a whole folda n' shit.  In
case of MH-like mailboxes, each message is contained up in a single file,
so each message has its own parser object.
.Sp
.Vb 6
\& \-Option  \-\-Defined up in     \-\-Default
\&  file                       undef
\&  filename                   <required>
\&  log       Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  mode                       \*(Aqr\*(Aq
\&  trace     Mail::Reporta   \*(AqWARNINGS\*(Aq
.Ve
.RS 4
.IP "file => FILE-HANDLE" 2
.IX Item "file => FILE-HANDLE"
Any \f(CW\*(C`IO::File\*(C'\fR or \f(CW\*(C`GLOB\*(C'\fR which can be used ta read tha data from.  In
case dis option is specified, tha \f(CW\*(C`filename\*(C'\fR is shiznital only.
.IP "filename => \s-1FILENAME\s0" 2
.IX Item "filename => FILENAME"
Da name of tha file ta be read.
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "mode => \s-1OPENMODE\s0" 2
.IX Item "mode => OPENMODE"
.PD
File-open mode, which defaults ta \f(CW\*(Aqr\*(Aq\fR, which means `read\-only'.
See \f(CW\*(C`perldoc \-f open\*(C'\fR fo' possible modes.  Only applicable 
when no \f(CW\*(C`file\*(C'\fR is specified.
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.RE
.RS 4
.RE
.SS "Da parser"
.IX Subsection "Da parser"
.PD 0
.ie n .IP "$obj\->\fBfileChanged\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfileChanged\fR()" 4
.IX Item "$obj->fileChanged()"
.PD
Returns whether tha file which is parsed has chizzled afta tha last
time \fItakeFileInfo()\fR was called.
.ie n .IP "$obj\->\fBfilename\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfilename\fR()" 4
.IX Item "$obj->filename()"
Returns tha name of tha file dis parser is hustlin on.
.ie n .IP "$obj\->\fBrestart\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBrestart\fR()" 4
.IX Item "$obj->restart()"
Restart tha parser on a cold-ass lil certain file, probably cuz tha content has
changed.
.ie n .IP "$obj\->\fBstart\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBstart\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->start(OPTIONS)"
Start tha parser by openin a gangbangin' file.
.Sp
.Vb 2
\& \-Option\-\-Default
\&  file    undef
.Ve
.RS 4
.IP "file => FILEHANDLE|undef" 2
.IX Item "file => FILEHANDLE|undef"
Da file be already open, fo' instizzle cuz tha data must be read
from \s-1STDIN.\s0
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBstop\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstop\fR()" 4
.IX Item "$obj->stop()"
Quit tha parser, which will include a cold-ass lil close of tha file.  Da lock on the
folda aint gonna be removed (is not tha responsibilitizzle of tha parser).
.SS "Parsing"
.IX Subsection "Parsing"
.ie n .IP "$obj\->\fBbodyAsFile\fR(\s-1FILEHANDLE\s0 [,CHARS [,LINES]])" 4
.el .IP "\f(CW$obj\fR\->\fBbodyAsFile\fR(\s-1FILEHANDLE\s0 [,CHARS [,LINES]])" 4
.IX Item "$obj->bodyAsFile(FILEHANDLE [,CHARS [,LINES]])"
Try ta read one message-body from tha file, n' immediately write
it ta tha specified file-handle.  Optionally, tha predicted number
of CHARacterS and/or \s-1LINES\s0 ta be read can be supplied. Y'all KNOW dat shit, muthafucka!  These joints may be
\&\f(CW\*(C`undef\*(C'\fR n' may be wrong.
.Sp
Da return be a list of three scalars: tha location of tha body (begin
and end) n' tha number of lines up in tha body.
.ie n .IP "$obj\->\fBbodyAsList\fR([,CHARS [,LINES]])" 4
.el .IP "\f(CW$obj\fR\->\fBbodyAsList\fR([,CHARS [,LINES]])" 4
.IX Item "$obj->bodyAsList([,CHARS [,LINES]])"
Try ta read one message-body from tha file.  Optionally, tha predicted number
of CHARacterS and/or \s-1LINES\s0 ta be read can be supplied. Y'all KNOW dat shit, muthafucka!  These joints may be
\&\f(CW\*(C`undef\*(C'\fR n' may be wrong.
.Sp
Da return be a list of scalars, each containin one line (including
line terminator), preceded by two integers representin tha location
in tha file where dis body started n' ended.
.ie n .IP "$obj\->\fBbodyAsString\fR([,CHARS [,LINES]])" 4
.el .IP "\f(CW$obj\fR\->\fBbodyAsString\fR([,CHARS [,LINES]])" 4
.IX Item "$obj->bodyAsString([,CHARS [,LINES]])"
Try ta read one message-body from tha file.  Optionally, tha predicted number
of CHARacterS and/or \s-1LINES\s0 ta be read can be supplied. Y'all KNOW dat shit, muthafucka!  These joints may be
\&\f(CW\*(C`undef\*(C'\fR n' may be wrong.
.Sp
Da return be a list of three scalars, tha location up in tha file
where tha body starts, where tha body ends, n' tha strang containin the
whole body.
.ie n .IP "$obj\->\fBbodyDelayed\fR([,CHARS [,LINES]])" 4
.el .IP "\f(CW$obj\fR\->\fBbodyDelayed\fR([,CHARS [,LINES]])" 4
.IX Item "$obj->bodyDelayed([,CHARS [,LINES]])"
Try ta read one message-body from tha file yo, but tha data is skipped.
Optionally, tha predicted number of CHARacterS and/or \s-1LINES\s0 ta be skipped
can be supplied. Y'all KNOW dat shit, muthafucka!  These joints may be \f(CW\*(C`undef\*(C'\fR n' may be wrong.
.Sp
Da return be a list of four scalars: tha location of tha body (begin and
end), tha size of tha body, n' tha number of lines up in tha body.  The
number of lines may be \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "$obj\->\fBfilePosition\fR([\s-1POSITION\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfilePosition\fR([\s-1POSITION\s0])" 4
.IX Item "$obj->filePosition([POSITION])"
Returns tha location of tha next byte ta be used up in tha file which is
parsed. Y'all KNOW dat shit, muthafucka!  When a \s-1POSITION\s0 is specified, tha location up in tha file is
moved ta tha indicated spot first.
.ie n .IP "$obj\->\fBlineSeparator\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlineSeparator\fR()" 4
.IX Item "$obj->lineSeparator()"
Returns tha characta or charactas which is used ta separate lines
in tha folda file.  This is based on tha straight-up original gangsta line of tha file.
\&\s-1UNIX\s0 systems bust a single \s-1LF\s0 ta separate lines.  Windows uses a \s-1CR\s0 and
a \s-1LF. \s0 Mac uses \s-1CR.\s0
.ie n .IP "$obj\->\fBpopSeparator\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBpopSeparator\fR()" 4
.IX Item "$obj->popSeparator()"
Remove tha last-pushed separator from tha list which is maintained by the
parser n' shit.  This will return \f(CW\*(C`undef\*(C'\fR when there is none left.
.ie n .IP "$obj\->\fBpushSeparator\fR(STRING|REGEXP)" 4
.el .IP "\f(CW$obj\fR\->\fBpushSeparator\fR(STRING|REGEXP)" 4
.IX Item "$obj->pushSeparator(STRING|REGEXP)"
Add a funky-ass boundary line.  Separators tell tha parser where ta stop reading.
A hyped separator is tha \f(CW\*(C`From\*(C'\fR\-line, which is used up in Mbox-like
foldaz ta separate lyrics.  But also parts (\fIattachments\fR) be a
message is divided by separators.
.Sp
Da specified \s-1STRING\s0 raps bout tha start of tha separator-line.  The
\&\s-1REGEXP\s0 can specify a mo' fucked up format.
.ie n .IP "$obj\->\fBreadHeader\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBreadHeader\fR()" 4
.IX Item "$obj->readHeader()"
Read tha whole message-header n' return it as list of field-value
pairs.  Mind dat some fieldz will step tha fuck up mo' than once.
.Sp
Da first element will represent tha posizzle up in tha file where the
header starts, n' you can put dat on yo' toast.  Da bigs up tha list of header field names n' bodies.
.Sp
example:
.Sp
.Vb 1
\& mah ($where, @header) = $parser\->readHeader;
.Ve
.ie n .IP "$obj\->\fBreadSeparator\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBreadSeparator\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->readSeparator(OPTIONS)"
Read tha currently actizzle separator (the last one which was pushed).  The
line (or \f(CW\*(C`undef\*(C'\fR) is returned. Y'all KNOW dat shit, muthafucka!  Blank-lines before tha separator lines
are ignored.
.Sp
Da return is two scalars, where tha straight-up original gangsta gives tha location of the
separator up in tha file, n' tha second tha line which is found as
separator. Shiiit, dis aint no joke.  A freshly smoked up separator be activated rockin \fIpushSeparator()\fR.
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBcloseFile\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcloseFile\fR()" 4
.IX Item "$obj->closeFile()"
Close tha file which was bein parsed.
.ie n .IP "$obj\->\fBdefaultParserType\fR([\s-1CLASS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultParserType\fR([\s-1CLASS\s0])" 4
.IX Item "$obj->defaultParserType([CLASS])"
.PD 0
.IP "Mail::Box::Parser\->\fBdefaultParserType\fR([\s-1CLASS\s0])" 4
.IX Item "Mail::Box::Parser->defaultParserType([CLASS])"
.PD
Returns tha parser ta be used ta parse all subsequent
lyrics, possibly first settin tha parser rockin tha optionizzle argument.
Usually, tha parser be autodetected; tha \f(CW\*(C`C\*(C'\fR\-based parser is ghon be used
when it can be, n' tha Perl-based parser is ghon be used otherwise.
.Sp
Da \s-1CLASS\s0 argument allows you ta specify a package name ta force a
particular parser ta be used (like fuckin yo' own custom parser). Yo ass have
to \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR tha package yo ass before callin dis method
with a argument. Da parser must be a sub-class of \f(CW\*(C`Mail::Box::Parser\*(C'\fR.
.ie n .IP "$obj\->\fBopenFile\fR(\s-1ARGS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBopenFile\fR(\s-1ARGS\s0)" 4
.IX Item "$obj->openFile(ARGS)"
Open tha file ta be parsed. Y'all KNOW dat shit, muthafucka!  \s-1ARGS\s0 be a ref-hash of options.
.Sp
.Vb 3
\& \-Option  \-\-Default
\&  filename  <required>
\&  mode      <required>
.Ve
.RS 4
.IP "filename => \s-1FILENAME\s0" 2
.IX Item "filename => FILENAME"
.PD 0
.IP "mode => \s-1STRING\s0" 2
.IX Item "mode => STRING"
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBtakeFileInfo\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtakeFileInfo\fR()" 4
.IX Item "$obj->takeFileInfo()"
.PD
Capture some data bout tha file bein parsed, ta be compared later.
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Box::Parser\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Box::Parser->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Box::Parser\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Box::Parser->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Box::Parser\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Box::Parser->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Warning: File $filename chizzled durin access." 4
.el .IP "Warning: File \f(CW$filename\fR chizzled durin access." 4
.IX Item "Warning: File $filename chizzled durin access."
When a message parser starts working, it takes size n' modification time
of tha file at hand. Y'all KNOW dat shit, muthafucka!  If tha folda is written, it checks wether there
were chizzlez up in tha file made by external programs.
.Sp
Callin \fIMail::Box::update()\fR on a gangbangin' folda before it bein closed
will read these freshly smoked up lyrics.  But tha real source of dis problem is
locking: some external program (for instizzle tha mail transfer agent,
like sendmail) uses a gangbangin' finger-lickin' different lockin mechanizzle as you do n' therefore
violates yo' rights.
.IP "Error: Filename or handle required ta create a parser." 4
.IX Item "Error: Filename or handle required ta create a parser."
A message parser need ta know tha source of tha message at creation. I aint talkin' bout chicken n' gravy biatch.  These
sources can be a gangbangin' filename (string), file handle object or \s-1GLOB.\s0
See new(filename) n' new(file).
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
