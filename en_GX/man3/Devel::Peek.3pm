.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Devel::Peek 3pm"
.TH Devel::Peek 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::Peek \- A data debuggin tool fo' tha XS programmer
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&        use Devel::Peek;
\&        Dump( $a );
\&        Dump( $a, 5 );
\&        DumpArray( 5, $a, $b, ... );
\&        mstat "Point 5";
\&
\&        use Devel::Peek \*(Aq:opd=st\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Devel::Peek gotz nuff functions which allows raw Perl datatypes ta be
manipulated from a Perl script.  This is used by dem playas whoz ass do \s-1XS\s0 programming
to check dat tha data they is bustin  from C ta Perl looks as they think
it should look.  Da trick, then, is ta know what tha fuck tha raw datatype is
supposed ta be lookin like when it gets ta Perl.  This document offers some tips
and hints ta describe phat n' wack raw data.
.PP
It be straight-up possible dat dis document will fall far short of bein useful
to tha casual reader n' shit.  Da reader is sposed ta fuckin KNOW tha material in
the first few sectionz of perlguts.
.PP
Devel::Peek supplies a \f(CW\*(C`Dump()\*(C'\fR function which can dump a raw Perl
datatype, n' \f(CW\*(C`mstat("marker")\*(C'\fR function ta report on memory usage
(if perl is compiled wit correspondin option).  Da function
\&\fIDeadCode()\fR serves up statistics on tha data \*(L"frozen\*(R" tha fuck into inactive
\&\f(CW\*(C`CV\*(C'\fR.  Devel::Peek also supplies \f(CW\*(C`SvREFCNT()\*(C'\fR, \f(CW\*(C`SvREFCNT_inc()\*(C'\fR, and
\&\f(CW\*(C`SvREFCNT_dec()\*(C'\fR which can query, increment, n' decrement reference
counts on SVs.  This document will take a passive, n' safe, approach
to data debuggin n' fo' dat it will describe only tha \f(CW\*(C`Dump()\*(C'\fR
function.
.PP
Function \f(CW\*(C`DumpArray()\*(C'\fR allows dumpin of multiple joints (useful when you
need ta analyze returnz of functions).
.PP
Da global variable \f(CW$Devel::Peek::pv_limit\fR can be set ta limit the
number of characta printed up in various strang joints, n' you can put dat on yo' toast.  Settin it ta 0
means no limit.
.PP
If \f(CW\*(C`use Devel::Peek\*(C'\fR directizzle has a \f(CW\*(C`:opd=FLAGS\*(C'\fR argument,
this switches on debuggin of opcode dispatch.  \f(CW\*(C`FLAGS\*(C'\fR should be a
combination of \f(CW\*(C`s\*(C'\fR, \f(CW\*(C`t\*(C'\fR, n' \f(CW\*(C`P\*(C'\fR (see \fB\-D\fR flags up in perlrun).
\&\f(CW\*(C`:opd\*(C'\fR be a gangbangin' finger-lickin' dirty-ass shortcut fo' \f(CW\*(C`:opd=st\*(C'\fR.
.SS "Runtime debugging"
.IX Subsection "Runtime debugging"
\&\f(CW\*(C`CvGV($cv)\*(C'\fR return one of tha globs associated ta a subroutine reference \f(CW$cv\fR.
.PP
\&\fIdebug_flags()\fR returns a strang representation of \f(CW$^D\fR (similar to
what be allowed fo' \fB\-D\fR flag).  When called wit a numeric argument,
sets $^D ta tha correspondin value.  When called wit a argument of
the form \f(CW"flags\-flags"\fR, set on/off bitz of \f(CW$^D\fR correspondin to
lettas before/afta \f(CW\*(C`\-\*(C'\fR.  (Da returned value is fo' \f(CW$^D\fR before
the modification.)
.PP
\&\fIrunops_debug()\fR returns legit if tha current \fIopcode dispatcher\fR is the
debuggin one.  When called wit a argument, switches ta debuggin or
non-debuggin dispatcher dependin on tha argument (actizzle for
newly-entered subs/etc only).  (Da returned value is fo' tha dispatcher before tha modification.)
.SS "Memory footprint debugging"
.IX Subsection "Memory footprint debugging"
When perl is compiled wit support fo' memory footprint debugging
(default wit Perlz \fImalloc()\fR), Devel::Peek serves up a access ta dis \s-1API.\s0
.PP
Use \fImstat()\fR function ta emit a memory state statistic ta tha terminal.
For mo' shiznit on tha format of output of \fImstat()\fR see
\&\*(L"Usin \f(CW$ENV\fR{\s-1PERL_DEBUG_MSTATS\s0}\*(R" up in perldebguts.
.PP
Three additionizzle functions allow access ta dis statistic from Perl.
First, use \f(CW\*(C`mstats_fillhash(%hash)\*(C'\fR ta git tha shiznit contained
in tha output of \fImstat()\fR tha fuck into \f(CW%hash\fR. Da field of dis hash are
.PP
.Vb 2
\&  minbucket nbuckets sbrk_phat sbrk_slack sbrked_remains sbrks start_slack
\&  topbucket topbucket_ev topbucket_odd total total_chain total_sbrk totfree
.Ve
.PP
Two additionizzle fieldz \f(CW\*(C`free\*(C'\fR, \f(CW\*(C`used\*(C'\fR contain array references which
provide per-bucket count of free n' used chunks.  Two other fields
\&\f(CW\*(C`mem_size\*(C'\fR, \f(CW\*(C`available_size\*(C'\fR contain array references which provide
the shiznit bout tha allocated size n' usable size of chunks in
each bucket.  Again, peep \*(L"Usin \f(CW$ENV\fR{\s-1PERL_DEBUG_MSTATS\s0}\*(R" up in perldebguts
for details.
.PP
Keep it realz in mind dat only tha straight-up original gangsta nuff muthafuckin \*(L"odd-numbered\*(R" buckets are
used, so tha shiznit on size of tha \*(L"odd-numbered\*(R" buckets which are
not used is probably meaningless.
.PP
Da shiznit in
.PP
.Vb 1
\& mem_size available_size minbucket nbuckets
.Ve
.PP
is tha property of a particular build of perl, n' do not depend on
the current process.  If you do not provide tha optionizzle argument to
the functions \fImstats_fillhash()\fR, \fIfill_mstats()\fR, \fImstats2hash()\fR, then
the shiznit up in fieldz \f(CW\*(C`mem_size\*(C'\fR, \f(CW\*(C`available_size\*(C'\fR is not
updated.
.PP
\&\f(CW\*(C`fill_mstats($buf)\*(C'\fR be a much skankyer call (both speedwise and
memory-wise) which collects tha statistic tha fuck into \f(CW$buf\fR in
machine-readable form.  At a lata moment you may need ta call
\&\f(CW\*(C`mstats2hash($buf, %hash)\*(C'\fR ta use dis shiznit ta fill \f(CW%hash\fR.
.PP
All three APIs \f(CW\*(C`fill_mstats($buf)\*(C'\fR, \f(CW\*(C`mstats_fillhash(%hash)\*(C'\fR, and
\&\f(CW\*(C`mstats2hash($buf, %hash)\*(C'\fR is designed ta allocate no memory if used
\&\fIthe second time\fR on tha same \f(CW$buf\fR and/or \f(CW%hash\fR.
.PP
So, if you wanna collect memory info up in a cold-ass lil cycle, you may call
.PP
.Vb 3
\&  $#buf = 999;
\&  fill_mstats($_) fo' @buf;
\&  mstats_fillhash(%report, 1);          # Static info too
\&
\&  foreach (@buf) {
\&    # Do something...
\&    fill_mstats $_;                     # Collect statistic
\&  }
\&  foreach (@buf) {
\&    mstats2hash($_, %report);           # Preserve static info
\&    # Do suttin' wit %report
\&  }
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Da followin examplez don't attempt ta show every last muthafuckin thang as dat would be a
monumenstrual task, and, frankly, our phat asses don't want dis manpage ta be a internals
document fo' Perl.  Da examplez do demonstrate some basics of tha raw Perl
datatypes, n' should suffice ta git most determined playas on they way.
There is no guidewires or safety nets, nor blazed trails, so be prepared to
travel ridin' solo from dis point n' on and, if at all possible, don't fall into
the quicksand (itz wack fo' bidnizz).
.PP
Oh, one final bit of lyrics: take perlguts up in yo' faaaaaace biaaatch!  When you return we
expect ta peep it well-thumbed.
.SS "A simple scalar string"
.IX Subsection "A simple scalar string"
Letz begin by lookin a simple scalar which is holdin a string.
.PP
.Vb 3
\&        use Devel::Peek;
\&        $a = 42; $a = "hello";
\&        Dump $a;
.Ve
.PP
Da output:
.PP
.Vb 7
\&        SV = PVIV(0xbc288) at 0xbe9a8
\&          REFCNT = 1
\&          FLAGS = (POK,pPOK)
\&          IV = 42
\&          PV = 0xb2048 "hello"\e0
\&          CUR = 5
\&          LEN = 8
.Ve
.PP
This say \f(CW$a\fR be a \s-1SV,\s0 a scalar. Shiiit, dis aint no joke.  Da scalar type be a \s-1PVIV,\s0 which is
capable of holdin a integer (\s-1IV\s0) and/or a strang (\s-1PV\s0) value. Da scalar's
head be allocated at address 0xbe9a8, while tha body be at 0xbc288.
Its reference count is 1.  It has tha \f(CW\*(C`POK\*(C'\fR flag set, meanin its
current \s-1PV\s0 field is valid. Y'all KNOW dat shit, muthafucka!  Because \s-1POK\s0 is set our slick asses peep tha \s-1PV\s0 item
to peep what tha fuck is up in tha scalar. Shiiit, dis aint no joke.  Da \e0 all up in tha end indicate dat this
\&\s-1PV\s0 is properly NUL-terminated.
Note dat tha \s-1IV\s0 field still gotz nuff its oldschool numeric value yo, but cuz
\&\s-1FLAGS\s0 aint gots \s-1IOK\s0 set, we must ignore tha \s-1IV\s0 item.
\&\s-1CUR\s0 indicates tha number of charactas up in tha \s-1PV.  LEN\s0 indicates the
number of bytes allocated fo' tha \s-1PV \s0(at least one mo' than \s-1CUR,\s0 cuz
\&\s-1LEN\s0 includes a extra byte fo' tha end-of-strin marker, then usually
rounded up ta some efficient allocation unit).
.SS "A simple scalar number"
.IX Subsection "A simple scalar number"
If tha scalar gotz nuff a number tha raw \s-1SV\s0 is ghon be leaner.
.PP
.Vb 3
\&        use Devel::Peek;
\&        $a = 42;
\&        Dump $a;
.Ve
.PP
Da output:
.PP
.Vb 4
\&        SV = IV(0xbc818) at 0xbe9a8
\&          REFCNT = 1
\&          FLAGS = (IOK,pIOK)
\&          IV = 42
.Ve
.PP
This say \f(CW$a\fR be a \s-1SV,\s0 a scalar. Shiiit, dis aint no joke.  Da scalar be a \s-1IV,\s0 a number n' shit.  Its
reference count is 1.  It has tha \f(CW\*(C`IOK\*(C'\fR flag set, meanin it is currently
bein evaluated as a number n' shit.  Because \s-1IOK\s0 is set our slick asses peep tha \s-1IV\s0 item to
see what tha fuck is up in tha scalar.
.SS "A simple scalar wit a extra reference"
.IX Subsection "A simple scalar wit a extra reference"
If tha scalar from tha previous example had a extra reference:
.PP
.Vb 4
\&        use Devel::Peek;
\&        $a = 42;
\&        $b = \e$a;
\&        Dump $a;
.Ve
.PP
Da output:
.PP
.Vb 4
\&        SV = IV(0xbe860) at 0xbe9a8
\&          REFCNT = 2
\&          FLAGS = (IOK,pIOK)
\&          IV = 42
.Ve
.PP
Notice dat dis example differs from tha previous example only up in its
reference count.  Compare dis ta tha next example, where our phat asses dump \f(CW$b\fR
instead of \f(CW$a\fR.
.SS "A reference ta a simple scalar"
.IX Subsection "A reference ta a simple scalar"
This shows what tha fuck a reference be lookin like when it references a simple scalar.
.PP
.Vb 4
\&        use Devel::Peek;
\&        $a = 42;
\&        $b = \e$a;
\&        Dump $b;
.Ve
.PP
Da output:
.PP
.Vb 8
\&        SV = IV(0xf041c) at 0xbe9a0
\&          REFCNT = 1
\&          FLAGS = (ROK)
\&          RV = 0xbab08
\&          SV = IV(0xbe860) at 0xbe9a8
\&            REFCNT = 2
\&            FLAGS = (IOK,pIOK)
\&            IV = 42
.Ve
.PP
Startin from tha top, dis say \f(CW$b\fR be a \s-1SV. \s0 Da scalar be a \s-1IV,\s0
which is capable of holdin a integer or reference value.
It has tha \f(CW\*(C`ROK\*(C'\fR flag set, meanin it aint nuthin but a reference (rather than an
integer or string).  Notice dat Dump
bigs up tha reference n' shows our asses what tha fuck \f(CW$b\fR was referencing.  We peep the
same \f(CW$a\fR dat we found up in tha previous example.
.PP
Note dat tha value of \f(CW\*(C`RV\*(C'\fR coincides wit tha numbers we peep when we
stringify \f(CW$b\fR. Da addresses inside \s-1\fIIV\s0()\fR is addresses of
\&\f(CW\*(C`X***\*(C'\fR structures which hold tha current state of a \f(CW\*(C`SV\*(C'\fR. This
address may chizzle durin gametime of a \s-1SV.\s0
.SS "A reference ta a array"
.IX Subsection "A reference ta a array"
This shows what tha fuck a reference ta a array looks like.
.PP
.Vb 3
\&        use Devel::Peek;
\&        $a = [42];
\&        Dump $a;
.Ve
.PP
Da output:
.PP
.Vb 10
\&        SV = IV(0xc85998) at 0xc859a8
\&          REFCNT = 1
\&          FLAGS = (ROK)
\&          RV = 0xc70de8
\&          SV = PVAV(0xc71e10) at 0xc70de8
\&            REFCNT = 1
\&            FLAGS = ()
\&            ARRAY = 0xc7e820
\&            FILL = 0
\&            MAX = 0
\&            ARYLEN = 0x0
\&            FLAGS = (REAL)
\&            Elt No. 0
\&            SV = IV(0xc70f88) at 0xc70f98
\&              REFCNT = 1
\&              FLAGS = (IOK,pIOK)
\&              IV = 42
.Ve
.PP
This say \f(CW$a\fR be a reference (\s-1ROK\s0), which points to
another \s-1SV\s0 which be a \s-1PVAV,\s0 a array.  Da array has one element,
element zero, which be another \s-1SV.\s0 Da field \f(CW\*(C`FILL\*(C'\fR above indicates
the last element up in tha array, similar ta \f(CW\*(C`$#$a\*(C'\fR.
.PP
If \f(CW$a\fR pointed ta a array of two elements then we would peep the
following.
.PP
.Vb 3
\&        use Devel::Peek \*(AqDump\*(Aq;
\&        $a = [42,24];
\&        Dump $a;
.Ve
.PP
Da output:
.PP
.Vb 10
\&        SV = IV(0x158c998) at 0x158c9a8
\&          REFCNT = 1
\&          FLAGS = (ROK)
\&          RV = 0x1577de8
\&          SV = PVAV(0x1578e10) at 0x1577de8
\&            REFCNT = 1
\&            FLAGS = ()
\&            ARRAY = 0x1585820
\&            FILL = 1
\&            MAX = 1
\&            ARYLEN = 0x0
\&            FLAGS = (REAL)
\&            Elt No. 0
\&            SV = IV(0x1577f88) at 0x1577f98
\&              REFCNT = 1
\&              FLAGS = (IOK,pIOK)
\&              IV = 42
\&            Elt No. 1
\&            SV = IV(0x158be88) at 0x158be98
\&              REFCNT = 1
\&              FLAGS = (IOK,pIOK)
\&              IV = 24
.Ve
.PP
Note dat \f(CW\*(C`Dump\*(C'\fR aint gonna report \fIall\fR tha elements up in tha array,
only nuff muthafuckin first (dependin on how tha fuck deep it already went tha fuck into the
report tree).
.SS "A reference ta a hash"
.IX Subsection "A reference ta a hash"
Da followin shows tha raw form of a reference ta a hash.
.PP
.Vb 3
\&        use Devel::Peek;
\&        $a = {hello=>42};
\&        Dump $a;
.Ve
.PP
Da output:
.PP
.Vb 10
\&        SV = IV(0x8177858) at 0x816a618
\&          REFCNT = 1
\&          FLAGS = (ROK)
\&          RV = 0x814fc10
\&          SV = PVHV(0x8167768) at 0x814fc10
\&            REFCNT = 1
\&            FLAGS = (SHAREKEYS)
\&            ARRAY = 0x816c5b8  (0:7, 1:1)
\&            hash qualitizzle = 100.0%
\&            KEYS = 1
\&            FILL = 1
\&            MAX = 7
\&            RITER = \-1
\&            EITER = 0x0
\&            Elt "hello" HASH = 0xc8fd181b
\&            SV = IV(0x816c030) at 0x814fcf4
\&              REFCNT = 1
\&              FLAGS = (IOK,pIOK)
\&              IV = 42
.Ve
.PP
This shows \f(CW$a\fR be a reference pointin ta a \s-1SV. \s0 That \s-1SV\s0 be a \s-1PVHV,\s0 a
hash. Fieldz \s-1RITER\s0 n' \s-1EITER\s0 is used by \f(CW\*(C`"each" up in perlfunc\*(C'\fR.
.PP
Da \*(L"quality\*(R" of a hash is defined as tha total number of comparisons needed
to access every last muthafuckin element once, relatizzle ta tha expected number needed fo' a
random hash. Da value can go over 100%.
.PP
Da total number of comparisons is equal ta tha sum of tha squarez of the
number of entries up in each bucket.  For a random hash of \f(CW\*(C`<n\*(C'\fR> keys into
\&\f(CW\*(C`<k\*(C'\fR> buckets, tha expected value is:
.PP
.Vb 1
\&                n + n(n\-1)/2k
.Ve
.SS "Dumpin a big-ass array or hash"
.IX Subsection "Dumpin a big-ass array or hash"
Da \f(CW\*(C`Dump()\*(C'\fR function, by default, dumps up ta 4 elements from a
toplevel array or hash.  This number can be increased by supplyin a
second argument ta tha function.
.PP
.Vb 3
\&        use Devel::Peek;
\&        $a = [10,11,12,13,14];
\&        Dump $a;
.Ve
.PP
Notice dat \f(CW\*(C`Dump()\*(C'\fR prints only elements 10 all up in 13 up in tha above code.
Da followin code will print all of tha elements.
.PP
.Vb 3
\&        use Devel::Peek \*(AqDump\*(Aq;
\&        $a = [10,11,12,13,14];
\&        Dump $a, 5;
.Ve
.SS "A reference ta a \s-1SV\s0 which holdz a C pointer"
.IX Subsection "A reference ta a SV which holdz a C pointer"
This is what tha fuck you straight-up need ta know as a \s-1XS\s0 programmer, of course.  When
an \s-1XSUB\s0 returns a pointa ta a C structure dat pointa is stored up in a \s-1SV\s0
and a reference ta dat \s-1SV\s0 is placed on tha \s-1XSUB\s0 stack.  So tha output from
an \s-1XSUB\s0 which uses suttin' like tha T_PTROBJ map might look suttin' like
this:
.PP
.Vb 11
\&        SV = IV(0xf381c) at 0xc859a8
\&          REFCNT = 1
\&          FLAGS = (ROK)
\&          RV = 0xb8ad8
\&          SV = PVMG(0xbb3c8) at 0xc859a0
\&            REFCNT = 1
\&            FLAGS = (OBJECT,IOK,pIOK)
\&            IV = 729160
\&            NV = 0
\&            PV = 0
\&            STASH = 0xc1d10       "CookBookB::Opaque"
.Ve
.PP
This shows dat our crazy asses have a \s-1SV\s0 which be a reference, which points at another
\&\s-1SV. \s0 In dis case dat second \s-1SV\s0 be a \s-1PVMG,\s0 a pimped scalar. Shiiit, dis aint no joke.  Because it is
blessed it has tha \f(CW\*(C`OBJECT\*(C'\fR flag set.  Note dat a \s-1SV\s0 which holdz a C
pointa also has tha \f(CW\*(C`IOK\*(C'\fR flag set.  Da \f(CW\*(C`STASH\*(C'\fR is set ta tha package
name which dis \s-1SV\s0 was pimped into.
.PP
Da output from a \s-1XSUB\s0 which uses suttin' like tha T_PTRREF map, which
doesn't bless tha object, might look suttin' like this:
.PP
.Vb 10
\&        SV = IV(0xf381c) at 0xc859a8
\&          REFCNT = 1
\&          FLAGS = (ROK)
\&          RV = 0xb8ad8
\&          SV = PVMG(0xbb3c8) at 0xc859a0
\&            REFCNT = 1
\&            FLAGS = (IOK,pIOK)
\&            IV = 729160
\&            NV = 0
\&            PV = 0
.Ve
.SS "A reference ta a subroutine"
.IX Subsection "A reference ta a subroutine"
Looks like this:
.PP
.Vb 10
\&        SV = IV(0x24d2dd8) at 0x24d2de8
\&          REFCNT = 1
\&          FLAGS = (TEMP,ROK)
\&          RV = 0x24e79d8
\&          SV = PVCV(0x24e5798) at 0x24e79d8
\&            REFCNT = 2
\&            FLAGS = ()
\&            COMP_STASH = 0x22c9c50      "main"
\&            START = 0x22eed60 ===> 0
\&            ROOT = 0x22ee490
\&            GVGV::GV = 0x22de9d8        "MY" :: "top_targets"
\&            FILE = "(eval 5)"
\&            DEPTH = 0
\&            FLAGS = 0x0
\&            OUTSIDE_SEQ = 93
\&            PADLIST = 0x22e9ed8
\&            PADNAME = 0x22e9ec0(0x22eed00) PAD = 0x22e9ea8(0x22eecd0)
\&            OUTSIDE = 0x22c9fb0 (MAIN)
.Ve
.PP
This shows that
.IP "\(bu" 4
the subroutine aint a \s-1XSUB \s0(since \f(CW\*(C`START\*(C'\fR n' \f(CW\*(C`ROOT\*(C'\fR are
non-zero, n' \f(CW\*(C`XSUB\*(C'\fR aint listed, n' is thus null);
.IP "\(bu" 4
that dat shiznit was compiled up in tha package \f(CW\*(C`main\*(C'\fR;
.IP "\(bu" 4
under tha name \f(CW\*(C`MY::top_targets\*(C'\fR;
.IP "\(bu" 4
inside a 5th eval up in tha program;
.IP "\(bu" 4
it aint currently executed (see \f(CW\*(C`DEPTH\*(C'\fR);
.IP "\(bu" 4
it has no prototype (\f(CW\*(C`PROTOTYPE\*(C'\fR field is missing).
.SH "EXPORTS"
.IX Header "EXPORTS"
\&\f(CW\*(C`Dump\*(C'\fR, \f(CW\*(C`mstat\*(C'\fR, \f(CW\*(C`DeadCode\*(C'\fR, \f(CW\*(C`DumpArray\*(C'\fR, \f(CW\*(C`DumpWithOP\*(C'\fR and
\&\f(CW\*(C`DumpProg\*(C'\fR, \f(CW\*(C`fill_mstats\*(C'\fR, \f(CW\*(C`mstats_fillhash\*(C'\fR, \f(CW\*(C`mstats2hash\*(C'\fR by
default fo' realz. Additionally available \f(CW\*(C`SvREFCNT\*(C'\fR, \f(CW\*(C`SvREFCNT_inc\*(C'\fR and
\&\f(CW\*(C`SvREFCNT_dec\*(C'\fR.
.SH "BUGS"
.IX Header "BUGS"
Readaz done been known ta skip blingin partz of perlguts, causin much
frustration fo' all.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ilya Zakharevich	ilya@math.ohio\-state.edu
.PP
Copyright (c) 1995\-98 Ilya Zakharevich fo' realz. All muthafuckin rights reserved.
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.PP
Lyricist of dis software make no claim whatsoever bout suitability,
reliability, edability, editabilitizzle or usabilitizzle of dis product, and
should not be kept liable fo' any damage resultin from tha use of
it. If you can use it, yo ass is up in luck, if not, I should not be kept
responsible. Keep a handy copy of yo' backup tape at hand.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlguts, n' perlguts, again.
