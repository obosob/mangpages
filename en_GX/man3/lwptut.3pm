.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "lwptut 3"
.TH lwptut 3 "2012-02-11" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
lwptut \-\- An LWP Tutorial
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1LWP \s0(short fo' \*(L"Library fo' \s-1WWW\s0 up in Perl\*(R") be a straight-up ghettofab crew of
Perl modulez fo' accessin data on tha Web. Like most Perl
module-distributions, each of \s-1LWP\s0z component modulez comes with
documentation dat be a cold-ass lil complete reference ta its intercourse yo. However,
there is all kindsa muthafuckin modulez up in \s-1LWP\s0 dat itz hard ta know where ta start
lookin fo' shiznit on how tha fuck ta do even tha simplest most common
things.
.PP
Straight-Up introducin you ta rockin \s-1LWP\s0 would require a whole book \*(-- a funky-ass book
that just happens ta exist, called \fIPerl & \s-1LWP\s0\fR. But dis article
should hit you wit a taste of how tha fuck you can go bout some common tasks with
\&\s-1LWP.\s0
.SS "Gettin documents wit LWP::Simple"
.IX Subsection "Gettin documents wit LWP::Simple"
If you just wanna git whatz at a particular \s-1URL,\s0 tha simplest way
to do it is LWP::Simplez functions.
.PP
In a Perl program, you can call its \f(CW\*(C`get($url)\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  It will try
gettin dat \s-1URL\s0z content.  If it works, then it'll return the
content; but if there be a some error, it'll return undef.
.PP
.Vb 2
\&  mah $url = \*(Aqhttp://www.npr.org/programs/fa/?todizzleDate=current\*(Aq;
\&    # Just a example: tha URL fo' da most thugged-out recent /Fresh Air/ show
\&
\&  use LWP::Simple;
\&  mah $content = git $url;
\&  take a thugged-out dirtnap "Couldn\*(Aqt git $url" unless defined $content;
\&
\&  # Then go do thangs wit $content, like this:
\&
\&  if($content =~ m/jazz/i) {
\&    print "They\*(Aqre rappin' bout jazz todizzle on Fresh Air!\en";
\&  }
\&  else {
\&    print "Fresh Air be apparently jazzless todizzle.\en";
\&  }
.Ve
.PP
Da handiest variant on \f(CW\*(C`get\*(C'\fR is \f(CW\*(C`getprint\*(C'\fR, which is useful up in Perl
one-liners.  If it can git tha page whose \s-1URL\s0 you provide, it sendz it
to \s-1STDOUT\s0; otherwise it bitches ta \s-1STDERR.\s0
.PP
.Vb 1
\&  % perl \-MLWP::Simple \-e "getprint \*(Aqhttp://www.cpan.org/RECENT\*(Aq"
.Ve
.PP
That is tha \s-1URL\s0 of a plain text file dat lists freshly smoked up filez up in \s-1CPAN\s0 in
the past two weeks.  Yo ass can easily make it part of a tidy lil
shell command, like dis one dat mails you tha list of new
\&\f(CW\*(C`Acme::\*(C'\fR modules:
.PP
.Vb 2
\&  % perl \-MLWP::Simple \-e "getprint \*(Aqhttp://www.cpan.org/RECENT\*(Aq"  \e
\&     | grep "/by\-module/Acme" | mail \-s "New Acme modules muthafucka! Joy!" $USER
.Ve
.PP
There is other useful functions up in LWP::Simple, includin one function
for hustlin a \s-1HEAD\s0 request on a \s-1URL \s0(useful fo' checkin links, or
gettin tha last-revised time of a \s-1URL\s0), n' two functions for
saving/mirrorin a \s-1URL\s0 ta a local file. Right back up in yo muthafuckin ass. See tha LWP::Simple
documentation fo' tha full details, or chapta 2 of \fIPerl
& \s-1LWP\s0\fR fo' mo' examples.
.SS "Da Basics of tha \s-1LWP\s0 Class Model"
.IX Subsection "Da Basics of tha LWP Class Model"
LWP::Simplez functions is handy fo' simple cases yo, but its functions
don't support dem scooby snacks or authorization, don't support settin header
lines up in tha \s-1HTTP\s0 request, generally don't support readin header lines
in tha \s-1HTTP\s0 response (notably tha full \s-1HTTP\s0 error message, up in case of an
error). To git at all dem features, you gonna gotta use tha full \s-1LWP\s0
class model.
.PP
While \s-1LWP\s0 consistz of dozenz of classes, tha main two dat you have to
understand is LWP::UserAgent n' HTTP::Response. LWP::UserAgent
is a cold-ass lil class fo' \*(L"virtual browsers\*(R" which you use fo' struttin requests,
and HTTP::Response be a cold-ass lil class fo' tha responses (or error lyrics)
that you git back from dem requests.
.PP
Da basic idiom is \f(CW\*(C`$response = $browser\->get($url)\*(C'\fR, or mo' fully
illustrated:
.PP
.Vb 1
\&  # Early up in yo' program:
\&  
\&  use LWP 5.64; # Loadz all blingin LWP classes, n' makes
\&                #  shizzle yo' version is reasonably recent.
\&
\&  mah $browser = LWP::UserAgent\->new;
\&  
\&  ...
\&  
\&  # Then later, whenever you need ta cook up a git request:
\&  mah $url = \*(Aqhttp://www.npr.org/programs/fa/?todizzleDate=current\*(Aq;
\&  
\&  mah $response = $browser\->get( $url );
\&  take a thugged-out dirtnap "Can\*(Aqt git $url \-\- ", $response\->status_line
\&   unless $response\->is_success;
\&
\&  take a thugged-out dirtnap "Yo, I was expectin HTML, not ", $response\->content_type
\&   unless $response\->content_type eq \*(Aqtext/html\*(Aq;
\&     # or whatever content\-type you\*(Aqre equipped ta deal with
\&
\&  # Otherwise, process tha content somehow:
\&  
\&  if($response\->decoded_content =~ m/jazz/i) {
\&    print "They\*(Aqre rappin' bout jazz todizzle on Fresh Air!\en";
\&  }
\&  else {
\&    print "Fresh Air be apparently jazzless todizzle.\en";
\&  }
.Ve
.PP
There is two objects involved: \f(CW$browser\fR, which holdz a object of
class LWP::UserAgent, n' then tha \f(CW$response\fR object, which is of
class HTTP::Response. Yo ass straight-up need only one browser object per
program; but every last muthafuckin time you cook up a request, you git back a new
HTTP::Response object, which gonna git some bangin-ass attributes:
.IP "\(bu" 4
A status code indicating
success or failure
(which you can test wit \f(CW\*(C`$response\->is_success\*(C'\fR).
.IP "\(bu" 4
An \s-1HTTP\s0 status
line dat is hopefully informatizzle if there be a gangbangin' failure (which you can
see wit \f(CW\*(C`$response\->status_line\*(C'\fR,
returnin suttin' like \*(L"404 Not Found\*(R").
.IP "\(bu" 4
A \s-1MIME\s0 content-type like \*(L"text/html\*(R", \*(L"image/gif\*(R",
\&\*(L"application/xml\*(R", etc., which you can peep wit 
\&\f(CW\*(C`$response\->content_type\*(C'\fR
.IP "\(bu" 4
Da actual content of tha response, up in \f(CW\*(C`$response\->decoded_content\*(C'\fR.
If tha response is \s-1HTML,\s0 thatz where tha \s-1HTML\s0 source will be; if
itz a \s-1GIF,\s0 then \f(CW\*(C`$response\->decoded_content\*(C'\fR is ghon be tha binary
\&\s-1GIF\s0 data.
.IP "\(bu" 4
And dozenz of other convenient n' mo' specific methodz dat are
documented up in tha docs fo' HTTP::Response, n' its superclasses
HTTP::Message n' HTTP::Headers.
.SS "Addin Other \s-1HTTP\s0 Request Headers"
.IX Subsection "Addin Other HTTP Request Headers"
Da most commonly used syntax fo' requests is \f(CW\*(C`$response =
$browser\->get($url)\*(C'\fR yo, but up in truth, you can add extra \s-1HTTP\s0 header
lines ta tha request by addin a list of key-value pairs afta tha \s-1URL,\s0
like so:
.PP
.Vb 1
\&  $response = $browser\->get( $url, $key1, $value1, $key2, $value2, ... );
.Ve
.PP
For example, herez how tha fuck ta bust some mo' Netscape-like headers, up in case
yo ass is dealin wit a joint dat would otherwise reject yo' request:
.PP
.Vb 6
\&  mah @ns_headaz = (
\&   \*(AqUser\-Agent\*(Aq => \*(AqMozilla/4.76 [en] (Win98; U)\*(Aq,
\&   \*(AqAccept\*(Aq => \*(Aqimage/gif, image/x\-xbitmap, image/jpeg, image/pjpeg, image/png, */*\*(Aq,
\&   \*(AqAccept\-Charset\*(Aq => \*(Aqiso\-8859\-1,*,utf\-8\*(Aq,
\&   \*(AqAccept\-Language\*(Aq => \*(Aqen\-US\*(Aq,
\&  );
\&
\&  ...
\&  
\&  $response = $browser\->get($url, @ns_headers);
.Ve
.PP
If you weren't reusin dat array, you could just go ahead n' do this:
.PP
.Vb 6
\&  $response = $browser\->get($url,
\&   \*(AqUser\-Agent\*(Aq => \*(AqMozilla/4.76 [en] (Win98; U)\*(Aq,
\&   \*(AqAccept\*(Aq => \*(Aqimage/gif, image/x\-xbitmap, image/jpeg, image/pjpeg, image/png, */*\*(Aq,
\&   \*(AqAccept\-Charset\*(Aq => \*(Aqiso\-8859\-1,*,utf\-8\*(Aq,
\&   \*(AqAccept\-Language\*(Aq => \*(Aqen\-US\*(Aq,
\&  );
.Ve
.PP
If you was only eva changin tha 'User\-Agent' line, you could just chizzle
the \f(CW$browser\fR objectz default line from \*(L"libwww\-perl/5.65\*(R" (or tha like)
to whatever you like, rockin tha LWP::UserAgent \f(CW\*(C`agent\*(C'\fR method:
.PP
.Vb 1
\&   $browser\->agent(\*(AqMozilla/4.76 [en] (Win98; U)\*(Aq);
.Ve
.SS "Enablin Cookies"
.IX Subsection "Enablin Cookies"
A default LWP::UserAgent object acts like a funky-ass browser wit its cookies
support turned off. There is various wayz of turnin it on, by setting
its \f(CW\*(C`cookie_jar\*(C'\fR attribute fo' realz. A \*(L"cookie jar\*(R" be a object representing
a lil database of all
the \s-1HTTP\s0 dem scooby snacks dat a funky-ass browser can know about. Well shiiiit, it can correspond ta a
file on disk (the way Netscape uses its \fIcookies.txt\fR file), or it can
be just a in-memory object dat starts up empty, n' whose collection of
cookies will disappear once tha program is finished hustlin.
.PP
To give a funky-ass browser a in-memory empty cookie jar, you set its \f(CW\*(C`cookie_jar\*(C'\fR
attribute like so:
.PP
.Vb 1
\&  $browser\->cookie_jar({});
.Ve
.PP
To give it a cold-ass lil copy dat is ghon be read from a gangbangin' file on disk, n' is ghon be saved
to it when tha program is finished hustlin, set tha \f(CW\*(C`cookie_jar\*(C'\fR attribute
like this:
.PP
.Vb 7
\&  use HTTP::Cookies;
\&  $browser\->cookie_jar( HTTP::Cookies\->new(
\&    \*(Aqfile\*(Aq => \*(Aq/some/where/cookies.lwp\*(Aq,
\&        # where ta read/write cookies
\&    \*(Aqautosave\*(Aq => 1,
\&        # save it ta disk when done
\&  ));
.Ve
.PP
That file is ghon be a LWP-specific format. If you wanna be access the
cookies up in yo' Netscape dem scooby snacks file, you can use the
HTTP::Cookies::Netscape class:
.PP
.Vb 2
\&  use HTTP::Cookies;
\&    # fo'sho, loadz HTTP::Cookies::Netscape too
\&  
\&  $browser\->cookie_jar( HTTP::Cookies::Netscape\->new(
\&    \*(Aqfile\*(Aq => \*(Aqc:/Program Files/Netscape/Users/DIR\-NAME\-HERE/cookies.txt\*(Aq,
\&        # where ta read cookies
\&  ));
.Ve
.PP
Yo ass could add a \f(CW\*(C`\*(Aqautosave\*(Aq => 1\*(C'\fR line as further above yo, but at
time of writing, itz uncertain whether Netscape might discard some of
the dem scooby snacks you could be freestylin back ta disk.
.SS "Postin Form Data"
.IX Subsection "Postin Form Data"
Many \s-1HTML\s0 forms bust data ta they server rockin a \s-1HTTP POST\s0 request, which
you can bust wit dis syntax:
.PP
.Vb 7
\& $response = $browser\->post( $url,
\&   [
\&     formkey1 => value1, 
\&     formkey2 => value2, 
\&     ...
\&   ],
\& );
.Ve
.PP
Or if you need ta bust \s-1HTTP\s0 headers:
.PP
.Vb 9
\& $response = $browser\->post( $url,
\&   [
\&     formkey1 => value1, 
\&     formkey2 => value2, 
\&     ...
\&   ],
\&   headerkey1 => value1, 
\&   headerkey2 => value2, 
\& );
.Ve
.PP
For example, tha followin program cook up a search request ta AltaVista
(by bustin  some form data via a \s-1HTTP POST\s0 request), n' extracts from
the \s-1HTML\s0 tha report of tha number of matches:
.PP
.Vb 4
\&  use strict;
\&  use warnings;
\&  use LWP 5.64;
\&  mah $browser = LWP::UserAgent\->new;
\&
\&  mah $word = \*(Aqtarragon\*(Aq;
\&
\&  mah $url = \*(Aqhttp://search.yahoo.com/yhs/search\*(Aq;
\&  mah $response = $browser\->post( $url,
\&    [ \*(Aqq\*(Aq => $word,  # tha Altavista query string
\&      \*(Aqfr\*(Aq => \*(Aqaltavista\*(Aq, \*(Aqpg\*(Aq => \*(Aqq\*(Aq, \*(Aqavkw\*(Aq => \*(Aqtgz\*(Aq, \*(Aqkl\*(Aq => \*(AqXX\*(Aq,
\&    ]
\&  );
\&  take a thugged-out dirtnap "$url error: ", $response\->status_line
\&   unless $response\->is_success;
\&  take a thugged-out dirtnap "Weird content type at $url \-\- ", $response\->content_type
\&   unless $response\->content_is_html;
\&
\&  if( $response\->decoded_content =~ m{([0\-9,]+)(?:<.*?>)? thangs up in dis biatch for} ) {
\&    # Da substrin is ghon be like "996,000</strong> thangs up in dis biatch for"
\&    print "$word: $1\en";
\&  }
\&  else {
\&    print "Couldn\*(Aqt find tha match\-strin up in tha response\en";
\&  }
.Ve
.SS "Sendin \s-1GET\s0 Form Data"
.IX Subsection "Sendin GET Form Data"
Some \s-1HTML\s0 forms convey they form data not by bustin  tha data
in a \s-1HTTP POST\s0 request yo, but by bustin a aiiight \s-1GET\s0 request with
the data stuck on tha end of tha \s-1URL. \s0 For example, if you went to
\&\f(CW\*(C`www.imdb.com\*(C'\fR n' ran a search on \*(L"Blade Runner\*(R", tha \s-1URL\s0 you'd see
in yo' browser window would be:
.PP
.Vb 1
\&  http://www.imdb.com/find?s=all&q=Blade+Runner
.Ve
.PP
To run tha same search wit \s-1LWP,\s0 you'd use dis idiom, which involves
the \s-1URI\s0 class:
.PP
.Vb 3
\&  use URI;
\&  mah $url = URI\->new( \*(Aqhttp://www.imdb.com/find\*(Aq );
\&    # make a object representin tha URL
\&
\&  $url\->query_form(  # And here tha form data pairs:
\&    \*(Aqq\*(Aq => \*(AqBlade Runner\*(Aq,
\&    \*(Aqs\*(Aq => \*(Aqall\*(Aq,
\&  );
\&
\&  mah $response = $browser\->get($url);
.Ve
.PP
See chapta 5 of \fIPerl & \s-1LWP\s0\fR fo' a longer rap of \s-1HTML\s0 forms
and of form data, n' chaptas 6 all up in 9 fo' a longer rap of
extractin data from \s-1HTML.\s0
.SS "Absolutizin URLs"
.IX Subsection "Absolutizin URLs"
Da \s-1URI\s0 class dat our laid-back asses just mentioned above serves up all sortz of methods
for accessin n' modifyin partz of URLs (like fuckin askin sort of \s-1URL\s0 it
is wit \f(CW\*(C`$url\->scheme\*(C'\fR, n' askin what tha fuck host it refers ta wit \f(CW\*(C`$url\->host\*(C'\fR, n' so on, as busted lyrics bout up in tha docs fo' tha \s-1URI\s0
class.  But fuck dat shiznit yo, tha word on tha street is dat tha methodz of most immediate interest
are tha \f(CW\*(C`query_form\*(C'\fR method peeped above, n' now tha \f(CW\*(C`new_abs\*(C'\fR method
for takin a probably-relatizzle \s-1URL\s0 strang (like \*(L"../foo.html\*(R") n' getting
back a absolute \s-1URL \s0(like \*(L"http://www.perl.com/stuff/foo.html\*(R"), as
shown here:
.PP
.Vb 2
\&  use URI;
\&  $abs = URI\->new_abs($maybe_relative, $base);
.Ve
.PP
For example, consider dis program dat matches URLs up in tha \s-1HTML\s0
list of freshly smoked up modulez up in \s-1CPAN:\s0
.PP
.Vb 4
\&  use strict;
\&  use warnings;
\&  use LWP;
\&  mah $browser = LWP::UserAgent\->new;
\&  
\&  mah $url = \*(Aqhttp://www.cpan.org/RECENT.html\*(Aq;
\&  mah $response = $browser\->get($url);
\&  take a thugged-out dirtnap "Can\*(Aqt git $url \-\- ", $response\->status_line
\&   unless $response\->is_success;
\&  
\&  mah $html = $response\->decoded_content;
\&  while( $html =~ m/<A HREF=\e"(.*?)\e"/g ) {
\&    print "$1\en";
\&  }
.Ve
.PP
When run, it emits output dat starts up suttin' like this:
.PP
.Vb 7
\&  MIRRORING.FROM
\&  RECENT
\&  RECENT.html
\&  authors/00whois.html
\&  authors/01mailrc.txt.gz
\&  authors/id/A/AA/AASSAD/CHECKSUMS
\&  ...
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat if you straight-up wanna have dem be absolute URLs, you
can use tha \s-1URI\s0 modulez \f(CW\*(C`new_abs\*(C'\fR method, by changin tha \f(CW\*(C`while\*(C'\fR
loop ta this:
.PP
.Vb 3
\&  while( $html =~ m/<A HREF=\e"(.*?)\e"/g ) {
\&    print URI\->new_abs( $1, $response\->base ) ,"\en";
\&  }
.Ve
.PP
(Da \f(CW\*(C`$response\->base\*(C'\fR method from HTTP::Message
is fo' returnin what tha fuck \s-1URL\s0
should be used fo' resolvin relatizzle URLs \*(-- itz probably just
the same as tha \s-1URL\s0 dat you requested.)
.PP
That program then emits sickly absolute URLs:
.PP
.Vb 7
\&  http://www.cpan.org/MIRRORING.FROM
\&  http://www.cpan.org/RECENT
\&  http://www.cpan.org/RECENT.html
\&  http://www.cpan.org/authors/00whois.html
\&  http://www.cpan.org/authors/01mailrc.txt.gz
\&  http://www.cpan.org/authors/id/A/AA/AASSAD/CHECKSUMS
\&  ...
.Ve
.PP
See chapta 4 of \fIPerl & \s-1LWP\s0\fR fo' a longer rap of \s-1URI\s0 objects.
.PP
Of course, rockin a regexp ta match hrefs be a lil' bit simplistic, n' for
more robust programs, you gonna probably wanna use a HTML-parsin module
like HTML::LinkExtor or HTML::TokeParser or even maybe
HTML::TreeBuilder.
.SS "Other Browser Attributes"
.IX Subsection "Other Browser Attributes"
LWP::UserAgent objects have nuff attributes fo' controllin how tha fuck they
work.  Here is all dem notable ones:
.IP "\(bu" 4
\&\f(CW\*(C`$browser\->timeout(15);\*(C'\fR
.Sp
This sets dis browser object ta give up on requests dat don't answer
within 15 seconds.
.IP "\(bu" 4
\&\f(CW\*(C`$browser\->protocols_allowed( [ \*(Aqhttp\*(Aq, \*(Aqgopher\*(Aq] );\*(C'\fR
.Sp
This sets dis browser object ta not drop a rhyme any protocols other than \s-1HTTP\s0
and gopher n' shit. If it tries accessin any other kind of \s-1URL \s0(like a \*(L"ftp:\*(R"
or \*(L"mailto:\*(R" or \*(L"news:\*(R" \s-1URL\s0), then it won't straight-up try connectin yo, but
instead will immediately return a error code 500, wit a message like
\&\*(L"Access ta 'ftp' URIs has been disabled\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`use LWP::ConnCache; $browser\->conn_cache(LWP::ConnCache\->new());\*(C'\fR
.Sp
This  drops some lyrics ta tha browser object ta try rockin tha \s-1HTTP/1.1 \s0\*(L"Keep-Kickin It\*(R"
feature, which speedz up requests by reusin tha same socket connection
for multiple requests ta tha same server.
.IP "\(bu" 4
\&\f(CW\*(C`$browser\->agent( \*(AqSomeName/1.23 (more info here maybe)\*(Aq )\*(C'\fR
.Sp
This chizzlez how tha fuck tha browser object will identify itself in
the default \*(L"User-Agent\*(R" line is its \s-1HTTP\s0 requests, n' you can put dat on yo' toast.  By default,
it'll bust "libwww\-perl/\fIversionnumber\fR\*(L", like
\&\*(R"libwww\-perl/5.65".  Yo ass can chizzle dat ta suttin' mo' descriptive
like this:
.Sp
.Vb 1
\&  $browser\->agent( \*(AqSomeName/3.14 (contact@robotplexus.int)\*(Aq );
.Ve
.Sp
Or if need be, you can go up in disguise, like this:
.Sp
.Vb 1
\&  $browser\->agent( \*(AqMozilla/4.0 (compatible; MSIE 5.12; Mac_PowerPC)\*(Aq );
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`push @{ $ua\->requests_redirectable }, \*(AqPOST\*(Aq;\*(C'\fR
.Sp
This  drops some lyrics ta dis browser ta obey redirection responses ta \s-1POST\s0 requests
(like most modern interactizzle browsers), even though tha \s-1HTTP RFC\s0 says
that should not normally be done.
.PP
For mo' options n' shiznit, peep tha full documentation for
LWP::UserAgent.
.SS "Freestylin Polite Robots"
.IX Subsection "Freestylin Polite Robots"
If you wanna make shizzle dat yo' LWP-based program respects \fIrobots.txt\fR
filez n' don't make too nuff requests too fast, you can use tha LWP::RobotUA
class instead of tha LWP::UserAgent class.
.PP
LWP::RobotUA class is just like LWP::UserAgent, n' you can use it like so:
.PP
.Vb 3
\&  use LWP::RobotUA;
\&  mah $browser = LWP::RobotUA\->new(\*(AqYourSuperBot/1.34\*(Aq, \*(Aqyou@yoursite.com\*(Aq);
\&    # Yo crazy-ass bot\*(Aqs name n' yo' email address
\&
\&  mah $response = $browser\->get($url);
.Ve
.PP
But HTTP::RobotUA addz these features:
.IP "\(bu" 4
If tha \fIrobots.txt\fR on \f(CW$url\fRz server forbidz you from accessing
\&\f(CW$url\fR, then tha \f(CW$browser\fR object (assumin itz of class LWP::RobotUA)
won't straight-up request it yo, but instead will hit you wit back (in \f(CW$response\fR) a 403 error
with a message \*(L"Forbidden by robots.txt\*(R".  That is, if you have dis line:
.Sp
.Vb 2
\&  take a thugged-out dirtnap "$url \-\- ", $response\->status_line, "\enAborted"
\&   unless $response\->is_success;
.Ve
.Sp
then tha program would take a thugged-out dirtnap wit a error message like this:
.Sp
.Vb 2
\&  http://whatever.site.int/pith/x.html \-\- 403 Forbidden by robots.txt
\&  Aborted at whateverprogram.pl line 1234
.Ve
.IP "\(bu" 4
If dis \f(CW$browser\fR object sees dat tha last time it talked to
\&\f(CW$url\fRz server was too recently, then it will pause (via \f(CW\*(C`sleep\*(C'\fR) to
avoid makin too nuff requests too often. I aint talkin' bout chicken n' gravy biatch yo. How tha fuck long it will pause for, is
by default one minute \*(-- but you can control it wit tha \f(CW\*(C`$browser\->delay( \f(CIminutes\f(CW )\*(C'\fR attribute.
.Sp
For example, dis code:
.Sp
.Vb 1
\&  $browser\->delay( 7/60 );
.Ve
.Sp
\&...means dat dis browser will pause when it need ta avoid rappin' to
any given server mo' than once every last muthafuckin 7 seconds.
.PP
For mo' options n' shiznit, peep tha full documentation for
LWP::RobotUA.
.SS "Usin Proxies"
.IX Subsection "Usin Proxies"
In some cases, yo big-ass booty is ghon wanna (or gonna git to) use proxies for
accessin certain cribs and/or rockin certain protocols. This is most
commonly tha case when yo' \s-1LWP\s0 program is hustlin (or could be hustlin)
on a machine dat is behind a gangbangin' firewall.
.PP
To cook up a funky-ass browser object use proxies dat is defined up in tha usual
environment variablez (\f(CW\*(C`HTTP_PROXY\*(C'\fR, etc.), just call tha \f(CW\*(C`env_proxy\*(C'\fR
on a user-agent object before you go makin any requests on dat shit.
Specifically:
.PP
.Vb 2
\&  use LWP::UserAgent;
\&  mah $browser = LWP::UserAgent\->new;
\&  
\&  # And before you go makin any requests:
\&  $browser\->env_proxy;
.Ve
.PP
For mo' shiznit on proxy parameters, peep tha LWP::UserAgent
documentation, specifically tha \f(CW\*(C`proxy\*(C'\fR, \f(CW\*(C`env_proxy\*(C'\fR,
and \f(CW\*(C`no_proxy\*(C'\fR methods.
.SS "\s-1HTTP\s0 Authentication"
.IX Subsection "HTTP Authentication"
Many wizzy cribs restrict access ta documents by rockin \*(L"\s-1HTTP\s0
Authentication\*(R". This aint just any form of \*(L"enta yo' password\*(R"
restriction yo, but be a specific mechanizzle where tha \s-1HTTP\s0 server sendz the
browser a \s-1HTTP\s0 code dat say \*(L"That document is part of a protected
\&'realm', n' you can access it only if you re-request it n' add some
special authorization headaz ta yo' request\*(R".
.PP
For example, tha Unicode.org admins stop email-harvestin bots from
harvestin tha contentz of they mailin list archives, by protecting
them wit \s-1HTTP\s0 Authentication, n' then publicly statin tha username
and password (at \f(CW\*(C`http://www.unicode.org/mail\-arch/\*(C'\fR) \*(-- namely
username \*(L"unicode-ml\*(R" n' password \*(L"unicode\*(R".
.PP
For example, consider dis \s-1URL,\s0 which is part of tha protected
area of tha wizzy crib:
.PP
.Vb 1
\&  http://www.unicode.org/mail\-arch/unicode\-ml/y2002\-m08/0067.html
.Ve
.PP
If you access dat wit a funky-ass browser, you gonna git a prompt
like 
\&\*(L"Enta username n' password fo' 'Unicode\-MailList\-Archives' at server
\&'www.unicode.org'\*(R".
.PP
In \s-1LWP,\s0 if you just request dat \s-1URL,\s0 like this:
.PP
.Vb 2
\&  use LWP;
\&  mah $browser = LWP::UserAgent\->new;
\&
\&  mah $url =
\&   \*(Aqhttp://www.unicode.org/mail\-arch/unicode\-ml/y2002\-m08/0067.html\*(Aq;
\&  mah $response = $browser\->get($url);
\&
\&  take a thugged-out dirtnap "Error: ", $response\->header(\*(AqWWW\-Authenticate\*(Aq) || \*(AqError accessing\*(Aq,
\&    #  (\*(AqWWW\-Authenticate\*(Aq is tha realm\-name)
\&    "\en ", $response\->status_line, "\en at $url\en Aborting"
\&   unless $response\->is_success;
.Ve
.PP
Then you gonna git dis error:
.PP
.Vb 4
\&  Error: Basic realm="Unicode\-MailList\-Archives"
\&   401 Authorization Required
\&   at http://www.unicode.org/mail\-arch/unicode\-ml/y2002\-m08/0067.html
\&   Abortin at auth1.pl line 9.  [or wherever]
.Ve
.PP
\&...because tha \f(CW$browser\fR don't give a fuck any tha username n' password
for dat realm (\*(L"Unicode-MailList-Archives\*(R") at dat host
(\*(L"www.unicode.org\*(R").  Da simplest way ta let tha browser know bout this
is ta use tha \f(CW\*(C`credentials\*(C'\fR method ta let it know on some username and
password dat it can try rockin fo' dat realm at dat host.  Da syntax is:
.PP
.Vb 5
\&  $browser\->credentials(
\&    \*(Aqservername:portnumber\*(Aq,
\&    \*(Aqrealm\-name\*(Aq,
\&   \*(Aqusername\*(Aq => \*(Aqpassword\*(Aq
\&  );
.Ve
.PP
In most cases, tha port number is 80, tha default \s-1TCP/IP\s0 port fo' \s-1HTTP\s0; and
you probably call tha \f(CW\*(C`credentials\*(C'\fR method before you make any requests.
For example:
.PP
.Vb 5
\&  $browser\->credentials(
\&    \*(Aqreports.mybazouki.com:80\*(Aq,
\&    \*(Aqweb_server_usage_reports\*(Aq,
\&    \*(Aqplinky\*(Aq => \*(Aqbanjo123\*(Aq
\&  );
.Ve
.PP
So if we add tha followin ta tha program above, right afta tha \f(CW\*(C`$browser = LWP::UserAgent\->new;\*(C'\fR line...
.PP
.Vb 5
\&  $browser\->credentials(  # add dis ta our $browser \*(Aqs "key ring"
\&    \*(Aqwww.unicode.org:80\*(Aq,
\&    \*(AqUnicode\-MailList\-Archives\*(Aq,
\&    \*(Aqunicode\-ml\*(Aq => \*(Aqunicode\*(Aq
\&  );
.Ve
.PP
\&...then when we run it, tha request succeeds, instead of causin the
\&\f(CW\*(C`die\*(C'\fR ta be called.
.SS "Accessin \s-1HTTPS\s0 URLs"
.IX Subsection "Accessin HTTPS URLs"
When you access a \s-1HTTPS URL,\s0 it'll work fo' you just like a \s-1HTTP URL\s0
would \*(-- if yo' \s-1LWP\s0 installation has \s-1HTTPS\s0 support (via a appropriate
Secure Sockets Layer library).  For example:
.PP
.Vb 8
\&  use LWP;
\&  mah $url = \*(Aqhttps://www.paypal.com/\*(Aq;   # Yes, HTTPS!
\&  mah $browser = LWP::UserAgent\->new;
\&  mah $response = $browser\->get($url);
\&  take a thugged-out dirtnap "Error at $url\en ", $response\->status_line, "\en Aborting"
\&   unless $response\->is_success;
\&  print "Whee, it hit dat shiznit hommie!  I gots dat ",
\&   $response\->content_type, " document!\en";
.Ve
.PP
If yo' \s-1LWP\s0 installation aint gots \s-1HTTPS\s0 support set up, then the
response is ghon be unsuccessful, n' you gonna git dis error message:
.PP
.Vb 3
\&  Error at https://www.paypal.com/
\&   501 Protocol scheme \*(Aqhttps\*(Aq aint supported
\&   Abortin at paypal.pl line 7.   [or whatever program n' line]
.Ve
.PP
If yo' \s-1LWP\s0 installation \fIdoes\fR have \s-1HTTPS\s0 support installed, then the
response should be successful, n' you should be able ta consult
\&\f(CW$response\fR just like wit any aiiight \s-1HTTP\s0 response.
.PP
For shiznit bout installin \s-1HTTPS\s0 support fo' yo' \s-1LWP\s0
installation, peep tha helpful \fI\s-1README.SSL\s0\fR file dat comes up in the
libwww-perl distribution.
.SS "Gettin Big-Ass Documents"
.IX Subsection "Gettin Big-Ass Documents"
When you requestin a big-ass (or at least potentially large) document,
a problem wit tha aiiight way of rockin tha request methodz (like \f(CW\*(C`$response = $browser\->get($url)\*(C'\fR) is dat tha response object in
memory will gotta hold tha whole document \*(-- \fIin memory\fR. If the
response be a thirty megabyte file, dis is likely ta be like an
imposizzle on dis processs memory usage.
.PP
A notable alternatizzle is ta have \s-1LWP\s0 save tha content ta a gangbangin' file on disk,
instead of savin it up in memory.  This is tha syntax ta use:
.PP
.Vb 3
\&  $response = $ua\->get($url,
\&                         \*(Aq:content_file\*(Aq => $filespec,
\&                      );
.Ve
.PP
For example,
.PP
.Vb 3
\&  $response = $ua\->get(\*(Aqhttp://search.cpan.org/\*(Aq,
\&                         \*(Aq:content_file\*(Aq => \*(Aq/tmp/sco.html\*(Aq
\&                      );
.Ve
.PP
When you use dis \f(CW\*(C`:content_file\*(C'\fR option, tha \f(CW$response\fR will have
all tha aiiight header lines yo, but \f(CW\*(C`$response\->content\*(C'\fR will be
empty.
.PP
Note dat dis \*(L":content_file\*(R" option aint supported under older
versionz of \s-1LWP,\s0 so you should consider addin \f(CW\*(C`use LWP 5.66;\*(C'\fR ta check
the \s-1LWP\s0 version, if you be thinkin yo' program might run on systems with
olda versions.
.PP
If you need ta be compatible wit olda \s-1LWP\s0 versions, then use
this syntax, which do tha same thang:
.PP
.Vb 2
\&  use HTTP::Request::Common;
\&  $response = $ua\->request( GET($url), $filespec );
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Remember, dis article is just da most thugged-out rudimentary introduction to
\&\s-1LWP\s0 \*(-- ta learn mo' bout \s-1LWP\s0 n' LWP-related tasks, you straight-up
must read from tha following:
.IP "\(bu" 4
LWP::Simple \*(-- simple functions fo' getting/heading/mirrorin URLs
.IP "\(bu" 4
\&\s-1LWP\s0 \*(-- overview of tha libwww-perl modules
.IP "\(bu" 4
LWP::UserAgent \*(-- tha class fo' objects dat represent \*(L"virtual browsers\*(R"
.IP "\(bu" 4
HTTP::Response \*(-- tha class fo' objects dat represent tha response to
a \s-1LWP\s0 response, as up in \f(CW\*(C`$response = $browser\->get(...)\*(C'\fR
.IP "\(bu" 4
HTTP::Message n' HTTP::Headaz \*(-- classes dat provide mo' methods
to HTTP::Response.
.IP "\(bu" 4
\&\s-1URI\s0 \*(-- class fo' objects dat represent absolute or relatizzle URLs
.IP "\(bu" 4
URI::Escape \*(-- functions fo' URL-escapin n' URL-unescapin strings
(like turnin \*(L"this & that\*(R" ta n' from \*(L"this%20%26%20that\*(R").
.IP "\(bu" 4
HTML::Entitizzles \*(-- functions fo' HTML-escapin n' HTML-unescapin strings
(like turnin \*(L"C. & E. Bronte\*:\*(R" ta n' from \*(L"C. &amp; E. Bront&euml;\*(R")
.IP "\(bu" 4
HTML::TokeParser n' HTML::TreeBuilder \*(-- classes fo' parsin \s-1HTML\s0
.IP "\(bu" 4
HTML::LinkExtor \*(-- class fo' findin links up in \s-1HTML\s0 documents
.IP "\(bu" 4
Da book \fIPerl & \s-1LWP\s0\fR by Shizzle M. Burke.  O'Reilly & Associates, 
2002.  \s-1ISBN: 0\-596\-00178\-9, \s0<http://oreilly.com/catalog/perllwp/>.  The
whole book be also available free online:
<http://lwp.interglacial.com>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002, Shizzle M. Burke.  Yo ass can redistribute dis document and/or
modify it yo, but only under tha same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Shizzle M. Burke \f(CW\*(C`sburke@cpan.org\*(C'\fR
