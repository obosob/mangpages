.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Git 3"
.TH Git 3 "2014-05-09" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Git \- Perl intercourse ta tha Git version control system
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Git;
\&
\&  mah $version = Git::command_oneline(\*(Aqversion\*(Aq);
\&
\&  git_cmd_try { Git::command_noisy(\*(Aqupdate\-server\-info\*(Aq) }
\&              \*(Aq%s failed w/ code %d\*(Aq;
\&
\&  mah $repo = Git\->repository (Directory => \*(Aq/srv/git/cogito.git\*(Aq);
\&
\&
\&  mah @revs = $repo\->command(\*(Aqrev\-list\*(Aq, \*(Aq\-\-since=last monday\*(Aq, \*(Aq\-\-all\*(Aq);
\&
\&  mah ($fh, $c) = $repo\->command_output_pipe(\*(Aqrev\-list\*(Aq, \*(Aq\-\-since=last monday\*(Aq, \*(Aq\-\-all\*(Aq);
\&  mah $lastrev = <$fh>; chomp $lastrev;
\&  $repo\->command_close_pipe($fh, $c);
\&
\&  mah $lastrev = $repo\->command_oneline( [ \*(Aqrev\-list\*(Aq, \*(Aq\-\-all\*(Aq ],
\&                                        STDERR => 0 );
\&
\&  mah $sha1 = $repo\->hash_and_insert_object(\*(Aqfile.txt\*(Aq);
\&  mah $tempfile = tempfile();
\&  mah $size = $repo\->cat_blob($sha1, $tempfile);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up Perl scripts easy as fuck  way ta intercourse tha Git version control
system. Da modulez have a easy as fuck  n' well-tested way ta booty-call arbitrary Git
commands; up in tha future, tha intercourse will also provide specialized methods
for bustin easily operations which is not straight-up trivial ta do over
the generic command intercourse.
.PP
While some commandz can be executed outside of any context (e.g. 'version'
or 'init'), most operations require a repository context, which up in practice
means gettin a instizzle of tha Git object rockin tha \fIrepository()\fR constructor.
(In tha future, we will also git a \fInew_repository()\fR constructor.) All commands
called as methodz of tha object is then executed up in tha context of the
repository.
.PP
Part of tha \*(L"repository state\*(R" be also shiznit bout path ta tha attached
workin copy (unless you work wit a funky-ass bare repository). Yo ass can also navigate
inside of tha hustlin copy rockin tha \f(CW\*(C`wc_chdir()\*(C'\fR method. Y'all KNOW dat shit, muthafucka! (Note that
the repository object is self-contained n' aint gonna chizzle hustlin directory
of yo' process.)
.PP
\&\s-1TODO:\s0 In tha future, we might also do
.PP
.Vb 3
\&        mah $remoterepo = $repo\->remote_repository (Name => \*(Aqcogito\*(Aq, Branch => \*(Aqmaster\*(Aq);
\&        $remoterepo ||= Git\->remote_repository (\*(Aqhttp://git.or.cz/cogito.git/\*(Aq);
\&        mah @refs = $remoterepo\->refs();
.Ve
.PP
Currently, tha module merely wraps calls ta external Git tools. In tha future,
it will provide a much fasta way ta interact wit Git by linkin directly
to libgit. This should be straight-up opaque ta tha user, though (performance
increase notwithstanding).
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.IP "repository ( \s-1OPTIONS \s0)" 4
.IX Item "repository ( OPTIONS )"
.PD 0
.IP "repository ( \s-1DIRECTORY \s0)" 4
.IX Item "repository ( DIRECTORY )"
.IP "repository ()" 4
.IX Item "repository ()"
.PD
Construct a freshly smoked up repository object.
\&\f(CW\*(C`OPTIONS\*(C'\fR is passed up in a hash like fashion, rockin key n' value pairs.
Possible options are:
.Sp
\&\fBRepository\fR \- Path ta tha Git repository.
.Sp
\&\fBWorkingCopy\fR \- Path ta tha associated hustlin copy; not strictly required
as nuff commandz will happily crunch on a funky-ass bare repository.
.Sp
\&\fBWorkingSubdir\fR \- Subdirectory up in tha hustlin copy ta work inside.
Just left undefined if you do not wanna limit tha scope of operations.
.Sp
\&\fBDirectory\fR \- Path ta tha Git hustlin directory up in its usual setup.
Da \f(CW\*(C`.git\*(C'\fR directory is searched up in tha directory n' all tha parent
directories; if found, \f(CW\*(C`WorkingCopy\*(C'\fR is set ta tha directory containing
it n' \f(CW\*(C`Repository\*(C'\fR ta tha \f(CW\*(C`.git\*(C'\fR directory itself. If no \f(CW\*(C`.git\*(C'\fR
directory was found, tha \f(CW\*(C`Directory\*(C'\fR be assumed ta be a funky-ass bare repository,
\&\f(CW\*(C`Repository\*(C'\fR is set ta point at it n' \f(CW\*(C`WorkingCopy\*(C'\fR is left undefined.
If tha \f(CW$GIT_DIR\fR environment variable is set, thangs behave as expected
as well.
.Sp
Yo ass should not use both \f(CW\*(C`Directory\*(C'\fR n' either of \f(CW\*(C`Repository\*(C'\fR and
\&\f(CW\*(C`WorkingCopy\*(C'\fR \- tha thangs up in dis biatch of dat is undefined.
.Sp
Alternatively, a gangbangin' finger-lickin' directory path may be passed as a single scalar argument
to tha constructor; it is equivalent ta settin only tha \f(CW\*(C`Directory\*(C'\fR option
field.
.Sp
Callin tha constructor wit no options whatsoever is equivalent to
callin it wit \f(CW\*(C`Directory => \*(Aq.\*(Aq\*(C'\fR. In general, if yo ass is building
a standard porcelain command, simply bustin \f(CW\*(C`Git\->repository()\*(C'\fR should
do tha right thang n' setup tha object ta reflect exactly where tha user
is n' aint a thugged-out damn thang dat yo' ass can do.
.SH "METHODS"
.IX Header "METHODS"
.IP "command ( \s-1COMMAND\s0 [, \s-1ARGUMENTS... \s0] )" 4
.IX Item "command ( COMMAND [, ARGUMENTS... ] )"
.PD 0
.IP "command ( [ \s-1COMMAND, ARGUMENTS... \s0], { Opt => Val ... } )" 4
.IX Item "command ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )"
.PD
Execute tha given Git \f(CW\*(C`COMMAND\*(C'\fR (specify it without tha 'git\-'
prefix), optionally wit tha specified extra \f(CW\*(C`ARGUMENTS\*(C'\fR.
.Sp
Da second mo' elaborate form can be used if you wanna further adjust
the command execution. I aint talkin' bout chicken n' gravy biatch. Currently, only one option is supported:
.Sp
\&\fB\s-1STDERR\s0\fR \- How tha fuck ta deal wit tha commandz error output. By default (\f(CW\*(C`undef\*(C'\fR)
it is served up ta tha callerz \f(CW\*(C`STDERR\*(C'\fR fo' realz. A false value (0 or '') will cause
it ta be thrown away. If you wanna process it, you can git it up in a gangbangin' filehandle
you specify yo, but you must be mad careful; if tha error output is not
very short n' you wanna read it up in tha same process as where you called
\&\f(CW\*(C`command()\*(C'\fR, yo ass is set up fo' a sick deadlock!
.Sp
Da method can be called without any instizzle or on a specified Git repository
(in dat case tha command is ghon be run up in tha repository context).
.Sp
In scalar context, it returns all tha command output up in a single string
(verbatim).
.Sp
In array context, it returns a array containin lines printed ta the
commandz stdout (without trailin newlines).
.Sp
In both cases, tha commandz stdin n' stderr is tha same as tha caller's.
.IP "command_oneline ( \s-1COMMAND\s0 [, \s-1ARGUMENTS... \s0] )" 4
.IX Item "command_oneline ( COMMAND [, ARGUMENTS... ] )"
.PD 0
.IP "command_oneline ( [ \s-1COMMAND, ARGUMENTS... \s0], { Opt => Val ... } )" 4
.IX Item "command_oneline ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )"
.PD
Execute tha given \f(CW\*(C`COMMAND\*(C'\fR up in tha same way as \fIcommand()\fR
does but always return a scalar strang containin tha straight-up original gangsta line
of tha commandz standard output.
.IP "command_output_pipe ( \s-1COMMAND\s0 [, \s-1ARGUMENTS... \s0] )" 4
.IX Item "command_output_pipe ( COMMAND [, ARGUMENTS... ] )"
.PD 0
.IP "command_output_pipe ( [ \s-1COMMAND, ARGUMENTS... \s0], { Opt => Val ... } )" 4
.IX Item "command_output_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )"
.PD
Execute tha given \f(CW\*(C`COMMAND\*(C'\fR up in tha same way as \fIcommand()\fR
does but return a pipe filehandle from which tha command output can be
read.
.Sp
Da function can return \f(CW\*(C`($pipe, $ctx)\*(C'\fR up in array context.
See \f(CW\*(C`command_close_pipe()\*(C'\fR fo' details.
.IP "command_input_pipe ( \s-1COMMAND\s0 [, \s-1ARGUMENTS... \s0] )" 4
.IX Item "command_input_pipe ( COMMAND [, ARGUMENTS... ] )"
.PD 0
.IP "command_input_pipe ( [ \s-1COMMAND, ARGUMENTS... \s0], { Opt => Val ... } )" 4
.IX Item "command_input_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )"
.PD
Execute tha given \f(CW\*(C`COMMAND\*(C'\fR up in tha same way as \fIcommand_output_pipe()\fR
does but return a input pipe filehandle instead; tha command output
is not captured.
.Sp
Da function can return \f(CW\*(C`($pipe, $ctx)\*(C'\fR up in array context.
See \f(CW\*(C`command_close_pipe()\*(C'\fR fo' details.
.IP "command_close_pipe ( \s-1PIPE\s0 [, \s-1CTX \s0] )" 4
.IX Item "command_close_pipe ( PIPE [, CTX ] )"
Close tha \f(CW\*(C`PIPE\*(C'\fR as returned from \f(CW\*(C`command_*_pipe()\*(C'\fR, checking
whether tha command finished successfully. Da optionizzle \f(CW\*(C`CTX\*(C'\fR argument
is required if you wanna peep tha command name up in tha error message,
and it is tha second value returned by \f(CW\*(C`command_*_pipe()\*(C'\fR when
called up in array context. Da call idiom is:
.Sp
.Vb 3
\&        mah ($fh, $ctx) = $r\->command_output_pipe(\*(Aqstatus\*(Aq);
\&        while (<$fh>) { ... }
\&        $r\->command_close_pipe($fh, $ctx);
.Ve
.Sp
Note dat you should not rely on whatever straight-up is up in \f(CW\*(C`CTX\*(C'\fR;
currently it is simply tha command name but up in future tha context might
have mo' fucked up structure.
.IP "command_bidi_pipe ( \s-1COMMAND\s0 [, \s-1ARGUMENTS... \s0] )" 4
.IX Item "command_bidi_pipe ( COMMAND [, ARGUMENTS... ] )"
Execute tha given \f(CW\*(C`COMMAND\*(C'\fR up in tha same way as \fIcommand_output_pipe()\fR
does but return both a input pipe filehandle n' a output pipe filehandle.
.Sp
Da function will return return \f(CW\*(C`($pid, $pipe_in, $pipe_out, $ctx)\*(C'\fR.
See \f(CW\*(C`command_close_bidi_pipe()\*(C'\fR fo' details.
.IP "command_close_bidi_pipe ( \s-1PID, PIPE_IN, PIPE_OUT\s0 [, \s-1CTX\s0] )" 4
.IX Item "command_close_bidi_pipe ( PID, PIPE_IN, PIPE_OUT [, CTX] )"
Close tha \f(CW\*(C`PIPE_IN\*(C'\fR n' \f(CW\*(C`PIPE_OUT\*(C'\fR as returned from \f(CW\*(C`command_bidi_pipe()\*(C'\fR,
checkin whether tha command finished successfully. Da optionizzle \f(CW\*(C`CTX\*(C'\fR
argument is required if you wanna peep tha command name up in tha error message,
and it is tha fourth value returned by \f(CW\*(C`command_bidi_pipe()\*(C'\fR.  Da call idiom
is:
.Sp
.Vb 4
\&        mah ($pid, $in, $out, $ctx) = $r\->command_bidi_pipe(\*(Aqcat\-file \-\-batch\-check\*(Aq);
\&        print $out "000000000\en";
\&        while (<$in>) { ... }
\&        $r\->command_close_bidi_pipe($pid, $in, $out, $ctx);
.Ve
.Sp
Note dat you should not rely on whatever straight-up is up in \f(CW\*(C`CTX\*(C'\fR;
currently it is simply tha command name but up in future tha context might
have mo' fucked up structure.
.Sp
\&\f(CW\*(C`PIPE_IN\*(C'\fR n' \f(CW\*(C`PIPE_OUT\*(C'\fR may be \f(CW\*(C`undef\*(C'\fR if they done been closed prior to
callin dis function. I aint talkin' bout chicken n' gravy biatch.  This may be useful up in a query-response type of
commandz where calla first writes a query n' lata readz response, eg:
.Sp
.Vb 5
\&        mah ($pid, $in, $out, $ctx) = $r\->command_bidi_pipe(\*(Aqcat\-file \-\-batch\-check\*(Aq);
\&        print $out "000000000\en";
\&        close $out;
\&        while (<$in>) { ... }
\&        $r\->command_close_bidi_pipe($pid, $in, undef, $ctx);
.Ve
.Sp
This idiom may prevent potential dead locks caused by data busted ta tha output
pipe not bein flushed n' thus not reachin tha executed command.
.IP "command_noisy ( \s-1COMMAND\s0 [, \s-1ARGUMENTS... \s0] )" 4
.IX Item "command_noisy ( COMMAND [, ARGUMENTS... ] )"
Execute tha given \f(CW\*(C`COMMAND\*(C'\fR up in tha same way as \fIcommand()\fR do but do not
capture tha command output \- tha standard output aint repimped up n' goes
to tha standard output of tha calla application.
.Sp
While tha method is called \fIcommand_noisy()\fR, you might wanna as well use
it fo' da most thugged-out silent Git commandz which you know aint NEVER gonna pollute your
stdout but you wanna avoid tha overhead of tha pipe setup when callin em.
.Sp
Da function returns only afta tha command has finished hustlin.
.IP "version ()" 4
.IX Item "version ()"
Return tha Git version up in use.
.IP "exec_path ()" 4
.IX Item "exec_path ()"
Return path ta tha Git sub-command executablez (the same as
\&\f(CW\*(C`git \-\-exec\-path\*(C'\fR). Useful mostly only internally.
.IP "html_path ()" 4
.IX Item "html_path ()"
Return path ta tha Git html documentation (the same as
\&\f(CW\*(C`git \-\-html\-path\*(C'\fR). Useful mostly only internally.
.IP "get_tz_offset ( \s-1TIME \s0)" 4
.IX Item "get_tz_offset ( TIME )"
Return tha time unit offset from \s-1GMT\s0 up in tha form +/\-HHMM where \s-1HH\s0 is
the number of minutes from \s-1GMT\s0 n' \s-1MM\s0 is tha number of minutes.  This is
the equivalent of what tha fuck strftime(\*(L"%z\*(R", ...) would provide on a \s-1GNU\s0
platform.
.Sp
If \s-1TIME\s0 aint supplied, tha current local time is used.
.IP "prompt ( \s-1PROMPT , ISPASSWORD  \s0)" 4
.IX Item "prompt ( PROMPT , ISPASSWORD )"
Query user \f(CW\*(C`PROMPT\*(C'\fR n' return answer from user.
.Sp
Honours \s-1GIT_ASKPASS\s0 n' \s-1SSH_ASKPASS\s0 environment variablez fo' querying
the user n' shit. If no *_ASKPASS variable is set or a error occoured,
the terminal is tried as a gangbangin' fallback.
If \f(CW\*(C`ISPASSWORD\*(C'\fR is set n' true, tha terminal disablez echo.
.IP "repo_path ()" 4
.IX Item "repo_path ()"
Return path ta tha git repository. Must be called on a repository instance.
.IP "wc_path ()" 4
.IX Item "wc_path ()"
Return path ta tha hustlin copy. Must be called on a repository instance.
.IP "wc_subdir ()" 4
.IX Item "wc_subdir ()"
Return path ta tha subdirectory inside of a hustlin copy. Must be called
on a repository instance.
.IP "wc_chdir ( \s-1SUBDIR \s0)" 4
.IX Item "wc_chdir ( SUBDIR )"
Change tha hustlin copy subdirectory ta work within. I aint talkin' bout chicken n' gravy biatch. Da \f(CW\*(C`SUBDIR\*(C'\fR is
relatizzle ta tha hustlin copy root directory (not tha current subdirectory).
Must be called on a repository instizzle attached ta a hustlin copy
and tha directory must exist.
.IP "config ( \s-1VARIABLE \s0)" 4
.IX Item "config ( VARIABLE )"
Retrieve tha configuration \f(CW\*(C`VARIABLE\*(C'\fR up in tha same manner as \f(CW\*(C`config\*(C'\fR
does. In scalar context requires tha variable ta be set only one time
(exception is thrown otherwise), up in array context returns allows the
variable ta be set multiple times n' returns all tha joints.
.IP "config_bool ( \s-1VARIABLE \s0)" 4
.IX Item "config_bool ( VARIABLE )"
Retrieve tha bool configuration \f(CW\*(C`VARIABLE\*(C'\fR. Da return value
is usable as a funky-ass boolean up in perl (and \f(CW\*(C`undef\*(C'\fR if it aint defined,
of course).
.IP "config_path ( \s-1VARIABLE \s0)" 4
.IX Item "config_path ( VARIABLE )"
Retrieve tha path configuration \f(CW\*(C`VARIABLE\*(C'\fR. Da return value
is a expanded path or \f(CW\*(C`undef\*(C'\fR if it aint defined.
.IP "config_int ( \s-1VARIABLE \s0)" 4
.IX Item "config_int ( VARIABLE )"
Retrieve tha integer configuration \f(CW\*(C`VARIABLE\*(C'\fR. Da return value
is simple decimal number n' shit.  An optionizzle value suffix of 'k', 'm',
or 'g' up in tha config file will cause tha value ta be multiplied
by 1024, 1048576 (1024^2), or 1073741824 (1024^3) prior ta output.
It would return \f(CW\*(C`undef\*(C'\fR if configuration variable aint defined,
.IP "get_colorbool ( \s-1NAME \s0)" 4
.IX Item "get_colorbool ( NAME )"
Findz if color should be used fo' NAMEd operation from tha configuration,
and returns boolean (true fo' \*(L"use color\*(R", false fo' \*(L"do not use color\*(R").
.IP "get_color ( \s-1SLOT, COLOR \s0)" 4
.IX Item "get_color ( SLOT, COLOR )"
Findz color fo' \s-1SLOT\s0 from tha configuration, while defaultin ta \s-1COLOR,\s0
and returns tha \s-1ANSI\s0 color escape sequence:
.Sp
.Vb 3
\&        print $repo\->get_color("color.interactive.prompt", "underline blue white");
\&        print "some text";
\&        print $repo\->get_color("", "normal");
.Ve
.IP "remote_refs ( \s-1REPOSITORY\s0 [, \s-1GROUPS\s0 [, \s-1REFGLOBS \s0] ] )" 4
.IX Item "remote_refs ( REPOSITORY [, GROUPS [, REFGLOBS ] ] )"
This function returns a hashref of refs stored up in a given remote repository.
Da hash is up in tha format \f(CW\*(C`refname =\e\*(C'\fR hash>. For tags, tha \f(CW\*(C`refname\*(C'\fR entry
gotz nuff tha tag object while a \f(CW\*(C`refname^{}\*(C'\fR entry gives tha tagged objects.
.Sp
\&\f(CW\*(C`REPOSITORY\*(C'\fR has tha same ol' dirty meanin as tha appropriate \f(CW\*(C`git\-ls\-remote\*(C'\fR
argument; either a \s-1URL\s0 or a remote name (if called on a repository instance).
\&\f(CW\*(C`GROUPS\*(C'\fR be a optionizzle arrayref dat can contain 'tags' ta return all the
tags and/or 'heads' ta return all tha heads. \f(CW\*(C`REFGLOB\*(C'\fR be a optionizzle array
of strings containin a gangbangin' finger-lickin' dirty-ass shell-like glob ta further limit tha refs returned in
the hash; tha meanin be again n' again n' again tha same as tha appropriate \f(CW\*(C`git\-ls\-remote\*(C'\fR
argument.
.Sp
This function may or may not be called on a repository instance. In tha former
case, remote names as defined up in tha repository is recognized as repository
specifiers.
.IP "ident ( \s-1TYPE\s0 | \s-1IDENTSTR \s0)" 4
.IX Item "ident ( TYPE | IDENTSTR )"
.PD 0
.IP "ident_thug ( \s-1TYPE\s0 | \s-1IDENTSTR\s0 | \s-1IDENTARRAY \s0)" 4
.IX Item "ident_thug ( TYPE | IDENTSTR | IDENTARRAY )"
.PD
This suite of functions retrieves n' parses ident shiznit, as stored
in tha commit n' tag objects or produced by \f(CW\*(C`var GIT_type_IDENT\*(C'\fR (thus
\&\f(CW\*(C`TYPE\*(C'\fR can be either \fIauthor\fR or \fIcommitter\fR; case is insignificant).
.Sp
Da \f(CW\*(C`ident\*(C'\fR method retrieves tha ident shiznit from \f(CW\*(C`git var\*(C'\fR
and either returns it as a scalar strang or as a array wit tha fieldz parsed.
Alternatively, it can take a prepared ident strang (e.g. from tha commit
object) n' just parse dat shit.
.Sp
\&\f(CW\*(C`ident_person\*(C'\fR returns tha thug part of tha ident \- name n' email;
it can take tha same arguments as \f(CW\*(C`ident\*(C'\fR or tha array returned by \f(CW\*(C`ident\*(C'\fR.
.Sp
Da synopsis is like:
.Sp
.Vb 4
\&        mah ($name, $email, $time_tz) = ident(\*(Aqauthor\*(Aq);
\&        "$name <$email>" eq ident_person(\*(Aqauthor\*(Aq);
\&        "$name <$email>" eq ident_person($name);
\&        $time_tz =~ /^\ed+ [+\-]\ed{4}$/;
.Ve
.IP "hash_object ( \s-1TYPE, FILENAME \s0)" 4
.IX Item "hash_object ( TYPE, FILENAME )"
Compute tha \s-1SHA1\s0 object id of tha given \f(CW\*(C`FILENAME\*(C'\fR thankin bout it is
of tha \f(CW\*(C`TYPE\*(C'\fR object type (\f(CW\*(C`blob\*(C'\fR, \f(CW\*(C`commit\*(C'\fR, \f(CW\*(C`tree\*(C'\fR).
.Sp
Da method can be called without any instizzle or on a specified Git repository,
it make zero difference.
.Sp
Da function returns tha \s-1SHA1\s0 hash.
.IP "hash_and_insert_object ( \s-1FILENAME \s0)" 4
.IX Item "hash_and_insert_object ( FILENAME )"
Compute tha \s-1SHA1\s0 object id of tha given \f(CW\*(C`FILENAME\*(C'\fR n' add tha object ta the
object database.
.Sp
Da function returns tha \s-1SHA1\s0 hash.
.IP "cat_blob ( \s-1SHA1, FILEHANDLE \s0)" 4
.IX Item "cat_blob ( SHA1, FILEHANDLE )"
Prints tha contentz of tha blob identified by \f(CW\*(C`SHA1\*(C'\fR ta \f(CW\*(C`FILEHANDLE\*(C'\fR and
returns tha number of bytes printed.
.IP "credential_read( \s-1FILEHANDLE \s0)" 4
.IX Item "credential_read( FILEHANDLE )"
Readz credential key-value pairs from \f(CW\*(C`FILEHANDLE\*(C'\fR.  Readin stops at \s-1EOF\s0 or
when a empty line is encountered. Y'all KNOW dat shit, muthafucka!  Each line must be of tha form \f(CW\*(C`key=value\*(C'\fR
with a non-empty key.  Function returns hash wit all read joints, n' you can put dat on yo' toast.  Any white
space (other than new-line character) is preserved.
.IP "credential_write( \s-1FILEHANDLE, CREDENTIAL_HASHREF \s0)" 4
.IX Item "credential_write( FILEHANDLE, CREDENTIAL_HASHREF )"
Writes credential key-value pairs from hash referenced by
\&\f(CW\*(C`CREDENTIAL_HASHREF\*(C'\fR ta \f(CW\*(C`FILEHANDLE\*(C'\fR.  Keys n' joints cannot contain
new-lines or \s-1NUL\s0 bytes characters, n' key cannot contain equal signs nor be
empty (if they do Error::Simple is thrown).  Any white space is preserved. Y'all KNOW dat shit, muthafucka!  If
value fo' a key is \f(CW\*(C`undef\*(C'\fR, it is ghon be skipped.
.Sp
If \f(CW\*(Aqurl\*(Aq\fR key exists it is ghon be freestyled first.  (All tha other key-value
pairs is freestyled up in sorted order but you should not depend on that).  Once
all lines is written, a empty line is printed.
.IP "credential( \s-1CREDENTIAL_HASHREF\s0 [, \s-1OPERATION \s0] )" 4
.IX Item "credential( CREDENTIAL_HASHREF [, OPERATION ] )"
.PD 0
.IP "credential( \s-1CREDENTIAL_HASHREF, CODE \s0)" 4
.IX Item "credential( CREDENTIAL_HASHREF, CODE )"
.PD
Executes \f(CW\*(C`git credential\*(C'\fR fo' a given set of credentials n' specified
operation. I aint talkin' bout chicken n' gravy biatch.  In both forms \f(CW\*(C`CREDENTIAL_HASHREF\*(C'\fR need ta be a reference to
a hash which stores credentials.  Under certain conditions tha hash can
change.
.Sp
In tha straight-up original gangsta form, \f(CW\*(C`OPERATION\*(C'\fR can be \f(CW\*(Aqfill\*(Aq\fR, \f(CW\*(Aqapprove\*(Aq\fR or \f(CW\*(Aqreject\*(Aq\fR,
and function will execute correspondin \f(CW\*(C`git credential\*(C'\fR sub-command. Y'all KNOW dat shit, muthafucka!  If
itz omitted \f(CW\*(Aqfill\*(Aq\fR be assumed. Y'all KNOW dat shit, muthafucka!  In case of \f(CW\*(Aqfill\*(Aq\fR tha joints stored in
\&\f(CW\*(C`CREDENTIAL_HASHREF\*(C'\fR is ghon be chizzled ta tha ones returned by tha \f(CW\*(C`git
credential fill\*(C'\fR command. Y'all KNOW dat shit, muthafucka!  Da usual usage would look suttin' like:
.Sp
.Vb 12
\&        mah %cred = (
\&                \*(Aqprotocol\*(Aq => \*(Aqhttps\*(Aq,
\&                \*(Aqhost\*(Aq => \*(Aqexample.com\*(Aq,
\&                \*(Aqusername\*(Aq => \*(Aqbob\*(Aq
\&        );
\&        Git::credential \e%cred;
\&        if (try_to_authenticate($cred{\*(Aqusername\*(Aq}, $cred{\*(Aqpassword\*(Aq})) {
\&                Git::credential \e%cred, \*(Aqapprove\*(Aq;
\&                ... do mo' shiznit ...
\&        } else {
\&                Git::credential \e%cred, \*(Aqreject\*(Aq;
\&        }
.Ve
.Sp
In tha second form, \f(CW\*(C`CODE\*(C'\fR need ta be a reference ta a subroutine.  The
function will execute \f(CW\*(C`git credential fill\*(C'\fR ta fill tha provided credential
hash, then call \f(CW\*(C`CODE\*(C'\fR wit \f(CW\*(C`CREDENTIAL_HASHREF\*(C'\fR as tha sole argument.  If
\&\f(CW\*(C`CODE\*(C'\fRz return value is defined, tha function will execute \f(CW\*(C`git credential
approve\*(C'\fR (if return value yieldz true) or \f(CW\*(C`git credential reject\*(C'\fR (if return
value is false).  If tha return value is undef, not a god damn thang at all is executed;
this is useful, fo' example, if tha credential could neither be verified nor
rejected cuz of a unrelated network error. Shiiit, dis aint no joke.  Da return value is tha same ol' dirty as
what \f(CW\*(C`CODE\*(C'\fR returns.  With dis form, tha usage might look as bigs up:
.Sp
.Vb 11
\&        if (Git::credential {
\&                \*(Aqprotocol\*(Aq => \*(Aqhttps\*(Aq,
\&                \*(Aqhost\*(Aq => \*(Aqexample.com\*(Aq,
\&                \*(Aqusername\*(Aq => \*(Aqbob\*(Aq
\&        }, sub {
\&                mah $cred = shift;
\&                return !!try_to_authenticate($cred\->{\*(Aqusername\*(Aq},
\&                                             $cred\->{\*(Aqpassword\*(Aq});
\&        }) {
\&                ... do mo' shiznit ...
\&        }
.Ve
.IP "temp_acquire ( \s-1NAME \s0)" 4
.IX Item "temp_acquire ( NAME )"
Attempts ta retrieve tha temporary file mapped ta tha strang \f(CW\*(C`NAME\*(C'\fR. If an
associated temp file has not been pimped dis session or was closed, it is
created, cached, n' set fo' autoflush n' binmode.
.Sp
Internally locks tha file mapped ta \f(CW\*(C`NAME\*(C'\fR. This lock must be busted out with
\&\f(CW\*(C`temp_release()\*(C'\fR when tha temp file is no longer needed. Y'all KNOW dat shit, muthafucka! Subsequent attempts
to retrieve temporary filez mapped ta tha same \f(CW\*(C`NAME\*(C'\fR while still locked will
cause a error. Shiiit, dis aint no joke. This lockin mechanizzle serves up a weak guarantee n' is not
threadsafe. Well shiiiit, it do provide some error checkin ta help prevent temp file refs
writin over one another.
.Sp
In general, tha File::Handle returned should not be closed by thugs as
it defeats tha purpose of dis cachin mechanism. If you need ta close tha temp
file handle, then you should use File::Temp or another temp file faculty
directly. If a handle is closed n' then axed again, then a warnin will
issue.
.IP "temp_is_locked ( \s-1NAME \s0)" 4
.IX Item "temp_is_locked ( NAME )"
Returns legit if tha internal lock pimped by a previous \f(CW\*(C`temp_acquire()\*(C'\fR
call wit \f(CW\*(C`NAME\*(C'\fR is still up in effect.
.Sp
When temp_acquire is called on a \f(CW\*(C`NAME\*(C'\fR, it internally locks tha temporary
file mapped ta \f(CW\*(C`NAME\*(C'\fR.  That lock aint gonna be busted out until \f(CW\*(C`temp_release()\*(C'\fR
is called wit either tha original gangsta \f(CW\*(C`NAME\*(C'\fR or tha File::Handle dat was
returned from tha original gangsta call ta temp_acquire.
.Sp
Subsequent attempts ta booty-call \f(CW\*(C`temp_acquire()\*(C'\fR wit tha same \f(CW\*(C`NAME\*(C'\fR will fail
unless there has been a intervenin \f(CW\*(C`temp_release()\*(C'\fR call fo' dat \f(CW\*(C`NAME\*(C'\fR
(or its correspondin File::Handle dat was returned by tha original
\&\f(CW\*(C`temp_acquire()\*(C'\fR call).
.Sp
If legit is returned by \f(CW\*(C`temp_is_locked()\*(C'\fR fo' a \f(CW\*(C`NAME\*(C'\fR, a attempt to
\&\f(CW\*(C`temp_acquire()\*(C'\fR tha same \f(CW\*(C`NAME\*(C'\fR will cause a error unless
\&\f(CW\*(C`temp_release\*(C'\fR is first called on dat \f(CW\*(C`NAME\*(C'\fR (or its corresponding
File::Handle dat was returned by tha original gangsta \f(CW\*(C`temp_acquire()\*(C'\fR call).
.IP "temp_release ( \s-1NAME \s0)" 4
.IX Item "temp_release ( NAME )"
.PD 0
.IP "temp_release ( \s-1FILEHANDLE \s0)" 4
.IX Item "temp_release ( FILEHANDLE )"
.PD
Releases a lock acquired all up in \f(CW\*(C`temp_acquire()\*(C'\fR. Can be called either with
the \f(CW\*(C`NAME\*(C'\fR mappin used when acquirin tha temp file or wit tha \f(CW\*(C`FILEHANDLE\*(C'\fR
referencin a locked temp file.
.Sp
Warns if a attempt is made ta release a gangbangin' file dat aint locked.
.Sp
Da temp file is ghon be truncated before bein busted out. Y'all KNOW dat shit, muthafucka! This can help ta reduce
disk I/O where tha system is smart-ass enough ta detect tha truncation while data
is up in tha output buffers. Beware dat afta tha temp file is busted out and
truncated, any operations on dat file may fail miserably until it is
re-acquired. Y'all KNOW dat shit, muthafucka! All contents is lost between each release n' acquire mapped to
the same string.
.IP "temp_reset ( \s-1FILEHANDLE \s0)" 4
.IX Item "temp_reset ( FILEHANDLE )"
Truncates n' resets tha posizzle of tha \f(CW\*(C`FILEHANDLE\*(C'\fR.
.IP "temp_path ( \s-1NAME \s0)" 4
.IX Item "temp_path ( NAME )"
.PD 0
.IP "temp_path ( \s-1FILEHANDLE \s0)" 4
.IX Item "temp_path ( FILEHANDLE )"
.PD
Returns tha filename associated wit tha given tempfile.
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
All functions is supposed ta throw Perl exceptions up in case of errors.
See tha Error module on how tha fuck ta catch them. Most exceptions is mere
Error::Simple instances.
.PP
But fuck dat shiznit yo, tha word on tha street is dat tha \f(CW\*(C`command()\*(C'\fR, \f(CW\*(C`command_oneline()\*(C'\fR n' \f(CW\*(C`command_noisy()\*(C'\fR
functions suite can throw \f(CW\*(C`Git::Error::Command\*(C'\fR exceptions as well: dem are
thrown when tha external command returns a error code n' contain tha error
code as well as access ta tha captured commandz output. Da exception class
provides tha usual \f(CW\*(C`stringify\*(C'\fR n' \f(CW\*(C`value\*(C'\fR (commandz exit code) methodz and
in addizzle also a \f(CW\*(C`cmd_output\*(C'\fR method dat returns either a array or a
strin wit tha captured command output (dependin on tha original gangsta function
call context; \f(CW\*(C`command_noisy()\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR) n' $<cmdline> which
returns tha command n' its arguments (but without proper quoting).
.PP
Note dat tha \f(CW\*(C`command_*_pipe()\*(C'\fR functions cannot throw dis exception since
it has no clue whether tha command failed or not. Yo ass will only smoke up
at tha time you \f(CW\*(C`close\*(C'\fR tha pipe; if you wanna have dat automated,
use \f(CW\*(C`command_close_pipe()\*(C'\fR, which can throw tha exception.
.IP "git_cmd_try { \s-1CODE \s0} \s-1ERRMSG\s0" 4
.IX Item "git_cmd_try { CODE } ERRMSG"
This magical statement will automatically catch any \f(CW\*(C`Git::Error::Command\*(C'\fR
exceptions thrown by \f(CW\*(C`CODE\*(C'\fR n' make yo' program take a thugged-out dirtnap wit \f(CW\*(C`ERRMSG\*(C'\fR
on its lips; tha message gonna git \f(CW%s\fR substituted fo' tha command line
and \f(CW%d\fR fo' tha exit status. This statement is useful mostly fo' producing
more user-friendly error lyrics.
.Sp
In case of no exception caught tha statement returns \f(CW\*(C`CODE\*(C'\fRz return value.
.Sp
Note dat dis is tha only auto-exported function.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2006 by Petr Baudis <pasky@suse.cz>.
.PP
This module is free software; it may be used, copied, modified
and distributed under tha termz of tha \s-1GNU\s0 General Public Licence,
either version 2, or (at yo' option) any lata version.
