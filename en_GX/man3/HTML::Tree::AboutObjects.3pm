.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::Tree::AboutObjects 3"
.TH HTML::Tree::AboutObjects 3 "2013-08-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::Tree::AboutObjects \-\- article: "Userz View of Object\-Oriented Modules"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # This a article, not a module.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da followin article by Shizzle M. Burke first rocked up in \fIDa Perl
Journal\fR #17 n' is copyright 2000 Da Perl Journal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Well shiiiit, it appears
courtesy of Jizzle Orwant n' Da Perl Journal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  This document may be
distributed under tha same terms as Perl itself.
.SH "A Userz View of Object-Oriented Modules"
.IX Header "A Userz View of Object-Oriented Modules"
\&\-\- Shizzle M. Burke
.PP
Da last time dat most Perl programmers run tha fuck into object-oriented
programmin when they need ta bust a module whose intercourse is
object-oriented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This is often a mystifyin experience, since rap of
\&\*(L"methods\*(R" n' \*(L"constructors\*(R" is unintelligible ta programmers who
thought dat functions n' variablez was all there was ta worry about.
.PP
Articlez n' books dat explain object-oriented programmin (\s-1OOP\s0), do so
in termz of how tha fuck ta program dat way.  Thatz understandable, n' if you
learn ta write object-oriented code of yo' own, you'd find it easy as fuck  to
use object-oriented code dat others write.  But dis approach is the
\&\fIlong\fR way round fo' playas whose immediate goal is just ta use
existin object-oriented modulez yo, but whoz ass don't yet wanna know all the
gory detailz of havin ta write such modulez fo' theyselves.
.PP
This article is fo' dem programmers \*(-- programmers whoz ass wanna know
about objects from tha perspectizzle of rockin object-oriented modules.
.SS "Modulez n' Their Functionizzle Interfaces"
.IX Subsection "Modulez n' Their Functionizzle Interfaces"
Modulez is tha main way dat Perl serves up fo' bundlin up code for
lata use by yo ass or others.  As I be shizzle you can't help noticing
from reading
\&\fIDa Perl Journal\fR, \s-1CPAN \s0(the Comprehensive Perl Archive
Network) is tha repository fo' modulez (or crewz of modules) that
others have written, ta do anythang from composin noize ta accessing
Web pages.  A phat deal of dem modulez even come wit every
installation of Perl.
.PP
One module dat you may have used before, n' which is fairly typical in
its intercourse, is Text::Wrap.  It comes wit Perl, so you don't even
need ta install it from \s-1CPAN. \s0 Yo ass use it up in a program of yours, by
havin yo' program code say early on:
.PP
.Vb 1
\&  use Text::Wrap;
.Ve
.PP
and afta that, you can access a gangbangin' function called \f(CW\*(C`wrap\*(C'\fR, which inserts
line-breaks up in text dat you feed it, so dat tha text is ghon be wrapped to
seventy-two (or however many) columns.
.PP
Da way dis \f(CW\*(C`use Text::Wrap\*(C'\fR bidnizz works is dat tha module
Text::Wrap exists as a gangbangin' file \*(L"Text/Wrap.pm\*(R" somewhere up in one of your
library directories. Put ya muthafuckin choppers up if ya feel dis!  That file gotz nuff Perl code...
.Sp
.RS 4
Footnote: And mixed up in wit tha Perl code, there be a thugged-out documentation, which
is what tha fuck you read wit \*(L"perldoc Text::Wrap\*(R".  Da perldoc program simply
ignores tha code n' formats tha documentation text, whereas \*(L"use
Text::Wrap\*(R" loadz n' runs tha code while ignorin tha documentation.
.RE
.PP
\&...which, among other thangs, defines a gangbangin' function called \f(CW\*(C`Text::Wrap::wrap\*(C'\fR,
and then \f(CW\*(C`exports\*(C'\fR dat function, which means dat when you say \f(CW\*(C`wrap\*(C'\fR
afta havin holla'd \*(L"use Text::Wrap\*(R", you gonna be straight-up callin the
\&\f(CW\*(C`Text::Wrap::wrap\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  Some modulez don't export their
functions, so you gotta call dem by they full name, like
\&\f(CW\*(C`Text::Wrap::wrap(...parameters...)\*(C'\fR.
.PP
Regardless of whether tha typical module exports tha functions it
provides, a module is basically just a cold-ass lil container fo' chunkz of code that
do useful thangs.  Da way tha module allows fo' you ta interact with
it, is its \fIinterface\fR.  And when, like wit Text::Wrap, its intercourse
consistz of functions, tha module is holla'd ta git a \fBfunctional
interface\fR.
.Sp
.RS 4
Footnote: tha term \*(L"function\*(R" (and therefore "function\fIal\fR") has
various senses.  I be rockin tha term here up in its broadest sense, to
refer ta routines \*(-- bitz of code dat is called by some name and
which take parametas n' return some value.
.RE
.PP
Usin modulez wit functionizzle intercourses is straightforward \*(-- instead
of definin yo' own \*(L"wrap\*(R" function wit \f(CW\*(C`sub wrap { ... }\*(C'\fR, you
entrust \*(L"use Text::Wrap\*(R" ta do dat fo' you, along wit whatever other
functions its defines n' exports, accordin ta tha module's
documentation. I aint talkin' bout chicken n' gravy biatch.  Without too much bother, you can even write yo' own
modulez ta contain yo' frequently used functions; I suggest havin a peep
the \f(CW\*(C`perlmod\*(C'\fR playa page fo' mo' leadz on bustin all dis bullshit.
.SS "Modulez wit Object-Oriented Interfaces"
.IX Subsection "Modulez wit Object-Oriented Interfaces"
So suppose dat one dizzle you wanna write a program dat will automate
the process of \f(CW\*(C`ftp\*(C'\fRin a funky-ass bunch of filez from one server down ta your
local machine, n' then off ta another server.
.PP
A quick browse all up in search.cpan.org turns up tha module \*(L"Net::FTP\*(R",
which you can downlizzle n' install it rockin aiiight installation
instructions (unless yo' sysadmin has already installed it, as many
have).
.PP
Like Text::Wrap or any other module wit a gangbangin' familiarly functional
interface, you start off rockin Net::FTP up in yo' program by saying:
.PP
.Vb 1
\&  use Net::FTP;
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat thatz where tha similaritizzle ends.  Da first hint of
difference is dat tha documentation fo' Net::FTP refers ta it as a
\&\fBclass\fR.  A class be a kind of module yo, but one dat has an
object-oriented intercourse.
.PP
Whereas modulez like Text::Wrap
provide bitz of useful code as \fIfunctions\fR, ta be called like
\&\f(CW\*(C`function(...parameters...)\*(C'\fR or like
\&\f(CW\*(C`PackageName::function(...parameters...)\*(C'\fR, Net::FTP n' other modules
with object-oriented intercourses provide \fBmethods\fR.  Methodz is sort of
like functions up in dat they gotz a name n' parameters; but methods
look different, n' is different, cuz you gotta call dem wit a
syntax dat has a cold-ass lil class name or a object as a special argument.  I be bout ta
explain tha syntax fo' method calls, n' then lata explain what tha fuck they
all mean.
.PP
Some methodz is meant ta be called as \fBclass methods\fR, wit tha class
name (same as tha module name) as a special argument.  Class methods
look like this:
.PP
.Vb 3
\&  ClassName\->methodname(parameter1, parameter2, ...)
\&  ClassName\->methodname()   # if no parameters
\&  ClassName\->methodname     # same as above
.Ve
.PP
which yo big-ass booty is ghon sometimes peep written:
.PP
.Vb 2
\&  methodname ClassName (parameter1, parameter2, ...)
\&  methodname ClassName      # if no parameters
.Ve
.PP
Basically all class methodz is fo' makin freshly smoked up objects, n' methodz that
make objects is called "\fBconstructors\fR\*(L" (and tha process of makin them
is called \*(R"constructing\*(L" or \*(R"instantiating\*(L").  Constructor methods
typically have tha name \*(R"new\*(L", or suttin' includin \*(R"new\*(L"
(\*(R"new_from_file\*(L", etc.); but they can conceivably be named
anythang \*(-- \s-1DBI\s0z constructor method is named \*(R"connect", fo' example.
.PP
Da object dat a cold-ass lil constructor method returns is
typically captured up in a scalar variable:
.PP
.Vb 1
\&  $object = ClassName\->new(param1, param2...);
.Ve
.PP
Once you have a object (more lata on exactly what tha fuck dat is), you can
use tha other kind of method call syntax, tha syntax fo' \fBobject method\fR
calls.  Callin object methodz is just like class methods, except
that instead of tha ClassName as tha special argument,
you use a expression dat yeildz a \*(L"object\*(R".  Usually dis is
just a scalar variable dat you earlier captured the
output of tha constructor in. I aint talkin' bout chicken n' gravy biatch.  Object method calls be lookin like this:
.PP
.Vb 3
\&  $object\->methodname(parameter1, parameter2, ...);
\&  $object\->methodname()   # if no parameters
\&  $object\->methodname     # same as above
.Ve
.PP
which is occasionally freestyled as:
.PP
.Vb 2
\&  methodname $object (parameter1, parameter2, ...)
\&  methodname $object      # if no parameters
.Ve
.PP
Examplez of method calls are:
.PP
.Vb 10
\&  mah $session1 = Net::FTP\->new("ftp.myhost.com");
\&    # Calls a cold-ass lil class method "new", from class Net::FTP,
\&    #  wit tha single parameta "ftp.myhost.com",
\&    #  n' saves tha return value (which is, as usual,
\&    #  a object), up in $session1.
\&    # Could also be written:
\&    #  freshly smoked up Net::FTP(\*(Aqftp.myhost.com\*(Aq)
\&  $session1\->login("sburke","aoeuaoeu")
\&    || take a thugged-out dirtnap "failed ta login!\en";
\&     # callin tha object method "login"
\&  print "Dir:\en", $session1\->dir(), "\en";
\&  $session1\->quit;
\&    # same as $session1\->quit()
\&  print "Done\en";
\&  exit;
.Ve
.PP
Incidentally, I suggest always rockin tha syntaxes wit parentheses and
\&\*(L"\->\*(R" up in them,
.Sp
.RS 4
Footnote: tha character-pair \*(L"\->\*(R" is supposed ta be lookin like an
arrow, not \*(L"negatizzle pimped outer-than\*(R"!
.RE
.PP
and avoidin tha syntaxes dat start up \*(L"methodname \f(CW$object\fR\*(R" or
\&\*(L"methodname ModuleName\*(R".  When every last muthafuckin thangz goin right, they all mean
the same thang as tha \*(L"\->\*(R" variants yo, but tha syntax wit \*(L"\->\*(R" is more
visually distinct from function calls, as well as bein immune ta some
kindz of rare but puzzlin ambiguitizzles dat can arise when you trying
to call methodz dat have tha same name as subroutines you've defined.
.PP
But, syntactic alternatives aside, all dis rap of constructin objects
and object methodz begs tha question \*(-- what tha fuck \fIis\fR a object, biatch?  There are
several anglez ta dis question dat tha rest of dis article will
answer up in turn: what tha fuck can you do wit objects, biatch?  whatz up in a object?
whatz a object value, biatch?  n' why do some modulez use objects at all?
.SS "What Can Yo ass Do wit Objects?"
.IX Subsection "What Can Yo ass Do wit Objects?"
You've peeped dat you can make objects, n' call object methodz with
them.  But what tha fuck is object methodz for, biatch?  Da answer dependz on tha class:
.PP
A Net::FTP object represents a session between yo' computa n' a \s-1FTP\s0
server n' shit.  So tha methodz you call on a Net::FTP object is fo' bustin
whatever you'd need ta do across a \s-1FTP\s0 connection. I aint talkin' bout chicken n' gravy biatch.  Yo ass make the
session n' log in:
.PP
.Vb 5
\&  mah $session = Net::FTP\->new(\*(Aqftp.aol.com\*(Aq);
\&  take a thugged-out dirtnap "Couldn\*(Aqt connect!" unless defined $session;
\&    # Da class method call ta "new" will return
\&    # tha freshly smoked up object if it goes OK, otherwise it
\&    # will return undef.
\&    
\&  $session\->login(\*(Aqsburke\*(Aq, \*(Aqp@ssw3rD\*(Aq)
\&   || take a thugged-out dirtnap "Did I chizzle mah password again?";
\&    # Da object method "login" will give a true
\&    # return value if straight-up logs in, otherwise
\&    # it\*(Aqll return false.
.Ve
.PP
Yo ass can use tha session object ta chizzle directory on dat session:
.PP
.Vb 3
\&  $session\->cwd("/home/sburke/public_html")
\&     || take a thugged-out dirtnap "Yo, dat was REALLY supposed ta work!";
\&   # if tha cwd fails, it\*(Aqll return false
.Ve
.PP
\&...get filez from tha machine all up in tha other end of tha session...
.PP
.Vb 5
\&  foreach mah $f (\*(Aqlog_report_ua.txt\*(Aq, \*(Aqlog_report_dom.txt\*(Aq,
\&                 \*(Aqlog_report_browsers.txt\*(Aq)
\&  {
\&    $session\->get($f) || warn "Gettin $f failed!"
\&  };
.Ve
.PP
\&...and fuckloadz else, endin finally wit closin tha connection:
.PP
.Vb 1
\&  $session\->quit();
.Ve
.PP
In short, object methodz is fo' bustin thangs related ta (or with)
whatever tha object represents, n' you can put dat on yo' toast.  For \s-1FTP\s0 sessions, itz bout sending
commandz ta tha server all up in tha other end of tha connection, n' that's
about it \*(-- there, methodz is fo' bustin suttin' ta tha ghetto outside
the object, n' tha objects is just suttin' dat specifies what tha fuck bit
of tha ghetto (well, what tha fuck \s-1FTP\s0 session) ta act upon.
.PP
With most other classes, however, tha object itself stores some kind of
information, n' it typically make no sense ta do thangs wit such an
object without thankin bout tha data thatz up in tha object.
.SS "Whatz \fIin\fP a Object?"
.IX Subsection "Whatz up in a Object?"
An object is (with rare exceptions) a thugged-out data structure containin a
bunch of attributes, each of which has a value, as well as a name
that you use when you
read or set tha attributez value.  Some of tha objectz attributes are
private, meanin you gonna never peep dem documented cuz they not
for you ta read or write; but most of tha objectz documented attributes
are at least readable, n' probably writeable, by yo thugged-out ass.  Net::FTP objects
are a lil' bit thin on attributes, so we'll use objects from tha class
Business::US_Amort fo' dis example.  Business::US_Amort be a hella
simple class (available from \s-1CPAN\s0) dat I freestyled fo' makin calculations
to do wit loans (specifically, amortization, rockin US-style
algorithms).
.PP
An object of tha class Business::US_Amort represents a loan with
particular parameters, i.e., attributes.  Da most basic attributez of a
\&\*(L"loan object\*(R" is its interest rate, its principal (how much scrilla it's
for), n' itz term (how long it'll take ta repay).  Yo ass need ta set
these attributes before anythang else can be done wit tha object.  The
way ta git at dem attributes fo' loan objects is just like the
way ta git at attributes fo' any classs objects: all up in accessors.
An \fBaccessor\fR is simply any method dat accesses (whether readin or
writing, \s-1AKA\s0 gettin or putting) some attribute up in tha given object.
Mo'over, accessors is tha \fBonly\fR way dat you can chizzle
an objectz attributes.  (If a modulez documentation wants you to
know bout any other way, it'll tell yo thugged-out ass.)
.PP
Usually, fo' simplicityz sake, a accessor is named afta tha attribute
it readz or writes.  With Business::US_Amort objects, tha accessors you
need ta use first is \f(CW\*(C`principal\*(C'\fR, \f(CW\*(C`interest_rate\*(C'\fR, n' \f(CW\*(C`term\*(C'\fR.
Then, wit at least dem attributes set, you can call tha \f(CW\*(C`run\*(C'\fR method
to figure up nuff muthafuckin thangs bout tha loan. I aint talkin' bout chicken n' gravy biatch.  Then you can call various
accessors, like \f(CW\*(C`total_paid_toward_interest\*(C'\fR, ta read tha thangs up in dis biatch:
.PP
.Vb 6
\&  use Business::US_Amort;
\&  mah $loan = Business::US_Amort\->new;
\&  # Set tha necessary attributes:
\&  $loan\->principal(123654);
\&  $loan\->interest_rate(9.25);
\&  $loan\->term(20); # twenty years
\&
\&  # NOW we know enough ta calculate:
\&  $loan\->run;
\&  
\&  # And peep what tha fuck came of that:
\&  print
\&    "Total paid toward interest: A WHOPPING ",
\&    $loan\->total_paid_interest, "!!\en";
.Ve
.PP
This illustrates a cold-ass lil convention thatz common wit accessors: callin the
accessor wit no arguments (as wit \f(CW$loan\fR\->total_paid_interest) usually
means ta read tha value of dat attribute yo, but providin a value (as
with \f(CW$loan\fR\->term(20)) means you want dat attribute ta be set ta that
value.  This standz ta reason: why would you be providin a value, if
not ta set tha attribute ta dat value?
.PP
Although a loanz term, principal, n' interest rates is all single
numeric joints, a objects joints can any kind of scalar, or a array,
or even a hash.  Mo'over, a attributez value(s) can be objects
themselves.  For example, consider \s-1MIDI\s0 filez (as I freestyled bout in
TPJ#13): a \s-1MIDI\s0 file probably consistz of nuff muthafuckin tracks.  A \s-1MIDI\s0 file is
complex enough ta merit bein a object wit attributes like its overall
tempo, tha file-format variant itz in, n' tha list of instrument
tracks up in tha file.  But tracks theyselves is complex enough ta be
objects too, wit attributes like they track-type, a list of \s-1MIDI\s0
commandz if they a \s-1MIDI\s0 track, or raw data if they not.  So I
ended up freestylin tha \s-1MIDI\s0 modulez so dat tha \*(L"tracks\*(R" attribute of a
MIDI::Opus object be a array of objects from tha class MIDI::Track.
This may seem like a runaround \*(-- you ask whatz up in one object, n' get
\&\fIanother\fR object, or several!  But up in dis case, it exactly reflects
what tha module is fo' \*(-- \s-1MIDI\s0 filez contain \s-1MIDI\s0 tracks, which then
contain data.
.SS "What tha fuck iz a Object Value?"
.IX Subsection "What tha fuck iz a Object Value?"
When you call a cold-ass lil constructor like Net::FTP\->new(\fIhostname\fR), you get
back a object value, a value you can lata use, up in combination wit a
method name, ta booty-call object methods.
.PP
Now, so far we've been pretending, up in tha above examples, dat the
variablez \f(CW$session\fR or \f(CW$loan\fR \fIare\fR tha objects you dealin with.
This scam is innocuous up ta a point yo, but itz straight-up a misconception
that will, at best, limit you up in what tha fuck you know how tha fuck ta do.  Da reality
is not dat tha variablez \f(CW$session\fR or \f(CW$query\fR is objects; itz a lil
more indirect \*(-- they \fIhold\fR joints dat symbolize objects, n' you can put dat on yo' toast.  Da kind of
value dat \f(CW$session\fR or \f(CW$query\fR hold is what tha fuck I be callin a object value.
.PP
To KNOW what tha fuck kind of value dis is, first be thinkin bout tha other
kindz of scalar joints you know about: Da first two scalar joints you
probably eva ran tha fuck into up in Perl is \fBnumbers\fR n' \fBstrings\fR, which you
learned (or just assumed) will probably turn tha fuck into each other on demand;
that is, tha three-characta strang \*(L"2.5\*(R" can become tha quantitizzle two
and a half, n' vice versa.  Then, especially if you started using
\&\f(CW\*(C`perl \-w\*(C'\fR early on, you hustled bout tha \fBundefined value\fR, which can
turn tha fuck into 0 if you treat it as a number, or tha empty-strin if you
treat it as a string.
.Sp
.RS 4
Footnote: Yo ass may \fIalso\fR done been peepin' bout references, up in which
case you locked n loaded ta hear dat object joints is just a kind of
reference, except dat they reflect tha class dat pimped thang they point
to, instead of merely bein a plain oldschool array reference, hash reference,
etc.  \fIIf\fR dis make makes sense ta you, n' you wanna know more
about how tha fuck objects is implemented up in Perl, gotz a peep the
\&\f(CW\*(C`perltoot\*(C'\fR playa page.
.RE
.PP
And now you peepin' bout \fBobject joints\fR.  An object value be a
value dat points ta a thugged-out data structure somewhere up in memory, which is
where all tha attributes fo' dis object is stored. Y'all KNOW dat shit, muthafucka!  That data
structure as a whole belongs ta a cold-ass lil class (probably tha one you named in
the constructor method, like ClassName\->new), so dat tha object value
can be used as part of object method calls.
.PP
If you wanna straight-up \fIsee\fR what tha fuck a object value is, you might try
just sayin \*(L"print \f(CW$object\fR\*(R".  That'll git you suttin' like this:
.PP
.Vb 1
\&  Net::FTP=GLOB(0x20154240)
.Ve
.PP
or
.PP
.Vb 1
\&  Business::US_Amort=HASH(0x15424020)
.Ve
.PP
Thatz not straight-up helpful if you wanted ta straight-up git all up in tha object's
insides yo, but thatz cuz tha object value is only a symbol fo' the
object.  This may all sound straight-up abstruse n' metaphysical, so a
real-world allegory might be straight-up helpful:
.Sp
.RS 4
Yo ass git a advertisement up in tha mail sayin dat you have been
(im)personally selected ta have tha rare privilege of applyin fo' a
credit card. Y'all KNOW dat shit, muthafucka!  For whatever reason, \fIthis\fR offer soundz phat ta you, so you
fill up tha form n' mail it back ta tha credit card company.  They
gleefully approve tha application n' create yo' account, n' bust you
a card wit a number on dat shit.
.Sp
Now, you can do thangs wit tha number on dat card \*(-- clerks at stores
can rang up thangs you wanna buy, n' charge yo' account by keyin in
the number on tha card. Y'all KNOW dat shit, muthafucka!  Yo ass can pay fo' thangs you order online by
punchin up in tha card number as part of yo' online order n' shit.  Yo ass can pay
off part of tha account by bustin  tha credit card playas a shitload of your
money (well, a cold-ass lil check) wit some note (usually tha pre-printed slip)
that has tha card number fo' tha account you wanna pay toward. Y'all KNOW dat shit, muthafucka!  And you
should be able ta booty-call tha credit card companyz computa n' ask it
things bout tha card, like its balance, its credit limit, its \s-1APR,\s0 and
maybe a itemization of recent purchases ad payments.
.Sp
Now, what tha fuck you \fIreally\fR bustin is manipulatin a cold-ass lil credit card
\&\fIaccount\fR, a cold-ass lil straight-up abstract entitizzle wit some data attached ta it
(balance, \s-1APR,\s0 etc).  But fo' ease of access, you gotz a cold-ass lil credit card
\&\fInumber\fR dat be a symbol fo' dat account.  Now, dat symbol is just a
bunch of digits, n' tha number is effectively meaningless n' useless
in n' of itself \*(-- but up in tha appropriate context, itz understood to
\&\fImean\fR tha credit card account you accessing.
.RE
.PP
This is exactly tha relationshizzle between objects n' object joints, and
from dis analogy, nuff muthafuckin facts bout object joints is a lil' bit more
explicable:
.PP
* An object value do not a god damn thang up in n' of itself yo, but itz useful when
you use it up in tha context of a \f(CW$object\fR\->method call, tha same way that
a card number is useful up in tha context of some operation dealin wit a
card account.
.PP
Mo'over, nuff muthafuckin copiez of tha same object value all refer ta tha same
object, tha same way dat makin nuff muthafuckin copiez of yo' card number
won't chizzle tha fact dat they all still refer ta tha same single
account (this is legit whether you \*(L"copying\*(R" tha number by just
writin it down on different slipz of paper, or whether you git all up in the
shiznit of forgin exact replicaz of yo' own plastic credit card).  That's
why this:
.PP
.Vb 2
\&  $x = Net::FTP\->new("ftp.aol.com");
\&  $x\->login("sburke", "aoeuaoeu");
.Ve
.PP
does tha same ol' dirty thang as this:
.PP
.Vb 4
\&  $x = Net::FTP\->new("ftp.aol.com");
\&  $y = $x;
\&  $z = $y;
\&  $z\->login("sburke", "aoeuaoeu");
.Ve
.PP
That is, \f(CW$z\fR n' \f(CW$y\fR n' \f(CW$x\fR is three different \fIslots\fR fo' joints,
but whatz up in dem slots is all object joints pointin ta tha same
object \*(-- you aint gots three different \s-1FTP\s0 connections, just three
variablez wit joints pointin ta tha some single \s-1FTP\s0 connection.
.PP
* Yo ass can't tell much of anythang bout tha object just by lookin at
the object value, any mo' than you can peep yo' credit account balance
by holdin tha plastic card up ta tha light, or by addin up tha digits
in yo' credit card number.
.PP
* Yo ass can't just make up yo' own object joints n' have dem work \*(--
they can come only from constructor methodz of tha appropriate class.
Similarly, you git a cold-ass lil credit card number \fIonly\fR by havin a funky-ass bank approve
your application fo' a cold-ass lil credit card account \*(-- at which point \fIthey\fR
let \fIyou\fR know what tha fuck tha number of yo' freshly smoked up card is.
.PP
Now, there be a even mo' ta tha fact dat you can't just make up yo' own
object value: even though you can print a object value n' git a string
like \*(L"Net::FTP=GLOB(0x20154240)\*(R", dat strang is just a
\&\fIrepresentation\fR of a object value.
.PP
Internally, a object value has a funky-ass basically different type from a
string, or a number, or tha undefined value \*(-- if \f(CW$x\fR holdz a real
string, then dat valuez slot up in memory say "this be a value of type
\&\fIstring\fR, n' its charactas are...\*(L", whereas if itz a object value,
the valuez slot up in memory says, \*(R"this be a value of type \fIreference\fR,
and tha location up in memory dat it points ta is..." (and by lookin at
whatz at dat location, Perl can tell tha class of whatz there).
.PP
Perl programmers typically don't gotta be thinkin bout all these details
of Perlz internals.  Many other languages force you ta be more
consciouz of tha differences between all of these (and also between
typez of numbers, which is stored differently dependin on they size
and whether they have fractionizzle parts).  But Perl do its dopest to
hide tha different typez of scalars from you \*(-- it turns numbers into
strings n' back as needed, n' takes tha strang or number
representation of undef or of object joints as needed. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat you
can't go from a strang representation of a object value, back ta an
object value.  And thatz why dis don't work:
.PP
.Vb 9
\&   $x = Net::FTP\->new(\*(Aqftp.aol.com\*(Aq);
\&   $y = Net::FTP\->new(\*(Aqftp.netcom.com\*(Aq);
\&   $z = Net::FTP\->new(\*(Aqftp.qualcomm.com\*(Aq);
\&   $all = join(\*(Aq \*(Aq, $x,$y,$z);           # !!!
\&  ...later...
\&   ($aol, $netcom, $qualcomm) = split(\*(Aq \*(Aq, $all);  # !!!
\&   $aol\->login("sburke", "aoeuaoeu");
\&   $netcom\->login("sburke", "qjkxqjkx");
\&   $qualcomm\->login("smb", "dhtndhtn");
.Ve
.PP
This fails cuz \f(CW$aol\fR endz up holdin merely tha \fBstrin representation\fR
of tha object value from \f(CW$x\fR, not tha object value itself \*(-- when
\&\f(CW\*(C`join\*(C'\fR tried ta join tha charactaz of tha \*(L"strings\*(R" \f(CW$x\fR, \f(CW$y\fR, n' \f(CW$z\fR,
Perl saw dat they weren't strings at all, so it gave \f(CW\*(C`join\*(C'\fR their
strin representations.
.PP
Unfortunately, dis distinction between object joints n' they string
representations don't straight-up fit tha fuck into tha analogy of credit card
numbers, cuz credit card numbers straight-up \fIare\fR numbers \*(-- even
thought they don't express any meaningful quantity, if you stored them
in a thugged-out database as a quantitizzle (as opposed ta just a \s-1ASCII\s0 string),
that wouldn't stop dem from bein valid as credit card numbers.
.PP
This may seem rather academic yo, but there be a therez two common mistakes
programmers freshly smoked up ta objects often make, which make sense only up in terms of
the distinction between object joints n' they strang representations:
.PP
Da first common error involves forgettin (or never havin known up in the
first place) dat when you git all up in bust a value as a hash key, Perl uses
the strang representation of dat value.  When you wanna use the
numeric value two n' a half as a key, Perl turns it tha fuck into the
three-characta strang \*(L"2.5\*(R".  But if you then wanna use dat string
as a number, Perl will treat it as meanin two n' a half, so you is
usually none tha wiser dat Perl converted tha number ta a strang and
back.  But recall dat Perl can't turn strings back tha fuck into objects \*(-- so
if you tried ta bust a Net::FTP object value as a hash key, Perl actually
used its strang representation, like \*(L"Net::FTP=GLOB(0x20154240)\*(R" yo, but
that strang is unusable as a object value.  (Incidentally, there's
a module Tie::RefHash dat implements hashes dat \fIdo\fR let you use
real object-values as keys.)
.PP
Da second common error wit object joints is in
tryin ta save a object value ta disk (whether printin it ta a
file, or storin it up in a cold-ass lil conventionizzle database file).  All you gonna git is the
string, which is ghon be useless.
.PP
When you wanna save a object n' restore it later, you may find that
the objectz class already serves up a method specifically fo' all dis bullshit.  For
example, MIDI::Opus serves up methodz fo' freestylin a object ta disk as a
standard \s-1MIDI\s0 file.  Da file can lata be read back tha fuck into memory by
a MIDI::Opus constructor method, which will return a freshly smoked up MIDI::Opus
object representin whatever file you tell it ta read tha fuck into memory.
Similar methodz is available with, fo' example, classes that
manipulate graphic images n' can save dem ta files, which can be read
back later.
.PP
But some classes, like Business::US_Amort, provide no such methodz for
storin a object up in a gangbangin' file.  When dis is tha case, you can try
usin any of tha Data::Dumper, Storable, or FreezeThaw modules.  Using
these is ghon be unproblematic fo' objectz of most classes yo, but it may run
into limitations wit others.  For example, a Business::US_Amort
object can be turned tha fuck into a strang wit Data::Dumper, n' dat string
written ta a gangbangin' file.  When itz restored later, its attributes will be
accessible as normal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  But up in tha unlikely case dat tha loan object was
saved up in mid-calculation, tha calculation may not be resumable.  This is
because of tha way dat that \fIparticular\fR class do its calculations,
but similar limitations may occur wit objects from other classses.
.PP
But often, even \fIwanting\fR ta save a object is basically wack \*(-- what tha fuck would
savin a ftp \fIsession\fR even mean, biatch?  Savin tha hostname, username, and
password, biatch?  current directory on both machines, biatch?  tha local \s-1TCP/IP\s0 port
number, biatch?  In tha case of \*(L"saving\*(R" a Net::FTP object, you betta off
just savin whatever details you straight-up need fo' yo' own purposes,
so dat you can cook up a freshly smoked up object lata n' just set dem joints fo' dat shit.
.SS "So Why Do Some Modulez Use Objects?"
.IX Subsection "So Why Do Some Modulez Use Objects?"
All these detailz of rockin objects is definitely enough ta make you
wonder \*(-- is it worth tha bother, biatch?  If you a module lyricist, writing
your module wit a object-oriented intercourse restricts tha crew of
potential playas ta dem playas whoz ass KNOW tha basic conceptz of objects
and object joints, as well as Perlz syntax fo' callin methods.  Why
complicate thangs by havin a object-oriented intercourse?
.PP
A somewhat esoteric answer is dat a module has a object-oriented
interface cuz tha modulez insides is freestyled up in an
object-oriented style.  This article be bout tha basics of
object-oriented \fIinterfaces\fR, n' it'd be goin far afield ta explain
what object-oriented \fIdesign\fR is.  But tha short rap is that
object-oriented design is just one way of comin' at messy problems.
It aint nuthin but a way dat nuff programmers find straight-up helpful (and which others
happen ta find ta be far mo' of a hassle than itz worth,
incidentally), n' it just happens ta show up fo' you, tha module user,
as merely tha steez of intercourse.
.PP
But a simpla answer is dat a gangbangin' functionizzle intercourse is sometimes a
hindrance, cuz it limits tha number of thangs you can do at once \*(--
limitin it, up in fact, ta one.  For nuff problems dat some modulez are
meant ta solve, bustin without a object-oriented intercourse would be like
wishin dat Perl didn't use filehandles.  Da scams is rather simpler
\&\*(-- just imagine dat Perl let you access filez yo, but \fIonly\fR one at a
time, wit code like:
.PP
.Vb 5
\&  open("foo.txt") || take a thugged-out dirtnap "Can\*(Aqt open foo.txt: $!";
\&  while(readline) {
\&    print $_ if /bar/;
\&  }
\&  close;
.Ve
.PP
That hypothetical kind of Perl would be simpler, by bustin without
filehandles.  But you'd be outta luck if you wanted ta read from
one file while readin from another, or read from two n' print ta a
third.
.PP
In tha same way, a gangbangin' functionizzle \s-1FTP\s0 module would be fine fo' just
uploadin filez ta one server at a time yo, but it wouldn't allow you to
easily write programs dat make need ta use \fIseveral\fR simultaneous
sessions (like \*(L"peep server A n' server B, n' if A has a gangbangin' file
called X.dat, then downlizzle it locally n' then upload it ta server B \*(--
except if B has a gangbangin' file called Y.dat, up in which case do it tha other way
around\*(R").
.PP
Some kindz of problems dat modulez solve just lend theyselves ta an
object-oriented intercourse.  For dem kindz of tasks, a gangbangin' functional
interface would be mo' familiar yo, but less bangin naaahhmean, biatch?  Learnin ta use
object-oriented modules' intercourses do require becomin comfortable
with tha concepts from dis article.  But up in tha end it will allow you
to bust a funky-ass broader range of modulez and, wit them, ta write programs
that can do more.
.PP
\&\fB[end body of article]\fR
.SS "[Lyricist Credit]"
.IX Subsection "[Lyricist Credit]"
Shizzle M. Burke has contributed nuff muthafuckin modulez ta \s-1CPAN,\s0 bout half of
them object-oriented.
.PP
[Da next section should be up in a greybox:]
.SS "Da Gory Details"
.IX Subsection "Da Gory Details"
For sake of claritizzle of explanation, I had ta oversimplify a shitload of the
facts bout objects, n' you can put dat on yo' toast.  Herez all dem of tha gorier details:
.PP
* Every example I gave of a cold-ass lil constructor was a cold-ass lil class method. Y'all KNOW dat shit, muthafucka!  But object
methodz can be constructors, too, if tha class was freestyled ta work that
way: \f(CW$new\fR = \f(CW$old\fR\->copy, \f(CW$node_y\fR = \f(CW$node_x\fR\->new_subnode, or tha like.
.PP
* I've given tha impression dat there be a two kindz of methods: object
methodz n' class methods.  In fact, tha same method can be both,
because it aint tha kind of method it is yo, but tha kind of calls it's
written ta accept \*(-- calls dat pass a object, or calls dat pass a
class-name.
.PP
* Da term \*(L"object value\*(R" aint suttin' you gonna find used much anywhere
else.  It aint nuthin but just mah shorthand fo' what tha fuck would properly be called an
\&\*(L"object reference\*(R" or \*(L"reference ta a pimped item\*(R".  In fact, people
usually say \*(L"object\*(R" when they properly mean a reference ta dat object.
.PP
* I mentioned bustin objects wit \fIcon\fRstructors yo, but I didn't
mention beatin tha livin shiznit outta dem wit \fIde\fRstructor \*(-- a thugged-out destructor be a kind of
method dat you call ta tidy up tha object once you done wit it, and
want it ta neatly go away (close connections, delete temporary files,
free up memory, etc).  But cuz of tha way Perl handlez memory,
most modulez won't require tha user ta know bout destructors.
.PP
* I holla'd dat class method syntax has ta have tha class name, as in
\&\f(CW$session\fR = \fBNet::FTP\fR\->new($host).  Actually, you can instead use any
expression dat returns a cold-ass lil class name: \f(CW$ftp_class\fR = 'Net::FTP'; \f(CW$session\fR
= \fB\f(CB$ftp_class\fB\fR\->new($host).  Mo'over, instead of tha method name for
object\- or class-method calls, you can bust a scalar holdin tha method
name: \f(CW$foo\fR\->\fB\f(CB$method\fB\fR($host).  But, up in practice, these syntaxes are
rarely useful.
.PP
And finally, ta learn bout objects from tha perspectizzle of writing
your own classes, peep tha \f(CW\*(C`perltoot\*(C'\fR documentation,
or Damian Conwayz exhaustizzle n' clear book \fIObject Oriented Perl\fR
(Mannin Publications 1999, \s-1ISBN 1\-884777\-79\-1\s0).
.SH "BACK"
.IX Header "BACK"
Return ta tha HTML::Tree docs.
