.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Status 3"
.TH HTTP::Status 3 "2012-02-16" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Status \- HTTP Status code processing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTTP::Status qw(:constants :is status_message);
\&
\& if ($rc != HTTP_OK) {
\&     print status_message($rc), "\en";
\& }
\&
\& if (is_success($rc)) { ... }
\& if (is_error($rc)) { ... }
\& if (is_redirect($rc)) { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIHTTP::Status\fR be a library of routines fo' definin and
classifyin \s-1HTTP\s0 status codes fo' libwww-perl.  Status codes are
used ta encode tha overall outcome of a \s-1HTTP\s0 response message.  Codes
correspond ta dem defined up in \s-1RFC 2616\s0 n' \s-1RFC 2518.\s0
.SH "CONSTANTS"
.IX Header "CONSTANTS"
Da followin constant functions can be used as mnemonic status code
names.  None of these is exported by default.  Use tha \f(CW\*(C`:constants\*(C'\fR
tag ta import dem all.
.PP
.Vb 3
\&   HTTP_CONTINUE                        (100)
\&   HTTP_SWITCHING_PROTOCOLS             (101)
\&   HTTP_PROCESSING                      (102)
\&
\&   HTTP_OK                              (200)
\&   HTTP_CREATED                         (201)
\&   HTTP_ACCEPTED                        (202)
\&   HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
\&   HTTP_NO_CONTENT                      (204)
\&   HTTP_RESET_CONTENT                   (205)
\&   HTTP_PARTIAL_CONTENT                 (206)
\&   HTTP_MULTI_STATUS                    (207)
\&   HTTP_ALREADY_REPORTED                (208)
\&
\&   HTTP_MULTIPLE_CHOICES                (300)
\&   HTTP_MOVED_PERMANENTLY               (301)
\&   HTTP_FOUND                           (302)
\&   HTTP_SEE_OTHER                       (303)
\&   HTTP_NOT_MODIFIED                    (304)
\&   HTTP_USE_PROXY                       (305)
\&   HTTP_TEMPORARY_REDIRECT              (307)
\&
\&   HTTP_BAD_REQUEST                     (400)
\&   HTTP_UNAUTHORIZED                    (401)
\&   HTTP_PAYMENT_REQUIRED                (402)
\&   HTTP_FORBIDDEN                       (403)
\&   HTTP_NOT_FOUND                       (404)
\&   HTTP_METHOD_NOT_ALLOWED              (405)
\&   HTTP_NOT_ACCEPTABLE                  (406)
\&   HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
\&   HTTP_REQUEST_TIMEOUT                 (408)
\&   HTTP_CONFLICT                        (409)
\&   HTTP_GONE                            (410)
\&   HTTP_LENGTH_REQUIRED                 (411)
\&   HTTP_PRECONDITION_FAILED             (412)
\&   HTTP_REQUEST_ENTITY_TOO_LARGE        (413)
\&   HTTP_REQUEST_URI_TOO_LARGE           (414)
\&   HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
\&   HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)
\&   HTTP_EXPECTATION_FAILED              (417)
\&   HTTP_I_AM_A_TEAPOT                   (418)
\&   HTTP_UNPROCESSABLE_ENTITY            (422)
\&   HTTP_LOCKED                          (423)
\&   HTTP_FAILED_DEPENDENCY               (424)
\&   HTTP_NO_CODE                         (425)
\&   HTTP_UPGRADE_REQUIRED                (426)
\&   HTTP_PRECONDITION_REQUIRED           (428)
\&   HTTP_TOO_MANY_REQUESTS               (429)
\&   HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE (431)
\&   HTTP_RETRY_WITH                      (449)
\&
\&   HTTP_INTERNAL_SERVER_ERROR           (500)
\&   HTTP_NOT_IMPLEMENTED                 (501)
\&   HTTP_BAD_GATEWAY                     (502)
\&   HTTP_SERVICE_UNAVAILABLE             (503)
\&   HTTP_GATEWAY_TIMEOUT                 (504)
\&   HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
\&   HTTP_VARIANT_ALSO_NEGOTIATES         (506)
\&   HTTP_INSUFFICIENT_STORAGE            (507)
\&   HTTP_BANDWIDTH_LIMIT_EXCEEDED        (509)
\&   HTTP_NOT_EXTENDED                    (510)
\&   HTTP_NETWORK_AUTHENTICATION_REQUIRED (511)
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Da followin additionizzle functions is provided. Y'all KNOW dat shit, muthafucka!  Most of dem are
exported by default.  Da \f(CW\*(C`:is\*(C'\fR import tag can be used ta import all
the classification functions.
.ie n .IP "status_message( $code )" 4
.el .IP "status_message( \f(CW$code\fR )" 4
.IX Item "status_message( $code )"
Da \fIstatus_message()\fR function will translate status codes ta human
readable strings. Da strang is tha same ol' dirty as found up in tha constant
names above.  If tha \f(CW$code\fR is unknown, then \f(CW\*(C`undef\*(C'\fR is returned.
.ie n .IP "is_info( $code )" 4
.el .IP "is_info( \f(CW$code\fR )" 4
.IX Item "is_info( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR be a \fIInformational\fR status code (1xx).  This
class of status code indicates a provisionizzle response which can't have
any content.
.ie n .IP "is_success( $code )" 4
.el .IP "is_success( \f(CW$code\fR )" 4
.IX Item "is_success( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR be a \fISuccessful\fR status code (2xx).
.ie n .IP "is_redirect( $code )" 4
.el .IP "is_redirect( \f(CW$code\fR )" 4
.IX Item "is_redirect( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR be a \fIRedirection\fR status code (3xx). This class of
status code indicates dat further action need ta be taken by the
user agent up in order ta fulfill tha request.
.ie n .IP "is_error( $code )" 4
.el .IP "is_error( \f(CW$code\fR )" 4
.IX Item "is_error( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR be a \fIError\fR status code (4xx or 5xx).  Da function
returns \s-1TRUE\s0 fo' both client n' server error status codes.
.ie n .IP "is_client_error( $code )" 4
.el .IP "is_client_error( \f(CW$code\fR )" 4
.IX Item "is_client_error( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR be a \fIClient Error\fR status code (4xx). This class
of status code is intended fo' cases up in which tha client seems ta have
erred.
.Sp
This function is \fBnot\fR exported by default.
.ie n .IP "is_server_error( $code )" 4
.el .IP "is_server_error( \f(CW$code\fR )" 4
.IX Item "is_server_error( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR be a \fIServer Error\fR status code (5xx). This class
of status codes is intended fo' cases up in which tha server be aware
that it has erred or is incapable of struttin tha request.
.Sp
This function is \fBnot\fR exported by default.
.SH "BUGS"
.IX Header "BUGS"
For legacy reasons all tha \f(CW\*(C`HTTP_\*(C'\fR constants is exported by default
with tha prefix \f(CW\*(C`RC_\*(C'\fR.  It aint nuthin but recommended ta use explicit imports and
the \f(CW\*(C`:constants\*(C'\fR tag instead of relyin on all dis bullshit.
