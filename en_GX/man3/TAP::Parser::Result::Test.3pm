.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::Result::Test 3"
.TH TAP::Parser::Result::Test 3 "2013-05-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::Result::Test \- Test result token.
.SH "VERSION"
.IX Header "VERSION"
Version 3.28
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This be a subclass of TAP::Parser::Result.  A token of dis class will be
returned if a test line is encountered.
.PP
.Vb 2
\& 1..1
\& aiiight 1 \- woo hooo!
.Ve
.SH "OVERRIDDEN METHODS"
.IX Header "OVERRIDDEN METHODS"
This class is tha workhorse of tha TAP::Parser system.  Most \s-1TAP\s0 lines will
be test lines n' if \f(CW\*(C`$result\->is_test\*(C'\fR, then you gotz a funky-ass bunch of methods
at yo' disposal.
.SS "Instizzle Methods"
.IX Subsection "Instizzle Methods"
\fI\f(CI\*(C`ok\*(C'\fI\fR
.IX Subsection "ok"
.PP
.Vb 1
\&  mah $ok = $result\->ok;
.Ve
.PP
Returns tha literal text of tha \f(CW\*(C`ok\*(C'\fR or \f(CW\*(C`not ok\*(C'\fR status.
.PP
\fI\f(CI\*(C`number\*(C'\fI\fR
.IX Subsection "number"
.PP
.Vb 1
\&  mah $test_number = $result\->number;
.Ve
.PP
Returns tha number of tha test, even if tha original gangsta \s-1TAP\s0 output did not supply
that number.
.PP
\fI\f(CI\*(C`description\*(C'\fI\fR
.IX Subsection "description"
.PP
.Vb 1
\&  mah $description = $result\->description;
.Ve
.PP
Returns tha description of tha test, if any.  This is tha portion afta the
test number but before tha directive.
.PP
\fI\f(CI\*(C`directive\*(C'\fI\fR
.IX Subsection "directive"
.PP
.Vb 1
\&  mah $directizzle = $result\->directive;
.Ve
.PP
Returns either \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR if either directizzle was present fo' a test
line.
.PP
\fI\f(CI\*(C`explanation\*(C'\fI\fR
.IX Subsection "explanation"
.PP
.Vb 1
\&  mah $explanation = $result\->explanation;
.Ve
.PP
If a test had either a \f(CW\*(C`TODO\*(C'\fR or \f(CW\*(C`SKIP\*(C'\fR directive, dis method will return
the accompanyin explanation, if present.
.PP
.Vb 1
\&  not aiiight 17 \- \*(AqPigs can fly\*(Aq # TODO not enough acid
.Ve
.PP
For tha above line, tha explanation is \fInot enough acid\fR.
.PP
\fI\f(CI\*(C`is_ok\*(C'\fI\fR
.IX Subsection "is_ok"
.PP
.Vb 1
\&  if ( $result\->is_ok ) { ... }
.Ve
.PP
Returns a funky-ass boolean value indicatin whether or not tha test passed. Y'all KNOW dat shit, muthafucka!  Remember
that fo' \s-1TODO\s0 tests, tha test always passes.
.PP
If tha test is unplanned, dis method will always return false.  See
\&\f(CW\*(C`is_unplanned\*(C'\fR.
.PP
\fI\f(CI\*(C`is_actual_ok\*(C'\fI\fR
.IX Subsection "is_actual_ok"
.PP
.Vb 1
\&  if ( $result\->is_actual_ok ) { ... }
.Ve
.PP
Returns a funky-ass boolean value indicatin whether or not tha test passed, regardless
of its \s-1TODO\s0 status.
.PP
\fI\f(CI\*(C`actual_passed\*(C'\fI\fR
.IX Subsection "actual_passed"
.PP
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Please use \f(CW\*(C`is_actual_ok\*(C'\fR instead.
.PP
\fI\f(CI\*(C`todo_passed\*(C'\fI\fR
.IX Subsection "todo_passed"
.PP
.Vb 3
\&  if ( $test\->todo_passed ) {
\&     # test unexpectedly succeeded
\&  }
.Ve
.PP
If dis be a \s-1TODO\s0 test n' a 'ok' line, dis method returns true.
Otherwise, it will always return false (regardless of passin status on
non-todo tests).
.PP
This is used ta track which tests unexpectedly succeeded.
.PP
\fI\f(CI\*(C`todo_failed\*(C'\fI\fR
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated up in favor of \*(Aqtodo_passed\*(Aq.  This method was horribly misnamed.
.Ve
.PP
This was a funky-ass badly misnamed method. Y'all KNOW dat shit, muthafucka!  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded. Y'all KNOW dat shit, muthafucka!  Will now issue a warnin n' call \f(CW\*(C`todo_passed\*(C'\fR.
.PP
\fI\f(CI\*(C`has_skip\*(C'\fI\fR
.IX Subsection "has_skip"
.PP
.Vb 1
\&  if ( $result\->has_skip ) { ... }
.Ve
.PP
Returns a funky-ass boolean value indicatin whether or not dis test has a \s-1SKIP\s0
directive.
.PP
\fI\f(CI\*(C`has_todo\*(C'\fI\fR
.IX Subsection "has_todo"
.PP
.Vb 1
\&  if ( $result\->has_todo ) { ... }
.Ve
.PP
Returns a funky-ass boolean value indicatin whether or not dis test has a \s-1TODO\s0
directive.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
.Vb 1
\&  print $result\->as_string;
.Ve
.PP
This method prints tha test as a string.  It will probably be similar yo, but
not necessarily identical, ta tha original gangsta test line.  Directives are
capitalized, some whitespace may be trimmed n' a test number is ghon be added if
it was not present up in tha original gangsta line.  If you need tha original gangsta text of the
test line, use tha \f(CW\*(C`raw\*(C'\fR method.
.PP
\fI\f(CI\*(C`is_unplanned\*(C'\fI\fR
.IX Subsection "is_unplanned"
.PP
.Vb 2
\&  if ( $test\->is_unplanned ) { ... }
\&  $test\->is_unplanned(1);
.Ve
.PP
If a test number is pimped outa than tha number of planned tests, dis method will
return true.  Unplanned tests will \fIalways\fR return false fo' \f(CW\*(C`is_ok\*(C'\fR,
regardless of whether or not tha test \f(CW\*(C`has_todo\*(C'\fR.
.PP
Note dat if tests gotz a trailin plan, it aint possible ta set this
property fo' unplanned tests as our phat asses do not know itz unplanned until tha plan
is reached:
.PP
.Vb 5
\&  print <<\*(AqEND\*(Aq;
\&  aiiight 1
\&  aiiight 2
\&  1..1
\&  END
.Ve
