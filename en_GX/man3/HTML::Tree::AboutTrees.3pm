.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::Tree::AboutTrees 3"
.TH HTML::Tree::AboutTrees 3 "2013-08-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::Tree::AboutTrees \-\- article on tree\-shaped data structures up in Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # This a article, not a module.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da followin article by Shizzle M. Burke first rocked up in \fIDa Perl
Journal\fR #18 n' is copyright 2000 Da Perl Journal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Well shiiiit, it appears
courtesy of Jizzle Orwant n' Da Perl Journal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  This document may be
distributed under tha same terms as Perl itself.
.SH "Trees"
.IX Header "Trees"
\&\-\- Shizzle M. Burke
.Sp
.RS 4
\&\*(L"AaaAAAaauugh!  Watch up fo' dat tree!\*(R"
  \*(-- \fIGeorge of tha Jungle theme\fR
.RE
.PP
Perlz facilitizzle wit references, combined wit its automatic pimpment of
memory allocation, make it straightforward ta write programs dat store data
in structurez of arbitrary form n' complexity.
.PP
But I've noticed dat nuff programmers, especially dem playas whoz ass started out
with mo' restrictizzle languages, seem up in da crib wit complex but uniform
data structures \*(-- N\-dimensionizzle arrays, or mo' struct-like thangs like
hashes\-of\-arrays(\-of\-hashes(\-of\-hashes), etc.) \*(-- but they often uneasy
with buildin mo' freeform, less tabular structures, like
tree-shaped data structures.
.PP
But trees is easy as fuck  ta build n' manage up in Perl, as I be bout ta demonstrate
by showin off how tha fuck tha HTML::Element class manages elements up in a \s-1HTML\s0
document tree, n' by struttin you all up in a gangbangin' from-scratch implementation
of game trees.  But first we need ta nail down what tha fuck we mean by a \*(L"tree\*(R".
.ie n .SS "Socratic Dialogues: ""What tha fuck iz a Tree?"""
.el .SS "Socratic Dialogues: ``What tha fuck iz a Tree?''"
.IX Subsection "Socratic Dialogues: What tha fuck iz a Tree?"
My fuckin first brush wit tree-shaped structures was up in linguistics classes,
where tree diagrams is used ta describe tha syntax underlyin natural
language sentences.  Afta peepin' mah way round \fIthose\fR trees, I
started ta wonder \*(-- is what tha fuck I be used ta callin \*(L"trees\*(R" tha same as what
programmers call \*(L"trees\*(R", biatch?  So I axed fuckin shitloadz of helpful n' patient
programmers how tha fuck they would define a tree.  Many replied wit a
answer up in jargon dat they could not straight-up explain (understandable,
since explainin thangs, especially definin thangs, is harder
than playas think):
.Sp
.RS 4
\&\-\- So what tha fuck \fIis\fR a \*(L"tree\*(R", a tree-shaped data structure?
.Sp
\&\-\- A tree be a special case of a acyclic pimped up graph!
.Sp
\&\-\- Whatz a \*(L"graph\*(R"?
.Sp
\&\-\- Um... lines... and... you draw dat shit... with... arcs muthafucka! nodes muthafucka!  um...
.RE
.PP
Da most helpful was folks whoz ass couldn't explain directly yo, but with
whom I could git tha fuck into a rather Socratic dialog (where \fII\fR axed the
half-dim half-earnest thangs), often wit much doodlin of
illustrations...
.PP
Question: so whatz a tree?
.PP
Answer: A tree be a cold-ass lil collection of nodes dat is linked together up in a,
well, tree-like way dawwwwg!  Like dis \fI[drawin on a napkin]:\fR
.PP
.Vb 5
\&     A
\&    / \e
\&   B   C
\&     / | \e
\&    D  E  F
.Ve
.PP
Q: So what tha fuck do these lettas represent?
.PP
A: Each be a gangbangin' finger-lickin' different node, a funky-ass bunch of data.  Maybe C be a
bunch of data dat stores a number, maybe a hash table, maybe nothing
at all besides tha fact dat it links ta D, E, n' F (which is other
nodes).
.PP
Q: So what're tha lines between tha nodes?
.PP
A: Links.  Also called \*(L"arcs\*(R".  They just symbolize tha fact dat each
node holdz a list of nodes it links to.
.PP
Q: So what tha fuck if I draw nodes n' links, like all dis bullshit...
.PP
.Vb 5
\&     B \-\- E
\&    / \e  / \e
\&   A   C    
\&    \e /
\&     E
.Ve
.PP
Is dat still a tree?
.PP
A: Fuck dat shit, not at all.  Therez a shitload of un-treelike thangs bout dis shit.
First off, E has a link comin off of it goin tha fuck into nowhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Yo ass can't have
a link ta not a god damn thang \*(-- you can only link ta another node.  Second off, I
don't give a fuck what tha fuck dat sideways link between B n' E means...
.PP
Q: Okay, letz work our way up from suttin' simpla n' shit.  Is dis a tree...?
.PP
.Vb 1
\&    A
.Ve
.PP
A: Yes, I suppose.  It aint nuthin but a tree of just one node.
.PP
Q: And how tha fuck about...
.PP
.Vb 1
\&   A
\&   
\&   B
.Ve
.PP
A: Fuck dat shit, you can't just have nodes floatin there, unattached.
.PP
Q: Okay, I be bout ta link A n' B.  Howz this?
.PP
.Vb 3
\&   A
\&   |
\&   B
.Ve
.PP
A: Yup, thatz a tree.  Therez a node A, n' a node B, n' they linked.
.PP
Q: How tha fuck is dat tree any different from dis one...?
.PP
.Vb 3
\&   B
\&   |
\&   A
.Ve
.PP
A: Well, up in both cases A n' B is linked. Y'all KNOW dat shit, muthafucka!  But itz up in a gangbangin' finger-lickin' different
direction.
.PP
Q: Direction, biatch?  What do tha direction mean?
.PP
A: Well, it dependz what tha fuck tha tree represents, n' you can put dat on yo' toast.  If it represents a
categorization, like this:
.PP
.Vb 3
\&          citrus
\&       /    |    \e
\&   orange  lemon  kumquat ...
.Ve
.PP
then you mean ta say dat oranges, lemons, kumquats, etc., is a kind of
citrus.  But if you drew it upside down, you'd be saying, falsely, that
citrus be a kind of kumquat, a kind of lemon, n' a kind of orange.
If tha tree represented cause-and-effect (or at least what tha fuck thangs
could follow others), or represented whatz a part of what, you
wouldn't wanna git dem backwards, either n' shit.  So wit tha nodes you
draw together on paper, one has ta be over tha other, so you can tell which
way tha relationshizzle up in tha tree works.
.PP
Q:  So is these two trees tha same?
.PP
.Vb 4
\&     A          A
\&    / \e        / \e
\&   B   C      B   \e
\&                   C
.Ve
.PP
A: Yes, although by convention we often try ta line up thangs up in the
same generation, like it is up in tha diagram on tha left.
.PP
Q: \*(L"generation\*(R", biatch?  This be a cold-ass lil crew tree?
.PP
A: Fuck dat shit, not unless itz a cold-ass lil crew tree fo' just yeast cells or something
else dat reproduces asexually.
But fo' sake of havin fuckin shitloadz of terms ta use, our laid-back asses just pretend dat links
in tha tree represent tha \*(L"is a cold-ass lil lil pimp of\*(R" relationshizzle, instead of \*(L"is a
kind of\*(R" or \*(L"is a part of\*(R", or \*(L"could result from\*(R", or whatever tha real
relationshizzle is.  So we git ta borrow a shitload of kinshizzle lyrics for
describin trees \*(-- B n' C is \*(L"children\*(R" (or \*(L"daughters\*(R") of A; A is
the \*(L"parent\*(R" (or \*(L"mother\*(R") of B n' C.  Node C be a \*(L"sibling\*(R" (or
\&\*(L"sister\*(R") of node C; n' so on, wit terms like \*(L"descendants\*(R" (a node's
children, childrenz children, etc.), n' \*(L"generation\*(R" (all the
nodes all up in tha same \*(L"level\*(R" up in tha tree, i.e., is either all
grandlil pimpz of tha top node, or all pimped out-grand-children, etc.), and
\&\*(L"lineage\*(R" or \*(L"ancestors\*(R" (parents, n' parentz muthafathas, etc., all the
way ta tha topmost node).
.PP
So then we git ta express rulez up in terms like "\fBA node cannot have more
than one parent\fR", which means dat dis aint a valid tree:
.PP
.Vb 5
\&    A
\&   / \e
\&  B   C
\&   \e /
\&    E
.Ve
.PP
And: "\fBA node can't be its own parent\fR", which excludes dis looped-up
connection:
.PP
.Vb 3
\&    /\e
\&   A  |
\&    \e/
.Ve
.PP
Or, put mo' generally: "\fBA node can't be its own ancestor\fR", which
excludes tha above loop, as well as tha one here:
.PP
.Vb 7
\&      /\e
\&     Z  |
\&    /   |
\&   A    |
\&  / \e   |
\& B   C  |
\&      \e/
.Ve
.PP
That tree is excluded cuz A be a cold-ass lil lil pimp of Z, n' Z be a cold-ass lil lil pimp of C,
and C be a cold-ass lil lil pimp of A, which means A is its own pimped out-grandparent.  So
this whole network can't be a tree, cuz it breaks tha sort of
meta-rule: \fBonce any node up in tha supposed tree breaks tha rulez for
trees, you aint gots a tree no mo'.\fR
.PP
Q: Okay, now, is these two trees tha same?
.PP
.Vb 3
\&     A         A
\&   / | \e     / | \e
\&  B  C  D   D  C  B
.Ve
.PP
A: It dependz whether you basin yo' concept of trees on each node
havin a set (unordered list) of children, or a (ordered) list of
children. I aint talkin' bout chicken n' gravy biatch.  It aint nuthin but a question of whether orderin is blingin fo' what
yo ass is bustin.  With mah diagram of citrus types, orderin aint
important, so these tree diagrams express tha same ol' dirty thang:
.PP
.Vb 3
\&          citrus
\&       /    |    \e
\&   orange  lemon  kumquat
\&
\&           citrus
\&       /     |    \e
\&   kumquat  orange  lemon
.Ve
.PP
because it don't make sense ta say dat oranges is \*(L"before\*(R" or
\&\*(L"after\*(R" kumquats up in tha whole botanical scheme of thangs.  (Unless, of
course, you \fIare\fR rockin orderin ta mean something, like a thugged-out degree of
genetic similarity.)
.PP
But consider a tree thatz a gangbangin' finger-lickin' diagram of what tha fuck steps is comprised up in an
activity, ta some degree of specificity:
.PP
.Vb 8
\&           make tea
\&         /    |     \e
\&   pour     infuse   serve
\& bangin' wata    / \e
\&in cup/pot  /     \e
\&           add     let
\&           chronic     sit
\&          leaves
.Ve
.PP
This means dat makin chronic consistz of puttin bangin' wata up in a cold-ass lil cup or
put, infusin it (which itself consistz of addin chronic leaves n' letting
it sit), then servin it \*(-- \fIin dat order\fR.  If you serve a empty
dry pot (sippin from empty cups, etc.), let it sit, add chronic leaves,
and pour up in bangin' water, then what tha fuck you bustin is performizzle art, not
tea preparation:
.PP
.Vb 9
\&        performance
\&            art
\&        /    |     \e
\&   serve   infuse    pour
\&            / \e       bangin' water
\&          /     \e      up in cup/pot
\&         let     add
\&         sit     tea
\&                leaves
.Ve
.PP
Except fo' mah havin renamed tha root, dis tree is tha same ol' dirty as
the making-tea tree as far as whatz under what tha fuck yo, but it differs
in order, n' what tha fuck tha tree means make tha order blingin.
.PP
Q: Wait \*(-- \*(L"root\*(R", biatch?  Whatz a root?
.PP
A: Besides kinshizzle terms like \*(L"mother\*(R" n' \*(L"daughter\*(R", tha jargon for
tree parts also has terms from real-life tree parts:  tha part that
everythang else grows from is called tha root; n' nodes dat don't
have nodes attached ta dem (i.e., childless nodes) is called
\&\*(L"leaves\*(R".
.PP
Q: But you've been drawin all yo' trees wit tha root all up in tha top and
leaves all up in tha bottom.
.PP
A: Yes yo, but fo' some reason, thatz tha way mah playas seems ta be thinkin of
trees.  They can draw trees as above; or they can draw dem sort of
sideways wit indentin representin what tha fuck nodes is lil pimpz of what:
.PP
.Vb 6
\&  * make tea
\&     * pour bangin' wata up in cup/pot
\&     * infuse
\&        * add chronic leaves
\&        * let sit
\&     * serve
.Ve
.PP
\&...but folks almost never seem ta draw trees wit tha root at the
bottom.  So imagine itz based on spider plant up in a hangin pot.
Unfortunately, spider plants \fIaren't\fR botanically trees, they're
plants; but \*(L"spider plant diagram\*(R" is rather a grillful, so letz just
call dem trees.
.SS "Trees Defined Formally"
.IX Subsection "Trees Defined Formally"
In time, I digested all these assorted facts bout programmers' scams of
trees (which turned up ta be just a mo' general case of linguistic
ideaz of trees) tha fuck into a single rule:
.PP
* A node be a item dat gotz nuff (\*(L"is over\*(R", \*(L"is parent of\*(R", etc.)
zero or mo' other nodes.
.PP
From dis you can build up formal definitions fo' useful terms, like so:
.PP
* A nodez \fBdescendants\fR is defined as all its children, n' all
their children, n' so on. I aint talkin' bout chicken n' gravy biatch.  Or, stated recursively: a node's
descendants is all its children, n' all its childrenz descendants.
(And if it has no children, it has no descendants.)
.PP
* A nodez \fBancestors\fR consist of its parent, n' its parent's
parent, etc, up ta tha root.  Or, recursively: a nodez ancestors
consist of its parent n' its parentz ancestors.  (If it has no parent,
it has no ancestors.)
.PP
* A \fBtree\fR be a root node n' all tha rootz descendants.
.PP
And you can add a proviso or two ta clarify exactly what tha fuck I impute ta the
word \*(L"other\*(R" up in \*(L"other nodes\*(R":
.PP
* A node cannot contain itself, or contain any node dat gotz nuff it,
etc.  Lookin at it tha other way: a node cannot be its own parent or
ancestor.
.PP
* A node can be root (i.e., no other node gotz nuff it) or can be
contained by only one parent; no node can be tha lil pimp of two or more
parents.
.PP
Add ta dis tha scam dat lil pimps is sometimes ordered, n' sometimes
not, n' thatz bout all you need ta know bout definin what tha fuck a tree
is.  From there itz a matta of rockin em.
.SS "Markup Language Trees: HTML-Tree"
.IX Subsection "Markup Language Trees: HTML-Tree"
While not \fIall\fR markup languages is inherently tree-like, the
best-known crew of markup languages, \s-1HTML, SGML,\s0 n' \s-1XML,\s0 is about
as tree-like as you can get.  In these languages, a thugged-out document consists
of elements n' characta data up in a tree structure where
there is one root element, n' elements can contain either other
elements, or characta data.
.Sp
.RS 4
Footnote:
For sake of simplicity, I be glossin over
comments (<!\-\- ... \-\->), processin instructions (<?xml
version='1.0'>), n' declarations (<!ELEMENT ...>, <!DOCTYPE ...>).
And I aint botherin ta distinguish entitizzle references
(&lt;, &#64;) or \s-1CDATA\s0 sections (<![CDATA[ ...]]>) from aiiight text.
.RE
.PP
For example, consider dis \s-1HTML\s0 document:
.PP
.Vb 10
\&  <html lang="en\-US">
\&    <head>
\&      <title>
\&        Blank Document!
\&      </title>
\&    </head>
\&    <body bgcolor="#d010ff">
\&      I\*(Aqve got
\&      <em>
\&        suttin' ta saaaaay
\&      </em>
\&      !
\&    </body>
\&  </html>
.Ve
.PP
I've indented dis ta point up what tha fuck nodes (elements or text items) are
lil pimpz of what, wit each node on a line of its own.
.PP
Da HTML::TreeBuilder module (in tha \s-1CPAN\s0 distribution HTML-Tree)
does tha work of takin \s-1HTML\s0 source and
buildin up in memory tha tree dat tha document source represents.
.Sp
.RS 4
Footnote: it requires tha HTML::Parser module, which tokenizes the
source \*(-- i.e., identifies each tag, bit of text, comment, etc.
.RE
.PP
Da trees structures dat it buildz represent bitz of text with
normal Perl scalar strang joints; but elements is represented with
objects \*(-- dat is, chunkz of data dat belong ta a
class (in dis case, HTML::Element), a cold-ass lil class dat serves up methods
(routines) fo' accessin tha piecez of data up in each element, and
otherwise bustin thangs wit elements, n' you can put dat on yo' toast.  (See mah article up in TPJ#17 fo' a
quick explanation of objects, tha \s-1POD\s0 document \f(CW\*(C`perltoot\*(C'\fR fo' a longer
explanation, or Damian Conwayz pimpin book \fIObject-Oriented Perl\fR
for tha full story.)
.PP
Each HTML::Element object gotz nuff a fuckin shitload of piecez of data:
.PP
* its element name (\*(L"html\*(R", \*(L"h1\*(R", etc., accessed as \f(CW$element\fR\->tag)
.PP
* a list of elements (or text segments) dat it gotz nuff, if any
(accessed as \f(CW$element\fR\->content_list or \f(CW$element\fR\->content, dependin on
whether you want a list, or a arrayref)
.PP
* what tha fuck element, if any, gotz nuff it (accessed as \f(CW$element\fR\->parent)
.PP
* n' any \s-1SGML\s0 attributes dat tha element has,
like fuckin \f(CW\*(C`lang="en\-US"\*(C'\fR, \f(CW\*(C`align="center"\*(C'\fR, etc. (accessed as
\&\f(CW$element\fR\->attr('lang'), \f(CW$element\fR\->attr('center'), etc.)
.PP
So, fo' example, when HTML::TreeBuilder buildz tha tree fo' tha above
\&\s-1HTML\s0 document source, tha object fo' tha \*(L"body\*(R" element has these pieces of
data:
.PP
.Vb 8
\& * element name: "body"
\& * nodes it gotz nuff:
\&    tha strang "I\*(Aqve gots "
\&    tha object fo' tha "em" element
\&    tha strang "!"
\& * its parent:
\&    tha object fo' tha "html" element
\& * bgcolor: "#d010ff"
.Ve
.PP
Now, once you have dis tree of objects, almost anythang you'd want to
do wit it starts wit searchin tha tree fo' some bit of shiznit
in some element.
.PP
Accessin a piece of shiznit in, say, a hash of hashez of hashes,
is straightforward:
.PP
.Vb 1
\&  $password{\*(Aqsean\*(Aq}{\*(Aqsburke1\*(Aq}{\*(Aqhpux\*(Aq}
.Ve
.PP
because you know dat all data points up in dat structure is accessible
with dat syntax yo, but wit just different keys.  Now, tha \*(L"em\*(R" element
in tha above \s-1HTML\s0 tree do happen ta be accessible
as tha rootz lil pimp #1z lil pimp #1:
.PP
.Vb 1
\&  $root\->content\->[1]\->content\->[1]
.Ve
.PP
But wit trees, you typically don't give a fuck tha exact location (via
indexes) of tha data you lookin for. Shiiit, dis aint no joke.  Instead, findin what tha fuck you want
will typically involve searchin all up in tha tree, seein if every last muthafuckin node is
the kind you want.  Searchin tha whole tree is simple enough \*(-- peep
a given node, n' if it aint what tha fuck you want, peep its children, and
so on. I aint talkin' bout chicken n' gravy biatch.  HTML-Tree serves up nuff muthafuckin methodz dat do dis fo' you, such as
\&\f(CW\*(C`find_by_tag_name\*(C'\fR, which returns tha elements (or tha straight-up original gangsta element, if
called up in scalar context) under a given node (typically tha root) whose
tag name is whatever you specify.
.PP
For example, dat \*(L"em\*(R" node can be found as:
.PP
.Vb 1
\&  mah $that_em = $root\->find_by_tag_name(\*(Aqem\*(Aq);
.Ve
.PP
or as:
.PP
.Vb 2
\&  @ems = $root\->find_by_tag_name(\*(Aqem\*(Aq);
\&   # will only have one element fo' dis particular tree
.Ve
.PP
Now, given a \s-1HTML\s0 document of whatever structure n' complexity, if you
wanted ta do suttin' like chizzle every
.Sp
.RS 4
<em>\fIstuff\fR</em>
.RE
.PP
to
.Sp
.RS 4
<em class=\*(L"funky\*(R">
\&\fB<b>[\-</b>\fR
\&\fIstuff\fR
\&\fB<b>\-]</b>\fR
</em>
.RE
.PP
the first step is ta frame dis operation up in termz of what tha fuck you bustin
to tha tree.  Yo ass is changin this:
.PP
.Vb 3
\&      em
\&       |
\&      ...
.Ve
.PP
to this:
.PP
.Vb 5
\&      em
\&    /  |  \e  
\&   b  ...   b
\&   |        |
\&  "[\-"     "\-]"
.Ve
.PP
In other lyrics, you findin all elements whose tag name is \*(L"em\*(R", 
settin its class attribute ta \*(L"funky\*(R", n' addin one lil pimp ta tha start
of its content list \*(-- a freshly smoked up \*(L"b\*(R" element
whose content is tha text strang \*(L"[\-\*(R" \*(-- n' one ta tha end of its
content list \*(-- a freshly smoked up \*(L"b\*(R" element whose content is tha text strang \*(L"\-]\*(R".
.PP
Once you've gots it up in these terms, itz just a matta of hustlin ta the
HTML::Element documentation, n' codin dis up wit calls ta the
appropriate methods, like so:
.PP
.Vb 5
\&  use HTML::Element 1.53;
\&  use HTML::TreeBuilder 2.96;
\&  # Build tha tree by parsin tha document
\&  mah $root = HTML::TreeBuilder\->new;
\&  $root\->parse_file(\*(Aqwhatever.html\*(Aq); # source file
\&  
\&  # Now make freshly smoked up nodes where needed
\&  foreach mah $em ($root\->find_by_tag_name(\*(Aqem\*(Aq)) {
\&    $em\->attr(\*(Aqclass\*(Aq, \*(Aqfunky\*(Aq); # Set dat attribute
\&    
\&    # Make tha two freshly smoked up B nodes
\&    mah $new1 = HTML::Element\->new(\*(Aqb\*(Aq);
\&    mah $new2 = HTML::Element\->new(\*(Aqb\*(Aq);
\&    # Give dem content (they have none at first)
\&    $new1\->push_content(\*(Aq[\-\*(Aq);
\&    $new2\->push_content(\*(Aq\-]\*(Aq);
\&    
\&    # And put \*(Aqem up in place!
\&    $em\->unshift_content($new1);
\&    $em\->push_content($new2);
\&  }
\&  print
\&   "<!\-\- Looky peep what tha fuck I did hommie! \-\->\en",
\&   $root\->as_HTML(), "\en";
.Ve
.PP
Da class HTML::Element serves up just bout every last muthafuckin method I can image you
needing, fo' manipulatin trees made of HTML::Element objects, n' you can put dat on yo' toast.  (And
what it don't directly provide, it will hit you wit tha components ta build
it with.)
.SS "Buildin Yo crazy-ass Own Trees"
.IX Subsection "Buildin Yo crazy-ass Own Trees"
Theoretically, any tree is pretty much like any other tree, so you could
use HTML::Element fo' anythang you'd eva wanna do wit tree-arranged
objects, n' you can put dat on yo' toast.  But fuck dat shiznit yo, tha word on tha street is dat as its name implies, HTML::Element is basically
\&\fIfor\fR \s-1HTML\s0 elements; it has fuckin shitloadz of features dat make sense only for
\&\s-1HTML\s0 elements (like tha scam dat every last muthafuckin element must gotz a tag-name).
And it lacks some features dat might be useful fo' general applications
\&\*(-- like fuckin any sort of checkin ta make shizzle dat you not tryin to
arrange objects up in a non-treelike way.  For a general-purpose tree class
that do have such features, you can use Tree::DAG_Node, also available
from \s-1CPAN. \s0
.PP
But fuck dat shiznit yo, tha word on tha street is dat if yo' task is simple enough, you might find it overkill to
bother rockin Tree::DAG_Node.  And, up in any case, I find dat tha best
way ta learn how tha fuck suttin' works is ta implement it (or suttin' like
it yo, but simpler) yo ass.  So I be bout ta here say shit bout how tha fuck you'd implement a tree
structure, \fIwithout\fR rockin any of tha existin classes fo' tree nodes.
.SS "Implementation: Game Trees fo' Alak"
.IX Subsection "Implementation: Game Trees fo' Alak"
Suppose dat tha task at hand is ta write a program dat can play
against a human opponent at a strategic board game (as opposed ta a
board game where there be a a element of chance).  For most such games, a
\&\*(L"game tree\*(R" be a essential part of tha program (as I'ma argue,
below), n' dis is ghon be our test case fo' implementin a tree
structure from scratch.
.PP
For sake of simplicity, our game aint chess or backgammon yo, but instead
a much simpla game called Alak.  Alak was invented by tha mathematician
A. K.  Dewdney, n' busted lyrics bout up in his 1984 book \fIPlaniverse\fR. Da rules
of Alak is simple:
.Sp
.RS 4
Footnote: Actually, I be describin only my
interpretation of tha rulez Dewdney raps bout up in \fIPlaniverse\fR.  Many
other interpretations is possible.
.RE
.PP
* Alak be a two-player game played on a one-dimensionizzle board with
eleven slots on dat shit.  Each slot can hold at most one piece at a time.
Therez two kindz of pieces, which I represent here as \*(L"x\*(R" n' \*(L"o\*(R" \*(--
xz belong ta one playa (called X), oz ta tha other (called O).
.PP
* Da initial configuration of tha board is:
.PP
.Vb 1
\&   xxxx_\|_\|_oooo
.Ve
.PP
For sake of tha article, tha slots is numbered from 1 (on tha left) to
11 (on tha right), n' X always has tha straight-up original gangsta move.
.PP
* Da playas take turns moving.  At each turn, each playa can move
only one piece, once.  (This unlike checkers, where you move one piece
per move but git ta keep movin it if you jump a yo' opponent's
piece.) A playa cannot pass up on his cold-ass turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  A playa can move any one
of his thugged-out lil' pieces ta tha next unoccupied slot ta its right or left, which
may involve jumpin over occupied slots, n' you can put dat on yo' toast.  A playa cannot move a piece
off tha side of tha board.
.PP
* If a move creates a pattern where tha opponentz pieces are
surrounded, on both sides, by two piecez of tha moverz color (with no
intervenin unoccupied blank slot), then dem surrounded pieces are
removed from tha board.
.PP
* Da goal of tha game is ta remove all of yo' opponentz pieces, at
which point tha game ends.  Removin all-but-one endz tha game as
well, since tha opponent can't surround you wit one piece, n' so will
always lose within all dem moves anyway.
.PP
Consider, then, dis rather short game where X starts:
.PP
.Vb 10
\&  xxxx_\|_\|_oooo
\&    ^         Move 1: X moves from 3 (shown wit caret) ta 5
\&               (Note dat any of X\*(Aqs pieces could move yo, but
\&               dat tha only place they could move ta is 5.)
\&  xx_xx_\|_oooo
\&          ^   Move 2: O moves from 9 ta 7.
\&  xx_xx_oo_oo
\&     ^        Move 3: X moves from 4 ta 6.
\&  xx_\|_xxoo_oo
\&           ^  Move 4: O (stupidly) moves from 10 ta 9.
\&  xx_\|_xxooo_o
\&      ^       Move 5: X moves from 5 ta 10, makin tha board
\&              "xx_\|_\|_xoooxo".  Da three o\*(Aqs dat X just
\&              surrounded is removed. Y'all KNOW dat shit, muthafucka! 
\&  xx_\|_\|_x_\|_\|_xo
\&              O has only one piece, so has lost.
.Ve
.PP
Now, move 4 could have gone like tha other way:
.PP
.Vb 11
\&  xx_\|_xxoo_oo
\&              Move 4: O moves from 8 ta 4, makin tha board 
\&              "xx_oxxo_\|_oo".  Da surrounded x\*(Aqs is removed.
\&  xx_o_\|_o_\|_oo
\&  ^           Move 5: X moves from 1 ta 2.
\&  _xxo_\|_o_\|_oo
\&        ^     Move 6: O moves from 7 ta 6.
\&  _xxo_o_\|_\|_oo
\&   ^          Move 7: X moves from 2 ta 5, removin tha o at 4.
\&  _\|_x_xo_\|_\|_oo
\&              ...and so on.
.Ve
.PP
To teach a cold-ass lil computa program ta play Alak (as playa X, say), it needz to
be able ta peep tha configuration of tha board, figure up what tha fuck moves
it can make, n' weigh tha benefit or costs, immediate or eventual, of
those moves.
.PP
So consider tha board from just before move 3, n' figure all tha possible
moves X could make.  X has pieces up in slots 1, 2, 4, n' 5.  Da leftmost
two xz (at 1 n' 2) is up against tha end of tha board, so they
can move only right.  Da other two xz (at 4 n' 5) can move either
right or left:
.PP
.Vb 7
\&  Startin board: xx_xx_oo_oo
\&   movin 1 ta 3 gives _xxxx_oo_oo
\&   movin 2 ta 3 gives x_xxx_oo_oo
\&   movin 4 ta 3 gives xxx_x_oo_oo
\&   movin 5 ta 3 gives xxxx_\|_oo_oo
\&   movin 4 ta 6 gives xx_\|_xxoo_oo
\&   movin 5 ta 6 gives xx_x_xoo_oo
.Ve
.PP
For tha computa ta decizzle which of these is tha dopest move ta make, it
needz ta quantify tha benefit of these moves as a number \*(-- call that
the \*(L"payoff\*(R".  Da payoff of a move can be figured as just tha number
of x pieces removed by da most thugged-out recent move, minus tha number of o
pieces removed by da most thugged-out recent move.  (It so happens dat tha rules
of tha game mean dat no move can delete both oz n' xz yo, but the
formula still applies.)  Since none of these moves removed any pieces,
all these moves have tha same immediate payoff: 0.
.PP
Now, we could race ahead n' write a Alak-playin program dat could
use tha immediate payoff ta decizzle which is tha dopest move ta make.
And when there be a mo' than one dopest move (as here, where all tha moves
are equally good), it could chizzle randomly between tha good
alternatives.  This game is simple ta implement; but it make fo' a
very dumb program.  Consider what tha fuck Oz response ta each of tha potential
moves (above) could be.  Nothang immediately suggests itself fo' the
first four possibilitizzles (X havin moved suttin' ta posizzle 3) yo, but
either of tha last two (illustrated below) is pretty perilous,
because up in either case O has tha obvious option (which da thug would be
foolish ta pass up) of removin xz from tha board:
.PP
.Vb 6
\&   xx_xx_oo_oo
\&      ^        X moves 4 ta 6.
\&   xx_\|_xxoo_oo
\&          ^    O moves 8 ta 4, givin "xx_oxxo_\|_oo".  Da two
\&               surrounded x\*(Aqs is removed.
\&   xx_o_\|_o_\|_oo
.Ve
.PP
or
.PP
.Vb 6
\&   xx_xx_oo_oo
\&       ^       X moves 5 ta 6.
\&   xx_x_xoo_oo
\&          ^    O moves 8 ta 5, givin "xx_xoxo_\|_oo".  Da one
\&               surrounded x is removed.
\&   xx_xo_o_\|_oo
.Ve
.PP
Both contingencies is like wack fo' X \*(-- but dis aint captured
by tha fact dat they start up wit X thankin his crazy-ass move will be
harmless, havin a payoff of zero.
.PP
So whatz needed is fo' X ta be thinkin \fImore\fR than one step ahead \*(-- to
consider not merely what tha fuck it can do up in dis move, n' what tha fuck tha payoff
is yo, but ta consider what tha fuck O might do up in response, n' the
payoff of dem potential moves, n' so on wit Xz possible responses
to dem cases could be.  All these possibilitizzles form a game tree \*(-- a
tree where each node be a funky-ass board, n' its lil pimps is successors of
that node \*(-- i.e., tha boardz dat could result from every last muthafuckin move
possible, given tha parentz board.
.PP
But how tha fuck ta represent tha tree, n' how tha fuck ta represent tha nodes?
.PP
Well, consider dat a node holdz nuff muthafuckin piecez of data:
.PP
1) tha configuration of tha board, which, bein sick n' simple and
one-dimensional, can be stored as just a string, like \*(L"xx_xx_oo_oo\*(R".
.PP
2) whose turn it is, X or O.  (Or: whoz ass moved last, from which we can
figure whose turn it is).
.PP
3) tha successors (child nodes).
.PP
4) tha immediate payoff of havin moved ta dis board posizzle from its
predecessor (parent node).
.PP
5) n' what tha fuck move gets our asses from our predecessor node ta here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  (Granted,
knowin tha board configuration before n' afta tha move, itz easy as fuck  to
figure up tha move; but itz easier still ta store it as one is
figurin up a nodez successors.)
.PP
6) whatever else we might wanna add later.
.PP
These could be stored equally well up in a array or up in a hash yo, but itz my
experience dat hashes is dopest fo' cases where you have mo' than just
two or three bitz of data, or especially when you might need ta add new
bitz of data.  Mo'over, hash key names is mnemonic \*(--
\&\f(CW$node\fR\->{'last_move_payoff'} is plain as day, whereas it aint so easy as fuck  havin to
remember wit a array dat \f(CW$node\fR\->[3] is where you decided ta keep the
payoff.
.Sp
.RS 4
Footnote:
Of course, there be ways round dat problem: just swear you gonna never
use a real numeric index ta access data up in tha array, n' instead use
constants wit mnemonic names:
.Sp
.Vb 4
\&  use strict;
\&  use constant idx_PAYOFF => 3;
\&  ...
\&  $n\->[idx_PAYOFF]
.Ve
.Sp
Or bust a pseudohash.  But I prefer ta keep it simple, n' bust a hash.
.Sp
These are, incidentally, tha same arguments that
people weigh when tryin ta decizzle whether they object-oriented
modulez should be based on pimped hashes, pimped arrays, or what.
Essentially tha only difference here is dat our asses aint blessin our
nodes or rappin' up in termz of classes n' methods.
.Sp
[end footnote]
.RE
.PP
So, we might as well represent nodes like so:
.PP
.Vb 2
\&  $node = { # hashref
\&     \*(Aqboard\*(Aq          => ...board string, e.g., "xx_x_xoo_oo"
\&     
\&     \*(Aqlast_move_payoff\*(Aq => ...payoff of tha move
\&                            dat gots our asses here.
\&                            
\&     \*(Aqlast_move_from\*(Aq =>  ...the start...
\&     \*(Aqlast_move_to\*(Aq   =>  ...and end point of tha move
\&                              dat gots our asses here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  E.g., 5 n' 6,
\&                              representin a move from 5 ta 6.
\&
\&     \*(Aqwhose_turn\*(Aq     => ...whose move it then becomes.
\&                           just a \*(Aqx\*(Aq or \*(Aqo\*(Aq.
\&                              
\&     \*(Aqsuccessors\*(Aq => ...the successors
\&  };
.Ve
.PP
Note dat we could gotz a gangbangin' field called suttin' like 'last_move_who' to
denote whoz ass last moved yo, but since turns up in Alak always alternate (and
no-one can pass), storin whose move it is now \fIand\fR whoz ass last moved is
redundant \*(-- if X last moved, itz O turn now, n' vice versa.
I chose ta git a 'whose_turn' field instead of a 'last_move_who' yo, but
it don't straight-up matter n' shit.  Either way, we'll end up inferrin one from
the other at nuff muthafuckin points up in tha program.
.PP
When we wanna store tha successorz of a node, should we use a array
or a hash, biatch?  On tha one hand, tha successors ta \f(CW$node\fR aren't essentially
ordered, so there be a no reason ta use a array per se; on tha other hand,
if we used a hash, wit successor nodes as joints, our phat asses don't have
anythang particularly meaningful ta use as keys.  (And we can't use the
successors theyselves as keys, since tha nodes is referred ta by
hash references, n' you can't bust a reference as a hash key.)  Given no
particularly compellin reason ta do otherwise, I chizzle ta just use an
array ta store all a nodez successors, although tha order is never
actually used fo' anything:
.PP
.Vb 5
\&  $node = {
\&    ...
\&    \*(Aqsuccessors\*(Aq => [ ...nodes... ],
\&    ...
\&  };
.Ve
.PP
In any case, now dat we've settled on what tha fuck should be up in a node, 
letz cook up a lil sample tree outta all dem nodes n' peep what tha fuck we can
do wit it:
.PP
.Vb 9
\&  # Board just before move 3 up in above game
\&  mah $n0 = {
\&    \*(Aqboard\*(Aq => \*(Aqxx_xx_oo_oo\*(Aq,
\&    \*(Aqlast_move_payoff\*(Aq => 0,
\&    \*(Aqlast_move_from\*(Aq =>  9,
\&    \*(Aqlast_move_to\*(Aq   =>  7,
\&    \*(Aqwhose_turn\*(Aq => \*(Aqx\*(Aq,
\&    \*(Aqsuccessors\*(Aq => [],
\&  };
\&
\&  # And, fo' now, just two of tha successors:
\&  
\&  # X moves 4 ta 6, givin xx_\|_xxoo_oo
\&  mah $n1 = {
\&    \*(Aqboard\*(Aq => \*(Aqxx_\|_xxoo_oo\*(Aq,
\&    \*(Aqlast_move_payoff\*(Aq => 0,
\&    \*(Aqlast_move_from\*(Aq =>  4,
\&    \*(Aqlast_move_to\*(Aq   =>  6,
\&    \*(Aqwhose_turn\*(Aq => \*(Aqo\*(Aq,
\&    \*(Aqsuccessors\*(Aq => [],
\&  };
\&
\&  # or X moves 5 ta 6, givin xx_x_xoo_oo
\&  mah $n2 = {
\&    \*(Aqboard\*(Aq => \*(Aqxx_x_xoo_oo\*(Aq,
\&    \*(Aqlast_move_payoff\*(Aq => 0,
\&    \*(Aqlast_move_from\*(Aq =>  5,
\&    \*(Aqlast_move_to\*(Aq   =>  6,
\&    \*(Aqwhose_turn\*(Aq => \*(Aqo\*(Aq,
\&    \*(Aqsuccessors\*(Aq => [],
\&  };
\&
\&  # Now connect em...
\&  push @{$n0\->{\*(Aqsuccessors\*(Aq}}, $n1, $n2;
.Ve
.SS "Digression: Links ta Parents"
.IX Subsection "Digression: Links ta Parents"
In comparin what tha fuck we store up in a Alak game tree node ta what
HTML::Element stores up in \s-1HTML\s0 element nodes, you gonna note one big
difference: every last muthafuckin HTML::Element node gotz nuff a link ta its parent,
whereas our phat asses aint gots our Alak nodes keepin a link ta theirs.
.PP
Da reason dis can be a blingin difference is cuz it can affect
how Perl knows when you not rockin piecez of memory no mo'.
Consider tha tree our laid-back asses just built, above:
.PP
.Vb 3
\&      node 0
\&     /      \e
\&  node 1    node 2
.Ve
.PP
Therez two ways Perl knows you rockin a piece of memory:
1) itz memory dat belongs directly ta a variable (i.e., is necessary
to hold dat variablez value, or value\fIs\fR up in tha case of a hash or
array), or 2) itz a piece of memory dat suttin' holdz a reference
to.  In tha above code, Perl knows dat tha hash fo' node 0 (for board
\&\*(L"xx_xx_oo_oo\*(R") is up in use cuz suttin' (namely, tha variable
\&\f(CW$n0\fR) holdz a reference ta dat shit.  Now, even if you followed tha above
code wit this:
.PP
.Vb 1
\&  $n1 = $n2 = \*(Aqwhatever\*(Aq;
.Ve
.PP
to make yo' variablez \f(CW$n1\fR n' \f(CW$n2\fR stop holdin references to
the hashes fo' tha two successorz of node 0, Perl would still know that
those hashes is still up in use, cuz node 0z successors array holds
a reference ta dem hashes.  And Perl knows dat node 0 is still in
use cuz suttin' still holdz a reference ta dat shit.  Now, if you
added:
.PP
.Vb 1
\&  mah $root = $n0;
.Ve
.PP
This would chizzle not a god damn thang \*(-- there be a just be \fItwo\fR thangs holdin a
reference ta tha node 0 hash, which up in turn holdz a reference ta the
node 1 n' node 2 hashes.  And if you then added:
.PP
.Vb 1
\&  $n0 = \*(Aqstuff\*(Aq;
.Ve
.PP
still not a god damn thang would chizzle, cuz suttin' (\f(CW$root\fR) still holdz a
reference ta tha node 0 hash.  But once \fInothing\fR holdz a reference to
the node 0 hash, Perl will know it can destroy dat hash (and reclaim
the memory fo' lata use, say), n' once it do that, not a god damn thang will hold
a reference ta tha node 1 or tha node 2 hashes, n' dem will be
destroyed like a muthafucka.
.PP
But consider if tha node 1 n' node 2 hashes each had a attribute
\&\*(L"parent\*(R" (or \*(L"predecessor\*(R") dat held a reference ta node 0.  If your
program stopped holdin a reference ta tha node 0 hash, Perl could
\&\fInot\fR then say dat \fInothing\fR holdz a reference ta node 0 \*(-- cuz
node 1 n' node 2 still do.  So, tha memory fo' nodes 0, 1, n' 2 would
never git reclaimed (until yo' program ended, at which point Perl
destroys \fIeverything\fR).  If yo' program grew n' discarded fuckin shitloadz of
nodes up in tha game tree yo, but didn't let Perl know it could reclaim their
memory, yo' program could grow ta use immense amountz of memory \*(--
never a sick thang ta have happen. I aint talkin' bout chicken n' gravy biatch.  Therez three ways round this:
.PP
1) When you finished wit a node, delete tha reference each of its
lil pimps gotta it (in dis case, deletin \f(CW$n1\fR\->{'parent'}, say).
When you finished wit a whole tree, just go all up in tha whole tree
erasin links dat lil pimps gotta they lil' thugs.
.PP
2) Reconsider whether you straight-up need ta have each node hold a reference
to its parent.  Just not havin dem links will avoid tha whole
problem.
.PP
3) use tha WeakRef module wit Perl 5.6 or later n' shit.  This allows you to
\&\*(L"weaken\*(R" some references (like tha references dat node 1 n' 2 could
hold ta they parent) so dat they don't count when Perl goes asking
whether anythang holdz a reference ta a given piece of memory.  This
wonderful freshly smoked up module eliminates tha headaches dat can often crop up
with either of tha two previous methods.
.PP
It so happens dat our Alak program is simple enough dat our phat asses don't need
for our nodes ta have links ta they muthafathas, so tha second solution is
fine.  But up in a mo' advanced program, tha straight-up original gangsta or third solutions
might be unavoidable.
.SS "Recursively Printin tha Tree"
.IX Subsection "Recursively Printin tha Tree"
I don't like hustlin blind \*(-- if I have any kind of a cold-ass lil complex data
structure up in memory fo' a program I be hustlin on, tha straight-up original gangsta thang I do
is write suttin' dat can dump dat structure ta tha screen so I can
make shizzle dat what tha fuck I \fIthink\fR is up in memory straight-up \fIis\fR whatz in
memory.  Now, I could just use tha \*(L"x\*(R" pretty-printa command up in Perl's
interactizzle debugger, or I could have tha program use the
\&\f(CW\*(C`Data::Dumper\*(C'\fR module.  But up in dis case, I be thinkin tha output from them
is rather too verbose.  Once our crazy asses have trees wit dozenz of nodes up in them,
we'll straight-up want a thugged-out dump of tha tree ta be as concise as possible,
hopefully just one line per node.  What I'd like is suttin' dat can
print \f(CW$n0\fR n' its successors (see above) as suttin' like:
.PP
.Vb 3
\&  xx_xx_oo_oo  (O moved 9 ta 7, 0 payoff)
\&    xx_\|_xxoo_oo  (X moved 4 ta 6, 0 payoff)
\&    xx_x_xoo_oo  (X moved 5 ta 6, 0 payoff)
.Ve
.PP
A subroutine ta print a line fo' a given node, n' then do dat again n' again n' again for
each successor, would look suttin' like:
.PP
.Vb 9
\&  sub dump_tree {
\&    mah $n = $_[0]; # "n" is fo' node
\&    print
\&      ...suttin' expressin $n\*(Aqn content...
\&    foreach mah $s (@{$n\->{\*(Aqsuccessors\*(Aq}}) {
\&      # "s fo' successor
\&      dump($s);
\&    }
\&  }
.Ve
.PP
And we could just start dat up wit a cold-ass lil call ta \f(CW\*(C`dump_tree($n0)\*(C'\fR.
.PP
Since dis routine...
.Sp
.RS 4
Footnote:
I first freestyled dis routine startin up wit \*(L"sub dump {\*(R".  But when
I tried straight-up callin \f(CW\*(C`dump($n0)\*(C'\fR, Perl would dump core biaaatch!  Imagine
my shock when I discovered dat dis is straight-up ta be expected \*(--
Perl serves up a funky-ass built-in function called \f(CW\*(C`dump\*(C'\fR, tha purpose of which
is to, fo'sho, make Perl dump core.  Callin our routine \*(L"dump_tree\*(R"
instead of \*(L"dump\*(R" neatly avoidz dat problem.
.RE
.PP
\&...does its work (dumpin tha subtree at n' under the
given node) by callin itself, itz \fBrecursive\fR.  But fuck dat shiznit yo, tha word on tha street is dat there be a a
special term fo' dis kind of recursion across a tree: traversal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  To
\&\fBtraverse\fR a tree means ta do suttin' ta a node, n' ta traverse its
children. I aint talkin' bout chicken n' gravy biatch.  Therez two prototypical ways ta do this, dependin on what
happens when:
.PP
.Vb 3
\&  traversin X up in pre\-order:
\&    * do suttin' ta X
\&    * then traverse X\*(Aqs children
\&
\&  traversin X up in post\-order:
\&    * traverse X\*(Aqs children
\&    * then do suttin' ta X
.Ve
.PP
Dumpin tha tree ta tha screen tha way we want it happens ta be a matter
of pre-order traversal, since tha thang our phat asses do (print a thugged-out description of
the node) happens before we recurse tha fuck into tha successors.
.PP
When we try freestylin tha \f(CW\*(C`print\*(C'\fR statement fo' our above \f(CW\*(C`dump_tree\*(C'\fR,
we can git suttin' like:
.PP
.Vb 2
\&  sub dump_tree {
\&    mah $n = $_[0];
\&
\&    # "xx_xx_oo_oo  (O moved 9 ta 7, 0 payoff)"
\&    print
\&      $n\->{\*(Aqboard\*(Aq}, "  (",
\&      ($n\->{\*(Aqwhose_turn\*(Aq} eq \*(Aqo\*(Aq , biatch? \*(AqX\*(Aq : \*(AqO\*(Aq),
\&      # Infer whoz ass last moved from whose turn it is now, nahmeean?
\&      " moved ", $n\->{\*(Aqlast_move_from\*(Aq},
\&      " ta ",    $n\->{\*(Aqlast_move_to\*(Aq},
\&      ", ",      $n\->{\*(Aqlast_move_payoff\*(Aq},
\&      " payoff)\en",
\&    ;
\&
\&    foreach mah $s (@{$n\->{\*(Aqsuccessors\*(Aq}}) {
\&      dump_tree($s);
\&    }
\&  }
.Ve
.PP
If we run dis on \f(CW$n0\fR from above, we git this:
.PP
.Vb 3
\&  xx_xx_oo_oo  (O moved 9 ta 7, 0 payoff)
\&  xx_\|_xxoo_oo  (X moved 4 ta 6, 0 payoff)
\&  xx_x_xoo_oo  (X moved 5 ta 6, 0 payoff)
.Ve
.PP
Each line on its own is fine yo, but we forget ta allow fo' indenting, and
without dat we can't tell whatz a cold-ass lil lil pimp of what.  (Imagine if the
first successor had successorz of its own \*(-- you wouldn't be able to
tell if it was a cold-ass lil child, or a sibling.)  To git indenting, we'll need
to have tha instancez of tha \f(CW\*(C`dump_tree\*(C'\fR routine know how tha fuck far down in
the tree they bein called, by passin a thugged-out depth parameta between
them:
.PP
.Vb 11
\&  sub dump_tree {
\&    mah $n = $_[0];
\&    mah $depth = $_[1];
\&    $depth = 0 unless defined $depth;
\&    print
\&      "  " x $depth,
\&      ...stuff...
\&    foreach mah $s (@{$n\->{\*(Aqsuccessors\*(Aq}}) {
\&      dump_tree($s, $depth + 1);
\&    }
\&  }
.Ve
.PP
When we call \f(CW\*(C`dump_tree($n0)\*(C'\fR, \f(CW$depth\fR (from \f(CW$_[1]\fR) is undefined, so
gets set ta 0, which translates tha fuck into a indentin of no spaces.  But when 
\&\f(CW\*(C`dump_tree\*(C'\fR invokes itself on \f(CW$n0\fRz children, dem instances see
\&\f(CW$depth\fR + 1 as they \f(CW$_[1]\fR, givin appropriate indenting.
.Sp
.RS 4
Footnote:
Passin joints round between different invocationz of a recursive
routine, as shown, be a thugged-out decent way ta share tha data.  Another way
to share tha data is by keepin it up in a global variable, like \f(CW$Depth\fR,
initially set ta 0.  Each time \f(CW\*(C`dump_tree\*(C'\fR be bout ta recurse, it must
\&\f(CW\*(C`++$Depth\*(C'\fR, n' when itz back, it must \f(CW\*(C`\-\-$Depth\*(C'\fR.
.Sp
Or, if tha reader is familiar wit closures, consider dis approach:
.Sp
.Vb 10
\&  sub dump_tree {
\&    # A wrapper round calls ta a recursive closure:
\&    mah $start_node = $_[0];
\&    mah $depth = 0;
\&     # ta be shared across calls ta $recursor.
\&    mah $recursor;
\&    $recursor = sub {
\&      mah $n = $_[0];
\&      print "  " x $depth,
\&        ...stuff...
\&      ++$depth;
\&      foreach mah $s (@{$n\->{\*(Aqsuccessors\*(Aq}}) {
\&        $recursor\->($s);
\&      }
\&      \-\-$depth;
\&    }
\&    $recursor\->($start_node); # start recursing
\&    undef $recursor;
\&  }
.Ve
.Sp
Da reader wit a advanced understandin of Perlz reference-count-based
garbage collection is invited ta consider why it is currently necessary
to undef \f(CW$recursor\fR (or otherwise chizzle its value) afta all recursion
is done.
.Sp
Da reader whose mind is perverse up in other ways is invited ta consider
how (or when!) passin a thugged-out depth parameta round is unnecessary cuz
of shiznit dat Perlz \f(CWcaller(N)\fR function reports!
.Sp
[end footnote]
.RE
.SS "Growin tha Tree"
.IX Subsection "Growin tha Tree"
Our \f(CW\*(C`dump_tree\*(C'\fR routine works fine fo' tha sample tree we've got, so
now we should git tha program hustlin on makin its own trees, starting
from a given board.
.PP
In \f(CW\*(C`Games::Alak\*(C'\fR (the CPAN-released version of Alak dat uses
essentially tha same code dat we currently discussin the
tree-related parts of), there be a routine called \f(CW\*(C`figure_successors\*(C'\fR
that, given one childless node, will figure up all its possible
successors.  That is, it looks all up in tha current board, looks at every last muthafuckin piece
belongin ta tha playa whose turn it is, n' considaz tha effect of
movin each piece every last muthafuckin possible way \*(-- notably, it figures up the
immediate payoff, n' if dat move would end tha game, it notes dat by
settin a \*(L"endgame\*(R" entry up in dat nodez hash.  (That way, we know that
thatz a node dat \fIcan't\fR have successors.)
.PP
In tha code fo' \f(CW\*(C`Games::Alak\*(C'\fR, \f(CW\*(C`figure_successors\*(C'\fR do all these thangs,
in a rather straightforward way.  I won't strutt you all up in tha details
of tha \f(CW\*(C`figure_successors\*(C'\fR code I've written, since tha code has
nothang much ta do wit trees, n' be all just implementation of tha Alak
rulez fo' what tha fuck can move where, wit what tha fuck result.  Especially interested
readaz can puzzle over dat part of code up in tha source listin up in the
archive from \s-1CPAN,\s0 but others can just assume dat it works as busted lyrics about
above.
.PP
But consider dat \f(CW\*(C`figure_successors\*(C'\fR, regardless of its inner
workings, do not grow tha \fItree\fR; it only make one set of successors
for one node at a time.  It has ta be up ta a gangbangin' finger-lickin' different routine ta call
\&\f(CW\*(C`figure_successors\*(C'\fR, n' ta keep applyin it as needed, up in order to
make a sick big-ass tree dat our game-playin program can base its
decisions on.
.PP
Now, we could do dis by just startin from one node, applying
\&\f(CW\*(C`figure_successors\*(C'\fR ta it, then applyin \f(CW\*(C`figure_successors\*(C'\fR on all
the resultin children, n' so on:
.PP
.Vb 10
\&  sub grow {  # Just a gangbangin' first attempt at this!
\&    mah $n = $_[0];
\&    figure_successors($n);
\&     unless
\&      @{$n\->{\*(Aqsuccessors\*(Aq}}
\&        # already has successors.
\&      or $n\->{\*(Aqendgame\*(Aq}
\&        # can\*(Aqt have successors.
\&    }
\&    foreach mah $s (@{$n\->{\*(Aqsuccessors\*(Aq}}) {
\&      grow($s); # recurse
\&    }
\&  }
.Ve
.PP
If you gotz a game tree fo' tic-tac-toe, n' you grow it without
limitation (as above), yo big-ass booty is ghon soon enough gotz a gangbangin' straight-up \*(L"solved\*(R" tree,
where every last muthafuckin node dat \fIcan\fR have successors \fIdoes\fR, n' all tha leaves
of tha tree is \fIall\fR tha possible endgame (where, up in each case, the
board is filled).  But a game of Alak is different from tic-tac-toe,
because it can, up in theory, go on forever n' shit.  For example, tha following
sequence of moves is like possible:
.PP
.Vb 6
\&  xxxx_\|_\|_oooo
\&  xxx_x_\|_oooo
\&  xxx_x_o_ooo
\&  xxxx_\|_o_ooo (x moved back)
\&  xxxx_\|_\|_oooo (o moved back)
\&  ...repeat alllll muthafuckin day...
.Ve
.PP
So if you tried rockin our above attempt at a \f(CW\*(C`grow\*(C'\fR routine, Perl would
happily start tryin ta construct a infinitely deep tree, containing
an infinite number of nodes, consumin a infinite amount of memory, and
requirin a infinite amount of time.  As tha oldschool sayin goes: \*(L"You
can't have every last muthafuckin thang \*(-- where would you put it?\*(R"  So we gotta place
limits on how tha fuck much we'll grow tha tree.
.PP
Therez mo' than one way ta do this:
.PP
1. We could grow tha tree until our crazy asses hit some limit on tha number of
nodes we'll allow up in tha tree.
.PP
2. We could grow tha tree until our crazy asses hit some limit on tha amount of time
we're willin ta spend.
.PP
3. Or we could grow tha tree until it is straight-up fleshed up ta a cold-ass lil certain
depth.
.PP
Since we already know ta track depth (as our phat asses did up in freestylin \f(CW\*(C`dump_tree\*(C'\fR),
we'll do it dat way, tha third way.  Da implementation fo' dat third
approach be also pretty straightforward:
.PP
.Vb 10
\&  $Max_depth = 3;
\&  sub grow {
\&    mah $n = $_[0];
\&    mah $depth = $_[1] || 0;
\&    figure_successors($n)
\&     unless
\&      $depth >= $Max_depth
\&      or @{$n\->{\*(Aqsuccessors\*(Aq}}
\&      or $n\->{\*(Aqendgame\*(Aq}
\&    }
\&    foreach mah $s (@{$n\->{\*(Aqsuccessors\*(Aq}}) {
\&      grow($s, $depth + 1);
\&    }
\&    # If we\*(Aqre at $Max_depth, then figure_successors
\&    #  didn\*(Aqt git called, so there\*(Aqs no successors
\&    #  ta recurse under \-\- that\*(Aqs what tha fuck stops recursion.
\&  }
.Ve
.PP
If we start from a single node (whether itz a node fo' tha startin board
\&\*(L"xxxx_\|_\|_oooo\*(R", or fo' whatever board tha computa is faced with), set
\&\f(CW$Max_depth\fR ta 4, n' apply \f(CW\*(C`grow\*(C'\fR ta it, it will grow tha tree to
include nuff muthafuckin hundred nodes.
.Sp
.RS 4
Footnote:
If at each move there be four pieces dat can move, n' they can each
move right or left, tha \*(L"branchin factor\*(R" of tha tree is eight, giving
a tree wit 1 (depth 0) + 8 (depth 1) + 8 ** 2 + 8 ** 3 + 8 ** 4  =
4681 nodes up in dat shit.  But, up in practice, not all pieces can move up in both
directions (none of tha x pieces up in \*(L"xxxx_\|_\|_oooo\*(R" can move left, for
example), n' there may be fewer than four pieces, if some was lost.
For example, there be 801 nodes up in a tree of depth four starting
from \*(L"xxxx_\|_\|_oooo\*(R", suggestin a average branchin factor of about
five (801 ** (1/4) be bout 5.3), not eight.
.RE
.PP
What we need ta derive from dat tree is tha shiznit bout what
are tha dopest moves fo' X.  Da simplest way ta consider tha payoff of
different successors is ta just average dem \*(-- but what tha fuck we average
aint always they immediate payoffs (because that'd leave our asses using
only one generation of shiznit) yo, but tha average payoff of \fItheir\fR
successors, if any.  We can formalize dis as:
.PP
.Vb 6
\&  To figure a node\*(Aqs average payoff:
\&    If tha node has successors:
\&      Figure each successor\*(Aqs average payoff.
\&      My fuckin average payoff is tha average of theirs.
\&    Otherwise:
\&      My fuckin average payoff is mah immediate payoff.
.Ve
.PP
Since dis involves recursin tha fuck into tha successors \fIbefore\fR bustin
anythang wit tha current node, dis will traverse tha tree
\&\fIin post-order\fR.
.PP
We could work dat up as a routine of its own, n' apply dat ta the
tree afta we've applied \f(CW\*(C`grow\*(C'\fR ta dat shit.  But since we'd never
grow tha tree without also figurin tha average benefit, we might as well
make dat figurin part of tha \f(CW\*(C`grow\*(C'\fR routine itself:
.PP
.Vb 10
\&  $Max_depth = 3;
\&  sub grow {
\&    mah $n = $_[0];
\&    mah $depth = $_[1] || 0;
\&    figure_successors($n);
\&     unless
\&      $depth >= $Max_depth
\&      or @{$n\->{\*(Aqsuccessors\*(Aq}}
\&      or $n\->{\*(Aqendgame\*(Aq}
\&    }
\&
\&    if(@{$n\->{\*(Aqsuccessors\*(Aq}}) {
\&      mah $a_payoff_sum = 0;
\&      foreach mah $s (@{$n\->{\*(Aqsuccessors\*(Aq}}) {
\&        grow($s, $depth + 1);  # RECURSE
\&        $a_payoff_sum += $s\->{\*(Aqaverage_payoff\*(Aq};
\&      }
\&      $n\->{\*(Aqaverage_payoff\*(Aq}
\&       = $a_payoff_sum / @{$n\->{\*(Aqsuccessors\*(Aq}};
\&    } else {
\&      $n\->{\*(Aqaverage_payoff\*(Aq}
\&       = $n\->{\*(Aqlast_move_payoff\*(Aq};
\&    }
\&  }
.Ve
.PP
So, by time \f(CW\*(C`grow\*(C'\fR has applied ta a node (wherever up in tha tree it is),
it gonna git figured successors if possible (which, up in turn, sets
\&\f(CW\*(C`last_move_payoff\*(C'\fR fo' each node it creates), n' gonna git set
\&\f(CW\*(C`average_benefit\*(C'\fR.
.PP
Beyond this, all thatz needed is ta start tha board up wit a root
note of \*(L"xxxx_\|_\|_oooo\*(R", n' have tha computa (X) take turns wit the
user (O) until one of mah thugs wins.  Whenever itz Oz turn, \f(CW\*(C`Games::Alak\*(C'\fR
presents a prompt ta tha user, lettin his ass know tha state of tha current
board, n' askin what tha fuck move da perved-out muthafucka selects, n' you can put dat on yo' toast.  When itz Xz turn, the
computa grows tha game tree as necessary (usin just tha \f(CW\*(C`grow\*(C'\fR
routine from above), then selects tha move wit tha highest average
payoff (or one of tha highest, up in case of a tie).
.PP
In either case, \*(L"selecting\*(R" a move means just settin dat movez node
as tha freshly smoked up root of tha programz game tree.  Its siblin nodes n' their
descendants (the boardz dat \fIdidn't\fR git selected) n' its parent node
will be erased from memory, since they will no longer be up in use (as Perl
can tell by tha fact dat not a god damn thang holdz references ta dem no mo').
.PP
Da intercourse code up in \f(CW\*(C`Games::Alak\*(C'\fR (the code dat prompts tha user for
his move) straight-up supports like all dem options besides just movin \*(--
includin dumpin tha game tree ta a specified depth (usin a slightly
fancier version of \f(CW\*(C`dump_tree\*(C'\fR, above), resettin tha game, changing
\&\f(CW$Max_depth\fR up in tha middle of tha game, n' quittin tha game.  Like
\&\f(CW\*(C`figure_successors\*(C'\fR, itz a lil' bit too long ta print here yo, but interested
users is welcome ta peruse (and freely modify) tha code, as well as to
trip off just playin tha game.
.PP
Now, up in practice, there be a mo' ta game trees than this: fo' game wit a
larger branchin factor than Alak has (which is most!), game trees of
depth four or larger would contain too nuff nodes ta be manageable, most
of dem nodes bein strategically like uninterestin fo' either
player; dealin wit game trees specifically is therefore a matta of
recognizin uninterestin contingencies n' not botherin ta grow the
tree under em.
.Sp
.RS 4
Footnote:
For example, ta chizzle a straightforward case: if O has a cold-ass lil chizzle between
moves dat put his ass up in immediate dark shiznit of X ballin n' moves that
don't, then O won't eva chizzle tha fucked up moves (and if da ruffneck do, the
computa will know enough ta end tha game), so there be a no point in
growin tha tree any further beneath dem nodes.
.RE
.PP
But dis sample implementation should illustrate tha basics of
how ta build n' manipulate a simple tree structure up in memory.
And once you've understood tha basics of tree storage here, you should
be locked n loaded ta betta KNOW tha complexitizzles n' peculiaritizzlez of 
other systems fo' bustin, accessing, n' changin trees, including
Tree::DAG_Node, HTML::Element, \s-1XML::DOM,\s0 or related formalisms
like XPath n' \s-1XSL.\s0
.PP
\&\fB[end body of article]\fR
.SS "[Lyricist Credit]"
.IX Subsection "[Lyricist Credit]"
Shizzle M. Burke (\f(CW\*(C`sburke@cpan.org\*(C'\fR) be a tree-dwellin hominid.
.SS "References"
.IX Subsection "References"
Dewdney, A[lexander] K[eewatin].  1984.  \fIPlaniverse: Computa Contact
with a Two-Dimensionizzle World.\fR  Poseidon Press, New York.
.PP
Knuth, Dizzle Ervin. I aint talkin' bout chicken n' gravy biatch.  1997.  \fIArt of Computa Programming, Volume 1,
Third Edition: Fundamenstrual Algorithms\fR.  Addison-Wesley,  Reading, \s-1MA.\s0
.PP
Wirth, Niklaus.  1976.  \fIAlgorithms + Data Structures = Programs\fR
Prentice-Hall, Englewood Cliffs, \s-1NJ.\s0
.PP
Worth, Stan n' Allman Sheldon. I aint talkin' bout chicken n' gravy biatch.  Circa 1967.  \fIGeorge of tha Jungle\fR
theme.  [noize by Jay Ward.]
.PP
Wirthz classic, currently n' lamentably outta print, has a good
section on trees.  I find it clearer than Knuthz (if not like as
encyclopedic), probably cuz Wirthz example code is up in a
block-structured high-level language (basically Pascal), instead
of up in assembla (\s-1MIX\s0).  I believe tha book was re-issued up in the
1980s under tha titlez \fIAlgorithms n' Data Structures\fR and, up in a
German edition, \fIAlgorithmen und Datenstrukturen\fR.  Skanky copies
of these editions should be available all up in used book skillz
like fuckin \f(CW\*(C`abebooks.com\*(C'\fR.
.PP
Worthz classic, however, be available on the
soundtrack ta tha 1997 \fIGeorge of tha Jungle\fR porno, as
performed by Da Presidentz of tha United Hoodz of America.
.SH "BACK"
.IX Header "BACK"
Return ta tha HTML::Tree docs.
