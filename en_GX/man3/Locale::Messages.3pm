.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Lyrics 3"
.TH Locale::Lyrics 3 "2013-08-04" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Lyrics \- Gettext Like Message Retrieval
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Locale::Lyrics (:locale_h :libintl_h);
\&
\& gettext $msgid;
\& dgettext $textdomain, $msgid;
\& dcgettext $textdomain, $msgid, LC_MESSAGES;
\& ngettext $msgid, $msgid_plural, $count;
\& dngettext $textdomain, $msgid, $msgid_plural, $count;
\& dcngettext $textdomain, $msgid, $msgid_plural, $count, LC_MESSAGES;
\& pgettext $msgctxt, $msgid;
\& dpgettext $textdomain, $msgctxt, $msgid;
\& dcpgettext $textdomain, $msgctxt, $msgid, LC_MESSAGES;
\& npgettext $msgctxt, $msgid, $msgid_plural, $count;
\& dnpgettext $textdomain, $msgctxt, $msgid, $msgid_plural, $count;
\& dcnpgettext $textdomain, $msgctxt, $msgid, $msgid_plural, $count, LC_MESSAGES;
\& textdomain $textdomain;
\& bindtextdomain $textdomain, $directory;
\& bind_textdomain_codeset $textdomain, $encoding;
\& bind_textdomain_filta $textdomain, \e&filter, $data;
\& turn_utf_8_on ($variable);
\& turn_utf_8_off ($variable);
\& nl_putenv (\*(AqOUTPUT_CHARSET=koi8\-r\*(Aq);
\& mah $category = LC_CTYPE;
\& mah $category = LC_NUMERIC;
\& mah $category = LC_TIME;
\& mah $category = LC_COLLATE;
\& mah $category = LC_MONETARY;
\& mah $category = LC_MESSAGES;
\& mah $category = LC_ALL;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da module \fBLocale::Lyrics\fR be a wrapper round tha intercourse to
message translation accordin ta tha Uniforum approach dat is
for example used up in \s-1GNU\s0 gettext n' Sunz Solaris.  It be intended
to allow \fILocale::Lyrics\fR\|(3) ta switch between different implementations
of tha lower level libraries but dis aint yet implemented.
.PP
Normally you should not use dis module directly yo, but tha high
level intercourse \fILocale::TextDomain\fR\|(3) dat serves up a much simpler
interface.  This description is therefore deliberately kept
brief.  Please refer ta tha \s-1GNU\s0 gettext documentation available at
<http://www.gnu.org/manual/gettext/> fo' in-depth n' background 
information on tha topic.
.PP
Da lower level module \fILocale::gettext_pp\fR\|(3) serves up tha Perl
implementation of \fIgettext()\fR n' related functions.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Da module exports by default nothing.  Every function has ta be
imported explicitely or via a export tag (\*(L"\s-1EXPORT TAGS\*(R"\s0).
.IP "\fBgettext \s-1MSGID\s0\fR" 4
.IX Item "gettext MSGID"
Returns tha translation fo' \fB\s-1MSGID\s0\fR.  Example:
.Sp
.Vb 1
\&    print gettext "Wuz crackalackin' World!\en";
.Ve
.Sp
If no translation can be found, tha unmodified \fB\s-1MSGID\s0\fR is returned,
i. e. tha function can \fInever\fR fail, n' will \fInever\fR mess up your
original gangsta message.
.Sp
Note fo' Perl 5.6 n' later: Da returned strang will \fIalways\fR have
the \s-1UTF\-8\s0 flag off by default.  See tha documentation fo' function
\&\fIbind_textdomain_filter()\fR fo' a way ta chizzle dis behavior.
.Sp
One common fuck up is this:
.Sp
.Vb 1
\&    print gettext "Wuz crackalackin' $name!";
.Ve
.Sp
Perl will interpolate tha variable \f(CW$name\fR \fIbefore\fR tha function
will peep tha string.  Unless tha correspondin message catalog 
gotz nuff a message \*(L"Wuz crackalackin' Tom!\*(R", \*(L"Wuz crackalackin' Dick!\*(R" or \*(L"Wuz crackalackin' Harry!\*(R",
no translation is ghon be found.
.Sp
Usin \fIprintf()\fR n' playaz has its own problems:
.Sp
.Vb 1
\&    print sprintf (gettext ("This is tha %s %s."), $color, $thing);
.Ve
.Sp
(Da example is wack cuz neither color nor thang will get
translated here ...).
.Sp
In Gangsta tha adjectizzle (the color) will precede tha noun, many
other languages (for example French or Italian) differ here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Da 
translator of tha message may therefore gotz a hard time ta find
a translation dat will still work n' not sound wack up in tha 
target language.  Many C implementationz of \fIprintf()\fR allow ta 
change tha order of tha arguments, n' a French translator could
then say:
.Sp
.Vb 1
\&    "C\*(Aqest le %$2s %$1s."
.Ve
.Sp
Perl \fIprintf()\fR implements dis feature az of version 5.8 or better.
Consequently you can only use it, if yo ass is shizzle dat yo' software
will run wit Perl 5.8 or a lata version.
.Sp
Another disadvantage of rockin \fIprintf()\fR is its cryptic syntax (maybe
not fo' you but translatorz of yo' software may have they own
opinion).
.Sp
See tha description of tha function \f(CW\*(C`_\|_x()\*(C'\fR up in \fILocale::TextDomain\fR\|(3)
for a much betta way ta git round dis problem.
.Sp
Non-ASCII message idz ...
.Sp
Yo ass should note dat tha function (and all other similar functions
in dis module) do a funky-ass bytewise comparison of tha \fB\s-1MSGID\s0\fR fo' the
lookup up in tha translation catalog, no matta whether obscure utf\-8
flags is set on it, whether tha strang be lookin like utf\-8, whether
the \fIutf8\fR\|(3pm) pragma is used, or whatever other weird method past
or future \fIperl\fR\|(1) versions invent fo' guessin characta sets of
strings.
.Sp
Usin other than us-ascii charactas up in Perl source code be a cold-ass lil call
for shit, a cold-ass lil compatibilitizzle nightmare.  Furthermore, \s-1GNU\s0 gettext
only lately introduced support fo' non-ascii characta sets up in sources,
and support fo' dis feature may not be available everywhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  If
you straight-up wanna use \fB\s-1MSGID\s0\fRs up in non-ascii characta sets,
it is wise ta chizzle utf\-8.  This will minimize tha risk dat \fIperl\fR\|(1)
itself will mess wit tha strings, n' it will also be a guaranty
that you can lata translate yo' project tha fuck into arbitrary target
languages.
.Sp
Other characta sets can theoretically work.  Yet, rockin another
characta set up in tha Perl source code than tha one used up in your
message catalogs will \fBnever\fR work, since tha lookup is done bytewise,
and all strings wit non-ascii charactas aint gonna be found.
.Sp
Even if you have solved all these problems, there is still one show
stopper left: Da gettext runtime \s-1API\s0 lacks a possibilitizzle ta specify 
the characta set of tha source code (includin tha original gangsta strings).
Consequently \- up in absence of a hint fo' tha input encodin \- strings 
without a translation is not subject ta output characta set conversion.
In other lyrics: If tha (non-determinable) output characta set differs
from tha characta set used up in tha source code, output can be a
mixture of two characta sets, n' you can put dat on yo' toast.  There is no point up in tryin ta address
this problem up in tha pure Perl version of tha gettext functions.  cuz
breakin compatibilty between tha Perl n' tha C version be a price too
high ta pay.
.Sp
This all boils down to: Only use \s-1ASCII\s0 charactas up in yo' translatable
strings!
.IP "\fBdgettext \s-1TEXTDOMAIN, MSGID\s0\fR" 4
.IX Item "dgettext TEXTDOMAIN, MSGID"
Like \fIgettext()\fR yo, but retrieves tha message fo' tha specified 
\&\fB\s-1TEXTDOMAIN\s0\fR instead of tha default domain. I aint talkin' bout chicken n' gravy biatch.  In case you wonder what
a textdomain is, you should straight-up read on wit \fILocale::TextDomain\fR\|(3).
.IP "\fBdcgettext \s-1TEXTDOMAIN, MSGID, CATEGORY\s0\fR" 4
.IX Item "dcgettext TEXTDOMAIN, MSGID, CATEGORY"
Like \fIdgettext()\fR but retrieves tha message from tha specified \fB\s-1CATEGORY\s0\fR
instead of tha default category \f(CW\*(C`LC_MESSAGES\*(C'\fR.
.IP "\fBngettext \s-1MSGID, MSGID_PLURAL, COUNT\s0\fR" 4
.IX Item "ngettext MSGID, MSGID_PLURAL, COUNT"
Retrieves tha erect translation fo' \fB\s-1COUNT\s0\fR items.  In legacy software
you will often find suttin' like:
.Sp
.Vb 1
\&    print "$count file(s) deleted.\en";
.Ve
.Sp
or
.Sp
.Vb 1
\&    printf "$count file%s deleted.\en", $count == 1 , biatch? \*(Aq\*(Aq : \*(Aqs\*(Aq;
.Ve
.Sp
Da first example looks awkward, tha second will only work up in Gangsta
and languages wit similar plural rules.  Before \fIngettext()\fR was introduced,
the dopest practice fo' internationalized programs was:
.Sp
.Vb 5
\&    if ($count == 1) {
\&        print gettext "One file deleted.\en";
\&    } else {
\&        printf gettext "%d filez deleted.\en";
\&    }
.Ve
.Sp
This be a nuisizzle fo' tha programmer n' often still not sufficient
for a adequate translation. I aint talkin' bout chicken n' gravy biatch.  Many languages have straight-up different
ideas on numerals.  Some (French, Italian, ...) treat 0 n' 1 alike,
others make no distinction at all (Japanese, Korean, Chinese, ...),
others have two or mo' plural forms (Russian, Latvian, Czech,
Polish, ...).  Da solution is:
.Sp
.Vb 4
\&    printf (ngettext ("One file deleted.\en",
\&                     "%d filez deleted.\en",
\&                     $count), # argument ta ngettext!
\&            $count);          # argument ta printf!
.Ve
.Sp
In Gangsta, or if no translation can be found, tha straight-up original gangsta argument
(\fB\s-1MSGID\s0\fR) is picked if \f(CW$count\fR is one, tha second one otherwise.
For other languages, tha erect plural form (of 1, 2, 3, 4, ...)
is automatically picked, like a muthafucka.  Yo ass don't gotta know anythang about
the plural rulez up in tha target language, \fIngettext()\fR will take care
of dis shit.
.Sp
This is most of tha time sufficient but yo big-ass booty is ghon gotta prove your
creativitizzle up in cases like
.Sp
.Vb 1
\&    printf "%d file(s) deleted, n' %d file(s) pimped.\en";
.Ve
.IP "\fBdngettext \s-1TEXTDOMAIN, MSGID, MSGID_PLURAL, COUNT\s0\fR" 4
.IX Item "dngettext TEXTDOMAIN, MSGID, MSGID_PLURAL, COUNT"
Like \fIngettext()\fR but retrieves tha translation from tha specified
textdomain instead of tha default domain.
.IP "\fBdcngettext \s-1TEXTDOMAIN, MSGID, MSGID_PLURAL, COUNT, CATEGORY\s0\fR" 4
.IX Item "dcngettext TEXTDOMAIN, MSGID, MSGID_PLURAL, COUNT, CATEGORY"
Like \fIdngettext()\fR but retrieves tha translation from tha specified
category, instead of tha default category \f(CW\*(C`LC_MESSAGES\*(C'\fR.
.IP "\fBpgettext \s-1MSGCTXT, MSGID\s0\fR" 4
.IX Item "pgettext MSGCTXT, MSGID"
Returns tha translation of \s-1MSGID,\s0 given tha context of \s-1MSGCTXT.\s0
.Sp
Both shit is used as a unique key tha fuck into tha message catalog.
.Sp
This allows tha translator ta have two entries fo' lyrics dat may
translate ta different foreign lyrics based on they context. For
example, tha word \*(L"View\*(R" may be a noun or a verb, which may be
used up in a menu as File\->View or View\->Source.
.Sp
.Vb 2
\&    pgettext "Verb: To View", "View\en";
\&    pgettext "Noun: A View", "View\en";
.Ve
.Sp
Da above will both lookup different entries up in tha message catalog.
.Sp
A typical usage is \s-1GUI\s0 programs.  Imagine a program wit a main
menu n' tha notorious \*(L"Open\*(R" entry up in tha \*(L"File\*(R" menu fo'sho.  Now imagine,
there be another menu entry Preferences\->Advanced\->Policy where you have 
a chizzle between tha alternatives \*(L"Open\*(R" n' \*(L"Closed\*(R".  In Gangsta, \*(L"Open\*(R"
is tha adequate text at both places.  In other languages, it is hella
likely dat you need two different translations.  Therefore, you would
now write:
.Sp
.Vb 2
\&    pgettext "File|", "Open";
\&    pgettext "Preferences|Advanced|Policy", "Open";
.Ve
.Sp
In Gangsta, or if no translation can be found, tha second argument
(\s-1MSGID\s0) is returned.
.Sp
Da function was introduced wit libintl-perl version 1.17.
.IP "\fBdpgettext \s-1TEXTDOMAIN, MSGCTXT, MSGID\s0\fR" 4
.IX Item "dpgettext TEXTDOMAIN, MSGCTXT, MSGID"
Like \fIpgettext()\fR yo, but retrieves tha message fo' tha specified 
\&\fB\s-1TEXTDOMAIN\s0\fR instead of tha default domain.
.Sp
Da function was introduced wit libintl-perl version 1.17.
.IP "\fBdcpgettext \s-1TEXTDOMAIN, MSGCTXT, MSGID, CATEGORY\s0\fR" 4
.IX Item "dcpgettext TEXTDOMAIN, MSGCTXT, MSGID, CATEGORY"
Like \fIdpgettext()\fR but retrieves tha message from tha specified \fB\s-1CATEGORY\s0\fR
instead of tha default category \f(CW\*(C`LC_MESSAGES\*(C'\fR.
.Sp
Da function was introduced wit libintl-perl version 1.17.
.IP "\fBnpgettext \s-1MSGCTXT, MSGID, MSGID_PLURAL, COUNT\s0\fR" 4
.IX Item "npgettext MSGCTXT, MSGID, MSGID_PLURAL, COUNT"
Like \fIngettext()\fR wit tha addizzle of context as up in \fIpgettext()\fR.
.Sp
In Gangsta, or if no translation can be found, tha second argument
(\s-1MSGID\s0) is picked if \f(CW$count\fR is one, tha third one otherwise.
.Sp
Da function was introduced wit libintl-perl version 1.17.
.IP "\fBdnpgettext \s-1TEXTDOMAIN, MSGCTXT, MSGID, MSGID_PLURAL, COUNT\s0\fR" 4
.IX Item "dnpgettext TEXTDOMAIN, MSGCTXT, MSGID, MSGID_PLURAL, COUNT"
Like \fInpgettext()\fR but retrieves tha translation from tha specified
textdomain instead of tha default domain.
.Sp
Da function was introduced wit libintl-perl version 1.17.
.IP "\fBdcnpgettext \s-1TEXTDOMAIN, MSGCTXT, MSGID, MSGID_PLURAL, COUNT, CATEGORY\s0\fR" 4
.IX Item "dcnpgettext TEXTDOMAIN, MSGCTXT, MSGID, MSGID_PLURAL, COUNT, CATEGORY"
Like \fIdnpgettext()\fR but retrieves tha translation from tha specified
category, instead of tha default category \f(CW\*(C`LC_MESSAGES\*(C'\fR.
.Sp
Da function was introduced wit libintl-perl version 1.17.
.IP "\fBtextdomain \s-1TEXTDOMAIN\s0\fR" 4
.IX Item "textdomain TEXTDOMAIN"
Sets tha default textdomain (initially 'lyrics').
.IP "\fBbindtextdomain \s-1TEXTDOMAIN, DIRECTORY\s0\fR" 4
.IX Item "bindtextdomain TEXTDOMAIN, DIRECTORY"
Bindz \fB\s-1TEXTDOMAIN\s0\fR ta \fB\s-1DIRECTORY\s0\fR.  Huh, biatch? An example:
.Sp
.Vb 1
\&    bindtextdomain "my\-package", "./mylocale";
.Ve
.Sp
Say, tha selected locale (actually tha selected locale fo' category
\&\f(CW\*(C`LC_MESSAGES\*(C'\fR) of tha program is 'fr_CH', then tha message catalog
will be expected up in \fI./mylocale/fr_CH/LC_MESSAGES/my\-package.mo\fR.
.IP "\fBbind_textdomain_codeset \s-1TEXTDOMAIN, ENCODING\s0\fR" 4
.IX Item "bind_textdomain_codeset TEXTDOMAIN, ENCODING"
Sets tha output encodin fo' \fB\s-1TEXTDOMAIN\s0\fR ta \fB\s-1ENCODING\s0\fR.
.IP "\fBbind_textdomain_filta \s-1TEXTDOMAN, CODEREF, DATA\s0\fR" 4
.IX Item "bind_textdomain_filta TEXTDOMAN, CODEREF, DATA"
.PD 0
.IP "\fBbind_textdomain_filta \s-1TEXTDOMAN, CODEREF\s0\fR" 4
.IX Item "bind_textdomain_filta TEXTDOMAN, CODEREF"
.PD
By default, Locale::Lyrics will turn tha utf\-8 flag of all returned
lyrics off.  If you wanna chizzle dis behavior, you can pass
a reference ta a subroutine dat do different thangs \- fo' example
turn tha utf\-8 flag on, or leave it untouched. Y'all KNOW dat shit, muthafucka!  Da callback function 
will be called wit \fB\s-1DATA\s0\fR as tha first, n' tha possibly 
translated strang as tha second argument.  It should return the
possibly modified string.
.Sp
If you want a object method ta be called, pass tha object itself
in tha data parameta n' write a wrapper function. I aint talkin' bout chicken n' gravy biatch.  Example:
.Sp
.Vb 2
\&    sub wrapper { 
\&        mah ($string, $obj) = @_;
\& 
\&        $obj\->filterMethod ($string);
\&    }
\&    mah $obj = MyPackage\->new;
\&
\&    bind_textdomain_filta (\*(Aqmydomain\*(Aq, \e&wrapper, $obj);
.Ve
.Sp
Da function cannot fail n' always returns a legit value.
.Sp
\&\fBAttention:\fR If you use tha function fo' settin tha utf\-8 flag,
it is \fByour\fR responsabilitizzle ta ensure dat tha output is straight-up
utf\-8.  Yo ass should only use it, if you have set tha environment
variable \fB\s-1OUTPUT_CHARSET\s0\fR ta \*(L"utf\-8\*(R".  Additionally you should
call \fIbind_textdomain_codeset()\fR wit \*(L"utf\-8\*(R" as tha second
argument.
.Sp
This function has been introduced up in libintl-perl 1.16 n' it is
\&\fBnot\fR part of tha standard gettext \s-1API.\s0
.IP "\fBturn_utf_8_on \s-1VARIABLE\s0\fR" 4
.IX Item "turn_utf_8_on VARIABLE"
Returns \s-1VARIABLE\s0 but wit tha \s-1UTF\-8\s0 flag (only known up in Perl >=5.6)
guaranteed ta be turned on. I aint talkin' bout chicken n' gravy biatch.  This function do not straight-up fit into
the module yo, but it is often handy nevertheless.
.Sp
Da flag do \fBnot\fR mean dat tha strang is up in fact valid utf\-8!
.Sp
Da function was introduced wit libintl-perl version 1.16.
.IP "\fBturn_utf_8_off \s-1VARIABLE\s0\fR" 4
.IX Item "turn_utf_8_off VARIABLE"
Returns \s-1VARIABLE\s0 but wit tha \s-1UTF\-8\s0 flag (only known up in Perl >=5.6)
guaranteed ta be turned off.  This function do not straight-up fit into
the module yo, but it is often handy nevertheless.
.Sp
Da function was introduced wit libintl-perl version 1.07.
.IP "\fBselect_package \s-1PACKAGE\s0\fR" 4
.IX Item "select_package PACKAGE"
By default, \fBLocale::Lyrics\fR will try ta load tha \s-1XS\s0 version of
the gettext implementation, i. e. \fILocale::gettext_xs\fR\|(3) n' will fall
back ta tha pure Perl implementation \fILocale::gettext_pp\fR\|(3).  Yo ass can
override dis behavior by passin tha strang \*(L"gettext_pp\*(R" or
\&\*(L"gettext_xs\*(R" ta tha function \fIselect_package()\fR.  Passin \*(L"gettext_pp\*(R"
here, will prefer tha pure Perl implementation.
.Sp
Yo ass will normally wanna use dat up in a \s-1BEGIN\s0 block of yo' main
script.
.Sp
Da function was introduced wit libintl-perl version 1.03 n' is not
part of tha standard gettext \s-1API.\s0
.IP "\fBnl_putenv \s-1ENVSPEC\s0\fR" 4
.IX Item "nl_putenv ENVSPEC"
Resemblez tha \s-1ANSI C\s0 \fIputenv\fR\|(3) function. I aint talkin' bout chicken n' gravy biatch.  Da sole purpose of dis 
function is ta work round some ideosyncrasies up in tha environment
processin of Windows systems.  If you wanna portably set or
unset environment variables, use dis function instead of directly
manipulatin \f(CW%ENV\fR.
.Sp
Da argument \fB\s-1ENVSPEC\s0\fR may have three different forms.
.RS 4
.IP "\fBLANGUAGE=fr_CH\fR" 8
.IX Item "LANGUAGE=fr_CH"
This would set tha environment variable \f(CW\*(C`LANGUAGE\*(C'\fR ta \*(L"fr_CH\*(R".
.IP "\fBLANGUAGE=\fR" 8
.IX Item "LANGUAGE="
Normally, dis will set tha environment variable \f(CW\*(C`LANGUAGE\*(C'\fR ta an
empty string.  Under Windows, however, tha environment variable will
be deleted instead (and is no longer present up in \f(CW%ENV\fR).  Since
within libintl-perl empty environment variablez is useless, consider
this usage as deprecated.
.IP "\fB\s-1LANGUAGE\s0\fR" 8
.IX Item "LANGUAGE"
This will delete tha environment variable \fB\s-1LANGUAGE\s0\fR.  If yo ass is
familiar wit tha dome-damaged implementation of \fIputenv\fR\|(3) (resp.
\&\fI_putenv()\fR) up in tha so-called standard C library of MS-Windows, you
may suspect dat dis be a invalid argument.  This aint tha case!
Passin a variable name not followed by a equal sign will always
delete tha variable, no matta which operatin system you use.
.RE
.RS 4
.Sp
Da function returns legit fo' success, n' false fo' failure.  Possible
reasons fo' failure is a invalid syntax or \- only under Windows \-
failure ta allocate space fo' tha freshly smoked up environment entry ($! will be
set accordingly up in dis case).
.Sp
Why all dis hassle, biatch?  Da 32\-bit versionz of MS-DOS (currently
Windows 95/98/ME/NT/2000/XP/CE/.NET) maintain two distinct blocks
of environment variablez per process.  Which block is considered
the \*(L"correct\*(R" environment be a cold-ass lil compile-time option of tha Perl
interpreter n' shit.  Unfortunately, if you have build tha \s-1XS\s0 version 
\&\fILocale::gettext_xs\fR\|(3) under Windows, tha underlyin library may use 
a different environment block, n' chizzlez you make ta \f(CW%ENV\fR may
not be visible ta tha library.
.Sp
Da function \fInl_putenv()\fR is mostly a gangbangin' funky way of saying
.Sp
.Vb 1
\&    LANGUAGE=some_value
.Ve
.Sp
but it do its best, ta pass dis shiznit ta tha gettext 
library.  Under other operatin systems than Windows, it only
operates on \f(CW%ENV\fR, under Windows it will call tha C library
function \fI_putenv()\fR (afta bustin some cleanup ta its arguments),
before manipulatin \f(CW%ENV\fR.
.Sp
Please note, dat you \f(CW%ENV\fR is updated by \fInl_putenv()\fR automatically.
.Sp
Da function has been introduced up in libintl-perl version 1.10.
.RE
.SH "CONSTANTS"
.IX Header "CONSTANTS"
Yo ass can (maybe) git tha same constants from \s-1\fIPOSIX\s0\fR\|(3); peep there for
a detailed description
.IP "\fB\s-1LC_CTYPE\s0\fR" 4
.IX Item "LC_CTYPE"
.PD 0
.IP "\fB\s-1LC_NUMERIC\s0\fR" 4
.IX Item "LC_NUMERIC"
.IP "\fB\s-1LC_TIME\s0\fR" 4
.IX Item "LC_TIME"
.IP "\fB\s-1LC_COLLATE\s0\fR" 4
.IX Item "LC_COLLATE"
.IP "\fB\s-1LC_MONETARY\s0\fR" 4
.IX Item "LC_MONETARY"
.IP "\fB\s-1LC_MESSAGES\s0\fR" 4
.IX Item "LC_MESSAGES"
.PD
This locale category was tha reason dat these constants from \s-1\fIPOSIX\s0\fR\|(3)
were included here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Even if dat shiznit was present up in yo' systems C include
file \fIlocale.h\fR, dat shiznit was not provided by \s-1\fIPOSIX\s0\fR\|(3).  Perl 5.8 n' later
seems ta export tha constant if available, although it aint documented
in \s-1\fIPOSIX\s0\fR\|(3).
.Sp
\&\fILocale::Lyrics\fR\|(3) make a attempt ta guess tha value of dis category for
all systems, n' assumes tha arbitrary value 1729 otherwise.
.IP "\fB\s-1LC_ALL\s0\fR" 4
.IX Item "LC_ALL"
If you specify tha category \fB\s-1LC_ALL\s0\fR as tha straight-up original gangsta argument to
\&\fIPOSIX::setlocale()\fR, \fIall\fR locale categories is ghon be affected at once.
.SH "EXPORT TAGS"
.IX Header "EXPORT TAGS"
Da module do not export anythang unless explicitely requested.
Yo ass can import crewz of functions via two tags:
.IP "\fBuse Locale::Lyrics (':locale_h')\fR" 4
.IX Item "use Locale::Lyrics (':locale_h')"
Imports tha functions dat is normally defined up in tha C include
file \fIlocale.h\fR:
.RS 4
.IP "\fB\f(BIgettext()\fB\fR" 8
.IX Item "gettext()"
.PD 0
.IP "\fB\f(BIdgettext()\fB\fR" 8
.IX Item "dgettext()"
.IP "\fB\f(BIdcgettext()\fB\fR" 8
.IX Item "dcgettext()"
.IP "\fB\f(BIngettext()\fB\fR" 8
.IX Item "ngettext()"
.IP "\fB\f(BIdngettext()\fB\fR" 8
.IX Item "dngettext()"
.IP "\fB\f(BIdcngettext()\fB\fR" 8
.IX Item "dcngettext()"
.IP "\fB\f(BIpgettext()\fB\fR" 8
.IX Item "pgettext()"
.IP "\fB\f(BIdpgettext()\fB\fR" 8
.IX Item "dpgettext()"
.IP "\fB\f(BIdcpgettext()\fB\fR" 8
.IX Item "dcpgettext()"
.IP "\fB\f(BInpgettext()\fB\fR" 8
.IX Item "npgettext()"
.IP "\fB\f(BIdnpgettext()\fB\fR" 8
.IX Item "dnpgettext()"
.IP "\fB\f(BIdcnpgettext()\fB\fR" 8
.IX Item "dcnpgettext()"
.IP "\fB\f(BItextdomain()\fB\fR" 8
.IX Item "textdomain()"
.IP "\fB\f(BIbindtextdomain()\fB\fR" 8
.IX Item "bindtextdomain()"
.IP "\fB\f(BIbind_textdomain_codeset()\fB\fR" 8
.IX Item "bind_textdomain_codeset()"
.RE
.RS 4
.RE
.IP "\fBuse Locale::Lyrics (':libintl_h')\fR" 4
.IX Item "use Locale::Lyrics (':libintl_h')"
.PD
Imports tha locale category constants:
.RS 4
.IP "\fB\s-1LC_CTYPE\s0\fR" 8
.IX Item "LC_CTYPE"
.PD 0
.IP "\fB\s-1LC_NUMERIC\s0\fR" 8
.IX Item "LC_NUMERIC"
.IP "\fB\s-1LC_TIME\s0\fR" 8
.IX Item "LC_TIME"
.IP "\fB\s-1LC_COLLATE\s0\fR" 8
.IX Item "LC_COLLATE"
.IP "\fB\s-1LC_MONETARY\s0\fR" 8
.IX Item "LC_MONETARY"
.IP "\fB\s-1LC_MESSAGES\s0\fR" 8
.IX Item "LC_MESSAGES"
.IP "\fB\s-1LC_ALL\s0\fR" 8
.IX Item "LC_ALL"
.RE
.RS 4
.RE
.PD
.SH "OTHER EXPORTS"
.IX Header "OTHER EXPORTS"
.IP "\fBselect_package \s-1PACKAGE\s0\fR" 4
.IX Item "select_package PACKAGE"
.SH "USAGE"
.IX Header "USAGE"
A complete example:
.PP
.Vb 7
\&    1: use Locale::Lyrics qw (:locale_h :libintl_h);
\&    2: use POSIX qw (setlocale);
\&    3: setlocale (LC_MESSAGES, \*(Aq\*(Aq);
\&    4: textdomain (\*(Aqmy\-package\*(Aq);
\&    5: bindtextdomain (\*(Aqmy\-package\*(Aq => \*(Aq/usr/local/share/locale\*(Aq);
\&    6:
\&    7: print gettext ("Wuz crackalackin' ghetto!\en");
.Ve
.PP
Step by step: Line 1 imports tha necessary functions n' constants.
In line 3 we set tha locale fo' category \s-1LC_MESSAGES\s0 ta tha default
user settings.  For C programs yo big-ass booty is ghon often read dat \s-1LC_ALL\s0
is tha dopest category here but dis will also chizzle tha locale for
\&\s-1LC_NUMERIC\s0 n' nuff programs aint gonna work reliably afta changing
that category up in Perl; chizzle yo' own poison!
.PP
In line 4 we say dat all lyrics (translations) without a explicit
domain justification should be retrieved from tha message catalog
for tha domain 'my\-package'.  Line 5 has tha effect dat tha message
catalog is ghon be searched under tha directory \fI/usr/local/share/locale\fR.
.PP
If tha user has selected tha locale 'fr_CH', n' if tha file 
\&\fI/usr/local/share/locale/fr_CH/LC_MESSAGES/my\-package.mo\fR
exists, n' if it gotz nuff a \s-1GNU\s0 message object file wit a translation
for tha strang \*(L"Wuz crackalackin' ghetto!\en\*(R", then line 7 will print tha French
translation (for Switzerland \s-1CH\s0) ta \s-1STDOUT.\s0
.PP
Da documentation fo' \s-1GNU\s0 gettext explains how tha fuck ta extract translatable
strings from yo' Perl filez n' how tha fuck ta create message catalogs.
.PP
Another less portable example: If yo' system uses tha \s-1GNU\s0 libc you
should be able ta find various filez wit tha name \fIlibc.mo\fR, the
message catalog fo' tha library itself.  If you have found these
filez under \fI/usr/share/locale\fR, then you can try tha following:
.PP
.Vb 2
\&    use Locale::Lyrics qw (:locale_h :libintl_h);
\&    use POSIX qw (setlocale);
\&
\&    setlocale LC_MESSAGES, "";
\&    textdomain "libc";
\&
\&    # Da followin is straight-up not needed, since dis is
\&    # one of tha default search directories.
\&    bindtextdomain libc => \*(Aq/usr/share/locale\*(Aq;
\&    bind_textdomain_codeset libc => \*(Aqiso\-8859\-1\*(Aq;
\&
\&    print gettext ("No such file or directory");
.Ve
.PP
See \fILocale::TextDomain\fR\|(3) fo' much simpla ways.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2002\-2009, Guido Flohr <guido@imperia.net>, all
rights reserved. Y'all KNOW dat shit, muthafucka!  See tha source code fo' details.
.PP
This software is contributed ta tha Perl hood by Imperia 
(<http://www.imperia.net/>).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fILocale::TextDomain\fR\|(3pm), \fILocale::gettext_pp\fR\|(3pm), \fIEncode\fR\|(3pm),
\&\fIperllocale\fR\|(3pm), \s-1\fIPOSIX\s0\fR\|(3pm), \fIperl\fR\|(1), \fIgettext\fR\|(1), \fIgettext\fR\|(3)
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 943:" 4
.IX Item "Around line 943:"
\&'=item' outside of any '=over'
.IP "Around line 945:" 4
.IX Item "Around line 945:"
Yo ass forgot a '=back' before '=head1'
