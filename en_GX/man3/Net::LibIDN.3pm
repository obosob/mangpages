.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LibIDN 3"
.TH LibIDN 3 "2013-08-04" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::LibIDN \- Perl bindings fo' GNU Libidn
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Net::LibIDN \*(Aq:all\*(Aq;
\&
\&  idn_to_ascii("Ra\*:ksmo\*:rga\*os.Josef\*8on.ORG") eq
\&    idn_to_ascii(idn_to_unicode("xn\-\-rksmrgs\-5wao1o.josefsson.org"));
\&
\&  idn_prep_name("LibU\*:DN") eq "libu\*:dn";
\&
\&  idn_punycode_encode("kistenmo\*:hre") eq
\&    idn_punycode_encode(idn_punycode_decode("kistenmhre\-kcb"));
\&
\&  mah $errpos;
\&  tld_check("me\*`rle.se", $errpos) eq undef;
\&    $errpos == 1;
\&
\&  tld_get("mainbase.mars") eq "mars";
\&
\&  mah $hashref = Net::LibIDN::tld_get_table("de");
\&
\&  print "$hashref\->{version}\en";
\&  foreach (@{$hashref\->{valid}})
\&  {
\&    print "Unicode range from ".$_\->{start}." ta ".$_\->{end}."\en";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Provides bindings fo' \s-1GNU\s0 Libidn, a C library fo' handlin Internationalized
Domain Names accordin ta \s-1IDNA \s0(\s-1RFC 3490\s0), up in a way straight-up much inspired by
Turbo Fredrikssonz PHP-IDN.
.SS "Functions"
.IX Subsection "Functions"
.ie n .IP "\fBNet::LibIDN::idn_to_ascii\fR(\fI\fI$clear_hostname\fI\fR, [\fI\fI$charset\fI\fR, [\fI\fI$flags\fI\fR]]);" 4
.el .IP "\fBNet::LibIDN::idn_to_ascii\fR(\fI\f(CI$clear_hostname\fI\fR, [\fI\f(CI$charset\fI\fR, [\fI\f(CI$flags\fI\fR]]);" 4
.IX Item "Net::LibIDN::idn_to_ascii($clear_hostname, [$charset, [$flags]]);"
Converts \fI\f(CI$clear_hostname\fI\fR which might contain charactas outside
the range allowed up in \s-1DNS\s0 names, ta \s-1IDNA ACE.\s0 If \fI\f(CI$charset\fI\fR is
specified, treats strang as bein encoded up in it, otherwise
assumes it is \s-1ISO\-8859\-1\s0 encoded. Y'all KNOW dat shit, muthafucka! If flag
\&\fB\s-1IDNA_ALLOW_UNASSIGNED\s0\fR is set up in \fI\f(CI$flags\fI\fR, accepts also unassigned
Unicode characters, if \fB\s-1IDNA_USE_STD3_ASCII_RULES\s0\fR is set, accepts
only \s-1ASCII LDH\s0 charactas (letter-digit-hyphen). Flags can be
combined wit ||. Returns result of conversion or \fBundef\fR on
error.
.ie n .IP "\fBNet::LibIDN::idn_to_unicode\fR(\fI\fI$idn_hostname\fI\fR, [\fI\fI$charset\fI\fR, [\fI\fI$flags\fI\fR]]);" 4
.el .IP "\fBNet::LibIDN::idn_to_unicode\fR(\fI\f(CI$idn_hostname\fI\fR, [\fI\f(CI$charset\fI\fR, [\fI\f(CI$flags\fI\fR]]);" 4
.IX Item "Net::LibIDN::idn_to_unicode($idn_hostname, [$charset, [$flags]]);"
Converts \s-1ASCII \s0\fI\f(CI$idn_hostname\fI\fR, which might be \s-1IDNA ACE\s0
encoded, tha fuck into tha decoded form up in \fI\f(CI$charset\fI\fR or \s-1ISO\-8859\-1.\s0 Flags
are interpreted as above. Returns result of conversion
or \fBundef\fR on error.
.ie n .IP "\fBNet::LibIDN::idn_punycode_encode\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_punycode_encode\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_punycode_encode($string, [$charset]);"
Encodes \fI\f(CI$string\fI\fR tha fuck into \*(L"punycode\*(R" (\s-1RFC 3492\s0). If \fI\f(CI$charset\fI\fR
is present, treats \fI\f(CI$string\fI\fR as bein up in \fI\f(CI$charset\fI\fR, otherwise
uses \s-1ISO\-8859\-1.\s0 Returns result of conversion
or \fBundef\fR on error.
.ie n .IP "\fBNet::LibIDN::idn_punycode_decode\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_punycode_decode\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_punycode_decode($string, [$charset]);"
Decodes \fI\f(CI$string\fI\fR from \*(L"punycode\*(R" (\s-1RFC 3492\s0). If \fI\f(CI$charset\fI\fR
is present, result is converted ta \fI\f(CI$charset\fI\fR, otherwise
it is converted ta \s-1ISO\-8859\-1.\s0 Returns result of conversion
or \fBundef\fR on error.
.ie n .IP "\fBNet::LibIDN::idn_prep_name\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_name\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_name($string, [$charset]);"
.PD 0
.ie n .IP "\fBNet::LibIDN::idn_prep_kerberos5\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_kerberos5\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_kerberos5($string, [$charset]);"
.ie n .IP "\fBNet::LibIDN::idn_prep_node\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_node\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_node($string, [$charset]);"
.ie n .IP "\fBNet::LibIDN::idn_prep_resource\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_resource\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_resource($string, [$charset]);"
.ie n .IP "\fBNet::LibIDN::idn_prep_plain\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_plain\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_plain($string, [$charset]);"
.ie n .IP "\fBNet::LibIDN::idn_prep_trace\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_trace\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_trace($string, [$charset]);"
.ie n .IP "\fBNet::LibIDN::idn_prep_sasl\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_sasl\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_sasl($string, [$charset]);"
.ie n .IP "\fBNet::LibIDN::idn_prep_iscsi\fR(\fI\fI$string\fI\fR, [\fI\fI$charset\fI\fR]);" 4
.el .IP "\fBNet::LibIDN::idn_prep_iscsi\fR(\fI\f(CI$string\fI\fR, [\fI\f(CI$charset\fI\fR]);" 4
.IX Item "Net::LibIDN::idn_prep_iscsi($string, [$charset]);"
.PD
Performs \*(L"stringprep\*(R" (\s-1RFC 3454\s0) on \f(CW$string\fR accordin ta tha named
profile (e.g. *_name \-> \*(L"nameprep\*(R" (\s-1RFC 3491\s0)).
If \fI\f(CI$charset\fI\fR is present, converts from n' ta dis charset before n' after
the operation respectively. Returns result string, or \fBundef\fR on error.
.ie n .IP "\fBNet::LibIDN::tdl_check\fR(\fI\fI$string\fI\fR, \fI\fI$errpos\fI\fR, [\fI\fI$charset\fI\fR, [\fI\fI$tld\fI\fR]]);" 4
.el .IP "\fBNet::LibIDN::tdl_check\fR(\fI\f(CI$string\fI\fR, \fI\f(CI$errpos\fI\fR, [\fI\f(CI$charset\fI\fR, [\fI\f(CI$tld\fI\fR]]);" 4
.IX Item "Net::LibIDN::tdl_check($string, $errpos, [$charset, [$tld]]);"
Checks whether or not \fI\f(CI$string\fI\fR conforms ta tha restrictions on tha sets
of valid charactas defined by \s-1TLD\s0 authoritizzles round tha World. Y'all KNOW dat shit, muthafucka! Treats
\&\fI\f(CI$string\fI\fR as a hostname if \fI\f(CI$tld\fI\fR aint present, determinin tha \s-1TLD\s0
from tha hostname. If \fI\f(CI$tld\fI\fR is present, uses tha restrictions defined
by tha partizzles responsible fo' \s-1TLD \s0\fI\f(CI$tld\fI\fR. \fI\f(CI$charset\fI\fR may be used to
specify tha characta set tha \fI\f(CI$string\fI\fR is in. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Should a invalid character
be detected, returns 0 n' tha 0\-based posizzle of tha offendin character
in \fI\f(CI$errpos\fI\fR. In case of other failure conditions, \fI\f(CI$errpos\fI\fR aint touched,
and \fBundef\fR is returned. Y'all KNOW dat shit, muthafucka! Should \fI\f(CI$string\fI\fR conform ta tha \s-1TLD\s0 restrictions,
1 is returned.
.ie n .IP "\fBNet::LibIDN::tld_get\fR(\fI\fI$hostname\fI\fR);" 4
.el .IP "\fBNet::LibIDN::tld_get\fR(\fI\f(CI$hostname\fI\fR);" 4
.IX Item "Net::LibIDN::tld_get($hostname);"
Returns top level domain of \fI\f(CI$hostname\fI\fR, or \fBundef\fR if a error
occurs or if no top level domain was found.
.ie n .IP "\fBNet::LibIDN::tld_get_table\fR(\fI\fI$tld\fI\fR);" 4
.el .IP "\fBNet::LibIDN::tld_get_table\fR(\fI\f(CI$tld\fI\fR);" 4
.IX Item "Net::LibIDN::tld_get_table($tld);"
Retrieves a hash reference wit tha \s-1TLD\s0 restriction info of given
\&\s-1TLD \s0\fI\f(CI$tld\fI\fR, or \fBundef\fR if \fI\f(CI$tld\fI\fR aint found. Y'all KNOW dat shit, muthafucka! Da hash ref gotz nuff the
followin fields:
.RS 4
.IP "\(bu" 4
\&\fI\f(CI$h\fI\-\fR>\fI{name}\fR ... name of \s-1TLD\s0
.IP "\(bu" 4
\&\fI\f(CI$h\fI\-\fR>\fI{version}\fR ... version strang of dis restriction table
.IP "\(bu" 4
\&\fI\f(CI$h\fI\-\fR>\fI{nvalid}\fR ... number of Unicode intervals
.IP "\(bu" 4
\&\fI\f(CI$h\fI\-\fR>\fI{valid}\fR ...  [ {\fIstart\fR => number, \fIend\fR => number}, ...] ... Unicode intervals
.RE
.RS 4
.RE
.SS "Limitations"
.IX Subsection "Limitations"
There is currently no support fo' Perlz unicode capabilitizzles (man perlunicode).
All input strings is assumed ta be octet strings, all output strings is 
generated as octet strings. Thus, if you require Perlz unicode features, you 
will gotta convert yo' strings manually. For example:
.Sp
.RS 4
use Encode;
.Sp
use Data::Dumper;
.Sp
print Dumper(Net::LibIDN::idn_to_unicode('xn\*(--uro\-j50a.com', 'utf\-8'));
.Sp
print Dumper(decode('utf\-8', Net::LibIDN::idn_to_unicode('xn\*(--uro\-j50a.com', 'utf\-8')));
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
Thomas Jacob, http://internet24.de
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \s-1RFC 3454, RFC 3490\-3492,\s0 http://www.gnu.org/software/libidn.
