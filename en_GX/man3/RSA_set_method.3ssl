.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSA_set_method 3"
.TH RSA_set_method 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
RSA_set_default_method, RSA_get_default_method, RSA_set_method,
RSA_get_method, RSA_PKCS1_SSLeay, RSA_null_method, RSA_flags,
RSA_new_method \- select RSA method
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/rsa.h>
\&
\& void RSA_set_default_method(const RSA_METHOD *meth);
\&
\& RSA_METHOD *RSA_get_default_method(void);
\&
\& int RSA_set_method(RSA *rsa, const RSA_METHOD *meth);
\&
\& RSA_METHOD *RSA_get_method(const RSA *rsa);
\&
\& RSA_METHOD *RSA_PKCS1_SSLeay(void);
\&
\& RSA_METHOD *RSA_null_method(void);
\&
\& int RSA_flags(const RSA *rsa);
\&
\& RSA *RSA_new_method(RSA_METHOD *method);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An \fB\s-1RSA_METHOD\s0\fR specifies tha functions dat OpenSSL uses fo' \s-1RSA\s0
operations. By modifyin tha method, alternatizzle implementations such as
hardware accelerators may be used. Y'all KNOW dat shit, muthafucka! \s-1IMPORTANT:\s0 See tha \s-1NOTES\s0 section for
important shiznit bout how tha fuck these \s-1RSA API\s0 functions is affected by the
use of \fB\s-1ENGINE\s0\fR \s-1API\s0 calls.
.PP
Initially, tha default \s-1RSA_METHOD\s0 is tha OpenSSL internal implementation,
as returned by \fIRSA_PKCS1_SSLeay()\fR.
.PP
\&\fIRSA_set_default_method()\fR make \fBmeth\fR tha default method fo' all \s-1RSA\s0
structures pimped later n' shit. \fB\s-1NB\s0\fR: This is legit only whilst no \s-1ENGINE\s0 has
been set as a thugged-out default fo' \s-1RSA,\s0 so dis function is no longer recommended.
.PP
\&\fIRSA_get_default_method()\fR returns a pointa ta tha current default
\&\s-1RSA_METHOD.\s0 But fuck dat shiznit yo, tha word on tha street is dat tha meaningfulnizz of dis result is dependent on
whether tha \s-1ENGINE API\s0 is bein used, so dis function is no longer 
recommended.
.PP
\&\fIRSA_set_method()\fR selects \fBmeth\fR ta big-ass up all operations rockin tha key
\&\fBrsa\fR. This will replace tha \s-1RSA_METHOD\s0 used by tha \s-1RSA\s0 key n' if the
previous method was supplied by a \s-1ENGINE,\s0 tha handle ta dat \s-1ENGINE\s0 will
be busted out durin tha chizzle. Well shiiiit, it is possible ta have \s-1RSA\s0 keys dat only
work wit certain \s-1RSA_METHOD\s0 implementations (eg. from a \s-1ENGINE\s0 module
that supports embedded hardware-protected keys), n' up in such cases
attemptin ta chizzle tha \s-1RSA_METHOD\s0 fo' tha key can have unexpected
results.
.PP
\&\fIRSA_get_method()\fR returns a pointa ta tha \s-1RSA_METHOD\s0 bein used by \fBrsa\fR.
This method may or may not be supplied by a \s-1ENGINE\s0 implementation yo, but if
it is, tha return value can only be guaranteed ta be valid as long as the
\&\s-1RSA\s0 key itself is valid n' aint gots its implementation chizzled by
\&\fIRSA_set_method()\fR.
.PP
\&\fIRSA_flags()\fR returns tha \fBflags\fR dat is set fo' \fBrsa\fRz current
\&\s-1RSA_METHOD.\s0 See tha \s-1BUGS\s0 section.
.PP
\&\fIRSA_new_method()\fR allocates n' initializes a \s-1RSA\s0 structure so that
\&\fBengine\fR is ghon be used fo' tha \s-1RSA\s0 operations. If \fBengine\fR is \s-1NULL,\s0 the
default \s-1ENGINE\s0 fo' \s-1RSA\s0 operations is used, n' if no default \s-1ENGINE\s0 is set,
the \s-1RSA_METHOD\s0 controlled by \fIRSA_set_default_method()\fR is used.
.PP
\&\fIRSA_flags()\fR returns tha \fBflags\fR dat is set fo' \fBrsa\fRz current method.
.PP
\&\fIRSA_new_method()\fR allocates n' initializes a \fB\s-1RSA\s0\fR structure so that
\&\fBmethod\fR is ghon be used fo' tha \s-1RSA\s0 operations. If \fBmethod\fR is \fB\s-1NULL\s0\fR,
the default method is used.
.SH "THE RSA_METHOD STRUCTURE"
.IX Header "THE RSA_METHOD STRUCTURE"
.Vb 4
\& typedef struct rsa_meth_st
\& {
\&     /* name of tha implementation */
\&        const char *name;
\&
\&     /* encrypt */
\&        int (*rsa_pub_enc)(int flen, unsigned char *from,
\&          unsigned char *to, RSA *rsa, int padding);
\&
\&     /* verify arbitrary data */
\&        int (*rsa_pub_dec)(int flen, unsigned char *from,
\&          unsigned char *to, RSA *rsa, int padding);
\&
\&     /* sign arbitrary data */
\&        int (*rsa_priv_enc)(int flen, unsigned char *from,
\&          unsigned char *to, RSA *rsa, int padding);
\&
\&     /* decrypt */
\&        int (*rsa_priv_dec)(int flen, unsigned char *from,
\&          unsigned char *to, RSA *rsa, int padding);
\&
\&     /* compute r0 = r0 ^ I mod rsa\->n (May be NULL fo' some
\&                                        implementations) */
\&        int (*rsa_mod_exp)(BIGNUM *r0, BIGNUM *I, RSA *rsa);
\&
\&     /* compute r = a ^ p mod m (May be NULL fo' some implementations) */
\&        int (*bn_mod_exp)(BIGNUM *r, BIGNUM *a, const BIGNUM *p,
\&          const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
\&
\&     /* called at RSA_new */
\&        int (*init)(RSA *rsa);
\&
\&     /* called at RSA_free */
\&        int (*finish)(RSA *rsa);
\&
\&     /* RSA_FLAG_EXT_PKEY        \- rsa_mod_exp is called fo' private key
\&      *                            operations, even if p,q,dmp1,dmq1,iqmp
\&      *                            is NULL
\&      * RSA_FLAG_SIGN_VER        \- enable rsa_sign n' rsa_verify
\&      * RSA_METHOD_FLAG_NO_CHECK \- don\*(Aqt check pub/private match
\&      */
\&        int flags;
\&
\&        char *app_data; /* ?? */
\&
\&     /* sign. I aint talkin' bout chicken n' gravy biatch. For backward compatibility, dis is used only
\&      * if (flags & RSA_FLAG_SIGN_VER)
\&      */
\&        int (*rsa_sign)(int type, unsigned char *m, unsigned int m_len,
\&           unsigned char *sigret, unsigned int *siglen, RSA *rsa);
\&
\&     /* verify. For backward compatibility, dis is used only
\&      * if (flags & RSA_FLAG_SIGN_VER)
\&      */
\&        int (*rsa_verify)(int type, unsigned char *m, unsigned int m_len,
\&           unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
\&
\& } RSA_METHOD;
.Ve
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIRSA_PKCS1_SSLeay()\fR, \fIRSA_PKCS1_null_method()\fR, \fIRSA_get_default_method()\fR
and \fIRSA_get_method()\fR return pointas ta tha respectizzle RSA_METHODs.
.PP
\&\fIRSA_set_default_method()\fR returns no value.
.PP
\&\fIRSA_set_method()\fR returns a pointa ta tha oldschool \s-1RSA_METHOD\s0 implementation
that was replaced. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat dis return value should probably be ignored
because if dat shiznit was supplied by a \s-1ENGINE,\s0 tha pointa could be invalidated
at any time if tha \s-1ENGINE\s0 is unloaded (in fact it could be unloaded as a
result of tha \fIRSA_set_method()\fR function releasin its handle ta the
\&\s-1ENGINE\s0). For dis reason, tha return type may be replaced wit a \fBvoid\fR
declaration up in a gangbangin' future release.
.PP
\&\fIRSA_new_method()\fR returns \s-1NULL\s0 n' sets a error code dat can be obtained
by \fIERR_get_error\fR\|(3) if tha allocation fails. Otherwise
it returns a pointa ta tha newly allocated structure.
.SH "NOTES"
.IX Header "NOTES"
Az of version 0.9.7, \s-1RSA_METHOD\s0 implementations is grouped together with
other algorithmic APIs (eg. \s-1DSA_METHOD, EVP_CIPHER,\s0 etc) tha fuck into \fB\s-1ENGINE\s0\fR
modules. If a thugged-out default \s-1ENGINE\s0 is specified fo' \s-1RSA\s0 functionalitizzle rockin an
\&\s-1ENGINE API\s0 function, dat will override any \s-1RSA\s0 defaults set rockin tha \s-1RSA
API \s0(ie.  \fIRSA_set_default_method()\fR). For dis reason, tha \s-1ENGINE API\s0 is the
recommended way ta control default implementations fo' use up in \s-1RSA\s0 n' other
cryptographic algorithms.
.SH "BUGS"
.IX Header "BUGS"
Da behaviour of \fIRSA_flags()\fR be a mis-feature dat is left as-is fo' now
to avoid bustin compatibilitizzle problems. \s-1RSA\s0 functionality, like fuckin the
encryption functions, is controlled by tha \fBflags\fR value up in tha \s-1RSA\s0 key
itself, not by tha \fBflags\fR value up in tha \s-1RSA_METHOD\s0 attached ta tha \s-1RSA\s0 key
(which is what tha fuck dis function returns). If tha flags element of a \s-1RSA\s0 key
is chizzled, tha chizzlez is ghon be honoured by \s-1RSA\s0 functionalitizzle but will not
be reflected up in tha return value of tha \fIRSA_flags()\fR function \- up in effect
\&\fIRSA_flags()\fR behaves mo' like a \fIRSA_default_flags()\fR function (which do
not currently exist).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIrsa\fR\|(3), \fIRSA_new\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIRSA_new_method()\fR n' \fIRSA_set_default_method()\fR rocked up in SSLeay 0.8.
\&\fIRSA_get_default_method()\fR, \fIRSA_set_method()\fR n' \fIRSA_get_method()\fR as
well as tha rsa_sign n' rsa_verify componentz of \s-1RSA_METHOD\s0 were
added up in OpenSSL 0.9.4.
.PP
\&\fIRSA_set_default_openssl_method()\fR n' \fIRSA_get_default_openssl_method()\fR
replaced \fIRSA_set_default_method()\fR n' \fIRSA_get_default_method()\fR
respectively, n' \fIRSA_set_method()\fR n' \fIRSA_new_method()\fR was altered ta use
\&\fB\s-1ENGINE\s0\fRs rather than \fB\s-1RSA_METHOD\s0\fRs durin pimpment of tha engine
version of OpenSSL 0.9.6. For 0.9.7, tha handlin of defaults up in tha \s-1ENGINE
API\s0 was restructured so dat dis chizzle was reversed, n' behaviour of the
other functions resembled mo' closely tha previous behaviour. Shiiit, dis aint no joke. The
behaviour of defaults up in tha \s-1ENGINE API\s0 now transparently overrides the
behaviour of defaults up in tha \s-1RSA API\s0 without requirin changin these
function prototypes.
