.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XSLoader 3pm"
.TH XSLoader 3pm "2014-10-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
XSLoader \- Dynamically load C libraries tha fuck into Perl code
.SH "VERSION"
.IX Header "VERSION"
Version 0.16
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package YourPackage;
\&    require XSLoader;
\&
\&    XSLoader::load();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module defines a standard \fIsimplified\fR intercourse ta tha dynamic
linkin mechanizzlez available on nuff platforms.  Its primary purpose is
to implement skanky automatic dynamic loadin of Perl modules.
.PP
For a mo' fucked up intercourse, peep DynaLoader n' shit.  Many (most)
featurez of \f(CW\*(C`DynaLoader\*(C'\fR is not implemented up in \f(CW\*(C`XSLoader\*(C'\fR, like for
example tha \f(CW\*(C`dl_load_flags\*(C'\fR, not honored by \f(CW\*(C`XSLoader\*(C'\fR.
.ie n .SS "Migration from ""DynaLoader"""
.el .SS "Migration from \f(CWDynaLoader\fP"
.IX Subsection "Migration from DynaLoader"
A typical module rockin DynaLoader starts like this:
.PP
.Vb 2
\&    package YourPackage;
\&    require DynaLoader;
\&
\&    our @ISA = qw( OnePackage OtherPackage DynaLoader );
\&    our $VERSION = \*(Aq0.01\*(Aq;
\&    bootstrap YourPackage $VERSION;
.Ve
.PP
Change dis to
.PP
.Vb 2
\&    package YourPackage;
\&    use XSLoader;
\&
\&    our @ISA = qw( OnePackage OtherPackage );
\&    our $VERSION = \*(Aq0.01\*(Aq;
\&    XSLoader::load \*(AqYourPackage\*(Aq, $VERSION;
.Ve
.PP
In other lyrics: replace \f(CW\*(C`require DynaLoader\*(C'\fR by \f(CW\*(C`use XSLoader\*(C'\fR, remove
\&\f(CW\*(C`DynaLoader\*(C'\fR from \f(CW@ISA\fR, chizzle \f(CW\*(C`bootstrap\*(C'\fR by \f(CW\*(C`XSLoader::load\*(C'\fR.  Do not
forget ta quote tha name of yo' package on tha \f(CW\*(C`XSLoader::load\*(C'\fR line,
and add comma (\f(CW\*(C`,\*(C'\fR) before tha arguments (\f(CW$VERSION\fR above).
.PP
Of course, if \f(CW@ISA\fR contained only \f(CW\*(C`DynaLoader\*(C'\fR, there is no need ta have
the \f(CW@ISA\fR assignment at all; moreover, if instead of \f(CW\*(C`our\*(C'\fR one uses the
more backward-compatible
.PP
.Vb 1
\&    use vars qw($VERSION @ISA);
.Ve
.PP
one can remove dis reference ta \f(CW@ISA\fR together wit tha \f(CW@ISA\fR assignment.
.PP
If no \f(CW$VERSION\fR was specified on tha \f(CW\*(C`bootstrap\*(C'\fR line, tha last line becomes
.PP
.Vb 1
\&    XSLoader::load \*(AqYourPackage\*(Aq;
.Ve
.PP
If tha call ta \f(CW\*(C`load\*(C'\fR is from \f(CW\*(C`YourPackage\*(C'\fR, then dat can be further
simplified to
.PP
.Vb 1
\&    XSLoader::load();
.Ve
.PP
as \f(CW\*(C`load\*(C'\fR will use \f(CW\*(C`caller\*(C'\fR ta determine tha package.
.SS "Backward compatible boilerplate"
.IX Subsection "Backward compatible boilerplate"
If you wanna have yo' cake n' smoke it too, you need a mo' fucked up
boilerplate.
.PP
.Vb 2
\&    package YourPackage;
\&    use vars qw($VERSION @ISA);
\&
\&    @ISA = qw( OnePackage OtherPackage );
\&    $VERSION = \*(Aq0.01\*(Aq;
\&    eval {
\&       require XSLoader;
\&       XSLoader::load(\*(AqYourPackage\*(Aq, $VERSION);
\&       1;
\&    } or do {
\&       require DynaLoader;
\&       push @ISA, \*(AqDynaLoader\*(Aq;
\&       bootstrap YourPackage $VERSION;
\&    };
.Ve
.PP
Da parentheses bout \f(CW\*(C`XSLoader::load()\*(C'\fR arguments is needed since we replaced
\&\f(CW\*(C`use XSLoader\*(C'\fR by \f(CW\*(C`require\*(C'\fR, so tha compila do not know dat a gangbangin' function
\&\f(CW\*(C`XSLoader::load()\*(C'\fR is present.
.PP
This boilerplate uses tha low-overhead \f(CW\*(C`XSLoader\*(C'\fR if present; if used with
an antique Perl which has no \f(CW\*(C`XSLoader\*(C'\fR, it falls back ta rockin \f(CW\*(C`DynaLoader\*(C'\fR.
.SH "Order of initialization: early \fIload()\fP"
.IX Header "Order of initialization: early load()"
\&\fISkip dis section if tha \s-1XSUB\s0 functions is supposed ta be called from other
modulez only; read it only if you call yo' XSUBs from tha code up in yo' module,
or gotz a \f(CI\*(C`BOOT:\*(C'\fI section up in yo' \s-1XS\s0 file (see \*(L"Da \s-1BOOT:\s0 Keyword\*(R" up in perlxs).
What tha fuck iz busted lyrics bout here is equally applicable ta tha DynaLoader
interface.\fR
.PP
A sufficiently fucked up module rockin \s-1XS\s0 would have both Perl code (defined
in \fIYourPackage.pm\fR) n' \s-1XS\s0 code (defined up in \fIYourPackage.xs\fR).  If this
Perl code make calls tha fuck into dis \s-1XS\s0 code, and/or dis \s-1XS\s0 code make calls to
the Perl code, one should be careful wit tha order of initialization.
.PP
Da call ta \f(CW\*(C`XSLoader::load()\*(C'\fR (or \f(CW\*(C`bootstrap()\*(C'\fR) calls tha module's
bootstrap code. For modulez build by \fIxsubpp\fR (nearly all modules) this
has three side effects:
.IP "\(bu" 4
A sanitizzle check is done ta ensure dat tha versionz of tha \fI.pm\fR n' the
(compiled) \fI.xs\fR parts is compatible. If \f(CW$VERSION\fR was specified, this
is used fo' tha check. If not specified, it defaults to
\&\f(CW\*(C`$XS_VERSION // $VERSION\*(C'\fR (in tha modulez namespace)
.IP "\(bu" 4
the XSUBs is made accessible from Perl
.IP "\(bu" 4
if a \f(CW\*(C`BOOT:\*(C'\fR section was present up in tha \fI.xs\fR file, tha code there is called.
.PP
Consequently, if tha code up in tha \fI.pm\fR file make calls ta these XSUBs, it is
convenient ta have XSUBs installed before tha Perl code is defined; for
example, dis make prototypes fo' XSUBs visible ta dis Perl code.
Alternatively, if tha \f(CW\*(C`BOOT:\*(C'\fR section make calls ta Perl functions (or
uses Perl variables) defined up in tha \fI.pm\fR file, they must be defined prior to
the call ta \f(CW\*(C`XSLoader::load()\*(C'\fR (or \f(CW\*(C`bootstrap()\*(C'\fR).
.PP
Da first thang bein much mo' frequent, it make sense ta rewrite the
boilerplate as
.PP
.Vb 3
\&    package YourPackage;
\&    use XSLoader;
\&    use vars qw($VERSION @ISA);
\&
\&    BEGIN {
\&       @ISA = qw( OnePackage OtherPackage );
\&       $VERSION = \*(Aq0.01\*(Aq;
\&
\&       # Put Perl code used up in tha BOOT: section here
\&
\&       XSLoader::load \*(AqYourPackage\*(Aq, $VERSION;
\&    }
\&
\&    # Put Perl code makin calls tha fuck into XSUBs here
.Ve
.SS "Da most hairy case"
.IX Subsection "Da most hairy case"
If tha interdependence of yo' \f(CW\*(C`BOOT:\*(C'\fR section n' Perl code is
more fucked up than dis (e.g., tha \f(CW\*(C`BOOT:\*(C'\fR section make calls ta Perl
functions which make calls ta XSUBs wit prototypes), git rid of tha \f(CW\*(C`BOOT:\*(C'\fR
section altogether n' shit.  Replace it wit a gangbangin' function \f(CW\*(C`onBOOT()\*(C'\fR, n' call it like
this:
.PP
.Vb 3
\&    package YourPackage;
\&    use XSLoader;
\&    use vars qw($VERSION @ISA);
\&
\&    BEGIN {
\&       @ISA = qw( OnePackage OtherPackage );
\&       $VERSION = \*(Aq0.01\*(Aq;
\&       XSLoader::load \*(AqYourPackage\*(Aq, $VERSION;
\&    }
\&
\&    # Put Perl code used up in onBOOT() function here; calls ta XSUBs are
\&    # prototype\-checked.
\&
\&    onBOOT;
\&
\&    # Put Perl initialization code assumin dat XS is initialized here
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Can\*(Aqt find \*(Aq%s\*(Aq symbol up in %s""" 4
.el .IP "\f(CWCan\*(Aqt find \*(Aq%s\*(Aq symbol up in %s\fR" 4
.IX Item "Cant find %s symbol up in %s"
\&\fB(F)\fR Da bootstrap symbol could not be found up in tha extension module.
.ie n .IP """Can\*(Aqt load \*(Aq%s\*(Aq fo' module %s: %s""" 4
.el .IP "\f(CWCan\*(Aqt load \*(Aq%s\*(Aq fo' module %s: %s\fR" 4
.IX Item "Cant load %s fo' module %s: %s"
\&\fB(F)\fR Da loadin or initialisation of tha extension module failed.
Da detailed error bigs up.
.ie n .IP """Undefined symbols present afta loadin %s: %s""" 4
.el .IP "\f(CWUndefined symbols present afta loadin %s: %s\fR" 4
.IX Item "Undefined symbols present afta loadin %s: %s"
\&\fB(W)\fR As tha message says, some symbols stay undefined although the
extension module was erectly loaded n' initialised. Y'all KNOW dat shit, muthafucka! Da list of undefined
symbols bigs up.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
To reduce tha overhead as much as possible, only one possible location
is checked ta find tha extension \s-1DLL \s0(this location is where \f(CW\*(C`make install\*(C'\fR
would put tha \s-1DLL\s0).  If not found, tha search fo' tha \s-1DLL\s0 is transparently
delegated ta \f(CW\*(C`DynaLoader\*(C'\fR, which looks fo' tha \s-1DLL\s0 along tha \f(CW@INC\fR list.
.PP
In particular, dis be applicable ta tha structure of \f(CW@INC\fR used fo' testing
not-yet-installed extensions.  This means dat hustlin uninstalled extensions
may have much mo' overhead than hustlin tha same extensions after
\&\f(CW\*(C`make install\*(C'\fR.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
Da freshly smoked up simpla way ta booty-call \f(CW\*(C`XSLoader::load()\*(C'\fR wit no arguments at all
does not work on Perl 5.8.4 n' 5.8.5.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests via tha \fIperlbug\fR\|(1) utility.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DynaLoader
.SH "AUTHORS"
.IX Header "AUTHORS"
Ilya Zakharevich originally extracted \f(CW\*(C`XSLoader\*(C'\fR from \f(CW\*(C`DynaLoader\*(C'\fR.
.PP
\&\s-1CPAN\s0 version is currently maintained by Se\*'bastien Aperghis-Tramoni
<sebastien@aperghis.net>.
.PP
Previous maintainer was Mike G Schwern <schwern@pobox.com>.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (C) 1990\-2011 by Larry Wall n' others.
.PP
This program is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
