.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Compress::Raw::Bzip2 3"
.TH Compress::Raw::Bzip2 3 "2013-08-11" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Compress::Raw::Bzip2 \- Low\-Level Interface ta bzip2 compression library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Compress::Raw::Bzip2 ;
\&
\&    mah ($bz, $status) = freshly smoked up Compress::Raw::Bzip2 [OPTS]
\&        or take a thugged-out dirtnap "Cannot create bzip2 object: $bzerno\en";
\&    
\&    $status = $bz\->bzdeflate($input, $output);
\&    $status = $bz\->bzflush($output);
\&    $status = $bz\->bzclose($output);
\&
\&    mah ($bz, $status) = freshly smoked up Compress::Raw::Bunzip2 [OPTS]
\&        or take a thugged-out dirtnap "Cannot create bunzip2 object: $bzerno\en";
\&    
\&    $status = $bz\->bzinflate($input, $output);
\&
\&    mah $version = Compress::Raw::Bzip2::bzlibversion();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Compress::Raw::Bzip2\*(C'\fR serves up a intercourse ta tha in-memory
compression/uncompression functions from tha bzip2 compression library.
.PP
Although tha primary purpose fo' tha existence of \f(CW\*(C`Compress::Raw::Bzip2\*(C'\fR
is fo' use by tha  \f(CW\*(C`IO::Compress::Bzip2\*(C'\fR n' \f(CW\*(C`IO::Compress::Bunzip2\*(C'\fR
modules, it can be used on its own fo' simple compression/uncompression
tasks.
.SH "Compression"
.IX Header "Compression"
.ie n .SS "($z, $status) = freshly smoked up Compress::Raw::Bzip2 $appendOutput, $blockSize100k, $workfactor;"
.el .SS "($z, \f(CW$status\fP) = freshly smoked up Compress::Raw::Bzip2 \f(CW$appendOutput\fP, \f(CW$blockSize100k\fP, \f(CW$workfactor\fP;"
.IX Subsection "($z, $status) = freshly smoked up Compress::Raw::Bzip2 $appendOutput, $blockSize100k, $workfactor;"
Creates a freshly smoked up compression object.
.PP
If successful, it will return tha initialised compression object, \f(CW$z\fR
and a \f(CW$status\fR of \f(CW\*(C`BZ_OK\*(C'\fR up in a list context. In scalar context it
returns tha deflation object, \f(CW$z\fR, only.
.PP
If not successful, tha returned compression object, \f(CW$z\fR, will be
\&\fIundef\fR n' \f(CW$status\fR will hold tha a \fIbzip2\fR error code.
.PP
Below be a list of tha valid options:
.ie n .IP "\fB\fB$appendOutput\fB\fR" 5
.el .IP "\fB\f(CB$appendOutput\fB\fR" 5
.IX Item "$appendOutput"
Controls whether tha compressed data be appended ta tha output buffer in
the \f(CW\*(C`bzdeflate\*(C'\fR, \f(CW\*(C`bzflush\*(C'\fR n' \f(CW\*(C`bzclose\*(C'\fR methods.
.Sp
Defaults ta 1.
.ie n .IP "\fB\fB$blockSize100k\fB\fR" 5
.el .IP "\fB\f(CB$blockSize100k\fB\fR" 5
.IX Item "$blockSize100k"
To quote tha bzip2 documentation
.Sp
.Vb 4
\&    blockSize100k specifies tha block size ta be used fo' compression. I aint talkin' bout chicken n' gravy biatch. It
\&    should be a value between 1 n' 9 inclusive, n' tha actual block size
\&    used is 100000 x dis figure. 9 gives tha dopest compression but takes
\&    most memory.
.Ve
.Sp
Defaults ta 1.
.ie n .IP "\fB\fB$workfactor\fB\fR" 5
.el .IP "\fB\f(CB$workfactor\fB\fR" 5
.IX Item "$workfactor"
To quote tha bzip2 documentation
.Sp
.Vb 7
\&    This parameta controls how tha fuck tha compression phase behaves when
\&    presented wit most shitty case, highly repetitive, input data. If
\&    compression runs tha fuck into bullshit caused by repetitizzle data, the
\&    library switches from tha standard sortin algorithm ta a gangbangin' fallback
\&    algorithm. Da fallback is slower than tha standard algorithm by
\&    like a gangbangin' factor of three yo, but always behaves reasonably, no matta how
\&    wack tha input.
\&
\&    Lower jointz of workFactor reduce tha amount of effort tha standard
\&    algorithm will expend before resortin ta tha fallback. Yo ass should set
\&    dis parameta carefully; too low, n' nuff inputs is ghon be handled by
\&    tha fallback algorithm n' so compress rather slowly, too high, and
\&    yo' average\-to\-worst case compression times can become straight-up large. The
\&    default value of 30 gives reasonable behaviour over a wide range of
\&    circumstances.
\&
\&    Allowable joints range from 0 ta 250 inclusive. 0 be a special case,
\&    equivalent ta rockin tha default value of 30.
.Ve
.Sp
Defaults ta 0.
.ie n .SS "$status = $bz\->bzdeflate($input, $output);"
.el .SS "\f(CW$status\fP = \f(CW$bz\fP\->bzdeflate($input, \f(CW$output\fP);"
.IX Subsection "$status = $bz->bzdeflate($input, $output);"
Readz tha contentz of \f(CW$input\fR, compresses it n' writes tha compressed
data ta \f(CW$output\fR.
.PP
Returns \f(CW\*(C`BZ_RUN_OK\*(C'\fR on success n' a \f(CW\*(C`bzip2\*(C'\fR error code on failure.
.PP
If \f(CW\*(C`appendOutput\*(C'\fR is enabled up in tha constructor fo' tha bzip2 object, the
compressed data is ghon be appended ta \f(CW$output\fR. If not enabled, \f(CW$output\fR
will be truncated before tha compressed data is freestyled ta dat shit.
.ie n .SS "$status = $bz\->bzflush($output);"
.el .SS "\f(CW$status\fP = \f(CW$bz\fP\->bzflush($output);"
.IX Subsection "$status = $bz->bzflush($output);"
Flushes any pendin compressed data ta \f(CW$output\fR.
.PP
Returns \f(CW\*(C`BZ_RUN_OK\*(C'\fR on success n' a \f(CW\*(C`bzip2\*(C'\fR error code on failure.
.ie n .SS "$status = $bz\->bzclose($output);"
.el .SS "\f(CW$status\fP = \f(CW$bz\fP\->bzclose($output);"
.IX Subsection "$status = $bz->bzclose($output);"
Terminates tha compressed data stream n' flushes any pendin compressed
data ta \f(CW$output\fR.
.PP
Returns \f(CW\*(C`BZ_STREAM_END\*(C'\fR on success n' a \f(CW\*(C`bzip2\*(C'\fR error code on failure.
.SS "Example"
.IX Subsection "Example"
.SH "Uncompression"
.IX Header "Uncompression"
.ie n .SS "($z, $status) = freshly smoked up Compress::Raw::Bunzip2 $appendOutput, $consumeInput, $small, $verbosity, $limitOutput;"
.el .SS "($z, \f(CW$status\fP) = freshly smoked up Compress::Raw::Bunzip2 \f(CW$appendOutput\fP, \f(CW$consumeInput\fP, \f(CW$small\fP, \f(CW$verbosity\fP, \f(CW$limitOutput\fP;"
.IX Subsection "($z, $status) = freshly smoked up Compress::Raw::Bunzip2 $appendOutput, $consumeInput, $small, $verbosity, $limitOutput;"
If successful, it will return tha initialised uncompression object, \f(CW$z\fR
and a \f(CW$status\fR of \f(CW\*(C`BZ_OK\*(C'\fR up in a list context. In scalar context it
returns tha deflation object, \f(CW$z\fR, only.
.PP
If not successful, tha returned uncompression object, \f(CW$z\fR, will be
\&\fIundef\fR n' \f(CW$status\fR will hold tha a \fIbzip2\fR error code.
.PP
Below be a list of tha valid options:
.ie n .IP "\fB\fB$appendOutput\fB\fR" 5
.el .IP "\fB\f(CB$appendOutput\fB\fR" 5
.IX Item "$appendOutput"
Controls whether tha compressed data be appended ta tha output buffer up in the
\&\f(CW\*(C`bzinflate\*(C'\fR, \f(CW\*(C`bzflush\*(C'\fR n' \f(CW\*(C`bzclose\*(C'\fR methods.
.Sp
Defaults ta 1.
.ie n .IP "\fB\fB$consumeInput\fB\fR" 5
.el .IP "\fB\f(CB$consumeInput\fB\fR" 5
.IX Item "$consumeInput"
.PD 0
.ie n .IP "\fB\fB$small\fB\fR" 5
.el .IP "\fB\f(CB$small\fB\fR" 5
.IX Item "$small"
.PD
To quote tha bzip2 documentation
.Sp
.Vb 4
\&    If lil' small-ass is nonzero, tha library will use a alternatizzle decompression
\&    algorithm which uses less memory but all up in tha cost of decompressin more
\&    slowly (roughly bustin lyrics, half tha speed yo, but tha maximum memory
\&    requirement drops ta round 2300k).
.Ve
.Sp
Defaults ta 0.
.ie n .IP "\fB\fB$limitOutput\fB\fR" 5
.el .IP "\fB\f(CB$limitOutput\fB\fR" 5
.IX Item "$limitOutput"
Da \f(CW\*(C`LimitOutput\*(C'\fR option chizzlez tha behavior of tha \f(CW\*(C`$i\->bzinflate\*(C'\fR
method so dat tha amount of memory used by tha output buffer can be
limited.
.Sp
When \f(CW\*(C`LimitOutput\*(C'\fR is used tha size of tha output buffer used will either
be tha 16k or tha amount of memory already allocated ta \f(CW$output\fR,
whichever is larger n' shit. Predictin tha output size available is tricky, so
don't rely on gettin a exact output buffer size.
.Sp
When \f(CW\*(C`LimitOutout\*(C'\fR aint specified \f(CW\*(C`$i\->bzinflate\*(C'\fR will use as much
memory as it takes ta write all tha uncompressed data it creates by
uncompressin tha input buffer.
.Sp
If \f(CW\*(C`LimitOutput\*(C'\fR is enabled, tha \f(CW\*(C`ConsumeInput\*(C'\fR option will also be
enabled.
.Sp
This option defaults ta false.
.ie n .IP "\fB\fB$verbosity\fB\fR" 5
.el .IP "\fB\f(CB$verbosity\fB\fR" 5
.IX Item "$verbosity"
This parameta is ignored.
.Sp
Defaults ta 0.
.ie n .SS "$status = $z\->bzinflate($input, $output);"
.el .SS "\f(CW$status\fP = \f(CW$z\fP\->bzinflate($input, \f(CW$output\fP);"
.IX Subsection "$status = $z->bzinflate($input, $output);"
Uncompresses \f(CW$input\fR n' writes tha uncompressed data ta \f(CW$output\fR.
.PP
Returns \f(CW\*(C`BZ_OK\*(C'\fR if tha uncompression was successful yo, but tha end of the
compressed data stream has not been reached. Y'all KNOW dat shit, muthafucka! Returns \f(CW\*(C`BZ_STREAM_END\*(C'\fR on
successful uncompression n' tha end of tha compression stream has been
reached.
.PP
If \f(CW\*(C`consumeInput\*(C'\fR is enabled up in tha constructor fo' tha bunzip2 object,
\&\f(CW$input\fR gonna git all compressed data removed from it after
uncompression. I aint talkin' bout chicken n' gravy biatch. On \f(CW\*(C`BZ_OK\*(C'\fR return dis will mean dat \f(CW$input\fR is ghon be an
empty string; when \f(CW\*(C`BZ_STREAM_END\*(C'\fR \f(CW$input\fR will either be a empty
strin or will contain whatever data immediately followed tha compressed
data stream.
.PP
If \f(CW\*(C`appendOutput\*(C'\fR is enabled up in tha constructor fo' tha bunzip2 object,
the uncompressed data is ghon be appended ta \f(CW$output\fR. If not enabled,
\&\f(CW$output\fR is ghon be truncated before tha uncompressed data is freestyled ta dat shit.
.SH "Misc"
.IX Header "Misc"
.ie n .SS "my $version = \fICompress::Raw::Bzip2::bzlibversion()\fP;"
.el .SS "my \f(CW$version\fP = \fICompress::Raw::Bzip2::bzlibversion()\fP;"
.IX Subsection "my $version = Compress::Raw::Bzip2::bzlibversion();"
Returns tha version of tha underlyin bzip2 library.
.SH "Constants"
.IX Header "Constants"
Da followin bzip2 constants is exported by dis module
.PP
.Vb 3
\&                BZ_RUN
\&                BZ_FLUSH
\&                BZ_FINISH
\&
\&                BZ_OK
\&                BZ_RUN_OK
\&                BZ_FLUSH_OK
\&                BZ_FINISH_OK
\&                BZ_STREAM_END
\&                BZ_SEQUENCE_ERROR
\&                BZ_PARAM_ERROR
\&                BZ_MEM_ERROR
\&                BZ_DATA_ERROR
\&                BZ_DATA_ERROR_MAGIC
\&                BZ_IO_ERROR
\&                BZ_UNEXPECTED_EOF
\&                BZ_OUTBUFF_FULL
\&                BZ_CONFIG_ERROR
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Compress::Zlib, IO::Compress::Gzip, IO::Uncompress::Gunzip, IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate, IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress
.PP
IO::Compress::FAQ
.PP
File::GlobMapper, Archive::Zip,
Archive::Tar,
IO::Zlib
.PP
Da primary joint fo' tha bzip2 program is \fIhttp://www.bzip.org\fR.
.PP
See tha module Compress::Bzip2
.SH "AUTHOR"
.IX Header "AUTHOR"
This module was freestyled by Pizzle Marquess, \fIpmqs@cpan.org\fR.
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
See tha Chizzlez file.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2005\-2013 Pizzle Marquess fo' realz. All muthafuckin rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
