.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DynaLoader 3pm"
.TH DynaLoader 3pm "2014-10-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
DynaLoader \- Dynamically load C libraries tha fuck into Perl code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    package YourPackage;
\&    require DynaLoader;
\&    @ISA = qw(... DynaLoader ...);
\&    bootstrap YourPackage;
\&
\&    # optionizzle method fo' \*(Aqglobal\*(Aq loading
\&    sub dl_load_flags { 0x01 }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document defines a standard generic intercourse ta tha dynamic
linkin mechanizzlez available on nuff platforms.  Its primary purpose is
to implement automatic dynamic loadin of Perl modules.
.PP
This document serves as both a justification fo' mah playas wishin to
implement tha DynaLoader fo' a freshly smoked up platform n' as a guide for
mah playas wishin ta use tha DynaLoader directly up in a application.
.PP
Da DynaLoader is designed ta be a straight-up simple high-level
interface dat is sufficiently general ta cover tha requirements
of SunOS, HP-UX, NeXT, Linux, \s-1VMS\s0 n' other platforms.
.PP
It be also hoped dat tha intercourse will cover tha needz of \s-1OS/2, NT\s0
etc n' also allow pseudo-dynamic linkin (usin \f(CW\*(C`ld \-A\*(C'\fR at runtime).
.PP
It must be stressed dat tha DynaLoader, by itself, is practically
useless fo' accessin non-Perl libraries cuz it serves up almost no
Perl-to-C 'glue'.  There is, fo' example, no mechanizzle fo' callin a C
library function or supplyin arguments, n' you can put dat on yo' toast.  A C::DynaLib module
is available from \s-1CPAN\s0 cribs which performs dat function fo' some
common system types.  And since tha year 2000, there be a also Inline::C,
a module dat allows you ta write Perl subroutines up in C.  Also available
from yo' local \s-1CPAN\s0 crib.
.PP
DynaLoader Interface Summary
.PP
.Vb 12
\&  @dl_library_path
\&  @dl_resolve_using
\&  @dl_require_symbols
\&  $dl_debug
\&  @dl_librefs
\&  @dl_modules
\&  @dl_shared_objects
\&                                                  Implemented in:
\&  bootstrap($modulename)                               Perl
\&  @filepaths = dl_findfile(@names)                     Perl
\&  $flags = $modulename\->dl_load_flags                  Perl
\&  $symref  = dl_find_symbol_anywhere($symbol)          Perl
\&
\&  $libref  = dl_load_file($filename, $flags)           C
\&  $status  = dl_unload_file($libref)                   C
\&  $symref  = dl_find_symbol($libref, $symbol)          C
\&  @symbols = dl_undef_symbols()                        C
\&  dl_install_xsub($name, $symref [, $filename])        C
\&  $message = dl_error                                  C
.Ve
.ie n .IP "@dl_library_path" 4
.el .IP "\f(CW@dl_library_path\fR" 4
.IX Item "@dl_library_path"
Da standard/default list of directories up in which \fIdl_findfile()\fR will
search fo' libraries etc.  Directories is searched up in order:
\&\f(CW$dl_library_path\fR[0], [1], ... etc
.Sp
\&\f(CW@dl_library_path\fR is initialised ta hold tha list of 'normal' directories
(\fI/usr/lib\fR, etc) determined by \fBConfigure\fR (\f(CW$Config{\*(Aqlibpth\*(Aq}\fR).  This should
ensure portabilitizzle across a wide range of platforms.
.Sp
\&\f(CW@dl_library_path\fR should also be initialised wit any other directories
that can be determined from tha environment at runtime (such as
\&\s-1LD_LIBRARY_PATH\s0 fo' SunOS).
.Sp
Afta initialisation \f(CW@dl_library_path\fR can be manipulated by an
application rockin push n' unshift before callin \fIdl_findfile()\fR.
Unshift can be used ta add directories ta tha front of tha search order
either ta save search time or ta override libraries wit tha same name
in tha 'normal' directories.
.Sp
Da load function dat \fIdl_load_file()\fR calls may require a absolute
pathname.  Da \fIdl_findfile()\fR function n' \f(CW@dl_library_path\fR can be
used ta search fo' n' return tha absolute pathname fo' the
library/object dat you wish ta load.
.ie n .IP "@dl_resolve_using" 4
.el .IP "\f(CW@dl_resolve_using\fR" 4
.IX Item "@dl_resolve_using"
A list of additionizzle libraries or other shared objects which can be
used ta resolve any undefined symbols dat might be generated by a
lata call ta \fIload_file()\fR.
.Sp
This is only required on some platforms which do not handle dependent
libraries automatically.  For example tha Socket Perl extension
library (\fIauto/Socket/Socket.so\fR) gotz nuff references ta nuff socket
functions which need ta be resolved when itz loaded. Y'all KNOW dat shit, muthafucka!  Most platforms
will automatically know where ta find tha 'dependent' library (e.g.,
\&\fI/usr/lib/libsocket.so\fR).  A few platforms need ta be holla'd at the
location of tha dependent library explicitly.  Use \f(CW@dl_resolve_using\fR
for all dis bullshit.
.Sp
Example usage:
.Sp
.Vb 1
\&    @dl_resolve_usin = dl_findfile(\*(Aq\-lsocket\*(Aq);
.Ve
.ie n .IP "@dl_require_symbols" 4
.el .IP "\f(CW@dl_require_symbols\fR" 4
.IX Item "@dl_require_symbols"
A list of one or mo' symbol names dat is up in tha library/object file
to be dynamically loaded. Y'all KNOW dat shit, muthafucka!  This is only required on some platforms.
.ie n .IP "@dl_librefs" 4
.el .IP "\f(CW@dl_librefs\fR" 4
.IX Item "@dl_librefs"
An array of tha handlez returned by successful calls ta \fIdl_load_file()\fR,
made by bootstrap, up in tha order up in which they was loaded.
Can be used wit \fIdl_find_symbol()\fR ta look fo' a symbol up in any of
the loaded files.
.ie n .IP "@dl_modules" 4
.el .IP "\f(CW@dl_modules\fR" 4
.IX Item "@dl_modules"
An array of module (package) names dat done been bootstrap'ed.
.ie n .IP "@dl_shared_objects" 4
.el .IP "\f(CW@dl_shared_objects\fR" 4
.IX Item "@dl_shared_objects"
An array of file names fo' tha shared objects dat was loaded.
.IP "\fIdl_error()\fR" 4
.IX Item "dl_error()"
Syntax:
.Sp
.Vb 1
\&    $message = dl_error();
.Ve
.Sp
Error message text from tha last failed DynaLoader function. I aint talkin' bout chicken n' gravy biatch.  Note
that, similar ta errno up in unix, a successful function call do not
reset dis message.
.Sp
Implementations should detect tha error as soon as it occurs up in any of
the other functions n' save tha correspondin message fo' later
retrieval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  This will avoid problems on some platforms (like fuckin SunOS)
where tha error message is straight-up temporary (e.g., \fIdlerror()\fR).
.ie n .IP "$dl_debug" 4
.el .IP "\f(CW$dl_debug\fR" 4
.IX Item "$dl_debug"
Internal debuggin lyrics is enabled when \f(CW$dl_debug\fR is set true.
Currently settin \f(CW$dl_debug\fR only affects tha Perl side of the
DynaLoader n' shit.  These lyrics should help a application pimper to
resolve any DynaLoader usage problems.
.Sp
\&\f(CW$dl_debug\fR is set ta \f(CW$ENV{\*(AqPERL_DL_DEBUG\*(Aq}\fR if defined.
.Sp
For tha DynaLoader pimper/porta there be a similar debugging
variable added ta tha C code (see dlutils.c) n' enabled if Perl was
built wit tha \fB\-DDEBUGGING\fR flag.  This can also be set via the
\&\s-1PERL_DL_DEBUG\s0 environment variable.  Set ta 1 fo' minimal shiznit or
higher fo' more.
.IP "\fIdl_findfile()\fR" 4
.IX Item "dl_findfile()"
Syntax:
.Sp
.Vb 1
\&    @filepaths = dl_findfile(@names)
.Ve
.Sp
Determine tha full paths (includin file suffix) of one or more
loadable filez given they generic names n' optionally one or more
directories. Put ya muthafuckin choppers up if ya feel dis!  Searches directories up in \f(CW@dl_library_path\fR by default and
returns a empty list if no filez was found.
.Sp
Names can be specified up in a variety of platform independent forms.  Any
names up in tha form \fB\-lname\fR is converted tha fuck into \fIlibname.*\fR, where \fI.*\fR is
an appropriate suffix fo' tha platform.
.Sp
If a name do not already gotz a suitable prefix and/or suffix then
the correspondin file is ghon be searched fo' by tryin combinations of
prefix n' suffix appropriate ta tha platform: \*(L"$name.o\*(R", \*(L"lib$name.*\*(R"
and \*(L"$name\*(R".
.Sp
If any directories is included up in \f(CW@names\fR they is searched before
\&\f(CW@dl_library_path\fR.  Directories may be specified as \fB\-Ldir\fR.  Any other
names is treated as filenames ta be searched for.
.Sp
Usin argumentz of tha form \f(CW\*(C`\-Ldir\*(C'\fR n' \f(CW\*(C`\-lname\*(C'\fR is recommended.
.Sp
Example:
.Sp
.Vb 1
\&    @dl_resolve_usin = dl_findfile(qw(\-L/usr/5lib \-lposix));
.Ve
.IP "\fIdl_expandspec()\fR" 4
.IX Item "dl_expandspec()"
Syntax:
.Sp
.Vb 1
\&    $filepath = dl_expandspec($spec)
.Ve
.Sp
Some unusual systems, like fuckin \s-1VMS,\s0 require special filename handlin in
order ta deal wit symbolic names fo' filez (i.e., \s-1VMS\s0z Logical Names).
.Sp
To support these systems a \fIdl_expandspec()\fR function can be implemented
either up in tha \fIdl_*.xs\fR file or code can be added ta tha \fIdl_expandspec()\fR
function up in \fIDynaLoader.pm\fR.  See \fIDynaLoader_pm.PL\fR fo' mo' shiznit.
.IP "\fIdl_load_file()\fR" 4
.IX Item "dl_load_file()"
Syntax:
.Sp
.Vb 1
\&    $libref = dl_load_file($filename, $flags)
.Ve
.Sp
Dynamically load \f(CW$filename\fR, which must be tha path ta a gangbangin' finger-lickin' dirty-ass shared object
or library.  An opaque 'library reference' is returned as a handle for
the loaded object.  Returns undef on error.
.Sp
Da \f(CW$flags\fR argument ta altas dl_load_file behaviour. Shiiit, dis aint no joke.  
Assigned bits:
.Sp
.Vb 3
\& 0x01  make symbols available fo' linkin lata dl_load_file\*(Aqs.
\&       (only known ta work on Solaris 2 rockin dlopen(RTLD_GLOBAL))
\&       (ignored under VMS; dis be a aiiight part of image linking)
.Ve
.Sp
(On systems dat provide a handle fo' tha loaded object like fuckin SunOS
and \s-1HPUX,\s0 \f(CW$libref\fR is ghon be dat handle.  On other systems \f(CW$libref\fR will
typically be \f(CW$filename\fR or a pointa ta a funky-ass buffer containin \f(CW$filename\fR.
Da application should not examine or alta \f(CW$libref\fR up in any way.)
.Sp
This is tha function dat do tha real work.  It should use the
current jointz of \f(CW@dl_require_symbols\fR n' \f(CW@dl_resolve_using\fR if required.
.Sp
.Vb 5
\&    SunOS: dlopen($filename)
\&    HP\-UX: shl_load($filename)
\&    Linux: dld_create_reference(@dl_require_symbols); dld_link($filename)
\&    NeXT:  rld_load($filename, @dl_resolve_using)
\&    VMS:   lib$find_image_symbol($filename,$dl_require_symbols[0])
.Ve
.Sp
(Da \fIdlopen()\fR function be also used by Solaris n' some versions of
Linux, n' be a cold-ass lil common chizzle when providin a \*(L"wrapper\*(R" on other
mechanizzlez as is done up in tha \s-1OS/2\s0 port.)
.IP "\fIdl_unload_file()\fR" 4
.IX Item "dl_unload_file()"
Syntax:
.Sp
.Vb 1
\&    $status = dl_unload_file($libref)
.Ve
.Sp
Dynamically unload \f(CW$libref\fR, which must be a opaque 'library reference' as
returned from dl_load_file.  Returns one on success n' zero on failure.
.Sp
This function is optionizzle n' may not necessarily be provided on all platforms.
If it is defined, it is called automatically when tha interpreta exits for
every shared object or library loaded by DynaLoader::bootstrap.  All such
library references is stored up in \f(CW@dl_librefs\fR by DynaLoader::Bootstrap as it
loadz tha libraries. Put ya muthafuckin choppers up if ya feel dis!  Da filez is unloaded up in last-in, first-out order.
.Sp
This unloadin is probably necessary when embeddin a gangbangin' finger-lickin' dirty-ass shared-object perl (e.g.
one configured wit \-Duseshrplib) within a larger application, n' tha perl
interpreta is pimped n' destroyed nuff muthafuckin times within tha gametime of the
application. I aint talkin' bout chicken n' gravy biatch.  In dis case it is possible dat tha system dynamic linker will
unload n' then subsequently reload tha shared libperl without relocatin any
references ta it from any filez DynaLoaded by tha previous incarnation of the
interpreter n' shit.  As a result, any shared objects opened by DynaLoader may point to
a now invalid 'ghost' of tha libperl shared object, causin apparently random
memory corruption n' crashes.  This behaviour is most commonly peeped when using
Apache n' mod_perl built wit tha \s-1APXS\s0 mechanism.
.Sp
.Vb 5
\&    SunOS: dlclose($libref)
\&    HP\-UX: ???
\&    Linux: ???
\&    NeXT:  ???
\&    VMS:   ???
.Ve
.Sp
(Da \fIdlclose()\fR function be also used by Solaris n' some versions of
Linux, n' be a cold-ass lil common chizzle when providin a \*(L"wrapper\*(R" on other
mechanizzlez as is done up in tha \s-1OS/2\s0 port.)
.IP "\fIdl_load_flags()\fR" 4
.IX Item "dl_load_flags()"
Syntax:
.Sp
.Vb 1
\&    $flags = dl_load_flags $modulename;
.Ve
.Sp
Designed ta be a method call, n' ta be overridden by a thugged-out derived class
(i.e. a cold-ass lil class which has DynaLoader up in its \f(CW@ISA\fR).  Da definizzle in
DynaLoader itself returns 0, which produces standard behavior from
\&\fIdl_load_file()\fR.
.IP "\fIdl_find_symbol()\fR" 4
.IX Item "dl_find_symbol()"
Syntax:
.Sp
.Vb 1
\&    $symref = dl_find_symbol($libref, $symbol)
.Ve
.Sp
Return tha address of tha symbol \f(CW$symbol\fR or \f(CW\*(C`undef\*(C'\fR if not found. Y'all KNOW dat shit, muthafucka!  If the
target system has separate functions ta search fo' symbolz of different
types then \fIdl_find_symbol()\fR should search fo' function symbols first and
then other types.
.Sp
Da exact manner up in which tha address is returned up in \f(CW$symref\fR is not
currently defined. Y'all KNOW dat shit, muthafucka!  Da only initial requirement is dat \f(CW$symref\fR can
be passed to, n' understood by, \fIdl_install_xsub()\fR.
.Sp
.Vb 5
\&    SunOS: dlsym($libref, $symbol)
\&    HP\-UX: shl_findsym($libref, $symbol)
\&    Linux: dld_get_func($symbol) and/or dld_get_symbol($symbol)
\&    NeXT:  rld_lookup("_$symbol")
\&    VMS:   lib$find_image_symbol($libref,$symbol)
.Ve
.IP "\fIdl_find_symbol_anywhere()\fR" 4
.IX Item "dl_find_symbol_anywhere()"
Syntax:
.Sp
.Vb 1
\&    $symref = dl_find_symbol_anywhere($symbol)
.Ve
.Sp
Applies \fIdl_find_symbol()\fR ta tha thugz of \f(CW@dl_librefs\fR n' returns
the first match found.
.IP "\fIdl_undef_symbols()\fR" 4
.IX Item "dl_undef_symbols()"
Example
.Sp
.Vb 1
\&    @symbols = dl_undef_symbols()
.Ve
.Sp
Return a list of symbol names which remain undefined afta \fIload_file()\fR.
Returns \f(CW\*(C`()\*(C'\fR if not known. I aint talkin' bout chicken n' gravy biatch.  Don't worry if yo' platform do not provide
a mechanizzle fo' all dis bullshit.  Most do not need it n' hence do not provide it,
they just return a empty list.
.IP "\fIdl_install_xsub()\fR" 4
.IX Item "dl_install_xsub()"
Syntax:
.Sp
.Vb 1
\&    dl_install_xsub($perl_name, $symref [, $filename])
.Ve
.Sp
Smoke a freshly smoked up Perl external subroutine named \f(CW$perl_name\fR rockin \f(CW$symref\fR as
a pointa ta tha function which implements tha routine.  This is simply
a direct call ta \fInewXSUB()\fR.  Returns a reference ta tha installed
function.
.Sp
Da \f(CW$filename\fR parameta is used by Perl ta identify tha source file for
the function if required by \fIdie()\fR, \fIcaller()\fR or tha debugger n' shit.  If
\&\f(CW$filename\fR aint defined then \*(L"DynaLoader\*(R" is ghon be used.
.IP "\fIbootstrap()\fR" 4
.IX Item "bootstrap()"
Syntax:
.Sp
bootstrap($module [...])
.Sp
This is tha aiiight entry point fo' automatic dynamic loadin up in Perl.
.Sp
It performs tha followin actions:
.RS 4
.IP "\(bu" 8
locates a auto/$module directory by searchin \f(CW@INC\fR
.IP "\(bu" 8
uses \fIdl_findfile()\fR ta determine tha filename ta load
.IP "\(bu" 8
sets \f(CW@dl_require_symbols\fR ta \f(CW\*(C`("boot_$module")\*(C'\fR
.IP "\(bu" 8
executes a \fIauto/$module/$module.bs\fR file if it exists
(typically used ta add ta \f(CW@dl_resolve_using\fR any filez which
are required ta load tha module on tha current platform)
.IP "\(bu" 8
calls \fIdl_load_flags()\fR ta determine how tha fuck ta load tha file.
.IP "\(bu" 8
calls \fIdl_load_file()\fR ta load tha file
.IP "\(bu" 8
calls \fIdl_undef_symbols()\fR n' warns if any symbols is undefined
.IP "\(bu" 8
calls \fIdl_find_symbol()\fR fo' \*(L"boot_$module\*(R"
.IP "\(bu" 8
calls \fIdl_install_xsub()\fR ta install it as \*(L"${module}::bootstrap\*(R"
.IP "\(bu" 8
calls &{\*(L"${module}::bootstrap\*(R"} ta bootstrap tha module (actually
it uses tha function reference returned by dl_install_xsub fo' speed)
.RE
.RS 4
.Sp
All arguments ta \fIbootstrap()\fR is passed ta tha modulez bootstrap function.
Da default code generated by \fIxsubpp\fR expects \f(CW$module\fR [, \f(CW$version\fR]
If tha optionizzle \f(CW$version\fR argument aint given, it defaults to
\&\f(CW\*(C`$XS_VERSION // $VERSION\*(C'\fR up in tha modulez symbol table. Da default code
compares tha Perl-space version wit tha version of tha compiled \s-1XS\s0 code,
and croaks wit a error if they do not match.
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
Slim Tim Bunce, 11 August 1994.
.PP
This intercourse is based on tha work n' commentz of (in no particular
order): Larry Wall, Robert Sanders, Dean Roehrich, Jeff Okamoto, Anno
Siegel, Thomas Neumann, Pizzle Marquess, Charlez Bailey, mah dirty ass n' others.
.PP
Larry Wall designed tha elegant inherited bootstrap mechanizzle and
implemented tha straight-up original gangsta Perl 5 dynamic loader rockin dat shit.
.PP
Solaris global loadin added by Nick Ing-Simmons wit design/coding
assistizzle from Slim Tim Bunce, January 1996.
