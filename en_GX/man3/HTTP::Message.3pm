.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Message 3"
.TH HTTP::Message 3 "2012-10-20" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Message \- HTTP steez message (base class)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use base \*(AqHTTP::Message\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An \f(CW\*(C`HTTP::Message\*(C'\fR object gotz nuff some headaz n' a cold-ass lil content body.
Da followin methodz is available:
.ie n .IP "$mess = HTTP::Message\->new" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->new" 4
.IX Item "$mess = HTTP::Message->new"
.PD 0
.ie n .IP "$mess = HTTP::Message\->new( $headaz )" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->new( \f(CW$headers\fR )" 4
.IX Item "$mess = HTTP::Message->new( $headaz )"
.ie n .IP "$mess = HTTP::Message\->new( $headers, $content )" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->new( \f(CW$headers\fR, \f(CW$content\fR )" 4
.IX Item "$mess = HTTP::Message->new( $headers, $content )"
.PD
This constructs a freshly smoked up message object.  Normally you would want
construct \f(CW\*(C`HTTP::Request\*(C'\fR or \f(CW\*(C`HTTP::Response\*(C'\fR objects instead.
.Sp
Da optionizzle \f(CW$header\fR argument should be a reference ta an
\&\f(CW\*(C`HTTP::Headers\*(C'\fR object or a plain array reference of key/value pairs.
If a \f(CW\*(C`HTTP::Headers\*(C'\fR object is provided then a cold-ass lil copy of it will be
embedded tha fuck into tha constructed message, i.e. it aint gonna be owned and
can be modified afterwardz without affectin tha message.
.Sp
Da optionizzle \f(CW$content\fR argument should be a strang of bytes.
.ie n .IP "$mess = HTTP::Message\->parse( $str )" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->parse( \f(CW$str\fR )" 4
.IX Item "$mess = HTTP::Message->parse( $str )"
This constructs a freshly smoked up message object by parsin tha given string.
.ie n .IP "$mess\->headers" 4
.el .IP "\f(CW$mess\fR\->headers" 4
.IX Item "$mess->headers"
Returns tha embedded \f(CW\*(C`HTTP::Headers\*(C'\fR object.
.ie n .IP "$mess\->headers_as_string" 4
.el .IP "\f(CW$mess\fR\->headers_as_string" 4
.IX Item "$mess->headers_as_string"
.PD 0
.ie n .IP "$mess\->headers_as_string( $eol )" 4
.el .IP "\f(CW$mess\fR\->headers_as_string( \f(CW$eol\fR )" 4
.IX Item "$mess->headers_as_string( $eol )"
.PD
Call tha \fIas_string()\fR method fo' tha headaz up in the
message.  This is ghon be tha same as
.Sp
.Vb 1
\&    $mess\->headers\->as_string
.Ve
.Sp
but it will make yo' program a whole characta shorta :\-)
.ie n .IP "$mess\->content" 4
.el .IP "\f(CW$mess\fR\->content" 4
.IX Item "$mess->content"
.PD 0
.ie n .IP "$mess\->content( $bytes )" 4
.el .IP "\f(CW$mess\fR\->content( \f(CW$bytes\fR )" 4
.IX Item "$mess->content( $bytes )"
.PD
Da \fIcontent()\fR method sets tha raw content if a argument is given. I aint talkin' bout chicken n' gravy biatch.  If no
argument is given tha content aint touched. Y'all KNOW dat shit, muthafucka!  In either case the
original gangsta raw content is returned.
.Sp
Note dat tha content should be a strang of bytes.  Strings up in perl
can contain charactas outside tha range of a funky-ass byte.  Da \f(CW\*(C`Encode\*(C'\fR
module can be used ta turn such strings tha fuck into a strang of bytes.
.ie n .IP "$mess\->add_content( $bytes )" 4
.el .IP "\f(CW$mess\fR\->add_content( \f(CW$bytes\fR )" 4
.IX Item "$mess->add_content( $bytes )"
Da \fIadd_content()\fR methodz appendz mo' data bytes ta tha end of the
current content buffer.
.ie n .IP "$mess\->add_content_utf8( $strin )" 4
.el .IP "\f(CW$mess\fR\->add_content_utf8( \f(CW$string\fR )" 4
.IX Item "$mess->add_content_utf8( $strin )"
Da \fIadd_content_utf8()\fR method appendz tha \s-1UTF\-8\s0 bytes representin the
strin ta tha end of tha current content buffer.
.ie n .IP "$mess\->content_ref" 4
.el .IP "\f(CW$mess\fR\->content_ref" 4
.IX Item "$mess->content_ref"
.PD 0
.ie n .IP "$mess\->content_ref( \e$bytes )" 4
.el .IP "\f(CW$mess\fR\->content_ref( \e$bytes )" 4
.IX Item "$mess->content_ref( $bytes )"
.PD
Da \fIcontent_ref()\fR method will return a reference ta content buffer string.
It can be mo' efficient ta access tha content dis way if tha content
is huge, n' it can even be used fo' direct manipulation of tha content,
for instance:
.Sp
.Vb 1
\&  ${$res\->content_ref} =~ s/\ebfoo\eb/bar/g;
.Ve
.Sp
This example would modify tha content buffer in-place.
.Sp
If a argument is passed it will setup tha content ta reference some
external source.  Da \fIcontent()\fR n' \fIadd_content()\fR methods
will automatically dereference scalar references passed dis way.  For
other references \fIcontent()\fR will return tha reference itself and
\&\fIadd_content()\fR will refuse ta do anything.
.ie n .IP "$mess\->content_charset" 4
.el .IP "\f(CW$mess\fR\->content_charset" 4
.IX Item "$mess->content_charset"
This returns tha charset used by tha content up in tha message.  The
charset is either found as tha charset attribute of the
\&\f(CW\*(C`Content\-Type\*(C'\fR header or by guessing.
.Sp
See <http://www.w3.org/TR/REC\-html40/charset.html#spec\-char\-encoding>
for details bout how tha fuck charset is determined.
.ie n .IP "$mess\->decoded_content( %options )" 4
.el .IP "\f(CW$mess\fR\->decoded_content( \f(CW%options\fR )" 4
.IX Item "$mess->decoded_content( %options )"
Returns tha content wit any \f(CW\*(C`Content\-Encoding\*(C'\fR undone n' fo' textual content
the raw content encoded ta Perlz Unicode strings.  If tha \f(CW\*(C`Content\-Encoding\*(C'\fR
or \f(CW\*(C`charset\*(C'\fR of tha message is unknown dis method will fail by returning
\&\f(CW\*(C`undef\*(C'\fR.
.Sp
Da followin options can be specified.
.RS 4
.ie n .IP """charset""" 4
.el .IP "\f(CWcharset\fR" 4
.IX Item "charset"
This override tha charset parameta fo' text content.  Da value
\&\f(CW\*(C`none\*(C'\fR can used ta suppress decodin of tha charset.
.ie n .IP """default_charset""" 4
.el .IP "\f(CWdefault_charset\fR" 4
.IX Item "default_charset"
This override tha default charset guessed by \fIcontent_charset()\fR or
if dat fails \*(L"\s-1ISO\-8859\-1\*(R".\s0
.ie n .IP """alt_charset""" 4
.el .IP "\f(CWalt_charset\fR" 4
.IX Item "alt_charset"
If decodin fails cuz tha charset specified up in tha Content-Type header
aint recognized by Perlz Encode module, then try decodin rockin dis charset
instead of failing.  Da \f(CW\*(C`alt_charset\*(C'\fR might be specified as \f(CW\*(C`none\*(C'\fR ta simply
return tha strang without any decodin of charset as alternative.
.ie n .IP """charset_strict""" 4
.el .IP "\f(CWcharset_strict\fR" 4
.IX Item "charset_strict"
Abort decodin if malformed charactas is found up in tha content.  By
default you git tha substitution characta (\*(L"\ex{\s-1FFFD\s0}\*(R") up in place of
malformed characters.
.ie n .IP """raise_error""" 4
.el .IP "\f(CWraise_error\fR" 4
.IX Item "raise_error"
If \s-1TRUE\s0 then raise a exception if not able ta decode content.  Reason
might be dat tha specified \f(CW\*(C`Content\-Encoding\*(C'\fR or \f(CW\*(C`charset\*(C'\fR is not
supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If dis option is \s-1FALSE,\s0 then \fIdecoded_content()\fR will return
\&\f(CW\*(C`undef\*(C'\fR on errors yo, but will still set $@.
.ie n .IP """ref""" 4
.el .IP "\f(CWref\fR" 4
.IX Item "ref"
If \s-1TRUE\s0 then a reference ta decoded content is returned. Y'all KNOW dat shit, muthafucka!  This might
be mo' efficient up in cases where tha decoded content is identical to
the raw content as no data copyin is required up in dis case.
.RE
.RS 4
.RE
.ie n .IP "$mess\->decodable" 4
.el .IP "\f(CW$mess\fR\->decodable" 4
.IX Item "$mess->decodable"
.PD 0
.IP "\fIHTTP::Message::decodable()\fR" 4
.IX Item "HTTP::Message::decodable()"
.PD
This returns tha encodin identifiers dat \fIdecoded_content()\fR can
process.  In scalar context returns a cold-ass lil comma separated strang of
identifiers.
.Sp
This value is suitable fo' initializin tha \f(CW\*(C`Accept\-Encoding\*(C'\fR request
header field.
.ie n .IP "$mess\->decode" 4
.el .IP "\f(CW$mess\fR\->decode" 4
.IX Item "$mess->decode"
This method tries ta replace tha content of tha message wit the
decoded version n' removes tha \f(CW\*(C`Content\-Encoding\*(C'\fR header n' shit.  Returns
\&\s-1TRUE\s0 if successful n' \s-1FALSE\s0 if not.
.Sp
If tha message aint gots a \f(CW\*(C`Content\-Encoding\*(C'\fR header dis method
does not a god damn thang n' returns \s-1TRUE.\s0
.Sp
Note dat tha content of tha message is still bytes afta dis method
has been called n' you still need ta booty-call \fIdecoded_content()\fR if you
wanna process its content as a string.
.ie n .IP "$mess\->encode( $encoding, ... )" 4
.el .IP "\f(CW$mess\fR\->encode( \f(CW$encoding\fR, ... )" 4
.IX Item "$mess->encode( $encoding, ... )"
Apply tha given encodings ta tha content of tha message.  Returns \s-1TRUE\s0
if successful naaahhmean? Da \*(L"identity\*(R" (non\-)encodin be always supported; other
currently supported encodings, subject ta availabilitizzle of required
additionizzle modules, is \*(L"gzip\*(R", \*(L"deflate\*(R", \*(L"x\-bzip2\*(R" n' \*(L"base64\*(R".
.Sp
A successful call ta dis function will set tha \f(CW\*(C`Content\-Encoding\*(C'\fR
header.
.Sp
Note dat \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR lyrics can't be encoded and
this method will croak if you try.
.ie n .IP "$mess\->parts" 4
.el .IP "\f(CW$mess\fR\->parts" 4
.IX Item "$mess->parts"
.PD 0
.ie n .IP "$mess\->parts( @parts )" 4
.el .IP "\f(CW$mess\fR\->parts( \f(CW@parts\fR )" 4
.IX Item "$mess->parts( @parts )"
.ie n .IP "$mess\->parts( \e@parts )" 4
.el .IP "\f(CW$mess\fR\->parts( \e@parts )" 4
.IX Item "$mess->parts( @parts )"
.PD
Lyrics can be composite, i.e. contain other lyrics.  Da composite
lyrics gotz a cold-ass lil content type of \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR.  This
method give access ta tha contained lyrics.
.Sp
Da argumentless form will return a list of \f(CW\*(C`HTTP::Message\*(C'\fR objects.
If tha content type of \f(CW$msg\fR aint \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR then
this will return tha empty list.  In scalar context only tha first
object is returned. Y'all KNOW dat shit, muthafucka!  Da returned message parts should be regarded as
read-only (future versionz of dis library might make it possible
to modify tha parent by modifyin tha parts).
.Sp
If tha content type of \f(CW$msg\fR is \f(CW\*(C`message/*\*(C'\fR then there will only be
one part returned.
.Sp
If tha content type is \f(CW\*(C`message/http\*(C'\fR, then tha return value will be
either a \f(CW\*(C`HTTP::Request\*(C'\fR or a \f(CW\*(C`HTTP::Response\*(C'\fR object.
.Sp
If a \f(CW@parts\fR argument is given, then tha content of tha message will be
modified. Y'all KNOW dat shit, muthafucka! Da array reference form is provided so dat a empty list
can be provided. Y'all KNOW dat shit, muthafucka!  Da \f(CW@parts\fR array should contain \f(CW\*(C`HTTP::Message\*(C'\fR
objects, n' you can put dat on yo' toast.  Da \f(CW@parts\fR objects is owned by \f(CW$mess\fR afta dis call and
should not be modified or made part of other lyrics.
.Sp
When uppimpin tha message wit dis method n' tha oldschool content type of
\&\f(CW$mess\fR aint \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR, then tha content type is
set ta \f(CW\*(C`multipart/mixed\*(C'\fR n' all other content headaz is cleared.
.Sp
This method will croak if tha content type is \f(CW\*(C`message/*\*(C'\fR n' more
than one part is provided.
.ie n .IP "$mess\->add_part( $part )" 4
.el .IP "\f(CW$mess\fR\->add_part( \f(CW$part\fR )" 4
.IX Item "$mess->add_part( $part )"
This will add a part ta a message.  Da \f(CW$part\fR argument should be
another \f(CW\*(C`HTTP::Message\*(C'\fR object.  If tha previous content type of
\&\f(CW$mess\fR aint \f(CW\*(C`multipart/*\*(C'\fR then tha oldschool content (together wit all
content headers) is ghon be made part #1 n' tha content type made
\&\f(CW\*(C`multipart/mixed\*(C'\fR before tha freshly smoked up part be added. Y'all KNOW dat shit, muthafucka!  Da \f(CW$part\fR object is
owned by \f(CW$mess\fR afta dis call n' should not be modified or made part
of other lyrics.
.Sp
There is no return value.
.ie n .IP "$mess\->clear" 4
.el .IP "\f(CW$mess\fR\->clear" 4
.IX Item "$mess->clear"
Will clear tha headaz n' set tha content ta tha empty string.  There
is no return value
.ie n .IP "$mess\->protocol" 4
.el .IP "\f(CW$mess\fR\->protocol" 4
.IX Item "$mess->protocol"
.PD 0
.ie n .IP "$mess\->protocol( $proto )" 4
.el .IP "\f(CW$mess\fR\->protocol( \f(CW$proto\fR )" 4
.IX Item "$mess->protocol( $proto )"
.PD
Sets tha \s-1HTTP\s0 protocol used fo' tha message.  Da \fIprotocol()\fR be a string
like \f(CW\*(C`HTTP/1.0\*(C'\fR or \f(CW\*(C`HTTP/1.1\*(C'\fR.
.ie n .IP "$mess\->clone" 4
.el .IP "\f(CW$mess\fR\->clone" 4
.IX Item "$mess->clone"
Returns a cold-ass lil copy of tha message object.
.ie n .IP "$mess\->as_string" 4
.el .IP "\f(CW$mess\fR\->as_string" 4
.IX Item "$mess->as_string"
.PD 0
.ie n .IP "$mess\->as_string( $eol )" 4
.el .IP "\f(CW$mess\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$mess->as_string( $eol )"
.PD
Returns tha message formatted as a single string.
.Sp
Da optionizzle \f(CW$eol\fR parameta specifies tha line endin sequence ta use.
Da default is \*(L"\en\*(R".  If no \f(CW$eol\fR is given then as_strin will ensure
that tha returned strang is newline terminated (even when tha message
content is not).  No extra newline be appended if a explicit \f(CW$eol\fR is
passed.
.ie n .IP "$mess\->dump( %opt )" 4
.el .IP "\f(CW$mess\fR\->dump( \f(CW%opt\fR )" 4
.IX Item "$mess->dump( %opt )"
Returns tha message formatted as a string.  In void context print tha string.
.Sp
This differs from \f(CW\*(C`$mess\->as_string\*(C'\fR up in dat it escapes tha bytes
of tha content so dat itz safe ta print dem n' it limits how tha fuck much
content ta print.  Da escapes syntax used is tha same ol' dirty as fo' Perl's
double quoted strings.  If there is no content tha strang \*(L"(no
content)\*(R" is shown up in its place.
.Sp
Options ta influence tha output can be passed as key/value pairs. The
followin options is recognized:
.RS 4
.ie n .IP "maxlength => $num" 4
.el .IP "maxlength => \f(CW$num\fR" 4
.IX Item "maxlength => $num"
How tha fuck much of tha content ta show.  Da default is 512.  Set dis ta 0
for unlimited.
.Sp
If tha content is longer then tha strang is chopped all up in tha limit and
the strang \*(L"...\en(### mo' bytes not shown)\*(R" appended.
.ie n .IP "no_content => $str" 4
.el .IP "no_content => \f(CW$str\fR" 4
.IX Item "no_content => $str"
Replaces tha \*(L"(no content)\*(R" marker.
.ie n .IP "prefix => $str" 4
.el .IP "prefix => \f(CW$str\fR" 4
.IX Item "prefix => $str"
A strang dat is ghon be prefixed ta each line of tha dump.
.RE
.RS 4
.RE
.PP
All methodz unknown ta \f(CW\*(C`HTTP::Message\*(C'\fR itself is delegated ta the
\&\f(CW\*(C`HTTP::Headers\*(C'\fR object dat is part of every last muthafuckin message.  This allows
convenient access ta these methods.  Refer ta HTTP::Headaz for
detailz of these methods:
.PP
.Vb 7
\&    $mess\->header( $field => $val )
\&    $mess\->push_header( $field => $val )
\&    $mess\->init_header( $field => $val )
\&    $mess\->remove_header( $field )
\&    $mess\->remove_content_headers
\&    $mess\->header_field_names
\&    $mess\->scan( \e&doit )
\&
\&    $mess\->date
\&    $mess\->expires
\&    $mess\->if_modified_since
\&    $mess\->if_unmodified_since
\&    $mess\->last_modified
\&    $mess\->content_type
\&    $mess\->content_encoding
\&    $mess\->content_length
\&    $mess\->content_language
\&    $mess\->title
\&    $mess\->user_agent
\&    $mess\->server
\&    $mess\->from
\&    $mess\->referer
\&    $mess\->www_authenticate
\&    $mess\->authorization
\&    $mess\->proxy_authorization
\&    $mess\->authorization_basic
\&    $mess\->proxy_authorization_basic
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2004 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
