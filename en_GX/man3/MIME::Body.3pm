.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MIME::Body 3"
.TH MIME::Body 3 "2013-11-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME::Body \- tha body of a MIME message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Before readin further, you should peep MIME::Tools ta make shizzle that
you KNOW where dis module fits tha fuck into tha grand scheme of thangs.
Go on, do it now, nahmeean, biatch?  I be bout ta wait.
.PP
Ready, biatch?  Ok...
.SS "Obtainin bodies"
.IX Subsection "Obtainin bodies"
.Vb 2
\&   ### Git tha bodyhandle of a MIME::Entitizzle object:
\&   $body = $entity\->bodyhandle;
\&
\&   ### Smoke a funky-ass body which stores data up in a gangbangin' finger-lickin' disk file:
\&   $body = freshly smoked up MIME::Body::File "/path/to/file";
\&
\&   ### Smoke a funky-ass body which stores data up in a in\-core array:
\&   $body = freshly smoked up MIME::Body::InCore \e@strings;
.Ve
.SS "Opening, closing, n' rockin \s-1IO\s0 handles"
.IX Subsection "Opening, closing, n' rockin IO handles"
.Vb 4
\&   ### Write data ta tha body:
\&   $IO = $body\->open("w")      || take a thugged-out dirtnap "open body: $!";
\&   $IO\->print($message);
\&   $IO\->close                  || take a thugged-out dirtnap "close I/O handle: $!";
\&
\&   ### Read data from tha body (in dis case, line by line):
\&   $IO = $body\->open("r")      || take a thugged-out dirtnap "open body: $!";
\&   while (defined($_ = $IO\->getline)) {
\&       ### do stuff
\&   }
\&   $IO\->close                  || take a thugged-out dirtnap "close I/O handle: $!";
.Ve
.SS "Other I/O"
.IX Subsection "Other I/O"
.Vb 2
\&   ### Dump tha ENCODED body data ta a gangbangin' filehandle:
\&   $body\->print(\e*STDOUT);
\&
\&   ### Slurp all tha UNENCODED data in, n' put it up in a scalar:
\&   $strin = $body\->as_string;
\&
\&   ### Slurp all tha UNENCODED data in, n' put it up in a array of lines:
\&   @lines = $body\->as_lines;
.Ve
.SS "Workin directly wit paths ta underlyin files"
.IX Subsection "Workin directly wit paths ta underlyin files"
.Vb 7
\&   ### Where\*(Aqs tha data?
\&   if (defined($body\->path)) {   ### data is on disk:
\&       print "data is stored externally, up in ", $body\->path;
\&   }
\&   else {                        ### data is up in core:
\&       print "data be already up in core, n' is...\en", $body\->as_string;
\&   }
\&
\&   ### Git rid of anythang on disk:
\&   $body\->purge;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1MIME\s0 lyrics can be straight-up long (e.g., tar files, MPEGs, etc.) or hella
short (short textual notes, as up in ordinary mail).  Long lyrics
are dopest stored up in files, while short ones is like dopest stored
in core.
.PP
This class be a attempt ta define a cold-ass lil common intercourse fo' objects
which contain message data, regardless of how tha fuck tha data is
physically stored. Y'all KNOW dat shit, muthafucka!  Da gamespan of a \*(L"body\*(R" object
usually be lookin like this:
.IP "1." 4
\&\fBBody object is pimped by a MIME::Parser durin parsing.\fR
It aint nuthin but at dis point dat tha actual MIME::Body subclass is chosen,
and \fInew()\fR is invoked. Y'all KNOW dat shit, muthafucka!  (For example: if tha body data is goin to
a file, then it be at dis point dat tha class MIME::Body::File,
and tha filename, is chosen).
.IP "2." 4
\&\fBData is freestyled ta tha body\fR (usually by tha \s-1MIME\s0 parser) like this:
Da body is opened fo' writing, via \f(CW\*(C`open("w")\*(C'\fR.  This will trash any
previous contents, n' return a \*(L"I/O handle\*(R" opened fo' writing.
Data is freestyled ta dis I/O handle, via \fIprint()\fR.
Then tha I/O handle is closed, via \fIclose()\fR.
.IP "3." 4
\&\fBData is read from tha body\fR (usually by tha user application) like this:
Da body is opened fo' readin by a user application, via \f(CW\*(C`open("r")\*(C'\fR.
This will return a \*(L"I/O handle\*(R" opened fo' reading.
Data is read from tha I/O handle, via \fIread()\fR, \fIgetline()\fR, or \fIgetlines()\fR.
Then tha I/O handle is closed, via \fIclose()\fR.
.IP "4." 4
\&\fBBody object is destructed.\fR
.PP
Yo ass can write yo' own subclasses, as long as they follow the
interface busted lyrics bout below.  Implementaz of subclasses should assume
that steps 2 n' 3 may be repeated any number of times, n' in
different ordaz (e.g., 1\-2\-2\-3\-2\-3\-3\-3\-3\-3\-2\-4).
.PP
In any case, once a MIME::Body has been pimped, you ask ta open it
for readin or writing, which gets you a \*(L"i/o handle\*(R": you then use
the same mechanizzlez fo' readin from or freestylin ta dat handle, no matter
what class it is.
.PP
Beware: unless you know fo' certain what tha fuck kind of body you have, you
should \fInot\fR assume dat tha body has a underlyin filehandle.
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
.IP "new \s-1ARGS...\s0" 4
.IX Item "new ARGS..."
\&\fIClass method, constructor.\fR
Smoke a freshly smoked up body.  Any \s-1ARGS\s0 is busted ta \fIinit()\fR.
.IP "init \s-1ARGS...\s0" 4
.IX Item "init ARGS..."
\&\fIInstizzle method, abstract, initiallizer.\fR
This is called automatically by \f(CW\*(C`new()\*(C'\fR, wit tha arguments given
to \f(CW\*(C`new()\*(C'\fR.  Da arguments is optional, n' entirely up ta the
subclass.  Da default method do nothing,
.IP "as_lines" 4
.IX Item "as_lines"
\&\fIInstizzle method.\fR
Return tha contentz of tha body as a array of lines (each terminated
by a newline, wit tha possible exception of tha final one).
Returns empty on failure (\s-1NB:\s0 indistinguishable from a empty body!).
.Sp
Note: tha default method gets tha data via
repeated \fIgetline()\fR calls; yo' subclass might wish ta override all dis bullshit.
.IP "as_string" 4
.IX Item "as_string"
\&\fIInstizzle method.\fR
Return tha body data as a strang (slurpin it tha fuck into core if necessary).
Best not ta do dis unless you \fIsure\fR dat tha body is reasonably small!
Returns empty strang fo' a empty body, n' undef on failure.
.Sp
Note: tha default method uses \fIprint()\fR, which gets tha data via
repeated \fIread()\fR calls; yo' subclass might wish ta override all dis bullshit.
.IP "binmode [\s-1ONOFF\s0]" 4
.IX Item "binmode [ONOFF]"
\&\fIInstizzle method.\fR
With argument, flags whether or not \fIopen()\fR should return a I/O handle
which has \fIbinmode()\fR activated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  With no argument, just returns the
current value.
.IP "is_encoded [\s-1ONOFF\s0]" 4
.IX Item "is_encoded [ONOFF]"
\&\fIInstizzle method.\fR
If set ta fo'sho, no decodin be applied on output. This flag is set
by MIME::Parser, if tha parser runs up in \fIdecode_bodies\fR\|(0) mode, so the
content is handled unmodified.
.IP "dup" 4
.IX Item "dup"
\&\fIInstizzle method.\fR
Duplicate tha bodyhandle.
.Sp
\&\fIBeware:\fR external data up in bodyhandlez is \fInot\fR copied ta freshly smoked up files!
Changin tha data up in one bodyz data file, or purgin dat body,
\&\fIwill\fR affect its duplicate.  Bodies wit in-core data probably need
not worry.
.IP "open \s-1READWRITE\s0" 4
.IX Item "open READWRITE"
\&\fIInstizzle method, abstract.\fR
This should do whatever is necessary ta open tha body fo' either
writin (if \s-1READWRITE\s0 is \*(L"w\*(R") or readin (if mode is \*(L"r\*(R").
.Sp
This method is sposed ta fuckin return a \*(L"I/O handle\*(R" object on success,
and undef on error. Shiiit, dis aint no joke.  An I/O handle can be any object dat supports a
small set of standard methodz fo' reading/writin data.
See tha IO::Handle class fo' a example.
.IP "path [\s-1PATH\s0]" 4
.IX Item "path [PATH]"
\&\fIInstizzle method.\fR
If you storin tha body data externally (e.g., up in a gangbangin' finger-lickin' disk file), you'll
wanna give applications tha mobilitizzle ta git at dat data, fo' cleanup.
This method should return tha path ta tha data, or undef if there is none.
.Sp
Where appropriate, tha path \fIshould\fR be a simple string, like a gangbangin' filename.
With argument, sets tha \s-1PATH,\s0 which should be undef if there is none.
.IP "print \s-1FILEHANDLE\s0" 4
.IX Item "print FILEHANDLE"
\&\fIInstizzle method.\fR
Output tha body data ta tha given filehandle, or ta tha currently-selected
one if none is given.
.IP "purge" 4
.IX Item "purge"
\&\fIInstizzle method, abstract.\fR
Remove any data which resides external ta tha program (e.g., up in disk files).
Immediately afta a \fIpurge()\fR, tha \fIpath()\fR should return undef ta indicate
that tha external data is no longer available.
.SH "SUBCLASSES"
.IX Header "SUBCLASSES"
Da followin built-in classes is provided:
.PP
.Vb 6
\&   Body                 Stores body     When open()ed,
\&   class:               data in:        returns:
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   MIME::Body::File     disk file       IO::Handle
\&   MIME::Body::Scalar   scalar          IO::Handle
\&   MIME::Body::InCore   scalar array    IO::Handle
.Ve
.SS "MIME::Body::File"
.IX Subsection "MIME::Body::File"
A body class dat stores tha data up in a gangbangin' finger-lickin' disk file.  Invoke the
constructor as:
.PP
.Vb 1
\&    $body = freshly smoked up MIME::Body::File "/path/to/file";
.Ve
.PP
In dis case, tha \f(CW\*(C`path()\*(C'\fR method would return tha given path,
so you \fIcould\fR say:
.PP
.Vb 7
\&    if (defined($body\->path)) {
\&        open BODY, $body\->path or take a thugged-out dirtnap "open: $!";
\&        while (<BODY>) {
\&            ### do stuff
\&        }
\&        close BODY;
\&    }
.Ve
.PP
But you dopest off not bustin all dis bullshit.
.SS "MIME::Body::Scalar"
.IX Subsection "MIME::Body::Scalar"
A body class dat stores tha data in-core, up in a simple scalar.
Invoke tha constructor as:
.PP
.Vb 1
\&    $body = freshly smoked up MIME::Body::Scalar \e$string;
.Ve
.PP
A single scalar argument sets tha body ta dat value, exactly as though
you'd opened fo' tha body fo' writing, freestyled tha value,
and closed tha body again:
.PP
.Vb 1
\&    $body = freshly smoked up MIME::Body::Scalar "Line 1\enLine 2\enLine 3";
.Ve
.PP
A single array reference sets tha body ta tha result of joinin all the
elementz of dat array together:
.PP
.Vb 3
\&    $body = freshly smoked up MIME::Body::Scalar ["Line 1\en",
\&                                    "Line 2\en",
\&                                    "Line 3"];
.Ve
.SS "MIME::Body::InCore"
.IX Subsection "MIME::Body::InCore"
A body class dat stores tha data in-core.
Invoke tha constructor as:
.PP
.Vb 3
\&    $body = freshly smoked up MIME::Body::InCore \e$string;
\&    $body = freshly smoked up MIME::Body::InCore  $string;
\&    $body = freshly smoked up MIME::Body::InCore \e@stringarray
.Ve
.PP
A simple scalar argument sets tha body ta dat value, exactly as though
you'd opened fo' tha body fo' writing, freestyled tha value,
and closed tha body again:
.PP
.Vb 1
\&    $body = freshly smoked up MIME::Body::InCore "Line 1\enLine 2\enLine 3";
.Ve
.PP
A single array reference sets tha body ta tha concatenation of all
scalars dat it holds:
.PP
.Vb 3
\&    $body = freshly smoked up MIME::Body::InCore ["Line 1\en",
\&                                    "Line 2\en",
\&                                    "Line 3"];
.Ve
.SS "Definin yo' own subclasses"
.IX Subsection "Definin yo' own subclasses"
So you not aiiight wit filez n' scalar-arrays?
No problem: just define yo' own MIME::Body subclass, n' cook up a subclass
of MIME::Parser or MIME::ParserBase which returns a instizzle of your
body class whenever appropriate up in tha \f(CW\*(C`new_body_for(head)\*(C'\fR method.
.PP
Yo crazy-ass \*(L"body\*(R" class must inherit from MIME::Body (or some subclass of it),
and it must either provide (or inherit tha default for) tha following
methods...
.PP
Da default inherited method \fIshould suffice\fR fo' all these:
.PP
.Vb 3
\&    new
\&    binmode [ONOFF]
\&    path
.Ve
.PP
Da default inherited method \fImay suffice\fR fo' these yo, but like
therez a funky-ass betta implementation fo' yo' subclass.
.PP
.Vb 6
\&    init ARGS...
\&    as_lines
\&    as_string
\&    dup
\&    print
\&    purge
.Ve
.PP
Da default inherited method \fIwill probably not suffice\fR fo' these:
.PP
.Vb 1
\&    open
.Ve
.SH "NOTES"
.IX Header "NOTES"
One reason I didn't just use IO::Handle objects fo' message bodies was
that I wanted a \*(L"body\*(R" object ta be a gangbangin' form of straight-up encapsulated
program-persistent storage; dat is, I wanted playas ta be able ta write
code like all dis bullshit...
.PP
.Vb 7
\&   ### Git body handle from dis MIME message, n' read its data:
\&   $body = $entity\->bodyhandle;
\&   $IO = $body\->open("r");
\&   while (defined($_ = $IO\->getline)) {
\&       print STDOUT $_;
\&   }
\&   $IO\->close;
.Ve
.PP
\&...without requirin dat they know anythang mo' bout how tha fuck the
\&\f(CW$body\fR object is straight-up storin its data (disk file, scalar variable,
array variable, or whatever).
.PP
Storin tha body of each \s-1MIME\s0 message up in a persistently-open
IO::Handle was a possibilitizzle yo, but it seemed like a wack idea,
thankin bout dat a single multipart \s-1MIME\s0 message could easily suck up
all tha available file descriptors on some systems.  This risk increases
if tha user application is processin mo' than one \s-1MIME\s0 entitizzle at a time.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MIME::Tools
.SH "AUTHOR"
.IX Header "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
Dizzy F. Right back up in yo muthafuckin ass. Skoll (dfs@roaringpenguin.com) http://www.roaringpenguin.com
.PP
All muthafuckin rights reserved. Y'all KNOW dat shit, muthafucka!  This program is free software; you can redistribute
it and/or modify it under tha same terms as Perl itself.
.PP
Thanks ta Achim Bohnet fo' suggestin dat MIME::Parser not be restricted
to tha use of FileHandles.
.PP
#\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
1;
