.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_CTX_set_client_cert_cb 3"
.TH SSL_CTX_set_client_cert_cb 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_CTX_set_client_cert_cb, SSL_CTX_get_client_cert_cb \- handle client certificate callback function
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& void SSL_CTX_set_client_cert_cb(SSL_CTX *ctx, int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey));
\& int (*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx))(SSL *ssl, X509 **x509, EVP_PKEY **pkey);
\& int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISSL_CTX_set_client_cert_cb()\fR sets tha \fB\f(BIclient_cert_cb()\fB\fR callback, dat is
called when a cold-ass lil client certificate be axed by a server n' no certificate
was yet set fo' tha \s-1SSL\s0 object.
.PP
When \fB\f(BIclient_cert_cb()\fB\fR is \s-1NULL,\s0 no callback function is used.
.PP
\&\fISSL_CTX_get_client_cert_cb()\fR returns a pointa ta tha currently set callback
function.
.PP
\&\fIclient_cert_cb()\fR is tha application defined callback. If it wants to
set a cold-ass lil certificate, a cold-ass lil certificate/private key combination must be set
usin tha \fBx509\fR n' \fBpkey\fR arguments n' \*(L"1\*(R" must be returned. Y'all KNOW dat shit, muthafucka! The
certificate is ghon be installed tha fuck into \fBssl\fR, peep tha \s-1NOTES\s0 n' \s-1BUGS\s0 sections.
If no certificate should be set, \*(L"0\*(R" has ta be returned n' no certificate
will be sent fo' realz. A wack return value will suspend tha handshake n' the
handshake function will return immediatly. \fISSL_get_error\fR\|(3)
will return \s-1SSL_ERROR_WANT_X509_LOOKUP\s0 ta indicate, dat tha handshake was
suspended. Y'all KNOW dat shit, muthafucka! Da next call ta tha handshake function will again n' again n' again lead ta tha call
of \fIclient_cert_cb()\fR. Well shiiiit, it is tha thang of tha \fIclient_cert_cb()\fR ta store shiznit
about tha state of tha last call, if required ta continue.
.SH "NOTES"
.IX Header "NOTES"
Durin a handshake (or renegotiation) a server may request a cold-ass lil certificate
from tha client fo' realz. A client certificate must only be sent, when tha server
did bust tha request.
.PP
When a cold-ass lil certificate was set rockin the
\&\fISSL_CTX_use_certificate\fR\|(3) crew of functions,
it is ghon be busted ta tha server n' shit. Da \s-1TLS\s0 standard requires dat only a
certificate is sent, if it matches tha list of aaight CAs busted by the
server n' shit. This constraint is violated by tha default behavior of tha OpenSSL
library. Usin tha callback function it is possible ta implement a proper
selection routine or ta allow a user interaction ta chizzle tha certificate to
be sent.
.PP
If a cold-ass lil callback function is defined n' no certificate was yet defined fo' the
\&\s-1SSL\s0 object, tha callback function is ghon be called.
If tha callback function returns a cold-ass lil certificate, tha OpenSSL library
will try ta load tha private key n' certificate data tha fuck into tha \s-1SSL\s0
object rockin tha \fISSL_use_certificate()\fR n' \fISSL_use_private_key()\fR functions.
Thus it will permanently install tha certificate n' key fo' dis \s-1SSL\s0
object. Well shiiiit, it aint gonna be reset by callin \fISSL_clear\fR\|(3).
If tha callback returns no certificate, tha OpenSSL library aint gonna send
a certificate.
.SH "BUGS"
.IX Header "BUGS"
Da \fIclient_cert_cb()\fR cannot return a cold-ass lil complete certificate chain, it can
only return one client certificate. If tha chain only has a length of 2,
the root \s-1CA\s0 certificate may be omitted accordin ta tha \s-1TLS\s0 standard and
thus a standard conformin answer can be busted ta tha server n' shit. For a
longer chain, tha client must bust tha complete chain (with tha option
to leave up tha root \s-1CA\s0 certificate). This can only be accomplished by
either addin tha intermediate \s-1CA\s0 certificates tha fuck into tha trusted
certificate store fo' tha \s-1SSL_CTX\s0 object (resultin up in havin ta add
\&\s-1CA\s0 certificates dat otherwise maybe would not be trusted), or by adding
the chain certificates rockin the
\&\fISSL_CTX_add_extra_chain_cert\fR\|(3)
function, which is only available fo' tha \s-1SSL_CTX\s0 object as a whole n' that
therefore probably can only apply fo' one client certificate, making
the concept of tha callback function (to allow tha chizzle from several
certificates) questionable.
.PP
Once tha \s-1SSL\s0 object has been used up in conjunction wit tha callback function,
the certificate is ghon be set fo' tha \s-1SSL\s0 object n' aint gonna be cleared
even when \fISSL_clear\fR\|(3) is bein called. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is therefore
mandatory ta destroy tha \s-1SSL\s0 object rockin \fISSL_free\fR\|(3)
and create a freshly smoked up one ta return ta tha previous state.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIssl\fR\|(3), \fISSL_CTX_use_certificate\fR\|(3),
\&\fISSL_CTX_add_extra_chain_cert\fR\|(3),
\&\fISSL_get_client_CA_list\fR\|(3),
\&\fISSL_clear\fR\|(3), \fISSL_free\fR\|(3)
