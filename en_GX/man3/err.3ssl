.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "err 3"
.TH err 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
err \- error codes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/err.h>
\&
\& unsigned long ERR_get_error(void);
\& unsigned long ERR_peek_error(void);
\& unsigned long ERR_get_error_line(const char **file, int *line);
\& unsigned long ERR_peek_error_line(const char **file, int *line);
\& unsigned long ERR_get_error_line_data(const char **file, int *line,
\&         const char **data, int *flags);
\& unsigned long ERR_peek_error_line_data(const char **file, int *line,
\&         const char **data, int *flags);
\&
\& int ERR_GET_LIB(unsigned long e);
\& int ERR_GET_FUNC(unsigned long e);
\& int ERR_GET_REASON(unsigned long e);
\&
\& void ERR_clear_error(void);
\&
\& char *ERR_error_string(unsigned long e, char *buf);
\& const char *ERR_lib_error_string(unsigned long e);
\& const char *ERR_func_error_string(unsigned long e);
\& const char *ERR_reason_error_string(unsigned long e);
\&
\& void ERR_print_errors(BIO *bp);
\& void ERR_print_errors_fp(FILE *fp);
\&
\& void ERR_load_crypto_strings(void);
\& void ERR_free_strings(void);
\&
\& void ERR_remove_state(unsigned long pid);
\&
\& void ERR_put_error(int lib, int func, int reason, const char *file,
\&         int line);
\& void ERR_add_error_data(int num, ...);
\&
\& void ERR_load_strings(int lib,ERR_STRING_DATA str[]);
\& unsigned long ERR_PACK(int lib, int func, int reason);
\& int ERR_get_next_error_library(void);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
When a cold-ass lil call ta tha OpenSSL library fails, dis is probably signalled
by tha return value, n' a error code is stored up in a error queue
associated wit tha current thread. Y'all KNOW dat shit, muthafucka! Da \fBerr\fR library provides
functions ta obtain these error codes n' textual error lyrics.
.PP
Da \fIERR_get_error\fR\|(3) manpage raps bout how tha fuck to
access error codes.
.PP
Error codes contain shiznit bout where tha error occurred, and
what went wrong. \s-1\fIERR_GET_LIB\s0\fR\|(3) raps bout how tha fuck to
extract dis shiznit. I aint talkin' bout chicken n' gravy biatch fo' realz. A method ta obtain human-readable error
lyrics is busted lyrics bout up in \fIERR_error_string\fR\|(3).
.PP
\&\fIERR_clear_error\fR\|(3) can be used ta clear the
error queue.
.PP
Note dat \fIERR_remove_state\fR\|(3) should be used to
avoid memory leaks when threadz is terminated.
.SH "ADDING NEW ERROR CODES TO OPENSSL"
.IX Header "ADDING NEW ERROR CODES TO OPENSSL"
See \fIERR_put_error\fR\|(3) if you wanna record error codes up in the
OpenSSL error system from within yo' application.
.PP
Da remainder of dis section iz of interest only if you wanna add
new error codes ta OpenSSL or add error codes from external libraries.
.SS "Reportin errors"
.IX Subsection "Reportin errors"
Each sub-library has a specific macro \fIXXXerr()\fR dat is used ta report
errors. Its first argument be a gangbangin' function code \fB\s-1XXX_F_...\s0\fR, tha second
argument be a reason code \fB\s-1XXX_R_...\s0\fR. Function codes is derived
from tha function names; reason codes consist of textual error
descriptions. For example, tha function \fIssl23_read()\fR reports a
\&\*(L"handshake failure\*(R" as bigs up:
.PP
.Vb 1
\& SSLerr(SSL_F_SSL23_READ, SSL_R_SSL_HANDSHAKE_FAILURE);
.Ve
.PP
Function n' reason codes should consist of upper case characters,
numbers n' underscores only. Da error file generation script translates
function codes tha fuck into function names by lookin up in tha header files
for a appropriate function name, if none is found it just uses
the capitalized form like fuckin \*(L"\s-1SSL23_READ\*(R"\s0 up in tha above example.
.PP
Da trailin section of a reason code (afta tha \*(L"_R_\*(R") is translated
into lower case n' underscores chizzled ta spaces.
.PP
When yo ass is rockin freshly smoked up function or reason codes, run \fBmake errors\fR.
Da necessary \fB#define\fRs will then automatically be added ta the
sub-libraryz header file.
.PP
Although a library will normally report errors rockin its own specific
XXXerr macro, another libraryz macro can be used. Y'all KNOW dat shit, muthafucka! This is normally
only done when a library wants ta include \s-1ASN1\s0 code which must use
the \fIASN1err()\fR macro.
.SS "Addin freshly smoked up libraries"
.IX Subsection "Addin freshly smoked up libraries"
When addin a freshly smoked up sub-library ta OpenSSL, assign it a library number
\&\fB\s-1ERR_LIB_XXX\s0\fR, define a macro \fIXXXerr()\fR (both up in \fBerr.h\fR), add its
name ta \fBERR_str_libraries[]\fR (in \fBcrypto/err/err.c\fR), n' add
\&\f(CW\*(C`ERR_load_XXX_strings()\*(C'\fR ta tha \fIERR_load_crypto_strings()\fR function
(in \fBcrypto/err/err_all.c\fR). Finally, add a entry
.PP
.Vb 1
\& L      XXX     xxx.h   xxx_err.c
.Ve
.PP
to \fBcrypto/err/openssl.ec\fR, n' add \fBxxx_err.c\fR ta tha Makefile.
Hustlin \fBmake errors\fR will then generate a gangbangin' file \fBxxx_err.c\fR, and
add all error codes used up in tha library ta \fBxxx.h\fR.
.PP
Additionally tha library include file must gotz a cold-ass lil certain form.
Typically it will initially be lookin like this:
.PP
.Vb 2
\& #ifndef HEADER_XXX_H
\& #define HEADER_XXX_H
\&
\& #ifdef _\|_cplusplus
\& extern "C" {
\& #endif
\&
\& /* Include filez */
\&
\& #include <openssl/bio.h>
\& #include <openssl/x509.h>
\&
\& /* Macros, structures n' function prototypes */
\&
\&
\& /* BEGIN ERROR CODES */
.Ve
.PP
Da \fB\s-1BEGIN ERROR CODES\s0\fR sequence is used by tha error code
generation script as tha point ta place freshly smoked up error codes, any text
afta dis point is ghon be overwritten when \fBmake errors\fR is run.
Da closin #endif etc is ghon be automatically added by tha script.
.PP
Da generated C error code file \fBxxx_err.c\fR will load tha header
filez \fBstdio.h\fR, \fBopenssl/err.h\fR n' \fBopenssl/xxx.h\fR so the
header file must load any additionizzle header filez containin any
definitions it uses.
.SH "USING ERROR CODES IN EXTERNAL LIBRARIES"
.IX Header "USING ERROR CODES IN EXTERNAL LIBRARIES"
It be also possible ta use OpenSSLz error code scheme up in external
libraries. Put ya muthafuckin choppers up if ya feel dis! Da library need ta load its own codes n' call tha OpenSSL
error code insertion script \fBmkerr.pl\fR explicitly ta add codes to
the header file n' generate tha C error code file. This will normally
be done if tha external library need ta generate freshly smoked up \s-1ASN1\s0 structures
but it can also be used ta add mo' general purpose error code handling.
.PP
\&\s-1TBA\s0 mo' details
.SH "INTERNALS"
.IX Header "INTERNALS"
Da error queues is stored up in a hash table wit one \fB\s-1ERR_STATE\s0\fR
entry fo' each pid. Y'all KNOW dat shit, muthafucka! \fIERR_get_state()\fR returns tha current thread's
\&\fB\s-1ERR_STATE\s0\fR fo' realz. An \fB\s-1ERR_STATE\s0\fR can hold up ta \fB\s-1ERR_NUM_ERRORS\s0\fR error
codes. When mo' error codes is added, tha oldschool ones is overwritten,
on tha assumption dat da most thugged-out recent errors is most blingin.
.PP
Error strings is also stored up in hash table. Da hash tablez can
be obtained by callin ERR_get_err_state_table(void) and
ERR_get_string_table(void) respectively.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fICRYPTO_set_id_callback\fR\|(3),
\&\fICRYPTO_set_locking_callback\fR\|(3),
\&\fIERR_get_error\fR\|(3),
\&\s-1\fIERR_GET_LIB\s0\fR\|(3),
\&\fIERR_clear_error\fR\|(3),
\&\fIERR_error_string\fR\|(3),
\&\fIERR_print_errors\fR\|(3),
\&\fIERR_load_crypto_strings\fR\|(3),
\&\fIERR_remove_state\fR\|(3),
\&\fIERR_put_error\fR\|(3),
\&\fIERR_load_strings\fR\|(3),
\&\fISSL_get_error\fR\|(3)
