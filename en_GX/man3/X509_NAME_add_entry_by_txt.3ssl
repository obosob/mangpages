.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "X509_NAME_add_entry_by_txt 3"
.TH X509_NAME_add_entry_by_txt 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
X509_NAME_add_entry_by_txt, X509_NAME_add_entry_by_OBJ, X509_NAME_add_entry_by_NID,
X509_NAME_add_entry, X509_NAME_delete_entry \- X509_NAME modification functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/x509.h>
\&
\& int X509_NAME_add_entry_by_txt(X509_NAME *name, const char *field, int type, const unsigned char *bytes, int len, int loc, int set);
\&
\& int X509_NAME_add_entry_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, int type, unsigned char *bytes, int len, int loc, int set);
\&
\& int X509_NAME_add_entry_by_NID(X509_NAME *name, int nid, int type, unsigned char *bytes, int len, int loc, int set);
\&
\& int X509_NAME_add_entry(X509_NAME *name,X509_NAME_ENTRY *ne, int loc, int set);
\&
\& X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIX509_NAME_add_entry_by_txt()\fR, \fIX509_NAME_add_entry_by_OBJ()\fR and
\&\fIX509_NAME_add_entry_by_NID()\fR add a gangbangin' field whose name is defined
by a strang \fBfield\fR, a object \fBobj\fR or a \s-1NID \s0\fBnid\fR respectively.
Da field value ta be added is up in \fBbytes\fR of length \fBlen\fR. If
\&\fBlen\fR is \-1 then tha field length is calculated internally using
strlen(bytes).
.PP
Da type of field is determined by \fBtype\fR which can either be a
definizzle of tha type of \fBbytes\fR (like fuckin \fB\s-1MBSTRING_ASC\s0\fR) or a
standard \s-1ASN1\s0 type (like fuckin \fBV_ASN1_IA5STRING\fR). Da freshly smoked up entry is
added ta a posizzle determined by \fBloc\fR n' \fBset\fR.
.PP
\&\fIX509_NAME_add_entry()\fR addz a cold-ass lil copy of \fBX509_NAME_ENTRY\fR structure \fBne\fR
to \fBname\fR. Da freshly smoked up entry be added ta a posizzle determined by \fBloc\fR
and \fBset\fR. Right back up in yo muthafuckin ass. Since a cold-ass lil copy of \fBne\fR be added \fBne\fR must be freed up after
the call.
.PP
\&\fIX509_NAME_delete_entry()\fR deletes a entry from \fBname\fR at position
\&\fBloc\fR. Da deleted entry is returned n' must be freed up.
.SH "NOTES"
.IX Header "NOTES"
Da use of strang types like fuckin \fB\s-1MBSTRING_ASC\s0\fR or \fB\s-1MBSTRING_UTF8\s0\fR
is straight fuckin recommened fo' tha \fBtype\fR parameter n' shit. This allows the
internal code ta erectly determine tha type of tha field n' to
apply length checks accordin ta tha relevant standards. This is
done rockin \fIASN1_STRING_set_by_NID()\fR.
.PP
If instead a \s-1ASN1\s0 type is used no checks is performed n' the
supplied data up in \fBbytes\fR is used directly.
.PP
In \fIX509_NAME_add_entry_by_txt()\fR tha \fBfield\fR strang represents
the field name rockin OBJ_txt2obj(field, 0).
.PP
Da \fBloc\fR n' \fBset\fR parametas determine where a freshly smoked up entry should
be added. Y'all KNOW dat shit, muthafucka! For almost all applications \fBloc\fR can be set ta \-1 n' \fBset\fR
to 0. This addz a freshly smoked up entry ta tha end of \fBname\fR as a single valued
RelativeDistinguishedName (\s-1RDN\s0).
.PP
\&\fBloc\fR straight-up determines tha index where tha freshly smoked up entry is inserted:
if it is \-1 it be appended.
.PP
\&\fBset\fR determines how tha fuck tha freshly smoked up type be added. Y'all KNOW dat shit, muthafucka! If it is zero a
new \s-1RDN\s0 is pimped.
.PP
If \fBset\fR is \-1 or 1 it be added ta tha previous or next \s-1RDN\s0
structure respectively. This will then be a multivalued \s-1RDN:\s0
since multivalues RDNs is straight-up seldom used \fBset\fR be almost
always set ta zero.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Smoke a \fBX509_NAME\fR structure:
.PP
\&\*(L"C=UK, O=Disorganized Organization, CN=Joe Bloggs\*(R"
.PP
.Vb 10
\& X509_NAME *nm;
\& nm = X509_NAME_new();
\& if (nm == NULL)
\&        /* Some error */
\& if (!X509_NAME_add_entry_by_txt(nm, MBSTRING_ASC,
\&                        "C", "UK", \-1, \-1, 0))
\&        /* Error */
\& if (!X509_NAME_add_entry_by_txt(nm, MBSTRING_ASC,
\&                        "O", "Disorganized Organization", \-1, \-1, 0))
\&        /* Error */
\& if (!X509_NAME_add_entry_by_txt(nm, MBSTRING_ASC,
\&                        "CN", "Joe Bloggs", \-1, \-1, 0))
\&        /* Error */
.Ve
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIX509_NAME_add_entry_by_txt()\fR, \fIX509_NAME_add_entry_by_OBJ()\fR,
\&\fIX509_NAME_add_entry_by_NID()\fR n' \fIX509_NAME_add_entry()\fR return 1 for
success of 0 if a error occurred.
.PP
\&\fIX509_NAME_delete_entry()\fR returns either tha deleted \fBX509_NAME_ENTRY\fR
structure of \fB\s-1NULL\s0\fR if a error occurred.
.SH "BUGS"
.IX Header "BUGS"
\&\fBtype\fR can still be set ta \fBV_ASN1_APP_CHOOSE\fR ta use a
different algorithm ta determine field types. Right back up in yo muthafuckin ass. Since dis form do
not KNOW multicharacta types, performs no length checks and
can result up in invalid field types its use is straight fuckin discouraged.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3), \fId2i_X509_NAME\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
