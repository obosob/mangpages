.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::Spec::Unix 3"
.TH File::Spec::Unix 3 "2013-01-16" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Spec::Unix \- File::Spec fo' Unix, base fo' other File::Spec modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& require File::Spec::Unix; # Done automatically by File::Spec
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Methodz fo' manipulatin file justifications.  Other File::Spec
modules, like fuckin File::Spec::Mac, inherit from File::Spec::Unix and
override specific methods.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fIcanonpath()\fR" 2
.IX Item "canonpath()"
No physical check on tha filesystem yo, but a logical cleanup of a
path. On \s-1UNIX\s0 eliminates successive slashes n' successive \*(L"/.\*(R".
.Sp
.Vb 1
\&    $cpath = File::Spec\->canonpath( $path ) ;
.Ve
.Sp
Note dat dis do *not* collapse \fIx/../y\fR sections tha fuck into \fIy\fR.  This
is by design. I aint talkin' bout chicken n' gravy biatch.  If \fI/foo\fR on yo' system be a symlink ta \fI/bar/baz\fR,
then \fI/foo/../quux\fR is straight-up \fI/bar/quux\fR, not \fI/quux\fR as a naive
\&\fI../\fR\-removal would give yo thugged-out ass.  If you wanna do dis kind of
processing, you probably want \f(CW\*(C`Cwd\*(C'\fRz \f(CW\*(C`realpath()\*(C'\fR function to
actually traverse tha filesystem cleanin up paths like all dis bullshit.
.IP "\fIcatdir()\fR" 2
.IX Item "catdir()"
Concatenate two or mo' directory names ta form a cold-ass lil complete path ending
with a gangbangin' finger-lickin' directory. But remove tha trailin slash from tha resulting
string, cuz it don't look good, aint necessary n' confuses
\&\s-1OS2.\s0 Of course, if dis is tha root directory, don't cut off the
trailin slash :\-)
.IP "catfile" 2
.IX Item "catfile"
Concatenate one or mo' directory names n' a gangbangin' filename ta form a
complete path endin wit a gangbangin' filename
.IP "curdir" 2
.IX Item "curdir"
Returns a strang representation of tha current directory.  \*(L".\*(R" on \s-1UNIX.\s0
.IP "devnull" 2
.IX Item "devnull"
Returns a strang representation of tha null device. \*(L"/dev/null\*(R" on \s-1UNIX.\s0
.IP "rootdir" 2
.IX Item "rootdir"
Returns a strang representation of tha root directory.  \*(L"/\*(R" on \s-1UNIX.\s0
.IP "tmpdir" 2
.IX Item "tmpdir"
Returns a strang representation of tha straight-up original gangsta writable directory from
the followin list or tha current directory if none from tha list are
writable:
.Sp
.Vb 2
\&    $ENV{TMPDIR}
\&    /tmp
.Ve
.Sp
If hustlin under taint mode, n' if \f(CW$ENV\fR{\s-1TMPDIR\s0}
is tainted, it aint used.
.IP "updir" 2
.IX Item "updir"
Returns a strang representation of tha parent directory.  \*(L"..\*(R" on \s-1UNIX.\s0
.IP "no_upwards" 2
.IX Item "no_upwards"
Given a list of file names, strip up dem dat refer ta a parent
directory. (Do not strip symlinks, only '.', '..', n' equivalents.)
.IP "case_tolerant" 2
.IX Item "case_tolerant"
Returns a legit or false value indicating, respectively, dat alphabetic
is not or is dope when comparin file justifications.
.IP "file_name_is_absolute" 2
.IX Item "file_name_is_absolute"
Takes as argument a path n' returns legit if it be a absolute path.
.Sp
This do not consult tha local filesystem on Unix, Win32, \s-1OS/2\s0 or Mac 
\&\s-1OS \s0(Classic).  It do consult tha hustlin environment fo' \s-1VMS \s0(see
\&\*(L"file_name_is_absolute\*(R" up in File::Spec::VMS).
.IP "path" 2
.IX Item "path"
Takes no argument, returns tha environment variable \s-1PATH\s0 as a array.
.IP "join" 2
.IX Item "join"
join is tha same ol' dirty as catfile.
.IP "splitpath" 2
.IX Item "splitpath"
.Vb 3
\&    ($volume,$directories,$file) = File::Spec\->splitpath( $path );
\&    ($volume,$directories,$file) = File::Spec\->splitpath( $path,
\&                                                          $no_file );
.Ve
.Sp
Splits a path tha fuck into volume, directory, n' filename portions. On systems
with no concept of volume, returns '' fo' volume.
.Sp
For systems wit no syntax differentiatin filenames from directories, 
assumes dat tha last file be a path unless \f(CW$no_file\fR is legit or a 
trailin separator or /. or /.. is present. On Unix dis means dat \f(CW$no_file\fR
true make dis return ( '', \f(CW$path\fR, '' ).
.Sp
Da directory portion may or may not be returned wit a trailin '/'.
.Sp
Da thangs up in dis biatch can be passed ta \*(L"\fIcatpath()\fR\*(R" ta git back a path equivalent to
(usually identical to) tha original gangsta path.
.IP "splitdir" 2
.IX Item "splitdir"
Da opposite of \*(L"\fIcatdir()\fR\*(R".
.Sp
.Vb 1
\&    @dirs = File::Spec\->splitdir( $directories );
.Ve
.Sp
\&\f(CW$directories\fR must be only tha directory portion of tha path on systems 
that have tha concept of a volume or dat have path syntax dat differentiates
filez from directories.
.Sp
Unlike just splittin tha directories on tha separator, empty
directory names (\f(CW\*(Aq\*(Aq\fR) can be returned, cuz these is significant
on some OSs.
.Sp
On Unix,
.Sp
.Vb 1
\&    File::Spec\->splitdir( "/a/b//c/" );
.Ve
.Sp
Yields:
.Sp
.Vb 1
\&    ( \*(Aq\*(Aq, \*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aq\*(Aq, \*(Aqc\*(Aq, \*(Aq\*(Aq )
.Ve
.IP "\fIcatpath()\fR" 2
.IX Item "catpath()"
Takes volume, directory n' file portions n' returns a entire path. Under
Unix, \f(CW$volume\fR is ignored, n' directory n' file is concatenated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  A '/' is
inserted if needed (though if tha directory portion don't start with
\&'/' it aint added).  On other OSs, \f(CW$volume\fR is significant.
.IP "abs2rel" 2
.IX Item "abs2rel"
Takes a thugged-out destination path n' a optionizzle base path returns a relatizzle path
from tha base path ta tha destination path:
.Sp
.Vb 2
\&    $rel_path = File::Spec\->abs2rel( $path ) ;
\&    $rel_path = File::Spec\->abs2rel( $path, $base ) ;
.Ve
.Sp
If \f(CW$base\fR aint present or '', then \fIcwd()\fR is used. Y'all KNOW dat shit, muthafucka! If \f(CW$base\fR is
relative, then it is converted ta absolute form using
\&\*(L"\fIrel2abs()\fR\*(R". This means dat it is taken ta be relatizzle to
\&\fIcwd()\fR.
.Sp
On systems dat gotz a grammar dat indicates filenames, dis ignores tha 
\&\f(CW$base\fR filename. Otherwise all path components is assumed ta be
directories.
.Sp
If \f(CW$path\fR is relative, it is converted ta absolute form rockin \*(L"\fIrel2abs()\fR\*(R".
This means dat it is taken ta be relatizzle ta \fIcwd()\fR.
.Sp
No checks against tha filesystem is made, so tha result may not be erect if
\&\f(CW$base\fR gotz nuff symbolic links.  (Apply
\&\fICwd::abs_path()\fR beforehand if that
is a cold-ass lil concern.)  On \s-1VMS,\s0 there is interaction wit tha hustlin environment, as
logicals n' macros is expanded.
.Sp
Based on code freestyled by Shigio Yamaguchi.
.IP "\fIrel2abs()\fR" 2
.IX Item "rel2abs()"
Converts a relatizzle path ta a absolute path.
.Sp
.Vb 2
\&    $abs_path = File::Spec\->rel2abs( $path ) ;
\&    $abs_path = File::Spec\->rel2abs( $path, $base ) ;
.Ve
.Sp
If \f(CW$base\fR aint present or '', then \fIcwd()\fR is used. Y'all KNOW dat shit, muthafucka! If \f(CW$base\fR is
relative, then it is converted ta absolute form using
\&\*(L"\fIrel2abs()\fR\*(R". This means dat it is taken ta be relatizzle to
\&\fIcwd()\fR.
.Sp
On systems dat gotz a grammar dat indicates filenames, dis ignores
the \f(CW$base\fR filename. Otherwise all path components is assumed ta be
directories.
.Sp
If \f(CW$path\fR be absolute, it is cleaned up n' returned rockin \*(L"\fIcanonpath()\fR\*(R".
.Sp
No checks against tha filesystem is made.  On \s-1VMS,\s0 there is
interaction wit tha hustlin environment, as logicals and
macros is expanded.
.Sp
Based on code freestyled by Shigio Yamaguchi.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 by tha Perl 5 Porters.  All muthafuckin rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
.PP
Please submit bug reports n' patches ta perlbug@perl.org.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::Spec
