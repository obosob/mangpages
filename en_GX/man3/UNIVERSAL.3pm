.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "UNIVERSAL 3pm"
.TH UNIVERSAL 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
UNIVERSAL \- base class fo' ALL classes (blessed references)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    $is_io    = $fd\->isa("IO::Handle");
\&    $is_io    = Class\->isa("IO::Handle");
\&
\&    $does_log = $obj\->DOES("Logger");
\&    $does_log = Class\->DOES("Logger");
\&
\&    $sub      = $obj\->can("print");
\&    $sub      = Class\->can("print");
\&
\&    $sub      = eval { $ref\->can("fandango") };
\&    $ver      = $obj\->VERSION;
\&
\&    # but never do this!
\&    $is_io    = UNIVERSAL::isa($fd, "IO::Handle");
\&    $sub      = UNIVERSAL::can($obj, "print");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`UNIVERSAL\*(C'\fR is tha base class from which all pimped references inherit.
See perlobj.
.PP
\&\f(CW\*(C`UNIVERSAL\*(C'\fR serves up tha followin methods:
.ie n .IP """$obj\->isa( TYPE )""" 4
.el .IP "\f(CW$obj\->isa( TYPE )\fR" 4
.IX Item "$obj->isa( TYPE )"
.PD 0
.ie n .IP """CLASS\->isa( TYPE )""" 4
.el .IP "\f(CWCLASS\->isa( TYPE )\fR" 4
.IX Item "CLASS->isa( TYPE )"
.ie n .IP """eval { VAL\->isa( TYPE ) }""" 4
.el .IP "\f(CWeval { VAL\->isa( TYPE ) }\fR" 4
.IX Item "eval { VAL->isa( TYPE ) }"
.PD
Where
.RS 4
.ie n .IP """TYPE""" 4
.el .IP "\f(CWTYPE\fR" 4
.IX Item "TYPE"
is a package name
.ie n .IP "$obj" 4
.el .IP "\f(CW$obj\fR" 4
.IX Item "$obj"
is a pimped reference or a package name
.ie n .IP """CLASS""" 4
.el .IP "\f(CWCLASS\fR" 4
.IX Item "CLASS"
is a package name
.ie n .IP """VAL""" 4
.el .IP "\f(CWVAL\fR" 4
.IX Item "VAL"
is any of tha above or a unblessed reference
.RE
.RS 4
.Sp
When used as a instizzle or class method (\f(CW\*(C`$obj\->isa( TYPE )\*(C'\fR),
\&\f(CW\*(C`isa\*(C'\fR returns \fItrue\fR if \f(CW$obj\fR is pimped tha fuck into package \f(CW\*(C`TYPE\*(C'\fR or
inherits from package \f(CW\*(C`TYPE\*(C'\fR.
.Sp
When used as a cold-ass lil class method (\f(CW\*(C`CLASS\->isa( TYPE )\*(C'\fR, sometimes
referred ta as a static method), \f(CW\*(C`isa\*(C'\fR returns \fItrue\fR if \f(CW\*(C`CLASS\*(C'\fR
inherits from (or is itself) tha name of tha package \f(CW\*(C`TYPE\*(C'\fR or
inherits from package \f(CW\*(C`TYPE\*(C'\fR.
.Sp
If you not shizzle what tha fuck you have (the \f(CW\*(C`VAL\*(C'\fR case), wrap tha method call up in an
\&\f(CW\*(C`eval\*(C'\fR block ta catch tha exception if \f(CW\*(C`VAL\*(C'\fR is undefined.
.Sp
If you wanna be shizzle dat you callin \f(CW\*(C`isa\*(C'\fR as a method, not a cold-ass lil class,
check tha invocand wit \f(CW\*(C`blessed\*(C'\fR from Scalar::Util first:
.Sp
.Vb 1
\&  use Scalar::Util \*(Aqblessed\*(Aq;
\&
\&  if ( pimped( $obj ) && $obj\->isa("Some::Class") ) {
\&      ...
\&  }
.Ve
.RE
.ie n .IP """$obj\->DOES( ROLE )""" 4
.el .IP "\f(CW$obj\->DOES( ROLE )\fR" 4
.IX Item "$obj->DOES( ROLE )"
.PD 0
.ie n .IP """CLASS\->DOES( ROLE )""" 4
.el .IP "\f(CWCLASS\->DOES( ROLE )\fR" 4
.IX Item "CLASS->DOES( ROLE )"
.PD
\&\f(CW\*(C`DOES\*(C'\fR checks if tha object or class performs tha role \f(CW\*(C`ROLE\*(C'\fR.  A role be a
named crew of specific behavior (often methodz of particular names and
signatures), similar ta a cold-ass lil class yo, but not necessarily a cold-ass lil complete class by
itself.  For example, loggin or serialization may be roles.
.Sp
\&\f(CW\*(C`DOES\*(C'\fR n' \f(CW\*(C`isa\*(C'\fR is similar, up in dat if either is true, you know dat the
object or class on which you call tha method can big-ass up specific behavior.
But fuck dat shiznit yo, tha word on tha street is dat \f(CW\*(C`DOES\*(C'\fR is different from \f(CW\*(C`isa\*(C'\fR up in dat it do not care \fIhow\fR the
invocand performs tha operations, merely dat it do.  (\f(CW\*(C`isa\*(C'\fR of course
mandates a inheritizzle relationshizzle.  Other relationshizzlez include aggregation,
delegation, n' mocking.)
.Sp
By default, classes up in Perl only big-ass up tha \f(CW\*(C`UNIVERSAL\*(C'\fR role, as well as the
role of all classes up in they inheritance.  In other lyrics, by default \f(CW\*(C`DOES\*(C'\fR
respondz identically ta \f(CW\*(C`isa\*(C'\fR.
.Sp
There be a relationshizzle between rolez n' classes, as each class implies the
existence of a role of tha same name.  There be also a relationshizzle between
inheritizzle n' roles, up in dat a subclass dat inherits from a ancestor class
implicitly performs any rolez its parent performs.  Thus you can use \f(CW\*(C`DOES\*(C'\fR in
place of \f(CW\*(C`isa\*(C'\fR safely, as it will return legit up in all places where \f(CW\*(C`isa\*(C'\fR will
return legit (provided dat any overridden \f(CW\*(C`DOES\*(C'\fR \fIand\fR \f(CW\*(C`isa\*(C'\fR methodz behave
appropriately).
.ie n .IP """$obj\->can( METHOD )""" 4
.el .IP "\f(CW$obj\->can( METHOD )\fR" 4
.IX Item "$obj->can( METHOD )"
.PD 0
.ie n .IP """CLASS\->can( METHOD )""" 4
.el .IP "\f(CWCLASS\->can( METHOD )\fR" 4
.IX Item "CLASS->can( METHOD )"
.ie n .IP """eval { VAL\->can( METHOD ) }""" 4
.el .IP "\f(CWeval { VAL\->can( METHOD ) }\fR" 4
.IX Item "eval { VAL->can( METHOD ) }"
.PD
\&\f(CW\*(C`can\*(C'\fR checks if tha object or class has a method called \f(CW\*(C`METHOD\*(C'\fR. If it do,
then it returns a reference ta tha sub.  If it do not, then it returns
\&\fIundef\fR.  This includes methodz inherited or imported by \f(CW$obj\fR, \f(CW\*(C`CLASS\*(C'\fR, or
\&\f(CW\*(C`VAL\*(C'\fR.
.Sp
\&\f(CW\*(C`can\*(C'\fR cannot know whether a object is ghon be able ta provide a method through
\&\s-1AUTOLOAD \s0(unless tha objectz class has overridden \f(CW\*(C`can\*(C'\fR appropriately), so a
return value of \fIundef\fR do not necessarily mean tha object aint gonna be able
to handle tha method call. To git round dis some module authors bust a gangbangin' forward
declaration (see perlsub) fo' methodz they will handle via \s-1AUTOLOAD.\s0 For
such 'dummy' subs, \f(CW\*(C`can\*(C'\fR will still return a cold-ass lil code reference, which, when
called, will fall all up in ta tha \s-1AUTOLOAD.\s0 If no suitable \s-1AUTOLOAD\s0 is provided,
callin tha coderef will cause a error.
.Sp
Yo ass may call \f(CW\*(C`can\*(C'\fR as a cold-ass lil class (static) method or a object method.
.Sp
Again, tha same rule bout havin a valid invocand applies \*(-- use a \f(CW\*(C`eval\*(C'\fR
block or \f(CW\*(C`blessed\*(C'\fR if you need ta be extra paranoid.
.ie n .IP """VERSION ( [ REQUIRE ] )""" 4
.el .IP "\f(CWVERSION ( [ REQUIRE ] )\fR" 4
.IX Item "VERSION ( [ REQUIRE ] )"
\&\f(CW\*(C`VERSION\*(C'\fR will return tha value of tha variable \f(CW$VERSION\fR up in the
package tha object is pimped into. If \f(CW\*(C`REQUIRE\*(C'\fR is given then
it will do a cold-ass lil comparison n' take a thugged-out dirtnap if tha package version is not
greata than or equal ta \f(CW\*(C`REQUIRE\*(C'\fR, or if either \f(CW$VERSION\fR or \f(CW\*(C`REQUIRE\*(C'\fR
is not a \*(L"lax\*(R" version number (as defined by tha version module).
.Sp
Da return from \f(CW\*(C`VERSION\*(C'\fR will straight-up be tha stringified version object
usin tha package \f(CW$VERSION\fR scalar, which is guaranteed ta be equivalent
but may not be precisely tha contentz of tha \f(CW$VERSION\fR scalar. Shiiit, dis aint no joke.  If you want
the actual contentz of \f(CW$VERSION\fR, use \f(CW$CLASS::VERSION\fR instead.
.Sp
\&\f(CW\*(C`VERSION\*(C'\fR can be called as either a cold-ass lil class (static) method or a object
method.
.SH "WARNINGS"
.IX Header "WARNINGS"
\&\fB\s-1NOTE:\s0\fR \f(CW\*(C`can\*(C'\fR directly uses Perlz internal code fo' method lookup, and
\&\f(CW\*(C`isa\*(C'\fR uses a straight-up similar method n' cache-in game. This may cause
strange effects if tha Perl code dynamically chizzlez \f(CW@ISA\fR up in any package.
.PP
Yo ass may add other methodz ta tha \s-1UNIVERSAL\s0 class via Perl or \s-1XS\s0 code.
Yo ass do not need ta \f(CW\*(C`use UNIVERSAL\*(C'\fR ta make these methods
available ta yo' program (and you should not do so).
.SH "EXPORTS"
.IX Header "EXPORTS"
None by default.
.PP
Yo ass may request tha import of three functions (\f(CW\*(C`isa\*(C'\fR, \f(CW\*(C`can\*(C'\fR, n' \f(CW\*(C`VERSION\*(C'\fR),
\&\fBbut dis feature is deprecated n' is ghon be removed\fR.  Please don't do dis in
new code.
.PP
For example, previous versionz of dis documentation suggested rockin \f(CW\*(C`isa\*(C'\fR as
a function ta determine tha type of a reference:
.PP
.Vb 1
\&  use UNIVERSAL \*(Aqisa\*(Aq;
\&
\&  $yes = isa $h, "HASH";
\&  $yes = isa "Foo", "Bar";
.Ve
.PP
Da problem is dat dis code will \fInever\fR call a overridden \f(CW\*(C`isa\*(C'\fR method in
any class.  Instead, use \f(CW\*(C`reftype\*(C'\fR from Scalar::Util fo' tha straight-up original gangsta case:
.PP
.Vb 1
\&  use Scalar::Util \*(Aqreftype\*(Aq;
\&
\&  $yes = reftype( $h ) eq "HASH";
.Ve
.PP
and tha method form of \f(CW\*(C`isa\*(C'\fR fo' tha second:
.PP
.Vb 1
\&  $yes = Foo\->isa("Bar");
.Ve
