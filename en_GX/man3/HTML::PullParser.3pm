.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::PullParser 3"
.TH HTML::PullParser 3 "2013-03-25" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::PullParser \- Alternatizzle HTML::Parser intercourse
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTML::PullParser;
\&
\& $p = HTML::PullParser\->new(file => "index.html",
\&                            start => \*(Aqevent, tagname, @attr\*(Aq,
\&                            end   => \*(Aqevent, tagname\*(Aq,
\&                            ignore_elements => [qw(script style)],
\&                           ) || take a thugged-out dirtnap "Can\*(Aqt open: $!";
\& while (my $token = $p\->get_token) {
\&     #...do suttin' wit $token
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da HTML::PullParser be a alternatizzle intercourse ta tha HTML::Parser class.
It basically turns tha HTML::Parser inside out.  Yo ass associate a gangbangin' file
(or any IO::Handle object or string) wit tha parser at construction time and
then repeatedly call \f(CW$parser\fR\->get_token ta obtain tha tags n' text
found up in tha parsed document.
.PP
Da followin methodz is provided:
.ie n .IP "$p = HTML::PullParser\->new( file => $file, %options )" 4
.el .IP "\f(CW$p\fR = HTML::PullParser\->new( file => \f(CW$file\fR, \f(CW%options\fR )" 4
.IX Item "$p = HTML::PullParser->new( file => $file, %options )"
.PD 0
.ie n .IP "$p = HTML::PullParser\->new( doc => \e$doc, %options )" 4
.el .IP "\f(CW$p\fR = HTML::PullParser\->new( doc => \e$doc, \f(CW%options\fR )" 4
.IX Item "$p = HTML::PullParser->new( doc => $doc, %options )"
.PD
A \f(CW\*(C`HTML::PullParser\*(C'\fR can be made ta parse from either a gangbangin' file or a
literal document based on whether tha \f(CW\*(C`file\*(C'\fR or \f(CW\*(C`doc\*(C'\fR option is
passed ta tha parserz constructor.
.Sp
Da \f(CW\*(C`file\*(C'\fR passed up in can either be a gangbangin' file name or a gangbangin' file handle
object.  If a gangbangin' file name is passed, n' it can't be opened fo' reading,
then tha constructor will return a undefined value n' $!  will tell
you why it failed. Y'all KNOW dat shit, muthafucka!  Otherwise tha argument is taken ta be some object
that tha \f(CW\*(C`HTML::PullParser\*(C'\fR can \fIread()\fR from when it needz mo' data.
Da stream is ghon be \fIread()\fR until \s-1EOF,\s0 but not closed.
.Sp
A \f(CW\*(C`doc\*(C'\fR can be passed plain or as a reference
to a scalar. Shiiit, dis aint no joke.  If a reference is passed then tha value of dis scalar
should not be chizzled before all tokens done been extracted.
.Sp
Next tha shiznit ta be returned fo' tha different token types must
be set up.  This is done by simply associatin a argspec (as defined
in HTML::Parser) wit tha events you have a interest in. I aint talkin' bout chicken n' gravy biatch.  For
instance, if you want \f(CW\*(C`start\*(C'\fR tokens ta be reported as tha string
\&\f(CW\*(AqS\*(Aq\fR followed by tha tagname n' tha attributes you might pass an
\&\f(CW\*(C`start\*(C'\fR\-option like this:
.Sp
.Vb 5
\&   $p = HTML::PullParser\->new(
\&          doc   => $document_to_parse,
\&          start => \*(Aq"S", tagname, @attr\*(Aq,
\&          end   => \*(Aq"E", tagname\*(Aq,
\&        );
.Ve
.Sp
At last other \f(CW\*(C`HTML::Parser\*(C'\fR options, like \f(CW\*(C`ignore_tags\*(C'\fR, and
\&\f(CW\*(C`unbroken_text\*(C'\fR, can be passed in. I aint talkin' bout chicken n' gravy biatch.  Note dat you should not use the
\&\fIevent\fR_h options ta set up parser handlezs.  That would confuse the
inner logic of \f(CW\*(C`HTML::PullParser\*(C'\fR.
.ie n .IP "$token = $p\->get_token" 4
.el .IP "\f(CW$token\fR = \f(CW$p\fR\->get_token" 4
.IX Item "$token = $p->get_token"
This method will return tha next \fItoken\fR found up in tha \s-1HTML\s0 document,
or \f(CW\*(C`undef\*(C'\fR all up in tha end of tha document.  Da token is returned as an
array reference.  Da content of dis array match tha argspec set up
durin \f(CW\*(C`HTML::PullParser\*(C'\fR construction.
.ie n .IP "$p\->unget_token( @tokens )" 4
.el .IP "\f(CW$p\fR\->unget_token( \f(CW@tokens\fR )" 4
.IX Item "$p->unget_token( @tokens )"
If you smoke up you have read too nuff tokens you can push dem back,
so dat they is returned again n' again n' again tha next time \f(CW$p\fR\->get_token is called.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Da 'eg/hform' script shows how tha fuck we might parse tha form section of
HTML::Documents rockin HTML::PullParser.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTML::Parser, HTML::TokeParser
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1998\-2001 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
