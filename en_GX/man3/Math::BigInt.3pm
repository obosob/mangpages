.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BigInt 3pm"
.TH Math::BigInt 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::BigInt \- Arbitrary size integer/float math package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Math::BigInt;
\&
\&  # or make it fasta wit big-ass numbers: install (optional)
\&  # Math::BigInt::GMP n' always use (it will fall back to
\&  # pure Perl if tha GMP library aint installed):
\&  # (See also tha L<MATH LIBRARY> section!)
\&
\&  # will warn if Math::BigInt::GMP cannot be found
\&  use Math::BigInt lib => \*(AqGMP\*(Aq;
\&
\&  # ta suppress tha warnin use this:
\&  # use Math::BigInt try => \*(AqGMP\*(Aq;
\&
\&  # takes a thugged-out dirt nap if GMP cannot be loaded:
\&  # use Math::BigInt only => \*(AqGMP\*(Aq;
\&
\&  mah $str = \*(Aq1234567890\*(Aq;
\&  mah @values = (64,74,18);
\&  mah $n = 1; mah $sign = \*(Aq\-\*(Aq;
\&
\&  # Number creation     
\&  mah $x = Math::BigInt\->new($str);      # defaults ta 0
\&  mah $y = $x\->copy();                   # cook up a legit copy
\&  mah $nan  = Math::BigInt\->bnan();      # create a NotANumber
\&  mah $zero = Math::BigInt\->bzero();     # create a +0
\&  mah $inf = Math::BigInt\->binf();       # create a +inf
\&  mah $inf = Math::BigInt\->binf(\*(Aq\-\*(Aq);    # create a \-inf
\&  mah $one = Math::BigInt\->bone();       # create a +1
\&  mah $mone = Math::BigInt\->bone(\*(Aq\-\*(Aq);   # create a \-1
\&
\&  mah $pi = Math::BigInt\->bpi();         # returns \*(Aq3\*(Aq
\&                                        # peep Math::BigFloat::bpi()
\&
\&  $h = Math::BigInt\->new(\*(Aq0x123\*(Aq);      # from hexadecimal
\&  $b = Math::BigInt\->new(\*(Aq0b101\*(Aq);      # from binary
\&  $o = Math::BigInt\->from_oct(\*(Aq0101\*(Aq);  # from octal
\&
\&  # Testin (don\*(Aqt modify they arguments)
\&  # (return legit if tha condizzle is met, otherwise false)
\&
\&  $x\->is_zero();        # if $x is +0
\&  $x\->is_nan();         # if $x is NaN
\&  $x\->is_one();         # if $x is +1
\&  $x\->is_one(\*(Aq\-\*(Aq);      # if $x is \-1
\&  $x\->is_odd();         # if $x is odd
\&  $x\->is_even();        # if $x is even
\&  $x\->is_pos();         # if $x > 0
\&  $x\->is_neg();         # if $x < 0
\&  $x\->is_inf($sign);    # if $x is +inf, or \-inf (sign is default \*(Aq+\*(Aq)
\&  $x\->is_int();         # if $x be a integer (not a gangbangin' float)
\&
\&  # comparin n' digit/sign extraction
\&  $x\->bcmp($y);         # compare numbers (undef,<0,=0,>0)
\&  $x\->bacmp($y);        # compare straight-up (undef,<0,=0,>0)
\&  $x\->sign();           # return tha sign, either +,\- or NaN
\&  $x\->digit($n);        # return tha nth digit, countin from right
\&  $x\->digit(\-$n);       # return tha nth digit, countin from left
\&
\&  # Da followin all modify they first argument. If you wanna pre\-
\&  # serve $x, use $z = $x\->copy()\->bXXX($y); See under L<CAVEATS> for
\&  # why dis is necessary when mixin $a = $b assignments wit non\-over\-
\&  # loaded math.
\&
\&  $x\->bzero();          # set $x ta 0
\&  $x\->bnan();           # set $x ta NaN
\&  $x\->bone();           # set $x ta +1
\&  $x\->bone(\*(Aq\-\*(Aq);        # set $x ta \-1
\&  $x\->binf();           # set $x ta inf
\&  $x\->binf(\*(Aq\-\*(Aq);        # set $x ta \-inf
\&
\&  $x\->bneg();           # negation
\&  $x\->babs();           # absolute value
\&  $x\->bsgn();           # sign function (\-1, 0, 1, or NaN)
\&  $x\->bnorm();          # normalize (no\-op up in BigInt)
\&  $x\->bnot();           # two\*(Aqs complement (bit wise not)
\&  $x\->binc();           # increment $x by 1
\&  $x\->bdec();           # decrement $x by 1
\&
\&  $x\->badd($y);         # addizzle (add $y ta $x)
\&  $x\->bsub($y);         # subtraction (subtract $y from $x)
\&  $x\->bmul($y);         # multiplication (multiply $x by $y)
\&  $x\->bdiv($y);         # divide, set $x ta quotient
\&                        # return (quo,rem) or quo if scalar
\&
\&  $x\->bmuladd($y,$z);   # $x = $x * $y + $z
\&
\&  $x\->bmod($y);            # modulus (x % y)
\&  $x\->bmodpow($y,$mod);    # modular exponentiation (($x ** $y) % $mod)
\&  $x\->bmodinv($mod);       # modular multiplicatizzle inverse
\&  $x\->bpow($y);            # juice of arguments (x ** y)
\&  $x\->blsft($y);           # left shift up in base 2
\&  $x\->brsft($y);           # right shift up in base 2
\&                           # returns (quo,rem) or quo if up in sca\-
\&                           # lar context
\&  $x\->blsft($y,$n);        # left shift by $y places up in base $n
\&  $x\->brsft($y,$n);        # right shift by $y places up in base $n
\&                           # returns (quo,rem) or quo if up in sca\-
\&                           # lar context
\&
\&  $x\->band($y);            # bitwise and
\&  $x\->bior($y);            # bitwise inclusive or
\&  $x\->bxor($y);            # bitwise exclusive or
\&  $x\->bnot();              # bitwise not (two\*(Aqs complement)
\&
\&  $x\->bsqrt();             # calculate square\-root
\&  $x\->broot($y);           # $y\*(Aqth root of $x (e.g. $y == 3 => cubic root)
\&  $x\->bfac();              # factorial of $x (1*2*3*4*..$x)
\&
\&  $x\->bnok($y);            # x over y (binomial coefficient n over k)
\&
\&  $x\->blog();              # logarithm of $x ta base e (Euler\*(Aqs number)
\&  $x\->blog($base);         # logarithm of $x ta base $base (f.i. 2)
\&  $x\->bexp();              # calculate e ** $x where e is Euler\*(Aqs number
\&
\&  $x\->round($A,$P,$mode);  # round ta accuracy or precision using
\&                           # mode $mode
\&  $x\->bround($n);          # accuracy: preserve $n digits
\&  $x\->bfround($n);         # $n > 0: round $nth digits,
\&                           # $n < 0: round ta tha $nth digit afta the
\&                           # dot, no\-op fo' BigInts
\&
\&  # Da followin do not modify they arguments up in BigInt (are no\-ops),
\&  # but do so up in BigFloat:
\&
\&  $x\->bfloor();            # return integer less or equal than $x
\&  $x\->bceil();             # return integer pimped outa or equal than $x
\&
\&  # Da followin do not modify they arguments:
\&
\&  # top billin common divisor (no OO style)
\&  mah $gcd = Math::BigInt::bgcd(@values);
\&  # lowest common multiple (no OO style)
\&  mah $lcm = Math::BigInt::blcm(@values);
\&
\&  $x\->length();            # return number of digits up in number
\&  ($xl,$f) = $x\->length(); # length of number n' length of fraction
\&                           # part, latta be always 0 digits long
\&                           # fo' BigInts
\&
\&  $x\->exponent();         # return exponent as BigInt
\&  $x\->mantissa();         # return (signed) mantissa as BigInt
\&  $x\->parts();            # return (mantissa,exponent) as BigInt
\&  $x\->copy();             # cook up a legit copy of $x (unlike $y = $x;)
\&  $x\->as_int();           # return as BigInt (in BigInt: same as copy())
\&  $x\->numify();           # return as scalar (might overflow!)
\&
\&  # conversion ta strang (do not modify they argument)
\&  $x\->bstr();         # normalized strang (e.g. \*(Aq3\*(Aq)
\&  $x\->bsstr();        # norm. strang up in scientistical notation (e.g. \*(Aq3E0\*(Aq)
\&  $x\->as_hex();       # as signed hexadecimal strang wit prefixed 0x
\&  $x\->as_bin();       # as signed binary strang wit prefixed 0b
\&  $x\->as_oct();       # as signed octal strang wit prefixed 0
\&
\&
\&  # precision n' accuracy (see section bout roundin fo' more)
\&  $x\->precision();       # return P of $x (or global, if P of $x undef)
\&  $x\->precision($n);     # set P of $x ta $n
\&  $x\->accuracy();        # return A of $x (or global, if A of $x undef)
\&  $x\->accuracy($n);      # set A $x ta $n
\&
\&  # Global methods
\&  Math::BigInt\->precision();   # get/set global P fo' all BigInt objects
\&  Math::BigInt\->accuracy();    # get/set global A fo' all BigInt objects
\&  Math::BigInt\->round_mode();  # get/set global round mode, one of
\&                               # \*(Aqeven\*(Aq, \*(Aqodd\*(Aq, \*(Aq+inf\*(Aq, \*(Aq\-inf\*(Aq, \*(Aqzero\*(Aq,
\&                               # \*(Aqtrunc\*(Aq or \*(Aqcommon\*(Aq
\&  Math::BigInt\->config();      # return hash containin configuration
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (includin basic math operations) is overloaded if you
declare yo' big-ass integers as
.PP
.Vb 1
\&  $i = freshly smoked up Math::BigInt \*(Aq123_456_789_123_456_789\*(Aq;
.Ve
.PP
Operations wit overloaded operators preserve tha arguments which is
exactly what tha fuck you expect.
.IP "Input" 2
.IX Item "Input"
Input joints ta these routines may be any string, dat be lookin like a number
and thangs up in dis biatch up in a integer, includin hexadecimal n' binary numbers.
.Sp
Scalars holdin numbers may also be passed yo, but note dat non-integer numbers
may already have lost precision cuz of tha conversion ta float. Quote
your input if you want BigInt ta peep all tha digits:
.Sp
.Vb 2
\&        $x = Math::BigInt\->new(12345678890123456789);   # bad
\&        $x = Math::BigInt\->new(\*(Aq12345678901234567890\*(Aq); # good
.Ve
.Sp
Yo ass can include one underscore between any two digits.
.Sp
This means integer joints like 1.01E2 or even 1000E\-2 is also accepted.
Non-integer joints result up in NaN.
.Sp
Hexadecimal (prefixed wit \*(L"0x\*(R") n' binary numbers (prefixed wit \*(L"0b\*(R")
are accepted, like a muthafucka. Please note dat octal numbers is not recognized
by \fInew()\fR, so tha followin will print \*(L"123\*(R":
.Sp
.Vb 1
\&        perl \-MMath::BigInt \-le \*(Aqprint Math::BigInt\->new("0123")\*(Aq
.Ve
.Sp
To convert a octal number, use \fIfrom_oct()\fR;
.Sp
.Vb 1
\&        perl \-MMath::BigInt \-le \*(Aqprint Math::BigInt\->from_oct("0123")\*(Aq
.Ve
.Sp
Currently, \fIMath::BigInt::new()\fR defaults ta 0, while Math::BigInt::new('')
results up in 'NaN'. This might chizzle up in tha future, so use always tha following
explicit forms ta git a zero or NaN:
.Sp
.Vb 2
\&        $zero = Math::BigInt\->bzero();
\&        $nan = Math::BigInt\->bnan();
.Ve
.Sp
\&\f(CW\*(C`bnorm()\*(C'\fR on a BigInt object is now effectively a no-op, since tha numbers 
are always stored up in normalized form. If passed a string, creates a BigInt 
object from tha input.
.IP "Output" 2
.IX Item "Output"
Output joints is BigInt objects (normalized), except fo' tha methodz which
return a strang (see \*(L"\s-1SYNOPSIS\*(R"\s0).
.Sp
Some routines (\f(CW\*(C`is_odd()\*(C'\fR, \f(CW\*(C`is_even()\*(C'\fR, \f(CW\*(C`is_zero()\*(C'\fR, \f(CW\*(C`is_one()\*(C'\fR,
\&\f(CW\*(C`is_nan()\*(C'\fR, etc.) return legit or false, while others (\f(CW\*(C`bcmp()\*(C'\fR, \f(CW\*(C`bacmp()\*(C'\fR)
return either undef (if NaN is involved), <0, 0 or >0 n' is suited fo' sort.
.SH "METHODS"
.IX Header "METHODS"
Each of tha methodz below (except \fIconfig()\fR, \fIaccuracy()\fR n' \fIprecision()\fR)
accepts three additionizzle parameters. These arguments \f(CW$A\fR, \f(CW$P\fR n' \f(CW$R\fR
are \f(CW\*(C`accuracy\*(C'\fR, \f(CW\*(C`precision\*(C'\fR n' \f(CW\*(C`round_mode\*(C'\fR. Please peep tha section about
\&\*(L"\s-1ACCURACY\s0 n' \s-1PRECISION\*(R"\s0 fo' mo' shiznit.
.SS "\fIconfig()\fP"
.IX Subsection "config()"
.Vb 1
\&        use Data::Dumper;
\&
\&        print Dumper ( Math::BigInt\->config() );
\&        print Math::BigInt\->config()\->{lib},"\en";
.Ve
.PP
Returns a hash containin tha configuration, e.g. tha version number, lib
loaded etc. Da followin hash keys is currently filled up in wit the
appropriate shiznit.
.PP
.Vb 10
\&        key           Description
\&                      Example
\&        ============================================================
\&        lib           Name of tha low\-level math library
\&                      Math::BigInt::Calc
\&        lib_version   Version of low\-level math library (see \*(Aqlib\*(Aq)
\&                      0.30
\&        class         Da class name of config() you just called
\&                      Math::BigInt
\&        upgrade       To which class math operations might be upgraded
\&                      Math::BigFloat
\&        downgrade     To which class math operations might be downgraded
\&                      undef
\&        precision     Global precision
\&                      undef
\&        accuracy      Global accuracy
\&                      undef
\&        round_mode    Global round mode
\&                      even
\&        version       version number of tha class you used
\&                      1.61
\&        div_scale     Fallback accuracy fo' div
\&                      40
\&        trap_nan      If true, traps creation of NaN via croak()
\&                      1
\&        trap_inf      If true, traps creation of +inf/\-inf via croak()
\&                      1
.Ve
.PP
Da followin joints can be set by passin \f(CW\*(C`config()\*(C'\fR a reference ta a hash:
.PP
.Vb 2
\&        trap_inf trap_nan
\&        upgrade downgrade precision accuracy round_mode div_scale
.Ve
.PP
Example:
.PP
.Vb 3
\&        $new_cfg = Math::BigInt\->config(
\&            { trap_inf => 1, precision => 5 }
\&        );
.Ve
.SS "\fIaccuracy()\fP"
.IX Subsection "accuracy()"
.Vb 3
\&    $x\->accuracy(5);         # local fo' $x
\&    CLASS\->accuracy(5);      # global fo' all thugz of CLASS
\&                             # Note: This also applies ta new()!
\&
\&    $A = $x\->accuracy();     # read up accuracy dat affects $x
\&    $A = CLASS\->accuracy();  # read up global accuracy
.Ve
.PP
Set or git tha global or local accuracy, aka how tha fuck nuff dope digits the
results have. If you set a global accuracy, then dis also applies ta \fInew()\fR!
.PP
Warning! Da accuracy \fIsticks\fR, e.g. once you pimped a number under the
influence of \f(CW\*(C`CLASS\->accuracy($A)\*(C'\fR, all thangs up in dis biatch from math operations with
that number will also be rounded.
.PP
In most cases, you should probably round tha thangs up in dis biatch explicitly rockin one of
\&\*(L"\fIround()\fR\*(R", \*(L"\fIbround()\fR\*(R" or \*(L"\fIbfround()\fR\*(R" or by passin tha desired accuracy
to tha math operation as additionizzle parameter:
.PP
.Vb 4
\&    mah $x = Math::BigInt\->new(30000);
\&    mah $y = Math::BigInt\->new(7);
\&    print scalar $x\->copy()\->bdiv($y, 2);               # print 4300
\&    print scalar $x\->copy()\->bdiv($y)\->bround(2);       # print 4300
.Ve
.PP
Please peep tha section bout \*(L"\s-1ACCURACY\s0 n' \s-1PRECISION\*(R"\s0 fo' further details.
.PP
Value must be pimped outa than zero. Pass a undef value ta disable it:
.PP
.Vb 2
\&    $x\->accuracy(undef);
\&    Math::BigInt\->accuracy(undef);
.Ve
.PP
Returns tha current accuracy. For \f(CW\*(C`$x\->accuracy()\*(C'\fR it will return either
the local accuracy, or if not defined, tha global. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. This means tha return value
represents tha accuracy dat is ghon be up in effect fo' \f(CW$x:\fR
.PP
.Vb 10
\&    $y = Math::BigInt\->new(1234567);       # unrounded
\&    print Math::BigInt\->accuracy(4),"\en";  # set 4, print 4
\&    $x = Math::BigInt\->new(123456);        # $x is ghon be automatic\-
\&                                           # ally rounded!
\&    print "$x $y\en";                       # \*(Aq123500 1234567\*(Aq
\&    print $x\->accuracy(),"\en";             # is ghon be 4
\&    print $y\->accuracy(),"\en";             # also 4, since global is 4
\&    print Math::BigInt\->accuracy(5),"\en";  # set ta 5, print 5
\&    print $x\->accuracy(),"\en";             # still 4
\&    print $y\->accuracy(),"\en";             # 5, since global is 5
.Ve
.PP
Note: Works also fo' subclasses like Math::BigFloat. Each class has itz own
globals separated from Math::BigInt yo, but it is possible ta subclass
Math::BigInt n' make tha globalz of tha subclass aliases ta tha ones from
Math::BigInt.
.SS "\fIprecision()\fP"
.IX Subsection "precision()"
.Vb 4
\&    $x\->precision(\-2);          # local fo' $x, round all up in tha second
\&                                # digit right of tha dot
\&    $x\->precision(2);           # ditto, round all up in tha second digit left
\&                                # of tha dot
\&
\&    CLASS\->precision(5);        # Global fo' all thugz of CLASS
\&                                # This also applies ta new()!
\&    CLASS\->precision(\-5);       # ditto
\&
\&    $P = CLASS\->precision();    # read up global precision
\&    $P = $x\->precision();       # read up precision dat affects $x
.Ve
.PP
Note: Yo ass probably wanna use \*(L"\fIaccuracy()\fR\*(R" instead. Y'all KNOW dat shit, muthafucka! With \*(L"\fIaccuracy()\fR\*(R" you
set tha number of digits each result should have, wit \*(L"\fIprecision()\fR\*(R" you
set tha place where ta round!
.PP
\&\f(CW\*(C`precision()\*(C'\fR sets or gets tha global or local precision, aka at which digit
before or afta tha dot ta round all thangs up in dis biatch fo' realz. A set global precision also
applies ta all newly pimped numbers!
.PP
In Math::BigInt, passin a wack number precision has no effect since no
numbers have digits afta tha dot. In Math::BigFloat, it will round all
results ta P digits afta tha dot.
.PP
Please peep tha section bout \*(L"\s-1ACCURACY\s0 n' \s-1PRECISION\*(R"\s0 fo' further details.
.PP
Pass a undef value ta disable it:
.PP
.Vb 2
\&    $x\->precision(undef);
\&    Math::BigInt\->precision(undef);
.Ve
.PP
Returns tha current precision. I aint talkin' bout chicken n' gravy biatch. For \f(CW\*(C`$x\->precision()\*(C'\fR it will return either
the local precision of \f(CW$x\fR, or if not defined, tha global. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. This means tha return
value represents tha prevision dat is ghon be up in effect fo' \f(CW$x:\fR
.PP
.Vb 4
\&    $y = Math::BigInt\->new(1234567);        # unrounded
\&    print Math::BigInt\->precision(4),"\en";  # set 4, print 4
\&    $x = Math::BigInt\->new(123456);      # is ghon be automatically rounded
\&    print $x;                               # print "120000"!
.Ve
.PP
Note: Works also fo' subclasses like Math::BigFloat. Each class has its
own globals separated from Math::BigInt yo, but it is possible ta subclass
Math::BigInt n' make tha globalz of tha subclass aliases ta tha ones from
Math::BigInt.
.SS "\fIbrsft()\fP"
.IX Subsection "brsft()"
.Vb 1
\&        $x\->brsft($y,$n);
.Ve
.PP
Shifts \f(CW$x\fR right by \f(CW$y\fR up in base \f(CW$n\fR. Default is base 2, used is probably 10 and
2 yo, but others work, like a muthafucka.
.PP
Right shiftin probably amounts ta dividin \f(CW$x\fR by \f(CW$n\fR ** \f(CW$y\fR n' truncatin the
result:
.PP
.Vb 4
\&        $x = Math::BigInt\->new(10);
\&        $x\->brsft(1);                   # same as $x >> 1: 5
\&        $x = Math::BigInt\->new(1234);
\&        $x\->brsft(2,10);                # result 12
.Ve
.PP
There is one exception, n' dat is base 2 wit wack \f(CW$x:\fR
.PP
.Vb 2
\&        $x = Math::BigInt\->new(\-5);
\&        print $x\->brsft(1);
.Ve
.PP
This will print \-3, not \-2 (as it would if you divide \-5 by 2 n' truncate the
result).
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\&        $x = Math::BigInt\->new($str,$A,$P,$R);
.Ve
.PP
Creates a freshly smoked up BigInt object from a scalar or another BigInt object. The
input be accepted as decimal, hex (with leadin '0x') or binary (with leading
\&'0b').
.PP
See \*(L"Input\*(R" fo' mo' info on accepted input formats.
.SS "\fIfrom_oct()\fP"
.IX Subsection "from_oct()"
.Vb 1
\&        $x = Math::BigInt\->from_oct("0775");    # input is octal
.Ve
.PP
Interpret tha input as a octal strang n' return tha correspondin value fo' realz. A
\&\*(L"0\*(R" (zero) prefix is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack fo' realz. A single underscore characta may be placed
right afta tha prefix, if present, or between any two digits, n' you can put dat on yo' toast. If tha input is
invalid, a NaN is returned.
.SS "\fIfrom_hex()\fP"
.IX Subsection "from_hex()"
.Vb 1
\&        $x = Math::BigInt\->from_hex("0xcafe");  # input is hexadecimal
.Ve
.PP
Interpret input as a hexadecimal strin fo' realz. A \*(L"0x\*(R" or \*(L"x\*(R" prefix is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack fo' realz. A
single underscore characta may be placed right afta tha prefix, if present,
or between any two digits, n' you can put dat on yo' toast. If tha input is invalid, a NaN is returned.
.SS "\fIfrom_bin()\fP"
.IX Subsection "from_bin()"
.Vb 1
\&        $x = Math::BigInt\->from_bin("0b10011"); # input is binary
.Ve
.PP
Interpret tha input as a funky-ass binary strin fo' realz. A \*(L"0b\*(R" or \*(L"b\*(R" prefix is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack fo' realz. A
single underscore characta may be placed right afta tha prefix, if present,
or between any two digits, n' you can put dat on yo' toast. If tha input is invalid, a NaN is returned.
.SS "\fIbnan()\fP"
.IX Subsection "bnan()"
.Vb 1
\&        $x = Math::BigInt\->bnan();
.Ve
.PP
Creates a freshly smoked up BigInt object representin NaN (Not A Number).
If used on a object, it will set it ta NaN:
.PP
.Vb 1
\&        $x\->bnan();
.Ve
.SS "\fIbzero()\fP"
.IX Subsection "bzero()"
.Vb 1
\&        $x = Math::BigInt\->bzero();
.Ve
.PP
Creates a freshly smoked up BigInt object representin zero.
If used on a object, it will set it ta zero:
.PP
.Vb 1
\&        $x\->bzero();
.Ve
.SS "\fIbinf()\fP"
.IX Subsection "binf()"
.Vb 1
\&        $x = Math::BigInt\->binf($sign);
.Ve
.PP
Creates a freshly smoked up BigInt object representin infinity. Da optionizzle argument is
either '\-' or '+', indicatin whether you want infinitizzle or minus infinity.
If used on a object, it will set it ta infinity:
.PP
.Vb 2
\&        $x\->binf();
\&        $x\->binf(\*(Aq\-\*(Aq);
.Ve
.SS "\fIbone()\fP"
.IX Subsection "bone()"
.Vb 1
\&        $x = Math::BigInt\->binf($sign);
.Ve
.PP
Creates a freshly smoked up BigInt object representin one. Da optionizzle argument is
either '\-' or '+', indicatin whether you want one or minus one.
If used on a object, it will set it ta one:
.PP
.Vb 2
\&        $x\->bone();             # +1
\&        $x\->bone(\*(Aq\-\*(Aq);          # \-1
.Ve
.SS "\fIis_one()\fP/\fIis_zero()\fP/\fIis_nan()\fP/\fIis_inf()\fP"
.IX Subsection "is_one()/is_zero()/is_nan()/is_inf()"
.Vb 6
\&        $x\->is_zero();          # legit if arg is +0
\&        $x\->is_nan();           # legit if arg is NaN
\&        $x\->is_one();           # legit if arg is +1
\&        $x\->is_one(\*(Aq\-\*(Aq);        # legit if arg is \-1
\&        $x\->is_inf();           # legit if +inf
\&        $x\->is_inf(\*(Aq\-\*(Aq);        # legit if \-inf (sign is default \*(Aq+\*(Aq)
.Ve
.PP
These methodz all test tha BigInt fo' bein one specific value n' return
true or false dependin on tha input. These is fasta than bustin something
like:
.PP
.Vb 1
\&        if ($x == 0)
.Ve
.SS "\fIis_pos()\fP/\fIis_neg()\fP/\fIis_positive()\fP/\fIis_negative()\fP"
.IX Subsection "is_pos()/is_neg()/is_positive()/is_negative()"
.Vb 2
\&        $x\->is_pos();                   # legit if > 0
\&        $x\->is_neg();                   # legit if < 0
.Ve
.PP
Da methodz return legit if tha argument is positizzle or negative, respectively.
\&\f(CW\*(C`NaN\*(C'\fR is neither positizzle nor negative, while \f(CW\*(C`+inf\*(C'\fR counts as positive, and
\&\f(CW\*(C`\-inf\*(C'\fR is negatizzle fo' realz. A \f(CW\*(C`zero\*(C'\fR is neither positizzle nor negative.
.PP
These methodz is only testin tha sign, n' not tha value.
.PP
\&\f(CW\*(C`is_positive()\*(C'\fR n' \f(CW\*(C`is_negative()\*(C'\fR is aliases ta \f(CW\*(C`is_pos()\*(C'\fR and
\&\f(CW\*(C`is_neg()\*(C'\fR, respectively. \f(CW\*(C`is_positive()\*(C'\fR n' \f(CW\*(C`is_negative()\*(C'\fR were
introduced up in v1.36, while \f(CW\*(C`is_pos()\*(C'\fR n' \f(CW\*(C`is_neg()\*(C'\fR was only introduced
in v1.68.
.SS "\fIis_odd()\fP/\fIis_even()\fP/\fIis_int()\fP"
.IX Subsection "is_odd()/is_even()/is_int()"
.Vb 3
\&        $x\->is_odd();                   # legit if odd, false fo' even
\&        $x\->is_even();                  # legit if even, false fo' odd
\&        $x\->is_int();                   # legit if $x be a integer
.Ve
.PP
Da return legit when tha argument satisfies tha condition. I aint talkin' bout chicken n' gravy biatch. \f(CW\*(C`NaN\*(C'\fR, \f(CW\*(C`+inf\*(C'\fR,
\&\f(CW\*(C`\-inf\*(C'\fR is not integers n' is neither odd nor even.
.PP
In BigInt, all numbers except \f(CW\*(C`NaN\*(C'\fR, \f(CW\*(C`+inf\*(C'\fR n' \f(CW\*(C`\-inf\*(C'\fR is integers.
.SS "\fIbcmp()\fP"
.IX Subsection "bcmp()"
.Vb 1
\&        $x\->bcmp($y);
.Ve
.PP
Compares \f(CW$x\fR wit \f(CW$y\fR n' takes tha sign tha fuck into account.
Returns \-1, 0, 1 or undef.
.SS "\fIbacmp()\fP"
.IX Subsection "bacmp()"
.Vb 1
\&        $x\->bacmp($y);
.Ve
.PP
Compares \f(CW$x\fR wit \f(CW$y\fR while ignorin they sign. I aint talkin' bout chicken n' gravy biatch. Returns \-1, 0, 1 or undef.
.SS "\fIsign()\fP"
.IX Subsection "sign()"
.Vb 1
\&        $x\->sign();
.Ve
.PP
Return tha sign, of \f(CW$x\fR, meanin either \f(CW\*(C`+\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, \f(CW\*(C`\-inf\*(C'\fR, \f(CW\*(C`+inf\*(C'\fR or NaN.
.PP
If you want \f(CW$x\fR ta git a cold-ass lil certain sign, use one of tha followin methods:
.PP
.Vb 5
\&        $x\->babs();             # \*(Aq+\*(Aq
\&        $x\->babs()\->bneg();     # \*(Aq\-\*(Aq
\&        $x\->bnan();             # \*(AqNaN\*(Aq
\&        $x\->binf();             # \*(Aq+inf\*(Aq
\&        $x\->binf(\*(Aq\-\*(Aq);          # \*(Aq\-inf\*(Aq
.Ve
.SS "\fIdigit()\fP"
.IX Subsection "digit()"
.Vb 1
\&        $x\->digit($n);       # return tha nth digit, countin from right
.Ve
.PP
If \f(CW$n\fR is negative, returns tha digit countin from left.
.SS "\fIbneg()\fP"
.IX Subsection "bneg()"
.Vb 1
\&        $x\->bneg();
.Ve
.PP
Negate tha number, e.g. chizzle tha sign between '+' n' '\-', or between '+inf'
and '\-inf', respectively. Do not a god damn thang fo' NaN or zero.
.SS "\fIbabs()\fP"
.IX Subsection "babs()"
.Vb 1
\&        $x\->babs();
.Ve
.PP
Set tha number ta its absolute value, e.g. chizzle tha sign from '\-' ta '+'
and from '\-inf' ta '+inf', respectively. Do not a god damn thang fo' NaN or positive
numbers.
.SS "\fIbsgn()\fP"
.IX Subsection "bsgn()"
.Vb 1
\&        $x\->bsgn();
.Ve
.PP
Signum function. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Set tha number ta \-1, 0, or 1, dependin on whether the
number is negative, zero, or positive, respectivly. Do not modify NaNs.
.SS "\fIbnorm()\fP"
.IX Subsection "bnorm()"
.Vb 1
\&        $x\->bnorm();                    # normalize (no\-op)
.Ve
.SS "\fIbnot()\fP"
.IX Subsection "bnot()"
.Vb 1
\&        $x\->bnot();
.Ve
.PP
Twoz complement (bitwise not). This is equivalent to
.PP
.Vb 1
\&        $x\->binc()\->bneg();
.Ve
.PP
but faster.
.SS "\fIbinc()\fP"
.IX Subsection "binc()"
.Vb 1
\&        $x\->binc();             # increment x by 1
.Ve
.SS "\fIbdec()\fP"
.IX Subsection "bdec()"
.Vb 1
\&        $x\->bdec();             # decrement x by 1
.Ve
.SS "\fIbadd()\fP"
.IX Subsection "badd()"
.Vb 1
\&        $x\->badd($y);           # addizzle (add $y ta $x)
.Ve
.SS "\fIbsub()\fP"
.IX Subsection "bsub()"
.Vb 1
\&        $x\->bsub($y);           # subtraction (subtract $y from $x)
.Ve
.SS "\fIbmul()\fP"
.IX Subsection "bmul()"
.Vb 1
\&        $x\->bmul($y);           # multiplication (multiply $x by $y)
.Ve
.SS "\fIbmuladd()\fP"
.IX Subsection "bmuladd()"
.Vb 1
\&        $x\->bmuladd($y,$z);
.Ve
.PP
Multiply \f(CW$x\fR by \f(CW$y\fR, n' then add \f(CW$z\fR ta tha result,
.PP
This method was added up in v1.87 of Math::BigInt (June 2007).
.SS "\fIbdiv()\fP"
.IX Subsection "bdiv()"
.Vb 2
\&        $x\->bdiv($y);           # divide, set $x ta quotient
\&                                # return (quo,rem) or quo if scalar
.Ve
.SS "\fIbmod()\fP"
.IX Subsection "bmod()"
.Vb 1
\&        $x\->bmod($y);           # modulus (x % y)
.Ve
.SS "\fIbmodinv()\fP"
.IX Subsection "bmodinv()"
.Vb 1
\&        $x\->bmodinv($mod);      # modular multiplicatizzle inverse
.Ve
.PP
Returns tha multiplicatizzle inverse of \f(CW$x\fR modulo \f(CW$mod\fR. If
.PP
.Vb 1
\&        $y = $x \-> copy() \-> bmodinv($mod)
.Ve
.PP
then \f(CW$y\fR is tha number closest ta zero, n' wit tha same sign as \f(CW$mod\fR,
satisfying
.PP
.Vb 1
\&        ($x * $y) % $mod = 1 % $mod
.Ve
.PP
If \f(CW$x\fR n' \f(CW$y\fR is non-zero, they must be relatizzle primes, i.e.,
\&\f(CW\*(C`bgcd($y, $mod)==1\*(C'\fR. '\f(CW\*(C`NaN\*(C'\fR' is returned when no modular multiplicative
inverse exists.
.SS "\fIbmodpow()\fP"
.IX Subsection "bmodpow()"
.Vb 2
\&        $num\->bmodpow($exp,$mod);       # modular exponentiation
\&                                        # ($num**$exp % $mod)
.Ve
.PP
Returns tha value of \f(CW$num\fR taken ta tha juice \f(CW$exp\fR up in tha modulus
\&\f(CW$mod\fR rockin binary exponentiation. I aint talkin' bout chicken n' gravy biatch.  \f(CW\*(C`bmodpow\*(C'\fR is far superior to
writing
.PP
.Vb 1
\&        $num ** $exp % $mod
.Ve
.PP
because it is much fasta \- it reduces internal variablez into
the modulus whenever possible, so it operates on smalla numbers.
.PP
\&\f(CW\*(C`bmodpow\*(C'\fR also supports wack exponents.
.PP
.Vb 1
\&        bmodpow($num, \-1, $mod)
.Ve
.PP
is exactly equivalent to
.PP
.Vb 1
\&        bmodinv($num, $mod)
.Ve
.SS "\fIbpow()\fP"
.IX Subsection "bpow()"
.Vb 1
\&        $x\->bpow($y);                 # juice of arguments (x ** y)
.Ve
.SS "\fIblog()\fP"
.IX Subsection "blog()"
.Vb 1
\&        $x\->blog($base, $accuracy);   # logarithm of x ta tha base $base
.Ve
.PP
If \f(CW$base\fR aint defined, Eulerz number (e) is used:
.PP
.Vb 1
\&        print $x\->blog(undef, 100);   # log(x) ta 100 digits
.Ve
.SS "\fIbexp()\fP"
.IX Subsection "bexp()"
.Vb 1
\&        $x\->bexp($accuracy);          # calculate e ** X
.Ve
.PP
Calculates tha expression \f(CW\*(C`e ** $x\*(C'\fR where \f(CW\*(C`e\*(C'\fR is Eulerz number.
.PP
This method was added up in v1.82 of Math::BigInt (April 2007).
.PP
See also \*(L"\fIblog()\fR\*(R".
.SS "\fIbnok()\fP"
.IX Subsection "bnok()"
.Vb 1
\&        $x\->bnok($y);        # x over y (binomial coefficient n over k)
.Ve
.PP
Calculates tha binomial coefficient n over k, also called tha \*(L"choose\*(R"
function. I aint talkin' bout chicken n' gravy biatch. Da result is equivalent to:
.PP
.Vb 3
\&        ( n )      n!
\&        | \- |  = \-\-\-\-\-\-\-
\&        ( k )    k!(n\-k)!
.Ve
.PP
This method was added up in v1.84 of Math::BigInt (April 2007).
.SS "\fIbpi()\fP"
.IX Subsection "bpi()"
.Vb 1
\&        print Math::BigInt\->bpi(100), "\en";             # 3
.Ve
.PP
Returns \s-1PI\s0 truncated ta a integer, wit tha argument bein ignored. Y'all KNOW dat shit, muthafucka! This means
under BigInt dis always returns \f(CW3\fR.
.PP
If upgradin is up in effect, returns \s-1PI,\s0 rounded ta N digits wit the
current roundin mode:
.PP
.Vb 4
\&        use Math::BigFloat;
\&        use Math::BigInt upgrade => Math::BigFloat;
\&        print Math::BigInt\->bpi(3), "\en";               # 3.14
\&        print Math::BigInt\->bpi(100), "\en";             # 3.1415....
.Ve
.PP
This method was added up in v1.87 of Math::BigInt (June 2007).
.SS "\fIbcos()\fP"
.IX Subsection "bcos()"
.Vb 2
\&        mah $x = Math::BigInt\->new(1);
\&        print $x\->bcos(100), "\en";
.Ve
.PP
Calculate tha cosinuz of \f(CW$x\fR, modifyin \f(CW$x\fR up in place.
.PP
In BigInt, unless upgradin is up in effect, tha result is truncated ta an
integer.
.PP
This method was added up in v1.87 of Math::BigInt (June 2007).
.SS "\fIbsin()\fP"
.IX Subsection "bsin()"
.Vb 2
\&        mah $x = Math::BigInt\->new(1);
\&        print $x\->bsin(100), "\en";
.Ve
.PP
Calculate tha sinuz of \f(CW$x\fR, modifyin \f(CW$x\fR up in place.
.PP
In BigInt, unless upgradin is up in effect, tha result is truncated ta an
integer.
.PP
This method was added up in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan2()\fP"
.IX Subsection "batan2()"
.Vb 3
\&        mah $x = Math::BigInt\->new(1);
\&        mah $y = Math::BigInt\->new(1);
\&        print $y\->batan2($x), "\en";
.Ve
.PP
Calculate tha arcus tangenz of \f(CW$y\fR divided by \f(CW$x\fR, modifyin \f(CW$y\fR up in place.
.PP
In BigInt, unless upgradin is up in effect, tha result is truncated ta an
integer.
.PP
This method was added up in v1.87 of Math::BigInt (June 2007).
.SS "\fIbatan()\fP"
.IX Subsection "batan()"
.Vb 2
\&        mah $x = Math::BigFloat\->new(0.5);
\&        print $x\->batan(100), "\en";
.Ve
.PP
Calculate tha arcus tangenz of \f(CW$x\fR, modifyin \f(CW$x\fR up in place.
.PP
In BigInt, unless upgradin is up in effect, tha result is truncated ta an
integer.
.PP
This method was added up in v1.87 of Math::BigInt (June 2007).
.SS "\fIblsft()\fP"
.IX Subsection "blsft()"
.Vb 2
\&        $x\->blsft($y);          # left shift up in base 2
\&        $x\->blsft($y,$n);       # left shift, up in base $n (like 10)
.Ve
.SS "\fIbrsft()\fP"
.IX Subsection "brsft()"
.Vb 2
\&        $x\->brsft($y);          # right shift up in base 2
\&        $x\->brsft($y,$n);       # right shift, up in base $n (like 10)
.Ve
.SS "\fIband()\fP"
.IX Subsection "band()"
.Vb 1
\&        $x\->band($y);                   # bitwise and
.Ve
.SS "\fIbior()\fP"
.IX Subsection "bior()"
.Vb 1
\&        $x\->bior($y);                   # bitwise inclusive or
.Ve
.SS "\fIbxor()\fP"
.IX Subsection "bxor()"
.Vb 1
\&        $x\->bxor($y);                   # bitwise exclusive or
.Ve
.SS "\fIbnot()\fP"
.IX Subsection "bnot()"
.Vb 1
\&        $x\->bnot();                     # bitwise not (two\*(Aqs complement)
.Ve
.SS "\fIbsqrt()\fP"
.IX Subsection "bsqrt()"
.Vb 1
\&        $x\->bsqrt();                    # calculate square\-root
.Ve
.SS "\fIbroot()\fP"
.IX Subsection "broot()"
.Vb 1
\&        $x\->broot($N);
.Ve
.PP
Calculates tha N'th root of \f(CW$x\fR.
.SS "\fIbfac()\fP"
.IX Subsection "bfac()"
.Vb 1
\&        $x\->bfac();                     # factorial of $x (1*2*3*4*..$x)
.Ve
.SS "\fIround()\fP"
.IX Subsection "round()"
.Vb 1
\&        $x\->round($A,$P,$round_mode);
.Ve
.PP
Round \f(CW$x\fR ta accuracy \f(CW$A\fR or precision \f(CW$P\fR rockin tha round mode
\&\f(CW$round_mode\fR.
.SS "\fIbround()\fP"
.IX Subsection "bround()"
.Vb 1
\&        $x\->bround($N);               # accuracy: preserve $N digits
.Ve
.SS "\fIbfround()\fP"
.IX Subsection "bfround()"
.Vb 1
\&        $x\->bfround($N);
.Ve
.PP
If N is > 0, roundz ta tha Nth digit from tha left. If N < 0, roundz to
the Nth digit afta tha dot. Right back up in yo muthafuckin ass. Since BigInts is integers, tha case N < 0
is a no-op fo' em.
.PP
Examples:
.PP
.Vb 6
\&        Input           N               Result
\&        ===================================================
\&        123456.123456   3               123500
\&        123456.123456   2               123450
\&        123456.123456   \-2              123456.12
\&        123456.123456   \-3              123456.123
.Ve
.SS "\fIbfloor()\fP"
.IX Subsection "bfloor()"
.Vb 1
\&        $x\->bfloor();
.Ve
.PP
Set \f(CW$x\fR ta tha integer less or equal than \f(CW$x\fR. This be a no-op up in BigInt yo, but
does chizzle \f(CW$x\fR up in BigFloat.
.SS "\fIbceil()\fP"
.IX Subsection "bceil()"
.Vb 1
\&        $x\->bceil();
.Ve
.PP
Set \f(CW$x\fR ta tha integer pimped outa or equal than \f(CW$x\fR. This be a no-op up in BigInt yo, but
does chizzle \f(CW$x\fR up in BigFloat.
.SS "\fIbgcd()\fP"
.IX Subsection "bgcd()"
.Vb 1
\&        bgcd(@values);          # top billin common divisor (no OO style)
.Ve
.SS "\fIblcm()\fP"
.IX Subsection "blcm()"
.Vb 1
\&        blcm(@values);          # lowest common multiple (no OO style)
.Ve
.PP
head2 \fIlength()\fR
.PP
.Vb 2
\&        $x\->length();
\&        ($xl,$fl) = $x\->length();
.Ve
.PP
Returns tha number of digits up in tha decimal representation of tha number.
In list context, returns tha length of tha integer n' fraction part. For
BigInt's, tha length of tha fraction part will always be 0.
.SS "\fIexponent()\fP"
.IX Subsection "exponent()"
.Vb 1
\&        $x\->exponent();
.Ve
.PP
Return tha exponent of \f(CW$x\fR as BigInt.
.SS "\fImantissa()\fP"
.IX Subsection "mantissa()"
.Vb 1
\&        $x\->mantissa();
.Ve
.PP
Return tha signed mantissa of \f(CW$x\fR as BigInt.
.SS "\fIparts()\fP"
.IX Subsection "parts()"
.Vb 1
\&        $x\->parts();    # return (mantissa,exponent) as BigInt
.Ve
.SS "\fIcopy()\fP"
.IX Subsection "copy()"
.Vb 1
\&        $x\->copy();     # cook up a legit copy of $x (unlike $y = $x;)
.Ve
.SS "\fIas_int()\fP/\fIas_number()\fP"
.IX Subsection "as_int()/as_number()"
.Vb 1
\&        $x\->as_int();
.Ve
.PP
Returns \f(CW$x\fR as a BigInt (truncated towardz zero). In BigInt dis is tha same ol' dirty as
\&\f(CW\*(C`copy()\*(C'\fR.
.PP
\&\f(CW\*(C`as_number()\*(C'\fR be a alias ta dis method. Y'all KNOW dat shit, muthafucka! \f(CW\*(C`as_number\*(C'\fR was introduced in
v1.22, while \f(CW\*(C`as_int()\*(C'\fR was only introduced up in v1.68.
.SS "\fIbstr()\fP"
.IX Subsection "bstr()"
.Vb 1
\&        $x\->bstr();
.Ve
.PP
Returns a normalized strang representation of \f(CW$x\fR.
.SS "\fIbsstr()\fP"
.IX Subsection "bsstr()"
.Vb 1
\&        $x\->bsstr();    # normalized strang up in scientistical notation
.Ve
.SS "\fIas_hex()\fP"
.IX Subsection "as_hex()"
.Vb 1
\&        $x\->as_hex();   # as signed hexadecimal strang wit prefixed 0x
.Ve
.SS "\fIas_bin()\fP"
.IX Subsection "as_bin()"
.Vb 1
\&        $x\->as_bin();   # as signed binary strang wit prefixed 0b
.Ve
.SS "\fIas_oct()\fP"
.IX Subsection "as_oct()"
.Vb 1
\&        $x\->as_oct();   # as signed octal strang wit prefixed 0
.Ve
.SS "\fInumify()\fP"
.IX Subsection "numify()"
.Vb 1
\&        print $x\->numify();
.Ve
.PP
This returns a aiiight Perl scalar from \f(CW$x\fR. Well shiiiit, it is used automatically
whenever a scalar is needed, fo' instizzle up in array index operations.
.PP
This loses precision, ta avoid dis use \fIas_int()\fR instead.
.SS "\fImodify()\fP"
.IX Subsection "modify()"
.Vb 1
\&        $x\->modify(\*(Aqbpowd\*(Aq);
.Ve
.PP
This method returns 0 if tha object can be modified wit tha given
operation, or 1 if not.
.PP
This is used fo' instizzle by Math::BigInt::Constant.
.SS "\fIupgrade()\fP/\fIdowngrade()\fP"
.IX Subsection "upgrade()/downgrade()"
Set/get tha class fo' downgrade/upgrade operations. Thuis is used
for instizzle by bignum. Da defaults is '', thus tha following
operation will create a BigInt, not a BigFloat:
.PP
.Vb 2
\&        mah $i = Math::BigInt\->new(123);
\&        mah $f = Math::BigFloat\->new(\*(Aq123.1\*(Aq);
\&
\&        print $i + $f,"\en";                     # print 246
.Ve
.SS "\fIdiv_scale()\fP"
.IX Subsection "div_scale()"
Set/get tha number of digits fo' tha default precision up in divide
operations.
.SS "\fIround_mode()\fP"
.IX Subsection "round_mode()"
Set/get tha current round mode.
.SH "ACCURACY n' PRECISION"
.IX Header "ACCURACY n' PRECISION"
Since version v1.33, Math::BigInt n' Math::BigFloat have full support for
accuracy n' precision based rounding, both automatically afta every
operation, as well as manually.
.PP
This section raps bout tha accuracy/precision handlin up in Math::Big* as it
used ta be n' as it is now, complete wit a explanation of all terms and
abbreviations.
.PP
Not yet implemented thangs (but wit erect description) is marked wit '!',
things dat need ta be answered is marked wit '?'.
.PP
In tha next paragraph bigs up a gangbangin' finger-lickin' dirty-ass short description of terms used here (because
these may differ from terms used by others playas or documentation).
.PP
Durin tha rest of dis document, tha shortcuts A (for accuracy), P (for
precision), F (fallback) n' R (roundin mode) is ghon be used.
.SS "Precision P"
.IX Subsection "Precision P"
A fixed number of digits before (positive) or afta (negative)
the decimal point. For example, 123.45 has a precision of \-2. 0 means an
integer like 123 (or 120) fo' realz. A precision of 2 means two digits ta tha left
of tha decimal point is zero, so 123 wit P = 1 becomes 120. Note that
numbers wit zeros before tha decimal point may have different precisions,
because 1200 can have p = 0, 1 or 2 (dependin on what tha fuck tha initial value
was). Well shiiiit, it could also have p < 0, when tha digits afta tha decimal point
are zero.
.PP
Da strang output (of floatin point numbers) is ghon be padded wit zeros:
.PP
.Vb 9
\&        Initial value   P       A       Result          String
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        1234.01         \-3              1000            1000
\&        1234            \-2              1200            1200
\&        1234.5          \-1              1230            1230
\&        1234.001        1               1234            1234.0
\&        1234.01         0               1234            1234
\&        1234.01         2               1234.01         1234.01
\&        1234.01         5               1234.01         1234.01000
.Ve
.PP
For BigInts, no paddin occurs.
.SS "Accuracy A"
.IX Subsection "Accuracy A"
Number of dope digits, n' you can put dat on yo' toast. Leadin zeros is not counted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. A
number may have a accuracy pimped outa than tha non-zero digits
when there be zeros up in it or trailin zeros. For example, 123.456 has
A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 n' 0.000123 has 3.
.PP
Da strang output (of floatin point numbers) is ghon be padded wit zeros:
.PP
.Vb 5
\&        Initial value   P       A       Result          String
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        1234.01                 3       1230            1230
\&        1234.01                 6       1234.01         1234.01
\&        1234.1                  8       1234.1          1234.1000
.Ve
.PP
For BigInts, no paddin occurs.
.SS "Fallback F"
.IX Subsection "Fallback F"
When both A n' P is undefined, dis is used as a gangbangin' fallback accuracy when
dividin numbers.
.SS "Roundin mode R"
.IX Subsection "Roundin mode R"
When roundin a number, different 'styles' or 'kinds'
of roundin is possible. (Note dat random rounding, as in
Math::Round, aint implemented.)
.IP "'trunc'" 2
.IX Item "'trunc'"
truncation invariably removes all digits followin the
roundin place, replacin dem wit zeros. Thus, 987.65 rounded
to tens (P=1) becomes 980, n' rounded ta tha fourth sigdig
becomes 987.6 (A=4). 123.456 rounded ta tha second place afta the
decimal point (P=\-2) becomes 123.46.
.Sp
All other implemented stylez of roundin attempt ta round ta the
\&\*(L"nearest digit.\*(R" If tha digit D immediately ta tha right of the
roundin place (skippin tha decimal point) is pimped outa than 5, the
number is incremented all up in tha roundin place (possibly causin a
cascade of incrementation): e.g. when roundin ta units, 0.9 rounds
to 1, n' \-19.9 roundz ta \-20. If D < 5, tha number is similarly
truncated all up in tha roundin place: e.g. when roundin ta units, 0.4
roundz ta 0, n' \-19.4 roundz ta \-19.
.Sp
However tha thangs up in dis biatch of other stylez of roundin differ if the
digit immediately ta tha right of tha roundin place (skippin the
decimal point) is 5 n' if there be no digits, or no digits other
than 0, afta dat 5. In such cases:
.IP "'even'" 2
.IX Item "'even'"
roundz tha digit all up in tha roundin place ta 0, 2, 4, 6, or 8
if it aint already. E.g., when roundin ta tha straight-up original gangsta sigdig, 0.45
becomes 0.4, \-0.55 becomes \-0.6 yo, but 0.4501 becomes 0.5.
.IP "'odd'" 2
.IX Item "'odd'"
roundz tha digit all up in tha roundin place ta 1, 3, 5, 7, or 9 if
it aint already. E.g., when roundin ta tha straight-up original gangsta sigdig, 0.45
becomes 0.5, \-0.55 becomes \-0.5 yo, but 0.5501 becomes 0.6.
.IP "'+inf'" 2
.IX Item "'+inf'"
round ta plus infinity, i.e. always round up. E.g., when
roundin ta tha straight-up original gangsta sigdig, 0.45 becomes 0.5, \-0.55 becomes \-0.5,
and 0.4501 also becomes 0.5.
.IP "'\-inf'" 2
.IX Item "'-inf'"
round ta minus infinity, i.e. always round down. I aint talkin' bout chicken n' gravy biatch. E.g., when
roundin ta tha straight-up original gangsta sigdig, 0.45 becomes 0.4, \-0.55 becomes \-0.6,
but 0.4501 becomes 0.5.
.IP "'zero'" 2
.IX Item "'zero'"
round ta zero, i.e. positizzle numbers down, wack ones up.
E.g., when roundin ta tha straight-up original gangsta sigdig, 0.45 becomes 0.4, \-0.55
becomes \-0.5 yo, but 0.4501 becomes 0.5.
.IP "'common'" 2
.IX Item "'common'"
round up if tha digit immediately ta tha right of tha roundin place
is 5 or pimped outer, otherwise round down. I aint talkin' bout chicken n' gravy biatch. E.g., 0.15 becomes 0.2 and
0.149 becomes 0.1.
.PP
Da handlin of A & P up in \s-1MBI/MBF \s0(the oldschool core code shipped wit Perl
versions <= 5.7.2) is like this:
.IP "Precision" 2
.IX Item "Precision"
.Vb 3
\&  * ffround($p) be able ta round ta $p number of digits afta tha decimal
\&    point
\&  * otherwise P is unused
.Ve
.IP "Accuracy (significant digits)" 2
.IX Item "Accuracy (significant digits)"
.Vb 10
\&  * fround($a) roundz ta $a dope digits
\&  * only fdiv() n' fsqrt() take A as (optional) parameter
\&    + other operations simply create tha same number (fneg etc), or mo' (fmul)
\&      of digits
\&    + rounding/truncatin is only done when explicitly callin one of fround
\&      or ffround, n' never fo' BigInt (not implemented)
\&  * fsqrt() simply handz its accuracy argument over ta fdiv.
\&  * tha documentation n' tha comment up in tha code indicate two different ways
\&    on how tha fuck fdiv() determines tha maximum number of digits it should calculate,
\&    n' tha actual code do yet another thang
\&    POD:
\&      max($Math::BigFloat::div_scale,length(dividend)+length(divisor))
\&    Comment:
\&      result has at most max(scale, length(dividend), length(divisor)) digits
\&    Actual code:
\&      scale = max(scale, length(dividend)\-1,length(divisor)\-1);
\&      scale += length(divisor) \- length(dividend);
\&    So fo' lx = 3, ly = 9, scale = 10, scale will straight-up be 16 (10+9\-3).
\&    Actually, tha \*(Aqdifference\*(Aq added ta tha scale is calculated from the
\&    number of "significant digits" up in dividend n' divisor, which is derived
\&    by lookin all up in tha length of tha mantissa. Which is wrong, since it includes
\&    tha + sign (oops) n' straight-up gets 2 fo' \*(Aq+100\*(Aq n' 4 fo' \*(Aq+101\*(Aq. Oops
\&    again. I aint talkin' bout chicken n' gravy biatch. Thus 124/3 wit div_scale=1 will git you \*(Aq41.3\*(Aq based on tha strange
\&    assumption dat 124 has 3 dope digits, while 120/7 will git you
\&    \*(Aq17\*(Aq, not \*(Aq17.1\*(Aq since 120 is thought ta have 2 dope digits.
\&    Da roundin afta tha division then uses tha remainder n' $y ta determine
\&    whether it must round up or down.
\& ?  I have no clue which is tha right way. That\*(Aqs why I used a slightly more
\& ?  simple scheme n' tweaked tha few failin testcases ta match dat shit.
.Ve
.PP
This is how tha fuck it works now:
.IP "Setting/Accessing" 2
.IX Item "Setting/Accessing"
.Vb 10
\&  * Yo ass can set tha A global via Math::BigInt\->accuracy() or
\&    Math::BigFloat\->accuracy() or whatever class yo ass is using.
\&  * Yo ass can also set P globally by rockin Math::SomeClass\->precision()
\&    likewise.
\&  * Globals is classwide, n' not inherited by subclasses.
\&  * ta undefine A, use Math::SomeCLass\->accuracy(undef);
\&  * ta undefine P, use Math::SomeClass\->precision(undef);
\&  * Settin Math::SomeClass\->accuracy() clears automatically
\&    Math::SomeClass\->precision(), n' vice versa.
\&  * To be valid, A must be > 0, P can have any value.
\&  * If P is negative, dis means round ta tha P\*(Aqth place ta tha right of the
\&    decimal point; positizzle joints mean ta tha left of tha decimal point.
\&    P of 0 means round ta integer.
\&  * ta smoke up tha current global A, use Math::SomeClass\->accuracy()
\&  * ta smoke up tha current global P, use Math::SomeClass\->precision()
\&  * use $x\->accuracy() respectizzle $x\->precision() fo' tha local
\&    settin of $x.
\&  * Please note dat $x\->accuracy() respectizzle $x\->precision()
\&    return eventually defined global A or P, when $x\*(Aqs A or P is not
\&    set.
.Ve
.IP "Creatin numbers" 2
.IX Item "Creatin numbers"
.Vb 12
\&  * When you create a number, you can give tha desired A or P via:
\&    $x = Math::BigInt\->new($number,$A,$P);
\&  * Only one of A or P can be defined, otherwise tha result is NaN
\&  * If no A or P is give ($x = Math::BigInt\->new($number) form), then the
\&    globals (if set) is ghon be used. Y'all KNOW dat shit, muthafucka! Thus changin tha global defaults lata on
\&    aint gonna chizzle tha A or P of previously pimped numbers (i.e., A n' P of
\&    $x is ghon be what tha fuck was up in effect when $x was pimped)
\&  * If given undef fo' A n' P, NO roundin will occur, n' tha globals will
\&    NOT be used. Y'all KNOW dat shit, muthafucka! This is used by subclasses ta create numbers without
\&    sufferin roundin up in tha parent. Thus a subclass be able ta have its own
\&    globals enforced upon creation of a number by using
\&    $x = Math::BigInt\->new($number,undef,undef):
\&
\&        use Math::BigInt::SomeSubclass;
\&        use Math::BigInt;
\&
\&        Math::BigInt\->accuracy(2);
\&        Math::BigInt::SomeSubClass\->accuracy(3);
\&        $x = Math::BigInt::SomeSubClass\->new(1234);
\&
\&    $x is now 1230, n' not 1200 fo' realz. A subclass might chizzle ta implement
\&    dis otherwise, e.g. fallin back ta tha parent\*(Aqs A n' P.
.Ve
.IP "Usage" 2
.IX Item "Usage"
.Vb 7
\&  * If A or P is enabled/defined, they is used ta round tha result of each
\&    operation accordin ta tha rulez below
\&  * Negatizzle P is ignored up in Math::BigInt, since BigInts never have digits
\&    afta tha decimal point
\&  * Math::BigFloat uses Math::BigInt internally yo, but settin A or P inside
\&    Math::BigInt as globals do not tamper wit tha partz of a BigFloat.
\&    A flag is used ta mark all Math::BigFloat numbers as \*(Aqnever round\*(Aq.
.Ve
.IP "Precedence" 2
.IX Item "Precedence"
.Vb 10
\&  * It only make sense dat a number has only one of A or P at a time.
\&    If you set either A or P on one object, or globally, tha other one will
\&    be automatically cleared.
\&  * If two objects is involved up in a operation, n' one of dem has A in
\&    effect, n' tha other P, dis thangs up in dis biatch up in a error (NaN).
\&  * A takes precedence over P (Hint: A comes before P).
\&    If neither of dem is defined, not a god damn thang is used, i.e. tha result will have
\&    as nuff digits as it can (with a exception fo' fdiv/fsqrt) n' will not
\&    be rounded.
\&  * There be another settin fo' fdiv() (and thus fo' fsqrt()). If neither of
\&    A or P is defined, fdiv() will bust a gangbangin' fallback (F) of $div_scale digits.
\&    If either tha dividend\*(Aqs or tha divisor\*(Aqs mantissa has mo' digits than
\&    tha value of F, tha higher value is ghon be used instead of F.
\&    This is ta limit tha digits (A) of tha result (just consider what tha fuck would
\&    happen wit unlimited A n' P up in tha case of 1/3 :\-)
\&  * fdiv will calculate (at least) 4 mo' digits than required (determined by
\&    A, P or F), and, if F aint used, round tha result
\&    (this will still fail up in tha case of a result like 0.12345000000001 wit A
\&    or P of 5 yo, but dis can not be helped \- or can it?)
\&  * Thus you can have tha math done by on Math::Big* class up in two modi:
\&    + never round (this is tha default):
\&      This is done by settin A n' P ta undef. No math operation
\&      will round tha result, wit fdiv() n' fsqrt() as exceptions ta guard
\&      against overflows. Yo ass must explicitly call bround(), bfround() or
\&      round() (the latta wit parameters).
\&      Note: Once you have rounded a number, tha settings will \*(Aqstick\*(Aq on it
\&      n' \*(Aqinfect\*(Aq all other numbers engaged up in math operations wit it, since
\&      local settings have tha highest precedence. Right back up in yo muthafuckin ass. So, ta git SaferRound[tm],
\&      bust a cold-ass lil copy() before roundin like this:
\&
\&        $x = Math::BigFloat\->new(12.34);
\&        $y = Math::BigFloat\->new(98.76);
\&        $z = $x * $y;                           # 1218.6984
\&        print $x\->copy()\->fround(3);            # 12.3 (but A is now 3!)
\&        $z = $x * $y;                           # still 1218.6984, without
\&                                                # copy would done been 1210!
\&
\&    + round afta each op:
\&      Afta each single operation (except fo' testin like is_zero()), the
\&      method round() is called n' tha result is rounded appropriately. By
\&      settin proper joints fo' A n' P, you can have all\-the\-same\-A or
\&      all\-the\-same\-P modes. For example, Math::Currency might set A ta undef,
\&      n' P ta \-2, globally.
\&
\& ?Maybe a extra option dat forbidz local A & P settings would be up in order,
\& ?so dat intermediate roundin do not \*(Aqpoison\*(Aq further math?
.Ve
.IP "Overridin globals" 2
.IX Item "Overridin globals"
.Vb 10
\&  * yo big-ass booty is ghon be able ta give A, P n' R as a argument ta all tha calculation
\&    routines; tha second parameta is A, tha third one is P, n' tha fourth is
\&    R (shift right by one fo' binary operations like badd). P is used only if
\&    tha straight-up original gangsta parameta (A) is undefined. Y'all KNOW dat shit, muthafucka! These three parametas override the
\&    globals up in tha order detailed as bigs up, i.e. tha straight-up original gangsta defined value
\&    wins:
\&    (local: per object, global: global default, parameter: argument ta sub)
\&      + parameta A
\&      + parameta P
\&      + local A (if defined on both of tha operands: smalla one is taken)
\&      + local P (if defined on both of tha operands: bigger one is taken)
\&      + global A
\&      + global P
\&      + global F
\&  * fsqrt() will hand its arguments ta fdiv(), as it used to, only now fo' two
\&    arguments (A n' P) instead of one
.Ve
.IP "Local settings" 2
.IX Item "Local settings"
.Vb 5
\&  * Yo ass can set A or P locally by rockin $x\->accuracy() or
\&    $x\->precision()
\&    n' thus force different A n' P fo' different objects/numbers.
\&  * Settin A or P dis way immediately roundz $x ta tha freshly smoked up value.
\&  * $x\->accuracy() clears $x\->precision(), n' vice versa.
.Ve
.IP "Rounding" 2
.IX Item "Rounding"
.Vb 10
\&  * tha roundin routines will use tha respectizzle global or local settings.
\&    fround()/bround() is fo' accuracy rounding, while ffround()/bfround()
\&    is fo' precision
\&  * tha two roundin functions take as tha second parameta one of the
\&    followin roundin modes (R):
\&    \*(Aqeven\*(Aq, \*(Aqodd\*(Aq, \*(Aq+inf\*(Aq, \*(Aq\-inf\*(Aq, \*(Aqzero\*(Aq, \*(Aqtrunc\*(Aq, \*(Aqcommon\*(Aq
\&  * you can set/get tha global R by rockin Math::SomeClass\->round_mode()
\&    or by settin $Math::SomeClass::round_mode
\&  * afta each operation, $result\->round() is called, n' tha result may
\&    eventually be rounded (that is, if A or P was set either locally,
\&    globally or as parameta ta tha operation)
\&  * ta manually round a number, call $x\->round($A,$P,$round_mode);
\&    dis will round tha number by rockin tha appropriate roundin function
\&    n' then normalize dat shit.
\&  * roundin modifies tha local settingz of tha number:
\&
\&        $x = Math::BigFloat\->new(123.456);
\&        $x\->accuracy(5);
\&        $x\->bround(4);
\&
\&    Here 4 takes precedence over 5, so 123.5 is tha result n' $x\->accuracy()
\&    is ghon be 4 from now on.
.Ve
.IP "Default joints" 2
.IX Item "Default joints"
.Vb 4
\&  * R: \*(Aqeven\*(Aq
\&  * F: 40
\&  * A: undef
\&  * P: undef
.Ve
.IP "Remarks" 2
.IX Item "Remarks"
.Vb 5
\&  * Da defaults is set up so dat tha freshly smoked up code gives tha same ol' dirty thangs up in dis biatch as
\&    tha oldschool code (except up in all dem cases on fdiv):
\&    + Both A n' P is undefined n' thus aint gonna be used fo' rounding
\&      afta each operation.
\&    + round() is thus a no\-op, unless given extra parametas A n' P
.Ve
.SH "Infinitizzle n' Not a Number"
.IX Header "Infinitizzle n' Not a Number"
While BigInt has extensive handlin of inf n' NaN, certain quirks remain.
.IP "\fIoct()\fR/\fIhex()\fR" 2
.IX Item "oct()/hex()"
These perl routines currently (az of Perl v.5.8.6) cannot handle passed
inf.
.Sp
.Vb 9
\&        te@linux:~> perl \-wle \*(Aqprint 2 ** 3333\*(Aq
\&        inf
\&        te@linux:~> perl \-wle \*(Aqprint 2 ** 3333 == 2 ** 3333\*(Aq
\&        1
\&        te@linux:~> perl \-wle \*(Aqprint oct(2 ** 3333)\*(Aq
\&        0
\&        te@linux:~> perl \-wle \*(Aqprint hex(2 ** 3333)\*(Aq
\&        Illegal hexadecimal digit \*(Aqi\*(Aq ignored at \-e line 1.
\&        0
.Ve
.Sp
Da same problems occur if you pass dem Math::BigInt\->\fIbinf()\fR objects, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Since
overloadin these routines aint possible, dis cannot be fixed from BigInt.
.IP "==, !=, <, >, <=, >= wit NaNs" 2
.IX Item "==, !=, <, >, <=, >= wit NaNs"
BigIntz \fIbcmp()\fR routine currently returns undef ta signal dat a NaN was
involved up in a cold-ass lil comparison. I aint talkin' bout chicken n' gravy biatch. But fuck dat shiznit yo, tha word on tha street is dat tha overload code turns dat into
either 1 or '' n' thus operations like \f(CW\*(C`NaN != NaN\*(C'\fR might return
wrong joints.
.IP "log(\-inf)" 2
.IX Item "log(-inf)"
\&\f(CW\*(C`log(\-inf)\*(C'\fR is highly weird. Y'all KNOW dat shit, muthafucka! Since log(\-x)=pi*i+log(x), then
log(\-inf)=pi*i+inf. But fuck dat shiznit yo, tha word on tha street is dat since tha imaginary part is finite, tha real
infinitizzle \*(L"overshadows\*(R" it, so tha number might as well just be infinity.
But fuck dat shiznit yo, tha word on tha street is dat tha result be a cold-ass lil complex number, n' since BigInt/BigFloat can only
have real numbers as thangs up in dis biatch, tha result is NaN.
.IP "\fIexp()\fR, \fIcos()\fR, \fIsin()\fR, \fIatan2()\fR" 2
.IX Item "exp(), cos(), sin(), atan2()"
These all might have problems handlin infinitizzle right.
.SH "INTERNALS"
.IX Header "INTERNALS"
Da actual numbers is stored as unsigned big-ass integers (with separate sign).
.PP
Yo ass should neither care bout nor depend on tha internal representation; it
might chizzle without notice. Use \fB\s-1ONLY\s0\fR method calls like \f(CW\*(C`$x\->sign();\*(C'\fR
instead relyin on tha internal representation.
.SS "\s-1MATH LIBRARY\s0"
.IX Subsection "MATH LIBRARY"
Math wit tha numbers is done (by default) by a module called
\&\f(CW\*(C`Math::BigInt::Calc\*(C'\fR. This is equivalent ta saying:
.PP
.Vb 1
\&        use Math::BigInt try => \*(AqCalc\*(Aq;
.Ve
.PP
Yo ass can chizzle dis backend library by using:
.PP
.Vb 1
\&        use Math::BigInt try => \*(AqGMP\*(Aq;
.Ve
.PP
\&\fBNote\fR: General purpose packages should not be explicit bout tha library
to use; let tha script lyricist decizzle which is best.
.PP
If yo' script works wit big-ass numbers n' Calc is too slow fo' them,
you can also fo' tha loadin of one of these libraries n' if none
of dem can be used, tha code will die:
.PP
.Vb 1
\&        use Math::BigInt only => \*(AqGMP,Pari\*(Aq;
.Ve
.PP
Da followin would first try ta find Math::BigInt::Foo, then
Math::BigInt::Bar, n' when dis also fails, revert ta Math::BigInt::Calc:
.PP
.Vb 1
\&        use Math::BigInt try => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
Da library dat is loaded last is ghon be used. Y'all KNOW dat shit, muthafucka! Note dat dis can be
overwritten at any time by loadin a gangbangin' finger-lickin' different library, n' numbers
constructed wit different libraries cannot be used up in math operations
together.
.PP
\fIWhat library ta use?\fR
.IX Subsection "What library ta use?"
.PP
\&\fBNote\fR: General purpose packages should not be explicit bout tha library
to use; let tha script lyricist decizzle which is best.
.PP
Math::BigInt::GMP n' Math::BigInt::Pari is up in cases involvin big
numbers much fasta than Calc, however it is slower when dealin wit hella
small numbers (less than bout 20 digits) n' when convertin straight-up large
numbers ta decimal (for instizzle fo' printing, rounding, calculatin their
length up in decimal etc).
.PP
So please select carefully what tha fuck library you wanna use.
.PP
Different low-level libraries use different formats ta store tha numbers.
But fuck dat shiznit yo, tha word on tha street is dat you should \fB\s-1NOT\s0\fR depend on tha number havin a specific format
internally.
.PP
See tha respectizzle math library module documentation fo' further details.
.SS "\s-1SIGN\s0"
.IX Subsection "SIGN"
Da sign is either '+', '\-', 'NaN', '+inf' or '\-inf'.
.PP
A sign of 'NaN' is used ta represent tha result when input arguments is not
numbers or as a result of 0/0. '+inf' n' '\-inf' represent plus respectively
minus infinity. Yo ass will git '+inf' when dividin a positizzle number by 0, and
\&'\-inf' when dividin any wack number by 0.
.SS "\fImantissa()\fP, \fIexponent()\fP n' \fIparts()\fP"
.IX Subsection "mantissa(), exponent() n' parts()"
\&\f(CW\*(C`mantissa()\*(C'\fR n' \f(CW\*(C`exponent()\*(C'\fR return tha holla'd partz of tha BigInt such
that:
.PP
.Vb 4
\&        $m = $x\->mantissa();
\&        $e = $x\->exponent();
\&        $y = $m * ( 10 ** $e );
\&        print "ok\en" if $x == $y;
.Ve
.PP
\&\f(CW\*(C`($m,$e) = $x\->parts()\*(C'\fR is just a gangbangin' finger-lickin' dirty-ass shortcut dat gives you both of them
in one go. Both tha returned mantissa n' exponent gotz a sign.
.PP
Currently, fo' BigInts \f(CW$e\fR be always 0, except +inf n' \-inf, where it is
\&\f(CW\*(C`+inf\*(C'\fR; n' fo' NaN, where it is \f(CW\*(C`NaN\*(C'\fR; n' fo' \f(CW\*(C`$x == 0\*(C'\fR, where it is \f(CW1\fR
(to be compatible wit Math::BigFloatz internal representation of a zero as
\&\f(CW0E1\fR).
.PP
\&\f(CW$m\fR is currently just a cold-ass lil copy of tha original gangsta number n' shit. Da relation between
\&\f(CW$e\fR n' \f(CW$m\fR will stay always tha same, though they real joints might
change.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&  use Math::BigInt;
\&
\&  sub bint { Math::BigInt\->new(shift); }
\&
\&  $x = Math::BigInt\->bstr("1234")       # strang "1234"
\&  $x = "$x";                            # same as bstr()
\&  $x = Math::BigInt\->bneg("1234");      # BigInt "\-1234"
\&  $x = Math::BigInt\->babs("\-12345");    # BigInt "12345"
\&  $x = Math::BigInt\->bnorm("\-0.00");    # BigInt "0"
\&  $x = bint(1) + bint(2);               # BigInt "3"
\&  $x = bint(1) + "2";                   # ditto (auto\-BigIntify of "2")
\&  $x = bint(1);                         # BigInt "1"
\&  $x = $x + 5 / 2;                      # BigInt "3"
\&  $x = $x ** 3;                         # BigInt "27"
\&  $x *= 2;                              # BigInt "54"
\&  $x = Math::BigInt\->new(0);            # BigInt "0"
\&  $x\-\-;                                 # BigInt "\-1"
\&  $x = Math::BigInt\->badd(4,5)          # BigInt "9"
\&  print $x\->bsstr();                    # 9e+0
.Ve
.PP
Examplez fo' rounding:
.PP
.Vb 2
\&  use Math::BigFloat;
\&  use Test;
\&
\&  $x = Math::BigFloat\->new(123.4567);
\&  $y = Math::BigFloat\->new(123.456789);
\&  Math::BigFloat\->accuracy(4);          # no mo' A than 4
\&
\&  aiiight ($x\->copy()\->fround(),123.4);      # even rounding
\&  print $x\->copy()\->fround(),"\en";      # 123.4
\&  Math::BigFloat\->round_mode(\*(Aqodd\*(Aq);    # round ta odd
\&  print $x\->copy()\->fround(),"\en";      # 123.5
\&  Math::BigFloat\->accuracy(5);          # no mo' A than 5
\&  Math::BigFloat\->round_mode(\*(Aqodd\*(Aq);    # round ta odd
\&  print $x\->copy()\->fround(),"\en";      # 123.46
\&  $y = $x\->copy()\->fround(4),"\en";      # A = 4: 123.4
\&  print "$y, ",$y\->accuracy(),"\en";     # 123.4, 4
\&
\&  Math::BigFloat\->accuracy(undef);      # A not blingin now
\&  Math::BigFloat\->precision(2);         # P blingin
\&  print $x\->copy()\->bnorm(),"\en";       # 123.46
\&  print $x\->copy()\->fround(),"\en";      # 123.46
.Ve
.PP
Examplez fo' converting:
.PP
.Vb 2
\&  mah $x = Math::BigInt\->new(\*(Aq0b1\*(Aq.\*(Aq01\*(Aq x 123);
\&  print "bin: ",$x\->as_bin()," hex:",$x\->as_hex()," dec: ",$x,"\en";
.Ve
.SH "Autobustin constants"
.IX Header "Autobustin constants"
Afta \f(CW\*(C`use Math::BigInt \*(Aq:constant\*(Aq\*(C'\fR all tha \fBinteger\fR decimal, hexadecimal
and binary constants up in tha given scope is converted ta \f(CW\*(C`Math::BigInt\*(C'\fR.
This conversion happens at compile time.
.PP
In particular,
.PP
.Vb 1
\&  perl \-MMath::BigInt=:constant \-e \*(Aqprint 2**100,"\en"\*(Aq
.Ve
.PP
prints tha integer value of \f(CW\*(C`2**100\*(C'\fR. Note dat without conversion of 
constants tha expression 2**100 is ghon be calculated as perl scalar.
.PP
Please note dat strings n' floatin point constants is not affected,
so that
.PP
.Vb 1
\&        use Math::BigInt qw/:constant/;
\&
\&        $x = 1234567890123456789012345678901234567890
\&                + 123456789123456789;
\&        $y = \*(Aq1234567890123456789012345678901234567890\*(Aq
\&                + \*(Aq123456789123456789\*(Aq;
.Ve
.PP
do not work. Yo ass need a explicit Math::BigInt\->\fInew()\fR round one of the
operands. Yo ass should also quote big-ass constants ta protect loss of precision:
.PP
.Vb 1
\&        use Math::BigInt;
\&
\&        $x = Math::BigInt\->new(\*(Aq1234567889123456789123456789123456789\*(Aq);
.Ve
.PP
Without tha quotes Perl would convert tha big-ass number ta a gangbangin' floatin point
constant at compile time n' then hand tha result ta BigInt, which thangs up in dis biatch in
an truncated result or a NaN.
.PP
This also applies ta integers dat be lookin like floatin point constants:
.PP
.Vb 1
\&        use Math::BigInt \*(Aq:constant\*(Aq;
\&
\&        print ref(123e2),"\en";
\&        print ref(123.2e2),"\en";
.Ve
.PP
will print not a god damn thang but newlines. Use either bignum or Math::BigFloat
to git dis ta work.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
Usin tha form \f(CW$x\fR += \f(CW$y\fR; etc over \f(CW$x\fR = \f(CW$x\fR + \f(CW$y\fR is faster, since a cold-ass lil copy of \f(CW$x\fR
must be made up in tha second case. For long numbers, tha copy can smoke up ta 20%
of tha work (in tha case of addition/subtraction, less for
multiplication/division). If \f(CW$y\fR is straight-up lil' small-ass compared ta \f(CW$x\fR, tha form
\&\f(CW$x\fR += \f(CW$y\fR is \s-1MUCH\s0 fasta than \f(CW$x\fR = \f(CW$x\fR + \f(CW$y\fR since makin tha copy of \f(CW$x\fR takes
more time then tha actual addition.
.PP
With a technique called copy-on-write, tha cost of copyin wit overload could
be minimized or even straight-up avoided. Y'all KNOW dat shit, muthafucka! A test implementation of \s-1COW\s0 did show
performizzle gains fo' overloaded math yo, but introduced a performizzle loss due
to a cold-ass lil constant overhead fo' all other operations. Right back up in yo muthafuckin ass. So Math::BigInt do currently
not \s-1COW.\s0
.PP
Da rewritten version of dis module (vs. v0.01) is slower on certain
operations, like \f(CW\*(C`new()\*(C'\fR, \f(CW\*(C`bstr()\*(C'\fR n' \f(CW\*(C`numify()\*(C'\fR. Da reason is dat it
does now mo' work n' handlez much mo' cases. Da time dropped up in these
operations is probably gained up in tha other math operations so dat code on
the average should git (much) fasta n' shit. If they don't, please contact tha lyricist.
.PP
Some operations may be slower fo' lil' small-ass numbers yo, but is hella faster
for big-ass numbers. Other operations is now constant (O(1), like \f(CW\*(C`bneg()\*(C'\fR,
\&\f(CW\*(C`babs()\*(C'\fR etc), instead of O(N) n' thus nearly always take much less time.
These optimizations was done on purpose.
.PP
If you find tha Calc module ta slow, try ta install any of tha replacement
modulez n' peep if they help yo thugged-out ass.
.SS "Alternatizzle math libraries"
.IX Subsection "Alternatizzle math libraries"
Yo ass can use a alternatizzle library ta drive Math::BigInt. Right back up in yo muthafuckin ass. See tha section
\&\*(L"\s-1MATH LIBRARY\*(R"\s0 fo' mo' shiznit.
.PP
For mo' benchmark thangs up in dis biatch peep <http://bloodgate.com/perl/benchmarks.html>.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
.SS "Subclassin Math::BigInt"
.IX Subsection "Subclassin Math::BigInt"
Da basic design of Math::BigInt allows simple subclasses wit straight-up lil
work, as long as all dem simple rulez is followed:
.IP "\(bu" 2
Da hood \s-1API\s0 must remain consistent, i.e. if a sub-class is overloading
addition, tha sub-class must use tha same name, up in dis case \fIbadd()\fR. The
reason fo' dis is dat Math::BigInt is optimized ta booty-call tha object methods
directly.
.IP "\(bu" 2
Da private object hash keys like \f(CW\*(C`$x\->{sign}\*(C'\fR may not be chizzled yo, but
additionizzle keys can be added, like \f(CW\*(C`$x\->{_custom}\*(C'\fR.
.IP "\(bu" 2
Accessor functions is available fo' all existin object hash keys n' should
be used instead of directly accessin tha internal hash keys. Da reason for
this is dat Math::BigInt itself has a pluggable intercourse which permits it
to support different storage methods.
.PP
Mo' complex sub-classes may gotta replicate mo' of tha logic internal of
Math::BigInt if they need ta chizzle mo' basic behaviors fo' realz. A subclass that
needz ta merely chizzle tha output only need ta overload \f(CW\*(C`bstr()\*(C'\fR.
.PP
All other object methodz n' overloaded functions can be directly inherited
from tha parent class.
.PP
At tha straight-up minimum, any subclass will need ta provide its own \f(CW\*(C`new()\*(C'\fR n' can
store additionizzle hash keys up in tha object. There is also some package globals
that must be defined, e.g.:
.PP
.Vb 5
\&  # Globals
\&  $accuracy = undef;
\&  $precision = \-2;       # round ta 2 decimal places
\&  $round_mode = \*(Aqeven\*(Aq;
\&  $div_scale = 40;
.Ve
.PP
Additionally, you might wanna provide tha followin two globals ta allow
auto-upgradin n' auto-downgradin ta work erectly:
.PP
.Vb 2
\&  $upgrade = undef;
\&  $downgrade = undef;
.Ve
.PP
This allows Math::BigInt ta erectly retrieve package globals from tha 
subclass, like \f(CW$SubClass::precision\fR.  See t/Math/BigInt/Subclass.pm or
t/Math/BigFloat/SubClass.pm straight-up functionizzle subclass examples.
.PP
Don't forget to
.PP
.Vb 1
\&        use overload;
.Ve
.PP
in yo' subclass ta automatically inherit tha overloadin from tha parent. If
you like, you can chizzle part of tha overloading, peep Math::Strin fo' an
example.
.SH "UPGRADING"
.IX Header "UPGRADING"
When used like this:
.PP
.Vb 1
\&        use Math::BigInt upgrade => \*(AqFoo::Bar\*(Aq;
.Ve
.PP
certain operations will 'upgrade' they calculation n' thus tha result to
the class Foo::Bar. Shiiit, dis aint no joke. Usually dis is used up in conjunction wit Math::BigFloat:
.PP
.Vb 1
\&        use Math::BigInt upgrade => \*(AqMath::BigFloat\*(Aq;
.Ve
.PP
As a gangbangin' finger-lickin' dirty-ass shortcut, you can use tha module \f(CW\*(C`bignum\*(C'\fR:
.PP
.Vb 1
\&        use bignum;
.Ve
.PP
Also phat fo' one-liners:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint 2 ** 255\*(Aq
.Ve
.PP
This make it possible ta mix argumentz of different classes (as up in 2.5 + 2)
as well es preserve accuracy (as up in \fIsqrt\fR\|(3)).
.PP
Beware: This feature aint straight-up implemented yet.
.SS "Auto-upgrade"
.IX Subsection "Auto-upgrade"
Da followin methodz upgrade theyselves unconditionally; dat is if upgrade
is up in effect, they will always hand up they work:
.IP "\fIbsqrt()\fR" 2
.IX Item "bsqrt()"
.PD 0
.IP "\fIdiv()\fR" 2
.IX Item "div()"
.IP "\fIblog()\fR" 2
.IX Item "blog()"
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.PD
.PP
Beware: This list aint complete.
.PP
All other methodz upgrade theyselves only when one (or all) of their
arguments iz of tha class mentioned up in \f(CW$upgrade\fR (This might chizzle up in later
versions ta a mo' sophisticated scheme):
.SH "EXPORTS"
.IX Header "EXPORTS"
\&\f(CW\*(C`Math::BigInt\*(C'\fR exports not a god damn thang by default yo, but can export tha followin methods:
.PP
.Vb 2
\&        bgcd
\&        blcm
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
Some thangs might not work as you expect em. Below is documented what tha fuck is
known ta be shitsome:
.IP "\fIbstr()\fR, \fIbsstr()\fR n' 'cmp'" 1
.IX Item "bstr(), bsstr() n' 'cmp'"
Both \f(CW\*(C`bstr()\*(C'\fR n' \f(CW\*(C`bsstr()\*(C'\fR as well as automated stringify via overload now
drop tha leadin '+'. Da oldschool code would return '+3', tha freshly smoked up returns '3'.
This is ta be consistent wit Perl n' ta make \f(CW\*(C`cmp\*(C'\fR (especially with
overloading) ta work as you expect. Well shiiiit, it also solves problems wit \f(CW\*(C`Test.pm\*(C'\fR,
because its \f(CW\*(C`ok()\*(C'\fR uses 'eq' internally.
.Sp
Mark Biggar holla'd, when axed bout ta drop tha '+' altogether, or make only
\&\f(CW\*(C`cmp\*(C'\fR work:
.Sp
.Vb 4
\&        I smoke (with tha straight-up original gangsta alternative), don\*(Aqt add tha \*(Aq+\*(Aq on positive
\&        numbers.  It\*(Aqs not as blingin no mo' wit tha freshly smoked up internal 
\&        form fo' numbers.  It made bustin thangs like abs n' neg easier,
\&        but dem gotta be done differently now anyway.
.Ve
.Sp
So, tha followin examplez will now work all as expected:
.Sp
.Vb 3
\&        use Test;
\&        BEGIN { plan tests => 1 }
\&        use Math::BigInt;
\&
\&        mah $x = freshly smoked up Math::BigInt 3*3;
\&        mah $y = freshly smoked up Math::BigInt 3*3;
\&
\&        aiiight ($x,3*3);
\&        print "$x eq 9" if $x eq $y;
\&        print "$x eq 9" if $x eq \*(Aq9\*(Aq;
\&        print "$x eq 9" if $x eq 3*3;
.Ve
.Sp
Additionally, tha followin still works:
.Sp
.Vb 3
\&        print "$x == 9" if $x == $y;
\&        print "$x == 9" if $x == 9;
\&        print "$x == 9" if $x == 3*3;
.Ve
.Sp
There is now a \f(CW\*(C`bsstr()\*(C'\fR method ta git tha strang up in scientistical notation aka
\&\f(CW1e+2\fR instead of \f(CW100\fR. Be advised dat overloaded 'eq' always uses \fIbstr()\fR
for comparison yo, but Perl will represent some numbers as 100 n' others
as 1e+308. If up in doubt, convert both arguments ta Math::BigInt before 
comparin dem as strings:
.Sp
.Vb 3
\&        use Test;
\&        BEGIN { plan tests => 3 }
\&        use Math::BigInt;
\&
\&        $x = Math::BigInt\->new(\*(Aq1e56\*(Aq); $y = 1e56;
\&        aiiight ($x,$y);                     # will fail
\&        aiiight ($x\->bsstr(),$y);            # aiiight
\&        $y = Math::BigInt\->new($y);
\&        aiiight ($x,$y);                     # aiiight
.Ve
.Sp
Alternatively, simple use \f(CW\*(C`<=>\*(C'\fR fo' comparisons, dis will git it
always right. There aint yet a way ta git a number automatically represented
as a strang dat matches exactly tha way Perl represents dat shit.
.Sp
See also tha section bout \*(L"Infinitizzle n' Not a Number\*(R" fo' problems in
comparin NaNs.
.IP "\fIint()\fR" 1
.IX Item "int()"
\&\f(CW\*(C`int()\*(C'\fR will return (at least fo' Perl v5.7.1 n' up) another BigInt, not a 
Perl scalar:
.Sp
.Vb 4
\&        $x = Math::BigInt\->new(123);
\&        $y = int($x);                           # BigInt 123
\&        $x = Math::BigFloat\->new(123.45);
\&        $y = int($x);                           # BigInt 123
.Ve
.Sp
In all Perl versions you can use \f(CW\*(C`as_number()\*(C'\fR or \f(CW\*(C`as_int\*(C'\fR fo' tha same
effect:
.Sp
.Vb 3
\&        $x = Math::BigFloat\->new(123.45);
\&        $y = $x\->as_number();                   # BigInt 123
\&        $y = $x\->as_int();                      # ditto
.Ve
.Sp
This also works fo' other subclasses, like Math::String.
.Sp
If you want a real Perl scalar, use \f(CW\*(C`numify()\*(C'\fR:
.Sp
.Vb 1
\&        $y = $x\->numify();                      # 123 as scalar
.Ve
.Sp
This is seldom necessary, though, cuz dis is done automatically, like
when you access a array:
.Sp
.Vb 1
\&        $z = $array[$x];                        # do work automatically
.Ve
.IP "length" 1
.IX Item "length"
Da followin will probably not do what tha fuck you expect:
.Sp
.Vb 2
\&        $c = Math::BigInt\->new(123);
\&        print $c\->length(),"\en";                # prints 30
.Ve
.Sp
It prints both tha number of digits up in tha number n' up in tha fraction part
since print calls \f(CW\*(C`length()\*(C'\fR up in list context. Use suttin' like:
.Sp
.Vb 1
\&        print scalar $c\->length(),"\en";         # prints 3
.Ve
.IP "bdiv" 1
.IX Item "bdiv"
Da followin will probably not do what tha fuck you expect:
.Sp
.Vb 1
\&        print $c\->bdiv(10000),"\en";
.Ve
.Sp
It prints both quotient n' remainder since print calls \f(CW\*(C`bdiv()\*(C'\fR up in list
context fo' realz. Also, \f(CW\*(C`bdiv()\*(C'\fR will modify \f(CW$c\fR, so be careful naaahhmean? Yo ass probably want
to use
.Sp
.Vb 2
\&        print $c / 10000,"\en";
\&        print scalar $c\->bdiv(10000),"\en";  # or if you wanna modify $c
.Ve
.Sp
instead.
.Sp
Da quotient be always tha top billin integer less than or equal ta the
real-valued quotient of tha two operands, n' tha remainder (when it is
non-zero) always has tha same ol' dirty sign as tha second operand; so, for
example,
.Sp
.Vb 6
\&          1 / 4  => ( 0, 1)
\&          1 / \-4 => (\-1,\-3)
\&         \-3 / 4  => (\-1, 1)
\&         \-3 / \-4 => ( 0,\-3)
\&        \-11 / 2  => (\-5,1)
\&         11 /\-2  => (\-5,\-1)
.Ve
.Sp
As a cold-ass lil consequence, tha behavior of tha operator % agrees wit the
behavior of Perlz built-in % operator (as documented up in tha perlop
manpage), n' tha equation
.Sp
.Vb 1
\&        $x == ($x / $y) * $y + ($x % $y)
.Ve
.Sp
holdz legit fo' any \f(CW$x\fR n' \f(CW$y\fR, which justifies callin tha two return
valuez of \fIbdiv()\fR tha quotient n' remainder n' shit. Da only exception ta dis rule
are when \f(CW$y\fR == 0 n' \f(CW$x\fR is negative, then tha remainder will also be
negative. Right back up in yo muthafuckin ass. See below under \*(L"infinitizzle handling\*(R" fo' tha reasonin behind all dis bullshit.
.Sp
Perlz 'use integer;' chizzlez tha behaviour of % n' / fo' scalars yo, but will
not chizzle BigIntz way ta do thangs. This is cuz under 'use integer' Perl
will do what tha fuck tha underlyin C be thinkin is right n' dis is different fo' each
system. If you need BigIntz behavin exactly like Perlz 'use integer', bug
the lyricist ta implement it ;)
.IP "infinitizzle handling" 1
.IX Item "infinitizzle handling"
Here is some examplez dat explain tha reasons why certain thangs up in dis biatch occur while
handlin infinity:
.Sp
Da followin table shows tha result of tha division n' tha remainder, so that
the equation above holdz true. Right back up in yo muthafuckin ass. Some \*(L"ordinary\*(R" cases is strewn up in ta show more
clearly tha reasoning:
.Sp
.Vb 10
\&        A /  B  =   C,     R so dat C *    B +    R =    A
\&     =========================================================
\&        5 /   8 =   0,     5         0 *    8 +    5 =    5
\&        0 /   8 =   0,     0         0 *    8 +    0 =    0
\&        0 / inf =   0,     0         0 *  inf +    0 =    0
\&        0 /\-inf =   0,     0         0 * \-inf +    0 =    0
\&        5 / inf =   0,     5         0 *  inf +    5 =    5
\&        5 /\-inf =   0,     5         0 * \-inf +    5 =    5
\&        \-5/ inf =   0,    \-5         0 *  inf +   \-5 =   \-5
\&        \-5/\-inf =   0,    \-5         0 * \-inf +   \-5 =   \-5
\&       inf/   5 =  inf,    0       inf *    5 +    0 =  inf
\&      \-inf/   5 = \-inf,    0      \-inf *    5 +    0 = \-inf
\&       inf/  \-5 = \-inf,    0      \-inf *   \-5 +    0 =  inf
\&      \-inf/  \-5 =  inf,    0       inf *   \-5 +    0 = \-inf
\&         5/   5 =    1,    0         1 *    5 +    0 =    5
\&        \-5/  \-5 =    1,    0         1 *   \-5 +    0 =   \-5
\&       inf/ inf =    1,    0         1 *  inf +    0 =  inf
\&      \-inf/\-inf =    1,    0         1 * \-inf +    0 = \-inf
\&       inf/\-inf =   \-1,    0        \-1 * \-inf +    0 =  inf
\&      \-inf/ inf =   \-1,    0         1 * \-inf +    0 = \-inf
\&         8/   0 =  inf,    8       inf *    0 +    8 =    8
\&       inf/   0 =  inf,  inf       inf *    0 +  inf =  inf
\&         0/   0 =  NaN
.Ve
.Sp
These cases below violate tha \*(L"remainder has tha sign of tha second of tha two
arguments\*(R", since they wouldn't match up otherwise.
.Sp
.Vb 4
\&        A /  B  =   C,     R so dat C *    B +    R =    A
\&     ========================================================
\&      \-inf/   0 = \-inf, \-inf      \-inf *    0 +  inf = \-inf
\&        \-8/   0 = \-inf,   \-8      \-inf *    0 +    8 = \-8
.Ve
.IP "Modifyin n' =" 1
.IX Item "Modifyin n' ="
Beware of:
.Sp
.Vb 2
\&        $x = Math::BigFloat\->new(5);
\&        $y = $x;
.Ve
.Sp
It aint gonna do what tha fuck you think, e.g. bustin a cold-ass lil copy of \f(CW$x\fR. Instead it just makes
a second reference ta tha \fBsame\fR object n' stores it up in \f(CW$y\fR. Thus anything
that modifies \f(CW$x\fR (except overloaded operators) will modify \f(CW$y\fR, n' vice versa.
Or up in other lyrics, \f(CW\*(C`=\*(C'\fR is only safe if you modify yo' BigInts only via
overloaded math fo' realz. As soon as you bust a method call it breaks:
.Sp
.Vb 2
\&        $x\->bmul(2);
\&        print "$x, $y\en";       # prints \*(Aq10, 10\*(Aq
.Ve
.Sp
If you want a legit copy of \f(CW$x\fR, use:
.Sp
.Vb 1
\&        $y = $x\->copy();
.Ve
.Sp
Yo ass can also chain tha calls like this, dis will make first a cold-ass lil copy n' then
multiply it by 2:
.Sp
.Vb 1
\&        $y = $x\->copy()\->bmul(2);
.Ve
.Sp
See also tha documentation fo' overload.pm regardin \f(CW\*(C`=\*(C'\fR.
.IP "bpow" 1
.IX Item "bpow"
\&\f(CW\*(C`bpow()\*(C'\fR (and tha roundin functions) now modifies tha straight-up original gangsta argument and
returns it, unlike tha oldschool code which left it ridin' solo n' only returned the
result. This is ta be consistent wit \f(CW\*(C`badd()\*(C'\fR etc. Da first three will
modify \f(CW$x\fR, tha last one won't:
.Sp
.Vb 4
\&        print bpow($x,$i),"\en";         # modify $x
\&        print $x\->bpow($i),"\en";        # ditto
\&        print $x **= $i,"\en";           # tha same
\&        print $x ** $i,"\en";            # leave $x alone
.Ve
.Sp
Da form \f(CW\*(C`$x **= $y\*(C'\fR is fasta than \f(CW\*(C`$x = $x ** $y;\*(C'\fR, though.
.IP "Overloadin \-$x" 1
.IX Item "Overloadin -$x"
Da following:
.Sp
.Vb 1
\&        $x = \-$x;
.Ve
.Sp
is slower than
.Sp
.Vb 1
\&        $x\->bneg();
.Ve
.Sp
since overload calls \f(CW\*(C`sub($x,0,1);\*(C'\fR instead of \f(CW\*(C`neg($x)\*(C'\fR. Da first variant
needz ta preserve \f(CW$x\fR since it do not know dat it lata will git overwritten.
This cook up a cold-ass lil copy of \f(CW$x\fR n' takes O(N) yo, but \f(CW$x\fR\->\fIbneg()\fR is O(1).
.IP "Mixin different object types" 1
.IX Item "Mixin different object types"
In Perl yo big-ass booty is ghon git a gangbangin' floatin point value if you do one of tha following:
.Sp
.Vb 3
\&        $float = 5.0 + 2;
\&        $float = 2 + 5.0;
\&        $float = 5 / 2;
.Ve
.Sp
With overloaded math, only tha straight-up original gangsta two variants will result up in a BigFloat:
.Sp
.Vb 2
\&        use Math::BigInt;
\&        use Math::BigFloat;
\&
\&        $mbf = Math::BigFloat\->new(5);
\&        $mbi2 = Math::BigInteger\->new(5);
\&        $mbi = Math::BigInteger\->new(2);
\&
\&                                        # what tha fuck straight-up gets called:
\&        $float = $mbf + $mbi;           # $mbf\->badd()
\&        $float = $mbf / $mbi;           # $mbf\->bdiv()
\&        $integer = $mbi + $mbf;         # $mbi\->badd()
\&        $integer = $mbi2 / $mbi;        # $mbi2\->bdiv()
\&        $integer = $mbi2 / $mbf;        # $mbi2\->bdiv()
.Ve
.Sp
This is cuz math wit overloaded operators bigs up tha straight-up original gangsta (dominating)
operand, n' tha operation of dat is called n' returns thus tha result. Right back up in yo muthafuckin ass. So,
\&\fIMath::BigInt::bdiv()\fR will always return a Math::BigInt, regardless whether
the result should be a Math::BigFloat or tha second operant is one.
.Sp
To git a Math::BigFloat you either need ta booty-call tha operation manually,
make shizzle tha operandz is already of tha proper type or casted ta dat type
via Math::BigFloat\->\fInew()\fR:
.Sp
.Vb 1
\&        $float = Math::BigFloat\->new($mbi2) / $mbi;     # = 2.5
.Ve
.Sp
Beware of simple \*(L"casting\*(R" tha entire expression, dis would only convert
the already computed result:
.Sp
.Vb 1
\&        $float = Math::BigFloat\->new($mbi2 / $mbi);     # = 2.0 thus wrong!
.Ve
.Sp
Beware also of tha order of mo' fucked up expressions like:
.Sp
.Vb 2
\&        $integer = ($mbi2 + $mbi) / $mbf;               # int / float => int
\&        $integer = $mbi2 / Math::BigFloat\->new($mbi);   # ditto
.Ve
.Sp
If up in doubt, break tha expression tha fuck into simpla terms, or cast all operands
to tha desired resultin type.
.Sp
Scalar joints is a lil' bit different, since:
.Sp
.Vb 2
\&        $float = 2 + $mbf;
\&        $float = $mbf + 2;
.Ve
.Sp
will both result up in tha proper type cuz of tha way tha overloaded math works.
.Sp
This section also applies ta other overloaded math packages, like Math::String.
.Sp
One solution ta you problem might be autoupgrading|upgrading. Right back up in yo muthafuckin ass. See the
pragmas bignum, bigint n' bigrat fo' a easy as fuck  way ta do all dis bullshit.
.IP "\fIbsqrt()\fR" 1
.IX Item "bsqrt()"
\&\f(CW\*(C`bsqrt()\*(C'\fR works only phat if tha result be a funky-ass big-ass integer, e.g. tha square
root of 144 is 12 yo, but from 12 tha square root is 3, regardless of rounding
mode. Da reason is dat tha result be always truncated ta a integer.
.Sp
If you want a funky-ass betta approximation of tha square root, then use:
.Sp
.Vb 4
\&        $x = Math::BigFloat\->new(12);
\&        Math::BigFloat\->precision(0);
\&        Math::BigFloat\->round_mode(\*(Aqeven\*(Aq);
\&        print $x\->copy\->bsqrt(),"\en";           # 4
\&
\&        Math::BigFloat\->precision(2);
\&        print $x\->bsqrt(),"\en";                 # 3.46
\&        print $x\->bsqrt(3),"\en";                # 3.464
.Ve
.IP "\fIbrsft()\fR" 1
.IX Item "brsft()"
For wack numbers up in base peep also brsft.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::BigFloat, Math::BigRat n' Math::Big as well as
Math::BigInt::Pari n'  Math::BigInt::GMP.
.PP
Da pragmas bignum, bigint n' bigrat also might be of interest
because they solve tha autoupgrading/downgradin issue, at least kinda.
.PP
Da package at
<http://search.cpan.org/search?mode=module&query=Math%3A%3ABigInt> gotz nuff
more documentation includin a gangbangin' full version history, testcases, empty
subclass filez n' benchmarks.
.SH "AUTHORS"
.IX Header "AUTHORS"
Original Gangsta code by Mark Biggar, overloaded intercourse by Ilya Zakharevich.
All Out rewritten by Tels http://bloodgate.com up in late 2000, 2001 \- 2006
and still at it up in 2007.
.PP
Many playas contributed up in one or mo' ways ta tha final beast, peep tha file
\&\s-1CREDITS\s0 fo' a (incomplete) list. If you miss yo' name, please drop me a
mail. Nuff props, nahmean biiiatch?
