.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::TLS 3"
.TH AnyEvent::TLS 3 "2012-04-13" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::TLS \- SSLv2/SSLv3/TLSv1 contexts fo' use up in AnyEvent::Handle
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   # via AnyEvent::Handle
\&
\&   use AnyEvent;
\&   use AnyEvent::Handle;
\&   use AnyEvent::Socket;
\&
\&   # simple https\-client
\&   mah $handle = freshly smoked up AnyEvent::Handle
\&      connect  => [$host, $port],
\&      tls      => "connect",
\&      tls_ctx  => { verify => 1, verify_peername => "https" },
\&      ...
\&
\&   # simple ssl\-server
\&   tcp_server undef, $port, sub {
\&      mah ($fh) = @_;
\&
\&      mah $handle = freshly smoked up AnyEvent::Handle
\&         fh       => $fh,
\&         tls      => "accept",
\&         tls_ctx  => { cert_file => "my\-server\-keycert.pem" },
\&         ...
\&
\&   # directly
\&
\&   mah $tls = freshly smoked up AnyEvent::TLS
\&      verify => 1,
\&      verify_peername => "ldaps",
\&      ca_file => "/etc/cacertificates.pem";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module be a helper module dat implements \s-1TLS/SSL \s0(Transhiznit Layer
Security/Secure Sockets Layer) contexts fo' realz. A \s-1TLS\s0 context be a cold-ass lil common set of
configuration joints fo' use up in establishin \s-1TLS\s0 connections.
.PP
For some quick facts bout \s-1SSL/TLS,\s0 peep tha section of tha same name near
the end of tha document.
.PP
A single \s-1TLS\s0 context can be used fo' any number of \s-1TLS\s0 connections that
wish ta use tha same certificates, policies etc.
.PP
Note dat dis module is inherently tied ta Net::SSLeay, as this
library is used ta implement dat shit. Right back up in yo muthafuckin ass. Since dat perl module is rather skanky,
and OpenSSL has a rather skanky license, AnyEvent might switch \s-1TLS\s0 providers
at some future point, at which dis \s-1API\s0 will chizzle dramatically, at least
in tha Net::SSLeay\-specific parts (most constructor arguments should still
work, though).
.PP
Although dis module do not require a specific version of Net::SSLeay,
many features will gradually stop working, or bugs is ghon be introduced with
old versions (verification might succeed when it shouldn't \- dis be a
real securitizzle issue). Version 1.35 is recommended, 1.33 should work, 1.32
might, n' olda versions is yours ta keep.
.SH "USAGE EXAMPLES"
.IX Header "USAGE EXAMPLES"
See tha AnyEvent::Handle manpage, \s-1NONFREQUENTLY ASKED QUESTIONS,\s0 for
some actual usage examples.
.SH "PUBLIC METHODS AND FUNCTIONS"
.IX Header "PUBLIC METHODS AND FUNCTIONS"
.ie n .IP "$tls = freshly smoked up AnyEvent::TLS key => value..." 4
.el .IP "\f(CW$tls\fR = freshly smoked up AnyEvent::TLS key => value..." 4
.IX Item "$tls = freshly smoked up AnyEvent::TLS key => value..."
Da constructor supports these arguments (all as key => value pairs).
.RS 4
.ie n .IP "method => ""SSLv2"" | ""SSLv3"" | ""TLSv1"" | ""any""" 4
.el .IP "method => ``SSLv2'' | ``SSLv3'' | ``TLSv1'' | ``any''" 4
.IX Item "method => SSLv2 | SSLv3 | TLSv1 | any"
Da protocol parser ta use. \f(CW\*(C`SSLv2\*(C'\fR, \f(CW\*(C`SSLv3\*(C'\fR n' \f(CW\*(C`TLSv1\*(C'\fR will use
a parser fo' dem protocols only (so will \fInot\fR accept or create
connections with/to other protocol versions), while \f(CW\*(C`any\*(C'\fR (the
default) uses a parser capable of all three protocols.
.Sp
Da default is ta use \f(CW"any"\fR but disable SSLv2. This has tha effect of
sendin a SSLv2 hello, indicatin tha support fo' SSLv3 n' TLSv1 yo, but not
actually negotiatin a (insecure) SSLv2 connection.
.Sp
Specifyin a specific version be almost always wack ta use fo' a server
speakin ta a wide variety of clients (e.g. wizzy browsers), n' often wrong
for a cold-ass lil client. If you only wanna allow a specific protocol version, use
the \f(CW\*(C`sslv2\*(C'\fR, \f(CW\*(C`sslv3\*(C'\fR or \f(CW\*(C`tlsv1\*(C'\fR arguments instead.
.Sp
For freshly smoked up skillz it is probably a phat scam ta enforce a \f(CW\*(C`TLSv1\*(C'\fR method
from tha beginning.
.ie n .IP "sslv2 => $enabled" 4
.el .IP "sslv2 => \f(CW$enabled\fR" 4
.IX Item "sslv2 => $enabled"
Enable or disable SSLv2 (normally \fIdisabled\fR).
.ie n .IP "sslv3 => $enabled" 4
.el .IP "sslv3 => \f(CW$enabled\fR" 4
.IX Item "sslv3 => $enabled"
Enable or disable SSLv3 (normally \fIenabled\fR).
.ie n .IP "tlsv1 => $enabled" 4
.el .IP "tlsv1 => \f(CW$enabled\fR" 4
.IX Item "tlsv1 => $enabled"
Enable or disable TLSv1 (normally \fIenabled\fR).
.ie n .IP "verify => $enable" 4
.el .IP "verify => \f(CW$enable\fR" 4
.IX Item "verify => $enable"
Enable or disable peer certificate checkin (default is \fIdisabled\fR, which
is \fInot recommended\fR).
.Sp
This is tha \*(L"masta switch\*(R" fo' all verify-related parametas and
functions.
.Sp
If it is disabled, then no peer certificate verification is ghon be done
\&\- tha connection is ghon be encrypted yo, but tha peer certificate won't be
verified against any known CAs, or whether it is still valid or not. No
peername verification or custom verification is ghon be done either.
.Sp
If enabled, then tha peer certificate (required up in client mode, optional
in server mode, peep \f(CW\*(C`verify_require_client_cert\*(C'\fR) is ghon be checked against
its \s-1CA\s0 certificate chain \- dat means there must be a signin chain from
the peer certificate ta any of tha \s-1CA\s0 certificates you trust locally, as
specified by tha \f(CW\*(C`ca_file\*(C'\fR and/or \f(CW\*(C`ca_path\*(C'\fR and/or \f(CW\*(C`ca_cert\*(C'\fR parameters
(or tha system default \s-1CA\s0 repository, if all of dem parametas are
missin \- peep also tha AnyEvent manpage fo' tha description of
\&\s-1PERL_ANYEVENT_CA_FILE\s0).
.Sp
Other basic checks, like fuckin checkin tha validitizzle period, will also be
done, as well as optionizzle peername/hostname/common name verification
\&\f(CW\*(C`verify_peername\*(C'\fR.
.Sp
An optionizzle \f(CW\*(C`verify_cb\*(C'\fR callback can also be set, which is ghon be invoked
with tha verification thangs up in dis biatch, n' which can override tha decision.
.ie n .IP "verify_require_client_cert => $enable" 4
.el .IP "verify_require_client_cert => \f(CW$enable\fR" 4
.IX Item "verify_require_client_cert => $enable"
Enable or disable mandatory client certificates (default is
\&\fIdisabled\fR). When dis mode is enabled, then a cold-ass lil client certificate will be
required up in server mode (a server certificate is mandatory, so up in client
mode, dis switch has no effect).
.ie n .IP "verify_peername => $scheme | $callback\->($tls, $cert, $peername)" 4
.el .IP "verify_peername => \f(CW$scheme\fR | \f(CW$callback\fR\->($tls, \f(CW$cert\fR, \f(CW$peername\fR)" 4
.IX Item "verify_peername => $scheme | $callback->($tls, $cert, $peername)"
\&\s-1TLS\s0 only protects tha data dat is busted \- it cannot automatically verify
that yo ass is straight-up rappin' ta tha right peer n' shit. Da reason is that
certificates contain a \*(L"common name\*(R" (and a set of possible alternative
\&\*(L"names\*(R") dat need ta be checked against tha peername (usually yo, but not
always, tha \s-1DNS\s0 name of tha server) up in a protocol-dependent way.
.Sp
This can be implemented by specifyin a cold-ass lil callback dat has ta verify that
the actual \f(CW$peername\fR matches tha given certificate up in \f(CW$cert\fR.
.Sp
Since dis can be rather hard ta implement, AnyEvent::TLS offers a variety
of predefined \*(L"schemes\*(R" (lifted from IO::Socket::SSL) dat is named
like tha protocols dat use them:
.RS 4
.IP "ldap (rfc4513), pop3,imap,acap (rfc2995), nntp (rfc4642)" 4
.IX Item "ldap (rfc4513), pop3,imap,acap (rfc2995), nntp (rfc4642)"
Simple wildcardz up in subjectAltNames is possible, e.g. *.example.org
matches www.example.org but not lala.www.example.org. If not a god damn thang from
subjectAltNames matches, it checks against tha common name yo, but there are
no wildcardz allowed.
.IP "http (rfc2818)" 4
.IX Item "http (rfc2818)"
Extended wildcardz up in subjectAltNames is possible, e.g. *.example.org or
even www*.example.org. Wildcardz up in tha common name is not allowed. Y'all KNOW dat shit, muthafucka! The
common name is ghon be only checked if no host names is given in
subjectAltNames.
.IP "smtp (rfc3207)" 4
.IX Item "smtp (rfc3207)"
This \s-1RFC\s0 aint straight-up useful up in determinin how tha fuck ta do verification so it
just assumes dat subjectAltNames is possible yo, but no wildcardz are
possible anywhere.
.ie n .IP "[$check_cn, $wildcards_in_alt, $wildcards_in_cn]" 4
.el .IP "[$check_cn, \f(CW$wildcards_in_alt\fR, \f(CW$wildcards_in_cn\fR]" 4
.IX Item "[$check_cn, $wildcards_in_alt, $wildcards_in_cn]"
Yo ass can also specify a scheme yo ass by rockin a array reference with
three integers.
.Sp
\&\f(CW$check_cn\fR specifies if n' how tha fuck tha common name field is used: \f(CW0\fR
means it is ghon be straight-up ignored, \f(CW1\fR means it will only be used if
no host names done been found up in tha subjectAltNames, n' \f(CW2\fR means the
common name will always be checked against tha peername.
.Sp
\&\f(CW$wildcards_in_alt\fR n' \f(CW$wildcards_in_cn\fR specify whether n' where
wildcardz (\f(CW\*(C`*\*(C'\fR) is allowed up in subjectAltNames n' tha common name,
respectively. \f(CW0\fR means no wildcardz is allowed, \f(CW1\fR means they
are allowed only as tha straight-up original gangsta component (\f(CW\*(C`*.example.org\*(C'\fR), n' \f(CW2\fR
means they can be used anywhere (\f(CW\*(C`www*.example.org\*(C'\fR), except dat hella
dangerous matches aint gonna be allowed (\f(CW\*(C`*.org\*(C'\fR or \f(CW\*(C`*\*(C'\fR).
.RE
.RS 4
.Sp
Yo ass can specify either tha name of tha parent protocol (recommended,
e.g. \f(CW\*(C`http\*(C'\fR, \f(CW\*(C`ldap\*(C'\fR), tha protocol name as probably used up in URIs
(e.g. \f(CW\*(C`https\*(C'\fR, \f(CW\*(C`ldaps\*(C'\fR) or tha \s-1RFC \s0(not recommended, e.g. \f(CW\*(C`rfc2995\*(C'\fR,
\&\f(CW\*(C`rfc3920\*(C'\fR).
.Sp
This verification will only be done when verification is enabled (\f(CW\*(C`verify => 1\*(C'\fR).
.RE
.ie n .IP "verify_cb => $callback\->($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert)" 4
.el .IP "verify_cb => \f(CW$callback\fR\->($tls, \f(CW$ref\fR, \f(CW$cn\fR, \f(CW$depth\fR, \f(CW$preverify_ok\fR, \f(CW$x509_store_ctx\fR, \f(CW$cert\fR)" 4
.IX Item "verify_cb => $callback->($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert)"
Provide a cold-ass lil custom peer verification callback used by \s-1TLS\s0 sessions,
which is called wit tha result of any other verification (\f(CW\*(C`verify\*(C'\fR,
\&\f(CW\*(C`verify_peername\*(C'\fR).
.Sp
This callback will only be called when verification is enabled (\f(CW\*(C`verify
=> 1\*(C'\fR).
.Sp
\&\f(CW$tls\fR is tha \f(CW\*(C`AnyEvent::TLS\*(C'\fR object associated wit tha session,
while \f(CW$ref\fR is whatever tha user associated wit tha session (usually
an AnyEvent::Handle object when used by AnyEvent::Handle).
.Sp
\&\f(CW$depth\fR is tha current verification depth \- \f(CW\*(C`$depth = 0\*(C'\fR means the
certificate ta verify is tha peer certificate, higher levels is its \s-1CA\s0
certificate n' so on. I aint talkin' bout chicken n' gravy biatch. In most cases, you can just return \f(CW$preverify_ok\fR
if tha \f(CW$depth\fR is non-zero:
.Sp
.Vb 2
\&   verify_cb => sub {
\&      mah ($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert) = @_;
\&
\&      return $preverify_ok
\&         if $depth;
\&
\&      # mo' verification
\&   },
.Ve
.Sp
\&\f(CW$preverify_ok\fR is legit iff tha basic verification of tha certificates
was successful (a valid \s-1CA\s0 chain must exist, tha certificate has passed
basic validitizzle checks, peername verification succeeded).
.Sp
\&\f(CW$x509_store_ctx\fR is tha Net::SSLeay::X509_CTX> object.
.Sp
\&\f(CW$cert\fR is tha \f(CW\*(C`Net::SSLeay::X509\*(C'\fR object representin the
peer certificate, or zero if there was a error. Shiiit, dis aint no joke. Yo ass can call
\&\f(CW\*(C`AnyEvent::TLS::certname $cert\*(C'\fR ta git a sick user-readable strang to
identify tha certificate.
.Sp
Da callback must return either \f(CW0\fR ta indicate failure, or \f(CW1\fR to
indicate success.
.ie n .IP "verify_client_once => $enable" 4
.el .IP "verify_client_once => \f(CW$enable\fR" 4
.IX Item "verify_client_once => $enable"
Enable or disable skippin tha client certificate verification on
renegotiations (default is \fIdisabled\fR, tha certificate will always be
checked). Only make sense up in server mode.
.ie n .IP "ca_file => $path" 4
.el .IP "ca_file => \f(CW$path\fR" 4
.IX Item "ca_file => $path"
If dis parameta is specified n' non-empty, it is ghon be tha path ta a
file wit (server) \s-1CA\s0 certificates up in \s-1PEM\s0 format dat is ghon be loaded. Y'all KNOW dat shit, muthafucka! Each
certificate will look like:
.Sp
.Vb 3
\&   \-\-\-\-\-BEGIN CERTIFICATE\-\-\-\-\-
\&   ... (CA certificate up in base64 encoding) ...
\&   \-\-\-\-\-END CERTIFICATE\-\-\-\-\-
.Ve
.Sp
Yo ass gotta enable verify mode (\f(CW\*(C`verify => 1\*(C'\fR) fo' dis parameta to
have any effect.
.ie n .IP "ca_path => $path" 4
.el .IP "ca_path => \f(CW$path\fR" 4
.IX Item "ca_path => $path"
If dis parameta is specified n' non-empty, it will be
the path ta a gangbangin' finger-lickin' directory wit hashed \s-1CA\s0 certificate filez in
\&\s-1PEM\s0 format. When tha ca certificate is bein verified, the
certificate is ghon be hashed n' looked up in dat directory (see
<http://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html> for
details)
.Sp
Da certificates specified via \f(CW\*(C`ca_file\*(C'\fR take precedence over tha ones
found up in \f(CW\*(C`ca_path\*(C'\fR.
.Sp
Yo ass gotta enable verify mode (\f(CW\*(C`verify => 1\*(C'\fR) fo' dis parameta to
have any effect.
.ie n .IP "ca_cert => $string" 4
.el .IP "ca_cert => \f(CW$string\fR" 4
.IX Item "ca_cert => $string"
In addizzle or instead of rockin \f(CW\*(C`ca_file\*(C'\fR and/or \f(CW\*(C`ca_path\*(C'\fR, you can
also use \f(CW\*(C`ca_cert\*(C'\fR ta directly specify tha \s-1CA\s0 certificates (there can be
multiple) up in \s-1PEM\s0 format, up in a string.
.ie n .IP "check_crl => $enable" 4
.el .IP "check_crl => \f(CW$enable\fR" 4
.IX Item "check_crl => $enable"
Enable or disable certificate revocation list checking. If enabled, then
peer certificates is ghon be checked against a list of revoked certificates
issued by tha \s-1CA.\s0 Da revocation lists is ghon be expected up in tha \f(CW\*(C`ca_path\*(C'\fR
directory.
.Sp
certificate verification will fail if dis is enabled but no revocation
list was found.
.Sp
This requires OpenSSL >= 0.9.7b. Peep tha OpenSSL documentation fo' more
details.
.ie n .IP "key_file => $path" 4
.el .IP "key_file => \f(CW$path\fR" 4
.IX Item "key_file => $path"
Path ta tha local private key file up in \s-1PEM\s0 format (might be a cold-ass lil combined
certificate/private key file).
.Sp
Da local certificate is used ta authenticate against tha peer \- servers
mandatorily need a cold-ass lil certificate n' key, clients can bust a cold-ass lil certificate and
key optionally ta authenticate, e.g. fo' log-in purposes.
.Sp
Da key up in tha file should look similar this:
.Sp
.Vb 4
\&   \-\-\-\-\-BEGIN RSA PRIVATE KEY\-\-\-\-\-
\&   ...header data
\&   ... (key data up in base64 encoding) ...
\&   \-\-\-\-\-END RSA PRIVATE KEY\-\-\-\-\-
.Ve
.ie n .IP "key => $string" 4
.el .IP "key => \f(CW$string\fR" 4
.IX Item "key => $string"
Da private key strang up in \s-1PEM\s0 format (see \f(CW\*(C`key_file\*(C'\fR, only one of
\&\f(CW\*(C`key_file\*(C'\fR or \f(CW\*(C`key\*(C'\fR can be specified).
.Sp
Da scam behind bein able ta specify a strang is ta avoid blockin in
I/O. Unfortunately, Net::SSLeay fails ta implement any intercourse ta the
needed OpenSSL functionality, dis is currently implemented by freestylin to
a temporary file.
.ie n .IP "cert_file => $path" 4
.el .IP "cert_file => \f(CW$path\fR" 4
.IX Item "cert_file => $path"
Da path ta tha local certificate file up in \s-1PEM\s0 format (might be a cold-ass lil combined
certificate/private key file, includin chained certificates).
.Sp
Da local certificate (and key) is used ta authenticate against the
peer \- servers mandatorily need a cold-ass lil certificate n' key, clients can use
certificate n' key optionally ta authenticate, e.g. fo' log-in purposes.
.Sp
Da certificate up in tha file should be lookin like this:
.Sp
.Vb 3
\&   \-\-\-\-\-BEGIN CERTIFICATE\-\-\-\-\-
\&   ... (certificate up in base64 encoding) ...
\&   \-\-\-\-\-END CERTIFICATE\-\-\-\-\-
.Ve
.Sp
If tha certificate file or strang contain both tha certificate and
private key, then there is no need ta specify a separate \f(CW\*(C`key_file\*(C'\fR or
\&\f(CW\*(C`key\*(C'\fR.
.Sp
Additionizzle signin certifiates ta bust ta tha peer (in SSLv3 n' newer)
can be specified by appendin dem ta tha certificate proper: tha order
must be from issuer certificate over any intermediate \s-1CA\s0 certificates to
the root \s-1CA.\s0
.Sp
So tha recommended orderin fo' a cold-ass lil combined key/cert/chain file, specified
via \f(CW\*(C`cert_file\*(C'\fR or \f(CW\*(C`cert\*(C'\fR be lookin like this:
.Sp
.Vb 5
\&  certificate private key
\&  client/server certificate
\&  ca 1, signin client/server certficate
\&  ca 2, signin ca 1
\&  ...
.Ve
.ie n .IP "cert => $string" 4
.el .IP "cert => \f(CW$string\fR" 4
.IX Item "cert => $string"
Da local certificate up in \s-1PEM\s0 format (might be a cold-ass lil combined
certificate/private key file). Right back up in yo muthafuckin ass. See \f(CW\*(C`cert_file\*(C'\fR.
.Sp
Da scam behind bein able ta specify a strang is ta avoid blockin in
I/O. Unfortunately, Net::SSLeay fails ta implement any intercourse ta the
needed OpenSSL functionality, dis is currently implemented by freestylin to
a temporary file.
.ie n .IP "cert_password => $strin | $callback\->($tls)" 4
.el .IP "cert_password => \f(CW$string\fR | \f(CW$callback\fR\->($tls)" 4
.IX Item "cert_password => $strin | $callback->($tls)"
Da certificate password \- if tha certificate is password-protected, then
you can specify its password here.
.Sp
Instead of providin a password directly (which aint so recommended),
you can also provide a password-query callback. Da callback will be
called whenever a password is required ta decode a local certificate, and
is supposed ta return tha password.
.ie n .IP "dh_file => $path" 4
.el .IP "dh_file => \f(CW$path\fR" 4
.IX Item "dh_file => $path"
Path ta a gangbangin' file containin Diffie-Hellman parametas up in \s-1PEM\s0 format, for
use up in servers. Right back up in yo muthafuckin ass. See also \f(CW\*(C`dh\*(C'\fR on how tha fuck ta specify dem directly, or use a
pre-generated set.
.Sp
Diffie-Hellman key exchange generates temporary encryption keys that
are not transferred over tha connection, which means dat even if the
certificate key(s) is made hood at a lata time n' a gangbangin' full dump of the
connection exists, tha key still cannot be deduced.
.Sp
These ciphers is only available wit SSLv3 n' lata (which is the
default wit AnyEvent::TLS), n' is only used up in server/accept
mode fo' realz. Anonymous \s-1DH\s0 protocols is probably disabled by default, n' usually
not even compiled tha fuck into tha underlyin library, as they provide no direct
protection against man-in-the-middle attacks. Da same is legit fo' the
common practise of self-signed certificates dat you gotta accept first,
of course.
.ie n .IP "dh => $string" 4
.el .IP "dh => \f(CW$string\fR" 4
.IX Item "dh => $string"
Specify tha Diffie-Hellman parametas up in \s-1PEM\s0 format directly as a string
(see \f(CW\*(C`dh_file\*(C'\fR), tha default is \f(CW\*(C`schmorp1539\*(C'\fR unless \f(CW\*(C`dh_file\*(C'\fR was
specified.
.Sp
AnyEvent::TLS supports supports a fuckin shitload of precomputed \s-1DH\s0 parameters,
since computin dem is expensive. They are:
.Sp
.Vb 2
\&   # from "Assigned Number fo' SKIP Protocols"
\&   skip512, skip1024, skip2048, skip4096
\&
\&   # from schmorp
\&   schmorp1024, schmorp1539, schmorp2048, schmorp4096, schmorp8192
.Ve
.Sp
Da default was chosen as a trade-off between securitizzle n' speed, and
should be secure fo' all dem years. Well shiiiit, it is holla'd dat 2048 bit \s-1DH\s0 parameters
are safe till 2030, n' \s-1DH\s0 parametas shorta than 900 bits is straight-up
insecure.
.Sp
To disable \s-1DH\s0 protocols straight-up, specify \f(CW\*(C`undef\*(C'\fR as \f(CW\*(C`dh\*(C'\fR parameter.
.ie n .IP "dh_single_use => $enable" 4
.el .IP "dh_single_use => \f(CW$enable\fR" 4
.IX Item "dh_single_use => $enable"
Enablez or disablez \*(L"use only once\*(R" mode when rockin Diffie-Hellman key
exchange. When enabled (default), each time a freshly smoked up key is exchanged a new
Diffie-Hellman key is generated, which improves securitizzle as each key is
only used once. When disabled, tha key is ghon be pimped as soon as the
AnyEvent::TLS object is pimped n' is ghon be reused.
.Sp
All tha \s-1DH\s0 parametas supplied wit AnyEvent::TLS should be safe with
\&\f(CW\*(C`dh_single_use\*(C'\fR switched off yo, but \s-1YMMV.\s0
.ie n .IP "cipher_list => $string" 4
.el .IP "cipher_list => \f(CW$string\fR" 4
.IX Item "cipher_list => $string"
Da list of ciphers ta use, as a strang (example:
\&\f(CW\*(C`AES:ALL:!aNULL:!eNULL:+RC4:@STRENGTH\*(C'\fR). Da format
of dis strang n' its default value is documented at
<http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS>.
.ie n .IP "session_ticket => $enable" 4
.el .IP "session_ticket => \f(CW$enable\fR" 4
.IX Item "session_ticket => $enable"
Enablez or disablez \s-1RC5077\s0 support (Session Resumption without Server-Side
State). Da default is disabled fo' clients, as nuff (buggy) \s-1TLS/SSL\s0
servers choke on it yo, but enabled fo' servers.
.Sp
When enabled n' supported by tha server, a session ticket will be
provided ta tha client, which allows fast resumin of connections.
.ie n .IP "prepare => $coderef\->($tls)" 4
.el .IP "prepare => \f(CW$coderef\fR\->($tls)" 4
.IX Item "prepare => $coderef->($tls)"
If dis argument is present, then it is ghon be called wit tha new
AnyEvent::TLS object afta any other initialisation has bee done, up in case
you wish ta fine-tune something...
.RE
.RS 4
.RE
.ie n .IP "$tls = new_from_ssleay AnyEvent::TLS $ctx" 4
.el .IP "\f(CW$tls\fR = new_from_ssleay AnyEvent::TLS \f(CW$ctx\fR" 4
.IX Item "$tls = new_from_ssleay AnyEvent::TLS $ctx"
This constructor takes a existin Net::SSLeay \s-1SSL_CTX\s0 object
(which is just a integer) n' converts it tha fuck into a \f(CW\*(C`AnyEvent::TLS\*(C'\fR
object. This only works cuz AnyEvent::TLS is currently implemented
usin Net::SSLeay fo' realz. As dis is such a wack perl module n' OpenSSL has
such a buggin license, dis might chizzle up in tha future, up in which case
this method might vanish.
.ie n .IP "$ctx = $tls\->ctx" 4
.el .IP "\f(CW$ctx\fR = \f(CW$tls\fR\->ctx" 4
.IX Item "$ctx = $tls->ctx"
Returns tha actual Net::SSLeay::CTX object (just a integer).
.IP "AnyEvent::TLS::init" 4
.IX Item "AnyEvent::TLS::init"
AnyEvent::TLS do on-demand initialisation, n' normally there is no need ta booty-call a initialise
function.
.Sp
As initialisation might take some time (to read e.g. \f(CW\*(C`/dev/urandom\*(C'\fR), this
could be buggin up in some highly interactizzle programs. In dat case, you can
call \f(CW\*(C`AnyEvent::TLS::init\*(C'\fR ta make shizzle there is ghon be no costly initialisation
later n' shit. Well shiiiit, it is harmless ta booty-call \f(CW\*(C`AnyEvent::TLS::init\*(C'\fR multiple times.
.ie n .IP "$certname = AnyEvent::TLS::certname $x509" 4
.el .IP "\f(CW$certname\fR = AnyEvent::TLS::certname \f(CW$x509\fR" 4
.IX Item "$certname = AnyEvent::TLS::certname $x509"
Utilitizzle function dat returns a user-readable strang identifyin tha X509
certificate object.
.SH "SSL/TLS QUICK FACTS"
.IX Header "SSL/TLS QUICK FACTS"
Here is some quick facts bout \s-1TLS/SSL\s0 dat might help you:
.IP "\(bu" 4
A certificate is tha hood key part, a key is tha private key part.
.Sp
While not strictly true, certificates is tha thangs you can hand around
publicly as a kind of identity, while keys should straight-up be kept private,
as provin dat you have tha private key is probably interpreted as being
the entitizzle behind tha certificate.
.IP "\(bu" 4
A certificate is signed by a \s-1CA \s0(Certificate Authority).
.Sp
By signing, tha \s-1CA\s0 basically fronts dat tha certificate it signs
really belongs ta tha identitizzle named up in it, verified accordin ta the
\&\s-1CA\s0 policies. Put ya muthafuckin choppers up if ya feel dis! For e.g. \s-1HTTPS,\s0 tha \s-1CA\s0 probably cook up some fuckin checks dat the
hostname mentioned up in tha certificate straight-up belongs ta tha company/person
that axed tha signin n' owns tha domain.
.IP "\(bu" 4
CAs can be certified by other CAs.
.Sp
Or by theyselves \- a cold-ass lil certificate dat is signed by a \s-1CA\s0 dat is itself
is called a self-signed certificate, a trust chain of length zero. When
you find a cold-ass lil certificate signed by another \s-1CA,\s0 which is up in turn signed by
another \s-1CA\s0 you trust, you gotz a trust chain of depth two.
.IP "\(bu" 4
\&\*(L"Trusting\*(R" a \s-1CA\s0 means trustin all certificates it has signed.
.Sp
If you \*(L"trust\*(R" a \s-1CA\s0 certificate, then all certificates signed by it are
automatically considered trusted as well.
.IP "\(bu" 4
A successfully verified certificate means dat you can be
reasonably shizzle dat whoever yo ass is rappin' wit straight-up is whoz ass his schmoooove ass fronts
he is.
.Sp
By verifyin certificates against a fuckin shitload of CAs dat you trust (meaning
it is signed directly or indirectly by such a \s-1CA\s0), you can smoke up that
the other side straight-up is whoever his schmoooove ass fronts, accordin ta tha \s-1CA\s0 policies,
and yo' belief up in tha integritizzle of tha \s-1CA.\s0
.IP "\(bu" 4
Verifyin tha certificate signature aint every last muthafuckin thang.
.Sp
Even when tha certificate is erect, it might belong ta some muthafucka else: if
www.attacker.com can make yo' computa believe dat it is straight-up called
www.mybank.com (by makin yo' \s-1DNS\s0 server believe dis fo' example),
then it could bust you tha certificate fo' www.attacker.com dat your
software trusts cuz it is signed by a \s-1CA\s0 you trust, n' intercept
all yo' traffic dat you be thinkin goes ta www.mybank.com. This works
because yo' software sees dat tha certificate is erectly signed (for
www.attacker.com) n' you be thinkin yo ass is rappin' ta yo' bank.
.Sp
To thwart dis battle vector, peername verification should be used, which
basically checks dat tha certificate (for www.attacker.com) straight-up
belongs ta tha host yo ass is tryin ta rap ta (www.mybank.com), which in
this example aint tha case, as www.attacker.com (from tha certificate)
doesn't match www.mybank.com (the hostname used ta create tha connection).
.Sp
So peername verification be almost as blingin as checkin tha \s-1CA\s0
signing. Unfortunately, every last muthafuckin protocol implements dis differently, if at
all...
.IP "\(bu" 4
Switchin off verification is sometimes reasonable.
.Sp
Yo ass can switch off verification. I aint talkin' bout chicken n' gravy biatch. Yo ass still git a encrypted connection
that is protected against eavesdroppin n' injection \- you just lose
protection against playa up in tha middle attacks, i.e. some muthafucka else with
enough abilitizzles ta ta intercept all traffic can masquerade her muthafuckin ass as the
other side.
.Sp
For nuff applications, switchin off verification is entirely
reasonable. Downloadin random shiznit from joints rockin \s-1HTTPS\s0 fo' no
reason is such a application. I aint talkin' bout chicken n' gravy biatch. Talkin ta yo' bank n' enterin TANs is
not such a application.
.IP "\(bu" 4
A \s-1SSL/TLS\s0 server always needz a cold-ass lil certificate/key pair ta operate,
for clients dis is optional.
.Sp
Apart from (usually disabled) anonymous cipher suites, a server always
needz a cold-ass lil certificate/key pair ta operate.
.Sp
Clients almost never use certificates yo, but if they do, they can be used
to authenticate tha client, just as server certificates can be used to
authenticate tha server.
.IP "\(bu" 4
\&\s-1SSL\s0 version 2 is straight-up insecure.
.Sp
\&\s-1SSL\s0 version 2 is oldschool n' not only has it some securitizzle issues, SSLv2\-only
implementations is probably buggy, too, cuz of they age.
.IP "\(bu" 4
Sometimes, even losin yo' \*(L"private\*(R" key might not expose all your
data.
.Sp
With Diffie-Hellman ephemeral key exchange, you can lose tha \s-1DH\s0 parameters
(the \*(L"keys\*(R") yo, but all yo' connections is still protected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Diffie-Hellman
needz special set-up (done by default by AnyEvent::TLS).
.SH "SECURITY CONSIDERATIONS"
.IX Header "SECURITY CONSIDERATIONS"
When you use any of tha options dat pass up in keys or certificates
as strings (e.g. \f(CW\*(C`ca_cert\*(C'\fR), then, cuz of straight-up shortcomings in
Net::SSLeay, dis module creates a temporary file ta store tha strang \-
see File::Temp n' possibly its \f(CW\*(C`safe_level\*(C'\fR settin fo' mo' details
on what tha fuck ta peep up for.
.SH "BUGS"
.IX Header "BUGS"
To ta tha abysmal code qualitizzle of Net::SSLeay, dis module will leak small
amountz of memory per \s-1TLS\s0 connection (currently at least one perl scalar).
.SH "AUTHORS"
.IX Header "AUTHORS"
Marc Lehmann <schmorp@schmorp.de>.
.PP
Some of tha \s-1API,\s0 documentation n' implementation (verify_hostname),
and a shitload of ideas/workarounds/knowledge done been taken from the
IO::Socket::SSL module. Care has been taken ta keep tha \s-1API\s0 similar to
that n' other modules, ta tha extent possible while providin a sensible
\&\s-1API\s0 fo' AnyEvent.
