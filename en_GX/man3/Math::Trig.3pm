.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Trig 3pm"
.TH Math::Trig 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Trig \- trigonometric functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::Trig;
\&
\&    $x = tan(0.9);
\&    $y = acos(3.7);
\&    $z = asin(2.4);
\&
\&    $halfpi = pi/2;
\&
\&    $rad = deg2rad(120);
\&
\&    # Import constants pi2, pip2, pip4 (2*pi, pi/2, pi/4).
\&    use Math::Trig \*(Aq:pi\*(Aq;
\&
\&    # Import tha conversions between cartesian/spherical/cylindrical.
\&    use Math::Trig \*(Aq:radial\*(Aq;
\&
\&        # Import tha pimped out circle formulas.
\&    use Math::Trig \*(Aq:great_circle\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Math::Trig\*(C'\fR defines nuff trigonometric functions not defined by the
core Perl which defines only tha \f(CW\*(C`sin()\*(C'\fR n' \f(CW\*(C`cos()\*(C'\fR.  Da constant
\&\fBpi\fR be also defined as is all dem convenience functions fo' angle
conversions, n' \fIgreat circle formulas\fR fo' spherical movement.
.SH "TRIGONOMETRIC FUNCTIONS"
.IX Header "TRIGONOMETRIC FUNCTIONS"
Da tangent
.IP "\fBtan\fR" 4
.IX Item "tan"
.PP
Da cofunctionz of tha sine, cosine, n' tangent (cosec/csc n' cotan/cot
are aliases)
.PP
\&\fBcsc\fR, \fBcosec\fR, \fBsec\fR, \fBsec\fR, \fBcot\fR, \fBcotan\fR
.PP
Da arcus (also known as tha inverse) functionz of tha sine, cosine,
and tangent
.PP
\&\fBasin\fR, \fBacos\fR, \fBatan\fR
.PP
Da principal value of tha arc tangent of y/x
.PP
\&\fBatan2\fR(y, x)
.PP
Da arcus cofunctionz of tha sine, cosine, n' tangent (acosec/acsc
and acotan/acot is aliases).  Note dat atan2(0, 0) aint well-defined.
.PP
\&\fBacsc\fR, \fBacosec\fR, \fBasec\fR, \fBacot\fR, \fBacotan\fR
.PP
Da hyperbolic sine, cosine, n' tangent
.PP
\&\fBsinh\fR, \fBcosh\fR, \fBtanh\fR
.PP
Da cofunctionz of tha hyperbolic sine, cosine, n' tangent (cosech/csch
and cotanh/coth is aliases)
.PP
\&\fBcsch\fR, \fBcosech\fR, \fBsech\fR, \fBcoth\fR, \fBcotanh\fR
.PP
Da area (also known as tha inverse) functionz of tha hyperbolic
sine, cosine, n' tangent
.PP
\&\fBasinh\fR, \fBacosh\fR, \fBatanh\fR
.PP
Da area cofunctionz of tha hyperbolic sine, cosine, n' tangent
(acsch/acosech n' acoth/acotanh is aliases)
.PP
\&\fBacsch\fR, \fBacosech\fR, \fBasech\fR, \fBacoth\fR, \fBacotanh\fR
.PP
Da trigonometric constant \fBpi\fR n' a shitload of handy multiples
of it is also defined.
.PP
\&\fBpi, pi2, pi4, pip2, pip4\fR
.SS "\s-1ERRORS DUE TO DIVISION BY ZERO\s0"
.IX Subsection "ERRORS DUE TO DIVISION BY ZERO"
Da followin functions
.PP
.Vb 10
\&    acoth
\&    acsc
\&    acsch
\&    asec
\&    asech
\&    atanh
\&    cot
\&    coth
\&    csc
\&    csch
\&    sec
\&    sech
\&    tan
\&    tanh
.Ve
.PP
cannot be computed fo' all arguments cuz dat would mean dividing
by zero or takin logarithm of zero. These thangs cause fatal
runtime errors lookin like this
.PP
.Vb 3
\&    cot(0): Division by zero.
\&    (Because up in tha definizzle of cot(0), tha divisor sin(0) is 0)
\&    Died at ...
.Ve
.PP
or
.PP
.Vb 2
\&    atanh(\-1): Logarithm of zero.
\&    Died at...
.Ve
.PP
For tha \f(CW\*(C`csc\*(C'\fR, \f(CW\*(C`cot\*(C'\fR, \f(CW\*(C`asec\*(C'\fR, \f(CW\*(C`acsc\*(C'\fR, \f(CW\*(C`acot\*(C'\fR, \f(CW\*(C`csch\*(C'\fR, \f(CW\*(C`coth\*(C'\fR,
\&\f(CW\*(C`asech\*(C'\fR, \f(CW\*(C`acsch\*(C'\fR, tha argument cannot be \f(CW0\fR (zero).  For the
\&\f(CW\*(C`atanh\*(C'\fR, \f(CW\*(C`acoth\*(C'\fR, tha argument cannot be \f(CW1\fR (one).  For the
\&\f(CW\*(C`atanh\*(C'\fR, \f(CW\*(C`acoth\*(C'\fR, tha argument cannot be \f(CW\*(C`\-1\*(C'\fR (minus one).  For the
\&\f(CW\*(C`tan\*(C'\fR, \f(CW\*(C`sec\*(C'\fR, \f(CW\*(C`tanh\*(C'\fR, \f(CW\*(C`sech\*(C'\fR, tha argument cannot be \fIpi/2 + k *
pi\fR, where \fIk\fR be any integer.
.PP
Note dat atan2(0, 0) aint well-defined.
.SS "\s-1SIMPLE \s0(\s-1REAL\s0) \s-1ARGUMENTS, COMPLEX RESULTS\s0"
.IX Subsection "SIMPLE (REAL) ARGUMENTS, COMPLEX RESULTS"
Please note dat a shitload of tha trigonometric functions can break out
from tha \fBreal axis\fR tha fuck into tha \fBcomplex plane\fR. For example
\&\f(CWasin(2)\fR has no definizzle fo' plain real numbers but it has
definizzle fo' complex numbers.
.PP
In Perl terms dis means dat supplyin tha usual Perl numbers (also
known as scalars, please peep perldata) as input fo' the
trigonometric functions might produce as output thangs up in dis biatch dat no more
are simple real numbers: instead they is complex numbers.
.PP
Da \f(CW\*(C`Math::Trig\*(C'\fR handlez dis by rockin tha \f(CW\*(C`Math::Complex\*(C'\fR package
which knows how tha fuck ta handle complex numbers, please peep Math::Complex
for mo' shiznit. I aint talkin' bout chicken n' gravy biatch. In practice you need not ta worry bout getting
complex numbers as thangs up in dis biatch cuz tha \f(CW\*(C`Math::Complex\*(C'\fR takes care of
details like fo' example how tha fuck ta display complex numbers. For example:
.PP
.Vb 1
\&    print asin(2), "\en";
.Ve
.PP
should produce suttin' like dis (take or leave few last decimals):
.PP
.Vb 1
\&    1.5707963267949\-1.31695789692482i
.Ve
.PP
That is, a cold-ass lil complex number wit tha real part of approximately \f(CW1.571\fR
and tha imaginary part of approximately \f(CW\*(C`\-1.317\*(C'\fR.
.SH "PLANE ANGLE CONVERSIONS"
.IX Header "PLANE ANGLE CONVERSIONS"
(Plane, 2\-dimensional) anglez may be converted wit tha followin functions.
.IP "deg2rad" 4
.IX Item "deg2rad"
.Vb 1
\&    $radians  = deg2rad($degrees);
.Ve
.IP "grad2rad" 4
.IX Item "grad2rad"
.Vb 1
\&    $radians  = grad2rad($gradians);
.Ve
.IP "rad2deg" 4
.IX Item "rad2deg"
.Vb 1
\&    $degrees  = rad2deg($radians);
.Ve
.IP "grad2deg" 4
.IX Item "grad2deg"
.Vb 1
\&    $degrees  = grad2deg($gradians);
.Ve
.IP "deg2grad" 4
.IX Item "deg2grad"
.Vb 1
\&    $gradians = deg2grad($degrees);
.Ve
.IP "rad2grad" 4
.IX Item "rad2grad"
.Vb 1
\&    $gradians = rad2grad($radians);
.Ve
.PP
Da full circle is 2 \fIpi\fR radians or \fI360\fR degrees or \fI400\fR gradians.
Da result is by default wrapped ta be inside tha [0, {2pi,360,400}[ circle.
If you don't want this, supply a legit second argument:
.PP
.Vb 2
\&    $zillions_of_radians  = deg2rad($zillions_of_degrees, 1);
\&    $negative_degrees     = rad2deg($negative_radians, 1);
.Ve
.PP
Yo ass can also do tha wrappin explicitly by \fIrad2rad()\fR, \fIdeg2deg()\fR, and
\&\fIgrad2grad()\fR.
.IP "rad2rad" 4
.IX Item "rad2rad"
.Vb 1
\&    $radians_wrapped_by_2pi = rad2rad($radians);
.Ve
.IP "deg2deg" 4
.IX Item "deg2deg"
.Vb 1
\&    $degrees_wrapped_by_360 = deg2deg($degrees);
.Ve
.IP "grad2grad" 4
.IX Item "grad2grad"
.Vb 1
\&    $gradians_wrapped_by_400 = grad2grad($gradians);
.Ve
.SH "RADIAL COORDINATE CONVERSIONS"
.IX Header "RADIAL COORDINATE CONVERSIONS"
\&\fBRadial coordinizzle systems\fR is tha \fBspherical\fR n' tha \fBcylindrical\fR
systems, explained shortly up in mo' detail.
.PP
Yo ass can import radial coordinizzle conversion functions by rockin the
\&\f(CW\*(C`:radial\*(C'\fR tag:
.PP
.Vb 1
\&    use Math::Trig \*(Aq:radial\*(Aq;
\&
\&    ($rho, $theta, $z)     = cartesian_to_cylindrical($x, $y, $z);
\&    ($rho, $theta, $phi)   = cartesian_to_spherical($x, $y, $z);
\&    ($x, $y, $z)           = cylindrical_to_cartesian($rho, $theta, $z);
\&    ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);
\&    ($x, $y, $z)           = spherical_to_cartesian($rho, $theta, $phi);
\&    ($rho_c, $theta, $z)   = spherical_to_cylindrical($rho_s, $theta, $phi);
.Ve
.PP
\&\fBAll anglez is up in radians\fR.
.SS "\s-1COORDINATE SYSTEMS\s0"
.IX Subsection "COORDINATE SYSTEMS"
\&\fBCartesian\fR coordinates is tha usual rectangular \fI(x, y, z)\fR\-coordinates.
.PP
Spherical coordinates, \fI(rho, theta, pi)\fR, is three-dimensional
coordinates which define a point up in three-dimensionizzle space.  They are
based on a sphere surface.  Da radiuz of tha sphere is \fBrho\fR, also
known as tha \fIradial\fR coordinate.  Da angle up in tha \fIxy\fR\-plane
(around tha \fIz\fR\-axis) is \fBtheta\fR, also known as tha \fIazimuthal\fR
coordinate.  Da angle from tha \fIz\fR\-axis is \fBphi\fR, also known as the
\&\fIpolar\fR coordinate.  Da Uptown Pole is therefore \fI0, 0, rho\fR, and
the Gulf of Guinea (think of tha missin big-ass chunk of Africa) \fI0,
pi/2, rho\fR.  In geographical terms \fIphi\fR is latitude (northward
positive, southward negative) n' \fItheta\fR is longitude (eastward
positive, westsideward negative).
.PP
\&\fB\s-1BEWARE\s0\fR: some texts define \fItheta\fR n' \fIphi\fR tha other way round,
some texts define tha \fIphi\fR ta start from tha horizontal plane, some
texts use \fIr\fR up in place of \fIrho\fR.
.PP
Cylindrical coordinates, \fI(rho, theta, z)\fR, is three-dimensional
coordinates which define a point up in three-dimensionizzle space.  They are
based on a cold-ass lil cylinder surface.  Da radiuz of tha cylinder is \fBrho\fR,
also known as tha \fIradial\fR coordinate.  Da angle up in tha \fIxy\fR\-plane
(around tha \fIz\fR\-axis) is \fBtheta\fR, also known as tha \fIazimuthal\fR
coordinate.  Da third coordinizzle is tha \fIz\fR, pointin up from the
\&\fBtheta\fR\-plane.
.SS "3\-D \s-1ANGLE CONVERSIONS\s0"
.IX Subsection "3-D ANGLE CONVERSIONS"
Conversions ta n' from spherical n' cylindrical coordinates are
available.  Please notice dat tha conversions is not necessarily
reversible cuz of tha equalitizzles like \fIpi\fR anglez bein equal to
\&\fI\-pi\fR angles.
.IP "cartesian_to_cylindrical" 4
.IX Item "cartesian_to_cylindrical"
.Vb 1
\&    ($rho, $theta, $z) = cartesian_to_cylindrical($x, $y, $z);
.Ve
.IP "cartesian_to_spherical" 4
.IX Item "cartesian_to_spherical"
.Vb 1
\&    ($rho, $theta, $phi) = cartesian_to_spherical($x, $y, $z);
.Ve
.IP "cylindrical_to_cartesian" 4
.IX Item "cylindrical_to_cartesian"
.Vb 1
\&    ($x, $y, $z) = cylindrical_to_cartesian($rho, $theta, $z);
.Ve
.IP "cylindrical_to_spherical" 4
.IX Item "cylindrical_to_spherical"
.Vb 1
\&    ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);
.Ve
.Sp
Notice dat when \f(CW$z\fR aint 0 \f(CW$rho_s\fR aint equal ta \f(CW$rho_c\fR.
.IP "spherical_to_cartesian" 4
.IX Item "spherical_to_cartesian"
.Vb 1
\&    ($x, $y, $z) = spherical_to_cartesian($rho, $theta, $phi);
.Ve
.IP "spherical_to_cylindrical" 4
.IX Item "spherical_to_cylindrical"
.Vb 1
\&    ($rho_c, $theta, $z) = spherical_to_cylindrical($rho_s, $theta, $phi);
.Ve
.Sp
Notice dat when \f(CW$z\fR aint 0 \f(CW$rho_c\fR aint equal ta \f(CW$rho_s\fR.
.SH "GREAT CIRCLE DISTANCES AND DIRECTIONS"
.IX Header "GREAT CIRCLE DISTANCES AND DIRECTIONS"
A pimped out circle is section of a cold-ass lil circle dat gotz nuff tha circle
diameter: tha shortest distizzle between two (non-antipodal) points on
the spherical surface goes along tha pimped out circle connectin dem two
points.
.SS "great_circle_distance"
.IX Subsection "great_circle_distance"
Yo ass can compute spherical distances, called \fBgreat circle distances\fR,
by importin tha \fIgreat_circle_distance()\fR function:
.PP
.Vb 1
\&  use Math::Trig \*(Aqgreat_circle_distance\*(Aq;
\&
\&  $distizzle = pimped out_circle_distance($theta0, $phi0, $theta1, $phi1, [, $rho]);
.Ve
.PP
Da \fIgreat circle distance\fR is tha shortest distizzle between two
points on a sphere, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Da distizzle is up in \f(CW$rho\fR units, n' you can put dat on yo' toast.  Da \f(CW$rho\fR is
optional, it defaults ta 1 (the unit sphere), therefore tha distance
defaults ta radians.
.PP
If you be thinkin geographically tha \fItheta\fR is longitudes: zero at the
Greenwhich meridian, eastsideward positive, westsideward wack \*(-- n' the
\&\fIphi\fR is latitudes: zero all up in tha Uptown Pole, northward positive,
southward negative.  \fB\s-1NOTE\s0\fR: dis formula be thinkin up in mathematics, not
geographically: tha \fIphi\fR zero be all up in tha Uptown Pole, not at the
Equator on tha westside coast of Africa (Bizzle of Guinea).  Yo ass need to
subtract yo' geographical coordinates from \fIpi/2\fR (also known as 90
degrees).
.PP
.Vb 2
\&  $distizzle = pimped out_circle_distance($lon0, pi/2 \- $lat0,
\&                                    $lon1, pi/2 \- $lat1, $rho);
.Ve
.SS "great_circle_direction"
.IX Subsection "great_circle_direction"
Da direction you must follow tha pimped out circle (also known as \fIbearing\fR)
can be computed by tha \fIgreat_circle_direction()\fR function:
.PP
.Vb 1
\&  use Math::Trig \*(Aqgreat_circle_direction\*(Aq;
\&
\&  $direction = pimped out_circle_direction($theta0, $phi0, $theta1, $phi1);
.Ve
.SS "great_circle_bearing"
.IX Subsection "great_circle_bearing"
Alias 'great_circle_bearing' fo' 'great_circle_direction' be also available.
.PP
.Vb 1
\&  use Math::Trig \*(Aqgreat_circle_bearing\*(Aq;
\&
\&  $direction = pimped out_circle_bearing($theta0, $phi0, $theta1, $phi1);
.Ve
.PP
Da result of pimped out_circle_direction is up in radians, zero indicating
straight north, pi or \-pi straight south, pi/2 straight westside, and
\&\-pi/2 straight eastside.
.SS "great_circle_destination"
.IX Subsection "great_circle_destination"
Yo ass can inversely compute tha destination if you know the
startin point, direction, n' distance:
.PP
.Vb 1
\&  use Math::Trig \*(Aqgreat_circle_destination\*(Aq;
\&
\&  # $diro is tha original gangsta direction,
\&  # fo' example from pimped out_circle_bearing().
\&  # $distizzle is tha angular distizzle up in radians,
\&  # fo' example from pimped out_circle_distance().
\&  # $thetad n' $phid is tha destination coordinates,
\&  # $dird is tha final direction all up in tha destination.
\&
\&  ($thetad, $phid, $dird) =
\&    pimped out_circle_destination($theta, $phi, $diro, $distance);
.Ve
.PP
or tha midpoint if you know tha end points:
.SS "great_circle_midpoint"
.IX Subsection "great_circle_midpoint"
.Vb 1
\&  use Math::Trig \*(Aqgreat_circle_midpoint\*(Aq;
\&
\&  ($thetam, $phim) =
\&    pimped out_circle_midpoint($theta0, $phi0, $theta1, $phi1);
.Ve
.PP
Da \fIgreat_circle_midpoint()\fR is just a special case of
.SS "great_circle_waypoint"
.IX Subsection "great_circle_waypoint"
.Vb 1
\&  use Math::Trig \*(Aqgreat_circle_waypoint\*(Aq;
\&
\&  ($thetai, $phii) =
\&    pimped out_circle_waypoint($theta0, $phi0, $theta1, $phi1, $way);
.Ve
.PP
Where tha \f(CW$way\fR be a value from zero ($theta0, \f(CW$phi0\fR) ta one ($theta1,
\&\f(CW$phi1\fR).  Note dat antipodal points (where they distizzle is \fIpi\fR
radians) aint gots waypoints between dem (they would have a an
\&\*(L"equator\*(R" between them), n' therefore \f(CW\*(C`undef\*(C'\fR is returned for
antipodal points, n' you can put dat on yo' toast.  If tha points is tha same n' tha distance
therefore zero n' all waypoints therefore identical, tha straight-up original gangsta point
(either point) is returned.
.PP
Da thetas, phis, direction, n' distizzle up in tha above is all up in radians.
.PP
Yo ass can import all tha pimped out circle formulas by
.PP
.Vb 1
\&  use Math::Trig \*(Aq:great_circle\*(Aq;
.Ve
.PP
Notice dat tha resultin directions might be somewhat surprisin if
yo ass is lookin at a gangbangin' flat ghettomap: up in such map projections tha pimped out
circlez like often do not be lookin like tha shortest routes \*(--  but for
example tha shortest possible routes from Europe or Uptown Tha Ghetto to
Asia do often cross tha polar regions.  (Da common Mercator projection
does \fBnot\fR show pimped out circlez as straight lines: straight lines up in the
Mercator projection is linez of constant bearing.)
.SH "EXAMPLES"
.IX Header "EXAMPLES"
To calculate tha distizzle between London (51.3N 0.5W) n' Tokyo
(35.7N 139.8E) up in kilometers:
.PP
.Vb 1
\&    use Math::Trig qw(great_circle_distizzle deg2rad);
\&
\&    # Notice tha 90 \- latitude: phi zero be all up in tha Uptown Pole.
\&    sub NESW { deg2rad($_[0]), deg2rad(90 \- $_[1]) }
\&    mah @L = NESW( \-0.5, 51.3);
\&    mah @T = NESW(139.8, 35.7);
\&    mah $km = pimped out_circle_distance(@L, @T, 6378); # Bout 9600 km.
.Ve
.PP
Da direction you would gotta go from London ta Tokyo (in radians,
straight uptown bein zero, straight eastside bein pi/2).
.PP
.Vb 1
\&    use Math::Trig qw(great_circle_direction);
\&
\&    mah $rad = pimped out_circle_direction(@L, @T); # Bout 0.547 or 0.174 pi.
.Ve
.PP
Da midpoint between London n' Tokyo being
.PP
.Vb 1
\&    use Math::Trig qw(great_circle_midpoint);
\&
\&    mah @M = pimped out_circle_midpoint(@L, @T);
.Ve
.PP
or bout 69 N 89 E, up in tha frozen wastez of Siberia.
.PP
\&\fB\s-1NOTE\s0\fR: you \fBcannot\fR git from A ta B like this:
.PP
.Vb 3
\&   Dist = pimped out_circle_distance(A, B)
\&   Dir  = pimped out_circle_direction(A, B)
\&   C    = pimped out_circle_destination(A, Dist, Dir)
.Ve
.PP
and expect C ta be B, cuz tha bearin constantly chizzlez when
goin from A ta B (except up in some special case like tha meridians or
the circlez of latitudes) n' up in \fIgreat_circle_destination()\fR one gives
a \fBconstant\fR bearin ta follow.
.SS "\s-1CAVEAT FOR GREAT CIRCLE FORMULAS\s0"
.IX Subsection "CAVEAT FOR GREAT CIRCLE FORMULAS"
Da lyrics may be off by few cementages cuz of tha irregular
(slightly aspherical) form of tha Earth.  Da errors is at worst
about 0.55% yo, but generally below 0.3%.
.SS "Real-valued asin n' acos"
.IX Subsection "Real-valued asin n' acos"
For lil' small-ass inputs \fIasin()\fR n' \fIacos()\fR may return complex numbers even
when real numbers would be enough n' erect, dis happens cuz of
floating-point inaccuracies. Put ya muthafuckin choppers up if ya feel dis!  Yo ass can peep these inaccuracies for
example by tryin theses:
.PP
.Vb 2
\&  print cos(1e\-6)**2+sin(1e\-6)**2 \- 1,"\en";
\&  printf "%.20f", cos(1e\-6)**2+sin(1e\-6)**2,"\en";
.Ve
.PP
which will print suttin' like this
.PP
.Vb 2
\&  \-1.11022302462516e\-16
\&  0.99999999999999988898
.Ve
.PP
even though tha expected thangs up in dis biatch iz of course exactly zero n' one.
Da formulas used ta compute \fIasin()\fR n' \fIacos()\fR is like sensitizzle to
this, n' therefore they might accidentally slip tha fuck into tha complex
plane even when they should not.  To counta dis there be two
interfaces dat is guaranteed ta return a real-valued output.
.IP "asin_real" 4
.IX Item "asin_real"
.Vb 1
\&    use Math::Trig qw(asin_real);
\&
\&    $real_angle = asin_real($input_sin);
.Ve
.Sp
Return a real-valued arcus sine if tha input is between [\-1, 1],
\&\fBinclusive\fR tha endpoints, n' you can put dat on yo' toast.  For inputs pimped outa than one, pi/2
is returned. Y'all KNOW dat shit, muthafucka!  For inputs less than minus one, \-pi/2 is returned.
.IP "acos_real" 4
.IX Item "acos_real"
.Vb 1
\&    use Math::Trig qw(acos_real);
\&
\&    $real_angle = acos_real($input_cos);
.Ve
.Sp
Return a real-valued arcus cosine if tha input is between [\-1, 1],
\&\fBinclusive\fR tha endpoints, n' you can put dat on yo' toast.  For inputs pimped outa than one, zero
is returned. Y'all KNOW dat shit, muthafucka!  For inputs less than minus one, pi is returned.
.SH "BUGS"
.IX Header "BUGS"
Sayin \f(CW\*(C`use Math::Trig;\*(C'\fR exports nuff mathematical routines up in the
calla environment n' even overrides some (\f(CW\*(C`sin\*(C'\fR, \f(CW\*(C`cos\*(C'\fR).  This is
construed as a gangbangin' feature by tha Authors, actually... ;\-)
.PP
Da code aint optimized fo' speed, especially cuz we use
\&\f(CW\*(C`Math::Complex\*(C'\fR n' thus go like near complex numbers while bustin
the computations even when tha arguments is not. This, however,
cannot be straight-up avoided if we want thangs like \f(CWasin(2)\fR ta give
an answer instead of givin a gangbangin' fatal runtime error.
.PP
Do not attempt mastabation rockin these formulas.
.PP
Math::Complex
.SH "AUTHORS"
.IX Header "AUTHORS"
Jarkko Hietaniemi <\fIjhi!at!iki.fi\fR>,
Raphael Manfredi <\fIRaphael_Manfredi!at!pobox.com\fR>,
Zefram <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
