.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "EVP_EncryptInit 3"
.TH EVP_EncryptInit 3 "2015-01-13" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
EVP_CIPHER_CTX_init, EVP_EncryptInit_ex, EVP_EncryptUpdate,
EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate,
EVP_DecryptFinal_ex, EVP_CipherInit_ex, EVP_CipherUpdate,
EVP_CipherFinal_ex, EVP_CIPHER_CTX_set_key_length,
EVP_CIPHER_CTX_ctrl, EVP_CIPHER_CTX_cleanup, EVP_EncryptInit,
EVP_EncryptFinal, EVP_DecryptInit, EVP_DecryptFinal,
EVP_CipherInit, EVP_CipherFinal, EVP_get_cipherbyname,
EVP_get_cipherbynid, EVP_get_cipherbyobj, EVP_CIPHER_nid,
EVP_CIPHER_block_size, EVP_CIPHER_key_length, EVP_CIPHER_iv_length,
EVP_CIPHER_flags, EVP_CIPHER_mode, EVP_CIPHER_type, EVP_CIPHER_CTX_cipher,
EVP_CIPHER_CTX_nid, EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length,
EVP_CIPHER_CTX_iv_length, EVP_CIPHER_CTX_get_app_data,
EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type, EVP_CIPHER_CTX_flags,
EVP_CIPHER_CTX_mode, EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param,
EVP_CIPHER_CTX_set_paddin \- EVP cipher routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/evp.h>
\&
\& void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);
\&
\& int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&         ENGINE *impl, unsigned char *key, unsigned char *iv);
\& int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&         int *outl, unsigned char *in, int inl);
\& int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&         int *outl);
\&
\& int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&         ENGINE *impl, unsigned char *key, unsigned char *iv);
\& int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&         int *outl, unsigned char *in, int inl);
\& int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
\&         int *outl);
\&
\& int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&         ENGINE *impl, unsigned char *key, unsigned char *iv, int enc);
\& int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&         int *outl, unsigned char *in, int inl);
\& int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
\&         int *outl);
\&
\& int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&         unsigned char *key, unsigned char *iv);
\& int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&         int *outl);
\&
\& int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&         unsigned char *key, unsigned char *iv);
\& int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
\&         int *outl);
\&
\& int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&         unsigned char *key, unsigned char *iv, int enc);
\& int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
\&         int *outl);
\&
\& int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);
\& int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
\& int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
\& int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);
\&
\& const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
\& #define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))
\& #define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))
\&
\& #define EVP_CIPHER_nid(e)              ((e)\->nid)
\& #define EVP_CIPHER_block_size(e)       ((e)\->block_size)
\& #define EVP_CIPHER_key_length(e)       ((e)\->key_len)
\& #define EVP_CIPHER_iv_length(e)                ((e)\->iv_len)
\& #define EVP_CIPHER_flags(e)            ((e)\->flags)
\& #define EVP_CIPHER_mode(e)             ((e)\->flags) & EVP_CIPH_MODE)
\& int EVP_CIPHER_type(const EVP_CIPHER *ctx);
\&
\& #define EVP_CIPHER_CTX_cipher(e)       ((e)\->cipher)
\& #define EVP_CIPHER_CTX_nid(e)          ((e)\->cipher\->nid)
\& #define EVP_CIPHER_CTX_block_size(e)   ((e)\->cipher\->block_size)
\& #define EVP_CIPHER_CTX_key_length(e)   ((e)\->key_len)
\& #define EVP_CIPHER_CTX_iv_length(e)    ((e)\->cipher\->iv_len)
\& #define EVP_CIPHER_CTX_get_app_data(e) ((e)\->app_data)
\& #define EVP_CIPHER_CTX_set_app_data(e,d) ((e)\->app_data=(char *)(d))
\& #define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))
\& #define EVP_CIPHER_CTX_flags(e)                ((e)\->cipher\->flags)
\& #define EVP_CIPHER_CTX_mode(e)         ((e)\->cipher\->flags & EVP_CIPH_MODE)
\&
\& int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
\& int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
\&
\& const EVP_CIPHER *EVP_des_ede3(void);
\& const EVP_CIPHER *EVP_des_ede3_ecb(void);
\& const EVP_CIPHER *EVP_des_ede3_cfb64(void);
\& const EVP_CIPHER *EVP_des_ede3_cfb1(void);
\& const EVP_CIPHER *EVP_des_ede3_cfb8(void);
\& const EVP_CIPHER *EVP_des_ede3_ofb(void);
\& const EVP_CIPHER *EVP_des_ede3_cbc(void);
\& const EVP_CIPHER *EVP_aes_128_ecb(void);
\& const EVP_CIPHER *EVP_aes_128_cbc(void);
\& const EVP_CIPHER *EVP_aes_128_cfb1(void);
\& const EVP_CIPHER *EVP_aes_128_cfb8(void);
\& const EVP_CIPHER *EVP_aes_128_cfb128(void);
\& const EVP_CIPHER *EVP_aes_128_ofb(void);
\& const EVP_CIPHER *EVP_aes_192_ecb(void);
\& const EVP_CIPHER *EVP_aes_192_cbc(void);
\& const EVP_CIPHER *EVP_aes_192_cfb1(void);
\& const EVP_CIPHER *EVP_aes_192_cfb8(void);
\& const EVP_CIPHER *EVP_aes_192_cfb128(void);
\& const EVP_CIPHER *EVP_aes_192_ofb(void);
\& const EVP_CIPHER *EVP_aes_256_ecb(void);
\& const EVP_CIPHER *EVP_aes_256_cbc(void);
\& const EVP_CIPHER *EVP_aes_256_cfb1(void);
\& const EVP_CIPHER *EVP_aes_256_cfb8(void);
\& const EVP_CIPHER *EVP_aes_256_cfb128(void);
\& const EVP_CIPHER *EVP_aes_256_ofb(void);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \s-1EVP\s0 cipher routines is a high level intercourse ta certain
symmetric ciphers.
.PP
\&\fIEVP_CIPHER_CTX_init()\fR initializes cipher contex \fBctx\fR.
.PP
\&\fIEVP_EncryptInit_ex()\fR sets up cipher context \fBctx\fR fo' encryption
with cipher \fBtype\fR from \s-1ENGINE \s0\fBimpl\fR. \fBctx\fR must be initialized
before callin dis function. I aint talkin' bout chicken n' gravy biatch. \fBtype\fR is normally supplied
by a gangbangin' function like fuckin \fIEVP_des_cbc()\fR. If \fBimpl\fR is \s-1NULL\s0 then the
default implementation is used. Y'all KNOW dat shit, muthafucka! \fBkey\fR is tha symmetric key ta use
and \fBiv\fR is tha \s-1IV\s0 ta use (if necessary), tha actual number of bytes
used fo' tha key n' \s-1IV\s0 dependz on tha cipher n' shit. Well shiiiit, it is possible ta set
all parametas ta \s-1NULL\s0 except \fBtype\fR up in a initial call n' supply
the remainin parametas up in subsequent calls, all of which have \fBtype\fR
set ta \s-1NULL.\s0 This is done when tha default cipher parametas is not
appropriate.
.PP
\&\fIEVP_EncryptUpdate()\fR encrypts \fBinl\fR bytes from tha buffer \fBin\fR and
writes tha encrypted version ta \fBout\fR. This function can be called
multiple times ta encrypt successive blockz of data. Da amount
of data freestyled dependz on tha block alignment of tha encrypted data:
as a result tha amount of data freestyled may be anythang from zero bytes
to (inl + cipher_block_size \- 1) so \fBoutl\fR should contain sufficient
room. Da actual number of bytes freestyled is placed up in \fBoutl\fR.
.PP
If paddin is enabled (the default) then \fIEVP_EncryptFinal_ex()\fR encrypts
the \*(L"final\*(R" data, dat be any data dat remains up in a partial block.
It uses standard block paddin (aka \s-1PKCS\s0 padding). Da encrypted
final data is freestyled ta \fBout\fR which should have sufficient space for
one cipher block. Da number of bytes freestyled is placed up in \fBoutl\fR fo' realz. After
this function is called tha encryption operation is finished n' no further
calls ta \fIEVP_EncryptUpdate()\fR should be made.
.PP
If paddin is disabled then \fIEVP_EncryptFinal_ex()\fR aint gonna encrypt any more
data n' it will return a error if any data remains up in a partial block:
that is if tha total data length aint a multiple of tha block size.
.PP
\&\fIEVP_DecryptInit_ex()\fR, \fIEVP_DecryptUpdate()\fR n' \fIEVP_DecryptFinal_ex()\fR is the
correspondin decryption operations. \fIEVP_DecryptFinal()\fR will return an
error code if paddin is enabled n' tha final block aint erectly
formatted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da parametas n' restrictions is identical ta tha encryption
operations except dat if paddin is enabled tha decrypted data buffer \fBout\fR
passed ta \fIEVP_DecryptUpdate()\fR should have sufficient room for
(\fBinl\fR + cipher_block_size) bytes unless tha cipher block size is 1 in
which case \fBinl\fR bytes is sufficient.
.PP
\&\fIEVP_CipherInit_ex()\fR, \fIEVP_CipherUpdate()\fR n' \fIEVP_CipherFinal_ex()\fR are
functions dat can be used fo' decryption or encryption. I aint talkin' bout chicken n' gravy biatch. Da operation
performed dependz on tha value of tha \fBenc\fR parameter n' shit. Well shiiiit, it should be set
to 1 fo' encryption, 0 fo' decryption n' \-1 ta leave tha value unchanged
(the actual value of 'enc' bein supplied up in a previous call).
.PP
\&\fIEVP_CIPHER_CTX_cleanup()\fR clears all shiznit from a cold-ass lil cipher context
and free up any allocated memory associate wit dat shit. Well shiiiit, it should be called
afta all operations rockin a cold-ass lil cipher is complete so sensitizzle shiznit
does not remain up in memory.
.PP
\&\fIEVP_EncryptInit()\fR, \fIEVP_DecryptInit()\fR n' \fIEVP_CipherInit()\fR behave up in a
similar way ta \fIEVP_EncryptInit_ex()\fR, EVP_DecryptInit_ex and
\&\fIEVP_CipherInit_ex()\fR except tha \fBctx\fR paramta do not need ta be
initialized n' they always use tha default cipher implementation.
.PP
\&\fIEVP_EncryptFinal()\fR, \fIEVP_DecryptFinal()\fR n' \fIEVP_CipherFinal()\fR behave up in a
similar way ta \fIEVP_EncryptFinal_ex()\fR, \fIEVP_DecryptFinal_ex()\fR and
\&\fIEVP_CipherFinal_ex()\fR except \fBctx\fR be automatically cleaned up 
afta tha call.
.PP
\&\fIEVP_get_cipherbyname()\fR, \fIEVP_get_cipherbynid()\fR n' \fIEVP_get_cipherbyobj()\fR
return a \s-1EVP_CIPHER\s0 structure when passed a cold-ass lil cipher name, a \s-1NID\s0 or an
\&\s-1ASN1_OBJECT\s0 structure.
.PP
\&\fIEVP_CIPHER_nid()\fR n' \fIEVP_CIPHER_CTX_nid()\fR return tha \s-1NID\s0 of a cold-ass lil cipher when
passed a \fB\s-1EVP_CIPHER\s0\fR or \fB\s-1EVP_CIPHER_CTX\s0\fR structure.  Da actual \s-1NID\s0
value be a internal value which may not gotz a cold-ass lil correspondin \s-1OBJECT
IDENTIFIER.\s0
.PP
\&\fIEVP_CIPHER_CTX_set_padding()\fR enablez or disablez padding. By default
encryption operations is padded rockin standard block paddin n' the
paddin is checked n' removed when decrypting. If tha \fBpad\fR parameter
is zero then no paddin is performed, tha total amount of data encrypted
or decrypted must then be a multiple of tha block size or a error will
occur.
.PP
\&\fIEVP_CIPHER_key_length()\fR n' \fIEVP_CIPHER_CTX_key_length()\fR return tha key
length of a cold-ass lil cipher when passed a \fB\s-1EVP_CIPHER\s0\fR or \fB\s-1EVP_CIPHER_CTX\s0\fR
structure. Da constant \fB\s-1EVP_MAX_KEY_LENGTH\s0\fR is tha maximum key length
for all ciphers. Note: although \fIEVP_CIPHER_key_length()\fR is fixed fo' a
given cipher, tha value of \fIEVP_CIPHER_CTX_key_length()\fR may be different
for variable key length ciphers.
.PP
\&\fIEVP_CIPHER_CTX_set_key_length()\fR sets tha key length of tha cipher ctx.
If tha cipher be a gangbangin' fixed length cipher then attemptin ta set tha key
length ta any value other than tha fixed value be a error.
.PP
\&\fIEVP_CIPHER_iv_length()\fR n' \fIEVP_CIPHER_CTX_iv_length()\fR return tha \s-1IV\s0
length of a cold-ass lil cipher when passed a \fB\s-1EVP_CIPHER\s0\fR or \fB\s-1EVP_CIPHER_CTX\s0\fR.
It will return zero if tha cipher do not use a \s-1IV. \s0 Da constant
\&\fB\s-1EVP_MAX_IV_LENGTH\s0\fR is tha maximum \s-1IV\s0 length fo' all ciphers.
.PP
\&\fIEVP_CIPHER_block_size()\fR n' \fIEVP_CIPHER_CTX_block_size()\fR return tha block
size of a cold-ass lil cipher when passed a \fB\s-1EVP_CIPHER\s0\fR or \fB\s-1EVP_CIPHER_CTX\s0\fR
structure. Da constant \fB\s-1EVP_MAX_IV_LENGTH\s0\fR be also tha maximum block
length fo' all ciphers.
.PP
\&\fIEVP_CIPHER_type()\fR n' \fIEVP_CIPHER_CTX_type()\fR return tha type of tha passed
cipher or context. This \*(L"type\*(R" is tha actual \s-1NID\s0 of tha cipher \s-1OBJECT
IDENTIFIER\s0 as such it ignores tha cipher parametas n' 40 bit \s-1RC2\s0 and
128 bit \s-1RC2\s0 have tha same \s-1NID.\s0 If tha cipher aint gots a object
identifier or aint gots \s-1ASN1\s0 support dis function will return
\&\fBNID_undef\fR.
.PP
\&\fIEVP_CIPHER_CTX_cipher()\fR returns tha \fB\s-1EVP_CIPHER\s0\fR structure when passed
an \fB\s-1EVP_CIPHER_CTX\s0\fR structure.
.PP
\&\fIEVP_CIPHER_mode()\fR n' \fIEVP_CIPHER_CTX_mode()\fR return tha block cipher mode:
\&\s-1EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE, EVP_CIPH_CFB_MODE\s0 or
\&\s-1EVP_CIPH_OFB_MODE.\s0 If tha cipher be a stream cipher then
\&\s-1EVP_CIPH_STREAM_CIPHER\s0 is returned.
.PP
\&\fIEVP_CIPHER_param_to_asn1()\fR sets tha AlgorithmIdentifier \*(L"parameter\*(R" based
on tha passed cipher n' shit. This will typically include any parametas n' an
\&\s-1IV.\s0 Da cipher \s-1IV \s0(if any) must be set when dis call is made. This call
should be made before tha cipher is straight-up \*(L"used\*(R" (before any
\&\fIEVP_EncryptUpdate()\fR, \fIEVP_DecryptUpdate()\fR calls fo' example). This function
may fail if tha cipher aint gots any \s-1ASN1\s0 support.
.PP
\&\fIEVP_CIPHER_asn1_to_param()\fR sets tha cipher parametas based on a \s-1ASN1\s0
AlgorithmIdentifier \*(L"parameter\*(R". Da precise effect dependz on tha cipher
In tha case of \s-1RC2,\s0 fo' example, it will set tha \s-1IV\s0 n' effectizzle key length.
This function should be called afta tha base cipher type is set but before
the key is set. For example \fIEVP_CipherInit()\fR is ghon be called wit tha \s-1IV\s0 and
key set ta \s-1NULL,\s0 \fIEVP_CIPHER_asn1_to_param()\fR is ghon be called n' finally
\&\fIEVP_CipherInit()\fR again n' again n' again wit all parametas except tha key set ta \s-1NULL.\s0 It is
possible fo' dis function ta fail if tha cipher aint gots any \s-1ASN1\s0 support
or tha parametas cannot be set (for example tha \s-1RC2\s0 effectizzle key length
is not supported.
.PP
\&\fIEVP_CIPHER_CTX_ctrl()\fR allows various cipher specific parametas ta be determined
and set. Currently only tha \s-1RC2\s0 effectizzle key length n' tha number of roundz of
\&\s-1RC5\s0 can be set.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIEVP_EncryptInit_ex()\fR, \fIEVP_EncryptUpdate()\fR n' \fIEVP_EncryptFinal_ex()\fR
return 1 fo' success n' 0 fo' failure.
.PP
\&\fIEVP_DecryptInit_ex()\fR n' \fIEVP_DecryptUpdate()\fR return 1 fo' success n' 0 fo' failure.
\&\fIEVP_DecryptFinal_ex()\fR returns 0 if tha decrypt failed or 1 fo' success.
.PP
\&\fIEVP_CipherInit_ex()\fR n' \fIEVP_CipherUpdate()\fR return 1 fo' success n' 0 fo' failure.
\&\fIEVP_CipherFinal_ex()\fR returns 0 fo' a thugged-out decryption failure or 1 fo' success.
.PP
\&\fIEVP_CIPHER_CTX_cleanup()\fR returns 1 fo' success n' 0 fo' failure.
.PP
\&\fIEVP_get_cipherbyname()\fR, \fIEVP_get_cipherbynid()\fR n' \fIEVP_get_cipherbyobj()\fR
return a \fB\s-1EVP_CIPHER\s0\fR structure or \s-1NULL\s0 on error.
.PP
\&\fIEVP_CIPHER_nid()\fR n' \fIEVP_CIPHER_CTX_nid()\fR return a \s-1NID.\s0
.PP
\&\fIEVP_CIPHER_block_size()\fR n' \fIEVP_CIPHER_CTX_block_size()\fR return tha block
size.
.PP
\&\fIEVP_CIPHER_key_length()\fR n' \fIEVP_CIPHER_CTX_key_length()\fR return tha key
length.
.PP
\&\fIEVP_CIPHER_CTX_set_padding()\fR always returns 1.
.PP
\&\fIEVP_CIPHER_iv_length()\fR n' \fIEVP_CIPHER_CTX_iv_length()\fR return tha \s-1IV\s0
length or zero if tha cipher do not use a \s-1IV.\s0
.PP
\&\fIEVP_CIPHER_type()\fR n' \fIEVP_CIPHER_CTX_type()\fR return tha \s-1NID\s0 of tha cipher's
\&\s-1OBJECT IDENTIFIER\s0 or NID_undef if it has no defined \s-1OBJECT IDENTIFIER.\s0
.PP
\&\fIEVP_CIPHER_CTX_cipher()\fR returns a \fB\s-1EVP_CIPHER\s0\fR structure.
.PP
\&\fIEVP_CIPHER_param_to_asn1()\fR n' \fIEVP_CIPHER_asn1_to_param()\fR return 1 fo' 
success or zero fo' failure.
.SH "CIPHER LISTING"
.IX Header "CIPHER LISTING"
All algorithms gotz a gangbangin' fixed key length unless otherwise stated.
.IP "\fIEVP_enc_null()\fR" 4
.IX Item "EVP_enc_null()"
Null cipher: do nothing.
.IP "EVP_des_cbc(void), EVP_des_ecb(void), EVP_des_cfb(void), EVP_des_ofb(void)" 4
.IX Item "EVP_des_cbc(void), EVP_des_ecb(void), EVP_des_cfb(void), EVP_des_ofb(void)"
\&\s-1DES\s0 up in \s-1CBC, ECB, CFB\s0 n' \s-1OFB\s0 modes respectively.
.IP "EVP_des_ede_cbc(void), \fIEVP_des_ede()\fR, EVP_des_ede_ofb(void),  EVP_des_ede_cfb(void)" 4
.IX Item "EVP_des_ede_cbc(void), EVP_des_ede(), EVP_des_ede_ofb(void), EVP_des_ede_cfb(void)"
Two key triple \s-1DES\s0 up in \s-1CBC, ECB, CFB\s0 n' \s-1OFB\s0 modes respectively.
.IP "EVP_des_ede3_cbc(void), \fIEVP_des_ede3()\fR, EVP_des_ede3_ofb(void),  EVP_des_ede3_cfb(void)" 4
.IX Item "EVP_des_ede3_cbc(void), EVP_des_ede3(), EVP_des_ede3_ofb(void), EVP_des_ede3_cfb(void)"
Three key triple \s-1DES\s0 up in \s-1CBC, ECB, CFB\s0 n' \s-1OFB\s0 modes respectively.
.IP "EVP_desx_cbc(void)" 4
.IX Item "EVP_desx_cbc(void)"
\&\s-1DESX\s0 algorithm up in \s-1CBC\s0 mode.
.IP "EVP_aes_128_cbc(void), \fIEVP_aes_128_ecb()\fR, EVP_aes_128_ofb(void), EVP_aes_128_cfb1(void), EVP_aes_128_cfb8(void), EVP_aes_128_cfb128(void)" 4
.IX Item "EVP_aes_128_cbc(void), EVP_aes_128_ecb(), EVP_aes_128_ofb(void), EVP_aes_128_cfb1(void), EVP_aes_128_cfb8(void), EVP_aes_128_cfb128(void)"
\&\s-1AES\s0 wit 128 bit key length up in \s-1CBC, ECB, OFB\s0 n' \s-1CFB\s0 modes respectively.
.IP "EVP_aes_192_cbc(void), \fIEVP_aes_192_ecb()\fR, EVP_aes_192_ofb(void), EVP_aes_192_cfb1(void), EVP_aes_192_cfb8(void), EVP_aes_192_cfb128(void)" 4
.IX Item "EVP_aes_192_cbc(void), EVP_aes_192_ecb(), EVP_aes_192_ofb(void), EVP_aes_192_cfb1(void), EVP_aes_192_cfb8(void), EVP_aes_192_cfb128(void)"
\&\s-1AES\s0 wit 192 bit key length up in \s-1CBC, ECB, OFB\s0 n' \s-1CFB\s0 modes respectively.
.IP "EVP_aes_256_cbc(void), \fIEVP_aes_256_ecb()\fR, EVP_aes_256_ofb(void), EVP_aes_256_cfb1(void), EVP_aes_256_cfb8(void), EVP_aes_256_cfb128(void)" 4
.IX Item "EVP_aes_256_cbc(void), EVP_aes_256_ecb(), EVP_aes_256_ofb(void), EVP_aes_256_cfb1(void), EVP_aes_256_cfb8(void), EVP_aes_256_cfb128(void)"
\&\s-1AES\s0 wit 256 bit key length up in \s-1CBC, ECB, OFB\s0 n' \s-1CFB\s0 modes respectively.
.IP "EVP_rc4(void)" 4
.IX Item "EVP_rc4(void)"
\&\s-1RC4\s0 stream cipher n' shit. This be a variable key length cipher wit default key length 128 bits.
.IP "EVP_rc4_40(void)" 4
.IX Item "EVP_rc4_40(void)"
\&\s-1RC4\s0 stream cipher wit 40 bit key length. This is obsolete n' freshly smoked up code should use \fIEVP_rc4()\fR
and tha \fIEVP_CIPHER_CTX_set_key_length()\fR function.
.IP "\fIEVP_idea_cbc()\fR EVP_idea_ecb(void), EVP_idea_cfb(void), EVP_idea_ofb(void), EVP_idea_cbc(void)" 4
.IX Item "EVP_idea_cbc() EVP_idea_ecb(void), EVP_idea_cfb(void), EVP_idea_ofb(void), EVP_idea_cbc(void)"
\&\s-1IDEA\s0 encryption algorithm up in \s-1CBC, ECB, CFB\s0 n' \s-1OFB\s0 modes respectively.
.IP "EVP_rc2_cbc(void), EVP_rc2_ecb(void), EVP_rc2_cfb(void), EVP_rc2_ofb(void)" 4
.IX Item "EVP_rc2_cbc(void), EVP_rc2_ecb(void), EVP_rc2_cfb(void), EVP_rc2_ofb(void)"
\&\s-1RC2\s0 encryption algorithm up in \s-1CBC, ECB, CFB\s0 n' \s-1OFB\s0 modes respectively. This be a variable key
length cipher wit a additionizzle parameta called \*(L"effectizzle key bits\*(R" or \*(L"effectizzle key length\*(R".
By default both is set ta 128 bits.
.IP "EVP_rc2_40_cbc(void), EVP_rc2_64_cbc(void)" 4
.IX Item "EVP_rc2_40_cbc(void), EVP_rc2_64_cbc(void)"
\&\s-1RC2\s0 algorithm up in \s-1CBC\s0 mode wit a thugged-out default key length n' effectizzle key length of 40 n' 64 bits.
These is obsolete n' freshly smoked up code should use \fIEVP_rc2_cbc()\fR, \fIEVP_CIPHER_CTX_set_key_length()\fR and
\&\fIEVP_CIPHER_CTX_ctrl()\fR ta set tha key length n' effectizzle key length.
.IP "EVP_bf_cbc(void), EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void);" 4
.IX Item "EVP_bf_cbc(void), EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void);"
Blowfish encryption algorithm up in \s-1CBC, ECB, CFB\s0 n' \s-1OFB\s0 modes respectively. This be a variable key
length cipher.
.IP "EVP_cast5_cbc(void), EVP_cast5_ecb(void), EVP_cast5_cfb(void), EVP_cast5_ofb(void)" 4
.IX Item "EVP_cast5_cbc(void), EVP_cast5_ecb(void), EVP_cast5_cfb(void), EVP_cast5_ofb(void)"
\&\s-1CAST\s0 encryption algorithm up in \s-1CBC, ECB, CFB\s0 n' \s-1OFB\s0 modes respectively. This be a variable key
length cipher.
.IP "EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void), EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)" 4
.IX Item "EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void), EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)"
\&\s-1RC5\s0 encryption algorithm up in \s-1CBC, ECB, CFB\s0 n' \s-1OFB\s0 modes respectively. This be a variable key length
cipher wit a additionizzle \*(L"number of rounds\*(R" parameter n' shit. By default tha key length is set ta 128
bits n' 12 rounds.
.SH "NOTES"
.IX Header "NOTES"
Where possible tha \fB\s-1EVP\s0\fR intercourse ta symmetric ciphers should be used in
preference ta tha low level intercourses. This is cuz tha code then becomes
transparent ta tha cipher used n' much mo' flexible.
.PP
\&\s-1PKCS\s0 paddin works by addin \fBn\fR paddin bytez of value \fBn\fR ta make tha total 
length of tha encrypted data a multiple of tha block size. Paddin be always
added so if tha data be already a multiple of tha block size \fBn\fR will equal
the block size. For example if tha block size is 8 n' 11 bytes is ta be
encrypted then 5 paddin bytez of value 5 is ghon be added.
.PP
When decryptin tha final block is checked ta peep if it has tha erect form.
.PP
Although tha decryption operation can produce a error if paddin is enabled,
it aint a phat test dat tha input data or key is erect fo' realz. A random block
has betta than 1 up in 256 chizzle of bein of tha erect format n' problems with
the input data earlier on aint gonna produce a gangbangin' final decrypt error.
.PP
If paddin is disabled then tha decryption operation will always succeed if
the total amount of data decrypted be a multiple of tha block size.
.PP
Da functions \fIEVP_EncryptInit()\fR, \fIEVP_EncryptFinal()\fR, \fIEVP_DecryptInit()\fR,
\&\fIEVP_CipherInit()\fR n' \fIEVP_CipherFinal()\fR is obsolete but is retained for
compatibilitizzle wit existin code. New code should use \fIEVP_EncryptInit_ex()\fR,
\&\fIEVP_EncryptFinal_ex()\fR, \fIEVP_DecryptInit_ex()\fR, \fIEVP_DecryptFinal_ex()\fR,
\&\fIEVP_CipherInit_ex()\fR n' \fIEVP_CipherFinal_ex()\fR cuz they can reuse an
existin context without allocatin n' freein it up on each call.
.SH "BUGS"
.IX Header "BUGS"
For \s-1RC5\s0 tha number of roundz can currently only be set ta 8, 12 or 16. This is
a limitation of tha current \s-1RC5\s0 code rather than tha \s-1EVP\s0 intercourse.
.PP
\&\s-1EVP_MAX_KEY_LENGTH\s0 n' \s-1EVP_MAX_IV_LENGTH\s0 only refer ta tha internal ciphers with
default key lengths. If custom ciphers exceed these joints tha thangs up in dis biatch are
unpredictable. This is cuz it has become standard practice ta define a 
generic key as a gangbangin' fixed unsigned char array containin \s-1EVP_MAX_KEY_LENGTH\s0 bytes.
.PP
Da \s-1ASN1\s0 code is incomplete (and sometimes inaccurate) it has only been tested
for certain common S/MIME ciphers (\s-1RC2, DES,\s0 triple \s-1DES\s0) up in \s-1CBC\s0 mode.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Git tha number of roundz used up in \s-1RC5:\s0
.PP
.Vb 2
\& int nrounds;
\& EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC5_ROUNDS, 0, &nrounds);
.Ve
.PP
Git tha \s-1RC2\s0 effectizzle key length:
.PP
.Vb 2
\& int key_bits;
\& EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC2_KEY_BITS, 0, &key_bits);
.Ve
.PP
Set tha number of roundz used up in \s-1RC5:\s0
.PP
.Vb 2
\& int nrounds;
\& EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC5_ROUNDS, nrounds, NULL);
.Ve
.PP
Set tha effectizzle key length used up in \s-1RC2:\s0
.PP
.Vb 2
\& int key_bits;
\& EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC2_KEY_BITS, key_bits, NULL);
.Ve
.PP
Encrypt a strang rockin blowfish:
.PP
.Vb 10
\& int do_crypt(char *outfile)
\&        {
\&        unsigned char outbuf[1024];
\&        int outlen, tmplen;
\&        /* Bogus key n' IV: we\*(Aqd normally set these from
\&         * another source.
\&         */
\&        unsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
\&        unsigned char iv[] = {1,2,3,4,5,6,7,8};
\&        char intext[] = "Some Crypto Text";
\&        EVP_CIPHER_CTX ctx;
\&        FILE *out;
\&        EVP_CIPHER_CTX_init(&ctx);
\&        EVP_EncryptInit_ex(&ctx, EVP_bf_cbc(), NULL, key, iv);
\&
\&        if(!EVP_EncryptUpdate(&ctx, outbuf, &outlen, intext, strlen(intext)))
\&                {
\&                /* Error */
\&                return 0;
\&                }
\&        /* Buffer passed ta EVP_EncryptFinal() must be afta data just
\&         * encrypted ta avoid overwritin dat shit.
\&         */
\&        if(!EVP_EncryptFinal_ex(&ctx, outbuf + outlen, &tmplen))
\&                {
\&                /* Error */
\&                return 0;
\&                }
\&        outlen += tmplen;
\&        EVP_CIPHER_CTX_cleanup(&ctx);
\&        /* Need binary mode fo' fopen cuz encrypted data is
\&         * binary data fo' realz. Also cannot use strlen() on it cuz
\&         * it aint gonna be null terminated n' may contain embedded
\&         * nulls.
\&         */
\&        up = fopen(outfile, "wb");
\&        fwrite(outbuf, 1, outlen, out);
\&        fclose(out);
\&        return 1;
\&        }
.Ve
.PP
Da ciphertext from tha above example can be decrypted rockin tha \fBopenssl\fR
utilitizzle wit tha command line:
.PP
.Vb 1
\& S<openssl bf \-in cipher.bin \-K 000102030405060708090A0B0C0D0E0F \-iv 0102030405060708 \-d>
.Ve
.PP
General encryption, decryption function example rockin \s-1FILE I/O\s0 n' \s-1RC2\s0 wit an
80 bit key:
.PP
.Vb 10
\& int do_crypt(FILE *in, FILE *out, int do_encrypt)
\&        {
\&        /* Allow enough space up in output buffer fo' additionizzle block */
\&        inbuf[1024], outbuf[1024 + EVP_MAX_BLOCK_LENGTH];
\&        int inlen, outlen;
\&        /* Bogus key n' IV: we\*(Aqd normally set these from
\&         * another source.
\&         */
\&        unsigned char key[] = "0123456789";
\&        unsigned char iv[] = "12345678";
\&        /* Don\*(Aqt set key or IV cuz we will modify tha parametas */
\&        EVP_CIPHER_CTX_init(&ctx);
\&        EVP_CipherInit_ex(&ctx, EVP_rc2(), NULL, NULL, NULL, do_encrypt);
\&        EVP_CIPHER_CTX_set_key_length(&ctx, 10);
\&        /* We finished modifyin parametas so now we can set key n' IV */
\&        EVP_CipherInit_ex(&ctx, NULL, NULL, key, iv, do_encrypt);
\&
\&        for(;;) 
\&                {
\&                inlen = fread(inbuf, 1, 1024, in);
\&                if(inlen <= 0) break;
\&                if(!EVP_CipherUpdate(&ctx, outbuf, &outlen, inbuf, inlen))
\&                        {
\&                        /* Error */
\&                        EVP_CIPHER_CTX_cleanup(&ctx);
\&                        return 0;
\&                        }
\&                fwrite(outbuf, 1, outlen, out);
\&                }
\&        if(!EVP_CipherFinal_ex(&ctx, outbuf, &outlen))
\&                {
\&                /* Error */
\&                EVP_CIPHER_CTX_cleanup(&ctx);
\&                return 0;
\&                }
\&        fwrite(outbuf, 1, outlen, out);
\&
\&        EVP_CIPHER_CTX_cleanup(&ctx);
\&        return 1;
\&        }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIevp\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIEVP_CIPHER_CTX_init()\fR, \fIEVP_EncryptInit_ex()\fR, \fIEVP_EncryptFinal_ex()\fR,
\&\fIEVP_DecryptInit_ex()\fR, \fIEVP_DecryptFinal_ex()\fR, \fIEVP_CipherInit_ex()\fR,
\&\fIEVP_CipherFinal_ex()\fR n' \fIEVP_CIPHER_CTX_set_padding()\fR rocked up in
OpenSSL 0.9.7.
