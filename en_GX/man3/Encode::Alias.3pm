.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Encode::Alias 3"
.TH Encode::Alias 3 "2013-08-29" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Encode::Alias \- alias definitions ta encodings
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use Encode;
\&  use Encode::Alias;
\&  define_alias( "newName" => ENCODING);
\&  define_alias( qr/.../ => ENCODING);
\&  define_alias( sub { return ENCODING if ...; } );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Allows newName ta be used as a alias fo' \s-1ENCODING. ENCODING\s0 may be
either tha name of a encodin or a encodin object (as busted lyrics bout 
in Encode).
.PP
Currently tha straight-up original gangsta argument ta \fIdefine_alias()\fR can be specified up in the
followin ways:
.IP "As a simple string." 4
.IX Item "As a simple string."
.PD 0
.IP "As a qr// compiled regular expression, e.g.:" 4
.IX Item "As a qr// compiled regular expression, e.g.:"
.PD
.Vb 1
\&  define_alias( qr/^iso8859\-(\ed+)$/i => \*(Aq"iso\-8859\-$1"\*(Aq );
.Ve
.Sp
In dis case, if \fI\s-1ENCODING\s0\fR aint a reference, it is \f(CW\*(C`eval\*(C'\fR\-ed
in order ta allow \f(CW$1\fR etc. ta be substituted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da example is one
way ta alias names as used up in X11 fonts ta tha \s-1MIME\s0 names fo' the
iso\-8859\-* crew.  Note tha double quotes inside tha single quotes.
.Sp
(or, you don't gotta do dis yo ass cuz dis example is predefined)
.Sp
If yo ass is rockin a regex here, you gotta use tha quotes as shown or
it won't work.  Also note dat regex handlin is tricky even fo' the
experienced. Y'all KNOW dat shit, muthafucka!  Use dis feature wit caution.
.IP "As a cold-ass lil code reference, e.g.:" 4
.IX Item "As a cold-ass lil code reference, e.g.:"
.Vb 1
\&  define_alias( sub {shift =~ /^iso8859\-(\ed+)$/i , biatch? "iso\-8859\-$1" : undef } );
.Ve
.Sp
Da same effect as tha example above up in a gangbangin' finger-lickin' different way.  Da coderef
takes tha alias name as a argument n' returns a cold-ass lil canonical name on
success or undef if not.  Note tha second argument is ignored if provided.
Use dis wit even mo' caution than tha regex version.
.PP
\fIChanges up in code reference aliasing\fR
.IX Subsection "Changes up in code reference aliasing"
.PP
Az of Encode 1.87, tha olda form
.PP
.Vb 1
\&  define_alias( sub { return  /^iso8859\-(\ed+)$/i , biatch? "iso\-8859\-$1" : undef } );
.Ve
.PP
no longer works.
.PP
Encode up ta 1.86 internally used \*(L"local \f(CW$_\fR\*(R" ta implement dis older
form.  But consider tha code below;
.PP
.Vb 6
\&  use Encode;
\&  $_ = "eeeee" ;
\&  while (/(e)/g) {
\&    mah $utf = decode(\*(Aqaliased\-encoding\-name\*(Aq, $1);
\&    print "position:",pos,"\en";
\&  }
.Ve
.PP
Prior ta Encode 1.86 dis fails cuz of \*(L"local \f(CW$_\fR\*(R".
.SS "Alias overloading"
.IX Subsection "Alias overloading"
Yo ass can override predefined aliases by simply applyin \fIdefine_alias()\fR.
Da freshly smoked up alias be always evaluated first, n' when necessary,
\&\fIdefine_alias()\fR flushes tha internal cache ta make tha freshly smoked up definition
available.
.PP
.Vb 2
\&  # redirect SHIFT_JIS ta MS/IBM Code Page 932, which be a
\&  # superset of SHIFT_JIS
\&
\&  define_alias( qr/shift.*jis$/i  => \*(Aq"cp932"\*(Aq );
\&  define_alias( qr/sjis$/i        => \*(Aq"cp932"\*(Aq );
.Ve
.PP
If you wanna zap all predefined aliases, you can use
.PP
.Vb 1
\&  Encode::Alias\->undef_aliases;
.Ve
.PP
to do so.  And
.PP
.Vb 1
\&  Encode::Alias\->init_aliases;
.Ve
.PP
gets tha factory settings back.
.PP
Note dat \fIdefine_alias()\fR aint gonna be able ta override tha canonical name
of encodings. Encodings is first looked up by canonical name before
potential aliases is tried.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode, Encode::Supported
