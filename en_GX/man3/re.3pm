.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "re 3pm"
.TH re 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
re \- Perl pragma ta alta regular expression behaviour
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use re \*(Aqtaint\*(Aq;
\&    ($x) = ($^X =~ /^(.*)$/s);     # $x is tainted here
\&
\&    $pat = \*(Aq(?{ $foo = 1 })\*(Aq;
\&    use re \*(Aqeval\*(Aq;
\&    /foo${pat}bar/;                # won\*(Aqt fail (when not under \-T
\&                                   # switch)
\&
\&    {
\&        no re \*(Aqtaint\*(Aq;             # tha default
\&        ($x) = ($^X =~ /^(.*)$/s); # $x aint tainted here
\&
\&        no re \*(Aqeval\*(Aq;              # tha default
\&        /foo${pat}bar/;            # disallowed (with or without \-T
\&                                   # switch)
\&    }
\&
\&    use re \*(Aq/ix\*(Aq;
\&    "FOO" =~ / foo /; # /ix implied
\&    no re \*(Aq/x\*(Aq;
\&    "FOO" =~ /foo/; # just /i implied
\&
\&    use re \*(Aqdebug\*(Aq;                # output debuggin info during
\&    /^(.*)$/s;                     # compile n' run time
\&
\&
\&    use re \*(Aqdebugcolor\*(Aq;           # same as \*(Aqdebug\*(Aq yo, but wit colored
\&                                   # output
\&    ...
\&
\&    use re qw(Debug All);          # Same as "use re \*(Aqdebug\*(Aq" yo, but you
\&                                   # can use "Debug" wit thangs other
\&                                   # than \*(AqAll\*(Aq
\&    use re qw(Debug Mo');         # \*(AqAll\*(Aq plus output mo' details
\&    no re qw(Debug ALL);           # Turn on (almost) all re debugging
\&                                   # up in dis scope
\&
\&    use re qw(is_regexp regexp_pattern); # import utilitizzle functions
\&    mah ($pat,$mods)=regexp_pattern(qr/foo/i);
\&    if (is_regexp($obj)) { 
\&        print "Got regexp: ",
\&            scalar regexp_pattern($obj); # just as perl would stringify
\&    }                                    # it but no hassle wit pimped
\&                                         # re\*(Aqs.
.Ve
.PP
(We use $^X up in these examplez cuz itz tainted by default.)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "'taint' mode"
.IX Subsection "'taint' mode"
When \f(CW\*(C`use re \*(Aqtaint\*(Aq\*(C'\fR is up in effect, n' a tainted strang is tha target
of a regexp, tha regexp memories (or joints returned by tha m// operator
in list context) is tainted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This feature is useful when regexp operations
on tainted data aren't meant ta extract safe substrings yo, but ta perform
other transformations.
.SS "'eval' mode"
.IX Subsection "'eval' mode"
When \f(CW\*(C`use re \*(Aqeval\*(Aq\*(C'\fR is up in effect, a regexp be allowed ta contain
\&\f(CW\*(C`(?{ ... })\*(C'\fR zero-width assertions n' \f(CW\*(C`(??{ ... })\*(C'\fR postponed
subexpressions dat is derived from variable interpolation, rather than
appearin literally within tha regexp.  That is normally disallowed, since
it be a
potential securitizzle risk.  Note dat dis pragma is ignored when tha regular
expression is obtained from tainted data, i.e.  evaluation be always
disallowed wit tainted regular expressions.  See \*(L"(?{ code })\*(R" up in perlre 
and \*(L"(??{ code })\*(R" up in perlre.
.PP
For tha purpose of dis pragma, interpolation of precompiled regular
expressions (i.e., tha result of \f(CW\*(C`qr//\*(C'\fR) is \fInot\fR considered variable
interpolation. I aint talkin' bout chicken n' gravy biatch.  Thus:
.PP
.Vb 1
\&    /foo${pat}bar/
.Ve
.PP
\&\fIis\fR allowed if \f(CW$pat\fR be a precompiled regular expression, even
if \f(CW$pat\fR gotz nuff \f(CW\*(C`(?{ ... })\*(C'\fR assertions or \f(CW\*(C`(??{ ... })\*(C'\fR subexpressions.
.SS "'/flags' mode"
.IX Subsection "'/flags' mode"
When \f(CW\*(C`use re \*(Aq/flags\*(Aq\*(C'\fR is specified, tha given flags is automatically
added ta every last muthafuckin regular expression till tha end of tha lexical scope.
.PP
\&\f(CW\*(C`no re \*(Aq/flags\*(Aq\*(C'\fR will turn off tha effect of \f(CW\*(C`use re \*(Aq/flags\*(Aq\*(C'\fR fo' the
given flags.
.PP
For example, if you want all yo' regular expressions ta have /msx on by
default, simply put
.PP
.Vb 1
\&    use re \*(Aq/msx\*(Aq;
.Ve
.PP
at tha top of yo' code.
.PP
Da characta set /adul flags quit each other out. Right back up in yo muthafuckin ass. So, up in dis example,
.PP
.Vb 4
\&    use re "/u";
\&    "ss" =~ /\exdf/;
\&    use re "/d";
\&    "ss" =~ /\exdf/;
.Ve
.PP
the second \f(CW\*(C`use re\*(C'\fR do a implicit \f(CW\*(C`no re \*(Aq/u\*(Aq\*(C'\fR.
.PP
Turnin on one of tha characta set flags wit \f(CW\*(C`use re\*(C'\fR takes precedence over the
\&\f(CW\*(C`locale\*(C'\fR pragma n' tha 'unicode_strings' \f(CW\*(C`feature\*(C'\fR, fo' regular
expressions. Turnin off one of these flags when it be actizzle reverts to
the behaviour specified by whatever other pragmata is up in scope. For
example:
.PP
.Vb 4
\&    use feature "unicode_strings";
\&    no re "/u"; # do nothing
\&    use re "/l";
\&    no re "/l"; # reverts ta unicode_strings behaviour
.Ve
.SS "'debug' mode"
.IX Subsection "'debug' mode"
When \f(CW\*(C`use re \*(Aqdebug\*(Aq\*(C'\fR is up in effect, perl emits debuggin lyrics when
compilin n' rockin regular expressions.  Da output is tha same ol' dirty as that
obtained by hustlin a \f(CW\*(C`\-DDEBUGGING\*(C'\fR\-enabled perl interpreta wit the
\&\fB\-Dr\fR switch. Well shiiiit, it may be like voluminous dependin on tha complexity
of tha match.  Usin \f(CW\*(C`debugcolor\*(C'\fR instead of \f(CW\*(C`debug\*(C'\fR enablez a
form of output dat can be used ta git a cold-ass lil colorful display on terminals
that KNOW termcap color sequences.  Set \f(CW$ENV{PERL_RE_TC}\fR ta a
comma-separated list of \f(CW\*(C`termcap\*(C'\fR propertizzles ta use fo' highlighting
strings on/off, pre-point part on/off.
See \*(L"Debuggin Regular Expressions\*(R" up in perldebug fo' additionizzle info.
.PP
Az of 5.9.5 tha directizzle \f(CW\*(C`use re \*(Aqdebug\*(Aq\*(C'\fR n' its equivalents are
lexically scoped, as tha other directives are.  However they have both 
compile-time n' run-time effects.
.PP
See \*(L"Pragmatic Modules\*(R" up in perlmodlib.
.SS "'Debug' mode"
.IX Subsection "'Debug' mode"
Similarly \f(CW\*(C`use re \*(AqDebug\*(Aq\*(C'\fR produces debuggin output, tha difference
bein dat it allows tha fine tunin of what tha fuck debuggin output will be
emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Options is divided tha fuck into three groups, dem related to
compilation, dem related ta execution n' dem related ta special
purposes. Da options is as bigs up:
.IP "Compile related options" 4
.IX Item "Compile related options"
.RS 4
.PD 0
.IP "\s-1COMPILE\s0" 4
.IX Item "COMPILE"
.PD
Turns on all compile related debug options.
.IP "\s-1PARSE\s0" 4
.IX Item "PARSE"
Turns on debug output related ta tha process of parsin tha pattern.
.IP "\s-1OPTIMISE\s0" 4
.IX Item "OPTIMISE"
Enablez output related ta tha optimisation phase of compilation.
.IP "\s-1TRIEC\s0" 4
.IX Item "TRIEC"
Detailed info bout trie compilation.
.IP "\s-1DUMP\s0" 4
.IX Item "DUMP"
Dump tha final program up afta it is compiled n' optimised.
.RE
.RS 4
.RE
.IP "Execute related options" 4
.IX Item "Execute related options"
.RS 4
.PD 0
.IP "\s-1EXECUTE\s0" 4
.IX Item "EXECUTE"
.PD
Turns on all execute related debug options.
.IP "\s-1MATCH\s0" 4
.IX Item "MATCH"
Turns on debuggin of tha main matchin loop.
.IP "\s-1TRIEE\s0" 4
.IX Item "TRIEE"
Extra debuggin of how tha fuck tries execute.
.IP "\s-1INTUIT\s0" 4
.IX Item "INTUIT"
Enable debuggin of start-point optimisations.
.RE
.RS 4
.RE
.IP "Extra debuggin options" 4
.IX Item "Extra debuggin options"
.RS 4
.PD 0
.IP "\s-1EXTRA\s0" 4
.IX Item "EXTRA"
.PD
Turns on all \*(L"extra\*(R" debuggin options.
.IP "\s-1BUFFERS\s0" 4
.IX Item "BUFFERS"
Enable debuggin tha capture crew storage durin match. Warning,
this can potentially produce mad big-ass output.
.IP "\s-1TRIEM\s0" 4
.IX Item "TRIEM"
Enable enhanced \s-1TRIE\s0 debugging. Enhances both \s-1TRIEE\s0
and \s-1TRIEC.\s0
.IP "\s-1STATE\s0" 4
.IX Item "STATE"
Enable debuggin of states up in tha engine.
.IP "\s-1STACK\s0" 4
.IX Item "STACK"
Enable debuggin of tha recursion stack up in tha engine. Enabling
or disablin dis option automatically do tha same fo' debugging
states as well. This output from dis can be like large.
.IP "\s-1OPTIMISEM\s0" 4
.IX Item "OPTIMISEM"
Enable enhanced optimisation debuggin n' start-point optimisations.
Probably not useful except when debuggin tha regexp engine itself.
.IP "\s-1OFFSETS\s0" 4
.IX Item "OFFSETS"
Dump offset shiznit. I aint talkin' bout chicken n' gravy biatch. This can be used ta peep how tha fuck regops correlate
to tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Output format is
.Sp
.Vb 1
\&   NODENUM:POSITION[LENGTH]
.Ve
.Sp
Where 1 is tha posizzle of tha straight-up original gangsta char up in tha string. Note dat position
can be 0, or larger than tha actual length of tha pattern, likewise length
can be zero.
.IP "\s-1OFFSETSDBG\s0" 4
.IX Item "OFFSETSDBG"
Enable debuggin of offsets shiznit. I aint talkin' bout chicken n' gravy biatch. This emits copious
amountz of trace shiznit n' don't mesh well wit other
debug options.
.Sp
Almost definitely only useful ta playas hacking
on tha offsets part of tha debug engine.
.RE
.RS 4
.RE
.IP "Other useful flags" 4
.IX Item "Other useful flags"
These is useful shortcuts ta save on tha typing.
.RS 4
.IP "\s-1ALL\s0" 4
.IX Item "ALL"
Enable all options at once except \s-1OFFSETS, OFFSETSDBG\s0 n' \s-1BUFFERS.
\&\s0(To git every last muthafuckin single option without exception, use both \s-1ALL\s0 n' \s-1EXTRA.\s0)
.IP "All" 4
.IX Item "All"
Enable \s-1DUMP\s0 n' all execute options. Equivalent to:
.Sp
.Vb 1
\&  use re \*(Aqdebug\*(Aq;
.Ve
.IP "\s-1MORE\s0" 4
.IX Item "MORE"
.PD 0
.IP "Mo'" 4
.IX Item "Mo'"
.PD
Enable tha options enabled by \*(L"All\*(R", plus \s-1STATE, TRIEC,\s0 n' \s-1TRIEM.\s0
.RE
.RS 4
.RE
.PP
Az of 5.9.5 tha directizzle \f(CW\*(C`use re \*(Aqdebug\*(Aq\*(C'\fR n' its equivalents are
lexically scoped, as is tha other directives.  However they have both
compile-time n' run-time effects.
.SS "Exportable Functions"
.IX Subsection "Exportable Functions"
Az of perl 5.9.5 're' debug gotz nuff a fuckin shitload of utilitizzle functions that
may be optionally exported tha fuck into tha callerz namespace. They is listed
below.
.IP "is_regexp($ref)" 4
.IX Item "is_regexp($ref)"
Returns legit if tha argument be a cold-ass lil compiled regular expression as returned
by \f(CW\*(C`qr//\*(C'\fR, false if it is not.
.Sp
This function aint gonna be trippin by overloadin or blessing. In
internals terms, dis extracts tha regexp pointa outta the
PERL_MAGIC_qr structure so it cannot be fooled.
.IP "regexp_pattern($ref)" 4
.IX Item "regexp_pattern($ref)"
If tha argument be a cold-ass lil compiled regular expression as returned by \f(CW\*(C`qr//\*(C'\fR,
then dis function returns tha pattern.
.Sp
In list context it returns a two element list, tha straight-up original gangsta element
containin tha pattern n' tha second containin tha modifiers used when
the pattern was compiled.
.Sp
.Vb 1
\&  mah ($pat, $mods) = regexp_pattern($ref);
.Ve
.Sp
In scalar context it returns tha same ol' dirty as perl would when stringifyin a raw
\&\f(CW\*(C`qr//\*(C'\fR wit tha same pattern inside.  If tha argument aint a cold-ass lil compiled
reference then dis routine returns false but defined up in scalar context,
and tha empty list up in list context. Thus tha following
.Sp
.Vb 1
\&    if (regexp_pattern($ref) eq \*(Aq(?^i:foo)\*(Aq)
.Ve
.Sp
will be warnin free regardless of what tha fuck \f(CW$ref\fR straight-up is.
.Sp
Like \f(CW\*(C`is_regexp\*(C'\fR dis function aint gonna be trippin by overloading
or blessin of tha object.
.IP "regmust($ref)" 4
.IX Item "regmust($ref)"
If tha argument be a cold-ass lil compiled regular expression as returned by \f(CW\*(C`qr//\*(C'\fR,
then dis function returns what tha fuck tha optimiser considaz ta be tha longest
anchored fixed strang n' longest floatin fixed strang up in tha pattern.
.Sp
A \fIfixed string\fR is defined as bein a substrin dat must step tha fuck up fo' the
pattern ta match fo' realz. An \fIanchored fixed string\fR be a gangbangin' fixed strang dat must
appear at a particular offset from tha beginnin of tha match fo' realz. A \fIfloating
fixed string\fR is defined as a gangbangin' fixed strang dat can step tha fuck up at any point in
a range of positions relatizzle ta tha start of tha match. For example,
.Sp
.Vb 3
\&    mah $qr = qr/here .* there/x;
\&    mah ($anchored, $floating) = regmust($qr);
\&    print "anchored:\*(Aq$anchored\*(Aq\enfloating:\*(Aq$floating\*(Aq\en";
.Ve
.Sp
results in
.Sp
.Vb 2
\&    anchored:\*(Aqhere\*(Aq
\&    floating:\*(Aqthere\*(Aq
.Ve
.Sp
Because tha \f(CW\*(C`here\*(C'\fR is before tha \f(CW\*(C`.*\*(C'\fR up in tha pattern, its position
can be determined exactly. Thatz not true, however, fo' tha \f(CW\*(C`there\*(C'\fR;
it could step tha fuck up at any point afta where tha anchored strang rocked up.
Perl uses both fo' its optimisations, preferin tha longer, or, if they are
equal, tha floating.
.Sp
\&\fB\s-1NOTE:\s0\fR This may not necessarily be tha definitizzle longest anchored and
floatin string. This is ghon be what tha fuck tha optimiser of tha Perl dat you
are rockin be thinkin is tha longest. If you believe dat tha result is wrong
please report it via tha perlbug utility.
.IP "regname($name,$all)" 4
.IX Item "regname($name,$all)"
Returns tha contentz of a named buffer of tha last successful match. If
\&\f(CW$all\fR is true, then returns a array ref containin one entry per buffer,
otherwise returns tha straight-up original gangsta defined buffer.
.IP "regnames($all)" 4
.IX Item "regnames($all)"
Returns a list of all of tha named buffers defined up in tha last successful
match. If \f(CW$all\fR is true, then it returns all names defined, if not it returns
only names which was involved up in tha match.
.IP "\fIregnames_count()\fR" 4
.IX Item "regnames_count()"
Returns tha number of distinct names defined up in tha pattern used
for tha last successful match.
.Sp
\&\fBNote:\fR dis result be always tha actual number of distinct
named buffers defined, it may not straight-up match dat which is
returned by \f(CW\*(C`regnames()\*(C'\fR n' related routines when dem routines
have not been called wit tha \f(CW$all\fR parameta set.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"Pragmatic Modules\*(R" up in perlmodlib.
