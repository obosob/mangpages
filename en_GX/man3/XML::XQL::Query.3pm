.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::XQL::Query 3"
.TH XML::XQL::Query 3 "2001-06-20" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::XQL::Query \- Creates a XQL query evaluata from a XQL expression
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use XML::XQL;
\& use XML::XQL::DOM;
\&
\& $parser = freshly smoked up XML::DOM::Parser;
\& $doc = $parser\->parsefile ("file.xml");
\&
\& # Return all elements wit tagName=\*(Aqtitle\*(Aq under tha root element \*(Aqbook\*(Aq
\& $query = freshly smoked up XML::XQL::Query (Expr => "book/title");
\& @result = $query\->solve ($doc);
\&
\& # Or (to save some typing)
\& @result = XML::XQL::solve ("book/title", $doc);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
To big-ass up \s-1XQL\s0 queries on a \s-1XML::DOM\s0 document (or, up in tha future, on other \s-1XML\s0
storage structures), you first gotta create a XML::XQL::Query object and
pass it a valid \s-1XQL\s0 query expression. I aint talkin' bout chicken n' gravy biatch. Yo ass can then big-ass up queries on one or
more documents by callin tha \fIsolve()\fR method.
.SH "XML::XQL::Query constructor"
.IX Header "XML::XQL::Query constructor"
Usage, e.g:
.PP
.Vb 9
\& $query = freshly smoked up XML::XQL::Query(
\&        Expr => "book/author",
\&        Func => [ myfunc => \e&my_func,          # define 2 functions
\&                  myfunc2 => \e&my_func2 ],
\&        FuncArgCount => [ myfunc2 => [2, \-1] ], # myfunc2 has 2 or mo' args
\&        AllowedOutSideSubquery => [ myfunc => 1 ],
\&        ConstFunc => [ myfunc2 => 1],
\&        CompareOper => [ mycmp => \e&mycmp ],    # define comparison operator
\&        q => "str");                            # use str// as strang delim
.Ve
.IP "Expr => \s-1STRING\s0" 4
.IX Item "Expr => STRING"
Da query expression ta be evaluated.
.IP "NodeQuery => \s-1BOOLEAN\s0" 4
.IX Item "NodeQuery => BOOLEAN"
If set ta 1, tha query be a \fINode Query\fR as opposed ta a 
\&\fIFull Query\fR (which is tha default.) 
A node query be a query dat is only capable of returnin Nodes. 
A full query is capable of returnin Node joints n' non-Node joints, n' you can put dat on yo' toast. 
Non-Node joints include \s-1XML\s0 Primitives, element type names, namespace \s-1URI\s0's, 
concatenated text nodes, n' node type names. Da distinction is significant
because node queries may step tha fuck up as \s-1XSL\s0 match n' select patterns, while full 
queries have use up in other applications.
Da difference between tha two formz of queries is trivial n' exists only as 
constraints on tha syntax of node queries. Put ya muthafuckin choppers up if ya feel dis! 
Node queries may contain nested full queries.
.IP "Func => [ \s-1FUNCNAME\s0 => \s-1FUNCREF, ...\s0]" 4
.IX Item "Func => [ FUNCNAME => FUNCREF, ...]"
Defines one or mo' functions. \s-1FUNCNAME\s0 is tha name as used up in tha query 
expression. I aint talkin' bout chicken n' gravy biatch. \s-1FUNCREF\s0 can be either a gangbangin' function reference like \e&my_func or
an anonymous sub.
See also: defineFunction
.IP "Method => [ \s-1FUNCNAME\s0 => \s-1FUNCREF, ...\s0]" 4
.IX Item "Method => [ FUNCNAME => FUNCREF, ...]"
Defines one or mo' methods. \s-1FUNCNAME\s0 is tha name as used up in tha query 
expression. I aint talkin' bout chicken n' gravy biatch. \s-1FUNCREF\s0 can be either a gangbangin' function reference like \e&my_func or
an anonymous sub.
See also: defineMethod
.IP "FuncArgCount => [ \s-1FUNCNAME\s0 => \s-1ARGCOUNT, ...\s0]" 4
.IX Item "FuncArgCount => [ FUNCNAME => ARGCOUNT, ...]"
Defines tha number of arguments fo' one or mo' functions or methods. 
\&\s-1FUNCNAME\s0 is tha name as used up in tha query expression. I aint talkin' bout chicken n' gravy biatch. 
See also: defineFunction n' defineMethod
.IP "AllowedOutsideSubquery => [ \s-1FUNCNAME\s0 => \s-1BOOLEAN, ...\s0]" 4
.IX Item "AllowedOutsideSubquery => [ FUNCNAME => BOOLEAN, ...]"
Defines whether tha specified function or method be allowed outside
subqueries. Put ya muthafuckin choppers up if ya feel dis! \s-1FUNCNAME\s0 is tha name as used up in tha query expression. I aint talkin' bout chicken n' gravy biatch. 
See also: defineFunction n' defineMethod
.IP "ConstFunc => [ \s-1FUNCNAME\s0 => \s-1BOOLEAN, ...\s0]" 4
.IX Item "ConstFunc => [ FUNCNAME => BOOLEAN, ...]"
Defines whether tha function (not method!) be a \*(L"constant\*(R" function.
\&\s-1FUNCNAME\s0 is tha name as used up in tha query expression. I aint talkin' bout chicken n' gravy biatch. 
See \*(L"Constant Function Invocations\*(R" fo' a thugged-out definizzle of \*(L"constant\*(R"
See also: defineFunction n' defineMethod
.IP "CompareOper => [ \s-1OPERNAME\s0 => \s-1FUNCREF, ...\s0]" 4
.IX Item "CompareOper => [ OPERNAME => FUNCREF, ...]"
Defines tha comparison operator wit tha specified \s-1OPERNAME,\s0 e.g. if
\&\s-1OPERNAME\s0 is \*(L"gotz nuff\*(R", you can use \*(L"$gotz nuff$\*(R" up in tha query.
See also: defineComparisonOperators
.IP "q => \s-1TOKEN\s0" 4
.IX Item "q => TOKEN"
Defines tha q// token. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See also: defineTokenQ
.IP "qq => \s-1TOKEN\s0" 4
.IX Item "qq => TOKEN"
Defines tha qq// token. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See also: defineTokenQQ
.IP "Error => \s-1FUNCREF\s0" 4
.IX Item "Error => FUNCREF"
Defines tha function dat is called when errors occur durin parsin the
query expression. I aint talkin' bout chicken n' gravy biatch. Da default function prints a error message ta \s-1STDERR.\s0
.IP "Debug => \s-1FLAGS\s0" 4
.IX Item "Debug => FLAGS"
Sets tha debug level fo' tha Yapp parser dat parses tha query expression.
Default value is 0 (don't print anything). Da maximum value is 0x17, which
prints a shitload of stuff. Right back up in yo muthafuckin ass. See tha Parse::Yapp manpage fo' tha meanin of the
individual bits.
.IP "Reserved hash keys" 4
.IX Item "Reserved hash keys"
Users may add they own (key, value) pairs ta tha Query constructor.
Beware dat tha key 'Tree' is used internally.
.SH "XML::XQL::Query methods"
.IX Header "XML::XQL::Query methods"
.IP "solve (\s-1INPUT_LIST...\s0)" 4
.IX Item "solve (INPUT_LIST...)"
Note dat solve takes a list of nodes which is assumed ta be up in document order
and must belong ta tha same document. E.g:
.Sp
.Vb 3
\& $query = freshly smoked up XML::XQL::Query (Expr => "doc//book");
\& @result = $query\->solve ($doc);
\& @result2 = $query\->solve ($node1, $node2, $node3);
.Ve
.PP
Da followin functions is also available all up in tha query level, i.e. when called
on a Query object they only affect dis Query n' no others:
.PP
.Vb 2
\& defineFunction, defineMethod, defineComparisonOperators, 
\& defineTokenQ, defineTokenQQ
.Ve
.PP
See Global functions fo' details.
Another way ta define these features fo' a particular Query is by passin the
appropriate joints ta tha XML::XQL::Query constructor.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1XML::XQL\s0 fo' general shiznit bout tha \s-1XML::XQL\s0 module
.PP
XML::XQL::Tutorial which raps bout tha \s-1XQL\s0 syntax
