.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BIO_ctrl 3"
.TH BIO_ctrl 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
BIO_ctrl, BIO_callback_ctrl, BIO_ptr_ctrl, BIO_int_ctrl, BIO_reset,
BIO_seek, BIO_tell, BIO_flush, BIO_eof, BIO_set_close, BIO_get_close,
BIO_pending, BIO_wpending, BIO_ctrl_pending, BIO_ctrl_wpending,
BIO_get_info_callback, BIO_set_info_callback \- BIO control operations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bio.h>
\&
\& long BIO_ctrl(BIO *bp,int cmd,long larg,void *parg);
\& long BIO_callback_ctrl(BIO *b, int cmd, void (*fp)(struct bio_st *, int, const char *, int, long, long));
\& char * BIO_ptr_ctrl(BIO *bp,int cmd,long larg);
\& long BIO_int_ctrl(BIO *bp,int cmd,long larg,int iarg);
\&
\& int BIO_reset(BIO *b);
\& int BIO_seek(BIO *b, int ofs);
\& int BIO_tell(BIO *b);
\& int BIO_flush(BIO *b);
\& int BIO_eof(BIO *b);
\& int BIO_set_close(BIO *b,long flag);
\& int BIO_get_close(BIO *b);
\& int BIO_pending(BIO *b);
\& int BIO_wpending(BIO *b);
\& size_t BIO_ctrl_pending(BIO *b);
\& size_t BIO_ctrl_wpending(BIO *b);
\&
\& int BIO_get_info_callback(BIO *b,bio_info_cb **cbp);
\& int BIO_set_info_callback(BIO *b,bio_info_cb *cb);
\&
\& typedef void bio_info_cb(BIO *b, int oper, const char *ptr, int arg1, long arg2, long arg3);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIBIO_ctrl()\fR, \fIBIO_callback_ctrl()\fR, \fIBIO_ptr_ctrl()\fR n' \fIBIO_int_ctrl()\fR
are \s-1BIO \s0\*(L"control\*(R" operations takin argumentz of various types.
These functions is not normally called directly, various macros
are used instead. Y'all KNOW dat shit, muthafucka! Da standard macros is busted lyrics bout below, macros
specific ta a particular type of \s-1BIO\s0 is busted lyrics bout up in tha specific
BIOs manual page as well as any special featurez of tha standard
calls.
.PP
\&\fIBIO_reset()\fR typically resets a \s-1BIO\s0 ta some initial state, up in tha case
of file related BIOs fo' example it rewindz tha file pointa ta the
start of tha file.
.PP
\&\fIBIO_seek()\fR resets a gangbangin' file related \s-1BIO\s0z (that is file descriptor and
\&\s-1FILE\s0 BIOs) file posizzle pointa ta \fBofs\fR bytes from start of file.
.PP
\&\fIBIO_tell()\fR returns tha current file posizzle of a gangbangin' file related \s-1BIO.\s0
.PP
\&\fIBIO_flush()\fR normally writes up any internally buffered data, up in some
cases it is used ta signal \s-1EOF\s0 n' dat no mo' data is ghon be written.
.PP
\&\fIBIO_eof()\fR returns 1 if tha \s-1BIO\s0 has read \s-1EOF,\s0 tha precise meanin of
\&\*(L"\s-1EOF\*(R"\s0 varies accordin ta tha \s-1BIO\s0 type.
.PP
\&\fIBIO_set_close()\fR sets tha \s-1BIO \s0\fBb\fR close flag ta \fBflag\fR. \fBflag\fR can
take tha value \s-1BIO_CLOSE\s0 or \s-1BIO_NOCLOSE.\s0 Typically \s-1BIO_CLOSE\s0 is used
in a source/sink \s-1BIO\s0 ta indicate dat tha underlyin I/O stream should
be closed when tha \s-1BIO\s0 is freed.
.PP
\&\fIBIO_get_close()\fR returns tha BIOs close flag.
.PP
\&\fIBIO_pending()\fR, \fIBIO_ctrl_pending()\fR, \fIBIO_wpending()\fR n' \fIBIO_ctrl_wpending()\fR
return tha number of pendin charactas up in tha BIOs read n' write buffers.
Not all BIOs support these calls. \fIBIO_ctrl_pending()\fR n' \fIBIO_ctrl_wpending()\fR
return a size_t type n' is functions, \fIBIO_pending()\fR n' \fIBIO_wpending()\fR are
macros which call \fIBIO_ctrl()\fR.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIBIO_reset()\fR normally returns 1 fo' success n' 0 or \-1 fo' failure. File
BIOs is a exception, they return 0 fo' success n' \-1 fo' failure.
.PP
\&\fIBIO_seek()\fR n' \fIBIO_tell()\fR both return tha current file posizzle on success
and \-1 fo' failure, except file BIOs which fo' \fIBIO_seek()\fR always return 0
for success n' \-1 fo' failure.
.PP
\&\fIBIO_flush()\fR returns 1 fo' success n' 0 or \-1 fo' failure.
.PP
\&\fIBIO_eof()\fR returns 1 if \s-1EOF\s0 has been reached 0 otherwise.
.PP
\&\fIBIO_set_close()\fR always returns 1.
.PP
\&\fIBIO_get_close()\fR returns tha close flag value: \s-1BIO_CLOSE\s0 or \s-1BIO_NOCLOSE.\s0
.PP
\&\fIBIO_pending()\fR, \fIBIO_ctrl_pending()\fR, \fIBIO_wpending()\fR n' \fIBIO_ctrl_wpending()\fR
return tha amount of pendin data.
.SH "NOTES"
.IX Header "NOTES"
\&\fIBIO_flush()\fR, cuz it can write data may return 0 or \-1 indicating
that tha call should be retried lata up in a similar manner ta \fIBIO_write()\fR. 
Da \fIBIO_should_retry()\fR call should be used n' appropriate action taken
is tha call fails.
.PP
Da return jointz of \fIBIO_pending()\fR n' \fIBIO_wpending()\fR may not reliably
determine tha amount of pendin data up in all cases. For example up in the
case of a gangbangin' file \s-1BIO\s0 some data may be available up in tha \s-1FILE\s0 structures
internal buffers but it aint possible ta determine dis up in a
portably way. For other typez of \s-1BIO\s0 they may not be supported.
.PP
Filta BIOs if they do not internally handle a particular \fIBIO_ctrl()\fR
operation probably pass tha operation ta tha next \s-1BIO\s0 up in tha chain.
This often means there is no need ta locate tha required \s-1BIO\s0 for
a particular operation, it can be called on a cold-ass lil chain n' it will
be automatically passed ta tha relevant \s-1BIO.\s0 However dis can cause
unexpected thangs up in dis biatch: fo' example no current filta BIOs implement
\&\fIBIO_seek()\fR yo, but dis may still succeed if tha chain endz up in a \s-1FILE\s0
or file descriptor \s-1BIO.\s0
.PP
Source/sink BIOs return a 0 if they do not recognize tha \fIBIO_ctrl()\fR
operation.
.SH "BUGS"
.IX Header "BUGS"
Some of tha return joints is ambiguous n' care should be taken. I aint talkin' bout chicken n' gravy biatch. In
particular a return value of 0 can be returned if a operation is not
supported, if a error occurred, if \s-1EOF\s0 has not been reached n' in
the case of \fIBIO_seek()\fR on a gangbangin' file \s-1BIO\s0 fo' a successful operation.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1TBA\s0
