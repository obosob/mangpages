.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_CTX_set_default_passwd_cb 3"
.TH SSL_CTX_set_default_passwd_cb 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_CTX_set_default_passwd_cb, SSL_CTX_set_default_passwd_cb_userdata \- set passwd callback fo' encrypted PEM file handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb);
\& void SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx, void *u);
\&
\& int pem_passwd_cb(char *buf, int size, int rwflag, void *userdata);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISSL_CTX_set_default_passwd_cb()\fR sets tha default password callback called
when loading/storin a \s-1PEM\s0 certificate wit encryption.
.PP
\&\fISSL_CTX_set_default_passwd_cb_userdata()\fR sets a pointa ta \fBuserdata\fR which
will be provided ta tha password callback on invocation.
.PP
Da \fIpem_passwd_cb()\fR, which must be provided by tha application, handz back the
password ta be used durin decryption. I aint talkin' bout chicken n' gravy biatch. On invocation a pointa ta \fBuserdata\fR
is provided. Y'all KNOW dat shit, muthafucka! Da pem_passwd_cb must write tha password tha fuck into tha provided buffer
\&\fBbuf\fR which iz of size \fBsize\fR. Da actual length of tha password must
be moonwalked back ta tha callin function. I aint talkin' bout chicken n' gravy biatch. \fBrwflag\fR indicates whether the
callback is used fo' reading/decryption (rwflag=0) or writing/encryption
(rwflag=1).
.SH "NOTES"
.IX Header "NOTES"
When loadin or storin private keys, a password might be supplied to
protect tha private key. Da way dis password can be supplied may depend
on tha application. I aint talkin' bout chicken n' gravy biatch. If only one private key is handled, it can be practical
to have \fIpem_passwd_cb()\fR handle tha password dialog interactively. If several
keys gotta be handled, it can be practical ta ask fo' tha password once,
then keep it up in memory n' use it nuff muthafuckin times. In tha last case, the
password could be stored tha fuck into tha \fBuserdata\fR storage n' the
\&\fIpem_passwd_cb()\fR only returns tha password already stored.
.PP
When askin fo' tha password interactively, \fIpem_passwd_cb()\fR can use
\&\fBrwflag\fR ta check, whether a item shall be encrypted (rwflag=1).
In dis case tha password dialog may ask fo' tha same password twice
for comparison up in order ta catch typos, dat would make decryption
impossible.
.PP
Other shit up in \s-1PEM\s0 formattin (certificates) can also be encrypted, it is
however not usual, as certificate shiznit is considered public.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fISSL_CTX_set_default_passwd_cb()\fR n' \fISSL_CTX_set_default_passwd_cb_userdata()\fR
do not provide diagnostic shiznit.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Da followin example returns tha password provided as \fBuserdata\fR ta the
callin function. I aint talkin' bout chicken n' gravy biatch. Da password is considered ta be a '\e0' terminated
string. If tha password do not fit tha fuck into tha buffer, tha password is
truncated.
.PP
.Vb 6
\& int pem_passwd_cb(char *buf, int size, int rwflag, void *password)
\& {
\&  strncpy(buf, (char *)(password), size);
\&  buf[size \- 1] = \*(Aq\e0\*(Aq;
\&  return(strlen(buf));
\& }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIssl\fR\|(3),
\&\fISSL_CTX_use_certificate\fR\|(3)
