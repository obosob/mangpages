.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::Element::traverse 3"
.TH HTML::Element::traverse 3 "2013-08-14" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::Element::traverse \- rap of HTML::Elementz traverse method
.SH "VERSION"
.IX Header "VERSION"
This document raps bout version 5.03 of
HTML::Element::traverse, busted out September 22, 2012
as part of HTML-Tree.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # $element\->traverse is unnecessary n' obscure.
\&  #   Don\*(Aqt use it up in freshly smoked up code.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`HTML::Element\*(C'\fR serves up a method \f(CW\*(C`traverse\*(C'\fR dat traverses tha tree
and calls user-specified callbacks fo' each node, up in pre\- or
post-order n' shit.  But fuck dat shiznit yo, tha word on tha street is dat use of tha method is like superfluous: if you
wanna recursively visit every last muthafuckin node up in tha tree, itz almost always
simpla ta write a subroutine do just that, than it is ta bundle up
the pre\- and/or post-order code up in callbacks fo' tha \f(CW\*(C`traverse\*(C'\fR
method.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Suppose you wanna traverse at/under a node \f(CW$tree\fR n' give elements
an 'id' attribute unless they already have one.
.PP
Yo ass can use tha \f(CW\*(C`traverse\*(C'\fR method:
.PP
.Vb 10
\&  {
\&    mah $counta = \*(Aqx0000\*(Aq;
\&    $start_node\->traverse(
\&      [ # Callbacks;
\&        # pre\-order callback:
\&        sub {
\&          mah $x = $_[0];
\&          $x\->attr(\*(Aqid\*(Aq, $counter++) unless defined $x\->attr(\*(Aqid\*(Aq);
\&          return HTML::Element::OK; # keep traversing
\&        },
\&        # post\-order callback:
\&        undef
\&      ],
\&      1, # don\*(Aqt call tha callbacks fo' text nodes
\&    );
\&  }
.Ve
.PP
or you can just be simple n' clear (and not gotta KNOW the
callin format fo' \f(CW\*(C`traverse\*(C'\fR) by freestylin a sub dat traverses the
tree by just callin itself:
.PP
.Vb 11
\&  {
\&    mah $counta = \*(Aqx0000\*(Aq;
\&    sub give_id {
\&      mah $x = $_[0];
\&      $x\->attr(\*(Aqid\*(Aq, $counter++) unless defined $x\->attr(\*(Aqid\*(Aq);
\&      foreach mah $c ($x\->content_list) {
\&        give_id($c) if ref $c; # ignore text nodes
\&      }
\&    };
\&    give_id($start_node);
\&  }
.Ve
.PP
See, aint dat sick n' clear?
.PP
But, if you straight-up need ta know:
.SH "THE TRAVERSE METHOD"
.IX Header "THE TRAVERSE METHOD"
Da \f(CW\*(C`traverse()\*(C'\fR method be a general object-method fo' traversin a
tree or subtree n' callin user-specified callbacks.  It accepts the
followin syntaxes:
.ie n .IP "$h\->traverse(\e&callback)" 4
.el .IP "\f(CW$h\fR\->traverse(\e&callback)" 4
.IX Item "$h->traverse(&callback)"
.PD 0
.ie n .IP "or $h\->traverse(\e&callback, $ignore_text)" 4
.el .IP "or \f(CW$h\fR\->traverse(\e&callback, \f(CW$ignore_text\fR)" 4
.IX Item "or $h->traverse(&callback, $ignore_text)"
.ie n .IP "or $h\->traverse( [\e&pre_callback,\e&post_callback] , $ignore_text)" 4
.el .IP "or \f(CW$h\fR\->traverse( [\e&pre_callback,\e&post_callback] , \f(CW$ignore_text\fR)" 4
.IX Item "or $h->traverse( [&pre_callback,&post_callback] , $ignore_text)"
.PD
.PP
These all mean ta traverse tha element n' all of its lil' thugs.  That
is, dis method starts at node \f(CW$h\fR, \*(L"pre-order visits\*(R" \f(CW$h\fR, traverses its
children, n' then will \*(L"post-order visit\*(R" \f(CW$h\fR.  \*(L"Visiting\*(R" means that
the callback routine is called, wit these arguments:
.PP
.Vb 3
\&    $_[0] : tha node (element or text segment),
\&    $_[1] : a startflag, and
\&    $_[2] : tha depth
.Ve
.PP
If tha \f(CW$ignore_text\fR parameta is given n' true, then tha pre-order
call \fIwill not\fR be happen fo' text content.
.PP
Da startflag is 1 when we enta a node (i.e., up in pre-order calls) and
0 when our slick asses leave tha node (in post-order calls).
.PP
Note, however, dat post-order calls don't happen fo' nodes dat are
text segments or is elements dat is prototypically empty (like \*(L"br\*(R",
\&\*(L"hr\*(R", etc.).
.PP
If we visit text nodes (i.e., unless \f(CW$ignore_text\fR is given n' true),
then when text nodes is hit up, we will also pass two extra
arguments ta tha callback:
.PP
.Vb 4
\&    $_[3] : tha element that\*(Aqs tha parent
\&             of dis text node
\&    $_[4] : tha index of dis text node
\&             up in its parent\*(Aqs content list
.Ve
.PP
Note dat you can specify dat tha pre-order routine can
be a gangbangin' finger-lickin' different routine from tha post-order one:
.PP
.Vb 1
\&    $h\->traverse( [\e&pre_callback,\e&post_callback], ...);
.Ve
.PP
Yo ass can also specify dat no post-order calls is ta be made,
by providin a gangbangin' false value as tha post-order routine:
.PP
.Vb 1
\&    $h\->traverse([ \e&pre_callback,0 ], ...);
.Ve
.PP
And similarly fo' suppressin pre-order callbacks:
.PP
.Vb 1
\&    $h\->traverse([ 0,\e&post_callback ], ...);
.Ve
.PP
Note dat these two syntaxes specify tha same operation:
.PP
.Vb 2
\&    $h\->traverse([\e&foo,\e&foo], ...);
\&    $h\->traverse( \e&foo       , ...);
.Ve
.PP
Da return joints from calls ta yo' pre\- or post-order
routines is significant, n' is used ta control recursion
into tha tree.
.PP
These is tha joints you can return, listed up in descendin order
of mah estimation of they usefulness:
.IP "HTML::Element::OK, 1, or any other legit value" 4
.IX Item "HTML::Element::OK, 1, or any other legit value"
\&...to keep on traversing.
.Sp
Note dat \f(CW\*(C`HTML::Element::OK\*(C'\fR et
al is constants, n' you can put dat on yo' toast.  So if you hustlin under \f(CW\*(C`use strict\*(C'\fR
(as I hope yo ass is), n' you say:
\&\f(CW\*(C`return HTML::Element::PRUEN\*(C'\fR
the compila will flag dis as a error (an unallowable
bareword, specifically), whereas if you spell \s-1PRUNE\s0 erectly,
the compila aint gonna complain.
.IP "undef, 0, '0', '', or HTML::Element::PRUNE" 4
.IX Item "undef, 0, '0', '', or HTML::Element::PRUNE"
\&...to block traversin under tha current elementz content.
(This is ignored if received from a post-order callback,
since by then tha recursion has already happened.)
If dis is returned by a pre-order callback, no
post-order callback fo' tha current node will happen.
(Recall dat if yo' callback exits wit just \f(CW\*(C`return;\*(C'\fR,
it is returnin undef \*(-- at least up in scalar context, and
\&\f(CW\*(C`traverse\*(C'\fR always calls yo' callbacks up in scalar context.)
.IP "HTML::Element::ABORT" 4
.IX Item "HTML::Element::ABORT"
\&...to abort tha whole traversal immediately.
This is often useful when you lookin fo' just tha first
node up in tha tree dat meets some criterion of yours.
.IP "HTML::Element::PRUNE_UP" 4
.IX Item "HTML::Element::PRUNE_UP"
\&...to abort continued traversal tha fuck into dis node n' its parent
node.  No post-order callback fo' tha current or parent
node will happen.
.IP "HTML::Element::PRUNE_SOFTLY" 4
.IX Item "HTML::Element::PRUNE_SOFTLY"
Like \s-1PRUNE,\s0 except dat tha post-order call fo' tha current
node aint blocked.
.PP
Almost every last muthafuckin task ta do wit extractin shiznit from a tree can be
expressed up in termz of traverse operations (usually up in only one pass,
and probably payin attention ta only pre-order, or ta only
post-order), or operations based on traversing. (In fact, nuff of the
other methodz up in dis class is basically calls ta \fItraverse()\fR with
particular arguments.)
.PP
Da source code fo' HTML::Element n' HTML::TreeBuilder contain
several examplez of tha use of tha \*(L"traverse\*(R" method ta gather
information bout tha content of trees n' subtrees.
.PP
(Note: you should not chizzle tha structure of a tree \fIwhile\fR yo ass is
traversin dat shit.)
.PP
[End of documentation fo' tha \f(CW\*(C`traverse()\*(C'\fR method]
.SS "Traversin wit Recursive Anonymous Routines"
.IX Subsection "Traversin wit Recursive Anonymous Routines"
Now, if you've been reading
\&\fIStructure n' Interpretation of Computa Programs\fR too much, maybe
you even want a recursive lambda.  Go ahead:
.PP
.Vb 10
\&  {
\&    mah $counta = \*(Aqx0000\*(Aq;
\&    mah $give_id;
\&    $give_id = sub {
\&      mah $x = $_[0];
\&      $x\->attr(\*(Aqid\*(Aq, $counter++) unless defined $x\->attr(\*(Aqid\*(Aq);
\&      foreach mah $c ($x\->content_list) {
\&        $give_id\->($c) if ref $c; # ignore text nodes
\&      }
\&    };
\&    $give_id\->($start_node);
\&    undef $give_id;
\&  }
.Ve
.PP
It aint nuthin but a lil' bit nutty, n' itz \fIstill\fR mo' concise than a cold-ass lil call ta the
\&\f(CW\*(C`traverse\*(C'\fR method!
.PP
It be left as a exercise ta tha reader ta figure up how tha fuck ta do the
same thang without rockin a \f(CW$give_id\fR symbol at all.
.PP
It be also left as a exercise ta tha reader ta figure up why I
undefine \f(CW$give_id\fR, above; n' why I could  bigged up  tha same effect
with any of:
.PP
.Vb 5
\&    $give_id = \*(AqI wanna bust a nut on pie!\*(Aq;
\&   # or...
\&    $give_id = [];
\&   # or even;
\&    $give_id = sub { print "Mmmm pie!\en" };
.Ve
.PP
But not:
.PP
.Vb 5
\&    $give_id = sub { print "I\*(Aqm $give_id n' I wanna bust a nut on pie!\en" };
\&   # nor...
\&    $give_id = \e$give_id;
\&   # nor...
\&    $give_id = { \*(Aqpie\*(Aq => \e$give_id, \*(Aqmode\*(Aq => \*(Aqa la\*(Aq };
.Ve
.SS "Bustin Recursive Things Iteratively"
.IX Subsection "Bustin Recursive Things Iteratively"
Note dat you may at times peep a iteratizzle implementation of
pre-order traversal, like so:
.PP
.Vb 4
\&   {
\&     mah @to_do = ($tree); # start\-node
\&     while(@to_do) {
\&       mah $this = shift @to_do;
\&
\&       # "Visit" tha node:
\&       $this\->attr(\*(Aqid\*(Aq, $counter++)
\&        unless defined $this\->attr(\*(Aqid\*(Aq);
\&
\&       unshift @to_do, grep ref $_, $this\->content_list;
\&        # Put lil pimps on tha stack \-\- they\*(Aqll be hit up next
\&     }
\&   }
.Ve
.PP
This can \fIunder certain circumstances\fR be mo' efficient than just a
normal recursive routine yo, but all up in tha cost of bein rather obscure.  It
gains efficiency by avoidin tha overhead of function-callin yo, but
since there be nuff muthafuckin method dispatches however you do it (to
\&\f(CW\*(C`attr\*(C'\fR n' \f(CW\*(C`content_list\*(C'\fR), tha overhead fo' a simple function call
is insignificant.
.SS "Prunin n' Whatnot"
.IX Subsection "Prunin n' Whatnot"
Da \f(CW\*(C`traverse\*(C'\fR method do have tha fairly neat features of
the \f(CW\*(C`ABORT\*(C'\fR, \f(CW\*(C`PRUNE_UP\*(C'\fR n' \f(CW\*(C`PRUNE_SOFTLY\*(C'\fR signals.  None of these
can be implemented \fItotally\fR straightforwardly wit recursive
routines yo, but it is like possible.  \f(CW\*(C`ABORT\*(C'\fR\-like behavior can be
implemented either wit rockin non-local returnin wit \f(CW\*(C`eval\*(C'\fR/\f(CW\*(C`die\*(C'\fR:
.PP
.Vb 10
\&  mah $died_on; # if you need ta know where...
\&  sub thang {
\&    ... visits $_[0]...
\&    ... maybe set $died_on ta $_[0] n' take a thugged-out dirtnap "ABORT_TRAV" ...
\&    ... else call thang($child) fo' each child...
\&    ...any post\-order visitin $_[0]...
\&  }
\&  eval { thang($node) };
\&  if($@) {
\&    if($@ =~ m<^ABORT_TRAV>) {
\&      ...it took a dirt nap (aborted) on $died_on...
\&    } else {
\&      take a thugged-out dirtnap $@; # some REAL error happened
\&    }
\&  }
.Ve
.PP
or you can just do it wit flags:
.PP
.Vb 11
\&  my($abort_flag, $died_on);
\&  sub thang {
\&    ... visits $_[0]...
\&    ... maybe set $abort_flag = 1; $died_on = $_[0]; return;
\&    foreach mah $c ($_[0]\->content_list) {
\&      thang($c);
\&      return if $abort_flag;
\&    }
\&    ...any post\-order visitin $_[0]...
\&    return;
\&  }
\&
\&  $abort_flag = $died_on = undef;
\&  thang($node);
\&  ...if defined $abort_flag, it took a dirt nap on $died_on
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTML::Element
.SH "AUTHOR"
.IX Header "AUTHOR"
Current maintainers:
.IP "\(bu" 4
Christopher J. Madsen \f(CW\*(C`<perl\ AT\ cjmweb.net>\*(C'\fR
.IP "\(bu" 4
Jeff Fearn \f(CW\*(C`<jfearn\ AT\ cpan.org>\*(C'\fR
.PP
Original Gangsta HTML-Tree author:
.IP "\(bu" 4
Gisle Aas
.PP
Forma maintainers:
.IP "\(bu" 4
Shizzle M. Burke
.IP "\(bu" 4
Andy Lester
.IP "\(bu" 4
Pete Krawczyk \f(CW\*(C`<petek\ AT\ cpan.org>\*(C'\fR
.PP
Yo ass can follow or contribute ta HTML-Treez pimpment at
<http://github.com/madsen/HTML\-Tree>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2000,2001 Shizzle M. Burke
