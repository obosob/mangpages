.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LWP::ConnCache 3"
.TH LWP::ConnCache 3 "2012-01-14" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
LWP::ConnCache \- Connection cache manager
.SH "NOTE"
.IX Header "NOTE"
This module is experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Detailz of its intercourse is likely to
change up in tha future.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use LWP::ConnCache;
\& mah $cache = LWP::ConnCache\->new;
\& $cache\->deposit($type, $key, $sock);
\& $sock = $cache\->withdraw($type, $key);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`LWP::ConnCache\*(C'\fR class is tha standard connection cache manager
for LWP::UserAgent.
.PP
Da followin basic methodz is provided:
.ie n .IP "$cache = LWP::ConnCache\->new( %options )" 4
.el .IP "\f(CW$cache\fR = LWP::ConnCache\->new( \f(CW%options\fR )" 4
.IX Item "$cache = LWP::ConnCache->new( %options )"
This method constructs a freshly smoked up \f(CW\*(C`LWP::ConnCache\*(C'\fR object.  Da only
option currently accepted is 'total_capacity'.  If specified it
initialize tha total_capacitizzle option. I aint talkin' bout chicken n' gravy biatch.  It defaults ta tha value 1.
.ie n .IP "$cache\->total_capacity( [$num_connections] )" 4
.el .IP "\f(CW$cache\fR\->total_capacity( [$num_connections] )" 4
.IX Item "$cache->total_capacity( [$num_connections] )"
Get/sets tha number of connection dat is ghon be cached. Y'all KNOW dat shit, muthafucka!  Connections
will start ta be dropped when dis limit is reached. Y'all KNOW dat shit, muthafucka!  If set ta \f(CW0\fR,
then all connections is immediately dropped. Y'all KNOW dat shit, muthafucka!  If set ta \f(CW\*(C`undef\*(C'\fR,
then there is no limit.
.ie n .IP "$cache\->capacity($type, [$num_connections] )" 4
.el .IP "\f(CW$cache\fR\->capacity($type, [$num_connections] )" 4
.IX Item "$cache->capacity($type, [$num_connections] )"
Get/set a limit fo' tha number of connectionz of tha specified type
that can be cached. Y'all KNOW dat shit, muthafucka!  Da \f(CW$type\fR will typically be a gangbangin' finger-lickin' dirty-ass short strang like
\&\*(L"http\*(R" or \*(L"ftp\*(R".
.ie n .IP "$cache\->drop( [$checker, [$reason]] )" 4
.el .IP "\f(CW$cache\fR\->drop( [$checker, [$reason]] )" 4
.IX Item "$cache->drop( [$checker, [$reason]] )"
Drop connections by some criteria.  Da \f(CW$checker\fR argument be a
subroutine dat is called fo' each connection. I aint talkin' bout chicken n' gravy biatch.  If tha routine returns
a \s-1TRUE\s0 value then tha connection is dropped. Y'all KNOW dat shit, muthafucka!  Da routine is called
with ($conn, \f(CW$type\fR, \f(CW$key\fR, \f(CW$deposit_time\fR) as arguments.
.Sp
Shortcuts: If tha \f(CW$checker\fR argument be absent (or \f(CW\*(C`undef\*(C'\fR) all cached
connections is dropped. Y'all KNOW dat shit, muthafucka!  If tha \f(CW$checker\fR be a number then all
connections untouched dat tha given number of secondz or mo' are
dropped. Y'all KNOW dat shit, muthafucka!  If \f(CW$checker\fR be a strang then all connectionz of tha given
type is dropped.
.Sp
Da \f(CW$reason\fR argument is passed on ta tha \fIdropped()\fR method.
.ie n .IP "$cache\->prune" 4
.el .IP "\f(CW$cache\fR\->prune" 4
.IX Item "$cache->prune"
Callin dis method will drop all connections dat is dead as fuckin fried chicken. I aint talkin' bout chicken n' gravy biatch.  This is
tested by callin tha \fIping()\fR method on tha connections.  If tha \fIping()\fR
method exists n' returns a \s-1FALSE\s0 value, then tha connection is
dropped.
.ie n .IP "$cache\->get_types" 4
.el .IP "\f(CW$cache\fR\->get_types" 4
.IX Item "$cache->get_types"
This returns all tha 'type' fieldz used fo' tha currently cached
connections.
.ie n .IP "$cache\->get_connections( [$type] )" 4
.el .IP "\f(CW$cache\fR\->get_connections( [$type] )" 4
.IX Item "$cache->get_connections( [$type] )"
This returns all connection objectz of tha specified type.  If no type
is specified then all connections is returned. Y'all KNOW dat shit, muthafucka!  In scalar context the
number of cached connectionz of tha specified type is returned.
.PP
Da followin methodz is called by low-level protocol modulez to
try ta save away connections n' ta git dem back.
.ie n .IP "$cache\->deposit($type, $key, $conn)" 4
.el .IP "\f(CW$cache\fR\->deposit($type, \f(CW$key\fR, \f(CW$conn\fR)" 4
.IX Item "$cache->deposit($type, $key, $conn)"
This method addz a freshly smoked up connection ta tha cache.  As a result other
already cached connections might be dropped. Y'all KNOW dat shit, muthafucka!  Multiple connections with
the same \f(CW$type\fR/$key might added.
.ie n .IP "$conn = $cache\->withdraw($type, $key)" 4
.el .IP "\f(CW$conn\fR = \f(CW$cache\fR\->withdraw($type, \f(CW$key\fR)" 4
.IX Item "$conn = $cache->withdraw($type, $key)"
This method tries ta fetch back a cold-ass lil connection dat was previously
deposited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If no cached connection wit tha specified \f(CW$type\fR/$key is
found, then \f(CW\*(C`undef\*(C'\fR is returned. Y'all KNOW dat shit, muthafucka!  There aint guarantee dat a
deposited connection can be withdrawn, as tha cache manger is free to
drop connections at any time.
.PP
Da followin methodz is called internally.  Subclasses might want to
override em.
.ie n .IP "$conn\->enforce_limits([$type])" 4
.el .IP "\f(CW$conn\fR\->enforce_limits([$type])" 4
.IX Item "$conn->enforce_limits([$type])"
This method is called wit afta a freshly smoked up connection be added (deposited)
in tha cache or capacitizzle limits is adjusted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da default
implementation drops connections until tha specified capacitizzle limits
are not exceeded.
.ie n .IP "$conn\->dropping($conn_record, $reason)" 4
.el .IP "\f(CW$conn\fR\->dropping($conn_record, \f(CW$reason\fR)" 4
.IX Item "$conn->dropping($conn_record, $reason)"
This method is called when a cold-ass lil connection is dropped. Y'all KNOW dat shit, muthafucka!  Da record
belongin ta tha dropped connection is passed as tha straight-up original gangsta argument
and a strang describin tha reason fo' tha drop is passed as the
second argument.  Da default implementation cook up some fuckin noise if the
\&\f(CW$LWP::ConnCache::DEBUG\fR variable is set n' not a god damn thang more.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
For specialized cache policy it make sense ta subclass
\&\f(CW\*(C`LWP::ConnCache\*(C'\fR n' like override tha \fIdeposit()\fR, \fIenforce_limits()\fR
and \fIdropping()\fR methods.
.PP
Da object itself be a hash.  Keys prefixed wit \f(CW\*(C`cc_\*(C'\fR is reserved
for tha base class.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
LWP::UserAgent
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
