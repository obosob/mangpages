.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Deparse 3pm"
.TH B::Deparse 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Deparse \- Perl compila backend ta produce perl code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBperl\fR \fB\-MO=Deparse\fR[\fB,\-d\fR][\fB,\-f\fR\fI\s-1FILE\s0\fR][\fB,\-p\fR][\fB,\-q\fR][\fB,\-l\fR]
        [\fB,\-s\fR\fI\s-1LETTERS\s0\fR][\fB,\-x\fR\fI\s-1LEVEL\s0\fR] \fIprog.pl\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
B::Deparse be a funky-ass backend module fo' tha Perl compila dat generates
perl source code, based on tha internal compiled structure dat perl
itself creates afta parsin a program.  Da output of B::Deparse won't
be exactly tha same as tha original gangsta source, since perl don't keep
track of comments or whitespace, n' there aint a one-to-one
correspondence between perlz syntactical constructions n' their
compiled form yo, but it will often be close.  When you use tha \fB\-p\fR
option, tha output also includes parentheses even when they is not
required by precedence, which can make it easy as fuck  ta peep if perl is
parsin yo' expressions tha way you intended.
.PP
While B::Deparse goes ta some lengths ta try ta figure up what tha fuck your
original gangsta program was bustin, some partz of tha language can still trip
it up; it still fails even on some partz of Perlz own test suite.  If
you encounta a gangbangin' failure other than da most thugged-out common ones busted lyrics bout in
the \s-1BUGS\s0 section below, you can help contribute ta B::Deparse's
ongoin pimpment by submittin a funky-ass bug report wit a small
example.
.SH "OPTIONS"
.IX Header "OPTIONS"
As wit all compila backend options, these must follow directly after
the '\-MO=Deparse', separated by a cold-ass lil comma but not any white space.
.IP "\fB\-d\fR" 4
.IX Item "-d"
Output data joints (when they step tha fuck up as constants) rockin Data::Dumper.
Without dis option, B::Deparse will use some simple routinez of its
own fo' tha same purpose.  Currently, Data::Dumper is betta fo' some
kindz of data (like fuckin complex structures wit pluggin and
self-reference) while tha built-in routines is betta fo' others
(like fuckin odd floating-point joints).
.IP "\fB\-f\fR\fI\s-1FILE\s0\fR" 4
.IX Item "-fFILE"
Normally, B::Deparse deparses tha main code of a program, n' all tha subs
defined up in tha same file.  To include subs defined in
other files, pass tha \fB\-f\fR option wit tha filename.
Yo ass can pass tha \fB\-f\fR option nuff muthafuckin times, to
include mo' than one secondary file.  (Most of tha time you don't want to
use it at all.)  Yo ass can also use dis option ta include subs which are
defined up in tha scope of a \fB#line\fR directizzle wit two parameters.
.IP "\fB\-l\fR" 4
.IX Item "-l"
Add '#line' declarations ta tha output based on tha line n' file
locationz of tha original gangsta code.
.IP "\fB\-p\fR" 4
.IX Item "-p"
Print extra parentheses.  Without dis option, B::Deparse includes
parentheses up in its output only when they is needed, based on the
structure of yo' program.  With \fB\-p\fR, it uses parentheses (almost)
whenever they would be legal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  This can be useful if yo ass is used to
\&\s-1LISP,\s0 or if you wanna peep how tha fuck perl parses yo' input.  If you say
.Sp
.Vb 3
\&    if ($var & 0x7f == 65) {print "Gimme a A!"}
\&    print ($which , biatch? $a : $b), "\en";
\&    $name = $ENV{USER} or "Bob";
.Ve
.Sp
\&\f(CW\*(C`B::Deparse,\-p\*(C'\fR will print
.Sp
.Vb 5
\&    if (($var & 0)) {
\&        print(\*(AqGimme a A!\*(Aq)
\&    };
\&    (print(($which , biatch? $a : $b)), \*(Aq???\*(Aq);
\&    (($name = $ENV{\*(AqUSER\*(Aq}) or \*(Aq???\*(Aq)
.Ve
.Sp
which probably aint what tha fuck you intended (the \f(CW\*(Aq???\*(Aq\fR be a sign that
perl optimized away a cold-ass lil constant value).
.IP "\fB\-P\fR" 4
.IX Item "-P"
Disable prototype checking.  With dis option, all function calls are
deparsed as if no prototype was defined fo' em.  In other lyrics,
.Sp
.Vb 1
\&    perl \-MO=Deparse,\-P \-e \*(Aqsub foo (\e@) { 1 } foo @x\*(Aq
.Ve
.Sp
will print
.Sp
.Vb 4
\&    sub foo (\e@) {
\&        1;
\&    }
\&    &foo(\e@x);
.Ve
.Sp
makin clear how tha fuck tha parametas is straight-up passed ta \f(CW\*(C`foo\*(C'\fR.
.IP "\fB\-q\fR" 4
.IX Item "-q"
Expand double-quoted strings tha fuck into tha correspondin combinations of
concatenation, uc, ucfirst, lc, lcfirst, quotemeta, n' join. I aint talkin' bout chicken n' gravy biatch.  For
instance, print
.Sp
.Vb 1
\&    print "Yo muthafucka, $world, @ladies, \eu$gentlemen\eE, \eu\eL$me!";
.Ve
.Sp
as
.Sp
.Vb 2
\&    print \*(AqYo muthafucka, \*(Aq . $world . \*(Aq, \*(Aq . join($", @ladies) . \*(Aq, \*(Aq
\&          . ucfirst($gentlemen) . \*(Aq, \*(Aq . ucfirst(lc $me . \*(Aq!\*(Aq);
.Ve
.Sp
Note dat tha expanded form represents tha way perl handlez such
constructions internally \*(-- dis option straight-up turns off tha reverse
translation dat B::Deparse probably do.  On tha other hand, note that
\&\f(CW\*(C`$x = "$y"\*(C'\fR aint tha same as \f(CW\*(C`$x = $y\*(C'\fR: tha forma make tha value
of \f(CW$y\fR tha fuck into a strang before bustin tha assignment.
.IP "\fB\-s\fR\fI\s-1LETTERS\s0\fR" 4
.IX Item "-sLETTERS"
Tweak tha steez of B::Deparsez output.  Da lettas should follow
directly afta tha 's', wit no space or punctuation. I aint talkin' bout chicken n' gravy biatch.  Da following
options is available:
.RS 4
.IP "\fBC\fR" 4
.IX Item "C"
Cuddle \f(CW\*(C`elsif\*(C'\fR, \f(CW\*(C`else\*(C'\fR, n' \f(CW\*(C`continue\*(C'\fR blocks.  For example, print
.Sp
.Vb 5
\&    if (...) {
\&         ...
\&    } else {
\&         ...
\&    }
.Ve
.Sp
instead of
.Sp
.Vb 6
\&    if (...) {
\&         ...
\&    }
\&    else {
\&         ...
\&    }
.Ve
.Sp
Da default aint ta cuddle.
.IP "\fBi\fR\fI\s-1NUMBER\s0\fR" 4
.IX Item "iNUMBER"
Indent lines by multiplez of \fI\s-1NUMBER\s0\fR columns.  Da default is 4 columns.
.IP "\fBT\fR" 4
.IX Item "T"
Use tabs fo' each 8 columnz of indent.  Da default is ta use only spaces.
For instance, if tha steez options is \fB\-si4T\fR, a line thatz indented
3 times is ghon be preceded by one tab n' four spaces; if tha options were
\&\fB\-si8T\fR, tha same line would be preceded by three tabs.
.IP "\fBv\fR\fI\s-1STRING\s0\fR\fB.\fR" 4
.IX Item "vSTRING."
Print \fI\s-1STRING\s0\fR fo' tha value of a cold-ass lil constant dat can't be determined
because dat shiznit was optimized away (mnemonic: dis happens when a cold-ass lil constant
is used up in \fBv\fRoid context).  Da end of tha strang is marked by a period.
Da strang should be a valid perl expression, generally a cold-ass lil constant.
Note dat unless itz a number, it probably need ta be quoted, n' on
a command line quotes need ta be protected from tha shell.  Some
conventionizzle joints include 0, 1, 42, '', 'foo', and
\&'Useless use of constant omitted' (which may need ta be
\&\fB\-sv\*(L"'Useless use of constant omitted'.\*(R"\fR
or suttin' similar dependin on yo' shell).  Da default is '???'.
If you rockin B::Deparse on a module or other file thatz require'd,
you shouldn't bust a value dat evaluates ta false, since tha customary
true constant all up in tha end of a module is ghon be up in void context when the
file is compiled as a main program.
.RE
.RS 4
.RE
.IP "\fB\-x\fR\fI\s-1LEVEL\s0\fR" 4
.IX Item "-xLEVEL"
Expand conventionizzle syntax constructions tha fuck into equivalent ones dat expose
their internal operation. I aint talkin' bout chicken n' gravy biatch.  \fI\s-1LEVEL\s0\fR should be a gangbangin' finger-lickin' digit, wit higher joints
meanin mo' expansion. I aint talkin' bout chicken n' gravy biatch.  As wit \fB\-q\fR, dis straight-up involves turnin off
special cases up in B::Deparsez aiiight operations.
.Sp
If \fI\s-1LEVEL\s0\fR be at least 3, \f(CW\*(C`for\*(C'\fR loops is ghon be translated tha fuck into equivalent
while loops wit continue blocks; fo' instance
.Sp
.Vb 3
\&    fo' ($i = 0; $i < 10; ++$i) {
\&        print $i;
\&    }
.Ve
.Sp
turns into
.Sp
.Vb 6
\&    $i = 0;
\&    while ($i < 10) {
\&        print $i;
\&    } continue {
\&        ++$i
\&    }
.Ve
.Sp
Note dat up in all dem cases dis translation can't be perfectly carried back
into tha source code \*(-- if tha loopz initializer declares a mah variable,
for instance, it won't have tha erect scope outside of tha loop.
.Sp
If \fI\s-1LEVEL\s0\fR be at least 5, \f(CW\*(C`use\*(C'\fR declarations is ghon be translated into
\&\f(CW\*(C`BEGIN\*(C'\fR blocks containin calls ta \f(CW\*(C`require\*(C'\fR n' \f(CW\*(C`import\*(C'\fR; for
instance,
.Sp
.Vb 1
\&    use strict \*(Aqrefs\*(Aq;
.Ve
.Sp
turns into
.Sp
.Vb 6
\&    sub BEGIN {
\&        require strict;
\&        do {
\&            \*(Aqstrict\*(Aq\->import(\*(Aqrefs\*(Aq)
\&        };
\&    }
.Ve
.Sp
If \fI\s-1LEVEL\s0\fR be at least 7, \f(CW\*(C`if\*(C'\fR statements is ghon be translated into
equivalent expressions rockin \f(CW\*(C`&&\*(C'\fR, \f(CW\*(C`?:\*(C'\fR n' \f(CW\*(C`do {}\*(C'\fR; fo' instance
.Sp
.Vb 9
\&    print \*(Aqhi\*(Aq if $nice;
\&    if ($nice) {
\&        print \*(Aqhi\*(Aq;
\&    }
\&    if ($nice) {
\&        print \*(Aqhi\*(Aq;
\&    } else {
\&        print \*(Aqbye\*(Aq;
\&    }
.Ve
.Sp
turns into
.Sp
.Vb 3
\&    $nice n' print \*(Aqhi\*(Aq;
\&    $nice n' do { print \*(Aqhi\*(Aq };
\&    $nice , biatch? do { print \*(Aqhi\*(Aq } : do { print \*(Aqbye\*(Aq };
.Ve
.Sp
Long sequencez of elsifs will turn tha fuck into nested ternary operators, which
B::Deparse don't give a fuck how tha fuck ta indent sickly.
.SH "USING B::Deparse AS A MODULE"
.IX Header "USING B::Deparse AS A MODULE"
.SS "Synopsis"
.IX Subsection "Synopsis"
.Vb 4
\&    use B::Deparse;
\&    $deparse = B::Deparse\->new("\-p", "\-sC");
\&    $body = $deparse\->coderef2text(\e&func);
\&    eval "sub func $body"; # tha inverse operation
.Ve
.SS "Description"
.IX Subsection "Description"
B::Deparse can also be used on a sub-by-sub basis from other perl
programs.
.SS "new"
.IX Subsection "new"
.Vb 1
\&    $deparse = B::Deparse\->new(OPTIONS)
.Ve
.PP
Smoke a object ta store tha state of a thugged-out deparsin operation n' any
options.  Da options is tha same as dem dat can be given on the
command line (see \*(L"\s-1OPTIONS\*(R"\s0); options dat is separated by commas
afta \fB\-MO=Deparse\fR should be given as separate strings.
.SS "ambient_pragmas"
.IX Subsection "ambient_pragmas"
.Vb 1
\&    $deparse\->ambient_pragmas(strict => \*(Aqall\*(Aq, \*(Aq$[\*(Aq => $[);
.Ve
.PP
Da compilation of a subroutine can be affected by all dem compiler
directives, \fBpragmas\fR.  These are:
.IP "\(bu" 4
use strict;
.IP "\(bu" 4
use warnings;
.IP "\(bu" 4
Assignin ta tha special variable $[
.IP "\(bu" 4
use integer;
.IP "\(bu" 4
use bytes;
.IP "\(bu" 4
use utf8;
.IP "\(bu" 4
use re;
.PP
Ordinarily, if you use B::Deparse on a subroutine which has
been compiled up in tha presence of one or mo' of these pragmas,
the output will include statements ta turn on tha appropriate
directives.  So if you then compile tha code returned by coderef2text,
it will behave tha same way as tha subroutine which you deparsed.
.PP
But fuck dat shiznit yo, tha word on tha street is dat you may know dat you intend ta use tha thangs up in dis biatch up in a
particular context, where some pragmas is already up in scope.  In
this case, you use tha \fBambient_pragmas\fR method ta describe the
assumptions you wish ta make.
.PP
Not all of tha options currently have any useful effect.  See
\&\*(L"\s-1BUGS\*(R"\s0 fo' mo' details.
.PP
Da parametas it accepts are:
.IP "strict" 4
.IX Item "strict"
Takes a string, possibly containin nuff muthafuckin joints separated
by whitespace.  Da special joints \*(L"all\*(R" n' \*(L"none\*(R" mean what tha fuck you'd
expect.
.Sp
.Vb 1
\&    $deparse\->ambient_pragmas(strict => \*(Aqsubs refs\*(Aq);
.Ve
.IP "$[" 4
Takes a number, tha value of tha array base $[.
Cannot be non-zero on Perl 5.15.3 or later.
.IP "bytes" 4
.IX Item "bytes"
.PD 0
.IP "utf8" 4
.IX Item "utf8"
.IP "integer" 4
.IX Item "integer"
.PD
If tha value is true, then tha appropriate pragma be assumed to
be up in tha ambient scope, otherwise not.
.IP "re" 4
.IX Item "re"
Takes a string, possibly containin a whitespace-separated list of
values.  Da joints \*(L"all\*(R" n' \*(L"none\*(R" is special. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  It aint nuthin but also permissible
to pass a array reference here.
.Sp
.Vb 1
\&    $deparser\->ambient_pragmas(re => \*(Aqeval\*(Aq);
.Ve
.IP "warnings" 4
.IX Item "warnings"
Takes a string, possibly containin a whitespace-separated list of
values.  Da joints \*(L"all\*(R" n' \*(L"none\*(R" is special, again. I aint talkin' bout chicken n' gravy biatch.  It aint nuthin but also
permissible ta pass a array reference here.
.Sp
.Vb 1
\&    $deparser\->ambient_pragmas(warnings => [qw[void io]]);
.Ve
.Sp
If one of tha joints is tha strang \*(L"\s-1FATAL\*(R",\s0 then all tha warnings
in dat list is ghon be considered fatal, just as wit tha \fBwarnings\fR
pragma itself.  Should you need ta specify dat some warnings are
fatal, n' others is merely enabled, you can pass tha \fBwarnings\fR
parameta twice:
.Sp
.Vb 4
\&    $deparser\->ambient_pragmas(
\&        warnings => \*(Aqall\*(Aq,
\&        warnings => [FATAL => qw/void io/],
\&    );
.Ve
.Sp
See perllexwarn fo' mo' shiznit bout lexical warnings.
.IP "hint_bits" 4
.IX Item "hint_bits"
.PD 0
.IP "warning_bits" 4
.IX Item "warning_bits"
.PD
These two parametas is used ta specify tha ambient pragmas in
the format used by tha special variablez $^H n' ${^WARNING_BITS}.
.Sp
They exist principally so dat you can write code like:
.Sp
.Vb 7
\&    { mah ($hint_bits, $warning_bits);
\&    BEGIN {($hint_bits, $warning_bits) = ($^H, ${^WARNING_BITS})}
\&    $deparser\->ambient_pragmas (
\&        hint_bits    => $hint_bits,
\&        warning_bits => $warning_bits,
\&        \*(Aq$[\*(Aq         => 0 + $[
\&    ); }
.Ve
.Sp
which specifies dat tha ambient pragmas is exactly dem which
are up in scope all up in tha deal wit calling.
.IP "%^H" 4
.IX Item "%^H"
This parameta is used ta specify tha ambient pragmas which are
stored up in tha special hash %^H.
.SS "coderef2text"
.IX Subsection "coderef2text"
.Vb 2
\&    $body = $deparse\->coderef2text(\e&func)
\&    $body = $deparse\->coderef2text(sub ($$) { ... })
.Ve
.PP
Return source code fo' tha body of a subroutine (a block, optionally
preceded by a prototype up in parens), given a reference ta the
sub.  Because a subroutine can have no names, or mo' than one name,
this method don't return a cold-ass lil complete subroutine definizzle \*(-- if you
wanna eval tha result, you should prepend \*(L"sub subname \*(R", or \*(L"sub \*(R"
for a anonymous function constructor. Shiiit, dis aint no joke.  Unless tha sub was defined in
the main:: package, tha code will include a package declaration.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
Da only pragmas ta be straight-up supported are: \f(CW\*(C`use warnings\*(C'\fR,
\&\f(CW\*(C`use strict\*(C'\fR, \f(CW\*(C`use bytes\*(C'\fR, \f(CW\*(C`use integer\*(C'\fR
and \f(CW\*(C`use feature\*(C'\fR.  (\f(CW$[\fR, which
behaves like a pragma, be also supported.)
.Sp
Exceptin dem listed above, we currently unable ta guarantee that
B::Deparse will produce a pragma all up in tha erect point up in tha program.
(Specifically, pragmas all up in tha beginnin of a funky-ass block often step tha fuck up right
before tha start of tha block instead.)
Since tha effectz of pragmas is often lexically scoped, dis can mean
that tha pragma holdz sway over a gangbangin' finger-lickin' different portion of tha program
than up in tha input file.
.IP "\(bu" 4
In fact, tha above be a specific instizzle of a mo' general problem:
we can't guarantee ta produce \s-1BEGIN\s0 blocks or \f(CW\*(C`use\*(C'\fR declarations in
exactly tha right place.  So if you bust a module which affects compilation
(like fuckin by over-ridin keywords, overloadin constants or whatever)
then tha output code might not work as intended.
.Sp
This is da most thugged-out straight-up outstandin problem, n' will require some help
from tha Perl core ta fix.
.IP "\(bu" 4
Some constants don't print erectly either wit or without \fB\-d\fR.
For instance, neither B::Deparse nor Data::Dumper know how tha fuck ta print
dual-valued scalars erectly, as in:
.Sp
.Vb 1
\&    use constant E2BIG => ($!=7); $y = E2BIG; print $y, 0+$y;
\&
\&    use constant H => { "#" => 1 }; H\->{"#"};
.Ve
.IP "\(bu" 4
An input file dat uses source filterin probably won't be deparsed into
runnable code, cuz it will still include tha \fBuse\fR declaration
for tha source filterin module, even though tha code dat is
produced be already ordinary Perl which shouldn't be filtered again.
.IP "\(bu" 4
Optimised away statements is rendered as
\&'???'.  This includes statements that
have a cold-ass lil compile-time side-effect, like fuckin tha obscure
.Sp
.Vb 1
\&    mah $x if 0;
.Ve
.Sp
which is not, consequently, deparsed erectly.
.Sp
.Vb 3
\&    foreach mah $i (@_) { 0 }
\&  =>
\&    foreach mah $i (@_) { \*(Aq???\*(Aq }
.Ve
.IP "\(bu" 4
Lexical (my) variablez declared up in scopes external ta a subroutine
appear up in code2ref output text as package variables.  This be a tricky
problem, as perl has no natizzle facilitizzle fo' referrin ta a lexical variable
defined within a gangbangin' finger-lickin' different scope, although PadWalker be a phat start.
.IP "\(bu" 4
There is probably nuff mo' bugs on non-ASCII platforms (\s-1EBCDIC\s0).
.IP "\(bu" 4
Lexical \f(CW\*(C`my\*(C'\fR subroutines is not deparsed properly all up in tha moment.  They are
emitted as pure declarations, without they body; n' tha declaration may
appear up in tha wack place (before any lexicals tha body closes over, or
before tha \f(CW\*(C`use feature\*(C'\fR declaration dat permits use of dis feature).
.Sp
We expect ta resolve dis before tha lexical-subroutine feature is no longer
considered experimental.
.IP "\(bu" 4
Lexical \f(CW\*(C`state\*(C'\fR subroutines is not deparsed at all all up in tha moment.
.Sp
We expect ta resolve dis before tha lexical-subroutine feature is no longer
considered experimental.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stephen McCamant <smcc@CSUA.Berkeley.EDU>, based on a earlier version
by Malcolm Beattie <mbeattie@sable.ox.ac.uk>, wit contributions from
Gisle Aas, Jizzy Duncan, Albert Dvornik, Robin Houston, Dizzle Mitchell,
Hugo van der Sanden, Gurusamy Sarathy, Nick Ing-Simmons, n' Rafael
Garcia-Suarez.
