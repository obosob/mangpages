.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MD5 3"
.TH MD5 3 "2013-07-02" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Digest::MD5 \- Perl intercourse ta tha MD5 Algorithm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& # Functionizzle style
\& use Digest::MD5 qw(md5 md5_hex md5_base64);
\&
\& $digest = md5($data);
\& $digest = md5_hex($data);
\& $digest = md5_base64($data);
\&
\& # OO style
\& use Digest::MD5;
\&
\& $ctx = Digest::MD5\->new;
\&
\& $ctx\->add($data);
\& $ctx\->addfile($file_handle);
\&
\& $digest = $ctx\->digest;
\& $digest = $ctx\->hexdigest;
\& $digest = $ctx\->b64digest;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`Digest::MD5\*(C'\fR module allows you ta use tha \s-1RSA\s0 Data Security
Inc. \s-1MD5\s0 Message Digest algorithm from within Perl programs.  The
algorithm takes as input a message of arbitrary length n' produces as
output a 128\-bit \*(L"fingerprint\*(R" or \*(L"message digest\*(R" of tha input.
.PP
Note dat tha \s-1MD5\s0 algorithm aint as phat as it used ta be.  It has
since 2005 been easy as fuck  ta generate different lyrics dat produce the
same \s-1MD5\s0 digest.  It still seems hard ta generate lyrics that
produce a given digest yo, but it is probably wise ta move ta stronger
algorithms fo' applications dat depend on tha digest ta uniquely identify
a message.
.PP
Da \f(CW\*(C`Digest::MD5\*(C'\fR module provide a procedural intercourse fo' simple
use, as well as a object oriented intercourse dat can handle lyrics
of arbitrary length n' which can read filez directly.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Da followin functions is provided by tha \f(CW\*(C`Digest::MD5\*(C'\fR module.
None of these functions is exported by default.
.IP "md5($data,...)" 4
.IX Item "md5($data,...)"
This function will concatenate all arguments, calculate tha \s-1MD5\s0 digest
of dis \*(L"message\*(R", n' return it up in binary form.  Da returned string
will be 16 bytes long.
.Sp
Da result of md5(\*(L"a\*(R", \*(L"b\*(R", \*(L"c\*(R") is ghon be exactly tha same as the
result of md5(\*(L"abc\*(R").
.IP "md5_hex($data,...)" 4
.IX Item "md5_hex($data,...)"
Same as \fImd5()\fR yo, but will return tha digest up in hexadecimal form. The
length of tha returned strang is ghon be 32 n' it will only contain
charactas from dis set: '0'..'9' n' 'a'..'f'.
.IP "md5_base64($data,...)" 4
.IX Item "md5_base64($data,...)"
Same as \fImd5()\fR yo, but will return tha digest as a funky-ass base64 encoded string.
Da length of tha returned strang is ghon be 22 n' it will only contain
charactas from dis set: 'A'..'Z', 'a'..'z', '0'..'9', '+' and
\&'/'.
.Sp
Note dat tha base64 encoded strang returned aint padded ta be a
multiple of 4 bytes long.  If you want interoperabilitizzle wit other
base64 encoded md5 digests you might wanna append tha redundant
strin \*(L"==\*(R" ta tha result.
.SH "METHODS"
.IX Header "METHODS"
Da object oriented intercourse ta \f(CW\*(C`Digest::MD5\*(C'\fR is busted lyrics bout up in this
section. I aint talkin' bout chicken n' gravy biatch.  Afta a \f(CW\*(C`Digest::MD5\*(C'\fR object has been pimped, yo big-ass booty is ghon add
data ta it n' finally ask fo' tha digest up in a suitable format.  A
single object can be used ta calculate multiple digests.
.PP
Da followin methodz is provided:
.ie n .IP "$md5 = Digest::MD5\->new" 4
.el .IP "\f(CW$md5\fR = Digest::MD5\->new" 4
.IX Item "$md5 = Digest::MD5->new"
Da constructor returns a freshly smoked up \f(CW\*(C`Digest::MD5\*(C'\fR object which encapsulate
the state of tha \s-1MD5\s0 message-digest algorithm.
.Sp
If called as a instizzle method (i.e. \f(CW$md5\fR\->new) it will just reset the
state tha object ta tha state of a newly pimped object.  No new
object is pimped up in dis case.
.ie n .IP "$md5\->reset" 4
.el .IP "\f(CW$md5\fR\->reset" 4
.IX Item "$md5->reset"
This is just a alias fo' \f(CW$md5\fR\->new.
.ie n .IP "$md5\->clone" 4
.el .IP "\f(CW$md5\fR\->clone" 4
.IX Item "$md5->clone"
This a cold-ass lil copy of tha \f(CW$md5\fR object. Well shiiiit, it is useful when you do not want to
destroy tha digests state yo, but need a intermediate value of the
digest, e.g. when calculatin digests iteratively on a cold-ass lil continuous data
stream.  Example:
.Sp
.Vb 5
\&    mah $md5 = Digest::MD5\->new;
\&    while (<>) {
\&        $md5\->add($_);
\&        print "Line $.: ", $md5\->clone\->hexdigest, "\en";
\&    }
.Ve
.ie n .IP "$md5\->add($data,...)" 4
.el .IP "\f(CW$md5\fR\->add($data,...)" 4
.IX Item "$md5->add($data,...)"
Da \f(CW$data\fR provided as argument is appended ta tha message we
calculate tha digest for. Shiiit, dis aint no joke.  Da return value is tha \f(CW$md5\fR object itself.
.Sp
All these lines gonna git tha same effect on tha state of tha \f(CW$md5\fR
object:
.Sp
.Vb 4
\&    $md5\->add("a"); $md5\->add("b"); $md5\->add("c");
\&    $md5\->add("a")\->add("b")\->add("c");
\&    $md5\->add("a", "b", "c");
\&    $md5\->add("abc");
.Ve
.ie n .IP "$md5\->addfile($io_handle)" 4
.el .IP "\f(CW$md5\fR\->addfile($io_handle)" 4
.IX Item "$md5->addfile($io_handle)"
Da \f(CW$io_handle\fR is ghon be read until \s-1EOF\s0 n' its content appended ta the
message we calculate tha digest for. Shiiit, dis aint no joke.  Da return value is tha \f(CW$md5\fR
object itself.
.Sp
Da \fIaddfile()\fR method will \fIcroak()\fR if it fails readin data fo' some
reason. I aint talkin' bout chicken n' gravy biatch.  If it croaks it is unpredictable what tha fuck tha state of tha \f(CW$md5\fR
object is ghon be in. I aint talkin' bout chicken n' gravy biatch. Da \fIaddfile()\fR method might done been able ta read
the file partially before it failed. Y'all KNOW dat shit, muthafucka!  It be probably wise ta discard
or reset tha \f(CW$md5\fR object if dis occurs.
.Sp
In most cases you wanna make shizzle dat tha \f(CW$io_handle\fR is in
\&\f(CW\*(C`binmode\*(C'\fR before you pass it as argument ta tha \fIaddfile()\fR method.
.ie n .IP "$md5\->add_bits($data, $nbits)" 4
.el .IP "\f(CW$md5\fR\->add_bits($data, \f(CW$nbits\fR)" 4
.IX Item "$md5->add_bits($data, $nbits)"
.PD 0
.ie n .IP "$md5\->add_bits($bitstring)" 4
.el .IP "\f(CW$md5\fR\->add_bits($bitstring)" 4
.IX Item "$md5->add_bits($bitstring)"
.PD
Since tha \s-1MD5\s0 algorithm is byte oriented you might only add bits as
multiplez of 8, so you probably wanna just use \fIadd()\fR instead. Y'all KNOW dat shit, muthafucka!  The
\&\fIadd_bits()\fR method is provided fo' compatibilitizzle wit other digest
implementations.  See Digest fo' description of tha arguments
that \fIadd_bits()\fR take.
.ie n .IP "$md5\->digest" 4
.el .IP "\f(CW$md5\fR\->digest" 4
.IX Item "$md5->digest"
Return tha binary digest fo' tha message.  Da returned strang will be
16 bytes long.
.Sp
Note dat tha \f(CW\*(C`digest\*(C'\fR operation is effectively a thugged-out destructive,
read-once operation. I aint talkin' bout chicken n' gravy biatch. Once it has been performed, tha \f(CW\*(C`Digest::MD5\*(C'\fR
object be automatically \f(CW\*(C`reset\*(C'\fR n' can be used ta calculate another
digest value.  Call \f(CW$md5\fR\->clone\->digest if you wanna calculate the
digest without resettin tha digest state.
.ie n .IP "$md5\->hexdigest" 4
.el .IP "\f(CW$md5\fR\->hexdigest" 4
.IX Item "$md5->hexdigest"
Same as \f(CW$md5\fR\->digest yo, but will return tha digest up in hexadecimal
form. Da length of tha returned strang is ghon be 32 n' it will only
contain charactas from dis set: '0'..'9' n' 'a'..'f'.
.ie n .IP "$md5\->b64digest" 4
.el .IP "\f(CW$md5\fR\->b64digest" 4
.IX Item "$md5->b64digest"
Same as \f(CW$md5\fR\->digest yo, but will return tha digest as a funky-ass base64 encoded
string.  Da length of tha returned strang is ghon be 22 n' it will only
contain charactas from dis set: 'A'..'Z', 'a'..'z', '0'..'9', '+'
and '/'.
.Sp
Da base64 encoded strang returned aint padded ta be a multiple of 4
bytes long.  If you want interoperabilitizzle wit other base64 encoded
md5 digests you might wanna append tha strang \*(L"==\*(R" ta tha result.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Da simplest way ta use dis library is ta import tha \fImd5_hex()\fR
function (or one of its cousins):
.PP
.Vb 2
\&    use Digest::MD5 qw(md5_hex);
\&    print "Digest is ", md5_hex("foobarbaz"), "\en";
.Ve
.PP
Da above example would print up tha message:
.PP
.Vb 1
\&    Digest is 6df23dc03f9b54cc38a0fc1483df6e21
.Ve
.PP
Da same checksum can also be calculated up in \s-1OO\s0 style:
.PP
.Vb 1
\&    use Digest::MD5;
\&    
\&    $md5 = Digest::MD5\->new;
\&    $md5\->add(\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq);
\&    $md5\->add(\*(Aqbaz\*(Aq);
\&    $digest = $md5\->hexdigest;
\&    
\&    print "Digest is $digest\en";
.Ve
.PP
With \s-1OO\s0 style, you can break tha message arbitrarily.  This means dat we
are no longer limited ta have space fo' tha whole message up in memory, i.e.
we can handle lyrics of any size.
.PP
This is useful when calculatin checksum fo' files:
.PP
.Vb 1
\&    use Digest::MD5;
\&
\&    mah $filename = shift || "/etc/passwd";
\&    open (my $fh, \*(Aq<\*(Aq, $filename) or take a thugged-out dirtnap "Can\*(Aqt open \*(Aq$filename\*(Aq: $!";
\&    binmode($fh);
\&
\&    $md5 = Digest::MD5\->new;
\&    while (<$fh>) {
\&        $md5\->add($_);
\&    }
\&    close($fh);
\&    print $md5\->b64digest, " $filename\en";
.Ve
.PP
Or we can use tha addfile method fo' mo' efficient readin of
the file:
.PP
.Vb 1
\&    use Digest::MD5;
\&
\&    mah $filename = shift || "/etc/passwd";
\&    open (my $fh, \*(Aq<\*(Aq, $filename) or take a thugged-out dirtnap "Can\*(Aqt open \*(Aq$filename\*(Aq: $!";
\&    binmode ($fh);
\&
\&    print Digest::MD5\->new\->addfile($fh)\->hexdigest, " $filename\en";
.Ve
.PP
Since tha \s-1MD5\s0 algorithm is only defined fo' stringz of bytes, it can not be
used on strings dat gotz nuff chars wit ordinal number above 255 (Unicode
strings).  Da \s-1MD5\s0 functions n' methodz will croak if you try ta feed them
such input data:
.PP
.Vb 1
\&    use Digest::MD5 qw(md5_hex);
\&
\&    mah $str = "abc\ex{300}";
\&    print md5_hex($str), "\en";  # croaks
\&    # Wide characta up in subroutine entry
.Ve
.PP
What you can do is calculate tha \s-1MD5\s0 checksum of tha \s-1UTF\-8\s0
representation of such strings.  This be  bigged up  by filterin the
strin all up in \fIencode_utf8()\fR function:
.PP
.Vb 2
\&    use Digest::MD5 qw(md5_hex);
\&    use Encode qw(encode_utf8);
\&
\&    mah $str = "abc\ex{300}";
\&    print md5_hex(encode_utf8($str)), "\en";
\&    # 8c2d46911f3f5a326455f0ed7a8ed3b3
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Digest,
Digest::MD2,
Digest::SHA,
Digest::HMAC
.PP
\&\fImd5sum\fR\|(1)
.PP
\&\s-1RFC 1321\s0
.PP
http://en.wikipedia.org/wiki/MD5
.PP
Da paper \*(L"How tha fuck ta Break \s-1MD5\s0 n' Other Hash Functions\*(R" by Xiaoyun Wang
and Hongbo Yu.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.PP
.Vb 3
\& Copyright 1998\-2003 Gisle Aas.
\& Copyright 1995\-1996 Neil Winton.
\& Copyright 1991\-1992 RSA Data Security, Inc.
.Ve
.PP
Da \s-1MD5\s0 algorithm is defined up in \s-1RFC 1321.\s0 This implementation is
derived from tha reference C code up in \s-1RFC 1321\s0 which is covered by
the followin copyright statement:
.IP "\(bu" 4
Copyright (C) 1991\-2, \s-1RSA\s0 Data Security, Inc. Created 1991 fo' realz. All
rights reserved.
.Sp
License ta copy n' use dis software is granted provided dat it
is identified as tha \*(L"\s-1RSA\s0 Data Security, Inc. \s-1MD5\s0 Message-Digest
Algorithm\*(R" up in all material mentionin or referencin dis software
or dis function.
.Sp
License be also granted ta make n' use derivatizzle works provided
that such works is identified as \*(L"derived from tha \s-1RSA\s0 Data
Security, Inc. \s-1MD5\s0 Message-Digest Algorithm\*(R" up in all material
mentionin or referencin tha derived work.
.Sp
\&\s-1RSA\s0 Data Security, Inc. make no representations concernin either
the merchantabilitizzle of dis software or tha suitabilitizzle of this
software fo' any particular purpose. Well shiiiit, it is provided \*(L"as is\*(R"
without express or implied warranty of any kind.
.Sp
These notices must be retained up in any copiez of any part of this
documentation and/or software.
.PP
This copyright do not prohibit distribution of any version of Perl
containin dis extension under tha termz of tha \s-1GNU\s0 or Artistic
licenses.
.SH "AUTHORS"
.IX Header "AUTHORS"
Da original gangsta \f(CW\*(C`MD5\*(C'\fR intercourse was freestyled by Neil Winton
(\f(CW\*(C`N.Winton@axion.bt.co.uk\*(C'\fR).
.PP
Da \f(CW\*(C`Digest::MD5\*(C'\fR module is freestyled by Gisle Aas <gisle@ActiveState.com>.
