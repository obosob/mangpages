.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Box::Locker 3"
.TH Mail::Box::Locker 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Box::Locker \- manage tha lockin of mail folders
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Box::Locker
\&   be a Mail::Reporter
\&
\& Mail::Box::Locker is extended by
\&   Mail::Box::Locker::DotLock
\&   Mail::Box::Locker::FcntlLock
\&   Mail::Box::Locker::Flock
\&   Mail::Box::Locker::Multi
\&   Mail::Box::Locker::Mutt
\&   Mail::Box::Locker::NFS
\&   Mail::Box::Locker::POSIX
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Mail::Box::Locker;
\& mah $locker = freshly smoked up Mail::Box::Locker(folda => $folder);
\&
\& $locker\->lock;
\& $locker\->isLocked;
\& $locker\->hasLock;
\& $locker\->unlock;
\&
\& use Mail::Box;
\& mah $folda = Mail::Box\->new(lock_method => \*(AqDOTLOCK\*(Aq);
\& print $folder\->locker\->type;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Each Mail::Box will create its own \f(CW\*(C`Mail::Box::Locker\*(C'\fR object which
will handle tha lockin fo' dat shit.  Yo ass can access of tha object directly
from tha folder, as shown up in tha examplez below.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Box::Locker\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Box::Locker->new(OPTIONS)"
Smoke a freshly smoked up lock. Yo ass may do dis directly. But fuck dat shiznit yo, tha word on tha street is dat up in most cases the
lock aint gonna be separately instantiated but is ghon be tha second class in
a multiple inheritizzle construction wit a Mail::Box.
.Sp
Generally tha client program specifies tha lockin behavior through
options given ta tha folda class.
.Sp
.Vb 8
\& \-Option \-\-Defined up in     \-\-Default
\&  expires                   1 hour
\&  file                      undef
\&  folda                    <undef>
\&  log      Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  method                    \*(AqDOTLOCK\*(Aq
\&  timeout                   10 seconds
\&  trace    Mail::Reporta   \*(AqWARNINGS\*(Aq
.Ve
.RS 4
.IP "expires => \s-1SECONDS\s0" 2
.IX Item "expires => SECONDS"
How tha fuck long can a lock exist, biatch?  If a gangbangin' finger-lickin' different e\-mail program leaves a stale
lock, then dis lock is ghon be removed automatically afta tha specified
number of seconds.
.IP "file => \s-1FILENAME\s0" 2
.IX Item "file => FILENAME"
Name of tha file ta lock.  By default, tha name of tha folda is taken.
.IP "folda => \s-1FOLDER\s0" 2
.IX Item "folda => FOLDER"
Which \s-1FOLDER\s0 is ta be locked, a Mail::Box object.
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "method => STRING|CLASS|ARRAY" 2
.IX Item "method => STRING|CLASS|ARRAY"
.PD
Which kind of locking, specified as one of tha followin names as \s-1STRING.\s0
Yo ass may also specify a \s-1CLASS\s0 name, or a \s-1ARRAY\s0 of names.  In case of an
\&\s-1ARRAY,\s0 a 'multi' locker is started wit all thee 
full \s-1CLASS\s0 name.
.Sp
Supported lockin names are
.RS 2
.IP "'\s-1DOTLOCK\s0' | 'dotlock'" 4
.IX Item "'DOTLOCK' | 'dotlock'"
Da folda handlez creates a gangbangin' file which signals dat it is up in use.  This
is a lil' bit problematic, cuz not all mail-handlin software smoke on
the name of tha file ta be pimped.
.Sp
On various folda types, tha lockfile differs.  See tha documentation for
each folder, which raps bout tha lockin game as well as special
options ta chizzle tha default behavior.
.IP "'\s-1FLOCK\s0' | 'flock'" 4
.IX Item "'FLOCK' | 'flock'"
For some folda handlezs, lockin is based on a gangbangin' file lockin mechanism
provided by tha operatin system.  But fuck dat shiznit yo, tha word on tha street is dat dis do not work on all
systems, like fuckin network filesystems, n' such. This also don't work on
foldaz based on directories (Mail::Box::Dir n' derived).
.IP "'\s-1FCNTLLOCK\s0' | 'fcntllock'" 4
.IX Item "'FCNTLLOCK' | 'fcntllock'"
\&\s-1POSIX\s0 lockin via File::FcntlLock, which works on mo' platforms.
But fuck dat shiznit yo, tha word on tha street is dat that module requires a C compila ta install.
.IP "'\s-1POSIX\s0' | 'posix'" 4
.IX Item "'POSIX' | 'posix'"
Use tha \s-1POSIX\s0 standard fcntl locking.
.IP "'\s-1MULTI\s0' | 'multi'" 4
.IX Item "'MULTI' | 'multi'"
Use \s-1ALL\s0 available lockin methodz all up in tha same time, ta git a funky-ass bigger
chizzle dat tha folda aint gonna be modified by some other application
which uses a unspecified lockin method. Y'all KNOW dat shit, muthafucka!  When one of tha locking
methodz disallows access, tha lockin fails.
.IP "'\s-1MUTT\s0'| 'mutt'" 4
.IX Item "'MUTT'| 'mutt'"
Use tha external program 'mutt_dotlock' ta lock n' unlock.
.IP "'\s-1NFS\s0' | 'nfs'" 4
.IX Item "'NFS' | 'nfs'"
A kind of \f(CW\*(C`dotlock\*(C'\fR file-lockin mechanizzle yo, but adapted ta work over
\&\s-1NFS. \s0 Extra precaution is needed cuz a \f(CW\*(C`open O_EXCL\*(C'\fR on \s-1NFS\s0 is
not a atomic action.
.IP "'\s-1NONE\s0' | 'none'" 4
.IX Item "'NONE' | 'none'"
Do not use locking.
.RE
.RS 2
.Sp
Da other option is ta produce yo' own \f(CW\*(C`Mail::Box::Locker\*(C'\fR derived class,
which implements tha desired lockin method. Y'all KNOW dat shit, muthafucka! (Please consider offerin it
for inclusion up in tha hood Mail::Box module!) Smoke a instizzle of that
class wit dis parameter:
.Sp
.Vb 2
\& mah $locker = Mail::Box::Locker::MyOwn\->new;
\& $folder\->open(locker => $locker);
.Ve
.RE
.IP "timeout => SECONDS|'\s-1NOTIMEOUT\s0'" 2
.IX Item "timeout => SECONDS|'NOTIMEOUT'"
How tha fuck long ta wait while tryin ta acquire tha lock. Da lock request will
fail when tha specified number of secondz is reached. Y'all KNOW dat shit, muthafucka!  If \f(CW\*(AqNOTIMEOUT\*(Aq\fR is
specified, tha module will wait until tha lock can be taken.
.Sp
Whether it is possible ta limit tha wait time is platform\- and
locking-method-specific.  For instance, tha `dotlock' method on Windows
will always wait until tha lock has been received.
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.RE
.RS 4
.RE
.SS "Da Locker"
.IX Subsection "Da Locker"
.PD 0
.ie n .IP "$obj\->\fBfilename\fR([\s-1FILENAME\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfilename\fR([\s-1FILENAME\s0])" 4
.IX Item "$obj->filename([FILENAME])"
.PD
Returns tha filename which is used ta lock tha folder, optionally after
settin it ta tha specified \s-1FILENAME.\s0
.Sp
example:
.Sp
.Vb 1
\& print $locker\->filename;
.Ve
.ie n .IP "$obj\->\fBfolder\fR([\s-1FOLDER\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfolder\fR([\s-1FOLDER\s0])" 4
.IX Item "$obj->folder([FOLDER])"
Returns tha folda object which is locker.
.ie n .IP "$obj\->\fBname\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBname\fR()" 4
.IX Item "$obj->name()"
Returns tha method used ta lock tha folda n' shit. Right back up in yo muthafuckin ass. See tha new(method) for
details on how tha fuck ta specify tha lock method. Y'all KNOW dat shit, muthafucka!  Da name of tha method is
returned up in upper-case.
.Sp
example:
.Sp
.Vb 1
\& if($locker\->name eq \*(AqFLOCK\*(Aq) ...
.Ve
.SS "Locking"
.IX Subsection "Locking"
.ie n .IP "$obj\->\fBhasLock\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBhasLock\fR()" 4
.IX Item "$obj->hasLock()"
Peep whether tha folda has tha lock.
.Sp
example:
.Sp
.Vb 2
\& if($locker\->hasLock) {...}
\& if($folder\->locker\->hasLock) {...}
.Ve
.ie n .IP "$obj\->\fBisLocked\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisLocked\fR()" 4
.IX Item "$obj->isLocked()"
Test if tha folda is locked by dis or a gangbangin' finger-lickin' different application.
.Sp
example:
.Sp
.Vb 2
\& if($locker\->isLocked) {...}
\& if($folder\->locker\->isLocked) {...}
.Ve
.ie n .IP "$obj\->\fBlock\fR(\s-1FOLDER\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlock\fR(\s-1FOLDER\s0)" 4
.IX Item "$obj->lock(FOLDER)"
Git a lock on a gangbangin' folda n' shit.  This will return false if tha lock fails.
.Sp
example:
.Sp
.Vb 2
\& take a thugged-out dirtnap unless $locker\->lock;
\& if($folder\->locker\->lock) {...}
.Ve
.ie n .IP "$obj\->\fBunlock\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBunlock\fR()" 4
.IX Item "$obj->unlock()"
Undo tha lock on a gangbangin' folder.
.Sp
example:
.Sp
.Vb 2
\& $locker\->unlock;
\& $folder\->locker\->unlock;
.Ve
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Box::Locker\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Box::Locker->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Box::Locker\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Box::Locker->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Box::Locker\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Box::Locker->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
When tha locker is destroyed, fo' instizzle when tha folda is closed
or tha program ends, tha lock is ghon be automatically removed.
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
