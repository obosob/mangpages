.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_COMP_add_compression_method 3"
.TH SSL_COMP_add_compression_method 3 "2015-01-13" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_COMP_add_compression_method \- handle SSL/TLS integrated compression methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& int SSL_COMP_add_compression_method(int id, COMP_METHOD *cm);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISSL_COMP_add_compression_method()\fR addz tha compression method \fBcm\fR with
the identifier \fBid\fR ta tha list of available compression methods. This
list is globally maintained fo' all \s-1SSL\s0 operations within dis application.
It cannot be set fo' specific \s-1SSL_CTX\s0 or \s-1SSL\s0 objects.
.SH "NOTES"
.IX Header "NOTES"
Da \s-1TLS\s0 standard (or SSLv3) allows tha integration of compression methods
into tha communication. I aint talkin' bout chicken n' gravy biatch. Da \s-1TLS RFC\s0 do however not specify compression
methodz or they correspondin identifiers, so there is currently no compatible
way ta integrate compression wit unknown peers. Well shiiiit, it is therefore currently not
recommended ta integrate compression tha fuck into applications fo' realz. Applications for
non-hood use may smoke on certain compression methods. Usin different
compression methodz wit tha same identifier will lead ta connection failure.
.PP
An OpenSSL client bustin lyrics a protocol dat allows compression (SSLv3, TLSv1)
will unconditionally bust tha list of all compression methodz enabled with
\&\fISSL_COMP_add_compression_method()\fR ta tha server durin tha handshake.
Unlike tha mechanizzlez ta set a cold-ass lil cipher list, there is no method available to
restrict tha list of compression method on a per connection basis.
.PP
An OpenSSL server will match tha identifiers listed by a cold-ass lil client against
its own compression methodz n' will unconditionally activate compression
when a matchin identifier is found. Y'all KNOW dat shit, muthafucka! There is no way ta restrict tha list
of compression methodz supported on a per connection basis.
.PP
Da OpenSSL library has tha compression methodz \fB\f(BICOMP_rle()\fB\fR n' (when
especially enabled durin compilation) \fB\f(BICOMP_zlib()\fB\fR available.
.SH "WARNINGS"
.IX Header "WARNINGS"
Once tha identitizzlez of tha compression methodz fo' tha \s-1TLS\s0 protocol have
been standardized, tha compression \s-1API\s0 will most likely be chizzled. Y'all KNOW dat shit, muthafucka! Using
it up in tha current state aint recommended.
.PP
It be also not recommended ta use compression if data transfered contain
untrusted parts dat can be manipulated by a attacker as his schmoooove ass could then
get shiznit bout tha encrypted data. Right back up in yo muthafuckin ass. See tha \s-1CRIME\s0 attack. For
that reason tha default loadin of tha zlib compression method is
disabled n' enabled only if tha environment variable \fB\s-1OPENSSL_DEFAULT_ZLIB\s0\fR
is present durin tha library initialization.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fISSL_COMP_add_compression_method()\fR may return tha followin joints:
.ie n .IP "0" 4
.el .IP "\f(CW0\fR" 4
.IX Item "0"
Da operation succeeded.
.ie n .IP "1" 4
.el .IP "\f(CW1\fR" 4
.IX Item "1"
Da operation failed. Y'all KNOW dat shit, muthafucka! Peep tha error queue ta smoke up tha reason.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIssl\fR\|(3)
