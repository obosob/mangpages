.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message::Head 3"
.TH Mail::Message::Head 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Head \- tha header of one message
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Message::Head
\&   be a Mail::Reporter
\&
\& Mail::Message::Head is extended by
\&   Mail::Box::IMAP4::Head
\&   Mail::Message::Head::Complete
\&   Mail::Message::Head::Delayed
\&   Mail::Message::Head::Subset
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& mah $head = Mail::Message::Head\->new;
\& $head\->add(\*(AqFrom: me@localhost\*(Aq);
\& $head\->add(From => \*(Aqme@localhost\*(Aq);
\& $head\->add(Mail::Message::Field\->new(From => \*(Aqme\*(Aq));
\& mah $subject = $head\->get(\*(Aqsubject\*(Aq);
\& mah @rec = $head\->get(\*(Aqreceived\*(Aq);
\& $head\->delete(\*(AqFrom\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mail::Message::Head\*(C'\fR \s-1MIME\s0 headaz is part of Mail::Message lyrics,
which is grouped up in Mail::Box folders.
.PP
\&\fB\s-1ATTENTION\s0!!!\fR most functionalitizzle bout e\-mail headaz is busted lyrics about
in Mail::Message::Head::Complete, which be a matured header object.
Other kindz of headaz is ghon be translated ta dat type when time comes.
.PP
On dis page, tha general methodz which is available on any header are
busted lyrics about. Y'all KNOW dat shit, muthafucka!  Read bout differences up in tha sub-class specific pages.
.SH "OVERLOADED"
.IX Header "OVERLOADED"
.ie n .IP "overload: \fB""""\fR()" 4
.el .IP "overload: \fB``''\fR()" 4
.IX Item "overload: """"()"
(stringifaction) Da header, when used as string, will format as if
\&\fIMail::Message::Head::Complete::string()\fR was called, so return a
nicely folda full header n' shit.  An exception is made fo' Carp, which will
get a simplified strang ta avoid unreadible lyrics from \f(CW\*(C`croak\*(C'\fR
and \f(CW\*(C`confess\*(C'\fR.
.Sp
example: rockin a header object as string
.Sp
.Vb 2
\& print $head;     # implicit stringification by print
\& $head\->print;    # tha same
\&
\& print "$head";   # explicit stringication
.Ve
.IP "overload: \fBbool\fR()" 4
.IX Item "overload: bool()"
When tha header do not contain any lines (which is illegal, according
to tha RFCs), false is returned. Y'all KNOW dat shit, muthafucka!  In all other cases, a legit value is
produced.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Message::Head\->\fBbuild\fR([PAIR|FIELD]\-LIST)" 4
.IX Item "Mail::Message::Head->build([PAIR|FIELD]-LIST)"
A fast way ta construct a header wit nuff lines.
Da PAIRs is \f(CW\*(C`(name, content)\*(C'\fR pairz of tha header yo, but it be also possible
to pass Mail::Message::Field objects, n' you can put dat on yo' toast.   A
Mail::Message::Head::Complete header is pimped by simply calling
\&\fIMail::Message::Head::Complete::build()\fR, n' then each field
is added. Y'all KNOW dat shit, muthafucka!  Double field names is permitted.
.Sp
example:
.Sp
.Vb 1
\& mah $subject = Mail::Message::Field\->new(Subject => \*(Aqxyz\*(Aq);
\&
\& mah $head = Mail::Message::Head\->build
\&  ( From     => \*(Aqme@example.com\*(Aq
\&  , To       => \*(Aqyou@anywhere.aq\*(Aq
\&  , $subject
\&  , Received => \*(Aqone\*(Aq
\&  , Received => \*(Aqtwo\*(Aq
\&  );
\&
\& print ref $head;
\&  # \-\->  Mail::Message::Head::Complete
.Ve
.IP "Mail::Message::Head\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Message::Head->new(OPTIONS)"
Smoke a freshly smoked up message header object.  Da object will store all the
fieldz of a header n' shit.  When you git shiznit from tha header, it
will be moonwalked back ta you as Mail::Message::Field objects, although
the fieldz may be stored differently internally.
.Sp
If you try ta instantiate a Mail::Message::Head, yo big-ass booty is ghon automatically
be upgraded ta a Mail::Message::Head::Complete \-\-a full head.
.Sp
.Vb 6
\& \-Option    \-\-Defined up in     \-\-Default
\&  field_type                   Mail::Message::Field::Fast
\&  log         Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  message                      undef
\&  modified                     <false>
\&  trace       Mail::Reporta   \*(AqWARNINGS\*(Aq
.Ve
.RS 4
.IP "field_type => \s-1CLASS\s0" 2
.IX Item "field_type => CLASS"
Da type of objects dat all tha fieldz will have.  This must be
an extension of Mail::Message::Field.
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "message => \s-1MESSAGE\s0" 2
.IX Item "message => MESSAGE"
.PD
Da \s-1MESSAGE\s0 where dis header belongs to.  Usually, dis aint known
at creation of tha header yo, but sometimes it is.  If not, call the
\&\fImessage()\fR method lata ta set dat shit.
.IP "modified => \s-1BOOLEAN\s0" 2
.IX Item "modified => BOOLEAN"
.PD 0
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.RE
.RS 4
.RE
.PD
.SS "Da header"
.IX Subsection "Da header"
.ie n .IP "$obj\->\fBisDelayed\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDelayed\fR()" 4
.IX Item "$obj->isDelayed()"
Headaz may only be partially read, up in which case they is called delayed.
This method returns legit if some header shiznit still need ta be
read. Y'all KNOW dat shit, muthafucka! Returns false if all header data has been read.
Will never trigger completion.
.ie n .IP "$obj\->\fBisEmpty\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisEmpty\fR()" 4
.IX Item "$obj->isEmpty()"
Is there any fieldz defined up in tha current header, biatch?  Be warned that
the header aint gonna be loaded fo' this: delayed headaz will return
true up in any case.
.ie n .IP "$obj\->\fBisModified\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisModified\fR()" 4
.IX Item "$obj->isModified()"
Returns whether tha header has been modified afta bein read.
.Sp
example:
.Sp
.Vb 1
\& if($head\->isModified) { ... }
.Ve
.ie n .IP "$obj\->\fBknownNames\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBknownNames\fR()" 4
.IX Item "$obj->knownNames()"
Like \fIMail::Message::Head::Complete::names()\fR yo, but only returns tha known
header fields, which may be less than \f(CW\*(C`names\*(C'\fR fo' header types which are
partial. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  \f(CW\*(C`names()\*(C'\fR will trigger completion, where \f(CW\*(C`knownNames()\*(C'\fR do not.
.ie n .IP "$obj\->\fBmessage\fR([\s-1MESSAGE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmessage\fR([\s-1MESSAGE\s0])" 4
.IX Item "$obj->message([MESSAGE])"
Git (afta setting) tha message where dis header belongs to.
This do not trigger completion.
.ie n .IP "$obj\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.IX Item "$obj->modified([BOOLEAN])"
Sets tha modified flag ta \s-1BOOLEAN. \s0 Without value, tha current settin is
returned yo, but up in dat case you can betta use \fIisModified()\fR.
Changin dis flag aint gonna trigger header completion.
.Sp
example:
.Sp
.Vb 3
\& $head\->modified(1);
\& if($head\->modified) { ... }
\& if($head\->isModified) { ... }
.Ve
.ie n .IP "$obj\->\fBorderedFields\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBorderedFields\fR()" 4
.IX Item "$obj->orderedFields()"
Retuns tha fieldz ordered tha way they was read or added.
.SS "Access ta tha header"
.IX Subsection "Access ta tha header"
.ie n .IP "$obj\->\fBget\fR(\s-1NAME\s0 [,INDEX])" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR(\s-1NAME\s0 [,INDEX])" 4
.IX Item "$obj->get(NAME [,INDEX])"
Git tha data which is related ta tha field wit tha \s-1NAME. \s0 Da case of the
charactas up in \s-1NAME\s0 do not matter.
.Sp
If there is only one data element defined fo' tha \s-1NAME,\s0 or if there be an
\&\s-1INDEX\s0 specified as tha second argument, only tha specified element will be
returned. Y'all KNOW dat shit, muthafucka! If tha field \s-1NAME\s0 matches mo' than one header tha return value
dependz on tha context. In \s-1LIST\s0 context, all joints is ghon be returned in
the order they is read. Y'all KNOW dat shit, muthafucka! In \s-1SCALAR\s0 context, only tha last value will be
returned.
.Sp
example:
.Sp
.Vb 4
\& mah $head = Mail::Message::Head\->new;
\& $head\->add(\*(AqReceived: abc\*(Aq);
\& $head\->add(\*(AqReceived: xyz\*(Aq);
\& $head\->add(\*(AqSubject: greetings\*(Aq);
\&
\& mah @rec_list   = $head\->get(\*(AqReceived\*(Aq);
\& mah $rec_scalar = $head\->get(\*(AqReceived\*(Aq);
\& print ",@rec_list,$rec_scalar,"     # ,abc xyz, xyz,
\& print $head\->get(\*(AqReceived\*(Aq, 0);    # abc
\& mah @sub_list   = $head\->get(\*(AqSubject\*(Aq);
\& mah $sub_scalar = $head\->get(\*(AqSubject\*(Aq);
\& print ",@sub_list,$sub_scalar,"     # ,greetings, greetings,
.Ve
.ie n .IP "$obj\->\fBstudy\fR(\s-1NAME\s0 [,INDEX])" 4
.el .IP "\f(CW$obj\fR\->\fBstudy\fR(\s-1NAME\s0 [,INDEX])" 4
.IX Item "$obj->study(NAME [,INDEX])"
Like \fIget()\fR yo, but puts mo' effort up in understandin tha contentz of the
field. Y'all KNOW dat shit, muthafucka!  \fIMail::Message::Field::study()\fR is ghon be called fo' tha field
with tha specified \s-1FIELDNAME,\s0 which returns Mail::Message::Field::Full
objects, n' you can put dat on yo' toast. In scalar context only tha last field wit dat name is returned.
When a \s-1INDEX\s0 is specified, dat element is returned.
.SS "Bout tha body"
.IX Subsection "Bout tha body"
.ie n .IP "$obj\->\fBguessBodySize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBguessBodySize\fR()" 4
.IX Item "$obj->guessBodySize()"
Try ta estimate tha size of tha body of dis message yo, but without parsing
the header or body.  Da result might be \f(CW\*(C`undef\*(C'\fR or all dem cement of
the real size.  It may even be straight-up far of tha real value, thatz why
this be a guess.
.ie n .IP "$obj\->\fBisMultipart\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisMultipart\fR()" 4
.IX Item "$obj->isMultipart()"
Returns whether tha body of tha related message be a multipart body.
May trigger completion, when tha \f(CW\*(C`Content\-Type\*(C'\fR field aint defined.
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBaddNoRealize\fR(\s-1FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddNoRealize\fR(\s-1FIELD\s0)" 4
.IX Item "$obj->addNoRealize(FIELD)"
Add a gangbangin' field, like \fIMail::Message::Head::Complete::add()\fR do yo, but
avoid tha loadin of a possibly partial header n' shit.  This method do not
test tha validitizzle of tha argument, nor flag tha header as chizzled.
This do not trigger completion.
.ie n .IP "$obj\->\fBaddOrderedFields\fR(\s-1FIELDS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddOrderedFields\fR(\s-1FIELDS\s0)" 4
.IX Item "$obj->addOrderedFields(FIELDS)"
.PD 0
.ie n .IP "$obj\->\fBfileLocation\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfileLocation\fR()" 4
.IX Item "$obj->fileLocation()"
.PD
Returns tha location of tha header up in tha file, as a pair begin n' end yo, but it ain't no stoppin cause I be still poppin'.  The
begin is tha straight-up original gangsta byte of tha header n' shit.  Da end is tha straight-up original gangsta byte after
the header.
.ie n .IP "$obj\->\fBload\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBload\fR()" 4
.IX Item "$obj->load()"
Be shizzle dat tha header is loaded. Y'all KNOW dat shit, muthafucka!  This returns tha loaded header
object.
.ie n .IP "$obj\->\fBmoveLocation\fR(\s-1DISTANCE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBmoveLocation\fR(\s-1DISTANCE\s0)" 4
.IX Item "$obj->moveLocation(DISTANCE)"
Move tha registration of tha header up in tha file.
.ie n .IP "$obj\->\fBread\fR(\s-1PARSER\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR(\s-1PARSER\s0)" 4
.IX Item "$obj->read(PARSER)"
Read tha header shiznit of one message tha fuck into dis header structure.  This
method is called by tha folda object (some Mail::Box sub-class), which
passes tha \s-1PARSER\s0 as a argument.
.ie n .IP "$obj\->\fBsetNoRealize\fR(\s-1FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBsetNoRealize\fR(\s-1FIELD\s0)" 4
.IX Item "$obj->setNoRealize(FIELD)"
Set a gangbangin' field yo, but avoid tha loadin of a possibly partial header as \fIset()\fR
does.  This method do not test tha validitizzle of tha argument, nor flag the
header as chizzled. Y'all KNOW dat shit, muthafucka!  This do not trigger completion.
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Message::Head\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Message::Head->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Message::Head\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Message::Head->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Message::Head\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Message::Head->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Ordered header fields"
.IX Subsection "Ordered header fields"
Many Perl implementations cook up a funky-ass big-ass fuck up by disturbin tha order
of header fields.  For some fieldz (especially tha \fIresent groups\fR,
see Mail::Message::Head::ResentGroup) tha order shall be
maintained.
.PP
MailBox will keep tha order of tha fieldz as they was found up in the
source.  When yo' add a freshly smoked up field, it is ghon be added all up in tha end yo, but it ain't no stoppin cause I be still poppin'.  If
your replace a gangbangin' field wit a freshly smoked up value, it will stay up in tha original
order.
.SS "Head class implementation"
.IX Subsection "Head class implementation"
Da header of a \s-1MIME\s0 message object gotz nuff a set of lines, which are
called \fIfields\fR (by default represented by Mail::Message::Field
objects).  Dependent on tha thang, tha knowledge bout tha fieldz can
be up in one of three thangs, each represented by a sub-class of this
module:
.IP "\(bu" 4
Mail::Message::Head::Complete
.Sp
In dis case, it is shizzle dat all knowledge bout tha header be available.
When you \fIget()\fR shiznit from tha header n' it aint there, it will
never be there.
.IP "\(bu" 4
Mail::Message::Head::Subset
.Sp
There is no certainty whether all header lines is known (probably not).  This
may be caused as result of readin a gangbangin' fast index file, as busted lyrics bout in
Mail::Box::MH::Index.  Da object be automatically transformed
into a Mail::Message::Head::Complete when all header lines must be known.
.IP "\(bu" 4
Mail::Message::Head::Partial
.Sp
A partial header is like a subset header: probably tha header is incomplete.
Da means dat yo ass is not shizzle whether a \fIget()\fR fo' a gangbangin' field fails cuz
the field aint a part of tha message or dat it fails cuz it is not
yet known ta tha program.  Where tha subset header knows where ta git the
other fields, tha partial header do not know dat shit.  It cannot hide its
imperfection.
.IP "\(bu" 4
Mail::Message::Head::Delayed
.Sp
In dis case, there is no single field known. I aint talkin' bout chicken n' gravy biatch.  Access ta dis header will
always trigger tha loadin of tha full header.
.SS "Subsetz of header fields"
.IX Subsection "Subsetz of header fields"
Message headaz can be like large, n' therefore MailBox provides
simplified access ta some subsetz of shiznit. I aint talkin' bout chicken n' gravy biatch.  Yo ass can grab these
setz of fieldz together, create n' delete dem as group.
.PP
On tha moment, tha followin sets is defined:
.IP "\(bu" 4
Mail::Message::Head::ResentGroup
.Sp
A \fIresent group\fR be a set of fieldz which is used ta log one step
in tha transmission of tha message from tha original gangsta sender ta the
destination.
.Sp
Each step addz a set of headaz ta indicate when tha message was received
and how tha fuck dat shiznit was forwarded (without modification).  These fieldz are
best pimped rockin \fIMail::Message::bounce()\fR.
.IP "\(bu" 4
Mail::Message::Head::ListGroup
.Sp
Fieldz which is used ta administa n' log mailin list activity.  Mailing
list software has ta play trics wit tha original gangsta message ta be able to
get tha reply on dat message back ta tha mailin list.  Usually a large
number of lines is added.
.IP "\(bu" 4
Mail::Message::Head::SpamGroup
.Sp
A set of fieldz which gotz nuff header fieldz which is produced by
spam detection software.  Yo ass may wanna remove these fieldz when
you store a message fo' a longer period of time.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
