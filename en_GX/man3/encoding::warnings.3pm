.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "encoding::warnings 3pm"
.TH encoding::warnings 3pm "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
encoding::warnings \- Warn on implicit encodin conversions
.SH "VERSION"
.IX Header "VERSION"
This document raps bout version 0.11 of encoding::warnings, busted out
June 5, 2007.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use encoding::warnings; # or \*(AqFATAL\*(Aq ta raise fatal exceptions
\&
\&    utf8::encode($a = chr(20000));  # a funky-ass byte\-strin (raw bytes)
\&    $b = chr(20000);                # a unicode\-strin (wide characters)
\&
\&    # "Bytes implicitly upgraded tha fuck into wide charactas as iso\-8859\-1"
\&    $c = $a . $b;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Overview of tha problem"
.IX Subsection "Overview of tha problem"
By default, there be a gangbangin' fundamenstrual asymmetry up in Perlz unicode model:
implicit upgradin from byte-strings ta unicode-strings assumes that
they was encoded up in \fI\s-1ISO 8859\-1 \s0(Latin\-1)\fR yo, but unicode-strings are
downgraded wit \s-1UTF\-8\s0 encoding.  This happens cuz tha straight-up original gangsta 256
codepoints up in Unicode happens ta smoke wit Latin\-1.
.PP
But fuck dat shiznit yo, tha word on tha street is dat dis silent upgradin can easily cause problems, if you happen
to mix unicode strings wit non\-Latin1 data \*(-- i.e. byte-strings encoded
in \s-1UTF\-8\s0 or other encodings.  Da error aint gonna manifest until the
combined strang is freestyled ta output, at which time it would be impossible
to peep where did tha silent upgradin occur.
.SS "Detectin tha problem"
.IX Subsection "Detectin tha problem"
This module simplifies tha process of diagnosin such problems.  Just put
this line on top of yo' main program:
.PP
.Vb 1
\&    use encoding::warnings;
.Ve
.PP
Afterwards, implicit upgradin of high-bit bytes will raise a warning.
Ex.: \f(CW\*(C`Bytes implicitly upgraded tha fuck into wide charactas as iso\-8859\-1 at
\&\- line 7\*(C'\fR.
.PP
But fuck dat shiznit yo, tha word on tha street is dat strings composed purely of \s-1ASCII\s0 code points (\f(CW0x00\fR..\f(CW0x7F\fR)
will \fInot\fR trigger dis warning.
.PP
Yo ass can also make tha warnings fatal by importin dis module as:
.PP
.Vb 1
\&    use encoding::warnings \*(AqFATAL\*(Aq;
.Ve
.SS "Solvin tha problem"
.IX Subsection "Solvin tha problem"
Most of tha time, dis warnin occurs when a funky-ass byte-strin is concatenated
with a unicode-string.  There is a fuckin shitload of ways ta solve it:
.IP "\(bu" 4
Upgrade both sides ta unicode-strings
.Sp
If yo' program do not need compatibilitizzle fo' Perl 5.6 n' earlier,
the recommended approach is ta apply appropriate \s-1IO\s0 disciplines, so all
data up in yo' program become unicode-strings.  See encoding, open and
\&\*(L"binmode\*(R" up in perlfunc fo' how.
.IP "\(bu" 4
Downgrade both sides ta byte-strings
.Sp
Da other way works too, especially if yo ass is shizzle dat all yo' data
are under tha same encoding, or if compatibilitizzle wit olda versions
of Perl is desired.
.Sp
Yo ass may downgrade strings wit \f(CW\*(C`Encode::encode\*(C'\fR n' \f(CW\*(C`utf8::encode\*(C'\fR.
See Encode n' utf8 fo' details.
.IP "\(bu" 4
Specify tha encodin fo' implicit byte-strin upgrading
.Sp
If yo ass is Kool & Tha Gang dat all byte-strings is ghon be up in a specific
encodin like \s-1UTF\-8, \s0\fIand\fR need not support olda versionz of Perl,
use tha \f(CW\*(C`encoding\*(C'\fR pragma:
.Sp
.Vb 1
\&    use encodin \*(Aqutf8\*(Aq;
.Ve
.Sp
Similarly, dis will silence warnings from dis module, n' preserve the
default behaviour:
.Sp
.Vb 1
\&    use encodin \*(Aqiso\-8859\-1\*(Aq;
.Ve
.Sp
But fuck dat shiznit yo, tha word on tha street is dat note dat \f(CW\*(C`use encoding\*(C'\fR straight-up had three distinct effects:
.RS 4
.IP "\(bu" 4
PerlIO layers fo' \fB\s-1STDIN\s0\fR n' \fB\s-1STDOUT\s0\fR
.Sp
This is similar ta what tha fuck open pragma do.
.IP "\(bu" 4
Literal conversions
.Sp
This turns \fIall\fR literal strang up in yo' program tha fuck into unicode-strings
(equivalent ta a \f(CW\*(C`use utf8\*(C'\fR), by decodin dem rockin tha specified
encoding.
.IP "\(bu" 4
Implicit upgradin fo' byte-strings
.Sp
This will silence warnings from dis module, as shown above.
.RE
.RS 4
.Sp
Because literal conversions also work on empty strings, it may surprise
some people:
.Sp
.Vb 1
\&    use encodin \*(Aqbig5\*(Aq;
\&
\&    mah $byte_strin = pack("C*", 0xA4, 0x40);
\&    print length $a;    # 2 here.
\&    $a .= "";           # concatenatin wit a unicode string...
\&    print length $a;    # 1 here!
.Ve
.Sp
In other lyrics, do not \f(CW\*(C`use encoding\*(C'\fR unless yo ass is certain dat the
program aint gonna deal wit any raw, 8\-bit binary data at all.
.Sp
But fuck dat shiznit yo, tha word on tha street is dat tha \f(CW\*(C`Filta => 1\*(C'\fR flavor of \f(CW\*(C`use encoding\*(C'\fR will \fInot\fR
affect implicit upgradin fo' byte-strings, n' is thus incapable of
silencin warnings from dis module.  See encodin fo' mo' details.
.RE
.SH "CAVEATS"
.IX Header "CAVEATS"
For Perl 5.9.4 or later, dis modulez effect is lexical.
.PP
For Perl versions prior ta 5.9.4, dis module affects tha whole script,
instead of inside its lexical block.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlunicode, perluniintro
.PP
open, utf8, encoding, Encode
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004, 2005, 2006, 2007 by Audrey Tang <cpan@audreyt.org>.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
