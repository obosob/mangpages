.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Uncompress::Gunzip 3"
.TH IO::Uncompress::Gunzip 3 "2013-08-11" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Uncompress::Gunzip \- Read RFC 1952 files/buffers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;
\&
\&    mah $status = gunzip $input => $output [,OPTS]
\&        or take a thugged-out dirtnap "gunzip failed: $GunzipError\en";
\&
\&    mah $z = freshly smoked up IO::Uncompress::Gunzip $input [OPTS] 
\&        or take a thugged-out dirtnap "gunzip failed: $GunzipError\en";
\&
\&    $status = $z\->read($buffer)
\&    $status = $z\->read($buffer, $length)
\&    $status = $z\->read($buffer, $length, $offset)
\&    $line = $z\->getline()
\&    $char = $z\->getc()
\&    $char = $z\->ungetc()
\&    $char = $z\->opened()
\&
\&    $status = $z\->inflateSync()
\&
\&    $data = $z\->trailingData()
\&    $status = $z\->nextStream()
\&    $data = $z\->getHeaderInfo()
\&    $z\->tell()
\&    $z\->seek($position, $whence)
\&    $z\->binmode()
\&    $z\->fileno()
\&    $z\->eof()
\&    $z\->close()
\&
\&    $GunzipError ;
\&
\&    # IO::File mode
\&
\&    <$z>
\&    read($z, $buffer);
\&    read($z, $buffer, $length);
\&    read($z, $buffer, $length, $offset);
\&    tell($z)
\&    seek($z, $position, $whence)
\&    binmode($z)
\&    fileno($z)
\&    eof($z)
\&    close($z)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up a Perl intercourse dat allows tha readin of
files/buffers dat conform ta \s-1RFC 1952.\s0
.PP
For freestylin \s-1RFC 1952\s0 files/buffers, peep tha companion module IO::Compress::Gzip.
.SH "Functionizzle Interface"
.IX Header "Functionizzle Interface"
A top-level function, \f(CW\*(C`gunzip\*(C'\fR, is provided ta carry out
\&\*(L"one-shot\*(R" uncompression between buffers and/or files. For finer
control over tha uncompression process, peep tha \*(L"\s-1OO\s0 Interface\*(R"
section.
.PP
.Vb 1
\&    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;
\&
\&    gunzip $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
\&        or take a thugged-out dirtnap "gunzip failed: $GunzipError\en";
.Ve
.PP
Da functionizzle intercourse needz Perl5.005 or better.
.ie n .SS "gunzip $input_filename_or_reference => $output_filename_or_reference [, \s-1OPTS\s0]"
.el .SS "gunzip \f(CW$input_filename_or_reference\fP => \f(CW$output_filename_or_reference\fP [, \s-1OPTS\s0]"
.IX Subsection "gunzip $input_filename_or_reference => $output_filename_or_reference [, OPTS]"
\&\f(CW\*(C`gunzip\*(C'\fR expects at least two parameters,
\&\f(CW$input_filename_or_reference\fR n' \f(CW$output_filename_or_reference\fR.
.PP
\fIDa \f(CI$input_filename_or_reference\fI parameter\fR
.IX Subsection "Da $input_filename_or_reference parameter"
.PP
Da parameter, \f(CW$input_filename_or_reference\fR, is used ta define the
source of tha compressed data.
.PP
It can take one of tha followin forms:
.IP "A filename" 5
.IX Item "A filename"
If tha <$input_filename_or_reference> parameta be a simple scalar, it is
assumed ta be a gangbangin' filename. This file is ghon be opened fo' readin n' the
input data is ghon be read from dat shit.
.IP "A filehandle" 5
.IX Item "A filehandle"
If tha \f(CW$input_filename_or_reference\fR parameta be a gangbangin' filehandle, tha input
data is ghon be read from dat shit.  Da strang '\-' can be used as a alias for
standard input.
.IP "A scalar reference" 5
.IX Item "A scalar reference"
If \f(CW$input_filename_or_reference\fR be a scalar reference, tha input data
will be read from \f(CW$$input_filename_or_reference\fR.
.IP "An array reference" 5
.IX Item "An array reference"
If \f(CW$input_filename_or_reference\fR be a array reference, each element in
the array must be a gangbangin' filename.
.Sp
Da input data is ghon be read from each file up in turn.
.Sp
Da complete array is ghon be strutted ta ensure dat it only
gotz nuff valid filenames before any data is uncompressed.
.IP "An Input FileGlob string" 5
.IX Item "An Input FileGlob string"
If \f(CW$input_filename_or_reference\fR be a strang dat is delimited by the
charactas \*(L"<\*(R" n' \*(L">\*(R" \f(CW\*(C`gunzip\*(C'\fR will assume dat it be a 
\&\fIinput fileglob string\fR. Da input is tha list of filez dat match tha 
fileglob.
.Sp
See File::GlobMapper fo' mo' details.
.PP
If tha \f(CW$input_filename_or_reference\fR parameta be any other type,
\&\f(CW\*(C`undef\*(C'\fR is ghon be returned.
.PP
\fIDa \f(CI$output_filename_or_reference\fI parameter\fR
.IX Subsection "Da $output_filename_or_reference parameter"
.PP
Da parameta \f(CW$output_filename_or_reference\fR is used ta control the
destination of tha uncompressed data. This parameta can take one of
these forms.
.IP "A filename" 5
.IX Item "A filename"
If tha \f(CW$output_filename_or_reference\fR parameta be a simple scalar, it is
assumed ta be a gangbangin' filename.  This file is ghon be opened fo' freestylin n' tha 
uncompressed data is ghon be freestyled ta dat shit.
.IP "A filehandle" 5
.IX Item "A filehandle"
If tha \f(CW$output_filename_or_reference\fR parameta be a gangbangin' filehandle, the
uncompressed data is ghon be freestyled ta dat shit.  Da strang '\-' can be used as
an alias fo' standard output.
.IP "A scalar reference" 5
.IX Item "A scalar reference"
If \f(CW$output_filename_or_reference\fR be a scalar reference, the
uncompressed data is ghon be stored up in \f(CW$$output_filename_or_reference\fR.
.IP "An Array Reference" 5
.IX Item "An Array Reference"
If \f(CW$output_filename_or_reference\fR be a array reference, 
the uncompressed data is ghon be pushed onto tha array.
.IP "An Output FileGlob" 5
.IX Item "An Output FileGlob"
If \f(CW$output_filename_or_reference\fR be a strang dat is delimited by the
charactas \*(L"<\*(R" n' \*(L">\*(R" \f(CW\*(C`gunzip\*(C'\fR will assume dat it be an
\&\fIoutput fileglob string\fR. Da output is tha list of filez dat match the
fileglob.
.Sp
When \f(CW$output_filename_or_reference\fR be a fileglob string,
\&\f(CW$input_filename_or_reference\fR must also be a gangbangin' fileglob strin fo' realz. Anything
else be a error.
.Sp
See File::GlobMapper fo' mo' details.
.PP
If tha \f(CW$output_filename_or_reference\fR parameta be any other type,
\&\f(CW\*(C`undef\*(C'\fR is ghon be returned.
.SS "Notes"
.IX Subsection "Notes"
When \f(CW$input_filename_or_reference\fR maps ta multiple compressed
files/buffers n' \f(CW$output_filename_or_reference\fR is
a single file/buffer, afta uncompression \f(CW$output_filename_or_reference\fR will contain a
concatenation of all tha uncompressed data from each of tha input
files/buffers.
.SS "Optionizzle Parameters"
.IX Subsection "Optionizzle Parameters"
Unless specified below, tha optionizzle parametas fo' \f(CW\*(C`gunzip\*(C'\fR,
\&\f(CW\*(C`OPTS\*(C'\fR, is tha same as dem used wit tha \s-1OO\s0 intercourse defined up in the
\&\*(L"Constructor Options\*(R" section below.
.ie n .IP """AutoClose => 0|1""" 5
.el .IP "\f(CWAutoClose => 0|1\fR" 5
.IX Item "AutoClose => 0|1"
This option applies ta any input or output data streams ta 
\&\f(CW\*(C`gunzip\*(C'\fR dat is filehandles.
.Sp
If \f(CW\*(C`AutoClose\*(C'\fR is specified, n' tha value is true, it will result up in all
input and/or output filehandlez bein closed once \f(CW\*(C`gunzip\*(C'\fR has
completed.
.Sp
This parameta defaults ta 0.
.ie n .IP """BinModeOut => 0|1""" 5
.el .IP "\f(CWBinModeOut => 0|1\fR" 5
.IX Item "BinModeOut => 0|1"
When freestylin ta a gangbangin' file or filehandle, set \f(CW\*(C`binmode\*(C'\fR before freestylin ta the
file.
.Sp
Defaults ta 0.
.ie n .IP """Append => 0|1""" 5
.el .IP "\f(CWAppend => 0|1\fR" 5
.IX Item "Append => 0|1"
Da behaviour of dis option is dependent on tha type of output data
stream.
.RS 5
.IP "\(bu" 5
A Buffer
.Sp
If \f(CW\*(C`Append\*(C'\fR is enabled, all uncompressed data is ghon be append ta tha end of
the output buffer n' shit. Otherwise tha output buffer is ghon be cleared before any
uncompressed data is freestyled ta dat shit.
.IP "\(bu" 5
A Filename
.Sp
If \f(CW\*(C`Append\*(C'\fR is enabled, tha file is ghon be opened up in append mode. Otherwise
the contentz of tha file, if any, is ghon be truncated before any uncompressed
data is freestyled ta dat shit.
.IP "\(bu" 5
A Filehandle
.Sp
If \f(CW\*(C`Append\*(C'\fR is enabled, tha filehandle is ghon be positioned ta tha end of
the file via a cold-ass lil call ta \f(CW\*(C`seek\*(C'\fR before any uncompressed data is
written ta dat shit.  Otherwise tha file pointa aint gonna be moved.
.RE
.RS 5
.Sp
When \f(CW\*(C`Append\*(C'\fR is specified, n' set ta true, it will \fIappend\fR all uncompressed 
data ta tha output data stream.
.Sp
So when tha output be a gangbangin' filehandle it will carry up a seek ta tha eof
before freestylin any uncompressed data. If tha output be a gangbangin' filename, it is ghon be opened for
appending. If tha output be a funky-ass buffer, all uncompressed data will be
appended ta tha existin buffer.
.Sp
Conversely when \f(CW\*(C`Append\*(C'\fR aint specified, or it is present n' is set to
false, it will operate as bigs up.
.Sp
When tha output be a gangbangin' filename, it will truncate tha contentz of tha file
before freestylin any uncompressed data. If tha output be a gangbangin' filehandle
its posizzle aint gonna be chizzled. Y'all KNOW dat shit, muthafucka! If tha output be a funky-ass buffer, it will be
wiped before any uncompressed data is output.
.Sp
Defaults ta 0.
.RE
.ie n .IP """MultiStream => 0|1""" 5
.el .IP "\f(CWMultiStream => 0|1\fR" 5
.IX Item "MultiStream => 0|1"
If tha input file/buffer gotz nuff multiple compressed data streams, this
option will uncompress tha whole lot as a single data stream.
.Sp
Defaults ta 0.
.ie n .IP """TrailingData => $scalar""" 5
.el .IP "\f(CWTrailingData => $scalar\fR" 5
.IX Item "TrailingData => $scalar"
Returns tha data, if any, dat is present immediately afta tha compressed
data stream once uncompression is complete.
.Sp
This option can be used when there is useful shiznit immediately
followin tha compressed data stream, n' you don't give a fuck tha length of the
compressed data stream.
.Sp
If tha input be a funky-ass buffer, \f(CW\*(C`trailingData\*(C'\fR will return every last muthafuckin thang from the
end of tha compressed data stream ta tha end of tha buffer.
.Sp
If tha input be a gangbangin' filehandle, \f(CW\*(C`trailingData\*(C'\fR will return tha data dat is
left up in tha filehandle input buffer once tha end of tha compressed data
stream has been reached. Y'all KNOW dat shit, muthafucka! Yo ass can then use tha filehandle ta read tha rest
of tha input file.
.Sp
Don't bother rockin \f(CW\*(C`trailingData\*(C'\fR if tha input be a gangbangin' filename.
.Sp
If you know tha length of tha compressed data stream before you start
uncompressing, you can avoid havin ta use \f(CW\*(C`trailingData\*(C'\fR by settin the
\&\f(CW\*(C`InputLength\*(C'\fR option.
.SS "Examples"
.IX Subsection "Examples"
To read tha contentz of tha file \f(CW\*(C`file1.txt.gz\*(C'\fR n' write the
uncompressed data ta tha file \f(CW\*(C`file1.txt\*(C'\fR.
.PP
.Vb 3
\&    use strict ;
\&    use warnings ;
\&    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;
\&
\&    mah $input = "file1.txt.gz";
\&    mah $output = "file1.txt";
\&    gunzip $input => $output
\&        or take a thugged-out dirtnap "gunzip failed: $GunzipError\en";
.Ve
.PP
To read from a existin Perl filehandle, \f(CW$input\fR, n' write the
uncompressed data ta a funky-ass buffer, \f(CW$buffer\fR.
.PP
.Vb 4
\&    use strict ;
\&    use warnings ;
\&    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;
\&    use IO::File ;
\&
\&    mah $input = freshly smoked up IO::File "<file1.txt.gz"
\&        or take a thugged-out dirtnap "Cannot open \*(Aqfile1.txt.gz\*(Aq: $!\en" ;
\&    mah $buffer ;
\&    gunzip $input => \e$buffer 
\&        or take a thugged-out dirtnap "gunzip failed: $GunzipError\en";
.Ve
.PP
To uncompress all filez up in tha directory \*(L"/my/home\*(R" dat match \*(L"*.txt.gz\*(R" n' store tha compressed data up in tha same directory
.PP
.Vb 3
\&    use strict ;
\&    use warnings ;
\&    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;
\&
\&    gunzip \*(Aq</my/home/*.txt.gz>\*(Aq => \*(Aq</my/home/#1.txt>\*(Aq
\&        or take a thugged-out dirtnap "gunzip failed: $GunzipError\en";
.Ve
.PP
and if you wanna compress each file one at a time, dis will do tha trick
.PP
.Vb 3
\&    use strict ;
\&    use warnings ;
\&    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;
\&
\&    fo' mah $input ( glob "/my/home/*.txt.gz" )
\&    {
\&        mah $output = $input;
\&        $output =~ s/.gz// ;
\&        gunzip $input => $output 
\&            or take a thugged-out dirtnap "Error compressin \*(Aq$input\*(Aq: $GunzipError\en";
\&    }
.Ve
.SH "OO Interface"
.IX Header "OO Interface"
.SS "Constructor"
.IX Subsection "Constructor"
Da format of tha constructor fo' IO::Uncompress::Gunzip is shown below
.PP
.Vb 2
\&    mah $z = freshly smoked up IO::Uncompress::Gunzip $input [OPTS]
\&        or take a thugged-out dirtnap "IO::Uncompress::Gunzip failed: $GunzipError\en";
.Ve
.PP
Returns a \f(CW\*(C`IO::Uncompress::Gunzip\*(C'\fR object on success n' undef on failure.
Da variable \f(CW$GunzipError\fR will contain a error message on failure.
.PP
If yo ass is hustlin Perl 5.005 or betta tha object, \f(CW$z\fR, returned from
IO::Uncompress::Gunzip can be used exactly like a IO::File filehandle.
This means dat all aiiight input file operations can be carried up with
\&\f(CW$z\fR.  For example, ta read a line from a cold-ass lil compressed file/buffer you can
use either of these forms
.PP
.Vb 2
\&    $line = $z\->getline();
\&    $line = <$z>;
.Ve
.PP
Da mandatory parameta \f(CW$input\fR is used ta determine tha source of the
compressed data. This parameta can take one of three forms.
.IP "A filename" 5
.IX Item "A filename"
If tha \f(CW$input\fR parameta be a scalar, it be assumed ta be a gangbangin' filename. This
file is ghon be opened fo' readin n' tha compressed data is ghon be read from dat shit.
.IP "A filehandle" 5
.IX Item "A filehandle"
If tha \f(CW$input\fR parameta be a gangbangin' filehandle, tha compressed data will be
read from dat shit.
Da strang '\-' can be used as a alias fo' standard input.
.IP "A scalar reference" 5
.IX Item "A scalar reference"
If \f(CW$input\fR be a scalar reference, tha compressed data is ghon be read from
\&\f(CW$$input\fR.
.SS "Constructor Options"
.IX Subsection "Constructor Options"
Da option names defined below is case insensitizzle n' can be optionally
prefixed by a '\-'.  So all of tha followin is valid
.PP
.Vb 4
\&    \-AutoClose
\&    \-autoclose
\&    AUTOCLOSE
\&    autoclose
.Ve
.PP
\&\s-1OPTS\s0 be a cold-ass lil combination of tha followin options:
.ie n .IP """AutoClose => 0|1""" 5
.el .IP "\f(CWAutoClose => 0|1\fR" 5
.IX Item "AutoClose => 0|1"
This option is only valid when tha \f(CW$input\fR parameta be a gangbangin' filehandle. If
specified, n' tha value is true, it will result up in tha file bein closed once
either tha \f(CW\*(C`close\*(C'\fR method is called or tha IO::Uncompress::Gunzip object is
destroyed.
.Sp
This parameta defaults ta 0.
.ie n .IP """MultiStream => 0|1""" 5
.el .IP "\f(CWMultiStream => 0|1\fR" 5
.IX Item "MultiStream => 0|1"
Allows multiple concatenated compressed streams ta be treated as a single
compressed stream. Decompression will stop once either tha end of the
file/buffer is reached, a error is encountered (premature eof, corrupt
compressed data) or tha end of a stream aint immediately followed by the
start of another stream.
.Sp
This parameta defaults ta 0.
.ie n .IP """Prime => $string""" 5
.el .IP "\f(CWPrime => $string\fR" 5
.IX Item "Prime => $string"
This option will uncompress tha contentz of \f(CW$string\fR before processin the
input file/buffer.
.Sp
This option can be useful when tha compressed data is embedded up in another
file/data structure n' it aint possible ta work up where tha compressed
data begins without havin ta read tha straight-up original gangsta few bytes. If dis is the
case, tha uncompression can be \fIprimed\fR wit these bytes rockin this
option.
.ie n .IP """Transparent => 0|1""" 5
.el .IP "\f(CWTransparent => 0|1\fR" 5
.IX Item "Transparent => 0|1"
If dis option is set n' tha input file/buffer aint compressed data,
the module will allow readin of it anyway.
.Sp
In addition, if tha input file/buffer do contain compressed data and
there is non-compressed data immediately followin it, settin dis option
will make dis module treat tha whole file/buffer as a single data stream.
.Sp
This option defaults ta 1.
.ie n .IP """BlockSize => $num""" 5
.el .IP "\f(CWBlockSize => $num\fR" 5
.IX Item "BlockSize => $num"
When readin tha compressed input data, IO::Uncompress::Gunzip will read it in
blockz of \f(CW$num\fR bytes.
.Sp
This option defaults ta 4096.
.ie n .IP """InputLength => $size""" 5
.el .IP "\f(CWInputLength => $size\fR" 5
.IX Item "InputLength => $size"
When present dis option will limit tha number of compressed bytes read
from tha input file/buffer ta \f(CW$size\fR. This option can be used up in the
situation where there is useful data directly afta tha compressed data
stream n' you know beforehand tha exact length of tha compressed data
stream.
.Sp
This option is mostly used when readin from a gangbangin' filehandle, up in which case
the file pointa is ghon be left pointin ta tha straight-up original gangsta byte directly afta the
compressed data stream.
.Sp
This option defaults ta off.
.ie n .IP """Append => 0|1""" 5
.el .IP "\f(CWAppend => 0|1\fR" 5
.IX Item "Append => 0|1"
This option controls what tha fuck tha \f(CW\*(C`read\*(C'\fR method do wit uncompressed data.
.Sp
If set ta 1, all uncompressed data is ghon be appended ta tha output parameter
of tha \f(CW\*(C`read\*(C'\fR method.
.Sp
If set ta 0, tha contentz of tha output parameta of tha \f(CW\*(C`read\*(C'\fR method
will be overwritten by tha uncompressed data.
.Sp
Defaults ta 0.
.ie n .IP """Strict => 0|1""" 5
.el .IP "\f(CWStrict => 0|1\fR" 5
.IX Item "Strict => 0|1"
This option controls whether tha extra checks defined below is used when
carryin up tha decompression. I aint talkin' bout chicken n' gravy biatch. When Strict is on, tha extra tests are
carried out, when Strict is off they is not.
.Sp
Da default fo' dis option is off.
.RS 5
.IP "1." 5
If tha \s-1FHCRC\s0 bit is set up in tha gzip \s-1FLG\s0 header byte, tha \s-1CRC16\s0 bytes up in the
header must match tha crc16 value of tha gzip header straight-up read.
.IP "2." 5
If tha gzip header gotz nuff a name field (\s-1FNAME\s0) it consists solely of \s-1ISO
8859\-1\s0 characters.
.IP "3." 5
If tha gzip header gotz nuff a cold-ass lil comment field (\s-1FCOMMENT\s0) it consists solely
of \s-1ISO 8859\-1\s0 charactas plus line-feed.
.IP "4." 5
If tha gzip \s-1FEXTRA\s0 header field is present it must conform ta tha sub-field
structure as defined up in \s-1RFC 1952.\s0
.IP "5." 5
Da \s-1CRC32\s0 n' \s-1ISIZE\s0 traila fieldz must be present.
.IP "6." 5
Da value of tha \s-1CRC32\s0 field read must match tha crc32 value of the
uncompressed data straight-up contained up in tha gzip file.
.IP "7." 5
Da value of tha \s-1ISIZE\s0 fieldz read must match tha length of the
uncompressed data straight-up read from tha file.
.RE
.RS 5
.RE
.ie n .IP """ParseExtra => 0|1"" If tha gzip \s-1FEXTRA\s0 header field is present n' dis option is set, it will force tha module ta check dat it conforms ta tha sub-field structure as defined up in \s-1RFC 1952.\s0" 5
.el .IP "\f(CWParseExtra => 0|1\fR If tha gzip \s-1FEXTRA\s0 header field is present n' dis option is set, it will force tha module ta check dat it conforms ta tha sub-field structure as defined up in \s-1RFC 1952.\s0" 5
.IX Item "ParseExtra => 0|1 If tha gzip FEXTRA header field is present n' dis option is set, it will force tha module ta check dat it conforms ta tha sub-field structure as defined up in RFC 1952."
If tha \f(CW\*(C`Strict\*(C'\fR is on it will automatically enable dis option.
.Sp
Defaults ta 0.
.SS "Examples"
.IX Subsection "Examples"
\&\s-1TODO\s0
.SH "Methods"
.IX Header "Methods"
.SS "read"
.IX Subsection "read"
Usage is
.PP
.Vb 1
\&    $status = $z\->read($buffer)
.Ve
.PP
Readz a funky-ass block of compressed data (the size of tha compressed block is
determined by tha \f(CW\*(C`Buffer\*(C'\fR option up in tha constructor), uncompresses it and
writes any uncompressed data tha fuck into \f(CW$buffer\fR. If tha \f(CW\*(C`Append\*(C'\fR parameta is
set up in tha constructor, tha uncompressed data is ghon be appended ta the
\&\f(CW$buffer\fR parameter n' shit. Otherwise \f(CW$buffer\fR is ghon be overwritten.
.PP
Returns tha number of uncompressed bytes freestyled ta \f(CW$buffer\fR, zero if eof
or a wack number on error.
.SS "read"
.IX Subsection "read"
Usage is
.PP
.Vb 2
\&    $status = $z\->read($buffer, $length)
\&    $status = $z\->read($buffer, $length, $offset)
\&
\&    $status = read($z, $buffer, $length)
\&    $status = read($z, $buffer, $length, $offset)
.Ve
.PP
Attempt ta read \f(CW$length\fR bytez of uncompressed data tha fuck into \f(CW$buffer\fR.
.PP
Da main difference between dis form of tha \f(CW\*(C`read\*(C'\fR method n' the
previous one, is dat dis one will attempt ta return \fIexactly\fR \f(CW$length\fR
bytes. Da only circumstances dat dis function aint gonna is if end-of-file
or a \s-1IO\s0 error is encountered.
.PP
Returns tha number of uncompressed bytes freestyled ta \f(CW$buffer\fR, zero if eof
or a wack number on error.
.SS "getline"
.IX Subsection "getline"
Usage is
.PP
.Vb 2
\&    $line = $z\->getline()
\&    $line = <$z>
.Ve
.PP
Readz a single line.
.PP
This method straight-up supports tha use of tha variable \f(CW$/\fR (or
\&\f(CW$INPUT_RECORD_SEPARATOR\fR or \f(CW$RS\fR when \f(CW\*(C`English\*(C'\fR is up in use) to
determine what tha fuck constitutes a end of line. Paragraph mode, record mode and
file slurp mode is all supported.
.SS "getc"
.IX Subsection "getc"
Usage is
.PP
.Vb 1
\&    $char = $z\->getc()
.Ve
.PP
Read a single character.
.SS "ungetc"
.IX Subsection "ungetc"
Usage is
.PP
.Vb 1
\&    $char = $z\->ungetc($string)
.Ve
.SS "inflateSync"
.IX Subsection "inflateSync"
Usage is
.PP
.Vb 1
\&    $status = $z\->inflateSync()
.Ve
.PP
\&\s-1TODO\s0
.SS "getHeaderInfo"
.IX Subsection "getHeaderInfo"
Usage is
.PP
.Vb 2
\&    $hdr  = $z\->getHeaderInfo();
\&    @hdrs = $z\->getHeaderInfo();
.Ve
.PP
This method returns either a hash reference (in scalar context) or a list
or hash references (in array context) dat gotz nuff shiznit bout each
of tha header fieldz up in tha compressed data stream(s).
.IP "Name" 5
.IX Item "Name"
Da contentz of tha Name header field, if present. If no name is
present, tha value is ghon be undef. Note dis is different from a zero length
name, which will return a empty string.
.IP "Comment" 5
.IX Item "Comment"
Da contentz of tha Comment header field, if present. If no comment is
present, tha value is ghon be undef. Note dis is different from a zero length
comment, which will return a empty string.
.SS "tell"
.IX Subsection "tell"
Usage is
.PP
.Vb 2
\&    $z\->tell()
\&    tell $z
.Ve
.PP
Returns tha uncompressed file offset.
.SS "eof"
.IX Subsection "eof"
Usage is
.PP
.Vb 2
\&    $z\->eof();
\&    eof($z);
.Ve
.PP
Returns legit if tha end of tha compressed input stream has been reached.
.SS "seek"
.IX Subsection "seek"
.Vb 2
\&    $z\->seek($position, $whence);
\&    seek($z, $position, $whence);
.Ve
.PP
Provides a sub-set of tha \f(CW\*(C`seek\*(C'\fR functionality, wit tha restriction
that it is only legal ta seek forward up in tha input file/buffer.
It be a gangbangin' fatal error ta attempt ta seek backward.
.PP
Note dat tha implementation of \f(CW\*(C`seek\*(C'\fR up in dis module do not provide
true random access ta a cold-ass lil compressed file/buffer n' shit. Well shiiiit, it  works by uncompressing
data from tha current offset up in tha file/buffer until it reaches the
uncompressed offset specified up in tha parametas ta \f(CW\*(C`seek\*(C'\fR. For straight-up small
filez dis may be aaight behaviour. Shiiit, dis aint no joke. For big-ass filez it may cause an
unacceptable delay.
.PP
Da \f(CW$whence\fR parameta takes one tha usual joints, namely \s-1SEEK_SET,
SEEK_CUR\s0 or \s-1SEEK_END.\s0
.PP
Returns 1 on success, 0 on failure.
.SS "binmode"
.IX Subsection "binmode"
Usage is
.PP
.Vb 2
\&    $z\->binmode
\&    binmode $z ;
.Ve
.PP
This be a noop provided fo' completeness.
.SS "opened"
.IX Subsection "opened"
.Vb 1
\&    $z\->opened()
.Ve
.PP
Returns legit if tha object currently refers ta a opened file/buffer.
.SS "autoflush"
.IX Subsection "autoflush"
.Vb 2
\&    mah $prev = $z\->autoflush()
\&    mah $prev = $z\->autoflush(EXPR)
.Ve
.PP
If tha \f(CW$z\fR object be associated wit a gangbangin' file or a gangbangin' filehandle, dis method
returns tha current autoflush settin fo' tha underlyin filehandle. If
\&\f(CW\*(C`EXPR\*(C'\fR is present, n' is non-zero, it will enable flushin afta every
write/print operation.
.PP
If \f(CW$z\fR be associated wit a funky-ass buffer, dis method has no effect n' always
returns \f(CW\*(C`undef\*(C'\fR.
.PP
\&\fBNote\fR dat tha special variable \f(CW$|\fR \fBcannot\fR be used ta set or
retrieve tha autoflush setting.
.SS "input_line_number"
.IX Subsection "input_line_number"
.Vb 2
\&    $z\->input_line_number()
\&    $z\->input_line_number(EXPR)
.Ve
.PP
Returns tha current uncompressed line number n' shit. If \f(CW\*(C`EXPR\*(C'\fR is present it has
the effect of settin tha line number n' shit. Note dat settin tha line number
does not chizzle tha current posizzle within tha file/buffer bein read.
.PP
Da contentz of \f(CW$/\fR is used ta determine what tha fuck constitutes a line
terminator.
.SS "fileno"
.IX Subsection "fileno"
.Vb 2
\&    $z\->fileno()
\&    fileno($z)
.Ve
.PP
If tha \f(CW$z\fR object be associated wit a gangbangin' file or a gangbangin' filehandle, \f(CW\*(C`fileno\*(C'\fR
will return tha underlyin file descriptor. Shiiit, dis aint no joke. Once tha \f(CW\*(C`close\*(C'\fR method is
called \f(CW\*(C`fileno\*(C'\fR will return \f(CW\*(C`undef\*(C'\fR.
.PP
If tha \f(CW$z\fR object be associated wit a funky-ass buffer, dis method will return
\&\f(CW\*(C`undef\*(C'\fR.
.SS "close"
.IX Subsection "close"
.Vb 2
\&    $z\->close() ;
\&    close $z ;
.Ve
.PP
Closes tha output file/buffer.
.PP
For most versionz of Perl dis method is ghon be automatically invoked if
the IO::Uncompress::Gunzip object is destroyed (either explicitly or by the
variable wit tha reference ta tha object goin outta scope). The
exceptions is Perl versions 5.005 all up in 5.00504 n' 5.8.0. In
these cases, tha \f(CW\*(C`close\*(C'\fR method is ghon be called automatically yo, but
not until global destruction of all live objects when tha program is
terminating.
.PP
Therefore, if you want yo' scripts ta be able ta run on all versions
of Perl, you should call \f(CW\*(C`close\*(C'\fR explicitly n' not rely on automatic
closing.
.PP
Returns legit on success, otherwise 0.
.PP
If tha \f(CW\*(C`AutoClose\*(C'\fR option has been enabled when tha IO::Uncompress::Gunzip
object was pimped, n' tha object be associated wit a gangbangin' file, the
underlyin file will also be closed.
.SS "nextStream"
.IX Subsection "nextStream"
Usage is
.PP
.Vb 1
\&    mah $status = $z\->nextStream();
.Ve
.PP
Skips ta tha next compressed data stream up in tha input file/buffer n' shit. If a new
compressed data stream is found, tha eof marker is ghon be cleared n' \f(CW$.\fR
will be reset ta 0.
.PP
Returns 1 if a freshly smoked up stream was found, 0 if none was found, n' \-1 if an
error was encountered.
.SS "trailingData"
.IX Subsection "trailingData"
Usage is
.PP
.Vb 1
\&    mah $data = $z\->trailingData();
.Ve
.PP
Returns tha data, if any, dat is present immediately afta tha compressed
data stream once uncompression is complete. Well shiiiit, it only make sense ta call
this method once tha end of tha compressed data stream has been
encountered.
.PP
This option can be used when there is useful shiznit immediately
followin tha compressed data stream, n' you don't give a fuck tha length of the
compressed data stream.
.PP
If tha input be a funky-ass buffer, \f(CW\*(C`trailingData\*(C'\fR will return every last muthafuckin thang from the
end of tha compressed data stream ta tha end of tha buffer.
.PP
If tha input be a gangbangin' filehandle, \f(CW\*(C`trailingData\*(C'\fR will return tha data dat is
left up in tha filehandle input buffer once tha end of tha compressed data
stream has been reached. Y'all KNOW dat shit, muthafucka! Yo ass can then use tha filehandle ta read tha rest
of tha input file.
.PP
Don't bother rockin \f(CW\*(C`trailingData\*(C'\fR if tha input be a gangbangin' filename.
.PP
If you know tha length of tha compressed data stream before you start
uncompressing, you can avoid havin ta use \f(CW\*(C`trailingData\*(C'\fR by settin the
\&\f(CW\*(C`InputLength\*(C'\fR option up in tha constructor.
.SH "Importing"
.IX Header "Importing"
No symbolic constants is required by dis IO::Uncompress::Gunzip at present.
.IP ":all" 5
.IX Item ":all"
Imports \f(CW\*(C`gunzip\*(C'\fR n' \f(CW$GunzipError\fR.
Same as bustin this
.Sp
.Vb 1
\&    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Workin wit Net::FTP"
.IX Subsection "Workin wit Net::FTP"
See IO::Compress::FAQ
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Compress::Zlib, IO::Compress::Gzip, IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate, IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress
.PP
IO::Compress::FAQ
.PP
File::GlobMapper, Archive::Zip,
Archive::Tar,
IO::Zlib
.PP
For \s-1RFC 1950, 1951\s0 n' 1952 peep 
\&\fIhttp://www.faqs.org/rfcs/rfc1950.html\fR,
\&\fIhttp://www.faqs.org/rfcs/rfc1951.html\fR and
\&\fIhttp://www.faqs.org/rfcs/rfc1952.html\fR
.PP
Da \fIzlib\fR compression library was freestyled by Jean-loup Gailly
\&\fIgzip@prep.ai.mit.edu\fR n' Mark Adla \fImadler@alumni.caltech.edu\fR.
.PP
Da primary joint fo' tha \fIzlib\fR compression library is
\&\fIhttp://www.zlib.org\fR.
.PP
Da primary joint fo' gzip is \fIhttp://www.gzip.org\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module was freestyled by Pizzle Marquess, \fIpmqs@cpan.org\fR.
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
See tha Chizzlez file.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2005\-2013 Pizzle Marquess fo' realz. All muthafuckin rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
