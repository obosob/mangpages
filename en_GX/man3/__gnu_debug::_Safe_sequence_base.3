.TH "__gnu_debug::_Safe_sequence_base" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_debug::_Safe_sequence_base \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherited by \fB__gnu_debug::_Safe_sequence< _Sequence >\fP, \fB__gnu_debug::_Safe_unordered_container_base\fP, \fB__gnu_debug::_Safe_sequence< basic_string< _CharT, _Traits, _Allocator > >\fP, \fB__gnu_debug::_Safe_sequence< deque< _Tp, _Allocator > >\fP, \fB__gnu_debug::_Safe_sequence< forward_list< _Tp, _Alloc > >\fP, \fB__gnu_debug::_Safe_sequence< list< _Tp, _Allocator > >\fP, \fB__gnu_debug::_Safe_sequence< map< _Key, _Tp, _Compare, _Allocator > >\fP, \fB__gnu_debug::_Safe_sequence< multimap< _Key, _Tp, _Compare, _Allocator > >\fP, \fB__gnu_debug::_Safe_sequence< multiset< _Key, _Compare, _Allocator > >\fP, \fB__gnu_debug::_Safe_sequence< set< _Key, _Compare, _Allocator > >\fP, n' \fB__gnu_debug::_Safe_sequence< vector< _Tp, _Allocator > >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_attach\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (\fB_Safe_iterator_base\fP *__it, bool __constant)  throw ()"
.br
.ti -1c
.RI "void \fB_M_detach\fP (\fB_Safe_iterator_base\fP *__it)"
.br
.ti -1c
.RI "void \fB_M_detach_single\fP (\fB_Safe_iterator_base\fP *__it)  throw ()"
.br
.ti -1c
.RI "void \fB_M_invalidate_all\fP () const "
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_const_iterators\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_iterators\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fB~_Safe_sequence_base\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_all\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_singular\fP ()"
.br
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()  throw ()"
.br
.ti -1c
.RI "void \fB_M_revalidate_singular\fP ()"
.br
.ti -1c
.RI "void \fB_M_swap\fP (\fB_Safe_sequence_base\fP &__x)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Base class dat supports trackin of iterators dat reference a sequence\&. 

Da _Safe_sequence_base class serves up basic support fo' trackin iterators tha fuck into a sequence\&. Right back up in yo muthafuckin ass. Sequences dat track iterators must derived from _Safe_sequence_base publicly, so dat safe iterators (which inherit _Safe_iterator_base) can attach ta them\&. This class gotz nuff two linked listz of iterators, one fo' constant iterators n' one fo' mutable iterators, n' a version number dat allows straight-up fast invalidation of all iterators dat reference tha container\&.
.PP
This class must ensure dat no operation on it may throw a exception, otherwise \fIsafe\fP sequences may fail ta provide tha exception-safety guarantees required by tha C++ standard\&. 
.PP
Definizzle at line 177 of file safe_base\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "__gnu_debug::_Safe_sequence_base::~_Safe_sequence_base ()\fC [inline]\fP, \fC [protected]\fP"
Notify all iterators dat reference dis sequence dat tha sequence is bein destroyed\&. 
.PP
Definizzle at line 197 of file safe_base\&.h\&.
.PP
References _M_detach_all()\&.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach (\fB_Safe_iterator_base\fP *__it, bool__constant)"
Attach a iterator ta dis sequence\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_attach_single (\fB_Safe_iterator_base\fP *__it, bool__constant)"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach (\fB_Safe_iterator_base\fP *__it)"
Detach a iterator from dis sequence 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_all ()\fC [protected]\fP"
Detach all iterators, leavin dem singular\&. 
.PP
Referenced by ~_Safe_sequence_base()\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_single (\fB_Safe_iterator_base\fP *__it)"
Likewise but not thread safe\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_singular ()\fC [protected]\fP"
Detach all singular iterators\&. 
.PP
\fBPostcondition:\fP
.RS 4
for all iterators i attached ta dis sequence, i->_M_version == _M_version\&. 
.RE
.PP

.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_sequence_base::_M_get_mutex ()\fC [protected]\fP"
For use up in _Safe_sequence\&. 
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_invalidate_all () const\fC [inline]\fP"
Invalidates all iterators\&. 
.PP
Definizzle at line 233 of file safe_base\&.h\&.
.PP
References _M_version\&.
.SS "void __gnu_debug::_Safe_sequence_base::_M_revalidate_singular ()\fC [protected]\fP"
Revalidates all attached singular iterators\&. This method may be used ta validate iterators dat was invalidated before (but fo' some reason, like fuckin a exception, need ta become valid again)\&. 
.SS "void __gnu_debug::_Safe_sequence_base::_M_swap (\fB_Safe_sequence_base\fP &__x)\fC [protected]\fP"
Swap dis sequence wit tha given sequence\&. This operation also swaps ballershizzle of tha iterators, so dat when tha operation is complete all iterators dat originally referenced one container now reference tha other container\&. 
.SH "Member Data Documentation"
.PP 
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_sequence_base::_M_const_iterators"

.PP
Da list of constant iterators dat reference dis container\&. 
.PP
Definizzle at line 184 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "\fB_Safe_iterator_base\fP* __gnu_debug::_Safe_sequence_base::_M_iterators"

.PP
Da list of mutable iterators dat reference dis container\&. 
.PP
Definizzle at line 181 of file safe_base\&.h\&.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.
.SS "unsigned int __gnu_debug::_Safe_sequence_base::_M_version\fC [mutable]\fP"

.PP
Da container version number\&. This number may never be 0\&. 
.PP
Definizzle at line 187 of file safe_base\&.h\&.
.PP
Referenced by _M_invalidate_all(), n' __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_from_if()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
