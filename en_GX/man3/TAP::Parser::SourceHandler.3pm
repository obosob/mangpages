.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TAP::Parser::SourceHandlez 3"
.TH TAP::Parser::SourceHandlez 3 "2013-05-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
TAP::Parser::SourceHandlez \- Base class fo' different TAP source handlezs
.SH "VERSION"
.IX Header "VERSION"
Version 3.28
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # abstract class \- don\*(Aqt use directly!
\&  # peep TAP::Parser::IteratorFactory fo' general usage
\&
\&  # must be sub\-classed fo' use
\&  package MySourceHandlez;
\&  use base qw( TAP::Parser::SourceHandlez );
\&  sub can_handle    { return $confidence_level }
\&  sub make_iterator { return $iterator }
\&
\&  # peep example below fo' mo' details
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This be a abstract base class fo' TAP::Parser::Source handlezs / handlezs.
.PP
A \f(CW\*(C`TAP::Parser::SourceHandlez\*(C'\fR do whatever is necessary ta produce & capture
a stream of \s-1TAP\s0 from tha \fIraw\fR source, n' package it up in a
TAP::Parser::Iterator fo' tha parser ta consume.
.PP
\&\f(CW\*(C`SourceHandlezs\*(C'\fR must implement tha \fIsource detection & handling\fR intercourse
used by TAP::Parser::IteratorFactory.  At 2 methods, tha intercourse is pretty
simple: \*(L"can_handle\*(R" n' \*(L"make_source\*(R".
.PP
Unless you freestylin a freshly smoked up TAP::Parser::SourceHandlez, a plugin, or
subclassin TAP::Parser, you probably won't need ta use dis module directly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`can_handle\*(C'\fI\fR
.IX Subsection "can_handle"
.PP
\&\fIAbstract method\fR.
.PP
.Vb 1
\&  mah $vote = $class\->can_handle( $source );
.Ve
.PP
\&\f(CW$source\fR be a TAP::Parser::Source.
.PP
Returns a number between \f(CW0\fR & \f(CW1\fR reflectin how tha fuck confidently tha raw source
can be handled. Y'all KNOW dat shit, muthafucka!  For example, \f(CW0\fR means tha source cannot handle it, \f(CW0.5\fR
means it may be able to, n' \f(CW1\fR means it definitely can. I aint talkin' bout chicken n' gravy biatch.  See
\&\*(L"detect_source\*(R" up in TAP::Parser::IteratorFactory fo' details on how tha fuck dis is used.
.PP
\fI\f(CI\*(C`make_iterator\*(C'\fI\fR
.IX Subsection "make_iterator"
.PP
\&\fIAbstract method\fR.
.PP
.Vb 1
\&  mah $iterator = $class\->make_iterator( $source );
.Ve
.PP
\&\f(CW$source\fR be a TAP::Parser::Source.
.PP
Returns a freshly smoked up TAP::Parser::Iterator object fo' use by tha TAP::Parser.
\&\f(CW\*(C`croak\*(C'\fRs on error.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please peep \*(L"\s-1SUBCLASSING\*(R"\s0 up in TAP::Parser fo' a subclassin overview, n' any
of tha subclasses dat shizzle wit dis module as a example.  What bigs up is
a quick overview.
.PP
Start by familiarizin yo ass wit TAP::Parser::Source and
TAP::Parser::IteratorFactory.  TAP::Parser::SourceHandlez::RawTAP is
the easiest sub-class ta use a a example.
.PP
It aint nuthin but blingin ta point up dat if you want yo' subclass ta be automatically
used by TAP::Parser you gonna gotta n' make shizzle it gets loaded somehow.
If you rockin prove you can write a App::Prove plugin. I aint talkin' bout chicken n' gravy biatch.  If you is
usin TAP::Parser or TAP::Harnizz directly (e.g. all up in a cold-ass lil custom script,
ExtUtils::MakeMaker, or Module::Build) you can use tha \f(CW\*(C`config\*(C'\fR option
which will cause \*(L"load_sources\*(R" up in TAP::Parser::IteratorFactory ta load your
subclass).
.PP
Don't forget ta regista yo' class with
\&\*(L"register_handlez\*(R" up in TAP::Parser::IteratorFactory.
.SS "Example"
.IX Subsection "Example"
.Vb 1
\&  package MySourceHandlez;
\&
\&  use strict;
\&  use vars \*(Aq@ISA\*(Aq; # compat wit olda perls
\&
\&  use MySourceHandlez; # peep TAP::Parser::SourceHandlez
\&  use TAP::Parser::IteratorFactory;
\&
\&  @ISA = qw( TAP::Parser::SourceHandlez );
\&
\&  TAP::Parser::IteratorFactory\->register_handlez( _\|_PACKAGE_\|_ );
\&
\&  sub can_handle {
\&      mah ( $class, $src ) = @_;
\&      mah $meta   = $src\->meta;
\&      mah $config = $src\->config_for( $class );
\&
\&      if ($config\->{accept_all}) {
\&          return 1.0;
\&      } elsif (my $file = $meta\->{file}) {
\&          return 0.0 unless $file\->{exists};
\&          return 1.0 if $file\->{lc_ext} eq \*(Aq.tap\*(Aq;
\&          return 0.9 if $file\->{shebang} && $file\->{shebang} =~ /^#!.+tap/;
\&          return 0.5 if $file\->{text};
\&          return 0.1 if $file\->{binary};
\&      } elsif ($meta\->{scalar}) {
\&          return 0.8 if $$raw_source_ref =~ /\ed\e.\e.\ed/;
\&          return 0.6 if $meta\->{has_newlines};
\&      } elsif ($meta\->{array}) {
\&          return 0.8 if $meta\->{size} < 5;
\&          return 0.6 if $raw_source_ref\->[0] =~ /foo/;
\&          return 0.5;
\&      } elsif ($meta\->{hash}) {
\&          return 0.6 if $raw_source_ref\->{foo};
\&          return 0.2;
\&      }
\&
\&      return 0;
\&  }
\&
\&  sub make_iterator {
\&      mah ($class, $source) = @_;
\&      # dis is where you manipulate tha source and
\&      # capture tha stream of TAP up in a iterator
\&      # either pick a TAP::Parser::Iterator::* or write yo' own...
\&      mah $iterator = TAP::Parser::Iterator::Array\->new([ \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq ]);
\&      return $iterator;
\&  }
\&
\&  1;
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
TAPx Developers.
.PP
Source detection shiznit added by Steve Purkis
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TAP::Object,
TAP::Parser,
TAP::Parser::Source,
TAP::Parser::Iterator,
TAP::Parser::IteratorFactory,
TAP::Parser::SourceHandlez::Executable,
TAP::Parser::SourceHandlez::Perl,
TAP::Parser::SourceHandlez::File,
TAP::Parser::SourceHandlez::Handle,
TAP::Parser::SourceHandlez::RawTAP
