.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Module::Pluggable 3"
.TH Module::Pluggable 3 "2014-01-06" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Module::Pluggable \- automatically give yo' module tha mobilitizzle ta have plugins
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Simple use Module::Pluggable \-
.PP
.Vb 2
\&    package MyClass;
\&    use Module::Pluggable;
.Ve
.PP
and then lata ...
.PP
.Vb 4
\&    use MyClass;
\&    mah $mc = MyClass\->new();
\&    # returns tha namez of all plugins installed under MyClass::Plugin::*
\&    mah @plugins = $mc\->plugins();
.Ve
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Why would you wanna do this? Say you have suttin' dat wants ta pass an
object ta a fuckin shitload of different plugins up in turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. For example you may 
wanna extract meta-data from every last muthafuckin email you git busted n' do something
with dat shit. Plugins make sense here cuz then you can keep addin freshly smoked up 
meta data parsers n' all tha logic n' docs fo' each one is ghon be 
self contained n' freshly smoked up handlezs is easy as fuck  ta add without changin tha 
core code. For that, you might do suttin' like ...
.PP
.Vb 1
\&    package Email::Examiner;
\&
\&    use strict;
\&    use Email::Simple;
\&    use Module::Pluggable require => 1;
\&
\&    sub handle_email {
\&        mah $self  = shift;
\&        mah $email = shift;
\&
\&        foreach mah $plugin ($self\->plugins) {
\&            $plugin\->examine($email);
\&        }
\&
\&        return 1;
\&    }
.Ve
.PP
\&.. n' all tha plugins will git a cold-ass lil chizzle up in turn ta peep dat shit.
.PP
This can be trivially extended so dat plugins could save tha email
somewhere n' then no other plugin should try n' do dis shit. 
Simply have it so dat tha \f(CW\*(C`examine\*(C'\fR method returns \f(CW1\fR if 
it has saved tha email somewhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Yo ass might also wanna be paranoid
and check ta peep if tha plugin has a \f(CW\*(C`examine\*(C'\fR method.
.PP
.Vb 4
\&        foreach mah $plugin ($self\->plugins) {
\&            next unless $plugin\->can(\*(Aqexamine\*(Aq);
\&            last if     $plugin\->examine($email);
\&        }
.Ve
.PP
And so on. I aint talkin' bout chicken n' gravy biatch. Da skyz tha limit.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Provides a simple but, hopefully, extensible way of havin 'plugins' fo' 
your module. Obviously dis aint goin ta be tha be all n' end all of
solutions but it works fo' mah dirty ass.
.PP
Essentially all it do is export a method tha fuck into yo' namespace dat 
looks all up in a search path fo' .pm filez n' turn dem tha fuck into class names.
.PP
Optionally it instantiates dem classes fo' yo thugged-out ass.
.SH "ADVANCED USAGE"
.IX Header "ADVANCED USAGE"
Alternatively, if you don't wanna use 'plugins' as tha method ...
.PP
.Vb 2
\&    package MyClass;
\&    use Module::Pluggable sub_name => \*(Aqfoo\*(Aq;
.Ve
.PP
and then lata ...
.PP
.Vb 1
\&    mah @plugins = $mc\->foo();
.Ve
.PP
Or if you wanna look up in another namespace
.PP
.Vb 2
\&    package MyClass;
\&    use Module::Pluggable search_path => [\*(AqAcme::MyClass::Plugin\*(Aq, \*(AqMyClass::Extend\*(Aq];
.Ve
.PP
or directory
.PP
.Vb 1
\&    use Module::Pluggable search_dirs => [\*(Aqmylibs/Foo\*(Aq];
.Ve
.PP
Or if you wanna instantiate each plugin rather than just return tha name
.PP
.Vb 2
\&    package MyClass;
\&    use Module::Pluggable instantiate => \*(Aqnew\*(Aq;
.Ve
.PP
and then
.PP
.Vb 3
\&    # whatever is passed ta \*(Aqplugins\*(Aq is ghon be passed 
\&    # ta \*(Aqnew\*(Aq fo' each plugin 
\&    mah @plugins = $mc\->plugins(@options);
.Ve
.PP
alternatively you can just require tha module without instantiatin it
.PP
.Vb 2
\&    package MyClass;
\&    use Module::Pluggable require => 1;
.Ve
.PP
since requirin automatically searches inner packages, which may not be desirable, you can turn dis off
.PP
.Vb 2
\&    package MyClass;
\&    use Module::Pluggable require => 1, inner => 0;
.Ve
.PP
Yo ass can limit tha plugins loaded rockin tha except option, either as a string,
array ref or regex
.PP
.Vb 2
\&    package MyClass;
\&    use Module::Pluggable except => \*(AqMyClass::Plugin::Foo\*(Aq;
.Ve
.PP
or
.PP
.Vb 2
\&    package MyClass;
\&    use Module::Pluggable except => [\*(AqMyClass::Plugin::Foo\*(Aq, \*(AqMyClass::Plugin::Bar\*(Aq];
.Ve
.PP
or
.PP
.Vb 2
\&    package MyClass;
\&    use Module::Pluggable except => qr/^MyClass::Plugin::(Foo|Bar)$/;
.Ve
.PP
and similarly fo' only which will only load plugins which match.
.PP
Remember you can use tha module mo' than once
.PP
.Vb 3
\&    package MyClass;
\&    use Module::Pluggable search_path => \*(AqMyClass::Filters\*(Aq sub_name => \*(Aqfilters\*(Aq;
\&    use Module::Pluggable search_path => \*(AqMyClass::Plugins\*(Aq sub_name => \*(Aqplugins\*(Aq;
.Ve
.PP
and then lata ...
.PP
.Vb 2
\&    mah @filtas = $self\->filters;
\&    mah @plugins = $self\->plugins;
.Ve
.SH "PLUGIN SEARCHING"
.IX Header "PLUGIN SEARCHING"
Every time you call 'plugins' tha whole search path is strutted again. I aint talkin' bout chicken n' gravy biatch. This allows 
for dynamically loadin plugins even at run time yo. However dis can git high-rollin' 
and so if you don't expect ta wanna add freshly smoked up plugins at run time you could do
.PP
.Vb 3
\&  package Foo;
\&  use strict;
\&  use Module::Pluggable sub_name => \*(Aq_plugins\*(Aq;
\&
\&  our @PLUGINS;
\&  sub plugins { @PLUGINS ||= shift\->_plugins }
\&  1;
.Ve
.SH "INNER PACKAGES"
.IX Header "INNER PACKAGES"
If you have, fo' example, a gangbangin' file \fBlib/Something/Plugin/Foo.pm\fR that
gotz nuff package definitions fo' both \f(CW\*(C`Something::Plugin::Foo\*(C'\fR n' 
\&\f(CW\*(C`Something::Plugin::Bar\*(C'\fR then as long as you either have either 
the \fBrequire\fR or \fBinstantiate\fR option set then we'll also find 
\&\f(CW\*(C`Something::Plugin::Bar\*(C'\fR. Nifty!
.SH "OPTIONS"
.IX Header "OPTIONS"
Yo ass can pass a hash of options when importin dis module.
.PP
Da options can be ...
.SS "sub_name"
.IX Subsection "sub_name"
Da name of tha subroutine ta create up in yo' namespace.
.PP
By default dis is 'plugins'
.SS "search_path"
.IX Subsection "search_path"
An array ref of namespaces ta look in.
.SS "search_dirs"
.IX Subsection "search_dirs"
An array ref of directories ta look up in before \f(CW@INC\fR.
.SS "instantiate"
.IX Subsection "instantiate"
Call dis method on tha class. In general dis will probably be 'new'
but it can be whatever you want. Whatever arguments is passed ta 'plugins' 
will be passed ta tha method.
.PP
Da default is 'undef' i.e just return tha class name.
.SS "require"
.IX Subsection "require"
Just require tha class, don't instantiate (overrides 'instantiate');
.SS "inner"
.IX Subsection "inner"
If set ta 0 will \fBnot\fR search inner packages. 
If set ta 1 will override \f(CW\*(C`require\*(C'\fR.
.SS "only"
.IX Subsection "only"
Takes a string, array ref or regex describin tha namez of tha only plugins ta 
return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Whilst dis may seem perverse ... well, it is. But it also 
makes sense. Trust mah dirty ass.
.SS "except"
.IX Subsection "except"
Similar ta \f(CW\*(C`only\*(C'\fR it takes a thugged-out description of plugins ta exclude 
from returning. This is slightly less perverse.
.SS "package"
.IX Subsection "package"
This is fo' use by extension modulez which build on \f(CW\*(C`Module::Pluggable\*(C'\fR:
passin a \f(CW\*(C`package\*(C'\fR option allows you ta place tha plugin method up in a
different package other than yo' own.
.SS "file_regex"
.IX Subsection "file_regex"
By default \f(CW\*(C`Module::Pluggable\*(C'\fR only looks fo' \fI.pm\fR files.
.PP
By supplyin a freshly smoked up \f(CW\*(C`file_regex\*(C'\fR then you can chizzle dis behaviour e.g
.PP
.Vb 1
\&    file_regex => qr/\e.plugin$/
.Ve
.SS "include_editor_junk"
.IX Subsection "include_editor_junk"
By default \f(CW\*(C`Module::Pluggable\*(C'\fR ignores filez dat be lookin like they were
left behind by editors. Currently dis means filez endin up in \fI~\fR (~),
the extensions \fI.swp\fR or \fI.swo\fR, or filez beginnin wit \fI.#\fR.
.PP
Settin \f(CW\*(C`include_editor_junk\*(C'\fR chizzlez \f(CW\*(C`Module::Pluggable\*(C'\fR so it do
not ignore any filez it finds.
.SS "follow_symlinks"
.IX Subsection "follow_symlinks"
Whether, when searchin directories, ta follow symlinks.
.PP
Defaults ta 1 i.e do follow symlinks.
.SS "min_depth, max_depth"
.IX Subsection "min_depth, max_depth"
This will allow you ta set what tha fuck 'depth' of plugin is ghon be allowed.
.PP
So, fo' example, \f(CW\*(C`MyClass::Plugin::Foo\*(C'\fR gonna git a thugged-out depth of 3 n' 
\&\f(CW\*(C`MyClass::Plugin::Foo::Bar\*(C'\fR gonna git a thugged-out depth of 4 so ta only git tha forma 
(i.e \f(CW\*(C`MyClass::Plugin::Foo\*(C'\fR) do
.PP
.Vb 2
\&        package MyClass;
\&        use Module::Pluggable max_depth => 3;
.Ve
.PP
and ta only git tha latta (i.e \f(CW\*(C`MyClass::Plugin::Foo::Bar\*(C'\fR)
.PP
.Vb 2
\&        package MyClass;
\&        use Module::Pluggable min_depth => 4;
.Ve
.SH "TRIGGERS"
.IX Header "TRIGGERS"
Various triggers can also be passed up in ta tha options.
.PP
If any of these triggers return 0 then tha plugin aint gonna be returned.
.SS "before_require <plugin>"
.IX Subsection "before_require <plugin>"
Gets passed tha plugin name.
.PP
If 0 is returned then dis plugin aint gonna be required either.
.SS "on_require_error <plugin> <err>"
.IX Subsection "on_require_error <plugin> <err>"
Gets called when there be a a error on requirin tha plugin.
.PP
Gets passed tha plugin name n' tha error.
.PP
Da default on_require_error handlez is ta \f(CW\*(C`carp\*(C'\fR tha error n' return 0.
.SS "on_instantiate_error <plugin> <err>"
.IX Subsection "on_instantiate_error <plugin> <err>"
Gets called when there be a a error on instantiatin tha plugin.
.PP
Gets passed tha plugin name n' tha error.
.PP
Da default on_instantiate_error handlez is ta \f(CW\*(C`carp\*(C'\fR tha error n' return 0.
.SS "after_require <plugin>"
.IX Subsection "after_require <plugin>"
Gets passed tha plugin name.
.PP
If 0 is returned then dis plugin is ghon be required but not returned as a plugin.
.SH "METHODs"
.IX Header "METHODs"
.SS "search_path"
.IX Subsection "search_path"
Da method \f(CW\*(C`search_path\*(C'\fR is exported tha fuck into you namespace as well. 
Yo ass can call dat at any time ta chizzle or replace tha 
search_path.
.PP
.Vb 2
\&    $self\->search_path( add => "New::Path" ); # add
\&    $self\->search_path( freshly smoked up => "New::Path" ); # replace
.Ve
.SH "BEHAVIOUR UNDER TEST ENVIRONMENT"
.IX Header "BEHAVIOUR UNDER TEST ENVIRONMENT"
In order ta make testin reliable we exclude anythang not from blib if blib.pm is 
in \f(CW%INC\fR.
.PP
However if tha module bein tested used another module dat itself used \f(CW\*(C`Module::Pluggable\*(C'\fR 
then tha second module would fail. This was fixed by checkin ta peep if tha calla 
had (^|/)blib/ up in they filename.
.PP
Therez a argument dat dis is tha wack behaviour n' dat modulez should explicitly
trigger dis behaviour but dat particular code has been round fo' 7 muthafuckin years now n' I be 
reluctant ta chizzle tha default behaviour.
.PP
Yo ass can now (az of version 4.1) force Module::Pluggable ta look outside blib up in a test environment by bustin either
.PP
.Vb 3
\&        require Module::Pluggable;
\&        $Module::Pluggable::FORCE_SEARCH_ALL_PATHS = 1;
\&        import Module::Pluggable;
.Ve
.PP
or
.PP
.Vb 1
\&        use Module::Pluggable force_search_all_paths => 1;
.Ve
.SH "FUTURE PLANS"
.IX Header "FUTURE PLANS"
This do every last muthafuckin thang I need n' I can't straight-up be thinkin of any other 
features I wanna add. Y'all KNOW dat shit, muthafucka! Hyped last lyrics of course
.PP
Recently tried fixed ta find inner packages n' ta make it 
\&'just work' wit \s-1PAR\s0 but there be still some issues.
.PP
However suggestions (and patches) is welcome.
.SH "DEVELOPMENT"
.IX Header "DEVELOPMENT"
Da masta repo fo' dis module be at
.PP
https://github.com/simonwistow/Module\-Pluggable
.SH "AUTHOR"
.IX Header "AUTHOR"
Semen Wistow <simon@thegestalt.org>
.SH "COPYING"
.IX Header "COPYING"
Copyright, 2006 Semen Wistow
.PP
Distributed under tha same terms as Perl itself.
.SH "BUGS"
.IX Header "BUGS"
None known.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::Spec, File::Find, File::Basename, Class::Factory::Util, Module::Pluggable::Ordered
