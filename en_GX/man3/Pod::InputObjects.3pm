.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::InputObjects 3"
.TH Pod::InputObjects 3 "2013-06-01" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::InputObjects \- objects representin POD input paragraphs, commands, etc.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Pod::InputObjects;
.Ve
.SH "REQUIRES"
.IX Header "REQUIRES"
perl5.004, Carp
.SH "EXPORTS"
.IX Header "EXPORTS"
Nothing.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module defines some basic input objects used by \fBPod::Parser\fR when
readin n' parsin \s-1POD\s0 text from a input source. Da followin objects
are defined:
.IP "package \fBPod::Paragraph\fR" 4
.IX Item "package Pod::Paragraph"
An object correspondin ta a paragraph of \s-1POD\s0 input text. Well shiiiit, it may be a
plain paragraph, a verbatim paragraph, or a cold-ass lil command paragraph (see
perlpod).
.IP "package \fBPod::InteriorSequence\fR" 4
.IX Item "package Pod::InteriorSequence"
An object correspondin ta a interior sequence command from tha \s-1POD\s0
input text (see perlpod).
.IP "package \fBPod::ParseTree\fR" 4
.IX Item "package Pod::ParseTree"
An object correspondin ta a tree of parsed \s-1POD\s0 text. Each \*(L"node\*(R" in
a parse-tree (or \fIptree\fR) is either a text-strin or a reference to
a \fBPod::InteriorSequence\fR object. Da nodes step tha fuck up in tha parse-tree
in tha order up in which they was parsed from left-to-right.
.PP
Each of these input objects is busted lyrics bout up in further detail up in the
sections which follow.
.SH "\fBPod::Paragraph\fP"
.IX Header "Pod::Paragraph"
An object representin a paragraph of \s-1POD\s0 input text.
It has tha followin methods/attributes:
.SS "Pod::Paragraph\->\fB\fP\f(BInew()\fP\fB\fP"
.IX Subsection "Pod::Paragraph->new()"
.Vb 10
\&        mah $pod_para1 = Pod::Paragraph\->new(\-text => $text);
\&        mah $pod_para2 = Pod::Paragraph\->new(\-name => $cmd,
\&                                            \-text => $text);
\&        mah $pod_para3 = freshly smoked up Pod::Paragraph(\-text => $text);
\&        mah $pod_para4 = freshly smoked up Pod::Paragraph(\-name => $cmd,
\&                                           \-text => $text);
\&        mah $pod_para5 = Pod::Paragraph\->new(\-name => $cmd,
\&                                            \-text => $text,
\&                                            \-file => $filename,
\&                                            \-line => $line_number);
.Ve
.PP
This be a cold-ass lil class method dat constructs a \f(CW\*(C`Pod::Paragraph\*(C'\fR object and
returns a reference ta tha freshly smoked up paragraph object. Well shiiiit, it may be given one or
two keyword arguments, n' you can put dat on yo' toast. Da \f(CW\*(C`\-text\*(C'\fR keyword indicates tha corresponding
text of tha \s-1POD\s0 paragraph. Da \f(CW\*(C`\-name\*(C'\fR keyword indicates tha name of
the correspondin \s-1POD\s0 command, like fuckin \f(CW\*(C`head1\*(C'\fR or \f(CW\*(C`item\*(C'\fR (it should
\&\fInot\fR contain tha \f(CW\*(C`=\*(C'\fR prefix); dis is needed only if tha \s-1POD\s0
paragraph correspondz ta a cold-ass lil command paragraph. Da \f(CW\*(C`\-file\*(C'\fR n' \f(CW\*(C`\-line\*(C'\fR
keywordz indicate tha filename n' line number correspondin ta the
beginnin of tha paragraph
.ie n .SS "$pod_para\->\fB\fP\f(BIcmd_name()\fP\fB\fP"
.el .SS "\f(CW$pod_para\fP\->\fB\fP\f(BIcmd_name()\fP\fB\fP"
.IX Subsection "$pod_para->cmd_name()"
.Vb 1
\&        mah $para_cmd = $pod_para\->cmd_name();
.Ve
.PP
If dis paragraph be a cold-ass lil command paragraph, then dis method will return 
the name of tha command (\fIwithout\fR any leadin \f(CW\*(C`=\*(C'\fR prefix).
.ie n .SS "$pod_para\->\fB\fP\f(BItext()\fP\fB\fP"
.el .SS "\f(CW$pod_para\fP\->\fB\fP\f(BItext()\fP\fB\fP"
.IX Subsection "$pod_para->text()"
.Vb 1
\&        mah $para_text = $pod_para\->text();
.Ve
.PP
This method will return tha correspondin text of tha paragraph.
.ie n .SS "$pod_para\->\fB\fP\f(BIraw_text()\fP\fB\fP"
.el .SS "\f(CW$pod_para\fP\->\fB\fP\f(BIraw_text()\fP\fB\fP"
.IX Subsection "$pod_para->raw_text()"
.Vb 1
\&        mah $raw_pod_para = $pod_para\->raw_text();
.Ve
.PP
This method will return tha \fIraw\fR text of tha \s-1POD\s0 paragraph, exactly
as it rocked up in tha input.
.ie n .SS "$pod_para\->\fB\fP\f(BIcmd_prefix()\fP\fB\fP"
.el .SS "\f(CW$pod_para\fP\->\fB\fP\f(BIcmd_prefix()\fP\fB\fP"
.IX Subsection "$pod_para->cmd_prefix()"
.Vb 1
\&        mah $prefix = $pod_para\->cmd_prefix();
.Ve
.PP
If dis paragraph be a cold-ass lil command paragraph, then dis method will return 
the prefix used ta denote tha command (which should be tha strang \*(L"=\*(R"
or \*(L"==\*(R").
.ie n .SS "$pod_para\->\fB\fP\f(BIcmd_separator()\fP\fB\fP"
.el .SS "\f(CW$pod_para\fP\->\fB\fP\f(BIcmd_separator()\fP\fB\fP"
.IX Subsection "$pod_para->cmd_separator()"
.Vb 1
\&        mah $separator = $pod_para\->cmd_separator();
.Ve
.PP
If dis paragraph be a cold-ass lil command paragraph, then dis method will return
the text used ta separate tha command name from tha rest of the
paragraph (if any).
.ie n .SS "$pod_para\->\fB\fP\f(BIparse_tree()\fP\fB\fP"
.el .SS "\f(CW$pod_para\fP\->\fB\fP\f(BIparse_tree()\fP\fB\fP"
.IX Subsection "$pod_para->parse_tree()"
.Vb 3
\&        mah $ptree = $pod_parser\->parse_text( $pod_para\->text() );
\&        $pod_para\->parse_tree( $ptree );
\&        $ptree = $pod_para\->parse_tree();
.Ve
.PP
This method will get/set tha correspondin parse-tree of tha paragraphz text.
.ie n .SS "$pod_para\->\fB\fP\f(BIfile_line()\fP\fB\fP"
.el .SS "\f(CW$pod_para\fP\->\fB\fP\f(BIfile_line()\fP\fB\fP"
.IX Subsection "$pod_para->file_line()"
.Vb 2
\&        mah ($filename, $line_number) = $pod_para\->file_line();
\&        mah $posizzle = $pod_para\->file_line();
.Ve
.PP
Returns tha current filename n' line number fo' tha paragraph
object.  If called up in a list context, it returns a list of two
elements: first tha filename, then tha line number n' shit. If called in
a scalar context, it returns a strang containin tha filename, followed
by a cold-ass lil colon (':'), followed by tha line number.
.SH "\fBPod::InteriorSequence\fP"
.IX Header "Pod::InteriorSequence"
An object representin a \s-1POD\s0 interior sequence command.
It has tha followin methods/attributes:
.SS "Pod::InteriorSequence\->\fB\fP\f(BInew()\fP\fB\fP"
.IX Subsection "Pod::InteriorSequence->new()"
.Vb 8
\&        mah $pod_seq1 = Pod::InteriorSequence\->new(\-name => $cmd
\&                                                  \-ldelim => $delimiter);
\&        mah $pod_seq2 = freshly smoked up Pod::InteriorSequence(\-name => $cmd,
\&                                                 \-ldelim => $delimiter);
\&        mah $pod_seq3 = freshly smoked up Pod::InteriorSequence(\-name => $cmd,
\&                                                 \-ldelim => $delimiter,
\&                                                 \-file => $filename,
\&                                                 \-line => $line_number);
\&
\&        mah $pod_seq4 = freshly smoked up Pod::InteriorSequence(\-name => $cmd, $ptree);
\&        mah $pod_seq5 = freshly smoked up Pod::InteriorSequence($cmd, $ptree);
.Ve
.PP
This be a cold-ass lil class method dat constructs a \f(CW\*(C`Pod::InteriorSequence\*(C'\fR object
and returns a reference ta tha freshly smoked up interior sequence object. Well shiiiit, it should
be given two keyword arguments, n' you can put dat on yo' toast.  Da \f(CW\*(C`\-ldelim\*(C'\fR keyword indicates the
correspondin left-delimita of tha interior sequence (e.g. '<').
Da \f(CW\*(C`\-name\*(C'\fR keyword indicates tha name of tha correspondin interior
sequence command, like fuckin \f(CW\*(C`I\*(C'\fR or \f(CW\*(C`B\*(C'\fR or \f(CW\*(C`C\*(C'\fR. Da \f(CW\*(C`\-file\*(C'\fR and
\&\f(CW\*(C`\-line\*(C'\fR keywordz indicate tha filename n' line number corresponding
to tha beginnin of tha interior sequence. If tha \f(CW$ptree\fR argument is
given, it must be tha last argument, n' it must be either string, or
else a array-ref suitable fo' passin ta \fBPod::ParseTree::new\fR (or
it may be a reference ta a Pod::ParseTree object).
.ie n .SS "$pod_seq\->\fB\fP\f(BIcmd_name()\fP\fB\fP"
.el .SS "\f(CW$pod_seq\fP\->\fB\fP\f(BIcmd_name()\fP\fB\fP"
.IX Subsection "$pod_seq->cmd_name()"
.Vb 1
\&        mah $seq_cmd = $pod_seq\->cmd_name();
.Ve
.PP
Da name of tha interior sequence command.
.ie n .SS "$pod_seq\->\fB\fP\f(BIprepend()\fP\fB\fP"
.el .SS "\f(CW$pod_seq\fP\->\fB\fP\f(BIprepend()\fP\fB\fP"
.IX Subsection "$pod_seq->prepend()"
.Vb 2
\&        $pod_seq\->prepend($text);
\&        $pod_seq1\->prepend($pod_seq2);
.Ve
.PP
Prependz tha given strang or parse-tree or sequence object ta tha parse-tree
of dis interior sequence.
.ie n .SS "$pod_seq\->\fB\fP\f(BIappend()\fP\fB\fP"
.el .SS "\f(CW$pod_seq\fP\->\fB\fP\f(BIappend()\fP\fB\fP"
.IX Subsection "$pod_seq->append()"
.Vb 2
\&        $pod_seq\->append($text);
\&        $pod_seq1\->append($pod_seq2);
.Ve
.PP
Appendz tha given strang or parse-tree or sequence object ta tha parse-tree
of dis interior sequence.
.ie n .SS "$pod_seq\->\fB\fP\f(BInested()\fP\fB\fP"
.el .SS "\f(CW$pod_seq\fP\->\fB\fP\f(BInested()\fP\fB\fP"
.IX Subsection "$pod_seq->nested()"
.Vb 1
\&        $outer_seq = $pod_seq\->nested || print "not nested";
.Ve
.PP
If dis interior sequence is nested inside of another interior
sequence, then tha outer/parent sequence dat gotz nuff it is
returned. Y'all KNOW dat shit, muthafucka! Otherwise \f(CW\*(C`undef\*(C'\fR is returned.
.ie n .SS "$pod_seq\->\fB\fP\f(BIraw_text()\fP\fB\fP"
.el .SS "\f(CW$pod_seq\fP\->\fB\fP\f(BIraw_text()\fP\fB\fP"
.IX Subsection "$pod_seq->raw_text()"
.Vb 1
\&        mah $seq_raw_text = $pod_seq\->raw_text();
.Ve
.PP
This method will return tha \fIraw\fR text of tha \s-1POD\s0 interior sequence,
exactly as it rocked up in tha input.
.ie n .SS "$pod_seq\->\fB\fP\f(BIleft_delimiter()\fP\fB\fP"
.el .SS "\f(CW$pod_seq\fP\->\fB\fP\f(BIleft_delimiter()\fP\fB\fP"
.IX Subsection "$pod_seq->left_delimiter()"
.Vb 1
\&        mah $ldelim = $pod_seq\->left_delimiter();
.Ve
.PP
Da leftmost delimita beginnin tha argument text ta tha interior
sequence (should be \*(L"<\*(R").
.ie n .SS "$pod_seq\->\fB\fP\f(BIright_delimiter()\fP\fB\fP"
.el .SS "\f(CW$pod_seq\fP\->\fB\fP\f(BIright_delimiter()\fP\fB\fP"
.IX Subsection "$pod_seq->right_delimiter()"
Da rightmost delimita beginnin tha argument text ta tha interior
sequence (should be \*(L">\*(R").
.ie n .SS "$pod_seq\->\fB\fP\f(BIparse_tree()\fP\fB\fP"
.el .SS "\f(CW$pod_seq\fP\->\fB\fP\f(BIparse_tree()\fP\fB\fP"
.IX Subsection "$pod_seq->parse_tree()"
.Vb 3
\&        mah $ptree = $pod_parser\->parse_text($paragraph_text);
\&        $pod_seq\->parse_tree( $ptree );
\&        $ptree = $pod_seq\->parse_tree();
.Ve
.PP
This method will get/set tha correspondin parse-tree of tha interior
sequencez text.
.ie n .SS "$pod_seq\->\fB\fP\f(BIfile_line()\fP\fB\fP"
.el .SS "\f(CW$pod_seq\fP\->\fB\fP\f(BIfile_line()\fP\fB\fP"
.IX Subsection "$pod_seq->file_line()"
.Vb 2
\&        mah ($filename, $line_number) = $pod_seq\->file_line();
\&        mah $posizzle = $pod_seq\->file_line();
.Ve
.PP
Returns tha current filename n' line number fo' tha interior sequence
object.  If called up in a list context, it returns a list of two
elements: first tha filename, then tha line number n' shit. If called in
a scalar context, it returns a strang containin tha filename, followed
by a cold-ass lil colon (':'), followed by tha line number.
.SS "Pod::InteriorSequence::\fB\s-1\fP\f(BIDESTROY\s0()\fP\fB\fP"
.IX Subsection "Pod::InteriorSequence::DESTROY()"
This method performs any necessary cleanup fo' tha interior-sequence.
If you override dis method then it is \fBimperative\fR dat you invoke
the parent method from within yo' own method, otherwise
\&\fIinterior-sequence storage aint gonna be reclaimed upon destruction!\fR
.SH "\fBPod::ParseTree\fP"
.IX Header "Pod::ParseTree"
This object correspondz ta a tree of parsed \s-1POD\s0 text fo' realz. As \s-1POD\s0 text is
scanned from left ta right, it is parsed tha fuck into a ordered list of
text-strings n' \fBPod::InteriorSequence\fR objects (in order of
appearance) fo' realz. A \fBPod::ParseTree\fR object correspondz ta dis list of
strings n' sequences. Each interior sequence up in tha parse-tree may
itself contain a parse-tree (since interior sequences may be nested).
.SS "Pod::ParseTree\->\fB\fP\f(BInew()\fP\fB\fP"
.IX Subsection "Pod::ParseTree->new()"
.Vb 4
\&        mah $ptree1 = Pod::ParseTree\->new;
\&        mah $ptree2 = freshly smoked up Pod::ParseTree;
\&        mah $ptree4 = Pod::ParseTree\->new($array_ref);
\&        mah $ptree3 = freshly smoked up Pod::ParseTree($array_ref);
.Ve
.PP
This be a cold-ass lil class method dat constructs a \f(CW\*(C`Pod::Parse_tree\*(C'\fR object and
returns a reference ta tha freshly smoked up parse-tree. If a single-argument is given,
it must be a reference ta a array, n' is used ta initialize tha root
(top) of tha parse tree.
.ie n .SS "$ptree\->\fB\fP\f(BItop()\fP\fB\fP"
.el .SS "\f(CW$ptree\fP\->\fB\fP\f(BItop()\fP\fB\fP"
.IX Subsection "$ptree->top()"
.Vb 3
\&        mah $top_node = $ptree\->top();
\&        $ptree\->top( $top_node );
\&        $ptree\->top( @lil pimps );
.Ve
.PP
This method gets/sets tha top node of tha parse-tree. If no arguments are
given, it returns tha topmost node up in tha tree (the root), which be also
a \fBPod::ParseTree\fR. If it is given a single argument dat be a reference,
then tha reference be assumed ta a parse-tree n' becomes tha freshly smoked up top node.
Otherwise, if arguments is given, they is treated as tha freshly smoked up list of
lil pimps fo' tha top node.
.ie n .SS "$ptree\->\fB\fP\f(BIchildren()\fP\fB\fP"
.el .SS "\f(CW$ptree\fP\->\fB\fP\f(BIchildren()\fP\fB\fP"
.IX Subsection "$ptree->children()"
This method gets/sets tha lil pimpz of tha top node up in tha parse-tree.
If no arguments is given, it returns tha list (array) of children
(each of which should be either a strang or a \fBPod::InteriorSequence\fR.
Otherwise, if arguments is given, they is treated as tha freshly smoked up list of
lil pimps fo' tha top node.
.ie n .SS "$ptree\->\fB\fP\f(BIprepend()\fP\fB\fP"
.el .SS "\f(CW$ptree\fP\->\fB\fP\f(BIprepend()\fP\fB\fP"
.IX Subsection "$ptree->prepend()"
This method prependz tha given text or parse-tree ta tha current parse-tree.
If tha straight-up original gangsta item on tha parse-tree is text n' tha argument be also text,
then tha text is prepended ta tha straight-up original gangsta item (not added as a separate string).
Otherwise tha argument be added as a freshly smoked up strang or parse-tree \fIbefore\fR
the current one.
.ie n .SS "$ptree\->\fB\fP\f(BIappend()\fP\fB\fP"
.el .SS "\f(CW$ptree\fP\->\fB\fP\f(BIappend()\fP\fB\fP"
.IX Subsection "$ptree->append()"
This method appendz tha given text or parse-tree ta tha current parse-tree.
If tha last item on tha parse-tree is text n' tha argument be also text,
then tha text be appended ta tha last item (not added as a separate string).
Otherwise tha argument be added as a freshly smoked up strang or parse-tree \fIafter\fR
the current one.
.ie n .SS "$ptree\->\fB\fP\f(BIraw_text()\fP\fB\fP"
.el .SS "\f(CW$ptree\fP\->\fB\fP\f(BIraw_text()\fP\fB\fP"
.IX Subsection "$ptree->raw_text()"
.Vb 1
\&        mah $ptree_raw_text = $ptree\->raw_text();
.Ve
.PP
This method will return tha \fIraw\fR text of tha \s-1POD\s0 parse-tree
exactly as it rocked up in tha input.
.SS "Pod::ParseTree::\fB\s-1\fP\f(BIDESTROY\s0()\fP\fB\fP"
.IX Subsection "Pod::ParseTree::DESTROY()"
This method performs any necessary cleanup fo' tha parse-tree.
If you override dis method then it is \fBimperative\fR
that you invoke tha parent method from within yo' own method,
otherwise \fIparse-tree storage aint gonna be reclaimed upon destruction!\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBPod::InputObjects\fR is part of tha Pod::Parser distribution.
.PP
See Pod::Parser, Pod::Select
.SH "AUTHOR"
.IX Header "AUTHOR"
Please report bugs rockin <http://rt.cpan.org>.
.PP
Brad Appleton <bradapp@enteract.com>
