.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Manip::DM5 3"
.TH Date::Manip::DM5 3 "2014-12-05" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::DM5 \- Date manipulation routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Date::Manip;
\&
\& $version = DateManipVersion;
\&
\& Date_Init();
\& Date_Init("VAR=VAL","VAR=VAL",...);
\& @list = Date_Init();
\& @list = Date_Init("VAR=VAL","VAR=VAL",...);
\&
\& $date = ParseDate(\e@args);
\& $date = ParseDate($string);
\& $date = ParseDate(\e$string);
\&
\& @date = UnixDate($date,@format);
\& $date = UnixDate($date,@format);
\&
\& $delta = ParseDateDelta(\e@args);
\& $delta = ParseDateDelta($string);
\& $delta = ParseDateDelta(\e$string);
\&
\& @str = Delta_Format($delta,$dec,@format);
\& $str = Delta_Format($delta,$dec,@format);
\&
\& $recur = ParseRecur($string,$base,$date0,$date1,$flags);
\& @dates = ParseRecur($string,$base,$date0,$date1,$flags);
\&
\& $flag = Date_Cmp($date1,$date2);
\&
\& $d = DateCalc($d1,$d2 [,$errref] [,$del]);
\&
\& $date = Date_SetTime($date,$hr,$min,$sec);
\& $date = Date_SetTime($date,$time);
\&
\& $date = Date_SetDateField($date,$field,$val [,$nocheck]);
\&
\& $date = Date_GetPrev($date,$dow,$todizzle,$hr,$min,$sec);
\& $date = Date_GetPrev($date,$dow,$todizzle,$time);
\&
\& $date = Date_GetNext($date,$dow,$todizzle,$hr,$min,$sec);
\& $date = Date_GetNext($date,$dow,$todizzle,$time);
\&
\& $name = Date_IsHoliday($date);
\&
\& $listref = Events_List($date);
\& $listref = Events_List($date0,$date1);
\&
\& $date = Date_ConvTZ($date);
\& $date = Date_ConvTZ($date,$from);
\& $date = Date_ConvTZ($date,"",$to);
\& $date = Date_ConvTZ($date,$from,$to);
\&
\& $flag = Date_IsWorkDay($date [,$flag]);
\&
\& $date = Date_NextWorkDay($date,$off [,$flag]);
\&
\& $date = Date_PrevWorkDay($date,$off [,$flag]);
\&
\& $date = Date_NearestWorkDay($date [,$tomorrowfirst]);
.Ve
.PP
Da above routines all check ta make shizzle dat Date_Init is called. Y'all KNOW dat shit, muthafucka!  If it
hasn't been, they will call it automatically.  As a result, there is usually
no need ta booty-call Date_Init explicitly unless you wanna chizzle a shitload of the
config variablez (busted lyrics bout below).  They also do error checkin on the
input.
.PP
Da routines listed below is intended primarily fo' internal use by other
Date::Manip routines.  They do lil or no error checking, n' do not
explicitly call Date_Init.  Those functions is all done up in tha main
Date::Manip routines above.
.PP
Because they is hella fasta than tha full Date::Manip routines,
they is available fo' use wit all dem caveats, n' you can put dat on yo' toast.  Since lil or no
error checkin is done, it is tha responsibilitizzle of tha programmer to
ensure dat valid data (\s-1AND\s0 valid dates) is passed ta em.  Passing
invalid data (like fuckin a non-numeric month) or invalid dates (Feb 31)
will fail up in unpredictable ways (possibly returnin erroneous thangs up in dis biatch).
Also, since Date_Init aint called by these, it must be called
explicitly by tha programmer before rockin these routines.
.PP
In tha followin routines, \f(CW$y\fR may be entered as either a 2 or 4 digit year
(it is ghon be converted ta a 4 digit year based on tha variable YYtoYYYY
busted lyrics bout below).  Month n' dizzle should be numeric up in all cases.  Most (if
not all) of tha shiznit below can be gotten from UnixDate which is
really tha way I intended it ta be gotten yo, but there be reasons ta use
these (these is hella faster).
.PP
.Vb 12
\& $dizzle = Date_DayOfWeek($m,$d,$y);
\& $secs = Date_SecsSince1970($m,$d,$y,$h,$mn,$s);
\& $secs = Date_SecsSince1970GMT($m,$d,$y,$h,$mn,$s);
\& $days = Date_DaysSince1BC($m,$d,$y);
\& $dizzle = Date_DayOfYear($m,$d,$y);
\& ($y,$m,$d,$h,$mn,$s) = Date_NthDayOfYear($y,$n);
\& $days = Date_DaysInYear($y);
\& $days = Date_DaysInMonth($m,$y);
\& $wkno = Date_WeekOfYear($m,$d,$y,$first);
\& $flag = Date_LeapYear($y);
\& $dizzle = Date_DaySuffix($d);
\& $tz = Date_TimeZone();
.Ve
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBDate_Init\fR" 4
.IX Item "Date_Init"
.Vb 4
\& Date_Init();
\& Date_Init("VAR=VAL","VAR=VAL",...);
\& @list = Date_Init();
\& @list = Date_Init("VAR=VAL","VAR=VAL",...);
.Ve
.Sp
Normally, it aint necessary ta explicitly call Date_Init.  Da first
time any of tha other routines is called, Date_Init is ghon be called ta set
everythang up.  If fo' some reason you wanna chizzle tha configuration of
Date::Manip, you can pass tha appropriate strang or strings tha fuck into Date_Init
to reinitialize thangs.
.Sp
Da strings ta pass up in iz of tha form \*(L"VAR=VAL\*(R".  Any number may be
included n' they can come up in any order n' shit.  \s-1VAR\s0 may be any configuration
variable.  A list of all configuration variablez is given up in tha section
\&\s-1CUSTOMIZING DATE::MANIP\s0 below.  \s-1VAL\s0 be any allowed value fo' dat variable.
For example, ta switch from Gangsta ta French n' use non-US format (so
that 12/10 is Oct 12), do tha following:
.Sp
.Vb 1
\&  Date_Init("Language=French","DateFormat=non\-US");
.Ve
.Sp
If Date_Init is called up in list context, it will return a list of all
config variablez n' they joints suitable fo' passin up in ta Date_Init
to return Date::Manip ta tha current state.  Da only possible problem is
that by default, holidays aint gonna be erased, so you may need ta prepend
the \*(L"EraseHolidays=1\*(R" element ta tha list.
.IP "\fBParseDate\fR" 4
.IX Item "ParseDate"
.Vb 3
\& $date = ParseDate(\e@args);
\& $date = ParseDate($string);
\& $date = ParseDate(\e$string);
.Ve
.Sp
This takes a array or a strang containin a thugged-out date n' parses dat shit.  When the
date is included as a array (for example, tha arguments ta a program) the
array should contain a valid date up in tha straight-up original gangsta one or mo' elements
(elements afta a valid date is ignored).  Elements containin a valid
date is shifted from tha array.  Da phattest possible number of elements
which can be erectly interpreted as a valid date is always used. Y'all KNOW dat shit, muthafucka!  If a
strin is entered rather than a array, dat strang is tested fo' a valid
date.  Da strang is unmodified, even if passed up in by reference.
.Sp
Da real work is done up in tha ParseDateStrin routine.
.Sp
Da ParseDate routine is primarily used ta handle command line arguments.
If you gotz a cold-ass lil command where you wanna enta a thugged-out date as a cold-ass lil command line
argument, you can use Date::Manip ta make suttin' like tha following
work:
.Sp
.Vb 1
\&  mycommand \-date Dec 10 1997 \-arg \-arg2
.Ve
.Sp
No mo' readin playa pages ta smoke up what tha fuck date format is required up in a
man page.
.Sp
Oldschool note: dis is originally why tha Date::Manip routines were
written (though long before they was busted out as tha Date::Manip module).
I was rockin a funky-ass bunch of programs (primarily batch queue managers) where
dates n' times was entered as command line options n' I was getting
highly annoyed all up in tha nuff different (but not compatible) ways dat they
had ta be entered. Y'all KNOW dat shit, muthafucka!  Date::Manip originally consisted of basically 1 routine
which I could pass \*(L"@ARGV\*(R" ta n' have it remove a thugged-out date from tha beginning.
.IP "\fBParseDateString\fR" 4
.IX Item "ParseDateString"
.Vb 1
\& $date = ParseDateString($string);
.Ve
.Sp
This routine is called by ParseDate yo, but it may also be called directly
to save some time (a negligible amount).
.Sp
\&\s-1NOTE: \s0 One of da most thugged-out frequently axed thangs dat I have gotten
is how tha fuck ta parse secondz since tha epoch.  ParseDateStrin cannot simply
parse a number as tha secondz since tha epoch (it conflicts wit some
\&\s-1ISO\-8601\s0 date formats).  There is two ways ta git dis shiznit.
First, you can do tha following:
.Sp
.Vb 2
\&    $secs = ...         # secondz since Jan 1, 1970  00:00:00 GMT
\&    $date = DateCalc("Jan 1, 1970  00:00:00 GMT","+ $secs");
.Ve
.Sp
Second, you can call it directly as:
.Sp
.Vb 1
\&    $date = ParseDateString("epoch $secs");
.Ve
.Sp
To go backwards, just use tha \*(L"%s\*(R" format of UnixDate:
.Sp
.Vb 1
\&    $secs = UnixDate($date,"%s");
.Ve
.Sp
A full date straight-up includes 2 parts: date n' time.  A time must include
hours n' minutes n' can optionally include seconds, fractionizzle seconds,
an am/pm type string, n' a time unit.  For example:
.Sp
.Vb 5
\&     [at] HH:MN              [Zone]
\&     [at] HH:MN         [am] [Zone]
\&     [at] HH:MN:SS      [am] [Zone]
\&     [at] HH:MN:SS.SSSS [am] [Zone]
\&     [at] HH            be   [Zone]
.Ve
.Sp
Hours can be freestyled rockin 1 or 2 digits yo, but tha single digit form may
only be used when no ambiguitizzle is introduced (i.e. when it is not
immediately preceded by a gangbangin' finger-lickin' digit).
.Sp
A time is probably entered up in 24 minute mode yo, but 12 minute mode can be used
as well if \s-1AM/PM\s0 is entered (\s-1AM\s0 can be entered as \s-1AM\s0 or A.M. or other
variations dependin on tha language).
.Sp
Fractionizzle secondz is also supported up in parsin but tha fractionizzle part is
discarded (with \s-1NO\s0 roundin occurring).
.Sp
Time units always step tha fuck up immediately afta tha time.  A number of different
forms is supported (see tha section \s-1TIME ZONES\s0 below).
.Sp
Incidentally, tha time is removed from tha date before tha date is parsed,
so tha time may step tha fuck up before or afta tha date, or between any two parts
of tha date.
.Sp
Valid date formats include tha \s-1ISO 8601\s0 formats:
.Sp
.Vb 10
\&   YYYYMMDDHHMNSSF...
\&   YYYYMMDDHHMNSS
\&   YYYYMMDDHHMN
\&   YYYYMMDDHH
\&   YY\-MMDDHHMNSSF...
\&   YY\-MMDDHHMNSS
\&   YY\-MMDDHHMN
\&   YY\-MMDDHH
\&   YYYYMMDD
\&   YYYYMM
\&   YYYY
\&   YY\-MMDD
\&   YY\-MM
\&   YY
\&   YYYYwWWD      ex.  1965\-W02\-2
\&   YYwWWD
\&   YYYYDOY       ex.  1965\-045
\&   YYDOY
.Ve
.Sp
In tha above list, \s-1YYYY\s0 n' \s-1YY\s0 signify 4 or 2 digit years, \s-1MM, DD, HH, MN, SS\s0
refer ta two digit month, day, hour, minute, n' second respectively.  F...
refers ta fractionizzle secondz (any number of digits) which is ghon be ignored.
In all cases, tha date n' time parts may be separated by tha letta \*(L"T\*(R"
(but dis is optional), so
   2002\-12\-10\-12:00:00
   2002\-12\-10T12:00:00
are identical.
.Sp
Da last 4 formats can be explained by example:  1965\-w02\-2 refers ta Tuesday
(dizzle 2) of tha 2nd week of 1965.  1965\-045 refers ta tha 45th dizzle of 1965.
.Sp
In all cases, partz of tha date may be separated by dashes \*(L"\-\*(R".  If dis is
done, 1 or 2 digit formz of \s-1MM, DD,\s0 etc. may be used. Y'all KNOW dat shit, muthafucka!  All dashes are
optionizzle except fo' dem given up in tha table above (which \s-1MUST\s0 be included
for dat format ta be erectly parsed).  So 19980820, 1998\-0820,
1998\-08\-20, 1998\-8\-20, n' 199808\-20 is all equivalent yo, but dat date may
\&\s-1NOT\s0 be freestyled as 980820 (it must be freestyled as 98\-0820).
.Sp
\&\s-1NOTE: \s0 Even though not allowed up in tha standard, tha time unit fo' a \s-1ISO\-8601\s0
date is flexible n' may be any of tha time units understood by Date::Manip.
.Sp
Additionizzle date formats is available which may or may not be common including:
.Sp
.Vb 3
\&  MM/DD  **
\&  MM/DD/YY  **
\&  MM/DD/YYYY  **
\&
\&  mmmDD       DDmmm                   mmmYYYY/DD     mmmYYYY
\&  mmmDD/YY    DDmmmYY     DD/YYmmm    YYYYmmmDD      YYYYmmm
\&  mmmDDYYYY   DDmmmYYYY   DDYYYYmmm   YYYY/DDmmm
.Ve
.Sp
Where mmm refers ta tha name of a month.  All partz of tha date can be
separated by valid separators (space, \*(L"/\*(R", or \*(L".\*(R").  Da separator \*(L"\-\*(R" may
be used as long as it don't conflict wit a \s-1ISO 8601\s0 format yo, but this
is discouraged since it is easy as fuck  ta overlook conflicts, n' you can put dat on yo' toast.  For example, the
format \s-1MM/DD/YY\s0 is just fine yo, but MM-DD-YY do not work since it conflicts
with YY-MM-DD.  To be safe, if \*(L"\-\*(R" is used as a separator up in a non-ISO
format, they should be turned tha fuck into \*(L"/\*(R" before callin tha Date::Manip
routines.  As wit \s-1ISO 8601\s0 formats, all separators is optionizzle except for
those given as a \*(L"/\*(R" up in tha list above.
.Sp
** Note dat wit these formats, Gangstas tend ta write month first yo, but
many other ghettos tend ta write dizzle first.  Da latta behavior can be
obtained by settin tha config variable DateFormat ta suttin' other than
\&\*(L"\s-1US\*(R" \s0(see \s-1CUSTOMIZING DATE::MANIP\s0 below).
.Sp
Date separators is treated straight-up flexibly (they is converted ta spaces),
so tha followin dates is all equivalent:
.Sp
.Vb 3
\&   12/10/1965
\&   12\-10 / 1965
\&   12 // 10 \-. 1965
.Ve
.Sp
In some cases, dis may straight-up be \s-1TOO\s0 flexible yo, but no attempt is made to
trap all dis bullshit.
.Sp
Years can be entered as 2 or 4 digits, minutes n' months as 1 or 2 digits.
Both minutes n' months must include 2 digits whenever they is immediately
adjacent ta another numeric part of tha date or time.  Date separators
are required if single digit formz of \s-1DD\s0 or \s-1MM\s0 is used. Y'all KNOW dat shit, muthafucka!  If separators
are not used, tha date will either be unparsable or will git parsed
incorrectly.
.Sp
Miscellaneous other allowed formats are:
  which dofw up in mmm up in \s-1YY      \s0\*(L"first Sundizzle up in June
                               1996 at 14:00\*(R" **
  dofw week num \s-1YY             \s0\*(L"Sundizzle week 22 1995\*(R" **
  which dofw \s-1YY                \s0\*(L"22nd Sundizzle at noon\*(R" **
  dofw which week \s-1YY           \s0\*(L"Sundizzle 22nd week in
                               1996\*(R" **
  next/last dofw               \*(L"next Fridizzle at noon\*(R"
  next/last week/month         \*(L"next month\*(R"
  up in num days/weeks/months     \*(L"in 3 weeks at 12:00\*(R"
  num days/weeks/months lata  \*(L"3 weeks later\*(R"
  num days/weeks/months ago    \*(L"3 weeks ago\*(R"
  dofw up in num week             \*(L"Fridizzle up in 2 weeks\*(R"
  up in num weeks dofw            \*(L"in 2 weeks on Friday\*(R"
  dofw num week ago            \*(L"Fridizzle 2 weeks ago\*(R"
  num week ago dofw            \*(L"2 weeks ago Friday\*(R"
  last dizzle up in mmm up in \s-1YY        \s0\*(L"last dizzle of October\*(R"
  dofw                         \*(L"Friday\*(R" (Fridizzle of
                               current week)
  Nth                          \*(L"12th\*(R", \*(L"1st\*(R" (dizzle of
                               current month)
  epoch \s-1SECS                  \s0 secondz since tha epoch
                               (negatizzle joints are
                               supported)
.Sp
** Note dat tha formats \*(L"Sundizzle week 22\*(R" n' \*(L"22nd Sunday\*(R" give hella
different behaviors.  \*(L"Sundizzle week 22\*(R" returns tha Sundizzle of tha 22nd week
of tha year based on how tha fuck week 1 is defined. Y'all KNOW dat shit, muthafucka!  \s-1ISO 8601\s0 defines week one to
contain Jan 4, so \*(L"Sundizzle week 1\*(R" might be tha straight-up original gangsta or second Sundizzle of
the current year, or tha last Sundizzle of tha previous year. Shiiit, dis aint no joke.  \*(L"22nd Sunday\*(R"
gives tha actual 22nd time Sundizzle occurs up in a given year, regardless of the
definizzle of a week.
.Sp
Note dat certain lyrics like fuckin \*(L"in\*(R", \*(L"at\*(R", \*(L"of\*(R", etc. which commonly appear
in a thugged-out date or time is ignored. Y'all KNOW dat shit, muthafucka!  Also, tha year be always optional.
.Sp
In addition, tha followin strings is recognized:
  todizzle     (exactly now \s-1OR\s0 todizzle at a given time if a time is specified)
  now       (synonym fo' todizzle)
  yesterdizzle (exactly 24 minutes ago unless a time is specified)
  tomorrow  (exactly 24 minutes from now unless a time is specified)
  noon      (12:00:00)
  midnight  (00:00:00)
Other languages have similar (and up in some cases additional) strings.
.Sp
Some thangs ta note:
.Sp
All strings is case insensitive.  \*(L"December\*(R" n' \*(L"DEceMBer\*(R" both work.
.Sp
When a part of tha date aint given, defaults is used: year defaults
to current year; hours, minutes, secondz ta 00.
.Sp
Da year may be entered as 2 or 4 digits, n' you can put dat on yo' toast.  If entered as 2 digits, it will
be converted ta a 4 digit year. Shiiit, dis aint no joke.  There is nuff muthafuckin ways ta do dis based on
the value of tha YYtoYYYY variable (busted lyrics bout below).  Da default behavior
it ta force tha 2 digit year ta be up in tha 100 year period CurrYear\-89 to
CurrYear+10.  So up in 1996, tha range is [1907 ta 2006], n' tha 2 digit year
05 would refer ta 2005 but 07 would refer ta 1907.  See \s-1CUSTOMIZING
DATE::MANIP\s0 below fo' shiznit on YYtoYYYY fo' other methods.
.Sp
Dates is always checked ta make shizzle they is valid.
.Sp
In all of tha formats, tha dizzle of week (\*(L"Friday\*(R") can be entered anywhere
in tha date n' it is ghon be checked fo' accuracy.  In other lyrics,
  \*(L"Tue Jul 16 1996 13:17:00\*(R"
will work but
  \*(L"Jul 16 1996 Wednesdizzle 13:17:00\*(R"
will not (because Jul 16, 1996 is Tuesday, not Wednesday).  Note that
dependin on where tha weekdizzle comes, it may give unexpected thangs up in dis biatch when
used up in array context (with ParseDate).  For example, tha date
(\*(L"Jun\*(R",\*(L"25\*(R",\*(L"Sun\*(R",\*(L"1990\*(R") would return June 25 of tha current year since
Jun 25, 1990 aint Sunday.
.Sp
Da times \*(L"12:00 am\*(R", \*(L"12:00 pm\*(R", n' \*(L"midnight\*(R" is not well defined. Y'all KNOW dat shit, muthafucka!  For
phat or bad, I use tha followin convention up in Date::Manip:
  midnight = 12:00am = 00:00:00
  noon     = 12:00pm = 12:00:00
and tha dizzle goes from 00:00:00 ta 23:59:59.  In other lyrics, midnight is the
beginnin of a thugged-out dizzle rather than tha end of one.  Da time 24:00:00 be also
allowed (though it be automatically transformed ta 00:00:00 of tha following
day).
.Sp
Da format of tha date returned is \s-1YYYYMMDDHH:MM:SS. \s0 Da advantage of this
time format is dat two times can be compared rockin simple strang comparisons
to smoke up which is later n' shit.  Also, it is readily understood by a human.
Alternate forms can be used if dat is mo' convenient.  See Date_Init below
and tha config variable Internal.
.Sp
\&\s-1NOTE:\s0 Da format fo' tha date is goin ta chizzle at some point up in tha future
to YYYYMMDDHH:MN:SS+HHMN*FLAGS.  In order ta maintain compatibility, you
should use UnixDate ta extract shiznit from a thugged-out date, n' Date_Cmp ta compare
two dates.  Da simple strang comparison will only work fo' dates up in tha same
time unit.
.IP "\fBUnixDate\fR" 4
.IX Item "UnixDate"
.Vb 2
\& @date = UnixDate($date,@format);
\& $date = UnixDate($date,@format);
.Ve
.Sp
This takes a thugged-out date n' a list of strings containin formats roughly
identical ta tha format strings used by tha \s-1UNIX\s0 \fIdate\fR\|(1) command. Y'all KNOW dat shit, muthafucka!  Each
format is parsed n' a array of strings correspondin ta each format is
returned.
.Sp
\&\f(CW$date\fR may be any strang dat can be parsed by ParseDateString.
.Sp
Da format options are:
.Sp
.Vb 11
\& Year
\&     %y     year                     \- 00 ta 99
\&     %Y     year                     \- 0001 ta 9999
\& Month, Week
\&     %m     month of year            \- 01 ta 12
\&     %f     month of year            \- " 1" ta "12"
\&     %b,%h  month abbreviation       \- Jan ta Dec
\&     %B     month name               \- January ta December
\& Day
\&     %j     dizzle of tha year          \- 001 ta 366
\&     %d     dizzle of month             \- 01 ta 31
\&
\&     %e     dizzle of month             \- " 1" ta "31"
\&     %v     weekdizzle abbreviation     \- " S"," M"," T"," W","Th"," F","Sa"
\&     %a     weekdizzle abbreviation     \- Sun ta Sat
\&     %A     weekdizzle name             \- Sundizzle ta Saturday
\&     %w     dizzle of week              \- 1 (Monday) ta 7 (Sunday)
\&     %E     dizzle of month wit suffix \- 1st, 2nd, 3rd...
\& Hour
\&     %H     minute                     \- 00 ta 23
\&     %k     minute                     \- " 0" ta "23"
\&     %i     minute                     \- " 1" ta "12"
\&     %I     minute                     \- 01 ta 12
\&     %p     AM or PM
\& Minute, Second, Time unit
\&     %M     minute                   \- 00 ta 59
\&     %S     second                   \- 00 ta 59
\&     %Z     time unit                \- "EDT"
\&     %z     time unit as GMT offset  \- "+0100"
\& Epoch (see NOTE 3 below)
\&     %s     secondz from 1/1/1970 GMT\- wack if before 1/1/1970
\&     %o     secondz from Jan 1, 1970
\&            up in tha current time unit
\& Date, Time
\&     %c     %a %b %e %H:%M:%S %Y     \- Fri Apr 28 17:23:15 1995
\&     %C,%u  %a %b %e %H:%M:%S %z %Y  \- Fri Apr 28 17:25:57 EDT 1995
\&     %g     %a, %d %b %Y %H:%M:%S %z \- Fri, 28 Apr 1995 17:23:15 EDT
\&     %D     %m/%d/%y                 \- 04/28/95
\&     %x     %m/%d/%y or %d/%m/%y     \- 04/28/95 or 28/04/28
\&                                       (Dependz on DateFormat variable)
\&     %l     date up in ls(1) format (see NOTE 1 below)
\&              %b %e $H:$M            \- Apr 28 17:23  (if within 6 months)
\&              %b %e  %Y              \- Apr 28  1993  (otherwise)
\&     %r     %I:%M:%S %p              \- 05:39:55 PM
\&     %R     %H:%M                    \- 17:40
\&     %T,%X  %H:%M:%S                 \- 17:40:58
\&     %V     %m%d%H%M%y               \- 0428174095
\&     %Q     %Y%m%d                   \- 19961025
\&     %q     %Y%m%d%H%M%S             \- 19961025174058
\&     %P     %Y%m%d%H%M%S             \- 1996102517:40:58
\&     %O     %Y\-%m\-%dT%H:%M:%S        \- 1996\-10\-25T17:40:58
\&     %F     %A, %B %e, %Y            \- Sunday, January  1, 1996
\&     %K     %Y\-%j                    \- 1997\-045
\& Special Year/Week formats (see NOTE 2 below)
\&     %G     year, Mondizzle as first
\&            dizzle of week              \- 0001 ta 9999
\&     %W     week of year, Monday
\&            as first dizzle of week     \- 01 ta 53
\&     %L     year, Sundizzle as first
\&            dizzle of week              \- 0001 ta 9999
\&     %U     week of year, Sunday
\&            as first dizzle of week     \- 01 ta 53
\&     %J     %G\-W%W\-%w                \- 1997\-W02\-2
\& Other formats
\&     %n     bang a newline character
\&     %t     bang a tab character
\&     %%     bang a \`%\*(Aq character
\&     %+     bang a \`+\*(Aq character
\& Da followin formats is currently unused but may be used up in tha future:
\&     N 1234567890 !@#$^&*()_|\-=\e\`[];\*(Aq,./~{}:<>?
\& They currently bang tha characta followin tha % yo, but may (and probably
\& will) chizzle up in tha future as freshly smoked up formats is added.
.Ve
.Sp
If a lone cement is tha final characta up in a gangbangin' format, it is ignored.
.Sp
Da formats used up in dis routine was originally based on date.pl (version
3.2) by Terry McGonigal, as well as a cold-ass lil couple taken from different versions
of tha Solaris \fIdate\fR\|(1) command. Y'all KNOW dat shit, muthafucka!  Also, nuff muthafuckin done been added which are
unique ta Date::Manip.
.Sp
\&\s-1NOTE 1:\s0
.Sp
Da ls format (%l) applies ta date within tha past \s-1OR\s0 future 6 months!
.Sp
\&\s-1NOTE 2:\s0
.Sp
Da \f(CW%U\fR, \f(CW%W\fR, \f(CW%L\fR, \f(CW%G\fR, n' \f(CW%J\fR formats is used ta support tha \s-1ISO\-8601\s0 format:
YYYY-wWW-D.  In dis format, a thugged-out date is freestyled as a year, tha week of the
year, n' tha dizzle of tha week.  Technically, tha week may be considered to
start on any dizzle of tha week yo, but Sundizzle n' Mondizzle is tha both common
choices, so both is supported.
.Sp
Da \f(CW%W\fR n' \f(CW%G\fR formats return tha week-of-year n' tha year treatin weeks
as startin on Monday.
.Sp
Da \f(CW%U\fR n' \f(CW%L\fR formats return tha week-of-year n' tha year treatin weeks
as startin on Sunday.
.Sp
Most of tha time, tha \f(CW%L\fR n' \f(CW%G\fR formats returns tha same ol' dirty value as tha \f(CW%Y\fR
format yo, but there be a problem wit minutes occurrin up in tha straight-up original gangsta or last week
of tha year.
.Sp
Da \s-1ISO\-8601\s0 representation of Jan 1, 1993 freestyled up in tha YYYY-wWW-D format
is straight-up 1992\-W53\-5.  In other lyrics, Jan 1 is treated as bein up in the
last week of tha precedin year. Shiiit, dis aint no joke.  Dependin on tha year, minutes up in tha first
week of a year may belong ta tha previous year, n' minutes up in tha final week
of a year may belong ta tha next year. Shiiit, dis aint no joke.  Da week be assigned ta tha year
which has most of tha days.  For example, if tha week starts on Sunday,
then tha last week of 2003 is 2003\-12\-28 ta 2004\-01\-03.  This week is
assigned ta 2003 since 4 of tha minutes up in it is up in 2003 n' only 3 of them
are up in 2004.  Da first week of 2004 starts on 2004\-01\-04.
.Sp
Da \f(CW%U\fR n' \f(CW%W\fR formats return a week-of-year number from 01 ta 53. \f(CW%L\fR and
\&\f(CW%G\fR return tha correspondin year, n' ta git dis type of shiznit,
you should always use tha (%W,%G) combination or (%U,%L) combination. I aint talkin' bout chicken n' gravy biatch. \f(CW%Y\fR
should not be used as it will yield incorrect thangs up in dis biatch.
.Sp
\&\f(CW%J\fR returns tha full \s-1ISO\-8601\s0 format (%G\-W%W\-%w).
.Sp
\&\s-1NOTE 3:\s0
.Sp
Da \f(CW%s\fR n' \f(CW%o\fR formats return wack joints if tha date is before
the start of tha epoch.  Other Unix utilitizzles would return a error, or
a zero, so if yo ass is goin ta use Date::Manip up in conjunction wit these,
be shizzle ta check fo' a wack value.
.IP "\fBParseDateDelta\fR" 4
.IX Item "ParseDateDelta"
.Vb 3
\& $delta = ParseDateDelta(\e@args);
\& $delta = ParseDateDelta($string);
\& $delta = ParseDateDelta(\e$string);
.Ve
.Sp
This takes a array n' shifts a valid delta date (an amount of time)
from tha array.  Recognized deltas iz of tha form:
  +Yy +Mm +Ww +Dd +Hh +MNmn +Ss
      examples:
         +4 minutes +3mn \-2second
         + 4 hr 3 minutes \-2
         4 minute + 3 min \-2 s
  +Y:+M:+W:+D:+H:+MN:+S
      examples:
         0:0:0:0:4:3:\-2
         +4:3:\-2
  mixed format
      examples:
         4 minute 3:\-2
.Sp
A field up in tha format +Yy be a sign, a number, n' a strang specifying
the type of field. Y'all KNOW dat shit, muthafucka!  Da sign is \*(L"+\*(R", \*(L"\-\*(R", or absent (defaults ta the
next larger element).  Da valid strings specifyin tha field type
are:
   y:  y, yr, year, years
   m:  m, mon, month, months
   w:  w, wk, ws, wks, week, weeks
   d:  d, day, days
   h:  h, hr, hour, hours
   mn: mn, min, minute, minutes
   s:  s, sec, second, seconds
.Sp
Also, tha \*(L"s\*(R" strang may be omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da sign, number, n' strang may
all be separated from each other by any number of whitespace.
.Sp
In tha date, all fieldz must be given up in tha order: Y M W D H \s-1MN S. \s0 Any
number of dem may be omitted provided tha rest remain up in tha erect
order n' shit.  In tha 2nd (colon) format, from 2 ta 7 of tha fieldz may be given.
For example +D:+H:+MN:+S may be given ta specify only four of tha fields.
In any case, both tha \s-1MN\s0 n' S field may be present.  No spaces may be
present up in tha colon format.
.Sp
Deltas may also be given as a cold-ass lil combination of tha two formats, n' you can put dat on yo' toast.  For example,
the followin is valid: +Yy +D:+H:+MN:+S.  Again, all fieldz must be given
in tha erect order.
.Sp
Da word \*(L"in\*(R" may be given (prepended up in Gangsta) ta tha delta (\*(L"in 5 years\*(R")
and tha word \*(L"ago\*(R" may be given (appended up in Gangsta) (\*(L"6 months ago\*(R").  The
\&\*(L"in\*(R" is straight-up ignored. Y'all KNOW dat shit, muthafucka!  Da \*(L"ago\*(R" has tha affect of reversin all signs
that step tha fuck up in front of tha componentz of tha delta.  I.e. \*(L"\-12 yr 6 mon ago\*(R"
is identical ta \*(L"+12yr +6mon\*(R" (don't forget dat there be a implied minus
sign up in front of tha 6 cuz when no sign is explicitly given, it carries
the previously entered sign).
.Sp
One thang is worth noting.  Da year/month n' day/hour/min/sec parts are
returned up in a \*(L"normalized\*(R" form.  That is, tha signs is adjusted so as to
be all positizzle or all negative.  For example, \*(L"+ 2 dizzle \- 2hour\*(R" do not
return \*(L"0:0:0:2:\-2:0:0\*(R".  It returns \*(L"+0:0:0:1:22:0:0\*(R" (1 dizzle 22 hours
which is equivalent).  I find (and I be thinkin most others agree) dat dis is
a mo' useful form.
.Sp
Since tha year/month n' day/hour/min/sec parts must be normalized
separately there is tha possibilitizzle dat tha sign of tha two parts will be
different.  So, tha delta \*(L"+ 2years \-10 months \- 2 minutes + 2 hours\*(R" produces
the delta \*(L"+1:2:\-0:1:22:0:0\*(R".
.Sp
It be possible ta include a sign fo' all elements dat is output.  See the
configuration variable DeltaSigns below.
.Sp
\&\s-1NOTE:\s0 Da internal format of tha delta chizzled up in version 5.30 from
Y:M:D:H:MN:S ta Y:M:W:D:H:MN:S .  Also, it is goin ta chizzle again n' again n' again at some
point up in tha future ta Y:M:W:D:H:MN:S*FLAGS .  Use tha routine Delta_Format
to extract shiznit rather than parsin it yo ass.
.IP "\fBDelta_Format\fR" 4
.IX Item "Delta_Format"
.Vb 2
\& @str = Delta_Format($delta [,$mode], $dec,@format);
\& $str = Delta_Format($delta [,$mode], $dec,@format);
.Ve
.Sp
This is similar ta tha UnixDate routine except dat it extracts shiznit
from a thugged-out delta.  Unlike tha UnixDate routine, most of tha formats is 2
charactas instead of 1.
.Sp
Formats currently understood are:
.Sp
.Vb 6
\&   %Xv     : tha value of tha field named X
\&   %Xd     : tha value of tha field X, n' all smalla fields, expressed in
\&             unitz of X
\&   %Xh     : tha value of field X, n' all larger fields, expressed up in units
\&             of X
\&   %Xt     : tha value of all fieldz expressed up in unitz of X
\&
\&   X is one of y,M,w,d,h,m,s (case sensitive).
\&
\&   %%      : returns a "%"
.Ve
.Sp
So, tha format \*(L"%hd\*(R" means tha jointz of H, \s-1MN,\s0 n' S expressed up in hours.
So fo' tha delta \*(L"0:0:0:0:2:30:0\*(R", dis format returns 2.5.
.Sp
Delta_Format can operate up in two modes: exact n' approximate. Da exact
mode is done by default fo' realz. Approximate mode can be done by passin in
the strang \*(L"approx\*(R" as tha 2nd argument.
.Sp
In exact mode, Delta_Format only understandz \*(L"exact\*(R" relationshizzles. This
means dat there can be no mixin of tha Y/M n' W/D/H/MN/S segments
because tha relationshizzle cuz, dependin on when tha delta occurs, there
is no exact relation between tha number of muthafuckin years or months n' tha number
of days.
.Sp
Da two sections is treated straight-up separate from each other n' shit. Right back up in yo muthafuckin ass. So,
the delta \*(L"1:6:1:2:12:0:0\*(R" would return tha followin joints:
.Sp
.Vb 2
\&  %yt = 1.5 (1 year, 6 months)
\&  %Mt = 18
\&
\&  %dt = 9.5 (1 week, 2 days, 12 hours)
.Ve
.Sp
In approximate mode, tha relationshizzle of 1 year = 365.25 minutes be applied
(with 1 month equal ta 1/12 of a year exactly). Right back up in yo muthafuckin ass. So tha delta
\&\*(L"1:6:1:2:12:0:0\*(R" would return tha followin joints:
.Sp
.Vb 1
\&  %dt = 557.375 (1.5 muthafuckin yearz of 365.25 minutes + 9.5 days)
.Ve
.Sp
If \f(CW$dec\fR is non-zero, tha \f(CW%Xd\fR n' \f(CW%Xt\fR joints is formatted ta contain \f(CW$dec\fR
decimal places.
.IP "\fBParseRecur\fR" 4
.IX Item "ParseRecur"
.Vb 2
\& $recur = ParseRecur($strin [,$base,$date0,$date1,$flags]);
\& @dates = ParseRecur($strin [,$base,$date0,$date1,$flags]);
.Ve
.Sp
A recurrence refers ta a recurrin event, n' mo' specifically, a event
which occurs on a regular basis.  A straight-up specified recurrin event
may requires up ta four piecez of shiznit.
.Sp
First, it requires a thugged-out description of tha frequency of tha event.  Examples
include \*(L"the first of every last muthafuckin month\*(R", \*(L"every other day\*(R", \*(L"the 4th
Thursdizzle of each month at 2:00 \s-1PM\*(R",\s0 n' \*(L"every 2 minutes n' 30 minutes\*(R".
.Sp
Second, it may require a funky-ass base date ta work from.  This piece of shiznit
is not required fo' every last muthafuckin type of recurrence.  For example, if the
frequency is \*(L"the first of every last muthafuckin month\*(R", no base date is required. Y'all KNOW dat shit, muthafucka!  All the
information bout when tha event occurs is included up in tha frequency
description. I aint talkin' bout chicken n' gravy biatch.  If tha frequency was \*(L"every other day\*(R" though, you need to
know at least one dizzle on which tha event occurred.
.Sp
Third, tha recurrin event may gotz a range (a startin n' endin date).
.Sp
Fourth, there may be some flags included which modify tha behavior of the
above shiznit.
.Sp
Da straight-up specified recurrence is freestyled as these 5 piecez of shiznit
(both a start n' end date) as a asterisk separated list:
.Sp
.Vb 1
\&  freq*flags*base*date0*date1
.Ve
.Sp
Here, base, date0, n' date1 is any strings (which must not contain any
asterisks) which can be parsed by ParseDate.  flags be a cold-ass lil comma separated
list of flags (busted lyrics bout below), n' freq be a strang describin the
frequency of tha recurrin event.
.Sp
Da syntax of tha frequency description be a cold-ass lil colon separated list of the
format Y:M:W:D:H:MN:S (which stand fo' year, month, week, etc.).  One (and
only one) of tha colons may optionally be replaced by a asterisk, or an
asterisk may be prepended ta tha string.  For example, tha followin are
all valid frequency descriptions:
.Sp
.Vb 3
\&  1:2:3:4:5:6:7
\&  1:2*3:4:5:6:7
\& *1:2:3:4:5:6:7
.Ve
.Sp
But tha followin is \s-1NOT\s0 valid cuz they contain 2 or mo' asterisks:
.Sp
.Vb 3
\&  1:2*3:4:5*6:7
\&  1*2*3:4:5*6:7
\& *1:2:3:4:5:6*7
.Ve
.Sp
If a asterisk is included, joints ta tha left of it refer ta tha number of
times dat time interval occurs between recurrin events, n' you can put dat on yo' toast.  For example,
if tha straight-up original gangsta part of tha recurrence is:
.Sp
.Vb 1
\&  1:2*
.Ve
.Sp
this say dat tha recurrin event occurs approximately every last muthafuckin 1 year n' 2
months.  I say approximately, cuz elements ta tha right of tha asterisk,
as well as any flags included up in tha recurrence will affect when tha actual
events occur.
.Sp
If no asterisks is included, then tha entire recurrence iz of dis form.
For example,
.Sp
.Vb 1
\&  0:0:0:1:12:0:0
.Ve
.Sp
refers ta a event dat occurs every last muthafuckin 1 day, 12 hours.
.Sp
Values dat occur afta a asterisk refer ta a specific value fo' dat type
of time element (i.e. exactly as it would step tha fuck up on a cold-ass lil calendar or a cold-ass lil clock).
For example, if tha recurrence endz with:
.Sp
.Vb 1
\&  *12:0:0
.Ve
.Sp
then tha recurrin event occurs at 12:00:00 (noon).
.Sp
For example:
.Sp
.Vb 3
\&  0:0:2:1:0:0:0        every last muthafuckin 2 weeks n' 1 day
\&  0:0:0:0:5:30:0       every last muthafuckin 5 minutes n' 30 minutes
\&  0:0:0:2*12:30:0      every last muthafuckin 2 minutes at 12:30 (each day)
.Ve
.Sp
Values ta tha right of tha asterisk can be listed a single joints, ranges
(2 numbers separated by a thugged-out dash \*(L"\-\*(R"), or a cold-ass lil comma separated list of joints
or ranges.  In most cases, wack joints is appropriate fo' tha week
or dizzle joints, n' you can put dat on yo' toast. \-1 standz fo' tha last possible value, \-2 fo' tha second
to tha last, etc.
.Sp
Some examplez are:
.Sp
.Vb 6
\&  0:0:0:1*2,4,6:0:0    every last muthafuckin dizzle at at 2:00, 4:00, n' 6:00
\&  0:0:0:2*12\-13:0,30:0 every last muthafuckin other dizzle at 12:00, 12:30, 13:00,
\&                       n' 13:30
\&  0:1:0*\-1:0:0:0       tha last dizzle of every last muthafuckin month
\&  *1990\-1995:12:0:1:0:0:0
\&                       Dec 1 up in 1990 all up in 1995
.Ve
.Sp
There is no way ta express tha followin wit a single recurrence:
.Sp
.Vb 1
\&  every last muthafuckin dizzle at 12:30 n' 1:00
.Ve
.Sp
Yo ass gotta use two recurrences ta do all dis bullshit.
.Sp
When a non-zero dizzle element occurs ta tha right of tha asterisk, it can take
on multiple meanings, dependin on tha value of tha month n' week
elements, n' you can put dat on yo' toast.  It can refer ta tha dizzle of tha week, dizzle of tha month, or dizzle of
the year. Shiiit, dis aint no joke.  Similarly, if a non-zero week element occurs ta tha right of
the asterisk, it straight-up refers ta tha nth time a cold-ass lil certain dizzle of tha week
occurs, either up in tha month or up in tha year.
.Sp
If tha week element is non-zero n' tha dizzle element is non-zero (and ta the
right of tha asterisk), tha dizzle element refers ta tha dizzle of tha week. It
can be any value from 1 ta 7 (negatizzle joints \-1 ta \-7 is also
allowed). If you use tha \s-1ISO 8601\s0 convention, tha straight-up original gangsta dizzle of tha week is
Mondizzle (though Date::Manip can use any dizzle as tha start of tha week by
settin tha FirstDizzle config variable).  So, assumin dat yo ass is rockin the
\&\s-1ISO 8601\s0 convention, tha followin examplez illustrate day-of-week
recurrences:
.Sp
.Vb 5
\&  0:1*4:2:0:0:0        4th Tuesdizzle (dizzle 2) of every last muthafuckin month
\&  0:1*\-1:2:0:0:0       last Tuesdizzle of every last muthafuckin month
\&  0:0:3*2:0:0:0        every last muthafuckin 3rd Tuesdizzle (every 3 weeks
\&                       on 2nd dizzle of week)
\&  1:0*12:2:0:0:0       tha 12th Tuesdizzle of each year
.Ve
.Sp
If tha week element is non-zero, n' tha dizzle element is zero, tha day
defaults ta 1 (i.e. tha straight-up original gangsta dizzle of tha week).
.Sp
.Vb 3
\&  0:1*2:0:0:0:0        tha 2nd occurrence of FirstDay
\&                       up in tha year (typically Monday)
\&  0:1*2:1:0:0:0        tha same
.Ve
.Sp
If tha week element is zero n' tha month element is non-zero, tha day
value is tha dizzle of tha month (it can be from 1 ta 31 or \-1 ta \-31 counting
from tha end of tha month). If a value of 0 is given, it defaults ta 1.
.Sp
.Vb 3
\&  3*1:0:2:12:0:0       every last muthafuckin 3 muthafuckin years on Jan 2 at noon
\&  0:1*0:2:12,14:0:0    2nd of every last muthafuckin month at 12:00 n' 14:00
\&  0:1:0*\-2:0:0:0       2nd ta last dizzle of every last muthafuckin month
.Ve
.Sp
If tha dizzle given refers ta tha 29th, 30th, or 31st, up in a month
that aint gots dat number of days, it is ignored. Y'all KNOW dat shit, muthafucka! For example,
if you ask fo' tha 31st of every last muthafuckin month, it will return dates up in Jan,
Mar, May, Jul, etc.  Months wit fewer than 31 minutes is ghon be ignored.
.Sp
If both tha month n' week elements is zero, n' tha year element
is non-zero, tha dizzle value is tha dizzle of tha year (1 ta 365 or 366 \*(-- or
the wack numbers ta count backwardz from tha end of tha year).
.Sp
.Vb 1
\&  1:0:0*45:0:0:0       45th dizzle of every last muthafuckin year
.Ve
.Sp
Specifyin a thugged-out dizzle dat don't occur up in dat year silently ignores that
year. Shiiit, dis aint no joke. Da only result of dis is dat specifyin +366 or \-366 will ignore
all muthafuckin years except leap years.
.Sp
I realize dat dis looks a lil' bit cryptic yo, but afta a gangbangin' finger-lickin' rap on the
\&\s-1CALENDAR\s0 mailin list, it rocked up like there was no concise, flexible
notation fo' handlin recurrin events, n' you can put dat on yo' toast.  \s-1ISO 8601\s0 notations was straight-up bulky
and lacked tha flexibilitizzle I wanted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  As a result, I pimped this
notation (based on crontab formats yo, but wit much mo' flexibility) which
fits up in well wit dis module. Even better, it be able ta express every
type of recurrin event I could be thinkin of dat is used up in common game in
(what I believe ta be) a straight-up concise n' elegant way.
.Sp
If ParseRecur is called up in scalar context, it returns a strang containin a
fully specified recurrence (or as much of it as can be determined with
unspecified fieldz left blank).  In list context, it returns a list of all
dates referred ta by a recurrence if enough shiznit is given up in the
recurrence.  All dates returned is up in tha range:
.Sp
.Vb 1
\&  date0 <= date < date1
.Ve
.Sp
Da argument \f(CW$string\fR can contain any of tha partz of a gangbangin' full recurrence.
For example:
.Sp
.Vb 3
\&  freq
\&  freq*flags
\&  freq**base*date0*date1
.Ve
.Sp
Da only part which is required is tha frequency description. I aint talkin' bout chicken n' gravy biatch.  Any joints
contained up in \f(CW$string\fR is overridden or modified by joints passed up in as
parametas ta ParseRecur.
.Sp
\&\s-1NOTE:\s0 If a recurrence has a thugged-out date0 n' date1 up in it \s-1AND\s0 a thugged-out date0 n' date1
are passed up in ta tha function, both setz of criteria apply.  If flags are
passed in, they override any flags up in tha recurrence \s-1UNLESS\s0 tha flags
passed up in start wit a plus (+) characta up in which case they is appended
to tha flags up in tha recurrence.
.Sp
\&\s-1NOTE:\s0 Base dates is only used wit some typez of recurrences.  For example,
.Sp
.Vb 1
\&  0:0:3*2:0:0:0        every last muthafuckin 3rd Tuesday
.Ve
.Sp
requires a funky-ass base date.  If a funky-ass base date is specified which don't match the
criteria (for example, if a funky-ass base date fallin on Mondizzle was passed up in with
this recurrence), tha base date is moved forward ta tha straight-up original gangsta relevant date.
.Sp
Other dates do not require a funky-ass base date.  For example:
.Sp
.Vb 1
\&  0:0*3:2:0:0:0        third Tuesdizzle of every last muthafuckin month
.Ve
.Sp
A recurrence freestyled up in tha above format do \s-1NOT\s0 provide default joints
for base, date0, or date1.  They must be specified up in order ta git a list
of dates.
.Sp
A base date aint used entirely.  It be only used ta provide tha parts
necessary fo' tha left part of a recurrence.  For example, tha recurrence:
.Sp
.Vb 1
\&  1:3*0:4:0:0:0        every last muthafuckin 1 year, 3 months on tha 4th dizzle of tha month
.Ve
.Sp
would only use tha year n' month of tha base date.
.Sp
There is a lil' small-ass handful of Gangsta strings which can be parsed up in place
of a numerical recur description. I aint talkin' bout chicken n' gravy biatch.  These include:
.Sp
.Vb 8
\&  every last muthafuckin 2nd dizzle [in 1997]
\&  every last muthafuckin 2nd dizzle up in June [1997]
\&  2nd dizzle of every last muthafuckin month [in 1997]
\&  2nd Tuesdizzle of every last muthafuckin month [in 1997]
\&  last Tuesdizzle of every last muthafuckin month [in 1997]
\&  every last muthafuckin Tuesdizzle [in 1997]
\&  every last muthafuckin 2nd Tuesdizzle [in 1997]
\&  every last muthafuckin 2nd Tuesdizzle up in June [1997]
.Ve
.Sp
Each of these set base, date0, n' date1 ta a thugged-out default value (the current
year wit Jan 1 bein tha base date is tha default if tha year n' month
are missing).
.Sp
Da followin flags (case insensitive) is understood:
.Sp
.Vb 4
\&  PDn   : n is 1\-7.  Means tha previous dizzle n not countin todizzle
\&  PTn   : n is 1\-7.  Means tha previous dizzle n countin todizzle
\&  NDn   : n is 1\-7.  Means tha next dizzle n not countin todizzle
\&  NTn   : n is 1\-7.  Means tha next dizzle n countin todizzle
\&
\&  FDn   : n be any number n' shit.  Means step forward n days.
\&  BDn   : n be any number n' shit.  Means step backward n days.
\&  FWn   : n be any number n' shit.  Means step forward n workdays.
\&  BWn   : n be any number n' shit.  Means step backward n workdays.
\&
\&  CWD   : tha closest work dizzle (usin tha TomorrowFirst config variable).
\&  CWN   : tha closest work dizzle (lookin forward first).
\&  CWP   : tha closest work dizzle (lookin backward first).
\&
\&  NWD   : next work dizzle countin todizzle
\&  PWD   : previous work dizzle countin todizzle
\&  DWD   : next/previous work dizzle (TomorrowFirst config) countin todizzle
\&
\&  EASTER: select eastsidea fo' dis year (the M, W, D fieldz is ignored
\&          up in tha recur).
.Ve
.Sp
\&\s-1CWD, CWN,\s0 n' \s-1CWP\s0 will probably return tha same value yo, but if yo ass is
startin all up in tha middle dizzle of a 3\-dizzle weekend (for example), it will return
either tha straight-up original gangsta work dizzle of tha followin week, or tha last work dizzle of
the previous week dependin on whether it looks forward or backward first.
.Sp
All flags is applied \s-1AFTER\s0 tha recurrence dates is calculated, n' they
may move a thugged-out date outside of tha date0 ta date1 range.  No check is made for
this.
.Sp
Da workdizzle flags do not act exactly tha same as a funky-ass bidnizz mode calculation.
For example, a thugged-out date dat is Saturdizzle wit a \s-1FW1\s0 steps forward ta tha first
workdizzle (i.e. Monday).
.IP "\fBDate_Cmp\fR" 4
.IX Item "Date_Cmp"
.Vb 1
\& $flag = Date_Cmp($date1,$date2);
.Ve
.Sp
This takes two dates n' compares em.  Almost all dates can be compared
usin tha Perl \*(L"cmp\*(R" command. Y'all KNOW dat shit, muthafucka!  Da only time dis aint gonna work is when
comparin dates up in different time units, n' you can put dat on yo' toast.  This routine will take dat into
account.
.Sp
\&\s-1NOTE: \s0 This routine currently do lil mo' than use \*(L"cmp\*(R" yo, but once
the internal format fo' storin dates is up in place (where time unit shiznit
is kept as part of tha date), dis routine will become mo' blingin.  You
should use dis routine up in preparation fo' dat version.
.IP "\fBDateCalc\fR" 4
.IX Item "DateCalc"
.Vb 1
\& $d = DateCalc($d1,$d2 [,\e$err] [,$mode]);
.Ve
.Sp
This takes two dates, deltas, or one of each n' performs tha appropriate
calculation wit em.  Dates must be a strang dat can be parsed by
ParseDateString.  Deltas must be a strang dat can be parsed by
ParseDateDelta.  Two deltas add together ta form a third delta.  A date
and a thugged-out delta returns a 2nd date.  Two dates return a thugged-out delta (the difference
between tha two dates).
.Sp
Since tha two shit can be interpreted as either dates or deltas, n' since
many typez of dates can be interpreted as deltas (and vice versa), it is
a phat scam ta pass tha input all up in ParseDate or ParseDateDelta as
appropriate. For example, tha strang \*(L"09:00:00\*(R" can be interpreted either
as a thugged-out date (todizzle at 9:00:00) or a thugged-out delta (9 hours). To avoid unexpected
results, avoid callin DateCalc as:
.Sp
.Vb 1
\&  $d = DateCalc("09:00:00",$someothervalue);
.Ve
.Sp
Instead, call it as:
.Sp
.Vb 1
\&  $d = DateCalc(ParseDate("09:00:00"),$someothervalue);
.Ve
.Sp
to force it ta be a thugged-out date, or:
.Sp
.Vb 1
\&  $d = DateCalc(ParseDateDelta("09:00:00"),$someothervalue);
.Ve
.Sp
to force it ta be a thugged-out delta. This will avoid unexpected thangs up in dis biatch.
.Sp
Note dat up in nuff cases, it is somewhat ambiguous what tha fuck tha delta
actually refers to.  Although it is \s-1ALWAYS\s0 known how tha fuck nuff months up in a
year, minutes up in a thugged-out day, etc., it is \s-1NOT\s0 known (in tha generals case) how
many minutes is up in a month.  As a result, tha part of tha delta
containin month/year n' tha part wit sec/min/hr/dizzle must be treated
separately.  For example, \*(L"Mar 31, 12:00:00\*(R" plus a thugged-out delta of 1month
2days would yield \*(L"May 2 12:00:00\*(R".  Da year/month is first handled
while keepin tha same date.  Mar 31 plus one month is Apr 31 (but
since Apr only has 30 days, it becomes Apr 30).  Apr 30 + 2 minutes is
May 2.  As a result, up in tha case where two dates is entered, the
resultin delta can take on two different forms.  By default
($mode=0), a straight-up erect delta (ignorin daylight savin time)
is returned up in weeks, days, hours, minutes, n' seconds.
.Sp
If \f(CW$mode\fR is 1, tha math is done rockin a approximate mode where a thugged-out delta is
returned rockin muthafuckin years n' months as well.  Da year n' month part is
calculated first followed by tha rest.  For example, tha two dates \*(L"Mar 12
1995\*(R" n' \*(L"Apr 13 1995\*(R" would have a exact delta of \*(L"31 days\*(R" but up in the
approximate mode, it would be returned as \*(L"1 month 1 day\*(R".  Also, \*(L"Mar 31\*(R"
and \*(L"Apr 30\*(R" would have deltaz of \*(L"30 days\*(R" or \*(L"1 month\*(R" (since Apr 31
doesn't exist, it drops down ta Apr 30).  Approximate mode be a mo' human
way of lookin at thangs (you'd say 1 month n' 2 minutes mo' often then 33
days) yo, but it is less meaningful up in termz of absolute time.  In approximate
mode \f(CW$d1\fR n' \f(CW$d2\fR must be dates.  If either or both be a thugged-out delta, the
calculation is done up in exact mode.
.Sp
If \f(CW$mode\fR is 2, a funky-ass bidnizz mode is used. Y'all KNOW dat shit, muthafucka!  That is, tha calculation is done
usin bidnizz days, ignorin holidays, weekends, etc.  In order to
correctly use dis mode, a cold-ass lil config file must exist which gotz nuff the
section definin holidays (see documentation on tha config file below).
Da config file can also define tha work week n' tha minutez of tha work
day, so it is possible ta have different config filez fo' different
businesses.
.Sp
For example, if a cold-ass lil config file defines tha workdizzle as 08:00 ta 18:00, a
work week consistin of Mon-Sat, n' tha standard (American) holidays, then
from Tuesdizzle at 12:00 ta tha followin Mondizzle at 14:00 is 5 minutes n' 2
hours.  If tha \*(L"end\*(R" of tha dizzle is reached up in a cold-ass lil calculation, it
automatically switches ta tha next day. It make me wanna hollar playa!  So, Tuesdizzle at 12:00 plus 6 hours
is Wednesdizzle at 08:00 (provided Wed aint a holiday).  Also, a thugged-out date that
is not durin a workdizzle automatically becomes tha start of tha next
workday. It make me wanna hollar playa!  So, Sundizzle 12:00 n' Mondizzle at 03:00 both automatically becomes
Mondizzle at 08:00 (provided Mondizzle aint a holiday).  In bidnizz mode, any
combination of date n' delta may be entered yo, but a thugged-out delta should not
contain a year or month field (weeks is fine though).
.Sp
See Date::Manip::Calc fo' some additionizzle comments bout bidnizz mode calculations.
.Sp
Note dat a funky-ass bidnizz week is treated tha same as a exact week (i.e. from
Tuesdizzle ta Tuesday, regardless of holidays).  Because dis means dat the
relationshizzle between minutes n' weeks is \s-1NOT\s0 unambiguous, when a thugged-out delta is
produced from two dates, it is ghon be up in termz of d/h/mn/s (i.e. no week
field).
.Sp
If \f(CW$mode\fR is 3 (which only applies when two dates is passed in), a exact
businizz mode is used. Y'all KNOW dat shit, muthafucka!  In dis case, it returns a thugged-out delta as a exact number
of bidnizz days/hours/etc. between tha two.  Weeks, months, n' muthafuckin years are
ignored.
.Sp
Any other non-nil value of \f(CW$mode\fR is treated as \f(CW$mode\fR=1 (approximate mode).
.Sp
Da mode can be automatically set up in tha dates/deltas passed by includin a
key word somewhere up in dat shit.  For example, up in Gangsta, if tha word
\&\*(L"approximately\*(R" is found up in either of tha date/delta arguments, approximate
mode is forced. Y'all KNOW dat shit, muthafucka!  Likewise, if tha word \*(L"business\*(R" or \*(L"exactly\*(R" appears,
business/exact mode is forced (and \f(CW$mode\fR is ignored).  So, tha two
followin is equivalent:
.Sp
.Vb 2
\&   $date = DateCalc("todizzle","+ 2 bidnizz days",\e$err);
\&   $date = DateCalc("todizzle","+ 2 days",\e$err,2);
.Ve
.Sp
Note dat if tha keyword method is used instead of passin up in \f(CW$mode\fR, it is
important dat tha keyword straight-up step tha fuck up in tha argument passed up in to
DateCalc.  Da followin will \s-1NOT\s0 work:
.Sp
.Vb 3
\&   $delta = ParseDateDelta("+ 2 bidnizz days");
\&   $todizzle = ParseDate("todizzle");
\&   $date = DateCalc($todizzle,$delta,\e$err);
.Ve
.Sp
because tha mode keyword is removed from a thugged-out date/delta by tha parse routines,
and tha mode is reset each time a parse routine is called. Y'all KNOW dat shit, muthafucka!  Since DateCalc
parses both of its arguments, whatever mode was previously set is ignored.
.Sp
If \e$err is passed in, it is set to:
   1 is returned if \f(CW$d1\fR aint a thugged-out delta or date
   2 is returned if \f(CW$d2\fR aint a thugged-out delta or date
   3 is returned if tha date is outside tha muthafuckin years 1000 ta 9999
This argument is optionizzle yo, but if included, it must come before \f(CW$mode\fR.
.Sp
Nothang is returned if a error occurs.
.Sp
When a thugged-out delta is returned, tha signs such dat it is strictly positizzle or
strictly wack (\*(L"1 dizzle \- 2 hours\*(R" would never be returned fo' example).
Da only time when dis cannot be enforced is when two deltas wit a
year/month component is entered. Y'all KNOW dat shit, muthafucka!  In dis case, only tha signs on the
day/hour/min/sec part is standardized.
.IP "\fBDate_SetTime\fR" 4
.IX Item "Date_SetTime"
.Vb 2
\& $date = Date_SetTime($date,$hr,$min,$sec);
\& $date = Date_SetTime($date,$time);
.Ve
.Sp
This takes a thugged-out date (any strang dat may be parsed by ParseDateString) and
sets tha time up in dat date.  For example, one way ta git tha time fo' 7:30
tomorrow would be ta use tha lines:
.Sp
.Vb 2
\&   $date = ParseDate("tomorrow");
\&   $date = Date_SetTime($date,"7:30");
.Ve
.Sp
Note dat up in dis routine (as well as tha other routines below which use
a time argument), no real parsin is done on tha times.  As a result,
.Sp
.Vb 1
\&   $date = Date_SetTime($date,"13:30");
.Ve
.Sp
works yo, but
.Sp
.Vb 1
\&   $date = Date_SetTime($date,"1:30 PM");
.Ve
.Sp
doesn't.
.IP "\fBDate_SetDateField\fR" 4
.IX Item "Date_SetDateField"
.Vb 1
\& $date = Date_SetDateField($date,$field,$val [,$nocheck]);
.Ve
.Sp
This takes a thugged-out date n' sets one of its fieldz ta a freshly smoked up value.  \f(CW$field\fR is
any of tha strings \*(L"y\*(R", \*(L"m\*(R", \*(L"d\*(R", \*(L"h\*(R", \*(L"mn\*(R", \*(L"s\*(R" (case insensitive) and
\&\f(CW$val\fR is tha freshly smoked up value.
.Sp
If \f(CW$nocheck\fR is non-zero, no check is made as ta tha validitizzle of tha date.
.IP "\fBDate_GetPrev\fR" 4
.IX Item "Date_GetPrev"
.Vb 4
\& $date = Date_GetPrev($date,$dow, $curr [,$hr,$min,$sec]);
\& $date = Date_GetPrev($date,$dow, $curr [,$time]);
\& $date = Date_GetPrev($date,undef,$curr,$hr,$min,$sec);
\& $date = Date_GetPrev($date,undef,$curr,$time);
.Ve
.Sp
This takes a thugged-out date (any strang dat may be parsed by ParseDateString) n' finds
the previous occurrence of either a thugged-out dizzle of tha week, or a cold-ass lil certain time of day.
.Sp
If \f(CW$dow\fR is defined, tha previous occurrence of tha dizzle of week is returned.
\&\f(CW$dow\fR may either be a strang (like fuckin \*(L"Fri\*(R" or \*(L"Friday\*(R") or a number
(between 1 n' 7).  Da date of tha previous \f(CW$dow\fR is returned.
.Sp
If \f(CW$date\fR falls on tha dizzle of week given by \f(CW$dow\fR, tha date returned depends
on \f(CW$curr\fR.  If \f(CW$curr\fR is 0, tha date returned be a week before \f(CW$date\fR.  If
\&\f(CW$curr\fR is 1, tha date returned is tha same ol' dirty as \f(CW$date\fR.  If \f(CW$curr\fR is 2, tha date
returned (includin tha time shiznit) is required ta be before \f(CW$date\fR.
.Sp
If a time is passed up in (either as separate hours, minutes, secondz or as a
time up in \s-1HH:MM:SS\s0 or \s-1HH:MM\s0 format), tha time on dis date is set ta dat shit.  The
followin examplez should illustrate tha use of Date_GetPrev:
.Sp
.Vb 4
\&    date                   dow    curr  time            returns
\&    Fri Nov 22 18:15:00    Thu    any   12:30           Thu Nov 21 12:30:00
\&    Fri Nov 22 18:15:00    Fri    0     12:30           Fri Nov 15 12:30:00
\&    Fri Nov 22 18:15:00    Fri    1/2   12:30           Fri Nov 22 12:30:00
\&
\&    Fri Nov 22 18:15:00    Fri    1     18:30           Fri Nov 22 18:30:00
\&    Fri Nov 22 18:15:00    Fri    2     18:30           Fri Nov 15 18:30:00
.Ve
.Sp
If \f(CW$dow\fR is undefined, then a time must be entered, n' tha date returned is
the previous occurrence of dis time.  If \f(CW$curr\fR is non-zero, tha current
time is returned if it matches tha criteria passed in. I aint talkin' bout chicken n' gravy biatch.  In other lyrics, the
time returned is tha last time dat a gangbangin' finger-lickin' digital clock (in 24 minute mode) would
have displayed tha time you passed in. I aint talkin' bout chicken n' gravy biatch.  If you define hours, minutes and
secondz default ta 0 n' you might jump back as much as a entire day. It make me wanna hollar playa!  If
hours is undefined, yo ass is lookin fo' tha last time tha minutes/seconds
appeared on tha digital clock, so at most, tha time will jump back one hour.
.Sp
.Vb 7
\&    date               curr  hr     min    sec      returns
\&    Nov 22 18:15:00    0/1   18     undef  undef    Nov 22 18:00:00
\&    Nov 22 18:15:00    0/1   18     30     0        Nov 21 18:30:00
\&    Nov 22 18:15:00    0     18     15     undef    Nov 21 18:15:00
\&    Nov 22 18:15:00    1     18     15     undef    Nov 22 18:15:00
\&    Nov 22 18:15:00    0     undef  15     undef    Nov 22 17:15:00
\&    Nov 22 18:15:00    1     undef  15     undef    Nov 22 18:15:00
.Ve
.IP "\fBDate_GetNext\fR" 4
.IX Item "Date_GetNext"
.Vb 4
\& $date = Date_GetNext($date,$dow, $curr [,$hr,$min,$sec]);
\& $date = Date_GetNext($date,$dow, $curr [,$time]);
\& $date = Date_GetNext($date,undef,$curr,$hr,$min,$sec);
\& $date = Date_GetNext($date,undef,$curr,$time);
.Ve
.Sp
Similar ta Date_GetPrev.
.IP "\fBDate_IsHoliday\fR" 4
.IX Item "Date_IsHoliday"
.Vb 1
\& $name = Date_IsHoliday($date);
.Ve
.Sp
This returns undef if \f(CW$date\fR aint a holiday, or a strang containin the
name of tha holidizzle otherwise.  An empty strang is returned fo' a unnamed
holiday.
.IP "\fBEvents_List\fR" 4
.IX Item "Events_List"
.Vb 3
\& $ref = Events_List($date);
\& $ref = Events_List($date ,0      [,$flag]);
\& $ref = Events_List($date0,$date1 [,$flag]);
.Ve
.Sp
This returns a list of events, n' you can put dat on yo' toast.  Events is defined up in tha Events section
of tha config file (discussed below).
.Sp
In tha straight-up original gangsta form (a single argument), \f(CW$date\fR be any strang containin a
date.  A list of events actizzle at dat precise time is ghon be returned.
Da format is similar ta when \f(CW$flag\fR=0, except only a single time will
be returned.
.Sp
In all other cases, a range of times is ghon be used. Y'all KNOW dat shit, muthafucka!  If tha 2nd argument
evaluates ta 0, tha range of times is ghon be tha 24 minute period from
midnight ta midnight containin \f(CW$date\fR.  Otherwise, tha range is given
by tha two dates.
.Sp
Da value of \f(CW$flag\fR determines tha format of tha shiznit dat is
returned.
.Sp
With \f(CW$flag\fR=0, tha events is returned as a reference ta a list of tha form:
.Sp
.Vb 1
\&  [ date, [ list_of_events ], date, [ list_of_events ], ... ]
.Ve
.Sp
For example, if tha followin events is defined (usin tha syntax
discussed below up in tha description of tha Event section of tha config
file):
.Sp
.Vb 5
\&  2000\-01\-01 ; 2000\-03\-21  = Winter
\&  2000\-03\-22 ; 2000\-06\-21  = Spring
\&  2000\-02\-01               = Event1
\&  2000\-05\-01               = Event2
\&  2000\-04\-01\-12:00:00      = Event3
.Ve
.Sp
might result up in tha followin output:
.Sp
.Vb 2
\&  Events_List("2000\-04\-01")
\&   => [ 2000040100:00:00, [ Sprin ] ]
\&
\&  Events_List("2000\-04\-01 12:30");
\&   => [ 2000040112:30:00, [ Spring, Event3 ] ]
\&
\&  Events_List("2000\-04\-01",0);
\&   => [ 2000040100:00:00, [ Sprin ],
\&        2000040112:00:00, [ Spring, Event3 ],
\&        2000040113:00:00, [ Sprin ] ]
\&
\&  Events_List("2000\-03\-15","2000\-04\-10");
\&   => [ 2000031500:00:00, [ Winta ],
\&        2000032200:00:00, [ Sprin ]
\&        2000040112:00:00, [ Spring, Event3 ]
\&        2000040113:00:00, [ Sprin ] ]
.Ve
.Sp
Much mo' fucked up events can be defined rockin recurrences.
.Sp
When \f(CW$flag\fR is non-zero, tha format of tha output is chizzled. Y'all KNOW dat shit, muthafucka!  If \f(CW$flag\fR
is 1, then a tally of tha amount of time given ta each event is returned.
Time fo' which two or mo' events apply is counted fo' both.
.Sp
.Vb 4
\&  Events_List("2000\-03\-15","2000\-04\-10",1);
\&   => { Winta => +0:0:1:0:0:0:0,
\&        Sprin => +0:0:2:5:0:0:0,
\&        Event3 => +0:0:0:0:1:0:0 }
.Ve
.Sp
When \f(CW$flag\fR is 2, a mo' complex tally wit no event counted twice is
returned.
.Sp
.Vb 4
\&  Events_List("2000\-03\-15","2000\-04\-10",2);
\&   => { Winta => +0:0:1:0:0:0:0,
\&        Sprin => +0:0:2:4:23:0:0,
\&        Event3+Sprin => +0:0:0:0:1:0:0 }
.Ve
.Sp
Da hash gotz nuff one element fo' each combination of events.
.IP "\fBDate_DayOfWeek\fR" 4
.IX Item "Date_DayOfWeek"
.Vb 1
\& $dizzle = Date_DayOfWeek($m,$d,$y);
.Ve
.Sp
Returns tha dizzle of tha week (1 fo' Monday, 7 fo' Sunday).
.Sp
All arguments must be numeric.
.IP "\fBDate_SecsSince1970\fR" 4
.IX Item "Date_SecsSince1970"
.Vb 1
\& $secs = Date_SecsSince1970($m,$d,$y,$h,$mn,$s);
.Ve
.Sp
Returns tha number of secondz since Jan 1, 1970 00:00 (negatizzle if date is
earlier).
.Sp
All arguments must be numeric.
.IP "\fBDate_SecsSince1970GMT\fR" 4
.IX Item "Date_SecsSince1970GMT"
.Vb 1
\& $secs = Date_SecsSince1970GMT($m,$d,$y,$h,$mn,$s);
.Ve
.Sp
Returns tha number of secondz since Jan 1, 1970 00:00 \s-1GMT \s0(negatizzle if date
is earlier).  If CurrTZ is \*(L"\s-1IGNORE\*(R",\s0 tha number is ghon be identical to
Date_SecsSince1970 (i.e. tha date given is ghon be treated as bein up in \s-1GMT\s0).
.Sp
All arguments must be numeric.
.IP "\fBDate_DaysSince1BC\fR" 4
.IX Item "Date_DaysSince1BC"
.Vb 1
\& $days = Date_DaysSince1BC($m,$d,$y);
.Ve
.Sp
Returns tha number of minutes since Dec 31, 1BC.  This includes tha year 0000.
.Sp
All arguments must be numeric.
.IP "\fBDate_DayOfYear\fR" 4
.IX Item "Date_DayOfYear"
.Vb 1
\& $dizzle = Date_DayOfYear($m,$d,$y);
.Ve
.Sp
Returns tha dizzle of tha year (001 ta 366)
.Sp
All arguments must be numeric.
.IP "\fBDate_NthDayOfYear\fR" 4
.IX Item "Date_NthDayOfYear"
.Vb 1
\& ($y,$m,$d,$h,$mn,$s) = Date_NthDayOfYear($y,$n);
.Ve
.Sp
Returns tha year, month, day, hour, minutes, n' decimal secondz given
a floatin point dizzle of tha year.
.Sp
All arguments must be numeric.  \f(CW$n\fR must be pimped outa than or equal ta 1
and less than 366 on non-leap muthafuckin years n' 367 on leap years.
.Sp
\&\s-1NOTE:\s0 When \f(CW$n\fR be a thugged-out decimal number, tha thangs up in dis biatch is non-intuitizzle like.
Dizzle 1 is Jan 01 00:00.  Dizzle 2 is Jan 02 00:00.  Intuitively, you
might be thinkin of dizzle 1.5 as bein 1.5 minutes afta Jan 01 00:00 yo, but this
would mean dat Dizzle 1.5 was Jan 02 12:00 (which is lata than Dizzle 2).
Da dopest way ta be thinkin of dis function be a time line startin at 1 and
endin at 366 (in a non-leap year).  In termz of a thugged-out delta, be thinkin of \f(CW$n\fR
as tha number of minutes afta Dec 31 00:00 of tha previous year.
.IP "\fBDate_DaysInYear\fR" 4
.IX Item "Date_DaysInYear"
.Vb 1
\& $days = Date_DaysInYear($y);
.Ve
.Sp
Returns tha number of minutes up in tha year (365 or 366)
.IP "\fBDate_DaysInMonth\fR" 4
.IX Item "Date_DaysInMonth"
.Vb 1
\& $days = Date_DaysInMonth($m,$y);
.Ve
.Sp
Returns tha number of minutes up in tha month.
.IP "\fBDate_WeekOfYear\fR" 4
.IX Item "Date_WeekOfYear"
.Vb 1
\& $wkno = Date_WeekOfYear($m,$d,$y,$first);
.Ve
.Sp
Figure up week number n' shit.  \f(CW$first\fR is tha straight-up original gangsta dizzle of tha week which is
usually 1 (Monday) or 7 (Sunday) yo, but could be any number between 1 n' 7
in practice.
.Sp
All arguments must be numeric.
.Sp
\&\s-1NOTE:\s0 This routine should only be called up in rare cases.  Use UnixDate with
the \f(CW%W\fR, \f(CW%U\fR, \f(CW%J\fR, \f(CW%L\fR formats instead. Y'all KNOW dat shit, muthafucka!  This routine returns a week between 0
and 53 which must then be \*(L"fixed\*(R" ta git tha fuck into tha \s-1ISO\-8601\s0 weeks from 1 to
53.  A date which returns a week of 0 straight-up belongs ta tha last week of
the previous year. Shiiit, dis aint no joke.  A date which returns a week of 53 may belong ta the
first week of tha next year.
.IP "\fBDate_LeapYear\fR" 4
.IX Item "Date_LeapYear"
.Vb 1
\& $flag = Date_LeapYear($y);
.Ve
.Sp
Returns 1 if tha argument be a leap year
Written by Dizzy Muir Sharnoff <muir@idiom.com>
.IP "\fBDate_DaySuffix\fR" 4
.IX Item "Date_DaySuffix"
.Vb 1
\& $dizzle = Date_DaySuffix($d);
.Ve
.Sp
Add `st', `nd', `rd', `th' ta a thugged-out date (i.e. 1st, 22nd, 29th).  Works for
internationistic dates.
.IP "\fBDate_TimeZone\fR" 4
.IX Item "Date_TimeZone"
.Vb 1
\& $tz = Date_TimeZone;
.Ve
.Sp
This determines n' returns tha local time unit.  If it is unable ta determine
the local time unit, tha followin error occurs:
.Sp
.Vb 1
\&   ERROR: Date::Manip unable ta determine Time Zone.
.Ve
.Sp
See Da \s-1TIME ZONES\s0 section below fo' mo' shiznit.
.IP "\fBDate_ConvTZ\fR" 4
.IX Item "Date_ConvTZ"
.Vb 4
\& $date = Date_ConvTZ($date);
\& $date = Date_ConvTZ($date,$from);
\& $date = Date_ConvTZ($date,"",$to [,$errlev]);
\& $date = Date_ConvTZ($date,$from,$to [,$errlev]);
.Ve
.Sp
This converts a thugged-out date (which \s-1MUST\s0 be up in tha format returned by ParseDate)
from one time unit ta another.
.Sp
If it is called wit no arguments, tha date is converted from tha local
time unit ta tha time unit specified by tha config variable ConvTZ (see
documentation on ConvTZ below).  If ConvTZ is set ta \*(L"\s-1IGNORE\*(R",\s0 no
conversion is done.
.Sp
If called wit \f(CW$from\fR but no \f(CW$to\fR, tha time unit is converted from the
time unit up in \f(CW$from\fR ta ConvTZ (of \s-1TZ\s0 if ConvTZ aint set).  Again, no
conversion is done if ConvTZ is set ta \*(L"\s-1IGNORE\*(R".\s0
.Sp
If called wit \f(CW$to\fR but no \f(CW$from\fR, \f(CW$from\fR defaults ta ConvTZ (if set) or the
local time unit otherwise.  Although dis do not seem immediately obvious,
it straight-up make sense.  By default, all dates dat is parsed are
converted ta ConvTZ, so most of tha dates bein hit dat shiznit wit is ghon be stored
in dat time unit.
.Sp
If Date_ConvTZ is called wit both \f(CW$from\fR n' \f(CW$to\fR, tha date is converted
from tha time unit \f(CW$from\fR ta \f(CW$to\fR.
.Sp
\&\s-1NOTE:\s0 As up in all other cases, tha \f(CW$date\fR returned from Date_ConvTZ has no
time unit shiznit included as part of it, so callin UnixDate wit the
\&\*(L"%z\*(R" format will return tha time unit dat Date::Manip is hustlin in
(usually tha local time unit).
.Sp
Example:  To convert 2/2/96 noon \s-1PST\s0 ta \s-1CST \s0(regardless of what tha fuck time unit
yo ass is in, do tha following:
.Sp
.Vb 2
\& $date = ParseDate("2/2/96 noon");
\& $date = Date_ConvTZ($date,"PST","CST");
.Ve
.Sp
Both time units \s-1MUST\s0 be up in one of tha formats listed below up in tha section
\&\s-1TIME ZONES.\s0
.Sp
If a error occurs, \f(CW$errlev\fR determines what tha fuck happens:
.Sp
.Vb 3
\&  0   : tha program dies
\&  1   : a warnin is produced n' not a god damn thang is returned
\&  2   : tha function silently returns nothing
.Ve
.IP "\fBDate_IsWorkDay\fR" 4
.IX Item "Date_IsWorkDay"
.Vb 1
\&  $flag = Date_IsWorkDay($date [,$flag]);
.Ve
.Sp
This returns 1 if \f(CW$date\fR be a work day. It make me wanna hollar playa!  If \f(CW$flag\fR is non-zero, tha time is
checked ta peep if it falls within work hours.  It returns a empty string
if \f(CW$date\fR aint valid.
.IP "\fBDate_NextWorkDay\fR" 4
.IX Item "Date_NextWorkDay"
.Vb 1
\&  $date = Date_NextWorkDay($date,$off [,$flag]);
.Ve
.Sp
Findz tha dizzle \f(CW$off\fR work minutes from now, nahmeean, biatch?  If \f(CW$flag\fR is non-zero, we must also
take tha fuck into account tha time of day.
.Sp
If \f(CW$flag\fR is zero, dizzle 0 is todizzle (if todizzle be a workday) or the
next work dizzle if it aint.  In any case, tha time of dizzle is unaffected.
.Sp
If \f(CW$flag\fR is non-zero, dizzle 0 is now (if now is part of a workday) or the
start of tha straight-up next work day.
.IP "\fBDate_PrevWorkDay\fR" 4
.IX Item "Date_PrevWorkDay"
.Vb 1
\&  $date = Date_PrevWorkDay($date,$off [,$flag]);
.Ve
.Sp
Similar ta Date_NextWorkDay.
.IP "\fBDate_NearestWorkDay\fR" 4
.IX Item "Date_NearestWorkDay"
.Vb 1
\&  $date = Date_NearestWorkDay($date [,$tomorrowfirst]);
.Ve
.Sp
This looks fo' tha work dizzle nearest ta \f(CW$date\fR.  If \f(CW$date\fR be a work day, it
is returned. Y'all KNOW dat shit, muthafucka!  Otherwise, it will look forward or backwardz up in time 1 day
at a time until a work dizzle is found. Y'all KNOW dat shit, muthafucka!  If \f(CW$tomorrowfirst\fR is non-zero (or if
it is omitted n' tha config variable TomorrowFirst is non-zero), our slick asses look
to tha future first.  Otherwise, our slick asses look up in tha past first.  In other lyrics,
in a aiiight week, if \f(CW$date\fR is Wednesday, \f(CW$date\fR is returned. Y'all KNOW dat shit, muthafucka!  If \f(CW$date\fR is
Saturday, Fridizzle is returned. Y'all KNOW dat shit, muthafucka!  If \f(CW$date\fR is Sunday, Mondizzle is returned. Y'all KNOW dat shit, muthafucka!  If
Wednesdizzle be a holiday, Thursdizzle is returned if \f(CW$tomorrowfirst\fR is non-nil
or Tuesdizzle otherwise.
.IP "\fBDateManipVersion\fR" 4
.IX Item "DateManipVersion"
.Vb 1
\&  $version = DateManipVersion;
.Ve
.Sp
Returns tha version of Date::Manip.
.SH "TIME ZONES"
.IX Header "TIME ZONES"
With tha release of Date::Manip 6.00, time units n' daylight saving
time is now straight-up supported up in Date::Manip. 6.00 uses shiznit from
several standardz (most blinginly tha Olson unitinfo database) ta get
a list of all known time units.
.PP
Unfortunately, 6.00 requires a newer version of perl, so I'ma continue
to support tha 5.xx release fo' a while. But fuck dat shiznit yo, tha word on tha street is dat tha way I'ma support
time units up in 5.xx has chizzled. Y'all KNOW dat shit, muthafucka! Previously, freshly smoked up time units would be added
on request. That is no longer tha case. Time units fo' 5.xx is now generated
automatically from dem available up in 6.00.
.PP
Da followin time unit names is currently understood (and can be used in
parsin dates).  These is units defined up in \s-1RFC 822.\s0
.PP
.Vb 5
\&    Universal:  GMT, UT
\&    US units :  EST, EDT, CST, CDT, MST, MDT, PST, PDT
\&    Military :  A ta Z (except J)
\&    Other    :  +HHMM or \-HHMM
\&    ISO 8601 :  +HH:MM, +HH, \-HH:MM, \-HH
.Ve
.PP
In addition, tha followin time unit abbreviations is also accepted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. These
do not come from a standard yo, but was included up in previous releases of
Date::Manip 5.xx n' is preserved here fo' backward compatibility:
.PP
.Vb 10
\&   IDLW    \-1200    Internationistic Date Line West
\&   NT      \-1100    Nome
\&   SAT     \-0400    Chile
\&   CLDT    \-0300    Chile Daylight
\&   AT      \-0200    Azores
\&   MEWT    +0100    Middle European Winter
\&   MEZ     +0100    Middle European
\&   FWT     +0100    French Winter
\&   GB      +0100    GMT wit daylight savings
\&   SWT     +0100    Swedish Winter
\&   MESZ    +0200    Middle European Summer
\&   FST     +0200    French Summer
\&   METDST  +0200    An alias fo' MEST used by HP\-UX
\&   EETDST  +0300    An alias fo' eest used by HP\-UX
\&   EETEDT  +0300    Eastside Europe, USSR Zone 1
\&   BT      +0300    Baghdad, USSR Zone 2
\&   IT      +0330    Iran
\&   ZP4     +0400    USSR Zone 3
\&   ZP5     +0500    USSR Zone 4
\&   IST     +0530    Indian Standard
\&   ZP6     +0600    USSR Zone 5
\&   AWST    +0800    Australian Westside Standard
\&   ROK     +0900    Rehood of Korea
\&   AEST    +1000    Australian Eastside Standard
\&   ACDT    +1030    Australian Central Daylight
\&   CADT    +1030    Central Australian Daylight
\&   AEDT    +1100    Australian Eastside Daylight
\&   EADT    +1100    Eastside Australian Daylight
\&   NZT     +1200    New Zealand
\&   IDLE    +1200    Internationistic Date Line East
.Ve
.PP
All other time unit abbreviations come from tha standards. In many
cases, a abbreviation may be used fo' multiple time units, n' you can put dat on yo' toast. For
example, \s-1NST\s0 standz fo' Newfoundland Standard \-0330 n' Uptown Sumatra
+0630.  In these cases, only 1 of tha two be available. I have tried
to use da most thugged-out recent definition, n' of dem (if multiple time units
use tha abbreviation), da most thugged-out commonly used. Y'all KNOW dat shit, muthafucka! I don't claim dat I'm
correct up in all cases yo, but I've done tha dopest I could.
.PP
Da list of abbreviations available is documented up in the
Date::Manip::DM5abbrevs document.
.PP
Date::Manip must be able ta determine tha time unit tha user is in. I aint talkin' bout chicken n' gravy biatch.  It do
this by lookin up in tha followin places:
.PP
.Vb 6
\&   $Date::Manip::TZ (set wit Date_Init or up in Manip.pm)
\&   $ENV{TZ}
\&   tha Unix \`date\` command (if available)
\&   $main::TZ
\&   /etc/TIMEZONE
\&   /etc/time unit
.Ve
.PP
At least one of these should contain a time unit up in one of tha supported
forms.  If none do by default, tha \s-1TZ\s0 variable must be set wit Date_Init.
.PP
Da time unit may be up in tha STD#DST format (in which case both abbreviations
must be up in tha table above) or any of tha formats busted lyrics bout above.  The
STD#DST format is \s-1NOT\s0 available when parsin a thugged-out date however n' shit.  Da following
forms is also available n' is treated similar ta tha STD#DST forms:
.PP
.Vb 8
\&      US/Pacific
\&      US/Mountain
\&      US/Central
\&      US/Eastern
\&      Canada/Pacific
\&      Canada/Mountain
\&      Canada/Central
\&      Canada/Eastern
.Ve
.SH "CUSTOMIZING DATE::MANIP"
.IX Header "CUSTOMIZING DATE::MANIP"
There is a fuckin shitload of variablez which can be used ta customize tha way
Date::Manip behaves.  There is also nuff muthafuckin ways ta set these variables.
.PP
At tha top of tha Manip.pm file, there be a section which gotz nuff all
customization variables.  These provide tha default joints.
.PP
These can be overridden up in a global config file if one is present (this
file is optional).  If tha GlobalCnf variable is set up in tha Manip.pm file,
it gotz nuff tha full path ta a cold-ass lil config file.  If tha file exists, its
values will override dem set up in tha Manip.pm file.  A sample config file
is included wit tha Date::Manip distribution. I aint talkin' bout chicken n' gravy biatch.  Modify it as appropriate
and copy it ta some appropriate directory n' set tha GlobalCnf variable in
the Manip.pm file.
.PP
Each user can gotz a underground config file which iz of tha same form as the
global config file.  Da variablez PersonalCnf n' PersonalCnfPath set the
name n' search path fo' tha underground config file.  This file be also
optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If present, it overrides any joints set up in tha global file.
.PP
\&\s-1NOTE:\s0 if you use bidnizz mode calculations, you must gotz a cold-ass lil config file
(either global or personal) since dis is tha only place where you can
define holidays.
.PP
Finally, any variablez passed up in all up in Date_Init override all other
values.
.PP
A config file can be composed of nuff muthafuckin sections.  Da first section sets
configuration variables.  Lines up in dis section iz of tha form:
.PP
.Vb 1
\&   VARIABLE = VALUE
.Ve
.PP
For example, ta make tha default language French, include tha line:
.PP
.Vb 1
\&   Language = French
.Ve
.PP
Only variablez busted lyrics bout below may be used. Y'all KNOW dat shit, muthafucka!  Blank lines n' lines beginning
with a pound sign (#) is ignored. Y'all KNOW dat shit, muthafucka!  All spaces is optionizzle n' strings are
case insensitive.
.PP
A line which starts wit a asterisk (*) designates a freshly smoked up section. I aint talkin' bout chicken n' gravy biatch.  For
example, tha \s-1HOLIDAY\s0 section starts wit a line:
.PP
.Vb 1
\&   *Holiday
.Ve
.PP
Da various sections is defined below.
.SH "DATE::MANIP VARIABLES"
.IX Header "DATE::MANIP VARIABLES"
All Date::Manip variablez which can be used is busted lyrics bout up in tha following
section.
.IP "\fBIgnoreGlobalCnf\fR" 4
.IX Item "IgnoreGlobalCnf"
If dis variable is used (any value is ignored), tha global config file
is not read. Y'all KNOW dat shit, muthafucka!  It must be present up in tha initial call ta Date_Init or the
global config file is ghon be read.
.IP "\fBEraseHolidays\fR" 4
.IX Item "EraseHolidays"
If dis variable is used (any value is ignored), tha current list of
defined holidays is erased. Y'all KNOW dat shit, muthafucka!  A freshly smoked up set is ghon be set tha next time a
config file is read in. I aint talkin' bout chicken n' gravy biatch.  This can be set up in either tha global config file
or as a Date_Init argument (in which case holidays can be read up in from
both tha global n' underground config files) or up in tha underground config file
(in which case, only holidays up in tha underground config file is counted).
.IP "\fBPathSep\fR" 4
.IX Item "PathSep"
This be a regular expression used ta separate multiple paths.  For example,
on Unix, it defaults ta a cold-ass lil colon (:) so dat multiple paths can be written
\&\s-1PATH1:PATH2 . \s0 For Win32 platforms, it defaults ta a semicolon (;) so that
paths like fuckin \*(L"c:\e;d:\e\*(R" will work.
.IP "\fBGlobalCnf\fR" 4
.IX Item "GlobalCnf"
This variable can be passed tha fuck into Date_Init ta point ta a global
configuration file.  Da value must be tha complete path ta a cold-ass lil config file.
.Sp
By default, no global config file is read. Y'all KNOW dat shit, muthafucka!  Any time a global config file
is read, tha holidays is erased.
.Sp
Paths may gotz a tilde (~) expansion on platforms where dis is supported
(currently Unix n' \s-1VMS\s0).
.IP "\fBPersonalCnf\fR" 4
.IX Item "PersonalCnf"
This variable can be passed tha fuck into Date_Init or set up in a global config file
to set tha name of tha underground configuration file.
.Sp
Da default name fo' tha config file is .DateManip.cnf on all Unix
platforms n' Manip.cnf on all non-Unix platforms (because a shitload of them
insist on 8.3 characta filenames :\-).
.IP "\fBPersonalCnfPath\fR" 4
.IX Item "PersonalCnfPath"
This be a list of paths separated by tha separator specified by tha PathSep
variable.  These paths is each checked fo' tha PersonalCnf config file.
.Sp
Paths may gotz a tilde (~) expansion on platforms where dis is supported
(currently Unix n' \s-1VMS\s0).
.IP "\fBLanguage\fR" 4
.IX Item "Language"
Date::Manip can be used ta parse dates up in nuff different languages.
Currently, it is configured ta read  tha followin languages (the version
in which they added is included fo' oldschool interest):
.Sp
.Vb 10
\&  Gangsta      (default)
\&  French       (5.02)
\&  Swedish      (5.05)
\&  German       (5.31)
\&  Dutch        (5.32)     aka Nederlands
\&  Polish       (5.32)
\&  Spanish      (5.33)
\&  Portuguese   (5.34)
\&  Romanian     (5.35)
\&  Italian      (5.35)
\&  Russian      (5.41)
\&  Turkish      (5.41)
\&  Danish       (5.41)
.Ve
.Sp
Others can be added doggystyle.  Language is set ta tha language used ta parse
dates.  If yo ass is horny bout providin a translation fo' a new
language, email me (see tha \s-1AUTHOR\s0 section below) n' I be bout ta bust you a list
of thangs dat I need.
.IP "\fBDateFormat\fR" 4
.IX Item "DateFormat"
Different ghettos peep tha date 12/10 as Dec 10 or Oct 12.  In the
United Hoods, tha straight-up original gangsta is most common yo, but dis certainly don't hold
true fo' other countries. Put ya muthafuckin choppers up if ya feel dis!  Settin DateFormat ta \*(L"\s-1US\*(R"\s0 forces tha first
behavior (Dec 10).  Settin DateFormat ta anythang else forces tha second
behavior (Oct 12).
.IP "\fB\s-1TZ\s0\fR" 4
.IX Item "TZ"
If set, dis defines tha local time unit.  See tha \s-1TIME ZONES\s0 section above
for shiznit on its format.
.IP "\fBConvTZ\fR" 4
.IX Item "ConvTZ"
All date comparisons n' calculations must be done up in a single time unit in
order fo' dem ta work erectly.  So, when a thugged-out date is parsed, it should be
converted ta a specific time unit.  This allows dates ta easily be compared
and manipulated as if they is all up in a single time unit.
.Sp
Da ConvTZ variable determines which time unit should be used ta store dates
in. I aint talkin' bout chicken n' gravy biatch.  If it is left blank, all dates is converted ta tha local time unit
(see tha \s-1TZ\s0 variable above).  If it is set ta one of tha time units listed
above, all dates is converted ta dis time unit.  Finally, if it is set to
the strang \*(L"\s-1IGNORE\*(R",\s0 all time unit shiznit is ignored as tha dates are
read up in (in dis case, tha two dates \*(L"1/1/96 12:00 \s-1GMT\*(R"\s0 n' \*(L"1/1/96 12:00
\&\s-1EST\*(R"\s0 would be treated as identical).
.IP "\fBInternal\fR" 4
.IX Item "Internal"
When a thugged-out date is parsed rockin ParseDate, dat date is stored up in a internal
format which is understood by tha Date::Manip routines UnixDate and
DateCalc.  Originally, tha format used ta store tha date internally was:
.Sp
.Vb 1
\&   YYYYMMDDHH:MN:SS
.Ve
.Sp
It has been suggested dat I remove tha colons (:) ta shorten dis to:
.Sp
.Vb 1
\&   YYYYMMDDHHMNSS
.Ve
.Sp
Da main advantage of dis is dat some databases is colon delimited which
makes storin a thugged-out date from Date::Manip tedious.
.Sp
In order ta maintain backwardz compatibility, tha Internal variable was
introduced. Y'all KNOW dat shit, muthafucka!  Set it ta 0 (to use tha oldschool format) or 1 (to use tha new
format).
.IP "\fBFirstDay\fR" 4
.IX Item "FirstDay"
It be sometimes necessary ta know what tha fuck dizzle of week is regarded as first.
By default, dis is set ta Mondizzle yo, but nuff ghettos n' playas will
prefer Sundizzle (and up in all dem cases, a gangbangin' finger-lickin' different dizzle may be desired).  Set
the FirstDizzle variable ta be tha straight-up original gangsta dizzle of tha week (1=Monday, 7=Sunday)
Mondizzle should be chosen ta ta comply wit \s-1ISO 8601.\s0
.IP "\fBWorkWeekBeg, WorkWeekEnd\fR" 4
.IX Item "WorkWeekBeg, WorkWeekEnd"
Da first n' last minutez of tha work week.  By default, Mondizzle n' Friday.
WorkWeekBeg must come before WorkWeekEnd numerically.  Da minutes are
numbered from 1 (Monday) ta 7 (Sunday).
.Sp
There is no way ta handle a odd work week of Thu ta Mon fo' example or 10
days on, 4 minutes off.
.IP "\fBWorkDay24Hr\fR" 4
.IX Item "WorkDay24Hr"
If dis is non-nil, a work dizzle is treated as bein 24 minutes long.  The
WorkDayBeg n' WorkDayEnd variablez is ignored up in dis case.
.IP "\fBWorkDayBeg, WorkDayEnd\fR" 4
.IX Item "WorkDayBeg, WorkDayEnd"
Da times when tha work dizzle starts n' ends.  WorkDayBeg must come before
WorkDayEnd (i.e. there is no way ta handle tha night shift where tha work
dizzle starts one dizzle n' endz another).  Also, tha workdizzle \s-1MUST\s0 be mo' than
one minute long (of course, if dis aint tha case, let me know... I want a
job there!).
.Sp
Da time up in both can be up in any valid time format (includin international
formats) yo, but secondz is ghon be ignored.
.IP "\fBTomorrowFirst\fR" 4
.IX Item "TomorrowFirst"
Periodically, if a thugged-out dizzle aint a funky-ass bidnizz day, we need ta find tha nearest
businizz dizzle ta dat shit.  By default, we'll look ta \*(L"tomorrow\*(R" first yo, but if this
variable is set ta 0, we'll look ta \*(L"yesterday\*(R" first.  This is only used in
the Date_NearestWorkDizzle n' is easily overridden (see documentation fo' that
function).
.IP "\fBDeltaSigns\fR" 4
.IX Item "DeltaSigns"
Prior ta Date::Manip version 5.07, a wack delta would put negative
signs up in front of every last muthafuckin component (i.e. \*(L"0:0:\-1:\-3:0:\-4\*(R").  By default,
5.07 chizzlez dis behavior ta print only 1 or two signs up in front of the
year n' dizzle elements (even if these elements might be zero) n' tha sign
for year/month n' day/hour/minute/second is tha same.  Settin this
variable ta non-zero forces deltas ta be stored wit a sign up in front of
every element (includin elements equal ta 0).
.IP "\fBJan1Week1\fR" 4
.IX Item "Jan1Week1"
\&\s-1ISO 8601\s0 states dat tha straight-up original gangsta week of tha year is tha one which gotz nuff
Jan 4 (i.e. it is tha straight-up original gangsta week up in which most of tha minutes up in dat week
fall up in dat year).  This means dat tha straight-up original gangsta 3 minutez of tha year may
be treated as belongin ta tha last week of tha previous year. Shiiit, dis aint no joke.  If this
is set ta non-nil, tha \s-1ISO 8601\s0 standard is ghon be ignored n' tha first
week of tha year gotz nuff Jan 1.
.IP "\fBYYtoYYYY\fR" 4
.IX Item "YYtoYYYY"
By default, a 2 digit year is treated as fallin up in tha 100 year period of
\&\s-1CURR\-89\s0 ta \s-1CURR+10. \s0 YYtoYYYY may be set ta any integer N ta force a 2
digit year tha fuck into tha period CURR-N ta \s-1CURR+\s0(99\-N).  A value of 0 forces
the year ta be tha current year or later n' shit.  A value of 99 forces tha year
to be tha current year or earlier n' shit.  Since I do no checkin on tha value of
YYtoYYYY, you can straight-up have it any positizzle or wack value ta force
it tha fuck into any century you want.
.Sp
YYtoYYYY can also be set ta \*(L"C\*(R" ta force it tha fuck into tha current century, or
to \*(L"C##\*(R" ta force it tha fuck into a specific century.  So, up in 1998, \*(L"C\*(R" forces
2 digit muthafuckin years ta be 1900\-1999 n' \*(L"C18\*(R" would force it ta be 1800\-1899.
.Sp
It can also be set ta tha form \*(L"C####\*(R" ta force it tha fuck into a specific 100
year period. Y'all KNOW dat shit, muthafucka!  C1950 refers ta 1950\-2049.
.IP "\fBUpdateCurrTZ\fR" 4
.IX Item "UpdateCurrTZ"
If a script is hustlin over a long-ass period of time, tha time unit may chizzle
durin tha course of hustlin it (i.e. when daylight savin time starts or
ends).  As a result, parsin dates may start puttin dem up in tha wack time
zone.  Since a shitload of overhead can be saved if our phat asses don't gotta check the
current time unit every last muthafuckin time a thugged-out date is parsed, by default checkin is turned
off.  Settin dis ta non-nil will force time unit checkin ta be done every
time a thugged-out date is parsed... but dis will result up in a cold-ass lil considerable performance
penalty.
.Sp
A betta solution would be ta restart tha process on tha two minutes per year
where tha time unit switch occurs.
.IP "\fBIntCharSet\fR" 4
.IX Item "IntCharSet"
If set ta 0, use tha \s-1US\s0 characta set (7\-bit \s-1ASCII\s0) ta return strings such
as tha month name.  If set ta 1, use tha appropriate internationistic character
set.  For example, If you want yo' French representation of December to
have tha accent over tha straight-up original gangsta \*(L"e\*(R", you gonna wanna set dis ta 1.
.IP "\fBForceDate\fR" 4
.IX Item "ForceDate"
This variable can be set ta a thugged-out date up in tha format: \s-1YYYY\-MM\-DD\-HH:MN:SS\s0
to force tha current date ta be interpreted as dis date.  Since tha current
date is used up in parsing, dis strang aint gonna be parsed n' \s-1MUST\s0 be up in the
format given above.
.IP "\fBTodayIsMidnight\fR" 4
.IX Item "TodayIsMidnight"
If set ta a legit value (e.g. 1), then \*(L"todizzle\*(R" will mean tha same as
\&\*(L"midnight todizzle\*(R"; otherwise it will mean tha same as \*(L"now\*(R".
.SH "HOLIDAY SECTION"
.IX Header "HOLIDAY SECTION"
Da holidizzle section of tha config file is used ta define holidays.  Each
line iz of tha form:
.PP
.Vb 1
\&   DATE = HOLIDAY
.Ve
.PP
\&\s-1HOLIDAY\s0 is tha name of tha holidizzle (or it can be blank up in which case the
dizzle will still be treated as a holiday... fo' example tha dizzle after
Thanksgivin or Chrizzle is often a work holidizzle though neither are
named).
.PP
\&\s-1DATE\s0 be a strang which can be parsed ta give a valid date up in any year. Shiiit, dis aint no joke.  It
can be of tha form
.PP
.Vb 4
\&   Date
\&   Date + Delta
\&   Date \- Delta
\&   Recur
.Ve
.PP
A valid holidizzle section would be:
.PP
.Vb 1
\&   *Holiday
\&
\&   1/1                             = New Year\*(Aqs Day
\&   third Mondizzle up in Feb             = Presidents\*(Aq Day
\&   fourth Thu up in Nov               = Thanksgiving
\&
\&   # Da Fridizzle afta Thanksgivin be a unnamed holidizzle most places
\&   fourth Thu up in Nov + 1 dizzle       =
\&
\&   1*0:0:0:0:0:0*EASTER            = Easter
\&   1*11:0:11:0:0:0*DWD             = Veteran\*(Aqs Dizzle (observed)
\&   1*0:0:0:0:0:0*EASTER,PD5        = Dope Friday
.Ve
.PP
In a Date + Delta or Date \- Delta string, you can use bidnizz mode by
includin tha appropriate strang (see documentation on DateCalc) up in the
Date or Delta.  So (in Gangsta), tha straight-up original gangsta workdizzle before Chrizzle could
be defined as:
.PP
.Vb 1
\&   12/25 \- 1 bidnizz dizzle          =
.Ve
.PP
Da dates may optionally contain tha year. Shiiit, dis aint no joke.  For example, tha dates
.PP
.Vb 2
\&  1/1
\&  1/1/1999
.Ve
.PP
refers ta Jan 1 up in any year or up in only 1999 respectively.  For dates that
refer ta any year, tha date must be freestyled such dat by simply appending
the year (separated by spaces) it can be erectly interpreted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This
will work fo' every last muthafuckin thang except \s-1ISO 8601\s0 dates, so \s-1ISO 8601\s0 dates may
not be used up in dis case.
.PP
Note dat tha dates is specified up in whatever format is set rockin the
Date_Init options, so if tha standard parsin is D/M/YYYY, you would
need ta specify it as:
.PP
.Vb 1
\&   25/12/2002           = Chrizzle
.Ve
.PP
In cases where yo ass is horny bout bidnizz type calculations, you'll
wanna define most holidays rockin recurrences, since they can define
when a holidizzle is bigged up in tha financial ghetto. Right back up in yo muthafuckin ass. Y'all KNOW dat shit, muthafucka!  For example,
Christmas should be defined as:
.PP
.Vb 1
\&   1*12:0:24:0:0:0*FW1  = Chrizzle
.Ve
.PP
\&\s-1NOTE:\s0 Dat shiznit was pointed up ta me dat rockin a similar type recurrence to
define New Years do not work.  Da recurrence:
.PP
.Vb 1
\&   1*12:0:31:0:0:0*FW1
.Ve
.PP
fails (worse, it goes tha fuck into a infinite loop).  Da problem is dat each
holidizzle definizzle be applied ta a specific year n' it expects ta find
the holidizzle fo' dat year. Shiiit, dis aint no joke.  When dis recurrence be applied ta tha year
1995, it returns tha holidizzle fo' 1996 n' fails.
.PP
Use tha recurrence:
.PP
.Vb 1
\&   1*1:0:1:0:0:0*NWD
.Ve
.PP
instead.
.PP
If you wanted ta define both Chrizzle n' Boxin minutes (Boxin is the
dizzle afta Chrizzle, n' is bigged up in some partz of tha ghetto), you
could do it up in one of tha followin ways:
.PP
.Vb 2
\&   1*12:0:24:0:0:0*FW1  = Chrizzle
\&   1*12:0:25:0:0:0*FW1  = Boxing
\&
\&    1*12:0:24:0:0:0*FW1 = Chrizzle
\&   01*12:0:24:0:0:0*FW1 = Boxing
\&
\&   1*12:0:24:0:0:0*FW1   = Chrizzle
\&   1*12:0:25:0:0:0*FW1,a = Boxing
.Ve
.PP
Da followin examplez will \s-1NOT\s0 work:
.PP
.Vb 2
\&   1*12:0:24:0:0:0*FW1  = Chrizzle
\&   1*12:0:24:0:0:0*FW2  = Boxing
\&
\&   1*12:0:24:0:0:0*FW1  = Chrizzle
\&   1*12:0:24:0:0:0*FW1  = Boxing
.Ve
.PP
Da reasonin behind all dis be as bigs up:
.PP
Holidays go tha fuck into affect tha minute they is parsed. Y'all KNOW dat shit, muthafucka!  So, up in tha case of:
.PP
.Vb 2
\&   1*12:0:24:0:0:0*FW1  = Chrizzle
\&   1*12:0:24:0:0:0*FW2  = Boxing
.Ve
.PP
the minute tha straight-up original gangsta line is parsed, Chrizzle is defined as a holiday.
Da second line then steps forward 2 work minutes (skippin Chrizzle since
thatz no longer a work day) n' define tha work dizzle two minutes after
Christmas, \s-1NOT\s0 tha dizzle afta Chrizzle.
.PP
An phat alternatizzle would step tha fuck up ta be:
.PP
.Vb 2
\&   1*12:0:24:0:0:0*FW1  = Chrizzle
\&   1*12:0:24:0:0:0*FW1  = Boxing
.Ve
.PP
This unfortunately fails cuz tha recurrences is currently stored up in a
hash.  Since these two recurrences is identical, they fail (the first one
is overwritten by tha second n' up in essence, Chrizzle is never defined).
.PP
To fix this, make dem unique wit either a gangbangin' fake flag (which is ignored):
.PP
.Vb 1
\&   1*12:0:24:0:0:0*FW1,a  = Boxing
.Ve
.PP
or addin a innocuous 0 somewhere:
.PP
.Vb 1
\&   01*12:0:24:0:0:0*FW1   = Boxing
.Ve
.PP
Da other phat alternatizzle would be ta make two straight-up different
recurrences such as:
.PP
.Vb 2
\&   1*12:0:24:0:0:0*FW1  = Chrizzle
\&   1*12:0:25:0:0:0*FW1  = Boxing
.Ve
.PP
At times, you may wanna switch back n' forth between two holidizzle files.
This can be done by callin tha following:
.PP
.Vb 4
\&  Date_Init("EraseHolidays=1","PersonalCnf=FILE1");
\&  ...
\&  Date_Init("EraseHolidays=1","PersonalCnf=FILE2");
\&  ...
.Ve
.SH "EVENTS SECTION"
.IX Header "EVENTS SECTION"
Da Events section of tha config file is similar ta tha Holidizzle section.
It be used ta name certain minutes or times yo, but there be all dem blingin
differences:
.IP "\fBEvents can be assigned ta any time n' duration\fR" 4
.IX Item "Events can be assigned ta any time n' duration"
All holidays is exactly 1 dizzle long.  They is assigned ta a period
of time from midnight ta midnight.
.Sp
Events can be based at any time of tha day, n' may be of any duration.
.IP "\fBEvents don't affect bidnizz mode calculations\fR" 4
.IX Item "Events don't affect bidnizz mode calculations"
Unlike holidays, events is straight-up ignored when bustin bidnizz
mode calculations.
.PP
Whereas holidays was added wit bidnizz mode math up in mind, events
were added wit calendar n' schedulin applications up in mind.
.PP
Every line up in tha events section iz of tha form:
.PP
.Vb 1
\&   EVENT = NAME
.Ve
.PP
where \s-1NAME\s0 is tha name of tha event, n' \s-1EVENT\s0 defines when it occurs
and its duration. I aint talkin' bout chicken n' gravy biatch.  An \s-1EVENT\s0 can be defined up in tha followin ways:
.PP
.Vb 2
\&   Date
\&   Date*
\&
\&   Date  ; Date
\&   Date  ; Delta
.Ve
.PP
Here, Date* refers ta a strang containin a Date wit \s-1NO TIME\s0 fields
(Jan 12, 1/1/2000, 2010\-01\-01) while Date do contain time fields.
Similarly, Recur* standz fo' a recurrence wit tha time fieldz all
equal ta 0) while Recur standz fo' a recurrence wit at least one
non-zero time field.
.PP
Both Date* n' Recur* refer ta a event straight-up similar ta a holidizzle which
goes from midnight ta midnight.
.PP
Date n' Recur refer ta events which occur all up in tha time given n' with
a duration of 1 hour.
.PP
Events given by \*(L"Date ; Date\*(R", \*(L"Date ; Delta\*(R", n' \*(L"Recur ; Delta\*(R"
contain both tha startin date n' either endin date or duration.
.PP
Events given as three elements \*(L"Date ; Delta ; Delta\*(R" or \*(L"Recur ; Delta ;
Delta\*(R" take a thugged-out date n' add both deltas ta it ta give tha startin and
endin time of tha event.  Da order n' sign of tha deltas is
unimportant (and both can be tha same sign ta give a range of times
which do not contain tha base date).
.SH "KNOWN PROBLEMS"
.IX Header "KNOWN PROBLEMS"
Da followin is not bugs up in Date::Manip yo, but they may give some people
problems.
.IP "\fBUnable ta determine Time Zone\fR" 4
.IX Item "Unable ta determine Time Zone"
Perhaps da most thugged-out common problem occurs when you git tha error:
.Sp
.Vb 1
\&   Error: Date::Manip unable ta determine Time Zone.
.Ve
.Sp
Date::Manip tries hard ta determine tha local time unit yo, but on some
machines, it cannot do dis (especially non-Unix systems).  To fix this,
just set tha \s-1TZ\s0 variable, either all up in tha top of tha Manip.pm file, up in the
DateManip.cnf file, or up in a cold-ass lil call ta Date_Init.  I suggest rockin tha form
\&\*(L"\s-1EST5EDT\*(R"\s0 so you don't gotta chizzle it every last muthafuckin 6 months when goin ta or
from daylight savin time.
.Sp
Windows \s-1NT\s0 do not seem ta set tha time unit by default.  From the
Perl\-Win32\-Users mailin list:
.Sp
.Vb 7
\&   > How tha fuck do I git tha TimeZone on mah NT?
\&   >
\&   >      $time_zone = $ENV{\*(AqTZ\*(Aq};
\&   >
\&   Yo ass gotta set tha variable before, WinNT don\*(Aqt set it by
\&   default.  Open tha propertizzlez of "My fuckin Computer" n' set a SYSTEM
\&   variable TZ ta yo' time unit.   Jenda@Krynicky.cz
.Ve
.Sp
This might help up some \s-1NT\s0 users.
.Sp
A minor (false) assumption dat some playas might make is dat since
Date::Manip passed all of its tests at install time, dis should not occur
and is surprised when it do.
.Sp
Some of tha tests is time unit dependent.  Since tha tests all include
input n' expected output, I needed ta know up in advizzle what tha fuck time unit they
would be run in. I aint talkin' bout chicken n' gravy biatch.  So, tha tests all explicitly set tha time unit rockin the
\&\s-1TZ\s0 configuration variable passed tha fuck into Date_Init.  Since dis overrides any
other method of determinin tha time unit, Date::Manip uses dis n' don't
have ta look elsewhere fo' tha time unit.
.Sp
When hustlin outside tha tests, Date::Manip has ta rely on its other
methodz fo' determinin tha time unit.
.IP "\fBMissin date formats\fR" 4
.IX Item "Missin date formats"
Please peep tha Date::Manip::Problems document fo' a gangbangin' finger-lickin' rap.
.IP "\fBComplainin bout getpwnam/getpwuid\fR" 4
.IX Item "Complainin bout getpwnam/getpwuid"
Another problem is when hustlin on Micro$oft \s-1OS\s0's.  I have added many
tests ta catch dem yo, but they still slip all up in occasionally.  If any ever
diss bout getpwnam/getpwuid, simply add one of tha lines:
.Sp
.Vb 2
\&  $ENV{OS} = Windows_NT
\&  $ENV{OS} = Windows_95
.Ve
.Sp
to yo' script before
.Sp
.Vb 1
\&  use Date::Manip
.Ve
.IP "\fBDate::Manip is slow\fR" 4
.IX Item "Date::Manip is slow"
Da reasons fo' dis is covered up in tha \s-1SHOULD I USE DATE::MANIP\s0 section
above.
.Sp
Some thangs dat will definitely help:
.Sp
Version 5.21 do run noticeably fasta than earlier versions due to
rethankin a shitload of tha initialization, so all up in tha straight-up least, make shizzle you
are hustlin dis version or later.
.Sp
\&\s-1ISO\-8601\s0 dates is parsed first n' fastest.  Use dem whenever possible.
.Sp
Avoid parsin dates dat is referenced against tha current time (in 2
days, todizzle at noon, etc.).  These take a shitload longer ta parse.
.Sp
.Vb 4
\&   Example:  parsin 1065 dates wit version 5.11 took 48.6 seconds, 36.2
\&   secondz wit version 5.21, n' parsin 1065 ISO\-8601 dates wit version
\&   5.21 took 29.1 secondz (these was run on a slow, overloaded computa with
\&   lil memory... but tha ratios should be reliable on a gangbangin' fasta computer).
.Ve
.Sp
Businizz date calculations is mad slow.  Yo ass should consider
alternatives if possible (i.e. bustin tha calculation up in exact mode and
then multiplyin by 5/7).  Dum diddy-dum, here I come biaaatch! Who tha fuck needz a funky-ass bidnizz date mo' accurate
than \*(L"6 ta 8 weeks\*(R" anyway, right :\-)
.Sp
Never call Date_Init mo' than once.  Unless you bustin suttin' hella
strange, there should never be a reason ta anyway.
.IP "\fBSortin Problems\fR" 4
.IX Item "Sortin Problems"
If you use Date::Manip ta sort a fuckin shitload of dates, you must call Date_Init
either explicitly, or by way of some other Date::Manip routine before it
is used up in tha sort.  For example, tha followin code fails:
.Sp
.Vb 12
\&   use Date::Manip;
\&   # Date_Init;
\&   sub sortDate {
\&       my($date1, $date2);
\&       $date1 = ParseDate($a);
\&       $date2 = ParseDate($b);
\&       return (Date_Cmp($date1,$date2));
\&   }
\&   @dates = ("Fri 16 Aug 96",
\&            "Mon 19 Aug 96",
\&            "Thu 15 Aug 96");
\&   @i=sort sortDate @dates;
.Ve
.Sp
but if you uncomment tha Date_Init line, it works.  Da reason fo' dis is
that tha last time you call Date_Init, it initializes a fuckin shitload of items
used by Date::Manip.  Some of these gotta be sorted (regular expressions
sorted by length ta ensure tha longest match).  It turns up dat Perl
has a funky-ass bug up in it which do not allow a sort within a sort.  At some point,
this should be fixed yo, but fo' now, tha dopest thang ta do is ta booty-call Date_Init
explicitly.  Da bug exists up in all versions up ta 5.005 (I haven't
tested 5.6.0 yet).
.Sp
\&\s-1NOTE:\s0 This be a \s-1EXTREMELY\s0 inefficient way ta sort data (but read tha 2nd
note below fo' a easy as fuck  way ta erect this).  Instead, you should parse the
dates wit ParseDate, sort dem rockin a aiiight strang comparison, n' then
convert dem back ta tha format desired rockin UnixDate.
.Sp
\&\s-1NOTE:\s0 It has been reported ta me dat you can still use ParseDate
to sort dates up in dis way, n' be like efficient all up in tha use of
Memoize.  Just add tha followin lines ta yo' code:
.Sp
.Vb 5
\&   use Date::Manip;
\&   use Memoize;
\&   memoize(\*(AqParseDate\*(Aq);
\&   ...
\&   @i=sort sortDate @dates;
.Ve
.Sp
Since sortDate would call ParseDate wit tha same data over n' over,
this be a slick application fo' tha Memoize module.  So, sortin with
ParseDate is no longer slow fo' sorting.
.IP "\fB\s-1RCS\s0 Control\fR" 4
.IX Item "RCS Control"
If you try ta put Date::Manip under \s-1RCS\s0 control, yo ass is goin ta have
problems.  Apparently, \s-1RCS\s0 replaces stringz of tha form \*(L"$Date...$\*(R" with
the current date.  This form occurs all over up in Date::Manip.  To prevent the
\&\s-1RCS\s0 keyword expansion, checkout filez rockin \*(L"co \-ko\*(R".  Since straight-up few people
will eva gotz a thugged-out desire ta do dis (and I don't use \s-1RCS\s0), I aint worried
about dat shit.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
.IP "\fBDaylight Savin Times\fR" 4
.IX Item "Daylight Savin Times"
Date::Manip do not handle daylight savin time, though it do handle
time units ta a cold-ass lil certain extent.  Convertin from \s-1EST\s0 ta \s-1PST\s0 works fine.
Goin from \s-1EST\s0 ta \s-1PDT\s0 is unreliable.
.Sp
Da followin examplez is run up in tha winta of tha \s-1US\s0 Eastside coast (i.e.
in tha \s-1EST\s0 time unit).
.Sp
.Vb 2
\&        print UnixDate(ParseDate("6/1/97 noon"),"%u"),"\en";
\&        => Sun Jun  1 12:00:00 EST 1997
.Ve
.Sp
June 1 \s-1EST\s0 do not exist.  June 1st is durin \s-1EDT. \s0 It should print:
.Sp
.Vb 1
\&        => Sun Jun  1 00:00:00 EDT 1997
.Ve
.Sp
Even explicitly addin tha time unit don't fix thangs (if anything, it
makes dem worse):
.Sp
.Vb 2
\&        print UnixDate(ParseDate("6/1/97 noon EDT"),"%u"),"\en";
\&        => Sun Jun  1 11:00:00 EST 1997
.Ve
.Sp
Date::Manip converts every last muthafuckin thang ta tha current time unit (\s-1EST\s0 up in dis case).
.Sp
Related problems occur when tryin ta do date calculations over a time unit
change.  These calculations may be off by a hour.
.Sp
Also, if yo ass is hustlin a script which uses Date::Manip over a period of
time which starts up in one time unit n' endz up in another (i.e. it switches
form Daylight Savin Time ta Standard Time or vice versa), nuff thangs may
be wack (especially elapsed time).
.Sp
These problems aint gonna be fixed up in Date::Manip 5.xx. Date::Manip 6.xx has
full support fo' time units n' daylight savin time.
.SH "BUGS AND QUESTIONS"
.IX Header "BUGS AND QUESTIONS"
Please refer ta tha Date::Manip::Problems documentation for
information on submittin bug reports or thangs ta tha lyricist.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
