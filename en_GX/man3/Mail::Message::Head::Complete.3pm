.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message::Head::Complete 3"
.TH Mail::Message::Head::Complete 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Head::Complete \- tha header of one message
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\& Mail::Message::Head::Complete
\&   be a Mail::Message::Head
\&   be a Mail::Reporter
\&
\& Mail::Message::Head::Complete is extended by
\&   Mail::Message::Head::Partial
\&   Mail::Message::Replace::MailHeader
\&
\& Mail::Message::Head::Complete is realized by
\&   Mail::Message::Head::Delayed
\&   Mail::Message::Head::Subset
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& mah $head = Mail::Message::Head::Complete\->new;
\& See Mail::Message::Head
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
E\-mailz message can be up in various states: unread, partially read, and
fully read. Y'all KNOW dat shit, muthafucka!  Da class stores a message of which all header lines are
known fo' sure.
.SH "OVERLOADED"
.IX Header "OVERLOADED"
.ie n .IP "overload: \fB""""\fR()" 4
.el .IP "overload: \fB``''\fR()" 4
.IX Item "overload: """"()"
See \*(L"\s-1OVERLOADED\*(R"\s0 up in Mail::Message::Head
.IP "overload: \fBbool\fR()" 4
.IX Item "overload: bool()"
See \*(L"\s-1OVERLOADED\*(R"\s0 up in Mail::Message::Head
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBbuild\fR([PAIR|FIELD]\-LIST)" 4
.el .IP "\f(CW$obj\fR\->\fBbuild\fR([PAIR|FIELD]\-LIST)" 4
.IX Item "$obj->build([PAIR|FIELD]-LIST)"
Undefined joints is interpreted as empty field joints, n' therefore skipped.
.ie n .IP "$obj\->\fBclone\fR([NAMES|ARRAY\-OF\-NAMES|REGEXS])" 4
.el .IP "\f(CW$obj\fR\->\fBclone\fR([NAMES|ARRAY\-OF\-NAMES|REGEXS])" 4
.IX Item "$obj->clone([NAMES|ARRAY-OF-NAMES|REGEXS])"
Make a cold-ass lil copy of tha header, optionally limited only ta tha header lines
specified by \s-1NAMES. \s0 See \fIgrepNames()\fR on tha way these fieldz can be
used.
.Sp
example:
.Sp
.Vb 1
\& mah $newhead = $head\->clone(\*(AqSubject\*(Aq, \*(AqReceived\*(Aq);
.Ve
.IP "Mail::Message::Head::Complete\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Message::Head::Complete->new(OPTIONS)"
See \*(L"Constructors\*(R" up in Mail::Message::Head
.SS "Da header"
.IX Subsection "Da header"
.ie n .IP "$obj\->\fBisDelayed\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDelayed\fR()" 4
.IX Item "$obj->isDelayed()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBisEmpty\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisEmpty\fR()" 4
.IX Item "$obj->isEmpty()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBisModified\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisModified\fR()" 4
.IX Item "$obj->isModified()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBknownNames\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBknownNames\fR()" 4
.IX Item "$obj->knownNames()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBmessage\fR([\s-1MESSAGE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmessage\fR([\s-1MESSAGE\s0])" 4
.IX Item "$obj->message([MESSAGE])"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmodified\fR([\s-1BOOLEAN\s0])" 4
.IX Item "$obj->modified([BOOLEAN])"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBnrLines\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnrLines\fR()" 4
.IX Item "$obj->nrLines()"
Return tha number of lines needed ta display dis header (including
the trailin newline)
.ie n .IP "$obj\->\fBorderedFields\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBorderedFields\fR()" 4
.IX Item "$obj->orderedFields()"
See \*(L"Da header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBsize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsize\fR()" 4
.IX Item "$obj->size()"
Return tha number of bytes needed ta display dis header (including
the trailin newline).  On systems which use \s-1CRLF\s0 as line separator,
the number of lines up in tha header (see \fInrLines()\fR) must be added to
find tha actual size up in tha file.
.ie n .IP "$obj\->\fBwrap\fR(\s-1INTEGER\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBwrap\fR(\s-1INTEGER\s0)" 4
.IX Item "$obj->wrap(INTEGER)"
Re-fold all fieldz from tha header ta contain at most \s-1INTEGER\s0 number of
charactas per line.
.Sp
example: re-foldin a header
.Sp
.Vb 1
\& $msg\->head\->wrap(78);
.Ve
.SS "Access ta tha header"
.IX Subsection "Access ta tha header"
.ie n .IP "$obj\->\fBadd\fR(\s-1FIELD\s0 | \s-1LINE\s0 | (\s-1NAME\s0,BODY[,ATTRS]))" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(\s-1FIELD\s0 | \s-1LINE\s0 | (\s-1NAME\s0,BODY[,ATTRS]))" 4
.IX Item "$obj->add(FIELD | LINE | (NAME,BODY[,ATTRS]))"
Add a gangbangin' field ta tha header n' shit.  If a gangbangin' field be added mo' than once, all joints
are stored up in tha header, up in tha order they is added.
.Sp
When a \s-1FIELD\s0 object is specified (some Mail::Message::Field instance), that
will be added. Y'all KNOW dat shit, muthafucka!  Another possibilitizzle is ta specify a raw header \s-1LINE,\s0 or a
header line sickly split-up up in \s-1NAME\s0 n' \s-1BODY,\s0 up in which case the
field constructor is called fo' yo thugged-out ass.
.Sp
\&\s-1LINE\s0 or \s-1BODY\s0 justifications which is terminated by a new-line is considered
to be erectly folded. Y'all KNOW dat shit, muthafucka!  Lines which is not terminated by a new-line will
be folded when needed: new-lines is ghon be added where required. Y'all KNOW dat shit, muthafucka!  It be strongly
advised ta let MailBox do tha foldin fo' yo thugged-out ass.
.Sp
Da return value of dis method is tha Mail::Message::Field object
which is pimped (or was specified).
.Sp
example:
.Sp
.Vb 6
\& mah $head  = Mail::Message::Head\->new;
\& $head\->add(\*(AqSubject: hi!\*(Aq);
\& $head\->add(From => \*(Aqme@home\*(Aq);
\& mah $field = Mail::Message::Field\->new(\*(AqTo: you@there\*(Aq);
\& $head\->add($field);
\& mah Mail::Message::Field $s = $head\->add(Sender => \*(AqI\*(Aq);
.Ve
.ie n .IP "$obj\->\fBaddListGroup\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddListGroup\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addListGroup(OBJECT)"
A \fIlist group\fR be a set of header fieldz which contain data bout a
mailin list which was used ta transmit tha message.  See
Mail::Message::Head::ListGroup fo' details bout tha implementation
of tha \s-1OBJECT.\s0
.Sp
When you gotz a list crew prepared, you can add it lata rockin this
method. Y'all KNOW dat shit, muthafucka!  Yo ass will git yo' private copy of tha list crew data in
return, cuz tha same crew can be used fo' multiple lyrics.
.Sp
example: of addin a list crew ta a header
.Sp
.Vb 2
\& mah $lg = Mail::Message::Head::ListGroup\->new(...);
\& mah $own_lg = $msg\->head\->addListGroup($lg);
.Ve
.ie n .IP "$obj\->\fBaddResentGroup\fR(RESENT\-GROUP|DATA)" 4
.el .IP "\f(CW$obj\fR\->\fBaddResentGroup\fR(RESENT\-GROUP|DATA)" 4
.IX Item "$obj->addResentGroup(RESENT-GROUP|DATA)"
Add a RESENT-GROUP (a Mail::Message::Head::ResentGroup object) to
the header n' shit.  If you specify \s-1DATA,\s0 dat is used ta create such group
first.  If no \f(CW\*(C`Received\*(C'\fR line is specified, it is ghon be pimped
for yo thugged-out ass.
.Sp
These header lines have not a god damn thang ta do wit tha userz sense
of \f(CW\*(C`reply\*(C'\fR or \f(CW\*(C`forward\*(C'\fR actions: these lines trace tha e\-mail
transhiznit mechanism.
.Sp
example:
.Sp
.Vb 2
\& mah $rg = Mail::Message::Head::ResentGroup\->new(head => $head, ...);
\& $head\->addResentGroup($rg);
\&
\& mah $rg = $head\->addResentGroup(From => \*(Aqme\*(Aq);
.Ve
.ie n .IP "$obj\->\fBaddSpamGroup\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddSpamGroup\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addSpamGroup(OBJECT)"
A \fIspam fightin group\fR be a set of header fieldz which gotz nuff data
which is used ta fight spam.  See Mail::Message::Head::SpamGroup
for details bout tha implementation of tha \s-1OBJECT.\s0
.Sp
When you gotz a spam crew prepared, you can add it lata rockin this
method. Y'all KNOW dat shit, muthafucka!  Yo ass will git yo' private copy of tha spam crew data in
return, cuz tha same crew can be used fo' multiple lyrics.
.Sp
example: of addin a spam crew ta a header
.Sp
.Vb 2
\& mah $sg = Mail::Message::Head::SpamGroup\->new(...);
\& mah $own_sg = $msg\->head\->addSpamGroup($sg);
.Ve
.ie n .IP "$obj\->\fBcount\fR(\s-1NAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcount\fR(\s-1NAME\s0)" 4
.IX Item "$obj->count(NAME)"
Count tha number of fieldz wit dis \s-1NAME. \s0 Most fieldz will return 1:
only one occurizzle up in tha header n' shit.  As example, tha \f(CW\*(C`Received\*(C'\fR fields
are probably present mo' than once.
.ie n .IP "$obj\->\fBdelete\fR(\s-1NAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1NAME\s0)" 4
.IX Item "$obj->delete(NAME)"
Remove tha field wit tha specified name.  If tha header contained
multiple lines wit tha same name, they is ghon be replaced all together.
This method simply calls \fIreset()\fR without replacement fields.
\&\s-1READ THE IMPORTANT WARNING IN \s0\fIremoveField()\fR
.ie n .IP "$obj\->\fBget\fR(\s-1NAME\s0 [,INDEX])" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR(\s-1NAME\s0 [,INDEX])" 4
.IX Item "$obj->get(NAME [,INDEX])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBgrepNames\fR([NAMES|ARRAY\-OF\-NAMES|REGEXS])" 4
.el .IP "\f(CW$obj\fR\->\fBgrepNames\fR([NAMES|ARRAY\-OF\-NAMES|REGEXS])" 4
.IX Item "$obj->grepNames([NAMES|ARRAY-OF-NAMES|REGEXS])"
Filta from all header fieldz dem wit names which start will any of the
specified list.  When no names is specified, all fieldz is ghon be returned.
Da list is ordered as they where read from file, or added later.
.Sp
Da \s-1NAMES\s0 is considered regular expressions, n' will all be matched
case insensitizzle n' attached ta tha front of tha strang only.  Yo ass may
also specify one or mo' prepared regexes.
.Sp
example:
.Sp
.Vb 3
\& mah @f  = $head\->grepNames();       # same as $head\->orderedFields
\& mah @f  = $head\->grepNames(\*(AqX\-\*(Aq, \*(AqSubject\*(Aq, \*(Aq);
\& mah @to = $head\->grepNames(\*(AqTo\eb\*(Aq); # will only select To
.Ve
.ie n .IP "$obj\->\fBlistGroup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlistGroup\fR()" 4
.IX Item "$obj->listGroup()"
Returns a \fIlist group\fR description: tha set of headaz which form
the shiznit bout mailin list software used ta transhiznit the
message.  See also \fIaddListGroup()\fR n' \fIremoveListGroup()\fR.
.Sp
example: use of \fIlistGroup()\fR
.Sp
.Vb 4
\& if(my $lg = $msg\->head\->listGroup)
\& {  $lg\->print(\e*STDERR);
\&    $lg\->delete;
\& }
\&
\& $msg\->head\->removeListGroup;
.Ve
.ie n .IP "$obj\->\fBnames\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnames\fR()" 4
.IX Item "$obj->names()"
Returns a gangbangin' full ordered list of known field names, as defined up in the
header n' shit.  Fieldz which was \fIreset()\fR ta be empty will still be
listed here.
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
Print all headaz ta tha specified \s-1FILEHANDLE,\s0 by default tha selected
filehandle.  See \fIprintUndisclosed()\fR ta limit tha headaz ta include
only tha hood headers.
.Sp
example:
.Sp
.Vb 2
\& $head\->print(\e*OUT);
\& $head\->print;
\&
\& mah $fh = IO::File\->new(...);
\& $head\->print($fh);
.Ve
.ie n .IP "$obj\->\fBprintSelected\fR(\s-1FILEHANDLE, \s0(STRING|REGEXP)s)" 4
.el .IP "\f(CW$obj\fR\->\fBprintSelected\fR(\s-1FILEHANDLE, \s0(STRING|REGEXP)s)" 4
.IX Item "$obj->printSelected(FILEHANDLE, (STRING|REGEXP)s)"
Like tha usual \fIprint()\fR, tha header lines is printed ta tha specified
\&\s-1FILEHANDLE. \s0 In dis case, however, only tha fieldz wit names as specified by
\&\s-1STRING \s0(case insensative) or \s-1REGEXP\s0 is printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  They will stay tha in-order
of tha source header.
.Sp
example: printin only a subset of tha fields
.Sp
.Vb 1
\& $head\->printSelected(STDOUT, qw/Subject From To/, qr/^x\e\-(spam|xyz)\e\-/i)
.Ve
.ie n .IP "$obj\->\fBprintUndisclosed\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprintUndisclosed\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->printUndisclosed([FILEHANDLE])"
Like tha usual \fIprint()\fR, tha header lines is printed ta tha specified
\&\s-1FILEHANDLE,\s0 by default tha selected filehandle.  In dis case, however,
\&\f(CW\*(C`Bcc\*(C'\fR n' \f(CW\*(C`Resent\-Bcc\*(C'\fR lines is included.
.ie n .IP "$obj\->\fBremoveContentInfo\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBremoveContentInfo\fR()" 4
.IX Item "$obj->removeContentInfo()"
Remove all body related fieldz from tha header n' shit.  Da header will become
partial.
.ie n .IP "$obj\->\fBremoveField\fR(\s-1FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBremoveField\fR(\s-1FIELD\s0)" 4
.IX Item "$obj->removeField(FIELD)"
Remove tha specified \s-1FIELD\s0 object from tha header n' shit.  This is useful when
there is possible mo' than one fieldz wit tha same name, n' you
need ta remove exactly one of em.  Also gotz a peep \fIdelete()\fR,
\&\fIreset()\fR, n' \fIset()\fR.
.Sp
See also \fIMail::Message::Head::Partial::removeFields()\fR (mind tha 's'
at tha end of tha name), which accepts a strang or regular expression
as argument ta select tha fieldz ta be removed.
.Sp
\&\s-1WARNING WARNING WARNING:\s0 fo' performizzle reasons, tha header administration
uses weak references (see Scalar::Util method \fIweaken()\fR> ta figure-out
which fieldz done been removed. Y'all KNOW dat shit, muthafucka!  A header be a hash of field fo' fast search
and a array of weak references ta remember tha order of tha fields, required
for printing.  If tha field is removed from tha hash, tha weak-ref is set to
undef n' tha field not printed.
.Sp
However... it is easy as fuck  ta disturb dis process.  Example:
 mah \f(CW$msg\fR = ....;                 # subject ref-count = 1 + 0 = 1
 \f(CW$msg\fR\->head\->delete('Subject');  # subject ref-count =     0 = 0: clean-up
 \f(CW$msg\fR\->print;                    # subject don't show: ok
.Sp
But
 mah \f(CW$msg\fR = ....;                 # subject ref-count = 1 + 0 = 1
 mah \f(CW$s\fR = \f(CW$msg\fR\->head\->get('subject'); # ref-count = 1 + 1 + 0 = 2
 \f(CW$msg\fR\->head\->delete('Subject');  # subject ref-count = 1 + 0 = 1: no clean-up
 \f(CW$msg\fR\->print;                    # subject \s-1DOES\s0 show: not ok
 undef \f(CW$s\fR;                       # ref-count becomes 0: clean-up
 \f(CW$msg\fR\->print;                    # subject don't show: ok
.Sp
To avoid tha latta thang, do not catch tha field object yo, but only
the field content.  \s-1SAVE\s0 is all methodz which return tha text:
 mah \f(CW$s\fR = \f(CW$msg\fR\->head\->get('subject')\->body;
 mah \f(CW$s\fR = \f(CW$msg\fR\->head\->get('subject')\->unfoldedBody;
 mah \f(CW$s\fR = \f(CW$msg\fR\->head\->get('subject')\->foldedBody;
 mah \f(CW$s\fR = \f(CW$msg\fR\->head\->get('subject')\->foldedBody;
 mah \f(CW$s\fR = \f(CW$msg\fR\->get('subject');
 mah \f(CW$s\fR = \f(CW$msg\fR\->subject;
 mah \f(CW$s\fR = \f(CW$msg\fR\->string;
.ie n .IP "$obj\->\fBremoveFields\fR(STRING|REGEXP, [STRING|REGEXP, ...])" 4
.el .IP "\f(CW$obj\fR\->\fBremoveFields\fR(STRING|REGEXP, [STRING|REGEXP, ...])" 4
.IX Item "$obj->removeFields(STRING|REGEXP, [STRING|REGEXP, ...])"
Da header object is turned tha fuck into a Mail::Message::Head::Partial object
which has a set of fieldz removed. Y'all KNOW dat shit, muthafucka!  Read bout tha implications n' the
possibilitizzles up in \fIMail::Message::Head::Partial::removeFields()\fR.
.ie n .IP "$obj\->\fBremoveFieldsExcept\fR(STRING|REGEXP, [STRING|REGEXP, ...])" 4
.el .IP "\f(CW$obj\fR\->\fBremoveFieldsExcept\fR(STRING|REGEXP, [STRING|REGEXP, ...])" 4
.IX Item "$obj->removeFieldsExcept(STRING|REGEXP, [STRING|REGEXP, ...])"
Da header object is turned tha fuck into a Mail::Message::Head::Partial object
which has a set of fieldz removed. Y'all KNOW dat shit, muthafucka!  Read bout tha implications n' the
possibilitizzles up in \fIMail::Message::Head::Partial::removeFieldsExcept()\fR.
.ie n .IP "$obj\->\fBremoveListGroup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBremoveListGroup\fR()" 4
.IX Item "$obj->removeListGroup()"
Removes all fieldz related ta mailin list administration at once.
Da header object is turned tha fuck into a Mail::Message::Head::Partial
object.  Read bout tha implications n' tha possibilitizzles in
\&\fIMail::Message::Head::Partial::removeListGroup()\fR.
.ie n .IP "$obj\->\fBremoveResentGroups\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBremoveResentGroups\fR()" 4
.IX Item "$obj->removeResentGroups()"
Removes all resent crews at once.  Da header object is turned into
a Mail::Message::Head::Partial object.  Read bout tha implications n' the
possibilitizzles up in \fIMail::Message::Head::Partial::removeResentGroups()\fR.
.ie n .IP "$obj\->\fBremoveSpamGroups\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBremoveSpamGroups\fR()" 4
.IX Item "$obj->removeSpamGroups()"
Removes all fieldz which was added by various spam detection software
at once.  Da header object is turned tha fuck into a Mail::Message::Head::Partial
object.  Read bout tha implications n' tha possibilitizzles in
\&\fIMail::Message::Head::Partial::removeSpamGroups()\fR.
.ie n .IP "$obj\->\fBresentGroups\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBresentGroups\fR()" 4
.IX Item "$obj->resentGroups()"
Returns a list of Mail::Message::Head::ResentGroup objects which
each represent one intermediate point up in tha messagez transmission in
the order as they step tha fuck up in tha header: da most thugged-out recent one first.
See also \fIaddResentGroup()\fR n' \fIremoveResentGroups()\fR.
.Sp
A resent crew gotz nuff a set of header fieldz whose names start
with \f(CW\*(C`Resent\-*\*(C'\fR.  Before tha straight-up original gangsta \f(CW\*(C`Resent\*(C'\fR line is \fItrace\fR shiznit,
which is composed of a optionizzle \f(CW\*(C`Return\-Path\*(C'\fR field n' a required
\&\f(CW\*(C`Received\*(C'\fR field.
.ie n .IP "$obj\->\fBreset\fR(\s-1NAME, FIELDS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBreset\fR(\s-1NAME, FIELDS\s0)" 4
.IX Item "$obj->reset(NAME, FIELDS)"
Replace tha joints up in tha header fieldz named by \s-1NAME\s0 wit tha joints
specified up in tha list of \s-1FIELDS fo' realz. A\s0 single name can correspond ta multiple
repeated fields.  \s-1READ THE IMPORTANT WARNING IN \s0\fIremoveField()\fR
.Sp
Removin fieldz which is part of one of tha predefined field crews is
not a smart-ass idea.  Yo ass can betta remove these fieldz as group, all
together n' shit.  For instance, tha \f(CW\*(AqReceived\*(Aq\fR lines is part of resent
groups, \f(CW\*(AqX\-Spam\*(Aq\fR is past of a spam group, n' \f(CW\*(C`List\-Post\*(C'\fR belongs
to a list group.  Yo ass can delete a whole crew with
\&\fIMail::Message::Head::FieldGroup::delete()\fR, or wit methodz which
are provided by Mail::Message::Head::Partial.
.Sp
If \s-1FIELDS\s0 is empty, tha correspondin \s-1NAME\s0 fieldz will
be removed. Y'all KNOW dat shit, muthafucka! Da location of removed fieldz up in tha header order will be
remembered. Y'all KNOW dat shit, muthafucka! Fieldz wit tha same name which is added lata will step tha fuck up at
the remembered position. I aint talkin' bout chicken n' gravy biatch.  This is equivalent ta tha \fIdelete()\fR method.
.Sp
example:
.Sp
.Vb 3
\& # reduce number of \*(AqKeywords\*(Aq lines ta last 5)
\& mah @keywordz = $head\->get(\*(AqKeywords\*(Aq);
\& $head\->reset(\*(AqKeywords\*(Aq, @keywords[\-5..\-1]) if @keywordz > 5;
\&
\& # Reduce tha number of Received lines ta only tha last added one.
\& mah @rgs = $head\->resentGroups;
\& shift @rgs;     # keep dis one (lata be added up in front)
\& $_\->delete foreach @rgs;
.Ve
.ie n .IP "$obj\->\fBset\fR(\s-1FIELD\s0 | \s-1LINE\s0 | (\s-1NAME, BODY\s0 [,ATTRS]))" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1FIELD\s0 | \s-1LINE\s0 | (\s-1NAME, BODY\s0 [,ATTRS]))" 4
.IX Item "$obj->set(FIELD | LINE | (NAME, BODY [,ATTRS]))"
Da \f(CW\*(C`set\*(C'\fR method is similar ta tha \fIadd()\fR method, n' takes tha same
options. But fuck dat shiznit yo, tha word on tha street is dat existin joints fo' fieldz is ghon be removed before a new
value be added. Y'all KNOW dat shit, muthafucka!  \s-1READ THE IMPORTANT WARNING IN \s0\fIremoveField()\fR
.ie n .IP "$obj\->\fBspamDetected\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBspamDetected\fR()" 4
.IX Item "$obj->spamDetected()"
Returns whether one of tha spam crews defines a report bout spam.  If there
are not header fieldz up in tha message which relate ta spam-detection
software, \f(CW\*(C`undef\*(C'\fR is returned. Y'all KNOW dat shit, muthafucka!  Da spamgroups which report spam is returned.
.Sp
example:
.Sp
.Vb 1
\& $message\->delete if $message\->spamDetected;
\&
\& call_spamassassin($message)
\&    unless defined $message\->spamDetected;
.Ve
.ie n .IP "$obj\->\fBspamGroups\fR([\s-1NAMES\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBspamGroups\fR([\s-1NAMES\s0])" 4
.IX Item "$obj->spamGroups([NAMES])"
Returns a list of Mail::Message::Head::SpamGroup objects, each collecting
some lines which contain spam fightin shiznit. I aint talkin' bout chicken n' gravy biatch.  When any \s-1NAMES\s0 are
given, then only these crews is returned.
See also \fIaddSpamGroup()\fR n' \fIremoveSpamGroups()\fR.
.Sp
In scalar context, wit exactly one \s-1NAME\s0 specified, dat crew will be
returned. Y'all KNOW dat shit, muthafucka!  With mo' \s-1NAMES\s0 or without \s-1NAMES,\s0 a list is ghon be returned
(which defaults ta tha length of tha list up in scalar context).
.Sp
example: use of \fIlistGroup()\fR
.Sp
.Vb 3
\& mah @sg = $msg\->head\->spamGroups;
\& $sg[0]\->print(\e*STDERR);
\& $sg[\-1]\->delete;
\&
\& mah $sg = $msg\->head\->spamGroups(\*(AqSpamAssassin\*(Aq);
.Ve
.ie n .IP "$obj\->\fBstring\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstring\fR()" 4
.IX Item "$obj->string()"
Returns tha whole header as one scalar (in scalar context) or list
of lines (list context).  Triggers completion.
.ie n .IP "$obj\->\fBstudy\fR(\s-1NAME\s0 [,INDEX])" 4
.el .IP "\f(CW$obj\fR\->\fBstudy\fR(\s-1NAME\s0 [,INDEX])" 4
.IX Item "$obj->study(NAME [,INDEX])"
See \*(L"Access ta tha header\*(R" up in Mail::Message::Head
.SS "Bout tha body"
.IX Subsection "Bout tha body"
.ie n .IP "$obj\->\fBguessBodySize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBguessBodySize\fR()" 4
.IX Item "$obj->guessBodySize()"
See \*(L"Bout tha body\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBguessTimeStamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBguessTimeStamp\fR()" 4
.IX Item "$obj->guessTimeStamp()"
Make a guess bout when tha message was origanally posted, based on the
information found up in tha headerz \f(CW\*(C`Date\*(C'\fR field.
.Sp
For some kindz of folders, \fIMail::Message::guessTimestamp()\fR may produce
a betta result, fo' instizzle by lookin all up in tha modification time of the
file up in which tha message is stored. Y'all KNOW dat shit, muthafucka!  Also some protocols, like \s-1POP\s0 can
supply dat shiznit.
.ie n .IP "$obj\->\fBisMultipart\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisMultipart\fR()" 4
.IX Item "$obj->isMultipart()"
See \*(L"Bout tha body\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBrecvstamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBrecvstamp\fR()" 4
.IX Item "$obj->recvstamp()"
Returns a indication bout when tha message was sent yo, but only rockin the
\&\f(CW\*(C`Date\*(C'\fR field up in tha header as last resort: our phat asses do not trust tha sender of
the message ta specify tha erect date.  See \fItimestamp()\fR when you do
trust tha sender.
.Sp
Many spam ballaz fake a thugged-out date, which mess up tha order of receiving
things.  Da timestamp which is produced is derived from tha Received
headers, if they is present, n' \f(CW\*(C`undef\*(C'\fR otherwise.
.Sp
Da timestamp is encoded as \f(CW\*(C`time\*(C'\fR is on yo' system (see perldoc \-f
time), n' as such usable fo' tha \f(CW\*(C`gmtime\*(C'\fR n' \f(CW\*(C`localtime\*(C'\fR methods.
.Sp
example: of time-sortin foldaz wit received lyrics
.Sp
.Vb 3
\& mah $folda = $mgr\->open(\*(AqInBox\*(Aq);
\& mah @lyrics = sort {$a\->recvstamp <=> $b\->recvstamp}
\&                   $folder\->lyrics;
.Ve
.Sp
example: of time-sortin lyrics of mixed origin
.Sp
.Vb 1
\& mah $folda = $mgr\->open(\*(AqMyFolder\*(Aq);
\&
\& # Pre\-calculate timestamps ta be sorted (for speed)
\& mah @stamps = map { [ ($_\->timestamp || 0), $_ ] }
\&                     $folder\->lyrics;
\&
\& mah @sorted
\&   = map { $_\->[1] }      # git tha message fo' tha stamp
\&       sort {$a\->[0] <=> $b\->[0]}   # stamps is numerics
\&          @stamps;
.Ve
.ie n .IP "$obj\->\fBtimestamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtimestamp\fR()" 4
.IX Item "$obj->timestamp()"
Returns a indication bout when tha message was sent, wit as
lil guessin as possible.  In dis case, tha date as specified by the
sender is trusted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See \fIrecvstamp()\fR when you do not wanna trust the
sender.
.Sp
Da timestamp is encoded as \f(CW\*(C`time\*(C'\fR is
on yo' system (see perldoc \-f time), n' as such usable fo' tha \f(CW\*(C`gmtime\*(C'\fR
and \f(CW\*(C`localtime\*(C'\fR methods.
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBaddNoRealize\fR(\s-1FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddNoRealize\fR(\s-1FIELD\s0)" 4
.IX Item "$obj->addNoRealize(FIELD)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBaddOrderedFields\fR(\s-1FIELDS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddOrderedFields\fR(\s-1FIELDS\s0)" 4
.IX Item "$obj->addOrderedFields(FIELDS)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBcreateFromLine\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcreateFromLine\fR()" 4
.IX Item "$obj->createFromLine()"
For some mail-folda types separate lyrics by a line startin with
\&'\f(CW\*(C`From \*(C'\fR'.  If a message is moved ta such folda from a gangbangin' folder-type
which do not support these separators, dis method is called ta produce
one.
.ie n .IP "$obj\->\fBcreateMessageId\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcreateMessageId\fR()" 4
.IX Item "$obj->createMessageId()"
Creates a message-id fo' dis message.  This method is ghon be run when
a freshly smoked up message is pimped, or a message is discovered without the
message-id header field. Y'all KNOW dat shit, muthafucka!  Message-idz is required fo' detection of
message-threads.  See \fImessageIdPrefix()\fR.
.ie n .IP "$obj\->\fBfileLocation\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfileLocation\fR()" 4
.IX Item "$obj->fileLocation()"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBload\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBload\fR()" 4
.IX Item "$obj->load()"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBmessageIdPrefix\fR([\s-1PREFIX,\s0 [\s-1HOSTNAME\s0]|CODE])" 4
.el .IP "\f(CW$obj\fR\->\fBmessageIdPrefix\fR([\s-1PREFIX,\s0 [\s-1HOSTNAME\s0]|CODE])" 4
.IX Item "$obj->messageIdPrefix([PREFIX, [HOSTNAME]|CODE])"
.PD 0
.IP "Mail::Message::Head::Complete\->\fBmessageIdPrefix\fR([\s-1PREFIX,\s0 [\s-1HOSTNAME\s0]|CODE])" 4
.IX Item "Mail::Message::Head::Complete->messageIdPrefix([PREFIX, [HOSTNAME]|CODE])"
.PD
When options is provided, it sets a freshly smoked up way ta create message-ids,
as used by \fIcreateMessageId()\fR.  Yo ass have two chizzles: either by
providin a \s-1PREFIX\s0 n' optionally a \s-1HOSTNAME,\s0 or a \s-1CODE\s0 reference.
.Sp
Da \s-1CODE\s0 reference is ghon be called wit tha header as first argument.
Yo ass must ensure yo ass dat tha returned value is \s-1RFC\s0 compliant.
.Sp
Da \s-1PREFIX\s0 defaults ta \f(CW\*(C`mailbox\-$$\*(C'\fR, tha \s-1HOSTNAME\s0 defaults ta the
return of Net::Domainss function \f(CW\*(C`hostfqdn()\*(C'\fR, or when not installed,
the Sys::Hostnamez function \f(CW\*(C`hostname()\*(C'\fR.  Inbetween the
two, a nano-second time provided by Time::HiRes is used. Y'all KNOW dat shit, muthafucka!  If that
module aint available, \f(CW\*(C`time\*(C'\fR is called all up in tha start of tha program,
and incremented fo' each newly pimped id.
.Sp
In any case, a subroutine is ghon be pimped ta be used. Y'all KNOW dat shit, muthafucka!  A reference
to dat is ghon be returned. Y'all KNOW dat shit, muthafucka!  When tha method is called without arguments,
but no subroutine is defined yet, one is ghon be pimped.
.Sp
example: settin a message prefix
.Sp
.Vb 3
\&  $head\->messageIdPrefix(\*(Aqprefix\*(Aq);
\&  Mail::Message::Head::Complete\->messageIdPrefix(\*(Aqprefix\*(Aq);
\&  mah $code = $head\->messageIdPrefix(\*(Aqmailbox\*(Aq, \*(Aqnohost\*(Aq);
\&
\&  sub new_msgid()
\&  {   mah $head = shift;
\&      "myid\-$$\-${(rand 10000)}@example.com";
\&  }
\&
\&  $many_msg\->messageIdPrefix(\e&new_msgid);
\&  Mail::Message::Head::Complete\->messageIdPrefix(&new_msgid);
.Ve
.ie n .IP "$obj\->\fBmoveLocation\fR(\s-1DISTANCE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBmoveLocation\fR(\s-1DISTANCE\s0)" 4
.IX Item "$obj->moveLocation(DISTANCE)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBread\fR(\s-1PARSER\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR(\s-1PARSER\s0)" 4
.IX Item "$obj->read(PARSER)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.ie n .IP "$obj\->\fBsetNoRealize\fR(\s-1FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBsetNoRealize\fR(\s-1FIELD\s0)" 4
.IX Item "$obj->setNoRealize(FIELD)"
See \*(L"Internals\*(R" up in Mail::Message::Head
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Message::Head::Complete\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Message::Head::Complete->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Message::Head::Complete\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Message::Head::Complete->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Message::Head::Complete\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Message::Head::Complete->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Warning: Cannot remove field $name from header: not found." 4
.el .IP "Warning: Cannot remove field \f(CW$name\fR from header: not found." 4
.IX Item "Warning: Cannot remove field $name from header: not found."
Yo ass ask ta remove a gangbangin' field which aint known up in tha header n' shit.  Using
\&\fIdelete()\fR, \fIreset()\fR, or \fIset()\fR ta do tha thang aint gonna result
in warnings: dem methodz check tha existence of tha field first.
.IP "Warning: Field objects have a implied name ($name)" 4
.IX Item "Warning: Field objects have a implied name ($name)"
.PD 0
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
.PD
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
