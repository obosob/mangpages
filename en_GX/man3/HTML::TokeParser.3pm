.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::TokeParser 3"
.TH HTML::TokeParser 3 "2013-03-25" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::TokeParser \- Alternatizzle HTML::Parser intercourse
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& require HTML::TokeParser;
\& $p = HTML::TokeParser\->new("index.html") ||
\&      take a thugged-out dirtnap "Can\*(Aqt open: $!";
\& $p\->empty_element_tags(1);  # configure its behaviour
\&
\& while (my $token = $p\->get_token) {
\&     #...
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`HTML::TokeParser\*(C'\fR be a alternatizzle intercourse ta the
\&\f(CW\*(C`HTML::Parser\*(C'\fR class.  It be a \f(CW\*(C`HTML::PullParser\*(C'\fR subclass wit a
predeclared set of token types.  If you wish tha tokens ta be reported
differently you probably wanna use tha \f(CW\*(C`HTML::PullParser\*(C'\fR directly.
.PP
Da followin methodz is available:
.ie n .IP "$p = HTML::TokeParser\->new( $filename, %opt );" 4
.el .IP "\f(CW$p\fR = HTML::TokeParser\->new( \f(CW$filename\fR, \f(CW%opt\fR );" 4
.IX Item "$p = HTML::TokeParser->new( $filename, %opt );"
.PD 0
.ie n .IP "$p = HTML::TokeParser\->new( $filehandle, %opt );" 4
.el .IP "\f(CW$p\fR = HTML::TokeParser\->new( \f(CW$filehandle\fR, \f(CW%opt\fR );" 4
.IX Item "$p = HTML::TokeParser->new( $filehandle, %opt );"
.ie n .IP "$p = HTML::TokeParser\->new( \e$document, %opt );" 4
.el .IP "\f(CW$p\fR = HTML::TokeParser\->new( \e$document, \f(CW%opt\fR );" 4
.IX Item "$p = HTML::TokeParser->new( $document, %opt );"
.PD
Da object constructor argument is either a gangbangin' file name, a gangbangin' file handle
object, or tha complete document ta be parsed. Y'all KNOW dat shit, muthafucka!  Extra options can be
provided as key/value pairs n' is processed as documented by tha base
classes.
.Sp
If tha argument be a plain scalar, then it is taken as tha name of a
file ta be opened n' parsed. Y'all KNOW dat shit, muthafucka!  If tha file can't be opened for
reading, then tha constructor will return \f(CW\*(C`undef\*(C'\fR n' $! will tell
you why it failed.
.Sp
If tha argument be a reference ta a plain scalar, then dis scalar is
taken ta be tha literal document ta parse.  Da value of this
scalar should not be chizzled before all tokens done been extracted.
.Sp
Otherwise tha argument is taken ta be some object dat the
\&\f(CW\*(C`HTML::TokeParser\*(C'\fR can \fIread()\fR from when it needz mo' data.  Typically
it is ghon be a gangbangin' filehandle of some kind. Y'all KNOW dat shit, muthafucka!  Da stream is ghon be \fIread()\fR until
\&\s-1EOF,\s0 but not closed.
.Sp
A newly constructed \f(CW\*(C`HTML::TokeParser\*(C'\fR differ from its base classes
by havin tha \f(CW\*(C`unbroken_text\*(C'\fR attribute enabled by default. Right back up in yo muthafuckin ass. See
HTML::Parser fo' a thugged-out description of dis n' other attributes that
influence how tha fuck tha document is parsed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is often a phat scam ta enable
\&\f(CW\*(C`empty_element_tags\*(C'\fR behaviour.
.Sp
Note dat tha parsin result will likely not be valid if raw undecoded
\&\s-1UTF\-8\s0 is used as a source.  When parsin \s-1UTF\-8\s0 encoded filez turn
on \s-1UTF\-8\s0 decoding:
.Sp
.Vb 3
\&   open(my $fh, "<:utf8", "index.html") || take a thugged-out dirtnap "Can\*(Aqt open \*(Aqindex.html\*(Aq: $!";
\&   mah $p = HTML::TokeParser\->new( $fh );
\&   # ...
.Ve
.Sp
If a \f(CW$filename\fR is passed ta tha constructor tha file is ghon be opened in
raw mode n' tha parsin result will only be valid if its content is
Latin\-1 or pure \s-1ASCII.\s0
.Sp
If parsin from a \s-1UTF\-8\s0 encoded strang buffer decode it first:
.Sp
.Vb 3
\&   utf8::decode($document);
\&   mah $p = HTML::TokeParser\->new( \e$document );
\&   # ...
.Ve
.ie n .IP "$p\->get_token" 4
.el .IP "\f(CW$p\fR\->get_token" 4
.IX Item "$p->get_token"
This method will return tha next \fItoken\fR found up in tha \s-1HTML\s0 document,
or \f(CW\*(C`undef\*(C'\fR all up in tha end of tha document.  Da token is returned as an
array reference.  Da first element of tha array is ghon be a string
denotin tha type of dis token: \*(L"S\*(R" fo' start tag, \*(L"E\*(R" fo' end tag,
\&\*(L"T\*(R" fo' text, \*(L"C\*(R" fo' comment, \*(L"D\*(R" fo' declaration, n' \*(L"\s-1PI\*(R"\s0 for
process instructions.  Da rest of tha token array depend on tha type
like this:
.Sp
.Vb 6
\&  ["S",  $tag, $attr, $attrseq, $text]
\&  ["E",  $tag, $text]
\&  ["T",  $text, $is_data]
\&  ["C",  $text]
\&  ["D",  $text]
\&  ["PI", $token0, $text]
.Ve
.Sp
where \f(CW$attr\fR be a hash reference, \f(CW$attrseq\fR be a array reference and
the rest is plain scalars.  Da \*(L"Argspec\*(R" up in HTML::Parser explains the
details.
.ie n .IP "$p\->unget_token( @tokens )" 4
.el .IP "\f(CW$p\fR\->unget_token( \f(CW@tokens\fR )" 4
.IX Item "$p->unget_token( @tokens )"
If you find you have read too nuff tokens you can push dem back,
so dat they is returned tha next time \f(CW$p\fR\->get_token is called.
.ie n .IP "$p\->get_tag" 4
.el .IP "\f(CW$p\fR\->get_tag" 4
.IX Item "$p->get_tag"
.PD 0
.ie n .IP "$p\->get_tag( @tags )" 4
.el .IP "\f(CW$p\fR\->get_tag( \f(CW@tags\fR )" 4
.IX Item "$p->get_tag( @tags )"
.PD
This method returns tha next start or end tag (skippin any other
tokens), or \f(CW\*(C`undef\*(C'\fR if there be no mo' tags up in tha document.  If
one or mo' arguments is given, then we skip tokens until one of the
specified tag types is found. Y'all KNOW dat shit, muthafucka!  For example:
.Sp
.Vb 1
\&   $p\->get_tag("font", "/font");
.Ve
.Sp
will find tha next start or end tag fo' a gangbangin' font-element.
.Sp
Da tag shiznit is returned as a array reference up in tha same form
as fo' \f(CW$p\fR\->get_token above yo, but tha type code (first element) is
missin fo' realz. A start tag is ghon be returned like this:
.Sp
.Vb 1
\&  [$tag, $attr, $attrseq, $text]
.Ve
.Sp
Da tagname of end tags is prefixed wit \*(L"/\*(R", i.e. end tag is
returned like this:
.Sp
.Vb 1
\&  ["/$tag", $text]
.Ve
.ie n .IP "$p\->get_text" 4
.el .IP "\f(CW$p\fR\->get_text" 4
.IX Item "$p->get_text"
.PD 0
.ie n .IP "$p\->get_text( @endtags )" 4
.el .IP "\f(CW$p\fR\->get_text( \f(CW@endtags\fR )" 4
.IX Item "$p->get_text( @endtags )"
.PD
This method returns all text found all up in tha current position. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it will
return a zero length strang if tha next token aint text fo' realz. Any
entitizzles is ghon be converted ta they correspondin character.
.Sp
If one or mo' arguments is given, then we return all text occurring
before tha straight-up original gangsta of tha specified tags found. Y'all KNOW dat shit, muthafucka! For example:
.Sp
.Vb 1
\&   $p\->get_text("p", "br");
.Ve
.Sp
will return tha text up ta either a paragraph of linebreak element.
.Sp
Da text might span tags dat should be \fItextified\fR.  This is
controlled by tha \f(CW$p\fR\->{textify} attribute, which be a hash that
defines how tha fuck certain tags can be treated as text.  If tha name of a
start tag matches a key up in dis hash then dis tag is converted to
text.  Da hash value is used ta specify which tag attribute ta obtain
the text from.  If dis tag attribute is missing, then tha upper case
name of tha tag enclosed up in brackets is returned, e.g. \*(L"[\s-1IMG\s0]\*(R".  The
hash value can also be a subroutine reference.  In dis case the
routine is called wit tha start tag token content as its argument and
the return value is treated as tha text.
.Sp
Da default \f(CW$p\fR\->{textify} value is:
.Sp
.Vb 1
\&  {img => "alt", applet => "alt"}
.Ve
.Sp
This means dat <\s-1IMG\s0> n' <\s-1APPLET\s0> tags is treated as text, n' that
the text ta substitute can be found up in tha \s-1ALT\s0 attribute.
.ie n .IP "$p\->get_trimmed_text" 4
.el .IP "\f(CW$p\fR\->get_trimmed_text" 4
.IX Item "$p->get_trimmed_text"
.PD 0
.ie n .IP "$p\->get_trimmed_text( @endtags )" 4
.el .IP "\f(CW$p\fR\->get_trimmed_text( \f(CW@endtags\fR )" 4
.IX Item "$p->get_trimmed_text( @endtags )"
.PD
Same as \f(CW$p\fR\->get_text above yo, but will collapse any sequencez of white
space ta a single space character n' shit.  Leadin n' trailin white space is
removed.
.ie n .IP "$p\->get_phrase" 4
.el .IP "\f(CW$p\fR\->get_phrase" 4
.IX Item "$p->get_phrase"
This will return all text found all up in tha current posizzle ignorin any
phrasal-level tags.  Text is extracted until tha straight-up original gangsta non
phrasal-level tag.  Textification of tags is tha same ol' dirty as for
\&\fIget_text()\fR.  This method will collapse white space up in tha same way as
\&\fIget_trimmed_text()\fR do.
.Sp
Da definizzle of <i>phrasal\-level tags</i> is obtained from the
HTML::Tagset module.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This example extracts all links from a thugged-out document.  It will print one
line fo' each link, containin tha \s-1URL\s0 n' tha textual description
between tha <A>...</A> tags:
.PP
.Vb 2
\&  use HTML::TokeParser;
\&  $p = HTML::TokeParser\->new(shift||"index.html");
\&
\&  while (my $token = $p\->get_tag("a")) {
\&      mah $url = $token\->[1]{href} || "\-";
\&      mah $text = $p\->get_trimmed_text("/a");
\&      print "$url\et$text\en";
\&  }
.Ve
.PP
This example extract tha <\s-1TITLE\s0> from tha document:
.PP
.Vb 6
\&  use HTML::TokeParser;
\&  $p = HTML::TokeParser\->new(shift||"index.html");
\&  if ($p\->get_tag("title")) {
\&      mah $title = $p\->get_trimmed_text;
\&      print "Title: $title\en";
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTML::PullParser, HTML::Parser
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1998\-2005 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
