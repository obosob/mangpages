" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::map< _Key, _Tp, _Compare, _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef _Rep_type::const_iterator \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef 
.br
_Pair_alloc_type::const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef 
.br
_Pair_alloc_type::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef 
.br
\fB_Rep_type::const_reverse_iterator\fP \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef _Rep_type::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef _Rep_type::iterator \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Compare \fBkey_compare\fP"
.br
.ti -1c
.RI "typedef _Key \fBkey_type\fP"
.br
.ti -1c
.RI "typedef _Tp \fBmapped_type\fP"
.br
.ti -1c
.RI "typedef _Pair_alloc_type::pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Pair_alloc_type::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef \fB_Rep_type::reverse_iterator\fP \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef _Rep_type::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef \fBstd::pair\fP< const _Key, 
.br
_Tp > \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBmap\fP ()"
.br
.ti -1c
.RI "\fBmap\fP (const _Compare &__comp, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBmap\fP (const \fBmap\fP &__x)"
.br
.ti -1c
.RI "\fBmap\fP (\fBmap\fP &&__x) noexcept(\fBis_nothrow_copy_constructible\fP< _Compare >::value)"
.br
.ti -1c
.RI "\fBmap\fP (\fBinitializer_list\fP< \fBvalue_type\fP > __l, const _Compare &__comp=_Compare(), const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBmap\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBmap\fP (_InputIterator __first, _InputIterator __last, const _Compare &__comp, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "mapped_type & \fBat\fP (const key_type &__k)"
.br
.ti -1c
.RI "const mapped_type & \fBat\fP (const key_type &__k) const "
.br
.ti -1c
.RI "iterator \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "const_iterator \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "const_iterator \fBcbegin\fP () const noexcept"
.br
.ti -1c
.RI "const_iterator \fBcend\fP () const noexcept"
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "size_type \fBcount\fP (const key_type &__x) const "
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const noexcept"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> \fBstd::pair\fP< iterator, bool > \fBemplace\fP (_Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. _Args> iterator \fBemplace_hint\fP (const_iterator __pos, _Args &&\&.\&.\&.__args)"
.br
.ti -1c
.RI "bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "iterator \fBend\fP () noexcept"
.br
.ti -1c
.RI "const_iterator \fBend\fP () const noexcept"
.br
.ti -1c
.RI "\fBstd::pair\fP< iterator, iterator > \fBequal_range\fP (const key_type &__x)"
.br
.ti -1c
.RI "\fBstd::pair\fP< const_iterator, 
.br
const_iterator > \fBequal_range\fP (const key_type &__x) const "
.br
.ti -1c
.RI "iterator \fBerase\fP (const_iterator __position)"
.br
.ti -1c
.RI "_GLIBCXX_ABI_TAG_CXX11 iterator \fBerase\fP (iterator __position)"
.br
.ti -1c
.RI "size_type \fBerase\fP (const key_type &__x)"
.br
.ti -1c
.RI "iterator \fBerase\fP (const_iterator __first, const_iterator __last)"
.br
.ti -1c
.RI "iterator \fBfind\fP (const key_type &__x)"
.br
.ti -1c
.RI "const_iterator \fBfind\fP (const key_type &__x) const "
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const noexcept"
.br
.ti -1c
.RI "\fBstd::pair\fP< iterator, bool > \fBinsert\fP (const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "template<typename _Pair , typename  = typename std::enable_if<std::is_constructible<value_type,						    _Pair&&>::value>::type> \fBstd::pair\fP< iterator, bool > \fBinsert\fP (_Pair &&__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBstd::initializer_list\fP< \fBvalue_type\fP > __list)"
.br
.ti -1c
.RI "iterator \fBinsert\fP (const_iterator __position, const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "template<typename _Pair , typename  = typename std::enable_if<std::is_constructible<value_type,						    _Pair&&>::value>::type> iterator \fBinsert\fP (const_iterator __position, _Pair &&__x)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fBinsert\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "key_compare \fBkey_comp\fP () const "
.br
.ti -1c
.RI "iterator \fBlower_bound\fP (const key_type &__x)"
.br
.ti -1c
.RI "const_iterator \fBlower_bound\fP (const key_type &__x) const "
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const noexcept"
.br
.ti -1c
.RI "\fBmap\fP & \fBoperator=\fP (const \fBmap\fP &__x)"
.br
.ti -1c
.RI "\fBmap\fP & \fBoperator=\fP (\fBmap\fP &&__x)"
.br
.ti -1c
.RI "\fBmap\fP & \fBoperator=\fP (\fBinitializer_list\fP< \fBvalue_type\fP > __l)"
.br
.ti -1c
.RI "mapped_type & \fBoperator[]\fP (const key_type &__k)"
.br
.ti -1c
.RI "mapped_type & \fBoperator[]\fP (key_type &&__k)"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const noexcept"
.br
.ti -1c
.RI "size_type \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "void \fBswap\fP (\fBmap\fP &__x)"
.br
.ti -1c
.RI "iterator \fBupper_bound\fP (const key_type &__x)"
.br
.ti -1c
.RI "const_iterator \fBupper_bound\fP (const key_type &__x) const "
.br
.ti -1c
.RI "value_compare \fBvalue_comp\fP () const "
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<typename _K1 , typename _T1 , typename _C1 , typename _A1 > bool \fBoperator<\fP (const \fBmap\fP< _K1, _T1, _C1, _A1 > &, const \fBmap\fP< _K1, _T1, _C1, _A1 > &)"
.br
.ti -1c
.RI "template<typename _K1 , typename _T1 , typename _C1 , typename _A1 > bool \fBoperator==\fP (const \fBmap\fP< _K1, _T1, _C1, _A1 > &, const \fBmap\fP< _K1, _T1, _C1, _A1 > &)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >>class std::map< _Key, _Tp, _Compare, _Alloc >"
A standard container made up of (key,value) pairs, which can be retrieved based on a key, up in logarithmic time\&. 


.PP
\fBTemplate Parameters:\fP
.RS 4
\fI_Key\fP Type of key objects\&. 
.br
\fI_Tp\fP Type of mapped objects\&. 
.br
\fI_Compare\fP Comparison function object type, defaults ta less<_Key>\&. 
.br
\fI_Alloc\fP Allocator type, defaults ta allocator<pair<const _Key, _Tp>\&.
.RE
.PP
Meets tha requirementz of a \fCcontainer\fP, a \fCreversible container\fP, n' a \fCassociatizzle container\fP (usin unique keys)\&. For a \fCmap<Key,T>\fP tha key_type is Key, tha mapped_type is T, n' tha value_type is std::pair<const Key,T>\&.
.PP
Maps support bidirectionizzle iterators\&.
.PP
Da private tree data is declared exactly tha same way fo' map n' multimap; tha distinction is made entirely up in how tha fuck tha tree functions is called (*_unique versus *_equal, same as tha standard)\&. 
.PP
Definizzle at line 96 of file stl_map\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP ()\fC [inline]\fP"

.PP
Default constructor creates no elements\&. 
.PP
Definizzle at line 160 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP (const _Compare &__comp, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Creates a map wit no elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__comp\fP A comparison object\&. 
.br
\fI__a\fP An allocator object\&. 
.RE
.PP

.PP
Definizzle at line 169 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP (const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__x)\fC [inline]\fP"

.PP
Map copy constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A map of identical element n' allocator types\&.
.RE
.PP
Da newly-created map uses a cold-ass lil copy of tha allocation object used by \fI__x\fP\&. 
.PP
Definizzle at line 180 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP (\fBmap\fP< _Key, _Tp, _Compare, _Alloc > &&__x)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Map move constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A map of identical element n' allocator types\&.
.RE
.PP
Da newly-created map gotz nuff tha exact contentz of \fI__x\fP\&. Da contentz of \fI__x\fP is a valid yo, but unspecified map\&. 
.PP
Definizzle at line 191 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP (\fBinitializer_list\fP< \fBvalue_type\fP >__l, const _Compare &__comp = \fC_Compare()\fP, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP"

.PP
Buildz a map from a initializer_list\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list\&. 
.br
\fI__comp\fP A comparison object\&. 
.br
\fI__a\fP An allocator object\&.
.RE
.PP
Smoke a map consistin of copiez of tha elements up in tha initializer_list \fI__l\fP\&. This is linear up in N if tha range be already sorted, n' NlogN otherwise (where N is \fI__l\&.size()\fP)\&. 
.PP
Definizzle at line 206 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename _InputIterator > \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP (_InputIterator__first, _InputIterator__last)\fC [inline]\fP"

.PP
Buildz a map from a range\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&.
.RE
.PP
Smoke a map consistin of copiez of tha elements from [__first,__last)\&. This is linear up in N if tha range be already sorted, n' NlogN otherwise (where N is distance(__first,__last))\&. 
.PP
Definizzle at line 224 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename _InputIterator > \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::\fBmap\fP (_InputIterator__first, _InputIterator__last, const _Compare &__comp, const allocator_type &__a = \fCallocator_type()\fP)\fC [inline]\fP"

.PP
Buildz a map from a range\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP An input iterator\&. 
.br
\fI__last\fP An input iterator\&. 
.br
\fI__comp\fP A comparison functor\&. 
.br
\fI__a\fP An allocator object\&.
.RE
.PP
Smoke a map consistin of copiez of tha elements from [__first,__last)\&. This is linear up in N if tha range be already sorted, n' NlogN otherwise (where N is distance(__first,__last))\&. 
.PP
Definizzle at line 241 of file stl_map\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> mapped_type& \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::at (const key_type &__k)\fC [inline]\fP"

.PP
Access ta map data\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__k\fP Da key fo' which data should be retrieved\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A reference ta tha data whose key is equivalent ta \fI__k\fP, if such a thugged-out data is present up in tha map\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP If no such data is present\&. 
.RE
.PP

.PP
Definizzle at line 501 of file stl_map\&.h\&.
.PP
References std::map< _Key, _Tp, _Compare, _Alloc >::end(), std::map< _Key, _Tp, _Compare, _Alloc >::key_comp(), n' std::map< _Key, _Tp, _Compare, _Alloc >::lower_bound()\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::begin ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write iterator dat points ta tha straight-up original gangsta pair up in tha map\&. Iteration is done up in ascendin order accordin ta tha keys\&. 
.PP
Definizzle at line 320 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::begin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points ta tha straight-up original gangsta pair up in tha map\&. Iteration is done up in ascendin order accordin ta tha keys\&. 
.PP
Definizzle at line 329 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::cbegin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points ta tha straight-up original gangsta pair up in tha map\&. Iteration is done up in ascendin order accordin ta tha keys\&. 
.PP
Definizzle at line 393 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::cend () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points one past tha last pair up in tha map\&. Iteration is done up in ascendin order accordin ta tha keys\&. 
.PP
Definizzle at line 402 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> void \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::clear ()\fC [inline]\fP, \fC [noexcept]\fP"
Erases all elements up in a map\&. Note dat dis function only erases tha elements, n' dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 788 of file stl_map\&.h\&.
.PP
Referenced by std::map< _Key, _Tp, _Compare, _Alloc >::operator=()\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> size_type \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::count (const key_type &__x) const\fC [inline]\fP"

.PP
Findz tha number of elements wit given key\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key of (key, value) pairs ta be located\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of elements wit specified key\&.
.RE
.PP
This function only make sense fo' multimaps; fo' map tha result will either be 0 (not present) or 1 (present)\&. 
.PP
Definizzle at line 848 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_reverse_iterator\fP \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::crbegin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta tha last pair up in tha map\&. Iteration is done up in descendin order accordin ta tha keys\&. 
.PP
Definizzle at line 411 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_reverse_iterator\fP \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::crend () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta one before tha straight-up original gangsta pair up in tha map\&. Iteration is done up in descendin order accordin ta tha keys\&. 
.PP
Definizzle at line 420 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename\&.\&.\&. _Args> \fBstd::pair\fP<iterator, bool> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::emplace (_Args &&\&.\&.\&.__args)\fC [inline]\fP"

.PP
Attempts ta build n' bang a std::pair tha fuck into tha map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__args\fP Arguments used ta generate a freshly smoked up pair instizzle (see std::piecewise_contruct fo' passin arguments ta each part of tha pair constructor)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A pair, of which tha straight-up original gangsta element be a iterator dat points ta tha possibly banged pair, n' tha second be a funky-ass bool dat is legit if tha pair was straight-up inserted\&.
.RE
.PP
This function attempts ta build n' bang a (key, value) pair tha fuck into tha map\& fo' realz. A map relies on unique keys n' thus a pair is only banged if its first element (the key) aint already present up in tha map\&.
.PP
Insertion requires logarithmic time\&. 
.PP
Definizzle at line 540 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename\&.\&.\&. _Args> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::emplace_hint (const_iterator__pos, _Args &&\&.\&.\&.__args)\fC [inline]\fP"

.PP
Attempts ta build n' bang a std::pair tha fuck into tha map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__pos\fP An iterator dat serves as a hint as ta where tha pair should be inserted\&. 
.br
\fI__args\fP Arguments used ta generate a freshly smoked up pair instizzle (see std::piecewise_contruct fo' passin arguments ta each part of tha pair constructor)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha element wit key of tha std::pair built from \fI__args\fP (may or may not be dat std::pair)\&.
.RE
.PP
This function aint concerned bout whether tha insertion took place, n' thus do not return a funky-ass boolean like tha single-argument emplace() do\&. Note dat tha straight-up original gangsta parameta is only a hint n' can potentially improve tha performizzle of tha insertion process\& fo' realz. A wack hint would cause no gains up in efficiency\&.
.PP
See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html fo' mo' on \fIhinting\fP\&.
.PP
Insertion requires logarithmic time (if tha hint aint taken)\&. 
.PP
Definizzle at line 570 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> bool \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::empty () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns legit if tha map is empty\&. (Thus begin() would equal end()\&.) 
.PP
Definizzle at line 429 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::end ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write iterator dat points one past tha last pair up in tha map\&. Iteration is done up in ascendin order accordin ta tha keys\&. 
.PP
Definizzle at line 338 of file stl_map\&.h\&.
.PP
Referenced by std::map< _Key, _Tp, _Compare, _Alloc >::at(), n' std::map< _Key, _Tp, _Compare, _Alloc >::operator[]()\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::end () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) iterator dat points one past tha last pair up in tha map\&. Iteration is done up in ascendin order accordin ta tha keys\&. 
.PP
Definizzle at line 347 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::pair\fP<iterator, iterator> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::equal_range (const key_type &__x)\fC [inline]\fP"

.PP
Findz a subsequence matchin given key\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key of (key, value) pairs ta be located\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pair of iterators dat possibly points ta tha subsequence matchin given key\&.
.RE
.PP
This function is equivalent ta 
.PP
.nf
std::make_pair(c\&.lower_bound(val),
               c\&.upper_bound(val))

.fi
.PP
 (but is fasta than makin tha calls separately)\&.
.PP
This function probably only make sense fo' multimaps\&. 
.PP
Definizzle at line 917 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::pair\fP<const_iterator, const_iterator> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::equal_range (const key_type &__x) const\fC [inline]\fP"

.PP
Findz a subsequence matchin given key\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key of (key, value) pairs ta be located\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pair of read-only (constant) iterators dat possibly points ta tha subsequence matchin given key\&.
.RE
.PP
This function is equivalent ta 
.PP
.nf
std::make_pair(c\&.lower_bound(val),
               c\&.upper_bound(val))

.fi
.PP
 (but is fasta than makin tha calls separately)\&.
.PP
This function probably only make sense fo' multimaps\&. 
.PP
Definizzle at line 936 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::erase (const_iterator__position)\fC [inline]\fP"

.PP
Erases a element from a map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator pointin ta tha element ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator pointin ta tha element immediately followin \fIposition\fP prior ta tha element bein erased\&. If no such element exists, end() is returned\&.
.RE
.PP
This function erases a element, pointed ta by tha given iterator, from a map\&. Note dat dis function only erases tha element, n' dat if tha element is itself a pointer, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 690 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> size_type \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::erase (const key_type &__x)\fC [inline]\fP"

.PP
Erases elements accordin ta tha provided key\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key of element ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da number of elements erased\&.
.RE
.PP
This function erases all tha elements located by tha given key from a map\&. Note dat dis function only erases tha element, n' dat if tha element is itself a pointer, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 726 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::erase (const_iterator__first, const_iterator__last)\fC [inline]\fP"

.PP
Erases a [first,last) range of elements from a map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP Iterator pointin ta tha start of tha range ta be erased\&. 
.br
\fI__last\fP Iterator pointin ta tha end of tha range ta be erased\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Da iterator \fI__last\fP\&.
.RE
.PP
This function erases a sequence of elements from a map\&. Note dat dis function only erases tha element, n' dat if tha element is itself a pointer, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
Definizzle at line 746 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::find (const key_type &__x)\fC [inline]\fP"

.PP
Tries ta locate a element up in a map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key of (key, value) pair ta be located\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator pointin ta sought-afta element, or end() if not found\&.
.RE
.PP
This function takes a key n' tries ta locate tha element wit which tha key matches\&. If successful tha function returns a iterator pointin ta tha sought afta pair\&. If unsuccessful it returns tha past-the-end ( \fCend()\fP ) iterator\&. 
.PP
Definizzle at line 821 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::find (const key_type &__x) const\fC [inline]\fP"

.PP
Tries ta locate a element up in a map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key of (key, value) pair ta be located\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) iterator pointin ta sought-afta element, or end() if not found\&.
.RE
.PP
This function takes a key n' tries ta locate tha element wit which tha key matches\&. If successful tha function returns a cold-ass lil constant iterator pointin ta tha sought afta pair\&. If unsuccessful it returns tha past-the-end ( \fCend()\fP ) iterator\&. 
.PP
Definizzle at line 836 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> allocator_type \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::get_allocator () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Git a cold-ass lil copy of tha memory allocation object\&. 
.PP
Definizzle at line 310 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBstd::pair\fP<iterator, bool> \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::insert (const \fBvalue_type\fP &__x)\fC [inline]\fP"

.PP
Attempts ta bang a std::pair tha fuck into tha map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Pair ta be banged (see std::make_pair fo' easy as fuck  creation of pairs)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A pair, of which tha straight-up original gangsta element be a iterator dat points ta tha possibly banged pair, n' tha second be a funky-ass bool dat is legit if tha pair was straight-up inserted\&.
.RE
.PP
This function attempts ta bang a (key, value) pair tha fuck into tha map\& fo' realz. A map relies on unique keys n' thus a pair is only banged if its first element (the key) aint already present up in tha map\&.
.PP
Insertion requires logarithmic time\&. 
.PP
Definizzle at line 594 of file stl_map\&.h\&.
.PP
Referenced by std::map< _Key, _Tp, _Compare, _Alloc >::insert(), std::map< _Key, _Tp, _Compare, _Alloc >::operator=(), n' std::map< _Key, _Tp, _Compare, _Alloc >::operator[]()\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> void \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::insert (\fBstd::initializer_list\fP< \fBvalue_type\fP >__list)\fC [inline]\fP"

.PP
Attempts ta bang a list of std::pairs tha fuck into tha map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__list\fP A std::initializer_list<value_type> of pairs ta be inserted\&.
.RE
.PP
Complexitizzle similar ta dat of tha range constructor\&. 
.PP
Definizzle at line 615 of file stl_map\&.h\&.
.PP
References std::map< _Key, _Tp, _Compare, _Alloc >::insert()\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::insert (const_iterator__position, const \fBvalue_type\fP &__x)\fC [inline]\fP"

.PP
Attempts ta bang a std::pair tha fuck into tha map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__position\fP An iterator dat serves as a hint as ta where tha pair should be inserted\&. 
.br
\fI__x\fP Pair ta be banged (see std::make_pair fo' easy as fuck  creation of pairs)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
An iterator dat points ta tha element wit key of \fI__x\fP (may or may not be tha pair passed in)\&.
.RE
.PP
This function aint concerned bout whether tha insertion took place, n' thus do not return a funky-ass boolean like tha single-argument insert() do\&. Note dat tha straight-up original gangsta parameta is only a hint n' can potentially improve tha performizzle of tha insertion process\& fo' realz. A wack hint would cause no gains up in efficiency\&.
.PP
See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html fo' mo' on \fIhinting\fP\&.
.PP
Insertion requires logarithmic time (if tha hint aint taken)\&. 
.PP
Definizzle at line 644 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> template<typename _InputIterator > void \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::insert (_InputIterator__first, _InputIterator__last)\fC [inline]\fP"

.PP
Template function dat attempts ta bang a range of elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__first\fP Iterator pointin ta tha start of tha range ta be inserted\&. 
.br
\fI__last\fP Iterator pointin ta tha end of tha range\&.
.RE
.PP
Complexitizzle similar ta dat of tha range constructor\&. 
.PP
Definizzle at line 670 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> key_compare \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::key_comp () const\fC [inline]\fP"
Returns tha key comparison object outta which tha map was constructed\&. 
.PP
Definizzle at line 797 of file stl_map\&.h\&.
.PP
Referenced by std::map< _Key, _Tp, _Compare, _Alloc >::at(), n' std::map< _Key, _Tp, _Compare, _Alloc >::operator[]()\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::lower_bound (const key_type &__x)\fC [inline]\fP"

.PP
Findz tha beginnin of a subsequence matchin given key\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key of (key, value) pair ta be located\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator pointin ta first element equal ta or pimped outa than key, or end()\&.
.RE
.PP
This function returns tha straight-up original gangsta element of a subsequence of elements dat matches tha given key\&. If unsuccessful it returns a iterator pointin ta tha straight-up original gangsta element dat has a pimped outa value than given key or end() if no such element exists\&. 
.PP
Definizzle at line 863 of file stl_map\&.h\&.
.PP
Referenced by std::map< _Key, _Tp, _Compare, _Alloc >::at(), n' std::map< _Key, _Tp, _Compare, _Alloc >::operator[]()\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::lower_bound (const key_type &__x) const\fC [inline]\fP"

.PP
Findz tha beginnin of a subsequence matchin given key\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key of (key, value) pair ta be located\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) iterator pointin ta first element equal ta or pimped outa than key, or end()\&.
.RE
.PP
This function returns tha straight-up original gangsta element of a subsequence of elements dat matches tha given key\&. If unsuccessful it returns a iterator pointin ta tha straight-up original gangsta element dat has a pimped outa value than given key or end() if no such element exists\&. 
.PP
Definizzle at line 878 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> size_type \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::max_size () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns tha maximum size of tha map\&. 
.PP
Definizzle at line 439 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBmap\fP& \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::operator= (const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__x)\fC [inline]\fP"

.PP
Map assignment operator\&. Da dtor only erases tha elements, n' note dat if tha elements theyselves is pointers, tha pointed-to memory aint touched up in any way\&. Managin tha pointa is tha userz responsibility\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A map of identical element n' allocator types\&.
.RE
.PP
All tha elementz of \fI__x\fP is copied yo, but unlike tha copy constructor, tha allocator object aint copied\&. 
.PP
Definizzle at line 264 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBmap\fP& \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::operator= (\fBmap\fP< _Key, _Tp, _Compare, _Alloc > &&__x)\fC [inline]\fP"

.PP
Map move assignment operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A map of identical element n' allocator types\&.
.RE
.PP
Da contentz of \fI__x\fP is moved tha fuck into dis map (without copying)\&. \fI__x\fP be a valid yo, but unspecified map\&. 
.PP
Definizzle at line 279 of file stl_map\&.h\&.
.PP
References std::map< _Key, _Tp, _Compare, _Alloc >::clear(), n' std::map< _Key, _Tp, _Compare, _Alloc >::swap()\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBmap\fP& \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::operator= (\fBinitializer_list\fP< \fBvalue_type\fP >__l)\fC [inline]\fP"

.PP
Map list assignment operator\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__l\fP An initializer_list\&.
.RE
.PP
This function fills a map wit copiez of tha elements up in tha initializer list \fI__l\fP\&.
.PP
Note dat tha assignment straight-up chizzlez tha map n' dat tha resultin mapz size is tha same ol' dirty as tha number of elements assigned\&. Oldskool data may be lost\&. 
.PP
Definizzle at line 300 of file stl_map\&.h\&.
.PP
References std::map< _Key, _Tp, _Compare, _Alloc >::clear(), n' std::map< _Key, _Tp, _Compare, _Alloc >::insert()\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> mapped_type& \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::operator[] (const key_type &__k)\fC [inline]\fP"

.PP
Subscript ( \fC\fP[] ) access ta map data\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__k\fP Da key fo' which data should be retrieved\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A reference ta tha data of tha (key,data) pair\&.
.RE
.PP
Allows fo' easy as fuck  lookup wit tha subscript ( \fC\fP[] ) operator\&. Returns data associated wit tha key specified up in subscript\&. If tha key do not exist, a pair wit dat key is pimped rockin default joints, which is then returned\&.
.PP
Lookup requires logarithmic time\&. 
.PP
Definizzle at line 456 of file stl_map\&.h\&.
.PP
References std::map< _Key, _Tp, _Compare, _Alloc >::end(), std::map< _Key, _Tp, _Compare, _Alloc >::insert(), std::map< _Key, _Tp, _Compare, _Alloc >::key_comp(), std::map< _Key, _Tp, _Compare, _Alloc >::lower_bound(), n' std::piecewise_construct\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBreverse_iterator\fP \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::rbegin ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write reverse iterator dat points ta tha last pair up in tha map\&. Iteration is done up in descendin order accordin ta tha keys\&. 
.PP
Definizzle at line 356 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_reverse_iterator\fP \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::rbegin () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta tha last pair up in tha map\&. Iteration is done up in descendin order accordin ta tha keys\&. 
.PP
Definizzle at line 365 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBreverse_iterator\fP \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::rend ()\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read/write reverse iterator dat points ta one before tha straight-up original gangsta pair up in tha map\&. Iteration is done up in descendin order accordin ta tha keys\&. 
.PP
Definizzle at line 374 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> \fBconst_reverse_iterator\fP \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::rend () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns a read-only (constant) reverse iterator dat points ta one before tha straight-up original gangsta pair up in tha map\&. Iteration is done up in descendin order accordin ta tha keys\&. 
.PP
Definizzle at line 383 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> size_type \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::size () const\fC [inline]\fP, \fC [noexcept]\fP"
Returns tha size of tha map\&. 
.PP
Definizzle at line 434 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> void \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::swap (\fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__x)\fC [inline]\fP"

.PP
Swaps data wit another map\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP A map of tha same element n' allocator types\&.
.RE
.PP
This exchanges tha elements between two maps up in constant time\&. (It be only swappin a pointer, a integer, n' a instizzle of tha \fCCompare\fP type (which itself is often stateless n' empty), so it should be like fast\&.) Note dat tha global std::swap() function is specialized such dat std::swap(m1,m2) will feed ta dis function\&. 
.PP
Definizzle at line 778 of file stl_map\&.h\&.
.PP
Referenced by std::map< _Key, _Tp, _Compare, _Alloc >::operator=(), n' std::swap()\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::upper_bound (const key_type &__x)\fC [inline]\fP"

.PP
Findz tha end of a subsequence matchin given key\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key of (key, value) pair ta be located\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator pointin ta tha straight-up original gangsta element pimped outa than key, or end()\&. 
.RE
.PP

.PP
Definizzle at line 888 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> const_iterator \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::upper_bound (const key_type &__x) const\fC [inline]\fP"

.PP
Findz tha end of a subsequence matchin given key\&. 
.PP
\fBParameters:\fP
.RS 4
\fI__x\fP Key of (key, value) pair ta be located\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) iterator pointin ta first iterator pimped outa than key, or end()\&. 
.RE
.PP

.PP
Definizzle at line 898 of file stl_map\&.h\&.
.SS "template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>, typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> value_compare \fBstd::map\fP< _Key, _Tp, _Compare, _Alloc >::value_comp () const\fC [inline]\fP"
Returns a value comparison object, built from tha key comparison object outta which tha map was constructed\&. 
.PP
Definizzle at line 805 of file stl_map\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
