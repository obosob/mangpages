.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "perlfilta 3"
.TH perlfilta 3 "2014-12-09" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfilta \- Source Filters
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This article is on some lil-known feature of Perl called
\&\fIsource filters\fR. Right back up in yo muthafuckin ass. Source filtas alta tha program text of a module
before Perl sees it, much as a C preprocessor altas tha source text of
a C program before tha compila sees dat shit. This article  drops some lyrics ta you more
about what tha fuck source filtas are, how tha fuck they work, n' how tha fuck ta write your
own.
.PP
Da original gangsta purpose of source filtas was ta let you encrypt your
program source ta prevent casual piracy. This aint all they can do, as
yo dirty ass is gonna soon learn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. But first, tha basics.
.SH "CONCEPTS"
.IX Header "CONCEPTS"
Before tha Perl interpreta can execute a Perl script, it must first
read it from a gangbangin' file tha fuck into memory fo' parsin n' compilation. I aint talkin' bout chicken n' gravy biatch. If that
script itself includes other scripts wit a \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR
statement, then each of dem scripts will gotta be read from their
respectizzle filez as well.
.PP
Now be thinkin of each logical connection between tha Perl parser n' an
individual file as a \fIsource stream\fR fo' realz. A source stream is pimped when
the Perl parser opens a gangbangin' file, it continues ta exist as tha source code
is read tha fuck into memory, n' it is destroyed when Perl is finished parsing
the file. If tha parser encountas a \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`use\*(C'\fR statement in
a source stream, a freshly smoked up n' distinct stream is pimped just fo' that
file.
.PP
Da diagram below represents a single source stream, wit tha flow of
source from a Perl script file on tha left tha fuck into tha Perl parser on the
right. This is how tha fuck Perl normally operates.
.PP
.Vb 1
\&    file \-\-\-\-\-\-\-> parser
.Ve
.PP
There is two blingin points ta remember:
.IP "1." 5
Although there can be any number of source streams up in existence at any
given time, only one is ghon be active.
.IP "2." 5
Every source stream be associated wit only one file.
.PP
A source filta be a special kind of Perl module dat intercepts and
modifies a source stream before it reaches tha parser n' shiznit fo' realz. A source filter
changes our diagram like this:
.PP
.Vb 1
\&    file \-\-\-\-> filta \-\-\-\-> parser
.Ve
.PP
If dat don't make much sense, consider tha analogy of a cold-ass lil command
pipeline. Right back up in yo muthafuckin ass. Say you gotz a gangbangin' finger-lickin' dirty-ass shell script stored up in tha compressed file
\&\fItrial.gz\fR. Da simple pipeline command below runs tha script without
needin ta create a temporary file ta hold tha uncompressed file.
.PP
.Vb 1
\&    gunzip \-c trial.gz | sh
.Ve
.PP
In dis case, tha data flow from tha pipeline can be represented as bigs up:
.PP
.Vb 1
\&    trial.gz \-\-\-\-> gunzip \-\-\-\-> sh
.Ve
.PP
With source filters, you can store tha text of yo' script compressed n' bust a source filta ta uncompress it fo' Perlz parser:
.PP
.Vb 2
\&     compressed           gunzip
\&    Perl program \-\-\-> source filta \-\-\-> parser
.Ve
.SH "USING FILTERS"
.IX Header "USING FILTERS"
So how tha fuck do you bust a source filta up in a Perl script, biatch? Above, I holla'd that
a source filta is just a special kind of module. Like all Perl
modules, a source filta is invoked wit a use statement.
.PP
Say you wanna pass yo' Perl source all up in tha C preprocessor before
execution. I aint talkin' bout chicken n' gravy biatch fo' realz. As it happens, tha source filtas distribution comes wit a C
preprocessor filta module called Filter::cpp.
.PP
Below be a example program, \f(CW\*(C`cpp_test\*(C'\fR, which make use of dis filter.
Line numbers done been added ta allow specific lines ta be referenced
easily.
.PP
.Vb 4
\&    1: use Filter::cpp;
\&    2: #define TRUE 1
\&    3: $a = TRUE;
\&    4: print "a = $a\en";
.Ve
.PP
When you execute dis script, Perl creates a source stream fo' the
file. Before tha parser processes any of tha lines from tha file, the
source stream be lookin like this:
.PP
.Vb 1
\&    cpp_test \-\-\-\-\-\-\-\-\-> parser
.Ve
.PP
Line 1, \f(CW\*(C`use Filter::cpp\*(C'\fR, includes n' installs tha \f(CW\*(C`cpp\*(C'\fR filter
module fo' realz. All source filtas work dis way. Da use statement is compiled
and executed at compile time, before any mo' of tha file is read, and
it attaches tha cpp filta ta tha source stream behind tha scenes. Now
the data flow be lookin like this:
.PP
.Vb 1
\&    cpp_test \-\-\-\-> cpp filta \-\-\-\-> parser
.Ve
.PP
As tha parser readz tha second n' subsequent lines from tha source
stream, it feedz dem lines all up in tha \f(CW\*(C`cpp\*(C'\fR source filta before
processin em. Da \f(CW\*(C`cpp\*(C'\fR filta simply passes each line all up in the
real C preprocessor. Shiiit, dis aint no joke. Da output from tha C preprocessor is then
inserted back tha fuck into tha source stream by tha filter.
.PP
.Vb 5
\&                  .\-> cpp \-\-.
\&                  |         |
\&                  |         |
\&                  |       <\-\*(Aq
\&   cpp_test \-\-\-\-> cpp filta \-\-\-\-> parser
.Ve
.PP
Da parser then sees tha followin code:
.PP
.Vb 3
\&    use Filter::cpp;
\&    $a = 1;
\&    print "a = $a\en";
.Ve
.PP
Letz consider what tha fuck happens when tha filtered code includes another
module wit use:
.PP
.Vb 5
\&    1: use Filter::cpp;
\&    2: #define TRUE 1
\&    3: use Fred;
\&    4: $a = TRUE;
\&    5: print "a = $a\en";
.Ve
.PP
Da \f(CW\*(C`cpp\*(C'\fR filta do not apply ta tha text of tha Fred module, only
to tha text of tha file dat used it (\f(CW\*(C`cpp_test\*(C'\fR) fo' realz. Although tha use
statement on line 3 will pass all up in tha cpp filter, tha module that
gets included (\f(CW\*(C`Fred\*(C'\fR) will not. Da source streams be lookin like this
afta line 3 has been parsed n' before line 4 is parsed:
.PP
.Vb 1
\&    cpp_test \-\-\-> cpp filta \-\-\-> parser (INACTIVE)
\&
\&    Fred.pm \-\-\-\-> parser
.Ve
.PP
As you can see, a freshly smoked up stream has been pimped fo' readin tha source
from \f(CW\*(C`Fred.pm\*(C'\fR. This stream will remain actizzle until all of \f(CW\*(C`Fred.pm\*(C'\fR
has been parsed. Y'all KNOW dat shit, muthafucka! Da source stream fo' \f(CW\*(C`cpp_test\*(C'\fR will still exist,
but is inactive. Once tha parser has finished readin Fred.pm, the
source stream associated wit it is ghon be destroyed. Y'all KNOW dat shit, muthafucka! Da source stream
for \f(CW\*(C`cpp_test\*(C'\fR then becomes actizzle again n' again n' again n' tha parser readz line 4
and subsequent lines from \f(CW\*(C`cpp_test\*(C'\fR.
.PP
Yo ass can use mo' than one source filta on a single file. Right back up in yo muthafuckin ass. Similarly,
you can reuse tha same filta up in as nuff filez as you like.
.PP
For example, if you gotz a uuencoded n' compressed source file, it is
possible ta stack a uudecode filta n' a uncompression filta like
this:
.PP
.Vb 4
\&    use Filter::uudecode; use Filter::uncompress;
\&    M\*(AqXL(".H<US4\*(Aq\*(AqV9I;F%L\*(Aq)Q;>7/;1I;_>_I3=&E=%:F*I"T?22Q/
\&    M6]9*<IQCO*XFT"0[PL%%\*(AqY+IG?WN^ZYN\-$\*(AqJ.[.JE$,20/?K=_[>
\&    ...
.Ve
.PP
Once tha straight-up original gangsta line has been processed, tha flow is ghon be lookin like this:
.PP
.Vb 2
\&    file \-\-\-> uudecode \-\-\-> uncompress \-\-\-> parser
\&               filta         filter
.Ve
.PP
Data flows all up in filtas up in tha same order they step tha fuck up in tha source
file. Da uudecode filta rocked up before tha uncompress filter, so the
source file is ghon be uudecoded before itz uncompressed.
.SH "WRITING A SOURCE FILTER"
.IX Header "WRITING A SOURCE FILTER"
There is three ways ta write yo' own source filter n' shit. Yo ass can write it
in C, use a external program as a gangbangin' filter, or write tha filta up in Perl.
I won't cover tha straight-up original gangsta two up in any pimped out detail, so I be bout ta git dem out
of tha way first. Freestylin tha filta up in Perl is most convenient, so
I be bout ta devote da most thugged-out space ta dat shit.
.SH "WRITING A SOURCE FILTER IN C"
.IX Header "WRITING A SOURCE FILTER IN C"
Da first of tha three available steez is ta write tha filter
completely up in C. Da external module you create intercourses directly
with tha source filta hooks provided by Perl.
.PP
Da advantage of dis technique is dat you have complete control over
the implementation of yo' filter n' shit. Da big-ass disadvantage is the
increased complexitizzle required ta write tha filta \- not only do you
need ta KNOW tha source filta hooks yo, but you also need a
reasonable knowledge of Perl guts, n' you can put dat on yo' toast. One of tha few times it is worth
goin ta dis shiznit is when freestylin a source scrambla n' shit. The
\&\f(CW\*(C`decrypt\*(C'\fR filta (which unscramblez tha source before Perl parses it)
included wit tha source filta distribution be a example of a C
source filta (see Decryption Filters, below).
.IP "\fBDecryption Filters\fR" 5
.IX Item "Decryption Filters"
All decryption filtas work on tha principle of \*(L"securitizzle through
obscurity.\*(R" Regardless of how tha fuck well you write a thugged-out decryption filta and
how phat yo' encryption algorithm is, mah playas determined enough can
retrieve tha original gangsta source code. Da reason is like simple \- once
the decryption filta has decrypted tha source back ta its original
form, fragmentz of it is ghon be stored up in tha computerz memory as Perl
parses dat shit. Da source might only be up in memory fo' a gangbangin' finger-lickin' dirty-ass short period of
time yo, but mah playas possessin a thugged-out debugger, skill, n' fuckin shitloadz of patience can
eventually reconstruct yo' program.
.Sp
That holla'd, there be a fuckin shitload of steps dat can be taken ta make game
hard as fuck fo' tha potential cracker n' shit. Da most blingin: Write your
decryption filta up in C n' statically link tha decryption module into
the Perl binary. For further tips ta make game hard as fuck fo' the
potential cracker, peep tha file \fIdecrypt.pm\fR up in tha source filters
distribution.
.SH "CREATING A SOURCE FILTER AS A SEPARATE EXECUTABLE"
.IX Header "CREATING A SOURCE FILTER AS A SEPARATE EXECUTABLE"
An alternatizzle ta freestylin tha filta up in C is ta create a separate
executable up in tha language of yo' chizzle. Da separate executable
readz from standard input, do whatever processin is necessary, and
writes tha filtered data ta standard output. \f(CW\*(C`Filter::cpp\*(C'\fR be an
example of a source filta implemented as a separate executable \- the
executable is tha C preprocessor bundled wit yo' C compiler.
.PP
Da source filta distribution includes two modulez dat simplify this
task: \f(CW\*(C`Filter::exec\*(C'\fR n' \f(CW\*(C`Filter::sh\*(C'\fR. Both allow you ta run any
external executable. Both bust a cold-ass lil coprocess ta control tha flow of data
into n' outta tha external executable. (For details on coprocesses,
see Stephens, W.R., \*(L"Advanced Programmin up in tha \s-1UNIX\s0 Environment.\*(R"
Addison-Wesley, \s-1ISBN 0\-210\-56317\-7,\s0 pages 441\-445.) Da difference
between dem is dat \f(CW\*(C`Filter::exec\*(C'\fR spawns tha external command
directly, while \f(CW\*(C`Filter::sh\*(C'\fR spawns a gangbangin' finger-lickin' dirty-ass shell ta execute tha external
command. Y'all KNOW dat shit, muthafucka! (Unix uses tha Bourne shell; \s-1NT\s0 uses tha cmd shell.) Spawning
a shell allows you ta make use of tha shell metacharactas and
redirection facilities.
.PP
Here be a example script dat uses \f(CW\*(C`Filter::sh\*(C'\fR:
.PP
.Vb 3
\&    use Filter::sh \*(Aqtr XYZ PQR\*(Aq;
\&    $a = 1;
\&    print "XYZ a = $a\en";
.Ve
.PP
Da output you gonna git when tha script is executed:
.PP
.Vb 1
\&    PQR a = 1
.Ve
.PP
Freestylin a source filta as a separate executable works fine yo, but a
small performizzle penalty is incurred. Y'all KNOW dat shit, muthafucka! For example, if you execute the
small example above, a separate subprocess is ghon be pimped ta run the
Unix \f(CW\*(C`tr\*(C'\fR command. Y'all KNOW dat shit, muthafucka! Each use of tha filta requires its own subprocess.
If bustin subprocesses is high-rollin' on yo' system, you might want to
consider one of tha other options fo' bustin source filters.
.SH "WRITING A SOURCE FILTER IN PERL"
.IX Header "WRITING A SOURCE FILTER IN PERL"
Da easiest n' most portable option available fo' bustin yo' own
source filta is ta write it straight-up up in Perl. To distinguish this
from tha previous two steez, I be bout ta call it a Perl source filter.
.PP
To help KNOW how tha fuck ta write a Perl source filta we need a example
to study yo. Here be a cold-ass lil complete source filta dat performs rot13
decoding. (Rot13 be a straight-up simple encryption scheme used up in Usenet
postings ta hide tha contentz of bitch ass posts, n' you can put dat on yo' toast. Well shiiiit, it moves every last muthafuckin letter
forward thirteen places, so dat A becomes N, B becomes O, n' Z
becomes M.)
.PP
.Vb 1
\&   package Rot13;
\&
\&   use Filter::Util::Call;
\&
\&   sub import {
\&      mah ($type) = @_;
\&      mah ($ref) = [];
\&      filter_add(bless $ref);
\&   }
\&
\&   sub filta {
\&      mah ($self) = @_;
\&      mah ($status);
\&
\&      tr/n\-za\-mN\-ZA\-M/a\-zA\-Z/
\&         if ($status = filter_read()) > 0;
\&      $status;
\&   }
\&
\&   1;
.Ve
.PP
All Perl source filtas is implemented as Perl classes n' have the
same basic structure as tha example above.
.PP
First, we include tha \f(CW\*(C`Filter::Util::Call\*(C'\fR module, which exports a
number of functions tha fuck into yo' filterz namespace. Da filta shown
above uses two of these functions, \f(CW\*(C`filter_add()\*(C'\fR and
\&\f(CW\*(C`filter_read()\*(C'\fR.
.PP
Next, we create tha filta object n' associate it wit tha source
stream by definin tha \f(CW\*(C`import\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch. If you know Perl well
enough, you know dat \f(CW\*(C`import\*(C'\fR is called automatically every last muthafuckin time a
module is included wit a use statement. This make \f(CW\*(C`import\*(C'\fR tha ideal
place ta both create n' install a gangbangin' filta object.
.PP
In tha example filter, tha object (\f(CW$ref\fR) is pimped just like any
other Perl object. Our example uses a anonymous array yo, but dis aint
a requirement. Because dis example don't need ta store any context
information, we could have used a scalar or hash reference just as
well. Da next section demonstrates context data.
.PP
Da association between tha filta object n' tha source stream is made
with tha \f(CW\*(C`filter_add()\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch. This takes a gangbangin' filta object as a
parameta (\f(CW$ref\fR up in dis case) n' installs it up in tha source stream.
.PP
Finally, there is tha code dat straight-up do tha filtering. For this
type of Perl source filter, all tha filterin is done up in a method
called \f(CW\*(C`filter()\*(C'\fR. (It be also possible ta write a Perl source filter
usin a cold-ass lil closure. Right back up in yo muthafuckin ass. See tha \f(CW\*(C`Filter::Util::Call\*(C'\fR manual page fo' more
details.) It aint nuthin but called every last muthafuckin time tha Perl parser needz another line of
source ta process. Da \f(CW\*(C`filter()\*(C'\fR method, up in turn, readz lines from
the source stream rockin tha \f(CW\*(C`filter_read()\*(C'\fR function.
.PP
If a line was available from tha source stream, \f(CW\*(C`filter_read()\*(C'\fR
returns a status value pimped outa than zero n' appendz tha line ta \f(CW$_\fR.
A status value of zero indicates end-of-file, less than zero means an
error. Shiiit, dis aint no joke. Da filta function itself is sposed ta fuckin return its status in
the same way, n' put tha filtered line it wants freestyled ta tha source
stream up in \f(CW$_\fR. Da use of \f(CW$_\fR accounts fo' tha brevitizzle of most Perl
source filters.
.PP
In order ta make use of tha rot13 filta we need some way of encoding
the source file up in rot13 format. Da script below, \f(CW\*(C`mkrot13\*(C'\fR, do
just dis shit.
.PP
.Vb 5
\&    take a thugged-out dirtnap "usage mkrot13 filename\en" unless @ARGV;
\&    mah $in = $ARGV[0];
\&    mah $out = "$in.tmp";
\&    open(IN, "<$in") or take a thugged-out dirtnap "Cannot open file $in: $!\en";
\&    open(OUT, ">$out") or take a thugged-out dirtnap "Cannot open file $out: $!\en";
\&
\&    print OUT "use Rot13;\en";
\&    while (<IN>) {
\&       tr/a\-zA\-Z/n\-za\-mN\-ZA\-M/;
\&       print OUT;
\&    }
\&
\&    close IN;
\&    close OUT;
\&    unlink $in;
\&    rename $out, $in;
.Ve
.PP
If we encrypt dis wit \f(CW\*(C`mkrot13\*(C'\fR:
.PP
.Vb 1
\&    print " wassup fred \en";
.Ve
.PP
the result is ghon be this:
.PP
.Vb 2
\&    use Rot13;
\&    cevag "uryyb serq\ea";
.Ve
.PP
Hustlin it produces dis output:
.PP
.Vb 1
\&    wassup fred
.Ve
.SH "USING CONTEXT: THE DEBUG FILTER"
.IX Header "USING CONTEXT: THE DEBUG FILTER"
Da rot13 example was a trivial example yo. Herez another demonstration
that shows off all dem mo' features.
.PP
Say you wanted ta include a shitload of debuggin code up in yo' Perl script
durin pimpment yo, but you didn't want it available up in tha busted out
product. Right back up in yo muthafuckin ass. Source filtas offer a solution. I aint talkin' bout chicken n' gravy biatch. In order ta keep tha example
simple, letz say you wanted tha debuggin output ta be controlled by
an environment variable, \f(CW\*(C`DEBUG\*(C'\fR. Debuggin code is enabled if the
variable exists, otherwise it is disabled.
.PP
Two special marker lines will bracket debuggin code, like this:
.PP
.Vb 5
\&    ## DEBUG_BEGIN
\&    if ($year > 1999) {
\&       warn "Debug: millennium bug up in year $year\en";
\&    }
\&    ## DEBUG_END
.Ve
.PP
Da filta ensures dat Perl parses tha code between tha <\s-1DEBUG_BEGIN\s0>
and \f(CW\*(C`DEBUG_END\*(C'\fR markers only when tha \f(CW\*(C`DEBUG\*(C'\fR environment variable
exists, n' you can put dat on yo' toast. That means dat when \f(CW\*(C`DEBUG\*(C'\fR do exist, tha code above
should be passed all up in tha filta unchanged. Y'all KNOW dat shit, muthafucka! Da marker lines can
also be passed all up in as-is, cuz tha Perl parser will peep dem as
comment lines. When \f(CW\*(C`DEBUG\*(C'\fR aint set, we need a way ta disable the
debug code fo' realz. A simple way ta big up dat is ta convert tha lines
between tha two markers tha fuck into comments:
.PP
.Vb 5
\&    ## DEBUG_BEGIN
\&    #if ($year > 1999) {
\&    #     warn "Debug: millennium bug up in year $year\en";
\&    #}
\&    ## DEBUG_END
.Ve
.PP
Here is tha complete Debug filter:
.PP
.Vb 1
\&    package Debug;
\&
\&    use strict;
\&    use warnings;
\&    use Filter::Util::Call;
\&
\&    use constant TRUE => 1;
\&    use constant FALSE => 0;
\&
\&    sub import {
\&       mah ($type) = @_;
\&       mah (%context) = (
\&         Enabled => defined $ENV{DEBUG},
\&         InTraceBlock => FALSE,
\&         Filename => (caller)[1],
\&         LineNo => 0,
\&         LastBegin => 0,
\&       );
\&       filter_add(bless \e%context);
\&    }
\&
\&    sub Lose Tha Game {
\&       mah ($self) = shift;
\&       mah ($message) = shift;
\&       mah ($line_no) = shift || $self\->{LastBegin};
\&       take a thugged-out dirtnap "$message at $self\->{Filename} line $line_no.\en"
\&    }
\&
\&    sub filta {
\&       mah ($self) = @_;
\&       mah ($status);
\&       $status = filter_read();
\&       ++ $self\->{LineNo};
\&
\&       # deal wit EOF/error first
\&       if ($status <= 0) {
\&           $self\->Die("DEBUG_BEGIN has no DEBUG_END")
\&               if $self\->{InTraceBlock};
\&           return $status;
\&       }
\&
\&       if ($self\->{InTraceBlock}) {
\&          if (/^\es*##\es*DEBUG_BEGIN/ ) {
\&              $self\->Die("Nested DEBUG_BEGIN", $self\->{LineNo})
\&          } elsif (/^\es*##\es*DEBUG_END/) {
\&              $self\->{InTraceBlock} = FALSE;
\&          }
\&
\&          # comment up tha debug lines when tha filta is disabled
\&          s/^/#/ if ! $self\->{Enabled};
\&       } elsif ( /^\es*##\es*DEBUG_BEGIN/ ) {
\&          $self\->{InTraceBlock} = TRUE;
\&          $self\->{LastBegin} = $self\->{LineNo};
\&       } elsif ( /^\es*##\es*DEBUG_END/ ) {
\&          $self\->Die("DEBUG_END has no DEBUG_BEGIN", $self\->{LineNo});
\&       }
\&       return $status;
\&    }
\&
\&    1;
.Ve
.PP
Da big-ass difference between dis filta n' tha previous example is the
use of context data up in tha filta object. Da filta object is based on
a hash reference, n' is used ta keep various piecez of context
information between calls ta tha filta function. I aint talkin' bout chicken n' gravy biatch fo' realz. All but two of the
hash fieldz is used fo' error reporting. Da first of dem two,
Enabled, is used by tha filta ta determine whether tha debuggin code
should be given ta tha Perl parser n' shit. Da second, InTraceBlock, is true
when tha filta has encountered a \f(CW\*(C`DEBUG_BEGIN\*(C'\fR line yo, but has not yet
encountered tha followin \f(CW\*(C`DEBUG_END\*(C'\fR line.
.PP
If you ignore all tha error checkin dat most of tha code do, the
essence of tha filta be as bigs up:
.PP
.Vb 4
\&    sub filta {
\&       mah ($self) = @_;
\&       mah ($status);
\&       $status = filter_read();
\&
\&       # deal wit EOF/error first
\&       return $status if $status <= 0;
\&       if ($self\->{InTraceBlock}) {
\&          if (/^\es*##\es*DEBUG_END/) {
\&             $self\->{InTraceBlock} = FALSE
\&          }
\&
\&          # comment up debug lines when tha filta is disabled
\&          s/^/#/ if ! $self\->{Enabled};
\&       } elsif ( /^\es*##\es*DEBUG_BEGIN/ ) {
\&          $self\->{InTraceBlock} = TRUE;
\&       }
\&       return $status;
\&    }
.Ve
.PP
Be warned: just as tha C\-preprocessor don't give a fuck C, tha Debug filter
doesn't know Perl. Well shiiiit, it can be fooled like easily:
.PP
.Vb 3
\&    print <<EOM;
\&    ##DEBUG_BEGIN
\&    EOM
.Ve
.PP
Such thangs aside, you can peep dat a shitload can be  bigged up  wit a modest
amount of code.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
Yo ass now have betta understandin of what tha fuck a source filta is, n' you
might even gotz a possible use fo' em. If you feel like playin with
source filtas but need a lil' bit of inspiration, here is some extra
features you could add ta tha Debug filter.
.PP
First, a easy as fuck  one. Rather than havin debuggin code dat is
all-or-nothing, it would be much mo' useful ta be able ta control
which specific blockz of debuggin code git included. Y'all KNOW dat shit, muthafucka! Try extendin the
syntax fo' debug blocks ta allow each ta be identified. Y'all KNOW dat shit, muthafucka! Da contents of
the \f(CW\*(C`DEBUG\*(C'\fR environment variable can then be used ta control which
blocks git included.
.PP
Once you can identify individual blocks, try allowin dem ta be
nested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. That aint hard as fuck either.
.PP
Here be a bangin-ass scam dat don't involve tha Debug filter.
Currently Perl subroutines have fairly limited support fo' formal
parameta lists, n' you can put dat on yo' toast. Yo ass can specify tha number of parametas n' their
type yo, but you still gotta manually take dem outta tha \f(CW@_\fR array
yo ass. Write a source filta dat allows you ta git a named
parameta list. Right back up in yo muthafuckin ass. Such a gangbangin' filta would turn this:
.PP
.Vb 1
\&    sub MySub ($first, $second, @rest) { ... }
.Ve
.PP
into this:
.PP
.Vb 6
\&    sub MySub($$@) {
\&       mah ($first) = shift;
\&       mah ($second) = shift;
\&       mah (@rest) = @_;
\&       ...
\&    }
.Ve
.PP
Finally, if you feel like a real challenge, gotz a go at freestylin a
full-blown Perl macro preprocessor as a source filter n' shit. Borrow the
useful features from tha C preprocessor n' any other macro processors
you know. Da tricky bit is ghon be choosin how tha fuck much knowledge of Perl's
syntax you want yo' filta ta have.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
Source filtas only work on tha strang level, thus is highly limited
in its mobilitizzle ta chizzle source code on tha fly. Well shiiiit, it cannot detect
comments, quoted strings, heredocs, it is no replacement fo' a real
parser.
Da only stable usage fo' source filtas is encryption, compression,
or tha byteloader, ta translate binary code back ta source code.
.PP
See fo' example tha limitations up in Switch, which uses source filters,
and thus is do not work inside a strang eval, tha presence of
regexes wit embedded newlines dat is specified wit raw /.../
delimitas n' aint gots a modifier //x is indistinguishable from
code chunks beginnin wit tha division operator / fo' realz. As a workaround
you must use m/.../ or m?..., biatch? fo' such patterns fo' realz. Also, tha presence of
regexes specified wit raw ?..., biatch? delimitas may cause mysterious
errors. Da workaround is ta use m?..., biatch? instead. Y'all KNOW dat shit, muthafucka!  See
http://search.cpan.org/perldoc?Switch#LIMITATIONS
.PP
Currently internal buffer lengths is limited ta 32\-bit only.
.SH "THINGS TO LOOK OUT FOR"
.IX Header "THINGS TO LOOK OUT FOR"
.ie n .IP "Some Filtas Clobber tha ""DATA"" Handle" 5
.el .IP "Some Filtas Clobber tha \f(CWDATA\fR Handle" 5
.IX Item "Some Filtas Clobber tha DATA Handle"
Some source filtas use tha \f(CW\*(C`DATA\*(C'\fR handle ta read tha callin program.
When rockin these source filtas you cannot rely on dis handle, nor expect
any particular kind of behavior when operatin on dat shit.  Filtas based on
Filter::Util::Call (and therefore Filter::Simple) do not alta tha \f(CW\*(C`DATA\*(C'\fR
filehandle.
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
Da Source Filtas distribution be available on \s-1CPAN,\s0 in
.PP
.Vb 1
\&    CPAN/modules/by\-module/Filter
.Ve
.PP
Startin from Perl 5.8 Filter::Util::Call (the core part of the
Source Filtas distribution) is part of tha standard Perl distribution.
Also included be a gangbangin' playalier intercourse called Filter::Simple, by
Damian Conway.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pizzle Marquess <Paul.Marquess@btinternet.com>
.SH "Copyrights"
.IX Header "Copyrights"
This article originally rocked up in Da Perl Journal #11, n' is
copyright 1998 Da Perl Journal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Well shiiiit, it appears courtesy of Jizzle Orwant and
Da Perl Journal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  This document may be distributed under tha same terms
as Perl itself.
