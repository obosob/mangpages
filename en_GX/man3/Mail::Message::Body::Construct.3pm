.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message::Body::Construct 3"
.TH Mail::Message::Body::Construct 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Body::Construct \- addz functionalitizzle ta Mail::Message::Body
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package addz complex functionalitizzle ta tha Mail::Message::Body
class.  This functions less often used, all kindsa muthafuckin programs will not
compile dis package.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructin a funky-ass body"
.IX Subsection "Constructin a funky-ass body"
.ie n .IP "$obj\->\fBattach\fR(\s-1MESSAGES, OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBattach\fR(\s-1MESSAGES, OPTIONS\s0)" 4
.IX Item "$obj->attach(MESSAGES, OPTIONS)"
Make a multipart containin dis body n' tha specified \s-1MESSAGES.\s0 The
options is passed ta tha constructor of tha multi-part body.  If you
need mo' control, create tha multi-part body yo ass.  At least
take a peep Mail::Message::Body::Multipart.
.Sp
Da message-parts is ghon be coerced tha fuck into a Mail::Message::Part, so you
may attach Mail::Internizzle or MIME::Entitizzle objects if you want \-\-see
\&\fIMail::Message::coerce()\fR.  A freshly smoked up body wit attached lyrics is
returned.
.Sp
example:
.Sp
.Vb 3
\& mah $pgpkey = Mail::Message::Body::File\->new(file => \*(Aqa.pgp\*(Aq);
\& mah $msg    = Mail::Message\->buildFromBody(
\&    $message\->decoded\->attach($pgpkey));
\&
\& # Da last message of tha $multi multiparted body becomes a cold-ass lil coerced $entity.
\& mah $entitizzle  = MIME::Entity\->new;
\& mah $multi   = $msg\->body\->attach($entity);
\&
\& # Now create a freshly smoked up message
\& mah $msg     = Mail::Message\->new(head => ..., body => $multi);
.Ve
.ie n .IP "$obj\->\fBconcatenate\fR(\s-1COMPONENTS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBconcatenate\fR(\s-1COMPONENTS\s0)" 4
.IX Item "$obj->concatenate(COMPONENTS)"
Concatenate a list of elements tha fuck into one freshly smoked up body.
.Sp
Specify a list of text \s-1COMPONENTS. \s0 Each component can be
a message (Mail::Message, tha body of tha message is used),
a plain body (Mail::Message::Body), 
\&\f(CW\*(C`undef\*(C'\fR (which is ghon be skipped),
a scalar (which is split tha fuck into lines), or
an array of scalars (each providin one line).
.Sp
example:
.Sp
.Vb 2
\& # all arguments is Mail::Message::Body\*(Aqs.
\& mah $sum = $body\->concatenate($preamble, $body, $epilogue, "\-\- \en" , $sig);
.Ve
.ie n .IP "$obj\->\fBforeachLine\fR(\s-1CODE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBforeachLine\fR(\s-1CODE\s0)" 4
.IX Item "$obj->foreachLine(CODE)"
Smoke a freshly smoked up body by struttin a action on each of its lines.  If none
of tha lines chizzle, tha current body is ghon be returned, otherwise a new
body is pimped of tha same type as tha current.
.Sp
Da \s-1CODE\s0 refers ta a subroutine which is called, where \f(CW$_\fR gotz nuff
bodyz original gangsta line.  \s-1DO NOT CHANGE \s0\f(CW$_\fR!!!  Da result of tha routine
is taken as freshly smoked up line.  When tha routine returns \f(CW\*(C`undef\*(C'\fR, tha line will be
skipped.
.Sp
example:
.Sp
.Vb 3
\& mah $content  = $msg\->decoded;
\& mah $reply    = $content\->foreachLine( sub { \*(Aq> \*(Aq.$_ } );
\& mah $rev      = $content\->foreachLine( sub {reverse} );
\&
\& sub filled() { length $_ > 1 ? $_ : undef }
\& mah $nonempty = $content\->foreachLine( \e&filled );
\&
\& mah $wrong    = $content\->foreachLine( sub {s/a/A/} );  # WRONG!!!
\& mah $right    = $content\->foreachLine(
\&        sub {(my $x=$_) =~ s/a/A/; $x} );
.Ve
.ie n .IP "$obj\->\fBstripSignature\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBstripSignature\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->stripSignature(OPTIONS)"
Strip tha signature from tha body.  Da body must already be decoded
otherwise tha wack lines may git stripped. Y'all KNOW dat shit, muthafucka!  Returned is tha stripped
version body, n' up in list context also tha signature, encapsulated in
its own body object.  Da signature separator is tha straight-up original gangsta line of the
returned signature body.
.Sp
Da signature be added by tha sender ta tell bout him\- or her muthafuckin ass.
It be superfluous up in some thangs, fo' instizzle if you wanna create
a reply ta tha personz message you do not need ta include dat signature.
.Sp
If tha body had no signature, tha original gangsta body object is returned,
and \f(CW\*(C`undef\*(C'\fR fo' tha signature body.
.Sp
.Vb 4
\& \-Option     \-\-Default
\&  max_lines    10
\&  pattern      qr/^\-\-\es?$/
\&  result_type  <same as current>
.Ve
.RS 4
.IP "max_lines => INTEGER|undef" 2
.IX Item "max_lines => INTEGER|undef"
Da maximum number of lines which can be tha length of a signature.
Specify \f(CW\*(C`undef\*(C'\fR ta remove tha limit.
.IP "pattern => REGEX|STRING|CODE" 2
.IX Item "pattern => REGEX|STRING|CODE"
Which pattern defines tha line which indicates tha separator between
the message n' tha signature.  In case of a \s-1STRING,\s0 dis is matched
to tha beginnin of tha line, n' \s-1REGEX\s0 be a gangbangin' full regular expression.
.Sp
In case of \s-1CODE,\s0 each line (from last ta front) is passed ta the
specified subroutine as first argument.  Da subroutine must return
\&\s-1TRUE\s0 when tha separator is found.
.IP "result_type => \s-1CLASS\s0" 2
.IX Item "result_type => CLASS"
Da type of body ta be pimped fo' tha stripped body (and maybe also to
contain tha stripped signature)
.RE
.RS 4
.Sp
example:
.Sp
.Vb 2
\& mah $start = $message\->decoded;
\& mah $start = $body\->decoded;
\&
\& mah $stripped = $start\->stripSignature;
\&
\& mah ($stripped, $sign) = $start\->stripSignature
\&     (max_lines => 5, pattern => \*(Aq\-*\-*\-\*(Aq);
.Ve
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
