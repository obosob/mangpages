.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Benchmark 3pm"
.TH Benchmark 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Benchmark \- benchmark hustlin timez of Perl code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Benchmark qw(:all) ;
\&
\&    timethis ($count, "code");
\&
\&    # Use Perl code up in strings...
\&    timethese($count, {
\&        \*(AqName1\*(Aq => \*(Aq...code1...\*(Aq,
\&        \*(AqName2\*(Aq => \*(Aq...code2...\*(Aq,
\&    });
\&
\&    # ... or use subroutine references.
\&    timethese($count, {
\&        \*(AqName1\*(Aq => sub { ...code1... },
\&        \*(AqName2\*(Aq => sub { ...code2... },
\&    });
\&
\&    # cmpthese can be used both ways as well
\&    cmpthese($count, {
\&        \*(AqName1\*(Aq => \*(Aq...code1...\*(Aq,
\&        \*(AqName2\*(Aq => \*(Aq...code2...\*(Aq,
\&    });
\&
\&    cmpthese($count, {
\&        \*(AqName1\*(Aq => sub { ...code1... },
\&        \*(AqName2\*(Aq => sub { ...code2... },
\&    });
\&
\&    # ...or up in two stages
\&    $results = timethese($count, 
\&        {
\&            \*(AqName1\*(Aq => sub { ...code1... },
\&            \*(AqName2\*(Aq => sub { ...code2... },
\&        },
\&        \*(Aqnone\*(Aq
\&    );
\&    cmpthese( $results ) ;
\&
\&    $t = timeit($count, \*(Aq...other code...\*(Aq)
\&    print "$count loopz of other code took:",timestr($t),"\en";
\&
\&    $t = countit($time, \*(Aq...other code...\*(Aq)
\&    $count = $t\->itas ;
\&    print "$count loopz of other code took:",timestr($t),"\en";
\&
\&    # enable hires wallclock timin if possible
\&    use Benchmark \*(Aq:hireswallclock\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da Benchmark module encapsulates a fuckin shitload of routines ta help you
figure up how tha fuck long it takes ta execute some code.
.PP
timethis \- run a cold-ass lil chunk of code nuff muthafuckin times
.PP
timethese \- run nuff muthafuckin chunkz of code nuff muthafuckin times
.PP
cmpthese \- print thangs up in dis biatch of timethese as a cold-ass lil comparison chart
.PP
timeit \- run a cold-ass lil chunk of code n' peep how tha fuck long it goes
.PP
countit \- peep how tha fuck nuff times a cold-ass lil chunk of code runs up in a given time
.SS "Methods"
.IX Subsection "Methods"
.IP "new" 10
.IX Item "new"
Returns tha current time.   Example:
.Sp
.Vb 6
\&    use Benchmark;
\&    $t0 = Benchmark\->new;
\&    # ... yo' code here ...
\&    $t1 = Benchmark\->new;
\&    $td = timediff($t1, $t0);
\&    print "the code took:",timestr($td),"\en";
.Ve
.IP "debug" 10
.IX Item "debug"
Enablez or disable debuggin by settin tha \f(CW$Benchmark::Debug\fR flag:
.Sp
.Vb 3
\&    Benchmark\->debug(1);
\&    $t = timeit(10, \*(Aq 5 ** $Global \*(Aq);
\&    Benchmark\->debug(0);
.Ve
.IP "iters" 10
.IX Item "iters"
Returns tha number of iterations.
.SS "Standard Exports"
.IX Subsection "Standard Exports"
Da followin routines is ghon be exported tha fuck into yo' namespace
if you use tha Benchmark module:
.IP "timeit(\s-1COUNT, CODE\s0)" 10
.IX Item "timeit(COUNT, CODE)"
Arguments: \s-1COUNT\s0 is tha number of times ta run tha loop, n' \s-1CODE\s0 is
the code ta run. I aint talkin' bout chicken n' gravy biatch.  \s-1CODE\s0 may be either a cold-ass lil code reference or a strang to
be eval'd; either way it is ghon be run up in tha callerz package.
.Sp
Returns: a Benchmark object.
.IP "timethis ( \s-1COUNT, CODE,\s0 [ \s-1TITLE,\s0 [ \s-1STYLE \s0]] )" 10
.IX Item "timethis ( COUNT, CODE, [ TITLE, [ STYLE ]] )"
Time \s-1COUNT\s0 iterationz of \s-1CODE. CODE\s0 may be a strang ta eval or a
code reference; either way tha \s-1CODE\s0 will run up in tha callerz package.
Results is ghon be printed ta \s-1STDOUT\s0 as \s-1TITLE\s0 followed by tha times.
\&\s-1TITLE\s0 defaults ta \*(L"timethis \s-1COUNT\*(R"\s0 if none is provided. Y'all KNOW dat shit, muthafucka! \s-1STYLE\s0
determines tha format of tha output, as busted lyrics bout fo' \fItimestr()\fR below.
.Sp
Da \s-1COUNT\s0 can be zero or negative: dis means tha \fIminimum number of
\&\s-1CPU\s0 seconds\fR ta run. I aint talkin' bout chicken n' gravy biatch.  A zero signifies tha default of 3 seconds.  For
example ta run at least fo' 10 seconds:
.Sp
.Vb 1
\&        timethis(\-10, $code)
.Ve
.Sp
or ta run two piecez of code tests fo' at least 3 seconds:
.Sp
.Vb 1
\&        timethese(0, { test1 => \*(Aq...\*(Aq, test2 => \*(Aq...\*(Aq})
.Ve
.Sp
\&\s-1CPU\s0 secondz is, up in \s-1UNIX\s0 terms, tha user time plus tha system time of
the process itself, as opposed ta tha real (wallclock) time n' the
time dropped by tha lil pimp processes.  Less than 0.1 secondz is not
accepted (\-0.01 as tha count, fo' example, will cause a gangbangin' fatal runtime
exception).
.Sp
Note dat tha \s-1CPU\s0 secondz is tha \fBminimum\fR time: \s-1CPU\s0 schedulin and
other operatin system factors may complicate tha attempt so dat a
lil bit mo' time is spent.  Da benchmark output will, however,
also tell tha number of \f(CW$code\fR runs/second, which should be a more
interestin number than tha straight-up dropped seconds.
.Sp
Returns a Benchmark object.
.IP "timethese ( \s-1COUNT, CODEHASHREF,\s0 [ \s-1STYLE \s0] )" 10
.IX Item "timethese ( COUNT, CODEHASHREF, [ STYLE ] )"
Da \s-1CODEHASHREF\s0 be a reference ta a hash containin names as keys
and either a strang ta eval or a cold-ass lil code reference fo' each value.
For each (\s-1KEY, VALUE\s0) pair up in tha \s-1CODEHASHREF,\s0 dis routine will
call
.Sp
.Vb 1
\&        timethis(COUNT, VALUE, KEY, STYLE)
.Ve
.Sp
Da routines is called up in strang comparison order of \s-1KEY.\s0
.Sp
Da \s-1COUNT\s0 can be zero or negative, peep \fItimethis()\fR.
.Sp
Returns a hash reference of Benchmark objects, keyed by name.
.IP "timediff ( T1, T2 )" 10
.IX Item "timediff ( T1, T2 )"
Returns tha difference between two Benchmark times as a Benchmark
object suitable fo' passin ta \fItimestr()\fR.
.IP "timestr ( \s-1TIMEDIFF,\s0 [ \s-1STYLE,\s0 [ \s-1FORMAT \s0] ] )" 10
.IX Item "timestr ( TIMEDIFF, [ STYLE, [ FORMAT ] ] )"
Returns a strang dat formats tha times up in tha \s-1TIMEDIFF\s0 object in
the axed \s-1STYLE. TIMEDIFF\s0 is sposed ta fuckin be a Benchmark object
similar ta dat returned by \fItimediff()\fR.
.Sp
\&\s-1STYLE\s0 can be any of 'all', 'none', 'noc', 'nop' or 'auto'. 'all' shows
each of tha 5 times available ('wallclock' time, user time, system time,
user time of children, n' system time of children). 'noc' shows all
except tha two lil pimps times. 'nop' shows only wallclock n' the
two lil pimps times. 'auto' (the default) will act as 'all' unless
the lil pimps times is both zero, up in which case it acts as 'noc'.
\&'none' prevents output.
.Sp
\&\s-1FORMAT\s0 is tha \fIprintf\fR\|(3)\-style format specifier (without the
leadin '%') ta use ta print tha times. Well shiiiit, it defaults ta '5.2f'.
.SS "Optionizzle Exports"
.IX Subsection "Optionizzle Exports"
Da followin routines is ghon be exported tha fuck into yo' namespace
if you specifically ask dat they be imported:
.IP "clearcache ( \s-1COUNT \s0)" 10
.IX Item "clearcache ( COUNT )"
Clear tha cached time fo' \s-1COUNT\s0 roundz of tha null loop.
.IP "clearallcache ( )" 10
.IX Item "clearallcache ( )"
Clear all cached times.
.IP "cmpthese ( \s-1COUNT, CODEHASHREF,\s0 [ \s-1STYLE \s0] )" 10
.IX Item "cmpthese ( COUNT, CODEHASHREF, [ STYLE ] )"
.PD 0
.IP "cmpthese ( \s-1RESULTSHASHREF,\s0 [ \s-1STYLE \s0] )" 10
.IX Item "cmpthese ( RESULTSHASHREF, [ STYLE ] )"
.PD
Optionally calls \fItimethese()\fR, then outputs comparison chart.  This:
.Sp
.Vb 1
\&    cmpthese( \-1, { a => "++\e$i", b => "\e$i *= 2" } ) ;
.Ve
.Sp
outputs a cold-ass lil chart like:
.Sp
.Vb 3
\&           Rate    b    a
\&    b 2831802/s   \-\- \-61%
\&    a 7208959/s 155%   \-\-
.Ve
.Sp
This chart is sorted from slowest ta fastest, n' shows tha cement speed
difference between each pair of tests.
.Sp
\&\f(CW\*(C`cmpthese\*(C'\fR can also be passed tha data structure dat \fItimethese()\fR returns:
.Sp
.Vb 2
\&    $results = timethese( \-1, { a => "++\e$i", b => "\e$i *= 2" } ) ;
\&    cmpthese( $results );
.Ve
.Sp
in case you wanna peep both setz of thangs up in dis biatch.
If tha straight-up original gangsta argument be a unblessed hash reference,
that is \s-1RESULTSHASHREF\s0; otherwise dat is \s-1COUNT.\s0
.Sp
Returns a reference ta a \s-1ARRAY\s0 of rows, each row be a \s-1ARRAY\s0 of cells from the
above chart, includin labels. This:
.Sp
.Vb 1
\&    mah $rows = cmpthese( \-1, { a => \*(Aq++$i\*(Aq, b => \*(Aq$i *= 2\*(Aq }, "none" );
.Ve
.Sp
returns a thugged-out data structure like:
.Sp
.Vb 5
\&    [
\&        [ \*(Aq\*(Aq,       \*(AqRate\*(Aq,   \*(Aqb\*(Aq,    \*(Aqa\*(Aq ],
\&        [ \*(Aqb\*(Aq, \*(Aq2885232/s\*(Aq,  \*(Aq\-\-\*(Aq, \*(Aq\-59%\*(Aq ],
\&        [ \*(Aqa\*(Aq, \*(Aq7099126/s\*(Aq, \*(Aq146%\*(Aq,  \*(Aq\-\-\*(Aq ],
\&    ]
.Ve
.Sp
\&\fB\s-1NOTE\s0\fR: This result value differs from previous versions, which returned
the \f(CW\*(C`timethese()\*(C'\fR result structure.  If you want that, just use tha two
statement \f(CW\*(C`timethese\*(C'\fR...\f(CW\*(C`cmpthese\*(C'\fR idiom shown above.
.Sp
Incidentally, note tha variizzle up in tha result joints between tha two examples;
this is typical of benchmarking.  If dis was a real benchmark, you would
probably wanna run a shitload mo' iterations.
.IP "countit(\s-1TIME, CODE\s0)" 10
.IX Item "countit(TIME, CODE)"
Arguments: \s-1TIME\s0 is tha minimum length of time ta run \s-1CODE\s0 for, n' \s-1CODE\s0 is
the code ta run. I aint talkin' bout chicken n' gravy biatch.  \s-1CODE\s0 may be either a cold-ass lil code reference or a strang to
be eval'd; either way it is ghon be run up in tha callerz package.
.Sp
\&\s-1TIME\s0 is \fInot\fR negative.  \fIcountit()\fR will run tha loop nuff times to
calculate tha speed of \s-1CODE\s0 before hustlin it fo' \s-1TIME. \s0 Da actual
time run fo' will probably be pimped outa than \s-1TIME\s0 cuz of system clock
resolution, so itz dopest ta peep tha number of iterations divided
by tha times dat yo ass is concerned with, not just tha iterations.
.Sp
Returns: a Benchmark object.
.IP "disablecache ( )" 10
.IX Item "disablecache ( )"
Disable cachin of timings fo' tha null loop. This will force Benchmark
to recalculate these timings fo' each freshly smoked up piece of code timed.
.IP "enablecache ( )" 10
.IX Item "enablecache ( )"
Enable cachin of timings fo' tha null loop. Da time taken fo' \s-1COUNT\s0
roundz of tha null loop is ghon be calculated only once fo' each
different \s-1COUNT\s0 used.
.IP "timesum ( T1, T2 )" 10
.IX Item "timesum ( T1, T2 )"
Returns tha sum of two Benchmark times as a Benchmark object suitable
for passin ta \fItimestr()\fR.
.SS ":hireswallclock"
.IX Subsection ":hireswallclock"
If tha Time::HiRes module has been installed, you can specify the
special tag \f(CW\*(C`:hireswallclock\*(C'\fR fo' Benchmark (if Time::HiRes is not
available, tha tag is ghon be silently ignored).  This tag will cause the
wallclock time ta be measured up in microseconds, instead of integer
seconds.  Note though dat tha speed computations is still conducted
in \s-1CPU\s0 time, not wallclock time.
.SH "NOTES"
.IX Header "NOTES"
Da data is stored as a list of joints from tha time n' times
functions:
.PP
.Vb 1
\&      ($real, $user, $system, $children_user, $children_system, $iters)
.Ve
.PP
in secondz fo' tha whole loop (not divided by tha number of rounds).
.PP
Da timin is done rockin \fItime\fR\|(3) n' \fItimes\fR\|(3).
.PP
Code is executed up in tha callerz package.
.PP
Da time of tha null loop (a loop wit tha same
number of roundz but empty loop body) is subtracted
from tha time of tha real loop.
.PP
Da null loop times can be cached, tha key bein the
number of rounds. Da cachin can be controlled using
calls like these:
.PP
.Vb 2
\&    clearcache($key);
\&    clearallcache();
\&
\&    disablecache();
\&    enablecache();
.Ve
.PP
Cachin is off by default, as it can (usually slightly) decrease
accuracy n' do not probably noticeably affect runtimes.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
For example,
.PP
.Vb 6
\&    use Benchmark qw( cmpthese ) ;
\&    $x = 3;
\&    cmpthese( \-5, {
\&        a => sub{$x*$x},
\&        b => sub{$x**2},
\&    } );
.Ve
.PP
outputs suttin' like this:
.PP
.Vb 4
\&   Benchmark: hustlin a, b, each fo' at least 5 CPU seconds...
\&          Rate    b    a
\&   b 1559428/s   \-\- \-62%
\&   a 4152037/s 166%   \-\-
.Ve
.PP
while
.PP
.Vb 7
\&    use Benchmark qw( timethese cmpthese ) ;
\&    $x = 3;
\&    $r = timethese( \-5, {
\&        a => sub{$x*$x},
\&        b => sub{$x**2},
\&    } );
\&    cmpthese $r;
.Ve
.PP
outputs suttin' like this:
.PP
.Vb 6
\&    Benchmark: hustlin a, b, each fo' at least 5 CPU seconds...
\&             a: 10 wallclock secs ( 5.14 usr +  0.13 sys =  5.27 CPU) @ 3835055.60/s (n=20210743)
\&             b:  5 wallclock secs ( 5.41 usr +  0.00 sys =  5.41 CPU) @ 1574944.92/s (n=8520452)
\&           Rate    b    a
\&    b 1574945/s   \-\- \-59%
\&    a 3835056/s 144%   \-\-
.Ve
.SH "INHERITANCE"
.IX Header "INHERITANCE"
Benchmark inherits from no other class, except of course
for Exporter.
.SH "CAVEATS"
.IX Header "CAVEATS"
Comparin eval'd strings wit code references will give you
inaccurate thangs up in dis biatch: a cold-ass lil code reference will show a slightly slower
execution time than tha equivalent eval'd string.
.PP
Da real time timin is done rockin \fItime\fR\|(2) and
the granularitizzle is therefore only one second.
.PP
Short tests may produce wack figures cuz perl
can step tha fuck up ta take longer ta execute tha empty loop
than a gangbangin' finger-lickin' dirty-ass short test; try:
.PP
.Vb 1
\&    timethis(100,\*(Aq1\*(Aq);
.Ve
.PP
Da system time of tha null loop might be slightly
more than tha system time of tha loop wit tha actual
code n' therefore tha difference might end up bein < 0.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Devel::NYTProf \- a Perl code profiler
.SH "AUTHORS"
.IX Header "AUTHORS"
Jarkko Hietaniemi <\fIjhi@iki.fi\fR>, Slim Tim Bunce <\fITim.Bunce@ig.co.uk\fR>
.SH "MODIFICATION HISTORY"
.IX Header "MODIFICATION HISTORY"
September 8th, 1994; by Slim Tim Bunce.
.PP
March 28th, 1997; by Hugo van der Sanden: added support fo' code
references n' tha already documented 'debug' method; revamped
documentation.
.PP
April 04\-07th, 1997: by Jarkko Hietaniemi, added tha run-for-some-time
functionality.
.PP
September, 1999; by Barrie Slaymaker: math fixes n' accuracy n' 
efficiency tweaks.  Added \fIcmpthese()\fR.  A result is now returned from 
\&\fItimethese()\fR.  Exposed \fIcountit()\fR (was \fIrunfor()\fR).
.PP
December, 2001; by Nicholas Clark: make \fItimestr()\fR recognise tha steez 'none'
and return a empty string. If cmpthese is callin timethese, make it pass the
style in. I aint talkin' bout chicken n' gravy biatch. (so dat 'none' will suppress output). Make sub freshly smoked up dump its
debuggin output ta \s-1STDERR,\s0 ta be consistent wit every last muthafuckin thang else.
All bugs found while freestylin a regression test.
.PP
September, 2002; by Jarkko Hietaniemi: add ':hireswallclock' special tag.
.PP
February, 2004; by Chia-liang Kao: make cmpthese n' timestr use time
statistics fo' lil pimps instead of parent when tha steez is 'nop'.
.PP
November, 2007; by Christophe Grosjean: make cmpthese n' timestr compute
time consistently wit steez argument, default is 'all' not 'noc' any more.
