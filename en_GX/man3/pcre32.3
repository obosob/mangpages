.TH PCRE 3 "12 May 2013" "PCRE 8.33"
.SH NAME
PCRE - Perl-compatible regular expressions
.sp
.B #include <pcre.h>
.
.
.SH "PCRE 32-BIT API BASIC FUNCTIONS"
.rs
.sp
.SM
.B pcre32 *pcre32_compile(PCRE_SPTR32 \fIpattern\fP, int \fIoptions\fP,
.ti +5n
.B const char **\fIerrptr\fP, int *\fIerroffset\fP,
.ti +5n
.B const unsigned char *\fItableptr\fP);
.PP
.B pcre32 *pcre32_compile2(PCRE_SPTR32 \fIpattern\fP, int \fIoptions\fP,
.ti +5n
.B int *\fIerrorcodeptr\fP,
.ti +5n
.B const char **\fIerrptr\fP, int *\fIerroffset\fP,
.ti +5n
.B const unsigned char *\fItableptr\fP);
.PP
.B pcre32_extra *pcre32_study(const pcre32 *\fIcode\fP, int \fIoptions\fP,
.ti +5n
.B const char **\fIerrptr\fP);
.PP
.B void pcre32_free_study(pcre32_extra *\fIextra\fP);
.PP
.B int pcre32_exec(const pcre32 *\fIcode\fP, "const pcre32_extra *\fIextra\fP,"
.ti +5n
.B "PCRE_SPTR32 \fIsubject\fP," int \fIlength\fP, int \fIstartoffset\fP,
.ti +5n
.B int \fIoptions\fP, int *\fIovector\fP, int \fIovecsize\fP);
.PP
.B int pcre32_dfa_exec(const pcre32 *\fIcode\fP, "const pcre32_extra *\fIextra\fP,"
.ti +5n
.B "PCRE_SPTR32 \fIsubject\fP," int \fIlength\fP, int \fIstartoffset\fP,
.ti +5n
.B int \fIoptions\fP, int *\fIovector\fP, int \fIovecsize\fP,
.ti +5n
.B int *\fIworkspace\fP, int \fIwscount\fP);
.
.
.SH "PCRE 32-BIT API STRING EXTRACTION FUNCTIONS"
.rs
.sp
.B int pcre32_copy_named_substring(const pcre32 *\fIcode\fP,
.ti +5n
.B PCRE_SPTR32 \fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, PCRE_SPTR32 \fIstringname\fP,
.ti +5n
.B PCRE_UCHAR32 *\fIbuffer\fP, int \fIbuffersize\fP);
.PP
.B int pcre32_copy_substring(PCRE_SPTR32 \fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, int \fIstringnumber\fP, PCRE_UCHAR32 *\fIbuffer\fP,
.ti +5n
.B int \fIbuffersize\fP);
.PP
.B int pcre32_get_named_substring(const pcre32 *\fIcode\fP,
.ti +5n
.B PCRE_SPTR32 \fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, PCRE_SPTR32 \fIstringname\fP,
.ti +5n
.B PCRE_SPTR32 *\fIstringptr\fP);
.PP
.B int pcre32_get_stringnumber(const pcre32 *\fIcode\fP,
.ti +5n
.B PCRE_SPTR32 \fIname\fP);
.PP
.B int pcre32_get_stringtable_entries(const pcre32 *\fIcode\fP,
.ti +5n
.B PCRE_SPTR32 \fIname\fP, PCRE_UCHAR32 **\fIfirst\fP, PCRE_UCHAR32 **\fIlast\fP);
.PP
.B int pcre32_get_substring(PCRE_SPTR32 \fIsubject\fP, int *\fIovector\fP,
.ti +5n
.B int \fIstringcount\fP, int \fIstringnumber\fP,
.ti +5n
.B PCRE_SPTR32 *\fIstringptr\fP);
.PP
.B int pcre32_get_substring_list(PCRE_SPTR32 \fIsubject\fP,
.ti +5n
.B int *\fIovector\fP, int \fIstringcount\fP, "PCRE_SPTR32 **\fIlistptr\fP);"
.PP
.B void pcre32_free_substring(PCRE_SPTR32 \fIstringptr\fP);
.PP
.B void pcre32_free_substring_list(PCRE_SPTR32 *\fIstringptr\fP);
.
.
.SH "PCRE 32-BIT API AUXILIARY FUNCTIONS"
.rs
.sp
.B pcre32_jit_stack *pcre32_jit_stack_alloc(int \fIstartsize\fP, int \fImaxsize\fP);
.PP
.B void pcre32_jit_stack_free(pcre32_jit_stack *\fIstack\fP);
.PP
.B void pcre32_assign_jit_stack(pcre32_extra *\fIextra\fP,
.ti +5n
.B pcre32_jit_callback \fIcallback\fP, void *\fIdata\fP);
.PP
.B const unsigned char *pcre32_maketables(void);
.PP
.B int pcre32_fullinfo(const pcre32 *\fIcode\fP, "const pcre32_extra *\fIextra\fP,"
.ti +5n
.B int \fIwhat\fP, void *\fIwhere\fP);
.PP
.B int pcre32_refcount(pcre32 *\fIcode\fP, int \fIadjust\fP);
.PP
.B int pcre32_config(int \fIwhat\fP, void *\fIwhere\fP);
.PP
.B const char *pcre32_version(void);
.PP
.B int pcre32_pattern_to_host_byte_order(pcre32 *\fIcode\fP,
.ti +5n
.B pcre32_extra *\fIextra\fP, const unsigned char *\fItables\fP);
.
.
.SH "PCRE 32-BIT API INDIRECTED FUNCTIONS"
.rs
.sp
.B void *(*pcre32_malloc)(size_t);
.PP
.B void (*pcre32_free)(void *);
.PP
.B void *(*pcre32_stack_malloc)(size_t);
.PP
.B void (*pcre32_stack_free)(void *);
.PP
.B int (*pcre32_callout)(pcre32_callout_block *);
.
.
.SH "PCRE 32-BIT API 32-BIT-ONLY FUNCTION"
.rs
.sp
.B int pcre32_utf32_to_host_byte_order(PCRE_UCHAR32 *\fIoutput\fP,
.ti +5n
.B PCRE_SPTR32 \fIinput\fP, int \fIlength\fP, int *\fIbyte_order\fP,
.ti +5n
.B int \fIkeep_boms\fP);
.
.
.SH "THE PCRE 32-BIT LIBRARY"
.rs
.sp
Startin wit release 8.32, it is possible ta compile a PCRE library that
supports 32-bit characta strings, includin UTF-32 strings, as well as or
instead of tha original gangsta 8-bit library. This work was done by Christian Persch,
based on tha work done by Zoltan Herczeg fo' tha 16-bit library fo' realz. All three
libraries contain identical setz of functions, used up in exactly tha same way.
Only tha namez of tha functions n' tha data typez of they arguments and
results is different. To avoid over-complication n' reduce tha documentation
maintenizzle load, most of tha PCRE documentation raps bout tha 8-bit library,
with only occasionizzle references ta tha 16-bit n' 32-bit libraries. Put ya muthafuckin choppers up if ya feel dis! This page
raps bout what tha fuck is different when you use tha 32-bit library.
.P
WARNING: A single application can be linked wit all or any of tha three
libraries yo, but you must take care when processin any particular pattern
to use functions from just one library. For example, if you wanna study
a pattern dat was compiled wit \fBpcre32_compile()\fP, you must do so
with \fBpcre32_study()\fP, not \fBpcre_study()\fP, n' you must free the
study data wit \fBpcre32_free_study()\fP.
.
.
.SH "THE HEADER FILE"
.rs
.sp
There is only one header file, \fBpcre.h\fP. Well shiiiit, it gotz nuff prototypes fo' all the
functions up in all libraries, as well as definitionz of flags, structures, error
codes, etc.
.
.
.SH "THE LIBRARY NAME"
.rs
.sp
In Unix-like systems, tha 32-bit library is called \fBlibpcre32\fP, n' can
normally be accesss by addin \fB-lpcre32\fP ta tha command fo' linkin an
application dat uses PCRE.
.
.
.SH "STRING TYPES"
.rs
.sp
In tha 8-bit library, strings is passed ta PCRE library functions as vectors
of bytes wit tha C type "char *". In tha 32-bit library, strings is passed as
vectorz of unsigned 32-bit quantities. Put ya muthafuckin choppers up if ya feel dis! Da macro PCRE_UCHAR32 specifies an
appropriate data type, n' PCRE_SPTR32 is defined as "const PCRE_UCHAR32 *". In
very nuff environments, "unsigned int" be a 32-bit data type. When PCRE is
built, it defines PCRE_UCHAR32 as "unsigned int" yo, but checks dat it straight-up is
a 32-bit data type. If it is not, tha build fails wit a error message telling
the maintainer ta modify tha definizzle appropriately.
.
.
.SH "STRUCTURE TYPES"
.rs
.sp
Da typez of tha opaque structures dat is used fo' compiled 32-bit patterns
and JIT stacks is \fBpcre32\fP n' \fBpcre32_jit_stack\fP respectively. The
type of tha user-accessible structure dat is returned by \fBpcre32_study()\fP
is \fBpcre32_extra\fP, n' tha type of tha structure dat is used fo' passing
data ta a cold-ass lil callout function is \fBpcre32_callout_block\fP. These structures
contain tha same fields, wit tha same names, as they 8-bit counterparts, n' you can put dat on yo' toast. The
only difference is dat pointas ta characta strings is 32-bit instead of
8-bit types.
.
.
.SH "32-BIT FUNCTIONS"
.rs
.sp
For every last muthafuckin function up in tha 8-bit library there be a cold-ass lil correspondin function in
the 32-bit library wit a name dat starts wit \fBpcre32_\fP instead of
\fBpcre_\fP. Da prototypes is listed above. In addition, there is one extra
function, \fBpcre32_utf32_to_host_byte_order()\fP. This be a utilitizzle function
that converts a UTF-32 characta strang ta host byte order if necessary. The
other 32-bit functions expect tha strings they is passed ta be up in host byte
order.
.P
Da \fIinput\fP n' \fIoutput\fP arguments of
\fBpcre32_utf32_to_host_byte_order()\fP may point ta tha same address, dat is,
conversion up in place is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da output buffer must be at least as long as
the input.
.P
Da \fIlength\fP argument specifies tha number of 32-bit data units up in the
input string; a wack value specifies a zero-terminated string.
.P
If \fIbyte_order\fP is NULL, it be assumed dat tha strang starts off up in host
byte order n' shit. This may be chizzled by byte-order marks (BOMs) anywhere up in the
strin (commonly as tha straight-up original gangsta character).
.P
If \fIbyte_order\fP aint NULL, a non-zero value of tha integer ta which it
points means dat tha input starts off up in host byte order, otherwise the
opposite order be assumed. Y'all KNOW dat shit, muthafucka! Again, BOMs up in tha strang can chizzle all dis bullshit. Da final
byte order is passed back all up in tha end of processing.
.P
If \fIkeep_boms\fP aint zero, byte-order mark charactas (0xfeff) is copied
into tha output string. Otherwise they is discarded.
.P
Da result of tha function is tha number of 32-bit units placed tha fuck into tha output
buffer, includin tha zero terminator if tha strang was zero-terminated.
.
.
.SH "SUBJECT STRING OFFSETS"
.rs
.sp
Da lengths n' startin offsetz of subject strings must be specified up in 32-bit
data units, n' tha offsets within subject strings dat is returned by the
matchin functions is up in also 32-bit units rather than bytes.
.
.
.SH "NAMED SUBPATTERNS"
.rs
.sp
Da name-to-number translation table dat is maintained fo' named subpatterns
uses 32-bit characters. Da \fBpcre32_get_stringtable_entries()\fP function
returns tha length of each entry up in tha table as tha number of 32-bit data
units.
.
.
.SH "OPTION NAMES"
.rs
.sp
There is two freshly smoked up general option names, PCRE_UTF32 n' PCRE_NO_UTF32_CHECK,
which correspond ta PCRE_UTF8 n' PCRE_NO_UTF8_CHECK up in tha 8-bit library. In
fact, these freshly smoked up options define tha same bits up in tha options word. Y'all KNOW dat shit, muthafucka! There be a
rap bout the
.\" HTML <a href="pcreunicode.html#utf32strings">
.\" </a>
validitizzle of UTF-32 strings
.\"
in the
.\" HREF
\fBpcreunicode\fP
.\"
page.
.P
For tha \fBpcre32_config()\fP function there be a option PCRE_CONFIG_UTF32
that returns 1 if UTF-32 support is configured, otherwise 0. If dis option is
given ta \fBpcre_config()\fP or \fBpcre16_config()\fP, or if the
PCRE_CONFIG_UTF8 or PCRE_CONFIG_UTF16 option is given ta \fBpcre32_config()\fP,
the result is tha PCRE_ERROR_BADOPTION error.
.
.
.SH "CHARACTER CODES"
.rs
.sp
In 32-bit mode, when PCRE_UTF32 aint set, characta joints is treated up in the
same way as up in 8-bit, non UTF-8 mode, except, of course, dat they can range
from 0 ta 0x7fffffff instead of 0 ta 0xff. Characta types fo' charactas less
than 0xff can therefore be hyped up by tha locale up in tha same way as before.
Charactas pimped outa than 0xff have only one case, n' no "type" (like fuckin letter
or digit).
.P
In UTF-32 mode, tha characta code is Unicode, up in tha range 0 ta 0x10ffff, with
the exception of joints up in tha range 0xd800 ta 0xdfff cuz dem are
"surrogate" joints dat is ill-formed up in UTF-32.
.P
A UTF-32 strang can indicate its endiannizz by special code knows as a
byte-order mark (BOM). Da PCRE functions do not handle this, expectin strings
to be up in host byte order n' shiznit fo' realz. A utilitizzle function called
\fBpcre32_utf32_to_host_byte_order()\fP is provided ta help wit dis (see
above).
.
.
.SH "ERROR NAMES"
.rs
.sp
Da error PCRE_ERROR_BADUTF32 correspondz ta its 8-bit counterpart.
Da error PCRE_ERROR_BADMODE is given when a cold-ass lil compiled
pattern is passed ta a gangbangin' function dat processes patterns up in tha other
mode, fo' example, if a pattern compiled wit \fBpcre_compile()\fP is passed to
\fBpcre32_exec()\fP.
.P
There is freshly smoked up error codes whose names begin wit PCRE_UTF32_ERR fo' invalid
UTF-32 strings, correspondin ta tha PCRE_UTF8_ERR codes fo' UTF-8 strings that
are busted lyrics bout up in tha section entitled
.\" HTML <a href="pcreapi.html#badutf8reasons">
.\" </a>
"Reason codes fo' invalid UTF-8 strings"
.\"
in tha main
.\" HREF
\fBpcreapi\fP
.\"
page. Da UTF-32 errors are:
.sp
  PCRE_UTF32_ERR1  Surrogate characta (range from 0xd800 ta 0xdfff)
  PCRE_UTF32_ERR2  Non-character
  PCRE_UTF32_ERR3  Characta > 0x10ffff
.
.
.SH "ERROR TEXTS"
.rs
.sp
If there be a error while compilin a pattern, tha error text dat is passed
back by \fBpcre32_compile()\fP or \fBpcre32_compile2()\fP is still a 8-bit
characta string, zero-terminated.
.
.
.SH "CALLOUTS"
.rs
.sp
Da \fIsubject\fP n' \fImark\fP fieldz up in tha callout block dat is passed to
a callout function point ta 32-bit vectors.
.
.
.SH "TESTING"
.rs
.sp
Da \fBpcretest\fP program continues ta operate wit 8-bit input n' output
filez yo, but it can be used fo' testin tha 32-bit library. If it is run wit the
command line option \fB-32\fP, patterns n' subject strings is converted from
8-bit ta 32-bit before bein passed ta PCRE, n' tha 32-bit library functions
are used instead of tha 8-bit ones. Returned 32-bit strings is converted to
8-bit fo' output. If both tha 8-bit n' tha 16-bit libraries was not compiled,
\fBpcretest\fP defaults ta 32-bit n' tha \fB-32\fP option is ignored.
.P
When PCRE is bein built, tha \fBRunTest\fP script dat is called by "make
check" uses tha \fBpcretest\fP \fB-C\fP option ta discover which of tha 8-bit,
16-bit n' 32-bit libraries has been built, n' runs tha tests appropriately.
.
.
.SH "NOT SUPPORTED IN 32-BIT MODE"
.rs
.sp
Not all tha featurez of tha 8-bit library is available wit tha 32-bit
library. Da C++ n' POSIX wrapper functions support only tha 8-bit library,
and tha \fBpcregrep\fP program be at present 8-bit only.
.
.
.SH AUTHOR
.rs
.sp
.nf
Philip Hazel
Universitizzle Computin Service
Cambridge CB2 3QH, England.
.fi
.
.
.SH REVISION
.rs
.sp
.nf
Last updated: 12 May 2013
Copyright (c) 1997-2013 Universitizzle of Cambridge.
.fi
