.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GD::Polyline 3"
.TH GD::Polyline 3 "2013-02-26" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
GD::Polyline \- Polyline object n' Polygon utilitizzles (includin splines) fo' use wit GD
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        use GD;
\&        use GD::Polyline;
\&
\&        # create a image
\&        $image = freshly smoked up GD::Image (500,300);
\&        $white  = $image\->colorAllocate(255,255,255);
\&        $black  = $image\->colorAllocate(  0,  0,  0);
\&        $red    = $image\->colorAllocate(255,  0,  0);
\&        
\&        # create a freshly smoked up polyline
\&        $polyline = freshly smoked up GD::Polyline;
\&                        
\&        # add some points
\&        $polyline\->addPt(  0,  0);
\&        $polyline\->addPt(  0,100);
\&        $polyline\->addPt( 50,125);
\&        $polyline\->addPt(100,  0);
\&
\&        # polylines can use polygon methodz (and vice versa)
\&        $polyline\->offset(200,100);
\&        
\&        # rotate 60 degrees, bout tha centroid
\&        $polyline\->rotate(3.14159/3, $polyline\->centroid()); 
\&        
\&        # scale bout tha centroid
\&        $polyline\->scale(1.5, 2, $polyline\->centroid());  
\&        
\&        # draw tha polyline
\&        $image\->polydraw($polyline,$black);
\&        
\&        # create a spline, which be also a polyine
\&        $spline = $polyline\->addControlPoints\->toSpline;
\&        $image\->polydraw($spline,$red);
\&
\&        # output tha png
\&        binmode STDOUT;
\&        print $image\->png;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBPolyline.pm\fR extendz tha \s-1GD\s0 module by allowin you ta create polylines.  Think
of a polyline as \*(L"an open polygon\*(R", dat is, tha last vertex aint connected
to tha straight-up original gangsta vertex (unless you expressly add tha same value as both points).
.PP
For tha remainder of dis doc, \*(L"polyline\*(R" will refer ta a GD::Polyline,
\&\*(L"polygon\*(R" will refer ta a GD::Polygon dat aint a polyline, and
\&\*(L"polything\*(R" n' \*(L"$poly\*(R" may be either.
.PP
Da big-ass feature added ta \s-1GD\s0 by dis module is tha means
to create splines, which is approximations ta curves.
.SH "Da Polyline Object"
.IX Header "Da Polyline Object"
GD::Polyline defines tha followin class:
.ie n .IP """GD::Polyline""" 5
.el .IP "\f(CWGD::Polyline\fR" 5
.IX Item "GD::Polyline"
A polyline object, used fo' storin listz of vertices prior to
renderin a polyline tha fuck into a image.
.ie n .IP """new""" 5
.el .IP "\f(CWnew\fR" 5
.IX Item "new"
\&\f(CW\*(C`GD::Polyline\->new\*(C'\fR \fIclass method\fR
.Sp
Smoke a empty polyline wit no vertices.
.Sp
.Vb 1
\&        $polyline = freshly smoked up GD::Polyline;
\&
\&        $polyline\->addPt(  0,  0);
\&        $polyline\->addPt(  0,100);
\&        $polyline\->addPt( 50,100);
\&        $polyline\->addPt(100,  0);
\&
\&        $image\->polydraw($polyline,$black);
.Ve
.Sp
In fact GD::Polyline be a subclass of GD::Polygon, 
so all polygon methodz (like fuckin \fBoffset\fR n' \fBtransform\fR)
may be used on polylines.
Some freshly smoked up methodz have thus been added ta GD::Polygon (like fuckin \fBrotate\fR)
and all dem updated/modified/enhanced (like fuckin \fBscale\fR) \fIin dis module\fR.  
See section \*(L"New or Updated GD::Polygon Methods\*(R" fo' mo' info.
.PP
Note dat dis module is straight-up \*(L"young\*(R" n' should be
considered subject ta chizzle up in future releases, and/or
possibly folded up in ta tha existin polygon object and/or \s-1GD\s0 module.
.SH "Updated Polygon Methods"
.IX Header "Updated Polygon Methods"
Da followin methodz (defined up in \s-1GD\s0.pm) is \s-1OVERRIDDEN\s0 if you use dis module.
.PP
All effort has been made ta provide 100% backward compatibilitizzle yo, but if you
can confirm dat has not been  bigged up , please consider dat a funky-ass bug n' let the
the lyricist of Polyline.pm know.
.ie n .IP """scale""" 5
.el .IP "\f(CWscale\fR" 5
.IX Item "scale"
\&\f(CW\*(C`$poly\->scale($sx, $sy, $cx, $cy)\*(C'\fR \fIobject method \*(-- \s-1UPDATE\s0 ta GD::Polygon::scale\fR
.Sp
Scale a polythang up in along x\-axis by \f(CW$sx\fR n' along tha y\-axis by \f(CW$sy\fR,
about centery point ($cx, \f(CW$cy\fR).
.Sp
Centa point ($cx, \f(CW$cy\fR) is optionizzle \*(-- if these is omitted, tha function
will scale bout tha origin.
.Sp
To flip a polything, bust a scale factor of \-1.  For example, to
flip tha polythang top ta bottom bout line y = 100, use:
.Sp
.Vb 1
\&        $poly\->scale(1, \-1, 0, 100);
.Ve
.SH "New Polygon Methods"
.IX Header "New Polygon Methods"
Da followin methodz is added ta GD::Polygon, n' thus can be used
by polygons n' polylines.
.PP
Don't forget: a polyline be a GD::Polygon, so GD::Polygon methodz 
like \fIoffset()\fR can be used, n' they can be used in
GD::Image methodz like \fIfilledPolygon()\fR.
.ie n .IP """rotate""" 5
.el .IP "\f(CWrotate\fR" 5
.IX Item "rotate"
\&\f(CW\*(C`$poly\->rotate($angle, $cx, $cy)\*(C'\fR \fIobject method\fR
.Sp
Rotate a polythang all up in \f(CW$angle\fR (clockwise, up in radians) bout centa point ($cx, \f(CW$cy\fR).
.Sp
Centa point ($cx, \f(CW$cy\fR) is optionizzle \*(-- if these is omitted, tha function
will rotate bout tha origin
.Sp
In dis function n' other angle-oriented functions up in GD::Polyline,
positizzle \f(CW$angle\fR correnspondz ta clockwise rotation. I aint talkin' bout chicken n' gravy biatch.  This is opposite
of tha usual Cartesian sense yo, but dat is cuz tha rasta is opposite
of tha usual Cartesian sense up in dat tha y\-axis goes \*(L"down\*(R".
.ie n .IP """centroid""" 5
.el .IP "\f(CWcentroid\fR" 5
.IX Item "centroid"
\&\f(CW\*(C`($cx, $cy) = $poly\->centroid($scale)\*(C'\fR \fIobject method\fR
.Sp
Calculate n' return ($cx, \f(CW$cy\fR), tha centrizzle of tha verticez of tha polything.
For example, ta rotate suttin' 180 degrees bout itz centroid:
.Sp
.Vb 1
\&        $poly\->rotate(3.14159, $poly\->centroid());
.Ve
.Sp
\&\f(CW$scale\fR is optional; if supplied, \f(CW$cx\fR n' \f(CW$cy\fR is multiplied by \f(CW$scale\fR 
before returning.  Da main use of dis is ta shift a polythang ta tha 
origin like this:
.Sp
.Vb 1
\&        $poly\->offset($poly\->centroid(\-1));
.Ve
.ie n .IP """segLength""" 5
.el .IP "\f(CWsegLength\fR" 5
.IX Item "segLength"
\&\f(CW\*(C`@segLengths = $poly\->segLength()\*(C'\fR \fIobject method\fR
.Sp
In array context, returns a array tha lengthz of tha segments up in tha polything.
Segment n is tha segment from vertex n ta vertex n+1.
Polygons have as nuff segments as vertices; polylines have one fewer.
.Sp
In a scalar context, returns tha sum of tha array dat would done been returned
in tha array context.
.ie n .IP """segAngle""" 5
.el .IP "\f(CWsegAngle\fR" 5
.IX Item "segAngle"
\&\f(CW\*(C`@segAnglez = $poly\->segAngle()\*(C'\fR \fIobject method\fR
.Sp
Returns a array tha anglez of each segment from tha x\-axis.
Segment n is tha segment from vertex n ta vertex n+1.
Polygons have as nuff segments as vertices; polylines have one fewer.
.Sp
Returned anglez is ghon be on tha interval 0 <= \f(CW$angle\fR < 2 * pi and
anglez increase up in a cold-ass lil clockwise direction.
.ie n .IP """vertexAngle""" 5
.el .IP "\f(CWvertexAngle\fR" 5
.IX Item "vertexAngle"
\&\f(CW\*(C`@vertexAnglez = $poly\->vertexAngle()\*(C'\fR \fIobject method\fR
.Sp
Returns a array of tha anglez between tha segment tha fuck into n' outta each vertex.
For polylines, tha vertex angle at vertex 0 n' tha last vertex is not defined;
however \f(CW$vertexAngle\fR[0] is ghon be undef so dat \f(CW$vertexAngle\fR[1] will correspond ta 
vertex 1.
.Sp
Returned anglez is ghon be on tha interval 0 <= \f(CW$angle\fR < 2 * pi and
anglez increase up in a cold-ass lil clockwise direction.
.Sp
Note dat dis calculation do not attempt ta figure up tha \*(L"interior\*(R" angle
with respect ta \*(L"inside\*(R" or \*(L"outside\*(R" tha polygon yo, but rather, 
just tha angle between tha adjacent segments
in a cold-ass lil clockwise sense.  Thus a polygon wit all right anglez gonna git vertex
anglez of either pi/2 or 3*pi/2, dependin on tha way tha polygon was \*(L"wound\*(R".
.ie n .IP """toSpline""" 5
.el .IP "\f(CWtoSpline\fR" 5
.IX Item "toSpline"
\&\f(CW\*(C`$poly\->toSpline()\*(C'\fR \fIobject method & factory method\fR
.Sp
Smoke a freshly smoked up polythang which be a reasonably smooth curve
usin cubic spline algorithms, often referred ta as Bezier
curves.  Da \*(L"source\*(R" polythang is called tha \*(L"control polything\*(R".
If it aint nuthin but a polyline, tha control polyline must 
have 4, 7, 10, or some number of verticez of equal ta 3n+1.
If it aint nuthin but a polygon, tha control polygon must 
have 3, 6, 9, or some number of verticez of equal ta 3n.
.Sp
.Vb 2
\&        $spline = $poly\->toSpline();    
\&        $image\->polydraw($spline,$red);
.Ve
.Sp
In brief, crewz of four points from tha control polyline
are considered \*(L"control
points\*(R" fo' a given portion of tha spline: tha straight-up original gangsta and
fourth is \*(L"anchor points\*(R", n' tha spline passes through
them; tha second n' third is \*(L"director points\*(R".  The
spline do not pass all up in director points, however the
spline is tangent ta tha line segment from anchor point to
adjacent director point.
.Sp
Da next portion of tha spline reuses tha previous portion's
last anchor point.  Da spline gonna git a cold-ass lil cusp
(non-continuous slope) at a anchor point, unless tha anchor
points n' its adjacent director point is colinear.
.Sp
In tha current implementation, \fItoSpline()\fR return a gangbangin' fixed
number of segments up in tha returned polyline per set-of-four
control points, n' you can put dat on yo' toast.  In tha future, dis n' other parametas of
the algorithm may be configurable.
.ie n .IP """addControlPoints""" 5
.el .IP "\f(CWaddControlPoints\fR" 5
.IX Item "addControlPoints"
\&\f(CW\*(C`$polyline\->addControlPoints()\*(C'\fR \fIobject method & factory method\fR
.Sp
So you say: \*(L"\s-1OK. \s0 Splines sound cool.  But how tha fuck can I
get mah anchor points n' its adjacent director point ta be
colinear so dat I gots a sick smooth curves from my
polyline?\*(R"  Relax!  For Da Lazy: \fIaddControlPoints()\fR ta the
rescue.
.Sp
\&\fIaddControlPoints()\fR returns a polyline dat can serve
as tha control polyline fo' \fItoSpline()\fR, which returns
another polyline which is tha spline.  Is yo' head spinning
yet?  Think of it dis way:
.RS 5
.IP "+" 5
If you gotz a polyline, n' you have already put your
control points where you want them, call \fItoSpline()\fR directly.
Remember, only every last muthafuckin third vertex is ghon be \*(L"on\*(R" tha spline.
.Sp
Yo ass git suttin' dat be lookin like tha spline \*(L"inscribed\*(R" 
inside tha control polyline.
.IP "+" 5
If you gotz a polyline, n' you want all of its vertices on
the resultin spline, call \fIaddControlPoints()\fR n' then
\&\fItoSpline()\fR:
.Sp
.Vb 3
\&        $control = $polyline\->addControlPoints();       
\&        $spline  = $control\->toSpline();        
\&        $image\->polyline($spline,$red);
.Ve
.Sp
Yo ass git suttin' dat be lookin like tha control polyline \*(L"inscribed\*(R" 
inside tha spline.
.RE
.RS 5
.Sp
Addin \*(L"good\*(R" control points is subjective; dis particular 
algorithm reveals its authorz tastes.  
In tha future, you may be able ta alta tha taste slightly
via parametas ta tha algorithm.  For Da Hubristic: please 
build a funky-ass betta one!
.Sp
And fo' Da Impatient: note dat \fIaddControlPoints()\fR returns a
polyline, so you can pile up tha the call like this, 
if you'd like:
.Sp
.Vb 1
\&        $image\->polyline($polyline\->addControlPoints()\->toSpline(),$mauve);
.Ve
.RE
.SH "New GD::Image Methods"
.IX Header "New GD::Image Methods"
.ie n .IP """polyline""" 5
.el .IP "\f(CWpolyline\fR" 5
.IX Item "polyline"
\&\f(CW\*(C`$image\->polyline(polyline,color)\*(C'\fR \fIobject method\fR
.Sp
.Vb 1
\&        $image\->polyline($polyline,$black)
.Ve
.Sp
This draws a polyline wit tha specified color. Shiiit, dis aint no joke.  
Both real color indexes n' tha special 
colors gdBrushed, gdStyled n' gdStyledBrushed can be specified.
.Sp
Neither tha \fIpolyline()\fR method or tha \fIpolygon()\fR method is hella
picky: you can call either method wit either a GD::Polygon or a GD::Polyline.
Da \fImethod\fR determines if tha shape is \*(L"closed\*(R" or \*(L"open\*(R" as drawn, \fInot\fR
the object type.
.ie n .IP """polydraw""" 5
.el .IP "\f(CWpolydraw\fR" 5
.IX Item "polydraw"
\&\f(CW\*(C`$image\->polydraw(polything,color)\*(C'\fR \fIobject method\fR
.Sp
.Vb 1
\&        $image\->polydraw($poly,$black)
.Ve
.Sp
This method draws tha polythang as expected (polygons is closed, 
polylines is open) by simply checkin tha object type n' callin 
either \f(CW$image\fR\->\fIpolygon()\fR or \f(CW$image\fR\->\fIpolyline()\fR.
.SH "Examples"
.IX Header "Examples"
Please peep file \*(L"polyline\-examples.pl\*(R" dat is included wit tha distribution.
.SH "See Also"
.IX Header "See Also"
For mo' info on Bezier splines, peep http://www.webreference.com/dlab/9902/bezier.html.
.SH "Future Features"
.IX Header "Future Features"
On tha drawin board is additionizzle features such as:
.PP
.Vb 1
\&        \- polygon windin algorithms (to determine if a point is "inside" or "outside" tha polygon)
\&
\&        \- freshly smoked up polygon from boundin box
\&        
\&        \- find boundin polygon (tightest fittin simple convex polygon fo' a given set of vertices)
\&        
\&        \- addPts() method ta add nuff points at once
\&        
\&        \- clone() method fo' polygon
\&        
\&        \- functions ta interwork GD wit SVG
.Ve
.PP
Please provide input on other possible features you'd like ta see.
.SH "Author"
.IX Header "Author"
This module has been freestyled by Daniel J yo. Harasty.  
Please bust thangs, comments, disses, n' kudos ta him
at harasty@cpan.org.
.PP
Thanks ta Lincoln Stein fo' input n' patience wit me n' this, 
my first \s-1CPAN\s0 contribution.
.SH "Copyright Information"
.IX Header "Copyright Information"
Da Polyline.pm module is copyright 2002, Daniel J yo. Harasty.  It is
distributed under tha same terms as Perl itself.  See tha \*(L"Artistic
License\*(R" up in tha Perl source code distribution fo' licensin terms.
.PP
Da sickest fuckin version of Polyline.pm be available at 
your straight-up \s-1CPAN\s0 repository and/or 
along wit \s-1GD\s0.pm by Lincoln D. Right back up in yo muthafuckin ass. Stein at http://stein.cshl.org/WWW/software/GD.
