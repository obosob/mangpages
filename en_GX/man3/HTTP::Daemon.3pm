.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Daemon 3"
.TH HTTP::Daemon 3 "2012-02-18" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Daemon \- a simple http server class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use HTTP::Daemon;
\&  use HTTP::Status;
\&
\&  mah $d = HTTP::Daemon\->new || die;
\&  print "Please contact me at: <URL:", $d\->url, ">\en";
\&  while (my $c = $d\->accept) {
\&      while (my $r = $c\->get_request) {
\&          if ($r\->method eq \*(AqGET\*(Aq n' $r\->uri\->path eq "/xyzzy") {
\&              # remember, dis is *not* recommended practice :\-)
\&              $c\->send_file_response("/etc/passwd");
\&          }
\&          else {
\&              $c\->send_error(RC_FORBIDDEN)
\&          }
\&      }
\&      $c\->close;
\&      undef($c);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Instancez of tha \f(CW\*(C`HTTP::Daemon\*(C'\fR class is \s-1HTTP/1.1\s0 servers that
listen on a socket fo' incomin requests, n' you can put dat on yo' toast. Da \f(CW\*(C`HTTP::Daemon\*(C'\fR be a
subclass of \f(CW\*(C`IO::Socket::INET\*(C'\fR, so you can big-ass up socket operations
directly on it like a muthafucka.
.PP
Da \fIaccept()\fR method will return when a cold-ass lil connection from a cold-ass lil client is
available.  Da returned value is ghon be a \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR
object which be another \f(CW\*(C`IO::Socket::INET\*(C'\fR subclass.  Callin the
\&\fIget_request()\fR method on dis object will read data from tha client and
return a \f(CW\*(C`HTTP::Request\*(C'\fR object.  Da ClientConn object also provide
methodz ta bust back various responses.
.PP
This \s-1HTTP\s0 daemon do not \fIfork\fR\|(2) fo' yo thugged-out ass.  Yo crazy-ass application, i.e. the
user of tha \f(CW\*(C`HTTP::Daemon\*(C'\fR is responsible fo' forkin if dat is
desirable.  Also note dat tha user is responsible fo' generating
responses dat conform ta tha \s-1HTTP/1.1\s0 protocol.
.PP
Da followin methodz of \f(CW\*(C`HTTP::Daemon\*(C'\fR is freshly smoked up (or enhanced) relative
to tha \f(CW\*(C`IO::Socket::INET\*(C'\fR base class:
.ie n .IP "$d = HTTP::Daemon\->new" 4
.el .IP "\f(CW$d\fR = HTTP::Daemon\->new" 4
.IX Item "$d = HTTP::Daemon->new"
.PD 0
.ie n .IP "$d = HTTP::Daemon\->new( %opts )" 4
.el .IP "\f(CW$d\fR = HTTP::Daemon\->new( \f(CW%opts\fR )" 4
.IX Item "$d = HTTP::Daemon->new( %opts )"
.PD
Da constructor method takes tha same ol' dirty arguments as the
\&\f(CW\*(C`IO::Socket::INET\*(C'\fR constructor yo, but unlike its base class it can also
be called without any arguments, n' you can put dat on yo' toast.  Da daemon will then set up a listen
queue of 5 connections n' allocate some random port number.
.Sp
A server dat wants ta bind ta some specific address on tha standard
\&\s-1HTTP\s0 port is ghon be constructed like this:
.Sp
.Vb 4
\&  $d = HTTP::Daemon\->new(
\&           LocalAddr => \*(Aqwww.thisplace.com\*(Aq,
\&           LocalPort => 80,
\&       );
.Ve
.Sp
See IO::Socket::INET fo' a thugged-out description of other arguments dat can
be used configure tha daemon durin construction.
.ie n .IP "$c = $d\->accept" 4
.el .IP "\f(CW$c\fR = \f(CW$d\fR\->accept" 4
.IX Item "$c = $d->accept"
.PD 0
.ie n .IP "$c = $d\->accept( $pkg )" 4
.el .IP "\f(CW$c\fR = \f(CW$d\fR\->accept( \f(CW$pkg\fR )" 4
.IX Item "$c = $d->accept( $pkg )"
.ie n .IP "($c, $peer_addr) = $d\->accept" 4
.el .IP "($c, \f(CW$peer_addr\fR) = \f(CW$d\fR\->accept" 4
.IX Item "($c, $peer_addr) = $d->accept"
.PD
This method works tha same ol' dirty tha one provided by tha base class yo, but it
returns a \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR reference by default.  If a
package name is provided as argument, then tha returned object will be
blessed tha fuck into tha given class.  It be probably a phat scam ta make that
class a subclass of \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR.
.Sp
Da accept method will return \f(CW\*(C`undef\*(C'\fR if timeouts done been enabled
and no connection is made within tha given time.  Da \fItimeout()\fR method
is busted lyrics bout up in IO::Socket.
.Sp
In list context both tha client object n' tha peer address will be
returned; peep tha description of tha accept method IO::Socket for
details.
.ie n .IP "$d\->url" 4
.el .IP "\f(CW$d\fR\->url" 4
.IX Item "$d->url"
Returns a \s-1URL\s0 strang dat can be used ta access tha server root.
.ie n .IP "$d\->product_tokens" 4
.el .IP "\f(CW$d\fR\->product_tokens" 4
.IX Item "$d->product_tokens"
Returns tha name dat dis server will use ta identify itself.  This
is tha strang dat is busted wit tha \f(CW\*(C`Server\*(C'\fR response header n' shit.  The
main reason ta have dis method is dat subclasses can override it if
they wanna use another thang name.
.Sp
Da default is tha strang \*(L"libwww\-perl\-daemon/#.##\*(R" where \*(L"#.##\*(R" is
replaced wit tha version number of dis module.
.PP
Da \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR be a \f(CW\*(C`IO::Socket::INET\*(C'\fR
subclass. Instancez of dis class is returned by tha \fIaccept()\fR method
of \f(CW\*(C`HTTP::Daemon\*(C'\fR.  Da followin methodz is provided:
.ie n .IP "$c\->get_request" 4
.el .IP "\f(CW$c\fR\->get_request" 4
.IX Item "$c->get_request"
.PD 0
.ie n .IP "$c\->get_request( $headers_only )" 4
.el .IP "\f(CW$c\fR\->get_request( \f(CW$headers_only\fR )" 4
.IX Item "$c->get_request( $headers_only )"
.PD
This method readz data from tha client n' turns it tha fuck into an
\&\f(CW\*(C`HTTP::Request\*(C'\fR object which is returned. Y'all KNOW dat shit, muthafucka!  It returns \f(CW\*(C`undef\*(C'\fR
if readin fails.  If it fails, then tha \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR
object ($c) should be discarded, n' you should not try call this
method again n' again n' again on dat shit.  Da \f(CW$c\fR\->reason method might hit you wit some
information bout why \f(CW$c\fR\->get_request failed.
.Sp
Da \fIget_request()\fR method will normally not return until tha whole
request has been received from tha client.  This might not be what tha fuck you
want if tha request be a upload of a big-ass file (and wit chunked
transfer encodin \s-1HTTP\s0 can even support infinite request lyrics \-
uploadin live audio fo' instance).  If you pass a \s-1TRUE\s0 value as the
\&\f(CW$headers_only\fR argument, then \fIget_request()\fR will return immediately
afta parsin tha request headaz n' yo ass is responsible fo' reading
the rest of tha request content.  If yo ass is goin ta call
\&\f(CW$c\fR\->get_request again n' again n' again on tha same connection you betta read the
correct number of bytes.
.ie n .IP "$c\->read_buffer" 4
.el .IP "\f(CW$c\fR\->read_buffer" 4
.IX Item "$c->read_buffer"
.PD 0
.ie n .IP "$c\->read_buffer( $new_value )" 4
.el .IP "\f(CW$c\fR\->read_buffer( \f(CW$new_value\fR )" 4
.IX Item "$c->read_buffer( $new_value )"
.PD
Bytes read by \f(CW$c\fR\->get_request yo, but not used is placed up in tha \fIread
buffer\fR.  Da next time \f(CW$c\fR\->get_request is called it will consume the
bytes up in dis buffer before readin mo' data from tha network
connection itself.  Da read buffer is invalid afta \f(CW$c\fR\->get_request
has failed.
.Sp
If you handle tha readin of tha request content yo ass you need to
empty dis buffer before you read mo' n' you need ta place
unconsumed bytes here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Yo ass also need dis buffer if you implement
skillz like \fI101 Switchin Protocols\fR.
.Sp
This method always returns tha oldschool buffer content n' can optionally
replace tha buffer content if you pass it a argument.
.ie n .IP "$c\->reason" 4
.el .IP "\f(CW$c\fR\->reason" 4
.IX Item "$c->reason"
When \f(CW$c\fR\->get_request returns \f(CW\*(C`undef\*(C'\fR you can obtain a gangbangin' finger-lickin' dirty-ass short string
describin why it happened by callin \f(CW$c\fR\->reason.
.ie n .IP "$c\->proto_ge( $proto )" 4
.el .IP "\f(CW$c\fR\->proto_ge( \f(CW$proto\fR )" 4
.IX Item "$c->proto_ge( $proto )"
Return \s-1TRUE\s0 if tha client announced a protocol wit version number
greata or equal ta tha given argument.  Da \f(CW$proto\fR argument can be a
strin like \*(L"\s-1HTTP/1.1\*(R"\s0 or just \*(L"1.1\*(R".
.ie n .IP "$c\->antique_client" 4
.el .IP "\f(CW$c\fR\->antique_client" 4
.IX Item "$c->antique_client"
Return \s-1TRUE\s0 if tha client speaks tha \s-1HTTP/0.9\s0 protocol.  No status
code n' no headaz should be moonwalked back ta such a cold-ass lil client.  This should
be tha same as !$c\->proto_ge(\*(L"\s-1HTTP/1.0\*(R"\s0).
.ie n .IP "$c\->head_request" 4
.el .IP "\f(CW$c\fR\->head_request" 4
.IX Item "$c->head_request"
Return \s-1TRUE\s0 if tha last request was a \f(CW\*(C`HEAD\*(C'\fR request.  No content
body must be generated fo' these requests.
.ie n .IP "$c\->force_last_request" 4
.el .IP "\f(CW$c\fR\->force_last_request" 4
.IX Item "$c->force_last_request"
Make shizzle dat \f(CW$c\fR\->get_request aint gonna try ta read mo' requests off
this connection. I aint talkin' bout chicken n' gravy biatch.  If you generate a response dat aint self
delimiting, then you should signal dis fact by callin dis method.
.Sp
This attribute is turned on automatically if tha client announces
protocol \s-1HTTP/1.0\s0 or worse n' do not include a \*(L"Connection:
Keep-Kickin It\*(R" header n' shit.  It be also turned on automatically when \s-1HTTP/1.1\s0
or betta clients bust tha \*(L"Connection: close\*(R" request header.
.ie n .IP "$c\->send_status_line" 4
.el .IP "\f(CW$c\fR\->send_status_line" 4
.IX Item "$c->send_status_line"
.PD 0
.ie n .IP "$c\->send_status_line( $code )" 4
.el .IP "\f(CW$c\fR\->send_status_line( \f(CW$code\fR )" 4
.IX Item "$c->send_status_line( $code )"
.ie n .IP "$c\->send_status_line( $code, $mess )" 4
.el .IP "\f(CW$c\fR\->send_status_line( \f(CW$code\fR, \f(CW$mess\fR )" 4
.IX Item "$c->send_status_line( $code, $mess )"
.ie n .IP "$c\->send_status_line( $code, $mess, $proto )" 4
.el .IP "\f(CW$c\fR\->send_status_line( \f(CW$code\fR, \f(CW$mess\fR, \f(CW$proto\fR )" 4
.IX Item "$c->send_status_line( $code, $mess, $proto )"
.PD
Send tha status line back ta tha client.  If \f(CW$code\fR is omitted 200 is
assumed. Y'all KNOW dat shit, muthafucka!  If \f(CW$mess\fR is omitted, then a message correspondin ta \f(CW$code\fR
is inserted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \f(CW$proto\fR is missin tha content of the
\&\f(CW$HTTP::Daemon::PROTO\fR variable is used.
.ie n .IP "$c\->send_crlf" 4
.el .IP "\f(CW$c\fR\->send_crlf" 4
.IX Item "$c->send_crlf"
Send tha \s-1CRLF\s0 sequence ta tha client.
.ie n .IP "$c\->send_basic_header" 4
.el .IP "\f(CW$c\fR\->send_basic_header" 4
.IX Item "$c->send_basic_header"
.PD 0
.ie n .IP "$c\->send_basic_header( $code )" 4
.el .IP "\f(CW$c\fR\->send_basic_header( \f(CW$code\fR )" 4
.IX Item "$c->send_basic_header( $code )"
.ie n .IP "$c\->send_basic_header( $code, $mess )" 4
.el .IP "\f(CW$c\fR\->send_basic_header( \f(CW$code\fR, \f(CW$mess\fR )" 4
.IX Item "$c->send_basic_header( $code, $mess )"
.ie n .IP "$c\->send_basic_header( $code, $mess, $proto )" 4
.el .IP "\f(CW$c\fR\->send_basic_header( \f(CW$code\fR, \f(CW$mess\fR, \f(CW$proto\fR )" 4
.IX Item "$c->send_basic_header( $code, $mess, $proto )"
.PD
Send tha status line n' tha \*(L"Date:\*(R" n' \*(L"Server:\*(R" headaz back to
the client.  This header be assumed ta be continued n' do not end
with a empty \s-1CRLF\s0 line.
.Sp
See tha description of \fIsend_status_line()\fR fo' tha description of the
accepted arguments.
.ie n .IP "$c\->send_header( $field, $value )" 4
.el .IP "\f(CW$c\fR\->send_header( \f(CW$field\fR, \f(CW$value\fR )" 4
.IX Item "$c->send_header( $field, $value )"
.PD 0
.ie n .IP "$c\->send_header( $field1, $value1, $field2, $value2, ... )" 4
.el .IP "\f(CW$c\fR\->send_header( \f(CW$field1\fR, \f(CW$value1\fR, \f(CW$field2\fR, \f(CW$value2\fR, ... )" 4
.IX Item "$c->send_header( $field1, $value1, $field2, $value2, ... )"
.PD
Send one or mo' header lines.
.ie n .IP "$c\->send_response( $res )" 4
.el .IP "\f(CW$c\fR\->send_response( \f(CW$res\fR )" 4
.IX Item "$c->send_response( $res )"
Write a \f(CW\*(C`HTTP::Response\*(C'\fR object ta the
client as a response.  We try hard ta make shizzle dat tha response is
self delimitin so dat tha connection can stay persistent fo' further
request/response exchanges.
.Sp
Da content attribute of tha \f(CW\*(C`HTTP::Response\*(C'\fR object can be a normal
strin or a subroutine reference.  If it aint nuthin but a subroutine, then
whatever dis callback routine returns is freestyled back ta the
client as tha response content.  Da routine is ghon be called until it
return a undefined or empty value.  If tha client is \s-1HTTP/1.1\s0 aware
then we will use chunked transfer encodin fo' tha response.
.ie n .IP "$c\->send_redirect( $loc )" 4
.el .IP "\f(CW$c\fR\->send_redirect( \f(CW$loc\fR )" 4
.IX Item "$c->send_redirect( $loc )"
.PD 0
.ie n .IP "$c\->send_redirect( $loc, $code )" 4
.el .IP "\f(CW$c\fR\->send_redirect( \f(CW$loc\fR, \f(CW$code\fR )" 4
.IX Item "$c->send_redirect( $loc, $code )"
.ie n .IP "$c\->send_redirect( $loc, $code, $entity_body )" 4
.el .IP "\f(CW$c\fR\->send_redirect( \f(CW$loc\fR, \f(CW$code\fR, \f(CW$entity_body\fR )" 4
.IX Item "$c->send_redirect( $loc, $code, $entity_body )"
.PD
Send a redirect response back ta tha client.  Da location ($loc) can
be a absolute or relatizzle \s-1URL.\s0 Da \f(CW$code\fR must be one tha redirect
status codes, n' defaults ta \*(L"301 Moved Permanently\*(R"
.ie n .IP "$c\->send_error" 4
.el .IP "\f(CW$c\fR\->send_error" 4
.IX Item "$c->send_error"
.PD 0
.ie n .IP "$c\->send_error( $code )" 4
.el .IP "\f(CW$c\fR\->send_error( \f(CW$code\fR )" 4
.IX Item "$c->send_error( $code )"
.ie n .IP "$c\->send_error( $code, $error_message )" 4
.el .IP "\f(CW$c\fR\->send_error( \f(CW$code\fR, \f(CW$error_message\fR )" 4
.IX Item "$c->send_error( $code, $error_message )"
.PD
Send a error response back ta tha client.  If tha \f(CW$code\fR is missin a
\&\*(L"Wack Request\*(R" error is reported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \f(CW$error_message\fR be a strang that
is incorporated up in tha body of tha \s-1HTML\s0 entitizzle body.
.ie n .IP "$c\->send_file_response( $filename )" 4
.el .IP "\f(CW$c\fR\->send_file_response( \f(CW$filename\fR )" 4
.IX Item "$c->send_file_response( $filename )"
Send back a response wit tha specified \f(CW$filename\fR as content.  If the
file be a gangbangin' finger-lickin' directory we try ta generate a \s-1HTML\s0 index of dat shit.
.ie n .IP "$c\->send_file( $filename )" 4
.el .IP "\f(CW$c\fR\->send_file( \f(CW$filename\fR )" 4
.IX Item "$c->send_file( $filename )"
.PD 0
.ie n .IP "$c\->send_file( $fd )" 4
.el .IP "\f(CW$c\fR\->send_file( \f(CW$fd\fR )" 4
.IX Item "$c->send_file( $fd )"
.PD
Copy tha file ta tha client.  Da file can be a strang (which
will be interpreted as a gangbangin' filename) or a reference ta a \f(CW\*(C`IO::Handle\*(C'\fR
or glob.
.ie n .IP "$c\->daemon" 4
.el .IP "\f(CW$c\fR\->daemon" 4
.IX Item "$c->daemon"
Return a reference ta tha correspondin \f(CW\*(C`HTTP::Daemon\*(C'\fR object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1RFC 2616\s0
.PP
IO::Socket::INET, IO::Socket
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1996\-2003, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself.
