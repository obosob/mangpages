" 3 "Thu Sep 11 2014" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_pbds::detail::binary_heap< Value_Type, Cmp_Fn, _Alloc > \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits type< Value_Type, Cmp_Fn, _Alloc, is_simple< Value_Type >::value >, n' \fB__gnu_pbds::detail::resize_policy< _Alloc::size_type >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef Cmp_Fn \fBcmp_fn\fP"
.br
.ti -1c
.RI "typedef \fBcond_dealtor\fP
.br
< value_type, _Alloc > \fBcond_dealtor_t\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBbinary_heap_const_iterator_\fP
.br
< value_type, entry, 
.br
simple_value, _Alloc > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef 
.br
value_allocator::const_pointa \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef 
.br
value_allocator::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef _Alloc::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef __conditional_type
.br
< simple_value, value_type, 
.br
pointa >::__type \fBentry\fP"
.br
.ti -1c
.RI "typedef _Alloc::template 
.br
rebind< entry >::other \fBentry_allocator\fP"
.br
.ti -1c
.RI "typedef entry_cmp< Value_Type, 
.br
Cmp_Fn, _Alloc, is_simple
.br
< Value_Type >::value >::type \fBentry_cmp\fP"
.br
.ti -1c
.RI "typedef entry_allocator::pointa \fBentry_pointer\fP"
.br
.ti -1c
.RI "typedef \fBconst_iterator\fP \fBiterator\fP"
.br
.ti -1c
.RI "typedef 
.br
\fBbinary_heap_point_const_iterator_\fP
.br
< value_type, entry, 
.br
simple_value, _Alloc > \fBpoint_const_iterator\fP"
.br
.ti -1c
.RI "typedef \fBpoint_const_iterator\fP \fBpoint_iterator\fP"
.br
.ti -1c
.RI "typedef value_allocator::pointa \fBpointer\fP"
.br
.ti -1c
.RI "typedef value_allocator::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef 
.br
\fB__gnu_pbds::detail::resize_policy\fP
.br
< typename _Alloc::size_type > \fBresize_policy\fP"
.br
.ti -1c
.RI "typedef _Alloc::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef Value_Type \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBbinary_heap\fP (const cmp_fn &)"
.br
.ti -1c
.RI "\fBbinary_heap\fP (const \fBbinary_heap\fP &)"
.br
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP ()"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const "
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP ()"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const "
.br
.ti -1c
.RI "void \fBerase\fP (\fBpoint_iterator\fP)"
.br
.ti -1c
.RI "void \fBerase_at\fP (entry_pointer, size_type, false_type)"
.br
.ti -1c
.RI "void \fBerase_at\fP (entry_pointer, size_type, true_type)"
.br
.ti -1c
.RI "template<typename Pred > \fBbinary_heap\fP< Value_Type, 
.br
Cmp_Fn, _Alloc >::size_type \fBerase_if\fP (Pred pred)"
.br
.ti -1c
.RI "template<typename Pred > size_type \fBerase_if\fP (Pred)"
.br
.ti -1c
.RI "Cmp_Fn & \fBget_cmp_fn\fP ()"
.br
.ti -1c
.RI "const Cmp_Fn & \fBget_cmp_fn\fP () const "
.br
.ti -1c
.RI "size_type \fBget_new_size_for_arbitrary\fP (size_type) const"
.br
.ti -1c
.RI "size_type \fBget_new_size_for_grow\fP () const"
.br
.ti -1c
.RI "size_type \fBget_new_size_for_shrink\fP () const"
.br
.ti -1c
.RI "bool \fBgrow_needed\fP (size_type) const"
.br
.ti -1c
.RI "void \fBjoin\fP (\fBbinary_heap\fP &)"
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const "
.br
.ti -1c
.RI "void \fBmodify\fP (\fBpoint_iterator\fP, const_reference)"
.br
.ti -1c
.RI "void \fBnotify_arbitrary\fP (size_type)"
.br
.ti -1c
.RI "void \fBnotify_grow_resize\fP ()"
.br
.ti -1c
.RI "void \fBnotify_shrink_resize\fP ()"
.br
.ti -1c
.RI "template<typename Pred > \fBbinary_heap\fP< Value_Type, 
.br
Cmp_Fn, _Alloc >::size_type \fBpartition\fP (Pred pred)"
.br
.ti -1c
.RI "void \fBpop\fP ()"
.br
.ti -1c
.RI "\fBpoint_iterator\fP \fBpush\fP (const_reference)"
.br
.ti -1c
.RI "bool \fBresize_needed_for_grow\fP (size_type) const"
.br
.ti -1c
.RI "bool \fBresize_needed_for_shrink\fP (size_type) const"
.br
.ti -1c
.RI "bool \fBshrink_needed\fP (size_type) const"
.br
.ti -1c
.RI "size_type \fBsize\fP () const "
.br
.ti -1c
.RI "template<typename Pred > void \fBsplit\fP (Pred, \fBbinary_heap\fP &)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBresize_policy\fP< _Alloc::size_type > &)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBbinary_heap\fP &)"
.br
.ti -1c
.RI "const_reference \fBtop\fP () const "
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const _Alloc::size_type \fBmin_size\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "template<typename It > void \fBcopy_from_range\fP (It, It)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename Value_Type, typename Cmp_Fn, typename _Alloc>class __gnu_pbds::detail::binary_heap< Value_Type, Cmp_Fn, _Alloc >"
Binary heaps composed of resize n' compare policies\&.
.PP
Based on CLRS\&. 
.PP
Definizzle at line 84 of file binary_heap_\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen fo' libstdc++ from tha source code\&.
