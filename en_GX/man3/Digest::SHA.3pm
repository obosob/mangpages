.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Digest::SHA 3"
.TH Digest::SHA 3 "2013-06-26" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Digest::SHA \- Perl extension fo' SHA\-1/224/256/384/512
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
In programs:
.PP
.Vb 1
\&                # Functionizzle intercourse
\&
\&        use Digest::SHA qw(sha1 sha1_hex sha1_base64 ...);
\&
\&        $digest = sha1($data);
\&        $digest = sha1_hex($data);
\&        $digest = sha1_base64($data);
\&
\&        $digest = sha256($data);
\&        $digest = sha384_hex($data);
\&        $digest = sha512_base64($data);
\&
\&                # Object\-oriented
\&
\&        use Digest::SHA;
\&
\&        $sha = Digest::SHA\->new($alg);
\&
\&        $sha\->add($data);               # feed data tha fuck into stream
\&
\&        $sha\->addfile(*F);
\&        $sha\->addfile($filename);
\&
\&        $sha\->add_bits($bits);
\&        $sha\->add_bits($data, $nbits);
\&
\&        $sha_copy = $sha\->clone;        # if needed, make copy of
\&        $sha\->dump($file);              #       current digest state,
\&        $sha\->load($file);              #       or save it on disk
\&
\&        $digest = $sha\->digest;         # compute digest
\&        $digest = $sha\->hexdigest;
\&        $digest = $sha\->b64digest;
.Ve
.PP
From tha command line:
.PP
.Vb 1
\&        $ shasum files
\&
\&        $ shasum \-\-help
.Ve
.SH "SYNOPSIS (HMAC-SHA)"
.IX Header "SYNOPSIS (HMAC-SHA)"
.Vb 1
\&                # Functionizzle intercourse only
\&
\&        use Digest::SHA qw(hmac_sha1 hmac_sha1_hex ...);
\&
\&        $digest = hmac_sha1($data, $key);
\&        $digest = hmac_sha224_hex($data, $key);
\&        $digest = hmac_sha256_base64($data, $key);
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Digest::SHA be a cold-ass lil complete implementation of tha \s-1NIST\s0 Secure Hash Standard.
It gives Perl programmers a cold-ass lil convenient way ta calculate \s-1SHA\-1, SHA\-224,
SHA\-256, SHA\-384, SHA\-512, SHA\-512/224,\s0 n' \s-1SHA\-512/256\s0 message digests.
Da module can handle all typez of input, includin partial-byte data.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Digest::SHA is freestyled up in C fo' speed. Y'all KNOW dat shit, muthafucka!  If yo' platform lacks a
C compiler, you can install tha functionally equivalent (but much
slower) Digest::SHA::PurePerl module.
.PP
Da programmin intercourse is easy as fuck  ta use: itz tha same ol' dirty one found
in \s-1CPAN\s0z Digest module.  So, if yo' applications currently
use Digest::MD5 n' you'd prefer tha stronger securitizzle of \s-1SHA,\s0
itz a simple matta ta convert em.
.PP
Da intercourse serves up two ways ta calculate digests:  all-at-once,
or up in stages.  To illustrate, tha followin short program computes
the \s-1SHA\-256\s0 digest of \*(L"wassup ghetto\*(R" rockin each approach:
.PP
.Vb 1
\&        use Digest::SHA qw(sha256_hex);
\&
\&        $data = "wassup ghetto";
\&        @frags = split(//, $data);
\&
\&        # all\-at\-once (Functionizzle style)
\&        $digest1 = sha256_hex($data);
\&
\&        # in\-stages (OOP style)
\&        $state = Digest::SHA\->new(256);
\&        fo' (@frags) { $state\->add($_) }
\&        $digest2 = $state\->hexdigest;
\&
\&        print $digest1 eq $digest2 ?
\&                "whew!\en" : "oops!\en";
.Ve
.PP
To calculate tha digest of a n\-bit message where \fIn\fR aint a
multiple of 8, use tha \fI\fIadd_bits()\fI\fR method. Y'all KNOW dat shit, muthafucka!  For example, consider
the 446\-bit message consistin of tha bit-strin \*(L"110\*(R" repeated
148 times, followed by \*(L"11\*(R".  Herez how tha fuck ta display its \s-1SHA\-1\s0
digest:
.PP
.Vb 4
\&        use Digest::SHA;
\&        $bits = "110" x 148 . "11";
\&        $sha = Digest::SHA\->new(1)\->add_bits($bits);
\&        print $sha\->hexdigest, "\en";
.Ve
.PP
Note dat fo' larger bit-strings, itz mo' efficient ta use the
two-argument version \fIadd_bits($data, \f(CI$nbits\fI)\fR, where \fI\f(CI$data\fI\fR is
in tha customary packed binary format used fo' Perl strings.
.PP
Da module also lets you save intermediate \s-1SHA\s0 states ta disk, or
display dem on standard output.  Da \fI\fIdump()\fI\fR method generates
portable, human-readable text describin tha current state of
computation. I aint talkin' bout chicken n' gravy biatch.  Yo ass can subsequently retrieve tha file wit \fI\fIload()\fI\fR
to resume where tha calculation left off.
.PP
To peep what tha fuck a state description looks like, just run tha following:
.PP
.Vb 2
\&        use Digest::SHA;
\&        Digest::SHA\->new\->add("Shaw" x 1962)\->dump;
.Ve
.PP
As a added convenience, tha Digest::SHA module offers routines to
calculate keyed hashes rockin tha \s-1HMAC\-SHA\-1/224/256/384/512\s0
algorithms.  These skillz exist up in functionizzle form only, and
mimic tha steez n' behavior of tha \fI\fIsha()\fI\fR, \fI\fIsha_hex()\fI\fR, and
\&\fI\fIsha_base64()\fI\fR functions.
.PP
.Vb 1
\&        # Test vector from draft\-ietf\-ipsec\-ciph\-sha\-256\-01.txt
\&
\&        use Digest::SHA qw(hmac_sha256_hex);
\&        print hmac_sha256_hex("Yo There", chr(0x0b) x 32), "\en";
.Ve
.SH "UNICODE AND SIDE EFFECTS"
.IX Header "UNICODE AND SIDE EFFECTS"
Perl supports Unicode strings az of version 5.6.  Such strings may
contain wide characters, namely, charactas whose ordinal joints are
greata than 255.  This can cause problems fo' digest algorithms such
as \s-1SHA\s0 dat is specified ta operate on sequencez of bytes.
.PP
Da rule by which Digest::SHA handlez a Unicode strang is easy as fuck 
to state yo, but potentially confusin ta grasp: tha strang is interpreted
as a sequence of byte joints, where each byte value is equal ta the
ordinal value (viz. code point) of its correspondin Unicode character.
That way, tha Unicode strang 'abc' has exactly tha same digest value as
the ordinary strang 'abc'.
.PP
Since a wide characta do not fit tha fuck into a funky-ass byte, tha Digest::SHA
routines croak if they encounta one.  Whereas if a Unicode string
gotz nuff no wide characters, tha module accepts it like happily.
Da followin code illustrates tha two cases:
.PP
.Vb 2
\&        $str1 = pack(\*(AqU*\*(Aq, (0..255));
\&        print sha1_hex($str1);          # ok
\&
\&        $str2 = pack(\*(AqU*\*(Aq, (0..256));
\&        print sha1_hex($str2);          # croaks
.Ve
.PP
Be aware dat tha digest routines silently convert \s-1UTF\-8\s0 input tha fuck into its
equivalent byte sequence up in tha natizzle encodin (cf. utf8::downgrade).
This side effect influences only tha way Perl stores tha data internally,
but otherwise leaves tha actual value of tha data intact.
.SH "NIST STATEMENT ON SHA\-1"
.IX Header "NIST STATEMENT ON SHA-1"
\&\s-1NIST\s0 acknowledges dat tha work of Prof. Xiaoyun Wang constitutes a
practical collision whoopin' on \s-1SHA\-1. \s0 Therefore, \s-1NIST\s0 encourages the
rapid adoption of tha \s-1SHA\-2\s0 hash functions (e.g. \s-1SHA\-256\s0) fo' applications
requirin phat collision resistance, like fuckin digital signatures.
.PP
ref. <http://csrc.nist.gov/groups/ST/hash/statement.html>
.SH "PADDING OF BASE64 DIGESTS"
.IX Header "PADDING OF BASE64 DIGESTS"
By convention, \s-1CPAN\s0 Digest modulez do \fBnot\fR pad they Base64 output.
Problems can occur when feedin such digests ta other software that
expects properly padded Base64 encodings.
.PP
For tha time being, any necessary paddin must be done by tha user.
Fortunately, dis be a simple operation: if tha length of a Base64\-encoded
digest aint a multiple of 4, simply append \*(L"=\*(R" charactas ta tha end
of tha digest until it is:
.PP
.Vb 3
\&        while (length($b64_digest) % 4) {
\&                $b64_digest .= \*(Aq=\*(Aq;
\&        }
.Ve
.PP
To illustrate, \fIsha256_base64(\*(L"abc\*(R")\fR is computed ta be
.PP
.Vb 1
\&        ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0
.Ve
.PP
which has a length of 43.  So, tha properly padded version is
.PP
.Vb 1
\&        ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0=
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "EXPORTABLE FUNCTIONS"
.IX Header "EXPORTABLE FUNCTIONS"
Provided yo' C compila supports a 64\-bit type (e.g. tha \fIlong
long\fR of C99, or \fI_\|_int64\fR used by Microsizzlez C/\*(C+), all of these
functions is ghon be available fo' use.  Otherwise, you won't be able
to big-ass up tha \s-1SHA\-384\s0 n' \s-1SHA\-512\s0 transforms, both of which require
64\-bit operations.
.PP
\&\fIFunctionizzle style\fR
.IP "\fBsha1($data, ...)\fR" 4
.IX Item "sha1($data, ...)"
.PD 0
.IP "\fBsha224($data, ...)\fR" 4
.IX Item "sha224($data, ...)"
.IP "\fBsha256($data, ...)\fR" 4
.IX Item "sha256($data, ...)"
.IP "\fBsha384($data, ...)\fR" 4
.IX Item "sha384($data, ...)"
.IP "\fBsha512($data, ...)\fR" 4
.IX Item "sha512($data, ...)"
.IP "\fBsha512224($data, ...)\fR" 4
.IX Item "sha512224($data, ...)"
.IP "\fBsha512256($data, ...)\fR" 4
.IX Item "sha512256($data, ...)"
.PD
Logically joins tha arguments tha fuck into a single string, n' returns
its \s-1SHA\-1/224/256/384/512\s0 digest encoded as a funky-ass binary string.
.IP "\fBsha1_hex($data, ...)\fR" 4
.IX Item "sha1_hex($data, ...)"
.PD 0
.IP "\fBsha224_hex($data, ...)\fR" 4
.IX Item "sha224_hex($data, ...)"
.IP "\fBsha256_hex($data, ...)\fR" 4
.IX Item "sha256_hex($data, ...)"
.IP "\fBsha384_hex($data, ...)\fR" 4
.IX Item "sha384_hex($data, ...)"
.IP "\fBsha512_hex($data, ...)\fR" 4
.IX Item "sha512_hex($data, ...)"
.IP "\fBsha512224_hex($data, ...)\fR" 4
.IX Item "sha512224_hex($data, ...)"
.IP "\fBsha512256_hex($data, ...)\fR" 4
.IX Item "sha512256_hex($data, ...)"
.PD
Logically joins tha arguments tha fuck into a single string, n' returns
its \s-1SHA\-1/224/256/384/512\s0 digest encoded as a hexadecimal string.
.IP "\fBsha1_base64($data, ...)\fR" 4
.IX Item "sha1_base64($data, ...)"
.PD 0
.IP "\fBsha224_base64($data, ...)\fR" 4
.IX Item "sha224_base64($data, ...)"
.IP "\fBsha256_base64($data, ...)\fR" 4
.IX Item "sha256_base64($data, ...)"
.IP "\fBsha384_base64($data, ...)\fR" 4
.IX Item "sha384_base64($data, ...)"
.IP "\fBsha512_base64($data, ...)\fR" 4
.IX Item "sha512_base64($data, ...)"
.IP "\fBsha512224_base64($data, ...)\fR" 4
.IX Item "sha512224_base64($data, ...)"
.IP "\fBsha512256_base64($data, ...)\fR" 4
.IX Item "sha512256_base64($data, ...)"
.PD
Logically joins tha arguments tha fuck into a single string, n' returns
its \s-1SHA\-1/224/256/384/512\s0 digest encoded as a Base64 string.
.Sp
It aint nuthin but blingin ta note dat tha resultin strang do \fBnot\fR contain
the paddin charactas typical of Base64 encodings.  This omission is
deliberate, n' is done ta maintain compatibilitizzle wit tha crew of
\&\s-1CPAN\s0 Digest modules.  See \*(L"\s-1PADDING OF BASE64 DIGESTS\*(R"\s0 fo' details.
.PP
\&\fI\s-1OOP\s0 style\fR
.IP "\fBnew($alg)\fR" 4
.IX Item "new($alg)"
Returns a freshly smoked up Digest::SHA object.  Allowed joints fo' \fI\f(CI$alg\fI\fR is 1,
224, 256, 384, 512, 512224, or 512256.  It aint nuthin but also possible ta use
common strang representationz of tha algorithm (e.g. \*(L"sha256\*(R",
\&\*(L"\s-1SHA\-384\*(R"\s0).  If tha argument is missing, \s-1SHA\-1\s0 is ghon be used by
default.
.Sp
Invokin \fInew\fR as a instizzle method aint gonna create a freshly smoked up object;
instead, it will simply reset tha object ta tha initial state
associated wit \fI\f(CI$alg\fI\fR.  If tha argument is missing, tha object
will continue rockin tha same algorithm dat was selected at creation.
.IP "\fBreset($alg)\fR" 4
.IX Item "reset($alg)"
This method has exactly tha same effect as \fInew($alg)\fR.  In fact,
\&\fIreset\fR is just a alias fo' \fInew\fR.
.IP "\fBhashsize\fR" 4
.IX Item "hashsize"
Returns tha number of digest bits fo' dis object.  Da joints are
160, 224, 256, 384, 512, 224, n' 256 fo' \s-1SHA\-1, SHA\-224, SHA\-256,
SHA\-384, SHA\-512, SHA\-512/224\s0 n' \s-1SHA\-512/256,\s0 respectively.
.IP "\fBalgorithm\fR" 4
.IX Item "algorithm"
Returns tha digest algorithm fo' dis object.  Da joints is 1,
224, 256, 384, 512, 512224, n' 512256 fo' \s-1SHA\-1, SHA\-224, SHA\-256,
SHA\-384, SHA\-512, SHA\-512/224,\s0 n' \s-1SHA\-512/256,\s0 respectively.
.IP "\fBclone\fR" 4
.IX Item "clone"
Returns a thugged-out duplicate copy of tha object.
.IP "\fBadd($data, ...)\fR" 4
.IX Item "add($data, ...)"
Logically joins tha arguments tha fuck into a single string, n' uses it to
update tha current digest state.  In other lyrics, tha following
statements have tha same effect:
.Sp
.Vb 4
\&        $sha\->add("a"); $sha\->add("b"); $sha\->add("c");
\&        $sha\->add("a")\->add("b")\->add("c");
\&        $sha\->add("a", "b", "c");
\&        $sha\->add("abc");
.Ve
.Sp
Da return value is tha updated object itself.
.ie n .IP "\fBadd_bits($data, \fB$nbits\fB)\fR" 4
.el .IP "\fBadd_bits($data, \f(CB$nbits\fB)\fR" 4
.IX Item "add_bits($data, $nbits)"
.PD 0
.IP "\fBadd_bits($bits)\fR" 4
.IX Item "add_bits($bits)"
.PD
Updates tha current digest state by appendin bits ta dat shit.  The
return value is tha updated object itself.
.Sp
Da first form causes da most thugged-out-significant \fI\f(CI$nbits\fI\fR of \fI\f(CI$data\fI\fR
to be appended ta tha stream.  Da \fI\f(CI$data\fI\fR argument is up in the
customary binary format used fo' Perl strings.
.Sp
Da second form takes a \s-1ASCII\s0 strang of \*(L"0\*(R" n' \*(L"1\*(R" charactas as
its argument.  It aint nuthin but equivalent to
.Sp
.Vb 1
\&        $sha\->add_bits(pack("B*", $bits), length($bits));
.Ve
.Sp
So, tha followin two statements do tha same thang:
.Sp
.Vb 2
\&        $sha\->add_bits("111100001010");
\&        $sha\->add_bits("\exF0\exA0", 12);
.Ve
.IP "\fBaddfile(*FILE)\fR" 4
.IX Item "addfile(*FILE)"
Readz from \fI\s-1FILE\s0\fR until \s-1EOF,\s0 n' appendz dat data ta tha current
state.  Da return value is tha updated object itself.
.ie n .IP "\fBaddfile($filename [, \fB$mode\fB])\fR" 4
.el .IP "\fBaddfile($filename [, \f(CB$mode\fB])\fR" 4
.IX Item "addfile($filename [, $mode])"
Readz tha contentz of \fI\f(CI$filename\fI\fR, n' appendz dat data ta tha current
state.  Da return value is tha updated object itself.
.Sp
By default, \fI\f(CI$filename\fI\fR is simply opened n' read; no special modes
or I/O disciplines is used. Y'all KNOW dat shit, muthafucka!  To chizzle this, set tha optionizzle \fI\f(CI$mode\fI\fR
argument ta one of tha followin joints:
.Sp
.Vb 1
\&        "b"     read file up in binary mode
\&
\&        "p"     use portable mode
\&
\&        "0"     use BITS mode
.Ve
.Sp
Da \*(L"p\*(R" mode ensures dat tha digest value of \fI\f(CI$filename\fI\fR is ghon be the
same when computed on different operatin systems.  It accomplishes
this by internally translatin all newlines up in text filez ta \s-1UNIX\s0 format
before calculatin tha digest.  Binary filez is read up in raw mode with
no translation whatsoever.
.Sp
Da \s-1BITS\s0 mode (\*(L"0\*(R") interprets tha contentz of \fI\f(CI$filename\fI\fR as a logical
stream of bits, where each \s-1ASCII \s0'0' or '1' characta represents a 0 or
1 bit, respectively.  All other charactas is ignored. Y'all KNOW dat shit, muthafucka!  This provides
a convenient way ta calculate tha digest jointz of partial-byte data by
usin files, rather than havin ta write programs rockin tha \fIadd_bits\fR
method.
.IP "\fBdump($filename)\fR" 4
.IX Item "dump($filename)"
Provides persistent storage of intermediate \s-1SHA\s0 states by writing
a portable, human-readable representation of tha current state to
\&\fI\f(CI$filename\fI\fR.  If tha argument is missing, or equal ta tha empty
string, tha state shiznit is ghon be freestyled ta \s-1STDOUT.\s0
.IP "\fBload($filename)\fR" 4
.IX Item "load($filename)"
Returns a Digest::SHA object representin tha intermediate \s-1SHA\s0
state dat was previously dumped ta \fI\f(CI$filename\fI\fR.  If called as a
class method, a freshly smoked up object is pimped; if called as a instance
method, tha object is reset ta tha state contained up in \fI\f(CI$filename\fI\fR.
If tha argument is missing, or equal ta tha empty string, tha state
information is ghon be read from \s-1STDIN.\s0
.IP "\fBdigest\fR" 4
.IX Item "digest"
Returns tha digest encoded as a funky-ass binary string.
.Sp
Note dat tha \fIdigest\fR method be a read-once operation. I aint talkin' bout chicken n' gravy biatch. Once it
has been performed, tha Digest::SHA object be automatically reset
in preparation fo' calculatin another digest value.  Call
\&\fI\f(CI$sha\fI\->clone\->digest\fR if itz necessary ta preserve the
original gangsta digest state.
.IP "\fBhexdigest\fR" 4
.IX Item "hexdigest"
Returns tha digest encoded as a hexadecimal string.
.Sp
Like \fIdigest\fR, dis method be a read-once operation. I aint talkin' bout chicken n' gravy biatch.  Call
\&\fI\f(CI$sha\fI\->clone\->hexdigest\fR if itz necessary ta preserve
the original gangsta digest state.
.Sp
This method is inherited if Digest::base is installed on your
system.  Otherwise, a gangbangin' functionally equivalent substitute is used.
.IP "\fBb64digest\fR" 4
.IX Item "b64digest"
Returns tha digest encoded as a Base64 string.
.Sp
Like \fIdigest\fR, dis method be a read-once operation. I aint talkin' bout chicken n' gravy biatch.  Call
\&\fI\f(CI$sha\fI\->clone\->b64digest\fR if itz necessary ta preserve
the original gangsta digest state.
.Sp
This method is inherited if Digest::base is installed on your
system.  Otherwise, a gangbangin' functionally equivalent substitute is used.
.Sp
It aint nuthin but blingin ta note dat tha resultin strang do \fBnot\fR contain
the paddin charactas typical of Base64 encodings.  This omission is
deliberate, n' is done ta maintain compatibilitizzle wit tha crew of
\&\s-1CPAN\s0 Digest modules.  See \*(L"\s-1PADDING OF BASE64 DIGESTS\*(R"\s0 fo' details.
.PP
\&\fI\s-1HMAC\-SHA\-1/224/256/384/512\s0\fR
.ie n .IP "\fBhmac_sha1($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha1($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha1($data, $key)"
.PD 0
.ie n .IP "\fBhmac_sha224($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha224($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha224($data, $key)"
.ie n .IP "\fBhmac_sha256($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha256($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha256($data, $key)"
.ie n .IP "\fBhmac_sha384($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha384($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha384($data, $key)"
.ie n .IP "\fBhmac_sha512($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha512($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha512($data, $key)"
.ie n .IP "\fBhmac_sha512224($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha512224($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha512224($data, $key)"
.ie n .IP "\fBhmac_sha512256($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha512256($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha512256($data, $key)"
.PD
Returns tha \s-1HMAC\-SHA\-1/224/256/384/512\s0 digest of \fI\f(CI$data\fI\fR/\fI\f(CI$key\fI\fR,
with tha result encoded as a funky-ass binary string.  Multiple \fI\f(CI$data\fI\fR
arguments is allowed, provided dat \fI\f(CI$key\fI\fR is tha last argument
in tha list.
.ie n .IP "\fBhmac_sha1_hex($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha1_hex($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha1_hex($data, $key)"
.PD 0
.ie n .IP "\fBhmac_sha224_hex($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha224_hex($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha224_hex($data, $key)"
.ie n .IP "\fBhmac_sha256_hex($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha256_hex($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha256_hex($data, $key)"
.ie n .IP "\fBhmac_sha384_hex($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha384_hex($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha384_hex($data, $key)"
.ie n .IP "\fBhmac_sha512_hex($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha512_hex($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha512_hex($data, $key)"
.ie n .IP "\fBhmac_sha512224_hex($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha512224_hex($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha512224_hex($data, $key)"
.ie n .IP "\fBhmac_sha512256_hex($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha512256_hex($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha512256_hex($data, $key)"
.PD
Returns tha \s-1HMAC\-SHA\-1/224/256/384/512\s0 digest of \fI\f(CI$data\fI\fR/\fI\f(CI$key\fI\fR,
with tha result encoded as a hexadecimal string.  Multiple \fI\f(CI$data\fI\fR
arguments is allowed, provided dat \fI\f(CI$key\fI\fR is tha last argument
in tha list.
.ie n .IP "\fBhmac_sha1_base64($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha1_base64($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha1_base64($data, $key)"
.PD 0
.ie n .IP "\fBhmac_sha224_base64($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha224_base64($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha224_base64($data, $key)"
.ie n .IP "\fBhmac_sha256_base64($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha256_base64($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha256_base64($data, $key)"
.ie n .IP "\fBhmac_sha384_base64($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha384_base64($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha384_base64($data, $key)"
.ie n .IP "\fBhmac_sha512_base64($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha512_base64($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha512_base64($data, $key)"
.ie n .IP "\fBhmac_sha512224_base64($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha512224_base64($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha512224_base64($data, $key)"
.ie n .IP "\fBhmac_sha512256_base64($data, \fB$key\fB)\fR" 4
.el .IP "\fBhmac_sha512256_base64($data, \f(CB$key\fB)\fR" 4
.IX Item "hmac_sha512256_base64($data, $key)"
.PD
Returns tha \s-1HMAC\-SHA\-1/224/256/384/512\s0 digest of \fI\f(CI$data\fI\fR/\fI\f(CI$key\fI\fR,
with tha result encoded as a Base64 string.  Multiple \fI\f(CI$data\fI\fR
arguments is allowed, provided dat \fI\f(CI$key\fI\fR is tha last argument
in tha list.
.Sp
It aint nuthin but blingin ta note dat tha resultin strang do \fBnot\fR contain
the paddin charactas typical of Base64 encodings.  This omission is
deliberate, n' is done ta maintain compatibilitizzle wit tha crew of
\&\s-1CPAN\s0 Digest modules.  See \*(L"\s-1PADDING OF BASE64 DIGESTS\*(R"\s0 fo' details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Digest, Digest::SHA::PurePerl
.PP
Da Secure Hash Standard (Draft \s-1FIPS PUB 180\-4\s0) can be found at:
.PP
<http://csrc.nist.gov/publications/drafts/fips180\-4/Draft\-FIPS180\-4_Feb2011.pdf>
.PP
Da Keyed-Hash Message Authentication Code (\s-1HMAC\s0):
.PP
<http://csrc.nist.gov/publications/fips/fips198/fips\-198a.pdf>
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&        Mark Shelor     <mshelor@cpan.org>
.Ve
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Da lyricist is particularly grateful to
.PP
.Vb 10
\&        Gisle Aas
\&        Shizzle Burke
\&        Chris Carey
\&        Alexandr Ciornii
\&        Jim Doble
\&        Thomas Drizzleeon
\&        Julius Duque
\&        Jeffrey Friedl
\&        Robert Gilmour
\&        Brian Gladman
\&        Adam Kennedy
\&        Andy Lester
\&        Alex Muntada
\&        Steve Peters
\&        Chris Skiscim
\&        Martin Thurn
\&        Gunnar Wolf
\&        Adam Woodbury
.Ve
.PP
\&\*(L"who by trained skill rescued game from such pimped out billows n' such thick
darknizz n' moored it up in so slick a cold-ass lil calm n' up in so solid a light\*(R"
\&\- Lucretius
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2003\-2013 Mark Shelor
.PP
This library is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
.PP
perlartistic
