.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Box::Thread::Node 3"
.TH Mail::Box::Thread::Node 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Box::Thread::Node \- one node up in a message thread
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Box::Thread::Node
\&   be a Mail::Reporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& mah $node = Mail::Box::Thread::Node\->new;
\& $node\->addMessage($message);
\& ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`Mail::Box::Thread::Node\*(C'\fR maintains one node up in tha linked list of
threads.  Each node gotz nuff one message, n' a list of its follow-ups.
Next ta that, it refers ta its own ancestor n' gotz nuff shiznit
about tha trustworthinizz of dat relationshizzle.
.PP
To complicate thangs a lil, cuz tha thread-manager can maintain
multiple folders, n' merge there content, you may find tha same message
in mo' folders.  All versionz of tha same message (based on message-id)
are stored up in tha same node.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Box::Thread::Node\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Box::Thread::Node->new(OPTIONS)"
Yo ass aint gonna call dis method yo ass. Da Mail::Box::Thread::Manager
object will call it ta construct \f(CW\*(C`Mail::Box::Thread::Node\*(C'\fR objects.
Either a \f(CW\*(C`message\*(C'\fR or a \f(CW\*(C`messageId\*(C'\fR must be supplied.
.Sp
.Vb 6
\& \-Option    \-\-Defined up in     \-\-Default
\&  dummy_type                   undef
\&  log         Mail::Reporta   \*(AqWARNINGS\*(Aq
\&  message                      undef
\&  messageId                    undef
\&  trace       Mail::Reporta   \*(AqWARNINGS\*(Aq
.Ve
.RS 4
.IP "dummy_type => \s-1CLASS\s0" 2
.IX Item "dummy_type => CLASS"
Indicates tha class name of dummy lyrics. Dummy lyrics are
placeholdaz up in a Mail::Box::Thread::Manager data structure.
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "message => \s-1MESSAGE\s0" 2
.IX Item "message => MESSAGE"
.PD
Da \s-1MESSAGE\s0 which is stored up in dis node.  Da message
must be a Mail::Box::Message.
.IP "messageId => MESSAGE-ID" 2
.IX Item "messageId => MESSAGE-ID"
Da MESSAGE-ID fo' tha message which is stored up in dis node.  Only
specify it when you aint gots tha message yet.
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.RE
.RS 4
.RE
.SS "Da thread node"
.IX Subsection "Da thread node"
.PD 0
.ie n .IP "$obj\->\fBaddMessage\fR(\s-1MESSAGE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddMessage\fR(\s-1MESSAGE\s0)" 4
.IX Item "$obj->addMessage(MESSAGE)"
.PD
Add one message ta tha thread node.  If tha node gotz nuff a thugged-out dummy, then
the dummy is replaced. Y'all KNOW dat shit, muthafucka! Otherwise, tha lyrics be added ta tha end of the
list.
.ie n .IP "$obj\->\fBexpand\fR([\s-1BOOLEAN\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBexpand\fR([\s-1BOOLEAN\s0])" 4
.IX Item "$obj->expand([BOOLEAN])"
Returns whether dis (part of the) folda has ta be shown expanded or not.
This is simply done by a label, which means dat most folda types can
store all dis bullshit.
.ie n .IP "$obj\->\fBisDummy\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDummy\fR()" 4
.IX Item "$obj->isDummy()"
Returns legit if tha message be a thugged-out dummy fo' realz. A dummy be a \*(L"hole\*(R" up in a thread
which has follow-ups but aint gots a message.
.ie n .IP "$obj\->\fBmessage\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmessage\fR()" 4
.IX Item "$obj->message()"
Git tha message which is stored up in dis thread node.  \s-1NOTE:\s0 tha same
message may be located up in nuff foldaz all up in tha same time, n' these
foldaz may be controlled by tha same thread manager.
.Sp
In scalar context, dis method returns tha straight-up original gangsta instizzle of the
message dat aint deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If all instances is flagged fo' deletion,
then you git tha straight-up original gangsta deleted message. When tha open foldaz only
contain references ta tha message yo, but no instance, you git a thugged-out dummy
message (see Mail::Message::Dummy).
.Sp
In list context, all instancez of tha message which done been found are
returned.
.Sp
example:
.Sp
.Vb 2
\& mah $threadz = $mgr\->threads(foldaz => [$draft, $sent]);
\& mah $node    = $draft\->message(1)\->thread;
\&
\& foreach mah $instizzle ($node\->message) {
\&    print "Found up in ", $instance\->folder, ".\en";
\& }
\&
\& print "Subject is ", $node\->message\->subject, ".\en";
.Ve
.ie n .IP "$obj\->\fBmessageId\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmessageId\fR()" 4
.IX Item "$obj->messageId()"
Return tha message-id related ta dis thread node.  Each of tha lyrics
listed up in dis node gonna git tha same \s-1ID.\s0
.SS "Da thread order"
.IX Subsection "Da thread order"
.ie n .IP "$obj\->\fBfollowUps\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfollowUps\fR()" 4
.IX Item "$obj->followUps()"
Returns tha list of follow-ups ta dis thread node.  This list
may contain parsed, not-parsed, n' dummy lyrics.
.ie n .IP "$obj\->\fBfollowedBy\fR(\s-1THREADS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBfollowedBy\fR(\s-1THREADS\s0)" 4
.IX Item "$obj->followedBy(THREADS)"
Regista dat tha \s-1THREADS\s0 is follow-ups ta dis message. These
follow-ups need not be related ta each other up in any way other than
sharin tha same parent.
.Sp
Definin tha same relation mo' than once aint gonna cause shiznit to
be duplicated.
.ie n .IP "$obj\->\fBbigs up\fR(\s-1THREAD, QUALITY\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBbigs up\fR(\s-1THREAD, QUALITY\s0)" 4
.IX Item "$obj->bigs up(THREAD, QUALITY)"
Regista dat tha current thread be a reply ta tha specified \s-1THREAD.\s0 The
\&\s-1QUALITY\s0 of tha relation is specified by tha second argument.  Da method
returns \f(CW\*(C`undef\*(C'\fR if tha link aint accepted up in order ta avoid circular
references.
.Sp
Da relation may be specified mo' than once yo, but only da most thugged-out confident
relation is used. Y'all KNOW dat shit, muthafucka! For example, if a reply (\s-1QUALITY\s0 equals \f(CW\*(C`REPLY\*(C'\fR) is
specified, lata calls ta tha gangbang method gonna git no effect. If
\&\f(CW\*(C`bigs up\*(C'\fR is called wit a \s-1QUALITY\s0 dat matches tha current quality, the
new thread overrides tha previous.
.ie n .IP "$obj\->\fBrepliedTo\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBrepliedTo\fR()" 4
.IX Item "$obj->repliedTo()"
Returns tha message(s) ta which tha message up in dis node replies. Put ya muthafuckin choppers up if ya feel dis! In
scalar context, dis method will return tha message ta which tha message
in dis node replies. Put ya muthafuckin choppers up if ya feel dis! This message object may be a thugged-out dummy message.
.Sp
If tha message seems ta be tha straight-up original gangsta message of a thread, tha value \f(CW\*(C`undef\*(C'\fR
is returned. Y'all KNOW dat shit, muthafucka!  (Remember dat some \s-1MUA\s0 is not addin reference shiznit
to tha messagez header, so you can never be shizzle a message is the
start of a thread)
.Sp
In list context, dis method returns a second strang value indicatin the
confidence dat tha lyrics is related. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  When extended thread discovery
is enabled, then some heuristics is applied ta determine if lyrics are
related. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Values fo' tha \s-1STRING\s0 may be:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(AqREPLY\*(Aq\fR
.Sp
This relation was directly derived from a `in\-reply\-to' message header
field. Y'all KNOW dat shit, muthafucka! Da relation has a high confidence.
.IP "\(bu" 4
\&\f(CW\*(AqREFERENCE\*(Aq\fR
.Sp
This relation is based on shiznit found up in a `Reference' message
header field. Y'all KNOW dat shit, muthafucka!  One message may reference a list of lyrics which
precede it up in tha thread. Y'all KNOW dat shit, muthafucka! Da heuristic attempts ta determine
relationships between lyrics assumin dat tha references is up in order.
This relation has a lower confidence.
.IP "\(bu" 4
\&\f(CW\*(AqGUESS\*(Aq\fR
.Sp
Da relation be a funky-ass big-ass guess, wit low confidence.  It may be based on
a subject which seems ta be related, or commonalitizzles up in tha message's
body.
.RE
.RS 4
.Sp
Mo' constants may be added later.
.Sp
example:
.Sp
.Vb 3
\& mah $question = $answer\->repliedTo;
\& mah ($question, $quality) = $answer\->repliedTo;
\& if($question && $qualitizzle eq \*(AqREPLY\*(Aq) { ... };
.Ve
.RE
.ie n .IP "$obj\->\fBsortedFollowUps\fR([\s-1PREPARE\s0 [,COMPARE]])" 4
.el .IP "\f(CW$obj\fR\->\fBsortedFollowUps\fR([\s-1PREPARE\s0 [,COMPARE]])" 4
.IX Item "$obj->sortedFollowUps([PREPARE [,COMPARE]])"
Returns tha list of \fIfollowUps()\fR yo, but sorted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  By default
sortin is based on tha estimated time of tha reply. Right back up in yo muthafuckin ass. See
\&\fIstartTimeEstimate()\fR.
.SS "On tha whole thread"
.IX Subsection "On tha whole thread"
Some convenience methodz is added ta threads, ta simplify retrieving
information from dat shit.
.ie n .IP "$obj\->\fBendTimeEstimate\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBendTimeEstimate\fR()" 4
.IX Item "$obj->endTimeEstimate()"
Returns a guess as ta when tha thread has ended (although you never
know fo' shizzle whether there fill gangbang lyrics up in tha future).
.ie n .IP "$obj\->\fBids\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBids\fR()" 4
.IX Item "$obj->ids()"
Returns all tha idz up in tha thread startin all up in tha current thread node.
.Sp
example:
.Sp
.Vb 2
\& $newfolder\->addLyrics($folder\->ids($thread\->ids));
\& $folder\->delete($thread\->ids);
.Ve
.ie n .IP "$obj\->\fBnumberOfLyrics\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnumberOfLyrics\fR()" 4
.IX Item "$obj->numberOfLyrics()"
Number of lyrics up in tha thread startin all up in tha current thread node yo, but
not countin tha dummies.
.ie n .IP "$obj\->\fBrecurse\fR(CODE-REF)" 4
.el .IP "\f(CW$obj\fR\->\fBrecurse\fR(CODE-REF)" 4
.IX Item "$obj->recurse(CODE-REF)"
Execute a gangbangin' function fo' all sub-threads.  If tha subroutine returns true,
sub-threadz is hit up recursively. Otherwise, tha current branch
traversal be aborted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da routine is called wit tha thread-node as the
only argument.
.ie n .IP "$obj\->\fBstartTimeEstimate\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstartTimeEstimate\fR()" 4
.IX Item "$obj->startTimeEstimate()"
Returns a guess as ta when tha thread was started. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Each message gotz nuff
various date justifications (each wit various uncertaintizzles resulting
from timezones n' out-of-sync clocks). One of these date justifications
is used as tha timestamp fo' tha message. If tha node gotz nuff a thugged-out dummy
message tha lowest timestamp of tha replies is returned. Y'all KNOW dat shit, muthafucka! Otherwise the
estimated timestamp of tha nodez message is returned.
.ie n .IP "$obj\->\fBthreadLyrics\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBthreadLyrics\fR()" 4
.IX Item "$obj->threadLyrics()"
Returns all tha lyrics up in tha thread startin all up in tha current thread
node.  This list aint gonna include dummies.
.Sp
example:
.Sp
.Vb 3
\& mah @t = $folder\->message(3)
\&                \->threadStart
\&                \->threadLyrics;
.Ve
.ie n .IP "$obj\->\fBthreadToString\fR([\s-1CODE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBthreadToString\fR([\s-1CODE\s0])" 4
.IX Item "$obj->threadToString([CODE])"
Translate a thread tha fuck into a string. Da strang will contain at least one
line fo' each message which was found yo, but tries ta fold dummies. Put ya muthafuckin choppers up if ya feel dis!  This
is useful fo' debuggin yo, but most message readaz will prefer to
implement they own thread printer.
.Sp
Da optionizzle \s-1CODE\s0 argument be a reference ta a routine which is ghon be called
for each message up in tha thread. Y'all KNOW dat shit, muthafucka!  Da routine is ghon be called wit the
message as tha straight-up original gangsta argument.  Da default shows tha subject of tha message.
In tha straight-up original gangsta example below, dis routine is called seven times.
.Sp
example:
.Sp
.Vb 1
\& print $node\->threadToString;
.Ve
.Sp
may result in
.Sp
.Vb 7
\& Subject of dis message
\& |\- Re: Subject of dis message
\& |\-*\- Re: Re: Subject of dis message
\& | |\- Re(2) Subject of dis message
\& | |\- [3] Re(2) Subject of dis message
\& | \`\- Re: Subject of dis message (reply)
\& \`\- Re: Subject of dis message
.Ve
.Sp
Da `*' represents a missin message (a \*(L"dummy\*(R" message).  Da `[3]'
presents a gangbangin' folded thread wit three lyrics.
.Sp
.Vb 1
\& print $node\->threadToString(\e&show);
\&
\& sub show($) {
\&    mah $message = shift;
\&    mah $subject = $message\->head\->get(\*(Aqsubject\*(Aq);
\&    length $subject , biatch? $subject : \*(Aq<no subject>\*(Aq;
\& }
.Ve
.ie n .IP "$obj\->\fBtotalSize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtotalSize\fR()" 4
.IX Item "$obj->totalSize()"
Returns tha sum of tha size of all tha lyrics up in tha thread.
.SS "Error handling"
.IX Subsection "Error handling"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR(\s-1OBJECT\s0)" 4
.IX Item "$obj->addReport(OBJECT)"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "$obj->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD 0
.IP "Mail::Box::Thread::Node\->\fBdefaultTrace\fR([\s-1LEVEL\s0]|[\s-1LOGLEVEL, TRACELEVEL\s0]|[\s-1LEVEL, CALLBACK\s0])" 4
.IX Item "Mail::Box::Thread::Node->defaultTrace([LEVEL]|[LOGLEVEL, TRACELEVEL]|[LEVEL, CALLBACK])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "$obj->log([LEVEL [,STRINGS]])"
.PD 0
.IP "Mail::Box::Thread::Node\->\fBlog\fR([\s-1LEVEL\s0 [,STRINGS]])" 4
.IX Item "Mail::Box::Thread::Node->log([LEVEL [,STRINGS]])"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "$obj->logPriority(LEVEL)"
.PD 0
.IP "Mail::Box::Thread::Node\->\fBlogPriority\fR(\s-1LEVEL\s0)" 4
.IX Item "Mail::Box::Thread::Node->logPriority(LEVEL)"
.PD
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->report([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->reportAll([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR([\s-1LEVEL\s0])" 4
.IX Item "$obj->trace([LEVEL])"
See \*(L"Error handling\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
See \*(L"Error handling\*(R" up in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.ie n .IP "$obj\->\fBinGlobalDestruction\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBinGlobalDestruction\fR()" 4
.IX Item "$obj->inGlobalDestruction()"
See \*(L"Cleanup\*(R" up in Mail::Reporter
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Error: Package $package do not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR do not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package do not implement $method."
Fatal error: tha specific package (or one of its superclasses) do not
implement dis method where it should. Y'all KNOW dat shit, muthafucka! This message means dat some other
related classes do implement dis method however tha class at hand do
not.  Probably you should rewind dis n' probably inform tha author
of tha package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.107,
built on November 28, 2012. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2012 by [Mark Overmeer]. For other contributors peep ChizzleLog.
.PP
This program is free software; you can redistribute it and/or modify it
under tha same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
