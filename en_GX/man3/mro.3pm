.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "mro 3pm"
.TH mro 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
mro \- Method Resolution Order
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use mro; # enablez next::method n' playaz globally
\&
\&  use mro \*(Aqdfs\*(Aq; # enable DFS MRO fo' dis class (Perl default)
\&  use mro \*(Aqc3\*(Aq; # enable C3 MRO fo' dis class
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \*(L"mro\*(R" namespace serves up nuff muthafuckin utilitizzles fo' dealing
with method resolution order n' method cachin up in general.
.PP
These intercourses is only available up in Perl 5.9.5 n' higher.
See MRO::Compat on \s-1CPAN\s0 fo' a mostly forwardz compatible
implementation fo' olda Perls.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
It aint nuthin but possible ta chizzle tha \s-1MRO\s0 of a given class either by rockin \f(CW\*(C`use
mro\*(C'\fR as shown up in tha synopsis, or by rockin tha \*(L"mro::set_mro\*(R" function
below.
.PP
Da special methodz \f(CW\*(C`next::method\*(C'\fR, \f(CW\*(C`next::can\*(C'\fR, and
\&\f(CW\*(C`maybe::next::method\*(C'\fR is not available until dis \f(CW\*(C`mro\*(C'\fR module
has been loaded via \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR.
.SH "Da C3 MRO"
.IX Header "Da C3 MRO"
In addizzle ta tha traditionizzle Perl default \s-1MRO \s0(depth first
search, called \f(CW\*(C`DFS\*(C'\fR here), Perl now offers tha C3 \s-1MRO\s0 as
well.  Perlz support fo' C3 is based on tha work done in
Stevan Littlez module Class::C3, n' most of tha C3\-related
documentation here is ripped directly from there.
.SS "What tha fuck iz C3?"
.IX Subsection "What tha fuck iz C3?"
C3 is tha name of a algorithm which aims ta provide a sane method
resolution order under multiple inheritance. Dat shiznit was first introduced in
the language Dylan (see links up in tha \*(L"\s-1SEE ALSO\*(R"\s0 section), n' then
lata adopted as tha preferred \s-1MRO \s0(Method Resolution Order) fo' the
new-style classes up in Python 2.3. Most recently it has been adopted as the
\&\*(L"canonical\*(R" \s-1MRO\s0 fo' Perl 6 classes, n' tha default \s-1MRO\s0 fo' Parrot objects
as well.
.SS "How tha fuck do C3 work"
.IX Subsection "How tha fuck do C3 work"
C3 works by always preservin local precedence ordering. This essentially
means dat no class will step tha fuck up before any of its subclasses. Take, for
instance, tha funky-ass diamond inheritizzle pattern:
.PP
.Vb 5
\&     <A>
\&    /   \e
\&  <B>   <C>
\&    \e   /
\&     <D>
.Ve
.PP
Da standard Perl 5 \s-1MRO\s0 would be (D, B, A, C). Da result bein dat \fBA\fR
appears before \fBC\fR, even though \fBC\fR is tha subclass of \fBA\fR. Da C3 \s-1MRO\s0
algorithm however, produces tha followin order: (D, B, C, A), which do
not have dis issue.
.PP
This example is fairly trivial; fo' mo' complex cases n' a thugged-out deeper
explanation, peep tha links up in tha \*(L"\s-1SEE ALSO\*(R"\s0 section.
.SH "Functions"
.IX Header "Functions"
.ie n .SS "mro::get_linear_isa($classname[, $type])"
.el .SS "mro::get_linear_isa($classname[, \f(CW$type\fP])"
.IX Subsection "mro::get_linear_isa($classname[, $type])"
Returns a arrayref which is tha linearized \s-1MRO\s0 of tha given class.
Uses whichever \s-1MRO\s0 is currently up in effect fo' dat class by default,
or tha given \s-1MRO \s0(either \f(CW\*(C`c3\*(C'\fR or \f(CW\*(C`dfs\*(C'\fR if specified as \f(CW$type\fR).
.PP
Da linearized \s-1MRO\s0 of a cold-ass lil class be a ordered array of all of the
classes one would search when resolvin a method on dat class,
startin wit tha class itself.
.PP
If tha axed class don't yet exist, dis function will still
succeed, n' return \f(CW\*(C`[ $classname ]\*(C'\fR
.PP
Note dat \f(CW\*(C`UNIVERSAL\*(C'\fR (and any thugz of \f(CW\*(C`UNIVERSAL\*(C'\fRz \s-1MRO\s0) is not
part of tha \s-1MRO\s0 of a cold-ass lil class, even though all classes implicitly inherit
methodz from \f(CW\*(C`UNIVERSAL\*(C'\fR n' its muthafathas.
.ie n .SS "mro::set_mro ($classname, $type)"
.el .SS "mro::set_mro ($classname, \f(CW$type\fP)"
.IX Subsection "mro::set_mro ($classname, $type)"
Sets tha \s-1MRO\s0 of tha given class ta tha \f(CW$type\fR argument (either
\&\f(CW\*(C`c3\*(C'\fR or \f(CW\*(C`dfs\*(C'\fR).
.SS "mro::get_mro($classname)"
.IX Subsection "mro::get_mro($classname)"
Returns tha \s-1MRO\s0 of tha given class (either \f(CW\*(C`c3\*(C'\fR or \f(CW\*(C`dfs\*(C'\fR).
.SS "mro::get_isarev($classname)"
.IX Subsection "mro::get_isarev($classname)"
Gets tha \f(CW\*(C`mro_isarev\*(C'\fR fo' dis class, returned as an
arrayref of class names.  These is every last muthafuckin class dat \*(L"isa\*(R"
the given class name, even if tha isa relationshizzle is
indirect.  This is used internally by tha \s-1MRO\s0 code to
keep track of method/MRO cache invalidations.
.PP
As wit \f(CW\*(C`mro::get_linear_isa\*(C'\fR above, \f(CW\*(C`UNIVERSAL\*(C'\fR is special.
\&\f(CW\*(C`UNIVERSAL\*(C'\fR (and muthafathas') isarev lists do not include
every class up in existence, even though all classes are
effectively descendants fo' method inheritizzle purposes.
.SS "mro::is_universal($classname)"
.IX Subsection "mro::is_universal($classname)"
Returns a funky-ass boolean status indicatin whether or not
the given classname is either \f(CW\*(C`UNIVERSAL\*(C'\fR itself,
or one of \f(CW\*(C`UNIVERSAL\*(C'\fRz muthafathas by \f(CW@ISA\fR inheritance.
.PP
Any class fo' which dis function returns legit is
\&\*(L"universal\*(R" up in tha sense dat all classes potentially
inherit methodz from dat shit.
.SS "\fImro::invalidate_all_method_caches()\fP"
.IX Subsection "mro::invalidate_all_method_caches()"
Increments \f(CW\*(C`PL_sub_generation\*(C'\fR, which invalidates method
cachin up in all packages.
.SS "mro::method_changed_in($classname)"
.IX Subsection "mro::method_changed_in($classname)"
Invalidates tha method cache of any classes dependent on the
given class.  This aint normally necessary.  Da only
known case where pure perl code can confuse tha method
cache is when you manually install a freshly smoked up constant
subroutine by rockin a readonly scalar value, like the
internalz of constant do.  If you find another case,
please report it so we can either fix it or document
the exception here.
.SS "mro::get_pkg_gen($classname)"
.IX Subsection "mro::get_pkg_gen($classname)"
Returns a integer which is incremented every last muthafuckin time a
real local method up in tha package \f(CW$classname\fR chizzles,
or tha local \f(CW@ISA\fR of \f(CW$classname\fR is modified.
.PP
This is intended fo' authorz of modulez which do lots
of class introspection, as it allows dem ta straight-up quickly
check if anythang blingin bout tha local properties
of a given class have chizzled since tha last time they
looked. Y'all KNOW dat shit, muthafucka!  It do not increment on method/\f(CW@ISA\fR
changes up in superclasses.
.PP
It aint nuthin but still up ta you ta seek up tha actual chizzles,
and there might not straight-up be any.  Perhaps all
of tha chizzlez since you last checked shut down each
other up n' left tha package up in tha state dat shiznit was in
before.
.PP
This integer normally starts off at a value of \f(CW1\fR
when a package stash is instantiated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Callin it
on packages whose stashes do not exist at all will
return \f(CW0\fR.  If a package stash is straight-up
deleted (not a aiiight occurence yo, but it can happen
if one of mah thugs do suttin' like \f(CW\*(C`undef %PkgName::\*(C'\fR),
the number is ghon be reset ta either \f(CW0\fR or \f(CW1\fR,
dependin on how tha fuck straight-up package was wiped out.
.SS "next::method"
.IX Subsection "next::method"
This is somewhat like \f(CW\*(C`SUPER\*(C'\fR yo, but it uses tha C3 method
resolution order ta git betta consistency up in multiple
inheritizzle thangs.  Note dat while inheritizzle in
general bigs up whichever \s-1MRO\s0 is up in effect fo' the
given class, \f(CW\*(C`next::method\*(C'\fR only uses tha C3 \s-1MRO.\s0
.PP
One generally uses it like so:
.PP
.Vb 5
\&  sub some_method {
\&    mah $self = shift;
\&    mah $superclass_answer = $self\->next::method(@_);
\&    return $superclass_answer + 1;
\&  }
.Ve
.PP
Note dat you don't (re\-)specify tha method name.
It forces you ta always use tha same method name
as tha method you started in.
.PP
It can be called on a object or a cold-ass lil class, of course.
.PP
Da way it resolves which actual method ta booty-call is:
.IP "1." 4
First, it determines tha linearized C3 \s-1MRO\s0 of
the object or class it is bein called on.
.IP "2." 4
Then, it determines tha class n' method name
of tha context dat shiznit was invoked from.
.IP "3." 4
Finally, it searches down tha C3 \s-1MRO\s0 list until
it reaches tha contextually enclosin class, then
searches further down tha \s-1MRO\s0 list fo' tha next
method wit tha same name as tha contextually
enclosin method.
.PP
Failure ta find a next method will result up in an
exception bein thrown (see below fo' alternatives).
.PP
This is substantially different than tha behavior
of \f(CW\*(C`SUPER\*(C'\fR under complex multiple inheritance.
(This becomes obvious when one realizes dat the
common superclasses up in tha C3 linearizations of
a given class n' one of its muthafathas will not
always be ordered tha same fo' both.)
.PP
\&\fBCaveat\fR: Callin \f(CW\*(C`next::method\*(C'\fR from methodz defined outside tha class:
.PP
There be a edge case when rockin \f(CW\*(C`next::method\*(C'\fR from within a subroutine
which was pimped up in a gangbangin' finger-lickin' different module than tha one it is called from. It
soundz fucked up yo, but it straight-up aint yo. Here be a example which will not
work erectly:
.PP
.Vb 1
\&  *Foo::foo = sub { (shift)\->next::method(@_) };
.Ve
.PP
Da problem exists cuz tha anonymous subroutine bein assigned ta the
\&\f(CW*Foo::foo\fR glob will show up in tha call stack as bein called
\&\f(CW\*(C`_\|_ANON_\|_\*(C'\fR n' not \f(CW\*(C`foo\*(C'\fR as you might expect. Right back up in yo muthafuckin ass. Since \f(CW\*(C`next::method\*(C'\fR uses
\&\f(CW\*(C`caller\*(C'\fR ta find tha name of tha method dat shiznit was called in, it will fail in
this case.
.PP
But fear not, there be a a simple solution. I aint talkin' bout chicken n' gravy biatch. Da module \f(CW\*(C`Sub::Name\*(C'\fR will
reach tha fuck into tha perl internals n' assign a name ta a anonymous subroutine
for yo thugged-out ass. Right back up in yo muthafuckin ass. Simply do this:
.PP
.Vb 2
\&  use Sub::Name \*(Aqsubname\*(Aq;
\&  *Foo::foo = subname \*(AqFoo::foo\*(Aq => sub { (shift)\->next::method(@_) };
.Ve
.PP
and thangs will Just Work.
.SS "next::can"
.IX Subsection "next::can"
This is similar ta \f(CW\*(C`next::method\*(C'\fR yo, but just returns either a cold-ass lil code
reference or \f(CW\*(C`undef\*(C'\fR ta indicate dat no further methodz of dis name
exist.
.SS "maybe::next::method"
.IX Subsection "maybe::next::method"
In simple cases, it is equivalent to:
.PP
.Vb 1
\&   $self\->next::method(@_) if $self\->next::can;
.Ve
.PP
But there be some cases where only dis solution
works (like \f(CW\*(C`goto &maybe::next::method\*(C'\fR);
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "Da original gangsta Dylan paper"
.IX Subsection "Da original gangsta Dylan paper"
.IP "<http://haahr.tempdomainname.com/dylan/linearization\-oopsla96.html>" 4
.IX Item "<http://haahr.tempdomainname.com/dylan/linearization-oopsla96.html>"
.SS "Pugs"
.IX Subsection "Pugs"
Da Pugs prototype Perl 6 Object Model uses C3
.SS "Parrot"
.IX Subsection "Parrot"
Parrot now uses C3
.IP "<http://use.perl.org/~autrijus/journal/25768>" 4
.IX Item "<http://use.perl.org/~autrijus/journal/25768>"
.SS "Python 2.3 \s-1MRO\s0 related links"
.IX Subsection "Python 2.3 MRO related links"
.PD 0
.IP "<http://www.python.org/2.3/mro.html>" 4
.IX Item "<http://www.python.org/2.3/mro.html>"
.IP "<http://www.python.org/2.2.2/descrintro.html#mro>" 4
.IX Item "<http://www.python.org/2.2.2/descrintro.html#mro>"
.PD
.SS "Class::C3"
.IX Subsection "Class::C3"
.IP "Class::C3" 4
.IX Item "Class::C3"
.SH "AUTHOR"
.IX Header "AUTHOR"
Brandon L. Black, <blblack@gmail.com>
.PP
Based on Stevan Littlez Class::C3
