.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pem 3"
.TH pem 3 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
PEM, PEM_read_bio_PrivateKey, PEM_read_PrivateKey, PEM_write_bio_PrivateKey, PEM_write_PrivateKey, PEM_write_bio_PKCS8PrivateKey, PEM_write_PKCS8PrivateKey, PEM_write_bio_PKCS8PrivateKey_nid, PEM_write_PKCS8PrivateKey_nid, PEM_read_bio_PUBKEY, PEM_read_PUBKEY, PEM_write_bio_PUBKEY, PEM_write_PUBKEY, PEM_read_bio_RSAPrivateKey, PEM_read_RSAPrivateKey, PEM_write_bio_RSAPrivateKey, PEM_write_RSAPrivateKey, PEM_read_bio_RSAPublicKey, PEM_read_RSAPublicKey, PEM_write_bio_RSAPublicKey, PEM_write_RSAPublicKey, PEM_read_bio_RSA_PUBKEY, PEM_read_RSA_PUBKEY, PEM_write_bio_RSA_PUBKEY, PEM_write_RSA_PUBKEY, PEM_read_bio_DSAPrivateKey, PEM_read_DSAPrivateKey, PEM_write_bio_DSAPrivateKey, PEM_write_DSAPrivateKey, PEM_read_bio_DSA_PUBKEY, PEM_read_DSA_PUBKEY, PEM_write_bio_DSA_PUBKEY, PEM_write_DSA_PUBKEY, PEM_read_bio_DSAparams, PEM_read_DSAparams, PEM_write_bio_DSAparams, PEM_write_DSAparams, PEM_read_bio_DHparams, PEM_read_DHparams, PEM_write_bio_DHparams, PEM_write_DHparams, PEM_read_bio_X509, PEM_read_X509, PEM_write_bio_X509, PEM_write_X509, PEM_read_bio_X509_AUX, PEM_read_X509_AUX, PEM_write_bio_X509_AUX, PEM_write_X509_AUX, PEM_read_bio_X509_REQ, PEM_read_X509_REQ, PEM_write_bio_X509_REQ, PEM_write_X509_REQ, PEM_write_bio_X509_REQ_NEW, PEM_write_X509_REQ_NEW, PEM_read_bio_X509_CRL, PEM_read_X509_CRL, PEM_write_bio_X509_CRL, PEM_write_X509_CRL, PEM_read_bio_PKCS7, PEM_read_PKCS7, PEM_write_bio_PKCS7, PEM_write_PKCS7, PEM_read_bio_NETSCAPE_CERT_SEQUENCE, PEM_read_NETSCAPE_CERT_SEQUENCE, PEM_write_bio_NETSCAPE_CERT_SEQUENCE, PEM_write_NETSCAPE_CERT_SEQUENCE \- PEM routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/pem.h>
\&
\& EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
\&                                        unsigned char *kstr, int klen,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
\&                                        unsigned char *kstr, int klen,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
\&                                        char *kstr, int klen,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
\&                                        char *kstr, int klen,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
\&                                        char *kstr, int klen,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,
\&                                        char *kstr, int klen,
\&                                        pem_password_cb *cb, void *u);
\&
\& EVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& EVP_PKEY *PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x);
\& int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x);
\&
\& RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,
\&                                        unsigned char *kstr, int klen,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,
\&                                        unsigned char *kstr, int klen,
\&                                        pem_password_cb *cb, void *u);
\&
\& RSA *PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& RSA *PEM_read_RSAPublicKey(FILE *fp, RSA **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_RSAPublicKey(BIO *bp, RSA *x);
\&
\& int PEM_write_RSAPublicKey(FILE *fp, RSA *x);
\&
\& RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& RSA *PEM_read_RSA_PUBKEY(FILE *fp, RSA **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x);
\&
\& int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x);
\&
\& DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,
\&                                        unsigned char *kstr, int klen,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,
\&                                        unsigned char *kstr, int klen,
\&                                        pem_password_cb *cb, void *u);
\&
\& DSA *PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& DSA *PEM_read_DSA_PUBKEY(FILE *fp, DSA **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x);
\&
\& int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x);
\&
\& DSA *PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u);
\&
\& DSA *PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_DSAparams(BIO *bp, DSA *x);
\&
\& int PEM_write_DSAparams(FILE *fp, DSA *x);
\&
\& DH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u);
\&
\& DH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_DHparams(BIO *bp, DH *x);
\&
\& int PEM_write_DHparams(FILE *fp, DH *x);
\&
\& X509 *PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb *cb, void *u);
\&
\& X509 *PEM_read_X509(FILE *fp, X509 **x, pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_X509(BIO *bp, X509 *x);
\&
\& int PEM_write_X509(FILE *fp, X509 *x);
\&
\& X509 *PEM_read_bio_X509_AUX(BIO *bp, X509 **x, pem_password_cb *cb, void *u);
\&
\& X509 *PEM_read_X509_AUX(FILE *fp, X509 **x, pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_X509_AUX(BIO *bp, X509 *x);
\&
\& int PEM_write_X509_AUX(FILE *fp, X509 *x);
\&
\& X509_REQ *PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& X509_REQ *PEM_read_X509_REQ(FILE *fp, X509_REQ **x,
\&                                        pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x);
\&
\& int PEM_write_X509_REQ(FILE *fp, X509_REQ *x);
\&
\& int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x);
\&
\& int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x);
\&
\& X509_CRL *PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x,
\&                                        pem_password_cb *cb, void *u);
\& X509_CRL *PEM_read_X509_CRL(FILE *fp, X509_CRL **x,
\&                                        pem_password_cb *cb, void *u);
\& int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x);
\& int PEM_write_X509_CRL(FILE *fp, X509_CRL *x);
\&
\& PKCS7 *PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x, pem_password_cb *cb, void *u);
\&
\& PKCS7 *PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x);
\&
\& int PEM_write_PKCS7(FILE *fp, PKCS7 *x);
\&
\& NETSCAPE_CERT_SEQUENCE *PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp,
\&                                                NETSCAPE_CERT_SEQUENCE **x,
\&                                                pem_password_cb *cb, void *u);
\&
\& NETSCAPE_CERT_SEQUENCE *PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *fp,
\&                                                NETSCAPE_CERT_SEQUENCE **x,
\&                                                pem_password_cb *cb, void *u);
\&
\& int PEM_write_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE *x);
\&
\& int PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE *x);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \s-1PEM\s0 functions read or write structures up in \s-1PEM\s0 format. In
this sense \s-1PEM\s0 format is simply base64 encoded data surrounded
by header lines.
.PP
For mo' details bout tha meanin of arguments peep the
\&\fB\s-1PEM FUNCTION ARGUMENTS\s0\fR section.
.PP
Each operation has four functions associated wit dat shit. For
claritizzle tha term "\fBfoobar\fR functions" is ghon be used ta collectively
refer ta tha \fIPEM_read_bio_foobar()\fR, \fIPEM_read_foobar()\fR,
\&\fIPEM_write_bio_foobar()\fR n' \fIPEM_write_foobar()\fR functions.
.PP
Da \fBPrivateKey\fR functions read or write a private key in
\&\s-1PEM\s0 format rockin a \s-1EVP_PKEY\s0 structure. Da write routines use
\&\*(L"traditional\*(R" private key format n' can handle both \s-1RSA\s0 n' \s-1DSA\s0
private keys. Da read functions can additionally transparently
handle PKCS#8 format encrypted n' unencrypted keys like a muthafucka.
.PP
\&\fIPEM_write_bio_PKCS8PrivateKey()\fR n' \fIPEM_write_PKCS8PrivateKey()\fR
write a private key up in a \s-1EVP_PKEY\s0 structure up in PKCS#8
EncryptedPrivateKeyInfo format rockin PKCS#5 v2.0 password based encryption
algorithms. Da \fBcipher\fR argument specifies tha encryption algoritm to
use: unlike all other \s-1PEM\s0 routines tha encryption be applied at the
PKCS#8 level n' not up in tha \s-1PEM\s0 headers. If \fBcipher\fR is \s-1NULL\s0 then no
encryption is used n' a PKCS#8 PrivateKeyInfo structure is used instead.
.PP
\&\fIPEM_write_bio_PKCS8PrivateKey_nid()\fR n' \fIPEM_write_PKCS8PrivateKey_nid()\fR
also write up a private key as a PKCS#8 EncryptedPrivateKeyInfo however
it uses PKCS#5 v1.5 or PKCS#12 encryption algorithms instead. Y'all KNOW dat shit, muthafucka! Da algorithm
to use is specified up in tha \fBnid\fR parameta n' should be tha \s-1NID\s0 of the
correspondin \s-1OBJECT IDENTIFIER \s0(see \s-1NOTES\s0 section).
.PP
Da \fB\s-1PUBKEY\s0\fR functions process a hood key rockin a \s-1EVP_PKEY\s0
structure. Da hood key is encoded as a SubjectPublicKeyInfo
structure.
.PP
Da \fBRSAPrivateKey\fR functions process a \s-1RSA\s0 private key rockin an
\&\s-1RSA\s0 structure. Well shiiiit, it handlez tha same ol' dirty formats as tha \fBPrivateKey\fR
functions but a error occurs if tha private key aint \s-1RSA.\s0
.PP
Da \fBRSAPublicKey\fR functions process a \s-1RSA\s0 hood key rockin an
\&\s-1RSA\s0 structure. Da hood key is encoded rockin a PKCS#1 RSAPublicKey
structure.
.PP
Da \fB\s-1RSA_PUBKEY\s0\fR functions also process a \s-1RSA\s0 hood key using
an \s-1RSA\s0 structure yo. However tha hood key is encoded rockin a
SubjectPublicKeyInfo structure n' a error occurs if tha public
key aint \s-1RSA.\s0
.PP
Da \fBDSAPrivateKey\fR functions process a \s-1DSA\s0 private key rockin a
\&\s-1DSA\s0 structure. Well shiiiit, it handlez tha same ol' dirty formats as tha \fBPrivateKey\fR
functions but a error occurs if tha private key aint \s-1DSA.\s0
.PP
Da \fB\s-1DSA_PUBKEY\s0\fR functions process a \s-1DSA\s0 hood key using
a \s-1DSA\s0 structure. Da hood key is encoded rockin a
SubjectPublicKeyInfo structure n' a error occurs if tha public
key aint \s-1DSA.\s0
.PP
Da \fBDSAparams\fR functions process \s-1DSA\s0 parametas rockin a \s-1DSA\s0
structure. Da parametas is encoded rockin a gangbangin' foobar structure.
.PP
Da \fBDHparams\fR functions process \s-1DH\s0 parametas rockin a \s-1DH\s0
structure. Da parametas is encoded rockin a PKCS#3 DHparameter
structure.
.PP
Da \fBX509\fR functions process a X509 certificate rockin a X509
structure. They will also process a trusted X509 certificate but
any trust settings is discarded.
.PP
Da \fBX509_AUX\fR functions process a trusted X509 certificate using
an X509 structure.
.PP
Da \fBX509_REQ\fR n' \fBX509_REQ_NEW\fR functions process a PKCS#10
certificate request rockin a X509_REQ structure. Da \fBX509_REQ\fR
write functions use \fB\s-1CERTIFICATE REQUEST\s0\fR up in tha header whereas
the \fBX509_REQ_NEW\fR functions use \fB\s-1NEW CERTIFICATE REQUEST\s0\fR
(as required by some CAs). Da \fBX509_REQ\fR read functions will
handle either form so there be no \fBX509_REQ_NEW\fR read functions.
.PP
Da \fBX509_CRL\fR functions process a X509 \s-1CRL\s0 rockin a X509_CRL
structure.
.PP
Da \fB\s-1PKCS7\s0\fR functions process a PKCS#7 ContentInfo rockin a \s-1PKCS7\s0
structure.
.PP
Da \fB\s-1NETSCAPE_CERT_SEQUENCE\s0\fR functions process a Netscape Certificate
Sequence rockin a \s-1NETSCAPE_CERT_SEQUENCE\s0 structure.
.SH "PEM FUNCTION ARGUMENTS"
.IX Header "PEM FUNCTION ARGUMENTS"
Da \s-1PEM\s0 functions have nuff common arguments.
.PP
Da \fBbp\fR \s-1BIO\s0 parameta (if present) specifies tha \s-1BIO\s0 ta read from
or write to.
.PP
Da \fBfp\fR \s-1FILE\s0 parameta (if present) specifies tha \s-1FILE\s0 pointa to
read from or write to.
.PP
Da \s-1PEM\s0 read functions all take a argument \fB\s-1TYPE\s0 **x\fR n' return
a \fB\s-1TYPE\s0 *\fR pointer n' shit. Where \fB\s-1TYPE\s0\fR is whatever structure tha function
uses. If \fBx\fR is \s-1NULL\s0 then tha parameta is ignored. Y'all KNOW dat shit, muthafucka! If \fBx\fR is not
\&\s-1NULL\s0 but \fB*x\fR is \s-1NULL\s0 then tha structure returned is ghon be written
to \fB*x\fR. If neither \fBx\fR nor \fB*x\fR is \s-1NULL\s0 then a attempt is made
to reuse tha structure at \fB*x\fR (but peep \s-1BUGS\s0 n' \s-1EXAMPLES\s0 sections).
Irrespectizzle of tha value of \fBx\fR a pointa ta tha structure be always
returned (or \s-1NULL\s0 if a error occurred).
.PP
Da \s-1PEM\s0 functions which write private keys take a \fBenc\fR parameter
which specifies tha encryption algorithm ta use, encryption is done
at tha \s-1PEM\s0 level. If dis parameta is set ta \s-1NULL\s0 then tha private
key is freestyled up in unencrypted form.
.PP
Da \fBcb\fR argument is tha callback ta use when queryin fo' tha pass
phrase used fo' encrypted \s-1PEM\s0 structures (normally only private keys).
.PP
For tha \s-1PEM\s0 write routines if tha \fBkstr\fR parameta aint \s-1NULL\s0 then
\&\fBklen\fR bytes at \fBkstr\fR is used as tha passphrase n' \fBcb\fR is
ignored.
.PP
If tha \fBcb\fR parametas is set ta \s-1NULL\s0 n' tha \fBu\fR parameta is not
\&\s-1NULL\s0 then tha \fBu\fR parameta is interpreted as a null terminated string
to use as tha passphrase. If both \fBcb\fR n' \fBu\fR is \s-1NULL\s0 then the
default callback routine is used which will typically prompt fo' the
passphrase on tha current terminal wit echoin turned off.
.PP
Da default passphrase callback is sometimes inappropriate (for example
in a \s-1GUI\s0 application) so a alternatizzle can be supplied. Y'all KNOW dat shit, muthafucka! Da callback
routine has tha followin form:
.PP
.Vb 1
\& int cb(char *buf, int size, int rwflag, void *u);
.Ve
.PP
\&\fBbuf\fR is tha buffer ta write tha passphrase to. \fBsize\fR is tha maximum
length of tha passphrase (i.e. tha size of buf). \fBrwflag\fR be a gangbangin' flag
which is set ta 0 when readin n' 1 when writin fo' realz. A typical routine
will ask tha user ta verify tha passphrase (for example by prompting
for it twice) if \fBrwflag\fR is 1. Da \fBu\fR parameta has tha same
value as tha \fBu\fR parameta passed ta tha \s-1PEM\s0 routine. Well shiiiit, it allows
arbitrary data ta be passed ta tha callback by tha application
(for example a window handle up in a \s-1GUI\s0 application). Da callback
\&\fBmust\fR return tha number of charactas up in tha passphrase or 0 if
an error occurred.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Although tha \s-1PEM\s0 routines take nuff muthafuckin arguments up in almost all applications
most of dem is set ta 0 or \s-1NULL.\s0
.PP
Read a cold-ass lil certificate up in \s-1PEM\s0 format from a \s-1BIO:\s0
.PP
.Vb 6
\& X509 *x;
\& x = PEM_read_bio_X509(bp, NULL, 0, NULL);
\& if (x == NULL)
\&        {
\&        /* Error */
\&        }
.Ve
.PP
Alternatizzle method:
.PP
.Vb 5
\& X509 *x = NULL;
\& if (!PEM_read_bio_X509(bp, &x, 0, NULL))
\&        {
\&        /* Error */
\&        }
.Ve
.PP
Write a cold-ass lil certificate ta a \s-1BIO:\s0
.PP
.Vb 4
\& if (!PEM_write_bio_X509(bp, x))
\&        {
\&        /* Error */
\&        }
.Ve
.PP
Write a unencrypted private key ta a \s-1FILE\s0 pointer:
.PP
.Vb 4
\& if (!PEM_write_PrivateKey(fp, key, NULL, NULL, 0, 0, NULL))
\&        {
\&        /* Error */
\&        }
.Ve
.PP
Write a private key (usin traditionizzle format) ta a \s-1BIO\s0 using
triple \s-1DES\s0 encryption, tha pass phrase is prompted for:
.PP
.Vb 4
\& if (!PEM_write_bio_PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, NULL))
\&        {
\&        /* Error */
\&        }
.Ve
.PP
Write a private key (usin PKCS#8 format) ta a \s-1BIO\s0 rockin triple
\&\s-1DES\s0 encryption, rockin tha pass phrase \*(L"hello\*(R":
.PP
.Vb 4
\& if (!PEM_write_bio_PKCS8PrivateKey(bp, key, EVP_des_ede3_cbc(), NULL, 0, 0, "hello"))
\&        {
\&        /* Error */
\&        }
.Ve
.PP
Read a private key from a \s-1BIO\s0 rockin tha pass phrase \*(L"hello\*(R":
.PP
.Vb 5
\& key = PEM_read_bio_PrivateKey(bp, NULL, 0, "hello");
\& if (key == NULL)
\&        {
\&        /* Error */
\&        }
.Ve
.PP
Read a private key from a \s-1BIO\s0 rockin a pass phrase callback:
.PP
.Vb 5
\& key = PEM_read_bio_PrivateKey(bp, NULL, pass_cb, "My fuckin Private Key");
\& if (key == NULL)
\&        {
\&        /* Error */
\&        }
.Ve
.PP
Skeleton pass phrase callback:
.PP
.Vb 6
\& int pass_cb(char *buf, int size, int rwflag, void *u);
\&        {
\&        int len;
\&        char *tmp;
\&        /* We\*(Aqd probably do suttin' else if \*(Aqrwflag\*(Aq is 1 */
\&        printf("Enta pass phrase fo' \e"%s\e"\en", u);
\&
\&        /* git pass phrase, length \*(Aqlen\*(Aq tha fuck into \*(Aqtmp\*(Aq */
\&        tmp = "hello";
\&        len = strlen(tmp);
\&
\&        if (len <= 0) return 0;
\&        /* if too long, truncate */
\&        if (len > size) len = size;
\&        memcpy(buf, tmp, len);
\&        return len;
\&        }
.Ve
.SH "NOTES"
.IX Header "NOTES"
Da oldschool \fBPrivateKey\fR write routines is retained fo' compatibility.
New applications should write private keys rockin the
\&\fIPEM_write_bio_PKCS8PrivateKey()\fR or \fIPEM_write_PKCS8PrivateKey()\fR routines
because they is mo' secure (they use a iteration count of 2048 whereas
the traditionizzle routines bust a cold-ass lil count of 1) unless compatibilitizzle wit older
versionz of OpenSSL is blingin.
.PP
Da \fBPrivateKey\fR read routines can be used up in all applications cuz
they handle all formats transparently.
.PP
A frequent cause of problems be attemptin ta use tha \s-1PEM\s0 routines like
this:
.PP
.Vb 2
\& X509 *x;
\& PEM_read_bio_X509(bp, &x, 0, NULL);
.Ve
.PP
this be a funky-ass bug cuz a attempt is ghon be made ta reuse tha data at \fBx\fR
which be a uninitialised pointer.
.SH "PEM ENCRYPTION FORMAT"
.IX Header "PEM ENCRYPTION FORMAT"
This oldschool \fBPrivateKey\fR routines bust a non standard technique fo' encryption.
.PP
Da private key (or other data) takes tha followin form:
.PP
.Vb 3
\& \-\-\-\-\-BEGIN RSA PRIVATE KEY\-\-\-\-\-
\& Proc\-Type: 4,ENCRYPTED
\& DEK\-Info: DES\-EDE3\-CBC,3F17F5316E2BAC89
\&
\& ...base64 encoded data...
\& \-\-\-\-\-END RSA PRIVATE KEY\-\-\-\-\-
.Ve
.PP
Da line beginnin DEK-Info gotz nuff two comma separated piecez of shiznit:
the encryption algorithm name as used by \fIEVP_get_cipherbyname()\fR n' a 8
byte \fBsalt\fR encoded as a set of hexadecimal digits.
.PP
Afta dis is tha base64 encoded encrypted data.
.PP
Da encryption key is determined rockin \fIEVP_bytestokey()\fR, rockin \fBsalt\fR n' an
iteration count of 1. Da \s-1IV\s0 used is tha value of \fBsalt\fR n' *not* tha \s-1IV\s0
returned by \fIEVP_bytestokey()\fR.
.SH "BUGS"
.IX Header "BUGS"
Da \s-1PEM\s0 read routines up in some versionz of OpenSSL aint gonna erectly reuse
an existin structure. Therefore tha following:
.PP
.Vb 1
\& PEM_read_bio_X509(bp, &x, 0, NULL);
.Ve
.PP
where \fBx\fR already gotz nuff a valid certificate, may not work, whereas:
.PP
.Vb 2
\& X509_free(x);
\& x = PEM_read_bio_X509(bp, NULL, 0, NULL);
.Ve
.PP
is guaranteed ta work.
.SH "RETURN CODES"
.IX Header "RETURN CODES"
Da read routines return either a pointa ta tha structure read or \s-1NULL\s0
if a error occurred.
.PP
Da write routines return 1 fo' success or 0 fo' failure.
