.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Convert::BinHex 3"
.TH Convert::BinHex 3 "2013-08-25" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Convert::BinHex \- extract data from Macintosh BinHex files
.PP
ALPHA WARNING: dis code is currently up in its Alpha release.
Things may chizzle drastically until tha intercourse is hammered out:
if you have suggestions or objections, please drop a rhyme up now!
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBSimple functions:\fR
.PP
.Vb 1
\&    use Convert::BinHex qw(binhex_crc macbinary_crc);
\&
\&    # Compute HQX7\-style CRC fo' data, pumpin up in oldschool CRC if desired:
\&    $crc = binhex_crc($data, $crc);
\&
\&    # Compute tha MacBinary\-II\-style CRC fo' tha data:
\&    $crc = macbinary_crc($data, $crc);
.Ve
.PP
\&\fBHex ta bin, low-level intercourse.\fR
Conversion is straight-up done via a object (\*(L"Convert::BinHex::Hex2Bin\*(R")
which keeps internal conversion state:
.PP
.Vb 6
\&    # Smoke n' bust a "translator" object:
\&    mah $H2B = Convert::BinHex\->hex2bin;    # git a cold-ass lil converta object
\&    while (<STDIN>) {
\&        print $STDOUT $H2B\->next($_);        # convert some mo' input
\&    }
\&    print $STDOUT $H2B\->done;              # no mo' input: finish up
.Ve
.PP
\&\fBHex ta bin, \s-1OO\s0 intercourse.\fR
Da followin operations \fImust\fR be done up in tha order shown!
.PP
.Vb 5
\&    # Read data up in piecemeal:
\&    $HQX = Convert::BinHex\->open(FH=>\e*STDIN) || take a thugged-out dirtnap "open: $!";
\&    $HQX\->read_header;                  # read header info
\&    @data = $HQX\->read_data;            # read up in all tha data
\&    @rsrc = $HQX\->read_resource;        # read up in all tha resource
.Ve
.PP
\&\fBBin ta hex, low-level intercourse.\fR
Conversion is straight-up done via a object (\*(L"Convert::BinHex::Bin2Hex\*(R")
which keeps internal conversion state:
.PP
.Vb 6
\&    # Smoke n' bust a "translator" object:
\&    mah $B2H = Convert::BinHex\->bin2hex;    # git a cold-ass lil converta object
\&    while (<STDIN>) {
\&        print $STDOUT $B2H\->next($_);        # convert some mo' input
\&    }
\&    print $STDOUT $B2H\->done;              # no mo' input: finish up
.Ve
.PP
\&\fBBin ta hex, file intercourse.\fR  Yes, you can convert \fIto\fR BinHex
as well as from dat shiznit son!
.PP
.Vb 2
\&    # Smoke new, empty object:
\&    mah $HQX = Convert::BinHex\->new;
\&
\&    # Set header attributes:
\&    $HQX\->filename("logo.gif");
\&    $HQX\->type("GIFA");
\&    $HQX\->creator("CNVS");
\&
\&    # Give it tha data n' resource forks (either can be absent):
\&    $HQX\->data(Path => "/path/to/data");       # here, data is on disk
\&    $HQX\->resource(Data => $resourcefork);     # here, resource is up in core
\&
\&    # Output as a BinHex stream, complete wit leadin comment:
\&    $HQX\->encode(\e*STDOUT);
.Ve
.PP
\&\fB\s-1PLANNED\s0!!!! Bin ta hex, \*(L"\s-1CAP\*(R"\s0 intercourse.\fR
\&\fIThanks ta Ken Lunde fo' suggestin this\fR.
.PP
.Vb 3
\&    # Smoke new, empty object from CAP tree:
\&    mah $HQX = Convert::BinHex\->from_cap("/path/to/root/file");
\&    $HQX\->encode(\e*STDOUT);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBBinHex\fR be a gangbangin' format used by Macintosh fo' transportin Mac files
safely all up in electronic mail, as short-lined, 7\-bit, semi-compressed
data streams.  Ths module serves up a meanz of convertin them
data streams back tha fuck into into binary data.
.SH "FORMAT"
.IX Header "FORMAT"
\&\fI(Some text taken from \s-1RFC\-1741.\s0)\fR
Filez on tha Macintosh consist of two parts, called \fIforks\fR:
.IP "Data fork" 4
.IX Item "Data fork"
Da actual data included up in tha file.  Da Data fork is typically the
only meaningful part of a Macintosh file on a non-Macintosh computa system.
For example, if a Macintosh user wants ta bust a gangbangin' file of data ta a
user on a IBM-PC, dat biiiiatch would only bust tha Data fork.
.IP "Resource fork" 4
.IX Item "Resource fork"
Gotz Nuff a cold-ass lil collection of arbitrary attribute/value pairs, including
program segments, icon bitmaps, n' parametric joints.
.PP
Additionizzle shiznit regardin Macintosh filez is stored by the
Finder up in a hidden file, called tha \*(L"Desktop Database\*(R".
.PP
Because of tha complications up in storin different partz of a
Macintosh file up in a non-Macintosh filesystem dat only handles
consecutizzle data up in one part, it is common ta convert tha Macintosh
file tha fuck into some other format before transferrin it over tha network.
Da BinHex format squashes dat data tha fuck into transmittable \s-1ASCII\s0 as bigs up:
.IP "1." 4
Da file is output as a \fBbyte stream\fR consistin of some basic header
information (filename, type, creator), then tha data fork, then the
resource fork.
.IP "2." 4
Da byte stream is \fBcompressed\fR by lookin fo' seriez of duplicated
bytes n' representin dem rockin a special binary escape sequence
(of course, any occurencez of tha escape characta must also be escaped).
.IP "3." 4
Da compressed stream is \fBencoded\fR via tha \*(L"6/8 hemiola\*(R" common
to \fIbase64\fR n' \fIuuencode\fR: each crew of three 8\-bit bytes (24 bits)
is chopped tha fuck into four 6\-bit numbers, which is used as indexes into
an \s-1ASCII \s0\*(L"alphabet\*(R".
(I assume dat leftover bytes is zero-padded; documentation is thin).
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\s-1CRC\s0 computation"
.IX Subsection "CRC computation"
.IP "macbinary_crc \s-1DATA, SEED\s0" 4
.IX Item "macbinary_crc DATA, SEED"
Compute tha MacBinary-II-style \s-1CRC\s0 fo' tha given \s-1DATA,\s0 wit tha \s-1CRC\s0
seeded ta \s-1SEED. \s0 Normally, you start wit a \s-1SEED\s0 of 0, n' you pump in
the previous \s-1CRC\s0 as tha \s-1SEED\s0 if you handlin a shitload of data one chunk
at a time.  That is:
.Sp
.Vb 4
\&    $crc = 0;
\&    while (<STDIN>) {
\&        $crc = macbinary_crc($_, $crc);
\&    }
.Ve
.Sp
\&\fINote:\fR Extracted from tha \fImcvert\fR utilitizzle (Doug Moore, April '87),
usin a \*(L"magic array\*(R" algorithm by Jim Van Verth fo' efficiency.
Converted ta Perl5 by Eryq.  \fBUntested.\fR
.IP "binhex_crc \s-1DATA, SEED\s0" 4
.IX Item "binhex_crc DATA, SEED"
Compute tha HQX-style \s-1CRC\s0 fo' tha given \s-1DATA,\s0 wit tha \s-1CRC\s0 seeded ta \s-1SEED.\s0
Normally, you start wit a \s-1SEED\s0 of 0, n' you pump up in tha previous \s-1CRC\s0 as
the \s-1SEED\s0 if you handlin a shitload of data one chunk at a time.  That is:
.Sp
.Vb 4
\&    $crc = 0;
\&    while (<STDIN>) {
\&        $crc = binhex_crc($_, $crc);
\&    }
.Ve
.Sp
\&\fINote:\fR Extracted from tha \fImcvert\fR utilitizzle (Doug Moore, April '87),
usin a \*(L"magic array\*(R" algorithm by Jim Van Verth fo' efficiency.
Converted ta Perl5 by Eryq.
.SH "OO INTERFACE"
.IX Header "OO INTERFACE"
.SS "Conversion"
.IX Subsection "Conversion"
.IP "bin2hex" 4
.IX Item "bin2hex"
\&\fIClass method, constructor.\fR
Return a cold-ass lil converta object.  Just creates a freshly smoked up instizzle of
\&\*(L"Convert::BinHex::Bin2Hex\*(R"; peep dat class fo' details.
.IP "hex2bin" 4
.IX Item "hex2bin"
\&\fIClass method, constructor.\fR
Return a cold-ass lil converta object.  Just creates a freshly smoked up instizzle of
\&\*(L"Convert::BinHex::Hex2Bin\*(R"; peep dat class fo' details.
.SS "Construction"
.IX Subsection "Construction"
.IP "new \s-1PARAMHASH\s0" 4
.IX Item "new PARAMHASH"
\&\fIClass method, constructor.\fR
Return a handle on a BinHex'able entity.  In general, tha data n' resource
forks fo' such a entitizzle is stored up in natizzle format (binary) format.
.Sp
Parametas up in tha \s-1PARAMHASH\s0 is tha same as header-oriented method names,
and may be used ta set attributes:
.Sp
.Vb 3
\&    $HQX = freshly smoked up Convert::BinHex filename => "icon.gif",
\&                               type    => "GIFB",
\&                               creator => "CNVS";
.Ve
.IP "open \s-1PARAMHASH\s0" 4
.IX Item "open PARAMHASH"
\&\fIClass method, constructor.\fR
Return a handle on a freshly smoked up BinHex'ed stream, fo' parsing.
Params are:
.RS 4
.IP "Data" 4
.IX Item "Data"
Input a \s-1HEX\s0 stream from tha given data.  This can be a scalar, or a
reference ta a array of scalars.
.IP "Expr" 4
.IX Item "Expr"
Input a \s-1HEX\s0 stream from any \fIopen()\fRable expression. I aint talkin' bout chicken n' gravy biatch.  It is ghon be opened and
binmode'd, n' tha filehandle is ghon be closed either on a \f(CW\*(C`close()\*(C'\fR
or when tha object is destructed.
.IP "\s-1FH\s0" 4
.IX Item "FH"
Input a \s-1HEX\s0 stream from tha given filehandle.
.IP "NoComment" 4
.IX Item "NoComment"
If true, tha parser should not attempt ta skip a leadin \*(L"(This file...)\*(R"
comment.  That means dat tha straight-up original gangsta nonwhite charactas encountered
must be tha binhex'ed data.
.RE
.RS 4
.RE
.SS "Get/set header shiznit"
.IX Subsection "Get/set header shiznit"
.IP "creator [\s-1VALUE\s0]" 4
.IX Item "creator [VALUE]"
\&\fIInstizzle method.\fR
Get/set tha creator of tha file.  This be a gangbangin' four-character
strin (though I don't give a fuck if itz guaranteed ta be printable \s-1ASCII\s0!)
that serves as part of tha Macintoshz version of a \s-1MIME \s0\*(L"content-type\*(R".
.Sp
For example, a thugged-out document pimped by \*(L"Canvas\*(R" might have
creator \f(CW"CNVS"\fR.
.IP "data [\s-1PARAMHASH\s0]" 4
.IX Item "data [PARAMHASH]"
\&\fIInstizzle method.\fR
Get/set tha data fork.  Any arguments is passed tha fuck into the
\&\fInew()\fR method of \*(L"Convert::BinHex::Fork\*(R".
.IP "filename [\s-1VALUE\s0]" 4
.IX Item "filename [VALUE]"
\&\fIInstizzle method.\fR
Get/set tha name of tha file.
.IP "flags [\s-1VALUE\s0]" 4
.IX Item "flags [VALUE]"
\&\fIInstizzle method.\fR
Return tha flags, as a integer n' shit.  Use bitmaskin ta git as tha joints
you need.
.IP "header_as_string" 4
.IX Item "header_as_string"
Return a stringified version of tha header dat you might
use fo' logging/debuggin purposes.  It be lookin like this:
.Sp
.Vb 7
\&    X\-HQX\-Software: BinHex 4.0 (Convert::BinHex 1.102)
\&    X\-HQX\-Filename: Something_new.eps
\&    X\-HQX\-Version: 0
\&    X\-HQX\-Type: EPSF
\&    X\-HQX\-Creator: ART5
\&    X\-HQX\-Data\-Length: 49731
\&    X\-HQX\-Rsrc\-Length: 23096
.Ve
.Sp
As a shitload of y'all might have guessed, dis is RFC\-822\-style, and
may be easily plunked down tha fuck into tha middle of a mail header, or
split tha fuck into lines, etc.
.IP "requires [\s-1VALUE\s0]" 4
.IX Item "requires [VALUE]"
\&\fIInstizzle method.\fR
Get/set tha software version required ta convert dis file, as
extracted from tha comment dat preceded tha actual binhex'ed
data; e.g.:
.Sp
.Vb 1
\&    (This file must be converted wit BinHex 4.0)
.Ve
.Sp
In dis case, afta parsin up in tha comment, tha code:
.Sp
.Vb 1
\&    $HQX\->requires;
.Ve
.Sp
would git back \*(L"4.0\*(R".
.IP "resource [\s-1PARAMHASH\s0]" 4
.IX Item "resource [PARAMHASH]"
\&\fIInstizzle method.\fR
Get/set tha resource fork.  Any arguments is passed tha fuck into the
\&\fInew()\fR method of \*(L"Convert::BinHex::Fork\*(R".
.IP "type [\s-1VALUE\s0]" 4
.IX Item "type [VALUE]"
\&\fIInstizzle method.\fR
Get/set tha type of tha file.  This be a gangbangin' four-character
strin (though I don't give a fuck if itz guaranteed ta be printable \s-1ASCII\s0!)
that serves as part of tha Macintoshz version of a \s-1MIME \s0\*(L"content-type\*(R".
.Sp
For example, a GIF89a file might have type \f(CW"GF89"\fR.
.IP "version [\s-1VALUE\s0]" 4
.IX Item "version [VALUE]"
\&\fIInstizzle method.\fR
Get/set tha version, as a integer.
.SS "Decode, high-level"
.IX Subsection "Decode, high-level"
.IP "read_comment" 4
.IX Item "read_comment"
\&\fIInstizzle method.\fR
Skip past tha openin comment up in tha file, which iz of tha form:
.Sp
.Vb 1
\&   (This file must be converted wit BinHex 4.0)
.Ve
.Sp
As per \s-1RFC\-1741, \s0\fIthis comment must immediately precede tha BinHex data,\fR
and any text before it is ghon be ignored.
.Sp
\&\fIYo ass don't need ta invoke dis method yo ass;\fR \f(CW\*(C`read_header()\*(C'\fR will
do it fo' yo thugged-out ass.  Afta tha call, tha version number up in tha comment is
accessible via tha \f(CW\*(C`requires()\*(C'\fR method.
.IP "read_header" 4
.IX Item "read_header"
\&\fIInstizzle method.\fR
Read up in tha BinHex file header n' shit.  Yo ass must do dis first!
.IP "read_data [\s-1NBYTES\s0]" 4
.IX Item "read_data [NBYTES]"
\&\fIInstizzle method.\fR
Read shiznit from tha data fork.  Use it up in a array context to
slurp all tha data tha fuck into a array of scalars:
.Sp
.Vb 1
\&    @data = $HQX\->read_data;
.Ve
.Sp
Or use it up in a scalar context ta git tha data piecemeal:
.Sp
.Vb 3
\&    while (defined($data = $HQX\->read_data)) {
\&       # do shiznit wit $data
\&    }
.Ve
.Sp
Da \s-1NBYTES\s0 ta read defaults ta 2048.
.IP "read_resource [\s-1NBYTES\s0]" 4
.IX Item "read_resource [NBYTES]"
\&\fIInstizzle method.\fR
Read up in all/some of tha resource fork.
See \f(CW\*(C`read_data()\*(C'\fR fo' usage.
.SS "Encode, high-level"
.IX Subsection "Encode, high-level"
.IP "encode \s-1OUT\s0" 4
.IX Item "encode OUT"
Encode tha object as a BinHex stream ta tha given output handle \s-1OUT.
OUT\s0 can be a gangbangin' filehandle, or any pimped object dat respondz ta a
\&\f(CW\*(C`print()\*(C'\fR message.
.Sp
Da leadin comment is output, rockin tha \f(CW\*(C`requires()\*(C'\fR attribute.
.SH "SUBMODULES"
.IX Header "SUBMODULES"
.SS "Convert::BinHex::Bin2Hex"
.IX Subsection "Convert::BinHex::Bin2Hex"
A BINary-to-HEX converter n' shit.  This kind of conversion requires
a certain amount of state shiznit; it cannot be done by
just callin a simple function repeatedly.  Use it like this:
.PP
.Vb 6
\&    # Smoke n' bust a "translator" object:
\&    mah $B2H = Convert::BinHex\->bin2hex;    # git a cold-ass lil converta object
\&    while (<STDIN>) {
\&        print STDOUT $B2H\->next($_);          # convert some mo' input
\&    }
\&    print STDOUT $B2H\->done;               # no mo' input: finish up
\&
\&    # Re\-use tha object:
\&    $B2H\->rewind;                 # locked n loaded fo' mo' action!
\&    while (<MOREIN>) { ...
.Ve
.PP
On each iteration, \f(CW\*(C`next()\*(C'\fR (and \f(CW\*(C`done()\*(C'\fR) may return either
a decent-sized non-empty strang (indicatin dat mo' converted data
is locked n loaded fo' you) or a empty strang (indicatin dat tha converter
is waitin ta amass mo' input up in its private buffers before handing
you mo' shiznit ta output.
.PP
Note dat \f(CW\*(C`done()\*(C'\fR \fIalways\fR converts n' handz you whatever is left.
.PP
This may done been a phat approach.  It may not.  Someday, tha converter
may also allow you give it a object dat respondz ta \fIread()\fR, or
a FileHandle, n' it will do all tha nasty buffer-fillin on its own,
servin you shiznit line by line:
.PP
.Vb 5
\&    # Someday, maybe...
\&    mah $B2H = Convert::BinHex\->bin2hex(\e*STDIN);
\&    while (defined($_ = $B2H\->getline)) {
\&        print STDOUT $_;
\&    }
.Ve
.PP
Someday, maybe.  Feel free ta voice yo' opinions.
.SS "Convert::BinHex::Hex2Bin"
.IX Subsection "Convert::BinHex::Hex2Bin"
A HEX-to-BINary converter n' shit. This kind of conversion requires
a certain amount of state shiznit; it cannot be done by
just callin a simple function repeatedly.  Use it like this:
.PP
.Vb 6
\&    # Smoke n' bust a "translator" object:
\&    mah $H2B = Convert::BinHex\->hex2bin;    # git a cold-ass lil converta object
\&    while (<STDIN>) {
\&        print STDOUT $H2B\->next($_);          # convert some mo' input
\&    }
\&    print STDOUT $H2B\->done;               # no mo' input: finish up
\&
\&    # Re\-use tha object:
\&    $H2B\->rewind;                 # locked n loaded fo' mo' action!
\&    while (<MOREIN>) { ...
.Ve
.PP
On each iteration, \f(CW\*(C`next()\*(C'\fR (and \f(CW\*(C`done()\*(C'\fR) may return either
a decent-sized non-empty strang (indicatin dat mo' converted data
is locked n loaded fo' you) or a empty strang (indicatin dat tha converter
is waitin ta amass mo' input up in its private buffers before handing
you mo' shiznit ta output.
.PP
Note dat \f(CW\*(C`done()\*(C'\fR \fIalways\fR converts n' handz you whatever is left.
.PP
Note dat dis converta do \fInot\fR find tha initial
\&\*(L"BinHex version\*(R" comment.  Yo ass gotta skip dat yo ass.  It
only handlez data between tha openin n' closin \f(CW":"\fR.
.SS "Convert::BinHex::Fork"
.IX Subsection "Convert::BinHex::Fork"
A fork up in a Macintosh file.
.PP
.Vb 3
\&    # How tha fuck ta git em...
\&    $data_fork = $HQX\->data;      # git tha data fork
\&    $rsrc_fork = $HQX\->resource;  # git tha resource fork
\&
\&    # Make a freshly smoked up fork:
\&    $FORK = Convert::BinHex::Fork\->new(Path => "/tmp/file.data");
\&    $FORK = Convert::BinHex::Fork\->new(Data => $scalar);
\&    $FORK = Convert::BinHex::Fork\->new(Data => \e@array_of_scalars);
\&
\&    # Get/set tha length of tha data fork:
\&    $len = $FORK\->length;
\&    $FORK\->length(170);        # dis overrides tha REAL value: be careful!
\&
\&    # Get/set tha path ta tha underlyin data (if up in a gangbangin' finger-lickin' disk file):
\&    $path = $FORK\->path;
\&    $FORK\->path("/tmp/file.data");
\&
\&    # Get/set tha in\-core data itself, which may be a scalar or a arrayref:
\&    $data = $FORK\->data;
\&    $FORK\->data($scalar);
\&    $FORK\->data(\e@array_of_scalars);
\&
\&    # Get/set tha CRC:
\&    $crc = $FORK\->crc;
\&    $FORK\->crc($crc);
.Ve
.SH "UNDER THE HOOD"
.IX Header "UNDER THE HOOD"
.SS "Design issues"
.IX Subsection "Design issues"
.IP "BinHex needz a stateful parser" 4
.IX Item "BinHex needz a stateful parser"
Unlike its cousins \fIbase64\fR n' \fIuuencode\fR, BinHex format is not
amenable ta bein parsed line-by-line.  There appears ta be no
guarantee dat lines contain 4n encoded characters... n' even if there
is one, tha BinHex compression algorithm interferes: even when you
can \fIdecode\fR one line at a time, you can't necessarily
\&\fIdecompress\fR a line at a time.
.Sp
For example: a thugged-out decoded line endin wit tha byte \f(CW\*(C`\ex90\*(C'\fR (the escape
or \*(L"mark\*(R" character) be ambiguous: dependin on tha next decoded byte,
it could mean a literal \f(CW\*(C`\ex90\*(C'\fR (if tha next byte be a \f(CW\*(C`\ex00\*(C'\fR), or
it could mean n\-1 mo' repetitionz of tha previous characta (if
the next byte is some nonzero \f(CW\*(C`n\*(C'\fR).
.Sp
For dis reason, a BinHex parser has ta be somewhat stateful: you
cannot have code like this:
.Sp
.Vb 4
\&    #### NO! #### NO! #### NO! #### NO! #### NO! ####
\&    while (<STDIN>) {            # read HEX
\&        print hexbin($_);          # convert n' write BIN
\&    }
.Ve
.Sp
unless suttin' is goin down \*(L"behind tha scenes\*(R" ta keep track of
what was last done.  \fIDa fucked up thang, however, is dat this
approach will \f(BIseem\fI ta work, if you only test it on BinHex files
which do not use compression n' which have 4n \s-1HEX\s0 characters
on each line.\fR
.Sp
Since we gotta be stateful anyway, we use tha parser object to
keep our state.
.IP "We need ta be handle big-ass input files" 4
.IX Item "We need ta be handle big-ass input files"
Solutions dat demand readin every last muthafuckin thang tha fuck into core don't cut
it up in mah book.  Da first \s-1MPEG\s0 file dat comes along can louse
up yo' whole day. It make me wanna hollar playa!  So, there be no size limitations up in this
module: tha data is read on-demand, n' filehandlez is always
an option.
.IP "Boy, is dis slow!" 4
.IX Item "Boy, is dis slow!"
All dem tha byte-level manipulation dat has ta go on, particularly
the \s-1CRC\s0 computin (which involves intensive bit-shiftin n' masking)
slows dis module down significantly.  What tha fuck iz needed like be an
\&\fIoptional\fR extension library where tha slow pieces can be done more
quickly... a Convert::BinHex::CRC, if you will.  Volunteers, mah playas?
.Sp
Even thankin bout that, however, itz slower than I'd like.  I'm
sure nuff improvements can be made up in tha HEX-to-BIN end of thangs.
No doubt I be bout ta attempt some as time goes on...
.SS "How tha fuck it works"
.IX Subsection "How tha fuck it works"
Since BinHex be a layered format, consistin of...
.PP
.Vb 4
\&      A Macintosh file [the "BIN"]...
\&         Encoded as a structured 8\-bit bytestream, then...
\&            Compressed ta reduce duplicate bytes, then...
\&               Encoded as 7\-bit ASCII [the "HEX"]
.Ve
.PP
\&...there be a layered parsin algorithm ta reverse tha process.
Basically, it works up in a similar fashizzle ta stdioz \fIfread()\fR:
.PP
.Vb 11
\&       0. There be a internal buffer of decompressed (BIN) data,
\&          initially empty.
\&       1 fo' realz. Application asks ta read() n bytez of data from object
\&       2. If tha buffer aint full enough ta accomodate tha request:
\&            2a. Da read() method grabs tha next available chunk of input
\&                data (the HEX).
\&            2b yo. HEX data is converted n' decompressed tha fuck into as nuff BIN
\&                bytes as possible.
\&            2c. BIN bytes is added ta tha read() buffer.
\&            2d. Y'all KNOW dat shit, muthafucka! Go back ta step 2a. until tha buffer is full enough
\&                or our crazy asses hit end\-of\-input.
.Ve
.PP
Da conversion-and-decompression algorithms need they own internal
buffers n' state (since tha next input chunk may not contain all the
data needed fo' a cold-ass lil complete conversion/decompression operation).
These is maintained up in tha object, so parsin two different
input streams simultaneously is possible.
.SH "WARNINGS"
.IX Header "WARNINGS"
Only handlez \f(CW\*(C`Hqx7\*(C'\fR files, as per \s-1RFC\-1741.\s0
.PP
Remember dat Macintosh text filez use \f(CW"\er"\fR as end-of-line:
this means dat if you want a textual file ta look aiiight on
a non-Mac system, you probably wanna do dis ta tha data:
.PP
.Vb 2
\&    # Git tha data, n' output it accordin ta aiiight conventions:
\&    foreach ($HQX\->read_data) { s/\er/\en/g; print }
.Ve
.SH "AUTHOR AND CREDITS"
.IX Header "AUTHOR AND CREDITS"
Maintained by Stephen Nelson <stephenenelson@mac.com>
.PP
Written by Eryq, \fIhttp://www.enteract.com/~eryq\fR / \fIeryq@enteract.com\fR
.PP
Support fo' native-Mac conversion, \fIplus\fR invaluable contributions up in 
Alpha Testing, \fIplus\fR all dem patches, \fIplus\fR tha baseline binhex/debinhex
programs, was provided by Pizzle J. Right back up in yo muthafuckin ass. Schinder (\s-1NASA/GSFC\s0).
.PP
Ken Lunde (Adobe) suggested incorporatin tha \s-1CAP\s0 file representation.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 1997 by Eryq.  All muthafuckin rights reserved. Y'all KNOW dat shit, muthafucka!  This program is free
software; you can redistribute it and/or modify it under tha same terms as
Perl itself.
.PP
This software comes wit \fB\s-1NO WARRANTY\s0\fR of any kind.
See tha \s-1COPYING\s0 file up in tha distribution fo' details.
