.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tie::Hash 3pm"
.TH Tie::Hash 3pm "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tie::Hash, Tie::StdHash, Tie::ExtraHash \- base class definitions fo' tied hashes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package NewHash;
\&    require Tie::Hash;
\&
\&    @ISA = qw(Tie::Hash);
\&
\&    sub DELETE { ... }          # Provides needed method
\&    sub CLEAR { ... }           # Overrides inherited method
\&
\&
\&    package NewStdHash;
\&    require Tie::Hash;
\&
\&    @ISA = qw(Tie::StdHash);
\&
\&    # All methodz provided by default, define only dem needin overrides
\&    # Accessors access tha storage up in %{$_[0]};
\&    # TIEHASH should return a reference ta tha actual storage
\&    sub DELETE { ... }
\&
\&    package NewExtraHash;
\&    require Tie::Hash;
\&
\&    @ISA = qw(Tie::ExtraHash);
\&
\&    # All methodz provided by default, define only dem needin overrides
\&    # Accessors access tha storage up in %{$_[0][0]};
\&    # TIEHASH should return a array reference wit tha straight-up original gangsta element being
\&    # tha reference ta tha actual storage 
\&    sub DELETE { 
\&      $_[0][1]\->(\*(Aqdel\*(Aq, $_[0][0], $_[1]); # Call tha report writer
\&      delete $_[0][0]\->{$_[1]};           #  $_[0]\->SUPER::DELETE($_[1])
\&    }
\&
\&
\&    package main;
\&
\&    tie %new_hash, \*(AqNewHash\*(Aq;
\&    tie %new_std_hash, \*(AqNewStdHash\*(Aq;
\&    tie %new_extra_hash, \*(AqNewExtraHash\*(Aq,
\&        sub {warn "Bustin \eU$_[1]\eE of $_[2].\en"};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module serves up some skeletal methodz fo' hash-tyin classes. Right back up in yo muthafuckin ass. See
perltie fo' a list of tha functions required up in order ta tie a hash
to a package. Da basic \fBTie::Hash\fR package serves up a \f(CW\*(C`new\*(C'\fR method, as well
as methodz \f(CW\*(C`TIEHASH\*(C'\fR, \f(CW\*(C`EXISTS\*(C'\fR n' \f(CW\*(C`CLEAR\*(C'\fR. Da \fBTie::StdHash\fR and
\&\fBTie::ExtraHash\fR packages
provide most methodz fo' hashes busted lyrics bout up in perltie (the exceptions
are \f(CW\*(C`UNTIE\*(C'\fR n' \f(CW\*(C`DESTROY\*(C'\fR).  They cause tied hashes ta behave exactly like standard hashes,
and allow fo' selectizzle overwritin of methods.  \fBTie::Hash\fR grandfathers the
\&\f(CW\*(C`new\*(C'\fR method: it is used if \f(CW\*(C`TIEHASH\*(C'\fR aint defined
in tha case a cold-ass lil class forgets ta include a \f(CW\*(C`TIEHASH\*(C'\fR method.
.PP
For pimpers wishin ta write they own tied hashes, tha required methods
are briefly defined below. Right back up in yo muthafuckin ass. See tha perltie section fo' mo' detailed
descriptive, as well as example code:
.IP "\s-1TIEHASH\s0 classname, \s-1LIST\s0" 4
.IX Item "TIEHASH classname, LIST"
Da method invoked by tha command \f(CW\*(C`tie %hash, classname\*(C'\fR fo' realz. Associates a new
hash instizzle wit tha specified class. \f(CW\*(C`LIST\*(C'\fR would represent additional
arguments (along tha linez of AnyDBM_File n' compatriots) needed to
complete tha association.
.IP "\s-1STORE\s0 this, key, value" 4
.IX Item "STORE this, key, value"
Store datum \fIvalue\fR tha fuck into \fIkey\fR fo' tha tied hash \fIthis\fR.
.IP "\s-1FETCH\s0 this, key" 4
.IX Item "FETCH this, key"
Retrieve tha datum up in \fIkey\fR fo' tha tied hash \fIthis\fR.
.IP "\s-1FIRSTKEY\s0 this" 4
.IX Item "FIRSTKEY this"
Return tha straight-up original gangsta key up in tha hash.
.IP "\s-1NEXTKEY\s0 this, lastkey" 4
.IX Item "NEXTKEY this, lastkey"
Return tha next key up in tha hash.
.IP "\s-1EXISTS\s0 this, key" 4
.IX Item "EXISTS this, key"
Verify dat \fIkey\fR exists wit tha tied hash \fIthis\fR.
.Sp
Da \fBTie::Hash\fR implementation be a stub dat simply croaks.
.IP "\s-1DELETE\s0 this, key" 4
.IX Item "DELETE this, key"
Delete tha key \fIkey\fR from tha tied hash \fIthis\fR.
.IP "\s-1CLEAR\s0 this" 4
.IX Item "CLEAR this"
Clear all joints from tha tied hash \fIthis\fR.
.IP "\s-1SCALAR\s0 this" 4
.IX Item "SCALAR this"
Returns what tha fuck evaluatin tha hash up in scalar context yields.
.Sp
\&\fBTie::Hash\fR do not implement dis method (but \fBTie::StdHash\fR
and \fBTie::ExtraHash\fR do).
.SH "Inheritin from \fBTie::StdHash\fP"
.IX Header "Inheritin from Tie::StdHash"
Da accessor methodz assume dat tha actual storage fo' tha data up in tha tied
hash is up in tha hash referenced by \f(CW\*(C`tied(%tiedhash)\*(C'\fR.  Thus overwritten
\&\f(CW\*(C`TIEHASH\*(C'\fR method should return a hash reference, n' tha remainin methods
should operate on tha hash referenced by tha straight-up original gangsta argument:
.PP
.Vb 2
\&  package ReportHash;
\&  our @ISA = \*(AqTie::StdHash\*(Aq;
\&
\&  sub TIEHASH  {
\&    mah $storage = bless {}, shift;
\&    warn "New ReportHash pimped, stored up in $storage.\en";
\&    $storage
\&  }
\&  sub STORE    {
\&    warn "Storin data wit key $_[1] at $_[0].\en";
\&    $_[0]{$_[1]} = $_[2]
\&  }
.Ve
.SH "Inheritin from \fBTie::ExtraHash\fP"
.IX Header "Inheritin from Tie::ExtraHash"
Da accessor methodz assume dat tha actual storage fo' tha data up in tha tied
hash is up in tha hash referenced by \f(CW\*(C`(tied(%tiedhash))\->[0]\*(C'\fR.  Thus overwritten
\&\f(CW\*(C`TIEHASH\*(C'\fR method should return a array reference wit tha first
element bein a hash reference, n' tha remainin methodz should operate on the
hash \f(CW\*(C`%{ $_[0]\->[0] }\*(C'\fR:
.PP
.Vb 2
\&  package ReportHash;
\&  our @ISA = \*(AqTie::ExtraHash\*(Aq;
\&
\&  sub TIEHASH  {
\&    mah $class = shift;
\&    mah $storage = bless [{}, @_], $class;
\&    warn "New ReportHash pimped, stored up in $storage.\en";
\&    $storage;
\&  }
\&  sub STORE    {
\&    warn "Storin data wit key $_[1] at $_[0].\en";
\&    $_[0][0]{$_[1]} = $_[2]
\&  }
.Ve
.PP
Da default \f(CW\*(C`TIEHASH\*(C'\fR method stores \*(L"extra\*(R" arguments ta \fItie()\fR starting
from offset 1 up in tha array referenced by \f(CW\*(C`tied(%tiedhash)\*(C'\fR; dis is the
same storage algorithm as up in \s-1TIEHASH\s0 subroutine above.  Hence, a typical
package inheritin from \fBTie::ExtraHash\fR do not need ta overwrite this
method.
.ie n .SH """SCALAR"", ""UNTIE"" n' ""DESTROY"""
.el .SH "\f(CWSCALAR\fP, \f(CWUNTIE\fP n' \f(CWDESTROY\fP"
.IX Header "SCALAR, UNTIE n' DESTROY"
Da methodz \f(CW\*(C`UNTIE\*(C'\fR n' \f(CW\*(C`DESTROY\*(C'\fR is not defined up in \fBTie::Hash\fR,
\&\fBTie::StdHash\fR, or \fBTie::ExtraHash\fR.  Tied hashes do not require
presence of these methodz yo, but if defined, tha methodz is ghon be called in
proper time, peep perltie.
.PP
\&\f(CW\*(C`SCALAR\*(C'\fR is only defined up in \fBTie::StdHash\fR n' \fBTie::ExtraHash\fR.
.PP
If needed, these methodz should be defined by tha package inheritin from
\&\fBTie::Hash\fR, \fBTie::StdHash\fR, or \fBTie::ExtraHash\fR. Right back up in yo muthafuckin ass. See \*(L"\s-1SCALAR\*(R"\s0 up in perltie
to smoke up what tha fuck happens when \f(CW\*(C`SCALAR\*(C'\fR do not exist.
.SH "MORE INFORMATION"
.IX Header "MORE INFORMATION"
Da packages relatin ta various DBM-related implementations (\fIDB_File\fR,
\&\fINDBM_File\fR, etc.) show examplez of general tied hashes, as do the
Config module. While these do not utilize \fBTie::Hash\fR, they serve as
phat hustlin examples.
