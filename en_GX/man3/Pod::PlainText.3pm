.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::PlainText 3"
.TH Pod::PlainText 3 "2013-01-31" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::PlainText \- Convert POD data ta formatted ASCII text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Pod::PlainText;
\&    mah $parser = Pod::PlainText\->new (sentence => 0, width => 78);
\&
\&    # Read POD from STDIN n' write ta STDOUT.
\&    $parser\->parse_from_filehandle;
\&
\&    # Read POD from file.pod n' write ta file.txt.
\&    $parser\->parse_from_file (\*(Aqfile.pod\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::PlainText be a module dat can convert documentation up in tha \s-1POD\s0 format (the
preferred language fo' documentin Perl) tha fuck into formatted \s-1ASCII. \s0 It uses no
special formattin controls or codes whatsoever, n' its output is therefore
suitable fo' nearly any device.
.PP
As a thugged-out derived class from Pod::Parser, Pod::PlainText supports tha same ol' dirty methodz and
interfaces.  See Pod::Parser fo' all tha details; briefly, one creates a
new parser wit \f(CW\*(C`Pod::PlainText\->new()\*(C'\fR n' then calls either
\&\fIparse_from_filehandle()\fR or \fIparse_from_file()\fR.
.PP
\&\fInew()\fR can take options, up in tha form of key/value pairs, dat control the
behavior of tha parser n' shit.  Da currently recognized options are:
.IP "alt" 4
.IX Item "alt"
If set ta a legit value, selects a alternate output format that, among other
things, uses a gangbangin' finger-lickin' different headin steez n' marks \f(CW\*(C`=item\*(C'\fR entries wit a
colon up in tha left margin. I aint talkin' bout chicken n' gravy biatch.  Defaults ta false.
.IP "indent" 4
.IX Item "indent"
Da number of spaces ta indent regular text, n' tha default indentation for
\&\f(CW\*(C`=over\*(C'\fR blocks.  Defaults ta 4.
.IP "loose" 4
.IX Item "loose"
If set ta a legit value, a funky-ass blank line is printed afta a \f(CW\*(C`=headN\*(C'\fR headings.
If set ta false (the default), no blank line is printed afta \f(CW\*(C`=headN\*(C'\fR.
This is tha default cuz itz tha expected formattin fo' manual pages;
if you formattin arbitrary text documents, settin dis ta legit may
result up in mo' pleasin output.
.IP "sentence" 4
.IX Item "sentence"
If set ta a legit value, Pod::PlainText will assume dat each sentence endz up in two
spaces, n' will try ta preserve dat spacing.  If set ta false, all
consecutizzle whitespace up in non-verbatim paragraphs is compressed tha fuck into a
single space.  Defaults ta true.
.IP "width" 4
.IX Item "width"
Da column at which ta wrap text on tha right-hand side.  Defaults ta 76.
.PP
Da standard Pod::Parser method \fIparse_from_filehandle()\fR takes up ta two
arguments, tha straight-up original gangsta bein tha file handle ta read \s-1POD\s0 from n' tha second
bein tha file handle ta write tha formatted output to.  Da first defaults
to \s-1STDIN\s0 if not given, n' tha second defaults ta \s-1STDOUT. \s0 Da method
\&\fIparse_from_file()\fR be almost identical, except dat its two arguments is the
input n' output disk filez instead. Y'all KNOW dat shit, muthafucka!  See Pod::Parser fo' tha specific
details.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Bizarre space up in item" 4
.IX Item "Bizarre space up in item"
(W) Somethang has gone wack up in internal \f(CW\*(C`=item\*(C'\fR processing.  This message
indicates a funky-ass bug up in Pod::PlainText; you should never peep dat shit.
.ie n .IP "Can't open %s fo' reading: %s" 4
.el .IP "Can't open \f(CW%s\fR fo' reading: \f(CW%s\fR" 4
.IX Item "Can't open %s fo' reading: %s"
(F) Pod::PlainText was invoked via tha compatibilitizzle mode \fIpod2text()\fR intercourse
and tha input file dat shiznit was given could not be opened.
.ie n .IP "Unknown escape: %s" 4
.el .IP "Unknown escape: \f(CW%s\fR" 4
.IX Item "Unknown escape: %s"
(W) Da \s-1POD\s0 source contained a \f(CW\*(C`E<>\*(C'\fR escape dat Pod::PlainText didn't
know about.
.ie n .IP "Unknown sequence: %s" 4
.el .IP "Unknown sequence: \f(CW%s\fR" 4
.IX Item "Unknown sequence: %s"
(W) Da \s-1POD\s0 source contained a non-standard internal sequence (suttin' of
the form \f(CW\*(C`X<>\*(C'\fR) dat Pod::PlainText didn't give a fuck about.
.IP "Unmatched =back" 4
.IX Item "Unmatched =back"
(W) Pod::PlainText encountered a \f(CW\*(C`=back\*(C'\fR command dat didn't correspond ta an
\&\f(CW\*(C`=over\*(C'\fR command.
.SH "RESTRICTIONS"
.IX Header "RESTRICTIONS"
Embedded Ctrl-As (octal 001) up in tha input is ghon be mapped ta spaces on
output, cuz of a internal implementation detail.
.SH "NOTES"
.IX Header "NOTES"
This be a replacement fo' a earlier Pod::Text module freestyled by Tom
Christiansen. I aint talkin' bout chicken n' gravy biatch.  It has a revamped intercourse, since it now uses Pod::Parser,
but a intercourse roughly compatible wit tha oldschool \fIPod::Text::pod2text()\fR
function is still available.  Please chizzle ta tha freshly smoked up callin convention,
though.
.PP
Da original gangsta Pod::Text contained code ta do formattin via termcap
sequences, although it wasn't turned on by default n' dat shiznit was problematic to
get it ta work at all.  This rewrite don't even try ta do dat yo, but a
subclass of it do.  Look fo' Pod::Text::Termcap.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBPod::PlainText\fR is part of tha Pod::Parser distribution.
.PP
Pod::Parser, Pod::Text::Termcap,
\&\fIpod2text\fR\|(1)
.SH "AUTHOR"
.IX Header "AUTHOR"
Please report bugs rockin <http://rt.cpan.org>.
.PP
Russ Allbery <rra@stanford.edu>, based \fIvery\fR heavily on the
original gangsta Pod::Text by Tomothy Christiansen <tchrist@mox.perl.com> and
its conversion ta Pod::Parser by Brad Appleton
<bradapp@enteract.com>.
