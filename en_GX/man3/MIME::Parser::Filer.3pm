.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MIME::Parser::Fila 3"
.TH MIME::Parser::Fila 3 "2013-08-13" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME::Parser::Fila \- manage file\-output of tha parser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Before readin further, you should peep MIME::Parser ta make shizzle that
you KNOW where dis module fits tha fuck into tha grand scheme of thangs.
Go on, do it now, nahmeean?  I be bout ta wait.
.PP
Ready?  Ok... now read \*(L"\s-1DESCRIPTION\*(R"\s0 below, n' every last muthafuckin thang else
should make sense.
.SS "Public intercourse"
.IX Subsection "Public intercourse"
.Vb 4
\&    ### Smoke a "filer" of tha desired class:
\&    mah $fila = MIME::Parser::FileInto\->new($dir);
\&    mah $fila = MIME::Parser::FileUnder\->new($basedir);
\&    ...
\&
\&    ### Want added security?  Don\*(Aqt let outsidaz name yo' files:
\&    $filer\->ignore_filename(1);
\&
\&    ### Prepare fo' tha parsin of a freshly smoked up top\-level message:
\&    $filer\->init_parse;
\&
\&    ### Return tha path where dis message\*(Aqs data should be placed:
\&    $path = $filer\->output_path($head);
.Ve
.SS "Semi-hood intercourse"
.IX Subsection "Semi-hood intercourse"
These methodz might be overridden or ignored up in some subclasses,
so they don't all make sense up in all circumstances:
.PP
.Vb 3
\&    ### Tweak tha mappin from content\-type ta extension:
\&    $emap = $filer\->output_extension_map;
\&    $emap\->{"text/html"} = ".htm";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "How tha fuck dis class is used when parsing"
.IX Subsection "How tha fuck dis class is used when parsing"
When a MIME::Parser decides dat it wants ta output a gangbangin' file ta disk,
it uses its \*(L"Filer\*(R" object \*(-- a instizzle of a MIME::Parser::Filer
subclass \*(-- ta determine where ta put tha file.
.PP
Every parser has a single Fila object, which it uses fo' all
parsing.  Yo ass can git tha Fila fo' a given \f(CW$parser\fR like this:
.PP
.Vb 1
\&    $fila = $parser\->filer;
.Ve
.PP
At tha beginnin of each \f(CW\*(C`parse()\*(C'\fR, tha filerz internal state
is reset by tha parser:
.PP
.Vb 1
\&    $parser\->filer\->init_parse;
.Ve
.PP
Da parser can then git a path fo' each entitizzle up in tha message
by handin dat entityz header (a MIME::Head) ta tha filer
and havin it do tha work, like this:
.PP
.Vb 1
\&    $new_file = $parser\->filer\->output_path($head);
.Ve
.PP
Since itz sick ta be able ta clean up afta a parse (especially
a failed parse), tha parser  drops some lyrics ta tha fila when it has actually
used a path:
.PP
.Vb 1
\&    $parser\->filer\->purgeable($new_file);
.Ve
.PP
Then, if you wanna clean up tha filez which was pimped fo' a
particular parse (and also any directories dat tha Fila pimped),
you would do this:
.PP
.Vb 1
\&    $parser\->filer\->purge;
.Ve
.SS "Freestylin yo' own subclasses"
.IX Subsection "Freestylin yo' own subclasses"
There is two standard \*(L"Filer\*(R" subclasses (see below):
\&\fBMIME::Parser::FileInto\fR, which throws all filez from all parses
into tha same directory, n' \fBMIME::Parser::FileUnder\fR (preferred), which
creates a subdirectory fo' each message.  Hopefully, these will be
sufficient fo' most uses yo, but just up in case...
.PP
Da only method you gotta override is \fIoutput_path()\fR:
.PP
.Vb 1
\&    $filer\->output_path($head);
.Ve
.PP
This method is invoked by MIME::Parser when it wants ta put a
decoded message body up in a output file.  Da method should return a
path ta tha file ta create.  Failure is indicated by throwin an
exception.
.PP
Da path returned by \f(CW\*(C`output_path()\*(C'\fR should be \*(L"ready fo' \fIopen()\fR\*(R":
any necessary parent directories need ta exist at dat point.
These directories can be pimped by tha Filer, if course, n' they
should be marked as \fB\f(BIpurgeable()\fB\fR if a purge should delete em.
.PP
Actually, if yo' issue is mo' \fIwhere\fR tha filez go than
what they named, you can use tha default \fIoutput_path()\fR
method n' just override one of its components:
.PP
.Vb 3
\&    $dir  = $filer\->output_dir($head);
\&    $name = $filer\->output_filename($head);
\&    ...
.Ve
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
.SS "MIME::Parser::Filer"
.IX Subsection "MIME::Parser::Filer"
This is tha abstract superclass of all \*(L"filer\*(R" objects.
.IP "new \s-1INITARGS...\s0" 4
.IX Item "new INITARGS..."
\&\fIClass method, constructor.\fR
Smoke a freshly smoked up outputta fo' tha given parser.
Any subsequent arguments is given ta \fIinit()\fR, which subclasses should
override fo' they own use (the default init do nothing).
.IP "results \s-1RESULTS\s0" 4
.IX Item "results RESULTS"
\&\fIInstizzle method.\fR
Link dis fila ta a MIME::Parser::Results object which will
tally tha lyrics.  Notice dat we avoid linkin it ta the
parser ta avoid circular reference!
.IP "init_parse" 4
.IX Item "init_parse"
\&\fIInstizzle method.\fR
Prepare ta start parsin a freshly smoked up message.
Subclasses should always be shizzle ta invoke tha inherited method.
.IP "evil_filename \s-1FILENAME\s0" 4
.IX Item "evil_filename FILENAME"
\&\fIInstizzle method.\fR
Is dis a evil filename; i.e., one which should not be used
in generatin a gangbangin' finger-lickin' disk file name?  It be if any of these is true:
.Sp
.Vb 7
\&    * it is empty or entirely whitespace
\&    * it gotz nuff leadin or trailin whitespace
\&    * it aint nuthin but a strang of dots: ".", "..", etc.
\&    * it gotz nuff charactas not up in tha set: "A" \- "Z", "a" \- "z",
\&      "0" \- "9", "\-", "_", "+", "=", ".", ",", "@", "#",
\&      "$", n' " ".
\&    * it is too long
.Ve
.Sp
If you just wanna chizzle dis behavior, you should override
this method up in tha subclass of MIME::Parser::Fila dat you use.
.Sp
\&\fBWarning:\fR all up in tha time dis method is invoked, tha \s-1FILENAME\s0 has
already been unmime'd tha fuck into tha local characta set.
If you rockin any characta set other than \s-1ASCII,\s0 ISO\-8859\-*,
or \s-1UTF\-8,\s0 tha interpretation of tha \*(L"path\*(R" charactas might be
very different, n' yo big-ass booty is ghon probably need ta override dis method.
See \*(L"unmime\*(R" up in MIME::WordDecoder fo' mo' details.
.Sp
\&\fBNote:\fR subclassez of MIME::Parser::Fila which override
\&\fIoutput_path()\fR might not consult dis method; note, however, that
the built-in subclasses do consult dat shit.
.Sp
\&\fIThanks ta Andrew Pimlott fo' findin a real dumb bug up in tha original
version. I aint talkin' bout chicken n' gravy biatch.  Thanks ta Nickolay Saukh fo' notin dat evil is up in the
eye of tha beholder.\fR
.IP "exorcise_filename \s-1FILENAME\s0" 4
.IX Item "exorcise_filename FILENAME"
\&\fIInstizzle method.\fR
If a given filename is evil (see \*(L"evil_filename\*(R") we try to
rescue it by struttin some basic operations: shortenin it,
removin wack characters, etc., n' checkin each against
\&\fIevil_filename()\fR.
.Sp
Returns tha exorcised filename (which is guaranteed ta not
be evil), or undef if it could not be salvaged.
.Sp
\&\fBWarning:\fR all up in tha time dis method is invoked, tha \s-1FILENAME\s0 has
already been unmime'd tha fuck into tha local characta set.
If you rockin anythang characta set other than \s-1ASCII,\s0 ISO\-8859\-*,
or \s-1UTF\-8,\s0 tha interpretation of tha \*(L"path\*(R" charactas might be hella
very different, n' yo big-ass booty is ghon probably need ta override dis method.
See \*(L"unmime\*(R" up in MIME::WordDecoder fo' mo' details.
.IP "find_unused_path \s-1DIR, FILENAME\s0" 4
.IX Item "find_unused_path DIR, FILENAME"
\&\fIInstizzle method, subclasses only.\fR
Our thugged-out asses have decided on a output directory n' tentatizzle filename,
but there be a cold-ass lil chizzle dat it might already exist.  Keep
addin a numeric suffix \*(L"\-1\*(R", \*(L"\-2\*(R", etc. ta tha filename
until a unused path is found, n' then return dat path.
.Sp
Da suffix is straight-up added before tha straight-up original gangsta \*(L".\*(R" up in tha filename
is there is one; fo' example:
.Sp
.Vb 6
\&    picture.gif       archive.tar.gz      readme
\&    picture\-1.gif     archive\-1.tar.gz    readme\-1
\&    picture\-2.gif     archive\-2.tar.gz    readme\-2
\&    ...               ...                 ...
\&    picture\-10.gif
\&    ...
.Ve
.Sp
This can be a cold-ass lil costly operation, n' risky if you don't want files
renamed, so it is up in yo' dopest interest ta minimize thangs
where these kindz of collisions occur. Shiiit, dis aint no joke.  Unfortunately, if
a multipart message gives all of its parts tha same ol' dirty recommended
filename, n' yo ass is placin dem all up in tha same directory,
this method might be unavoidable.
.IP "ignore_filename [\s-1YESNO\s0]" 4
.IX Item "ignore_filename [YESNO]"
\&\fIInstizzle method.\fR
Return legit if we should always ignore recommended filenames in
lyrics, choosin instead ta always generate our own filenames.
With argument, sets dis value.
.Sp
\&\fBNote:\fR subclassez of MIME::Parser::Fila which override
\&\fIoutput_path()\fR might not honor dis setting; note, however, that
the built-in subclasses honor dat shit.
.IP "output_dir \s-1HEAD\s0" 4
.IX Item "output_dir HEAD"
\&\fIInstizzle method.\fR
Return tha output directory fo' tha given header.
Da default method returns \*(L".\*(R".
.IP "output_filename \s-1HEAD\s0" 4
.IX Item "output_filename HEAD"
\&\fIInstizzle method, subclasses only.\fR
A given recommended filename was either not given, or dat shiznit was judged
to be evil.  Return a gangbangin' fake name, possibly rockin shiznit up in the
message HEADer n' shit.  Note dat dis is just tha filename, not tha full path.
.Sp
Used by \fIoutput_path()\fR.
If you rockin tha default \f(CW\*(C`output_path()\*(C'\fR, you probably don't
need ta worry bout avoidin collisions wit existin files;
we take care of dat up in \fIfind_unused_path()\fR.
.IP "output_prefix [\s-1PREFIX\s0]" 4
.IX Item "output_prefix [PREFIX]"
\&\fIInstizzle method.\fR
Git tha short strang dat all filenames fo' extracted body-parts
will begin wit (assumin dat there is no betta \*(L"recommended filename\*(R").
Da default is \fI\*(L"msg\*(R"\fR.
.Sp
If \s-1PREFIX \s0\fIis not\fR given, tha current output prefix is returned.
If \s-1PREFIX \s0\fIis\fR given, tha output prefix is set ta tha freshly smoked up value,
and tha previous value is returned.
.Sp
Used by \fIoutput_filename()\fR.
.Sp
\&\fBNote:\fR subclassez of MIME::Parser::Fila which override
\&\fIoutput_path()\fR or \fIoutput_filename()\fR might not honor dis setting;
note, however, dat tha built-in subclasses honor dat shit.
.IP "output_type_ext" 4
.IX Item "output_type_ext"
\&\fIInstizzle method.\fR
Return a reference ta tha hash used by tha default
\&\fIoutput_filename()\fR fo' mappin from content-types
to extensions when there is no default extension ta use.
.Sp
.Vb 5
\&    $emap = $filer\->output_typemap;
\&    $emap\->{\*(Aqtext/plain\*(Aq} = \*(Aq.txt\*(Aq;
\&    $emap\->{\*(Aqtext/html\*(Aq}  = \*(Aq.html\*(Aq;
\&    $emap\->{\*(Aqtext/*\*(Aq}     = \*(Aq.txt\*(Aq;
\&    $emap\->{\*(Aq*/*\*(Aq}        = \*(Aq.dat\*(Aq;
.Ve
.Sp
\&\fBNote:\fR subclassez of MIME::Parser::Fila which override
\&\fIoutput_path()\fR or \fIoutput_filename()\fR might not consult dis hash;
note, however, dat tha built-in subclasses consult dat shit.
.IP "output_path \s-1HEAD\s0" 4
.IX Item "output_path HEAD"
\&\fIInstizzle method, subclasses only.\fR
Given a \s-1MIME\s0 head fo' a gangbangin' file ta be extracted, come up wit a good
output pathname fo' tha extracted file.  This is tha only method
you need ta worry bout if yo ass is buildin a cold-ass lil custom filer.
.Sp
Da default implementation do a shitload of work; subclass
implementas \fIreally\fR should try ta just override its components
instead of tha whole thang.  It works basically as bigs up:
.Sp
.Vb 1
\&    $directory = $self\->output_dir($head);
\&
\&    $filename = $head\->recommended_filename();
\&    if (!$filename or
\&         $self\->ignore_filename() or
\&         $self\->evil_filename($filename)) {
\&        $filename = $self\->output_filename($head);
\&    }
\&
\&    return $self\->find_unused_path($directory, $filename);
.Ve
.Sp
\&\fBNote:\fR There is many, many, nuff ways you might wanna control
the namin of files, based on yo' application. I aint talkin' bout chicken n' gravy biatch.  If you don't like
the behavior of dis function, you can easily define yo' own subclass
of MIME::Parser::Fila n' override it there.
.Sp
\&\fBNote:\fR Nickolay Saukh pointed up that, given tha subjectizzle nature of
what is \*(L"evil\*(R", dis function straight-up shouldn't \fIwarn\fR bout a evil
filename yo, but maybe just issue a \fIdebug\fR message.  I considered that,
but then I thought: if debuggin was off, playas wouldn't know why
(or even if) a given filename had been ignored. Y'all KNOW dat shit, muthafucka!  In mail robots
that depend on externally-provided filenames, dis could cause
hard-to-diagnose problems.  So, tha message is still a warning.
.Sp
\&\fIThanks ta Laurent Amon fo' pointin up problems wit tha original
implementation, n' fo' makin some phat suggestions.  Thanks also to
Achim Bohnet fo' pointin up dat there should be a hookless, \s-1OO\s0 way of
overridin tha output path.\fR
.IP "purge" 4
.IX Item "purge"
\&\fIInstizzle method, final.\fR
Purge all files/directories pimped by tha last parse.
This method simply goes all up in tha purgeable list up in reverse order
(see \*(L"purgeable\*(R") n' removes all existin files/directories up in dat shit.
Yo ass should not need ta override dis method.
.IP "purgeable [\s-1FILE\s0]" 4
.IX Item "purgeable [FILE]"
\&\fIInstizzle method, final.\fR
Add \s-1FILE\s0 ta tha list of \*(L"purgeable\*(R" files/directories (those which
will be removed if you do a \f(CW\*(C`purge()\*(C'\fR).
Yo ass should not need ta override dis method.
.Sp
If \s-1FILE\s0 aint given, tha \*(L"purgeable\*(R" list is returned.
This may be used fo' more-sophisticated purging.
.Sp
As a special case, invokin dis method wit a \s-1FILE\s0 dat be an
arrayref will replace tha purgeable list wit a cold-ass lil copy of the
arrayz contents, so [] may be used ta clear tha list.
.Sp
Note dat tha \*(L"purgeable\*(R" list is cleared when a parser begins a
new parse; therefore, if you wanna use \fIpurge()\fR ta do cleanup,
you \fImust\fR do so \fIbefore\fR startin a freshly smoked up parse!
.SS "MIME::Parser::FileInto"
.IX Subsection "MIME::Parser::FileInto"
This concrete subclass of MIME::Parser::Fila supports filing
into a given directory.
.IP "init \s-1DIRECTORY\s0" 4
.IX Item "init DIRECTORY"
\&\fIInstizzle method, initiallizer.\fR
Set tha directory where all filez will go.
.SS "MIME::Parser::FileUnder"
.IX Subsection "MIME::Parser::FileUnder"
This concrete subclass of MIME::Parser::Fila supports filin under
a given directory, rockin one subdirectory per message yo, but with
all message parts up in tha same directory.
.IP "init \s-1BASEDIR, OPTSHASH...\s0" 4
.IX Item "init BASEDIR, OPTSHASH..."
\&\fIInstizzle method, initiallizer.\fR
Set tha base directory which will contain tha message directories.
If used, then each parse of begins by bustin a freshly smoked up subdirectory
of \s-1BASEDIR\s0 where tha actual partz of tha message is placed.
\&\s-1OPTSHASH\s0 can contain tha following:
.RS 4
.IP "DirName" 4
.IX Item "DirName"
Explicitly set tha name of tha subdirectory which is pimped.
Da default is ta use tha time, process id, n' a sequence number,
but you might want a predictable directory.
.IP "Purge" 4
.IX Item "Purge"
Automatically purge tha contentz of tha directory (includin all
subdirectories) before each parse.  This is straight-up only needed if
usin a explicit DirName, n' is provided as a cold-ass lil convenience only.
Currently we use tha 1\-arg form of File::Path::rmtree; you should
familiarize yo ass wit tha caveats therein.
.RE
.RS 4
.Sp
Da \fIoutput_dir()\fR will return tha path ta dis message-specific directory
until tha next parse is begun, so you can do this:
.Sp
.Vb 1
\&    use File::Path;
\&
\&    $parser\->output_under("/tmp");
\&    $ent = eval { $parser\->parse_open($msg); };   ### parse
\&    if (!$ent) {         ### parse failed
\&        rmtree($parser\->output_dir);
\&        take a thugged-out dirtnap "parse failed: $@";
\&    }
\&    else {               ### parse succeeded
\&        ...do stuff...
\&    }
.Ve
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MIME::Tools, MIME::Parser
.SH "AUTHOR"
.IX Header "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
.PP
All muthafuckin rights reserved. Y'all KNOW dat shit, muthafucka!  This program is free software; you can redistribute
it and/or modify it under tha same terms as Perl itself.
