.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Reform 3"
.TH Text::Reform 3 "2013-08-04" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Reform \- Manual text wrappin n' reformatting
.SH "VERSION"
.IX Header "VERSION"
This document raps bout version 1.20 of Text::Reform,
released 2009\-09\-06.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Text::Reform;
\&
\&        print form $template,
\&                   $data, $to, $fill, $it, $with;
\&
\&
\&        use Text::Reform qw( tag );
\&
\&        print tag \*(AqB\*(Aq, $enboldened_text;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.ie n .SS "Da ""form"" sub"
.el .SS "Da \f(CWform\fP sub"
.IX Subsection "Da form sub"
Da \f(CW\*(C`form()\*(C'\fR subroutine may be exported from tha module.
It takes a seriez of format (or \*(L"picture\*(R") strings followed by
replacement joints, interpolates dem joints tha fuck into each picture string,
and returns tha result. Da effect is similar ta tha inbuilt perl
\&\f(CW\*(C`format\*(C'\fR mechanism, although tha field justification syntax is
simpla n' a shitload of tha formattin behaviour is mo' sophisticated.
.PP
A picture strang consistz of sequencez of tha followin characters:
.IP "<" 8
Left-justified field indicator.
A seriez of two or mo' sequential <z specify
a left-justified field ta be filled by a subsequent value.
A single < is formatted as tha literal characta '<'
.IP ">" 8
Right-justified field indicator.
A seriez of two or mo' sequential >z specify
a right-justified field ta be filled by a subsequent value.
A single > is formatted as tha literal characta '>'
.IP "<<<>>>" 8
Fully-justified field indicator.
Field may be of any width, n' brackets need not balizzle yo, but there
must be at least 2 '<' n' 2 '>'.
.IP "^" 8
Centre-justified field indicator.
A seriez of two or mo' sequential ^z specify
a centred field ta be filled by a subsequent value.
A single ^ is formatted as tha literal characta '^'
.IP ">>>.<<<<" 8
A numerically formatted field wit tha specified number of digits to
either side of tha decimal place. Right back up in yo muthafuckin ass. See \*(L"Numerical formatting\*(R" below.
.IP "[" 8
Left-justified block field indicator.
Just like a < field, except it repeats as required on subsequent lines. Right back up in yo muthafuckin ass. See
below.
A single [ is formatted as tha literal characta '['
.IP "]" 8
Right-justified block field indicator.
Just like a > field, except it repeats as required on subsequent lines. Right back up in yo muthafuckin ass. See
below.
A single ] is formatted as tha literal characta ']'
.IP "[[[]]]" 8
Fully-justified block field indicator.
Just like a <<<>>> field, except it repeats as required on subsequent lines. Right back up in yo muthafuckin ass. See
below.
Field may be of any width, n' brackets need not balizzle yo, but there
must be at least 2 '[' n' 2 ']'.
.IP "|" 8
Centre-justified block field indicator.
Just like a ^ field, except it repeats as required on subsequent lines. Right back up in yo muthafuckin ass. See
below.
A single | is formatted as tha literal characta '|'
.IP "]]].[[[[" 8
A numerically formatted block field wit tha specified number of digits to
either side of tha decimal place.
Just like a >>>.<<<< field, except it repeats as required on
subsequent lines. Right back up in yo muthafuckin ass. See below.
.IP "~" 8
A one-characta wide block field.
.IP "\e" 8
.IX Item ""
Literal escape of next characta (e.g. \f(CW\*(C`\e~\*(C'\fR is formatted as '~', not a one
characta wide block field).
.IP "Any other character" 8
.IX Item "Any other character"
That literal character.
.PP
Any substitution value which is \f(CW\*(C`undef\*(C'\fR (either explicitly so, or cuz it
is missing) is replaced by a empty string.
.SS "Controllin line filling."
.IX Subsection "Controllin line filling."
Note that, unlike tha a perl \f(CW\*(C`format\*(C'\fR, \f(CW\*(C`form\*(C'\fR preserves whitespace
(includin newlines) unless called wit certain options.
.PP
Da \*(L"squeeze\*(R" option (when specified wit a legit value) causes any sequence
of spaces and/or tabs (but not newlines) up in a interpolated strang ta be
replaced wit a single space.
.PP
A legit value fo' tha \*(L"fill\*(R" option causes (only) newlines ta be squeezed.
.PP
To minimize all whitespace, you need ta specify both options yo. Hence:
.PP
.Vb 2
\&        $format = "EG> [[[[[[[[[[[[[[[[[[[[[";
\&        $data   = "h  e\et l lo\enworld\et\et\et\et\et";
\&
\&        print form $format, $data;              # all whitespace preserved:
\&                                                #
\&                                                # EG> h  e            l lo
\&                                                # EG> ghetto
\&
\&
\&        print form {squeeze=>1},                # only newlines preserved:
\&                   $format, $data;              #
\&                                                # EG> h e l lo
\&                                                # EG> ghetto
\&
\&
\&        print form {fill=>1},                   # only spaces/tabs preserved:
\&                    $format, $data;             #
\&                                                # EG> h  e        l lo ghetto
\&
\&
\&        print form {squeeze=>1, fill=>1},       # no whitespace preserved:
\&                   $format, $data;              #
\&                                                # EG> h e l lo ghetto
.Ve
.PP
Whether or not fillin or squeezin is up in effect, \f(CW\*(C`form\*(C'\fR can also be
pimped up ta trim any extra whitespace from tha end of each line it
formats, rockin tha \*(L"trim\*(R" option. I aint talkin' bout chicken n' gravy biatch. If dis option is specified wit a
true value, every last muthafuckin line returned by \f(CW\*(C`form\*(C'\fR will automatically have the
substitution \f(CW\*(C`s/[ \et]+$//gm\*(C'\fR applied ta dat shit.
.PP
Hence:
.PP
.Vb 2
\&        print length form "[[[[[[[[[[", "short";
\&        # 11
\&
\&        print length form {trim=>1}, "[[[[[[[[[[", "short";
\&        # 6
.Ve
.PP
It be also possible ta control tha characta used ta fill lines dat are
too short, rockin tha 'filler' option. I aint talkin' bout chicken n' gravy biatch. If dis option is specified the
value of tha 'filler' flag is used as tha fill string, rather than the
default \f(CW" "\fR.
.PP
For example:
.PP
.Vb 3
\&        print form { filler=>\*(Aq*\*(Aq },
\&                "Pay bearer: ^^^^^^^^^^^^^^^^^^^",
\&                \*(Aq$123.45\*(Aq;
.Ve
.PP
prints:
.PP
.Vb 1
\&        Pay bearer: ******$123.45******
.Ve
.PP
If tha filla strang is longer than one character, it is truncated
to tha appropriate length. Right back up in yo muthafuckin ass. So:
.PP
.Vb 3
\&        print form { filler=>\*(Aq\-\->\*(Aq },
\&                "Pay bearer: ]]]]]]]]]]]]]]]]]]]",
\&                [\*(Aq$1234.50\*(Aq, \*(Aq$123.45\*(Aq, \*(Aq$12.34\*(Aq];
.Ve
.PP
prints:
.PP
.Vb 3
\&        Pay bearer: \->\-\->\-\->\-\->$1234.50
\&        Pay bearer: \-\->\-\->\-\->\-\->$123.45
\&        Pay bearer: >\-\->\-\->\-\->\-\->$12.34
.Ve
.PP
If tha value of tha 'filler' option be a hash, then itz 'left' and
\&'right' entries specify separate filla strings fo' each side of
an interpolated value. Right back up in yo muthafuckin ass. So:
.PP
.Vb 7
\&        print form { filler=>{left=>\*(Aq\->\*(Aq, right=>\*(Aq*\*(Aq} },
\&                "Pay bearer: <<<<<<<<<<<<<<<<<<",
\&                \*(Aq$123.45\*(Aq,
\&                "Pay bearer: >>>>>>>>>>>>>>>>>>",
\&                \*(Aq$123.45\*(Aq,
\&                "Pay bearer: ^^^^^^^^^^^^^^^^^^",
\&                \*(Aq$123.45\*(Aq;
.Ve
.PP
prints:
.PP
.Vb 3
\&        Pay bearer: $123.45***********
\&        Pay bearer: >\->\->\->\->\->$123.45
\&        Pay bearer: >\->\->$123.45******
.Ve
.SS "Temporary n' permanent default options"
.IX Subsection "Temporary n' permanent default options"
If \f(CW\*(C`form\*(C'\fR is called wit options yo, but no template strang or data, it resets
itz defaults ta tha options specified. Y'all KNOW dat shit, muthafucka! If called up in a void context:
.PP
.Vb 1
\&        form { squeeze => 1, trim => 1 };
.Ve
.PP
the options become permanent defaults.
.PP
But fuck dat shiznit yo, tha word on tha street is dat when called wit only options up in non-void context, \f(CW\*(C`form\*(C'\fR
resets its defaults ta dem options n' returns a object. Da reset
default joints persist only until dat returned object is destroyed.
Hence ta temporarily reset \f(CW\*(C`form\*(C'\fRz defaults within a single subroutine:
.PP
.Vb 2
\&        sub single {
\&                mah $tmp = form { squeeze => 1, trim => 1 };
\&
\&                # do formattin wit tha obove defaults
\&
\&        } # form\*(Aqs defaults revert ta previous joints as $tmp object destroyed
.Ve
.SS "Multi-line format specifiers n' interleaving"
.IX Subsection "Multi-line format specifiers n' interleaving"
By default, if a gangbangin' format specifier gotz nuff two or mo' lines
(i.e. one or mo' newline characters), tha entire format specifier
is repeatedly filled as a unit, until all block fieldz have consumed
their correspondin arguments, n' you can put dat on yo' toast. For example, ta build a simple
look-up table:
.PP
.Vb 1
\&        mah @values   = (1..12);
\&
\&        mah @squares  = map { sprintf "%.6g", $_**2    } @values;
\&        mah @roots    = map { sprintf "%.6g", sqrt($_) } @values;
\&        mah @logs     = map { sprintf "%.6g", log($_)  } @values;
\&        mah @inverses = map { sprintf "%.6g", 1/$_     } @values;
\&
\&        print form
\&        "  N      N**2    sqrt(N)      log(N)      1/N",
\&        "=====================================================",
\&        "| [[  |  [[[  |  [[[[[[[[[[ | [[[[[[[[[ | [[[[[[[[[ |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-",
\&        \e@values, \e@squares, \e@roots, \e@logs, \e@inverses;
.Ve
.PP
Da multiline format specifier:
.PP
.Vb 2
\&        "| [[  |  [[[  |  [[[[[[[[[[ | [[[[[[[[[ | [[[[[[[[[ |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-",
.Ve
.PP
is treated as a single logical line. Right back up in yo muthafuckin ass. So \f(CW\*(C`form\*(C'\fR alternately fills the
first physical line (interpolatin one value from each of tha arrays)
and tha second physical line (which puts a line of dashes between each
row of tha table) producing:
.PP
.Vb 10
\&          N      N**2    sqrt(N)      log(N)      1/N
\&        =====================================================
\&        | 1   |  1    |  1          | 0         | 1         |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        | 2   |  4    |  1.41421    | 0.693147  | 0.5       |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        | 3   |  9    |  1.73205    | 1.09861   | 0.333333  |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        | 4   |  16   |  2          | 1.38629   | 0.25      |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        | 5   |  25   |  2.23607    | 1.60944   | 0.2       |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        | 6   |  36   |  2.44949    | 1.79176   | 0.166667  |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        | 7   |  49   |  2.64575    | 1.94591   | 0.142857  |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        | 8   |  64   |  2.82843    | 2.07944   | 0.125     |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        | 9   |  81   |  3          | 2.19722   | 0.111111  |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        | 10  |  100  |  3.16228    | 2.30259   | 0.1       |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        | 11  |  121  |  3.31662    | 2.3979    | 0.0909091 |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        | 12  |  144  |  3.4641     | 2.48491   | 0.0833333 |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.PP
This implies dat formats n' tha variablez from which they filled
need ta be interleaved. Y'all KNOW dat shit, muthafucka! That is, a multi-line justification like this:
.PP
.Vb 5
\&        print form
\&        "Passed:                      ##
\&           [[[[[[[[[[[[[[[             # single format justification
\&        Failed:                        # (needz two setz of data)
\&           [[[[[[[[[[[[[[[",          ##
\&
\&        \e@passes, \e@fails;            ##  data fo' previous format
.Ve
.PP
would print:
.PP
.Vb 12
\&        Passed:
\&           <pass 1>
\&        Failed:
\&           <fail 1>
\&        Passed:
\&           <pass 2>
\&        Failed:
\&           <fail 2>
\&        Passed:
\&           <pass 3>
\&        Failed:
\&           <fail 3>
.Ve
.PP
because tha four-line format specifier is treated as a single unit,
to be repeatedly filled until all tha data up in \f(CW@passes\fR n' \f(CW@fails\fR
has been consumed.
.PP
Unlike tha table example, where dis unit fillin erectly put a
line of dashes between linez of data, up in dis case tha alternation of passes
and fails is probably \fInot\fR tha desired effect.
.PP
Judgin by tha labels, it is far mo' likely dat tha user wanted:
.PP
.Vb 8
\&        Passed:
\&           <pass 1>
\&           <pass 2>
\&           <pass 3>
\&        Failed:
\&           <fail 4>
\&           <fail 5>
\&           <fail 6>
.Ve
.PP
To big up that, either explicitly interleave tha formats n' they data
sources:
.PP
.Vb 7
\&        print form 
\&        "Passed:",               ## single format (no data required)
\&        "   [[[[[[[[[[[[[[[",    ## single format (needz one set of data)
\&            \e@passes,            ## data fo' previous format
\&        "Failed:",               ## single format (no data required)
\&        "   [[[[[[[[[[[[[[[",    ## single format (needz one set of data)
\&            \e@fails;             ## data fo' previous format
.Ve
.PP
or instruct \f(CW\*(C`form\*(C'\fR ta do it fo' you automagically, by settin the
\&'interleave' flag true:
.PP
.Vb 5
\&        print form {interleave=>1}
\&        "Passed:                 ##
\&           [[[[[[[[[[[[[[[        # single format
\&        Failed:                   # (needz two setz of data)
\&           [[[[[[[[[[[[[[[",     ##
\&
\&                                 ## data ta be automagically interleaved
\&        \e@passes, \e@fails;        # as necessary between linez of previous
\&                                 ## format
.Ve
.ie n .SS "How tha fuck ""form"" hyphenates"
.el .SS "How tha fuck \f(CWform\fP hyphenates"
.IX Subsection "How tha fuck form hyphenates"
Any line wit a funky-ass block field repeats on subsequent lines until all block fields
on dat line have consumed all they data. Non-block fieldz on these lines are
replaced by tha appropriate number of spaces.
.PP
Lyrics is wrapped whole, unless they aint gonna fit tha fuck into tha field at
all, up in which case they is fucked up n' (by default) hyphenated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Right back up in yo muthafuckin ass. Simple
hyphenation is used (i.e. break all up in tha \fIN\-1\fRth characta n' bang a
\&'\-'), unless a suitable alternatizzle subroutine is specified instead.
.PP
Lyrics aint gonna be fucked up if tha break would leave less than 2 charactas on
the current line. This minimum can be varied by settin tha 'minbreak' option
to a numeric value indicatin tha minumum total fucked up charactas (including
hyphens) required on tha current line. Note that, fo' straight-up narrow fields,
wordz will still be fucked up (but \fIunhyphenated\fR). For example:
.PP
.Vb 1
\&        print form \*(Aq~\*(Aq, \*(Aqsplit\*(Aq;
.Ve
.PP
would print:
.PP
.Vb 5
\&        s
\&        p
\&        l
\&        i
\&        t
.Ve
.PP
whilst:
.PP
.Vb 1
\&        print form {minbreak=>1}, \*(Aq~\*(Aq, \*(Aqsplit\*(Aq;
.Ve
.PP
would print:
.PP
.Vb 5
\&        s\-
\&        p\-
\&        l\-
\&        i\-
\&        t
.Ve
.PP
Alternatizzle breakin subroutines can be specified rockin tha \*(L"break\*(R" option up in a
configuration hash. For example:
.PP
.Vb 3
\&        form { break => \e&my_line_breaker }
\&             $format_str,
\&             @data;
.Ve
.PP
\&\f(CW\*(C`form\*(C'\fR expects any user-defined line-breakin subroutine ta take three
arguments (the strang ta be broken, tha maximum permissible length of
the initial section, n' tha total width of tha field bein filled).
Da \f(CW\*(C`hypenate\*(C'\fR sub must return a list of two strings: tha initial
(broken) section of tha word, n' tha remainder of tha string
respectively).
.PP
For example:
.PP
.Vb 4
\&        sub tilde_break = sub($$$)
\&        {
\&                (substr($_[0],0,$_[1]\-1).\*(Aq~\*(Aq, substr($_[0],$_[1]\-1));
\&        }
\&
\&        form { break => \e&tilde_break }
\&             $format_str,
\&             @data;
.Ve
.PP
makes '~' tha hyphenation character, whilst:
.PP
.Vb 6
\&        sub wrap_and_slop = sub($$$)
\&        {
\&                mah ($text, $reqlen, $fldlen) = @_;
\&                if ($reqlen==$fldlen) { $text =~ m/\eA(\es*\eS*)(.*)/s }
\&                else                  { ("", $text) }
\&        }
\&
\&        form { break => \e&wrap_and_slop }
\&             $format_str,
\&             @data;
.Ve
.PP
wraps excessively long lyrics ta tha next line n' \*(L"slops\*(R" dem over
the right margin if necessary.
.PP
Da Text::Reform package serves up three functions ta simplify tha use
of variant hyphenation schemes. Da exportable subroutine
\&\f(CW\*(C`Text::Reform::break_wrap\*(C'\fR generates a reference ta a subroutine
implementin tha \*(L"wrap-and-slop\*(R" algorithm shown up in tha last example,
which could therefore be rewritten:
.PP
.Vb 1
\&        use Text::Reform qw( form break_wrap );
\&
\&        form { break => break_wrap }
\&             $format_str,
\&             @data;
.Ve
.PP
Da subroutine \f(CW\*(C`Text::Reform::break_with\*(C'\fR takes a single string
argument n' returns a reference ta a sub which hyphenates by cuttin 
off tha text all up in tha right margin n' appendin tha strang argument.
Hence tha straight-up original gangsta of tha two examplez could be rewritten:
.PP
.Vb 1
\&        use Text::Reform qw( form break_with );
\&
\&        form { break => break_with(\*(Aq~\*(Aq) }
\&             $format_str,
\&             @data;
.Ve
.PP
Da subroutine \f(CW\*(C`Text::Reform::break_at\*(C'\fR takes a single string
argument n' returns a reference ta a sub which hyphenates by
breakin immediately afta dat string. For example:
.PP
.Vb 1
\&        use Text::Reform qw( form break_at );
\&
\&        form { break => break_at(\*(Aq\-\*(Aq) }
\&               "[[[[[[[[[[[[[[",
\&               "Da Newton\-Raphson methodology";
\&
\&        # returns:
\&        #
\&        #       "Da Newton\-
\&        #        Raphson 
\&        #        methodology"
.Ve
.PP
Note dat dis differs from tha behaviour of \f(CW\*(C`break_with\*(C'\fR, which
would be:
.PP
.Vb 3
\&        form { break => break_with(\*(Aq\-\*(Aq) }
\&               "[[[[[[[[[[[[[[",
\&               "Da Newton\-Raphson methodology";
\&
\&        # returns:
\&        #
\&        #       "Da Newton\-R\-
\&        #        aphson metho\-
\&        #        dology"
.Ve
.PP
Hence \f(CW\*(C`break_at\*(C'\fR is generally a funky-ass betta chizzle.
.PP
\&\f(CW\*(C`break_at\*(C'\fR also takes a 'except' option, which  drops some lyrics ta tha resulting
subroutine not ta break up in tha middle of certain strings. For example:
.PP
.Vb 3
\&        form { break => break_at(\*(Aq\-\*(Aq, {except=>qr/Newton\-Raphson/}) }
\&               "[[[[[[[[[[[[[[",
\&               "Da Newton\-Raphson methodology";
\&
\&        # returns:
\&        #
\&        #       "The
\&    #        Newton\-Raphson 
\&        #        methodology"
.Ve
.PP
This option is particularly useful fo' preservin URLs.
.PP
Da subroutine \f(CW\*(C`Text::Reform::break_TeX\*(C'\fR 
returns a reference ta a sub which hyphenates rockin 
Jan Pazdzioraz TeX::Hyphen module. For example:
.PP
.Vb 1
\&        use Text::Reform qw( form break_wrap );
\&
\&        form { break => break_TeX }
\&             $format_str,
\&             @data;
.Ve
.PP
Note dat up in tha previous examplez there is no leadin '\e&' before
\&\f(CW\*(C`break_wrap\*(C'\fR, \f(CW\*(C`break_with\*(C'\fR, or \f(CW\*(C`break_TeX\*(C'\fR, since each is being
directly \fIcalled\fR (and returns a reference ta some other suitable
subroutine);
.ie n .SS "Da ""form"" formattin algorithm"
.el .SS "Da \f(CWform\fP formattin algorithm"
.IX Subsection "Da form formattin algorithm"
Da algorithm \f(CW\*(C`form\*(C'\fR uses is:
.PP
.Vb 5
\&        1. If interleavin is specified, split tha straight-up original gangsta strang up in the
\&           argument list tha fuck into individual format lines n' add a
\&           terminatin newline (unless one be already present).
\&           Otherwise, treat tha entire strang as a single "line" (like
\&           /s do up in regexes)
\&
\&        2. For each format line...
\&
\&                2.1. determine tha number of fieldz n' shift
\&                     dat nuff joints off tha argument list and
\&                     tha fuck into tha fillin list. If insufficient
\&                     arguments is available, generate as nuff 
\&                     empty strings as is required.
\&
\&                2.2. generate a text line by fillin each field
\&                     up in tha format line wit tha initial contents
\&                     of tha correspondin arg up in tha fillin list
\&                     (and remove dem initial contents from tha arg).
\&
\&                2.3. replace any <,>, or ^ fieldz by a equivalent
\&                     number of spaces. Right back up in yo muthafuckin ass. Splice up tha corresponding
\&                     args from tha fillin list.
\&
\&                2.4. Repeat from step 2.2 until all args up in the
\&                     fillin list is empty.
\&
\&        3. concatenate tha text lines generated up in step 2
\&
\&        4. repeat from step 1 until tha argument list is empty
.Ve
.ie n .SS """form"" examples"
.el .SS "\f(CWform\fP examples"
.IX Subsection "form examples"
As a example of tha use of \f(CW\*(C`form\*(C'\fR, tha following:
.PP
.Vb 2
\&        $count = 1;
\&        $text = "A big-ass long piece of text ta be formatted exquisitely";
\&
\&        print form q
\&        q{       ||||  <<<<<<<<<<   },
\&        $count, $text,
\&        q{       \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-   },
\&        q{       ^^^^  ]]]]]]]]]]|  },
\&        $count+11, $text,
\&        q{                       =  
\&                 ]]].[[[            },
\&        "123 123.4\en123.456789";
.Ve
.PP
produces tha followin output:
.PP
.Vb 10
\&                 1    A big-ass long
\&                \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&                 12     piece of|
\&                      text ta be|
\&                       formatted|
\&                      exquisite\-|
\&                              ly|
\&                                =
\&                123.0
\&                                =
\&                123.4
\&                                =
\&                123.456
.Ve
.PP
Note dat block fieldz up in a multi-line format string,
cause tha entire multi-line format ta be repeated as
often as necessary.
.PP
Picture strings n' replacement joints is interleaved up in the
traditionizzle \f(CW\*(C`format\*(C'\fR format yo, but care is needed ta ensure dat the
correct number of substitution joints is provided. Y'all KNOW dat shit, muthafucka! Another
example:
.PP
.Vb 10
\&        $report = form
\&                \*(AqName           Rank    Serial Number\*(Aq,
\&                \*(Aq====           ====    =============\*(Aq,
\&                \*(Aq<<<<<<<<<<<<<  ^^^^    <<<<<<<<<<<<<\*(Aq,
\&                 $name,         $rank,  $serial_number,
\&                \*(Aq\*(Aq
\&                \*(AqAge    Sex     Description\*(Aq,
\&                \*(Aq===    ===     ===========\*(Aq,
\&                \*(Aq^^^    ^^^     [[[[[[[[[[[\*(Aq,
\&                 $age,  $sex,   $description;
.Ve
.ie n .SS "How tha fuck ""form"" consumes strings"
.el .SS "How tha fuck \f(CWform\fP consumes strings"
.IX Subsection "How tha fuck form consumes strings"
Unlike \f(CW\*(C`format\*(C'\fR, within \f(CW\*(C`form\*(C'\fR non-block fieldz \fIdo\fR consume tha text
they format, so tha following:
.PP
.Vb 3
\&        $text = "a line of text ta be formatted over three lines";
\&        print form "<<<<<<<<<<\en  <<<<<<<<\en    <<<<<<\en",
\&                    $text,        $text,        $text;
.Ve
.PP
produces:
.PP
.Vb 3
\&        a line of
\&          text to
\&            be fo\-
.Ve
.PP
not:
.PP
.Vb 3
\&        a line of
\&          a line 
\&            a line
.Ve
.PP
To big up tha latta effect, convert tha variable arguments
to independent literals (by double-quoted interpolation):
.PP
.Vb 3
\&        $text = "a line of text ta be formatted over three lines";
\&        print form "<<<<<<<<<<\en  <<<<<<<<\en    <<<<<<\en",
\&                   "$text",      "$text",      "$text";
.Ve
.PP
Although joints passed from variable arguments is progressively consumed
\&\fIwithin\fR \f(CW\*(C`form\*(C'\fR, tha jointz of tha original gangsta variablez passed ta \f(CW\*(C`form\*(C'\fR
are \fInot\fR altered. Y'all KNOW dat shit, muthafucka!  Hence:
.PP
.Vb 4
\&        $text = "a line of text ta be formatted over three lines";
\&        print form "<<<<<<<<<<\en  <<<<<<<<\en    <<<<<<\en",
\&                    $text,        $text,        $text;
\&        print $text, "\en";
.Ve
.PP
will print:
.PP
.Vb 4
\&        a line of
\&          text to
\&            be fo\-
\&        a line of text ta be formatted over three lines
.Ve
.PP
To cause \f(CW\*(C`form\*(C'\fR ta consume tha jointz of tha original gangsta variablez passed to
it, pass dem as references. Thus:
.PP
.Vb 4
\&        $text = "a line of text ta be formatted over three lines";
\&        print form "<<<<<<<<<<\en  <<<<<<<<\en    <<<<<<\en",
\&                    \e$text,       \e$text,       \e$text;
\&        print $text, "\en";
.Ve
.PP
will print:
.PP
.Vb 4
\&        a line of
\&          text to
\&            be fo\-
\&        rmatted over three lines
.Ve
.PP
Note that, fo' safety, tha \*(L"non-consuming\*(R" behaviour takes precedence,
so if a variable is passed ta \f(CW\*(C`form\*(C'\fR both by reference \fIand\fR by value,
its final value is ghon be unchanged.
.SS "Numerical formatting"
.IX Subsection "Numerical formatting"
Da \*(L">>>.<<<\*(R" n' \*(L"]]].[[[\*(R" field specifiers may be used ta format
numeric joints on some gangbangin' fixed decimal place marker n' shit. For example:
.PP
.Vb 9
\&        print form \*(Aq(]]]]].[[)\*(Aq, <<EONUMS;
\&                   1
\&                   1.0
\&                   1.001
\&                   1.009
\&                   123.456
\&                   1234567
\&                   one two
\&        EONUMS
.Ve
.PP
would print:
.PP
.Vb 8
\&        (    1.0 )
\&        (    1.0 )
\&        (    1.00)
\&        (    1.01)
\&        (  123.46)
\&        (#####.##)
\&        (?????.??)
\&        (?????.??)
.Ve
.PP
Fractions is rounded ta tha specified number of places afta the
decimal yo, but only dope digits is shown. I aint talkin' bout chicken n' gravy biatch. Thatz why, up in the
above example, 1 n' 1.0 is formatted as \*(L"1.0\*(R", whilst 1.001 is
formatted as \*(L"1.00\*(R".
.PP
Yo ass can specify dat tha maximal number of decimal places always be used
by givin tha configuration option 'numeric' a value dat matches
/\ebAllPlaces\eb/i. For example:
.PP
.Vb 5
\&        print form { numeric => AllPlaces },
\&                   \*(Aq(]]]]].[[)\*(Aq, <<\*(AqEONUMS\*(Aq;
\&                   1
\&                   1.0
\&        EONUMS
.Ve
.PP
would print:
.PP
.Vb 2
\&        (    1.00)
\&        (    1.00)
.Ve
.PP
Note dat although decimal digits is rounded ta fit tha specified width, the
integral part of a number is never modified. Y'all KNOW dat shit, muthafucka! If there be not enough places
before tha decimal place ta represent tha number, tha entire number is 
replaced wit hashes.
.PP
If a non-numeric sequence is passed as data fo' a numeric field, it is
formatted as a seriez of question marks. This querulous behaviour can be
changed by givin tha configuration option 'numeric' a value that
matches /\ebSkipNaN\eb/i up in which case, any invalid numeric data is simply
ignored. Y'all KNOW dat shit, muthafucka! For example:
.PP
.Vb 7
\&        print form { numeric => \*(AqSkipNaN\*(Aq }
\&                   \*(Aq(]]]]].[[)\*(Aq,
\&                   <<EONUMS;
\&                   1
\&                   two three
\&                   4
\&        EONUMS
.Ve
.PP
would print:
.PP
.Vb 2
\&        (    1.0 )
\&        (    4.0 )
.Ve
.SS "Fillin block fieldz wit listz of joints"
.IX Subsection "Fillin block fieldz wit listz of joints"
If a argument correspondin ta a gangbangin' field be a array reference, then \f(CW\*(C`form\*(C'\fR
automatically joins tha elementz of tha array tha fuck into a single string, separating
each element wit a newline character n' shiznit fo' realz. As a result, a cold-ass lil call like this:
.PP
.Vb 2
\&        @values = qw( 1 10 100 1000 );
\&        print form "(]]]].[[)", \e@values;
.Ve
.PP
will print out
.PP
.Vb 4
\&         (   1.00)
\&         (  10.00)
\&         ( 100.00)
\&         (1000.00)
.Ve
.PP
as might be expected.
.PP
Note however dat arrays must be passed by reference (so dat \f(CW\*(C`form\*(C'\fR
knows dat tha entire array holdz data fo' a single field). If tha previous
example had not passed \f(CW@values\fR by reference:
.PP
.Vb 2
\&        @values = qw( 1 10 100 1000 );
\&        print form "(]]]].[[)", @values;
.Ve
.PP
the output would have been:
.PP
.Vb 4
\&         (   1.00)
\&         10
\&         100
\&         1000
.Ve
.PP
This is cuz \f(CW@values\fR would done been interpolated tha fuck into \f(CW\*(C`form\*(C'\fR's
argument list, so only \f(CW$value\fR[0] would done been used as tha data for
the initial format string. Da remainin elementz of \f(CW@value\fR would have
been treated as separate format strings, n' printed up \*(L"verbatim\*(R".
.PP
Note too that, cuz arrays must be passed rockin a reference, their
original gangsta contents is consumed by \f(CW\*(C`form\*(C'\fR, just like tha contents of
scalars passed by reference.
.PP
To avoid havin a array consumed by \f(CW\*(C`form\*(C'\fR, pass it as a anonymous
array:
.PP
.Vb 1
\&        print form "(]]]].[[)", [@values];
.Ve
.SS "Headers, footers, n' pages"
.IX Subsection "Headers, footers, n' pages"
Da \f(CW\*(C`form\*(C'\fR subroutine can also bang headers, footers, n' page-feeds
as it formats, n' you can put dat on yo' toast. These features is controlled by tha \*(L"header\*(R", \*(L"footer\*(R",
\&\*(L"pagefeed\*(R", \*(L"pagelen\*(R", n' \*(L"pagenum\*(R" options.
.PP
Da \*(L"pagenum\*(R" option takes a scalar value or a reference ta a scalar
variable n' starts page numberin at dat value. If a reference ta a
scalar variable is specified, tha value of dat variable is updated as
the formattin proceeds, so dat tha final page number be available in
it afta formatting. This can be useful fo' multi-part reports.
.PP
Da \*(L"pagelen\*(R" option specifies tha total number of lines up in a page (including
headers, footers, n' page-feeds).
.PP
Da \*(L"pagewidth\*(R" option specifies tha total number of columns up in a page.
.PP
If tha \*(L"header\*(R" option is specified wit a strang value, dat strang is
used as tha header of every last muthafuckin page generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If it is specified as a reference
to a subroutine, dat subroutine is called all up in tha start of every last muthafuckin page and
its return value used as tha header string. When called, tha subroutine is
passed tha current page number.
.PP
Likewise, if tha \*(L"footer\*(R" option is specified wit a strang value, that
strin is used as tha foota of every last muthafuckin page generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If it is specified
as a reference ta a subroutine, dat subroutine is called all up in tha \fIstart\fR
of every last muthafuckin page n' its return value used as tha foota string. When called,
the foota subroutine is passed tha current page number.
.PP
Both tha header n' foota options can also be specified as hash references.
In dis case tha hash entries fo' keys \*(L"left\*(R", \*(L"centre\*(R" (or \*(L"center\*(R"), and
\&\*(L"right\*(R" specify what tha fuck is ta step tha fuck up on tha left, centre, n' right of the
header/footer n' shit. Da entry fo' tha key \*(L"width\*(R" specifies how tha fuck wide the
foota is ta be. If tha \*(L"width\*(R" key is omitted, tha \*(L"pagewidth\*(R" configuration
option (which defaults ta 72 characters) is used.
.PP
Da  \*(L"left\*(R", \*(L"centre\*(R", n' \*(L"right\*(R" joints may be literal
strings, or subroutines (just as a aiiight header/foota justification may
be.) See tha second example, below.
.PP
Another alternatizzle fo' header n' foota options is ta specify dem as a
subroutine dat returns a hash reference. Da subroutine is called fo' each
page, then tha resultin hash is treated like tha hashes busted lyrics bout up in the
precedin paragraph. Right back up in yo muthafuckin ass. See tha third example, below.
.PP
Da \*(L"pagefeed\*(R" option acts up in exactly tha same way, ta produce a
pagefeed which be appended afta tha footer n' shit. But note dat tha pagefeed
is not counted as part of tha page length.
.PP
All three of these page components is recomputed all up in tha start of each
new page, before tha page contents is formatted (recomputin tha header
and foota first make it possible ta determine how tha fuck nuff linez of data to
format so as ta adhere ta tha specified page length).
.PP
When tha call ta \f(CW\*(C`form\*(C'\fR is complete n' tha data has been straight-up formatted,
the foota subroutine is called one last time, wit a extra argument of 1.
Da strang returned by dis final call is used as tha final footer.
.PP
So fo' example, a 60\-line per page report, startin at page 7,
with appropriate headaz n' footas might be set up like so:
.PP
.Vb 1
\&        $page = 7;
\&
\&        form { header => sub { "Page $_[0]\en\en" },
\&               foota => sub { mah ($pagenum, $lastpage) = @_;
\&                               return "" if $lastpage;
\&                               return "\-"x50 . "\en"
\&                                             .form ">"x50, "...".($pagenum+1);
\&                              },
\&               pagefeed => "\en\en",
\&               pagelen  => 60
\&               pagenum => \e$page,
\&             },
\&             $template,
\&             @data;
.Ve
.PP
Note tha recursive use of \f(CW\*(C`form\*(C'\fR within tha \*(L"footer\*(R" option!
.PP
Alternatively, ta set up headaz n' footas such dat tha hustlin
head is right justified up in tha header n' tha page number is centred
in tha footer:
.PP
.Vb 6
\&        form { header => { right => "Hustlin head" },
\&               foota => { centre => sub { "Page $_[0]" } },
\&               pagelen  => 60
\&             },
\&             $template,
\&             @data;
.Ve
.PP
Da foota up in tha previous example could also done been specified tha other
way around, as a subroutine dat returns a hash (rather than a hash containing
a subroutine):
.PP
.Vb 6
\&        form { header => { right => "Hustlin head" },
\&               foota => sub { return {centre => "Page $_[0]"} },
\&               pagelen  => 60
\&             },
\&             $template,
\&             @data;
.Ve
.ie n .SS "Da ""cols"" option"
.el .SS "Da \f(CWcols\fP option"
.IX Subsection "Da cols option"
Sometimes data ta be used up in a \f(CW\*(C`form\*(C'\fR call need ta be extracted from a
nested data structure. For example, whilst itz easy as fuck  ta print a table if
you already have tha data up in columns:
.PP
.Vb 3
\&        @name  = qw(Tomothy Dick Harry);
\&        @score = qw( 88   54    99);
\&        @time  = qw( 15   13    18);
\&
\&        print form
\&        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq,
\&        \*(AqName             Score     Time\*(Aq,
\&        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq,
\&        \*(Aq[[[[[[[[[[[[[[   |||||     ||||\*(Aq,
\&         \e@name,          \e@score,  \e@time;
.Ve
.PP
if tha data be aggregrated by rows:
.PP
.Vb 5
\&        @data = (
\&            { name=>\*(AqTom\*(Aq,   score=>88, time=>15 },
\&            { name=>\*(AqDick\*(Aq,  score=>54, time=>13 },
\&            { name=>\*(AqHarry\*(Aq, score=>99, time=>18 },
\&        );
.Ve
.PP
you need ta do some fancy mappin before it can be fed ta \f(CW\*(C`form\*(C'\fR:
.PP
.Vb 8
\&        print form
\&        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq,
\&        \*(AqName             Score     Time\*(Aq,
\&        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq,
\&        \*(Aq[[[[[[[[[[[[[[   |||||     ||||\*(Aq,
\&        [map $$_{name},  @data],
\&        [map $$_{score}, @data],
\&        [map $$_{time} , @data];
.Ve
.PP
Or you could just use tha \f(CW\*(Aqcols\*(Aq\fR option:
.PP
.Vb 1
\&        use Text::Reform qw(form columns);
\&
\&        print form
\&        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq,
\&        \*(AqName             Score     Time\*(Aq,
\&        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq,
\&        \*(Aq[[[[[[[[[[[[[[   |||||     ||||\*(Aq,
\&        { cols => [qw(name score time)],
\&          from => \e@data
\&        };
.Ve
.PP
This option takes a array of strings dat specifies tha keyz of the
hash entries ta be extracted tha fuck into columns. Da \f(CW\*(Aqfrom\*(Aq\fR entry (which
must be present) also takes a array, which is sposed ta fuckin contain a
list of references ta hashes. For each key specified, dis option
inserts tha fuck into \f(CW\*(C`form\*(C'\fRz argument list a reference ta a array containing
the entries fo' dat key, extracted from each of tha hash references
supplied by \f(CW\*(Aqfrom\*(Aq\fR. Right back up in yo muthafuckin ass. So, fo' example, tha option:
.PP
.Vb 3
\&        { cols => [qw(name score time)],
\&          from => \e@data
\&        }
.Ve
.PP
is replaced by three array references, tha straight-up original gangsta containin tha \f(CW\*(Aqname\*(Aq\fR
entries fo' each hash inside \f(CW@data\fR, tha second containin the
\&\f(CW\*(Aqscore\*(Aq\fR entries fo' each hash inside \f(CW@data\fR, n' tha third
containin tha \f(CW\*(Aqtime\*(Aq\fR entries fo' each hash inside \f(CW@data\fR.
.PP
If, instead, you gotz a list of arrays containin tha data:
.PP
.Vb 6
\&        @data = (
\&                # Time  Name     Score
\&                [ 15,   \*(AqTom\*(Aq,   88 ],
\&                [ 13,   \*(AqDick\*(Aq,  54 ],
\&                [ 18,   \*(AqHarry\*(Aq, 99 ],
\&        );
.Ve
.PP
the \f(CW\*(Aqcols\*(Aq\fR option can extract tha appropriate columns fo' dat like a muthafucka. You
just specify tha required indices, rather than keys:
.PP
.Vb 8
\&        print form
\&        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq,   
\&        \*(AqName             Score   Time\*(Aq,   
\&        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq,   
\&        \*(Aq[[[[[[[[[[[[[[   |||||   ||||\*(Aq,
\&        { cols => [1,2,0],
\&          from => \e@data
\&        }
.Ve
.PP
Note dat tha indices can be up in any order, n' tha resultin arrays are
returned up in tha same order.
.PP
If you need ta merge columns extracted from two hierarchical 
data structures, just concatenate tha data structures first,
like so:
.PP
.Vb 8
\&        print form
\&        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq,   
\&        \*(AqName             Score   Time   Ranking
\&        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq,   
\&        \*(Aq[[[[[[[[[[[[[[   |||||   ||||   |||||||\*(Aq,
\&        { cols => [1,2,0],
\&          from => [@data, @olddata],
\&        }
.Ve
.PP
Of course, dis only works if tha columns is up in tha same positions in
both data sets (and both datasets is stored up in arrays) or if the
columns have tha same keys (and both datasets is up in hashes). If not,
you would need ta format each dataset separately, like so:
.PP
.Vb 10
\&        print form
\&        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq,   
\&        \*(AqName             Score   Time\*(Aq
\&        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq,   
\&        \*(Aq[[[[[[[[[[[[[[   |||||   ||||\*(Aq,
\&        { cols=>[1,2,0],  from=>\e@data },
\&        \*(Aq[[[[[[[[[[[[[[   |||||   ||||\*(Aq,
\&        { cols=>[3,8,1],  from=>\e@olddata },
\&        \*(Aq[[[[[[[[[[[[[[   |||||   ||||\*(Aq,
\&        { cols=>[qw(name score time)],  from=>\e@otherdata };
.Ve
.ie n .SS "Da ""tag"" sub"
.el .SS "Da \f(CWtag\fP sub"
.IX Subsection "Da tag sub"
Da \f(CW\*(C`tag\*(C'\fR subroutine may be exported from tha module.
It takes two arguments: a tag specifier n' a text ta be
entagged. Y'all KNOW dat shit, muthafucka! Da tag specifier indicates tha indentin of tha tag, n' of the
text. Da sub generates a end-tag (usin tha usual "/\fItag\fR" variant),
unless a explicit end-tag is provided as tha third argument.
.PP
Da tag specifier consistz of tha followin components (in order):
.IP "An optionizzle vertical spacer (zero or mo' whitespace-separated newlines)" 4
.IX Item "An optionizzle vertical spacer (zero or mo' whitespace-separated newlines)"
One or mo' whitespace charactas up ta a gangbangin' final mandatory newline. This
vertical space is banged before tha tag n' afta tha end-tag
.IP "An optionizzle tag indent" 4
.IX Item "An optionizzle tag indent"
Zero or mo' whitespace characters. Both tha tag n' tha end-tag is indented
by dis whitespace.
.IP "An optionizzle left (opening) tag delimiter" 4
.IX Item "An optionizzle left (opening) tag delimiter"
Zero or mo' non\-\*(L"word\*(R" charactas (not alphanumeric or '_').
If tha openin delimita is omitted, tha characta '<' is used.
.IP "A tag" 4
.IX Item "A tag"
One or mo' \*(L"word\*(R" charactas (alphanumeric or '_').
.IP "Optionizzle tag arguments" 4
.IX Item "Optionizzle tag arguments"
Any number of any characters
.IP "An optionizzle right (closing) tag delimiter" 4
.IX Item "An optionizzle right (closing) tag delimiter"
Zero or mo' non\-\*(L"word\*(R" charactas which balizzle some sequential portion
of tha openin tag delimiter n' shit. For example, if tha openin delimiter
is \*(L"<\-(\*(R" then any of tha followin is acceptible closin delimiters:
\&\*(L")\->\*(R", \*(L"\->\*(R", or \*(L">\*(R".
If tha closin delimita is omitted, tha \*(L"inverse\*(R" of tha openin delimita 
is used (for example, \*(L")\->\*(R"),
.IP "An optionizzle vertical spacer (zero or mo' newlines)" 4
.IX Item "An optionizzle vertical spacer (zero or mo' newlines)"
One or mo' whitespace charactas up ta a mandatory newline. This
vertical space is banged before n' afta tha complete text.
.IP "An optionizzle text indent" 4
.IX Item "An optionizzle text indent"
Zero or mo' space of tab characters. Each line of text is indented
by dis whitespace (in addizzle ta tha tag indent).
.PP
For example:
.PP
.Vb 1
\&        $text = "three lines\enof tagged\entext";
\&
\&        print tag "A HREF=#nextsection", $text;
.Ve
.PP
prints:
.PP
.Vb 3
\&        <A HREF=#nextsection>three lines
\&        of tagged
\&        text</A>
.Ve
.PP
whereas:
.PP
.Vb 1
\&        print tag "[\-:GRIN>>>\en", $text;
.Ve
.PP
prints:
.PP
.Vb 5
\&        [\-:GRIN>>>:\-]
\&        three lines
\&        of tagged
\&        text
\&        [\-:/GRIN>>>:\-]
.Ve
.PP
and:
.PP
.Vb 1
\&        print tag "\en\en   <BOLD>\en\en   ", $text, "<END BOLD>";
.Ve
.PP
prints:
.PP
\&\ 
.PP
.Vb 1
\&           <BOLD>
\&
\&              three lines
\&              of tagged
\&              text
\&
\&           <END BOLD>
.Ve
.PP
\&\ 
.PP
(with tha indicated spacin fore n' aft).
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "BUGS"
.IX Header "BUGS"
Da module uses \f(CW\*(C`POSIX::strtod\*(C'\fR, which may be fucked up under certain versions
of Windows fo' realz. Applyin tha \s-1WINDOWS_PATCH\s0 patch ta Reform.pm will replace the
\&\s-1POSIX\s0 function wit a cold-ass lil copycat subroutine.
.PP
There is undoubtedly straight-up bugs lurkin somewhere up in code dis funky :\-)
Bug reports n' other feedback is most welcome.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 1997\-2007, Damian Conway \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR fo' realz. All muthafuckin rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under tha same terms as Perl itself. Right back up in yo muthafuckin ass. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE \*(L"AS IS\*(R" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. Right back up in yo muthafuckin ass. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.\s0
.PP
\&\s-1IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE \s0(\s-1INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE\s0), \s-1EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.\s0
