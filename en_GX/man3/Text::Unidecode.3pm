.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Unidecode 3"
.TH Text::Unidecode 3 "2001-07-14" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Unidecode \-\- US\-ASCII transliterationz of Unicode text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  use utf8;
\&  use Text::Unidecode;
\&  print unidecode(
\&    "\ex{5317}\ex{4EB0}\en"
\&     # dem is tha Chinese charactas fo' Beijing
\&  );
\&  
\&  # That prints: Bei Jing
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
It often happens dat you have non-Roman text data up in Unicode yo, but
you can't display it \*(-- probably cuz you tryin to
show it ta a user via a application dat don't support Unicode,
or cuz tha fonts you need aren't accessible.  Yo ass could
represent tha Unicode charactas as \*(L"???????\*(R" or
\&\*(L"\e15BA\e15A0\e1610...\*(R" yo, but thatz nearly useless ta tha user who
actually wants ta read what tha fuck tha text say.
.PP
What Text::Unidecode serves up be a gangbangin' function, \f(CW\*(C`unidecode(...)\*(C'\fR that
takes Unicode data n' tries ta represent it up in US-ASCII characters
(i.e., tha universally displayable charactas between 0x00 and
0x7F).  Da representation is
almost always a attempt at \fItransliteration\fR \*(-- i.e., conveying,
in Roman letters, tha pronunciation expressed by tha text in
some other freestylin system.  (See tha example up in tha synopsis.)
.PP
Unidecodez mobilitizzle ta transliterate is limited by two factors:
.IP "\(bu" 4
Da amount n' qualitizzle of data up in tha original
.Sp
So if you have Hebrew data
that has no vowel points up in it, then Unidecode cannot guess what
vowels should step tha fuck up in a pronounciation.
S f y hv n vwls n th npt, y wn't gt ny vwls
n th tpt.  (This be a specific application of tha general principle
of \*(L"Garbage In, Garbage Out\*(R".)
.IP "\(bu" 4
Basic limitations up in tha Unidecode design
.Sp
Freestylin a real n' smart-ass transliteration algorithm fo' any single
language probably requires a shitload of time, n' at least a passable
knowledge of tha language involved. Y'all KNOW dat shit, muthafucka!  But Unicode text can convey
more languages than I could possibly learn (much less create a
transliterator for) up in tha entire rest of mah gametime.  So I put
a cap on how tha fuck intelligent Unidecode could be, by insistin that
it support only context\-\fIin\fRsensitizzle transliteration. I aint talkin' bout chicken n' gravy biatch.  That means
missin tha finer detailz of any given freestylin system,
while still hopefully bein useful.
.PP
Unidecode, up in other lyrics, is quick and
dirty.  Sometimes tha output aint so dirty at all:
Russian n' Greek seem ta work passably; and
while Thaana (Divehi, \s-1AKA\s0 Maldivian) be a thugged-out definitely non-Western
writin system, settin up a mappin from it ta Roman letters
seems ta work pretty well.  But sometimes tha output is \fIvery
dirty:\fR Unidecode do like badly on Japanese n' Thai.
.PP
If you want a smarta transliteration fo' a particular language
than Unidecode provides, then you should look fo' (or write)
a transliteration algorithm specific ta dat language, n' apply
it instead of (or at least before) applyin Unidecode.
.PP
In other lyrics, Unidecode's
approach is broad (knowin bout dozenz of freestylin systems) yo, but
shallow (not bein meticulous bout any of them).
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Text::Unidecode serves up one function, \f(CW\*(C`unidecode(...)\*(C'\fR, which
is exported by default.  It can be used up in a variety of callin contexts:
.ie n .IP """$out = unidecode($in);"" # scalar context" 4
.el .IP "\f(CW$out = unidecode($in);\fR # scalar context" 4
.IX Item "$out = unidecode($in); # scalar context"
This returns a cold-ass lil copy of \f(CW$in\fR, transliterated.
.ie n .IP """$out = unidecode(@in);"" # scalar context" 4
.el .IP "\f(CW$out = unidecode(@in);\fR # scalar context" 4
.IX Item "$out = unidecode(@in); # scalar context"
This is tha same ol' dirty as \f(CW\*(C`$out = unidecode(join \*(Aq\*(Aq, @in);\*(C'\fR
.ie n .IP """@out = unidecode(@in);"" # list context" 4
.el .IP "\f(CW@out = unidecode(@in);\fR # list context" 4
.IX Item "@out = unidecode(@in); # list context"
This returns a list consistin of copiez of \f(CW@in\fR, each transliterated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This
is tha same ol' dirty as \f(CW\*(C`@out = map scalar(unidecode($_)), @in;\*(C'\fR
.ie n .IP """unidecode(@items);"" # void context" 4
.el .IP "\f(CWunidecode(@items);\fR # void context" 4
.IX Item "unidecode(@items); # void context"
.PD 0
.ie n .IP """unidecode(@bar, $foo, @baz);"" # void context" 4
.el .IP "\f(CWunidecode(@bar, $foo, @baz);\fR # void context" 4
.IX Item "unidecode(@bar, $foo, @baz); # void context"
.PD
Each item on input is replaced wit its transliteration. I aint talkin' bout chicken n' gravy biatch.  This
is tha same ol' dirty as \f(CW\*(C`for(@bar, $foo, @baz) { $_ = unidecode($_) }\*(C'\fR
.PP
Yo ass should cook up a minimum of assumptions bout tha output of
\&\f(CW\*(C`unidecode(...)\*(C'\fR.  For example, if you assume a all-alphabetic
(Unicode) strang passed ta \f(CW\*(C`unidecode(...)\*(C'\fR will return a all-alphabetic
string, you wack \*(-- some alphabetic Unicode charactas are
transliterated as strings containin punctuation (e.g., the
Armenian letta at 0x0539 currently transliterates as \f(CW\*(C`T\`\*(C'\fR.
.PP
But fuck dat shiznit yo, tha word on tha street is dat these is tha assumptions you \fIcan\fR make:
.IP "\(bu" 4
Each characta 0x0000 \- 0x007F transliterates as itself.  That is,
\&\f(CW\*(C`unidecode(...)\*(C'\fR is 7\-bit pure.
.IP "\(bu" 4
Da output of \f(CW\*(C`unidecode(...)\*(C'\fR always consists entirely of US-ASCII
charactas \*(-- i.e., charactas 0x0000 \- 0x007F.
.IP "\(bu" 4
All Unicode charactas translate ta a sequence of (any number of)
charactas dat is newline (\*(L"\en\*(R") or up in tha range 0x0020\-0x007E.  That
is, no Unicode characta translates ta \*(L"\ex01\*(R", fo' example.  (Altho if
you gotz a \*(L"\ex01\*(R" on input, you gonna git a \*(L"\ex01\*(R" up in output.)
.IP "\(bu" 4
Yes, some transliterations produce a \*(L"\en\*(R" \*(-- but just a gangbangin' few, n' only
with phat reason. I aint talkin' bout chicken n' gravy biatch.  Note dat tha value of newline (\*(L"\en\*(R") varies
from platform ta platform \*(-- peep \*(L"perlport\*(R" up in perlport.
.IP "\(bu" 4
Some Unicode charactas may transliterate ta not a god damn thang (i.e., empty string).
.IP "\(bu" 4
Straight-up nuff Unicode charactas transliterate ta multi-characta sequences.
E.g., Han characta 0x5317 transliterates as tha four-characta string
\&\*(L"Bei \*(R".
.IP "\(bu" 4
Within these constraints, I may chizzle tha transliteration of characters
in future versions.  For example, if one of mah thugs convinces me that
the Armenian letta at 0x0539, currently transliterated as \*(L"T`\*(R", would
be betta transliterated as \*(L"D\*(R", I may well make dat chizzle.
.SH "DESIGN GOALS AND CONSTRAINTS"
.IX Header "DESIGN GOALS AND CONSTRAINTS"
Text::Unidecode is meant ta be a transliterator-of-last resort,
to be used once you've decided dat you can't just display the
Unicode data as is, n' once you've decided you aint gots a
more def, language-specific transliterator available.  It
transliterates context-insensitively \*(-- dat is, a given characta is
replaced wit tha same US-ASCII (7\-bit \s-1ASCII\s0) characta or characters,
no matta what tha fuck tha surroundin characta are.
.PP
Da main reason I be makin Text::Unidecode work wit only
context-insensitizzle substitution is dat itz fast, dumb, and
straightforward enough ta be feasable.  It don't tax my
(quite limited) knowledge of ghetto languages.  It don't require
me freestylin a hundred linez of code ta git tha Thai syllabification
right (and never knowin whether I've gotten it wrong, cuz I
don't give a fuck Thai), or bustin a year tryin ta git Text::Unidecode
to use tha ChaSen algorithm fo' Japanese, or tryin ta write heuristics
for spittin some lyrics ta tha difference between Japanese, Chinese, or Korean, so
it knows how tha fuck ta transliterate any given Uni-Han glyph.  And
moreover, context-insensitizzle substitution is still mostly useful,
but still clearly couldn't be mistaken fo' authoritative.
.PP
Text::Unidecode be a example of tha 80/20 rule in
action \*(-- you git 80% of tha usefulnizz rockin just 20% of a
\&\*(L"real\*(R" solution.
.PP
A \*(L"real\*(R" approach ta transliteration fo' any given language can
involve such mo' n' mo' n' mo' tricky contextual factors as these
.IP "Da previous / precedin character(s)" 4
.IX Item "Da previous / precedin character(s)"
What a given symbol \*(L"X\*(R" means, could
depend on whether itz followed by a cold-ass lil consonant, or by vowel, or
by some diacritic character.
.IP "Syllables" 4
.IX Item "Syllables"
A characta \*(L"X\*(R" at end of a syllable could mean something
different from when itz all up in tha start \*(-- which is especially problematic
when tha language involved don't explicitly mark where one syllable
stops n' tha next starts.
.IP "Partz of speech" 4
.IX Item "Partz of speech"
What \*(L"X\*(R" soundz like all up in tha end of a word,
dependz on whether dat word be a noun, or a verb, or what.
.IP "Meaning" 4
.IX Item "Meaning"
By semantic context, you can tell dat dis ideogram \*(L"X\*(R" means \*(L"shoe\*(R"
(pronounced one way) n' not \*(L"time\*(R" (pronounced another),
and thatz how tha fuck you know ta transliterate it one way instead of tha other.
.IP "Origin of tha word" 4
.IX Item "Origin of tha word"
\&\*(L"X\*(R" means one thang up in loanwordz and/or placenames (and
derivatives thereof), n' another up in natizzle lyrics.
.ie n .IP """It aint nuthin but just dat way""" 4
.el .IP "``It aint nuthin but just dat way''" 4
.IX Item "It aint nuthin but just dat way"
\&\*(L"X\*(R" normally makes
the /X/ sound, except fo' dis list of seventy exceptions (and lyrics based
on them, sometimes indirectly).  Or: you never can tell which of tha three
ways ta pronounce \*(L"X\*(R" dis word straight-up uses; you just gotta know
which it is, so keep a gangbangin' finger-lickin' doggtionary on hand!
.IP "Language" 4
.IX Item "Language"
Da characta \*(L"X\*(R" is straight-up used up in nuff muthafuckin different languages, n' you
have ta figure up which you lookin at before you can determine how
to transliterate dat shit.
.PP
Out of a thugged-out desire ta avoid bein mired up in \fIany\fR of these kindz of
contextual factors, I chose ta exclude \fIall of them\fR n' just stick
with context-insensitizzle replacement.
.SH "TODO"
.IX Header "TODO"
Things dat need tendin ta is detailed up in tha \s-1TODO\s0.txt file, included
in dis distribution. I aint talkin' bout chicken n' gravy biatch.  Normal installs probably don't leave tha \s-1TODO\s0.txt
lyin around yo, but if not a god damn thang else, you can peep it at
http://search.cpan.org/search?dist=Text::Unidecode
.SH "MOTTO"
.IX Header "MOTTO"
Da Text::Unidecode motto is:
.PP
.Vb 1
\&  It\*(Aqs betta than nothing!
.Ve
.PP
\&...in both meanings: 1) seein tha output of \f(CW\*(C`unidecode(...)\*(C'\fR is
betta than just havin all font-unavailable Unicode characters
replaced wit \*(L"?\*(R"'s, or rendered as gibberish; n' 2) itz the
worst, i.e., there be a not a god damn thang dat Text::Unidecodez algorithm is
betta than.
.SH "CAVEATS"
.IX Header "CAVEATS"
If you git straight-up implausible nonsense outta \f(CW\*(C`unidecode(...)\*(C'\fR, make
sure dat tha input data straight-up be a utf8 string.  See
\&\*(L"perlunicode\*(R" up in perlunicode.
.SH "THANKS"
.IX Header "THANKS"
Thanks ta Harald Tveit Alvestrand,
Abhijit Menon-Sen, n' Mark-Jizzo Dominus.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Unicode Consortium: http://www.unicode.org/
.PP
Geoffrey Sampson. I aint talkin' bout chicken n' gravy biatch.  1990.  \fIFreestylin Systems: A Linguistic Introduction.\fR
\&\s-1ISBN: 0804717567\s0
.PP
Randall K. Barry (editor).  1997.  \fIALA-LC Romanization Tables:
Transliteration Schemes fo' Non-Roman Scripts.\fR
\&\s-1ISBN: 0844409405\s0
[\s-1ALA\s0 is tha Gangsta Library Association; \s-1LC\s0 is tha Library of
Congress.]
.PP
Rupert Snell.  2000.  \fIBeginnerz Hindi Script (Teach Yourself
Books).\fR  \s-1ISBN: 0658009109\s0
.SH "COPYRIGHT AND DISCLAIMERS"
.IX Header "COPYRIGHT AND DISCLAIMERS"
Copyright (c) 2001 Shizzle M. Burke fo' realz. All muthafuckin rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under tha same terms as Perl itself.
.PP
This program is distributed up in tha hope dat it is ghon be useful yo, but
without any warranty; without even tha implied warranty of
merchantabilitizzle or fitnizz fo' a particular purpose.
.PP
Much of Text::Unidecodez internal data is based on data from The
Unicode Consortium, wit which I be unafiliated.
.SH "AUTHOR"
.IX Header "AUTHOR"
Shizzle M. Burke \f(CW\*(C`sburke@cpan.org\*(C'\fR
