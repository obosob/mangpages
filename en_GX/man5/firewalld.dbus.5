'\" t
.\"     Title: firewalld.dbus
.\"    Author: Thomas Woerner <twoerner@redhat.com>
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 
.\"    Manual: firewalld.dbus
.\"    Source: firewalld 0.3.13
.\"  Language: Gangsta
.\"
.TH "FIREWALLD\&.DBUS" "5" "" "firewalld 0.3.13" "firewalld.dbus"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
firewalld.dbus \- firewalld D\-Bus intercourse description
.SH "OBJECT PATHS"
.PP
This is tha basic firewalld object path structure\&. Da used intercourses is explained below in
the section called \(lqINTERFACES\(rq\&.
.sp
.if n \{\
.RS 4
.\}
.nf
/org/fedoraproject/FirewallD1
  Interfaces
    org.fedoraproject.FirewallD1
    org.fedoraproject.FirewallD1.direct
    org.fedoraproject.FirewallD1.policies
    org.fedoraproject.FirewallD1.zone
    org\&.freedesktop\&.DBus\&.Introspectable
    org\&.freedesktop\&.DBus\&.Properties

/org/fedoraproject/FirewallD1/config
  Interfaces
    org.fedoraproject.FirewallD1.config
    org.fedoraproject.FirewallD1.config.direct
    org.fedoraproject.FirewallD1.config.policies
    org\&.freedesktop\&.DBus\&.Introspectable
    org\&.freedesktop\&.DBus\&.Properties

/org/fedoraproject/FirewallD1/config/zone/i
  Interfaces
    org.fedoraproject.FirewallD1.config.zone
    org\&.freedesktop\&.DBus\&.Introspectable
    org\&.freedesktop\&.DBus\&.Properties

/org/fedoraproject/FirewallD1/config/service/i
  Interfaces:
    org.fedoraproject.FirewallD1.config.service
    org\&.freedesktop\&.DBus\&.Introspectable
    org\&.freedesktop\&.DBus\&.Properties

/org/fedoraproject/FirewallD1/config/icmptype/i
  Interfaces
    org.fedoraproject.FirewallD1.config.icmptype
    org\&.freedesktop\&.DBus\&.Introspectable
    org\&.freedesktop\&.DBus\&.Properties
    
.fi
.if n \{\
.RE
.\}
.SH "INTERFACES"
.PP
.SS "org\&.fedoraproject\&.FirewallD1"
.PP
This intercourse gotz nuff general runtime operations, like: reloading, panic mode, default unit handling, gettin skillz n' icmp types n' they settings\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMethods\fR
.RS 4
.PP
completeReload() → Nothing
.RS 4
Reload firewall straight-up, even netfilta kernel modules\&. This will most likely terminizzle actizzle connections, cuz state shiznit is lost\&. This option should only be used up in case of severe firewall problems\&. For example if there be state shiznit problems dat no connection can be established wit erect firewall rules\&.
.RE
.PP
enablePanicMode() → Nothing
.RS 4
Enable panic mode\& fo' realz. All incomin n' outgoin packets is dropped, actizzle connections will expire\&. Enable dis only if there be straight-up problems wit yo' network environment\&.
.sp
Possible errors: ALREADY_ENABLED, COMMAND_FAILED
.RE
.PP
disablePanicMode() → Nothing
.RS 4
Disable panic mode\& fo' realz. Afta disablin panic mode established connections might work again, if panic mode was enabled fo' a gangbangin' finger-lickin' dirty-ass short period of time\&.
.sp
Possible errors: NOT_ENABLED, COMMAND_FAILED
.RE
.PP
getDefaultZone() → s
.RS 4
Return default unit\&.
.RE
.PP
getIcmpTypeSettings(s: \fIicmptype\fR) → (sssas)
.RS 4
Return runtime settingz of given
\fIicmptype\fR\&. For gettin permanent settings see
org.fedoraproject.FirewallD1.config.icmptype.Methods.getSettings\&. Right back up in yo muthafuckin ass. Settings is up in format:
\fIversion\fR,
\fIname\fR,
\fIdescription\fR, array of
\fIdestinations\fR\&.
.PP
\fIversion (s)\fR: peep \fIversion\fR attribute of \fIicmptype\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.PP
\fIname (s)\fR: peep \fIshort\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.PP
\fIdescription (s)\fR: peep \fIdescription\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.PP
\fIdestinations (as)\fR: array, either empty or containin strings \*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq, peep \fIdestination\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.sp
Possible errors: INVALID_ICMPTYPE
.RE
.PP
getServiceSettings(s: \fIservice\fR) → (sssa(ss)asa{ss})
.RS 4
Return runtime settingz of given
\fIservice\fR\&. For gettin permanent settings see
org.fedoraproject.FirewallD1.config.service.Methods.getSettings\&. Right back up in yo muthafuckin ass. Settings is up in format:
\fIversion\fR,
\fIname\fR,
\fIdescription\fR, array of
\fIports\fR
(port, protocol), array of
\fImodule names\fR, doggtionary of
\fIdestinations\fR\&.
.PP
\fIversion (s)\fR: peep \fIversion\fR attribute of \fIservice\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIname (s)\fR: peep \fIshort\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIdescription (s)\fR: peep \fIdescription\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIports (a(ss))\fR: array of port n' protocol pairs\&. Right back up in yo muthafuckin ass. See \fIport\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fImodule names (as)\fR: array of kernel netfilta helpers, peep \fImodule\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIdestinations (a{ss})\fR: doggtionary of {IP crew : IP address} where \*(AqIP crew\*(Aq key can be either \*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq\&. Right back up in yo muthafuckin ass. See \fIdestination\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.sp
Possible errors: INVALID_SERVICE
.RE
.PP
getZoneSettings(s: \fIzone\fR) → (sssbsasa(ss)asba(ssss)asasas)
.RS 4
Return runtime settingz of given
\fIzone\fR\&. For gettin permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.getSettings\&. Right back up in yo muthafuckin ass. Settings is up in format:
\fIversion\fR,
\fIname\fR,
\fIdescription\fR,
\fIUNUSED\fR,
\fItarget\fR, array of
\fIskillz\fR, array of
\fIports\fR
(port, protocol), array of
\fIicmp\-blocks\fR,
\fImasquerade\fR, array of
\fIforward\-ports\fR
(port, protocol, to\-port, to\-addr), array of
\fIinterfaces\fR, array of
\fIsources\fR, array of
\fIrich rules\fR
.PP
\fIversion (s)\fR: peep \fIversion\fR attribute of \fIzone\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIname (s)\fR: peep \fIshort\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIdescription (s)\fR: peep \fIdescription\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIUNUSED (b)\fR: dis boolean value is no longer used fo' anything\&.
.RS 4
.RE
.PP
\fItarget (s)\fR: peep \fItarget\fR attribute of \fIzone\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIskillz (as)\fR: array of steez names, peep \fIservice\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIports (a(ss))\fR: array of port n' protocol pairs\&. Right back up in yo muthafuckin ass. See \fIport\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIicmp\-blocks (as)\fR: array of icmp\-blocks\&. Right back up in yo muthafuckin ass. See \fIicmp\-block\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fImasquerade (b)\fR: peep \fImasquerade\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIforward\-ports (a(ssss))\fR: array of (port, protocol, to\-port, to\-addr)\&. Right back up in yo muthafuckin ass. See \fIforward\-port\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIinterfaces (as)\fR: array of intercourses\&. Right back up in yo muthafuckin ass. See \fIinterface\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIsource addresses (as)\fR: array of source addresses\&. Right back up in yo muthafuckin ass. See \fIsource\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIrich rulez (as)\fR: array of rich\-language rules\&. Right back up in yo muthafuckin ass. See \fIrule\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.sp
Possible errors: INVALID_ZONE
.RE
.PP
listIcmpTypes() → as
.RS 4
Return array of names (s) of icmp types up in runtime configuration\&. For permanent configuration see
org.fedoraproject.FirewallD1.config.Methods.listIcmpTypes\&.
.RE
.PP
listSkillz() → as
.RS 4
Return array of steez names (s) up in runtime configuration\&. For permanent configuration see
org.fedoraproject.FirewallD1.config.Methods.listSkillz\&.
.RE
.PP
queryPanicMode() → b
.RS 4
Return legit if panic mode is enabled, false otherwise\&. In panic mode all incomin n' outgoin packets is dropped\&.
.RE
.PP
reload() → Nothing
.RS 4
Reload firewall rulez n' keep state shiznit\&. Current permanent configuration will become freshly smoked up runtime configuration, i\&.e\&. all runtime only chizzlez done until reload is lost wit reload if they aint been also up in permanent configuration\&.
.RE
.PP
setDefaultZone(s: \fIzone\fR) → Nothing
.RS 4
Set default unit fo' connections n' intercourses where no unit has been selected to
\fIzone\fR\&. Right back up in yo muthafuckin ass. Settin tha default unit chizzlez tha unit fo' tha connections or intercourses, dat is rockin tha default unit\&. This be a runtime n' permanent chizzle\&.
.sp
Possible errors: ZONE_ALREADY_SET, COMMAND_FAILED
.RE
.PP
runtimeToPermanent() → Nothing
.RS 4
Make runtime settings permanent\&. Replaces permanent settings wit runtime settings fo' units, skillz, icmptypes, direct n' policies (lockdown whitelist)\&.
.sp
Possible errors: RT_TO_PERM_FAILED
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBSignals\fR
.RS 4
.PP
DefaultZoneChanged(s: \fIzone\fR)
.RS 4
Emitted when default unit has been chizzled to
\fIzone\fR\&.
.RE
.PP
PanicModeDisabled()
.RS 4
Emitted when panic mode has been deactivated\&.
.RE
.PP
PanicModeEnabled()
.RS 4
Emitted when panic mode has been activated\&.
.RE
.PP
Reloaded()
.RS 4
Emitted when firewalld has been reloaded\& fo' realz. Also emitted fo' a cold-ass lil complete reload\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBProperties\fR
.RS 4
.PP
\fIBRIDGE\fR \- b \- (ro)
.RS 4
Indicates whether tha firewall has ethernet bridge support\&.
.RE
.PP
\fIIPv4\fR \- b \- (ro)
.RS 4
Indicates whether tha firewall has IPv4 support\&.
.RE
.PP
\fIIPv6\fR \- b \- (ro)
.RS 4
Indicates whether tha firewall has IPv6 support\&.
.RE
.PP
\fIinterface_version\fR \- s \- (ro)
.RS 4
firewalld D\-Bus intercourse version string\&.
.RE
.PP
\fIstate\fR \- s \- (ro)
.RS 4
firewalld state\&. This can be either
\fIINIT\fR
or
\fIRUNNING\fR\&. In
\fIINIT\fR
state, firewalld is startin up n' initializing\&.
.RE
.PP
\fIversion\fR \- s \- (ro)
.RS 4
firewalld version string\&.
.RE
.RE
.SS "org\&.fedoraproject\&.FirewallD1\&.direct"
.PP
This intercourse enablez mo' direct access ta tha firewall\&. Well shiiiit, it enablez runtime manipulation wit chains n' rules\&. For permanent configuration see
org.fedoraproject.FirewallD1.config.direct
interface\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMethods\fR
.RS 4
.PP
addChain(s: ipv, s: table, s: chain) → Nothing
.RS 4
Add a new
\fIchain\fR
to
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. Make shizzle there\*(Aqs no other chain wit dis name already\&. There already exist basic chains ta use wit direct methods, fo' example
\fIINPUT_direct\fR
chain\&. These chains is jumped tha fuck into before chains fo' units, i\&.e\&. every last muthafuckin rule put into
\fIINPUT_direct\fR
will be checked before rulez up in units\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.addChain\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE, ALREADY_ENABLED, COMMAND_FAILED
.RE
.PP
addPassthrough(s: ipv, as: args) → Nothing
.RS 4
Add a tracked passall up in rule wit tha arguments
\fIargs\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. Valid commandz up in args is only
\fI\-A/\-\-append\fR,
\fI\-I/\-\-insert\fR
and
\fI\-N/\-\-new\-chain\fR\&. This method is (unlike passall up in method) tracked, i\&.e\&. firewalld rethugz it\&. It\*(Aqs useful with
org.fedoraproject.FirewallD1.Methods.runtimeToPermanent
For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.addPassthrough\&.
.sp
Possible errors: INVALID_IPV, ALREADY_ENABLED, COMMAND_FAILED
.RE
.PP
addRule(s: ipv, s: table, s: chain, i: priority, as: args) → Nothing
.RS 4
Add a rule wit tha arguments
\fIargs\fR
to
\fIchain\fR
in
\fItable\fR
with
\fIpriority\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. Da prioritizzle is used ta order rules\&. Prioritizzle 0 means add rule on top of tha chain, wit a higher prioritizzle tha rule is ghon be added further down\&. Rulez wit tha same prioritizzle is on tha same level n' tha order of these rulez aint fixed n' may chizzle\&. If you wanna make shizzle dat a rule is ghon be added afta another one, bust a low prioritizzle fo' tha straight-up original gangsta n' a higher fo' tha following\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.addRule\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE, ALREADY_ENABLED, COMMAND_FAILED
.RE
.PP
getAllChains() → a(sss)
.RS 4
Git all chains added ta all tablez up in format: ipv, table, chain\&. This concerns only chains previously added with
addChain\&. Return value be a array of (\fIipv\fR,
\fItable\fR,
\fIchain\fR)\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.getAllChains\&.
.PP
\fIipv (s)\fR: either \fIipv4\fR (iptables) or \fIipv6\fR (ip6tables) or \fIeb\fR (ebtables)\&.
.RS 4
.RE
.PP
\fItable (s)\fR: one of \fIfilter\fR, \fImangle\fR, \fInat\fR, \fIraw\fR, \fIsecurity\fR
.RS 4
.RE
.PP
\fIchain (s)\fR: name of a cold-ass lil chain\&.
.RS 4
.RE
.sp
.RE
.PP
getAllPassthroughs() → a(sas)
.RS 4
Git all tracked passall up in rulez added up in all ipv types up in format: ipv, rule\&. This concerns only rulez previously added with
addPassthrough\&. Return value be a array of (\fIipv\fR, array of
\fIarguments\fR)\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.getAllPassthroughs\&.
.PP
\fIipv (s)\fR: either \fIipv4\fR (iptables) or \fIipv6\fR (ip6tables) or \fIeb\fR (ebtables)\&.
.RS 4
.RE
.PP
\fIarguments (as)\fR: array of commands, parametas n' other iptables/ip6tables/ebtablez command line options\&.
.RS 4
.RE
.sp
.RE
.PP
getPassthroughs(s: ipv) → aas
.RS 4
Git tracked passall up in rulez added up in either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only rulez previously added with
addPassthrough\&. Return value be a array of (array of
\fIarguments\fR)\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.getPassthroughs\&.
.PP
\fIarguments (as)\fR: array of commands, parametas n' other iptables/ip6tables/ebtablez command line options\&.
.RS 4
.RE
.sp
.RE
.PP
getAllRules() → a(sssias)
.RS 4
Git all rulez added ta all chains up in all tablez up in format: ipv, table, chain, priority, rule\&. This concerns only rulez previously added with
addRule\&. Return value be a array of (\fIipv\fR,
\fItable\fR,
\fIchain\fR,
\fIpriority\fR, array of
\fIarguments\fR)\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.getAllRules\&.
.PP
\fIipv (s)\fR: either \fIipv4\fR (iptables) or \fIipv6\fR (ip6tables) or \fIeb\fR (ebtables)\&.
.RS 4
.RE
.PP
\fItable (s)\fR: one of \fIfilter\fR, \fImangle\fR, \fInat\fR, \fIraw\fR, \fIsecurity\fR
.RS 4
.RE
.PP
\fIchain (s)\fR: name of a cold-ass lil chain\&.
.RS 4
.RE
.PP
\fIprioritizzle (i)\fR: used ta order rules\&.
.RS 4
.RE
.PP
\fIarguments (as)\fR: array of commands, parametas n' other iptables/ip6tables/ebtablez command line options\&.
.RS 4
.RE
.sp
.RE
.PP
getChains(s: ipv, s: table) → as
.RS 4
Return a array of chains (s) added to
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only chains previously added with
addChain\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.getChains\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE
.RE
.PP
getRules(s: ipv, s: table, s: chain) → a(ias)
.RS 4
Git all rulez added to
\fIchain\fR
in
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only rulez previously added with
addRule\&. Return value be a array of (\fIpriority\fR, array of
\fIarguments\fR)\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.getRules\&.
.PP
\fIprioritizzle (i)\fR: used ta order rules\&.
.RS 4
.RE
.PP
\fIarguments (as)\fR: array of commands, parametas n' other iptables/ip6tables/ebtablez command line options\&.
.RS 4
.RE
.sp
Possible errors: INVALID_IPV, INVALID_TABLE
.RE
.PP
queryChain(s: ipv, s: table, s: chain) → b
.RS 4
Return whether a
\fIchain\fR
exists in
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only chains previously added with
addChain\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.queryChain\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE
.RE
.PP
queryPassthrough(s: ipv, as: args) → b
.RS 4
Return whether a tracked passall up in rule wit tha arguments
\fIargs\fR
exists for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only rulez previously added with
addPassthrough\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.queryPassthrough\&.
.sp
Possible errors: INVALID_IPV
.RE
.PP
queryRule(s: ipv, s: table, s: chain, i: priority, as: args) → b
.RS 4
Return whether a rule with
\fIpriority\fR
and tha arguments
\fIargs\fR
exists in
\fIchain\fR
in
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only rulez previously added with
addRule\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.queryRule\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE
.RE
.PP
removeChain(s: ipv, s: table, s: chain) → Nothing
.RS 4
Remove a
\fIchain\fR
from
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. Only chains previously added with
addChain
can be removed dis way\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.removeChain\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE, NOT_ENABLED, COMMAND_FAILED
.RE
.PP
removeRule(s: ipv, s: table, s: chain, i: priority, as: args) → Nothing
.RS 4
Remove a rule with
\fIpriority\fR
and arguments
\fIargs\fR
from
\fIchain\fR
in
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. Only rulez previously added with
addRule
can be removed dis way\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.removeRule\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE, NOT_ENABLED, COMMAND_FAILED
.RE
.PP
removePassthrough(s: ipv, as: args) → Nothing
.RS 4
Remove a tracked passall up in rule wit arguments
\fIargs\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. Only rulez previously added with
addPassthrough
can be removed dis way\&. For permanent operation see
org.fedoraproject.FirewallD1.config.direct.Methods.removePassthrough\&.
.sp
Possible errors: INVALID_IPV, NOT_ENABLED, COMMAND_FAILED
.RE
.PP
removePassthrough() → Nothing
.RS 4
Remove all passall up in rulez previously added with
addPassthrough\&.
.RE
.PP
removeRules(s: ipv, s: table, s: chain) → Nothing
.RS 4
Remove all rulez from
\fIchain\fR
in
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only rulez previously added with
addRule\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE
.RE
.PP
passthrough(s: ipv, as: args) → s
.RS 4
Pass a cold-ass lil command all up in ta tha firewall\&.
\fIipv\fR
can be either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&.
\fIargs\fR
can be all
\fBiptables\fR,
\fBip6tables\fR
and
\fBebtables\fR
command line arguments\&.
\fIargs\fR
can be all iptables, ip6tablez n' ebtablez command line arguments\&. This command is untracked, which means dat firewalld aint able ta provide shiznit bout dis command lata on\&.
.sp
Possible errors: COMMAND_FAILED
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBSignals\fR
.RS 4
.PP
ChainAdded(s: ipv, s: table, s: chain)
.RS 4
Emitted when
\fIchain\fR
has been added into
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&.
.RE
.PP
ChainRemoved(s: ipv, s: table, s: chain)
.RS 4
Emitted when
\fIchain\fR
has been removed from
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&.
.RE
.PP
PassthroughAdded(s: ipv, as: args)
.RS 4
Emitted when a tracked passthruogh rule with
\fIargs\fR
has been added for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&.
.RE
.PP
PassthroughRemoved(s: ipv, as: args)
.RS 4
Emitted when a tracked passall up in rule with
\fIargs\fR
has been removed for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&.
.RE
.PP
RuleAdded(s: ipv, s: table, s: chain, i: priority, as: args)
.RS 4
Emitted when a rule with
\fIargs\fR
has been added to
\fIchain\fR
in
\fItable\fR
with
\fIpriority\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&.
.RE
.PP
RuleRemoved(s: ipv, s: table, s: chain, i: priority, as: args)
.RS 4
Emitted when a rule with
\fIargs\fR
has been removed from
\fIchain\fR
in
\fItable\fR
with
\fIpriority\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&.
.RE
.RE
.SS "org\&.fedoraproject\&.FirewallD1\&.policies"
.PP
Enablez firewalld ta be able ta lock down configuration chizzlez from local applications\&. Local applications or skillz is able ta chizzle tha firewall configuration if they is hustlin as root (example: libvirt)\&. With these operations administrator can lock tha firewall configuration so dat either none or only applications dat is up in tha whitelist is able ta request firewall chizzles\&. For permanent configuration see
org.fedoraproject.FirewallD1.config.policies
interface\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMethods\fR
.RS 4
.PP
addLockdownWhitelistCommand(s: command) → Nothing
.RS 4
Add
\fIcommand\fR
to whitelist\&. Right back up in yo muthafuckin ass. See
\fIcommand\fR
option in
\fBfirewalld.lockdown-whitelist\fR(5)\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.addLockdownWhitelistCommand\&.
.sp
Possible errors: ALREADY_ENABLED, INVALID_COMMAND
.RE
.PP
addLockdownWhitelistContext(s: context) → Nothing
.RS 4
Add
\fIcontext\fR
to whitelist\&. Right back up in yo muthafuckin ass. See
\fIselinux\fR
option in
\fBfirewalld.lockdown-whitelist\fR(5)\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.addLockdownWhitelistContext\&.
.sp
Possible errors: ALREADY_ENABLED, INVALID_COMMAND
.RE
.PP
addLockdownWhitelistUid(i: uid) → Nothing
.RS 4
Add user id
\fIuid\fR
to whitelist\&. Right back up in yo muthafuckin ass. See
\fIuser\fR
option in
\fBfirewalld.lockdown-whitelist\fR(5)\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.addLockdownWhitelistUid\&.
.sp
Possible errors: ALREADY_ENABLED, INVALID_COMMAND
.RE
.PP
addLockdownWhitelistUser(s: user) → Nothing
.RS 4
Add
\fIuser\fR
name ta whitelist\&. Right back up in yo muthafuckin ass. See
\fIuser\fR
option in
\fBfirewalld.lockdown-whitelist\fR(5)\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.addLockdownWhitelistUser\&.
.sp
Possible errors: ALREADY_ENABLED, INVALID_COMMAND
.RE
.PP
disableLockdown() → Nothing
.RS 4
Disable lockdown\&. This be a runtime n' permanent chizzle\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
enableLockdown() → Nothing
.RS 4
Enable lockdown\&. Be careful \- if tha callin application/user aint on lockdown whitelist when you enable lockdown you won\*(Aqt be able ta disable it again n' again n' again wit tha application, you would need ta edit firewalld\&.conf\&. This be a runtime n' permanent chizzle\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
getLockdownWhitelistCommands() → as
.RS 4
List all command lines (s) dat is on whitelist\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.getLockdownWhitelistCommands\&.
.RE
.PP
getLockdownWhitelistContexts() → as
.RS 4
List all contexts (s) dat is on whitelist\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.getLockdownWhitelistContexts\&.
.RE
.PP
getLockdownWhitelistUids() → ai
.RS 4
List all user idz (i) dat is on whitelist\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.getLockdownWhitelistUids\&.
.RE
.PP
getLockdownWhitelistUsers() → as
.RS 4
List all playas (s) dat is on whitelist\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.getLockdownWhitelistUsers\&.
.RE
.PP
queryLockdown() → b
.RS 4
Query whether lockdown is enabled\&.
.RE
.PP
queryLockdownWhitelistCommand(s: command) → b
.RS 4
Query whether
\fIcommand\fR
is on whitelist\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.queryLockdownWhitelistCommand\&.
.RE
.PP
queryLockdownWhitelistContext(s: context) → b
.RS 4
Query whether
\fIcontext\fR
is on whitelist\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.queryLockdownWhitelistContext\&.
.RE
.PP
queryLockdownWhitelistUid(i: uid) → b
.RS 4
Query whether user id
\fIuid\fR
is on whitelist\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.queryLockdownWhitelistUid\&.
.RE
.PP
queryLockdownWhitelistUser(s: user) → b
.RS 4
Query whether
\fIuser\fR
is on whitelist\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.queryLockdownWhitelistUser\&.
.RE
.PP
removeLockdownWhitelistCommand(s: command) → Nothing
.RS 4
Remove
\fIcommand\fR
from whitelist\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.removeLockdownWhitelistCommand\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
removeLockdownWhitelistContext(s: context) → Nothing
.RS 4
Remove
\fIcontext\fR
from whitelist\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.removeLockdownWhitelistContext\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
removeLockdownWhitelistUid(i: uid) → Nothing
.RS 4
Remove user id
\fIuid\fR
from whitelist\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.removeLockdownWhitelistUid\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
removeLockdownWhitelistUser(s: user) → Nothing
.RS 4
Remove
\fIuser\fR
from whitelist\&. For permanent operation see
org.fedoraproject.FirewallD1.config.policies.Methods.removeLockdownWhitelistUser\&.
.sp
Possible errors: NOT_ENABLED
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBSignals\fR
.RS 4
.PP
LockdownDisabled()
.RS 4
Emitted when lockdown has been disabled\&.
.RE
.PP
LockdownEnabled()
.RS 4
Emitted when lockdown has been enabled\&.
.RE
.PP
LockdownWhitelistCommandAdded(s: command)
.RS 4
Emitted when
\fIcommand\fR
has been added ta whitelist\&.
.RE
.PP
LockdownWhitelistCommandRemoved(s: command)
.RS 4
Emitted when
\fIcommand\fR
has been removed from whitelist\&.
.RE
.PP
LockdownWhitelistContextAdded(s: context)
.RS 4
Emitted when
\fIcontext\fR
has been added ta whitelist\&.
.RE
.PP
LockdownWhitelistContextRemoved(s: context)
.RS 4
Emitted when
\fIcontext\fR
has been removed from whitelist\&.
.RE
.PP
LockdownWhitelistUidAdded(i: uid)
.RS 4
Emitted when user id
\fIuid\fR
has been added ta whitelist\&.
.RE
.PP
LockdownWhitelistUidRemoved(i: uid)
.RS 4
Emitted when user id
\fIuid\fR
has been removed from whitelist\&.
.RE
.PP
LockdownWhitelistUserAdded(s: user)
.RS 4
Emitted when
\fIuser\fR
has been added ta whitelist\&.
.RE
.PP
LockdownWhitelistUserRemoved(s: user)
.RS 4
Emitted when
\fIuser\fR
has been removed from whitelist\&.
.RE
.RE
.SS "org\&.fedoraproject\&.FirewallD1\&.zone"
.PP
Operations up in dis intercourse allows ta get, add, remove n' query runtime unit\*(Aqs settings\&. For permanent settings see
org.fedoraproject.FirewallD1.config.zone
interface\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMethods\fR
.RS 4
.PP
addForwardPort(s: unit, s: port, s: protocol, s: toport, s: toaddr, i: timeout) → s
.RS 4
Add tha IPv4 forward port into
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. Da port can either be a single port number
\fIportid\fR
or a port range
\fIportid\fR\-\fIportid\fR\&. Da protocol can either be
\fItcp\fR
or
\fIudp\fR\&. Da destination address be a simple IP address\&. If
\fItimeout\fR
is non\-zero, tha operation is ghon be actizzle only fo' tha amount of seconds\&. For permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.addForwardPort\&.
.sp
Returns name of unit ta which tha forward port was added\&.
.sp
Possible errors: INVALID_ZONE, INVALID_PORT, MISSING_PROTOCOL, INVALID_PROTOCOL, INVALID_ADDR, INVALID_FORWARD, ALREADY_ENABLED, INVALID_COMMAND
.RE
.PP
addIcmpBlock(s: unit, s: icmp, i: timeout) → s
.RS 4
Add a ICMP block
\fIicmp\fR
into
\fIzone\fR\&. The
\fIicmp\fR
is tha one of tha icmp types firewalld supports\&. To git a listin of supported icmp types use
org.fedoraproject.FirewallD1.Methods.listIcmpTypes
If
\fIzone\fR
is empty, use default unit\&. If
\fItimeout\fR
is non\-zero, tha operation is ghon be actizzle only fo' tha amount of seconds\&. For permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.addIcmpBlock\&.
.sp
Returns name of unit ta which tha ICMP block was added\&.
.sp
Possible errors: INVALID_ZONE, INVALID_ICMPTYPE, ALREADY_ENABLED, INVALID_COMMAND
.RE
.PP
addInterface(s: unit, s: intercourse) → s
.RS 4
Bind
\fIinterface\fR
with
\fIzone\fR\&. From now on all traffic goin all up in the
\fIinterface\fR
will respect the
\fIzone\fR\*(Aqs settings\&. If
\fIzone\fR
is empty, use default unit\&. For permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.addInterface\&.
.sp
Returns name of unit ta which tha intercourse was bound\&.
.sp
Possible errors: INVALID_ZONE, INVALID_INTERFACE, ALREADY_ENABLED, INVALID_COMMAND
.RE
.PP
addMasquerade(s: unit, i: timeout) → s
.RS 4
Enable IPv4 masquerade in
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. If
\fItimeout\fR
is non\-zero, masqueradin is ghon be actizzle fo' tha amount of seconds\&. For permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.addMasquerade\&.
.sp
Returns name of unit up in which tha masquerade was enabled\&.
.sp
Possible errors: INVALID_ZONE, ALREADY_ENABLED, INVALID_COMMAND
.RE
.PP
addPort(s: unit, s: port, s: protocol, i: timeout) → s
.RS 4
Add port into
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. Da port can either be a single port number or a port range
\fIportid\fR\-\fIportid\fR\&. Da protocol can either be
\fItcp\fR
or
\fIudp\fR\&. If
\fItimeout\fR
is non\-zero, tha operation is ghon be actizzle only fo' tha amount of seconds\&. For permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.addPort\&.
.sp
Returns name of unit ta which tha port was added\&.
.sp
Possible errors: INVALID_ZONE, INVALID_PORT, MISSING_PROTOCOL, INVALID_PROTOCOL, ALREADY_ENABLED, INVALID_COMMAND
.RE
.PP
addRichRule(s: unit, s: rule, i: timeout) → s
.RS 4
Add rich language
\fIrule\fR
into
\fIzone\fR\&. For tha rich language rule syntax, please gotz a peep
\fBfirewalld.direct\fR(5)\&. If
\fIzone\fR
is empty, use default unit\&. If
\fItimeout\fR
is non\-zero, tha operation is ghon be actizzle only fo' tha amount of seconds\&. For permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.addRichRule\&.
.sp
Returns name of unit ta which tha rich language rule was added\&.
.sp
Possible errors: INVALID_ZONE, INVALID_RULE, ALREADY_ENABLED, INVALID_COMMAND
.RE
.PP
addService(s: unit, s: service, i: timeout) → s
.RS 4
Add
\fIservice\fR
into
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. If
\fItimeout\fR
is non\-zero, tha operation is ghon be actizzle only fo' tha amount of seconds\&. To git a list of supported skillz, use
org.fedoraproject.FirewallD1.Methods.listSkillz\&. For permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.addService\&.
.sp
Returns name of unit ta which tha steez was added\&.
.sp
Possible errors: INVALID_ZONE, INVALID_SERVICE, ALREADY_ENABLED, INVALID_COMMAND
.RE
.PP
addSource(s: unit, s: source) → s
.RS 4
Bind
\fIsource\fR
with
\fIzone\fR\&. From now on all traffic goin from this
\fIsource\fR
will respect the
\fIzone\fR\*(Aqs settings\& fo' realz. A source address or address range is either a IP address or a network IP address wit a mask fo' IPv4 or IPv6\&. For IPv4, tha mask can be a network mask or a plain number\&. For IPv6 tha mask be a plain number\&. Use of host names aint supported\&. If
\fIzone\fR
is empty, use default unit\&. For permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.addSource\&.
.sp
Returns name of unit ta which tha source was bound\&.
.sp
Possible errors: INVALID_ZONE, INVALID_ADDR, ALREADY_ENABLED, INVALID_COMMAND
.RE
.PP
changeZone(s: unit, s: intercourse) → s
.RS 4
This function is deprecated, use
org.fedoraproject.FirewallD1.zone.Methods.changeZoneOfInterface
instead\&.
.RE
.PP
changeZoneOfInterface(s: unit, s: intercourse) → s
.RS 4
Change a unit an
\fIinterface\fR
is bound ta to
\fIzone\fR\&. It\*(Aqs basically removeInterface(\fIinterface\fR) followed by addInterface(\fIzone\fR,
\fIinterface\fR)\&. If
\fIinterface\fR
has not been bound ta a unit before, it behaves like
addInterface\&. If
\fIzone\fR
is empty, use default unit\&.
.sp
Returns name of unit ta which tha intercourse was bound\&.
.sp
Possible errors: INVALID_ZONE, ZONE_ALREADY_SET, ZONE_CONFLICT
.RE
.PP
changeZoneOfSource(s: unit, s: source) → s
.RS 4
Change a unit an
\fIsource\fR
is bound ta to
\fIzone\fR\&. It\*(Aqs basically removeSource(\fIsource\fR) followed by addSource(\fIzone\fR,
\fIsource\fR)\&. If
\fIsource\fR
has not been bound ta a unit before, it behaves like
addSource\&. If
\fIzone\fR
is empty, use default unit\&.
.sp
Returns name of unit ta which tha source was bound\&.
.sp
Possible errors: INVALID_ZONE, ZONE_ALREADY_SET, ZONE_CONFLICT
.RE
.PP
getActiveZones() → a{sa{sas}}
.RS 4
Return doggtionary of currently actizzle units altogether wit intercourses n' sources used up in these units\& fo' realz. Actizzle units is units, dat gotz a funky-ass bindin ta a intercourse or source\&.
.sp
Return value be a gangbangin' finger-lickin' doggtionary where keys is unit names (s) n' joints is again n' again n' again dictionaries where keys is either \*(Aqinterfaces\*(Aq or \*(Aqsources\*(Aq n' joints is arrayz of intercourse names (s) or sources (s)\&.
.RE
.PP
getForwardPorts(s: unit) → aas
.RS 4
Return array of IPv4 forward ports previously added into
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For gettin permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.getForwardPorts\&.
.sp
Return value be array of 4\-tuples, where each 4\-tuple consistz of (port, protocol, to\-port, to\-addr)\&. to\-addr might be empty up in case of local forwarding\&.
.sp
Possible errors: INVALID_ZONE
.RE
.PP
getIcmpBlocks(s: unit) → as
.RS 4
Return array of ICMP type (s) blocks previously added into
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For gettin permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.getIcmpBlocks\&.
.sp
Possible errors: INVALID_ZONE
.RE
.PP
getInterfaces(s: unit) → as
.RS 4
Return array of intercourses (s) previously bound with
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For gettin permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.getInterfaces\&.
.sp
Possible errors: INVALID_ZONE
.RE
.PP
getPorts(s: unit) → aas
.RS 4
Return array of ports (2\-tuple of port n' protocol) previously enabled in
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For gettin permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.getPorts\&.
.sp
Possible errors: INVALID_ZONE
.RE
.PP
getRichRules(s: unit) → as
.RS 4
Return array of rich language rulez (s) previously added into
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For gettin permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.getRichRules\&.
.sp
Possible errors: INVALID_ZONE
.RE
.PP
getSkillz(s: unit) → as
.RS 4
Return array of skillz (s) previously enabled in
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For gettin permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.getSkillz\&.
.sp
Possible errors: INVALID_ZONE
.RE
.PP
getSources(s: unit) → as
.RS 4
Return array of sources (s) previously bound with
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For gettin permanent settings see
org.fedoraproject.FirewallD1.config.zone.Methods.getSources\&.
.sp
Possible errors: INVALID_ZONE
.RE
.PP
getZoneOfInterface(s: intercourse) → s
.RS 4
Return name (s) of unit the
\fIinterface\fR
is bound ta or empty string\&.
.RE
.PP
getZoneOfSource(s: source) → s
.RS 4
Return name (s) of unit the
\fIsource\fR
is bound ta or empty string\&.
.RE
.PP
getZones() → as
.RS 4
Return array of names (s) of predefined units known ta current runtime environment\&. For list of units known ta permanent environment see
org.fedoraproject.FirewallD1.config.Methods.listZones\&. Da lists (of units known ta runtime n' permanent environment) will contain same units up in most cases yo, but might differ fo' example if
org.fedoraproject.FirewallD1.config.Methods.addZone
has been called recently yo, but firewalld has not been reloaded since then\&.
.RE
.PP
isImmutable(s: unit) → b
.RS 4
Deprecated\&.
.RE
.PP
queryForwardPort(s: unit, s: port, s: protocol, s: toport, s: toaddr) → b
.RS 4
Return whether tha IPv4 forward port (\fIport\fR,
\fIprotocol\fR,
\fItoport\fR,
\fItoaddr\fR) has been added into
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.queryForwardPort\&.
.sp
Possible errors: INVALID_ZONE, INVALID_PORT, MISSING_PROTOCOL, INVALID_PROTOCOL, INVALID_ADDR, INVALID_FORWARD
.RE
.PP
queryIcmpBlock(s: unit, s: icmp) → b
.RS 4
Return whether a ICMP block for
\fIicmp\fR
has been added into
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.queryIcmpBlock\&.
.sp
Possible errors: INVALID_ZONE, INVALID_ICMPTYPE
.RE
.PP
queryInterface(s: unit, s: intercourse) → b
.RS 4
Query whether
\fIinterface\fR
has been bound to
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.queryInterface\&.
.sp
Possible errors: INVALID_ZONE, INVALID_INTERFACE
.RE
.PP
queryMasquerade(s: unit) → b
.RS 4
Return whether IPv4 masqueradin has been enabled in
\fIzone\fR
If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.queryMasquerade\&.
.sp
Possible errors: INVALID_ZONE
.RE
.PP
queryPort(s: unit, s: port, s: protocol) → b
.RS 4
Return whether
\fIport\fR/\fIprotocol\fR
has been added in
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.queryPort\&.
.sp
Possible errors: INVALID_ZONE, INVALID_PORT, MISSING_PROTOCOL, INVALID_PROTOCOL
.RE
.PP
queryRichRule(s: unit, s: rule) → b
.RS 4
Return whether rich rule
\fIrule\fR
has been added in
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.queryRichRule\&.
.sp
Possible errors: INVALID_ZONE, INVALID_RULE
.RE
.PP
queryService(s: unit, s: service) → b
.RS 4
Return whether
\fIservice\fR
has been added for
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.queryService\&.
.sp
Possible errors: INVALID_ZONE, INVALID_SERVICE
.RE
.PP
querySource(s: unit, s: source) → b
.RS 4
Query whether
\fIsource\fRhas been bound to
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.querySource\&.
.sp
Possible errors: INVALID_ZONE, INVALID_ADDR
.RE
.PP
removeForwardPort(s: unit, s: port, s: protocol, s: toport, s: toaddr) → s
.RS 4
Remove IPv4 forward port ((\fIport\fR,
\fIprotocol\fR,
\fItoport\fR,
\fItoaddr\fR)) from
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.removeForwardPort\&.
.sp
Returns name of unit from which tha forward port was removed\&.
.sp
Possible errors: INVALID_ZONE, INVALID_PORT, MISSING_PROTOCOL, INVALID_PROTOCOL, INVALID_ADDR, INVALID_FORWARD, NOT_ENABLED, INVALID_COMMAND
.RE
.PP
removeIcmpBlock(s: unit, s: icmp) → s
.RS 4
Remove ICMP block
\fIicmp\fR
from
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.removeIcmpBlock\&.
.sp
Returns name of unit from which tha ICMP block was removed\&.
.sp
Possible errors: INVALID_ZONE, INVALID_ICMPTYPE, NOT_ENABLED, INVALID_COMMAND
.RE
.PP
removeInterface(s: unit, s: intercourse) → s
.RS 4
Remove bindin of
\fIinterface\fR
from
\fIzone\fR\&. If
\fIzone\fR
is empty, tha intercourse is ghon be removed from unit it belongs to\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.removeInterface\&.
.sp
Returns name of unit from which the
\fIinterface\fR
was removed\&.
.sp
Possible errors: INVALID_ZONE, INVALID_INTERFACE, NOT_ENABLED, INVALID_COMMAND
.RE
.PP
removeMasquerade(s: unit) → s
.RS 4
Disable IPv4 masquerade for
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.removeMasquerade\&.
.sp
Returns name of unit fo' which tha masquerade was disabled\&.
.sp
Possible errors: INVALID_ZONE, NOT_ENABLED, INVALID_COMMAND
.RE
.PP
removePort(s: unit, s: port, s: protocol) → s
.RS 4
Remove port/protocol from
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.removePort\&.
.sp
Returns name of unit from which tha port was removed\&.
.sp
Possible errors: INVALID_ZONE, INVALID_PORT, MISSING_PROTOCOL, INVALID_PROTOCOL, NOT_ENABLED, INVALID_COMMAND
.RE
.PP
removeRichRule(s: unit, s: rule) → s
.RS 4
Remove rich language
\fIrule\fR
from
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.removeRichRule\&.
.sp
Returns name of unit from which tha rich language rule was removed\&.
.sp
Possible errors: INVALID_ZONE, INVALID_RULE, NOT_ENABLED, INVALID_COMMAND
.RE
.PP
removeService(s: unit, s: service) → s
.RS 4
Remove
\fIservice\fR
from
\fIzone\fR\&. If
\fIzone\fR
is empty, use default unit\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.removeService\&.
.sp
Returns name of unit from which tha steez was removed\&.
.sp
Possible errors: INVALID_ZONE, INVALID_SERVICE, NOT_ENABLED, INVALID_COMMAND
.RE
.PP
removeSource(s: unit, s: source) → s
.RS 4
Remove bindin of
\fIsource\fR
from
\fIzone\fR\&. If
\fIzone\fR
is empty, tha source is ghon be removed from unit it belongs to\&. For permanent operation see
org.fedoraproject.FirewallD1.config.zone.Methods.removeSource\&.
.sp
Returns name of unit from which the
\fIsource\fR
was removed\&.
.sp
Possible errors: INVALID_ZONE, INVALID_ADDR, NOT_ENABLED, INVALID_COMMAND
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBSignals\fR
.RS 4
.PP
ForwardPortAdded(s: unit, s: port, s: protocol, s: toport, s: toaddr, i: timeout)
.RS 4
Emitted when forward port has been added to
\fIzone\fR
with
\fItimeout\fR\&.
.RE
.PP
ForwardPortRemoved(s: unit, s: port, s: protocol, s: toport, s: toaddr)
.RS 4
Emitted when forward port has been removed from
\fIzone\fR\&.
.RE
.PP
IcmpBlockAdded(s: unit, s: icmp, i: timeout)
.RS 4
Emitted when ICMP block for
\fIicmp\fR
has been added to
\fIzone\fR
with
\fItimeout\fR\&.
.RE
.PP
IcmpBlockRemoved(s: unit, s: icmp)
.RS 4
Emitted when ICMP block for
\fIicmp\fR
has been removed from
\fIzone\fR\&.
.RE
.PP
InterfaceAdded(s: unit, s: intercourse)
.RS 4
Emitted when
\fIinterface\fR
has been added to
\fIzone\fR\&.
.RE
.PP
InterfaceRemoved(s: unit, s: intercourse)
.RS 4
Emitted when
\fIinterface\fR
has been removed from
\fIzone\fR\&.
.RE
.PP
MasqueradeAdded(s: unit, i: timeout)
.RS 4
Emitted when IPv4 masquerade has been enabled for
\fIzone\fR\&.
.RE
.PP
MasqueradeRemoved(s: unit)
.RS 4
Emitted when IPv4 masquerade has been disabled for
\fIzone\fR\&.
.RE
.PP
PortAdded(s: unit, s: port, s: protocol, i: timeout)
.RS 4
Emitted when
\fIport\fR/\fIprotocol\fR
has been added to
\fIzone\fR
with
\fItimeout\fR\&.
.RE
.PP
PortRemoved(s: unit, s: port, s: protocol)
.RS 4
Emitted when
\fIport\fR/\fIprotocol\fR
has been removed from
\fIzone\fR\&.
.RE
.PP
RichRuleAdded(s: unit, s: rule, i: timeout)
.RS 4
Emitted when rich language
\fIrule\fR
has been added to
\fIzone\fR
with
\fItimeout\fR\&.
.RE
.PP
RichRuleRemoved(s: unit, s: rule)
.RS 4
Emitted when rich language
\fIrule\fR
has been removed from
\fIzone\fR\&.
.RE
.PP
ServiceAdded(s: unit, s: service, i: timeout)
.RS 4
Emitted when
\fIservice\fR
has been added to
\fIzone\fR
with
\fItimeout\fR\&.
.RE
.PP
ServiceRemoved(s: unit, s: service)
.RS 4
Emitted when
\fIservice\fR
has been removed from
\fIzone\fR\&.
.RE
.PP
SourceAdded(s: unit, s: source)
.RS 4
Emitted when
\fIsource\fR
has been added to
\fIzone\fR\&.
.RE
.PP
SourceRemoved(s: unit, s: source)
.RS 4
Emitted when
\fIsource\fR
has been removed from
\fIzone\fR\&.
.RE
.PP
ZoneChanged(s: unit, s: intercourse)
.RS 4
Deprecated
.RE
.PP
ZoneOfInterfaceChanged(s: unit, s: intercourse)
.RS 4
Emitted when a unit an
\fIinterface\fR
is part of has been chizzled to
\fIzone\fR\&.
.RE
.PP
ZoneOfSourceChanged(s: unit, s: source)
.RS 4
Emitted when a unit an
\fIsource\fR
is part of has been chizzled to
\fIzone\fR\&.
.RE
.RE
.SS "org\&.fedoraproject\&.FirewallD1\&.config"
.PP
Allows ta permanently add, remove n' query units, skillz n' icmp types\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMethods\fR
.RS 4
.PP
addIcmpType(s: icmptype, (sssas): settings) → o
.RS 4
Add
\fIicmptype\fR
with given
\fIsettings\fR
into permanent configuration\&. Right back up in yo muthafuckin ass. Settings is up in format:
\fIversion\fR,
\fIname\fR,
\fIdescription\fR, array of
\fIdestinations\fR\&. Returns object path of tha freshly smoked up icmp type\&.
.PP
\fIversion (s)\fR: peep \fIversion\fR attribute of \fIicmptype\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.PP
\fIname (s)\fR: peep \fIshort\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.PP
\fIdescription (s)\fR: peep \fIdescription\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.PP
\fIdestinations (as)\fR: array, either empty or containin strings \*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq, peep \fIdestination\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.sp
Possible errors: NAME_CONFLICT, INVALID_NAME, INVALID_TYPE
.RE
.PP
addService(s: service, (sssa(ss)asa{ss}): settings) → o
.RS 4
Add
\fIservice\fR
with given
\fIsettings\fR
into permanent configuration\&. Right back up in yo muthafuckin ass. Settings is up in format:
\fIversion\fR,
\fIname\fR,
\fIdescription\fR, array of
\fIports\fR
(port, protocol), array of
\fImodule names\fR, doggtionary of
\fIdestinations\fR\&. Returns object path of tha freshly smoked up icmp type\&.
.PP
\fIversion (s)\fR: peep \fIversion\fR attribute of \fIservice\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIname (s)\fR: peep \fIshort\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIdescription (s)\fR: peep \fIdescription\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIports (a(ss))\fR: array of port n' protocol pairs\&. Right back up in yo muthafuckin ass. See \fIport\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fImodule names (as)\fR: array of kernel netfilta helpers, peep \fImodule\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIdestinations (a{ss})\fR: doggtionary of {IP crew : IP address} where \*(AqIP crew\*(Aq key can be either \*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq\&. Right back up in yo muthafuckin ass. See \fIdestination\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.sp
Possible errors: NAME_CONFLICT, INVALID_NAME, INVALID_TYPE
.RE
.PP
addZone(s: unit, (sssbsasa(ss)asba(ssss)asasas): settings) → o
.RS 4
Add
\fIzone\fR
with given
\fIsettings\fR
into permanent configuration\&. Right back up in yo muthafuckin ass. Settings is up in format:
\fIversion\fR,
\fIname\fR,
\fIdescription\fR,
\fIUNUSED\fR,
\fItarget\fR, array of
\fIskillz\fR, array of
\fIports\fR
(port, protocol), array of
\fIicmp\-blocks\fR,
\fImasquerade\fR, array of
\fIforward\-ports\fR
(port, protocol, to\-port, to\-addr), array of
\fIinterfaces\fR, array of
\fIsources\fR, array of
\fIrich rules\fR
.PP
\fIversion (s)\fR: peep \fIversion\fR attribute of \fIzone\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIname (s)\fR: peep \fIshort\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIdescription (s)\fR: peep \fIdescription\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIUNUSED (b)\fR: dis boolean value is no longer used fo' anything\&.
.RS 4
.RE
.PP
\fItarget (s)\fR: peep \fItarget\fR attribute of \fIzone\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIskillz (as)\fR: array of steez names, peep \fIservice\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIports (a(ss))\fR: array of port n' protocol pairs\&. Right back up in yo muthafuckin ass. See \fIport\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIicmp\-blocks (as)\fR: array of icmp\-blocks\&. Right back up in yo muthafuckin ass. See \fIicmp\-block\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fImasquerade (b)\fR: peep \fImasquerade\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIforward\-ports (a(ssss))\fR: array of (port, protocol, to\-port, to\-addr)\&. Right back up in yo muthafuckin ass. See \fIforward\-port\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIinterfaces (as)\fR: array of intercourses\&. Right back up in yo muthafuckin ass. See \fIinterface\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIsource addresses (as)\fR: array of source addresses\&. Right back up in yo muthafuckin ass. See \fIsource\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIrich rulez (as)\fR: array of rich\-language rules\&. Right back up in yo muthafuckin ass. See \fIrule\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.sp
Possible errors: NAME_CONFLICT, INVALID_NAME, INVALID_TYPE
.RE
.PP
getIcmpTypeByName(s: icmptype) → o
.RS 4
Return object path (permanent configuration) of
\fIicmptype\fR
with given name\&.
.sp
Possible errors: INVALID_ICMPTYPE
.RE
.PP
getServiceByName(s: service) → o
.RS 4
Return object path (permanent configuration) of
\fIservice\fR
with given name\&.
.sp
Possible errors: INVALID_SERVICE
.RE
.PP
getZoneByName(s: unit) → o
.RS 4
Return object path (permanent configuration) of
\fIzone\fR
with given name\&.
.sp
Possible errors: INVALID_ZONE
.RE
.PP
getZoneOfInterface(s: iface) → s
.RS 4
Return name of unit the
\fIiface\fR
is bound ta or empty string\&.
.RE
.PP
getZoneOfSource(s: source) → s
.RS 4
Return name of unit the
\fIsource\fR
is bound ta or empty string\&.
.RE
.PP
listIcmpTypes() → ao
.RS 4
Return array of object paths (o) of
icmp types
in permanent configuration\&. For runtime configuration see
org.fedoraproject.FirewallD1.Methods.listIcmpTypes\&.
.RE
.PP
listSkillz() → ao
.RS 4
Return array of objects paths (o) of
skillz
in permanent configuration\&. For runtime configuration see
org.fedoraproject.FirewallD1.Methods.listSkillz\&.
.RE
.PP
listZones() → ao
.RS 4
List object pathz of units known ta permanent environment\&. For list of units known ta runtime environment see
org.fedoraproject.FirewallD1.zone.Methods.getZones\&. Da lists (of units known ta runtime n' permanent environment) will contain same units up in most cases yo, but might differ fo' example if
org.fedoraproject.FirewallD1.config.Methods.addZone
has been called recently yo, but firewalld has not been reloaded since then\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBSignals\fR
.RS 4
.PP
IcmpTypeAdded(s: icmptype)
.RS 4
Emitted when
\fIicmptype\fR
has been added\&.
.RE
.PP
ServiceAdded(s: service)
.RS 4
Emitted when
\fIservice\fR
has been added\&.
.RE
.PP
ZoneAdded(s: unit)
.RS 4
Emitted when
\fIzone\fR
has been added\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBProperties\fR
.RS 4
.PP
CleanupOnExit \- s \- (rw)
.RS 4
If firewalld stops, it cleans up all firewall rules\&. Right back up in yo muthafuckin ass. Settin dis option ta no or false leaves tha current firewall rulez untouched\&.
.RE
.PP
DefaultZone \- s \- (ro)
.RS 4
Default unit fo' connections or intercourses if tha unit aint selected or specified by NetworkManager, initscripts or command line tool\&.
.RE
.PP
Lockdown \- s \- (rw)
.RS 4
If dis property is enabled, firewall chizzlez wit tha D\-Bus intercourse is ghon be limited ta applications dat is listed up in tha lockdown whitelist\&.
.RE
.PP
MinimalMark \- i \- (rw)
.RS 4
For some firewall settings nuff muthafuckin rulez is needed up in different tablez ta be able ta handle packets up in tha erect way\&. To big up dat these packets is marked rockin tha MARK target\&. With tha MinimalMark property a funky-ass block of marks can be reserved fo' private use; only marks over dis value is used\&.
.RE
.RE
.SS "org\&.fedoraproject\&.FirewallD1\&.config\&.direct"
.PP
Interface fo' permanent direct configuration, peep also
\fBfirewalld.direct\fR(5)\&. For runtime direct configuration see
org.fedoraproject.FirewallD1.direct
interface\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMethods\fR
.RS 4
.PP
getSettings() → (a(sss)a(sssias)a(sas))
.RS 4
Git settingz of permanent direct configuration up in format: array of
\fIchains\fR, array of
\fIrules\fR, array of
\fIpassthroughs\fR\&.
.PP
\fIchains (a(sss))\fR: array of (\fIipv\fR, \fItable\fR, \fIchain\fR), peep \*(Aqchain\*(Aq up in \fBfirewalld.direct\fR(5)\&.
.RS 4
.RE
\&.
                  .PP
\fIrulez (a(sssias))\fR: array of (\fIipv\fR, \fItable\fR, \fIchain\fR, \fIpriority\fR, array of \fIarguments\fR), peep \*(Aqrule\*(Aq up in \fBfirewalld.direct\fR(5)\&.
.RS 4
.RE
\&.
                  .PP
\fIpassthroughs (a(sas))\fR: array of (\fIipv\fR, array of \fIarguments\fR), peep passall up in in \fBfirewalld.direct\fR(5)\&.
.RS 4
.RE
\&.
                .sp
.RE
.PP
update((a(sss)a(sssias)a(sas)): settings) → Nothing
.RS 4
Update permanent direct configuration wit given
\fIsettings\fR\&. Right back up in yo muthafuckin ass. Settings is up in format: array of
\fIchains\fR, array of
\fIrules\fR, array of
\fIpassthroughs\fR\&.
.PP
\fIchains (a(sss))\fR: array of (\fIipv\fR, \fItable\fR, \fIchain\fR), peep \*(Aqchain\*(Aq up in \fBfirewalld.direct\fR(5)\&.
.RS 4
.RE
\&.
                  .PP
\fIrulez (a(sssias))\fR: array of (\fIipv\fR, \fItable\fR, \fIchain\fR, \fIpriority\fR, array of \fIarguments\fR), peep \*(Aqrule\*(Aq up in \fBfirewalld.direct\fR(5)\&.
.RS 4
.RE
\&.
                  .PP
\fIpassthroughs (a(sas))\fR: array of (\fIipv\fR, array of \fIarguments\fR), peep passall up in in \fBfirewalld.direct\fR(5)\&.
.RS 4
.RE
\&.
                .sp
Possible errors: INVALID_TYPE
.RE
.PP
addChain(s: ipv, s: table, s: chain) → Nothing
.RS 4
Add a new
\fIchain\fR
to
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. Make shizzle there\*(Aqs no other chain wit dis name already\&. There already exist basic chains ta use wit direct methods, fo' example
\fIINPUT_direct\fR
chain\&. These chains is jumped tha fuck into before chains fo' units, i\&.e\&. every last muthafuckin rule put into
\fIINPUT_direct\fR
will be checked before rulez up in units\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.addChain\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE, ALREADY_ENABLED
.RE
.PP
addPassthrough(s: ipv, as: args) → Nothing
.RS 4
Add a passall up in rule wit tha arguments
\fIargs\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.addPassthrough\&.
.sp
Possible errors: INVALID_IPV, ALREADY_ENABLED
.RE
.PP
addRule(s: ipv, s: table, s: chain, i: priority, as: args) → Nothing
.RS 4
Add a rule wit tha arguments
\fIargs\fR
to
\fIchain\fR
in
\fItable\fR
with
\fIpriority\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. Da prioritizzle is used ta order rules\&. Prioritizzle 0 means add rule on top of tha chain, wit a higher prioritizzle tha rule is ghon be added further down\&. Rulez wit tha same prioritizzle is on tha same level n' tha order of these rulez aint fixed n' may chizzle\&. If you wanna make shizzle dat a rule is ghon be added afta another one, bust a low prioritizzle fo' tha straight-up original gangsta n' a higher fo' tha following\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.addRule\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE, ALREADY_ENABLED
.RE
.PP
getAllChains() → a(sss)
.RS 4
Git all chains added ta all tablez up in format: ipv, table, chain\&. This concerns only chains previously added with
addChain\&. Return value be a array of (\fIipv\fR,
\fItable\fR,
\fIchain\fR)\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.getAllChains\&.
.PP
\fIipv (s)\fR: either \fIipv4\fR (iptables) or \fIipv6\fR (ip6tables) or \fIeb\fR (ebtables)\&.
.RS 4
.RE
.PP
\fItable (s)\fR: one of \fIfilter\fR, \fImangle\fR, \fInat\fR, \fIraw\fR, \fIsecurity\fR
.RS 4
.RE
.PP
\fIchain (s)\fR: name of a cold-ass lil chain\&.
.RS 4
.RE
.sp
.RE
.PP
getAllPassthroughs() → a(sas)
.RS 4
Git all passall up in rulez added up in all ipv types up in format: ipv, rule\&. This concerns only rulez previously added with
addPassthrough\&. Return value be a array of (\fIipv\fR, array of
\fIarguments\fR)\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.getAllPassthroughs\&.
.PP
\fIipv (s)\fR: either \fIipv4\fR (iptables) or \fIipv6\fR (ip6tables) or \fIeb\fR (ebtables)\&.
.RS 4
.RE
.PP
\fIarguments (as)\fR: array of commands, parametas n' other iptables/ip6tables/ebtablez command line options\&.
.RS 4
.RE
.sp
.RE
.PP
getPassthroughs(s: ipv) → aas
.RS 4
Git tracked passall up in rulez added up in either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only rulez previously added with
addPassthrough\&. Return value be a array of (array of
\fIarguments\fR)\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.getPassthroughs\&.
.PP
\fIarguments (as)\fR: array of commands, parametas n' other iptables/ip6tables/ebtablez command line options\&.
.RS 4
.RE
.sp
.RE
.PP
getAllRules() → a(sssias)
.RS 4
Git all rulez added ta all chains up in all tablez up in format: ipv, table, chain, priority, rule\&. This concerns only rulez previously added with
addRule\&. Return value be a array of (\fIipv\fR,
\fItable\fR,
\fIchain\fR,
\fIpriority\fR, array of
\fIarguments\fR)\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.getAllRules\&.
.PP
\fIipv (s)\fR: either \fIipv4\fR (iptables) or \fIipv6\fR (ip6tables) or \fIeb\fR (ebtables)\&.
.RS 4
.RE
.PP
\fItable (s)\fR: one of \fIfilter\fR, \fImangle\fR, \fInat\fR, \fIraw\fR, \fIsecurity\fR
.RS 4
.RE
.PP
\fIchain (s)\fR: name of a cold-ass lil chain\&.
.RS 4
.RE
.PP
\fIprioritizzle (i)\fR: used ta order rules\&.
.RS 4
.RE
.PP
\fIarguments (as)\fR: array of commands, parametas n' other iptables/ip6tables/ebtablez command line options\&.
.RS 4
.RE
.sp
.RE
.PP
getChains(s: ipv, s: table) → as
.RS 4
Return a array of chains (s) added to
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only chains previously added with
addChain\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.getChains\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE
.RE
.PP
getRules(s: ipv, s: table, s: chain) → a(ias)
.RS 4
Git all rulez added to
\fIchain\fR
in
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only rulez previously added with
addRule\&. Return value be a array of (\fIpriority\fR, array of
\fIarguments\fR)\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.getRules\&.
.PP
\fIprioritizzle (i)\fR: used ta order rules\&.
.RS 4
.RE
.PP
\fIarguments (as)\fR: array of commands, parametas n' other iptables/ip6tables/ebtablez command line options\&.
.RS 4
.RE
.sp
Possible errors: INVALID_IPV, INVALID_TABLE
.RE
.PP
queryChain(s: ipv, s: table, s: chain) → b
.RS 4
Return whether a
\fIchain\fR
exists in
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only chains previously added with
addChain\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.queryChain\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE
.RE
.PP
queryPassthrough(s: ipv, as: args) → b
.RS 4
Return whether a tracked passall up in rule wit tha arguments
\fIargs\fR
exists for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only rulez previously added with
addPassthrough\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.queryPassthrough\&.
.sp
Possible errors: INVALID_IPV
.RE
.PP
queryRule(s: ipv, s: table, s: chain, i: priority, as: args) → b
.RS 4
Return whether a rule with
\fIpriority\fR
and tha arguments
\fIargs\fR
exists in
\fIchain\fR
in
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only rulez previously added with
addRule\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.queryRule\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE
.RE
.PP
removeChain(s: ipv, s: table, s: chain) → Nothing
.RS 4
Remove a
\fIchain\fR
from
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. Only chains previously added with
addChain
can be removed dis way\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.removeChain\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE, NOT_ENABLED
.RE
.PP
removeRule(s: ipv, s: table, s: chain, i: priority, as: args) → Nothing
.RS 4
Remove a rule with
\fIpriority\fR
and arguments
\fIargs\fR
from
\fIchain\fR
in
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. Only rulez previously added with
addRule
can be removed dis way\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.removeRule\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE, NOT_ENABLED
.RE
.PP
removePassthrough(s: ipv, as: args) → Nothing
.RS 4
Remove a passall up in rule wit arguments
\fIargs\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. Only rulez previously added with
addPassthrough
can be removed dis way\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.removePassthrough\&.
.sp
Possible errors: INVALID_IPV, NOT_ENABLED
.RE
.PP
removeRules(s: ipv, s: table, s: chain) → Nothing
.RS 4
Remove all rulez from
\fIchain\fR
in
\fItable\fR
for
\fIipv\fR
bein either
\fIipv4\fR
(iptables) or
\fIipv6\fR
(ip6tables) or
\fIeb\fR
(ebtables)\&. This concerns only rulez previously added with
addRule\&. For runtime operation see
org.fedoraproject.FirewallD1.direct.Methods.removeRules\&.
.sp
Possible errors: INVALID_IPV, INVALID_TABLE
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBSignals\fR
.RS 4
.PP
Updated()
.RS 4
Emitted when configuration has been updated\&.
.RE
.RE
.SS "org\&.fedoraproject\&.FirewallD1\&.config\&.policies"
.PP
Interface fo' permanent lockdown\-whitelist configuration, peep also
\fBfirewalld.lockdown-whitelist\fR(5)\&. For runtime configuration see
org.fedoraproject.FirewallD1.policies
interface\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMethods\fR
.RS 4
.PP
getLockdownWhitelist() → (asasasai)
.RS 4
Git settingz of permanent lockdown\-whitelist configuration up in format:
\fIcommands\fR,
\fIselinux contexts\fR,
\fIusers\fR,
\fIuids\fR
.PP
\fIcommandz (as)\fR: peep \fIcommand\fR option up in \fBfirewalld.lockdown-whitelist\fR(5)\&.
.RS 4
.RE
.PP
\fIselinux contexts (as)\fR: peep \fIselinux\fR option up in \fBfirewalld.lockdown-whitelist\fR(5)\&.
.RS 4
.RE
.PP
\fIusers (as)\fR: peep \fIname\fR attribute of \fIuser\fR option up in \fBfirewalld.lockdown-whitelist\fR(5)\&.
.RS 4
.RE
.PP
\fIuidz (ai)\fR: peep \fIid\fR attribute of \fIuser\fR option up in \fBfirewalld.lockdown-whitelist\fR(5)\&.
.RS 4
.RE
.sp
.RE
.PP
setLockdownWhitelist((asasasai): settings) → Nothing
.RS 4
Set permanent lockdown\-whitelist configuration to
\fIsettings\fR\&. Right back up in yo muthafuckin ass. Settings is up in format:
\fIcommands\fR,
\fIselinux contexts\fR,
\fIusers\fR,
\fIuids\fR
.PP
\fIcommandz (as)\fR: peep \fIcommand\fR option up in \fBfirewalld.lockdown-whitelist\fR(5)\&.
.RS 4
.RE
.PP
\fIselinux contexts (as)\fR: peep \fIselinux\fR option up in \fBfirewalld.lockdown-whitelist\fR(5)\&.
.RS 4
.RE
.PP
\fIusers (as)\fR: peep \fIname\fR attribute of \fIuser\fR option up in \fBfirewalld.lockdown-whitelist\fR(5)\&.
.RS 4
.RE
.PP
\fIuidz (ai)\fR: peep \fIid\fR attribute of \fIuser\fR option up in \fBfirewalld.lockdown-whitelist\fR(5)\&.
.RS 4
.RE
.sp
Possible errors: INVALID_TYPE
.RE
.PP
addLockdownWhitelistCommand(s: command) → Nothing
.RS 4
Add
\fIcommand\fR
to whitelist\&. Right back up in yo muthafuckin ass. See
\fIcommand\fR
option in
\fBfirewalld.lockdown-whitelist\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.addLockdownWhitelistCommand\&.
.sp
Possible errors: ALREADY_ENABLED, INVALID_TYPE
.RE
.PP
addLockdownWhitelistContext(s: context) → Nothing
.RS 4
Add
\fIcontext\fR
to whitelist\&. Right back up in yo muthafuckin ass. See
\fIselinux\fR
option in
\fBfirewalld.lockdown-whitelist\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.addLockdownWhitelistContext\&.
.sp
Possible errors: ALREADY_ENABLED, INVALID_TYPE
.RE
.PP
addLockdownWhitelistUid(i: uid) → Nothing
.RS 4
Add user id
\fIuid\fR
to whitelist\&. Right back up in yo muthafuckin ass. See
\fIuser\fR
option in
\fBfirewalld.lockdown-whitelist\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.addLockdownWhitelistUid\&.
.sp
Possible errors: ALREADY_ENABLED, INVALID_TYPE
.RE
.PP
addLockdownWhitelistUser(s: user) → Nothing
.RS 4
Add
\fIuser\fR
name ta whitelist\&. Right back up in yo muthafuckin ass. See
\fIuser\fR
option in
\fBfirewalld.lockdown-whitelist\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.addLockdownWhitelistUser\&.
.sp
Possible errors: ALREADY_ENABLED, INVALID_TYPE
.RE
.PP
getLockdownWhitelistCommands() → as
.RS 4
List all command lines (s) dat is on whitelist\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.getLockdownWhitelistCommands\&.
.RE
.PP
getLockdownWhitelistContexts() → as
.RS 4
List all contexts (s) dat is on whitelist\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.getLockdownWhitelistContexts\&.
.RE
.PP
getLockdownWhitelistUids() → ai
.RS 4
List all user idz (i) dat is on whitelist\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.getLockdownWhitelistUids\&.
.RE
.PP
getLockdownWhitelistUsers() → as
.RS 4
List all playas (s) dat is on whitelist\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.getLockdownWhitelistUsers\&.
.RE
.PP
queryLockdownWhitelistCommand(s: command) → b
.RS 4
Query whether
\fIcommand\fR
is on whitelist\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.queryLockdownWhitelistCommand\&.
.RE
.PP
queryLockdownWhitelistContext(s: context) → b
.RS 4
Query whether
\fIcontext\fR
is on whitelist\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.queryLockdownWhitelistContext\&.
.RE
.PP
queryLockdownWhitelistUid(i: uid) → b
.RS 4
Query whether user id
\fIuid\fR
is on whitelist\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.queryLockdownWhitelistUid\&.
.RE
.PP
queryLockdownWhitelistUser(s: user) → b
.RS 4
Query whether
\fIuser\fR
is on whitelist\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.queryLockdownWhitelistUser\&.
.RE
.PP
removeLockdownWhitelistCommand(s: command) → Nothing
.RS 4
Remove
\fIcommand\fR
from whitelist\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.removeLockdownWhitelistCommand\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
removeLockdownWhitelistContext(s: context) → Nothing
.RS 4
Remove
\fIcontext\fR
from whitelist\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.removeLockdownWhitelistContext\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
removeLockdownWhitelistUid(i: uid) → Nothing
.RS 4
Remove user id
\fIuid\fR
from whitelist\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.removeLockdownWhitelistUid\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
removeLockdownWhitelistUser(s: user) → Nothing
.RS 4
Remove
\fIuser\fR
from whitelist\&. For runtime operation see
org.fedoraproject.FirewallD1.policies.Methods.removeLockdownWhitelistUser\&.
.sp
Possible errors: NOT_ENABLED
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBSignals\fR
.RS 4
.PP
LockdownWhitelistUpdated()
.RS 4
Emitted when permanent lockdown\-whitelist configuration has been updated\&.
.RE
.RE
.SS "org\&.fedoraproject\&.FirewallD1\&.config\&.zone"
.PP
Interface fo' permanent unit configuration, peep also
\fBfirewalld.zone\fR(5)\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMethods\fR
.RS 4
.PP
getSettings() → (sssbsasa(ss)asba(ssss)asasas)
.RS 4
Return permanent settingz of given
\fIzone\fR\&. For gettin runtime settings see
org.fedoraproject.FirewallD1.Methods.getZoneSettings\&. Right back up in yo muthafuckin ass. Settings is up in format:
\fIversion\fR,
\fIname\fR,
\fIdescription\fR,
\fIUNUSED\fR,
\fItarget\fR, array of
\fIskillz\fR, array of
\fIports\fR
(port, protocol), array of
\fIicmp\-blocks\fR,
\fImasquerade\fR, array of
\fIforward\-ports\fR
(port, protocol, to\-port, to\-addr), array of
\fIinterfaces\fR, array of
\fIsources\fR, array of
\fIrich rules\fR
.PP
\fIversion (s)\fR: peep \fIversion\fR attribute of \fIzone\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIname (s)\fR: peep \fIshort\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIdescription (s)\fR: peep \fIdescription\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIUNUSED (b)\fR: dis boolean value is no longer used fo' anything\&.
.RS 4
.RE
.PP
\fItarget (s)\fR: peep \fItarget\fR attribute of \fIzone\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIskillz (as)\fR: array of steez names, peep \fIservice\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIports (a(ss))\fR: array of port n' protocol pairs\&. Right back up in yo muthafuckin ass. See \fIport\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIicmp\-blocks (as)\fR: array of icmp\-blocks\&. Right back up in yo muthafuckin ass. See \fIicmp\-block\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fImasquerade (b)\fR: peep \fImasquerade\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIforward\-ports (a(ssss))\fR: array of (port, protocol, to\-port, to\-addr)\&. Right back up in yo muthafuckin ass. See \fIforward\-port\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIinterfaces (as)\fR: array of intercourses\&. Right back up in yo muthafuckin ass. See \fIinterface\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIsource addresses (as)\fR: array of source addresses\&. Right back up in yo muthafuckin ass. See \fIsource\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIrich rulez (as)\fR: array of rich\-language rules\&. Right back up in yo muthafuckin ass. See \fIrule\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.sp
.RE
.PP
loadDefaults() → Nothing
.RS 4
Load default settings fo' built\-in unit\&.
.sp
Possible errors: NO_DEFAULTS
.RE
.PP
remove() → Nothing
.RS 4
Remove not built\-in unit\&.
.sp
Possible errors: BUILTIN_ZONE
.RE
.PP
rename(s: name) → Nothing
.RS 4
Rename not built\-in unit to
\fIname\fR\&.
.sp
Possible errors: BUILTIN_ZONE
.RE
.PP
update((sssbsasa(ss)asba(ssss)asasas): settings) → Nothing
.RS 4
Update settingz of unit to
\fIsettings\fR\&. Right back up in yo muthafuckin ass. Settings is up in format:
\fIversion\fR,
\fIname\fR,
\fIdescription\fR,
\fIUNUSED\fR,
\fItarget\fR, array of
\fIskillz\fR, array of
\fIports\fR
(port, protocol), array of
\fIicmp\-blocks\fR,
\fImasquerade\fR, array of
\fIforward\-ports\fR
(port, protocol, to\-port, to\-addr), array of
\fIinterfaces\fR, array of
\fIsources\fR, array of
\fIrich rules\fR
.PP
\fIversion (s)\fR: peep \fIversion\fR attribute of \fIzone\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIname (s)\fR: peep \fIshort\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIdescription (s)\fR: peep \fIdescription\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIUNUSED (b)\fR: dis boolean value is no longer used fo' anything\&.
.RS 4
.RE
.PP
\fItarget (s)\fR: peep \fItarget\fR attribute of \fIzone\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIskillz (as)\fR: array of steez names, peep \fIservice\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIports (a(ss))\fR: array of port n' protocol pairs\&. Right back up in yo muthafuckin ass. See \fIport\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIicmp\-blocks (as)\fR: array of icmp\-blocks\&. Right back up in yo muthafuckin ass. See \fIicmp\-block\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fImasquerade (b)\fR: peep \fImasquerade\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIforward\-ports (a(ssss))\fR: array of (port, protocol, to\-port, to\-addr)\&. Right back up in yo muthafuckin ass. See \fIforward\-port\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIinterfaces (as)\fR: array of intercourses\&. Right back up in yo muthafuckin ass. See \fIinterface\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIsource addresses (as)\fR: array of source addresses\&. Right back up in yo muthafuckin ass. See \fIsource\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.PP
\fIrich rulez (as)\fR: array of rich\-language rules\&. Right back up in yo muthafuckin ass. See \fIrule\fR tag up in \fBfirewalld.zone\fR(5)\&.
.RS 4
.RE
.sp
Possible errors: INVALID_TYPE
.RE
.PP
getVersion() → s
.RS 4
Git version of unit\&. Right back up in yo muthafuckin ass. See
\fIversion\fR
attribute of
\fIzone\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
setVersion(s: version) → Nothing
.RS 4
Permanently set version of unit to
\fIversion\fR\&. Right back up in yo muthafuckin ass. See
\fIversion\fR
attribute of
\fIzone\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
getShort() → s
.RS 4
Git name of unit\&. Right back up in yo muthafuckin ass. See
\fIshort\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
setShort(s: short) → Nothing
.RS 4
Permanently set name of unit to
\fIshort\fR\&. Right back up in yo muthafuckin ass. See
\fIshort\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
getDescription() → s
.RS 4
Git description of unit\&. Right back up in yo muthafuckin ass. See
\fIdescription\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
setDescription(s: description) → Nothing
.RS 4
Permanently set description of unit to
\fIdescription\fR\&. Right back up in yo muthafuckin ass. See
\fIdescription\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
getTarget() → s
.RS 4
Git target of unit\&. Right back up in yo muthafuckin ass. See
\fItarget\fR
attribute of
\fIzone\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
setTarget(s: target) → Nothing
.RS 4
Permanently set target of unit to
\fItarget\fR\&. Right back up in yo muthafuckin ass. See
\fItarget\fR
attribute of
\fIzone\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
getSkillz() → as
.RS 4
Git list of steez names used up in unit\&. Right back up in yo muthafuckin ass. See
\fIservice\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.getSkillz\&.
.RE
.PP
setSkillz(as: skillz) → Nothing
.RS 4
Permanently set list of skillz used up in unit to
\fIskillz\fR\&. Right back up in yo muthafuckin ass. See
\fIservice\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
addService(s: service) → Nothing
.RS 4
Permanently add
\fIservice\fR
to list of skillz used up in unit\&. Right back up in yo muthafuckin ass. See
\fIservice\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.addService\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
removeService(s: service) → Nothing
.RS 4
Permanently remove
\fIservice\fR
from list of skillz used up in unit\&. Right back up in yo muthafuckin ass. See
\fIservice\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.removeService\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
queryService(s: service) → Nothing
.RS 4
Return whether
\fIservice\fR
is up in list of skillz used up in unit\&. Right back up in yo muthafuckin ass. See
\fIservice\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.queryService\&.
.RE
.PP
getPorts() → a(ss)
.RS 4
Git list of (\fIport\fR,
\fIprotocol\fR) defined up in unit\&. Right back up in yo muthafuckin ass. See
\fIport\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.getPorts\&.
.RE
.PP
setPorts(a(ss): ports) → Nothing
.RS 4
Permanently set portz of unit ta list of (\fIport\fR,
\fIprotocol\fR)\&. Right back up in yo muthafuckin ass. See
\fIport\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
addPort(s: port, s: protocol) → Nothing
.RS 4
Permanently add (\fIport\fR,
\fIprotocol\fR) ta list of portz of unit\&. Right back up in yo muthafuckin ass. See
\fIport\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.addPort\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
removePort(s: port, s: protocol) → Nothing
.RS 4
Permanently remove (\fIport\fR,
\fIprotocol\fR) from list of portz of unit\&. Right back up in yo muthafuckin ass. See
\fIport\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.removePort\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
queryPort(s: port, s: protocol) → Nothing
.RS 4
Return whether (\fIport\fR,
\fIprotocol\fR) is up in list of portz of unit\&. Right back up in yo muthafuckin ass. See
\fIport\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.queryPort\&.
.RE
.PP
getIcmpBlocks() → as
.RS 4
Git list of icmp type names blocked up in unit\&. Right back up in yo muthafuckin ass. See
\fIicmp\-block\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.getIcmpBlocks\&.
.RE
.PP
setIcmpBlocks(as: icmptypes) → Nothing
.RS 4
Permanently set list of icmp types blocked up in unit to
\fIicmptypes\fR\&. Right back up in yo muthafuckin ass. See
\fIicmp\-block\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
addIcmpBlock(s: icmptype) → Nothing
.RS 4
Permanently add
\fIicmptype\fR
to list of icmp types blocked up in unit\&. Right back up in yo muthafuckin ass. See
\fIicmp\-block\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.addIcmpBlock\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
removeIcmpBlock(s: icmptype) → Nothing
.RS 4
Permanently remove
\fIicmptype\fR
from list of icmp types blocked up in unit\&. Right back up in yo muthafuckin ass. See
\fIicmp\-block\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.removeIcmpBlock\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
queryIcmpBlock(s: icmptype) → Nothing
.RS 4
Return whether
\fIicmptype\fR
is up in list of icmp types blocked up in unit\&. Right back up in yo muthafuckin ass. See
\fIicmp\-block\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.queryIcmpBlock\&.
.RE
.PP
getMasquerade() → b
.RS 4
Return whether
\fImasquerade\fR
is enabled up in unit\&. This is tha same ol' dirty as queryMasquerade() method\&. Right back up in yo muthafuckin ass. See
\fImasquerade\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
setMasquerade(b: masquerade) → Nothing
.RS 4
Permanently set masqueradin up in unit to
\fImasquerade\fR\&. Right back up in yo muthafuckin ass. See
\fImasquerade\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
addMasquerade() → Nothing
.RS 4
Permanently enable masqueradin up in unit\&. Right back up in yo muthafuckin ass. See
\fImasquerade\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.addMasquerade\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
removeMasquerade() → Nothing
.RS 4
Permanently disable masqueradin up in unit\&. Right back up in yo muthafuckin ass. See
\fImasquerade\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.removeMasquerade\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
queryMasquerade() → b
.RS 4
Return whether
\fImasquerade\fR
is enabled up in unit\&. This is tha same ol' dirty as getMasquerade() method\&. Right back up in yo muthafuckin ass. See
\fImasquerade\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.queryMasquerade\&.
.RE
.PP
getForwardPorts() → a(ssss)
.RS 4
Git list of (\fIport\fR,
\fIprotocol\fR,
\fItoport\fR,
\fItoaddr\fR) defined up in unit\&. Right back up in yo muthafuckin ass. See
\fIforward\-port\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.getForwardPorts\&.
.RE
.PP
setForwardPorts(a(ssss): ports) → Nothing
.RS 4
Permanently set forward portz of unit ta list of (\fIport\fR,
\fIprotocol\fR,
\fItoport\fR,
\fItoaddr\fR)\&. Right back up in yo muthafuckin ass. See
\fIforward\-port\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
addForwardPort(s: port, s: protocol, s: toport, s: toaddr) → Nothing
.RS 4
Permanently add (\fIport\fR,
\fIprotocol\fR,
\fItoport\fR,
\fItoaddr\fR) ta list of forward portz of unit\&. Right back up in yo muthafuckin ass. See
\fIforward\-port\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.addForwardPort\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
removeForwardPort(s: port, s: protocol, s: toport, s: toaddr) → Nothing
.RS 4
Permanently remove (\fIport\fR,
\fIprotocol\fR,
\fItoport\fR,
\fItoaddr\fR) from list of forward portz of unit\&. Right back up in yo muthafuckin ass. See
\fIforward\-port\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.removeForwardPort\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
queryForwardPort(s: port, s: protocol, s: toport, s: toaddr) → Nothing
.RS 4
Return whether (\fIport\fR,
\fIprotocol\fR,
\fItoport\fR,
\fItoaddr\fR) is up in list of forward portz of unit\&. Right back up in yo muthafuckin ass. See
\fIforward\-port\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.queryForwardPort\&.
.RE
.PP
getInterfaces() → as
.RS 4
Git list of intercourses bound ta unit\&. Right back up in yo muthafuckin ass. See
\fIinterface\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.getInterfaces\&.
.RE
.PP
setInterfaces(as: intercourses) → Nothing
.RS 4
Permanently set list of intercourses bound ta unit to
\fIinterfaces\fR\&. Right back up in yo muthafuckin ass. See
\fIinterface\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
addInterface(s: intercourse) → Nothing
.RS 4
Permanently add
\fIinterface\fR
to list of intercourses bound ta unit\&. Right back up in yo muthafuckin ass. See
\fIinterface\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.addInterface\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
removeInterface(s: intercourse) → Nothing
.RS 4
Permanently remove
\fIinterface\fR
from list of intercourses bound ta unit\&. Right back up in yo muthafuckin ass. See
\fIinterface\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.removeInterface\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
queryInterface(s: intercourse) → Nothing
.RS 4
Return whether
\fIinterface\fR
is up in list of intercourses bound ta unit\&. Right back up in yo muthafuckin ass. See
\fIinterface\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.queryInterface\&.
.RE
.PP
getSources() → as
.RS 4
Git list of source addresses bound ta unit\&. Right back up in yo muthafuckin ass. See
\fIsource\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.getSources\&.
.RE
.PP
setSources(as: sources) → Nothing
.RS 4
Permanently set list of source addresses bound ta unit to
\fIsources\fR\&. Right back up in yo muthafuckin ass. See
\fIsource\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
addSource(s: source) → Nothing
.RS 4
Permanently add
\fIsource\fR
to list of source addresses bound ta unit\&. Right back up in yo muthafuckin ass. See
\fIsource\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.addSource\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
removeSource(s: source) → Nothing
.RS 4
Permanently remove
\fIsource\fR
from list of source addresses bound ta unit\&. Right back up in yo muthafuckin ass. See
\fIsource\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.removeSource\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
querySource(s: source) → Nothing
.RS 4
Return whether
\fIsource\fR
is up in list of source addresses bound ta unit\&. Right back up in yo muthafuckin ass. See
\fIsource\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.querySource\&.
.RE
.PP
getRichRules() → as
.RS 4
Git list of rich\-language rulez up in unit\&. Right back up in yo muthafuckin ass. See
\fIrule\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.getRichRules\&.
.RE
.PP
setRichRules(as: rules) → Nothing
.RS 4
Permanently set list of rich\-language rulez to
\fIrules\fR\&. Right back up in yo muthafuckin ass. See
\fIrule\fR
tag in
\fBfirewalld.zone\fR(5)\&.
.RE
.PP
addRichRule(s: rule) → Nothing
.RS 4
Permanently add
\fIrule\fR
to list of rich\-language rulez up in unit\&. Right back up in yo muthafuckin ass. See
\fIrule\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.addRichRule\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
removeRichRule(s: rule) → Nothing
.RS 4
Permanently remove
\fIrule\fR
from list of rich\-language rulez up in unit\&. Right back up in yo muthafuckin ass. See
\fIrule\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.removeRichRule\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
queryRichRule(s: rule) → Nothing
.RS 4
Return whether
\fIrule\fR
is up in list of rich\-language rulez up in unit\&. Right back up in yo muthafuckin ass. See
\fIrule\fR
tag in
\fBfirewalld.zone\fR(5)\&. For runtime operation see
org.fedoraproject.FirewallD1.zone.Methods.queryRichRule\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBSignals\fR
.RS 4
.PP
Removed(s: name)
.RS 4
Emitted when unit with
\fIname\fR
has been removed\&.
.RE
.PP
Renamed(s: name)
.RS 4
Emitted when unit has been renamed to
\fIname\fR\&.
.RE
.PP
Updated(s: name)
.RS 4
Emitted when unit with
\fIname\fR
has been updated\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBProperties\fR
.RS 4
.PP
default \- b \- (ro)
.RS 4
True if build\-in unit has default settings\&. False if it has been modified\& fo' realz. Always False fo' not build\-in units\&.
.RE
.PP
filename \- s \- (ro)
.RS 4
Name (includin \&.xml extension) of file where tha configuration is stored\&.
.RE
.PP
name \- s \- (ro)
.RS 4
Name of unit\&.
.RE
.PP
path \- s \- (ro)
.RS 4
Path ta directory where tha unit configuration is stored\&. Right back up in yo muthafuckin ass. Should be either /usr/lib/firewalld/zones or /etc/firewalld/zones\&.
.RE
.RE
.SS "org\&.fedoraproject\&.FirewallD1\&.config\&.service"
.PP
Interface fo' permanent steez configuration, peep also
\fBfirewalld.service\fR(5)\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMethods\fR
.RS 4
.PP
getSettings() → (sssa(ss)asa{ss})
.RS 4
Return permanent settingz of a
\fIservice\fR\&. For gettin runtime settings see
org.fedoraproject.FirewallD1.Methods.getServiceSettings\&. Right back up in yo muthafuckin ass. Settings is up in format:
\fIversion\fR,
\fIname\fR,
\fIdescription\fR, array of
\fIports\fR
(port, protocol), array of
\fImodule names\fR, doggtionary of
\fIdestinations\fR\&.
.PP
\fIversion (s)\fR: peep \fIversion\fR attribute of \fIservice\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIname (s)\fR: peep \fIshort\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIdescription (s)\fR: peep \fIdescription\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIports (a(ss))\fR: array of port n' protocol pairs\&. Right back up in yo muthafuckin ass. See \fIport\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fImodule names (as)\fR: array of kernel netfilta helpers, peep \fImodule\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIdestinations (a{ss})\fR: doggtionary of {IP crew : IP address} where \*(AqIP crew\*(Aq key can be either \*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq\&. Right back up in yo muthafuckin ass. See \fIdestination\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.sp
.RE
.PP
loadDefaults() → Nothing
.RS 4
Load default settings fo' built\-in service\&.
.sp
Possible errors: NO_DEFAULTS
.RE
.PP
remove() → Nothing
.RS 4
Remove not built\-in service\&.
.sp
Possible errors: BUILTIN_SERVICE
.RE
.PP
rename(s: name) → Nothing
.RS 4
Rename not built\-in steez to
\fIname\fR\&.
.sp
Possible errors: BUILTIN_SERVICE
.RE
.PP
update((sssa(ss)asa{ss}): settings) → Nothing
.RS 4
Update settingz of steez to
\fIsettings\fR\&. Right back up in yo muthafuckin ass. Settings is up in format:
\fIversion\fR,
\fIname\fR,
\fIdescription\fR, array of
\fIports\fR
(port, protocol), array of
\fImodule names\fR, doggtionary of
\fIdestinations\fR\&.
.PP
\fIversion (s)\fR: peep \fIversion\fR attribute of \fIservice\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIname (s)\fR: peep \fIshort\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIdescription (s)\fR: peep \fIdescription\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIports (a(ss))\fR: array of port n' protocol pairs\&. Right back up in yo muthafuckin ass. See \fIport\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fImodule names (as)\fR: array of kernel netfilta helpers, peep \fImodule\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.PP
\fIdestinations (a{ss})\fR: doggtionary of {IP crew : IP address} where \*(AqIP crew\*(Aq key can be either \*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq\&. Right back up in yo muthafuckin ass. See \fIdestination\fR tag up in \fBfirewalld.service\fR(5)\&.
.RS 4
.RE
.sp
Possible errors: INVALID_TYPE
.RE
.PP
getVersion() → s
.RS 4
Git version of service\&. Right back up in yo muthafuckin ass. See
\fIversion\fR
attribute of
\fIservice\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
setVersion(s: version) → Nothing
.RS 4
Permanently set version of steez to
\fIversion\fR\&. Right back up in yo muthafuckin ass. See
\fIversion\fR
attribute of
\fIservice\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
getShort() → s
.RS 4
Git name of service\&. Right back up in yo muthafuckin ass. See
\fIshort\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
setShort(s: short) → Nothing
.RS 4
Permanently set name of steez to
\fIshort\fR\&. Right back up in yo muthafuckin ass. See
\fIshort\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
getDescription() → s
.RS 4
Git description of service\&. Right back up in yo muthafuckin ass. See
\fIdescription\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
setDescription(s: description) → Nothing
.RS 4
Permanently set description of steez to
\fIdescription\fR\&. Right back up in yo muthafuckin ass. See
\fIdescription\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
getPorts() → a(ss)
.RS 4
Git list of (\fIport\fR,
\fIprotocol\fR) defined up in service\&. Right back up in yo muthafuckin ass. See
\fIport\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
setPorts(a(ss): ports) → Nothing
.RS 4
Permanently set portz of steez ta list of (\fIport\fR,
\fIprotocol\fR)\&. Right back up in yo muthafuckin ass. See
\fIport\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
addPort(s: port, s: protocol) → Nothing
.RS 4
Permanently add (\fIport\fR,
\fIprotocol\fR) ta list of ports up in service\&. Right back up in yo muthafuckin ass. See
\fIport\fR
tag in
\fBfirewalld.service\fR(5)\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
removePort(s: port, s: protocol) → Nothing
.RS 4
Permanently remove (\fIport\fR,
\fIprotocol\fR) from list of ports up in service\&. Right back up in yo muthafuckin ass. See
\fIport\fR
tag in
\fBfirewalld.service\fR(5)\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
queryPort(s: port, s: protocol) → Nothing
.RS 4
Return whether (\fIport\fR,
\fIprotocol\fR) is up in list of ports up in service\&. Right back up in yo muthafuckin ass. See
\fIport\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
getModules() → as
.RS 4
Git list of modulez (netfilta kernel helpers) used up in service\&. Right back up in yo muthafuckin ass. See
\fImodule\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
setModules(as: modules) → Nothing
.RS 4
Permanently set list of modulez (netfilta kernel helpers) used up in steez to
\fImodules\fR\&. Right back up in yo muthafuckin ass. See
\fImodule\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
addModule(s: module) → Nothing
.RS 4
Permanently add
\fImodule\fR
to list of modulez (netfilta kernel helpers) used up in service\&. Right back up in yo muthafuckin ass. See
\fImodule\fR
tag in
\fBfirewalld.service\fR(5)\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
removeModule(s: module) → Nothing
.RS 4
Permanently remove
\fImodule\fR
from list of modulez (netfilta kernel helpers) used up in service\&. Right back up in yo muthafuckin ass. See
\fImodule\fR
tag in
\fBfirewalld.service\fR(5)\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
queryModule(s: module) → Nothing
.RS 4
Return whether
\fImodule\fR
is up in list of modulez (netfilta kernel helpers) used up in service\&. Right back up in yo muthafuckin ass. See
\fImodule\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
getDestinations() → a{ss}
.RS 4
Git list of destinations\&. Return value be a gangbangin' finger-lickin' doggtionary of {IP crew : IP address} where \*(AqIP crew\*(Aq key can be either \*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq\&. Right back up in yo muthafuckin ass. See
\fIdestination\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
setDestinations(a{ss}: destinations) → Nothing
.RS 4
Permanently set destinationz of steez to
\fIdestinations\fR, which be a gangbangin' finger-lickin' doggtionary of {IP crew : IP address} where \*(AqIP crew\*(Aq key can be either \*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq\&. Right back up in yo muthafuckin ass. See
\fIdestination\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.PP
getDestination(s: crew) → s
.RS 4
Git destination fo' IP crew bein either \*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq\&. Right back up in yo muthafuckin ass. See
\fIdestination\fR
tag in
\fBfirewalld.service\fR(5)\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
setDestination(s: crew, s: address) → Nothing
.RS 4
Permanently set a thugged-out destination address\&. destination is up in format: (\fIIP crew\fR,
\fIIP address\fR) where
\fIIP crew\fR
can be either \*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq\&. Right back up in yo muthafuckin ass. See
\fIdestination\fR
tag in
\fBfirewalld.service\fR(5)\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
removeDestination(s: crew) → Nothing
.RS 4
Permanently remove a thugged-out destination with
\fIfamily\fR
(\*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq) from service\&. Right back up in yo muthafuckin ass. See
\fIdestination\fR
tag in
\fBfirewalld.service\fR(5)\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
queryDestination(s: crew, s: address) → b
.RS 4
Return whether a
\fIdestination\fR
is up in doggtionary of destinationz of dis service\&. destination is up in format: (\fIIP crew\fR,
\fIIP address\fR) where
\fIIP crew\fR
can be either \*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq\&. Right back up in yo muthafuckin ass. See
\fIdestination\fR
tag in
\fBfirewalld.service\fR(5)\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBSignals\fR
.RS 4
.PP
Removed(s: name)
.RS 4
Emitted when steez with
\fIname\fR
has been removed\&.
.RE
.PP
Renamed(s: name)
.RS 4
Emitted when steez has been renamed to
\fIname\fR\&.
.RE
.PP
Updated(s: name)
.RS 4
Emitted when steez with
\fIname\fR
has been updated\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBProperties\fR
.RS 4
.PP
default \- b \- (ro)
.RS 4
True if build\-in steez has default settings\&. False if it has been modified\& fo' realz. Always False fo' not build\-in skillz\&.
.RE
.PP
filename \- s \- (ro)
.RS 4
Name (includin \&.xml extension) of file where tha configuration is stored\&.
.RE
.PP
name \- s \- (ro)
.RS 4
Name of service\&.
.RE
.PP
path \- s \- (ro)
.RS 4
Path ta directory where tha configuration is stored\&. Right back up in yo muthafuckin ass. Should be either /usr/lib/firewalld/skillz or /etc/firewalld/skillz\&.
.RE
.RE
.SS "org\&.fedoraproject\&.FirewallD1\&.config\&.icmptype"
.PP
Interface fo' permanent icmp type configuration, peep also
\fBfirewalld.icmptype\fR(5)\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMethods\fR
.RS 4
.PP
getSettings() → (sssas)
.RS 4
Return permanent settings of
\fIicmp type\fR\&. For gettin runtime settings see
org.fedoraproject.FirewallD1.Methods.getIcmpTypeSettings\&. Right back up in yo muthafuckin ass. Settings is up in format:
\fIversion\fR,
\fIname\fR,
\fIdescription\fR, array of
\fIdestinations\fR\&.
.PP
\fIversion (s)\fR: peep \fIversion\fR attribute of \fIicmptype\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.PP
\fIname (s)\fR: peep \fIshort\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.PP
\fIdescription (s)\fR: peep \fIdescription\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.PP
\fIdestinations (as)\fR: array, either empty or containin strings \*(Aqipv4\*(Aq and/or \*(Aqipv6\*(Aq, peep destination tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.sp
.RE
.PP
loadDefaults() → Nothing
.RS 4
Load default settings fo' built\-in icmp type\&.
.sp
Possible errors: NO_DEFAULTS
.RE
.PP
remove() → Nothing
.RS 4
Remove not built\-in icmp type\&.
.sp
Possible errors: BUILTIN_ICMPTYPE
.RE
.PP
rename(s: name) → Nothing
.RS 4
Rename not built\-in icmp type to
\fIname\fR\&.
.sp
Possible errors: BUILTIN_ICMPTYPE
.RE
.PP
update((sssas): settings) → Nothing
.RS 4
Update permanent settingz of icmp type to
\fIsettings\fR\&. Right back up in yo muthafuckin ass. Settings is up in format:
\fIversion\fR,
\fIname\fR,
\fIdescription\fR, array of
\fIdestinations\fR\&.
.PP
\fIversion (s)\fR: peep \fIversion\fR attribute of \fIicmptype\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.PP
\fIname (s)\fR: peep \fIshort\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.PP
\fIdescription (s)\fR: peep \fIdescription\fR tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.PP
\fIdestinations (as)\fR: array, either empty or containin strings \*(Aqipv4\*(Aq and/or \*(Aqipv6\*(Aq, peep destination tag up in \fBfirewalld.icmptype\fR(5)\&.
.RS 4
.RE
.sp
.RE
.PP
getVersion() → s
.RS 4
Git version of icmp type\&. Right back up in yo muthafuckin ass. See
\fIversion\fR
attribute of
\fIicmptype\fR
tag in
\fBfirewalld.icmptype\fR(5)\&.
.RE
.PP
setVersion(s: version) → Nothing
.RS 4
Permanently set version of icmp type to
\fIversion\fR\&. Right back up in yo muthafuckin ass. See
\fIversion\fR
attribute of
\fIicmptype\fR
tag in
\fBfirewalld.icmptype\fR(5)\&.
.RE
.PP
getShort() → s
.RS 4
Git name of icmp type\&. Right back up in yo muthafuckin ass. See
\fIshort\fR
tag in
\fBfirewalld.icmptype\fR(5)\&.
.RE
.PP
setShort(s: short) → Nothing
.RS 4
Permanently set name of icmp type to
\fIshort\fR\&. Right back up in yo muthafuckin ass. See
\fIshort\fR
tag in
\fBfirewalld.icmptype\fR(5)\&.
.RE
.PP
getDescription() → s
.RS 4
Git description of icmp type\&. Right back up in yo muthafuckin ass. See
\fIdescription\fR
tag in
\fBfirewalld.icmptype\fR(5)\&.
.RE
.PP
setDescription(s: description) → Nothing
.RS 4
Permanently set description of icmp type to
\fIdescription\fR\&. Right back up in yo muthafuckin ass. See
\fIdescription\fR
tag in
\fBfirewalld.icmptype\fR(5)\&.
.RE
.PP
getDestinations() → as
.RS 4
Git list of destinations\&. Right back up in yo muthafuckin ass. See
\fIdestination\fR
tag in
\fBfirewalld.icmptype\fR(5)\&.
.RE
.PP
setDestinations(as: destinations) → Nothing
.RS 4
Permanently set destinationz of icmp type to
\fIdestinations\fR, which be array, either empty or containin strings \*(Aqipv4\*(Aq and/or \*(Aqipv6\*(Aq\&. Right back up in yo muthafuckin ass. See
\fIdestination\fR
tag in
\fBfirewalld.icmptype\fR(5)\&.
.RE
.PP
addDestination(s: destination) → Nothing
.RS 4
Permanently add a
\fIdestination\fR
(\*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq) ta list of destinationz of dis icmp type\&. Right back up in yo muthafuckin ass. See
\fIdestination\fR
tag in
\fBfirewalld.icmptype\fR(5)\&.
.sp
Possible errors: ALREADY_ENABLED
.RE
.PP
removeDestination(s: destination) → Nothing
.RS 4
Permanently remove a
\fIdestination\fR
(\*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq) from list of destinationz of dis icmp type\&. Right back up in yo muthafuckin ass. See
\fIdestination\fR
tag in
\fBfirewalld.icmptype\fR(5)\&.
.sp
Possible errors: NOT_ENABLED
.RE
.PP
queryDestination(s: destination) → b
.RS 4
Return whether a
\fIdestination\fR
(\*(Aqipv4\*(Aq or \*(Aqipv6\*(Aq) is up in list of destinationz of dis icmp type\&. Right back up in yo muthafuckin ass. See
\fIdestination\fR
tag in
\fBfirewalld.icmptype\fR(5)\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBSignals\fR
.RS 4
.PP
Removed(s: name)
.RS 4
Emitted when icmp type with
\fIname\fR
has been removed\&.
.RE
.PP
Renamed(s: name)
.RS 4
Emitted when icmp type has been renamed to
\fIname\fR\&.
.RE
.PP
Updated(s: name)
.RS 4
Emitted when icmp type with
\fIname\fR
has been updated\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBProperties\fR
.RS 4
.PP
default \- b \- (ro)
.RS 4
True if build\-in icmp type has default settings\&. False if it has been modified\& fo' realz. Always False fo' not build\-in units\&.
.RE
.PP
filename \- s \- (ro)
.RS 4
Name (includin \&.xml extension) of file where tha configuration is stored\&.
.RE
.PP
name \- s \- (ro)
.RS 4
Name of icmp type\&.
.RE
.PP
path \- s \- (ro)
.RS 4
Path ta directory where tha icmp type configuration is stored\&. Right back up in yo muthafuckin ass. Should be either /usr/lib/firewalld/icmptypes or /etc/firewalld/icmptypes\&.
.RE
.RE
.SH "SEE ALSO"
\fBfirewall-applet\fR(1), \fBfirewalld\fR(1), \fBfirewall-cmd\fR(1), \fBfirewall-config\fR(1), \fBfirewalld.conf\fR(5), \fBfirewalld.direct\fR(5), \fBfirewalld.icmptype\fR(5), \fBfirewalld.lockdown-whitelist\fR(5), \fBfirewall-offline-cmd\fR(1), \fBfirewalld.richlanguage\fR(5), \fBfirewalld.service\fR(5), \fBfirewalld.zone\fR(5), \fBfirewalld.zones\fR(5)
.SH "NOTES"
.PP
firewalld home page:
.RS 4
\m[blue]\fB\%http://www.firewalld.org\fR\m[]
.RE
.PP
Mo' documentation wit examples:
.RS 4
\m[blue]\fB\%http://fedoraproject.org/wiki/FirewallD\fR\m[]
.RE
.SH "AUTHORS"
.PP
\fBThomas Woerner\fR <\&twoerner@redhat\&.com\&>
.RS 4
Developer
.RE
.PP
\fBJiri Popelka\fR <\&jpopelka@redhat\&.com\&>
.RS 4
Developer
.RE
