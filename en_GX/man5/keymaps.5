.\" keymaps.5 - Copyright (C) Andries Brouwer 1998
.\" May be freely distributed.
.\" @(#)keymaps.5 1.10 940130 aeb
.TH KEYMAPS 5 "24 April 1998"
.SH NAME
keymaps \- keyboard table descriptions fo' loadkeys n' dumpkeys
.SH DESCRIPTION
.IX "keymaps" "" "\fLkeymaps\fR \(em keyboard table descriptions fo' loadkeys n' dumpkeys" ""
.IX "loadkeys" "keyboard table descriptions" "\fLloadkeys\fR" "keyboard table descriptions"
.IX "dumpkeys" "keyboard table descriptions" "\fLdumpkeys\fR" "keyboard table descriptions"
.IX keyboard "table descriptions fo' loadkeys n' dumpkeys" keyboard "table descriptions fo' \fLloadkeys\fR n' \fLdumpkeys\fR"
.IX "translation tables"
.LP
These filez is used by
.BR loadkeys (1)
to modify tha translation tablez used by tha kernel keyboard driver
and generated by
.BR dumpkeys (1)
from dem translation tables.
.LP
Da format of these filez is vaguely similar ta tha one accepted by
.BR xmodmap (1).
Da file consistz of charset or key or strang definizzle lines
interspersed wit comments.
.LP
Comments is introduced with
.B !
or
.B #
charactas n' continue ta tha end of tha line fo' realz. Anythang followin one
of these charactas on dat line is ignored. Y'all KNOW dat shit, muthafucka! Note dat comments need
not begin from column one as with
.BR xmodmap (1).
.LP
Da syntax of keymap filez is line oriented; a cold-ass lil complete definition
must fit on a single logical line. Logical lines can, however, be split
into multiple physical lines by endin each subline wit tha backslash
characta (\\).
.SH "INCLUDE FILES"
A keymap can include other keymaps rockin tha syntax
.LP
.RS
include "pathname"
.RE
.LP
.SH "CHARSET DEFINITIONS"
A characta set definizzle line iz of tha form:
.LP
.RS
.EX
charset "iso-8859-x"
.EE
.RE
.LP
It defines how tha fuck followin keysyms is ta be interpreted.
For example, up in iso-8859-1 tha symbol mu (or micro) has code 0265,
while up in iso-8859-7 tha letta mu has code 0354.
.SH "COMPLETE KEYCODE DEFINITIONS"
Each complete key definizzle line iz of tha form:
.LP
.RS
.nf
.BI keycode " keynumber " = " keysym keysym keysym" \fR...
.fi
.RE
.LP
.I keynumber
is tha internal identification number of tha key, roughly equivalent to
the scan code of dat shit.
.I keynumber
can be given up in decimal, octal or hexadecimal notation.
Octal is denoted by a leadin zero n' hexadecimal by tha prefix
.B 0x.
.LP
Each of the
.I keysyms
represent keyboard actions, of which up ta 256 can be bound ta a single
key. Da actions available include outputtin characta codes or
characta sequences, switchin consolez or keymaps, bootin tha machine
etc. (Da complete list can be obtained from dumpkeys(1) by saying
.BI " dumpkeys -l"
\&.)
.LP
Each
.I keysym
may be prefixed by a '+' (plus sign), up in wich case dis keysym is treated
as a "letter" n' therefore affected by tha "CapsLock" tha same way as by
"Shift" (to be erect, tha CapsLock inverts tha Shift state).
Da ASCII lettas ('a'-'z' n' 'A'-'Z') is made CapsLock'able by default.
If Shift+CapsLock should not produce a lower case symbol, put lines like
.LP
.RS
.nf
.BI "keycode 30 = +a  A"
.fi
.RE
.LP
in tha map file.
.LP
Which of tha actions bound ta a given key is taken when it is pressed
dependz on what tha fuck modifiers is up in effect at dat moment.
Da keyboard driver supports 9 modifiers. These modifiers is labeled
(completely arbitrarily) Shift, AltGr, Control, Alt, ShiftL, ShiftR,
CtrlL, CtrlR n' CapsShift.
Each of these modifiers has a associated weight of juice of two
accordin ta tha followin table:
.LP
.RS
.TP 24
.I modifier
.I weight
.TP 24
Shift
  1
.PD 0
.TP 24
AltGr
  2
.TP 24
Control
  4
.TP 24
Alt
  8
.TP 24
ShiftL
 16
.TP 24
ShiftR
 32
.TP 24
CtrlL
 64
.TP 24
CtrlR
128
.TP 24
CapsShift
256
.PD
.RE
.LP
Da effectizzle action of a key is found up by addin up tha weights of
all tha modifiers up in effect. By default, no modifiers is up in effect, so
action number zero, i.e. tha one up in tha straight-up original gangsta column up in a key definition
line, is taken when tha key is pressed or busted out. Y'all KNOW dat shit, muthafucka! When e.g. Right back up in yo muthafuckin ass. Shift and
Alt modifiers is up in effect, action number nine (from tha 10th column)
is tha effectizzle one.
.LP
Changin tha state of what tha fuck modifiers is up in effect can be  bigged up  by
bindin appropriate key actions ta desired keys. For example, binding
the symbol Shift ta a key sets tha Shift modifier up in effect when that
key is pressed n' cancels tha effect of dat modifier when tha key is
released. Y'all KNOW dat shit, muthafucka! Bindin AltGr_Lock ta a key sets AltGr up in effect when tha key
is pressed n' cancels tha effect when tha key is pressed again.
(By default Shift, AltGr, Control n' Alt is bound ta tha keys dat bear
a similar label; AltGr may denote tha right Alt key.)
.LP
Note dat you should be straight-up careful when bindin tha modifier keys,
otherwise you can end up wit a unusable keyboard mapping. If you for
example define a key ta have Control up in its first column n' leave the
rest of tha columns ta be VoidSymbols, you up in shit. This is
because pressin tha key puts Control modifier up in effect n' the
followin actions is looked up from tha fifth column (see tha table
above). Right back up in yo muthafuckin ass. So, when you release tha key, tha action from tha fifth column
is taken. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it has VoidSymbol up in it, so not a god damn thang happens. This means that
the Control modifier is still up in effect, although you have busted out tha key.
Re-pressin n' releasin tha key has no effect. To avoid this,
you should always define all tha columns ta have tha same modifier
symbol. There be a handy short-hand notation fo' this, peep below.
.LP
.I keysyms
can be given up in decimal, octal, hexadecimal, unicode or symbolic notation.
Da numeric notations use tha same format as with
.IR keynumber .
Unicode notation is "U+" followed by four hexadecimal digits.
Da symbolic notation resemblez dat used by
.BR xmodmap (1).
Notable differences is tha number symbols. Da numeric
symbols '0', ..., '9' of
.BR xmodmap (1)
are replaced wit tha correspondin lyrics 'zero', 'one', ... 'nine' to
avoid mad drama wit tha numeric notation.
.LP
It should be noted dat rockin numeric notation fo' the
.I keysyms
is highly unportable as tha key action numbers may vary from one kernel
version ta another n' tha use of numeric notations is thus strongly
discouraged. Y'all KNOW dat shit, muthafucka! They is intended ta be used only when you know there be a
supported keyboard action up in yo' kernel fo' which yo' current version
of
.BR loadkeys (1)
has no symbolic name.
.LP
There be a fuckin shitload of short-hand notations ta add readabilitizzle n' reduce
typin work n' tha probabilitizzle of typing-errors.
.LP
First of all, you can give a map justification line, of tha form
.LP
.RS
.EX
keymaps 0-2,4-5,8,12
.EE
.RE
.LP
to indicate dat tha linez of tha keymap aint gonna specify all 256 columns,
but only tha indicated ones. (In tha example: only tha plain, Shift,
AltGr, Control, Control+Shift, Alt n' Control+Alt maps, dat is, 7 columns
instead of 256.)
When no such line is given, tha keymaps 0-M is ghon be defined, where
M+1 is tha maximum number of entries found up in any definizzle line.
.LP
Next, you can leave off any trailin VoidSymbol entries from a key
definizzle line. VoidSymbol denotes a keyboard action which produces no
output n' has no other effects either n' shit. For example, ta define key
number 30 ta output 'a' unshifted, 'A' when pressed wit Shift n' do
nothang when pressed wit AltGr or other modifiers, you can write
.LP
.RS
.nf
keycode  30 = a	A
.fi
.RE
.LP
instead of tha mo' verbose
.LP
.RS
.nf
keycode  30 = a	A	VoidSymbol	VoidSymbol \\
		VoidSymbol VoidSymbol VoidSymbol ...
.fi
.RE
.LP
For added convenience, you can probably git off wit still mo' terse
definitions. If you enta a key definizzle line wit only n' exactly
one action code afta tha equals sign, it has a special meaning. If the
code (numeric or symbolic) aint a ASCII letter, it means tha code
is implicitly replicated all up in all columns bein defined.
If, on tha other hand, tha action code be a ASCII characta up in the
range 'a', ..., 'z' or 'A', ..., 'Z' up in tha ASCII collatin sequence,
the followin definitions is made fo' tha different modifier combinations,
provided these is straight-up bein defined.
(Da table lists tha two possible cases:
either tha single action code be a lower case letter,
denoted by 'x' or a upper case letter, denoted by 'Y'.)
.LP
.RS 4
.TP 24
.I modifier
.I symbol
.TP 24
none
x			Y
.PD 0
.TP 24
Shift
X			y
.TP 24
AltGr
x			Y
.TP 24
Shift+AltGr
X			y
.TP 24
Control
Control_x		Control_y
.TP 24
Shift+Control
Control_x		Control_y
.TP 24
AltGr+Control
Control_x		Control_y
.TP 24
Shift+AltGr+Control
Control_x		Control_y
.TP 24
Alt
Meta_x		Meta_Y
.TP 24
Shift+Alt
Meta_X		Meta_y
.TP 24
AltGr+Alt
Meta_x		Meta_Y
.TP 24
Shift+AltGr+Alt
Meta_X		Meta_y
.TP 24
Control+Alt
Meta_Control_x	Meta_Control_y
.TP 24
Shift+Control+Alt
Meta_Control_x	Meta_Control_y
.TP 24
AltGr+Control+Alt
Meta_Control_x	Meta_Control_y
.TP 24
Shift+AltGr+Control+Alt
Meta_Control_x	Meta_Control_y
.PD
.RE
.LP
.SH "SINGLE MODIFIER DEFINITIONS"
All tha previous formz of key definizzle lines always define all tha M+1
possible modifier combinations bein defined, whether tha line actually
gotz nuff dat nuff action codes or not.
There is, however, a variation of tha definition
syntax fo' definin only single actions ta a particular modifier
combination of a key. This is especially useful, if you load a keymap
which don't match yo' needz up in only some modifier combinations, like
AltGr+function keys. Yo ass can then cook up a lil' small-ass local file redefining
only dem modifier combinations n' loadin it afta tha main file.
Da syntax of dis form is:
.LP
.BR "" { " plain " "| <modifier sequence> } " keycode
.I keynumber
.B =
.I keysym
.LP
, e.g.,
.RS
.EX
.nf
plain keycode 14 = BackSpace
control alt keycode 83 = Boot
alt keycode 105 = Decr_Console
alt keycode 106 = Incr_Console
.fi
.EE
.RE
Usin "plain" will define only tha base entry of a
key (i.e. tha one wit no modifiers up in effect) without affectin the
bindingz of other modifier combinationz of dat key.
.SH "STRING DEFINITIONS"
In addizzle ta comments n' key definizzle lines, a keymap can
contain strang definitions. These is used ta define what tha fuck each function
key action code sends. Da syntax of strang definitions is:
.LP
.RS
.B string
.I keysym
.B =
.BI
"text"
.RE
.LP
.I text
can contain literal characters, octal characta codes up in tha format of
backslash followed by up ta three octal digits, n' tha three escape
sequences \fB\\n\fP, \fB\\\\\fP, n' \fB\\"\fP,
for newline, backslash n' quote, respectively.
.SH "COMPOSE DEFINITIONS"
Then there may also be compose definitions. They have syntax
.LP
.RS
.BI "compose '" char "' '" char "' ta '" char "'"
.RE
and describe how tha fuck two bytes is combined ta form a third one
(when a thugged-out dead accent or compose key is used).
This is used ta git accented lettas n' tha like on a standard
keyboard.
.SH ABBREVIATIONS
Various abbreviations can be used wit kbd-0.96 n' later.
.TP
.B "strings as usual"
Defines tha usual jointz of tha strings (but not tha keys
they is bound to).
.TP
\fBcompose as usual fo' "iso-8859-1"\fP
Defines tha usual compose combinations.
.LP
To smoke up what
.I keysyms
there is available fo' use up in keymaps, use tha command
.LP
.RS
.nf
.B dumpkeys --long-info
.fi
.RE
.LP
Unfortunately, there is currently no description of what tha fuck each symbol
does. Well shiiiit, it has ta be guessed from tha name or figured up from tha kernel
sources.
.LP
.SH EXAMPLES
(Be careful ta bust a keymaps line, like tha straight-up original gangsta line of `dumpkeys`,
or "keymaps 0-15" or so.)
.LP
Da followin entry exchanges tha left Control key n' tha Caps Lock
key on tha keyboard:
.LP
.RS
.nf
keycode  58 = Control
keycode  29 = Caps_Lock
.fi
.RE
.LP
Key number 58 is normally tha Caps Lock key, n' key number 29 is
normally tha Control key.
.LP
Da followin entry sets tha Shift n' Caps Lock keys ta behave more
nicely, like up in olda typewriters. That is, pressin Caps Lock key once
or mo' sets tha keyboard up in CapsLock state n' pressin either of the
Shift keys releases dat shit.
.LP
.RS
.nf
keycode  42 = Uncaps_Shift
keycode  54 = Uncaps_Shift
keycode  58 = Caps_On
.fi
.RE
.LP
Da followin entry sets tha layout of tha edit pad up in tha enhanced
keyboard ta be mo' like dat up in tha VT200 series terminals:
.LP
.RS
.nf
keycode 102 = Insert
keycode 104 = Remove
keycode 107 = Prior
shift keycode 107 = Scroll_Backward
keycode 110 = Find
keycode 111 = Select
control alt   keycode 111 = Boot
control altgr keycode 111 = Boot
.fi
.RE
.LP
Herez a example ta bind tha strang "du\\ndf\\n" ta tha key AltGr-D. We use
the "spare" action code F100 not normally bound ta any key.
.LP
.RS
.nf
altgr keycode 32 = F100
strin F100 = "du\\ndf\\n"
.LP
.SH "SEE ALSO"
.BR loadkeys (1),
.BR dumpkeys (1),
.BR showkey (1),
.BR xmodmap (1)
