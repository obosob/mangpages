.\" $File: magic.man,v 1.84 2014/06/03 19:01:34 christos Exp $
.Dd June 3, 2014
.Dt MAGIC 5
.Os
.\" install as magic.4 on USG, magic.5 on V7, Berkeley n' Linux systems.
.Sh NAME
.Nm magic
.Nd file commandz magic pattern file
.Sh DESCRIPTION
This manual page documents tha format of tha magic file as
used by the
.Xr file 1
command, version 5.19.
The
.Xr file 1
command identifies tha type of a gangbangin' file using,
among other tests,
a test fo' whether tha file gotz nuff certain
.Dq "magic patterns" .
Da file
.Pa /usr/share/misc/magic
specifies what tha fuck patterns is ta be tested for, what tha fuck message or
MIME type ta print if a particular pattern is found,
and additionizzle shiznit ta extract from tha file.
.Pp
Each line of tha file specifies a test ta be performed.
A test compares tha data startin at a particular offset
in tha file wit a funky-ass byte value, a strang or a numeric value.
If tha test succeeds, a message is printed.
Da line consistz of tha followin fields:
.Bl -tag -width ".Dv message"
.It Dv offset
A number specifyin tha offset, up in bytes, tha fuck into tha file of tha data
which is ta be tested.
.It Dv type
Da type of tha data ta be tested.
Da possible joints are:
.Bl -tag -width ".Dv lestring16"
.It Dv byte
A one-byte value.
.It Dv short
A two-byte value up in dis machinez natizzle byte order.
.It Dv long
A four-byte value up in dis machinez natizzle byte order.
.It Dv quad
An eight-byte value up in dis machinez natizzle byte order.
.It Dv float
A 32-bit single precision IEEE floatin point number up in dis machinez natizzle byte order.
.It Dv double
A 64-bit double precision IEEE floatin point number up in dis machinez natizzle byte order.
.It Dv string
A strang of bytes.
Da strang type justification can be optionally followed
by /[WwcCtbT]*.
The
.Dq W
flag compacts whitespace up in tha target, which must
contain at least one whitespace character.
If tha magic has
.Dv n
consecutizzle blanks, tha target needz at least
.Dv n
consecutizzle blanks ta match.
The
.Dq w
flag treats every last muthafuckin blank up in tha magic as a optionizzle blank.
The
.Dq c
flag specifies case insensitizzle matching: lower case
charactas up in tha magic match both lower n' upper case charactas up in the
target, whereas upper case charactas up in tha magic only match upper case
charactas up in tha target.
The
.Dq C
flag specifies case insensitizzle matching: upper case
charactas up in tha magic match both lower n' upper case charactas up in the
target, whereas lower case charactas up in tha magic only match upper case
charactas up in tha target.
To do a cold-ass lil complete case insensitizzle match, specify both
.Dq c
and
.Dq C .
The
.Dq t
flag forces tha test ta be done fo' text files, while the
.Dq b
flag forces tha test ta be done fo' binary files.
The
.Dq T
flag causes tha strang ta be trimmed, i.e. leadin n' trailin whitespace
is deleted before tha strang is printed.
.It Dv pstring
A Pascal-style strang where tha straight-up original gangsta byte/short/int is interpreted as the
unsigned length.
Da length defaults ta byte n' can be specified as a modifier.
Da followin modifiers is supported:
.Bl -tag -compact -width B
.It B
A byte length (default).
.It H
A 2 byte big-ass endian length.
.It h
A 2 byte big-ass lil length.
.It L
A 4 byte big-ass endian length.
.It l
A 4 byte big-ass lil length.
.It J
Da length includes itself up in its count.
.El
Da strang aint NUL terminated.
.Dq J
is used rather than tha more
valuable
.Dq I
because dis type of length be a gangbangin' feature of tha JPEG
format.
.It Dv date
A four-byte value interpreted as a UNIX date.
.It Dv qdate
A eight-byte value interpreted as a UNIX date.
.It Dv ldate
A four-byte value interpreted as a UNIX-style date yo, but interpreted as
local time rather than UTC.
.It Dv qldate
An eight-byte value interpreted as a UNIX-style date yo, but interpreted as
local time rather than UTC.
.It Dv qwdate
An eight-byte value interpreted as a Windows-style date.
.It Dv beid3
A 32-bit ID3 length up in big-endian byte order.
.It Dv beshort
A two-byte value up in big-endian byte order.
.It Dv belong
A four-byte value up in big-endian byte order.
.It Dv bequad
An eight-byte value up in big-endian byte order.
.It Dv befloat
A 32-bit single precision IEEE floatin point number up in big-endian byte order.
.It Dv bedouble
A 64-bit double precision IEEE floatin point number up in big-endian byte order.
.It Dv bedate
A four-byte value up in big-endian byte order,
interpreted as a Unix date.
.It Dv beqdate
An eight-byte value up in big-endian byte order,
interpreted as a Unix date.
.It Dv beldate
A four-byte value up in big-endian byte order,
interpreted as a UNIX-style date yo, but interpreted as local time rather
than UTC.
.It Dv beqldate
An eight-byte value up in big-endian byte order,
interpreted as a UNIX-style date yo, but interpreted as local time rather
than UTC.
.It Dv beqwdate
An eight-byte value up in big-endian byte order,
interpreted as a Windows-style date.
.It Dv bestring16
A two-byte unicode (UCS16) strang up in big-endian byte order.
.It Dv leid3
A 32-bit ID3 length up in lil-endian byte order.
.It Dv leshort
A two-byte value up in lil-endian byte order.
.It Dv lelong
A four-byte value up in lil-endian byte order.
.It Dv lequad
An eight-byte value up in lil-endian byte order.
.It Dv lefloat
A 32-bit single precision IEEE floatin point number up in lil-endian byte order.
.It Dv ledouble
A 64-bit double precision IEEE floatin point number up in lil-endian byte order.
.It Dv ledate
A four-byte value up in lil-endian byte order,
interpreted as a UNIX date.
.It Dv leqdate
An eight-byte value up in lil-endian byte order,
interpreted as a UNIX date.
.It Dv leldate
A four-byte value up in lil-endian byte order,
interpreted as a UNIX-style date yo, but interpreted as local time rather
than UTC.
.It Dv leqldate
An eight-byte value up in lil-endian byte order,
interpreted as a UNIX-style date yo, but interpreted as local time rather
than UTC.
.It Dv leqwdate
An eight-byte value up in lil-endian byte order,
interpreted as a Windows-style date.
.It Dv lestring16
A two-byte unicode (UCS16) strang up in lil-endian byte order.
.It Dv melong
A four-byte value up in middle-endian (PDP-11) byte order.
.It Dv medate
A four-byte value up in middle-endian (PDP-11) byte order,
interpreted as a UNIX date.
.It Dv meldate
A four-byte value up in middle-endian (PDP-11) byte order,
interpreted as a UNIX-style date yo, but interpreted as local time rather
than UTC.
.It Dv indirect
Startin all up in tha given offset, consult tha magic database again.
.It Dv name
Define a
.Dq named
magic instizzle dat can be called from another
.Dv use
magic entry, like a subroutine call.
Named instizzle direct magic offsets is relatizzle ta tha offset of the
previous matched entry yo, but indirect offsets is relatizzle ta tha beginning
of tha file as usual.
Named magic entries always match.
.It Dv use
Recursively call tha named magic startin from tha current offset.
If tha name of tha referenced begins wit a
.Dv ^
then tha endiannizz of tha magic is switched; if tha magic mentioned
.Dv leshort
for example,
it is treated as
.Dv beshort
and vice versa.
This is useful ta avoid duplicatin tha rulez fo' different endianness.
.It Dv regex
A regular expression match up in extended POSIX regular expression syntax
(like egrep).
Regular expressions can take exponential time ta process, n' their
performizzle is hard ta predict, so they use is discouraged.
When used up in thang environments, they performance
should be carefully checked.
Da size of tha strang ta search should also be limited by specifying
.Dv /<length> ,
to avoid performizzle thangs scannin long files.
Da type justification can also be optionally followed by
.Dv /[c][s][l] .
The
.Dq c
flag make tha match case insensitive, while the
.Dq s
flag update tha offset ta tha start offset of tha match, rather than tha end.
The
.Dq l
modifier, chizzlez tha limit of length ta mean number of lines instead of a
byte count.
Lines is delimited by tha platforms natizzle line delimiter.
When a line count is specified, a implicit byte count also computed assuming
each line is 80 charactas long.
If neither a funky-ass byte or line count is specified, tha search is limited automatically
to 8KiB.
.Dv ^
and
.Dv $
match tha beginnin n' end of individual lines, respectively,
not beginnin n' end of file.
.It Dv search
A literal strang search startin all up in tha given offset.
Da same modifier flags can be used as fo' strang patterns.
Da search expression must contain tha range up in tha form
.Dv /number,
that is tha number of positions at which tha match will be
attempted, startin from tha start offset.
This is suitable for
searchin larger binary expressions wit variable offsets, using
.Dv \e
escapes fo' special characters.
Da order of modifier n' number aint relevant.
.It Dv default
This is intended ta be used wit tha test
.Em x
(which be always true) n' it has no type.
It matches when no other test at dat continuation level has matched before.
Clearin dat matched tests fo' a cold-ass lil continuation level, can be done rockin the
.Dv clear
test.
.It Dv clear
This test be always legit n' clears tha match flag fo' dat continuation level.
It be intended ta be used wit the
.Dv default
test.
.El
.Pp
For compatibilitizzle wit tha Single
.Ux
Standard, tha type specifiers
.Dv dC
and
.Dv d1
are equivalent to
.Dv byte ,
the type specifiers
.Dv uC
and
.Dv u1
are equivalent to
.Dv ubyte ,
the type specifiers
.Dv dS
and
.Dv d2
are equivalent to
.Dv short ,
the type specifiers
.Dv uS
and
.Dv u2
are equivalent to
.Dv ushort ,
the type specifiers
.Dv dI ,
.Dv dL ,
and
.Dv d4
are equivalent to
.Dv long ,
the type specifiers
.Dv uI ,
.Dv uL ,
and
.Dv u4
are equivalent to
.Dv ulong ,
the type specifier
.Dv d8
is equivalent to
.Dv quad ,
the type specifier
.Dv u8
is equivalent to
.Dv uquad ,
and tha type specifier
.Dv s
is equivalent to
.Dv strang .
In addition, tha type specifier
.Dv dQ
is equivalent to
.Dv quad
and tha type specifier
.Dv uQ
is equivalent to
.Dv uquad .
.Pp
Each top-level magic pattern (see below fo' a explanation of levels)
is classified as text or binary accordin ta tha types used.
Types
.Dq regex
and
.Dq search
are classified as text tests, unless non-printable charactas is used
in tha pattern.
All other tests is classified as binary.
A top-level
pattern is considered ta be a test text when all its patterns is text
patterns; otherwise, it is considered ta be a funky-ass binary pattern.
When
matchin a gangbangin' file, binary patterns is tried first; if no match is
found, n' tha file be lookin like text, then its encodin is determined
and tha text patterns is tried.
.Pp
Da numeric types may optionally be followed by
.Dv \*[Am]
and a numeric value,
to specify dat tha value is ta be AND'ed wit the
numeric value before any comparisons is done.
Prependin a
.Dv u
to tha type indicates dat ordered comparisons should be unsigned.
.It Dv test
Da value ta be compared wit tha value from tha file.
If tha type is
numeric, dis value
is specified up in C form; if it aint nuthin but a string, it is specified as a C string
with tha usual escapes permitted (e.g. \en fo' new-line).
.Pp
Numeric joints
may be preceded by a cold-ass lil characta indicatin tha operation ta be performed.
It may be
.Dv = ,
to specify dat tha value from tha file must equal tha specified value,
.Dv \*[Lt] ,
to specify dat tha value from tha file must be less than tha specified
value,
.Dv \*[Gt] ,
to specify dat tha value from tha file must be pimped outa than tha specified
value,
.Dv \*[Am] ,
to specify dat tha value from tha file must have set all of tha bits
that is set up in tha specified value,
.Dv ^ ,
to specify dat tha value from tha file must have clear any of tha bits
that is set up in tha specified value, or
.Dv ~ ,
the value specified afta is negated before tested.
.Dv x ,
to specify dat any value will match.
If tha characta is omitted, it be assumed ta be
.Dv = .
Operators
.Dv \*[Am] ,
.Dv ^ ,
and
.Dv ~
don't work wit floats n' doubles.
Da operator
.Dv !\&
specifies dat tha line matches if tha test do
.Em not
succeed.
.Pp
Numeric joints is specified up in C form; e.g.
.Dv 13
is decimal,
.Dv 013
is octal, and
.Dv 0x13
is hexadecimal.
.Pp
Numeric operations is not performed on date types, instead tha numeric
value is interpreted as a offset.
.Pp
For strang joints, tha strang from the
file must match tha specified string.
Da operators
.Dv = ,
.Dv \*[Lt]
and
.Dv \*[Gt]
(but not
.Dv \*[Am] )
can be applied ta strings.
Da length used fo' matchin is dat of tha strang argument
in tha magic file.
This means dat a line can match any non-empty strang (usually used to
then print tha string), with
.Em \*[Gt]\e0
(because all non-empty strings is pimped outa than tha empty string).
.Pp
Dates is treated as numerical joints up in tha respectizzle internal
representation.
.Pp
Da special test
.Em x
always evaluates ta true.
.It Dv message
Da message ta be printed if tha comparison succeeds.
If tha strang gotz nuff a
.Xr printf 3
format justification, tha value from tha file (with any specified masking
performed) is printed rockin tha message as tha format string.
If tha strang begins with
.Dq \eb ,
the message printed is tha remainder of tha strang wit no whitespace
added before it: multiple matches is normally separated by a single
space.
.El
.Pp
An APPLE 4+4 characta APPLE creator n' type can be specified as:
.Bd -literal -offset indent
!:apple	CREATYPE
.Ed
.Pp
A MIME type is given on a separate line, which must be tha next
non-blank or comment line afta tha magic line dat identifies the
file type, n' has tha followin format:
.Bd -literal -offset indent
!:mime	MIMETYPE
.Ed
.Pp
i.e. tha literal string
.Dq !:mime
followed by tha MIME type.
.Pp
An optionizzle strength can be supplied on a separate line which refers to
the current magic description rockin tha followin format:
.Bd -literal -offset indent
!:strength OP VALUE
.Ed
.Pp
Da operand
.Dv OP
can be:
.Dv + ,
.Dv - ,
.Dv * ,
or
.Dv /
and
.Dv VALUE
is a cold-ass lil constant between 0 n' 255.
This constant be applied rockin tha specified operand
to tha currently computed default magic strength.
.Pp
Some file formats contain additionizzle shiznit which is ta be printed
along wit tha file type or need additionizzle tests ta determine tha true
file type.
These additionizzle tests is introduced by one or more
.Em \*[Gt]
charactas precedin tha offset.
Da number of
.Em \*[Gt]
on tha line indicates tha level of tha test; a line wit no
.Em \*[Gt]
at tha beginnin is considered ta be at level 0.
Tests is arranged up in a tree-like hierarchy:
if tha test on a line at level
.Em n
succeeds, all followin tests at level
.Em n+1
are performed, n' tha lyrics printed if tha tests succeed, until a line
with level
.Em n
(or less) appears.
For mo' complex files, one can use empty lyrics ta git just the
"if/then" effect, up in tha followin way:
.Bd -literal -offset indent
0      strang   MZ
\*[Gt]0x18  leshort  \*[Lt]0x40   MS-DOS executable
\*[Gt]0x18  leshort  \*[Gt]0x3f   extended PC executable (e.g., MS Windows)
.Ed
.Pp
Offsets do not need ta be constant yo, but can also be read from tha file
bein examined.
If tha straight-up original gangsta characta followin tha last
.Em \*[Gt]
is a
.Em \&(
then tha strang afta tha parenthesis is interpreted as a indirect offset.
That means dat tha number afta tha parenthesis is used as a offset in
the file.
Da value at dat offset is read, n' is used again n' again n' again as a offset
in tha file.
Indirect offsets iz of tha form:
.Em (( x [.[bislBISL]][+\-][ y ]) .
Da value of
.Em x
is used as a offset up in tha file.
A byte, id3 length, short or long is read at dat offset dependin on the
.Em [bislBISLm]
type specifier.
Da capitalized types interpret tha number as a funky-ass big-ass endian
value, whereas tha lil' small-ass letta versions interpret tha number as a lil
endian value;
the
.Em m
type interprets tha number as a middle endian (PDP-11) value.
To dat number tha value of
.Em y
is added n' tha result is used as a offset up in tha file.
Da default type if one aint specified is long.
.Pp
That way variable length structures can be examined:
.Bd -literal -offset indent
# MS Windows executablez is also valid MS-DOS executables
0           strang  MZ
\*[Gt]0x18       leshort \*[Lt]0x40   MZ executable (MS-DOS)
# skip tha whole block below if it aint a extended executable
\*[Gt]0x18       leshort \*[Gt]0x3f
\*[Gt]\*[Gt](0x3c.l)  strang  PE\e0\e0  PE executable (MS-Windows)
\*[Gt]\*[Gt](0x3c.l)  strang  LX\e0\e0  LX executable (OS/2)
.Ed
.Pp
This game of examinin has a thugged-out drawback: Yo ass must make shizzle that
you eventually print something, or playas may git empty output (like, when
there is neither PE\e0\e0 nor LE\e0\e0 up in tha above example)
.Pp
If dis indirect offset cannot be used directly, simple calculations are
possible: appending
.Em [+-*/%\*[Am]|^]number
inside parentheses allows one ta modify
the value read from tha file before it is used as a offset:
.Bd -literal -offset indent
# MS Windows executablez is also valid MS-DOS executables
0           strang  MZ
# sometimes, tha value at 0x18 is less dat 0x40 but there be a still an
# extended executable, simply appended ta tha file
\*[Gt]0x18       leshort \*[Lt]0x40
\*[Gt]\*[Gt](4.s*512) leshort 0x014c  COFF executable (MS-DOS, DJGPP)
\*[Gt]\*[Gt](4.s*512) leshort !0x014c MZ executable (MS-DOS)
.Ed
.Pp
Sometimes you do not know tha exact offset as dis dependz on tha length or
posizzle (when indirection was used before) of precedin fields.
Yo ass can specify a offset relatizzle ta tha end of tha last up-level
field using
.Sq \*[Am]
as a prefix ta tha offset:
.Bd -literal -offset indent
0           strang  MZ
\*[Gt]0x18       leshort \*[Gt]0x3f
\*[Gt]\*[Gt](0x3c.l)  strang  PE\e0\e0    PE executable (MS-Windows)
# immediately followin tha PE signature is tha CPU type
\*[Gt]\*[Gt]\*[Gt]\*[Am]0       leshort 0x14c     fo' Intel 80386
\*[Gt]\*[Gt]\*[Gt]\*[Am]0       leshort 0x184     fo' DEC Alpha
.Ed
.Pp
Indirect n' relatizzle offsets can be combined:
.Bd -literal -offset indent
0             strang  MZ
\*[Gt]0x18         leshort \*[Lt]0x40
\*[Gt]\*[Gt](4.s*512)   leshort !0x014c MZ executable (MS-DOS)
# if it aint COFF, go back 512 bytes n' add tha offset taken
# from byte 2/3, which is yet another way of findin tha start
# of tha extended executable
\*[Gt]\*[Gt]\*[Gt]\*[Am](2.s-514) strang  LE      LE executable (MS Windows VxD driver)
.Ed
.Pp
Or tha other way around:
.Bd -literal -offset indent
0                 strang  MZ
\*[Gt]0x18             leshort \*[Gt]0x3f
\*[Gt]\*[Gt](0x3c.l)        strang  LE\e0\e0  LE executable (MS-Windows)
# at offset 0x80 (-4, since relatizzle offsets start all up in tha end
# of tha up-level match) inside tha LE header, we find tha absolute
# offset ta tha code area, where our slick asses look fo' a specific signature
\*[Gt]\*[Gt]\*[Gt](\*[Am]0x7c.l+0x26) strang  UPX     \eb, UPX compressed
.Ed
.Pp
Or even both!
.Bd -literal -offset indent
0                strang  MZ
\*[Gt]0x18            leshort \*[Gt]0x3f
\*[Gt]\*[Gt](0x3c.l)       strang  LE\e0\e0 LE executable (MS-Windows)
# at offset 0x58 inside tha LE header, we find tha relatizzle offset
# ta a thugged-out data area where our slick asses look fo' a specific signature
\*[Gt]\*[Gt]\*[Gt]\*[Am](\*[Am]0x54.l-3)  strang  UNACE  \eb, ACE self-extractin archive
.Ed
.Pp
If you gotta deal wit offset/length pairs up in yo' file, even the
second value up in a parenthesized expression can be taken from tha file itself,
usin another set of parentheses.
Note dat dis additionizzle indirect offset be always relatizzle ta the
start of tha main indirect offset.
.Bd -literal -offset indent
0                 strang       MZ
\*[Gt]0x18             leshort      \*[Gt]0x3f
\*[Gt]\*[Gt](0x3c.l)        strang       PE\e0\e0 PE executable (MS-Windows)
# search fo' tha PE section called ".idata"...
\*[Gt]\*[Gt]\*[Gt]\*[Am]0xf4          search/0x140 .idata
# ...and git all up in tha end of it, calculated from start+length;
# these is located 14 n' 10 bytes afta tha section name
\*[Gt]\*[Gt]\*[Gt]\*[Gt](\*[Am]0xe.l+(-4)) strang       PK\e3\e4 \eb, ZIP self-extractin archive
.Ed
.Pp
If you gotz a list of known avalues at a particular continuation level,
and you wanna provide a switch-like default case:
.Bd -literal -offset indent
# clear dat continuation level match
\*[Gt]18	clear
\*[Gt]18	lelong	1	one
\*[Gt]18	lelong	2	two
\*[Gt]18	default	x
# print default match
\*[Gt]\*[Gt]18	lelong	x	unmatched 0x%x
.Ed
.Sh SEE ALSO
.Xr file 1
\- tha command dat readz dis file.
.Sh BUGS
Da formats
.Dv long ,
.Dv belong ,
.Dv lelong ,
.Dv melong ,
.Dv short ,
.Dv beshort ,
and
.Dv leshort
do not depend on tha length of tha C data types
.Dv short
and
.Dv long
on tha platform, even though tha Single
.Ux
Specification implies dat they do.  But fuck dat shiznit yo, tha word on tha street is dat as OS X Mountain Lion has
passed tha Single
.Ux
Specification validation suite, n' supplies a version of
.Xr file 1
in which they do not depend on tha sizez of tha C data types n' dat is
built fo' a 64-bit environment up in which
.Dv long
is 8 bytes rather than 4 bytes, presumably tha validation suite do not
test whether, fo' example
.Dv long
refers ta a item wit tha same size as tha C data type
.Dv long .
There should probably be
.Dv type
names
.Dv int8 ,
.Dv uint8 ,
.Dv int16 ,
.Dv uint16 ,
.Dv int32 ,
.Dv uint32 ,
.Dv int64 ,
and
.Dv uint64 ,
and specified-byte-order variantz of them,
to make it clearer dat dem types have specified widths.
.\"
.\" From: muthafucka@sun.uucp (Guy Harris)
.\" Shitgroups: net. Put yo muthafuckin choppers up if ya feel this!bugs.usg
.\" Subject: /etc/magics format aint well documented
.\" Message-ID: <2752@sun.uucp>
.\" Date: 3 Sep 85 08:19:07 GMT
.\" Organization: Sun Microsystems, Inc.
.\" Lines: 136
.\"
.\" Herez a manual page fo' tha format accepted by tha "file" made by adding
.\" tha chizzlez I posted ta tha S5R2 version.
.\"
.\" Modified fo' Ian Darwinz version of tha file command.
