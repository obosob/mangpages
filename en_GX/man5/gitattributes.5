'\" t
.\"     Title: gitattributes
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 10/25/2014
.\"    Manual: Git Manual
.\"    Source: Git 1.9.3
.\"  Language: Gangsta
.\"
.TH "GITATTRIBUTES" "5" "10/25/2014" "Git 1\&.9\&.3" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
gitattributes \- definin attributes per path
.SH "SYNOPSIS"
.sp
$GIT_DIR/info/attributes, \&.gitattributes
.SH "DESCRIPTION"
.sp
A gitattributes file be a simple text file dat gives attributes ta pathnames\&.
.sp
Each line up in gitattributes file iz of form:
.sp
.if n \{\
.RS 4
.\}
.nf
pattern attr1 attr2 \&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
That is, a pattern followed by a attributes list, separated by whitespaces\&. When tha pattern matches tha path up in question, tha attributes listed on tha line is given ta tha path\&.
.sp
Each attribute can be up in one of these states fo' a given path:
.PP
Set
.RS 4
Da path has tha attribute wit special value "true"; dis is specified by listin only tha name of tha attribute up in tha attribute list\&.
.RE
.PP
Unset
.RS 4
Da path has tha attribute wit special value "false"; dis is specified by listin tha name of tha attribute prefixed wit a thugged-out dash
\-
in tha attribute list\&.
.RE
.PP
Set ta a value
.RS 4
Da path has tha attribute wit specified strang value; dis is specified by listin tha name of tha attribute followed by a equal sign
=
and its value up in tha attribute list\&.
.RE
.PP
Unspecified
.RS 4
No pattern matches tha path, n' not a god damn thang say if tha path has or aint gots tha attribute, tha attribute fo' tha path is holla'd ta be Unspecified\&.
.RE
.sp
When mo' than one pattern matches tha path, a lata line overrides a earlier line\&. This overridin is done per attribute\&. Da rulez how tha fuck tha pattern matches paths is tha same as up in \&.gitignore files; peep \fBgitignore\fR(5)\&. Unlike \&.gitignore, wack patterns is forbidden\&.
.sp
When decidin what tha fuck attributes is assigned ta a path, Git consults $GIT_DIR/info/attributes file (which has tha highest precedence), \&.gitattributes file up in tha same directory as tha path up in question, n' its parent directories up ta tha toplevel of tha work tree (the further tha directory dat gotz nuff \&.gitattributes is from tha path up in question, tha lower its precedence)\&. Finally global n' system\-wide filez is considered (they have tha lowest precedence)\&.
.sp
When tha \&.gitattributes file is missin from tha work tree, tha path up in tha index is used as a gangbangin' fall\-back\&. Durin checkout process, \&.gitattributes up in tha index is used n' then tha file up in tha hustlin tree is used as a gangbangin' fall\-back\&.
.sp
If you wish ta affect only a single repository (i\&.e\&., ta assign attributes ta filez dat is particular ta one user\(cqs workflow fo' dat repository), then attributes should be placed up in tha $GIT_DIR/info/attributes file\& fo' realz. Attributes which should be version\-controlled n' distributed ta other repositories (i\&.e\&., attributez of interest ta all users) should go tha fuck into \&.gitattributes files\& fo' realz. Attributes dat should affect all repositories fo' a single user should be placed up in a gangbangin' file specified by tha core\&.attributesfile configuration option (see \fBgit-config\fR(1))\&. Its default value is $XDG_CONFIG_HOME/git/attributes\&. If $XDG_CONFIG_HOME is either not set or empty, $HOME/\&.config/git/attributes is used instead\& fo' realz. Attributes fo' all playas on a system should be placed up in tha $(prefix)/etc/gitattributes file\&.
.sp
Sometimes you would need ta override a settin of a attribute fo' a path ta Unspecified state\&. This can be done by listin tha name of tha attribute prefixed wit a exclamation point !\&.
.SH "EFFECTS"
.sp
Certain operations by Git can be hyped up by assignin particular attributes ta a path\&. Currently, tha followin operations is attributes\-aware\&.
.SS "Checking\-out n' checking\-in"
.sp
These attributes affect how tha fuck tha contents stored up in tha repository is copied ta tha hustlin tree filez when commandz like fuckin \fIgit checkout\fR n' \fIgit merge\fR run\&. They also affect how tha fuck Git stores tha contents you prepare up in tha hustlin tree up in tha repository upon \fIgit add\fR n' \fIgit commit\fR\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBtext\fR
.RS 4
.sp
This attribute enablez n' controls end\-of\-line normalization\&. When a text file is normalized, its line endings is converted ta LF up in tha repository\&. To control what tha fuck line endin steez is used up in tha hustlin directory, use tha eol attribute fo' a single file n' tha core\&.eol configuration variable fo' all text files\&.
.PP
Set
.RS 4
Settin the
text
attribute on a path enablez end\-of\-line normalization n' marks tha path as a text file\&. End\-of\-line conversion takes place without guessin tha content type\&.
.RE
.PP
Unset
.RS 4
Unsettin the
text
attribute on a path  drops some lyrics ta Git not ta attempt any end\-of\-line conversion upon checkin or checkout\&.
.RE
.PP
Set ta strang value "auto"
.RS 4
When
text
is set ta "auto", tha path is marked fo' automatic end\-of\-line normalization\&. If Git decides dat tha content is text, its line endings is normalized ta LF on checkin\&.
.RE
.PP
Unspecified
.RS 4
If the
text
attribute is unspecified, Git uses the
core\&.autocrlf
configuration variable ta determine if tha file should be converted\&.
.RE
.sp
Any other value causes Git ta act as if text has been left unspecified\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBeol\fR
.RS 4
.sp
This attribute sets a specific line\-endin steez ta be used up in tha hustlin directory\&. Well shiiiit, it enablez end\-of\-line normalization without any content checks, effectively settin tha text attribute\&.
.PP
Set ta strang value "crlf"
.RS 4
This settin forces Git ta normalize line endings fo' dis file on checkin n' convert dem ta CRLF when tha file is checked out\&.
.RE
.PP
Set ta strang value "lf"
.RS 4
This settin forces Git ta normalize line endings ta LF on checkin n' prevents conversion ta CRLF when tha file is checked out\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBBackwardz compatibilitizzle wit crlf attribute\fR
.RS 4
.sp
For backwardz compatibility, tha crlf attribute is interpreted as bigs up:
.sp
.if n \{\
.RS 4
.\}
.nf
crlf            text
\-crlf           \-text
crlf=input      eol=lf
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBEnd-of-line conversion\fR
.RS 4
.sp
While Git normally leaves file contents alone, it can be configured ta normalize line endings ta LF up in tha repository and, optionally, ta convert dem ta CRLF when filez is checked out\&.
.sp
Here be a example dat will make Git normalize \&.txt, \&.vcproj n' \&.sh files, ensure dat \&.vcproj filez have CRLF n' \&.sh filez have LF up in tha hustlin directory, n' prevent \&.jpg filez from bein normalized regardless of they content\&.
.sp
.if n \{\
.RS 4
.\}
.nf
*\&.txt           text
*\&.vcproj        eol=crlf
*\&.sh            eol=lf
*\&.jpg           \-text
.fi
.if n \{\
.RE
.\}
.sp
.sp
Other source code pimpment systems normalize all text filez up in they repositories, n' there be two ways ta enable similar automatic normalization up in Git\&.
.sp
If you simply wanna have CRLF line endings up in yo' hustlin directory regardless of tha repository yo ass is hustlin with, you can set tha config variable "core\&.autocrlf" without changin any attributes\&.
.sp
.if n \{\
.RS 4
.\}
.nf
[core]
        autocrlf = true
.fi
.if n \{\
.RE
.\}
.sp
.sp
This do not force normalization of all text filez yo, but do ensure dat text filez dat you introduce ta tha repository have they line endings normalized ta LF when they is added, n' dat filez dat is already normalized up in tha repository stay normalized\&.
.sp
If you wanna interoperate wit a source code pimpment system dat enforces end\-of\-line normalization, or you simply want all text filez up in yo' repository ta be normalized, you should instead set tha text attribute ta "auto" fo' \fIall\fR files\&.
.sp
.if n \{\
.RS 4
.\}
.nf
*       text=auto
.fi
.if n \{\
.RE
.\}
.sp
.sp
This ensures dat all filez dat Git considaz ta be text gonna git normalized (LF) line endings up in tha repository\&. Da core\&.eol configuration variable controls which line endings Git will use fo' normalized filez up in yo' hustlin directory; tha default is ta use tha natizzle line endin fo' yo' platform, or CRLF if core\&.autocrlf is set\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
When text=auto normalization is enabled up in a existin repository, any text filez containin CRLFs should be normalized\&. If they is not they is ghon be normalized tha next time one of mah thugs tries ta chizzle them, causin fucked up misattribution\&. From a cold-ass lil clean hustlin directory:
.sp .5v
.RE
.sp
.if n \{\
.RS 4
.\}
.nf
$ echo "* text=auto" >>\&.gitattributes
$ rm \&.git/index     # Remove tha index ta force Git to
$ git reset         # re\-scan tha hustlin directory
$ git status        # Show filez dat is ghon be normalized
$ git add \-u
$ git add \&.gitattributes
$ git commit \-m "Introduce end\-of\-line normalization"
.fi
.if n \{\
.RE
.\}
.sp
.sp
If any filez dat should not be normalized show up in \fIgit status\fR, unset they text attribute before hustlin \fIgit add \-u\fR\&.
.sp
.if n \{\
.RS 4
.\}
.nf
manual\&.pdf      \-text
.fi
.if n \{\
.RE
.\}
.sp
.sp
Conversely, text filez dat Git do not detect can have normalization enabled manually\&.
.sp
.if n \{\
.RS 4
.\}
.nf
weirdchars\&.txt  text
.fi
.if n \{\
.RE
.\}
.sp
.sp
If core\&.safecrlf is set ta "true" or "warn", Git verifies if tha conversion is reversible fo' tha current settin of core\&.autocrlf\&. For "true", Git rejects irreversible conversions; fo' "warn", Git only prints a warnin but accepts a irreversible conversion\&. Da safety triggers ta prevent such a cold-ass lil conversion done ta tha filez up in tha work tree yo, but there be all dem exceptions\&. Even though\&...
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIgit add\fR
itself do not bust a nut on tha filez up in tha work tree, tha next checkout would, so tha safety triggers;
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIgit apply\fR
to update a text file wit a patch do bust a nut on tha filez up in tha work tree yo, but tha operation be bout text filez n' CRLF conversion be bout fixin tha line endin inconsistencies, so tha safety do not trigger;
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIgit diff\fR
itself do not bust a nut on tha filez up in tha work tree, it is often run ta inspect tha chizzlez you intend ta next
\fIgit add\fR\&. To catch potential problems early, safety triggers\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBident\fR
.RS 4
.sp
When tha attribute ident is set fo' a path, Git replaces $Id$ up in tha blob object wit $Id:, followed by tha 40\-characta hexadecimal blob object name, followed by a thugged-out dollar sign $ upon checkout\& fo' realz. Any byte sequence dat begins wit $Id: n' endz wit $ up in tha worktree file is replaced wit $Id$ upon check\-in\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBfilter\fR
.RS 4
.sp
A filta attribute can be set ta a strang value dat names a gangbangin' filta driver specified up in tha configuration\&.
.sp
A filta driver consistz of a cold-ass lil clean command n' a smudge command, either of which can be left unspecified\&. Upon checkout, when tha smudge command is specified, tha command is fed tha blob object from its standard input, n' its standard output is used ta update tha worktree file\&. Right back up in yo muthafuckin ass. Similarly, tha clean command is used ta convert tha contentz of worktree file upon checkin\&.
.sp
One use of tha content filterin is ta massage tha content tha fuck into a gangbangin' finger-lickin' dirty-ass shape dat is mo' convenient fo' tha platform, filesystem, n' tha user ta use\&. For dis mode of operation, tha key phrase here is "more convenient" n' not "turnin suttin' unusable tha fuck into usable"\&. In other lyrics, tha intent is dat if one of mah thugs unsets tha filta driver definition, or aint gots tha appropriate filta program, tha project should still be usable\&.
.sp
Another use of tha content filterin is ta store tha content dat cannot be directly used up in tha repository (e\&.g\&. a UUID dat refers ta tha legit content stored outside Git, or a encrypted content) n' turn it tha fuck into a usable form upon checkout (e\&.g\&. downlizzle tha external content, or decrypt tha encrypted content)\&.
.sp
These two filtas behave differently, n' by default, a gangbangin' filta is taken as tha former, massagin tha contents tha fuck into mo' convenient shape\& fo' realz. A missin filta driver definizzle up in tha config, or a gangbangin' filta driver dat exits wit a non\-zero status, aint a error but make tha filta a no\-op passthru\&.
.sp
Yo ass can declare dat a gangbangin' filta turns a cold-ass lil content dat by itself is unusable tha fuck into a usable content by settin tha filter\&.<driver>\&.required configuration variable ta true\&.
.sp
For example, up in \&.gitattributes, you would assign tha filta attribute fo' paths\&.
.sp
.if n \{\
.RS 4
.\}
.nf
*\&.c     filter=indent
.fi
.if n \{\
.RE
.\}
.sp
.sp
Then you would define a "filter\&.indent\&.clean" n' "filter\&.indent\&.smudge" configuration up in yo' \&.git/config ta specify a pair of commandz ta modify tha contentz of C programs when tha source filez is checked up in ("clean" is run) n' checked up (no chizzle is made cuz tha command is "cat")\&.
.sp
.if n \{\
.RS 4
.\}
.nf
[filta "indent"]
        clean = indent
        smudge = cat
.fi
.if n \{\
.RE
.\}
.sp
.sp
For dopest thangs up in dis biatch, clean should not alta its output further if it is run twice ("clean\(->clean" should be equivalent ta "clean"), n' multiple smudge commandz should not alta clean\(aqs output ("smudge\(->smudge\(->clean" should be equivalent ta "clean")\&. Right back up in yo muthafuckin ass. See tha section on mergin below\&.
.sp
Da "indent" filta is well\-behaved up in dis regard: it aint gonna modify input dat be already erectly indented\&. In dis case, tha lack of a smudge filta means dat tha clean filta \fImust\fR accept its own output without modifyin it\&.
.sp
If a gangbangin' filta \fImust\fR succeed up in order ta make tha stored contents usable, you can declare dat tha filta is required, up in tha configuration:
.sp
.if n \{\
.RS 4
.\}
.nf
[filta "crypt"]
        clean = openssl enc \&.\&.\&.
        smudge = openssl enc \-d \&.\&.\&.
        required
.fi
.if n \{\
.RE
.\}
.sp
.sp
Sequence "%f" on tha filta command line is replaced wit tha name of tha file tha filta is hustlin on\& fo' realz. A filta might use dis up in keyword substitution\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
[filta "p4"]
        clean = git\-p4\-filta \-\-clean %f
        smudge = git\-p4\-filta \-\-smudge %f
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBInteraction between checkin/checkout attributes\fR
.RS 4
.sp
In tha check\-in codepath, tha worktree file is first converted wit filta driver (if specified n' correspondin driver defined), then tha result is processed wit ident (if specified), n' then finally wit text (again, if specified n' applicable)\&.
.sp
In tha check\-out codepath, tha blob content is first converted wit text, n' then ident n' fed ta filter\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMergin branches wit differin checkin/checkout attributes\fR
.RS 4
.sp
If you have added attributes ta a gangbangin' file dat cause tha canonical repository format fo' dat file ta chizzle, like fuckin addin a cold-ass lil clean/smudge filta or text/eol/ident attributes, mergin anythang where tha attribute aint up in place would normally cause merge conflicts\&.
.sp
To prevent these unnecessary merge conflicts, Git can be holla'd at ta run a virtual check\-out n' check\-in of all three stagez of a gangbangin' file when resolvin a three\-way merge by settin tha merge\&.renormalize configuration variable\&. This prevents chizzlez caused by check\-in conversion from causin spurious merge conflicts when a cold-ass lil converted file is merged wit a unconverted file\&.
.sp
As long as a "smudge\(->clean" thangs up in dis biatch up in tha same output as a "clean" even on filez dat is already smudged, dis game will automatically resolve all filter\-related conflicts\&. Filtas dat do not act up in dis way may cause additionizzle merge conflicts dat must be resolved manually\&.
.RE
.SS "Generatin diff text"
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBdiff\fR
.RS 4
.sp
Da attribute diff affects how tha fuck Git generates diffs fo' particular files\&. Well shiiiit, it can tell Git whether ta generate a textual patch fo' tha path or ta treat tha path as a funky-ass binary file\&. Well shiiiit, it can also affect what tha fuck line is shown on tha hunk header @@ \-k,l +n,m @@ line, tell Git ta use a external command ta generate tha diff, or ask Git ta convert binary filez ta a text format before generatin tha diff\&.
.PP
Set
.RS 4
A path ta which the
diff
attribute is set is treated as text, even when they contain byte joints dat normally never step tha fuck up in text files, like fuckin NUL\&.
.RE
.PP
Unset
.RS 4
A path ta which the
diff
attribute is unset will generate
Binary filez differ
(or a funky-ass binary patch, if binary patches is enabled)\&.
.RE
.PP
Unspecified
.RS 4
A path ta which the
diff
attribute is unspecified first gets its contents inspected, n' if it be lookin like text, it is treated as text\&. Otherwise it would generate
Binary filez differ\&.
.RE
.PP
String
.RS 4
Diff is shown rockin tha specified diff driver\&. Each driver may specify one or mo' options, as busted lyrics bout up in tha followin section\&. Da options fo' tha diff driver "foo" is defined by tha configuration variablez up in tha "diff\&.foo" section of tha Git config file\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBDefinin a external diff driver\fR
.RS 4
.sp
Da definizzle of a gangbangin' finger-lickin' diff driver is done up in gitconfig, not gitattributes file, so strictly bustin lyrics dis manual page be a wack place ta rap bout it\& yo. However\&...
.sp
To define a external diff driver jcdiff, add a section ta yo' $GIT_DIR/config file (or $HOME/\&.gitconfig file) like this:
.sp
.if n \{\
.RS 4
.\}
.nf
[diff "jcdiff"]
        command = j\-c\-diff
.fi
.if n \{\
.RE
.\}
.sp
.sp
When Git need ta show you a gangbangin' finger-lickin' diff fo' tha path wit diff attribute set ta jcdiff, it calls tha command you specified wit tha above configuration, i\&.e\&. j\-c\-diff, wit 7 parameters, just like GIT_EXTERNAL_DIFF program is called\&. Right back up in yo muthafuckin ass. See \fBgit\fR(1) fo' details\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBDefinin a cold-ass lil custom hunk-header\fR
.RS 4
.sp
Each crew of chizzlez (called a "hunk") up in tha textual diff output is prefixed wit a line of tha form:
.sp
.if n \{\
.RS 4
.\}
.nf
@@ \-k,l +n,m @@ TEXT
.fi
.if n \{\
.RE
.\}
.sp
This is called a \fIhunk header\fR\&. Da "TEXT" portion is by default a line dat begins wit a alphabet, a underscore or a thugged-out dollar sign; dis matches what tha fuck GNU \fIdiff \-p\fR output uses\&. This default selection however aint suited fo' some contents, n' you can bust a cold-ass lil customized pattern ta cook up a selection\&.
.sp
First, up in \&.gitattributes, you would assign tha diff attribute fo' paths\&.
.sp
.if n \{\
.RS 4
.\}
.nf
*\&.tex   diff=tex
.fi
.if n \{\
.RE
.\}
.sp
.sp
Then, you would define a "diff\&.tex\&.xfuncname" configuration ta specify a regular expression dat matches a line dat you would wanna step tha fuck up as tha hunk header "TEXT"\& fo' realz. Add a section ta yo' $GIT_DIR/config file (or $HOME/\&.gitconfig file) like this:
.sp
.if n \{\
.RS 4
.\}
.nf
[diff "tex"]
        xfuncname = "^(\e\e\e\e(sub)*section\e\e{\&.*)$"
.fi
.if n \{\
.RE
.\}
.sp
.sp
Note\& fo' realz. A single level of backslashes is smoked by tha configuration file parser, so you would need ta double tha backslashes; tha pattern above picks a line dat begins wit a funky-ass backslash, n' zero or mo' occurrencez of sub followed by section followed by open brace, ta tha end of line\&.
.sp
There is all dem built\-in patterns ta make dis easier, n' tex is one of them, so you do not gotta write tha above up in yo' configuration file (you still need ta enable dis wit tha attribute mechanism, via \&.gitattributes)\&. Da followin built up in patterns is available:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ada
suitable fo' source code up in tha Ada language\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
bibtex
suitable fo' filez wit BibTeX coded references\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
cpp
suitable fo' source code up in tha C n' C++ languages\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
csharp
suitable fo' source code up in tha C# language\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
fortran
suitable fo' source code up in tha Fortran language\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
html
suitable fo' HTML/XHTML documents\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
java
suitable fo' source code up in tha Java language\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
matlab
suitable fo' source code up in tha MATLAB language\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
objc
suitable fo' source code up in tha Objective\-C language\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
pascal
suitable fo' source code up in tha Pascal/Delphi language\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
perl
suitable fo' source code up in tha Perl language\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
php
suitable fo' source code up in tha PHP language\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
python
suitable fo' source code up in tha Python language\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ruby
suitable fo' source code up in tha Ruby language\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
tex
suitable fo' source code fo' LaTeX documents\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBCustomizin word diff\fR
.RS 4
.sp
Yo ass can customize tha rulez dat git diff \-\-word\-diff uses ta split lyrics up in a line, by specifyin a appropriate regular expression up in tha "diff\&.*\&.wordRegex" configuration variable\&. For example, up in TeX a funky-ass backslash followed by a sequence of lettas forms a cold-ass lil command yo, but nuff muthafuckin such commandz can be run together without intervenin whitespace\&. To separate them, bust a regular expression up in yo' $GIT_DIR/config file (or $HOME/\&.gitconfig file) like this:
.sp
.if n \{\
.RS 4
.\}
.nf
[diff "tex"]
        wordRegex = "\e\e\e\e[a\-zA\-Z]+|[{}]|\e\e\e\e\&.|[^\e\e{}[:space:]]+"
.fi
.if n \{\
.RE
.\}
.sp
.sp
A built\-in pattern is provided fo' all languages listed up in tha previous section\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBPerformin text diffz of binary files\fR
.RS 4
.sp
Sometimes it is desirable ta peep tha diff of a text\-converted version of some binary files\&. For example, a word processor document can be converted ta a ASCII text representation, n' tha diff of tha text shown\&. Even though dis conversion loses some shiznit, tha resultin diff is useful fo' human viewin (but cannot be applied directly)\&.
.sp
Da textconv config option is used ta define a program fo' struttin such a cold-ass lil conversion\&. Da program should take a single argument, tha name of a gangbangin' file ta convert, n' produce tha resultin text on stdout\&.
.sp
For example, ta show tha diff of tha exif shiznit of a gangbangin' file instead of tha binary shiznit (assumin you have tha exif tool installed), add tha followin section ta yo' $GIT_DIR/config file (or $HOME/\&.gitconfig file):
.sp
.if n \{\
.RS 4
.\}
.nf
[diff "jpg"]
        textconv = exif
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
Da text conversion is generally a one\-way conversion; up in dis example, our slick asses lose tha actual image contents n' focus just on tha text data\&. This means dat diffs generated by textconv is \fInot\fR suitable fo' applying\&. For dis reason, only git diff n' tha git log crew of commandz (i\&.e\&., log, whatchanged, show) will big-ass up text conversion\&. git format\-patch aint NEVER gonna generate dis output\&. If you wanna bust some muthafucka a text\-converted diff of a funky-ass binary file (e\&.g\&., cuz it quickly conveys tha chizzlez you have made), you should generate it separately n' bust it as a cold-ass lil comment \fIin addizzle to\fR tha usual binary diff dat you might send\&.
.sp .5v
.RE
.sp
Because text conversion can be slow, especially when bustin a big-ass number of dem wit git log \-p, Git serves up a mechanizzle ta cache tha output n' use it up in future diffs\&. To enable caching, set tha "cachetextconv" variable up in yo' diff driver\(cqs config\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
[diff "jpg"]
        textconv = exif
        cachetextconv = true
.fi
.if n \{\
.RE
.\}
.sp
.sp
This will cache tha result of hustlin "exif" on each blob indefinitely\&. If you chizzle tha textconv config variable fo' a gangbangin' finger-lickin' diff driver, Git will automatically invalidate tha cache entries n' re\-run tha textconv filter\&. If you wanna invalidate tha cache manually (e\&.g\&., cuz yo' version of "exif" was updated n' now produces betta output), you can remove tha cache manually wit git update\-ref \-d refs/notes/textconv/jpg (where "jpg" is tha name of tha diff driver, as up in tha example above)\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBChoosin textconv versus external diff\fR
.RS 4
.sp
If you wanna show differences between binary or specially\-formatted blobs up in yo' repository, you can chizzle ta use either a external diff command, or ta use textconv ta convert dem ta a gangbangin' finger-lickin' diff\-able text format\&. Which method you chizzle dependz on yo' exact thang\&.
.sp
Da advantage of rockin a external diff command is flexibility\&. Yo ass aint bound ta find line\-oriented chizzles, nor is it necessary fo' tha output ta resemble unified diff\&. Yo ass is free ta locate n' report chizzlez up in da most thugged-out appropriate way fo' yo' data format\&.
.sp
A textconv, by comparison, is much mo' limiting\&. Yo ass provide a transformation of tha data tha fuck into a line\-oriented text format, n' Git uses its regular diff tools ta generate tha output\&. There is nuff muthafuckin advantages ta choosin dis method:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Ease of use\&. Well shiiiit, it is often much simpla ta write a funky-ass binary ta text transformation than it is ta big-ass up yo' own diff\&. In nuff cases, existin programs can be used as textconv filtas (e\&.g\&., exif, odt2txt)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Git diff features\&. By struttin only tha transformation step yo ass, you can still utilize nuff of Git\(cqs diff features, includin colorization, word\-diff, n' combined diffs fo' merges\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
Caching\&. Textconv cachin can speed up repeated diffs, like fuckin dem you might trigger by hustlin
git log \-p\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMarkin filez as binary\fR
.RS 4
.sp
Git probably guesses erectly whether a funky-ass blob gotz nuff text or binary data by examinin tha beginnin of tha contents\&. But fuck dat shiznit yo, tha word on tha street is dat sometimes you may wanna override its decision, either cuz a funky-ass blob gotz nuff binary data lata up in tha file, or cuz tha content, while technologically composed of text characters, is opaque ta a human reader\&. For example, nuff postscript filez contain only ascii charactas yo, but produce noisy n' meaningless diffs\&.
.sp
Da simplest way ta mark a gangbangin' file as binary is ta unset tha diff attribute up in tha \&.gitattributes file:
.sp
.if n \{\
.RS 4
.\}
.nf
*\&.ps \-diff
.fi
.if n \{\
.RE
.\}
.sp
.sp
This will cause Git ta generate Binary filez differ (or a funky-ass binary patch, if binary patches is enabled) instead of a regular diff\&.
.sp
But fuck dat shiznit yo, tha word on tha street is dat one may also wanna specify other diff driver attributes\&. For example, you might wanna use textconv ta convert postscript filez ta a ascii representation fo' human viewin yo, but otherwise treat dem as binary files\&. Yo ass cannot specify both \-diff n' diff=ps attributes\&. Da solution is ta use tha diff\&.*\&.binary config option:
.sp
.if n \{\
.RS 4
.\}
.nf
[diff "ps"]
  textconv = ps2ascii
  binary = true
.fi
.if n \{\
.RE
.\}
.sp
.RE
.SS "Performin a three\-way merge"
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBmerge\fR
.RS 4
.sp
Da attribute merge affects how tha fuck three versionz of a gangbangin' file is merged when a gangbangin' file\-level merge is necessary durin git merge, n' other commandz like fuckin git revert n' git cherry\-pick\&.
.PP
Set
.RS 4
Built\-in 3\-way merge driver is used ta merge tha contents up in a way similar to
\fImerge\fR
command of
RCS
suite\&. This is suitable fo' ordinary text files\&.
.RE
.PP
Unset
.RS 4
Take tha version from tha current branch as tha tentatizzle merge result, n' declare dat tha merge has conflicts\&. This is suitable fo' binary filez dat aint gots a well\-defined merge semantics\&.
.RE
.PP
Unspecified
.RS 4
By default, dis uses tha same ol' dirty built\-in 3\-way merge driver as is tha case when the
merge
attribute is set\&. But fuck dat shiznit yo, tha word on tha street is dat the
merge\&.default
configuration variable can name different merge driver ta be used wit paths fo' which the
merge
attribute is unspecified\&.
.RE
.PP
String
.RS 4
3\-way merge is performed rockin tha specified custom merge driver\&. Da built\-in 3\-way merge driver can be explicitly specified by askin fo' "text" driver; tha built\-in "take tha current branch" driver can be axed wit "binary"\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBBuilt-in merge drivers\fR
.RS 4
.sp
There is all dem built\-in low\-level merge drivers defined dat can be axed fo' via tha merge attribute\&.
.PP
text
.RS 4
Usual 3\-way file level merge fo' text files\&. Conflicted regions is marked wit conflict markers
<<<<<<<,
=======
and
>>>>>>>\&. Da version from yo' branch appears before the
=======
marker, n' tha version from tha merged branch appears afta the
=======
marker\&.
.RE
.PP
binary
.RS 4
Keep tha version from yo' branch up in tha work tree yo, but leave tha path up in tha conflicted state fo' tha user ta sort out\&.
.RE
.PP
union
.RS 4
Run 3\-way file level merge fo' text filez yo, but take lines from both versions, instead of leavin conflict markers\&. This tendz ta leave tha added lines up in tha resultin file up in random order n' tha user should verify tha result\&. Do not use dis if you do not KNOW tha implications\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBDefinin a cold-ass lil custom merge driver\fR
.RS 4
.sp
Da definizzle of a merge driver is done up in tha \&.git/config file, not up in tha gitattributes file, so strictly bustin lyrics dis manual page be a wack place ta rap bout it\& yo. However\&...
.sp
To define a cold-ass lil custom merge driver filfre, add a section ta yo' $GIT_DIR/config file (or $HOME/\&.gitconfig file) like this:
.sp
.if n \{\
.RS 4
.\}
.nf
[merge "filfre"]
        name = feel\-free merge driver
        driver = filfre %O %A %B
        recursive = binary
.fi
.if n \{\
.RE
.\}
.sp
.sp
Da merge\&.*\&.name variable gives tha driver a human\-readable name\&.
.sp
Da \(oqmerge\&.*\&.driver` variable\(cqs value is used ta construct a cold-ass lil command ta run ta merge ancestor\(cqs version (%O), current version (%A) n' tha other branches\(cq version (%B)\&. These three tokens is replaced wit tha namez of temporary filez dat hold tha contentz of these versions when tha command line is built\& fo' realz. Additionally, %L is ghon be replaced wit tha conflict marker size (see below)\&.
.sp
Da merge driver is sposed ta fuckin leave tha result of tha merge up in tha file named wit %A by overwritin it, n' exit wit zero status if it managed ta merge dem cleanly, or non\-zero if there was conflicts\&.
.sp
Da merge\&.*\&.recursive variable specifies what tha fuck other merge driver ta use when tha merge driver is called fo' a internal merge between common ancestors, when there be mo' than one\&. When left unspecified, tha driver itself is used fo' both internal merge n' tha final merge\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBconflict-marker-size\fR
.RS 4
.sp
This attribute controls tha length of conflict markers left up in tha work tree file durin a cold-ass lil conflicted merge\&. Only settin ta tha value ta a positizzle integer has any meaningful effect\&.
.sp
For example, dis line up in \&.gitattributes can be used ta tell tha merge machinery ta leave much longer (instead of tha usual 7\-character\-long) conflict markers when mergin tha file Documentation/git\-merge\&.txt thangs up in dis biatch up in a cold-ass lil conflict\&.
.sp
.if n \{\
.RS 4
.\}
.nf
Documentation/git\-merge\&.txt     conflict\-marker\-size=32
.fi
.if n \{\
.RE
.\}
.sp
.RE
.SS "Checkin whitespace errors"
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBwhitespace\fR
.RS 4
.sp
Da core\&.whitespace configuration variable allows you ta define what tha fuck \fIdiff\fR n' \fIapply\fR should consider whitespace errors fo' all paths up in tha project (See \fBgit-config\fR(1))\&. This attribute gives you finer control per path\&.
.PP
Set
.RS 4
Notice all typez of potential whitespace errors known ta Git\&. Da tab width is taken from tha value of the
core\&.whitespace
configuration variable\&.
.RE
.PP
Unset
.RS 4
Do not notice anythang as error\&.
.RE
.PP
Unspecified
.RS 4
Use tha value of the
core\&.whitespace
configuration variable ta decizzle what tha fuck ta notice as error\&.
.RE
.PP
String
.RS 4
Specify a cold-ass lil comma separate list of common whitespace problems ta notice up in tha same format as the
core\&.whitespace
configuration variable\&.
.RE
.RE
.SS "Creatin a archive"
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBexport-ignore\fR
.RS 4
.sp
Filez n' directories wit tha attribute export\-ignore won\(cqt be added ta archive files\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBexport-subst\fR
.RS 4
.sp
If tha attribute export\-subst is set fo' a gangbangin' file then Git will expand nuff muthafuckin placeholdaz when addin dis file ta a archive\&. Da expansion dependz on tha availabilitizzle of a cold-ass lil commit ID, i\&.e\&., if \fBgit-archive\fR(1) has been given a tree instead of a cold-ass lil commit or a tag then no replacement is ghon be done\&. Da placeholdaz is tha same as dem fo' tha option \-\-pretty=format: of \fBgit-log\fR(1), except dat they need ta be wrapped like this: $Format:PLACEHOLDERS$ up in tha file\&. E\&.g\&. tha strang $Format:%H$ is ghon be replaced by tha commit hash\&.
.RE
.SS "Packin objects"
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBdelta\fR
.RS 4
.sp
Delta compression aint gonna be attempted fo' blobs fo' paths wit tha attribute delta set ta false\&.
.RE
.SS "Viewin filez up in GUI tools"
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBencoding\fR
.RS 4
.sp
Da value of dis attribute specifies tha characta encodin dat should be used by GUI tools (e\&.g\&. \fBgitk\fR(1) n' \fBgit-gui\fR(1)) ta display tha contentz of tha relevant file\&. Note dat cuz of performizzle considerations \fBgitk\fR(1) do not use dis attribute unless you manually enable per\-file encodings up in its options\&.
.sp
If dis attribute aint set or has a invalid value, tha value of tha gui\&.encodin configuration variable is used instead (See \fBgit-config\fR(1))\&.
.RE
.SH "USING MACRO ATTRIBUTES"
.sp
Yo ass do not want any end\-of\-line conversions applied to, nor textual diffs produced for, any binary file you track\&. Yo ass would need ta specify e\&.g\&.
.sp
.if n \{\
.RS 4
.\}
.nf
*\&.jpg \-text \-diff
.fi
.if n \{\
.RE
.\}
.sp
.sp
but dat may become cumbersome, when you have nuff attributes\&. Usin macro attributes, you can define a attribute that, when set, also sets or unsets a fuckin shitload of other attributes all up in tha same time\&. Da system knows a funky-ass built\-in macro attribute, binary:
.sp
.if n \{\
.RS 4
.\}
.nf
*\&.jpg binary
.fi
.if n \{\
.RE
.\}
.sp
.sp
Settin tha "binary" attribute also unsets tha "text" n' "diff" attributes as above\&. Note dat macro attributes can only be "Set", though settin one might have tha effect of settin or unsettin other attributes or even returnin other attributes ta tha "Unspecified" state\&.
.SH "DEFINING MACRO ATTRIBUTES"
.sp
Custom macro attributes can be defined only up in top\-level gitattributes filez ($GIT_DIR/info/attributes, tha \&.gitattributes file all up in tha top level of tha hustlin tree, or tha global or system\-wide gitattributes files), not up in \&.gitattributes filez up in hustlin tree subdirectories\&. Da built\-in macro attribute "binary" is equivalent to:
.sp
.if n \{\
.RS 4
.\}
.nf
[attr]binary \-diff \-merge \-text
.fi
.if n \{\
.RE
.\}
.sp
.SH "EXAMPLE"
.sp
If you have these three gitattributes file:
.sp
.if n \{\
.RS 4
.\}
.nf
(in $GIT_DIR/info/attributes)

a*      foo !bar \-baz

(in \&.gitattributes)
abc     foo bar baz

(in t/\&.gitattributes)
ab*     merge=filfre
abc     \-foo \-bar
*\&.c     frotz
.fi
.if n \{\
.RE
.\}
.sp
.sp
the attributes given ta path t/abc is computed as bigs up:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
By examining
t/\&.gitattributes
(which is up in tha same directory as tha path up in question), Git findz dat tha straight-up original gangsta line matches\&.
merge
attribute is set\&. Well shiiiit, it also findz dat tha second line matches, n' attributes
foo
and
bar
are unset\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Then it examines
\&.gitattributes
(which is up in tha parent directory), n' findz dat tha straight-up original gangsta line matches yo, but
t/\&.gitattributes
file already decided how
merge,
foo
and
bar
attributes should be given ta dis path, so it leaves
foo
and
bar
unset\& fo' realz. Attribute
baz
is set\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
Finally it examines
$GIT_DIR/info/attributes\&. This file is used ta override tha in\-tree settings\&. Da first line be a match, and
foo
is set,
bar
is reverted ta unspecified state, and
baz
is unset\&.
.RE
.sp
As tha result, tha attributes assignment ta t/abc becomes:
.sp
.if n \{\
.RS 4
.\}
.nf
foo     set ta true
bar     unspecified
baz     set ta false
merge   set ta strang value "filfre"
frotz   unspecified
.fi
.if n \{\
.RE
.\}
.sp
.SH "SEE ALSO"
.sp
\fBgit-check-attr\fR(1)\&.
.SH "GIT"
.sp
Part of tha \fBgit\fR(1) suite
