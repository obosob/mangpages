'\" t
.\" DO NOT EDIT THIS FILE BY HAND!
.\" It be generated from terminfo.head, Caps, n' terminfo.tail.
.\"
.\" Note: dis must be run all up in tbl before nroff.
.\" Da magic cookie on tha straight-up original gangsta line triggers dis under some playa programs.
.\"***************************************************************************
.\" Copyright (c) 1998-2012,2013 Jacked Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, ta any thug obtainin a  *
.\" copy of dis software n' associated documentation filez (the            *
.\" "Software"), ta deal up in tha Software without restriction, includin      *
.\" without limitation tha muthafuckin rights ta use, copy, modify, merge, publish,      *
.\" distribute, distribute wit modifications, sublicense, and/or push       *
.\" copiez of tha Software, n' ta permit peeps ta whom tha Software is    *
.\" furnished ta do so, subject ta tha followin conditions:                 *
.\"                                                                          *
.\" Da above copyright notice n' dis permission notice shall be included  *
.\" up in all copies or substantial portionz of tha Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained up in dis notice, tha name(s) of tha above copyright   *
.\" holdaz shall not be used up in advertisin or otherwise ta promote tha     *
.\" sale, use or other dealings up in dis Software without prior freestyled       *
.\" authorization. I aint talkin' bout chicken n' gravy biatch.                                                           *
.\"***************************************************************************
.\"
.\" $Id: terminfo.head,v 1.21 2013/03/09 22:11:36 tom Exp $
.TH terminfo 5 "" "" "File Formats"
.ds n 5
.ds d /usr/share/terminfo
.ie \n(.g .ds `` \(lq
.el       .ds `` ``
.ie \n(.g .ds '' \(rq
.el       .ds '' ''
.de bP
.IP \(bu 4
..
.SH NAME
terminfo \- terminal capabilitizzle data base
.SH SYNOPSIS
\*d/*/*
.SH DESCRIPTION
.I Terminfo
is a thugged-out data base describin terminals, used by screen-oriented programs such as
\fBnvi\fR(1),
\fBrogue\fR(1)
and libraries such as
\fBcurses\fR(3X).
.I Terminfo
raps bout terminals by givin a set of capabilitizzles which they
have, by specifyin how tha fuck ta big-ass up screen operations, n' by
specifyin paddin requirements n' initialization sequences.
This raps bout \fBncurses\fR
version 5.9 (patch 20130511).
.PP
Entries in
.I terminfo
consist of a sequence of `,' separated fieldz (embedded commas may be
escaped wit a funky-ass backslash or notated as \\054).
White space afta tha `,' separator is ignored.
Da first entry fo' each terminal gives tha names which is known fo' the
terminal, separated by `|' characters.
Da first name given is da most thugged-out common abbreviation fo' tha terminal,
the last name given should be a long-ass name straight-up identifyin tha terminal,
and all others is understood as synonyms fo' tha terminal name.
All names but tha last should be up in lower case n' contain no blanks;
the last name may well contain upper case n' blanks fo' readability.
.PP
Lines beginnin wit a `#' up in tha straight-up original gangsta column is treated as comments.
While comment lines is legal at any point, tha output of \fBcaptoinfo\fP
and \fBinfotocap\fP (aliases fo' \fBtic\fP)
will move comments so they occur only between entries.
.PP
Newlines n' leadin tabs may be used fo' formattin entries fo' readability.
These is removed from parsed entries.
Da \fBinfocmp\ \-f\fP option relies on dis ta format if-then-else expressions:
the result can be read by \fBtic\fP.
.PP
Terminal names (except fo' tha last, verbose entry) should
be chosen rockin tha followin conventions.
Da particular piece of hardware makin up tha terminal should
have a root name, thus \*(``hp2621\*(''.
This name should not contain hyphens.
Modes dat tha hardware can be in, or user preferences, should
be indicated by appendin a hyphen n' a mode suffix.
Thus, a vt100 up in 132 column mode would be vt100\-w.
Da followin suffixes should be used where possible:
.PP
.TS
centa ;
l c l
l l l.
\fBSuffix	Meaning	Example\fP
\-\fInn\fP	Number of lines on tha screen	aaa\-60
\-\fIn\fPp	Number of pagez of memory	c100\-4p
\-am	With automargins (usually tha default)	vt100\-am
\-m	Mono mode; suppress color       	ansi\-m
\-mc	Magic cookie; spaces when highlighting	wy30\-mc
\-na	No arrow keys (leave dem up in local)	c100\-na
\-nam	Without automatic margins       	vt100\-nam
\-nl	No status line                  	att4415\-nl
\-ns	No status line                  	hp2626\-ns
\-rv	Reverse vizzle                   	c100\-rv
\-s	Enable status line              	vt100\-s
\-vb	Use visible bell instead of beep	wy370\-vb
\-w	Wide mode (> 80 columns, probably 132)	vt100\-w
.TE
.PP
For mo' on terminal namin conventions, peep tha \fBterm(7)\fR manual page.
.SS Predefined Capabilities
.\" Head of terminfo playa page endz here
.ps -1
Da followin be a cold-ass lil complete table of tha capabilitizzles included up in a
terminfo description block n' available ta terminfo-usin code.  In each
line of tha table,

Da \fBvariable\fR is tha name by which tha programmer (at tha terminfo level)
accesses tha capability.

Da \fBcapname\fR is tha short name used up in tha text of tha database,
and is used by a thug uppimpin tha database.
Whenever possible, capnames is chosen ta be tha same as or similar to
the ANSI X3.64-1979 standard (now superseded by ECMA-48, which uses
identical or straight-up similar names).  Semantics is also intended ta match
those of tha justification.

Da termcap code is tha old
.B termcap
capabilitizzle name (some capabilitizzles is new, n' have names which termcap
did not originate).
.P
Capabilitizzle names have no hard length limit yo, but a informal limit of 5
charactas has been adopted ta keep dem short n' ta allow tha tabs in
the source file
.B Caps
to line up sickly.

Finally, tha description field attempts ta convey tha semantics of the
capability.  Yo ass may find some codes up in tha description field:
.TP
(P)
indicates dat paddin may be specified
.TP
#[1-9]
in tha description field indicates dat tha strang is passed all up in tparm with
parms as given (#\fIi\fP).
.TP
(P*)
indicates dat paddin may vary up in proportion ta tha number of
lines affected
.TP
(#\d\fIi\fP\u)
indicates tha \fIi\fP\uth\d parameter.

.PP
These is tha boolean capabilities:

.na
.TS H
centa expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBVariable	Cap-	TCap	Description\fR
\fBBooleans	name	Code\fR
auto_left_margin	bw	bw	T{
cub1 wraps from column 0 ta last column
T}
auto_right_margin	am	am	T{
terminal has automatic margins
T}
back_color_erase	bce	ut	T{
screen erased wit background color
T}
can_change	ccc	cc	T{
terminal can re-define existin colors
T}
ceol_standout_glitch	xhp	xs	T{
standout not erased by overwritin (hp)
T}
col_addr_glitch	xhpa	YA	T{
only positizzle motion fo' hpa/mhpa caps
T}
cpi_changes_res	cpix	YF	T{
changin characta pitch chizzlez resolution
T}
cr_cancels_micro_mode	crxm	YB	T{
usin cr turns off micro mode
T}
dest_tabs_magic_smso	xt	xt	T{
tabs destructive, magic so char (t1061)
T}
eat_newline_glitch	xenl	xn	T{
newline ignored afta 80 cols (concept)
T}
erase_overstrike	eo	eo	T{
can erase overstrikes wit a funky-ass blank
T}
generic_type	gn	gn	T{
generic line type
T}
hard_copy	hc	hc	T{
hardcopy terminal
T}
hard_cursor	chts	HC	T{
cursor is hard ta see
T}
has_meta_key	km	km	T{
Has a meta key (i.e., sets 8th-bit)
T}
has_print_wheel	daisy	YC	T{
printa needz operator ta chizzle characta set
T}
has_status_line	hs	hs	T{
has extra status line
T}
hue_lightness_saturation	hls	hl	T{
terminal uses only HLS color notation (Tektronix)
T}
insert_null_glitch	in	in	T{
insert mode distinguishes nulls
T}
lpi_changes_res	lpix	YG	T{
changin line pitch chizzlez resolution
T}
memory_above	da	da	T{
display may be retained above tha screen
T}
memory_below	db	db	T{
display may be retained below tha screen
T}
move_insert_mode	mir	mi	T{
safe ta move while up in bang mode
T}
move_standout_mode	msgr	ms	T{
safe ta move while up in standout mode
T}
needs_xon_xoff	nxon	nx	T{
paddin aint gonna work, xon/xoff required
T}
no_esc_ctlc	xsb	xb	T{
beehive (f1=escape, f2=ctrl C)
T}
no_pad_char	npc	NP	T{
pad characta do not exist
T}
non_dest_scroll_region	ndscr	ND	T{
scrollin region is non-destructive
T}
non_rev_rmcup	nrrmc	NR	T{
smcup do not reverse rmcup
T}
over_strike	os	os	T{
terminal can overstrike
T}
prtr_silent	mc5i	5i	T{
printa aint gonna echo on screen
T}
row_addr_glitch	xvpa	YD	T{
only positizzle motion fo' vpa/mvpa caps
T}
semi_auto_right_margin	sam	YE	T{
printin up in last column causes cr
T}
status_line_esc_ok	eslok	es	T{
escape can be used on tha status line
T}
tilde_glitch	hz	hz	T{
cannot print ~z (hazeltine)
T}
transparent_underline	ul	ul	T{
underline characta overstrikes
T}
xon_xoff	xon	xo	T{
terminal uses xon/xoff handbobbin
T}
.TE
.ad

These is tha numeric capabilities:

.na
.TS H
centa expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBVariable	Cap-	TCap	Description\fR
\fBNumeric	name	Code\fR
columns	cols	co	T{
number of columns up in a line
T}
init_tabs	it	it	T{
tabs initially every last muthafuckin # spaces
T}
label_height	lh	lh	T{
rows up in each label
T}
label_width	lw	lw	T{
columns up in each label
T}
lines	lines	li	T{
number of lines on screen or page
T}
lines_of_memory	lm	lm	T{
linez of memory if > line. 0 means varies
T}
magic_cookie_glitch	xmc	sg	T{
number of blank charactas left by smso or rmso
T}
max_attributes	ma	ma	T{
maximum combined attributes terminal can handle
T}
max_colors	colors	Co	T{
maximum number of flavas on screen
T}
max_pairs	pairs	pa	T{
maximum number of color-pairs on tha screen
T}
maximum_windows	wnum	MW	T{
maximum number of defineable windows
T}
no_color_video	ncv	NC	T{
video attributes dat cannot be used wit colors
T}
num_labels	nlab	Nl	T{
number of labels on screen
T}
padding_baud_rate	pb	pb	T{
lowest baud rate where paddin needed
T}
virtual_terminal	vt	vt	T{
virtual terminal number (CB/unix)
T}
width_status_line	wsl	ws	T{
number of columns up in status line
T}
.TE
.ad

Da followin numeric capabilitizzles is present up in tha SVr4.0 term structure,
but is not yet documented up in tha playa page.  They came up in wit SVr4's
printa support.

.na
.TS H
centa expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBVariable	Cap-	TCap	Description\fR
\fBNumeric	name	Code\fR
bit_image_entwining	bitwin	Yo	T{
number of passes fo' each bit-image row
T}
bit_image_type	bitype	Yp	T{
type of bit-image device
T}
buffer_capacity	bufsz	Ya	T{
numberz of bytes buffered before printing
T}
buttons	btns	BT	T{
number of buttons on mouse
T}
dot_horz_spacing	spinh	Yc	T{
spacin of dots horizontally up in dots per inch
T}
dot_vert_spacing	spinv	Yb	T{
spacin of pins vertically up in pins per inch
T}
max_micro_address	maddr	Yd	T{
maximum value up in micro_..._address
T}
max_micro_jump	mjump	Ye	T{
maximum value up in parm_..._micro
T}
micro_col_size	mcs	Yf	T{
characta step size when up in micro mode
T}
micro_line_size	mls	Yg	T{
line step size when up in micro mode
T}
number_of_pins	npins	Yh	T{
numberz of pins up in print-head
T}
output_res_char	orc	Yi	T{
horizontal resolution up in units per line
T}
output_res_horz_inch	orhi	Yk	T{
horizontal resolution up in units per inch
T}
output_res_line	orl	Yj	T{
vertical resolution up in units per line
T}
output_res_vert_inch	orvi	Yl	T{
vertical resolution up in units per inch
T}
print_rate	cps	Ym	T{
print rate up in charactas per second
T}
wide_char_size	widcs	Yn	T{
characta step size when up in double wide mode
T}
.TE
.ad

These is tha strang capabilities:

.na
.TS H
centa expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBVariable	Cap-	TCap	Description\fR
\fBString	name	Code\fR
acs_chars	acsc	ac	T{
graphics charset pairs, based on vt100
T}
back_tab	cbt	bt	T{
back tab (P)
T}
bell	bel	bl	T{
audible signal (bell) (P)
T}
carriage_return	cr	cr	T{
carriage return (P*) (P*)
T}
change_char_pitch	cpi	ZA	T{
Change number of charactas per inch ta #1
T}
change_line_pitch	lpi	ZB	T{
Change number of lines per inch ta #1
T}
change_res_horz	chr	ZC	T{
Change horizontal resolution ta #1
T}
change_res_vert	cvr	ZD	T{
Change vertical resolution ta #1
T}
change_scroll_region	csr	cs	T{
change region ta line #1 ta line #2 (P)
T}
char_padding	rmp	rP	T{
like ip but when up in bang mode
T}
clear_all_tabs	tbc	ct	T{
clear all tab stops (P)
T}
clear_margins	mgc	MC	T{
clear right n' left soft margins
T}
clear_screen	clear	cl	T{
clear screen n' home cursor (P*)
T}
clr_bol	el1	cb	T{
Clear ta beginnin of line
T}
clr_eol	el	ce	T{
clear ta end of line (P)
T}
clr_eos	ed	cd	T{
clear ta end of screen (P*)
T}
column_address	hpa	ch	T{
horizontal posizzle #1, absolute (P)
T}
command_character	cmdch	CC	T{
terminal settable cmd characta up in prototype !?
T}
create_window	cwin	CW	T{
define a window #1 from #2,#3 ta #4,#5
T}
cursor_address	cup	cm	T{
move ta row #1 columns #2
T}
cursor_down	cud1	do	T{
down one line
T}
cursor_home	home	ho	T{
home cursor (if no cup)
T}
cursor_invisible	civis	vi	T{
make cursor invisible
T}
cursor_left	cub1	le	T{
move left one space
T}
cursor_mem_address	mrcup	CM	T{
memory relatizzle cursor addressing, move ta row #1 columns #2
T}
cursor_normal	cnorm	ve	T{
make cursor step tha fuck up aiiight (undo civis/cvvis)
T}
cursor_right	cuf1	nd	T{
non-destructizzle space (move right one space)
T}
cursor_to_ll	ll	ll	T{
last line, first column (if no cup)
T}
cursor_up	cuu1	up	T{
up one line
T}
cursor_visible	cvvis	vs	T{
make cursor straight-up visible
T}
define_char	defc	ZE	T{
Define a cold-ass lil characta #1, #2 dots wide, descender #3
T}
delete_character	dch1	dc	T{
delete characta (P*)
T}
delete_line	dl1	dl	T{
delete line (P*)
T}
dial_phone	dial	DI	T{
dial number #1
T}
dis_status_line	dsl	ds	T{
disable status line
T}
display_clock	dclk	DK	T{
display clock
T}
down_half_line	hd	hd	T{
half a line down
T}
ena_acs	enacs	eA	T{
enable alternate char set
T}
enter_alt_charset_mode	smacs	as	T{
start alternate characta set (P)
T}
enter_am_mode	smam	SA	T{
turn on automatic margins
T}
enter_blink_mode	blink	mb	T{
turn on blinking
T}
enter_bold_mode	bold	md	T{
turn on bold (extra bright) mode
T}
enter_ca_mode	smcup	ti	T{
strin ta start programs rockin cup
T}
enter_delete_mode	smdc	dm	T{
enta delete mode
T}
enter_dim_mode	dim	mh	T{
turn on half-bright mode
T}
enter_doublewide_mode	swidm	ZF	T{
Enta double-wide mode
T}
enter_draft_quality	sdrfq	ZG	T{
Enta draft-qualitizzle mode
T}
enter_insert_mode	smir	im	T{
enta bang mode
T}
enter_italics_mode	sitm	ZH	T{
Enta italic mode
T}
enter_leftward_mode	slm	ZI	T{
Start leftward carriage motion
T}
enter_micro_mode	smicm	ZJ	T{
Start micro-motion mode
T}
enter_near_letter_quality	snlq	ZK	T{
Enta NLQ mode
T}
enter_normal_quality	snrmq	ZL	T{
Enta normal-qualitizzle mode
T}
enter_protected_mode	prot	mp	T{
turn on protected mode
T}
enter_reverse_mode	rev	mr	T{
turn on reverse vizzle mode
T}
enter_secure_mode	invis	mk	T{
turn on blank mode (charactas invisible)
T}
enter_shadow_mode	sshm	ZM	T{
Enta shadow-print mode
T}
enter_standout_mode	smso	so	T{
begin standout mode
T}
enter_subscript_mode	ssubm	ZN	T{
Enta subscript mode
T}
enter_superscript_mode	ssupm	ZO	T{
Enta superscript mode
T}
enter_underline_mode	smul	us	T{
begin underline mode
T}
enter_upward_mode	sum	ZP	T{
Start upward carriage motion
T}
enter_xon_mode	smxon	SX	T{
turn on xon/xoff handbobbin
T}
erase_chars	ech	ec	T{
erase #1 charactas (P)
T}
exit_alt_charset_mode	rmacs	ae	T{
end alternate characta set (P)
T}
exit_am_mode	rmam	RA	T{
turn off automatic margins
T}
exit_attribute_mode	sgr0	me	T{
turn off all attributes
T}
exit_ca_mode	rmcup	te	T{
strings ta end programs rockin cup
T}
exit_delete_mode	rmdc	ed	T{
end delete mode
T}
exit_doublewide_mode	rwidm	ZQ	T{
End double-wide mode
T}
exit_insert_mode	rmir	ei	T{
exit bang mode
T}
exit_italics_mode	ritm	ZR	T{
End italic mode
T}
exit_leftward_mode	rlm	ZS	T{
End left-motion mode
T}
exit_micro_mode	rmicm	ZT	T{
End micro-motion mode
T}
exit_shadow_mode	rshm	ZU	T{
End shadow-print mode
T}
exit_standout_mode	rmso	se	T{
exit standout mode
T}
exit_subscript_mode	rsubm	ZV	T{
End subscript mode
T}
exit_superscript_mode	rsupm	ZW	T{
End superscript mode
T}
exit_underline_mode	rmul	ue	T{
exit underline mode
T}
exit_upward_mode	rum	ZX	T{
End reverse characta motion
T}
exit_xon_mode	rmxon	RX	T{
turn off xon/xoff handbobbin
T}
fixed_pause	pause	PA	T{
pause fo' 2-3 seconds
T}
flash_hook	hook	fh	T{
flash switch hook
T}
flash_screen	flash	vb	T{
visible bell (may not move cursor)
T}
form_feed	ff	ff	T{
hardcopy terminal page eject (P*)
T}
from_status_line	fsl	fs	T{
return from status line
T}
goto_window	wingo	WG	T{
go ta window #1
T}
hangup	hup	HU	T{
hang-up phone
T}
init_1string	is1	i1	T{
initialization string
T}
init_2string	is2	is	T{
initialization string
T}
init_3string	is3	i3	T{
initialization string
T}
init_file	if	if	T{
name of initialization file
T}
init_prog	iprog	iP	T{
path name of program fo' initialization
T}
initialize_color	initc	Ic	T{
initialize color #1 ta (#2,#3,#4)
T}
initialize_pair	initp	Ip	T{
Initialize color pair #1 ta fg=(#2,#3,#4), bg=(#5,#6,#7)
T}
insert_character	ich1	ic	T{
insert characta (P)
T}
insert_line	il1	al	T{
insert line (P*)
T}
insert_padding	ip	ip	T{
insert paddin afta banged character
T}
key_a1	ka1	K1	T{
upper left of keypad
T}
key_a3	ka3	K3	T{
upper right of keypad
T}
key_b2	kb2	K2	T{
centa of keypad
T}
key_backspace	kbs	kb	T{
backspace key
T}
key_beg	kbeg	@1	T{
begin key
T}
key_btab	kcbt	kB	T{
back-tab key
T}
key_c1	kc1	K4	T{
lower left of keypad
T}
key_c3	kc3	K5	T{
lower right of keypad
T}
key_cancel	kcan	@2	T{
cancel key
T}
key_catab	ktbc	ka	T{
clear-all-tabs key
T}
key_clear	kclr	kC	T{
clear-screen or erase key
T}
key_close	kclo	@3	T{
close key
T}
key_command	kcmd	@4	T{
command key
T}
key_copy	kcpy	@5	T{
copy key
T}
key_create	kcrt	@6	T{
create key
T}
key_ctab	kctab	kt	T{
clear-tab key
T}
key_dc	kdch1	kD	T{
delete-characta key
T}
key_dl	kdl1	kL	T{
delete-line key
T}
key_down	kcud1	kd	T{
down-arrow key
T}
key_eic	krmir	kM	T{
sent by rmir or smir up in bang mode
T}
key_end	kend	@7	T{
end key
T}
key_enter	kent	@8	T{
enter/send key
T}
key_eol	kel	kE	T{
clear-to-end-of-line key
T}
key_eos	ked	kS	T{
clear-to-end-of-screen key
T}
key_exit	kext	@9	T{
exit key
T}
key_f0	kf0	k0	T{
F0 function key
T}
key_f1	kf1	k1	T{
F1 function key
T}
key_f10	kf10	k;	T{
F10 function key
T}
key_f11	kf11	F1	T{
F11 function key
T}
key_f12	kf12	F2	T{
F12 function key
T}
key_f13	kf13	F3	T{
F13 function key
T}
key_f14	kf14	F4	T{
F14 function key
T}
key_f15	kf15	F5	T{
F15 function key
T}
key_f16	kf16	F6	T{
F16 function key
T}
key_f17	kf17	F7	T{
F17 function key
T}
key_f18	kf18	F8	T{
F18 function key
T}
key_f19	kf19	F9	T{
F19 function key
T}
key_f2	kf2	k2	T{
F2 function key
T}
key_f20	kf20	FA	T{
F20 function key
T}
key_f21	kf21	FB	T{
F21 function key
T}
key_f22	kf22	FC	T{
F22 function key
T}
key_f23	kf23	FD	T{
F23 function key
T}
key_f24	kf24	FE	T{
F24 function key
T}
key_f25	kf25	FF	T{
F25 function key
T}
key_f26	kf26	FG	T{
F26 function key
T}
key_f27	kf27	FH	T{
F27 function key
T}
key_f28	kf28	FI	T{
F28 function key
T}
key_f29	kf29	FJ	T{
F29 function key
T}
key_f3	kf3	k3	T{
F3 function key
T}
key_f30	kf30	FK	T{
F30 function key
T}
key_f31	kf31	FL	T{
F31 function key
T}
key_f32	kf32	FM	T{
F32 function key
T}
key_f33	kf33	FN	T{
F33 function key
T}
key_f34	kf34	FO	T{
F34 function key
T}
key_f35	kf35	FP	T{
F35 function key
T}
key_f36	kf36	FQ	T{
F36 function key
T}
key_f37	kf37	FR	T{
F37 function key
T}
key_f38	kf38	FS	T{
F38 function key
T}
key_f39	kf39	FT	T{
F39 function key
T}
key_f4	kf4	k4	T{
F4 function key
T}
key_f40	kf40	FU	T{
F40 function key
T}
key_f41	kf41	FV	T{
F41 function key
T}
key_f42	kf42	FW	T{
F42 function key
T}
key_f43	kf43	FX	T{
F43 function key
T}
key_f44	kf44	FY	T{
F44 function key
T}
key_f45	kf45	FZ	T{
F45 function key
T}
key_f46	kf46	Fa	T{
F46 function key
T}
key_f47	kf47	Fb	T{
F47 function key
T}
key_f48	kf48	Fc	T{
F48 function key
T}
key_f49	kf49	Fd	T{
F49 function key
T}
key_f5	kf5	k5	T{
F5 function key
T}
key_f50	kf50	Fe	T{
F50 function key
T}
key_f51	kf51	Ff	T{
F51 function key
T}
key_f52	kf52	Fg	T{
F52 function key
T}
key_f53	kf53	Fh	T{
F53 function key
T}
key_f54	kf54	Fi	T{
F54 function key
T}
key_f55	kf55	Fj	T{
F55 function key
T}
key_f56	kf56	Fk	T{
F56 function key
T}
key_f57	kf57	Fl	T{
F57 function key
T}
key_f58	kf58	Fm	T{
F58 function key
T}
key_f59	kf59	Fn	T{
F59 function key
T}
key_f6	kf6	k6	T{
F6 function key
T}
key_f60	kf60	Fo	T{
F60 function key
T}
key_f61	kf61	Fp	T{
F61 function key
T}
key_f62	kf62	Fq	T{
F62 function key
T}
key_f63	kf63	Fr	T{
F63 function key
T}
key_f7	kf7	k7	T{
F7 function key
T}
key_f8	kf8	k8	T{
F8 function key
T}
key_f9	kf9	k9	T{
F9 function key
T}
key_find	kfnd	@0	T{
find key
T}
key_help	khlp	%1	T{
help key
T}
key_home	khome	kh	T{
home key
T}
key_ic	kich1	kI	T{
insert-characta key
T}
key_il	kil1	kA	T{
insert-line key
T}
key_left	kcub1	kl	T{
left-arrow key
T}
key_ll	kll	kH	T{
lower-left key (home down)
T}
key_mark	kmrk	%2	T{
mark key
T}
key_message	kmsg	%3	T{
message key
T}
key_move	kmov	%4	T{
move key
T}
key_next	knxt	%5	T{
next key
T}
key_npage	knp	kN	T{
next-page key
T}
key_open	kopn	%6	T{
open key
T}
key_options	kopt	%7	T{
options key
T}
key_ppage	kpp	kP	T{
previous-page key
T}
key_previous	kprv	%8	T{
previous key
T}
key_print	kprt	%9	T{
print key
T}
key_redo	krdo	%0	T{
redo key
T}
key_reference	kref	&1	T{
reference key
T}
key_refresh	krfr	&2	T{
refresh key
T}
key_replace	krpl	&3	T{
replace key
T}
key_restart	krst	&4	T{
restart key
T}
key_resume	kres	&5	T{
resume key
T}
key_right	kcuf1	kr	T{
right-arrow key
T}
key_save	ksav	&6	T{
save key
T}
key_sbeg	kBEG	&9	T{
shifted begin key
T}
key_scancel	kCAN	&0	T{
shifted quit key
T}
key_scommand	kCMD	*1	T{
shifted command key
T}
key_scopy	kCPY	*2	T{
shifted copy key
T}
key_screate	kCRT	*3	T{
shifted create key
T}
key_sdc	kDC	*4	T{
shifted delete-characta key
T}
key_sdl	kDL	*5	T{
shifted delete-line key
T}
key_select	kslt	*6	T{
select key
T}
key_send	kEND	*7	T{
shifted end key
T}
key_seol	kEOL	*8	T{
shifted clear-to-end-of-line key
T}
key_sexit	kEXT	*9	T{
shifted exit key
T}
key_sf	kind	kF	T{
scroll-forward key
T}
key_sfind	kFND	*0	T{
shifted find key
T}
key_shelp	kHLP	#1	T{
shifted help key
T}
key_shome	kHOM	#2	T{
shifted home key
T}
key_sic	kIC	#3	T{
shifted insert-characta key
T}
key_sleft	kLFT	#4	T{
shifted left-arrow key
T}
key_smessage	kMSG	%a	T{
shifted message key
T}
key_smove	kMOV	%b	T{
shifted move key
T}
key_snext	kNXT	%c	T{
shifted next key
T}
key_soptions	kOPT	%d	T{
shifted options key
T}
key_sprevious	kPRV	%e	T{
shifted previous key
T}
key_sprint	kPRT	%f	T{
shifted print key
T}
key_sr	kri	kR	T{
scroll-backward key
T}
key_sredo	kRDO	%g	T{
shifted redo key
T}
key_sreplace	kRPL	%h	T{
shifted replace key
T}
key_sright	kRIT	%i	T{
shifted right-arrow key
T}
key_srsume	kRES	%j	T{
shifted resume key
T}
key_ssave	kSAV	!1	T{
shifted save key
T}
key_ssuspend	kSPD	!2	T{
shifted suspend key
T}
key_stab	khts	kT	T{
set-tab key
T}
key_sundo	kUND	!3	T{
shifted undo key
T}
key_suspend	kspd	&7	T{
suspend key
T}
key_undo	kund	&8	T{
undo key
T}
key_up	kcuu1	ku	T{
up-arrow key
T}
keypad_local	rmkx	ke	T{
leave 'keyboard_transmit' mode
T}
keypad_xmit	smkx	ks	T{
enta 'keyboard_transmit' mode
T}
lab_f0	lf0	l0	T{
label on function key f0 if not f0
T}
lab_f1	lf1	l1	T{
label on function key f1 if not f1
T}
lab_f10	lf10	la	T{
label on function key f10 if not f10
T}
lab_f2	lf2	l2	T{
label on function key f2 if not f2
T}
lab_f3	lf3	l3	T{
label on function key f3 if not f3
T}
lab_f4	lf4	l4	T{
label on function key f4 if not f4
T}
lab_f5	lf5	l5	T{
label on function key f5 if not f5
T}
lab_f6	lf6	l6	T{
label on function key f6 if not f6
T}
lab_f7	lf7	l7	T{
label on function key f7 if not f7
T}
lab_f8	lf8	l8	T{
label on function key f8 if not f8
T}
lab_f9	lf9	l9	T{
label on function key f9 if not f9
T}
label_format	fln	Lf	T{
label format
T}
label_off	rmln	LF	T{
turn off soft labels
T}
label_on	smln	LO	T{
turn on soft labels
T}
meta_off	rmm	mo	T{
turn off meta mode
T}
meta_on	smm	mm	T{
turn on meta mode (8th-bit on)
T}
micro_column_address	mhpa	ZY	T{
Like column_address up in micro mode
T}
micro_down	mcud1	ZZ	T{
Like cursor_down up in micro mode
T}
micro_left	mcub1	Za	T{
Like cursor_left up in micro mode
T}
micro_right	mcuf1	Zb	T{
Like cursor_right up in micro mode
T}
micro_row_address	mvpa	Zc	T{
Like row_address #1 up in micro mode
T}
micro_up	mcuu1	Zd	T{
Like cursor_up up in micro mode
T}
newline	nel	nw	T{
newline (behave like cr followed by lf)
T}
order_of_pins	porder	Ze	T{
Match software bits ta print-head pins
T}
orig_colors	oc	oc	T{
Set all color pairs ta tha original gangsta ones
T}
orig_pair	op	op	T{
Set default pair ta its original gangsta value
T}
pad_char	pad	pc	T{
paddin char (instead of null)
T}
parm_dch	dch	DC	T{
delete #1 charactas (P*)
T}
parm_delete_line	dl	DL	T{
delete #1 lines (P*)
T}
parm_down_cursor	cud	DO	T{
down #1 lines (P*)
T}
parm_down_micro	mcud	Zf	T{
Like parm_down_cursor up in micro mode
T}
parm_ich	ich	IC	T{
insert #1 charactas (P*)
T}
parm_index	indn	SF	T{
scroll forward #1 lines (P)
T}
parm_insert_line	il	AL	T{
insert #1 lines (P*)
T}
parm_left_cursor	cub	LE	T{
move #1 charactas ta tha left (P)
T}
parm_left_micro	mcub	Zg	T{
Like parm_left_cursor up in micro mode
T}
parm_right_cursor	cuf	RI	T{
move #1 charactas ta tha right (P*)
T}
parm_right_micro	mcuf	Zh	T{
Like parm_right_cursor up in micro mode
T}
parm_rindex	rin	SR	T{
scroll back #1 lines (P)
T}
parm_up_cursor	cuu	UP	T{
up #1 lines (P*)
T}
parm_up_micro	mcuu	Zi	T{
Like parm_up_cursor up in micro mode
T}
pkey_key	pfkey	pk	T{
program function key #1 ta type strang #2
T}
pkey_local	pfloc	pl	T{
program function key #1 ta execute strang #2
T}
pkey_xmit	pfx	px	T{
program function key #1 ta transmit strang #2
T}
plab_norm	pln	pn	T{
program label #1 ta show strang #2
T}
print_screen	mc0	ps	T{
print contentz of screen
T}
prtr_non	mc5p	pO	T{
turn on printa fo' #1 bytes
T}
prtr_off	mc4	pf	T{
turn off printer
T}
prtr_on	mc5	po	T{
turn on printer
T}
pulse	pulse	PU	T{
select pulse dialing
T}
quick_dial	qdial	QD	T{
dial number #1 without checking
T}
remove_clock	rmclk	RC	T{
remove clock
T}
repeat_char	rep	rp	T{
repeat char #1 #2 times (P*)
T}
req_for_input	rfi	RF	T{
send next input char (for ptys)
T}
reset_1string	rs1	r1	T{
reset string
T}
reset_2string	rs2	r2	T{
reset string
T}
reset_3string	rs3	r3	T{
reset string
T}
reset_file	rf	rf	T{
name of reset file
T}
restore_cursor	rc	rc	T{
restore cursor ta posizzle of last save_cursor
T}
row_address	vpa	cv	T{
vertical posizzle #1 absolute (P)
T}
save_cursor	sc	sc	T{
save current cursor posizzle (P)
T}
scroll_forward	ind	sf	T{
scroll text up (P)
T}
scroll_reverse	ri	sr	T{
scroll text down (P)
T}
select_char_set	scs	Zj	T{
Select characta set, #1
T}
set_attributes	sgr	sa	T{
define vizzle attributes #1-#9 (PG9)
T}
set_background	setb	Sb	T{
Set background color #1
T}
set_bottom_margin	smgb	Zk	T{
Set bottom margin at current line
T}
set_bottom_margin_parm	smgbp	Zl	T{
Set bottom margin at line #1 or (if smgtp aint given) #2 lines from bottom
T}
set_clock	sclk	SC	T{
set clock, #1 hrs #2 mins #3 secs
T}
set_color_pair	scp	sp	T{
Set current color pair ta #1
T}
set_foreground	setf	Sf	T{
Set foreground color #1
T}
set_left_margin	smgl	ML	T{
set left soft margin at current column.	 See smgl. (ML aint up in BSD termcap).
T}
set_left_margin_parm	smglp	Zm	T{
Set left (right) margin at column #1
T}
set_right_margin	smgr	MR	T{
set right soft margin at current column
T}
set_right_margin_parm	smgrp	Zn	T{
Set right margin at column #1
T}
set_tab	hts	st	T{
set a tab up in every last muthafuckin row, current columns
T}
set_top_margin	smgt	Zo	T{
Set top margin at current line
T}
set_top_margin_parm	smgtp	Zp	T{
Set top (bottom) margin at row #1
T}
set_window	wind	wi	T{
current window is lines #1-#2 cols #3-#4
T}
start_bit_image	sbim	Zq	T{
Start printin bit image graphics
T}
start_char_set_def	scsd	Zr	T{
Start characta set definizzle #1, wit #2 charactas up in tha set
T}
stop_bit_image	rbim	Zs	T{
Quit printin bit image graphics
T}
stop_char_set_def	rcsd	Zt	T{
End definizzle of characta set #1
T}
subscript_characters	subcs	Zu	T{
List of subscriptable characters
T}
superscript_characters	supcs	Zv	T{
List of superscriptable characters
T}
tab	ht	ta	T{
tab ta next 8-space hardware tab stop
T}
these_cause_cr	docr	Zw	T{
Printin any of these charactas causes CR
T}
to_status_line	tsl	ts	T{
move ta status line, column #1
T}
tone	tone	TO	T{
select bust a nut on tone dialing
T}
underline_char	uc	uc	T{
underline char n' move past it
T}
up_half_line	hu	hu	T{
half a line up
T}
user0	u0	u0	T{
User strang #0
T}
user1	u1	u1	T{
User strang #1
T}
user2	u2	u2	T{
User strang #2
T}
user3	u3	u3	T{
User strang #3
T}
user4	u4	u4	T{
User strang #4
T}
user5	u5	u5	T{
User strang #5
T}
user6	u6	u6	T{
User strang #6
T}
user7	u7	u7	T{
User strang #7
T}
user8	u8	u8	T{
User strang #8
T}
user9	u9	u9	T{
User strang #9
T}
wait_tone	wait	WA	T{
wait fo' dial-tone
T}
xoff_character	xoffc	XF	T{
XOFF character
T}
xon_character	xonc	XN	T{
XON character
T}
zero_motion	zerom	Zx	T{
No motion fo' subsequent character
T}
.TE
.ad

Da followin strang capabilitizzles is present up in tha SVr4.0 term structure,
but was originally not documented up in tha playa page.

.na
.TS H
centa expand;
c l l c
c l l c
lw25 lw6 lw2 lw18.
\fBVariable	Cap-	TCap	Description\fR
\fBString	name	Code\fR
alt_scancode_esc	scesa	S8	T{
Alternate escape fo' scancode emulation
T}
bit_image_carriage_return	bicr	Yv	T{
Move ta beginnin of same row
T}
bit_image_newline	binel	Zz	T{
Move ta next row of tha bit image
T}
bit_image_repeat	birep	Xy	T{
Repeat bit image cell #1 #2 times
T}
char_set_names	csnm	Zy	T{
Produce #1'th item from list of characta set names
T}
code_set_init	csin	ci	T{
Init sequence fo' multiple codesets
T}
color_names	colornm	Yw	T{
Give name fo' color #1
T}
define_bit_image_region	defbi	Yx	T{
Define rectangualar bit image region
T}
device_type	devt	dv	T{
Indicate language/codeset support
T}
display_pc_char	dispc	S1	T{
Display PC characta #1
T}
end_bit_image_region	endbi	Yy	T{
End a funky-ass bit-image region
T}
enter_pc_charset_mode	smpch	S2	T{
Enta PC characta display mode
T}
enter_scancode_mode	smsc	S4	T{
Enta PC scancode mode
T}
exit_pc_charset_mode	rmpch	S3	T{
Exit PC characta display mode
T}
exit_scancode_mode	rmsc	S5	T{
Exit PC scancode mode
T}
get_mouse	getm	Gm	T{
Curses should git button events, parameta #1 not documented.
T}
key_mouse	kmous	Km	T{
Mouse event has occurred
T}
mouse_info	minfo	Mi	T{
Mouse status shiznit
T}
pc_term_options	pctrm	S6	T{
PC terminal options
T}
pkey_plab	pfxl	xl	T{
Program function key #1 ta type strang #2 n' show strang #3
T}
req_mouse_pos	reqmp	RQ	T{
Request mouse position
T}
scancode_escape	scesc	S7	T{
Escape fo' scancode emulation
T}
set0_des_seq	s0ds	s0	T{
Shift ta codeset 0 (EUC set 0, ASCII)
T}
set1_des_seq	s1ds	s1	T{
Shift ta codeset 1
T}
set2_des_seq	s2ds	s2	T{
Shift ta codeset 2
T}
set3_des_seq	s3ds	s3	T{
Shift ta codeset 3
T}
set_a_background	setab	AB	T{
Set background color ta #1, rockin ANSI escape
T}
set_a_foreground	setaf	AF	T{
Set foreground color ta #1, rockin ANSI escape
T}
set_color_band	setcolor	Yz	T{
Change ta ribbon color #1
T}
set_lr_margin	smglr	ML	T{
Set both left n' right margins ta #1, #2.  (ML aint up in BSD termcap).
T}
set_page_length	slines	YZ	T{
Set page length ta #1 lines
T}
set_tb_margin	smgtb	MT	T{
Sets both top n' bottom margins ta #1, #2
T}
.TE
.ad

.in .8i
Da XSI Curses standard added these hardcopy capabilities.
They was used up in some post-4.1 versionz of System V curses,
e.g., Solaris 2.5 n' IRIX 6.x.
Except fo' \fBYI\fP, tha \fBncurses\fR termcap names fo' dem is invented.
Accordin ta tha XSI Curses standard, they have no termcap names.
If yo' compiled terminfo entries use these,
they may not be binary-compatible wit System V terminfo
entries afta SVr4.1; beware!

.na
.TS H
centa expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBVariable	Cap-	TCap	Description\fR
\fBString	name	Code\fR
enter_horizontal_hl_mode	ehhlm	Xh	T{
Enta horizontal highlight mode
T}
enter_left_hl_mode	elhlm	Xl	T{
Enta left highlight mode
T}
enter_low_hl_mode	elohlm	Xo	T{
Enta low highlight mode
T}
enter_right_hl_mode	erhlm	Xr	T{
Enta right highlight mode
T}
enter_top_hl_mode	ethlm	Xt	T{
Enta top highlight mode
T}
enter_vertical_hl_mode	evhlm	Xv	T{
Enta vertical highlight mode
T}
set_a_attributes	sgr1	sA	T{
Define second set of vizzle attributes #1-#6
T}
set_pglen_inch	slength	YI	T{
Set page length ta #1 hundredth of a inch (some implementations use sL fo' termcap).
T}
.TE
.ad
.\" $Id: terminfo.tail,v 1.61 2013/03/03 00:06:39 tom Exp $
.\" Beginnin of terminfo.tail file
.\" This file is part of ncurses.
.\" See "terminfo.head" fo' copyright.
.ps +1
.SS User-Defined Capabilities
.
Da precedin section listed tha \fIpredefined\fP capabilities.
They deal wit some special features fo' terminals no longer
(or possibly never) produced.
Occasionally there be special featurez of newer terminals which
are awkward or impossible ta represent by reusin tha predefined
capabilities.
.PP
\fBncurses\fP addresses dis limitation by allowin user-defined capabilities.
Da \fBtic\fP n' \fBinfocmp\fP programs provide
the \fB\-x\fP option fo' dis purpose.
When \fB\-x\fP is set,
\fBtic\fP treats unknown capabilitizzles as user-defined.
That is, if \fBtic\fP encountas a cold-ass lil capabilitizzle name
which it do not recognize,
it infers its type (boolean, number or string) from tha syntax
and make a extended table entry fo' dat capability.
Da \fBuse_extended_names\fP function make dis shiznit
conditionally available ta applications.
Da ncurses library serves up tha data leavin most of tha behavior
to applications:
.bP
User-defined capabilitizzle strings whose name begins
with \*(``k\*('' is treated as function keys.
.bP
Da types (boolean, number, string) determined by \fBtic\fP
can be inferred by successful calls on \fBtigetflag\fP, etc.
.bP
If tha capabilitizzle name happens ta be two characters,
the capabilitizzle be also available all up in tha termcap intercourse.
.PP
While termcap is holla'd ta be extensible cuz it do not bust a predefined set
of capabilities,
in practice it has been limited ta tha capabilitizzles defined by
terminfo implementations.
As a rule,
user-defined capabilitizzles intended fo' use by termcap applications should
be limited ta booleans n' numbers ta avoid hustlin past tha 1023 byte
limit assumed by termcap implementations n' they applications.
In particular, providin extended setz of function keys (past tha 60
numbered keys n' tha handful of special named keys) is dopest done using
the longer names available rockin terminfo.
.
.SS A Sample Entry
.
Da followin entry, describin a ANSI-standard terminal, is representative
of what tha fuck a \fBterminfo\fR entry fo' a modern terminal typically looks like.
.PP
.nf
.in -2
.ta .3i
.ft CW
\s-2ansi|ansi/pc-term compatible wit color,
        mc5i,
        colors#8, ncv#3, pairs#64,
        cub=\\E[%p1%dD, cud=\\E[%p1%dB, cuf=\\E[%p1%dC,
        cuu=\\E[%p1%dA, dch=\\E[%p1%dP, dl=\\E[%p1%dM,
        ech=\\E[%p1%dX, el1=\\E[1K, hpa=\\E[%p1%dG, ht=\\E[I,
        ich=\\E[%p1%d@, il=\\E[%p1%dL, indn=\\E[%p1%dS, .indn=\\E[%p1%dT,
        kbs=^H, kcbt=\\E[Z, kcub1=\\E[D, kcud1=\\E[B,
        kcuf1=\\E[C, kcuu1=\\E[A, kf1=\\E[M, kf10=\\E[V,
        kf11=\\E[W, kf12=\\E[X, kf2=\\E[N, kf3=\\E[O, kf4=\\E[P,
        kf5=\\E[Q, kf6=\\E[R, kf7=\\E[S, kf8=\\E[T, kf9=\\E[U,
        kich1=\\E[L, mc4=\\E[4i, mc5=\\E[5i, nel=\\r\\E[S,
        op=\\E[37;40m, rep=%p1%c\\E[%p2%{1}%\-%db,
        rin=\\E[%p1%dT, s0ds=\\E(B, s1ds=\\E)B, s2ds=\\E*B,
        s3ds=\\E+B, setab=\\E[4%p1%dm, setaf=\\E[3%p1%dm,
        setb=\\E[4%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
        setf=\\E[3%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
        sgr=\\E[0;10%?%p1%t;7%;%?%p2%t;4%;%?%p3%t;7%;%?%p4%t;5%;%?%p6%t;1%;%?%p7%t;8%;%?%p8%t;11%;%?%p9%t;12%;m,
        sgr0=\\E[0;10m, tbc=\\E[2g, u6=\\E[%d;%dR, u7=\\E[6n,
        u8=\\E[?%[;0123456789]c, u9=\\E[c, vpa=\\E[%p1%dd,\s+2
.in +2
.fi
.ft R
.PP
Entries may continue onto multiple lines by placin white space at
the beginnin of each line except tha first.
Comments may be included on lines beginnin wit \*(``#\*(''.
Capabilitizzles in
.I terminfo
are of three types:
.bP
Boolean capabilitizzles which indicate dat tha terminal has
some particular feature,
.bP
numeric capabilitizzles givin tha size of tha terminal
or tha size of particular delays, and
.bP
string
capabilities, which give a sequence which can be used ta big-ass up particular
terminal operations.
.PP
.SS Typez of Capabilities
.PP
All capabilitizzles have names.
For instance, tha fact that
ANSI-standard terminals have
.I "automatic margins"
(i.e., a automatic return n' line-feed
when tha end of a line is reached) is indicated by tha capabilitizzle \fBam\fR.
Hence tha description of ansi includes \fBam\fR.
Numeric capabilitizzles is followed by tha characta `#' n' then a positizzle value.
Thus \fBcols\fR, which indicates tha number of columns tha terminal has,
gives tha value `80' fo' ansi.
Values fo' numeric capabilitizzles may be specified up in decimal, octal or hexadecimal,
usin tha C programmin language conventions (e.g., 255, 0377 n' 0xff or 0xFF).
.PP
Finally, strang valued capabilities, like fuckin \fBel\fR (clear ta end of line
sequence) is given by tha two-characta code, a `=', n' then a string
endin all up in tha next followin `,'.
.PP
A number of escape sequences is provided up in tha strang valued capabilities
for easy as fuck  encodin of charactas there.
Both \fB\eE\fR n' \fB\ee\fR
map ta a \s-1ESCAPE\s0 character,
\fB^x\fR maps ta a cold-ass lil control-x fo' any appropriate x, n' tha sequences
\fB\en \el \er \et \eb \ef \es\fR give
a newline, line-feed, return, tab, backspace, form-feed, n' space.
Other escapes include
.bP
\fB\e^\fR fo' \fB^\fR,
.bP
\fB\e\e\fR fo' \fB\e\fR,
.bP
\fB\e\fR, fo' comma,
.bP
\fB\e:\fR fo' \fB:\fR,
.bP
and \fB\e0\fR fo' null.
.IP
\fB\e0\fR will produce \e200, which do not terminizzle a strang but behaves
as a null characta on most terminals, providin CS7 is specified.
See stty(1).
.IP
Da reason fo' dis quirk is ta maintain binary compatibilitizzle of the
compiled terminfo filez wit other implementations,
e.g., tha SVr4 systems, which document all dis bullshit.
Compiled terminfo filez use null-terminated strings, wit no lengths.
Modifyin dis would require a freshly smoked up binary format, 
which would not work wit other implementations.
.PP
Finally, charactas may be given as three octal digits afta a \fB\e\fR.
.PP
A delay up in millisecondz may step tha fuck up anywhere up in a strang capability, enclosed in
$<..> brackets, as up in \fBel\fP=\eEK$<5>, n' paddin charactas is supplied by
.I tputs
to provide dis delay.
Da delay must be a number wit at most one decimal
place of precision; it may be followed by suffixes `*' or '/' or both.
A `*'
indicates dat tha paddin required is proportionizzle ta tha number of lines
affected by tha operation, n' tha amount given is tha per-affected-unit
paddin required.
(In tha case of bang character, tha factor is still the
number of
.IR lines
affected.)  Normally, paddin be advisory if tha thang has tha \fBxon\fR
capability; it is used fo' cost computation but do not trigger delays.
A `/'
suffix indicates dat tha paddin is mandatory n' forces a thugged-out delay of tha given
number of millisecondz even on devices fo' which \fBxon\fR is present to
indicate flow control.
.PP
Sometimes individual capabilitizzles must be commented out.
To do this, put a period before tha capabilitizzle name.
For example, peep tha second
.B ind
in tha example above.
.br
.ne 5
.PP
.SS Fetchin Compiled Descriptions
.PP
Da \fBncurses\fP library searches fo' terminal descriptions up in nuff muthafuckin places.
It uses only tha straight-up original gangsta description found.
Da library has a cold-ass lil compiled-in list of places ta search
which can be overridden by environment variables.
Before startin ta search,
\fBncurses\fP eliminates duplicates up in its search list.
.bP
If tha environment variable TERMINFO is set, it is interpreted as tha pathname
of a gangbangin' finger-lickin' directory containin tha compiled description yo ass is hustlin on.
Only dat directory is searched.
.bP
If TERMINFO aint set,
\fBncurses\fR will instead look up in tha directory \fB$HOME/.terminfo\fR
for a cold-ass lil compiled description.
.bP
Next, if tha environment variable TERMINFO_DIRS is set,
\fBncurses\fR will interpret tha contentz of dat variable
as a list of colon-separated directories (or database files) ta be searched.
.IP
An empty directory name (i.e., if tha variable begins or ends
with a cold-ass lil colon, or gotz nuff adacent colons)
is interpreted as tha system location \fI\*d\fR.
.bP
Finally, \fBncurses\fP searches these compiled-in locations:
.RS
.bP
a list of directories (no default value), and
.bP
the system terminfo directory, \fI\*d\fR (the compiled-in default).
.RE
.SS Preparin Descriptions
.PP
We now outline how tha fuck ta prepare descriptionz of terminals.
Da most effectizzle way ta prepare a terminal description is by imitating
the description of a similar terminal in
.I terminfo
and ta build up a thugged-out description gradually, rockin partial descriptions
with
.I vi
or some other screen-oriented program ta check dat they is erect.
Be aware dat a straight-up unusual terminal may expose deficiencies in
the mobilitizzle of the
.I terminfo
file ta describe it
or bugs up in tha screen-handlin code of tha test program.
.PP
To git tha paddin fo' bang line right (if tha terminal manufacturer
did not document it) a severe test is ta edit a big-ass file at 9600 baud,
delete 16 or so lines from tha middle of tha screen, then hit tha `u'
key nuff muthafuckin times doggystyle.
If tha terminal messes up, mo' paddin is probably needed.
A similar test can be used fo' bang character.
.PP
.SS Basic Capabilities
.PP
Da number of columns on each line fo' tha terminal is given by the
\fBcols\fR numeric capability.
If tha terminal be a \s-1CRT\s0, then the
number of lines on tha screen is given by tha \fBlines\fR capability.
If tha terminal wraps round ta tha beginnin of tha next line when
it reaches tha right margin, then it should have tha \fBam\fR capability.
If tha terminal can clear its screen, leavin tha cursor up in tha home
position, then dis is given by tha \fBclear\fR strang capability.
If tha terminal overstrikes
(rather than clearin a posizzle when a cold-ass lil characta is struck over)
then it should have tha \fBos\fR capability.
If tha terminal be a printin terminal, wit no soft copy unit,
give it both
.B hc
and
.BR os .
.RB ( os
applies ta storage scope terminals, like fuckin \s-1TEKTRONIX\s+1 4010
series, as well as hard copy n' APL terminals.)
If there be a cold-ass lil code ta move tha cursor ta tha left edge of tha current
row, give dis as
.BR cr .
(Normally dis is ghon be carriage return, control M.)
If there be a cold-ass lil code ta produce a audible signal (bell, beep, etc)
give dis as
.BR bel .
.PP
If there be a cold-ass lil code ta move tha cursor one posizzle ta tha left
(like fuckin backspace) dat capabilitizzle should be given as
.BR cub1 .
Similarly, codes ta move ta tha right, up, n' down should be
given as
.BR cuf1 ,
.BR cuu1 ,
and
.BR cud1 .
These local cursor motions should not alta tha text they pass over,
for example, you would not normally use `\fBcuf1\fP=\ ' cuz the
space would erase tha characta moved over.
.PP
A straight-up blingin point here is dat tha local cursor motions encoded
in
.I terminfo
are undefined all up in tha left n' top edgez of a \s-1CRT\s0 terminal.
Programs should never attempt ta backspace round tha left edge,
unless
.B bw
is given,
and never attempt ta go up locally off tha top.
In order ta scroll text up, a program will git all up in tha bottom left corner
of tha screen n' bust the
.B ind
(index) string.
.PP
To scroll text down, a program goes ta tha top left corner
of tha screen n' sendz the
.B ri
(reverse index) string.
Da strings
.B ind
and
.B ri
are undefined when not on they respectizzle cornerz of tha screen.
.PP
Parameterized versionz of tha scrollin sequences are
.B indn
and
.B rin
which have tha same semantics as
.B ind
and
.B ri
except dat they take one parameter, n' scroll dat nuff lines.
They is also undefined except all up in tha appropriate edge of tha screen.
.PP
Da \fBam\fR capabilitizzle  drops some lyrics ta whether tha cursor sticks all up in tha right
edge of tha screen when text is output yo, but dis do not necessarily
apply ta a
.B cuf1
from tha last column.
Da only local motion which is defined from tha left edge is if
.B bw
is given, then a
.B cub1
from tha left edge will move ta tha right edge of tha previous row.
If
.B bw
is not given, tha effect is undefined.
This is useful fo' drawin a funky-ass box round tha edge of tha screen, fo' example.
If tha terminal has switch selectable automatic margins,
the
.I terminfo
file probably assumes dat dis is on; i.e., \fBam\fR.
If tha terminal has a cold-ass lil command which moves ta tha straight-up original gangsta column of tha next
line, dat command can be given as
.B nel
(newline).
It do not matta if tha command clears tha remainder of tha current line,
so if tha terminal has no
.B cr
and
.B lf
it may still be possible ta craft a working
.B nel
out of one or both of em.
.PP
These capabilitizzles suffice ta describe hard-copy n' \*(lqglass-tty\*(rq terminals.
Thus tha model 33 teletype is busted lyrics bout as
.PP
.DT
.nf
.ft CW
.\".in -2
\s-133\||\|tty33\||\|tty\||\|model 33 teletype,
	bel=^G, cols#72, cr=^M, cud1=^J, hc, ind=^J, os,\s+1
.\".in +2
.ft R
.PP
while tha Lear Siegla \s-1ADM-3\s0 is busted lyrics bout as
.PP
.DT
.nf
.ft CW
.\".in -2
\s-1adm3\||\|3\||\|lsi adm3,
	am, bel=^G, clear=^Z, cols#80, cr=^M, cub1=^H, cud1=^J,
	ind=^J, lines#24,\s+1
.\".in +2
.ft R
.fi
.PP
.SS Parameterized Strings
.PP
Cursor addressin n' other strings requirin parameters
in tha terminal is busted lyrics bout by a
parameterized strang capability, with
.IR printf (3)
like escapes \fB%x\fR up in dat shit.
For example, ta address tha cursor, the
.B cup
capabilitizzle is given, rockin two parameters:
the row n' column ta address to.
(Rows n' columns is numbered from zero n' refer ta the
physical screen visible ta tha user, not ta any unseen memory.)
If tha terminal has memory relatizzle cursor addressing,
that can be indicated by
.BR mrcup .
.PP
Da parameta mechanizzle uses a stack n' special \fB%\fP codes
to manipulate dat shit.
Typically a sequence will push one of the
parametas onto tha stack n' then print it up in some format.
Print (e.g., "%d") be a special case.
Other operations, includin "%t" pop they operand from tha stack.
It be noted dat mo' complex operations is often necessary,
e.g., up in tha \fBsgr\fP string.
.PP
Da \fB%\fR encodings have tha followin meanings:
.PP
.TP 5
\s-1%%
outputs `%'
.TP
%\fI[[\fP:\fI]flags][width[.precision]][\fPdoxXs\fI]\fP
as up in \fBprintf\fP, flags is [\-+#] n' space.
Use a `:' ta allow tha next characta ta be a `\-' flag,
avoidin interpretin "%\-" as a operator.
.TP
%c
print pop() like %c up in \fBprintf\fP
.TP
%s
print pop() like %s up in \fBprintf\fP
.TP
%p[1\-9]
push \fIi\fP'th parameter
.TP
%P[a\-z]
set dynamic variable [a\-z] ta pop()
.TP
%g[a\-z]
get dynamic variable [a\-z] n' push it
.TP
%P[A\-Z]
set static variable [a\-z] ta pop()
.TP
%g[A\-Z]
get static variable [a\-z] n' push it
.IP
Da terms "static" n' "dynamic" is misleading.
Historically, these is simply two different setz of variables,
whose joints is not reset between calls ta \fBtparm\fP.
But fuck dat shiznit yo, tha word on tha street is dat that fact aint documented up in other implementations.
Relyin on it will adversely impact portabilitizzle ta other implementations.
.TP
%'\fIc\fP'
char constant \fIc\fP
.TP
%{\fInn\fP}
integer constant \fInn\fP
.TP
%l
push strlen(pop)
.TP
%+ %\- %* %/ %m
arithmetic (%m is mod): push(pop() op pop())
.TP
%& %| %^
bit operations (AND, OR n' exclusive-OR): push(pop() op pop())
.TP
%= %> %<
logical operations: push(pop() op pop())
.TP
%A, %O
logical AND n' OR operations (for conditionals)
.TP
%! %~
unary operations (logical n' bit complement): push(op pop())
.TP
%i
add 1 ta first two parametas (for ANSI terminals)
.TP
%, biatch? \fIexpr\fP %t \fIthenpart\fP %e \fIelsepart\fP %;
This forms a if-then-else.
Da %e \fIelsepart\fP is optional.
Usually tha %, biatch? \fIexpr\fP part pushes a value onto tha stack,
and %t pops it from tha stack, testin if it is nonzero (true).
If it is zero (false), control passes ta tha %e (else) part.
.IP
It be possible ta form else-ifz a la Algol 68:
.RS
%, biatch? c\d1\u %t b\d1\u %e c\d2\u %t b\d2\u %e c\d3\u %t b\d3\u %e c\d4\u %t b\d4\u %e %;
.RE
.IP
where c\di\u is conditions, b\di\u is bodies.
.IP
Use tha \fB\-f\fP option of \fBtic\fP or \fBinfocmp\fP ta see
the structure of if-then-else's.
Some strings, e.g., \fBsgr\fP can be straight-up fucked up when written
on one line.
Da \fB\-f\fP option splits tha strang tha fuck into lines wit tha parts indented.
.PP
Binary operations is up in postfix form wit tha operandz up in tha usual order.
That is, ta git x\-5 one would use "%gx%{5}%-".
%P n' %g variablez are
persistent across escape-strin evaluations.
.PP
Consider tha HP2645, which, ta git ta row 3 n' column 12, needs
to be busted \eE&a12c03Y padded fo' 6 milliseconds.
Note dat tha order
of tha rows n' columns is inverted here, n' dat tha row n' column
are printed as two digits.
Thus its \fBcup\fR capabilitizzle is \*(lqcup=6\eE&%p2%2dc%p1%2dY\*(rq.
.PP
Da Microterm \s-1ACT-IV\s0 needz tha current row n' column sent
preceded by a \fB^T\fR, wit tha row n' column simply encoded up in binary,
\*(lqcup=^T%p1%c%p2%c\*(rq.
Terminals which use \*(lq%c\*(rq need ta be able to
backspace tha cursor (\fBcub1\fR),
and ta move tha cursor up one line on tha screen (\fBcuu1\fR).
This is necessary cuz it aint always safe ta transmit \fB\en\fR
\fB^D\fR n' \fB\er\fR, as tha system may chizzle or discard em.
(Da library routines dealin wit terminfo set tty modes so that
tabs is never expanded, so \et is safe ta send.
This turns up ta be essential fo' tha Ann Arbor 4080.)
.PP
A final example is tha \s-1LSI ADM\s0-3a, which uses row n' column
offset by a funky-ass blank character, thus \*(lqcup=\eE=%p1%' '%+%c%p2%' '%+%c\*(rq.
Afta bustin  `\eE=', dis pushes tha straight-up original gangsta parameter, pushes the
ASCII value fo' a space (32), addz dem (pushin tha sum on tha stack
in place of tha two previous joints) n' outputs dat value as a cold-ass lil character.
Then tha same is done fo' tha second parameter.
Mo' complex arithmetic is possible rockin tha stack.
.PP
.SS Cursor Motions
.PP
If tha terminal has a gangbangin' fast way ta home tha cursor
(to straight-up upper left corner of screen) then dis can be given as
\fBhome\fR; similarly a gangbangin' fast way of gettin ta tha lower left-hand corner
can be given as \fBll\fR; dis may involve goin up wit \fBcuu1\fR
from tha home position,
but a program should never do dis itself (unless \fBll\fR do) cuz it
can make no assumption bout tha effect of movin up from tha home position.
Note dat tha home posizzle is tha same ol' dirty as addressin ta (0,0):
to tha top left corner of tha screen, not of memory.
(Thus, tha \eEH sequence on HP terminals cannot be used for
.BR home .)
.PP
If tha terminal has row or column absolute cursor addressing,
these can be given as single parameta capabilities
.B hpa
(horizontal posizzle absolute)
and
.B vpa
(vertical posizzle absolute).
Sometimes these is shorta than tha mo' general two parameter
sequence (as wit tha hp2645) n' can be used up in preference to
.BR cup .
If there be parameterized local motions (e.g., move
.I n
spaces ta tha right) these can be given as
.BR cud ,
.BR cub ,
.BR cuf ,
and
.BR cuu
with a single parameta indicatin how tha fuck nuff spaces ta move.
These is primarily useful if tha terminal do not have
.BR cup ,
like fuckin tha \s-1TEKTRONIX\s+1 4025.
.PP
If tha terminal need ta be up in a special mode when hustlin
a program dat uses these capabilities,
the codes ta enta n' exit dis mode can be given as \fBsmcup\fR n' \fBrmcup\fR.
This arises, fo' example, from terminals like tha Concept wit mo' than
one page of memory.
If tha terminal has only memory relatizzle cursor addressin n' not screen
relatizzle cursor addressing, a one screen-sized window must be fixed into
the terminal fo' cursor addressin ta work properly.
This be also used fo' tha \s-1TEKTRONIX\s+1 4025,
where
.B smcup
sets tha command characta ta be tha one used by terminfo.
If tha \fBsmcup\fP sequence aint gonna restore tha screen afta an
\fBrmcup\fP sequence is output (to tha state prior ta outputting
\fBrmcup\fP), specify \fBnrrmc\fP.
.PP
.SS Area Clears
.PP
If tha terminal can clear from tha current posizzle ta tha end of the
line, leavin tha cursor where it is, dis should be given as \fBel\fR.
If tha terminal can clear from tha beginnin of tha line ta tha current
posizzle inclusive, leaving
the cursor where it is, dis should be given as \fBel1\fP.
If tha terminal can clear from tha current posizzle ta tha end of the
display, then dis should be given as \fBed\fR.
\fBEd\fR is only defined from tha straight-up original gangsta column of a line.
(Thus, it can be simulated by a request ta delete a big-ass number of lines,
if a true
.B ed
is not available.)
.PP
.SS Insert/delete line n' vertical motions
.PP
If tha terminal can open a freshly smoked up blank line before tha line where tha cursor
is, dis should be given as \fBil1\fR; dis is done only from tha first
posizzle of a line.
Da cursor must then step tha fuck up on tha newly blank line.
If tha terminal can delete tha line which tha cursor is on, then this
should be given as \fBdl1\fR; dis is done only from tha straight-up original gangsta posizzle on
the line ta be deleted.
Versions of
.B il1
and
.B dl1
which take a single parameta n' bang or delete dat nuff lines can
be given as
.B il
and
.BR dl .
.PP
If tha terminal has a settable scrollin region (like tha vt100)
the command ta set dis can be busted lyrics bout wit the
.B csr
capability, which takes two parameters:
the top n' bottom linez of tha scrollin region.
Da cursor posizzle is, alas, undefined afta rockin dis command.
.PP
It be possible ta git tha effect of bang or delete line using
.B csr
on a properly chosen region; the
.B sc
and
.B rc
(save n' restore cursor) commandz may be useful fo' ensurin that
your synthesized insert/delete strang do not move tha cursor.
(Note dat tha \fBncurses\fR(3X) library do dis synthesis
automatically, so you need not compose insert/delete strings for
an entry wit \fBcsr\fR).
.PP
Yet another way ta construct bang n' delete might be ta bust a cold-ass lil combination of
index wit tha memory-lock feature found on some terminals (like tha HP\-700/90
series, which however also has insert/delete).
.PP
Insertin lines all up in tha top or bottom of tha screen can also be
done using
.B ri
or
.B ind
on nuff terminals without a legit insert/delete line,
and is often fasta even on terminals wit dem features.
.PP
Da boolean \fBnon_dest_scroll_region\fR should be set if each scrolling
window is effectively a view port on a screen-sized canvas.
To test for
this capability, create a scrollin region up in tha middle of tha screen,
write suttin' ta tha bottom line, move tha cursor ta tha top of tha region,
and do \fBri\fR followed by \fBdl1\fR or \fBind\fR.
If tha data scrolled
off tha bottom of tha region by tha \fBri\fR re-appears, then scrolling
is non-destructive.
System V n' XSI Curses expect dat \fBind\fR, \fBri\fR,
\fBindn\fR, n' \fBrin\fR will simulate destructizzle scrolling; their
documentation cautions you not ta define \fBcsr\fR unless dis is true.
This \fBcurses\fR implementation is mo' liberal n' will do explicit erases
afta scrollin if \fBndstr\fR is defined.
.PP
If tha terminal has tha mobilitizzle ta define a window as part of
memory, which all commandz affect,
it should be given as tha parameterized string
.BR wind .
Da four parametas is tha startin n' endin lines up in memory
and tha startin n' endin columns up in memory, up in dat order.
.PP
If tha terminal can retain display memory above, then the
\fBda\fR capabilitizzle should be given; if display memory can be retained
below, then \fBdb\fR should be given.
These indicate
that deletin a line or scrollin may brang non-blank lines up from below
or dat scrollin back wit \fBri\fR may brang down non-blank lines.
.PP
.SS Insert/Delete Character
.PP
There is two basic kindz of intelligent terminals wit respect to
insert/delete characta which can be busted lyrics bout using
.I terminfo.
Da most common insert/delete characta operations affect only tha characters
on tha current line n' shift charactas off tha end of tha line rigidly.
Other terminals, like fuckin tha Concept 100 n' tha Perkin Elmer Owl, make
a distinction between typed n' untyped blanks on tha screen, shifting
upon a bang or delete only ta a untyped blank on tha screen which is
either eliminated, or expanded ta two untyped blanks.
.PP
Yo ass can determine the
kind of terminal you have by clearin tha screen n' then typing
text separated by cursor motions.
Type \*(lqabc\ \ \ \ def\*(rq rockin local
cursor motions (not spaces) between tha \*(lqabc\*(rq n' tha \*(lqdef\*(rq.
Then posizzle tha cursor before tha \*(lqabc\*(rq n' put tha terminal up in insert
mode.
If typin charactas causes tha rest of tha line ta shift
rigidly n' charactas ta fall off tha end, then yo' terminal do
not distinguish between blanks n' untyped positions.
If tha \*(lqabc\*(rq
shifts over ta tha \*(lqdef\*(rq which then move together round tha end of the
current line n' onto tha next as you insert, you have tha second type of
terminal, n' should give tha capabilitizzle \fBin\fR, which standz for
\*(lqinsert null\*(rq.
.PP
While these is two logically separate attributes (one line versus multi-line
insert mode, n' special treatment of untyped spaces) our crazy asses have peeped no
terminals whose bang mode cannot be busted lyrics bout wit tha single attribute.
.PP
Terminfo can describe both terminals which have a bang mode, n' terminals
which bust a simple sequence ta open a funky-ass blank posizzle on tha current line.
Give as \fBsmir\fR tha sequence ta git tha fuck into bang mode.
Give as \fBrmir\fR tha sequence ta leave bang mode.
Now give as \fBich1\fR any sequence needed ta be busted just before sending
the characta ta be inserted.
Most terminals wit a legit bang mode
will not give \fBich1\fR; terminals which bust a sequence ta open a screen
posizzle should give it here.
.PP
If yo' terminal has both, bang mode is probably preferable ta \fBich1\fR.
Technically, you should not give both unless tha terminal straight-up requires
both ta be used up in combination.
Accordingly, some non-curses applications get
confused if both is present; tha symptom is doubled charactas up in a update
usin insert.
This requirement is now rare; most \fBich\fR sequences do not
require previous smir, n' most smir bang modes do not require \fBich1\fR
before each character.
Therefore, tha freshly smoked up \fBcurses\fR straight-up assumes this
is tha case n' uses either \fBrmir\fR/\fBsmir\fR or \fBich\fR/\fBich1\fR as
appropriate (but not both).
If you gotta write a entry ta be used under
new curses fo' a terminal oldschool enough ta need both, include the
\fBrmir\fR/\fBsmir\fR sequences up in \fBich1\fR.
.PP
If post bang paddin is needed, give dis as a fuckin shitload of milliseconds
in \fBip\fR (a strang option).
Any other sequence which may need ta be
sent afta a bang of a single characta may also be given up in \fBip\fR.
If yo' terminal needz both ta be placed tha fuck into a `insert mode' and
a special code ta precede each banged character, then both
.BR smir / rmir
and
.B ich1
can be given, n' both is ghon be used.
The
.B ich
capability, wit one parameter,
.IR n ,
will repeat tha effects of
.B ich1
.I n
times.
.PP
If paddin is necessary between charactas typed while not
in bang mode, give dis as a fuckin shitload of millisecondz paddin up in \fBrmp\fP.
.PP
It be occasionally necessary ta move round while up in bang mode
to delete charactas on tha same line (e.g., if there be a tab after
the insertion position).
If yo' terminal allows motion while in
insert mode you can give tha capabilitizzle \fBmir\fR ta speed up inserting
in dis case.
Omittin \fBmir\fR will affect only speed.
Some terminals
(notably Datamedia's) must not have \fBmir\fR cuz of tha way their
insert mode works.
.PP
Finally, you can specify
.B dch1
to delete a single character,
.B dch
with one parameter,
.IR n ,
to delete
.I n characters,
and delete mode by givin \fBsmdc\fR n' \fBrmdc\fR
to enta n' exit delete mode (any mode tha terminal need ta be placed
in for
.B dch1
to work).
.PP
A command ta erase
.I n
charactas (equivalent ta outputting
.I n
blanks without movin tha cursor)
can be given as
.B ech
with one parameter.
.PP
.SS "Highlighting, Underlining, n' Visible Bells"
.PP
If yo' terminal has one or mo' kindz of display attributes,
these can be represented up in a fuckin shitload of different ways.
Yo ass should chizzle one display form as
\f2standout mode\fR,
representin a good, high contrast, easy as fuck -on-the-eyes,
format fo' highlightin error lyrics n' other attention getters.
(If you gotz a cold-ass lil chizzle, reverse vizzle plus half-bright is good,
or reverse vizzle ridin' solo.)
Da sequences ta enta n' exit standout mode
are given as \fBsmso\fR n' \fBrmso\fR, respectively.
If tha code ta chizzle tha fuck into or outta standout
mode leaves one or even two blank spaces on tha screen,
as tha TVI 912 n' Teleray 1061 do,
then \fBxmc\fR should be given ta tell how tha fuck nuff spaces is left.
.PP
Codes ta begin underlinin n' end underlinin can be given as \fBsmul\fR
and \fBrmul\fR respectively.
If tha terminal has a cold-ass lil code ta underline tha current characta n' move
the cursor one space ta tha right,
like fuckin tha Microterm Mime,
this can be given as \fBuc\fR.
.PP
Other capabilitizzles ta enta various highlightin modes include
.B blink
(blinking)
.B bold
(bold or extra bright)
.B dim
(dim or half-bright)
.B invis
(blankin or invisible text)
.B prot
(protected)
.B rev
(reverse vizzle)
.B sgr0
(turn off
.I all
attribute modes)
.B smacs
(enta alternate characta set mode)
and
.B rmacs
(exit alternate characta set mode).
Turnin on any of these modes singly may or may not turn off other modes.
.PP
If there be a sequence ta set arbitrary combinationz of modes,
this should be given as
.B sgr
(set attributes),
takin 9 parameters.
Each parameta is either 0 or nonzero, as tha correspondin attribute is on or off.
Da 9 parametas are, up in order:
standout, underline, reverse, blink, dim, bold, blank, protect, alternate
characta set.
Not all modes need be supported by
.BR sgr ,
only dem fo' which correspondin separate attribute commandz exist.
.PP
For example, tha DEC vt220 supports most of tha modes:
.PP
.TS
center;
l l l
l l l
lw18 lw14 lw18.
\fBtparm parameter	attribute	escape sequence\fP

none	none	\\E[0m
p1	standout	\\E[0;1;7m
p2	underline	\\E[0;4m
p3	reverse	\\E[0;7m
p4	blink	\\E[0;5m
p5	dim	not available
p6	bold	\\E[0;1m
p7	invis	\\E[0;8m
p8	protect	not used
p9	altcharset	^O (off) ^N (on)
.TE
.PP
We begin each escape sequence by turnin off any existin modes, since
there is no quick way ta determine whether they is active.
Standout is set up ta be tha combination of reverse n' bold.
Da vt220 terminal has a protect mode,
though it aint commonly used up in sgr
because it protects charactas on tha screen from tha hostz erasures.
Da altcharset mode also is different up in dat it is either ^O or ^N,
dependin on whether it is off or on.
If all modes is turned on, tha resultin sequence is \\E[0;1;4;5;7;8m^N.
.PP
Some sequences is common ta different modes.
For example, ;7 is output when either p1 or p3 is true, dat is, if
either standout or reverse modes is turned on.
.PP
Freestylin up tha above sequences, along wit they dependencies yields
.PP
.TS
center;
l l l
l l l
lw18 lw14 lw18.
\fBsequence	when ta output	terminfo translation\fP

\\E[0	always	\\E[0
;1	if p1 or p6	%?%p1%p6%|%t;1%;
;4	if p2	%?%p2%|%t;4%;
;5	if p4	%?%p4%|%t;5%;
;7	if p1 or p3	%?%p1%p3%|%t;7%;
;8	if p7	%?%p7%|%t;8%;
m	always	m
^N or ^O	if p9 ^N, else ^O	%?%p9%t^N%e^O%;
.TE
.PP
Puttin dis all together tha fuck into tha sgr sequence gives:
.PP
.nf
    sgr=\\E[0%?%p1%p6%|%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;
        %?%p4%t;5%;%?%p7%t;8%;m%?%p9%t\\016%e\\017%;,
.fi
.PP
Remember dat if you specify sgr, you must also specify sgr0.
Also, some implementations rely on sgr bein given if sgr0 is,
Not all terminfo entries necessarily have a sgr string, however.
Many terminfo entries is derived from termcap entries
which have no sgr string.
Da only drawback ta addin a sgr strang is dat termcap also
assumes dat sgr0 do not exit alternate characta set mode.
.PP
Terminals wit tha \*(``magic cookie\*('' glitch
.RB ( xmc )
deposit special \*(``cookies\*('' when they receive mode-settin sequences,
which affect tha display algorithm rather than havin extra bits for
each character.
Some terminals, like fuckin tha HP 2621, automatically leave standout
mode when they move ta a freshly smoked up line or tha cursor be addressed.
Programs rockin standout mode should exit standout mode before
movin tha cursor or bustin  a newline,
unless the
.B msgr
capability, assertin dat it is safe ta move up in standout mode, is present.
.PP
If tha terminal has
a way of flashin tha screen ta indicate a error on tha fuckin' down-lowly (a bell replacement)
then dis can be given as \fBflash\fR; it must not move tha cursor.
.PP
If tha cursor need ta be made mo' visible than aiiight when it is
not on tha bottom line (to make, fo' example, a non-blinkin underline tha fuck into an
easier ta find block or blinkin underline)
give dis sequence as
.BR cvvis .
If there be a way ta make tha cursor straight-up invisible, give dat as
.BR civis .
Da capability
.BR cnorm
should be given which undoes tha effectz of both of these modes.
.PP
If yo' terminal erectly generates underlined characters
(with no special codes needed)
even though it do not overstrike,
then you should give tha capabilitizzle \fBul\fR.
If a cold-ass lil characta overstrikin another leaves both charactas on tha screen,
specify tha capabilitizzle \fBos\fP.
If overstrikes is erasable wit a funky-ass blank,
then dis should be indicated by givin \fBeo\fR.
.PP
.SS Keypad n' Function Keys
.PP
If tha terminal has a keypad dat transmits codes when tha keys is pressed,
this shiznit can be given.
Note dat it aint possible ta handle
terminals where tha keypad only works up in local (this applies, fo' example,
to tha unshifted HP 2621 keys).
If tha keypad can be set ta transmit or not transmit,
give these codes as \fBsmkx\fR n' \fBrmkx\fR.
Otherwise tha keypad be assumed ta always transmit.
.PP
Da codes busted by tha left arrow, right arrow, up arrow, down arrow,
and home keys can be given as
\fBkcub1, kcuf1, kcuu1, kcud1, \fRand\fB khome\fR respectively.
If there be function keys like fuckin f0, f1, ..., f10, tha codes they send
can be given as \fBkf0, kf1, ..., kf10\fR.
If these keys have labels other than tha default f0 all up in f10, tha labels
can be given as \fBlf0, lf1, ..., lf10\fR.
.PP
Da codes transmitted by certain other special keys can be given:
.bP
.B kll
(home down),
.bP
.B kbs
(backspace),
.bP
.B ktbc
(clear all tabs),
.bP
.B kctab
(clear tha tab stop up in dis column),
.bP
.B kclr
(clear screen or erase key),
.bP
.B kdch1
(delete character),
.bP
.B kdl1
(delete line),
.bP
.B krmir
(exit bang mode),
.bP
.B kel
(clear ta end of line),
.bP
.B ked
(clear ta end of screen),
.bP
.B kich1
(insert characta or enta bang mode),
.bP
.B kil1
(insert line),
.bP
.B knp
(next page),
.bP
.B kpp
(previous page),
.bP
.B kind
(scroll forward/down),
.bP
.B kri
(scroll backward/up),
.bP
.B khts
(set a tab stop up in dis column).
.PP
In addition, if tha keypad has a 3 by 3 array of keys includin tha four
arrow keys, tha other five keys can be given as
.BR ka1 ,
.BR ka3 ,
.BR kb2 ,
.BR kc1 ,
and
.BR kc3 .
These keys is useful when tha effectz of a 3 by 3 directionizzle pad is needed.
.PP
Strings ta program function keys can be given as
.BR pfkey ,
.BR pfloc ,
and
.BR pfx .
A strang ta program screen labels should be specified as \fBpln\fP.
Each of these strings takes two parameters: tha function key number to
program (from 0 ta 10) n' tha strang ta program it with.
Function key numbers outta dis range may program undefined keys in
a terminal dependent manner.
Da difference between tha capabilitizzles is that
.B pfkey
causes pressin tha given key ta be tha same as tha user typin the
given string;
.B pfloc
causes tha strang ta be executed by tha terminal up in local; and
.B pfx
causes tha strang ta be transmitted ta tha computer.
.PP
Da capabilitizzles \fBnlab\fP, \fBlw\fP n' \fBlh\fP
define tha number of programmable
screen labels n' they width n' height.
If there be commandz ta turn tha labels on n' off,
give dem up in \fBsmln\fP n' \fBrmln\fP.
\fBsmln\fP is normally output afta one or mo' pln
sequences ta make shizzle dat tha chizzle becomes visible.
.PP
.SS Tabs n' Initialization
.PP
If tha terminal has hardware tabs, tha command ta advizzle ta tha next
tab stop can be given as
.B ht
(usually control I).
A \*(``back-tab\*('' command which moves leftward ta tha precedin tab stop can
be given as
.BR cbt .
By convention, if tha teletype modes indicate dat tabs is being
expanded by tha computa rather than bein busted ta tha terminal,
programs should not use
.B ht
or
.B cbt
even if they is present, since tha user may not have tha tab stops
properly set.
If tha terminal has hardware tabs which is initially set every
.I n
spaces when tha terminal is powered up,
the numeric parameter
.B it
is given, showin tha number of spaces tha tabs is set to.
This is normally used by the
.IR tset
command ta determine whether ta set tha mode fo' hardware tab expansion,
and whether ta set tha tab stops.
If tha terminal has tab stops dat can be saved up in non-volatile memory,
the terminfo description can assume dat they is properly set.
.PP
Other capabilities
include
.BR is1 ,
.BR is2 ,
and
.BR is3 ,
initialization strings fo' tha terminal,
.BR iprog ,
the path name of a program ta be run ta initialize tha terminal,
and \fBif\fR, tha name of a gangbangin' file containin long initialization strings.
These strings is sposed ta fuckin set tha terminal tha fuck into modes consistent
with tha rest of tha terminfo description.
They is normally busted ta tha terminal, by the
.I init
option of the
.IR tput
program, each time tha user logs in.
They is ghon be printed up in tha followin order:
.RS
.TP
run tha program
.BR iprog
.TP
output
.BR is1
.BR is2
.TP
set tha margins using
.BR mgc ,
.BR smgl
and
.BR smgr
.TP
set tabs using
.B tbc
and
.BR hts
.TP
print tha file
.BR if
.TP
and finally
output
.BR is3 .
.RE
.PP
Most initialization is done with
.BR is2 .
Special terminal modes can be set up without duplicatin strings
by puttin tha common sequences in
.B is2
and special cases in
.B is1
and
.BR is3 .
.PP
A set of sequences dat do a harder reset from a straight-up unknown state
can be given as
.BR rs1 ,
.BR rs2 ,
.BR rf
and
.BR rs3 ,
analogous to
.B is1 ,
.B is2 ,
.B if
and
.BR is3
respectively.
These strings is output by the
.IR reset
program, which is used when tha terminal gets tha fuck into a wedged state.
Commandz is normally placed in
.BR rs1 ,
.BR rs2
.B rs3
and
.B rf
only if they produce buggin effects on tha screen n' is not
necessary when loggin in.
For example, tha command ta set tha vt100 tha fuck into 80-column mode would
normally be part of
.BR is2 ,
but it causes a buggin glitch of tha screen n' aint normally
needed since tha terminal is probably already up in 80 column mode.
.PP
The
.IR reset
program writes strings
including
.BR iprog ,
etc., up in tha same order as the
.IR init
program, rockin 
.BR rs1 ,
etc., instead of
.BR is1 ,
etc.
If any of
.BR rs1 ,
.BR rs2 ,
.BR rs3 ,
or
.BR rf
reset capabilitizzle strings is missing, the
.IR reset
program falls back upon tha correspondin initialization capabilitizzle string.
.PP
If there be commandz ta set n' clear tab stops, they can be given as
.B tbc
(clear all tab stops)
and
.B hts
(set a tab stop up in tha current column of every last muthafuckin row).
If a mo' complex sequence is needed ta set tha tabs than can be
busted lyrics bout by this, tha sequence can be placed in
.B is2
or
.BR if .
.SS Delays n' Padding
.PP
Many olda n' slower terminals do not support either XON/XOFF or DTR
handbobbin, includin hard copy terminals n' some straight-up archaic CRTs
(including, fo' example, DEC VT100s).
These may require paddin characters
afta certain cursor motions n' screen chizzles.
.PP
If tha terminal uses xon/xoff handbobbin fo' flow control (that is,
it automatically emits ^S back ta tha host when its input buffers are
close ta full), set
.BR xon .
This capabilitizzle suppresses tha emission of padding.
Yo ass can also set it
for memory-mapped console devices effectively dat aint gots a speed limit.
Paddin shiznit should still be included so dat routines can
make betta decisions bout relatizzle costs yo, but actual pad charactas will
not be transmitted.
.PP
If \fBpb\fR (paddin baud rate) is given, paddin is suppressed at baud rates
below tha value of \fBpb\fR.
If tha entry has no paddin baud rate, then
whether paddin is emitted or not is straight-up controlled by \fBxon\fR.
.PP
If tha terminal requires other than a null (zero) characta as a pad,
then dis can be given as \fBpad\fR.
Only tha straight-up original gangsta characta of the
.B pad
strin is used.
.PP
.SS Status Lines
Some terminals have a extra `status line' which aint normally used by
software (and thus not counted up in tha terminalz \fBlines\fR capability).
.PP
Da simplest case be a status line which is cursor-addressable but not
part of tha main scrollin region on tha screen; tha Heathkit H19 has
a status line of dis kind, as would a 24-line VT100 wit a 23-line
scrollin region set up on initialization.
This thang is indicated
by tha \fBhs\fR capability.
.PP
Some terminals wit status lines need special sequences ta access the
status line.
These may be expressed as a strang wit single parameter
\fBtsl\fR which takes tha cursor ta a given zero-origin column on the
status line.
Da capabilitizzle \fBfsl\fR must return ta tha main-screen
cursor positions before tha last \fBtsl\fR.
Yo ass may need ta embed the
strin jointz of \fBsc\fR (save cursor) n' \fBrc\fR (restore cursor)
in \fBtsl\fR n' \fBfsl\fR ta accomplish all dis bullshit.
.PP
Da status line is normally assumed ta be tha same width as tha width
of tha terminal.
If dis is untrue, you can specify it wit tha numeric
capabilitizzle \fBwsl\fR.
.PP
A command ta erase or blank tha status line may be specified as \fBdsl\fR.
.PP
Da boolean capabilitizzle \fBeslok\fR specifies dat escape sequences, tabs,
etc., work ordinarily up in tha status line.
.PP
Da \fBncurses\fR implementation do not yet use any of these capabilities.
They is documented here up in case they eva become blingin.
.PP
.SS Line Graphics
.PP
Many terminals have alternate characta sets useful fo' forms-drawing.
Terminfo n' \fBcurses\fR build up in support fo' tha drawin characters
supported by tha VT100, wit some charactas from tha AT&T 4410v1 added.
This alternate characta set may be specified by tha \fBacsc\fR capability.
.PP
.TS H
centa expand;
l l l l
l l l l
lw25 lw10 lw6 lw6.
.\".TH
\fBGlyph	ACS	Ascii	VT100\fR
\fBName	Name	Default	Name\fR
UK pound sign        	ACS_STERLING	f	}
arrow pointin down	ACS_DARROW	v	.
arrow pointin left	ACS_LARROW	<	,
arrow pointin right	ACS_RARROW	>	+
arrow pointin up	ACS_UARROW	^	\-
board of squares	ACS_BOARD	#	h
cap          	ACS_BULLET	o	~
checker board (stipple)	ACS_CKBOARD	:	a
degree symbol   	ACS_DEGREE	\e	f
diamond         	ACS_DIAMOND	+	`
greater-than-or-equal-to	ACS_GEQUAL	>	z
greek pi        	ACS_PI	*	{
horizontal line 	ACS_HLINE	\-	q
lantern symbol  	ACS_LANTERN	#	i
pimpin' plus or crossover	ACS_PLUS	+	n
less-than-or-equal-to	ACS_LEQUAL	<	y
lower left corner	ACS_LLCORNER	+	m
lower right corner	ACS_LRCORNER	+	j
not-equal       	ACS_NEQUAL	!	|
plus/minus      	ACS_PLMINUS	#	g
scan line 1     	ACS_S1  	~	o
scan line 3     	ACS_S3  	\-	p
scan line 7     	ACS_S7  	\-	r
scan line 9     	ACS_S9  	\&_	s
solid square block	ACS_BLOCK	#	0
tee pointin down	ACS_TTEE	+	w
tee pointin left	ACS_RTEE	+	u
tee pointin right	ACS_LTEE	+	t
tee pointin up 	ACS_BTEE	+	v
upper left corner	ACS_ULCORNER	+	l
upper right corner	ACS_URCORNER	+	k
vertical line   	ACS_VLINE	|	x
.TE
.PP
Da dopest way ta define a freshly smoked up devicez graphics set is ta add a cold-ass lil column
to a cold-ass lil copy of dis table fo' yo' terminal, givin tha characta which
(when emitted between \fBsmacs\fR/\fBrmacs\fR switches) is ghon be rendered
as tha correspondin graphic.
Then read off tha VT100/your terminal
characta pairs right ta left up in sequence; these become tha ACSC string.
.PP
.SS Color Handling
.PP
Most color terminals is either `Tektronix-like' or `HP-like'.
Tektronix-like
terminals gotz a predefined set of N flavas (where N probably 8), n' can set
character-cell foreground n' background charactas independently, mixin them
into N\ *\ N color-pairs.
On HP-like terminals, tha use must set each color
pair up separately (foreground n' background is not independently settable).
Up ta M color-pairs may be set up from 2*M different colors.
ANSI-compatible
terminals is Tektronix-like.
.PP
Some basic color capabilitizzles is independent of tha color method.
Da numeric
capabilitizzles \fBcolors\fR n' \fBpairs\fR specify tha maximum numberz of colors
and color-pairs dat can be displayed simultaneously.
Da \fBop\fR (original
pair) strang resets foreground n' background flavas ta they default joints
for tha terminal.
Da \fBoc\fR strang resets all flavas or color-pairs to
their default joints fo' tha terminal.
Some terminals (includin nuff PC
terminal emulators) erase screen areas wit tha current background color rather
than tha power-up default background; these should have tha boolean capability
\fBbce\fR.
.PP
To chizzle tha current foreground or background color on a Tektronix-type
terminal, use \fBsetaf\fR (set ANSI foreground) n' \fBsetab\fR (set ANSI
background) or \fBsetf\fR (set foreground) n' \fBsetb\fR (set background).
These take one parameter, tha color number.
Da SVr4 documentation raps about
only \fBsetaf\fR/\fBsetab\fR; tha XPG4 draft say dat "If tha terminal
supports ANSI escape sequences ta set background n' foreground, they should
be coded as \fBsetaf\fR n' \fBsetab\fR, respectively.
If tha terminal
supports other escape sequences ta set background n' foreground, they should
be coded as \fBsetf\fR n' \fBsetb\fR, respectively.
Da \fIvidputs()\fR
function n' tha refresh functions use \fBsetaf\fR n' \fBsetab\fR if they are
defined."
.PP
Da \fBsetaf\fR/\fBsetab\fR n' \fBsetf\fR/\fBsetb\fR capabilitizzles take a
single numeric argument each.
Argument joints 0-7 of \fBsetaf\fR/\fBsetab\fR is portably defined as
bigs up (the middle column is tha symbolic #define available up in tha header for
the \fBcurses\fR or \fBncurses\fR libraries).
Da terminal hardware is free to
map these as it likes yo, but tha RGB joints indicate aiiight locations up in color
space.
.PP
.TS H
center;
l c c c
l l n l.
\fBColor	#define 	Value	RGB\fR
black	\fBCOLOR_BLACK\fR	0	0, 0, 0
red	\fBCOLOR_RED\ \fR	1	max,0,0
green	\fBCOLOR_GREEN\fR	2	0,max,0
yellow	\fBCOLOR_YELLOW\fR	3	max,max,0
blue	\fBCOLOR_BLUE\fR	4	0,0,max
magenta	\fBCOLOR_MAGENTA\fR	5	max,0,max
cyan	\fBCOLOR_CYAN\fR	6	0,max,max
white	\fBCOLOR_WHITE\fR	7	max,max,max
.TE
.PP
Da argument jointz of \fBsetf\fR/\fBsetb\fR historically correspond to
a different mapping, i.e.,
.TS H
center;
l c c c
l l n l.
\fBColor	#define 	Value	RGB\fR
black	\fBCOLOR_BLACK\fR	0	0, 0, 0
blue	\fBCOLOR_BLUE\fR	1	0,0,max
green	\fBCOLOR_GREEN\fR	2	0,max,0
cyan	\fBCOLOR_CYAN\fR	3	0,max,max
red	\fBCOLOR_RED\ \fR	4	max,0,0
magenta	\fBCOLOR_MAGENTA\fR	5	max,0,max
yellow	\fBCOLOR_YELLOW\fR	6	max,max,0
white	\fBCOLOR_WHITE\fR	7	max,max,max
.TE
.PP
It be blingin ta not confuse tha two setz of color capabilities;
otherwise red/blue is ghon be interchanged on tha display.
.PP
On a HP-like terminal, use \fBscp\fR wit a cold-ass lil color-pair number parameta ta set
which color pair is current.
.PP
On a Tektronix-like terminal, tha capabilitizzle \fBccc\fR may be present to
indicate dat flavas can be modified.
If so, tha \fBinitc\fR capabilitizzle will
take a cold-ass lil color number (0 ta \fBcolors\fR \- 1)and three mo' parametas which
describe tha color.
These three parametas default ta bein interpreted as RGB
(Red, Green, Blue) joints.
If tha boolean capabilitizzle \fBhls\fR is present,
they is instead as HLS (Hue, Lightness, Saturation) indices.
Da ranges are
terminal-dependent.
.PP
On a HP-like terminal, \fBinitp\fR may give a cold-ass lil capabilitizzle fo' changin a
color-pair value.
It will take seven parameters; a cold-ass lil color-pair number (0 to
\fBmax_pairs\fR \- 1), n' two triplez describin first background n' then
foreground colors.
These parametas must be (Red, Green, Blue) or
(Hue, Lightness, Saturation) dependin on \fBhls\fR.
.PP
On some color terminals, flavas collide wit highlights.
Yo ass can register
these collisions wit tha \fBncv\fR capability.
This be a funky-ass bit-mask of
attributes not ta be used when flavas is enabled.
Da correspondence wit the
attributes understood by \fBcurses\fR be as bigs up:
.PP
.TS
center;
l c c
lw25 lw2 lw10.
\fBAttribute	Bit	Decimal\fR
A_STANDOUT	0	1
A_UNDERLINE	1	2
A_REVERSE	2	4
A_BLINK   	3	8
A_DIM      	4	16
A_BOLD    	5	32
A_INVIS   	6	64
A_PROTECT	7	128
A_ALTCHARSET	8	256
.TE
.PP
For example, on nuff IBM PC consoles, tha underline attribute collides wit the
foreground color blue n' aint available up in color mode.
These should have
an \fBncv\fR capabilitizzle of 2.
.PP
SVr4 curses do not a god damn thang wit \fBncv\fR, ncurses recognizes it n' optimizes
the output up in favor of colors.
.PP
.SS Miscellaneous
If tha terminal requires other than a null (zero) characta as a pad, then this
can be given as pad.
Only tha straight-up original gangsta characta of tha pad strang is used.
If tha terminal aint gots a pad character, specify npc.
Note dat ncurses implements tha termcap-compatible \fBPC\fR variable;
though tha application may set dis value ta suttin' other than
a null, ncurses will test \fBnpc\fR first n' use napms if tha terminal
has no pad character.
.PP
If tha terminal can move up or down half a line,
this can be indicated with
.B hu
(half-line up)
and
.B hd
(half-line down).
This is primarily useful fo' superscripts n' subscripts on hard-copy terminals.
If a hard-copy terminal can eject ta tha next page (form feed), give dis as
.B ff
(usually control L).
.PP
If there be a cold-ass lil command ta repeat a given characta a given number of
times (to save time transmittin a big-ass number of identical characters)
this can be indicated wit tha parameterized string
.BR rep .
Da first parameta is tha characta ta be repeated n' tha second
is tha number of times ta repeat dat shit.
Thus, tparm(repeat_char, 'x', 10) is tha same ol' dirty as `xxxxxxxxxx'.
.PP
If tha terminal has a settable command character, like fuckin tha \s-1TEKTRONIX\s+1 4025,
this can be indicated with
.BR cmdch .
A prototype command characta is chosen which is used up in all capabilities.
This characta is given up in the
.B cmdch
capabilitizzle ta identify dat shit.
Da followin convention is supported on some UNIX systems:
Da environment is ta be searched fo' a
.B CC
variable, n' if found, all
occurrencez of tha prototype characta is replaced wit tha character
in tha environment variable.
.PP
Terminal descriptions dat do not represent a specific kind of known
terminal, such as
.IR switch ,
.IR dialup ,
.IR patch ,
and
.IR network ,
should include the
.B gn
(generic) capabilitizzle so dat programs can diss dat they do not know
how ta rap ta tha terminal.
(This capabilitizzle do not apply to
.I virtual
terminal descriptions fo' which tha escape sequences is known.)
.PP
If tha terminal has a \*(``meta key\*('' which acts as a gangbangin' finger-lickin' dirty-ass shift key,
settin tha 8th bit of any characta transmitted, dis fact can
be indicated with
.BR km .
Otherwise, software will assume dat tha 8th bit is paritizzle n' it
will probably be cleared.
If strings exist ta turn dis \*(``meta mode\*('' on n' off, they
can be given as
.B smm
and
.BR rmm .
.PP
If tha terminal has mo' linez of memory than will fit on tha screen
at once, tha number of linez of memory can be indicated with
.BR lm .
A value of
.BR lm #0
indicates dat tha number of lines aint fixed,
but dat there is still mo' memory than fits on tha screen.
.PP
If tha terminal is one of dem supported by tha \s-1UNIX\s+1 virtual
terminal protocol, tha terminal number can be given as
.BR vt .
.PP
Media copy
strings which control a auxiliary printa connected ta tha terminal
can be given as
.BR mc0 :
print tha contentz of tha screen,
.BR mc4 :
turn off tha printer, and
.BR mc5 :
turn on tha printer.
When tha printa is on, all text busted ta tha terminal is ghon be sent
to tha printer.
It be undefined whether tha text be also displayed on tha terminal screen
when tha printa is on.
A variation
.B mc5p
takes one parameter, n' leaves tha printa on fo' as nuff characters
as tha value of tha parameter, then turns tha printa off.
Da parameta should not exceed 255.
All text, including
.BR mc4 ,
is transparently passed ta tha printa while an
.B mc5p
is up in effect.
.PP
.SS Glitches n' Domedamage
.PP
Hazeltine terminals, which do not allow `~' charactas ta be displayed should
indicate \fBhz\fR.
.PP
Terminals which ignore a line-feed immediately afta a \fBam\fR wrap,
like fuckin tha Concept n' vt100,
should indicate \fBxenl\fR.
.PP
If
.B el
is required ta git rid of standout
(instead of merely freestylin aiiight text on top of it),
\fBxhp\fP should be given.
.PP
Teleray terminals, where tabs turn all charactas moved over ta blanks,
should indicate \fBxt\fR (destructizzle tabs).
Note: tha variable indicatin dis is now `dest_tabs_magic_smso'; in
olda versions, dat shiznit was teleray_glitch.
This glitch be also taken ta mean dat it aint possible ta position
the cursor on top of a \*(``magic cookie\*('',
that ta erase standout mode it is instead necessary ta use
delete n' bang line.
Da ncurses implementation ignores dis glitch.
.PP
Da Beehive Superbee, which is unable ta erectly transmit tha escape
or control C characters, has
.BR xsb ,
indicatin dat tha f1 key is used fo' escape n' f2 fo' control C.
(Only certain Superbees have dis problem, dependin on tha ROM.)
Note dat up in olda terminfo versions, dis capabilitizzle was called
`beehive_glitch'; it is now `no_esc_ctl_c'.
.PP
Other specific terminal problems may be erected by addin more
capabilitizzlez of tha form \fBx\fR\fIx\fR.
.PP
.SS Similar Terminals
.PP
If there be two straight-up similar terminals, one (the variant) can be defined as
bein just like tha other (the base) wit certain exceptions.
In the
definizzle of tha variant, tha strang capabilitizzle \fBuse\fR can be given with
the name of tha base terminal.
Da capabilitizzles given before
.B use
override dem up in tha base type named by
.BR use .
If there be multiple \fBuse\fR capabilities, they is merged up in reverse order.
That is, tha rightmost \fBuse\fR reference is processed first, then tha one to
its left, n' so forth.
Capabilitizzles given explicitly up in tha entry override
those brought up in by \fBuse\fR references.
.PP
A capabilitizzle can be canceled by placin \fBxx@\fR ta tha left of the
use reference dat imports it, where \fIxx\fP is tha capability.
For example, tha entry
.RS
.PP
2621\-nl, smkx@, rmkx@, use=2621,
.RE
.PP
defines a 2621\-nl dat aint gots tha \fBsmkx\fR or \fBrmkx\fR capabilities,
and hence do not turn on tha function key labels when up in visual mode.
This is useful fo' different modes fo' a terminal, or fo' different
user preferences.
.PP
.SS Pitfallz of Long Entries
.PP
Long terminfo entries is unlikely ta be a problem; ta date, no entry has even
approached terminfoz 4096-byte string-table maximum.
Unfortunately, tha termcap
translations is much mo' strictly limited (to 1023 bytes), thus termcap translations
of long terminfo entries can cause problems.
.PP
Da playa pages fo' 4.3BSD n' olda versionz of \fBtgetent()\fP instruct tha user to
allocate a 1024-byte buffer fo' tha termcap entry.
Da entry gets null-terminated by
the termcap library, so dat make tha maximum safe length fo' a termcap entry
1k\-1 (1023) bytes.
Dependin on what tha fuck tha application n' tha termcap library
bein used do, n' where up in tha termcap file tha terminal type dat \fBtgetent()\fP
is searchin fo' is, nuff muthafuckin wack thangs can happen.
.PP
Some termcap libraries print a warnin message or exit if they find an
entry thatz longer than 1023 bytes; others do not; others truncate the
entries ta 1023 bytes.
Some application programs allocate mo' than
the recommended 1K fo' tha termcap entry; others do not.
.PP
Each termcap entry has two blingin sizes associated wit it: before
"tc" expansion, n' afta "tc" expansion.
"tc" is tha capabilitizzle that
tacks on another termcap entry ta tha end of tha current one, ta add
on its capabilities.
If a termcap entry do not use tha "tc"
capability, then of course tha two lengths is tha same.
.PP
Da "before tc expansion" length is da most thugged-out blingin one, cuz it
affects mo' than just playaz of dat particular terminal.
This is the
length of tha entry as it exists up in /etc/termcap, minus the
backslash-newline pairs, which \fBtgetent()\fP strips up while readin dat shit.
Some termcap libraries strip off tha final newline, too (GNU termcap do not).
Now suppose:
.bP
a termcap entry before expansion is mo' than 1023 bytes long,
.bP
and tha application has only allocated a 1k buffer,
.bP
and tha termcap library (like tha one up in BSD/OS 1.1 n' GNU) reads
the whole entry tha fuck into tha buffer, no matta what tha fuck its length, ta see
if it is tha entry it wants,
.bP
and \fBtgetent()\fP is searchin fo' a terminal type dat either is the
long entry, appears up in tha termcap file afta tha long entry, or
does not step tha fuck up in tha file at all (so dat \fBtgetent()\fP has ta search
the whole termcap file).
.PP
Then \fBtgetent()\fP will overwrite memory, like its stack, n' probably core dump
the program.
Programs like telnet is particularly vulnerable; modern telnets
pass along joints like tha terminal type automatically.
Da thangs up in dis biatch is almost
as undesirable wit a termcap library, like SunOS 4.1.3 n' Ultrix 4.4, that
prints warnin lyrics when it readz a overly long termcap entry.
If a
termcap library truncates long entries, like OSF/1 3.0, it is immune ta dying
here but will return incorrect data fo' tha terminal.
.PP
Da "afta tc expansion" length gonna git a similar effect ta the
above yo, but only fo' playas whoz ass straight-up set TERM ta dat terminal
type, since \fBtgetent()\fP only do "tc" expansion once it is found the
terminal type dat shiznit was lookin for, not while searching.
.PP
In summary, a termcap entry dat is longer than 1023 bytes can cause,
on various combinationz of termcap libraries n' applications, a cold-ass lil core
dump, warnings, or incorrect operation.
If it is too long even before
"tc" expansion, it gonna git dis effect even fo' playaz of some other
terminal types n' playas whose TERM variable aint gots a termcap
entry.
.PP
When up in \-C (translate ta termcap) mode, tha \fBncurses\fR implementation of
\fBtic\fR(1M) thangs warnin lyrics when tha pre-tc length of a termcap
translation is too long.
Da \-c (check) option also checks resolved (afta tc
expansion) lengths.
.SS Binary Compatibility
It aint wise ta count on portabilitizzle of binary terminfo entries between
commercial UNIX versions.
Da problem is dat there be at least two versions
of terminfo (under HP\-UX n' AIX) which diverged from System V terminfo after
SVr1, n' have added extension capabilitizzles ta tha strang table dat (in the
binary format) collide wit System V n' XSI Curses extensions.
.SH EXTENSIONS
.PP
Searchin fo' terminal descriptions in
\fB$HOME/.terminfo\fR n' TERMINFO_DIRS 
is not supported by olda implementations.
.PP
Some SVr4 \fBcurses\fR implementations, n' all previous ta SVr4, do not
interpret tha %A n' %O operators up in parameta strings.
.PP
SVr4/XPG4 do not specify whether \fBmsgr\fR licenses movement while in
an alternate-character-set mode (such modes may, among other thangs, map
CR n' NL ta charactas dat do not trigger local motions).
Da \fBncurses\fR implementation ignores \fBmsgr\fR up in \fBALTCHARSET\fR
mode.
This raises tha possibilitizzle dat a XPG4
implementation makin tha opposite interpretation may need terminfo
entries made fo' \fBncurses\fR ta have \fBmsgr\fR turned off.
.PP
Da \fBncurses\fR library handlez insert-characta n' insert-characta modes
in a slightly non-standard way ta git betta update efficiency.
See
the \fBInsert/Delete Character\fR subsection above.
.PP
Da parameta substitutions fo' \fBset_clock\fR n' \fBdisplay_clock\fR are
not documented up in SVr4 or tha XSI Curses standard.
They is deduced from the
documentation fo' tha AT&T 505 terminal.
.PP
Be careful assignin tha \fBkmous\fR capability.
Da \fBncurses\fR wants to
interpret it as \fBKEY_MOUSE\fR, fo' use by terminals n' emulators like xterm
that can return mouse-trackin shiznit up in tha keyboard-input stream.
.PP
Different commercial portz of terminfo n' curses support different subsets of
the XSI Curses standard n' (in some cases) different extension sets.
Here
is a summary, accurate az of October 1995:
.PP
\fBSVR4, Solaris, ncurses\fR \-\-
These support all SVr4 capabilities.
.PP
\fBSGI\fR \-\-
Supports tha SVr4 set, addz one undocumented extended string
capabilitizzle (\fBset_pglen\fR).
.PP
\fBSVr1, Ultrix\fR \-\-
These support a restricted subset of terminfo capabilities.
Da booleans end wit \fBxon_xoff\fR;
the numerics wit \fBwidth_status_line\fR;
and tha strings wit \fBprtr_non\fR.
.PP
\fBHP/UX\fR \-\-
Supports tha SVr1 subset, plus tha SVr[234] numerics \fBnum_labels\fR,
\fBlabel_height\fR, \fBlabel_width\fR, plus function keys 11 all up in 63, plus
\fBplab_norm\fR, \fBlabel_on\fR, n' \fBlabel_off\fR, plus some incompatible
extensions up in tha strang table.
.PP
\fBAIX\fR \-\-
Supports tha SVr1 subset, plus function keys 11 all up in 63, plus a number
of incompatible strang table extensions.
.PP
\fBOSF\fR \-\-
Supports both tha SVr4 set n' tha AIX extensions.
.SH FILES
.TP 25
\*d/?/*
filez containin terminal descriptions
.SH SEE ALSO
\fBtic\fR(1M),
\fBinfocmp\fR(1M),
\fBcurses\fR(3X),
\fBprintf\fR(3),
\fBterm\fR(\*n).
\fBterm_variables\fR(3X).
.SH AUTHORS
Zeyd M. Ben-Halim, Eric S. Raymond, Thomas E. Dickey.
Based on pcurses by Pavel Curtis.
