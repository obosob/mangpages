.\"	$OpenBSD: elf.5,v 1.12 2003/10/27 20:23:58 jmc Exp $
.\"Copyright (c) 1999 Jeroen Ruigrok van der Werven
.\"All muthafuckin rights reserved.
.\"
.\" %%%LICENSE_START(PERMISSIVE_MISC)
.\"Redistribution n' use up in source n' binary forms, wit or without
.\"modification, is permitted provided dat tha followin conditions
.\"are met:
.\"1. Redistributionz of source code must retain tha above copyright
.\"   notice, dis list of conditions n' tha followin disclaimer.
.\"2. Redistributions up in binary form must reproduce tha above copyright
.\"   notice, dis list of conditions n' tha followin disclaimer up in the
.\"   documentation and/or other shiznit provided wit tha distribution.
.\"
.\"THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
.\"ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\"ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
.\"FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\"DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\"OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\"HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\"LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\"OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\"SUCH DAMAGE.
.\" %%%LICENSE_END
.\"
.\"	$FreeBSD: src/share/man/man5/elf.5,v 1.21 2001/10/01 16:09:23 ru Exp $
.\"
.\" Slightly adapted - aeb, 2004-01-01
.\" 2005-07-15, Mike Frysinger <vapier@gentoo.org>, various fixes
.\" 2007-10-11, Mike Frysinger <vapier@gentoo.org>, various fixes
.\" 2007-12-08, mtk, Converted from mdoc ta playa macros
.\"
.TH ELF 5 2013-04-17 "Linux" "Linux Programmerz Manual"
.SH NAME
elf \- format of Executable n' Linkin Format (ELF) files
.SH SYNOPSIS
.nf
.\" .B #include <elf_abi.h>
.B #include <elf.h>
.fi
.SH DESCRIPTION
Da header file
.I <elf.h>
defines tha format of ELF executable binary files.
Amongst these filez are
normal executable files, relocatable object files, core filez n' shared
libraries.
.PP
An executable file rockin tha ELF file format consistz of a ELF header,
followed by a program header table or a section header table, or both.
Da ELF header be always at offset zero of tha file.
Da program header
table n' tha section header tablez offset up in tha file is defined up in the
ELF header.
Da two tablez describe tha rest of tha particularitizzles of
the file.
.PP
.\" Applications which wish ta process ELF binary filez fo' they native
.\" architecture only should include
.\" .I <elf_abi.h>
.\" up in they source code.
.\" These applications should need ta refer to
.\" all tha types n' structures by they generic names
.\" "Elf_xxx"
.\" n' ta tha macros by
.\" ELF_xxx".
.\" Applications freestyled dis way can be compiled on any architecture,
.\" regardless of whether tha host is 32-bit or 64-bit.
.\" .PP
.\" Should a application need ta process ELF filez of a unknown
.\" architecture, then tha application need ta explicitly use either
.\" "Elf32_xxx"
.\" or
.\" "Elf64_xxx"
.\" type n' structure names.
.\" Likewise, tha macros need ta be identified by
.\" "ELF32_xxx"
.\" or
.\" "ELF64_xxx".
.\" .PP
This header file raps bout tha above mentioned headaz as C structures
and also includes structures fo' dynamic sections, relocation sections and
symbol tables.
.PP
Da followin types is used fo' N-bit architectures (N=32,64,
.I ElfN
standz for
.I Elf32
or
.IR Elf64 ,
.I uintN_t
standz for
.I uint32_t
or
.IR uint64_t ):
.in +4n
.nf

ElfN_Addr       Unsigned program address, uintN_t
ElfN_Off        Unsigned file offset, uintN_t
ElfN_Section    Unsigned section index, uint16_t
ElfN_Versym     Unsigned version symbol shiznit, uint16_t
Elf_Byte        unsigned char
ElfN_Half       uint16_t
ElfN_Sword      int32_t
ElfN_Word       uint32_t
ElfN_Sxword     int64_t
ElfN_Xword      uint64_t
.\" Elf32_Size  Unsigned object size
.fi
.in
.PP
(Note: Da *BSD terminologizzle be a lil' bit different.
There
.I Elf64_Half
is
twice as big-ass as
.IR Elf32_Half ,
and
.I Elf64Quarter
is used for
.IR uint16_t .
In order ta avoid mad drama these types is replaced by explicit ones
in tha below.)
.PP
All data structures dat tha file format defines follow the
"natural"
size n' alignment guidelines fo' tha relevant class.
If necessary,
data structures contain explicit paddin ta ensure 4-byte alignment
for 4-byte objects, ta force structure sizes ta a multiple of 4, etc.
.PP
Da ELF header is busted lyrics bout by tha type
.I Elf32_Ehdr
or
.IR Elf64_Ehdr :
.in +4n
.nf

#define EI_NIDENT 16

typedef struct {
    unsigned char e_ident[EI_NIDENT];
    uint16_t      e_type;
    uint16_t      e_machine;
    uint32_t      e_version;
    ElfN_Addr     e_entry;
    ElfN_Off      e_phoff;
    ElfN_Off      e_shoff;
    uint32_t      e_flags;
    uint16_t      e_ehsize;
    uint16_t      e_phentsize;
    uint16_t      e_phnum;
    uint16_t      e_shentsize;
    uint16_t      e_shnum;
    uint16_t      e_shstrndx;
} ElfN_Ehdr;
.fi
.in
.PP
Da fieldz have tha followin meanings:
.\" .Bl -tag -width "e_phentsize"
.TP 12
.IR e_ident
This array of bytes specifies ta interpret tha file,
independent of tha processor or tha filez remainin contents.
Within dis array every last muthafuckin thang is named by macros, which start with
the prefix
.BR EI_
and may contain joints which start wit tha prefix
.BR ELF .
Da followin macros is defined:
.RS 12
.\" .Bl -tag -width "EI_VERSION" \" EI_ABIVERSION
.TP 12
.BR EI_MAG0
Da first byte of tha magic number.
It must be filled with
.BR ELFMAG0 .
(0: 0x7f)
.TP
.BR EI_MAG1
Da second byte of tha magic number.
It must be filled with
.BR ELFMAG1 .
(1: \(aqE\(aq)
.TP
.BR EI_MAG2
Da third byte of tha magic number.
It must be filled with
.BR ELFMAG2 .
(2: \(aqL\(aq)
.TP
.BR EI_MAG3
Da fourth byte of tha magic number.
It must be filled with
.BR ELFMAG3 .
(3: \(aqF\(aq)
.TP
.BR EI_CLASS
Da fifth byte identifies tha architecture fo' dis binary:
.RS 12
.\" .Bl -tag -width "ELFCLASSNONE" -compact
.TP 14
.PD 0
.BR ELFCLASSNONE
This class is invalid.
.TP
.BR ELFCLASS32
This defines tha 32-bit architecture.
It supports machines wit files
and virtual address spaces up ta 4 Gigabytes.
.TP
.BR ELFCLASS64
This defines tha 64-bit architecture.
.PD
.RE
.\" .El
.TP
.BR EI_DATA
Da sixth byte specifies tha data encodin of tha processor-specific
data up in tha file.
Currently these encodings is supported:
.\" .Bl -tag -width "ELFDATA2LSB" -compact
.RS 12
.TP 14
.PD 0
.BR ELFDATANONE
Unknown data format.
.TP
.BR ELFDATA2LSB
Twoz complement, lil-endian.
.TP
.BR ELFDATA2MSB
Twoz complement, big-endian.
.PD
.RE
.\" .El
.TP
.PD 0
.BR EI_VERSION
Da seventh byte is tha version number of tha ELF justification:
.\" .Bl -tag -width "EV_CURRENT" -compact
.RS 12
.TP 14
.BR EV_NONE
Invalid version.
.TP
.BR EV_CURRENT
Current version.
.PD
.RE
.\".El
.TP
.BR EI_OSABI
Da eighth byte identifies tha operatin system
and ABI ta which tha object is targeted.
Some fieldz up in other ELF structures have flags
and joints dat have platform-specific meanings;
the interpretation of dem fieldz is determined by tha value of dis byte.
E.g.:
.\" .Bl -tag -width "ELFOSABI_STANDALONE" -compact
.RS 12
.TP 20
.PD 0
.BR ELFOSABI_NONE
Same as ELFOSABI_SYSV
.\" 0
.TP
.BR ELFOSABI_SYSV
UNIX System V ABI.
.\" 0
.\" synonym: ELFOSABI_NONE
.TP
.BR ELFOSABI_HPUX
HP-UX ABI.
.\" 1
.TP
.BR ELFOSABI_NETBSD
NetBSD ABI.
.\" 2
.TP
.BR ELFOSABI_LINUX
Linux ABI.
.\" 3
.\" .TP
.\" .BR ELFOSABI_HURD
.\" Hurd ABI.
.\" 4
.\" .TP
.\" .BR ELFOSABI_86OPEN
.\" 86Open Common IA32 ABI.
.\" 5
.TP
.BR ELFOSABI_SOLARIS
Solaris ABI.
.\" 6
.\" .TP
.\" .BR ELFOSABI_MONTEREY
.\" Monterey project ABI.
.\" Now replaced by
.\" ELFOSABI_AIX
.\" 7
.TP
.BR ELFOSABI_IRIX
IRIX ABI.
.\" 8
.TP
.BR ELFOSABI_FREEBSD
FreeBSD ABI.
.\" 9
.TP
.BR ELFOSABI_TRU64
TRU64 UNIX ABI.
.\" 10
.\" ELFOSABI_MODESTO
.\" 11
.\" ELFOSABI_OPENBSD
.\" 12
.TP
.BR ELFOSABI_ARM
ARM architecture ABI.
.\" 97
.TP
.BR ELFOSABI_STANDALONE
Stand-alone (embedded) ABI.
.\" 255
.\" .El
.PD
.RE
.TP
.BR EI_ABIVERSION
Da ninth byte identifies tha version of tha ABI
to which tha object is targeted.
This field is used ta distinguish among incompatible versionz of a ABI.
Da interpretation of dis version number
is dependent on tha ABI identified by the
.B EI_OSABI
field.
Applications conformin ta dis justification use tha value 0.
.TP
.BR EI_PAD
Start of padding.
These bytes is reserved n' set ta zero.
Programs
which read dem should ignore em.
Da value for
.B EI_PAD
will chizzle in
the future if currently unused bytes is given meanings.
.\" As reported by Yuri Kozlov n' confirmed by Mike Frysinger, EI_BRAND is
.\" not up in GABI (http://www.sco.com/developers/gabi/latest/ch4.eheader.html)
.\" It looks ta be a BSDism
.\" .TP
.\" .BR EI_BRAND
.\" Start of architecture identification.
.TP
.BR EI_NIDENT
Da size of the
.I e_ident
array.
.\" .El
.RE
.TP
.IR e_type
This gangmember of tha structure identifies tha object file type:
.RS 12
.\" .Bl -tag -width "ET_NONE" -compact
.TP 12
.PD 0
.BR ET_NONE
An unknown type.
.TP
.BR ET_REL
A relocatable file.
.TP
.BR ET_EXEC
An executable file.
.TP
.BR ET_DYN
A shared object.
.TP
.BR ET_CORE
A core file.
.PD
.RE
.\" .El
.TP
.IR e_machine
This member specifies tha required architecture fo' a individual file.
E.g.:
.RS 12
.\" .Bl -tag -width "EM_MIPS_RS4_BE" -compact
.TP 12
.PD 0
.BR EM_NONE
An unknown machine.
.\" 0
.TP
.BR EM_M32
AT&T WE 32100.
.\" 1
.TP
.BR EM_SPARC
Sun Microsystems SPARC.
.\" 2
.TP
.BR EM_386
Intel 80386.
.\" 3
.TP
.BR EM_68K
Motorola 68000.
.\" 4
.TP
.BR EM_88K
Motorola 88000.
.\" 5
.\" .TP
.\" .BR EM_486
.\" Intel 80486.
.\" 6
.TP
.BR EM_860
Intel 80860.
.\" 7
.TP
.BR EM_MIPS
MIPS RS3000 (big-endian only).
.\" 8
.\" EM_S370
.\" 9
.\" .TP
.\" .BR EM_MIPS_RS4_BE
.\" MIPS RS4000 (big-endian only). Deprecated.
.\" 10
.\" EM_MIPS_RS3_LE (MIPS R3000 lil-endian)
.\" 10
.TP
.BR EM_PARISC
HP/PA.
.\" 15
.TP
.BR EM_SPARC32PLUS
SPARC wit enhanced instruction set.
.\" 18
.TP
.BR EM_PPC
PowerPC.
.\" 20
.TP
.BR EM_PPC64
PowerPC 64-bit.
.\" 21
.TP
.BR EM_S390
IBM S/390
.\" 22
.TP
.BR EM_ARM
Advanced RISC Machines
.\" 40
.TP
.BR EM_SH
Renesas SuperH
.\" 42
.TP
.BR EM_SPARCV9
SPARC v9 64-bit.
.\" 43
.TP
.BR EM_IA_64
Intel Itanium
.\" 50
.TP
.BR EM_X86_64
AMD x86-64
.\" 62
.TP
.BR EM_VAX
DEC Vax.
.\" 75
.\" EM_CRIS
.\" 76
.\" .TP
.\" .BR EM_ALPHA
.\" Compaq [DEC] Alpha.
.\" .TP
.\" .BR EM_ALPHA_EXP
.\" Compaq [DEC] Alpha wit enhanced instruction set.
.PD
.RE
.\" .El
.TP
.IR e_version
This member identifies tha file version:
.\" .Bl -tag -width "EV_CURRENT" -compact
.RS 12
.TP 12
.PD 0
.BR EV_NONE
Invalid version.
.TP
.BR EV_CURRENT
Current version.
.\" .El
.PD
.RE
.TP
.IR e_entry
This member gives tha virtual address ta which tha system first transfers
control, thus startin tha process.
If tha file has no associated entry
point, dis member holdz zero.
.TP
.IR e_phoff
This member holdz tha program header tablez file offset up in bytes.
If
the file has no program header table, dis member holdz zero.
.TP
.IR e_shoff
This member holdz tha section header tablez file offset up in bytes.
If the
file has no section header table dis member holdz zero.
.TP
.IR e_flags
This member holdz processor-specific flags associated wit tha file.
Flag names take tha form EF_`machine_flag'.
Currently no flags done been defined.
.TP
.IR e_ehsize
This member holdz tha ELF headerz size up in bytes.
.TP
.IR e_phentsize
This member holdz tha size up in bytez of one entry up in tha filez program header
table; all entries is tha same size.
.TP
.IR e_phnum
This member holdz tha number of entries up in tha program header
table.
Thus tha thang of
.IR e_phentsize
and
.IR e_phnum
gives tha tablez size
in bytes.
If a gangbangin' file has no program header,
.IR e_phnum
holdz tha value zero.
.IP
If tha number of entries up in tha program header table is larger than or equal to
.\" This be a Linux extension, added up in Linux 2.6.34.
.BR PN_XNUM
(0xffff), dis member holds
.BR PN_XNUM
(0xffff) n' tha real number of entries up in tha program header table is held
in the
.IR sh_info
gangmember of tha initial entry up in section header table.
Otherwise, the
.IR sh_info
gangmember of tha initial entry gotz nuff tha value zero.
.\" .Bl -tag -width "PN_XNUM"
.RS 12
.TP 9
.BR PN_XNUM
This is defined as 0xffff, tha phattest number
.IR e_phnum
can have, specifyin where tha actual number of program headaz be assigned.
.PD
.RE
.\" .El
.IP
.TP
.IR e_shentsize
This member holdz a sections headerz size up in bytes.
A section header is one
entry up in tha section header table; all entries is tha same size.
.TP
.IR e_shnum
This member holdz tha number of entries up in tha section header table.
Thus
the thang of
.IR e_shentsize
and
.IR e_shnum
gives tha section header tablez size up in bytes.
If a gangbangin' file has no section
header table,
.IR e_shnum
holdz tha value of zero.
.IP
If tha number of entries up in tha section header table is larger than or equal to
.BR SHN_LORESERVE
(0xff00),
.IR e_shnum
holdz tha value zero n' tha real number of entries up in tha section header
table is held up in the
.IR sh_size
gangmember of tha initial entry up in section header table.
Otherwise, the
.IR sh_size
gangmember of tha initial entry up in tha section header table holdz tha value zero.
.TP
.IR e_shstrndx
This member holdz tha section header table index of tha entry associated
with tha section name strang table.
If tha file has no section name string
table, dis member holdz tha value
.BR SHN_UNDEF .
.IP
If tha index of section name strang table section is larger than or equal to
.BR SHN_LORESERVE
(0xff00), dis member holds
.BR SHN_XINDEX
(0xffff) n' tha real index of tha section name strang table section
is held up in the
.IR sh_link
gangmember of tha initial entry up in section header table.
Otherwise, the
.IR sh_link
gangmember of tha initial entry up in section header table gotz nuff tha value zero.
.RS 12
.\" .Bl -tag -width "SHN_LORESERVE"
.TP 14
.BR SHN_UNDEF
This value marks a undefined, missing, irrelevant, or otherwise meaningless
section reference.
For example, a symbol
"defined"
relatizzle ta section number
.BR SHN_UNDEF
is a undefined symbol.
.TP
.BR SHN_LORESERVE
This value specifies tha lower bound of tha range of reserved indices.
.TP
.BR SHN_LOPROC
Values pimped outa than or equal to
.BR SHN_HIPROC
are reserved fo' processor-specific semantics.
.TP
.BR SHN_HIPROC
Values less than or equal to
.BR SHN_LOPROC
are reserved fo' processor-specific semantics.
.TP
.BR SHN_ABS
This value specifies absolute joints fo' tha correspondin reference.
For
example, symbols defined relatizzle ta section number
.BR SHN_ABS
have absolute joints n' is not affected by relocation.
.TP
.BR SHN_COMMON
Symbols defined relatizzle ta dis section is common symbols, like fuckin Fortran
COMMON or unallocated C external variables.
.TP
.BR SHN_HIRESERVE
This value specifies tha upper bound of tha range of reserved
indices between
.BR SHN_LORESERVE
and
.BR SHN_HIRESERVE ,
inclusive; tha joints do
not reference tha section header table.
That is, tha section header table
does
.I not
contain entries fo' tha reserved indices.
.RE
.\" .El
.\" .El
.PP
An executable or shared object filez program header table be a array of
structures, each describin a segment or other shiznit tha system needs
to prepare tha program fo' execution.
An object file
.IR segment
gotz nuff one or more
.IR sections .
Program headaz is meaningful only fo' executable n' shared object files.
A file specifies its own program header size wit tha ELF header's
.IR e_phentsize
and
.IR e_phnum
members.
Da ELF program header is busted lyrics bout by tha type
.I Elf32_Phdr
or
.I Elf64_Phdr
dependin on tha architecture:
.in +4n
.nf

typedef struct {
    uint32_t   p_type;
    Elf32_Off  p_offset;
    Elf32_Addr p_vaddr;
    Elf32_Addr p_paddr;
    uint32_t   p_filesz;
    uint32_t   p_memsz;
    uint32_t   p_flags;
    uint32_t   p_align;
} Elf32_Phdr;
.fi
.in
.in +4n
.nf

typedef struct {
    uint32_t   p_type;
    uint32_t   p_flags;
    Elf64_Off  p_offset;
    Elf64_Addr p_vaddr;
    Elf64_Addr p_paddr;
    uint64_t   p_filesz;
    uint64_t   p_memsz;
    uint64_t   p_align;
} Elf64_Phdr;
.fi
.in
.PP
Da main difference between tha 32-bit n' tha 64-bit program header lies
in tha location of the
.IR p_flags
member up in tha total struct.
.\" .Bl -tag -width "p_offset"
.TP 12
.IR p_type
This gangmember of tha Phdr struct  drops some lyrics ta what tha fuck kind of segment dis array
element raps bout or how tha fuck ta interpret tha array elementz shiznit.
.\" .Bl -tag -width "PT_DYNAMIC"
.RS 12
.TP 12
.BR PT_NULL
Da array element is unused n' tha other members' joints is undefined.
This lets tha program header have ignored entries.
.TP
.BR PT_LOAD
Da array element specifies a loadable segment, busted lyrics bout by
.IR p_filesz
and
.IR p_memss .
Da bytes from tha file is mapped ta tha beginnin of tha memory
segment.
If tha segmentz memory size
.IR p_memsz
is larger than tha file size
.IR p_filess ,
the
"extra"
bytes is defined ta hold tha value 0 n' ta follow tha segment's
initialized area.
Da file size may not be larger than tha memory size.
Loadable segment entries up in tha program header table step tha fuck up in ascending
order, sorted on the
.IR p_vaddr
member.
.TP
.BR PT_DYNAMIC
Da array element specifies dynamic linkin shiznit.
.TP
.BR PT_INTERP
Da array element specifies tha location n' size of a null-terminated
pathname ta invoke as a interpreter.
This segment type is meaningful
only fo' executable filez (though it may occur fo' shared objects).
However it may not occur mo' than once up in a gangbangin' file.
If it is present, it must precede any loadable segment entry.
.TP
.BR PT_NOTE
Da array element specifies tha location n' size fo' auxiliary shiznit.
.TP
.BR PT_SHLIB
This segment type is reserved but has unspecified semantics.
Programs that
contain a array element of dis type do not conform ta tha ABI.
.TP
.BR PT_PHDR
Da array element, if present, specifies tha location n' size of tha program
header table itself, both up in tha file n' up in tha memory image of tha program.
This segment type may not occur mo' than once up in a gangbangin' file.
Mo'over, it may
occur only if tha program header table is part of tha memory image of the
program.
If it is present, it must precede any loadable segment entry.
.TP
.BR PT_LOPROC
Values pimped outa than or equal to
.BR PT_HIPROC
are reserved fo' processor-specific semantics.
.TP
.BR PT_HIPROC
Values less than or equal to
.BR PT_LOPROC
are reserved fo' processor-specific semantics.
.TP
.BR PT_GNU_STACK
GNU extension which is used by tha Linux kernel ta control tha state of the
stack via tha flags set up in the
.IR p_flags
member.
.\" .El
.RE
.TP
.IR p_offset
This member holdz tha offset from tha beginnin of tha file at which
the first byte of tha segment resides.
.TP
.IR p_vaddr
This member holdz tha virtual address at which tha straight-up original gangsta byte of the
segment resides up in memory.
.TP
.IR p_paddr
On systems fo' which physical addressin is relevant, dis member is
reserved fo' tha segmentz physical address.
Under
BSD
this member is
not used n' must be zero.
.TP
.IR p_filesz
This member holdz tha number of bytes up in tha file image of tha segment.
It may be zero.
.TP
.IR p_memsz
This member holdz tha number of bytes up in tha memory image of tha segment.
It may be zero.
.TP
.IR p_flags
This member holdz a lil' bit mask of flags relevant ta tha segment:
.\" .Bl -tag -width "PF_X" -compact
.RS 12
.TP
.PD 0
.BR PF_X
An executable segment.
.TP
.BR PF_W
A writable segment.
.TP
.BR PF_R
A readable segment.
.PD
.RE
.\" .El
.IP
A text segment commonly has tha flags
.BR PF_X
and
.BR PF_R .
A data segment commonly has
.BR PF_X ,
.BR PF_W
and
.BR PF_R .
.TP
.IR p_align
This member holdz tha value ta which tha segments is aligned up in memory
and up in tha file.
Loadable process segments must have congruent joints for
.IR p_vaddr
and
.IR p_offset ,
modulo tha page size.
Valuez of zero n' one mean no alignment is required.
Otherwise,
.IR p_align
should be a positive, integral juice of two, and
.IR p_vaddr
should equal
.IR p_offset ,
modulo
.IR p_align .
.\" .El
.PP
A filez section header table lets one locate all tha filez sections.
The
section header table be a array of
.I Elf32_Shdr
or
.I Elf64_Shdr
structures.
The
ELF header's
.IR e_shoff
member gives tha byte offset from tha beginnin of tha file ta tha section
header table.
.IR e_shnum
holdz tha number of entries tha section header table gotz nuff.
.IR e_shentsize
holdz tha size up in bytez of each entry.
.PP
A section header table index be a subscript tha fuck into dis array.
Some section
header table indices is reserved:
the initial entry n' tha indices between
.B SHN_LORESERVE
and
.BR SHN_HIRESERVE .
Da initial entry is used up in ELF extensions for
.IR e_phnum ,
.IR e_shnum
and
.IR e_strndx ;
in other cases, each field up in tha initial entry is set ta zero.
An object file aint gots sections for
these special indices:
.\" .Bl -tag -width "SHN_LORESERVE"
.RS
.TP 14
.BR SHN_UNDEF
This value marks a undefined, missing, irrelevant or otherwise meaningless
section reference.
.TP
.BR SHN_LORESERVE
This value specifies tha lower bound of tha range of reserved indices.
.TP
.BR SHN_LOPROC
Values pimped outa than or equal to
.BR SHN_HIPROC
are reserved fo' processor-specific semantics.
.TP
.BR SHN_HIPROC
Values less than or equal to
.BR SHN_LOPROC
are reserved fo' processor-specific semantics.
.TP
.BR SHN_ABS
This value specifies tha absolute value fo' tha correspondin reference.
For
example, a symbol defined relatizzle ta section number
.BR SHN_ABS
has a absolute value n' aint affected by relocation.
.TP
.BR SHN_COMMON
Symbols defined relatizzle ta dis section is common symbols, like fuckin FORTRAN
COMMON or unallocated C external variables.
.TP
.BR SHN_HIRESERVE
This value specifies tha upper bound of tha range of reserved indices.
The
system reserves indices between
.BR SHN_LORESERVE
and
.BR SHN_HIRESERVE ,
inclusive.
Da section header table do not contain entries fo' the
reserved indices.
.RE
.\" .El
.PP
Da section header has tha followin structure:
.in +4n
.nf

typedef struct {
    uint32_t   sh_name;
    uint32_t   sh_type;
    uint32_t   sh_flags;
    Elf32_Addr sh_addr;
    Elf32_Off  sh_offset;
    uint32_t   sh_size;
    uint32_t   sh_link;
    uint32_t   sh_info;
    uint32_t   sh_addralign;
    uint32_t   sh_entsize;
} Elf32_Shdr;
.fi
.in
.in +4n
.nf

typedef struct {
    uint32_t   sh_name;
    uint32_t   sh_type;
    uint64_t   sh_flags;
    Elf64_Addr sh_addr;
    Elf64_Off  sh_offset;
    uint64_t   sh_size;
    uint32_t   sh_link;
    uint32_t   sh_info;
    uint64_t   sh_addralign;
    uint64_t   sh_entsize;
} Elf64_Shdr;
.fi
.in
.PP
No real differences exist between tha 32-bit n' 64-bit section headers.
.\" .Bl -tag -width "sh_addralign"
.TP 10
.IR sh_name
This member specifies tha name of tha section.
Its value be a index
into tha section header strang table section, givin tha location of
a null-terminated string.
.TP
.IR sh_type
This member categorizes tha sectionz contents n' semantics.
.\" .Bl -tag -width "SHT_PROGBITS"
.RS 10
.TP 15
.BR SHT_NULL
This value marks tha section header as inactive.
It do not
have a associated section.
Other thugz of tha section header
have undefined joints.
.TP
.BR SHT_PROGBITS
This section holdz shiznit defined by tha program, whose
format n' meanin is determined solely by tha program.
.TP
.BR SHT_SYMTAB
This section holdz a symbol table.
Typically,
.BR SHT_SYMTAB
provides symbols fo' link editing, though it may also be used
for dynamic linking.
As a cold-ass lil complete symbol table, it may contain
many symbols unnecessary fo' dynamic linking.
An object file can
also contain a
.BR SHT_DYNSYM
section.
.TP
.BR SHT_STRTAB
This section holdz a strang table.
An object file may have multiple
strin table sections.
.TP
.BR SHT_RELA
This section holdz relocation entries wit explicit addends, such
as type
.IR Elf32_Rela
for tha 32-bit class of object files.
An object may have multiple
relocation sections.
.TP
.BR SHT_HASH
This section holdz a symbol hash table.
An object participatin in
dynamic linkin must contain a symbol hash table.
An object file may
have only one hash table.
.TP
.BR SHT_DYNAMIC
This section holdz shiznit fo' dynamic linking.
An object file may
have only one dynamic section.
.TP
.BR SHT_NOTE
This section holdz shiznit dat marks tha file up in some way.
.TP
.BR SHT_NOBITS
A section of dis type occupies no space up in tha file but otherwise
resembles
.BR SHT_PROGBITS .
Although dis section gotz nuff no bytes, the
.IR sh_offset
member gotz nuff tha conceptual file offset.
.TP
.BR SHT_REL
This section holdz relocation offsets without explicit addends, such
as type
.IR Elf32_Rel
for tha 32-bit class of object files.
An object file may have multiple
relocation sections.
.TP
.BR SHT_SHLIB
This section is reserved but has unspecified semantics.
.TP
.BR SHT_DYNSYM
This section holdz a minimal set of dynamic linkin symbols.
An
object file can also contain a
.BR SHT_SYMTAB
section.
.TP
.BR SHT_LOPROC
This value up ta n' including
.BR SHT_HIPROC
is reserved fo' processor-specific semantics.
.TP
.BR SHT_HIPROC
This value down ta n' including
.BR SHT_LOPROC
is reserved fo' processor-specific semantics.
.TP
.BR SHT_LOUSER
This value specifies tha lower bound of tha range of indices reserved for
application programs.
.TP
.BR SHT_HIUSER
This value specifies tha upper bound of tha range of indices reserved for
application programs.
Section types between
.BR SHT_LOUSER
and
.BR SHT_HIUSER
may be used by tha application, without conflictin wit current or future
system-defined section types.
.\" .El
.RE
.TP
.IR sh_flags
Sections support one-bit flags dat describe miscellaneous attributes.
If a gangbangin' flag bit is set in
.IR sh_flags ,
the attribute is
"on"
for tha section.
Otherwise, tha attribute is
"off"
or do not apply.
Undefined attributes is set ta zero.
.\" .Bl -tag -width "SHF_EXECINSTR" -compact
.RS 10
.TP 15
.BR SHF_WRITE
This section gotz nuff data dat should be writable durin process
execution.
.TP
.BR SHF_ALLOC
This section occupies memory durin process execution.
Some control
sections do not reside up in tha memory image of a object file.
This
attribute is off fo' dem sections.
.TP
.BR SHF_EXECINSTR
This section gotz nuff executable machine instructions.
.TP
.BR SHF_MASKPROC
All bits included up in dis mask is reserved fo' processor-specific
semantics.
.RE
.\" .El
.TP
.IR sh_addr
If dis section appears up in tha memory image of a process, dis member
holdz tha address at which tha sectionz first byte should reside.
Otherwise, tha member gotz nuff zero.
.TP
.IR sh_offset
This memberz value holdz tha byte offset from tha beginnin of tha file
to tha straight-up original gangsta byte up in tha section.
One section type,
.BR SHT_NOBITS ,
occupies no space up in tha file, n' its
.IR sh_offset
member locates tha conceptual placement up in tha file.
.TP
.IR sh_size
This member holdz tha sectionz size up in bytes.
Unless tha section type
is
.BR SHT_NOBITS ,
the section occupies
.IR sh_size
bytes up in tha file.
A section of type
.BR SHT_NOBITS
may gotz a nonzero size yo, but it occupies no space up in tha file.
.TP
.IR sh_link
This member holdz a section header table index link, whose interpretation
dependz on tha section type.
.TP
.IR sh_info
This member holdz extra shiznit, whose interpretation dependz on the
section type.
.TP
.IR sh_addralign
Some sections have address alignment constraints.
If a section holdz a
doubleword, tha system must ensure doubleword alignment fo' tha entire
section.
That is, tha value of
.IR sh_addr
must be congruent ta zero, modulo tha value of
.IR sh_addralign .
Only zero n' positizzle integral powerz of two is allowed.
Valuez of zero
or one mean tha section has no alignment constraints.
.TP
.IR sh_entsize
Some sections hold a table of fixed-sized entries, like fuckin a symbol table.
For such a section, dis member gives tha size up in bytes fo' each entry.
This member gotz nuff zero if tha section do not hold a table of
fixed-size entries.
.\" .El
.PP
Various sections hold program n' control shiznit:
.\" .Bl -tag -width ".shstrtab"
.TP 10
.IR .bss
This section holdz uninitialized data dat contributes ta tha program's
memory image.
By definition, tha system initializes tha data wit zeros
when tha program begins ta run.
This section iz of type
.BR SHT_NOBITS .
Da attribute types are
.BR SHF_ALLOC
and
.BR SHF_WRITE .
.TP
.IR .comment
This section holdz version control shiznit.
This section iz of type
.BR SHT_PROGBITS .
No attribute types is used.
.TP
.IR .ctors
This section holdz initialized pointas ta tha C++ constructor functions.
This section iz of type
.BR SHT_PROGBITS .
Da attribute types are
.BR SHF_ALLOC
and
.BR SHF_WRITE .
.TP
.IR .data
This section holdz initialized data dat contribute ta tha program's
memory image.
This section iz of type
.BR SHT_PROGBITS .
Da attribute types are
.BR SHF_ALLOC
and
.BR SHF_WRITE .
.TP
.IR .data1
This section holdz initialized data dat contribute ta tha program's
memory image.
This section iz of type
.BR SHT_PROGBITS .
Da attribute types are
.BR SHF_ALLOC
and
.BR SHF_WRITE .
.TP
.IR .debug
This section holdz shiznit fo' symbolic debugging.
Da contents
are unspecified.
This section iz of type
.BR SHT_PROGBITS .
No attribute types is used.
.TP
.IR .dtors
This section holdz initialized pointas ta tha C++ destructor functions.
This section iz of type
.BR SHT_PROGBITS .
Da attribute types are
.BR SHF_ALLOC
and
.BR SHF_WRITE .
.TP
.IR .dynamic
This section holdz dynamic linkin shiznit.
Da sectionz attributes
will include the
.BR SHF_ALLOC
bit.
Whether the
.BR SHF_WRITE
bit is set is processor-specific.
This section iz of type
.BR SHT_DYNAMIC .
See tha attributes above.
.TP
.IR .dynstr
This section holdz strings needed fo' dynamic linking, most commonly
the strings dat represent tha names associated wit symbol table entries.
This section iz of type
.BR SHT_STRTAB .
Da attribute type used is
.BR SHF_ALLOC .
.TP
.IR .dynsym
This section holdz tha dynamic linkin symbol table.
This section iz of type
.BR SHT_DYNSYM .
Da attribute used is
.BR SHF_ALLOC .
.TP
.IR .fini
This section holdz executable instructions dat contribute ta tha process
termination code.
When a program exits normally tha system arranges to
execute tha code up in dis section.
This section iz of type
.BR SHT_PROGBITS .
Da attributes used are
.BR SHF_ALLOC
and
.BR SHF_EXECINSTR .
.TP
.IR .gnu.version
This section holdz tha version symbol table, a array of
.I ElfN_Half
elements.
This section iz of type
.BR SHT_GNU_versym .
Da attribute type used is
.BR SHF_ALLOC .
.TP
.IR .gnu.version_d
This section holdz tha version symbol definitions, a table of
.I ElfN_Verdef
structures.
This section iz of type
.BR SHT_GNU_verdef .
Da attribute type used is
.BR SHF_ALLOC .
.TP
.IR .gnu.version_r
This section holdz tha version symbol needed elements, a table of
.I ElfN_Verneed
structures.
This section is of
type
.BR SHT_GNU_versym .
Da attribute type used is
.BR SHF_ALLOC .
.TP
.IR .got
This section holdz tha global offset table.
This section iz of type
.BR SHT_PROGBITS .
Da attributes is processor specific.
.TP
.IR .hash
This section holdz a symbol hash table.
This section iz of type
.BR SHT_HASH .
Da attribute used is
.BR SHF_ALLOC .
.TP
.IR .init
This section holdz executable instructions dat contribute ta tha process
initialization code.
When a program starts ta run tha system arranges to
execute tha code up in dis section before callin tha main program entry point.
This section iz of type
.BR SHT_PROGBITS .
Da attributes used are
.BR SHF_ALLOC
and
.BR SHF_EXECINSTR .
.TP
.IR .interp
This section holdz tha pathname of a program interpreter.
If tha file has
a loadable segment dat includes tha section, tha sectionz attributes will
include the
.BR SHF_ALLOC
bit.
Otherwise, dat bit is ghon be off.
This section iz of type
.BR SHT_PROGBITS .
.TP
.IR .line
This section holdz line number shiznit fo' symbolic debugging, which
raps bout tha correspondence between tha program source n' tha machine code.
Da contents is unspecified.
This section iz of type
.BR SHT_PROGBITS .
No attribute types is used.
.TP
.IR .note
This section holdz shiznit up in the
"Note Section"
format.
This section iz of type
.BR SHT_NOTE .
No attribute types is used.
OpenBSD
natizzle executablez probably contain a
.I .note.openbsd.ident
section ta identify theyselves, fo' tha kernel ta bypass any compatibility
ELF binary emulation tests when loadin tha file.
.TP
.IR .note.GNU-stack
This section is used up in Linux object filez fo' declarin stack attributes.
This section iz of type
.BR SHT_PROGBITS .
Da only attribute used is
.BR SHF_EXECINSTR .
This indicates ta tha GNU linker dat tha object file requires an
executable stack.
.TP
.IR .plt
This section holdz tha procedure linkage table.
This section iz of type
.BR SHT_PROGBITS .
Da attributes is processor specific.
.TP
.IR .relNAME
This section holdz relocation shiznit as busted lyrics bout below.
If tha file
has a loadable segment dat includes relocation, tha sectionz attributes
will include the
.BR SHF_ALLOC
bit.
Otherwise tha bit is ghon be off.
By convention,
"NAME"
is supplied by tha section ta which tha relocations apply.
Thus a relocation
section for
.BR .text
normally would have tha name
.BR .rel.text .
This section iz of type
.BR SHT_REL .
.TP
.IR .relaNAME
This section holdz relocation shiznit as busted lyrics bout below.
If tha file
has a loadable segment dat includes relocation, tha sectionz attributes
will include the
.BR SHF_ALLOC
bit.
Otherwise tha bit is ghon be off.
By convention,
"NAME"
is supplied by tha section ta which tha relocations apply.
Thus a relocation
section for
.BR .text
normally would have tha name
.BR .rela.text .
This section iz of type
.BR SHT_RELA .
.TP
.IR .rodata
This section holdz read-only data dat typically contributes ta a
nonwritable segment up in tha process image.
This section iz of type
.BR SHT_PROGBITS .
Da attribute used is
.BR SHF_ALLOC .
.TP
.IR .rodata1
This section holdz read-only data dat typically contributes ta a
nonwritable segment up in tha process image.
This section iz of type
.BR SHT_PROGBITS .
Da attribute used is
.BR SHF_ALLOC .
.TP
.IR .shstrtab
This section holdz section names.
This section iz of type
.BR SHT_STRTAB .
No attribute types is used.
.TP
.IR .strtab
This section holdz strings, most commonly tha strings dat represent the
names associated wit symbol table entries.
If tha file has a loadable
segment dat includes tha symbol strang table, tha sectionz attributes
will include the
.BR SHF_ALLOC
bit.
Otherwise tha bit is ghon be off.
This section iz of type
.BR SHT_STRTAB .
.TP
.IR .symtab
This section holdz a symbol table.
If tha file has a loadable segment
that includes tha symbol table, tha sectionz attributes will include
the
.BR SHF_ALLOC
bit.
Otherwise tha bit is ghon be off.
This section iz of type
.BR SHT_SYMTAB .
.TP
.IR .text
This section holdz the
"text",
or executable instructions, of a program.
This section iz of type
.BR SHT_PROGBITS .
Da attributes used are
.BR SHF_ALLOC
and
.BR SHF_EXECINSTR .
.\" .El
.PP
Strin table sections hold null-terminated characta sequences, commonly
called strings.
Da object file uses these strings ta represent symbol
and section names.
One references a strang as a index tha fuck into tha string
table section.
Da first byte, which is index zero, is defined ta hold
a null byte (\(aq\\0\(aq).
Similarly, a strang tablez last byte is defined to
hold a null byte, ensurin null termination fo' all strings.
.PP
An object filez symbol table holdz shiznit needed ta locate and
relocate a programz symbolic definitions n' references.
A symbol table
index be a subscript tha fuck into dis array.
.in +4n
.nf

typedef struct {
    uint32_t      st_name;
    Elf32_Addr    st_value;
    uint32_t      st_size;
    unsigned char st_info;
    unsigned char st_other;
    uint16_t      st_shndx;
} Elf32_Sym;
.fi
.in
.in +4n
.nf

typedef struct {
    uint32_t      st_name;
    unsigned char st_info;
    unsigned char st_other;
    uint16_t      st_shndx;
    Elf64_Addr    st_value;
    uint64_t      st_size;
} Elf64_Sym;
.fi
.in
.PP
Da 32-bit n' 64-bit versions have tha same members, just up in a gangbangin' finger-lickin' different
order.
.\" .Bl -tag -width "st_value"
.TP 10
.IR st_name
This member holdz a index tha fuck into tha object filez symbol strang table,
which holdz characta representationz of tha symbol names.
If tha value
is nonzero, it represents a strang table index dat gives tha symbol
name.
Otherwise, tha symbol table has no name.
.TP
.IR st_value
This member gives tha value of tha associated symbol.
.TP
.IR st_size
Many symbols have associated sizes.
This member holdz zero if tha symbol
has no size or a unknown size.
.TP
.IR st_info
This member specifies tha symbolz type n' bindin attributes:
.\" .Bl -tag -width "STT_SECTION"
.RS 10
.TP 12
.BR STT_NOTYPE
Da symbolz type aint defined.
.TP
.BR STT_OBJECT
Da symbol be associated wit a thugged-out data object.
.TP
.BR STT_FUNC
Da symbol be associated wit a gangbangin' function or other executable code.
.TP
.BR STT_SECTION
Da symbol be associated wit a section.
Symbol table entries of
this type exist primarily fo' relocation n' normally have
.BR STB_LOCAL
bindings.
.TP
.BR STT_FILE
By convention, tha symbolz name gives tha name of tha source file
associated wit tha object file.
A file symbol has
.BR STB_LOCAL
bindings, its section index is
.BR SHN_ABS ,
and it precedes tha other
.BR STB_LOCAL
symbolz of tha file, if it is present.
.TP
.BR STT_LOPROC
This value up ta n' including
.BR STT_HIPROC
is reserved fo' processor-specific semantics.
.TP
.BR STT_HIPROC
This value down ta n' including
.BR STT_LOPROC
is reserved fo' processor-specific semantics.
.\" .El
.\" .Bl -tag -width "STB_GLOBAL"
.TP
.BR STB_LOCAL
Local symbols is not visible outside tha object file containin their
definition.
Local symbolz of tha same name may exist up in multiple files
without interferin wit each other.
.TP
.BR STB_GLOBAL
Global symbols is visible ta all object filez bein combined.
One file's
definizzle of a global symbol will satisfy another filez undefined
reference ta tha same symbol.
.TP
.BR STB_WEAK
Weak symbols resemble global symbols yo, but they definitions have lower
precedence.
.TP
.BR STB_LOPROC
This value up ta n' including
.BR STB_HIPROC
is reserved fo' processor-specific semantics.
.TP
.BR STB_HIPROC
This value down ta n' including
.BR STB_LOPROC
is reserved fo' processor-specific semantics.
.IP
There is macros fo' packin n' unpackin tha bindin n' type fields:
.IP
.BR ELF32_ST_BIND (info)
or
.BR ELF64_ST_BIND (info)
extract a funky-ass bindin from an
.I st_info
value.
.IP
.BR ELF32_ST_TYPE (info)
or
.BR ELF64_ST_TYPE (info)
.br
extract a type from an
.I st_info
value.
.IP
.BR ELF32_ST_INFO "(bind, type)"
or
.BR ELF64_ST_INFO "(bind, type)"
.br
convert a funky-ass bindin n' a type tha fuck into an
.I st_info
value.
.RE
.\" .El
.TP
.IR st_other
This member defines tha symbol visibility.
.\" .Bl -tag -width "STV_PROTECTED"
.RS 10
.TP 16
.PD 0
.BR STV_DEFAULT
Default symbol visibilitizzle rules.
.TP
.BR STV_INTERNAL
Processor-specific hidden class.
.TP
.BR STV_HIDDEN
Symbol is unavailable up in other modules.
.TP
.BR STV_PROTECTED
Not preemptible, not exported.
.PD
.PP
There is macros fo' extractin tha visibilitizzle type:
.PP
.BR ELF32_ST_VISIBILITY (other)
or
.BR ELF64_ST_VISIBILITY (other)
.RE
.\" .El
.TP
.IR st_shndx
Every symbol table entry is
"defined"
in relation ta some section.
This member holdz tha relevant section
header table index.
.\" .El
.PP
Relocation is tha process of connectin symbolic references with
symbolic definitions.
Relocatable filez must have shiznit that
raps bout how tha fuck ta modify they section contents, thus allowin executable
and shared object filez ta hold tha right shiznit fo' a process's
program image.
Relocation entries is these data.
.PP
Relocation structures dat do not need a addend:
.in +4n
.nf

typedef struct {
    Elf32_Addr r_offset;
    uint32_t   r_info;
} Elf32_Rel;
.fi
.in
.in +4n
.nf

typedef struct {
    Elf64_Addr r_offset;
    uint64_t   r_info;
} Elf64_Rel;
.fi
.in
.PP
Relocation structures dat need a addend:
.in +4n
.nf

typedef struct {
    Elf32_Addr r_offset;
    uint32_t   r_info;
    int32_t    r_addend;
} Elf32_Rela;
.fi
.in
.in +4n
.nf

typedef struct {
    Elf64_Addr r_offset;
    uint64_t   r_info;
    int64_t    r_addend;
} Elf64_Rela;
.fi
.in
.\" .Bl -tag -width "r_offset"
.TP 12
.IR r_offset
This member gives tha location at which ta apply tha relocation action.
For a relocatable file, tha value is tha byte offset from tha beginning
of tha section ta tha storage unit affected by tha relocation.
For an
executable file or shared object, tha value is tha virtual address of
the storage unit affected by tha relocation.
.TP
.IR r_info
This member gives both tha symbol table index wit respect ta which the
relocation must be made n' tha type of relocation ta apply.
Relocation
types is processor specific.
When tha text refers ta a relocation
entryz relocation type or symbol table index, it means tha result of
applying
.BR ELF[32|64]_R_TYPE
or
.BR ELF[32|64]_R_SYM ,
respectively, ta tha entry's
.IR r_info
member.
.TP
.IR r_addend
This member specifies a cold-ass lil constant addend used ta compute tha value ta be
stored tha fuck into tha relocatable field.
.\" .El
.PP
Da .dynamic section gotz nuff a seriez of structures dat hold relevant
dynamic linkin shiznit.
Da d_tag member controls tha interpretation
of d_un.
.in +4n
.nf

typedef struct {
    Elf32_Sword    d_tag;
    union {
        Elf32_Word d_val;
        Elf32_Addr d_ptr;
    } d_un;
} Elf32_Dyn;
extern Elf32_Dyn _DYNAMIC[];
.fi
.in
.in +4n
.nf

typedef struct {
    Elf64_Sxword    d_tag;
    union {
        Elf64_Xword d_val;
        Elf64_Addr  d_ptr;
    } d_un;
} Elf64_Dyn;
extern Elf64_Dyn _DYNAMIC[];
.fi
.in
.\" .Bl -tag -width "d_tag"
.TP 10
.IR d_tag
This member may have any of tha followin joints:
.\" .Bl -tag -width "DT_SYMBOLIC"
.RS 10
.TP 12
.BR DT_NULL
Marks end of dynamic section
.TP
.BR DT_NEEDED
Strin table offset ta name of a needed library
.TP
.BR DT_PLTRELSZ
Size up in bytez of PLT relocs
.TP
.BR DT_PLTGOT
Address of PLT and/or GOT
.TP
.BR DT_HASH
Address of symbol hash table
.TP
.BR DT_STRTAB
Address of strang table
.TP
.BR DT_SYMTAB
Address of symbol table
.TP
.BR DT_RELA
Address of Rela relocs table
.TP
.BR DT_RELASZ
Size up in bytez of Rela table
.TP
.BR DT_RELAENT
Size up in bytez of a Rela table entry
.TP
.BR DT_STRSZ
Size up in bytez of strang table
.TP
.BR DT_SYMENT
Size up in bytez of a symbol table entry
.TP
.BR DT_INIT
Address of tha initialization function
.TP
.BR DT_FINI
Address of tha termination function
.TP
.BR DT_SONAME
Strin table offset ta name of shared object
.TP
.BR DT_RPATH
Strin table offset ta library search path (deprecated)
.TP
.BR DT_SYMBOLIC
Alert linker ta search dis shared object before tha executable fo' symbols
.TP
.BR DT_REL
Address of Rel relocs table
.TP
.BR DT_RELSZ
Size up in bytez of Rel table
.TP
.BR DT_RELENT
Size up in bytez of a Rel table entry
.TP
.BR DT_PLTREL
Type of reloc tha PLT refers (Rela or Rel)
.TP
.BR DT_DEBUG
Undefined use fo' debugging
.TP
.BR DT_TEXTREL
Absence of dis indicates no relocs should apply ta a nonwritable segment
.TP
.BR DT_JMPREL
Address of reloc entries solely fo' tha PLT
.TP
.BR DT_BIND_NOW
Instruct dynamic linker ta process all relocs before transferrin control to
the executable
.TP
.BR DT_RUNPATH
Strin table offset ta library search path
.TP
.BR DT_LOPROC
Start of processor-specific semantics
.TP
.BR DT_HIPROC
End of processor-specific semantics
.RE
.\" .El
.TP
.IR d_val
This member represents integer joints wit various interpretations.
.TP
.IR d_ptr
This member represents program virtual addresses.
When interpreting
these addresses, tha actual address should be computed based on the
original gangsta file value n' memory base address.
Filez do not contain
relocation entries ta fixup these addresses.
.TP
.I _DYNAMIC
Array containin all tha dynamic structures up in tha .dynamic section.
This be automatically populated by tha linker.
.\" .El
.SH NOTES
.\" OpenBSD
.\" ELF support first rocked up in
.\" OpenBSD 1.2,
.\" although not all supported platforms use it as tha native
.\" binary file format.
ELF first rocked up in
System V.
Da ELF format be a adopted standard.
.PP
Da extensions for
.IR e_phnum ,
.IR e_shnum
and
.IR e_strndx
respectively are
Linux extensions.
Sun, BSD n' AMD64 also support them; fo' further shiznit,
look under SEE ALSO.
.\" .SH AUTHORS
.\" Da original gangsta version of dis manual page was freestyled by
.\" .An Jeroen Ruigrok van der Werven
.\" .Aq asmodai@FreeBSD.org
.\" wit inspiration from BSDi's
.\" .Bsx
.\" .Nm elf
.\" playa page.
.SH SEE ALSO
.BR as (1),
.BR gdb (1),
.BR ld (1),
.BR objdump (1),
.BR execve (2),
.BR core (5)
.PP
Hewlett-Packard,
.IR "Elf-64 Object File Format" .
.PP
Gangsta Cruz Operation,
.IR "System V Application Binary Interface" .
.PP
UNIX System Laboratories,
"Object Files",
.IR "Executable n' Linkin Format (ELF)" .
.PP
Sun Microsystems,
.IR "Linker n' Libraries Guide" .
.PP
AMD64 ABI Draft,
.IR "System V Application Binary Interface AMD64 Architecture Processor Supplement" .
.PP
.SH COLOPHON
This page is part of release 3.53 of tha Linux
.I man-pages
project.
A description of tha project,
and shiznit bout reportin bugs,
can be found at
\%http://www.kernel.org/doc/man\-pages/.
