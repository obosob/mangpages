.TH iptables-extensions 8 "" "iptablez 1.4.19.1" "iptablez 1.4.19.1"
.SH NAME
iptables-extensions \(em list of extensions up in tha standard iptablez distribution
.SH SYNOPSIS
\fBip6tables\fP [\fB\-m\fP \fIname\fP [\fImodule-options\fP...]]
[\fB\-j\fP \fItarget-name\fP [\fItarget-options\fP...]
.PP
\fBiptables\fP [\fB\-m\fP \fIname\fP [\fImodule-options\fP...]]
[\fB\-j\fP \fItarget-name\fP [\fItarget-options\fP...]
.SH MATCH EXTENSIONS
iptablez can use extended packet matchin modules
with tha \fB\-m\fP or \fB\-\-match\fP
options, followed by tha matchin module name; afta these, various
extra command line options become available, dependin on tha specific
module.  Yo ass can specify multiple extended match modulez up in one line,
and you can use tha \fB\-h\fP or \fB\-\-help\fP
options afta tha module has been specified ta receive help specific
to dat module.  Da extended match modulez is evaluated up in tha order
they is specified up in tha rule.
.PP
If tha \fB\-p\fP or \fB\-\-protocol\fP was specified n' if n' only if an
unknown option is encountered, iptablez will try load a match module of the
same name as tha protocol, ta try makin tha option available.
.\" @MATCH@
.SS addrtype
This module matches packets based on they 
.B address type.
Address types is used within tha kernel networkin stack n' categorize
addresses tha fuck into various groups.  Da exact definizzle of dat crew dependz on tha specific layer three protocol.
.PP
Da followin address types is possible:
.TP
.BI "UNSPEC"
an unspecified address (i.e. 0.0.0.0)
.TP
.BI "UNICAST"
an unicast address
.TP
.BI "LOCAL"
a local address
.TP
.BI "BROADCAST"
a broadcast address
.TP
.BI "ANYCAST"
an anycast packet
.TP
.BI "MULTICAST"
a multicast address
.TP
.BI "BLACKHOLE"
a blackhole address
.TP
.BI "UNREACHABLE"
an unreachable address
.TP
.BI "PROHIBIT"
a prohibited address
.TP
.BI "THROW"
FIXME
.TP
.BI "NAT"
FIXME
.TP
.BI "XRESOLVE"
.TP
[\fB!\fP] \fB\-\-src\-type\fP \fItype\fP
Matches if tha source address iz of given type
.TP
[\fB!\fP] \fB\-\-dst\-type\fP \fItype\fP
Matches if tha destination address iz of given type
.TP
.BI "\-\-limit\-iface\-in"
Da address type checkin can be limited ta tha intercourse tha packet is coming
in. I aint talkin' bout chicken n' gravy biatch. This option is only valid up in the
.BR PREROUTING ,
.B INPUT
and
.B FORWARD
chains. Well shiiiit, it cannot be specified wit the
\fB\-\-limit\-iface\-out\fP
option.
.TP
\fB\-\-limit\-iface\-out\fP
Da address type checkin can be limited ta tha intercourse tha packet is going
out. This option is only valid up in the
.BR POSTROUTING ,
.B OUTPUT
and
.B FORWARD
chains. Well shiiiit, it cannot be specified wit the
\fB\-\-limit\-iface\-in\fP
option.
.SS ah (IPv6-specific)
This module matches tha parametas up in Authentication header of IPsec packets.
.TP
[\fB!\fP] \fB\-\-ahspi\fP \fIspi\fP[\fB:\fP\fIspi\fP]
Matches SPI.
.TP
[\fB!\fP] \fB\-\-ahlen\fP \fIlength\fP
Total length of dis header up in octets.
.TP
\fB\-\-ahres\fP
Matches if tha reserved field is filled wit zero.
.SS ah (IPv4-specific)
This module matches tha SPIs up in Authentication header of IPsec packets.
.TP
[\fB!\fP] \fB\-\-ahspi\fP \fIspi\fP[\fB:\fP\fIspi\fP]
.SS bpf
Match rockin Linux Socket Filter n' shit. Expects a BPF program up in decimal format. This
is tha format generated by tha \fBnfbpf_compile\fP utility.
.TP
\fB\-\-bytecode\fP \fIcode\fP
Pass tha BPF byte code format (busted lyrics bout up in tha example below).
.PP
Da code format is similar ta tha output of tha tcpdump -ddd command: one line
that stores tha number of instructions, followed by one line fo' each
instruction. I aint talkin' bout chicken n' gravy biatch. Instruction lines follow tha pattern 'u16 u8 u8 u32' up in decimal
notation. I aint talkin' bout chicken n' gravy biatch. Fieldz encode tha operation, jump offset if true, jump offset if
false n' generic multiuse field 'K'. Comments is not supported.
.PP
For example, ta read only packets matchin 'ip proto 6', bang tha following,
without tha comments or trailin whitespace:
.IP
4               # number of instructions
.br
48 0 0 9        # load byte  ip->proto
.br
21 0 1 6        # jump equal IPPROTO_TCP
.br
6 0 0 1         # return     pass (non-zero)
.br
6 0 0 0         # return     fail (zero)
.PP
Yo ass can pass dis filta ta tha bpf match wit tha followin command:
.IP
iptablez \-A OUTPUT \-m bpf \-\-bytecode '4,48 0 0 9,21 0 1 6,6 0 0 1,6 0 0 0' \-j ACCEPT
.PP
Or instead, you can invoke tha nfbpf_compile utility.
.IP
iptablez \-A OUTPUT \-m bpf \-\-bytecode "`nfbpf_compile RAW 'ip proto 6'`" \-j ACCEPT
.PP
Yo ass may wanna learn mo' bout BPF from FreeBSDz bpf(4) manpage.
.SS cluster
Allows you ta deploy gateway n' back-end load-sharin clustas without the
need of load-balancers.
.PP
This match requires dat all tha nodes peep tha same packets, n' you can put dat on yo' toast. Thus, tha cluster
match decides if dis node has ta handle a packet given tha followin options:
.TP
\fB\-\-cluster\-total\-nodes\fP \fInum\fP
Set number of total nodes up in cluster.
.TP
[\fB!\fP] \fB\-\-cluster\-local\-node\fP \fInum\fP
Set tha local node number ID.
.TP
[\fB!\fP] \fB\-\-cluster\-local\-nodemask\fP \fImask\fP
Set tha local node number ID mask. Yo ass can use dis option instead
of \fB\-\-cluster\-local\-node\fP.
.TP
\fB\-\-cluster\-hash\-seed\fP \fIvalue\fP
Set seed value of tha Jenkins hash.
.PP
Example:
.IP
iptablez \-A PREROUTING \-t mangle \-i eth1 \-m cluster
\-\-cluster\-total\-nodes 2 \-\-cluster\-local\-node 1
\-\-cluster\-hash\-seed 0xdeadbeef
\-j MARK \-\-set-mark 0xffff
.IP
iptablez \-A PREROUTING \-t mangle \-i eth2 \-m cluster
\-\-cluster\-total\-nodes 2 \-\-cluster\-local\-node 1
\-\-cluster\-hash\-seed 0xdeadbeef
\-j MARK -\-set\-mark 0xffff
.IP
iptablez \-A PREROUTING \-t mangle \-i eth1
\-m mark ! \-\-mark 0xffff \-j DROP
.IP
iptablez \-A PREROUTING \-t mangle \-i eth2
\-m mark ! \-\-mark 0xffff \-j DROP
.PP
And tha followin commandz ta make all nodes peep tha same packets:
.IP
ip maddr add 01:00:5e:00:01:01 dev eth1
.IP
ip maddr add 01:00:5e:00:01:02 dev eth2
.IP
arptablez \-A OUTPUT \-o eth1 \-\-h\-length 6
\-j mangle \-\-mangle-mac-s 01:00:5e:00:01:01
.IP
arptablez \-A INPUT \-i eth1 \-\-h-length 6
\-\-destination-mac 01:00:5e:00:01:01
\-j mangle \-\-mangle\-mac\-d 00:zz:yy:xx:5a:27
.IP
arptablez \-A OUTPUT \-o eth2 \-\-h\-length 6
\-j mangle \-\-mangle\-mac\-s 01:00:5e:00:01:02
.IP
arptablez \-A INPUT \-i eth2 \-\-h\-length 6
\-\-destination\-mac 01:00:5e:00:01:02
\-j mangle \-\-mangle\-mac\-d 00:zz:yy:xx:5a:27
.PP
In tha case of TCP connections, pickup facilitizzle has ta be disabled
to avoid markin TCP ACK packets comin up in tha reply direction as
valid.
.IP
echo 0 > /proc/sys/net/netfilter/nf_conntrack_tcp_loose
.SS comment
Allows you ta add comments (up ta 256 characters) ta any rule.
.TP
\fB\-\-comment\fP \fIcomment\fP
.TP
Example:
iptablez \-A INPUT \-i eth1 \-m comment \-\-comment "my local LAN"
.SS connbytes
Match by how tha fuck nuff bytes or packets a cold-ass lil connection (or one of tha two
flows constitutin tha connection) has transferred so far, or by
average bytes per packet.
.PP
Da countas is 64-bit n' is thus not sposed ta fuckin overflow ;)
.PP
Da primary use is ta detect long-lived downloadz n' mark dem ta be
scheduled rockin a lower prioritizzle crew up in traffic control.
.PP
Da transferred bytes per connection can also be viewed through
`conntrack \-L` n' accessed via ctnetlink.
.PP
NOTE dat fo' connections which have no accountin shiznit, tha match will
always return false. Da "net.netfilter.nf_conntrack_acct" sysctl flag controls
whether \fBnew\fP connections is ghon be byte/packet counted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Existin connection
flows aint gonna be gaining/losin a/the accountin structure when be sysctl flag
is flipped.
.TP
[\fB!\fP] \fB\-\-connbytes\fP \fIfrom\fP[\fB:\fP\fIto\fP]
match packets from a cold-ass lil connection whose packets/bytes/average packet
size is mo' than FROM n' less than TO bytes/packets, n' you can put dat on yo' toast. if TO is
omitted only FROM check is done. "!" is used ta match packets not
fallin up in tha range.
.TP
\fB\-\-connbytes\-dir\fP {\fBoriginal\fP|\fBreply\fP|\fBboth\fP}
which packets ta consider
.TP
\fB\-\-connbytes\-mode\fP {\fBpackets\fP|\fBbytes\fP|\fBavgpkt\fP}
whether ta check tha amount of packets, number of bytes transferred or
the average size (in bytes) of all packets received so far. Shiiit, dis aint no joke. Note that
when "both" is used together wit "avgpkt", n' data is goin (mainly)
only up in one erection (for example HTTP), tha average packet size will
be bout half of tha actual data packets.
.TP
Example:
iptablez .. \-m connbytes \-\-connbytes 10000:100000 \-\-connbytes\-dir both \-\-connbytes\-mode bytes ...
.SS connlabel
Module matches or addz connlabels ta a cold-ass lil connection.
connlabels is similar ta connmarks, except labels is bit-based; i.e.
all labels may be attached ta a gangbangin' flow all up in tha same time.
Up ta 128 unique labels is currently supported.
.TP
[\fB!\fP] \fB\-\-label\fP \fBname\fP
matches if label \fBname\fP has been set on a cold-ass lil connection.
Instead of a name (which is ghon be translated ta a number, peep EXAMPLE below),
a number may be used instead. Y'all KNOW dat shit, muthafucka!  Usin a number always overrides connlabel.conf.
.TP
\fB\-\-set\fP
if tha label has not been set on tha connection, set dat shit.
Note dat settin a label can fail.  This is cuz tha kernel allocates the
conntrack label storage area when tha connection is pimped, n' it only
reserves tha amount of memory required by tha ruleset dat exists at
the time tha connection is pimped.
In dis case, tha match will fail (or succeed, up in case \fB\-\-label\fP
option was negated).
.PP
Label translation is done via tha \fB/etc/xtables/connlabel.conf\fP configuration file.
.PP
Example:
.IP
.nf
0	eth0-in
1	eth0-out
2	ppp-in
3	ppp-out
4	bulk-traffic
5	interactive
.fi
.PP
.SS connlimit
Allows you ta restrict tha number of parallel connections ta a server per
client IP address (or client address block).
.TP
\fB\-\-connlimit\-upto\fP \fIn\fP
Match if tha number of existin connections is below or equal \fIn\fP.
.TP
\fB\-\-connlimit\-above\fP \fIn\fP
Match if tha number of existin connections be above \fIn\fP.
.TP
\fB\-\-connlimit\-mask\fP \fIprefix_length\fP
Group hosts rockin tha prefix length. For IPv4, dis must be a number between
(including) 0 n' 32. For IPv6, between 0 n' 128. If not specified, the
maximum prefix length fo' tha applicable protocol is used.
.TP
\fB\-\-connlimit\-saddr\fP
Apply tha limit onto tha source group. This is tha default if
\-\-connlimit\-daddr aint specified.
.TP
\fB\-\-connlimit\-daddr\fP
Apply tha limit onto tha destination group.
.PP
Examples:
.TP
# allow 2 telnet connections per client host
iptablez \-A INPUT \-p tcp \-\-syn \-\-dport 23 \-m connlimit \-\-connlimit\-above 2 \-j REJECT
.TP
# you can also match tha other way around:
iptablez \-A INPUT \-p tcp \-\-syn \-\-dport 23 \-m connlimit \-\-connlimit\-upto 2 \-j ACCEPT
.TP
# limit tha number of parallel HTTP requests ta 16 per class C sized \
source network (24 bit netmask)
iptablez \-p tcp \-\-syn \-\-dport 80 \-m connlimit \-\-connlimit\-above 16
\-\-connlimit\-mask 24 \-j REJECT
.TP
# limit tha number of parallel HTTP requests ta 16 fo' tha link local network
(ipv6)
ip6tablez \-p tcp \-\-syn \-\-dport 80 \-s fe80::/64 \-m connlimit \-\-connlimit\-above
16 \-\-connlimit\-mask 64 \-j REJECT
.TP
# Limit tha number of connections ta a particular host:
ip6tablez \-p tcp \-\-syn \-\-dport 49152:65535 \-d 2001:db8::1 \-m connlimit
\-\-connlimit-above 100 \-j REJECT
.SS connmark
This module matches tha netfilta mark field associated wit a cold-ass lil connection
(which can be set rockin tha \fBCONNMARK\fP target below).
.TP
[\fB!\fP] \fB\-\-mark\fP \fIvalue\fP[\fB/\fP\fImask\fP]
Matches packets up in connections wit tha given mark value (if a mask is
specified, dis is logically ANDed wit tha mark before tha comparison).
.SS conntrack
This module, when combined wit connection tracking, allows access ta the
connection trackin state fo' dis packet/connection.
.TP
[\fB!\fP] \fB\-\-ctstate\fP \fIstatelist\fP
\fIstatelist\fP be a cold-ass lil comma separated list of tha connection states ta match.
Possible states is listed below.
.TP
[\fB!\fP] \fB\-\-ctproto\fP \fIl4proto\fP
Layer-4 protocol ta match (by number or name)
.TP
[\fB!\fP] \fB\-\-ctorigsrc\fP \fIaddress\fP[\fB/\fP\fImask\fP]
.TP
[\fB!\fP] \fB\-\-ctorigdst\fP \fIaddress\fP[\fB/\fP\fImask\fP]
.TP
[\fB!\fP] \fB\-\-ctreplsrc\fP \fIaddress\fP[\fB/\fP\fImask\fP]
.TP
[\fB!\fP] \fB\-\-ctrepldst\fP \fIaddress\fP[\fB/\fP\fImask\fP]
Match against original/reply source/destination address
.TP
[\fB!\fP] \fB\-\-ctorigsrcport\fP \fIport\fP[\fB:\fP\fIport\fP]
.TP
[\fB!\fP] \fB\-\-ctorigdstport\fP \fIport\fP[\fB:\fP\fIport\fP]
.TP
[\fB!\fP] \fB\-\-ctreplsrcport\fP \fIport\fP[\fB:\fP\fIport\fP]
.TP
[\fB!\fP] \fB\-\-ctrepldstport\fP \fIport\fP[\fB:\fP\fIport\fP]
Match against original/reply source/destination port (TCP/UDP/etc.) or GRE key.
Matchin against port ranges is only supported up in kernel versions above 2.6.38.
.TP
[\fB!\fP] \fB\-\-ctstatus\fP \fIstatelist\fP
\fIstatuslist\fP be a cold-ass lil comma separated list of tha connection statuses ta match.
Possible statuses is listed below.
.TP
[\fB!\fP] \fB\-\-ctexpire\fP \fItime\fP[\fB:\fP\fItime\fP]
Match remainin gametime up in secondz against given value or range of joints
(inclusive)
.TP
\fB\-\-ctdir\fP {\fBORIGINAL\fP|\fBREPLY\fP}
Match packets dat is flowin up in tha specified direction. I aint talkin' bout chicken n' gravy biatch. If dis flag is not
specified at all, matches packets up in both directions.
.PP
States fo' \fB\-\-ctstate\fP:
.TP
\fBINVALID\fP
Da packet be associated wit no known connection.
.TP
\fBNEW\fP
Da packet has started a freshly smoked up connection, or otherwise associated
with a cold-ass lil connection which has not peeped packets up in both directions.
.TP
\fBESTABLISHED\fP
Da packet be associated wit a cold-ass lil connection which has peeped packets
in both directions.
.TP
\fBRELATED\fP
Da packet is startin a freshly smoked up connection yo, but be associated wit an
existin connection, like fuckin a FTP data transfer, or a ICMP error.
.TP
\fBUNTRACKED\fP
Da packet aint tracked at all, which happens if you explicitly untrack it
by rockin \-j CT \-\-notrack up in tha raw table.
.TP
\fBSNAT\fP
A virtual state, matchin if tha original gangsta source address differs from tha reply
destination.
.TP
\fBDNAT\fP
A virtual state, matchin if tha original gangsta destination differs from tha reply
source.
.PP
Statuses fo' \fB\-\-ctstatus\fP:
.TP
\fBNONE\fP
None of tha below.
.TP
\fBEXPECTED\fP
This be a expected connection (i.e. a cold-ass lil conntrack helper set it up).
.TP
\fBSEEN_REPLY\fP
Conntrack has peeped packets up in both directions.
.TP
\fBASSURED\fP
Conntrack entry should never be early-expired.
.TP
\fBCONFIRMED\fP
Connection is confirmed: originatin packet has left box.
.SS cpu
.TP
[\fB!\fP] \fB\-\-cpu\fP \fInumber\fP
Match cpu handlin dis packet. cpus is numbered from 0 ta NR_CPUS-1
Can be used up in combination wit RPS (Remote Packet Steering) or
multiqueue NICs ta spread network traffic on different queues.
.PP
Example:
.PP
iptablez \-t nat \-A PREROUTING \-p tcp \-\-dport 80 \-m cpu \-\-cpu 0 
\-j REDIRECT \-\-to\-port 8080
.PP
iptablez \-t nat \-A PREROUTING \-p tcp \-\-dport 80 \-m cpu \-\-cpu 1 
\-j REDIRECT \-\-to\-port 8081
.PP
Available since Linux 2.6.36.
.SS dccp
.TP
[\fB!\fP] \fB\-\-source\-port\fP,\fB\-\-sport\fP \fIport\fP[\fB:\fP\fIport\fP]
.TP
[\fB!\fP] \fB\-\-destination\-port\fP,\fB\-\-dport\fP \fIport\fP[\fB:\fP\fIport\fP]
.TP
[\fB!\fP] \fB\-\-dccp\-types\fP \fImask\fP
Match when tha DCCP packet type is one of 'mask'. 'mask' be a cold-ass lil comma-separated
list of packet types.  Packet types are: 
.BR "REQUEST RESPONSE DATA ACK DATAACK CLOSEREQ CLOSE RESET SYNC SYNCACK INVALID" .
.TP
[\fB!\fP] \fB\-\-dccp\-option\fP \fInumber\fP
Match if DCCP option set.
.SS devgroup
Match thang crew of a packets incoming/outgoin intercourse.
.TP
[\fB!\fP] \fB\-\-src\-group\fP \fIname\fP
Match thang crew of incomin device
.TP
[\fB!\fP] \fB\-\-dst\-group\fP \fIname\fP
Match thang crew of outgoin device
.SS dscp
This module matches tha 6 bit DSCP field within tha TOS field up in the
IP header n' shit.  DSCP has superseded TOS within tha IETF.
.TP
[\fB!\fP] \fB\-\-dscp\fP \fIvalue\fP
Match against a numeric (decimal or hex) value [0-63].
.TP
[\fB!\fP] \fB\-\-dscp\-class\fP \fIclass\fP
Match tha DiffServ class. This value may be any of the
BE, EF, AFxx or CSx classes.  It will then be converted
into its accordin numeric value.
.SS dst (IPv6-specific)
This module matches tha parametas up in Destination Options header
.TP
[\fB!\fP] \fB\-\-dst\-len\fP \fIlength\fP
Total length of dis header up in octets.
.TP
\fB\-\-dst\-opts\fP \fItype\fP[\fB:\fP\fIlength\fP][\fB,\fP\fItype\fP[\fB:\fP\fIlength\fP]...]
numeric type of option n' tha length of tha option data up in octets.
.SS ecn
This allows you ta match tha ECN bitz of tha IPv4/IPv6 n' TCP header n' shit.  ECN is tha Explicit Congestion Notification mechanizzle as specified up in RFC3168
.TP
[\fB!\fP] \fB\-\-ecn\-tcp\-cwr\fP
This matches if tha TCP ECN CWR (Congestion Window Received) bit is set.
.TP
[\fB!\fP] \fB\-\-ecn\-tcp\-ece\fP
This matches if tha TCP ECN ECE (ECN Echo) bit is set.
.TP
[\fB!\fP] \fB\-\-ecn\-ip\-ect\fP \fInum\fP
This matches a particular IPv4/IPv6 ECT (ECN-Capable Transport). Yo ass gotta specify
a number between `0' n' `3'.
.SS esp
This module matches tha SPIs up in ESP header of IPsec packets.
.TP
[\fB!\fP] \fB\-\-espspi\fP \fIspi\fP[\fB:\fP\fIspi\fP]
.SS eui64 (IPv6-specific)
This module matches tha EUI-64 part of a stateless autoconfigured IPv6 address.
It compares tha EUI-64 derived from tha source MAC address up in Ethernet frame
with tha lower 64 bitz of tha IPv6 source address. But "Universal/Local"
bit aint compared. Y'all KNOW dat shit, muthafucka! This module don't match other link layer frame, and
is only valid up in the
.BR PREROUTING ,
.BR INPUT
and
.BR FORWARD
chains.
.SS frag (IPv6-specific)
This module matches tha parametas up in Fragment header.
.TP
[\fB!\fP] \fB\-\-fragid\fP \fIid\fP[\fB:\fP\fIid\fP]
Matches tha given Identification or range of dat shit.
.TP
[\fB!\fP] \fB\-\-fraglen\fP \fIlength\fP
This option cannot be used wit kernel version 2.6.10 or later n' shit. Da length of
Fragment header is static n' dis option don't make sense.
.TP
\fB\-\-fragres\fP
Matches if tha reserved fieldz is filled wit zero.
.TP
\fB\-\-fragfirst\fP
Matches on tha straight-up original gangsta fragment.
.TP
\fB\-\-fragmore\fP
Matches if there be mo' fragments.
.TP
\fB\-\-fraglast\fP
Matches if dis is tha last fragment.
.SS hashlimit
\fBhashlimit\fP uses hash buckets ta express a rate limitin match (like the
\fBlimit\fP match) fo' a crew of connections rockin a \fBsingle\fP iptables
rule. Groupin can be done per-hostgroup (source and/or destination address)
and/or per-port. Well shiiiit, it gives you tha mobilitizzle ta express "\fIN\fP packets per time
quantum per group" or "\fIN\fP bytes per seconds" (see below fo' some examples).
.PP
A hash limit option (\fB\-\-hashlimit\-upto\fP, \fB\-\-hashlimit\-above\fP) and
\fB\-\-hashlimit\-name\fP is required.
.TP
\fB\-\-hashlimit\-upto\fP \fIamount\fP[\fB/second\fP|\fB/minute\fP|\fB/hour\fP|\fB/day\fP]
Match if tha rate is below or equal ta \fIamount\fP/quantum. Well shiiiit, it is specified either as
a number, wit a optionizzle time quantum suffix (the default is 3/hour), or as
\fIamount\fPb/second (number of bytes per second).
.TP
\fB\-\-hashlimit\-above\fP \fIamount\fP[\fB/second\fP|\fB/minute\fP|\fB/hour\fP|\fB/day\fP]
Match if tha rate be above \fIamount\fP/quantum.
.TP
\fB\-\-hashlimit\-burst\fP \fIamount\fP
Maximum initial number of packets ta match: dis number gets recharged by one
every time tha limit specified above aint reached, up ta dis number; the
default is 5.  When byte-based rate matchin is requested, dis option specifies
the amount of bytes dat can exceed tha given rate.  This option should be used
with caution -- if tha entry expires, tha burst value is reset like a muthafucka.
.TP
\fB\-\-hashlimit\-mode\fP {\fBsrcip\fP|\fBsrcport\fP|\fBdstip\fP|\fBdstport\fP}\fB,\fP...
A comma-separated list of objects ta take tha fuck into consideration. I aint talkin' bout chicken n' gravy biatch. If no
\-\-hashlimit\-mode option is given, hashlimit acts like limit yo, but at the
expensive of bustin tha hash housekeeping.
.TP
\fB\-\-hashlimit\-srcmask\fP \fIprefix\fP
When \-\-hashlimit\-mode srcip is used, all source addresses encountered will be
grouped accordin ta tha given prefix length n' tha so-created subnet will be
subject ta hashlimit. \fIprefix\fP must be between (inclusive) 0 n' 32. Note
that \-\-hashlimit\-srcmask 0 is basically bustin tha same thang as not specifying
srcip fo' \-\-hashlimit\-mode yo, but is technologically mo' expensive.
.TP
\fB\-\-hashlimit\-dstmask\fP \fIprefix\fP
Like \-\-hashlimit\-srcmask yo, but fo' destination addresses.
.TP
\fB\-\-hashlimit\-name\fP \fIfoo\fP
Da name fo' tha /proc/net/ipt_hashlimit/foo entry.
.TP
\fB\-\-hashlimit\-htable\-size\fP \fIbuckets\fP
Da number of bucketz of tha hash table
.TP
\fB\-\-hashlimit\-htable\-max\fP \fIentries\fP
Maximum entries up in tha hash.
.TP
\fB\-\-hashlimit\-htable\-expire\fP \fImsec\fP
Afta how tha fuck nuff millisecondz do hash entries expire.
.TP
\fB\-\-hashlimit\-htable\-gcinterval\fP \fImsec\fP
How tha fuck nuff millisecondz between garbage collection intervals.
.PP
Examples:
.TP
matchin on source host
"1000 packets per second fo' every last muthafuckin host up in 192.168.0.0/16" =>
\-s 192.168.0.0/16 \-\-hashlimit\-mode srcip \-\-hashlimit\-upto 1000/sec
.TP
matchin on source port
"100 packets per second fo' every last muthafuckin steez of 192.168.1.1" =>
\-s 192.168.1.1 \-\-hashlimit\-mode srcport \-\-hashlimit\-upto 100/sec
.TP
matchin on subnet
"10000 packets per minute fo' every last muthafuckin /28 subnet (groupz of 8 addresses)
in 10.0.0.0/8" =>
\-s 10.0.0.8 \-\-hashlimit\-mask 28 \-\-hashlimit\-upto 10000/min
.TP
matchin bytes per second
"flows exceedin 512kbyte/s" =>
\-\-hashlimit-mode srcip,dstip,srcport,dstport \-\-hashlimit\-above 512kb/s
.TP
matchin bytes per second
"hosts dat exceed 512kbyte/s yo, but permit up ta 1Megabytes without matching"
\-\-hashlimit-mode dstip \-\-hashlimit\-above 512kb/s \-\-hashlimit-burst 1mb
.SS hbh (IPv6-specific)
This module matches tha parametas up in Hop-by-Hop Options header
.TP
[\fB!\fP] \fB\-\-hbh\-len\fP \fIlength\fP
Total length of dis header up in octets.
.TP
\fB\-\-hbh\-opts\fP \fItype\fP[\fB:\fP\fIlength\fP][\fB,\fP\fItype\fP[\fB:\fP\fIlength\fP]...]
numeric type of option n' tha length of tha option data up in octets.
.SS helper
This module matches packets related ta a specific conntrack-helper.
.TP
[\fB!\fP] \fB\-\-helper\fP \fIstring\fP
Matches packets related ta tha specified conntrack-helper.
.RS
.PP
strin can be "ftp" fo' packets related ta a gangbangin' ftp-session on default port.
For other ports append \-portnr ta tha value, ie. "ftp\-2121".
.PP
Same rulez apply fo' other conntrack-helpers.
.RE
.SS hl (IPv6-specific)
This module matches tha Hop Limit field up in tha IPv6 header.
.TP
[\fB!\fP] \fB\-\-hl\-eq\fP \fIvalue\fP
Matches if Hop Limit equals \fIvalue\fP.
.TP
\fB\-\-hl\-lt\fP \fIvalue\fP
Matches if Hop Limit is less than \fIvalue\fP.
.TP
\fB\-\-hl\-gt\fP \fIvalue\fP
Matches if Hop Limit is pimped outa than \fIvalue\fP.
.SS icmp (IPv4-specific)
This extension can be used if `\-\-protocol icmp' is specified. Y'all KNOW dat shit, muthafucka! It
provides tha followin option:
.TP
[\fB!\fP] \fB\-\-icmp\-type\fP {\fItype\fP[\fB/\fP\fIcode\fP]|\fItypename\fP}
This allows justification of tha ICMP type, which can be a numeric
ICMP type, type/code pair, or one of tha ICMP type names shown by tha command
.nf
 iptablez \-p icmp \-h
.fi
.SS icmp6 (IPv6-specific)
This extension can be used if `\-\-protocol ipv6\-icmp' or `\-\-protocol icmpv6' is
specified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it serves up tha followin option:
.TP
[\fB!\fP] \fB\-\-icmpv6\-type\fP \fItype\fP[\fB/\fP\fIcode\fP]|\fItypename\fP
This allows justification of tha ICMPv6 type, which can be a numeric
ICMPv6
.IR type ,
.IR type
and
.IR code ,
or one of tha ICMPv6 type names shown by tha command
.nf
 ip6tablez \-p ipv6\-icmp \-h
.fi
.SS iprange
This matches on a given arbitrary range of IP addresses.
.TP
[\fB!\fP] \fB\-\-src\-range\fP \fIfrom\fP[\fB\-\fP\fIto\fP]
Match source IP up in tha specified range.
.TP
[\fB!\fP] \fB\-\-dst\-range\fP \fIfrom\fP[\fB\-\fP\fIto\fP]
Match destination IP up in tha specified range.
.SS ipv6header (IPv6-specific)
This module matches IPv6 extension headaz and/or upper layer header.
.TP
\fB\-\-soft\fP
Matches if tha packet includes \fBany\fP of tha headaz specified with
\fB\-\-header\fP.
.TP
[\fB!\fP] \fB\-\-header\fP \fIheader\fP[\fB,\fP\fIheader\fP...]
Matches tha packet which EXACTLY includes all specified headers. Da headers
encapsulated wit ESP header is outta scope.
Possible \fIheader\fP types can be:
.TP
\fBhop\fP|\fBhop\-by\-hop\fP
Hop-by-Hop Options header
.TP
\fBdst\fP
Destination Options header
.TP
\fBroute\fP
Routin header
.TP
\fBfrag\fP
Fragment header
.TP
\fBauth\fP
Authentication header
.TP
\fBesp\fP
Encapsulatin Securitizzle Payload header
.TP
\fBnone\fP
No Next header which matches 59 up in tha 'Next Header field' of IPv6 header or
any IPv6 extension headers
.TP
\fBproto\fP
which matches any upper layer protocol header n' shiznit fo' realz. A protocol name from
/etc/protocols n' numeric value also allowed. Y'all KNOW dat shit, muthafucka! Da number 255 is equivalent to
\fBproto\fP.
.SS ipvs
Match IPVS connection properties.
.TP
[\fB!\fP] \fB\-\-ipvs\fP
packet belongs ta a IPVS connection
.TP
Any of tha followin options implies \-\-ipvs (even negated)
.TP
[\fB!\fP] \fB\-\-vproto\fP \fIprotocol\fP
VIP protocol ta match; by number or name, e.g. "tcp"
.TP
[\fB!\fP] \fB\-\-vaddr\fP \fIaddress\fP[\fB/\fP\fImask\fP]
VIP address ta match
.TP
[\fB!\fP] \fB\-\-vport\fP \fIport\fP
VIP port ta match; by number or name, e.g. "http"
.TP
\fB\-\-vdir\fP {\fBORIGINAL\fP|\fBREPLY\fP}
flow direction of packet
.TP
[\fB!\fP] \fB\-\-vmethod\fP {\fBGATE\fP|\fBIPIP\fP|\fBMASQ\fP}
IPVS forwardin method used
.TP
[\fB!\fP] \fB\-\-vportctl\fP \fIport\fP
VIP port of tha controllin connection ta match, e.g. 21 fo' FTP
.SS length
This module matches tha length of tha layer-3 payload (e.g. layer-4 packet)
of a packet against a specific value
or range of joints.
.TP
[\fB!\fP] \fB\-\-length\fP \fIlength\fP[\fB:\fP\fIlength\fP]
.SS limit
This module matches at a limited rate rockin a token bucket filter.
A rule rockin dis extension will match until dis limit is reached.
It can be used up in combination wit the
.B LOG
target ta give limited logging, fo' example.
.PP
xt_limit has no negation support - yo big-ass booty is ghon gotta use \-m hashlimit !
\-\-hashlimit \fIrate\fP up in dis case whilst omittin \-\-hashlimit\-mode.
.TP
\fB\-\-limit\fP \fIrate\fP[\fB/second\fP|\fB/minute\fP|\fB/hour\fP|\fB/day\fP]
Maximum average matchin rate: specified as a number, wit a optional
`/second', `/minute', `/hour', or `/day' suffix; tha default is
3/hour.
.TP
\fB\-\-limit\-burst\fP \fInumber\fP
Maximum initial number of packets ta match: dis number gets
recharged by one every last muthafuckin time tha limit specified above aint reached,
up ta dis number; tha default is 5.
.SS mac
.TP
[\fB!\fP] \fB\-\-mac\-source\fP \fIaddress\fP
Match source MAC address.  It must be of tha form XX:XX:XX:XX:XX:XX.
Note dat dis only make sense fo' packets comin from a Ethernet device
and enterin the
.BR PREROUTING ,
.B FORWARD
or
.B INPUT
chains.
.SS mark
This module matches tha netfilta mark field associated wit a packet
(which can be set rockin the
.B MARK
target below).
.TP
[\fB!\fP] \fB\-\-mark\fP \fIvalue\fP[\fB/\fP\fImask\fP]
Matches packets wit tha given unsigned mark value (if a \fImask\fP is
specified, dis is logically ANDed wit tha \fImask\fP before the
comparison).
.SS mh (IPv6-specific)
This extension is loaded if `\-\-protocol ipv6\-mh' or `\-\-protocol mh' is
specified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it serves up tha followin option:
.TP
[\fB!\fP] \fB\-\-mh\-type\fP \fItype\fP[\fB:\fP\fItype\fP]
This allows justification of tha Mobilitizzle Header(MH) type, which can be
a numeric MH
.IR type ,
.IR type
or one of tha MH type names shown by tha command
.nf
 ip6tablez \-p ipv6\-mh \-h
.fi
.SS multiport
This module matches a set of source or destination ports, n' you can put dat on yo' toast.  Up ta 15
ports can be specified. Y'all KNOW dat shit, muthafucka!  A port range (port:port) counts as two
ports, n' you can put dat on yo' toast.  It can only be used up in conjunction wit one of the
followin protocols:
\fBtcp\fP, \fBudp\fP, \fBudplite\fP, \fBdccp\fP n' \fBsctp\fP.
.TP
[\fB!\fP] \fB\-\-source\-ports\fP,\fB\-\-sports\fP \fIport\fP[\fB,\fP\fIport\fP|\fB,\fP\fIport\fP\fB:\fP\fIport\fP]...
Match if tha source port is one of tha given ports, n' you can put dat on yo' toast.  Da flag
\fB\-\-sports\fP
is a cold-ass lil convenient alias fo' dis option. I aint talkin' bout chicken n' gravy biatch. Multiple ports or port ranges are
separated rockin a cold-ass lil comma, n' a port range is specified rockin a cold-ass lil colon.
\fB53,1024:65535\fP would therefore match ports 53 n' all from 1024 through
65535.
.TP
[\fB!\fP] \fB\-\-destination\-ports\fP,\fB\-\-dports\fP \fIport\fP[\fB,\fP\fIport\fP|\fB,\fP\fIport\fP\fB:\fP\fIport\fP]...
Match if tha destination port is one of tha given ports, n' you can put dat on yo' toast.  Da flag
\fB\-\-dports\fP
is a cold-ass lil convenient alias fo' dis option.
.TP
[\fB!\fP] \fB\-\-ports\fP \fIport\fP[\fB,\fP\fIport\fP|\fB,\fP\fIport\fP\fB:\fP\fIport\fP]...
Match if either tha source or destination ports is equal ta one of
the given ports.
.SS nfacct
Da nfacct match serves up tha extended accountin infrastructure fo' iptables.
Yo ass gotta use dis match together wit tha standalone user-space utility
.B nfacct(8)
.PP
Da only option available fo' dis match is tha following:
.TP
\fB\-\-nfacct\-name\fP \fIname\fP
This allows you ta specify tha existin object name dat is ghon be use for
accountin tha traffic dat dis rule-set is matching.
.PP
To use dis extension, you gotta create a accountin object:
.IP
nfacct add http\-traffic
.PP
Then, you gotta attach it ta tha accountin object via iptables:
.IP
iptablez \-I INPUT \-p tcp \-\-shiznit 80 \-m nfacct \-\-nfacct\-name http\-traffic
.IP
iptablez \-I OUTPUT \-p tcp \-\-dport 80 \-m nfacct \-\-nfacct\-name http\-traffic
.PP
Then, you can check fo' tha amount of traffic dat tha rulez match:
.IP
nfacct git http\-traffic
.IP
{ pkts = 00000000000000000156, bytes = 00000000000000151786 } = http-traffic;
.PP
Yo ass can obtain
.B nfacct(8)
from http://www.netfilter.org or, alternatively, from tha git.netfilter.org
repository.
.SS osf
Da osf module do passive operatin system fingerprinting. This modules
compares some data (Window Size, MSS, options n' they order, TTL, DF,
and others) from packets wit tha SYN bit set. 
.TP
[\fB!\fP] \fB\-\-genre\fP \fIstring\fP
Match a operatin system genre by rockin a passive fingerprinting.
.TP
\fB\-\-ttl\fP \fIlevel\fP
Do additionizzle TTL checks on tha packet ta determine tha operatin system.
\fIlevel\fP can be one of tha followin joints:
.IP \(bu 4
0 - True IP address n' fingerprint TTL comparison. I aint talkin' bout chicken n' gravy biatch. This generally works for
LANs.
.IP \(bu 4
1 - Peep if tha IP headerz TTL is less than tha fingerprint one. Works for
globally-routable addresses.
.IP \(bu 4
2 - Do not compare tha TTL at all.
.TP
\fB\-\-log\fP \fIlevel\fP
Log determined genres tha fuck into dmesg even if they do not match tha desired one.
\fIlevel\fP can be one of tha followin joints:
.IP \(bu 4
0 - Log all matched or unknown signatures
.IP \(bu 4
1 - Log only tha straight-up original gangsta one
.IP \(bu 4
2 - Log all known matched signatures
.PP
Yo ass may find suttin' like dis up in syslog:
.PP
Windows [2000:SP3:Windows XP Pro SP1, 2000 SP3]: 11.22.33.55:4024 ->
11.22.33.44:139 hops=3 Linux [2.5-2.6:] : 1.2.3.4:42624 -> 1.2.3.5:22 hops=4
.PP
OS fingerprints is loadable rockin tha \fBnfnl_osf\fP program. To load
fingerprints from a gangbangin' file, use:
.PP
\fBnfnl_osf -f /usr/share/xtables/pf.os\fP
.PP
To remove dem again,
.PP
\fBnfnl_osf -f /usr/share/xtables/pf.os -d\fP
.PP
Da fingerprint database can be downlaoded from
http://www.openbsd.org/cgi-bin/cvsweb/src/etc/pf.os .
.SS baller
This module attempts ta match various characteristics of tha packet creator,
for locally generated packets, n' you can put dat on yo' toast. This match is only valid up in tha OUTPUT and
POSTROUTING chains. Forwarded packets aint gots any socket associated with
them. Packets from kernel threadz do gotz a socket yo, but probably no baller.
.TP
[\fB!\fP] \fB\-\-uid\-baller\fP \fIusername\fP
.TP
[\fB!\fP] \fB\-\-uid\-baller\fP \fIuserid\fP[\fB\-\fP\fIuserid\fP]
Matches if tha packet socketz file structure (if it has one) is owned by the
given user n' shit. Yo ass may also specify a numerical UID, or a UID range.
.TP
[\fB!\fP] \fB\-\-gid\-baller\fP \fIgroupname\fP
.TP
[\fB!\fP] \fB\-\-gid\-baller\fP \fIgroupid\fP[\fB\-\fP\fIgroupid\fP]
Matches if tha packet socketz file structure is owned by tha given group.
Yo ass may also specify a numerical GID, or a GID range.
.TP
[\fB!\fP] \fB\-\-socket\-exists\fP
Matches if tha packet be associated wit a socket.
.SS physdev
This module matches on tha bridge port input n' output devices enslaved
to a funky-ass bridge device. This module be a part of tha infrastructure dat enables
a transparent bridgin IP firewall n' is only useful fo' kernel versions
above version 2.5.44.
.TP
[\fB!\fP] \fB\-\-physdev\-in\fP \fIname\fP
Name of a funky-ass bridge port via which a packet is received (only for
packets enterin the
.BR INPUT ,
.B FORWARD
and
.B PREROUTING
chains). If tha intercourse name endz up in a "+", then any
interface which begins wit dis name will match. If tha packet didn't arrive
all up in a funky-ass bridge device, dis packet won't match dis option, unless '!' is used.
.TP
[\fB!\fP] \fB\-\-physdev\-out\fP \fIname\fP
Name of a funky-ass bridge port via which a packet is goin ta be busted (for packets
enterin the
.BR FORWARD ,
.B OUTPUT
and
.B POSTROUTING
chains).  If tha intercourse name endz up in a "+", then any
interface which begins wit dis name will match. Note dat up in the
.BR nat " n' " mangle
.B OUTPUT
chains one cannot match on tha bridge output port, however one can up in the
.B "filta OUTPUT"
chain. I aint talkin' bout chicken n' gravy biatch. If tha packet won't leave by a funky-ass bridge thang or if it is yet unknown what
the output thang will be, then tha packet won't match dis option,
unless '!' is used.
.TP
[\fB!\fP] \fB\-\-physdev\-is\-in\fP
Matches if tha packet has entered all up in a funky-ass bridge intercourse.
.TP
[\fB!\fP] \fB\-\-physdev\-is\-out\fP
Matches if tha packet will leave all up in a funky-ass bridge intercourse.
.TP
[\fB!\fP] \fB\-\-physdev\-is\-bridged\fP
Matches if tha packet is bein bridged n' therefore aint bein routed.
This is only useful up in tha FORWARD n' POSTROUTING chains.
.SS pkttype
This module matches tha link-layer packet type.
.TP
[\fB!\fP] \fB\-\-pkt\-type\fP {\fBunicast\fP|\fBbroadcast\fP|\fBmulticast\fP}
.SS policy
This modulez matches tha policy used by IPsec fo' handlin a packet.
.TP
\fB\-\-dir\fP {\fBin\fP|\fBout\fP}
Used ta select whether ta match tha policy used fo' decapsulation or the
policy dat is ghon be used fo' encapsulation.
.B in
is valid up in the
.B PREROUTING, INPUT n' FORWARD
chains,
.B out
is valid up in the
.B POSTROUTING, OUTPUT n' FORWARD
chains.
.TP
\fB\-\-pol\fP {\fBnone\fP|\fBipsec\fP}
Matches if tha packet is subject ta IPsec processing. \fB\-\-pol none\fP
cannot be combined wit \fB\-\-strict\fP.
.TP
\fB\-\-strict\fP
Selects whether ta match tha exact policy or match if any rule of
the policy matches tha given policy.
.PP
For each policy element dat is ta be busted lyrics about, one can use one or mo' of
the followin options. When \fB\-\-strict\fP is up in effect, at least one must be
used per element.
.TP
[\fB!\fP] \fB\-\-reqid\fP \fIid\fP
Matches tha reqid of tha policy rule. Da reqid can be specified with
.B setkey(8)
using
.B unique:id
as level.
.TP
[\fB!\fP] \fB\-\-spi\fP \fIspi\fP
Matches tha SPI of tha SA.
.TP
[\fB!\fP] \fB\-\-proto\fP {\fBah\fP|\fBesp\fP|\fBipcomp\fP}
Matches tha encapsulation protocol.
.TP
[\fB!\fP] \fB\-\-mode\fP {\fBtunnel\fP|\fBtransport\fP}
Matches tha encapsulation mode.
.TP
[\fB!\fP] \fB\-\-tunnel\-src\fP \fIaddr\fP[\fB/\fP\fImask\fP]
Matches tha source end-point address of a tunnel mode SA.
Only valid wit \fB\-\-mode tunnel\fP.
.TP
[\fB!\fP] \fB\-\-tunnel\-dst\fP \fIaddr\fP[\fB/\fP\fImask\fP]
Matches tha destination end-point address of a tunnel mode SA.
Only valid wit \fB\-\-mode tunnel\fP.
.TP
\fB\-\-next\fP
Start tha next element up in tha policy justification. I aint talkin' bout chicken n' gravy biatch. Can only be used with
\fB\-\-strict\fP.
.SS quota
Implements network quotas by decrementin a funky-ass byte counta wit each
packet. Da condizzle matches until tha byte counta reaches zero. Behavior
is reversed wit negation (i.e. tha condizzle do not match until the
byte counta reaches zero).
.TP
[\fB!\fP] \fB\-\-quota\fP \fIbytes\fP
Da quota up in bytes.
.SS rateest
Da rate estimator can match on estimated rates as collected by tha RATEEST
target. Well shiiiit, it supports matchin on absolute bps/pps joints, comparin two rate
estimators n' matchin on tha difference between two rate estimators.
.PP
For a funky-ass betta understandin of tha available options, these is all possible
combinations:
.\" * Absolute:
.IP \(bu 4
\fBrateest\fP \fIoperator\fP \fBrateest-bps\fP
.IP \(bu 4
\fBrateest\fP \fIoperator\fP \fBrateest-pps\fP
.\" * Absolute + Delta:
.IP \(bu 4
(\fBrateest\fP minus \fBrateest-bps1\fP) \fIoperator\fP \fBrateest-bps2\fP
.IP \(bu 4
(\fBrateest\fP minus \fBrateest-pps1\fP) \fIoperator\fP \fBrateest-pps2\fP
.\" * Relative:
.IP \(bu 4
\fBrateest1\fP \fIoperator\fP \fBrateest2\fP \fBrateest-bps\fP(without rate!)
.IP \(bu 4
\fBrateest1\fP \fIoperator\fP \fBrateest2\fP \fBrateest-pps\fP(without rate!)
.\" * Relatizzle + Delta:
.IP \(bu 4
(\fBrateest1\fP minus \fBrateest-bps1\fP) \fIoperator\fP
(\fBrateest2\fP minus \fBrateest-bps2\fP)
.IP \(bu 4
(\fBrateest1\fP minus \fBrateest-pps1\fP) \fIoperator\fP
(\fBrateest2\fP minus \fBrateest-pps2\fP)
.TP
\fB\-\-rateest\-delta\fP
For each estimator (either absolute or relatizzle mode), calculate tha difference
between tha estimator-determined flow rate n' tha static value chosen wit the
BPS/PPS options. If tha flow rate is higher than tha specified BPS/PPS, 0 will
be used instead of a wack value. In other lyrics, "max(0, rateest#_rate -
rateest#_bps)" is used.
.TP
[\fB!\fP] \fB\-\-rateest\-lt\fP
Match if rate is less than given rate/estimator.
.TP
[\fB!\fP] \fB\-\-rateest\-gt\fP
Match if rate is pimped outa than given rate/estimator.
.TP
[\fB!\fP] \fB\-\-rateest\-eq\fP
Match if rate is equal ta given rate/estimator.
.PP
In tha so-called "absolute mode", only one rate estimator is used n' compared
against a static value, while up in "relatizzle mode", two rate estimators are
compared against another.
.TP
\fB\-\-rateest\fP \fIname\fP
Name of tha one rate estimator fo' absolute mode.
.TP
\fB\-\-rateest1\fP \fIname\fP
.TP
\fB\-\-rateest2\fP \fIname\fP
Da namez of tha two rate estimators fo' relatizzle mode.
.TP
\fB\-\-rateest\-bps\fP [\fIvalue\fP]
.TP
\fB\-\-rateest\-pps\fP [\fIvalue\fP]
.TP
\fB\-\-rateest\-bps1\fP [\fIvalue\fP]
.TP
\fB\-\-rateest\-bps2\fP [\fIvalue\fP]
.TP
\fB\-\-rateest\-pps1\fP [\fIvalue\fP]
.TP
\fB\-\-rateest\-pps2\fP [\fIvalue\fP]
Compare tha estimator(s) by bytes or packets per second, n' compare against
the chosen value. Right back up in yo muthafuckin ass. See tha above cap list fo' which option is ta be used in
which case fo' realz. A unit suffix may be used - available ones are: bit, [kmgt]bit,
[KMGT]ibit, Bps, [KMGT]Bps, [KMGT]iBps.
.PP
Example: This is what tha fuck can be used ta route outgoin data connections from an
FTP server over two lines based on tha available bandwidth all up in tha time tha data
connection was started:
.PP
# Estimate outgoin rates
.PP
iptablez \-t mangle \-A POSTROUTING \-o eth0 \-j RATEEST \-\-rateest\-name eth0
\-\-rateest\-interval 250ms \-\-rateest\-ewma 0.5s
.PP
iptablez \-t mangle \-A POSTROUTING \-o ppp0 \-j RATEEST \-\-rateest\-name ppp0
\-\-rateest\-interval 250ms \-\-rateest\-ewma 0.5s
.PP
# Mark based on available bandwidth
.PP
iptablez \-t mangle \-A balizzle \-m conntrack \-\-ctstate NEW \-m helper \-\-helper ftp
\-m rateest \-\-rateest\-delta \-\-rateest1 eth0 \-\-rateest\-bps1 2.5mbit \-\-rateest\-gt
\-\-rateest2 ppp0 \-\-rateest\-bps2 2mbit \-j CONNMARK \-\-set\-mark 1
.PP
iptablez \-t mangle \-A balizzle \-m conntrack \-\-ctstate NEW \-m helper \-\-helper ftp
\-m rateest \-\-rateest\-delta \-\-rateest1 ppp0 \-\-rateest\-bps1 2mbit \-\-rateest\-gt
\-\-rateest2 eth0 \-\-rateest\-bps2 2.5mbit \-j CONNMARK \-\-set\-mark 2
.PP
iptablez \-t mangle \-A balizzle \-j CONNMARK \-\-restore\-mark
.SS realm (IPv4-specific)
This matches tha routin realm.  Routin realms is used up in complex routing
setups involvin dynamic routin protocols like BGP.
.TP
[\fB!\fP] \fB\-\-realm\fP \fIvalue\fP[\fB/\fP\fImask\fP]
Matches a given realm number (and optionally mask). If not a number, value
can be a named realm from /etc/iproute2/rt_realms (mask can not be used in
that case).
.SS recent
Allows you ta dynamically create a list of IP addresses n' then match against
that list up in all dem different ways.
.PP
For example, you can create a "badguy" list outta playas attemptin ta connect
to port 139 on yo' firewall n' then DROP all future packets from dem without
thankin bout em.
.PP
\fB\-\-set\fP, \fB\-\-rcheck\fP, \fB\-\-update\fP n' \fB\-\-remove\fP are
mutually exclusive.
.TP
\fB\-\-name\fP \fIname\fP
Specify tha list ta use fo' tha commands. If no name is given then
\fBDEFAULT\fP is ghon be used.
.TP
[\fB!\fP] \fB\-\-set\fP
This will add tha source address of tha packet ta tha list. If tha source
address be already up in tha list, dis will update tha existin entry. This will
always return success (or failure if \fB!\fP is passed in).
.TP
\fB\-\-rsource\fP
Match/save tha source address of each packet up in tha recent list table. This
is tha default.
.TP
\fB\-\-rdest\fP
Match/save tha destination address of each packet up in tha recent list table.
.TP
\fB\-\-mask\fP \fInetmask\fP
Netmask dat is ghon be applied ta dis recent list.
.TP
[\fB!\fP] \fB\-\-rcheck\fP
Peep if tha source address of tha packet is currently up in tha list.
.TP
[\fB!\fP] \fB\-\-update\fP
Like \fB\-\-rcheck\fP, except it will update tha "last seen" timestamp if it
matches.
.TP
[\fB!\fP] \fB\-\-remove\fP
Peep if tha source address of tha packet is currently up in tha list n' if so
that address is ghon be removed from tha list n' tha rule will return true. If
the address aint found, false is returned.
.TP
\fB\-\-seconds\fP \fIseconds\fP
This option must be used up in conjunction wit one of \fB\-\-rcheck\fP or
\fB\-\-update\fP. When used, dis will narrow tha match ta only happen when the
address is up in tha list n' was peeped within tha last given number of seconds.
.TP
\fB\-\-reap\fP
This option can only be used up in conjunction wit \fB\-\-seconds\fP.
When used, dis will cause entries olda than tha last given number of seconds
to be purged.
.TP
\fB\-\-hitcount\fP \fIhits\fP
This option must be used up in conjunction wit one of \fB\-\-rcheck\fP or
\fB\-\-update\fP. When used, dis will narrow tha match ta only happen when the
address is up in tha list n' packets had been received pimped outa than or equal to
the given value. This option may be used along wit \fB\-\-seconds\fP ta create
an even narrower match requirin a cold-ass lil certain number of hits within a specific
time frame. Da maximum value fo' tha hitcount parameta is given by the
"ip_pkt_list_tot" parameta of tha xt_recent kernel module. Exceedin this
value on tha command line will cause tha rule ta be rejected.
.TP
\fB\-\-rttl\fP
This option may only be used up in conjunction wit one of \fB\-\-rcheck\fP or
\fB\-\-update\fP. When used, dis will narrow tha match ta only happen when the
address is up in tha list n' tha TTL of tha current packet matches dat of the
packet which hit tha \fB\-\-set\fP rule. This may be useful if you have problems
with playas fakin they source address up in order ta DoS you via dis module by
disallowin others access ta yo' joint by bustin  bogus packets ta yo thugged-out ass.
.PP
Examples:
.IP
iptablez \-A FORWARD \-m recent \-\-name badguy \-\-rcheck \-\-secondz 60 \-j DROP
.IP
iptablez \-A FORWARD \-p tcp \-i eth0 \-\-dport 139 \-m recent \-\-name badguy \-\-set \-j DROP
.PP
Stevez ipt_recent joint (http://snowman.net/projects/ipt_recent/) also has
some examplez of usage.
.PP
\fB/proc/net/xt_recent/*\fP is tha current listz of addresses n' shiznit
about each entry of each list.
.PP
Each file up in \fB/proc/net/xt_recent/\fP can be read from ta peep tha current
list or freestyled two rockin tha followin commandz ta modify tha list:
.TP
\fBecho +\fP\fIaddr\fP\fB >/proc/net/xt_recent/DEFAULT\fP
to add \fIaddr\fP ta tha DEFAULT list
.TP
\fBecho \-\fP\fIaddr\fP\fB >/proc/net/xt_recent/DEFAULT\fP
to remove \fIaddr\fP from tha DEFAULT list
.TP
\fBecho / >/proc/net/xt_recent/DEFAULT\fP
to flush tha DEFAULT list (remove all entries).
.PP
Da module itself accepts parameters, defaults shown:
.TP
\fBip_list_tot\fP=\fI100\fP
Number of addresses remembered per table.
.TP
\fBip_pkt_list_tot\fP=\fI20\fP
Number of packets per address remembered.
.TP
\fBip_list_hash_size\fP=\fI0\fP
Hash table size. 0 means ta calculate it based on ip_list_tot, default: 512.
.TP
\fBip_list_perms\fP=\fI0644\fP
Permissions fo' /proc/net/xt_recent/* files.
.TP
\fBip_list_uid\fP=\fI0\fP
Numerical UID fo' ballershizzle of /proc/net/xt_recent/* files.
.TP
\fBip_list_gid\fP=\fI0\fP
Numerical GID fo' ballershizzle of /proc/net/xt_recent/* files.
.SS rpfilter
Performs a reverse path filta test on a packet.
If a reply ta tha packet would be busted via tha same intercourse
that tha packet arrived on, tha packet will match.
Note that, unlike tha in-kernel rp_filter, packets protected
by IPSec is not treated specially.  Combine dis match with
the policy match if you want all dis bullshit.
Also, packets arrivin via tha loopback intercourse is always permitted.
This match can only be used up in tha PREROUTING chain of tha raw or mangle table.
.TP
\fB\-\-loose\fP
Used ta specifiy dat tha reverse path filta test should match
even if tha selected output thang aint tha expected one.
.TP
\fB\-\-validmark\fP
Also use tha packets' nfmark value when struttin tha reverse path route lookup.
.TP
\fB\-\-accept\-local\fP
This will permit packets arrivin from tha network wit a source address dat be also
assigned ta tha local machine.
.TP
\fB\-\-invert\fP
This will invert tha sense of tha match.  Instead of matchin packets dat passed the
reverse path filta test, match dem dat have failed dat shit.
.PP
Example ta log n' drop packets failin tha reverse path filta test:

iptablez \-t raw \-N RPFILTER

iptablez \-t raw \-A RPFILTER \-m rpfilta \-j RETURN

iptablez \-t raw \-A RPFILTER \-m limit \-\-limit 10/minute \-j NFLOG \-\-nflog\-prefix "rpfilta drop"

iptablez \-t raw \-A RPFILTER \-j DROP

iptablez \-t raw \-A PREROUTING \-j RPFILTER

Example ta drop failed packets, without logging:

iptablez \-t raw \-A RPFILTER \-m rpfilta \-\-invert \-j DROP
.SS rt (IPv6-specific)
Match on IPv6 routin header
.TP
[\fB!\fP] \fB\-\-rt\-type\fP \fItype\fP
Match tha type (numeric).
.TP
[\fB!\fP] \fB\-\-rt\-segsleft\fP \fInum\fP[\fB:\fP\fInum\fP]
Match tha `segments left' field (range).
.TP
[\fB!\fP] \fB\-\-rt\-len\fP \fIlength\fP
Match tha length of dis header.
.TP
\fB\-\-rt\-0\-res\fP
Match tha reserved field, too (type=0)
.TP
\fB\-\-rt\-0\-addrs\fP \fIaddr\fP[\fB,\fP\fIaddr\fP...]
Match type=0 addresses (list).
.TP
\fB\-\-rt\-0\-not\-strict\fP
List of type=0 addresses aint a strict list.
.SS sctp
.TP
[\fB!\fP] \fB\-\-source\-port\fP,\fB\-\-sport\fP \fIport\fP[\fB:\fP\fIport\fP]
.TP
[\fB!\fP] \fB\-\-destination\-port\fP,\fB\-\-dport\fP \fIport\fP[\fB:\fP\fIport\fP]
.TP
[\fB!\fP] \fB\-\-chunk\-types\fP {\fBall\fP|\fBany\fP|\fBonly\fP} \fIchunktype\fP[\fB:\fP\fIflags\fP] [...]
Da flag letta up in upper case indicates dat tha flag is ta match if set,
in tha lower case indicates ta match if unset.

Chunk types: DATA INIT INIT_ACK SACK HEARTBEAT HEARTBEAT_ACK ABORT SHUTDOWN SHUTDOWN_ACK ERROR COOKIE_ECHO COOKIE_ACK ECN_ECNE ECN_CWR SHUTDOWN_COMPLETE ASCONF ASCONF_ACK FORWARD_TSN

chunk type            available flags      
.br
DATA                  I U B E i u b e
.br
ABORT                 T t                 
.br
SHUTDOWN_COMPLETE     T t                 

(lowercase means flag should be "off", uppercase means "on")
.P
Examples:

iptablez \-A INPUT \-p sctp \-\-dport 80 \-j DROP

iptablez \-A INPUT \-p sctp \-\-chunk\-types any DATA,INIT \-j DROP

iptablez \-A INPUT \-p sctp \-\-chunk\-types any DATA:Be \-j ACCEPT
.SS set
This module matches IP sets which can be defined by ipset(8).
.TP
[\fB!\fP] \fB\-\-match\-set\fP \fIsetname\fP \fIflag\fP[\fB,\fP\fIflag\fP]...
where flags is tha comma separated list of
.BR "src"
and/or
.BR "dst" 
specifications n' there can be no mo' than six of em yo. Hence tha command
.IP
 iptablez \-A FORWARD \-m set \-\-match\-set test src,dst
.IP
will match packets, fo' which (if tha set type is ipportmap) tha source
address n' destination port pair can be found up in tha specified set. If
the set type of tha specified set is single dimension (for example ipmap),
then tha command will match packets fo' which tha source address can be
found up in tha specified set. 
.TP
\fB\-\-return\-\-nomatch\fP
If tha \fB\-\-return\-\-nomatch\fP option is specified n' tha set type
supports tha \fBnomatch\fP flag, then tha matchin is reversed: a match
with a element flagged wit \fBnomatch\fP returns \fBtrue\fP, while a
match wit a plain element returns \fBfalse\fP.
.PP
Da option \fB\-\-match\-set\fP can be replaced by \fB\-\-set\fP if dat do 
not clash wit a option of other extensions.
.PP
Use of -m set requires dat ipset kernel support is provided, which, for
standard kernels, is tha case since Linux 2.6.39.
.SS socket
This matches if a open socket can be found by bustin a socket lookup on the
packet.
.TP
\fB\-\-transparent\fP
Ignore non-transparent sockets.
.SS state
Da "state" extension be a subset of tha "conntrack" module.
"state" allows access ta tha connection trackin state fo' dis packet.
.TP
[\fB!\fP] \fB\-\-state\fP \fIstate\fP
Where state be a cold-ass lil comma separated list of tha connection states ta match. Only a
subset of tha states unterstood by "conntrack" is recognized: \fBINVALID\fP,
\fBESTABLISHED\fP, \fBNEW\fP, \fBRELATED\fP or \fBUNTRACKED\fP. For their
description, peep tha "conntrack" headin up in dis manpage.
.SS statistic
This module matches packets based on some statistic condition.
It supports two distinct modes settable wit tha 
\fB\-\-mode\fP
option.
.PP
Supported options:
.TP
\fB\-\-mode\fP \fImode\fP
Set tha matchin mode of tha matchin rule, supported modes are
.B random
and
.B nth. 
.TP
[\fB!\fP] \fB\-\-probability\fP \fIp\fP
Set tha probabilitizzle fo' a packet ta be randomly matched. Y'all KNOW dat shit, muthafucka! Well shiiiit, it only works wit the
\fBrandom\fP mode. \fIp\fP must be within 0.0 n' 1.0. Da supported
granularitizzle is up in 1/2147483648th increments.
.TP
[\fB!\fP] \fB\-\-every\fP \fIn\fP
Match one packet every last muthafuckin nth packet. Well shiiiit, it works only wit the
.B nth
mode (see also tha 
\fB\-\-packet\fP
option).
.TP
\fB\-\-packet\fP \fIp\fP
Set tha initial counta value (0 <= p <= n\-1, default 0) fo' the
.B nth 
mode.
.SS string
This modulez matches a given strang by rockin some pattern matchin game. Well shiiiit, it requires a linux kernel >= 2.6.14.
.TP
\fB\-\-algo\fP {\fBbm\fP|\fBkmp\fP}
Select tha pattern matchin game. (bm = Boyer-Moore, kmp = Knuth-Pratt-Morris)
.TP
\fB\-\-from\fP \fIoffset\fP
Set tha offset from which it starts lookin fo' any matching. If not passed, default is 0.
.TP
\fB\-\-to\fP \fIoffset\fP
Set tha offset up ta which should be scanned. Y'all KNOW dat shit, muthafucka! That is, byte \fIoffset\fP-1
(countin from 0) is tha last one dat is scanned.
If not passed, default is tha packet size.
.TP
[\fB!\fP] \fB\-\-string\fP \fIpattern\fP
Matches tha given pattern.
.TP
[\fB!\fP] \fB\-\-hex\-string\fP \fIpattern\fP
Matches tha given pattern up in hex notation.
.SS tcp
These extensions can be used if `\-\-protocol tcp' is specified. Y'all KNOW dat shit, muthafucka! It
provides tha followin options:
.TP
[\fB!\fP] \fB\-\-source\-port\fP,\fB\-\-sport\fP \fIport\fP[\fB:\fP\fIport\fP]
Source port or port range justification. I aint talkin' bout chicken n' gravy biatch. This can either be a service
name or a port number n' shiznit fo' realz. An inclusive range can also be specified,
usin tha format \fIfirst\fP\fB:\fP\fIlast\fP.
If tha straight-up original gangsta port is omitted, "0" be assumed; if tha last is omitted,
"65535" be assumed.
If tha straight-up original gangsta port is pimped outa than tha second one they is ghon be swapped.
Da flag
\fB\-\-sport\fP
is a cold-ass lil convenient alias fo' dis option.
.TP
[\fB!\fP] \fB\-\-destination\-port\fP,\fB\-\-dport\fP \fIport\fP[\fB:\fP\fIport\fP]
Destination port or port range justification. I aint talkin' bout chicken n' gravy biatch.  Da flag
\fB\-\-dport\fP
is a cold-ass lil convenient alias fo' dis option.
.TP
[\fB!\fP] \fB\-\-tcp\-flags\fP \fImask\fP \fIcomp\fP
Match when tha TCP flags is as specified. Y'all KNOW dat shit, muthafucka!  Da first argument \fImask\fP is the
flags which we should examine, freestyled as a cold-ass lil comma-separated list, and
the second argument \fIcomp\fP be a cold-ass lil comma-separated list of flags which must be
set.  Flags are:
.BR "SYN ACK FIN RST URG PSH ALL NONE" .
Hence tha command
.nf
 iptablez \-A FORWARD \-p tcp \-\-tcp\-flags SYN,ACK,FIN,RST SYN
.fi
will only match packets wit tha SYN flag set, n' tha ACK, FIN and
RST flags unset.
.TP
[\fB!\fP] \fB\-\-syn\fP
Only match TCP packets wit tha SYN bit set n' tha ACK,RST n' FIN bits
cleared. Y'all KNOW dat shit, muthafucka!  Such packets is used ta request TCP connection initiation;
for example, blockin such packets comin up in a intercourse will prevent
incomin TCP connections yo, but outgoin TCP connections will be
unaffected.
It be equivalent ta \fB\-\-tcp\-flags SYN,RST,ACK,FIN SYN\fP.
If tha "!" flag precedes tha "\-\-syn", tha sense of the
option is inverted.
.TP
[\fB!\fP] \fB\-\-tcp\-option\fP \fInumber\fP
Match if TCP option set.
.SS tcpmss
This matches tha TCP MSS (maximum segment size) field of tha TCP header n' shit.  Yo ass can only use dis on TCP SYN or SYN/ACK packets, since tha MSS is only negotiated durin tha TCP handshake at connection startup time.
.TP
[\fB!\fP] \fB\-\-mss\fP \fIvalue\fP[\fB:\fP\fIvalue\fP]
Match a given TCP MSS value or range.
.SS time
This matches if tha packet arrival time/date is within a given range fo' realz. All
options is optionizzle yo, but is ANDed when specified. Y'all KNOW dat shit, muthafucka! All times is interpreted
as UTC by default.
.TP
\fB\-\-datestart\fP \fIYYYY\fP[\fB\-\fP\fIMM\fP[\fB\-\fP\fIDD\fP[\fBT\fP\fIhh\fP[\fB:\fP\fImm\fP[\fB:\fP\fIss\fP]]]]]
.TP
\fB\-\-datestop\fP \fIYYYY\fP[\fB\-\fP\fIMM\fP[\fB\-\fP\fIDD\fP[\fBT\fP\fIhh\fP[\fB:\fP\fImm\fP[\fB:\fP\fIss\fP]]]]]
Only match durin tha given time, which must be up in ISO 8601 "T" notation.
Da possible time range is 1970-01-01T00:00:00 ta 2038-01-19T04:17:07.
.IP
If \-\-datestart or \-\-datestop is not specified, it will default ta 1970-01-01
and 2038-01-19, respectively.
.TP
\fB\-\-timestart\fP \fIhh\fP\fB:\fP\fImm\fP[\fB:\fP\fIss\fP]
.TP
\fB\-\-timestop\fP \fIhh\fP\fB:\fP\fImm\fP[\fB:\fP\fIss\fP]
Only match durin tha given daytime. Da possible time range is 00:00:00 to
23:59:59. Leadin zeroes is allowed (e.g. "06:03") n' erectly interpreted
as base-10.
.TP
[\fB!\fP] \fB\-\-monthdays\fP \fIday\fP[\fB,\fP\fIday\fP...]
Only match on tha given minutez of tha month. Possible joints is \fB1\fP
to \fB31\fP. Note dat specifyin \fB31\fP will of course not match
on months which aint gots a 31st day; tha same goes fo' 28- or 29-day
February.
.TP
[\fB!\fP] \fB\-\-weekdays\fP \fIday\fP[\fB,\fP\fIday\fP...]
Only match on tha given weekdays. Possible joints is \fBMon\fP, \fBTue\fP,
\fBWed\fP, \fBThu\fP, \fBFri\fP, \fBSat\fP, \fBSun\fP, or joints from \fB1\fP
to \fB7\fP, respectively. Yo ass may also use two-characta variants (\fBMo\fP,
\fBTu\fP, etc.).
.TP
\fB\-\-contiguous\fP
When \fB\-\-timestop\fP is smalla than \fB\-\-timestart\fP value, match
this as a single time period instead distinct intervals.  See EXAMPLES.
.TP
\fB\-\-kerneltz\fP
Use tha kernel timezone instead of UTC ta determine whether a packet meets the
time regulations.
.PP
Bout kernel timezones: Linux keeps tha system time up in UTC, n' always do so.
On boot, system time is initialized from a referential time source. Where this
time source has no timezone shiznit, like fuckin tha x86 CMOS RTC, UTC will be
assumed. Y'all KNOW dat shit, muthafucka! If tha time source is however not up in UTC, userspace should provide the
correct system time n' timezone ta tha kernel once it has tha shiznit.
.PP
Local time be a gangbangin' feature on top of tha (timezone independent) system time. Each
process has its own scam of local time, specified via tha TZ environment
variable. Da kernel also has its own timezone offset variable. Da TZ
userspace environment variable specifies how tha fuck tha UTC-based system time is
displayed, e.g. when you run date(1), or what tha fuck you peep on yo' desktop clock.
Da TZ strang may resolve ta different offsets at different dates, which is
what enablez tha automatic time-jumpin up in userspace. when DST chizzles. The
kernelz timezone offset variable is used when it has ta convert between
non-UTC sources, like fuckin FAT filesystems, ta UTC (since tha latta is what tha fuck the
rest of tha system uses).
.PP
Da caveat wit tha kernel timezone is dat Linux distributions may ignore to
set tha kernel timezone, n' instead only set tha system time. Even if a
particular distribution do set tha timezone at boot, it is probably do not
keep tha kernel timezone offset - which is what tha fuck chizzlez on DST - up ta date.
ntpd aint gonna bust a nut on tha kernel timezone, so hustlin it aint gonna resolve the
issue fo' realz. As such, one may encounta a timezone dat be always +0000, or one that
is wack half of tha time of tha year fo' realz. As such, \fBusin \-\-kerneltz is highly
discouraged.\fP
.PP
EXAMPLES. To match on weekends, use:
.IP
\-m time \-\-weekdays Sa,Su
.PP
Or, ta match (once) on a nationistic holidizzle block:
.IP
\-m time \-\-datestart 2007\-12\-24 \-\-datestop 2007\-12\-27
.PP
Since tha stop time is straight-up inclusive, you would need tha followin stop
time ta not match tha straight-up original gangsta second of tha freshly smoked up day:
.IP
\-m time \-\-datestart 2007\-01\-01T17:00 \-\-datestop 2007\-01\-01T23:59:59
.PP
Durin lunch hour:
.IP
\-m time \-\-timestart 12:30 \-\-timestop 13:30
.PP
Da fourth Fridizzle up in tha month:
.IP
\-m time \-\-weekdays Fr \-\-monthdays 22,23,24,25,26,27,28
.PP
(Note dat dis exploits a cold-ass lil certain mathematical property. Well shiiiit, it aint possible to
say "fourth Thursdizzle OR fourth Friday" up in one rule. Well shiiiit, it is possible with
multiple rules, though.)
.PP
Matchin across minutes might not do what tha fuck is expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For instance,
.IP
\-m time \-\-weekdays Mo \-\-timestart 23:00  \-\-timestop 01:00
Will match Monday, fo' one minute from midnight ta 1 a.m., n' then
again fo' another minute from 23:00 onwards.  If dis is unwanted, e.g. if you
wanna 'match fo' two minutes from Montay 23:00 onwards' you need ta also specify
the \-\-contiguous option up in tha example above.
.SS tos
This module matches tha 8-bit Type of Service field up in tha IPv4 header (i.e.
includin tha "Precedence" bits) or tha (also 8-bit) Prioritizzle field up in tha IPv6
header.
.TP
[\fB!\fP] \fB\-\-tos\fP \fIvalue\fP[\fB/\fP\fImask\fP]
Matches packets wit tha given TOS mark value. If a mask is specified, it is
logically ANDed wit tha TOS mark before tha comparison.
.TP
[\fB!\fP] \fB\-\-tos\fP \fIsymbol\fP
Yo ass can specify a symbolic name when rockin tha tos match fo' IPv4. Da list of
recognized TOS names can be obtained by callin iptablez wit \fB\-m tos \-h\fP.
Note dat dis implies a mask of 0x3F, i.e. all but tha ECN bits.
.SS ttl (IPv4-specific)
This module matches tha time ta live field up in tha IP header.
.TP
[\fB!\fP] \fB\-\-ttl\-eq\fP \fIttl\fP
Matches tha given TTL value.
.TP
\fB\-\-ttl\-gt\fP \fIttl\fP
Matches if TTL is pimped outa than tha given TTL value.
.TP
\fB\-\-ttl\-lt\fP \fIttl\fP
Matches if TTL is less than tha given TTL value.
.SS u32
U32 tests whether quantitizzlez of up ta 4 bytes extracted from a packet have
specified joints, n' you can put dat on yo' toast. Da justification of what tha fuck ta extract is general enough to
find data at given offsets from tcp headaz or payloads.
.TP
[\fB!\fP] \fB\-\-u32\fP \fItests\fP
Da argument amounts ta a program up in a lil' small-ass language busted lyrics bout below.
.IP
tests := location "=" value | tests "&&" location "=" value
.IP
value := range | value "," range
.IP
range := number | number ":" number
.PP
a single number, \fIn\fP, is interpreted tha same as \fIn:n\fP. \fIn:m\fP is
interpreted as tha range of numbers \fB>=n\fP n' \fB<=m\fP.
.IP "" 4
location := number | location operator number
.IP "" 4
operator := "&" | "<<" | ">>" | "@"
.PP
Da operators \fB&\fP, \fB<<\fP, \fB>>\fP n' \fB&&\fP mean tha same as up in C.
Da \fB=\fP is straight-up a set membershizzle operator n' tha value syntax raps about
a set. Da \fB@\fP operator is what tha fuck allows movin ta tha next header n' is
busted lyrics bout further below.
.PP
There is currently some artificial implementation limits on tha size of the
tests:
.IP "    *"
no mo' than 10 of "\fB=\fP" (and 9 "\fB&&\fP"s) up in tha u32 argument
.IP "    *"
no mo' than 10 ranges (and 9 commas) per value
.IP "    *"
no mo' than 10 numbers (and 9 operators) per location
.PP
To describe tha meanin of location, imagine tha followin machine that
interprets dat shit. There is three registers:
.IP
A iz of type \fBchar *\fP, initially tha address of tha IP header
.IP
B n' C is unsigned 32 bit integers, initially zero
.PP
Da instructions are:
.IP
number B = number;
.IP
C = (*(A+B)<<24) + (*(A+B+1)<<16) + (*(A+B+2)<<8) + *(A+B+3)
.IP
&number C = C & number
.IP
<< number C = C << number
.IP
>> number C = C >> number
.IP
@number A = A + C; then do tha instruction number
.PP
Any access of memory outside [skb\->data,skb\->end] causes tha match ta fail.
Otherwise tha result of tha computation is tha final value of C.
.PP
Whitespace be allowed but not required up in tha tests, n' you can put dat on yo' toast. But fuck dat shiznit yo, tha word on tha street is dat tha characters
that do occur there be likely ta require shell quoting, so it aint nuthin but a phat idea
to enclose tha arguments up in quotes.
.PP
Example:
.IP
match IP packets wit total length >= 256
.IP
Da IP header gotz nuff a total length field up in bytes 2-3.
.IP
\-\-u32 "\fB0 & 0xFFFF = 0x100:0xFFFF\fP"
.IP
read bytes 0-3
.IP
AND dat wit 0xFFFF (givin bytes 2-3), n' test whether dat is up in tha range
[0x100:0xFFFF]
.PP
Example: (more realistic, hence mo' fucked up)
.IP
match ICMP packets wit icmp type 0
.IP
First test dat it be a ICMP packet, legit iff byte 9 (protocol) = 1
.IP
\-\-u32 "\fB6 & 0xFF = 1 &&\fP ...
.IP
read bytes 6-9, use \fB&\fP ta throw away bytes 6-8 n' compare tha result to
1. Next test dat it aint a gangbangin' fragment. (If so, it might be part of such a
packet but we cannot always tell.) N.B.: This test is generally needed if you
wanna match anythang beyond tha IP header n' shit. Da last 6 bitz of byte 6 n' all
of byte 7 is 0 iff dis be a cold-ass lil complete packet (not a gangbangin' fragment) fo' realz. Alternatively,
you can allow first fragments by only testin tha last 5 bitz of byte 6.
.IP
 ... \fB4 & 0x3FFF = 0 &&\fP ...
.IP
Last test: tha straight-up original gangsta byte past tha IP header (the type) is 0. This is where we
have ta use tha @syntax. Da length of tha IP header (IHL) up in 32 bit lyrics is
stored up in tha right half of byte 0 of tha IP header itself.
.IP
 ... \fB0 >> 22 & 0x3C @ 0 >> 24 = 0\fP"
.IP
Da first 0 means read bytes 0-3, \fB>>22\fP means shift dat 22 bits ta the
right. Right back up in yo muthafuckin ass. Shiftin 24 bits would give tha straight-up original gangsta byte, so only 22 bits is four
times dat plus all dem mo' bits, n' you can put dat on yo' toast. \fB&3C\fP then eliminates tha two extra bits
on tha right n' tha straight-up original gangsta four bitz of tha straight-up original gangsta byte. For instance, if IHL=5,
then tha IP header is 20 (4 x 5) bytes long. In dis case, bytes 0-1 is (in
binary) xxxx0101 yyzzzzzz, \fB>>22\fP gives tha 10 bit value xxxx0101yy and
\fB&3C\fP gives 010100. \fB@\fP means ta use dis number as a freshly smoked up offset into
the packet, n' read four bytes startin from there, so peek-a-boo, clear tha way, I be comin' thru fo'sho. This is tha straight-up original gangsta 4 bytes
of tha ICMP payload, of which byte 0 is tha ICMP type. Therefore, we simply
shift tha value 24 ta tha right ta throw up all but tha straight-up original gangsta byte n' compare
the result wit 0.
.PP
Example:
.IP
TCP payload bytes 8-12 be any of 1, 2, 5 or 8
.IP
First we test dat tha packet be a tcp packet (similar ta ICMP).
.IP
\-\-u32 "\fB6 & 0xFF = 6 &&\fP ...
.IP
Next, test dat it aint a gangbangin' fragment (same as above).
.IP
 ... \fB0 >> 22 & 0x3C @ 12 >> 26 & 0x3C @ 8 = 1,2,5,8\fP"
.IP
\fB0>>22&3C\fP as above computes tha number of bytes up in tha IP header n' shit. \fB@\fP
makes dis tha freshly smoked up offset tha fuck into tha packet, which is tha start of tha TCP
header n' shit. Da length of tha TCP header (again up in 32 bit lyrics) is tha left half
of byte 12 of tha TCP header n' shit. Da \fB12>>26&3C\fP computes dis length up in bytes
(similar ta tha IP header before). "@" make dis tha freshly smoked up offset, which is the
start of tha TCP payload. Y'all KNOW dat shit, muthafucka! Finally, 8 readz bytes 8-12 of tha payload and
\fB=\fP checks whether tha result be any of 1, 2, 5 or 8.
.SS udp
These extensions can be used if `\-\-protocol udp' is specified. Y'all KNOW dat shit, muthafucka! It
provides tha followin options:
.TP
[\fB!\fP] \fB\-\-source\-port\fP,\fB\-\-sport\fP \fIport\fP[\fB:\fP\fIport\fP]
Source port or port range justification.
See tha description of the
\fB\-\-source\-port\fP
option of tha TCP extension fo' details.
.TP
[\fB!\fP] \fB\-\-destination\-port\fP,\fB\-\-dport\fP \fIport\fP[\fB:\fP\fIport\fP]
Destination port or port range justification.
See tha description of the
\fB\-\-destination\-port\fP
option of tha TCP extension fo' details.
.SS unclean (IPv4-specific)
This module takes no options yo, but attempts ta match packets which seem
malformed or unusual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  This is regarded as experimental.
.SH TARGET EXTENSIONS
iptablez can use extended target modules: tha followin is included
in tha standard distribution.
.\" @TARGET@
.SS AUDIT
This target allows ta create audit recordz fo' packets hittin tha target.
It can be used ta record accepted, dropped, n' rejected packets, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See
auditd(8) fo' additionizzle details.
.TP
\fB\-\-type\fP {\fBaccept\fP|\fBdrop\fP|\fBreject\fP}
Set type of audit record.
.PP
Example:
.IP
iptablez \-N AUDIT_DROP
.IP
iptablez \-A AUDIT_DROP \-j AUDIT \-\-type drop
.IP
iptablez \-A AUDIT_DROP \-j DROP
.SS CHECKSUM
This target allows ta selectively work round broken/old applications.
It can only be used up in tha mangle table.
.TP
\fB\-\-checksum\-fill\fP
Compute n' fill up in tha checksum up in a packet dat lacks a cold-ass lil checksum.
This is particularly useful, if you need ta work round oldschool applications
like fuckin dhcp clients, dat do not work well wit checksum offloads,
but don't wanna disable checksum offload up in yo' device.
.SS CLASSIFY
This module allows you ta set tha skb\->prioritizzle value (and thus classify tha packet tha fuck into a specific CBQ class).
.TP
\fB\-\-set\-class\fP \fImajor\fP\fB:\fP\fIminor\fP
Set tha major n' minor class value. Da joints is always interpreted as
hexadecimal even if no 0x prefix is given.
.SS CLUSTERIP (IPv4-specific)
This module allows you ta configure a simple clusta of nodes dat share
a certain IP n' MAC address without a explicit load balancer up in front of
them.  Connections is statically distributed between tha nodes up in this
cluster.
.TP
\fB\-\-new\fP
Smoke a freshly smoked up ClusterIP.  Yo ass always gotta set dis on tha straight-up original gangsta rule
for a given ClusterIP.
.TP
\fB\-\-hashmode\fP \fImode\fP
Specify tha hashin mode.  Has ta be one of
\fBsourceip\fP, \fBsourceip\-sourceport\fP, \fBsourceip\-sourceport\-destport\fP.
.TP
\fB\-\-clustermac\fP \fImac\fP
Specify tha ClusterIP MAC address yo. Has ta be a link\-layer multicast address
.TP
\fB\-\-total\-nodes\fP \fInum\fP
Number of total nodes within dis cluster.
.TP
\fB\-\-local\-node\fP \fInum\fP
Local node number within dis cluster.
.TP
\fB\-\-hash\-init\fP \fIrnd\fP
Specify tha random seed used fo' hash initialization.
.SS CONNMARK
This module sets tha netfilta mark value associated wit a cold-ass lil connection. I aint talkin' bout chicken n' gravy biatch. The
mark is 32 bits wide.
.TP
\fB\-\-set\-xmark\fP \fIvalue\fP[\fB/\fP\fImask\fP]
Zero up tha bits given by \fImask\fP n' XOR \fIvalue\fP tha fuck into tha ctmark.
.TP
\fB\-\-save\-mark\fP [\fB\-\-nfmask\fP \fInfmask\fP] [\fB\-\-ctmask\fP \fIctmask\fP]
Copy tha packet mark (nfmark) ta tha connection mark (ctmark) rockin tha given
masks. Da freshly smoked up nfmark value is determined as bigs up:
.IP
ctmark = (ctmark & ~ctmask) ^ (nfmark & nfmask)
.IP
i.e. \fIctmask\fP defines what tha fuck bits ta clear n' \fInfmask\fP what tha fuck bitz of the
nfmark ta XOR tha fuck into tha ctmark. \fIctmask\fP n' \fInfmask\fP default to
0xFFFFFFFF.
.TP
\fB\-\-restore\-mark\fP [\fB\-\-nfmask\fP \fInfmask\fP] [\fB\-\-ctmask\fP \fIctmask\fP]
Copy tha connection mark (ctmark) ta tha packet mark (nfmark) rockin tha given
masks. Da freshly smoked up ctmark value is determined as bigs up:
.IP
nfmark = (nfmark & ~\fInfmask\fP) ^ (ctmark & \fIctmask\fP);
.IP
i.e. \fInfmask\fP defines what tha fuck bits ta clear n' \fIctmask\fP what tha fuck bitz of the
ctmark ta XOR tha fuck into tha nfmark. \fIctmask\fP n' \fInfmask\fP default to
0xFFFFFFFF.
.IP
\fB\-\-restore\-mark\fP is only valid up in tha \fBmangle\fP table.
.PP
Da followin mnemonics is available fo' \fB\-\-set\-xmark\fP:
.TP
\fB\-\-and\-mark\fP \fIbits\fP
Binary AND tha ctmark wit \fIbits\fP. (Mnemonic fo' \fB\-\-set\-xmark
0/\fP\fIinvbits\fP, where \fIinvbits\fP is tha binary negation of \fIbits\fP.)
.TP
\fB\-\-or\-mark\fP \fIbits\fP
Binary OR tha ctmark wit \fIbits\fP. (Mnemonic fo' \fB\-\-set\-xmark\fP
\fIbits\fP\fB/\fP\fIbits\fP.)
.TP
\fB\-\-xor\-mark\fP \fIbits\fP
Binary XOR tha ctmark wit \fIbits\fP. (Mnemonic fo' \fB\-\-set\-xmark\fP
\fIbits\fP\fB/0\fP.)
.TP
\fB\-\-set\-mark\fP \fIvalue\fP[\fB/\fP\fImask\fP]
Set tha connection mark. If a mask is specified then only dem bits set up in the
mask is modified.
.TP
\fB\-\-save\-mark\fP [\fB\-\-mask\fP \fImask\fP]
Copy tha nfmark ta tha ctmark. If a mask is specified, only dem bits are
copied.
.TP
\fB\-\-restore\-mark\fP [\fB\-\-mask\fP \fImask\fP]
Copy tha ctmark ta tha nfmark. If a mask is specified, only dem bits are
copied. Y'all KNOW dat shit, muthafucka! This is only valid up in tha \fBmangle\fP table.
.SS CONNSECMARK
This module copies securitizzle markings from packets ta connections
(if unlabeled), n' from connections back ta packets (also only
if unlabeled).  Typically used up in conjunction wit SECMARK, it is
valid up in the
.B security
table (for backwardz compatibilitizzle wit olda kernels, it be also
valid up in the
.B mangle
table).
.TP
\fB\-\-save\fP
If tha packet has a securitizzle marking, copy it ta tha connection
if tha connection aint marked.
.TP
\fB\-\-restore\fP
If tha packet aint gots a securitizzle marking, n' tha connection
does, copy tha securitizzle markin from tha connection ta tha packet.

.SS CT
Da CT target allows ta set parametas fo' a packet or its associated
connection. I aint talkin' bout chicken n' gravy biatch. Da target attaches a "template" connection trackin entry to
the packet, which is then used by tha conntrack core when initializing
a freshly smoked up ct entry. This target is thus only valid up in tha "raw" table.
.TP
\fB\-\-notrack\fP
Disablez connection trackin fo' dis packet.
.TP
\fB\-\-helper\fP \fIname\fP
Use tha helper identified by \fIname\fP fo' tha connection. I aint talkin' bout chicken n' gravy biatch. This is more
flexible than loadin tha conntrack helper modulez wit preset ports.
.TP
\fB\-\-ctevents\fP \fIevent\fP[\fB,\fP...]
Only generate tha specified conntrack events fo' dis connection. I aint talkin' bout chicken n' gravy biatch. Possible
event types are: \fBnew\fP, \fBrelated\fP, \fBdestroy\fP, \fBreply\fP,
\fBassured\fP, \fBprotoinfo\fP, \fBhelper\fP, \fBmark\fP (this refers to
the ctmark, not nfmark), \fBnatseqinfo\fP, \fBsecmark\fP (ctsecmark).
.TP
\fB\-\-expevents\fP \fIevent\fP[\fB,\fP...]
Only generate tha specified expectation events fo' dis connection.
Possible event types are: \fBnew\fP.
.TP
\fB\-\-zone\fP \fIid\fP
Assign dis packet ta unit \fIid\fP n' only have lookups done up in dat unit.
By default, packets have unit 0.
.TP
\fB\-\-timeout\fP \fIname\fP
Use tha timeout policy identified by \fIname\fP fo' tha connection. I aint talkin' bout chicken n' gravy biatch. This is
provides mo' flexible timeout policy definizzle than global timeout joints
available at /proc/sys/net/netfilter/nf_conntrack_*_timeout_*.
.SS DNAT (IPv4-specific)
This target is only valid up in the
.B nat
table, up in the
.B PREROUTING
and
.B OUTPUT
chains, n' user-defined chains which is only called from them
chains.  It specifies dat tha destination address of tha packet
should be modified (and all future packets up in dis connection will
also be mangled), n' rulez should cease bein examined. Y'all KNOW dat shit, muthafucka!  It takes one
type of option:
.TP
\fB\-\-to\-destination\fP [\fIipaddr\fP[\fB\-\fP\fIipaddr\fP]][\fB:\fP\fIport\fP[\fB\-\fP\fIport\fP]]
which can specify a single freshly smoked up destination IP address, a inclusive
range of IP addresses, n' optionally, a port range (which is only
valid if tha rule also specifies
\fB\-p tcp\fP
or
\fB\-p udp\fP).
If no port range is specified, then tha destination port aint NEVER gonna be
modified. Y'all KNOW dat shit, muthafucka! If no IP address is specified then only tha destination port
will be modified.

In Kernels up ta 2.6.10 you can add nuff muthafuckin \-\-to\-destination options. For
those kernels, if you specify mo' than one destination address, either via an
address range or multiple \-\-to\-destination options, a simple round-robin (one
afta another up in cycle) load balancin takes place between these addresses.
Lata Kernels (>= 2.6.11-rc1) aint gots tha mobilitizzle ta NAT ta multiple ranges
anymore.
.TP
\fB\-\-random\fP
If option
\fB\-\-random\fP
is used then port mappin is ghon be randomized (kernel >= 2.6.22).
.TP
\fB\-\-persistent\fP
Gives a cold-ass lil client tha same source-/destination-address fo' each connection.
This supersedes tha SAME target. Right back up in yo muthafuckin ass. Support fo' persistent mappings be available
from 2.6.29-rc2.
.SS DNPT (IPv6-specific)
Provides stateless destination IPv6-to-IPv6 Network Prefix Translation (as
busted lyrics bout by RFC 6296).
.PP
Yo ass gotta use dis target up in the
.B mangle
table, not up in the
.B nat
table. Well shiiiit, it takes tha followin options:
.TP
\fB\-\-src\-pfx\fP [\fIprefix/\fP\fIlength]
Set source prefix dat you wanna translate n' length
.TP
\fB\-\-dst\-pfx\fP [\fIprefix/\fP\fIlength]
Set destination prefix dat you wanna use up in tha translation n' length
.PP
Yo ass gotta use tha SNPT target ta undo tha translation. I aint talkin' bout chicken n' gravy biatch. Example:
.IP
ip6tablez \-t mangle \-I POSTROUTING \-s fd00::/64 \! \-o vboxnet0
\-j SNPT \-\-src-pfx fd00::/64 \-\-dst-pfx 2001:e20:2000:40f::/64
.IP
ip6tablez \-t mangle \-I PREROUTING \-i wlan0 \-d 2001:e20:2000:40f::/64
\-j DNPT \-\-src-pfx 2001:e20:2000:40f::/64 \-\-dst-pfx fd00::/64
.PP
Yo ass may need ta enable IPv6 neighbor proxy:
.IP
sysctl -w net. Put yo muthafuckin choppers up if ya feel this!ipv6.conf.all.proxy_ndp=1
.PP
Yo ass also gotta use the
.B NOTRACK
target ta disable connection trackin fo' translated flows.
.SS DSCP
This target allows ta alta tha value of tha DSCP bits within tha TOS
header of tha IPv4 packet.  As dis manipulates a packet, it can only
be used up in tha mangle table.
.TP
\fB\-\-set\-dscp\fP \fIvalue\fP
Set tha DSCP field ta a numerical value (can be decimal or hex)
.TP
\fB\-\-set\-dscp\-class\fP \fIclass\fP
Set tha DSCP field ta a DiffServ class.
.SS ECN (IPv4-specific)
This target allows ta selectively work round known ECN blackholes.
It can only be used up in tha mangle table.
.TP
\fB\-\-ecn\-tcp\-remove\fP
Remove all ECN bits from tha TCP header n' shit.  Of course, it can only be used
in conjunction with
\fB\-p tcp\fP.
.SS HL (IPv6-specific)
This is used ta modify tha Hop Limit field up in IPv6 header n' shit. Da Hop Limit field
is similar ta what tha fuck is known as TTL value up in IPv4.  Settin or incrementin the
Hop Limit field can potentially be straight-up dangerous, so it should be avoided at
any cost. This target is only valid in
.B mangle
table.
.PP
.B Don't eva set or increment tha value on packets dat leave yo' local network!
.TP
\fB\-\-hl\-set\fP \fIvalue\fP
Set tha Hop Limit ta `value'.
.TP
\fB\-\-hl\-dec\fP \fIvalue\fP
Decrement tha Hop Limit `value' times.
.TP
\fB\-\-hl\-inc\fP \fIvalue\fP
Increment tha Hop Limit `value' times.
.SS HMARK
Like MARK, i.e. set tha fwmark yo, but tha mark is calculated from hashing
packet selector at chizzle. Yo ass have also ta specify tha mark range and,
optionally, tha offset ta start from. ICMP error lyrics is inspected
and used ta calculate tha hashing.
.PP
Existin options are:
.TP
\fB\-\-hmark\-tuple\fP tuple\fI\fP
Possible tuple thugz are:
.B src
meanin source address (IPv4, IPv6 address),
.B dst
meanin destination address (IPv4, IPv6 address),
.B sport
meanin source port (TCP, UDP, UDPlite, SCTP, DCCP),
.B dport
meanin destination port (TCP, UDP, UDPlite, SCTP, DCCP),
.B spi
meanin Securitizzle Parameta Index (AH, ESP), and
.B ct
meanin tha usage of tha conntrack tuple instead of tha packet selectors.
.TP
\fB\-\-hmark\-mod\fP \fIvalue (must be > 0)\fP
Modulus fo' hash calculation (to limit tha range of possible marks)
.TP
\fB\-\-hmark\-offset\fP \fIvalue\fP
Offset ta start marks from.
.TP
For advanced usage, instead of rockin \-\-hmark\-tuple, you can specify custom
prefixes n' masks:
.TP
\fB\-\-hmark\-src\-prefix\fP \fIcidr\fP
Da source address mask up in CIDR notation.
.TP
\fB\-\-hmark\-dst\-prefix\fP \fIcidr\fP
Da destination address mask up in CIDR notation.
.TP
\fB\-\-hmark\-sport\-mask\fP \fIvalue\fP
A 16 bit source port mask up in hexadecimal.
.TP
\fB\-\-hmark\-dport\-mask\fP \fIvalue\fP
A 16 bit destination port mask up in hexadecimal.
.TP
\fB\-\-hmark\-spi\-mask\fP \fIvalue\fP
A 32 bit field wit spi mask.
.TP
\fB\-\-hmark\-proto\-mask\fP \fIvalue\fP
An 8 bit field wit layer 4 protocol number.
.TP
\fB\-\-hmark\-rnd\fP \fIvalue\fP
A 32 bit random custom value ta feed hash calculation.
.PP
\fIExamples:\fP
.PP
iptablez \-t mangle \-A PREROUTING \-m conntrack \-\-ctstate NEW
 \-j HMARK \-\-hmark-tuple ct,src,dst,proto \-\-hmark-offset 10000
\-\-hmark\-mod 10 \-\-hmark\-rnd 0xfeedcafe
.PP
iptablez \-t mangle \-A PREROUTING -j HMARK \-\-hmark\-offset 10000
\-\-hmark-tuple src,dst,proto \-\-hmark-mod 10 \-\-hmark\-rnd 0xdeafbeef
.SS IDLETIMER
This target can be used ta identify when intercourses done been idle fo' a
certain period of time.  Timers is identified by labels n' is pimped when
a rule is set wit a freshly smoked up label.  Da rulez also take a timeout value (in
seconds) as a option. I aint talkin' bout chicken n' gravy biatch.  If mo' than one rule uses tha same ol' dirty timer label, the
timer is ghon be restarted whenever any of tha rulez git a hit.  One entry for
each timer is pimped up in sysfs.  This attribute gotz nuff tha timer remaining
for tha timer ta expire.  Da attributes is located under tha xt_idletimer
class:
.PP
/sys/class/xt_idletimer/timers/<label>
.PP
When tha timer expires, tha target module sendz a sysfs notification ta the
userspace, which can then decizzle what tha fuck ta do (eg. disconnect ta save power).
.TP
\fB\-\-timeout\fP \fIamount\fP
This is tha time up in secondz dat will trigger tha notification.
.TP
\fB\-\-label\fP \fIstring\fP
This be a unique identifier fo' tha timer n' shit.  Da maximum length fo' the
label strang is 27 characters.
.SS LED
This creates a LED-trigger dat can then be attached ta system indicator
lights, ta blink or illuminizzle dem when certain packets pass all up in the
system. One example might be ta light up a LED fo' all dem minutes every last muthafuckin time
an SSH connection is made ta tha local machine. Da followin options control
the trigger behavior:
.TP
\fB\-\-led\-trigger\-id\fP \fIname\fP
This is tha name given ta tha LED trigger n' shit. Da actual name of tha trigger
will be prefixed wit "netfilter-".
.TP
\fB\-\-led-delay\fP \fIms\fP
This indicates how tha fuck long (in milliseconds) tha LED should be left illuminated
when a packet arrives before bein switched off again. I aint talkin' bout chicken n' gravy biatch. Da default is 0
(blink as fast as possible.) Da special value \fIinf\fP can be given to
leave tha LED on permanently once activated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (In dis case tha trigger will
need ta be manually detached n' reattached ta tha LED thang ta switch it
off again.)
.TP
\fB\-\-led\-always\-blink\fP
Always make tha LED blink on packet arrival, even if tha LED be already on.
This allows notification of freshly smoked up packets even wit long delay joints (which
otherwise would result up in a silent prolongin of tha delay time.)
.TP
Example:
.TP
Smoke a LED trigger fo' incomin SSH traffic:
iptablez \-A INPUT \-p tcp \-\-dport 22 \-j LED \-\-led\-trigger\-id ssh
.TP
Then attach tha freshly smoked up trigger ta a LED:
echo netfilter\-ssh >/sys/class/leds/\fIledname\fP/trigger
.SS LOG (IPv6-specific)
Turn on kernel loggin of matchin packets, n' you can put dat on yo' toast.  When dis option is set
for a rule, tha Linux kernel will print some shiznit on all
matchin packets (like most IPv6 IPv6-header fields) via tha kernel log
(where it can be read with
.I dmesg
or 
.IR syslogd (8)).
This be a "non-terminatin target", i.e. rule traversal continues at
the next rule.  So if you wanna LOG tha packets you refuse, use two
separate rulez wit tha same matchin criteria, first rockin target LOG
then DROP (or REJECT).
.TP
\fB\-\-log\-level\fP \fIlevel\fP
Level of logging, which can be (system-specific) numeric or a mnemonic.
Possible joints is (in decreasin order of priority): \fBemerg\fP,
\fBalert\fP, \fBcrit\fP, \fBerror\fP, \fBwarning\fP, \fBnotice\fP, \fBinfo\fP
or \fBdebug\fP.
.TP
\fB\-\-log\-prefix\fP \fIprefix\fP
Prefix log lyrics wit tha specified prefix; up ta 29 lettas long,
and useful fo' distinguishin lyrics up in tha logs.
.TP
\fB\-\-log\-tcp\-sequence\fP
Log TCP sequence numbers. This be a securitizzle risk if tha log is
readable by users.
.TP
\fB\-\-log\-tcp\-options\fP
Log options from tha TCP packet header.
.TP
\fB\-\-log\-ip\-options\fP
Log options from tha IPv6 packet header.
.TP
\fB\-\-log\-uid\fP
Log tha userid of tha process which generated tha packet.
.SS LOG (IPv4-specific)
Turn on kernel loggin of matchin packets, n' you can put dat on yo' toast.  When dis option is set
for a rule, tha Linux kernel will print some shiznit on all
matchin packets (like most IP header fields) via tha kernel log
(where it can be read with
.I dmesg
or 
.IR syslogd (8)).
This be a "non-terminatin target", i.e. rule traversal continues at
the next rule.  So if you wanna LOG tha packets you refuse, use two
separate rulez wit tha same matchin criteria, first rockin target LOG
then DROP (or REJECT).
.TP
\fB\-\-log\-level\fP \fIlevel\fP
Level of logging, which can be (system-specific) numeric or a mnemonic.
Possible joints is (in decreasin order of priority): \fBemerg\fP,
\fBalert\fP, \fBcrit\fP, \fBerror\fP, \fBwarning\fP, \fBnotice\fP, \fBinfo\fP
or \fBdebug\fP.
.TP
\fB\-\-log\-prefix\fP \fIprefix\fP
Prefix log lyrics wit tha specified prefix; up ta 29 lettas long,
and useful fo' distinguishin lyrics up in tha logs.
.TP
\fB\-\-log\-tcp\-sequence\fP
Log TCP sequence numbers. This be a securitizzle risk if tha log is
readable by users.
.TP
\fB\-\-log\-tcp\-options\fP
Log options from tha TCP packet header.
.TP
\fB\-\-log\-ip\-options\fP
Log options from tha IP packet header.
.TP
\fB\-\-log\-uid\fP
Log tha userid of tha process which generated tha packet.
.SS MARK
This target is used ta set tha Netfilta mark value associated wit tha packet.
It can, fo' example, be used up in conjunction wit routin based on fwmark (needs
iproute2). If you plan on bustin so, note dat tha mark need ta be set up in the
PREROUTING chain of tha mangle table ta affect routing.
Da mark field is 32 bits wide.
.TP
\fB\-\-set\-xmark\fP \fIvalue\fP[\fB/\fP\fImask\fP]
Zeroes up tha bits given by \fImask\fP n' XORs \fIvalue\fP tha fuck into tha packet
mark ("nfmark"). If \fImask\fP is omitted, 0xFFFFFFFF be assumed.
.TP
\fB\-\-set\-mark\fP \fIvalue\fP[\fB/\fP\fImask\fP]
Zeroes up tha bits given by \fImask\fP n' ORs \fIvalue\fP tha fuck into tha packet
mark. If \fImask\fP is omitted, 0xFFFFFFFF be assumed.
.PP
Da followin mnemonics is available:
.TP
\fB\-\-and\-mark\fP \fIbits\fP
Binary AND tha nfmark wit \fIbits\fP. (Mnemonic fo' \fB\-\-set\-xmark
0/\fP\fIinvbits\fP, where \fIinvbits\fP is tha binary negation of \fIbits\fP.)
.TP
\fB\-\-or\-mark\fP \fIbits\fP
Binary OR tha nfmark wit \fIbits\fP. (Mnemonic fo' \fB\-\-set\-xmark\fP
\fIbits\fP\fB/\fP\fIbits\fP.)
.TP
\fB\-\-xor\-mark\fP \fIbits\fP
Binary XOR tha nfmark wit \fIbits\fP. (Mnemonic fo' \fB\-\-set\-xmark\fP
\fIbits\fP\fB/0\fP.)
.SS MASQUERADE (IPv6-specific)
This target is only valid up in the
.B nat
table, up in the
.B POSTROUTING
chain. I aint talkin' bout chicken n' gravy biatch.  It should only be used wit dynamically assigned IPv6 (dialup)
connections: if you gotz a static IP address, you should use tha SNAT
target.  Masqueradin is equivalent ta specifyin a mappin ta tha IP
address of tha intercourse tha packet is goin up yo, but also has the
effect dat connections are
.I forgotten
when tha intercourse goes down. I aint talkin' bout chicken n' gravy biatch.  This is tha erect behavior when the
next dialup is unlikely ta have tha same intercourse address (and hence
any established connections is lost anyway).
.TP
\fB\-\-to\-ports\fP \fIport\fP[\fB\-\fP\fIport\fP]
This specifies a range of source ports ta use, overridin tha default
.B SNAT
source port-selection heuristics (see above).  This is only valid
if tha rule also specifies
\fB\-p tcp\fP
or
\fB\-p udp\fP.
.TP
\fB\-\-random\fP
Randomize source port mapping
If option
\fB\-\-random\fP
is used then port mappin is ghon be randomized.
.RS
.PP
.SS MASQUERADE (IPv4-specific)
This target is only valid up in the
.B nat
table, up in the
.B POSTROUTING
chain. I aint talkin' bout chicken n' gravy biatch.  It should only be used wit dynamically assigned IP (dialup)
connections: if you gotz a static IP address, you should use tha SNAT
target.  Masqueradin is equivalent ta specifyin a mappin ta tha IP
address of tha intercourse tha packet is goin up yo, but also has the
effect dat connections are
.I forgotten
when tha intercourse goes down. I aint talkin' bout chicken n' gravy biatch.  This is tha erect behavior when the
next dialup is unlikely ta have tha same intercourse address (and hence
any established connections is lost anyway).
.TP
\fB\-\-to\-ports\fP \fIport\fP[\fB\-\fP\fIport\fP]
This specifies a range of source ports ta use, overridin tha default
.B SNAT
source port-selection heuristics (see above).  This is only valid
if tha rule also specifies
\fB\-p tcp\fP
or
\fB\-p udp\fP.
.TP
\fB\-\-random\fP
Randomize source port mapping
If option
\fB\-\-random\fP
is used then port mappin is ghon be randomized (kernel >= 2.6.21).
.RS
.PP
.SS MIRROR (IPv4-specific)
This be a experimenstrual demonstration target which inverts tha source
and destination fieldz up in tha IP header n' retransmits tha packet.
It be only valid up in the
.BR INPUT ,
.B FORWARD
and
.B PREROUTING
chains, n' user-defined chains which is only called from them
chains.  Note dat tha outgoin packets are
.B NOT
seen by any packet filterin chains, connection trackin or NAT, to
avoid loops n' other problems.
.SS NETMAP (IPv4-specific)
This target allows you ta statically map a whole network of addresses onto
another network of addresses.  It can only be used from rulez up in the
.B nat
table.
.TP
\fB\-\-to\fP \fIaddress\fP[\fB/\fP\fImask\fP]
Network address ta map to.  Da resultin address is ghon be constructed up in the
followin way: All 'one' bits up in tha mask is filled up in from tha freshly smoked up `address'.
All bits dat is zero up in tha mask is filled up in from tha original gangsta address.
.SS NFLOG
This target serves up loggin of matchin packets, n' you can put dat on yo' toast. When dis target is
set fo' a rule, tha Linux kernel will pass tha packet ta tha loaded
loggin backend ta log tha packet. This is probably used up in combination
with nfnetlink_log as loggin backend, which will multicast tha packet
all up in a
.IR netlink
socket ta tha specified multicast group. One or mo' userspace processes
may subscribe ta tha crew ta receive tha packets, n' you can put dat on yo' toast. Like LOG, dis be a
non-terminatin target, i.e. rule traversal continues all up in tha next rule.
.TP
\fB\-\-nflog\-group\fP \fInlgroup\fP
Da netlink crew (0 - 2^16\-1) ta which packets is (only applicable for
nfnetlink_log). Da default value is 0.
.TP
\fB\-\-nflog\-prefix\fP \fIprefix\fP
A prefix strang ta include up in tha log message, up ta 64 characters
long, useful fo' distinguishin lyrics up in tha logs.
.TP
\fB\-\-nflog\-range\fP \fIsize\fP
Da number of bytes ta be copied ta userspace (only applicable for
nfnetlink_log). nfnetlink_log instances may specify they own
range, dis option overrides dat shit.
.TP
\fB\-\-nflog\-threshold\fP \fIsize\fP
Number of packets ta queue inside tha kernel before bustin  them
to userspace (only applicable fo' nfnetlink_log) yo. Higher joints
result up in less overhead per packet yo, but increase delay until the
packets reach userspace. Da default value is 1.
.BR
.SS NFQUEUE
This target be a extension of tha QUEUE target fo' realz. As opposed ta QUEUE, it allows
you ta put a packet tha fuck into any specific queue, identified by its 16-bit queue
number.
It can only be used wit Kernel versions 2.6.14 or later, since it requires
the
.B
nfnetlink_queue
kernel support. Da \fBqueue-balance\fP option was added up in Linux 2.6.31,
\fBqueue-bypass\fP up in 2.6.39.
.TP
\fB\-\-queue\-num\fP \fIvalue\fP
This specifies tha QUEUE number ta use. Valid queue numbers is 0 ta 65535. Da default value is 0.
.PP
.TP
\fB\-\-queue\-balance\fP \fIvalue\fP\fB:\fP\fIvalue\fP
This specifies a range of queues ta use. Packets is then balanced across tha given queues.
This is useful fo' multicore systems: start multiple instancez of tha userspace program on
queues x, x+1, .. x+n n' use "\-\-queue\-balizzle \fIx\fP\fB:\fP\fIx+n\fP".
Packets belongin ta tha same connection is put tha fuck into tha same nfqueue.
.PP
.TP
\fB\-\-queue\-bypass\fP
By default, if no userspace program is listenin on a NFQUEUE, then all packets dat is ta be queued
are dropped. Y'all KNOW dat shit, muthafucka!  When dis option is used, tha NFQUEUE rule behaves like ACCEPT instead, n' tha packet
will move on ta tha next table.
.SS NOTRACK
This target disablez connection trackin fo' all packets matchin dat rule.
It be obsoleted by \-j CT \-\-notrack. Like CT, NOTRACK can only be used in
the \fBraw\fP table.
.SS RATEEST
Da RATEEST target collects statistics, performs rate estimation calculation
and saves tha thangs up in dis biatch fo' lata evaluation rockin tha \fBrateest\fP match.
.TP
\fB\-\-rateest\-name\fP \fIname\fP
Count matched packets tha fuck into tha pool referred ta by \fIname\fP, which is freely
choosable.
.TP
\fB\-\-rateest\-interval\fP \fIamount\fP{\fBs\fP|\fBms\fP|\fBus\fP}
Rate measurement interval, up in seconds, millisecondz or microseconds.
.TP
\fB\-\-rateest\-ewmalog\fP \fIvalue\fP
Rate measurement averagin time constant.
.SS REDIRECT (IPv4-specific)
This target is only valid up in the
.B nat
table, up in the
.B PREROUTING
and
.B OUTPUT
chains, n' user-defined chains which is only called from them
chains.  It redirects tha packet ta tha machine itself by changin the
destination IP ta tha primary address of tha incomin intercourse
(locally-generated packets is mapped ta tha 127.0.0.1 address).
.TP
\fB\-\-to\-ports\fP \fIport\fP[\fB\-\fP\fIport\fP]
This specifies a thugged-out destination port or range of ports ta use: without
this, tha destination port is never altered. Y'all KNOW dat shit, muthafucka!  This is only valid
if tha rule also specifies
\fB\-p tcp\fP
or
\fB\-p udp\fP.
.TP
\fB\-\-random\fP
If option
\fB\-\-random\fP
is used then port mappin is ghon be randomized (kernel >= 2.6.22).
.RS
.PP
.SS REJECT (IPv6-specific)
This is used ta bust back a error packet up in response ta tha matched
packet: otherwise it is equivalent ta 
.B DROP
so it aint nuthin but a terminatin TARGET, endin rule traversal.
This target is only valid up in the
.BR INPUT ,
.B FORWARD
and
.B OUTPUT
chains, n' user-defined chains which is only called from them
chains.  Da followin option controls tha nature of tha error packet
returned:
.TP
\fB\-\-reject\-with\fP \fItype\fP
Da type given can be
\fBicmp6\-no\-route\fP,
\fBno\-route\fP,
\fBicmp6\-adm\-prohibited\fP,
\fBadm\-prohibited\fP,
\fBicmp6\-addr\-unreachable\fP,
\fBaddr\-unreach\fP,
\fBicmp6\-port\-unreachable\fP or
\fBport\-unreach\fP
which return tha appropriate ICMPv6 error message (\fBport\-unreach\fP is
the default). Finally, tha option
\fBtcp\-reset\fP
can be used on rulez which only match tha TCP protocol: dis causes a
TCP RST packet ta be busted back.  This is mainly useful fo' blockin 
.I ident
(113/tcp) probes which frequently occur when bustin  mail ta fucked up mail
hosts (which won't accept yo' mail otherwise).
\fBtcp\-reset\fP
can only be used wit kernel versions 2.6.14 or later.
.SS REJECT (IPv4-specific)
This is used ta bust back a error packet up in response ta tha matched
packet: otherwise it is equivalent to
.B DROP
so it aint nuthin but a terminatin TARGET, endin rule traversal.
This target is only valid up in the
.BR INPUT ,
.B FORWARD
and
.B OUTPUT
chains, n' user-defined chains which is only called from them
chains.  Da followin option controls tha nature of tha error packet
returned:
.TP
\fB\-\-reject\-with\fP \fItype\fP
Da type given can be
\fBicmp\-net\-unreachable\fP,
\fBicmp\-host\-unreachable\fP,
\fBicmp\-port\-unreachable\fP,
\fBicmp\-proto\-unreachable\fP,
\fBicmp\-net\-prohibited\fP,
\fBicmp\-host\-prohibited\fP or
\fBicmp\-admin\-prohibited\fP (*)
which return tha appropriate ICMP error message (\fBport\-unreachable\fP is
the default).  Da option
\fBtcp\-reset\fP
can be used on rulez which only match tha TCP protocol: dis causes a
TCP RST packet ta be busted back.  This is mainly useful fo' blockin 
.I ident
(113/tcp) probes which frequently occur when bustin  mail ta fucked up mail
hosts (which won't accept yo' mail otherwise).
.PP
(*) Usin icmp\-admin\-prohibited wit kernels dat do not support it will result up in a plain DROP instead of REJECT
.SS SAME (IPv4-specific)
Similar ta SNAT/DNAT dependin on chain: it takes a range of addresses
(`\-\-to 1.2.3.4\-1.2.3.7') n' gives a cold-ass lil client tha same
source-/destination-address fo' each connection.
.PP
N.B.: Da DNAT targetz \fB\-\-persistent\fP option replaced tha SAME target.
.TP
\fB\-\-to\fP \fIipaddr\fP[\fB\-\fP\fIipaddr\fP]
Addresses ta map source to. May be specified mo' than once for
multiple ranges.
.TP
\fB\-\-nodst\fP
Don't use tha destination-ip up in tha calculations when selectin the
new source-ip
.TP
\fB\-\-random\fP
Port mappin is ghon be forcibly randomized ta avoid attacks based on 
port prediction (kernel >= 2.6.21).
.SS SECMARK
This is used ta set tha securitizzle mark value associated wit the
packet fo' use by securitizzle subsystems like fuckin SELinux.  It is
valid up in the
.B security
table (for backwardz compatibilitizzle wit olda kernels, it be also
valid up in the
.B mangle
table). Da mark is 32 bits wide.
.TP
\fB\-\-selctx\fP \fIsecurity_context\fP
.SS SET
This module addz and/or deletes entries from IP sets which can be defined
by ipset(8).
.TP
\fB\-\-add\-set\fP \fIsetname\fP \fIflag\fP[\fB,\fP\fIflag\fP...]
add tha address(es)/port(s) of tha packet ta tha set
.TP
\fB\-\-del\-set\fP \fIsetname\fP \fIflag\fP[\fB,\fP\fIflag\fP...]
delete tha address(es)/port(s) of tha packet from tha set
.IP
where \fIflag\fP(s) are
.BR "src"
and/or
.BR "dst"
specifications n' there can be no mo' than six of em.
.TP
\fB\-\-timeout\fP \fIvalue\fP
when addin a entry, tha timeout value ta use instead of tha default
one from tha set definition
.TP
\fB\-\-exist\fP
when addin a entry if it already exists, reset tha timeout value
to tha specified one or ta tha default from tha set definition
.PP
Use of -j SET requires dat ipset kernel support is provided, which, for
standard kernels, is tha case since Linux 2.6.39.
.SS SNAT (IPv4-specific)
This target is only valid up in the
.B nat
table, up in the
.B POSTROUTING
and
.B INPUT
chains, n' user-defined chains which is only called from them
chains.  It specifies dat tha source address of tha packet should be
modified (and all future packets up in dis connection will also be
mangled), n' rulez should cease bein examined. Y'all KNOW dat shit, muthafucka!  It takes one type
of option:
.TP
\fB\-\-to\-source\fP [\fIipaddr\fP[\fB\-\fP\fIipaddr\fP]][\fB:\fP\fIport\fP[\fB\-\fP\fIport\fP]]
which can specify a single freshly smoked up source IP address, a inclusive range
of IP addresses, n' optionally, a port range (which is only valid if
the rule also specifies
\fB\-p tcp\fP
or
\fB\-p udp\fP).
If no port range is specified, then source ports below 512 will be
mapped ta other ports below 512: dem between 512 n' 1023 inclusive
will be mapped ta ports below 1024, n' other ports is ghon be mapped to
1024 or above. Where possible, no port alteration will occur.

In Kernels up ta 2.6.10, you can add nuff muthafuckin \-\-to\-source options. For them
kernels, if you specify mo' than one source address, either via a address
range or multiple \-\-to\-source options, a simple round-robin (one afta another
in cycle) takes place between these addresses.
Lata Kernels (>= 2.6.11-rc1) aint gots tha mobilitizzle ta NAT ta multiple ranges
anymore.
.TP
\fB\-\-random\fP
If option
\fB\-\-random\fP
is used then port mappin is ghon be randomized (kernel >= 2.6.21).
.TP
\fB\-\-persistent\fP
Gives a cold-ass lil client tha same source-/destination-address fo' each connection.
This supersedes tha SAME target. Right back up in yo muthafuckin ass. Support fo' persistent mappings be available
from 2.6.29-rc2.
.PP
Kernels prior ta 2.6.36-rc1 aint gots tha mobilitizzle to
.B SNAT
in the
.B INPUT
chain.
.SS SNPT (IPv6-specific)
Provides stateless source IPv6-to-IPv6 Network Prefix Translation (as busted lyrics about
by RFC 6296).
.PP
Yo ass gotta use dis target up in the
.B mangle
table, not up in the
.B nat
table. Well shiiiit, it takes tha followin options:
.TP
\fB\-\-src\-pfx\fP [\fIprefix/\fP\fIlength]
Set source prefix dat you wanna translate n' length
.TP
\fB\-\-dst\-pfx\fP [\fIprefix/\fP\fIlength]
Set destination prefix dat you wanna use up in tha translation n' length
.PP
Yo ass gotta use tha DNPT target ta undo tha translation. I aint talkin' bout chicken n' gravy biatch. Example:
.IP
ip6tablez \-t mangle \-I POSTROUTING \-s fd00::/64 \! \-o vboxnet0
\-j SNPT \-\-src-pfx fd00::/64 \-\-dst-pfx 2001:e20:2000:40f::/64
.IP
ip6tablez \-t mangle \-I PREROUTING \-i wlan0 \-d 2001:e20:2000:40f::/64
\-j DNPT \-\-src-pfx 2001:e20:2000:40f::/64 \-\-dst-pfx fd00::/64
.PP
Yo ass may need ta enable IPv6 neighbor proxy:
.IP
sysctl -w net. Put yo muthafuckin choppers up if ya feel this!ipv6.conf.all.proxy_ndp=1
.PP
Yo ass also gotta use the
.B NOTRACK
target ta disable connection trackin fo' translated flows.
.SS TCPMSS
This target allows ta alta tha MSS value of TCP SYN packets, ta control
the maximum size fo' dat connection (usually limitin it ta your
outgoin intercoursez MTU minus 40 fo' IPv4 or 60 fo' IPv6, respectively).
Of course, it can only be used
in conjunction with
\fB\-p tcp\fP.
.PP
This target is used ta overcome criminally domedead ISPs or servers
which block "ICMP Fragmentation Needed" or "ICMPv6 Packet Too Big"
packets, n' you can put dat on yo' toast.  Da symptomz of this
problem is dat every last muthafuckin thang works fine from yo' Linux
firewall/router yo, but machines behind it can never exchange large
packets:
.IP 1. 4
Web browsers connect, then hang wit no data received.
.IP 2. 4
Lil Small-Ass mail works fine yo, but big-ass emails hang.
.IP 3. 4
ssh works fine yo, but scp hangs afta initial handbobbin.
.PP
Workaround: activate dis option n' add a rule ta yo' firewall
configuration like:
.IP
 iptablez \-t mangle \-A FORWARD \-p tcp \-\-tcp\-flags SYN,RST SYN
             \-j TCPMSS \-\-clamp\-mss\-to\-pmtu
.TP
\fB\-\-set\-mss\fP \fIvalue\fP
Explicitly sets MSS option ta specified value. If tha MSS of tha packet is
already lower than \fIvalue\fP, it will \fBnot\fP be increased (from Linux
2.6.25 onwards) ta avoid mo' problems wit hosts relyin on a proper MSS.
.TP
\fB\-\-clamp\-mss\-to\-pmtu\fP
Automatically clamp MSS value ta (path_MTU \- 40 fo' IPv4; \-60 fo' IPv6).
This may not function as desired where asymmetric routes wit differing
path MTU exist \(em tha kernel uses tha path MTU which it would use ta send
packets from itself ta tha source n' destination IP addresses. Prior to
Linux 2.6.25, only tha path MTU ta tha destination IP address was
considered by dis option; subsequent kernels also consider tha path MTU
to tha source IP address.
.PP
These options is mutually exclusive.
.SS TCPOPTSTRIP
This target will strip TCP options off a TCP packet. (It will straight-up replace
them by NO-OPs.) As such, yo big-ass booty is ghon need ta add tha \fB\-p tcp\fP parameters.
.TP
\fB\-\-strip\-options\fP \fIoption\fP[\fB,\fP\fIoption\fP...]
Strip tha given option(s). Da options may be specified by TCP option number or
by symbolic name. Da list of recognized options can be obtained by calling
iptablez wit \fB\-j TCPOPTSTRIP \-h\fP.
.SS TEE
Da \fBTEE\fP target will clone a packet n' redirect dis clone ta another
machine on tha \fBlocal\fP network segment. In other lyrics, tha nexthop
must be tha target, or yo big-ass booty is ghon gotta configure tha nexthop ta forward it
further if so desired.
.TP
\fB\-\-gateway\fP \fIipaddr\fP
Send tha cloned packet ta tha host reachable all up in tha given IP address.
Use of 0.0.0.0 (for IPv4 packets) or :: (IPv6) is invalid.
.PP
To forward all incomin traffic on eth0 ta a Network Layer loggin box:
.PP
\-t mangle \-A PREROUTING \-i eth0 \-j TEE \-\-gateway 2001:db8::1
.SS TOS
This module sets tha Type of Service field up in tha IPv4 header (includin the
"precedence" bits) or tha Prioritizzle field up in tha IPv6 header n' shit. Note dat TOS
shares tha same ol' dirty bits as DSCP n' ECN. Da TOS target is only valid up in the
\fBmangle\fP table.
.TP
\fB\-\-set\-tos\fP \fIvalue\fP[\fB/\fP\fImask\fP]
Zeroes up tha bits given by \fImask\fP (see NOTE below) n' XORs \fIvalue\fP
into tha TOS/Prioritizzle field. Y'all KNOW dat shit, muthafucka! If \fImask\fP is omitted, 0xFF be assumed.
.TP
\fB\-\-set\-tos\fP \fIsymbol\fP
Yo ass can specify a symbolic name when rockin tha TOS target fo' IPv4. Well shiiiit, it implies
a mask of 0xFF (see NOTE below). Da list of recognized TOS names can be
obtained by callin iptablez wit \fB\-j TOS \-h\fP.
.PP
Da followin mnemonics is available:
.TP
\fB\-\-and\-tos\fP \fIbits\fP
Binary AND tha TOS value wit \fIbits\fP. (Mnemonic fo' \fB\-\-set\-tos
0/\fP\fIinvbits\fP, where \fIinvbits\fP is tha binary negation of \fIbits\fP.
See NOTE below.)
.TP
\fB\-\-or\-tos\fP \fIbits\fP
Binary OR tha TOS value wit \fIbits\fP. (Mnemonic fo' \fB\-\-set\-tos\fP
\fIbits\fP\fB/\fP\fIbits\fP. Right back up in yo muthafuckin ass. See NOTE below.)
.TP
\fB\-\-xor\-tos\fP \fIbits\fP
Binary XOR tha TOS value wit \fIbits\fP. (Mnemonic fo' \fB\-\-set\-tos\fP
\fIbits\fP\fB/0\fP. Right back up in yo muthafuckin ass. See NOTE below.)
.PP
NOTE: In Linux kernels up ta n' includin 2.6.38, wit tha exception of
longterm releases 2.6.32 (>=.42), 2.6.33 (>=.15), n' 2.6.35 (>=.14), there is
a bug whereby IPv6 TOS manglin do not behave as documented n' differs from
the IPv4 version. I aint talkin' bout chicken n' gravy biatch. Da TOS mask indicates tha bits one wants ta zero out, so it
needz ta be inverted before applyin it ta tha original gangsta TOS field. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat the
aformentioned kernels forgo tha inversion which breaks --set-tos n' its
mnemonics.
.SS TPROXY
This target is only valid up in tha \fBmangle\fP table, up in tha \fBPREROUTING\fP
chain n' user-defined chains which is only called from dis chain. I aint talkin' bout chicken n' gravy biatch. It
redirects tha packet ta a local socket without changin tha packet header in
any way. Well shiiiit, it can also chizzle tha mark value which can then be used up in advanced
routin rules.
It takes three options:
.TP
\fB\-\-on\-port\fP \fIport\fP
This specifies a thugged-out destination port ta use. Well shiiiit, it aint nuthin but a required option, 0 means the
new destination port is tha same ol' dirty as tha original. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. This is only valid if the
rule also specifies \fB\-p tcp\fP or \fB\-p udp\fP.
.TP
\fB\-\-on\-ip\fP \fIaddress\fP
This specifies a thugged-out destination address ta use. By default tha address is tha IP
address of tha incomin intercourse. This is only valid if tha rule also
specifies \fB\-p tcp\fP or \fB\-p udp\fP.
.TP
\fB\-\-tproxy\-mark\fP \fIvalue\fP[\fB/\fP\fImask\fP]
Marks packets wit tha given value/mask. Da fwmark value set here can be used
by advanced routing. (Required fo' transparent proxyin ta work: otherwise
these packets will git forwarded, which is probably not what tha fuck you want.)
.SS TRACE
This target marks packets so dat tha kernel will log every last muthafuckin rule which match 
the packets as dem traverse tha tables, chains, rules.
.PP
A loggin backend, like fuckin ip(6)t_LOG or nfnetlink_log, must be loaded fo' this
to be visible.
Da packets is logged wit tha strang prefix:
"TRACE: tablename:chainname:type:rulenum " where type can be "rule" fo' 
plain rule, "return" fo' implicit rule all up in tha end of a user defined chain 
and "policy" fo' tha policy of tha built up in chains. 
.br
It can only be used up in the
.BR raw
table.
.SS TTL (IPv4-specific)
This is used ta modify tha IPv4 TTL header field. Y'all KNOW dat shit, muthafucka!  Da TTL field determines
how nuff hops (routers) a packet can traverse until itz time ta live is
exceeded.
.PP
Settin or incrementin tha TTL field can potentially be straight-up dangerous,
so it should be avoided at any cost. This target is only valid in
.B mangle
table.
.PP
.B Don't eva set or increment tha value on packets dat leave yo' local network!
.TP
\fB\-\-ttl\-set\fP \fIvalue\fP
Set tha TTL value ta `value'.
.TP
\fB\-\-ttl\-dec\fP \fIvalue\fP
Decrement tha TTL value `value' times.
.TP
\fB\-\-ttl\-inc\fP \fIvalue\fP
Increment tha TTL value `value' times.
.SS ULOG (IPv4-specific)
This target serves up userspace loggin of matchin packets, n' you can put dat on yo' toast.  When this
target is set fo' a rule, tha Linux kernel will multicast dis packet
all up in a
.IR netlink 
socket. One or mo' userspace processes may then subscribe ta various 
multicast crews n' receive tha packets.
Like LOG, dis be a "non-terminatin target", i.e. rule traversal
continues all up in tha next rule.
.TP
\fB\-\-ulog\-nlgroup\fP \fInlgroup\fP
This specifies tha netlink crew (1-32) ta which tha packet is sent.
Default value is 1.
.TP
\fB\-\-ulog\-prefix\fP \fIprefix\fP
Prefix log lyrics wit tha specified prefix; up ta 32 characters
long, n' useful fo' distinguishin lyrics up in tha logs.
.TP
\fB\-\-ulog\-cprange\fP \fIsize\fP
Number of bytes ta be copied ta userspace.  A value of 0 always copies
the entire packet, regardless of its size.  Default is 0.
.TP
\fB\-\-ulog\-qthreshold\fP \fIsize\fP
Number of packet ta queue inside kernel.  Settin dis value to, e.g. 10
accumulates ten packets inside tha kernel n' transmits dem as one
netlink multipart message ta userspace.  Default is 1 (for backwards
compatibility).
.br
