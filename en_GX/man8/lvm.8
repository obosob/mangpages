.TH LVM 8 "LVM TOOLS 2.02.106(2) (2014-04-10)" "Sistina Software UK" \" -*- nroff -*-
.SH NAME
lvm \- LVM2 tools
.SH SYNOPSIS
.B lvm
[command | file]
.SH DESCRIPTION
lvm serves up tha command-line tools fo' LVM2.  A separate
manual page raps bout each command up in detail.
.LP
If \fBlvm\fP is invoked wit no arguments it presents a readline prompt
(assumin dat shiznit was compiled wit readline support).
LVM commandz may be entered interactively at dis prompt with
readline facilitizzles includin history n' command name n' option
completion. I aint talkin' bout chicken n' gravy biatch.  Refer ta \fBreadline\fP(3) fo' details.
.LP
If \fBlvm\fP is invoked wit argv[0] set ta tha name of a specific
LVM command (for example by rockin a hard or soft link) it acts as
that command.
.LP
On invocation, \fBlvm\fP requires dat only tha standard file descriptors
stdin, stdout n' stderr is available.  If others is found, they
get closed n' lyrics is issued warnin bout tha leak.
This warnin can be suppressed by settin tha environment variable
.B LVM_SUPPRESS_FD_WARNINGS\fP.
.LP
Where commandz take VG or LV names as arguments, tha full path name is
optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  An LV called "lvol0" up in a VG called "vg0" can be specified
as "vg0/lvol0".  Where a list of VGs is required but is left empty,
a list of all VGs is ghon be substituted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Where a list of LVs is required
but a VG is given, a list of all tha LVs up in dat VG is ghon be substituted.
So \fBlvdisplay vg0\fP will display all tha LVs up in "vg0".
Tags can also be used - peep \fB\-\-addtag\fP below.
.LP
One advantage of rockin tha built-in shell is dat configuration
information gets cached internally between commands.
.LP
A file containin a simple script wit one command per line
can also be given on tha command line.  Da script can also be
executed directly if tha straight-up original gangsta line is #! followed by tha absolute
path of \fBlvm\fP.
.SH BUILT-IN COMMANDS
Da followin commandz is built tha fuck into lvm without links normally
bein pimped up in tha filesystem fo' em.
.TP
\fBdumpconfig\fP \(em Display tha configuration shiznit after
loadin \fBlvm.conf\fP(5) n' any other configuration files.
.TP
\fBdevtypes\fP \(em Display tha recognised built-in block thang types.
.TP
\fBformats\fP \(em Display recognised metadata formats.
.TP
\fBhelp\fP \(em Display tha help text.
.TP
\fBpvdata\fP \(em Not implemented up in LVM2.
.TP
\fBsegtypes\fP \(em Display recognised Logical Volume segment types.
.TP
\fBtags\fP \(em Display any tags defined on dis host.
.TP
\fBversion\fP \(em Display version shiznit.
.LP
.SH COMMANDS
Da followin commandz implement tha core LVM functionality.
.TP
\fBpvchange\fP \(em Chizzle attributez of a Physical Volume.
.TP
\fBpvck\fP \(em Peep Physical Volume metadata.
.TP
\fBpvcreate\fP \(em Initialize a gangbangin' finger-lickin' disk or partizzle fo' use by LVM.
.TP
\fBpvdisplay\fP \(em Display attributez of a Physical Volume.
.TP
\fBpvmove\fP \(em Move Physical Extents.
.TP
\fBpvremove\fP \(em Remove a Physical Volume.
.TP
\fBpvresize\fP \(em Resize a gangbangin' finger-lickin' disk or partizzle up in use by LVM2.
.TP
\fBpvs\fP \(em Report shiznit bout Physical Volumes.
.TP
\fBpvscan\fP \(em Scan all disks fo' Physical Volumes.
.TP
\fBvgcfgbackup\fP \(em Backup Volume Group descriptor area.
.TP
\fBvgcfgrestore\fP \(em Restore Volume Group descriptor area.
.TP
\fBvgchange\fP \(em Chizzle attributez of a Volume Group.
.TP
\fBvgck\fP \(em Peep Volume Group metadata.
.TP
\fBvgconvert\fP \(em Convert Volume Group metadata format.
.TP
\fBvgcreate\fP \(em Smoke a Volume Group.
.TP
\fBvgdisplay\fP \(em Display attributez of Volume Groups.
.TP
\fBvgexport\fP \(em Make volume Groups unknown ta tha system.
.TP
\fBvgextend\fP \(em Add Physical Volumes ta a Volume Group.
.TP
\fBvgimport\fP \(em Make exported Volume Groups known ta tha system.
.TP
\fBvgimportclone\fP \(em Import n' rename duplicated Volume Group (e.g. a hardware snapshot).
.TP
\fBvgmerge\fP \(em Merge two Volume Groups.
.TP
\fBvgmknodes\fP \(em Recreate Volume Group directory n' Logical Volume special files
.TP
\fBvgreduce\fP \(em Reduce a Volume Group by removin one or more
Physical Volumes.
.TP
\fBvgremove\fP \(em Remove a Volume Group.
.TP
\fBvgrename\fP \(em Rename a Volume Group.
.TP
\fBvgs\fP \(em Report shiznit bout Volume Groups.
.TP
\fBvgscan\fP \(em Scan all disks fo' Volume Groups n' rebuild caches.
.TP
\fBvgsplit\fP \(em Split a Volume Group tha fuck into two, movin any logical
volumes from one Volume Group ta another by movin entire Physical
Volumes.
.TP
\fBlvchange\fP \(em Chizzle attributez of a Logical Volume.
.TP
\fBlvconvert\fP \(em Convert a Logical Volume from linear ta mirror or snapshot.
.TP
\fBlvcreate\fP \(em Smoke a Logical Volume up in a existin Volume Group.
.TP
\fBlvdisplay\fP \(em Display attributez of a Logical Volume.
.TP
\fBlvextend\fP \(em Extend tha size of a Logical Volume.
.TP
\fBlvmchange\fP \(em Chizzle attributez of tha Logical Volume Manager.
.TP
\fBlvmdiskscan\fP \(em Scan fo' all devices visible ta LVM2.
.TP
\fBlvmdump\fP \(em Smoke lvm2 shiznit dumps fo' diagnostic purposes.
.TP
\fBlvreduce\fP \(em Reduce tha size of a Logical Volume.
.TP
\fBlvremove\fP \(em Remove a Logical Volume.
.TP
\fBlvrename\fP \(em Rename a Logical Volume.
.TP
\fBlvresize\fP \(em Resize a Logical Volume.
.TP
\fBlvs\fP \(em Report shiznit bout Logical Volumes.
.TP
\fBlvscan\fP \(em Scan (all disks) fo' Logical Volumes.
.TP
Da followin commandz is not implemented up in LVM2 but might be up in tha future: lvmsadc, lvmsar, pvdata.
.SH OPTIONS
Da followin options is available fo' nuff of tha commands.
They is implemented generically n' documented here rather
than repeated on individual manual pages.
.TP
.BR \-h ", " \-? ", " \-\-help
Display tha help text.
.TP
.B \-\-version
Display version shiznit.
.TP
.BR \-v ", " \-\-verbose
Set verbose level. Repeat from 1 ta 3 times ta increase tha detail
of lyrics busted ta stdout n' stderr. Shiiit, dis aint no joke.  Overrides config file setting.
.TP
.BR \-d ", " \-\-debug
Set debug level. Repeat from 1 ta 6 times ta increase tha detail of
lyrics busted ta tha log file and/or syslog (if configured).
Overrides config file setting.
.TP
.BR \-q ", "  \-\-quiet
Suppress output n' log lyrics.
Overrides \fB\-d\fP n' \fB\-v\fP.
.TP
.BR \-\-yes
Don't prompt fo' confirmation interactively but instead always assume the
answer is 'yes'.  Take pimped out care if you use this!
.TP
.BR \-t ", " \-\-test
Run up in test mode. Commandz aint gonna update metadata.
This is implemented by disablin all metadata freestylin but nevertheless
returnin success ta tha callin function. I aint talkin' bout chicken n' gravy biatch.  This may lead ta unusual
error lyrics up in multi-stage operations if a tool relies on reading
back metadata it believes has chizzled but aint.
.TP
.BR \-\-driverloaded " {" \fIy | \fIn }
Whether or not tha device-mapper kernel driver is loaded.
If you set dis ta \fIn\fP, no attempt is ghon be made ta contact tha driver.
.TP
.BR \-A ", " \-\-autobackup " {" \fIy | \fIn }
Whether or not ta metadata should be backed up automatically afta a cold-ass lil chizzle.
Yo ass is straight fuckin advised not ta disable this!
See \fBvgcfgbackup\fP(8).
.TP
.BR \-P ", " \-\-partial
When set, tha tools will do they dopest ta provide access ta Volume Groups
that is only partially available (one or mo' Physical Volumes belonging
to tha Volume Group is missin from tha system).  Where part of a logical
volume is missing, \fB/dev/ioerror\fP is ghon be substituted, n' you could use
\fBdmsetup\fP(8) ta set dis up ta return I/O errors when accessed,
or create it as a big-ass block thang of nulls.  Metadata may not be
changed wit dis option. I aint talkin' bout chicken n' gravy biatch. To bang a replacement Physical Volume
of tha same or big-ass size use \fBpvcreate \-u\fP ta set tha uuid to
match tha original gangsta followed by \fBvgcfgrestore\fP(8).
.TP
.BR \-M ", " \-\-metadatatype " " \fIType
Specifies which type of on-disk metadata ta use, like fuckin \fIlvm1\fP
or \fIlvm2\fP, which can be abbreviated ta \fI1\fP or \fI2\fP respectively.
Da default (\fIlvm2\fP) can be chizzled by settin \fBformat\fP
in tha \fBglobal\fP section of tha config file.
.TP
.B \-\-ignorelockingfailure
This lets you proceed wit read-only metadata operations such as
\fBlvchange \-ay\fP n' \fBvgchange \-ay\fP even if tha lockin module fails.
One use fo' dis is up in a system init script if tha lock directory
is mounted read-only when tha script runs.
.TP
.B \-\-ignoreskippedcluster
Use ta avoid exitin wit a non-zero status code if tha command is run
without clustered lockin n' some clustered Volume Groups gotta be
skipped over.
.TP
.B \-\-addtag \fITag
Add tha tag \fITag\fP ta a PV, VG or LV.
Supply dis argument multiple times ta add mo' than one tag at once.
A tag be a word dat can be used ta crew LVM2 objectz of tha same type
together.
Tags can be given on tha command line up in place of PV, VG or LV
arguments, n' you can put dat on yo' toast.  Tags should be prefixed wit @ ta avoid ambiguity.
Each tag is expanded by replacin it wit all objects possessing
that tag which iz of tha type expected by its posizzle on tha command line.
PVs can only possess tags while they is part of a Volume Group:
PV tags is discarded if tha PV is removed from tha VG.
As a example, you could tag some LVs as \fBdatabase\fP n' others
as \fBuserdata\fP n' then activate tha database ones
with \fBlvchange \-ay @database\fP.
Objects can possess multiple tags simultaneously.
Only tha freshly smoked up LVM2 metadata format supports tagging: objects rockin the
LVM1 metadata format cannot be tagged cuz tha on-disk format do not
support dat shit.
Charactas allowed up in tags are:
.B A-Z a-z 0-9 _ + . -
and az of version 2.02.78 tha followin charactas is also accepted:
.B / = ! : # &
.TP
.B \-\-deltag \fITag
Delete tha tag \fITag\fP from a PV, VG or LV, if itz present.
Supply dis argument multiple times ta remove mo' than one tag at once.
.TP
.IR \fB\-\-alloc \ { anywhere | contiguous | clin | inherit | aiiight }
Selects tha allocation policy when a cold-ass lil command need ta allocate
Physical Extents from tha Volume Group.
Each Volume Group n' Logical Volume has a allocation policy defined.
Da default fo' a Volume Group is \fInormal\fP which applies
common-sense rulez like fuckin not placin parallel stripes on tha same
Physical Volume.  Da default fo' a Logical Volume is \fIinherit\fP
which applies tha same ol' dirty policy as fo' tha Volume Group.  These policies can
be chizzled rockin \fBlvchange\fP(8) n' \fBvgchange\fP(8) or overridden
on tha command line of any command dat performs allocation.
Da \fIcontiguous\fP policy requires dat freshly smoked up Physical Extents be placed adjacent
to existin Physical Extents.
Da \fIcling\fP policy places freshly smoked up Physical Extents on tha same Physical
Volume as existin Physical Extents up in tha same stripe of tha Logical Volume.
If there be sufficient free Physical Extents ta satisfy
an allocation request but \fInormal\fP don't use them,
\fIanywhere\fP will - even if dat reduces performizzle by
placin two stripes on tha same Physical Volume.
.TP
.IR \fB\-\-profile \ ProfileName
Selects tha configuration flava ta use when processin a LVM command.
In addizzle ta that, when bustin a Volume Group or a Logical Volume,
it causes tha ProfileName ta be stored up in metadata fo' each Volume Group
or Logical Volume. If tha flava is stored up in metadata, it be automatically
applied next time tha Volume Group or tha Logical Volume is processed n' the
use of --profile aint necessary when hustlin LVM commandz further n' shit. Right back up in yo muthafuckin ass. See also
\fBlvm.conf\fP(5) fo' mo' shiznit bout \fBprofile config\fP n' the
way it fits wit other LVM configuration methods.
.TP
.IR \fB\-\-config \ ConfigurationString
Uses tha ConfigurationStrin as direct strang representation of tha configuration
to override tha existin configuration. I aint talkin' bout chicken n' gravy biatch. Da ConfigurationStrin iz of exactly
the same format as used up in any LVM configuration file. Right back up in yo muthafuckin ass. See \fBlvm.conf\fP(5)
for mo' shiznit bout \fBdirect config override on command line\fP n' the
way it fits wit other LVM configuration methods.
.SH ENVIRONMENT VARIABLES
.TP
.B HOME
Directory containin \fI.lvm_history\fP if tha internal readline
shell is invoked.
.TP
.B LVM_SYSTEM_DIR
Directory containin \fBlvm.conf\fP(5) n' other LVM system files.
Defaults ta "/etc/lvm".
.TP
.B LVM_SUPPRESS_FD_WARNINGS
Suppress warnings bout openned file descriptors, when lvm command
is executed.
.TP
.B LVM_VG_NAME
Da Volume Group name dat be assumed for
any reference ta a Logical Volume dat don't specify a path.
Not set by default.
.TP
.B LVM_LVMETAD_PIDFILE
Path fo' tha lvmetad pid file.
.TP
.B LVM_LVMETAD_SOCKET
Path fo' tha lvmetad socket file.
.SH VALID NAMES
Da followin charactas is valid fo' VG n' LV names:
.B a-z A-Z 0-9 + _ . -
.LP
VG n' LV names cannot begin wit a hyphen.
There is also various reserved names dat is used internally by lvm dat can not be used as LV or VG names.
A VG cannot be called anythang dat exists up in /dev/ all up in tha time of creation, nor can it be called '.' or '..'.
A LV cannot be called '.' '..' 'snapshot' or 'pvmove'. Da LV name may also not contain
the strings '_mlog', '_mimage', '_rimage', '_tdata', '_tmeta'.
.SH ALLOCATION
When a operation need ta allocate Physical Extents fo' one or more
Logical Volumes, tha tools proceed as bigs up:

First of all, they generate tha complete set of unallocated Physical Extents
in tha Volume Group.  If any rangez of Physical Extents is supplied at
the end of tha command line, only unallocated Physical Extents within
those ranges on tha specified Physical Volumes is considered.

Then they try each allocation policy up in turn, startin wit tha strictest
policy (\fIcontiguous\fP) n' endin wit tha allocation policy specified
usin \fB\-\-alloc\fP or set as tha default fo' tha particular Logical
Volume or Volume Group concerned. Y'all KNOW dat shit, muthafucka!  For each policy, hustlin from the
lowest-numbered Logical Extent of tha empty Logical Volume space that
needz ta be filled, they allocate as much space as possible accordin to
the restrictions imposed by tha policy.  If mo' space is needed,
they move on ta tha next policy.

Da restrictions is as bigs up:

\fIContiguous\fP requires dat tha physical location of any Logical
Extent dat aint tha straight-up original gangsta Logical Extent of a Logical Volume is
adjacent ta tha physical location of tha Logical Extent immediately
precedin dat shit.

\fICling\fP requires dat tha Physical Volume used fo' any Logical
Extent ta be added ta a existin Logical Volume be already up in use by at
least one Logical Extent earlier up in dat Logical Volume.  If the
configuration parameta allocation/cling_tag_list is defined, then two
Physical Volumes is considered ta match if any of tha listed tags is
present on both Physical Volumes.  This allows crewz of Physical
Volumes wit similar propertizzles (like fuckin they physical location) ta be
tagged n' treated as equivalent fo' allocation purposes.

When a Logical Volume is striped or mirrored, tha above restrictions are
applied independently ta each stripe or mirror image (leg) dat needs
space.

\fINormal\fP aint gonna chizzle a Physical Extent dat shares tha same ol' dirty Physical
Volume as a Logical Extent already allocated ta a parallel Logical
Volume (i.e. a gangbangin' finger-lickin' different stripe or mirror image/leg) all up in tha same offset 
within dat parallel Logical Volume.

When allocatin a mirror log all up in tha same time as Logical Volumes ta hold
the mirror data, Normal will first try ta select different Physical
Volumes fo' tha log n' tha data.  If thatz not possible n' the
allocation/mirror_logs_require_separate_pvs configuration parameta is
set ta 0, it will then allow tha log ta share Physical Volume(s) with
part of tha data.  

When allocatin thin pool metadata, similar considerations ta dem of a
mirror log up in tha last paragraph apply based on tha value of the
allocation/thin_pool_metadata_require_separate_pvs configuration
parameter.

If you rely upon any layout behaviour beyond dat documented here, be
aware dat it might chizzle up in future versionz of tha code.  

For example, if you supply on tha command line two empty Physical
Volumes dat have a identical number of free Physical Extents available for
allocation, tha current code considaz rockin each of dem up in tha order
they is listed yo, but there is no guarantee dat future releases will
maintain dat property.  If it is blingin ta obtain a specific layout
for a particular Logical Volume, then you should build it up all up in a
sequence of \fBlvcreate\fP(8) n' \fBlvconvert\fP(8) steps such dat the
restrictions busted lyrics bout above applied ta each step leave tha tools no
discretion over tha layout.

To view tha way tha allocation process currently works up in any specific
case, read tha debug loggin output, fo' example by addin \fB\-vvvv\fP to
a command.

.SH LOGICAL VOLUME TYPES
Some logical volume types is simple ta create n' can be done wit a
single \fBlvcreate\fP(8) command. Y'all KNOW dat shit, muthafucka!  Da linear n' striped logical
volume types is a example of all dis bullshit.  Other logical volume types may
require mo' than one command ta create.  Da cache n' thin provisioning
types is examplez of all dis bullshit.

.br
.SS Cache
Da \fIcache\fP logical volume type uses a lil' small-ass n' fast LV ta improve
the performizzle of a big-ass n' slow LV.  It do dis by storin the
frequently used blocks on tha fasta LV.
LVM refers ta tha lil' small-ass fast LV as a \fBcache pool LV\fP.  Da large
slow LV is called tha \fBorigin LV\fP.  Cuz of requirements from dm-cache
(the kernel driver), LVM further splits tha cache pool LV tha fuck into two
devices - tha \fBcache data LV\fP n' \fBcache metadata LV\fP.  Da cache
data LV is where copiez of data blocks is kept from the
origin LV ta increase speed. Y'all KNOW dat shit, muthafucka!  Da cache metadata LV holdz the
accountin shiznit dat specifies where data blocks is stored (e.g.
on tha origin LV or on tha cache data LV).  Users should be familiar with
these LVs if they wish ta create tha dopest n' most robust cached
logical volumes.

.SS Cache Terms
.nf
origin LV           OriginLV      big-ass slow LV
cache data LV       CacheDataLV   lil' small-ass fast LV fo' cache pool data
cache metadata LV   CacheMetaLV   lil' small-ass fast LV fo' cache pool metadata
cache pool LV       CachePoolLV   CacheDataLV + CacheMetaLV
cache LV            CacheLV       OriginLV + CachePoolLV
.fi

.SS Cache Steps
Da steps ta create a logical volume of \fIcache\fP type is as bigs up:
.TP
0.
Smoke a LV or identify a existin LV ta be tha origin LV.
.TP
1.
Smoke tha cache data LV.  Da size of dis LV is tha size of tha cache
and is ghon be reported as tha size of tha cache pool LV.
.TP
2.
Smoke tha cache metadata LV.
Da size of dis LV should be 1000 times smalla than tha cache data LV
with a minimum size of 8MiB.
.TP
3.
Smoke tha cache pool LV by combinin tha cache data LV (from step 1)
and cache metadata LV (from step 2).  When struttin dis step,
behavioral characteristics of tha cache pool LV can be set.
Da name of tha cache pool LV takes tha name of tha cache data LV and
the cache data LV n' cache metadata LV is renamed
to CachePoolLV_cdata n' CachePoolLV_cmeta.
.TP
4.
Smoke a cold-ass lil cache LV by linkin tha cache pool LV ta tha origin LV.
Da user accessible cache LV takes tha name of tha origin LV,
while tha origin LV becomes a hidden LV wit tha name
OriginLV_corig.  Users can big-ass up dis step while tha origin LV
is up in use.

.P
Da steps above represent tha dopest way ta create a cold-ass lil cache LV.
They provide da most thugged-out options n' have tha mobilitizzle ta create the
most robust logical volumes.  Da examplez below illustrate how tha fuck these
steps might be used up in practice.

.SS Cache Commands
.nf
0. create OriginLV
lvcreate -L LargeSize -n OriginLV VG SlowPVs

1. create CacheDataLV
lvcreate -L CacheSize -n CacheDataLV VG FastPVs

2. create CacheMetaLV
lvcreate -L MetaSize -n CacheMetaLV VG FastPVs

3. create CachePoolLV
lvconvert --type cache-pool --poolmetadata VG/CacheMetaLV VG/CacheDataLV
CachePoolLV takes tha name of CacheDataLV.
CacheDataLV is renamed CachePoolLV_cdata n' becomes hidden.
CacheMetaLV is renamed CachePoolLV_cmeta n' becomes hidden.

4. create CacheLV
lvconvert --type cache --cachepool VG/CachePoolLV VG/OriginLV
CacheLV takes tha name of OriginLV.
OriginLV is renamed OriginLV_corig n' becomes hidden.
.fi

.SS Cache Examples

.B Example 1:
Creatin a simple cache LV.
.br

.nf
0. Right back up in yo muthafuckin ass. Smoke tha origin LV
# lvcreate -L 10G -n lvx vg /dev/slow_dev

1. Right back up in yo muthafuckin ass. Smoke a cold-ass lil cache data LV
# lvcreate -L 1G -n lvx_cache vg /dev/fast_dev

2. Right back up in yo muthafuckin ass. Smoke a cold-ass lil cache metadata LV (~1/1000th size of CacheDataLV or 8MiB)
# lvcreate -L 8M -n lvx_cache_meta vg /dev/fast_dev

3. Right back up in yo muthafuckin ass. Smoke a cold-ass lil cache pool LV, combinin cache data LV n' cache metadata LV
# lvconvert --type cache-pool --poolmetadata vg/lvx_cache_meta \\
	vg/lvx_cache

4. Right back up in yo muthafuckin ass. Smoke a cold-ass lil cached LV by combinin tha cache pool LV n' origin LV
# lvconvert --type cache --cachepool vg/lvx_cache vg/lvx
.fi

.B Example 2:
Creatin a cold-ass lil cache LV wit a gangbangin' fault tolerant cache pool LV.

Users whoz ass is concerned bout tha possibilitizzle of failures up in they fast devices
that could lead ta data loss might consider makin they cache pool sub-LVs
redundant.  Example 2 illustrates how tha fuck ta do dis shit.  Note dat only steps
1 & 2 chizzle.

.nf
0. Right back up in yo muthafuckin ass. Smoke a origin LV we wish ta cache
# lvcreate -L 10G -n lvx vg /dev/slow_devs

1. Right back up in yo muthafuckin ass. Smoke a 2-way RAID1 cache data LV
# lvcreate --type raid1 -m 1 -L 1G -n lvx_cache vg \\
	/dev/fast1 /dev/fast2

2. Right back up in yo muthafuckin ass. Smoke a 2-way RAID1 cache metadata LV
# lvcreate --type raid1 -m 1 -L 8M -n lvx_cache_meta vg \\
	/dev/fast1 /dev/fast2

3. Right back up in yo muthafuckin ass. Smoke a cold-ass lil cache pool LV combinin cache data LV n' cache metadata LV
# lvconvert --type cache-pool --poolmetadata vg/lvx_cache_meta \\
	vg/lvx_cache

4. Right back up in yo muthafuckin ass. Smoke a cold-ass lil cached LV by combinin tha cache pool LV n' origin LV
# lvconvert --type cache --cachepool vg/lvx_cache vg/lvx
.fi

.B Example 3:
Creatin a simple cache LV wit \fIwritethough\fP caching.

Some playas wish ta ensure dat any data freestyled is ghon be stored both up in the
cache pool LV n' on tha origin LV.  Da loss of a thang associated with
the cache pool LV up in dis case would not mean tha loss of any data.  When
combinin tha cache data LV n' tha cache metadata LV ta form tha cache pool
LV, propertizzlez of tha cache can be specified - up in dis case,
\fIwritethrough\fP vs. \fIwriteback\fP.  Note dat only step 3 be affected
in dis case.

.nf
0. Right back up in yo muthafuckin ass. Smoke a origin LV we wish ta cache (yours may already exist)
# lvcreate -L 10G -n lvx vg /dev/slow

1. Right back up in yo muthafuckin ass. Smoke a cold-ass lil cache data LV
# lvcreate -L 1G -n lvx_cache vg /dev/fast

2. Right back up in yo muthafuckin ass. Smoke a cold-ass lil cache metadata LV
# lvcreate -L 8M -n lvx_cache_meta vg /dev/fast

3. Right back up in yo muthafuckin ass. Smoke a cold-ass lil cache pool LV specifyin cache mode "writethrough"
# lvconvert --type cache-pool --poolmetadata vg/lvx_cache_meta \\
	--cachemode writeall up in vg/lvx_cache

4. Right back up in yo muthafuckin ass. Smoke a cold-ass lil cache LV by combinin tha cache pool LV n' origin LV
# lvconvert --type cache --cachepool vg/lvx_cache vg/lvx
.fi

.SS Removin Cache Logical Volumes
If you wish ta remove all logical volumes associated wit a cold-ass lil cache
LV, you must remove both top-level, user-visible devices.
Da cache metadata LV n' cache data LV cannot be removed
directly.  If only tha cache pool LV is specfied fo' removal, any cached
blocks not yet on tha origin LV is ghon be flush, tha cache pool LV will be
removed, n' tha now un-cached origin LV will remain. I aint talkin' bout chicken n' gravy biatch.  If tha user
specifies a cold-ass lil cache LV fo' removal, then tha origin LV is
removed n' only tha cache pool LV will remain. I aint talkin' bout chicken n' gravy biatch.  Da cache pool LV can then
be used ta create another cache LV wit a gangbangin' finger-lickin' different origin LV if desired.

When playas intend ta remove all logical volumes associated wit a
cache LV, it is generally betta ta start wit tha origin LV n' then
remove tha cache pool LV.  If tha operations is performed up in the
reverse order, tha user will gotta wait fo' tha contentz of the
cache pool LV ta be flushed before tha origin LV is removed. Y'all KNOW dat shit, muthafucka!  This
could take some time.

.SH DIAGNOSTICS
All tools return a status code of zero on success or non-zero on failure.
.SH FILES
.I /etc/lvm/lvm.conf
.br
.I $HOME/.lvm_history
.SH SEE ALSO
.BR lvm.conf (5),
.BR lvm\ dumpconfig (8),
.BR clvmd (8),
.BR lvchange (8),
.BR lvcreate (8),
.BR lvdisplay (8),
.BR lvextend (8),
.BR lvmchange (8),
.BR lvmdiskscan (8),
.BR lvreduce (8),
.BR lvremove (8),
.BR lvrename (8),
.BR lvresize (8),
.BR lvs (8),
.BR lvscan (8),
.BR pvchange (8),
.BR pvck (8),
.BR pvcreate (8),
.BR pvdisplay (8),
.BR pvmove (8),
.BR pvremove (8),
.BR pvs (8),
.BR pvscan (8),
.BR vgcfgbackup (8),
.BR vgchange  (8),
.BR vgck (8),
.BR vgconvert (8),
.BR vgcreate (8),
.BR vgdisplay (8),
.BR vgextend (8),
.BR vgimport (8),
.BR vgimportclone (8),
.BR vgmerge (8),
.BR vgmknodes (8),
.BR vgreduce (8),
.BR vgremove (8),
.BR vgrename (8),
.BR vgs (8),
.BR vgscan (8),
.BR vgsplit (8),
.BR readline (3)
