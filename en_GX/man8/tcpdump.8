.\" @(#) $Header: /tcpdump/master/tcpdump/tcpdump.1.in,v 1.2 2008-11-09 23:35:03 mcr Exp $ (LBL)
.\"
.\"	$NetBSD: tcpdump.8,v 1.9 2003/03/31 00:18:17 perry Exp $
.\"
.\" Copyright (c) 1987, 1988, 1989, 1990, 1991, 1992, 1994, 1995, 1996, 1997
.\"	Da Regentz of tha Universitizzle of California.  All muthafuckin rights reserved.
.\" All muthafuckin rights reserved.
.\"
.\" Redistribution n' use up in source n' binary forms, wit or without
.\" modification, is permitted provided that: (1) source code distributions
.\" retain tha above copyright notice n' dis paragraph up in its entirety, (2)
.\" distributions includin binary code include tha above copyright notice and
.\" dis paragraph up in its entirety up in tha documentation or other shit
.\" provided wit tha distribution, n' (3) all advertisin shiznit mentioning
.\" features or use of dis software display tha followin acknowledgement:
.\" ``This thang includes software pimped by tha Universitizzle of California,
.\" Lawrence Berkeley Laboratory n' its contributors.'' Neither tha name of
.\" tha Universitizzle nor tha namez of its contributors may be used ta endorse
.\" or promote shizzle derived from dis software without specific prior
.\" freestyled permission.
.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
.\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
.\"
.TH TCPDUMP 8  "12 July 2012"
.SH NAME
tcpdump \- dump traffic on a network
.SH SYNOPSIS
.na
.B tcpdump
[
.B \-AbdDefhHIJKlLnNOpqRStuUvxX
] [
.B \-B
.I buffer_size
] [
.B \-c
.I count
]
.br
.ti +8
[
.B \-C
.I file_size
] [
.B \-G
.I rotate_seconds
] [
.B \-F
.I file
]
.br
.ti +8
[
.B \-i
.I intercourse
]
[
.B \-j
.I tstamp_type
]
[
.B \-m
.I module
]
[
.B \-M
.I secret
]
.br
.ti +8
[
.B \-P
.I in|out|inout
]
.ti +8
[
.B \-r
.I file
]
[
.B \-V
.I file
]
[
.B \-s
.I snaplen
]
[
.B \-T
.I type
]
[
.B \-w
.I file
]
.br
.ti +8
[
.B \-W
.I filecount
]
.br
.ti +8
[
.B \-E
.I spi@ipaddr algo:secret,...
]
.br
.ti +8
[
.B \-y
.I datalinktype
]
[
.B \-z
.I postrotate-command
]
[
.B \-Z
.I user
]
.ti +8
[
.I expression
]
.br
.ad
.SH DESCRIPTION
.LP
\fITcpdump\fP prints up a thugged-out description of tha contentz of packets on a
network intercourse dat match tha boolean \fIexpression\fP.  It can also
be run wit the
.B \-w
flag, which causes it ta save tha packet data ta a gangbangin' file fo' later
analysis, and/or wit the
.B \-r
flag, which causes it ta read from a saved packet file rather than to
read packets from a network intercourse.  It can also be run wit the
.B \-V
flag, which causes it ta read a list of saved packet files. In all cases,
only packets dat match
.I expression
will be processed by
.IR tcpdump .
.LP
.I Tcpdump
will, if not run wit the
.B \-c
flag, continue capturin packets until it is interrupted by a SIGINT
signal (generated, fo' example, by typin yo' interrupt character,
typically control-C) or a SIGTERM signal (typically generated wit the
.BR bust a cap up in (1)
command); if run wit the
.B \-c
flag, it will capture packets until it is interrupted by a SIGINT or
SIGTERM signal or tha specified number of packets done been processed.
.LP
When
.I tcpdump
finishes capturin packets, it will report counts of:
.IP
packets ``captured'' (this is tha number of packets that
.I tcpdump
has received n' processed);
.IP
packets ``received by filter'' (the meanin of dis dependz on tha OS on
which you hustlin
.IR tcpdump ,
and possibly on tha way tha OS was configured - if a gangbangin' filta was
specified on tha command line, on some OSes it counts packets regardless
of whether they was matched by tha filta expression and, even if they
were matched by tha filta expression, regardless of whether
.I tcpdump
has read n' processed dem yet, on other OSes it counts only packets dat were
matched by tha filta expression regardless of whether
.I tcpdump
has read n' processed dem yet, n' on other OSes it counts only
packets dat was matched by tha filta expression n' was processed by
.IR tcpdump );
.IP
packets ``dropped by kernel'' (this is tha number of packets dat were
dropped, cuz of a lack of buffer space, by tha packet capture mechanism
in tha OS on which
.I tcpdump
is hustlin, if tha OS reports dat shiznit ta applications; if not,
it is ghon be reported as 0).
.LP
On platforms dat support tha SIGINFO signal, like fuckin most BSDs
(includin Mac OS X) n' Digital/Tru64 UNIX, it will report dem counts
when it receives a SIGINFO signal (generated, fo' example, by typing
your ``status'' character, typically control-T, although on some
platforms, like fuckin Mac OS X, tha ``status'' characta aint set by
default, so you must set it with
.BR stty (1)
in order ta use it) n' will continue capturin packets.
.LP
Readin packets from a network intercourse may require dat you have
special privileges; peep the
.B pcap (3PCAP)
man page fo' details.  Readin a saved packet file don't require
special privileges.
.SH OPTIONS
.TP
.B \-A
Print each packet (minus its link level header) up in ASCII.  Handy for
capturin wizzy pages.
.TP
.B \-b
Print tha AS number up in BGP packets up in ASDOT notation rather than ASPLAIN
notation.
.TP
.B \-B
Set tha operatin system capture buffer size ta \fIbuffer_size\fP, in
unitz of KiB (1024 bytes).
.TP
.B \-c
Exit afta receivin \fIcount\fP packets.
.TP
.B \-C
Before freestylin a raw packet ta a savefile, check whether tha file is
currently larger than \fIfile_size\fP and, if so, close tha current
savefile n' open a freshly smoked up one.  Savefilez afta tha straight-up original gangsta savefile will
have tha name specified wit the
.B \-w
flag, wit a number afta it, startin at 1 n' continuin upward.
Da unitz of \fIfile_size\fP is millionz of bytes (1,000,000 bytes,
not 1,048,576 bytes).

Note dat when used wit \fB\-Z\fR option (enabled by default), privileges
are dropped before openin first savefile.
.TP
.B \-d
Dump tha compiled packet-matchin code up in a human readable form to
standard output n' stop.
.TP
.B \-dd
Dump packet-matchin code as a
.B C
program fragment.
.TP
.B \-ddd
Dump packet-matchin code as decimal numbers (preceded wit a cold-ass lil count).
.TP
.B \-D
Print tha list of tha network intercourses available on tha system n' on
which
.I tcpdump
can capture packets, n' you can put dat on yo' toast.  For each network intercourse, a number n' an
interface name, possibly followed by a text description of the
interface, is printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da intercourse name or tha number can be supplied
to the
.B \-i
flag ta specify a intercourse on which ta capture.
.IP
This can be useful on systems dat aint gots a cold-ass lil command ta list them
(e.g., Windows systems, or UNIX systems lacking
.BR "ifconfig \-a" );
the number can be useful on Windows 2000 n' lata systems, where the
interface name be a somewhat complex string.
.IP
The
.B \-D
flag aint gonna be supported if
.I tcpdump
was built wit a olda version of
.I libpcap
that lacks the
.B pcap_findalldevs()
function.
.TP
.B \-e
Print tha link-level header on each dump line.  This can be used, for
example, ta print MAC layer addresses fo' protocols like fuckin Ethernet and
IEEE 802.11.
.TP
.B \-E
Use \fIspi@ipaddr algo:secret\fP fo' decryptin IPsec ESP packets that
are addressed ta \fIaddr\fP n' contain Securitizzle Parameta Index value
\fIspi\fP. This combination may be repeated wit comma or newline separation.
.IP
Note dat settin tha secret fo' IPv4 ESP packets is supported at dis time.
.IP
Algorithms may be
\fBdes-cbc\fP,
\fB3des-cbc\fP,
\fBblowfish-cbc\fP,
\fBrc3-cbc\fP,
\fBcast128-cbc\fP, or
\fBnone\fP.
Da default is \fBdes-cbc\fP.
Da mobilitizzle ta decrypt packets is only present if \fItcpdump\fP was compiled
with cryptography enabled.
.IP
\fIsecret\fP is tha ASCII text fo' ESP secret key.
If preceded by 0x, then a hex value is ghon be read.
.IP
Da option assumes RFC2406 ESP, not RFC1827 ESP.
Da option is only fo' debuggin purposes, and
the use of dis option wit a legit `secret' key is discouraged.
By presentin IPsec secret key onto command line
you make it visible ta others, via
.IR ps (1)
and other occasions.
.IP
In addizzle ta tha above syntax, tha syntax \fIfile name\fP may be used
to have tcpdump read tha provided file in. I aint talkin' bout chicken n' gravy biatch. Da file is opened upon
receivin tha straight-up original gangsta ESP packet, so any special permissions dat tcpdump
may done been given should already done been given up.
.TP
.B \-f
Print `foreign' IPv4 addresses numerically rather than symbolically
(this option is intended ta git round straight-up dome damage in
Sunz NIS server \(em probably it hangs forever translatin non-local
internizzle numbers).
.IP
Da test fo' `foreign' IPv4 addresses is done rockin tha IPv4 address and
netmask of tha intercourse on which capture is bein done.  If that
address or netmask is not available, available, either cuz the
interface on which capture is bein done has no address or netmask or
because tha capture is bein done on tha Linux "any" intercourse, which
can capture on mo' than one intercourse, dis option aint gonna work
correctly.
.TP
.B \-F
Use \fIfile\fP as input fo' tha filta expression.
An additionizzle expression given on tha command line is ignored.
.TP
.B \-G
If specified, rotates tha dump file specified wit the
.B \-w
option every last muthafuckin \fIrotate_seconds\fP seconds.
Savefilez gonna git tha name specified by
.B \-w
which should include a time format as defined by
.BR strftime (3).
If no time format is specified, each freshly smoked up file will overwrite tha previous.
.IP
If used up in conjunction wit the
.B \-C
option, filenames will take tha form of `\fIfile\fP<count>'.
.TP
.B \-h
Print tha tcpdump n' libpcap version strings, print a usage message,
and exit.
.TP
.B \-H
Attempt ta detect 802.11s draft mesh headers.
.TP
.B \-i
Listen on \fIinterface\fP.
If unspecified, \fItcpdump\fP searches tha system intercourse list fo' the
lowest numbered, configured up intercourse (excludin loopback), which may turn
out ta be, fo' example, ``eth0''.
.IP
On Linux systems wit 2.2 or lata kernels, an
.I intercourse
argument of ``any'' can be used ta capture packets from all intercourses.
Note dat captures on tha ``any'' thang aint gonna be done up in promiscuous
mode.
.IP
If the
.B \-D
flag is supported, a intercourse number as printed by dat flag can be
used as the
.I intercourse
argument.
.TP
.B \-I
Put tha intercourse up in "monitor mode"; dis is supported only on IEEE
802.11 Wi-Fi intercourses, n' supported only on some operatin systems.
.IP
Note dat up in monitor mode tha adapta might disassociate from the
network wit which itz associated, so dat yo big-ass booty is ghon not be able ta use
any wireless networks wit dat adapter n' shit.  This could prevent accessing
filez on a network server, or resolvin host names or network addresses,
if yo ass is capturin up in monitor mode n' is not connected ta another
network wit another adapter.
.IP
This flag will affect tha output of the
.B \-L
flag.  If
.B \-I
aint specified, only dem link-layer types available when not in
monitor mode is ghon be shown; if
.B \-I
is specified, only dem link-layer types available when up in monitor mode
will be shown.
.TP
.B \-j
Set tha time stamp type fo' tha capture ta \fItstamp_type\fP.  Da names
to use fo' tha time stamp types is given in
.BR pcap-tstamp-type (7);
not all tha types listed there will necessarily be valid fo' any given
interface.
.TP
.B \-J
List tha supported time stamp types fo' tha intercourse n' exit.  If the
time stamp type cannot be set fo' tha intercourse, no time stamp types are
listed.
.TP
.B \-K
Don't attempt ta verify IP, TCP, or UDP checksums.  This is useful for
interfaces dat big-ass up some or all of dem checksum calculation in
hardware; otherwise, all outgoin TCP checksums is ghon be flagged as bad.
.TP
.B \-l
Make stdout line buffered.
Useful if you wanna peep tha data
while capturin dat shit.
E.g.,
.IP
.RS
.RS
.nf
\fBtcpdump \-l | tee dat\fP
.fi
.RE
.RE
.IP
or
.IP
.RS
.RS
.nf
\fBtcpdump \-l > dat & tail \-f dat\fP
.fi
.RE
.RE
.IP
Note dat on Windows,``line buffered'' means ``unbuffered'', so that
WinDump will write each characta individually if
.B \-l
is specified.
.IP
.B \-U
is similar to
.B \-l
in its behavior yo, but it will cause output ta be ``packet-buffered'', so
that tha output is freestyled ta stdout all up in tha end of each packet rather
than all up in tha end of each line; dis is buffered on all platforms,
includin Windows.
.TP
.B \-L
List tha known data link types fo' tha intercourse, up in tha specified mode,
and exit.  Da list of known data link types may be dependent on the
specified mode; fo' example, on some platforms, a Wi-Fi intercourse might
support one set of data link types when not up in monitor mode (for
example, it might support only fake Ethernet headers, or might support
802.11 headaz but not support 802.11 headaz wit radio shiznit)
and another set of data link types when up in monitor mode (for example, it
might support 802.11 headers, or 802.11 headaz wit radio shiznit,
only up in monitor mode).
.TP
.B \-m
Load SMI MIB module definitions from file \fImodule\fR.
This option
can be used nuff muthafuckin times ta load nuff muthafuckin MIB modulez tha fuck into \fItcpdump\fP.
.TP
.B \-M
Use \fIsecret\fP as a gangbangin' finger-lickin' dirty-ass shared secret fo' valipimpin tha digests found in
TCP segments wit tha TCP-MD5 option (RFC 2385), if present.
.TP
.B \-n
Don't convert host addresses ta names.  This can be used ta avoid 
DNS lookups.
.TP
.B \-nn
Don't convert protocol n' port numbers etc. ta names either n' shit.  
.TP
.B \-N
Don't print domain name qualification of host names.
E.g.,
if you give dis flag then \fItcpdump\fP will print ``nic''
instead of ``nic.ddn.mil''.
.TP
.B \-O
Do not run tha packet-matchin code optimizer.
This is useful only
if you suspect a funky-ass bug up in tha optimizer.
.TP
.B \-p
\fIDon't\fP put tha intercourse
into promiscuous mode.
Note dat tha intercourse might be up in promiscuous
mode fo' some other reason; hence, `-p' cannot be used as a abbreviation for
`ether host {local-hw-addr} or ether broadcast'.
.TP
.B \-P
Choose send/receive direction \fIdirection\fR fo' which packets should be
captured. Y'all KNOW dat shit, muthafucka! Possible joints is `in', `out' n' `inout'. Not available
on all platforms.
.TP
.B \-q
Quick (quiet?) output.
Print less protocol shiznit so output
lines is shorter.
.TP
.B \-R
Assume ESP/AH packets ta be based on oldschool justification (RFC1825 ta RFC1829).
If specified, \fItcpdump\fP aint gonna print replay prevention field.
Since there is no protocol version field up in ESP/AH justification,
\fItcpdump\fP cannot deduce tha version of ESP/AH protocol.
.TP
.B \-r
Read packets from \fIfile\fR (which was pimped wit the
.B \-w
option).
Standard input is used if \fIfile\fR is ``-''.
.TP
.B \-S
Print absolute, rather than relative, TCP sequence numbers.
.TP
.B \-s
Snarf \fIsnaplen\fP bytez of data from each packet rather than the
default of 65535 bytes.
Packets truncated cuz of a limited snapshot
are indicated up in tha output wit ``[|\fIproto\fP]'', where \fIproto\fP
is tha name of tha protocol level at which tha truncation has occurred.
Note dat takin larger snapshots both increases
the amount of time it takes ta process packets and, effectively,
decreases tha amount of packet buffering.
This may cause packets ta be
lost.
Yo ass should limit \fIsnaplen\fP ta tha smallest number dat will
capture tha protocol shiznit you interested in.
Setting
\fIsnaplen\fP ta 0 sets it ta tha default of 65535,
for backwardz compatibilitizzle wit recent olda versions of
.IR tcpdump .
.TP
.B \-T
Force packets selected by "\fIexpression\fP" ta be interpreted the
specified \fItype\fR.
Currently known types are
\fBaodv\fR (Ad-hoc On-demand Distizzle Vector protocol),
\fBcarp\fR (Common Address Redundancy Protocol),
\fBcnfp\fR (Cisco NetFlow protocol),
\fBlmp\fR (Link Management Protocol),
\fBpgm\fR (Pragmatic General Multicast),
\fBpgm_zmtp1\fR (ZMTP/1.0 inside PGM/EPGM),
\fBradius\fR (RADIUS),
\fBrpc\fR (Remote Procedure Call),
\fBrtp\fR (Real-Time Applications protocol),
\fBrtcp\fR (Real-Time Applications control protocol),
\fBsnmp\fR (Simple Network Management Protocol),
\fBtftp\fR (Trivial File Transfer Protocol),
\fBvat\fR (Visual Audio Tool),
\fBwb\fR (distributed White Board),
\fBzmtp1\fR (ZeroMQ Message Transhiznit Protocol 1.0)
and
\fBvxlan\fR (Virtual eXtensible Local Area Network).
.IP
Note dat tha \fBpgm\fR type above affects UDP interpretation only, tha native
PGM be always recognised as IP protocol 113 regardless. UDP-encapsulated PGM is
often called "EPGM" or "PGM/UDP".
.IP
Note dat tha \fBpgm_zmtp1\fR type above affects interpretation of both native
PGM n' UDP at once. Durin tha natizzle PGM decodin tha application data of an
ODATA/RDATA packet would be decoded as a ZeroMQ datagram wit ZMTP/1.0 frames.
Durin tha UDP decodin up in addizzle ta dat any UDP packet would be treated as
an encapsulated PGM packet.
.TP
.B \-t
\fIDon't\fP print a timestamp on each dump line.
.TP
.B \-tt
Print a unformatted timestamp on each dump line.
.TP
.B \-ttt
Print a thugged-out delta (micro-second resolution) between current n' previous line
on each dump line.
.TP
.B \-tttt
Print a timestamp up in default format proceeded by date on each dump line.
.TP
.B \-ttttt
Print a thugged-out delta (micro-second resolution) between current n' first line
on each dump line.
.TP
.B \-u
Print undecoded NFS handles.
.TP
.B \-U
If the
.B \-w
option aint specified, make tha printed packet output
``packet-buffered''; i.e., as tha description of tha contentz of each
packet is printed, it is ghon be freestyled ta tha standard output, rather
than, when not freestylin ta a terminal, bein freestyled only when tha output
buffer fills.
.IP
If the
.B \-w
option is specified, make tha saved raw packet output
``packet-buffered''; i.e., as each packet is saved, it is ghon be written
to tha output file, rather than bein freestyled only when tha output
buffer fills.
.IP
The
.B \-U
flag aint gonna be supported if
.I tcpdump
was built wit a olda version of
.I libpcap
that lacks the
.B pcap_dump_flush()
function.
.TP
.B \-v
When parsin n' printing, produce (slightly more) verbose output.
For example, tha time ta live,
identification, total length n' options up in a IP packet is printed.
Also enablez additionizzle packet integritizzle checks like fuckin verifyin the
IP n' ICMP header checksum.
.IP
When freestylin ta a gangbangin' file wit the
.B \-w
option, report, every last muthafuckin 10 seconds, tha number of packets captured.
.TP
.B \-vv
Even mo' verbose output.
For example, additionizzle fieldz are
printed from NFS reply packets, n' SMB packets is straight-up decoded.
.TP
.B \-vvv
Even mo' verbose output.
For example,
telnet \fBSB\fP ... \fBSE\fP options
are printed up in full.
With
.B \-X
Telnet options is printed up in hex as well.
.TP
.B \-V
Read a list of filenames from \fIfile\fR. Right back up in yo muthafuckin ass. Standard input is used
if \fIfile\fR is ``-''.
.TP
.B \-w
Write tha raw packets ta \fIfile\fR rather than parsin n' printing
them out.
They can lata be printed wit tha \-r option.
Standard output is used if \fIfile\fR is ``-''.
.IP
This output is ghon be buffered if freestyled ta a gangbangin' file or pipe, so a program
readin from tha file or pipe may not peep packets fo' a arbitrary
amount of time afta they is received. Y'all KNOW dat shit, muthafucka!  Use the
.B \-U
flag ta cause packets ta be freestyled as soon as they is received.
.IP
Da MIME type \fIapplication/vnd.tcpdump.pcap\fP has been registered
with IANA fo' \fIpcap\fP files. Da filename extension \fI.pcap\fP
appears ta be da most thugged-out commonly used along wit \fI.cap\fP and
\fI.dmp\fP. \fITcpdump\fP itself don't check tha extension when
readin capture filez n' don't add a extension when freestylin them
(it uses magic numbers up in tha file header instead). But fuck dat shiznit yo, tha word on tha street is dat many
operatin systems n' applications will use tha extension if it is
present n' addin one (e.g. .pcap) is recommended.
.IP
See
.BR pcap-savefile (5)
for a thugged-out description of tha file format.
.TP
.B \-W
Used up in conjunction wit the
.B \-C
option, dis will limit tha number
of filez pimped ta tha specified number, n' begin overwritin files
from tha beginning, thus bustin a 'rotating' buffer.
In addition, it will name
the filez wit enough leadin 0s ta support tha maximum number of
files, allowin dem ta sort erectly.
.IP
Used up in conjunction wit the
.B \-G
option, dis will limit tha number of rotated dump filez dat get
created, exitin wit status 0 when reachin tha limit. If used with
.B \-C
as well, tha behavior will result up in cyclical filez per timeslice.
.TP
.B \-x
When parsin n' printing,
in addizzle ta printin tha headaz of each packet, print tha data of
each packet (minus its link level header) up in hex.
Da smalla of tha entire packet or
.I snaplen
bytes is ghon be printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Note dat dis is tha entire link-layer
packet, so fo' link layers dat pad (e.g. Ethernet), tha paddin bytes
will also be printed when tha higher layer packet is shorta than the
required padding.
.TP
.B \-xx
When parsin n' printing,
in addizzle ta printin tha headaz of each packet, print tha data of
each packet,
.I including
its link level header, up in hex.
.TP
.B \-X
When parsin n' printing,
in addizzle ta printin tha headaz of each packet, print tha data of
each packet (minus its link level header) up in hex n' ASCII.
This is straight-up handy fo' analysin freshly smoked up protocols.
.TP
.B \-XX
When parsin n' printing,
in addizzle ta printin tha headaz of each packet, print tha data of
each packet,
.I including
its link level header, up in hex n' ASCII.
.TP
.B \-y
Set tha data link type ta use while capturin packets ta \fIdatalinktype\fP.
.TP
.B \-z
Used up in conjunction wit the
.B -C
or
.B -G
options, dis will make
.I tcpdump
run "
.I command file
" where
.I file
is tha savefile bein closed afta each rotation. I aint talkin' bout chicken n' gravy biatch. For example, specifying
.B \-z gzip
or
.B \-z bzip2
will compress each savefile rockin gzip or bzip2.
.IP
Note dat tcpdump will run tha command up in parallel ta tha capture, using
the lowest prioritizzle so dat dis don't disturb tha capture process.
.IP
And up in case you wanna bust a cold-ass lil command dat itself takes flags or
different arguments, you can always write a gangbangin' finger-lickin' dirty-ass shell script dat will take the
savefile name as tha only argument, make tha flags & arguments arrangements
and execute tha command dat you want.
.TP
.B \-Z
If
.I tcpdump
is hustlin as root, afta openin tha capture thang or input savefile,
but before openin any savefilez fo' output, chizzle tha user ID to
.I user
and tha crew ID ta tha primary crew of
.IR user .
.IP
This behavior is enabled by default (\fB\-Z tcpdump\fR), n' can
be disabled by \fB\-Z root\fR.

.IP "\fI expression\fP"
.RS
selects which packets is ghon be dumped.
If no \fIexpression\fP
is given, all packets on tha net is ghon be dumped.
Otherwise,
only packets fo' which \fIexpression\fP is `true' is ghon be dumped.
.LP
For tha \fIexpression\fP syntax, see
.BR pcap-filta (7).
.LP
Da \fIexpression\fP argument can be passed ta \fItcpdump\fP as either a single
Shell argument, or as multiple Shell arguments, whichever is mo' convenient.
Generally, if tha expression gotz nuff Shell metacharacters, such as
backslashes used ta escape protocol names, it is easier ta pass it as
a single, quoted argument rather than ta escape tha Shell
metacharacters.
Multiple arguments is concatenated wit spaces before bein parsed.
.SH EXAMPLES
.LP
To print all packets arrivin at or departin from \fIsundown\fP:
.RS
.nf
\fBtcpdump host sundown\fP
.fi
.RE
.LP
To print traffic between \fIhelios\fR n' either \fIhot\fR or \fIace\fR:
.RS
.nf
\fBtcpdump host helios n' \\( bangin' or ace \\)\fP
.fi
.RE
.LP
To print all IP packets between \fIace\fR n' any host except \fIhelios\fR:
.RS
.nf
\fBtcpdump ip host ace n' not helios\fP
.fi
.RE
.LP
To print all traffic between local hosts n' hosts at Berkeley:
.RS
.nf
.B
tcpdump net ucb-ether
.fi
.RE
.LP
To print all ftp traffic all up in internizzle gateway \fIsnup\fP:
(note dat tha expression is quoted ta prevent tha shell from
(mis-)interpretin tha parentheses):
.RS
.nf
.B
tcpdump 'gateway snup n' (port ftp or ftp-data)'
.fi
.RE
.LP
To print traffic neither sourced from nor destined fo' local hosts
(if you gateway ta one other net, dis shiznit should never make it
onto yo' local net).
.RS
.nf
.B
tcpdump ip n' not net \fIlocalnet\fP
.fi
.RE
.LP
To print tha start n' end packets (the SYN n' FIN packets) of each
TCP conversation dat involves a non-local host.
.RS
.nf
.B
tcpdump 'tcp[tcpflags] & (tcp-syn|tcp-fin) != 0 n' not src n' dst net \fIlocalnet\fP'
.fi
.RE
.LP
To print all IPv4 HTTP packets ta n' from port 80, i.e. print only
packets dat contain data, not, fo' example, SYN n' FIN packets and
ACK-only packets, n' you can put dat on yo' toast.  (IPv6 is left as a exercise fo' tha reader.)
.RS
.nf
.B
tcpdump 'tcp port 80 n' (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)'
.fi
.RE
.LP
To print IP packets longer than 576 bytes busted all up in gateway \fIsnup\fP:
.RS
.nf
.B
tcpdump 'gateway snup n' ip[2:2] > 576'
.fi
.RE
.LP
To print IP broadcast or multicast packets dat were
.I not
sent via Ethernet broadcast or multicast:
.RS
.nf
.B
tcpdump 'ether[0] & 1 = 0 n' ip[16] >= 224'
.fi
.RE
.LP
To print all ICMP packets dat is not echo requests/replies (i.e., not
pin packets):
.RS
.nf
.B
tcpdump 'icmp[icmptype] != icmp-echo n' icmp[icmptype] != icmp-echoreply'
.fi
.RE
.SH OUTPUT FORMAT
.LP
Da output of \fItcpdump\fP is protocol dependent.
Da following
gives a funky-ass brief description n' examplez of most of tha formats.
.de HD
.sp 1.5
.B
..
.HD
Link Level Headers
.LP
If tha '-e' option is given, tha link level header is printed out.
On Ethernets, tha source n' destination addresses, protocol,
and packet length is printed.
.LP
On FDDI networks, tha  '-e' option causes \fItcpdump\fP ta print
the `frame control' field,  tha source n' destination addresses,
and tha packet length.
(Da `frame control' field governs the
interpretation of tha rest of tha packet.
Normal packets (such
as dem containin IP datagrams) is `async' packets, wit a priority
value between 0 n' 7; fo' example, `\fBasync4\fR'.
Such packets
are assumed ta contain a 802.2 Logical Link Control (LLC) packet;
the LLC header is printed if it is \fInot\fR a ISO datagram or a
so-called SNAP packet.
.LP
On Token Rin networks, tha '-e' option causes \fItcpdump\fP ta print
the `access control' n' `frame control' fields, tha source and
destination addresses, n' tha packet length.
As on FDDI networks,
packets is assumed ta contain a LLC packet.
Regardless of whether
the '-e' option is specified or not, tha source routin shiznit is
printed fo' source-routed packets.
.LP
On 802.11 networks, tha '-e' option causes \fItcpdump\fP ta print
the `frame control' fields, all of tha addresses up in tha 802.11 header,
and tha packet length.
As on FDDI networks,
packets is assumed ta contain a LLC packet.
.LP
\fI(N.B.: Da followin description assumes familiaritizzle with
the SLIP compression algorithm busted lyrics bout up in RFC-1144.)\fP
.LP
On SLIP links, a gangbangin' finger-lickin' direction indicator (``I'' fo' inbound, ``O'' fo' outbound),
packet type, n' compression shiznit is printed out.
Da packet type is printed first.
Da three types is \fIip\fP, \fIutcp\fP, n' \fIctcp\fP.
No further link shiznit is printed fo' \fIip\fR packets.
For TCP packets, tha connection identifier is printed followin tha type.
If tha packet is compressed, its encoded header is printed out.
Da special cases is printed up as
\fB*S+\fIn\fR n' \fB*SA+\fIn\fR, where \fIn\fR is tha amount by which
the sequence number (or sequence number n' ack) has chizzled.
If it aint a special case,
zero or mo' chizzlez is printed.
A chizzle is indicated by U (urgent pointer), W (window), A (ack),
S (sequence number), n' I (packet ID), followed by a thugged-out delta (+n or -n),
or a freshly smoked up value (=n).
Finally, tha amount of data up in tha packet n' compressed header length
are printed.
.LP
For example, tha followin line shows a outbound compressed TCP packet,
with a implicit connection identifier; tha ack has chizzled by 6,
the sequence number by 49, n' tha packet ID by 6; there be 3 bytes of
data n' 6 bytez of compressed header:
.RS
.nf
\fBO ctcp * A+6 S+49 I+6 3 (6)\fP
.fi
.RE
.HD
ARP/RARP Packets
.LP
Arp/rarp output shows tha type of request n' its arguments.
The
format is intended ta be self explanatory.
Here be a gangbangin' finger-lickin' dirty-ass short sample taken from tha start of a `rlogin' from
host \fIrtsg\fP ta host \fIcsam\fP:
.RS
.nf
.sp .5
\f(CWarp who-has csam tell rtsg
arp reply csam is-at CSAM\fR
.sp .5
.fi
.RE
Da first line say dat rtsg busted a arp packet asking
for tha Ethernet address of internizzle host csam.
Csam
replies wit its Ethernet address (in dis example, Ethernet addresses
are up in caps n' internizzle addresses up in lower case).
.LP
This would look less redundant if our crazy asses had done \fItcpdump \-n\fP:
.RS
.nf
.sp .5
\f(CWarp who-has 128.3.254.6 tell 128.3.254.68
arp reply 128.3.254.6 is-at 02:07:01:00:01:c4\fP
.fi
.RE
.LP
If our crazy asses had done \fItcpdump \-e\fP, tha fact dat tha straight-up original gangsta packet is
broadcast n' tha second is point-to-point would be visible:
.RS
.nf
.sp .5
\f(CWRTSG Broadcast 0806  64: arp who-has csam tell rtsg
CSAM RTSG 0806  64: arp reply csam is-at CSAM\fR
.sp .5
.fi
.RE
For tha straight-up original gangsta packet dis say tha Ethernet source address is RTSG, the
destination is tha Ethernet broadcast address, tha type field
contained hex 0806 (type ETHER_ARP) n' tha total length was 64 bytes.
.HD
TCP Packets
.LP
\fI(N.B.:Da followin description assumes familiaritizzle with
the TCP protocol busted lyrics bout up in RFC-793.
If yo ass is not familiar
with tha protocol, neither dis description nor \fItcpdump\fP will
be of much use ta yo thugged-out ass.)\fP
.LP
Da general format of a tcp protocol line is:
.RS
.nf
.sp .5
\fIsrc > dst: flags data-seqno ack window urgent options\fP
.sp .5
.fi
.RE
\fISrc\fP n' \fIdst\fP is tha source n' destination IP
addresses n' ports.
\fIFlags\fP is some combination of S (SYN),
F (FIN), P (PUSH), R (RST), U (URG), W (ECN CWR), E (ECN-Echo) or
`.' (ACK), or `none' if no flags is set.
\fIData-seqno\fP raps bout tha portion of sequence space covered
by tha data up in dis packet (see example below).
\fIAck\fP is sequence number of tha next data expected tha other
direction on dis connection.
\fIWindow\fP is tha number of bytez of receive buffer space available
the other direction on dis connection.
\fIUrg\fP indicates there is `urgent' data up in tha packet.
\fIOptions\fP is tcp options enclosed up in angle brackets (e.g., <mss 1024>).
.LP
\fISrc, dst\fP n' \fIflags\fP is always present.
Da other fields
depend on tha contentz of tha packetz tcp protocol header and
are output only if appropriate.
.LP
Here is tha openin portion of a rlogin from host \fIrtsg\fP to
host \fIcsam\fP.
.RS
.nf
.sp .5
\s-2\f(CWrtsg.1023 > csam.login: S 768512:768512(0) win 4096 <mss 1024>
csam.login > rtsg.1023: S 947648:947648(0) ack 768513 win 4096 <mss 1024>
rtsg.1023 > csam.login: . ack 1 win 4096
rtsg.1023 > csam.login: P 1:2(1) ack 1 win 4096
csam.login > rtsg.1023: . ack 2 win 4096
rtsg.1023 > csam.login: P 2:21(19) ack 1 win 4096
csam.login > rtsg.1023: P 1:2(1) ack 21 win 4077
csam.login > rtsg.1023: P 2:3(1) ack 21 win 4077 urg 1
csam.login > rtsg.1023: P 3:4(1) ack 21 win 4077 urg 1\fR\s+2
.sp .5
.fi
.RE
Da first line say dat tcp port 1023 on rtsg busted a packet
to port \fIlogin\fP
on csam.
Da \fBS\fP indicates dat tha \fISYN\fP flag was set.
Da packet sequence number was 768512 n' it contained no data.
(Da notation is `first:last(nbytes)' which means `sequence
numbers \fIfirst\fP
up ta but not includin \fIlast\fP which is \fInbytes\fP bytez of user data'.)
There was no piggy-backed ack, tha available receive window was 4096
bytes n' there was a max-segment-size option requestin a mss of
1024 bytes.
.LP
Csam replies wit a similar packet except it includes a piggy-backed
ack fo' rtsgz SYN.
Rtsg then acks csamz SYN.
Da `.' means tha ACK flag was set.
Da packet contained no data so there is no data sequence number.
Note dat tha ack sequence
number be a lil' small-ass integer (1).
Da last time \fItcpdump\fP sees a
tcp `conversation', it prints tha sequence number from tha packet.
On subsequent packetz of tha conversation, tha difference between
the current packetz sequence number n' dis initial sequence number
is printed.
This means dat sequence numbers afta the
first can be interpreted
as relatizzle byte positions up in tha conversationz data stream (with the
first data byte each direction bein `1').
`-S' will override this
feature, causin tha original gangsta sequence numbers ta be output.
.LP
On tha 6th line, rtsg sendz csam 19 bytez of data (bytes 2 all up in 20
in tha rtsg \(-> csam side of tha conversation).
Da PUSH flag is set up in tha packet.
On tha 7th line, csam say itz received data busted by rtsg up to
but not includin byte 21.
Most of dis data be apparently chillin up in the
socket buffer since csamz receive window has gotten 19 bytes smaller.
Csam also sendz one byte of data ta rtsg up in dis packet.
On tha 8th n' 9th lines,
csam sendz two bytez of urgent, pushed data ta rtsg.
.LP
If tha snapshot was lil' small-ass enough dat \fItcpdump\fP didn't capture
the full TCP header, it interprets as much of tha header as it can
and then reports ``[|\fItcp\fP]'' ta indicate tha remainder could not
be interpreted.
If tha header gotz nuff a funky-ass bogus option (one wit a length
thatz either too lil' small-ass or beyond tha end of tha header), \fItcpdump\fP
reports it as ``[\fIbad opt\fP]'' n' do not interpret any further
options (since itz impossible ta tell where they start).
If tha header
length indicates options is present but tha IP datagram length is not
long enough fo' tha options ta straight-up be there, \fItcpdump\fP reports
it as ``[\fIbad hdr length\fP]''.
.HD
.B Capturin TCP packets wit particular flag combinations (SYN-ACK, URG-ACK, etc.)
.PP
There is 8 bits up in tha control bits section of tha TCP header:
.IP
.I CWR | ECE | URG | ACK | PSH | RST | SYN | FIN
.PP
Letz assume dat we wanna peep packets used up in establishing
a TCP connection.
Recall dat TCP uses a 3-way handshake protocol
when it initializes a freshly smoked up connection; tha connection sequence with
regard ta tha TCP control bits is
.PP
.RS
1) Calla sendz SYN
.RE
.RS
2) Recipient respondz wit SYN, ACK
.RE
.RS
3) Calla sendz ACK
.RE
.PP
Now our crazy asses horny bout capturin packets dat have only the
SYN bit set (Step 1).
Note dat our phat asses don't want packets from step 2
(SYN-ACK), just a plain initial SYN.
What we need be a cold-ass lil erect filter
expression fo' \fItcpdump\fP.
.PP
Recall tha structure of a TCP header without options:
.PP
.nf
 0                            15                              31
-----------------------------------------------------------------
|          source port          |       destination port        |
-----------------------------------------------------------------
|                        sequence number                        |
-----------------------------------------------------------------
|                     acknowledgment number                     |
-----------------------------------------------------------------
|  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
-----------------------------------------------------------------
|         TCP checksum          |       urgent pointa          |
-----------------------------------------------------------------
.fi
.PP
A TCP header probably holdz 20 octetz of data, unless options are
present.
Da first line of tha graph gotz nuff octets 0 - 3, the
second line shows octets 4 - 7 etc.
.PP
Startin ta count wit 0, tha relevant TCP control bits is contained
in octet 13:
.PP
.nf
 0             7|             15|             23|             31
----------------|---------------|---------------|----------------
|  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
----------------|---------------|---------------|----------------
|               |  13th octet   |               |               |
.fi
.PP
Letz gotz a cold-ass lil closer peep octet no. 13:
.PP
.nf
                |               |
                |---------------|
                |C|E|U|A|P|R|S|F|
                |---------------|
                |7   5   3     0|
.fi
.PP
These is tha TCP control bits we is interested
in.
Our thugged-out asses have numbered tha bits up in dis octet from 0 ta 7, right to
left, so tha PSH bit is bit number 3, while tha URG bit is number 5.
.PP
Recall dat we wanna capture packets wit only SYN set.
Letz peep what tha fuck happens ta octet 13 if a TCP datagram arrives
with tha SYN bit set up in its header:
.PP
.nf
                |C|E|U|A|P|R|S|F|
                |---------------|
                |0 0 0 0 0 0 1 0|
                |---------------|
                |7 6 5 4 3 2 1 0|
.fi
.PP
Lookin at the
control bits section we peep dat only bit number 1 (SYN) is set.
.PP
Assumin dat octet number 13 be a 8-bit unsigned integer in
network byte order, tha binary value of dis octet is
.IP
00000010
.PP
and its decimal representation is
.PP
.nf
   7     6     5     4     3     2     1     0
0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 1*2 + 0*2  =  2
.fi
.PP
We almost done, cuz now we know dat if only SYN is set,
the value of tha 13th octet up in tha TCP header, when interpreted
as a 8-bit unsigned integer up in network byte order, must be exactly 2.
.PP
This relationshizzle can be expressed as
.RS
.B
tcp[13] == 2
.RE
.PP
We can use dis expression as tha filta fo' \fItcpdump\fP up in order
to peep packets which have only SYN set:
.RS
.B
tcpdump -i xl0 tcp[13] == 2
.RE
.PP
Da expression say "let tha 13th octet of a TCP datagram have
the decimal value 2", which is exactly what tha fuck we want.
.PP
Now, letz assume dat we need ta capture SYN packets yo, but we
couldn't give a fuckin shiznit if ACK or any other TCP control bit is set at the
same time.
Letz peep what tha fuck happens ta octet 13 when a TCP datagram
with SYN-ACK set arrives:
.PP
.nf
     |C|E|U|A|P|R|S|F|
     |---------------|
     |0 0 0 1 0 0 1 0|
     |---------------|
     |7 6 5 4 3 2 1 0|
.fi
.PP
Now bits 1 n' 4 is set up in tha 13th octet.
Da binary value of
octet 13 is
.IP
     00010010
.PP
which translates ta decimal
.PP
.nf
   7     6     5     4     3     2     1     0
0*2 + 0*2 + 0*2 + 1*2 + 0*2 + 0*2 + 1*2 + 0*2   = 18
.fi
.PP
Now we can't just use 'tcp[13] == 18' up in tha \fItcpdump\fP filter
expression, cuz dat would select only dem packets dat have
SYN-ACK set yo, but not dem wit only SYN set.
Remember dat our phat asses couldn't give a fuckin shit
if ACK or any other control bit is set as long as SYN is set.
.PP
In order ta big up our goal, we need ta logically AND the
binary value of octet 13 wit some other value ta preserve
the SYN bit.
We know dat we want SYN ta be set up in any case,
so we'll logically AND tha value up in tha 13th octet with
the binary value of a SYN:
.PP
.nf

          00010010 SYN-ACK              00000010 SYN
     AND  00000010 (we want SYN)   AND  00000010 (we want SYN)
          --------                      --------
     =    00000010                 =    00000010
.fi
.PP
We peep dat dis AND operation delivers tha same ol' dirty result
regardless whether ACK or another TCP control bit is set.
Da decimal representation of tha AND value as well as
the result of dis operation is 2 (binary 00000010),
so we know dat fo' packets wit SYN set tha following
relation must hold true:
.IP
( ( value of octet 13 ) AND ( 2 ) ) == ( 2 )
.PP
This points our asses ta tha \fItcpdump\fP filta expression
.RS
.B
     tcpdump -i xl0 'tcp[13] & 2 == 2'
.RE
.PP
Some offsets n' field joints may be expressed as names
rather than as numeric joints, n' you can put dat on yo' toast. For example tcp[13] may
be replaced wit tcp[tcpflags]. Da followin TCP flag
field joints is also available: tcp-fin, tcp-syn, tcp-rst,
tcp-push, tcp-act, tcp-urg.
.PP
This can be demonstrated as:
.RS
.B
     tcpdump -i xl0 'tcp[tcpflags] & tcp-push != 0'
.RE
.PP
Note dat you should use single quotes or a funky-ass backslash
in tha expression ta hide tha AND ('&') special character
from tha shell.
.HD
.B
UDP Packets
.LP
UDP format is illustrated by dis rwho packet:
.RS
.nf
.sp .5
\f(CWactinide.who > broadcast.who: udp 84\fP
.sp .5
.fi
.RE
This say dat port \fIwho\fP on host \fIactinide\fP busted a udp
datagram ta port \fIwho\fP on host \fIbroadcast\fP, tha Internet
broadcast address.
Da packet contained 84 bytez of user data.
.LP
Some UDP skillz is recognized (from tha source or destination
port number) n' tha higher level protocol shiznit printed.
In particular, Domain Name steez requests (RFC-1034/1035) n' Sun
RPC calls (RFC-1050) ta NFS.
.HD
UDP Name Server Requests
.LP
\fI(N.B.:Da followin description assumes familiaritizzle with
the Domain Service protocol busted lyrics bout up in RFC-1035.
If yo ass is not familiar
with tha protocol, tha followin description will step tha fuck up ta be written
in greek.)\fP
.LP
Name server requests is formatted as
.RS
.nf
.sp .5
\fIsrc > dst: id op? flags qtype qclass name (len)\fP
.sp .5
\f(CWh2opolo.1538 > helios.domain: 3+ A? ucbvax.berkeley.edu fo'sho. (37)\fR
.sp .5
.fi
.RE
Host \fIh2opolo\fP axed tha domain server on \fIhelios\fP fo' an
address record (qtype=A) associated wit tha name \fIucbvax.berkeley.edu.\fP
Da query id was `3'.
Da `+' indicates tha \fIrecursion desired\fP flag
was set.
Da query length was 37 bytes, not includin tha UDP and
IP protocol headers.
Da query operation was tha aiiight one, \fIQuery\fP,
so tha op field was omitted.
If tha op had been anythang else, it would
have been printed between tha `3' n' tha `+'.
Similarly, tha qclass was tha aiiight one,
\fIC_IN\fP, n' omitted.
Any other qclass would done been printed
immediately afta tha `A'.
.LP
A few anomalies is checked n' may result up in extra fieldz enclosed in
square brackets:  If a query gotz nuff a answer, authoritizzle recordz or
additionizzle recordz section,
.IR ancount ,
.IR nscount ,
or
.I arcount
are printed as `[\fIn\fPa]', `[\fIn\fPn]' or  `[\fIn\fPau]' where \fIn\fP
is tha appropriate count.
If any of tha response bits is set (AA, RA or rcode) or any of the
`must be zero' bits is set up in bytes two n' three, `[b2&3=\fIx\fP]'
is printed, where \fIx\fP is tha hex value of header bytes two n' three.
.HD
UDP Name Server Responses
.LP
Name server responses is formatted as
.RS
.nf
.sp .5
\fIsrc > dst:  id op rcode flags a/n/au type class data (len)\fP
.sp .5
\f(CWhelios.domain > h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273)
helios.domain > h2opolo.1537: 2 NXDomain* 0/1/0 (97)\fR
.sp .5
.fi
.RE
In tha straight-up original gangsta example, \fIhelios\fP respondz ta query id 3 from \fIh2opolo\fP
with 3 answer records, 3 name server recordz n' 7 additionizzle records.
Da first answer record is type A (address) n' its data is internet
address 128.32.137.3.
Da total size of tha response was 273 bytes,
excludin UDP n' IP headers.
Da op (Query) n' response code
(NoError) was omitted, as was tha class (C_IN) of tha A record.
.LP
In tha second example, \fIhelios\fP respondz ta query 2 wit a
response code of non-existent domain (NXDomain) wit no lyrics,
one name server n' no authoritizzle records.
Da `*' indicates that
the \fIauthoritatizzle answer\fP bit was set.
Since there was no
answers, no type, class or data was printed.
.LP
Other flag charactas dat might step tha fuck up is `\-' (recursion available,
RA, \fInot\fP set) n' `|' (truncated message, TC, set).
If the
`question' section don't contain exactly one entry, `[\fIn\fPq]'
is printed.
.HD
SMB/CIFS decoding
.LP
\fItcpdump\fP now includes fairly extensive SMB/CIFS/NBT decodin fo' data
on UDP/137, UDP/138 n' TCP/139.
Some primitizzle decodin of IPX and
NetBEUI SMB data be also done.
.LP
By default a gangbangin' fairly minimal decode is done, wit a much mo' detailed
decode done if -v is used.
Be warned dat wit -v a single SMB packet
may take up a page or more, so only use -v if you straight-up want all the
gory details.
.LP
For shiznit on SMB packet formats n' what tha fuck all tha fieldz mean see
www.cifs.org or tha pub/samba/specs/ directory on yo' favorite
samba.org mirror crib.
Da SMB patches was freestyled by Andrew Tridgell
(tridge@samba.org).
.HD
NFS Requests n' Replies
.LP
Sun NFS (Network File System) requests n' replies is printed as:
.RS
.nf
.sp .5
\fIsrc.xid > dst.nfs: len op args\fP
\fIsrc.nfs > dst.xid: reply stat len op thangs up in dis biatch\fP
.sp .5
\f(CW
sushi.6709 > wrl.nfs: 112 readlink fh 21,24/10.73165
wrl.nfs > sushi.6709: reply aiiight 40 readlink "../var"
sushi.201b > wrl.nfs:
	144 lookup fh 9,74/4096.6878 "xcolors"
wrl.nfs > sushi.201b:
	reply aiiight 128 lookup fh 9,74/4134.3150
\fR
.sp .5
.fi
.RE
In tha straight-up original gangsta line, host \fIsushi\fP sendz a transaction wit id \fI6709\fP
to \fIwrl\fP (note dat tha number followin tha src host be a
transaction id, \fInot\fP tha source port).
Da request was 112 bytes,
excludin tha UDP n' IP headers.
Da operation was a \fIreadlink\fP
(read symbolic link) on file handle (\fIfh\fP) 21,24/10.731657119.
(If one is dirty, as up in dis case, tha file handle can be interpreted
as a major,minor thang number pair, followed by tha inode number and
generation number.)
\fIWrl\fP replies `ok' wit tha contentz of tha link.
.LP
In tha third line, \fIsushi\fP asks \fIwrl\fP ta lookup tha name
`\fIxcolors\fP' up in directory file 9,74/4096.6878.
Note dat tha data printed
dependz on tha operation type.
Da format is intended ta be self
explanatory if read up in conjunction with
an NFS protocol spec.
.LP
If tha \-v (verbose) flag is given, additionizzle shiznit is printed.
For example:
.RS
.nf
.sp .5
\f(CW
sushi.1372a > wrl.nfs:
	148 read fh 21,11/12.195 8192 bytes @ 24576
wrl.nfs > sushi.1372a:
	reply aiiight 1472 read REG 100664 idz 417/0 ss 29388
\fP
.sp .5
.fi
.RE
(\-v also prints tha IP header TTL, ID, length, n' fragmentation fields,
which done been omitted from dis example.)  In tha straight-up original gangsta line,
\fIsushi\fP asks \fIwrl\fP ta read 8192 bytes from file 21,11/12.195,
at byte offset 24576.
\fIWrl\fP replies `ok'; tha packet shown on the
second line is tha straight-up original gangsta fragment of tha reply, n' hence is only 1472
bytes long (the other bytes will follow up in subsequent fragments yo, but
these fragments aint gots NFS or even UDP headaz n' so might not be
printed, dependin on tha filta expression used).
Because tha \-v flag
is given, a shitload of tha file attributes (which is returned up in addition
to tha file data) is printed: tha file type (``REG'', fo' regular file),
the file mode (in octal), tha uid n' gid, n' tha file size.
.LP
If tha \-v flag is given mo' than once, even mo' details is printed.
.LP
Note dat NFS requests is straight-up big-ass n' much of tha detail won't be printed
unless \fIsnaplen\fP is increased.
Try rockin `\fB\-s 192\fP' ta watch
NFS traffic.
.LP
NFS reply packets do not explicitly identify tha RPC operation.
Instead,
\fItcpdump\fP keeps track of ``recent'' requests, n' matches dem ta the
replies rockin tha transaction ID.
If a reply do not closely follow the
correspondin request, it might not be parsable.
.HD
AFS Requests n' Replies
.LP
Transarc AFS (Andrew File System) requests n' replies is printed
as:
.HD
.RS
.nf
.sp .5
\fIsrc.shiznit > dst.dport: rx packet-type\fP
\fIsrc.shiznit > dst.dport: rx packet-type steez call call-name args\fP
\fIsrc.shiznit > dst.dport: rx packet-type steez reply call-name args\fP
.sp .5
\f(CW
elvis.7001 > pike.afsfs:
	rx data fs call rename oldschool fid 536876964/1/1 ".newsrc.new"
	new fid 536876964/1/1 ".newsrc"
pike.afsfs > elvis.7001: rx data fs reply rename
\fR
.sp .5
.fi
.RE
In tha straight-up original gangsta line, host elvis sendz a RX packet ta pike.
This was
a RX data packet ta tha fs (fileserver) service, n' is tha start of
an RPC call.
Da RPC call was a rename, wit tha oldschool directory file id
of 536876964/1/1 n' a oldschool filename of `.newsrc.new', n' a freshly smoked up directory
file id of 536876964/1/1 n' a freshly smoked up filename of `.newsrc'.
Da host pike
respondz wit a RPC reply ta tha rename call (which was successful, cuz
it was a thugged-out data packet n' not a abort packet).
.LP
In general, all AFS RPCs is decoded at least by RPC call name.
Most
AFS RPCs have at least a shitload of tha arguments decoded (generally only
the `interesting' arguments, fo' some definizzle of interesting).
.LP
Da format is intended ta be self-describin yo, but it will probably
not be useful ta playas whoz ass is not familiar wit tha workings of
AFS n' RX.
.LP
If tha -v (verbose) flag is given twice, acknowledgement packets and
additionizzle header shiznit is printed, like fuckin tha RX call ID,
call number, sequence number, serial number, n' tha RX packet flags.
.LP
If tha -v flag is given twice, additionizzle shiznit is printed,
like fuckin tha RX call ID, serial number, n' tha RX packet flags.
Da MTU negotiation shiznit be also printed from RX ack packets.
.LP
If tha -v flag is given three times, tha securitizzle index n' steez id
are printed.
.LP
Error codes is printed fo' abort packets, wit tha exception of Ubik
beacon packets (because abort packets is used ta signify a yeaaaa vote
for tha Ubik protocol).
.LP
Note dat AFS requests is straight-up big-ass n' nuff of tha arguments won't
be printed unless \fIsnaplen\fP is increased.
Try rockin `\fB-s 256\fP'
to peep AFS traffic.
.LP
AFS reply packets do not explicitly identify tha RPC operation.
Instead,
\fItcpdump\fP keeps track of ``recent'' requests, n' matches dem ta the
replies rockin tha call number n' steez ID.
If a reply do not closely
follow the
correspondin request, it might not be parsable.

.HD
KIP AppleTalk (DDP up in UDP)
.LP
AppleTalk DDP packets encapsulated up in UDP datagrams is de-encapsulated
and dumped as DDP packets (i.e., all tha UDP header shiznit is
discarded).
Da file
.I /etc/atalk.names
is used ta translate AppleTalk net n' node numbers ta names.
Lines up in dis file have tha form
.RS
.nf
.sp .5
\fInumber	name\fP

\f(CW1.254		ether
16.1		icsd-net
1.254.110	ace\fR
.sp .5
.fi
.RE
Da first two lines give tha namez of AppleTalk networks.
Da third
line gives tha name of a particular host (a host is distinguished
from a net by tha 3rd octet up in tha number \-
a net number \fImust\fP have two octets n' a host number \fImust\fP
have three octets.)  Da number n' name should be separated by
whitespace (blanks or tabs).
The
.I /etc/atalk.names
file may contain blank lines or comment lines (lines startin with
a `#').
.LP
AppleTalk addresses is printed up in tha form
.RS
.nf
.sp .5
\fInet.host.port\fP

\f(CW144.1.209.2 > icsd-net.112.220
office.2 > icsd-net.112.220
jssmag.149.235 > icsd-net.2\fR
.sp .5
.fi
.RE
(If the
.I /etc/atalk.names
doesn't exist or don't contain a entry fo' some AppleTalk
host/net number, addresses is printed up in numeric form.)
In tha straight-up original gangsta example, NBP (DDP port 2) on net 144.1 node 209
is bustin  ta whatever is listenin on port 220 of net icsd node 112.
Da second line is tha same ol' dirty except tha full name of tha source node
is known (`office').
Da third line be a bust from port 235 on
net jssmag node 149 ta broadcast on tha icsd-net NBP port (note that
the broadcast address (255) is indicated by a net name wit no host
number \- fo' dis reason itz a phat scam ta keep node names and
net names distinct up in /etc/atalk.names).
.LP
NBP (name bindin protocol) n' ATP (AppleTalk transaction protocol)
packets have they contents interpreted.
Other protocols just dump
the protocol name (or number if no name is registered fo' the
protocol) n' packet size.

\fBNBP packets\fP is formatted like tha followin examples:
.RS
.nf
.sp .5
\s-2\f(CWicsd-net.112.220 > jssmag.2: nbp-lkup 190: "=:LaserWriter@*"
jssmag.209.2 > icsd-net.112.220: nbp-reply 190: "RM1140:LaserWriter@*" 250
techpit.2 > icsd-net.112.220: nbp-reply 190: "techpit:LaserWriter@*" 186\fR\s+2
.sp .5
.fi
.RE
Da first line be a name lookup request fo' laserwritas busted by net icsd host
112 n' broadcast on net jssmag.
Da nbp id fo' tha lookup is 190.
Da second line shows a reply fo' dis request (note dat it has the
same id) from host jssmag.209 sayin dat it has a laserwriter
resource named "RM1140" registered on port 250.
Da third line is
another reply ta tha same request sayin host techpit has laserwriter
"techpit" registered on port 186.

\fBATP packet\fP formattin is demonstrated by tha followin example:
.RS
.nf
.sp .5
\s-2\f(CWjssmag.209.165 > helios.132: atp-req  12266<0-7> 0xae030001
helios.132 > jssmag.209.165: atp-resp 12266:0 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp 12266:1 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp 12266:2 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp 12266:4 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp 12266:6 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp*12266:7 (512) 0xae040000
jssmag.209.165 > helios.132: atp-req  12266<3,5> 0xae030001
helios.132 > jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
helios.132 > jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
jssmag.209.165 > helios.132: atp-rel  12266<0-7> 0xae030001
jssmag.209.133 > helios.132: atp-req* 12267<0-7> 0xae030002\fR\s+2
.sp .5
.fi
.RE
Jssmag.209 initiates transaction id 12266 wit host helios by requesting
up ta 8 packets (the `<0-7>').
Da hex number all up in tha end of tha line
is tha value of tha `userdata' field up in tha request.
.LP
Helios respondz wit 8 512-byte packets.
Da `:digit' followin the
transaction id gives tha packet sequence number up in tha transaction
and tha number up in parens is tha amount of data up in tha packet,
excludin tha atp header.
Da `*' on packet 7 indicates dat the
EOM bit was set.
.LP
Jssmag.209 then requests dat packets 3 & 5 be retransmitted.
Helios
resendz dem then jssmag.209 releases tha transaction.
Finally,
jssmag.209 initiates tha next request.
Da `*' on tha request
indicates dat XO (`exactly once') was \fInot\fP set.

.HD
IP Fragmentation
.LP
Fragmented Internizzle datagrams is printed as
.RS
.nf
.sp .5
\fB(frag \fIid\fB:\fIsize\fB@\fIoffset\fB+)\fR
\fB(frag \fIid\fB:\fIsize\fB@\fIoffset\fB)\fR
.sp .5
.fi
.RE
(Da first form indicates there be mo' fragments.
Da second
indicates dis is tha last fragment.)
.LP
\fIId\fP is tha fragment id.
\fISize\fP is tha fragment
size (in bytes) excludin tha IP header.
\fIOffset\fP is this
fragmentz offset (in bytes) up in tha original gangsta datagram.
.LP
Da fragment shiznit is output fo' each fragment.
Da first
fragment gotz nuff tha higher level protocol header n' tha frag
info is printed afta tha protocol info.
Fragments
afta tha straight-up original gangsta contain no higher level protocol header n' the
frag info is printed afta tha source n' destination addresses.
For example, here is part of a ftp from arizona.edu ta lbl-rtsg.arpa
over a CSNET connection dat don't step tha fuck up ta handle 576 byte datagrams:
.RS
.nf
.sp .5
\s-2\f(CWarizona.ftp-data > rtsg.1170: . 1024:1332(308) ack 1 win 4096 (frag 595a:328@0+)
arizona > rtsg: (frag 595a:204@328)
rtsg.1170 > arizona.ftp-data: . ack 1536 win 2560\fP\s+2
.sp .5
.fi
.RE
There is a cold-ass lil couple thangs ta note here:  First, addresses up in the
2nd line don't include port numbers.
This is cuz tha TCP
protocol shiznit be all up in tha straight-up original gangsta fragment n' our crazy asses have no idea
what tha port or sequence numbers is when we print tha lata fragments.
Second, tha tcp sequence shiznit up in tha straight-up original gangsta line is printed as if there
were 308 bytez of user data when, up in fact, there be 512 bytes (308 in
the first frag n' 204 up in tha second).
If yo ass is lookin fo' holes
in tha sequence space or tryin ta match up acks
with packets, dis can fool yo thugged-out ass.
.LP
A packet wit tha IP \fIdon't fragment\fP flag is marked wit a
trailin \fB(DF)\fP.
.HD
Timestamps
.LP
By default, all output lines is preceded by a timestamp.
Da timestamp
is tha current clock time up in tha form
.RS
.nf
\fIhh:mm:ss.frac\fP
.fi
.RE
and be as accurate as tha kernelz clock.
Da timestamp reflects tha time tha kernel first saw tha packet.
No attempt
is made ta account fo' tha time lag between when the
Ethernet intercourse removed tha packet from tha wire n' when tha kernel
serviced tha `new packet' interrupt.
.SH "SEE ALSO"
stty(1), pcap(3PCAP), bpf(4), nit(4P), pcap-savefile(5),
pcap-filter(7), pcap-tstamp-type(7)
.LP
.RS
.I http://www.iana.org/assignments/media-types/application/vnd.tcpdump.pcap
.RE
.LP
.SH AUTHORS
Da original gangsta authors are:
.LP
Van Jacobson,
Craig Leres and
Steven McCanne, all of the
Lawrence Berkeley Nationizzle Laboratory, Universitizzle of California, Berkeley, CA.
.LP
It be currently bein maintained by tcpdump.org.
.LP
Da current version be available via http:
.LP
.RS
.I http://www.tcpdump.org/
.RE
.LP
Da original gangsta distribution be available via anonymous ftp:
.LP
.RS
.I ftp://ftp.ee.lbl.gov/old/tcpdump.tar.Z
.RE
.LP
IPv6/IPsec support be added by WIDE/KAME project.
This program uses Eric Youngz SSLeay library, under specific configurations.
.SH BUGS
Please bust problems, bugs, thangs, desirable enhancements, patches
etc. to:
.LP
.RS
tcpdump-workers@lists.tcpdump.org
.RE
.LP
NIT don't let you peep yo' own outbound traffic, BPF will.
We recommend dat you use tha latter.
.LP
On Linux systems wit 2.0[.x] kernels:
.IP
packets on tha loopback thang is ghon be peeped twice;
.IP
packet filterin cannot be done up in tha kernel, so dat all packets must
be copied from tha kernel up in order ta be filtered up in user mode;
.IP
all of a packet, not just tha part thatz within tha snapshot length,
will be copied from tha kernel (the 2.0[.x] packet capture mechanism, if
axed ta copy only part of a packet ta userland, aint gonna report the
true length of tha packet; dis would cause most IP packets ta git an
error from
.BR tcpdump );
.IP
capturin on some PPP devices won't work erectly.
.LP
We recommend dat you upgrade ta a 2.2 or lata kernel.
.LP
Some attempt should be made ta reassemble IP fragments or, at least
to compute tha right length fo' tha higher level protocol.
.LP
Name server inverse queries is not dumped erectly: tha (empty)
question section is printed rather than real query up in tha answer
section.
Some believe dat inverse queries is theyselves a funky-ass bug and
prefer ta fix tha program generatin dem rather than \fItcpdump\fP.
.LP
A packet trace dat crosses a thugged-out daylight savings time chizzle will give
skewed time stamps (the time chizzle is ignored).
.LP
Filta expressions on fieldz other than dem up in Token Rin headaz will
not erectly handle source-routed Token Rin packets.
.LP
Filta expressions on fieldz other than dem up in 802.11 headaz will not
correctly handle 802.11 data packets wit both To DS n' From DS set.
.LP
.BR "ip6 proto"
should chase header chain yo, but at dis moment it do not.
.BR "ip6 protochain"
is supplied fo' dis behavior.
.LP
Arithmetic expression against transhiznit layer headers, like \fBtcp[0]\fP,
does not work against IPv6 packets.
It only looks at IPv4 packets.
