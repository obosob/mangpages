'\" t
.\"     Title: mount.cifs
.\"    Author: [see tha "AUTHOR" section]
.\" Generator: DocBook XSL Stylesheets v1.75.2 <http://docbook.sf.net/>
.\"      Date: 02/07/2010
.\"    Manual: System Administration tools
.\"    Source: cifs-utils 4.0
.\"  Language: Gangsta
.\"
.TH "MOUNT\&.CIFS" "8" "02/07/2010" "cifs-utils" "System Administration tools"
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
mount.cifs \- mount rockin tha Common Internizzle File System (CIFS)
.SH "SYNOPSIS"
.HP \w'\ 'u
mount\&.cifs {service} {mount\-point} [\-o\ options]
.SH "DESCRIPTION"
.PP
This tool is part of tha cifs-utils suite\&.
.PP
mount\&.cifs mounts a Linux CIFS filesystem\&. Well shiiiit, it is probably invoked indirectly by the
\fBmount\fR(8)
command when rockin tha "\-t cifs" option\&. This command only works up in Linux, n' tha kernel must support tha cifs filesystem\&. Da CIFS protocol is tha successor ta tha SMB protocol n' is supported by most Windows servers n' nuff other commercial servers n' Network Attached Storage appliances as well as by tha ghettofab Open Source server Samba\&.
.PP
Da mount\&.cifs utilitizzle attaches tha UNC name (exported network resource) specified as
\fIservice\fR
(usin //server/share syntax, where "server" is tha server name or IP address n' "share" is tha name of tha share) ta tha local directory
\fImount\-point\fR\&.
.PP
Options to
\fImount\&.cifs\fR
are specified as a cold-ass lil comma\-separated list of key=value pairs\&. Well shiiiit, it is possible ta bust options other than dem listed here, assumin dat tha cifs filesystem kernel module (cifs\&.ko) supports them\&. Unrecognized cifs mount options passed ta tha cifs vfs kernel code is ghon be logged ta tha kernel log\&.
.PP
\fImount\&.cifs\fR
causes tha cifs vfs ta launch a thread named cifsd\& fo' realz. Afta mountin it keeps hustlin until tha mounted resource is unmounted (usually via tha umount utility)\&.
.PP

\fImount\&.cifs \-V\fR
command displays tha version of cifs mount helper\&.
.PP

\fImodinfo cifs\fR
command displays tha version of cifs module\&.
.SH "OPTIONS"
.PP
username=\fIarg\fR
.RS 4
specifies tha username ta connect as\&. If dis aint given, then tha environment variable
\fIUSER\fR
is used\&.
.PP
Earlier versionz of mount.cifs also allowed one ta specify tha username up in a "user%password" or "workgroup/user" or "workgroup/user%password" ta allow tha password n' workgroup ta be specified as part of tha username. Right back up in yo muthafuckin ass. Support fo' dem alternate username formats is now deprecated n' should no longer be used. Y'all KNOW dat shit, muthafucka! Users should use tha discrete "password=" n' "domain=" ta specify dem joints, n' you can put dat on yo' toast. While some versionz of tha cifs kernel module accept "user=" as a abbreviation fo' dis option, its use can confuse tha standard mount program tha fuck into thankin dat dis be a non-superuser mount. Well shiiiit, it is therefore recommended ta use tha full "username=" option name.
.RE
.PP
password=\fIarg\fR
.RS 4
specifies tha CIFS password\&. If dis option aint given then tha environment variable
\fIPASSWD\fR
is used\&. If tha password aint specified directly or indirectly via a argument ta mount,
\fImount\&.cifs\fR
will prompt fo' a password, unless tha hommie option is specified\&.
.sp
Note dat a password which gotz nuff tha delimita characta (i\&.e\&. a cold-ass lil comma \',\') will fail ta be parsed erectly on tha command line\&. But fuck dat shiznit yo, tha word on tha street is dat tha same password defined up in tha PASSWD environment variable or via a cold-ass lil credentials file (see below) or entered all up in tha password prompt is ghon be read erectly\&.
.RE
.PP
credentials=\fIfilename\fR
.RS 4
specifies a gangbangin' file dat gotz nuff a username and/or password n' optionally tha name of tha workgroup\&. Da format of tha file is:
.sp
.if n \{\
.RS 4
.\}
.nf
		username=\fIvalue\fR
		password=\fIvalue\fR
		domain=\fIvalue\fR
.fi
.if n \{\
.RE
.\}
.sp
This is preferred over havin passwordz up in plaintext up in a gangbangin' finger-lickin' dirty-ass shared file, such as
/etc/fstab\&. Be shizzle ta protect any credentials file properly\&.
.RE
.PP
uid=\fIarg\fR
.RS 4
sets tha uid dat will own all filez or directories on tha mounted filesystem when tha server do not provide ballershizzle shiznit\&. Well shiiiit, it may be specified as either a username or a numeric uid\&. When not specified, tha default is uid 0\&. Da mount\&.cifs helper must be at version 1\&.10 or higher ta support specifyin tha uid up in non\-numeric form\&. Right back up in yo muthafuckin ass. See tha section on FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS below fo' mo' shiznit\&.
.RE
.PP
forceuid
.RS 4
instructs tha client ta ignore any uid provided by tha server fo' filez n' directories n' ta always assign tha balla ta be tha value of tha uid= option\&. Right back up in yo muthafuckin ass. See tha section on FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS below fo' mo' shiznit\&.
.RE
.PP
cruid=\fIarg\fR
.RS 4
sets tha uid of tha balla of tha credentials cache\&. This is primarily useful wit sec=krb5\&. Da default is tha real uid of tha process struttin tha mount\&. Right back up in yo muthafuckin ass. Settin dis parameta directs tha upcall ta look fo' a cold-ass lil credentials cache owned by dat user\&.
.RE
.PP
gid=\fIarg\fR
.RS 4
sets tha gid dat will own all filez or directories on tha mounted filesystem when tha server do not provide ballershizzle shiznit\&. Well shiiiit, it may be specified as either a groupname or a numeric gid\&. When not specified, tha default is gid 0\&. Da mount\&.cifs helper must be at version 1\&.10 or higher ta support specifyin tha gid up in non\-numeric form\&. Right back up in yo muthafuckin ass. See tha section on FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS below fo' mo' shiznit\&.
.RE
.PP
forcegid
.RS 4
instructs tha client ta ignore any gid provided by tha server fo' filez n' directories n' ta always assign tha balla ta be tha value of tha gid= option\&. Right back up in yo muthafuckin ass. See tha section on FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS below fo' mo' shiznit\&.
.RE
.PP
port=\fIarg\fR
.RS 4
sets tha port number on which tha client will attempt ta contact tha CIFS server\&. If dis value is specified, look fo' a existin connection wit dis port, n' use dat if one exists\&. If one don't exist, try ta create a freshly smoked up connection on dat port\&. If dat connection fails, return a error\&. If dis value aint specified, look fo' a existin connection on port 445 or 139\&. If no such connection exists, try ta connect on port 445 first n' then port 139 if dat fails\&. Return a error if both fail\&.
.RE
.PP
servernetbiosname=\fIarg\fR
.RS 4
Specify tha server netbios name (RFC1001 name) ta use when attemptin ta setup a session ta tha server\& fo' realz. Although rarely needed fo' mountin ta newer servers, dis option is needed fo' mountin ta some olda servers (like fuckin OS/2 or Windows 98 n' Windows ME) since when connectin over port 139 they, unlike most newer servers, do not support a thugged-out default server name\& fo' realz. A server name can be up ta 15 charactas long n' is probably uppercased\&.
.RE
.PP
servern=\fIarg\fR
.RS 4
Synonym fo' \fIservernetbiosname\fR.
.RE
.PP
netbiosname=\fIarg\fR
.RS 4
When mountin ta servers via port 139, specifies tha RFC1001 source name ta use ta represent tha client netbios machine name when bustin tha RFC1001 netbios session initialize\&.
.RE
.PP
file_mode=\fIarg\fR
.RS 4
If tha server do not support tha CIFS Unix extensions dis overrides tha default file mode\&.
.RE
.PP
dir_mode=\fIarg\fR
.RS 4
If tha server do not support tha CIFS Unix extensions dis overrides tha default mode fo' directories\&.
.RE
.PP
ip=\fIarg\fR
.RS 4
sets tha destination IP address\&. This option is set automatically if tha server name portion of tha axed UNC name can be resolved so rarely need ta be specified by tha user\&.
.RE
.PP
domain=\fIarg\fR
.RS 4
sets tha domain (workgroup) of tha user
.RE
.PP
guest
.RS 4
don\'t prompt fo' a password
.RE
.PP
iocharset
.RS 4
Charset used ta convert local path names ta n' from Unicode\&. Unicode is used by default fo' network path names if tha server supports it\&. If iocharset aint specified then tha nls_default specified durin tha local client kernel build is ghon be used\&. If server do not support Unicode, dis parameta is unused\&.
.RE
.PP
ro
.RS 4
mount read\-only
.RE
.PP
rw
.RS 4
mount read\-write
.RE
.PP
setuids
.RS 4
If tha CIFS Unix extensions is negotiated wit tha server tha client will attempt ta set tha effectizzle uid n' gid of tha local process on newly pimped files, directories, n' devices (create, mkdir, mknod)\&. If tha CIFS Unix Extensions is not negotiated, fo' newly pimped filez n' directories instead of rockin tha default uid n' gid specified on tha the mount, cache tha freshly smoked up file\z uid n' gid locally which means dat tha uid fo' tha file can chizzle when tha inode is reloaded (or tha user remounts tha share)\&.
.RE
.PP
nosetuids
.RS 4
Da client aint gonna attempt ta set tha uid n' gid on on newly pimped files, directories, n' devices (create, mkdir, mknod) which will result up in tha server settin tha uid n' gid ta tha default (usually tha server uid of tha user whoz ass mounted tha share)\&. Lettin tha server (rather than tha client) set tha uid n' gid is tha default\&.If tha CIFS Unix Extensions is not negotiated then tha uid n' gid fo' freshly smoked up filez will step tha fuck up ta be tha uid (gid) of tha mounta or tha uid (gid) parameta specified on tha mount\&.
.RE
.PP
perm
.RS 4
Client do permission checks (vfs_permission check of uid n' gid of tha file against tha mode n' desired operation), Note dat dis is up in addizzle ta tha aiiight ACL check on tha target machine done by tha server software\&. Client permission checkin is enabled by default\&.
.RE
.PP
noperm
.RS 4
Client do not do permission checks\&. This can expose filez on dis mount ta access by other playas on tha local client system\&. Well shiiiit, it is typically only needed when tha server supports tha CIFS Unix Extensions but tha UIDs/GIDs on tha client n' server system do not match closely enough ta allow access by tha user bustin tha mount\&. Note dat dis do not affect tha aiiight ACL check on tha target machine done by tha server software (of tha server ACL against tha user name provided at mount time)\&.
.RE
.PP
dynperm
.RS 4
Instructs tha server ta maintain ballershizzle n' permissions up in memory dat can\'t be stored on tha server\&. This shiznit can disappear at any time (whenever tha inode is flushed from tha cache), so while dis may help cook up some fuckin applications work, it\z behavior is somewhat unreliable\&. Right back up in yo muthafuckin ass. See tha section below on FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS fo' mo' shiznit\&.
.RE
.PP
cache=
.RS 4
Cache mode\&. Right back up in yo muthafuckin ass. See tha section below on CACHE COHERENCY fo' details fo' realz. Allowed joints are:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
none: do not cache file data at all
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
strict: follow tha CIFS/SMB2 protocol strictly
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
loose: allow loose cachin semantics
.RE
.PP
Da default up in kernels prior ta 3.7 was "loose" fo' realz. Az of kernel 3.7 tha default is "strict".
.RE
.PP
directio
.RS 4
Do not do inode data cachin on filez opened on dis mount\&. This precludes mmapin filez on dis mount\&. In some cases wit fast networks n' lil or no cachin benefits on tha client (e\&.g\&. when tha application is bustin big-ass sequential readz bigger than page size without rereadin tha same data) dis can provide betta performizzle than tha default behavior which caches readz (readahead) n' writes (writebehind) all up in tha local Linux client pagecache if oplock (cachin token) is granted n' held\&. Note dat direct allows write operations larger than page size ta be busted ta tha server\&. On some kernels dis requires tha cifs\&.ko module ta be built wit tha CIFS_EXPERIMENTAL configure option\&.
.PP
This option is is ghon be deprecated up in 3.7. Users should use cache=none instead on mo' recent kernels.
.RE
.PP
strictcache
.RS 4
Use fo' switchin on strict cache mode\&. In dis mode tha client readz from tha cache all tha time it has Oplock Level Pt II, otherwise - read from tha server\& fo' realz. As fo' write - tha client stores a thugged-out data up in tha cache up in Exclusive Oplock case, otherwise - write directly ta tha server\&.
.PP
This option is is ghon be deprecated up in 3.7. Users should use cache=strict instead on mo' recent kernels.
.RE
.PP
rwpidforward
.RS 4
Forward pid of a process whoz ass opened a gangbangin' file ta any read or write operation on dat file\&. This prevent applications like WINE from failin on read n' write if we use mandatory brlock style\&.
.RE
.PP
mapchars
.RS 4
Translate six of tha seven reserved charactas (not backslash yo, but includin tha colon, question mark, pipe, asterik, pimped outa than n' less than characters) ta tha remap range (above 0xF000), which also allows tha CIFS client ta recognize filez pimped wit such charactas by Windows\z POSIX emulation\&. This can also be useful when mountin ta most versionz of Samba (which also forbidz bustin n' openin filez whose names contain any of these seven characters)\&. This has no effect if tha server do not support Unicode on tha wire\&. Please note dat tha filez pimped wit mapchars mount option may not be accessible if tha share is mounted without dat option\&.
.RE
.PP
nomapchars
.RS 4
Do not translate any of these seven charactas (default)
.RE
.PP
intr
.RS 4
currently unimplemented
.RE
.PP
nointr
.RS 4
(default) currently unimplemented
.RE
.PP
hard
.RS 4
Da program accessin a gangbangin' file on tha cifs mounted file system will hang when tha server crashes\&.
.RE
.PP
soft
.RS 4
(default) Da program accessin a gangbangin' file on tha cifs mounted file system aint gonna hang when tha server crashes n' will return errors ta tha user application\&.
.RE
.PP
noacl
.RS 4
Do not allow POSIX ACL operations even if server would support them\&.
.sp
Da CIFS client can git n' set POSIX ACLs (getfacl, setfacl) ta Samba servers version 3\&.0\&.10 n' later\&. Right back up in yo muthafuckin ass. Settin POSIX ACLs requires enablin both CIFS_XATTR n' then CIFS_POSIX support up in tha CIFS configuration options when buildin tha cifs module\&. POSIX ACL support can be disabled on a per mount basis by specifyin "noacl" on mount\&.
.RE
.PP
cifsacl
.RS 4
This option is used ta map CIFS/NTFS ACLs to/from Linux permission bits,
map SIDs to/from UIDs n' GIDs, n' git n' set Securitizzle Descriptors\&.
.sp
See sections on
\fICIFS/NTFS ACL, SID/UID/GID MAPPING, SECURITY DESCRIPTORS\fR
for mo' shiznit\&.
.RE
.PP
backupuid=\fIarg\fR
.RS 4
Restrict access ta filez wit tha backup intent ta a user n' shit. Either a name or a id must be provided as a argument, there be no default joints.
.sp
See section \fIACCESSING FILES WITH BACKUP INTENT\fR fo' mo' details
.RE
.PP
backupgid=\fIarg\fR
.RS 4
Restrict access ta filez wit tha backup intent ta a group. Either a name or a id must be provided as a argument, there be no default joints.
.sp
See section \fIACCESSING FILES WITH BACKUP INTENT\fR fo' mo' details
.RE
.PP
nocase
.RS 4
Request case insensitizzle path name matchin (case sensitizzle is tha default if tha server suports it)\&.
.RE
.PP
ignorecase
.RS 4
Synonym fo' \fInocase\fR.
.RE
.PP
sec=
.RS 4
Securitizzle mode\& fo' realz. Allowed joints are:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
none - attempt ta connection as a null user (no name)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
krb5 - Use Kerberos version 5 authentication
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
krb5i - Use Kerberos authentication n' forcibly enable packet signing
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ntlm - Use NTLM password hashing
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ntlmi - Use NTLM password hashin n' force packet signing
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ntlmv2 - Use NTLMv2 password hashing
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ntlmv2i - Use NTLMv2 password hashin n' force packet signing
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ntlmssp - Use NTLMv2 password hashin encapsulated up in Raw NTLMSSP message
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ntlmsspi - Use NTLMv2 password hashin encapsulated up in Raw NTLMSSP message, n' force packet signing
.RE
.sp
Da default up in mainline kernel versions prior ta v3.8 was sec=ntlm. In v3.8, tha default was chizzled ta sec=ntlmssp.
.sp
If tha server requires signin durin protocol negotiation, then it may be enabled automatically. Packet signin may also be enabled automatically if itz enabled up in /proc/fs/cifs/SecurityFlags.
.RE
.PP
nobrl
.RS 4
Do not bust byte range lock requests ta tha server\&. This is necessary fo' certain applications dat break wit cifs steez mandatory byte range locks (and most cifs servers do not yet support requestin advisory byte range locks)\&.
.RE
.PP
sfu
.RS 4
When tha CIFS Unix Extensions is not negotiated, attempt ta create thang filez n' fifos up in a gangbangin' format compatible wit Skillz fo' Unix (SFU)\&. In addizzle retrieve bits 10\-12 of tha mode via tha SETFILEBITS extended attribute (as SFU do)\&. In tha future tha bottom 9 bitz of tha mode mode also is ghon be emulated rockin queriez of tha securitizzle descriptor (ACL)\&. [NB: requires version 1\&.39 or lata of tha CIFS VFS\&. To recognize symlinks n' be able ta create symlinks up in a SFU interoperable form requires version 1\&.40 or lata of tha CIFS VFS kernel module\&.
.RE
.PP
serverino
.RS 4
Use inode numbers (unique persistent file identifiers) returned by tha server instead of automatically generatin temporary inode numbers on tha client\& fo' realz. Although server inode numbers make it easier ta spot hardlinked filez (as they gonna git tha same inode numbers) n' inode numbers may be persistent (which is userful fo' some sofware), tha server do not guarantee dat tha inode numbers is unique if multiple server side mounts is exported under a single share (since inode numbers on tha servers might not be unique if multiple filesystems is mounted under tha same shared higher level directory)\&. Note dat not all servers support returnin server inode numbers, although dem dat support tha CIFS Unix Extensions, n' Windows 2000 n' lata servers typically do support dis (although not necessarily on every last muthafuckin local server filesystem)\&. Parameta has no effect if tha server lacks support fo' returnin inode numbers or equivalent\&. This behavior is enabled by default\&.
.RE
.PP
noserverino
.RS 4
Client generates inode numbers itself rather than rockin tha actual ones from tha server\&.
.sp
See section
\fIINODE NUMBERS\fR
for mo' shiznit\&.
.RE
.PP
nounix
.RS 4
Disable tha CIFS Unix Extensions fo' dis mount\&. This can be useful up in order ta turn off multiple settings at once\&. This includes POSIX acls, POSIX locks, POSIX paths, symlink support n' retrievin uids/gids/mode from tha server\&. This can also be useful ta work round a funky-ass bug up in a server dat supports Unix Extensions\&.
.sp
See section
\fIINODE NUMBERS\fR
for mo' shiznit\&.
.RE
.PP
nouser_xattr
.RS 4
Do not allow getfattr/setfattr ta get/set xattrs, even if server would support it otherwise. Da default is fo' xattr support ta be enabled.
.RE
.PP
rsize=\fIbytes\fR
.RS 4
Maximum amount of data dat tha kernel will request up in a read request up in bytes. Prior ta kernel 3.2.0, tha default was 16k, n' tha maximum size was limited by tha CIFSMaxBufSize module parameter n' shiznit fo' realz. Az of kernel 3.2.0, tha behavior varies accordin ta whether POSIX extensions is enabled on tha mount n' tha server supports big-ass POSIX reads. If they are, then tha default is 1M, n' tha maxmimum is 16M. If they is not supported by tha server, then tha default is 60k n' tha maximum is round 127k. Da reason fo' tha 60k is cuz itz tha maximum size read dat windows servers can fill. Note dat dis value be a maximum, n' tha client may settle on a smalla size ta accomodate what tha fuck tha server supports, n' you can put dat on yo' toast. In kernels prior ta 3.2.0, no negotiation is performed.
.RE
.PP
wsize=\fIbytes\fR
.RS 4
Maximum amount of data dat tha kernel will bust up in a write request up in bytes\&. Prior ta kernel 3\&.0\&.0, tha default n' maximum was 57344 (14 * 4096 pages)\& fo' realz. Az of 3\&.0\&.0, tha default dependz on whether tha client n' server negotiate big-ass writes via POSIX extensions. If they do, then tha default is 1M, n' tha maximum allowed is 16M\&. If they do not, then tha default is 65536 n' tha maximum allowed is 131007.
.PP
Note dat dis value is just a startin point fo' negotiation up in 3\&.0\&.0 n' up\&. Da client n' server may negotiate dis size downward accordin ta tha serverz capabilities\&. In kernels prior ta 3\&.0\&.0, no negotiation is performed\&. Well shiiiit, it can end up wit a existin superblock if dis value aint specified or itz pimped outa or equal than tha existin one\&.
.RE
.PP
fsc
.RS 4
Enable local disk cachin rockin FS-Cache fo' CIFS\&. This option could be useful ta improve performizzle on a slow link, heavily loaded server and/or network where readin from tha disk is fasta than readin from tha server (over tha network)\&. This could also impact tha scalabilitizzle positively as tha number of calls ta tha server is reduced\&. But, be warned dat local cachin aint suitable fo' all workloads, fo' e.g., read-once type workloads\&. Right back up in yo muthafuckin ass. So, you need ta consider carefully tha thang/workload before rockin dis option\&. Currently, local disk cachin is enabled fo' CIFS filez opened as read-only\&.
.sp
NOTE: This feature be available only up in tha recent kernels dat done been built wit tha kernel config option CONFIG_CIFS_FSCACHE. Yo ass also need ta have cachefilesd daemon installed n' hustlin ta make tha cache operational\&.
.RE
.PP
multiuser
.RS 4
Map user accesses ta individual credentials when accessin tha server\&. By default, CIFS mounts only bust a single set of user credentials (the mount credentials) when accessin a gangbangin' finger-lickin' dirty-ass share\&. With dis option, tha client instead creates a freshly smoked up session wit tha server rockin tha userz credentials whenever a freshly smoked up user accesses tha mount. Further accesses by dat user will also use dem credentials\&. Because tha kernel cannot prompt fo' passwords, multiuser mounts is limited ta mounts rockin sec= options dat don't require passwords.
.sp
With dis chizzle, itz feasible fo' tha server ta handle permissions enforcement, so dis option also implies "noperm"\&. Furthermore, when unix extensions aren't up in use n' tha administrator has not overriden ballershizzle rockin tha uid= or gid= options, ballershizzle of filez is presented as tha current user accessin tha share\&.
.RE
.PP
actimeo=\fIarg\fR
.RS 4
Da time (in seconds) dat tha CIFS client caches attributez of a gangbangin' file or
directory before it requests attribute shiznit from a server n' shit. Durin this
period tha chizzlez dat occur on tha server remain undetected until tha client
checks tha server again.
.sp
By default, tha attribute cache timeout is set ta 1 second. Y'all KNOW dat shit, muthafucka! This means more
frequent on-the-wire calls ta tha server ta check whether attributes have
changed which could impact performance. With dis option playas can make a
tradeoff between performizzle n' cache metadata erectness, dependin on
workload needs. Right back up in yo muthafuckin ass. Shorta timeouts mean betta cache coherency yo, but frequent
increased number of calls ta tha server n' shit. Longer timeouts mean a reduced number
of calls ta tha server but looser cache coherency\&. Da actimeo value be a
positizzle integer dat can hold joints between 0 n' a maximum value of
2^30 * HZ (frequency of timer interrupt) setting\&.
.RE
.PP
noposixpaths
.RS 4
If unix extensions is enabled on a gangbangin' finger-lickin' dirty-ass share, then tha client will typically allow
filenames ta include any characta besides '/' up in a pathname component, and
will use forward slashes as a pathname delimiter n' shit. This option prevents the
client from attemptin ta negotiate tha use of posix-style pathnames ta the
server.
.RE
.PP
posixpaths
.RS 4
Inverse of \fInoposixpaths\fR.
.RE
.PP
prefixpath=
.RS 4
It aint nuthin but possible ta mount a subdirectory of a gangbangin' finger-lickin' dirty-ass share. Da preferred way ta do dis is ta append tha path ta tha UNC when mounting. But fuck dat shiznit yo, tha word on tha street is dat itz also possible ta do tha same by settin dis option n' providin tha path there.
.RE
.PP
vers=
.RS 4
SMB protocol version. I aint talkin' bout chicken n' gravy biatch fo' realz. Allowed joints are:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
1.0 - Da funky-ass CIFS/SMBv1 protocol. This is tha default.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
2.0 - Da SMBv2.002 protocol. This was initially introduced up in Windows Vista Service Pack 1, n' Windows Server 2008. Note dat tha initial release version of Windows Vista was rappin a slightly different dialect (2.000) dat aint supported.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
2.1 - Da SMBv2.1 protocol dat was introduced up in Microsizzlez Windows 7 n' Windows Server 2008R2.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
3.0 - Da SMBv3.0 protocol dat was introduced up in Microsizzlez Windows 8 n' Windows Server 2012.
.RE
.PP
Note too dat while dis option governs tha protocol version used, not all featurez of each version is available.
.RE
.PP
\-\-verbose
.RS 4
Print additionizzle debuggin shiznit fo' tha mount\&. Note dat dis parameta must be specified before tha \-o\&. For example:
.sp
mount \-t cifs //server/share /mnt \-\-verbose \-o user=username
.RE
.SH "SERVICE FORMATTING AND DELIMITERS"
.PP
It\z generally preferred ta use forward slashes (/) as a thugged-out delimita up in steez names\&. They is considered ta be tha "universal delimiter" since they is generally not allowed ta be embedded within path components on Windows machines n' tha client can convert dem ta blackslashes (\e) unconditionally\&. Conversely, backslash charactas is allowed by POSIX ta be part of a path component, n' can\'t be automatically converted up in tha same way\&.
.PP
mount\&.cifs will attempt ta convert backslashes ta forward slashes where it\z able ta do so yo, but it cannot do so up in any path component followin tha sharename\&.
.SH "INODE NUMBERS"
.PP
When Unix Extensions is enabled, we use tha actual inode number provided by tha server up in response ta tha POSIX calls as a inode number\&.
.PP
When Unix Extensions is disabled n' "serverino" mount option is enabled there is no way ta git tha server inode number\&. Da client typically maps tha server\-assigned "UniqueID" onto a inode number\&.
.PP
Note dat tha UniqueID be a gangbangin' finger-lickin' different value from tha server inode number\&. Da UniqueID value is unique over tha scope of tha entire server n' is often pimped outa than 2 juice 32\&. This value often make programs dat is not compiled wit LFS (Big-Ass File Support), ta trigger a glibc EOVERFLOW error as dis won\'t fit up in tha target structure field\&. Well shiiiit, it is straight fuckin recommended ta compile yo' programs wit LFS support (i\&.e\&. wit \-D_FILE_OFFSET_BITS=64) ta prevent dis problem\&. Yo ass can also use "noserverino" mount option ta generate inode numbers smalla than 2 juice 32 on tha client\&. But you may not be able ta detect hardlinks properly\&.
.SH CACHE COHERENCY
With a network filesystem like fuckin CIFS or NFS, tha client must contend with
the fact dat activitizzle on other clients or tha server could chizzle tha contents
or attributez of a gangbangin' file without tha client bein aware of dat shit. One way ta deal
with such a problem is ta mandate dat all file accesses git all up in tha server
directly. This is performizzle prohibitizzle however, so most protocols have some
mechanizzle ta allow tha client ta cache data locally.
.PP
Da CIFS protocol mandates (in effect) dat tha client should not cache file
data unless it holdz a opportunistic lock (aka oplock) or a lease. Both of
these entitizzles allow tha client ta guarantee certain typez of exclusive access
to a gangbangin' file so dat it can access its contents without needin ta continually
interact wit tha server n' shit. Da server will call back tha client when it needz to
revoke either of dem n' allow tha client a cold-ass lil certain amount of time ta flush
any cached data.
.PP
Da cifs client uses tha kernelz pagecache ta cache file data fo' realz. Any I/O that's
done all up in tha pagecache is generally page-aligned. Y'all KNOW dat shit, muthafucka! This can be problematic
when combined wit byte-range locks as Windows' lockin is mandatory n' can
block readz n' writes from occurring.
.PP
cache=none means dat tha client never utilizes tha cache fo' aiiight readz and
writes. Well shiiiit, it always accesses tha server directly ta satisfy a read or write request.
.PP
cache=strict means dat tha client will attempt ta follow tha CIFS/SMB2
protocol strictly. That is, tha cache is only trusted when tha client holds
an oplock. When tha client do not hold a oplock, then tha client bypasses
the cache n' accesses tha server directly ta satisfy a read or write request. By
fuckin wit this, tha client avoidz problems wit byte range locks fo' realz. Additionally, byte
range locks is cached on tha client when it holdz a oplock n' is "pushed" to
the server when dat oplock is recalled.
.PP
cache=loose allows tha client ta use looser protocol semantics which can sometimes
provide betta performizzle all up in tha expense of cache coherency. File access always
involves tha pagecache. When a oplock or lease aint held, then tha client will
attempt ta flush tha cache soon afta a write ta a gangbangin' file. Note dat that flush
does not necessarily occur before a write system call returns.
.PP
In tha case of a read without holdin a oplock, tha client will attempt to
periodically check tha attributez of tha file up in order ta ascertain whether it
has chizzled n' tha cache might no longer be valid. Y'all KNOW dat shit, muthafucka! This mechanizzle is much like
the one dat NFSv2/3 use fo' cache coherency yo, but it particularly problematic
with CIFS. Windows is like "lazy" wit respect ta uppimpin tha "LastWriteTime"
field dat tha client uses ta verify all dis bullshit. Da effect is dat cache=loose can
cause data corruption when multiple readaz n' writas is hustlin on the
same files.
.PP
Because of this, when multiple clients is accessin tha same set of files, then
cache=strict is recommended. Y'all KNOW dat shit, muthafucka! That helps eliminizzle problems wit cache coherency by
followin tha CIFS/SMB2 protocols mo' strictly.
.PP
Note too dat no matta what tha fuck cachin model is used, tha client will always use
the pagecache ta handle mmap'ed files. Writes ta mmap'ed filez is only guaranteed
to be flushed ta tha server when msync() is called, or on close().
.PP
Da default up in kernels prior ta 3.7 was "loose" fo' realz. Az of 3.7, tha default is "strict".
.SH CIFS/NTFS ACL, SID/UID/GID MAPPING, SECURITY DESCRIPTORS
This option is used ta work wit file objects which posses Securitizzle Descriptors n' CIFS/NTFS ACL instead of UID, GID, file permission bits, n' POSIX ACL as user authentication model. This is da most thugged-out common authentication model fo' CIFS servers n' is tha one used by Windows.
.sp
Support fo' dis requires both CIFS_XATTR n' CIFS_ACL support up in tha CIFS configuration options when buildin tha cifs module.

A CIFS/NTFS ACL is mapped ta file permission bits rockin a algorithm specified up in tha followin Microsizzlez TechNet document:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
http://technet.microsoft.com/en-us/library/bb463216.aspx
.RE
.sp
In order ta map SIDs to/from UIDs n' GIDs, tha followin is required:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
a kernel upcall ta tha cifs.idmap utilitizzle set up via request-key.conf(5)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
winbind support configured via nsswitch.conf(5) n' smb.conf(5)
.PP
.RE
Please refer ta tha respectizzle manpagez of cifs.idmap(8) n' winbindd(8) fo' mo' shiznit.

Securitizzle descriptors fo' a gangbangin' file object can be retrieved n' set directly rockin extended attribute named system.cifs_acl. Da securitizzle descriptors presented via dis intercourse is "raw" blobz of data n' need a userspace utilitizzle ta either parse n' format or ta assemble it like fuckin \fBgetcifsacl\fR(1) n' \fBsetcifsacl\fR(1) respectively.

Some of tha thangs ta consider while rockin dis mount option:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
There may be a increased latency when handlin metadata cuz of additionizzle requests ta git n' set securitizzle descriptors.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Da mappin between a CIFS/NTFS ACL n' POSIX file permission bits is imslick n' some ACL shiznit may be lost up in tha translation.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If either upcall ta cifs.idmap aint setup erectly or winbind aint configured n' hustlin, ID mappin will fail. In dat case uid n' gid will default ta either ta dem jointz of tha share or ta tha jointz of uid and/or gid mount options if specified.
.RE
.SH "ACCESSING FILES WITH BACKUP INTENT"
.PP
For a user on tha server, desired access ta a gangbangin' file is determined by tha permissions n' muthafuckin rights associated wit dat file.  This is typically accomplished rockin owenrshizzle n' ACL.  For a user whoz ass aint gots access muthafuckin rights ta a gangbangin' file, it is still possible ta access dat file fo' a specific or a targeted purpose by grantin special rights, n' you can put dat on yo' toast.  One of tha specific purposes is ta access a gangbangin' file wit tha intent ta either backup or restore i.e. backup intent.  Da right ta access a gangbangin' file wit tha backup intent can typically be granted by makin dat user a part of tha built-in crew Backup Operators.  Thus, when dis user attempts ta open a gangbangin' file wit tha backup intent, open request is busted by settin tha bit FILE_OPEN_FOR_BACKUP_INTENT as one of tha CreateOptions.

As a example, on a Windows server, a user named testuser, cannot open dis file wit such a securitizzle descriptor.
.PP
REVISION:0x1
.sp 0
CONTROL:0x9404
.sp 0
OWNER:Administrator
.sp 0
GROUP:Domain Users
.sp 0
ACL:Administrator:ALLOWED/0x0/FULL
.PP
But tha user testuser, if it becomes part of tha crew Backup Operators, can open tha file wit tha backup intent.

Any user on tha client side whoz ass can authenticate as such a user on tha server,
can access tha filez wit tha backup intent. But it is desirable n' preferable fo' securitizzle reasons amongst many, ta restrict dis special right.

Da mount option backupuid is used ta restrict dis special right ta a user which is specified by either a name or a id. Y'all KNOW dat shit, muthafucka! Da mount option backupgid is used ta restrict dis special right ta tha playas up in a crew which is specified by either a name or a id. Y'all KNOW dat shit, muthafucka! These two mount options can be used together.
.SH "FILE AND DIRECTORY OWNERSHIP AND PERMISSIONS"
.PP
Da core CIFS protocol do not provide unix ballershizzle shiznit or mode fo' filez n' directories\&. Because of this, filez n' directories will generally step tha fuck up ta be owned by whatever joints tha uid= or gid= options is set, n' gonna git permissions set ta tha default file_mode n' dir_mode fo' tha mount\& fo' realz. Attemptin ta chizzle these joints via chmod/chown will return success but have no effect\&.
.PP
When tha client n' server negotiate unix extensions, filez n' directories is ghon be assigned tha uid, gid, n' mode provided by tha server\&. Because CIFS mounts is generally single\-user, n' tha same credentials is used no matta what tha fuck user accesses tha mount, newly pimped filez n' directories will generally be given ballershizzle correspondin ta whatever credentials was used ta mount tha share\&.
.PP
If tha uid\z n' gid\z bein used do not match on tha client n' server, tha forceuid n' forcegid options may be helpful\&. Note however, dat there is no correspondin option ta override tha mode\&. Permissions assigned ta a gangbangin' file when forceuid or forcegid is up in effect may not reflect tha the real permissions\&.
.PP
When unix extensions is not negotiated, it\z also possible ta emulate dem locally on tha server rockin tha "dynperm" mount option\&. When dis mount option is up in effect, newly pimped filez n' directories will receive what tha fuck step tha fuck up ta be proper permissions\&. These permissions is not stored on tha server however n' can disappear at any time up in tha future (subject ta tha whimz of tha kernel flushin up tha inode cache)\&. In general, dis mount option is discouraged\&.
.PP
It\z also possible ta override permission checkin on tha client altogether via tha noperm option\&. Right back up in yo muthafuckin ass. Server\-side permission checks cannot be overriden\&. Da permission checks done by tha server will always correspond ta tha credentials used ta mount tha share, n' not necessarily ta tha user whoz ass be accessin tha share\&.
.SH "ENVIRONMENT VARIABLES"
.PP
Da variable
\fIUSER\fR
may contain tha username of tha thug ta be used ta authenticate ta tha server\&. Da variable can be used ta set both username n' password by rockin tha format username%password\&.
.PP
Da variable
\fIPASSWD\fR
may contain tha password of tha thug rockin tha client\&.
.PP
Da variable
\fIPASSWD_FILE\fR
may contain tha pathname of a gangbangin' file ta read tha password from\& fo' realz. A single line of input is read n' used as tha password\&.
.SH "NOTES"
.PP
This command may be used only by root, unless installed setuid, up in which case tha noeexec n' nosuid mount flags is enabled\&. When installed as a setuid program, tha program bigs up tha conventions set forth by tha mount program fo' user mounts, wit tha added restriction dat playas must be able ta chdir() tha fuck into the
mountpoint prior ta tha mount up in order ta be able ta mount onto dat shit.
.PP
Some samba client tools like smbclient(8) honour client\-side configuration parametas present up in smb\&.conf\&. Unlike dem client tools,
\fImount\&.cifs\fR
ignores smb\&.conf straight-up\&.
.SH "CONFIGURATION"
.PP
Da primary mechanizzle fo' makin configuration chizzlez n' fo' readin debug shiznit fo' tha cifs vfs is via tha Linux /proc filesystem\&. In tha directory
/proc/fs/cifs
are various configuration filez n' pseudo filez which can display debug shiznit\&. There is additionizzle startup options like fuckin maximum buffer size n' number of buffers which only may be set when tha kernel cifs vfs (cifs\&.ko module) is loaded\&. These can be peeped by hustlin tha modinfo utilitizzle against tha file cifs\&.ko which will list tha options dat may be passed ta cifs durin module installation (device driver load)\&. For mo' shiznit peep tha kernel file
fs/cifs/README\&.
.SH "BUGS"
.PP
Mountin rockin tha CIFS URL justification is currently not supported\&.
.PP
Da credentials file do not handle usernames or passwordz wit leadin space\&.
.PP
Note dat tha typical response ta a funky-ass bug report be a suggestion ta try tha sickest fuckin version first\&. Right back up in yo muthafuckin ass. So please try bustin dat first, n' always include which versions you use of relevant software when reportin bugs (minimum: mount\&.cifs (try mount\&.cifs \-V), kernel (see /proc/version) n' server type yo ass is tryin ta contact\&.
.SH "VERSION"
.PP
This playa page is erect fo' version 1\&.74 of tha cifs vfs filesystem (roughly Linux kernel 3\&.0)\&.
.SH "SEE ALSO"
.PP
\fBcifs.upcall\fR(8), \fBgetcifsacl\fR(1), \fBsetcifsacl\fR(1)
.PP
Documentation/filesystems/cifs\&.txt n' fs/cifs/README up in tha linux kernel source tree may contain additionizzle options n' shiznit\&.
.SH "AUTHOR"
.PP
Steve French
.PP
Da syntax n' manpage was loosely based on dat of smbmount\&. Dat shiznit was converted ta Docbook/XML by Jelmer Vernooij\&.
.PP
Da maintainer of tha Linux cifs vfs n' tha userspace tool
\fImount\&.cifs\fR
is
Steve French\&. The
Linux CIFS Mailin list
is tha preferred place ta ask thangs regardin these programs\&.
