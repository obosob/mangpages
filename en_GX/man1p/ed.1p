.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "ED" 1P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" ed 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
ed \- edit text
.SH SYNOPSIS
.LP
\fBed\fP \fB[\fP\fB-p\fP \fIstring\fP\fB][\fP\fB-s\fP\fB][\fP\fIfile\fP\fB]\fP
.SH DESCRIPTION
.LP
Da \fIed\fP utilitizzle be a line-oriented text editor dat uses two
modes: \fIcommand mode\fP n' \fIinput mode\fP. In command
mode tha input charactas shall be interpreted as commands, n' in
input mode they shall be interpreted as text. Right back up in yo muthafuckin ass. See tha EXTENDED
DESCRIPTION section.
.SH OPTIONS
.LP
Da \fIed\fP utilitizzle shall conform ta tha Base Definitions volume
of IEEE\ Std\ 1003.1-2001, Section 12.2, Utilitizzle Syntax Guidelines.
.LP
Da followin options shall be supported:
.TP 7
\fB-p\ \fP \fIstring\fP
Use \fIstring\fP as tha prompt strang when up in command mode. By default,
there shall be no prompt string.
.TP 7
\fB-s\fP
Suppress tha freestylin of byte counts by \fBe\fP, \fBE\fP, \fBr\fP,
and \fBw\fP commandz n' of tha \fB'!'\fP prompt after
a !\fIcommand\fP.
.sp
.SH OPERANDS
.LP
Da followin operand shall be supported:
.TP 7
\fIfile\fP
If tha \fIfile\fP argument is given, \fIed\fP shall simulate a \fBe\fP
command on tha file named by tha pathname,
\fIfile\fP, before acceptin commandz from tha standard input. If
the \fIfile\fP operand is \fB'-'\fP, tha thangs up in dis biatch are
unspecified.
.sp
.SH STDIN
.LP
Da standard input shall be a text file consistin of commands, as
busted lyrics bout up in tha EXTENDED DESCRIPTION section.
.SH INPUT FILES
.LP
Da input filez shall be text files.
.SH ENVIRONMENT VARIABLES
.LP
Da followin environment variablez shall affect tha execution of
\fIed\fP:
.TP 7
\fIHOME\fP
Determine tha pathname of tha userz home directory.
.TP 7
\fILANG\fP
Provide a thugged-out default value fo' tha internationalization variablez that
are unset or null. (See tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, Section 8.2, Internationalization Variables
for
the precedence of internationalization variablez used ta determine
the jointz of locale categories.)
.TP 7
\fILC_ALL\fP
If set ta a non-empty strang value, override tha jointz of all the
other internationalization variables.
.TP 7
\fILC_COLLATE\fP
.sp
Determine tha locale fo' tha behavior of ranges, equivalence classes,
and multi-characta collatin elements within regular
expressions.
.TP 7
\fILC_CTYPE\fP
Determine tha locale fo' tha interpretation of sequencez of bytes
of text data as charactas (for example, single-byte as
opposed ta multi-byte charactas up in arguments n' input files) and
the behavior of characta classes within regular
expressions.
.TP 7
\fILC_MESSAGES\fP
Determine tha locale dat should be used ta affect tha format and
contentz of diagnostic lyrics freestyled ta standard error and
informatizzle lyrics freestyled ta standard output.
.TP 7
\fINLSPATH\fP
Determine tha location of message catalogs fo' tha processin of \fILC_MESSAGES
\&.\fP 
.sp
.SH ASYNCHRONOUS EVENTS
.LP
Da \fIed\fP utilitizzle shall take tha standard action fo' all signals
(see tha ASYNCHRONOUS EVENTS section up in \fIUtilitizzle Description Defaults\fP
) wit tha followin exceptions:
.TP 7
SIGINT
Da \fIed\fP utilitizzle shall interrupt its current activity, write the
strin \fB"?\\n"\fP ta standard output, n' return to
command mode (see tha EXTENDED DESCRIPTION section).
.TP 7
SIGHUP
If tha buffer aint empty n' has chizzled since tha last write, the
\fIed\fP utilitizzle shall attempt ta write a cold-ass lil copy of the
buffer up in a gangbangin' file. First, tha file named \fBed.hup\fP up in tha current
directory shall be used; if dat fails, tha file named
\fBed.hup\fP up in tha directory named by tha \fIHOME\fP environment
variable shall be used. Y'all KNOW dat shit, muthafucka! In any case, tha \fIed\fP utility
shall exit without returnin ta command mode.
.TP 7
SIGQUIT
Da \fIed\fP utilitizzle shall ignore dis event.
.sp
.SH STDOUT
.LP
Various editin commandz n' tha promptin feature (see \fB-p\fP)
write ta standard output, as busted lyrics bout up in tha EXTENDED
DESCRIPTION section.
.SH STDERR
.LP
Da standard error shall be used only fo' diagnostic lyrics.
.SH OUTPUT FILES
.LP
Da output filez shall be text filez whose formats is dependent on
the editin commandz given.
.SH EXTENDED DESCRIPTION
.LP
Da \fIed\fP utilitizzle shall operate on a cold-ass lil copy of tha file it is editing;
changes made ta tha copy shall have no effect on the
file until a \fBw\fP (write) command is given. I aint talkin' bout chicken n' gravy biatch. Da copy of tha text
is called tha \fIbuffer\fP.
.LP
Commandz ta \fIed\fP gotz a simple n' regular structure: zero, one,
or two \fIaddresses\fP followed by a single-character
\fIcommand\fP, possibly followed by parametas ta dat command. Y'all KNOW dat shit, muthafucka! These
addresses specify one or mo' lines up in tha buffer n' shit. Every
command dat requires addresses has default addresses, so dat the
addresses straight-up often can be omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha \fB-p\fP option is
specified, tha prompt strang shall be freestyled ta standard output before
each command is read.
.LP
In general, only one command can step tha fuck up on a line. Certain commands
allow text ta be input. This text is placed up in the
appropriate place up in tha buffer n' shit. While \fIed\fP be acceptin text,
it is holla'd ta be up in \fIinput mode\fP. In dis mode, no
commandz shall be recognized; all input is merely collected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Input
mode is terminated by enterin a line consistin of two
characters: a period ( \fB'.'\fP ) followed by a <newline>. This line
is not considered part of tha input text.
.SS Regular Expressions up in ed
.LP
Da \fIed\fP utilitizzle shall support basic regular expressions, as busted lyrics about
in tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, Section 9.3, Basic Regular Expressions. Right back up in yo muthafuckin ass. Since
regular expressions up in \fIed\fP is always matched against single
lines (excludin tha terminatin <newline>s), never
against any larger section of text, there is no way fo' a regular
expression ta match a <newline>.
.LP
A null RE shall be equivalent ta tha last RE encountered.
.LP
Regular expressions is used up in addresses ta specify lines, n' in
some commandz (for example, tha \fBs\fP substitute command)
to specify portionz of a line ta be substituted.
.SS Addresses up in ed
.LP
Addressin up in \fIed\fP relates ta tha current line. Generally, the
current line is tha last line affected by a cold-ass lil command. Y'all KNOW dat shit, muthafucka! The
current line number is tha address of tha current line. If tha edit
buffer aint empty, tha initial value fo' tha current line
shall be tha last line up in tha edit buffer; otherwise, zero.
.LP
Addresses shall be constructed as bigs up:
.IP " 1." 4
Da period characta ( \fB'.'\fP ) shall address tha current line.
.LP
.IP " 2." 4
Da dollar sign characta ( \fB'$'\fP ) shall address tha last line
of tha edit buffer.
.LP
.IP " 3." 4
Da positizzle decimal number \fIn\fP shall address tha \fIn\fPth line
of tha edit buffer.
.LP
.IP " 4." 4
Da apostrophe-x characta pair ( \fB"'x"\fP ) shall address tha line
marked wit tha mark name characta \fIx\fP, which
shall be a lowercase letta from tha portable characta set. Well shiiiit, it shall
be a error if tha characta has not been set ta mark a line
or if tha line dat was marked aint currently present up in tha edit
buffer.
.LP
.IP " 5." 4
A BRE enclosed by slash charactas ( \fB'/'\fP ) shall address the
first line found by searchin forwardz from tha line
followin tha current line toward tha end of tha edit buffer n' stopping
at tha straight-up original gangsta line fo' which tha line excludin the
terminatin <newline> matches tha BRE. Da BRE consistin of a null
BRE delimited by a pair of slash charactas shall address
the next line fo' which tha line excludin tha terminatin <newline>
matches tha last BRE encountered. Y'all KNOW dat shit, muthafucka! In addition, the
second slash can be omitted all up in tha end of a cold-ass lil command line. Within the
BRE, a funky-ass backslash-slash pair ( \fB"\\/"\fP ) shall represent
a literal slash instead of tha BRE delimiter n' shit. If necessary, tha search
shall wrap round ta tha beginnin of tha buffer and
continue up ta n' includin tha current line, so dat tha entire
buffer is searched.
.LP
.IP " 6." 4
A BRE enclosed by question-mark charactas ( \fB'?'\fP ) shall address
the first line found by searchin backwardz from the
line precedin tha current line toward tha beginnin of tha edit buffer
and stoppin all up in tha straight-up original gangsta line fo' which tha line excluding
the terminatin <newline> matches tha BRE. Da BRE consistin of a
null BRE delimited by a pair of question-mark charactas (
\fB"??"\fP ) shall address tha previous line fo' which tha line excluding
the terminatin <newline> matches tha last BRE
encountered. Y'all KNOW dat shit, muthafucka! In addition, tha second question-mark can be omitted
at tha end of a cold-ass lil command line. Within tha BRE, a
backslash-question-mark pair ( \fB"\\?"\fP ) shall represent a literal
question mark instead of tha BRE delimiter n' shit. If necessary,
the search shall wrap round ta tha end of tha buffer n' continue
up ta n' includin tha current line, so dat tha entire buffer
is searched.
.LP
.IP " 7." 4
A plus-sign ( \fB'+'\fP ) or hyphen characta ( \fB'-'\fP ) followed
by a thugged-out decimal number shall address tha current line
plus or minus tha number n' shiznit fo' realz. A plus-sign or hyphen characta not followed
by a thugged-out decimal number shall address tha current line plus or
minus 1.
.LP
.LP
Addresses can be followed by zero or mo' address offsets, optionally
<blank>-separated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. Address offsets is constructed
as bigs up:
.IP " *" 3
A plus-sign or hyphen characta followed by a thugged-out decimal number shall
add or subtract, respectively, tha indicated number of lines
to or from tha address fo' realz. A plus-sign or hyphen characta not followed
by a thugged-out decimal number shall add or subtract 1 ta or from the
address.
.LP
.IP " *" 3
A decimal number shall add tha indicated number of lines ta tha address.
.LP
.LP
It shall not be a error fo' a intermediate address value ta be less
than zero or pimped outa than tha last line up in tha edit
buffer n' shit. Well shiiiit, it shall be a error fo' tha final address value ta be less
than zero or pimped outa than tha last line up in tha edit buffer n' shit. It
shall be a error if a search fo' a BRE fails ta find a matchin line.
.LP
Commandz accept zero, one, or two addresses. If mo' than tha required
number of addresses is provided ta a cold-ass lil command that
requires zero addresses, it shall be a error. Shiiit, dis aint no joke. Otherwise, if more
than tha required number of addresses is provided ta a cold-ass lil command,
the addresses specified first shall be evaluated n' then discarded
until tha maximum number of valid addresses remain, fo' the
specified command.
.LP
Addresses shall be separated from each other by a cold-ass lil comma ( \fB','\fP
) or semicolon characta ( \fB';'\fP ). In tha case of
a semicolon separator, tha current line ( \fB'.'\fP ) shall be set
to tha straight-up original gangsta address, n' only then will tha second address
be calculated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This feature can be used ta determine tha starting
line fo' forwardz n' backwardz searches; peep rulez 5. n' 6.
.LP
Addresses can be omitted on either side of tha comma or semicolon
separator, up in which case tha resultin address pairs shall be
as bigs up:
.TS C
center; l l.
\fBSpecified\fP	\fBResulting\fP
,	1 , $,
addr	1 , addr
addr ,	addr , addr
;	. ; $
; addr	. ; addr
addr ;	addr ; addr
.TE
.LP
Any <blank>s included between addresses, address separators, or address
offsets shall be ignored.
.SS Commandz up in ed
.LP
In tha followin list of \fIed\fP commands, tha default addresses
are shown up in parentheses. Da number of addresses shown in
the default shall be tha number expected by tha command. Y'all KNOW dat shit, muthafucka! Da parentheses
are not part of tha address; they show dat tha given
addresses is tha default.
.LP
It be generally invalid fo' mo' than one command ta step tha fuck up on a line.
But fuck dat shiznit yo, tha word on tha street is dat any command (except \fBe\fP, \fBE\fP,
\fBf\fP, \fBq\fP, \fBQ\fP, \fBr\fP, \fBw\fP, n' \fB!\fP) can be suffixed
by tha letta \fBl\fP, \fBn\fP, or \fBp\fP; in
which case, except fo' tha \fBl\fP, \fBn\fP, n' \fBp\fP commands,
the command shall be executed n' then tha freshly smoked up current line
shall be freestyled as busted lyrics bout below under tha \fBl\fP, \fBn\fP, and
\fBp\fP commands. When a \fBl\fP, \fBn\fP, or \fBp\fP
suffix is used wit a \fBl\fP, \fBn\fP, or \fBp\fP command, tha command
shall write ta standard output as busted lyrics bout below yo, but
it is unspecified whether tha suffix writes tha current line again
in tha axed format or whether tha suffix has no effect. For
example, tha \fBpl\fP command (base \fBp\fP command wit a \fBl\fP
suffix) shall either write just tha current line or write it
twice-once as specified fo' \fBp\fP n' once as specified fo' \fBl\fP.
Also, tha \fBg\fP, \fBG\fP, \fBv\fP, n' \fBV\fP
commandz shall take a cold-ass lil command as a parameter.
.LP
Each address component can be preceded by zero or mo' <blank>s. The
command letta can be preceded by zero or more
<blank>s. If a suffix letta ( \fBl\fP, \fBn\fP, or \fBp\fP) is given,
the application shall ensure dat it immediately
bigs up tha command.
.LP
Da \fBe\fP, \fBE\fP, \fBf\fP, \fBr\fP, n' \fBw\fP commandz shall
take a optionizzle \fIfile\fP parameter, separated from
the command letta by one or mo' <blank>s.
.LP
If chizzlez done been made up in tha buffer since tha last \fBw\fP command
that freestyled tha entire buffer, \fIed\fP shall warn the
user if a attempt is made ta destroy tha editor buffer via tha \fBe\fP
or \fBq\fP commands. Da \fIed\fP utilitizzle shall write
the string:
.sp
.RS
.nf

\fB"?\\n"
\fP
.fi
.RE
.LP
(followed by a explanatory message if \fIhelp mode\fP has been enabled
via tha \fBH\fP command) ta standard output n' shall
continue up in command mode wit tha current line number unchanged. Y'all KNOW dat shit, muthafucka! If
the \fBe\fP or \fBq\fP command is repeated wit no
intervenin command, it shall take effect.
.LP
If a terminal disconnect is detected:
.IP " *" 3
If tha buffer aint empty n' has chizzled since tha last write, the
\fIed\fP utilitizzle shall attempt ta write a cold-ass lil copy of the
buffer ta a gangbangin' file named \fBed.hup\fP up in tha current directory. If this
write fails, \fIed\fP shall attempt ta write a cold-ass lil copy of the
buffer ta a gangbangin' filename \fBed.hup\fP up in tha directory named by tha \fIHOME\fP
environment variable. If both these attempts fail,
\fIed\fP shall exit without savin tha buffer.
.LP
.IP " *" 3
Da \fIed\fP utilitizzle shall not write tha file ta tha currently remembered
pathname or return ta command mode, n' shall
terminizzle wit a non-zero exit status.
.LP
.LP
If a end-of-file is detected on standard input:
.IP " *" 3
If tha \fIed\fP utilitizzle is up in input mode, \fIed\fP shall terminate
input mode n' return ta command mode. Well shiiiit, it is unspecified if
any partially entered lines (that is, input text without a terminating
<newline>) is discarded from tha input text.
.LP
.IP " *" 3
If tha \fIed\fP utilitizzle is up in command mode, it shall act as if a \fBq\fP
command had been entered.
.LP
.LP
If tha closin delimita of a RE or of a replacement strang (for
example, \fB'/'\fP ) up in a \fBg\fP, \fBG\fP, \fBs\fP,
\fBv\fP, or \fBV\fP command would be tha last characta before a <newline>,
that delimita can be omitted, up in which case
the addressed line shall be written. I aint talkin' bout chicken n' gravy biatch. For example, tha followin pairs
of commandz is equivalent:
.sp
.RS
.nf

\fBs/s1/s2   s/s1/s2/p
g/s1      g/s1/p
?s1       ?s1?
\fP
.fi
.RE
.LP
If a invalid command is entered, \fIed\fP shall write tha string:
.sp
.RS
.nf

\fB"?\\n"
\fP
.fi
.RE
.LP
(followed by a explanatory message if \fIhelp mode\fP has been enabled
via tha \fBH\fP command) ta standard output n' shall
continue up in command mode wit tha current line number unchanged.
.SS Append Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(.)a
<\fP\fItext\fP\fB>
\&.
\fP
.fi
.RE
.sp
.LP
Da \fBa\fP command shall read tha given text n' append it after
the addressed line; tha current line number shall become the
address of tha last banged line or, if there was none, tha addressed
line fo' realz. Address 0 shall be valid fo' dis command; it shall
cause tha appended text ta be placed all up in tha beginnin of tha buffer.
.SS Chizzle Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(.,.)c
<\fP\fItext\fP\fB>
\&.
\fP
.fi
.RE
.sp
.LP
Da \fBc\fP command shall delete tha addressed lines, then accept
input text dat replaces these lines; tha current line shall
be set ta tha address of tha last line input; or, if there was none,
at tha line afta tha last line deleted; if tha lines deleted
were originally all up in tha end of tha buffer, tha current line number
shall be set ta tha address of tha freshly smoked up last line; if no lines
remain up in tha buffer, tha current line number shall be set ta zero.
Address 0 shall be valid fo' dis command; it shall be
interpreted as if address 1 was specified.
.SS Delete Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(.,.)d
\fP
.fi
.RE
.sp
.LP
Da \fBd\fP command shall delete tha addressed lines from tha buffer.
Da address of tha line afta tha last line deleted shall
become tha current line number; if tha lines deleted was originally
at tha end of tha buffer, tha current line number shall be set
to tha address of tha freshly smoked up last line; if no lines remain up in tha buffer,
the current line number shall be set ta zero.
.SS Edit Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBe\fP \fB[\fP\fIfile\fP\fB]\fP
.fi
.RE
.sp
.LP
Da \fBe\fP command shall delete tha entire contentz of tha buffer
and then read up in tha file named by tha pathname \fIfile\fP.
Da current line number shall be set ta tha address of tha last line
of tha buffer n' shit. If no pathname is given, tha currently
remembered pathname, if any, shall be used (see tha \fBf\fP command).
Da number of bytes read shall be freestyled ta standard
output, unless tha \fB-s\fP option was specified, up in tha following
format:
.sp
.RS
.nf

\fB"%d\\n", <\fP\fInumber of bytes read\fP\fB>
\fP
.fi
.RE
.LP
Da name \fIfile\fP shall be remembered fo' possible use as a thugged-out default
pathname up in subsequent \fBe\fP, \fBE\fP, \fBr\fP, and
\fBw\fP commands. If \fIfile\fP is replaced by \fB'!'\fP, tha rest
of tha line shall be taken ta be a gangbangin' finger-lickin' dirty-ass shell command line
whose output is ta be read. Y'all KNOW dat shit, muthafucka! Such a gangbangin' finger-lickin' dirty-ass shell command line shall not be
remembered as tha current \fIfile\fP fo' realz. All marks shall be
discarded upon tha completion of a successful \fBe\fP command. Y'all KNOW dat shit, muthafucka! If
the buffer has chizzled since tha last time tha entire buffer was
written, tha user shall be warned, as busted lyrics bout previously.
.SS Edit Without Checkin Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBE\fP \fB[\fP\fIfile\fP\fB]\fP
.fi
.RE
.sp
.LP
Da \fBE\fP command shall possess all propertizzles n' restrictions
of tha \fBe\fP command except dat tha editor shall not
check ta peep whether any chizzlez done been made ta tha buffer since
the last \fBw\fP command.
.SS Filename Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBf\fP \fB[\fP\fIfile\fP\fB]\fP
.fi
.RE
.sp
.LP
If \fIfile\fP is given, tha \fBf\fP command shall chizzle tha currently
remembered pathname ta \fIfile\fP; whether tha name is
changed or not, it shall then write tha (possibly new) currently remembered
pathname ta tha standard output up in tha following
format:
.sp
.RS
.nf

\fB"%s\\n", <\fP\fIpathname\fP\fB>
\fP
.fi
.RE
.LP
Da current line number shall be unchanged.
.SS Global Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(1,$)g/\fP\fIRE\fP\fB/\fP\fIcommand list\fP
.fi
.RE
.sp
.LP
In tha \fBg\fP command, tha straight-up original gangsta step shall be ta mark every last muthafuckin line
for which tha line excludin tha terminatin <newline>
matches tha given RE. Then, goin sequentially from tha beginning
of tha file ta tha end of tha file, tha given \fIcommand list\fP
shall be executed fo' each marked line, wit tha current line number
set ta tha address of dat line fo' realz. Any line modified by the
\fIcommand list\fP shall be unmarked. Y'all KNOW dat shit, muthafucka! When tha \fBg\fP command completes,
the current line number shall have tha value assigned
by tha last command up in tha \fIcommand list\fP. If there was no matching
lines, tha current line number shall not be chizzled. Y'all KNOW dat shit, muthafucka! A
single command or tha straight-up original gangsta of a list of commandz shall step tha fuck up on
the same line as tha global command. Y'all KNOW dat shit, muthafucka! All linez of a multi-line
list except tha last line shall be ended wit a funky-ass backslash preceding
the terminatin <newline>; tha \fBa\fP, \fBi\fP, and
\fBc\fP commandz n' associated input is permitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da \fB'.'\fP
terminatin input mode can be omitted if it would be the
last line of tha \fIcommand list\fP fo' realz. An empty \fIcommand list\fP shall
be equivalent ta tha \fBp\fP command. Y'all KNOW dat shit, muthafucka! Da use of the
\fBg\fP, \fBG\fP, \fBv\fP, \fBV\fP, n' \fB!\fP commandz up in tha \fIcommand
list\fP produces undefined thangs up in dis biatch fo' realz. Any character
other than <space> or <newline> can be used instead of a slash to
delimit tha RE. Within tha RE, tha RE delimiter
itself can be used as a literal characta if it is preceded by a funky-ass backslash.
.SS Interactizzle Global Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(1,$)G/\fP\fIRE\fP\fB/
\fP
.fi
.RE
.sp
.LP
In tha \fBG\fP command, tha straight-up original gangsta step shall be ta mark every last muthafuckin line
for which tha line excludin tha terminatin <newline>
matches tha given RE. Then, fo' every last muthafuckin such line, dat line shall be
written, tha current line number shall be set ta tha address of
that line, n' any one command (other than one of tha \fBa\fP, \fBc\fP,
\fBi\fP, \fBg\fP, \fBG\fP, \fBv\fP, n' \fBV\fP
commands) shall be read n' executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. A <newline> shall act as a null
command (causin no action ta be taken on tha current
line); a \fB'&'\fP shall cause tha re-execution of da most thugged-out recent
non-null command executed within tha current invocation
of \fBG\fP. Note dat tha commandz input as part of tha execution
of tha \fBG\fP command can address n' affect any lines up in the
buffer n' shiznit fo' realz. Any line modified by tha command shall be unmarked. Y'all KNOW dat shit, muthafucka! Da final
value of tha current line number shall be tha value set by
the last command successfully executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Note dat tha last command
successfully executed shall be tha \fBG\fP command itself if a
command fails or tha null command is specified.) If there was no
matchin lines, tha current line number shall not be chizzled. Y'all KNOW dat shit, muthafucka! The
\fBG\fP command can be terminated by a SIGINT signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack fo' realz. Any character
other than <space> or <newline> can be used
instead of a slash ta delimit tha RE n' tha replacement. Within the
RE, tha RE delimita itself can be used as a literal character
if it is preceded by a funky-ass backslash.
.SS Help Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBh
\fP
.fi
.RE
.sp
.LP
Da \fBh\fP command shall write a gangbangin' finger-lickin' dirty-ass short message ta standard output
that explains tha reason fo' da most thugged-out recent \fB'?'\fP
notification. I aint talkin' bout chicken n' gravy biatch. Da current line number shall be unchanged.
.SS Help-Mode Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBH
\fP
.fi
.RE
.sp
.LP
Da \fBH\fP command shall cause \fIed\fP ta enta a mode up in which
help lyrics (see tha \fBh\fP command) shall be freestyled to
standard output fo' all subsequent \fB'?'\fP notifications. Da \fBH\fP
command alternately shall turn dis mode on n' off; it
is initially off. If tha help-mode is bein turned on, tha \fBH\fP
command also explains tha previous \fB'?'\fP notification,
if there was one. Da current line number shall be unchanged.
.SS Insert Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(.)i
<\fP\fItext\fP\fB>
\&.
\fP
.fi
.RE
.sp
.LP
Da \fBi\fP command shall bang tha given text before tha addressed
line; tha current line is set ta tha last banged line
or, if there was none, ta tha addressed line. This command differs
from tha \fBa\fP command only up in tha placement of tha input
text fo' realz. Address 0 shall be valid fo' dis command; it shall be interpreted
as if address 1 was specified.
.SS Join Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(.,.+1)j
\fP
.fi
.RE
.sp
.LP
Da \fBj\fP command shall join contiguous lines by removin tha appropriate
<newline>s. If exactly one address is given,
this command shall do nothing. If lines is joined, tha current line
number shall be set ta tha address of tha joined line;
otherwise, tha current line number shall be unchanged.
.SS Mark Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(.)k\fP\fIx\fP
.fi
.RE
.sp
.LP
Da \fBk\fP command shall mark tha addressed line wit name \fIx\fP,
which tha application shall ensure be a lowercase letter
from tha portable characta set. Da address \fB"'x"\fP shall then
refer ta dis line; tha current line number shall be
unchanged.
.SS List Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(.,.)l
\fP
.fi
.RE
.sp
.LP
Da \fBl\fP command shall write ta standard output tha addressed lines
in a visually unambiguous form. Da charactas listed in
the Base Definitions volume of IEEE\ Std\ 1003.1-2001, Table 5-1,
Escape Sequences n' Associated Actions ( \fB'\\\\'\fP,
\fB'\\a'\fP, \fB'\\b'\fP, \fB'\\f'\fP, \fB'\\r'\fP, \fB'\\t'\fP,
\fB'\\v'\fP ) shall be freestyled as the
correspondin escape sequence; tha \fB'\\n'\fP up in dat table is not
applicable. Non-printable charactas not up in tha table shall
be freestyled as one three-digit octal number (with a precedin backslash
character) fo' each byte up in tha characta (most significant
byte first). If tha size of a funky-ass byte on tha system is pimped outa than nine
bits, tha format used fo' non-printable charactas is
implementation-defined.
.LP
Long lines shall be folded, wit tha deal wit foldin indicated by
<newline> preceded by a funky-ass backslash; tha length at which
foldin occurs is unspecified yo, but should be appropriate fo' tha output
device. Da end of each line shall be marked wit a
\fB'$'\fP, n' \fB'$'\fP charactas within tha text shall be written
with a precedin backslash fo' realz. An \fBl\fP command can be
appended ta any other command other than \fBe\fP, \fBE\fP, \fBf\fP,
\fBq\fP, \fBQ\fP, \fBr\fP, \fBw\fP, or \fB!\fP. The
current line number shall be set ta tha address of tha last line written.
.SS Move Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(.,.)m\fP\fIaddress\fP
.fi
.RE
.sp
.LP
Da \fBm\fP command shall reposizzle tha addressed lines afta the
line addressed by \fIaddress\fP fo' realz. Address 0 shall be valid
for \fIaddress\fP n' cause tha addressed lines ta be moved ta the
beginnin of tha buffer n' shit. Well shiiiit, it shall be a error if address
\fIaddress\fP falls within tha range of moved lines. Da current line
number shall be set ta tha address of tha last line
moved.
.SS Number Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(.,.)n
\fP
.fi
.RE
.sp
.LP
Da \fBn\fP command shall write ta standard output tha addressed lines,
precedin each line by its line number n' a
<tab>; tha current line number shall be set ta tha address of the
last line written. I aint talkin' bout chicken n' gravy biatch. Da \fBn\fP command can be appended to
any command other than \fBe\fP, \fBE\fP, \fBf\fP, \fBq\fP, \fBQ\fP,
\fBr\fP, \fBw\fP, or \fB!\fP.
.SS Print Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(.,.)p
\fP
.fi
.RE
.sp
.LP
Da \fBp\fP command shall write ta standard output tha addressed lines;
the current line number shall be set ta tha address of
the last line written. I aint talkin' bout chicken n' gravy biatch. Da \fBp\fP command can be appended ta any
command other than \fBe\fP, \fBE\fP, \fBf\fP, \fBq\fP,
\fBQ\fP, \fBr\fP, \fBw\fP, or \fB!\fP.
.SS Prompt Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBP
\fP
.fi
.RE
.sp
.LP
Da \fBP\fP command shall cause \fIed\fP ta prompt wit a asterisk
( \fB'*'\fP ) (or \fIstring\fP, if \fB-p\fP is
specified) fo' all subsequent commands. Da \fBP\fP command alternatively
shall turn dis mode on n' off; it shall be initially
on if tha \fB-p\fP option is specified; otherwise, off. Da current
line number shall be unchanged.
.SS Quit Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBq
\fP
.fi
.RE
.sp
.LP
Da \fBq\fP command shall cause \fIed\fP ta exit. If tha buffer has
changed since tha last time tha entire buffer was written,
the user shall be warned, as busted lyrics bout previously.
.SS Quit Without Checkin Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBQ
\fP
.fi
.RE
.sp
.LP
Da \fBQ\fP command shall cause \fIed\fP ta exit without checking
whether chizzlez done been made up in tha buffer since tha last
\fBw\fP command.
.SS Read Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB($)r\fP \fB[\fP\fIfile\fP\fB]\fP
.fi
.RE
.sp
.LP
Da \fBr\fP command shall read up in tha file named by tha pathname \fIfile\fP
and append it afta tha addressed line. If no
\fIfile\fP argument is given, tha currently remembered pathname, if
any, shall be used (see tha \fBe\fP n' \fBf\fP commands).
Da currently remembered pathname shall not be chizzled unless there
is no remembered pathname fo' realz. Address 0 shall be valid for
\fBr\fP n' shall cause tha file ta be read all up in tha beginnin of the
buffer n' shit. If tha read is successful, n' \fB-s\fP was not
specified, tha number of bytes read shall be freestyled ta standard output
in tha followin format:
.sp
.RS
.nf

\fB"%d\\n", <\fP\fInumber of bytes read\fP\fB>
\fP
.fi
.RE
.LP
Da current line number shall be set ta tha address of tha last line
read in. I aint talkin' bout chicken n' gravy biatch. If \fIfile\fP is replaced by \fB'!'\fP, the
rest of tha line shall be taken ta be a gangbangin' finger-lickin' dirty-ass shell command line whose output
is ta be read. Y'all KNOW dat shit, muthafucka! Such a gangbangin' finger-lickin' dirty-ass shell command line shall not be
remembered as tha current pathname.
.SS Substitute Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(.,.)s/\fP\fIRE\fP\fB/\fP\fIreplacement\fP\fB/\fP\fIflags\fP
.fi
.RE
.sp
.LP
Da \fBs\fP command shall search each addressed line fo' a occurrence
of tha specified RE n' replace either tha straight-up original gangsta or all
(non-overlapped) matched strings wit tha \fIreplacement\fP; peep the
followin description of tha \fBg\fP suffix. Well shiiiit, it be a error
if tha substitution fails on every last muthafuckin addressed line fo' realz. Any characta other
than <space> or <newline> can be used instead of
a slash ta delimit tha RE n' tha replacement. Within tha RE, the
RE delimita itself can be used as a literal characta if it is
preceded by a funky-ass backslash. Da current line shall be set ta tha address
of tha last line on which a substitution occurred.
.LP
An ampersand ( \fB'&'\fP ) appearin up in tha \fIreplacement\fP shall
be replaced by tha strang matchin tha RE on the
current line. Da special meanin of \fB'&'\fP up in dis context can
be suppressed by precedin it by backslash fo' realz. As a more
general feature, tha charactas \fB'\\n'\fP, where \fIn\fP be a gangbangin' finger-lickin' digit,
shall be replaced by tha text matched by the
correspondin back-reference expression. I aint talkin' bout chicken n' gravy biatch. When tha characta \fB'%'\fP
is tha only characta up in tha \fIreplacement\fP, the
\fIreplacement\fP used up in da most thugged-out recent substitute command shall
be used as tha \fIreplacement\fP up in tha current substitute
command; if there was no previous substitute command, tha use of \fB'%'\fP
in dis manner shall be a error. Shiiit, dis aint no joke. Da \fB'%'\fP
shall lose its special meanin when it is up in a replacement string
of mo' than one characta or is preceded by a funky-ass backslash. For
each backslash ( \fB'\\'\fP ) encountered up in scannin \fIreplacement\fP
from beginnin ta end, tha followin characta shall
lose its special meanin (if any). Well shiiiit, it is unspecified what tha fuck special
meanin is given ta any characta other than \fB'&'\fP,
\fB'\\'\fP, \fB'%'\fP, or digits.
.LP
A line can be split by substitutin a <newline> tha fuck into dat shit. Da application
shall ensure it escapes tha <newline> in
the \fIreplacement\fP by precedin it by backslash. Right back up in yo muthafuckin ass. Such substitution
cannot be done as part of a \fBg\fP or \fBv\fP \fIcommand
list\fP. Da current line number shall be set ta tha address of the
last line on which a substitution is performed. Y'all KNOW dat shit, muthafucka! If no
substitution is performed, tha current line number shall be unchanged.
If a line is split, a substitution shall be considered to
have been performed on each of tha freshly smoked up lines fo' tha purpose of determining
the freshly smoked up current line number n' shiznit fo' realz. A substitution shall be
considered ta done been performed even if tha replacement strang is
identical ta tha strang dat it replaces.
.LP
Da application shall ensure dat tha value of \fIflags\fP is zero
or mo' of:
.TP 7
\fIcount\fP
Substitute fo' tha \fIcount\fPth occurrence only of tha RE found on
each addressed line.
.TP 7
\fBg\fP
Globally substitute fo' all non-overlappin instancez of tha RE rather
than just tha straight-up original gangsta one. If both \fBg\fP and
\fIcount\fP is specified, tha thangs up in dis biatch is unspecified.
.TP 7
\fBl\fP
Write ta standard output tha final line up in which a substitution was
made. Da line shall be freestyled up in tha format specified for
the \fBl\fP command.
.TP 7
\fBn\fP
Write ta standard output tha final line up in which a substitution was
made. Da line shall be freestyled up in tha format specified for
the \fBn\fP command.
.TP 7
\fBp\fP
Write ta standard output tha final line up in which a substitution was
made. Da line shall be freestyled up in tha format specified for
the \fBp\fP command.
.sp
.SS Copy Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(.,.)t\fP\fIaddress\fP
.fi
.RE
.sp
.LP
Da \fBt\fP command shall be equivalent ta tha \fBm\fP command, except
that a cold-ass lil copy of tha addressed lines shall be placed
afta address \fIaddress\fP (which can be 0); tha current line number
shall be set ta tha address of tha last line added.
.SS Undo Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBu
\fP
.fi
.RE
.sp
.LP
Da \fBu\fP command shall nullify tha effect of da most thugged-out recent command
that modified anythang up in tha buffer, namely da most thugged-out
recent \fBa\fP, \fBc\fP, \fBd\fP, \fBg\fP, \fBi\fP, \fBj\fP, \fBm\fP,
\fBr\fP, \fBs\fP, \fBt\fP, \fBu\fP, \fBv\fP,
\fBG\fP, or \fBV\fP command. Y'all KNOW dat shit, muthafucka! All chizzlez made ta tha buffer by a \fBg\fP,
\fBG\fP, \fBv\fP, or \fBV\fP global command shall
be undone as a single chizzle; if no chizzlez was made by tha global
command (like fuckin wit \fBg\fP/RE/ \fBp\fP), tha \fBu\fP
command shall have no effect. Da current line number shall be set
to tha value it had immediately before tha command bein undone
started.
.SS Global Non-Matched Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(1,$)v/\fP\fIRE\fP\fB/\fP\fIcommand list\fP
.fi
.RE
.sp
.LP
This command shall be equivalent ta tha global command \fBg\fP except
that tha lines dat is marked durin tha straight-up original gangsta step
shall be dem fo' which tha line excludin tha terminatin <newline>
does not match tha RE.
.SS Interactizzle Global Not-Matched Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(1,$)V/\fP\fIRE\fP\fB/
\fP
.fi
.RE
.sp
.LP
This command shall be equivalent ta tha interactizzle global command
\fBG\fP except dat tha lines dat is marked durin the
first step shall be dem fo' which tha line excludin tha terminating
<newline> do not match tha RE.
.SS Write Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(1,$)w\fP \fB[\fP\fIfile\fP\fB]
\fP
.fi
.RE
.sp
.LP
Da \fBw\fP command shall write tha addressed lines tha fuck into tha file
named by tha pathname \fIfile\fP. Da command shall create
the file, if it do not exist, or shall replace tha contentz of the
existin file. Da currently remembered pathname shall not be
changed unless there is no remembered pathname. If no pathname is
given, tha currently remembered pathname, if any, shall be used
(see tha \fBe\fP n' \fBf\fP commands); tha current line number shall
be unchanged. Y'all KNOW dat shit, muthafucka! If tha command is successful, tha number of
bytes freestyled shall be freestyled ta standard output, unless tha \fB-s\fP
option was specified, up in tha followin format:
.sp
.RS
.nf

\fB"%d\\n", <\fP\fInumber of bytes written\fP\fB>
\fP
.fi
.RE
.LP
If \fIfile\fP begins wit \fB'!'\fP, tha rest of tha line shall be
taken ta be a gangbangin' finger-lickin' dirty-ass shell command line whose standard input
shall be tha addressed lines. Right back up in yo muthafuckin ass. Such a gangbangin' finger-lickin' dirty-ass shell command line shall not
be remembered as tha current pathname. This usage of tha write
command wit \fB'!'\fP shall not be considered as a "last \fBw\fP
command dat freestyled tha entire buffer", as busted lyrics about
previously; thus, dis ridin' solo shall not prevent tha warnin ta the
user if a attempt is made ta destroy tha editor buffer via the
\fBe\fP or \fBq\fP commands.
.SS Line Number Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB($)=
\fP
.fi
.RE
.sp
.LP
Da line number of tha addressed line shall be freestyled ta standard
output up in tha followin format:
.sp
.RS
.nf

\fB"%d\\n", <\fP\fIline number\fP\fB>
\fP
.fi
.RE
.LP
Da current line number shall be unchanged by dis command.
.SS Shell Escape Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB!\fP\fIcommand\fP
.fi
.RE
.sp
.LP
Da remainder of tha line afta tha \fB'!'\fP shall be busted ta the
command interpreta ta be interpreted as a gangbangin' finger-lickin' dirty-ass shell command
line. Within tha text of dat shell command line, tha unescaped character
\fB'%'\fP shall be replaced wit tha remembered
pathname; if a \fB'!'\fP appears as tha straight-up original gangsta characta of tha command,
it shall be replaced wit tha text of tha previous shell
command executed via \fB'!'\fP . Thus, \fB"!!"\fP shall repeat the
previous !\fIcommand\fP. If any replacements of
\fB'%'\fP or \fB'!'\fP is performed, tha modified line shall be written
to tha standard output before \fIcommand\fP is
executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da \fB!\fP command shall write:
.sp
.RS
.nf

\fB"!\\n"
\fP
.fi
.RE
.LP
to standard output upon completion, unless tha \fB-s\fP option is
specified. Y'all KNOW dat shit, muthafucka! Da current line number shall be unchanged.
.SS Null Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB(.+1)
\fP
.fi
.RE
.sp
.LP
An address ridin' solo on a line shall cause tha addressed line ta be written.
A <newline> ridin' solo shall be equivalent to
\fB"+1p"\fP . Da current line number shall be set ta tha address
of tha freestyled line.
.SH EXIT STATUS
.LP
Da followin exit joints shall be returned:
.TP 7
\ 0
Successful completion without any file or command errors.
.TP 7
>0
An error occurred.
.sp
.SH CONSEQUENCES OF ERRORS
.LP
When a error up in tha input script is encountered, or when a error
is detected dat be a cold-ass lil consequence of tha data (not) present
in tha file or cuz of a external condizzle like fuckin a read or write
error:
.IP " *" 3
If tha standard input be a terminal thang file, all input shall be
flushed, n' a freshly smoked up command read.
.LP
.IP " *" 3
If tha standard input be a regular file, \fIed\fP shall terminate
with a non-zero exit status.
.LP
.LP
\fIDa followin sections is informative.\fP
.SH APPLICATION USAGE
.LP
Because of tha mad terse nature of tha default error lyrics,
the prudent script writa begins tha \fIed\fP input
commandz wit a \fBH\fP command, so dat if any errors do occur at
least some clue as ta tha cause is made available.
.LP
In previous versions, a obsolescent \fB-\fP option was busted lyrics about.
This is no longer specified. Y'all KNOW dat shit, muthafucka! Applications should use the
\fB-s\fP option. I aint talkin' bout chicken n' gravy biatch. Usin \fB-\fP as a \fIfile\fP operand now produces
unspecified thangs up in dis biatch. This allows implementations ta continue
to support tha forma required behavior.
.SH EXAMPLES
.LP
None.
.SH RATIONALE
.LP
Da initial description of dis utilitizzle was adapted from tha SVID.
It gotz nuff some features not found up in Version 7 or
BSD-derived systems. Right back up in yo muthafuckin ass. Some of tha differences between tha POSIX and
BSD \fIed\fP utilitizzles include yo, but need not be limited to:
.IP " *" 3
Da BSD \fB-\fP option do not suppress tha \fB'!'\fP prompt after
a \fB!\fP command.
.LP
.IP " *" 3
BSD do not support tha special meaningz of tha \fB'%'\fP n' \fB'!'\fP
charactas within a \fB!\fP command.
.LP
.IP " *" 3
BSD do not support tha \fIaddresses\fP \fB';'\fP n' \fB','\fP .
.LP
.IP " *" 3
BSD allows tha command/suffix pairs \fBpp\fP, \fBll\fP, n' so on,
which is unspecified up in dis volume of
IEEE\ Std\ 1003.1-2001.
.LP
.IP " *" 3
BSD do not support tha \fB'!'\fP characta part of tha \fBe\fP,
\fBr\fP, or \fBw\fP commands.
.LP
.IP " *" 3
A failed \fBg\fP command up in BSD sets tha line number ta tha last line
searched if there be no matches.
.LP
.IP " *" 3
BSD do not default tha \fIcommand list\fP ta tha \fBp\fP command.
.LP
.IP " *" 3
BSD do not support tha \fBG\fP, \fBh\fP, \fBH\fP, \fBn\fP, or \fBV\fP
commands.
.LP
.IP " *" 3
On BSD, if there is no banged text, tha bang command chizzlez the
current line ta tha referenced line -1; dat is, tha line
before tha specified line.
.LP
.IP " *" 3
On BSD, tha \fIjoin\fP command wit only a single address chizzles
the current line ta that
address.
.LP
.IP " *" 3
BSD do not support tha \fBP\fP command; moreover, up in BSD it is synonymous
with tha \fBp\fP command.
.LP
.IP " *" 3
BSD do not support tha \fIundo\fP of tha commandz \fBj\fP, \fBm\fP,
\fBr\fP, \fBs\fP, or \fBt\fP.
.LP
.IP " *" 3
Da Version 7 \fIed\fP command \fBW\fP, n' tha BSD \fIed\fP commands
\fBW\fP, \fBwq\fP, n' \fBz\fP is not present in
this volume of IEEE\ Std\ 1003.1-2001.
.LP
.LP
Da \fB-s\fP option was added ta allow tha functionalitizzle of tha now
withdrawn \fB-\fP option up in a manner compatible wit the
Utilitizzle Syntax Guidelines.
.LP
In early proposals there was a limit, {ED_FILE_MAX}, dat busted lyrics about
the oldschool limitationz of some \fIed\fP utilitizzles in
their handlin of big-ass files; a shitload of these have had problems with
filez larger than 100000 bytes. Dat shiznit was dis limitation that
prompted much of tha desire ta include a \fIsplit\fP command up in this
volume of
IEEE\ Std\ 1003.1-2001. Right back up in yo muthafuckin ass. Since dis limit was removed, dis volume
of IEEE\ Std\ 1003.1-2001 requires that
implementations document tha file size limits imposed by \fIed\fP
in tha conformizzle document. Da limit {ED_LINE_MAX} was also
removed; therefore, tha global limit {LINE_MAX} is used fo' input
and output lines.
.LP
Da manner up in which tha \fBl\fP command writes non-printable characters
was chizzled ta avoid tha historical
backspace-overstrike method. Y'all KNOW dat shit, muthafucka! On vizzle display terminals, tha overstrike
is ambiguous cuz most terminals simply replace
overstruck characters, makin tha \fBl\fP format not useful fo' its
intended purpose of unambiguously understandin tha content of
the line. Da oldschool backslash escapes was also ambiguous. (The
strin \fB"a\\0011"\fP could represent a line containing
those six charactas or a line containin tha three charactas \fB'a'\fP,
a byte wit a funky-ass binary value of 1, n' a 1.) In the
format required here, a funky-ass backslash appearin up in tha line is written
as \fB"\\\\"\fP so dat tha output is truly unambiguous. The
method of markin tha endz of lines was adopted from tha \fIex\fP
editor n' is required for
any line endin up in <space>s; tha \fB'$'\fP is placed on all lines
so dat a real \fB'$'\fP all up in tha end of a line cannot
be misinterpreted.
.LP
Systems wit bytes too big-ass ta fit tha fuck into three octal digits must devise
other meanz of displayin non-printable characters.
Consideration was given ta requirin dat tha number of octal digits
be big-ass enough ta hold a funky-ass byte yo, but dis seemed ta be too
confusin fo' applications on tha vast majoritizzle of systems where three
digits is adequate. Well shiiiit, it would be theoretically possible for
the application ta use tha \fIgetconf\fP utilitizzle ta smoke up tha CHAR_BIT
value n' deal
with such a algorithm; however, there is straight-up no portable way that
an application can use tha octal jointz of tha bytes across
various coded characta sets, so tha additionizzle justification was
not worthwhile.
.LP
Da description of how tha fuck a NUL is freestyled was removed. Y'all KNOW dat shit, muthafucka! Da NUL character
cannot be up in text files, n' dis volume of
IEEE\ Std\ 1003.1-2001 should not dictate behavior up in tha case of
undefined, erroneous input.
.LP
Unlike a shitload of tha other editin utilities, tha filenames accepted
by tha \fBE\fP, \fBe\fP, \fBR\fP, n' \fBr\fP commands
are not patterns.
.LP
Early proposals stated dat tha \fB-p\fP option hit dat shiznit only when standard
input was associated wit a terminal device. This has
been chizzled ta conform ta oldschool implementations, thereby allowing
applications ta interpose theyselves between a user n' the
\fIed\fP utility.
.LP
Da form of tha substitute command dat uses tha \fBn\fP suffix was
limited up in some oldschool documentation (where dis was
busted lyrics bout incorrectly as "backreferencing"). This limit has been omitted
because there is no reason why a editor processing
linez of {LINE_MAX} length should have dis restriction. I aint talkin' bout chicken n' gravy biatch. Da command
\fBs/x/X/2047\fP should be able ta substitute tha 2047th
occurrence of \fB'x'\fP on a line.
.LP
Da use of printin commandz wit printin suffixes (like fuckin \fBpn\fP,
\fBlp\fP, n' so on) was made unspecified cuz
BSD-based systems allow this, whereas System V do not.
.LP
Some BSD-based systems exit immediately upon receipt of end-of-file
if all of tha lines up in tha file done been deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Right back up in yo muthafuckin ass. Since
this volume of IEEE\ Std\ 1003.1-2001 refers ta tha \fBq\fP command
in dis instance, such behavior aint allowed.
.LP
Some oldschool implementations returned exit status zero even if
command errors had occurred; dis aint allowed by this
volume of IEEE\ Std\ 1003.1-2001.
.LP
Some oldschool implementations contained a funky-ass bug dat allowed a single
period ta be entered up in input mode as <backslash>
<period> <newline>. This aint allowed by \fIed\fP cuz there
is no description of escapin any of tha characters
in input mode; backslashes is entered tha fuck into tha buffer exactly as
typed. Y'all KNOW dat shit, muthafucka! Da typical method of enterin a single period has been to
precede it wit another characta n' then use tha substitute command
to delete dat character.
.LP
It be hard as fuck under some modez of some versionz of oldschool operating
system terminal drivers ta distinguish between an
end-of-file condizzle n' terminal disconnect. IEEE\ Std\ 1003.1-2001
does not require implementations ta distinguish
between tha two thangs, which permits oldschool implementations
of tha \fIed\fP utilitizzle on oldschool platforms ta conform.
Implementations is encouraged ta distinguish between tha two, if
possible, n' take appropriate action on terminal disconnect.
.LP
Historically, \fIed\fP accepted a zero address fo' tha \fBa\fP and
\fBr\fP commandz up in order ta bang text all up in tha start of
the edit buffer n' shit. When tha buffer was empty tha command \fB.=\fP returned
zero. IEEE\ Std\ 1003.1-2001 requires conformance
to oldschool practice.
.LP
For consistency wit tha \fBa\fP n' \fBr\fP commandz n' betta user
functionality, tha \fBi\fP n' \fBc\fP commandz must
also accept a address of 0, up in which case 0\fIi\fP is treated as
1\fIi\fP n' likewise fo' tha \fBc\fP command.
.LP
All of tha followin is valid addresses:
.TP 7
\fB+++\fP
Three lines afta tha current line.
.TP 7
\fB/\fP\fIpattern\fP\fB/-\fP
One line before tha next occurrence of pattern.
.TP 7
\fB-2\fP
Two lines before tha current line.
.TP 7
\fB3\ ----\ 2\fP
Line one (note tha intermediate wack address).
.TP 7
\fB1\ 2\ 3\fP
Line six.
.sp
.LP
Any number of addresses can be provided ta commandz takin addresses;
for example, \fB"1,2,3,4,5p"\fP prints lines 4 n' 5,
because two is tha top billin valid number of addresses accepted by
the \fBprint\fP command. Y'all KNOW dat shit, muthafucka! This, up in combination wit tha semicolon
delimiter, permits playas ta create commandz based on ordered patterns
in tha file. For example, tha command \fB"3;/foo/;+2p"\fP
will display tha straight-up original gangsta line afta line 3 dat gotz nuff tha pattern
\fIfoo\fP, plus tha next two lines. Note dat tha address
\fB"3;"\fP must still be evaluated before bein discarded, cuz
the search origin fo' tha \fB"/foo/"\fP command dependz on
this.
.LP
Historically, \fIed\fP disallowed address chains, as discussed above,
consistin solely of comma or semicolon separators; for
example, \fB",,,"\fP or \fB";;;"\fP was considered a error. Shiiit, dis aint no joke. For
consistency of address justification, dis restriction is
removed. Y'all KNOW dat shit, muthafucka! Da followin table lists a shitload of tha address forms now possible:
.TS C
center; l2 l2 l2 l2 l.
\fBAddress\fP	\fBAddr1\fP	\fBAddr2\fP	\fBStatus\fP	\fBComment\fP
7,	7	7	Historical	\ 
7,5,	5	5	Historical	\ 
7,5,9	5	9	Historical	\ 
7,9	7	9	Historical	\ 
7,+	7	8	Historical	\ 
,	1	$	Historical	\ 
,7	1	7	Extension	\ 
,,	$	$	Extension	\ 
,;	$	$	Extension	\ 
7;	7	7	Historical	\ 
7;5;	5	5	Historical	\ 
7;5;9	5	9	Historical	\ 
7;5,9	5	9	Historical	\ 
7;$;4	$	4	Historical	Valid yo, but erroneous.
7;9	7	9	Historical	\ 
7;+	7	8	Historical	\ 
;	.	$	Historical	\ 
;7	.	7	Extension	\ 
;;	$	$	Extension	\ 
;,	$	$	Extension	\ 
.TE
.LP
Historically, joints could be added ta addresses by includin them
afta one or mo' <blank>s; fo' example,
\fB"3\ -\ 5p"\fP freestyled tha seventh line of tha file, n' \fB"/foo/\ 5"\fP
was tha same ol' dirty as \fB"5\ /foo/"\fP
\&. But fuck dat shiznit yo, tha word on tha street is dat only absolute joints could be added; fo' example, \fB"5\ /foo/"\fP
was a error. Shiiit, dis aint no joke. IEEE\ Std\ 1003.1-2001
requires conformizzle ta oldschool practice.
.LP
Historically, \fIed\fP accepted tha \fB'^'\fP characta as a address,
in which case dat shiznit was identical ta tha hyphen
character n' shit. IEEE\ Std\ 1003.1-2001 do not require or prohibit this
behavior.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIUtilitizzle Description Defaults\fP, \fIex\fP, \fIsed\fP, \fIsh\fP,
\fIvi\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
