.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "AWK" 1P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" awk 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
awk \- pattern scannin n' processin language
.SH SYNOPSIS
.LP
\fBawk\fP \fB[\fP\fB-F\fP \fIERE\fP\fB][\fP\fB-v\fP \fIassignment\fP\fB]\fP
\fB\&...\fP \fIprogram\fP
\fB[\fP\fIargument\fP \fB...\fP\fB]\fP\fB
.br
.sp
awk\fP \fB[\fP\fB-F\fP \fIERE\fP\fB]\fP \fB-f\fP \fIprogfile\fP \fB...\fP
\fB[\fP\fB-v\fP
\fIassignment\fP\fB]\fP \fB...\fP\fB[\fP\fIargument\fP \fB...\fP\fB]\fP\fB
.br
\fP
.SH DESCRIPTION
.LP
Da \fIawk\fP utilitizzle shall execute programs freestyled up in tha \fIawk\fP
programmin language, which is specialized fo' textual
data manipulation. I aint talkin' bout chicken n' gravy biatch fo' realz. An \fIawk\fP program be a sequence of patterns
and correspondin actions. When input is read dat matches a
pattern, tha action associated wit dat pattern is carried out.
.LP
Input shall be interpreted as a sequence of records. By default, a
record be a line, less its terminatin <newline> yo, but
this can be chizzled by rockin tha \fBRS\fP built-in variable. Each
record of input shall be matched up in turn against each pattern in
the program. For each pattern matched, tha associated action shall
be executed.
.LP
Da \fIawk\fP utilitizzle shall interpret each input record as a sequence
of fieldz where, by default, a gangbangin' field be a strang of non-
<blank>s. This default white-space field delimita can be chizzled
by rockin tha \fBFS\fP built-in variable or \fB-F\fP
\fIERE\fP. Da \fIawk\fP utilitizzle shall denote tha straight-up original gangsta field up in a
record $1, tha second $2, n' so on. I aint talkin' bout chicken n' gravy biatch. Da symbol $0 shall refer
to tha entire record; settin any other field causes tha re-evaluation
of $0 fo' realz. Assignin ta $0 shall reset tha jointz of all other
fieldz n' tha \fBNF\fP built-in variable.
.SH OPTIONS
.LP
Da \fIawk\fP utilitizzle shall conform ta tha Base Definitions volume
of IEEE\ Std\ 1003.1-2001, Section 12.2, Utilitizzle Syntax Guidelines.
.LP
Da followin options shall be supported:
.TP 7
\fB-F\ \fP \fIERE\fP
Define tha input field separator ta be tha extended regular expression
\fIERE\fP, before any input is read; peep Regular Expressions .
.TP 7
\fB-f\ \fP \fIprogfile\fP
Specify tha pathname of tha file \fIprogfile\fP containin a \fIawk\fP
program. If multiple instancez of dis option are
specified, tha concatenation of tha filez specified as \fIprogfile\fP
in tha order specified shall be tha \fIawk\fP program. The
\fIawk\fP program can alternatively be specified up in tha command line
as a single argument.
.TP 7
\fB-v\ \fP \fIassignment\fP
Da application shall ensure dat tha \fIassignment\fP argument is
in tha same form as a \fIassignment\fP operand. Y'all KNOW dat shit, muthafucka! Da specified
variable assignment shall occur prior ta executin tha \fIawk\fP program,
includin tha actions associated wit \fBBEGIN\fP
patterns (if any). Multiple occurrencez of dis option can be specified.
.sp
.SH OPERANDS
.LP
Da followin operandz shall be supported:
.TP 7
\fIprogram\fP
If no \fB-f\fP option is specified, tha straight-up original gangsta operand ta \fIawk\fP
shall be tha text of tha \fIawk\fP program. The
application shall supply tha \fIprogram\fP operand as a single argument
to \fIawk\fP. If tha text do not end up in a
<newline>, \fIawk\fP shall interpret tha text as if it done did.
.TP 7
\fIargument\fP
Either of tha followin two typez of \fIargument\fP can be intermixed:
.TP 7
\fIfile\fP
.RS
A pathname of a gangbangin' file dat gotz nuff tha input ta be read, which is
matched against tha set of patterns up in tha program. If no
\fIfile\fP operandz is specified, or if a \fIfile\fP operand is \fB'-'\fP,
the standard input shall be used.
.RE
.TP 7
\fIassignment\fP
.RS
An operand dat begins wit a underscore or alphabetic character
from tha portable characta set (see tha table up in tha Base
Definitions volume of IEEE\ Std\ 1003.1-2001, Section 6.1, Portable
Characta Set), followed by a sequence of underscores, digits, and
alphabetics from tha portable characta set, followed by the
\fB'='\fP character, shall specify a variable assignment rather than
a pathname. Da charactas before tha \fB'='\fP
represent tha name of a \fIawk\fP variable; if dat name be a \fIawk\fP
reserved word (see Grammar ) tha behavior is undefined. Y'all KNOW dat shit, muthafucka! Da characters
followin tha equal sign shall be interpreted as if they
appeared up in tha \fIawk\fP program preceded n' followed by a thugged-out double-quote
( \fB' )'\fP character, as a \fBSTRING\fP token (see
Grammar ), except dat if tha last characta be a unescaped backslash,
it shall be interpreted as a
literal backslash rather than as tha straight-up original gangsta characta of tha sequence
\fB"\\""\fP . Da variable shall be assigned tha value of
that \fBSTRING\fP token and, if appropriate, shall be considered a
\fInumeric string\fP (see Expressions up in awk ), tha variable shall
also be assigned its numeric value. Each such variable assignment
shall occur just prior ta tha processin of tha followin \fIfile\fP,
if any. Thus, a assignment before tha straight-up original gangsta \fIfile\fP
argument shall be executed afta tha \fBBEGIN\fP actions (if any),
while a assignment afta tha last \fIfile\fP argument shall
occur before tha \fBEND\fP actions (if any). If there be no \fIfile\fP
arguments, assignments shall be executed before
processin tha standard input.
.RE
.sp
.sp
.SH STDIN
.LP
Da standard input shall be used only if no \fIfile\fP operandz are
specified, or if a \fIfile\fP operand is \fB'-'\fP ;
see tha INPUT FILES section. I aint talkin' bout chicken n' gravy biatch. If tha \fIawk\fP program gotz nuff no
actions n' no patterns yo, but is otherwise a valid \fIawk\fP
program, standard input n' any \fIfile\fP operandz shall not be read
and \fIawk\fP shall exit wit a return statuz of zero.
.SH INPUT FILES
.LP
Input filez ta tha \fIawk\fP program from any of tha followin sources
shall be text files:
.IP " *" 3
Any \fIfile\fP operandz or they equivalents,  bigged up  by modifying
the \fIawk\fP variablez \fBARGV\fP n' \fBARGC\fP
.LP
.IP " *" 3
Standard input up in tha absence of any \fIfile\fP operands
.LP
.IP " *" 3
Arguments ta tha \fBgetline\fP function
.LP
.LP
Whether tha variable \fBRS\fP is set ta a value other than a <newline>
or not, fo' these files, implementations shall
support recordz terminated wit tha specified separator up ta {LINE_MAX}
bytes n' may support longer records.
.LP
If \fB-f\fP \fIprogfile\fP is specified, tha application shall ensure
that tha filez named by each of tha \fIprogfile\fP
option-arguments is text filez n' they concatenation, up in tha same
order as they step tha fuck up in tha arguments, be a \fIawk\fP
program.
.SH ENVIRONMENT VARIABLES
.LP
Da followin environment variablez shall affect tha execution of
\fIawk\fP:
.TP 7
\fILANG\fP
Provide a thugged-out default value fo' tha internationalization variablez that
are unset or null. (See tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, Section 8.2, Internationalization Variables
for
the precedence of internationalization variablez used ta determine
the jointz of locale categories.)
.TP 7
\fILC_ALL\fP
If set ta a non-empty strang value, override tha jointz of all the
other internationalization variables.
.TP 7
\fILC_COLLATE\fP
Determine tha locale fo' tha behavior of ranges, equivalence classes,
and multi-characta collatin elements within regular
expressions n' up in comparisonz of strang joints.
.TP 7
\fILC_CTYPE\fP
Determine tha locale fo' tha interpretation of sequencez of bytes
of text data as charactas (for example, single-byte as
opposed ta multi-byte charactas up in arguments n' input files), the
behavior of characta classes within regular expressions, the
identification of charactas as letters, n' tha mappin of uppercase
and lowercase charactas fo' tha \fBtoupper\fP and
\fBtolower\fP functions.
.TP 7
\fILC_MESSAGES\fP
Determine tha locale dat should be used ta affect tha format and
contentz of diagnostic lyrics freestyled ta standard
error.
.TP 7
\fILC_NUMERIC\fP
Determine tha radix characta used when interpretin numeric input,
performin conversions between numeric n' strang joints, and
formattin numeric output. Regardless of locale, tha period character
(the decimal-point characta of tha POSIX locale) is the
decimal-point characta recognized up in processin \fIawk\fP programs
(includin assignments up in command line arguments).
.TP 7
\fINLSPATH\fP
Determine tha location of message catalogs fo' tha processin of \fILC_MESSAGES
\&.\fP 
.TP 7
\fIPATH\fP
Determine tha search path when lookin fo' commandz executed by \fIsystem\fP(\fIexpr\fP),
or input n' output pipes; peep the
Base Definitions volume of IEEE\ Std\ 1003.1-2001, Chapta 8, Environment
Variables.
.sp
.LP
In addition, all environment variablez shall be visible via tha \fIawk\fP
variable \fBENVIRON\fP.
.SH ASYNCHRONOUS EVENTS
.LP
Default.
.SH STDOUT
.LP
Da nature of tha output filez dependz on tha \fIawk\fP program.
.SH STDERR
.LP
Da standard error shall be used only fo' diagnostic lyrics.
.SH OUTPUT FILES
.LP
Da nature of tha output filez dependz on tha \fIawk\fP program.
.SH EXTENDED DESCRIPTION
.SS Overall Program Structure
.LP
An \fIawk\fP program is composed of pairz of tha form:
.sp
.RS
.nf

\fIpattern\fP \fB{\fP \fIaction\fP \fB}
\fP
.fi
.RE
.LP
Either tha pattern or tha action (includin tha enclosin brace characters)
can be omitted.
.LP
A missin pattern shall match any record of input, n' a missin action
shall be equivalent to:
.sp
.RS
.nf

\fB{ print }
\fP
.fi
.RE
.LP
Execution of tha \fIawk\fP program shall start by first executing
the actions associated wit all \fBBEGIN\fP patterns up in the
order they occur up in tha program. Then each \fIfile\fP operand (or
standard input if no filez was specified) shall be processed in
turn by readin data from tha file until a record separator is seen
( <newline> by default). Before tha straight-up original gangsta reference ta a
field up in tha record is evaluated, tha record shall be split tha fuck into fields,
accordin ta tha rulez up in Regular Expressions, rockin tha value of
\fBFS\fP dat was current all up in tha time tha record was read. Y'all KNOW dat shit, muthafucka! Each
pattern up in tha program then shall be evaluated up in tha order of occurrence,
and tha action associated wit each pattern dat matches
the current record executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da action fo' a matchin pattern shall
be executed before evaluatin subsequent patterns. Finally,
the actions associated wit all \fBEND\fP patterns shall be executed
in tha order they occur up in tha program.
.SS Expressions up in awk
.LP
Expressions describe computations used up in \fIpatterns\fP n' \fIactions\fP.
In tha followin table, valid expression
operations is given up in crews from highest precedence first ta lowest
precedence last, wit equal-precedence operators grouped
between horizontal lines. In expression evaluation, where tha grammar
is formally ambiguous, higher precedence operators shall be
evaluated before lower precedence operators. In dis table \fIexpr\fP,
\fIexpr1\fP, \fIexpr2\fP, n' \fIexpr3\fP represent any
expression, while lvalue represents any entitizzle dat can be assigned
to (that is, on tha left side of a assignment operator). The
precise syntax of expressions is given up in Grammar .
.sp
.ce 1
\fBTable: Expressions up in Decreasin Precedence up in \fIawk\fP\fP
.TS C
center; l1 l1 l1 l.
\fBSyntax\fP	\fBName\fP	\fBType of Result\fP	\fBAssociativity\fP
( \fIexpr\fP )	Grouping	Type of \fIexpr\fP	N/A
$\fIexpr\fP	Field reference	String	N/A
++ lvalue	Pre-increment	Numeric	N/A
-- lvalue	Pre-decrement	Numeric	N/A
lvalue ++	Post-increment	Numeric	N/A
lvalue --	Post-decrement	Numeric	N/A
\fIexpr\fP ^ \fIexpr\fP	Exponentiation	Numeric	Right
! \fIexpr\fP	Logical not	Numeric	N/A
+ \fIexpr\fP	Unary plus	Numeric	N/A
- \fIexpr\fP	Unary minus	Numeric	N/A
\fIexpr\fP * \fIexpr\fP	Multiplication	Numeric	Left
\fIexpr\fP / \fIexpr\fP	Division	Numeric	Left
\fIexpr\fP % \fIexpr\fP	Modulus	Numeric	Left
\fIexpr\fP + \fIexpr\fP	Addition	Numeric	Left
\fIexpr\fP - \fIexpr\fP	Subtraction	Numeric	Left
\fIexpr\fP \fIexpr\fP	Strin concatenation	String	Left
\fIexpr\fP < \fIexpr\fP	Less than	Numeric	None
\fIexpr\fP <= \fIexpr\fP	Less than or equal to	Numeric	None
\fIexpr\fP != \fIexpr\fP	Not equal to	Numeric	None
\fIexpr\fP == \fIexpr\fP	Equal to	Numeric	None
\fIexpr\fP > \fIexpr\fP	Greata than	Numeric	None
\fIexpr\fP >= \fIexpr\fP	Greata than or equal to	Numeric	None
\fIexpr\fP ~ \fIexpr\fP	ERE match	Numeric	None
\fIexpr\fP !~ \fIexpr\fP	ERE non-match	Numeric	None
\fIexpr\fP up in array	Array membership	Numeric	Left
( \fIindex\fP ) up in \fIarray\fP	Multi-dimension array	Numeric	Left
\ 	membership	\ 	\ 
\fIexpr\fP && \fIexpr\fP	Logical AND	Numeric	Left
\fIexpr\fP || \fIexpr\fP	Logical OR	Numeric	Left
\fIexpr1\fP ? \fIexpr2\fP : \fIexpr3\fP	Conditionizzle expression	Type of selected	Right
\ 	\ 	\fIexpr2\fP or \fIexpr3\fP	\ 
lvalue ^= \fIexpr\fP	Exponentiation assignment	Numeric	Right
lvalue %= \fIexpr\fP	Modulus assignment	Numeric	Right
lvalue *= \fIexpr\fP	Multiplication assignment	Numeric	Right
lvalue /= \fIexpr\fP	Division assignment	Numeric	Right
lvalue += \fIexpr\fP	Addizzle assignment	Numeric	Right
lvalue -= \fIexpr\fP	Subtraction assignment	Numeric	Right
lvalue = \fIexpr\fP	Assignment	Type of \fIexpr\fP	Right
.TE
.LP
Each expression shall have either a strang value, a numeric value,
or both. Except as stated fo' specific contexts, tha value of
an expression shall be implicitly converted ta tha type needed for
the context up in which it is used. Y'all KNOW dat shit, muthafucka! A strang value shall be
converted ta a numeric value by tha equivalent of tha followin calls
to functions defined by tha ISO\ C standard:
.sp
.RS
.nf

\fBsetlocale(LC_NUMERIC, "");
\fP\fInumeric_value\fP \fB= atof(\fP\fIstring_value\fP\fB);
\fP
.fi
.RE
.LP
A numeric value dat is exactly equal ta tha value of a integer (see
\fIConcepts Derived
from tha ISO C Standard\fP ) shall be converted ta a strang by the
equivalent of a cold-ass lil call ta tha \fBsprintf\fP function (see Strin Functions
) wit tha strang \fB"%d"\fP as tha \fIfmt\fP argument n' tha numeric
value being
converted as tha straight-up original gangsta n' only \fIexpr\fP argument fo' realz. Any other numeric
value shall be converted ta a strang by tha equivalent of a
call ta tha \fBsprintf\fP function wit tha value of tha variable
\fBCONVFMT\fP as tha \fIfmt\fP argument n' tha numeric value
bein converted as tha straight-up original gangsta n' only \fIexpr\fP argument. Da result
of tha conversion is unspecified if tha value of
\fBCONVFMT\fP aint a gangbangin' floating-point format justification. I aint talkin' bout chicken n' gravy biatch. This volume
of IEEE\ Std\ 1003.1-2001 specifies no explicit
conversions between numbers n' strings fo' realz. An application can force
an expression ta be treated as a number by addin zero ta it, or
can force it ta be treated as a strang by concatenatin tha null string
( \fB""\fP ) ta dat shit.
.LP
A strang value shall be considered a \fInumeric string\fP if it comes
from one of tha following:
.IP " 1." 4
Field variables
.LP
.IP " 2." 4
Input from tha \fIgetline\fP() function
.LP
.IP " 3." 4
\fBFILENAME\fP
.LP
.IP " 4." 4
\fBARGV\fP array elements
.LP
.IP " 5." 4
\fBENVIRON\fP array elements
.LP
.IP " 6." 4
Array elements pimped by tha \fIsplit\fP() function
.LP
.IP " 7." 4
A command line variable assignment
.LP
.IP " 8." 4
Variable assignment from another numeric strang variable
.LP
.LP
and afta all tha followin conversions done been applied, tha resulting
strin would lexically be recognized as a \fBNUMBER\fP
token as busted lyrics bout by tha lexical conventions up in Grammar :
.IP " *" 3
All leadin n' trailin <blank>s is discarded.
.LP
.IP " *" 3
If tha straight-up original gangsta non- <blank> is \fB'+'\fP or \fB'-'\fP, it is discarded.
.LP
.IP " *" 3
Changin each occurrence of tha decimal point characta from tha current
locale ta a period.
.LP
.LP
If a \fB'-'\fP characta is ignored up in tha precedin description,
the numeric value of tha \fInumeric string\fP shall be the
negation of tha numeric value of tha recognized \fBNUMBER\fP token.
Otherwise, tha numeric value of tha \fInumeric string\fP
shall be tha numeric value of tha recognized \fBNUMBER\fP token. I aint talkin' bout chicken n' gravy biatch. Whether
or not a strang be a \fInumeric string\fP shall be
relevant only up in contexts where dat term is used up in dis section.
.LP
When a expression is used up in a Boolean context, if it has a numeric
value, a value of zero shall be treated as false n' any
other value shall be treated as true. Otherwise, a strang value of
the null strang shall be treated as false n' any other value
shall be treated as true fo' realz. A Boolean context shall be one of tha following:
.IP " *" 3
Da first subexpression of a cold-ass lil conditionizzle expression
.LP
.IP " *" 3
An expression operated on by logical NOT, logical AND, or logical
OR
.LP
.IP " *" 3
Da second expression of a \fBfor\fP statement
.LP
.IP " *" 3
Da expression of a \fBif\fP statement
.LP
.IP " *" 3
Da expression of tha \fBwhile\fP clause up in either a \fBwhile\fP or
\fBdo\fP... \fBwhile\fP statement
.LP
.IP " *" 3
An expression used as a pattern (as up in Overall Program Structure)
.LP
.LP
All arithmetic shall follow tha semantics of floating-point arithmetic
as specified by tha ISO\ C standard (see \fIConcepts Derived from
the ISO C Standard\fP ).
.LP
Da value of tha expression:
.sp
.RS
.nf

\fIexpr1\fP \fB^\fP \fIexpr2\fP
.fi
.RE
.LP
shall be equivalent ta tha value returned by tha ISO\ C standard function
call:
.sp
.RS
.nf

\fBpow(\fP\fIexpr1\fP\fB,\fP \fIexpr2\fP\fB)
\fP
.fi
.RE
.LP
Da expression:
.sp
.RS
.nf

\fBlvalue ^=\fP \fIexpr\fP
.fi
.RE
.LP
shall be equivalent ta tha ISO\ C standard expression:
.sp
.RS
.nf

\fBlvalue = pow(lvalue,\fP \fIexpr\fP\fB)
\fP
.fi
.RE
.LP
except dat lvalue shall be evaluated only once. Da value of the
expression:
.sp
.RS
.nf

\fIexpr1\fP \fB%\fP \fIexpr2\fP
.fi
.RE
.LP
shall be equivalent ta tha value returned by tha ISO\ C standard function
call:
.sp
.RS
.nf

\fBfmod(\fP\fIexpr1\fP\fB,\fP \fIexpr2\fP\fB)
\fP
.fi
.RE
.LP
Da expression:
.sp
.RS
.nf

\fBlvalue %=\fP \fIexpr\fP
.fi
.RE
.LP
shall be equivalent ta tha ISO\ C standard expression:
.sp
.RS
.nf

\fBlvalue = fmod(lvalue,\fP \fIexpr\fP\fB)
\fP
.fi
.RE
.LP
except dat lvalue shall be evaluated only once.
.LP
Variablez n' fieldz shall be set by tha assignment statement:
.sp
.RS
.nf

\fBlvalue =\fP \fIexpression\fP
.fi
.RE
.LP
and tha type of \fIexpression\fP shall determine tha resultin variable
type. Da assignment includes tha arithmetic
assignments ( \fB"+="\fP, \fB"-="\fP, \fB"*="\fP, \fB"/="\fP,
\fB"%="\fP, \fB"^="\fP, \fB"++"\fP,
\fB"--"\fP ) all of which shall produce a numeric result. Da left-hand
side of a assignment n' tha target of increment and
decrement operators can be one of a variable, a array wit index,
or a gangbangin' field selector.
.LP
Da \fIawk\fP language supplies arrays dat is used fo' storin numbers
or strings fo' realz. Arrays need not be declared. Y'all KNOW dat shit, muthafucka! They shall
initially be empty, n' they sizes shall chizzle dynamically. The
subscripts, or element identifiers, is strings, providin a type
of associatizzle array capabilitizzle fo' realz. An array name followed by a subscript
within square brackets can be used as a lvalue n' thus as
an expression, as busted lyrics bout up in tha grammar; peep Grammar . Unsubscripted
array names can be used in
only tha followin contexts:
.IP " *" 3
A parameta up in a gangbangin' function definizzle or function call
.LP
.IP " *" 3
Da \fBNAME\fP token followin any use of tha keyword \fBin\fP as
specified up in tha grammar (see Grammar ); if tha name used up in this
context aint a array name, tha behavior is undefined
.LP
.LP
A valid array \fIindex\fP shall consist of one or mo' comma-separated
expressions, similar ta tha way up in which
multi-dimensionizzle arrays is indexed up in some programmin languages.
Because \fIawk\fP arrays is straight-up one-dimensional, such a
comma-separated list shall be converted ta a single strang by concatenating
the strang jointz of tha separate expressions, each
separated from tha other by tha value of tha \fBSUBSEP\fP variable.
Thus, tha followin two index operations shall be
equivalent:
.sp
.RS
.nf

\fIvar\fP\fB[\fP\fIexpr1\fP\fB,\fP \fIexpr2\fP\fB, ...\fP \fIexprn\fP\fB]
.sp

\fP\fIvar\fP\fB[\fP\fIexpr1\fP \fBSUBSEP\fP \fIexpr2\fP \fBSUBSEP ... Right back up in yo muthafuckin ass. SUBSEP\fP \fIexprn\fP\fB]\fP
.fi
.RE
.LP
Da application shall ensure dat a multi-dimensioned \fIindex\fP
used wit tha \fBin\fP operator is parenthesized. Y'all KNOW dat shit, muthafucka! The
\fBin\fP operator, which tests fo' tha existence of a particular array
element, shall not cause dat element ta exist fo' realz. Any other
reference ta a nonexistent array element shall automatically create
it.
.LP
Comparisons (with tha \fB'<'\fP, \fB"<="\fP, \fB"!="\fP, \fB"=="\fP,
\fB'>'\fP, and
\fB">="\fP operators) shall be made numerically if both operandz are
numeric, if one is numeric n' tha other has a string
value dat be a numeric string, or if one is numeric n' tha other
has tha uninitialized value. Otherwise, operandz shall be
converted ta strings as required n' a strang comparison shall be
made rockin tha locale-specific collation sequence. Da value of
the comparison expression shall be 1 if tha relation is true, or 0
if tha relation is false.
.SS Variablez n' Special Variables
.LP
Variablez can be used up in a \fIawk\fP program by referencin em.
With tha exception of function parametas (see User-Defined Functions
), they is not explicitly declared. Y'all KNOW dat shit, muthafucka! Function parameta names shall
be local ta the
function; all other variable names shall be global. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da same name
shall not be used as both a gangbangin' function parameta name n' as the
name of a gangbangin' function or a special \fIawk\fP variable. Da same name
shall not be used both as a variable name wit global scope and
as tha name of a gangbangin' function. I aint talkin' bout chicken n' gravy biatch. Da same name shall not be used within
the same scope both as a scalar variable n' as a array.
Uninitialized variables, includin scalar variables, array elements,
and field variables, shall have a uninitialized value fo' realz. An
uninitialized value shall have both a numeric value of zero n' a
strin value of tha empty string. Evaluation of variablez wit an
uninitialized value, ta either strang or numeric, shall be determined
by tha context up in which they is used.
.LP
Field variablez shall be designated by a \fB'$'\fP followed by a number
or numerical expression. I aint talkin' bout chicken n' gravy biatch. Da effect of tha field
number \fIexpression\fP evaluatin ta anythang other than a non-negative
integer is unspecified; uninitialized variablez or string
values need not be converted ta numeric joints up in dis context. New
field variablez can be pimped by assignin a value ta em.
References ta nonexistent fieldz (that is, fieldz afta $\fBNF\fP),
shall evaluate ta tha uninitialized value. Right back up in yo muthafuckin ass. Such references
shall not create freshly smoked up fields. But fuck dat shiznit yo, tha word on tha street is dat assignin ta a nonexistent field
(for example, $(\fBNF\fP+2)=5) shall increase tha value of
\fBNF\fP; create any intervenin fieldz wit tha uninitialized value;
and cause tha value of $0 ta be recomputed, wit tha fields
bein separated by tha value of \fBOFS\fP. Each field variable shall
have a strang value or a uninitialized value when pimped.
Field variablez shall have tha uninitialized value when pimped from
$0 rockin \fBFS\fP n' tha variable do not contain any
characters. If appropriate, tha field variable shall be considered
a numeric strang (see Expressions in
awk ).
.LP
Implementations shall support tha followin other special variables
that is set by \fIawk\fP:
.TP 7
\fBARGC\fP
Da number of elements up in tha \fBARGV\fP array.
.TP 7
\fBARGV\fP
An array of command line arguments, excludin options n' tha \fIprogram\fP
argument, numbered from zero ta \fBARGC\fP-1. 
.LP
Da arguments up in \fBARGV\fP can be modified or added to; \fBARGC\fP
can be altered. Y'all KNOW dat shit, muthafucka! As each input file ends, \fIawk\fP shall
treat tha next non-null element of \fBARGV\fP, up ta tha current value
of \fBARGC\fP-1, inclusive, as tha name of tha next input
file. Thus, settin a element of \fBARGV\fP ta null means dat it
shall not be treated as a input file. Da name \fB'-'\fP
indicates tha standard input. If a argument matches tha format of
an \fIassignment\fP operand, dis argument shall be treated as
an \fIassignment\fP rather than a \fIfile\fP argument.
.TP 7
\fBCONVFMT\fP
Da \fBprintf\fP format fo' convertin numbers ta strings (except
for output statements, where \fBOFMT\fP is used);
\fB"%.6g"\fP by default.
.TP 7
\fBENVIRON\fP
An array representin tha value of tha environment, as busted lyrics bout in
the \fIexec\fP functions defined up in tha System Interfaces
volume of IEEE\ Std\ 1003.1-2001. Da indicez of tha array shall be
strings consistin of tha namez of tha environment
variables, n' tha value of each array element shall be a strang consisting
of tha value of dat variable. If appropriate, the
environment variable shall be considered a \fInumeric string\fP (see
Expressions up in awk ); the
array element shall also have its numeric value. 
.LP
In all cases where tha behavior of \fIawk\fP be affected by environment
variablez (includin tha environment of any commands
that \fIawk\fP executes via tha \fBsystem\fP function or via pipeline
redirections wit tha \fBprint\fP statement, the
\fBprintf\fP statement, or tha \fBgetline\fP function), tha environment
used shall be tha environment all up in tha time \fIawk\fP
fuckin started executing; it is implementation-defined whether any modification
of \fBENVIRON\fP affects dis environment.
.TP 7
\fBFILENAME\fP
A pathname of tha current input file. Inside a \fBBEGIN\fP action
the value is undefined. Y'all KNOW dat shit, muthafucka! Inside a \fBEND\fP action the
value shall be tha name of tha last input file processed.
.TP 7
\fBFNR\fP
Da ordinal number of tha current record up in tha current file. Inside
a \fBBEGIN\fP action tha value shall be zero. Inside an
\fBEND\fP action tha value shall be tha number of tha last record
processed up in tha last file processed.
.TP 7
\fBFS\fP
Input field separator regular expression; a <space> by default.
.TP 7
\fBNF\fP
Da number of fieldz up in tha current record. Y'all KNOW dat shit, muthafucka! Inside a \fBBEGIN\fP action,
the use of \fBNF\fP is undefined unless a
\fBgetline\fP function without a \fIvar\fP argument is executed previously.
Inside a \fBEND\fP action, \fBNF\fP shall retain
the value it had fo' tha last record read, unless a subsequent, redirected,
\fBgetline\fP function without a \fIvar\fP argument
is performed prior ta enterin tha \fBEND\fP action.
.TP 7
\fBNR\fP
Da ordinal number of tha current record from tha start of input.
Inside a \fBBEGIN\fP action tha value shall be zero. Inside
an \fBEND\fP action tha value shall be tha number of tha last record
processed.
.TP 7
\fBOFMT\fP
Da \fBprintf\fP format fo' convertin numbers ta strings up in output
statements (see Output
Statements ); \fB"%.6g"\fP by default. Da result of tha conversion
is unspecified if tha value of \fBOFMT\fP aint a
floating-point format justification.
.TP 7
\fBOFS\fP
Da \fBprint\fP statement output field separation; <space> by default.
.TP 7
\fBORS\fP
Da \fBprint\fP statement output record separator; a <newline> by
default.
.TP 7
\fBRLENGTH\fP
Da length of tha strang matched by tha \fBmatch\fP function.
.TP 7
\fBRS\fP
Da first characta of tha strang value of \fBRS\fP shall be tha input
record separator; a <newline> by default. If
\fBRS\fP gotz nuff mo' than one character, tha thangs up in dis biatch is unspecified.
If \fBRS\fP is null, then recordz is separated by
sequences consistin of a <newline> plus one or mo' blank lines,
leadin or trailin blank lines shall not result up in empty
recordz all up in tha beginnin or end of tha input, n' a <newline> shall
always be a gangbangin' field separator, no matta what tha fuck tha value of
\fBFS\fP is.
.TP 7
\fBRSTART\fP
Da startin posizzle of tha strang matched by tha \fBmatch\fP function,
numberin from 1. This shall always be equivalent to
the return value of tha \fBmatch\fP function.
.TP 7
\fBSUBSEP\fP
Da subscript separator strang fo' multi-dimensionizzle arrays; tha default
value is implementation-defined.
.sp
.SS Regular Expressions
.LP
Da \fIawk\fP utilitizzle shall make use of tha extended regular expression
notation (see tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, Section 9.4, Extended Regular Expressions)
except dat it shall allow tha use of C-language conventions fo' escaping
special charactas within tha EREs, as specified up in the
table up in tha Base Definitions volume of IEEE\ Std\ 1003.1-2001, Chapter
5, File
Format Notation ( \fB'\\\\'\fP, \fB'\\a'\fP, \fB'\\b'\fP, \fB'\\f'\fP,
\fB'\\n'\fP, \fB'\\r'\fP, \fB'\\t'\fP,
\fB'\\v'\fP ) n' tha followin table; these escape sequences shall
be recognized both inside n' outside bracket expressions.
Note dat recordz need not be separated by <newline>s n' strang constants
can contain <newline>s, so even the
\fB"\\n"\fP sequence is valid up in \fIawk\fP EREs. Usin a slash character
within a ERE requires tha escapin shown up in the
followin table.
.br
.sp
.ce 1
\fBTable: Escape Sequences up in \fIawk\fP\fP
.TS C
center; l1 lw(30)1 lw(30).
\fBEscape\fP	T{
.na
\fB\ \fP
.ad
T}	T{
.na
\fB\ \fP
.ad
T}
\fBSequence\fP	T{
.na
\fBDescription\fP
.ad
T}	T{
.na
\fBMeaning\fP
.ad
T}
\\"	T{
.na
Backslash quotation-mark
.ad
T}	T{
.na
Quotation-mark character
.ad
T}
\\/	T{
.na
Backslash slash
.ad
T}	T{
.na
Slash character
.ad
T}
\\ddd	T{
.na
A backslash characta followed by tha longest sequence of one, two, or three octal-digit charactas (01234567). If all of tha digits is 0 (that is, representation of tha NUL character), tha behavior is undefined.
.ad
T}	T{
.na
Da characta whose encodin is represented by tha one, two, or three-digit octal integer n' shit. Multi-byte charactas require multiple, concatenated escape sequencez of dis type, includin tha leadin \fB'\\'\fP fo' each byte.
.ad
T}
\\c	T{
.na
A backslash characta followed by any characta not busted lyrics bout up in dis table or up in tha table up in tha Base Definitions volume of IEEE\ Std\ 1003.1-2001, Chapta 5, File Format Notation ( \fB'\\\\'\fP, \fB'\\a'\fP, \fB'\\b'\fP, \fB'\\f'\fP, \fB'\\n'\fP, \fB'\\r'\fP, \fB'\\t'\fP, \fB'\\v'\fP ).
.ad
T}	T{
.na
Undefined
.ad
T}
.TE
.LP
A regular expression can be matched against a specific field or string
by rockin one of tha two regular expression matching
operators, \fB'~'\fP n' \fB"!~"\fP . These operators shall interpret
their right-hand operand as a regular
expression n' they left-hand operand as a string. If tha regular
expression matches tha string, tha \fB'~'\fP expression
shall evaluate ta a value of 1, n' tha \fB"!~"\fP expression shall
evaluate ta a value of 0. (Da regular expression
matchin operation be as defined by tha term matched up in tha Base Definitions
volume of IEEE\ Std\ 1003.1-2001, Section 9.1, Regular Expression
Definitions, where a match occurs on any part of the
strin unless tha regular expression is limited wit tha circumflex
or dollar sign special characters.) If tha regular expression
does not match tha string, tha \fB'~'\fP expression shall evaluate
to a value of 0, n' tha \fB"!~"\fP expression
shall evaluate ta a value of 1. If tha right-hand operand be any expression
other than tha lexical token \fBERE\fP, tha string
value of tha expression shall be interpreted as a extended regular
expression, includin tha escape conventions busted lyrics bout above.
Note dat these same escape conventions shall also be applied up in determining
the value of a strang literal (the lexical token
\fBSTRING\fP), n' thus shall be applied a second time when a string
literal is used up in dis context.
.LP
When a \fBERE\fP token appears as a expression up in any context other
than as tha right-hand of tha \fB'~'\fP or
\fB"!~"\fP operator or as one of tha built-in function arguments busted lyrics about
below, tha value of tha resultin expression
shall be tha equivalent of:
.sp
.RS
.nf

\fB$0 ~ /\fP\fIere\fP\fB/
\fP
.fi
.RE
.LP
Da \fIere\fP argument ta tha \fBgsub\fP, \fBmatch\fP, \fBsub\fP functions,
and tha \fIfs\fP argument ta tha \fBsplit\fP
function (see Strin Functions ) shall be interpreted as extended
regular expressions. These can be
either \fBERE\fP tokens or arbitrary expressions, n' shall be interpreted
in tha same manner as tha right-hand side of the
\fB'~'\fP or \fB"!~"\fP operator.
.LP
An extended regular expression can be used ta separate fieldz by using
the \fB-F\fP \fIERE\fP option or by assignin a string
containin tha expression ta tha built-in variable \fBFS\fP. Da default
value of tha \fBFS\fP variable shall be a single
<space>. Da followin raps bout \fBFS\fP behavior:
.IP " 1." 4
If \fBFS\fP be a null string, tha behavior is unspecified.
.LP
.IP " 2." 4
If \fBFS\fP be a single character:
.RS
.IP " a." 4
If \fBFS\fP is <space>, skip leadin n' trailin <blank>s; fields
shall be delimited by setz of one or more
<blank>s.
.LP
.IP " b." 4
Otherwise, if \fBFS\fP be any other characta \fIc\fP, fieldz shall
be delimited by each single occurrence of \fIc\fP.
.LP
.RE
.LP
.IP " 3." 4
Otherwise, tha strang value of \fBFS\fP shall be considered ta be
an extended regular expression. I aint talkin' bout chicken n' gravy biatch. Each occurrence of a sequence
matchin tha extended regular expression shall delimit fields.
.LP
.LP
Except fo' tha \fB'~'\fP n' \fB"!~"\fP operators, n' up in tha \fBgsub\fP,
\fBmatch\fP, \fBsplit\fP, and
\fBsub\fP built-in functions, ERE matchin shall be based on input
records; dat is, record separator charactas (the first
characta of tha value of tha variable \fBRS\fP, <newline> by default)
cannot be embedded up in tha expression, n' no
expression shall match tha record separator character n' shit. If tha record
separator aint <newline>, <newline>s embedded in
the expression can be matched. Y'all KNOW dat shit, muthafucka! For tha \fB'~'\fP n' \fB"!~"\fP operators,
and up in dem four built-in functions,
ERE matchin shall be based on text strings; dat is, any character
(includin <newline> n' tha record separator) can be
embedded up in tha pattern, n' a appropriate pattern shall match any
character n' shit. But fuck dat shiznit yo, tha word on tha street is dat up in all \fIawk\fP ERE matching, tha use of
one or mo' NUL charactas up in tha pattern, input record, or text string
produces undefined thangs up in dis biatch.
.SS Patterns
.LP
A \fIpattern\fP be any valid \fIexpression\fP, a range specified by
two expressions separated by a cold-ass lil comma, or one of tha two
special patterns \fBBEGIN\fP or \fBEND\fP.
.SS Special Patterns
.LP
Da \fIawk\fP utilitizzle shall recognize two special patterns, \fBBEGIN\fP
and \fBEND\fP. Each \fBBEGIN\fP pattern shall be
matched once n' its associated action executed before tha straight-up original gangsta record
of input is read (except possibly by use of the
\fBgetline\fP function-see Input/Output n' General Functions - in
a prior \fBBEGIN\fP action) and
before command line assignment is done. Each \fBEND\fP pattern shall
be matched once n' its associated action executed afta the
last record of input has been read. Y'all KNOW dat shit, muthafucka! These two patterns shall have
associated actions.
.LP
\fBBEGIN\fP n' \fBEND\fP shall not combine wit other patterns. Multiple
\fBBEGIN\fP n' \fBEND\fP patterns shall be
allowed. Y'all KNOW dat shit, muthafucka! Da actions associated wit tha \fBBEGIN\fP patterns shall
be executed up in tha order specified up in tha program, as is the
\fBEND\fP actions fo' realz. An \fBEND\fP pattern can precede a \fBBEGIN\fP
pattern up in a program.
.LP
If a \fIawk\fP program consistz of only actions wit tha pattern
\fBBEGIN\fP, n' tha \fBBEGIN\fP action gotz nuff no
\fBgetline\fP function, \fIawk\fP shall exit without readin its input
when tha last statement up in tha last \fBBEGIN\fP action is
executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If a \fIawk\fP program consistz of only actions wit the
pattern \fBEND\fP or only actions wit tha patterns
\fBBEGIN\fP n' \fBEND\fP, tha input shall be read before tha statements
in tha \fBEND\fP actions is executed.
.SS Expression Patterns
.LP
An expression pattern shall be evaluated as if it was a expression
in a Boolean context. If tha result is true, tha pattern
shall be considered ta match, n' tha associated action (if any) shall
be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha result is false, tha action shall not be
executed.
.SS Pattern Ranges
.LP
A pattern range consistz of two expressions separated by a cold-ass lil comma;
in dis case, tha action shall be performed fo' all records
between a match of tha straight-up original gangsta expression n' tha followin match of
the second expression, inclusive fo' realz. At dis point, tha pattern
range can be repeated startin at input recordz subsequent ta the
end of tha matched range.
.SS Actions
.LP
An action be a sequence of statements as shown up in tha grammar up in Grammar
\& fo' realz. Any single statement
can be replaced by a statement list enclosed up in braces. Da application
shall ensure dat statements up in a statement list are
separated by <newline>s or semicolons. Right back up in yo muthafuckin ass. Statements up in a statement list
shall be executed sequentially up in tha order dat they
appear.
.LP
Da \fIexpression\fP actin as tha conditionizzle up in a \fBif\fP statement
shall be evaluated n' if it is non-zero or non-null,
the followin statement shall be executed; otherwise, if \fBelse\fP
is present, tha statement followin tha \fBelse\fP shall be
executed.
.LP
Da \fBif\fP, \fBwhile\fP, \fBdo\fP... \fBwhile\fP, \fBfor\fP, \fBbreak\fP,
and \fBcontinue\fP statements is based on
the ISO\ C standard (see \fIConcepts Derived from tha ISO C Standard\fP
), except
that tha Boolean expressions shall be treated as busted lyrics bout up in Expressions
in awk , n' except up in the
case of:
.sp
.RS
.nf

\fBfor (\fP\fIvariable\fP \fBin\fP \fIarray\fP\fB)
\fP
.fi
.RE
.LP
which shall iterate, assignin each \fIindex\fP of \fIarray\fP to
\fIvariable\fP up in a unspecified order n' shit. Da thangs up in dis biatch of
addin freshly smoked up elements ta \fIarray\fP within such a \fBfor\fP loop are
undefined. Y'all KNOW dat shit, muthafucka! If a \fBbreak\fP or \fBcontinue\fP statement
occurs outside of a loop, tha behavior is undefined.
.LP
Da \fBdelete\fP statement shall remove a individual array element.
Thus, tha followin code deletes a entire array:
.sp
.RS
.nf

\fBfor (index up in array)
    delete array[index]
\fP
.fi
.RE
.LP
Da \fBnext\fP statement shall cause all further processin of the
current input record ta be abandoned. Y'all KNOW dat shit, muthafucka! Da behavior is
undefined if a \fBnext\fP statement appears or is invoked up in a \fBBEGIN\fP
or \fBEND\fP action.
.LP
Da \fBexit\fP statement shall invoke all \fBEND\fP actions up in the
order up in which they occur up in tha program source n' then
terminizzle tha program without readin further input fo' realz. An \fBexit\fP
statement inside a \fBEND\fP action shall terminizzle the
program without further execution of \fBEND\fP actions. If a expression
is specified up in a \fBexit\fP statement, its numeric
value shall be tha exit statuz of \fIawk\fP, unless subsequent errors
are encountered or a subsequent \fBexit\fP statement with
an expression is executed.
.SS Output Statements
.LP
Both \fBprint\fP n' \fBprintf\fP statements shall write ta standard
output by default. Da output shall be freestyled ta the
location specified by \fIoutput_redirection\fP if one is supplied,
as bigs up:
.sp
.RS
.nf

\fB>\fP \fIexpression\fP\fB>>\fP \fIexpression\fP\fB|\fP \fIexpression\fP
.fi
.RE
.LP
In all cases, tha \fIexpression\fP shall be evaluated ta produce a
strin dat is used as a pathname tha fuck into which ta write (for
\fB'>'\fP or \fB">>"\fP ) or as a cold-ass lil command ta be executed (for \fB'|'\fP
). Usin tha straight-up original gangsta two forms, if tha file
of dat name aint currently open, it shall be opened, bustin it
if necessary n' rockin tha straight-up original gangsta form, truncatin tha file. The
output then shall be appended ta tha file fo' realz. As long as tha file remains
open, subsequent calls up in which \fIexpression\fP evaluates
to tha same strang value shall simply append output ta tha file. The
file remains open until tha \fBclose\fP function (see Input/Output
and General Functions ) is called wit a expression dat evaluates
to tha same string
value.
.LP
Da third form shall write output onto a stream piped ta tha input
of a cold-ass lil command. Y'all KNOW dat shit, muthafucka! Da stream shall be pimped if no stream is
currently open wit tha value of \fIexpression\fP as its command name.
Da stream pimped shall be equivalent ta one pimped by a
call ta tha \fIpopen\fP() function defined up in tha System Interfaces
volume of
IEEE\ Std\ 1003.1-2001 wit tha value of \fIexpression\fP as tha \fIcommand\fP
argument n' a value of \fIw\fP as the
\fImode\fP argument fo' realz. As long as tha stream remains open, subsequent
calls up in which \fIexpression\fP evaluates ta tha same string
value shall write output ta tha existin stream. Da stream shall
remain open until tha \fBclose\fP function (see Input/Output n' General
Functions ) is called wit a expression dat evaluates ta tha same
strin value.
At dat time, tha stream shall be closed as if by a cold-ass lil call ta tha \fIpclose\fP()
function
defined up in tha System Interfaces volume of IEEE\ Std\ 1003.1-2001.
.LP
As busted lyrics bout up in detail by tha grammar up in Grammar , these output statements
shall take a
comma-separated list of \fIexpression\fPs referred ta up in tha grammar
by tha non-terminal symbols \fBexpr_list\fP,
\fBprint_expr_list\fP, or \fBprint_expr_list_opt\fP. This list is
referred ta here as tha \fIexpression list\fP, n' each member
is referred ta as a \fIexpression argument\fP.
.LP
Da \fBprint\fP statement shall write tha value of each expression
argument onto tha indicated output stream separated by the
current output field separator (see variable \fBOFS\fP above), and
terminated by tha output record separator (see variable
\fBORS\fP above) fo' realz. All expression arguments shall be taken as strings,
bein converted if necessary; dis conversion shall be as
busted lyrics bout up in Expressions up in awk , wit tha exception dat tha \fBprintf\fP
format up in \fBOFMT\fP
shall be used instead of tha value up in \fBCONVFMT\fP fo' realz. An empty expression
list shall stand fo' tha whole input record ($0).
.LP
Da \fBprintf\fP statement shall produce output based on a notation
similar ta tha File Format Notation used ta describe file
formats up in dis volume of IEEE\ Std\ 1003.1-2001 (see tha Base Definitions
volume of IEEE\ Std\ 1003.1-2001, Chapta 5, File Format Notation).
Output shall be produced as specified wit tha first
\fIexpression\fP argument as tha strang \fIformat\fP n' subsequent
\fIexpression\fP arguments as tha strings \fIarg1\fP to
\fIargn\fP, inclusive, wit tha followin exceptions:
.IP " 1." 4
Da \fIformat\fP shall be a actual characta strang rather than a
graphical representation. I aint talkin' bout chicken n' gravy biatch. Therefore, it cannot contain empty
characta positions. Da <space> up in tha \fIformat\fP string, up in any
context other than a \fIflag\fP of a cold-ass lil conversion
specification, shall be treated as a ordinary characta dat is copied
to tha output.
.LP
.IP " 2." 4
If tha characta set gotz nuff a \fB' '\fP characta n' dat character
appears in
the \fIformat\fP string, it shall be treated as a ordinary character
that is copied ta tha output.
.LP
.IP " 3." 4
Da \fIescape sequences\fP beginnin wit a funky-ass backslash characta shall
be treated as sequencez of ordinary charactas dat are
copied ta tha output. Note dat these same sequences shall be interpreted
lexically by \fIawk\fP when they step tha fuck up in literal
strings yo, but they shall not be treated specially by tha \fBprintf\fP
statement.
.LP
.IP " 4." 4
A \fIfield width\fP or \fIprecision\fP can be specified as tha \fB'*'\fP
characta instead of a gangbangin' finger-lickin' digit string. In dis case
the next argument from tha expression list shall be fetched n' its
numeric value taken as tha field width or precision.
.LP
.IP " 5." 4
Da implementation shall not precede or follow output from tha \fBd\fP
or \fBu\fP conversion specifier charactas with
<blank>s not specified by tha \fIformat\fP string.
.LP
.IP " 6." 4
Da implementation shall not precede output from tha \fBo\fP conversion
specifier characta wit leadin zeros not specified
by tha \fIformat\fP string.
.LP
.IP " 7." 4
For tha \fBc\fP conversion specifier character: if tha argument has
a numeric value, tha characta whose encodin is that
value shall be output. If tha value is zero or aint tha encoding
of any characta up in tha characta set, tha behavior is
undefined. Y'all KNOW dat shit, muthafucka! If tha argument aint gots a numeric value, tha first
characta of tha strang value shall be output; if tha string
does not contain any characters, tha behavior is undefined.
.LP
.IP " 8." 4
For each conversion justification dat consumes a argument, tha next
expression argument shall be evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. With tha exception
of tha \fBc\fP conversion specifier character, tha value shall be
converted (accordin ta tha rulez specified up in Expressions up in awk
) ta tha appropriate type fo' tha conversion justification.
.LP
.IP " 9." 4
If there be insufficient expression arguments ta satisfy all the
conversion justifications up in tha \fIformat\fP string, the
behavior is undefined.
.LP
.IP "10." 4
If any characta sequence up in tha \fIformat\fP strang begins wit a
\fB'%'\fP character yo, but do not form a valid conversion
specification, tha behavior is unspecified.
.LP
.LP
Both \fBprint\fP n' \fBprintf\fP can output at least {LINE_MAX} bytes.
.SS Functions
.LP
Da \fIawk\fP language has a variety of built-in functions: arithmetic,
string, input/output, n' general.
.SS Arithmetic Functions
.LP
Da arithmetic functions, except fo' \fBint\fP, shall be based on
the ISO\ C standard (see \fIConcepts Derived from tha ISO C Standard\fP
). Da behavior is undefined up in cases where the
ISO\ C standard specifies dat a error be returned or dat tha behavior
is undefined. Y'all KNOW dat shit, muthafucka! Although tha grammar (see Grammar ) permits built-in
functions ta step tha fuck up wit no arguments or parentheses, unless tha argument
or
parentheses is indicated as optionizzle up in tha followin list (by displaying
them within tha \fB"[]"\fP brackets), such use is
undefined.
.TP 7
\fBatan2\fP(\fIy\fP,\fIx\fP)
Return arctangent of \fIy\fP/\fIx\fP up in radians up in tha range [-pi,pi].
.TP 7
\fBcos\fP(\fIx\fP)
Return cosine of \fIx\fP, where \fIx\fP is up in radians.
.TP 7
\fBsin\fP(\fIx\fP)
Return sine of \fIx\fP, where \fIx\fP is up in radians.
.TP 7
\fBexp\fP(\fIx\fP)
Return tha exponential function of \fIx\fP.
.TP 7
\fBlog\fP(\fIx\fP)
Return tha natural logarithm of \fIx\fP.
.TP 7
\fBsqrt\fP(\fIx\fP)
Return tha square root of \fIx\fP.
.TP 7
\fBint\fP(\fIx\fP)
Return tha argument truncated ta a integer n' shit. Truncation shall be toward
0 when \fIx\fP>0.
.TP 7
\fBrand\fP()
Return a random number \fIn\fP, such dat 0<=\fIn\fP<1.
.TP 7
\fBsrand\fP(\fB[\fP\fIexpr\fP\fB]\fP)
Set tha seed value fo' \fIrand\fP ta \fIexpr\fP or use tha time of
dizzle if \fIexpr\fP is omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da previous seed value
shall be returned.
.sp
.SS Strin Functions
.LP
Da strang functions up in tha followin list shall be supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. Although
the grammar (see Grammar
) permits built-in functions ta step tha fuck up wit no arguments or parentheses,
unless tha argument or parentheses is indicated as
optionizzle up in tha followin list (by displayin dem within tha \fB"[]"\fP
brackets), such use is undefined.
.TP 7
\fBgsub\fP(\fIere\fP,\ \fIrepl\fP\fB[\fP,\ \fIin\fP\fB]\fP)
Behave like \fBsub\fP (see below), except dat it shall replace all
occurrencez of tha regular expression (like tha \fIed\fP utilitizzle global
substitute) up in $0 or up in tha \fIin\fP argument, when specified.
.TP 7
\fBindex\fP(\fIs\fP,\ \fIt\fP)
Return tha position, up in characters, numberin from 1, up in strang \fIs\fP
where strang \fIt\fP first occurs, or zero if it do
not occur at all.
.TP 7
\fBlength[\fP(\fB[\fP\fIs\fP\fB]\fP)\fB]\fP
Return tha length, up in characters, of its argument taken as a string,
or of tha whole record, $0, if there is no argument.
.TP 7
\fBmatch\fP(\fIs\fP,\ \fIere\fP)
Return tha position, up in characters, numberin from 1, up in strang \fIs\fP
where tha extended regular expression \fIere\fP
occurs, or zero if it do not occur at all. RSTART shall be set to
the startin posizzle (which is tha same ol' dirty as tha returned
value), zero if no match is found; RLENGTH shall be set ta tha length
of tha matched string, -1 if no match is found.
.TP 7
\fBsplit\fP(\fIs\fP,\ \fIa\fP\fB[\fP,\ \fIfs\ \fP \fB]\fP)
Split tha strang \fIs\fP tha fuck into array elements \fIa\fP[1], \fIa\fP[2],
\&..., \fIa\fP[\fIn\fP], n' return \fIn\fP fo' realz. All elements
of tha array shall be deleted before tha split is performed. Y'all KNOW dat shit, muthafucka! Da separation
shall be done wit tha ERE \fIfs\fP or wit tha field
separator \fBFS\fP if \fIfs\fP aint given. I aint talkin' bout chicken n' gravy biatch. Each array element shall
have a strang value when pimped and, if appropriate, the
array element shall be considered a numeric strang (see Expressions
in awk ). Da effect of a null
strin as tha value of \fIfs\fP is unspecified.
.TP 7
\fBsprintf\fP(\fIfmt\fP,\ \fIexpr\fP,\ \fIexpr\fP,\ ...)
Format tha expressions accordin ta tha \fBprintf\fP format given
by \fIfmt\fP n' return tha resultin string.
.TP 7
\fBsub(\fP\fIere\fP,\ \fIrepl\fP\fB[\fP,\ \fIin\ \fP \fB]\fP)
Substitute tha strang \fIrepl\fP up in place of tha straight-up original gangsta instizzle of
the extended regular expression \fIERE\fP up in strang \fIin\fP
and return tha number of substitutions fo' realz. An ampersand ( \fB'&'\fP )
appearin up in tha strang \fIrepl\fP shall be replaced by
the strang from \fIin\fP dat matches tha ERE fo' realz. An ampersand preceded
with a funky-ass backslash ( \fB'\\'\fP ) shall be interpreted as the
literal ampersand character n' shiznit fo' realz. An occurrence of two consecutizzle backslashes
shall be interpreted as just a single literal backslash
character n' shiznit fo' realz. Any other occurrence of a funky-ass backslash (for example, preceding
any other character) shall be treated as a literal backslash
character n' shit. Note dat if \fIrepl\fP be a strang literal (the lexical
token \fBSTRING\fP; peep Grammar ), tha handlin of tha ampersand character
occurs afta any lexical processing, includin any
lexical backslash escape sequence processing. If \fIin\fP is specified
and it aint a lvalue (see Expressions up in awk ), tha behavior is
undefined. Y'all KNOW dat shit, muthafucka! If \fIin\fP is omitted, \fIawk\fP shall use tha current
record ($0) up in its place.
.TP 7
\fBsubstr\fP(\fIs\fP,\ \fIm\fP\fB[\fP,\ \fIn\ \fP \fB]\fP)
Return tha at most \fIn\fP-characta substrin of \fIs\fP dat begins
at posizzle \fIm\fP, numberin from 1. If \fIn\fP is
omitted, or if \fIn\fP specifies mo' charactas than is left in
the string, tha length of tha substrin shall be limited by the
length of tha strang \fIs\fP.
.TP 7
\fBtolower\fP(\fIs\fP)
Return a strang based on tha strang \fIs\fP. Each characta up in \fIs\fP
that be a uppercase letta specified ta have a
\fBtolower\fP mappin by tha \fILC_CTYPE\fP category of tha current
locale shall be replaced up in tha returned strang by the
lowercase letta specified by tha mapping. Other charactas up in \fIs\fP
shall be unchanged up in tha returned string.
.TP 7
\fBtoupper\fP(\fIs\fP)
Return a strang based on tha strang \fIs\fP. Each characta up in \fIs\fP
that be a lowercase letta specified ta have a
\fBtoupper\fP mappin by tha \fILC_CTYPE\fP category of tha current
locale is replaced up in tha returned strang by tha uppercase
letta specified by tha mapping. Other charactas up in \fIs\fP is unchanged
in tha returned string.
.sp
.LP
All of tha precedin functions dat take \fIERE\fP as a parameter
expect a pattern or a strang valued expression dat be a
regular expression as defined up in Regular Expressions .
.SS Input/Output n' General Functions
.LP
Da input/output n' general functions are:
.TP 7
\fBclose\fP(\fIexpression\fP)
Close tha file or pipe opened by a \fBprint\fP or \fBprintf\fP statement
or a cold-ass lil call ta \fBgetline\fP wit tha same string-valued
\fIexpression\fP. Da limit on tha number of open \fIexpression\fP
arguments is implementation-defined. Y'all KNOW dat shit, muthafucka! If tha close was
successful, tha function shall return zero; otherwise, it shall return
non-zero.
.TP 7
\fIexpression\ |\ \fP \fBgetline\ [\fP\fIvar\fP\fB]\fP
Read a record of input from a stream piped from tha output of a cold-ass lil command.
Da stream shall be pimped if no stream is currently open
with tha value of \fIexpression\fP as its command name. Da stream
created shall be equivalent ta one pimped by a cold-ass lil call ta tha \fIpopen\fP()
function wit tha value of \fIexpression\fP as tha \fIcommand\fP argument
and a
value of \fIr\fP as tha \fImode\fP argument fo' realz. As long as tha stream
remains open, subsequent calls up in which \fIexpression\fP
evaluates ta tha same strang value shall read subsequent recordz from
the stream. Da stream shall remain open until the
\fBclose\fP function is called wit a expression dat evaluates to
the same strang value fo' realz. At dat time, tha stream shall be
closed as if by a cold-ass lil call ta tha \fIpclose\fP() function. I aint talkin' bout chicken n' gravy biatch. If \fIvar\fP
is omitted, $0 and
\fBNF\fP shall be set; otherwise, \fIvar\fP shall be set and, if appropriate,
it shall be considered a numeric strang (see Expressions up in awk ).
.LP
Da \fBgetline\fP operator can form ambiguous constructs when there
are unparenthesized operators (includin concatenate) to
the left of tha \fB'|'\fP (to tha beginnin of tha expression containing
\fBgetline\fP). In tha context of tha \fB'$'\fP
operator, \fB'|'\fP shall behave as if it had a lower precedence than
\fB'$'\fP . Da result of evaluatin other operators is
unspecified, n' conformin applications shall parenthesize properly
all such usages.
.TP 7
\fBgetline\fP
Set $0 ta tha next input record from tha current input file. This
form of \fBgetline\fP shall set tha \fBNF\fP, \fBNR\fP,
and \fBFNR\fP variables.
.TP 7
\fBgetline\ \fP \fIvar\fP
Set variable \fIvar\fP ta tha next input record from tha current input
file and, if appropriate, \fIvar\fP shall be
considered a numeric strang (see Expressions up in awk ). This form of
\fBgetline\fP shall set the
\fBFNR\fP n' \fBNR\fP variables.
.TP 7
\fBgetline\ [\fP\fIvar\fP\fB]\ \fP <\ \fIexpression\fP
Read tha next record of input from a named file. Da \fIexpression\fP
shall be evaluated ta produce a strang dat is used as a
pathname. If tha file of dat name aint currently open, it shall
be opened. Y'all KNOW dat shit, muthafucka! As long as tha stream remains open, subsequent calls
in which \fIexpression\fP evaluates ta tha same strang value shall
read subsequent recordz from tha file. Da file shall remain
open until tha \fBclose\fP function is called wit a expression that
evaluates ta tha same strang value. If \fIvar\fP is
omitted, $0 n' \fBNF\fP shall be set; otherwise, \fIvar\fP shall
be set and, if appropriate, it shall be considered a numeric
strin (see Expressions up in awk ). 
.LP
Da \fBgetline\fP operator can form ambiguous constructs when there
are unparenthesized binary operators (including
concatenate) ta tha right of tha \fB'<'\fP (up ta tha end of tha expression
containin tha \fBgetline\fP). Da result of
evaluatin such a cold-ass lil construct is unspecified, n' conformin applications
shall parenthesize properly all such usages.
.TP 7
\fBsystem\fP(\fIexpression\fP)
Execute tha command given by \fIexpression\fP up in a manner equivalent
to tha \fIsystem\fP()
function defined up in tha System Interfaces volume of IEEE\ Std\ 1003.1-2001
and return tha exit statuz of tha command.
.sp
.LP
All formz of \fBgetline\fP shall return 1 fo' successful input, zero
for end-of-file, n' -1 fo' a error.
.LP
Where strings is used as tha name of a gangbangin' file or pipeline, tha application
shall ensure dat tha strings is textually identical.
Da terminologizzle "same strang value" implies dat "equivalent strings",
even dem dat differ only by <space>s, represent
different files.
.SS User-Defined Functions
.LP
Da \fIawk\fP language also serves up user-defined functions. Right back up in yo muthafuckin ass. Such
functions can be defined as:
.sp
.RS
.nf

\fBfunction\fP \fIname\fP\fB(\fP\fB[\fP\fIparameter\fP\fB, ...\fP\fB]\fP\fB) {\fP \fIstatements\fP \fB}
\fP
.fi
.RE
.LP
A function can be referred ta anywhere up in a \fIawk\fP program; in
particular, its use can precede its definition. I aint talkin' bout chicken n' gravy biatch. Da scope of
a function is global.
.LP
Function parameters, if present, can be either scalars or arrays;
the behavior is undefined if a array name is passed as a
parameta dat tha function uses as a scalar, or if a scalar expression
is passed as a parameta dat tha function uses as an
array. Function parametas shall be passed by value if scalar and
by reference if array name.
.LP
Da number of parametas up in tha function definizzle need not match
the number of parametas up in tha function call. Excess formal
parametas can be used as local variables. If fewer arguments are
supplied up in a gangbangin' function call than is up in tha function definition,
the extra parametas dat is used up in tha function body as scalars
shall evaluate ta tha uninitialized value until they are
otherwise initialized, n' tha extra parametas dat is used up in the
function body as arrays shall be treated as uninitialized
arrays where each element evaluates ta tha uninitialized value until
otherwise initialized.
.LP
When invokin a gangbangin' function, no white space can be placed between the
function name n' tha openin parenthesis. Function calls can
be nested n' recursive calls can be made upon functions. Upon return
from any nested or recursive function call, tha jointz of all
of tha callin functionz parametas shall be unchanged, except for
array parametas passed by reference. Da \fBreturn\fP
statement can be used ta return a value. If a \fBreturn\fP statement
appears outside of a gangbangin' function definition, tha behavior is
undefined.
.LP
In tha function definition, <newline>s shall be optionizzle before the
openin brace n' afta tha closin brace. Function
definitions can step tha fuck up anywhere up in tha program where a \fIpattern-action\fP
pair be allowed.
.SS Grammar
.LP
Da grammar up in dis section n' tha lexical conventions up in tha following
section shall together describe tha syntax for
\fIawk\fP programs. Da general conventions fo' dis steez of grammar
are busted lyrics bout up in \fIGrammar Conventions\fP  fo' realz. A valid program can be
represented as tha non-terminal symbol
\fIprogram\fP up in tha grammar. Shiiit, dis aint no joke. This formal syntax shall take precedence
over tha precedin text syntax description.
.sp
.RS
.nf

\fB%token NAME NUMBER STRING ERE
%token FUNC_NAME   /* Name followed by '(' without white space. */
.sp

/* Keywordz  */
%token       Begin   End
/*          'BEGIN' 'END'                            */
.sp

%token       Break   Continue   Delete   Do   Else
/*          'break' 'continue' 'delete' 'do' 'else'  */
.sp

%token       Exit   For   Function   If   In
/*          'exit' 'for' 'function' 'if' 'in'        */
.sp

%token       Next   Print   Printf   Return   While
/*          'next' 'print' 'printf' 'return' 'while' */
.sp

/* Reserved function names */
%token BUILTIN_FUNC_NAME
            /* One token fo' tha following:
             * atan2 cos sin exp log sqrt int rand srand
             * gsub index length match split sprintf sub
             * substr tolower toupper close system
             */
%token GETLINE
            /* Syntactically different from other built-ins. */
.sp

/* Two-characta tokens. */
%token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN POW_ASSIGN
/*     '+='       '-='       '*='       '/='       '%='       '^=' */
.sp

%token OR   AND  NO_MATCH   EQ   LE   GE   NE   INCR  DECR  APPEND
/*     '||' '&&' '!~' '==' '<=' '>=' '!=' '++'  '--'  '>>'   */
.sp

/* One-characta tokens. */
%token '{' '}' '(' ')' '[' ']' ',' ';' NEWLINE
%token '+' '-' '*' '%' '^' '!' '>' '<' '|' '?' ':' '~' '$' '='
.sp

%start program
%%
.sp

program          : item_list
                 | actionless_item_list
                 ;
.sp

item_list        : newline_opt
                 | actionless_item_list item terminator
                 | item_list            item terminator
                 | item_list          action terminator
                 ;
.sp

actionless_item_list : item_list            pattern terminator
                 | actionless_item_list pattern terminator
                 ;
.sp

item             : pattern action
                 | Function NAME      '(' param_list_opt ')'
                       newline_opt action
                 | Function FUNC_NAME '(' param_list_opt ')'
                       newline_opt action
                 ;
.sp

param_list_opt   : /* empty */
                 | param_list
                 ;
.sp

param_list       : NAME
                 | param_list ',' NAME
                 ;
.sp

pattern          : Begin
                 | End
                 | expr
                 | expr ',' newline_opt expr
                 ;
.sp

action           : '{' newline_opt                             '}'
                 | '{' newline_opt terminated_statement_list   '}'
                 | '{' newline_opt unterminated_statement_list '}'
                 ;
.sp

terminator       : terminator ';'
                 | terminator NEWLINE
                 |            ';'
                 |            NEWLINE
                 ;
.sp

terminated_statement_list : terminated_statement
                 | terminated_statement_list terminated_statement
                 ;
.sp

unterminated_statement_list : unterminated_statement
                 | terminated_statement_list unterminated_statement
                 ;
.sp

terminated_statement : action newline_opt
                 | If '(' expr ')' newline_opt terminated_statement
                 | If '(' expr ')' newline_opt terminated_statement
                       Else newline_opt terminated_statement
                 | While '(' expr ')' newline_opt terminated_statement
                 | For '(' simple_statement_opt ';'
                      expr_opt ';' simple_statement_opt ')' newline_opt
                      terminated_statement
                 | For '(' NAME In NAME ')' newline_opt
                      terminated_statement
                 | ';' newline_opt
                 | terminatable_statement NEWLINE newline_opt
                 | terminatable_statement ';'     newline_opt
                 ;
.sp

unterminated_statement : terminatable_statement
                 | If '(' expr ')' newline_opt unterminated_statement
                 | If '(' expr ')' newline_opt terminated_statement
                      Else newline_opt unterminated_statement
                 | While '(' expr ')' newline_opt unterminated_statement
                 | For '(' simple_statement_opt ';'
                  expr_opt ';' simple_statement_opt ')' newline_opt
                      unterminated_statement
                 | For '(' NAME In NAME ')' newline_opt
                      unterminated_statement
                 ;
.sp

terminatable_statement : simple_statement
                 | Break
                 | Continue
                 | Next
                 | Exit expr_opt
                 | Return expr_opt
                 | Do newline_opt terminated_statement While '(' expr ')'
                 ;
.sp

simple_statement_opt : /* empty */
                 | simple_statement
                 ;
.sp

simple_statement : Delete NAME '[' expr_list ']'
                 | expr
                 | print_statement
                 ;
.sp

print_statement  : simple_print_statement
                 | simple_print_statement output_redirection
                 ;
.sp

simple_print_statement : Print  print_expr_list_opt
                 | Print  '(' multiple_expr_list ')'
                 | Printf print_expr_list
                 | Printf '(' multiple_expr_list ')'
                 ;
.sp

output_redirection : '>'    expr
                 | APPEND expr
                 | '|'    expr
                 ;
.sp

expr_list_opt    : /* empty */
                 | expr_list
                 ;
.sp

expr_list        : expr
                 | multiple_expr_list
                 ;
.sp

multiple_expr_list : expr ',' newline_opt expr
                 | multiple_expr_list ',' newline_opt expr
                 ;
.sp

expr_opt         : /* empty */
                 | expr
                 ;
.sp

expr             : unary_expr
                 | non_unary_expr
                 ;
.sp

unary_expr       : '+' expr
                 | '-' expr
                 | unary_expr '^'      expr
                 | unary_expr '*'      expr
                 | unary_expr '/'      expr
                 | unary_expr '%'      expr
                 | unary_expr '+'      expr
                 | unary_expr '-'      expr
                 | unary_expr          non_unary_expr
                 | unary_expr '<'      expr
                 | unary_expr LE       expr
                 | unary_expr NE       expr
                 | unary_expr EQ       expr
                 | unary_expr '>'      expr
                 | unary_expr GE       expr
                 | unary_expr '~'      expr
                 | unary_expr NO_MATCH expr
                 | unary_expr In NAME
                 | unary_expr AND newline_opt expr
                 | unary_expr OR  newline_opt expr
                 | unary_expr '?' expr ':' expr
                 | unary_input_function
                 ;
.sp

non_unary_expr   : '(' expr ')'
                 | '!' expr
                 | non_unary_expr '^'      expr
                 | non_unary_expr '*'      expr
                 | non_unary_expr '/'      expr
                 | non_unary_expr '%'      expr
                 | non_unary_expr '+'      expr
                 | non_unary_expr '-'      expr
                 | non_unary_expr          non_unary_expr
                 | non_unary_expr '<'      expr
                 | non_unary_expr LE       expr
                 | non_unary_expr NE       expr
                 | non_unary_expr EQ       expr
                 | non_unary_expr '>'      expr
                 | non_unary_expr GE       expr
                 | non_unary_expr '~'      expr
                 | non_unary_expr NO_MATCH expr
                 | non_unary_expr In NAME
                 | '(' multiple_expr_list ')' In NAME
                 | non_unary_expr AND newline_opt expr
                 | non_unary_expr OR  newline_opt expr
                 | non_unary_expr '?' expr ':' expr
                 | NUMBER
                 | STRING
                 | lvalue
                 | ERE
                 | lvalue INCR
                 | lvalue DECR
                 | INCR lvalue
                 | DECR lvalue
                 | lvalue POW_ASSIGN expr
                 | lvalue MOD_ASSIGN expr
                 | lvalue MUL_ASSIGN expr
                 | lvalue DIV_ASSIGN expr
                 | lvalue ADD_ASSIGN expr
                 | lvalue SUB_ASSIGN expr
                 | lvalue '=' expr
                 | FUNC_NAME '(' expr_list_opt ')'
                      /* no white space allowed before '(' */
                 | BUILTIN_FUNC_NAME '(' expr_list_opt ')'
                 | BUILTIN_FUNC_NAME
                 | non_unary_input_function
                 ;
.sp

print_expr_list_opt : /* empty */
                 | print_expr_list
                 ;
.sp

print_expr_list  : print_expr
                 | print_expr_list ',' newline_opt print_expr
                 ;
.sp

print_expr       : unary_print_expr
                 | non_unary_print_expr
                 ;
.sp

unary_print_expr : '+' print_expr
                 | '-' print_expr
                 | unary_print_expr '^'      print_expr
                 | unary_print_expr '*'      print_expr
                 | unary_print_expr '/'      print_expr
                 | unary_print_expr '%'      print_expr
                 | unary_print_expr '+'      print_expr
                 | unary_print_expr '-'      print_expr
                 | unary_print_expr          non_unary_print_expr
                 | unary_print_expr '~'      print_expr
                 | unary_print_expr NO_MATCH print_expr
                 | unary_print_expr In NAME
                 | unary_print_expr AND newline_opt print_expr
                 | unary_print_expr OR  newline_opt print_expr
                 | unary_print_expr '?' print_expr ':' print_expr
                 ;
.sp

non_unary_print_expr : '(' expr ')'
                 | '!' print_expr
                 | non_unary_print_expr '^'      print_expr
                 | non_unary_print_expr '*'      print_expr
                 | non_unary_print_expr '/'      print_expr
                 | non_unary_print_expr '%'      print_expr
                 | non_unary_print_expr '+'      print_expr
                 | non_unary_print_expr '-'      print_expr
                 | non_unary_print_expr          non_unary_print_expr
                 | non_unary_print_expr '~'      print_expr
                 | non_unary_print_expr NO_MATCH print_expr
                 | non_unary_print_expr In NAME
                 | '(' multiple_expr_list ')' In NAME
                 | non_unary_print_expr AND newline_opt print_expr
                 | non_unary_print_expr OR  newline_opt print_expr
                 | non_unary_print_expr '?' print_expr ':' print_expr
                 | NUMBER
                 | STRING
                 | lvalue
                 | ERE
                 | lvalue INCR
                 | lvalue DECR
                 | INCR lvalue
                 | DECR lvalue
                 | lvalue POW_ASSIGN print_expr
                 | lvalue MOD_ASSIGN print_expr
                 | lvalue MUL_ASSIGN print_expr
                 | lvalue DIV_ASSIGN print_expr
                 | lvalue ADD_ASSIGN print_expr
                 | lvalue SUB_ASSIGN print_expr
                 | lvalue '=' print_expr
                 | FUNC_NAME '(' expr_list_opt ')'
                     /* no white space allowed before '(' */
                 | BUILTIN_FUNC_NAME '(' expr_list_opt ')'
                 | BUILTIN_FUNC_NAME
                 ;
.sp

lvalue           : NAME
                 | NAME '[' expr_list ']'
                 | '$' expr
                 ;
.sp

non_unary_input_function : simple_get
                 | simple_get '<' expr
                 | non_unary_expr '|' simple_get
                 ;
.sp

unary_input_function : unary_expr '|' simple_get
                 ;
.sp

simple_get       : GETLINE
                 | GETLINE lvalue
                 ;
.sp

newline_opt      : /* empty */
                 | newline_opt NEWLINE
                 ;
\fP
.fi
.RE
.LP
This grammar has nuff muthafuckin ambiguitizzles dat shall be resolved as bigs up:
.IP " *" 3
Operator precedence n' associativitizzle shall be as busted lyrics bout up in Expressions
in Decreasin Precedence up in \fIawk\fP .
.LP
.IP " *" 3
In case of ambiguity, a \fBelse\fP shall be associated wit da most thugged-out
immediately precedin \fBif\fP dat would satisfy the
grammar.
.LP
.IP " *" 3
In some contexts, a slash ( \fB'/'\fP ) dat is used ta surround an
ERE could also be tha division operator. Shiiit, dis aint no joke. This shall be
resolved up in such a way dat wherever tha division operator could appear,
a slash be assumed ta be tha division operator. Shiiit, dis aint no joke. (There is
no unary division operator.)
.LP
.LP
One convention dat might not be obvious from tha formal grammar is
where <newline>s is acceptable. There is several
obvious placements like fuckin terminatin a statement, n' a funky-ass backslash
can be used ta escape <newline>s between any lexical
tokens. In addition, <newline>s without backslashes can follow a cold-ass lil comma,
an open brace, logical AND operator (
\fB"&&"\fP ), logical OR operator ( \fB"||"\fP ), tha \fBdo\fP keyword,
the \fBelse\fP keyword, n' tha closing
parenthesiz of a \fBif\fP, \fBfor\fP, or \fBwhile\fP statement. For
example:
.sp
.RS
.nf

\fB{ print  $1,
         $2 }
\fP
.fi
.RE
.SS Lexical Conventions
.LP
Da lexical conventions fo' \fIawk\fP programs, wit respect ta the
precedin grammar, shall be as bigs up:
.IP " 1." 4
Except as noted, \fIawk\fP shall recognize tha longest possible token
or delimita beginnin at a given point.
.LP
.IP " 2." 4
A comment shall consist of any charactas beginnin wit tha number
sign characta n' terminated by yo, but excludin tha next
occurrence of, a <newline>. Comments shall have no effect, except
to delimit lexical tokens.
.LP
.IP " 3." 4
Da <newline> shall be recognized as tha token \fBNEWLINE\fP.
.LP
.IP " 4." 4
A backslash characta immediately followed by a <newline> shall have
no effect.
.LP
.IP " 5." 4
Da token \fBSTRING\fP shall represent a strang constant fo' realz. A string
constant shall begin wit tha characta \fB' .'\fP Within
a strang constant, a funky-ass backslash characta shall be considered ta begin
an escape sequence as specified up in tha table up in tha Base
Definitions volume of IEEE\ Std\ 1003.1-2001, Chapta 5, File Format
Notation (
\fB'\\\\'\fP, \fB'\\a'\fP, \fB'\\b'\fP, \fB'\\f'\fP, \fB'\\n'\fP,
\fB'\\r'\fP, \fB'\\t'\fP, \fB'\\v'\fP ). In
addition, tha escape sequences up in Expressions up in Decreasin Precedence
in \fIawk\fP shall be recognized. Y'all KNOW dat shit, muthafucka! A <newline> shall not
occur within a strang constant fo' realz. A strang constant shall be terminated
by tha straight-up original gangsta unescaped occurrence of tha character
\fB''\fP afta tha one dat begins tha strang constant. Da value
of tha strang shall be tha sequence of all unescaped
charactas n' jointz of escape sequences between yo, but not including,
the two delimitin \fB''\fP characters.
.LP
.IP " 6." 4
Da token \fBERE\fP represents a extended regular expression constant.
An ERE constant shall begin wit tha slash character.
Within a ERE constant, a funky-ass backslash characta shall be considered
to begin a escape sequence as specified up in tha table up in tha Base
Definitions volume of IEEE\ Std\ 1003.1-2001, Chapta 5, File Format
Notation. I aint talkin' bout chicken n' gravy biatch. In
addition, tha escape sequences up in Expressions up in Decreasin Precedence
in \fIawk\fP shall be recognized. Y'all KNOW dat shit, muthafucka! Da application shall
ensure dat a <newline> do not occur within a ERE constant fo' realz. An
ERE constant shall be terminated by tha straight-up original gangsta unescaped
occurrence of tha slash characta afta tha one dat begins tha ERE
constant. Da extended regular expression represented by the
ERE constant shall be tha sequence of all unescaped charactas and
valuez of escape sequences between yo, but not including, tha two
delimitin slash characters.
.LP
.IP " 7." 4
A <blank> shall have no effect, except ta delimit lexical tokens or
within \fBSTRING\fP or \fBERE\fP tokens.
.LP
.IP " 8." 4
Da token \fBNUMBER\fP shall represent a numeric constant. Its form
and numeric value shall be equivalent ta either of the
tokens \fBfloating-constant\fP or \fBinteger-constant\fP as specified
by tha ISO\ C standard, wit tha following
exceptions:
.RS
.IP " a." 4
An integer constant cannot begin wit 0x or include tha hexadecimal
digits \fB'a'\fP, \fB'b'\fP, \fB'c'\fP,
\fB'd'\fP, \fB'e'\fP, \fB'f'\fP, \fB'A'\fP, \fB'B'\fP, \fB'C'\fP,
\fB'D'\fP, \fB'E'\fP, or
\fB'F'\fP .
.LP
.IP " b." 4
Da value of a integer constant beginnin wit 0 shall be taken in
decimal rather than octal.
.LP
.IP " c." 4
An integer constant cannot include a suffix ( \fB'u'\fP, \fB'U'\fP,
\fB'l'\fP, or \fB'L'\fP ).
.LP
.IP " d." 4
A floatin constant cannot include a suffix ( \fB'f'\fP, \fB'F'\fP,
\fB'l'\fP, or \fB'L'\fP ).
.LP
.RE
.LP
If tha value is too big-ass or too lil' small-ass ta be representable (see \fIConcepts
Derived from
the ISO C Standard\fP ), tha behavior is undefined.
.LP
.IP " 9." 4
A sequence of underscores, digits, n' alphabetics from tha portable
characta set (see tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, Section 6.1, Portable Characta Set), beginning
with a underscore or alphabetic, shall be considered a word.
.LP
.IP "10." 4
Da followin lyrics is keywordz dat shall be recognized as individual
tokens; tha name of tha token is tha same ol' dirty as the
keyword:
.TS C
center; lw(13) lw(13) lw(13) lw(13) lw(13) lw(13).
T{
\fB
.br
BEGIN
.br
break
.br
continue
.br
\fP
T}	T{
\fB
.br
delete
.br
do
.br
else
.br
\fP
T}	T{
\fB
.br
END
.br
exit
.br
for
.br
\fP
T}	T{
\fB
.br
function
.br
getline
.br
if
.br
\fP
T}	T{
\fB
.br
in
.br
next
.br
print
.br
\fP
T}	T{
\fB
.br
printf
.br
return
.br
while
.br
\fP
T}
.TE
.LP
.IP "11." 4
Da followin lyrics is namez of built-in functions n' shall be recognized
as tha token \fBBUILTIN_FUNC_NAME\fP:
.TS C
center; lw(13) lw(13) lw(13) lw(13) lw(13) lw(13).
T{
\fB
.br
atan2
.br
close
.br
cos
.br
exp
.br
\fP
T}	T{
\fB
.br
gsub
.br
index
.br
int
.br
length
.br
\fP
T}	T{
\fB
.br
log
.br
match
.br
rand
.br
sin
.br
\fP
T}	T{
\fB
.br
split
.br
sprintf
.br
sqrt
.br
srand
.br
\fP
T}	T{
\fB
.br
sub
.br
substr
.br
system
.br
tolower
.br
\fP
T}	T{
\fB
.br
toupper
.br
\fP
T}
.TE
.LP
Da above-listed keywordz n' namez of built-in functions is considered
reserved lyrics.
.LP
.IP "12." 4
Da token \fBNAME\fP shall consist of a word dat aint a keyword
or a name of a funky-ass built-in function n' aint followed
immediately (without any delimiters) by tha \fB'('\fP character.
.LP
.IP "13." 4
Da token \fBFUNC_NAME\fP shall consist of a word dat aint a keyword
or a name of a funky-ass built-in function, followed immediately
(without any delimiters) by tha \fB'('\fP character n' shit. Da \fB'('\fP
characta shall not be included as part of tha token.
.LP
.IP "14." 4
Da followin two-characta sequences shall be recognized as tha named
tokens:
.TS C
center; l l l l.
\fBToken Name\fP	\fBSequence\fP	\fBToken Name\fP	\fBSequence\fP
\fBADD_ASSIGN\fP	+=	\fBNO_MATCH\fP	!~
\fBSUB_ASSIGN\fP	-=	\fBEQ\fP	==
\fBMUL_ASSIGN\fP	*=	\fBLE\fP	<=
\fBDIV_ASSIGN\fP	/=	\fBGE\fP	>=
\fBMOD_ASSIGN\fP	%=	\fBNE\fP	!=
\fBPOW_ASSIGN\fP	^=	\fBINCR\fP	++
\fBOR\fP	||	\fBDECR\fP	--
\fBAND\fP	&&	\fBAPPEND\fP	>>
.TE
.LP
.IP "15." 4
Da followin single charactas shall be recognized as tokens whose
names is tha character:
.sp
.RS
.nf

\fB<newline> { } ( ) [ ] , ; + - * % ^ ! > < | ? : ~ $ =
\fP
.fi
.RE
.LP
.LP
There be a lexical ambiguitizzle between tha token \fBERE\fP n' tha tokens
\fB'/'\fP n' \fBDIV_ASSIGN\fP. When a input
sequence begins wit a slash characta up in any syntactic context where
the token \fB'/'\fP or \fBDIV_ASSIGN\fP could step tha fuck up as
the next token up in a valid program, tha longer of dem two tokens
that can be recognized shall be recognized. Y'all KNOW dat shit, muthafucka! In any other
syntactic context where tha token \fBERE\fP could step tha fuck up as tha next
token up in a valid program, tha token \fBERE\fP shall be
recognized.
.SH EXIT STATUS
.LP
Da followin exit joints shall be returned:
.TP 7
\ 0
All input filez was processed successfully.
.TP 7
>0
An error occurred.
.sp
.LP
Da exit status can be altered within tha program by rockin a \fBexit\fP
expression.
.SH CONSEQUENCES OF ERRORS
.LP
If any \fIfile\fP operand is specified n' tha named file cannot be
accessed, \fIawk\fP shall write a gangbangin' finger-lickin' diagnostic message to
standard error n' terminizzle without any further action.
.LP
If tha program specified by either tha \fIprogram\fP operand or a
\fIprogfile\fP operand aint a valid \fIawk\fP program (as
specified up in tha EXTENDED DESCRIPTION section), tha behavior is undefined.
.LP
\fIDa followin sections is informative.\fP
.SH APPLICATION USAGE
.LP
Da \fBindex\fP, \fBlength\fP, \fBmatch\fP, n' \fBsubstr\fP functions
should not be trippin wit similar functions up in the
ISO\ C standard; tha \fIawk\fP versions deal wit characters, while
the ISO\ C standard deals wit bytes.
.LP
Because tha concatenation operation is represented by adjacent expressions
rather than a explicit operator, it is often
necessary ta use parentheses ta enforce tha proper evaluation precedence.
.SH EXAMPLES
.LP
Da \fIawk\fP program specified up in tha command line is most easily
specified within single-quotes (for example,
\fI'program'\fP) fo' applications rockin \fIsh\fP, cuz \fIawk\fP
programs commonly contain
charactas dat is special ta tha shell, includin double-quotes.
In tha cases where a \fIawk\fP program gotz nuff single-quote
characters, it is probably easiest ta specify most of tha program as
strings within single-quotes concatenated by tha shell with
quoted single-quote characters. For example:
.sp
.RS
.nf

\fBawk '/'\\''/ { print "quote:", $0 }'
\fP
.fi
.RE
.LP
prints all lines from tha standard input containin a single-quote
character, prefixed wit \fIquote\fP:.
.LP
Da followin is examplez of simple \fIawk\fP programs:
.IP " 1." 4
Write ta tha standard output all input lines fo' which field 3 is
greata than 5:
.sp
.RS
.nf

\fB$3 > 5
\fP
.fi
.RE
.LP
.IP " 2." 4
Write every last muthafuckin tenth line:
.sp
.RS
.nf

\fB(NR % 10) == 0
\fP
.fi
.RE
.LP
.IP " 3." 4
Write any line wit a substrin matchin tha regular expression:
.sp
.RS
.nf

\fB/(G|D)(2[0-9][[:alpha:]]*)/
\fP
.fi
.RE
.LP
.IP " 4." 4
Print any line wit a substrin containin a \fB'G'\fP or \fB'D'\fP,
followed by a sequence of digits n' characters.
This example uses characta classes \fBdigit\fP n' \fBalpha\fP to
match language-independent digit n' alphabetic characters
respectively:
.sp
.RS
.nf

\fB/(G|D)([[:digit:][:alpha:]]*)/
\fP
.fi
.RE
.LP
.IP " 5." 4
Write any line up in which tha second field matches tha regular expression
and tha fourth field do not:
.sp
.RS
.nf

\fB$2 ~ /xyz/ && $4 !~ /xyz/
\fP
.fi
.RE
.LP
.IP " 6." 4
Write any line up in which tha second field gotz nuff a funky-ass backslash:
.sp
.RS
.nf

\fB$2 ~ /\\\\/
\fP
.fi
.RE
.LP
.IP " 7." 4
Write any line up in which tha second field gotz nuff a funky-ass backslash. Note
that backslash escapes is interpreted twice; once in
lexical processin of tha strang n' once up in processin tha regular
expression:
.sp
.RS
.nf

\fB$2 ~ "\\\\\\\\"
\fP
.fi
.RE
.LP
.IP " 8." 4
Write tha second ta tha last n' tha last field up in each line. Right back up in yo muthafuckin ass. Separate
the fieldz by a cold-ass lil colon:
.sp
.RS
.nf

\fB{OFS=":";print $(NF-1), $NF}
\fP
.fi
.RE
.LP
.IP " 9." 4
Write tha line number n' number of fieldz up in each line. Da three
strings representin tha line number, tha colon, n' the
number of fieldz is concatenated n' dat strang is freestyled ta standard
output:
.sp
.RS
.nf

\fB{print NR ":" NF}
\fP
.fi
.RE
.LP
.IP "10." 4
Write lines longer than 72 characters:
.sp
.RS
.nf

\fBlength($0) > 72
\fP
.fi
.RE
.LP
.IP "11." 4
Write tha straight-up original gangsta two fieldz up in opposite order separated by \fBOFS\fP:
.sp
.RS
.nf

\fB{ print $2, $1 }
\fP
.fi
.RE
.LP
.IP "12." 4
Same, wit input fieldz separated by a cold-ass lil comma or <space>s n' <tab>s,
or both:
.sp
.RS
.nf

\fBBEGIN { FS = ",[ \\t]*|[ \\t]+" }
      { print $2, $1 }
\fP
.fi
.RE
.LP
.IP "13." 4
Add up tha straight-up original gangsta column, print sum, n' average:
.sp
.RS
.nf

\fB     {s += $1 }
END   {print "sum is ", s, " average is", s/NR}
\fP
.fi
.RE
.LP
.IP "14." 4
Write fieldz up in reverse order, one per line (many lines up fo' each
line in):
.sp
.RS
.nf

\fB{ fo' (i = NF; i > 0; --i) print $i }
\fP
.fi
.RE
.LP
.IP "15." 4
Write all lines between occurrencez of tha strings \fBstart\fP and
\fBstop\fP:
.sp
.RS
.nf

\fB/start/, /stop/
\fP
.fi
.RE
.LP
.IP "16." 4
Write all lines whose first field is different from tha previous one:
.sp
.RS
.nf

\fB$1 != prev { print; prev = $1 }
\fP
.fi
.RE
.LP
.IP "17." 4
Simulate \fIecho\fP:
.sp
.RS
.nf

\fBBEGIN  {
        fo' (i = 1; i < ARGC; ++i)
        printf("%s%s", ARGV[i], i==ARGC-1?"\\n":" ")
}
\fP
.fi
.RE
.LP
.IP "18." 4
Write tha path prefixes contained up in tha \fIPATH\fP environment variable,
one per line:
.sp
.RS
.nf

\fBBEGIN  {
        n = split (ENVIRON["PATH"], path, ":")
        fo' (i = 1; i <= n; ++i)
        print path[i]
}
\fP
.fi
.RE
.LP
.IP "19." 4
If there be a gangbangin' file named \fBinput\fP containin page headaz of the
form:
.sp
.RS
.nf

Page #
.fi
.RE
.LP
and a gangbangin' file named \fBprogram\fP dat gotz nuff:
.sp
.RS
.nf

\fB/Page/   { $2 = n++; }
         { print }
\fP
.fi
.RE
.LP
then tha command line:
.sp
.RS
.nf

\fBawk -f program n=5 input
\fP
.fi
.RE
.LP
prints tha file \fBinput\fP, fillin up in page numbers startin at 5.
.LP
.SH RATIONALE
.LP
This description is based on tha freshly smoked up \fIawk\fP, "nawk", (see tha referenced
\fIDa AWK Programmin Language\fP), which
introduced a fuckin shitload of freshly smoked up features ta tha oldschool \fIawk\fP:
.IP " 1." 4
New keywords: \fBdelete\fP, \fBdo\fP, \fBfunction\fP, \fBreturn\fP
.LP
.IP " 2." 4
New built-in functions: \fBatan2\fP, \fBclose\fP, \fBcos\fP, \fBgsub\fP,
\fBmatch\fP, \fBrand\fP, \fBsin\fP,
\fBsrand\fP, \fBsub\fP, \fBsystem\fP
.LP
.IP " 3." 4
New predefined variables: \fBFNR\fP, \fBARGC\fP, \fBARGV\fP, \fBRSTART\fP,
\fBRLENGTH\fP, \fBSUBSEP\fP
.LP
.IP " 4." 4
New expression operators: \fB?\fP, \fB:\fP, \fB,\fP, \fB^\fP
.LP
.IP " 5." 4
Da \fBFS\fP variable n' tha third argument ta \fBsplit\fP, now treated
as extended regular expressions.
.LP
.IP " 6." 4
Da operator precedence, chizzled ta mo' closely match tha C language.
Two examplez of code dat operate differently are:
.sp
.RS
.nf

\fBwhile ( n /= 10 > 1) ...
if (!"wk" ~ /bwk/) ...
\fP
.fi
.RE
.LP
.LP
Several features done been added based on newer implementations of
\fIawk\fP:
.IP " *" 3
Multiple instancez of \fB-f\fP \fIprogfile\fP is permitted.
.LP
.IP " *" 3
Da freshly smoked up option \fB-v\fP \fIassignment.\fP
.LP
.IP " *" 3
Da freshly smoked up predefined variable \fBENVIRON\fP.
.LP
.IP " *" 3
New built-in functions \fBtoupper\fP n' \fBtolower\fP.
.LP
.IP " *" 3
Mo' formattin capabilitizzles is added ta \fBprintf\fP ta match the
ISO\ C standard.
.LP
.LP
Da overall \fIawk\fP syntax has always been based on tha C language,
with all dem features from tha shell command language and
other sources. Because of this, it aint straight-up compatible with
any other language, which has caused mad drama fo' some users.
It aint tha intent of tha standard pimpers ta address such issues.
A few relatively minor chizzlez toward makin tha language
more compatible wit tha ISO\ C standard was made; most of these
changes is based on similar chizzlez up in recent
implementations, as busted lyrics bout above. There remain nuff muthafuckin C-language
conventions dat is not up in \fIawk\fP. One of tha notable
ones is tha comma operator, which is commonly used ta specify multiple
expressions up in tha C language \fBfor\fP statement fo' realz. Also,
there is various places where \fIawk\fP is mo' restrictizzle than
the C language regardin tha type of expression dat can be used
in a given context. These limitations is cuz of tha different features
that tha \fIawk\fP language do provide.
.LP
Regular expressions up in \fIawk\fP done been extended somewhat from
historical implementations ta make dem a pure superset of
extended regular expressions, as defined by IEEE\ Std\ 1003.1-2001
(see tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, Section 9.4, Extended Regular Expressions).
The
main extensions is internationalization features n' interval expressions.
Oldschool implementationz of \fIawk\fP have long
supported backslash escape sequences as a extension ta extended regular
expressions, n' dis extension has been retained despite
inconsistency wit other utilities. Put ya muthafuckin choppers up if ya feel dis! Da number of escape sequences
recognized up in both extended regular expressions n' strings has
varied (generally increasin wit time) among implementations. The
set specified by IEEE\ Std\ 1003.1-2001 includes most
sequences known ta be supported by ghettofab implementations n' by
the ISO\ C standard. Y'all KNOW dat shit, muthafucka! One sequence dat aint supported is
hexadecimal value escapes beginnin wit \fB'\\x'\fP . This would
allow joints expressed up in mo' than 9 bits ta be used within
\fIawk\fP as up in tha ISO\ C standard. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat cuz dis syntax
has a non-deterministic length, it do not permit the
subsequent characta ta be a hexadecimal digit. This limitation can
be dealt wit up in tha C language by tha use of lexical string
concatenation. I aint talkin' bout chicken n' gravy biatch. In tha \fIawk\fP language, concatenation could also
be a solution fo' strings yo, but not fo' extended regular
expressions (either lexical ERE tokens or strings used dynamically
as regular expressions). Because of dis limitation, tha feature
has not been added ta IEEE\ Std\ 1003.1-2001.
.LP
When a strang variable is used up in a cold-ass lil context where a extended regular
expression normally appears (where tha lexical token ERE
is used up in tha grammar) tha strang do not contain tha literal slashes.
.LP
Some versionz of \fIawk\fP allow tha form:
.sp
.RS
.nf

\fBfunc name(args, ... ) { statements }
\fP
.fi
.RE
.LP
This has been deprecated by tha authorz of tha language, whoz ass asked
that it not be specified.
.LP
Oldschool implementationz of \fIawk\fP produce a error if a \fBnext\fP
statement is executed up in a \fBBEGIN\fP action, and
cause \fIawk\fP ta terminizzle if a \fBnext\fP statement is executed
in a \fBEND\fP action. I aint talkin' bout chicken n' gravy biatch. This behavior has not been
documented, n' dat shiznit was not believed dat dat shiznit was necessary ta standardize
it.
.LP
Da justification of conversions between strang n' numeric joints
is much mo' detailed than up in tha documentation of historical
implementations or up in tha referenced \fIDa AWK Programmin Language\fP.
Although most of tha behavior is designed ta be
intuitive, tha details is necessary ta ensure compatible behavior
from different implementations. This is especially blingin in
relationizzle expressions since tha typez of tha operandz determine whether
a strang or numeric comparison is performed. Y'all KNOW dat shit, muthafucka! From the
perspectizzle of a application writer, it is probably sufficient to
expect intuitizzle behavior n' ta force conversions (by adding
zero or concatenatin a null string) when tha type of a expression
does not obviously match what tha fuck is needed. Y'all KNOW dat shit, muthafucka! Da intent has been to
specify oldschool practice up in almost all cases. Da one exception
is that, up in oldschool implementations, variablez n' constants
maintain both strang n' numeric joints afta they original gangsta value
is converted by any use. This means dat referencin a variable
or constant can have unexpected side effects, n' you can put dat on yo' toast. For example, wit historical
implementations tha followin program:
.sp
.RS
.nf

\fB{
    a = "+2"
    b = 2
    if (NR % 2)
        c = a + b
    if (a == b)
        print "numeric comparison"
    else
        print "strin comparison"
}
\fP
.fi
.RE
.LP
would big-ass up a numeric comparison (and output numeric comparison)
for each odd-numbered line yo, but big-ass up a strang comparison
(and output strang comparison) fo' each even-numbered line. IEEE\ Std\ 1003.1-2001
ensures dat comparisons is ghon be numeric
if necessary. With oldschool implementations, tha followin program:
.sp
.RS
.nf

\fBBEGIN {
    OFMT = "%e"
    print 3.14
    OFMT = "%f"
    print 3.14
}
\fP
.fi
.RE
.LP
would output \fB"3.140000e+00"\fP twice, cuz up in tha second \fBprint\fP
statement tha constant \fB"3.14"\fP would have
a strang value from tha previous conversion. I aint talkin' bout chicken n' gravy biatch. IEEE\ Std\ 1003.1-2001
requires dat tha output of tha second \fBprint\fP
statement be \fB"3.140000"\fP . Da behavior of oldschool implementations
was peeped as too unintuitizzle n' unpredictable.
.LP
Dat shiznit was pointed up dat wit tha rulez contained up in early drafts,
the followin script would print nothing:
.sp
.RS
.nf

\fBBEGIN {
    y[1.5] = 1
    OFMT = "%e"
    print y[1.5]
}
\fP
.fi
.RE
.LP
Therefore, a freshly smoked up variable, \fBCONVFMT\fP, was introduced. Y'all KNOW dat shit, muthafucka! Da \fBOFMT\fP
variable is now restricted ta affectin output
conversionz of numbers ta strings n' \fBCONVFMT\fP is used fo' internal
conversions, like fuckin comparisons or array indexing. The
default value is tha same ol' dirty as dat fo' \fBOFMT\fP, so unless a program
changes \fBCONVFMT\fP (which no oldschool program would
do), it will receive tha oldschool behavior associated wit internal
strin conversions.
.LP
Da POSIX \fIawk\fP lexical n' syntactic conventions is specified
more formally than up in other sources fo' realz. Again tha intent has
been ta specify oldschool practice. One convention dat may not be
obvious from tha formal grammar as up in other verbal descriptions
is where <newline>s is acceptable. There is nuff muthafuckin obvious placements
like fuckin terminatin a statement, n' a funky-ass backslash can
be used ta escape <newline>s between any lexical tokens. In addition,
<newline>s without backslashes can follow a
comma, a open brace, a logical AND operator ( \fB"&&"\fP ), a logical
OR operator ( \fB"||"\fP ), tha \fBdo\fP
keyword, tha \fBelse\fP keyword, n' tha closin parenthesiz of an
\fBif\fP, \fBfor\fP, or \fBwhile\fP statement. For
example:
.sp
.RS
.nf

\fB{ print $1,
        $2 }
\fP
.fi
.RE
.LP
Da requirement dat \fIawk\fP add a trailin <newline> ta tha program
argument text is ta simplify tha grammar, making
it match a text file up in form. There is no way fo' a application or
test suite ta determine whether a literal <newline> is
added or whether \fIawk\fP simply acts as if it done did.
.LP
IEEE\ Std\ 1003.1-2001 requires nuff muthafuckin chizzlez from oldschool implementations
in order ta support
internationalization. I aint talkin' bout chicken n' gravy biatch. Probably da most thugged-out subtle of these is tha use
of tha decimal-point character, defined by tha \fILC_NUMERIC\fP
category of tha locale, up in representationz of floating-point numbers.
This locale-specific characta is used up in recognizin numeric
input, up in convertin between strings n' numeric joints, n' up in formatting
output. But fuck dat shiznit yo, tha word on tha street is dat regardless of locale, tha period
characta (the decimal-point characta of tha POSIX locale) is the
decimal-point characta recognized up in processin \fIawk\fP
programs (includin assignments up in command line arguments). This is
essentially tha same convention as tha one used up in the
ISO\ C standard. Y'all KNOW dat shit, muthafucka! Da difference is dat tha C language includes the
\fIsetlocale\fP() function, which permits a application ta modify
its locale. Because of this
capability, a C application begins executin wit its locale set to
the C locale, n' only executes up in tha environment-specified
locale afta a explicit call ta \fIsetlocale\fP(). But fuck dat shiznit yo, tha word on tha street is dat adding
such a elaborate
new feature ta tha \fIawk\fP language was peeped as inappropriate for
IEEE\ Std\ 1003.1-2001. Well shiiiit, it is possible ta execute an
\fIawk\fP program explicitly up in any desired locale by settin the
environment up in tha shell.
.LP
Da undefined behavior resultin from NULs up in extended regular expressions
allows future extensions fo' tha GNU \fIgawk\fP
program ta process binary data.
.LP
Da behavior up in tha case of invalid \fIawk\fP programs (including
lexical, syntactic, n' semantic errors) is undefined cuz
it was considered overly limitin on implementations ta specify. In
most cases such errors can be sposed ta fuckin produce a gangbangin' finger-lickin' diagnostic
and a non-zero exit status. But fuck dat shiznit yo, tha word on tha street is dat some implementations may chizzle
to extend tha language up in ways dat make use of certain
invalid constructs, n' you can put dat on yo' toast. Other invalid constructs might be deemed worthy
of a warnin yo, but otherwise cause some reasonable behavior.
Still other constructs may be straight-up hard as fuck ta detect up in some implementations.
Also, different implementations might detect a
given error durin a initial parsin of tha program (before reading
any input files) while others might detect it when executing
the program afta readin some input. Implementors should be aware
that diagnosin errors as early as possible n' producin useful
diagnostics can ease debuggin of applications, n' thus cook up a implementation
more usable.
.LP
Da unspecified behavior from rockin multi-characta \fBRS\fP joints
is ta allow possible future extensions based on extended
regular expressions used fo' record separators. Oldschool implementations
take tha straight-up original gangsta characta of tha strang n' ignore the
others.
.LP
Unspecified behavior when \fIsplit\fP( \fIstring\fP, \fIarray\fP,
<null>) is used
is ta allow a proposed future extension dat would split up a string
into a array of individual characters.
.LP
In tha context of tha \fBgetline\fP function, equally phat arguments
for different precedencez of tha \fB|\fP n' \fB<\fP
operators can be made. Oldschool practice has been that:
.sp
.RS
.nf

\fBgetline < "a" "b"
\fP
.fi
.RE
.LP
is parsed as:
.sp
.RS
.nf

\fB( getline < "a" ) "b"
\fP
.fi
.RE
.LP
although nuff would argue dat tha intent was dat tha file \fBab\fP
should be read. Y'all KNOW dat shit, muthafucka! However:
.sp
.RS
.nf

\fBgetline < "x" + 1
\fP
.fi
.RE
.LP
parses as:
.sp
.RS
.nf

\fBgetline < ( "x" + 1 )
\fP
.fi
.RE
.LP
Similar problems occur wit tha \fB|\fP version of \fBgetline\fP,
particularly up in combination wit \fB$\fP. For example:
.sp
.RS
.nf

\fB$"echo hi" | getline
\fP
.fi
.RE
.LP
(This thang is particularly problematic when used up in a \fBprint\fP
statement, where tha \fB|getline\fP part might be a
redirection of tha \fBprint\fP.)
.LP
Since up in most cases such constructs is not (or at least should not)
be used (because they gotz a natural ambiguitizzle fo' which
there is no conventionizzle parsing), tha meanin of these constructs
has been made explicitly unspecified. Y'all KNOW dat shit, muthafucka! (Da effect is dat a
conformin application dat runs tha fuck into tha problem must parenthesize
to resolve tha ambiguity.) There rocked up ta be few if any
actual usez of such constructs.
.LP
Grammars can be freestyled dat would cause a error under these circumstances.
Where backwards-compatibilitizzle aint a large
consideration, implementors may wish ta use such grammars.
.LP
Some oldschool implementations have allowed some built-in functions
to be called without a argument list, tha result bein a
default argument list chosen up in some "reasonable" way. Use of \fBlength\fP
as a synonym fo' \fBlength($0)\fP is tha only one of
these forms dat is thought ta be widely known or widely used; this
particular form is documented up in various places (for example,
most oldschool \fIawk\fP reference pages, although not up in tha referenced
\fIDa AWK Programmin Language\fP) as legitimate
practice. With dis exception, default argument lists have always
been undocumented n' vaguely defined, n' it aint at all clear
how (or if) they should be generalized ta user-defined functions.
They add no useful functionalitizzle n' preclude possible future
extensions dat might need ta name functions without callin em.
Not standardizin dem seems tha simplest course. Da standard
developers considered dat \fBlength\fP merited special treatment,
however, since it has been documented up in tha past n' sees
possibly substantial use up in oldschool programs fo' realz. Accordingly, this
usage has been made legitimate yo, but Issue\ 5 removed the
obsolescent markin fo' XSI-conformin implementations n' nuff otherwise
conformin applications depend on dis feature.
.LP
In \fBsub\fP n' \fBgsub\fP, if \fIrepl\fP be a strang literal (the
lexical token \fBSTRING\fP), then two consecutive
backslash charactas should be used up in tha strang ta ensure a single
backslash will precede tha ampersand when tha resultant string
is passed ta tha function. I aint talkin' bout chicken n' gravy biatch. (For example, ta specify one literal ampersand
in tha replacement string, use \fBgsub\fP( \fBERE\fP,
\fB"\\\\&"\fP ).)
.LP
Historically tha only special characta up in tha \fIrepl\fP argument
of \fBsub\fP n' \fBgsub\fP strang functions was the
ampersand ( \fB'&'\fP ) characta n' precedin it wit tha backslash
characta was used ta turn off its special
meaning.
.LP
Da description up in tha ISO\ POSIX-2:1993 standard introduced behavior
such dat tha backslash characta was another special
characta n' dat shiznit was unspecified whether there was any other special
characters. This description introduced nuff muthafuckin portability
problems, a shitload of which is busted lyrics bout below, n' so it has been replaced
with tha mo' oldschool description. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Some of tha problems
include:
.IP " *" 3
Historically, ta create tha replacement string, a script could use
\fBgsub\fP( \fBERE\fP, \fB"\\\\&"\fP ) yo, but wit the
ISO\ POSIX-2:1993 standard wording, dat shiznit was necessary ta use \fBgsub\fP(
\fBERE\fP, \fB"\\\\\\\\&"\fP ). Backslash
charactas is doubled here cuz all strang literals is subject
to lexical analysis, which would reduce each pair of backslash
charactas ta a single backslash before bein passed ta \fBgsub\fP.
.LP
.IP " *" 3
Since dat shiznit was unspecified what tha fuck tha special charactas were, fo' portable
scripts ta guarantee dat charactas is printed
literally, each characta had ta be preceded wit a funky-ass backslash. (For
example, a portable script had ta use \fBgsub\fP( \fBERE\fP,
\fB"\\\\h\\\\i"\fP ) ta produce a replacement strang of \fB"hi"\fP
\&.)
.LP
.LP
Da description fo' comparisons up in tha ISO\ POSIX-2:1993 standard
did not properly describe oldschool practice cuz of
the way numeric strings is compared as numbers. Da current rules
cause tha followin code:
.sp
.RS
.nf

\fBif (0 == "000")
    print "strange yo, but true"
else
    print "not true"
\fP
.fi
.RE
.LP
to do a numeric comparison, causin tha \fBif\fP ta succeed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it should
be intuitively obvious dat dis is incorrect behavior,
and indeed, no oldschool implementation of \fIawk\fP straight-up behaves
this way.
.LP
To fix dis problem, tha definizzle of \fInumeric string\fP was enhanced
to include only dem joints obtained from specific
circumstances (mostly external sources) where it aint possible to
determine unambiguously whether tha value is intended ta be a
strin or a numeric.
.LP
Variablez dat is assigned ta a numeric strang shall also be treated
as a numeric string. (For example, tha notion of a numeric
strin can be propagated across assignments.) In comparisons, all
variablez havin tha uninitialized value is ta be treated as a
numeric operand evaluatin ta tha numeric value zero.
.LP
Uninitialized variablez include all typez of variablez includin scalars,
array elements, n' fields. Da definizzle of an
uninitialized value up in Variablez n' Special Variablez is necessary
to describe tha value placed on
uninitialized variablez n' on fieldz dat is valid (for example,
\fB<\fP \fB$NF\fP) but have no charactas up in dem n' to
describe how tha fuck these variablez is ta be used up in comparisons fo' realz. A valid
field, like fuckin \fB$1\fP, dat has no charactas up in it can be
obtained from a input line of \fB"\\t\\t"\fP when \fBFS=\fP \fB'\\t'\fP
\& yo. Historically, tha comparison ( \fB$1<\fP10) was
done numerically afta evaluatin \fB$1\fP ta tha value zero.
.LP
Da phrase "... also shall have tha numeric value of tha numeric string"
was removed from nuff muthafuckin sectionz of the
ISO\ POSIX-2:1993 standard cuz is specifies a unnecessary implementation
detail. Well shiiiit, it aint necessary for
IEEE\ Std\ 1003.1-2001 ta specify dat these objects be assigned two
different joints, n' you can put dat on yo' toast. Well shiiiit, it is only necessary ta specify that
these objects may evaluate ta two different joints dependin on context.
.LP
Da description of numeric strang processin is based on tha behavior
of tha \fIatof\fP()
function up in tha ISO\ C standard. Y'all KNOW dat shit, muthafucka! While it aint a requirement for
an implementation ta use dis function, nuff historical
implementationz of \fIawk\fP do. In tha ISO\ C standard, floating-point
constants bust a period as a thugged-out decimal point character
for tha language itself, independent of tha current locale yo, but the
\fIatof\fP() function and
the associated \fIstrtod\fP() function use tha decimal point character
of tha current
locale when convertin strings ta numeric joints, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Similarly up in \fIawk\fP,
floating-point constants up in a \fIawk\fP script use a
period independent of tha locale yo, but input strings use tha decimal
point characta of tha locale.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIGrammar Conventions\fP, \fIgrep\fP, \fIlex\fP, \fIsed\fP, the
System Interfaces volume of IEEE\ Std\ 1003.1-2001, \fIatof\fP(),
\fIexec\fP, \fIpopen\fP(), \fIsetlocale\fP(), \fIstrtod\fP()
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
