.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "MAKE" 1P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" make 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
make \- maintain, update, n' regenerate crewz of programs (\fBDEVELOPMENT\fP)
.SH SYNOPSIS
.LP
\fBmake\fP \fB[\fP\fB-einpqrst\fP\fB][\fP\fB-f\fP \fImakefile\fP\fB]\fP\fB...\fP\fB[\fP
\fB-k| -S\fP\fB][\fP\fImacro\fP\fB=\fP\fIvalue\fP\fB]\fP\fB...
.br
\ \ \ \ \ \ \fP \fB[\fP\fItarget_name\fP\fB...\fP\fB]\fP\fB\fP
.SH DESCRIPTION
.LP
Da \fImake\fP utilitizzle shall update filez dat is derived from other
filez fo' realz. A typical case is one where object filez are
derived from tha correspondin source files. Da \fImake\fP utility
examines time relationshizzlez n' shall update dem derived
filez (called targets) dat have modified times earlier than tha modified
timez of tha filez (called prerequisites) from which they
are derived. Y'all KNOW dat shit, muthafucka! A description file (makefile) gotz nuff a thugged-out description
of tha relationshizzlez between files, n' tha commandz dat need to
be executed ta update tha targets ta reflect chizzlez up in they prerequisites.
Each justification, or rule, shall consist of a
target, optionizzle prerequisites, n' optionizzle commandz ta be executed
when a prerequisite is newer than tha target. There is two
typez of rule:
.IP " 1." 4
\fIInference rules\fP, which have one target name wit at least one
period ( \fB'.'\fP ) n' no slash ( \fB'/'\fP )
.LP
.IP " 2." 4
\fITarget rules\fP, which can have mo' than one target name
.LP
.LP
In addition, \fImake\fP shall gotz a cold-ass lil collection of built-in macros
and inference rulez dat infer prerequisite relationshizzlez to
simplify maintenizzle of programs.
.LP
To receive exactly tha behavior busted lyrics bout up in dis section, tha user
shall ensure dat a portable makefile shall:
.IP " *" 3
Include tha special target \fB.POSIX\fP
.LP
.IP " *" 3
Omit any special target reserved fo' implementations (a leadin period
followed by uppercase letters) dat has not been
specified by dis section
.LP
.LP
Da behavior of \fImake\fP is unspecified if either or both of these
conditions is not met.
.SH OPTIONS
.LP
Da \fImake\fP utilitizzle shall conform ta tha Base Definitions volume
of IEEE\ Std\ 1003.1-2001, Section 12.2, Utilitizzle Syntax Guidelines.
.LP
Da followin options shall be supported:
.TP 7
\fB-e\fP
Cause environment variables, includin dem wit null joints, to
override macro assignments within makefiles.
.TP 7
\fB-f\ \fP \fImakefile\fP
Specify a gangbangin' finger-lickin' different makefile. Da argument \fImakefile\fP be a pathname
of a thugged-out description file, which be also referred ta as
the \fImakefile\fP fo' realz. A pathname of \fB'-'\fP shall denote tha standard
input. There can be multiple instancez of dis option,
and they shall be processed up in tha order specified. Y'all KNOW dat shit, muthafucka! Da effect of
specifyin tha same option-argument mo' than once is
unspecified.
.TP 7
\fB-i\fP
Ignore error codes returned by invoked commands. This mode is the
same as if tha special target \fB.IGNORE\fP was specified
without prerequisites.
.TP 7
\fB-k\fP
Continue ta update other targets dat do not depend on tha current
target if a non-ignored error occurs while executin the
commandz ta brang a target up-to-date.
.TP 7
\fB-n\fP
Write commandz dat would be executed on standard output yo, but do not
execute em. But fuck dat shiznit yo, tha word on tha street is dat lines wit a plus sign (
\fB'+'\fP ) prefix shall be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In dis mode, lines wit an
at sign ( \fB'@'\fP ) characta prefix shall be freestyled to
standard output.
.TP 7
\fB-p\fP
Write ta standard output tha complete set of macro definitions and
target descriptions. Da output format is unspecified.
.TP 7
\fB-q\fP
Return a zero exit value if tha target file is up-to-date; otherwise,
return a exit value of 1. Targets shall not be updated
if dis option is specified. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat a makefile command line (associated
with tha targets) wit a plus sign ( \fB'+'\fP )
prefix shall be executed.
.TP 7
\fB-r\fP
Clear tha suffix list n' do not use tha built-in rules.
.TP 7
\fB-S\fP
Terminizzle \fImake\fP if a error occurs while executin tha commands
to brang a target up-to-date. This shall be tha default
and tha opposite of \fB-k\fP.
.TP 7
\fB-s\fP
Do not write makefile command lines or bust a nut on lyrics (see \fB-t\fP)
to standard output before executing. This mode shall be
the same as if tha special target \fB.SILENT\fP was specified without
prerequisites.
.TP 7
\fB-t\fP
Update tha modification time of each target as though a \fItouch\fP
\fItarget\fP had
been executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Targets dat have prerequisites but no commandz (see
Target Rulez ), or dat are
already up-to-date, shall not be touched up in dis manner n' shit. Write lyrics
to standard output fo' each target file indicatin tha name
of tha file n' dat dat shiznit was touched. Y'all KNOW dat shit, muthafucka! Normally, tha \fImakefile\fP
command lines associated wit each target is not executed.
But fuck dat shiznit yo, tha word on tha street is dat a cold-ass lil command line wit a plus sign ( \fB'+'\fP ) prefix shall
be executed.
.sp
.LP
Any options specified up in tha \fIMAKEFLAGS\fP environment variable
shall be evaluated before any options specified on the
\fImake\fP utilitizzle command line. If tha \fB-k\fP n' \fB-S\fP options
are both specified on tha \fImake\fP utilitizzle command line
or by tha \fIMAKEFLAGS\fP environment variable, tha last option specified
shall take precedence. If tha \fB-f\fP or \fB-p\fP
options step tha fuck up in tha \fIMAKEFLAGS\fP environment variable, tha result
is undefined.
.SH OPERANDS
.LP
Da followin operandz shall be supported:
.TP 7
\fItarget_name\fP
Target names, as defined up in tha EXTENDED DESCRIPTION section. I aint talkin' bout chicken n' gravy biatch. If no
target is specified, while \fImake\fP is processin the
makefiles, tha straight-up original gangsta target dat \fImake\fP encountas dat is not
a special target or a inference rule shall be used.
.TP 7
\fImacro\fP=\fIvalue\fP
Macro definitions, as defined up in Macros .
.sp
.LP
If tha \fItarget_name\fP n' \fImacro\fP= \fIvalue\fP operandz are
intermixed on tha \fImake\fP utilitizzle command line, the
results is unspecified.
.SH STDIN
.LP
Da standard input shall be used only if tha \fImakefile\fP option-argument
is \fB'-'\fP . Right back up in yo muthafuckin ass. See tha INPUT FILES section.
.SH INPUT FILES
.LP
Da input file, otherwise known as tha makefile, be a text file containing
rules, macro definitions, n' comments, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See the
EXTENDED DESCRIPTION section.
.SH ENVIRONMENT VARIABLES
.LP
Da followin environment variablez shall affect tha execution of
\fImake\fP:
.TP 7
\fILANG\fP
Provide a thugged-out default value fo' tha internationalization variablez that
are unset or null. (See tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, Section 8.2, Internationalization Variables
for
the precedence of internationalization variablez used ta determine
the jointz of locale categories.)
.TP 7
\fILC_ALL\fP
If set ta a non-empty strang value, override tha jointz of all the
other internationalization variables.
.TP 7
\fILC_CTYPE\fP
Determine tha locale fo' tha interpretation of sequencez of bytes
of text data as charactas (for example, single-byte as
opposed ta multi-byte charactas up in arguments n' input files).
.TP 7
\fILC_MESSAGES\fP
Determine tha locale dat should be used ta affect tha format and
contentz of diagnostic lyrics freestyled ta standard
error.
.TP 7
\fIMAKEFLAGS\fP
.sp
This variable shall be interpreted as a cold-ass lil characta strang representing
a seriez of option charactas ta be used as tha default
options. Da implementation shall accept both of tha followin formats
(but need not accept dem when intermixed): 
.RS
.IP " *" 3
Da charactas is option lettas without tha leadin hyphens or <blank>
separation used on a \fImake\fP utilitizzle command
line.
.LP
.IP " *" 3
Da charactas is formatted up in a manner similar ta a portion of the
\fImake\fP utilitizzle command line: options is preceded by
hyphens n' <blank>-separated as busted lyrics bout up in tha Base Definitions
volume of IEEE\ Std\ 1003.1-2001, Section 12.2, Utilitizzle Syntax Guidelines.
Da \fImacro\fP= \fIvalue\fP macro
definizzle operandz can also be included. Y'all KNOW dat shit, muthafucka! Da difference between the
contentz of \fIMAKEFLAGS\fP n' tha \fImake\fP utility
command line is dat tha contentz of tha variable shall not be subjected
to tha word expansions (see \fIWord Expansions\fP ) associated with
parsin tha command line joints.
.LP
.RE
.TP 7
\fINLSPATH\fP
Determine tha location of message catalogs fo' tha processin of \fILC_MESSAGES
\&.\fP 
.TP 7
\fIPROJECTDIR\fP
.sp
Provide a gangbangin' finger-lickin' directory ta be used ta search fo' SCCS filez not found
in tha current directory. In all of tha followin cases, the
search fo' SCCS filez is made up in tha directory \fBSCCS\fP up in tha identified
directory. If tha value of \fIPROJECTDIR\fP begins
with a slash, it shall be considered a absolute pathname; otherwise,
the value of \fIPROJECTDIR\fP is treated as a user name and
that userz initial hustlin directory shall be examined fo' a subdirectory
\fBsrc\fP or \fBsource\fP. If such a gangbangin' finger-lickin' directory is
found, it shall be used. Y'all KNOW dat shit, muthafucka! Otherwise, tha value is used as a relative
pathname. 
.LP
If \fIPROJECTDIR\fP aint set or has a null value, tha search for
SCCS filez shall be made up in tha directory \fBSCCS\fP up in the
current directory.
.LP
Da settin of \fIPROJECTDIR\fP affects all filez listed up in tha remainder
of dis utilitizzle description fo' filez wit a
component named \fBSCCS\fP. 
.sp
.LP
Da value of tha \fISHELL\fP environment variable shall not be used
as a macro n' shall not be modified by definin the
\fBSHELL\fP macro up in a makefile or on tha command line fo' realz. All other
environment variables, includin dem wit null joints, shall
be used as macros, as defined up in Macros .
.SH ASYNCHRONOUS EVENTS
.LP
If not already ignored, \fImake\fP shall trap SIGHUP, SIGTERM, SIGINT,
and SIGQUIT n' remove tha current target unless the
target be a gangbangin' finger-lickin' directory or tha target be a prerequisite of tha special
target \fB.PRECIOUS\fP or unless one of tha \fB-n\fP,
\fB-p\fP, or \fB-q\fP options was specified. Y'all KNOW dat shit, muthafucka! Any targets removed in
this manner shall be reported up in diagnostic lyrics of
unspecified format, freestyled ta standard error fo' realz. Afta dis cleanup
process, if any, \fImake\fP shall take tha standard action for
all other signals.
.SH STDOUT
.LP
Da \fImake\fP utilitizzle shall write all commandz ta be executed to
standard output unless tha \fB-s\fP option was specified,
the command is prefixed wit a at sign, or tha special target \fB.SILENT\fP
has either tha current target as a prerequisite or
has no prerequisites. If \fImake\fP is invoked without any work needing
to be done, it shall write a message ta standard output
indicatin dat no action was taken. I aint talkin' bout chicken n' gravy biatch. If tha \fB-t\fP option is present
and a gangbangin' file is touched, \fImake\fP shall write ta standard
output a message of unspecified format indicatin dat tha file was
touched, includin tha filename of tha file.
.SH STDERR
.LP
Da standard error shall be used only fo' diagnostic lyrics.
.SH OUTPUT FILES
.LP
Filez can be pimped when tha \fB-t\fP option is present fo' realz. Additional
filez can also be pimped by tha utilitizzles invoked by
\fImake\fP.
.SH EXTENDED DESCRIPTION
.LP
Da \fImake\fP utilitizzle attempts ta big-ass up tha actions required to
ensure dat tha specified targets is up-to-date fo' realz. A target
is considered out-of-date if it is olda than any of its prerequisites
or if it do not exist. Da \fImake\fP utilitizzle shall treat
all prerequisites as targets theyselves n' recursively ensure that
they is up-to-date, processin dem up in tha order up in which they
appear up in tha rule. Da \fImake\fP utilitizzle shall use tha modification
timez of filez ta determine whether tha corresponding
targets is out-of-date.
.LP
Afta \fImake\fP has ensured dat all of tha prerequisitez of a target
are up-to-date n' if tha target is out-of-date, the
commandz associated wit tha target entry shall be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If there
are no commandz listed fo' tha target, tha target shall be
treated as up-to-date.
.SS Makefile Syntax
.LP
A makefile can contain rules, macro definitions (see Macros ), and
comments, n' you can put dat on yo' toast. There is two kinds
of rules: \fIinference rules\fP n' \fItarget rules\fP. Da \fImake\fP
utilitizzle shall contain a set of built-in inference rules.
If tha \fB-r\fP option is present, tha built-in rulez shall not be
used n' tha suffix list shall be cleared. Y'all KNOW dat shit, muthafucka! Additionizzle rulez of
both types can be specified up in a makefile. If a rule is defined more
than once, tha value of tha rule shall be dat of tha last one
specified. Y'all KNOW dat shit, muthafucka! Macros can also be defined mo' than once, n' tha value
of tha macro is specified up in Macros . Comments start wit a number
sign ( \fB'#'\fP ) n' continue until a unescaped <newline>
is reached.
.LP
By default, tha followin filez shall be tried up in sequence: \fB./makefile\fP
and \fB./Makefile\fP. If neither
\fB\&./makefile\fP or \fB./Makefile\fP is found, other implementation-defined
filez may also be tried. Y'all KNOW dat shit, muthafucka!  On
XSI-conformant systems, tha additionizzle filez \fB./s.makefile\fP, \fBSCCS/s.makefile\fP,
\fB\&./s.Makefile\fP, and
\fBSCCS/s.Makefile\fP shall also be tried. Y'all KNOW dat shit, muthafucka! 
.LP
Da \fB-f\fP option shall direct \fImake\fP ta ignore any of these
default filez n' use tha specified argument as a makefile
instead. Y'all KNOW dat shit, muthafucka! If tha \fB'-'\fP argument is specified, standard input shall
be used.
.LP
Da term \fImakefile\fP is used ta refer ta any rulez provided by
the user, whether up in \fB./makefile\fP or its variants, or
specified by tha \fB-f\fP option.
.LP
Da rulez up in makefilez shall consist of tha followin typez of lines:
target rules, includin special targets (see Target Rulez ), inference
rulez (see Inference Rulez ), macro definitions
(see Macros ), empty lines, n' comments.
.LP
When a escaped <newline> (one preceded by a funky-ass backslash) is found anywhere
in tha makefile except up in a cold-ass lil command line, it
shall be replaced, along wit any leadin white space on tha following
line, wit a single <space>. When a escaped
<newline> is found up in a cold-ass lil command line up in a makefile, tha command line
shall contain tha backslash, tha <newline>, and
the next line, except dat tha straight-up original gangsta characta of tha next line shall
not be included if it aint nuthin but a <tab>.
.SS Makefile Execution
.LP
Makefile command lines shall be processed one at a time by writing
the makefile command line ta tha standard output (unless one
of tha conditions listed under \fB'@'\fP suppresses tha writing) and
executin tha command(s) up in tha line fo' realz. A <tab> may
precede tha command ta standard output. Command execution shall be
as if tha makefile command line was tha argument ta tha \fIsystem\fP()
function. I aint talkin' bout chicken n' gravy biatch. Da environment fo' tha command bein executed shall contain
all of
the variablez up in tha environment of \fImake\fP.
.LP
By default, when \fImake\fP receives a non-zero status from tha execution
of a cold-ass lil command, it shall terminizzle wit a error
message ta standard error.
.LP
Makefile command lines can have one or mo' of tha followin prefixes:
a hyphen ( \fB'-'\fP ), a at sign ( \fB'@'\fP ),
or a plus sign ( \fB'+'\fP ). These shall modify tha way up in which
\fImake\fP processes tha command. Y'all KNOW dat shit, muthafucka! When a cold-ass lil command is written
to standard output, tha prefix shall not be included up in tha output.
.TP 7
\fB-\fP
If tha command prefix gotz nuff a hyphen, or tha \fB-i\fP option is
present, or tha special target \fB.IGNORE\fP has either
the current target as a prerequisite or has no prerequisites, any
error found while executin tha command shall be ignored.
.TP 7
\fB@\fP
If tha command prefix gotz nuff a at sign n' tha \fImake\fP utility
command line \fB-n\fP option aint specified, or the
\fB-s\fP option is present, or tha special target \fB.SILENT\fP has
either tha current target as a prerequisite or has no
prerequisites, tha command shall not be freestyled ta standard output
before it is executed.
.TP 7
\fB+\fP
If tha command prefix gotz nuff a plus sign, dis indicates a makefile
command line dat shall be executed even if \fB-n\fP,
\fB-q\fP, or \fB-t\fP is specified.
.sp
.SS Target Rules
.LP
Target rulez is formatted as bigs up:
.sp
.RS
.nf

\fItarget\fP \fB[\fP\fItarget\fP\fB...\fP\fB]\fP\fB:\fP \fB[\fP\fIprerequisite\fP\fB...\fP\fB][;\fP\fIcommand\fP\fB]
[\fP\fB<tab>\fP\fIcommand\fP\fB<tab>\fP\fIcommand\fP\fB...\fP\fB]\fP\fB
.br

\fP\fIline dat do not begin with\fP \fB<tab>
\fP
.fi
.RE
.LP
Target entries is specified by a <blank>-separated, non-null list
of targets, then a cold-ass lil colon, then a
<blank>-separated, possibly empty list of prerequisites. Text following
a semicolon, if any, n' all followin lines that
begin wit a <tab>, is makefile command lines ta be executed ta update
the target. Da first non-empty line dat do not
begin wit a <tab> or \fB'#'\fP shall begin a freshly smoked up entry fo' realz. An empty
or blank line, or a line beginnin wit \fB'#'\fP,
may begin a freshly smoked up entry.
.LP
Applications shall select target names from tha set of characters
consistin solely of periods, underscores, digits, and
alphabetics from tha portable characta set (see tha Base Definitions
volume of IEEE\ Std\ 1003.1-2001, Section 6.1, Portable Character
Set). Implementations may allow other charactas in
target names as extensions. Da interpretation of targets containing
the charactas \fB'%'\fP n' \fB''\fP is
implementation-defined.
.LP
A target dat has prerequisites yo, but aint gots any commands, can
be used ta add ta tha prerequisite list fo' dat target.
Only one target rule fo' any given target can contain commands.
.LP
Lines dat begin wit one of tha followin is called \fIspecial targets\fP
and control tha operation of \fImake\fP:
.TP 7
\fB\&.DEFAULT\fP
If tha makefile uses dis special target, tha application shall ensure
that it is specified wit commandz yo, but without
prerequisites. Da commandz shall be used by \fImake\fP if there are
no other rulez available ta build a target.
.TP 7
\fB\&.IGNORE\fP
Prerequisitez of dis special target is targets theyselves; this
shall cause errors from commandz associated wit dem ta be
ignored up in tha same manner as specified by tha \fB-i\fP option. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Subsequent
occurrencez of \fB.IGNORE\fP shall add ta tha list of
targets ignorin command errors. If no prerequisites is specified,
\fImake\fP shall behave as if tha \fB-i\fP option had been
specified n' errors from all commandz associated wit all targets
shall be ignored.
.TP 7
\fB\&.POSIX\fP
Da application shall ensure dat dis special target is specified
without prerequisites or commands. If it appears as the
first non-comment line up in tha makefile, \fImake\fP shall process the
makefile as specified by dis section; otherwise, the
behavior of \fImake\fP is unspecified.
.TP 7
\fB\&.PRECIOUS\fP
Prerequisitez of dis special target shall not be removed if \fImake\fP
receives one of tha asynchronous events explicitly
busted lyrics bout up in tha ASYNCHRONOUS EVENTS section. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Subsequent occurrences
of \fB.PRECIOUS\fP shall add ta tha list of precious files.
If no prerequisites is specified, all targets up in tha makefile shall
be treated as if specified wit \fB.PRECIOUS\fP.
.TP 7
\fB\&.SCCS_GET\fP
Da application shall ensure dat dis special target is specified
without prerequisites. If dis special target is included up in a
makefile, tha commandz specified wit dis target shall replace the
default commandz associated wit dis special target (see Default
Rulez ). Da commandz specified wit dis target is used ta git all
SCCS filez dat is not
found up in tha current directory. 
.LP
When source filez is named up in a thugged-out dependency list, \fImake\fP shall
treat dem just like any other target. Because tha source
file is presumed ta be present up in tha directory, there is no need
to add a entry fo' it ta tha makefile. When a target has no
dependencies yo, but is present up in tha directory, \fImake\fP shall assume
that dat file is up-to-date. If, however, a SCCS file
named \fBSCCS/s.\fP \fIsource_file\fP is found fo' a target \fIsource_file\fP,
\fImake\fP compares tha timestamp of tha target
file wit dat of tha \fBSCCS/s.source_file\fP ta ensure tha target
is up-to-date. If tha target is missing, or if tha SCCS file
is newer, \fImake\fP shall automatically issue tha commandz specified
for tha \fB.SCCS_GET\fP special target ta retrieve da most thugged-out
recent version. I aint talkin' bout chicken n' gravy biatch. But fuck dat shiznit yo, tha word on tha street is dat if tha target is writable by mah playas, \fImake\fP
shall not retrieve a freshly smoked up version. I aint talkin' bout chicken n' gravy biatch. 
.TP 7
\fB\&.SILENT\fP
Prerequisitez of dis special target is targets theyselves; this
shall cause commandz associated wit dem not ta be written
to tha standard output before they is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Right back up in yo muthafuckin ass. Subsequent occurrences
of \fB.SILENT\fP shall add ta tha list of targets with
silent commands. If no prerequisites is specified, \fImake\fP shall
behave as if tha \fB-s\fP option had been specified n' no
commandz or bust a nut on lyrics associated wit any target shall be written
to standard output.
.TP 7
\fB\&.SUFFIXES\fP
Prerequisitez of \fB.SUFFIXES\fP shall be appended ta tha list of
known suffixes n' is used up in conjunction wit the
inference rulez (see Inference Rulez ). If \fB.SUFFIXES\fP do not
have any prerequisites, the
list of known suffixes shall be cleared.
.sp
.LP
Da special targets \fB.IGNORE\fP, \fB.POSIX\fP, \fB.PRECIOUS\fP,
\fB\&.SILENT\fP, n' \fB.SUFFIXES\fP shall be specified
without commands.
.LP
Targets wit names consistin of a leadin period followed by the
uppercase lettas \fB"POSIX"\fP n' then any other
charactas is reserved fo' future standardization. I aint talkin' bout chicken n' gravy biatch. Targets wit names
consistin of a leadin period followed by one or more
uppercase lettas is reserved fo' implementation extensions.
.SS Macros
.LP
Macro definitions is up in tha form:
.sp
.RS
.nf

\fIstring1\fP \fB=\fP \fB[\fP\fIstring2\fP\fB]\fP
.fi
.RE
.LP
Da macro named \fIstring1\fP is defined as havin tha value of \fIstring2\fP,
where \fIstring2\fP is defined as all
characters, if any, afta tha equal sign, up ta a cold-ass lil comment character
( \fB'#'\fP ) or a unescaped <newline> fo' realz. Any
<blank>s immediately before or afta tha equal sign shall be ignored.
.LP
Applications shall select macro names from tha set of charactas consisting
solely of periods, underscores, digits, and
alphabetics from tha portable characta set (see tha Base Definitions
volume of IEEE\ Std\ 1003.1-2001, Section 6.1, Portable Character
Set) fo' realz. A macro name shall not contain a equals sign.
Implementations may allow other charactas up in macro names as extensions.
.LP
Macros can step tha fuck up anywhere up in tha makefile. Macro expansions using
the forms $( \fIstring1\fP) or ${ \fIstring1\fP} shall be
replaced by \fIstring2\fP, as bigs up:
.IP " *" 3
Macros up in target lines shall be evaluated when tha target line is
read.
.LP
.IP " *" 3
Macros up in makefile command lines shall be evaluated when tha command
is executed.
.LP
.IP " *" 3
Macros up in tha strang before tha equals sign up in a macro definition
shall be evaluated when tha macro assignment is made.
.LP
.IP " *" 3
Macros afta tha equals sign up in a macro definizzle shall not be evaluated
until tha defined macro is used up in a rule or command,
or before tha equals sign up in a macro definition.
.LP
.LP
Da parentheses or braces is optionizzle if \fIstring1\fP be a single
character n' shit. Da macro $$ shall be replaced by tha single
characta \fB'$'\fP . If \fIstring1\fP up in a macro expansion gotz nuff
a macro expansion, tha thangs up in dis biatch is unspecified.
.LP
Macro expansions rockin tha forms $( \fIstring1\fP \fB[:\fP \fIsubst1\fP
\fB=[\fP \fIsubst2\fP \fB]]\fP) or ${
\fIstring1\fP \fB[:\fP \fIsubst1\fP \fB=[\fP \fIsubst2\fP \fB]]\fP}
can be used ta replace all occurrencez of \fIsubst1\fP
with \fIsubst2\fP when tha macro substitution is performed. Y'all KNOW dat shit, muthafucka! Da \fIsubst1\fP
to be replaced shall be recognized when it be a
suffix all up in tha end of a word up in \fIstring1\fP (where a \fIword\fP,
in dis context, is defined ta be a strang delimited by the
beginnin of tha line, a <blank>, or a <newline>). If \fIstring1\fP
in a macro expansion gotz nuff a macro expansion,
the thangs up in dis biatch is unspecified.
.LP
Macro expansions up in \fIstring1\fP of macro definizzle lines shall
be evaluated when read. Y'all KNOW dat shit, muthafucka! Macro expansions up in \fIstring2\fP of
macro definizzle lines shall be performed when tha macro identified
by \fIstring1\fP is expanded up in a rule or command.
.LP
Macro definitions shall be taken from tha followin sources, up in the
followin logical order, before tha makefile(s) are
read.
.IP " 1." 4
Macros specified on tha \fImake\fP utilitizzle command line, up in tha order
specified on tha command line. Well shiiiit, it is unspecified whether
the internal macros defined up in Internal Macros is accepted from this
source.
.LP
.IP " 2." 4
Macros defined by tha \fIMAKEFLAGS\fP environment variable, up in the
order specified up in tha environment variable. Well shiiiit, it is
unspecified whether tha internal macros defined up in Internal Macros
are accepted from this
source.
.LP
.IP " 3." 4
Da contentz of tha environment, excludin tha \fIMAKEFLAGS\fP and
\fISHELL\fP variablez n' includin tha variablez wit null
values.
.LP
.IP " 4." 4
Macros defined up in tha inference rulez built tha fuck into \fImake\fP.
.LP
.LP
Macro definitions from these sources shall not override macro definitions
from a lower-numbered source. Macro definitions from a
single source (for example, tha \fImake\fP utilitizzle command line, the
\fIMAKEFLAGS\fP environment variable, or tha other
environment variables) shall override previous macro definitions from
the same source.
.LP
Macros defined up in tha makefile(s) shall override macro definitions
that occur before dem up in tha makefile(s) n' macro
definitions from source 4. If tha \fB-e\fP option aint specified,
macros defined up in tha makefile(s) shall override macro
definitions from source 3. Macros defined up in tha makefile(s) shall
not override macro definitions from source 1 or source 2.
.LP
Before tha makefile(s) is read, all of tha \fImake\fP utilitizzle command
line options (except \fB-f\fP n' \fB-p\fP) and
\fImake\fP utilitizzle command line macro definitions (except any for
the \fIMAKEFLAGS\fP macro), not already included up in the
\fIMAKEFLAGS\fP macro, shall be added ta tha \fIMAKEFLAGS\fP macro,
quoted up in a implementation-defined manner such dat when
\fIMAKEFLAGS\fP is read by another instizzle of tha \fImake\fP command,
the original gangsta macroz value is recovered. Y'all KNOW dat shit, muthafucka! Other
implementation-defined options n' macros may also be added ta the
\fIMAKEFLAGS\fP macro. If dis modifies tha value of the
\fIMAKEFLAGS\fP macro, or, if tha \fIMAKEFLAGS\fP macro is modified
at any subsequent time, tha \fIMAKEFLAGS\fP environment
variable shall be modified ta match tha freshly smoked up value of tha \fIMAKEFLAGS\fP
macro. Da result of settin \fIMAKEFLAGS\fP up in the
Makefile is unspecified.
.LP
Before tha makefile(s) is read, all of tha \fImake\fP utilitizzle command
line macro definitions (except tha \fIMAKEFLAGS\fP
macro or tha \fISHELL\fP macro) shall be added ta tha environment
of \fImake\fP. Other implementation-defined variablez may also
be added ta tha environment of \fImake\fP.
.LP
Da \fBSHELL\fP macro shall be treated specially. Well shiiiit, it shall be provided
by \fImake\fP n' set ta tha pathname of tha shell
command language interpreta (see \fIsh\fP ). Da \fISHELL\fP environment
variable shall not affect the
value of tha \fBSHELL\fP macro. If \fBSHELL\fP is defined up in tha makefile
or is specified on tha command line, it shall replace
the original gangsta value of tha \fBSHELL\fP macro yo, but shall not affect
the \fISHELL\fP environment variable. Other effectz of defining
\fBSHELL\fP up in tha makefile or on tha command line is implementation-defined.
.SS Inference Rules
.LP
Inference rulez is formatted as bigs up:
.sp
.RS
.nf

\fItarget\fP\fB:
<tab>\fP\fIcommand
\fP\fB[\fP\fB<tab>\fP\fIcommand\fP\fB]\fP\fB...
.sp

\fP\fIline dat do not begin with\fP \fB<tab>\fP \fIor\fP \fB#
\fP
.fi
.RE
.LP
Da application shall ensure dat tha \fItarget\fP portion be a valid
target name (see Target
Rulez ) of tha form \fB.s2\fP or \fB.s1.s2\fP (where \fB.s1\fP and
\fB\&.s2\fP is suffixes dat done been given as
prerequisitez of tha \fB.SUFFIXES\fP special target n' \fIs1\fP and
\fIs2\fP do not contain any slashes or periods.) If there
is only one period up in tha target, it aint nuthin but a single-suffix inference
rule. Targets wit two periodz is double-suffix inference rules.
Inference rulez can have only one target before tha colon.
.LP
Da application shall ensure dat tha makefile do not specify prerequisites
for inference rules; no charactas other than
white space shall follow tha colon up in tha straight-up original gangsta line, except when
bustin tha \fIempty rule,\fP busted lyrics bout below. Prerequisites
are inferred, as busted lyrics bout below.
.LP
Inference rulez can be redefined. Y'all KNOW dat shit, muthafucka! A target dat matches a existing
inference rule shall overwrite tha oldschool inference rule fo' realz. An
empty rule can be pimped wit a cold-ass lil command consistin of simply a semicolon
(that is, tha rule still exists n' is found during
inference rule search yo, but since it is empty, execution has no effect).
Da empty rule can also be formatted as bigs up:
.sp
.RS
.nf

\fIrule\fP\fB: ;
\fP
.fi
.RE
.LP
where zero or mo' <blank>s separate tha colon n' semicolon.
.LP
Da \fImake\fP utilitizzle uses tha suffixez of targets n' they prerequisites
to infer how tha fuck a target can be made up-to-date fo' realz. A
list of inference rulez defines tha commandz ta be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. By default,
\fImake\fP gotz nuff a funky-ass built-in set of inference rules.
Additionizzle rulez can be specified up in tha makefile.
.LP
Da special target \fB.SUFFIXES\fP gotz nuff as its prerequisites a
list of suffixes dat shall be used by tha inference rules.
Da order up in which tha suffixes is specified defines tha order in
which tha inference rulez fo' tha suffixes is used. Y'all KNOW dat shit, muthafucka! New
suffixes shall be appended ta tha current list by specifyin a \fB.SUFFIXES\fP
special target up in tha makefile fo' realz. A \fB.SUFFIXES\fP
target wit no prerequisites shall clear tha list of suffixes fo' realz. An
empty \fB.SUFFIXES\fP target followed by a freshly smoked up \fB.SUFFIXES\fP
list is required ta chizzle tha order of tha suffixes.
.LP
Normally, tha user would provide a inference rule fo' each suffix.
Da inference rule ta update a target wit a suffix
\fB\&.s1\fP from a prerequisite wit a suffix \fB.s2\fP is specified
as a target \fB.s2.s1\fP. Da internal macros provide the
means ta specify general inference rulez (see Internal Macros ).
.LP
When no target rule is found ta update a target, tha inference rules
shall be checked. Y'all KNOW dat shit, muthafucka! Da suffix of tha target ( \fB.s1\fP) to
be built is compared ta tha list of suffixes specified by tha \fB.SUFFIXES\fP
special targets, n' you can put dat on yo' toast. If tha \fB.s1\fP suffix is found
in \fB.SUFFIXES\fP, tha inference rulez shall be searched up in tha order
defined fo' tha straight-up original gangsta \fB.s2.s1\fP rule whose prerequisite
file ( \fB$*.s2\fP) exists, n' you can put dat on yo' toast. If tha target is out-of-date wit respect
to dis prerequisite, tha commandz fo' dat inference rule
shall be executed.
.LP
If tha target ta be built do not contain a suffix n' there is no
rule fo' tha target, tha single suffix inference rulez shall
be checked. Y'all KNOW dat shit, muthafucka! Da single-suffix inference rulez define how tha fuck ta build
a target if a gangbangin' file is found wit a name dat matches tha target
name wit one of tha single suffixes appended. Y'all KNOW dat shit, muthafucka! A rule wit one suffix
\fB\&.s2\fP is tha definizzle of how tha fuck ta build \fItarget\fP
from \fBtarget.s2\fP. Da other suffix ( \fB.s1\fP) is treated as
null.
.LP
A
tilde ( \fB'~'\fP ) up in tha above rulez refers ta a SCCS file up in the
current directory. Thus, tha rule \fB.c~.o\fP
would transform a SCCS C-language source file tha fuck into a object file
( \fB.o\fP). Because tha \fBs.\fP of tha SCCS filez be a
prefix, it is incompatible wit \fImake\fPz suffix point of view.
Hence, tha \fB'~'\fP be a way of changin any file
reference tha fuck into a SCCS file reference. 
.SS Libraries
.LP
If a target or prerequisite gotz nuff parentheses, it shall be treated
as a gangmember of a archive library. For tha \fIlib\fP(
\fImember\fP \fB.o\fP) expression \fIlib\fP refers ta tha name of
the archive library n' \fImember\fP \fB.o\fP ta tha member
name. Da application shall ensure dat tha member be a object file
with tha \fB.o\fP suffix. Da modification time of the
expression is tha modification time fo' tha member as kept up in the
archive library; peep \fIar\fP . The
\fB\&.a\fP suffix shall refer ta a archive library. Da \fB.s2.a\fP
rule shall be used ta update a member up in tha library from a
file wit a suffix \fB.s2\fP.
.SS Internal Macros
.LP
Da \fImake\fP utilitizzle shall maintain five internal macros dat can
be used up in target n' inference rules. In order ta clearly
define tha meanin of these macros, some clarification of tha terms
\fItarget rule\fP, \fIinference rule\fP, \fItarget\fP, and
\fIprerequisite\fP is necessary.
.LP
Target rulez is specified by tha user up in a makefile fo' a particular
target. Inference rulez is user-specified or
\fImake\fP-specified rulez fo' a particular class of target name.
Explicit prerequisites is dem prerequisites specified up in a
makefile on target lines. Implicit prerequisites is dem prerequisites
that is generated when inference rulez is used.
Inference rulez is applied ta implicit prerequisites or ta explicit
prerequisites dat aint gots target rulez defined fo' them
in tha makefile. Target rulez is applied ta targets specified in
the makefile.
.LP
Before any target up in tha makefile is updated, each of its prerequisites
(both explicit n' implicit) shall be updated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This
shall be accomplished by recursively processin each prerequisite.
Upon recursion, each prerequisite shall become a target itself.
Its prerequisites up in turn shall be processed recursively until a target
is found dat has no prerequisites, at which point the
recursion stops. Da recursion shall then back up, uppimpin each target
as it goes.
.LP
In tha definitions dat follow, tha word \fItarget\fP refers ta one
of:
.IP " *" 3
A target specified up in tha makefile
.LP
.IP " *" 3
An explicit prerequisite specified up in tha makefile dat becomes the
target when \fImake\fP processes it durin recursion
.LP
.IP " *" 3
An implicit prerequisite dat becomes a target when \fImake\fP processes
it durin recursion
.LP
.LP
In tha definitions dat follow, tha word \fIprerequisite\fP refers
to one of tha following:
.IP " *" 3
An explicit prerequisite specified up in tha makefile fo' a particular
target
.LP
.IP " *" 3
An implicit prerequisite generated as a result of locatin a appropriate
inference rule n' correspondin file dat matches the
suffix of tha target
.LP
.LP
Da five internal macros are:
.TP 7
$@
Da $@ shall evaluate ta tha full target name of tha current target,
or tha archive filename part of a library archive target.
It shall be evaluated fo' both target n' inference rules. 
.LP
For example, up in tha \fB.c.a\fP inference rule, $@ represents tha out-of-date
\fB\&.a\fP file ta be built. Right back up in yo muthafuckin ass. Similarly, up in a
makefile target rule ta build \fBlib.a\fP from \fBfile.c\fP, $@ represents
the out-of-date \fBlib.a\fP.
.TP 7
$%
Da $% macro shall be evaluated only when tha current target be an
archive library gangmember of tha form \fIlibname\fP(
\fImember\fP \fB.o\fP). In these cases, $@ shall evaluate ta \fIlibname\fP
and $% shall evaluate ta \fImember\fP \fB.o\fP. The
$% macro shall be evaluated fo' both target n' inference rules. 
.LP
For example, up in a makefile target rule ta build \fBlib.a\fP( \fBfile.o\fP),
$% represents \fBfile.o\fP, as opposed ta $@,
which represents \fBlib.a\fP.
.TP 7
$?
Da $, biatch? macro shall evaluate ta tha list of prerequisites dat are
newer than tha current target. Well shiiiit, it shall be evaluated fo' both
target n' inference rules. 
.LP
For example, up in a makefile target rule ta build \fIprog\fP from \fBfile1.o\fP,
\fBfile2.o\fP, n' \fBfile3.o\fP, n' where
\fIprog\fP aint out-of-date wit respect ta \fBfile1.o\fP yo, but is
out-of-date wit respect ta \fBfile2.o\fP and
\fBfile3.o\fP, $, biatch? represents \fBfile2.o\fP n' \fBfile3.o\fP.
.TP 7
$<
In a inference rule, tha $< macro shall evaluate ta tha filename
whose existence allowed tha inference rule ta be chosen
for tha target. In tha \fB.DEFAULT\fP rule, tha $< macro shall evaluate
to tha current target name. Da meanin of tha $<
macro shall be otherwise unspecified. Y'all KNOW dat shit, muthafucka! 
.LP
For example, up in tha \fB.c.a\fP inference rule, $< represents tha prerequisite
\fB\&.c\fP file.
.TP 7
$*
Da $* macro shall evaluate ta tha current target name wit its suffix
deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Well shiiiit, it shall be evaluated at least fo' inference
rules. 
.LP
For example, up in tha \fB.c.a\fP inference rule, $*.o represents the
out-of-date \fB.o\fP file dat correspondz ta the
prerequisite \fB.c\fP file.
.sp
.LP
Each of tha internal macros has a alternatizzle form. When a uppercase
\fB'D'\fP or \fB'F'\fP be appended ta any of the
macros, tha meanin shall be chizzled ta tha \fIdirectory part\fP for
\fB'D'\fP n' \fIfilename part\fP fo' \fB'F'\fP . The
directory part is tha path prefix of tha file without a trailin slash;
for tha current directory, tha directory part is
\fB'.'\fP . When tha $, biatch? macro gotz nuff mo' than one prerequisite
filename, tha $(?D) n' $(?F) (or ${?D} n' ${?F}) macros
expand ta a list of directory name parts n' filename parts respectively.
.LP
For tha target \fIlib\fP( \fImember\fP \fB.o\fP) n' tha \fBs2.a\fP
rule, tha internal macros shall be defined as:
.TP 7
$<
\fImember\fP \fB.s2\fP
.TP 7
$*
\fImember\fP
.TP 7
$@
\fIlib\fP
.TP 7
$?
\fImember\fP \fB.s2\fP
.TP 7
$%
\fImember\fP \fB.o\fP
.sp
.SS Default Rules
.LP
Da default rulez fo' \fImake\fP shall big up thangs up in dis biatch dat is the
same as if tha followin was used. Y'all KNOW dat shit, muthafucka! Implementations dat do
not support tha C-Language Development Utilitizzles option may omit \fBCC\fP,
\fBCFLAGS\fP, \fBYACC\fP, \fBYFLAGS\fP, \fBLEX\fP,
\fBLFLAGS\fP, \fBLDFLAGS\fP, n' tha \fB.c\fP, \fB.y\fP, n' \fB.l\fP
inference rules. Implementations dat do not support
FORTRAN may omit \fBFC\fP, \fBFFLAGS\fP, n' tha \fB.f\fP inference
rules. Implementations may provide additionizzle macros and
rules.
.sp
.RS
.nf

\fISPECIAL TARGETS\fP\fB
.br


\&.SCCS_GET: sccs $(SCCSFLAGS) git $(SCCSGETFLAGS) $@

.sp


\&.SUFFIXES: .o .c .y .l .a .sh .f .c~ .y~ .l~ .sh~ .f~
.sp

\fP\fIMACROS\fP\fB
.br

MAKE=make
AR=ar
ARFLAGS=-rv
YACC=yacc
YFLAGS=
LEX=lex
LFLAGS=
LDFLAGS=
CC=c99
CFLAGS=-O
FC=fort77
FFLAGS=-O 1

GET=get
GFLAGS=
SCCSFLAGS=
SCCSGETFLAGS=-s

.sp

\fP\fISINGLE SUFFIX RULES\fP\fB
.br

\&.c:
    $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $<
.sp

\&.f:
    $(FC) $(FFLAGS) $(LDFLAGS) -o $@ $<
.sp

\&.sh:
    cp $< $@
    chmod a+x $@
.sp


\&.c~:
    $(GET) $(GFLAGS) -p $< > $*.c
    $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $*.c
.sp

\&.f~:
    $(GET) $(GFLAGS) -p $< > $*.f
    $(FC) $(FFLAGS) $(LDFLAGS) -o $@ $*.f
.sp

\&.sh~:
    $(GET) $(GFLAGS) -p $< > $*.sh
    cp $*.sh $@
    chmod a+x $@

.sp

\fP\fIDOUBLE SUFFIX RULES\fP\fB
.br

\&.c.o:
    $(CC) $(CFLAGS) -c $<
.sp

\&.f.o:
    $(FC) $(FFLAGS) -c $<
.sp

\&.y.o:
    $(YACC) $(YFLAGS) $<
    $(CC) $(CFLAGS) -c y.tab.c
    rm -f y.tab.c
    mv y.tab.o $@
.sp

\&.l.o:
    $(LEX) $(LFLAGS) $<
    $(CC) $(CFLAGS) -c lex.yy.c
    rm -f lex.yy.c
    mv lex.yy.o $@
.sp

\&.y.c:
    $(YACC) $(YFLAGS) $<
    mv y.tab.c $@
.sp

\&.l.c:
    $(LEX) $(LFLAGS) $<
    mv lex.yy.c $@
.sp


\&.c~.o:
    $(GET) $(GFLAGS) -p $< > $*.c
    $(CC) $(CFLAGS) -c $*.c
.sp

\&.f~.o:
    $(GET) $(GFLAGS) -p $< > $*.f
    $(FC) $(FFLAGS) -c $*.f
.sp

\&.y~.o:
    $(GET) $(GFLAGS) -p $< > $*.y
    $(YACC) $(YFLAGS) $*.y
    $(CC) $(CFLAGS) -c y.tab.c
    rm -f y.tab.c
    mv y.tab.o $@
.sp

\&.l~.o:
    $(GET) $(GFLAGS) -p $< > $*.l
    $(LEX) $(LFLAGS) $*.l
    $(CC) $(CFLAGS) -c lex.yy.c
    rm -f lex.yy.c
    mv lex.yy.o $@
.sp

\&.y~.c:
    $(GET) $(GFLAGS) -p $< > $*.y
    $(YACC) $(YFLAGS) $*.y
    mv y.tab.c $@
.sp

\&.l~.c:
    $(GET) $(GFLAGS) -p $< > $*.l
    $(LEX) $(LFLAGS) $*.l
    mv lex.yy.c $@

.sp

\&.c.a:
    $(CC) -c $(CFLAGS) $<
    $(AR) $(ARFLAGS) $@ $*.o
    rm -f $*.o
.sp

\&.f.a:
    $(FC) -c $(FFLAGS) $<
    $(AR) $(ARFLAGS) $@ $*.o
    rm -f $*.o
\fP
.fi
.RE
.SH EXIT STATUS
.LP
When tha \fB-q\fP option is specified, tha \fImake\fP utilitizzle shall
exit wit one of tha followin joints:
.TP 7
\ 0
Successful completion.
.TP 7
\ 1
Da target was not up-to-date.
.TP 7
>1
An error occurred.
.sp
.LP
When tha \fB-q\fP option aint specified, tha \fImake\fP utility
shall exit wit one of tha followin joints:
.TP 7
\ 0
Successful completion.
.TP 7
>0
An error occurred.
.sp
.SH CONSEQUENCES OF ERRORS
.LP
Default.
.LP
\fIDa followin sections is informative.\fP
.SH APPLICATION USAGE
.LP
If there be a source file (like fuckin \fB./source.c\fP) n' there are
two SCCS filez correspondin ta it ( \fB./s.source.c\fP and
\fB\&./SCCS/s.source.c\fP), on XSI-conformant systems \fImake\fP uses
the SCCS file up in tha current directory. But fuck dat shiznit yo, tha word on tha street is dat playas are
advised ta use tha underlyin SCCS utilitizzles ( \fIadmin\fP, \fIdelta\fP,
\fIget\fP, n' so on) or tha \fIsccs\fP utilitizzle fo' all source files
in a given directory. If both forms is used fo' a given
source file, future pimpers is straight-up likely ta be confused.
.LP
It be incumbent upon portable makefilez ta specify tha \fB.POSIX\fP
special target up in order ta guarantee dat they is not
affected by local extensions.
.LP
Da \fB-k\fP n' \fB-S\fP options is both present so dat tha relationshizzle
between tha command line, tha \fIMAKEFLAGS\fP
variable, n' tha makefile can be controlled precisely. If tha \fBk\fP
flag is passed up in \fIMAKEFLAGS\fP n' a cold-ass lil command iz of the
form:
.sp
.RS
.nf

\fB$(MAKE) -S foo
\fP
.fi
.RE
.LP
then tha default behavior is restored fo' tha lil pimp \fImake\fP.
.LP
When tha \fB-n\fP option is specified, it be always added ta \fIMAKEFLAGS
\&.\fP This allows a recursive \fImake\fP \fB-n\fP
\fItarget\fP ta be used ta peep all of tha action dat would be taken
to update \fItarget\fP.
.LP
Because of widespread oldschool practice, interpretin a \fB'#'\fP
number sign inside a variable as tha start of a cold-ass lil comment
has tha fucked up side effect of makin it impossible ta place a
number sign up in a variable, thus forbiddin suttin' like:
.sp
.RS
.nf

\fBCFLAGS = "-D COMMENT_CHAR='#'"
\fP
.fi
.RE
.LP
Many oldschool \fImake\fP utilitizzles stop chainin together inference
rulez when a intermediate target is nonexistent. For
example, it might be possible fo' a \fImake\fP ta determine dat both
\fB\&.y.c\fP n' \fB.c.o\fP could be used ta convert a
\fB\&.y\fP ta a \fB.o\fP. Instead, up in dis case, \fImake\fP requires
the use of a \fB.y.o\fP rule.
.LP
Da dopest way ta provide portable makefilez is ta include all of the
rulez needed up in tha makefile itself. Da rulez provided use
only features provided by other partz of dis volume of IEEE\ Std\ 1003.1-2001.
Da default rulez include rulez for
optionizzle commandz up in dis volume of IEEE\ Std\ 1003.1-2001. Only rules
pertainin ta commandz dat is provided is needed
in a implementationz default set.
.LP
Macros used within other macros is evaluated when tha freshly smoked up macro is
used rather than when tha freshly smoked up macro is defined.
Therefore:
.sp
.RS
.nf

\fBMACRO =\fP \fIvalue1\fP\fBNEW   = $(MACRO)
MACRO =\fP \fIvalue2\fP\fB
.br

target:
    echo $(NEW)
\fP
.fi
.RE
.LP
would produce \fIvalue2\fP n' not \fIvalue1\fP since \fBNEW\fP was
not expanded until dat shiznit was needed up in tha \fIecho\fP command line.
.LP
Some oldschool applications done been known ta intermix \fItarget_name\fP
and \fImacro=name\fP operandz on tha command line,
expectin dat all of tha macros is processed before any of tha targets
are dealt with. Conformin applications do not do this,
although some backwards-compatibilitizzle support may be included up in some
implementations.
.LP
Da followin charactas up in filenames may give shit: \fB'='\fP,
\fB':'\fP, \fB'`'\fP, \fB'"\fP, and
\fB'@'\fP . For inference rules, tha description of $< n' $, biatch? seem
similar. Shiiit, dis aint no joke. But fuck dat shiznit yo, tha word on tha street is dat a example shows tha minor difference.
In a makefile containing:
.sp
.RS
.nf

\fBfoo.o: foo.h
\fP
.fi
.RE
.LP
if \fBfoo.h\fP is newer than \fBfoo.o\fP, yet \fBfoo.c\fP is older
than \fBfoo.o\fP, tha built-in rule ta make \fBfoo.o\fP
from \fBfoo.c\fP is used, wit $< equal ta \fBfoo.c\fP n' $, biatch? equal
to \fBfoo.h\fP. If \fBfoo.c\fP be also newer than
\fBfoo.o\fP, $< is equal ta \fBfoo.c\fP n' $, biatch? is equal ta \fBfoo.h
foo.c\fP.
.SH EXAMPLES
.IP " 1." 4
Da followin command:
.sp
.RS
.nf

\fBmake
\fP
.fi
.RE
.LP
makes tha straight-up original gangsta target found up in tha makefile.
.LP
.IP " 2." 4
Da followin command:
.sp
.RS
.nf

\fBmake junk
\fP
.fi
.RE
.LP
makes tha target \fBjunk\fP.
.LP
.IP " 3." 4
Da followin makefile say dat \fBpgm\fP dependz on two files, \fBa.o\fP
and \fBb.o\fP, n' dat they up in turn depend on
their correspondin source filez ( \fBa.c\fP n' \fBb.c\fP), n' a
common file \fBincl.h\fP:
.sp
.RS
.nf

\fBpgm: a.o b.o
    c99 a.o b.o -o pgm
a.o: incl.h a.c
    c99 -c a.c
b.o: incl.h b.c
    c99 -c b.c
\fP
.fi
.RE
.LP
.IP " 4." 4
An example fo' makin optimized \fB.o\fP filez from \fB.c\fP files
is:
.sp
.RS
.nf

\fB\&.c.o:
    c99 -c -O $*.c
\fP
.fi
.RE
.LP
or:
.sp
.RS
.nf

\fB\&.c.o:
    c99 -c -O $<
\fP
.fi
.RE
.LP
.IP " 5." 4
Da most common use of tha archive intercourse bigs up yo. Here, it is
assumed dat tha source filez is all C-language source:
.sp
.RS
.nf

\fBlib: lib(file1.o) lib(file2.o) lib(file3.o)
    @echo lib is now up-to-date
\fP
.fi
.RE
.LP
Da \fB.c.a\fP rule is used ta make \fBfile1.o\fP, \fBfile2.o\fP,
and \fBfile3.o\fP n' bang dem tha fuck into \fBlib\fP.
.LP
Da treatment of escaped <newline>s all up in tha makefile is historical
practice. For example, tha inference rule:
.sp
.RS
.nf

\fB\&.c.o\\
:
\fP
.fi
.RE
.LP
works, n' tha macro:
.sp
.RS
.nf

\fBf=  bar baz\\
    biz
a:
    echo ==$f==
\fP
.fi
.RE
.LP
echoes \fB"==bar\ baz\ biz=="\fP .
.LP
If $, biatch? were:
.sp
.RS
.nf

\fB/usr/include/stdio.h /usr/include/unistd.h foo.h
\fP
.fi
.RE
.LP
then $(?D) would be:
.sp
.RS
.nf

\fB/usr/include /usr/include .
\fP
.fi
.RE
.LP
and $(?F) would be:
.sp
.RS
.nf

\fBstdio.h unistd.h foo.h
\fP
.fi
.RE
.LP
.IP " 6." 4
Da contentz of tha built-in rulez can be viewed by hustlin:
.sp
.RS
.nf

\fBmake -p -f /dev/null 2>/dev/null
\fP
.fi
.RE
.LP
.SH RATIONALE
.LP
Da \fImake\fP utilitizzle busted lyrics bout up in dis volume of IEEE\ Std\ 1003.1-2001
is intended ta provide tha means fo' changing
portable source code tha fuck into executablez dat can be run on a IEEE\ Std\ 1003.1-2001-conforming
system. Well shiiiit, it reflects da most thugged-out
common features present up in System V n' BSD \fImake\fPs.
.LP
Historically, tha \fImake\fP utilitizzle has been a especially fertile
ground fo' vendor n' research organization-specific syntax
modifications n' extensions. Examplez include:
.IP " *" 3
Syntax supportin parallel execution (like fuckin from various multi-processor
vendors, GNU, n' others)
.LP
.IP " *" 3
Additionizzle "operators" separatin targets n' they prerequisites
(System V, BSD, n' others)
.LP
.IP " *" 3
Specifyin dat command lines containin tha strings \fB"${MAKE}"\fP
and \fB"$(MAKE)"\fP is executed when tha \fB-n\fP
option is specified (GNU n' System V)
.LP
.IP " *" 3
Modificationz of tha meanin of internal macros when referencin libraries
(BSD n' others)
.LP
.IP " *" 3
Usin a single instizzle of tha shell fo' all of tha command lines
of tha target (BSD n' others)
.LP
.IP " *" 3
Allowin spaces as well as tabs ta delimit command lines (BSD)
.LP
.IP " *" 3
Addin C preprocessor-style "include" n' "ifdef" constructs (System
V, GNU, BSD, n' others)
.LP
.IP " *" 3
Remote execution of command lines (Sprite n' others)
.LP
.IP " *" 3
Specifyin additionizzle special targets (BSD, System V, n' most others)
.LP
.LP
Additionally, nuff vendors n' research crews have rethought
the basic conceptz of \fImake\fP, bustin vastly
extended, as well as straight-up new, syntaxes. Each of these versions
of \fImake\fP fulfills tha needz of a gangbangin' finger-lickin' different hood of
users; it is unreasonable fo' dis volume of IEEE\ Std\ 1003.1-2001
to require behavior dat would be incompatible (and
probably inferior) ta oldschool practice fo' such a cold-ass lil hood.
.LP
In similar circumstances, when tha industry has enough sufficiently
incompatible formats as ta make dem irreconcilable, this
volume of IEEE\ Std\ 1003.1-2001 has followed one or both of two courses
of action. I aint talkin' bout chicken n' gravy biatch. Commandz done been renamed ( \fIcksum\fP, \fIecho\fP, and
\fIpax\fP) and/or command line options done been provided ta select
the desired behavior ( \fIgrep\fP, \fIod\fP, n' \fIpax\fP).
.LP
Because tha syntax specified fo' tha \fImake\fP utilitizzle is, by and
large, a subset of tha syntaxes accepted by almost all
versionz of \fImake\fP, dat shiznit was decided dat it would be counter-productive
to chizzle tha name fo' realz. And since tha makefile itself be a
basic unit of portability, it would not be straight-up effectizzle to
reserve a freshly smoked up option letter, like fuckin \fImake\fP \fB-P\fP, to
achieve tha portable behavior. Shiiit, dis aint no joke. Therefore, tha special target \fB.POSIX\fP
was added ta tha makefile, allowin playas ta specify
"standard" behavior. Shiiit, dis aint no joke. This special target do not preclude extensions
in tha \fImake\fP utility, nor do it preclude such
extensions bein used by tha makefile specifyin tha target; it do,
however, preclude any extensions from bein applied that
could alta tha behavior of previously valid syntax; such extensions
must be controlled via command line options or freshly smoked up special
targets, n' you can put dat on yo' toast. Well shiiiit, it is incumbent upon portable makefilez ta specify tha \fB.POSIX\fP
special target up in order ta guarantee dat they are
not affected by local extensions.
.LP
Da portable version of \fImake\fP busted lyrics bout up in dis reference page
is not intended ta be tha state-of-the-art software
generation tool and, as such, some newer n' mo' leading-edge features
have not been included. Y'all KNOW dat shit, muthafucka! An attempt has been made to
describe tha portable makefile up in a manner dat do not preclude
such extensions as long as they do not disturb tha portable
behavior busted lyrics bout here.
.LP
When tha \fB-n\fP option is specified, it be always added ta \fIMAKEFLAGS
\&.\fP This allows a recursive \fImake\fP \fB-n\fP
\fItarget\fP ta be used ta peep all of tha action dat would be taken
to update \fItarget\fP.
.LP
Da definizzle of \fIMAKEFLAGS\fP allows both tha System V letter
strin n' tha BSD command line formats, n' you can put dat on yo' toast. Da two formats are
sufficiently different ta allow implementations ta support both without
ambiguity.
.LP
Early proposals stated dat a "unquoted" number sign was treated
as tha start of a cold-ass lil comment. Da \fImake\fP utilitizzle do not
pay any attention ta quotes fo' realz. A number sign starts a cold-ass lil comment regardless
of its surroundings.
.LP
Da text bout "other implementation-defined pathnames may also be
tried" up in addizzle ta \fB./makefile\fP and
\fB\&./Makefile\fP is ta allow such extensions as \fBSCCS/s.Makefile\fP
and other variations. Dat shiznit was made a implementation-defined
requirement (as opposed ta unspecified behavior) ta highlight surprising
implementations dat might select suttin' unexpected
like \fB/etc/Makefile\fP. XSI-conformant systems also try \fB./s.makefile\fP,
\fBSCCS/s.makefile\fP, \fB./s.Makefile\fP, and
\fBSCCS/s.Makefile\fP.
.LP
Early proposals contained tha macro \fBNPROC\fP as a meanz of specifying
that \fImake\fP should use \fIn\fP processes ta do
the work required. Y'all KNOW dat shit, muthafucka! While dis feature be a valuable extension for
many systems, it aint common usage n' could require other
non-trivial extensions ta makefile syntax. This extension aint required
by dis volume of IEEE\ Std\ 1003.1-2001 yo, but
could be provided as a cold-ass lil compatible extension. I aint talkin' bout chicken n' gravy biatch. Da macro \fBPARALLEL\fP
is used by some oldschool systems wit essentially tha same
meanin (but without rockin a name dat be a cold-ass lil common system limit value).
It be suggested dat implementors recognize tha existing
use of \fBNPROC\fP and/or \fBPARALLEL\fP as extensions ta \fImake\fP.
.LP
Da default rulez is based on System V. Da default \fBCC=\fP value
is \fIc99\fP instead
of \fIcc\fP cuz dis volume of IEEE\ Std\ 1003.1-2001 do not
standardize tha utilitizzle named \fIcc\fP. Thus, every
conformin application would be required ta define \fBCC=\fP \fIc99\fP
to expect ta run.
There is no advantage conferred by tha hope dat tha makefile might
hit tha "preferred" compila cuz dis cannot be
guaranteed ta work fo' realz. Also, since tha portable makescript can only use
the \fIc99\fP options, no
advantage is conferred up in termz of what tha fuck tha script can do. Well shiiiit, it be a
quality-of-implementation issue as ta whether \fIc99\fP be as valuable
as \fIcc\fP.
.LP
Da \fB-d\fP option ta \fImake\fP is frequently used ta produce debugging
information yo, but is too implementation-defined to
add ta dis volume of IEEE\ Std\ 1003.1-2001.
.LP
Da \fB-p\fP option aint passed up in \fIMAKEFLAGS\fP on most historical
implementations n' ta chizzle dis would cause many
implementations ta break without sufficiently increased portability.
.LP
Commandz dat begin wit a plus sign ( \fB'+'\fP ) is executed even
if tha \fB-n\fP option is present. Based on tha GNU
version of \fImake\fP, tha behavior of \fB-n\fP when tha plus-sign
prefix is encountered has been extended ta apply ta \fB-q\fP
and \fB-t\fP as well. But fuck dat shiznit yo, tha word on tha street is dat tha System V convention of forcing
command execution wit \fB-n\fP when tha command line of a
target gotz nuff either of tha strings \fB"$(MAKE)"\fP or \fB"${MAKE}"\fP
has not been adopted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This functionalitizzle rocked up in
early proposals yo, but tha dark shiznit of dis approach was pointed up with
the followin example of a portion of a makefile:
.sp
.RS
.nf

\fBsubdir:
    cd subdir; rm all_the_files; $(MAKE)
\fP
.fi
.RE
.LP
Da loss of tha System V behavior up in dis case is well-balanced by
the safety afforded ta other makefilez dat was not aware of
this thang. In any event, tha command line plus-sign prefix can
provide tha desired functionality.
.LP
Da double colon up in tha target rule format is supported up in BSD systems
to allow mo' than one target line containin tha same
target name ta have commandz associated wit dat shit. Right back up in yo muthafuckin ass. Since dis is not
functionalitizzle busted lyrics bout up in tha SVID or XPG3 it has been allowed
as a extension yo, but not mandated.
.LP
Da default rulez is provided wit text specifyin dat tha built-in
rulez shall be tha same as if tha listed set was used.
Da intent is dat implementations should be able ta use tha rules
without chizzle yo, but is ghon be allowed ta alta dem up in ways that
do not affect tha primary behavior.
.LP
Da dopest way ta provide portable makefilez is ta include all of the
rulez needed up in tha makefile itself. Da rulez provided use
only features provided by other portionz of dis volume of IEEE\ Std\ 1003.1-2001.
Da default rulez include rulez for
optionizzle commandz up in dis volume of IEEE\ Std\ 1003.1-2001. Only rules
pertainin ta commandz dat is provided is needed
in tha default set of a implementation.
.LP
One point of rap was whether ta drop tha default rulez list
from dis volume of IEEE\ Std\ 1003.1-2001. They
provide convenience yo, but do not enhizzle portabilitizzle of applications.
Da prime benefit is up in portabilitizzle of playas whoz ass wish ta type
\fImake\fP \fIcommand\fP n' have tha command build from a \fBcommand.c\fP
file.
.LP
Da oldschool \fIMAKESHELL\fP feature was omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In some implementations
it is used ta let a user override tha shell ta be
used ta run \fImake\fP commands. This was confusing; fo' a portable
\fImake\fP, tha shell should be chosen by tha makefile writer
or specified on tha \fImake\fP command line n' not by a user hustlin
\fImake\fP.
.LP
Da \fImake\fP utilitizzles up in most oldschool implementations process
the prerequisitez of a target up in left-to-right order, and
the makefile format requires all dis bullshit. Well shiiiit, it supports tha standard idiom
used up in nuff makefilez dat produce \fIyacc\fP programs; fo' example:
.sp
.RS
.nf

\fBfoo: y.tab.o lex.o main.o
    $(CC) $(CFLAGS) -o $\fP@ \fBt.tab.o lex.o main.o
\fP
.fi
.RE
.LP
In dis example, if \fImake\fP chose any arbitrary order, tha \fBlex.o\fP
might not be made wit tha erect \fBy.tab.h\fP.
Although there may be betta ways ta express dis relationshizzle, it
is widely used historically. Implementations dat desire to
update prerequisites up in parallel should require a explicit extension
to \fImake\fP or tha makefile format ta accomplish it, as
busted lyrics bout previously.
.LP
Da algorithm fo' determinin a freshly smoked up entry fo' target rulez is partially
unspecified. Y'all KNOW dat shit, muthafucka! Some oldschool \fImake\fPs allow blank,
empty, or comment lines within tha collection of commandz marked by
leadin <tab>s fo' realz. A conformin makefile must ensure that
each command starts wit a <tab> yo, but implementations is free to
ignore blank, empty, n' comment lines without triggering
the start of a freshly smoked up entry.
.LP
Da ASYNCHRONOUS EVENTS section includes havin SIGTERM n' SIGHUP,
along wit tha mo' traditionizzle SIGINT n' SIGQUIT, remove
the current target unless pimped up not ta do so. Right back up in yo muthafuckin ass. SIGTERM n' SIGHUP
were added ta parallel other utilitizzles dat have historically
cleaned up they work as a result of these signals. When \fImake\fP
receives any signal other than SIGQUIT, it is required to
resend itself tha signal it received so dat it exits wit a status
that reflects tha signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da thangs up in dis biatch from SIGQUIT are
partially unspecified cuz, on systems dat create \fBcore\fP files
upon receipt of SIGQUIT, tha \fBcore\fP from \fImake\fP
would conflict wit a \fBcore\fP file from tha command dat was hustlin
when tha SIGQUIT arrived. Y'all KNOW dat shit, muthafucka! Da main concern was ta prevent
damaged filez from appearin up-to-date when \fImake\fP is rerun.
.LP
Da \fB.PRECIOUS\fP special target was extended ta affect all targets
globally (by specifyin no prerequisites). The
\fB\&.IGNORE\fP n' \fB.SILENT\fP special targets was extended ta allow
prerequisites; dat shiznit was judged ta be mo' useful up in some
cases ta be able ta turn off errors or echoin fo' a list of targets
than fo' tha entire makefile. These extensions ta \fImake\fP
in System V was made ta match oldschool practice from tha BSD \fImake\fP.
.LP
Macros is not exported ta tha environment of commandz ta be run.
This was never tha case up in any oldschool \fImake\fP and
would have straight-up consequences. Da environment is tha same ol' dirty as the
environment ta \fImake\fP except dat \fIMAKEFLAGS\fP and
macros defined on tha \fImake\fP command line is added.
.LP
Some implementations do not use \fIsystem\fP() fo' all command lines,
as required by the
portable makefile format; as a performizzle enhancement, they select
lines without shell metacharactas fo' direct execution by \fIexecve\fP().
There is no requirement dat \fIsystem\fP() be used specifically,
but merely dat tha same thangs up in dis biatch be  bigged up . Y'all KNOW dat shit, muthafucka! The
metacharactas typically used ta bypass tha direct \fIexecve\fP()
execution done been any
of:
.sp
.RS
.nf

\fB=  |  ^  (  )  ;  &  <  >  *  , biatch?  [  ]  :  $  `  '  "  \\  \\n
\fP
.fi
.RE
.LP
Da default up in some advanced versionz of \fImake\fP is ta crew all
the command lines fo' a target n' execute dem rockin a
single shell invocation; tha System V method is ta pass each line
individually ta a separate shell. Da single-shell method has the
advantages up in performizzle n' tha lack of a requirement fo' nuff continued
lines. But fuck dat shiznit yo, tha word on tha street is dat convertin ta dis newer method has
caused portabilitizzle problems wit nuff oldschool makefiles, so the
behavior wit tha POSIX makefile is specified ta be tha same as
that of System V. Well shiiiit, it is suggested dat tha special target \fB.ONESHELL\fP
be used as a implementation extension ta big up the
single-shell groupin fo' a target or crew of targets.
.LP
Novice playaz of \fImake\fP have had hang-up wit tha historical
need ta start commandz wit a <tab>. Right back up in yo muthafuckin ass. Since it is often
hard as fuck ta discern differences between <tab>s n' <space>s on terminals
or printed listings, confusin bugs can
arise. In early proposals, a attempt was made ta erect dis problem
by allowin leadin <blank>s instead of <tab>s.
But fuck dat shiznit yo, tha word on tha street is dat implementors reported nuff makefilez dat failed up in subtle
ways followin dis chizzle, n' it is hard as fuck ta implement a
\fImake\fP dat unambiguously can differentiate between macro and
command lines. There is extensive oldschool practice of
allowin leadin spaces before macro definitions. Forcin macro lines
into column 1 would be a thugged-out dope backwards-compatibility
problem fo' some makefiles. Therefore, oldschool practice was restored.
.LP
Da System V INCLUDE feature was considered yo, but not included. Y'all KNOW dat shit, muthafucka! This
would treat a line dat fuckin started up in tha straight-up original gangsta column and
contained INCLUDE <\fIfilename\fP> as a indication ta read <\fIfilename\fP>
at dat point up in tha makefile. This is
hard as fuck ta use up in a portable way, n' it raises concerns bout nesting
levels n' diagnostics. Right back up in yo muthafuckin ass. System V, BSD, GNU, n' others
have used different methodz fo' includin files.
.LP
Da System V dynamic dependency feature was not included. Y'all KNOW dat shit, muthafucka! Well shiiiit, it would
support:
.sp
.RS
.nf

\fBcat: $$@.c
\fP
.fi
.RE
.LP
that would expand to;
.sp
.RS
.nf

\fBcat: cat.c
\fP
.fi
.RE
.LP
This feature exists only up in tha freshly smoked up version of System V \fImake\fP
and, while useful, aint up in wide usage. This means that
macros is expanded twice fo' prerequisites: once at makefile parse
time n' once at target update time.
.LP
Consideration was given ta addin metarulez ta tha POSIX \fImake\fP.
This would make \fB%.o:\ %.c\fP tha same as
\fB\&.c.o:\fP. This is like useful n' available from some vendors,
but it would cause too nuff chizzlez ta dis \fImake\fP to
support. Well shiiiit, it would have introduced rule chainin n' freshly smoked up substitution
rules. But fuck dat shiznit yo, tha word on tha street is dat tha rulez fo' target names done been set to
reserve tha \fB'%'\fP n' \fB''\fP characters. These is traditionally
used ta implement metarulez n' quotin of target
names, respectively. Implementors is straight fuckin encouraged ta use these
charactas only fo' these purposes.
.LP
A request was made ta extend tha suffix delimita characta from a
period ta any character n' shit. Da metarulez feature up in newer
\fImake\fPs solves dis problem up in a mo' general way. This volume
of IEEE\ Std\ 1003.1-2001 is stayin wit tha more
conservatizzle oldschool definition.
.LP
Da standard output format fo' tha \fB-p\fP option aint busted lyrics about
because it is primarily a thugged-out debuggin option n' cuz the
format aint generally useful ta programs. In oldschool implementations
the output aint suitable fo' use up in generating
makefiles. Da \fB-p\fP format has been variable across historical
implementations. Therefore, tha definizzle of \fB-p\fP was
only ta provide a cold-ass lil consistently named option fo' obtainin \fImake\fP
script debuggin shiznit.
.LP
Some oldschool implementations aint cleared tha suffix list with
\fB-r\fP.
.LP
Implementations should be aware dat some oldschool applications
have intermixed \fItarget_name\fP n' \fImacro\fP=
\fIvalue\fP operandz on tha command line, expectin dat all of the
macros is processed before any of tha targets is dealt with.
Conformin applications do not do dis yo, but some backwards-compatibility
support may be warranted.
.LP
Empty inference rulez is specified wit a semicolon command rather
than omittin all commands, as busted lyrics bout up in a early
proposal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da latta case has no traditionizzle meanin n' is reserved
for implementation extensions, like fuckin up in GNU \fImake\fP.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIShell Command Language\fP, \fIar\fP, \fIc99\fP, \fIget\fP,
\fIlex\fP, \fIsccs\fP, \fIsh\fP, \fIyacc\fP, tha System Interfaces
volume
of IEEE\ Std\ 1003.1-2001, \fIexec\fP, \fIsystem\fP()
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
