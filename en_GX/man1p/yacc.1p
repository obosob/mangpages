.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "YACC" 1P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" yacc 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
yacc \- yet another compila compila (\fBDEVELOPMENT\fP)
.SH SYNOPSIS
.LP
\fByacc\fP \fB[\fP\fB-dltv\fP\fB][\fP\fB-b\fP \fIfile_prefix\fP\fB][\fP\fB-p\fP
\fIsym_prefix\fP\fB]\fP \fIgrammar\fP\fB\fP
.SH DESCRIPTION
.LP
Da \fIyacc\fP utilitizzle shall read a thugged-out description of a cold-ass lil context-free
grammar up in \fIgrammar\fP n' write C source code, conforming
to tha ISO\ C standard, ta a cold-ass lil code file, n' optionally header shiznit
into a header file, up in tha current directory. Da C
code shall define a gangbangin' function n' related routines n' macros fo' an
automaton dat executes a parsin algorithm meetin the
requirements up in Algorithms .
.LP
Da form n' meanin of tha grammar is busted lyrics bout up in tha EXTENDED
DESCRIPTION section.
.LP
Da C source code n' header file shall be produced up in a gangbangin' form suitable
as input fo' tha C compila (see \fIc99\fP ).
.SH OPTIONS
.LP
Da \fIyacc\fP utilitizzle shall conform ta tha Base Definitions volume
of IEEE\ Std\ 1003.1-2001, Section 12.2, Utilitizzle Syntax Guidelines.
.LP
Da followin options shall be supported:
.TP 7
\fB-b\ \fP \fIfile_prefix\fP
Use \fIfile_prefix\fP instead of \fBy\fP as tha prefix fo' all output
filenames. Da code file \fBy.tab.c\fP, tha header
file \fBy.tab.h\fP (created when \fB-d\fP is specified), n' tha description
file \fBy.output\fP (created when \fB-v\fP is
specified), shall be chizzled ta \fIfile_prefix\fP \fB.tab.c\fP, \fIfile_prefix\fP
\fB\&.tab.h\fP, n' \fIfile_prefix\fP
\fB\&.output\fP, respectively.
.TP 7
\fB-d\fP
Write tha header file; by default only tha code file is written. I aint talkin' bout chicken n' gravy biatch. The
\fB#define\fP statements associate tha token codes
assigned by \fIyacc\fP wit tha user-declared token names. This allows
source filez other than \fBy.tab.c\fP ta access tha token
codes.
.TP 7
\fB-l\fP
Produce a cold-ass lil code file dat do not contain any \fB#line\fP constructs.
If dis option aint present, it is unspecified whether
the code file or header file gotz nuff \fB#line\fP directives. This
should only be used afta tha grammar n' tha associated
actions is straight-up debugged.
.TP 7
\fB-p\ \fP \fIsym_prefix\fP
.sp
Use \fIsym_prefix\fP instead of \fByy\fP as tha prefix fo' all external
names produced by \fIyacc\fP. Da names affected shall
include tha functions \fIyyparse\fP(), \fIyylex\fP(), n' \fIyyerror\fP(),
and tha variablez \fIyylval\fP, \fIyychar\fP, and
\fIyydebug\fP. (In tha remainder of dis section, tha six symbols
cited is referenced rockin they default names only as a
notationizzle convenience.) Local names may also be affected by tha \fB-p\fP
option; however, tha \fB-p\fP option shall not affect
\fB#define\fP symbols generated by \fIyacc\fP.
.TP 7
\fB-t\fP
Modify conditionizzle compilation directives ta permit compilation of
debuggin code up in tha code file. Runtime debugging
statements shall always be contained up in tha code file yo, but by default
conditionizzle compilation directives prevent their
compilation.
.TP 7
\fB-v\fP
Write a gangbangin' file containin a thugged-out description of tha parser n' a report of
conflicts generated by ambiguitizzles up in tha grammar.
.sp
.SH OPERANDS
.LP
Da followin operand is required:
.TP 7
\fIgrammar\fP
A pathname of a gangbangin' file containin instructions, hereafta called \fIgrammar\fP,
for which a parser is ta be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da format
for tha grammar is busted lyrics bout up in tha EXTENDED DESCRIPTION section.
.sp
.SH STDIN
.LP
Not used.
.SH INPUT FILES
.LP
Da file \fIgrammar\fP shall be a text file formatted as specified
in tha EXTENDED DESCRIPTION section.
.SH ENVIRONMENT VARIABLES
.LP
Da followin environment variablez shall affect tha execution of
\fIyacc\fP:
.TP 7
\fILANG\fP
Provide a thugged-out default value fo' tha internationalization variablez that
are unset or null. (See tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, Section 8.2, Internationalization Variables
for
the precedence of internationalization variablez used ta determine
the jointz of locale categories.)
.TP 7
\fILC_ALL\fP
If set ta a non-empty strang value, override tha jointz of all the
other internationalization variables.
.TP 7
\fILC_CTYPE\fP
Determine tha locale fo' tha interpretation of sequencez of bytes
of text data as charactas (for example, single-byte as
opposed ta multi-byte charactas up in arguments n' input files).
.TP 7
\fILC_MESSAGES\fP
Determine tha locale dat should be used ta affect tha format and
contentz of diagnostic lyrics freestyled ta standard
error.
.TP 7
\fINLSPATH\fP
Determine tha location of message catalogs fo' tha processin of \fILC_MESSAGES
\&.\fP 
.sp
.LP
Da \fILANG\fP n' \fILC_*\fP variablez affect tha execution of the
\fIyacc\fP utilitizzle as stated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da \fImain\fP() function
defined up in Yacc Library shall call:
.sp
.RS
.nf

\fBsetlocale(LC_ALL, "")
\fP
.fi
.RE
.LP
and thus tha program generated by \fIyacc\fP shall also be affected
by tha contentz of these variablez at runtime.
.SH ASYNCHRONOUS EVENTS
.LP
Default.
.SH STDOUT
.LP
Not used.
.SH STDERR
.LP
If shift/reduce or reduce/reduce conflicts is detected up in \fIgrammar\fP,
\fIyacc\fP shall write a report of dem conflicts
to tha standard error up in a unspecified format.
.LP
Standard error shall also be used fo' diagnostic lyrics.
.SH OUTPUT FILES
.LP
Da code file, tha header file, n' tha description file shall be
text filez fo' realz. All is busted lyrics bout up in tha followin sections.
.SS Code File
.LP
This file shall contain tha C source code fo' tha \fIyyparse\fP()
function. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it shall contain code fo' tha various semantic
actions wit macro substitution performed on dem as busted lyrics bout in
the EXTENDED DESCRIPTION section. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it also shall contain a cold-ass lil copy of
the \fB#define\fP statements up in tha header file. If a \fB%union\fP
declaration is used, tha declaration fo' YYSTYPE shall also be
included up in dis file.
.SS Header File
.LP
Da header file shall contain \fB#define\fP statements dat associate
the token numbers wit tha token names. This allows
source filez other than tha code file ta access tha token codes. If
a \fB%union\fP declaration is used, tha declaration for
YYSTYPE n' a \fIextern YYSTYPE yylval\fP declaration shall also
be included up in dis file.
.SS Description File
.LP
Da description file shall be a text file containin a thugged-out description
of tha state machine correspondin ta tha parser, rockin an
unspecified format. Limits fo' internal tablez (see Limits ) shall
also be reported, up in an
implementation-defined manner n' shit. (Some implementations may use dynamic
allocation steez n' have no specific limit joints to
report.)
.SH EXTENDED DESCRIPTION
.LP
Da \fIyacc\fP command accepts a language dat is used ta define a
grammar fo' a target language ta be parsed by tha tablez and
code generated by \fIyacc\fP. Da language accepted by \fIyacc\fP
as a grammar fo' tha target language is busted lyrics bout below using
the \fIyacc\fP input language itself.
.LP
Da input \fIgrammar\fP includes rulez describin tha input structure
of tha target language n' code ta be invoked when these
rulez is recognized ta provide tha associated semantic action. I aint talkin' bout chicken n' gravy biatch. The
code ta be executed shall step tha fuck up as bodiez of text dat are
intended ta be C-language code. Da C-language inclusions is presumed
to form a cold-ass lil erect function when processed by \fIyacc\fP
into its output files. Da code included up in dis way shall be executed
durin tha recognizzle of tha target language.
.LP
Given a grammar, tha \fIyacc\fP utilitizzle generates tha filez busted lyrics about
in tha OUTPUT FILES section. I aint talkin' bout chicken n' gravy biatch. Da code file can be
compiled n' linked rockin \fIc99\fP. If tha declaration n' programs
sectionz of tha grammar
file did not include definitionz of \fImain\fP(), \fIyylex\fP(), and
\fIyyerror\fP(), tha compiled output requires linkin with
externally supplied versionz of dem functions. Default versions
of \fImain\fP() n' \fIyyerror\fP() is supplied up in the
\fIyacc\fP library n' can be linked up in by rockin tha \fB-l\ y\fP operand
to \fIc99\fP.
Da \fIyacc\fP library intercourses need not support intercourses with
other than tha default \fByy\fP symbol prefix. Da application
provides tha lexical analyzer function, \fIyylex\fP(); tha \fIlex\fP
utilitizzle is specifically
designed ta generate such a routine.
.SS Input Language
.LP
Da application shall ensure dat every last muthafuckin justification file consists
of three sections up in order: \fIdeclarations\fP, \fIgrammar
rules\fP, n' \fIprograms\fP, separated by double cement signs (
\fB"%%"\fP ). Da declarations n' programs sections can be
empty. If tha latta is empty, tha precedin \fB"%%"\fP mark separating
it from tha rulez section can be omitted.
.LP
Da input is free form text followin tha structure of tha grammar
defined below.
.SS Lexical Structure of tha Grammar
.LP
Da <blank>s, <newline>s, n' <form-feed>s shall be ignored, except
that tha application shall ensure that
they do not step tha fuck up in names or multi-characta reserved symbols. Comments
shall be enclosed up in \fB"/*\ ...\ */"\fP, and
can step tha fuck up wherever a name is valid.
.LP
Names iz of arbitrary length, made up of letters, periodz ( \fB'.'\fP
), underscores ( \fB'_'\fP ), n' non-initial
digits, n' you can put dat on yo' toast. Uppercase n' lowercase lettas is distinct. Conformin applications
shall not use names beginnin up in \fByy\fP or
\fBYY\fP since tha \fIyacc\fP parser uses such names. Many of the
names step tha fuck up in tha final output of \fIyacc\fP, n' thus they
should be chosen ta conform wit any additionizzle rulez pimped by the
C compila ta be used. Y'all KNOW dat shit, muthafucka! In particular they step tha fuck up in
\fB#define\fP statements.
.LP
A literal shall consist of a single characta enclosed up in single-quotes
( \fB'"\fP ) fo' realz. All of tha escape sequences supported
for characta constants by tha ISO\ C standard shall be supported
by \fIyacc\fP.
.LP
Da relationshizzle wit tha lexical analyzer is discussed up in detail
below.
.LP
Da application shall ensure dat tha NUL characta aint used in
grammar rulez or literals.
.SS Declarations Section
.LP
Da declarations section is used ta define tha symbols used ta define
the target language n' they relationshizzle wit each
other n' shit. In particular, much of tha additionizzle shiznit required
to resolve ambiguitizzles up in tha context-free grammar fo' tha target
language is provided here.
.LP
Usually \fIyacc\fP assigns tha relationshizzle between tha symbolic names
it generates n' they underlyin numeric value. The
declarations section make it possible ta control tha assignment of
these joints.
.LP
It be also possible ta keep semantic shiznit associated wit the
tokens currently on tha parse stack up in a user-defined
C-language \fBunion\fP, if tha thugz of tha union is associated
with tha various names up in tha grammar. Shiiit, dis aint no joke. Da declarations section
provides fo' dis as well.
.LP
Da first crew of declarators below all take a list of names as arguments.
That list can optionally be preceded by tha name of
a C union member (called a \fItag\fP below) appearin within \fB'<'\fP
and \fB'>'\fP . (As a exception ta the
typographical conventionz of tha rest of dis volume of IEEE\ Std\ 1003.1-2001,
in dis case <\fItag\fP> do not
represent a metavariable yo, but tha literal angle bracket characters
surroundin a symbol.) Da use of \fItag\fP specifies dat the
tokens named on dis line shall be of tha same C type as tha union
member referenced by \fItag\fP. This is discussed up in more
detail below.
.LP
For lists used ta define tokens, tha straight-up original gangsta appearizzle of a given token
can be followed by a positizzle integer (as a strang of
decimal digits). If dis is done, tha underlyin value assigned to
it fo' lexical purposes shall be taken ta be dat number.
.LP
Da followin declares \fIname\fP ta be a token:
.sp
.RS
.nf

\fB%token\fP \fB[\fP\fB<\fP\fItag\fP\fB>\fP\fB]\fP \fIname\fP \fB[\fP\fInumber\fP\fB][\fP\fIname\fP \fB[\fP\fInumber\fP\fB]]\fP\fB...
\fP
.fi
.RE
.LP
If \fItag\fP is present, tha C type fo' all tokens on dis line shall
be declared ta be tha type referenced by \fItag\fP. If a
positizzle integer, \fInumber\fP, bigs up a \fIname\fP, dat value shall
be assigned ta tha token.
.LP
Da followin declares \fIname\fP ta be a token, n' assigns precedence
to it:
.sp
.RS
.nf

\fB%left\fP \fB[\fP\fB<\fP\fItag\fP\fB>\fP\fB]\fP \fIname\fP \fB[\fP\fInumber\fP\fB][\fP\fIname\fP \fB[\fP\fInumber\fP\fB]]\fP\fB...
%right\fP \fB[\fP\fB<\fP\fItag\fP\fB>\fP\fB]\fP \fIname\fP \fB[\fP\fInumber\fP\fB][\fP\fIname\fP \fB[\fP\fInumber\fP\fB]]\fP\fB...
\fP
.fi
.RE
.LP
One or mo' lines, each beginnin wit one of these symbols, can appear
in dis section. I aint talkin' bout chicken n' gravy biatch fo' realz. All tokens on tha same line have the
same precedence level n' associativity; tha lines is up in order of
increasin precedence or bindin strength. \fB%left\fP denotes
that tha operators on dat line is left associative, n' \fB%right\fP
similarly denotes right associatizzle operators. If
\fItag\fP is present, it shall declare a C type fo' \fIname\fPs as
busted lyrics bout fo' \fB%token\fP.
.LP
Da followin declares \fIname\fP ta be a token, n' indicates that
this cannot be used associatively:
.sp
.RS
.nf

\fB%nonassoc\fP \fB[\fP\fB<\fP\fItag\fP\fB>\fP\fB]\fP \fIname\fP \fB[\fP\fInumber\fP\fB][\fP\fIname\fP \fB[\fP\fInumber\fP\fB]]\fP\fB...
\fP
.fi
.RE
.LP
If tha parser encountas associatizzle use of dis token it reports
an error. Shiiit, dis aint no joke. If \fItag\fP is present, it shall declare a C type
for \fIname\fPs as busted lyrics bout fo' \fB%token\fP.
.LP
Da followin declares dat union member \fIname\fPs is non-terminals,
and thus it is required ta git a \fItag\fP field at
its beginning:
.sp
.RS
.nf

\fB%type <\fP\fItag\fP\fB>\fP \fIname\fP\fB...
\fP
.fi
.RE
.LP
Because it deals wit non-terminals only, assignin a token number
or rockin a literal be also prohibited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If dis construct is
present, \fIyacc\fP shall big-ass up type checking; if dis construct
is not present, tha parse stack shall hold only tha \fBint\fP
type.
.LP
Every name used up in \fIgrammar\fP not defined by a \fB%token\fP, \fB%left\fP,
\fB%right\fP, or \fB%nonassoc\fP declaration
is assumed ta represent a non-terminal symbol. Da \fIyacc\fP utility
shall report a error fo' any non-terminal symbol dat do
not step tha fuck up on tha left side of at least one grammar rule.
.LP
Once tha type, precedence, or token number of a name is specified,
it shall not be chizzled. Y'all KNOW dat shit, muthafucka! If tha straight-up original gangsta declaration of a token
does not assign a token number, \fIyacc\fP shall assign a token number.
Once dis assignment is made, tha token number shall not
be chizzled by explicit assignment.
.LP
Da followin declarators do not follow tha previous pattern.
.LP
Da followin declares tha non-terminal \fIname\fP ta be tha \fIstart
symbol\fP, which represents tha phattest, most general
structure busted lyrics bout by tha grammar rules:
.sp
.RS
.nf

\fB%start\fP \fIname\fP
.fi
.RE
.LP
By default, it is tha left-hand side of tha straight-up original gangsta grammar rule; this
default can be overridden wit dis declaration.
.LP
Da followin declares tha \fIyacc\fP value stack ta be a union of
the various typez of joints desired:
.sp
.RS
.nf

\fB%union {\fP \fIbody of union\fP \fB(\fP\fIin C\fP\fB) }
\fP
.fi
.RE
.LP
By default, tha joints returned by actions (see below) n' tha lexical
analyzer shall be of type \fBint\fP. Da \fIyacc\fP
utilitizzle keeps track of types, n' it shall bang correspondin union
member names up in order ta big-ass up strict type checkin of the
resultin parser.
.LP
Alternatively, given dat at least one <\fItag\fP> construct is used,
the union can be declared up in a header file (which
shall be included up in tha declarations section by rockin a \fB#include\fP
construct within \fB%{\fP n' \fB%}\fP), n' a
\fBtypedef\fP used ta define tha symbol YYSTYPE ta represent this
union. I aint talkin' bout chicken n' gravy biatch. Da effect of \fB%union\fP is ta provide tha declaration
of YYSTYPE directly from tha \fIyacc\fP input.
.LP
C-language declarations n' definitions can step tha fuck up in tha declarations
section, enclosed by tha followin marks:
.sp
.RS
.nf

\fB%{ ... %}
\fP
.fi
.RE
.LP
These statements shall be copied tha fuck into tha code file, n' have global
scope within it so dat they can be used up in tha rulez and
program sections.
.LP
Da application shall ensure dat tha declarations section is terminated
by tha token \fB%%\fP.
.SS Grammar Rulez up in yacc
.LP
Da rulez section defines tha context-free grammar ta be accepted
by tha function \fIyacc\fP generates, n' associates with
those rulez C-language actions n' additionizzle precedence shiznit.
Da grammar is busted lyrics bout below, n' a gangbangin' formal definition
bigs up.
.LP
Da rulez section is comprised of one or mo' grammar rulez fo' realz. A grammar
rule has tha form:
.sp
.RS
.nf

\fBA : BODY ;
\fP
.fi
.RE
.LP
Da symbol \fBA\fP represents a non-terminal name, n' \fBBODY\fP
represents a sequence of zero or mo' \fIname\fPs,
\fIliteral\fPs, n' \fIsemantic action\fPs dat can then be followed
by optionizzle \fIprecedence rule\fPs. Only tha names and
literals participate up in tha formation of tha grammar; tha semantic
actions n' precedence rulez is used up in other ways. Da colon
and tha semicolon is \fIyacc\fP punctuation. I aint talkin' bout chicken n' gravy biatch. If there be several
successive grammar rulez wit tha same left-hand side, the
vertical bar \fB'|'\fP can be used ta avoid rewritin tha left-hand
side; up in dis case tha semicolon appears only afta tha last
rule. Da BODY part can be empty (or empty of names n' literals)
to indicate dat tha non-terminal symbol matches tha empty
string.
.LP
Da \fIyacc\fP utilitizzle assigns a unique number ta each rule. Rules
usin tha vertical bar notation is distinct rules. The
number assigned ta tha rule appears up in tha description file.
.LP
Da elements comprisin a BODY are:
.TP 7
\fIname\fP,\ \fIliteral\fP
These form tha rulez of tha grammar: \fIname\fP is either a \fItoken\fP
or a \fInon-terminal\fP; \fIliteral\fP standz for
itself (less tha lexically required quotation marks).
.TP 7
\fIsemantic action\fP
.sp
With each grammar rule, tha user can associate actions ta be performed
each time tha rule is recognized up in tha input process. (Note
that tha word "action" can also refer ta tha actionz of tha parser-shift,
reduce, n' so on.) 
.LP
These actions can return joints n' can obtain tha joints returned
by previous actions. These joints is kept up in objectz of type
YYSTYPE (see \fB%union\fP). Da result value of tha action shall be
kept on tha parse stack wit tha left-hand side of tha rule,
to be accessed by other reductions as part of they right-hand side.
By rockin tha <\fItag\fP> shiznit provided up in the
declarations section, tha code generated by \fIyacc\fP can be strictly
type checked n' contain arbitrary shiznit. I aint talkin' bout chicken n' gravy biatch. In
addition, tha lexical analyzer can provide tha same kindz of joints
for tokens, if desired.
.LP
An action be a arbitrary C statement n' as such can do input or
output, call subprograms, n' alta external variablez fo' realz. An
action is one or mo' C statements enclosed up in curly braces \fB'{'\fP
and \fB'}'\fP .
.LP
Certain pseudo-variablez can be used up in tha action. I aint talkin' bout chicken n' gravy biatch. These is macros
for access ta data structures known internally to
\fIyacc\fP.
.TP 7
$$
.RS
Da value of tha action can be set by assignin it ta $$. If type
checkin is enabled n' tha type of tha value ta be assigned
cannot be determined, a gangbangin' finger-lickin' diagnostic message may be generated.
.RE
.TP 7
$\fInumber\fP
.RS
This refers ta tha value returned by tha component specified by the
token \fInumber\fP up in tha right side of a rule, reading
from left ta right; \fInumber\fP can be zero or negative. If \fInumber\fP
is zero or negative, it refers ta tha data associated
with tha name on tha parserz stack precedin tha leftmost symbol
of tha current rule. (That is, \fB"$0"\fP refers ta tha name
immediately precedin tha leftmost name up in tha current rule ta be
found on tha parserz stack n' \fB"$-1"\fP refers ta the
symbol ta \fIits\fP left.) If \fInumber\fP refers ta a element past
the current point up in tha rule, or beyond tha bottom of the
stack, tha result is undefined. Y'all KNOW dat shit, muthafucka! If type checkin is enabled n' the
type of tha value ta be assigned cannot be determined, a
diagnostic message may be generated.
.RE
.TP 7
$<\fItag\fP>\fInumber\fP
.RS
.sp
These correspond exactly ta tha correspondin symbols without the
\fItag\fP inclusion yo, but allow fo' strict type checkin (and
preclude unwanted type conversions). Da effect is dat tha macro
is expanded ta use \fItag\fP ta select a element from the
YYSTYPE union (usin \fIdataname.tag\fP). This is particularly useful
if \fInumber\fP aint positive.
.RE
.TP 7
$<\fItag\fP>$
.RS
This imposes on tha reference tha type of tha union member referenced
by \fItag\fP. This construction be applicable when a
reference ta a left context value occurs up in tha grammar, n' provides
\fIyacc\fP wit a means fo' selectin a type.
.RE
.sp
.LP
Actions can occur anywhere up in a rule (not just all up in tha end); a action
can access joints returned by actions ta its left, n' in
turn tha value it returns can be accessed by actions ta its right.
An action appearin up in tha middle of a rule shall be equivalent
to replacin tha action wit a freshly smoked up non-terminal symbol n' adding
an empty rule wit dat non-terminal symbol on tha left-hand
side. Da semantic action associated wit tha freshly smoked up rule shall be equivalent
to tha original gangsta action. I aint talkin' bout chicken n' gravy biatch. Da use of actions within rules
might introduce conflicts dat would not otherwise exist.
.LP
By default, tha value of a rule shall be tha value of tha straight-up original gangsta element
in dat shit. If tha straight-up original gangsta element aint gots a type
(particularly up in tha case of a literal) n' type checkin is turned
on by \fB%type\fP, a error message shall result.
.TP 7
\fIprecedence\fP
Da keyword \fB%prec\fP can be used ta chizzle tha precedence level
associated wit a particular grammar rule. Examplez of this
are up in cases where a unary n' binary operator have tha same symbolic
representation yo, but need ta be given different precedences,
or where tha handlin of a ambiguous if-else construction is necessary.
Da reserved symbol \fB%prec\fP can step tha fuck up immediately
afta tha body of tha grammar rule n' can be followed by a token
name or a literal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Well shiiiit, it shall cause tha precedence of tha grammar
rule ta become dat of tha followin token name or literal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da action
for tha rule as a whole can follow \fB%prec\fP.
.sp
.LP
If a program section bigs up, tha application shall ensure dat the
grammar rulez is terminated by \fB%%\fP.
.SS Programs Section
.LP
Da \fIprograms\fP section can include tha definizzle of tha lexical
analyzer \fIyylex\fP(), n' any other functions; for
example, dem used up in tha actions specified up in tha grammar rules.
It be unspecified whether tha programs section precedes or
bigs up tha semantic actions up in tha output file; therefore, if the
application gotz nuff any macro definitions n' declarations
intended ta apply ta tha code up in tha semantic actions, it shall place
them within \fB"%{\ ...\ %}"\fP up in the
declarations section.
.SS Input Grammar
.LP
Da followin input ta \fIyacc\fP yieldz a parser fo' tha input to
\fIyacc\fP. This formal syntax takes precedence over the
precedin text syntax description.
.LP
Da lexical structure is defined less precisely; Lexical Structure
of tha Grammar defines most
terms. Da correspondence between tha previous terms n' tha tokens
below be as bigs up.
.TP 7
\fBIDENTIFIER\fP
This correspondz ta tha concept of \fIname\fP, given previously. It
also includes literals as defined previously.
.TP 7
\fBC_IDENTIFIER\fP
This be a name, n' additionally it is known ta be followed by a cold-ass lil colon.
A literal cannot yield dis token.
.TP 7
\fBNUMBER\fP
A strang of digits (a non-negatizzle decimal integer).
.TP 7
\fBTYPE\fP,\ \fBLEFT\fP,\ \fBMARK\fP,\ \fBLCURL\fP,\ \fBRCURL\fP
.sp
These correspond directly ta \fB%type\fP, \fB%left\fP, \fB%%\fP, \fB%{\fP,
and \fB%}\fP.
.TP 7
\fB{\ ...\ }\fP
This indicates C-language source code, wit tha possible inclusion
of \fB'$'\fP macros as discussed previously.
.sp
.sp
.RS
.nf

\fB/* Grammar fo' tha input ta yacc. */
/* Basic entries. Put ya muthafuckin choppers up if ya feel dis! */
/* Da followin is recognized by tha lexical analyzer n' shit. */
.sp

%token    IDENTIFIER      /* Includes identifiers n' literals */
%token    C_IDENTIFIER    /* identifier (but not literal)
                             followed by a :. */
%token    NUMBER          /* [0-9][0-9]* */
.sp

/* Reserved lyrics : %type=>TYPE %left=>LEFT, n' so on */
.sp

%token    LEFT RIGHT NONASSOC TOKEN PREC TYPE START UNION
.sp

%token    MARK            /* Da %% mark. */
%token    LCURL           /* Da %{ mark. */
%token    RCURL           /* Da %} mark. */
.sp

/* 8-bit characta literals stand fo' theyselves; */
/* tokens gotta be defined fo' multi-byte characters. */
.sp

%start    spec
.sp

%%
.sp

spec  : defs MARK rulez tail
      ;
tail  : MARK
      {
        /* In dis action, set up tha rest of tha file. */
      }
      | /* Empty; tha second MARK is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. */
      ;
defs  : /* Empty. */
      |    defs def
      ;
def   : START IDENTIFIER
      |    UNION
      {
        /* Copy union definizzle ta output. */
      }
      |    LCURL
      {
        /* Copy C code ta output file. */
      }
        RCURL
      |    rword tag nlist
      ;
rword : TOKEN
      | LEFT
      | RIGHT
      | NONASSOC
      | TYPE
      ;
tag   : /* Empty: union tag ID optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. */
      | '<' IDENTIFIER '>'
      ;
nlist : nmno
      | nlist nmno
      ;
nmno  : IDENTIFIER         /* Note: literal invalid wit % type. */
      | IDENTIFIER NUMBER  /* Note: invalid wit % type. */
      ;
.sp

/* Rule section */
.sp

rulez : C_IDENTIFIER rbody prec
      | rulez  rule
      ;
rule  : C_IDENTIFIER rbody prec
      | '|' rbody prec
      ;
rbody : /* empty */
      | rbody IDENTIFIER
      | rbody act
      ;
act   : '{'
        {
          /* Copy action, translate $$, n' so on. I aint talkin' bout chicken n' gravy biatch. */
        }
        '}'
      ;
prec  : /* Empty */
      | PREC IDENTIFIER
      | PREC IDENTIFIER act
      | prec ';'
      ;
\fP
.fi
.RE
.SS Conflicts
.LP
Da parser produced fo' a input grammar may contain states up in which
conflicts occur. Shiiit, dis aint no joke. Da conflicts occur cuz tha grammar is
not LALR(1) fo' realz. An ambiguous grammar always gotz nuff at least one LALR(1)
conflict. Da \fIyacc\fP utilitizzle shall resolve all
conflicts, rockin either default rulez or user-specified precedence
rules.
.LP
Conflicts is either shift/reduce conflicts or reduce/reduce conflicts.
A shift/reduce conflict is where, fo' a given state and
lookahead symbol, both a gangbangin' finger-lickin' dirty-ass shift action n' a reduce action is possible.
A reduce/reduce conflict is where, fo' a given state and
lookahead symbol, reductions by two different rulez is possible.
.LP
Da rulez below describe how tha fuck ta specify what tha fuck actions ta take when
a conflict occurs. Not all shift/reduce conflicts can be
successfully resolved dis way cuz tha conflict may be due to
suttin' other than ambiguity, so incautious use of these
facilitizzles can cause tha language accepted by tha parser ta be much
different from dat which was intended. Y'all KNOW dat shit, muthafucka! Da description file
shall contain sufficient shiznit ta KNOW tha cause of the
conflict. Where ambiguitizzle is tha reason either tha default or
explicit rulez should be adequate ta produce a hustlin parser.
.LP
Da declared precedences n' associativitizzles (see Declarations Section
) is used ta resolve
parsin conflicts as bigs up:
.IP " 1." 4
A precedence n' associativitizzle be associated wit each grammar rule;
it is tha precedence n' associativitizzle of tha last token or
literal up in tha body of tha rule. If tha \fB%prec\fP keyword is used,
it overrides dis default. Right back up in yo muthafuckin ass. Some grammar rulez might not have
both precedence n' associativity.
.LP
.IP " 2." 4
If there be a gangbangin' finger-lickin' dirty-ass shift/reduce conflict, n' both tha grammar rule and
the input symbol have precedence n' associativitizzle associated
with them, then tha conflict is resolved up in favor of tha action (shift
or reduce) associated wit tha higher precedence. If the
precedences is tha same, then tha associativitizzle is used; left associative
implies reduce, right associatizzle implies shift, and
non-associatizzle implies a error up in tha strang bein parsed.
.LP
.IP " 3." 4
When there be a gangbangin' finger-lickin' dirty-ass shift/reduce conflict dat cannot be resolved by rule
2, tha shift is done. Conflicts resolved dis way are
counted up in tha diagnostic output busted lyrics bout up in Error Handlin .
.LP
.IP " 4." 4
When there be a reduce/reduce conflict, a reduction is done by the
grammar rule dat occurs earlier up in tha input sequence.
Conflicts resolved dis way is counted up in tha diagnostic output busted lyrics about
in Error Handlin .
.LP
.LP
Conflicts resolved by precedence or associativitizzle shall not be counted
in tha shift/reduce n' reduce/reduce conflicts reported
by \fIyacc\fP on either standard error or up in tha description file.
.SS Error Handling
.LP
Da token \fBerror\fP shall be reserved fo' error handling. Da name
\fBerror\fP can be used up in grammar rules. Well shiiiit, it indicates
places where tha parser can recover from a syntax error. Shiiit, dis aint no joke. Da default
value of \fBerror\fP shall be 256. Its value can be chizzled
usin a \fB%token\fP declaration. I aint talkin' bout chicken n' gravy biatch. Da lexical analyzer should not
return tha value of \fBerror\fP.
.LP
Da parser shall detect a syntax error when it is up in a state where
the action associated wit tha lookahead symbol is
\fBerror\fP fo' realz. A semantic action can cause tha parser ta initiate error
handlin by executin tha macro YYERROR. When YYERROR is
executed, tha semantic action passes control back ta tha parser n' shit. YYERROR
cannot be used outside of semantic actions.
.LP
When tha parser detects a syntax error, it normally calls \fIyyerror\fP()
with tha characta string
\fB"syntax\ error"\fP as its argument. Da call shall not be made
if tha parser is still recoverin from a previous error
when tha error is detected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da parser is considered ta be recovering
from a previous error until tha parser has shifted over at
least three aiiight input symbols since tha last error was detected
or a semantic action has executed tha macro \fIyyerrok\fP. The
parser shall not call \fIyyerror\fP() when YYERROR is executed.
.LP
Da macro function YYRECOVERING shall return 1 if a syntax error has
been detected n' tha parser has not yet straight-up recovered
from dat shit. Otherwise, zero shall be returned.
.LP
When a syntax error is detected by tha parser, tha parser shall check
if a previous syntax error has been detected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If a
previous error was detected, n' if no aiiight input symbols have been
shifted since tha precedin error was detected, tha parser
checks if tha lookahead symbol be a endmarker (see Interface ta the
Lexical Analyzer ). If it is,
the parser shall return wit a non-zero value. Otherwise, tha lookahead
symbol shall be discarded n' aiiight parsin shall
resume.
.LP
When YYERROR is executed or when tha parser detects a syntax error
and no previous error has been detected, or at least one
normal input symbol has been shifted since tha previous error was
detected, tha parser shall pop back one state at a time until the
parse stack is empty or tha current state allows a gangbangin' finger-lickin' dirty-ass shift over \fBerror\fP.
If tha parser emptizzles tha parse stack, it shall return
with a non-zero value. Otherwise, it shall shift over \fBerror\fP
and then resume aiiight parsing. If tha parser readz a lookahead
symbol before tha error was detected, dat symbol shall still be the
lookahead symbol when parsin is resumed.
.LP
Da macro \fIyyerrok\fP up in a semantic action shall cause tha parser
to act as if it has straight-up recovered from any previous
errors. Da macro \fIyyclearin\fP shall cause tha parser ta discard
the current lookahead token. I aint talkin' bout chicken n' gravy biatch. If tha current lookahead token
has not yet been read, \fIyyclearin\fP shall have no effect.
.LP
Da macro YYACCEPT shall cause tha parser ta return wit tha value
zero. Da macro YYABORT shall cause tha parser ta return with
a non-zero value.
.SS Interface ta tha Lexical Analyzer
.LP
Da \fIyylex\fP() function be a integer-valued function dat returns
a \fItoken number\fP representin tha kind of token
read. Y'all KNOW dat shit, muthafucka! If there be a value associated wit tha token returned by \fIyylex\fP()
(see tha rap of \fItag\fP above), it shall
be assigned ta tha external variable \fIyylval\fP.
.LP
If tha parser n' \fIyylex\fP() do not smoke on these token numbers,
reliable communication between dem cannot occur. Shiiit, dis aint no joke. For
(single-byte character) literals, tha token is simply tha numeric
value of tha characta up in tha current characta set. Da numbers
for other tokens can either be chosen by \fIyacc\fP, or chosen by
the user n' shit. In either case, tha \fB#define\fP construct of C is
used ta allow \fIyylex\fP() ta return these numbers symbolically.
Da \fB#define\fP statements is put tha fuck into tha code file, and
the header file if dat file is requested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da set of charactas permitted
by \fIyacc\fP up in a identifier is larger than that
permitted by C. Token names found ta contain such charactas shall
not be included up in tha \fB#define\fP declarations.
.LP
If tha token numbers is chosen by \fIyacc\fP, tha tokens other than
literals shall be assigned numbers pimped outa than 256,
although no order is implied. Y'all KNOW dat shit, muthafucka! A token can be explicitly assigned a
number by followin its first appearizzle up in tha declarations
section wit a number n' shit. Names n' literals not defined dis way retain
their default definition. I aint talkin' bout chicken n' gravy biatch fo' realz. All token numbers assigned by
\fIyacc\fP shall be unique n' distinct from tha token numbers used
for literals n' user-assigned tokens. If duplicate token
numbers cause conflicts up in parser generation, \fIyacc\fP shall report
an error; otherwise, it is unspecified whether tha token
assignment be accepted or a error is reported.
.LP
Da end of tha input is marked by a special token called tha \fIendmarker\fP,
which has a token number dat is zero or
negative. (These joints is invalid fo' any other token.) All lexical
analyzers shall return zero or wack as a token number
upon reachin tha end of they input. If tha tokens up ta yo, but excluding,
the endmarker form a structure dat matches tha start
symbol, tha parser shall accept tha input. If tha endmarker is seen
in any other context, it shall be considered a error.
.SS Completin tha Program
.LP
In addizzle ta \fIyyparse\fP() n' \fIyylex\fP(), tha functions \fIyyerror\fP()
and \fImain\fP() is required ta make a
complete program. Da application can supply \fImain\fP() n' \fIyyerror\fP(),
or dem routines can be obtained from the
\fIyacc\fP library.
.SS Yacc Library
.LP
Da followin functions shall step tha fuck up only up in tha \fIyacc\fP library
accessible all up in tha \fB-l\ y\fP operand ta \fIc99\fP; they can
therefore be redefined by a cold-ass lil conformin application:
.TP 7
\fBint\ \fP \fImain\fP(\fBvoid\fP)
.sp
This function shall call \fIyyparse\fP() n' exit wit a unspecified
value. Other actions within dis function are
unspecified.
.TP 7
\fBint\ \fP \fIyyerror\fP(\fBconst\ char\fP\ *\fIs\fP)
.sp
This function shall write tha NUL-terminated argument ta standard
error, followed by a <newline>.
.sp
.LP
Da order of tha \fB-l\ y\fP n' \fB-l\ l\fP operandz given ta \fIc99\fP
is
significant; tha application shall either provide its own \fImain\fP()
function or ensure dat \fB-l\ y\fP precedes
\fB-l\ l\fP.
.SS Debuggin tha Parser
.LP
Da parser generated by \fIyacc\fP shall have diagnostic facilities
in it dat can be optionally enabled at either compile time
or at runtime (if enabled at compile time). Da compilation of the
runtime debuggin code is under tha control of YYDEBUG, a
preprocessor symbol. If YYDEBUG has a non-zero value, tha debugging
code shall be included. Y'all KNOW dat shit, muthafucka! If its value is zero, tha code shall
not be included.
.LP
In parsers where tha debuggin code has been included, tha external
\fBint\fP \fIyydebug\fP can be used ta turn debuggin on
(with a non-zero value) n' off (zero value) at runtime. Da initial
value of \fIyydebug\fP shall be zero.
.LP
When \fB-t\fP is specified, tha code file shall be built such that,
if YYDEBUG aint already defined at compilation time
(usin tha \fIc99\fP \fB-D\fP YYDEBUG option, fo' example), YYDEBUG
shall be set explicitly
to 1. When \fB-t\fP aint specified, tha code file shall be built
such that, if YYDEBUG aint already defined, it shall be set
explicitly ta zero.
.LP
Da format of tha debuggin output is unspecified but includes at
least enough shiznit ta determine tha shift n' reduce
actions, n' tha input symbols. Well shiiiit, it also serves up shiznit about
error recovery.
.SS Algorithms
.LP
Da parser constructed by \fIyacc\fP implements a LALR(1) parsing
algorithm as documented up in tha literature. Well shiiiit, it is unspecified
whether tha parser is table-driven or direct-coded.
.LP
A parser generated by \fIyacc\fP shall never request a input symbol
from \fIyylex\fP() while up in a state where tha only
actions other than tha error action is reductions by a single rule.
.LP
Da literature of parsin theory defines these concepts.
.SS Limits
.LP
Da \fIyacc\fP utilitizzle may have nuff muthafuckin internal tables. Da minimum
maximums fo' these tablez is shown up in tha following
table. Da exact meanin of these joints is implementation-defined.
Da implementation shall define tha relationshizzle between these
values n' between dem n' any error lyrics dat tha implementation
may generate should it run outta space fo' any internal
structure fo' realz. An implementation may combine crewz of these resources
into a single pool as long as tha total available ta tha user
does not fall below tha sum of tha sizes specified by dis section.
.br
.sp
.ce 1
\fBTable: Internal Limits up in \fIyacc\fP\fP
.TS C
center; l l lw(40).
\fB\ \fP	\fBMinimum\fP	T{
.na
\fB\ \fP
.ad
T}
\fBLimit\fP	\fBMaximum\fP	T{
.na
\fBDescription\fP
.ad
T}
{NTERMS}	126	T{
.na
Number of tokens.
.ad
T}
{NNONTERM}	200	T{
.na
Number of non-terminals.
.ad
T}
{NPROD}	300	T{
.na
Number of rules.
.ad
T}
{NSTATES}	600	T{
.na
Number of states.
.ad
T}
{MEMSIZE}	5200	T{
.na
Length of rules. Da total length, up in names (tokens n' non-terminals), of all tha rulez of tha grammar. Shiiit, dis aint no joke. Da left-hand side is counted fo' each rule, even if it aint explicitly repeated, as specified up in Grammar Rulez up in yacc .
.ad
T}
{ACTSIZE}	4000	T{
.na
Number of actions. "Actions" here (and up in tha description file) refer ta parser actions (shift, reduce, n' so on) not ta semantic actions defined up in Grammar Rulez up in yacc .
.ad
T}
.TE
.SH EXIT STATUS
.LP
Da followin exit joints shall be returned:
.TP 7
\ 0
Successful completion.
.TP 7
>0
An error occurred.
.sp
.SH CONSEQUENCES OF ERRORS
.LP
If any errors is encountered, tha run be aborted n' \fIyacc\fP exits
with a non-zero status. Partial code filez n' header
filez may be produced. Y'all KNOW dat shit, muthafucka! Da summary shiznit up in tha description
file shall always be produced if tha \fB-v\fP flag is
present.
.LP
\fIDa followin sections is informative.\fP
.SH APPLICATION USAGE
.LP
Oldschool implementations experience name conflicts on tha names
\fByacc.tmp\fP, \fByacc.acts\fP, \fByacc.debug\fP,
\fBy.tab.c\fP, \fBy.tab.h\fP, n' \fBy.output\fP if mo' than one
copy of \fIyacc\fP is hustlin up in a single directory at one
time. Da \fB-b\fP option was added ta overcome dis problem. The
related problem of allowin multiple \fIyacc\fP parsers ta be
placed up in tha same file was addressed by addin a \fB-p\fP option
to override tha previously hard-coded \fByy\fP variable
prefix.
.LP
Da description of tha \fB-p\fP option specifies tha minimal set of
function n' variable names dat cause conflict when
multiple parsers is linked together n' shit. YYSTYPE do not need ta be
changed. Y'all KNOW dat shit, muthafucka! Instead, tha programmer can use \fB-b\fP ta give the
header filez fo' different parsers different names, n' then tha file
with tha \fIyylex\fP() fo' a given parser can include the
header fo' dat parser n' shit. Names like fuckin \fIyyclearerr\fP do not need
to be chizzled cuz they is used only up in tha actions; they
do not have linkage. Well shiiiit, it is possible dat a implementation has other
names, either internal ones fo' implementin thangs such as
\fIyyclearerr\fP, or providin non-standard features dat it wants
to chizzle wit \fB-p\fP.
.LP
Unary operators dat is tha same token as a funky-ass binary operator up in general
need they precedence adjusted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This is handled by the
\fB%prec\fP advisory symbol associated wit tha particular grammar
rule definin dat unary operator. Shiiit, dis aint no joke. (See Grammar Rulez up in yacc .) Applications
are not required ta use dis operator fo' unary operators yo, but the
grammars dat do not require it is rare.
.SH EXAMPLES
.LP
Access ta tha \fIyacc\fP library is obtained wit library search operands
to \fIc99\fP. To
use tha \fIyacc\fP library \fImain\fP():
.sp
.RS
.nf

\fBc99 y.tab.c -l y
\fP
.fi
.RE
.LP
Both tha \fIlex\fP library n' tha \fIyacc\fP library contain \fImain\fP().
To access the
\fIyacc\fP \fImain\fP():
.sp
.RS
.nf

\fBc99 y.tab.c lex.yy.c -l y -l l
\fP
.fi
.RE
.LP
This ensures dat tha \fIyacc\fP library is searched first, so that
its \fImain\fP() is used.
.LP
Da oldschool \fIyacc\fP libraries have contained two simple functions
that is normally coded by tha application programmer.
These functions is similar ta tha followin code:
.sp
.RS
.nf

\fB#include <locale.h>
int main(void)
{
    extern int yyparse();
.sp

    setlocale(LC_ALL, "");
.sp

    /* If tha followin parser is one pimped by lex, the
       application must be careful ta ensure dat LC_CTYPE
       n' LC_COLLATE is set ta tha POSIX locale. */
    (void) yyparse();
    return (0);
}
.sp

#include <stdio.h>
.sp

int yyerror(const char *msg)
{
    (void) fprintf(stderr, "%s\\n", msg);
    return (0);
}
\fP
.fi
.RE
.SH RATIONALE
.LP
Da references up in may be helpful up in constructin tha parser generator.
Da referenced DeRemer n' Pennello article (along with
the works it references) raps on some technique ta generate parsers
that conform ta dis volume of IEEE\ Std\ 1003.1-2001.
Work up in dis area continues ta be done, so implementors should consult
current literature before bustin any freshly smoked up implementations. The
original gangsta Knuth article is tha theoretical basis fo' dis kind of parser,
but tha tablez it generates is impractically big-ass for
reasonable grammars n' should not be used. Y'all KNOW dat shit, muthafucka! Da "equivalent to" wording
is intentionizzle ta assure dat tha dopest tablez dat are
LALR(1) can be generated.
.LP
There has been mad drama between tha class of grammars, tha algorithms
needed ta generate parsers, n' tha algorithms needed to
parse tha languages. They is all reasonably orthogonal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. In particular,
a parser generator dat accepts tha full range of LR(1)
grammars need not generate a table any mo' complex than one that
accepts SLR(1) (a relatively weak class of LR grammars) fo' a
grammar dat happens ta be SLR(1). Right back up in yo muthafuckin ass. Such a implementation need not
recognize tha case, either; table compression can yield the
SLR(1) table (or one even smalla than that) without recognizin that
the grammar is SLR(1). Da speed of a LR(1) parser fo' any
class is dependent mo' upon tha table representation n' compression
(or tha code generation if a gangbangin' finger-lickin' direct parser is generated) than
upon tha class of grammar dat tha table generator handles.
.LP
Da speed of tha parser generator is somewhat dependent upon tha class
of grammar it handles. But fuck dat shiznit yo, tha word on tha street is dat tha original gangsta Knuth
article algorithms fo' constructin LR parsers was judged by its
lyricist ta be impractically slow at dat time fo' realz. Although full LR is
more complex than LALR(1), as computa speedz n' algorithms improve,
the difference (in termz of aaight wall-clock execution
time) is becomin less significant.
.LP
Potential authors is cautioned dat tha referenced DeRemer n' Pennello
article previously cited identifies a funky-ass bug (an
over-simplification of tha computation of LALR(1) lookahead sets)
in a shitload of tha LALR(1) algorithm statements dat preceded it to
publication. I aint talkin' bout chicken n' gravy biatch. They should take tha time ta seek up dat paper, as
well as current relevant work, particularly Aho's.
.LP
Da \fB-b\fP option was added ta provide a portable method fo' permitting
\fIyacc\fP ta work on multiple separate parsers in
the same directory. If a gangbangin' finger-lickin' directory gotz nuff mo' than one \fIyacc\fP
grammar, n' both grammars is constructed all up in tha same time
(by, fo' example, a parallel \fImake\fP program), conflict thangs up in dis biatch.
While tha solution is not
historical practice, it erects a known deficiency up in historical
implementations. Correspondin chizzlez was made ta all sections
that referenced tha filenames \fBy.tab.c\fP (now "the code file"),
\fBy.tab.h\fP (now "the header file"), n' \fBy.output\fP
(now "the description file").
.LP
Da grammar fo' \fIyacc\fP input is based on System V documentation.
Da textual description shows there dat tha \fB';'\fP
is required all up in tha end of tha rule. Da grammar n' tha implementation
do not require all dis bullshit. (Da use of \fBC_IDENTIFIER\fP causes
a reduce ta occur up in tha right place.)
.LP
Also, up in dat implementation, tha constructs like fuckin \fB%token\fP
can be terminated by a semicolon yo, but dis aint permitted
by tha grammar. Shiiit, dis aint no joke. Da keywordz like fuckin \fB%token\fP can also appear
in uppercase, which be again n' again n' again not discussed. Y'all KNOW dat shit, muthafucka! In most places where
\fB'%'\fP is used, \fB'\\'\fP can be substituted, n' there be alternate
spellings fo' a shitload of tha symbols (for example,
\fB%LEFT\fP can be \fB"%<"\fP or even \fB"\\<"\fP ).
.LP
Historically, <\fItag\fP> can contain any charactas except \fB'>'\fP,
includin white space, up in the
implementation. I aint talkin' bout chicken n' gravy biatch. But fuck dat shiznit yo, tha word on tha street is dat since tha \fItag\fP must reference a ISO\ C
standard union member, up in practice conforming
implementations need ta support only tha set of charactas fo' ISO\ C
standard identifiers up in dis context.
.LP
Some oldschool implementations is known ta accept actions dat are
terminated by a period. Y'all KNOW dat shit, muthafucka! Oldschool implementations often
allow \fB'$'\fP up in names fo' realz. A conformin implementation do not need
to support either of these behaviors.
.LP
Decidin when ta use \fB%prec\fP illustrates tha hang-up up in specifying
the behavior of \fIyacc\fP. There may be thangs
in which tha \fIgrammar\fP is not, strictly bustin lyrics, up in error, and
yet \fIyacc\fP cannot interpret it unambiguously. The
resolution of ambiguitizzles up in tha grammar can up in nuff instances be
resolved by providin additionizzle shiznit, like fuckin using
\fB%type\fP or \fB%union\fP declarations. Well shiiiit, it is often easier n' it
usually yieldz a smalla parser ta take dis alternatizzle when
it be appropriate.
.LP
Da size n' execution time of a program produced without tha runtime
debuggin code is probably smalla n' slightly fasta in
historical implementations.
.LP
Statistics lyrics from nuff muthafuckin oldschool implementations include
the followin typez of shiznit:
.sp
.RS
.nf

\fIn\fP\fB/512 terminals,\fP \fIn\fP\fB/300 non-terminals
\fP\fIn\fP\fB/600 grammar rules,\fP \fIn\fP\fB/1500 states
\fP\fIn\fP \fBshift/reduce,\fP \fIn\fP \fBreduce/reduce conflicts reported
\fP\fIn\fP\fB/350 hustlin sets used
Memory: states, etc.\fP \fIn\fP\fB/15000, parser\fP \fIn\fP\fB/15000
\fP\fIn\fP\fB/600 distinct lookahead sets
\fP\fIn\fP \fBextra closures
\fP\fIn\fP \fBshift entries,\fP \fIn\fP \fBexceptions
\fP\fIn\fP \fBgoto entries
\fP\fIn\fP \fBentries saved by goto default
Optimizer space used: input\fP \fIn\fP\fB/15000, output\fP \fIn\fP\fB/15000
\fP\fIn\fP \fBtable entries,\fP \fIn\fP \fBzero
Maximum spread:\fP \fIn\fP\fB, Maximum offset:\fP \fIn\fP
.fi
.RE
.LP
Da report of internal tablez up in tha description file is left implementation-defined
because all aspectz of these limits are
also implementation-defined. Y'all KNOW dat shit, muthafucka! Some implementations may use dynamic
allocation steez n' have no specific limit joints to
report.
.LP
Da format of tha \fBy.output\fP file aint given cuz justification
of tha format was not peeped ta enhizzle applications
portability. Da listin is primarily intended ta help human users
understand n' debug tha parser; use of \fBy.output\fP by a
conformin application script would be unusual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Furthermore, implementations
have not produced consistent output n' no popular
format was apparent. Da format selected by tha implementation should
be human-readable, up in addizzle ta tha requirement dat it be
a text file.
.LP
Standard error reports is not specifically busted lyrics bout cuz they
are seldom of use ta conformin applications n' there was no
reason ta restrict implementations.
.LP
Some implementations recognize \fB"={"\fP as equivalent ta \fB'{'\fP
because it appears up in oldschool documentation. I aint talkin' bout chicken n' gravy biatch. This
construction was recognized n' documented as obsolete as long ago
as 1978, up in tha referenced \fIYacc: Yet Another
Compiler-Compiler\fP. This volume of IEEE\ Std\ 1003.1-2001 chose
to leave it as obsolete n' omit dat shit.
.LP
Multi-byte charactas should be recognized by tha lexical analyzer
and returned as tokens. They should not be returned as
multi-byte characta literals. Da token \fBerror\fP dat is used
for error recovery is normally assigned tha value 256 up in the
historical implementation. I aint talkin' bout chicken n' gravy biatch. Thus, tha token value 256, which is used
in nuff multi-byte characta sets, aint available fo' use as
the value of a user-defined token.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIc99\fP, \fIlex\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
