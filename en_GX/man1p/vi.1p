.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "VI" 1P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" vi 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
vi \- screen-oriented (visual) display editor
.SH SYNOPSIS
.LP
\fBvi\fP \fB[\fP\fB-rR\fP\fB][\fP\fB-c\fP \fIcommand\fP\fB][\fP\fB-t\fP
\fItagstring\fP\fB][\fP\fB-w\fP \fIsize\fP\fB][\fP\fIfile\fP \fB...\fP\fB]\fP\fB\fP
.SH DESCRIPTION
.LP
This utilitizzle shall be provided on systems dat both support tha User
Portabilitizzle Utilitizzles option n' define the
POSIX2_CHAR_TERM symbol. On other systems it is optional.
.LP
Da \fIvi\fP (visual) utilitizzle be a screen-oriented text editor. Shiiit, dis aint no joke. Only
the open n' visual modez of tha editor is busted lyrics bout in
IEEE\ Std\ 1003.1-2001; peep tha line editor \fIex\fP fo' additional
editing
capabilitizzles used up in \fIvi\fP. Da user can switch back n' forth
between \fIvi\fP n' \fIex\fP n' execute \fIex\fP commandz from within
\fIvi\fP.
.LP
This reference page uses tha term \fIedit buffer\fP ta describe the
current hustlin text. No specific implementation is implied
by dis term fo' realz. All editin chizzlez is performed on tha edit buffer,
and no chizzlez ta it shall affect any file until a editor
command writes tha file.
.LP
When rockin \fIvi\fP, tha terminal screen acts as a window tha fuck into the
editin buffer n' shit. Chizzlez made ta tha editin buffer shall be
reflected up in tha screen display; tha posizzle of tha cursor on the
screen shall indicate tha posizzle within tha editing
buffer.
.LP
Certain terminals aint gots all tha capabilitizzles necessary ta support
the complete \fIvi\fP definition. I aint talkin' bout chicken n' gravy biatch. When these commands
cannot be supported on such terminals, dis condizzle shall not produce
an error message like fuckin "not a editor command" or
report a syntax error. Shiiit, dis aint no joke. Da implementation may either accept tha commands
and produce thangs up in dis biatch on tha screen dat is tha result of
an unsuccessful attempt ta hook up tha requirementz of dis volume of
IEEE\ Std\ 1003.1-2001 or report a error describin the
terminal-related deficiency.
.SH OPTIONS
.LP
Da \fIvi\fP utilitizzle shall conform ta tha Base Definitions volume
of IEEE\ Std\ 1003.1-2001, Section 12.2, Utilitizzle Syntax Guidelines.
.LP
Da followin options shall be supported:
.TP 7
\fB-c\ \fP \fIcommand\fP
See tha \fIex\fP command description of tha \fB-c\fP option.
.TP 7
\fB-r\fP
See tha \fIex\fP command description of tha \fB-r\fP option.
.TP 7
\fB-R\fP
See tha \fIex\fP command description of tha \fB-R\fP option.
.TP 7
\fB-t\ \fP \fItagstring\fP
See tha \fIex\fP command description of tha \fB-t\fP option.
.TP 7
\fB-w\ \fP \fIsize\fP
See tha \fIex\fP command description of tha \fB-w\fP option.
.sp
.SH OPERANDS
.LP
See tha OPERANDS section of tha \fIex\fP command fo' a thugged-out description
of tha operandz supported
by tha \fIvi\fP command.
.SH STDIN
.LP
If standard input aint a terminal device, tha thangs up in dis biatch is undefined.
Da standard input consistz of a seriez of commandz and
input text, as busted lyrics bout up in tha EXTENDED DESCRIPTION section.
.LP
If a read from tha standard input returns a error, or if tha editor
detects a end-of-file condizzle from tha standard input,
it shall be equivalent ta a SIGHUP asynchronous event.
.SH INPUT FILES
.LP
See tha INPUT FILES section of tha \fIex\fP command fo' a thugged-out description
of tha input files
supported by tha \fIvi\fP command.
.SH ENVIRONMENT VARIABLES
.LP
See tha ENVIRONMENT VARIABLES section of tha \fIex\fP command for
the environment variables
that affect tha execution of tha \fIvi\fP command.
.SH ASYNCHRONOUS EVENTS
.LP
See tha ASYNCHRONOUS EVENTS section of tha \fIex\fP fo' tha asynchronous
events dat affect
the execution of tha \fIvi\fP command.
.SH STDOUT
.LP
If standard output aint a terminal device, undefined thangs up in dis biatch occur.
.LP
Standard output may be used fo' freestylin prompts ta tha user, fo' shiznital
lyrics, n' fo' freestylin lines from the
file.
.SH STDERR
.LP
If standard output aint a terminal device, undefined thangs up in dis biatch occur.
.LP
Da standard error shall be used only fo' diagnostic lyrics.
.SH OUTPUT FILES
.LP
See tha OUTPUT FILES section of tha \fIex\fP command fo' a thugged-out description
of tha output files
supported by tha \fIvi\fP command.
.SH EXTENDED DESCRIPTION
.LP
If tha terminal aint gots tha capabilitizzles necessary ta support
an unspecified portion of tha \fIvi\fP definition,
implementations shall start initially up in \fIex\fP mode or open mode.
Otherwise, after
initialization, \fIvi\fP shall be up in command mode; text input mode
can be entered by one of nuff muthafuckin commandz used ta bang or
change text. In text input mode, <ESC> can be used ta return ta command
mode; other usez of <ESC> is busted lyrics bout later
in dis section; peep Terminizzle Command or Input Mode .
.SS Initialization up in ex n' vi
.LP
See \fIInitialization up in ex n' vi\fP fo' a thugged-out description of \fIex\fP
and \fIvi\fP initialization fo' tha \fIvi\fP utility.
.SS Command Descriptions up in vi
.LP
Da followin symbols is used up in dis reference page ta represent
arguments ta commands.
.TP 7
\fIbuffer\fP
See tha description of \fIbuffer\fP up in tha EXTENDED DESCRIPTION section
of tha \fIex\fP
utility; peep \fICommand Descriptions up in ex\fP . 
.LP
In open n' visual mode, when a cold-ass lil command synopsis shows both [ \fIbuffer\fP]
and [ \fIcount\fP] precedin tha command name,
they can be specified up in either order.
.TP 7
\fIcount\fP
A positizzle integer used as a optionizzle argument ta most commands,
either ta give a repeat count or as a size. This argument is
optionizzle n' shall default ta 1 unless otherwise specified. Y'all KNOW dat shit, muthafucka! 
.LP
Da Synopsis lines fo' tha \fIvi\fP commandz <control>-G, <control>-L,
<control>-R, <control>-],
\fB%\fP, \fB&\fP, \fB^\fP, \fBD\fP, \fBm\fP, \fBM\fP, \fBQ\fP, \fBu\fP,
\fBU\fP, n' \fBZZ\fP do not have
\fIcount\fP as a optionizzle argument. Regardless, it shall not be an
error ta specify a \fIcount\fP ta these commands, n' any
specified \fIcount\fP shall be ignored.
.TP 7
\fImotion\fP
An optionizzle trailin argument used by tha \fB!\fP, \fB<\fP, \fB>\fP,
\fBc\fP, \fBd\fP, n' \fBy\fP commands, which
is used ta indicate tha region of text dat shall be affected by the
command. Y'all KNOW dat shit, muthafucka! Da motion can be either one of tha command
charactas repeated or one of nuff muthafuckin other \fIvi\fP commandz (listed
in tha followin table). Each of tha applicable commands
specifies tha region of text matched by repeatin tha command; each
command dat can be used as a motion command specifies the
region of text it affects, n' you can put dat on yo' toast. 
.LP
Commandz dat take \fImotion\fP arguments operate on either lines
or characters, dependin on tha circumstances. When operating
on lines, all lines dat fall partially or wholly within tha text
region specified fo' tha command shall be affected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. When
operatin on characters, only tha exact charactas up in tha specified
text region shall be affected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Each motion command specifies
this individually.
.LP
When commandz dat may be motion commandz is not used as motion commands,
they shall set tha current posizzle ta tha current
line n' column as specified.
.LP
Da followin commandz shall be valid cursor motion commands:
.sp
.RS
.nf

\fB<apostrophe>       (    -    j    H
<carriage-return>  )    $    k    L
<comma>            [[   %    l    M
<control>-H        ]]   _    n    N
<control>-N        {    ;    t    T
<control>-P        }    ?    w    W
<grave accent>     ^    b    B
<newline>          +    e    E
<space>            |    f    F
<zero>             /    h    G
\fP
.fi
.RE
.LP
Any \fIcount\fP dat is specified ta a cold-ass lil command dat has a associated
motion command shall be applied ta tha motion command. Y'all KNOW dat shit, muthafucka! If
a \fIcount\fP be applied ta both tha command n' its associated motion
command, tha effect shall be multiplicative.
.sp
.LP
Da followin symbols is used up in dis section ta specify locations
in tha edit buffer:
.TP 7
\fIcurrent\ character\fP
.sp
Da characta dat is currently indicated by tha cursor.
.TP 7
\fIend\ of\ a\ line\fP
.sp
Da point located between tha last non- <newline> (if any) n' the
terminatin <newline> of a line. For a empty line,
this location coincides wit tha beginnin of tha line.
.TP 7
\fIend\ of\ the\ edit\ buffer\fP
.sp
Da location correspondin ta tha end of tha last line up in tha edit
buffer.
.sp
.LP
Da followin symbols is used up in dis section ta specify command
actions:
.TP 7
\fIbigword\fP
In tha POSIX locale, \fIvi\fP shall recognize four kindz of \fIbigwords\fP:
.RS
.IP " 1." 4
A maximal sequence of non- <blank>s preceded n' followed by <blank>s
or tha beginnin or end of a line or tha edit
buffer
.LP
.IP " 2." 4
One or mo' sequential blank lines
.LP
.IP " 3." 4
Da first characta up in tha edit buffer
.LP
.IP " 4." 4
Da last non- <newline> up in tha edit buffer
.LP
.RE
.TP 7
\fIword\fP
In tha POSIX locale, \fIvi\fP shall recognize five kindz of lyrics:
.RS
.IP " 1." 4
A maximal sequence of letters, digits, n' underscores, delimited
at both endz by:
.RS
.IP " *" 3
Charactas other than letters, digits, or underscores
.LP
.IP " *" 3
Da beginnin or end of a line
.LP
.IP " *" 3
Da beginnin or end of tha edit buffer
.LP
.RE
.LP
.IP " 2." 4
A maximal sequence of charactas other than letters, digits, underscores,
or <blank>s, delimited at both endz by:
.RS
.IP " *" 3
A letter, digit, underscore
.LP
.IP " *" 3
<blank>s
.LP
.IP " *" 3
Da beginnin or end of a line
.LP
.IP " *" 3
Da beginnin or end of tha edit buffer
.LP
.RE
.LP
.IP " 3." 4
One or mo' sequential blank lines
.LP
.IP " 4." 4
Da first characta up in tha edit buffer
.LP
.IP " 5." 4
Da last non- <newline> up in tha edit buffer
.LP
.RE
.TP 7
\fIsection\ boundary\fP
.sp
A \fIsection boundary\fP is one of tha following: 
.RS
.IP " 1." 4
A line whose first characta be a <form-feed>
.LP
.IP " 2." 4
A line whose first characta be a open curly brace ( \fB'{'\fP )
.LP
.IP " 3." 4
A line whose first characta be a period n' whose second n' third
charactas match a two-characta pair up in tha \fBsections\fP
edit option (see \fIed\fP)
.LP
.IP " 4." 4
A line whose first characta be a period n' whose only other character
matches tha straight-up original gangsta characta of a two-characta pair in
the \fBsections\fP edit option, where tha second characta of the
two-characta pair be a <space>
.LP
.IP " 5." 4
Da first line of tha edit buffer
.LP
.IP " 6." 4
Da last line of tha edit buffer if tha last line of tha edit buffer
is empty or if it aint nuthin but a \fB]]\fP or \fB}\fP command;
otherwise, tha last non- <newline> of tha last line of tha edit buffer
.LP
.RE
.TP 7
\fIparagraph\ boundary\fP
.sp
A \fIparagraph boundary\fP is one of tha following: 
.RS
.IP " 1." 4
A section boundary
.LP
.IP " 2." 4
A line whose first characta be a period n' whose second n' third
charactas match a two-characta pair up in the
\fBparagraphs\fP edit option (see \fIed\fP)
.LP
.IP " 3." 4
A line whose first characta be a period n' whose only other character
matches tha straight-up original gangsta characta of a two-characta pair in
the \fIparagraphs\fP edit option, where tha second characta of the
two-characta pair be a <space>
.LP
.IP " 4." 4
One or mo' sequential blank lines
.LP
.RE
.TP 7
\fIremembered\ search\ direction\fP
.sp
See tha description of \fIremembered search direction\fP up in \fIed\fP.
.TP 7
\fIsentence\ boundary\fP
.sp
A \fIsentence boundary\fP is one of tha following: 
.RS
.IP " 1." 4
A paragraph boundary
.LP
.IP " 2." 4
Da first non- <blank> dat occurs afta a paragraph boundary
.LP
.IP " 3." 4
Da first non- <blank> dat occurs afta a period ( \fB'.'\fP ), exclamation
mark ( \fB'!'\fP ), or question mark (
\fB'?'\fP ), followed by two <space>s or tha end of a line; any number
of closin parenthesis ( \fB')'\fP ), closing
brackets ( \fB']'\fP ), double quote ( \fB' ),'\fP or single quote
( \fB'"\fP ) charactas can step tha fuck up between the
punctuation mark n' tha two <space>s or end-of-line
.LP
.RE
.sp
.LP
In tha remainder of tha description of tha \fIvi\fP utility, tha term
"buffer line" refers ta a line up in tha edit buffer and
the term "display line" refers ta tha line or lines on tha display
screen used ta display one buffer line. Da term "current
line" refers ta a specific "buffer line".
.LP
If there be display lines on tha screen fo' which there be no corresponding
buffer lines cuz they correspond ta lines that
would be afta tha end of tha file, they shall be displayed as a single
tilde ( \fB'~'\fP ) character, plus tha terminating
<newline>.
.LP
Da last line of tha screen shall be used ta report errors or display
informationizzle lyrics. Well shiiiit, it shall also be used ta display
the input fo' "line-oriented commands" ( \fB/\fP, \fB?\fP, \fB:\fP,
and \fB!\fP). When a line-oriented command is executed,
the editor shall enta text input mode on tha last line on tha screen,
usin tha respectizzle command charactas as prompt
characters. (In tha case of tha \fB!\fP command, tha associated motion
shall be entered by tha user before tha editor entas text
input mode.) Da line entered by tha user shall be terminated by a
<newline>, a non- <control>-V-escaped
<carriage-return>, or unescaped <ESC>. Well shiiiit, it is unspecified if mo' characters
than require a gangbangin' finger-lickin' display width minus one
column number of screen columns can be entered.
.LP
If any command is executed dat overwrites a portion of tha screen
other than tha last line of tha screen (for example, tha \fIex\fP
\fBsuspend\fP or \fB!\fP commands), other than tha \fIex\fP \fBshell\fP
command, tha user shall be prompted fo' a cold-ass lil characta before tha screen
is
refreshed n' tha edit session continued.
.LP
<tab>s shall take up tha number of columns on tha screen set by the
\fBtabstop\fP edit option (see \fIed\fP), unless there be less than
that number of columns before tha display margin dat will cause
the displayed line ta be folded; up in dis case, they shall only take
up tha number of columns up ta dat boundary.
.LP
Da cursor shall be placed on tha current line n' relatizzle ta the
current column as specified by each command busted lyrics bout up in the
followin sections.
.LP
In open mode, if tha current line aint already displayed, then it
shall be displayed.
.LP
In visual mode, if tha current line aint displayed, then tha lines
that is displayed shall be expanded, scrolled, or redrawn
to cause a unspecified portion of tha current line ta be displayed.
If tha screen is redrawn, no mo' than tha number of display
lines specified by tha value of tha \fBwindow\fP edit option shall
be displayed (unless tha current line cannot be straight-up
displayed up in tha number of display lines specified by tha \fBwindow\fP
edit option) n' tha current line shall be positioned as
close ta tha centa of tha displayed lines as possible (within the
constraints imposed by tha distizzle of tha line from the
beginnin or end of tha edit buffer). If tha current line is before
the first line up in tha display n' tha screen is scrolled, an
unspecified portion of tha current line shall be placed on tha first
line of tha display. If tha current line be afta tha last
line up in tha display n' tha screen is scrolled, a unspecified portion
of tha current line shall be placed on tha last line of the
display.
.LP
In visual mode, if a line from tha edit buffer (other than tha current
line) do not entirely fit tha fuck into tha lines all up in tha bottom
of tha display dat is available fo' its presentation, tha editor
may chizzle not ta display any portion of tha line. Da lines of
the display dat do not contain text from tha edit buffer fo' this
reason shall each consist of a single \fB'@'\fP
character.
.LP
In visual mode, tha editor may chizzle fo' unspecified reasons ta not
update lines up in tha display ta correspond ta tha underlying
edit buffer text. Da linez of tha display dat do not erectly correspond
to text from tha edit buffer fo' dis reason shall
consist of a single \fB'@'\fP characta (plus tha terminatin <newline>),
and tha <control>-R command shall cause
the editor ta update tha screen ta erectly represent tha edit buffer.
.LP
Open n' visual mode commandz dat set tha current column set it to
a column posizzle up in tha display, n' not a cold-ass lil character
posizzle up in tha line. In dis case, however, tha column posizzle in
the display shall be calculated fo' a infinite width display;
for example, tha column related ta a cold-ass lil characta dat is part of a line
that has been folded onto additionizzle screen lines will be
offset from tha display line column where tha buffer line begins,
not from tha beginnin of a particular display line.
.LP
Da display cursor column up in tha display is based on tha value of
the current column, as bigs up, wit each rule applied in
turn:
.IP " 1." 4
If tha current column be afta tha last display line column used by
the displayed line, tha display cursor column shall be set
to tha last display line column occupied by tha last non- <newline>
in tha current line; otherwise, tha display cursor column
shall be set ta tha current column.
.LP
.IP " 2." 4
If tha characta of which some portion is displayed up in tha display
line column specified by tha display cursor column requires
more than a single display line column:
.RS
.IP " a." 4
If up in text input mode, tha display cursor column shall be adjusted
to tha straight-up original gangsta display line column up in which any portion of that
characta is displayed.
.LP
.IP " b." 4
Otherwise, tha display cursor column shall be adjusted ta tha last
display line column up in which any portion of dat characta is
displayed.
.LP
.RE
.LP
.LP
Da current column shall not be chizzled by these adjustments ta the
display cursor column.
.LP
If a error occurs durin tha parsin or execution of a \fIvi\fP command:
.IP " *" 3
Da terminal shall be alerted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Execution of tha \fIvi\fP command shall
stop, n' tha cursor (for example, tha current line and
column) shall not be further modified.
.LP
.IP " *" 3
Unless otherwise specified by tha followin command sections, it is
unspecified whether a shiznital message shall be
displayed.
.LP
.IP " *" 3
Any partially entered \fIvi\fP command shall be discarded.
.LP
.IP " *" 3
If tha \fIvi\fP command resulted from a \fBmap\fP expansion, all characters
from dat \fBmap\fP expansion shall be discarded,
except as otherwise specified by tha \fBmap\fP command (see \fIed\fP).
.LP
.IP " *" 3
If tha \fIvi\fP command resulted from tha execution of a funky-ass buffer, no
further commandz caused by tha execution of tha buffer
shall be executed.
.LP
.SS Page Backwards
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB<control>-B
\fP
.fi
.RE
.sp
.LP
If up in open mode, tha <control>-B command shall behave identically
to tha \fBz\fP command. Y'all KNOW dat shit, muthafucka! Otherwise, if tha current line
is tha straight-up original gangsta line of tha edit buffer, it shall be a error.
.LP
If tha \fBwindow\fP edit option is less than 3, display a screen where
the last line of tha display shall be some portion
of:
.sp
.RS
.nf

\fB(\fP\fIcurrent first line\fP\fB) -1
\fP
.fi
.RE
.LP
otherwise, display a screen where tha straight-up original gangsta line of tha display shall
be some portion of:
.sp
.RS
.nf

\fB(\fP\fIcurrent first line\fP\fB) -\fP \fIcount\fP \fBx ((window edit option) -2)
\fP
.fi
.RE
.LP
If dis calculation would result up in a line dat is before tha first
line of tha edit buffer, tha straight-up original gangsta line of tha display shall
display some portion of tha straight-up original gangsta line of tha edit buffer.
.LP
\fICurrent line\fP: If no lines from tha previous display remain on
the screen, set ta tha last line of tha display; otherwise,
set ta ( \fIline\fP - tha number of freshly smoked up lines displayed on dis screen).
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Scroll Forward
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB<control>-D
\fP
.fi
.RE
.sp
.LP
If tha current line is tha last line of tha edit buffer, it shall
be a error.
.LP
If no \fIcount\fP is specified, \fIcount\fP shall default ta tha \fIcount\fP
associated wit tha previous <control>-D
or <control>-U command. Y'all KNOW dat shit, muthafucka! If there was no previous <control>-D or <control>-U
command, \fIcount\fP shall default
to tha value of tha \fBscroll\fP edit option.
.LP
If up in open mode, write lines startin wit tha line afta tha current
line, until \fIcount\fP lines or tha last line of the
file done been written.
.LP
\fICurrent line\fP: If tha current line + \fIcount\fP is past the
last line of tha edit buffer, set ta tha last line of the
edit buffer; otherwise, set ta tha current line + \fIcount\fP.
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Scroll Forward by Line
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB<control>-E
\fP
.fi
.RE
.sp
.LP
Display tha line count lines afta tha last line currently displayed.
.LP
If tha last line of tha edit buffer is displayed, it shall be a error.
If there is no line \fIcount\fP lines afta tha last
line currently displayed, tha last line of tha display shall display
some portion of tha last line of tha edit buffer.
.LP
\fICurrent line\fP: Unchanged if tha previous current characta is
displayed; otherwise, set ta tha straight-up original gangsta line displayed.
.LP
\fICurrent column\fP: Unchanged.
.SS Page Forward
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB<control>-F
\fP
.fi
.RE
.sp
.LP
If up in open mode, tha <control>-F command shall behave identically
to tha \fBz\fP command. Y'all KNOW dat shit, muthafucka! Otherwise, if tha current line
is tha last line of tha edit buffer, it shall be a error.
.LP
If tha \fBwindow\fP edit option is less than 3, display a screen where
the first line of tha display shall be some portion
of:
.sp
.RS
.nf

\fB(\fP\fIcurrent last line\fP\fB) +1
\fP
.fi
.RE
.LP
otherwise, display a screen where tha straight-up original gangsta line of tha display shall
be some portion of:
.sp
.RS
.nf

\fB(\fP\fIcurrent first line\fP\fB) +\fP \fIcount\fP \fBx ((window edit option) -2)
\fP
.fi
.RE
.LP
If dis calculation would result up in a line dat be afta tha last
line of tha edit buffer, tha last line of tha display shall
display some portion of tha last line of tha edit buffer.
.LP
\fICurrent line\fP: If no lines from tha previous display remain on
the screen, set ta tha straight-up original gangsta line of tha display;
otherwise, set ta ( \fIline\fP + tha number of freshly smoked up lines displayed
on dis screen).
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Display Information
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<control>-G
\fP
.fi
.RE
.sp
.LP
This command shall be equivalent ta tha \fIex\fP \fBfile\fP command.
.SS Move Cursor Backwards
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB<control>-H
.sp

\fP\fB[\fP\fIcount\fP\fB]\fP \fBh
.sp

the current\fP \fIerase\fP \fBcharacta (see stty)
\fP
.fi
.RE
.sp
.LP
If there be no charactas before tha current characta on tha current
line, it shall be a error. Shiiit, dis aint no joke. If there be less than
\fIcount\fP previous charactas on tha current line, \fIcount\fP shall
be adjusted ta tha number of previous charactas on the
line.
.LP
If used as a motion command:
.IP " 1." 4
Da text region shall be from tha characta before tha startin cursor
up ta n' includin tha \fIcount\fPth characta before
the startin cursor.
.LP
.IP " 2." 4
Any text copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Set ta ( \fIcolumn\fP - tha number of columns
occupied by \fIcount\fP charactas endin wit the
previous current column).
.SS Move Down
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB<newline>
.sp

\fP\fB[\fP\fIcount\fP\fB]\fP \fB<control>-J
.sp

\fP\fB[\fP\fIcount\fP\fB]\fP \fB<control>-M
.sp

\fP\fB[\fP\fIcount\fP\fB]\fP \fB<control>-N
.sp

\fP\fB[\fP\fIcount\fP\fB]\fP \fBj
.sp

\fP\fB[\fP\fIcount\fP\fB]\fP \fB<carriage-return>
.sp

\fP\fB[\fP\fIcount\fP\fB]\fP \fB+
\fP
.fi
.RE
.sp
.LP
If there be less than \fIcount\fP lines afta tha current line in
the edit buffer, it shall be a error.
.LP
If used as a motion command:
.IP " 1." 4
Da text region shall include tha startin line n' tha next \fIcount\fP
- 1 lines.
.LP
.IP " 2." 4
Any text copied ta a funky-ass buffer shall be up in line mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Set ta \fIcurrent line\fP+ \fIcount\fP.
.LP
\fICurrent column\fP: Set ta non- <blank> fo' tha <carriage-return>,
<control>-M, n' \fB+\fP commands;
otherwise, unchanged.
.SS Clear n' Redisplay
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<control>-L
\fP
.fi
.RE
.sp
.LP
If up in open mode, clear tha screen n' redisplay tha current line.
Otherwise, clear n' redisplay tha screen.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Unchanged.
.SS Move Up
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB<control>-P
.sp

\fP\fB[\fP\fIcount\fP\fB]\fP \fBk
.sp

\fP\fB[\fP\fIcount\fP\fB]\fP \fB-
\fP
.fi
.RE
.sp
.LP
If there be less than \fIcount\fP lines before tha current line in
the edit buffer, it shall be a error.
.LP
If used as a motion command:
.IP " 1." 4
Da text region shall include tha startin line n' tha previous \fIcount\fP
lines.
.LP
.IP " 2." 4
Any text copied ta a funky-ass buffer shall be up in line mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Set ta \fIcurrent line\fP - \fIcount\fP.
.LP
\fICurrent column\fP: Set ta non- <blank> fo' tha \fB-\fP command;
otherwise, unchanged.
.SS Redraw Screen
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<control>-R
\fP
.fi
.RE
.sp
.LP
If any lines done been deleted from tha display screen n' flagged
as deleted on tha terminal rockin tha \fB@\fP convention (see
the beginnin of tha EXTENDED DESCRIPTION section), they shall be
redisplayed ta match tha contentz of tha edit buffer.
.LP
It be unspecified whether lines flagged wit \fB@\fP cuz they
do not fit on tha terminal display shall be affected.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Unchanged.
.SS Scroll Backward
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB<control>-U
\fP
.fi
.RE
.sp
.LP
If tha current line is tha straight-up original gangsta line of tha edit buffer, it shall
be a error.
.LP
If no \fIcount\fP is specified, \fIcount\fP shall default ta tha \fIcount\fP
associated wit tha previous <control>-D
or <control>-U command. Y'all KNOW dat shit, muthafucka! If there was no previous <control>-D or <control>-U
command, \fIcount\fP shall default
to tha value of tha \fBscroll\fP edit option.
.LP
\fICurrent line\fP: If \fIcount\fP is pimped outa than tha current line,
set ta 1; otherwise, set ta tha current line -
\fIcount\fP.
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Scroll Backward by Line
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB<control>-Y
\fP
.fi
.RE
.sp
.LP
Display tha line \fIcount\fP lines before tha straight-up original gangsta line currently
displayed.
.LP
If tha current line is tha straight-up original gangsta line of tha edit buffer, it shall
be a error. Shiiit, dis aint no joke. If dis calculation would result up in a line that
is before tha straight-up original gangsta line of tha edit buffer, tha straight-up original gangsta line of the
display shall display some portion of tha straight-up original gangsta line of tha edit
buffer.
.LP
\fICurrent line\fP: Unchanged if tha previous current characta is
displayed; otherwise, set ta tha straight-up original gangsta line displayed.
.LP
\fICurrent column\fP: Unchanged.
.SS Edit tha Alternate File
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<control>-^
\fP
.fi
.RE
.sp
This command shall be equivalent ta tha \fIex\fP \fBedit\fP command,
with tha alternate
pathname as its argument. 
.SS Terminizzle Command or Input Mode
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<ESC>
\fP
.fi
.RE
.sp
.LP
If a partial \fIvi\fP command (as defined by at least one, non- \fIcount\fP
character) has been entered, discard the
\fIcount\fP n' tha command character(s).
.LP
Otherwise, if no command charactas done been entered, n' tha <ESC>
was tha result of a map expansion, tha terminal shall
be alerted n' tha <ESC> characta shall be discarded yo, but it shall
not be a error.
.LP
Otherwise, it shall be a error.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Unchanged.
.SS Search fo' tagstring
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<control>-]
\fP
.fi
.RE
.sp
.LP
If tha current characta aint a word or <blank>, it shall be an
error.
.LP
This command shall be equivalent ta tha \fIex\fP \fBtag\fP command,
with tha argument to
that command defined as bigs up.
.LP
If tha current characta be a <blank>:
.IP " 1." 4
Skip all <blank>s afta tha cursor up ta tha end of tha line.
.LP
.IP " 2." 4
If tha end of tha line is reached, it shall be a error.
.LP
.LP
Then, tha argument ta tha \fIex\fP \fBtag\fP command shall be the
current characta n' all
subsequent characters, up ta tha straight-up original gangsta non-word characta or tha end
of tha line.
.SS Move Cursor Forward
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB<space>
.sp

\fP\fB[\fP\fIcount\fP\fB]\fP \fBl\fP  (ell)
.fi
.RE
.sp
.LP
If there be less than \fIcount\fP non- <newline>s afta tha cursor
on tha current line, \fIcount\fP shall be adjusted
to tha number of non- <newline>s afta tha cursor on tha line.
.LP
If used as a motion command:
.IP " 1." 4
If tha current or \fIcount\fPth characta afta tha cursor is the
last non- <newline> up in tha line, tha text region shall
be comprised of tha current characta up ta n' includin tha last
non- <newline> up in tha line. Otherwise, tha text region
shall be from tha current characta up ta yo, but not including, the
\fIcount\fPth characta afta tha cursor.
.LP
.IP " 2." 4
Any text copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
If there be no non- <newline>s afta tha current characta on the
current line, it shall be a error.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Set ta tha last column dat displays any portion
of tha \fIcount\fPth characta afta tha current
character.
.SS Replace Text wit Results from Shell Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB!\fP \fImotion shell-commands\fP \fB<newline>
\fP
.fi
.RE
.sp
.LP
If tha motion command is tha \fB!\fP command repeated:
.IP " 1." 4
If tha edit buffer is empty n' no \fIcount\fP was supplied, tha command
shall be tha equivalent of tha \fIex\fP \fB:read\fP \fB!\fP command,
with tha text input, n' no text shall be copied ta any
buffer.
.LP
.IP " 2." 4
Otherwise:
.RS
.IP " a." 4
If there be less than \fIcount\fP -1 lines afta tha current line
in tha edit buffer, it shall be a error.
.LP
.IP " b." 4
Da text region shall be from tha current line up ta n' including
the next \fIcount\fP -1 lines.
.LP
.RE
.LP
.LP
Otherwise, tha text region shall be tha lines up in which any character
of tha text region specified by tha motion command
appear.
.LP
Any text copied ta a funky-ass buffer shall be up in line mode.
.LP
This command shall be equivalent ta tha \fIex\fP \fB!\fP command for
the specified
lines.
.SS Move Cursor ta End-of-Line
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB$
\fP
.fi
.RE
.sp
.LP
It shall be a error if there be less than ( \fIcount\fP -1) lines
afta tha current line up in tha edit buffer.
.LP
If used as a motion command:
.IP " 1." 4
If \fIcount\fP is 1:
.RS
.IP " a." 4
It shall be a error if tha line is empty.
.LP
.IP " b." 4
Otherwise, tha text region shall consist of all charactas from the
startin cursor ta tha last non- <newline> up in the
line, inclusive, n' any text copied ta a funky-ass buffer shall be up in character
mode.
.LP
.RE
.LP
.IP " 2." 4
Otherwise, if tha startin cursor posizzle be at or before tha first
non- <blank> up in tha line, tha text region shall
consist of tha current n' tha next \fIcount\fP -1 lines, n' any
text saved ta a funky-ass buffer shall be up in line mode.
.LP
.IP " 3." 4
Otherwise, tha text region shall consist of all charactas from the
startin cursor ta tha last non- <newline> up in tha line
that is \fIcount\fP -1 lines forward from tha current line, n' any
text copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Set ta tha \fIcurrent line\fP + \fIcount\fP-1.
.LP
\fICurrent column\fP: Da current column is set ta tha last display
line column of tha last non- <newline> up in tha line,
or column posizzle 1 if tha line is empty.
.LP
Da current column shall be adjusted ta be on tha last display line
column of tha last non- <newline> of tha current line
as subsequent commandz chizzle tha current line, until a cold-ass lil command chizzles
the current column.
.SS Move ta Matchin Character
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB%
\fP
.fi
.RE
.sp
.LP
If tha characta all up in tha current posizzle aint a parenthesis, bracket,
or curly brace, search forward up in tha line ta tha first
one of dem characters. If no such characta is found, it shall be
an error.
.LP
Da matchin characta shall be tha parenthesis, bracket, or curly
brace matchin tha parenthesis, bracket, or curly brace,
respectively, dat was all up in tha current posizzle or dat was found on
the current line.
.LP
Matchin shall be determined as bigs up, fo' a open parenthesis:
.IP " 1." 4
Set a cold-ass lil counta ta 1.
.LP
.IP " 2." 4
Search forwardz until a parenthesis is found or tha end of tha edit
buffer is reached.
.LP
.IP " 3." 4
If tha end of tha edit buffer is reached, it shall be a error.
.LP
.IP " 4." 4
If a open parenthesis is found, increment tha counta by 1.
.LP
.IP " 5." 4
If a cold-ass lil close parenthesis is found, decrement tha counta by 1.
.LP
.IP " 6." 4
If tha counta is zero, tha current characta is tha matchin character.
.LP
.LP
Matchin fo' a cold-ass lil close parenthesis shall be equivalent, except that
the search shall be backwards, from tha startin characta to
the beginnin of tha buffer, a cold-ass lil close parenthesis shall increment the
counta by 1, n' a open parenthesis shall decrement the
counta by 1.
.LP
Matchin fo' brackets n' curly braces shall be equivalent, except
that searchin shall be done fo' open n' close brackets or
open n' close curly braces. Well shiiiit, it is implementation-defined whether
other charactas is searched fo' n' matched as well.
.LP
If used as a motion command:
.IP " 1." 4
If tha matchin cursor was afta tha startin cursor up in tha edit buffer,
and tha startin cursor posizzle was at or before the
first non- <blank> non- <newline> up in tha startin line, n' tha matching
cursor posizzle was at or afta tha last non-
<blank> non- <newline> up in tha matchin line, tha text region shall
consist of tha current line ta tha matchin line,
inclusive, n' any text copied ta a funky-ass buffer shall be up in line mode.
.LP
.IP " 2." 4
If tha matchin cursor was before tha startin cursor up in tha edit
buffer, n' tha startin cursor posizzle was at or afta the
last non- <blank> non- <newline> up in tha startin line, n' tha matching
cursor posizzle was at or before tha straight-up original gangsta non-
<blank> non- <newline> up in tha matchin line, tha text region shall
consist of tha current line ta tha matchin line,
inclusive, n' any text copied ta a funky-ass buffer shall be up in line mode.
.LP
.IP " 3." 4
Otherwise, tha text region shall consist of tha startin character
to tha matchin character, inclusive, n' any text copied to
a buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Set ta tha line where tha matchin characta is
located.
.LP
\fICurrent column\fP: Set ta tha last column where any portion of
the matchin characta is displayed.
.SS Repeat Substitution
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB&
\fP
.fi
.RE
.sp
.LP
Repeat tha previous substitution command. Y'all KNOW dat shit, muthafucka! This command shall be equivalent
to tha \fIex\fP
\fB&\fP command wit tha current line as its addresses, n' without
\fIoptions\fP, \fIcount\fP, or \fIflags\fP.
.SS Return ta Previous Context at Beginnin of Line
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB'\fP \fIcharacter\fP
.fi
.RE
.sp
.LP
It shall be a error if there is no line up in tha edit buffer marked
by \fIcharacter\fP.
.LP
If used as a motion command:
.IP " 1." 4
If tha startin cursor be afta tha marked cursor, then tha locations
of tha startin cursor n' tha marked cursor up in tha edit
buffer shall be logically swapped.
.LP
.IP " 2." 4
Da text region shall consist of tha startin line up ta n' including
the marked line, n' any text copied ta a funky-ass buffer shall be
in line mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Set ta tha line referenced by tha mark.
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Return ta Previous Context
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB`\fP \fIcharacter\fP
.fi
.RE
.sp
.LP
It shall be a error if tha marked line is no longer up in tha edit buffer.
If tha marked line no longer gotz nuff a cold-ass lil characta in
the saved numbered characta position, it shall be as if tha marked
posizzle is tha straight-up original gangsta non- <blank>.
.LP
If used as a motion command:
.IP " 1." 4
It shall be a error if tha marked cursor references tha same ol' dirty character
in tha edit buffer as tha startin cursor.
.LP
.IP " 2." 4
If tha startin cursor be afta tha marked cursor, then tha locations
of tha startin cursor n' tha marked cursor up in tha edit
buffer shall be logically swapped.
.LP
.IP " 3." 4
If tha startin line is empty or tha startin cursor be at or before
the first non- <blank> non- <newline> of the
startin line, n' tha marked cursor line is empty or tha marked cursor
references tha straight-up original gangsta characta of tha marked cursor line,
the text region shall consist of all lines containin charactas from
the startin cursor ta tha line before tha marked cursor
line, inclusive, n' any text copied ta a funky-ass buffer shall be up in line
mode.
.LP
.IP " 4." 4
Otherwise, if tha marked cursor line is empty or tha marked cursor
references a cold-ass lil characta at or before tha straight-up original gangsta non-
<blank> non- <newline> of tha marked cursor line, tha region of text
shall be from tha startin cursor ta tha last non-
<newline> of tha line before tha marked cursor line, inclusive, and
any text copied ta a funky-ass buffer shall be up in character
mode.
.LP
.IP " 5." 4
Otherwise, tha region of text shall be from tha startin cursor (inclusive),
to tha marked cursor (exclusive), n' any text
copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Set ta tha line referenced by tha mark.
.LP
\fICurrent column\fP: Set ta tha last column up in which any portion
of tha characta referenced by tha mark is displayed.
.SS Return ta Previous Section
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB[[
\fP
.fi
.RE
.sp
.LP
Move tha cursor backward all up in tha edit buffer ta tha straight-up original gangsta character
of tha previous section boundary, \fIcount\fP
times.
.LP
If used as a motion command:
.IP " 1." 4
If tha startin cursor was all up in tha straight-up original gangsta characta of tha starting
line or tha startin line was empty, n' tha straight-up original gangsta character
of tha boundary was tha straight-up original gangsta characta of tha boundary line, the
text region shall consist of tha current line up ta n' including
the line where tha \fIcount\fPth next boundary starts, n' any text
copied ta a funky-ass buffer shall be up in line mode.
.LP
.IP " 2." 4
If tha boundary was tha last line of tha edit buffer or tha last non-
<newline> of tha last line of tha edit buffer, the
text region shall consist of tha last characta up in tha edit buffer
up ta n' includin tha startin character, n' any text saved
to a funky-ass buffer shall be up in characta mode.
.LP
.IP " 3." 4
Otherwise, tha text region shall consist of tha startin character
up ta but not includin tha straight-up original gangsta characta up in the
\fIcount\fPth next boundary, n' any text copied ta a funky-ass buffer shall
be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Set ta tha line where tha \fIcount\fPth next boundary
in tha edit buffer starts.
.LP
\fICurrent column\fP: Set ta tha last column up in which any portion
of tha straight-up original gangsta characta of tha \fIcount\fPth next boundary is
displayed, or column posizzle 1 if tha line is empty.
.SS Move ta Next Section
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB]]
\fP
.fi
.RE
.sp
.LP
Move tha cursor forward all up in tha edit buffer ta tha straight-up original gangsta character
of tha next section boundary, \fIcount\fP times.
.LP
If used as a motion command:
.IP " 1." 4
If tha startin cursor was all up in tha straight-up original gangsta characta of tha starting
line or tha startin line was empty, n' tha straight-up original gangsta character
of tha boundary was tha straight-up original gangsta characta of tha boundary line, the
text region shall consist of tha current line up ta n' including
the line where tha \fIcount\fPth previous boundary starts, n' any
text copied ta a funky-ass buffer shall be up in line mode.
.LP
.IP " 2." 4
If tha boundary was tha straight-up original gangsta line of tha edit buffer, tha text region
shall consist of tha straight-up original gangsta characta up in tha edit buffer
up ta but not includin tha startin character, n' any text copied
to a funky-ass buffer shall be up in characta mode.
.LP
.IP " 3." 4
Otherwise, tha text region shall consist of tha straight-up original gangsta characta in
the \fIcount\fPth previous section boundary up ta but not
includin tha startin character, n' any text copied ta a funky-ass buffer
shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Set ta tha line where tha \fIcount\fPth previous
boundary up in tha edit buffer starts.
.LP
\fICurrent column\fP: Set ta tha last column up in which any portion
of tha straight-up original gangsta characta of tha \fIcount\fPth previous
boundary is displayed, or column posizzle 1 if tha line is empty.
.SS Move ta First Non-<blank> Posizzle on Current Line
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB^
\fP
.fi
.RE
.sp
If used as a motion command: 
.IP " 1." 4
If tha line has no non- <blank> non- <newline>s, or if tha cursor
is all up in tha straight-up original gangsta non- <blank> non-
<newline> of tha line, it shall be a error.
.LP
.IP " 2." 4
If tha cursor is before tha straight-up original gangsta non- <blank> non- <newline> of the
line, tha text region shall be comprised of the
current character, up ta yo, but not including, tha straight-up original gangsta non- <blank>
non- <newline> of tha line.
.LP
.IP " 3." 4
If tha cursor be afta tha straight-up original gangsta non- <blank> non- <newline> of the
line, tha text region shall be from the
characta before tha startin cursor up ta n' includin tha first
non- <blank> non- <newline> of tha line.
.LP
.IP " 4." 4
Any text copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Current n' Line Above
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB_
\fP
.fi
.RE
.sp
.LP
If there be less than \fIcount\fP -1 lines afta tha current line
in tha edit buffer, it shall be a error.
.LP
If used as a motion command:
.IP " 1." 4
If \fIcount\fP is less than 2, tha text region shall be tha current
line.
.LP
.IP " 2." 4
Otherwise, tha text region shall include tha startin line n' the
next \fIcount\fP -1 lines.
.LP
.IP " 3." 4
Any text copied ta a funky-ass buffer shall be up in line mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Set ta current line + \fIcount\fP -1.
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Move Back ta Beginnin of Sentence
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB(
\fP
.fi
.RE
.sp
.LP
Move backward ta tha beginnin of a sentence. This command shall be
equivalent ta tha \fB[[\fP command, wit tha exception that
sentence boundaries shall be used instead of section boundaries.
.SS Move Forward ta Beginnin of Sentence
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB)
\fP
.fi
.RE
.sp
.LP
Move forward ta tha beginnin of a sentence. This command shall be
equivalent ta tha \fB]]\fP command, wit tha exception that
sentence boundaries shall be used instead of section boundaries.
.SS Move Back ta Precedin Paragraph
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB{
\fP
.fi
.RE
.sp
.LP
Move back ta tha beginnin of tha precedin paragraph. This command
shall be equivalent ta tha \fB[[\fP command, wit the
exception dat paragraph boundaries shall be used instead of section
boundaries.
.SS Move Forward ta Next Paragraph
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB}
\fP
.fi
.RE
.sp
.LP
Move forward ta tha beginnin of tha next paragraph. This command
shall be equivalent ta tha \fB]]\fP command, wit the
exception dat paragraph boundaries shall be used instead of section
boundaries.
.SS Move ta Specific Column Position
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB|
\fP
.fi
.RE
.sp
.LP
For tha purposez of dis command, lines dat is too long fo' the
current display n' dat done been folded shall be treated as
havin a single, 1-based, number of columns.
.LP
If there be less than \fIcount\fP columns up in which charactas from
the current line is displayed on tha screen, \fIcount\fP
shall be adjusted ta be tha last column up in which any portion of the
line is displayed on tha screen.
.LP
If used as a motion command:
.IP " 1." 4
If tha line is empty, or tha cursor characta is tha same ol' dirty as tha character
on tha \fIcount\fPth column of tha line, it shall be
an error.
.LP
.IP " 2." 4
If tha cursor is before tha \fIcount\fPth column of tha line, the
text region shall be comprised of tha current character, up
to but not includin tha characta on tha \fIcount\fPth column of
the line.
.LP
.IP " 3." 4
If tha cursor be afta tha \fIcount\fPth column of tha line, tha text
region shall be from tha characta before tha starting
cursor up ta n' includin tha characta on tha \fIcount\fPth column
of tha line.
.LP
.IP " 4." 4
Any text copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Set ta tha last column up in which any portion
of tha characta dat is displayed up in tha \fIcount\fP column
of tha line is displayed.
.SS Reverse Find Character
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB,
\fP
.fi
.RE
.sp
.LP
If tha last \fBF\fP, \fBf\fP, \fBT\fP, or \fBt\fP command was \fBF\fP,
\fBf\fP, \fBT\fP, or \fBt\fP, dis command shall
be equivalent ta a \fBf\fP, \fBF\fP, \fBt\fP, or \fBT\fP command,
respectively, wit tha specified \fIcount\fP n' tha same
search character.
.LP
If there was no previous \fBF\fP, \fBf\fP, \fBT\fP, or \fBt\fP command,
it shall be a error.
.SS Repeat
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB.
\fP
.fi
.RE
.sp
.LP
Repeat tha last \fB!\fP, \fB<\fP, \fB>\fP, \fBA\fP, \fBC\fP, \fBD\fP,
\fBI\fP, \fBJ\fP, \fBO\fP, \fBP\fP,
\fBR\fP, \fBS\fP, \fBX\fP, \fBY\fP, \fBa\fP, \fBc\fP, \fBd\fP, \fBi\fP,
\fBo\fP, \fBp\fP, \fBr\fP, \fBs\fP, \fBx\fP,
\fBy\fP, or \fB~\fP command. Y'all KNOW dat shit, muthafucka! Well shiiiit, it shall be a error if none of these
commandz done been executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Commandz (other than
commandz dat enta text input mode) executed as a result of map expansions,
shall not chizzle tha value of tha last repeatable
command.
.LP
Repeated commandz wit associated motion commandz shall repeat the
motion command as well; however, any specified \fIcount\fP
shall replace tha \fIcount\fP(s) dat was originally specified to
the repeated command or its associated motion command.
.LP
If tha motion component of tha repeated command is \fBf\fP, \fBF\fP,
\fBt\fP, or \fBT\fP, tha repeated command shall not set
the remembered search characta fo' tha \fB;\fP n' \fB,\fP commands.
.LP
If tha repeated command is \fBp\fP or \fBP\fP, n' tha buffer associated
with dat command was a numeric buffer named wit a
number less than 9, tha buffer associated wit tha repeated command
shall be set ta be tha buffer named by tha name of tha previous
buffer logically incremented by 1.
.LP
If tha repeated characta be a text input command, tha input text
associated wit dat command is repeated literally:
.IP " *" 3
Input charactas is neither macro or abbreviation-expanded.
.LP
.IP " *" 3
Input charactas is not interpreted up in any special way wit tha exception
that <newline>, <carriage-return>, and
<control>-T behave as busted lyrics bout up in Input Mode Commandz up in vi .
.LP
.LP
\fICurrent line\fP: Set as busted lyrics bout fo' tha repeated command.
.LP
\fICurrent column\fP: Set as busted lyrics bout fo' tha repeated command.
.SS Find Regular Expression
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB/
\fP
.fi
.RE
.sp
.LP
If tha input line gotz nuff no non- <newline>s, it shall be equivalent
to a line containin only tha last regular
expression encountered. Y'all KNOW dat shit, muthafucka! Da enhanced regular expressions supported
by \fIvi\fP is busted lyrics bout up in \fIRegular Expressions up in ex\fP .
.LP
Otherwise, tha line shall be interpreted as one or mo' regular expressions,
optionally followed by a address offset or a
\fIvi\fP \fBz\fP command.
.LP
If tha regular expression aint tha last regular expression on the
line, or if a line offset or \fBz\fP command is specified,
the regular expression shall be terminated by a unescaped \fB'/'\fP
character, which shall not be used as part of tha regular
expression. I aint talkin' bout chicken n' gravy biatch. If tha regular expression aint tha straight-up original gangsta regular expression
on tha line, it shall be preceded by zero or more
<blank>s, a semicolon, zero or mo' <blank>s, n' a leadin \fB'/'\fP
character, which shall not be interpreted as
part of tha regular expression. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it shall be a error ta precede any
regular expression wit any charactas other than these.
.LP
Each search shall begin from tha characta afta tha straight-up original gangsta character
of tha last match (or, if it is tha straight-up original gangsta search, afta the
cursor). If tha \fBwrapscan\fP edit option is set, tha search shall
continue ta tha characta before tha startin cursor
character; otherwise, ta tha end of tha edit buffer n' shit. Well shiiiit, it shall be an
error if any search fails ta find a match, n' a shiznital
message ta dis effect shall be displayed.
.LP
An optionizzle address offset (see \fIAddressin up in ex\fP ) can be specified
afta tha last
regular expression by includin a trailin \fB'/'\fP characta after
the regular expression n' specifyin tha address offset.
This offset is ghon be from tha line containin tha match fo' tha last
regular expression specified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it shall be a error if tha line
offset would indicate a line address less than 1 or pimped outa than the
last line up in tha edit buffer n' shiznit fo' realz. An address offset of zero shall
be supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Well shiiiit, it shall be a error ta follow tha address offset with
any other charactas than <blank>s.
.LP
If not used as a motion command, a optionizzle \fBz\fP command (see
Redraw Window ) can be
specified afta tha last regular expression by includin a trailing
\fB'/'\fP characta afta tha regular expression, zero or
more <blank>s, a \fB'z'\fP, zero or mo' <blank>s, a optionizzle new
\fBwindow\fP edit option value, zero or more
<blank>s, n' a location character n' shit. Da effect shall be as if the
\fBz\fP command was executed afta tha \fB/\fP command.
It shall be a error ta follow tha \fBz\fP command wit any other
charactas than <blank>s.
.LP
Da remembered search direction shall be set ta forward.
.LP
If used as a motion command:
.IP " 1." 4
It shall be a error if tha last match references tha same ol' dirty character
in tha edit buffer as tha startin cursor.
.LP
.IP " 2." 4
If any address offset is specified, tha last match shall be adjusted
by tha specified offset as busted lyrics bout previously.
.LP
.IP " 3." 4
If tha startin cursor be afta tha last match, then tha locations
of tha startin cursor n' tha last match up in tha edit buffer
shall be logically swapped.
.LP
.IP " 4." 4
If any address offset is specified, tha text region shall consist
of all lines containin charactas from tha startin cursor to
the last match line, inclusive, n' any text copied ta a funky-ass buffer shall
be up in line mode.
.LP
.IP " 5." 4
Otherwise, if tha startin line is empty or tha startin cursor is
at or before tha straight-up original gangsta non- <blank> non-
<newline> of tha startin line, n' tha last match line is empty or
the last match starts all up in tha straight-up original gangsta characta of tha last
match line, tha text region shall consist of all lines containing
charactas from tha startin cursor ta tha line before tha last
match line, inclusive, n' any text copied ta a funky-ass buffer shall be in
line mode.
.LP
.IP " 6." 4
Otherwise, if tha last match line is empty or tha last match begins
at a cold-ass lil characta at or before tha straight-up original gangsta non- <blank>
non- <newline> of tha last match line, tha region of text shall be
from tha current cursor ta tha last non- <newline>
of tha line before tha last match line, inclusive, n' any text copied
to a funky-ass buffer shall be up in characta mode.
.LP
.IP " 7." 4
Otherwise, tha region of text shall be from tha current cursor (inclusive),
to tha straight-up original gangsta characta of tha last match
(exclusive), n' any text copied ta a funky-ass buffer shall be up in character
mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: If a match is found, set ta tha last matched line
plus tha address offset, if any; otherwise,
unchanged.
.LP
\fICurrent column\fP: Set ta tha last column on which any portion
of tha straight-up original gangsta characta up in tha last matched strang is
displayed, if a match is found; otherwise, unchanged.
.SS Move ta First Characta up in Line
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB0 \fP (zero)
.fi
.RE
.sp
.LP
Move ta tha straight-up original gangsta characta on tha current line. Da characta \fB'0'\fP
shall not be interpreted as a cold-ass lil command if it is
immediately preceded by a gangbangin' finger-lickin' digit.
.LP
If used as a motion command:
.IP " 1." 4
If tha cursor characta is tha straight-up original gangsta characta up in tha line, it shall
be a error.
.LP
.IP " 2." 4
Da text region shall be from tha characta before tha cursor character
up ta n' includin tha straight-up original gangsta characta up in tha line.
.LP
.IP " 3." 4
Any text copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Da last column up in which any portion of the
first characta up in tha line is displayed, or if tha line is
empty, unchanged.
.SS Execute a ex Command
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB:
\fP
.fi
.RE
.sp
.LP
Execute one or mo' \fIex\fP commands.
.LP
If any portion of tha screen other than tha last line of tha screen
was overwritten by any \fIex\fP command (except \fBshell\fP), \fIvi\fP
shall display a message indicatin dat it is waiting
for a input from tha user, n' shall then read a cold-ass lil character n' shit. This
action may also be taken fo' other, unspecified reasons.
.LP
If tha next characta entered be a \fB':'\fP, another \fIex\fP command
shall be accepted
and executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. Any other characta shall cause tha screen ta be refreshed
and \fIvi\fP shall return ta command mode.
.LP
\fICurrent line\fP: As specified fo' tha \fIex\fP command.
.LP
\fICurrent column\fP: As specified fo' tha \fIex\fP command.
.SS Repeat Find
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB;
\fP
.fi
.RE
.sp
.LP
This command shall be equivalent ta tha last \fBF\fP, \fBf\fP, \fBT\fP,
or \fBt\fP command, wit tha specified \fIcount\fP,
and wit tha same search characta used fo' tha last \fBF\fP, \fBf\fP,
\fBT\fP, or \fBt\fP command. Y'all KNOW dat shit, muthafucka! If there was no previous
\fBF\fP, \fBf\fP, \fBT\fP, or \fBt\fP command, it shall be a error.
.SS Shift Left
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB<\fP \fImotion\fP
.fi
.RE
.sp
.LP
If tha motion command is tha \fB<\fP command repeated:
.IP " 1." 4
If there be less than \fIcount\fP -1 lines afta tha current line
in tha edit buffer, it shall be a error.
.LP
.IP " 2." 4
Da text region shall be from tha current line, up ta n' including
the next \fIcount\fP -1 lines.
.LP
.LP
Shift any line up in tha text region specified by tha \fIcount\fP and
motion command one shiftwidth (see tha \fIex\fP \fBshiftwidth\fP option)
toward tha start of tha line, as busted lyrics bout by tha \fIex\fP \fB<\fP
command. Y'all KNOW dat shit, muthafucka! Da unshifted lines shall be copied ta tha unnamed buffer
in line
mode.
.LP
\fICurrent line\fP: If tha motion was from tha current cursor position
toward tha end of tha edit buffer, unchanged. Y'all KNOW dat shit, muthafucka! Otherwise,
set ta tha straight-up original gangsta line up in tha edit buffer dat is part of tha text
region specified by tha motion command.
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Shift Right
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB>\fP \fImotion\fP
.fi
.RE
.sp
.LP
If tha motion command is tha \fB>\fP command repeated:
.IP " 1." 4
If there be less than \fIcount\fP -1 lines afta tha current line
in tha edit buffer, it shall be a error.
.LP
.IP " 2." 4
Da text region shall be from tha current line, up ta n' including
the next \fIcount\fP -1 lines.
.LP
.LP
Shift any line wit charactas up in tha text region specified by the
\fIcount\fP n' motion command one shiftwidth (see tha \fIex\fP \fBshiftwidth\fP
option) away from tha start of tha line, as busted lyrics bout by tha \fIex\fP
\fB>\fP command. Y'all KNOW dat shit, muthafucka! Da unshifted lines shall be copied tha fuck into tha unnamed
buffer up in line
mode.
.LP
\fICurrent line\fP: If tha motion was from tha current cursor position
toward tha end of tha edit buffer, unchanged. Y'all KNOW dat shit, muthafucka! Otherwise,
set ta tha straight-up original gangsta line up in tha edit buffer dat is part of tha text
region specified by tha motion command.
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Scan Backwardz fo' Regular Expression
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB?
\fP
.fi
.RE
.sp
.LP
Scan backwards; tha \fB?\fP command shall be equivalent ta tha \fB/\fP
command (see Find Regular
Expression ) wit tha followin exceptions:
.IP " 1." 4
Da input prompt shall be a \fB'?'\fP .
.LP
.IP " 2." 4
Each search shall begin from tha characta before tha straight-up original gangsta character
of tha last match (or, if it is tha straight-up original gangsta search, the
characta before tha cursor character).
.LP
.IP " 3." 4
Da search direction shall be from tha cursor toward tha beginning
of tha edit buffer, n' tha \fBwrapscan\fP edit option shall
affect whether tha search wraps ta tha end of tha edit buffer and
continues.
.LP
.IP " 4." 4
Da remembered search direction shall be set ta backward.
.LP
.SS Execute
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB@\fP\fIbuffer\fP
.fi
.RE
.sp
.LP
If tha \fIbuffer\fP is specified as \fB@\fP, tha last buffer executed
shall be used. Y'all KNOW dat shit, muthafucka! If no previous buffer has been executed,
it shall be a error.
.LP
Behave as if tha contentz of tha named buffer was entered as standard
input fo' realz. Afta each line of a line-mode buffer, n' all but
the last line of a cold-ass lil characta mode buffer, behave as if a <newline>
were entered as standard input.
.LP
If a error occurs durin dis process, a error message shall be
written, n' no mo' charactas resultin from tha execution
of dis command shall be processed.
.LP
If a \fIcount\fP is specified, behave as if dat count was entered
as user input before tha charactas from tha \fB@\fP
buffer was entered.
.LP
\fICurrent line\fP: As specified fo' tha individual commands.
.LP
\fICurrent column\fP: As specified fo' tha individual commands.
.SS Reverse Case
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fB~
\fP
.fi
.RE
.sp
.LP
Reverse tha case of tha current characta n' tha next \fIcount\fP
-1 characters, such dat lowercase charactas dat have
uppercase counterparts shall be chizzled ta uppercase characters, and
uppercase charactas dat have lowercase counterparts shall be
changed ta lowercase characters, as prescribed by tha current locale.
No other charactas shall be affected by dis command.
.LP
If there be less than \fIcount\fP -1 charactas afta tha cursor
in tha edit buffer, \fIcount\fP shall be adjusted ta the
number of charactas afta tha cursor up in tha edit buffer minus 1.
.LP
For tha purposez of dis command, tha next characta afta tha last
non- <newline> on tha line shall be tha next character
in tha edit buffer.
.LP
\fICurrent line\fP: Set ta tha line includin tha ( \fIcount\fP-1)th
characta afta tha cursor.
.LP
\fICurrent column\fP: Set ta tha last column up in which any portion
of tha ( \fIcount\fP-1)th characta afta tha cursor is
displayed.
.SS Append
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBa
\fP
.fi
.RE
.sp
.LP
Enta text input mode afta tha current cursor position. I aint talkin' bout chicken n' gravy biatch. No characters
already up in tha edit buffer shall be affected by this
command. Y'all KNOW dat shit, muthafucka! A \fIcount\fP shall cause tha input text ta be appended \fIcount\fP
-1 mo' times ta tha end of tha input.
.LP
\fICurrent line/column\fP: As specified fo' tha text input commands
(see Input Mode Commandz in
vi ).
.SS Append at End-of-Line
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBA
\fP
.fi
.RE
.sp
.LP
This command shall be equivalent ta tha \fIvi\fP command:
.sp
.RS
.nf

\fB$\fP \fB[\fP \fIcount\fP \fB]\fP \fBa
\fP
.fi
.RE
.LP
(see Append ).
.SS Move Backward ta Precedin Word
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBb
\fP
.fi
.RE
.sp
.LP
With tha exception dat lyrics is used as tha delimita instead of
bigwords, dis command shall be equivalent ta tha \fBB\fP
command.
.SS Move Backward ta Precedin Bigword
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBB
\fP
.fi
.RE
.sp
.LP
If tha edit buffer is empty or tha cursor is on tha straight-up original gangsta character
of tha edit buffer, it shall be a error. Shiiit, dis aint no joke. If less than
\fIcount\fP bigwordz begin between tha cursor n' tha start of the
edit buffer, \fIcount\fP shall be adjusted ta tha number of
bigword beginnings between tha cursor n' tha start of tha edit buffer.
.LP
If used as a motion command:
.IP " 1." 4
Da text region shall be from tha straight-up original gangsta characta of tha \fIcount\fPth
previous bigword beginnin up ta but not includin the
cursor character.
.LP
.IP " 2." 4
Any text copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Set ta tha line containin tha \fIcurrent column\fP.
.LP
\fICurrent column\fP: Set ta tha last column upon which any part of
the first characta of tha \fIcount\fPth previous bigword
is displayed.
.SS Chizzle
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB][\fP\fIcount\fP\fB]\fP \fBc\fP \fImotion\fP
.fi
.RE
.sp
.LP
If tha motion command is tha \fBc\fP command repeated:
.IP " 1." 4
Da buffer text shall be up in line mode.
.LP
.IP " 2." 4
If there be less than \fIcount\fP -1 lines afta tha current line
in tha edit buffer, it shall be a error.
.LP
.IP " 3." 4
Da text region shall be from tha current line up ta n' including
the next \fIcount\fP -1 lines.
.LP
.LP
Otherwise, tha buffer text mode n' text region shall be as specified
by tha motion command.
.LP
Da replaced text shall be copied tha fuck into \fIbuffer\fP, if specified,
and tha fuck into tha unnamed buffer n' shit. If tha text ta be replaced
gotz nuff charactas from mo' than a single line, or tha buffer text
is up in line mode, tha replaced text shall be copied tha fuck into the
numeric buffers as well.
.LP
If tha buffer text is up in line mode:
.IP " 1." 4
Any lines dat contain charactas up in tha region shall be deleted,
and tha editor shall enta text input mode all up in tha beginnin of
a freshly smoked up line which shall replace tha straight-up original gangsta line deleted.
.LP
.IP " 2." 4
If tha \fBautoindent\fP edit option is set, \fBautoindent\fP characters
equal ta tha \fBautoindent\fP charactas on tha first
line deleted shall be banged as if entered by tha user.
.LP
.LP
Otherwise, if charactas from mo' than one line is up in tha region
of text:
.IP " 1." 4
Da text shall be deleted.
.LP
.IP " 2." 4
Any text remainin up in tha last line up in tha text region shall be appended
to tha straight-up original gangsta line up in tha region, n' tha last line in
the region shall be deleted.
.LP
.IP " 3." 4
Da editor shall enta text input mode afta tha last characta not
deleted from tha straight-up original gangsta line up in tha text region, if any;
otherwise, on tha straight-up original gangsta column of tha straight-up original gangsta line up in tha region.
.LP
.LP
Otherwise:
.IP " 1." 4
If tha glyph fo' \fB'$'\fP is smalla than tha region, tha end of
the region shall be marked wit a \fB'$'\fP .
.LP
.IP " 2." 4
Da editor shall enta text input mode, overwritin tha region of
text.
.LP
.LP
\fICurrent line/column\fP: As specified fo' tha text input commands
(see Input Mode Commandz in
vi ).
.SS Chizzle ta End-of-Line
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB][\fP\fIcount\fP\fB]\fP \fBC
\fP
.fi
.RE
.sp
.LP
This command shall be equivalent ta tha \fIvi\fP command:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB][\fP\fIcount\fP\fB]\fP \fBc$
\fP
.fi
.RE
.LP
See tha \fBc\fP command.
.SS Delete
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB][\fP\fIcount\fP\fB]\fP \fBd\fP \fImotion\fP
.fi
.RE
.sp
.LP
If tha motion command is tha \fBd\fP command repeated:
.IP " 1." 4
Da buffer text shall be up in line mode.
.LP
.IP " 2." 4
If there be less than \fIcount\fP -1 lines afta tha current line
in tha edit buffer, it shall be a error.
.LP
.IP " 3." 4
Da text region shall be from tha current line up ta n' including
the next \fIcount\fP -1 lines.
.LP
.LP
Otherwise, tha buffer text mode n' text region shall be as specified
by tha motion command.
.LP
If up in open mode, n' tha current line is deleted, n' tha line remains
on tha display, a \fB'@'\fP characta shall be
displayed as tha straight-up original gangsta glyph of dat line.
.LP
Delete tha region of text tha fuck into \fIbuffer\fP, if specified, n' into
the unnamed buffer n' shit. If tha text ta be deleted gotz nuff
charactas from mo' than a single line, or tha buffer text is in
line mode, tha deleted text shall be copied tha fuck into tha numeric
buffers, as well.
.LP
\fICurrent line\fP: Set ta tha straight-up original gangsta text region line dat appears
in tha edit buffer, unless dat line has been deleted, in
which case it shall be set ta tha last line up in tha edit buffer, or
line 1 if tha edit buffer is empty.
.LP
\fICurrent column\fP:
.IP " 1." 4
If tha line is empty, set ta column posizzle 1.
.LP
.IP " 2." 4
Otherwise, if tha buffer text is up in line mode or tha motion was from
the cursor toward tha end of tha edit buffer:
.RS
.IP " a." 4
If a cold-ass lil characta from tha current line is displayed up in tha current column,
set ta tha last column dat displays any portion of
that character.
.LP
.IP " b." 4
Otherwise, set ta tha last column up in which any portion of any character
in tha line is displayed.
.LP
.RE
.LP
.IP " 3." 4
Otherwise, if a cold-ass lil characta is displayed up in tha column dat fuckin started the
text region, set ta tha last column dat displays any
portion of dat character.
.LP
.IP " 4." 4
Otherwise, set ta tha last column up in which any portion of any character
in tha line is displayed.
.LP
.SS Delete ta End-of-Line
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB]\fP \fBD
\fP
.fi
.RE
.sp
.LP
Delete tha text from tha current posizzle ta tha end of tha current
line; equivalent ta tha \fIvi\fP command:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB]\fP \fBd$
\fP
.fi
.RE
.SS Move ta End-of-Word
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBe
\fP
.fi
.RE
.sp
.LP
With tha exception dat lyrics is used instead of bigwordz as the
delimiter, dis command shall be equivalent ta tha \fBE\fP
command.
.SS Move ta End-of-Bigword
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBE
\fP
.fi
.RE
.sp
.LP
If tha edit buffer is empty it shall be a error. Shiiit, dis aint no joke. If less than \fIcount\fP
bigwordz end between tha cursor n' tha end of the
edit buffer, \fIcount\fP shall be adjusted ta tha number of bigword
endings between tha cursor n' tha end of tha edit buffer.
.LP
If used as a motion command:
.IP " 1." 4
Da text region shall be from tha last characta of tha \fIcount\fPth
next bigword up ta n' includin tha cursor
character.
.LP
.IP " 2." 4
Any text copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Set ta tha line containin tha current column.
.LP
\fICurrent column\fP: Set ta tha last column upon which any part of
the last characta of tha \fIcount\fPth next bigword is
displayed.
.SS Find Characta up in Current Line (Forward)
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBf\fP \fIcharacter\fP
.fi
.RE
.sp
.LP
It shall be a error if \fIcount\fP occurrencez of tha characta do
not occur afta tha cursor up in tha line.
.LP
If used as a motion command:
.IP " 1." 4
Da text range shall be from tha cursor characta up ta n' including
the \fIcount\fPth occurrence of tha specified character
afta tha cursor.
.LP
.IP " 2." 4
Any text copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Set ta tha last column up in which any portion
of tha \fIcount\fPth occurrence of tha specified character
afta tha cursor appears up in tha line.
.SS Find Characta up in Current Line (Reverse)
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBF\fP \fIcharacter\fP
.fi
.RE
.sp
.LP
It shall be a error if \fIcount\fP occurrencez of tha characta do
not occur before tha cursor up in tha line.
.LP
If used as a motion command:
.IP " 1." 4
Da text region shall be from tha \fIcount\fPth occurrence of the
specified characta before tha cursor, up ta yo, but not
includin tha cursor character.
.LP
.IP " 2." 4
Any text copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Set ta tha last column up in which any portion
of tha \fIcount\fPth occurrence of tha specified character
before tha cursor appears up in tha line.
.SS Move ta Line
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBG
\fP
.fi
.RE
.sp
.LP
If \fIcount\fP aint specified, it shall default ta tha last line
of tha edit buffer n' shit. If \fIcount\fP is pimped outa than tha last
line of tha edit buffer, it shall be a error.
.LP
If used as a motion command:
.IP " 1." 4
Da text region shall be from tha cursor line up ta n' including
the specified line.
.LP
.IP " 2." 4
Any text copied ta a funky-ass buffer shall be up in line mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Set ta \fIcount\fP if \fIcount\fP is specified;
otherwise, tha last line.
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Move ta Top of Screen
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBH
\fP
.fi
.RE
.sp
.LP
If tha beginnin of tha line \fIcount\fP pimped outa than tha straight-up original gangsta line
of which any portion appears on tha display do not
exist, it shall be a error.
.LP
If used as a motion command:
.IP " 1." 4
If up in open mode, tha text region shall be tha current line.
.LP
.IP " 2." 4
Otherwise, tha text region shall be from tha startin line up ta and
includin (the first line of tha display + \fIcount\fP
-1).
.LP
.IP " 3." 4
Any text copied ta a funky-ass buffer shall be up in line mode.
.LP
.LP
If not used as a motion command:
.LP
If up in open mode, dis command shall set tha current column ta non-
<blank> n' do not a god damn thang else.
.LP
Otherwise, it shall set tha current line n' current column as bigs up.
.LP
\fICurrent line\fP: Set ta (the first line of tha display + \fIcount\fP
-1).
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Insert Before Cursor
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBi
\fP
.fi
.RE
.sp
.LP
Enta text input mode before tha current cursor position. I aint talkin' bout chicken n' gravy biatch. No characters
already up in tha edit buffer shall be affected by this
command. Y'all KNOW dat shit, muthafucka! A \fIcount\fP shall cause tha input text ta be appended \fIcount\fP
-1 mo' times ta tha end of tha input.
.LP
\fICurrent line/column\fP: As specified fo' tha text input commands
(see Input Mode Commandz in
vi ).
.SS Insert at Beginnin of Line
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBI
\fP
.fi
.RE
.sp
.LP
This command shall be equivalent ta tha \fIvi\fP command ^[ \fIcount\fP]
\fBi\fP.
.SS Join
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBJ
\fP
.fi
.RE
.sp
.LP
If tha current line is tha last line up in tha edit buffer, it shall
be a error.
.LP
This command shall be equivalent ta tha \fIex\fP \fBjoin\fP command
with no addresses, and
an \fIex\fP command \fIcount\fP value of 1 if \fIcount\fP was not
specified or if a
\fIcount\fP of 1 was specified, n' a \fIex\fP command \fIcount\fP
value of \fIcount\fP -1
for any other value of \fIcount\fP, except dat tha current line and
column shall be set as bigs up.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Da last column up in which any portion of the
characta followin tha last characta up in tha initial line is
displayed, or tha last non- <newline> up in tha line if no characters
were appended.
.SS Move ta Bottom of Screen
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBL
\fP
.fi
.RE
.sp
.LP
If tha beginnin of tha line \fIcount\fP less than tha last line of
which any portion appears on tha display do not exist, it
shall be a error.
.LP
If used as a motion command:
.IP " 1." 4
If up in open mode, tha text region shall be tha current line.
.LP
.IP " 2." 4
Otherwise, tha text region shall include all lines from tha starting
cursor line ta (the last line of tha display -(
\fIcount\fP -1)).
.LP
.IP " 3." 4
Any text copied ta a funky-ass buffer shall be up in line mode.
.LP
.LP
If not used as a motion command:
.IP " 1." 4
If up in open mode, dis command shall set tha current column ta non-
<blank> n' do not a god damn thang else.
.LP
.IP " 2." 4
Otherwise, it shall set tha current line n' current column as bigs up.
.LP
.LP
\fICurrent line\fP: Set ta (the last line of tha display -( \fIcount\fP
-1)).
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Mark Position
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBm\fP \fIletter\fP
.fi
.RE
.sp
.LP
This command shall be equivalent ta tha \fIex\fP \fBmark\fP command
with tha specified
characta as a argument.
.SS Move ta Middle of Screen
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBM
\fP
.fi
.RE
.sp
.LP
Da middle line of tha display shall be calculated as bigs up:
.sp
.RS
.nf

\fB(the top line of tha display) + (((number of lines displayed) +1) /2) -1
\fP
.fi
.RE
.LP
If used as a motion command:
.IP " 1." 4
If up in open mode, tha text region shall be tha current line.
.LP
.IP " 2." 4
Otherwise, tha text region shall include all lines from tha starting
cursor line up ta n' includin tha middle line of the
display.
.LP
.IP " 3." 4
Any text copied ta a funky-ass buffer shall be up in line mode.
.LP
.LP
If not used as a motion command:
.LP
If up in open mode, dis command shall set tha current column ta non-
<blank> n' do not a god damn thang else.
.LP
Otherwise, it shall set tha current line n' current column as bigs up.
.LP
\fICurrent line\fP: Set ta tha middle line of tha display.
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Repeat Regular Expression Find (Forward)
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBn
\fP
.fi
.RE
.sp
.LP
If tha remembered search direction was forward, tha \fBn\fP command
shall be equivalent ta tha \fIvi\fP \fB/\fP command with
no charactas entered by tha user n' shit. Otherwise, it shall be equivalent
to tha \fIvi\fP \fB?\fP command wit no charactas entered
by tha user.
.LP
If tha \fBn\fP command is used as a motion command fo' tha \fB!\fP
command, tha editor shall not enta text input mode on the
last line on tha screen, n' shall behave as if tha user entered a
single \fB'!'\fP characta as tha text input.
.SS Repeat Regular Expression Find (Reverse)
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBN
\fP
.fi
.RE
.sp
.LP
Scan fo' tha next match of tha last pattern given ta \fB/\fP or \fB?\fP,
but up in tha reverse direction; dis is tha reverse of
\fBn\fP.
.LP
If tha remembered search direction was forward, tha \fBN\fP command
shall be equivalent ta tha \fIvi\fP \fB?\fP command with
no charactas entered by tha user n' shit. Otherwise, it shall be equivalent
to tha \fIvi\fP \fB/\fP command wit no charactas entered
by tha user n' shit. If tha \fBN\fP command is used as a motion command for
the \fB!\fP command, tha editor shall not enta text input
mode on tha last line on tha screen, n' shall behave as if tha user
entered a single \fB!\fP characta as tha text input.
.SS Insert Empty Line Below
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBo
\fP
.fi
.RE
.sp
.LP
Enta text input mode up in a freshly smoked up line appended afta tha current line.
A \fIcount\fP shall cause tha input text ta be appended
\fIcount\fP -1 mo' times ta tha end of tha already added text, each
time startin on a new, appended line.
.LP
\fICurrent line/column\fP: As specified fo' tha text input commands
(see Input Mode Commandz in
vi ).
.SS Insert Empty Line Above
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBO
\fP
.fi
.RE
.sp
.LP
Enta text input mode up in a freshly smoked up line banged before tha current line.
A \fIcount\fP shall cause tha input text ta be appended
\fIcount\fP -1 mo' times ta tha end of tha already added text, each
time startin on a new, appended line.
.LP
\fICurrent line/column\fP: As specified fo' tha text input commands
(see Input Mode Commandz in
vi ).
.SS Put from Buffer Peepin
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB]\fP \fBp
\fP
.fi
.RE
.sp
.LP
If no \fIbuffer\fP is specified, tha unnamed buffer shall be used.
.LP
If tha buffer text is up in line mode, tha text shall be appended below
the current line, n' each line of tha buffer shall become
a freshly smoked up line up in tha edit buffer n' shiznit fo' realz. A \fIcount\fP shall cause tha buffer
text ta be appended \fIcount\fP -1 mo' times ta tha end of
the already added text, each time startin on a new, appended line.
.LP
If tha buffer text is up in characta mode, tha text shall be appended
into tha current line afta tha cursor, n' each line of the
buffer other than tha straight-up original gangsta n' last shall become a freshly smoked up line up in the
edit buffer n' shiznit fo' realz. A \fIcount\fP shall cause tha buffer text ta be
appended \fIcount\fP -1 mo' times ta tha end of tha already added
text, each time startin afta tha last added character.
.LP
\fICurrent line\fP: If tha buffer text is up in line mode, set tha line
to line +1; otherwise, unchanged.
.LP
\fICurrent column\fP: If tha buffer text is up in line mode:
.IP " 1." 4
If there be a non- <blank> up in tha straight-up original gangsta line of tha buffer, set to
the last column on which any portion of tha straight-up original gangsta non-
<blank> up in tha line is displayed.
.LP
.IP " 2." 4
If there is no non- <blank> up in tha straight-up original gangsta line of tha buffer, set to
the last column on which any portion of tha last non-
<newline> up in tha straight-up original gangsta line of tha buffer is displayed.
.LP
.LP
If tha buffer text is up in characta mode:
.IP " 1." 4
If tha text up in tha buffer is from mo' than a single line, then set
to tha last column on which any portion of tha first
characta from tha buffer is displayed.
.LP
.IP " 2." 4
Otherwise, if tha buffer is tha unnamed buffer, set ta tha last column
on which any portion of tha last characta from the
buffer is displayed.
.LP
.IP " 3." 4
Otherwise, set ta tha straight-up original gangsta column on which any portion of tha first
characta from tha buffer is displayed.
.LP
.SS Put from Buffer Before
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB]\fP \fBP
\fP
.fi
.RE
.sp
.LP
If no \fIbuffer\fP is specified, tha unnamed buffer shall be used.
.LP
If tha buffer text is up in line mode, tha text shall be banged above
the current line, n' each line of tha buffer shall become
a freshly smoked up line up in tha edit buffer n' shiznit fo' realz. A \fIcount\fP shall cause tha buffer
text ta be appended \fIcount\fP -1 mo' times ta tha end of
the already added text, each time startin on a new, appended line.
.LP
If tha buffer text is up in characta mode, tha text shall be inserted
into tha current line before tha cursor, n' each line of
the buffer other than tha straight-up original gangsta n' last shall become a freshly smoked up line in
the edit buffer n' shiznit fo' realz. A \fIcount\fP shall cause tha buffer text to
be appended \fIcount\fP -1 mo' times ta tha end of tha already added
text, each time startin afta tha last added character.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: If tha buffer text is up in line mode:
.IP " 1." 4
If there be a non- <blank> up in tha straight-up original gangsta line of tha buffer, set to
the last column on which any portion of dat character
is displayed.
.LP
.IP " 2." 4
If there is no non- <blank> up in tha straight-up original gangsta line of tha buffer, set to
the last column on which any portion of tha last non-
<newline> up in tha straight-up original gangsta line of tha buffer is displayed.
.LP
.LP
If tha buffer text is up in characta mode:
.IP " 1." 4
If tha buffer is tha unnamed buffer, set ta tha last column on which
any portion of tha last characta from tha buffer is
displayed.
.LP
.IP " 2." 4
Otherwise, set ta tha straight-up original gangsta column on which any portion of tha first
characta from tha buffer is displayed.
.LP
.SS Enta ex Mode
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBQ
\fP
.fi
.RE
.sp
.LP
Leave visual or open mode n' enta \fIex\fP command mode.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Unchanged.
.SS Replace Character
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBr\fP \fIcharacter\fP
.fi
.RE
.sp
.LP
Replace tha \fIcount\fP charactas at n' afta tha cursor wit the
specified character n' shit. If there be less than \fIcount\fP
non- <newline>s at n' afta tha cursor on tha line, it shall be an
error.
.LP
If characta is <control>-V, any next characta other than tha <newline>
shall be stripped of any special meaning
and used as a literal character.
.LP
If characta is <ESC>, no replacement shall be made n' tha current
line n' current column shall be unchanged.
.LP
If characta is <carriage-return> or <newline>, \fIcount\fP freshly smoked up lines
shall be appended ta tha current line fo' realz. All
but tha last of these lines shall be empty. \fIcount\fP characters
at n' afta tha cursor shall be discarded, n' any remaining
charactas afta tha cursor up in tha current line shall be moved to
the last of tha freshly smoked up lines. If tha \fBautoindent\fP edit option
is set, they shall be preceded by tha same number of \fBautoindent\fP
charactas found on tha line from which tha command was
executed.
.LP
\fICurrent line\fP: Unchanged unless tha replacement characta is
a <carriage-return> or <newline>, up in which case
it shall be set ta line + \fIcount\fP.
.LP
\fICurrent column\fP: Set ta tha last column posizzle on which a portion
of tha last replaced characta is displayed, or if the
replacement characta caused freshly smoked up lines ta be pimped, set ta non-
<blank>.
.SS Replace Characters
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBR
\fP
.fi
.RE
.sp
.LP
Enta text input mode all up in tha current cursor posizzle possibly replacing
text on tha current line fo' realz. A \fIcount\fP shall cause the
input text ta be appended \fIcount\fP -1 mo' times ta tha end of
the input.
.LP
\fICurrent line/column\fP: As specified fo' tha text input commands
(see Input Mode Commandz in
vi ).
.SS Substitute Character
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB][\fP\fIcount\fP\fB]\fP \fBs
\fP
.fi
.RE
.sp
.LP
This command shall be equivalent ta tha \fIvi\fP command:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB][\fP\fIcount\fP\fB]\fP \fBc<space>
\fP
.fi
.RE
.SS Substitute Lines
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB][\fP\fIcount\fP\fB]\fP \fBS
\fP
.fi
.RE
.sp
.LP
This command shall be equivalent ta tha \fIvi\fP command:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB][\fP\fIcount\fP\fB]\fP \fBc_
\fP
.fi
.RE
.SS Move Cursor ta Before Characta (Forward)
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBt\fP \fIcharacter\fP
.fi
.RE
.sp
.LP
It shall be a error if \fIcount\fP occurrencez of tha characta do
not occur afta tha cursor up in tha line.
.LP
If used as a motion command:
.IP " 1." 4
Da text region shall be from tha cursor up ta but not includin the
\fIcount\fPth occurrence of tha specified characta after
the cursor.
.LP
.IP " 2." 4
Any text copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Set ta tha last column up in which any portion
of tha characta before tha \fIcount\fPth occurrence of the
specified characta afta tha cursor appears up in tha line.
.SS Move Cursor ta Afta Characta (Reverse)
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBT\fP \fIcharacter\fP
.fi
.RE
.sp
.LP
It shall be a error if \fIcount\fP occurrencez of tha characta do
not occur before tha cursor up in tha line.
.LP
If used as a motion command:
.IP " 1." 4
If tha characta before tha cursor is tha specified character, it
shall be a error.
.LP
.IP " 2." 4
Da text region shall be from tha characta before tha cursor up to
but not includin tha \fIcount\fPth occurrence of the
specified characta before tha cursor.
.LP
.IP " 3." 4
Any text copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Set ta tha last column up in which any portion
of tha characta afta tha \fIcount\fPth occurrence of the
specified characta before tha cursor appears up in tha line.
.SS Undo
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBu
\fP
.fi
.RE
.sp
.LP
This command shall be equivalent ta tha \fIex\fP \fBundo\fP command
except dat tha current
line n' current column shall be set as bigs up:
.LP
\fICurrent line\fP: Set ta tha straight-up original gangsta line added or chizzled if any;
otherwise, move ta tha line precedin any deleted text if
one exists; otherwise, move ta line 1.
.LP
\fICurrent column\fP: If unfuckin wit a \fIex\fP command, set ta tha first
non-
<blank>.
.LP
Otherwise, if unfuckin wit a text input command:
.IP " 1." 4
If tha command was a \fBC\fP, \fBc\fP, \fBO\fP, \fBo\fP, \fBR\fP,
\fBS\fP, or \fBs\fP command, tha current column shall
be set ta tha value it held when tha text input command was entered.
.LP
.IP " 2." 4
Otherwise, set ta tha last column up in which any portion of tha first
characta afta tha deleted text is displayed, or, if no
non- <newline>s follow tha text deleted from dis line, set ta the
last column up in which any portion of tha last non-
<newline> up in tha line is displayed, or 1 if tha line is empty.
.LP
.LP
Otherwise, if a single line was modified (that is, not added or deleted)
by tha \fBu\fP command:
.IP " 1." 4
If text was added or chizzled, set ta tha last column up in which any
portion of tha straight-up original gangsta characta added or chizzled is
displayed.
.LP
.IP " 2." 4
If text was deleted, set ta tha last column up in which any portion of
the first characta afta tha deleted text is displayed, or,
if no non- <newline>s follow tha deleted text, set ta tha last column
in which any portion of tha last non- <newline>
in tha line is displayed, or 1 if tha line is empty.
.LP
.LP
Otherwise, set ta non- <blank>.
.SS Undo Current Line
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBU
\fP
.fi
.RE
.sp
.LP
Restore tha current line ta its state immediately before da most thugged-out
recent time dat it became tha current line.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Set ta tha straight-up original gangsta column up in tha line up in which
any portion of tha straight-up original gangsta characta up in tha line is
displayed.
.SS Move ta Beginnin of Word
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBw
\fP
.fi
.RE
.sp
.LP
With tha exception dat lyrics is used as tha delimita instead of
bigwords, dis command shall be equivalent ta tha \fBW\fP
command.
.SS Move ta Beginnin of Bigword
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBW
\fP
.fi
.RE
.sp
.LP
If tha edit buffer is empty, it shall be a error. Shiiit, dis aint no joke. If there be less
than \fIcount\fP bigwordz between tha cursor n' tha end
of tha edit buffer, \fIcount\fP shall be adjusted ta move tha cursor
to tha last bigword up in tha edit buffer.
.LP
If used as a motion command:
.IP " 1." 4
If tha associated command is \fBc\fP, \fIcount\fP is 1, n' tha cursor
is on a <blank>, tha region of text shall be the
current characta n' no further action shall be taken.
.LP
.IP " 2." 4
If there be less than \fIcount\fP bigwordz between tha cursor and
the end of tha edit buffer, then tha command shall succeed,
and tha region of text shall include tha last characta of tha edit
buffer.
.LP
.IP " 3." 4
If there be <blank>s or a end-of-line dat precede tha \fIcount\fPth
bigword, n' tha associated command is \fBc\fP,
the region of text shall be up ta n' includin tha last character
before tha precedin <blank>s or end-of-line.
.LP
.IP " 4." 4
If there be <blank>s or a end-of-line dat precede tha bigword,
and tha associated command is \fBd\fP or \fBy\fP, the
region of text shall be up ta n' includin tha last <blank> before
the start of tha bigword or end-of-line.
.LP
.IP " 5." 4
Any text copied ta a funky-ass buffer shall be up in characta mode.
.LP
.LP
If not used as a motion command:
.IP " 1." 4
If tha cursor is on tha last characta of tha edit buffer, it shall
be a error.
.LP
.LP
\fICurrent line\fP: Set ta tha line containin tha current column.
.LP
\fICurrent column\fP: Set ta tha last column up in which any part of
the first characta of tha \fIcount\fPth next bigword is
displayed.
.SS Delete Characta at Cursor
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB][\fP\fIcount\fP\fB]\fP \fBx
\fP
.fi
.RE
.sp
.LP
Delete tha \fIcount\fP charactas at n' afta tha current character
into \fIbuffer\fP, if specified, n' tha fuck into tha unnamed
buffer.
.LP
If tha line is empty, it shall be a error. Shiiit, dis aint no joke. If there be less than
\fIcount\fP non- <newline>s at n' afta tha cursor on
the current line, \fIcount\fP shall be adjusted ta tha number of non-
<newline>s at n' afta tha cursor.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: If tha line is empty, set ta column position
1. Otherwise, if there was \fIcount\fP or less non-
<newline>s at n' afta tha cursor on tha current line, set ta the
last column dat displays any part of tha last non-
<newline> of tha line. Otherwise, unchanged.
.SS Delete Characta Before Cursor
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB][\fP\fIcount\fP\fB]\fP \fBX
\fP
.fi
.RE
.sp
.LP
Delete tha \fIcount\fP charactas before tha current characta into
\fIbuffer\fP, if specified, n' tha fuck into tha unnamed
buffer.
.LP
If there be no charactas before tha current characta on tha current
line, it shall be a error. Shiiit, dis aint no joke. If there be less than
\fIcount\fP previous charactas on tha current line, \fIcount\fP shall
be adjusted ta tha number of previous charactas on the
line.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Set ta (current column - tha width of tha deleted
characters).
.SS Yank
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB][\fP\fIcount\fP\fB]\fP \fBy\fP \fImotion\fP
.fi
.RE
.sp
.LP
Copy (yank) tha region of text tha fuck into \fIbuffer\fP, if specified, and
into tha unnamed buffer.
.LP
If tha motion command is tha \fBy\fP command repeated:
.IP " 1." 4
Da buffer shall be up in line mode.
.LP
.IP " 2." 4
If there be less than \fIcount\fP -1 lines afta tha current line
in tha edit buffer, it shall be a error.
.LP
.IP " 3." 4
Da text region shall be from tha current line up ta n' including
the next \fIcount\fP -1 lines.
.LP
.LP
Otherwise, tha buffer text mode n' text region shall be as specified
by tha motion command.
.LP
\fICurrent line\fP: If tha motion was from tha current cursor position
toward tha end of tha edit buffer, unchanged. Y'all KNOW dat shit, muthafucka! Otherwise,
set ta tha straight-up original gangsta line up in tha edit buffer dat is part of tha text
region specified by tha motion command.
.LP
\fICurrent column\fP:
.IP " 1." 4
If tha motion was from tha current cursor posizzle toward tha end
of tha edit buffer, unchanged.
.LP
.IP " 2." 4
Otherwise, if tha current line is empty, set ta column posizzle 1.
.LP
.IP " 3." 4
Otherwise, set ta tha last column dat displays any part of tha first
characta up in tha file dat is part of tha text region
specified by tha motion command.
.LP
.SS Yank Current Line
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB][\fP\fIcount\fP\fB]\fP \fBY
\fP
.fi
.RE
.sp
.LP
This command shall be equivalent ta tha \fIvi\fP command:
.sp
.RS
.nf

\fB[\fP\fIbuffer\fP\fB][\fP\fIcount\fP\fB]\fP \fBy_
\fP
.fi
.RE
.SS Redraw Window
.LP
If up in open mode, tha \fBz\fP command shall have tha Synopsis:
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIcount\fP\fB]\fP \fBz
\fP
.fi
.RE
.sp
.LP
If \fIcount\fP aint specified, it shall default ta tha \fBwindow\fP
edit option -1. Da \fBz\fP command shall be equivalent
to tha \fIex\fP \fBz\fP command, wit a type characta of \fB=\fP
and a \fIcount\fP of
\fIcount\fP -2, except dat tha current line n' current column shall
be set as bigs up, n' tha \fBwindow\fP edit option shall
not be affected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha calculation fo' tha \fIcount\fP argument would
result up in a wack number, tha \fIcount\fP argument to
the \fIex\fP \fBz\fP command shall be zero fo' realz. A blank line shall be
written afta tha last line
is written.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Unchanged.
.LP
If not up in open mode, tha \fBz\fP command shall have tha following
Synopsis:
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB[\fP\fIline\fP\fB]\fP \fBz\fP \fB[\fP\fIcount\fP\fB]\fP \fIcharacter\fP
.fi
.RE
.sp
.LP
If \fIline\fP aint specified, it shall default ta tha current line.
If \fIline\fP is specified yo, but is pimped outa than the
number of lines up in tha edit buffer, it shall default ta tha number
of lines up in tha edit buffer.
.LP
If \fIcount\fP is specified, tha value of tha \fBwindow\fP edit option
shall be set ta \fIcount\fP (as busted lyrics bout up in tha \fIex\fP \fBwindow\fP
command), n' tha screen shall be redrawn.
.LP
\fIline\fP shall be placed as specified by tha followin characters:
.TP 7
<newline>,\ <carriage-return>
.sp
Place tha beginnin of tha line on tha straight-up original gangsta line of tha display.
.TP 7
\fB\&.\fP
Place tha beginnin of tha line up in tha centa of tha display. The
middle line of tha display shall be calculated as busted lyrics about
for tha \fBM\fP command.
.TP 7
\fB-\fP
Place a unspecified portion of tha line on tha last line of tha display.
.TP 7
\fB+\fP
If \fIline\fP was specified, equivalent ta tha <newline> case. If
\fIline\fP was not specified, display a screen where
the first line of tha display shall be (current last line) +1. If
there is no lines afta tha last line up in tha display, it shall
be a error.
.TP 7
\fB^\fP
If \fIline\fP was specified, display a screen where tha last line
of tha display shall contain a unspecified portion of the
first line of a gangbangin' finger-lickin' display dat had a unspecified portion of tha specified
line on tha last line of tha display. If dis calculation
results up in a line before tha beginnin of tha edit buffer, display
the first screen of tha edit buffer n' shit. 
.LP
Otherwise, display a screen where tha last line of tha display shall
contain a unspecified portion of (current first line -1).
If dis calculation thangs up in dis biatch up in a line before tha beginnin of the
edit buffer, it shall be a error.
.sp
.LP
\fICurrent line\fP: If \fIline\fP n' tha \fB'^'\fP characta were
specified:
.IP " 1." 4
If tha straight-up original gangsta screen was displayed as a result of tha command attempting
to display lines before tha beginnin of tha edit
buffer: if tha straight-up original gangsta screen was already displayed, unchanged; otherwise,
set ta (current first line -1).
.LP
.IP " 2." 4
Otherwise, set ta tha last line of tha display.
.LP
.LP
If \fIline\fP n' tha \fB'+'\fP characta was specified, set ta the
first line of tha display.
.LP
Otherwise, if \fIline\fP was specified, set ta \fIline\fP.
.LP
Otherwise, unchanged.
.LP
\fICurrent column\fP: Set ta non- <blank>.
.SS Exit
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBZZ
\fP
.fi
.RE
.sp
.LP
This command shall be equivalent ta tha \fIex\fP \fBxit\fP command
with no addresses,
trailin \fB!\fP, or filename (see tha \fIex\fP \fBxit\fP command).
.SS Input Mode Commandz up in vi
.LP
In text input mode, tha current line shall consist of zero or more
of tha followin categories, plus tha terminating
<newline>:
.IP " 1." 4
Charactas precedin tha text input entry point
.LP
Charactas up in dis category shall not be modified durin text input
mode.
.LP
.IP " 2." 4
\fBautoindent\fP characters
.LP
\fBautoindent\fP charactas shall be automatically banged tha fuck into each
line dat is pimped up in text input mode, either as a
result of enterin a <newline> or <carriage-return> while up in text
input mode, or as a effect of tha command itself;
for example, \fBO\fP or \fBo\fP (see tha \fIex\fP \fBautoindent\fP
command), as if entered
by tha user.
.LP
It shall be possible ta erase \fBautoindent\fP charactas wit the
<control>-D command; it is unspecified whether they
can be erased by <control>-H, <control>-U, n' <control>-W characters.
Erasin any \fBautoindent\fP character
turns tha glyph tha fuck into erase-columns n' deletes tha characta from
the edit buffer yo, but do not chizzle its representation on the
screen.
.LP
.IP " 3." 4
Text input characters
.LP
Text input charactas is tha charactas entered by tha user n' shit. Erasing
any text input characta turns tha glyph into
erase-columns n' deletes tha characta from tha edit buffer yo, but
does not chizzle its representation on tha screen.
.LP
Each text input characta entered by tha user (that do not have
a special meaning) shall be treated as bigs up:
.RS
.IP " a." 4
Da text input characta shall be appended ta tha last characta in
the edit buffer from tha first, second, or third
categories.
.LP
.IP " b." 4
If there be no erase-columns on tha screen, tha text input command
was tha \fBR\fP command, n' charactas up in tha fifth
category from tha original gangsta line follow tha cursor, tha next such character
shall be deleted from tha edit buffer n' shit. If the
\fBslowopen\fP edit option aint set, tha correspondin glyph on
the screen shall become erase-columns.
.LP
.IP " c." 4
If there be erase-columns on tha screen, as nuff columns as they
occupy, or as is necessary, shall be overwritten ta display
the text input character n' shit. (If only part of a multi-column glyph is
overwritten, tha remainder shall be left on tha screen, and
continue ta be treated as erase-columns; it is unspecified whether
the remainder of tha glyph is modified up in any way.)
.LP
.IP " d." 4
If additionizzle display line columns is needed ta display tha text
input character:
.RS
.IP " 1." 4
If tha \fBslowopen\fP edit option is set, tha text input characters
shall be displayed on subsequent display line columns,
overwritin any charactas displayed up in dem columns.
.LP
.IP " 2." 4
Otherwise, any charactas currently displayed on or afta tha column
on tha display line where tha text input characta is ta be
displayed shall be pushed ahead tha number of display line columns
necessary ta display tha rest of tha text input character.
.LP
.RE
.LP
.RE
.LP
.IP " 4." 4
Erase-columns
.LP
Erase-columns is not logically part of tha edit buffer, appearing
only on tha screen, n' may be overwritten on tha screen by
subsequent text input characters. When text input mode ends, all erase-columns
shall no longer step tha fuck up on tha screen.
.LP
Erase-columns is initially tha region of text specified by tha \fBc\fP
command (see Chizzle );
however, erasin \fBautoindent\fP or text input charactas causes
the glyphz of tha erased charactas ta be treated as
erase-columns.
.LP
.IP " 5." 4
Charactas followin tha text region fo' tha \fBc\fP command, or the
text input entry point fo' all other commands
.LP
Charactas up in dis category shall not be modified durin text input
mode, except as specified up in category 3.b. fo' tha \fBR\fP
text input command, or as <blank>s deleted when a <newline> or <carriage-return>
is entered.
.LP
.LP
It be unspecified whether it be a error ta attempt ta erase past
the beginnin of a line dat was pimped by tha entry of a
<newline> or <carriage-return> durin text input mode. If it is not
an error, tha editor shall behave as if tha erasing
characta was entered immediately afta tha last text input character
entered on tha previous line, n' all of tha non-
<newline>s on tha current line shall be treated as erase-columns.
.LP
When text input mode is entered, or afta a text input mode character
is entered (except as specified fo' tha special characters
below), tha cursor shall be positioned as bigs up:
.IP " 1." 4
On tha straight-up original gangsta column dat displays any part of tha straight-up original gangsta erase-column,
if one exists
.LP
.IP " 2." 4
Otherwise, if tha \fBslowopen\fP edit option is set, on tha first
display line column afta tha last characta up in tha first,
second, or third categories, if one exists
.LP
.IP " 3." 4
Otherwise, tha straight-up original gangsta column dat displays any part of tha straight-up original gangsta character
in tha fifth category, if one exists
.LP
.IP " 4." 4
Otherwise, tha display line column afta tha last characta up in the
first, second, or third categories, if one exists
.LP
.IP " 5." 4
Otherwise, on column posizzle 1
.LP
.LP
Da charactas dat is updated on tha screen durin text input mode
are unspecified, other than dat tha last text input
characta shall always be updated, and, if tha \fBslowopen\fP edit
option aint set, tha current cursor characta shall always be
updated.
.LP
Da followin justifications is fo' command charactas entered during
text input mode.
.SS NUL
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fBNUL
\fP
.fi
.RE
.sp
.LP
If tha straight-up original gangsta characta of tha text input be a NUL, da most thugged-out recently
input text shall be input as if entered by tha user, and
then text input mode shall be exited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da text shall be input literally;
that is, charactas is neither macro or abbreviation
expanded, nor is any charactas interpreted up in any special manner.
It be unspecified whether implementations shall support more
than 256 bytez of remembered input text.
.SS <control>-D
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<control>-D
\fP
.fi
.RE
.sp
.LP
Da <control>-D characta shall have no special meanin when up in text
input mode fo' a line-oriented command (see Command Descriptions in
vi ).
.LP
This command need not be supported on block-mode terminals.
.LP
If tha cursor do not follow a \fBautoindent\fP character, or an
\fBautoindent\fP characta n' a \fB'0'\fP or
\fB'^'\fP character:
.IP " 1." 4
If tha cursor is up in column posizzle 1, tha <control>-D characta shall
be discarded n' no further action taken.
.LP
.IP " 2." 4
Otherwise, tha <control>-D characta shall have no special meaning.
.LP
.LP
If tha last input characta was a \fB'0'\fP, tha cursor shall be
moved ta column posizzle 1.
.LP
Otherwise, if tha last input characta was a \fB'^'\fP, tha cursor
shall be moved ta column posizzle 1. In addition, the
\fBautoindent\fP level fo' tha next input line shall be derived from
the same line from which tha \fBautoindent\fP level fo' the
current input line was derived.
.LP
Otherwise, tha cursor shall be moved back ta tha column afta the
previous shiftwidth (see tha \fIex\fP \fBshiftwidth\fP command) boundary.
.LP
All of tha glyphs on columns between tha startin cursor position
and (inclusively) tha endin cursor posizzle shall become
erase-columns as busted lyrics bout up in Input Mode Commandz up in vi .
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Set ta 1 if tha <control>-D was preceded by
a \fB'^'\fP or \fB'0'\fP ; otherwise, set to
(column -1) -((column -2) % \fBshiftwidth\fP).
.SS <control>-H
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<control>-H
\fP
.fi
.RE
.sp
.LP
If up in text input mode fo' a line-oriented command, n' there be no
charactas ta erase, text input mode shall be terminated, no
further action shall be done fo' dis command, n' tha current line
and column shall be unchanged.
.LP
If there be charactas other than \fBautoindent\fP charactas that
have been input on tha current line before tha cursor, the
cursor shall move back one character.
.LP
Otherwise, if there be \fBautoindent\fP charactas on tha current
line before tha cursor, it is implementation-defined whether
the <control>-H command be a error or if tha cursor moves back one
\fBautoindent\fP character.
.LP
Otherwise, if tha cursor is up in column posizzle 1 n' there be previous
lines dat done been input, it is implementation-defined
whether tha <control>-H command be a error or if it is equivalent
to enterin <control>-H afta tha last input
characta on tha previous input line.
.LP
Otherwise, it shall be a error.
.LP
All of tha glyphs on columns between tha startin cursor position
and (inclusively) tha endin cursor posizzle shall become
erase-columns as busted lyrics bout up in Input Mode Commandz up in vi .
.LP
Da current erase characta (see \fIstty\fP) shall cause a equivalent
action ta the
<control>-H command, unless tha previously banged characta was
a backslash, up in which case it shall be as if tha literal
current erase characta had been banged instead of tha backslash.
.LP
\fICurrent line\fP: Unchanged, unless previously input lines is erased,
in which case it shall be set ta line -1.
.LP
\fICurrent column\fP: Set ta tha straight-up original gangsta column dat displays any portion
of tha characta backed up over.
.SS <newline>
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<newline>
.sp

<carriage-return>
.sp

<control>-J
.sp

<control>-M
\fP
.fi
.RE
.sp
.LP
If input was part of a line-oriented command, text input mode shall
be terminated n' tha command shall continue execution with
the input provided.
.LP
Otherwise, terminizzle tha current line. If there be no characters
other than \fBautoindent\fP charactas on tha line, all
charactas on tha line shall be discarded. Y'all KNOW dat shit, muthafucka! Otherwise, it is unspecified
whether tha \fBautoindent\fP charactas up in tha line are
modified by enterin these characters.
.LP
Continue text input mode on a freshly smoked up line appended afta tha current
line. If tha \fBslowopen\fP edit option is set, tha lines on
the screen below tha current line shall not be pushed down yo, but the
first of dem shall be cleared n' shall step tha fuck up ta be
overwritten. I aint talkin' bout chicken n' gravy biatch. Otherwise, tha linez of tha screen below tha current
line shall be pushed down.
.LP
If tha \fBautoindent\fP edit option is set, a appropriate number
of \fBautoindent\fP charactas shall be added as a prefix to
the line as busted lyrics bout by tha \fIex\fP \fBautoindent\fP edit option.
.LP
All columns afta tha cursor dat is erase-columns (as busted lyrics about
in Input Mode Commandz up in vi )
shall be discarded.
.LP
If tha \fBautoindent\fP edit option is set, all <blank>s immediately
followin tha cursor shall be discarded.
.LP
All remainin charactas afta tha cursor shall be transferred to
the freshly smoked up line, positioned afta any \fBautoindent\fP
characters.
.LP
\fICurrent line\fP: Set ta current line +1.
.LP
\fICurrent column\fP: Set ta tha straight-up original gangsta column dat displays any portion
of tha straight-up original gangsta characta afta tha \fBautoindent\fP
charactas on tha freshly smoked up line, if any, or tha straight-up original gangsta column posizzle after
the last \fBautoindent\fP character, if any, or column
posizzle 1.
.SS <control>-T
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<control>-T
\fP
.fi
.RE
.sp
.LP
Da <control>-T characta shall have no special meanin when up in text
input mode fo' a line-oriented command (see Command Descriptions in
vi ).
.LP
This command need not be supported on block-mode terminals.
.LP
Behave as if tha user entered tha minimum number of <blank>s necessary
to move tha cursor forward ta tha column position
afta tha next \fBshiftwidth\fP (see tha \fIex\fP \fBshiftwidth\fP
command) boundary.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Set ta \fIcolumn\fP + \fBshiftwidth\fP - ((column
-1) % \fBshiftwidth\fP).
.SS <control>-U
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<control>-U
\fP
.fi
.RE
.sp
.LP
If there be charactas other than \fBautoindent\fP charactas that
have been input on tha current line before tha cursor, the
cursor shall move ta tha straight-up original gangsta characta input afta tha \fBautoindent\fP
characters.
.LP
Otherwise, if there be \fBautoindent\fP charactas on tha current
line before tha cursor, it is implementation-defined whether
the <control>-U command be a error or if tha cursor moves ta the
first column posizzle on tha line.
.LP
Otherwise, if tha cursor is up in column posizzle 1 n' there be previous
lines dat done been input, it is implementation-defined
whether tha <control>-U command be a error or if it is equivalent
to enterin <control>-U afta tha last input
characta on tha previous input line.
.LP
Otherwise, it shall be a error.
.LP
All of tha glyphs on columns between tha startin cursor position
and (inclusively) tha endin cursor posizzle shall become
erase-columns as busted lyrics bout up in Input Mode Commandz up in vi .
.LP
Da current \fIkill\fP characta (see \fIstty\fP) shall cause a equivalent
action ta the
<control>-U command, unless tha previously banged characta was
a backslash, up in which case it shall be as if tha literal
current \fIkill\fP characta had been banged instead of tha backslash.
.LP
\fICurrent line\fP: Unchanged, unless previously input lines is erased,
in which case it shall be set ta line -1.
.LP
\fICurrent column\fP: Set ta tha straight-up original gangsta column dat displays any portion
of tha last characta backed up over.
.SS <control>-V
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<control>-V
.sp

<control>-Q
\fP
.fi
.RE
.sp
.LP
Allow tha entry of any subsequent character, other than <control>-J
or tha <newline>, as a literal character,
removin any special meanin dat it may gotta tha editor up in text
input mode. If a <control>-V or <control>-Q is
entered before a <control>-J or <newline>, tha <control>-V or <control>-Q
characta shall be discarded, and
the <control>-J or <newline> shall behave as busted lyrics bout up in tha <newline>
command characta durin input mode.
.LP
For purposez of tha display only, tha editor shall behave as if a
\fB'^'\fP characta was entered, n' tha cursor shall be
positioned as if overwritin tha \fB'^'\fP character n' shit. When a subsequent
characta is entered, tha editor shall behave as if that
characta was entered instead of tha original gangsta <control>-V or <control>-Q
character.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP: Unchanged.
.SS <control>-W
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<control>-W
\fP
.fi
.RE
.sp
.LP
If there be charactas other than \fBautoindent\fP charactas that
have been input on tha current line before tha cursor, the
cursor shall move back over tha last word precedin tha cursor (including
any <blank>s between tha end of tha last word and
the current cursor); tha cursor shall not move ta before tha first
characta afta tha end of any \fBautoindent\fP characters.
.LP
Otherwise, if there be \fBautoindent\fP charactas on tha current
line before tha cursor, it is implementation-defined whether
the <control>-W command be a error or if tha cursor moves ta the
first column posizzle on tha line.
.LP
Otherwise, if tha cursor is up in column posizzle 1 n' there be previous
lines dat done been input, it is implementation-defined
whether tha <control>-W command be a error or if it is equivalent
to enterin <control>-W afta tha last input
characta on tha previous input line.
.LP
Otherwise, it shall be a error.
.LP
All of tha glyphs on columns between tha startin cursor position
and (inclusively) tha endin cursor posizzle shall become
erase-columns as busted lyrics bout up in Input Mode Commandz up in vi .
.LP
\fICurrent line\fP: Unchanged, unless previously input lines is erased,
in which case it shall be set ta line -1.
.LP
\fICurrent column\fP: Set ta tha straight-up original gangsta column dat displays any portion
of tha last characta backed up over.
.SS <ESC>
.TP 7
\fISynopsis\fP:
.sp
.RS
.nf

\fB<ESC>
\fP
.fi
.RE
.sp
.LP
If input was part of a line-oriented command:
.IP " 1." 4
If \fIinterrupt\fP was entered, text input mode shall be terminated
and tha editor shall return ta command mode. Da terminal
shall be alerted.
.LP
.IP " 2." 4
If <ESC> was entered, text input mode shall be terminated n' the
command shall continue execution wit tha input
provided.
.LP
.LP
Otherwise, terminizzle text input mode n' return ta command mode.
.LP
Any \fBautoindent\fP charactas entered on newly pimped lines that
have no other non- <newline>s shall be deleted.
.LP
Any leadin \fBautoindent\fP n' <blank>s on newly pimped lines shall
be rewritten ta be tha minimum number of
<blank>s possible.
.LP
Da screen shall be redisplayed as necessary ta match tha contents
of tha edit buffer.
.LP
\fICurrent line\fP: Unchanged.
.LP
\fICurrent column\fP:
.IP " 1." 4
If there be text input charactas on tha current line, tha column
shall be set ta tha last column where any portion of tha last
text input characta is displayed.
.LP
.IP " 2." 4
Otherwise, if a cold-ass lil characta is displayed up in tha current column, unchanged.
.LP
.IP " 3." 4
Otherwise, set ta column posizzle 1.
.LP
.SH EXIT STATUS
.LP
Da followin exit joints shall be returned:
.TP 7
\ 0
Successful completion.
.TP 7
>0
An error occurred.
.sp
.SH CONSEQUENCES OF ERRORS
.LP
When any error is encountered n' tha standard input aint a terminal
device file, \fIvi\fP shall not write tha file or return
to command or text input mode, n' shall terminizzle wit a non-zero
exit status.
.LP
Otherwise, when a unrecoverable error is encountered it shall be
equivalent ta a SIGHUP asynchronous event.
.LP
Otherwise, when a error is encountered, tha editor shall behave as
specified up in Command
Descriptions up in vi .
.LP
\fIDa followin sections is informative.\fP
.SH APPLICATION USAGE
.LP
None.
.SH EXAMPLES
.LP
None.
.SH RATIONALE
.LP
See tha RATIONALE fo' \fIex\fP fo' mo' shiznit on \fIvi\fP. Major
portionz of tha \fIvi\fP utility
specification point ta \fIex\fP ta avoid inadvertent divergence. While
\fIex\fP n' \fIvi\fP have historically been implemented as a single
utility, dis aint required by
IEEE\ Std\ 1003.1-2001.
.LP
It be recognized dat portionz of \fIvi\fP would be difficult, if
not impossible, ta implement satisfactorily on a funky-ass block-mode
terminal, or a terminal without any form of cursor addressing, thus
it aint a mandatory requirement dat such features should
work on all terminals. Well shiiiit, it is tha intention, however, dat a \fIvi\fP
implementation should provide tha full set of capabilitizzles on
all terminals capable of supportin em.
.LP
Historically, \fIvi\fP exited immediately if tha standard input was
not a terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. IEEE\ Std\ 1003.1-2001 permits yo, but
does not require, dis behavior fo' realz. An end-of-file condizzle aint equivalent
to a end-of-file character n' shiznit fo' realz. A common end-of-file
character, <control>-D, is historically a \fIvi\fP command.
.LP
Da text up in tha STDOUT section reflects tha usage of tha verb \fIdisplay\fP
in dis section; some implementationz of \fIvi\fP
use standard output ta write ta tha terminal yo, but IEEE\ Std\ 1003.1-2001
does not require dat ta be tha case.
.LP
Historically, implementations reverted ta open mode if tha terminal
was incapable of supportin full visual mode.
IEEE\ Std\ 1003.1-2001 requires dis behavior yo. Historically, tha open
mode of \fIvi\fP behaved roughly equivalently ta the
visual mode, wit tha exception dat only a single line from tha edit
buffer (one "buffer line") was kept current at any time.
This line was normally displayed on tha next-to-last line of a terminal
with cursor addressin (and tha last line performed its
normal visual functions fo' line-oriented commandz n' lyrics).
In addition, some few commandz behaved differently up in open mode
than up in visual mode. IEEE\ Std\ 1003.1-2001 requires conformizzle to
historical practice.
.LP
Historically, \fIex\fP n' \fIvi\fP implementations have expected
text ta proceed up in the
usual European/Latin order of left ta right, top ta bottom. There
is no requirement up in IEEE\ Std\ 1003.1-2001 dat dis be
the case. Da justification was deliberately freestyled rockin lyrics like
"before", "after", "first", n' "last" up in order to
permit implementations ta support tha natural text order of tha language.
.LP
Historically, lines past tha end of tha edit buffer was marked with
single tilde ( \fB'~'\fP ) characters; dat is, if
the one-based display was 20 lines up in length, n' tha last line of
the file was on line one, then lines 2-20 would contain only a
single \fB'~'\fP character.
.LP
Historically, tha \fIvi\fP editor attempted ta display only complete
lines all up in tha bottom of tha screen (it did display partial
lines all up in tha top of tha screen). If a line was too long ta fit in
its entirety all up in tha bottom of tha screen, tha screen lines where
the line would done been displayed was displayed as single \fB'@'\fP
characters, instead of displayin part of tha line.
IEEE\ Std\ 1003.1-2001 permits yo, but do not require, dis behavior.
Implementations is encouraged ta attempt always to
display a cold-ass lil complete line all up in tha bottom of tha screen when bustin scrolling
or screen positionin by buffer lines.
.LP
Historically, lines marked wit \fB'@'\fP was also used ta minimize
output ta dumb terminals over slow lines; dat is,
changes local ta tha cursor was updated yo, but chizzlez ta lines on
the screen dat was not close ta tha cursor was simply marked
with a \fB'@'\fP sign instead of bein updated ta match tha current
text. IEEE\ Std\ 1003.1-2001 permits yo, but do not
require dis feature cuz it is used eva less frequently as terminals
become smarta n' connections is faster.
.SS Initialization up in ex n' vi
.LP
Historically, \fIvi\fP always had a line up in tha edit buffer, even
if tha edit buffer was "empty". For example:
.IP " 1." 4
Da \fIex\fP command \fB=\fP executed from visual mode freestyled "1" when
the buffer was
empty.
.LP
.IP " 2." 4
Writes from visual mode of a empty edit buffer freestyled filez of a single
characta (a <newline>), while writes from \fIex\fP mode of a empty
edit buffer freestyled empty files.
.LP
.IP " 3." 4
Put n' read commandz tha fuck into a empty edit buffer left a empty line
at tha top of tha edit buffer.
.LP
.LP
For consistency, IEEE\ Std\ 1003.1-2001 do not permit any of these
behaviors.
.LP
Historically, \fIvi\fP did not always return tha terminal ta its original
modes; fo' example, ICRNL was modified if dat shiznit was not
originally set. IEEE\ Std\ 1003.1-2001 do not permit dis behavior.
.SS Command Descriptions up in vi
.LP
Motion commandz is among da most thugged-out fucked up aspectz of \fIvi\fP
to describe. With some exceptions, tha text region and
buffer type effect of a motion command on a \fIvi\fP command is busted lyrics about
on a cold-ass lil case-by-case basis. Da descriptionz of text
regions up in IEEE\ Std\ 1003.1-2001 is not intended ta imply direction;
that is, a inclusive region from line \fIn\fP to
line \fIn\fP+5 is identical ta a region from line \fIn\fP+5 ta line
\fIn\fP. This iz of mo' than academic interest-movements to
marks can be up in either direction, and, if tha \fBwrapscan\fP option
is set, so can movements ta search points yo. Historically, lines
are always stored tha fuck into buffers up in text order; dat is, from tha start
of tha edit buffer ta tha end yo, but it ain't no stoppin cause I be still poppin'. IEEE\ Std\ 1003.1-2001
requires conformizzle ta oldschool practice.
.LP
Historically, command counts was applied ta any associated motion,
and was multiplicatizzle ta any supplied motion count. For
example, \fB2cw\fP is tha same ol' dirty as \fBc2w\fP, n' \fB2c3w\fP is the
same as \fBc6w\fP. IEEE\ Std\ 1003.1-2001 requires
this behavior yo. Historically, \fIvi\fP commandz dat used bigwords,
words, paragraphs, n' sentences as objects treated crews of
empty lines, or lines dat contained only <blank>s, inconsistently.
Some commandz treated dem as a single entity, while
others treated each line separately. For example, tha \fBw\fP, \fBW\fP,
and \fBB\fP commandz treated crewz of empty lines as
individual lyrics; dat is, tha command would move tha cursor ta each
new empty line. Da \fBe\fP n' \fBE\fP commandz treated
groupz of empty lines as a single word; dat is, tha straight-up original gangsta use would
move past tha crew of lines. Da \fBb\fP command would just
beep all up in tha user, or if done from tha start of tha line as a motion
command, fail up in unexpected ways. If tha lines contained only
(or ended with) <blank>s, tha \fBw\fP n' \fBW\fP commandz would just
beep all up in tha user, tha \fBE\fP n' \fBe\fP commands
would treat tha crew as a single word, n' tha \fBB\fP n' \fBb\fP
commandz would treat tha lines as individual lyrics. For
consistency n' simplicitizzle of justification, IEEE\ Std\ 1003.1-2001
requires dat all \fIvi\fP commandz treat crews of
empty or blank lines as a single entity, n' dat movement through
lines endin wit <blank>s be consistent wit other
movements.
.LP
Historically, \fIvi\fP documentation indicated dat any number of
double quotes was skipped afta punctuation marks at
sentence boundaries; however, implementations only skipped single
quotes. IEEE\ Std\ 1003.1-2001 requires both ta be
skipped.
.LP
Historically, tha straight-up original gangsta n' last charactas up in tha edit buffer were
word boundaries. Put ya muthafuckin choppers up if ya feel dis! This oldschool practice is required by
IEEE\ Std\ 1003.1-2001.
.LP
Historically, \fIvi\fP attempted ta update tha minimum number of columns
on tha screen possible, which could lead ta misleading
information bein displayed. Y'all KNOW dat shit, muthafucka! IEEE\ Std\ 1003.1-2001 make no requirements
other than dat tha current characta being
entered is displayed erectly, leavin all other decisions up in this
area up ta tha implementation.
.LP
Historically, lines was arbitrarily folded between columnz of any
charactas dat required multiple column positions on the
screen, wit tha exception of tabs, which terminated all up in tha right-hand
margin. I aint talkin' bout chicken n' gravy biatch. IEEE\ Std\ 1003.1-2001 permits tha former
and requires tha latter n' shit. Implementations dat do not arbitrarily break
lines between columnz of charactas dat occupy multiple
column positions should not permit tha cursor ta rest on a cold-ass lil column
that do not contain any part of a cold-ass lil character.
.LP
Da oldschool \fIvi\fP had a problem up in dat all movements was by
buffer lines, not by display or screen lines. This is often
the right thang ta do; fo' example, single line movements, such as
\fBj\fP or \fBk\fP, should work on buffer lines. Commandz like
\fBdj\fP, or \fBj.\fP, where \fB.\fP be a cold-ass lil chizzle command, only make
sense fo' buffer lines. Well shiiiit, it is not, however, tha right thang
to do fo' screen motion or scrollin commandz like <control>-D, <control>-F,
and \fBH\fP. If tha window is fairly
small, rockin buffer lines up in these cases can result up in straight-up
random motion; fo' example, \fB1\fP <control>-D can result
in a cold-ass lil straight-up chizzled screen, without any overlap. This is clearly
not what tha fuck tha user wanted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da problem is even worse up in the
case of tha \fBH\fP, \fBL\fP, n' \fBM\fP commands-as they position
the cursor all up in tha straight-up original gangsta non- <blank> of tha line, they
may all refer ta tha same location up in big-ass lines, n' will result
in no movement at all.
.LP
In addition, if tha line is larger than tha screen, rockin buffer lines
can make it impossible ta display partz of tha line-there
are not any commandz dat do not display tha beginnin of tha line
in oldschool \fIvi\fP, n' if both tha beginnin n' end of
the line cannot be on tha screen all up in tha same time, tha user suffers.
Finally, tha page n' half-page scrollin commands
historically moved ta tha straight-up original gangsta non- <blank> up in tha freshly smoked up line. If the
line be approximately tha same size as tha screen, this
is inadequate cuz tha cursor before n' afta a <control>-D command
will refer ta tha same location on tha screen.
.LP
Implementationz of \fIex\fP n' \fIvi\fP exist dat aint gots these
problems cuz the
relevant commandz ( <control>-B, <control>-D, <control>-F, <control>-U,
<control>-Y,
<control>-E, \fBH\fP, \fBL\fP, n' \fBM)\fP operate on display (screen)
lines, not (edit) buffer lines.
.LP
IEEE\ Std\ 1003.1-2001 do not permit dis behavior by default cuz
the standard pimpers believed dat users
would find it too confusing. But fuck dat shiznit yo, tha word on tha street is dat oldschool practice has been
relaxed. Y'all KNOW dat shit, muthafucka! For example, \fIex\fP n' \fIvi\fP historically attempted,
albeit sometimes unsuccessfully, ta never put part of a
line on tha last linez of a screen; fo' example, if a line would not
fit up in its entirety, no part of tha line was displayed, and
the screen lines correspondin ta tha line contained single \fB'@'\fP
characters. This behavior is permitted yo, but not required
by IEEE\ Std\ 1003.1-2001, so dat it is possible fo' implementations
to support long lines up in lil' small-ass screens more
reasonably without changin tha commandz ta be oriented ta tha display
(instead of oriented ta tha buffer).
IEEE\ Std\ 1003.1-2001 also permits implementations ta refuse ta edit
any edit buffer containin a line dat aint gonna fit
on tha screen up in its entirety.
.LP
Da display area (for example, tha value of tha \fBwindow\fP edit
option) has historically been "grown", or expanded, to
display freshly smoked up text when local movements is done up in displays where the
number of lines displayed is less than tha maximum possible.
Expansion has historically been tha straight-up original gangsta chizzle, when tha target
line is less than tha maximum possible expansion value away.
Scrollin has historically been tha next chizzle, done when tha target
line is less than half a gangbangin' finger-lickin' display away, n' otherwise, the
screen was redrawn. I aint talkin' bout chicken n' gravy biatch. There was exceptions, however, up in dat \fIex\fP
commandz generally always
caused tha screen ta be redrawn. I aint talkin' bout chicken n' gravy biatch. IEEE\ Std\ 1003.1-2001 do not specify
a standard behavior cuz there may be external
issues, like fuckin connection speed, tha number of charactas necessary
to redraw as opposed ta scroll, or terminal capabilitizzles that
implementations will gotta accommodate.
.LP
Da current line up in IEEE\ Std\ 1003.1-2001 maps one-to-one ta a funky-ass buffer
line up in tha file. Da current column do not.
There is two different column joints dat is busted lyrics bout by IEEE\ Std\ 1003.1-2001.
Da first is tha current column value
as set by nuff of tha \fIvi\fP commands. This value is remembered
for tha gametime of tha editor. Shiiit, dis aint no joke. Da second column value is the
actual posizzle on tha screen where tha cursor rests, n' you can put dat on yo' toast. Da two are
not always tha same. For example, when tha cursor is backed by a
multi-column character, tha actual cursor posizzle on tha screen has
historically been tha last column of tha characta up in command
mode, n' tha straight-up original gangsta column of tha characta up in input mode.
.LP
Commandz dat set tha current line yo, but dat do not set tha current
cursor value (for example, \fBj\fP n' \fBk\fP) attempt to
get as close as possible ta tha remembered column position, so that
the cursor tendz ta restrict itself ta a vertical column as the
user moves round up in tha edit buffer n' shit. IEEE\ Std\ 1003.1-2001 requires
conformizzle ta oldschool practice, requirin that
the display location of tha cursor on tha display line be adjusted
from tha current column value as necessary ta support this
historical behavior.
.LP
Historically, only a single line (and fo' some terminals, a single
line minus 1 column) of charactas could be entered by the
user fo' tha line-oriented commands; dat is, \fB:\fP, \fB!\fP, \fB/\fP,
or \fB?\fP. IEEE\ Std\ 1003.1-2001 permits,
but do not require, dis limitation.
.LP
Historically, "soft" errors up in \fIvi\fP caused tha terminal ta be
alerted yo, but no error message was displayed. Y'all KNOW dat shit, muthafucka! As a general
rule, no error message was displayed fo' errors up in command execution
in \fIvi\fP, when tha error resulted from tha user attempting
an invalid or impossible action, or when a searched-for object was
not found. Y'all KNOW dat shit, muthafucka! Examplez of soft errors included \fBh\fP all up in tha left
margin, <control>-B or \fB[[\fP all up in tha beginnin of tha file, \fB2G\fP
at tha end of tha file, n' so on. I aint talkin' bout chicken n' gravy biatch. In addition,
errors like fuckin \fB%\fP, \fB]]\fP, \fB}\fP, \fB)\fP, \fBN\fP, \fBn\fP,
\fBf\fP, \fBF\fP, \fBt\fP, n' \fBT\fP failin to
find tha searched-for object was soft as well. Less consistently,
\fB/\fP n' \fB?\fP displayed a error message if tha pattern
was not found, \fB/\fP, \fB?\fP, \fBN\fP, n' \fBn\fP displayed an
error message if no previous regular expression had been
specified, n' \fB;\fP did not display a error message if no previous
\fBf\fP, \fBF\fP, \fBt\fP, or \fBT\fP command had
occurred. Y'all KNOW dat shit, muthafucka! Also, behavior up in dis area might reasonably be based on
a runtime evaluation of tha speed of a network connection.
Finally, some implementations have provided error lyrics fo' soft
errors up in order ta assist naive users, based on tha value of a
verbose edit option. I aint talkin' bout chicken n' gravy biatch. IEEE\ Std\ 1003.1-2001 do not list specific
errors fo' which a error message shall be displayed.
Implementations should conform ta oldschool practice up in tha absence
of any phat reason ta diverge.
.SS Page Backwards
.LP
Da <control>-B n' <control>-F commandz historically considered it
an error ta attempt ta page past tha beginning
or end of tha file, whereas tha <control>-D n' <control>-U commands
simply moved ta tha beginnin or end of tha file.
For consistency, IEEE\ Std\ 1003.1-2001 requires tha latta behavior
for all four commandz fo' realz. All four commandz still
consider it a error if tha current line be all up in tha beginnin ( <control>-B,
<control>-U) or end ( <control>-F,
<control>-D) of tha file yo. Historically, tha <control>-B n' <control>-F
commandz skip two lines up in order to
include overlappin lines when a single command is entered. Y'all KNOW dat shit, muthafucka! This makes
less sense up in tha presence of a \fIcount\fP, as there will
be, by definition, no overlappin lines. Da actual calculation used
by oldschool implementationz of tha \fIvi\fP editor for
<control>-B was:
.sp
.RS
.nf

\fB((current first line) - count x (window edit option)) +2
\fP
.fi
.RE
.LP
and fo' <control>-F was:
.sp
.RS
.nf

\fB((current first line) + count x (window edit option)) -2
\fP
.fi
.RE
.LP
This calculation do not work well when intermixin commandz with
and without counts; fo' example, \fB3\fP <control>-F
is not equivalent ta enterin tha <control>-F command three times,
and aint reversible by enterin tha <control>-B
command three times. For consistency wit other \fIvi\fP commands
that take counts, IEEE\ Std\ 1003.1-2001 requires a
different calculation.
.SS Scroll Forward
.LP
Da 4BSD n' System V implementationz of \fIvi\fP differed on the
initial value used by tha \fBscroll\fP command. Y'all KNOW dat shit, muthafucka! 4BSD
used:
.sp
.RS
.nf

\fB((window edit option) +1) /2
\fP
.fi
.RE
.LP
while System V used tha value of tha \fBscroll\fP edit option. I aint talkin' bout chicken n' gravy biatch. The
System V version is specified by
IEEE\ Std\ 1003.1-2001 cuz tha standard pimpers believed that
it was mo' intuitizzle n' permitted tha user a method
of settin tha scroll value initially without also settin tha number
of lines dat is displayed.
.SS Scroll Forward by Line
.LP
Historically, tha <control>-E n' <control>-Y commandz considered
it a error if tha last n' first lines,
respectively, was already on tha screen. I aint talkin' bout chicken n' gravy biatch. IEEE\ Std\ 1003.1-2001 requires
conformizzle ta oldschool practice yo. Historically,
the <control>-E n' <control>-Y commandz had no effect up in open mode.
For simplicitizzle n' consistency of justification,
IEEE\ Std\ 1003.1-2001 requires dat they behave as usual, albeit
with a single line screen.
.SS Clear n' Redisplay
.LP
Da oldschool <control>-L command refreshed tha screen exactly as
it was supposed ta be currently displayed, replacing
any \fB'@'\fP charactas fo' lines dat had been deleted but not updated
on tha screen wit refreshed \fB'@'\fP characters.
Da intent of tha <control>-L command is ta refresh when tha screen
has been accidentally overwritten; fo' example, by a
\fBwrite\fP command from another user, or modem noise.
.SS Redraw Screen
.LP
Da oldschool <control>-R command redisplayed only when necessary
to update lines dat had been deleted but not updated
on tha screen n' dat was flagged wit \fB'@'\fP characters. There
is no requirement dat tha screen be up in any way refreshed
if no linez of dis form is currently displayed. Y'all KNOW dat shit, muthafucka! IEEE\ Std\ 1003.1-2001
permits implementations ta extend dis command to
refresh lines on tha screen flagged wit \fB'@'\fP charactas cuz
they is too long ta be displayed up in tha current
framework; however, tha current line n' column need not be modified.
.SS Search fo' tagstring
.LP
Historically, tha straight-up original gangsta non- <blank> at or afta tha cursor was the
first character, n' all subsequent charactas that
were word characters, up ta tha end of tha line, was included. Y'all KNOW dat shit, muthafucka! For
example, wit tha cursor on tha leadin space or on the
\fB'#'\fP characta up in tha text \fB"#bar@"\fP, tha tag was \fB"#bar"\fP
\&. On tha characta \fB'b'\fP it was
\fB"bar"\fP, n' on tha \fB'a'\fP dat shiznit was \fB"ar"\fP . IEEE\ Std\ 1003.1-2001
requires dis behavior.
.SS Replace Text wit Results from Shell Command
.LP
Historically, tha \fB<\fP, \fB>\fP, n' \fB!\fP commandz considered
most cursor motions other than line-oriented
motions a error; fo' example, tha command \fB>/foo<CR>\fP succeeded,
while tha command \fB>l\fP failed, even though
the text region busted lyrics bout by tha two commandz might be identical.
For consistency, all three commandz only consider entire lines
and not partial lines, n' tha region is defined as any line that
gotz nuff a cold-ass lil characta dat was specified by tha motion.
.SS Move ta Matchin Character
.LP
Other matchin charactas done been left implementation-defined in
order ta allow extensions like fuckin matchin \fB'<'\fP
and \fB'>'\fP fo' searchin HTML, or \fB#ifdef\fP, \fB#else\fP, and
\fB#endif\fP fo' searchin C source.
.SS Repeat Substitution
.LP
IEEE\ Std\ 1003.1-2001 requires dat any \fBc\fP n' \fBg\fP flags
specified ta tha previous substitute command be
ignored; however, tha \fBr\fP flag may still apply, if supported by
the implementation.
.SS Return ta Previous (Context or Section)
.LP
Da \fB[[\fP, \fB]]\fP, \fB(\fP, \fB)\fP, \fB{\fP, n' \fB}\fP commands
are all affected by "section boundaries" yo, but in
some oldschool implementations not all of tha commandz recognize
the same section boundaries. Put ya muthafuckin choppers up if ya feel dis! This be a funky-ass bug, not a gangbangin' feature, n' a
unique section-boundary algorithm was not busted lyrics bout fo' each command.
One special case dat is preserved is dat tha sentence
command moves ta tha end of tha last line of tha edit buffer while
the other commandz git all up in tha beginning, up in order ta preserve the
traditionizzle characta cut semantics of tha sentence command. Y'all KNOW dat shit, muthafucka! Historically,
\fIvi\fP section boundaries all up in tha beginnin n' end of
the edit buffer was tha straight-up original gangsta non- <blank> on tha straight-up original gangsta n' last
linez of tha edit buffer if one exists; otherwise, tha last
characta of tha straight-up original gangsta n' last linez of tha edit buffer if one exists.
To increase consistency wit other section locations, this
has been simplified by IEEE\ Std\ 1003.1-2001 ta tha straight-up original gangsta character
of tha straight-up original gangsta n' last linez of tha edit buffer, or the
first n' tha last linez of tha edit buffer if they is empty.
.LP
Sentence boundaries was problematic up in tha oldschool \fIvi\fP. They
were not only tha boundaries as defined fo' tha section
and paragraph commandz yo, but they was tha straight-up original gangsta non- <blank> that
occurred afta dem boundaries, as well yo. Historically, the
\fIvi\fP section commandz was documented as takin a optionizzle window
size as a \fIcount\fP precedin tha command. Y'all KNOW dat shit, muthafucka! This was not
implemented up in oldschool versions, so IEEE\ Std\ 1003.1-2001 requires
that tha \fIcount\fP repeat tha command, for
consistency wit other \fIvi\fP commands.
.SS Repeat
.LP
Historically, mapped commandz other than text input commandz could
not be repeated rockin tha \fBperiod\fP command.
IEEE\ Std\ 1003.1-2001 requires conformizzle ta oldschool practice.
.LP
Da restrictions on tha interpretation of special charactas (for
example, <control>-H) up in tha repetizzle of text input
mode commandz is intended ta match oldschool practice. For example,
given tha input sequence:
.sp
.RS
.nf

\fBiab<control>-H<control>-H<control>-Hdef<escape>
\fP
.fi
.RE
.LP
the user should be informed of a error when tha sequence is first
entered yo, but not durin a cold-ass lil command repetition. I aint talkin' bout chicken n' gravy biatch. Da character
<control>-T is specifically exempted from dis restriction. I aint talkin' bout chicken n' gravy biatch yo. Historical
implementationz of \fIvi\fP ignored <control>-T
charactas dat was input up in tha original gangsta command durin command
repetition. I aint talkin' bout chicken n' gravy biatch. IEEE\ Std\ 1003.1-2001 prohibits this
behavior.
.SS Find Regular Expression
.LP
Historically, commandz did not affect tha line searched ta or from
if tha motion command was a search ( \fB/\fP, \fB?\fP,
\fBN\fP, \fBn\fP) n' tha final posizzle was tha start/end of the
line. There was some special cases n' \fIvi\fP was not
consistent. IEEE\ Std\ 1003.1-2001 do not permit dis behavior,
for consistency. Oldschool implementations permitted but
were unable ta handle searches as motion commandz dat wrapped (that
is, cuz of tha edit option \fBwrapscan\fP) ta tha original
location. I aint talkin' bout chicken n' gravy biatch. IEEE\ Std\ 1003.1-2001 requires dat dis behavior be treated
as a error.
.LP
Historically, tha syntax \fB"/RE/0"\fP was used ta force tha command
to cut text up in line mode. IEEE\ Std\ 1003.1-2001
requires conformizzle ta oldschool practice.
.LP
Historically, up in open mode, a \fBz\fP specified ta a search command
redisplayed tha current line instead of displayin the
current screen wit tha current line highlighted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. For consistency
and simplicitizzle of justification, IEEE\ Std\ 1003.1-2001
does not permit dis behavior.
.LP
Historically, trailin \fBz\fP commandz was permitted n' ignored
if entered as part of a search used as a motion command. Y'all KNOW dat shit, muthafucka! For
consistency n' simplicitizzle of justification, IEEE\ Std\ 1003.1-2001
does not permit dis behavior.
.SS Execute a ex Command
.LP
Historically, \fIvi\fP implementations restricted tha commandz that
could be entered on tha colon command line (for example,
\fBappend\fP n' \fBchange\fP), n' some other commandz was known
to cause dem ta fail catastrophically. For consistency,
IEEE\ Std\ 1003.1-2001 do not permit these restrictions. When executing
an \fIex\fP
command by enterin \fB:\fP, it aint possible ta enta a <newline>
as part of tha command cuz it is considered tha end
of tha command. Y'all KNOW dat shit, muthafucka! A different approach is ta enta \fIex\fP command
mode by rockin tha \fIvi\fP
\fBQ\fP command (and lata resumin visual mode wit tha \fIex\fP
\fBvi\fP command). In \fIex\fP command mode, tha single-line limitation
does not exist. Right back up in yo muthafuckin ass. So, fo' example, tha following
is valid:
.sp
.RS
.nf

\fBQ
s/break here/break\\
here/
vi
\fP
.fi
.RE
.LP
IEEE\ Std\ 1003.1-2001 requires that, if tha \fIex\fP command overwrites
any part of
the screen dat would be erased by a refresh, \fIvi\fP pauses for
a characta from tha user n' shiznit yo. Historically, dis characta could be
any character; fo' example, a cold-ass lil characta input by tha user before the
message rocked up, or even a mapped character n' shit. This is probably
a bug yo, but implementations dat have tried ta be mo' rigorous by
requirin dat tha user enta a specific character, or dat the
user enta a cold-ass lil characta afta tha message was displayed, have been
forced by user indignation back tha fuck into oldschool behavior.
IEEE\ Std\ 1003.1-2001 requires conformizzle ta oldschool practice.
.SS Shift Left (Right)
.LP
Refer ta tha Rationale fo' tha \fB!\fP n' \fB/\fP commandz yo. Historically,
the \fB<\fP n' \fB>\fP commandz sometimes
moved tha cursor ta tha straight-up original gangsta non- <blank> (for example if tha command
was repeated or wit \fB_\fP as tha motion command),
and sometimes left it unchanged. Y'all KNOW dat shit, muthafucka! IEEE\ Std\ 1003.1-2001 do not permit
this inconsistency, requirin instead dat the
cursor always move ta tha straight-up original gangsta non- <blank> yo. Historically, tha \fB<\fP
and \fB>\fP commandz did not support buffer
arguments, although some implementations allow tha justification of
an optionizzle buffer n' shit. This behavior is neither required nor
disallowed by IEEE\ Std\ 1003.1-2001.
.SS Execute
.LP
Historically, buffers could execute other buffers, n' loops, infinite
and otherwise, was possible.
IEEE\ Std\ 1003.1-2001 requires conformizzle ta oldschool practice.
Da * \fIbuffer\fP syntax of \fIex\fP aint required up in \fIvi\fP,
because it aint oldschool practice n' has been used up in some
\fIvi\fP implementations ta support additionizzle scriptin languages.
.SS Reverse Case
.LP
Historically, tha \fB~\fP command ignored any associated \fIcount\fP,
and acted only on tha charactas up in tha current
line. For consistency wit other \fIvi\fP commands, IEEE\ Std\ 1003.1-2001
requires dat a associated \fIcount\fP act on
the next \fIcount\fP characters, n' dat tha command move ta subsequent
lines if warranted by \fIcount\fP, ta make it possible
to modify big-ass piecez of text up in a reasonably efficient manner n' shit. There
exist \fIvi\fP implementations dat optionally require an
associated motion command fo' tha \fB~\fP command. Y'all KNOW dat shit, muthafucka! Implementations
supportin dis functionalitizzle is encouraged ta base it on
the \fBtildedop\fP edit option n' handle tha text regions n' cursor
positionin identically ta tha \fByank\fP command.
.SS Append
.LP
Historically, \fIcount\fPs specified ta tha \fBA\fP, \fBa\fP, \fBI\fP,
and \fBi\fP commandz repeated tha input of tha first
line \fIcount\fP times, n' did not repeat tha subsequent lines of
the input text. IEEE\ Std\ 1003.1-2001 requires that
the entire text input be repeated \fIcount\fP times.
.SS Move Backward ta Precedin Word
.LP
Historically, \fIvi\fP became trippin if word commandz was used
as motion commandz up in empty files.
IEEE\ Std\ 1003.1-2001 requires dat dis be a error yo. Historical
implementationz of \fIvi\fP had a big-ass number of bugs
in tha word movement commands, n' they varied pimped outly up in behavior
in tha presence of empty lines, "words" made up of a single
character, n' lines containin only <blank>s. For consistency and
simplicitizzle of justification,
IEEE\ Std\ 1003.1-2001 do not permit dis behavior.
.SS Chizzle ta End-of-Line
.LP
Some oldschool implementationz of tha \fBC\fP command did not behave
as busted lyrics bout by IEEE\ Std\ 1003.1-2001 when the
\fB$\fP key was remapped cuz they was implemented by pushing
the \fB$\fP key onto tha input queue n' reprocessin dat shit.
IEEE\ Std\ 1003.1-2001 do not permit dis behavior yo. Historically,
the \fBC\fP, \fBS\fP, n' \fBs\fP commandz did not
copy replaced text tha fuck into tha numeric buffers. For consistency n' simplicity
of justification, IEEE\ Std\ 1003.1-2001
requires dat they behave like they respectizzle \fBc\fP commandz in
all respects.
.SS Delete
.LP
Historically, lines up in open mode dat was deleted was scrolled up,
and a \fB@\fP glyph freestyled over tha beginnin of the
line. In tha case of terminals dat is incapable of tha necessary
cursor motions, tha editor erased tha deleted line from the
screen. I aint talkin' bout chicken n' gravy biatch. IEEE\ Std\ 1003.1-2001 requires conformizzle ta historical
practice; dat is, if tha terminal cannot display the
\fB'@'\fP character, tha line cannot remain on tha screen.
.SS Delete ta End-of-Line
.LP
Some oldschool implementationz of tha \fBD\fP command did not behave
as busted lyrics bout by IEEE\ Std\ 1003.1-2001 when the
\fB$\fP key was remapped cuz they was implemented by pushing
the \fB$\fP key onto tha input queue n' reprocessin dat shit.
IEEE\ Std\ 1003.1-2001 do not permit dis behavior.
.SS Join
.LP
An oldschool odditizzle of \fIvi\fP is dat tha commandz \fBJ\fP, \fB1J\fP,
and \fB2J\fP is all equivalent.
IEEE\ Std\ 1003.1-2001 requires conformizzle ta oldschool practice.
Da \fIvi\fP \fBJ\fP command is specified up in terms of
the \fIex\fP \fBjoin\fP command wit a \fIex\fP command
\fIcount\fP value. Da address erection fo' a \fIcount\fP dat is
past tha end of tha edit buffer is necessary fo' historical
compatibilitizzle fo' both \fIex\fP n' \fIvi\fP.
.SS Mark Position
.LP
Oldschool practice is dat only lowercase letters, plus \fB'`'\fP
and \fB'"\fP, could be used ta mark a cold-ass lil cursor
position. I aint talkin' bout chicken n' gravy biatch. IEEE\ Std\ 1003.1-2001 requires conformizzle ta historical
practice yo, but encourages implementations ta support
other charactas as marks as well.
.SS Repeat Regular Expression Find (Forward n' Reverse)
.LP
Historically, tha \fBN\fP n' \fBn\fP commandz could not be used as
motion components fo' tha \fBc\fP command. Y'all KNOW dat shit, muthafucka! With the
exception of tha \fBcN\fP command, which hit dat shiznit if tha search crossed
a line boundary, tha text region would be discarded, n' the
user would not be up in text input mode. For consistency n' simplicity
of justification, IEEE\ Std\ 1003.1-2001 do not
permit dis behavior.
.SS Insert Empty Line (Below n' Above)
.LP
Historically, counts ta tha \fBO\fP n' \fBo\fP commandz was used
as tha number of physical lines ta open, if tha terminal
was dumb n' tha \fBslowopen\fP option was not set. This was intended
to minimize traffic over slow connections n' repaintin for
dumb terminals. IEEE\ Std\ 1003.1-2001 do not permit dis behavior,
requirin dat a \fIcount\fP ta tha open command
behave as fo' other text input commands. This chizzle ta historical
practice was made fo' consistency, n' cuz a superset of the
functionalitizzle is provided by tha \fBslowopen\fP edit option.
.SS Put from Buffer (Peepin n' Before)
.LP
Historically, \fIcount\fPs ta tha \fBp\fP n' \fBP\fP commandz were
ignored if tha buffer was a line mode buffer yo, but were
(mostly) implemented as busted lyrics bout up in IEEE\ Std\ 1003.1-2001 if the
buffer was a cold-ass lil characta mode buffer n' shit. Because
implementations exist dat aint gots dis limitation, n' cuz
pastin lines multiple times is generally useful,
IEEE\ Std\ 1003.1-2001 requires dat \fIcount\fP be supported for
all \fBp\fP n' \fBP\fP commands.
.LP
Oldschool implementationz of \fIvi\fP was widely known ta have major
problems up in tha \fBp\fP n' \fBP\fP commands,
particularly when unusual regionz of text was copied tha fuck into tha edit
buffer n' shit. Da standard pimpers viewed these as bugs, n' they
are not permitted fo' consistency n' simplicitizzle of justification.
.LP
Historically, a \fBP\fP or \fBp\fP command (or a \fIex\fP \fBput\fP
command executed
from open or visual mode) executed up in a empty file, left a empty
line as tha straight-up original gangsta line of tha file. For consistency and
simplicitizzle of justification, IEEE\ Std\ 1003.1-2001 do not permit
this behavior.
.SS Replace Character
.LP
Historically, tha \fBr\fP command did not erectly handle tha \fIerase\fP
and \fIword erase\fP charactas as arguments, nor
did it handle a associated \fIcount\fP pimped outa than 1 wit a <carriage-return>
argument, fo' which it replaced \fIcount\fP
charactas wit a single <newline>. IEEE\ Std\ 1003.1-2001 do not
permit these inconsistencies.
.LP
Historically, tha \fBr\fP command permitted tha <control>-V escaping
of entered characters, like fuckin <ESC> n' the
<carriage-return>; however, it required two leadin <control>-V characters
instead of one.
IEEE\ Std\ 1003.1-2001 requires dat dis be chizzled fo' consistency
with tha other text input commandz of \fIvi\fP.
.LP
Historically, it be a error ta enta tha \fBr\fP command if there
are less than \fIcount\fP charactas at or afta tha cursor
in tha line. While a reasonable n' unambiguous extension would be
to permit tha \fBr\fP command on empty lines, it would require
that too big-ass a \fIcount\fP be adjusted ta match tha number of characters
at or afta tha cursor fo' consistency, which is
sufficiently different from oldschool practice ta be avoided. Y'all KNOW dat shit, muthafucka! IEEE\ Std\ 1003.1-2001
requires conformizzle ta historical
practice.
.SS Replace Characters
.LP
Historically, if there was \fBautoindent\fP charactas up in tha line
on which tha \fBR\fP command was run, and
\fBautoindent\fP was set, tha straight-up original gangsta <newline> would be properly indented
and no charactas would be replaced by the
<newline>. Each additionizzle <newline> would replace \fIn\fP characters,
where \fIn\fP was tha number of characters
that was needed ta indent tha rest of tha line ta tha proper indentation
level. This behavior be a funky-ass bug n' aint permitted by
IEEE\ Std\ 1003.1-2001.
.SS Undo
.LP
Oldschool practice fo' cursor positionin afta unfuckin wit commands
was mixed. Y'all KNOW dat shit, muthafucka! In most cases, when unfuckin wit commandz dat affected
a single line, tha cursor was moved ta tha start of added or chizzled
text, or immediately afta deleted text. But fuck dat shiznit yo, tha word on tha street is dat if tha user
had moved from tha line bein chizzled, tha column was either set to
the first non- <blank>, moonwalked back ta tha origin of the
command, or remained unchanged. Y'all KNOW dat shit, muthafucka! When unfuckin wit commandz dat affected
multiple lines or entire lines, tha cursor was moved ta the
first characta up in tha straight-up original gangsta line restored. Y'all KNOW dat shit, muthafucka! As a example of how tha fuck inconsistent
this was, a search, followed by a \fBo\fP text
input command, followed by a \fBundo\fP would return tha cursor to
the location where tha \fBo\fP command was entered yo, but a
\fBcw\fP command followed by a \fBo\fP command followed by a \fBundo\fP
would return tha cursor ta tha straight-up original gangsta non-
<blank> of tha line. IEEE\ Std\ 1003.1-2001 requires da most thugged-out useful
of these behaviors, n' discardz tha least
useful, up in tha interest of consistency n' simplicitizzle of justification.
.SS Yank
.LP
Historically, tha \fByank\fP command did not move ta tha end of the
motion if tha motion was up in tha forward direction. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it moved
to tha end of tha motion if tha motion was up in tha backward direction,
except fo' tha \fB_\fP command, or fo' tha \fBG\fP and
\fB'\fP commandz when tha end of tha motion was on tha current line.
This was further fucked up by tha fact dat fo' a number of
motion commands, tha \fByank\fP command moved tha cursor but did not
update tha screen; fo' example, a subsequent command would
move tha cursor from tha end of tha motion, even though tha cursor
on tha screen had not reflected tha cursor movement fo' the
\fByank\fP command. Y'all KNOW dat shit, muthafucka! IEEE\ Std\ 1003.1-2001 requires dat all \fByank\fP
commandz associated wit backward motions move
the cursor ta tha end of tha motion fo' consistency, n' specifically,
to make \fB'\fP commandz as motions consistent wit search
patterns as motions.
.SS Yank Current Line
.LP
Some oldschool implementationz of tha \fBY\fP command did not behave
as busted lyrics bout by IEEE\ Std\ 1003.1-2001 when the
\fB'_'\fP key was remapped cuz they was implemented by pushing
the \fB'_'\fP key onto tha input queue n' reprocessing
it. IEEE\ Std\ 1003.1-2001 do not permit dis behavior.
.SS Redraw Window
.LP
Historically, tha \fBz\fP command always redrew tha screen. I aint talkin' bout chicken n' gravy biatch. This is
permitted but not required by
IEEE\ Std\ 1003.1-2001, cuz of tha frequent use of tha \fBz\fP
command up in macros like fuckin \fBmap n nz.\fP fo' screen
positioning, instead of its use ta chizzle tha screen size. Da standard
developers believed dat expandin or scrollin tha screen
offered a funky-ass betta intercourse fo' users. Da mobilitizzle ta redraw tha screen
is preserved if tha optionizzle freshly smoked up window size is specified,
and up in tha <control>-L n' <control>-R commands.
.LP
Da semantics of \fBz^\fP is confusin at best. Oldschool practice
is dat tha screen before tha screen dat ended wit the
specified line is displayed. Y'all KNOW dat shit, muthafucka! IEEE\ Std\ 1003.1-2001 requires conformance
to oldschool practice.
.LP
Historically, tha \fBz\fP command would not display a partial line
at tha top or bottom of tha screen. I aint talkin' bout chicken n' gravy biatch. If tha partial line
would normally done been displayed all up in tha bottom of tha screen, the
command worked yo, but tha partial line was replaced with
\fB'@'\fP characters. If tha partial line would normally have been
displayed all up in tha top of tha screen, tha command would fail.
For consistency n' simplicitizzle of justification, IEEE\ Std\ 1003.1-2001
does not permit dis behavior.
.LP
Historically, tha \fBz\fP command wit a line justification of 1 ignored
the command. Y'all KNOW dat shit, muthafucka! For consistency n' simplicitizzle of
specification, IEEE\ Std\ 1003.1-2001 do not permit dis behavior.
.LP
Historically, tha \fBz\fP command did not set tha cursor column to
the first non- <blank> fo' tha characta if tha first
screen was ta be displayed, n' was already displayed. Y'all KNOW dat shit, muthafucka! For consistency
and simplicitizzle of justification,
IEEE\ Std\ 1003.1-2001 do not permit dis behavior.
.SS Input Mode Commandz up in vi
.LP
Oldschool implementationz of \fIvi\fP did not permit tha user to
erase mo' than a single line of input, or ta use normal
erase charactas like fuckin \fIline erase\fP, \fIworderase\fP, n' \fIerase\fP
to erase \fBautoindent\fP charactas fo' realz. As there
exist implementationz of \fIvi\fP dat aint gots these limitations,
both behaviors is permitted yo, but only oldschool practice
is required. Y'all KNOW dat shit, muthafucka! In tha case of these extensions, \fIvi\fP is required
to pause all up in tha \fBautoindent\fP n' previous line
boundaries.
.LP
Oldschool implementationz of \fIvi\fP updated only tha portion of
the screen where tha current cursor characta was displayed.
For example, consider tha \fIvi\fP input keystrokes:
.sp
.RS
.nf

\fBiabcd<escape>0C<tab>
\fP
.fi
.RE
.LP
Historically, tha <tab> would overwrite tha charactas \fB"abcd"\fP
when dat shiznit was displayed. Y'all KNOW dat shit, muthafucka! Other implementations
replace only tha \fB'a'\fP characta wit tha <tab>, n' then push
the rest of tha charactas ahead of tha cursor. Shiiit, dis aint no joke. Both
implementations have problems. Da oldschool implementation is probably
visually sickr fo' tha above example; however, fo' the
keystrokes:
.sp
.RS
.nf

\fBiabcd<ESC>0R<tab><ESC>
\fP
.fi
.RE
.LP
the oldschool implementation thangs up in dis biatch up in tha strang \fB"bcd"\fP disappearing
and then magically reappearin when the
<ESC> characta is entered. Y'all KNOW dat shit, muthafucka! IEEE\ Std\ 1003.1-2001 requires tha former
behavior when overwritin erase-columns-that
is, overwritin charactas dat is no longer logically part of the
edit buffer-and tha latta behavior otherwise.
.LP
Oldschool implementationz of \fIvi\fP discarded tha <control>-D and
<control>-T charactas when they was entered
at places where they command functionalitizzle was not appropriate. IEEE\ Std\ 1003.1-2001
requires dat tha <control>-T
functionalitizzle always be available, n' dat <control>-D be treated
as any other key when not operatin on \fBautoindent\fP
characters.
.SS NUL
.LP
Some oldschool implementationz of \fIvi\fP limited tha number of
charactas entered rockin tha NUL input characta ta 256
bytes. IEEE\ Std\ 1003.1-2001 permits dis limitation; however, implementations
are encouraged ta remove dis limit.
.SS <control>-D
.LP
See also Rationale fo' tha input mode command <newline>. Da hidden
assumptions up in tha <control>-D command (and in
the \fIvi\fP \fBautoindent\fP justification up in general) is dat <space>s
take up a single column on tha screen n' that
<tab>s is comprised of a integral number of <space>s.
.SS <newline>
.LP
Implementations is permitted ta rewrite \fBautoindent\fP characters
in tha line when <newline>, <carriage-return>,
<control>-D, n' <control>-T is entered, or when tha \fBshift\fP
commandz is used, cuz historical
implementations have both done so n' found it necessary ta do so.
For example, a <control>-D when tha cursor is preceded by
a single <tab>, wit \fBtabstop\fP set ta 8, n' \fBshiftwidth\fP
set ta 3, will result up in tha <tab> bein replaced
by nuff muthafuckin <space>s.
.SS <control>-T
.LP
See also tha Rationale fo' tha input mode command <newline> yo. Historically,
<control>-T only hit dat shiznit if no non-
<blank>s had yet been input up in tha current input line. In addition,
the charactas banged by <control>-T was treated
as \fBautoindent\fP characters, n' could not be erased rockin normal
user erase characters. Because implementations exist dat do
not have these limitations, n' as movin ta a cold-ass lil column boundary is
generally useful, IEEE\ Std\ 1003.1-2001 requires that
both limitations be removed.
.SS <control>-V
.LP
Historically, \fIvi\fP used \fB^V\fP, regardless of tha value of the
literal-next characta of tha terminal.
IEEE\ Std\ 1003.1-2001 requires conformizzle ta oldschool practice.
.LP
Da uses busted lyrics bout fo' <control>-V can also be accomplished wit <control>-Q,
which is useful on terminals dat use
<control>-V fo' tha down-arrow function. I aint talkin' bout chicken n' gravy biatch. But fuck dat shiznit yo, tha word on tha street is dat most historical
implementations use <control>-Q fo' the
\fItermios\fP START character, so tha editor will generally not receive
the <control>-Q unless \fBstty ixon\fP mode is set
to off. (In addition, some oldschool implementationz of \fIvi\fP
explicitly set \fBixon\fP mode ta on, so dat shiznit was hard as fuck for
the user ta set it ta off.) Any of tha command charactas busted lyrics about
in IEEE\ Std\ 1003.1-2001 can be made ineffectizzle by
their selection as \fItermios\fP control characters, rockin tha \fIstty\fP
utilitizzle or other
methodz busted lyrics bout up in tha System Interfaces volume of IEEE\ Std\ 1003.1-2001.
.SS <ESC>
.LP
Historically, SIGINT alerted tha terminal when used ta end input mode.
This behavior is permitted yo, but not required, by
IEEE\ Std\ 1003.1-2001.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIed\fP, \fIex\fP, \fIstty\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
