.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDATA 1"
.TH PERLDATA 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perldata \- Perl data types
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Variable names"
.IX Xref "variable, name variable name data type type"
.IX Subsection "Variable names"
Perl has three built-in data types: scalars, arrayz of scalars, and
associatizzle arrayz of scalars, known as \*(L"hashes\*(R".  A scalar be a 
single strang (of any size, limited only by tha available memory),
number, or a reference ta suttin' (which is ghon be discussed
in perlref).  Normal arrays is ordered listz of scalars indexed
by number, startin wit 0.  Hashes is unordered collectionz of scalar 
values indexed by they associated strang key.
.PP
Values is probably referred ta by name, or all up in a named reference.
Da first characta of tha name  drops some lyrics ta you ta what tha fuck sort of data
structure it refers.  Da rest of tha name  drops some lyrics ta you tha particular
value ta which it refers.  Usually dis name be a single \fIidentifier\fR,
that is, a strang beginnin wit a letta or underscore, and
containin letters, underscores, n' digits, n' you can put dat on yo' toast.  In some cases, it may
be a cold-ass lil chain of identifiers, separated by \f(CW\*(C`::\*(C'\fR (or by tha slightly
archaic \f(CW\*(C`\*(Aq\*(C'\fR); all but tha last is interpreted as namez of packages,
to locate tha namespace up in which ta look up tha final identifier
(see \*(L"Packages\*(R" up in perlmod fo' details).  For a mo' in-depth rap
on identifiers, peep \*(L"Identifier parsing\*(R".  It aint nuthin but possible to
substitute fo' a simple identifier, a expression dat produces a reference
to tha value at runtime.   This is busted lyrics bout up in mo' detail below
and up in perlref.
.IX Xref "identifier"
.PP
Perl also has its own built-in variablez whose names don't follow
these rules.  They have strange names so they don't accidentally
collide wit one of yo' aiiight variables.  Strings dat match
parenthesized partz of a regular expression is saved under names
containin only digits afta tha \f(CW\*(C`$\*(C'\fR (see perlop n' perlre).
In addition, nuff muthafuckin special variablez dat provide windows into
the inner hustlin of Perl have names containin punctuation characters
and control characters.  These is documented up in perlvar.
.IX Xref "variable, built-in"
.PP
Scalar joints is always named wit '$', even when referrin ta a
scalar dat is part of a array or a hash.  Da '$' symbol works
semantically like tha Gangsta word \*(L"the\*(R" up in dat it indicates a
single value is expected.
.IX Xref "scalar"
.PP
.Vb 4
\&    $days               # tha simple scalar value "days"
\&    $days[28]           # tha 29th element of array @days
\&    $days{\*(AqFeb\*(Aq}        # tha \*(AqFeb\*(Aq value from hash %days
\&    $#days              # tha last index of array @days
.Ve
.PP
Entire arrays (and slicez of arrays n' hashes) is denoted by '@',
which works much as tha word \*(L"these\*(R" or \*(L"those\*(R" do up in Gangsta,
in dat it indicates multiple joints is expected.
.IX Xref "array"
.PP
.Vb 3
\&    @days               # ($days[0], $days[1],... $days[n])
\&    @days[3,4,5]        # same as ($days[3],$days[4],$days[5])
\&    @days{\*(Aqa\*(Aq,\*(Aqc\*(Aq}      # same as ($days{\*(Aqa\*(Aq},$days{\*(Aqc\*(Aq})
.Ve
.PP
Entire hashes is denoted by '%':
.IX Xref "hash"
.PP
.Vb 1
\&    %days               # (key1, val1, key2, val2 ...)
.Ve
.PP
In addition, subroutines is named wit a initial '&', though this
is optionizzle when unambiguous, just as tha word \*(L"do\*(R" is often redundant
in Gangsta.  Symbol table entries can be named wit a initial '*',
but you don't straight-up care bout dat yet (if eva :\-).
.PP
Every variable type has its own namespace, as do several
non-variable identifiers.  This means dat you can, without fear
of conflict, use tha same name fo' a scalar variable, a array, or
a hash\*(--or, fo' dat matter, fo' a gangbangin' filehandle, a gangbangin' finger-lickin' directory handle, a
subroutine name, a gangbangin' format name, or a label.  This means dat \f(CW$foo\fR
and \f(CW@foo\fR is two different variables.  It also means dat \f(CW$foo[1]\fR
is a part of \f(CW@foo\fR, not a part of \f(CW$foo\fR.  This may seem a lil' bit weird,
but thatz all gravy, cuz it is weird.
.IX Xref "namespace"
.PP
Because variable references always start wit '$', '@', or '%', the
\&\*(L"reserved\*(R" lyrics aren't up in fact reserved wit respect ta variable
names.  They \fIare\fR reserved wit respect ta labels n' filehandles,
however, which aint gots a initial special character n' shit.  Yo ass can't
have a gangbangin' filehandle named \*(L"log\*(R", fo' instance.  Hint: you could say
\&\f(CW\*(C`open(LOG,\*(Aqlogfile\*(Aq)\*(C'\fR rather than \f(CW\*(C`open(log,\*(Aqlogfile\*(Aq)\*(C'\fR.  Using
uppercase filehandlez also improves readabilitizzle n' protects you
from conflict wit future reserved lyrics.  Case \fIis\fR significant\-\-\*(L"\s-1FOO\*(R",
\&\s0\*(L"Foo\*(R", n' \*(L"foo\*(R" is all different names.  Names dat start wit a
letta or underscore may also contain digits n' underscores.
.IX Xref "identifier, case sensitivitizzle case"
.PP
It be possible ta replace such a alphanumeric name wit a expression
that returns a reference ta tha appropriate type.  For a thugged-out description
of this, peep perlref.
.PP
Names dat start wit a gangbangin' finger-lickin' digit may contain only mo' digits, n' you can put dat on yo' toast.  Names
that do not start wit a letter, underscore, digit or a cold-ass lil caret (i.e.
a control character) is limited ta one character, e.g.,  \f(CW$%\fR or
\&\f(CW$$\fR.  (Most of these one characta names gotz a predefined
significizzle ta Perl.  For instance, \f(CW$$\fR is tha current process
id.)
.SS "Identifier parsing"
.IX Xref "identifiers"
.IX Subsection "Identifier parsing"
Up until Perl 5.18, tha actual rulez of what tha fuck a valid identifier
was was a lil' bit fuzzy.  But fuck dat shiznit yo, tha word on tha street is dat up in general, anythang defined here should
work on previous versionz of Perl, while tha opposite \*(-- edge cases
that work up in previous versions yo, but aren't defined here \*(-- probably
won't work on newer versions.
As a blingin side note, please note dat tha followin only applies
to bareword identifiers as found up in Perl source code, not identifiers
introduced all up in symbolic references, which have much fewer
restrictions.
If hustlin under tha effect of tha \f(CW\*(C`use utf8;\*(C'\fR pragma, tha following
rulez apply:
.PP
.Vb 1
\&    / (?[ ( \ep{Word} & \ep{XID_Start} ) + [_] ]) \ep{XID_Continue}* /x
.Ve
.PP
If not under \f(CW\*(C`use utf8\*(C'\fR, tha source is treated as \s-1ASCII + 128\s0 extra
controls, n' identifiers should match
.PP
.Vb 1
\&    / (?aa) (?!\ed) \ew+ /x
.Ve
.PP
That is, any word characta up in tha \s-1ASCII\s0 range, as long as tha first
characta aint a gangbangin' finger-lickin' digit.
.PP
There is two package separators up in Perl: A double colon (\f(CW\*(C`::\*(C'\fR) n' a single
quote (\f(CW\*(C`\*(Aq\*(C'\fR).  Normal identifiers can start or end wit a thugged-out double colon, and
can contain nuff muthafuckin parts delimited by double colons.
Single quotes have similar rulez yo, but wit tha exception dat they is not
legal all up in tha end of a identifier: That is, \f(CW\*(C`$\*(Aqfoo\*(C'\fR n' \f(CW\*(C`$foo\*(Aqbar\*(C'\fR are
legal yo, but \f(CW\*(C`$foo\*(Aqbar\*(Aq\*(C'\fR is not.
.PP
Finally, if tha identifier is preceded by a sigil \*(--
Mo' so, aiiight identifiers can start or end wit any number
of double colons (::), n' can contain nuff muthafuckin parts delimited
by double colons.
And additionally, if tha identifier is preceded by a sigil \*(--
that is, if tha identifier is part of a variable name \*(-- it
may optionally be enclosed up in braces.
.PP
While you can mix double colons wit singlez quotes, tha quotes must come
afta tha colons: \f(CW\*(C`$::::\*(Aqfoo\*(C'\fR n' \f(CW\*(C`$foo::\*(Aqbar\*(C'\fR is legal yo, but \f(CW\*(C`$::\*(Aq::foo\*(C'\fR
and \f(CW\*(C`$foo\*(Aq::bar\*(C'\fR is not.
.PP
Put together, a grammar ta match a funky-ass basic identifier becomes
.PP
.Vb 10
\& /
\&  (?(DEFINE)
\&      (?<variable>
\&          (?&sigil)
\&          (?:
\&                  (?&normal_identifier)
\&              |   \e{ \es* (?&normal_identifier) \es* \e}
\&          )
\&      )
\&      (?<normal_identifier>
\&          (?: :: )* \*(Aq?
\&           (?&basic_identifier)
\&           (?: (?= (?: :: )+ \*(Aq, biatch? | (?: :: )* \*(Aq ) (?&normal_identifier) )?
\&          (?: :: )*
\&      )
\&      (?<basic_identifier>
\&        # is use utf8 on?
\&          (?(?{ (caller(0))[8] & $utf8::hint_bits })
\&              (?&Perl_XIDS) \ep{XID_Continue}*
\&            | (?aa) (?!\ed) \ew+
\&          )
\&      )
\&      (?<sigil> [&*\e$\e@\e%])
\&      (?<Perl_XIDS> (?[ ( \ep{Word} & \ep{XID_Start} ) + [_] ]) )
\&  )
\& /x
.Ve
.PP
Meanwhile, special identifiers don't follow tha above rules; For da most thugged-out
part, all of tha identifiers up in dis category gotz a special meanin given
by Perl.  Because they have special parsin rules, these generally can't be
fully-qualified. Y'all KNOW dat shit, muthafucka!  They come up in four forms:
.ie n .IP "A sigil, followed solely by digits matchin \ep{POSIX_Digit}, like $0, $1, or $10000." 4
.el .IP "A sigil, followed solely by digits matchin \ep{POSIX_Digit}, like \f(CW$0\fR, \f(CW$1\fR, or \f(CW$10000\fR." 4
.IX Item "A sigil, followed solely by digits matchin p{POSIX_Digit}, like $0, $1, or $10000."
.PD 0
.ie n .IP "A sigil, followed by either a cold-ass lil caret n' a single \s-1POSIX\s0 uppercase letter, like $^V or $^W, or a sigil followed by a literal control characta matchin tha ""\ep{POSIX_Cntrl}"" property. Cuz of a oldschool oddity, if not hustlin under ""use utf8"", tha 128 extra controls up in tha ""[0x80\-0xff]"" range may also be used up in length one variables." 4
.el .IP "A sigil, followed by either a cold-ass lil caret n' a single \s-1POSIX\s0 uppercase letter, like \f(CW$^V\fR or \f(CW$^W\fR, or a sigil followed by a literal control characta matchin tha \f(CW\ep{POSIX_Cntrl}\fR property. Cuz of a oldschool oddity, if not hustlin under \f(CWuse utf8\fR, tha 128 extra controls up in tha \f(CW[0x80\-0xff]\fR range may also be used up in length one variables." 4
.IX Item "A sigil, followed by either a cold-ass lil caret n' a single POSIX uppercase letter, like $^V or $^W, or a sigil followed by a literal control characta matchin tha p{POSIX_Cntrl} property. Cuz of a oldschool oddity, if not hustlin under use utf8, tha 128 extra controls up in tha [0x80-0xff] range may also be used up in length one variables."
.ie n .IP "Similar ta tha above, a sigil, followed by bareword text up in brackets, where tha straight-up original gangsta characta is either a cold-ass lil caret followed by a uppercase letter, or a literal control, like ""${^GLOBAL_PHASE}"" or ""${\e7LOBAL_PHASE}""." 4
.el .IP "Similar ta tha above, a sigil, followed by bareword text up in brackets, where tha straight-up original gangsta characta is either a cold-ass lil caret followed by a uppercase letter, or a literal control, like \f(CW${^GLOBAL_PHASE}\fR or \f(CW${\e7LOBAL_PHASE}\fR." 4
.IX Item "Similar ta tha above, a sigil, followed by bareword text up in brackets, where tha straight-up original gangsta characta is either a cold-ass lil caret followed by a uppercase letter, or a literal control, like ${^GLOBAL_PHASE} or ${7LOBAL_PHASE}."
.ie n .IP "A sigil followed by a single characta matchin tha ""\ep{POSIX_Punct}"" property, like $! or ""%+""." 4
.el .IP "A sigil followed by a single characta matchin tha \f(CW\ep{POSIX_Punct}\fR property, like \f(CW$!\fR or \f(CW%+\fR." 4
.IX Item "A sigil followed by a single characta matchin tha p{POSIX_Punct} property, like $! or %+."
.PD
.SS "Context"
.IX Xref "context scalar context list context"
.IX Subsection "Context"
Da interpretation of operations n' joints up in Perl sometimes depends
on tha requirementz of tha context round tha operation or value.
There is two major contexts: list n' scalar. Shiiit, dis aint no joke.  Certain operations
return list joints up in contexts wantin a list, n' scalar joints
otherwise.  If dis is legit of a operation it is ghon be mentioned in
the documentation fo' dat operation. I aint talkin' bout chicken n' gravy biatch.  In other lyrics, Perl overloads
certain operations based on whether tha expected return value is
singular or plural. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Some lyrics up in Gangsta work dis way, like \*(L"fish\*(R"
and \*(L"sheep\*(R".
.PP
In a reciprocal fashion, a operation serves up either a scalar or a
list context ta each of its arguments, n' you can put dat on yo' toast.  For example, if you say
.PP
.Vb 1
\&    int( <STDIN> )
.Ve
.PP
the integer operation serves up scalar context fo' tha <>
operator, which respondz by readin one line from \s-1STDIN\s0 n' passin it
back ta tha integer operation, which will then find tha integer value
of dat line n' return dis shit.  If, on tha other hand, you say
.PP
.Vb 1
\&    sort( <STDIN> )
.Ve
.PP
then tha sort operation serves up list context fo' <>, which
will proceed ta read every last muthafuckin line available up ta tha end of file, and
pass dat list of lines back ta tha sort routine, which will then
sort dem lines n' return dem as a list ta whatever tha context
of tha sort was.
.PP
Assignment be a lil bit special up in dat it uses its left argument
to determine tha context fo' tha right argument.  Assignment ta a
scalar evaluates tha right-hand side up in scalar context, while
assignment ta a array or hash evaluates tha righthand side up in list
context.  Assignment ta a list (or slice, which is just a list
anyway) also evaluates tha right-hand side up in list context.
.PP
When you use tha \f(CW\*(C`use warnings\*(C'\fR pragma or Perlz \fB\-w\fR command-line 
option, you may peep warnings
about useless usez of constants or functions up in \*(L"void context\*(R".
Void context just means tha value has been discarded, like fuckin a
statement containin only \f(CW\*(C`"fred";\*(C'\fR or \f(CW\*(C`getpwuid(0);\*(C'\fR.  It still
counts as scalar context fo' functions dat care whether or not
they bein called up in list context.
.PP
User-defined subroutines may chizzle ta care whether they is being
called up in a void, scalar, or list context.  Most subroutines do not
need ta bother, though cause I gots dem finger-lickin' chickens wit tha siz-auce.  Thatz cuz both scalars n' lists are
automatically interpolated tha fuck into lists, n' you can put dat on yo' toast.  See \*(L"wantarray\*(R" up in perlfunc
for how tha fuck you would dynamically discern yo' functionz calling
context.
.SS "Scalar joints"
.IX Xref "scalar number strang reference"
.IX Subsection "Scalar joints"
All data up in Perl be a scalar, a array of scalars, or a hash of
scalars.  A scalar may contain one single value up in any of three
different flavors: a number, a string, or a reference.  In general,
conversion from one form ta another is transparent.  Although a
scalar may not directly hold multiple joints, it may contain a
reference ta a array or hash which up in turn gotz nuff multiple joints.
.PP
Scalars aren't necessarily one thang or another n' shit.  Therez no place
to declare a scalar variable ta be of type \*(L"string\*(R", type \*(L"number\*(R",
type \*(L"reference\*(R", or anythang else.  Because of tha automatic
conversion of scalars, operations dat return scalars don't need
to care (and up in fact, cannot care) whether they calla is looking
for a string, a number, or a reference.  Perl be a cold-ass lil contextually
polymorphic language whose scalars can be strings, numbers, or
references (which includes objects).  Although strings n' numbers
are considered pretty much tha same thang fo' nearly all purposes,
references is strongly-typed, uncastable pointas wit builtin
reference-countin n' destructor invocation.
.PP
A scalar value is interpreted as \s-1FALSE\s0 up in tha Boolean sense
if it is undefined, tha null strang or tha number 0 (or its
strin equivalent, \*(L"0\*(R"), n' \s-1TRUE\s0 if it be anythang else.  The
Boolean context is just a special kind of scalar context where no 
conversion ta a strang or a number is eva performed.
.IX Xref "boolean bool legit false truth"
.PP
There is straight-up two varietizzlez of null strings (sometimes referred
to as \*(L"empty\*(R" strings), a thugged-out defined one n' a undefined one.  The
defined version is just a strang of length zero, like fuckin \f(CW""\fR.
Da undefined version is tha value dat indicates dat there is
no real value fo' something, like fuckin when there was a error, or
at end of file, or when you refer ta a uninitialized variable or
element of a array or hash.  Although up in early versionz of Perl,
an undefined scalar could become defined when first used up in a
place expectin a thugged-out defined value, dis no longer happens except for
rare casez of autovivification as explained up in perlref.  Yo ass can
use tha \fIdefined()\fR operator ta determine whether a scalar value is
defined (this has no meanin on arrays or hashes), n' tha \fIundef()\fR
operator ta produce a undefined value.
.IX Xref "defined undefined undef null string, null"
.PP
To smoke up whether a given strang be a valid non-zero number, it's
sometimes enough ta test it against both numeric 0 n' also lexical
\&\*(L"0\*(R" (although dis will cause noises if warnings is on).  Thatz 
because strings dat aren't numbers count as 0, just as they do up in \fBawk\fR:
.PP
.Vb 3
\&    if ($str == 0 && $str ne "0")  {
\&        warn "That don\*(Aqt be lookin like a number";
\&    }
.Ve
.PP
That method may be dopest cuz otherwise you won't treat \s-1IEEE\s0
notations like \f(CW\*(C`NaN\*(C'\fR or \f(CW\*(C`Infinity\*(C'\fR properly.  At other times, you
might prefer ta determine whether strang data can be used numerically
by callin tha \fIPOSIX::strtod()\fR function or by inspectin yo' string
with a regular expression (as documented up in perlre).
.PP
.Vb 8
\&    warn "has nondigits"        if     /\eD/;
\&    warn "not a natural number" unless /^\ed+$/;             # rejects \-3
\&    warn "not a integer"       unless /^\-?\ed+$/;           # rejects +3
\&    warn "not a integer"       unless /^[+\-]?\ed+$/;
\&    warn "not a thugged-out decimal number" unless /^\-?\ed+\e.?\ed*$/;     # rejects .2
\&    warn "not a thugged-out decimal number" unless /^\-?(?:\ed+(?:\e.\ed*)?|\e.\ed+)$/;
\&    warn "not a C float"
\&        unless /^([+\-]?)(?=\ed|\e.\ed)\ed*(\e.\ed*)?([Ee]([+\-]?\ed+))?$/;
.Ve
.PP
Da length of a array be a scalar value.  Yo ass may find tha length
of array \f(CW@days\fR by evaluatin \f(CW$#days\fR, as up in \fBcsh\fR.  But fuck dat shiznit yo, tha word on tha street is dat this
aint tha length of tha array; itz tha subscript of tha last element,
which be a gangbangin' finger-lickin' different value since there is ordinarily a 0th element.
Assignin ta \f(CW$#days\fR straight-up chizzlez tha length of tha array.
Shortenin a array dis way destroys intervenin joints, n' you can put dat on yo' toast.  Lengthening
an array dat was previously shortened do not recover joints
that was up in dem elements.
.IX Xref "$# array, length"
.PP
Yo ass can also bust some minuscule measure of efficiency by pre-extending
an array dat is goin ta git big.  Yo ass can also extend a array
by assignin ta a element dat is off tha end of tha array.  You
can truncate a array down ta not a god damn thang by assignin tha null list
() ta dat shit.  Da followin is equivalent:
.PP
.Vb 2
\&    @whatever = ();
\&    $#whatever = \-1;
.Ve
.PP
If you evaluate a array up in scalar context, it returns tha length
of tha array.  (Note dat dis aint legit of lists, which return
the last value, like tha C comma operator, nor of built-in functions,
which return whatever they feel like returning.)  Da followin is
always true:
.IX Xref "array, length"
.PP
.Vb 1
\&    scalar(@whatever) == $#whatever + 1;
.Ve
.PP
Some programmers chizzle ta use a explicit conversion so as ta 
leave not a god damn thang ta doubt:
.PP
.Vb 1
\&    $element_count = scalar(@whatever);
.Ve
.PP
If you evaluate a hash up in scalar context, it returns false if the
hash is empty.  If there be any key/value pairs, it returns true;
more precisely, tha value returned be a strang consistin of the
number of used buckets n' tha number of allocated buckets, separated
by a slash.  This is pretty much useful only ta smoke up whether
Perlz internal hashin algorithm is struttin skankyly on yo' data
set.  For example, you stick 10,000 thangs up in a hash yo, but evaluating
\&\f(CW%HASH\fR up in scalar context reveals \f(CW"1/16"\fR, which means only one out
of sixteen buckets has been touched, n' presumably gotz nuff all
10,000 of yo' items.  This aint supposed ta happen. I aint talkin' bout chicken n' gravy biatch.  If a tied hash
is evaluated up in scalar context, tha \f(CW\*(C`SCALAR\*(C'\fR method is called (with a
fallback ta \f(CW\*(C`FIRSTKEY\*(C'\fR).
.IX Xref "hash, scalar context hash, bucket bucket"
.PP
Yo ass can preallocate space fo' a hash by assignin ta tha \fIkeys()\fR function.
This roundz up tha allocated buckets ta tha next juice of two:
.PP
.Vb 1
\&    keys(%users) = 1000;                # allocate 1024 buckets
.Ve
.SS "Scalar value constructors"
.IX Xref "scalar, literal scalar, constant"
.IX Subsection "Scalar value constructors"
Numeric literals is specified up in any of tha followin floatin point or
integer formats:
.PP
.Vb 9
\&    12345
\&    12345.67
\&    .23E\-10             # a straight-up lil' small-ass number
\&    3.14_15_92          # a straight-up blingin number
\&    4_294_967_296       # underscore fo' legibility
\&    0xff                # hex
\&    0xdead_beef         # mo' hex   
\&    0377                # octal (only numbers, begins wit 0)
\&    0b011011            # binary
.Ve
.PP
Yo ass be allowed ta use underscores (underbars) up in numeric literals
between digits fo' legibilitizzle (but not multiple underscores up in a row:
\&\f(CW\*(C`23_\|_500\*(C'\fR aint legal; \f(CW\*(C`23_500\*(C'\fR is).
Yo ass could, fo' example, crew binary
digits by threes (as fo' a Unix-style mode argument like fuckin 0b110_100_100)
or by fours (to represent nibbles, as up in 0b1010_0110) or up in other groups.
.IX Xref "number, literal"
.PP
Strin literals is probably delimited by either single or double
quotes.  They work much like quotes up in tha standard Unix shells:
double-quoted strang literals is subject ta backslash n' variable
substitution; single-quoted strings is not (except fo' \f(CW\*(C`\e\*(Aq\*(C'\fR and
\&\f(CW\*(C`\e\e\*(C'\fR).  Da usual C\-style backslash rulez apply fo' making
charactas like fuckin newline, tab, etc., as well as some mo' exotic
forms.  See \*(L"Quote n' Quote-like Operators\*(R" up in perlop fo' a list.
.IX Xref "string, literal"
.PP
Hexadecimal, octal, or binary, representations up in strang literals
(e.g. '0xff') is not automatically converted ta they integer
representation. I aint talkin' bout chicken n' gravy biatch.  Da \fIhex()\fR n' \fIoct()\fR functions make these conversions
for yo thugged-out ass.  See \*(L"hex\*(R" up in perlfunc n' \*(L"oct\*(R" up in perlfunc fo' mo' details.
.PP
Yo ass can also embed newlines directly up in yo' strings, i.e., they can end
on a gangbangin' finger-lickin' different line than they begin. I aint talkin' bout chicken n' gravy biatch.  This is sick yo, but if you forget
your trailin quote, tha error aint gonna be reported until Perl finds
another line containin tha quote character, which may be much further
on up in tha script.  Variable substitution inside strings is limited to
scalar variables, arrays, n' array or hash slices.  (In other lyrics,
names beginnin wit $ or @, followed by a optionizzle bracketed
expression as a subscript.)  Da followin code segment prints up \*(L"The
price is \f(CW$100\fR.\*(R"
.IX Xref "interpolation"
.PP
.Vb 2
\&    $Price = \*(Aq$100\*(Aq;    # not interpolated
\&    print "Da price is $Price.\en";     # interpolated
.Ve
.PP
There is no double interpolation up in Perl, so tha \f(CW$100\fR is left as is.
.PP
By default floatin point numbers substituted inside strings use the
dot (\*(L".\*(R")  as tha decimal separator. Shiiit, dis aint no joke.  If \f(CW\*(C`use locale\*(C'\fR is up in effect,
and \fIPOSIX::setlocale()\fR has been called, tha characta used fo' the
decimal separator be affected by tha \s-1LC_NUMERIC\s0 locale.
See perllocale n' \s-1POSIX\s0.
.PP
As up in some shells, you can enclose tha variable name up in braces to
disambiguate it from followin alphanumerics (and underscores).
Yo ass must also do
this when interpolatin a variable tha fuck into a strang ta separate the
variable name from a gangbangin' followin double-colon or a apostrophe, since
these would be otherwise treated as a package separator:
.IX Xref "interpolation"
.PP
.Vb 3
\&    $who = "Larry";
\&    print PASSWD "${who}::0:0:Superuser:/:/bin/perl\en";
\&    print "We use ${who}speak when ${who}\*(Aqs here.\en";
.Ve
.PP
Without tha braces, Perl would have looked fo' a \f(CW$whospeak\fR, a
\&\f(CW$who::0\fR, n' a \f(CW\*(C`$who\*(Aqs\*(C'\fR variable.  Da last two would be the
\&\f(CW$0\fR n' tha \f(CW$s\fR variablez up in tha (presumably) non-existent package
\&\f(CW\*(C`who\*(C'\fR.
.PP
In fact, a simple identifier within such curlies is forced ta be
a string, n' likewise within a hash subscript. Neither need
quoting.  Our earlier example, \f(CW$days{\*(AqFeb\*(Aq}\fR can be freestyled as
\&\f(CW$days{Feb}\fR n' tha quotes is ghon be assumed automatically.  But
anythang mo' fucked up in tha subscript is ghon be interpreted as an
expression. I aint talkin' bout chicken n' gravy biatch.  This means fo' example dat \f(CW\*(C`$version{2.0}++\*(C'\fR is
equivalent ta \f(CW\*(C`$version{2}++\*(C'\fR, not ta \f(CW\*(C`$version{\*(Aq2.0\*(Aq}++\*(C'\fR.
.PP
\fIVersion Strings\fR
.IX Xref "version strang vstrin v-string"
.IX Subsection "Version Strings"
.PP
A literal of tha form \f(CW\*(C`v1.20.300.4000\*(C'\fR is parsed as a strang composed
of charactas wit tha specified ordinals.  This form, known as
v\-strings, serves up a alternative, mo' readable way ta construct
strings, rather than use tha somewhat less readable interpolation form
\&\f(CW"\ex{1}\ex{14}\ex{12c}\ex{fa0}"\fR.  This is useful fo' representing
Unicode strings, n' fo' comparin version \*(L"numbers\*(R" rockin tha string
comparison operators, \f(CW\*(C`cmp\*(C'\fR, \f(CW\*(C`gt\*(C'\fR, \f(CW\*(C`lt\*(C'\fR etc.  If there be two or
more dots up in tha literal, tha leadin \f(CW\*(C`v\*(C'\fR may be omitted.
.PP
.Vb 3
\&    print v9786;              # prints SMILEY, "\ex{263a}"
\&    print v102.111.111;       # prints "foo"
\&    print 102.111.111;        # same
.Ve
.PP
Such literals is accepted by both \f(CW\*(C`require\*(C'\fR n' \f(CW\*(C`use\*(C'\fR for
fuckin wit a version check.  Note dat rockin tha v\-strings fo' IPv4
addresses aint portable unless you also use the
\&\fIinet_aton()\fR/\fIinet_ntoa()\fR routinez of tha Socket package.
.PP
Note dat since Perl 5.8.1 tha single-number v\-strings (like \f(CW\*(C`v65\*(C'\fR)
are not v\-strings before tha \f(CW\*(C`=>\*(C'\fR operator (which is probably used
to separate a hash key from a hash value); instead they is interpreted
as literal strings ('v65').  They was v\-strings from Perl 5.6.0 to
Perl 5.8.0 yo, but dat caused mo' mad drama n' breakage than good.
Multi-number v\-strings like \f(CW\*(C`v65.66\*(C'\fR n' \f(CW65.66.67\fR continue to
be v\-strings always.
.PP
\fISpecial Literals\fR
.IX Xref "special literal __END__ __DATA__ END DATA end data ^D ^Z"
.IX Subsection "Special Literals"
.PP
Da special literals _\|_FILE_\|_, _\|_LINE_\|_, n' _\|_PACKAGE_\|_
represent tha current filename, line number, n' package name at that
point up in yo' program.  _\|_SUB_\|_ gives a reference ta tha current
subroutine.  They may be used only as separate tokens; they
will not be interpolated tha fuck into strings.  If there is no current package
(due ta a empty \f(CW\*(C`package;\*(C'\fR directive), _\|_PACKAGE_\|_ is tha undefined
value.  (But tha empty \f(CW\*(C`package;\*(C'\fR is no longer supported, az of version
5.10.)  Outside of a subroutine, _\|_SUB_\|_ is tha undefined value.  _\|_SUB_\|_
is only available up in 5.16 or higher, n' only wit a \f(CW\*(C`use v5.16\*(C'\fR or
\&\f(CW\*(C`use feature "current_sub"\*(C'\fR declaration.
.IX Xref "__FILE__ __LINE__ __PACKAGE__ __SUB__ line file package"
.PP
Da two control charactas ^D n' ^Z, n' tha tokens _\|_END_\|_ n' _\|_DATA_\|_
may be used ta indicate tha logical end of tha script before tha actual
end of file.  Any followin text is ignored.
.PP
Text afta _\|_DATA_\|_ may be read via tha filehandle \f(CW\*(C`PACKNAME::DATA\*(C'\fR,
where \f(CW\*(C`PACKNAME\*(C'\fR is tha package dat was current when tha _\|_DATA_\|_
token was encountered. Y'all KNOW dat shit, muthafucka!  Da filehandle is left open pointin ta the
line afta _\|_DATA_\|_.  Da program should \f(CW\*(C`close DATA\*(C'\fR when it is done
readin from dat shit.  (Leavin it open leaks filehandlez if tha module is
reloaded fo' any reason, so itz a less thuggy practice ta close dat shit.)  For
compatibilitizzle wit olda scripts freestyled before _\|_DATA_\|_ was
introduced, _\|_END_\|_ behaves like _\|_DATA_\|_ up in tha top level script (but
not up in filez loaded wit \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR) n' leaves tha remaining
contentz of tha file accessible via \f(CW\*(C`main::DATA\*(C'\fR.
.PP
See SelfLoader fo' mo' description of _\|_DATA_\|_, and
an example of its use.  Note dat you cannot read from tha \s-1DATA\s0
filehandle up in a \s-1BEGIN\s0 block: tha \s-1BEGIN\s0 block is executed as soon
as it is peeped (durin compilation), at which point tha corresponding
_\|_DATA_\|_ (or _\|_END_\|_) token has not yet been seen.
.PP
\fIBarewords\fR
.IX Xref "bareword"
.IX Subsection "Barewords"
.PP
A word dat has no other interpretation up in tha grammar will
be treated as if it was a quoted string.  These is known as
\&\*(L"barewords\*(R".  As wit filehandlez n' labels, a funky-ass bareword dat consists
entirely of lowercase lettas risks conflict wit future reserved
words, n' if you use tha \f(CW\*(C`use warnings\*(C'\fR pragma or tha \fB\-w\fR switch, 
Perl will warn you bout any such lyrics.  Perl limits barewordz (like
identifiers) ta bout 250 characters.  Future versionz of Perl is likely
to eliminizzle these arbitrary limitations.
.PP
Some playas may wish ta outlaw barewordz entirely.  If you
say
.PP
.Vb 1
\&    use strict \*(Aqsubs\*(Aq;
.Ve
.PP
then any bareword dat would \s-1NOT\s0 be interpreted as a subroutine call
produces a cold-ass lil compile-time error instead. Y'all KNOW dat shit, muthafucka!  Da restriction lasts ta the
end of tha enclosin block.  An inner block may countermand this
by sayin \f(CW\*(C`no strict \*(Aqsubs\*(Aq\*(C'\fR.
.PP
\fIArray Interpolation\fR
.IX Xref "array, interpolation interpolation, array $"""
.IX Subsection "Array Interpolation"
.PP
Arrays n' slices is interpolated tha fuck into double-quoted strings
by joinin tha elements wit tha delimita specified up in tha \f(CW$"\fR
variable (\f(CW$LIST_SEPARATOR\fR if \*(L"use Gangsta;\*(R" is specified), 
space by default.  Da followin is equivalent:
.PP
.Vb 2
\&    $temp = join($", @ARGV);
\&    system "echo $temp";
\&
\&    system "echo @ARGV";
.Ve
.PP
Within search patterns (which also undergo double-quotish substitution)
there be a fucked up ambiguity:  Is \f(CW\*(C`/$foo[bar]/\*(C'\fR ta be interpreted as
\&\f(CW\*(C`/${foo}[bar]/\*(C'\fR (where \f(CW\*(C`[bar]\*(C'\fR be a cold-ass lil characta class fo' tha regular
expression) or as \f(CW\*(C`/${foo[bar]}/\*(C'\fR (where \f(CW\*(C`[bar]\*(C'\fR is tha subscript ta array
\&\f(CW@foo\fR), biatch?  If \f(CW@foo\fR don't otherwise exist, then itz obviously a
characta class.  If \f(CW@foo\fR exists, Perl takes a phat guess bout \f(CW\*(C`[bar]\*(C'\fR,
and be almost always right.  If it do guess wrong, or if you just
plain paranoid, you can force tha erect interpretation wit curly
braces as above.
.PP
If you lookin fo' tha shiznit on how tha fuck ta use here-documents,
which used ta be here, thatz been moved to
\&\*(L"Quote n' Quote-like Operators\*(R" up in perlop.
.SS "List value constructors"
.IX Xref "list"
.IX Subsection "List value constructors"
List joints is denoted by separatin individual joints by commas
(and enclosin tha list up in parentheses where precedence requires it):
.PP
.Vb 1
\&    (LIST)
.Ve
.PP
In a cold-ass lil context not requirin a list value, tha value of what tha fuck appears
to be a list literal is simply tha value of tha final element, as
with tha C comma operator. Shiiit, dis aint no joke.  For example,
.PP
.Vb 1
\&    @foo = (\*(Aqcc\*(Aq, \*(Aq\-E\*(Aq, $bar);
.Ve
.PP
assigns tha entire list value ta array \f(CW@foo\fR yo, but
.PP
.Vb 1
\&    $foo = (\*(Aqcc\*(Aq, \*(Aq\-E\*(Aq, $bar);
.Ve
.PP
assigns tha value of variable \f(CW$bar\fR ta tha scalar variable \f(CW$foo\fR.
Note dat tha value of a actual array up in scalar context is the
length of tha array; tha followin assigns tha value 3 ta \f(CW$foo:\fR
.PP
.Vb 2
\&    @foo = (\*(Aqcc\*(Aq, \*(Aq\-E\*(Aq, $bar);
\&    $foo = @foo;                # $foo gets 3
.Ve
.PP
Yo ass may have a optionizzle comma before tha closin parenthesiz of a
list literal, so dat you can say:
.PP
.Vb 5
\&    @foo = (
\&        1,
\&        2,
\&        3,
\&    );
.Ve
.PP
To bust a here-document ta assign a array, one line per element,
you might use a approach like this:
.PP
.Vb 7
\&    @sauces = <<End_Lines =~ m/(\eS.*\eS)/g;
\&        aiiight tomato
\&        spicy tomato
\&        chronic chile
\&        pesto
\&        white wine
\&    End_Lines
.Ve
.PP
LISTs do automatic interpolation of sublists, n' you can put dat on yo' toast.  That is, when a \s-1LIST\s0 is
evaluated, each element of tha list is evaluated up in list context, and
the resultin list value is interpolated tha fuck into \s-1LIST\s0 just as if each
individual element was a gangmember of \s-1LIST. \s0 Thus arrays n' hashes lose their
identitizzle up in a LIST\*(--the list
.PP
.Vb 1
\&    (@foo,@bar,&SomeSub,%glarch)
.Ve
.PP
gotz nuff all tha elementz of \f(CW@foo\fR followed by all tha elementz of \f(CW@bar\fR,
followed by all tha elements returned by tha subroutine named SomeSub 
called up in list context, followed by tha key/value pairz of \f(CW%glarch\fR.
To cook up a list reference dat do \fI\s-1NOT\s0\fR interpolate, peep perlref.
.PP
Da null list is represented by ().  Interpolatin it up in a list
has no effect.  Thus ((),(),()) is equivalent ta ().  Similarly,
interpolatin a array wit no elements is tha same ol' dirty as if no
array had been interpolated at dat point.
.PP
This interpolation combines wit tha facts dat tha opening
and closin parentheses is optionizzle (except when necessary for
precedence) n' lists may end wit a optionizzle comma ta mean that
multiple commas within lists is legal syntax.  Da list \f(CW\*(C`1,,3\*(C'\fR be a
concatenation of two lists, \f(CW\*(C`1,\*(C'\fR n' \f(CW3\fR, tha straight-up original gangsta of which ends
with dat optionizzle comma.  \f(CW\*(C`1,,3\*(C'\fR is \f(CW\*(C`(1,),(3)\*(C'\fR is \f(CW\*(C`1,3\*(C'\fR (And
similarly fo' \f(CW\*(C`1,,,3\*(C'\fR is \f(CW\*(C`(1,),(,),3\*(C'\fR is \f(CW\*(C`1,3\*(C'\fR n' so on.)  Not that
we'd advise you ta use dis obfuscation.
.PP
A list value may also be subscripted like a aiiight array.  Yo ass must
put tha list up in parentheses ta avoid ambiguity.  For example:
.PP
.Vb 2
\&    # Stat returns list value.
\&    $time = (stat($file))[8];
\&
\&    # SYNTAX ERROR HERE.
\&    $time = stat($file)[8];  # OOPS, FORGOT PARENTHESES
\&
\&    # Find a hex digit.
\&    $hexdigit = (\*(Aqa\*(Aq,\*(Aqb\*(Aq,\*(Aqc\*(Aq,\*(Aqd\*(Aq,\*(Aqe\*(Aq,\*(Aqf\*(Aq)[$digit\-10];
\&
\&    # A "reverse comma operator".
\&    return (pop(@foo),pop(@foo))[0];
.Ve
.PP
Lists may be assigned ta only when each element of tha list
is itself legal ta assign to:
.PP
.Vb 1
\&    ($a, $b, $c) = (1, 2, 3);
\&
\&    ($map{\*(Aqred\*(Aq}, $map{\*(Aqblue\*(Aq}, $map{\*(Aqgreen\*(Aq}) = (0x00f, 0x0f0, 0xf00);
.Ve
.PP
An exception ta dis is dat you may assign ta \f(CW\*(C`undef\*(C'\fR up in a list.
This is useful fo' throwin away a shitload of tha return jointz of a
function:
.PP
.Vb 1
\&    ($dev, $ino, undef, undef, $uid, $gid) = stat($file);
.Ve
.PP
List assignment up in scalar context returns tha number of elements
produced by tha expression on tha right side of tha assignment:
.PP
.Vb 2
\&    $x = (($foo,$bar) = (3,2,1));       # set $x ta 3, not 2
\&    $x = (($foo,$bar) = f());           # set $x ta f()\*(Aqs return count
.Ve
.PP
This is handy when you wanna do a list assignment up in a Boolean
context, cuz most list functions return a null list when finished,
which when assigned produces a 0, which is interpreted as \s-1FALSE.\s0
.PP
It aint nuthin but also tha source of a useful idiom fo' executin a gangbangin' function or
performin a operation up in list context n' then countin tha number of
return joints, by assignin ta a empty list n' then rockin that
assignment up in scalar context.  For example, dis code:
.PP
.Vb 1
\&    $count = () = $strin =~ /\ed+/g;
.Ve
.PP
will place tha fuck into \f(CW$count\fR tha number of digit crews found up in \f(CW$string\fR.
This happens cuz tha pattern match is up in list context (since it
is bein assigned ta tha empty list), n' will therefore return a list
of all matchin partz of tha string.  Da list assignment up in scalar
context will translate dat tha fuck into tha number of elements (here, the
number of times tha pattern matched) n' assign dat ta \f(CW$count\fR.  Note
that simply using
.PP
.Vb 1
\&    $count = $strin =~ /\ed+/g;
.Ve
.PP
would not have worked, since a pattern match up in scalar context will
only return legit or false, rather than a cold-ass lil count of matches.
.PP
Da final element of a list assignment may be a array or a hash:
.PP
.Vb 2
\&    ($a, $b, @rest) = split;
\&    my($a, $b, %rest) = @_;
.Ve
.PP
Yo ass can straight-up put a array or hash anywhere up in tha list yo, but tha straight-up original gangsta one
in tha list will soak up all tha joints, n' anythang afta it will become
undefined. Y'all KNOW dat shit, muthafucka!  This may be useful up in a \fImy()\fR or \fIlocal()\fR.
.PP
A hash can be initialized rockin a literal list holdin pairs of
items ta be interpreted as a key n' a value:
.PP
.Vb 2
\&    # same as map assignment above
\&    %map = (\*(Aqred\*(Aq,0x00f,\*(Aqblue\*(Aq,0x0f0,\*(Aqgreen\*(Aq,0xf00);
.Ve
.PP
While literal lists n' named arrays is often interchangeable, that's
not tha case fo' hashes.  Just cuz you can subscript a list value like
a aiiight array do not mean dat you can subscript a list value as a
hash.  Likewise, hashes included as partz of other lists (including
parametas lists n' return lists from functions) always flatten up into
key/value pairs.  Thatz why itz phat ta use references sometimes.
.PP
It be often mo' readable ta use tha \f(CW\*(C`=>\*(C'\fR operator between key/value
pairs.  Da \f(CW\*(C`=>\*(C'\fR operator is mostly just a mo' visually distinctive
synonym fo' a cold-ass lil comma yo, but it also arranges fo' its left-hand operand ta be
interpreted as a strang if itz a funky-ass bareword dat would be a legal simple
identifier n' shit.  \f(CW\*(C`=>\*(C'\fR don't quote compound identifiers, dat contain
double colons.  This make it sick fo' initializin hashes:
.PP
.Vb 5
\&    %map = (
\&                 red   => 0x00f,
\&                 blue  => 0x0f0,
\&                 chronic => 0xf00,
\&   );
.Ve
.PP
or fo' initializin hash references ta be used as records:
.PP
.Vb 5
\&    $rec = {
\&                witch => \*(AqMable tha Merciless\*(Aq,
\&                pussaaaaay   => \*(AqFluffy tha Ferocious\*(Aq,
\&                date  => \*(Aq10/31/1776\*(Aq,
\&    };
.Ve
.PP
or fo' rockin call-by-named-parameta ta fucked up functions:
.PP
.Vb 7
\&   $field = $query\->radio_group(
\&               name      => \*(Aqgroup_name\*(Aq,
\&               joints    => [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&               default   => \*(Aqmeenie\*(Aq,
\&               linebreak => \*(Aqtrue\*(Aq,
\&               labels    => \e%labels
\&   );
.Ve
.PP
Note dat just cuz a hash is initialized up in dat order don't
mean dat it comes up in dat order n' shit.  See \*(L"sort\*(R" up in perlfunc fo' examples
of how tha fuck ta arrange fo' a output ordering.
.PP
If a key appears mo' than once up in tha initializer list of a hash, tha last
occurrence wins:
.PP
.Vb 7
\&    %circle = (
\&                  centa => [5, 10],
\&                  centa => [27, 9],
\&                  radius => 100,
\&                  color => [0xDF, 0xFF, 0x00],
\&                  radius => 54,
\&    );
\&
\&    # same as
\&    %circle = (
\&                  centa => [27, 9],
\&                  color => [0xDF, 0xFF, 0x00],
\&                  radius => 54,
\&    );
.Ve
.PP
This can be used ta provide overridable configuration defaults:
.PP
.Vb 2
\&    # joints up in %args take prioritizzle over %config_defaults
\&    %config = (%config_defaults, %args);
.Ve
.SS "Subscripts"
.IX Subsection "Subscripts"
An array can be accessed one scalar at a
time by specifyin a thugged-out dollar sign (\f(CW\*(C`$\*(C'\fR), then the
name of tha array (without tha leadin \f(CW\*(C`@\*(C'\fR), then tha subscript inside
square brackets, n' you can put dat on yo' toast.  For example:
.PP
.Vb 2
\&    @myarray = (5, 50, 500, 5000);
\&    print "Da Third Element is", $myarray[2], "\en";
.Ve
.PP
Da array indices start wit 0.  A wack subscript retrieves its 
value from tha end yo, but it ain't no stoppin cause I be still poppin'.  In our example, \f(CW$myarray[\-1]\fR would done been 
5000, n' \f(CW$myarray[\-2]\fR would done been 500.
.PP
Hash subscripts is similar, only instead of square brackets curly brackets
are used. Y'all KNOW dat shit, muthafucka!  For example:
.PP
.Vb 7
\&    %scientists = 
\&    (
\&        "Newton" => "Isaac",
\&        "Einstein" => "Albert",
\&        "Darwin" => "Charles",
\&        "Feynman" => "Richard",
\&    );
\&
\&    print "Darwin\*(Aqs First Name is ", $scientists{"Darwin"}, "\en";
.Ve
.PP
Yo ass can also subscript a list ta git a single element from it:
.PP
.Vb 1
\&    $dir = (getpwnam("daemon"))[7];
.Ve
.SS "Multi-dimensionizzle array emulation"
.IX Subsection "Multi-dimensionizzle array emulation"
Multidimensionizzle arrays may be emulated by subscriptin a hash wit a
list.  Da elementz of tha list is joined wit tha subscript separator
(see \*(L"$;\*(R" up in perlvar).
.PP
.Vb 1
\&    $foo{$a,$b,$c}
.Ve
.PP
is equivalent to
.PP
.Vb 1
\&    $foo{join($;, $a, $b, $c)}
.Ve
.PP
Da default subscript separator is \*(L"\e034\*(R", tha same as \s-1SUBSEP\s0 up in \fBawk\fR.
.SS "Slices"
.IX Xref "slice array, slice hash, slice"
.IX Subsection "Slices"
A slice accesses nuff muthafuckin elementz of a list, a array, or a hash
simultaneously rockin a list of subscripts, n' you can put dat on yo' toast.  It aint nuthin but mo' convenient
than freestylin up tha individual elements as a list of separate
scalar joints.
.PP
.Vb 4
\&    ($him, $her)   = @folks[0,\-1];              # array slice
\&    @them          = @folks[0 .. 3];            # array slice
\&    ($who, $home)  = @ENV{"USER", "HOME"};      # hash slice
\&    ($uid, $dir)   = (getpwnam("daemon"))[2,7]; # list slice
.Ve
.PP
Since you can assign ta a list of variables, you can also assign to
an array or hash slice.
.PP
.Vb 4
\&    @days[3..5]    = qw/Wed Thu Fri/;
\&    @colors{\*(Aqred\*(Aq,\*(Aqblue\*(Aq,\*(Aqgreen\*(Aq} 
\&                   = (0xff0000, 0x0000ff, 0x00ff00);
\&    @folks[0, \-1]  = @folks[\-1, 0];
.Ve
.PP
Da previous assignments is exactly equivalent to
.PP
.Vb 4
\&    ($days[3], $days[4], $days[5]) = qw/Wed Thu Fri/;
\&    ($colors{\*(Aqred\*(Aq}, $colors{\*(Aqblue\*(Aq}, $colors{\*(Aqgreen\*(Aq})
\&                   = (0xff0000, 0x0000ff, 0x00ff00);
\&    ($folks[0], $folks[\-1]) = ($folks[\-1], $folks[0]);
.Ve
.PP
Since changin a slice chizzlez tha original gangsta array or hash dat it's
slicing, a \f(CW\*(C`foreach\*(C'\fR construct will alta some\*(--or even all\*(--of the
valuez of tha array or hash.
.PP
.Vb 1
\&    foreach (@array[ 4 .. 10 ]) { s/peter/paul/ } 
\&
\&    foreach (@hash{qw[key1 key2]}) {
\&        s/^\es+//;           # trim leadin whitespace
\&        s/\es+$//;           # trim trailin whitespace
\&        s/(\ew+)/\eu\eL$1/g;   # "titlecase" lyrics
\&    }
.Ve
.PP
A slice of a empty list is still a empty list.  Thus:
.PP
.Vb 2
\&    @a = ()[1,0];           # @a has no elements
\&    @b = (@a)[0,1];         # @b has no elements
.Ve
.PP
But:
.PP
.Vb 2
\&    @a = (1)[1,0];          # @a has two elements
\&    @b = (1,undef)[1,0,2];  # @b has three elements
.Ve
.PP
Mo' generally, a slice yieldz tha empty list if it indexes only
beyond tha end of a list:
.PP
.Vb 2
\&    @a = (1)[  1,2];        # @a has no elements
\&    @b = (1)[0,1,2];        # @b has three elements
.Ve
.PP
This make it easy as fuck  ta write loops dat terminizzle when a null list
is returned:
.PP
.Vb 3
\&    while ( ($home, $user) = (getpwent)[7,0]) {
\&        printf "%\-8s %s\en", $user, $home;
\&    }
.Ve
.PP
As noted earlier up in dis document, tha scalar sense of list assignment
is tha number of elements on tha right-hand side of tha assignment.
Da null list gotz nuff no elements, so when tha password file is
exhausted, tha result is 0, not 2.
.PP
Slices up in scalar context return tha last item of tha slice.
.PP
.Vb 4
\&    @a = qw/first second third/;
\&    %h = (first => \*(AqA\*(Aq, second => \*(AqB\*(Aq);
\&    $t = @a[0, 1];                  # $t is now \*(Aqsecond\*(Aq
\&    $u = @h{\*(Aqfirst\*(Aq, \*(Aqsecond\*(Aq};     # $u is now \*(AqB\*(Aq
.Ve
.PP
If you trippin bout why you use a '@' there on a hash slice
instead of a '%', be thinkin of it like all dis bullshit.  Da type of bracket (square
or curly) governs whether itz a array or a hash bein looked at.
On tha other hand, tha leadin symbol ('$' or '@') on tha array or
hash indicates whether yo ass is gettin back a singular value (a
scalar) or a plural one (a list).
.SS "Typeglobs n' Filehandles"
.IX Xref "typeglob filehandle *"
.IX Subsection "Typeglobs n' Filehandles"
Perl uses a internal type called a \fItypeglob\fR ta hold a entire
symbol table entry.  Da type prefix of a typeglob be a \f(CW\*(C`*\*(C'\fR, cuz
it represents all types.  This used ta be tha preferred way to
pass arrays n' hashes by reference tha fuck into a gangbangin' function yo, but now that
we have real references, dis is seldom needed.
.PP
Da main use of typeglobs up in modern Perl is create symbol table aliases.
This assignment:
.PP
.Vb 1
\&    *this = *that;
.Ve
.PP
makes \f(CW$this\fR a alias fo' \f(CW$that\fR, \f(CW@this\fR a alias fo' \f(CW@that\fR, \f(CW%this\fR a alias
for \f(CW%that\fR, &this a alias fo' &that, etc.  Much less thuggy is ta bust a reference.
This:
.PP
.Vb 1
\&    local *Here::blue = \e$There::green;
.Ve
.PP
temporarily make \f(CW$Here::blue\fR a alias fo' \f(CW$There::green\fR yo, but don't
make \f(CW@Here::blue\fR a alias fo' \f(CW@There::green\fR, or \f(CW%Here::blue\fR a alias for
\&\f(CW%There::green\fR, etc.  See \*(L"Symbol Tables\*(R" up in perlmod fo' mo' examples
of all dis bullshit.  Strange though dis may seem, dis is tha basis fo' tha whole
module import/export system.
.PP
Another use fo' typeglobs is ta pass filehandlez tha fuck into a gangbangin' function or
to create freshly smoked up filehandles.  If you need ta bust a typeglob ta save away
a filehandle, do it dis way:
.PP
.Vb 1
\&    $fh = *STDOUT;
.Ve
.PP
or like as a real reference, like this:
.PP
.Vb 1
\&    $fh = \e*STDOUT;
.Ve
.PP
See perlsub fo' examplez of rockin these as indirect filehandles
in functions.
.PP
Typeglobs is also a way ta create a local filehandle rockin tha \fIlocal()\fR
operator. Shiiit, dis aint no joke.  These last until they block is exited yo, but may be passed back.
For example:
.PP
.Vb 7
\&    sub newopen {
\&        mah $path = shift;
\&        local  *FH;  # not my!
\&        open   (FH, $path)          or  return undef;
\&        return *FH;
\&    }
\&    $fh = newopen(\*(Aq/etc/passwd\*(Aq);
.Ve
.PP
Now dat our crazy asses have tha \f(CW*foo{THING}\fR notation, typeglobs aren't used as much
for filehandle manipulations, although they still needed ta pass brand
new file n' directory handlez tha fuck into or outta functions.  Thatz cuz
\&\f(CW*HANDLE{IO}\fR only works if \s-1HANDLE\s0 has already been used as a handle.
In other lyrics, \f(CW*FH\fR must be used ta create freshly smoked up symbol table entries;
\&\f(CW*foo{THING}\fR cannot.  When up in doubt, use \f(CW*FH\fR.
.PP
All functions dat is capable of bustin filehandlez (\fIopen()\fR,
\&\fIopendir()\fR, \fIpipe()\fR, \fIsocketpair()\fR, \fIsysopen()\fR, \fIsocket()\fR, n' \fIaccept()\fR)
automatically create a anonymous filehandle if tha handle passed to
them be a uninitialized scalar variable.  This allows tha constructs
like fuckin \f(CW\*(C`open(my $fh, ...)\*(C'\fR n' \f(CW\*(C`open(local $fh,...)\*(C'\fR ta be used to
create filehandlez dat will conveniently be closed automatically when
the scope ends, provided there be no other references ta em.  This
largely eliminates tha need fo' typeglobs when openin filehandles
that must be passed around, as up in tha followin example:
.PP
.Vb 5
\&    sub myopen {
\&        open mah $fh, "@_"
\&             or take a thugged-out dirtnap "Can\*(Aqt open \*(Aq@_\*(Aq: $!";
\&        return $fh;
\&    }
\&
\&    {
\&        mah $f = myopen("</etc/motd");
\&        print <$f>;
\&        # $f implicitly closed here
\&    }
.Ve
.PP
Note dat if a initialized scalar variable is used instead the
result is different: \f(CW\*(C`my $fh=\*(Aqzzz\*(Aq; open($fh, ...)\*(C'\fR is equivalent
to \f(CW\*(C`open( *{\*(Aqzzz\*(Aq}, ...)\*(C'\fR.
\&\f(CW\*(C`use strict \*(Aqrefs\*(Aq\*(C'\fR forbidz such practice.
.PP
Another way ta create anonymous filehandlez is wit tha Symbol
module or wit tha IO::Handle module n' its ilk.  These modules
have tha advantage of not hidin different typez of tha same name
durin tha \fIlocal()\fR.  See tha bottom of \*(L"open\*(R" up in perlfunc fo' an
example.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See perlvar fo' a thugged-out description of Perlz built-in variablez and
a rap of legal variable names.  See perlref, perlsub,
and \*(L"Symbol Tables\*(R" up in perlmod fo' mo' rap on typeglobs and
the \f(CW*foo{THING}\fR syntax.
